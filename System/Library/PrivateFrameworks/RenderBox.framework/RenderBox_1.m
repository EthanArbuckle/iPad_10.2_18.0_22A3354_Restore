_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::encode(RB::DisplayList::Item *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)a1 + 56);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)a1 + 104);
  v4 = (float64x2_t *)*((_QWORD *)a1 + 6);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode(a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(this, (uint64_t)(a1 + 13));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 200 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xC8uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 200;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C225490;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 320;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(v15, *a6, a2, a3, a4, *a5, *a7);
  *result = &off_24C2255A8;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(uint64_t a1, float _S0, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7)
{
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a7 & 0x3F;
  *(_QWORD *)a1 = off_24C226D48;
  *(_QWORD *)(a1 + 48) = a6;
  *(_QWORD *)(a1 + 56) = off_24C229900;
  *(_QWORD *)(a1 + 64) = *(id *)(a4 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a4 + 16);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a4 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a4 + 33);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a4 + 35);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a4 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a4 + 40);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 112), a5);
  return a1;
}

void sub_209B3D4EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::~GenericItem(uint64_t a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)a1 = off_24C226D48;
  v2 = (const void **)(a1 + 120);
  v3 = *(const void ***)(a1 + 216);
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (*(_QWORD *)(a1 + 224))
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *(_QWORD *)(a1 + 224));
    v3 = *(const void ***)(a1 + 216);
  }
  if (v3)
    free(v3);
  v6 = *(unsigned int **)(a1 + 112);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::~GenericItem(uint64_t a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *(_QWORD *)a1 = off_24C226D48;
  v2 = (const void **)(a1 + 120);
  v3 = *(const void ***)(a1 + 216);
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (*(_QWORD *)(a1 + 224))
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *(_QWORD *)(a1 + 224));
    v3 = *(const void ***)(a1 + 216);
  }
  if (v3)
    free(v3);
  v6 = *(unsigned int **)(a1 + 112);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::type_id()
{
  return 16793601;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::copy(__n128 *a1, uint64_t a2, char a3)
{
  RB::Heap *v4;
  unsigned __int16 v5;
  BOOL v6;
  __int16 v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v5 = a1[2].n128_u16[7];
  if (*(_BYTE *)(a2 + 272))
    v6 = (a3 & 2 | v5 & 0x1000) == 0;
  else
    v6 = 0;
  if (v6)
    v7 = 4096;
  else
    v7 = 0;
  v10 = v5 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v4, (uint64_t)v4, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v7;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 92) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare(uint64_t a1, uint64_t **a2)
{
  if (*(_BYTE *)(a1 + 88) == 1)
    RBStrokeRef::prepare((void **)(a1 + 64), a2);
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), (const RB::RenderParams *)a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, __int32 a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  __n128 (***v13)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  RB::Fill::Custom *v14;
  _OWORD v20[3];
  _BYTE v21[40];

  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  v20[2] = _Q0;
  v13 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  v14 = (RB::Fill::Custom *)(a1 + 112);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke((uint64_t **)a4, (uint64_t (**)(_QWORD, _QWORD *))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), v18);
  RB::Bounds::Bounds(&v21, v16, v17);
  RBStrokeRef::clip(a1 + 112);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 16793601)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
        && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
        && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
        && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
        && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
        && *(float *)(a1 + 96) == *(float *)(a4 + 96))
      {
        result = (unint64_t *)RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a4 + 64));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 112), (const RB::Fill::Custom *)(a4 + 112));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  double v14;
  double v15;
  double v16;
  int8x16_t v17;
  _OWORD v19[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v19[0] = v10;
  v19[1] = v11;
  v19[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v19);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 112), *(float32_t *)(a2 + 16), (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16), v13, v14, v15, v16, v17);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Custom>(this, (RB::Fill::Custom *)(a1 + 14));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 320 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x140uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 320;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>::GenericItem1(v15, _S0, a2, a3, a4, *a5, *a7);
  *result = &off_24C2255A8;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::type_id()
{
  return 4102;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t v11[2];
  uint64_t v12;
  uint64_t v13;

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_209BD5290;
  v11[1] = (float64x2_t)xmmword_209BD52A0;
  v12 = 0;
  v13 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 56), v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::map_dod(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 56), v7);
  RB::DisplayList::affine_style_dod(a2, a3, v7, *(const RB::AffineTransform **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint32x2_t v3;

  if (a3
    && *(double *)(a1 + 56) == *(double *)(a3 + 56)
    && (v3 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 64), *(float32x2_t *)(a3 + 64)),
        (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
  {
    return 4;
  }
  else
  {
    return 1;
  }
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 v6;
  float32x2_t *v7;
  float32x2_t *v8;
  float32x2_t *v9;
  const RB::GeometryStyle::Rotation *v10;

  v6 = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v8 = v7;
  v9 = v7 + 7;
  if (a3)
    v10 = (const RB::GeometryStyle::Rotation *)(a3 + 56);
  else
    v10 = 0;
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::GeometryStyle::Rotation::mix(v9, v10, v6.n128_f64[0]);
  return v8;
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Rotation::encode((RB::GeometryStyle::Rotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Rotation::print((RB::GeometryStyle::Rotation *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 72;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228680;
  result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::type_id()
{
  return 8198;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t v11[2];
  uint64_t v12;
  uint64_t v13;

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_209BD5290;
  v11[1] = (float64x2_t)xmmword_209BD52A0;
  v12 = 0;
  v13 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::map_dod(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Scale::set_affine_transform((float32x2_t *)(a1 + 56), v7);
  RB::DisplayList::affine_style_dod(a2, a3, v7, *(const RB::AffineTransform **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::can_mix(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  uint32x2_t v3;

  if (a3
    && (v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(a1[8], a3[8]), (int8x8_t)vceq_f32(a1[7], a3[7])),
        (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
  {
    return 4;
  }
  else
  {
    return 1;
  }
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  float32x2_t *v6;
  float32x2_t *v7;
  float32x2_t *v8;
  float32x2_t *v9;

  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 7;
  if (a3)
    v9 = a3 + 7;
  else
    v9 = 0;
  RB::GeometryStyle::Scale::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Scale::encode((RB::GeometryStyle::Scale *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Scale::print((RB::GeometryStyle::Scale *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2241D8;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::type_id()
{
  return 16390;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t v11[2];
  uint64_t v12;
  uint64_t v13;

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v11[0] = (float64x2_t)xmmword_209BD5290;
  v11[1] = (float64x2_t)xmmword_209BD52A0;
  v12 = 0;
  v13 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v11);
  return RB::DisplayList::Builder::affine_style_draw(a2, a3, a4, a5, v11, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::map_dod(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Translation::set_affine_transform((float32x2_t *)(a1 + 56), (RB::AffineTransform *)v7);
  RB::DisplayList::affine_style_dod(a2, a3, v7, *(const RB::AffineTransform **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::can_mix(float32x2_t *a1, uint64_t a2, float32x2_t *a3)
{
  uint32x2_t v3;

  if (a3 && (v3 = (uint32x2_t)vceq_f32(a1[7], a3[7]), (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
    return 4;
  else
    return 1;
}

float32x2_t *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::mix(uint64_t a1, uint64_t a2, float32x2_t *a3, uint64_t a4)
{
  float32x2_t *v6;
  float32x2_t *v7;
  float32x2_t *v8;
  float32x2_t *v9;

  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 7;
  if (a3)
    v9 = a3 + 7;
  else
    v9 = 0;
  RB::GeometryStyle::Translation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Translation::encode((RB::GeometryStyle::Translation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Translation::print((RB::GeometryStyle::Translation *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 128 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 128;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2285F8;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  v8 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 96) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 112) = v8;
  *(__n128 *)(v5 + 64) = result;
  *(_OWORD *)(v5 + 80) = v7;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::type_id()
{
  return 12294;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::draw(uint64_t a1, size_t **a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float32x4_t v11[2];
  int v12;

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v12 = 1065353216;
  v11[0] = (float32x4_t)xmmword_209BD5460;
  v11[1] = (float32x4_t)xmmword_209BD5460;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v11);
  return RB::DisplayList::Builder::projection_style_draw(a2, a3, a4, a5, (const RB::ProjectionMatrix *)v11, *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

float32x2_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::map_roi(uint64_t a1, float32x2_t *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float32x4_t v8[2];
  int v9;

  v9 = 1065353216;
  v8[0] = (float32x4_t)xmmword_209BD5460;
  v8[1] = (float32x4_t)xmmword_209BD5460;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v8);
  return RB::DisplayList::projection_style_roi(a2, a3, (RB::AffineTransform *)v8, *(float64x2_t **)(a1 + 16), v6);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::map_dod(uint64_t a1, float32x2_t *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float32x4_t v7[2];
  int v8;

  v8 = 1065353216;
  v7[0] = (float32x4_t)xmmword_209BD5460;
  v7[1] = (float32x4_t)xmmword_209BD5460;
  RB::GeometryStyle::Rotation3D::set_projection_matrix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v7);
  RB::DisplayList::projection_style_dod(a2, a3, (RB::AffineTransform *)v7, *(float64x2_t **)(a1 + 16), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  const RB::GeometryStyle::Rotation3D *v6;

  if (a3 && RB::GeometryStyle::Rotation3D::operator==(a1 + 64, a3 + 64))
    return 4;
  if (a3)
    v6 = (const RB::GeometryStyle::Rotation3D *)(a3 + 64);
  else
    v6 = 0;
  return RB::GeometryStyle::Rotation3D::can_mix((RB::GeometryStyle::Rotation3D *)(a1 + 64), v6);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::mix(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  __n128 v6;
  uint64_t v7;
  uint64_t v8;
  RB::GeometryStyle::Rotation3D *v9;
  float32x4_t *v10;

  v6 = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 64);
  v8 = v7;
  v9 = (RB::GeometryStyle::Rotation3D *)(v7 + 64);
  if (a3)
    v10 = a3 + 4;
  else
    v10 = 0;
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::GeometryStyle::Rotation3D::mix(v9, v10, v6.n128_f64[0]);
  return v8;
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Rotation3D::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Rotation3D::print((RB::GeometryStyle::Rotation3D *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 112;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224260;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 96) = v7;
  *(__n128 *)(v5 + 64) = result;
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::type_id()
{
  return 20486;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::draw(uint64_t a1, RB::DisplayList::Builder *this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t v5;
  float64x2_t v7[3];

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v5 = *(float64x2_t *)(a1 + 80);
  v7[0] = *(float64x2_t *)(a1 + 64);
  v7[1] = v5;
  v7[2] = *(float64x2_t *)(a1 + 96);
  return RB::DisplayList::Builder::affine_style_draw(this, a3, a4, a5, v7, *(const RB::AffineTransform **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::map_roi(uint64_t a1, RB::DisplayList *this, float64x2_t *a3, uint64_t a4, const RB::AffineTransform *a5)
{
  float64x2_t v5;
  float64x2_t v6[3];

  v5 = *(float64x2_t *)(a1 + 80);
  v6[0] = *(float64x2_t *)(a1 + 64);
  v6[1] = v5;
  v6[2] = *(float64x2_t *)(a1 + 96);
  RB::DisplayList::affine_style_roi(this, a3, v6, *(int8x16_t **)(a1 + 16), a5);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::map_dod(uint64_t a1, RB::DisplayList *this, float64x2_t *a3, uint64_t a4, const RB::AffineTransform *a5)
{
  float64x2_t v5;
  float64x2_t v6[3];

  v5 = *(float64x2_t *)(a1 + 80);
  v6[0] = *(float64x2_t *)(a1 + 64);
  v6[1] = v5;
  v6[2] = *(float64x2_t *)(a1 + 96);
  RB::DisplayList::affine_style_dod(this, a3, v6, *(const RB::AffineTransform **)(a1 + 16), a5);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::can_mix(float64x2_t *a1, uint64_t a2, float64x2_t *a3)
{
  int64x2_t v3;
  RB *v4;
  const RB::AffineTransform *v5;

  if (a3)
  {
    v3 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a1[5], a3[5]), (int8x16_t)vceqq_f64(a1[4], a3[4])), (int8x16_t)vceqq_f64(a1[6], a3[6]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v3, 1), (int8x16_t)v3).u64[0] & 0x8000000000000000) != 0)
      return 4;
  }
  v4 = (RB *)&a1[4];
  if (a3)
    v5 = (const RB::AffineTransform *)&a3[4];
  else
    v5 = 0;
  return RB::GeometryStyle::Affine::can_mix(v4, v5, (const RB::AffineTransform *)a3);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  const RB::AffineTransform *v6;
  uint64_t v7;
  uint64_t v8;
  CGAffineTransform *v9;
  uint64_t v10;

  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 64);
  v8 = v7;
  v9 = (CGAffineTransform *)(v7 + 64);
  if (a3)
    v10 = a3 + 64;
  else
    v10 = 0;
  RB::GeometryStyle::Affine::mix(v9, v10, v6, *(float *)(a2 + 16));
  return v8;
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Affine::encode((RB::GeometryStyle::Affine *)(a1 + 8), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Affine::print((RB::GeometryStyle::Affine *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  uint64_t v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 96;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224628;
  result = *(__n128 *)a2;
  *(_OWORD *)(v5 + 68) = *(_OWORD *)(a2 + 12);
  *(__n128 *)(v5 + 56) = result;
  v7 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(v5 + 88) = v7;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::MeshGradient>(__int128 **a1, uint64_t a2)
{
  __int128 *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Custom>(__int128 **a1, uint64_t a2)
{
  __int128 *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(_QWORD *)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 104 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 104;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2245A0;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 88) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::~FilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::type_id()
{
  return 4098;
}

double RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 56).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::draw(float16x4_t *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t *v10;
  const RB::DisplayList::ClipNode *v11;
  RB::DisplayList::LayerFilter *v12;
  RB::DisplayList::Item *result;

  if ((RB::ColorMatrix::is_identity(a1 + 8) & 1) != 0
    || (v10 = (float64x2_t *)a1[2],
        v11 = (const RB::DisplayList::ClipNode *)a1[3],
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)&a1[7]), result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11), (a4 = result) != 0))
  {
    *((float16x4_t *)a4 + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::can_mix(float16x4_t *a1, RB::DisplayList::Interpolator::Contents *a2, float16x4_t *a3)
{
  float16x4_t *v3;
  float16x4_t *v4;

  v3 = a1 + 7;
  if (a3)
    v4 = a3 + 7;
  else
    v4 = 0;
  return RB::Filter::ColorMatrix::can_mix(v3, a2, v4);
}

float16x4_t *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, uint64_t a3, const RB::DisplayList::CachedTransform *a4)
{
  float16x4_t *v7;
  float16x4_t *v8;
  float16x4_t *v9;
  const RB::Filter::ColorMatrix *v10;

  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 56);
  v8 = v7;
  v9 = v7 + 7;
  if (a3)
    v10 = (const RB::Filter::ColorMatrix *)(a3 + 56);
  else
    v10 = 0;
  RB::Filter::ColorMatrix::mix(v9, a2, v10, a4);
  return v8;
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::ColorMatrix::encode((RB::Filter::ColorMatrix *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::ColorMatrix::print((float16x4_t *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 80 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 80;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)v5 = &off_24C227A78;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 64) = v7;
  *(__n128 *)(v5 + 32) = result;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::~GenericFilter()
{
  JUMPOUT(0x20BD16544);
}

double RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

BOOL RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::append(uint64_t a1, int a2, float16x4_t *a3)
{
  return RB::Filter::ColorMatrix::append(a1 + 32, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::filter_data()
{
  return 1;
}

int32x2_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::dod(uint64_t a1, int32x2_t *a2)
{
  return RB::Filter::ColorMatrix::dod((RB::Filter::ColorMatrix *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

BOOL RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::can_discard_color(uint64_t a1, BOOL *a2)
{
  return RB::Filter::ColorMatrix::can_discard_color((RB::Filter::ColorMatrix *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::can_render_inline()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::render(float16x4_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  return RB::Filter::ColorMatrix::render(a1 + 4, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::render(float16x4_t *a1, RB::_anonymous_namespace_ **a2)
{
  return RB::Filter::ColorMatrix::render(a1 + 4, a2);
}

void RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>::print(float16x4_t *a1, std::string *a2)
{
  RB::Filter::ColorMatrix::print(a1 + 4, a2);
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 72;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228240;
  result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::type_id()
{
  return 4101;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::DisplayList::Item *result;
  _BYTE v13[40];

  RB::ColorStyle::ColorMultiply::set_color_matrix((RB::ColorStyle::ColorMultiply *)(a1 + 56), (RB::ColorMatrix *)v13, a6, a7);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ColorStyle::ColorMultiply::operator==(a1 + 56, a3 + 56))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 v6;
  int8x16_t v7;
  double v8;
  double v9;
  double v10;
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  RB::ColorStyle::ColorMultiply *v14;
  const RB::ColorStyle::ColorMultiply *v15;

  v6 = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v13 = v12;
  v14 = (RB::ColorStyle::ColorMultiply *)(v12 + 56);
  if (a3)
    v15 = (const RB::ColorStyle::ColorMultiply *)(a3 + 56);
  else
    v15 = 0;
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::ColorStyle::ColorMultiply::mix(v14, v15, (int8x16_t)v6, v7, v8, v9, v10, v11);
  return v13;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMultiply::encode((RB::ColorStyle::ColorMultiply *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorMultiply::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

BOOL RB::ColorStyle::ColorMultiply::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0;
  _ZF = !*(_BYTE *)(a1 + 13) || *(_BYTE *)(a2 + 13) == 0;
  if (!_ZF && *(unsigned __int8 *)(a1 + 12) != *(unsigned __int8 *)(a2 + 12))
    return 0;
  _H0 = *(_WORD *)(a1 + 4);
  _H1 = *(_WORD *)(a2 + 4);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 6);
  _H1 = *(_WORD *)(a2 + 6);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 8);
  _H1 = *(_WORD *)(a2 + 8);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 10);
  _H1 = *(_WORD *)(a2 + 10);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  return _S0 == _S1;
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 72;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2281B8;
  result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::type_id()
{
  return 8197;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::DisplayList::Item *result;
  int8x8_t v13[5];

  RB::ColorStyle::AlphaMultiply::set_color_matrix((RB::ColorStyle::AlphaMultiply *)(a1 + 56), v13, a6, a7);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::ColorStyle::AlphaMultiply::matches((RB::ColorStyle::AlphaMultiply *)(a1 + 56), a2, a3) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
    return 0;
  if (RB::ColorStyle::ColorMultiply::operator==(a1 + 56, a3 + 56))
    return 4;
  return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 v6;
  int8x16_t v7;
  double v8;
  double v9;
  double v10;
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  RB::ColorStyle::AlphaMultiply *v14;
  const RB::ColorStyle::AlphaMultiply *v15;

  v6 = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v13 = v12;
  v14 = (RB::ColorStyle::AlphaMultiply *)(v12 + 56);
  if (a3)
    v15 = (const RB::ColorStyle::AlphaMultiply *)(a3 + 56);
  else
    v15 = 0;
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::ColorStyle::AlphaMultiply::mix(v14, v15, (int8x16_t)v6, v7, v8, v9, v10, v11);
  return v13;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMultiply::encode((RB::ColorStyle::ColorMultiply *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::AlphaMultiply::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228130;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::type_id()
{
  return 12293;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Item *result;
  float32x2_t v11[5];

  RB::ColorMatrix::set_hue_rotate(v11, *(float *)(a1 + 60));
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 56;
  if (a3)
    v9 = a3 + 56;
  else
    v9 = 0;
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::HueRotation::encode((RB::ColorStyle::HueRotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::HueRotation::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228020;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::type_id()
{
  return 16389;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, double a6, double a7, double a8, double a9, double a10, float32x4_t a11, float32x4_t a12)
{
  RB::DisplayList::Item *result;
  float32x2_t v18[5];

  RB::ColorMatrix::set_saturate(v18, *(float *)(a1 + 60), a7, a8, a9, a10, a11, a12);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v18, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 56;
  if (a3)
    v9 = a3 + 56;
  else
    v9 = 0;
  RB::ColorStyle::Saturation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Saturation::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C227F98;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::type_id()
{
  return 20485;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, int16x4_t a6)
{
  RB::DisplayList::Item *result;
  __n64 v12[5];

  a6.i32[0] = *(_DWORD *)(a1 + 60);
  RB::ColorMatrix::set_brightness(v12, a6);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v12, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 56;
  if (a3)
    v9 = a3 + 56;
  else
    v9 = 0;
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Brightness::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2283D8;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::type_id()
{
  return 24581;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Item *result;
  __n64 v11[5];

  RB::ColorMatrix::set_contrast(v11, *(float *)(a1 + 60));
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 56;
  if (a3)
    v9 = a3 + 56;
  else
    v9 = 0;
  RB::ColorStyle::Saturation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::Saturation::encode((RB::ColorStyle::Saturation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::Contrast::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>(RB::Heap *this, _DWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228350;
  *(_DWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::type_id()
{
  return 28677;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_DWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Item *result;
  _BYTE v11[40];

  RB::ColorMatrix::set_luminance_to_alpha((RB::ColorMatrix *)v11);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v11, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!a3)
    return 0;
  if (*(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56))
    return 4;
  return 2;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_DWORD *)(a1 + 56));
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::LuminanceToAlpha::encode((RB::ColorStyle::LuminanceToAlpha *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::LuminanceToAlpha::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>(RB::Heap *this, _QWORD *a2)
{
  unint64_t v4;
  unint64_t v5;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  *(_QWORD *)(v5 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2280A8;
  *(_QWORD *)(v5 + 56) = *a2;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::type_id()
{
  return 36869;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)(a1 + 56));
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, double a6)
{
  RB::DisplayList::Item *result;
  __n64 v12[5];

  LODWORD(a6) = *(_DWORD *)(a1 + 60);
  RB::ColorMatrix::set_color_invert(v12, a6);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v12, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && *(_DWORD *)(a1 + 56) == *(_DWORD *)(a3 + 56) && *(float *)(a1 + 60) == *(float *)(a3 + 60))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (_QWORD *)(a1 + 56));
  v7 = v6;
  v8 = v6 + 56;
  if (a3)
    v9 = a3 + 56;
  else
    v9 = 0;
  RB::ColorStyle::HueRotation::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x4AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::HueRotation::encode((RB::ColorStyle::HueRotation *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorInvert::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 80 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 80;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2282C8;
  result = *a2;
  *(_QWORD *)(v5 + 72) = a2[1].n128_u64[0];
  *(__n128 *)(v5 + 56) = result;
  return result;
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::~ColorFilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::type_id()
{
  return 32773;
}

double RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)(a1 + 56)).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::draw(uint64_t a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5, uint16x4_t a6, int8x8_t a7)
{
  RB::DisplayList::Item *result;
  _BYTE v13[40];

  RB::ColorStyle::ColorMonochrome::set_color_matrix((RB::ColorStyle::ColorMonochrome *)(a1 + 56), (RB::ColorMatrix *)v13, a6, a7);
  result = RB::DisplayList::Builder::apply_color_matrix(a2, a4, (const RB::ColorMatrix *)v13, *(_DWORD *)(a1 + 56), *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
  if (result)
  {
    *((_QWORD *)result + 2) = *(_QWORD *)(a1 + 32);
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 56), a2) | 0x100;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ColorStyle::ColorMonochrome::operator==(a1 + 56, a3 + 56))
    return 4;
  else
    return 2;
}

uint64_t RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 v6;
  int8x16_t v7;
  double v8;
  double v9;
  double v10;
  int8x16_t v11;
  uint64_t v12;
  uint64_t v13;
  RB::ColorStyle::ColorMonochrome *v14;
  const RB::ColorStyle::ColorMonochrome *v15;

  v6 = RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(a1 + 56));
  v13 = v12;
  v14 = (RB::ColorStyle::ColorMonochrome *)(v12 + 56);
  if (a3)
    v15 = (const RB::ColorStyle::ColorMonochrome *)(a3 + 56);
  else
    v15 = 0;
  v6.n128_u32[0] = *(_DWORD *)(a2 + 16);
  RB::ColorStyle::ColorMonochrome::mix(v14, v15, (int8x16_t)v6, v7, v8, v9, v10, v11);
  return v13;
}

_QWORD *RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x52uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x42uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorStyle::ColorMonochrome::encode((RB::ColorStyle::ColorMonochrome *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "color");
  RB::ColorStyle::ColorMonochrome::print((std::string *)(a1 + 56), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

BOOL RB::ColorStyle::ColorMonochrome::operator==(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)a1 != *(_DWORD *)a2)
    return 0;
  _ZF = !*(_BYTE *)(a1 + 13) || *(_BYTE *)(a2 + 13) == 0;
  if (!_ZF && *(unsigned __int8 *)(a1 + 12) != *(unsigned __int8 *)(a2 + 12))
    return 0;
  _H0 = *(_WORD *)(a1 + 4);
  _H1 = *(_WORD *)(a2 + 4);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 6);
  _H1 = *(_WORD *)(a2 + 6);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 8);
  _H1 = *(_WORD *)(a2 + 8);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  _H0 = *(_WORD *)(a1 + 10);
  _H1 = *(_WORD *)(a2 + 10);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
    return 0;
  return *(float *)(a1 + 16) == *(float *)(a2 + 16) && *(float *)(a1 + 20) == *(float *)(a2 + 20);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 112;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2246B0;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 96) = v7;
  *(__n128 *)(v5 + 64) = result;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::~FilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::type_id()
{
  return 8194;
}

double RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::draw(_QWORD *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t *v10;
  const RB::DisplayList::ClipNode *v11;
  RB::DisplayList::LayerFilter *v12;
  RB::DisplayList::Item *result;

  v10 = (float64x2_t *)a1[2];
  v11 = (const RB::DisplayList::ClipNode *)a1[3];
  RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((_QWORD *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::can_mix(float32x4_t *a1, RB::DisplayList::Interpolator::Contents *a2, float32x4_t *a3)
{
  float32x4_t *v3;
  float32x4_t *v4;

  v3 = a1 + 4;
  if (a3)
    v4 = a3 + 4;
  else
    v4 = 0;
  return RB::Filter::LuminanceCurve::can_mix(v3, a2, v4);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, uint64_t a3, const RB::DisplayList::CachedTransform *a4)
{
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  int8x16_t v12;
  uint64_t v13;
  uint64_t v14;
  RB::Filter::LuminanceCurve *v15;
  const RB::Filter::LuminanceCurve *v16;

  *(_QWORD *)&v7 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 64).n128_u64[0];
  v14 = v13;
  v15 = (RB::Filter::LuminanceCurve *)(v13 + 64);
  if (a3)
    v16 = (const RB::Filter::LuminanceCurve *)(a3 + 64);
  else
    v16 = 0;
  RB::Filter::LuminanceCurve::mix(v15, a2, v16, a4, v7, v8, v9, v10, v11, v12);
  return v14;
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::LuminanceCurve::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::LuminanceCurve::print((RB::Filter::LuminanceCurve *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 112;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2246B0;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 90) = *(_OWORD *)(a2 + 26);
  *(__n128 *)(v5 + 64) = result;
  *(_OWORD *)(v5 + 80) = v7;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 80 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 80;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)v5 = &off_24C227B98;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 58) = *(_OWORD *)(a2 + 26);
  *(__n128 *)(v5 + 32) = result;
  *(_OWORD *)(v5 + 48) = v7;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::~GenericFilter()
{
  JUMPOUT(0x20BD16544);
}

double RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve const&,RB::DisplayList::Builder &>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::filter_data()
{
  return 2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 8);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::can_discard_color(uint64_t a1, BOOL *a2)
{
  return RB::Filter::LuminanceCurve::can_discard_color((RB::Filter::LuminanceCurve *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::can_render_inline()
{
  return 1;
}

int32x2_t *RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::render(int32x2_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  return RB::Filter::LuminanceCurve::render(a1 + 4, a2, a3);
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::render(uint64_t a1, uint64_t a2)
{
  RB::Filter::LuminanceCurve::render(a1 + 32, a2);
}

void RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>::print(uint64_t a1, std::string *a2)
{
  RB::Filter::LuminanceCurve::print((RB::Filter::LuminanceCurve *)(a1 + 32), a2);
}

__n128 RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 144 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x90uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 144;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224038;
  *(_OWORD *)(v5 + 64) = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 112) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 128) = v8;
  *(__n128 *)(v5 + 80) = result;
  *(_OWORD *)(v5 + 96) = v7;
  return result;
}

void RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::~FilterStyle()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::type_id()
{
  return 12290;
}

double RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 64).n128_u64[0];
  return result;
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::draw(_QWORD *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t *v10;
  const RB::DisplayList::ClipNode *v11;
  RB::DisplayList::LayerFilter *v12;
  RB::DisplayList::Item *result;

  v10 = (float64x2_t *)a1[2];
  v11 = (const RB::DisplayList::ClipNode *)a1[3];
  RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((_QWORD *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::can_mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  float32x4_t *v3;
  float32x4_t *v4;

  v3 = a1 + 4;
  if (a3)
    v4 = a3 + 4;
  else
    v4 = 0;
  return RB::Filter::RGBACurves::can_mix(v3, a2, v4);
}

float32x4_t *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::mix(uint64_t a1, uint64_t a2, float32x4_t *a3, uint64_t a4)
{
  float32x4_t *v6;
  float32x4_t *v7;
  float32x4_t *v8;
  float32x4_t *v9;

  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 64);
  v7 = v6;
  v8 = v6 + 4;
  if (a3)
    v9 = a3 + 4;
  else
    v9 = 0;
  RB::Filter::RGBACurves::mix(v8, a2, v9);
  return v7;
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::encode(float32x4_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::RGBACurves::encode(a1 + 4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::RGBACurves::print((RB::Filter::RGBACurves *)(a1 + 8), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;
  __int128 v8;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 112 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 112;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)v5 = &off_24C2240C0;
  *(_OWORD *)(v5 + 32) = *(_OWORD *)a2;
  result = *(__n128 *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v8 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v5 + 80) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v5 + 96) = v8;
  *(__n128 *)(v5 + 48) = result;
  *(_OWORD *)(v5 + 64) = v7;
  return result;
}

void RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::~GenericFilter()
{
  JUMPOUT(0x20BD16544);
}

double RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 32).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::filter_data()
{
  return 3;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::can_render_inline()
{
  return 1;
}

int32x2_t *RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::render(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return RB::Filter::RGBACurves::render((_DWORD *)(a1 + 32), a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::render(uint64_t a1, uint64_t a2)
{
  return RB::Filter::RGBACurves::render(a1 + 32, a2);
}

void RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>::print(uint64_t a1, std::string *a2)
{
  RB::Filter::RGBACurves::print((RB::Filter::RGBACurves *)(a1 + 32), a2);
}

uint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom>(size_t *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  else
    a1[2] = v3 + 272;
  return RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(v3, a2);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)(a1 + 48) = 0;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_QWORD *)a1 = &off_24C224738;
  *(_DWORD *)(a1 + 64) = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 72) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0;
  *(_QWORD *)(a1 + 192) = 4;
  v4 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 176) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 184) = v4;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  v5 = *(_QWORD *)(a1 + 192);
  *(_QWORD *)(a1 + 192) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v5;
  RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline((__int128 *)(a1 + 80), (__int128 *)(a2 + 16));
  v6 = *(_OWORD *)(a2 + 144);
  v7 = *(_OWORD *)(a2 + 160);
  v8 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 240) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 256) = v8;
  *(_OWORD *)(a1 + 208) = v6;
  *(_OWORD *)(a1 + 224) = v7;
  return a1;
}

void sub_209B41410(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  const void **v3;
  void **v4;
  void *v6;
  unint64_t v7;

  v6 = *(void **)(v1 + 176);
  if (v6)
    v3 = *(const void ***)(v1 + 176);
  if (*(_QWORD *)(v1 + 184))
  {
    v7 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v3);
      ++v7;
      v3 += 3;
    }
    while (v7 < *(_QWORD *)(v1 + 184));
    v6 = *v4;
  }
  RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(v2, v6);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::Custom>::~FilterStyle(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (const void **)(a1 + 10);
  v3 = (const void **)a1[22];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[23])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[23]);
    v3 = (const void **)a1[22];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[9];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return a1;
}

void RB::DisplayList::FilterStyle<RB::Filter::Custom>::~FilterStyle(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (const void **)(a1 + 10);
  v3 = (const void **)a1[22];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[23])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[23]);
    v3 = (const void **)a1[22];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[9];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::type_id()
{
  return 16386;
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(_QWORD *)(a2 + 8) + 16), a1 + 64);
}

RB::DisplayList::Item *RB::DisplayList::FilterStyle<RB::Filter::Custom>::draw(_QWORD *a1, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t *v10;
  const RB::DisplayList::ClipNode *v11;
  RB::DisplayList::LayerFilter *v12;
  RB::DisplayList::Item *result;

  v10 = (float64x2_t *)a1[2];
  v11 = (const RB::DisplayList::ClipNode *)a1[3];
  v12 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)(a1 + 8));
  result = RB::DisplayList::Builder::apply_filter_(a2, a4, v12, v10, v11);
  if (result)
  {
    *((_QWORD *)result + 2) = a1[4];
    return RB::DisplayList::Builder::draw(a2, result, a3, a5);
  }
  return result;
}

BOOL RB::DisplayList::FilterStyle<RB::Filter::Custom>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _DWORD *v3;
  uint64_t v4;

  v3 = (_DWORD *)(a1 + 64);
  if (a3)
    v4 = a3 + 64;
  else
    v4 = 0;
  return RB::Filter::Custom::can_mix(v3, a2, v4);
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::Custom>::mix(uint64_t a1, float32_t *a2, uint64_t a3, const RB::DisplayList::CachedTransform *a4)
{
  unint64_t v7;
  double v8;
  int8x16_t v9;
  double v10;
  double v11;
  double v12;
  int8x16_t v13;
  const RB::Filter::Custom *v14;

  v7 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 64);
  if (a3)
    v14 = (const RB::Filter::Custom *)(a3 + 64);
  else
    v14 = 0;
  RB::Filter::Custom::mix((RB::Filter::Custom *)(v7 + 64), a2, v14, a4, v8, v9, v10, v11, v12, v13);
  return v7;
}

uint64_t *RB::DisplayList::FilterStyle<RB::Filter::Custom>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode((RB::DisplayList::Style *)a1, a2);
  return RB::Filter::Custom::prepare_encode((RB::Filter::Custom *)(a1 + 64), a2);
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::Custom>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::Custom::encode((RB::Filter::Custom *)(a1 + 8), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::Custom>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::Custom::print((float32x2_t *)(a1 + 64), this);
  RB::DisplayList::Style::print((const RB::AffineTransform **)a1, this);
  RB::SexpString::pop(this);
}

__int128 *RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline(__int128 *result, __int128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v2 = *((_QWORD *)a2 + 12);
  v3 = *((_QWORD *)result + 12);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
  {
    v11 = a2[2];
    v12 = a2[3];
    v13 = a2[4];
    v14 = a2[5];
    v9 = *a2;
    v10 = a2[1];
    v5 = result[1];
    *a2 = *result;
    a2[1] = v5;
    v6 = result[5];
    v8 = result[2];
    v7 = result[3];
    a2[4] = result[4];
    a2[5] = v6;
    a2[2] = v8;
    a2[3] = v7;
    result[4] = v13;
    result[5] = v14;
    result[2] = v11;
    result[3] = v12;
    *result = v9;
    result[1] = v10;
    if (v3)
    {
      if (v2)
        return result;
    }
    else
    {
      *((_QWORD *)result + 12) = 0;
      if (v2)
        return result;
    }
    *((_QWORD *)a2 + 12) = 0;
  }
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>(size_t *a1, uint64_t a2)
{
  unint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  else
    a1[2] = v3 + 272;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C224738;
  *(_DWORD *)(v3 + 64) = *(_DWORD *)a2;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v3 + 72), (const RB::CustomShader::Closure *)(a2 + 8));
  v4 = *(_OWORD *)(a2 + 144);
  v5 = *(_OWORD *)(a2 + 160);
  v6 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v3 + 240) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v3 + 256) = v6;
  *(_OWORD *)(v3 + 208) = v4;
  *(_OWORD *)(v3 + 224) = v5;
  return v3;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>(size_t *a1, uint64_t a2)
{
  unint64_t v3;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 240 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0xF0uLL, 15);
  else
    a1[2] = v3 + 240;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)v3 = &off_24C227C28;
  *(_DWORD *)(v3 + 32) = *(_DWORD *)a2;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v3 + 40), (const RB::CustomShader::Closure *)(a2 + 8));
  v4 = *(_OWORD *)(a2 + 144);
  v5 = *(_OWORD *)(a2 + 160);
  v6 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v3 + 208) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v3 + 224) = v6;
  *(_OWORD *)(v3 + 176) = v4;
  *(_OWORD *)(v3 + 192) = v5;
  return v3;
}

_QWORD *RB::DisplayList::GenericFilter<RB::Filter::Custom>::~GenericFilter(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (const void **)(a1 + 6);
  v3 = (const void **)a1[18];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[19])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[19]);
    v3 = (const void **)a1[18];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[5];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return a1;
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::~GenericFilter(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (const void **)(a1 + 6);
  v3 = (const void **)a1[18];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[19])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[19]);
    v3 = (const void **)a1[18];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[5];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

unint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::copy(uint64_t a1, uint64_t a2)
{
  return RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)(*(_QWORD *)(a2 + 8) + 16), a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::apply_transform(uint64_t a1, float64x2_t *a2)
{
  RB::Filter::Custom::apply_transform(a1 + 32, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::append()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::filter_data()
{
  return 4;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::dod(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 32);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::commutes_with_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::can_discard_color()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::can_render_inline()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::Filter::Custom::prepare(a1 + 32, a2);
}

Function *RB::DisplayList::GenericFilter<RB::Filter::Custom>::render(uint64_t a1, uint64_t a2, uint64_t a3, double a4)
{
  return RB::Filter::Custom::render(a1 + 32, a4, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::render(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::Custom>::print(float32x2_t *a1, std::string *a2)
{
  RB::Filter::Custom::print(a1 + 4, a2);
}

id RB::ObjcEncoderDelegate::encode_message_f<NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#1},NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#2}>(id *a1, RB::DisplayList::Contents **a2, RB::DisplayList::Contents **a3)
{
  _QWORD *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  void *v12;
  id v13;
  id v14;
  _QWORD *v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  void *v20;
  _QWORD v21[5];
  void *v22[4];
  __int128 v23;
  char v24;
  id *v25;
  _QWORD *v26;
  uint64_t v27;
  _DWORD v28[24];

  v6 = RB::ObjcEncoderDelegate::font_set(a1);
  memset(v22, 0, sizeof(v22));
  v23 = 0u;
  v24 = 0;
  v25 = a1;
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 1);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  v26 = v6;
  v27 = 0;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)v28, 0, 0, 0, 0, 0);
  do
  {
    v9 = __ldxr((unsigned int *)&RB::Encoder::_last_encoder_id);
    v10 = v9 + 1;
  }
  while (__stxr(v10, (unsigned int *)&RB::Encoder::_last_encoder_id));
  v28[20] = v10;
  v28[21] = 0;
  RB::DisplayList::Contents::prepare_encode(*a2, (RB::Encoder *)v22);
  RB::Encoder::prepare_fonts((RB::Encoder *)v22);
  RB::DisplayList::Contents::encode(*a3, (void (****)(CFDataRef *__return_ptr))v22);
  v11 = operator new();
  v12 = v22[0];
  *(void **)v11 = v22[0];
  v20 = v22[1];
  *(_OWORD *)(v11 + 8) = *(_OWORD *)&v22[1];
  memset(v22, 0, 24);
  v13 = objc_alloc(MEMORY[0x24BDBCE50]);
  v21[0] = MEMORY[0x24BDAC760];
  v21[1] = 3221225472;
  v21[2] = ___ZN2RB19ObjcEncoderDelegate16encode_message_fIZNS0_14encode_messageINS_11DisplayList8ContentsEEEP6NSDataRKT_EUlRS7_E_ZNS2_IS4_EES6_S9_EUlSA_E0_EES6_S9_RKT0__block_invoke;
  v21[3] = &__block_descriptor_40_e12_v24__0_v8Q16l;
  v21[4] = v11;
  v14 = (id)objc_msgSend(v13, "initWithBytesNoCopy:length:deallocator:", v12, v20, v21);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v28);
  v15 = v26;
  if (v26)
  {
    v16 = (unsigned int *)(v26 + 1);
    do
    {
      v17 = __ldxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
    {
      __dmb(9u);
      (*(void (**)(_QWORD *))(*v15 + 8))(v15);
    }
  }
  if (v22[3])
    free(v22[3]);
  if (v22[0])
    free(v22[0]);
  return v14;
}

void sub_209B41D1C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25)
{
  if (a25)
    -[RBEncoderSet addDisplayList:].cold.1(a25);
  if (a20)
    free(a20);
  if (a17)
    free(a17);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN2RB19ObjcEncoderDelegate16encode_message_fIZNS0_14encode_messageINS_11DisplayList8ContentsEEEP6NSDataRKT_EUlRS7_E_ZNS2_IS4_EES6_S9_EUlSA_E0_EES6_S9_RKT0__block_invoke(uint64_t result)
{
  void **v1;

  v1 = *(void ***)(result + 32);
  if (v1)
  {
    if (*v1)
      free(*v1);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::Path::Renderer::render(int32x2_t **a1, uint64_t a2, char a3, int a4)
{
  _BOOL4 may_discard_shape;
  _QWORD v6[2];
  char v7;
  int v8;

  v6[0] = &off_24C22A4B8;
  v6[1] = a2;
  v7 = a3;
  v8 = a4;
  may_discard_shape = RB::may_discard_shape(a4);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, may_discard_shape);
}

{
  _BOOL4 may_discard_shape;
  _QWORD v6[2];
  char v7;
  int v8;

  v6[0] = &off_24C22A500;
  v6[1] = a2;
  v7 = a3;
  v8 = a4;
  may_discard_shape = RB::may_discard_shape(a4);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, may_discard_shape);
}

void RB::Path::Renderer::render(int32x2_t **a1, uint64_t a2, uint64_t a3, char a4, int a5, float a6)
{
  _BOOL4 may_discard_shape;
  _QWORD v8[3];
  char v9;
  float v10;
  int v11;

  v8[0] = &off_24C22A4E8;
  v8[1] = a2;
  v8[2] = a3;
  v9 = a4;
  v10 = a6;
  v11 = a5;
  may_discard_shape = RB::may_discard_shape(a5);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v8, may_discard_shape);
}

{
  _QWORD v6[3];
  char v7;
  float v8;
  int v9;

  v6[0] = &off_24C223F58;
  v6[1] = a2;
  v6[2] = a3;
  v7 = a4;
  v8 = a6;
  v9 = a5;
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v6, 1);
}

{
  _BOOL4 may_discard_shape;
  _QWORD v8[3];
  char v9;
  float v10;
  int v11;

  v8[0] = &off_24C22A4D0;
  v8[1] = a2;
  v8[2] = a3;
  v9 = a4;
  v10 = a6;
  v11 = a5;
  may_discard_shape = RB::may_discard_shape(a5);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)v8, may_discard_shape);
}

int8x8_t *RB::Path::ImmediateRenderer::ImmediateRenderer(int8x8_t *this, int32x2_t *a2, float64x2_t *a3, const RB::Coverage::Path *a4)
{
  RB::Path::Accumulator *v8;
  uint64_t v9;
  float v10;
  int32x2_t v11;
  int32x2_t v12;
  uint32x2_t v13;
  int8x8_t v14;
  float32x2_t v15;
  float32x2_t v16;
  uint32x2_t v17;
  float v18;
  int32x2_t v19;
  int32x4_t v20;
  int32x2_t v21;
  int8x8_t *v22;
  float32x2_t v23;
  float32x2_t v24;
  uint32x2_t v25;
  int8x8_t v26;
  __int8 v27;
  __int8 v28;
  float v29;
  float v30;

  v8 = (RB::Path::Accumulator *)&this[1];
  v9 = **(_QWORD **)a2;
  v10 = RB::bezier_flatness((RB *)*((unsigned __int8 *)a4 + 29));
  v11.i32[0] = 0;
  v12 = a2[21];
  v13 = (uint32x2_t)vceq_s32(v12, (int32x2_t)0x8000000080000000);
  v14 = (int8x8_t)vdup_lane_s32(vcgt_s32(v11, (int32x2_t)vpmin_u32(v13, v13)), 0);
  v15 = (float32x2_t)vbsl_s8(v14, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v12));
  v16 = (float32x2_t)vbsl_s8(v14, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
  if (*((unsigned __int8 *)a4 + 29) >= 2u)
  {
    v17 = (uint32x2_t)vcgtz_f32(v15);
    if ((vpmin_u32(v17, v17).u32[0] & 0x80000000) != 0)
    {
      if (*((float *)a4 + 6) >= 0.0)
        v18 = *((float *)a4 + 6);
      else
        v18 = 0.0;
      *(float *)v19.i32 = v18 * RB::AffineTransform::scale(a3);
      *(int32x2_t *)v20.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v15);
      v20.i64[0] = vcltzq_s32(v20).u64[0];
      v16 = (float32x2_t)vbsl_s8(*(int8x8_t *)v20.i8, (int8x8_t)vsub_f32(v16, (float32x2_t)vdup_lane_s32(v19, 0)), (int8x8_t)v16);
      v15 = (float32x2_t)vbsl_s8(*(int8x8_t *)v20.i8, (int8x8_t)vmla_n_f32(v15, (float32x2_t)0x4000000040000000, *(float *)v19.i32), (int8x8_t)v15);
    }
  }
  RB::Path::Accumulator::Accumulator((uint64_t)v8, v9, (uint64_t *)a4, a3, v10, v16, v15);
  if (this[36].i8[0])
    RB::Path::Accumulator::commit_buffer(v8);
  v22 = (int8x8_t *)this[33];
  this[40] = (int8x8_t)v22;
  if (v22)
  {
    if (this[36].i8[0])
      RB::Path::Accumulator::commit_buffer(v8);
    v22 = this + 16;
    if (this[32])
      v22 = (int8x8_t *)this[32];
  }
  v21.i32[0] = 0;
  this[41] = (int8x8_t)v22;
  v24 = (float32x2_t)this[8];
  v23 = (float32x2_t)this[9];
  v25 = (uint32x2_t)vcgt_f32(v23, v24);
  v26 = (int8x8_t)vdup_lane_s32(vcgt_s32(v21, (int32x2_t)vpmin_u32(v25, v25)), 0);
  this[42] = vand_s8((int8x8_t)v24, v26);
  this[43] = vand_s8((int8x8_t)vsub_f32(v23, v24), v26);
  *(_OWORD *)this[44].i8 = xmmword_209BD5290;
  *(_OWORD *)this[46].i8 = xmmword_209BD52A0;
  this[48] = 0;
  this[49] = 0;
  v27 = *((_BYTE *)a4 + 28);
  v28 = *((_BYTE *)a4 + 29);
  v29 = 0.0;
  if ((v28 & 0xFE) == 2)
  {
    v30 = *((float *)a4 + 6);
    v29 = RB::AffineTransform::scale(a3) * v30;
  }
  this[50] = (int8x8_t)a2;
  this[51].i8[0] = v27;
  this[51].i8[1] = v28;
  *(float *)&this[51].i32[1] = v29;
  this[52] = (int8x8_t)1;
  this[53] = (int8x8_t)&this[40];
  return this;
}

void sub_209B42130(_Unwind_Exception *a1)
{
  RB::Path::Accumulator *v1;

  RB::Path::Accumulator::~Accumulator(v1);
  _Unwind_Resume(a1);
}

int32x2_t *RB::Path::Renderer::render_coverage(float,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7;
  float32x2_t *v9;
  uint32x2_t v10;
  int8x8_t v11;
  RB::Buffer *v17;
  _OWORD *v18;
  __int128 v19;
  __int128 v21;
  __int128 v22;
  RB::Buffer *v23;
  int64x2_t v24;

  v7 = a4;
  a4.i32[0] = 0;
  v9 = *a2;
  v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v21, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  _S0 = *(_DWORD *)(a1 + 8);
  __asm { FCVT            H0, S0 }
  WORD6(v22) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x20, 4uLL, 0, &v23);
  v17 = v23;
  if (v23)
  {
    v18 = (_OWORD *)(*((_QWORD *)v23 + 7) + v24.i64[0]);
    v19 = v22;
    *v18 = v21;
    v18[1] = v19;
  }
  else
  {
    v23 = 0;
    v24 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v17);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v24);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)(((*(_WORD *)(a1 + 12) & 0x3F) << 6) & 0xFFF | ((a3 & 0x3FF) << 12) | 0x11u | ((unint64_t)(v9[17].i32[0] == 2) << 33)), 4, ***(_QWORD ***)v9 + 80, 0, 1uLL, v7, a5);
}

int32x2_t *RB::Path::Renderer::render(RB::Fill::Color const&,BOOL,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7;
  float32x2_t *v9;
  uint32x2_t v10;
  int8x8_t v11;
  uint16x4_t v12;
  int16x4_t v13;
  uint64_t v14;
  int v15;
  float16x4_t v16;
  RB::Buffer *v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  RB::Buffer *v22;
  __int128 v23;
  _BYTE v24[20];
  RB::Buffer *v25;
  int64x2_t v26;

  v7 = a4;
  a4.i32[0] = 0;
  v9 = *a2;
  v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  *(float *)v12.i32 = RB::Coverage::set_plane((float32x2_t *)&v23, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  v14 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v14 + 9) && (v15 = v9[15].u8[4], *(unsigned __int8 *)(v14 + 8) != v15))
  {
    v22 = *(RB::Buffer **)v14;
    v26.i16[0] = *(_WORD *)(v14 + 8);
    v25 = v22;
    RB::Fill::Color::convert((uint64_t)&v25, v15, v12);
    v16.i16[3] = 15360;
    v16.i32[0] = (int)v25;
    v16.i16[2] = WORD2(v25);
    v13.i32[0] = (unint64_t)v25 >> 48;
  }
  else
  {
    v16.i32[0] = *(_DWORD *)v14;
    v16.i16[2] = *(_WORD *)(v14 + 4);
    v16.i16[3] = *(_WORD *)"";
    v13.i16[0] = *(_WORD *)(v14 + 6);
  }
  *(float16x4_t *)&v24[12] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v13, 0)), vcvtq_f32_f16(v16)));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x24, 4uLL, 0, &v25);
  v17 = v25;
  if (v25)
  {
    v18 = *((_QWORD *)v25 + 7) + v26.i64[0];
    v19 = v23;
    v20 = *(_OWORD *)v24;
    *(_DWORD *)(v18 + 32) = *(_DWORD *)&v24[16];
    *(_OWORD *)v18 = v19;
    *(_OWORD *)(v18 + 16) = v20;
  }
  else
  {
    v25 = 0;
    v26 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v17);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v26);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)(((*(_WORD *)(a1 + 20) & 0x3F) << 6) & 0xFFF | ((a3 & 0x3FF) << 12) | 0x12u | ((unint64_t)(*(unsigned __int8 *)(a1 + 16) | (2 * (v9[17].i32[0] == 2))) << 32)), 4, ***(_QWORD ***)v9 + 80, 0, 1uLL, v7, a5);
}

int32x2_t *RB::Path::Renderer::render(RB::Fill::Gradient const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7;
  float32x2_t *v9;
  uint32x2_t v10;
  int8x8_t v11;
  double v12;
  RB::Buffer *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  _BOOL4 v19;
  int8x8_t v20;
  int32x2_t *result;
  __int128 v22;
  _OWORD v23[4];
  int v24;
  RB::Buffer *v25;
  int64x2_t v26;

  v7 = a4;
  a4.i32[0] = 0;
  v9 = *a2;
  v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v22, *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  LODWORD(v12) = *(_DWORD *)(a1 + 28);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 8), (uint64_t)v23 + 12, (uint64_t)v9, *(float64x2_t **)(a1 + 16), v12);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x54, 4uLL, 0, &v25);
  v13 = v25;
  if (v25)
  {
    v14 = *((_QWORD *)v25 + 7) + v26.i64[0];
    v15 = v22;
    *(_OWORD *)(v14 + 16) = v23[0];
    v16 = v23[3];
    v17 = v23[2];
    v18 = v23[1];
    *(_DWORD *)(v14 + 80) = v24;
    *(_OWORD *)(v14 + 48) = v17;
    *(_OWORD *)(v14 + 64) = v16;
    *(_OWORD *)(v14 + 32) = v18;
    *(_OWORD *)v14 = v15;
  }
  else
  {
    v25 = 0;
    v26 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v26);
  v19 = v9[17].i32[0] == 2;
  LODWORD(v25) = ((a3 & 0x3FF) << 12) | 0x13;
  HIDWORD(v25) = 2 * v19;
  RB::Fill::Gradient::set_fill_state(*(float32x2_t **)(a1 + 8), (int *)&v25, (uint64_t)v9, *(float *)(a1 + 28));
  v20.i32[0] = (*(_DWORD *)(a1 + 32) & 0x3F) << 6;
  v20.i32[1] = *(unsigned __int8 *)(a1 + 24);
  v25 = (RB::Buffer *)vorr_s8(vand_s8((int8x8_t)v25, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v20);
  result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, (const char *)v25, 4, ***(_QWORD ***)v9 + 80, 0, 1uLL, v7, a5);
  v9[28] = 0;
  v9[27].i32[1] = 0;
  return result;
}

void RB::Path::Renderer::render(RB::Fill::MeshGradient const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, RB::RenderPass **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v5[2];

  v5[0] = a4;
  v5[1] = a5;
  RB::render_mesh_gradient(*a2, *(float64x2_t **)(a1 + 16), *(int32x2_t **)(a1 + 8), a3, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 32), v5, *(float *)(a1 + 28));
}

int32x2_t *RB::Path::Renderer::render(RB::Shader::Globals<RB::Shader::PlaneGlobals,RB::Shader::ImageGlobals> &,BOOL,RB::BlendMode)::Paint::fill(uint64_t a1, float32x2_t **a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  int32x2_t v7;
  float32x2_t *v9;
  uint32x2_t v10;
  int8x8_t v11;
  __int128 *v12;
  RB::Buffer *v13;
  _OWORD *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BOOL4 v20;
  int8x8_t v21;
  RB::Buffer *v23;
  int64x2_t v24;

  v7 = a4;
  a4.i32[0] = 0;
  v9 = *a2;
  v10 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
  v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(a4, (int32x2_t)vpmin_u32(v10, v10)), 0);
  RB::Coverage::set_plane(*(float32x2_t **)(a1 + 8), *a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v7)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
  v12 = *(__int128 **)(a1 + 8);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x70, 4uLL, 0, &v23);
  v13 = v23;
  if (v23)
  {
    v14 = (_OWORD *)(*((_QWORD *)v23 + 7) + v24.i64[0]);
    v15 = v12[2];
    v16 = *v12;
    v14[1] = v12[1];
    v14[2] = v15;
    v17 = v12[6];
    v19 = v12[3];
    v18 = v12[4];
    v14[5] = v12[5];
    v14[6] = v17;
    v14[3] = v19;
    v14[4] = v18;
    *v14 = v16;
  }
  else
  {
    v23 = 0;
    v24 = 0uLL;
  }
  v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
  *(int32x2_t *)((char *)&v9[23] + 4) = vmovn_s64(v24);
  v20 = v9[17].i32[0] == 2;
  LODWORD(v23) = ((a3 & 0x3FF) << 12) | 0x15;
  HIDWORD(v23) = 2 * v20;
  RB::RenderState::set_image((int *)&v23, *(_QWORD *)(a1 + 8) + 28, v9[15].u8[4]);
  v21.i32[0] = (*(_DWORD *)(a1 + 20) & 0x3F) << 6;
  v21.i32[1] = *(unsigned __int8 *)(a1 + 16);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, *(const char **)&vorr_s8(vand_s8((int8x8_t)v23, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v21), 4, ***(_QWORD ***)v9 + 80, 0, 1uLL, v7, a5);
}

void RB::Path::Renderer::render(RB::Fill::Custom const&,RB::AffineTransform const&,BOOL,float,RB::BlendMode)::Paint::fill(uint64_t a1, uint64_t ***a2, __int16 a3, int32x2_t a4, int32x2_t a5)
{
  uint64_t **v9;
  uint64_t *v10;
  Function *v11;
  int32x2_t v12;
  uint64_t v13;
  uint32x2_t v14;
  int8x8_t v15;
  _BOOL4 v16;
  int8x8_t v17;
  int8x8_t v18;
  RB::Buffer *v19;
  int64x2_t v20;

  v9 = *a2;
  v10 = RB::Fill::Custom::function(*(RB::Fill::Custom **)(a1 + 8), *a2);
  if (v10)
  {
    v11 = (Function *)v10;
    RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**v9, (RB::Device *)(*((unsigned int *)v10 + 20) + 56), 4uLL, 0, &v19);
    if (v19)
    {
      v12.i32[0] = 0;
      v13 = *((_QWORD *)v19 + 7) + v20.i64[0];
      v14 = (uint32x2_t)vceq_s32(a5, (int32x2_t)0x8000000080000000);
      v15 = (int8x8_t)vdup_lane_s32(vcgt_s32(v12, (int32x2_t)vpmin_u32(v14, v14)), 0);
      RB::Coverage::set_plane((float32x2_t *)v13, (float32x2_t *)v9, (float32x2_t)vbsl_s8(v15, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a4)), COERCE_DOUBLE(vbsl_s8(v15, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a5))));
      if (RB::Fill::Custom::set_custom(*(_QWORD *)(a1 + 8), (float32x2_t *)(v13 + 28), (uint64_t)v11, v13 + 56, (uint64_t)v9, *(float32x4_t **)(a1 + 16), *(float *)(a1 + 28)))
      {
        *((_DWORD *)v9 + 46) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**v9, v19);
        *(uint64_t **)((char *)v9 + 188) = (uint64_t *)vmovn_s64(v20);
        v16 = *((_DWORD *)v9 + 34) == 2;
        v18.i32[0] = ((a3 & 0x3FF) << 12) | 0x16;
        v18.i32[1] = 2 * v16;
        RB::Fill::Custom::set_fill_state(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderState *)&v18, v11, (unint64_t **)v9);
        v17.i32[0] = (*(_DWORD *)(a1 + 32) & 0x3F) << 6;
        v17.i32[1] = *(unsigned __int8 *)(a1 + 24);
        v18 = vorr_s8(vand_s8(v18, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v17);
        RB::RenderPass::draw_indexed_primitives((int32x2_t *)v9, *(const char **)&v18, 4, *(_QWORD *)**v9 + 80, 0, 1uLL, a4, a5);
        RB::Fill::Custom::reset_custom(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderPass *)v9);
      }
    }
  }
}

uint64_t RB::FontMixer::shared(RB::FontMixer *this)
{
  unsigned __int8 v1;
  _OWORD *v3;
  uint64_t i;
  _QWORD *v5;

  {
    v3 = (_OWORD *)operator new();
    bzero(v3, 0x470uLL);
    for (i = 1; i != 65; i += 2)
    {
      v5 = &v3[i];
      *(_QWORD *)((char *)v5 + 6) = 0;
      *v5 = 0;
    }
    v3[69] = 0u;
    v3[70] = 0u;
    v3[67] = 0u;
    v3[68] = 0u;
    v3[65] = 0u;
    v3[66] = 0u;
    RB::FontMixer::shared(void)::shared = (uint64_t)v3;
  }
  return RB::FontMixer::shared(void)::shared;
}

void sub_209B42A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *RB::FontMixer::get_info(RB::FontMixer *this, CGFont *a2, CGFont *a3)
{
  unsigned int Identifier;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  char *v15;
  unint64_t v16;
  signed int v17;
  int v18;
  int v19;
  uint64_t v20;
  char *v21;
  char *v22;
  _BYTE *v23;
  id v24;
  const void *v25;
  const void *v26;
  int v27;
  id v28;
  const void *v29;
  const void *v30;
  const void *v31;

  Identifier = CGFontGetIdentifier();
  v7 = CGFontGetIdentifier();
  v8 = 0;
  v9 = 0;
  v10 = ~((uint64_t)(int)(v7 ^ Identifier) << 32) + (int)(v7 ^ Identifier);
  v11 = (v10 ^ (v10 >> 22)) + ~((v10 ^ (v10 >> 22)) << 13);
  v12 = (9 * (v11 ^ (v11 >> 8))) ^ ((9 * (v11 ^ (v11 >> 8))) >> 15);
  v13 = (v12 + ~(v12 << 27)) ^ ((v12 + ~(v12 << 27)) >> 31);
  v14 = 4 * (v13 & 7);
  v15 = (char *)this + 16;
  v16 = (v13 & 7) << 7;
  v17 = 0x80000000;
  do
  {
    v18 = *(_DWORD *)&v15[128 * (v13 & 7)];
    if (v18 == Identifier && *(_DWORD *)&v15[v16 + 4] == (_DWORD)v7
      || v18 == (_DWORD)v7 && *(_DWORD *)&v15[v16 + 4] == Identifier)
    {
      v27 = *((_DWORD *)this + 1) + 1;
      *((_DWORD *)this + 1) = v27;
      v22 = &v15[128 * (v13 & 7)];
      *((_DWORD *)v22 + 2) = v27;
      return v22;
    }
    v19 = *((_DWORD *)this + 1);
    if (v19 - *((_DWORD *)v15 + 2) > v17)
    {
      v17 = v19 - *((_DWORD *)v15 + 2);
      v9 = v8;
    }
    ++v8;
    v15 += 32;
  }
  while (v8 != 4);
  v20 = v9 + v14;
  v21 = (char *)this + 32 * v9 + 32 * v14;
  *((_QWORD *)v21 + 2) = Identifier | (unint64_t)(v7 << 32);
  v22 = v21 + 16;
  *((_DWORD *)this + 1) = v19 + 1;
  *((_DWORD *)v22 + 2) = v19 + 1;
  v23 = v22 + 13;
  *((_WORD *)v22 + 6) = 0;
  v24 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a2);
  if (v24)
  {
    v25 = (const void *)-[RBDecodedFontMetadata fontUID]((uint64_t)v24);
    if (v25)
      v26 = CFRetain(v25);
    else
      v26 = 0;
    *v23 = 1;
  }
  else
  {
    v26 = (const void *)CGFontCopyName();
  }
  v28 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a3);
  if (v28)
  {
    v29 = (const void *)-[RBDecodedFontMetadata fontUID]((uint64_t)v28);
    if (v29)
      v30 = CFRetain(v29);
    else
      v30 = 0;
    *v23 = 1;
    if (v26)
      goto LABEL_24;
  }
  else
  {
    v30 = (const void *)CGFontCopyName();
    if (v26)
    {
LABEL_24:
      if (v30)
      {
        if (CFEqual(v26, v30))
        {
          v22[12] = 1;
          *((_QWORD *)this + 4 * v20 + 5) = CGFontGetVariationAxes();
        }
        CFRelease(v30);
      }
      v31 = v26;
      goto LABEL_29;
    }
  }
  if (v30)
  {
    v31 = v30;
LABEL_29:
    CFRelease(v31);
  }
  return v22;
}

void sub_209B42CAC(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v1);
  CFRelease(v2);
  _Unwind_Resume(a1);
}

uint64_t RB::FontMixer::can_mix(os_unfair_lock_s *a1, CGFont *a2, CGFont *a3, uint64_t *a4)
{
  _BOOL8 v5;
  char *info;
  char *v10;
  id v11;
  id v12;

  if (a2 == a3)
    return 1;
  v5 = 0;
  if (a2 && a3)
  {
    os_unfair_lock_lock(a1);
    info = RB::FontMixer::get_info((RB::FontMixer *)a1, a2, a3);
    v10 = info;
    if (a4 && info[13])
    {
      v11 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a2);
      *a4 = -[RBDecodedFontMetadata glyphMap]((uint64_t)v11);
      v12 = +[RBDecodedFontMetadata fontMetadata:]((uint64_t)RBDecodedFontMetadata, a3);
      a4[1] = -[RBDecodedFontMetadata glyphMap]((uint64_t)v12);
    }
    v5 = v10[12] != 0;
    os_unfair_lock_unlock(a1);
  }
  return v5;
}

void sub_209B42D90(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::FontMixer::mix(os_unfair_lock_s *this@<X0>, CGFont *cf@<X1>, CGFont *a3@<X2>, uint32_t a4@<S0>, _QWORD *a5@<X8>)
{
  char *info;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  os_unfair_lock_s *v16;
  signed int v17;
  uint32_t os_unfair_lock_opaque;
  uint32_t v19;
  float v20;
  signed int v21;
  os_unfair_lock_s *v22;
  const void *v23;
  CFTypeRef *v24;
  os_unfair_lock_s *v25;
  uint64_t Variations;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  uint64_t v30;
  size_t v31;
  char *v32;
  int v33;
  const void *v34;
  CFTypeRef v35;
  const void *v36;
  CFTypeRef v37;
  const void *v38;
  char *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  double v47;
  double v48;
  char *v49;
  double *v50;
  uint64_t v51;
  double *v52;
  char *v53;
  CFTypeRef v54;
  CFTypeRef v55;
  CFTypeRef v56;
  const void *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;

  v61 = *MEMORY[0x24BDAC8D0];
  if (cf != a3 && *(float *)&a4 != 0.0)
  {
    if (!cf || !a3)
    {
      *a5 = 0;
      return;
    }
    os_unfair_lock_lock(this);
    info = RB::FontMixer::get_info((RB::FontMixer *)this, cf, a3);
    v11 = info;
    if (!info[12])
      goto LABEL_64;
    if (*(float *)&a4 == 1.0 && !info[13])
    {
      CFRetain(a3);
      *a5 = a3;
LABEL_67:
      os_unfair_lock_unlock(this);
      return;
    }
    v12 = 0;
    v13 = 0;
    v14 = *(_DWORD *)info;
    v15 = *((_DWORD *)info + 1);
    v16 = this + 265;
    v17 = 0x80000000;
    while (1)
    {
      if ((os_unfair_lock_opaque = v16[-3]._os_unfair_lock_opaque, os_unfair_lock_opaque == v14)
        && v16[-2]._os_unfair_lock_opaque == v15
        || os_unfair_lock_opaque == v15 && v16[-2]._os_unfair_lock_opaque == v14)
      {
        if (*(float *)&v16[-1]._os_unfair_lock_opaque == *(float *)&a4)
          break;
      }
      v19 = this[2]._os_unfair_lock_opaque;
      v20 = *(float *)&v16->_os_unfair_lock_opaque;
      v16 += 6;
      v21 = v19 - LODWORD(v20);
      if ((int)(v19 - LODWORD(v20)) > v17)
        v12 = v13;
      if (v21 > v17)
        v17 = v21;
      if (++v13 == 4)
      {
        v22 = &this[6 * v12];
        v23 = *(const void **)&v22[260]._os_unfair_lock_opaque;
        if (v23)
        {
          CFRelease(v23);
          v19 = this[2]._os_unfair_lock_opaque;
        }
        v24 = (CFTypeRef *)&v22[260];
        *(_QWORD *)&v22[260]._os_unfair_lock_opaque = 0;
        v25 = &this[6 * v12];
        *(_QWORD *)&v25[262]._os_unfair_lock_opaque = *(_QWORD *)v11;
        v25[264]._os_unfair_lock_opaque = a4;
        this[2]._os_unfair_lock_opaque = v19 + 1;
        v25[265]._os_unfair_lock_opaque = v19 + 1;
        if (*((_QWORD *)v11 + 2))
        {
          v59 = 0;
          v60 = 0;
          Variations = CGFontGetVariations();
          v27 = CGFontGetVariations();
          v29 = *((_QWORD *)v11 + 2);
          if (v29 >> 60)
            goto LABEL_56;
          v30 = v27;
          v31 = 16 * v29;
          if (16 * v29 <= 0x1000)
          {
            MEMORY[0x24BDAC7A8](v27, v28);
            v32 = (char *)&v58 - ((v31 + 15) & 0xFFFFFFFFFFFFFFF0);
            bzero(v32, v31);
            goto LABEL_36;
          }
          v32 = (char *)malloc_type_malloc(16 * v29, 0x16ADB4B9uLL);
          if (!v32)
            goto LABEL_55;
LABEL_36:
          v40 = *((_QWORD *)v11 + 2);
          if (v40)
          {
            v41 = 0;
            v42 = *((_QWORD *)v11 + 3);
            v44 = v59;
            v43 = v60;
            while (1)
            {
              v45 = v42 + 40 * v41;
              v46 = *(_DWORD *)(v45 + 8);
              v47 = *(double *)(v45 + 32);
              v48 = v47;
              if (v43)
                break;
LABEL_43:
              if (v44)
                goto LABEL_46;
LABEL_51:
              v53 = &v32[16 * v41];
              *(_DWORD *)v53 = v46;
              *((double *)v53 + 1) = v48 + (v47 - v48) * *(float *)&a4;
              if (++v41 == v40)
                goto LABEL_52;
            }
            v49 = v43;
            v50 = (double *)(Variations + 8);
            while (*((_DWORD *)v50 - 2) != v46)
            {
              v50 += 2;
              if (!--v49)
              {
                v48 = v47;
                goto LABEL_43;
              }
            }
            v48 = *v50;
            if (!v44)
              goto LABEL_51;
LABEL_46:
            v51 = v44;
            v52 = (double *)(v30 + 8);
            while (*((_DWORD *)v52 - 2) != v46)
            {
              v52 += 2;
              if (!--v51)
                goto LABEL_51;
            }
            v47 = *v52;
            goto LABEL_51;
          }
LABEL_52:
          v54 = (CFTypeRef)CGFontCreateWithVariations();
          if (*v24)
            CFRelease(*v24);
          *v24 = v54;
          if (v31 > 0x1000)
          {
LABEL_55:
            free(v32);
LABEL_56:
            v54 = *v24;
          }
          if (v54)
            goto LABEL_70;
        }
        v54 = CFRetain(cf);
        *v24 = v54;
        if (v54)
        {
LABEL_70:
          v55 = CFRetain(v54);
          v36 = v55;
          if (v55)
          {
            CFRetain(v55);
            v56 = CFRetain(v36);
            v57 = v56;
            if (v56)
            {
              v39 = (char *)CFRetain(v56);
              v60 = v39;
              CFRelease(v57);
              if (v39)
              {
                *a5 = CFRetain(v39);
                CFRelease(v39);
LABEL_63:
                CFRelease(v39);
LABEL_66:
                CFRelease(v36);
                goto LABEL_67;
              }
            }
LABEL_65:
            *a5 = 0;
            goto LABEL_66;
          }
        }
        goto LABEL_64;
      }
    }
    v33 = this[2]._os_unfair_lock_opaque + 1;
    this[2]._os_unfair_lock_opaque = v33;
    v16->_os_unfair_lock_opaque = v33;
    v34 = *(const void **)&v16[-5]._os_unfair_lock_opaque;
    if (v34)
    {
      v35 = CFRetain(v34);
      v36 = v35;
      if (v35)
      {
        CFRetain(v35);
        v37 = CFRetain(v36);
        v38 = v37;
        if (v37)
        {
          v39 = (char *)CFRetain(v37);
          v60 = v39;
          CFRelease(v38);
          if (v39)
          {
            *a5 = CFRetain(v39);
            CFRelease(v39);
            goto LABEL_63;
          }
        }
        goto LABEL_65;
      }
    }
LABEL_64:
    *a5 = 0;
    goto LABEL_67;
  }
  if (cf)
    CFRetain(cf);
  *a5 = cf;
}

void sub_209B431D4(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

CFTypeRef *RB::cf_ptr<RB::cf_ptr<CGFont *>>::~cf_ptr(CFTypeRef *a1)
{
  CFTypeRef v2;

  v2 = *a1;
  if (v2)
  {
    CFRelease(v2);
    if (*a1)
      CFRelease(*a1);
  }
  return a1;
}

void sub_209B432A0(_Unwind_Exception *exception_object)
{
  CFTypeRef *v1;

  if (*v1)
    CFRelease(*v1);
  _Unwind_Resume(exception_object);
}

BOOL RB::FontMixer::GlyphEquality::operator()(const __CFDictionary **a1, void *key, void *a3)
{
  unsigned int v3;
  unsigned __int16 v4;
  const __CFDictionary *v6;
  const __CFDictionary *v7;
  void *value;

  v3 = a3;
  v4 = (unsigned __int16)key;
  v6 = *a1;
  if (v6)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(v6, (const void *)key, (const void **)&value))
      v4 = (unsigned __int16)value;
  }
  v7 = a1[1];
  if (v7)
  {
    value = 0;
    if (CFDictionaryGetValueIfPresent(v7, (const void *)v3, (const void **)&value))
      LOWORD(v3) = (_WORD)value;
  }
  return v4 == (unsigned __int16)v3;
}

void RB::Symbol::Presentation::apply_interpolations(RB::Symbol::Presentation *this)
{
  uint64_t v1;
  RB::Symbol::Presentation *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unsigned int v8;
  unint64_t v9;
  int v10;
  char *v11;
  _QWORD *v12;
  char *v13;
  unint64_t v14;
  unsigned int *v15;
  float v16;
  uint64_t v17;
  float v18;
  char *v19;
  char *v20;
  uint64_t v21;
  uint64_t v22;
  float *v23;
  size_t v24;
  char *v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t *v28;
  uint64_t *v29;
  int v30;
  unsigned int v31;
  unint64_t v32;
  void **v33;
  uint64_t v34;
  unsigned int v35;
  unsigned int v36;
  uint64_t *v37;
  unsigned int v38;
  unint64_t v39;
  void **v40;
  uint64_t v41;
  unsigned int v42;
  BOOL v43;
  unsigned int *v44;
  unsigned int *v45;
  unint64_t *v46;
  void **v47;
  unint64_t v48;
  unsigned int v49;
  unsigned int v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  void **v54;
  unint64_t v55;
  unsigned int v56;
  unsigned int v57;
  unint64_t v58;
  uint64_t v59;
  unsigned int v60;
  unsigned int v61;
  unint64_t *v62;
  void **v63;
  unint64_t v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  unint64_t *v68;
  void **v69;
  unint64_t v70;
  uint64_t v71;
  float v72;
  float v73;
  unsigned int *v74;
  char *v75;
  char *v76;
  unsigned int v77;
  unsigned int v78;
  unsigned int v79;
  unsigned int v80;
  _QWORD *v82;
  unsigned int v83;
  _QWORD *v84;
  void ***v85;
  void ***v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  unsigned int v93;
  void ***v94;
  float v95;
  int v96;
  unsigned int *v97;
  _DWORD *v98;
  unsigned int v99;
  char *v101;
  RB::Symbol::Presentation *v102;
  int v103;
  char *v104;
  char *v105;
  char *v106;
  unsigned int *v107;
  unsigned int v108;
  unsigned int v109;
  uint64_t v110;
  unsigned int v111;
  unsigned int v112;
  char *v113;
  void *v114;
  uint64_t v115;
  unsigned int *v116;
  unsigned int *v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int *v120;
  unsigned int *v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t *v127;
  char *v128;
  RB::Symbol::Presentation *v129;
  uint64_t v130;
  uint64_t *v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  unint64_t v135;
  _DWORD *v136;
  unsigned int *v137;
  char *v138;
  _QWORD *v139;
  _QWORD *v140;
  uint64_t v141;
  char *v142;
  _QWORD *v143;
  unint64_t v144;
  char *v145;
  uint64_t v146;
  void ***v147;
  char *v148;
  uint64_t *v149;
  char v150;
  id *v151;
  uint64_t v152;
  void *v153;
  char v154;
  uint64_t v155;
  id v156;
  void **v157;
  unint64_t *v158;
  unint64_t v159;
  RB::Symbol::Presentation *v160;
  uint64_t v161;
  uint64_t v162;

  v162 = *MEMORY[0x24BDAC8D0];
  v1 = *((unsigned int *)this + 212);
  if (v1 >= 2)
  {
    v2 = this;
    v3 = (char *)this + 8;
    v156 = 0;
    v126 = (uint64_t)this + 2032;
    v4 = (v1 - 1);
    v128 = (char *)this + 8;
    v129 = this;
    while (1)
    {
      v5 = v1 - 1;
      v6 = (char *)*((_QWORD *)v2 + 105);
      if (!v6)
        v6 = v3;
      v141 = (v1 - 1);
      v142 = v6;
      v138 = &v6[416 * v5];
      v7 = *((_QWORD *)v138 + 49);
      if (!v7)
        goto LABEL_162;
      v8 = *((_DWORD *)v2 + 212);
      if ((_DWORD)v1 + 1 != v8)
      {
        if (v8 > v5)
        {
          v16 = *(float *)v7;
          if (*(float *)v7 < 0.0)
            v16 = 0.0;
          if (v16 > 1.0)
            v16 = 1.0;
          v17 = v4;
          do
          {
            if (v17 == v141)
              v18 = v16;
            else
              v18 = 1.0 - v16;
            v19 = &v142[416 * v17];
            v20 = v19 + 16;
            if (*((_QWORD *)v19 + 47))
              v20 = (char *)*((_QWORD *)v19 + 47);
            v21 = *((unsigned int *)v19 + 96);
            if ((_DWORD)v21)
            {
              v22 = 120 * v21;
              v23 = (float *)(v20 + 32);
              do
              {
                *v23 = *v23 * v18;
                v23 += 30;
                v22 -= 120;
              }
              while (v22);
            }
            ++v17;
          }
          while (v8 != (_DWORD)v17);
        }
        goto LABEL_161;
      }
      v9 = (unint64_t)&v142[416 * v1];
      v10 = *(unsigned __int8 *)(v7 + 8);
      v133 = v1 - 1;
      if (v10
        && (this = *(RB::Symbol::Presentation **)(*(_QWORD *)v9 + 16)) != 0
        && *(_QWORD *)(*(_QWORD *)v138 + 16)
        && (((*(unsigned __int16 *)(*(_QWORD *)v138 + 88) | (*(unsigned __int8 *)(*(_QWORD *)v138 + 90) << 16)) ^ (*(unsigned __int16 *)(*(_QWORD *)v9 + 88) | (*(unsigned __int8 *)(*(_QWORD *)v9 + 90) << 16))) & 0x200FF) == 0)
      {
        this = (RB::Symbol::Presentation *)-[RB::Symbol::Presentation canBeInterpolatedWith:](this, "canBeInterpolatedWith:");
        v134 = (int)this;
      }
      else
      {
        v134 = 0;
      }
      v11 = &v142[416 * v1];
      v12 = v11 + 16;
      v135 = v9;
      v136 = v11 + 384;
      LODWORD(v11) = *((_DWORD *)v11 + 96);
      v13 = &v142[416 * v141];
      v139 = v13 + 16;
      v140 = v12;
      v137 = (unsigned int *)(v13 + 384);
      v14 = (*((_DWORD *)v13 + 96) + (_DWORD)v11);
      v155 = 0;
      v132 = v4;
      if (v14 <= 0x200)
        break;
      v153 = malloc_type_malloc(8 * v14, 0xD3FAFDCuLL);
      v154 = 1;
      if (v153)
        goto LABEL_32;
      v15 = 0;
LABEL_86:
      v72 = *(float *)v7;
      if (*(float *)v7 < 0.0)
        v72 = 0.0;
      v160 = 0;
      v161 = 0x300000000;
      if (v72 <= 1.0)
        v73 = v72;
      else
        v73 = 1.0;
      v143 = v2;
      v144 = v135;
      v145 = v138;
      v146 = v7;
      v147 = &v157;
      v148 = (char *)&v152 + 4;
      v149 = &v152;
      v150 = v134;
      v151 = &v156;
      v152 = 0;
      if (v155)
      {
        v74 = &v15[2 * v155];
        v75 = &v142[416 * v1 + 376];
        v76 = &v142[416 * v141 + 376];
        do
        {
          if (*((_BYTE *)v15 + 4))
            v77 = *v15;
          else
            v77 = -1;
          if (*((_BYTE *)v15 + 4))
            v78 = -1;
          else
            v78 = *v15;
          while (1)
          {
            v79 = v152;
            v80 = HIDWORD(v152);
            if (HIDWORD(v152) >= v77 || v152 >= v78)
              break;
            RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()((uint64_t *)&v143);
          }
          if (*((_BYTE *)v15 + 4))
          {
            ++HIDWORD(v152);
            if (*(_QWORD *)v75)
              v82 = *(_QWORD **)v75;
            else
              v82 = v140;
          }
          else
          {
            LODWORD(v152) = v152 + 1;
            if (*(_QWORD *)v76)
              v82 = *(_QWORD **)v76;
            else
              v82 = v139;
            v80 = v79;
          }
          v83 = v161;
          if (HIDWORD(v161) < (v161 + 1))
          {
            RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(&v157, v161 + 1);
            v83 = v161;
          }
          v84 = &v82[15 * v80];
          v85 = (void ***)v160;
          if (!v160)
            v85 = &v157;
          v86 = &v85[15 * v83];
          v87 = *(_OWORD *)v84;
          v88 = *((_OWORD *)v84 + 1);
          v89 = *((_OWORD *)v84 + 3);
          *((_OWORD *)v86 + 2) = *((_OWORD *)v84 + 2);
          *((_OWORD *)v86 + 3) = v89;
          *(_OWORD *)v86 = v87;
          *((_OWORD *)v86 + 1) = v88;
          v90 = *((_OWORD *)v84 + 4);
          v91 = *((_OWORD *)v84 + 5);
          v92 = *((_OWORD *)v84 + 6);
          v86[14] = (void **)v84[14];
          *((_OWORD *)v86 + 5) = v91;
          *((_OWORD *)v86 + 6) = v92;
          *((_OWORD *)v86 + 4) = v90;
          v93 = v161;
          LODWORD(v161) = v161 + 1;
          if (*((_BYTE *)v15 + 5))
          {
            v94 = (void ***)v160;
            if (!v160)
              v94 = &v157;
            if (*((_BYTE *)v15 + 4))
              v95 = 1.0 - v73;
            else
              v95 = v73;
            *(float *)&v94[15 * v93 + 4] = *(float *)&v94[15 * v93 + 4] * v95;
          }
          v15 += 2;
        }
        while (v15 != v74);
      }
      v3 = v128;
      v2 = v129;
      v96 = v141;
      v98 = v136;
      v97 = v137;
      while (1)
      {
        v99 = *v97;
        if (HIDWORD(v152) >= *v98 || v152 >= v99)
          break;
        RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()((uint64_t *)&v143);
      }
      v101 = &v142[416 * v96];
      v102 = (RB::Symbol::Presentation *)*((_QWORD *)v101 + 47);
      *((_QWORD *)v101 + 47) = v160;
      v160 = v102;
      *v97 = v161;
      LODWORD(v161) = v99;
      v103 = *((_DWORD *)v101 + 97);
      *((_DWORD *)v101 + 97) = HIDWORD(v161);
      HIDWORD(v161) = v103;
      RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::swap_inline(v139, &v157);
      v104 = (char *)*((_QWORD *)v2 + 105);
      if (!v104)
        v104 = v3;
      v105 = &v104[416 * v96];
      v106 = v105 + 416;
      v107 = (unsigned int *)*((_QWORD *)v105 + 52);
      v4 = v132;
      if (v107)
      {
        v108 = *((_DWORD *)v2 + 510);
        v109 = v108 + 1;
        if (*((_DWORD *)v2 + 511) < v108 + 1)
        {
          RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v126, v109);
          v108 = *((_DWORD *)v2 + 510);
          v107 = *(unsigned int **)v106;
          v109 = v108 + 1;
        }
        *(_QWORD *)(*((_QWORD *)v2 + 254) + 8 * v108) = v107;
        *(_QWORD *)v106 = 0;
        *((_DWORD *)v2 + 510) = v109;
      }
      v110 = *((_QWORD *)v105 + 53);
      if (v110)
      {
        v111 = *((_DWORD *)v2 + 510);
        v112 = v111 + 1;
        if (*((_DWORD *)v2 + 511) < v111 + 1)
        {
          RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v126, v112);
          v111 = *((_DWORD *)v2 + 510);
          v110 = *((_QWORD *)v105 + 53);
          v112 = v111 + 1;
        }
        *(_QWORD *)(*((_QWORD *)v2 + 254) + 8 * v111) = v110;
        *((_QWORD *)v105 + 53) = 0;
        *((_DWORD *)v2 + 510) = v112;
      }
      if (*((_QWORD *)v2 + 105))
        v113 = (char *)*((_QWORD *)v2 + 105);
      else
        v113 = v3;
      *((_QWORD *)v106 + 49) = 0;
      v114 = (void *)*((_QWORD *)v106 + 47);
      if (v114)
        free(v114);
      v115 = 0x4EC4EC4EC4EC4EC5 * ((v106 - v113) >> 5);
      v116 = *(unsigned int **)&v113[32 * ((v106 - v113) >> 5) + 8];
      v5 = v133;
      if (v116)
      {
        v117 = v116 + 2;
        do
        {
          v118 = __ldxr(v117);
          v119 = v118 - 1;
        }
        while (__stlxr(v119, v117));
        if (!v119)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v116 + 8))(v116);
        }
      }
      v120 = *(unsigned int **)v106;
      if (*(_QWORD *)v106)
      {
        v121 = v120 + 2;
        do
        {
          v122 = __ldxr(v121);
          v123 = v122 - 1;
        }
        while (__stlxr(v123, v121));
        if (!v123)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v120 + 8))(v120);
        }
      }
      v124 = (*((_DWORD *)v2 + 212) - 1);
      *((_DWORD *)v2 + 212) = v124;
      v125 = v124 - v115;
      if (v125)
        memmove(v106, v106 + 416, 416 * v125);
      this = v160;
      if (v160)
        free(v160);
      if (v154)
        free(v153);
LABEL_161:
      *((_QWORD *)v138 + 49) = 0;
      v142[416 * v141 + 410] = 1;
LABEL_162:
      --v4;
      v1 = v5;
      if (!(_DWORD)v5)
      {

        return;
      }
    }
    MEMORY[0x24BDAC7A8](this, 8 * v14);
    v25 = (char *)&v126 - ((v24 + 15) & 0xFFFFFFFF0);
    bzero(v25, v24);
    v153 = v25;
    v154 = 0;
LABEL_32:
    v157 = &v153;
    v158 = (unint64_t *)&v155;
    v159 = v14;
    v26 = *v136;
    v27 = *v137;
    if (*(_QWORD *)&v142[416 * v1 + 376])
      v28 = *(uint64_t **)&v142[416 * v1 + 376];
    else
      v28 = v140;
    if (*(_QWORD *)&v142[416 * v141 + 376])
      v29 = *(uint64_t **)&v142[416 * v141 + 376];
    else
      v29 = v139;
    v30 = *(unsigned __int8 *)(v7 + 16);
    v130 = v1;
    v131 = v28;
    if (v30)
    {
      if (v26)
      {
        v31 = 0;
        while (RB::Symbol::Glyph::Layer::contains(*v28, *(_DWORD *)(v7 + 12)))
        {
          v32 = *v158;
          if (*v158 < v159)
          {
            v33 = v157;
            *v158 = v32 + 1;
            v34 = (uint64_t)*v33 + 8 * v32;
            *(_DWORD *)v34 = v31;
            *(_WORD *)(v34 + 4) = 1;
          }
          if (v26 == ++v31)
          {
            v35 = 0;
            v31 = v26;
            goto LABEL_52;
          }
        }
        v127 = v29;
        v37 = v28;
        v35 = v26 - v31;
        v38 = v26 - 1;
        do
        {
          if (!RB::Symbol::Glyph::Layer::contains(v37[15 * v38], *(_DWORD *)(v7 + 12)))
            break;
          --v38;
          --v35;
        }
        while (v35);
        v29 = v127;
      }
      else
      {
        v35 = 0;
        v31 = 0;
      }
LABEL_52:
      v36 = 0;
      if (v27)
      {
        while (RB::Symbol::Glyph::Layer::contains(*v29, *(_DWORD *)(v7 + 12)))
        {
          v39 = *v158;
          if (*v158 < v159)
          {
            v40 = v157;
            *v158 = v39 + 1;
            v41 = (uint64_t)*v40 + 8 * v39;
            *(_DWORD *)v41 = v36;
            *(_WORD *)(v41 + 4) = 0;
          }
          if (v27 == ++v36)
          {
            v36 = v27;
            v26 = v35;
            v27 = 0;
            goto LABEL_62;
          }
        }
        v42 = v27 - 1;
        v27 -= v36;
        do
        {
          if (!RB::Symbol::Glyph::Layer::contains(v29[15 * v42], *(_DWORD *)(v7 + 12)))
            break;
          --v42;
          --v27;
        }
        while (v27);
      }
      v26 = v35;
LABEL_62:
      v2 = v129;
    }
    else
    {
      v36 = 0;
      v31 = 0;
    }
    v143 = &v157;
    v144 = __PAIR64__(v36, v31);
    v43 = RB::lcs_diff<RB::Symbol::Presentation::Layer,RB::Symbol::Presentation::apply_interpolations(void)::$_2,RB::Symbol::Presentation::apply_interpolations(void)::$_3>(v26, v131, v27, (uint64_t)v29, (uint64_t *)&v143);
    v44 = v136;
    v45 = v137;
    if (!v43)
    {
      if (v26)
      {
        v47 = v157;
        v46 = v158;
        v48 = *v158;
        v49 = v31;
        v50 = v26;
        do
        {
          if (v48 < v159)
          {
            v51 = v48 + 1;
            *v46 = v48 + 1;
            v52 = (uint64_t)*v47 + 8 * v48;
            *(_DWORD *)v52 = v49;
            *(_WORD *)(v52 + 4) = 257;
            v48 = v51;
          }
          ++v49;
          --v50;
        }
        while (v50);
      }
      if (v27)
      {
        v54 = v157;
        v53 = v158;
        v55 = *v158;
        v56 = v36;
        v57 = v27;
        do
        {
          if (v55 < v159)
          {
            v58 = v55 + 1;
            *v53 = v55 + 1;
            v59 = (uint64_t)*v54 + 8 * v55;
            *(_DWORD *)v59 = v56;
            *(_WORD *)(v59 + 4) = 256;
            v55 = v58;
          }
          ++v56;
          --v57;
        }
        while (v57);
      }
    }
    if (*(_BYTE *)(v7 + 16))
    {
      v60 = v31 + v26;
      v61 = *v44;
      if (v31 + v26 < *v44)
      {
        v63 = v157;
        v62 = v158;
        v64 = *v158;
        do
        {
          if (v64 < v159)
          {
            *v62 = v64 + 1;
            v65 = (uint64_t)*v63 + 8 * v64;
            *(_DWORD *)v65 = v60;
            *(_WORD *)(v65 + 4) = 1;
            v61 = *v44;
            ++v64;
          }
          ++v60;
        }
        while (v60 < v61);
      }
      v66 = v27 + v36;
      v67 = *v45;
      if (v27 + v36 < *v45)
      {
        v69 = v157;
        v68 = v158;
        v70 = *v158;
        do
        {
          if (v70 < v159)
          {
            *v68 = v70 + 1;
            v71 = (uint64_t)*v69 + 8 * v70;
            *(_DWORD *)v71 = v66;
            *(_WORD *)(v71 + 4) = 0;
            v67 = *v45;
            ++v70;
          }
          ++v66;
        }
        while (v66 < v67);
      }
    }
    v15 = (unsigned int *)v153;
    v1 = v130;
    goto LABEL_86;
  }
}

void sub_209B43CC0(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 608);
  if (v3)
    free(v3);
  if (*(_BYTE *)(v1 + 224))
    free(*(void **)(v1 + 216));

  _Unwind_Resume(a1);
}

void RB::Symbol::Presentation::print(RB::Symbol::Presentation *this, std::string *a2, os_unfair_lock_t lock, char a4)
{
  float v6;
  float64x2_t v7;
  float64x2_t v8;
  int64x2_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;
  float v15;
  int v16;
  uint64_t v17;
  int *v18;
  int v19;
  float32x2_t v21;
  uint32x2_t v22;
  uint64_t *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  const char *v28;
  uint64_t v29;
  char i;
  char v31;
  uint64_t v32;
  char *v37;
  RB::Symbol::Model **v38;
  uint64_t v39;
  double v40;
  uint64_t v41;
  const char *v42;
  RB::Symbol::Model *v43;
  float32x2_t v44;
  uint32x2_t v45;
  float32x2_t v46;
  uint32x2_t v47;
  char *v48;
  RB::Symbol::Glyph::Sublayers ***v49;
  unsigned int v50;
  RB::Symbol::Glyph::Sublayers ***v51;
  unint64_t v52;
  const char *v53;
  RB::Symbol::GlyphCache *v54;
  RB::Symbol::Glyph::Sublayers **v55;
  uint64_t v56;
  unsigned int *v57;
  uint64_t v58;
  os_unfair_lock_s *v59;
  uint64_t v60;
  const char *v61;
  std::string *v62;
  int v63;
  float v64;
  float v65;
  float v66;
  float v67;
  float v68;
  float v69;
  float v70;
  float32x2_t v71;
  uint32x2_t v72;
  float32x2_t v73;
  uint32x2_t v74;
  float v75;
  char *v76;
  _QWORD *v77;
  uint64_t v78;
  _DWORD *v79;
  uint64_t v80;
  os_unfair_lock_s *locka;
  std::string __p[2];

  if ((a4 & 1) != 0)
  {
    locka = 0;
  }
  else
  {
    os_unfair_lock_lock(lock);
    locka = lock;
  }
  RB::SexpString::push(a2, "symbol-presentation");
  RB::SexpString::printf(a2, 0, "(time %.4f)", *(double *)&lock[10]._os_unfair_lock_opaque);
  v6 = *((float *)this + 230);
  if (v6 != 0.0)
    RB::SexpString::printf(a2, 0, "(max-velocity %d)", (int)(float)(v6 + 0.5));
  v7 = *((float64x2_t *)this + 54);
  v8 = *((float64x2_t *)this + 56);
  v9 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 55), (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v8));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9).u64[0] & 0x8000000000000000) == 0)
    RB::SexpString::printf(a2, 0, "(transform %g %g %g %g %.2f %.2f)", v7.f64[0], v7.f64[1], *((double *)this + 110), *((double *)this + 111), v8.f64[0], v8.f64[1]);
  if (*(_QWORD *)&lock[6]._os_unfair_lock_opaque)
  {
    RB::SexpString::push(a2, "animations");
    v10 = *(_QWORD *)&lock[6]._os_unfair_lock_opaque;
    if (v10)
    {
      v11 = *(_QWORD *)&lock[4]._os_unfair_lock_opaque;
      v12 = v11 + 88 * v10;
      while (1)
      {
        v13 = *(unsigned int *)(v11 + 4);
        v14 = "unknown";
        if (v13 <= 0xB)
          v14 = (&off_24C22AF28)[v13];
        RB::SexpString::push(a2, v14);
        RB::SexpString::printf(a2, 0, "(id %u)", *(_DWORD *)v11);
        if ((*(_QWORD *)(v11 + 48) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
          RB::SexpString::printf(a2, 0, "(begin %.4f)", *(double *)(v11 + 48));
        v15 = *(float *)(v11 + 24);
        if (v15 != 1.0)
          RB::SexpString::printf(a2, 0, "(speed %g)", v15);
        v16 = *(_DWORD *)(v11 + 12);
        if ((v16 & 0x800) != 0)
        {
          RB::SexpString::printf(a2, 0, "(repeat %g)", *(float *)(v11 + 28));
          v16 = *(_DWORD *)(v11 + 12);
        }
        if ((v16 & 0xF000B010) != 0)
          break;
LABEL_30:
        v21 = *(float32x2_t *)(v11 + 40);
        v22 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v21));
        if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0)
          RB::SexpString::printf(a2, 0, "(axis (%g . %g))", v21.f32[0], v21.f32[1]);
        v23 = (uint64_t *)*((_QWORD *)this + 253);
        if (v23)
        {
          v24 = v23[1];
          if (v24)
          {
            v25 = *v23;
            v26 = *v23 + 24 * v24;
            do
            {
              if (*(_DWORD *)v25 == *(_DWORD *)v11)
              {
                RB::SexpString::push(a2, "keyframes");
                v27 = *(_DWORD *)(v25 + 4);
                if (v27)
                {
                  if (v27 == 1)
                    v28 = "from";
                  else
                    v28 = "to";
                  RB::SexpString::printf(a2, 0, "(symbol %s)", v28);
                }
                v29 = *(_QWORD *)(v25 + 8);
                if (!v29)
                  v29 = RB::Symbol::KeyframeStorage::commit(*(RB::Symbol::KeyframeStorage **)(v25 + 16));
                for (i = *(_BYTE *)v29; (i & 0xF) != 0; i = v31)
                {
                  RB::Symbol::Keyframes::print((int *)v29, a2, *(_DWORD *)(v25 + 4), *(_QWORD *)(v25 + 16));
                  v31 = *(_BYTE *)(v29 + 16);
                  v29 += 16;
                }
                RB::SexpString::pop(a2);
              }
              v25 += 24;
            }
            while (v25 != v26);
          }
        }
        RB::SexpString::pop(a2);
        v11 += 88;
        if (v11 == v12)
          goto LABEL_49;
      }
      RB::SexpString::push(a2, "flags");
      v17 = -28;
      v18 = &dword_24C22AC90;
      while (1)
      {
        if (((*(v18 - 2) >> *(_DWORD *)(v11 + 4)) & 1) != 0)
        {
          v19 = *v18;
          if ((unint64_t)(v17 + 3) <= 0xFFFFFFFFFFFFFFEDLL)
          {
            if ((*(_DWORD *)(v11 + 12) & v19) == 0)
              goto LABEL_27;
LABEL_26:
            RB::SexpString::print(a2, 0, *((const char **)v18 + 1));
            goto LABEL_27;
          }
          if ((*(_DWORD *)(v11 + 12) & *(v18 - 1)) == v19)
            goto LABEL_26;
        }
LABEL_27:
        v18 += 6;
        if (__CFADD__(v17++, 1))
        {
          RB::SexpString::pop(a2);
          goto LABEL_30;
        }
      }
    }
LABEL_49:
    RB::SexpString::pop(a2);
  }
  if (*((_DWORD *)this + 212))
  {
    RB::SexpString::push(a2, "symbols");
    v32 = *((unsigned int *)this + 212);
    __asm { FMOV            V12.2S, #1.0 }
    while (v32)
    {
      --v32;
      if (*((_QWORD *)this + 105))
        v37 = (char *)*((_QWORD *)this + 105);
      else
        v37 = (char *)this + 8;
      v38 = (RB::Symbol::Model **)&v37[416 * v32];
      v39 = RB::Symbol::Model::glyph_info(*v38);
      RB::SexpString::push(a2, (const char *)objc_msgSend((id)objc_msgSend(*((id *)*v38 + 2), "name"), "UTF8String"));
      objc_msgSend(*((id *)*v38 + 2), "pointSize");
      RB::SexpString::printf(a2, 0, "(size %g)", v40);
      v41 = *(unsigned int *)(v39 + 24);
      v42 = "unknown";
      if (v41 <= 5)
        v42 = (&off_24C22AF88)[v41];
      RB::SexpString::printf(a2, 0, "(mode %s)", v42);
      if (*((_DWORD *)*v38 + 20) != -1)
        RB::SexpString::printf(a2, 0, "(value-index %d)", *((_DWORD *)*v38 + 20));
      RB::SexpString::printf(a2, 0, "(alignment-rect %.2f %.2f %.2f %.2f)", COERCE_FLOAT(*(_QWORD *)(v39 + 72)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v39 + 72))), COERCE_FLOAT(*(_QWORD *)(v39 + 80)), COERCE_FLOAT(HIDWORD(*(_QWORD *)(v39 + 80))));
      v43 = *v38;
      v44 = *(float32x2_t *)((char *)*v38 + 48);
      v45 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v44));
      if ((vpmax_u32(v45, v45).u32[0] & 0x80000000) != 0)
      {
        RB::SexpString::printf(a2, 0, "(position %.2f %.2f)", v44.f32[0], v44.f32[1]);
        v43 = *v38;
      }
      v46 = *(float32x2_t *)((char *)v43 + 40);
      v47 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v46, (float32x2_t)0x3F0000003F000000));
      if ((vpmax_u32(v47, v47).u32[0] & 0x80000000) != 0)
        RB::SexpString::printf(a2, 0, "(anchor-point %.2f %.2f)", v46.f32[0], v46.f32[1]);
      v48 = &v37[416 * v32];
      if (*((_DWORD *)v48 + 96))
      {
        RB::SexpString::push(a2, "layers");
        if (*(_QWORD *)&v37[416 * v32 + 376])
          v49 = *(RB::Symbol::Glyph::Sublayers ****)&v37[416 * v32 + 376];
        else
          v49 = (RB::Symbol::Glyph::Sublayers ***)(v48 + 16);
        v50 = *((_DWORD *)v48 + 96);
        if (v50)
        {
          v51 = &v49[15 * v50];
          do
          {
            v52 = ((unint64_t)*((unsigned int *)*v49 + 21) >> 8) & 0xF;
            v53 = "unknown";
            if (v52 <= 0xC)
              v53 = (&off_24C22AFB8)[v52];
            v54 = (RB::Symbol::GlyphCache *)RB::SexpString::push(a2, v53);
            v55 = *v49;
            if (*((_DWORD *)*v49 + 12))
            {
              v56 = RB::Symbol::GlyphCache::shared(v54);
              memset(__p, 0, 41);
              if ((*v49)[5])
                v57 = (unsigned int *)(*v49)[5];
              else
                v57 = (unsigned int *)(*v49 + 3);
              v58 = *((unsigned int *)*v49 + 12);
              if ((_DWORD)v58)
              {
                v59 = (os_unfair_lock_s *)v56;
                v60 = 4 * v58;
                do
                {
                  v61 = (const char *)objc_msgSend((id)RB::Symbol::GlyphCache::tag(v59, *v57), "UTF8String");
                  RB::SexpString::print(__p, 0, v61);
                  ++v57;
                  v60 -= 4;
                }
                while (v60);
                v62 = __p;
                if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
                  v62 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
              }
              else
              {
                v62 = __p;
              }
              RB::SexpString::printf(a2, 0, "(tags %s)", (const char *)v62);
              if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
                operator delete(__p[0].__r_.__value_.__l.__data_);
              v55 = *v49;
            }
            if ((*((_DWORD *)v55 + 21) & 0xF00) == 0x900)
            {
              RB::SexpString::printf(a2, 0, "(color \"%s\")", (const char *)-[RB::Symbol::Glyph::Sublayers UTF8String](v55[1], "UTF8String"));
              v55 = *v49;
            }
            v63 = *((_DWORD *)v55 + 17);
            if (v63)
              RB::SexpString::printf(a2, 0, "(timing-group %u)", v63);
            v64 = *((float *)v49 + 5);
            if (v64 != -32768.0)
              RB::SexpString::printf(a2, 0, "(draw-color %.2g %.2g %.2g %.2f)", *((float *)v49 + 2), *((float *)v49 + 3), *((float *)v49 + 4), v64);
            v65 = *((float *)v49 + 6);
            if (v65 != 1.0)
              RB::SexpString::printf(a2, 0, "(draw-alpha %.2g)", v65);
            if ((*((_BYTE *)*v49 + 86) & 0x40) != 0)
            {
              v66 = *((float *)*v49 + 18) <= 0.0 ? *((float *)v49 + 8) * *((float *)v49 + 7) : *((float *)v49 + 8);
              if (v66 != 0.0)
                RB::SexpString::printf(a2, 0, "(clip-alpha %.2g)", v66);
            }
            v67 = *((float *)v49 + 9);
            if (v67 != 1.0)
              RB::SexpString::printf(a2, 0, "(scale %.2f)", v67);
            v68 = *((float *)v49 + 10);
            if (v68 != 1.0)
              RB::SexpString::printf(a2, 0, "(badge-scale %.2f)", v68);
            v69 = *((float *)v49 + 11);
            if (v69 != 0.0)
              RB::SexpString::printf(a2, 0, "(symbol-rotation %.2f deg)", (float)(v69 * 180.0) * 0.318309886);
            v70 = *((float *)v49 + 12);
            if (v70 != 0.0)
              RB::SexpString::printf(a2, 0, "(layer-rotation %.2f deg)", (float)(v70 * 180.0) * 0.318309886);
            v71 = (float32x2_t)v49[12];
            v72 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v71, _D12));
            if ((vpmax_u32(v72, v72).u32[0] & 0x80000000) != 0)
              RB::SexpString::printf(a2, 0, "(size-scale %.2f %.2f)", v71.f32[0], v71.f32[1]);
            v73 = (float32x2_t)v49[8];
            v74 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v73));
            if ((vpmax_u32(v74, v74).u32[0] & 0x80000000) != 0)
              RB::SexpString::printf(a2, 0, "(translation %g %g)", v73.f32[0], v73.f32[1]);
            v75 = *((float *)v49 + 13);
            if (v75 != 1.0)
              RB::SexpString::printf(a2, 0, "(stroke-length %g)", v75);
            if ((*((_DWORD *)*v49 + 21) & 0xC0000) == 0x80000)
              RB::Symbol::Glyph::Sublayers::print(**v49, a2);
            RB::SexpString::pop(a2);
            v49 += 15;
          }
          while (v49 != v51);
        }
        RB::SexpString::pop(a2);
      }
      v76 = &v37[416 * v32];
      if (*((_QWORD *)v76 + 50))
      {
        RB::SexpString::push(a2, "merged-layers");
        v77 = (_QWORD *)*((_QWORD *)v76 + 50);
        v78 = v77[1];
        if (v78)
        {
          v79 = (_DWORD *)*v77;
          v80 = *v77 + 8 * v78;
          do
          {
            RB::SexpString::printf(a2, 0, "(%d . %d)", *v79, v79[1]);
            v79 += 2;
          }
          while (v79 != (_DWORD *)v80);
        }
        RB::SexpString::pop(a2);
      }
      RB::SexpString::pop(a2);
    }
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
  if ((a4 & 1) == 0)
    os_unfair_lock_unlock(locka);
}

void sub_209B44748(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_unfair_lock_t lock, int a16, char a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if ((a17 & 1) == 0)
    os_unfair_lock_unlock(lock);
  _Unwind_Resume(exception_object);
}

void RB::Symbol::KeyframeStorage::~KeyframeStorage(RB::Symbol::KeyframeStorage *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 226);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 96);
  if (v3)
    free(v3);
}

uint64_t RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::~vector(uint64_t a1)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t i;
  RB::Symbol::Glyph::Layer *v5;

  v2 = *(_QWORD **)a1;
  v3 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v3)
  {
    for (i = 0; i < v3; ++i)
    {
      v5 = (RB::Symbol::Glyph::Layer *)v2[i];
      v2[i] = 0;
      if (v5)
      {
        RB::Symbol::Glyph::Layer::~Layer(v5);
        v3 = *(unsigned int *)(a1 + 8);
      }
    }
    v2 = *(_QWORD **)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

uint64_t RB::vector<RB::path_ptr,0ul,unsigned int>::~vector(uint64_t a1)
{
  uint64_t *v2;
  unint64_t v3;
  uint64_t *v4;

  v2 = *(uint64_t **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    v3 = 0;
    v4 = v2 + 1;
    do
    {
      RBPathRelease(*(v4 - 1), *v4);
      ++v3;
      v4 += 2;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    v2 = *(uint64_t **)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

uint64_t RB::vector<RB::refcounted_ptr<RB::Symbol::Model const>,0ul,unsigned int>::~vector(uint64_t a1)
{
  _QWORD *v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD **)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    v3 = 0;
    do
    {
      v4 = (unsigned int *)v2[v3];
      if (v4)
      {
        v5 = v4 + 2;
        do
        {
          v6 = __ldxr(v5);
          v7 = v6 - 1;
        }
        while (__stlxr(v7, v5));
        if (!v7)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 8))(v4);
        }
      }
      ++v3;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    v2 = *(_QWORD **)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

uint64_t RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::~vector(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t v4;
  unsigned int **v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;

  v2 = *(_QWORD **)(a1 + 832);
  if (v2)
    v3 = v2;
  else
    v3 = (_QWORD *)a1;
  if (*(_DWORD *)(a1 + 840))
  {
    v4 = 0;
    do
    {
      v5 = (unsigned int **)&v3[52 * v4];
      v5[49] = 0;
      v6 = v5[47];
      if (v6)
        free(v6);
      v7 = (unsigned int *)v3[52 * v4 + 1];
      if (v7)
      {
        v8 = v7 + 2;
        do
        {
          v9 = __ldxr(v8);
          v10 = v9 - 1;
        }
        while (__stlxr(v10, v8));
        if (!v10)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
        }
      }
      v11 = *v5;
      if (*v5)
      {
        v12 = v11 + 2;
        do
        {
          v13 = __ldxr(v12);
          v14 = v13 - 1;
        }
        while (__stlxr(v14, v12));
        if (!v14)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
        }
      }
      ++v4;
    }
    while (v4 < *(unsigned int *)(a1 + 840));
    v2 = *(_QWORD **)(a1 + 832);
  }
  if (v2)
    free(v2);
  return a1;
}

double RB::Symbol::Presentation::bounding_rect(RB::Symbol::Presentation *this, double a2, double a3, float64x2_t a4, int32x4_t a5)
{
  char *v5;
  int v6;
  char *v8;
  float32x2_t *v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;
  double v16;
  int32x4_t v17;
  float32x2_t v19[2];

  v19[0] = 0;
  v19[1] = 0;
  if (*((_QWORD *)this + 105))
    v5 = (char *)*((_QWORD *)this + 105);
  else
    v5 = (char *)this + 8;
  v6 = *((_DWORD *)this + 212);
  if (!v6)
    return 0.0;
  v8 = &v5[416 * v6];
  do
  {
    if (*((_QWORD *)v5 + 47))
      v9 = (float32x2_t *)*((_QWORD *)v5 + 47);
    else
      v9 = (float32x2_t *)(v5 + 16);
    v10 = *((unsigned int *)v5 + 96);
    if ((_DWORD)v10)
    {
      v11 = 120 * v10;
      do
      {
        LODWORD(a4.f64[0]) = v9[4].i32[0];
        *(float *)&a3 = v9[3].f32[0] * *(float *)a4.f64;
        *(float *)&a2 = *(float *)&a3 * *(float *)(*(_QWORD *)v9 + 72);
        if (*(float *)&a2 > 0.0)
        {
          RB::Symbol::Presentation::Layer::bounding_rect(v9, this, (RB::Symbol::Model **)v5, a2, a3, a4, a5);
          RB::Rect::Union(v19, v12, v13, v14, v15, v16, v17);
        }
        v9 += 15;
        v11 -= 120;
      }
      while (v11);
    }
    v5 += 416;
  }
  while (v5 != v8);
  return *(double *)v19;
}

void RB::Symbol::Presentation::Layer::bounding_rect(float32x2_t *this, const RB::Symbol::Presentation *a2, RB::Symbol::Model **a3, double a4, double a5, float64x2_t a6, int32x4_t a7)
{
  int8x8_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float64x2_t v12;
  __int128 v13;
  __int128 v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float64x2_t v18;
  __int128 v19;
  __int128 v20;
  float64x2_t v21;
  __int128 v22;
  __int128 v23;

  if (!*((_BYTE *)a3 + 410)
    && (LODWORD(a4) = this[5].i32[1], *(float *)&a4 == 0.0)
    && (LODWORD(a4) = this[6].i32[0], *(float *)&a4 == 0.0))
  {
    v17 = *(float32x2_t *)(RB::Symbol::Model::glyph_info(*a3) + 80);
    v18.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a2);
    v21 = v18;
    v22 = v19;
    v23 = v20;
    v15 = 0;
    v16 = v17;
  }
  else
  {
    v9 = RB::Symbol::Glyph::Layer::content_bounds(*(float32x2_t ***)this, a4, a5, a6, a7);
    v11 = v10;
    v12.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a2);
    v21 = v12;
    v22 = v13;
    v23 = v14;
    v15 = (float32x2_t)v9;
    v16 = v11;
  }
  RB::operator*(&v21, v15, v16);
}

uint64_t RB::Symbol::Presentation::style_mask(RB::Symbol::Presentation *this)
{
  char *v1;
  int v2;
  uint64_t result;
  char *v4;
  float *v5;
  int v6;
  float *v7;

  v1 = (char *)this + 8;
  if (*((_QWORD *)this + 105))
    v1 = (char *)*((_QWORD *)this + 105);
  v2 = *((_DWORD *)this + 212);
  if (!v2)
    return 0;
  result = 0;
  v4 = &v1[416 * v2];
  do
  {
    v5 = (float *)(v1 + 16);
    if (*((_QWORD *)v1 + 47))
      v5 = (float *)*((_QWORD *)v1 + 47);
    v6 = *((_DWORD *)v1 + 96);
    if (v6)
    {
      v7 = &v5[30 * v6];
      do
      {
        if ((float)((float)(v5[6] * v5[8]) * *(float *)(*(_QWORD *)v5 + 72)) > 0.0 && v5[5] == -32768.0)
          result = (1 << (BYTE1(*(_DWORD *)(*(_QWORD *)v5 + 84)) & 0xF)) | result;
        v5 += 30;
      }
      while (v5 != v7);
    }
    v1 += 416;
  }
  while (v1 != v4);
  return result;
}

BOOL RB::lcs_diff<RB::Symbol::Presentation::Layer,RB::Symbol::Presentation::apply_interpolations(void)::$_2,RB::Symbol::Presentation::apply_interpolations(void)::$_3>(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _BOOL8 v27;
  uint64_t v28;
  size_t v30;
  char *v31;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  _QWORD *v45;
  uint64_t v46;
  uint64_t v48;
  uint64_t *v49;
  uint64_t v50;
  unsigned int v51;
  int v52;
  unsigned int v53;
  uint64_t v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;
  uint64_t *v58;
  uint64_t v59;
  unint64_t *v60;
  unint64_t v61;
  BOOL v62;
  uint64_t v63;
  int v64;
  _DWORD *v65;
  int v66;
  _QWORD *v67;
  unint64_t v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  uint64_t *v72;
  int v73;
  unint64_t v74;
  _BOOL8 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t *v85;
  _QWORD *v86;
  char *v87;
  size_t v88[2];
  unint64_t v89;
  unint64_t v90;
  char v91[1024];
  uint64_t v92;

  v6 = a4;
  v7 = a3;
  v9 = a1;
  v92 = *MEMORY[0x24BDAC8D0];
  if (a1 >= a3)
    v10 = a3;
  else
    v10 = a1;
  if (v10 < 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = a2;
    v13 = a4;
    while (1)
    {
      v14 = *v12;
      v15 = *(_DWORD *)(*v12 + 84);
      v16 = (v15 >> 8) & 0xF;
      v17 = *(_DWORD *)(*(_QWORD *)v13 + 84);
      if (v16 != ((v17 >> 8) & 0xF) || ((v17 ^ v15) & 0x400000) != 0)
        break;
      if (v16 == 9)
      {
        a1 = objc_msgSend(*(id *)(v14 + 8), "isEqualToString:", *(_QWORD *)(*(_QWORD *)v13 + 8));
        if (!(_DWORD)a1)
          break;
        v14 = *v12;
        v15 = *(_DWORD *)(*v12 + 84);
      }
      if ((v15 & 0xF00) == 0xC00 && *(_QWORD *)(v14 + 16) != *(_QWORD *)(*(_QWORD *)v13 + 16))
        break;
      ++v11;
      v13 += 120;
      v12 += 15;
      if (v10 == v11)
      {
        v11 = v10;
        break;
      }
    }
  }
  if (v11 < v7 && v11 < v9)
  {
    v18 = (uint64_t)&a2[15 * v9 - 15];
    v19 = v6 + 120 * v7 - 120;
    do
    {
      v20 = *(_QWORD *)v18;
      v21 = *(_DWORD *)(*(_QWORD *)v18 + 84);
      v22 = (v21 >> 8) & 0xF;
      v23 = *(_DWORD *)(*(_QWORD *)v19 + 84);
      if (v22 != ((v23 >> 8) & 0xF) || ((v23 ^ v21) & 0x400000) != 0)
        break;
      if (v22 == 9)
      {
        a1 = objc_msgSend(*(id *)(v20 + 8), "isEqualToString:", *(_QWORD *)(*(_QWORD *)v19 + 8));
        if (!(_DWORD)a1)
          break;
        v20 = *(_QWORD *)v18;
        v21 = *(_DWORD *)(*(_QWORD *)v18 + 84);
      }
      if ((v21 & 0xF00) == 0xC00 && *(_QWORD *)(v20 + 16) != *(_QWORD *)(*(_QWORD *)v19 + 16))
        break;
      --v9;
      if (v11 >= --v7)
        break;
      v18 -= 120;
      v19 -= 120;
    }
    while (v11 < v9);
  }
  v85 = a2;
  if (v9 + v7 >= 32)
    v24 = 32;
  else
    v24 = v9 + v7;
  if (v11 == v9)
    v25 = v9 + 1;
  else
    v25 = v9 - 1;
  if (v11 == v7)
    v26 = v9 - 1;
  else
    v26 = v9 + 1;
  if (v11 == v7 && v11 == v9)
  {
    LOBYTE(v27) = 1;
    return v27;
  }
  if (v24 < 1 || (v9 <= v7 ? (v28 = v7) : (v28 = v9), v28 >= 0x8000 || (((unint64_t)v28 >> 60) & 7) != 0))
  {
    LOBYTE(v27) = 0;
    return v27;
  }
  v84 = v26;
  v74 = (16 * v28) | 8;
  if (v74 <= 0x1000)
  {
    v77 = v24;
    MEMORY[0x24BDAC7A8](a1, a2);
    v31 = (char *)&v71 - ((v30 + 15) & 0xFFFFFFFFFFFFFFF0);
    v32 = v30;
    bzero(v31, v30);
    MEMORY[0x24BDAC7A8](v33, v34);
    v86 = v31;
    bzero(v31, v32);
    v73 = 0;
    v35 = v84;
    goto LABEL_53;
  }
  v36 = (16 * v28) | 8;
  v31 = (char *)malloc_type_malloc(v36, 0x5560CE4DuLL);
  v86 = malloc_type_malloc(v36, 0x14FC10C4uLL);
  v35 = v84;
  if (v31)
  {
    v73 = 1;
    if (v86)
    {
      v77 = v24;
LABEL_53:
      v72 = a5;
      v87 = v31;
      RB::Heap::Heap((RB::Heap *)v88, v91, 1024, 0);
      *(_QWORD *)&v31[8 * v9] = v11;
      v86[v9] = 0;
      v76 = -v9;
      v27 = 1;
      v37 = 1;
      v80 = v6;
      while (1)
      {
        v78 = v37;
        if (v25 <= v35)
          break;
        v38 = v25;
LABEL_56:
        v25 = v38 - 1;
        ++v35;
        v37 = v78 + 1;
        v27 = v78 < v77;
        if (v78 == v77)
        {
LABEL_108:
          RB::Heap::~Heap((RB::Heap *)v88);
          v31 = v87;
          v70 = v73;
          if (v74 <= 0x1000)
            goto LABEL_114;
          goto LABEL_113;
        }
      }
      v75 = v27;
      v82 = v37 + v9;
      v83 = v9 - v37;
      v79 = v37 + v9 - 1;
      v81 = v9 - v37 + 1;
      v39 = v76 + v25;
      v38 = v25;
      while (1)
      {
        v40 = (v89 + 7) & 0xFFFFFFFFFFFFFFF8;
        if (v40 + 32 > v90)
          v40 = RB::Heap::alloc_slow(v88, 0x20uLL, 7);
        else
          v89 = v40 + 32;
        if (v25 == v83)
          break;
        if (v25 == v82)
        {
          v44 = 0;
          v41 = v79;
          v43 = *(_QWORD *)&v87[8 * v79];
        }
        else
        {
          v41 = v25 + 1;
          v42 = *(_QWORD *)&v87[8 * v25 + 8];
          v43 = *(_QWORD *)&v87[8 * v25 - 8];
          if (v42 >= v43)
            goto LABEL_63;
          v44 = 0;
          v41 = v25 - 1;
        }
LABEL_68:
        v45 = v86;
        *(_QWORD *)v40 = v86[v41];
        *(_DWORD *)(v40 + 8) = v44;
        v46 = v25 - v9 + v43;
        *(_QWORD *)(v40 + 16) = v43 - 1;
        *(_QWORD *)(v40 + 24) = v46 - 1;
        v45[v25] = v40;
        if (v43 < v9 && v46 < v7)
        {
          v84 = v35;
          v48 = v6 + 120 * (v43 + v39);
          v49 = &v85[15 * v43];
          while (1)
          {
            v50 = *v49;
            v51 = *(_DWORD *)(*v49 + 84);
            v52 = (v51 >> 8) & 0xF;
            v53 = *(_DWORD *)(*(_QWORD *)v48 + 84);
            if (v52 != ((v53 >> 8) & 0xF) || ((v53 ^ v51) & 0x400000) != 0)
              break;
            if (v52 == 9)
            {
              if (!objc_msgSend(*(id *)(v50 + 8), "isEqualToString:", *(_QWORD *)(*(_QWORD *)v48 + 8)))
                break;
              v50 = *v49;
              v51 = *(_DWORD *)(*v49 + 84);
            }
            if (((v51 & 0xF00) != 0xC00 || *(_QWORD *)(v50 + 16) == *(_QWORD *)(*(_QWORD *)v48 + 16)) && ++v43 < v9)
            {
              ++v46;
              v48 += 120;
              v49 += 15;
              if (v43 + v39 < v7)
                continue;
            }
            v46 = v39 + v43;
            break;
          }
          v6 = v80;
          v35 = v84;
        }
        *(_QWORD *)&v87[8 * v25] = v43;
        if (v43 == v9 && v46 == v7)
        {
          v55 = (_QWORD *)v86[v25];
          if (v55)
          {
            v56 = 0;
            LOBYTE(v27) = v75;
            do
            {
              v57 = v55;
              v55 = (_QWORD *)*v55;
              *v57 = v56;
              v56 = v57;
            }
            while (v55);
            v58 = v72;
            v59 = *v72;
            v60 = *(unint64_t **)(*v72 + 8);
            v61 = *v60;
            do
            {
              if (v61 < *(_QWORD *)(v59 + 16))
              {
                v62 = *((_DWORD *)v57 + 2) == 1;
                if (*((_DWORD *)v57 + 2) == 1)
                  v63 = 2;
                else
                  v63 = 3;
                v64 = v57[v63];
                v65 = v58 + 1;
                if (*((_DWORD *)v57 + 2) != 1)
                  v65 = (_DWORD *)v58 + 3;
                v66 = *v65 + v64;
                v67 = *(_QWORD **)v59;
                v68 = v61 + 1;
                *v60 = v61 + 1;
                v69 = *v67 + 8 * v61;
                *(_DWORD *)v69 = v66;
                *(_BYTE *)(v69 + 4) = v62;
                *(_BYTE *)(v69 + 5) = 1;
                v61 = v68;
              }
              v57 = (_QWORD *)*v57;
            }
            while (v57);
          }
          else
          {
            LOBYTE(v27) = v75;
          }
          goto LABEL_108;
        }
        v54 = v25 + 2;
        if (v43 == v9)
          v38 = v25 + 2;
        if (v46 == v7)
          v35 = v25 - 2;
        v39 += 2;
        v25 += 2;
        if (v54 > v35)
          goto LABEL_56;
      }
      v41 = v81;
      v42 = *(_QWORD *)&v87[8 * v81];
LABEL_63:
      v43 = v42 + 1;
      v44 = 1;
      goto LABEL_68;
    }
    LOBYTE(v27) = 0;
    v86 = 0;
  }
  else
  {
    LOBYTE(v27) = 0;
  }
  v70 = 1;
LABEL_113:
  free(v86);
LABEL_114:
  if (v70)
    free(v31);
  return v27;
}

void sub_209B45320(_Unwind_Exception *a1)
{
  uint64_t v1;

  RB::Heap::~Heap((RB::Heap *)(v1 + 136));
  if (*(_QWORD *)(v1 + 24) > 0x1000uLL)
  {
    free(*(void **)(v1 + 120));
    free(*(void **)(v1 + 128));
  }
  _Unwind_Resume(a1);
}

float32x2_t RB::Symbol::Presentation::apply_interpolations(void)::$_4::operator()(uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  _DWORD **v19;
  _DWORD **v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  __int32 v35;
  float v36;
  float32x4_t v37;
  uint64_t v38;
  float32x4_t v39;
  int8x16_t v40;
  int8x16_t v41;
  double v42;
  double v43;
  double v44;
  int8x16_t v45;
  float32x2_t *v46;
  float32x2_t *v47;
  float v48;
  float32x2_t *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  float v53;
  float32x2_t result;
  char v55;
  float64x2_t v56[3];
  float64x2_t v57[3];
  float16x4_t v58;
  __int16 v59;
  float16x4_t v60;
  __int16 v61;

  v3 = *a1;
  v2 = a1[1];
  v4 = v2 + 16;
  v5 = *(_DWORD *)a1[5];
  v6 = *(_QWORD *)(v2 + 376);
  if (v6)
    v7 = v6;
  else
    v7 = v4;
  v8 = a1[2];
  v9 = v8 + 16;
  v10 = *(_DWORD *)a1[6];
  v11 = *(_QWORD *)(v8 + 376);
  if (v11)
    v12 = v11;
  else
    v12 = v9;
  v13.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v7 + 120 * v5), 0);
  v57[0] = v13;
  v57[1] = v14;
  v57[2] = v15;
  v16.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v12 + 120 * v10), 0);
  v56[0] = v16;
  v56[1] = v17;
  v56[2] = v18;
  RB::Heap::emplace<RB::Symbol::Glyph::Layer>((RB::Heap *)(v3 + 944));
  v20 = v19;
  v21 = *(_DWORD *)(v3 + 2072);
  v22 = v21 + 1;
  if (*(_DWORD *)(v3 + 2076) < v21 + 1)
  {
    RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v3 + 2064, v22);
    v21 = *(_DWORD *)(v3 + 2072);
    v22 = v21 + 1;
  }
  *(_QWORD *)(*(_QWORD *)(v3 + 2064) + 8 * v21) = v20;
  *(_DWORD *)(v3 + 2072) = v22;
  v55 = 0;
  RB::Symbol::Glyph::Layer::mix_layers(v20, *(_QWORD *)(v7 + 120 * v5), *(_QWORD *)(v12 + 120 * v10), v57, v56, (RB::Symbol::Presentation *)v3, *((_BYTE *)a1 + 56), (id *)a1[8], *(float *)a1[3], &v55);
  v23 = a1[4];
  v24 = *(_DWORD *)(v23 + 368);
  if (*(_DWORD *)(v23 + 372) < v24 + 1)
  {
    RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow((void *)a1[4], v24 + 1);
    v24 = *(_DWORD *)(v23 + 368);
  }
  v25 = *(_QWORD *)(v23 + 360);
  if (!v25)
    v25 = v23;
  v26 = v25 + 120 * v24;
  *(_QWORD *)v26 = v20;
  *(_OWORD *)(v26 + 8) = RBColorNull;
  __asm { FMOV            V0.4S, #1.0 }
  *(_OWORD *)(v26 + 24) = _Q0;
  *(_OWORD *)(v26 + 40) = xmmword_209BD6C10;
  *(_OWORD *)(v26 + 64) = 0u;
  *(_OWORD *)(v26 + 80) = 0u;
  __asm { FMOV            V0.2S, #1.0 }
  *(_QWORD *)(v26 + 96) = _Q0;
  *(_QWORD *)(v26 + 104) = 0;
  *(_QWORD *)(v26 + 112) = 0;
  ++*(_DWORD *)(v23 + 368);
  v32 = a1[4];
  if (*(_QWORD *)(v32 + 360))
    v33 = *(_QWORD *)(v32 + 360);
  else
    v33 = a1[4];
  v34 = *(_DWORD *)(v32 + 368) - 1;
  v35 = *(_DWORD *)a1[3];
  v36 = *(float *)(v12 + 120 * v10 + 20);
  if (*(float *)(v7 + 120 * v5 + 20) == -32768.0 && v36 == -32768.0)
  {
    v37 = (float32x4_t)RBColorNull;
  }
  else
  {
    v38 = v12 + 120 * v10;
    v60 = vcvt_f16_f32(*(float32x4_t *)(v7 + 120 * v5 + 8));
    v61 = 257;
    v39.i64[0] = *(_QWORD *)(v38 + 8);
    v39.i32[2] = *(_DWORD *)(v38 + 16);
    v39.f32[3] = v36;
    v58 = vcvt_f16_f32(v39);
    v59 = 257;
    if (RB::Fill::Color::can_mix((RB::Fill::Color *)&v60, (const RB::Fill::Color *)&v58))
    {
      v40.i32[0] = v35;
      RB::Fill::Color::mix(&v60, &v58, 3, v40, v41, v42, v43, v44, v45);
    }
    else
    {
      v60 = v58;
      v61 = v59;
    }
    v37 = vcvtq_f32_f16(v60);
  }
  *(float32x4_t *)(v33 + 120 * v34 + 8) = v37;
  v46 = (float32x2_t *)(v7 + 120 * v5);
  v47 = (float32x2_t *)(v12 + 120 * v10);
  v48 = *(float *)a1[3];
  v49 = (float32x2_t *)(v33 + 120 * v34);
  v49[3] = vmla_n_f32(v46[3], vsub_f32(v47[3], v46[3]), v48);
  v49[4].f32[0] = v46[4].f32[0] + (float)((float)(v47[4].f32[0] - v46[4].f32[0]) * v48);
  v49[7] = vmla_n_f32(v46[7], vsub_f32(v47[7], v46[7]), v48);
  v49[9] = vmla_n_f32(v46[9], vsub_f32(v47[9], v46[9]), *(float *)a1[3]);
  v49[10] = vmla_n_f32(v46[10], vsub_f32(v47[10], v46[10]), *(float *)a1[3]);
  v49[11] = vmla_n_f32(v46[11], vsub_f32(v47[11], v46[11]), *(float *)a1[3]);
  if (!v55)
  {
    v50 = v7 + 120 * v5;
    v51 = v12 + 120 * v10;
    v52 = v33 + 120 * v34;
    *(float32x2_t *)(v52 + 64) = vmla_n_f32(*(float32x2_t *)(v50 + 64), vsub_f32(*(float32x2_t *)(v51 + 64), *(float32x2_t *)(v50 + 64)), *(float *)a1[3]);
    v53 = *(float *)a1[3];
    *(float32x2_t *)(v52 + 36) = vmla_n_f32(*(float32x2_t *)(v50 + 36), vsub_f32(*(float32x2_t *)(v51 + 36), *(float32x2_t *)(v50 + 36)), v53);
    *(float *)(v52 + 44) = *(float *)(v50 + 44) + (float)((float)(*(float *)(v51 + 44) - *(float *)(v50 + 44)) * v53);
    *(float32x2_t *)(v52 + 96) = vmla_n_f32(*(float32x2_t *)(v50 + 96), vsub_f32(*(float32x2_t *)(v51 + 96), *(float32x2_t *)(v50 + 96)), v53);
    *(float *)(v52 + 112) = *(float *)(v50 + 112)
                          + (float)(*(float *)a1[3] * (float)(*(float *)(v51 + 112) - *(float *)(v50 + 112)));
  }
  result = vmaxnm_f32(*(float32x2_t *)(v7 + 120 * v5 + 104), *(float32x2_t *)(v12 + 120 * v10 + 104));
  *(float32x2_t *)(v33 + 120 * v34 + 104) = result;
  ++*(_DWORD *)a1[5];
  ++*(_DWORD *)a1[6];
  return result;
}

float32x2_t RB::Symbol::Presentation::Layer::add_velocity(float32x2_t *a1, double a2)
{
  float32x2_t result;

  result = vmaxnm_f32((float32x2_t)(*(_QWORD *)&a2 & 0x7FFFFFFF7FFFFFFFLL), a1[13]);
  a1[13] = result;
  return result;
}

float32x2_t RB::Symbol::Presentation::Layer::add_scale_velocity(float32x2_t *this, float a2)
{
  float32x2_t result;

  result = vadd_f32(this[13], vabs_f32(vmul_n_f32(this[9], a2)));
  this[13] = result;
  return result;
}

uint64_t RB::Symbol::Presentation::Layer::set_animation_layer(RB::Symbol::Presentation::Layer *this, _RBDrawingState *a2, RB::Symbol::Model **a3)
{
  _DWORD v5[2];

  v5[0] = *(_DWORD *)(*(_QWORD *)this + 68);
  v5[1] = *(_DWORD *)(RB::Symbol::Model::glyph_info(*a3) + 400);
  return RB::DisplayList::State::set_animation_layer((uint64_t)a2, v5);
}

__n128 __Block_byref_object_copy__0(uint64_t a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)(a2 + 48);
  v3 = *(_OWORD *)(a2 + 64);
  *(_QWORD *)(a1 + 80) = *(_QWORD *)(a2 + 80);
  *(__n128 *)(a1 + 48) = result;
  *(_OWORD *)(a1 + 64) = v3;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a2 + 88) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{
  const void *v1;

  v1 = *(const void **)(a1 + 88);
  if (v1)
    CFRelease(v1);
}

uint64_t ___ZNK2RB6Symbol12Presentation4drawEP15_RBDrawingStateU13block_pointerF7RBColor13RBSymbolStyleP8NSStringE_block_invoke(_QWORD *a1, void *a2, double a3, double a4, double a5, double a6)
{
  float32x2_t *v8;
  float32x2_t v9;
  uint64_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  __int128 v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  double v19;
  uint64_t v21;
  uint64_t v22;
  int v23;
  float v24;
  float v25;
  float v26;
  float v27;
  float32x2_t *v28;
  _DWORD *v29;
  float32x2_t *v30;
  float32x2_t *v31;
  _OWORD v32[3];
  float64x2_t v33[3];
  float64x2_t v34[2];
  uint64_t v35;
  uint64_t v36;

  v8 = (float32x2_t *)a1[7];
  v9 = *v8;
  if ((*(_DWORD *)(*(_QWORD *)v8 + 84) & 0xF00) == 0xC00 && *(_QWORD *)(*(_QWORD *)&v9 + 16))
  {
    v10 = a1[6];
    v11.f64[0] = 0.0;
    v11.f64[1] = COERCE_FLOAT(HIDWORD(*(_QWORD *)&v8[7]));
    v34[0] = (float64x2_t)COERCE_UNSIGNED_INT64(COERCE_FLOAT(*(_QWORD *)&v8[7]));
    v34[1] = v11;
    v35 = 0;
    v36 = 0;
    v12.f64[0] = RB::Symbol::Presentation::Layer::transform(v8, v10);
    v33[0] = v12;
    v33[1] = v13;
    v33[2] = v14;
    *(double *)&v15 = RB::operator*(v34, v33);
    v16 = *(_QWORD *)(*(_QWORD *)a1[7] + 16);
    v32[0] = v15;
    v32[1] = v17;
    v32[2] = v18;
    LODWORD(v15) = 1065353216;
    LODWORD(v17) = 1065353216;
    LODWORD(v18) = 1065353216;
    LODWORD(v19) = 1065353216;
    return objc_msgSend(a2, "setImage:transform:interpolation:tintColor:flags:", v16, v32, 10, 0, *(double *)&v15, *(double *)&v17, *(double *)&v18, v19);
  }
  else
  {
    LODWORD(a6) = v8[2].i32[1];
    if (*(float *)&a6 == -32768.0)
    {
      v21 = a1[4];
      v22 = *(_QWORD *)(a1[5] + 8) + 48;
      v23 = (*(_DWORD *)(*(_QWORD *)v8 + 84) >> 8) & 0xF;
      if (RB::Symbol::ResolvedColor::begin_update(v22, v23, *(_QWORD *)(*(_QWORD *)&v9 + 8), *(CGColorRef *)(*(_QWORD *)&v9 + 16)))
      {
        if (v23 == 10)
        {
          v24 = 1.0;
          v25 = 1.0;
          v26 = 1.0;
          v27 = 1.0;
        }
        else
        {
          v24 = (*(float (**)(uint64_t, _QWORD, _QWORD))(v21 + 16))(v21, (*(_DWORD *)(*(_QWORD *)v8 + 84) >> 8) & 0xF, *(_QWORD *)(*(_QWORD *)v8 + 8));
        }
        RB::Symbol::ResolvedColor::commit_update(v22, v24, v25, v26, v27);
      }
      v31 = *(float32x2_t **)(a1[5] + 8);
      v28 = v31 + 6;
      v29 = (_DWORD *)&v31[6] + 1;
      v30 = v31 + 7;
      LODWORD(a6) = v31[7].i32[1];
    }
    else
    {
      v28 = v8 + 1;
      v29 = (_DWORD *)&v8[1] + 1;
      v30 = v8 + 2;
    }
    LODWORD(a5) = v30->i32[0];
    LODWORD(a4) = *v29;
    LODWORD(a3) = v28->i32[0];
    return objc_msgSend(a2, "setColor:colorSpace:", 1, a3, a4, a5, a6);
  }
}

uint64_t RB::Symbol::Presentation::Layer::append_path(float32x2_t *this, RB::Path::Storage *a2, const RB::Symbol::Presentation *a3)
{
  float64x2_t v5;
  uint64_t v6;
  double v7;
  float64x2_t v8;
  float64x2_t v9;
  int64x2_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;

  v5.f64[0] = RB::Symbol::Presentation::Layer::transform(this, (uint64_t)a3);
  v6 = (uint64_t)*this;
  v7 = *(float *)(*(_QWORD *)this + 56);
  v15 = vmulq_n_f64(v5, v7);
  v16 = vmulq_n_f64(v8, v7);
  v17 = v9;
  v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v16, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v15, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v9));
  v11 = vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0];
  if ((v11 & 0x8000000000000000) == 0)
  {
    RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v15);
    v6 = (uint64_t)*this;
  }
  RB::Symbol::Glyph::Layer::append_path(v6);
  v13 = v12;
  if ((v11 & 0x8000000000000000) == 0 && (_DWORD)v12)
    RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
  return v13;
}

void RB::Symbol::Presentation::record_keyframes(uint64_t a1, int *a2, int a3, uint64_t a4, RB::Symbol::KeyframeStorage *this)
{
  _QWORD *v5;
  uint64_t v11;
  _QWORD *v12;
  int v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  RB::Symbol::KeyframeStorage *v21;
  uint64_t v22;
  RB::Symbol::KeyframeStorage **v23;
  uint64_t v24;
  uint64_t v25;

  v5 = *(_QWORD **)(a1 + 2024);
  if (v5)
  {
    v11 = v5[1];
    if (v5[2] < (unint64_t)(v11 + 1))
    {
      RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow(*(_QWORD *)(a1 + 2024), v11 + 1);
      v11 = v5[1];
    }
    v12 = (_QWORD *)(*v5 + 24 * v11);
    *v12 = 0;
    v12[1] = 0;
    v12[2] = 0;
    ++v5[1];
    v13 = *a2;
    v14 = *(uint64_t **)(a1 + 2024);
    v15 = *v14;
    v16 = v14[1] - 1;
    v17 = (_DWORD *)(v15 + 24 * v16);
    *v17 = v13;
    v17[1] = a3;
    if (!*((_DWORD *)this + 454))
      goto LABEL_7;
    v18 = RB::Symbol::KeyframeStorage::commit(this);
    v19 = *(uint64_t **)(a1 + 2024);
    v15 = *v19;
    v20 = v19[1];
    if (v18 != a4)
    {
      v16 = v20 - 1;
LABEL_7:
      *(_QWORD *)(v15 + 24 * v16 + 8) = a4;
      return;
    }
    v21 = (RB::Symbol::KeyframeStorage *)operator new();
    RB::Symbol::KeyframeStorage::KeyframeStorage(v21, this);
    v22 = v15 + 24 * v20;
    v25 = *(_QWORD *)(v22 - 8);
    v23 = (RB::Symbol::KeyframeStorage **)(v22 - 8);
    v24 = v25;
    *v23 = v21;
    if (v25)
      std::default_delete<RB::Symbol::KeyframeStorage>::operator()[abi:nn180100]((uint64_t)v23, v24);
  }
}

void sub_209B45BC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1020C400F1BD0D8);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Presentation::take_path(RB::Symbol::Presentation *this, const path_ptr *a2)
{
  unsigned int v4;
  _QWORD *v5;
  uint64_t result;
  uint64_t v7;

  v4 = *((_DWORD *)this + 514);
  if (*((_DWORD *)this + 515) < v4 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)this + 2048, v4 + 1);
    v4 = *((_DWORD *)this + 514);
  }
  v5 = (_QWORD *)(*((_QWORD *)this + 256) + 16 * v4);
  result = RBPathRetain((uint64_t)a2->_p.info, (uint64_t)a2->_p.callbacks);
  *v5 = result;
  v5[1] = v7;
  ++*((_DWORD *)this + 514);
  return result;
}

uint64_t RB::Symbol::Presentation::take_path(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  _QWORD *v6;

  v3 = *a2;
  *a2 = 0;
  v4 = *(_DWORD *)(a1 + 2056);
  v5 = v4 + 1;
  if (*(_DWORD *)(a1 + 2060) < v4 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow(a1 + 2048, v5);
    v4 = *(_DWORD *)(a1 + 2056);
    v5 = v4 + 1;
  }
  v6 = (_QWORD *)(*(_QWORD *)(a1 + 2048) + 16 * v4);
  *v6 = v3;
  v6[1] = &RB::Path::Object::callbacks;
  *(_DWORD *)(a1 + 2056) = v5;
  return *(_QWORD *)(*(_QWORD *)(a1 + 2048) + 16 * v4);
}

void RB::Symbol::ResolvedColor::update(uint64_t a1, float a2, float a3, float a4, float a5)
{
  if (*(float *)a1 != a2 || *(float *)(a1 + 4) != a3 || *(float *)(a1 + 8) != a4 || *(float *)(a1 + 12) != a5)
    RB::Symbol::ResolvedColor::commit_update(a1, a2, a3, a4, a5);
}

uint64_t RB::Symbol::ResolvedColor::begin_update(uint64_t a1, int a2, uint64_t a3, CGColorRef color2)
{
  if (*(_DWORD *)(a1 + 16) == a2)
  {
    if (a2 != 9
      || CGColorEqualToColor(*(CGColorRef *)(a1 + 32), color2)
      && (objc_msgSend(*(id *)(a1 + 24), "isEqualToString:", a3) & 1) != 0)
    {
      return 0;
    }
    *(_DWORD *)(a1 + 16) = 9;
    goto LABEL_9;
  }
  *(_DWORD *)(a1 + 16) = a2;
  if (a2 == 9)
  {
LABEL_9:
    *(_QWORD *)(a1 + 24) = a3;
    *(_QWORD *)(a1 + 32) = color2;
    return 1;
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  return 1;
}

CGColorRef RB::Symbol::ResolvedColor::operator CGColor *(uint64_t a1)
{
  CGColorRef v1;
  const void *v3;

  v1 = *(CGColorRef *)(a1 + 40);
  if (!v1)
  {
    v1 = RBColorCopyCGColor(1u, *(float *)a1, *(float *)(a1 + 4), *(float *)(a1 + 8), *(float *)(a1 + 12));
    v3 = *(const void **)(a1 + 40);
    if (v3)
      CFRelease(v3);
    *(_QWORD *)(a1 + 40) = v1;
  }
  return v1;
}

double RB::Heap::emplace<RB::Symbol::Glyph::Layer>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;
  unsigned int v5;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 88 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 88;
  *(_QWORD *)(v3 + 40) = 0;
  *(_QWORD *)(v3 + 8) = 0;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)&result = 0x400000000;
  *(_QWORD *)(v3 + 48) = 0x400000000;
  *(_QWORD *)(v3 + 56) = 1065353216;
  *(_QWORD *)(v3 + 64) = 2139095040;
  *(_QWORD *)(v3 + 72) = 1065353216;
  v5 = *(_DWORD *)(v3 + 84) & 0xFE000000 | 0x311A00;
  *(_DWORD *)(v3 + 80) = -1;
  *(_DWORD *)(v3 + 84) = v5;
  return result;
}

RB::Symbol::KeyframeStorage *RB::Symbol::KeyframeStorage::KeyframeStorage(RB::Symbol::KeyframeStorage *this, const RB::Symbol::KeyframeStorage *a2)
{
  const RB::Symbol::KeyframeStorage *v4;
  unsigned int v5;
  unsigned int v6;
  RB::Symbol::KeyframeStorage *v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  int v11;
  __int128 *v12;
  unsigned int v13;
  char *v14;
  uint64_t v15;
  char *v16;
  unsigned int v17;
  __int128 v18;
  int v19;

  *((_QWORD *)this + 96) = 0;
  *((_QWORD *)this + 97) = 0x4000000000;
  if (*((_QWORD *)a2 + 96))
    v4 = (const RB::Symbol::KeyframeStorage *)*((_QWORD *)a2 + 96);
  else
    v4 = a2;
  v5 = *((_DWORD *)a2 + 194);
  v6 = v5;
  if (v5 >= 0x41)
  {
    RB::vector<RB::Symbol::Keyframes::Value,64ul,unsigned int>::reserve_slow(this, v5);
    v7 = (RB::Symbol::KeyframeStorage *)*((_QWORD *)this + 96);
    v8 = *((_DWORD *)this + 194);
  }
  else
  {
    if (!v5)
    {
      v11 = 0;
      goto LABEL_13;
    }
    v7 = 0;
    v8 = 0;
  }
  if (!v7)
    v7 = this;
  v9 = (char *)v7 + 12 * v8;
  do
  {
    v10 = *(_QWORD *)v4;
    *((_DWORD *)v9 + 2) = *((_DWORD *)v4 + 2);
    *(_QWORD *)v9 = v10;
    v9 += 12;
    v4 = (const RB::Symbol::KeyframeStorage *)((char *)v4 + 12);
    --v6;
  }
  while (v6);
  v11 = *((_DWORD *)this + 194);
LABEL_13:
  *((_DWORD *)this + 194) = v11 + v5;
  *((_QWORD *)this + 226) = 0;
  *((_QWORD *)this + 227) = 0x4000000000;
  if (*((_QWORD *)a2 + 226))
    v12 = (__int128 *)*((_QWORD *)a2 + 226);
  else
    v12 = (__int128 *)((char *)a2 + 784);
  v13 = *((_DWORD *)a2 + 454);
  if (v13 >= 0x41)
  {
    RB::vector<RB::Symbol::Keyframes,64ul,unsigned int>::reserve_slow((char *)this + 784, *((_DWORD *)a2 + 454));
    v14 = (char *)*((_QWORD *)this + 226);
    v15 = *((unsigned int *)this + 454);
  }
  else
  {
    if (!v13)
    {
      v19 = 0;
      goto LABEL_25;
    }
    v14 = 0;
    v15 = 0;
  }
  if (!v14)
    v14 = (char *)this + 784;
  v16 = &v14[16 * v15];
  v17 = v13;
  do
  {
    v18 = *v12++;
    *(_OWORD *)v16 = v18;
    v16 += 16;
    --v17;
  }
  while (v17);
  v19 = *((_DWORD *)this + 454);
LABEL_25:
  *((_DWORD *)this + 454) = v19 + v13;
  *((_BYTE *)this + 1824) = *((_BYTE *)a2 + 1824);
  return this;
}

void sub_209B45F94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 1808);
  if (v3)
    free(v3);
  v4 = *(void **)(v1 + 768);
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::Symbol::Keyframes::Value,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 195) + (*((_DWORD *)__dst + 195) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 195) + (*((_DWORD *)__dst + 195) >> 1);
  result = RB::details::realloc_vector<unsigned int,12ul>(*((void **)__dst + 96), __dst, 0x40u, (_DWORD *)__dst + 195, v3);
  *((_QWORD *)__dst + 96) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,12ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 12 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(12 * a5);
    v9 = v8 / 0xC;
    if (*a4 != (v8 / 0xC))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 12 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::Symbol::Keyframes,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1);
  result = RB::details::realloc_vector<unsigned int,16ul>(*((void **)__dst + 128), __dst, 0x40u, (_DWORD *)__dst + 259, v3);
  *((_QWORD *)__dst + 128) = result;
  return result;
}

void std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  uint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t *v6;
  uint64_t v7;

  if (a2)
  {
    v3 = *(uint64_t **)a2;
    v4 = *(_QWORD *)(a2 + 8);
    if (v4)
    {
      v5 = 0;
      v6 = v3 + 2;
      do
      {
        v7 = *v6;
        *v6 = 0;
        if (v7)
        {
          std::default_delete<RB::Symbol::KeyframeStorage>::operator()[abi:nn180100]((uint64_t)v6, v7);
          v4 = *(_QWORD *)(a2 + 8);
        }
        ++v5;
        v6 += 3;
      }
      while (v5 < v4);
      v3 = *(uint64_t **)a2;
    }
    if (v3)
      free(v3);
    JUMPOUT(0x20BD16544);
  }
}

void *RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 211) + (*((_DWORD *)__dst + 211) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 211) + (*((_DWORD *)__dst + 211) >> 1);
  result = RB::details::realloc_vector<unsigned int,416ul>(*((void **)__dst + 104), __dst, 2u, (_DWORD *)__dst + 211, v3);
  *((_QWORD *)__dst + 104) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,416ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 416 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(416 * a5);
    v9 = v8 / 0x1A0;
    if (*a4 != (v8 / 0x1A0))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 416 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::details::realloc_vector<unsigned int,120ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 120 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(120 * a5);
    v9 = v8 / 0x78;
    if (*a4 != (v8 / 0x78))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 120 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

_QWORD *RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::swap_inline(_QWORD *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  _QWORD *v6;
  _BYTE v7[360];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = a2[45];
  v3 = result[45];
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
  {
    v6 = result;
    memcpy(v7, a2, sizeof(v7));
    memcpy(a2, v6, 0x168uLL);
    result = memcpy(v6, v7, 0x168uLL);
    if (v3)
    {
      if (v2)
        return result;
    }
    else
    {
      v6[45] = 0;
      if (v2)
        return result;
    }
    a2[45] = 0;
  }
  return result;
}

void std::default_delete<RB::Symbol::KeyframeStorage>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = *(void **)(a2 + 1808);
    if (v3)
      free(v3);
    v4 = *(void **)(a2 + 768);
    if (v4)
      free(v4);
    JUMPOUT(0x20BD16544);
  }
}

uint64_t RB::CustomShader::Library::Library(uint64_t a1, int a2, void *a3)
{
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = &off_24C228BE8;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 28) = 0;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 24) = a2;
  RB::Heap::Heap((RB::Heap *)(a1 + 40), (char *)(a1 + 80), 512, 0);
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 592), (unint64_t (*)(RB *, const void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_0::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_1::__invoke, 0, (void (*)(void *))RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_2::__invoke, (RB::Heap *)(a1 + 40));
  *(_QWORD *)(a1 + 688) = 0;
  *(_QWORD *)(a1 + 696) = 0x100000000;
  *(_OWORD *)(a1 + 704) = 0u;
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(_DWORD *)(a1 + 28) = ++RB::CustomShader::Library::_last_id;
  os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 32));
  return a1;
}

void sub_209B46594(_Unwind_Exception *a1)
{
  uint64_t v1;
  RB::Heap *v2;

  RB::Heap::~Heap(v2);

  _Unwind_Resume(a1);
}

uint64_t RB::vector<std::pair<unsigned int,RB::objc_ptr<void({block_pointer})(NSError *)>>,0ul,unsigned int>::~vector(uint64_t a1)
{
  void **v2;
  unint64_t v3;
  void **v4;
  void *v5;

  v2 = *(void ***)a1;
  if (*(_DWORD *)(a1 + 8))
  {
    v3 = 0;
    v4 = v2 + 1;
    do
    {
      v5 = *v4;
      v4 += 2;

      ++v3;
    }
    while (v3 < *(unsigned int *)(a1 + 8));
    v2 = *(void ***)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

void RB::CustomShader::Library::~Library(RB::CustomShader::Library *this)
{
  os_unfair_lock_s *v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  void (**v6)(RB::CustomShader::Library *, _QWORD);
  void **v7;
  unint64_t v8;
  void **v9;
  void *v10;
  void *v11;

  *(_QWORD *)this = &off_24C228BE8;
  v2 = (os_unfair_lock_s *)((char *)this + 32);
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  v3 = (char *)this + 672;
  if (*((_QWORD *)this + 86))
    v3 = (char *)*((_QWORD *)this + 86);
  v4 = *((unsigned int *)this + 174);
  if ((_DWORD)v4)
  {
    v5 = 16 * v4;
    v6 = (void (**)(RB::CustomShader::Library *, _QWORD))(v3 + 8);
    do
    {
      (*v6)(this, *(v6 - 1));
      v6 += 2;
      v5 -= 16;
    }
    while (v5);
  }
  os_unfair_lock_unlock(v2);
  v7 = (void **)*((_QWORD *)this + 88);
  if (*((_DWORD *)this + 178))
  {
    v8 = 0;
    v9 = v7 + 1;
    do
    {
      v10 = *v9;
      v9 += 2;

      ++v8;
    }
    while (v8 < *((unsigned int *)this + 178));
    v7 = (void **)*((_QWORD *)this + 88);
  }
  if (v7)
    free(v7);
  v11 = (void *)*((_QWORD *)this + 86);
  if (v11)
    free(v11);
  RB::UntypedTable::~UntypedTable((RB::CustomShader::Library *)((char *)this + 592));
  RB::Heap::~Heap((RB::CustomShader::Library *)((char *)this + 40));

}

{
  RB::CustomShader::Library::~Library(this);
  JUMPOUT(0x20BD16544);
}

void sub_209B466F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  void *v4;

  os_unfair_lock_unlock(v2);
  RB::vector<std::pair<unsigned int,RB::objc_ptr<void({block_pointer})(NSError *)>>,0ul,unsigned int>::~vector(v1 + 704);
  v4 = *(void **)(v1 + 688);
  if (v4)
    free(v4);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v1 + 592));
  RB::Heap::~Heap((RB::Heap *)(v1 + 40));

  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::finalize(RB::CustomShader::Library *this)
{
  NSObject *global_queue;

  global_queue = dispatch_get_global_queue(0, 0);
  dispatch_async_f(global_queue, this, (dispatch_function_t)RB::CustomShader::Library::finalize(void)::$_0::__invoke);
}

void RB::CustomShader::Library::intern_function(os_unfair_lock_s *this@<X0>, NSString *a2@<X1>, uint64_t *a3@<X8>)
{
  os_unfair_lock_s *v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v16;
  size_t *v17;

  v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  v7 = RB::UntypedTable::lookup((RB::UntypedTable *)&this[148], (uint64_t *)a2, 0);
  v8 = (uint64_t)v7;
  if (v7)
  {
    if (!*((_BYTE *)v7 + 36))
    {
      v9 = (unsigned int *)(v7[2] + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
      *((_BYTE *)v7 + 36) = 1;
    }
    v11 = (unsigned int *)(v7 + 1);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
  }
  else
  {
    v13 = operator new();
    v8 = v13;
    v14 = ++RB::CustomShader::Library::_last_id;
    *(_DWORD *)(v13 + 8) = 1;
    *(_QWORD *)v13 = &off_24C228C18;
    p_os_unfair_lock_opaque = &this[2]._os_unfair_lock_opaque;
    do
      v16 = __ldxr(p_os_unfair_lock_opaque);
    while (__stxr(v16 + 1, p_os_unfair_lock_opaque));
    *(_QWORD *)(v13 + 16) = this;
    v17 = (size_t *)-[NSString copy](a2, "copy");
    *(_QWORD *)(v8 + 24) = v17;
    *(_DWORD *)(v8 + 32) = v14;
    *(_BYTE *)(v8 + 36) = 1;
    RB::UntypedTable::insert((size_t **)&this[148], v17, (size_t *)v8);
  }
  *a3 = v8;
  os_unfair_lock_unlock(v6);
}

void sub_209B468C4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v5;
  unsigned int v6;

  do
  {
    v5 = __ldxr(v3);
    v6 = v5 - 1;
  }
  while (__stlxr(v6, v3));
  if (!v6)
    RB::CustomShader::Library::intern_function(v2);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::add_observer(os_unfair_lock_s *this, void *a2, void (*a3)(RB::CustomShader::Library *, void *))
{
  os_unfair_lock_s *v6;
  uint32_t os_unfair_lock_opaque;
  unsigned int v8;
  os_unfair_lock_s *v9;
  char *v10;

  v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
  v8 = os_unfair_lock_opaque + 1;
  if (this[175]._os_unfair_lock_opaque < os_unfair_lock_opaque + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&this[168], v8);
    os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
    v8 = os_unfair_lock_opaque + 1;
  }
  v9 = *(os_unfair_lock_s **)&this[172]._os_unfair_lock_opaque;
  if (!v9)
    v9 = this + 168;
  v10 = (char *)&v9[4 * os_unfair_lock_opaque];
  *(_QWORD *)v10 = a2;
  *((_QWORD *)v10 + 1) = a3;
  this[174]._os_unfair_lock_opaque = v8;
  os_unfair_lock_unlock(v6);
}

void sub_209B469A8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::remove_observer(os_unfair_lock_s *this, void *a2)
{
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  uint64_t os_unfair_lock_opaque;
  os_unfair_lock_s *v7;
  uint64_t v8;
  uint32_t v9;
  char *v10;
  uint64_t v11;

  v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  v5 = this + 168;
  if (*(_QWORD *)&this[172]._os_unfair_lock_opaque)
    v5 = *(os_unfair_lock_s **)&this[172]._os_unfair_lock_opaque;
  os_unfair_lock_opaque = this[174]._os_unfair_lock_opaque;
  if ((_DWORD)os_unfair_lock_opaque)
  {
    v7 = v5 + 2;
    v8 = 16 * os_unfair_lock_opaque;
    while (*(void **)&v7[-2]._os_unfair_lock_opaque != a2)
    {
      v7 += 4;
      v8 -= 16;
      if (!v8)
        goto LABEL_9;
    }
    v9 = os_unfair_lock_opaque - 1;
    v10 = (char *)&v5[4 * v9];
    *(_QWORD *)&v7[-2]._os_unfair_lock_opaque = *(_QWORD *)v10;
    *(_QWORD *)v10 = a2;
    v11 = *(_QWORD *)&v7->_os_unfair_lock_opaque;
    *(_QWORD *)&v7->_os_unfair_lock_opaque = *((_QWORD *)v10 + 1);
    *((_QWORD *)v10 + 1) = v11;
    this[174]._os_unfair_lock_opaque = v9;
  }
LABEL_9:
  os_unfair_lock_unlock(v4);
}

uint64_t RB::CustomShader::Library::add_error_handler(uint64_t a1, void *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;

  v4 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  v5 = ++RB::CustomShader::Library::_last_id;
  v6 = objc_msgSend(a2, "copy");
  v7 = *(_DWORD *)(a1 + 712);
  v8 = v7 + 1;
  if (*(_DWORD *)(a1 + 716) < v7 + 1)
  {
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow(a1 + 704, v8);
    v7 = *(_DWORD *)(a1 + 712);
    v8 = v7 + 1;
  }
  v9 = *(_QWORD *)(a1 + 704) + 16 * v7;
  *(_DWORD *)v9 = v5;
  *(_QWORD *)(v9 + 8) = v6;
  *(_DWORD *)(a1 + 712) = v8;
  os_unfair_lock_unlock(v4);
  return v5;
}

void sub_209B46AF0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::remove_error_handler(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_s *v4;
  uint32_t os_unfair_lock_opaque;
  uint64_t v6;
  _QWORD *v7;
  uint32_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;

  v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  os_unfair_lock_opaque = this[178]._os_unfair_lock_opaque;
  if (os_unfair_lock_opaque)
  {
    v6 = *(_QWORD *)&this[176]._os_unfair_lock_opaque;
    v7 = (_QWORD *)(v6 + 8);
    v8 = this[178]._os_unfair_lock_opaque;
    while (*((_DWORD *)v7 - 2) != a2)
    {
      v7 += 2;
      if (!--v8)
        goto LABEL_7;
    }
    v9 = v6 + 16 * (os_unfair_lock_opaque - 1);
    *((_DWORD *)v7 - 2) = *(_DWORD *)v9;
    *(_DWORD *)v9 = a2;
    v10 = *v7;
    *v7 = *(_QWORD *)(v9 + 8);
    *(_QWORD *)(v9 + 8) = v10;
    v11 = this[178]._os_unfair_lock_opaque - 1;
    this[178]._os_unfair_lock_opaque = v11;

  }
LABEL_7:
  os_unfair_lock_unlock(v4);
}

BOOL RB::CustomShader::Library::call_error_handler(os_unfair_lock_s *this, NSError *a2)
{
  os_unfair_lock_s *v4;
  uint32_t os_unfair_lock_opaque;
  _BOOL8 v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  id *v10;
  id v11;
  int v12;
  char *v13;
  id v14;
  char *v15;

  if (!a2)
    return 1;
  v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  os_unfair_lock_opaque = this[178]._os_unfair_lock_opaque;
  v6 = os_unfair_lock_opaque != 0;
  if (os_unfair_lock_opaque)
  {
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[9] = 0;
    v7[10] = 0x800000000;

    *v7 = a2;
    v8 = this[178]._os_unfair_lock_opaque;
    if ((_DWORD)v8)
    {
      v9 = 16 * v8;
      v10 = (id *)(*(_QWORD *)&this[176]._os_unfair_lock_opaque + 8);
      do
      {
        v11 = *v10;
        v12 = *((_DWORD *)v7 + 20);
        if (*((_DWORD *)v7 + 21) < (v12 + 1))
        {
          RB::vector<RB::objc_ptr<void({block_pointer})(NSError *)>,8ul,unsigned int>::reserve_slow(v7 + 1, v12 + 1);
          v12 = *((_DWORD *)v7 + 20);
        }
        v13 = (char *)v7[9];
        v14 = v11;
        if (v13)
          v15 = v13;
        else
          v15 = (char *)(v7 + 1);
        *(_QWORD *)&v15[8 * v12] = v14;
        ++*((_DWORD *)v7 + 20);

        v10 += 2;
        v9 -= 16;
      }
      while (v9);
    }
    dispatch_async_f(MEMORY[0x24BDAC9B8], v7, (dispatch_function_t)RB::CustomShader::Library::call_error_handler(NSError *)const::$_0::__invoke);
  }
  os_unfair_lock_unlock(v4);
  return v6;
}

void sub_209B46CFC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::CustomShader::Library::log_error(os_unfair_lock_s *this, NSError *a2)
{
  _BOOL8 v3;
  NSObject *v4;
  int v5;
  NSString *v6;
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  v3 = RB::CustomShader::Library::call_error_handler(this, a2);
  if (!v3)
  {
    v4 = RB::error_log((RB *)v3);
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      v5 = 138412290;
      v6 = -[NSError localizedDescription](a2, "localizedDescription");
      _os_log_impl(&dword_209ACA000, v4, OS_LOG_TYPE_DEFAULT, "custom shader: %@", (uint8_t *)&v5, 0xCu);
    }
  }
}

uint64_t *RB::CustomShader::Library::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t v3;
  size_t *v4;
  size_t *v5;
  _QWORD *v6;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef theData;

  v3 = *((_QWORD *)a2 + 7);
  if (v3)
  {
    if ((*((_BYTE *)a2 + 164) & 1) == 0)
    {
      v4 = (size_t *)this;
      theData = 0;
      this = RB::UntypedTable::lookup((RB::Encoder *)((char *)a2 + 80), this, (void **)&theData);
      if (theData != (CFDataRef)v4)
      {
        v5 = (size_t *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = (char *)v5 + 1;
        RB::UntypedTable::insert((size_t **)a2 + 10, v4, v5);
        RB::ProtobufEncoder::encode_varint(a2, 0x7AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        if (v5)
        {
          RB::ProtobufEncoder::encode_varint(a2, 8uLL);
          RB::ProtobufEncoder::encode_varint(a2, (unint64_t)v5);
        }
        RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        v6 = -[RBShaderLibrary initWithLibrary:]([RBShaderLibrary alloc], (unsigned int *)v4);
        (*(void (**)(CFDataRef *__return_ptr, uint64_t, _QWORD *))(*(_QWORD *)v3 + 40))(&theData, v3, v6);
        if (theData)
        {
          BytePtr = CFDataGetBytePtr(theData);
          Length = CFDataGetLength(theData);
          if (Length)
          {
            RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
            RB::ProtobufEncoder::encode_data(a2, BytePtr, Length);
          }
          if (theData)
            CFRelease(theData);
        }
        else
        {
          *((_BYTE *)a2 + 48) = 1;
        }

        RB::ProtobufEncoder::end_length_delimited(a2);
        return RB::ProtobufEncoder::end_length_delimited(a2);
      }
    }
  }
  else
  {
    *((_BYTE *)a2 + 48) = 1;
  }
  return this;
}

void sub_209B46F40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  void *v10;

  _Unwind_Resume(a1);
}

CFTypeRef RB::CustomShader::Library::decode(RB::CustomShader::Library *this, RB::Decoder *a2)
{
  uint64_t v2;
  uint64_t field;
  uint64_t v5;
  CFTypeRef v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef cf;

  v2 = *((_QWORD *)this + 9);
  if (!v2)
    return 0;
  field = RB::ProtobufDecoder::next_field(this);
  if (!field)
    return 0;
  v5 = field;
  v6 = 0;
  do
  {
    if ((v5 & 0x7FFFFFFF8) == 8)
    {
      v7 = RB::ProtobufDecoder::data_field(this, v5);
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 24))(&cf, v2, v7, v8);
      v9 = cf;
      if (cf)
      {
        cf = 0;
        RB::ObjectTable::adopt((RB::CustomShader::Library *)((char *)this + 184), v9);
        if (cf)
          CFRelease(cf);
        v6 = v9;
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v5);
    }
    v5 = RB::ProtobufDecoder::next_field(this);
  }
  while (v5);
  return v6;
}

void sub_209B4703C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

size_t *RB::CustomShader::Library::decode(RB::ProtobufDecoder *this, char a2)
{
  uint64_t field;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  size_t *v7;
  __int128 v8;
  __int128 v9;
  RB::Decoder *v10;
  CFTypeRef v11;
  __int128 v13;
  __int128 v14;
  void *v15[2];
  uint64_t v16;

  if ((a2 & 7) != 2)
    goto LABEL_12;
  RB::ProtobufDecoder::begin_message(this);
  field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
    v5 = 0;
    v6 = 0;
    goto LABEL_14;
  }
  v4 = field;
  v5 = 0;
  v6 = 0;
  do
  {
    if ((v4 >> 3) == 2)
    {
      v13 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field(this, v4);
      v6 = v4;
    }
    else if ((v4 >> 3) == 1)
    {
      v5 = RB::ProtobufDecoder::uint_field(this, v4);
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  if (!(v5 >> 61))
  {
LABEL_14:
    v15[0] = 0;
    v7 = (size_t *)RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0xC000000000000000), v15);
    if ((void *)(v5 | 0xC000000000000000) == v15[0])
      goto LABEL_22;
    v8 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 6, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_21:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0xC000000000000000), v7);
LABEL_22:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        if (v7)
          return v7;
        goto LABEL_12;
      }
      v8 = *(_OWORD *)v15;
    }
    v9 = *(_OWORD *)this;
    *(_OWORD *)this = v8;
    if ((v6 & 7) == 2)
    {
      v14 = v9;
      RB::ProtobufDecoder::begin_message(this);
      v11 = RB::CustomShader::Library::decode(this, v10);
      v7 = (size_t *)-[RBDecodedFontMetadata fontUID]((uint64_t)v11);
      RB::ProtobufDecoder::end_message((uint64_t)this);
      v9 = v14;
    }
    else
    {
      *((_BYTE *)this + 56) = 1;
    }
    *(_OWORD *)this = v9;
    goto LABEL_21;
  }
  RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_12:
  v7 = 0;
  *((_BYTE *)this + 56) = 1;
  *(_QWORD *)this = *((_QWORD *)this + 1);
  return v7;
}

void RB::CustomShader::Function::~Function(id *this)
{
  *this = &off_24C228C18;

}

{
  *this = &off_24C228C18;

  JUMPOUT(0x20BD16544);
}

void RB::CustomShader::Function::finalize(RB::CustomShader::Function *this)
{
  os_unfair_lock_s *v2;
  int v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  v2 = (os_unfair_lock_s *)(*((_QWORD *)this + 2) + 32);
  os_unfair_lock_lock(v2);
  v3 = *((unsigned __int8 *)this + 36);
  *((_BYTE *)this + 36) = 0;
  os_unfair_lock_unlock(v2);
  if (v3)
  {
    v4 = (unsigned int *)*((_QWORD *)this + 2);
    v5 = v4 + 2;
    do
    {
      v6 = __ldxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 8))(v4);
    }
  }
}

uint64_t *RB::CustomShader::Function::function(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t *result;

  result = RB::Device::function_library(*(RB::Device **)a2, *(RB::CustomShader::Library **)(a1 + 16));
  if (result)
  {
    *(uint64_t *)((char *)result + 20) = *(_QWORD *)(a2 + 84);
    return (uint64_t *)RB::FunctionLibrary::function((uint64_t)result, a1, a3, a4);
  }
  return result;
}

_QWORD *RB::CustomShader::Function::encode(RB::CustomShader::Function *this, RB::Encoder *a2)
{
  const char *v4;
  _QWORD *result;
  unint64_t v6;

  RB::Encoder::shared_field_f(a2, 1, *((uint64_t **)this + 2));
  v4 = (const char *)objc_msgSend(*((id *)this + 3), "UTF8String");
  result = (_QWORD *)strlen(v4);
  if (result)
  {
    v6 = (unint64_t)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    return RB::ProtobufEncoder::encode_data(a2, v4, v6);
  }
  return result;
}

void RB::CustomShader::Function::decode(RB::ProtobufDecoder *this@<X0>, char a2@<W1>, uint64_t *a3@<X8>)
{
  unint64_t field;
  size_t *v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;

  if ((a2 & 7) != 2)
  {
    v8 = 0;
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
LABEL_17:
    *a3 = 0;
    goto LABEL_18;
  }
  RB::ProtobufDecoder::begin_message(this);
  field = RB::ProtobufDecoder::next_field(this);
  v6 = 0;
  if (field)
  {
    v7 = 0;
    do
    {
      if ((field >> 3) == 2)
      {
        v9 = RB::ProtobufDecoder::data_field(this, field);
        v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithBytes:length:encoding:", v9, v10, 4);

      }
      else
      {
        if ((field >> 3) == 1)
          v6 = RB::CustomShader::Library::decode(this, field);
        else
          RB::ProtobufDecoder::skip_field(this, field);
        v8 = v7;
      }
      field = RB::ProtobufDecoder::next_field(this);
      v7 = v8;
    }
    while (field);
  }
  else
  {
    v8 = 0;
  }
  RB::ProtobufDecoder::end_message((uint64_t)this);
  if (!v6 || !objc_msgSend(v8, "length"))
    goto LABEL_17;
  RB::CustomShader::Library::intern_function((os_unfair_lock_s *)v6, (NSString *)v8, a3);
LABEL_18:

}

void sub_209B47514(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL RB::CustomShader::Closure::operator==(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  uint64_t v5;
  RB::CustomShader::Value *v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL8 result;
  uint64_t v10;

  v2 = *a1;
  v3 = *a2;
  if (*a1 != *a2)
  {
    v4 = !v2 || v3 == 0;
    if (v4 || *(_DWORD *)(v2 + 32) != *(_DWORD *)(v3 + 32))
      return 0;
  }
  v5 = a1[14];
  if (v5 != a2[14])
    return 0;
  if (a1[13])
    v6 = (RB::CustomShader::Value *)a1[13];
  else
    v6 = (RB::CustomShader::Value *)(a1 + 1);
  if (!v5)
    return 1;
  if (a2[13])
    v7 = a2[13];
  else
    v7 = (uint64_t)(a2 + 1);
  v8 = 24 * v5 - 24;
  do
  {
    result = RB::CustomShader::Value::operator==(v6, v7);
    if (!result)
      break;
    v6 = (RB::CustomShader::Value *)((char *)v6 + 24);
    v7 += 24;
    v10 = v8;
    v8 -= 24;
  }
  while (v10);
  return result;
}

void RB::CustomShader::Closure::ensure_arg(RB::CustomShader::Closure *this, unint64_t a2)
{
  unint64_t v2;
  char *v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  RB::CustomShader::Value *v9;
  char *v10;
  const void **v11;
  unint64_t v12;
  char *v13;
  const void *v14[4];

  v14[3] = *(const void **)MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 14);
  if (v2 <= a2)
  {
    v5 = (char *)this + 8;
    v6 = a2 + 1;
    v14[0] = (const void *)0x401010000000000;
    if (v2 >= a2 + 1)
    {
      v10 = (char *)*((_QWORD *)this + 13);
      if (!v10)
        v10 = v5;
      if (v6 < v2)
      {
        v11 = (const void **)&v10[24 * a2 + 24];
        v12 = a2 + 1;
        do
        {
          RB::CustomShader::Value::reset_data(v11);
          ++v12;
          v11 += 3;
        }
        while (v12 < *((_QWORD *)this + 14));
      }
    }
    else
    {
      if (*((_QWORD *)this + 15) < v6)
      {
        v13 = v5;
        RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow(v5, a2 + 1);
        v2 = *((_QWORD *)this + 14);
        v5 = v13;
      }
      v7 = (char *)*((_QWORD *)this + 13);
      if (!v7)
        v7 = v5;
      if (v2 < v6)
      {
        v8 = a2 - v2 + 1;
        v9 = (RB::CustomShader::Value *)&v7[24 * v2];
        do
        {
          v9 = (RB::CustomShader::Value *)((char *)RB::CustomShader::Value::Value(v9, (const RB::CustomShader::Value *)v14)+ 24);
          --v8;
        }
        while (v8);
      }
    }
    *((_QWORD *)this + 14) = v6;
    RB::CustomShader::Value::reset_data(v14);
  }
}

void sub_209B4772C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, const void *a9)
{
  RB::CustomShader::Value::reset_data(&a9);
  _Unwind_Resume(a1);
}

uint64_t RB::CustomShader::Closure::prepare(uint64_t this, uint64_t **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  int v12;
  __int16 v13;
  float64x2_t v14[2];
  uint64_t v15;
  uint64_t v16;
  _QWORD v17[4];
  __int128 v18;
  __int128 v19;
  int v20;
  uint64_t v21;
  __int16 v22;
  __int16 v23;

  v2 = this + 8;
  v3 = *(_QWORD *)(this + 112);
  if (*(_QWORD *)(this + 104))
    v2 = *(_QWORD *)(this + 104);
  if (v3)
  {
    v5 = 24 * v3;
    v6 = v2 + 8;
    __asm { FMOV            V8.2S, #1.0 }
    do
    {
      v12 = *(unsigned __int8 *)(v6 - 4);
      if ((v12 - 9) >= 0xFFFFFFFE)
      {
        v16 = 0;
        v17[0] = 0;
        v17[1] = _D8;
        v17[2] = 0;
        v17[3] = 0;
        v20 = 1065353216;
        v18 = xmmword_209BD5460;
        v19 = xmmword_209BD5460;
        v21 = 0x3C003C003C003C00;
        v22 = 0;
        if (v12 == 8)
          v13 = 768;
        else
          v13 = 256;
        v23 = v13;
        v14[0] = (float64x2_t)xmmword_209BD5290;
        v14[1] = (float64x2_t)xmmword_209BD52A0;
        v15 = 0;
        this = RB::ImageTexture::prepare(v6, a2, (const RB::Fill::ImageData *)v17, v14, 1);
      }
      v6 += 24;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::CustomShader::Value::image(RB::CustomShader::Value *this)
{
  if (*((unsigned __int8 *)this + 4) - 7 >= 2)
    return 0;
  else
    return (uint64_t)this + 8;
}

uint64_t RB::CustomShader::Closure::marshal_args(_QWORD *a1, uint64_t a2, uint64_t a3, _OWORD *a4, uint64_t a5, uint64_t a6, uint64_t *a7, double a8, float32x4_t a9)
{
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  float32x4_t v26;
  uint64_t v27;
  _QWORD *v28;
  _BYTE *v29;
  int v30;
  unsigned int *v31;
  unint64_t v32;
  int v33;
  uint64_t *v34;
  CGImage **v35;
  __int16 v36;
  RB::Device ***v37;
  uint64_t v38;
  uint64_t *v39;
  _QWORD *v40;
  float16x4_t *v41;
  char v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  RB::Device *v47;
  void *v48;
  uint64_t v49;
  float32x4_t v50;
  uint64_t v51;
  float32x4_t v52;
  char *v53;
  char *v54;
  _QWORD *v55;
  void *v56;
  void *v57;
  uint64_t v58;
  const __CFString *v59;
  uint64_t v61;
  uint64_t v62;
  RB::Device *v63;
  uint64_t v65;
  float64x2_t v67[2];
  uint64_t v68;
  uint64_t v69;
  _BYTE v70[32];
  __int128 v71;
  __int128 v72;
  int v73;
  uint64_t v74;
  int v75;
  char *v76;
  uint64_t v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  _QWORD v84[3];

  v9 = a1;
  v84[1] = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD *)(a3 + 64);
  v11 = a1[14];
  if (v10 == v11)
  {
    v65 = *(_QWORD *)(a3 + 64);
    v81 = 0x401010000000000;
    if (a4)
    {
      *(_OWORD *)v70 = *a4;
      RB::CustomShader::Value::set_bytes((uint64_t)&v81, 4u, 1uLL, v70);
      v65 = *(_QWORD *)(a3 + 64);
    }
    v61 = a6;
    v62 = a2;
    v15 = v9 + 1;
    v76 = 0;
    v77 = 0;
    v78 = 0;
    *a7 = 0;
    v16 = v65;
    if (v65)
    {
      v17 = 0;
      v63 = 0;
      v18 = 0;
      v19 = a3;
      v20 = 4;
      __asm { FMOV            V8.2S, #1.0 }
      v26 = (float32x4_t)xmmword_209BD52A0;
      while (1)
      {
        if (*(_QWORD *)(v19 + 56))
          v27 = *(_QWORD *)(v19 + 56);
        else
          v27 = a3 + 24;
        v28 = (_QWORD *)v9[13];
        if (!v28)
          v28 = v15;
        v29 = (char *)v28 + v20;
        v30 = *((unsigned __int8 *)v28 + v20);
        if (v30 == 6)
          v31 = (unsigned int *)&v81;
        else
          v31 = (unsigned int *)((char *)v28 + v20 - 4);
        v32 = *(unsigned int *)(v27 + 4 * v18);
        v33 = *(_DWORD *)(v27 + 4 * v18) & 0x3F;
        if (v33 == 4)
        {
          if (v30 == 6)
            v29 = (char *)&v81 + 4;
          if (*v29 - 7 > 1)
            goto LABEL_54;
          if (!*a7)
          {
            v34 = (_QWORD *)((char *)v28 + v20 + 4);
            v35 = (CGImage **)(v30 == 6 ? &v82 : v34);
            *(_QWORD *)v70 = 0;
            *(_QWORD *)&v70[8] = _D8;
            *(_OWORD *)&v70[16] = 0uLL;
            v73 = 1065353216;
            v71 = xmmword_209BD5460;
            v72 = xmmword_209BD5460;
            v74 = 0x3C003C003C003C00;
            v75 = 0x1000000;
            v36 = *v29 == 8 ? 768 : 256;
            HIWORD(v75) = v36;
            v37 = *(RB::Device ****)v62;
            v67[0] = (float64x2_t)xmmword_209BD5290;
            v67[1] = (float64x2_t)xmmword_209BD52A0;
            v68 = 0;
            v69 = 0;
            v38 = RB::ImageTexture::texture(v35, (uint64_t **)v37, (const RB::Fill::ImageData *)v70, v67, 1);
            *a7 = v38;
            v19 = a3;
            if (!v38)
              *a7 = RB::Device::invalid_texture(***(RB::Device ****)v62);
          }
        }
        else
        {
          v39 = a7;
          v40 = v9;
          v41 = (float16x4_t *)(a5 + ((v32 >> 6) & 0x3FFFFFC));
          if ((v32 & 0x40) != 0)
          {
            if ((RB::CustomShader::Value::prepare_array(v31, v33, (uint64_t)v70) & 1) == 0)
              goto LABEL_53;
            v43 = ((_DWORD)v63 + 15);
            if (((v43 >> 31) & 1) != 0)
              goto LABEL_55;
            v44 = v43 & 0xFFFFFFF0;
            v41->i32[0] = v43 & 0xFFFFFFF0;
            v45 = v77;
            if (v78 < v77 + 1)
            {
              RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow((uint64_t)&v76, v77 + 1);
              v45 = v77;
            }
            v46 = &v76[48 * v45];
            *(_QWORD *)v46 = v18;
            *((_QWORD *)v46 + 1) = v44;
            *((_OWORD *)v46 + 1) = *(_OWORD *)v70;
            v26 = *(float32x4_t *)&v70[16];
            *((_OWORD *)v46 + 2) = *(_OWORD *)&v70[16];
            ++v77;
            _CF = __CFADD__(v44, *(_QWORD *)&v70[24]);
            v47 = (RB::Device *)(v44 + *(_QWORD *)&v70[24]);
            v19 = a3;
            if (_CF)
              goto LABEL_55;
            if ((*(_BYTE *)(v27 + 4 * v18) & 0x80) != 0)
            {
              if (*(_QWORD *)&v70[8] >> 31)
              {
LABEL_53:
                v9 = v40;
LABEL_54:
                v56 = (void *)MEMORY[0x24BDD1540];
                v79 = *MEMORY[0x24BDD0FC8];
                v57 = (void *)MEMORY[0x24BDD17C8];
                v58 = *(_QWORD *)(*v9 + 24);
                v59 = RB::CustomShader::Value::description((RB::CustomShader::Value *)v31);
                v80 = objc_msgSend(v57, "stringWithFormat:", CFSTR("Invalid shader argument: %@, #%d: %@, expected %@"), v58, v18, v59, RB::Function::Param::description((RB::Function::Param *)(v27 - v17)));
                RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(*v9 + 16), (NSError *)objc_msgSend(v56, "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 3, objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v80, &v79, 1)));
LABEL_55:
                v49 = 0;
LABEL_56:
                v53 = v76;
                if (v76)
                  goto LABEL_57;
                goto LABEL_58;
              }
              v41->i32[1] = *(_DWORD *)&v70[8];
            }
            v63 = v47;
            v9 = v40;
            a7 = v39;
            v16 = v65;
          }
          else
          {
            v42 = RB::CustomShader::Value::convert((uint64_t)v31, v33, v41, *(unsigned __int8 *)(v62 + 124), v26, a9);
            v9 = v40;
            a7 = v39;
            v16 = v65;
            if ((v42 & 1) == 0)
              goto LABEL_54;
          }
        }
        ++v18;
        v20 += 24;
        v17 -= 4;
        if (v16 == v18)
          goto LABEL_44;
      }
    }
    v63 = 0;
LABEL_44:
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v62, v63, 4uLL, 0, v70);
    v51 = *(_QWORD *)v70;
    *(_QWORD *)v61 = *(_QWORD *)v70;
    v52 = *(float32x4_t *)&v70[8];
    *(_OWORD *)(v61 + 8) = *(_OWORD *)&v70[8];
    if (!v51)
      goto LABEL_55;
    v53 = v76;
    if (v77)
    {
      v54 = &v76[48 * v77];
      do
      {
        v55 = (_QWORD *)v9[13];
        if (!v55)
          v55 = v15;
        RB::CustomShader::Value::convert((uint64_t)&v55[3 * *(_QWORD *)v53], v53[16], *((_QWORD *)v53 + 4), (float16x4_t *)(*(_QWORD *)(*(_QWORD *)v61 + 56) + *(_QWORD *)(v61 + 8) + *((_QWORD *)v53 + 1)), *(unsigned __int8 *)(v62 + 124), v52, v50);
        v53 += 48;
      }
      while (v53 != v54);
      v49 = 1;
      goto LABEL_56;
    }
    v49 = 1;
    if (v76)
LABEL_57:
      free(v53);
LABEL_58:
    RB::CustomShader::Value::reset_data((const void **)&v81);
  }
  else
  {
    v48 = (void *)MEMORY[0x24BDD1540];
    v83 = *MEMORY[0x24BDD0FC8];
    v84[0] = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Invalid number of shader arguments: %@: %d, expected %d"), *(_QWORD *)(*a1 + 24), v11, v10);
    RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(*v9 + 16), (NSError *)objc_msgSend(v48, "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 4, objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v84, &v83, 1)));
    return 0;
  }
  return v49;
}

void sub_209B47DEC(_Unwind_Exception *a1)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 192);
  if (v3)
    free(v3);
  RB::CustomShader::Value::reset_data((const void **)(v1 - 152));
  _Unwind_Resume(a1);
}

void RB::CustomShader::Value::set_bytes(uint64_t a1, unsigned int a2, unint64_t a3, const UInt8 *a4)
{
  const void *v8;
  const void *v9;
  size_t v10;

  RB::CustomShader::Value::reset_data((const void **)a1);
  if (!HIDWORD(a3))
  {
    *(_DWORD *)a1 = a3;
    *(_BYTE *)(a1 + 4) = a2;
    if (a2 - 7 > 1)
    {
      v10 = *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + a2) * a3;
      if (v10 > 0x10)
      {
        *(_BYTE *)(a1 + 7) &= ~4u;
        *(_QWORD *)(a1 + 8) = CFDataCreate(0, a4, v10);
      }
      else
      {
        memcpy((void *)(a1 + 8), a4, v10);
      }
    }
    else
    {
      v8 = (const void *)*((_QWORD *)a4 + 1);
      if (v8)
      {
        CFRetain(v8);
        v9 = (const void *)*((_QWORD *)a4 + 1);
      }
      else
      {
        v9 = 0;
      }
      RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 8), (CGImage *)*(unsigned int *)a4, v9);
    }
  }
}

uint64_t RB::CustomShader::Value::convert(uint64_t a1, int a2, float16x4_t *__dst, int a4, float32x4_t a5, float32x4_t a6)
{
  char v7;
  CFDataRef *BytePtr;
  char v9;
  const UInt8 *v10;
  CFDataRef v11;
  char v12;
  CFDataRef *v13;
  uint64_t v14;
  char v15;
  CFDataRef *v16;

  if (*(_DWORD *)a1 != 1)
    return 0;
  switch(*(_BYTE *)(a1 + 4))
  {
    case 1:
      if (a2 != 5)
        return 0;
      v7 = *(_BYTE *)(a1 + 7);
      BytePtr = (CFDataRef *)(a1 + 8);
      if ((v7 & 4) == 0)
        BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
      __dst->i32[0] = *(_DWORD *)BytePtr;
      goto LABEL_22;
    case 2:
      if (a2 != 6)
        return 0;
      v15 = *(_BYTE *)(a1 + 7);
      v16 = (CFDataRef *)(a1 + 8);
      if ((v15 & 4) == 0)
        v16 = (CFDataRef *)CFDataGetBytePtr(*v16);
      v11 = *v16;
      goto LABEL_21;
    case 3:
      if (a2 != 7)
        return 0;
      v9 = *(_BYTE *)(a1 + 7);
      v10 = (const UInt8 *)(a1 + 8);
      if ((v9 & 4) == 0)
        v10 = CFDataGetBytePtr(*(CFDataRef *)v10);
      v11 = *(CFDataRef *)v10;
      __dst[1].i32[0] = *((_DWORD *)v10 + 2);
LABEL_21:
      *__dst = (float16x4_t)v11;
      goto LABEL_22;
    case 4:
      if (a2 != 8)
        return 0;
      v12 = *(_BYTE *)(a1 + 7);
      v13 = (CFDataRef *)(a1 + 8);
      if ((v12 & 4) == 0)
        v13 = (CFDataRef *)CFDataGetBytePtr(*v13);
      *(_OWORD *)__dst->i8 = *(_OWORD *)v13;
LABEL_22:
      v14 = 1;
      break;
    case 5:
      if (a2 != 2)
        return 0;
      v14 = 1;
      RB::CustomShader::Value::convert(a1, 2, 1uLL, __dst, a4, a5, a6);
      break;
    default:
      return 0;
  }
  return v14;
}

uint64_t RB::CustomShader::Value::prepare_array(unsigned int *a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  uint64_t v7;

  switch(*((_BYTE *)a1 + 4))
  {
    case 0:
      if (a2)
        goto LABEL_16;
      *(_BYTE *)a3 = 0;
      v3 = *a1;
      *(_QWORD *)(a3 + 8) = v3;
      *(_QWORD *)(a3 + 16) = v3;
      goto LABEL_15;
    case 1:
      if (a2 != 5)
        goto LABEL_16;
      v4 = *a1;
      v5 = v4;
      goto LABEL_12;
    case 2:
      if (a2 != 6)
        goto LABEL_16;
      v4 = *a1;
      v5 = 2 * v4;
      goto LABEL_12;
    case 3:
      if (a2 != 7)
        goto LABEL_16;
      v4 = *a1;
      v5 = 3 * v4;
      goto LABEL_12;
    case 4:
      if (a2 != 8)
        goto LABEL_16;
      v4 = *a1;
      v5 = 4 * v4;
LABEL_12:
      result = 1;
      *(_BYTE *)a3 = 1;
      *(_QWORD *)(a3 + 8) = v4;
      *(_QWORD *)(a3 + 16) = v5;
      *(_QWORD *)(a3 + 24) = 4 * v5;
      break;
    case 5:
      if (a2 != 2)
        goto LABEL_16;
      *(_BYTE *)a3 = 2;
      v7 = *a1;
      *(_QWORD *)(a3 + 8) = v7;
      *(_QWORD *)(a3 + 16) = v7;
      v3 = 8 * v7;
LABEL_15:
      *(_QWORD *)(a3 + 24) = v3;
      result = 1;
      break;
    default:
LABEL_16:
      result = 0;
      break;
  }
  return result;
}

const __CFString *RB::CustomShader::Value::description(RB::CustomShader::Value *this)
{
  unint64_t v1;
  char *v2;
  uint64_t v3;

  v1 = *((unsigned __int8 *)this + 4);
  if (v1 > 7)
    return CFSTR("Unknown");
  v2 = (&RB::CustomShader::Value::description(void)const::names)[v1];
  v3 = *(unsigned int *)this;
  if ((_DWORD)v3 == 1)
    return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v2);
  else
    return (const __CFString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s[%u]"), v2, v3);
}

uint64_t RB::CustomShader::Value::convert(uint64_t a1, int a2, size_t __n, float16x4_t *__dst, int a5, float32x4_t a6, float32x4_t _Q1)
{
  CFDataRef *BytePtr;
  unsigned __int32 *v13;
  unsigned int v20;
  unint64_t v22;
  __int16 v23;

  BytePtr = (CFDataRef *)(a1 + 8);
  if ((*(_BYTE *)(a1 + 7) & 4) == 0)
    BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
  if (a2)
  {
    if (a2 != 1)
    {
      if (a2 == 2 && __n)
      {
        v13 = (unsigned __int32 *)BytePtr + 3;
        do
        {
          a6.i64[0] = *(_QWORD *)(v13 - 3);
          *(float16x4_t *)a6.f32 = vcvt_f16_f32(a6);
          _S1 = *(v13 - 1);
          __asm { FCVT            H2, S1 }
          _Q1.i32[0] = *v13;
          __asm { FCVT            H1, S1 }
          v20 = *(unsigned __int16 *)(a1 + 5);
          if (v20 < 0x100 || a5 == v20)
          {
            a6.i16[2] = _H2;
            a6.i16[3] = unk_209BD6C5C;
          }
          else
          {
            LODWORD(v22) = a6.i32[0];
            WORD2(v22) = _H2;
            HIWORD(v22) = _Q1.i16[0];
            v23 = v20;
            RB::Fill::Color::convert((uint64_t)&v22, a5, *(uint16x4_t *)a6.f32);
            a6.i16[3] = 15360;
            a6.i32[0] = v22;
            a6.i16[2] = WORD2(v22);
            _Q1.i32[0] = HIWORD(v22);
          }
          _Q1 = vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)_Q1.f32, 0));
          a6 = vmulq_f32(_Q1, vcvtq_f32_f16(*(float16x4_t *)a6.f32));
          *__dst++ = vcvt_f16_f32(a6);
          v13 += 4;
          --__n;
        }
        while (__n);
      }
      return 1;
    }
    __n *= 4;
  }
  switch(__n)
  {
    case 1uLL:
      __dst->i8[0] = *(_BYTE *)BytePtr;
      break;
    case 2uLL:
      __dst->i16[0] = *(_WORD *)BytePtr;
      break;
    case 3uLL:
    case 5uLL:
    case 6uLL:
    case 7uLL:
      goto LABEL_19;
    case 4uLL:
      __dst->i32[0] = *(_DWORD *)BytePtr;
      break;
    case 8uLL:
      *__dst = (float16x4_t)*BytePtr;
      break;
    default:
      if (__n == 16)
        *(_OWORD *)__dst->i8 = *(_OWORD *)BytePtr;
      else
LABEL_19:
        memcpy(__dst, BytePtr, __n);
      break;
  }
  return 1;
}

uint64_t RB::CustomShader::Closure::marshal_layer_arg(uint64_t a1, uint64_t a2, uint64_t a3, int a4, float64x2_t *a5, float32x2_t *a6)
{
  float32x2_t *v6;

  v6 = (float32x2_t *)(a3 + (4 * a4));
  *v6 = vcvt_f32_f64(*a5);
  v6[1] = vcvt_f32_f64(a5[1]);
  v6[2] = vcvt_f32_f64(a5[2]);
  v6[3] = *a6;
  v6[4] = vadd_f32(a6[1], *a6);
  return 1;
}

BOOL RB::CustomShader::Closure::can_mix(RB::CustomShader::Closure *this, const Closure *a2)
{
  return *(_DWORD *)(*(_QWORD *)this + 32) == *((_DWORD *)a2->function._p + 8);
}

void RB::CustomShader::Closure::mix(RB::CustomShader::Closure *this, const RB::CustomShader::Closure *a2, float32_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  unint64_t v8;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  int v17;
  BOOL v18;
  CFDataRef *BytePtr;
  char *v20;
  UInt8 *v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  float v25;
  unint64_t v26;
  char *v27;
  char *v28;
  __int16 v29;
  __int16 v30;
  float32x4_t v31;
  unint64_t v32;
  char *v33;
  float16x4_t v34;
  __int16 v35;
  float16x4_t v36;
  __int16 v37;

  v8 = *((_QWORD *)this + 14);
  if (*((_QWORD *)a2 + 14) < v8)
    v8 = *((_QWORD *)a2 + 14);
  if (v8)
  {
    v12 = 0;
    v33 = (char *)a2 + 8;
    v13 = (char *)this + 8;
    do
    {
      if (*((_QWORD *)this + 13))
        v14 = (char *)*((_QWORD *)this + 13);
      else
        v14 = v13;
      v15 = &v14[24 * v12];
      if (*((_QWORD *)a2 + 13))
        v16 = (char *)*((_QWORD *)a2 + 13);
      else
        v16 = v33;
      v17 = v15[4];
      if (v15[4])
        v18 = v17 == v16[24 * v12 + 4];
      else
        v18 = 0;
      if (v18 && *(_DWORD *)v15 == *(_DWORD *)&v16[24 * v12])
      {
        BytePtr = (CFDataRef *)&RB::CustomShader::Value::data_ptr(void)const::null_image;
        if ((v17 - 7) >= 2)
        {
          v20 = &v16[24 * v12];
          BytePtr = (CFDataRef *)(v20 + 8);
          if ((v20[7] & 4) == 0)
            BytePtr = (CFDataRef *)CFDataGetBytePtr(*BytePtr);
        }
        if ((v14[24 * v12 + 7] & 4) != 0)
          v21 = (UInt8 *)&v14[24 * v12 + 8];
        else
          v21 = RB::CustomShader::Value::mutable_data_ptr((RB::CustomShader::Value *)&v14[24 * v12]);
        v22 = v15[4];
        if ((v22 - 1) >= 4)
        {
          if (v22 == 5 && *(_DWORD *)v15)
          {
            v26 = 0;
            v27 = &v14[24 * v12 + 5];
            v28 = &v16[24 * v12 + 5];
            do
            {
              v29 = *(_WORD *)v27;
              v36 = vcvt_f16_f32(*(float32x4_t *)&v21[16 * v26]);
              v37 = v29;
              v30 = *(_WORD *)v28;
              v31 = *(float32x4_t *)&BytePtr[2 * v26];
              *(float16x4_t *)v31.f32 = vcvt_f16_f32(v31);
              v34 = *(float16x4_t *)v31.f32;
              v35 = v30;
              v31.f32[0] = a3;
              RB::Fill::Color::mix(&v36, &v34, 3, (int8x16_t)v31, a4, a5, a6, a7, a8);
              *(float32x4_t *)&v21[16 * v26] = vcvtq_f32_f16(v36);
              if (!v26)
                *(_WORD *)v27 = v37;
              ++v26;
            }
            while (v26 < *(unsigned int *)v15);
          }
        }
        else
        {
          v23 = *(_DWORD *)v15;
          if (v22 == 2)
            v23 = 2 * *(_DWORD *)v15;
          if (v22 == 3)
            v23 = 3 * *(_DWORD *)v15;
          if (v22 == 4)
            v24 = (4 * *(_DWORD *)v15);
          else
            v24 = v23;
          if ((_DWORD)v24)
          {
            do
            {
              v25 = *(float *)BytePtr;
              BytePtr = (CFDataRef *)((char *)BytePtr + 4);
              a4.i32[0] = *(_DWORD *)v21;
              *(float *)v21 = *(float *)v21 + (float)((float)(v25 - *(float *)v21) * a3);
              v21 += 4;
              --v24;
            }
            while (v24);
          }
        }
      }
      ++v12;
      v32 = *((_QWORD *)this + 14);
      if (*((_QWORD *)a2 + 14) < v32)
        v32 = *((_QWORD *)a2 + 14);
    }
    while (v12 < v32);
  }
}

CFDataRef *RB::CustomShader::Value::data_ptr(RB::CustomShader::Value *this)
{
  CFDataRef *result;
  char v2;

  if (*((unsigned __int8 *)this + 4) - 7 < 2)
    return (CFDataRef *)&RB::CustomShader::Value::data_ptr(void)const::null_image;
  v2 = *((_BYTE *)this + 7);
  result = (CFDataRef *)((char *)this + 8);
  if ((v2 & 4) == 0)
    return (CFDataRef *)CFDataGetBytePtr(*result);
  return result;
}

UInt8 *RB::CustomShader::Value::mutable_data_ptr(RB::CustomShader::Value *this)
{
  CFDataRef *v1;
  CFMutableDataRef MutableCopy;
  __CFData *v3;

  if (*((unsigned __int8 *)this + 4) - 7 >= 2)
  {
    v1 = (CFDataRef *)((char *)this + 8);
    if ((*((_BYTE *)this + 7) & 4) != 0)
      return (UInt8 *)v1;
    MutableCopy = CFDataCreateMutableCopy(0, 0, *v1);
    if (MutableCopy)
    {
      v3 = MutableCopy;
      CFRelease(*v1);
      *v1 = v3;
      return CFDataGetMutableBytePtr(v3);
    }
  }
  return 0;
}

uint64_t *RB::CustomShader::Closure::prepare_encode(RB::CustomShader::Closure *this, RB::Encoder *a2)
{
  uint64_t *result;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;

  result = RB::CustomShader::Library::prepare_encode(*(uint64_t **)(*(_QWORD *)this + 16), a2);
  v5 = (char *)this + 8;
  v6 = *((_QWORD *)this + 14);
  if (*((_QWORD *)this + 13))
    v5 = (char *)*((_QWORD *)this + 13);
  if (v6)
  {
    v7 = 24 * v6;
    v8 = v5 + 8;
    do
    {
      if (*(v8 - 4) - 7 <= 1)
        result = RB::Encoder::prepare_image((uint64_t *)a2, *((unsigned int *)v8 + 2), *(uint64_t **)v8);
      v8 += 24;
      v7 -= 24;
    }
    while (v7);
  }
  return result;
}

RB::CustomShader::Function **RB::CustomShader::Closure::encode(RB::CustomShader::Function **this, RB::Encoder *a2)
{
  RB::CustomShader::Function **v3;
  RB::CustomShader::Function *v4;
  RB::CustomShader::Function *v5;
  RB::CustomShader::Function *v6;
  uint64_t v7;

  v3 = this;
  v4 = *this;
  if (*this)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::CustomShader::Function::encode(v4, a2);
    this = (RB::CustomShader::Function **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v5 = v3[14];
  if (v3[13])
    v6 = v3[13];
  else
    v6 = (RB::CustomShader::Function *)(v3 + 1);
  if (v5)
  {
    v7 = 24 * (_QWORD)v5;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::CustomShader::Value::encode(v6, a2);
      this = (RB::CustomShader::Function **)RB::ProtobufEncoder::end_length_delimited(a2);
      v6 = (RB::CustomShader::Function *)((char *)v6 + 24);
      v7 -= 24;
    }
    while (v7);
  }
  return this;
}

unint64_t RB::CustomShader::Closure::decode(RB::CustomShader::Closure *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  char *v11;
  char *v12;
  uint64_t v13;
  char *v14;
  RB::CustomShader::Value *v15;
  uint64_t v16;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        v10 = *((_QWORD *)this + 14);
        if (*((_QWORD *)this + 15) < (unint64_t)(v10 + 1))
        {
          RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow((char *)this + 8, v10 + 1);
          v10 = *((_QWORD *)this + 14);
        }
        v11 = (char *)*((_QWORD *)this + 13);
        if (!v11)
          v11 = (char *)this + 8;
        v12 = &v11[24 * v10];
        *(_DWORD *)v12 = 0;
        *((_WORD *)v12 + 2) = 256;
        v12[6] = 1;
        v12[7] = v12[7] & 0xF8 | 4;
        v13 = *((_QWORD *)this + 14);
        *((_QWORD *)this + 14) = v13 + 1;
        if ((v5 & 7) == 2)
        {
          v14 = (char *)*((_QWORD *)this + 13);
          if (!v14)
            v14 = (char *)this + 8;
          v15 = (RB::CustomShader::Value *)&v14[24 * v13];
          RB::ProtobufDecoder::begin_message(a2);
          RB::CustomShader::Value::decode(v15, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else if ((v5 >> 3) == 1)
      {
        RB::CustomShader::Function::decode(a2, v5, &v16);
        v6 = *(_QWORD *)this;
        *(_QWORD *)this = v16;
        v16 = v6;
        if (v6)
        {
          v7 = (unsigned int *)(v6 + 8);
          do
          {
            v8 = __ldxr(v7);
            v9 = v8 - 1;
          }
          while (__stlxr(v9, v7));
          if (!v9)
          {
            __dmb(9u);
            (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
          }
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  if (!*(_QWORD *)this)
  {
    *((_BYTE *)a2 + 56) = 1;
    *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
  }
  return result;
}

void RB::CustomShader::Value::reset_data(const void **this)
{
  if ((*((_BYTE *)this + 7) & 4) != 0)
  {
    if (*((unsigned __int8 *)this + 4) - 7 <= 1)
      RB::RetainedImageTexture::~RetainedImageTexture(this + 1);
  }
  else
  {
    CFRelease(this[1]);
    *((_BYTE *)this + 7) |= 4u;
  }
  *(_DWORD *)this = 0;
  *((_BYTE *)this + 4) = 0;
}

unint64_t RB::CustomShader::Value::set_data(uint64_t a1, int a2, const __CFData *a3)
{
  unint64_t result;
  unint64_t v7;
  size_t v8;
  const UInt8 *BytePtr;

  RB::CustomShader::Value::reset_data((const void **)a1);
  result = CFDataGetLength(a3);
  v7 = HIDWORD(result);
  if (!HIDWORD(result))
  {
    v8 = result;
    switch(a2)
    {
      case 0:
        LODWORD(v7) = result;
        goto LABEL_8;
      case 1:
        v7 = result >> 2;
        goto LABEL_8;
      case 2:
        v7 = result >> 3;
        goto LABEL_8;
      case 3:
        LODWORD(v7) = result / 0xC;
        goto LABEL_8;
      case 4:
      case 5:
        v7 = result >> 4;
        goto LABEL_8;
      case 7:
      case 8:
        return result;
      default:
LABEL_8:
        *(_DWORD *)a1 = v7;
        *(_BYTE *)(a1 + 4) = a2;
        if (result > 0x10)
        {
          *(_BYTE *)(a1 + 7) &= ~4u;
          result = (unint64_t)CFDataCreateCopy(0, a3);
          *(_QWORD *)(a1 + 8) = result;
        }
        else
        {
          BytePtr = CFDataGetBytePtr(a3);
          result = (unint64_t)memcpy((void *)(a1 + 8), BytePtr, v8);
        }
        break;
    }
  }
  return result;
}

RB::CustomShader::Value *RB::CustomShader::Value::Value(RB::CustomShader::Value *this, const RB::CustomShader::Value *a2)
{
  int v3;
  char v4;
  char v5;
  int v6;
  _OWORD *v7;
  CFTypeRef *v8;

  *(_DWORD *)this = *(_DWORD *)a2;
  v3 = *((unsigned __int8 *)a2 + 4);
  *((_BYTE *)this + 4) = v3;
  *(_WORD *)((char *)this + 5) = *(_WORD *)((char *)a2 + 5);
  v4 = *((_BYTE *)this + 7) & 0xFE | *((_BYTE *)a2 + 7) & 1;
  *((_BYTE *)this + 7) = v4;
  v5 = v4 & 0xFD | *((_BYTE *)a2 + 7) & 2;
  *((_BYTE *)this + 7) = v5;
  v6 = *((_BYTE *)a2 + 7) & 4;
  *((_BYTE *)this + 7) = v5 & 0xFB | v6;
  v7 = (_OWORD *)((char *)this + 8);
  if ((v3 - 7) > 1)
  {
    v8 = (CFTypeRef *)((char *)a2 + 8);
    if (v6)
      *v7 = *(_OWORD *)v8;
    else
      *(_QWORD *)v7 = CFRetain(*v8);
  }
  else
  {
    RB::RetainedImageTexture::RetainedImageTexture((RB::CustomShader::Value *)((char *)this + 8), (const RB::CustomShader::Value *)((char *)a2 + 8));
  }
  return this;
}

BOOL RB::CustomShader::Value::operator==(RB::CustomShader::Value *this, uint64_t a2)
{
  int v2;
  int v5;
  BOOL v6;
  CFDataRef *v9;
  CFDataRef *v10;

  v2 = *((unsigned __int8 *)this + 4);
  if (v2 != *(unsigned __int8 *)(a2 + 4) || *(_DWORD *)this != *(_DWORD *)a2)
    return 0;
  v5 = *(unsigned __int8 *)(a2 + 6);
  if (*((_BYTE *)this + 6))
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    if ((*((_BYTE *)this + 6) != 0) != (v5 != 0))
      return 0;
  }
  else if (*((unsigned __int8 *)this + 5) != *(unsigned __int8 *)(a2 + 5))
  {
    return 0;
  }
  if (((*(_BYTE *)(a2 + 7) ^ *((_BYTE *)this + 7)) & 3) != 0)
    return 0;
  if ((v2 - 7) > 1)
  {
    v9 = RB::CustomShader::Value::data_ptr(this);
    v10 = RB::CustomShader::Value::data_ptr((RB::CustomShader::Value *)a2);
    return memcmp(v9, v10, *(_DWORD *)this* *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element+ *((unsigned __int8 *)this + 4))) == 0;
  }
  else
  {
    if (*((_QWORD *)this + 1) != *(_QWORD *)(a2 + 8))
      return 0;
    return *((_DWORD *)this + 4) == *(_DWORD *)(a2 + 16);
  }
}

_QWORD *RB::CustomShader::Value::encode(_QWORD *this, RB::Encoder *a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unsigned int v6;
  const UInt8 *BytePtr;
  _QWORD *v8;
  RB::ProtobufEncoder *v9;
  const UInt8 *v10;
  unint64_t v11;
  unint64_t v12;
  int v13;
  unint64_t v14;

  v3 = (uint64_t)this;
  v4 = *(unsigned int *)this;
  if ((_DWORD)v4 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  v5 = *(unsigned __int8 *)(v3 + 4);
  if (v5 == 1)
  {
    v6 = 1u;
  }
  else
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v5);
    v6 = *(unsigned __int8 *)(v3 + 4);
    if (v6 - 7 <= 1)
    {
      this = RB::Encoder::image_field(a2, 6, *(_DWORD *)(v3 + 16), *(uint64_t **)(v3 + 8));
      goto LABEL_13;
    }
  }
  if ((*(_BYTE *)(v3 + 7) & 4) != 0)
  {
    v12 = *(_DWORD *)v3 * *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v6);
    if ((_DWORD)v12)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      v9 = a2;
      v10 = (const UInt8 *)(v3 + 8);
      v11 = v12;
      goto LABEL_12;
    }
  }
  else
  {
    BytePtr = CFDataGetBytePtr(*(CFDataRef *)(v3 + 8));
    this = (_QWORD *)CFDataGetLength(*(CFDataRef *)(v3 + 8));
    if (this)
    {
      v8 = this;
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      v9 = a2;
      v10 = BytePtr;
      v11 = (unint64_t)v8;
LABEL_12:
      this = RB::ProtobufEncoder::encode_data(v9, v10, v11);
    }
  }
LABEL_13:
  if (*(_BYTE *)(v3 + 4) == 5 && *(_BYTE *)(v3 + 6))
  {
    v13 = rb_color_space(*(unsigned __int8 *)(v3 + 5) | 0x100u);
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v13);
  }
  if ((*(_BYTE *)(v3 + 7) & 1) != 0)
  {
    if ((*(_BYTE *)(v3 + 7) & 2) != 0)
      v14 = 2;
    else
      v14 = 1;
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    return RB::ProtobufEncoder::encode_varint(a2, v14);
  }
  return this;
}

void RB::CustomShader::Value::decode(RB::CustomShader::Value *this, RB::Decoder *a2)
{
  uint64_t v4;
  const UInt8 *v5;
  CFTypeRef v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t field;
  uint64_t v12;
  unsigned int v13;
  unsigned __int16 v14;
  unsigned __int8 v15;
  unsigned int v16;
  uint64_t v17;
  CFTypeRef v18;
  const void *v19;
  _QWORD v20[2];

  v4 = 0;
  v5 = 0;
  v6 = 0;
  v7 = 0;
  v8 = 1;
  v9 = 1;
  while (1)
  {
    v10 = v8;
    field = RB::ProtobufDecoder::next_field(a2);
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v9 = RB::ProtobufDecoder::uint_field(a2, field);
        v8 = v10;
        continue;
      case 2u:
        v8 = RB::ProtobufDecoder::uint_field(a2, field);
        if (v8 > 8)
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          goto LABEL_18;
        }
        continue;
      case 3u:
        v5 = (const UInt8 *)RB::ProtobufDecoder::data_field(a2, field);
        v4 = v12;
        goto LABEL_18;
      case 4u:
        v13 = RB::ProtobufDecoder::uint_field(a2, field);
        v14 = rb_color_space(v13);
        v15 = v14;
        v16 = v14;
        v8 = v10;
        if (v16 < 0x100)
          continue;
        *(_WORD *)((char *)this + 5) = v15 | 0x100;
LABEL_18:
        v8 = v10;
        break;
      case 5u:
        v17 = RB::ProtobufDecoder::uint_field(a2, field);
        *((_BYTE *)this + 7) = (v17 != 0) | (2 * (v17 == 2)) | *((_BYTE *)this + 7) & 0xFC;
        goto LABEL_18;
      case 6u:
        v7 = RB::Decoder::image_field(a2, field);
        v19 = v18;
        if (v6 != v18)
        {
          if (v6)
            CFRelease(v6);
          if (v19)
            v6 = CFRetain(v19);
          else
            v6 = 0;
        }
        goto LABEL_18;
      default:
        RB::ProtobufDecoder::skip_field(a2, field);
        v8 = v10;
        continue;
    }
  }
  if ((v10 - 7) <= 1u)
  {
    v20[1] = v6;
    v20[0] = v7;
    RB::CustomShader::Value::set_bytes((uint64_t)this, v10, 1uLL, (const UInt8 *)v20);
    goto LABEL_24;
  }
  if (is_mul_ok(v9, *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v10))
    && v4 == v9 * *((unsigned __int8 *)&RB::CustomShader::Value::bytes_per_element + v10))
  {
    RB::CustomShader::Value::set_bytes((uint64_t)this, v10, v9, v5);
LABEL_24:
    if (!v6)
      return;
    goto LABEL_25;
  }
  *((_BYTE *)a2 + 56) = 1;
  *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
  if (!v6)
    return;
LABEL_25:
  CFRelease(v6);
}

void sub_209B48FE0(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Refcount<RB::CustomShader::Library,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::CustomShader::Function,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_1::__invoke(void *a1, const char *a2)
{
  return objc_msgSend(a1, "isEqualToString:", a2);
}

uint64_t RB::CustomShader::Library::Library(RB::CustomShader::Library::Type,objc_object *)::$_2::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t RB::CustomShader::Library::finalize(void)::$_0::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::CustomShader::Library::call_error_handler(NSError *)const::$_0::__invoke(uint64_t a1)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;

  v2 = (uint64_t *)(a1 + 8);
  v3 = *(uint64_t **)(a1 + 72);
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  v5 = *(unsigned int *)(a1 + 80);
  if ((_DWORD)v5)
  {
    v6 = 8 * v5;
    do
    {
      v7 = *v4++;
      (*(void (**)(void))(v7 + 16))();
      v6 -= 8;
    }
    while (v6);
    v3 = *(uint64_t **)(a1 + 72);
    if (v3)
      v2 = *(uint64_t **)(a1 + 72);
    if (*(_DWORD *)(a1 + 80))
    {
      v8 = 0;
      do

      while (v8 < *(unsigned int *)(a1 + 80));
      v3 = *(uint64_t **)(a1 + 72);
    }
  }
  if (v3)
    free(v3);

  JUMPOUT(0x20BD16544);
}

void *RB::vector<RB::objc_ptr<void({block_pointer})(NSError *)>,8ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 19) + (*((_DWORD *)__dst + 19) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 19) + (*((_DWORD *)__dst + 19) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 8), __dst, 8u, (_DWORD *)__dst + 19, v3);
  *((_QWORD *)__dst + 8) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,8ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(8 * a5);
    v9 = v8 >> 3;
    if (*a4 != (v8 >> 3))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 8 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,48ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,48ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(48 * a3);
    v6 = v5 / 0x30;
    if (v5 / 0x30 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::ImageProvider::submit_all(RB::ImageProvider *this)
{
  uint64_t v1;
  _QWORD *v2;
  unint64_t v3;
  uint64_t i;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;
  _QWORD *v10;
  unint64_t v11;

  os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  v1 = RB::ImageProvider::_pending_image_providers;
  if (RB::ImageProvider::_pending_image_providers)
  {
    v2 = *(_QWORD **)RB::ImageProvider::_pending_image_providers;
    v3 = *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8);
    v10 = *(_QWORD **)RB::ImageProvider::_pending_image_providers;
    *(_QWORD *)RB::ImageProvider::_pending_image_providers = 0;
    v11 = v3;
    *(_QWORD *)(v1 + 8) = 0;
    *(_QWORD *)(v1 + 16) = 0;
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    if (v3)
    {
      for (i = 0; i != v3; ++i)
        RB::ImageProvider::wait_phase(v2[i], 2);
      v5 = 0;
      do
      {
        v6 = (unsigned int *)v2[v5];
        if (v6)
        {
          v7 = v6 + 2;
          do
          {
            v8 = __ldxr(v7);
            v9 = v8 - 1;
          }
          while (__stlxr(v9, v7));
          if (!v9)
          {
            __dmb(9u);
            (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
          }
        }
        ++v5;
      }
      while (v5 < v11);
      v2 = v10;
    }
    if (v2)
      free(v2);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  }
}

void sub_209B49450(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RB::vector<RB::refcounted_ptr<RB::ImageProvider>,0ul,unsigned long>::~vector((uint64_t)va);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::wait_phase(uint64_t a1, int a2)
{
  std::unique_lock<std::mutex> v4;

  v4.__m_ = (std::unique_lock<std::mutex>::mutex_type *)(a1 + 104);
  v4.__owns_ = 1;
  std::mutex::lock((std::mutex *)(a1 + 104));
  RB::ImageProvider::start_rendering_locked((RB::ImageProvider *)a1);
  if (*(_DWORD *)(a1 + 216) >= a2)
    goto LABEL_4;
  do
    std::condition_variable::wait((std::condition_variable *)(a1 + 168), &v4);
  while (*(_DWORD *)(a1 + 216) < a2);
  if (v4.__owns_)
LABEL_4:
    std::mutex::unlock(v4.__m_);
}

void sub_209B494EC(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::refcounted_ptr<RB::ImageProvider>,0ul,unsigned long>::~vector(uint64_t a1)
{
  _QWORD *v2;
  unint64_t v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;

  v2 = *(_QWORD **)a1;
  if (*(_QWORD *)(a1 + 8))
  {
    v3 = 0;
    do
    {
      v4 = (unsigned int *)v2[v3];
      if (v4)
      {
        v5 = v4 + 2;
        do
        {
          v6 = __ldxr(v5);
          v7 = v6 - 1;
        }
        while (__stlxr(v7, v5));
        if (!v7)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 8))(v4);
        }
      }
      ++v3;
    }
    while (v3 < *(_QWORD *)(a1 + 8));
    v2 = *(_QWORD **)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

uint64_t RB::ImageProvider::ImageProvider(uint64_t a1, id a2, void *a3, uint64_t a4, char a5, char a6, unsigned __int8 a7, int a8, double a9, float a10, float a11, float a12, float a13, float a14)
{
  __int16 v27;
  __int16 v28;
  char v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int v34;
  unsigned int v35;
  _BOOL4 v36;
  unint64_t v37;
  int v38;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_24C228CD8;
  *(_QWORD *)(a1 + 16) = a2;
  *(_QWORD *)(a1 + 24) = a3;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  *(double *)(a1 + 56) = a9;
  *(float *)(a1 + 64) = a10;
  *(float *)(a1 + 68) = a11;
  *(float *)(a1 + 72) = a12;
  *(float *)(a1 + 76) = a13;
  *(float *)(a1 + 80) = a14;
  *(_QWORD *)(a1 + 88) = a4;
  *(_BYTE *)(a1 + 96) = a5;
  *(_BYTE *)(a1 + 97) = a6;
  if (a8)
    v27 = 256;
  else
    v27 = 0;
  v28 = v27 & 0xFF00 | a7 | *(_WORD *)(a1 + 98) & 0xFC00;
  *(_WORD *)(a1 + 98) = v28;
  *(_QWORD *)(a1 + 104) = 850045863;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_QWORD *)(a1 + 160) = 0;
  *(_QWORD *)(a1 + 168) = 1018212795;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 204) = 0u;
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0;
  *(_QWORD *)(a1 + 224) = 0;
  if (a4 <= 80)
  {
    switch(a4)
    {
      case 'F':
        goto LABEL_12;
      case 'G':
LABEL_15:
        v30 = 71;
LABEL_16:
        *(_QWORD *)(a1 + 88) = v30;
        v31 = 4;
        if (a2)
          return a1;
        goto LABEL_20;
      case 'P':
LABEL_12:
        v30 = 70;
        goto LABEL_16;
    }
LABEL_18:
    *(_QWORD *)(a1 + 88) = 115;
    goto LABEL_19;
  }
  v29 = a4 - 7;
  if ((unint64_t)(a4 - 2147483655) > 5)
  {
    if (a4 == 81)
      goto LABEL_15;
    goto LABEL_18;
  }
  if (((1 << v29) & 5) != 0)
  {
    v30 = 2147483657;
    goto LABEL_16;
  }
  if (((1 << v29) & 0xA) != 0)
  {
    v30 = 2147483658;
    goto LABEL_16;
  }
LABEL_19:
  *(_WORD *)(a1 + 98) = v28 | 0x200;
  v31 = 8;
  if (a2)
    return a1;
LABEL_20:
  v32 = v31 * (uint64_t)SLODWORD(a9);
  v33 = v32 << 31 >> 31;
  *(_DWORD *)(a1 + 244) = v32;
  if (v33 != v32 || v33 < 0)
    goto LABEL_31;
  v34 = HIDWORD(a9);
  v35 = (v32 & 0xFFFFFFC0) + 64;
  v36 = a9 < 0.0;
  if (a9 < 0.0)
    v34 = -HIDWORD(a9);
  v37 = v34 * (unint64_t)v35;
  v38 = a9 >= 0.0 ? v37 : -(int)v37;
  if (!(_DWORD)v37)
    v36 = 0;
  *(_DWORD *)(a1 + 240) = v38;
  *(_DWORD *)(a1 + 244) = v35;
  if ((v37 & 0xFFFFFFFF00000000) != 0 || v36)
LABEL_31:
    *(_QWORD *)(a1 + 240) = 0;
  return a1;
}

void sub_209B497D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void RB::ImageProvider::~ImageProvider(RB::ImageProvider *this)
{
  os_unfair_lock_s *v2;
  void *v3;
  const void *v4;

  *(_QWORD *)this = off_24C228CD8;
  if (*((_QWORD *)this + 28))
  {
    v2 = (os_unfair_lock_s *)RB::SurfacePool::shared(this);
    RB::SurfacePool::dealloc(v2, *((RB::Surface **)this + 28), 0);
  }
  v3 = (void *)*((_QWORD *)this + 29);
  if (v3)
    munmap(v3, *((unsigned int *)this + 60));
  std::condition_variable::~condition_variable((std::condition_variable *)((char *)this + 168));
  std::mutex::~mutex((std::mutex *)((char *)this + 104));
  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
    CFRelease(v4);

}

{
  RB::ImageProvider::~ImageProvider(this);
  JUMPOUT(0x20BD16544);
}

void sub_209B49878(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v3;

  std::condition_variable::~condition_variable((std::condition_variable *)(v1 + 168));
  std::mutex::~mutex((std::mutex *)(v1 + 104));
  v3 = *(const void **)(v1 + 48);
  if (v3)
    CFRelease(v3);

  _Unwind_Resume(a1);
}

void RB::ImageProvider::make_cgimage(RB::ImageProvider *this@<X0>, _QWORD *a2@<X8>)
{
  const void *v4;
  void *v5;
  void *v6;
  _QWORD *v7;
  char *v8;
  MTLPixelFormat v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  const void *v13;
  unsigned int *v14;
  unsigned int v15;
  CGDataProviderRef v16;
  MTLPixelFormat v17;
  CGDataProvider *v18;
  __int16 v19;
  size_t v20;
  char *v21;
  unsigned int *v22;
  char *v23;
  size_t v24;
  int v25;
  int v26;
  CGBitmapInfo v27;
  uint64_t v28;
  CGDataProviderDirectCallbacks callbacks;

  v4 = (const void *)*((_QWORD *)this + 6);
  if (v4)
  {
    *a2 = CFRetain(v4);
  }
  else if (*((_QWORD *)this + 2))
  {
    *(_OWORD *)&callbacks.version = xmmword_24C22B060;
    *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)&off_24C22B070;
    v5 = (void *)objc_opt_new();
    v6 = v5;
    v7 = (_QWORD *)MEMORY[0x24BDBF3B0];
    if ((*((_WORD *)this + 49) & 0x100) != 0)
      v7 = (_QWORD *)MEMORY[0x24BDBF3A8];
    objc_msgSend(v5, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C8], *v7);
    v8 = (char *)*((unsigned __int8 *)this + 96);
    v10 = RB::pixel_format_traits(*((_QWORD *)this + 11), v9);
    RB::cg_color_space(v8, ((*v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32)) & 0xA00000000) != 0);
    v11 = (unsigned int *)((char *)this + 8);
    do
      v12 = __ldxr(v11);
    while (__stxr(v12 + 1, v11));
    v13 = (const void *)CGImageProviderCreate();
    if (v13)
    {
      *a2 = CGImageCreateWithImageProvider();
      CFRelease(v13);
    }
    else
    {
      ((void (*)(RB::ImageProvider *))callbacks.getBytesAtPosition)(this);
      *a2 = 0;
    }

  }
  else
  {
    *(_OWORD *)&callbacks.version = xmmword_24C22B080;
    *(_OWORD *)&callbacks.releaseBytePointer = *(_OWORD *)algn_24C22B090;
    callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)RB::ImageProvider::make_cgimage(void)::$_4::__invoke;
    v14 = (unsigned int *)((char *)this + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v16 = CGDataProviderCreateDirect(this, *((unsigned int *)this + 60), &callbacks);
    if (v16)
    {
      v18 = v16;
      v19 = *((_WORD *)this + 49);
      v28 = *((_QWORD *)this + 7);
      v20 = *((unsigned int *)this + 61);
      v21 = (char *)*((unsigned __int8 *)this + 96);
      v22 = RB::pixel_format_traits(*((_QWORD *)this + 11), v17);
      v23 = RB::cg_color_space(v21, ((*v22 | ((unint64_t)*((unsigned __int16 *)v22 + 2) << 32)) & 0xA00000000) != 0);
      if ((v19 & 0x200) != 0)
        v24 = 16;
      else
        v24 = 8;
      if ((*((_WORD *)this + 49) & 0x100) != 0)
        v25 = 4357;
      else
        v25 = 4353;
      if ((*((_WORD *)this + 49) & 0x100) != 0)
        v26 = 6;
      else
        v26 = 2;
      if ((*((_WORD *)this + 49) & 0x200) != 0)
        v27 = v25;
      else
        v27 = v26;
      *a2 = CGImageCreate((int)v28, SHIDWORD(v28), v24, 4 * v24, v20, (CGColorSpaceRef)v23, v27, v18, 0, 1, kCGRenderingIntentDefault);
      CFRelease(v18);
    }
    else
    {
      ((void (*)(uint64_t))callbacks.releaseInfo)((uint64_t)this);
      *a2 = 0;
    }
  }
}

void sub_209B49B58(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_0::__invoke(uint64_t a1, uint64_t a2, void *a3, uint64_t a4)
{
  return RB::ImageProvider::copy_image_block_set(a1, a2, (uint64_t)a3, a4, a3);
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_2::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_3::__invoke(uint64_t a1)
{
  RB::ImageProvider::wait_phase(a1, 3);
  return *(_QWORD *)(a1 + 232);
}

uint64_t RB::ImageProvider::make_cgimage(void)::$_4::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void RB::ImageProvider::start_rendering(RB::ImageProvider *this)
{
  std::mutex *v2;

  v2 = (std::mutex *)((char *)this + 104);
  std::mutex::lock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::start_rendering_locked(this);
  std::mutex::unlock(v2);
}

void sub_209B49C5C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::start_rendering_locked(RB::ImageProvider *this)
{
  _QWORD *v2;
  CFTypeRef *v3;
  CGImage *v4;
  void *v5;
  NSObject *v6;
  unsigned __int8 v7;
  unsigned int *v8;
  unsigned int v9;
  NSObject *v10;

  if (*((int *)this + 54) <= 0)
  {
    *((_DWORD *)this + 54) = 1;
    std::condition_variable::notify_all((std::condition_variable *)((char *)this + 168));
    if (!*((_BYTE *)this + 98)
      || (vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_f32(*(float32x4_t *)((char *)this + 68), (float32x4_t)RBColorClear)), 0xFuLL))) & 1) != 0)
    {
      v2 = (_QWORD *)objc_msgSend(*((id *)this + 3), "_rb_contents");
      if (v2)
      {
        v3 = (CFTypeRef *)((char *)this + 48);
        RB::DisplayList::Contents::get_cgimage(v2, (const void **)this + 6, *((double *)this + 7));
        v4 = (CGImage *)*((_QWORD *)this + 6);
        if (v4)
        {
          if (CGImageGetWidth(v4) == (int)*((_QWORD *)this + 7)
            && CGImageGetHeight(*((CGImageRef *)this + 6)) == *((_DWORD *)this + 15))
          {
            RB::ImageProvider::set_phase((uint64_t)this, 3);
            return;
          }
          if (*v3)
            CFRelease(*v3);
          *v3 = 0;
        }
      }
    }
    RB::ImageProvider::add_to_pending(this);
    v5 = (void *)*((_QWORD *)this + 2);
    if (v5)
    {
      v6 = objc_msgSend(v5, "queue");
    }
    else
    {
      if ((v7 & 1) == 0
      {
        v10 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
      }
    }
    v8 = (unsigned int *)((char *)this + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    dispatch_async_f(v6, this, (dispatch_function_t)RB::ImageProvider::start_rendering_locked(void)::$_0::__invoke);
  }
}

BOOL RB::ImageProvider::set_phase(uint64_t a1, int a2)
{
  int v3;
  NSObject *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _QWORD block[4];
  uint64_t v17;

  v3 = *(_DWORD *)(a1 + 216);
  if (v3 < a2)
  {
    *(_DWORD *)(a1 + 216) = a2;
    std::condition_variable::notify_all((std::condition_variable *)(a1 + 168));
    if (a2 == 3)
    {
      if (*(_QWORD *)(a1 + 32))
      {
        v5 = *(NSObject **)(a1 + 40);
        if (v5)
        {
          v6 = (unsigned int *)(a1 + 8);
          do
            v7 = __ldxr(v6);
          while (__stxr(v7 + 1, v6));
          block[0] = MEMORY[0x24BDAC760];
          block[1] = 3321888768;
          block[2] = ___ZN2RB13ImageProvider9set_phaseENS0_5PhaseE_block_invoke;
          block[3] = &__block_descriptor_40_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE_e5_v8__0l;
          do
            v8 = __ldxr(v6);
          while (__stxr(v8 + 1, v6));
          v17 = a1;
          dispatch_async(v5, block);
          v9 = v17;
          if (v17)
          {
            v10 = (unsigned int *)(v17 + 8);
            do
            {
              v11 = __ldxr(v10);
              v12 = v11 - 1;
            }
            while (__stlxr(v12, v10));
            if (!v12)
            {
              __dmb(9u);
              (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
            }
          }
          do
          {
            v13 = __ldxr(v6);
            v14 = v13 - 1;
          }
          while (__stlxr(v14, v6));
          if (!v14)
          {
            __dmb(9u);
            (*(void (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
          }
        }
      }
    }
  }
  return v3 < a2;
}

void RB::ImageProvider::add_to_pending(RB::ImageProvider *this)
{
  _QWORD *v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  unint64_t v6;

  if (*((_QWORD *)this + 2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    v2 = (_QWORD *)RB::ImageProvider::_pending_image_providers;
    if (!RB::ImageProvider::_pending_image_providers)
    {
      v2 = (_QWORD *)operator new();
      *v2 = 0;
      v2[1] = 0;
      v2[2] = 0;
      RB::ImageProvider::_pending_image_providers = (uint64_t)v2;
    }
    v3 = (unsigned int *)((char *)this + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
    v5 = v2[1];
    v6 = v5 + 1;
    if (v2[2] < (unint64_t)(v5 + 1))
    {
      RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v2, v6);
      v5 = v2[1];
      v6 = v5 + 1;
    }
    *(_QWORD *)(*v2 + 8 * v5) = this;
    v2[1] = v6;
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  }
}

void sub_209B49FD8(_Unwind_Exception *a1)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v4;
  unsigned int v5;

  do
  {
    v4 = __ldxr(v2);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v2));
  if (!v5)
    RB::ImageProvider::add_to_pending(v1);
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
  _Unwind_Resume(a1);
}

void RB::ImageProvider::render_device(RB::ImageProvider *this)
{
  RB::Device *v2;
  unint64_t v3;
  double v4;
  float v5;
  char v6;
  char v7;
  MTLPixelFormat v8;
  unsigned int *v9;
  uint64_t v10;
  const RB::DisplayList::Contents *v11;
  float32x4_t v12;
  id v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  RB::ImageProvider *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  int v23;
  _QWORD v24[4];
  RB::ImageProvider *v25;
  _QWORD v26[5];
  __int128 v27;
  int32x2_t v28;
  char v29;
  _QWORD v30[3];
  id v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 28))
  {
    v2 = (RB::Device *)-[RBDecodedFontMetadata fontUID](*((_QWORD *)this + 2));
    RB::RenderFrame::RenderFrame((RB::RenderFrame *)v30, v2, 0, 1u);
    v3 = *((_QWORD *)this + 11);
    v4 = *((double *)this + 7);
    v5 = *((float *)this + 16);
    v6 = *((_BYTE *)this + 96);
    v7 = *((_BYTE *)this + 97);
    v9 = RB::pixel_format_traits(v3, v8);
    RB::RenderParams::RenderParams((uint64_t)&v27, (uint64_t)v30, v3, v6, v7, (v9[1] & 2) != 0, v4, v5);
    v29 |= 4u;
    v10 = MEMORY[0x24BDAC760];
    v26[0] = MEMORY[0x24BDAC760];
    v26[1] = 3221225472;
    v26[2] = ___ZN2RB13ImageProvider13render_deviceEv_block_invoke;
    v26[3] = &__block_descriptor_40_e19____MTLTexture__8__0l;
    v26[4] = this;
    v11 = (const RB::DisplayList::Contents *)objc_msgSend(*((id *)this + 3), "_rb_contents");
    if (v11)
    {
      v12.i64[0] = *(_QWORD *)((char *)this + 68);
      v12.i32[2] = *((_DWORD *)this + 19);
      v12.i32[3] = 1.0;
      RB::DisplayList::render(v11, &v27, (uint64_t)v26, *((char *)this + 98), 0, 0, v28, (__n128)vmulq_n_f32(v12, *((float *)this + 20)));
      if ((*(_BYTE *)(v30[0] + 292) & 2) != 0)
      {
        v13 = (id)*((_QWORD *)this + 3);
        if (v31 != v13)
        {

          v31 = v13;
        }
      }
    }
    v14 = (unsigned int *)((char *)this + 8);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
    v24[0] = v10;
    v24[1] = 3321888768;
    v24[2] = ___ZN2RB13ImageProvider13render_deviceEv_block_invoke_2;
    v24[3] = &__block_descriptor_40_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE_e5_v8__0l;
    do
      v16 = __ldxr(v14);
    while (__stxr(v16 + 1, v14));
    v25 = this;
    RB::RenderFrame::add_continuation((uint64_t)v30, 0, v24);
    v17 = v25;
    if (v25)
    {
      v18 = (unsigned int *)((char *)v25 + 8);
      do
      {
        v19 = __ldxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v20, v18));
      if (!v20)
      {
        __dmb(9u);
        (*(void (**)(RB::ImageProvider *))(*(_QWORD *)v17 + 8))(v17);
      }
    }
    do
    {
      v21 = __ldxr(v14);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v14));
    if (!v22)
    {
      __dmb(9u);
      (*(void (**)(RB::ImageProvider *))(*(_QWORD *)this + 8))(this);
    }
    RB::RenderFrame::~RenderFrame((RB::RenderFrame *)v30);
  }
  RBXMLRecorderMarkFrame(*((const void **)this + 2), *((void **)this + 3), *((unsigned __int8 *)this + 96), (double)(int)*((_QWORD *)this + 7), (double)(int)HIDWORD(*((_QWORD *)this + 7)));
  std::mutex::lock((std::mutex *)((char *)this + 104));
  if (*((_QWORD *)this + 28))
    v23 = 2;
  else
    v23 = 3;
  RB::ImageProvider::set_phase((uint64_t)this, v23);
  std::mutex::unlock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::remove_from_pending(this);
}

void sub_209B4A2AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, ...)
{
  va_list va;

  va_start(va, a16);
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)va);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB13ImageProvider13render_deviceEv_block_invoke(uint64_t a1, MTLPixelFormat a2)
{
  return RB::Surface::texture(*(RB::Surface **)(*(_QWORD *)(a1 + 32) + 224), a2);
}

void ___ZN2RB13ImageProvider13render_deviceEv_block_invoke_2(uint64_t a1)
{
  std::mutex *v2;

  v2 = (std::mutex *)(*(_QWORD *)(a1 + 32) + 104);
  std::mutex::lock(v2);
  RB::ImageProvider::set_phase(*(_QWORD *)(a1 + 32), 3);
  std::mutex::unlock(v2);
}

void sub_209B4A36C(_Unwind_Exception *a1)
{
  std::mutex *v1;

  std::mutex::unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t __copy_helper_block_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;

  v2 = *(_QWORD *)(a2 + 32);
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_QWORD *)(result + 32) = v2;
  return result;
}

uint64_t __destroy_helper_block_e8_32c46_ZTSN2RB14refcounted_ptrINS_13ImageProviderEEE(uint64_t a1)
{
  uint64_t result;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    v2 = (unsigned int *)(result + 8);
    do
    {
      v3 = __ldxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      __dmb(9u);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  return result;
}

void RB::ImageProvider::remove_from_pending(RB::ImageProvider *this)
{
  uint64_t v2;
  uint64_t v3;
  RB::ImageProvider **v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;

  if (*((_QWORD *)this + 2))
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    if (RB::ImageProvider::_pending_image_providers
      && (v2 = *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8)) != 0)
    {
      v3 = *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8);
      v4 = *(RB::ImageProvider ***)RB::ImageProvider::_pending_image_providers;
      while (*v4 != this)
      {
        ++v4;
        if (!--v3)
          goto LABEL_7;
      }
      v5 = *(_QWORD *)RB::ImageProvider::_pending_image_providers + 8 * v2;
      *v4 = *(RB::ImageProvider **)(v5 - 8);
      *(_QWORD *)(v5 - 8) = this;
      v6 = *(_QWORD *)RB::ImageProvider::_pending_image_providers
         + 8 * *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8);
      v7 = *(unsigned int **)(v6 - 8);
      *(_QWORD *)(v6 - 8) = 0;
      v8 = *(_QWORD *)RB::ImageProvider::_pending_image_providers;
      v9 = *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8) - 1;
      *(_QWORD *)(RB::ImageProvider::_pending_image_providers + 8) = v9;
      v10 = *(unsigned int **)(v8 + 8 * v9);
      if (v10)
      {
        v11 = v10 + 2;
        do
        {
          v12 = __ldxr(v11);
          v13 = v12 - 1;
        }
        while (__stlxr(v13, v11));
        if (!v13)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v10 + 8))(v10);
        }
      }
      os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
      if (v7)
      {
        v14 = v7 + 2;
        do
        {
          v15 = __ldxr(v14);
          v16 = v15 - 1;
        }
        while (__stlxr(v16, v14));
        if (!v16)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
        }
      }
    }
    else
    {
LABEL_7:
      os_unfair_lock_unlock((os_unfair_lock_t)&RB::ImageProvider::_pending_image_providers_lock);
    }
  }
}

void RB::ImageProvider::render_bitmap(RB::ImageProvider *this)
{
  void *v2;
  MTLPixelFormat v3;
  void *v4;
  uint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  char *v10;
  unsigned int *v11;
  char *v12;
  int v13;
  int v14;
  uint32_t v15;
  CGContext *v16;
  CGContext *v17;
  CGFloat v18;
  const float *v19;
  double v20;
  int v25;
  RB::DisplayList *v44;
  void *v45;
  _WORD v46[5];
  CGAffineTransform transform;
  CGContextRef c[14];
  __int16 v49;
  __int16 v50;
  __int16 v51;
  __int16 v52;
  unsigned __int8 v53;
  char v54;
  uint64_t v55;

  v55 = *MEMORY[0x24BDAC8D0];
  v2 = mmap(0, *((unsigned int *)this + 60), 3, 4098, -1, 0);
  if (v2 != (void *)-1)
  {
    v4 = v2;
    *((_QWORD *)this + 29) = v2;
    v5 = *((_QWORD *)this + 7);
    v6 = (int)v5;
    v7 = (*((_WORD *)this + 49) & 0x200) != 0 ? 16 : 8;
    v8 = SHIDWORD(v5);
    v9 = *((unsigned int *)this + 61);
    v10 = (char *)*((unsigned __int8 *)this + 96);
    v11 = RB::pixel_format_traits(*((_QWORD *)this + 11), v3);
    v12 = RB::cg_color_space(v10, ((*v11 | ((unint64_t)*((unsigned __int16 *)v11 + 2) << 32)) & 0xA00000000) != 0);
    v13 = (*((_WORD *)this + 49) & 0x100) != 0 ? 4357 : 4353;
    v14 = (*((_WORD *)this + 49) & 0x100) != 0 ? 6 : 2;
    v15 = (*((_WORD *)this + 49) & 0x200) != 0 ? v13 : v14;
    v16 = CGBitmapContextCreate(v4, v6, v8, v7, v9, (CGColorSpaceRef)v12, v15);
    if (v16)
    {
      v17 = v16;
      v18 = (double)*((int *)this + 15);
      transform.b = 0.0;
      transform.c = 0.0;
      transform.a = 1.0;
      *(_OWORD *)&transform.d = xmmword_209BD6C00;
      transform.ty = v18;
      CGContextConcatCTM(v16, &transform);
      v19 = (const float *)((char *)this + 64);
      *(float32x2_t *)&v20 = vld1_dup_f32(v19);
      RB::CGContext::CGContext(c, v17, *((unsigned __int8 *)this + 96), v20);
      if (*((_BYTE *)this + 98) == 2)
      {
        _S3 = *((_DWORD *)this + 17);
        _S2 = *((_DWORD *)this + 18);
        _S1 = *((_DWORD *)this + 19);
        _D0.i32[0] = *((_DWORD *)this + 20);
        v25 = *((unsigned __int8 *)this + 97);
        __asm
        {
          FCVT            H0, S0
          FCVT            H1, S1
          FCVT            H2, S2
          FCVT            H3, S3
        }
        v46[0] = _H3;
        v46[1] = _H2;
        v46[2] = _H1;
        v46[3] = _D0.i16[0];
        v46[4] = v25 | 0x100;
        if (v54 && v53 != v25)
          goto LABEL_22;
        _H4 = v49;
        __asm
        {
          FCVT            S3, H3
          FCVT            S4, H4
        }
        if (_S4 != _S3)
          goto LABEL_22;
        _H3 = v50;
        __asm
        {
          FCVT            S2, H2
          FCVT            S3, H3
        }
        if (_S3 != _S2)
          goto LABEL_22;
        _H2 = v51;
        __asm
        {
          FCVT            S1, H1
          FCVT            S2, H2
        }
        if (_S2 != _S1)
          goto LABEL_22;
        _H1 = v52;
        __asm
        {
          FCVT            S0, H0
          FCVT            S1, H1
        }
        if (_S1 != *(float *)_D0.i32)
LABEL_22:
          RB::CGContext::set_fill_color_slow((RB::CGContext *)c, (const RB::Fill::Color *)v46, _D0);
        CGContextFillRect(c[0], *MEMORY[0x24BDBF028]);
      }
      v44 = (RB::DisplayList *)objc_msgSend(*((id *)this + 3), "_rb_contents");
      if (v44)
        RB::DisplayList::render(v44, (const RB::DisplayList::Contents *)c, 0, v45);
      mprotect(v4, *((unsigned int *)this + 60), 1);
      RB::CGContext::~CGContext((RB::CGContext *)c);
      CFRelease(v17);
    }
  }
  std::mutex::lock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::set_phase((uint64_t)this, 3);
  std::mutex::unlock((std::mutex *)((char *)this + 104));
  RB::ImageProvider::remove_from_pending(this);
}

void sub_209B4A79C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  const void *v9;
  va_list va;

  va_start(va, a9);
  RB::CGContext::~CGContext((RB::CGContext *)va);
  CFRelease(v9);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB13ImageProvider9set_phaseENS0_5PhaseE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 32) + 16))();
}

uint64_t RB::ImageProvider::copy_image_block_set(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, void *a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const void *v13;
  uint64_t v14;
  void *v15;
  char *v16;
  MTLPixelFormat v17;
  unsigned int *v18;
  uint64_t v19;
  __IOSurface *v20;
  kern_return_t v21;
  uint64_t result;
  void *BaseAddress;
  unsigned int *v24;
  unsigned int v25;
  uint64_t v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v8 = objc_msgSend(a5, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
    if (v8)
    {
      v9 = v8;
      v10 = *(_QWORD *)v28;
      v11 = *MEMORY[0x24BDBF380];
      v12 = *MEMORY[0x24BDBF398];
      v13 = (const void *)*MEMORY[0x24BDBF370];
      v26 = a2;
LABEL_4:
      v14 = 0;
      while (1)
      {
        if (*(_QWORD *)v28 != v10)
          objc_enumerationMutation(a5);
        v15 = *(void **)(*((_QWORD *)&v27 + 1) + 8 * v14);
        if ((objc_msgSend(v15, "isEqualToString:", v11, v26) & 1) != 0)
          return 0;
        if ((objc_msgSend(v15, "isEqualToString:", v12) & 1) != 0)
          return 0;
        if ((objc_msgSend(v15, "isEqualToString:", v12) & 1) != 0)
          return 0;
        if (objc_msgSend(v15, "isEqualToString:", v13))
        {
          CFDictionaryGetValue((CFDictionaryRef)a5, v13);
          v16 = (char *)*(unsigned __int8 *)(a1 + 96);
          v18 = RB::pixel_format_traits(*(_QWORD *)(a1 + 88), v17);
          RB::cg_color_space(v16, ((*v18 | ((unint64_t)*((unsigned __int16 *)v18 + 2) << 32)) & 0xA00000000) != 0);
          if (!CGColorSpaceEqualToColorSpace())
            return 0;
        }
        if (v9 == ++v14)
        {
          v9 = objc_msgSend(a5, "countByEnumeratingWithState:objects:count:", &v27, v31, 16);
          if (v9)
            goto LABEL_4;
          break;
        }
      }
    }
  }
  RB::ImageProvider::wait_phase(a1, 3);
  v19 = *(_QWORD *)(a1 + 224);
  if (v19)
  {
    v20 = *(__IOSurface **)(v19 + 48);
    v21 = IOSurfaceLock(v20, 1u, 0);
    result = 0;
    if (v21)
      return result;
    BaseAddress = IOSurfaceGetBaseAddress(v20);
    IOSurfaceGetBytesPerRow(v20);
    if (!BaseAddress)
      return 0;
  }
  else if (!*(_QWORD *)(a1 + 232))
  {
    return 0;
  }
  v24 = (unsigned int *)(a1 + 8);
  do
    v25 = __ldxr(v24);
  while (__stxr(v25 + 1, v24));
  if (CGImageBlockCreate())
  {
    result = CGImageBlockSetCreate();
    if (result)
      return result;
    CGImageBlockRelease();
  }
  else
  {
    ((void (*)(uint64_t, _QWORD))RB::ImageProvider::copy_image_block_set(CGImageProvider *,CGRect const&,CGSize const&,__CFDictionary const*)::$_0::__invoke)(a1, 0);
  }
  return 0;
}

uint64_t RB::ImageProvider::copy_image_block_set(CGImageProvider *,CGRect const&,CGSize const&,__CFDictionary const*)::$_0::__invoke(uint64_t result)
{
  unsigned int *v1;
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v1 = (unsigned int *)result;
  v2 = *(_QWORD *)(result + 224);
  if (v2)
    result = IOSurfaceUnlock(*(IOSurfaceRef *)(v2 + 48), 1u, 0);
  v3 = v1 + 2;
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
  {
    __dmb(9u);
    return (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
  }
  return result;
}

uint64_t RB::ImageProvider::copy_iosurface(RB::ImageProvider *this, const __CFDictionary *a2)
{
  uint64_t v3;
  uint64_t v4;

  RB::ImageProvider::wait_phase((uint64_t)this, 2);
  v3 = *((_QWORD *)this + 28);
  if (!v3)
    return 0;
  v4 = *(_QWORD *)(v3 + 48);
  if (v4)
    CFRetain(*(CFTypeRef *)(v3 + 48));
  return v4;
}

uint64_t RB::Refcount<RB::ImageProvider,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::ImageProvider,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::ImageProvider::start_rendering_locked(void)::$_0::__invoke(RB::ImageProvider *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (*((_QWORD *)this + 2))
  {
    v2 = (os_unfair_lock_s *)RB::SurfacePool::shared(this);
    v3 = -[RBDecodedFontMetadata fontUID](*((_QWORD *)this + 2));
    *((_QWORD *)this + 28) = RB::SurfacePool::alloc(v2, v3, *((_QWORD *)this + 11), *((unsigned __int8 *)this + 96), 2, 0, *((double *)this + 7), 0);
    RB::ImageProvider::render_device(this);
  }
  else
  {
    RB::ImageProvider::render_bitmap(this);
  }
  v4 = (unsigned int *)((char *)this + 8);
  do
  {
    v5 = __ldxr(v4);
    v6 = v5 - 1;
  }
  while (__stlxr(v6, v4));
  if (!v6)
  {
    __dmb(9u);
    (*(void (**)(RB::ImageProvider *))(*(_QWORD *)this + 8))(this);
  }
}

void sub_209B4AC50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v3 = (unsigned int *)(v1 + 8);
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
    RB::ImageProvider::add_to_pending(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Path::FlattenedConsumer::push_back(uint64_t a1, __n128 a2, float32x2_t a3, float32x2_t a4)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = vadd_f32(a3, a3);
  v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  return (*(uint64_t (**)(uint64_t, __n128, double, double))(*(_QWORD *)a1 + 40))(a1, a2, COERCE_DOUBLE(vmul_f32(vadd_f32(v5, (float32x2_t)a2.n128_u64[0]), v6)), COERCE_DOUBLE(vmul_f32(vadd_f32(v5, a4), v6)));
}

uint64_t RB::Path::Flattener::push_cropped(uint64_t a1, double a2, float32x2_t a3)
{
  uint32x2_t v6;
  uint64_t result;

  if (*(_BYTE *)(a1 + 88))
  {
    v6 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a1 + 24), vmaxnm_f32(*(float32x2_t *)(a1 + 96), a3)), (int8x8_t)vcgt_f32(vminnm_f32(*(float32x2_t *)(a1 + 96), a3), *(float32x2_t *)(a1 + 32)));
    if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
    {
      if ((*(unsigned int (**)(_QWORD))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8)))
        a2 = *(double *)(a1 + 96);
    }
  }
  result = (*(uint64_t (**)(_QWORD, double, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), a2, *(double *)&a3);
  *(_BYTE *)(a1 + 88) = 1;
  *(double *)(a1 + 96) = a2;
  return result;
}

void RB::Path::Flattener::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3, double a4, int32x4_t a5, int8x16_t a6)
{
  double v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  uint32x2_t v12;
  double v13;
  float32x2_t v14;
  uint32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float v18;
  uint32x2_t v21;
  uint64_t v22;
  float32x2_t v23;

  v7 = *(double *)(a1 + 80);
  v8 = vcvt_f32_f64(a2);
  v9 = vcvt_f32_f64(a3);
  *(float32x2_t *)(a1 + 80) = v9;
  v10 = vminnm_f32(vminnm_f32(*(float32x2_t *)&v7, v8), v9);
  v11 = vmaxnm_f32(vmaxnm_f32(*(float32x2_t *)&v7, v8), v9);
  v12 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(a1 + 24), v11), (int8x8_t)vcgt_f32(v10, *(float32x2_t *)(a1 + 32)));
  if ((vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)
  {
    v23 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v11);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), v10);
    *(float32x2_t *)(a1 + 64) = v23;
    RB::Path::Flattener::push_cropped(a1, v7, v9);
  }
  else
  {
    v13 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v7, v9));
    v14 = vmaxnm_f32(*(float32x2_t *)&v7, v9);
    *(int32x2_t *)a5.i8 = vcge_f32(v14, v8);
    v15 = (uint32x2_t)vand_s8(*(int8x8_t *)a5.i8, (int8x8_t)vcge_f32(v8, *(float32x2_t *)&v13));
    if ((vpmin_u32(v15, v15).u32[0] & 0x80000000) == 0)
      v13 = RB::Path::quadratic_bounds_slow(*(float32x2_t *)&v7, v8, v9, a5, a6);
    v16 = *(float32x2_t *)(a1 + 64);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)&v13);
    *(float32x2_t *)(a1 + 64) = vmaxnm_f32(v16, v14);
    v17 = vabs_f32(vadd_f32(vsub_f32(v9, vadd_f32(v8, v8)), *(float32x2_t *)&v7));
    v18 = ceilf(sqrtf(*(float *)(a1 + 20) * sqrtf(vaddv_f32(vmul_f32(v17, v17)))));
    if (v18 >= 0.0 && ((LODWORD(v18) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v18) == 0)
    {
      if (v18 >= 1.0)
      {
        if (v18 > 1024.0)
          v18 = 1024.0;
        v22 = (int)v18;
      }
      else
      {
        v21 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v7, v9);
        if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) != 0)
          return;
        v22 = 1;
      }
      (*(void (**)(_QWORD, uint64_t, double, double, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), v22, v7, *(double *)&v8, *(double *)&v9);
      *(_BYTE *)(a1 + 88) = 0;
    }
  }
}

RB::DisplayList::Transform::Term *RB::DisplayList::Transform::Term::Term(RB::DisplayList::Transform::Term *this, const Term *a2)
{
  int v4;
  _OWORD *v5;
  uint64_t v6;
  CFTypeRef v7;
  __int128 v8;

  v4 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  v5 = (_OWORD *)((char *)this + 8);
  switch(v4)
  {
    case 3:
      v7 = (CFTypeRef)*((_QWORD *)a2 + 1);
      if (v7)
        v7 = CFRetain(v7);
      *((_QWORD *)this + 1) = v7;
      *((_QWORD *)this + 2) = *((_QWORD *)a2 + 2);
      break;
    case 2:
      v8 = *(_OWORD *)((char *)a2 + 8);
      *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
      *v5 = v8;
      break;
    case 1:
      v6 = *((_QWORD *)a2 + 1);
      *((_WORD *)this + 8) = *((_WORD *)a2 + 8);
      *(_QWORD *)v5 = v6;
      break;
  }
  return this;
}

void RB::DisplayList::Transform::Term::~Term(RB::DisplayList::Transform::Term *this)
{
  const void *v1;

  if (*(_DWORD *)this == 3)
  {
    v1 = (const void *)*((_QWORD *)this + 1);
    if (v1)
      CFRelease(v1);
  }
}

void RB::DisplayList::Transform::clear(RB::DisplayList::Transform *this)
{
  RB::DisplayList::Transform *v2;
  uint64_t v3;
  CFTypeRef *v4;
  uint64_t v5;

  if (*((_QWORD *)this + 4))
    v2 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
  else
    v2 = this;
  v3 = *((unsigned int *)this + 10);
  if ((_DWORD)v3)
  {
    v4 = (CFTypeRef *)((char *)v2 + 8);
    v5 = 32 * v3;
    do
    {
      if (*((_DWORD *)v4 - 2) == 3 && *v4)
        CFRelease(*v4);
      v4 += 4;
      v5 -= 32;
    }
    while (v5);
  }
  *((_DWORD *)this + 10) = 0;
}

_DWORD *RB::DisplayList::Transform::add_color_to(_DWORD *this, const RB::Fill::Color *a2)
{
  _DWORD *v3;
  int v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;

  v3 = this;
  v4 = this[10];
  if (this[11] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    v4 = v3[10];
  }
  v5 = (_DWORD *)*((_QWORD *)v3 + 4);
  if (!v5)
    v5 = v3;
  v6 = &v5[8 * v4];
  *v6 = 1;
  v7 = *(_QWORD *)a2;
  *((_WORD *)v6 + 8) = *((_WORD *)a2 + 4);
  *((_QWORD *)v6 + 1) = v7;
  ++v3[10];
  return this;
}

_DWORD *RB::DisplayList::Transform::add_color_from_to(_DWORD *this, const RB::Fill::Color *a2, const RB::Fill::Color *a3)
{
  _DWORD *v5;
  int v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  uint64_t v10;

  v5 = this;
  v6 = this[10];
  if (this[11] < (v6 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v6 + 1);
    v6 = v5[10];
  }
  v7 = (_DWORD *)*((_QWORD *)v5 + 4);
  if (!v7)
    v7 = v5;
  v8 = &v7[8 * v6];
  *v8 = 2;
  v9 = *(_QWORD *)a2;
  *((_WORD *)v8 + 8) = *((_WORD *)a2 + 4);
  *((_QWORD *)v8 + 1) = v9;
  v10 = *(_QWORD *)a3;
  *((_WORD *)v8 + 13) = *((_WORD *)a3 + 4);
  *(_QWORD *)((char *)v8 + 18) = v10;
  ++v5[10];
  return this;
}

_DWORD *RB::DisplayList::Transform::add_font_mix_to(_DWORD *this, CFTypeRef cf, float a3, int a4)
{
  _DWORD *v7;
  int v8;
  _DWORD *v9;
  _DWORD *v10;

  v7 = this;
  v8 = this[10];
  if (this[11] < (v8 + 1))
  {
    this = RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v8 + 1);
    v8 = v7[10];
  }
  v9 = (_DWORD *)*((_QWORD *)v7 + 4);
  if (!v9)
    v9 = v7;
  v10 = &v9[8 * v8];
  *v10 = 3;
  *((_QWORD *)v10 + 1) = 0;
  *((_QWORD *)v10 + 2) = 0;
  if (cf)
  {
    this = CFRetain(cf);
    *((_QWORD *)v10 + 1) = this;
  }
  *((float *)v10 + 4) = a3;
  v10[5] = a4;
  ++v7[10];
  return this;
}

void RB::DisplayList::Transform::apply_to_color(RB::DisplayList::Transform *this, float16x4_t *a2, uint32x4_t _Q0)
{
  RB::DisplayList::Transform *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  unint64_t v10;
  float16x4_t v11;
  unsigned int v13;
  float32x4_t v21;
  char *v22;
  uint64_t v24;
  uint64_t v25;
  __int16 v26;
  float16x4_t v34;
  float32x4_t v35;

  if (*((_QWORD *)this + 4))
    v3 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
  else
    v3 = this;
  v4 = *((unsigned int *)this + 10);
  if ((_DWORD)v4)
  {
    v6 = 0;
    v7 = 32 * v4;
    do
    {
      v8 = *(_DWORD *)((char *)v3 + v6);
      if (v8 == 2)
      {
        v22 = (char *)v3 + v6;
        if (RB::Fill::Color::matches((float16x4_t *)((char *)v3 + v6 + 8), a2, *(uint16x4_t *)_Q0.i8))
        {
          _H0 = *((_WORD *)v22 + 7);
          v24 = *((unsigned __int16 *)v22 + 11);
          v25 = *(unsigned int *)(v22 + 18);
          v26 = *((_WORD *)v22 + 12);
          v13 = *((unsigned __int16 *)v22 + 13);
          _H1 = a2->i16[3];
          _H2 = v26;
          __asm
          {
            FCVT            S2, H2
            FCVT            S1, H1
          }
          _S1 = _S1 * _S2;
          __asm
          {
            FCVT            H1, S1
            FCVT            S0, H0
          }
          if (_S0 == -32768.0)
            v26 = _H1;
          v34.i32[0] = *(_DWORD *)(v22 + 18);
          v34.i16[2] = *((_WORD *)v22 + 11);
          v34.i16[3] = v26;
          v35.i64[0] = 0xC7000000C7000000;
          v35.i64[1] = 0xC7000000C7000000;
          _Q0 = (uint32x4_t)vceqq_f32(vcvtq_f32_f16(v34), v35);
          _Q0.i32[0] = vmaxvq_u32(_Q0);
          if (_Q0.i32[0] < 0)
          {
LABEL_16:
            if (v13 >= 0x100)
              RB::Fill::Color::convert((uint64_t)a2, v13, *(uint16x4_t *)_Q0.i8);
            goto LABEL_18;
          }
          a2->i32[0] = v25;
          a2->i16[2] = (v25 | (unint64_t)(v24 << 32)) >> 32;
          a2->i16[3] = v26;
          goto LABEL_15;
        }
      }
      else if (v8 == 1)
      {
        v9 = *(unsigned int *)((char *)v3 + v6 + 8);
        v10 = v9 | ((unint64_t)*(unsigned __int16 *)((char *)v3 + v6 + 12) << 32);
        v11.i32[0] = *(_DWORD *)((char *)v3 + v6 + 8);
        _H0 = *(_WORD *)((char *)v3 + v6 + 14);
        v13 = *(unsigned __int16 *)((char *)v3 + v6 + 16);
        _H2 = a2->i16[3];
        __asm
        {
          FCVT            S0, H0
          FCVT            S2, H2
        }
        *(float *)_Q0.i32 = _S2 * _S0;
        __asm { FCVT            H0, S0 }
        v11.i16[2] = *(_WORD *)((char *)v3 + v6 + 12);
        v11.i16[3] = _Q0.i16[0];
        v21.i64[0] = 0xC7000000C7000000;
        v21.i64[1] = 0xC7000000C7000000;
        if ((vmaxvq_u32((uint32x4_t)vceqq_f32(vcvtq_f32_f16(v11), v21)) & 0x80000000) != 0)
          goto LABEL_16;
        a2->i16[0] = v9;
        a2->i16[1] = WORD1(v10);
        a2->i16[2] = WORD2(v10);
        a2->i16[3] = _Q0.i16[0];
LABEL_15:
        a2[1].i16[0] = v13;
      }
LABEL_18:
      v6 += 32;
    }
    while (v7 != v6);
  }
}

void RB::DisplayList::Transform::apply_to_font(uint64_t a1, CGFont **a2, const CGGlyph *a3, float *a4, size_t a5)
{
  uint64_t v5;
  uint64_t v6;
  size_t v9;
  uint64_t v10;
  os_unfair_lock_s *v11;
  uint64_t v12;
  CGFont *v13;
  CGFont *v14;
  int v15;
  char *v16;
  int *v17;
  int UnitsPerEm;
  int v19;
  uint64_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;
  float v27;
  float v28;
  uint64_t v29;
  float v30;
  float v31;
  float *v32;
  float v33;
  uint64_t v34;
  CGFont *v35;
  uint64_t v36;
  float *v37;
  const CGGlyph *v38;
  uint64_t v39;
  _QWORD v40[2];

  v38 = a3;
  v40[1] = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a1 + 32))
    v5 = *(_QWORD *)(a1 + 32);
  else
    v5 = a1;
  v6 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v6)
  {
    v39 = a5 & 0x6000000000000000;
    v9 = 8 * a5;
    v10 = v5 + 32 * v6;
    v37 = a4;
    while (1)
    {
      if (*(_DWORD *)v5 != 3)
        goto LABEL_33;
      v11 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)a1);
      RB::FontMixer::mix(v11, *a2, *(CGFont **)(v5 + 8), *(_DWORD *)(v5 + 16), v40);
      v13 = (CGFont *)v40[0];
      if (!v40[0])
        goto LABEL_33;
      if (a5)
      {
        v14 = *a2;
        if ((CGFont *)v40[0] != *a2)
        {
          v15 = *(_DWORD *)(v5 + 20);
          if ((v15 & 7) != 0 && !v39)
            break;
        }
      }
LABEL_31:
      v35 = (CGFont *)v40[0];
      v40[0] = *a2;
      a1 = v40[0];
      *a2 = v35;
      if (a1)
        CFRelease((CFTypeRef)a1);
LABEL_33:
      v5 += 32;
      if (v5 == v10)
        return;
    }
    if (v9 > 0x1000)
    {
      v16 = (char *)malloc_type_malloc(v9, 0x44D47804uLL);
      if (!v16)
      {
LABEL_30:
        free(v16);
        goto LABEL_31;
      }
      v13 = (CGFont *)v40[0];
      v14 = *a2;
    }
    else
    {
      MEMORY[0x24BDAC7A8](a1, v12);
      v16 = (char *)&v36 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v16, v9);
    }
    if (CGFontGetGlyphAdvances(v14, v38, a5, (int *)v16))
    {
      v17 = (int *)&v16[4 * a5];
      if (CGFontGetGlyphAdvances(v13, v38, a5, v17))
      {
        UnitsPerEm = CGFontGetUnitsPerEm(*a2);
        v19 = CGFontGetUnitsPerEm(v13);
        v20 = 0;
        v21 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm));
        v22 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm), v21), v21);
        LODWORD(v23) = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)UnitsPerEm), v22)).u32[0];
        v24 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19));
        v25 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19), v24), v24);
        LODWORD(v26) = vmul_f32(v25, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v19), v25)).u32[0];
        v27 = 0.0;
        if ((v15 & 2) != 0)
          v28 = 1.0;
        else
          v28 = 0.0;
        if ((v15 & 1) != 0)
          v28 = 0.5;
        do
        {
          v27 = (float)(v27 + (float)(v23 * (float)*(int *)&v16[4 * v20])) - (float)(v26 * (float)v17[v20]);
          ++v20;
        }
        while (a5 > v20);
        v29 = 0;
        v30 = v27 * v28;
        v31 = 0.0;
        v32 = v37;
        do
        {
          v33 = -(float)((float)(v26 * (float)v17[v29]) - (float)(v23 * (float)*(int *)&v16[4 * v29]));
          v34 = *(_QWORD *)v32;
          if ((v15 & 4) != 0)
          {
            *v32 = (float)(v30 - v31) + *(float *)&v34;
            v31 = v33 + v31;
          }
          else
          {
            *v32 = *(float *)&v34 + (float)(v33 * v28);
          }
          ++v29;
          v32 += 2;
        }
        while (a5 > v29);
      }
    }
    if (v9 <= 0x1000)
      goto LABEL_31;
    goto LABEL_30;
  }
}

void sub_209B4B5F8(_Unwind_Exception *exception_object)
{
  unint64_t v1;
  void *v2;
  uint64_t v3;
  const void *v5;

  if (v1 > 0x1000)
    free(v2);
  v5 = *(const void **)(v3 - 112);
  if (v5)
    CFRelease(v5);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::Transform::Term::can_mix(CGFont **this, CGFont **a2)
{
  int v2;
  unsigned int can_mix;
  unsigned int v7;
  os_unfair_lock_s *v8;

  v2 = *(_DWORD *)this;
  if (*(_DWORD *)this != *(_DWORD *)a2)
    return 0;
  switch(v2)
  {
    case 3:
      if (*((_DWORD *)this + 5) == *((_DWORD *)a2 + 5))
      {
        v8 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
        return RB::FontMixer::can_mix(v8, this[1], a2[1], 0);
      }
      return 0;
    case 2:
      can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(this + 1), (const RB::Fill::Color *)(a2 + 1));
      v7 = RB::Fill::Color::can_mix((RB::Fill::Color *)((char *)this + 18), (const RB::Fill::Color *)((char *)a2 + 18));
      if (v7 >= can_mix)
        return can_mix;
      else
        return v7;
    case 1:
      return RB::Fill::Color::can_mix((RB::Fill::Color *)(this + 1), (const RB::Fill::Color *)(a2 + 1));
    default:
      return 4;
  }
}

void RB::DisplayList::Transform::Term::mix(CGFont **this, CGFont **a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  float v8;
  int v11;
  float16x4_t *v12;
  float16x4_t *v13;
  os_unfair_lock_s *v14;
  CGFont *v15;
  CGFont *v16;

  v8 = *(float *)a3.i32;
  v11 = *(_DWORD *)this;
  if (*(_DWORD *)this == 3)
  {
    v14 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
    RB::FontMixer::mix(v14, this[1], a2[1], LODWORD(v8), &v16);
    v15 = this[1];
    this[1] = v16;
    v16 = v15;
    if (v15)
      CFRelease(v15);
    *((float *)this + 4) = *((float *)this + 4) + (float)((float)(*((float *)a2 + 4) - *((float *)this + 4)) * v8);
  }
  else
  {
    if (v11 == 2)
    {
      RB::Fill::Color::mix((float16x4_t *)this + 1, (float16x4_t *)a2 + 1, 0, a3, a4, a5, a6, a7, a8);
      v12 = (float16x4_t *)((char *)this + 18);
      v13 = (float16x4_t *)((char *)a2 + 18);
      goto LABEL_10;
    }
    if (v11 == 1)
    {
      v12 = (float16x4_t *)(this + 1);
      v13 = (float16x4_t *)(a2 + 1);
LABEL_10:
      *(float *)a3.i32 = v8;
      RB::Fill::Color::mix(v12, v13, 0, a3, a4, a5, a6, a7, a8);
    }
  }
}

uint64_t RB::DisplayList::Transform::can_mix(RB::DisplayList::Transform *this, const RB::DisplayList::Transform *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  RB::DisplayList::Transform *v8;
  CGFont **v9;
  const RB::DisplayList::Transform *v10;
  unsigned int can_mix;

  v2 = *((unsigned int *)this + 10);
  if ((_DWORD)v2 != *((_DWORD *)a2 + 10))
    return 0;
  if (!(_DWORD)v2)
    return 4;
  v5 = 0;
  v6 = 32 * v2;
  LOBYTE(v7) = 4;
  do
  {
    v8 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
    if (!v8)
      v8 = this;
    v9 = (CGFont **)((char *)v8 + v5);
    v10 = (const RB::DisplayList::Transform *)*((_QWORD *)a2 + 4);
    if (!v10)
      v10 = a2;
    can_mix = RB::DisplayList::Transform::Term::can_mix(v9, (CGFont **)((char *)v10 + v5));
    if (can_mix >= v7)
      v7 = v7;
    else
      v7 = can_mix;
    if (!(_DWORD)v7)
      break;
    v5 += 32;
  }
  while (v6 != v5);
  return v7;
}

void RB::DisplayList::Transform::mix(RB::DisplayList::Transform *this, const RB::DisplayList::Transform *a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  uint64_t v8;
  unsigned __int32 v9;
  uint64_t v12;
  uint64_t v13;
  RB::DisplayList::Transform *v14;
  CGFont **v15;
  const RB::DisplayList::Transform *v16;

  v8 = *((unsigned int *)this + 10);
  if ((_DWORD)v8)
  {
    v9 = a3.i32[0];
    v12 = 0;
    v13 = 32 * v8;
    do
    {
      v14 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
      if (!v14)
        v14 = this;
      v15 = (CGFont **)((char *)v14 + v12);
      v16 = (const RB::DisplayList::Transform *)*((_QWORD *)a2 + 4);
      if (!v16)
        v16 = a2;
      a3.i32[0] = v9;
      RB::DisplayList::Transform::Term::mix(v15, (CGFont **)((char *)v16 + v12), a3, a4, a5, a6, a7, a8);
      v12 += 32;
    }
    while (v13 != v12);
  }
}

uint64_t RB::DisplayList::Transform::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  uint64_t v2;
  uint64_t v3;
  _BYTE *v5;
  uint64_t v6;
  int v7;
  _QWORD *v8;
  float16x4_t *v9;
  _QWORD *v10;
  CGFont *v11;
  _QWORD *v12;
  double v13;
  _QWORD *v14;
  const char *v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v18;
  double v19;
  void (**v20)(RB::XML::Value::Font *__hidden);
  CFTypeRef cf;

  if (*(_QWORD *)(this + 32))
    v2 = *(_QWORD *)(this + 32);
  else
    v2 = this;
  v3 = *(unsigned int *)(this + 40);
  if ((_DWORD)v3)
  {
    v5 = (_BYTE *)(v2 + 20);
    v6 = 32 * v3;
    while (1)
    {
      v7 = *((_DWORD *)v5 - 5);
      if (v7 == 3)
        break;
      if (v7 == 2)
      {
        RB::XML::Document::push(a2, "color");
        v16 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
        RB::XML::Value::Color::Color((RB::XML::Value::Color *)&v20, (float16x4_t *)(v5 - 12));
        RB::XML::Element::set<RB::XML::Value::Color>(v16, (uint64_t)"from", (uint64_t)&v20);
        v8 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
        v9 = (float16x4_t *)(v5 - 2);
LABEL_16:
        RB::XML::Value::Color::Color((RB::XML::Value::Color *)&v20, v9);
        RB::XML::Element::set<RB::XML::Value::Color>(v8, (uint64_t)"to", (uint64_t)&v20);
LABEL_22:
        this = RB::XML::Document::pop((uint64_t)a2);
        goto LABEL_23;
      }
      if (v7 == 1)
      {
        RB::XML::Document::push(a2, "color");
        v8 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
        v9 = (float16x4_t *)(v5 - 12);
        goto LABEL_16;
      }
LABEL_23:
      v5 += 32;
      v6 -= 32;
      if (!v6)
        return this;
    }
    RB::XML::Document::push(a2, "mix-fonts");
    v10 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
    v11 = *(CGFont **)(v5 - 12);
    v20 = &off_24C229038;
    cf = CGFontRetain(v11);
    RB::XML::Element::set<RB::XML::Value::Font>(v10, (uint64_t)"to-font", (uint64_t)&v20);
    v20 = &off_24C229038;
    if (cf)
      CFRelease(cf);
    v12 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
    v13 = *((float *)v5 - 1);
    v20 = (void (**)(RB::XML::Value::Font *__hidden))&unk_24C229178;
    cf = *(CFTypeRef *)&v13;
    RB::XML::Element::set<RB::XML::Value::Float>(v12, (uint64_t)"value", (uint64_t)&v20);
    if ((*(_DWORD *)v5 & 1) != 0)
    {
      v14 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
      v20 = (void (**)(RB::XML::Value::Font *__hidden))&unk_24C228F48;
      v15 = "center";
    }
    else
    {
      if ((*(_DWORD *)v5 & 2) == 0)
      {
LABEL_19:
        if ((*v5 & 4) != 0)
        {
          v17 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v20 = (void (**)(RB::XML::Value::Font *__hidden))&unk_24C229010;
          LOBYTE(cf) = 1;
          RB::XML::Element::set<RB::XML::Value::Bool>(v17, (uint64_t)"pack-runs", (uint64_t)&v20);
        }
        v18 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
        v19 = *((float *)v5 - 1);
        v20 = (void (**)(RB::XML::Value::Font *__hidden))&unk_24C229178;
        cf = *(CFTypeRef *)&v19;
        RB::XML::Element::set<RB::XML::Value::Float>(v18, (uint64_t)"value", (uint64_t)&v20);
        goto LABEL_22;
      }
      v14 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
      v20 = (void (**)(RB::XML::Value::Font *__hidden))&unk_24C228F48;
      v15 = "right";
    }
    cf = v15;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v14, (uint64_t)"align", (uint64_t)&v20);
    goto LABEL_19;
  }
  return this;
}

void sub_209B4BBA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Color>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &off_24C229150;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  *(_DWORD *)(v6 + 24) = *(_DWORD *)(a3 + 24);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Color,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::ConstantString>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  v7 = *(_QWORD *)(a3 + 8);
  *v6 = &unk_24C228F48;
  v6[1] = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ConstantString,void>(v9 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

uint64_t RB::DisplayList::Contents::apply_transform(RB::DisplayList::Contents *this, const RB::DisplayList::Transform *a2)
{
  return RB::DisplayList::Layer::apply_transform((uint64_t)this + 320, a2, this);
}

uint64_t RB::DisplayList::Layer::apply_transform(uint64_t this, const RB::DisplayList::Transform *a2, RB::DisplayList::Contents *a3)
{
  uint64_t v5;
  _QWORD *i;

  v5 = this;
  if (*(_BYTE *)(this + 64) == 2)
  {
    this = (*(uint64_t (**)(_QWORD, RB::DisplayList::Contents *, const RB::DisplayList::Transform *))(**(_QWORD **)(this + 24) + 80))(*(_QWORD *)(this + 24), a3, a2);
    *(_QWORD *)(v5 + 24) = this;
  }
  for (i = *(_QWORD **)v5; i; i = (_QWORD *)i[1])
    this = (*(uint64_t (**)(_QWORD *, const RB::DisplayList::Transform *, RB::DisplayList::Contents *))(*i + 200))(i, a2, a3);
  return this;
}

uint64_t RB::DisplayList::LayerItem::apply_transform(RB::DisplayList::LayerItem *this, const RB::DisplayList::Transform *a2, RB::DisplayList::Contents *a3)
{
  return RB::DisplayList::Layer::apply_transform(*((_QWORD *)this + 6), a2, a3);
}

int *RB::DisplayList::Transform::encode(int *this, RB::Encoder *a2)
{
  int *v2;
  uint64_t v3;
  uint64_t v5;

  if (*((_QWORD *)this + 4))
    v2 = (int *)*((_QWORD *)this + 4);
  else
    v2 = this;
  v3 = this[10];
  if ((_DWORD)v3)
  {
    v5 = 32 * v3;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::DisplayList::Transform::Term::encode(v2, a2);
      this = (int *)RB::ProtobufEncoder::end_length_delimited(a2);
      v2 += 8;
      v5 -= 32;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::DisplayList::Transform::decode(RB::DisplayList::Transform *this, RB::Decoder *a2)
{
  RB::DisplayList::Transform *v4;
  uint64_t v5;
  CFTypeRef *v6;
  uint64_t v7;
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  RB::DisplayList::Transform *v12;
  RB::DisplayList::Transform::Term *v13;

  if (*((_QWORD *)this + 4))
    v4 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
  else
    v4 = this;
  v5 = *((unsigned int *)this + 10);
  if ((_DWORD)v5)
  {
    v6 = (CFTypeRef *)((char *)v4 + 8);
    v7 = 32 * v5;
    do
    {
      if (*((_DWORD *)v6 - 2) == 3 && *v6)
        CFRelease(*v6);
      v6 += 4;
      v7 -= 32;
    }
    while (v7);
  }
  *((_DWORD *)this + 10) = 0;
  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v9 = result;
    do
    {
      if ((v9 & 0x7FFFFFFF8) == 8)
      {
        v10 = *((_DWORD *)this + 10);
        v11 = v10 + 1;
        if (*((_DWORD *)this + 11) < v10 + 1)
        {
          RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(this, v11);
          v10 = *((_DWORD *)this + 10);
          v11 = v10 + 1;
        }
        v12 = (RB::DisplayList::Transform *)*((_QWORD *)this + 4);
        if (!v12)
          v12 = this;
        v13 = (RB::DisplayList::Transform *)((char *)v12 + 32 * v10);
        *(_DWORD *)v13 = 0;
        *((_DWORD *)this + 10) = v11;
        if ((v9 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Transform::Term::decode(v13, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v9);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v9 = result;
    }
    while (result);
  }
  return result;
}

int *RB::DisplayList::Transform::Term::encode(int *this, RB::Encoder *a2)
{
  int *v3;
  int v4;
  int v5;
  unint64_t v6;

  v3 = this;
  v4 = *this;
  if (*this == 3)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Encoder::cgfont_field(a2, 1, *((CGFont **)v3 + 1));
    v5 = v3[4];
    if (*(float *)&v5 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v5);
    }
    v6 = v3[5];
    if ((_DWORD)v6)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
      RB::ProtobufEncoder::encode_varint(a2, v6);
    }
  }
  else if (v4 == 2)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)(v3 + 2), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)((char *)v3 + 18), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  else
  {
    if (v4 != 1)
      return this;
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::Color *)(v3 + 2), a2);
  }
  return (int *)RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::Transform::Term::decode(RB::DisplayList::Transform::Term *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  CFTypeRef *v6;
  unint64_t v7;
  uint64_t field;
  unint64_t v9;
  unint64_t v10;
  uint64_t *v11;
  CFTypeRef v12;
  CFTypeRef v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    v6 = (CFTypeRef *)((char *)this + 8);
    while (1)
    {
      v7 = v5 >> 3;
      if ((v5 >> 3) == 4)
      {
        if (*(_DWORD *)this == 3 && *v6)
          CFRelease(*v6);
        *(_DWORD *)this = 3;
        *v6 = 0;
        *((_QWORD *)this + 2) = 0;
        if ((v5 & 7) != 2)
        {
LABEL_53:
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          goto LABEL_51;
        }
        RB::ProtobufDecoder::begin_message(a2);
        field = RB::ProtobufDecoder::next_field(a2);
        if (field)
        {
          v9 = field;
          do
          {
            v10 = v9 >> 3;
            if ((v9 >> 3) == 3)
            {
              *((_DWORD *)this + 5) = RB::ProtobufDecoder::uint_field(a2, v9);
            }
            else if ((_DWORD)v10 == 2)
            {
              *((float *)this + 4) = RB::ProtobufDecoder::float_field(a2, v9);
            }
            else if ((_DWORD)v10 == 1)
            {
              v11 = RB::Decoder::cgfont_field(a2, v9);
              v12 = *v6;
              if (*v6 != v11)
              {
                if (v12)
                  CFRelease(v12);
                if (v11)
                  v13 = CFRetain(v11);
                else
                  v13 = 0;
                *v6 = v13;
              }
            }
            else
            {
              RB::ProtobufDecoder::skip_field(a2, v9);
            }
            v9 = RB::ProtobufDecoder::next_field(a2);
          }
          while (v9);
        }
        goto LABEL_49;
      }
      if ((_DWORD)v7 == 2)
        break;
      if ((_DWORD)v7 != 1)
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
        goto LABEL_51;
      }
      if (*(_DWORD *)this == 3)
      {
        if (*v6)
          CFRelease(*v6);
      }
      *(_DWORD *)this = 1;
      if ((v5 & 7) != 2)
        goto LABEL_53;
      RB::ProtobufDecoder::begin_message(a2);
      RB::Fill::Color::decode((uint64_t)this + 8, a2);
LABEL_49:
      RB::ProtobufDecoder::end_message((uint64_t)a2);
LABEL_51:
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
      if (!result)
        return result;
    }
    if (*(_DWORD *)this == 3 && *v6)
      CFRelease(*v6);
    *(_DWORD *)this = 2;
    if ((v5 & 7) != 2)
      goto LABEL_53;
    RB::ProtobufDecoder::begin_message(a2);
    *((_QWORD *)this + 1) = 0x3C00000000000000;
    *((_WORD *)this + 8) = 0;
    *(_QWORD *)((char *)this + 18) = 0x3C00000000000000;
    *((_WORD *)this + 13) = 0;
    v14 = RB::ProtobufDecoder::next_field(a2);
    if (!v14)
      goto LABEL_49;
    v15 = v14;
    while (1)
    {
      if ((v15 >> 3) == 2)
      {
        if ((v15 & 7) != 2)
        {
LABEL_48:
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          goto LABEL_46;
        }
        RB::ProtobufDecoder::begin_message(a2);
        v16 = (char *)this + 18;
      }
      else
      {
        if ((v15 >> 3) != 1)
        {
          RB::ProtobufDecoder::skip_field(a2, v15);
          goto LABEL_46;
        }
        if ((v15 & 7) != 2)
          goto LABEL_48;
        RB::ProtobufDecoder::begin_message(a2);
        v16 = (char *)this + 8;
      }
      RB::Fill::Color::decode((uint64_t)v16, a2);
      RB::ProtobufDecoder::end_message((uint64_t)a2);
LABEL_46:
      v15 = RB::ProtobufDecoder::next_field(a2);
      if (!v15)
        goto LABEL_49;
    }
  }
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Color,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229DC8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B4C3A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Color *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Color>,std::allocator<RB::XML::Value::Color>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Color *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Color>,std::allocator<RB::XML::Value::Color>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ConstantString,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229AF0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B4C460(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ConstantString *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ConstantString>,std::allocator<RB::XML::Value::ConstantString>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ConstantString *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ConstantString>,std::allocator<RB::XML::Value::ConstantString>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t RB::Stroke::stroke_points(void *a1, uint64_t (***a2)(_QWORD), float64x2_t a3)
{
  _QWORD v5[3];

  v5[0] = a2;
  v5[1] = vcvt_f32_f64(a3);
  v5[2] = 0x3F80000000000000;
  objc_msgSend(a1, "applyFunction:info:", _ZZN2RB6Stroke13stroke_pointsEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_5PointEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv, v5);
  return (**a2)(a2);
}

uint64_t RB::Stroke::stroke_particles(void *a1, uint64_t (***a2)(_QWORD), float64x2_t a3)
{
  _QWORD v10[7];

  v10[0] = a2;
  __asm { FMOV            V1.2S, #1.0 }
  v10[1] = vcvt_f32_f64(a3);
  v10[2] = _D1;
  v10[3] = 1065353216;
  v10[4] = 0;
  v10[5] = 0;
  v10[6] = 1065353216;
  objc_msgSend(a1, "applyFunction:info:", _ZZN2RB6Stroke16stroke_particlesEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_8ParticleEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv, v10);
  return (**a2)(a2);
}

uint64_t _ZZN2RB6Stroke13stroke_pointsEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_5PointEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv(uint64_t result, unsigned __int8 *a2, float32x2_t *a3, float32x2_t *a4, __n128 a5)
{
  uint64_t v8;
  float *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  if (result)
  {
    v8 = result;
    v9 = (float *)&a4[2];
    do
    {
      v11 = *a2++;
      v10 = v11;
      if (v11 > 0xF)
        v12 = 0;
      else
        v12 = RB::Stroke::element_args(RBStrokeElement)::elts[v10];
      switch((int)v10)
      {
        case 0:
          a5.n128_u64[0] = (unint64_t)vadd_f32(*a3, a4[1]);
          result = (*(uint64_t (**)(__n128))(**(_QWORD **)a4 + 16))(a5);
          break;
        case 1:
          a5.n128_u64[0] = (unint64_t)vadd_f32(*a3, a4[1]);
          result = (*(uint64_t (**)(__n128))(**(_QWORD **)a4 + 24))(a5);
          break;
        case 2:
          result = (*(uint64_t (**)(float32x2_t, float *, double, double))(**(_QWORD **)a4 + 32))(*a4, v9, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])));
          break;
        case 3:
          result = (*(uint64_t (**)(float32x2_t, float *, double, double, double))(**(_QWORD **)a4 + 40))(*a4, v9, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])), COERCE_DOUBLE(vadd_f32(a3[2], a4[1])));
          break;
        case 4:
          result = (*(uint64_t (**)(float32x2_t))(**(_QWORD **)a4 + 8))(*a4);
          break;
        case 5:
          *v9 = fmaxf(a3->f32[0] * 0.5, 0.0);
          break;
        case 14:
          a4[2].i32[1] = a3->i32[0];
          break;
        default:
          break;
      }
      a3 = (float32x2_t *)((char *)a3 + 4 * v12);
      --v8;
    }
    while (v8);
  }
  return result;
}

uint64_t _ZZN2RB6Stroke16stroke_particlesEPU18objcproto8RBStroke11objc_objectDv2_dRNS0_12PathConsumerINS0_8ParticleEEEEN3__08__invokeEmPK15RBStrokeElementPKfPv(uint64_t result, unsigned __int8 *a2, float32x2_t *a3, float32x2_t *a4, __n128 a5)
{
  uint64_t v8;
  float32x2_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  if (result)
  {
    v8 = result;
    v9 = a4 + 2;
    do
    {
      v11 = *a2++;
      v10 = v11;
      if (v11 > 0xF)
        v12 = 0;
      else
        v12 = RB::Stroke::element_args(RBStrokeElement)::elts[v10];
      switch((int)v10)
      {
        case 0:
          a5.n128_u64[0] = (unint64_t)vadd_f32(*a3, a4[1]);
          result = (*(uint64_t (**)(__n128))(**(_QWORD **)a4 + 16))(a5);
          break;
        case 1:
          a5.n128_u64[0] = (unint64_t)vadd_f32(*a3, a4[1]);
          result = (*(uint64_t (**)(__n128))(**(_QWORD **)a4 + 24))(a5);
          break;
        case 2:
          result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double, double))(**(_QWORD **)a4 + 32))(*a4, v9, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])));
          break;
        case 3:
          result = (*(uint64_t (**)(float32x2_t, float32x2_t *, double, double, double))(**(_QWORD **)a4 + 40))(*a4, v9, COERCE_DOUBLE(vadd_f32(*a3, a4[1])), COERCE_DOUBLE(vadd_f32(a3[1], a4[1])), COERCE_DOUBLE(vadd_f32(a3[2], a4[1])));
          break;
        case 4:
          result = (*(uint64_t (**)(float32x2_t))(**(_QWORD **)a4 + 8))(*a4);
          break;
        case 6:
          v9->i32[0] = a3->i32[0];
          break;
        case 7:
          a4[2].i32[1] = a3->i32[0];
          break;
        case 8:
          a4[3].i32[0] = a3->i32[0];
          break;
        case 9:
          a4[3].i32[1] = a3->i32[0];
          break;
        case 10:
          a4[4].i32[0] = a3->i32[0];
          break;
        case 11:
          a4[4].i32[1] = a3->i32[0];
          break;
        case 12:
          a4[5].i32[0] = a3->i32[0];
          break;
        case 13:
          a4[5].i32[1] = a3->i32[0];
          break;
        case 14:
          a4[6].i32[0] = a3->i32[0];
          break;
        case 15:
          a4[6].i32[1] = a3->i32[0];
          break;
        default:
          break;
      }
      a3 = (float32x2_t *)((char *)a3 + 4 * v12);
      --v8;
    }
    while (v8);
  }
  return result;
}

void sub_209B4C980(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

void sub_209B4CA30(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

void sub_209B4CD08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va);
  _Unwind_Resume(a1);
}

void sub_209B4D084(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, uint64_t a11, id a12, id a13, unsigned int *a14, id a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,id a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  uint64_t v31;
  unsigned int *v33;
  unsigned int v34;
  unsigned int v35;

  if (v31)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3((uint64_t)a14);

  if (a14)
  {
    v33 = a14 + 2;
    do
    {
      v34 = __ldxr(v33);
      v35 = v34 - 1;
    }
    while (__stlxr(v35, v33));
    if (!v35)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)a14 + 8))(a14);
    }
  }

  _Unwind_Resume(a1);
}

void sub_209B4D598(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v2;
  uint64_t v3;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  v5 = (unsigned int *)v1[7];
  if (v5)
  {
    v6 = v5 + 2;
    do
    {
      v7 = __ldxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
    }
  }
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)(v1 + 20));
  RB::vector<RB::refcounted_ptr<RB::DisplayList::Contents>,8ul,unsigned int>::~vector(v3 - 224);
  if (v1[3] > 0x1000uLL)
    free(v2);
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::refcounted_ptr<RB::DisplayList::Contents>,8ul,unsigned int>::~vector(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  v2 = *(_QWORD **)(a1 + 64);
  if (v2)
    v3 = v2;
  else
    v3 = (_QWORD *)a1;
  if (*(_DWORD *)(a1 + 72))
  {
    v4 = 0;
    do
    {
      v5 = (unsigned int *)v3[v4];
      if (v5)
      {
        v6 = v5 + 2;
        do
        {
          v7 = __ldxr(v6);
          v8 = v7 - 1;
        }
        while (__stlxr(v8, v6));
        if (!v8)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
        }
      }
      ++v4;
    }
    while (v4 < *(unsigned int *)(a1 + 72));
    v2 = *(_QWORD **)(a1 + 64);
  }
  if (v2)
    free(v2);
  return a1;
}

void sub_209B4D918(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34)
{
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)&a34);

  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a28, 8);
  _Unwind_Resume(a1);
}

void __Block_byref_object_copy__1(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 131);
}

void __Block_byref_object_dispose__1(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 131);
}

id __copy_helper_block_e8_56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 56);
  *(_QWORD *)(a1 + 56) = result;
  return result;
}

void __destroy_helper_block_e8_56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE(uint64_t a1)
{

}

id __copy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  id result;

  a1[6] = *(id *)(a2 + 48);
  a1[7] = *(id *)(a2 + 56);
  a1[8] = *(id *)(a2 + 64);
  v4 = *(_QWORD *)(a2 + 72);
  if (v4)
  {
    v5 = (unsigned int *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[9] = v4;
  result = *(id *)(a2 + 120);
  a1[15] = result;
  return result;
}

void sub_209B4DAC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 72);
  if (v3)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3(v3);

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_48c58_ZTSN2RB8objc_ptrIPU21objcproto10MTLTexture11objc_objectEE56c66_ZTSN2RB8objc_ptrIPU29objcproto18RBDrawableDelegate11objc_objectEE64c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE120c55_ZTSN2RB8objc_ptrIPU18objcproto8MTLEvent11objc_objectEE(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(unsigned int **)(a1 + 72);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }

}

void sub_209B4DDF0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209B4DE7C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_1(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint8_t a9)
{
  _os_log_error_impl(a1, a2, OS_LOG_TYPE_ERROR, a4, &a9, 0xCu);
}

RB::FunctionLibrary *RB::FunctionLibrary::FunctionLibrary(RB::FunctionLibrary *this, id *a2, const RB::CustomShader::Library *a3)
{
  id v6;
  void *v7;
  uint64_t v8;
  id v9;
  const void *v10;
  size_t v11;
  uint64_t v12;
  uint64_t v13;
  id v15;
  _QWORD destructor[5];
  id v17;
  _QWORD v18[2];
  _QWORD v19[3];

  v19[2] = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = *((unsigned int *)a3 + 7);
  *((_DWORD *)this + 6) = 0;
  RB::UntypedTable::UntypedTable((RB::FunctionLibrary *)((char *)this + 32), 0, 0, 0, (void (*)(void *))RB::FunctionLibrary::FunctionLibrary(RB::Device &,RB::CustomShader::Library const&)::$_0::__invoke, 0);
  *((_BYTE *)this + 112) = 0;
  v17 = 0;
  switch(*((_DWORD *)a3 + 6))
  {
    case 0:
      v6 = (id)objc_msgSend(a2[3], "newDefaultLibraryWithBundle:error:", *((_QWORD *)a3 + 2), &v17);

      goto LABEL_5;
    case 1:
      v6 = (id)objc_msgSend(a2[3], "newLibraryWithURL:error:", *((_QWORD *)a3 + 2), &v17);

      goto LABEL_5;
    case 2:
      v9 = *((id *)a3 + 2);
      v10 = (const void *)objc_msgSend(v9, "bytes");
      v11 = objc_msgSend(v9, "length");
      destructor[0] = MEMORY[0x24BDAC760];
      destructor[1] = 3221225472;
      destructor[2] = ___ZN2RB15FunctionLibraryC2ERNS_6DeviceERKNS_12CustomShader7LibraryE_block_invoke;
      destructor[3] = &unk_24C22B108;
      destructor[4] = v9;
      v7 = dispatch_data_create(v10, v11, MEMORY[0x24BDAC9B8], destructor);
      v8 = objc_msgSend(a2[3], "newLibraryWithData:error:", v7, &v17);

      goto LABEL_7;
    case 3:
      v6 = (id)*((_QWORD *)a3 + 2);
      if ((id)objc_msgSend(v6, "device") != a2[3])
        goto LABEL_9;
      v15 = (id)*((_QWORD *)this + 1);
      if (v15 != v6)
      {

        v6 = v6;
LABEL_5:
        *((_QWORD *)this + 1) = v6;
      }
      goto LABEL_10;
    case 4:
      v7 = (void *)objc_opt_new();
      objc_msgSend(v7, "appendString:", CFSTR("#include <metal_stdlib>\n\nnamespace RB {\n  struct Layer {\n    metal::texture2d<half> tex;\n    float2 info[5];\n    half4 sample(float2 p) const {\n      p = metal::fma(p.x, info[0], metal::fma(p.y, info[1], info[2]));\n      p = metal::clamp(p, info[3], info[4]);\n      return tex.sample(metal::sampler(metal::filter::linear), p);\n    }\n  };\n}\n\n#line 0\n"));
      objc_msgSend(v7, "appendString:", *((_QWORD *)a3 + 2));
      v8 = objc_msgSend(a2[3], "newLibraryWithSource:options:error:", v7, 0, &v17);

LABEL_7:
      *((_QWORD *)this + 1) = v8;

      goto LABEL_9;
    default:
LABEL_9:
      v6 = (id)*((_QWORD *)this + 1);
LABEL_10:
      if (!v6)
      {
        if (v17)
        {
          v18[0] = *MEMORY[0x24BDD0FC8];
          v12 = objc_msgSend(v17, "localizedDescription");
          v18[1] = *MEMORY[0x24BDD1398];
          v19[0] = v12;
          v19[1] = v17;
          v13 = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v19, v18, 2);
        }
        else
        {
          v13 = 0;
        }
        RB::CustomShader::Library::log_error((os_unfair_lock_s *)a3, (NSError *)objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 0, v13));
      }
      return this;
  }
}

void sub_209B4E320(_Unwind_Exception *a1)
{
  uint64_t v1;
  RB::UntypedTable *v2;

  RB::UntypedTable::~UntypedTable(v2);

  _Unwind_Resume(a1);
}

void ___ZN2RB15FunctionLibraryC2ERNS_6DeviceERKNS_12CustomShader7LibraryE_block_invoke(uint64_t a1)
{

}

uint64_t RB::FunctionLibrary::function(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t *v8;
  size_t **v9;
  uint64_t *v10;
  uint64_t v11;
  double v12;
  RB::Device *v13;
  void *v14;
  void *v15;
  void *v16;
  id v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  size_t v24;
  int *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _DWORD *v29;
  size_t v30;
  int v31;
  RB *v33;
  double v34;
  id v35;
  NSError *v36;
  void *v37;
  uint64_t v38;
  void *v39;
  size_t v40;
  uint64_t v41;
  __int128 v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (!*(_QWORD *)(a1 + 8) || *(_DWORD *)(a1 + 16) != *(_DWORD *)(*(_QWORD *)(a2 + 16) + 28))
    return 0;
  v8 = (uint64_t *)(a3 | (8 * *(_DWORD *)(a2 + 32)));
  v9 = (size_t **)(a1 + 32);
  v37 = 0;
  v10 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 32), v8, &v37);
  v11 = (uint64_t)v10;
  if (!v37)
  {
    v12 = RB::current_time_seconds((RB *)v10);
    v39 = 0;
    v40 = 0;
    v41 = 8;
    v42 = xmmword_209BD6D00;
    v36 = 0;
    v13 = *(RB::Device **)a1;
    v14 = *(void **)(a1 + 8);
    v15 = (void *)*((_QWORD *)v13 + 3);
    v16 = (void *)RB::Device::library(v13);
    v17 = v35;
    if (!v35 && v36)
      RB::CustomShader::Library::log_error(*(os_unfair_lock_s **)(a2 + 16), v36);
    v18 = objc_msgSend(v17, "newFunctionWithName:", CFSTR("custom_fn"));
    v19 = v18;
    if (!v18)
    {
      if (!v11)
      {
LABEL_24:
        RB::UntypedTable::insert(v9, (size_t *)v8, (size_t *)v11);

        if (v39)
          free(v39);
        return v11;
      }
LABEL_22:
      v33 = (RB *)RB::verbose_mode((RB *)v18);
      if ((_DWORD)v33)
      {
        v34 = RB::current_time_seconds(v33);
        printf("built stitched function %s (%.2f ms)\n", (const char *)objc_msgSend(*(id *)(a2 + 24), "UTF8String"), (v34 - v12) * 1000.0);
        fflush((FILE *)*MEMORY[0x24BDAC8E8]);
      }
      goto LABEL_24;
    }
    v18 = operator new();
    v11 = v18;
    v20 = (int)v37;
    v22 = v42;
    v21 = DWORD1(v42);
    *(_DWORD *)v18 = *(_DWORD *)(a2 + 32);
    *(_DWORD *)(v18 + 4) = a3;
    *(_QWORD *)(v18 + 8) = v19;
    *(_DWORD *)(v18 + 16) = v20;
    v23 = v18 + 24;
    *(_QWORD *)(v18 + 56) = 0;
    v24 = v40;
    if (v39)
      v25 = (int *)v39;
    else
      v25 = (int *)&v38;
    *(_QWORD *)(v18 + 64) = 0;
    *(_QWORD *)(v18 + 72) = 8;
    if (v24 >= 9)
    {
      v18 = (uint64_t)RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow((void *)(v18 + 24), v24);
      v26 = *(_QWORD *)(v11 + 56);
      v27 = *(_QWORD *)(v11 + 64);
    }
    else
    {
      v26 = 0;
      v27 = 0;
      v28 = 0;
      if (!v24)
      {
LABEL_18:
        *(_QWORD *)(v11 + 64) = v28 + v24;
        *(_DWORD *)(v11 + 80) = v22;
        *(_QWORD *)(v11 + 84) = *((_QWORD *)&v42 + 1);
        *(_DWORD *)(v11 + 92) = 0;
        *(_DWORD *)(v11 + 96) = 0;
        *(_DWORD *)(v11 + 100) = v21;
        *(_WORD *)(v11 + 104) = 0;
        goto LABEL_22;
      }
    }
    if (!v26)
      v26 = v23;
    v29 = (_DWORD *)(v26 + 4 * v27);
    v30 = v24;
    do
    {
      v31 = *v25++;
      *v29++ = v31;
      --v30;
    }
    while (v30);
    v28 = *(_QWORD *)(v11 + 64);
    goto LABEL_18;
  }
  return v11;
}

void sub_209B4E630(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  uint64_t v19;
  void **v20;

  if (*v20)
    free(*v20);

  MEMORY[0x20BD16544](v19, 0x10A0C408BE17B63);
  if (a19)
    free(a19);
  _Unwind_Resume(a1);
}

void RB::`anonymous namespace'::make_stitched_library(uint64_t a1@<X0>, unsigned int a2@<W1>, _QWORD *a3@<X2>, void *a4@<X3>, void *a5@<X4>, void *a6@<X5>, uint64_t a7@<X6>, _QWORD *a8@<X7>, uint64_t *a9@<X8>)
{
  uint64_t v16;
  void *v17;
  int v18;
  uint64_t v19;
  char *v20;
  uint64_t i;
  int v22;
  unsigned int v23;
  unsigned int v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  unsigned int v31;
  unsigned int v32;
  void *v33;
  void *v34;
  const char *v35;
  id v36;
  uint64_t v37;
  void *v38;
  _QWORD *v39;
  void *v40;
  id v41;
  void *v42;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v45;
  uint64_t v46;
  unsigned int v47;
  unsigned int v48;
  unsigned int v49;
  void *v50;
  id v51;
  void *v52;
  void *v53;
  void *fn;
  id v55;
  void *v56;
  void *v57;
  const __CFString *v58;
  id v59;
  void *v60;
  id v61;
  void *v62;
  void *v63;
  void *v64;
  id v65;
  id v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  id v70;
  void *v71;
  void *v72;
  void *v73;
  uint64_t v74;
  id v75;
  void *v76;
  void *v77;
  const __CFString *v78;
  NSMutableString *v79;
  NSMutableString *v80;
  const RB::Function::Param *v81;
  const RB::Function::Param *v82;
  uint64_t v83;
  void *v84;
  uint64_t v85;
  int *v86;
  NSArray *v87;
  uint64_t v88;
  NSArray *v89;
  void *v90;
  uint64_t v91;
  unint64_t v92;
  void *v93;
  void *v94;
  id v95;
  _QWORD *v96;
  void *v97;
  void *v98;
  uint64_t *v99;
  id v100;
  id v101;
  unsigned int v102;
  id v103;
  id v104;
  id v105;
  void *v107;
  id v108;
  id v109;
  id v110;
  void *v111;
  void *v112;
  id v113;
  _QWORD v114[4];
  id v115;
  void *v116;
  void *v117;
  void *v118;
  _QWORD v119[2];
  _QWORD v120[5];
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125[2];
  id v126;
  uint64_t v127;
  uint64_t v128;

  v128 = *MEMORY[0x24BDAC8D0];
  v16 = objc_msgSend(a5, "newFunctionWithName:", *(_QWORD *)(a1 + 24));
  v17 = (void *)v16;
  if (v16)
  {
    v111 = a6;
    v96 = a8;
    v97 = a4;
    v99 = a9;
    v107 = (void *)v16;
    v102 = a2;
    if (a2 == 3)
      v18 = 6;
    else
      v18 = 2;
    *(_DWORD *)a7 = v18;
    v19 = a3[1];
    if (v19)
    {
      v20 = (char *)(*a3 + 7);
      for (i = 24 * v19; i; i -= 24)
      {
        switch(*(v20 - 3))
        {
          case 1:
            v22 = 0;
            v23 = 5u;
            break;
          case 2:
            v22 = 0;
            v23 = 6u;
            break;
          case 3:
            v22 = 0;
            v23 = 7u;
            break;
          case 4:
          case 6:
            v22 = 0;
            v23 = 8u;
            break;
          case 5:
            v22 = 0;
            v23 = 2u;
            break;
          case 7:
          case 8:
            v23 = 4u;
            v22 = 1;
            break;
          default:
            v22 = 0;
            v23 = 0;
            break;
        }
        v24 = *(_DWORD *)(a7 + 64) + 3;
        *(_DWORD *)(a7 + 64) = v24 & 0xFFFFFFFC;
        v25 = *v20;
        v26 = *(_QWORD *)(a7 + 48);
        if (*(_QWORD *)(a7 + 56) < (unint64_t)(v26 + 1))
        {
          RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow((void *)(a7 + 8), v26 + 1);
          v26 = *(_QWORD *)(a7 + 48);
        }
        v27 = *(_QWORD *)(a7 + 40);
        if (!v27)
          v27 = a7 + 8;
        *(_DWORD *)(v27 + 4 * v26) = ((v25 << 7) | 0x40) & (v25 << 6) & 0xC0 | (v24 >> 2 << 8) | v23;
        v28 = *(_QWORD *)(a7 + 48) + 1;
        *(_QWORD *)(a7 + 48) = v28;
        if ((*v20 & 1) != 0)
        {
          v30 = *(_DWORD *)(a7 + 64);
          *(_DWORD *)(a7 + 64) = v30 + 4;
          if ((*v20 & 2) == 0)
            goto LABEL_24;
          v29 = v30 + 8;
        }
        else
        {
          v29 = *(_DWORD *)(a7 + 64) + RB::Function::Param::size_values[v23];
        }
        *(_DWORD *)(a7 + 64) = v29;
LABEL_24:
        if (v22)
        {
          if ((*(_DWORD *)(a7 + 68) & 0x80000000) == 0)
          {
            v17 = v107;
            if (v96)
            {
              v84 = (void *)MEMORY[0x24BDD1540];
              v121 = *MEMORY[0x24BDD0FC8];
              v122 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Only one texture argument is allowed: %@"), *(_QWORD *)(a1 + 24));
              *v96 = objc_msgSend(v84, "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 3, objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v122, &v121, 1));
            }
            *v99 = 0;
            goto LABEL_98;
          }
          *(_DWORD *)(a7 + 68) = v28 - 1;
        }
        v20 += 24;
      }
    }
    if (a2 - 2 <= 2)
    {
      v31 = *(_DWORD *)(a7 + 64) + 3;
      *(_DWORD *)(a7 + 72) = v31 >> 2;
      *(_DWORD *)(a7 + 64) = (v31 & 0xFFFFFFFC) + 40;
      if (a2 == 4)
      {
        v32 = (v31 & 0xFFFFFFFC) + 43;
        *(_DWORD *)(a7 + 76) = v32 >> 2;
        *(_DWORD *)(a7 + 64) = (v32 & 0xFFFFFFFC) + 40;
      }
    }
    v33 = (void *)objc_opt_new();
    v95 = v33;
    v103 = (id)objc_opt_new();
    v34 = (void *)objc_opt_new();
    v113 = (id)objc_opt_new();
    v109 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 0);
    v104 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 1);
    v101 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 2);
    v105 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 3);
    v100 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 4);
    v110 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 5);
    v108 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5D8]), "initWithArgumentIndex:", 6);
    if ((RB::disable_workaround((RB *)"stitched-inputs", v35) & 1) == 0)
    {
      v36 = objc_alloc(MEMORY[0x24BDDD5C8]);
      v120[0] = v109;
      v120[1] = v104;
      v120[2] = v101;
      v120[3] = v105;
      v120[4] = v100;
      v37 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v120, 5);
      v38 = (void *)objc_msgSend(v36, "initWithName:arguments:controlDependencies:", CFSTR("__RB::XXX"), v37, MEMORY[0x24BDBD1A8]);
      objc_msgSend(v103, "addObject:", v38);
      objc_msgSend(v34, "addObject:", v38);

    }
    objc_msgSend(v33, "addObject:", v105);
    if (a2 == 4 || a2 == 2)
    {
      v41 = v126;
      objc_msgSend(v33, "addObject:", v126);
      if (a2 == 4)
      {
        v42 = (void *)v125[0];
        objc_msgSend(v33, "addObject:", v125[0]);

      }
    }
    else if (a2 == 1)
    {
      objc_msgSend(v33, "addObject:", v100);
    }
    v43 = *(_QWORD *)(a7 + 48);
    if (*(_QWORD *)(a7 + 40))
      v44 = *(unsigned int **)(a7 + 40);
    else
      v44 = (unsigned int *)(a7 + 8);
    if (v43)
    {
      v45 = 4 * v43;
      v46 = MEMORY[0x24BDBD1A8];
      do
      {
        v47 = *v44;
        v48 = *v44 & 0x3F;
        if (v48 == 4)
        {
          objc_msgSend(v33, "addObject:", v109);
        }
        else
        {
          v49 = v47 >> 8;
          if ((v47 & 0x40) != 0)
          {
            v55 = objc_alloc(MEMORY[0x24BDDD5C8]);
            v56 = v116;
            v126 = v110;
            v127 = (uint64_t)v116;
            v57 = (void *)objc_msgSend(v55, "initWithName:arguments:controlDependencies:", fn, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v126, 2), v46);
            objc_msgSend(v34, "addObject:", v57);
            v58 = CFSTR("__RB::Ainvalid");
            if (v48 != 3)
            {
              v58 = CFSTR("__RB::Avoid");
            }
            v59 = objc_alloc(MEMORY[0x24BDDD5C8]);
            v125[0] = (uint64_t)v108;
            v125[1] = (uint64_t)v57;
            v53 = (void *)objc_msgSend(v59, "initWithName:arguments:controlDependencies:", v58, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v125, 2), v46);
            objc_msgSend(v34, "addObject:", v53);

            objc_msgSend(v33, "addObject:", v53);
            if ((*v44 & 0x80) != 0)
            {
              v61 = objc_alloc(MEMORY[0x24BDDD5C8]);
              v62 = (void *)v125[0];
              v126 = v110;
              v127 = v125[0];
              v63 = (void *)objc_msgSend(v61, "initWithName:arguments:controlDependencies:", v60, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v126, 2), v46);
              objc_msgSend(v34, "addObject:", v63);

              objc_msgSend(v33, "addObject:", v63);
            }
          }
          else
          {
            v51 = objc_alloc(MEMORY[0x24BDDD5C8]);
            v52 = (void *)v125[0];
            v126 = v110;
            v127 = v125[0];
            v53 = (void *)objc_msgSend(v51, "initWithName:arguments:controlDependencies:", v50, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v126, 2), v46);
            objc_msgSend(v34, "addObject:", v53);

            objc_msgSend(v33, "addObject:", v53);
          }

        }
        ++v44;
        v45 -= 4;
      }
      while (v45);
    }
    v64 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDDD5C8]), "initWithName:arguments:controlDependencies:", *(_QWORD *)(a1 + 24), v33, v103);
    if (v102 == 3)
    {
      objc_msgSend(v34, "addObject:", v64);
      v65 = objc_alloc(MEMORY[0x24BDDD5C8]);
      v66 = v126;
      v119[0] = v126;
      v119[1] = v64;
      v67 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v119, 2);
      v68 = objc_msgSend(v65, "initWithName:arguments:controlDependencies:", CFSTR("__RB::Slayer"), v67, MEMORY[0x24BDBD1A8]);

      v64 = (void *)v68;
    }
    v69 = (void *)objc_opt_new();
    v70 = objc_alloc(MEMORY[0x24BDDD5D0]);
    v118 = v69;
    v71 = (void *)objc_msgSend(v70, "initWithFunctionName:nodes:outputNode:attributes:", CFSTR("custom_fn"), v34, v64, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v118, 1));
    v72 = (void *)objc_opt_new();
    objc_msgSend(v72, "addObject:", v107);
    v114[0] = MEMORY[0x24BDAC760];
    v114[1] = 3321888768;
    v114[2] = ___ZN2RB12_GLOBAL__N_121make_stitched_libraryERKNS_12CustomShader8FunctionENS1_4TypeERKNSt3__14spanIKNS1_5ValueELm18446744073709551615EEEPU19objcproto9MTLDevice11objc_objectPU21objcproto10MTLLibrary11objc_objectSG_RNS0_12FunctionInfoEPP7NSError_block_invoke;
    v114[3] = &__block_descriptor_40_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE_e15_v32__0_8_16_B24l;
    v115 = v72;
    objc_msgSend(v113, "enumerateKeysAndObjectsUsingBlock:", v114);
    v73 = (void *)objc_opt_new();
    v117 = v71;
    objc_msgSend(v73, "setFunctionGraphs:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v117, 1));
    objc_msgSend(v73, "setFunctions:", v72);
    v126 = 0;
    v74 = objc_msgSend(v97, "newLibraryWithStitchedDescriptor:error:", v73, &v126);
    if (!v74)
    {
      if (v96)
      {
        v93 = v72;
        v94 = v71;
        v98 = v69;
        v112 = v64;
        v75 = objc_alloc_init(MEMORY[0x24BDD16A8]);
        v76 = (void *)objc_msgSend(v107, "returnType");
        v77 = v76;
        if (!v76)
          goto LABEL_69;
        if (v102 >= 3)
        {
          if (v102 == 3)
          {
            if (objc_msgSend(v76, "dataType") == 4)
            {
LABEL_69:
              v79 = (NSMutableString *)objc_msgSend(v107, "arguments");
              v80 = v79;
              if (!v79)
              {
LABEL_90:
                if (v126 && !objc_msgSend(v75, "length"))
                  objc_msgSend(v75, "appendString:", objc_msgSend(v126, "localizedDescription"));
                else
                  objc_msgSend(v75, "appendString:", CFSTR("unknown error"));
                v90 = (void *)objc_opt_new();
                v91 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Function stitching failed: %@.\n%@"), *(_QWORD *)(a1 + 24), v75);
                objc_msgSend(v90, "setObject:forKey:", v91, *MEMORY[0x24BDD0FC8]);
                if (v126)
                  objc_msgSend(v90, "setObject:forKey:", v126, *MEMORY[0x24BDD1398]);
                *v96 = objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 2, v90);

                v74 = 0;
                v64 = v112;
                v69 = v98;
                v72 = v93;
                v71 = v94;
                goto LABEL_97;
              }
              v92 = -[NSMutableString count](v79, "count");
              LODWORD(v125[0]) = 6;
              if (v102 == 4)
              {
                LODWORD(v125[0]) = 3;
                v83 = 2;
              }
              else
              {
                v83 = 1;
                if (v102 != 2)
                {
                  if (v102 == 1)
                  {
                    LODWORD(v125[0]) = 2;
                    v83 = 2;
                  }
                  goto LABEL_80;
                }
              }
              LODWORD(v125[0]) = 3;
LABEL_80:
              v85 = *(_QWORD *)(a7 + 48);
              if (*(_QWORD *)(a7 + 40))
                v86 = *(int **)(a7 + 40);
              else
                v86 = (int *)(a7 + 8);
              v87 = (NSArray *)v83;
              if (v85)
              {
                v88 = 4 * v85;
                v89 = (NSArray *)v83;
                do
                {
                  v87 = (NSArray *)((char *)&v89->super.isa + 1);
                  if ((~*v86 & 0xC0) == 0)
                  {
                    LODWORD(v125[0]) = 1;
                    v87 = (NSArray *)((char *)&v89->super.isa + 2);
                  }
                  ++v86;
                  v89 = v87;
                  v88 -= 4;
                }
                while (v88);
              }
              if ((unint64_t)v87 < v92)
                objc_msgSend(v75, "appendFormat:", CFSTR("Too few function arguments: expected %d, received %d.\n"), v92 - v83, *(_QWORD *)(a7 + 48));
              goto LABEL_90;
            }
            v78 = CFSTR("Expected float2 result, has %@.\n");
LABEL_68:
            objc_msgSend(v75, "appendFormat:", v78, objc_msgSend(v77, "description"));
            goto LABEL_69;
          }
          if (v102 != 4)
            goto LABEL_69;
        }
        if (objc_msgSend(v76, "dataType") == 19)
          goto LABEL_69;
        v78 = CFSTR("Expected half4 result, has %@.\n");
        goto LABEL_68;
      }
      v74 = 0;
    }
LABEL_97:
    *v99 = v74;

    v17 = v107;
    goto LABEL_98;
  }
  if (a8)
  {
    v39 = a8;
    v40 = (void *)MEMORY[0x24BDD1540];
    v123 = *MEMORY[0x24BDD0FC8];
    v124 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("Unknown Metal function: %@"), *(_QWORD *)(a1 + 24));
    *v39 = objc_msgSend(v40, "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 1, objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v124, &v123, 1));
  }
  *a9 = 0;
LABEL_98:

}

void sub_209B4F48C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, id a13, uint64_t a14, id a15, uint64_t a16, id a17, uint64_t a18, id a19, id a20,uint64_t a21,id a22,id a23,id a24,uint64_t a25,id a26,id a27,id a28,id a29,id a30,id a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,id a36,uint64_t a37)
{

  _Unwind_Resume(a1);
}

uint64_t RB::FunctionLibrary::prune_caches(RB::FunctionLibrary *this, int a2)
{
  int v3;

  v3 = a2;
  return RB::UntypedTable::remove_if ((uint64_t)this + 32, (BOOL (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::Function *>::remove_if<RB::FunctionLibrary::prune_caches::$_0>(RB::FunctionLibrary::prune_caches::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, &v3);
}

uint64_t RB::Function::Param::description(RB::Function::Param *this)
{
  int v1;
  const char *v2;
  const char *v3;

  v1 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 0x3Fu) > 8)
    v2 = "unknown";
  else
  if ((v1 & 0x40) != 0)
    v3 = " pointer";
  else
    v3 = "";
  return objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s%s"), v2, v3);
}

BOOL RB::FunctionLibrary::compile_shader(uint64_t a1, uint64_t *a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v5;
  int v9;
  uint64_t v10;
  NSObject *v11;
  _BOOL8 v12;
  _QWORD *v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t *v17;
  uint64_t v18;
  void *v19;
  NSObject *v20;
  _QWORD v22[9];
  int v23;
  unsigned int v24;
  _QWORD v25[2];
  void *v26;
  _QWORD block[10];
  int v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  char v32;
  uint64_t v33;
  uint64_t *v34;
  uint64_t v35;
  uint64_t (*v36)(uint64_t, uint64_t);
  void (*v37)(uint64_t);
  const char *v38;
  id v39;
  uint64_t v40;
  uint64_t *v41;
  uint64_t v42;
  uint64_t (*v43)(uint64_t, uint64_t);
  void (*v44)(uint64_t);
  const char *v45;
  id v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t (*v50)(uint64_t, uint64_t);
  void (*v51)(uint64_t);
  const char *v52;
  id v53;
  _QWORD v54[6];
  uint64_t v55;
  void *v56;
  uint64_t v57;
  uint64_t v58;
  __int128 v59;
  uint64_t v60;
  _QWORD v61[3];

  v61[1] = *MEMORY[0x24BDAC8D0];
  v5 = *a2;
  if (*a2)
  {
    v9 = a3 | (8 * *(_DWORD *)(v5 + 32));
    v47 = 0;
    v48 = &v47;
    v49 = 0x3812000000;
    v50 = __Block_byref_object_copy__2;
    v51 = __Block_byref_object_dispose__2;
    v53 = 0;
    v40 = 0;
    v41 = &v40;
    v42 = 0x3812000000;
    v43 = __Block_byref_object_copy__2;
    v44 = __Block_byref_object_dispose__2;
    v46 = 0;
    v33 = 0;
    v34 = &v33;
    v35 = 0x3812000000;
    v36 = __Block_byref_object_copy__15;
    v37 = __Block_byref_object_dispose__16;
    v39 = 0;
    v29 = 0;
    v30 = &v29;
    v31 = 0x2020000000;
    v32 = 0;
    v10 = MEMORY[0x24BDAC760];
    v11 = *(NSObject **)(a1 + 32);
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke;
    block[3] = &unk_24C22B130;
    block[8] = a1;
    block[9] = v5;
    block[4] = &v29;
    block[5] = &v47;
    v28 = v9;
    block[6] = &v40;
    block[7] = &v33;
    dispatch_sync(v11, block);
    if (v34[6])
    {
      v12 = 1;
    }
    else
    {
      v54[0] = 0;
      v54[1] = v54;
      v54[2] = 0x8012000000;
      v54[3] = __Block_byref_object_copy__18;
      v54[4] = __Block_byref_object_dispose__19;
      v54[5] = &unk_209BEAE19;
      v56 = 0;
      v57 = 0;
      v58 = 8;
      v59 = xmmword_209BD6D00;
      v13 = a2 + 1;
      v14 = a2[14];
      if (a2[13])
        v13 = (_QWORD *)a2[13];
      v25[0] = v13;
      v25[1] = v14;
      v15 = v26;
      if (v26)
      {
        v16 = (void *)objc_opt_new();
        objc_msgSend(v16, "setName:", CFSTR("custom_fn"));
        if (*((_BYTE *)v30 + 24))
          objc_msgSend(v16, "setOptions:", objc_msgSend(v16, "options") | 1);
        v17 = v34;
        v18 = objc_msgSend(v15, "newFunctionWithDescriptor:error:", v16, a4);

        v17[6] = v18;
        v19 = (void *)v34[6];
        v12 = v19 != 0;
        if (v19)
        {
          objc_msgSend(v19, "setLabel:", *(_QWORD *)(*a2 + 24));
          v20 = *(NSObject **)(a1 + 32);
          v22[0] = v10;
          v22[1] = 3221225472;
          v22[2] = ___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke_22;
          v22[3] = &unk_24C22B158;
          v22[7] = a1;
          v22[8] = v5;
          v23 = v9;
          v24 = a3;
          v22[4] = &v33;
          v22[5] = v54;
          v22[6] = &v29;
          dispatch_sync(v20, v22);
        }

      }
      else
      {
        v12 = 0;
      }

      _Block_object_dispose(v54, 8);
      if (v56)
        free(v56);
    }
    _Block_object_dispose(&v29, 8);
    _Block_object_dispose(&v33, 8);

    _Block_object_dispose(&v40, 8);
    _Block_object_dispose(&v47, 8);

  }
  else if (a4)
  {
    v60 = *MEMORY[0x24BDD0FC8];
    v61[0] = CFSTR("No function name");
    v12 = 0;
    *a4 = objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("com.apple.RenderBox.RBShaderError"), 1, objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v61, &v60, 1));
  }
  else
  {
    return 0;
  }
  return v12;
}

void sub_209B4FB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,char a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,id a44,char a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,id a51,char a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,id a58)
{
  void *v58;
  uint64_t v59;
  void *v61;

  _Block_object_dispose((const void *)(v59 - 256), 8);
  v61 = *(void **)(v59 - 168);
  if (v61)
    free(v61);
  _Block_object_dispose(&a34, 8);
  _Block_object_dispose(&a38, 8);

  _Block_object_dispose(&a45, 8);
  _Block_object_dispose(&a52, 8);

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__15(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__16(uint64_t a1)
{

}

__n128 __Block_byref_object_copy__18(uint64_t a1, uint64_t a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  __n128 result;

  v4 = *(_DWORD *)(a2 + 48);
  *(_QWORD *)(a1 + 88) = 0;
  *(_DWORD *)(a1 + 48) = v4;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 8;
  v5 = *(_QWORD *)(a2 + 96);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 88);
  *(_QWORD *)(a1 + 96) = v5;
  *(_QWORD *)(a2 + 88) = 0;
  *(_QWORD *)(a2 + 96) = 0;
  v6 = *(_QWORD *)(a1 + 104);
  *(_QWORD *)(a1 + 104) = *(_QWORD *)(a2 + 104);
  *(_QWORD *)(a2 + 104) = v6;
  RB::vector<RB::Rect,2ul,unsigned int>::swap_inline((__int128 *)(a1 + 56), (__int128 *)(a2 + 56));
  result = *(__n128 *)(a2 + 112);
  *(__n128 *)(a1 + 112) = result;
  return result;
}

void sub_209B4FDC8(_Unwind_Exception *exception_object)
{
  void **v1;

  if (*v1)
    free(*v1);
  _Unwind_Resume(exception_object);
}

void __Block_byref_object_dispose__19(uint64_t a1)
{
  void *v1;

  v1 = *(void **)(a1 + 88);
  if (v1)
    free(v1);
}

uint64_t ___ZN2RB15FunctionLibrary14compile_shaderERNS_6DeviceERKNS_12CustomShader7ClosureENS3_4TypeEPP7NSError_block_invoke_22(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;
  size_t **v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  char *v15;
  size_t v16;
  int *v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  int v23;
  size_t v24;

  result = (uint64_t)RB::Device::function_library(*(RB::Device **)(a1 + 56), *(RB::CustomShader::Library **)(*(_QWORD *)(a1 + 64) + 16));
  if (result)
  {
    v3 = result;
    v4 = (size_t **)(result + 32);
    result = (uint64_t)RB::UntypedTable::lookup((RB::UntypedTable *)(result + 32), (uint64_t *)*(unsigned int *)(a1 + 72), 0);
    if (result)
    {
      v5 = result;
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
      v7 = *(_QWORD *)(result + 8);
      *(_QWORD *)(result + 8) = *(_QWORD *)(v6 + 48);
      *(_QWORD *)(v6 + 48) = v7;
LABEL_15:
      *(_BYTE *)(v5 + 104) = *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 48) + 8) + 24);
      *(_BYTE *)(v3 + 112) = 1;
      *(_BYTE *)(v5 + 105) = 1;
      return result;
    }
    v5 = operator new();
    v8 = *(_DWORD *)(*(_QWORD *)(a1 + 64) + 32);
    v9 = *(_DWORD *)(a1 + 76);
    v10 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v11 = *(_QWORD *)(v10 + 48);
    *(_QWORD *)(v10 + 48) = 0;
    v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
    LODWORD(v10) = *(_DWORD *)(v12 + 48);
    v14 = *(_DWORD *)(v12 + 112);
    v13 = *(_DWORD *)(v12 + 116);
    *(_DWORD *)v5 = v8;
    *(_DWORD *)(v5 + 4) = v9;
    *(_QWORD *)(v5 + 8) = v11;
    *(_DWORD *)(v5 + 16) = v10;
    v15 = (char *)(v5 + 24);
    *(_QWORD *)(v5 + 56) = 0;
    *(_QWORD *)(v5 + 64) = 0;
    *(_QWORD *)(v5 + 72) = 8;
    v16 = *(_QWORD *)(v12 + 96);
    if (*(_QWORD *)(v12 + 88))
      v17 = *(int **)(v12 + 88);
    else
      v17 = (int *)(v12 + 56);
    if (v16 >= 9)
    {
      v24 = *(_QWORD *)(v12 + 96);
      RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(v15, v16);
      v18 = *(char **)(v5 + 56);
      v19 = *(_QWORD *)(v5 + 64);
      v16 = v24;
      v15 = (char *)(v5 + 24);
    }
    else
    {
      v18 = 0;
      v19 = 0;
      v20 = 0;
      if (!v16)
      {
LABEL_14:
        *(_QWORD *)(v5 + 64) = v20 + v16;
        *(_DWORD *)(v5 + 80) = v14;
        *(_DWORD *)(v5 + 84) = *(_DWORD *)(v12 + 120);
        *(_QWORD *)(v5 + 88) = *(unsigned int *)(v12 + 124);
        *(_DWORD *)(v5 + 96) = 0;
        *(_DWORD *)(v5 + 100) = v13;
        *(_WORD *)(v5 + 104) = 0;
        result = RB::UntypedTable::insert(v4, (size_t *)*(unsigned int *)(a1 + 72), (size_t *)v5);
        goto LABEL_15;
      }
    }
    if (!v18)
      v18 = v15;
    v21 = &v18[4 * v19];
    v22 = v16;
    do
    {
      v23 = *v17++;
      *(_DWORD *)v21 = v23;
      v21 += 4;
      --v22;
    }
    while (v22);
    v20 = *(_QWORD *)(v5 + 64);
    goto LABEL_14;
  }
  return result;
}

void sub_209B4FF9C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*v2)
    free(*v2);

  MEMORY[0x20BD16544](v1, 0x10A0C408BE17B63);
  _Unwind_Resume(a1);
}

uint64_t RB::FunctionLibrary::FunctionLibrary(RB::Device &,RB::CustomShader::Library const&)::$_0::__invoke(uint64_t result)
{
  uint64_t v1;
  void *v2;

  if (result)
  {
    v1 = result;
    v2 = *(void **)(result + 56);
    if (v2)
      free(v2);

    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::`anonymous namespace'::custom_function(void *a1, void *a2, void *a3)
{
  void *v6;
  uint64_t v7;
  const char *v8;

  if (!objc_msgSend(a3, "objectForKeyedSubscript:", a2))
  {
    v6 = (void *)objc_msgSend(a1, "newFunctionWithName:", a2);
    if (!v6)
    {
      v7 = objc_msgSend(a2, "UTF8String");
      RB::precondition_failure((RB *)"invalid custom function: %s", v8, v7);
    }
    objc_msgSend(a3, "setObject:forKeyedSubscript:", v6, a2);

  }
}

void sub_209B500BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::`anonymous namespace'::param_load_layer(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, uint64_t a4@<X3>, unsigned int a5@<W4>, uint64_t a6@<X5>, uint64_t *a7@<X8>)
{
  void *fn;
  void *v14;
  id v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  _QWORD v20[4];

  v20[3] = *MEMORY[0x24BDAC8D0];
  v14 = (void *)objc_opt_new();
  v15 = objc_alloc(MEMORY[0x24BDDD5C8]);
  v16 = v19;
  v20[0] = a4;
  v20[1] = v19;
  v20[2] = a6;
  v17 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v20, 3);
  v18 = objc_msgSend(v15, "initWithName:arguments:controlDependencies:", fn, v17, MEMORY[0x24BDBD1A8]);
  *a7 = v18;
  objc_msgSend(a2, "addObject:", v18);

}

void sub_209B501E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB12_GLOBAL__N_121make_stitched_libraryERKNS_12CustomShader8FunctionENS1_4TypeERKNSt3__14spanIKNS1_5ValueELm18446744073709551615EEEPU19objcproto9MTLDevice11objc_objectPU21objcproto10MTLLibrary11objc_objectSG_RNS0_12FunctionInfoEPP7NSError_block_invoke(uint64_t a1)
{
  return objc_msgSend(*(id *)(a1 + 32), "addObject:");
}

id __copy_helper_block_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c37_ZTSN2RB8objc_ptrIP14NSMutableArrayEE(uint64_t a1)
{

}

void *RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1);
  result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 4), __dst, 8uLL, (size_t *)__dst + 6, v3);
  *((_QWORD *)__dst + 4) = result;
  return result;
}

void RB::`anonymous namespace'::constant_node(void *a1@<X0>, void *a2@<X1>, void *a3@<X2>, unsigned int a4@<W3>, uint64_t *a5@<X8>)
{
  unsigned __int8 v8;
  _BYTE *v9;
  size_t v10;
  size_t v11;
  _BYTE *v12;
  BOOL v13;
  uint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  _BYTE *v19;
  uint64_t v20;
  id v21;
  void *v22;
  id v23;
  uint64_t v24;
  _QWORD v27[2];
  _BYTE __dst[32];
  void *v29;
  size_t v30;
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if ((v8 & 1) == 0
  {
  }
  v29 = 0;
  v30 = 0;
  v31 = 8;
  if (!a4)
  {
    v15 = 0;
    v9 = 0;
LABEL_16:
    if (!v9)
      v9 = __dst;
    *(_DWORD *)&v9[4 * v15] = 0;
    v14 = v15 + 1;
    v30 = v15 + 1;
LABEL_20:
    *a5 = 0;
    if (!v14)
      goto LABEL_28;
    goto LABEL_21;
  }
  v9 = 0;
  v10 = 0;
  do
  {
    v11 = v10 + 1;
    if (v31 < v10 + 1)
    {
      RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(__dst, v11);
      v9 = v29;
      v10 = v30;
      v11 = v30 + 1;
    }
    if (v9)
      v12 = v9;
    else
      v12 = __dst;
    *(_DWORD *)&v12[4 * v10] = a4 & 7;
    v30 = v11;
    v10 = v11;
    v13 = a4 >= 8;
    a4 >>= 3;
  }
  while (v13);
  if (!v11)
  {
    if (v31)
    {
      v15 = 0;
    }
    else
    {
      RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(__dst, 1uLL);
      v9 = v29;
      v15 = v30;
    }
    goto LABEL_16;
  }
  if (v11 != 1)
  {
    v14 = v30;
    goto LABEL_20;
  }
  *a5 = 0;
  v14 = 1;
LABEL_21:
  v16 = 0;
  v17 = v14 - 1;
  v18 = MEMORY[0x24BDBD1A8];
  do
  {
    v19 = v29;
    if (!v29)
      v19 = __dst;
    v20 = *(unsigned int *)&v19[4 * v17];
    v21 = objc_alloc(MEMORY[0x24BDDD5C8]);
    objc_msgSend(a2, "addObject:", v22);
    if (v16)
    {
      v23 = objc_alloc(MEMORY[0x24BDDD5C8]);
      v27[0] = v16;
      v27[1] = v22;
      v24 = objc_msgSend(v23, "initWithName:arguments:controlDependencies:", CFSTR("__RB::Cx"), objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v27, 2), v18);

      *a5 = v24;
      objc_msgSend(a2, "addObject:", v24);
      v16 = (void *)v24;
    }
    else
    {

      *a5 = (uint64_t)v22;
      v16 = v22;
      v22 = 0;
    }

    --v17;
  }
  while (v17 != -1);
LABEL_28:
  if (v29)
    free(v29);
}

void sub_209B505D4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

void *RB::`anonymous namespace'::param_load_fn(void *a1, void *a2, unsigned int a3)
{
  unsigned __int8 v5;
  void *v6;
  int v8;
  unsigned int v9;

  if ((v5 & 1) == 0)
  {
    v9 = a3;
    a3 = v9;
    if (v8)
    {
      a3 = v9;
    }
  }
  return v6;
}

void sub_209B5072C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::`anonymous namespace'::diagnose_parameter_error(RB::_anonymous_namespace_ *this, NSMutableString *a2, NSArray *a3, int *a4, const RB::Function::Param *a5)
{
  void *v9;
  void *v10;
  RB::_anonymous_namespace_ *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  int v26;
  const char *v27;
  int v28;
  const char *v29;
  const char *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  const char *v42;
  uint64_t v43;
  const char *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  const char *v51;
  char v52;
  _QWORD v53[2];
  RB::_anonymous_namespace_ *v54;

  v54 = this;
  if (-[NSMutableString count](a2, "count", a3, a4, a5) <= (unint64_t)a3)
  {
    v28 = *a4;
    if ((*a4 & 0x3Fu) > 8)
      v29 = "unknown";
    else
    if ((v28 & 0x40) != 0)
      v30 = " pointer";
    else
      v30 = "";
    -[RB::_anonymous_namespace_ appendFormat:](this, "appendFormat:", CFSTR("Missing parameter at index %d: %@.\n"), a3, objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("%s%s"), v29, v30));
  }
  else
  {
    v9 = (void *)objc_msgSend((id)-[NSMutableString objectAtIndexedSubscript:](a2, "objectAtIndexedSubscript:", a3), "dataTypeDescription");
    if (!v9)
      return;
    v10 = v9;
    v11 = (RB::_anonymous_namespace_ *)objc_msgSend(v9, "dataType");
    v53[0] = &v54;
    v53[1] = a3;
    if (v11 == (RB::_anonymous_namespace_ *)1)
    {
      if ((*(_BYTE *)a4 & 0x40) != 0)
      v31 = (void *)objc_msgSend(v10, "members");
      if (objc_msgSend(v31, "count") != 2
        || (v38 = (void *)objc_msgSend(v31, "objectAtIndexedSubscript:", 0),
            v39 = (void *)objc_msgSend(v31, "objectAtIndexedSubscript:", 1),
            objc_msgSend(v38, "dataType") != 58)
        || objc_msgSend(v39, "dataType") != 2
        || (v40 = (void *)objc_msgSend(v38, "textureReferenceType"),
            v41 = (void *)objc_msgSend(v39, "arrayType"),
            objc_msgSend(v40, "textureDataType") != 16)
        || objc_msgSend(v40, "textureType") != 2
        || objc_msgSend(v40, "access")
        || (objc_msgSend(v40, "isDepthTexture") & 1) != 0
        || objc_msgSend(v41, "elementType") != 137
        || objc_msgSend(v41, "arrayLength") != 5
        || (*a4 & 0x3F) == 3)
      {
        v42 = "unsupported struct type";
LABEL_44:
        return;
      }
      if ((*a4 & 0x3Fu) > 8)
        v51 = "unknown";
      else
    }
    else
    {
      v18 = (char)v11;
      if (v11 == (RB::_anonymous_namespace_ *)60)
      {
        if ((*(_BYTE *)a4 & 0x40) == 0)
        if ((v19 & 0xFF00000000) != 0)
        {
          v26 = v19;
          if ((*a4 & 0x3F) != (_DWORD)v19)
          {
            if (v19 > 8)
              v27 = "unknown";
            else
          }
          if (objc_msgSend(v10, "alignment") > (unint64_t)RB::Function::Param::alignment_values[v26])
          if (objc_msgSend(v10, "access"))
          {
            v42 = "pointer access must be read-only";
            goto LABEL_44;
          }
        }
      }
      else
      {
        if ((v43 & 0xFF00000000) == 0)
        {
          return;
        }
        if ((*a4 & 0x3F) != (_DWORD)v43)
        {
          if (v43 > 8)
            v44 = "unknown";
          else
          v52 = (char)v44;
          v42 = "invalid type, %s, expected %s";
          goto LABEL_44;
        }
      }
    }
  }
}

void RB::`anonymous namespace'::diagnose_parameter_error(NSMutableString *,NSArray *,unsigned long,RB::Function::Param const&)::$_0::operator()(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v10[2];

  v10[0] = 0;
  v10[1] = &a9;
  vasprintf(v10, a2, &a9);
  if (v10[0])
  {
    objc_msgSend(**(id **)a1, "appendFormat:", CFSTR("Parameter at index %d: %s.\n"), *(_QWORD *)(a1 + 8), v10[0]);
    free(v10[0]);
  }
}

uint64_t RB::`anonymous namespace'::param_type(RB::_anonymous_namespace_ *this, MTLDataType a2)
{
  uint64_t v2;
  uint64_t v3;

  if ((uint64_t)this <= 18)
  {
    switch((unint64_t)this)
    {
      case 3uLL:
        v2 = 0x100000000;
        v3 = 5;
        break;
      case 4uLL:
        v2 = 0x100000000;
        v3 = 6;
        break;
      case 5uLL:
        v2 = 0x100000000;
        v3 = 7;
        break;
      case 6uLL:
        v2 = 0x100000000;
        v3 = 8;
        break;
      default:
        goto LABEL_18;
    }
    return v3 | v2;
  }
  if ((uint64_t)this <= 57)
  {
    if (this == (RB::_anonymous_namespace_ *)19)
    {
      v2 = 0x100000000;
      v3 = 2;
      return v3 | v2;
    }
    if (this == (RB::_anonymous_namespace_ *)29)
    {
      v2 = 0x100000000;
      v3 = 1;
      return v3 | v2;
    }
LABEL_18:
    v2 = 0;
    v3 = 0;
    return v3 | v2;
  }
  if (this == (RB::_anonymous_namespace_ *)58)
  {
    v2 = 0x100000000;
    v3 = 4;
    return v3 | v2;
  }
  if (this != (RB::_anonymous_namespace_ *)61)
    goto LABEL_18;
  v3 = 0;
  v2 = 0x100000000;
  if (!(_DWORD)a2)
    v2 = 0;
  return v3 | v2;
}

BOOL RB::Table<unsigned long,RB::Function *>::remove_if<RB::FunctionLibrary::prune_caches(unsigned int)::$_0>(RB::FunctionLibrary::prune_caches(unsigned int)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  return a2 && !*(_BYTE *)(a2 + 105) && *(_DWORD *)(a2 + 96) <= *a3;
}

float RB::Coverage::Path::min_scale(RB::Coverage::Path *this, const RB::AffineTransform *a2)
{
  float result;

  result = 0.0;
  if (*((_BYTE *)this + 29) == 1)
    return 1.0;
  return result;
}

uint64_t RB::Coverage::Path::can_mix(float64x2_t **this, const RB::DisplayList::Interpolator::Op *a2, float64x2_t **a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  unsigned int CanMix;
  uint64_t result;

  if (*((unsigned __int8 *)this + 28) != *((unsigned __int8 *)a3 + 28)
    || *((unsigned __int8 *)this + 29) != *((unsigned __int8 *)a3 + 29))
  {
    return 0;
  }
  can_mix = RB::can_mix(this[2], a3[2], (const RB::AffineTransform *)a3);
  if (can_mix)
  {
    v6 = can_mix;
    CanMix = RBPathCanMix(*(RBPath *)this, *(RBPath *)a3);
    if (CanMix >= v6)
      result = v6;
    else
      result = CanMix;
  }
  else
  {
    result = 0;
  }
  if (*((float *)this + 6) != *((float *)a3 + 6))
  {
    if (result >= 2)
      return 2;
    else
      return result;
  }
  return result;
}

float RB::Coverage::Path::mix(RBPath *this, const RB::DisplayList::Interpolator::State *a2, RBPath *a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, RB::Heap *a7)
{
  float64x2_t *info;
  const RB::AffineTransform ***v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t *v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  const RB::AffineTransform **v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  uint64_t v29;
  uint64_t callbacks;
  float result;
  RBPath v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;

  v14 = (const RB::AffineTransform ***)&this[1];
  info = (float64x2_t *)this[1].info;
  if (info)
  {
    v15.f64[0] = RB::operator*(a4, info);
    v39 = v15;
    v40 = v16;
    v41 = v17;
  }
  else
  {
    v18 = a4[1];
    v39 = *a4;
    v40 = v18;
    v41 = a4[2];
  }
  v19 = (float64x2_t *)a3[1].info;
  if (v19)
  {
    v20.f64[0] = RB::operator*(a5, v19);
    v36 = v20;
    v37 = v21;
    v38 = v22;
    v23 = (const RB::AffineTransform **)a3[1].info;
  }
  else
  {
    v23 = 0;
    v24 = a5[1];
    v36 = *a5;
    v37 = v24;
    v20 = a5[2];
    v38 = v20;
  }
  LODWORD(v20.f64[0]) = *((_DWORD *)a2 + 4);
  RB::mix(a7, v14, v23, (const RB::AffineTransform *)a4, v20.f64[0]);
  if (*v14)
  {
    v25.f64[0] = RB::operator*(a6, (float64x2_t *)*v14);
    v33 = v25;
    v34 = v26;
    v35 = v27;
  }
  else
  {
    v28 = a6[1];
    v33 = *a6;
    v34 = v28;
    v35 = a6[2];
  }
  RBPathMix(*this, *a3, *((float *)a2 + 4), &v39, &v36, &v33, (uint64_t *)&v32);
  v29 = (uint64_t)this->info;
  callbacks = (uint64_t)this->callbacks;
  *this = v32;
  v32.info = (void *)v29;
  v32.callbacks = (RBPathCallbacks *)callbacks;
  RBPathRelease(v29, callbacks);
  result = *(float *)&this[1].callbacks
         + (float)((float)(*(float *)&a3[1].callbacks - *(float *)&this[1].callbacks) * *((float *)a2 + 4));
  *(float *)&this[1].callbacks = result;
  return result;
}

void RB::Coverage::Path::clip(RB::Coverage::Path *this, CGContextRef *a2)
{
  float64x2_t v4;
  float64x2_t *v5;
  float64x2_t v6;
  float64x2_t v7;
  int64x2_t v8;
  unint64_t v9;
  CGContext *v10;
  int v11;
  const CGPath *v12;
  const CGPath *v13;
  CGContext *v14;
  CGAffineTransform v15;
  CGAffineTransform v16;
  CGAffineTransform transform;

  v4 = 0uLL;
  memset(&v16, 0, sizeof(v16));
  v5 = (float64x2_t *)*((_QWORD *)this + 2);
  v6 = (float64x2_t)xmmword_209BD52A0;
  v7 = (float64x2_t)xmmword_209BD5290;
  if (v5)
  {
    v7 = *v5;
    v6 = v5[1];
    v4 = v5[2];
  }
  v8 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqzq_f64(v4)), (int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_209BD5290));
  v9 = vandq_s8((int8x16_t)vdupq_laneq_s64(v8, 1), (int8x16_t)v8).u64[0];
  if ((v9 & 0x8000000000000000) == 0)
  {
    *(float64x2_t *)&v15.c = v6;
    *(float64x2_t *)&v15.tx = v4;
    *(float64x2_t *)&v15.a = v7;
    CGContextGetCTM(&v16, *a2);
    v10 = *a2;
    transform = v15;
    CGContextConcatCTM(v10, &transform);
  }
  v11 = rb_clip_mode(*((unsigned __int8 *)this + 29));
  if (*((unsigned __int8 *)a2 + 140) != v11)
    RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v11);
  CGContextBeginPath(*a2);
  v12 = RBPathCopyCGPath(*(const CGPath **)this, *((_QWORD *)this + 1));
  if (v12)
  {
    v13 = v12;
    CGContextAddPath(*a2, v12);
    CFRelease(v13);
  }
  v14 = *a2;
  if (*((_BYTE *)this + 28))
  {
    CGContextEOClip(v14);
    if ((v9 & 0x8000000000000000) != 0)
      return;
  }
  else
  {
    CGContextClip(v14);
    if ((v9 & 0x8000000000000000) != 0)
      return;
  }
  transform = v16;
  CGContextSetCTM();
}

void sub_209B50F5C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

_QWORD *RB::Coverage::Path::encode(RBPath *this, RB::Encoder *a2)
{
  float64x2_t *info;
  int64x2_t v5;
  unint64_t v6;
  _QWORD *result;
  int callbacks;

  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RBPathEncode(*this, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  info = (float64x2_t *)this[1].info;
  if (info)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(info[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*info, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(info[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(info->f64, a2);
      RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  if (BYTE4(this[1].callbacks) == 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  v6 = BYTE5(this[1].callbacks);
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  result = RB::ProtobufEncoder::encode_varint(a2, v6);
  callbacks = (int)this[1].callbacks;
  if (*(float *)&callbacks != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, callbacks);
  }
  return result;
}

unint64_t RB::Coverage::Path::decode(RB::Coverage::Path *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  __int128 v10;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RBPathDecode(a2, (uint64_t *)&v10);
            v6 = *(_QWORD *)this;
            v7 = *((_QWORD *)this + 1);
            *(_OWORD *)this = v10;
            *(_QWORD *)&v10 = v6;
            *((_QWORD *)&v10 + 1) = v7;
            RBPathRelease(v6, v7);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          break;
        case 2u:
          RB::Decoder::affine_transform_field((size_t **)a2, v5);
          *((_QWORD *)this + 2) = v8;
          break;
        case 3u:
          *((_BYTE *)this + 28) = RB::ProtobufDecoder::BOOL_field(a2, v5);
          break;
        case 4u:
          v9 = RB::ProtobufDecoder::uint_field(a2, v5);
          if (v9 <= 3)
            *((_BYTE *)this + 29) = v9;
          break;
        case 5u:
          *((float *)this + 6) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

_QWORD *RB::Coverage::Path::attributes(RB::Coverage::Path *this, RB::XML::Element *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  void (**v12)(RB::XML::Value::Path *__hidden);
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v4 = *(_QWORD *)this;
  v5 = *((_QWORD *)this + 1);
  v12 = &off_24C229060;
  *(_QWORD *)&v13 = RBPathRetain(v4, v5);
  *((_QWORD *)&v13 + 1) = v6;
  RB::XML::Element::set<RB::XML::Value::Path>(a2, (uint64_t)"path", (uint64_t)&v12);
  v12 = &off_24C229060;
  RBPathRelease(v13, *((uint64_t *)&v13 + 1));
  v7 = (__int128 *)*((_QWORD *)this + 2);
  if (v7)
  {
    v8 = *v7;
    v9 = v7[1];
    v10 = v7[2];
    v12 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229330;
    v13 = v8;
    v14 = v9;
    v15 = v10;
    RB::XML::Element::set<RB::XML::Value::Transform>(a2, (uint64_t)"transform", (uint64_t)&v12);
  }
  if (*((_BYTE *)this + 28) == 1)
  {
    v12 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229010;
    LOBYTE(v13) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"eo-fill", (uint64_t)&v12);
  }
  return RB::XML::Element::set_rendering_mode(a2, *((unsigned __int8 *)this + 29), *((float *)this + 6));
}

void sub_209B512BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  RBPathRelease(a11, a12);
  _Unwind_Resume(a1);
}

uint64_t *RB::DisplayList::Contents::prepare_encode(RB::DisplayList::Contents *this, RB::Encoder *a2)
{
  return RB::DisplayList::Layer::prepare_encode((uint64_t *)this + 40, a2);
}

uint64_t *RB::DisplayList::Layer::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t *v3;
  _QWORD *v4;
  RB::DisplayList::LayerFilter *i;

  v3 = this;
  v4 = (_QWORD *)*this;
  if (*this)
  {
    do
    {
      this = (uint64_t *)(*(uint64_t (**)(_QWORD *, RB::Encoder *))(*v4 + 240))(v4, a2);
      v4 = (_QWORD *)v4[1];
    }
    while (v4);
  }
  for (i = (RB::DisplayList::LayerFilter *)v3[2]; i; i = (RB::DisplayList::LayerFilter *)*((_QWORD *)i + 1))
    this = RB::DisplayList::LayerFilter::prepare_encode(i, a2);
  return this;
}

void RB::DisplayList::Contents::encode(RB::DisplayList::Contents *this, void (****a2)(CFDataRef *__return_ptr))
{
  uint64_t *v4;
  void (***v5)(CFDataRef *__return_ptr);
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef theData;

  v4 = RB::Encoder::local_namespace(this);
  RB::ProtobufEncoder::uuid_field((RB::ProtobufEncoder *)a2, 4, (const UUID *)v4);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Layer::encode((_QWORD **)this + 40, (RB::Encoder *)a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  v5 = a2[7];
  if (v5)
  {
    (**v5)(&theData);
    if (theData)
    {
      BytePtr = CFDataGetBytePtr(theData);
      Length = CFDataGetLength(theData);
      if (Length)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
        RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)a2, BytePtr, Length);
      }
      if (theData)
        CFRelease(theData);
    }
  }
  if (!*((_BYTE *)this + 400))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
}

void sub_209B51430(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

unint64_t RB::DisplayList::Contents::decode(RB::DisplayList::Contents *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  void (***v6)(_QWORD, uint64_t, uint64_t);
  uint64_t v7;
  uint64_t v8;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::DisplayList::Layer::decode((RB::DisplayList::Contents *)((char *)this + 320), (RB::Heap **)a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          break;
        case 2u:
          goto LABEL_10;
        case 3u:
          v6 = (void (***)(_QWORD, uint64_t, uint64_t))*((_QWORD *)a2 + 9);
          if (!v6)
            goto LABEL_10;
          v7 = RB::ProtobufDecoder::data_field(a2, v5);
          (**v6)(v6, v7, v8);
          break;
        case 4u:
          RB::ProtobufDecoder::uuid_field(a2, v5, (_OWORD *)a2 + 13);
          break;
        case 5u:
          *((_BYTE *)this + 400) = RB::ProtobufDecoder::uint_field(a2, v5) == 0;
          break;
        default:
          if ((v5 >> 3) == 15)
            RB::Decoder::push_shared((char *)a2, v5);
          else
LABEL_10:
            RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t *RB::DisplayList::LayerFilter::prepare_encode(RB::DisplayList::LayerFilter *this, RB::Encoder *a2)
{
  uint64_t *result;
  RB::Filter::Custom *v4;

  result = (uint64_t *)(*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(_QWORD *)this + 40))(this);
  if ((_DWORD)result == 4)
    return RB::Filter::Custom::prepare_encode(v4, a2);
  if ((_DWORD)result == 5)
    return (uint64_t *)RB::Filter::GaussianBlur::prepare_encode((uint64_t)v4);
  return result;
}

_QWORD **RB::DisplayList::Layer::encode(_QWORD **this, RB::Encoder *a2)
{
  _QWORD **v3;
  _QWORD *i;
  RB::DisplayList::LayerFilter *j;
  int v6;
  _QWORD *v7;
  int v8;
  _QWORD *v9;
  int v10;
  int v11;

  v3 = this;
  for (i = *this; i; i = (_QWORD *)i[1])
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(_QWORD *, RB::Encoder *))(*i + 248))(i, a2);
    this = (_QWORD **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  for (j = (RB::DisplayList::LayerFilter *)v3[2]; j; j = (RB::DisplayList::LayerFilter *)*((_QWORD *)j + 1))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::LayerFilter::encode(j, a2);
    this = (_QWORD **)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  if (*((_BYTE *)v3 + 64))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    v6 = *((unsigned __int8 *)v3 + 64);
    if (v6 == 2)
    {
      v8 = (*(uint64_t (**)(_QWORD *))(*v3[3] + 152))(v3[3]);
      v9 = v3[3];
      RB::ProtobufEncoder::encode_varint(a2, (8 * v8) | 2);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      (*(void (**)(_QWORD *, RB::Encoder *))(*v9 + 168))(v9, a2);
    }
    else
    {
      if (v6 != 1)
      {
LABEL_11:
        this = (_QWORD **)RB::ProtobufEncoder::end_length_delimited(a2);
        goto LABEL_12;
      }
      v7 = v3[3];
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::ProjectionMatrix::encode(v7, a2);
    }
    RB::ProtobufEncoder::end_length_delimited(a2);
    goto LABEL_11;
  }
LABEL_12:
  v10 = *((int *)v3 + 12);
  if (*(float *)&v10 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    this = (_QWORD **)RB::ProtobufEncoder::encode_fixed32(a2, v10);
  }
  v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v11 = *((_DWORD *)v3 + 15);
    if ((v11 & 2) == 0)
    {
LABEL_16:
      if ((v11 & 4) == 0)
        goto LABEL_17;
      goto LABEL_24;
    }
  }
  else if ((v11 & 2) == 0)
  {
    goto LABEL_16;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
  this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 4) == 0)
  {
LABEL_17:
    if ((v11 & 8) == 0)
      goto LABEL_18;
    goto LABEL_25;
  }
LABEL_24:
  RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
  this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 8) == 0)
  {
LABEL_18:
    if ((v11 & 0x40) == 0)
      goto LABEL_19;
    goto LABEL_26;
  }
LABEL_25:
  RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
  this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 0x40) == 0)
  {
LABEL_19:
    if ((v11 & 0x200) == 0)
      goto LABEL_20;
    goto LABEL_27;
  }
LABEL_26:
  RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
  this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v11 = *((_DWORD *)v3 + 15);
  if ((v11 & 0x200) == 0)
  {
LABEL_20:
    if ((v11 & 0x800) == 0)
      return this;
LABEL_28:
    RB::ProtobufEncoder::encode_varint(a2, 0x58uLL);
    return (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
LABEL_27:
  RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
  this = (_QWORD **)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*((_DWORD *)v3 + 15) & 0x800) != 0)
    goto LABEL_28;
  return this;
}

unint64_t RB::DisplayList::Layer::decode(RB::DisplayList::Layer *this, RB::Heap **a2)
{
  unint64_t result;
  unint64_t v5;
  RB::Decoder *v6;
  RB::DisplayList::Item *v7;
  RB::Decoder *v8;
  _QWORD *v9;
  uint64_t field;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  RB::Heap *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  BOOL v23;

  result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) != 2)
            goto LABEL_56;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          v7 = (RB::DisplayList::Item *)RB::DisplayList::Item::decode((size_t **)a2, v6);
          if (v7)
            RB::DisplayList::Layer::append_item(this, v7);
          goto LABEL_36;
        case 2u:
          if ((v5 & 7) != 2)
            goto LABEL_56;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          v9 = (_QWORD *)RB::DisplayList::LayerFilter::decode(a2, v8);
          if (v9)
            RB::DisplayList::Layer::append_filter((uint64_t)this, v9);
          goto LABEL_36;
        case 3u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
            if (field)
            {
              v11 = field;
              do
              {
                switch((v11 >> 3))
                {
                  case 1u:
                    RB::Heap::emplace<RB::ProjectionMatrix>(a2[8]);
                    v13 = v12;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::ProjectionMatrix::decode(v13, (RB::ProtobufDecoder *)a2);
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
                      *((_BYTE *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((_BYTE *)this + 64) = 1;
                    goto LABEL_24;
                  case 2u:
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(a2[8]);
                    v13 = v14;
                    if ((v11 & 7) != 2)
                      goto LABEL_33;
                    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                    RB::AlphaThresholdEffect::decode((float *)(v13 + 16), (RB::ProtobufDecoder *)a2);
                    goto LABEL_22;
                  case 3u:
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(a2[8]);
                    v13 = v15;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::AlphaGradientEffect::decode((RB::AlphaGradientEffect *)(v13 + 16), (RB::Decoder *)a2);
LABEL_22:
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
LABEL_33:
                      *((_BYTE *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((_BYTE *)this + 64) = 2;
LABEL_24:
                    *((_QWORD *)this + 3) = v13;
                    break;
                  case 4u:
                    v16 = a2[9];
                    if (!v16)
                      goto LABEL_30;
                    v17 = (*(uint64_t (**)(RB::Heap *))(*(_QWORD *)v16 + 32))(v16);
                    if (!v17)
                      goto LABEL_30;
                    v18 = v17;
                    RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>>(a2[8]);
                    v20 = v19;
                    if ((v11 & 7) == 2)
                    {
                      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
                      RB::CustomEffect::decode((RB::DisplayList::Layer **)(v20 + 16), (size_t **)a2);
                      RB::ProtobufDecoder::end_message((uint64_t)a2);
                    }
                    else
                    {
                      *((_BYTE *)a2 + 56) = 1;
                      *a2 = a2[1];
                    }
                    *((_BYTE *)this + 64) = 2;
                    *((_QWORD *)this + 3) = v20;
                    *(_QWORD *)(v20 + 8) = *(_QWORD *)(v18 + 312);
                    *(_QWORD *)(v18 + 312) = v20;
                    break;
                  default:
LABEL_30:
                    RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v11);
                    break;
                }
                v11 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
              }
              while (v11);
            }
LABEL_36:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_56:
            *((_BYTE *)a2 + 56) = 1;
            *a2 = a2[1];
          }
          break;
        case 4u:
          *((float *)this + 12) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v5);
          break;
        case 5u:
          v21 = *((_DWORD *)this + 15) | RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5);
          goto LABEL_50;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5))
            v22 = 2;
          else
            v22 = 0;
          goto LABEL_49;
        case 7u:
          v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          v22 = 4;
          goto LABEL_46;
        case 8u:
          v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          v22 = 8;
          goto LABEL_46;
        case 9u:
          v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          v22 = 64;
          goto LABEL_46;
        case 0xAu:
          v23 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5) == 0;
          v22 = 512;
LABEL_46:
          if (v23)
            v22 = 0;
          goto LABEL_49;
        case 0xBu:
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v5))
            v22 = 2048;
          else
            v22 = 0;
LABEL_49:
          v21 = *((_DWORD *)this + 15) | v22;
LABEL_50:
          *((_DWORD *)this + 15) = v21;
          break;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

uint64_t *RB::DisplayList::Item::prepare_encode(uint64_t *this, RB::Encoder *a2)
{
  uint64_t v3;
  _QWORD *v4;
  unint64_t v5;
  _QWORD *v6;
  uint64_t *v7;
  size_t *v8;
  void *v9;

  v3 = (uint64_t)this;
  v4 = (_QWORD *)this[3];
  if (v4)
  {
    do
    {
      v5 = v4[1] & 0xFFFFFFFFFFFFFFFELL;
      if (v5)
        (*(void (**)(unint64_t, RB::Encoder *))(*(_QWORD *)v5 + 112))(v5, a2);
      v4 = (_QWORD *)*v4;
    }
    while (v4);
    v9 = *(void **)(v3 + 24);
    this = RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>((uint64_t *)a2, 4, (uint64_t *)v9, (_QWORD **)&v9);
  }
  v6 = *(_QWORD **)(v3 + 16);
  if (v6)
  {
    do
    {
      this = (uint64_t *)(*(uint64_t (**)(_QWORD *, RB::Encoder *))(*v6 + 96))(v6, a2);
      v6 = (_QWORD *)v6[4];
    }
    while (v6);
    if ((*((_BYTE *)a2 + 164) & 1) == 0)
    {
      v7 = *(uint64_t **)(v3 + 16);
      v9 = 0;
      this = RB::UntypedTable::lookup((RB::Encoder *)((char *)a2 + 80), v7, &v9);
      if (v9 != v7)
      {
        v8 = (size_t *)*((_QWORD *)a2 + 9);
        *((_QWORD *)a2 + 9) = (char *)v8 + 1;
        RB::UntypedTable::insert((size_t **)a2 + 10, (size_t *)v7, v8);
        RB::ProtobufEncoder::encode_varint(a2, 0x7AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        if (v8)
        {
          RB::ProtobufEncoder::encode_varint(a2, 8uLL);
          RB::ProtobufEncoder::encode_varint(a2, (unint64_t)v8);
        }
        RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        for (; v7; v7 = (uint64_t *)v7[4])
        {
          RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
          RB::ProtobufEncoder::begin_length_delimited(a2);
          (*(void (**)(uint64_t *, RB::Encoder *))(*v7 + 104))(v7, a2);
          RB::ProtobufEncoder::end_length_delimited(a2);
        }
        RB::ProtobufEncoder::end_length_delimited(a2);
        return RB::ProtobufEncoder::end_length_delimited(a2);
      }
    }
  }
  return this;
}

unint64_t RB::DisplayList::ClipNode::prepare_encode(unint64_t result, uint64_t a2)
{
  _QWORD *v3;

  if (result)
  {
    v3 = (_QWORD *)result;
    do
    {
      result = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      if (result)
        result = (*(uint64_t (**)(unint64_t, uint64_t))(*(_QWORD *)result + 112))(result, a2);
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  return result;
}

_QWORD *RB::DisplayList::Item::encode(RB::DisplayList::Item *this, RB::Encoder *a2)
{
  _QWORD *result;
  int v11;
  uint64_t *v12;
  uint64_t *v13;

  _H0 = *((_WORD *)this + 22);
  __asm { FCVT            S8, H0 }
  if (*(float *)&_S8 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, _S8);
  }
  result = (_QWORD *)rb_blend_mode(*((_WORD *)this + 23) & 0x3F);
  if ((_DWORD)result)
  {
    v11 = (int)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, v11);
  }
  v12 = (uint64_t *)*((_QWORD *)this + 3);
  if (v12)
    result = RB::Encoder::shared_field_f(a2, 6, v12);
  if (*((_QWORD *)this + 4) || *((_DWORD *)this + 10))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, *((RB::Encoder **)this + 4), (const RB::DisplayList::Metadata *)*((unsigned int *)this + 10), 0);
    result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v13 = (uint64_t *)*((_QWORD *)this + 2);
  if (v13)
    return RB::Encoder::shared_field_f(a2, 8, v13);
  return result;
}

uint64_t RB::DisplayList::Item::decode(size_t **this, RB::Decoder *a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  RB::UntypedTable *v6;
  char v8;
  void (***v9)(_QWORD);
  unint64_t field;
  uint64_t v11;
  __int128 *v12;
  double v13;
  double v14;
  int8x16_t v15;
  int32x4_t v16;
  unint64_t v17;
  unint64_t v18;
  __int128 *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  size_t *v23;
  RB::Decoder *v24;
  unsigned int *v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  __int128 v29;
  RB::Decoder *v30;
  __int128 v37;
  _QWORD v38[3];
  __int16 v39;
  RBFillData *v40;
  uint64_t v41;
  char v42;
  uint64_t v43;
  _BYTE v44[12];
  RBFillData v45;
  RBShapeData v46;
  uint64_t v47;

  v3 = 0;
  v4 = 0;
  v5 = 0;
  v47 = *MEMORY[0x24BDAC8D0];
  v6 = (RB::UntypedTable *)(this + 10);
  memset(v44, 0, sizeof(v44));
  _S8 = 1.0;
  v8 = 2;
  while (1)
  {
    v9 = (void (***)(_QWORD))v3;
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    v11 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v12 = RB::AffineTransform::identity((RB::AffineTransform *)field);
        v46.type = 0;
        v45.type = 0;
        if ((v11 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          v17 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          if (!v17)
          {
LABEL_52:
            RB::ProtobufDecoder::end_message((uint64_t)this);
            goto LABEL_53;
          }
          while (2)
          {
            v18 = v17 >> 3;
            if ((v17 >> 3) == 3)
            {
              RB::Decoder::affine_transform_field(this, v17);
              v12 = v19;
            }
            else if ((_DWORD)v18 == 2)
            {
              if ((v17 & 7) != 2)
                goto LABEL_18;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RBFillData::decode(&v45, (RB::Heap **)this);
LABEL_14:
              RB::ProtobufDecoder::end_message((uint64_t)this);
            }
            else if ((_DWORD)v18 == 1)
            {
              if ((v17 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RBShapeData::decode(&v46, (RB::Decoder *)this);
                goto LABEL_14;
              }
LABEL_18:
              *((_BYTE *)this + 56) = 1;
              *this = this[1];
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v17);
            }
            v17 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
            if (!v17)
              goto LABEL_52;
            continue;
          }
        }
        *((_BYTE *)this + 56) = 1;
        *this = this[1];
LABEL_53:
        v38[0] = this[8];
        v38[1] = v12;
        v38[2] = 0x23F800000;
        v39 = 0;
        v40 = &v45;
        v41 = 0;
        v42 = 0;
        v43 = 0;
        RBShapeData::apply<RB::DisplayList::ItemFactory>((float32x2_t *)&v46, (uint64_t)v38, v13, v14, v15, v16);
        v3 = v43;
        if (v9)
          (**v9)(v9);
        RBFillData::~RBFillData(&v45);
        RBShapeData::~RBShapeData(&v46);
        break;
      case 2u:
        v46.type = 1;
        LODWORD(v38[0]) = 2;
        *(_QWORD *)&v45.type = 0;
        RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,decltype(nullptr)>(this[8], &v46.type, v38);
        v3 = v20;
        if ((v11 & 7) != 2)
          goto LABEL_60;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::LayerItem::decode((RB::DisplayList::LayerItem *)v3, this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_24;
      case 3u:
        RB::Heap::emplace<RB::DisplayList::BackdropColorMatrixItem>((RB::Heap *)this[8]);
        v3 = v21;
        if ((v11 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::BackdropColorMatrixItem::decode(v3, this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_24:
          if (v9)
          {
LABEL_25:
            (**v9)(v9);
            continue;
          }
        }
        else
        {
LABEL_60:
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
          if (v9)
            goto LABEL_25;
        }
        continue;
      case 4u:
        _S8 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 5u:
        v22 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
        v8 = rb_blend_mode(v22);
        continue;
      case 6u:
        v5 = RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>((RB::ProtobufDecoder *)this, field, 4, (uint64_t)&v45);
        continue;
      case 7u:
        v23 = this[9];
        if (v23 && (v24 = (RB::Decoder *)(*(uint64_t (**)(size_t *))(*v23 + 32))(v23)) != 0)
        {
          if ((v11 & 7) != 2)
            goto LABEL_59;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::decode_metadata((RB::DisplayList *)this, v24, (RB::DisplayList::Contents *)&v44[4], (const RB::DisplayList::Metadata **)v44, v25);
          RB::ProtobufDecoder::end_message((uint64_t)this);
          v3 = (uint64_t)v9;
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v11);
          v3 = (uint64_t)v9;
        }
        continue;
      case 8u:
        if ((field & 7) != 2)
          goto LABEL_58;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        v26 = 0;
        v27 = 0;
        v28 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        if (v28)
        {
          do
          {
            if ((v28 >> 3) == 2)
            {
              v37 = *(_OWORD *)this;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v28);
              v27 = v28;
            }
            else if ((v28 >> 3) == 1)
            {
              v26 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, v28);
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v28);
            }
            v28 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          }
          while (v28);
          if (v26 >> 61)
          {
            RB::ProtobufDecoder::end_message((uint64_t)this);
            goto LABEL_58;
          }
        }
        *(_QWORD *)&v45.type = 0;
        v4 = RB::UntypedTable::lookup(v6, (uint64_t *)(v26 | 0xA000000000000000), (void **)&v45);
        v29 = v37;
        if ((v26 | 0xA000000000000000) == *(_QWORD *)&v45.type)
          goto LABEL_50;
        if (v27)
          goto LABEL_46;
        RB::Decoder::saved_shared_field((uint64_t)this, 5, v26, (uint64_t)&v45);
        LOBYTE(v27) = v45.data[12];
        if (*(_QWORD *)&v45.data[12])
        {
          v29 = *(_OWORD *)&v45.type;
LABEL_46:
          v37 = *(_OWORD *)this;
          *(_OWORD *)this = v29;
          if ((v27 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            v4 = (uint64_t *)RB::DisplayList::decode_style_list((RB::DisplayList *)this, v30);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
          }
          *(_OWORD *)this = v37;
        }
        RB::UntypedTable::insert((size_t **)v6, (size_t *)(v26 | 0xA000000000000000), (size_t *)v4);
LABEL_50:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        v3 = (uint64_t)v9;
        if (v4)
          continue;
LABEL_58:
        v4 = 0;
LABEL_59:
        *((_BYTE *)this + 56) = 1;
        *this = this[1];
        v3 = (uint64_t)v9;
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3)
  {
    if (!*((_BYTE *)this + 56) && *this <= this[1])
    {
      __asm { FCVT            H0, S8 }
      *(_WORD *)(v3 + 44) = _H0;
      *(_WORD *)(v3 + 46) = *(_WORD *)(v3 + 46) & 0xFFC0 | v8 & 0x3F;
      *(_QWORD *)(v3 + 16) = v4;
      *(_QWORD *)(v3 + 24) = v5;
      *(_QWORD *)(v3 + 32) = *(_QWORD *)&v44[4];
      *(_DWORD *)(v3 + 40) = *(_DWORD *)v44;
    }
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
  return v3;
}

void sub_209B52438(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, RBFillData *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21)
{
  void (***v21)(_QWORD);
  uint64_t v22;

  RBFillData::~RBFillData((RBFillData *)&a21);
  RBShapeData::~RBShapeData((RBShapeData *)(v22 - 224));
  if (v21)
    (**v21)(v21);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::decode_style_list(RB::DisplayList *this, RB::Decoder *a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t field;
  uint64_t v6;
  RB::DisplayList::AnimationStyle **v7;
  RB::Decoder *v8;
  RB::DisplayList::AnimationStyle *v9;
  uint64_t v10;

  result = *((_QWORD *)this + 9);
  if (result)
  {
    result = (*(uint64_t (**)(uint64_t, RB::Decoder *))(*(_QWORD *)result + 32))(result, a2);
    if (result)
    {
      v4 = result;
      v10 = 0;
      field = RB::ProtobufDecoder::next_field(this);
      if (field)
      {
        v6 = field;
        v7 = (RB::DisplayList::AnimationStyle **)&v10;
        do
        {
          if ((v6 & 0x7FFFFFFF8) == 8)
          {
            if ((v6 & 7) == 2)
            {
              RB::ProtobufDecoder::begin_message(this);
              v9 = RB::DisplayList::Style::decode((RB::Heap **)this, v8);
              if (v9)
              {
                *((_QWORD *)v9 + 1) = *(_QWORD *)(v4 + 312);
                *(_QWORD *)(v4 + 312) = v9;
                *v7 = v9;
                v7 = (RB::DisplayList::AnimationStyle **)((char *)v9 + 32);
              }
              RB::ProtobufDecoder::end_message((uint64_t)this);
            }
            else
            {
              *((_BYTE *)this + 56) = 1;
              *(_QWORD *)this = *((_QWORD *)this + 1);
            }
          }
          else
          {
            RB::ProtobufDecoder::skip_field(this, v6);
          }
          v6 = RB::ProtobufDecoder::next_field(this);
        }
        while (v6);
      }
      else
      {
        v7 = (RB::DisplayList::AnimationStyle **)&v10;
      }
      *v7 = 0;
      return v10;
    }
  }
  return result;
}

uint64_t *RB::DisplayList::LayerItem::prepare_encode(RB::DisplayList::LayerItem *this, RB::Encoder *a2)
{
  uint64_t *result;

  RB::DisplayList::Item::prepare_encode((uint64_t *)this, a2);
  result = (uint64_t *)*((_QWORD *)this + 6);
  if (result)
    return RB::DisplayList::Layer::prepare_encode(result, a2);
  return result;
}

_QWORD *RB::DisplayList::LayerItem::encode(RB::DisplayList::LayerItem *this, RB::Encoder *a2)
{
  _QWORD **v4;

  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = (_QWORD **)*((_QWORD *)this + 6);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Layer::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Item::encode(this, a2);
}

uint64_t RB::DisplayList::LayerItem::decode(RB::DisplayList::LayerItem *this, size_t **a2)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  uint64_t v7;
  RB::DisplayList::Layer *v8;
  RB::DisplayList::Layer *v9;
  uint64_t v10;
  int v11;
  int v12;

  result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        v6 = *((_DWORD *)a2 + 56) + 1;
        *((_DWORD *)a2 + 56) = v6;
        v11 = 0;
        v12 = v6;
        v7 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v12, &v11);
        v8 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
        *((_QWORD *)this + 6) = v7;
        if (v8)
          RB::DisplayList::Layer::~Layer(v8);
        if ((v5 & 7) == 2)
        {
          v9 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::DisplayList::Layer::decode(v9, (RB::Decoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *a2 = a2[1];
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
      }
      result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      v5 = result;
    }
    while (result);
  }
  v10 = *((_QWORD *)this + 6);
  if (v10)
  {
    if ((*(_BYTE *)(v10 + 60) & 1) != 0)
      *((_WORD *)this + 23) |= 0x400u;
  }
  else
  {
    *((_BYTE *)a2 + 56) = 1;
    *a2 = a2[1];
  }
  return result;
}

_QWORD *RB::DisplayList::BackdropColorMatrixItem::encode(RB::DisplayList::BackdropColorMatrixItem *this, RB::Encoder *a2)
{
  RB::Filter::ColorMatrix *v4;

  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = (RB::Filter::ColorMatrix *)*((_QWORD *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Filter::ColorMatrix::encode(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Item::encode(this, a2);
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::decode(uint64_t a1, size_t **this)
{
  uint64_t result;
  uint64_t v5;
  _DWORD *v6;

  result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        v6 = RB::Heap::emplace<RB::Filter::ColorMatrix>(this[8]);
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::ColorMatrix::decode(v6, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        *(_QWORD *)(a1 + 48) = v6;
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v5);
      }
      result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
      v5 = result;
    }
    while (result);
  }
  if (!*(_QWORD *)(a1 + 48))
  {
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
  return result;
}

_QWORD *RB::DisplayList::LayerFilter::encode(RB::DisplayList::LayerFilter *this, RB::Encoder *a2)
{
  _QWORD *result;
  RB::Filter::ColorMatrix *v4;
  RB::Filter::ColorMatrix *v5;

  result = (_QWORD *)(*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(_QWORD *)this + 40))(this);
  v5 = v4;
  switch((int)result)
  {
    case 1:
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::ColorMatrix::encode(v5, a2);
      goto LABEL_7;
    case 2:
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::LuminanceCurve::encode((float32x4_t *)v5, a2);
      goto LABEL_7;
    case 3:
      RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::RGBACurves::encode((float32x4_t *)v5, a2);
      goto LABEL_7;
    case 4:
      RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::Custom::encode(v5, a2);
      goto LABEL_7;
    case 5:
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::Filter::GaussianBlur::encode((int *)v5, a2);
LABEL_7:
      result = RB::ProtobufEncoder::end_length_delimited(a2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t RB::DisplayList::LayerFilter::decode(RB::Heap **this, RB::Decoder *a2)
{
  uint64_t field;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 v7;
  uint64_t v8;
  void (***v9)(_QWORD, __n128);
  void *v10;
  const void **v11;
  unint64_t i;
  unint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  __n128 v18;
  _QWORD v19[4];
  __int128 v20;
  __int128 v21;
  void *v22;
  unint64_t v23;
  uint64_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  if (!field)
    return 0;
  v4 = field;
  v5 = 0;
  do
  {
    switch((v4 >> 3))
    {
      case 1u:
        v18.n128_u32[0] = 0;
        RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v18.n128_i8[8]);
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::ColorMatrix::decode(&v18, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>(this[8], (uint64_t)&v18);
        goto LABEL_34;
      case 2u:
        v18.n128_u32[0] = 0;
        v19[0] = 0;
        v19[1] = 0;
        *(_QWORD *)((char *)&v19[1] + 6) = 0;
        *(_DWORD *)((char *)&v19[2] + 6) = 15360;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::LuminanceCurve::decode(&v18, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(this[8], (uint64_t)&v18);
        goto LABEL_34;
      case 3u:
        v18.n128_u32[0] = 0;
        v19[2] = 0;
        v18.n128_u64[1] = 0;
        v19[0] = 0;
        LODWORD(v19[1]) = 0;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::GaussianBlur::decode((RB::Filter::GaussianBlur *)&v18, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        v7 = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(this[8], (uint64_t)&v18);
        v5 = v8;
        v9 = (void (***)(_QWORD, __n128))v19[2];
        v19[2] = 0;
        if (v9)
          (**v9)(v9, v7);
        break;
      case 4u:
        v18.n128_u32[0] = 0;
        v22 = 0;
        v23 = 0;
        v18.n128_u64[1] = 0;
        v24 = 4;
        v25 = xmmword_209BD5290;
        v26 = xmmword_209BD52A0;
        v27 = 0u;
        v28 = 0u;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::Custom::decode(&v18, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        v5 = RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom>((size_t *)this[8], (uint64_t)&v18);
        v10 = v22;
        if (v22)
          v11 = (const void **)v22;
        else
          v11 = (const void **)v19;
        if (v23)
        {
          for (i = 0; i < v23; ++i)
          {
            RB::CustomShader::Value::reset_data(v11);
            v11 += 3;
          }
          v10 = v22;
        }
        if (v10)
          free(v10);
        v13 = v18.n128_u64[1];
        if (v18.n128_u64[1])
        {
          v14 = (unsigned int *)(v18.n128_u64[1] + 8);
          do
          {
            v15 = __ldxr(v14);
            v16 = v15 - 1;
          }
          while (__stlxr(v16, v14));
          if (!v16)
          {
            __dmb(9u);
            (*(void (**)(unint64_t))(*(_QWORD *)v13 + 8))(v13);
          }
        }
        break;
      case 5u:
        v18.n128_u32[0] = 0;
        memset(v19, 0, sizeof(v19));
        v20 = 0u;
        v21 = 0u;
        if ((v4 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::Filter::RGBACurves::decode(&v18, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::RGBACurves>,RB::Filter::RGBACurves const&,RB::DisplayList::Builder &>(this[8], (uint64_t)&v18);
LABEL_34:
        v5 = v6;
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v4);
        break;
    }
    v4 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  }
  while (v4);
  return v5;
}

void sub_209B52D24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  RB::Filter::Custom::~Custom((RB::Filter::Custom *)va);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::Clip::encode(_QWORD *this, RB::Encoder *a2)
{
  uint64_t v3;

  v3 = (uint64_t)this;
  if (*((_BYTE *)this + 44) == 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  if (*(_QWORD *)(v3 + 32) || *(_DWORD *)(v3 + 40))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, *(RB::Encoder **)(v3 + 32), (const RB::DisplayList::Metadata *)*(unsigned int *)(v3 + 40), 0);
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  return this;
}

uint64_t RB::DisplayList::Clip::decode(RB::Heap **this, RB::Decoder *a2)
{
  uint64_t v3;
  char v4;
  void (***v5)(_QWORD);
  unint64_t field;
  uint64_t v7;
  __int128 *v8;
  int8x16_t v9;
  unint64_t v10;
  float i;
  unint64_t v12;
  __int128 *v13;
  RB::Heap *v14;
  RB::Decoder *v15;
  unsigned int *v16;
  RB::Heap *v18;
  float v19;
  int v20;
  __int128 *v21;
  char v22;
  uint64_t v23;
  _BYTE v24[12];
  RBShapeData v25;
  uint64_t v26;

  v3 = 0;
  v4 = 0;
  v26 = *MEMORY[0x24BDAC8D0];
  memset(v24, 0, sizeof(v24));
  while (1)
  {
    v5 = (void (***)(_QWORD))v3;
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    v7 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v8 = RB::AffineTransform::identity((RB::AffineTransform *)field);
        v25.type = 0;
        if ((v7 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          v10 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
          for (i = 1.0; v10; v10 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this))
          {
            v12 = v10 >> 3;
            if ((v10 >> 3) == 3)
            {
              i = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, v10);
            }
            else if ((_DWORD)v12 == 2)
            {
              RB::Decoder::affine_transform_field((size_t **)this, v10);
              v8 = v13;
            }
            else if ((_DWORD)v12 == 1)
            {
              if ((v10 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RBShapeData::decode(&v25, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
            }
            else
            {
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v10);
            }
          }
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
          i = 1.0;
        }
        v18 = this[8];
        v19 = i;
        v20 = 0;
        v21 = v8;
        v22 = 0;
        v23 = 0;
        RBShapeData::apply<RB::DisplayList::ClipFactory>((uint64_t)&v25, (uint64_t)&v18, v9);
        v3 = v23;
        if (v5)
          (**v5)(v5);
        RBShapeData::~RBShapeData(&v25);
        continue;
      case 2u:
        *(_QWORD *)&v25.type = 0;
        v3 = RB::Heap::emplace<RB::DisplayList::LayerClip,decltype(nullptr)>(this[8]);
        if ((v7 & 7) != 2)
          goto LABEL_35;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::LayerClip::decode((float32x2_t *)v3, (size_t **)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_22;
      case 3u:
        *(_QWORD *)&v25.type = 0;
        v3 = RB::Heap::emplace<RB::DisplayList::ItemClip,decltype(nullptr)>(this[8]);
        if ((v7 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::ItemClip::decode((RB::DisplayList::ItemClip *)v3, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_22:
          if (v5)
          {
LABEL_23:
            (**v5)(v5);
            continue;
          }
        }
        else
        {
LABEL_35:
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
          if (v5)
            goto LABEL_23;
        }
        break;
      case 4u:
        v4 = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 5u:
        v14 = this[9];
        if (v14 && (v15 = (RB::Decoder *)(*(uint64_t (**)(RB::Heap *))(*(_QWORD *)v14 + 32))(v14)) != 0)
        {
          if ((v7 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            RB::DisplayList::decode_metadata((RB::DisplayList *)this, v15, (RB::DisplayList::Contents *)&v24[4], (const RB::DisplayList::Metadata **)v24, v16);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *this = this[1];
          }
          v3 = (uint64_t)v5;
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v7);
          v3 = (uint64_t)v5;
        }
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3)
  {
    if ((v4 & 1) != 0)
    {
      *(_BYTE *)(v3 + 44) = 1;
      *(_QWORD *)(v3 + 16) = 0x100000001000000;
      *(int32x2_t *)(v3 + 24) = vdup_n_s32(0x7F7FFFFFu);
      *(_QWORD *)(v3 + 32) = *(_QWORD *)&v24[4];
      *(_DWORD *)(v3 + 40) = *(_DWORD *)v24;
    }
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
  return v3;
}

void sub_209B53174(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, RBShapeData *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  void (***v17)(_QWORD);

  RBShapeData::~RBShapeData((RBShapeData *)&a17);
  if (v17)
    (**v17)(v17);
  _Unwind_Resume(a1);
}

uint64_t *RB::DisplayList::LayerClip::prepare_encode(RB::DisplayList::LayerClip *this, RB::Encoder *a2)
{
  uint64_t *result;

  result = (uint64_t *)*((_QWORD *)this + 6);
  if (result)
    return RB::DisplayList::Layer::prepare_encode(result, a2);
  return result;
}

_QWORD *RB::DisplayList::LayerClip::encode(RB::DisplayList::LayerClip *this, RB::Encoder *a2)
{
  _QWORD **v4;
  int v5;

  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = (_QWORD **)*((_QWORD *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Layer::encode(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v5 = *((int *)this + 14);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Clip::encode(this, a2);
}

void RB::DisplayList::LayerClip::decode(float32x2_t *this, size_t **a2)
{
  uint64_t field;
  unint64_t v5;
  int v6;
  uint64_t v7;
  RB::DisplayList::Layer *v8;
  RB::DisplayList::Layer *v9;
  RB::DisplayList::Layer *v10;
  float32x2_t v11;
  int v12;
  int v13;

  field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (field)
  {
    v5 = field;
    do
    {
      if ((v5 >> 3) == 2)
      {
        this[7].f32[0] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v5);
      }
      else if ((v5 >> 3) == 1)
      {
        v6 = *((_DWORD *)a2 + 56) + 1;
        *((_DWORD *)a2 + 56) = v6;
        v12 = 0;
        v13 = v6;
        v7 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v13, &v12);
        v8 = (RB::DisplayList::Layer *)this[6];
        this[6] = (float32x2_t)v7;
        if (v8)
          RB::DisplayList::Layer::~Layer(v8);
        if ((v5 & 7) == 2)
        {
          v9 = (RB::DisplayList::Layer *)this[6];
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::DisplayList::Layer::decode(v9, (RB::Decoder *)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *a2 = a2[1];
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
      }
      v5 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    }
    while (v5);
  }
  v10 = (RB::DisplayList::Layer *)this[6];
  if (v10)
  {
    this[2] = RB::DisplayList::Layer::bounds(v10);
    this[3] = v11;
  }
  else
  {
    *((_BYTE *)a2 + 56) = 1;
    *a2 = a2[1];
  }
}

uint64_t RB::DisplayList::ItemClip::prepare_encode(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 48);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 240))(result);
  return result;
}

_QWORD *RB::DisplayList::ItemClip::encode(RB::DisplayList::ItemClip *this, RB::Encoder *a2)
{
  uint64_t v4;

  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = *((_QWORD *)this + 6);
  if (v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(uint64_t, RB::Encoder *))(*(_QWORD *)v4 + 248))(v4, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::DisplayList::Clip::encode(this, a2);
}

void RB::DisplayList::ItemClip::decode(RB::DisplayList::ItemClip *this, RB::Decoder *a2)
{
  uint64_t field;
  uint64_t v5;
  RB::Decoder *v6;
  uint64_t v7;
  void (***v8)(_QWORD);
  uint64_t v9;
  uint64_t v10;

  field = RB::ProtobufDecoder::next_field(a2);
  if (field)
  {
    v5 = field;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          v7 = RB::DisplayList::Item::decode(a2, v6);
          v8 = (void (***)(_QWORD))*((_QWORD *)this + 6);
          *((_QWORD *)this + 6) = v7;
          if (v8)
            (**v8)(v8);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      v5 = RB::ProtobufDecoder::next_field(a2);
    }
    while (v5);
  }
  v9 = *((_QWORD *)this + 6);
  if (v9)
  {
    *((double *)this + 2) = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)v9 + 144))(v9, 0);
    *((_QWORD *)this + 3) = v10;
  }
  else
  {
    *((_BYTE *)a2 + 56) = 1;
    *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
  }
}

_QWORD *RB::DisplayList::ClipNode::encode(_QWORD *this, RB::Encoder *a2)
{
  _QWORD *v3;
  unint64_t v4;

  if (this)
  {
    v3 = this;
    do
    {
      v4 = v3[1] & 0xFFFFFFFFFFFFFFFELL;
      if (v4)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
        RB::ProtobufEncoder::begin_length_delimited(a2);
        (*(void (**)(unint64_t, RB::Encoder *))(*(_QWORD *)v4 + 120))(v4, a2);
        this = RB::ProtobufEncoder::end_length_delimited(a2);
      }
      v3 = (_QWORD *)*v3;
    }
    while (v3);
  }
  return this;
}

void RB::DisplayList::ClipNode::decode(RB::DisplayList::ClipNode *this, size_t **a2)
{
  uint64_t field;
  size_t *v5;
  uint64_t v6;
  RB::Decoder *v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  _BYTE *v11;
  size_t v12;
  uint64_t v13;
  _BYTE *v14;
  const RB::DisplayList::Clip **v15;
  __int128 v16;
  _OWORD v17[2];
  const RB::DisplayList::ClipNode *v18;
  _BYTE __dst[64];
  void *v20;
  size_t v21;
  unint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v20 = 0;
  v21 = 0;
  v22 = 8;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    if (!field)
      break;
    if ((field & 0x7FFFFFFF8) == 8
      && (v5 = a2[9]) != 0
      && (v6 = (*(uint64_t (**)(size_t *))(*v5 + 32))(v5)) != 0)
    {
      if ((field & 7) == 2)
      {
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
        v8 = RB::DisplayList::Clip::decode((RB::Heap **)a2, v7);
        if (v8)
        {
          v9 = v21;
          v10 = v21 + 1;
          if (v22 < v21 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v10);
            v9 = v21;
            v10 = v21 + 1;
          }
          v11 = v20;
          if (!v20)
            v11 = __dst;
          *(_QWORD *)&v11[8 * v9] = v8;
          v21 = v10;
          *(_QWORD *)(v8 + 8) = *(_QWORD *)(v6 + 312);
          *(_QWORD *)(v6 + 312) = v8;
        }
        RB::ProtobufDecoder::end_message((uint64_t)a2);
      }
      else
      {
        *((_BYTE *)a2 + 56) = 1;
        *a2 = a2[1];
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, field);
    }
  }
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  if (v21)
  {
    v18 = 0;
    v12 = v21 - 1;
    if (v21 != 1)
    {
      v13 = 8 * v21 - 8;
      do
      {
        v14 = v20;
        if (!v20)
          v14 = __dst;
        v18 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(a2[8], (const RB::DisplayList::Clip **)&v14[v13], &v18);
        v13 -= 8;
        --v12;
      }
      while (v12);
    }
    v15 = (const RB::DisplayList::Clip **)v20;
    if (!v20)
      v15 = (const RB::DisplayList::Clip **)__dst;
    RB::DisplayList::ClipNode::ClipNode((RB::DisplayList::ClipNode *)v17, *v15, v18);
    v16 = v17[1];
    *(_OWORD *)this = v17[0];
    *((_OWORD *)this + 1) = v16;
  }
  else
  {
    *((_BYTE *)a2 + 56) = 1;
    *a2 = a2[1];
  }
  if (v20)
    free(v20);
}

void sub_209B53790(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  if (a23)
    free(a23);
  _Unwind_Resume(exception_object);
}

RB::Encoder *RB::DisplayList::encode_metadata(RB::Encoder *this, RB::Encoder *a2, const RB::DisplayList::Metadata *a3, char a4)
{
  RB::Encoder *v6;
  unsigned int v7;
  uint64_t *v8;
  uint64_t *v9;
  RB::Transition *v10;
  uint64_t *v11;
  int v12;
  uint64_t *v13;
  RB::TextIdentity *v14;
  RB::Encoder *v15;
  unsigned int v16;
  __int128 v17;
  uint64_t v18;

  v6 = this;
  v18 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)a3)
  {
    v7 = a3;
    uuid_clear((unsigned __int8 *)&v17);
    v16 = v7;
    if (a2)
    {
      v8 = RB::DisplayList::Metadata::identity_ns((uint64_t *)a2);
      if (v8)
        v17 = *(_OWORD *)v8;
    }
    RB::ProtobufEncoder::encode_varint(v6, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(v6);
    RB::Identity::encode(&v16, v6);
    this = (RB::Encoder *)RB::ProtobufEncoder::end_length_delimited(v6);
  }
  if (a2 && (a4 & 1) == 0)
  {
    v9 = RB::DisplayList::Metadata::transition((uint64_t *)a2);
    if (v9)
    {
      v10 = (RB::Transition *)v9;
      RB::ProtobufEncoder::encode_varint(v6, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::Transition::encode(v10, v6);
      RB::ProtobufEncoder::end_length_delimited(v6);
    }
    v11 = RB::DisplayList::Metadata::numeric_value((uint64_t *)a2);
    if (v11)
    {
      v12 = *(_DWORD *)v11;
      RB::ProtobufEncoder::encode_varint(v6, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v6, v12);
    }
    v13 = RB::DisplayList::Metadata::text_identity((uint64_t *)a2);
    if (v13)
    {
      v14 = (RB::TextIdentity *)v13;
      RB::ProtobufEncoder::encode_varint(v6, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::TextIdentity::encode(v14, v6);
      RB::ProtobufEncoder::end_length_delimited(v6);
    }
    this = (RB::Encoder *)RB::DisplayList::Metadata::animation_layer((uint64_t *)a2);
    if (this)
    {
      v15 = this;
      RB::ProtobufEncoder::encode_varint(v6, 0x2AuLL);
      RB::ProtobufEncoder::begin_length_delimited(v6);
      RB::AnimationLayer::encode(v15, v6);
      return (RB::Encoder *)RB::ProtobufEncoder::end_length_delimited(v6);
    }
  }
  return this;
}

uint64_t RB::DisplayList::decode_metadata(RB::DisplayList *this, RB::Decoder *a2, RB::DisplayList::Contents *a3, const RB::DisplayList::Metadata **a4, unsigned int *a5)
{
  unsigned int *v8;
  float v9;
  unint64_t field;
  char v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  _DWORD *v17;
  uint64_t result;
  _QWORD *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned __int8 *v24;
  uint64_t v25;
  char v26;
  _DWORD *v27;
  int v28;
  unsigned __int8 v29[16];
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v28 = 0;
  uuid_clear(v29);
  v8 = 0;
  v27 = 0;
  LOBYTE(v25) = 0;
  v26 = 0;
  v9 = NAN;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field(this);
    v11 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) != 2)
          goto LABEL_23;
        RB::ProtobufDecoder::begin_message(this);
        RB::Identity::decode((uint64_t)&v28, this);
        goto LABEL_10;
      case 2u:
        v12 = operator new();
        *(_DWORD *)(v12 + 8) = 1;
        *(_QWORD *)v12 = off_24C224008;
        *(_WORD *)(v12 + 12) = 0;
        *(_BYTE *)(v12 + 14) = 32;
        *(_DWORD *)(v12 + 16) = -1;
        *(_QWORD *)(v12 + 40) = 0;
        *(_QWORD *)(v12 + 48) = 0x400000000;
        *(_QWORD *)(v12 + 80) = 0;
        *(_QWORD *)(v12 + 88) = 0x600000000;
        if (v8)
        {
          v13 = v8 + 2;
          do
          {
            v14 = __ldxr(v13);
            v15 = v14 - 1;
          }
          while (__stlxr(v15, v13));
          if (!v15)
          {
            __dmb(9u);
            (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
          }
        }
        if ((v11 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::Transition::decode(v12, this);
          v8 = (unsigned int *)v12;
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          v8 = (unsigned int *)v12;
LABEL_23:
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
        break;
      case 3u:
        v9 = RB::ProtobufDecoder::float_field(this, field);
        continue;
      case 4u:
        if ((field & 7) != 2)
          goto LABEL_23;
        RB::ProtobufDecoder::begin_message(this);
        v27 = RB::TextIdentity::decode((size_t **)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        break;
      case 5u:
        if (!v26)
          v26 = 1;
        v25 = 0x100000000;
        if ((field & 7) != 2)
          goto LABEL_23;
        RB::ProtobufDecoder::begin_message(this);
        RB::AnimationLayer::decode(&v25, this);
LABEL_10:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        break;
      default:
        RB::ProtobufDecoder::skip_field(this, field);
        continue;
    }
  }
  *(_DWORD *)a4 = v28;
  *(float *)&v24 = v9;
  RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::Decoder *)((char *)a2 + 16), a3, (float *)&v24);
  *(_QWORD *)a3 = v16;
  if (v27)
    *(_QWORD *)a3 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::Decoder *)((char *)a2 + 16), a3, (uint64_t *)&v27);
  if (v26)
    *(_QWORD *)a3 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::Decoder *)((char *)a2 + 16), a3, &v25);
  if (v8 && *((_BYTE *)v8 + 12))
  {
    v24 = (unsigned __int8 *)v8;
    v17 = (_DWORD *)*((_QWORD *)a2 + 6);
    if (!v17)
    {
      RB::Heap::make_object_table((size_t *)a2 + 2);
      v17 = (_DWORD *)*((_QWORD *)a2 + 6);
    }
    RB::ObjectTable::adopt(v17, (unint64_t)v8);
    v8 = 0;
    *(_QWORD *)a3 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>((RB::Decoder *)((char *)a2 + 16), a3, (uint64_t *)&v24);
  }
  result = uuid_is_null(v29);
  if (!(_DWORD)result)
  {
    v24 = v29;
    v19 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)0>,RB::DisplayList::Metadata const*&,RB::UUID *>((size_t *)a2 + 2, a3, (uint64_t *)&v24);
    result = RB::DisplayList::Contents::intern_uuid(a2, (const UUID *)v19[1]);
    v19[1] = result;
    *(_QWORD *)a3 = v19;
  }
  if (v8)
  {
    v20 = v8 + 2;
    do
    {
      v21 = __ldxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
    {
      __dmb(9u);
      return (*(uint64_t (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
    }
  }
  return result;
}

void sub_209B53D00(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  if (v1)
  {
    v3 = v1 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
    }
  }
  _Unwind_Resume(exception_object);
}

double RB::Heap::emplace<RB::ProjectionMatrix>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (v3 + 36 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x24uLL, 3);
  else
    *((_QWORD *)this + 2) = v3 + 36;
  *(_DWORD *)(v3 + 32) = 1065353216;
  *(_QWORD *)&result = 1065353216;
  *(_OWORD *)v3 = xmmword_209BD5460;
  *(_OWORD *)(v3 + 16) = xmmword_209BD5460;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 48 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 48;
  *(_QWORD *)v3 = &off_24C2279B8;
  result = 0.0078125;
  *(_QWORD *)(v3 + 16) = 0x3F80000000000000;
  *(_QWORD *)(v3 + 24) = 0x3C00000000000000;
  *(_WORD *)(v3 + 32) = 0;
  *(_BYTE *)(v3 + 40) = 1;
  return result;
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::~GenericEffect()
{
  JUMPOUT(0x20BD16544);
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::copy(__n128 *a1, uint64_t a2)
{
  uint64_t v2;

  RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1);
  *(_BYTE *)(v2 + 40) = 0;
}

int32x2_t *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::dod(int32x2_t *a1, int32x2_t *a2)
{
  return RB::AlphaThresholdEffect::dod(a1 + 2, a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::can_append_color_matrix()
{
  return 1;
}

__n128 *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::append_color_matrix(__n128 *a1, float16x4_t *a2, int a3, __int16 a4, uint64_t a5, uint16x4_t a6)
{
  __n128 *v9;
  __n128 *v10;

  v9 = a1;
  if (a1[2].n128_u8[8])
  {
    a6 = (uint16x4_t)RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::Heap *)(*(_QWORD *)(a5 + 8) + 16), a1).n128_u64[0];
    v9 = v10;
    v10[2].n128_u8[8] = 0;
  }
  RB::Fill::Color::append_color_matrix(&v9[1].n128_i16[4], a2, a3, a4, a6);
  return v9;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::AlphaThresholdEffect::matches((RB::AlphaThresholdEffect *)(a1 + 16), a2, a3);
}

float16x4_t *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::apply_transform(__n128 *a1, RB::DisplayList::Contents *a2, RB::DisplayList::Transform *a3, __n128 a4)
{
  float16x4_t *v6;
  float16x4_t *v7;

  v6 = (float16x4_t *)a1;
  if (a1[2].n128_u8[8])
  {
    a4 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>((RB::DisplayList::Contents *)((char *)a2 + 16), a1);
    v6 = v7;
    v7[5].i8[0] = 0;
  }
  RB::AlphaThresholdEffect::apply_transform(v6 + 2, a2, a3, (uint32x4_t)a4);
  return v6;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 3);
}

BOOL RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::needs_zero_alpha(uint64_t a1)
{
  return COERCE_FLOAT(*(_QWORD *)(a1 + 16)) <= 0.0;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::splits_parent()
{
  return 0;
}

int32x2_t *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::render(int32x2_t *a1, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, int a6, float64x2_t *a7, float32x2_t *a8, double a9, float a10, unsigned __int8 a11, __int16 a12, char a13)
{
  return RB::AlphaThresholdEffect::render(a1 + 2, a9, a10, a2, a3, a4, a5, a6, a7, a8, a11, a12, a13);
}

size_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::render(int32x2_t *a1, CGContextRef *a2, uint16x4_t a3)
{
  return RB::AlphaThresholdEffect::render(a1 + 2, a2, a3);
}

void RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::print(uint64_t a1, std::string *a2)
{
  RB::AlphaThresholdEffect::print((RB::AlphaThresholdEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::field()
{
  return 2;
}

_QWORD *RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::AlphaThresholdEffect::encode((RB::AlphaThresholdEffect *)(a1 + 16), a2);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> const&,RB::DisplayList::Contents &>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  __n128 *v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (__n128 *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5[3].n128_u64 > v4)
    v5 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 3;
  v5->n128_u64[0] = (unint64_t)&off_24C2279B8;
  result = a2[1];
  v5[2].n128_u16[0] = a2[2].n128_u16[0];
  v5[1] = result;
  v5[2].n128_u8[8] = 1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 88 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 88;
  *(_QWORD *)v3 = &off_24C2278F8;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_QWORD *)(v3 + 63) = 0;
  *(_WORD *)(v3 + 71) = 1;
  *(_BYTE *)(v3 + 80) = 1;
  return result;
}

void RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::~GenericEffect()
{
  JUMPOUT(0x20BD16544);
}

unint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(_QWORD *)(a2 + 8) + 16), a1, *(_QWORD *)(a2 + 8));
  *(_BYTE *)(result + 80) = 0;
  return result;
}

int32x2_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::dod(uint64_t a1, int32x2_t *a2, double a3, double a4, double a5, double a6, float a7)
{
  return RB::AlphaGradientEffect::dod((RB::AlphaGradientEffect *)(a1 + 16), a2, a3, a4, a5, a6, a7);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::can_append_color_matrix()
{
  return 1;
}

unint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4, uint64_t a5)
{
  unint64_t v8;

  v8 = a1;
  if (*(_BYTE *)(a1 + 80))
  {
    v8 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(_QWORD *)(a5 + 8) + 16), a1, *(_QWORD *)(a5 + 8));
    *(_BYTE *)(v8 + 80) = 0;
  }
  RB::Fill::Gradient::append_color_matrix(v8 + 16, a2, a3, a4);
  return v8;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 72);
}

BOOL RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::needs_zero_alpha(uint64_t a1, double a2, double a3, double a4, double a5, float a6)
{
  return RB::Fill::Gradient::sample_alpha((RB::Fill::Gradient *)(a1 + 16), 0.0, a3, a4, a5, a6) > 0.0;
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::splits_parent()
{
  return 0;
}

RB::Fill::Gradient *RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::render(uint64_t a1, uint64_t a2, uint64_t a3, float32x2_t *a4, uint64_t a5, int a6, float64x2_t *a7, float32x2_t *a8, double a9, double a10, double a11, double a12, float a13, unsigned __int8 a14, __int16 a15, char a16)
{
  return RB::AlphaGradientEffect::render((RB::Fill::Gradient *)(a1 + 16), a9, a10, a11, a12, a13, a2, a3, a4, a5, a6, a7, a8, a14, a15, a16);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::render(uint64_t a1, RB::CGContext *a2)
{
  return RB::AlphaGradientEffect::render((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

void RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::print(uint64_t a1, std::string *a2)
{
  RB::AlphaGradientEffect::print((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::field()
{
  return 3;
}

_QWORD *RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::AlphaGradientEffect::encode((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t a2, uint64_t a3)
{
  unint64_t v5;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 88 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  else
    a1[2] = v5 + 88;
  *(_QWORD *)v5 = &off_24C2278F8;
  RB::AlphaGradientEffect::AlphaGradientEffect((uint64_t *)(v5 + 16), (uint64_t *)(a2 + 16), a3);
  *(_BYTE *)(v5 + 80) = 1;
  return v5;
}

double RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 272 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x110uLL, 15);
  else
    *((_QWORD *)this + 2) = v3 + 272;
  *(_QWORD *)v3 = &off_24C227838;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 128) = 0;
  *(_QWORD *)(v3 + 136) = 4;
  *(_QWORD *)(v3 + 144) = 0;
  *(_QWORD *)(v3 + 152) = 0;
  *(_QWORD *)(v3 + 160) = 0;
  *(_OWORD *)(v3 + 176) = xmmword_209BD5290;
  *(_OWORD *)(v3 + 192) = xmmword_209BD52A0;
  result = 0.0;
  *(_OWORD *)(v3 + 208) = 0u;
  *(_OWORD *)(v3 + 224) = 0u;
  *(_DWORD *)(v3 + 240) = 0;
  *(_BYTE *)(v3 + 256) = 1;
  return result;
}

_QWORD *RB::DisplayList::GenericEffect<RB::CustomEffect>::~GenericEffect(_QWORD *a1)
{
  RB::DisplayList::Layer *v2;
  void *v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (RB::DisplayList::Layer *)a1[18];
  a1[18] = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  v3 = (void *)a1[15];
  if (v3)
    v4 = (const void **)a1[15];
  else
    v4 = (const void **)(a1 + 3);
  if (a1[16])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[16]);
    v3 = (void *)a1[15];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[2];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return a1;
}

void RB::DisplayList::GenericEffect<RB::CustomEffect>::~GenericEffect(_QWORD *a1)
{
  RB::DisplayList::Layer *v2;
  void *v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (RB::DisplayList::Layer *)a1[18];
  a1[18] = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  v3 = (void *)a1[15];
  if (v3)
    v4 = (const void **)a1[15];
  else
    v4 = (const void **)(a1 + 3);
  if (a1[16])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[16]);
    v3 = (void *)a1[15];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[2];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

unint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::copy(uint64_t a1, uint64_t a2)
{
  unint64_t result;
  uint64_t v4;

  result = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>((size_t *)(*(_QWORD *)(a2 + 8) + 16), a1, *(RB::DisplayList::Contents **)(a2 + 8));
  *(_BYTE *)(result + 256) = 0;
  v4 = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(result + 8) = *(_QWORD *)(v4 + 312);
  *(_QWORD *)(v4 + 312) = result;
  return result;
}

unint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::apply_transform(uint64_t a1, float64x2_t *a2)
{
  unint64_t v3;
  size_t *v4;

  v3 = a1;
  if (*(_BYTE *)(a1 + 256))
  {
    v4 = *(size_t **)(*(_QWORD *)&a2->f64[0] + 8);
    v3 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>(v4 + 2, a1, (RB::DisplayList::Contents *)v4);
    *(_BYTE *)(v3 + 256) = 0;
    *(_QWORD *)(v3 + 8) = v4[39];
    v4[39] = v3;
  }
  RB::CustomEffect::apply_transform((RB::CustomEffect *)(v3 + 16), a2);
  return v3;
}

float32x2_t RB::DisplayList::GenericEffect<RB::CustomEffect>::roi(uint64_t a1, float32x2_t *a2, double a3, double a4, double a5, int32x4_t a6)
{
  return RB::CustomEffect::roi((RB::CustomEffect *)(a1 + 16), a2, a3, a4, a5, a6);
}

RB::DisplayList::Layer *RB::DisplayList::GenericEffect<RB::CustomEffect>::dod(uint64_t a1, float32x2_t *a2, double a3, double a4, double a5, int32x4_t a6)
{
  return RB::CustomEffect::dod((RB::CustomEffect *)(a1 + 16), a2, a3, a4, a5, a6);
}

BOOL RB::DisplayList::GenericEffect<RB::CustomEffect>::can_discard_color(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 240) & 3) == 2;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::required_depth(uint64_t a1, uint64_t a2)
{
  return a2;
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::needs_zero_alpha()
{
  return 0;
}

RB::RenderTask *RB::DisplayList::GenericEffect<RB::CustomEffect>::add_tasks(uint64_t a1, MTLPixelFormat a2, __n128 *a3, double a4, double a5)
{
  return RB::CustomEffect::add_tasks(a1 + 16, a2, a3, a4, a5);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::splits_parent(float32x2_t *a1, int32x2_t *a2, const RB::BoundsAccumulator *a3)
{
  return RB::CustomEffect::splits_parent(a1 + 2, a2, a3);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::CustomEffect::prepare(a1 + 16, a2);
}

int32x2_t *RB::DisplayList::GenericEffect<RB::CustomEffect>::render(uint64_t a1, uint64_t a2, uint64_t **a3, float32x4_t *a4, uint64_t a5, uint64_t a6, float64x2_t *a7, float32x2_t *a8, int32x2_t a9, float a10, unsigned __int8 a11, __int16 a12, char a13)
{
  return RB::CustomEffect::render(a1 + 16, a2, a3, a4, a5, a9, a10, a6, a7, a8, a11, a12, a13);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::render(uint64_t a1)
{
  return RBStrokeRef::clip(a1 + 16);
}

void RB::DisplayList::GenericEffect<RB::CustomEffect>::print(uint64_t a1, std::string *a2)
{
  RB::CustomEffect::print((RB::CustomEffect *)(a1 + 16), a2);
}

uint64_t RB::DisplayList::GenericEffect<RB::CustomEffect>::field()
{
  return 4;
}

uint64_t *RB::DisplayList::GenericEffect<RB::CustomEffect>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::CustomEffect::prepare_encode((uint64_t **)(a1 + 16), a2);
}

_QWORD *RB::DisplayList::GenericEffect<RB::CustomEffect>::encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::CustomEffect::encode((RB::CustomEffect *)(a1 + 16), a2);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::CustomEffect>,RB::DisplayList::GenericEffect<RB::CustomEffect> const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t a2, RB::DisplayList::Contents *a3)
{
  unint64_t v5;

  v5 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 272 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  else
    a1[2] = v5 + 272;
  *(_QWORD *)v5 = &off_24C227838;
  RB::CustomEffect::CustomEffect((RB::CustomEffect *)(v5 + 16), (const RB::CustomEffect *)(a2 + 16), a3);
  *(_BYTE *)(v5 + 256) = 1;
  return v5;
}

uint64_t *RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>(uint64_t *result, uint64_t a2, uint64_t *a3, _QWORD **a4)
{
  uint64_t *v7;
  size_t **v8;
  size_t *v9;
  void *v10;

  if ((*((_BYTE *)result + 164) & 1) == 0)
  {
    v7 = result;
    v8 = (size_t **)(result + 10);
    v10 = 0;
    result = RB::UntypedTable::lookup((RB::UntypedTable *)(result + 10), a3, &v10);
    if (v10 != a3)
    {
      v9 = (size_t *)v7[9];
      v7[9] = (uint64_t)v9 + 1;
      RB::UntypedTable::insert(v8, (size_t *)a3, v9);
      RB::ProtobufEncoder::encode_varint(v7, 0x7AuLL);
      RB::ProtobufEncoder::begin_length_delimited(v7);
      if (v9)
      {
        RB::ProtobufEncoder::encode_varint(v7, 8uLL);
        RB::ProtobufEncoder::encode_varint(v7, (unint64_t)v9);
      }
      RB::ProtobufEncoder::encode_varint(v7, (8 * a2) | 2);
      RB::ProtobufEncoder::begin_length_delimited(v7);
      RB::DisplayList::ClipNode::encode(*a4, (RB::Encoder *)v7);
      RB::ProtobufEncoder::end_length_delimited(v7);
      return RB::ProtobufEncoder::end_length_delimited(v7);
    }
  }
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,decltype(nullptr)>(size_t *a1, int *a2, _DWORD *a3)
{
  uint64_t v5;
  double result;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 56 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v5 + 56;
  *(_QWORD *)&result = RB::DisplayList::LayerItem::LayerItem(v5, *a3, 0, (float)*a2);
  return result;
}

double RB::Heap::emplace<RB::DisplayList::BackdropColorMatrixItem>(RB::Heap *this)
{
  unint64_t v2;
  uint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 56 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 56;
  *(_QWORD *)&result = RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem(v3, 0, 2, 1.0);
  return result;
}

uint64_t RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder *this, char a2, uint64_t a3, uint64_t a4)
{
  uint64_t result;
  _QWORD v6[3];
  uint64_t v7;

  v6[0] = a3;
  v6[1] = a4;
  v6[2] = &v7;
  v7 = 0;
  if ((a2 & 7) != 2
    || (RB::ProtobufDecoder::begin_message(this),
        RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1} const&)::{lambda(RB::DisplayList::ClipNode&)#1}::operator()<RB::Decoder>((uint64_t)v6, (size_t **)this), RB::ProtobufDecoder::end_message((uint64_t)this), (result = v7) == 0))
  {
    result = 0;
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
  }
  return result;
}

uint64_t *RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1} const&)::{lambda(RB::DisplayList::ClipNode&)#1}::operator()<RB::Decoder>(uint64_t a1, size_t **this)
{
  uint64_t field;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *result;
  uint64_t *v9;
  uint64_t *v10;
  __int128 v11;
  RB::DisplayList::ClipNode **v12;
  __int128 v13;
  RB::DisplayList::ClipNode *v14;
  __int128 v15;
  __int128 v16;
  void *v17[2];
  uint64_t v18;

  field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
  if (!field)
  {
    v6 = 0;
    v7 = 0;
    goto LABEL_12;
  }
  v5 = field;
  v6 = 0;
  v7 = 0;
  do
  {
    if ((v5 >> 3) == 2)
    {
      v15 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v5);
      v7 = v5;
    }
    else if ((v5 >> 3) == 1)
    {
      v6 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, v5);
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v5);
    }
    result = (uint64_t *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    v5 = (unint64_t)result;
  }
  while (result);
  if (!(v6 >> 61))
  {
LABEL_12:
    v9 = (uint64_t *)(v6 | (*(_QWORD *)a1 << 61));
    v17[0] = 0;
    result = RB::UntypedTable::lookup((RB::UntypedTable *)(this + 10), v9, v17);
    v10 = (uint64_t *)v17[0];
    **(_QWORD **)(a1 + 16) = result;
    if (v9 == v10)
      return result;
    v11 = v15;
    if (!v7)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, *(_QWORD *)a1, v6, (uint64_t)v17);
      LOBYTE(v7) = v18;
      if (!v18)
        return (uint64_t *)RB::UntypedTable::insert(this + 10, (size_t *)v9, **(size_t ***)(a1 + 16));
      v11 = *(_OWORD *)v17;
    }
    v12 = *(RB::DisplayList::ClipNode ***)(a1 + 16);
    v13 = *(_OWORD *)this;
    *(_OWORD *)this = v11;
    if ((v7 & 7) == 2)
    {
      v16 = v13;
      RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
      v14 = (RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode>(this[8]);
      RB::DisplayList::ClipNode::decode(v14, this);
      *v12 = v14;
      RB::ProtobufDecoder::end_message((uint64_t)this);
      v13 = v16;
    }
    else
    {
      *((_BYTE *)this + 56) = 1;
    }
    *(_OWORD *)this = v13;
    return (uint64_t *)RB::UntypedTable::insert(this + 10, (size_t *)v9, **(size_t ***)(a1 + 16));
  }
  return result;
}

_OWORD *RB::Heap::emplace<RB::DisplayList::ClipNode>(size_t *a1)
{
  _OWORD *v1;

  v1 = (_OWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 2) > a1[3])
    v1 = (_OWORD *)RB::Heap::alloc_slow(a1, 0x20uLL, 7);
  else
    a1[2] = (size_t)(v1 + 2);
  *v1 = 0u;
  v1[1] = 0u;
  return v1;
}

_DWORD *RB::Heap::emplace<RB::Filter::ColorMatrix>(size_t *a1)
{
  _DWORD *v1;

  v1 = (_DWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 12) > a1[3])
    v1 = (_DWORD *)RB::Heap::alloc_slow(a1, 0x30uLL, 7);
  else
    a1[2] = (size_t)(v1 + 12);
  *v1 = 0;
  RB::ColorMatrix::set_identity((RB::ColorMatrix *)(v1 + 2));
  return v1;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v5 + 80 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 15);
  else
    *((_QWORD *)this + 2) = v5 + 80;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)v5 = &off_24C227B98;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 48) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v5 + 64) = v7;
  *(__n128 *)(v5 + 32) = result;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  uint64_t v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 72;
  *(_QWORD *)(v5 + 16) = 0;
  *(_QWORD *)(v5 + 24) = 0;
  *(_QWORD *)v5 = &off_24C227B08;
  result = *(__n128 *)a2;
  *(_OWORD *)(v5 + 44) = *(_OWORD *)(a2 + 12);
  *(__n128 *)(v5 + 32) = result;
  v7 = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = 0;
  *(_QWORD *)(v5 + 64) = v7;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::Custom>,RB::Filter::Custom>(size_t *a1, uint64_t a2)
{
  uint64_t v3;

  v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 240 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0xF0uLL, 15);
  else
    a1[2] = v3 + 240;
  return RB::DisplayList::GenericFilter<RB::Filter::Custom>::GenericFilter(v3, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::Custom>::GenericFilter(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)a1 = &off_24C227C28;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)a2;
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 4;
  v4 = *(_QWORD *)(a2 + 120);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 112);
  *(_QWORD *)(a1 + 152) = v4;
  *(_QWORD *)(a2 + 112) = 0;
  *(_QWORD *)(a2 + 120) = 0;
  v5 = *(_QWORD *)(a1 + 160);
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a2 + 128);
  *(_QWORD *)(a2 + 128) = v5;
  RB::vector<RB::CustomShader::Value,4ul,unsigned long>::swap_inline((__int128 *)(a1 + 48), (__int128 *)(a2 + 16));
  v6 = *(_OWORD *)(a2 + 144);
  v7 = *(_OWORD *)(a2 + 160);
  v8 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(a1 + 208) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 224) = v8;
  *(_OWORD *)(a1 + 176) = v6;
  *(_OWORD *)(a1 + 192) = v7;
  return a1;
}

void sub_209B54C58(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  const void **v3;
  void **v4;
  void *v6;
  unint64_t v7;

  v6 = *(void **)(v1 + 144);
  if (v6)
    v3 = *(const void ***)(v1 + 144);
  if (*(_QWORD *)(v1 + 152))
  {
    v7 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v3);
      ++v7;
      v3 += 3;
    }
    while (v7 < *(_QWORD *)(v1 + 152));
    v6 = *v4;
  }
  RB::DisplayList::FilterStyle<RB::Filter::Custom>::FilterStyle<RB::Filter::Custom>(v2, v6);
  _Unwind_Resume(a1);
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,decltype(nullptr)>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  return RB::DisplayList::LayerClip::LayerClip(v3, 0, 0, 1.0);
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,decltype(nullptr)>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 56 > v2)
    RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 56;
  return RB::DisplayList::ItemClip::ItemClip(1.0);
}

float RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>(RB::Heap *this, _QWORD *a2, float *a3)
{
  unint64_t v6;
  unint64_t v7;
  float result;

  v6 = *((_QWORD *)this + 3);
  v7 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 16 > v6)
    v7 = RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  else
    *((_QWORD *)this + 2) = v7 + 16;
  *(_QWORD *)v7 = *a2 | 2;
  result = *a3;
  *(float *)(v7 + 8) = *a3;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>(RB::Heap *this, _QWORD *a2, uint64_t *a3)
{
  unint64_t v6;
  _QWORD *result;
  uint64_t v8;

  v6 = *((_QWORD *)this + 3);
  result = (_QWORD *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6)
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 2;
  v8 = *a3;
  *result = *a2 | 3;
  result[1] = v8;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>(RB::Heap *this, _QWORD *a2, _QWORD *a3)
{
  unint64_t v6;
  _QWORD *result;

  v6 = *((_QWORD *)this + 3);
  result = (_QWORD *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6)
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 2;
  *result = *a2 | 4;
  result[1] = *a3;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>(RB::Heap *this, _QWORD *a2, uint64_t *a3)
{
  unint64_t v6;
  _QWORD *result;
  uint64_t v8;

  v6 = *((_QWORD *)this + 3);
  result = (_QWORD *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v6)
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this, 0x10uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 2;
  v8 = *a3;
  *result = *a2 | 1;
  result[1] = v8;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)0>,RB::DisplayList::Metadata const*&,RB::UUID *>(size_t *a1, _QWORD *a2, uint64_t *a3)
{
  _QWORD *v5;
  uint64_t v6;

  v5 = (_QWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v5 + 2) > a1[3])
    v5 = (_QWORD *)RB::Heap::alloc_slow(a1, 0x10uLL, 7);
  else
    a1[2] = (size_t)(v5 + 2);
  v6 = *a3;
  *v5 = *a2;
  v5[1] = v6;
  return v5;
}

uint64_t RB::Path::Mapper::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t *v3;
  float64x2_t v4;

  *(float64x2_t *)(a1 + 336) = a3;
  *(_BYTE *)(a1 + 368) = 0;
  v3 = *(float64x2_t **)(a1 + 320);
  if (v3)
  {
    v4 = v3[1];
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v3[2], *v3, a2.f64[0]), v4, a2, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(v3[2], *v3, a3.f64[0]), v4, a3, 1);
  }
  return (*(uint64_t (**)(_QWORD, __n128, __n128))(**(_QWORD **)(a1 + 312) + 32))(*(_QWORD *)(a1 + 312), (__n128)a2, (__n128)a3);
}

uint64_t RB::Path::Mapper::StackItem::endpath(RB::Path::Mapper::StackItem *this)
{
  return (***((uint64_t (****)(_QWORD))this + 2))(*((_QWORD *)this + 2));
}

uint64_t RB::Path::Mapper::StackItem::closepath(uint64_t this)
{
  uint64_t v1;

  if (!*(_BYTE *)(this + 64))
  {
    v1 = this;
    *(_OWORD *)(this + 32) = *(_OWORD *)(this + 48);
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 16) + 8))(*(_QWORD *)(this + 16));
    *(_BYTE *)(v1 + 64) = 1;
  }
  return this;
}

uint64_t RB::Path::Mapper::StackItem::moveto(uint64_t a1, __n128 a2)
{
  *(__n128 *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 64) = 0;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 16))(*(_QWORD *)(a1 + 16));
}

uint64_t RB::Path::Mapper::StackItem::lineto(uint64_t a1, __n128 a2)
{
  *(__n128 *)(a1 + 32) = a2;
  *(_BYTE *)(a1 + 64) = 0;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 24))(*(_QWORD *)(a1 + 16));
}

uint64_t RB::Path::Mapper::StackItem::quadto(uint64_t a1, double a2, __n128 a3)
{
  *(__n128 *)(a1 + 32) = a3;
  *(_BYTE *)(a1 + 64) = 0;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 32))(*(_QWORD *)(a1 + 16));
}

uint64_t RB::Path::Mapper::StackItem::cubeto(uint64_t a1, double a2, double a3, __n128 a4)
{
  *(__n128 *)(a1 + 32) = a4;
  *(_BYTE *)(a1 + 64) = 0;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 16) + 40))(*(_QWORD *)(a1 + 16));
}

uint64_t RB::Path::Mapper::elt_quadto(uint64_t a1, float64x2_t *a2, float64x2_t a3, float64x2_t a4)
{
  float64x2_t v4;
  uint64_t v5;

  if (a2)
  {
    v4 = a2[1];
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a4.f64[0]), v4, a4, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), v4, a3, 1);
  }
  v5 = *(_QWORD *)(a1 + 328);
  if (!v5)
    return RB::Path::Mapper::quadto(a1, a3, a4);
  *(float64x2_t *)(v5 + 32) = a4;
  *(_BYTE *)(v5 + 64) = 0;
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v5 + 16) + 32))(*(_QWORD *)(v5 + 16));
}

uint64_t RB::Path::Mapper::add_rect(__n128 *this, CGRect a2, float64x2_t *a3, int a4)
{
  CGFloat y;
  CGFloat height;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64_t v13;
  float64x2_t v14;
  float64x2_t v16;
  float64x2_t v17;

  y = a2.origin.y;
  height = a2.size.height;
  v8 = vaddq_f64((float64x2_t)a2.origin, (float64x2_t)a2.size);
  v9 = vminnmq_f64((float64x2_t)a2.origin, v8);
  v10 = vmaxnmq_f64((float64x2_t)a2.origin, v8);
  v16 = v9;
  v17 = v10;
  if (a4)
  {
    RB::Path::Mapper::elt_moveto(this, a3, v9);
    v11.f64[0] = v17.f64[0];
    v11.f64[1] = v16.f64[1];
    RB::Path::Mapper::elt_lineto(this, a3, v11);
    RB::Path::Mapper::elt_lineto(this, a3, v17);
    v12.f64[0] = v16.f64[0];
    v13 = v17.f64[1];
  }
  else
  {
    v10.f64[1] = vmuld_lane_f64(0.5, vaddq_f64(v10, v9), 1);
    RB::Path::Mapper::elt_moveto(this, a3, v10);
    RB::Path::Mapper::elt_lineto(this, a3, v17);
    v14.f64[0] = v16.f64[0];
    v14.f64[1] = v17.f64[1];
    RB::Path::Mapper::elt_lineto(this, a3, v14);
    RB::Path::Mapper::elt_lineto(this, a3, v16);
    v13 = v16.f64[1];
    v12.f64[0] = v17.f64[0];
  }
  v12.f64[1] = v13;
  RB::Path::Mapper::elt_lineto(this, a3, v12);
  return RB::Path::Mapper::elt_closepath((uint64_t)this);
}

uint64_t RB::Path::Mapper::add_ellipse(__n128 *this, CGRect a2, int a3, const CGAffineTransform *a4)
{
  double v7;
  double v8;
  __int128 v9;
  CGAffineTransform t2;
  CGAffineTransform t1;
  CGAffineTransform v13;
  CGRect v14;

  v14 = CGRectStandardize(a2);
  v7 = v14.size.width * 0.5;
  v13.a = v7;
  v8 = -0.5;
  if (!a3)
    v8 = 0.5;
  v13.b = 0.0;
  v13.c = 0.0;
  v13.d = v14.size.height * v8;
  v13.tx = v7 + v14.origin.x;
  v13.ty = v14.origin.y + v14.size.height * 0.5;
  if (a4)
  {
    t1 = v13;
    v9 = *(_OWORD *)&a4->c;
    *(_OWORD *)&t2.a = *(_OWORD *)&a4->a;
    *(_OWORD *)&t2.c = v9;
    *(_OWORD *)&t2.tx = *(_OWORD *)&a4->tx;
    CGAffineTransformConcat(&v13, &t1, &t2);
  }
  RB::Path::Mapper::elt_moveto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_209BD5290);
  RB::Path::Mapper::elt_cubeto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_209BD6D50, (float64x2_t)xmmword_209BD6D60, (float64x2_t)xmmword_209BD52A0);
  RB::Path::Mapper::elt_cubeto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_209BD6D70, (float64x2_t)xmmword_209BD6D80, (float64x2_t)xmmword_209BD6C00);
  RB::Path::Mapper::elt_cubeto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_209BD6D90, (float64x2_t)xmmword_209BD6DA0, (float64x2_t)xmmword_209BD6DB0);
  RB::Path::Mapper::elt_cubeto(this, (float64x2_t *)&v13, (float64x2_t)xmmword_209BD6DC0, (float64x2_t)xmmword_209BD6DD0, (float64x2_t)xmmword_209BD5290);
  return RB::Path::Mapper::elt_closepath((uint64_t)this);
}

uint64_t RB::Path::Mapper::add_relative_arc(__n128 *a1, float64x2_t *a2, float64x2_t a3, double a4, double a5, double a6)
{
  double v8;
  __double2 v10;
  float64x2_t v11;
  float64x2_t v12;
  unint64_t v13;
  __n128 *v14;
  uint64_t result;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  double v19;
  uint64_t i;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  __double2 v26;
  float64x2_t v27;
  __double2 v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v33;
  double v34;
  float64x2_t v35;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  int8x16_t v40;
  float64x2_t v41;

  v8 = a5;
  v10 = __sincos_stret(a5);
  v11.f64[0] = v10.__cosval;
  v11.f64[1] = v10.__sinval;
  v12 = vmlaq_n_f64(a3, v11, a4);
  v13 = a1[20].n128_u64[1];
  if (v13)
    v14 = (__n128 *)(v13 + 64);
  else
    v14 = a1 + 23;
  v39 = v12;
  if (v14->n128_u8[0])
    result = RB::Path::Mapper::elt_moveto(a1, a2, v12);
  else
    result = RB::Path::Mapper::elt_lineto(a1, a2, v12);
  v16.f64[0] = v10.__sinval;
  v17 = v39;
  if ((*(_QWORD *)&a6 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
  {
    v35 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&a4, 0);
    v18 = dbl_209BD6DE0[a6 < 0.0];
    v19 = 1.0;
    if (a6 < 0.0)
      v19 = -1.0;
    v34 = v19;
    v33 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(dbl_209BD6DF0[a6 < 0.0] * a4), 0);
    v16.f64[1] = v10.__cosval;
    for (i = 1023; a6 > 0.0 && a6 > v18 || a6 < 0.0 && a6 < v18; --i)
    {
      if (!i)
        return result;
      *(_QWORD *)&v23.f64[0] = vdupq_laneq_s64((int64x2_t)v16, 1).u64[0];
      v23.f64[1] = -v16.f64[0];
      v40 = (int8x16_t)vmulq_n_f64(v23, v34);
      v16.f64[0] = -v16.f64[0];
      v24 = vmlaq_f64(v17, v33, v16);
      *(_QWORD *)&v25.f64[1] = v40.i64[1];
      v25.f64[0] = -*(double *)v40.i64;
      v37 = vmlaq_f64(a3, v35, (float64x2_t)vextq_s8(v40, v40, 8uLL));
      result = RB::Path::Mapper::elt_cubeto(a1, a2, v24, vmlsq_f64(v37, v33, v25), v37);
      v8 = v8 + v18;
      a6 = a6 - v18;
      v17 = v37;
      v16 = (float64x2_t)v40;
    }
    if (fabs(a6) > 0.00000999999975)
    {
      v41 = v17;
      v38 = v16;
      v26 = __sincos_stret(a6 * 0.5);
      v28 = __sincos_stret(v8 + a6);
      v27.f64[0] = v28.__cosval;
      v29.f64[0] = -v28.__sinval;
      v29.f64[1] = v28.__cosval;
      v27.f64[1] = v28.__sinval;
      v30 = vmlaq_f64(a3, v35, v27);
      v31.f64[1] = v38.f64[1];
      v31.f64[0] = -v38.f64[0];
      return RB::Path::Mapper::elt_cubeto(a1, a2, vmlaq_n_f64(v41, v31, (4.0 - v26.__cosval * 4.0) * a4 / (v26.__sinval * 3.0)), vmlsq_lane_f64(v30, v29, (4.0 - v26.__cosval * 4.0) * a4 / (v26.__sinval * 3.0), 0), v30);
    }
  }
  return result;
}

uint64_t RB::Path::Mapper::add_arc(__n128 *a1, int a2, CGAffineTransform *a3, float64x2_t a4, double a5, double a6, double a7)
{
  unint64_t v7;
  __n128 *v8;
  double v9;
  double v11;
  double v12;
  double v13;
  int v14;

  v7 = a1[20].n128_u64[1];
  if (v7)
    v8 = (__n128 *)(v7 + 64);
  else
    v8 = a1 + 23;
  if (v8->n128_u8[0])
  {
    v9 = a7 + -6.28318531;
    if (a6 == 0.0 && a7 >= 6.28318531 && v9 < 0.00001 && a2 != 0)
    {
      v11 = a5 + a5;
      a4.f64[0] = a4.f64[0] - a5;
      v12 = a4.f64[1] - a5;
      v13 = v11;
      v14 = 1;
      return RB::Path::Mapper::add_ellipse(a1, *(CGRect *)a4.f64, v14, a3);
    }
    if (a6 == 0.0 && fabs(v9) < 0.00000999999975 && a2 == 0)
    {
      v11 = a5 + a5;
      a4.f64[0] = a4.f64[0] - a5;
      v12 = a4.f64[1] - a5;
      v13 = v11;
      v14 = 0;
      return RB::Path::Mapper::add_ellipse(a1, *(CGRect *)a4.f64, v14, a3);
    }
  }
  if (a2)
  {
    if (a6 < a7)
      a6 = a6 + ceil((a7 - a6) * 0.159154943) * 6.28318531;
  }
  else if (a7 < a6)
  {
    a7 = a7 + ceil((a6 - a7) * 0.159154943) * 6.28318531;
  }
  return RB::Path::Mapper::add_relative_arc(a1, (float64x2_t *)a3, a4, a5, a6, a7 - a6);
}

uint64_t RB::Path::Mapper::add_arc_to_point(__n128 *a1, int8x16_t *a2, float64x2_t a3, float64x2_t a4, double a5)
{
  float64x2_t v6;
  unint64_t v8;
  __n128 *v9;
  float64x2_t v10;
  unint64_t v11;
  int8x16_t v12;
  float64x2_t v13;
  int8x16_t v14;
  float64x2_t v15;
  double v16;
  int v17;
  double v18;
  double v19;
  float64x2_t v20;
  __double2 v21;
  float64x2_t v22;
  int8x16_t v23;
  float64x2_t v24;
  __double2 v25;
  double v26;
  double v27;
  double v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  int8x16_t v33;
  int8x16_t v34;
  int8x16_t v35;
  __int128 v36;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;

  v6 = a4;
  v8 = a1[20].n128_u64[1];
  if (v8)
    v9 = (__n128 *)(v8 + 32);
  else
    v9 = a1 + 21;
  v10 = *(float64x2_t *)v9;
  if (a2)
  {
    v33 = a2[1];
    v34 = *a2;
    v35 = a2[2];
    v46 = *a2;
    v47 = v33;
    v48 = v35;
    v44 = v10;
    v38 = a3;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v46))
      v11 = -1;
    else
      v11 = 0;
    v12 = (int8x16_t)vdupq_n_s64(v11);
    v6 = a4;
    v10 = vmlaq_laneq_f64(vmlaq_n_f64((float64x2_t)vbslq_s8(v12, v48, v35), (float64x2_t)vbslq_s8(v12, v46, v34), v44.f64[0]), (float64x2_t)vbslq_s8(v12, v47, v33), v44, 1);
    a3 = v38;
  }
  v13 = vsubq_f64(a3, v10);
  v14 = (int8x16_t)vceqzq_f64(v13);
  v45 = v10;
  v15 = vsubq_f64(v6, v10);
  v36 = xmmword_209BD52A0;
  v16 = 0.0;
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v14), 1), v14).u64[0] & 0x8000000000000000) != 0)
  {
    v39 = v13;
    v42 = v15;
    v19 = atan2(v13.f64[1], v13.f64[0]);
    v18 = v19;
    if (v19 == 0.0)
    {
      v17 = 0;
      v13 = v39;
      v15 = v42;
    }
    else
    {
      v21 = __sincos_stret(v19);
      v20.f64[0] = v21.__cosval;
      v20.f64[1] = -v21.__sinval;
      v36 = (__int128)v21;
      v22 = vmlaq_n_f64(vmulq_laneq_f64((float64x2_t)v21, v42, 1), v20, v42.f64[0]);
      v17 = 1;
      v13 = vmlaq_n_f64(vmulq_laneq_f64((float64x2_t)v21, v39, 1), v20, v39.f64[0]);
      v15 = v22;
    }
  }
  else
  {
    v17 = 0;
    a5 = 0.0;
    v18 = 0.0;
  }
  v40 = v13;
  v43 = v15;
  v23 = (int8x16_t)vceqq_f64(v13, v15);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v23), 1), v23).u64[0] & 0x8000000000000000) != 0)
  {
    v24 = vsubq_f64(v15, v13);
    v16 = 3.14159265 - fabs(atan2(v24.f64[1], v24.f64[0]));
  }
  v25 = __sincos_stret(v16 * 0.5);
  v26 = 0.0;
  v27 = 0.0;
  v28 = 0.0;
  v29 = v40;
  if (v25.__sinval == 0.0)
  {
    if (v17)
    {
LABEL_18:
      v30 = (float64x2_t)v36;
      v31 = vmulq_n_f64((float64x2_t)vextq_s8((int8x16_t)v30, (int8x16_t)v30, 8uLL), v29.f64[0]);
      v30.f64[0] = -*(double *)&v36;
      v27 = v27 + v18;
      v28 = v28 + v18;
      v29 = vmlaq_laneq_f64(v31, v30, v29, 1);
    }
  }
  else
  {
    v26 = a5;
    v29.f64[0] = v40.f64[0] - fabs(v25.__cosval / v25.__sinval) * a5;
    if ((vmovn_s64(vcgtq_f64(v43, v40)).i32[1] & 1) != 0)
    {
      v29.f64[1] = a5;
      v28 = 1.57079633 - v16;
      v27 = -1.57079633;
    }
    else
    {
      v29.f64[1] = -a5;
      v28 = v16 + -1.57079633;
      v27 = 1.57079633;
    }
    if (v17)
      goto LABEL_18;
  }
  return RB::Path::Mapper::add_arc(a1, vmovn_s64((int64x2_t)vmvnq_s8((int8x16_t)vcgtq_f64(v43, v40))).i32[1] & 1, (CGAffineTransform *)a2, vaddq_f64(v29, v45), v26, v27, v28);
}

double RB::Path::Mapper::push_cut(RB::Path::Mapper *this, double a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  RB::Path::Mapper *v9;
  float v10;
  float v11;
  unint64_t v12;
  double result;

  v6 = operator new();
  v7 = v6;
  v8 = *((_QWORD *)this + 41);
  if (v8)
    v9 = (RB::Path::Mapper *)*((_QWORD *)this + 41);
  else
    v9 = this;
  v10 = a2;
  v11 = a3;
  *(_OWORD *)(v6 + 136) = 0u;
  *(_QWORD *)(v6 + 152) = 128;
  *(_OWORD *)(v6 + 4256) = 0u;
  *(_QWORD *)(v6 + 4272) = 512;
  *(_QWORD *)v6 = &unk_24C229548;
  *(_QWORD *)(v6 + 4280) = v9;
  *(float *)(v6 + 4288) = v10;
  *(float *)(v6 + 4292) = v11;
  v12 = *((_QWORD *)this + 38);
  if (v12)
  {
    *((_QWORD *)this + 38) = *(_QWORD *)v12;
  }
  else
  {
    v12 = (*((_QWORD *)this + 3) + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v12 + 80 > *((_QWORD *)this + 4))
    {
      v12 = RB::Heap::alloc_slow((size_t *)this + 1, 0x50uLL, 15);
      v8 = *((_QWORD *)this + 41);
    }
    else
    {
      *((_QWORD *)this + 3) = v12 + 80;
    }
  }
  *(_QWORD *)v12 = off_24C229588;
  *(_QWORD *)(v12 + 8) = v8;
  *(_QWORD *)(v12 + 16) = v7;
  result = 0.0;
  *(_OWORD *)(v12 + 32) = 0u;
  *(_OWORD *)(v12 + 48) = 0u;
  *(_WORD *)(v12 + 64) = 257;
  *((_QWORD *)this + 41) = v12;
  return result;
}

double RB::Path::Mapper::push_offset(RB::Path::Mapper *this, double a2)
{
  uint64_t v4;
  uint64_t v5;
  RB::Path::Mapper *v6;
  unint64_t v7;
  uint64_t v8;
  double result;

  v4 = operator new();
  v5 = v4;
  if (*((_QWORD *)this + 41))
    v6 = (RB::Path::Mapper *)*((_QWORD *)this + 41);
  else
    v6 = this;
  CG::offset::offset(v4, (uint64_t)v6, 0.0, a2);
  v7 = *((_QWORD *)this + 38);
  if (v7)
  {
    *((_QWORD *)this + 38) = *(_QWORD *)v7;
  }
  else
  {
    v7 = (*((_QWORD *)this + 3) + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v7 + 80 > *((_QWORD *)this + 4))
      v7 = RB::Heap::alloc_slow((size_t *)this + 1, 0x50uLL, 15);
    else
      *((_QWORD *)this + 3) = v7 + 80;
  }
  v8 = *((_QWORD *)this + 41);
  *(_QWORD *)v7 = off_24C229588;
  *(_QWORD *)(v7 + 8) = v8;
  *(_QWORD *)(v7 + 16) = v5;
  result = 0.0;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_WORD *)(v7 + 64) = 513;
  *((_QWORD *)this + 41) = v7;
  return result;
}

unint64_t RB::Path::Mapper::push_stroke(size_t *a1, uint64_t a2, double a3, double a4, double a5)
{
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  float v16;
  float v17;
  float v18;
  unint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  size_t v23;
  __int16 v24;
  size_t v25;

  if (a2)
  {
    v9 = *(_DWORD *)a2;
    v8 = *(_DWORD *)(a2 + 4);
    v10 = *(_QWORD *)(a2 + 8);
    if (v10)
    {
      v12 = *(_QWORD *)(a2 + 16);
      v13 = (_QWORD *)operator new();
      v14 = v13;
      if (a1[41])
        v15 = a1[41];
      else
        v15 = (uint64_t)a1;
      v16 = a3;
      v17 = a4;
      v18 = a5;
      RB::Path::DasherStroker::DasherStroker(v13, v15, v9, v8, v10, v12, v16, v17, v18);
      result = a1[38];
      if (result)
      {
        a1[38] = *(_QWORD *)result;
      }
      else
      {
        result = (a1[3] + 15) & 0xFFFFFFFFFFFFFFF0;
        if (result + 80 > a1[4])
          result = RB::Heap::alloc_slow(a1 + 1, 0x50uLL, 15);
        else
          a1[3] = result + 80;
      }
      v25 = a1[41];
      *(_QWORD *)result = off_24C229588;
      *(_QWORD *)(result + 8) = v25;
      *(_QWORD *)(result + 16) = v14;
      *(_OWORD *)(result + 32) = 0u;
      *(_OWORD *)(result + 48) = 0u;
      v24 = 1025;
      goto LABEL_20;
    }
  }
  else
  {
    v8 = 0;
    v9 = 0;
  }
  v20 = operator new();
  v21 = v20;
  if (a1[41])
    v22 = a1[41];
  else
    v22 = (uint64_t)a1;
  CG::stroker::stroker(v20, MEMORY[0x24BDBD8B8], v9, v8, v22, 0.0, a3, a4);
  result = a1[38];
  if (result)
  {
    a1[38] = *(_QWORD *)result;
  }
  else
  {
    result = (a1[3] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (result + 80 > a1[4])
      result = RB::Heap::alloc_slow(a1 + 1, 0x50uLL, 15);
    else
      a1[3] = result + 80;
  }
  v23 = a1[41];
  *(_QWORD *)result = off_24C229588;
  *(_QWORD *)(result + 8) = v23;
  *(_QWORD *)(result + 16) = v21;
  *(_OWORD *)(result + 32) = 0u;
  *(_OWORD *)(result + 48) = 0u;
  v24 = 769;
LABEL_20:
  *(_WORD *)(result + 64) = v24;
  a1[41] = result;
  return result;
}

double RB::Path::Mapper::push_BOOLean(size_t *a1, char *a2)
{
  char v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  size_t v7;
  size_t *v8;
  unint64_t v9;
  double result;

  if (a2)
  {
    v3 = *a2;
    v4 = a2[1] != 0;
  }
  else
  {
    v3 = 0;
    v4 = 0;
  }
  v5 = operator new();
  v6 = v5;
  v7 = a1[41];
  if (v7)
    v8 = (size_t *)a1[41];
  else
    v8 = a1;
  *(_QWORD *)v5 = &unk_24C229488;
  *(_QWORD *)(v5 + 8) = 0;
  *(_QWORD *)(v5 + 16) = v8;
  *(_BYTE *)(v5 + 24) = v3;
  *(_BYTE *)(v5 + 25) = v4;
  *(_QWORD *)(v5 + 32) = 0;
  v9 = a1[38];
  if (v9)
  {
    a1[38] = *(_QWORD *)v9;
  }
  else
  {
    v9 = (a1[3] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v9 + 80 > a1[4])
    {
      v9 = RB::Heap::alloc_slow(a1 + 1, 0x50uLL, 15);
      v7 = a1[41];
    }
    else
    {
      a1[3] = v9 + 80;
    }
  }
  *(_QWORD *)v9 = off_24C229588;
  *(_QWORD *)(v9 + 8) = v7;
  *(_QWORD *)(v9 + 16) = v6;
  result = 0.0;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_OWORD *)(v9 + 48) = 0u;
  *(_WORD *)(v9 + 64) = 1281;
  a1[41] = v9;
  return result;
}

double RB::Path::Mapper::push_clip_stroke(size_t *a1, unsigned int *a2, double a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  size_t *v12;
  float v13;
  unint64_t v14;
  size_t v15;
  double result;

  if (a2)
  {
    v6 = *a2;
    v7 = rb_line_cap(a2[1]);
    v9 = *((_QWORD *)a2 + 1);
    v8 = *((_QWORD *)a2 + 2);
  }
  else
  {
    v8 = 0;
    v6 = 0;
    v7 = 0;
    v9 = 0;
  }
  v10 = operator new();
  v11 = v10;
  if (a1[41])
    v12 = (size_t *)a1[41];
  else
    v12 = a1;
  v13 = a3;
  RB::Path::ClipStroke::ClipStroke(v10, v12, v6, v7, v8, v9, v13);
  v14 = a1[38];
  if (v14)
  {
    a1[38] = *(_QWORD *)v14;
  }
  else
  {
    v14 = (a1[3] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v14 + 80 > a1[4])
      v14 = RB::Heap::alloc_slow(a1 + 1, 0x50uLL, 15);
    else
      a1[3] = v14 + 80;
  }
  v15 = a1[41];
  *(_QWORD *)v14 = off_24C229588;
  *(_QWORD *)(v14 + 8) = v15;
  *(_QWORD *)(v14 + 16) = v11;
  result = 0.0;
  *(_OWORD *)(v14 + 32) = 0u;
  *(_OWORD *)(v14 + 48) = 0u;
  *(_WORD *)(v14 + 64) = 1793;
  a1[41] = v14;
  return result;
}

double RB::Path::Mapper::push_dilate_glyph(size_t *a1, __n128 a2)
{
  uint64_t v3;
  uint64_t v4;
  size_t v5;
  size_t *v6;
  unint64_t v7;
  double result;

  v3 = operator new();
  v4 = v3;
  v5 = a1[41];
  if (v5)
    v6 = (size_t *)a1[41];
  else
    v6 = a1;
  *(_OWORD *)(v3 + 136) = 0u;
  *(_QWORD *)(v3 + 152) = 128;
  *(_QWORD *)(v3 + 4272) = 512;
  *(_OWORD *)(v3 + 4256) = 0u;
  *(_QWORD *)v3 = &unk_24C222C40;
  *(_QWORD *)(v3 + 4280) = v6;
  *(__n128 *)(v3 + 4288) = a2;
  v7 = a1[38];
  if (v7)
  {
    a1[38] = *(_QWORD *)v7;
  }
  else
  {
    v7 = (a1[3] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v7 + 80 > a1[4])
    {
      v7 = RB::Heap::alloc_slow(a1 + 1, 0x50uLL, 15);
      v5 = a1[41];
    }
    else
    {
      a1[3] = v7 + 80;
    }
  }
  *(_QWORD *)v7 = off_24C229588;
  *(_QWORD *)(v7 + 8) = v5;
  *(_QWORD *)(v7 + 16) = v4;
  result = 0.0;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_WORD *)(v7 + 64) = 1537;
  a1[41] = v7;
  return result;
}

_QWORD *RB::Path::DasherStroker::DasherStroker(_QWORD *a1, uint64_t a2, int a3, int a4, uint64_t a5, uint64_t a6, float a7, float a8, float a9)
{
  _QWORD *v13;
  uint64_t v14;

  *a1 = off_24C223DE0;
  v13 = a1 + 1;
  v14 = MEMORY[0x24BDBD8B8];
  CG::stroker::stroker((uint64_t)(a1 + 1), MEMORY[0x24BDBD8B8], a3, a4, a2, 0.0, a7, a8);
  CG::dasher::dasher(a1 + 32, v14, a6, a5, v13, a9);
  return a1;
}

uint64_t RB::Path::DasherStroker::endpath(RB::Path::DasherStroker *this)
{
  return CG::dasher::endpath((RB::Path::DasherStroker *)((char *)this + 256));
}

double RB::Path::DasherStroker::closepath(RB::Path::DasherStroker *this)
{
  double result;

  *(_QWORD *)&result = CG::dasher::closepath((RB::Path::DasherStroker *)((char *)this + 256)).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::moveto(uint64_t a1, __n128 a2)
{
  double result;

  *(_QWORD *)&result = CG::dasher::moveto(a1 + 256, a2).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::lineto(uint64_t a1, float64x2_t a2)
{
  double result;

  *(_QWORD *)&result = CG::dasher::lineto(a1 + 256, a2).n128_u64[0];
  return result;
}

double RB::Path::DasherStroker::quadto(const Point *a1, __n128 a2, __n128 a3)
{
  return CG::dasher::quadto(a1 + 64, a2, a3);
}

double RB::Path::DasherStroker::cubeto(const Point *a1, __n128 a2, __n128 a3, __n128 a4)
{
  return CG::dasher::cubeto(a1 + 64, a2, a3, a4);
}

_DWORD *RB::RenderTask::set_parent(uint64_t a1, uint64_t a2)
{
  _DWORD *result;
  int v5;

  *(_QWORD *)(a1 + 16) = a2;
  result = *(_DWORD **)(a1 + 40);
  *(_QWORD *)(a1 + 40) = *(_QWORD *)(a2 + 32);
  *(_QWORD *)(a2 + 32) = result;
  if (result != (_DWORD *)a1)
  {
    if (result)
    {
      v5 = result[2] - 1;
      result[2] = v5;
      if (!v5)
        result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
    }
    ++*(_DWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 32) = a1;
  }
  return result;
}

double RB::RenderTask::set_continuation(uint64_t a1, uint64_t a2)
{
  _DWORD *v4;
  int v5;
  double result;
  _DWORD *v7;
  _DWORD *v8;
  int v9;

  *(_BYTE *)(a1 + 73) |= 1u;
  v4 = *(_DWORD **)(a2 + 24);
  if (v4 != (_DWORD *)a1)
  {
    if (v4)
    {
      v5 = v4[2] - 1;
      v4[2] = v5;
      if (!v5)
        (*(void (**)(_DWORD *))(*(_QWORD *)v4 + 8))(v4);
    }
    ++*(_DWORD *)(a1 + 8);
    *(_QWORD *)(a2 + 24) = a1;
  }
  v7 = *(_DWORD **)(a1 + 88);
  if (v7)
  {
    v8 = *(_DWORD **)(a2 + 88);
    if (v8 != v7)
    {
      if (!v8
        || (v9 = v8[2] - 1, (v8[2] = v9) != 0)
        || ((*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8), (v7 = *(_DWORD **)(a1 + 88)) != 0))
      {
        ++v7[2];
      }
      *(_QWORD *)(a2 + 88) = v7;
    }
    result = *(double *)(a1 + 64);
    *(double *)(a2 + 64) = result;
  }
  return result;
}

uint64_t RB::RenderTask::bytes(RB::RenderTask *this, MTLPixelFormat a2)
{
  signed __int32 v2;

  v2 = vmul_lane_s32(*(int32x2_t *)((char *)this + 56), *(int32x2_t *)((char *)this + 56), 1).u32[0];
  return *((unsigned __int8 *)RB::pixel_format_traits(*((_QWORD *)this + 10), a2) + 6) * (uint64_t)v2;
}

void RB::RenderTask::print(RB::RenderTask *this, std::string *a2)
{
  int v4;
  int v5;
  int v6;
  MTLPixelFormat v7;
  char *v8;
  const char *v9;
  RB::RenderTask *i;

  RB::SexpString::push(a2, "task");
  v4 = HIDWORD(*((_QWORD *)this + 7));
  v5 = *((_QWORD *)this + 7);
  v6 = *((_DWORD *)this + 3);
  v8 = RB::pixel_format_name(*((RB **)this + 10), v7);
  v9 = RB::color_space_name(*((unsigned __int8 *)this + 72));
  RB::SexpString::printf(a2, 0, "%p [%d %d] @%u %s %s", this, v5, v4, v6, v8, v9);
  if (*((_QWORD *)this + 11))
  {
    RB::SexpString::push(a2, "texture");
    RB::SexpString::printf(a2, 0, "%p (offset %d %d)", *((const void **)this + 11), *((_QWORD *)this + 8), HIDWORD(*((_QWORD *)this + 8)));
    RB::SexpString::pop(a2);
  }
  if (*((_QWORD *)this + 4))
  {
    RB::SexpString::push(a2, "children");
    for (i = (RB::RenderTask *)*((_QWORD *)this + 4); i; i = (RB::RenderTask *)*((_QWORD *)i + 5))
      RB::RenderTask::print(i, (RB::SexpString *)a2);
    RB::SexpString::pop(a2);
  }
  if (*((_QWORD *)this + 3))
  {
    RB::SexpString::push(a2, "continuation-of");
    RB::RenderTask::print(*((RB::RenderTask **)this + 3), (RB::SexpString *)a2);
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
}

void RB::Filter::RenderGroup::~RenderGroup(RB::Filter::RenderGroup *this)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t *v5;
  uint64_t v6;

  v2 = (uint64_t *)*((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  if (v3)
  {
    v4 = 0;
    v5 = v2 + 1;
    do
    {
      v6 = *v5;
      *v5 = 0;
      if (v6)
      {
        (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
        v3 = *((_QWORD *)this + 2);
      }
      ++v4;
      v5 += 7;
    }
    while (v4 < v3);
    v2 = (uint64_t *)*((_QWORD *)this + 1);
  }
  if (v2)
    free(v2);
}

void *RB::vector<RB::RenderTask *,32ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 32), __dst, 0x20u, (_DWORD *)__dst + 67, v3);
  *((_QWORD *)__dst + 32) = result;
  return result;
}

uint64_t *RBFillData::apply<RB::DestroyAny>(uint64_t *result, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  if (*(_DWORD *)result == 5)
    return (uint64_t *)RB::DestroyAny::operator()<RB::Fill::Custom>(a2, result + 2);
  if (*(_DWORD *)result == 3)
  {
    result = (uint64_t *)result[3];
    if (result)
    {
      v2 = (unsigned int *)(result + 1);
      do
      {
        v3 = __ldxr(v2);
        v4 = v3 - 1;
      }
      while (__stlxr(v4, v2));
      if (!v4)
      {
        __dmb(9u);
        return (uint64_t *)(*(uint64_t (**)(uint64_t *))(*result + 8))(result);
      }
    }
  }
  return result;
}

void RBFillData::~RBFillData(RBFillData *this)
{
  char v2;

  RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v2);
  this->type = 0;
}

unint64_t RBFillData::decode(RBFillData *this, RB::Heap **a2)
{
  unint64_t result;
  unint64_t v5;
  unsigned __int8 *v6;
  RB::Heap *v12;
  _BYTE v13[16];
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  uint64_t v17;

  result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    v5 = result;
    v6 = &this->data[12];
    __asm { FMOV            V9.2S, #1.0 }
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v16);
          *(_QWORD *)&this->data[12] = 0x3C00000000000000;
          *(_WORD *)&this->data[20] = 0;
          this->type = 1;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Color::decode((uint64_t)&this->data[12], (RB::ProtobufDecoder *)a2);
          goto LABEL_15;
        case 2u:
          RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v16);
          *(_QWORD *)&this->data[59] = 0;
          *(_OWORD *)&this->data[28] = 0u;
          *(_OWORD *)&this->data[44] = 0u;
          *(_OWORD *)v6 = 0u;
          *(_WORD *)&this->data[67] = 1;
          this->type = 2;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Gradient::decode((unint64_t *)&this->data[12], a2);
          goto LABEL_15;
        case 3u:
          RB::ImageTexture::ImageTexture((RB::ImageTexture *)v13, 0, 0);
          v12 = a2[8];
          RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v16);
          this->type = 0;
          RB::ImageTexture::ImageTexture((RB::ImageTexture *)&this->data[12], (const RB::ImageTexture *)v13, v12);
          *(_QWORD *)&this->data[28] = 0;
          *(_QWORD *)&this->data[36] = _D9;
          *(_QWORD *)&this->data[44] = 0;
          *(_QWORD *)&this->data[52] = 0;
          *(_OWORD *)&this->data[60] = xmmword_209BD5460;
          *(_OWORD *)&this->data[76] = xmmword_209BD5460;
          *(_DWORD *)&this->data[92] = 1065353216;
          *(_QWORD *)&this->data[96] = 0x3C003C003C003C00;
          *(_DWORD *)&this->data[104] = 0x1000000;
          this->type = 4;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::ImageData::decode((RB::ProtobufDecoder *)a2, (uint64_t)&this->data[28], (uint64_t)&v16);
          v14 = v16;
          v15 = v17;
          RB::ImageTexture::decode((uint64_t)&this->data[12], (RB::ProtobufDecoder *)a2, (uint64_t)&v14);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
          goto LABEL_16;
        case 4u:
          RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v16);
          *(_QWORD *)&this->data[12] = 0;
          *(_QWORD *)&this->data[116] = 0;
          *(_QWORD *)&this->data[124] = 0;
          *(_QWORD *)&this->data[132] = 4;
          *(_OWORD *)&this->data[140] = xmmword_209BD5290;
          *(_OWORD *)&this->data[156] = xmmword_209BD52A0;
          *(_OWORD *)&this->data[172] = 0u;
          *(_OWORD *)&this->data[188] = 0u;
          *(_DWORD *)&this->data[204] = 0;
          this->type = 5;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::Fill::Custom::decode((RB::Fill::Custom *)&this->data[12], (RB::Decoder *)a2);
          goto LABEL_15;
        case 5u:
          RBFillData::apply<RB::DestroyAny>((uint64_t *)&this->type, (uint64_t)&v16);
          *(_WORD *)&this->data[44] = 0;
          *(_OWORD *)v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(_DWORD *)&this->data[46] = 15360;
          this->data[50] = 0;
          this->data[51] = this->data[51] & 0xE0 | 0x10;
          this->data[52] = 0;
          this->type = 3;
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            RB::Fill::MeshGradient::decode((uint64_t)&this->data[12], a2);
LABEL_15:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_18:
            *((_BYTE *)a2 + 56) = 1;
            *a2 = a2[1];
          }
LABEL_16:
          result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
          v5 = result;
          if (!result)
            return result;
          continue;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v5);
          goto LABEL_16;
      }
    }
  }
  return result;
}

uint64_t RB::DestroyAny::operator()<RB::Fill::Custom>(uint64_t a1, uint64_t *a2)
{
  void *v3;
  const void **v4;
  unint64_t v5;
  uint64_t result;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v3 = (void *)a2[13];
  if (v3)
    v4 = (const void **)a2[13];
  else
    v4 = (const void **)(a2 + 1);
  if (a2[14])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a2[14]);
    v3 = (void *)a2[13];
  }
  if (v3)
    free(v3);
  result = *a2;
  if (*a2)
  {
    v7 = (unsigned int *)(result + 8);
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  return result;
}

double RB::BoundsAccumulator::reset(RB::BoundsAccumulator *this)
{
  double result;

  result = 0.0;
  *((_OWORD *)this + 4) = 0u;
  *((_OWORD *)this + 5) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *(_OWORD *)this = 0u;
  *((_OWORD *)this + 1) = 0u;
  return result;
}

int *RB::BoundsAccumulator::add(int *this, int32x2_t *a2)
{
  int32x2_t v2;
  uint32x2_t v3;
  unsigned __int32 v4;
  int v5;
  unsigned int v6;
  _DWORD *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int *v11;
  int *v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  int v17;
  int32x2_t v18;
  int v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v32;
  int v33;
  BOOL v34;
  _DWORD *v35;
  int v36;
  int v37;
  uint64_t v38;
  int v39;
  uint64_t v40;
  int v41;
  int32x2_t v42;
  int v43;
  __int32 v44;
  __int32 v45;
  _DWORD *v46;
  _DWORD *v47;
  int *v48;
  int v49;
  __int32 v50;
  int v51;
  __int32 v52;
  uint64_t v53;
  __int32 *v54;
  int v55;
  int v56;
  __int32 v57;
  int v58;
  int v59;
  __int32 v60;
  int v61;
  __int32 v62;
  int v63;
  int v64;
  __int32 v65;
  int v66;
  int v67;
  int v68;
  int v69;
  int v71;
  int v72;

  v2 = a2[1];
  v3 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v2);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    return this;
  v4 = vmul_lane_s32(v2, v2, 1).u32[0];
  v5 = *this;
  v6 = this[1];
  v7 = this + 2;
  v8 = 0xFFFFFFFFLL;
  v9 = v6;
  do
  {
    if ((_DWORD)v9 == v5)
      goto LABEL_40;
    v10 = v5 + ((((int)v9 - 1) * (int)v9) >> 1);
    if ((int)v9 < v5)
      v10 = v9 + (((v5 - 1) * v5) >> 1);
    v11 = &v7[4 * (_DWORD)v9];
    v12 = &this[v10 + 18];
    v14 = *v11;
    v13 = v11[1];
    v15 = v13 - *v11;
    v16 = v9;
    if (v15 < 1)
      goto LABEL_21;
    v17 = HIDWORD(*(unint64_t *)a2);
    v18 = vadd_s32(a2[1], *a2);
    v19 = (int)*a2;
    v21 = v11[2];
    v20 = v11[3];
    if (v14 >= v19)
      v22 = (int)*a2;
    else
      v22 = v14;
    if (v13 <= v18.i32[0])
      v23 = v18.i32[0];
    else
      v23 = v13;
    v24 = v23 - v22;
    if (v21 >= v17)
      v25 = HIDWORD(*(unint64_t *)a2);
    else
      v25 = v21;
    if (v20 <= v18.i32[1])
      v26 = v18.i32[1];
    else
      v26 = v20;
    v27 = (v26 - v25) * v24 - (v4 + (v20 - v21) * v15);
    if (!v27)
    {
      v16 = v8;
LABEL_21:
      *v12 = 0;
      v8 = v16;
      goto LABEL_40;
    }
    if (v20 >= v18.i32[1])
      v20 = v18.i32[1];
    if (v21 > v17)
      v17 = v21;
    v28 = v20 - v17;
    if (v13 >= v18.i32[0])
      v13 = v18.i32[0];
    if (v14 <= v19)
      v14 = (int)*a2;
    v29 = v13 - v14;
    v30 = v28 * v29;
    if (v28 <= 0 || v29 <= 0)
      v32 = 0;
    else
      v32 = v28 * v29;
    v33 = v32 + v27;
    *v12 = v33;
    if (v33)
      v34 = 0;
    else
      v34 = v30 == v4;
    if (v34)
    {
      this[1] = v9;
      return this;
    }
LABEL_40:
    if ((_DWORD)v9 == 3)
      v9 = 0;
    else
      v9 = (v9 + 1);
  }
  while ((_DWORD)v9 != v6);
  if ((int)v8 >= 1)
  {
    v35 = &v7[4 * v5];
    *v35 = *a2;
    v35[1] = *(_QWORD *)&a2[1] + *(_QWORD *)a2;
    v35[2] = a2->i32[1];
    v35[3] = a2[1].i32[1] + a2->i32[1];
    *this = v8;
    this[1] = v5;
    return this;
  }
  v36 = v5 == 0;
  v37 = 0x40000000;
  v38 = 1;
  v39 = v5;
  do
  {
    v40 = 0;
    do
    {
      if (this[((((int)v38 - 1) * (int)v38) >> 1) + 18 + v40] < v37)
      {
        v36 = v40;
        v37 = this[((((int)v38 - 1) * (int)v38) >> 1) + 18 + v40];
        v39 = v38;
      }
      ++v40;
    }
    while (v38 != v40);
    ++v38;
  }
  while (v38 != 4);
  v41 = HIDWORD(*(unint64_t *)a2);
  v42 = vadd_s32(a2[1], *a2);
  v43 = (int)*a2;
  v44 = v42.i32[1];
  v45 = v42.i32[0];
  if (v36 == v5)
  {
    v36 = v39;
    goto LABEL_55;
  }
  if (v39 == v5)
  {
LABEL_55:
    v39 = v5;
  }
  else
  {
    v46 = &v7[4 * v5];
    *v46 = v43;
    v46[1] = v42.i32[0];
    v46[2] = v41;
    v46[3] = v42.i32[1];
    v47 = &v7[4 * v39];
    v43 = *v47;
    v45 = v47[1];
    v41 = v47[2];
    v44 = v47[3];
    *(_QWORD *)v47 = 0;
    *((_QWORD *)v47 + 1) = 0;
  }
  v48 = &v7[4 * v36];
  *this = v39;
  v49 = *v48;
  v50 = v48[1];
  if (*v48 > v43)
  {
    *v48 = v43;
    v49 = v43;
  }
  v51 = v48[2];
  if (v50 < v45)
  {
    v48[1] = v45;
    v50 = v45;
  }
  v52 = v48[3];
  if (v51 > v41)
  {
    v48[2] = v41;
    v51 = v41;
  }
  this[1] = v36;
  if (v52 < v44)
  {
    v48[3] = v44;
    v52 = v44;
  }
  v53 = 0;
  v54 = this + 3;
  do
  {
    if (v36 != v53)
    {
      v55 = v36 + ((((int)v53 - 1) * (int)v53) >> 1);
      if (v53 < v36)
        v55 = (((v36 - 1) * v36) >> 1) + v53;
      v56 = *(v54 - 1);
      v57 = *v54;
      v58 = *v54 - v56;
      if (v58 < 1)
      {
        v72 = 0;
      }
      else
      {
        v59 = v54[1];
        v60 = v54[2];
        if (v56 >= v49)
          v61 = v49;
        else
          v61 = *(v54 - 1);
        if (v57 <= v50)
          v62 = v50;
        else
          v62 = *v54;
        v63 = v62 - v61;
        if (v59 >= v51)
          v64 = v51;
        else
          v64 = v54[1];
        if (v60 <= v52)
          v65 = v52;
        else
          v65 = v54[2];
        v66 = (v52 - v51) * (v50 - v49) + (v60 - v59) * v58;
        v67 = (v65 - v64) * v63;
        if (v60 >= v52)
          v60 = v52;
        if (v59 <= v51)
          v59 = v51;
        v68 = v60 - v59;
        if (v57 >= v50)
          v57 = v50;
        if (v56 <= v49)
          v56 = v49;
        v69 = v57 - v56;
        if (v68 <= 0 || v69 <= 0)
          v71 = 0;
        else
          v71 = v68 * v69;
        v72 = v67 - v66 + v71;
        if (v67 == v66)
          v72 = 0;
      }
      this[v55 + 18] = v72;
    }
    ++v53;
    v54 += 4;
  }
  while (v53 != 4);
  return this;
}

BOOL RB::BoundsAccumulator::intersects(RB::BoundsAccumulator *this, int32x2_t *a2, double a3, double a4, double a5, double a6, double a7, int32x2_t a8)
{
  unint64_t v8;
  int32x2_t v9;
  uint32x2_t v10;
  int32x2_t v11;
  int32x2_t *v12;
  BOOL v13;
  unsigned __int32 v14;
  int32x2_t v15;
  int32x2_t v17;
  uint32x2_t v18;
  int32x2_t v19;
  uint32x2_t v20;

  v8 = 0;
  v9 = a2[1];
  v10 = (uint32x2_t)vceqz_s32(v9);
  v11 = vadd_s32(v9, *a2);
  v12 = (int32x2_t *)((char *)this + 16);
  v13 = 1;
  v14 = vpmax_u32(v10, v10).u32[0];
  do
  {
    v15 = vsub_s32(vdup_lane_s32(*v12, 1), *v12);
    if (v12[-1].i32[1] - v12[-1].i32[0] >= 1 && v15.i32[0] >= 1 && (v14 & 0x80000000) == 0)
    {
      a8.i32[0] = v12[-1].i32[1] - v12[-1].i32[0];
      v17 = vzip1_s32(a8, v15);
      v18 = (uint32x2_t)vceqz_s32(v17);
      a8 = (int32x2_t)vpmax_u32(v18, v18);
      if ((a8.i32[0] & 0x80000000) == 0)
      {
        a8.i32[0] = v12[-1].i32[0];
        v19 = vzip1_s32(a8, *v12);
        a8 = vmax_s32(v19, *a2);
        v20 = (uint32x2_t)vcge_s32(a8, vmin_s32(vadd_s32(v17, v19), v11));
        if ((vpmax_u32(v20, v20).u32[0] & 0x80000000) == 0)
          break;
      }
    }
    v13 = v8 < 3;
    v12 += 2;
    ++v8;
  }
  while (v8 != 4);
  return v13;
}

void sub_209B57DB4(_Unwind_Exception *a1)
{
  void *v1;
  os_unfair_lock_s *v2;

  os_unfair_lock_unlock(v2);

  _Unwind_Resume(a1);
}

void sub_209B57F28(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209B59180(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, os_unfair_lock_s *lock, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, CFTypeRef cf, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  uint64_t a65;

  RB::Symbol::Presentation::~Presentation((RB::Symbol::Presentation *)&a65);
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void sub_209B59394(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

_anonymous_namespace_::Updater *`anonymous namespace'::Updater::Updater(_anonymous_namespace_::Updater *this, RBSymbolLayer *a2, RB::Symbol::Animator *a3)
{
  RB::Symbol::Presentation *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  double v9;
  double v10;
  float64x2_t v11;
  int32x4_t v12;
  double v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float32x2_t v17;
  uint32x2_t v18;
  BOOL v19;
  float32x2_t v21;
  float32x2_t v22;

  *(_QWORD *)this = a2;
  v5 = (_anonymous_namespace_::Updater *)((char *)this + 16);
  RB::Symbol::Presentation::Presentation((char *)this + 16, a3, 0, 0, 255, 0, (__n128)0);
  v6 = 0uLL;
  v7 = 0uLL;
  v8 = 0uLL;
  if (a2)
  {
    v6 = *((_OWORD *)a2 + 6);
    *(_QWORD *)&v8 = *((_QWORD *)a2 + 10);
    *((_QWORD *)&v7 + 1) = *((_QWORD *)a2 + 11);
  }
  *((_OWORD *)this + 131) = v8;
  *((_OWORD *)this + 132) = v7;
  *((_OWORD *)this + 133) = v6;
  -[RBSymbolLayer contentsScale](a2, "contentsScale");
  *((double *)this + 272) = v9;
  v13 = RB::Symbol::Presentation::bounding_rect(v5, v9, v10, v11, v12);
  v21 = RB::operator*((float64x2_t *)this + 131, *(float32x2_t *)&v13, v14);
  v22 = v15;
  v16 = *((double *)this + 272);
  RB::Rect::round_outwards_by_scale(&v21, v16);
  v17 = v22;
  *((float64x2_t *)this + 134) = vcvtq_f64_f32(v21);
  *((float64x2_t *)this + 135) = vcvtq_f64_f32(v17);
  v18 = (uint32x2_t)vclez_f32(v17);
  v19 = (vpmax_u32(v18, v18).u32[0] & 0x80000000) != 0 || *((double *)this + 272) == 0.0 || *((_DWORD *)this + 216) == 0;
  *((_BYTE *)this + 2184) = v19;
  return this;
}

void sub_209B594B0(_Unwind_Exception *a1)
{
  RB::Symbol::Presentation *v1;

  RB::Symbol::Presentation::~Presentation(v1);
  _Unwind_Resume(a1);
}

void sub_209B5971C(_Unwind_Exception *a1)
{
  RB::Symbol::Presentation *v1;

  RB::Symbol::Presentation::~Presentation(v1);
  _Unwind_Resume(a1);
}

__n128 `anonymous namespace'::Updater::drawing_transform(RB::Symbol::Model **this, CALayer *a2)
{
  RB::Symbol::Model::glyph_info(this[2]);
  if (a2 && !-[CALayer contentsAreFlipped](a2, "contentsAreFlipped"))
    return *((__n128 *)this + 131);
  else
    return *((__n128 *)this + 131);
}

void sub_209B599FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B59B70(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t ___ZN12_GLOBAL__N_17Updater13update_mergedEv_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return objc_msgSend(**(id **)(a1 + 32), "resolveStyle:colorName:", a2, a3);
}

void ___ZN12_GLOBAL__N_17Updater13update_mergedEv_block_invoke_2(_QWORD *a1, uint64_t a2)
{
  RB::Symbol::Model **v3;
  RB::DisplayList::State *State;
  __int128 v5;
  __int128 v6;
  _OWORD v7[3];

  v3 = (RB::Symbol::Model **)a1[6];
  State = (RB::DisplayList::State *)RBDisplayListGetState(a2);
  v7[1] = v5;
  v7[2] = v6;
  RBDrawingStateConcatCTM((uint64_t)State, (uint64_t)v7);
  RB::Symbol::Presentation::draw((uint64_t)(v3 + 2), State, a1[5]);
}

uint64_t color_symbols(void)
{
  unsigned __int8 v0;
  const char *v2;
  unsigned int v3;

  {
    v3 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_COLOR_SYMBOLS", v2);
    if (v3 <= 0x100)
      LOBYTE(v3) = 0;
    color_symbols(void)::flag = v3 != 0;
  }
  return color_symbols(void)::flag;
}

void sub_209B59CB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *RB::vector<`anonymous namespace'::Updater::update_shape_layers(BOOL)::Group,2ul,unsigned long>::~vector(char *a1)
{
  char *v2;
  char *v3;
  unint64_t v4;
  char *v5;
  void *v6;
  unint64_t v7;
  char *v8;
  unint64_t v9;
  CFTypeRef *v10;

  v2 = (char *)*((_QWORD *)a1 + 104);
  if (v2)
    v3 = v2;
  else
    v3 = a1;
  if (*((_QWORD *)a1 + 105))
  {
    v4 = 0;
    do
    {
      v5 = &v3[416 * v4];
      v6 = (void *)*((_QWORD *)v5 + 48);
      v7 = *((_QWORD *)v5 + 49);
      if (v6)
        v8 = (char *)*((_QWORD *)v5 + 48);
      else
        v8 = &v3[416 * v4];
      if (v7)
      {
        v9 = 0;
        v10 = (CFTypeRef *)(v8 + 16);
        do
        {
          if (*v10)
          {
            CFRelease(*v10);
            v7 = *((_QWORD *)v5 + 49);
          }
          ++v9;
          v10 += 12;
        }
        while (v9 < v7);
        v6 = (void *)*((_QWORD *)v5 + 48);
      }
      if (v6)
        free(v6);
      ++v4;
    }
    while (v4 < *((_QWORD *)a1 + 105));
    v2 = (char *)*((_QWORD *)a1 + 104);
  }
  if (v2)
    free(v2);
  return a1;
}

void *RB::vector<`anonymous namespace'::Updater::update_shape_layers(BOOL)::Group,2ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 106) + (*((_QWORD *)__dst + 106) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 106) + (*((_QWORD *)__dst + 106) >> 1);
  result = RB::details::realloc_vector<unsigned long,416ul>(*((void **)__dst + 104), __dst, 2uLL, (unint64_t *)__dst + 106, v3);
  *((_QWORD *)__dst + 104) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,416ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 416 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(416 * a5);
    v9 = v8 / 0x1A0;
    if (v8 / 0x1A0 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 416 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<`anonymous namespace'::Updater::update_shape_layers(BOOL)::LayerPath,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 50) + (*((_QWORD *)__dst + 50) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 50) + (*((_QWORD *)__dst + 50) >> 1);
  result = RB::details::realloc_vector<unsigned long,96ul>(*((void **)__dst + 48), __dst, 4uLL, (unint64_t *)__dst + 50, v3);
  *((_QWORD *)__dst + 48) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,96ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 96 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(96 * a5);
    v9 = v8 / 0x60;
    if (v8 / 0x60 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 96 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::Item::clip_affects_blurred_bounds(RB::DisplayList::Item *this, float a2)
{
  double v4;
  double v5;
  double v7;
  double v8;

  if (!*((_QWORD *)this + 3))
    return 0;
  v4 = (*(double (**)(RB::DisplayList::Item *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
  v7 = v4;
  v8 = v5;
  *(float *)&v4 = -ceilf(a2 * 2.8);
  RB::Rect::inset((float32x2_t *)&v7, *(float32x2_t *)&v4, *(float32_t *)&v4);
  return RB::DisplayList::ClipNode::contains(*((_QWORD **)this + 3), v7, v8) ^ 1;
}

uint64_t RB::DisplayList::Item::may_mix(RB::DisplayList::Item *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Item *a3, const RB::DisplayList::Style *a4)
{
  uint64_t result;
  unsigned __int8 can_mix;
  unsigned __int8 v9;
  unsigned int v10;

  if (((*((_WORD *)a3 + 23) ^ *((_WORD *)this + 23)) & 0x3F) != 0)
    return 0;
  can_mix = RB::DisplayList::can_mix(a2, *((RB::DisplayList::Interpolator::Contents **)this + 2), *((_QWORD *)a3 + 2), a4);
  if (can_mix)
  {
    v9 = can_mix;
    v10 = RB::DisplayList::can_mix((uint64_t)a2, *((float32x2_t **)this + 3), *((float32x2_t **)a3 + 3), (uint64_t)this, (uint64_t)a3);
    if (v10 >= v9)
      result = v9;
    else
      result = v10;
  }
  else
  {
    result = 0;
  }
  _H0 = *((_WORD *)this + 22);
  _H1 = *((_WORD *)a3 + 22);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (_S0 != _S1)
  {
    if (result >= 2)
      return 2;
    else
      return result;
  }
  return result;
}

uint64_t RB::DisplayList::Item::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v6;
  uint64_t result;
  uint64_t v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  uint64_t v12;
  int v13;
  float v14;

  v14 = a5;
  v13 = a3;
  v6 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v12 = a1;
  result = RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *,float &,RB::ClipMode &>(v6, (uint64_t)&v12, &v14);
  v8 = result;
  v9 = a4[5];
  v10 = v9 + 1;
  if (a4[6] < (unint64_t)(v9 + 1))
  {
    result = (uint64_t)RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v10);
    v9 = a4[5];
    v10 = v9 + 1;
  }
  v11 = (_QWORD *)a4[4];
  if (!v11)
    v11 = a4;
  v11[v9] = v8;
  a4[5] = v10;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *,float &,RB::ClipMode &>(size_t *a1, uint64_t a2, float *a3)
{
  unint64_t v4;

  v4 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v4 + 56 > a1[3])
    RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v4 + 56;
  return RB::DisplayList::ItemClip::ItemClip(*a3);
}

RB::DisplayList::Item *RB::DisplayList::Item::project(RB::DisplayList::Item *this, RB::DisplayList::Builder *a2, const RB::Path::Projection *a3, float64x2_t *a4, char a5)
{
  float64x2_t v9;
  float64x2_t *v10;
  float64x2_t v11;
  float64x2_t v12;
  int v13;
  float32x2_t v14;
  float32x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t *v26;
  float32x2_t v27;
  float32x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v37;
  const RB::Path::Projection *v38;
  RB::DisplayList::Builder *v39;
  float64x2_t *v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  _BYTE v50[80];
  _QWORD v51[17];

  v51[14] = *MEMORY[0x24BDAC8D0];
  v38 = a3;
  v39 = a2;
  v40 = a4;
  v9 = a4[1];
  v47 = *a4;
  v48 = v9;
  v49 = a4[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v47))
    v10 = &v47;
  else
    v10 = a4;
  v11 = v10[1];
  v12 = v10[2];
  v41 = *v10;
  v42 = v11;
  v43 = v12;
  if ((a5 & 2) != 0
    || (v13 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(_QWORD *)this + 40))(this),
        (v13 + 1) <= 2))
  {
    *(double *)&v14 = (*(double (**)(RB::DisplayList::Item *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
    v16 = vcvtq_f64_f32(vmla_f32(v14, (float32x2_t)0x3F0000003F000000, v15));
    v44 = xmmword_209BD5290;
    v45 = xmmword_209BD52A0;
    v46 = 0uLL;
    if (RB::Path::Projection::project((uint64_t)v38, (uint64_t)&v44, vcvtq_f64_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(v43, v41, v16.f64[0]), v42, v16, 1)))))
    {
      v17.f64[0] = RB::operator*(&v41, (float64x2_t *)&v44);
      v47 = v17;
      v48 = v18;
      v49 = v19;
      *(double *)&v20 = RB::operator*(&v47, v40);
      v44 = v20;
      v45 = v21;
      v46 = v22;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v47, (uint64_t)v39, &v44, 0, 0, 0);
      (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(_QWORD *)this + 32))(this, &v47, 1);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v51);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v50);
      RB::Heap::~Heap((RB::Heap *)&v47.f64[1]);
    }
  }
  else
  {
    v23 = 0;
    v37 = 0;
    v24 = &v37;
    do
    {
      v25 = (*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t, uint64_t, _QWORD))(*(_QWORD *)this + 48))(this, a2, v23, 1, 0);
      v26 = (uint64_t *)v25;
      if (v25)
      {
        *(double *)&v27 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)v25 + 144))(v25, 0);
        v29 = vcvtq_f64_f32(vmla_f32(v27, (float32x2_t)0x3F0000003F000000, v28));
        v44 = xmmword_209BD5290;
        v45 = xmmword_209BD52A0;
        v46 = 0uLL;
        if (RB::Path::Projection::project((uint64_t)v38, (uint64_t)&v44, vcvtq_f64_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(v43, v41, v29.f64[0]), v42, v29, 1)))))
        {
          v30.f64[0] = RB::operator*(&v41, (float64x2_t *)&v44);
          v47 = v30;
          v48 = v31;
          v49 = v32;
          *(double *)&v33 = RB::operator*(&v47, v40);
          v44 = v33;
          v45 = v34;
          v46 = v35;
          RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v47, (uint64_t)v39, &v44, 0, 0, 0);
          (*(void (**)(uint64_t *, float64x2_t *, uint64_t))(*v26 + 32))(v26, &v47, 1);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v51);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v50);
          RB::Heap::~Heap((RB::Heap *)&v47.f64[1]);
        }
        *v24 = (uint64_t)v26;
        v24 = v26 + 1;
      }
      v23 = (v23 + 1);
    }
    while (v13 != (_DWORD)v23);
    *v24 = 0;
    (**(void (***)(RB::DisplayList::Item *))this)(this);
    return (RB::DisplayList::Item *)v37;
  }
  return this;
}

void sub_209B5A52C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, RB::Heap *a10)
{
  uint64_t v10;

  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v10 + 1368));
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v10 + 1288));
  RB::Heap::~Heap((RB::Heap *)(v10 | 8));
  _Unwind_Resume(a1);
}

void RB::DisplayList::Item::print(RB::DisplayList::Item *this, std::string *a2)
{
  unsigned int v11;
  const char *v12;
  uint64_t *v13;
  uint64_t *v14;
  _QWORD *i;
  _QWORD *v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t *v19;
  uint64_t *v20;

  if ((*((_WORD *)this + 23) & 0x800) != 0)
    RB::SexpString::print(a2, 0, "disable-mix");
  _H0 = *((_WORD *)this + 22);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
  {
    __asm { FCVT            D0, H0 }
    RB::SexpString::printf(a2, 0, "(alpha %g)", _D0);
  }
  v11 = *((_WORD *)this + 23) & 0x3F;
  if (v11 != 2)
  {
    v12 = RB::blend_name(v11);
    RB::SexpString::printf(a2, 0, "(blend %s)", v12);
  }
  if (*((_DWORD *)this + 10))
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 10));
  v13 = (uint64_t *)*((_QWORD *)this + 4);
  if (v13 && RB::DisplayList::Metadata::numeric_value(v13))
  {
    v14 = RB::DisplayList::Metadata::numeric_value(*((uint64_t **)this + 4));
    RB::SexpString::printf(a2, 0, "(numeric-value %g)", *(float *)v14);
  }
  if (*((_QWORD *)this + 2))
  {
    RB::SexpString::push(a2, "styles");
    for (i = (_QWORD *)*((_QWORD *)this + 2); i; i = (_QWORD *)i[4])
      (*(void (**)(_QWORD *, std::string *))(*i + 112))(i, a2);
    RB::SexpString::pop(a2);
    a2[1].__r_.__value_.__s.__data_[16] = 1;
  }
  v16 = (_QWORD *)*((_QWORD *)this + 3);
  if (v16)
  {
    do
    {
      (*(void (**)(unint64_t, std::string *))(*(_QWORD *)(v16[1] & 0xFFFFFFFFFFFFFFFELL) + 128))(v16[1] & 0xFFFFFFFFFFFFFFFELL, a2);
      v16 = (_QWORD *)*v16;
    }
    while (v16);
    a2[1].__r_.__value_.__s.__data_[16] = 1;
  }
  v17 = (uint64_t *)*((_QWORD *)this + 4);
  if (v17)
  {
    if (RB::DisplayList::Metadata::transition(v17))
    {
      v18 = RB::DisplayList::Metadata::transition(*((uint64_t **)this + 4));
      RB::Transition::print((RB::Transition *)v18, a2);
      a2[1].__r_.__value_.__s.__data_[16] = 1;
    }
    v19 = (uint64_t *)*((_QWORD *)this + 4);
    if (v19)
    {
      if (RB::DisplayList::Metadata::text_identity(v19))
      {
        v20 = RB::DisplayList::Metadata::text_identity(*((uint64_t **)this + 4));
        RB::TextIdentity::print((RB::TextIdentity *)v20, a2);
        a2[1].__r_.__value_.__s.__data_[16] = 1;
      }
    }
  }
}

__int16 RB::DisplayList::LayerItem::LayerItem@<H0>(uint64_t a1@<X0>, char a2@<W1>, uint64_t a3@<X2>, float _S0@<S0>)
{
  __int16 v4;
  __int16 result;

  v4 = 512;
  if (a3)
  {
    if ((*(_WORD *)(a3 + 60) & 0x2001) != 0)
      v4 = 1536;
    else
      v4 = 512;
  }
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = result;
  *(_WORD *)(a1 + 46) = v4 | a2 & 0x3F;
  *(_QWORD *)a1 = &off_24C228AD0;
  *(_QWORD *)(a1 + 48) = a3;
  return result;
}

__n128 RB::DisplayList::LayerItem::copy(RB::DisplayList::LayerItem *this, RB::DisplayList::Builder *a2, unsigned int a3)
{
  __n128 result;
  RB::Heap *v6;
  __n128 *v7;
  int v8;
  uint64_t v9;

  if ((a3 & 4) != 0 && (*((_WORD *)this + 23) & 0x3F) != 0x18)
    a3 &= ~4u;
  v9 = RB::DisplayList::Layer::copy(*((RB::DisplayList::Layer **)this + 6), a2, a3);
  if (v9)
  {
    v6 = (RB::Heap *)(*((_QWORD *)a2 + 1) + 16);
    v8 = *((_WORD *)this + 23) & 0x3F;
    v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRKDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v6, (__int16 *)this + 22, &v8, &v9);
    result = *((__n128 *)this + 1);
    v7[1] = result;
    v7[2].n128_u64[0] = *((_QWORD *)this + 4);
    v7[2].n128_u32[2] = *((_DWORD *)this + 10);
  }
  return result;
}

uint64_t _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRKDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(RB::Heap *this, __int16 *a2, int *a3, uint64_t *a4)
{
  unint64_t v8;
  uint64_t result;
  __int16 v10;
  int v11;
  __int16 v12;
  uint64_t v13;

  v8 = *((_QWORD *)this + 3);
  result = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 56 > v8)
    result = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 56;
  v10 = *a2;
  v11 = *a3;
  v12 = 512;
  v13 = *a4;
  if (*a4)
  {
    if ((*(_WORD *)(v13 + 60) & 0x2001) != 0)
      v12 = 1536;
    else
      v12 = 512;
  }
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_DWORD *)(result + 40) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_WORD *)(result + 44) = v10;
  *(_WORD *)(result + 46) = v12 | v11 & 0x3F;
  *(_QWORD *)result = &off_24C228AD0;
  *(_QWORD *)(result + 48) = v13;
  return result;
}

uint64_t RB::DisplayList::LayerItem::disable_subpixel_quantization(uint64_t this, float64x2_t *a2)
{
  float64x2_t v2;
  uint64_t v3;
  float v4;
  double v5;
  _QWORD *v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;

  v2 = a2[1];
  v7 = *a2;
  v8 = v2;
  v9 = a2[2];
  v3 = *(_QWORD *)(this + 48);
  v4 = *(float *)(v3 + 48);
  if (v4 != 0.0)
  {
    v5 = v4;
    v7 = vmulq_n_f64(v7, v5);
    v8 = vmulq_n_f64(v8, v5);
    v9 = vmulq_n_f64(v9, v5);
  }
  v6 = *(_QWORD **)v3;
  if (*(_QWORD *)v3)
  {
    do
    {
      this = (*(uint64_t (**)(_QWORD *, float64x2_t *))(*v6 + 128))(v6, &v7);
      v6 = (_QWORD *)v6[1];
    }
    while (v6);
  }
  return this;
}

uint64_t RB::DisplayList::LayerItem::can_append_color_matrix(uint64_t a1, uint64_t a2, uint64_t a3, unsigned __int16 a4)
{
  unsigned int v4;
  uint64_t v5;
  int v7;
  int v8;
  _QWORD *v9;
  _DWORD *v10;
  unsigned int v12;
  int v14;
  unsigned int v16;

  v4 = a3;
  v5 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v5 + 64) == 2)
    return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD))(**(_QWORD **)(v5 + 24) + 56))(*(_QWORD *)(v5 + 24), a2, a3, a4);
  v7 = a4;
  v8 = HIBYTE(a4);
  v9 = *(_QWORD **)(v5 + 16);
  if (v9)
  {
    if (!v9[1] && (*(unsigned int (**)(_QWORD))(*v9 + 40))(*(_QWORD *)(v5 + 16)) == 1)
    {
      if ((*v10 & 3) == 0 || v8 == 0)
        return ((*v10 & 4) == 0) ^ v4;
      v12 = ((*v10 & 2) << 7) | (*v10 >> 1) & 1;
      if ((*v10 & 1) != 0)
        v12 = 256;
      if (v12 >= 0x100 && (v12 & 1) == v7)
        return ((*v10 & 4) == 0) ^ v4;
    }
    return 0;
  }
  v14 = *(_DWORD *)(v5 + 60);
  if ((v14 & 1) != 0)
    return 0;
  if ((v14 & 6) != 0 && HIBYTE(a4) != 0)
  {
    v16 = (v14 & 2) != 0 ? 256 : ((*(_DWORD *)(v5 + 60) & 4) << 6) | (*(_DWORD *)(v5 + 60) >> 2) & 1;
    if (v16 < 0x100 || (v16 & 1) != a4)
      return 0;
  }
  return RB::DisplayList::Builder::can_lower_color_matrix((uint64_t *)v5, a2, a3, a4, 1);
}

__int16 RB::DisplayList::LayerItem::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, uint64_t a3@<X2>, unsigned __int16 a4@<W3>, uint64_t a5@<X4>)
{
  uint64_t v8;
  __int16 result;
  uint64_t v10;
  __int128 v11;
  float v12;
  _OWORD v20[2];
  uint64_t v21;

  v8 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v8 + 64) == 2)
  {
    *(_QWORD *)(*(_QWORD *)(a1 + 48) + 24) = (*(uint64_t (**)(_QWORD, float16x4_t *, uint64_t, _QWORD))(**(_QWORD **)(v8 + 24) + 64))(*(_QWORD *)(v8 + 24), a2, a3, a4);
  }
  else
  {
    v10 = *(_QWORD *)(v8 + 16);
    if (v10)
    {
      RB::operator*(a2, (int16x4_t *)(v10 + 40), (float16x4_t *)v20);
      result = v20[0];
      v11 = v20[1];
      *(_OWORD *)(v10 + 40) = v20[0];
      *(_OWORD *)(v10 + 56) = v11;
      *(_QWORD *)(v10 + 72) = v21;
    }
    else
    {
      v12 = RB::DisplayList::Builder::lower_color_matrix(a5, (_QWORD **)v8, (uint64_t)a2, a3, a4, 1);
      _H1 = *(_WORD *)(a1 + 44);
      __asm { FCVT            S1, H1 }
      _S0 = v12 * _S1;
      __asm { FCVT            H0, S0 }
      *(_WORD *)(a1 + 44) = result;
    }
  }
  return result;
}

void RB::DisplayList::LayerItem::apply_transform(RB::DisplayList::Layer **this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)this, a2, a3);
  RB::DisplayList::Layer::apply_transform(this[6], a2);
}

uint64_t RB::DisplayList::LayerItem::required_depth(RB::DisplayList::LayerItem *this)
{
  RB::DisplayList::Layer *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  if (!v2)
    return 0;
  v3 = RB::DisplayList::Layer::output_depth(v2);
  v4 = *((_QWORD *)this + 6);
  if (*(_BYTE *)(v4 + 64) == 2)
    return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(v4 + 24) + 88))(*(_QWORD *)(v4 + 24), v3);
  return v3;
}

float32x2_t RB::DisplayList::LayerItem::bounds(RB::DisplayList::Layer **this)
{
  if (this[6] && RB::may_discard_alpha(*((_WORD *)this + 23) & 0x3F))
    return RB::DisplayList::Layer::bounds(this[6]);
  return (float32x2_t)0xFEFFFFFFFEFFFFFFLL;
}

float RB::DisplayList::LayerItem::min_scale(RB::DisplayList::LayerItem *this)
{
  RB::DisplayList::Layer *v1;
  float result;

  v1 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  if (!v1)
    return 0.0;
  RB::DisplayList::Layer::min_scale(v1);
  return result;
}

uint64_t RB::DisplayList::LayerItem::make_clip(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, float a5)
{
  uint64_t result;
  int v10;
  int v11;
  size_t *v12;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  _QWORD *v21;
  _QWORD *v22;
  int v24;
  _QWORD *v25;
  __int16 v26;
  _QWORD *i;
  _QWORD *v29;
  size_t v30;
  size_t v31;
  _QWORD *v32;
  __int128 v33[2];
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  _QWORD v37[186];

  v37[185] = *MEMORY[0x24BDAC8D0];
  v36 = a3;
  result = *(_QWORD *)(a1 + 48);
  if (!result)
    return result;
  if (*(_BYTE *)(a2 + 272))
  {
    if (!*(_BYTE *)(result + 64) && !*(_QWORD *)(result + 16))
    {
      v10 = *(_DWORD *)(result + 60);
      if ((v10 & 0x2001) == 0 && (v10 & 6) == 0 && *(float *)(result + 48) == 0.0)
      {
        v22 = *(_QWORD **)result;
        if (*(_QWORD *)result)
        {
          if (!v22[1])
          {
            v24 = (*(uint64_t (**)(_QWORD))(*v22 + 80))(*(_QWORD *)result);
            result = *(_QWORD *)(a1 + 48);
            if (v24)
            {
              v25 = *(_QWORD **)result;
              v26 = *(_WORD *)(*(_QWORD *)result + 46);
              _ZF = (v26 & 0x3F) == 0x18 || (v26 & 0x3F) == 2;
              if (_ZF && (a5 == 1.0 || !v25[3]))
              {
                if ((_DWORD)a3)
                {
                  if ((*(_WORD *)(*(_QWORD *)result + 46) & 0x2000) != 0 || v25[3])
                    goto LABEL_6;
                }
                else
                {
                  if ((*(_WORD *)(*(_QWORD *)result + 46) & 0x2000) != 0)
                    goto LABEL_6;
                  if (v25[3])
                  {
                    v33[0] = xmmword_209BD5290;
                    v33[1] = xmmword_209BD52A0;
                    v34 = 0;
                    v35 = 0;
                    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v37, a2, v33, 0, 0, 0);
                    for (i = *(_QWORD **)(**(_QWORD **)(a1 + 48) + 24); i; i = (_QWORD *)*i)
                    {
                      v29 = (_QWORD *)(*(uint64_t (**)(unint64_t, _QWORD *, _QWORD, _QWORD))(*(_QWORD *)(i[1] & 0xFFFFFFFFFFFFFFFELL) + 24))(i[1] & 0xFFFFFFFFFFFFFFFELL, v37, 0, 0);
                      if (v29)
                      {
                        v30 = a4[5];
                        do
                        {
                          v31 = v30 + 1;
                          if (a4[6] < v30 + 1)
                          {
                            RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v31);
                            v30 = a4[5];
                            v31 = v30 + 1;
                          }
                          v32 = (_QWORD *)a4[4];
                          if (!v32)
                            v32 = a4;
                          v32[v30] = v29[1];
                          a4[5] = v31;
                          v29 = (_QWORD *)*v29;
                          v30 = v31;
                        }
                        while (v29);
                      }
                    }
                    RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)v37);
                    v25 = **(_QWORD ***)(a1 + 48);
                  }
                }
                result = (*(uint64_t (**)(_QWORD *, uint64_t, uint64_t, _QWORD *, float))(*v25 + 88))(v25, a2, a3, a4, a5);
                **(_QWORD **)(a1 + 48) = 0;
                return result;
              }
            }
          }
        }
      }
    }
LABEL_6:
    v11 = *(unsigned __int8 *)(a2 + 272);
    v12 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
    if (v11)
    {
      RB::DisplayList::Layer::discard_color(result);
      result = *(_QWORD *)(a1 + 48);
    }
    goto LABEL_9;
  }
  v12 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
LABEL_9:
  *(_QWORD *)(a1 + 48) = 0;
  v37[0] = result;
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  *(float *)v33 = _S0 * a5;
  result = RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(v12, v37, (float *)v33, &v36);
  v18 = result;
  v19 = a4[5];
  v20 = v19 + 1;
  if (a4[6] < (unint64_t)(v19 + 1))
  {
    result = (uint64_t)RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v20);
    v19 = a4[5];
    v20 = v19 + 1;
  }
  v21 = (_QWORD *)a4[4];
  if (!v21)
    v21 = a4;
  v21[v19] = v18;
  a4[5] = v20;
  return result;
}

void sub_209B5AF10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::LayerItem::project(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4, uint64_t a5)
{
  uint64_t v6;
  float v7;
  double v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  uint64_t *v12;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _OWORD v21[3];

  v6 = *(_QWORD *)(a1 + 48);
  v7 = *(float *)(v6 + 48);
  if (v7 == 0.0)
    v7 = 1.0;
  v8 = v7;
  v9 = vmulq_n_f64(*a4, v8);
  v10 = vmulq_n_f64(a4[1], v8);
  v11 = vmulq_n_f64(a4[2], v8);
  v21[0] = v9;
  v21[1] = v10;
  v21[2] = v11;
  v12 = *(uint64_t **)v6;
  if (*(_QWORD *)v6)
  {
    do
    {
      v16 = v12;
      v12 = (uint64_t *)v12[1];
      v17 = *v16;
      v16[1] = 0;
      v18 = (*(uint64_t (**)(uint64_t *, uint64_t, uint64_t, _OWORD *, uint64_t))(v17 + 232))(v16, a2, a3, v21, a5);
      *(_QWORD *)v6 = v18;
      do
      {
        v19 = v18;
        v18 = *(_QWORD *)(v18 + 8);
      }
      while (v18);
      v6 = v19 + 8;
    }
    while (v12);
  }
  *(_QWORD *)v6 = 0;
  return a1;
}

void RB::DisplayList::LayerItem::print(RB::DisplayList::Layer **this, std::string *a2)
{
  RB::SexpString::push(a2, "draw-layer");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  RB::DisplayList::Layer::print(this[6], a2);
  RB::SexpString::pop(a2);
}

__int16 RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem@<H0>(uint64_t a1@<X0>, uint64_t a2@<X1>, char a3@<W2>, float _S0@<S0>)
{
  __int16 result;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  __asm { FCVT            H0, S0 }
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = result;
  *(_WORD *)(a1 + 46) = a3 & 0x3F | 0x400;
  *(_QWORD *)a1 = &off_24C228858;
  *(_QWORD *)(a1 + 48) = a2;
  return result;
}

__n128 RB::DisplayList::BackdropColorMatrixItem::copy(__n128 *this, RB::DisplayList::Builder *a2)
{
  RB::Heap *v3;
  __n128 result;
  __n128 *v5;
  int v6;

  v3 = (RB::Heap *)(*((_QWORD *)a2 + 1) + 16);
  v6 = this[2].n128_u16[7] & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRKPKNS_6Filter11ColorMatrixERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(v3, (uint64_t *)&this[3], &this[2].n128_i16[6], &v6);
  result = this[1];
  v5[1] = result;
  v5[2].n128_u64[0] = this[2].n128_u64[0];
  v5[2].n128_u32[2] = this[2].n128_u32[2];
  return result;
}

__int16 _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRKPKNS_6Filter11ColorMatrixERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_@<H0>(RB::Heap *this@<X0>, uint64_t *a2@<X1>, __int16 *a3@<X2>, _WORD *a4@<X3>)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __int16 result;
  char v12;

  v8 = *((_QWORD *)this + 3);
  v9 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 56 > v8)
    v9 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  else
    *((_QWORD *)this + 2) = v9 + 56;
  v10 = *a2;
  result = *a3;
  v12 = *a4;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 24) = 0;
  *(_DWORD *)(v9 + 40) = 0;
  *(_QWORD *)(v9 + 32) = 0;
  *(_WORD *)(v9 + 44) = result;
  *(_WORD *)(v9 + 46) = v12 & 0x3F | 0x400;
  *(_QWORD *)v9 = &off_24C228858;
  *(_QWORD *)(v9 + 48) = v10;
  return result;
}

void RB::DisplayList::BackdropColorMatrixItem::print(float16x4_t **this, std::string *a2)
{
  float16x4_t *v4;

  RB::SexpString::push(a2, "backdrop-color-matrix");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  v4 = this[6];
  if (v4)
    RB::Filter::ColorMatrix::print(v4, a2);
  RB::SexpString::pop(a2);
}

float32x2_t RB::DisplayList::CustomItem::bounds(RB::DisplayList::CustomItem *this)
{
  return RB::operator*(*((float64x2_t **)this + 7), *(float32x2_t *)((char *)this + 64), *(float32x2_t *)((char *)this + 72));
}

uint64_t RB::DisplayList::CustomItem::CustomItem(uint64_t a1, void *a2, int a3, uint64_t a4, _OWORD *a5, char a6, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x2000;
  *(_QWORD *)a1 = &off_24C224448;
  *(_QWORD *)(a1 + 48) = objc_msgSend(a2, "copy");
  *(_QWORD *)(a1 + 56) = a4;
  *(_OWORD *)(a1 + 64) = *a5;
  *(_DWORD *)(a1 + 80) = a3;
  return a1;
}

__n128 RB::DisplayList::CustomItem::copy(__n128 *this, RB::DisplayList::Builder *a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;
  unint64_t v7;

  v3 = (size_t *)(*((_QWORD *)a2 + 1) + 16);
  v7 = this[3].n128_u64[0];
  v6 = this[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList10CustomItemEJU13block_pointerFvP18RBMetalRenderStateERKjRKPKNS_15AffineTransformERKNS_4RectERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(v3, (void **)&v7, (int *)&this[5], &this[3].n128_i64[1], (__n128 *)this[4].n128_u64, &this[2].n128_i16[6], &v6);
  result = this[1];
  v4[1] = result;
  v4[2].n128_u64[0] = this[2].n128_u64[0];
  v4[2].n128_u32[2] = this[2].n128_u32[2];
  v4[2].n128_u16[7] |= this[2].n128_u16[7] & 0x5800;
  return result;
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList10CustomItemEJU13block_pointerFvP18RBMetalRenderStateERKjRKPKNS_15AffineTransformERKNS_4RectERKDF16_RKNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, void **a2, int *a3, uint64_t *a4, _OWORD *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  void *v14;
  int v15;
  uint64_t v16;
  __int16 v17;
  char v18;

  v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  else
    a1[2] = v13 + 88;
  v14 = *a2;
  v15 = *a3;
  v16 = *a4;
  v17 = *a6;
  v18 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v17;
  *(_WORD *)(v13 + 46) = v18 & 0x3F | 0x2000;
  *(_QWORD *)v13 = &off_24C224448;
  *(_QWORD *)(v13 + 48) = objc_msgSend(v14, "copy");
  *(_QWORD *)(v13 + 56) = v16;
  *(_OWORD *)(v13 + 64) = *a5;
  *(_DWORD *)(v13 + 80) = v15;
  return v13;
}

const RB::AffineTransform *RB::DisplayList::CustomItem::apply_transform(const RB::AffineTransform **this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)this, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, this[7]);
  this[7] = result;
  return result;
}

void RB::DisplayList::CustomItem::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::push(a2, "draw-custom");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)this, a2);
  RB::SexpString::printf(a2, 0, "(rect %g %g %g %g)", COERCE_FLOAT(this[8]), COERCE_FLOAT((unint64_t)this[8] >> 32), COERCE_FLOAT(this[9]), COERCE_FLOAT((unint64_t)this[9] >> 32));
  RB::SexpString::print_ctm(a2, this[7]);
  RB::SexpString::pop(a2);
}

uint64_t RB::DisplayList::Item::atom_position(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::Item::can_make_clip(RB::DisplayList::Item *this)
{
  return 1;
}

uint64_t RB::DisplayList::Item::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::Item::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::Item::required_depth(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::Item::has_no_effect(RB::DisplayList::Item *this)
{
  return 0;
}

uint64_t RB::DisplayList::LayerItem::type_id(RB::DisplayList::LayerItem *this)
{
  return 0;
}

void RB::DisplayList::BackdropColorMatrixItem::~BackdropColorMatrixItem(RB::DisplayList::BackdropColorMatrixItem *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::type_id(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return 2;
}

double RB::DisplayList::BackdropColorMatrixItem::bounds(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return -5.48612406e303;
}

float RB::DisplayList::BackdropColorMatrixItem::min_scale(RB::DisplayList::BackdropColorMatrixItem *this)
{
  return 1.0;
}

void RB::DisplayList::CustomItem::~CustomItem(id *this)
{

}

{

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::CustomItem::type_id(RB::DisplayList::CustomItem *this)
{
  return 3;
}

float RB::DisplayList::CustomItem::min_scale(RB::DisplayList::CustomItem *this)
{
  return 1.0;
}

_DWORD *RB::Refcount<RB::Resource,unsigned int>::release(_DWORD *result)
{
  int v1;

  v1 = result[2] - 1;
  result[2] = v1;
  if (!v1)
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t RB::Refcount<RB::Resource,unsigned int>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Resource::~Resource(RB::Resource *this)
{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

}

{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

  JUMPOUT(0x20BD16544);
}

{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

}

void RB::render_glyphs_coverage(uint64_t a1, float64x2_t *a2, float32x2_t *a3, int a4, float a5)
{
  _BOOL4 may_discard_shape;
  uint64_t (**v9)(RB::_anonymous_namespace_::GlyphRenderer *__hidden);
  float v10;
  int v11;

  v10 = a5;
  v9 = &off_24C22A458;
  v11 = a4;
  may_discard_shape = RB::may_discard_shape(a4);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, float32x2_t *this, char a5, int a6, float a7)
{
  char is_opaque;
  BOOL v13;
  char v14;
  _BOOL4 may_discard_shape;
  _QWORD v16[3];
  char v17;
  float v18;
  int v19;

  v16[0] = &off_24C22A398;
  v16[1] = this;
  v16[2] = a2;
  v17 = a5;
  v18 = a7;
  v19 = a6;
  if (a7 == 1.0)
    is_opaque = RB::Fill::Gradient::is_opaque(this);
  else
    is_opaque = 0;
  if (a3[2].i32[0] < 2u)
  {
    v14 = 0;
  }
  else
  {
    v13 = a6 != 2 && a6 != 24;
    if (a3[6].i8[5] & 1 | ((is_opaque & 1) == 0))
      v14 = 1;
    else
      v14 = v13;
  }
  may_discard_shape = RB::may_discard_shape(a6);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *this, uint64_t a4, char a5, int a6, float a7)
{
  _QWORD v7[3];
  char v8;
  float v9;
  int v10;

  v7[0] = &off_24C223F10;
  v7[1] = a4;
  v7[2] = a2;
  v8 = a5;
  v9 = a7;
  v10 = a6;
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, uint64_t a5, char a6, int a7)
{
  BOOL v11;
  char v12;
  char v13;
  _BOOL4 may_discard_shape;
  _QWORD v15[3];
  char v16;
  int v17;

  v15[0] = &off_24C22A3C8;
  v15[1] = a4;
  v15[2] = a5;
  v16 = a6;
  v17 = a7;
  if (a3[2].i32[0] < 2u)
  {
    v13 = 0;
  }
  else
  {
    v11 = a7 != 2 && a7 != 24;
    v12 = (a3[6].i8[5] & 1) != 0 || v11;
    if ((*(_BYTE *)(a4 + 81) & 1) != 0)
      v13 = v12;
    else
      v13 = 1;
  }
  may_discard_shape = RB::may_discard_shape(a7);
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, char a5, int a6, float a7)
{
  char v10;
  _BOOL4 may_discard_shape;
  _QWORD v12[3];
  char v13;
  float v14;
  int v15;

  v12[0] = &off_24C22A368;
  v12[1] = a4;
  v12[2] = a2;
  v13 = a5;
  v14 = a7;
  v15 = a6;
  v10 = a3[2].i32[0] > 1u;
  may_discard_shape = RB::may_discard_shape(a6);
}

void RB::`anonymous namespace'::render_glyph_paths(uint64_t a1, RB::Device ****a2, float64x2_t *this, float32x2_t *a4, int a5, char a6)
{
  int v11;
  float v12;
  int v13;
  float v14;
  uint64_t v15;
  const RB::AffineTransform *v16;
  uint64_t v17;
  float32x2_t v18;
  unint64_t v19;
  size_t v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  float64x2_t v24;
  __n128 v25;
  float64x2_t v26;
  RB *v27;
  float32x2_t v28;
  uint64_t v29;
  double v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  size_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  int v40;
  float64x2_t v41;
  __n128 v42;
  float64x2_t v43;
  RB *v44;
  float32x2_t v45;
  uint64_t v46;
  float64_t v47;
  uint64_t v48;
  int v49;
  __int128 v50;
  __int128 v51;
  float64x2_t v52;
  uint64_t v53;
  uint64_t v54;
  char *v55;
  char *v56;
  uint64_t v57;
  int v58;
  int v59;
  char *v60;
  char *v61;
  uint64_t v62;
  double v63;
  float64x2_t v64;
  float64x2_t v65[2];
  float64x2_t v66;
  RB::Device ****v67;
  char v68;
  char v69;
  float v70;
  uint64_t v71;
  _BYTE *v72;
  _BYTE v73[32];
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  float64_t v77;
  float64x2_t v78;
  int v79;
  char v80;
  uint64_t v81;

  v62 = a1;
  v81 = *MEMORY[0x24BDAC8D0];
  v11 = a4[6].u8[4];
  v12 = 0.0;
  if (v11 == 1)
  {
    v13 = 0;
  }
  else if (a4[6].i8[4])
  {
    v14 = a4[6].f32[0];
    a6 = 0;
    v12 = RB::AffineTransform::scale(this) * v14;
    v13 = 2;
  }
  else
  {
    v13 = 0;
    v11 = (a4[2].i8[4] & 1) == 0;
  }
  v15 = RB::Device::glyph_path_cache(***a2);
  v17 = v15;
  v18 = 0;
  if (a5)
    v18 = RB::GlyphPathCache::glyph_dilation(a4, this, v16);
  v19 = a4[2].u32[0];
  if ((a6 & 1) == 0)
  {
    if (!a4[2].i32[0])
      return;
    v23 = 0;
    while (1)
    {
      v24 = this[1];
      v66 = this[2];
      v25 = *(__n128 *)this;
      v26 = *this;
      v65[1] = this[1];
      v65[0] = (float64x2_t)v25;
      v27 = (RB *)*a4;
      v28 = a4[1];
      v66 = vmlaq_n_f64(vmlaq_n_f64(v66, v24, COERCE_FLOAT(HIDWORD(*(_QWORD *)(*(_QWORD *)&v28 + 8 * v23)))), v26, COERCE_FLOAT(*(_QWORD *)(*(_QWORD *)&v28 + 8 * v23)));
      v25.n128_u64[0] = (unint64_t)v18;
      v29 = RB::GlyphPathCache::lookup_glyph(v17, v27, (CGFont *)*(unsigned __int16 *)(*(_QWORD *)&v28 + 8 * v19 + 2 * v23), v65, (uint64_t)*a2, v13, v25);
      if (*(_QWORD *)(v29 + 56))
      {
        RB::RenderFrame::cached_region((uint64_t)**a2, 2u, *(_DWORD *)(v29 + 76), (uint64_t)&v63);
        v30 = v63;
        if (v63 != 0.0)
          goto LABEL_19;
        RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(32 * *(_QWORD *)(v29 + 56)), 4uLL, 0, v73);
        v63 = *(double *)v73;
        v64 = *(float64x2_t *)&v73[8];
        if (*(_QWORD *)v73)
          break;
      }
LABEL_20:
      ++v23;
      v19 = a4[2].u32[0];
      if (v23 >= v19)
        return;
    }
    v31 = *(_QWORD *)(v29 + 56);
    if (v31)
      memmove((void *)(*(_QWORD *)(*(_QWORD *)v73 + 56) + *(_QWORD *)&v73[8]), *(const void **)(v29 + 48), 32 * v31);
    RB::RenderFrame::set_cached_region((uint64_t)**a2, 2u, *(_DWORD *)(v29 + 76), (uint64_t)&v63);
    v30 = v63;
LABEL_19:
    v32 = *(_DWORD *)(v29 + 72);
    v33 = *(_QWORD *)(v29 + 32);
    v34 = *(_QWORD *)(v29 + 40);
    v77 = v30;
    v78 = v64;
    v79 = v32;
    v80 = 4;
    *(_QWORD *)v73 = 1;
    *(_QWORD *)&v73[8] = &v77;
    *(_QWORD *)&v73[16] = v33;
    *(_QWORD *)&v73[24] = v34;
    v74 = v65[0];
    v75 = v65[1];
    v76 = v66;
    v67 = a2;
    v68 = 0;
    v69 = v11;
    v70 = v12;
    v71 = 1;
    v72 = v73;
    (*(void (**)(uint64_t, RB::Device *****))(*(_QWORD *)v62 + 24))(v62, &v67);
    goto LABEL_20;
  }
  if (v19 <= 0x33)
  {
    MEMORY[0x24BDAC7A8](v15, 80 * v19);
    v61 = (char *)&v57 - ((v20 + 15) & 0xFFFFFFFFF0);
    bzero(v61, v20);
    v22 = 32 * v19;
LABEL_23:
    MEMORY[0x24BDAC7A8](v21, v22);
    v60 = (char *)&v57 - ((v36 + 15) & 0x3FFFFFFFF0);
    bzero(v60, v36);
    v59 = 1;
    goto LABEL_25;
  }
  v21 = (char *)malloc_type_malloc(80 * v19, 0xDB92CD52uLL);
  v61 = v21;
  v35 = a4[2].u32[0];
  v22 = 32 * v35;
  if (v35 < 0x81)
    goto LABEL_23;
  v60 = (char *)malloc_type_malloc(32 * v35, 0xE9AE4D03uLL);
  v59 = 0;
LABEL_25:
  if (!v61)
    goto LABEL_39;
  if (!v60)
    goto LABEL_39;
  v37 = a4[2].u32[0];
  if (!(_DWORD)v37)
    goto LABEL_39;
  v58 = v11;
  v38 = 0;
  v39 = 0;
  v40 = v13 | 1;
  do
  {
    v41 = this[1];
    v74 = this[2];
    v43 = this[1];
    *(float64x2_t *)v73 = *this;
    v42.n128_u64[1] = *(_QWORD *)&v73[8];
    *(float64x2_t *)&v73[16] = v43;
    v44 = (RB *)*a4;
    v45 = a4[1];
    v74 = vmlaq_n_f64(vmlaq_n_f64(v74, v41, COERCE_FLOAT(HIDWORD(*(_QWORD *)(*(_QWORD *)&v45 + 8 * v39)))), *(float64x2_t *)v73, COERCE_FLOAT(*(_QWORD *)(*(_QWORD *)&v45 + 8 * v39)));
    v42.n128_u64[0] = (unint64_t)v18;
    v46 = RB::GlyphPathCache::lookup_glyph(v17, v44, (CGFont *)*(unsigned __int16 *)(*(_QWORD *)&v45 + 8 * v37 + 2 * v39), (float64x2_t *)v73, (uint64_t)*a2, v40, v42);
    if (!*(_QWORD *)(v46 + 56))
      goto LABEL_36;
    RB::RenderFrame::cached_region((uint64_t)**a2, 2u, *(_DWORD *)(v46 + 76), (uint64_t)v65);
    v47 = v65[0].f64[0];
    if (!*(_QWORD *)&v65[0].f64[0])
    {
      RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(32 * *(_QWORD *)(v46 + 56)), 4uLL, 0, &v77);
      v65[0].f64[0] = v77;
      *(float64x2_t *)((char *)v65 + 8) = v78;
      if (v77 == 0.0)
        goto LABEL_36;
      v48 = *(_QWORD *)(v46 + 56);
      if (v48)
        memmove((void *)(*(_QWORD *)(*(_QWORD *)&v77 + 56) + *(_QWORD *)&v78.f64[0]), *(const void **)(v46 + 48), 32 * v48);
      RB::RenderFrame::set_cached_region((uint64_t)**a2, 2u, *(_DWORD *)(v46 + 76), (uint64_t)v65);
      v47 = v65[0].f64[0];
    }
    v49 = *(_DWORD *)(v46 + 72);
    v50 = *(_OWORD *)v73;
    v51 = *(_OWORD *)&v73[16];
    v52 = v74;
    v53 = *(_QWORD *)(v46 + 32);
    v54 = *(_QWORD *)(v46 + 40);
    v55 = &v61[80 * v38];
    *(_QWORD *)v55 = 1;
    v56 = &v60[32 * v38];
    *(float64_t *)v56 = v47;
    *(float64x2_t *)(v56 + 8) = *(float64x2_t *)((char *)v65 + 8);
    *((_DWORD *)v56 + 6) = v49;
    v56[28] = 4;
    *((_QWORD *)v55 + 1) = v56;
    *((_QWORD *)v55 + 2) = v53;
    *((_QWORD *)v55 + 3) = v54;
    *((_OWORD *)v55 + 2) = v50;
    *((_OWORD *)v55 + 3) = v51;
    *((float64x2_t *)v55 + 4) = v52;
    ++v38;
LABEL_36:
    ++v39;
    v37 = a4[2].u32[0];
  }
  while (v39 < v37);
  if (v38)
  {
    *(_QWORD *)v73 = a2;
    v73[8] = 0;
    v73[9] = v58;
    *(float *)&v73[12] = v12;
    *(_QWORD *)&v73[16] = v38;
    *(_QWORD *)&v73[24] = v61;
    (*(void (**)(uint64_t, _BYTE *))(*(_QWORD *)v62 + 24))(v62, v73);
  }
LABEL_39:
  if ((v59 & 1) == 0)
    free(v60);
  if (v19 >= 0x34)
    free(v61);
}

void sub_209B5BF04(_Unwind_Exception *exception_object)
{
  unint64_t v1;
  uint64_t v2;

  if ((*(_DWORD *)(v2 - 372) & 1) == 0)
    free(*(void **)(v2 - 368));
  if (v1 >= 0x34)
    free(*(void **)(v2 - 360));
  _Unwind_Resume(exception_object);
}

void RB::`anonymous namespace'::render_glyph_masks<RB::`anonymous namespace'::render_glyphs(RB::`anonymous namespace'::GlyphRenderer const&,RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,BOOL,BOOL)::$_0>(uint64_t *a1, RB::Device ****a2, uint64_t a3, float64x2_t *a4)
{
  float64x2_t v8;
  float64x2_t v9;
  uint64_t QuantizationLevel;
  uint64_t v11;
  size_t v12;
  float64x2_t *v13;
  float64x2_t *v14;
  uint64_t v15;
  float32x2_t *v16;
  float64x2_t *v17;
  uint64_t v18;
  float32x2_t v19;
  uint64_t v20;
  char *v21;
  size_t v22;
  size_t v23;
  char *v24;
  uint64_t GlyphIdentifiers;
  uint64_t v26;
  size_t v27;
  char *v28;
  unint64_t v29;
  uint64_t v30;
  _DWORD *v31;
  int16x4_t v32;
  double v33;
  double v34;
  double v35;
  int32x4_t v36;
  uint64_t v37;
  const char *v38;
  _DWORD *v39;
  int v40;
  uint64_t v41;
  unsigned int v42;
  unsigned int v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  int16x4_t v47;
  char *v48;
  int v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  int v58;
  float32x2_t v59;
  float64x2_t *v60;
  uint64_t v61;
  uint64_t v62;
  int v63;
  char *v64;
  uint64_t v65;
  int64x2_t v66;
  uint64_t v67;
  int64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  float64x2_t v71;
  uint64_t v72;

  v72 = *MEMORY[0x24BDAC8D0];
  RB::Device::glyph_lock(***a2);
  v8 = vmulq_f64(a4[1], (float64x2_t)xmmword_209BD52B0);
  v9 = vmulq_f64(a4[2], (float64x2_t)xmmword_209BD52B0);
  v69 = vmulq_f64(*a4, (float64x2_t)xmmword_209BD52B0);
  v70 = v8;
  v71 = v9;
  if (!CGGlyphLockAccessCustomized())
    return;
  QuantizationLevel = CGGlyphLockGetQuantizationLevel();
  if (!(_DWORD)QuantizationLevel)
    return;
  v11 = *(unsigned int *)(a3 + 16);
  if (v11 > 0x100)
  {
    v14 = (float64x2_t *)malloc_type_malloc(16 * v11, 0x437EC846uLL);
    v13 = v14;
    if (!v14)
    {
LABEL_52:
      free(v13);
      return;
    }
  }
  else
  {
    MEMORY[0x24BDAC7A8](QuantizationLevel, 16 * v11);
    v13 = (float64x2_t *)((char *)&v60 - ((v12 + 15) & 0x1FFFFFFFF0));
    bzero(v13, v12);
  }
  v15 = *(unsigned int *)(a3 + 16);
  if ((_DWORD)v15)
  {
    v16 = *(float32x2_t **)(a3 + 8);
    v17 = v13;
    v18 = *(unsigned int *)(a3 + 16);
    do
    {
      v19 = *v16++;
      *v17++ = vcvtq_f64_f32(v19);
      --v18;
    }
    while (v18);
    v20 = 4 * v15;
    if (v15 >= 0x401)
    {
      v21 = (char *)malloc_type_malloc(4 * v15, 0xEBB51928uLL);
      v64 = v21;
      v63 = 0;
      v15 = *(unsigned int *)(a3 + 16);
      goto LABEL_13;
    }
  }
  else
  {
    v20 = 0;
  }
  MEMORY[0x24BDAC7A8](v14, v20);
  v64 = (char *)&v60 - ((v22 + 15) & 0x7FFFFFFF0);
  bzero(v64, v22);
  v63 = 1;
LABEL_13:
  if (v15 >= 0x201)
  {
    v24 = (char *)malloc_type_malloc(8 * v15, 0x2A006B26uLL);
  }
  else
  {
    MEMORY[0x24BDAC7A8](v21, 8 * v15);
    v24 = (char *)&v60 - ((v23 + 15) & 0xFFFFFFFF0);
    bzero(v24, v23);
  }
  if (v64 && v24)
  {
    GlyphIdentifiers = CGFontGetGlyphIdentifiers();
    v26 = *(unsigned int *)(a3 + 16);
    v62 = v26;
    if (v26 >= 0x201)
    {
      v28 = (char *)malloc_type_malloc(8 * v26, 0x7A5FF13DuLL);
      if (!v28)
      {
LABEL_46:
        free(v28);
        goto LABEL_47;
      }
    }
    else
    {
      MEMORY[0x24BDAC7A8](GlyphIdentifiers, 8 * v26);
      v28 = (char *)&v60 - ((v27 + 15) & 0xFFFFFFFF0);
      bzero(v28, v27);
    }
    if (CGGlyphLockLockGlyphBitmaps())
    {
      v60 = v13;
      v61 = v11;
      v29 = *(unsigned int *)(a3 + 16);
      if ((_DWORD)v29)
      {
        v30 = 0;
        while (1)
        {
          v31 = *(_DWORD **)&v28[8 * v30];
          if (!v31[5] || !v31[6])
            goto LABEL_43;
          RB::RenderFrame::cached_region((uint64_t)**a2, 1u, v31[9], (uint64_t)&v67);
          v37 = v67;
          if (v67)
            goto LABEL_39;
          RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(v31[6] * v31[5]), 0, 2, &v65);
          v67 = v65;
          v68 = v66;
          if (v65)
            break;
LABEL_42:
          v29 = *(unsigned int *)(a3 + 16);
LABEL_43:
          if (++v30 >= v29)
            goto LABEL_44;
        }
        v39 = v31 + 10;
        v40 = v31[7];
        v41 = (int)v31[8];
        if (v40 == 16)
        {
          v42 = v31[6];
          if (v42)
          {
            v43 = 0;
            v44 = *(_QWORD *)(v65 + 56) + v66.i64[0];
            LODWORD(v45) = v31[5];
            do
            {
              if ((_DWORD)v45)
              {
                v46 = 0;
                do
                {
                  *(_BYTE *)(v44 + v46) = *((unsigned __int16 *)v39 + v46) >> 7;
                  ++v46;
                  v45 = v31[5];
                }
                while (v46 < v45);
                v42 = v31[6];
                v44 += v46;
              }
              v39 = (_DWORD *)((char *)v39 + v41);
              ++v43;
            }
            while (v43 < v42);
          }
        }
        else
        {
          if (v40 != 8)
            RB::precondition_failure((RB *)"unknown CG glyph mask format: %d", v38, v39, v31[7]);
          CGBlt_copyBytes();
        }
        RB::RenderFrame::set_cached_region((uint64_t)**a2, 1u, v31[9], (uint64_t)&v67);
        v37 = v67;
LABEL_39:
        v47 = *(int16x4_t *)(v31 + 5);
        v48 = &v24[8 * v30];
        v49 = *(_DWORD *)v48;
        v50 = *((_DWORD *)v48 + 1);
        v52 = v31[3];
        v51 = v31[4];
        v53 = *a1;
        v54 = (_QWORD *)a1[1];
        v55 = (*v54)++;
        if (v37)
          ++*(_DWORD *)(v37 + 8);
        v56 = v51 + v50;
        v57 = v53 + 32 * v55;
        v58 = -v56;
        *(_QWORD *)v57 = v37;
        *(_BYTE *)(v57 + 24) = 0;
        v32.i16[0] = v52 + v49;
        v32.i16[1] = v58;
        *(int16x4_t *)(v57 + 8) = vuzp1_s16(vzip1_s16(v32, v47), v47);
        *(int32x2_t *)(v57 + 16) = vmovn_s64(v68);
        v59.f32[0] = (float)(__int16)(v52 + v49);
        *(float *)&v33 = (float)(__int16)v58;
        v47.i32[1] = v47.u16[2];
        v59.f32[1] = *(float *)&v33;
        RB::Rect::Union((float32x2_t *)a1[2], v59, vcvt_f32_s32(vshr_n_s32(vshl_n_s32((int32x2_t)v47, 0x10uLL), 0x10uLL)), v33, v34, v35, v36);
        goto LABEL_42;
      }
LABEL_44:
      v13 = v60;
      LODWORD(v11) = v61;
      CGGlyphLockUnlock();
    }
    if (v62 >= 0x201)
      goto LABEL_46;
  }
LABEL_47:
  if (v15 >= 0x201)
    free(v24);
  if ((v63 & 1) == 0)
    free(v64);
  if (v11 >= 0x101)
    goto LABEL_52;
}

void sub_209B5C454()
{
  __break(1u);
}

void sub_209B5C45C(_Unwind_Exception *exception_object)
{
  void *v1;
  void *v2;
  unsigned int v3;
  uint64_t v4;

  if (*(_QWORD *)(v4 - 240) >= 0x201)
    free(v2);
  if (v3 >= 0x201)
    free(v1);
  if ((*(_DWORD *)(v4 - 228) & 1) == 0)
    free(*(void **)(v4 - 224));
  if (*(_QWORD *)(v4 - 248) >= 0x101)
    free(*(void **)(v4 - 256));
  _Unwind_Resume(exception_object);
}

uint64_t RB::`anonymous namespace'::GlyphRenderer::supports_draw_masks(RB::_anonymous_namespace_::GlyphRenderer *this)
{
  return 1;
}

int32x2_t *RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  int32x2_t v8[2];

  v8[0] = a6;
  v8[1] = a7;
  return RB::render_masks_coverage(a2, v8, a3, a4, a5, *(_DWORD *)(a1 + 12), *(float *)(a1 + 8));
}

int32x2_t *RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  RB::Buffer *v13;
  _OWORD *v14;
  __int128 v15;
  const char *v16;
  int32x2_t v18[2];
  __int128 v19;
  __int128 v20;
  RB::Buffer *v21;
  int64x2_t v22;

  RB::Coverage::set_plane((float32x2_t *)&v19, (float32x2_t *)a2, a3, a4);
  _S0 = *(_DWORD *)(a1 + 8);
  __asm { FCVT            H0, S0 }
  WORD6(v20) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x20, 4uLL, 0, &v21);
  v13 = v21;
  if (v21)
  {
    v14 = (_OWORD *)(*((_QWORD *)v21 + 7) + v22.i64[0]);
    v15 = v20;
    *v14 = v19;
    v14[1] = v15;
  }
  else
  {
    v21 = 0;
    v22 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v22);
  v16 = (const char *)(((unint64_t)(*(_DWORD *)(a2 + 136) == 2) << 33) | ((unint64_t)(*(_DWORD *)(a1 + 12) & 0x3F) << 6) | 0x11);
  RB::Bounds::Bounds(v18, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v16, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, v18[0], v18[1]);
}

void RB::render_glyphs_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  RB::Path::Renderer::render_coverage(a2, *(_DWORD *)(a1 + 12), *(float *)(a1 + 8));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  int32x2_t v8[2];

  v8[0] = a6;
  v8[1] = a7;
  return RB::render_masks(a2, v8, a3, a4, a5, *(_QWORD *)(a1 + 8), *(unsigned __int8 *)(a1 + 16), *(_DWORD *)(a1 + 20));
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  RB::Path::Renderer::render(a2, *(_QWORD *)(a1 + 8), *(_BYTE *)(a1 + 16), *(_DWORD *)(a1 + 20));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  int32x2_t v8[2];

  v8[0] = a6;
  v8[1] = a7;
  a6.i32[0] = *(_DWORD *)(a1 + 28);
  return RB::render_masks(a2, v8, a3, a4, a5, *(float64x2_t **)(a1 + 16), *(float32x2_t **)(a1 + 8), *(unsigned __int8 *)(a1 + 24), *(double *)&a6, *(_DWORD *)(a1 + 32));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  double v8;
  RB::Buffer *v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BOOL4 v15;
  int8x8_t v16;
  const char *v17;
  int32x2_t *result;
  int32x2_t v19[2];
  __int128 v20;
  _OWORD v21[4];
  int v22;
  RB::Buffer *v23;
  int64x2_t v24;

  RB::Coverage::set_plane((float32x2_t *)&v20, (float32x2_t *)a2, a3, a4);
  LODWORD(v8) = *(_DWORD *)(a1 + 28);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 8), (uint64_t)v21 + 12, a2, *(float64x2_t **)(a1 + 16), v8);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x54, 4uLL, 0, &v23);
  v9 = v23;
  if (v23)
  {
    v10 = *((_QWORD *)v23 + 7) + v24.i64[0];
    v11 = v20;
    *(_OWORD *)(v10 + 16) = v21[0];
    v12 = v21[3];
    v13 = v21[2];
    v14 = v21[1];
    *(_DWORD *)(v10 + 80) = v22;
    *(_OWORD *)(v10 + 48) = v13;
    *(_OWORD *)(v10 + 64) = v12;
    *(_OWORD *)(v10 + 32) = v14;
    *(_OWORD *)v10 = v11;
  }
  else
  {
    v23 = 0;
    v24 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v9);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v24);
  v15 = *(_DWORD *)(a2 + 136) == 2;
  LODWORD(v23) = 19;
  HIDWORD(v23) = 2 * v15;
  RB::Fill::Gradient::set_fill_state(*(float32x2_t **)(a1 + 8), (int *)&v23, a2, *(float *)(a1 + 28));
  v16.i32[0] = (*(_DWORD *)(a1 + 32) & 0x3F) << 6;
  v16.i32[1] = *(unsigned __int8 *)(a1 + 24);
  v23 = (RB::Buffer *)vorr_s8(vand_s8((int8x8_t)v23, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v16);
  v17 = (const char *)v23;
  RB::Bounds::Bounds(v19, a3, *(float32x2_t *)&a4);
  result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v17, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, v19[0], v19[1]);
  *(_QWORD *)(a2 + 224) = 0;
  *(_DWORD *)(a2 + 220) = 0;
  return result;
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  RB::Path::Renderer::render(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_BYTE *)(a1 + 24), *(_DWORD *)(a1 + 32), *(float *)(a1 + 28));
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks()
{
  abort();
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, RB::RenderPass *a2, float32x2_t a3, float32x2_t a4)
{
  float64x2_t *v5;
  int32x2_t *v6;
  __int32 v7;
  float v8;
  int v9;
  int32x2_t v10[2];

  v6 = *(int32x2_t **)(a1 + 8);
  v5 = *(float64x2_t **)(a1 + 16);
  v7 = *(unsigned __int8 *)(a1 + 24);
  v8 = *(float *)(a1 + 28);
  v9 = *(_DWORD *)(a1 + 32);
  RB::Bounds::Bounds(v10, a3, a4);
  RB::render_mesh_gradient(a2, v5, v6, 0, v7, v9, v10, v8);
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  RB::Path::Renderer::render(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_BYTE *)(a1 + 24), *(_DWORD *)(a1 + 32), *(float *)(a1 + 28));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_masks(uint64_t a1, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int32x2_t a6, int32x2_t a7)
{
  uint64_t v7;
  __int128 *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x8_t v14[3];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  int v20;
  int32x2_t v21[2];

  v21[0] = a6;
  v21[1] = a7;
  v8 = *(__int128 **)(a1 + 8);
  v7 = *(_QWORD *)(a1 + 16);
  v9 = v8[1];
  v15 = *v8;
  v16 = v9;
  v11 = v8[3];
  v10 = v8[4];
  v12 = v8[2];
  LODWORD(v8) = *((_DWORD *)v8 + 20);
  v17 = v12;
  v20 = (int)v8;
  v19 = v10;
  v18 = v11;
  return RB::render_masks(a2, v21, a3, a4, a5, v14, v7, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 28));
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  int v12;
  RB::Buffer *v13;
  _OWORD *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BOOL4 v20;
  int8x8_t v21;
  const char *v22;
  int32x2_t v24[2];
  __int128 v25;
  _BYTE v26[96];
  RB::Buffer *v27;
  int64x2_t v28;

  v8 = *(_QWORD *)(a1 + 8);
  v9 = *(_OWORD *)(v8 + 16);
  *(_OWORD *)&v26[12] = *(_OWORD *)v8;
  *(_OWORD *)&v26[28] = v9;
  v11 = *(_OWORD *)(v8 + 48);
  v10 = *(_OWORD *)(v8 + 64);
  v12 = *(_DWORD *)(v8 + 80);
  *(_OWORD *)&v26[44] = *(_OWORD *)(v8 + 32);
  *(_DWORD *)&v26[92] = v12;
  *(_OWORD *)&v26[76] = v10;
  *(_OWORD *)&v26[60] = v11;
  RB::Coverage::set_plane((float32x2_t *)&v25, (float32x2_t *)a2, a3, a4);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x70, 4uLL, 0, &v27);
  v13 = v27;
  if (v27)
  {
    v14 = (_OWORD *)(*((_QWORD *)v27 + 7) + v28.i64[0]);
    v15 = *(_OWORD *)&v26[16];
    v16 = v25;
    v14[1] = *(_OWORD *)v26;
    v14[2] = v15;
    v17 = *(_OWORD *)&v26[80];
    v18 = *(_OWORD *)&v26[48];
    v19 = *(_OWORD *)&v26[32];
    v14[5] = *(_OWORD *)&v26[64];
    v14[6] = v17;
    v14[3] = v19;
    v14[4] = v18;
    *v14 = v16;
  }
  else
  {
    v27 = 0;
    v28 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v28);
  v20 = *(_DWORD *)(a2 + 136) == 2;
  LODWORD(v27) = 21;
  HIDWORD(v27) = 2 * v20;
  RB::RenderState::set_image((int *)&v27, (uint64_t)&v26[12], *(unsigned __int8 *)(a2 + 124));
  v21.i32[0] = (*(_DWORD *)(a1 + 28) & 0x3F) << 6;
  v21.i32[1] = *(unsigned __int8 *)(a1 + 24);
  v27 = (RB::Buffer *)vorr_s8(vand_s8((int8x8_t)v27, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v21);
  v22 = (const char *)v27;
  RB::Bounds::Bounds(v24, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v22, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, v24[0], v24[1]);
}

__n128 RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Shader::ImageGlobals &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  int v6;
  __n128 result;
  _BYTE v8[44];
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int v13;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_OWORD *)(v2 + 16);
  *(_OWORD *)&v8[28] = *(_OWORD *)v2;
  v9 = v3;
  v5 = *(_OWORD *)(v2 + 48);
  v4 = *(_OWORD *)(v2 + 64);
  v6 = *(_DWORD *)(v2 + 80);
  v10 = *(_OWORD *)(v2 + 32);
  v13 = v6;
  v12 = v4;
  v11 = v5;
  RB::Path::Renderer::render(a2, (uint64_t)v8, *(_BYTE *)(a1 + 24), *(_DWORD *)(a1 + 28));
  return result;
}

uint64_t RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::supports_draw_masks()
{
  return 0;
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_masks()
{
  abort();
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  uint64_t *v8;
  Function *v9;
  uint64_t v10;
  _BOOL4 v11;
  int8x8_t v12;
  const char *v13;
  int32x2_t v14[2];
  const char *v15;
  RB::Buffer *v16;
  int64x2_t v17;

  v8 = RB::Fill::Custom::function(*(RB::Fill::Custom **)(a1 + 8), (uint64_t **)a2);
  if (v8)
  {
    v9 = (Function *)v8;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(*((unsigned int *)v8 + 20) + 56), 4uLL, 0, &v16);
    if (v16)
    {
      v10 = *((_QWORD *)v16 + 7) + v17.i64[0];
      RB::Coverage::set_plane((float32x2_t *)v10, (float32x2_t *)a2, a3, a4);
      if (RB::Fill::Custom::set_custom(*(_QWORD *)(a1 + 8), (float32x2_t *)(v10 + 28), (uint64_t)v9, v10 + 56, a2, *(float32x4_t **)(a1 + 16), *(float *)(a1 + 28)))
      {
        *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v16);
        *(int32x2_t *)(a2 + 188) = vmovn_s64(v17);
        v11 = *(_DWORD *)(a2 + 136) == 2;
        LODWORD(v15) = 22;
        HIDWORD(v15) = 2 * v11;
        RB::Fill::Custom::set_fill_state(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderState *)&v15, v9, (unint64_t **)a2);
        v12.i32[0] = (*(_DWORD *)(a1 + 32) & 0x3F) << 6;
        v12.i32[1] = *(unsigned __int8 *)(a1 + 24);
        v15 = (const char *)vorr_s8(vand_s8((int8x8_t)v15, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v12);
        v13 = v15;
        RB::Bounds::Bounds(v14, a3, *(float32x2_t *)&a4);
        RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v13, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, v14[0], v14[1]);
        RB::Fill::Custom::reset_custom(*(RB::Fill::Custom **)(a1 + 8), (RB::RenderPass *)a2);
      }
    }
  }
}

void RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::draw_path(uint64_t a1, int32x2_t **a2)
{
  RB::Path::Renderer::render(a2, *(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_BYTE *)(a1 + 24), *(_DWORD *)(a1 + 32), *(float *)(a1 + 28));
}

int32x2_t *RB::AlphaThresholdEffect::dod(int32x2_t *this, int32x2_t *a2)
{
  if ((vcgt_f32((float32x2_t)vdup_lane_s32(*this, 1), (float32x2_t)*this).u8[0] & 1) != 0)
  {
    if (COERCE_FLOAT(*this) > 0.0)
    {
      *a2 = (int32x2_t)0x100000001000000;
      a2[1] = vdup_n_s32(0x7F7FFFFFu);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t RB::AlphaThresholdEffect::matches(RB::AlphaThresholdEffect *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::AlphaThresholdEffect *)((char *)this + 8), a3);
}

void RB::AlphaThresholdEffect::apply_transform(float16x4_t *this, RB::DisplayList::Contents *a2, const RB::DisplayList::Transform *a3, uint32x4_t a4)
{
  RB::DisplayList::Transform::apply_to_color(a3, this + 1, a4);
}

uint64_t RB::AlphaThresholdEffect::can_mix(float32x2_t *this, float32x2_t *a2)
{
  uint64_t result;
  unsigned int v5;
  uint32x2_t v6;
  int v7;

  LODWORD(result) = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[1], (const RB::Fill::Color *)&a2[1]);
  v5 = result;
  v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*this, *a2));
  v7 = vpmax_u32(v6, v6).u32[0];
  if ((result & 0xFE) != 0)
    v5 = 2;
  if (v7 >= 0)
    return result;
  else
    return v5;
}

void RB::AlphaThresholdEffect::mix(RB::AlphaThresholdEffect *this, const RB::AlphaThresholdEffect *a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  float32x2_t v8;

  v8 = vsub_f32(*(float32x2_t *)a2, *(float32x2_t *)this);
  *(float32x2_t *)a4.i8 = vmla_n_f32(*(float32x2_t *)this, v8, *(float *)a3.i32);
  *(_QWORD *)this = a4.i64[0];
  RB::Fill::Color::mix((float16x4_t *)this + 1, (float16x4_t *)a2 + 1, 0, a3, a4, *(double *)&v8, a6, a7, a8);
}

int32x2_t *RB::AlphaThresholdEffect::render(int32x2_t *result, double a2, float a3, uint64_t a4, uint64_t a5, float32x2_t *a6, uint64_t a7, int a8, float64x2_t *a9, float32x2_t *a10, unsigned __int8 a11, __int16 a12, char a13)
{
  int32x2_t *v19;
  int32x2_t v20;
  int32x2_t v21;
  __int16 v26;
  __int16 v27;
  __int16 v28;
  float32x4_t v32;
  uint32x4_t v33;
  unsigned int v35;
  int v36;
  float16x4_t v37;
  RB::Buffer *v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  _OWORD v49[4];
  __int128 v50;
  uint64_t v51;
  int32x2_t v52;
  int32x2_t v53;
  RB::Buffer *v54;
  int64x2_t v55;

  if (a7)
  {
    _S8 = a3;
    v19 = result;
    if (COERCE_FLOAT(*result) <= 0.0)
    {
      v20 = *(int32x2_t *)(a5 + 160);
      v21 = *(int32x2_t *)(a5 + 168);
      v52 = v20;
      v53 = v21;
    }
    else
    {
      v20 = (int32x2_t)RB::Bounds::Bounds(&v52, *a6, a6[1]);
    }
    __asm { FCVT            H0, S8 }
    v26 = v19[1].i16[0];
    v27 = v19[1].i16[1];
    v28 = v19[1].i16[2];
    _H1 = v19[1].i16[3];
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
    }
    _D0.f32[0] = _S1 * _D0.f32[0];
    *(int32x2_t *)v32.f32 = *v19;
    _D1 = (int16x4_t)vcvt_f16_f32(v32);
    v33 = vmovl_u16((uint16x4_t)_D1);
    __asm { FCVT            H1, S0 }
    WORD6(v50) = v33.i16[0];
    v35 = v19[2].u16[0];
    HIWORD(v50) = v33.i16[2];
    if (v35 < 0x100 || (v36 = *(unsigned __int8 *)(a5 + 124), v36 == v35))
    {
      v37.i16[3] = 15360;
      v37.i16[0] = v26;
      v37.i16[1] = v27;
      v37.i16[2] = v28;
    }
    else
    {
      LOWORD(v54) = v26;
      WORD1(v54) = v27;
      WORD2(v54) = v28;
      HIWORD(v54) = _D1.i16[0];
      v55.i16[0] = v35;
      RB::Fill::Color::convert((uint64_t)&v54, v36, (uint16x4_t)_D0);
      v37.i16[3] = 15360;
      v37.i32[0] = (int)v54;
      v37.i16[2] = WORD2(v54);
      _D1.i32[0] = (unint64_t)v54 >> 48;
    }
    *(float16x4_t *)((char *)&v50 + 4) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D1, 0)), vcvtq_f32_f16(v37)));
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a5, (RB::Device *)0x58, 4uLL, 0, &v54);
    v38 = v54;
    if (v54)
    {
      v39 = *((_QWORD *)v54 + 7) + v55.i64[0];
      v40 = v49[0];
      *(_OWORD *)(v39 + 16) = v49[1];
      v42 = v49[3];
      v41 = v50;
      v43 = v49[2];
      *(_QWORD *)(v39 + 80) = v51;
      *(_OWORD *)(v39 + 48) = v42;
      *(_OWORD *)(v39 + 64) = v41;
      *(_OWORD *)(v39 + 32) = v43;
      *(_OWORD *)v39 = v40;
    }
    else
    {
      v54 = 0;
      v55 = 0uLL;
    }
    *(_DWORD *)(a5 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a5, v38);
    *(int32x2_t *)(a5 + 188) = vmovn_s64(v55);
    v44 = COERCE_FLOAT(*v19) > 0.0;
    v45 = (COERCE_FLOAT(HIDWORD(*(unint64_t *)v19)) < 1.0) << 14;
    v46 = a11 | (2 * (*(_DWORD *)(a5 + 136) == 2));
    v47 = v45 & 0xFFFFF03F | ((a13 & 0x3F) << 6) | (v44 << 13) | 0x24;
    if (a8)
      v48 = 2;
    else
      v48 = 1;
    *(_DWORD *)(a5 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a5, a7);
    *(_BYTE *)(a5 + 236) = v48;
    result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)a5, (const char *)(v47 | (v46 << 32)), 4, ***(_QWORD ***)a5 + 80, 0, 1uLL, v52, v53);
    *(_DWORD *)(a5 + 232) = 0;
    *(_BYTE *)(a5 + 236) = 0;
  }
  return result;
}

void sub_209B5D07C(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 232) = 0;
  *(_BYTE *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

float32x2_t RB::`anonymous namespace'::set_alpha_effect(float32x2_t *a1, uint64_t a2, int32x2_t *a3, float64x2_t *a4, float32x2_t *a5, int32x2_t a6)
{
  int32x2_t v10;
  uint32x2_t v11;
  int8x8_t v12;
  float64x2_t v13;
  float64x2_t *v14;
  float64x2_t v15;
  float32x2_t v16;
  int64x2_t v17;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float32x2_t result;
  _OWORD v27[3];

  a6.i32[0] = 0;
  v10 = a3[1];
  v11 = (uint32x2_t)vceq_s32(v10, (int32x2_t)0x8000000080000000);
  v12 = (int8x8_t)vdup_lane_s32(vcgt_s32(a6, (int32x2_t)vpmin_u32(v11, v11)), 0);
  RB::Coverage::set_plane((float32x2_t *)a2, a1, (float32x2_t)vbsl_s8(v12, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a3)), COERCE_DOUBLE(vbsl_s8(v12, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v10))));
  v13 = a4[1];
  v27[0] = *a4;
  v27[1] = v13;
  v27[2] = a4[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)v27))
    v14 = (float64x2_t *)v27;
  else
    v14 = a4;
  v15 = v14[1];
  v16 = a1[13];
  v17.i64[0] = v16.i32[0];
  v17.i64[1] = v16.i32[1];
  __asm { FMOV            V4.2D, #0.5 }
  v23 = vmulq_f64(vcvtq_f64_s64(v17), _Q4);
  v24 = vmulq_n_f64(*v14, v23.f64[0]);
  v25 = vmlaq_laneq_f64(vaddq_f64(v24, v14[2]), v15, v23, 1);
  *(float32x2_t *)(a2 + 28) = vcvt_f32_f64(v24);
  *(float32x2_t *)(a2 + 36) = vcvt_f32_f64(vmulq_n_f64(v15, -v23.f64[1]));
  *(float32x2_t *)(a2 + 44) = vcvt_f32_f64(v25);
  *(float32x2_t *)(a2 + 52) = *a5;
  result = vadd_f32(a5[1], *a5);
  *(float32x2_t *)(a2 + 60) = result;
  return result;
}

size_t RB::AlphaThresholdEffect::render(int32x2_t *this, CGContextRef *a2, uint16x4_t a3)
{
  int v5;
  uint64_t v6;
  float16x4_t v7;
  float32x4_t v13;
  int8x16_t v14;
  int v15;
  unsigned int v16;
  float32x4_t v17;
  float32x4_t v18;
  int8x16_t v19;
  int64x2_t v20;
  int64x2_t v21;
  float32x4_t v22;
  int64x2_t v23;
  float32x4_t v24;
  int16x8_t v26[64];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v5 = *((unsigned __int8 *)a2 + 8);
  *(int32x2_t *)v26[0].i8 = this[1];
  v26[0].i16[4] = this[2].i16[0];
  RB::Fill::Color::convert((uint64_t)v26, v5, a3);
  v6 = 0;
  v7.i16[3] = 15360;
  v7.i32[0] = v26[0].i32[0];
  v7.i16[2] = v26[0].i16[2];
  __asm { FMOV            V2.4S, #1.0 }
  v13.i64[0] = 0x3F0000003F000000;
  v13.i64[1] = 0x3F0000003F000000;
  v14 = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(v13, (float32x4_t)vdupq_n_s32(0x437F0000u), vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_n_s16(v26[0].u16[3])), vcvtq_f32_f16(v7)))), (float32x4_t)0), _Q2)));
  v15 = v14.i32[2] | (v14.i32[0] << 16);
  v14.i32[0] = vextq_s8(v14, v14, 8uLL).i32[1];
  *(uint32x2_t *)v14.i8 = vshl_u32(*(uint32x2_t *)v14.i8, (uint32x2_t)0x800000018);
  v16 = v15 | v14.i32[0] | v14.i32[1];
  v17 = (float32x4_t)vdupq_lane_s32(*this, 0);
  v18 = (float32x4_t)vdupq_lane_s32(*this, 1);
  v19 = (int8x16_t)vdupq_n_s32(v16);
  v20 = (int64x2_t)xmmword_209BD6EE0;
  v21 = (int64x2_t)xmmword_209BD6EF0;
  v22 = (float32x4_t)vdupq_n_s32(0x3B808081u);
  v23 = vdupq_n_s64(4uLL);
  do
  {
    v24 = vmulq_f32(vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vcvtq_f64_u64((uint64x2_t)v21)), vcvtq_f64_u64((uint64x2_t)v20)), v22);
    v26[v6] = (int16x8_t)vbicq_s8(v19, vorrq_s8((int8x16_t)vcgtq_f32(v17, v24), (int8x16_t)vcgtq_f32(v24, v18)));
    v20 = vaddq_s64(v20, v23);
    v21 = vaddq_s64(v21, v23);
    ++v6;
  }
  while (v6 != 64);
  return RB::CGContext::apply_alpha_lut(a2, v26);
}

_QWORD *RB::AlphaThresholdEffect::encode(RB::AlphaThresholdEffect *this, RB::Encoder *a2)
{
  int v4;
  int v6;

  if (COERCE_FLOAT(*(_QWORD *)this) == 0.0)
  {
    v4 = HIDWORD(*(_QWORD *)this);
  }
  else
  {
    v6 = *(_QWORD *)this;
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v6);
    v4 = *((int *)this + 1);
  }
  if (*(float *)&v4 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::AlphaThresholdEffect *)((char *)this + 8), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::AlphaThresholdEffect::decode(float *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::Fill::Color::decode((uint64_t)(a1 + 2), this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else if ((_DWORD)v6 == 2)
      {
        a1[1] = RB::ProtobufDecoder::float_field(this, v5);
      }
      else if ((_DWORD)v6 == 1)
      {
        *a1 = RB::ProtobufDecoder::float_field(this, v5);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::AlphaThresholdEffect::print(RB::AlphaThresholdEffect *this, std::string *a2)
{
  RB::SexpString::push(a2, "alpha-threshold");
  RB::SexpString::printf(a2, 1, "(alpha [%g %g])", COERCE_FLOAT(*(_QWORD *)this), COERCE_FLOAT(HIDWORD(*(_QWORD *)this)));
  RB::Fill::Color::print((RB::AlphaThresholdEffect *)((char *)this + 8), a2);
  RB::SexpString::pop(a2);
}

uint64_t *RB::AlphaGradientEffect::AlphaGradientEffect(uint64_t *a1, uint64_t *a2, uint64_t a3)
{
  return RB::Fill::Gradient::Gradient(a1, a2, 0, (RB::Heap *)(a3 + 16));
}

int32x2_t RB::AlphaGradientEffect::dod(RB::AlphaGradientEffect *this, int32x2_t *a2, double a3, double a4, double a5, double a6, float a7)
{
  int32x2_t result;

  *(float *)result.i32 = RB::Fill::Gradient::sample_alpha(this, 0.0, a4, a5, a6, a7);
  if (*(float *)result.i32 > 0.0)
  {
    result = vdup_n_s32(0x7F7FFFFFu);
    *a2 = (int32x2_t)0x100000001000000;
    a2[1] = result;
  }
  return result;
}

uint64_t RB::AlphaGradientEffect::matches(RB::AlphaGradientEffect *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

RB::Fill::Gradient *RB::AlphaGradientEffect::render(RB::Fill::Gradient *result, double a2, double a3, double a4, double a5, float a6, uint64_t a7, uint64_t a8, float32x2_t *a9, uint64_t a10, int a11, float64x2_t *a12, float32x2_t *a13, unsigned __int8 a14, __int16 a15, char a16)
{
  float v16;
  float32x2_t *v23;
  float32x2_t v24;
  int32x2_t v25;
  double v26;
  RB::Buffer *v27;
  uint64_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BOOL4 v33;
  char v34;
  _OWORD v35[4];
  __int128 v36;
  uint64_t v37;
  int32x2_t v38;
  int32x2_t v39;
  RB::Buffer *v40;
  int64x2_t v41;

  if (a10)
  {
    v16 = *(float *)&a3;
    v23 = (float32x2_t *)result;
    if (RB::Fill::Gradient::sample_alpha(result, 0.0, a3, a4, a5, a6) <= 0.0)
    {
      v24 = RB::Bounds::Bounds(&v38, *a9, a9[1]);
    }
    else
    {
      v24 = *(float32x2_t *)(a8 + 160);
      v25 = *(int32x2_t *)(a8 + 168);
      v38 = (int32x2_t)v24;
      v39 = v25;
    }
    *(float *)&v26 = v16;
    RB::Fill::Gradient::set_gradient_color((uint64_t)v23, (float16x4_t *)((char *)&v36 + 4), a8, v26);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a8, (RB::Device *)0x58, 4uLL, 0, &v40);
    v27 = v40;
    if (v40)
    {
      v28 = *((_QWORD *)v40 + 7) + v41.i64[0];
      v29 = v35[0];
      *(_OWORD *)(v28 + 16) = v35[1];
      v31 = v35[3];
      v30 = v36;
      v32 = v35[2];
      *(_QWORD *)(v28 + 80) = v37;
      *(_OWORD *)(v28 + 48) = v31;
      *(_OWORD *)(v28 + 64) = v30;
      *(_OWORD *)(v28 + 32) = v32;
      *(_OWORD *)v28 = v29;
    }
    else
    {
      v40 = 0;
      v41 = 0uLL;
    }
    *(_DWORD *)(a8 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a8, v27);
    *(int32x2_t *)(a8 + 188) = vmovn_s64(v41);
    v33 = *(_DWORD *)(a8 + 136) == 2;
    LODWORD(v40) = ((a16 & 0x3F) << 6) | 0x1024;
    HIDWORD(v40) = a14 | (2 * v33);
    RB::Fill::Gradient::set_fill_state(v23, (int *)&v40, a8, v16);
    if (a11)
      v34 = 2;
    else
      v34 = 1;
    *(_DWORD *)(a8 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a8, a10);
    *(_BYTE *)(a8 + 236) = v34;
    result = (RB::Fill::Gradient *)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a8, (const char *)v40, 4, ***(_QWORD ***)a8 + 80, 0, 1uLL, v38, v39);
    *(_QWORD *)(a8 + 228) = 0;
    *(_QWORD *)(a8 + 220) = 0;
    *(_BYTE *)(a8 + 236) = 0;
  }
  return result;
}

void sub_209B5D740(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 232) = 0;
  *(_BYTE *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

_QWORD *RB::AlphaGradientEffect::encode(RB::AlphaGradientEffect *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Gradient::encode(this, a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::AlphaGradientEffect::decode(RB::AlphaGradientEffect *this, RB::Decoder *a2)
{
  uint64_t result;
  uint64_t v5;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::Fill::Gradient::decode((unint64_t *)this, (RB::Heap **)a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::AlphaGradientEffect::print(RB::AlphaGradientEffect *this, std::string *a2)
{
  uint64_t v4;
  int v5;
  void (**v6)(RB::XML::Value::Gradient *__hidden);
  void *v7;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::XML::Value::Gradient::Gradient((RB::XML::Value::Gradient *)&v6, this);
  RB::XML::Element::set<RB::XML::Value::Gradient>((_QWORD *)v4, (uint64_t)"alpha-gradient", (uint64_t)&v6);
  v6 = &off_24C229290;
  if (v7)
    free(v7);
  a2[1].__r_.__value_.__s.__data_[16] = 1;
  RB::XML::Element::print((RB::XML::Element *)v4, a2, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B5D918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  _DWORD *v11;
  int v13;

  v13 = v11[2] - 1;
  v11[2] = v13;
  if (!v13)
    (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 8))(v11);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Gradient>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *result;
  __int128 *v13;
  _OWORD *v14;
  uint64_t v15;
  __int128 v16;

  v6 = (_QWORD *)operator new();
  v7 = (uint64_t)v6;
  v8 = 0;
  *v6 = &off_24C229290;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = 0;
  v9 = *(_QWORD *)(a3 + 16);
  if (v9)
  {
    v13 = *(__int128 **)(a3 + 8);
    RB::vector<RB::Fill::Gradient::Stop,0ul,unsigned long>::reserve_slow((uint64_t)(v6 + 1), *(_QWORD *)(a3 + 16));
    v14 = (_OWORD *)(*(_QWORD *)(v7 + 8) + 16 * *(_QWORD *)(v7 + 16));
    v15 = v9;
    do
    {
      v16 = *v13++;
      *v14++ = v16;
      --v15;
    }
    while (v15);
    v8 = *(_QWORD *)(v7 + 16);
  }
  *(_QWORD *)(v7 + 16) = v8 + v9;
  *(_DWORD *)(v7 + 32) = *(_DWORD *)(a3 + 32);
  v10 = a1[7];
  if (a1[8] < (unint64_t)(v10 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v10 + 1);
    v10 = a1[7];
  }
  v11 = (_QWORD *)(a1[6] + 24 * v10);
  *v11 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Gradient,void>(v11 + 1, v7);
  ++a1[7];
  return result;
}

void sub_209B5DA74(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*v2)
    free(*v2);
  MEMORY[0x20BD16544](v1, 0x10A1C4050C3A8F3);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Gradient,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229F88;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B5DAF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Gradient *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Gradient>,std::allocator<RB::XML::Value::Gradient>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Gradient *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Gradient>,std::allocator<RB::XML::Value::Gradient>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void *RB::vector<RB::Fill::Gradient::Stop,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,16ul>(void *a1, size_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(16 * a3);
    v6 = v5 >> 4;
    if (v5 >> 4 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t rb_alpha_blend_mode(unsigned int a1)
{
  if (a1 > 3)
    return 12;
  else
    return rb_alpha_blend_mode(RBAlphaBlendMode)::table[a1];
}

uint64_t rb_alpha_blend_mode(int a1)
{
  int v1;
  unsigned int v2;

  if (a1 == 11)
    v1 = 2;
  else
    v1 = 0;
  if (a1 == 15)
    v2 = 3;
  else
    v2 = v1;
  if (a1)
    return v2;
  else
    return 1;
}

uint64_t cg_line_cap(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return dword_209BD709C[(char)a1];
}

uint64_t rb_transition_method(int a1)
{
  char v1;

  if ((a1 - 1) >= 8)
    v1 = 0;
  else
    v1 = 0x408070605030201uLL >> (8 * (a1 - 1));
  return v1 & 0xF;
}

uint64_t rb_transition_method(Method a1)
{
  if (((_BYTE)a1 - 1) > 7u)
    return 0;
  else
    return dword_209BD7104[(char)((_BYTE)a1 - 1)];
}

unint64_t rb_shader_type(unsigned int a1)
{
  uint64_t v1;

  if (a1 >= 5)
    v1 = 0;
  else
    v1 = a1;
  return v1 | ((unint64_t)(a1 < 5) << 32);
}

uint64_t RBInvalidateCachedImage(RB::Device *a1, CGImage *a2)
{
  unsigned int Identifier;

  Identifier = CGImageGetIdentifier();
  return RB::Device::set_texture_cache((uint64_t)a1, 0, Identifier, 0);
}

uint64_t *RBGetCachedIOSurfaceTexture(uint64_t **a1, IOSurfaceRef buffer, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v9;
  IOSurfaceID ID;
  uint64_t *result;
  uint64_t v12;
  unsigned int entry;
  uint64_t v14;
  int v15;

  v9 = **a1;
  ID = IOSurfaceGetID(buffer);
  result = RB::Device::texture_cache(v9, 1, ID);
  if (result)
  {
    v12 = (uint64_t)result;
    entry = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
    if ((entry & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      v14 = v12 + 32;
      if (*(_QWORD *)(v12 + 48))
        v14 = *(_QWORD *)(v12 + 48);
      return *(uint64_t **)(v14 + 16 * entry + 8);
    }
  }
  return result;
}

uint64_t RBMakeCachedIOSurfaceTexture(uint64_t **a1, IOSurfaceRef buffer, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v10;
  IOSurfaceID ID;
  int32x2_t *v12;
  unsigned int Width;
  unsigned int Height;
  int v16;

  v10 = **a1;
  ID = IOSurfaceGetID(buffer);
  v12 = (int32x2_t *)RB::Device::texture_cache(v10, 1, ID);
  if (!v12)
  {
    Width = IOSurfaceGetWidth(buffer);
    Height = IOSurfaceGetHeight(buffer);
    v12 = (int32x2_t *)operator new();
    objc_initWeakOrNil((id *)v12, buffer);
    v12[1] = (int32x2_t)__PAIR64__(Height, Width);
    v12[6] = 0;
    v12[2] = 0;
    v12[3] = 0;
    v12[7] = (int32x2_t)0x100000000;
    v12[9] = 0;
    v12[10] = (int32x2_t)0x100000000;
    RB::Device::set_texture_cache(v10, 1, ID, (size_t *)v12);
  }
  return RB::TextureCache::prepare((uint64_t)v12, (uint64_t)*a1, buffer, (unsigned __int8 *)&v16);
}

void sub_209B5DF50(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

uint64_t RBInvalidateCachedIOSurface(RB::Device *a1, IOSurfaceRef buffer)
{
  IOSurfaceID ID;

  ID = IOSurfaceGetID(buffer);
  return RB::Device::set_texture_cache((uint64_t)a1, 1, ID, 0);
}

uint64_t *RBGetCachedMTLTexture(uint64_t **a1, id object, uint64_t a3, float64x2_t *a4, char a5)
{
  uint64_t v9;
  unsigned int AssociatedObject;
  uint64_t *result;
  uint64_t v12;
  unsigned int entry;
  uint64_t v14;
  int v15;

  v9 = **a1;
  if (!AssociatedObject)
    return 0;
  result = RB::Device::texture_cache(v9, 2, AssociatedObject);
  if (!result)
    return result;
  v12 = (uint64_t)result;
  entry = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
  if ((entry & 0x80000000) != 0)
    return 0;
  v14 = v12 + 32;
  if (*(_QWORD *)(v12 + 48))
    v14 = *(_QWORD *)(v12 + 48);
  return *(uint64_t **)(v14 + 16 * entry + 8);
}

uint64_t RBMakeCachedMTLTexture(uint64_t *a1, id object, uint64_t a3, float64x2_t *a4, char a5)
{
  uint64_t v10;
  void *v11;
  int32x2_t *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t result;
  uint64_t v16;
  unsigned int v17;
  int v18;

  v10 = *(_QWORD *)*a1;
  if (!(_DWORD)v11)
  {
    v16 = *(_QWORD *)(v10 + 24);
    result = objc_msgSend(object, "device");
    if (v16 != result)
      return result;
    result = objc_msgSend(object, "textureType");
    if (result != 2)
      return result;
    do
    {
      v11 = (void *)(v17 + 1);
    }
  }
  v12 = (int32x2_t *)RB::Device::texture_cache(v10, 2, v11);
  if (!v12)
  {
    v12 = (int32x2_t *)operator new();
    v13 = objc_msgSend(object, "width");
    v14 = objc_msgSend(object, "height");
    objc_initWeakOrNil((id *)v12, object);
    v12[1] = (int32x2_t)__PAIR64__(v14, v13);
    v12[6] = 0;
    v12[2] = 0;
    v12[3] = 0;
    v12[7] = (int32x2_t)0x100000000;
    v12[9] = 0;
    v12[10] = (int32x2_t)0x100000000;
    RB::Device::set_texture_cache(v10, 2, v11, (size_t *)v12);
  }
  return RB::TextureCache::prepare((uint64_t)v12, *a1, object, (unsigned __int8 *)&v18);
}

void sub_209B5E1FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

id RBInvalidateCachedMTLTexture(uint64_t a1, id object)
{
  id result;

  if ((_DWORD)result)
    return (id)RB::Device::set_texture_cache(a1, 2, result, 0);
  return result;
}

void RBUpdateIOSurfaceCodingProxy(id *a1, uint64_t a2)
{
  __CFString *v4;
  Class v5;
  objc_class *v6;
  char isKindOfClass;
  id v8;
  uint64_t v9;

  if (*MEMORY[0x24BDE5418])
    v4 = CFSTR("LKCGImageCodingProxy");
  else
    v4 = CFSTR("CAIOSurfaceCodingProxy");
  v5 = NSClassFromString(&v4->isa);
  if (v5)
  {
    v6 = v5;
    if (*a1)
    {
      isKindOfClass = objc_opt_isKindOfClass();
      v8 = *a1;
      if ((isKindOfClass & 1) != 0)
      {
        if (v8)
          return;
      }
      else
      {

        *a1 = 0;
      }
    }
    if (-[objc_class instancesRespondToSelector:](v6, "instancesRespondToSelector:", sel_initWithObject_))
    {
      v9 = objc_msgSend([v6 alloc], "initWithObject:", a2);

      *a1 = (id)v9;
    }
  }
}

BOOL RBProjectVersion(int a1, int a2, int a3)
{
  unsigned __int8 v3;
  char v4;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;
  int v11;

  if ((v3 & 1) == 0)
  {
    v11 = a1;
    v9 = a2;
    v10 = a3;
    a2 = v9;
    a3 = v10;
    v7 = v6;
    a1 = v11;
    if (v7)
    {
      RBProjectVersion::versions = RBProjectVersion::$_0::operator()();
      dword_2545ADA28 = v8;
      a1 = v11;
      a2 = v9;
      a3 = v10;
    }
  }
  if ((int)RBProjectVersion::versions >= a1)
    v4 = 1;
  else
    v4 = -1;
  if ((_DWORD)RBProjectVersion::versions == a1)
  {
    v4 = SHIDWORD(RBProjectVersion::versions) >= a2 ? 1 : -1;
    if (HIDWORD(RBProjectVersion::versions) == a2)
    {
      v4 = -1;
      if (dword_2545ADA28 >= a3)
        v4 = 1;
      if (dword_2545ADA28 == a3)
        v4 = 0;
    }
  }
  return (v4 & 0x80) == 0;
}

uint64_t RBProjectVersion::$_0::operator()()
{
  unsigned int v0;
  uint64_t v1;
  char *__endptr;

  __endptr = 0;
  v0 = strtol("6.0.87", &__endptr, 10);
  v1 = 0;
  if (*__endptr == 46)
  {
    v1 = strtol(__endptr + 1, &__endptr, 10) << 32;
    if (*__endptr == 46)
      strtol(__endptr + 1, &__endptr, 10);
  }
  return v1 | v0;
}

float RB::BezierTiming::Fn::solve(RB::BezierTiming::Fn *this, float a2, float a3)
{
  double v3;
  float v4;
  float v5;
  double v6;
  double v7;
  double v8;
  double v9;
  int v10;
  double v11;
  double v12;
  double v13;
  float v14;
  double v15;
  double v16;
  int v17;
  double v18;
  double v20;

  v3 = a2;
  v5 = *((float *)this + 1);
  v4 = *((float *)this + 2);
  v6 = v4;
  v7 = v5;
  v8 = *(float *)this;
  v9 = a3;
  v10 = 8;
  v11 = a2;
  do
  {
    v12 = -(v3 - (v8 + (v7 + v11 * v6) * v11) * v11);
    if (fabs(v12) < v9)
      return v11;
    v13 = v8 + ((float)(v5 + v5) + v11 * (float)(v4 * 3.0)) * v11;
    if (fabs(v13) < 0.000001)
      break;
    v11 = v11 - v12 / v13;
    --v10;
  }
  while (v10);
  v14 = 0.0;
  if (a2 >= 0.0)
  {
    v14 = 1.0;
    if (a2 <= 1.0)
    {
      v15 = 0.0;
      v16 = 1.0;
      v17 = -1025;
      v18 = v3;
      do
      {
        if (__CFADD__(v17++, 1))
          break;
        v20 = -(v3 - (v8 + (v7 + v18 * v6) * v18) * v18);
        if (fabs(v20) < v9)
          break;
        if (v20 >= 0.0)
          v16 = v18;
        else
          v15 = v18;
        v18 = v15 + (v16 - v15) * 0.5;
      }
      while (v15 < v16);
      return v18;
    }
  }
  return v14;
}

float RB::BezierTiming::eval(RB::BezierTiming *this, float a2)
{
  float v3;

  v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return (*((float *)this + 3) + (*((float *)this + 4) + *((float *)this + 5) * v3) * v3) * v3;
}

float RB::BezierTiming::derivative(RB::BezierTiming *this, float a2)
{
  float v3;

  v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return *((float *)this + 3)
       + ((float)(*((float *)this + 4) + *((float *)this + 4)) + (float)(*((float *)this + 5) * 3.0) * v3) * v3;
}

float RB::BezierTiming::eval_with_derivative(RB::BezierTiming *this, float a2)
{
  float v3;

  v3 = RB::BezierTiming::Fn::solve(this, a2, 0.001);
  return (*((float *)this + 3) + (*((float *)this + 4) + *((float *)this + 5) * v3) * v3) * v3;
}

float RB::SpringTiming::eval(RB::SpringTiming *this, float a2)
{
  float v3;
  __float2 v4;
  float v5;
  float v6;

  v3 = -a2;
  if (*((float *)this + 1) >= 1.0)
  {
    v6 = *((float *)this + 3) + (float)(*((float *)this + 4) * a2);
    v5 = expf(*(float *)this * v3) * v6;
  }
  else
  {
    v4 = __sincosf_stret(*((float *)this + 2) * a2);
    v5 = (float)((float)(*((float *)this + 3) * v4.__cosval) + (float)(*((float *)this + 4) * v4.__sinval))
       * expf((float)(*((float *)this + 1) * v3) * *(float *)this);
  }
  return 1.0 - v5;
}

float RB::SpringTiming::derivative(RB::SpringTiming *this, float a2)
{
  __float2 v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;

  if (*((float *)this + 1) >= 1.0)
  {
    v9 = *(float *)this;
    v7 = expf(-(float)(a2 * *(float *)this));
    v8 = (float)(*((float *)this + 3) * v9) + (float)(*((float *)this + 4) * (float)((float)(v9 * a2) + -1.0));
  }
  else
  {
    v4 = __sincosf_stret(*((float *)this + 2) * a2);
    v6 = *(float *)this;
    v5 = *((float *)this + 1);
    v7 = expf((float)-(float)(a2 * v5) * *(float *)this);
    v8 = (float)((float)-(float)((float)(*((float *)this + 4) * *((float *)this + 2))
                               - (float)((float)(v6 * v5) * *((float *)this + 3)))
               * v4.__cosval)
       + (float)((float)((float)(*((float *)this + 2) * *((float *)this + 3))
                       + (float)((float)(v6 * v5) * *((float *)this + 4)))
               * v4.__sinval);
  }
  return v8 * v7;
}

unint64_t RB::Animation::size(uint64_t a1, unint64_t a2)
{
  unint64_t result;
  uint64_t v4;

  result = 0;
  while (result < a2)
  {
    v4 = *(unsigned int *)(a1 + 4 * result);
    if ((_DWORD)v4 == 18)
    {
      result += (2 * *(_DWORD *)(a1 + 4 * result + 4) + 3);
      return result;
    }
    result += RB::Animation::_term_args[v4] + 1;
    if ((v4 - 15) <= 0xFFFFFFFB)
      return result;
  }
  return result;
}

uint64_t RB::Animation::hash(unsigned int *a1, uint64_t a2)
{
  uint64_t result;
  unsigned int v4;

  for (result = 2166136261; a2; --a2)
  {
    v4 = *a1++;
    result = (16777619 * result) ^ v4;
  }
  return result;
}

BOOL RB::Animation::equal(_DWORD *a1, unint64_t a2, _DWORD *a3, uint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  int v7;

  if (a2 != a4)
    return 0;
  if (!a2)
    return 1;
  if (*a1 != *a3)
    return 0;
  v4 = 1;
  do
  {
    v5 = v4;
    if (a2 == v4)
      break;
    v6 = a1[v4];
    v7 = a3[v4++];
  }
  while (v6 == v7);
  return v5 >= a2;
}

float RB::Animation::active_duration(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  float v3;
  float v4;
  float *v5;
  uint64_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float v9;
  float v10;
  float32x2_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float32x2_t v15;
  float32x2_t v16;
  float v18;

  if (a2)
  {
    v2 = 0;
    v3 = 0.0;
    v4 = 1.0;
    while (2)
    {
      v5 = (float *)(a1 + 4 * v2);
      v6 = *(unsigned int *)v5;
      switch((int)v6)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 9:
        case 10:
        case 15:
        case 16:
        case 17:
          v9 = v5[1];
          goto LABEL_17;
        case 5:
          v13 = v5[1];
          v14 = 1.5;
          goto LABEL_15;
        case 6:
          v13 = v5[1];
          v14 = 1.65;
          goto LABEL_15;
        case 7:
          v13 = v5[1];
          v14 = 2.075;
LABEL_15:
          v9 = v13 * v14;
          goto LABEL_17;
        case 11:
          v4 = v5[1] * v4;
          goto LABEL_6;
        case 12:
          v7 = vrecpe_f32((float32x2_t)LODWORD(v4));
          v8 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v4), v7), v7);
          v3 = vmlas_n_f32(v3, v5[1], vmul_f32(v8, vrecps_f32((float32x2_t)LODWORD(v4), v8)).f32[0]);
          goto LABEL_6;
        case 13:
        case 14:
          v18 = v4;
          v10 = v5[1] * RB::Animation::active_duration(v5 + 2, a2 - v2 - 2);
          v11 = vrecpe_f32((float32x2_t)LODWORD(v18));
          v12 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v18), v11), v11);
          LODWORD(v9) = vmul_f32(v12, vrecps_f32((float32x2_t)LODWORD(v18), v12)).u32[0];
          return v3 + (float)(v10 * v9);
        case 18:
          v9 = v5[2];
          goto LABEL_17;
        default:
LABEL_6:
          v2 += RB::Animation::_term_args[v6] + 1;
          if (v2 >= a2)
            goto LABEL_9;
          continue;
      }
    }
  }
  v4 = 1.0;
  v3 = 0.0;
LABEL_9:
  v9 = 0.0;
LABEL_17:
  v15 = vrecpe_f32((float32x2_t)LODWORD(v4));
  v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v4), v15), v15);
  LODWORD(v10) = vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v4), v16)).u32[0];
  return v3 + (float)(v10 * v9);
}

uint64_t RB::Animation::prepare(uint64_t result, unint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  unint64_t v14;
  float v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;

  if (a2)
  {
    v3 = 0;
    while (2)
    {
      v4 = *(unsigned int *)(result + 4 * v3);
      switch((int)v4)
      {
        case 0:
        case 1:
        case 15:
        case 16:
        case 17:
        case 18:
          return result;
        case 2:
          v14 = 0x3EF5C294BF3D70A6;
          goto LABEL_13;
        case 3:
          *(_QWORD *)a3 = 0x3FDEB852BF3D70A4;
          v15 = 3.0;
          v12 = -2.0;
          v9 = 0.0;
          v16 = 5;
          v17 = 4;
          v18 = 3;
          v19 = 2;
          v13 = 0.0;
          goto LABEL_23;
        case 4:
          v14 = 0xBF47AE143F051EB8;
LABEL_13:
          *(_QWORD *)a3 = v14;
          v13 = 0.0;
          v15 = 3.0;
          v12 = -2.0;
          v16 = 5;
          v17 = 4;
          v18 = 3;
          v9 = 1.26;
          goto LABEL_19;
        case 5:
          *(_DWORD *)a3 = 1065354305;
          v15 = 1.0;
          v12 = 0.0;
          v16 = 4;
          v17 = 3;
          v18 = 2;
          v9 = 15.708;
          v19 = 1;
          v13 = 15.708;
          goto LABEL_23;
        case 6:
          *(_DWORD *)a3 = 1061157876;
          v15 = 1.0;
          v13 = 1.1337;
          v16 = 4;
          v17 = 3;
          v12 = 10.391;
          goto LABEL_17;
        case 7:
          *(_DWORD *)a3 = 1057798793;
          v15 = 1.0;
          v13 = 0.65807;
          v16 = 4;
          v17 = 3;
          v12 = 13.122;
LABEL_17:
          v18 = 2;
          v9 = 15.708;
          goto LABEL_22;
        case 8:
          v20 = (float *)(result + 4 * v3);
          v21 = v20[2];
          v22 = v20[3];
          v9 = v21 * 3.0;
          v23 = (float)(v20[4] - v21) * 3.0;
          v24 = v23 - v9;
          v25 = 1.0 - v23;
          v13 = v22 * 3.0;
          v26 = (float)(v20[5] - v22) * 3.0;
          v15 = v26 - v13;
          v12 = 1.0 - v26;
          *(float *)a3 = v25;
          *(float *)(a3 + 4) = v24;
          v16 = 5;
          v17 = 4;
          v18 = 3;
LABEL_19:
          v19 = 2;
          goto LABEL_23;
        case 9:
        case 10:
          v5 = (float *)(result + 4 * v3);
          v6 = v5[2];
          v7 = v5[3];
          v8 = 0.0;
          if ((_DWORD)v4 == 10)
            v8 = v5[5];
          v9 = sqrtf(v7 / v6);
          v10 = sqrtf(v7 * v6);
          v11 = v5[4] / (float)(v10 + v10);
          if (v11 >= 1.0)
          {
            v13 = v9 - v8;
            v12 = 0.0;
          }
          else
          {
            v12 = sqrtf(-(float)((float)(v11 * v11) + -1.0)) * v9;
            v13 = (float)-(float)(v8 - (float)(v11 * v9)) / v12;
          }
          *(float *)a3 = v11;
          v15 = 1.0;
          v16 = 4;
          v17 = 3;
          v18 = 2;
LABEL_22:
          v19 = 1;
LABEL_23:
          *(float *)(a3 + 4 * v19) = v9;
          *(float *)(a3 + 4 * v18) = v12;
          *(float *)(a3 + 4 * v17) = v15;
          *(float *)(a3 + 4 * v16) = v13;
          break;
        default:
          v3 += RB::Animation::_term_args[v4] + 1;
          if (v3 < a2)
            continue;
          break;
      }
      break;
    }
  }
  return result;
}

void RB::Animation::eval(uint64_t a1, unint64_t a2, int32x2_t *a3, double a4, double a5)
{
  float v5;
  unint64_t v9;
  unint64_t v10;
  float *v11;
  uint64_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float v15;
  float v16;
  float32x2_t v17;
  float32x2_t v18;
  int32x2_t v19;
  __int32 v20;
  __int128 v21;
  float32x2_t v22;
  float32x2_t v23;
  __int128 v24;
  float32x2_t v25;
  float32x2_t v26;
  unsigned int *v27;
  unint64_t v28;
  unint64_t v29;
  float *v30;
  float *v31;
  float v32;
  _BYTE v33[20];
  __int32 v34;

  v5 = *(float *)&a4;
  if (a2)
  {
    v9 = 0;
    v10 = a2 - 2;
    while (2)
    {
      v11 = (float *)(a1 + 4 * v9);
      v12 = *(unsigned int *)v11;
      switch((int)v12)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 15:
        case 16:
        case 17:
          *(float *)&a4 = v11[1];
          v17 = vrecpe_f32(*(float32x2_t *)&a4);
          v18 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v17), v17);
          *(float *)&a4 = v5 * vmul_f32(v18, vrecps_f32(*(float32x2_t *)&a4, v18)).f32[0];
          if (*(float *)&a4 < 0.0)
            *(float *)&a4 = 0.0;
          if (*(float *)&a4 > 1.0)
            *(float *)&a4 = 1.0;
          switch((int)v12)
          {
            case 0:
            case 1:
            case 15:
            case 16:
            case 17:
              return;
            case 2:
            case 3:
            case 4:
            case 8:
              v19 = *a3;
              v20 = a3[1].i32[1];
              *(_DWORD *)v33 = a3[1].i32[0];
              v34 = v20;
              *(int32x2_t *)&v21 = vrev64_s32(v19);
              *((int32x2_t *)&v21 + 1) = vrev64_s32(a3[2]);
              *(_OWORD *)&v33[4] = v21;
              RB::BezierTiming::Fn::solve((RB::BezierTiming::Fn *)v33, *(float *)&a4, 0.001);
              break;
            default:
              abort();
          }
          return;
        case 5:
        case 6:
        case 7:
          *(float *)&a5 = v11[1];
          v22 = vrecpe_f32(*(float32x2_t *)&a5);
          v23 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v22), v22);
          v5 = (float)(v5 * 0.4) * vmul_f32(v23, vrecps_f32(*(float32x2_t *)&a5, v23)).f32[0];
          goto LABEL_20;
        case 9:
        case 10:
LABEL_20:
          *(_QWORD *)&v24 = vrev64q_s32(*(int32x4_t *)a3->i8).u64[0];
          *((int32x2_t *)&v24 + 1) = a3[1];
          *(_OWORD *)v33 = v24;
          *(_DWORD *)&v33[16] = a3[2].i32[0];
          RB::SpringTiming::eval((RB::SpringTiming *)v33, fmaxf(v5, 0.0));
          return;
        case 11:
          v5 = v11[1] * v5;
          goto LABEL_11;
        case 12:
          v5 = fmaxf(v5 - v11[1], 0.0);
          goto LABEL_11;
        case 13:
        case 14:
          *(float *)&a4 = RB::Animation::active_duration((uint64_t)(v11 + 2), v10 - v9);
          v13 = vrecpe_f32((float32x2_t)LODWORD(a4));
          v14 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a4), v13), v13);
          a5 = COERCE_DOUBLE(vmul_f32(v14, vrecps_f32((float32x2_t)LODWORD(a4), v14)));
          *(float *)&a5 = floorf(v5 * *(float *)&a5);
          v5 = v5 - (float)(*(float *)&a5 * *(float *)&a4);
          if ((_DWORD)v12 == 14 && ((int)*(float *)&a5 & 1) != 0)
          {
            v15 = *(float *)&a4 - v5;
            v16 = *(float *)&a4 + -0.00001;
            if (v16 >= v15)
              v5 = v15;
            else
              v5 = v16;
          }
          goto LABEL_11;
        case 18:
          *(float *)&a4 = v11[2];
          v25 = vrecpe_f32(*(float32x2_t *)&a4);
          v26 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v25), v25);
          *(float *)&a4 = v5 * vmul_f32(v26, vrecps_f32(*(float32x2_t *)&a4, v26)).f32[0];
          if (*(float *)&a4 < 0.0)
            *(float *)&a4 = 0.0;
          if (*(float *)&a4 > 1.0)
            *(float *)&a4 = 1.0;
          if (*((_DWORD *)v11 + 1) >= 2u)
          {
            v27 = (unsigned int *)(v11 + 3);
            v28 = *((unsigned int *)v11 + 1);
            do
            {
              v29 = v28 >> 1;
              v30 = (float *)&v27[2 * (v28 >> 1)];
              v32 = *v30;
              v31 = v30 + 2;
              v28 += ~(v28 >> 1);
              if (v32 < *(float *)&a4)
                v27 = (unsigned int *)v31;
              else
                v28 = v29;
            }
            while (v28);
          }
          return;
        default:
LABEL_11:
          v9 += RB::Animation::_term_args[v12] + 1;
          if (v9 >= a2)
            return;
          continue;
      }
    }
  }
}

void RB::Animation::speed(uint64_t a1, unint64_t a2, int32x2_t *a3, double a4, double a5)
{
  float v8;
  unint64_t v9;
  unint64_t v10;
  float v11;
  float *v12;
  uint64_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  float v18;
  float32x2_t v19;
  float32x2_t v20;
  int32x2_t v21;
  __int32 v22;
  __int128 v23;
  float32x2_t v24;
  float32x2_t v25;
  __int128 v26;
  float32x2_t v27;
  float32x2_t v28;
  float v29;
  unint64_t v30;
  unsigned int *v31;
  unint64_t v32;
  unint64_t v33;
  float *v34;
  float *v35;
  float v36;
  _BYTE v37[20];
  __int32 v38;

  if (a2)
  {
    v8 = *(float *)&a4;
    v9 = 0;
    v10 = a2 - 2;
    v11 = 1.0;
    while (2)
    {
      v12 = (float *)(a1 + 4 * v9);
      v13 = *(unsigned int *)v12;
      switch((int)v13)
      {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 8:
        case 15:
        case 16:
        case 17:
          *(float *)&a4 = v12[1];
          v19 = vrecpe_f32(*(float32x2_t *)&a4);
          v20 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v19), v19);
          *(float *)&a4 = v8 * vmul_f32(v20, vrecps_f32(*(float32x2_t *)&a4, v20)).f32[0];
          if (*(float *)&a4 < 0.0)
            *(float *)&a4 = 0.0;
          if (*(float *)&a4 > 1.0)
            *(float *)&a4 = 1.0;
          switch((int)v13)
          {
            case 0:
            case 1:
            case 15:
            case 16:
            case 17:
              return;
            case 2:
            case 3:
            case 4:
            case 8:
              v21 = *a3;
              v22 = a3[1].i32[1];
              *(_DWORD *)v37 = a3[1].i32[0];
              v38 = v22;
              *(int32x2_t *)&v23 = vrev64_s32(v21);
              *((int32x2_t *)&v23 + 1) = vrev64_s32(a3[2]);
              *(_OWORD *)&v37[4] = v23;
              RB::BezierTiming::derivative((RB::BezierTiming *)v37, *(float *)&a4);
              break;
            default:
              abort();
          }
          return;
        case 5:
        case 6:
        case 7:
          *(float *)&a5 = v12[1];
          v24 = vrecpe_f32(*(float32x2_t *)&a5);
          v25 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v24), v24);
          v8 = (float)(v8 * 0.4) * vmul_f32(v25, vrecps_f32(*(float32x2_t *)&a5, v25)).f32[0];
          goto LABEL_20;
        case 9:
        case 10:
LABEL_20:
          *(_QWORD *)&v26 = vrev64q_s32(*(int32x4_t *)a3->i8).u64[0];
          *((int32x2_t *)&v26 + 1) = a3[1];
          *(_OWORD *)v37 = v26;
          *(_DWORD *)&v37[16] = a3[2].i32[0];
          fabsf(RB::SpringTiming::derivative((RB::SpringTiming *)v37, fmaxf(v8, 0.0)) * v11);
          return;
        case 11:
          v18 = v12[1];
          v8 = v18 * v8;
          v11 = v18 * v11;
          goto LABEL_11;
        case 12:
          v8 = fmaxf(v8 - v12[1], 0.0);
          goto LABEL_11;
        case 13:
        case 14:
          *(float *)&a4 = RB::Animation::active_duration((uint64_t)(v12 + 2), v10 - v9);
          v14 = vrecpe_f32((float32x2_t)LODWORD(a4));
          v15 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a4), v14), v14);
          a5 = COERCE_DOUBLE(vmul_f32(v15, vrecps_f32((float32x2_t)LODWORD(a4), v15)));
          *(float *)&a5 = floorf(v8 * *(float *)&a5);
          v8 = v8 - (float)(*(float *)&a5 * *(float *)&a4);
          if ((_DWORD)v13 == 14 && ((int)*(float *)&a5 & 1) != 0)
          {
            v16 = *(float *)&a4 - v8;
            v17 = *(float *)&a4 + -0.00001;
            if (v17 >= v16)
              v8 = v16;
            else
              v8 = v17;
          }
          goto LABEL_11;
        case 18:
          *(float *)&a4 = v12[2];
          v27 = vrecpe_f32(*(float32x2_t *)&a4);
          v28 = vmul_f32(vrecps_f32(*(float32x2_t *)&a4, v27), v27);
          v29 = v8 * vmul_f32(v28, vrecps_f32(*(float32x2_t *)&a4, v28)).f32[0];
          if (v29 < 0.0)
            v29 = 0.0;
          if (v29 > 1.0)
            v29 = 1.0;
          v30 = *((unsigned int *)v12 + 1);
          if (v30 >= 2)
          {
            v31 = (unsigned int *)(v12 + 3);
            v32 = v30;
            do
            {
              v33 = v32 >> 1;
              v34 = (float *)&v31[2 * (v32 >> 1)];
              v36 = *v34;
              v35 = v34 + 2;
              v32 += ~(v32 >> 1);
              if (v36 < v29)
                v31 = (unsigned int *)v35;
              else
                v32 = v33;
            }
            while (v32);
          }
          return;
        default:
LABEL_11:
          v9 += RB::Animation::_term_args[v13] + 1;
          if (v9 >= a2)
            return;
          continue;
      }
    }
  }
}

BOOL RB::Animation::operator==(uint64_t a1, uint64_t a2)
{
  _DWORD *v2;
  unint64_t v3;
  _DWORD *v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  int v8;

  if (*(_QWORD *)(a1 + 24))
    v2 = *(_DWORD **)(a1 + 24);
  else
    v2 = (_DWORD *)a1;
  v3 = *(unsigned int *)(a1 + 32);
  v4 = *(_DWORD **)(a2 + 24);
  if (!v4)
    v4 = (_DWORD *)a2;
  if ((_DWORD)v3 != *(_DWORD *)(a2 + 32))
    return 0;
  if (!(_DWORD)v3)
    return 1;
  if (*v2 != *v4)
    return 0;
  v5 = 1;
  do
  {
    v6 = v5;
    if (v3 == v5)
      break;
    v7 = v2[v5];
    v8 = v4[v5++];
  }
  while (v7 == v8);
  return v6 >= v3;
}

uint64_t RB::Animation::hash(RB::Animation *this)
{
  uint64_t result;
  uint64_t v3;
  unsigned int v4;

  result = 2166136261;
  v3 = *((unsigned int *)this + 8);
  if ((_DWORD)v3)
  {
    if (*((_QWORD *)this + 3))
      this = (RB::Animation *)*((_QWORD *)this + 3);
    do
    {
      v4 = *(_DWORD *)this;
      this = (RB::Animation *)((char *)this + 4);
      result = (16777619 * result) ^ v4;
      --v3;
    }
    while (v3);
  }
  return result;
}

_QWORD *RB::Animation::encode(_QWORD *this, RB::Encoder *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  unint64_t v10;
  unsigned int v11;
  const unsigned int *v12;
  uint64_t v13;
  int v14;

  if (*((_DWORD *)this + 8))
  {
    v3 = (uint64_t)this;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v3 + 24);
      if (!v5)
        v5 = v3;
      v6 = (unsigned int *)(v5 + 4 * v4);
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      v7 = *v6;
      RB::ProtobufEncoder::encode_varint(a2, 8uLL);
      RB::ProtobufEncoder::encode_varint(a2, v7);
      v9 = v6 + 1;
      v8 = *v6;
      if ((_DWORD)v8 == 18)
      {
        v10 = *v9;
        if ((_DWORD)v10)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
          RB::ProtobufEncoder::encode_varint(a2, v10);
          v11 = (2 * *v9) | 1;
        }
        else
        {
          v11 = 1;
        }
        v12 = v6 + 2;
      }
      else
      {
        v11 = RB::Animation::_term_args[v8];
        v12 = v6 + 1;
      }
      RB::ProtobufEncoder::packed_fixed32_field(a2, 2, v12, v11);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
      v13 = *v6;
      if ((_DWORD)v13 == 18)
        v14 = 2 * *v9 + 2;
      else
        v14 = RB::Animation::_term_args[v13];
      v4 += v14 + 1;
    }
    while (v4 < *(_DWORD *)(v3 + 32));
  }
  return this;
}

uint64_t RB::Animation::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  uint64_t result;
  uint64_t v5;
  int v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t field;
  unint64_t v10;
  float v11;
  size_t v12;
  size_t v13;
  _BYTE *v14;
  unint64_t v15;
  unint64_t v16;
  int v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unsigned int v21;
  uint64_t v22;
  int *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  _BYTE v27[32];
  void *v28;
  size_t v29;
  unint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          v6 = 0;
          v7 = 0;
          LODWORD(v8) = 0;
          v28 = 0;
          v29 = 0;
          v30 = 8;
          while (1)
          {
            field = RB::ProtobufDecoder::next_field(this);
            if (!field)
              break;
            v10 = field >> 3;
            if ((field >> 3) == 2)
            {
              v11 = RB::ProtobufDecoder::float_field(this, field);
              v12 = v29;
              v13 = v29 + 1;
              if (v30 < v29 + 1)
              {
                RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(v27, v13);
                v12 = v29;
                v13 = v29 + 1;
              }
              v14 = v28;
              if (!v28)
                v14 = v27;
              *(float *)&v14[4 * v12] = v11;
              v29 = v13;
            }
            else if ((_DWORD)v10 == 3)
            {
              v6 = RB::ProtobufDecoder::uint_field(this, field);
            }
            else if ((_DWORD)v10 == 1)
            {
              v15 = RB::ProtobufDecoder::uint_field(this, field);
              v16 = v15 | 0x100000000;
              if (v15 > 0x12)
                v16 = 0;
              v7 = v16;
              v8 = HIDWORD(v16);
            }
            else
            {
              RB::ProtobufDecoder::skip_field(this, field);
            }
          }
          if ((_DWORD)v8)
          {
            if (v7 == 18)
              v17 = (2 * v6) | 1;
            else
              v17 = RB::Animation::_term_args[v7];
            if (v29 == v17)
            {
              v18 = *(_DWORD *)(a1 + 32);
              if (*(_DWORD *)(a1 + 36) < v18 + 1)
              {
                RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((void *)a1, v18 + 1);
                v18 = *(_DWORD *)(a1 + 32);
              }
              v19 = *(_QWORD *)(a1 + 24);
              if (!v19)
                v19 = a1;
              *(_DWORD *)(v19 + 4 * v18) = v7;
              v20 = *(_DWORD *)(a1 + 32);
              v21 = v20 + 1;
              *(_DWORD *)(a1 + 32) = v20 + 1;
              if (v7 == 18)
              {
                if (*(_DWORD *)(a1 + 36) < (v20 + 2))
                {
                  RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((void *)a1, v20 + 2);
                  v21 = *(_DWORD *)(a1 + 32);
                }
                v22 = *(_QWORD *)(a1 + 24);
                if (!v22)
                  v22 = a1;
                *(_DWORD *)(v22 + 4 * v21) = v6;
                v21 = *(_DWORD *)(a1 + 32) + 1;
                *(_DWORD *)(a1 + 32) = v21;
              }
              if (v28)
                v23 = (int *)v28;
              else
                v23 = (int *)v27;
              if (v29)
              {
                v24 = 4 * v29;
                do
                {
                  v25 = *v23;
                  if (*(_DWORD *)(a1 + 36) < v21 + 1)
                  {
                    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((void *)a1, v21 + 1);
                    v21 = *(_DWORD *)(a1 + 32);
                  }
                  v26 = *(_QWORD *)(a1 + 24);
                  if (!v26)
                    v26 = a1;
                  *(_DWORD *)(v26 + 4 * v21) = v25;
                  v21 = *(_DWORD *)(a1 + 32) + 1;
                  *(_DWORD *)(a1 + 32) = v21;
                  ++v23;
                  v24 -= 4;
                }
                while (v24);
              }
            }
            else
            {
              *((_BYTE *)this + 56) = 1;
              *(_QWORD *)this = *((_QWORD *)this + 1);
            }
          }
          if (v28)
            free(v28);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void sub_209B5F8AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  if (a13)
    free(a13);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Animation::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  float32x2_t *v6;
  uint64_t v7;
  const char *v8;
  _QWORD *v9;
  double v10;
  _QWORD *v11;
  double v12;
  _QWORD *v13;
  double v14;
  _QWORD *v15;
  double v16;
  _QWORD *v17;
  double v18;
  const char *v19;
  _QWORD *v20;
  double v21;
  _QWORD *v22;
  _QWORD *v23;
  double v24;
  _QWORD *v25;
  _QWORD *v26;
  double v27;
  double v28;
  int v29;
  _QWORD *v30;
  double v31;
  _QWORD *v32;
  void (**v33)(RB::XML::Value::FloatArray *__hidden);
  void *v34[2];

  if (*(_DWORD *)(this + 32))
  {
    v3 = this;
    v4 = 0;
    do
    {
      v5 = *(_QWORD *)(v3 + 24);
      if (!v5)
        v5 = v3;
      v6 = (float32x2_t *)(v5 + 4 * v4);
      v7 = v6->u32[0];
      v8 = "linear";
      switch((int)v7)
      {
        case 0:
          goto LABEL_23;
        case 1:
          v8 = "smoothstep";
          goto LABEL_23;
        case 2:
          v8 = "ease-in";
          goto LABEL_23;
        case 3:
          v8 = "ease-out";
          goto LABEL_23;
        case 4:
          v8 = "ease-in-ease-out";
          goto LABEL_23;
        case 5:
          v8 = "spring-0";
          goto LABEL_23;
        case 6:
          v8 = "spring-1";
          goto LABEL_23;
        case 7:
          v8 = "spring-2";
          goto LABEL_23;
        case 8:
          RB::XML::Document::push(a2, "bezier");
          v23 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v24 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v24;
          RB::XML::Element::set<RB::XML::Value::Float>(v23, (uint64_t)"duration", (uint64_t)&v33);
          v25 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C2290B0;
          *(float64x2_t *)v34 = vcvtq_f64_f32(v6[1]);
          RB::XML::Element::set<RB::XML::Value::Vec2>(v25, (uint64_t)"cp1", (uint64_t)&v33);
          v26 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C2290B0;
          *(float64x2_t *)v34 = vcvtq_f64_f32(v6[2]);
          RB::XML::Element::set<RB::XML::Value::Vec2>(v26, (uint64_t)"cp2", (uint64_t)&v33);
          goto LABEL_26;
        case 9:
        case 10:
          RB::XML::Document::push(a2, "spring");
          v9 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v10 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v10;
          RB::XML::Element::set<RB::XML::Value::Float>(v9, (uint64_t)"duration", (uint64_t)&v33);
          v11 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v12 = v6[1].f32[0];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v12;
          RB::XML::Element::set<RB::XML::Value::Float>(v11, (uint64_t)"mass", (uint64_t)&v33);
          v13 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v14 = v6[1].f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v14;
          RB::XML::Element::set<RB::XML::Value::Float>(v13, (uint64_t)"stiffness", (uint64_t)&v33);
          v15 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v16 = v6[2].f32[0];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v16;
          RB::XML::Element::set<RB::XML::Value::Float>(v15, (uint64_t)"damping", (uint64_t)&v33);
          if (v6->i32[0] != 10)
            goto LABEL_26;
          v17 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v18 = v6[2].f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v18;
          v19 = "initial-velocity";
          goto LABEL_25;
        case 11:
          RB::XML::Document::push(a2, "speed");
          v17 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v27 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v27;
          v19 = "value";
          goto LABEL_25;
        case 12:
          RB::XML::Document::push(a2, "delay");
          v17 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v28 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          goto LABEL_24;
        case 13:
        case 14:
          RB::XML::Document::push(a2, "repeat");
          v20 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v21 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v21;
          RB::XML::Element::set<RB::XML::Value::Float>(v20, (uint64_t)"count", (uint64_t)&v33);
          if (v6->i32[0] == 14)
          {
            v22 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
            v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229010;
            LOBYTE(v34[0]) = 1;
            RB::XML::Element::set<RB::XML::Value::Bool>(v22, (uint64_t)"autoreverses", (uint64_t)&v33);
          }
          goto LABEL_26;
        case 15:
          v8 = "circular-ease-in";
          goto LABEL_23;
        case 16:
          v8 = "circular-ease-out";
          goto LABEL_23;
        case 17:
          v8 = "circular-ease-in-ease-out";
LABEL_23:
          RB::XML::Document::push(a2, v8);
          v17 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v28 = v6->f32[1];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
LABEL_24:
          v34[0] = *(void **)&v28;
          v19 = "duration";
LABEL_25:
          RB::XML::Element::set<RB::XML::Value::Float>(v17, (uint64_t)v19, (uint64_t)&v33);
          goto LABEL_26;
        case 18:
          RB::XML::Document::push(a2, "sampled-function");
          v30 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v31 = v6[1].f32[0];
          v33 = (void (**)(RB::XML::Value::FloatArray *__hidden))&unk_24C229178;
          v34[0] = *(void **)&v31;
          RB::XML::Element::set<RB::XML::Value::Float>(v30, (uint64_t)"duration", (uint64_t)&v33);
          v32 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          RB::XML::Value::FloatArray::FloatArray<float>(&v33, (float *)&v6[1] + 1, (2 * v6->i32[1]));
          RB::XML::Element::set<RB::XML::Value::FloatArray>(v32, (uint64_t)"values", (uint64_t)&v33);
          v33 = &off_24C228E58;
          if (v34[0])
            free(v34[0]);
LABEL_26:
          this = RB::XML::Document::pop((uint64_t)a2);
          v7 = v6->u32[0];
          break;
        default:
          break;
      }
      if (v7 == 18)
        v29 = 2 * v6->i32[1] + 2;
      else
        v29 = RB::Animation::_term_args[v7];
      v4 += v29 + 1;
    }
    while (v4 < *(_DWORD *)(v3 + 32));
  }
  return this;
}

void sub_209B5FDD8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  if (a14)
    free(a14);
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1);
  result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 3), __dst, 6u, (_DWORD *)__dst + 9, v3);
  *((_QWORD *)__dst + 3) = result;
  return result;
}

double RB::Path::quadratic_bounds_slow(float32x2_t a1, float32x2_t a2, float32x2_t a3, int32x4_t a4, int8x16_t a5)
{
  float32x2_t v5;
  float32x2_t v6;
  int8x16_t v11;
  int8x16_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v17;

  *(float32x2_t *)a5.i8 = vsub_f32(a1, a3);
  *(int32x2_t *)a4.i8 = vceqz_f32(*(float32x2_t *)a5.i8);
  if ((vpmin_u32(*(uint32x2_t *)a4.i8, *(uint32x2_t *)a4.i8).u32[0] & 0x80000000) != 0)
  {
    v14 = vminnm_f32(a1, a3);
  }
  else
  {
    v5 = vrecpe_f32(*(float32x2_t *)a5.i8);
    v6 = vmul_f32(vrecps_f32(*(float32x2_t *)a5.i8, v5), v5);
    *(float32x2_t *)a5.i8 = vmul_f32(vrecps_f32(*(float32x2_t *)a5.i8, v6), vmul_f32(vsub_f32(a1, a2), v6));
    __asm { FMOV            V5.4S, #-1.0 }
    v11 = vbslq_s8((int8x16_t)vcltzq_s32(a4), (int8x16_t)_Q5, a5);
    *(int32x2_t *)_Q5.i8 = vdup_n_s32(0x358637BDu);
    *(int32x2_t *)a5.i8 = vcgt_f32(*(float32x2_t *)_Q5.i8, *(float32x2_t *)v11.i8);
    v12.i64[0] = 0x4000000040000000;
    v12.i64[1] = 0x4000000040000000;
    v13 = (float32x2_t)vbslq_s8((int8x16_t)vcltzq_s32((int32x4_t)a5), v12, v11).u64[0];
    v14 = vminnm_f32(a1, a3);
    *(int8x8_t *)_Q5.i8 = vand_s8((int8x8_t)vcgt_f32(v13, *(float32x2_t *)_Q5.i8), (int8x8_t)vcgt_f32((float32x2_t)vdup_n_s32(0x3F7FFFEFu), v13));
    if ((vpmax_u32(*(uint32x2_t *)_Q5.i8, *(uint32x2_t *)_Q5.i8).u32[0] & 0x80000000) != 0)
    {
      __asm { FMOV            V7.2S, #1.0 }
      v17 = vsub_f32(_D7, v13);
      v14 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(_Q5), (int8x8_t)vminnm_f32(v14, vmla_f32(vmul_f32(vmul_f32(v13, v13), a3), v17, vmla_f32(vmul_f32(a2, vadd_f32(v13, v13)), a1, v17))), (int8x8_t)v14);
    }
  }
  return *(double *)&v14;
}

float32x2_t RB::Path::BoundingRect::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, double a4, int32x4_t a5, int8x16_t a6)
{
  float32x2_t v7;
  float32x2_t v8;
  double v9;
  float32x2_t v10;
  uint32x2_t v11;
  float32x2_t result;
  float32x2_t v13;

  v7 = vcvt_f32_f64(a2);
  v8 = vcvt_f32_f64(a3);
  *(float32x2_t *)a5.i8 = a1[3];
  v9 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)a5.i8, v8));
  v10 = vmaxnm_f32(*(float32x2_t *)a5.i8, v8);
  v11 = (uint32x2_t)vand_s8((int8x8_t)vcge_f32(v10, v7), (int8x8_t)vcge_f32(v7, *(float32x2_t *)&v9));
  *(uint32x2_t *)a6.i8 = vpmin_u32(v11, v11);
  if ((a6.i32[0] & 0x80000000) == 0)
    v9 = RB::Path::quadratic_bounds_slow(a1[3], v7, v8, a5, a6);
  result = vminnm_f32(a1[1], *(float32x2_t *)&v9);
  v13 = vmaxnm_f32(a1[2], v10);
  a1[1] = result;
  a1[2] = v13;
  a1[3] = v8;
  return result;
}

BOOL RB::ProjectionMatrix::invert(RB::ProjectionMatrix *this)
{
  float v2;
  float v3;
  float64x2_t v4;
  float64x2_t v5;
  _BOOL8 result;
  float64x2_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  float v26;
  float v27;
  float v28;
  float v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;

  v2 = *((float *)this + 2);
  v3 = *((float *)this + 5);
  if (v2 == 0.0 && v3 == 0.0 && *((float *)this + 8) == 1.0)
  {
    v4 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 12));
    v5 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 24));
    v35 = vcvtq_f64_f32(*(float32x2_t *)this);
    v36 = v4;
    v37 = v5;
    result = RB::AffineTransform::invert((RB::AffineTransform *)&v35);
    if (result)
    {
      v7 = v36;
      *(float32x2_t *)this = vcvt_f32_f64(v35);
      *((_DWORD *)this + 2) = 0;
      *(float32x2_t *)((char *)this + 12) = vcvt_f32_f64(v7);
      *((_DWORD *)this + 5) = 0;
      *((float32x2_t *)this + 3) = vcvt_f32_f64(v37);
      *((_DWORD *)this + 8) = 1065353216;
    }
  }
  else
  {
    v8 = *((float *)this + 4);
    v9 = v3;
    v10 = *((float *)this + 7);
    v11 = *((float *)this + 8);
    v12 = -(v10 * v3 - v11 * v8);
    v13 = *((float *)this + 3);
    v14 = *((float *)this + 6);
    v15 = -(v14 * v3 - v13 * v11);
    v16 = -(v14 * v8 - v13 * v10);
    v17 = *((float *)this + 1);
    v18 = v2;
    v19 = *(float *)this;
    v20 = v16 * v18 - (v15 * v17 - v12 * v19);
    if (v20 == 0.0)
    {
      return 0;
    }
    else
    {
      v21 = -(v17 * v13 - v19 * v8);
      v22 = -(v19 * v9 - v13 * v18);
      v23 = -(v8 * v18 - v17 * v9);
      v24 = -(v19 * v10 - v17 * v14);
      v25 = -(v14 * v18 - v19 * v11);
      v26 = 1.0 / v20 * v12;
      v27 = -(v17 * v11 - v10 * v18) * (1.0 / v20);
      *(float *)this = v26;
      *((float *)this + 1) = v27;
      v28 = 1.0 / v20 * v23;
      v29 = -(1.0 / v20 * v15);
      *((float *)this + 2) = v28;
      *((float *)this + 3) = v29;
      v30 = 1.0 / v20 * v25;
      v31 = v22 * (1.0 / v20);
      *((float *)this + 4) = v30;
      *((float *)this + 5) = v31;
      v32 = 1.0 / v20 * v16;
      v33 = v24 * (1.0 / v20);
      *((float *)this + 6) = v32;
      *((float *)this + 7) = v33;
      v34 = 1.0 / v20 * v21;
      *((float *)this + 8) = v34;
      return 1;
    }
  }
  return result;
}

float32_t RB::operator*@<S0>(uint64_t a1@<X0>, uint64_t a2@<X1>, float32x4_t *a3@<X8>, int8x16_t a4@<Q3>, int32x4_t a5@<Q4>, int32x4_t a6@<Q7>)
{
  int8x16_t v6;
  int32x2_t v7;
  float32x4_t v8;
  float32x2_t v9;
  float v10;
  float32x2_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  int32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  int32x4_t v23;
  float32x4_t v24;
  float32_t result;

  v8.i64[0] = *(_QWORD *)(a1 + 4);
  a5.i32[0] = *(_DWORD *)(a1 + 12);
  v9 = *(float32x2_t *)(a1 + 28);
  v10 = *(float *)(a1 + 24);
  v7.i32[0] = *(_DWORD *)(a2 + 12);
  v6.i32[0] = *(_DWORD *)(a2 + 16);
  a6.i64[0] = *(_QWORD *)a2;
  v11 = *(float32x2_t *)(a2 + 28);
  a4.i64[0] = *(_QWORD *)(a2 + 20);
  *(int32x2_t *)v12.f32 = vrev64_s32(*(int32x2_t *)v8.f32);
  v12.i32[2] = v12.i32[0];
  v12.i32[3] = *(_DWORD *)(a1 + 16);
  v13.i32[0] = vdup_lane_s32(*(int32x2_t *)a4.i8, 1).u32[0];
  v13.i32[1] = v6.i32[0];
  v13.i64[1] = __PAIR64__(v7.u32[0], v11.u32[1]);
  v8.i32[2] = v8.i32[0];
  v8.i32[3] = *(_DWORD *)(a1 + 20);
  *(int32x2_t *)v14.f32 = vzip1_s32(v7, (int32x2_t)v11);
  v14.i64[1] = a4.i64[0];
  v15 = vmulq_f32(v8, v14);
  v16 = *(int32x4_t *)a1;
  v16.i32[1] = a5.i32[0];
  v17 = (float32x4_t)vzip1q_s32(v16, v16);
  v17.i32[2] = *(_OWORD *)a1;
  v18.i64[0] = *(_QWORD *)a2;
  v18.i32[2] = *(_DWORD *)(a2 + 8);
  v18.i32[3] = *(_QWORD *)a2;
  v19 = vmlaq_f32(vmlaq_f32(v15, v13, v12), v18, v17);
  *(float32x2_t *)v18.f32 = v11;
  v18.i64[1] = __PAIR64__(v11.u32[0], v7.u32[0]);
  v20.i32[0] = *(_DWORD *)(a1 + 20);
  *(float32x2_t *)&v20.u32[2] = v9;
  v20.i32[1] = v20.i32[0];
  v21 = vmulq_f32(v18, v20);
  v22 = (float32x4_t)vextq_s8(vextq_s8(v6, v6, 4uLL), a4, 0xCuLL);
  v22.i32[3] = v22.i32[0];
  v20.i32[0] = v12.i32[3];
  *(int32x2_t *)&v20.u32[2] = vrev64_s32((int32x2_t)v9);
  v20.i32[1] = v12.i32[3];
  v23 = vuzp2q_s32(a6, vzip1q_s32(a6, a6));
  v24 = (float32x4_t)v23;
  v24.i32[1] = *(_DWORD *)(a2 + 8);
  v24.i32[3] = v23.i32[0];
  *(float *)&a5.i32[1] = v10;
  *a3 = v19;
  a3[1] = vmlaq_f32(vmlaq_f32(v21, v20, v22), (float32x4_t)vzip1q_s32(a5, a5), v24);
  result = vmla_f32((float32x2_t)vdup_lane_s32((int32x2_t)vmul_f32(v11, v9), 1), v9, *(float32x2_t *)a4.i8).f32[0]
         + (float)(v24.f32[1] * v10);
  a3[2].f32[0] = result;
  return result;
}

float32x2_t RB::operator*@<D0>(float64x2_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  double v3;
  float64x2_t v4;
  float64x2_t v5;
  double v7;
  float32x4_t v8;
  float64x2_t v9;
  float v11;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  double v21;
  float64x2_t v22;
  float64x2_t v23;
  float32x2_t result;

  v3 = *(float *)a2;
  v5 = *a1;
  v4 = a1[1];
  _Q5 = a1[2];
  v7 = *(float *)(a2 + 20);
  v8 = *(float32x4_t *)(a2 + 4);
  v9 = vcvtq_f64_f32(*(float32x2_t *)v8.f32);
  _Q6 = vcvt_hight_f64_f32(v8);
  v11 = vmlad_n_f64(vmuld_lane_f64(_Q6.f64[0], *a1, 1), v3, a1->f64[0]);
  *(float *)a3 = v11;
  __asm { FMLA            D3, D6, V5.D[1] }
  v17 = vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v4, (int64x2_t)v5), v9);
  *(_QWORD *)&v18.f64[0] = vdupq_laneq_s64((int64x2_t)_Q6, 1).u64[0];
  v18.f64[1] = v7;
  v19 = vmlaq_laneq_f64(vcvtq_f64_f32(*(float32x2_t *)(a2 + 28)), v18, _Q5, 1);
  v18.f64[0] = v9.f64[1];
  v20 = vmlaq_n_f64(v19, v9, _Q5.f64[0]);
  v9.f64[1] = v7;
  v21 = vmlad_n_f64(_D3, v3, _Q5.f64[0]);
  v22 = vmulq_f64((float64x2_t)vzip2q_s64((int64x2_t)v4, (int64x2_t)v5), _Q6);
  _Q6.f64[0] = v3;
  *(float *)&v3 = v21;
  v23.f64[1] = v17.f64[1];
  v23.f64[0] = v22.f64[1];
  v22.f64[1] = v17.f64[0];
  *(float32x4_t *)(a3 + 4) = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(vmlaq_f64(v23, v9, v5)), vmlaq_f64(v22, _Q6, v4));
  *(float *)v4.f64 = vmlad_n_f64(vmuld_lane_f64(v7, v4, 1), v18.f64[0], v4.f64[0]);
  *(_DWORD *)(a3 + 20) = LODWORD(v4.f64[0]);
  *(_DWORD *)(a3 + 24) = LODWORD(v3);
  result = vcvt_f32_f64(v20);
  *(float32x2_t *)(a3 + 28) = result;
  return result;
}

float RB::operator*@<S0>(float *a1@<X0>, float64x2_t *a2@<X1>, uint64_t a3@<X8>)
{
  float result;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float v7;
  double v8;
  double v9;
  float v10;
  double v11;
  double v12;

  result = a1[2];
  v5 = a2[1];
  v4 = a2[2];
  v6 = *a2;
  v7 = a1[5];
  v8 = a1[4];
  v9 = a1[3];
  v10 = a1[8];
  v11 = a1[7];
  v12 = a1[6];
  *(float32x2_t *)a3 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, result), v5, a1[1]), *a2, *a1));
  *(float32x2_t *)(a3 + 12) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, v7), v5, v8), v6, v9));
  *(float32x2_t *)(a3 + 24) = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v4, v10), v5, v11), v6, v12));
  *(float *)(a3 + 8) = result;
  *(float *)(a3 + 20) = v7;
  *(float *)(a3 + 32) = v10;
  return result;
}

uint64_t RB::operator*=(uint64_t a1, uint64_t a2, double a3, double a4, double a5, int8x16_t a6, int32x4_t a7, double a8, double a9, int32x4_t a10)
{
  float32x4_t v11;
  float32x4_t v13[2];
  int v14;

  RB::operator*(a1, a2, v13, a6, a7, a10);
  v11 = v13[1];
  *(float32x4_t *)a1 = v13[0];
  *(float32x4_t *)(a1 + 16) = v11;
  *(_DWORD *)(a1 + 32) = v14;
  return a1;
}

float RB::ProjectionMatrix::translate(RB::ProjectionMatrix *this, float a2, float a3)
{
  float result;

  *((float32x2_t *)this + 3) = vmla_n_f32(vmla_n_f32(*(float32x2_t *)((char *)this + 24), *(float32x2_t *)((char *)this + 12), a3), *(float32x2_t *)this, a2);
  result = (float)(*((float *)this + 8) + (float)(*((float *)this + 5) * a3)) + (float)(*((float *)this + 2) * a2);
  *((float *)this + 8) = result;
  return result;
}

__n64 RB::ProjectionMatrix::translate_right(RB::ProjectionMatrix *this, __n64 result, float a3)
{
  result.n64_f32[1] = a3;
  *(float32x2_t *)this = vmla_n_f32(*(float32x2_t *)this, (float32x2_t)result.n64_u64[0], *((float *)this + 2));
  *(float32x2_t *)((char *)this + 12) = vmla_n_f32(*(float32x2_t *)((char *)this + 12), (float32x2_t)result.n64_u64[0], *((float *)this + 5));
  *((float32x2_t *)this + 3) = vmla_n_f32(*(float32x2_t *)((char *)this + 24), (float32x2_t)result.n64_u64[0], *((float *)this + 8));
  return result;
}

float32x2_t RB::operator*(uint64_t a1, double _D0, float32x2_t a3)
{
  float64x2_t v5;
  float64x2_t v6;
  float v12;
  float v13;
  float v14;
  float32x2_t v15;
  float32x2_t v16;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float v24;
  float v25;
  float v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float v32;
  float32x2_t v33;
  float32x2_t v34;
  float64x2_t v35[3];

  _S5 = *(float *)(a1 + 20);
  if (*(float *)(a1 + 8) == 0.0 && (_S5 == 0.0 ? (_ZF = *(float *)(a1 + 32) == 1.0) : (_ZF = 0), _ZF))
  {
    v5 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 12));
    v6 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 24));
    v35[0] = vcvtq_f64_f32(*(float32x2_t *)a1);
    v35[1] = v5;
    v35[2] = v6;
    return RB::operator*(v35, *(float32x2_t *)&_D0, a3);
  }
  else
  {
    __asm { FMLA            S7, S5, V0.S[1] }
    v12 = 1.0;
    v13 = 1.0;
    if (_S7 != 1.0)
    {
      if (_S7 <= 0.0)
      {
        v13 = INFINITY;
      }
      else
      {
        v14 = _S7;
        v15 = vrecpe_f32((float32x2_t)LODWORD(_S7));
        v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v14), v15), v15);
        LODWORD(v13) = vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v14), v16)).u32[0];
      }
    }
    _D7 = vadd_f32((float32x2_t)a3.u32[0], *(float32x2_t *)&_D0);
    __asm { FMLA            S16, S5, V7.S[1] }
    if (_S16 != 1.0)
    {
      if (_S16 <= 0.0)
      {
        v12 = INFINITY;
      }
      else
      {
        v19 = _S16;
        v20 = vrecpe_f32((float32x2_t)LODWORD(_S16));
        v21 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v19), v20), v20);
        LODWORD(v12) = vmul_f32(v21, vrecps_f32((float32x2_t)LODWORD(v19), v21)).u32[0];
      }
    }
    _D17 = vadd_f32(a3, *(float32x2_t *)&_D0);
    __asm { FMLA            S18, S5, V17.S[1] }
    v24 = 1.0;
    v25 = 1.0;
    if (_S18 != 1.0)
    {
      if (_S18 <= 0.0)
      {
        v25 = INFINITY;
      }
      else
      {
        v26 = _S18;
        v27 = vrecpe_f32((float32x2_t)LODWORD(_S18));
        v28 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v26), v27), v27);
        LODWORD(v25) = vmul_f32(v28, vrecps_f32((float32x2_t)LODWORD(v26), v28)).u32[0];
      }
    }
    a3.i32[0] = 0;
    _D1 = vadd_f32(a3, *(float32x2_t *)&_D0);
    __asm { FMLA            S3, S5, V1.S[1] }
    if (_S3 != 1.0)
    {
      if (_S3 <= 0.0)
      {
        v24 = INFINITY;
      }
      else
      {
        v32 = _S3;
        v33 = vrecpe_f32((float32x2_t)LODWORD(_S3));
        v34 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v32), v33), v33);
        LODWORD(v24) = vmul_f32(v34, vrecps_f32((float32x2_t)LODWORD(v32), v34)).u32[0];
      }
    }
    v29 = *(float32x2_t *)(a1 + 24);
    return vminnm_f32(vminnm_f32(vmul_n_f32(vmla_lane_f32(vmla_n_f32(v29, *(float32x2_t *)a1, *(float *)&_D0), *(float32x2_t *)(a1 + 12), *(float32x2_t *)&_D0, 1), v13), vmul_n_f32(vmla_lane_f32(vmla_n_f32(v29, *(float32x2_t *)a1, _D7.f32[0]), *(float32x2_t *)(a1 + 12), _D7, 1), v12)), vminnm_f32(vmul_n_f32(vmla_lane_f32(vmla_n_f32(v29, *(float32x2_t *)a1, _D17.f32[0]), *(float32x2_t *)(a1 + 12), _D17, 1), v25), vmul_n_f32(vmla_lane_f32(vmla_n_f32(v29, *(float32x2_t *)a1, _D1.f32[0]), *(float32x2_t *)(a1 + 12), _D1, 1), v24)));
  }
}

uint64_t RB::unapply(float32x2_t *a1, float *a2)
{
  float v3;
  float v5;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;

  _S0 = a2[2];
  v3 = a2[3];
  _D1 = *a1;
  v5 = a2[1];
  __asm { FMLA            S6, S0, V1.S[1] }
  v12 = a2[4];
  v11 = a2[5];
  v13 = vmuls_lane_f32(v11, *a1, 1);
  v14 = vmlas_n_f32(_S6 * v3, -(float)((float)(v12 * _S0) - (float)(v11 * v5)), COERCE_FLOAT(*a1))
      + (float)((float)(v12 - v13) * *a2);
  if (v14 == 0.0)
    return 0;
  v16 = a2[7];
  v15 = a2[8];
  v17 = a2[6];
  v18 = -(float)((float)(v16 * v11) - (float)(v15 * v12));
  v19 = v17 * (float)(v13 - v12);
  v20 = v16 - (float)(v15 * _D1.f32[1]);
  v21 = -(float)((float)(v20 * *a2)
               - (float)((float)((float)-(float)((float)(v15 * v5) - (float)(v16 * _S0)) * _D1.f32[0])
                       - (float)(v17 * _S6)));
  _D1.f32[0] = (float)((float)(v19 + (float)(v18 * _D1.f32[0])) + (float)(v20 * v3)) / v14;
  if ((float)((float)(v15 + (float)((float)(v21 / v14) * v11)) + (float)(_D1.f32[0] * _S0)) <= 0.0)
    return 0;
  _D1.f32[1] = v21 / v14;
  *a1 = _D1;
  return 1;
}

BOOL RB::unapply(float32x2_t *this, RB::Rect *a2, const RB::ProjectionMatrix *a3)
{
  BOOL v4;
  float64x2_t v5;
  float64x2_t v6;
  _BOOL8 v7;
  float32x2_t v8;
  __int128 v9;
  float32x2_t v10;
  int v11;
  float32x2_t v12;
  int v13;
  float32x2_t v14;
  int v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v21;
  _OWORD v22[2];
  int v23;
  float64x2_t v24[3];

  if (*((float *)a2 + 2) == 0.0 && (*((float *)a2 + 5) == 0.0 ? (v4 = *((float *)a2 + 8) == 1.0) : (v4 = 0), v4))
  {
    v5 = vcvtq_f64_f32(*(float32x2_t *)((char *)a2 + 12));
    v6 = vcvtq_f64_f32(*(float32x2_t *)((char *)a2 + 24));
    v24[0] = vcvtq_f64_f32(*(float32x2_t *)a2);
    v24[1] = v5;
    v24[2] = v6;
    v7 = RB::AffineTransform::invert((RB::AffineTransform *)v24);
    if (v7)
    {
      *this = RB::operator*(v24, *this, this[1]);
      this[1] = v8;
    }
  }
  else
  {
    v9 = *((_OWORD *)a2 + 1);
    v22[0] = *(_OWORD *)a2;
    v22[1] = v9;
    v23 = *((_DWORD *)a2 + 8);
    v24[0].f64[0] = *(float64_t *)this;
    v10 = *(float32x2_t *)&v24[0].f64[0];
    v11 = RB::unapply((float32x2_t *)v24, (float *)v22);
    v12 = *(float32x2_t *)&v24[0].f64[0];
    v21 = this[1];
    *(float32x2_t *)&v24[0].f64[0] = vadd_f32((float32x2_t)v21.u32[0], v10);
    v13 = RB::unapply((float32x2_t *)v24, (float *)v22);
    v14 = *(float32x2_t *)&v24[0].f64[0];
    *(float32x2_t *)&v24[0].f64[0] = vadd_f32(v10, v21);
    v15 = RB::unapply((float32x2_t *)v24, (float *)v22);
    v16 = *(float32x2_t *)&v24[0].f64[0];
    v17.i32[1] = v21.i32[1];
    v17.i32[0] = 0;
    *(float32x2_t *)&v24[0].f64[0] = vadd_f32(v17, v10);
    if ((RB::unapply((float32x2_t *)v24, (float *)v22) & 1) != 0 && (v15 & v13 & v11) == 1)
    {
      v18 = vminnm_f32(vminnm_f32(v12, v14), vminnm_f32(v16, *(float32x2_t *)&v24[0].f64[0]));
      v19 = vsub_f32(vmaxnm_f32(vmaxnm_f32(v12, v14), vmaxnm_f32(v16, *(float32x2_t *)&v24[0].f64[0])), v18);
      *this = v18;
      this[1] = v19;
      return 1;
    }
    else
    {
      return 0;
    }
  }
  return v7;
}

float32_t RB::ProjectionMatrix::mix(float32x4_t *this, float32x4_t *a2, float a3)
{
  float32x4_t v3;
  float32_t result;

  v3 = this[1];
  *this = vmlaq_n_f32(*this, vsubq_f32(*a2, *this), a3);
  this[1] = vmlaq_n_f32(v3, vsubq_f32(a2[1], v3), a3);
  result = this[2].f32[0] + (float)((float)(a2[2].f32[0] - this[2].f32[0]) * a3);
  this[2].f32[0] = result;
  return result;
}

_QWORD *RB::ProjectionMatrix::encode(_QWORD *this, RB::Encoder *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  int v6;
  _DWORD v7[9];

  v3 = this;
  v4 = 0;
  v7[0] = 1065353216;
  v5 = 13;
  do
  {
    v6 = *(int *)((char *)v3 + v4 * 4);
    if (*(float *)&v6 != *(float *)&v7[v4])
    {
      RB::ProtobufEncoder::encode_varint(a2, v5);
      this = RB::ProtobufEncoder::encode_fixed32(a2, v6);
    }
    ++v4;
    v5 += 8;
  }
  while (v4 != 9);
  return this;
}

unint64_t RB::ProjectionMatrix::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 >> 3) - 1 > 8)
        RB::ProtobufDecoder::skip_field(this, v5);
      else
        *(float *)(a1 + 4 * ((v5 >> 3) - 1)) = RB::ProtobufDecoder::float_field(this, v5);
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

intptr_t RB::Drawable::finish(intptr_t this)
{
  intptr_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  if (*(_QWORD *)(this + 16))
  {
    v1 = this;
    if (*(_DWORD *)(this + 12))
    {
      v2 = 0;
      do
      {
        this = dispatch_semaphore_wait(*(dispatch_semaphore_t *)(v1 + 16), 0xFFFFFFFFFFFFFFFFLL);
        ++v2;
        v3 = *(unsigned int *)(v1 + 12);
      }
      while (v2 < v3);
      if ((_DWORD)v3)
      {
        v4 = 0;
        do
        {
          this = dispatch_semaphore_signal(*(dispatch_semaphore_t *)(v1 + 16));
          ++v4;
        }
        while (v4 < *(unsigned int *)(v1 + 12));
      }
    }
  }
  return this;
}

NSObject *RB::Drawable::cancel_frame(RB::Drawable *this)
{
  NSObject *result;

  result = *((_QWORD *)this + 2);
  if (result)
    return dispatch_semaphore_signal(result);
  return result;
}

void RB::Drawable::statistics(os_unfair_lock_s *this@<X0>, void *a2@<X8>)
{
  os_unfair_lock_s *v4;

  v4 = this + 8;
  os_unfair_lock_lock(this + 8);
  memcpy(a2, &this[10], 0x120uLL);
  os_unfair_lock_unlock(v4);
}

uint64_t RB::Drawable::Statistics::dictionary(RB::Drawable::Statistics *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  _QWORD *v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  _QWORD *v22;
  uint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  void *v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  _QWORD *v34;
  uint64_t v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  _QWORD *v40;
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  _QWORD *v46;
  uint64_t v47;
  _QWORD *v48;
  uint64_t v49;
  uint64_t v50;
  void *v51;
  _QWORD *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  _QWORD *v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  uint64_t v62;
  void *v63;
  _QWORD *v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  _QWORD *v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  _QWORD *v76;
  uint64_t v77;
  _QWORD *v78;
  uint64_t v79;
  void *v80;
  _QWORD *v81;
  uint64_t v82;
  _QWORD *v83;
  uint64_t v84;
  void *v85;
  _QWORD *v86;
  uint64_t v87;
  _QWORD *v88;
  uint64_t v89;
  void *v90;
  _QWORD *v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  void *v95;
  _QWORD *v96;
  uint64_t v97;
  _QWORD *v98;
  uint64_t v99;
  void *v100;
  _QWORD *v101;
  uint64_t v102;
  _QWORD *v103;
  uint64_t v104;
  void *v105;
  _QWORD *v106;
  uint64_t v107;
  _QWORD *v108;
  uint64_t v109;
  void *v110;
  _QWORD *v111;
  uint64_t v112;
  _QWORD *v113;
  uint64_t v114;
  void *v115;
  _QWORD *v116;
  uint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  void *v120;
  _QWORD *v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  void *v125;
  _QWORD *v126;
  uint64_t v127;
  _QWORD *v128;
  uint64_t v129;
  void *v130;
  _QWORD *v131;
  uint64_t v132;
  _QWORD *v133;
  uint64_t v134;
  void *v135;
  _QWORD *v136;
  uint64_t v137;
  _QWORD *v138;
  uint64_t v139;
  void *v140;
  _QWORD *v141;
  uint64_t v142;
  _QWORD *v143;
  uint64_t v144;
  void *v145;
  _QWORD *v146;
  uint64_t v147;
  _QWORD *v148;
  uint64_t v149;
  void *v150;
  _QWORD *v151;
  uint64_t v152;
  _QWORD *v153;
  uint64_t v154;
  void *v155;
  _QWORD *v156;
  uint64_t v157;
  _QWORD *v158;
  uint64_t v159;
  void *v160;
  _QWORD *v161;
  uint64_t v162;
  _QWORD *v163;
  uint64_t v164;
  void *v165;
  _QWORD *v166;
  uint64_t v167;
  _QWORD *v168;
  uint64_t v169;
  void *v170;
  _QWORD *v171;
  uint64_t v172;
  _QWORD *v173;
  uint64_t v174;
  void *v175;
  _QWORD *v176;
  uint64_t v177;
  _QWORD *v178;
  _QWORD *v179;
  _QWORD *v180;
  uint64_t v181;
  _QWORD v183[32];
  __int128 v184;
  unint64_t v185;
  _QWORD __dst[64];
  void *v187[2];
  unint64_t v188;
  uint64_t v189;

  v189 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v187 = 0u;
  v188 = 64;
  v184 = 0u;
  v185 = 64;
  v2 = RBDrawableStatisticsFramesSubmitted;
  v3 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((_QWORD *)this + 2));
  __dst[0] = v2;
  v187[1] = (void *)1;
  v183[0] = v3;
  *((_QWORD *)&v184 + 1) = 1;
  v4 = RBDrawableStatisticsFramesRendered;
  v5 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((_QWORD *)this + 3));
  __dst[1] = v4;
  v187[1] = (void *)2;
  v183[1] = v5;
  *((_QWORD *)&v184 + 1) = 2;
  v6 = *(_QWORD *)this;
  if ((*(_QWORD *)this & 1) != 0)
  {
    v7 = RBDrawableStatisticsMinSubmitTime;
    v8 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 12));
    v9 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v9 = v187[1];
    }
    v10 = v187[0];
    if (!v187[0])
      v10 = __dst;
    v10[(_QWORD)v9] = v7;
    ++v187[1];
    v11 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v11 = *((_QWORD *)&v184 + 1);
    }
    v12 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v12 = v183;
    v12[v11] = v8;
    ++*((_QWORD *)&v184 + 1);
    v13 = RBDrawableStatisticsMaxSubmitTime;
    v14 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 20));
    v15 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v15 = v187[1];
    }
    v16 = v187[0];
    if (!v187[0])
      v16 = __dst;
    v16[(_QWORD)v15] = v13;
    ++v187[1];
    v17 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v17 = *((_QWORD *)&v184 + 1);
    }
    v18 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v18 = v183;
    v18[v17] = v14;
    ++*((_QWORD *)&v184 + 1);
    v19 = RBDrawableStatisticsTotalSubmitTime;
    v20 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 4));
    v21 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v21 = v187[1];
    }
    v22 = v187[0];
    if (!v187[0])
      v22 = __dst;
    v22[(_QWORD)v21] = v19;
    ++v187[1];
    v23 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v23 = *((_QWORD *)&v184 + 1);
    }
    v24 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v24 = v183;
    v24[v23] = v20;
    ++*((_QWORD *)&v184 + 1);
    v25 = RBDrawableStatisticsEMASubmitTime;
    v26 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 28));
    v27 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v27 = v187[1];
    }
    v28 = v187[0];
    if (!v187[0])
      v28 = __dst;
    v28[(_QWORD)v27] = v25;
    ++v187[1];
    v29 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v29 = *((_QWORD *)&v184 + 1);
    }
    v30 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v30 = v183;
    v30[v29] = v26;
    ++*((_QWORD *)&v184 + 1);
    v6 = *(_QWORD *)this;
  }
  if ((v6 & 2) != 0)
  {
    v31 = RBDrawableStatisticsMinRenderTime;
    v32 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 13));
    v33 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v33 = v187[1];
    }
    v34 = v187[0];
    if (!v187[0])
      v34 = __dst;
    v34[(_QWORD)v33] = v31;
    ++v187[1];
    v35 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v35 = *((_QWORD *)&v184 + 1);
    }
    v36 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v36 = v183;
    v36[v35] = v32;
    ++*((_QWORD *)&v184 + 1);
    v37 = RBDrawableStatisticsMaxRenderTime;
    v38 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 21));
    v39 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v39 = v187[1];
    }
    v40 = v187[0];
    if (!v187[0])
      v40 = __dst;
    v40[(_QWORD)v39] = v37;
    ++v187[1];
    v41 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v41 = *((_QWORD *)&v184 + 1);
    }
    v42 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v42 = v183;
    v42[v41] = v38;
    ++*((_QWORD *)&v184 + 1);
    v43 = RBDrawableStatisticsTotalRenderTime;
    v44 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 5));
    v45 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v45 = v187[1];
    }
    v46 = v187[0];
    if (!v187[0])
      v46 = __dst;
    v46[(_QWORD)v45] = v43;
    ++v187[1];
    v47 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v47 = *((_QWORD *)&v184 + 1);
    }
    v48 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v48 = v183;
    v48[v47] = v44;
    ++*((_QWORD *)&v184 + 1);
    v49 = RBDrawableStatisticsEMARenderTime;
    v50 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 29));
    v51 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v51 = v187[1];
    }
    v52 = v187[0];
    if (!v187[0])
      v52 = __dst;
    v52[(_QWORD)v51] = v49;
    ++v187[1];
    v53 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v53 = *((_QWORD *)&v184 + 1);
    }
    v54 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v54 = v183;
    v54[v53] = v50;
    ++*((_QWORD *)&v184 + 1);
    v6 = *(_QWORD *)this;
  }
  if ((v6 & 4) != 0)
  {
    v55 = RBDrawableStatisticsMinCostEstimate;
    v56 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 14));
    v57 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v57 = v187[1];
    }
    v58 = v187[0];
    if (!v187[0])
      v58 = __dst;
    v58[(_QWORD)v57] = v55;
    ++v187[1];
    v59 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v59 = *((_QWORD *)&v184 + 1);
    }
    v60 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v60 = v183;
    v60[v59] = v56;
    ++*((_QWORD *)&v184 + 1);
    v61 = RBDrawableStatisticsMaxCostEstimate;
    v62 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 22));
    v63 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v63 = v187[1];
    }
    v64 = v187[0];
    if (!v187[0])
      v64 = __dst;
    v64[(_QWORD)v63] = v61;
    ++v187[1];
    v65 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v65 = *((_QWORD *)&v184 + 1);
    }
    v66 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v66 = v183;
    v66[v65] = v62;
    ++*((_QWORD *)&v184 + 1);
    v67 = RBDrawableStatisticsTotalCostEstimate;
    v68 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 6));
    v69 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v69 = v187[1];
    }
    v70 = v187[0];
    if (!v187[0])
      v70 = __dst;
    v70[(_QWORD)v69] = v67;
    ++v187[1];
    v71 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v71 = *((_QWORD *)&v184 + 1);
    }
    v72 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v72 = v183;
    v72[v71] = v68;
    ++*((_QWORD *)&v184 + 1);
    v73 = RBDrawableStatisticsEMACostEstimate;
    v74 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 30));
    v75 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v75 = v187[1];
    }
    v76 = v187[0];
    if (!v187[0])
      v76 = __dst;
    v76[(_QWORD)v75] = v73;
    ++v187[1];
    v77 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v77 = *((_QWORD *)&v184 + 1);
    }
    v78 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v78 = v183;
    v78[v77] = v74;
    ++*((_QWORD *)&v184 + 1);
    v6 = *(_QWORD *)this;
  }
  if ((v6 & 8) != 0)
  {
    v79 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 15));
    v80 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v80 = v187[1];
    }
    v81 = v187[0];
    if (!v187[0])
      v81 = __dst;
    v81[(_QWORD)v80] = CFSTR("min_triangles");
    ++v187[1];
    v82 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v82 = *((_QWORD *)&v184 + 1);
    }
    v83 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v83 = v183;
    v83[v82] = v79;
    ++*((_QWORD *)&v184 + 1);
    v84 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 23));
    v85 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v85 = v187[1];
    }
    v86 = v187[0];
    if (!v187[0])
      v86 = __dst;
    v86[(_QWORD)v85] = CFSTR("max_triangles");
    ++v187[1];
    v87 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v87 = *((_QWORD *)&v184 + 1);
    }
    v88 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v88 = v183;
    v88[v87] = v84;
    ++*((_QWORD *)&v184 + 1);
    v89 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 7));
    v90 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v90 = v187[1];
    }
    v91 = v187[0];
    if (!v187[0])
      v91 = __dst;
    v91[(_QWORD)v90] = CFSTR("total_triangles");
    ++v187[1];
    v92 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v92 = *((_QWORD *)&v184 + 1);
    }
    v93 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v93 = v183;
    v93[v92] = v89;
    ++*((_QWORD *)&v184 + 1);
    v94 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 31));
    v95 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v95 = v187[1];
    }
    v96 = v187[0];
    if (!v187[0])
      v96 = __dst;
    v96[(_QWORD)v95] = CFSTR("ema_triangles");
    ++v187[1];
    v97 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v97 = *((_QWORD *)&v184 + 1);
    }
    v98 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v98 = v183;
    v98[v97] = v94;
    ++*((_QWORD *)&v184 + 1);
    v99 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 16));
    v100 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v100 = v187[1];
    }
    v101 = v187[0];
    if (!v187[0])
      v101 = __dst;
    v101[(_QWORD)v100] = CFSTR("min_texture_bytes");
    ++v187[1];
    v102 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v102 = *((_QWORD *)&v184 + 1);
    }
    v103 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v103 = v183;
    v103[v102] = v99;
    ++*((_QWORD *)&v184 + 1);
    v104 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 24));
    v105 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v105 = v187[1];
    }
    v106 = v187[0];
    if (!v187[0])
      v106 = __dst;
    v106[(_QWORD)v105] = CFSTR("max_texture_bytes");
    ++v187[1];
    v107 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v107 = *((_QWORD *)&v184 + 1);
    }
    v108 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v108 = v183;
    v108[v107] = v104;
    ++*((_QWORD *)&v184 + 1);
    v109 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 8));
    v110 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v110 = v187[1];
    }
    v111 = v187[0];
    if (!v187[0])
      v111 = __dst;
    v111[(_QWORD)v110] = CFSTR("total_texture_bytes");
    ++v187[1];
    v112 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v112 = *((_QWORD *)&v184 + 1);
    }
    v113 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v113 = v183;
    v113[v112] = v109;
    ++*((_QWORD *)&v184 + 1);
    v114 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 32));
    v115 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v115 = v187[1];
    }
    v116 = v187[0];
    if (!v187[0])
      v116 = __dst;
    v116[(_QWORD)v115] = CFSTR("ema_texture_bytes");
    ++v187[1];
    v117 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v117 = *((_QWORD *)&v184 + 1);
    }
    v118 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v118 = v183;
    v118[v117] = v114;
    ++*((_QWORD *)&v184 + 1);
    v119 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 17));
    v120 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v120 = v187[1];
    }
    v121 = v187[0];
    if (!v187[0])
      v121 = __dst;
    v121[(_QWORD)v120] = CFSTR("min_buffer_bytes");
    ++v187[1];
    v122 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v122 = *((_QWORD *)&v184 + 1);
    }
    v123 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v123 = v183;
    v123[v122] = v119;
    ++*((_QWORD *)&v184 + 1);
    v124 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 25));
    v125 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v125 = v187[1];
    }
    v126 = v187[0];
    if (!v187[0])
      v126 = __dst;
    v126[(_QWORD)v125] = CFSTR("max_buffer_bytes");
    ++v187[1];
    v127 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v127 = *((_QWORD *)&v184 + 1);
    }
    v128 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v128 = v183;
    v128[v127] = v124;
    ++*((_QWORD *)&v184 + 1);
    v129 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 9));
    v130 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v130 = v187[1];
    }
    v131 = v187[0];
    if (!v187[0])
      v131 = __dst;
    v131[(_QWORD)v130] = CFSTR("total_buffer_bytes");
    ++v187[1];
    v132 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v132 = *((_QWORD *)&v184 + 1);
    }
    v133 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v133 = v183;
    v133[v132] = v129;
    ++*((_QWORD *)&v184 + 1);
    v134 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 33));
    v135 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v135 = v187[1];
    }
    v136 = v187[0];
    if (!v187[0])
      v136 = __dst;
    v136[(_QWORD)v135] = CFSTR("ema_buffer_bytes");
    ++v187[1];
    v137 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v137 = *((_QWORD *)&v184 + 1);
    }
    v138 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v138 = v183;
    v138[v137] = v134;
    ++*((_QWORD *)&v184 + 1);
    v139 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 18));
    v140 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v140 = v187[1];
    }
    v141 = v187[0];
    if (!v187[0])
      v141 = __dst;
    v141[(_QWORD)v140] = CFSTR("min_fill_rate");
    ++v187[1];
    v142 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v142 = *((_QWORD *)&v184 + 1);
    }
    v143 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v143 = v183;
    v143[v142] = v139;
    ++*((_QWORD *)&v184 + 1);
    v144 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 26));
    v145 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v145 = v187[1];
    }
    v146 = v187[0];
    if (!v187[0])
      v146 = __dst;
    v146[(_QWORD)v145] = CFSTR("max_fill_rate");
    ++v187[1];
    v147 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v147 = *((_QWORD *)&v184 + 1);
    }
    v148 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v148 = v183;
    v148[v147] = v144;
    ++*((_QWORD *)&v184 + 1);
    v149 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 10));
    v150 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v150 = v187[1];
    }
    v151 = v187[0];
    if (!v187[0])
      v151 = __dst;
    v151[(_QWORD)v150] = CFSTR("total_fill_rate");
    ++v187[1];
    v152 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v152 = *((_QWORD *)&v184 + 1);
    }
    v153 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v153 = v183;
    v153[v152] = v149;
    ++*((_QWORD *)&v184 + 1);
    v154 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 34));
    v155 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v155 = v187[1];
    }
    v156 = v187[0];
    if (!v187[0])
      v156 = __dst;
    v156[(_QWORD)v155] = CFSTR("ema_fill_rate");
    ++v187[1];
    v157 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v157 = *((_QWORD *)&v184 + 1);
    }
    v158 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v158 = v183;
    v158[v157] = v154;
    ++*((_QWORD *)&v184 + 1);
    v159 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 19));
    v160 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v160 = v187[1];
    }
    v161 = v187[0];
    if (!v187[0])
      v161 = __dst;
    v161[(_QWORD)v160] = CFSTR("min_render_passes");
    ++v187[1];
    v162 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v162 = *((_QWORD *)&v184 + 1);
    }
    v163 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v163 = v183;
    v163[v162] = v159;
    ++*((_QWORD *)&v184 + 1);
    v164 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 27));
    v165 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v165 = v187[1];
    }
    v166 = v187[0];
    if (!v187[0])
      v166 = __dst;
    v166[(_QWORD)v165] = CFSTR("max_render_passes");
    ++v187[1];
    v167 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v167 = *((_QWORD *)&v184 + 1);
    }
    v168 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v168 = v183;
    v168[v167] = v164;
    ++*((_QWORD *)&v184 + 1);
    v169 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 11));
    v170 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v170 = v187[1];
    }
    v171 = v187[0];
    if (!v187[0])
      v171 = __dst;
    v171[(_QWORD)v170] = CFSTR("total_render_passes");
    ++v187[1];
    v172 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v172 = *((_QWORD *)&v184 + 1);
    }
    v173 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v173 = v183;
    v173[v172] = v169;
    ++*((_QWORD *)&v184 + 1);
    v174 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithDouble:", *((double *)this + 35));
    v175 = v187[1];
    if ((void *)v188 < (char *)v187[1] + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(__dst, (size_t)v187[1] + 1);
      v175 = v187[1];
    }
    v176 = v187[0];
    if (!v187[0])
      v176 = __dst;
    v176[(_QWORD)v175] = CFSTR("ema_render_passes");
    ++v187[1];
    v177 = *((_QWORD *)&v184 + 1);
    if (v185 < *((_QWORD *)&v184 + 1) + 1)
    {
      RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(v183, *((_QWORD *)&v184 + 1) + 1);
      v177 = *((_QWORD *)&v184 + 1);
    }
    v178 = (_QWORD *)v184;
    if (!(_QWORD)v184)
      v178 = v183;
    v178[v177] = v174;
    ++*((_QWORD *)&v184 + 1);
  }
  if ((_QWORD)v184)
    v179 = (_QWORD *)v184;
  else
    v179 = v183;
  if (v187[0])
    v180 = v187[0];
  else
    v180 = __dst;
  v181 = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v179, v180);
  if ((_QWORD)v184)
    free((void *)v184);
  if (v187[0])
    free(v187[0]);
  return v181;
}

void sub_209B62080(_Unwind_Exception *a1)
{
  if (STACK[0x208])
    free((void *)STACK[0x208]);
  if (STACK[0x420])
    free((void *)STACK[0x420]);
  _Unwind_Resume(a1);
}

uint64_t RB::Refcount<RB::Drawable,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::Drawable,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Drawable::~Drawable(id *this)
{
  *this = off_24C229940;

}

{
  *this = off_24C229940;

  JUMPOUT(0x20BD16544);
}

void *RB::vector<objc_object *,64ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 66) + (*((_QWORD *)__dst + 66) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 66) + (*((_QWORD *)__dst + 66) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 64), __dst, 0x40uLL, (size_t *)__dst + 66, v3);
  *((_QWORD *)__dst + 64) = result;
  return result;
}

uint64_t CG::dasher::dasher(uint64_t a1, uint64_t a2, uint64_t *a3, size_t a4, uint64_t a5, double a6)
{
  size_t v6;
  double *v11;
  double **v12;
  unint64_t v13;
  double *v14;
  double *v15;
  unint64_t v16;
  uint64_t v17;
  char v18;
  double v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  double *v23;
  double *v24;
  uint64_t *v25;
  size_t v26;
  uint64_t *v27;
  uint64_t *v28;
  size_t v29;
  uint64_t v30;
  size_t v31;
  unint64_t v32;
  double *v33;
  uint64_t v34;
  double *v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  double v39;
  unint64_t v40;
  int v41;
  unint64_t v43;
  BOOL v44;
  unint64_t v45;
  _BYTE v46[32];
  void *v47;
  size_t v48;
  uint64_t v49;
  uint64_t v50;

  v6 = a4;
  v50 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = off_24C222F08;
  *(_QWORD *)(a1 + 8) = a5;
  v11 = (double *)(a1 + 16);
  *(_QWORD *)(a1 + 48) = 0;
  v12 = (double **)(a1 + 48);
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 4;
  v13 = 8 * a4;
  if (a4 && v13 >= 0x21)
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow((void *)(a1 + 16), a4);
    v14 = *(double **)(a1 + 48);
    *(_QWORD *)(a1 + 56) = v6;
  }
  else
  {
    v14 = 0;
    *(_QWORD *)(a1 + 56) = a4;
    if (!a4)
    {
      v18 = 1;
      goto LABEL_11;
    }
  }
  if (v14)
    v15 = v14;
  else
    v15 = v11;
  v16 = v13;
  do
  {
    v17 = *a3++;
    *(_QWORD *)v15++ = v17;
    v16 -= 8;
  }
  while (v16);
  v18 = 0;
LABEL_11:
  v19 = *(double *)a2;
  v20 = *(float64x2_t *)(a2 + 8);
  v21 = vnegq_f64(v20);
  v20.f64[0] = *(float64_t *)(a2 + 24);
  v22 = vmulq_f64(v20, *(float64x2_t *)a2);
  v22.f64[0] = vsubq_f64(v22, (float64x2_t)vdupq_laneq_s64((int64x2_t)v22, 1)).f64[0];
  *(double *)(a1 + 72) = *(double *)(a2 + 24) / v22.f64[0];
  *(float64x2_t *)(a1 + 80) = vdivq_f64(v21, (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v22.f64[0], 0));
  *(double *)(a1 + 96) = v19 / v22.f64[0];
  *(_BYTE *)(a1 + 104) = 1;
  *(_QWORD *)(a1 + 168) = 0;
  *(_QWORD *)(a1 + 176) = 0;
  if (v14)
    v23 = v14;
  else
    v23 = v11;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  if ((v18 & 1) == 0)
  {
    v24 = v23;
    do
    {
      *v24 = fabs(*v24);
      ++v24;
      v13 -= 8;
    }
    while (v13);
  }
  if ((v6 & 1) != 0)
  {
    v47 = 0;
    v48 = 0;
    v49 = 4;
    if (v6 >= 5)
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(v46, v6);
      v25 = (uint64_t *)v47;
      v26 = v48;
    }
    else
    {
      v25 = 0;
      v26 = 0;
    }
    if (v25)
      v27 = v25;
    else
      v27 = (uint64_t *)v46;
    v28 = &v27[v26];
    v29 = v6;
    do
    {
      v30 = *(_QWORD *)v23++;
      *v28++ = v30;
      --v29;
    }
    while (v29);
    v31 = v26 + v6;
    v48 = v31;
    v32 = *(_QWORD *)(a1 + 56);
    if (*(_QWORD *)(a1 + 64) < v32 + v31)
    {
      RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(v11, v32 + v31);
      v43 = *(_QWORD *)(a1 + 56);
      if (*(_QWORD *)(a1 + 48))
        v33 = *(double **)(a1 + 48);
      else
        v33 = v11;
      v44 = v43 > v32;
      v45 = v43 - v32;
      if (v44)
        memmove(&v33[v32 + v31], &v33[v32], 8 * v45);
    }
    else if (*v12)
    {
      v33 = *v12;
    }
    else
    {
      v33 = v11;
    }
    if (v31)
    {
      v34 = 8 * v31;
      v35 = &v33[v32];
      do
      {
        v36 = *v27++;
        *(_QWORD *)v35++ = v36;
        v34 -= 8;
      }
      while (v34);
    }
    v6 = *(_QWORD *)(a1 + 56) + 1;
    *(_QWORD *)(a1 + 56) = v6;
    if (v47)
    {
      free(v47);
      v6 = *(_QWORD *)(a1 + 56);
    }
    v14 = *v12;
  }
  if (!v14)
    v14 = v11;
  if (!v6)
    goto LABEL_41;
  v37 = 0;
  v38 = 0.0;
  do
    v38 = v14[v37++] + v38;
  while (v6 != v37);
  if (v38 >= 2.22044605e-16)
  {
    while (a6 < 0.0)
      a6 = a6 + v38;
    *(_QWORD *)(a1 + 112) = 0;
    *(_BYTE *)(a1 + 104) = 1;
    v39 = *v14;
    if (a6 >= *v14)
    {
      v40 = 0;
      v41 = 1;
      do
      {
        if (a6 == 0.0 && v39 == 0.0)
          break;
        a6 = a6 - v39;
        v41 ^= 1u;
        *(_BYTE *)(a1 + 104) = v41;
        if (v40 < v6 - 1)
          ++v40;
        else
          v40 = 0;
        *(_QWORD *)(a1 + 112) = v40;
        v39 = v14[v40];
      }
      while (a6 >= v39);
    }
    *(double *)(a1 + 120) = v39 - a6;
  }
  else
  {
LABEL_41:
    *(_QWORD *)(a1 + 56) = 0;
  }
  return a1;
}

__n128 CG::dasher::moveto(uint64_t a1, __n128 a2)
{
  __n128 result;

  *(__n128 *)(a1 + 128) = a2;
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a1 + 112);
  *(_BYTE *)(a1 + 144) = *(_BYTE *)(a1 + 104);
  *(_BYTE *)(a1 + 184) = 1;
  *(_QWORD *)(a1 + 160) = *(_QWORD *)(a1 + 120);
  result = *(__n128 *)(a1 + 128);
  *(__n128 *)(a1 + 168) = result;
  return result;
}

__n128 CG::dasher::lineto(uint64_t a1, float64x2_t a2)
{
  __n128 result;
  float64x2_t v5[2];

  v5[0] = *(float64x2_t *)(a1 + 168);
  v5[1] = a2;
  CG::dasher::dash_path_element<CG::LineSegment>(a1, v5);
  result = (__n128)a2;
  *(float64x2_t *)(a1 + 168) = a2;
  return result;
}

uint64_t CG::dasher::dash_path_element<CG::LineSegment>(uint64_t result, float64x2_t *a2)
{
  float64x2_t v2;
  double v3;
  uint64_t v5;
  double v6;
  double v7;
  int v8;
  double v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double v15;

  v2 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)(result + 88), a2[1].f64[1] - a2->f64[1]), *(float64x2_t *)(result + 72), a2[1].f64[0] - a2->f64[0]);
  v3 = sqrt(vaddvq_f64(vmulq_f64(v2, v2)));
  if (v3 != 0.0)
  {
    v5 = result;
    v6 = *(double *)(result + 160);
    if (v3 <= v6)
    {
      if (*(_BYTE *)(result + 144))
      {
        result = CG::dasher::add_path_dash_segment<CG::LineSegment>(result, a2, 0.0, v3);
        *(_BYTE *)(v5 + 184) = 0;
        v6 = *(double *)(v5 + 160);
      }
      v15 = v6 - v3;
      goto LABEL_20;
    }
    v7 = 0.0;
    v8 = *(unsigned __int8 *)(result + 144);
    v9 = *(double *)(result + 160);
    do
    {
      if (v8)
      {
        result = CG::dasher::add_path_dash_segment<CG::LineSegment>(v5, a2, v7, v9);
        v6 = *(double *)(v5 + 160);
        v8 = *(unsigned __int8 *)(v5 + 144);
      }
      v10 = *(_QWORD *)(v5 + 152);
      v11 = *(_QWORD *)(v5 + 48);
      v12 = *(_QWORD *)(v5 + 56) - 1;
      v7 = v6 + v7;
      v8 ^= 1u;
      *(_BYTE *)(v5 + 144) = v8;
      if (v10 == v12)
        v13 = 0;
      else
        v13 = v10 + 1;
      *(_QWORD *)(v5 + 152) = v13;
      if (v11)
        v14 = v11;
      else
        v14 = v5 + 16;
      v6 = *(double *)(v14 + 8 * v13);
      *(double *)(v5 + 160) = v6;
      *(_BYTE *)(v5 + 184) = 1;
      v9 = v6 + v7;
    }
    while (v6 + v7 < v3);
    if (v7 < v3)
    {
      if (*(_BYTE *)(v5 + 144))
      {
        result = CG::dasher::add_path_dash_segment<CG::LineSegment>(v5, a2, v7, v3);
        *(_BYTE *)(v5 + 184) = 0;
        v6 = *(double *)(v5 + 160);
      }
      v15 = v7 - v3 + v6;
LABEL_20:
      *(double *)(v5 + 160) = v15;
    }
  }
  return result;
}

double CG::dasher::quadto(const Point *a1, __n128 a2, __n128 a3)
{
  double result;
  _BYTE v5[80];
  Point v6[4];
  Point v7[4];

  *(__n128 *)&v6[0].v = a3;
  *(__n128 *)&v7[0].v = a2;
  CG::Quadratic::Quadratic((CG::Quadratic *)v5, a1 + 42, v7, v6);
  CG::dasher::dash_path_element<CG::Quadratic>((uint64_t)a1, (CG::Quadratic *)v5);
  result = *(double *)&v6[0].v;
  *(_OWORD *)&a1[42].v = *(_OWORD *)&v6[0].v;
  return result;
}

uint64_t CG::dasher::dash_path_element<CG::Quadratic>(uint64_t a1, CG::Quadratic *a2)
{
  __int128 v4;
  __int128 v5;
  double v6;
  double v7;
  double v8;
  double v9;
  uint64_t result;
  double v11;
  double v12;
  double v13;
  double v14;
  int v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  Point v28[2];
  double v29;
  Point v30[2];
  double v31;
  Point v32[2];
  double v33;

  v4 = *((_OWORD *)a2 + 1);
  v23 = *(_OWORD *)a2;
  v24 = v4;
  v5 = *((_OWORD *)a2 + 3);
  v25 = *((_OWORD *)a2 + 2);
  v26 = v5;
  v27 = *((_OWORD *)a2 + 4);
  v6 = *(double *)(a1 + 72);
  v7 = *(double *)(a1 + 80);
  v8 = *(double *)(a1 + 88);
  v9 = *(double *)(a1 + 96);
  *(double *)&v32[0].v = v6 * *(double *)&v23 + v8 * *((double *)&v23 + 1);
  v33 = v7 * *(double *)&v23 + v9 * *((double *)&v23 + 1);
  *(double *)&v30[0].v = *(double *)&v24 * v6 + *((double *)&v24 + 1) * v8;
  v31 = *(double *)&v24 * v7 + *((double *)&v24 + 1) * v9;
  *(double *)&v28[0].v = *(double *)&v25 * v6 + *((double *)&v25 + 1) * v8;
  v29 = *(double *)&v25 * v7 + *((double *)&v25 + 1) * v9;
  CG::Quadratic::Quadratic((CG::Quadratic *)&v23, v32, v30, v28);
  result = CG::Quadratic::length((CG::Quadratic *)&v23, 0);
  if (v11 != 0.0)
  {
    v12 = v11;
    v13 = *(double *)(a1 + 160);
    if (v12 <= v13)
    {
      if (*(_BYTE *)(a1 + 144))
      {
        result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, 0.0, v12);
        *(_BYTE *)(a1 + 184) = 0;
        v13 = *(double *)(a1 + 160);
      }
      v22 = v13 - v12;
      goto LABEL_20;
    }
    v14 = 0.0;
    v15 = *(unsigned __int8 *)(a1 + 144);
    v16 = *(double *)(a1 + 160);
    do
    {
      if (v15)
      {
        result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, v14, v16);
        v13 = *(double *)(a1 + 160);
        v15 = *(unsigned __int8 *)(a1 + 144);
      }
      v17 = *(_QWORD *)(a1 + 152);
      v18 = *(_QWORD *)(a1 + 48);
      v19 = *(_QWORD *)(a1 + 56) - 1;
      v14 = v13 + v14;
      v15 ^= 1u;
      *(_BYTE *)(a1 + 144) = v15;
      if (v17 == v19)
        v20 = 0;
      else
        v20 = v17 + 1;
      *(_QWORD *)(a1 + 152) = v20;
      if (v18)
        v21 = v18;
      else
        v21 = a1 + 16;
      v13 = *(double *)(v21 + 8 * v20);
      *(double *)(a1 + 160) = v13;
      *(_BYTE *)(a1 + 184) = 1;
      v16 = v13 + v14;
    }
    while (v13 + v14 < v12);
    if (v14 < v12)
    {
      if (*(_BYTE *)(a1 + 144))
      {
        result = CG::dasher::add_path_dash_segment<CG::Quadratic>(a1, a2, v14, v12);
        *(_BYTE *)(a1 + 184) = 0;
        v13 = *(double *)(a1 + 160);
      }
      v22 = v14 - v12 + v13;
LABEL_20:
      *(double *)(a1 + 160) = v22;
    }
  }
  return result;
}

double CG::dasher::cubeto(const Point *a1, __n128 a2, __n128 a3, __n128 a4)
{
  double result;
  _OWORD v6[7];
  Point v7[4];
  Point v8[4];
  Point v9[4];

  *(__n128 *)&v8[0].v = a3;
  *(__n128 *)&v9[0].v = a2;
  *(__n128 *)&v7[0].v = a4;
  CG::Cubic::Cubic((CG::Cubic *)v6, a1 + 42, v9, v8, v7);
  CG::dasher::dash_path_element<CG::Cubic>((uint64_t)a1, v6);
  result = *(double *)&v7[0].v;
  *(_OWORD *)&a1[42].v = *(_OWORD *)&v7[0].v;
  return result;
}

void CG::dasher::dash_path_element<CG::Cubic>(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  int v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  double v22;
  _OWORD v23[2];
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  Point v29[2];
  double v30;
  Point v31[2];
  double v32;
  Point v33[2];
  double v34;
  Point v35[2];
  double v36;

  v4 = a2[5];
  v26 = a2[4];
  v27 = v4;
  v28 = a2[6];
  v5 = a2[1];
  v23[0] = *a2;
  v23[1] = v5;
  v6 = a2[3];
  v24 = a2[2];
  v25 = v6;
  v7 = *(double *)(a1 + 72);
  v8 = *(double *)(a1 + 80);
  v9 = *(double *)(a1 + 88);
  v10 = *(double *)(a1 + 96);
  *(double *)&v35[0].v = v7 * *(double *)v23 + v9 * *((double *)v23 + 1);
  v36 = v8 * *(double *)v23 + v10 * *((double *)v23 + 1);
  *(double *)&v33[0].v = *(double *)&v5 * v7 + *((double *)&v5 + 1) * v9;
  v34 = *(double *)&v5 * v8 + *((double *)&v5 + 1) * v10;
  *(double *)&v31[0].v = *(double *)&v24 * v7 + *((double *)&v24 + 1) * v9;
  v32 = *(double *)&v24 * v8 + *((double *)&v24 + 1) * v10;
  *(double *)&v29[0].v = *(double *)&v6 * v7 + *((double *)&v6 + 1) * v9;
  v30 = *(double *)&v6 * v8 + *((double *)&v6 + 1) * v10;
  CG::Cubic::Cubic((CG::Cubic *)v23, v35, v33, v31, v29);
  v11 = CG::Cubic::length((CG::Cubic *)v23, 0.5);
  if (v11 != 0.0)
  {
    v12 = v11;
    v13 = *(double *)(a1 + 160);
    if (v12 <= v13)
    {
      if (*(_BYTE *)(a1 + 144))
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, (uint64_t)a2, 0.0, v12);
        *(_BYTE *)(a1 + 184) = 0;
        v13 = *(double *)(a1 + 160);
      }
      v22 = v13 - v12;
      goto LABEL_20;
    }
    v14 = 0.0;
    v15 = *(unsigned __int8 *)(a1 + 144);
    v16 = *(double *)(a1 + 160);
    do
    {
      if (v15)
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, (uint64_t)a2, v14, v16);
        v13 = *(double *)(a1 + 160);
        v15 = *(unsigned __int8 *)(a1 + 144);
      }
      v17 = *(_QWORD *)(a1 + 152);
      v18 = *(_QWORD *)(a1 + 48);
      v19 = *(_QWORD *)(a1 + 56) - 1;
      v14 = v13 + v14;
      v15 ^= 1u;
      *(_BYTE *)(a1 + 144) = v15;
      if (v17 == v19)
        v20 = 0;
      else
        v20 = v17 + 1;
      *(_QWORD *)(a1 + 152) = v20;
      if (v18)
        v21 = v18;
      else
        v21 = a1 + 16;
      v13 = *(double *)(v21 + 8 * v20);
      *(double *)(a1 + 160) = v13;
      *(_BYTE *)(a1 + 184) = 1;
      v16 = v13 + v14;
    }
    while (v13 + v14 < v12);
    if (v14 < v12)
    {
      if (*(_BYTE *)(a1 + 144))
      {
        CG::dasher::add_path_dash_segment<CG::Cubic>(a1, (uint64_t)a2, v14, v12);
        *(_BYTE *)(a1 + 184) = 0;
        v13 = *(double *)(a1 + 160);
      }
      v22 = v14 - v12 + v13;
LABEL_20:
      *(double *)(a1 + 160) = v22;
    }
  }
}

__n128 CG::dasher::closepath(CG::dasher *this)
{
  float64x2_t v2;
  __n128 result;
  float64x2_t v4[2];

  v2 = *((float64x2_t *)this + 8);
  v4[0] = *(float64x2_t *)((char *)this + 168);
  v4[1] = v2;
  CG::dasher::dash_path_element<CG::LineSegment>((uint64_t)this, v4);
  *((_QWORD *)this + 19) = *((_QWORD *)this + 14);
  *((_BYTE *)this + 144) = *((_BYTE *)this + 104);
  *((_BYTE *)this + 184) = 1;
  *((_QWORD *)this + 20) = *((_QWORD *)this + 15);
  result = *((__n128 *)this + 8);
  *(__n128 *)((char *)this + 168) = result;
  return result;
}

uint64_t CG::dasher::endpath(CG::dasher *this)
{
  return (***((uint64_t (****)(_QWORD))this + 1))(*((_QWORD *)this + 1));
}

uint64_t CG::dasher::add_path_dash_segment<CG::LineSegment>(uint64_t a1, float64x2_t *a2, double a3, double a4)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  float64x2_t v17;
  __n128 v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  float64x2_t v26;
  __n128 v27;
  float64x2_t v28;
  double v29;
  double v30;
  float64x2_t v31;
  float64x2_t v32;

  v8 = a2->f64[1];
  v9 = a2[1].f64[0];
  v10 = a2[1].f64[1];
  v11 = *(double *)(a1 + 72);
  v12 = *(double *)(a1 + 80);
  v13 = *(double *)(a1 + 88);
  v14 = *(double *)(a1 + 96);
  v15 = v12 * a2->f64[0] + v14 * v8;
  v28.f64[0] = v11 * a2->f64[0] + v13 * v8;
  v28.f64[1] = v15;
  v29 = v11 * v9 + v13 * v10;
  v30 = v12 * v9 + v14 * v10;
  v16 = CG::LineSegment::index(&v28, a3);
  CG::LineSegment::split(a2, v16, (uint64_t)&v28);
  if (*(_BYTE *)(a1 + 184))
    (*(void (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), (__n128)v31);
  if (a3 == a4)
  {
    v17 = vsubq_f64(v32, v31);
    if (v17.f64[0] != 0.0 || v17.f64[1] != 0.0)
      v17 = vdivq_f64(v17, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v17, v17)))), 0));
    v18 = (__n128)vmlaq_f64(v31, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL), v17);
    v19 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v20 = *(double *)(a1 + 72);
    v21 = *(double *)(a1 + 80);
    v22 = *(double *)(a1 + 88);
    v23 = *(double *)(a1 + 96);
    v26.f64[0] = v20 * v31.f64[0] + v22 * v31.f64[1];
    v26.f64[1] = v21 * v31.f64[0] + v23 * v31.f64[1];
    v27.n128_f64[0] = v20 * v32.f64[0] + v22 * v32.f64[1];
    v27.n128_f64[1] = v21 * v32.f64[0] + v23 * v32.f64[1];
    v24 = CG::LineSegment::index(&v26, a4 - a3);
    CG::LineSegment::split(&v31, v24, (uint64_t)&v26);
    v19 = *(_QWORD *)(a1 + 8);
    v18 = v27;
  }
  return (*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)v19 + 24))(v19, v18);
}

uint64_t CG::dasher::add_path_dash_segment<CG::Quadratic>(uint64_t a1, CG::Quadratic *a2, double a3, double a4)
{
  __int128 v8;
  __int128 v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  __n128 v15;
  unint64_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  __n128 v22;
  double v23;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  float64x2_t v30;
  __n128 v31;
  __n128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  float64x2_t v40;
  __n128 v41;
  __n128 v42;
  __int128 v43;
  __int128 v44;
  Point v45[2];
  double v46;
  Point v47[2];
  double v48;
  Point v49[2];
  double v50;

  v8 = *((_OWORD *)a2 + 1);
  v35 = *(_OWORD *)a2;
  v36 = v8;
  v9 = *((_OWORD *)a2 + 3);
  v37 = *((_OWORD *)a2 + 2);
  v38 = v9;
  v39 = *((_OWORD *)a2 + 4);
  v10 = *(double *)(a1 + 72);
  v11 = *(double *)(a1 + 80);
  v12 = *(double *)(a1 + 88);
  v13 = *(double *)(a1 + 96);
  v30.f64[0] = v10 * *(double *)&v35 + v12 * *((double *)&v35 + 1);
  v30.f64[1] = v11 * *(double *)&v35 + v13 * *((double *)&v35 + 1);
  *(double *)&v49[0].v = *(double *)&v36 * v10 + *((double *)&v36 + 1) * v12;
  v50 = *(double *)&v36 * v11 + *((double *)&v36 + 1) * v13;
  *(double *)&v47[0].v = *(double *)&v37 * v10 + *((double *)&v37 + 1) * v12;
  v48 = *(double *)&v37 * v11 + *((double *)&v37 + 1) * v13;
  CG::Quadratic::Quadratic((CG::Quadratic *)&v35, (const Point *)&v30, v49, v47);
  CG::Quadratic::index((CG::Quadratic *)&v35, a3);
  CG::Quadratic::split(a2, v14, (uint64_t)&v35);
  if (*(_BYTE *)(a1 + 184))
  {
    v15.n128_f64[0] = CG::Quadratic::start_point((CG::Quadratic *)&v40);
    v15.n128_u64[1] = v16;
    (*(void (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), v15);
  }
  if (a3 == a4)
  {
    v17 = CG::Quadratic::derivative(&v40, 0.0);
    v19 = v17;
    v20 = v18;
    if (v17 != 0.0 || v18 != 0.0)
    {
      v21 = sqrt(v17 * v17 + v18 * v18);
      v19 = v19 / v21;
      v20 = v18 / v21;
    }
    v22.n128_f64[0] = CG::Quadratic::start_point((CG::Quadratic *)&v40) + v19 * 0.0000152587891;
    v22.n128_f64[1] = v23 + v20 * 0.0000152587891;
    return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), v22);
  }
  else
  {
    v30 = v40;
    v31 = v41;
    v32 = v42;
    v33 = v43;
    v34 = v44;
    v25 = *(double *)(a1 + 72);
    v26 = *(double *)(a1 + 80);
    v27 = *(double *)(a1 + 88);
    v28 = *(double *)(a1 + 96);
    *(double *)&v49[0].v = v25 * v40.f64[0] + v27 * v40.f64[1];
    v50 = v26 * v40.f64[0] + v28 * v40.f64[1];
    *(double *)&v47[0].v = v41.n128_f64[0] * v25 + v41.n128_f64[1] * v27;
    v48 = v41.n128_f64[0] * v26 + v41.n128_f64[1] * v28;
    *(double *)&v45[0].v = v42.n128_f64[0] * v25 + v42.n128_f64[1] * v27;
    v46 = v42.n128_f64[0] * v26 + v42.n128_f64[1] * v28;
    CG::Quadratic::Quadratic((CG::Quadratic *)&v30, v49, v47, v45);
    CG::Quadratic::index((CG::Quadratic *)&v30, a4 - a3);
    CG::Quadratic::split((CG::Quadratic *)&v40, v29, (uint64_t)&v30);
    return (*(uint64_t (**)(_QWORD, __n128, __n128))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), v31, v32);
  }
}

uint64_t CG::dasher::add_path_dash_segment<CG::Cubic>(uint64_t a1, uint64_t a2, double a3, double a4)
{
  __int128 v8;
  float64x2_t v9;
  __int128 v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  float64x2_t v18;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  float64x2_t v25;
  __n128 v26;
  __n128 v27;
  __n128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  float64x2_t v32[2];
  __int128 v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  __int128 v37;
  float64x2_t v38;
  __n128 v39;
  __n128 v40;
  __n128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  Point v45[2];
  double v46;
  Point v47[2];
  double v48;
  Point v49[2];
  double v50;
  Point v51[2];
  double v52;

  v8 = *(_OWORD *)(a2 + 80);
  v35 = *(_OWORD *)(a2 + 64);
  v36 = v8;
  v37 = *(_OWORD *)(a2 + 96);
  v9 = *(float64x2_t *)(a2 + 16);
  v32[0] = *(float64x2_t *)a2;
  v32[1] = v9;
  v10 = *(_OWORD *)(a2 + 48);
  v33 = *(_OWORD *)(a2 + 32);
  v34 = v10;
  v11 = *(double *)(a1 + 72);
  v12 = *(double *)(a1 + 80);
  v13 = *(double *)(a1 + 88);
  v14 = *(double *)(a1 + 96);
  v25.f64[0] = v11 * v32[0].f64[0] + v13 * v32[0].f64[1];
  v25.f64[1] = v12 * v32[0].f64[0] + v14 * v32[0].f64[1];
  *(double *)&v51[0].v = v9.f64[0] * v11 + v9.f64[1] * v13;
  v52 = v9.f64[0] * v12 + v9.f64[1] * v14;
  *(double *)&v49[0].v = *(double *)&v33 * v11 + *((double *)&v33 + 1) * v13;
  v50 = *(double *)&v33 * v12 + *((double *)&v33 + 1) * v14;
  *(double *)&v47[0].v = *(double *)&v10 * v11 + *((double *)&v10 + 1) * v13;
  v48 = *(double *)&v10 * v12 + *((double *)&v10 + 1) * v14;
  CG::Cubic::Cubic((CG::Cubic *)v32, (const Point *)&v25, v51, v49, v47);
  v15 = CG::Cubic::index((CG::Cubic *)v32, a3, 0.5);
  CG::Cubic::split((float64x2_t *)a2, v15, v32);
  if (*(_BYTE *)(a1 + 184))
    (*(void (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), (__n128)v38);
  if (a3 == a4)
  {
    v16 = CG::Cubic::derivative((CG::Cubic *)&v38, 0.0);
    v18.f64[0] = v16;
    v18.f64[1] = v17;
    if (v16 != 0.0 || v17 != 0.0)
      v18 = vdivq_f64(v18, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(v16 * v16 + v17 * v17)), 0));
    return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), (__n128)vmlaq_f64(v38, (float64x2_t)vdupq_n_s64(0x3EF0000000000000uLL), v18));
  }
  else
  {
    v29 = v42;
    v30 = v43;
    v31 = v44;
    v25 = v38;
    v26 = v39;
    v27 = v40;
    v28 = v41;
    v20 = *(double *)(a1 + 72);
    v21 = *(double *)(a1 + 80);
    v22 = *(double *)(a1 + 88);
    v23 = *(double *)(a1 + 96);
    *(double *)&v51[0].v = v20 * v38.f64[0] + v22 * v38.f64[1];
    v52 = v21 * v38.f64[0] + v23 * v38.f64[1];
    *(double *)&v49[0].v = v39.n128_f64[0] * v20 + v39.n128_f64[1] * v22;
    v50 = v39.n128_f64[0] * v21 + v39.n128_f64[1] * v23;
    *(double *)&v47[0].v = v40.n128_f64[0] * v20 + v40.n128_f64[1] * v22;
    v48 = v40.n128_f64[0] * v21 + v40.n128_f64[1] * v23;
    *(double *)&v45[0].v = v41.n128_f64[0] * v20 + v41.n128_f64[1] * v22;
    v46 = v41.n128_f64[0] * v21 + v41.n128_f64[1] * v23;
    CG::Cubic::Cubic((CG::Cubic *)&v25, v51, v49, v47, v45);
    v24 = CG::Cubic::index((CG::Cubic *)&v25, a4 - a3, 0.5);
    CG::Cubic::split(&v38, v24, &v25);
    return (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8), v26, v27, v28);
  }
}

void RBXMLRecorderInstall()
{
  RB::XMLRecorder::installed = 1;
}

_QWORD *RBXMLRecorderStart()
{
  _QWORD *result;

  if (!RB::XMLRecorder::installed)
    return std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Set RB_XML_RECORDER=1 in environment to enable recording.\n", 58);
  if (!RB::XMLRecorder::enabled)
    RB::XMLRecorder::enabled = 1;
  return result;
}

void RBXMLRecorderStop()
{
  if (RB::XMLRecorder::enabled)
    RB::XMLRecorder::enabled = 0;
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x24BEDB870];
  v3 = MEMORY[0x24BEDB870] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x24BEDB870] + 64;
  v4 = *(_QWORD *)(MEMORY[0x24BEDB800] + 8);
  v5 = *(_QWORD *)(MEMORY[0x24BEDB800] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_209B63224(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x20BD16520](v1);
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB800];
  v3 = *MEMORY[0x24BEDB800];
  *(_QWORD *)a1 = *MEMORY[0x24BEDB800];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x24BEDB848] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x20BD16520](a1 + 112);
  return a1;
}

uint64_t RBXMLRecorderExportCGImage(CGImage *a1)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  CGDataConsumer *v6;
  CGDataConsumer *v7;
  CGImageDestination *v8;
  CGImageDestination *v9;
  _BOOL4 v10;

  if (RB::XMLRecorder::image_names)
  {
    v2 = (void *)MEMORY[0x20BD168EC]();
    v3 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", CGImageGetIdentifier());
    v4 = objc_msgSend((id)RB::XMLRecorder::image_names, "objectForKeyedSubscript:", v3);
    if (v4)
    {
LABEL_15:
      objc_autoreleasePoolPop(v2);
      return v4;
    }
    v4 = objc_msgSend((id)RB::XMLRecorder::resource_path, "stringByAppendingPathComponent:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("image-%@.png"), v3));
    if (!objc_msgSend((id)RB::XMLRecorder::image_names, "count"))
    {
      v5 = (void *)objc_msgSend(MEMORY[0x24BDD1580], "defaultManager");
      objc_msgSend(v5, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", RB::XMLRecorder::resource_path, 0, 0, 0);
    }
    v6 = CGDataConsumerCreateWithURL((CFURLRef)objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithPath:", v4));
    if (v6)
    {
      v7 = v6;
      v8 = CGImageDestinationCreateWithDataConsumer(v6, CFSTR("public.png"), 1uLL, 0);
      v9 = v8;
      if (v8)
      {
        CGImageDestinationAddImage(v8, a1, 0);
        v10 = CGImageDestinationFinalize(v9);
      }
      else
      {
        v10 = 0;
      }
      CGDataConsumerRelease(v7);
      if (v9)
      {
        CFRelease(v9);
        if (v10)
        {
LABEL_12:
          objc_msgSend((id)RB::XMLRecorder::image_names, "setObject:forKeyedSubscript:", v4, v3);
          goto LABEL_15;
        }
      }
      else if (v10)
      {
        goto LABEL_12;
      }
    }
    v4 = 0;
    goto LABEL_15;
  }
  return 0;
}

void sub_209B63454(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

id RBDisplayListContentsXMLDescription(void *a1)
{
  return RBDisplayListContentsXMLDescription2(a1, 0, *MEMORY[0x24BDBF148], *(double *)(MEMORY[0x24BDBF148] + 8));
}

id RBDisplayListContentsXMLDescription2(void *a1, uint64_t a2, double a3, double a4)
{
  id v8;
  unsigned __int16 v9;
  id v11;
  void **v12;
  unint64_t v13;
  void *__p[2];
  unsigned __int8 v16;
  uint64_t v17;
  _QWORD v18[10];
  char v19;
  uint64_t v20;

  v8 = (id)objc_msgSend(a1, "_rb_xml_document");
  if (v8)
  {
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v9 = rb_color_space(objc_msgSend(a1, "defaultColorSpace"));
      if ((v9 & 1) == 0 && v9 > 0xFFu)
        a2 = a2 | 0x80000000;
      else
        a2 = a2;
    }
    std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)&v17);
    RB::XML::Document::print((uint64_t)v8, &v17, a2, a3, a4);
    std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v18, __p);
    v11 = objc_alloc(MEMORY[0x24BDD17C8]);
    if ((v16 & 0x80u) == 0)
      v12 = __p;
    else
      v12 = (void **)__p[0];
    if ((v16 & 0x80u) == 0)
      v13 = v16;
    else
      v13 = (unint64_t)__p[1];
    v8 = (id)objc_msgSend(v11, "initWithBytes:length:encoding:", v12, v13, 4);
    if ((char)v16 < 0)
      operator delete(__p[0]);
    v17 = *MEMORY[0x24BEDB800];
    *(_QWORD *)((char *)&v18[-1] + *(_QWORD *)(v17 - 24)) = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
    v18[0] = MEMORY[0x24BEDB848] + 16;
    if (v19 < 0)
      operator delete((void *)v18[8]);
    std::streambuf::~streambuf();
    std::ostream::~ostream();
    MEMORY[0x20BD16520](&v20);
  }
  return v8;
}

void sub_209B635F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15, char a16)
{
  std::ostringstream::~ostringstream((uint64_t)&a16);
  _Unwind_Resume(a1);
}

RB::XML::Element **RBDisplayListContentsXMLDictionary(void *a1, uint64_t a2)
{
  RB::XML::Element **result;
  RB::XML::Element **v5;
  unsigned __int16 v6;
  void *v8;
  void *v9;

  result = (RB::XML::Element **)objc_msgSend(a1, "_rb_xml_document");
  if (result)
  {
    v5 = result;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      v6 = rb_color_space(objc_msgSend(a1, "defaultColorSpace"));
      if ((v6 & 1) == 0 && v6 > 0xFFu)
        a2 = a2 | 0x80000000;
      else
        a2 = a2;
    }
    v8 = (void *)MEMORY[0x20BD168EC]();
    v9 = RB::XML::Document::dictionary(v5, a2);
    objc_autoreleasePoolPop(v8);
    return (RB::XML::Element **)v9;
  }
  return result;
}

_QWORD *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x20BD16454](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x20BD16460](v13);
  return a1;
}

void sub_209B637D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  MEMORY[0x20BD16460](&a10);
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:nn180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:nn180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_209B63918(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:nn180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    abort();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

uint64_t std::stringbuf::str[abi:nn180100]<std::allocator<char>>@<X0>(uint64_t a1@<X0>, _QWORD *a2@<X8>)
{
  uint64_t result;
  unint64_t v4;
  const void *v5;
  size_t v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;

  result = std::stringbuf::view[abi:nn180100](a1);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = (const void *)result;
  v6 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v9 = operator new(v7 + 1);
    a2[1] = v6;
    a2[2] = v8 | 0x8000000000000000;
    *a2 = v9;
    a2 = v9;
  }
  else
  {
    *((_BYTE *)a2 + 23) = v4;
    if (!v4)
      goto LABEL_9;
  }
  result = (uint64_t)memmove(a2, v5, v6);
LABEL_9:
  *((_BYTE *)a2 + v6) = 0;
  return result;
}

uint64_t std::stringbuf::view[abi:nn180100](uint64_t a1)
{
  int v1;
  unint64_t v3;

  v1 = *(_DWORD *)(a1 + 96);
  if ((v1 & 0x10) != 0)
  {
    v3 = *(_QWORD *)(a1 + 48);
    if (*(_QWORD *)(a1 + 88) < v3)
      *(_QWORD *)(a1 + 88) = v3;
    return *(_QWORD *)(a1 + 40);
  }
  else if ((v1 & 8) != 0)
  {
    return *(_QWORD *)(a1 + 16);
  }
  else
  {
    return 0;
  }
}

uint64_t RB::Coverage::Primitive::set_rendering_mode(uint64_t result, char a2)
{
  *(_BYTE *)(result + 45) = a2;
  if ((a2 & 0xFE) == 2)
    *(_BYTE *)(result + 46) &= ~4u;
  return result;
}

_QWORD *RB::Coverage::Primitive::encode(float32x4_t *this, RB::Encoder *a2)
{
  unint64_t v4;
  _QWORD *result;
  int v6;
  int8x16_t v7;
  int8x16_t v8;
  float32x4_t v9;
  int v10;
  int v11;
  float v12;
  int v13;
  unint64_t v14;
  __int8 v15;
  int v16;

  v4 = this[2].u8[12];
  if (v4 == 2
    || (RB::ProtobufEncoder::encode_varint(a2, 8uLL),
        result = RB::ProtobufEncoder::encode_varint(a2, v4),
        v6 = this[2].u8[12],
        (v6 - 2) < 7))
  {
    RB::ProtobufEncoder::float4_field(a2, 2, *this);
    v7.i8[0] = this[2].i8[12];
    v8.i32[0] = 4;
    v9 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v7, v8), 0), (int8x16_t)vmulq_f32(this[1], (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)this[1]);
    if ((vminvq_u32((uint32x4_t)vceqq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 0))) & 0x80000000) != 0)
    {
      if (v9.f32[0] != 0.0)
      {
        v16 = v9.i32[0];
        RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v16);
      }
    }
    else
    {
      RB::ProtobufEncoder::float4_field(a2, 4, v9);
    }
    v10 = this[2].i32[0];
    if (*(float *)&v10 != 1.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v10);
    }
    v11 = this[2].i32[1];
    if (*(float *)&v11 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
      RB::ProtobufEncoder::encode_fixed32(a2, v11);
    }
    if ((this[2].i8[14] & 4) != 0)
    {
      v13 = this[2].i32[2];
      RB::ProtobufEncoder::encode_varint(a2, 0x3DuLL);
    }
    else
    {
      v12 = this[2].f32[2];
      if (v12 == 0.0)
      {
LABEL_16:
        v14 = this[2].u8[13];
        RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
        result = RB::ProtobufEncoder::encode_varint(a2, v14);
        v15 = this[2].i8[14];
        if ((v15 & 1) != 0)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
          result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
          v15 = this[2].i8[14];
        }
        if ((v15 & 2) != 0)
        {
          RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
          return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
        }
        return result;
      }
      RB::ProtobufEncoder::encode_varint(a2, 0x5DuLL);
      v13 = LODWORD(v12);
    }
    RB::ProtobufEncoder::encode_fixed32(a2, v13);
    goto LABEL_16;
  }
  if ((v6 - 9) < 3)
    abort();
  return result;
}

unint64_t RB::Coverage::Primitive::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  int32x2_t v7;
  __n128 v8;
  unint64_t v9;
  char v10;
  char v11;
  int v12;
  char v13;
  char v14;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          v6 = RB::ProtobufDecoder::uint_field(this, v5);
          if (v6 <= 8)
            *(_BYTE *)(a1 + 44) = v6;
          break;
        case 2u:
          *(__n128 *)a1 = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 3u:
          *(float *)v7.i32 = RB::ProtobufDecoder::float_field(this, v5);
          v8 = (__n128)vdupq_lane_s32(v7, 0);
          goto LABEL_9;
        case 4u:
          v8 = RB::ProtobufDecoder::float4_field(this, v5);
LABEL_9:
          *(__n128 *)(a1 + 16) = v8;
          break;
        case 5u:
          *(float *)(a1 + 32) = RB::ProtobufDecoder::float_field(this, v5);
          break;
        case 6u:
          *(float *)(a1 + 36) = RB::ProtobufDecoder::float_field(this, v5);
          break;
        case 7u:
          *(_BYTE *)(a1 + 46) |= 4u;
          goto LABEL_13;
        case 8u:
          v9 = RB::ProtobufDecoder::uint_field(this, v5);
          if (v9 <= 3)
            *(_BYTE *)(a1 + 45) = v9;
          break;
        case 9u:
          v10 = *(_BYTE *)(a1 + 46) & 0xFE | RB::ProtobufDecoder::BOOL_field(this, v5);
          goto LABEL_21;
        case 0xAu:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v11 = 2;
          else
            v11 = 0;
          v10 = *(_BYTE *)(a1 + 46) & 0xFD | v11;
LABEL_21:
          *(_BYTE *)(a1 + 46) = v10;
          break;
        case 0xBu:
LABEL_13:
          *(float *)(a1 + 40) = RB::ProtobufDecoder::float_field(this, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  v12 = *(unsigned __int8 *)(a1 + 44);
  if (v12 == 4)
    *(float32x4_t *)(a1 + 16) = vmulq_f32(*(float32x4_t *)(a1 + 16), (float32x4_t)vdupq_n_s32(0x3FA33333u));
  v13 = *(_BYTE *)(a1 + 46);
  if ((v13 & 1) != 0)
  {
    if (v12)
    {
      if (v12 != 1)
        return result;
      v14 = 0;
    }
    else
    {
      v14 = 1;
    }
    *(_BYTE *)(a1 + 44) = v14;
    *(_BYTE *)(a1 + 46) = v13 & 0xFE;
  }
  return result;
}

_QWORD *RB::Coverage::Primitive::attributes(RB::Coverage::Primitive *this, RB::XML::Element *a2, double a3, double a4, int8x16_t a5)
{
  float32x2_t v7;
  float32x2_t v13;
  int v14;
  char v15;
  const char *v16;
  float32x4_t v17;
  int8x16_t v18;
  float32x4_t v19;
  float v20;
  const char *v21;
  float32x2_t v22;
  float64_t v23;
  const char *v24;
  float32x2_t v26;
  float32x2_t v27;
  float v30;
  _QWORD *result;
  float64_t v32;
  char v33;
  void *v34;
  float64x2_t v35;
  float64x2_t v36;

  switch(*((_BYTE *)this + 44))
  {
    case 0:
      v34 = &unk_24C229010;
      LOBYTE(v35.f64[0]) = 1;
      v16 = "empty";
      return RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)v16, (uint64_t)&v34);
    case 1:
      v34 = &unk_24C229010;
      LOBYTE(v35.f64[0]) = 1;
      v16 = "infinite";
      return RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)v16, (uint64_t)&v34);
    case 2:
      goto LABEL_24;
    case 3:
      goto LABEL_9;
    case 4:
      v34 = &unk_24C228F48;
      *(_QWORD *)&v35.f64[0] = "continuous";
      RB::XML::Element::set<RB::XML::Value::ConstantString>(a2, (uint64_t)"corner-style", (uint64_t)&v34);
LABEL_9:
      v17 = *((float32x4_t *)this + 1);
      v18 = vmvnq_s8((int8x16_t)vceqzq_f32(v17));
      v18.i32[0] = vmaxvq_u32((uint32x4_t)v18);
      if (v18.i32[0] < 0)
      {
        v18.i8[0] = *((_BYTE *)this + 44);
        a5.i32[0] = 4;
        v19 = (float32x4_t)vbslq_s8(vdupq_lane_s8((int8x8_t)*(_OWORD *)&vceqq_s8(v18, a5), 0), (int8x16_t)vmulq_f32(v17, (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)v17);
        if ((vminvq_u32((uint32x4_t)vceqq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 0))) & 0x80000000) != 0)
        {
          if (*((float *)this + 8) == 1.0)
          {
            v34 = &unk_24C229178;
            v35.f64[0] = v19.f32[0];
            RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"corner-radius", (uint64_t)&v34);
          }
          else
          {
            __asm { FMOV            V2.2S, #1.0 }
            _D2.i32[0] = *((_DWORD *)this + 8);
            v34 = &unk_24C2290B0;
            v35 = vcvtq_f64_f32(vmul_n_f32(_D2, v19.f32[0]));
            RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"corner-radius", (uint64_t)&v34);
          }
        }
        else
        {
          v34 = &unk_24C229100;
          v35 = vcvtq_f64_f32(*(float32x2_t *)v19.f32);
          v36 = vcvt_hight_f64_f32(v19);
          RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)"corner-radius", (uint64_t)&v34);
        }
      }
LABEL_24:
      if (*((float *)this + 9) <= 0.0)
        v24 = "rect";
      else
        v24 = "stroked-rect";
      __asm { FMOV            V2.2S, #1.0 }
      _D2.i32[0] = *((_DWORD *)this + 8);
      v26 = vmul_f32(*(float32x2_t *)this, _D2);
      v27 = vmul_f32(*(float32x2_t *)((char *)this + 8), _D2);
      goto LABEL_28;
    case 5:
      v20 = *((float *)this + 9);
      if (*((float *)this + 8) == 1.0)
      {
        if (v20 <= 0.0)
          v21 = "circle";
        else
          v21 = "stroked-circle";
        v22 = vmla_f32(*(float32x2_t *)this, (float32x2_t)0x3F0000003F000000, *(float32x2_t *)((char *)this + 8));
        v34 = &unk_24C2290B0;
        v35 = vcvtq_f64_f32(v22);
        RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)v21, (uint64_t)&v34);
        v23 = (float)(0.5 * COERCE_FLOAT(*((_QWORD *)this + 1)));
        v34 = &unk_24C229178;
        v35.f64[0] = v23;
        RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"radius", (uint64_t)&v34);
      }
      else
      {
        if (v20 <= 0.0)
          v24 = "ellipse";
        else
          v24 = "stroked-ellipse";
        __asm { FMOV            V3.2S, #1.0 }
        _D3.i32[0] = *((_DWORD *)this + 8);
        v26 = vmul_f32(*(float32x2_t *)this, _D3);
        v27 = vmul_f32(*(float32x2_t *)((char *)this + 8), _D3);
LABEL_28:
        v34 = &unk_24C229100;
        v35 = vcvtq_f64_f32(v26);
        v36 = vcvtq_f64_f32(v27);
        RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)v24, (uint64_t)&v34);
      }
LABEL_29:
      v30 = *((float *)this + 9);
      if (v30 > 0.0)
      {
        v34 = &unk_24C229178;
        v35.f64[0] = v30;
        RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"line-width", (uint64_t)&v34);
      }
      if ((*((_BYTE *)this + 46) & 4) != 0)
      {
        v32 = *((float *)this + 10);
        v34 = &unk_24C229178;
        v35.f64[0] = v32;
        result = RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"blur-radius", (uint64_t)&v34);
      }
      else
      {
        result = RB::XML::Element::set_rendering_mode(a2, *((unsigned __int8 *)this + 45), *((float *)this + 10));
      }
      v33 = *((_BYTE *)this + 46);
      if ((v33 & 1) != 0)
      {
        v34 = &unk_24C229010;
        LOBYTE(v35.f64[0]) = 1;
        result = RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"inverse", (uint64_t)&v34);
        v33 = *((_BYTE *)this + 46);
      }
      if ((v33 & 2) != 0)
      {
        v34 = &unk_24C229010;
        LOBYTE(v35.f64[0]) = 1;
        v16 = "shape-is-alpha";
        return RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)v16, (uint64_t)&v34);
      }
      return result;
    case 6:
    case 7:
    case 8:
      v7 = *(float32x2_t *)((char *)this + 8);
      __asm { FMOV            V2.2S, #1.0 }
      _D2.i32[0] = *((_DWORD *)this + 8);
      v13 = vmul_f32(*(float32x2_t *)this, _D2);
      v34 = &unk_24C229100;
      v35 = vcvtq_f64_f32(v13);
      v36 = vcvtq_f64_f32(vmla_f32(v13, _D2, v7));
      RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)"stroked-line", (uint64_t)&v34);
      v14 = *((unsigned __int8 *)this + 44);
      if (v14 == 6)
        v15 = 2;
      else
        v15 = v14 != 7;
      v34 = &unk_24C229218;
      LOBYTE(v35.f64[0]) = v15;
      RB::XML::Element::set<RB::XML::Value::LineCap>(a2, (uint64_t)"line-cap", (uint64_t)&v34);
      goto LABEL_29;
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      goto LABEL_29;
  }
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Vec4>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229100;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v6 + 24) = *(_OWORD *)(a3 + 24);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec4,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

BOOL RB::Coverage::Primitive::append_blur(RB::Coverage::Primitive *this, float a2, float64x2_t *a3, float64x2_t *a4)
{
  char v8;
  __int128 v9;
  _BOOL8 result;
  float v11;
  float64x2_t v12;
  float64x2_t *v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  char v19;
  float v20;
  __int128 v21;
  float64x2_t v22[3];
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;

    return 0;
  v8 = *((_BYTE *)this + 44);
  v9 = *((_OWORD *)this + 1);
  result = 1;
  switch(v8)
  {
    case 0:
    case 1:
      return result;
    case 2:
    case 3:
    case 4:
    case 6:
    case 7:
    case 8:
      return 0;
    case 5:
      if (*((float *)this + 8) != 1.0)
        return 0;
      v11 = *(float *)&v9 + *(float *)&v9;
      v20 = *((float *)this + 9);
      if (v20 > 0.0 && v11 >= v20)
        v11 = *((float *)this + 9);
LABEL_7:
      if (a4 == a3)
        goto LABEL_13;
      v21 = *((_OWORD *)this + 1);
      v12 = a3[1];
      v23 = *a3;
      v24 = v12;
      v25 = a3[2];
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v23))
        v13 = &v23;
      else
        v13 = a3;
      v14 = v13[1];
      v15 = v13[2];
      v23 = *v13;
      v24 = v14;
      v25 = v15;
      v16.f64[0] = RB::operator*(a4, &v23);
      v22[0] = v16;
      v22[1] = v17;
      v22[2] = v18;
      result = RB::AffineTransform::is_uniform(v22);
      if (!result)
        return result;
      a2 = RB::AffineTransform::scale(v22) * a2;
      v9 = v21;
LABEL_13:
      v19 = *((_BYTE *)this + 46);
      if ((v19 & 4) != 0)
        a2 = sqrtf((float)(a2 * a2) + (float)(*((float *)this + 10) * *((float *)this + 10)));
      if (v11 < (float)(a2 * 2.8))
        return 0;
      *((_BYTE *)this + 44) = v8;
      *((_OWORD *)this + 1) = v9;
      *((float *)this + 10) = a2;
      *((_BYTE *)this + 46) = v19 | 4;
      result = 1;
      break;
    case 9:
    case 10:
    case 11:
      abort();
    default:
      v11 = 0.0;
      goto LABEL_7;
  }
  return result;
}

uint64_t RB::Coverage::Primitive::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v4;
  unsigned int v5;
  uint32x2_t v6;
  int v7;

  if (*(unsigned __int8 *)(a1 + 45) != *(unsigned __int8 *)(a3 + 45)
    || ((*(_BYTE *)(a3 + 46) ^ *(_BYTE *)(a1 + 46)) & 3) != 0)
  {
    return 0;
  }
  v4 = *(unsigned __int8 *)(a1 + 44);
  v5 = *(unsigned __int8 *)(a3 + 44);
  if (v4 != v5)
  {
    v7 = v5 >= v4 ? *(unsigned __int8 *)(a1 + 44) : *(unsigned __int8 *)(a3 + 44);
    if (v7 != 2)
      return 0;
    if (v4 <= v5)
      v4 = *(unsigned __int8 *)(a3 + 44);
    if (v4 - 3 > 1)
      return 0;
  }
  v6 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(a1 + 8), *(float32x2_t *)(a3 + 8)), (int8x8_t)vceq_f32(*(float32x2_t *)a1, *(float32x2_t *)a3));
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) == 0 || *(float *)(a1 + 32) != *(float *)(a3 + 32))
    return 1;
  if ((vminvq_u32((uint32x4_t)vceqq_f32(*(float32x4_t *)(a1 + 16), *(float32x4_t *)(a3 + 16))) & 0x80000000) != 0
    && *(float *)(a1 + 36) == *(float *)(a3 + 36)
    && *(float *)(a1 + 40) == *(float *)(a3 + 40))
  {
    return 4;
  }
  return 2;
}

uint64_t RB::Coverage::Primitive::mix(uint64_t result, uint64_t a2, uint64_t a3)
{
  float v3;
  float v4;
  float v5;
  float v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  unsigned int v25;

  v3 = *(float *)(result + 32);
  v4 = *(float *)(a3 + 32);
  v5 = *(float *)(a2 + 16);
  v6 = v3 + (float)((float)(v4 - v3) * v5);
  v7 = *(float32x2_t *)(result + 8);
  if (v3 == v4)
  {
    v8 = vadd_f32(v7, *(float32x2_t *)result);
    v9 = vmla_n_f32(*(float32x2_t *)result, vsub_f32(*(float32x2_t *)a3, *(float32x2_t *)result), v5);
    v10 = vsub_f32(vmla_n_f32(v8, vadd_f32(vsub_f32(*(float32x2_t *)a3, v8), *(float32x2_t *)(a3 + 8)), v5), v9);
  }
  else
  {
    __asm { FMOV            V6.2S, #1.0 }
    v16.i32[1] = _D6.i32[1];
    v16.i32[0] = *(_DWORD *)(result + 32);
    v17 = vmul_f32(*(float32x2_t *)result, v16);
    _D6.i32[0] = *(_DWORD *)(a3 + 32);
    v18 = vmul_f32(*(float32x2_t *)a3, _D6);
    v19 = vmla_n_f32(v17, vsub_f32(v18, v17), v5);
    v20 = vmla_f32(v17, v16, v7);
    v21 = vsub_f32(vmla_n_f32(v20, vmla_f32(vsub_f32(v18, v20), _D6, *(float32x2_t *)(a3 + 8)), v5), v19);
    v22 = vrecpe_f32((float32x2_t)LODWORD(v6));
    v23 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v6), v22), v22);
    v24.i32[0] = vmul_f32(v23, vrecps_f32((float32x2_t)LODWORD(v6), v23)).u32[0];
    v24.i32[1] = 1.0;
    v9 = vmul_f32(v24, v19);
    v10 = vmul_f32(v21, v24);
  }
  *(float32x2_t *)result = v9;
  *(float32x2_t *)(result + 8) = v10;
  *(float *)(result + 32) = v6;
  *(float32x4_t *)(result + 16) = vmlaq_n_f32(*(float32x4_t *)(result + 16), vsubq_f32(*(float32x4_t *)(a3 + 16), *(float32x4_t *)(result + 16)), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  *(float32x2_t *)(result + 36) = vmla_n_f32(*(float32x2_t *)(result + 36), vsub_f32(*(float32x2_t *)(a3 + 36), *(float32x2_t *)(result + 36)), COERCE_FLOAT(*(_QWORD *)(a2 + 16)));
  v25 = *(unsigned __int8 *)(result + 44);
  if (v25 <= *(unsigned __int8 *)(a3 + 44))
    LOBYTE(v25) = *(_BYTE *)(a3 + 44);
  *(_BYTE *)(result + 44) = v25;
  return result;
}

uint64_t RB::Coverage::Primitive::set_coverage_state(uint64_t result, _DWORD *a2)
{
  char v2;
  float v3;
  unsigned int v5;
  unsigned int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;

  v2 = *(_BYTE *)(result + 46);
  v3 = *(float *)(result + 40);
  if (v3 > 0.0 && (v2 & 4) != 0)
  {
    v7 = *a2 & 0xFFFFFFCF | 0x20;
LABEL_11:
    *a2 = v7;
    v2 &= 1u;
    goto LABEL_14;
  }
  v5 = *(unsigned __int8 *)(result + 45);
  if (v3 <= 0.0 || v5 < 2)
  {
    v7 = *a2 & 0xFFFFFFCF | (16 * (v5 == 1));
    goto LABEL_11;
  }
  v7 = *a2 | 0x30;
  *a2 = v7;
  if (*(_BYTE *)(result + 45) == 3)
    v2 = (v2 & 1) == 0;
LABEL_14:
  if (*(unsigned __int8 *)(result + 44) - 6 >= 3)
    v8 = (*(float *)(result + 36) > 0.0) << 6;
  else
    v8 = 0;
  v9 = v7 & 0xFFFFFF3F;
  if ((v2 & 1) != 0)
    v10 = 128;
  else
    v10 = 0;
  v11 = v8 | v10 | v9;
  *a2 = v11;
  *a2 = v11 & 0xFFFFFEFF | (((*(unsigned __int8 *)(result + 46) >> 1) & 1) << 8);
  return result;
}

void RB::Coverage::Primitive::make_image_mask(float32x2_t *this@<X0>, RB::CGContext *a2@<X1>, CGImageRef *a3@<X8>)
{
  CGFloat y;
  CGFloat height;
  float32x2_t v8;
  float32x2_t v9;
  double v10;
  double v11;
  double v12;
  int32x4_t v13;
  uint32x2_t v14;
  float v15;
  int v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  int32x4_t v27;
  RB::CGContext *v28;
  float v29;
  char v30;
  int32x2_t v31;
  CGContext *v32;
  float v33;
  CGContext *v34;
  CFTypeRef v35;
  CFTypeRef cf;
  __int128 v37;
  CGContextRef c[2];
  __int128 v39;
  uint64_t v40;
  uint64_t v41;
  unsigned __int8 v42;
  uint64_t v43;
  CGRect ClipBoundingBox;

  v43 = *MEMORY[0x24BDAC8D0];
  ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
  y = ClipBoundingBox.origin.y;
  height = ClipBoundingBox.size.height;
  *(float32x2_t *)&v37 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  *((float32x2_t *)&v37 + 1) = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  *(_OWORD *)c = xmmword_209BD5290;
  v39 = xmmword_209BD52A0;
  v40 = 0;
  v41 = 0;
  v8 = RB::Coverage::Primitive::bounds(this, (float64x2_t *)c, (int8x16_t)xmmword_209BD5290, 0.0, (int8x16_t)ClipBoundingBox.size, *(int32x4_t *)&ClipBoundingBox.size.height);
  RB::Rect::intersect((float32x2_t *)&v37, v8, v9, v10, v11, v12, v13);
  v14 = (uint32x2_t)vclez_f32(*(float32x2_t *)((char *)&v37 + 8));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0)
    goto LABEL_11;
  v15 = 0.0;
  if ((this[5].i8[6] & 4) != 0)
  {
    if (this[5].f32[0] >= 0.0)
      v15 = this[5].f32[0];
    else
      v15 = 0.0;
  }
  v33 = fminf(3.5 / v15, 1.0);
  RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v37, 1, 0, (int8x8_t)vmul_n_f32(*(float32x2_t *)((char *)a2 + 16), v33), 1u, (CGContext **)&cf);
  if (!cf)
  {
LABEL_11:
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    __asm { FMOV            V0.2S, #1.0 }
    RB::CGContext::CGContext(c, cf, *((unsigned __int8 *)a2 + 8), _D0);
    v21 = rb_clip_mode(this[5].u8[5]);
    if (v42 != v21)
      RB::CGContext::set_aliasing_mode_slow((uint64_t)c, v21);
    RB::Coverage::Primitive::add_path(this, c, v22, v23, v24, v25, v26, v27);
    v29 = this[4].f32[1];
    if (v29 == 0.0)
    {
      CGContextFillPath(c[0]);
    }
    else
    {
      CGContextStrokePath(c[0]);
    }
    v30 = 2 * (this[5].i8[6] & 1);
    v35 = 0;
    RB::CGContext::apply_blur((uint64_t)c, v30, &v35, v33 * v15);
    if (v33 < 0.9)
    {
      v31 = (int32x2_t)RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v37, 1, 0, 0, 0, &v34);
      if (v34)
      {
        *(float *)v31.i32 = 1.0 / v33;
        RB::CGContext::apply_scale(c, v34, COERCE_DOUBLE(vdup_lane_s32(v31, 0)));
        v32 = (CGContext *)cf;
        cf = v34;
        v34 = v32;
        if (v32)
          CFRelease(v32);
      }
    }
    *a3 = CGBitmapContextCreateImage((CGContextRef)cf);
    *(_OWORD *)(a3 + 1) = v37;
    if (v35)
      CFRelease(v35);
    RB::CGContext::~CGContext((RB::CGContext *)c);
    if (cf)
      CFRelease(cf);
  }
}

void sub_209B64A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf, CFTypeRef a13, CFTypeRef a14, uint64_t a15, uint64_t a16, char a17)
{
  if (cf)
    CFRelease(cf);
  if (a13)
    CFRelease(a13);
  RB::CGContext::~CGContext((RB::CGContext *)&a17);
  if (a14)
    CFRelease(a14);
  _Unwind_Resume(a1);
}

void RB::Coverage::`anonymous namespace'::set_stroke(CGContextRef *this, RB::CGContext *a2, CGFloat a3)
{
  CGContextSetLineWidth(*this, a3);
  CGContextSetLineJoin(*this, kCGLineJoinMiter);
  CGContextSetLineDash(*this, 0.0, 0, 0);
  CGContextSetMiterLimit(*this, 10.0);
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec4,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229D58;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B64B1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec4 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec4>,std::allocator<RB::XML::Value::Vec4>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec4 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec4>,std::allocator<RB::XML::Value::Vec4>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

float64x2_t CG::stroker::stroker(uint64_t a1, float64x2_t *a2, int a3, int a4, uint64_t a5, double a6, double a7, double a8)
{
  double v8;
  double v9;
  double v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t result;

  *(_QWORD *)a1 = off_24C222F88;
  *(double *)(a1 + 40) = a7;
  *(_DWORD *)(a1 + 48) = a3;
  *(_DWORD *)(a1 + 52) = a4;
  *(double *)(a1 + 56) = a8;
  *(double *)(a1 + 64) = a6;
  *(_QWORD *)(a1 + 80) = a5;
  *(_DWORD *)(a1 + 88) = 0;
  v8 = a6 * 0.1;
  if (a6 * 0.1 < 0.001)
    v8 = 0.001;
  if (a6 <= 0.0)
    v9 = 0.1;
  else
    v9 = v8;
  v10 = a7 * 0.5;
  v11 = a2[1];
  v12 = vmulq_n_f64(*a2, v10);
  *(_QWORD *)(a1 + 240) = 0;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(double *)(a1 + 72) = v9;
  *(float64x2_t *)(a1 + 8) = v12;
  result = vmulq_n_f64(v11, v10);
  *(float64x2_t *)(a1 + 24) = result;
  return result;
}

__n128 CG::stroker::moveto(__n128 *this, __n128 a2)
{
  __n128 result;
  __n128 v4;

  if (this[5].n128_u32[2] - 3 <= 1)
  {
    v4 = a2;
    CG::stroker::end_contour((uint64_t)this);
    a2 = v4;
  }
  this[5].n128_u32[2] = 2;
  this[12] = a2;
  result = this[12];
  this[9] = result;
  this[6] = result;
  return result;
}

uint64_t CG::stroker::end_contour(uint64_t this)
{
  uint64_t v1;
  int v2;
  float64x2_t v3;

  v1 = this;
  v2 = *(_DWORD *)(this + 88);
  if (v2 == 4)
  {
    CG::stroker::add_cap(this, (float64x2_t *)(this + 144), this + 176, 1);
    CG::stroker::unroll_path(v1);
    v3 = vnegq_f64(*(float64x2_t *)(v1 + 128));
    CG::stroker::add_cap(v1, (float64x2_t *)(v1 + 96), (uint64_t)&v3, 0);
    return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 80) + 8))(*(_QWORD *)(v1 + 80));
  }
  else if (v2 == 3)
  {
    v3 = vsubq_f64(*(float64x2_t *)(this + 192), *(float64x2_t *)(this + 96));
    return CG::stroker::add_point(this, (float64x2_t *)(this + 96), (uint64_t)&v3);
  }
  return this;
}

__n128 CG::stroker::lineto(__n128 *a1, __n128 result)
{
  __int32 v2;
  __n128 *v3;
  __n128 *v4;

  v2 = a1[5].n128_i32[2];
  if (v2)
  {
    if (v2 == 1)
      a1[5].n128_u32[2] = 2;
    a1[12] = result;
    v3 = a1 + 12;
    v4 = a1 + 9;
    if (CG::stroker::add_line_segment((CG::stroker *)a1, (float64x2_t *)&a1[9], (const Point *)&a1[12]))
    {
      result = *v3;
      *v4 = *v3;
    }
  }
  return result;
}

BOOL CG::stroker::add_line_segment(CG::stroker *this, float64x2_t *a2, const Point *a3)
{
  float64x2_t v4;
  double v5;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t *v16;
  float64x2_t v17;
  float64x2_t v18;
  double v19;
  __n128 v20;
  double v21;
  float64x2_t v23;
  Point v24[2];
  double v25;
  float64x2_t v26;
  float64x2_t v27;

  v4 = vsubq_f64(*(float64x2_t *)&a3->v, *a2);
  v27 = v4;
  v5 = vaddvq_f64(vmulq_f64(v4, v4));
  if (v5 <= 0.00000001)
  {
    if (*((_DWORD *)this + 22) == 2)
      *((_DWORD *)this + 22) = 3;
  }
  else
  {
    v8 = *(float64x2_t *)((char *)this + 8);
    v9 = *(float64x2_t *)((char *)this + 24);
    v10 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v9, 8uLL), v8);
    if (vsubq_f64(v10, (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1)).f64[0] >= 0.0)
    {
      v13.f64[0] = *((float64_t *)this + 3);
      v13.f64[1] = *((float64_t *)this + 2);
      v12 = vnegq_f64(v13);
      v11 = (float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v8, 8uLL);
    }
    else
    {
      v11 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v9, (int8x16_t)v8, 8uLL));
      v12.f64[0] = *((float64_t *)this + 3);
      v12.f64[1] = *((float64_t *)this + 2);
    }
    v14 = vmlaq_f64(vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL), v12), v4, v11);
    if (v14.f64[0] != 0.0 || v14.f64[1] != 0.0)
      v14 = vdivq_f64(v14, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v14, v14)))), 0));
    v26 = v14;
    v15 = vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v8, v14, 1)), v9, v14.f64[0]);
    v16 = (float64x2_t *)((char *)this + 160);
    v23 = v15;
    if (*((_DWORD *)this + 22) == 4)
    {
      CG::stroker::add_join(this, a2, v27.f64, v26.f64);
      *v16 = v27;
      *((float64x2_t *)this + 11) = v26;
    }
    else
    {
      *((_DWORD *)this + 22) = 4;
      v18 = v26;
      v17 = v27;
      *v16 = v27;
      *((float64x2_t *)this + 11) = v18;
      *((float64x2_t *)this + 7) = v17;
      *((float64x2_t *)this + 8) = v18;
      (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 16))(*((_QWORD *)this + 10), (__n128)vaddq_f64(*a2, v15));
    }
    v19 = a2->f64[1] - v23.f64[1];
    *(double *)&v24[0].v = a2->f64[0] - v23.f64[0];
    v25 = v19;
    CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v24);
    v20.n128_f64[0] = *(double *)&a3->v + v23.f64[0];
    v20.n128_f64[1] = *(double *)&a3[2].v + v23.f64[1];
    (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), v20);
    v21 = *(double *)&a3[2].v - v23.f64[1];
    *((double *)this + 26) = *(double *)&a3->v - v23.f64[0];
    *((double *)this + 27) = v21;
  }
  return v5 > 0.00000001;
}

float64x2_t CG::stroker::quadto(Point *a1, float64x2_t result, float64x2_t a3)
{
  Point v3;
  float64x2_t *v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8[7];
  Point v9[4];
  Point v10[4];

  v3 = a1[22];
  if (v3)
  {
    if (v3 == 1)
      a1[22] = (Point)2;
    *(float64x2_t *)&a1[48].v = a3;
    v5 = (float64x2_t *)&a1[48];
    v6 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
    v7 = vmlaq_f64(result, v6, vsubq_f64(*(float64x2_t *)&a1[36].v, result));
    *(float64x2_t *)&v9[0].v = vmlaq_f64(result, v6, vsubq_f64(a3, result));
    *(float64x2_t *)&v10[0].v = v7;
    CG::Cubic::Cubic((CG::Cubic *)v8, a1 + 36, v10, v9, a1 + 48);
    if (CG::stroker::add_cubic_segment((CG::stroker *)a1, v8))
    {
      result = *v5;
      *(float64x2_t *)&a1[36].v = *v5;
    }
  }
  return result;
}

uint64_t CG::stroker::add_cubic_segment(CG::stroker *this, float64x2_t *a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  float64x2_t v8;
  float64_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  CG::stroker *v32;
  float64x2_t *v33;
  uint64_t result;
  float64x2_t v35[7];
  uint64_t v36;
  float64x2_t v37[7];
  float64x2_t v38[7];
  float64x2_t v39;
  __int128 v40;

  v4 = a2[1].f64[0];
  v5 = a2[1].f64[1];
  if ((v4 - a2->f64[0]) * (v4 - a2->f64[0]) + (v5 - a2->f64[1]) * (v5 - a2->f64[1]) <= 0.00000001
    && (v6 = a2[2].f64[0], v7 = a2[2].f64[1], (v6 - v4) * (v6 - v4) + (v7 - v5) * (v7 - v5) <= 0.00000001)
    && (a2[3].f64[0] - v6) * (a2[3].f64[0] - v6) + (a2[3].f64[1] - v7) * (a2[3].f64[1] - v7) <= 0.00000001)
  {
    if (*((_DWORD *)this + 22) == 2)
    {
      result = 0;
      *((_DWORD *)this + 22) = 3;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    v8.f64[0] = CG::Cubic::derivative((CG::Cubic *)a2, 0.0);
    *(float64_t *)&v40 = v8.f64[0];
    *((float64_t *)&v40 + 1) = v9;
    v10 = *(float64x2_t *)((char *)this + 8);
    v11 = *(float64x2_t *)((char *)this + 24);
    v12 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v11, 8uLL), v10);
    if (vsubq_f64(v12, (float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1)).f64[0] >= 0.0)
    {
      v15.f64[0] = *((float64_t *)this + 3);
      v15.f64[1] = *((float64_t *)this + 2);
      v14 = vnegq_f64(v15);
      v13 = (float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v10, 8uLL);
    }
    else
    {
      v13 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v11, (int8x16_t)v10, 8uLL));
      v14.f64[0] = *((float64_t *)this + 3);
      v14.f64[1] = *((float64_t *)this + 2);
    }
    v8.f64[1] = v9;
    v16 = vmlaq_f64(vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v8, (int8x16_t)v8, 8uLL), v14), v8, v13);
    if (v16.f64[0] != 0.0 || v16.f64[1] != 0.0)
      v16 = vdivq_f64(v16, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v16, v16)))), 0));
    v39 = v16;
    if (*((_DWORD *)this + 22) == 4)
    {
      v37[0] = *a2;
      CG::stroker::add_join(this, v37, (double *)&v40, v39.f64);
    }
    else
    {
      *((_DWORD *)this + 22) = 4;
      v17 = v39;
      *((_OWORD *)this + 7) = v40;
      *((float64x2_t *)this + 8) = v17;
      (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 16))(*((_QWORD *)this + 10), (__n128)vaddq_f64(vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v10, v16, 1)), v11, v16.f64[0]), *a2));
    }
    v18 = CG::Cubic::derivative((CG::Cubic *)a2, 1.0);
    *((double *)this + 20) = v18;
    *((double *)this + 21) = v19;
    v20 = *((double *)this + 1);
    v21 = *((double *)this + 2);
    v22 = *((double *)this + 3);
    v23 = *((double *)this + 4);
    if (-(v22 * v21 - v23 * v20) >= 0.0)
    {
      v21 = -v21;
      v22 = -v22;
    }
    else
    {
      v23 = -v23;
      v20 = -v20;
    }
    v24 = v23 * v18 + v19 * v22;
    v25 = v21 * v18 + v19 * v20;
    if (v24 != 0.0 || v25 != 0.0)
    {
      v26 = sqrt(v24 * v24 + v25 * v25);
      v24 = v24 / v26;
      v25 = v25 / v26;
    }
    *((double *)this + 22) = v24;
    *((double *)this + 23) = v25;
    v27 = a2[1].f64[0];
    if (((a2[2].f64[0] - a2[3].f64[0]) * (a2[2].f64[1] - a2[1].f64[1])
        + (a2[3].f64[1] - a2[2].f64[1]) * (a2[2].f64[0] - v27))
       * ((a2[2].f64[0] - v27) * (a2->f64[1] - a2[1].f64[1]) + (a2[2].f64[1] - a2[1].f64[1]) * (v27 - a2->f64[0])) > 0.0
      || (v28 = CG::Cubic::inflection_points_classic((CG::Cubic *)a2), v30 = v28, v31 = v29, v28 == -1.0) && v29 == -1.0)
    {
      v32 = this;
      v33 = a2;
    }
    else
    {
      CG::Cubic::split(a2, v28, v37);
      CG::stroker::path_stroke_round_cube(this, v37);
      if (v31 == -1.0)
      {
        v33 = v38;
      }
      else
      {
        CG::Cubic::split(v38, (v31 - v30) / (1.0 - v30), v35);
        CG::stroker::path_stroke_round_cube(this, v35);
        v33 = (float64x2_t *)&v36;
      }
      v32 = this;
    }
    CG::stroker::path_stroke_round_cube(v32, v33);
    return 1;
  }
  return result;
}

__n128 CG::stroker::cubeto(uint64_t a1, __n128 result, __n128 a3, __n128 a4)
{
  int v4;
  __n128 *v6;
  float64x2_t v7[7];
  Point v8[4];
  Point v9[4];

  v4 = *(_DWORD *)(a1 + 88);
  if (v4)
  {
    if (v4 == 1)
      *(_DWORD *)(a1 + 88) = 2;
    *(__n128 *)&v8[0].v = a3;
    *(__n128 *)&v9[0].v = result;
    *(__n128 *)(a1 + 192) = a4;
    v6 = (__n128 *)(a1 + 192);
    CG::Cubic::Cubic((CG::Cubic *)v7, (const Point *)(a1 + 144), v9, v8, (const Point *)(a1 + 192));
    if (CG::stroker::add_cubic_segment((CG::stroker *)a1, v7))
    {
      result = *v6;
      *(__n128 *)(a1 + 144) = *v6;
    }
  }
  return result;
}

__n128 CG::stroker::closepath(CG::stroker *this)
{
  unsigned int v1;
  _OWORD *v3;
  __n128 result;
  float64x2_t v5;

  v1 = *((_DWORD *)this + 22);
  if (v1 >= 2)
  {
    if (v1 == 4)
    {
      CG::stroker::add_line_segment(this, (float64x2_t *)this + 9, (const Point *)this + 24);
      *((_OWORD *)this + 9) = *((_OWORD *)this + 6);
      CG::stroker::add_join(this, (float64x2_t *)this + 6, (double *)this + 14, (double *)this + 16);
      (*(void (**)(_QWORD))(**((_QWORD **)this + 10) + 8))(*((_QWORD *)this + 10));
      (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 16))(*((_QWORD *)this + 10), *((__n128 *)this + 13));
      CG::stroker::unroll_path((uint64_t)this);
      (*(void (**)(_QWORD))(**((_QWORD **)this + 10) + 8))(*((_QWORD *)this + 10));
    }
    else
    {
      v3 = (_OWORD *)((char *)this + 96);
      v5 = vsubq_f64(*((float64x2_t *)this + 12), *((float64x2_t *)this + 6));
      CG::stroker::add_point((uint64_t)this, (float64x2_t *)this + 6, (uint64_t)&v5);
      *((_OWORD *)this + 9) = *v3;
    }
    *((_DWORD *)this + 22) = 1;
    result = *((__n128 *)this + 6);
    *((__n128 *)this + 12) = result;
  }
  return result;
}

uint64_t CG::stroker::add_join(CG::stroker *a1, float64x2_t *a2, double *a3, double *a4)
{
  int v4;

  v4 = *((_DWORD *)a1 + 13);
  if (!v4)
    return CG::stroker::add_miter_join(a1, a2, a3, a4);
  if (v4 == 1)
    return CG::stroker::add_round_join(a1, a2, a3, a4);
  if (v4 != 2)
    abort();
  return CG::stroker::add_bevel_join((uint64_t)a1, a2, a3, a4);
}

uint64_t CG::stroker::unroll_path(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t i;
  uint64_t v4;
  int v5;
  uint64_t v6;

  v1 = this;
  v2 = *(_QWORD *)(this + 232);
  for (i = v2 - 1; i >= 0; --i)
  {
    v4 = *(_QWORD *)(v1 + 224);
    v5 = *(_DWORD *)(v4 + 24 * i);
    if (v5 == 3)
    {
      v6 = v4 + 24 * i;
      i = v2 - 3;
      this = (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**(_QWORD **)(v1 + 80) + 40))(*(_QWORD *)(v1 + 80), *(__n128 *)(v4 + 24 * v2 - 64), *(__n128 *)(v4 + 24 * v2 - 40), *(__n128 *)(v6 + 8));
    }
    else if (v5 == 1)
    {
      this = (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(v1 + 80) + 24))(*(_QWORD *)(v1 + 80), *(__n128 *)(v4 + 24 * i + 8));
    }
    v2 = i;
  }
  *(_QWORD *)(v1 + 232) = 0;
  return this;
}

uint64_t CG::stroker::add_point(uint64_t result, float64x2_t *a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v6;
  int32x2_t v7;
  int64x2_t v8;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  _QWORD *v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;

  v3 = *(_DWORD *)(result + 48);
  if (v3 > 6 || ((1 << v3) & 0x69) == 0)
  {
    v6 = *(double *)a3 == 0.0;
    if (*(double *)(a3 + 8) != 0.0)
      v6 = 0;
    v7 = vdup_n_s32(v6);
    v8.i64[0] = v7.u32[0];
    v8.i64[1] = v7.u32[1];
    __asm { FMOV            V2.2D, #1.0 }
    v13 = (float64x2_t)vbslq_s8((int8x16_t)vcltzq_s64(vshlq_n_s64(v8, 0x3FuLL)), _Q2, *(int8x16_t *)a3);
    v14 = *(float64x2_t *)(result + 8);
    v15 = *(float64x2_t *)(result + 24);
    v16 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v15, 8uLL), v14);
    if (vsubq_f64(v16, (float64x2_t)vdupq_laneq_s64((int64x2_t)v16, 1)).f64[0] >= 0.0)
    {
      v19.f64[0] = *(float64_t *)(result + 24);
      v19.f64[1] = *(float64_t *)(result + 16);
      v18 = vnegq_f64(v19);
      v17 = (float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 8uLL);
    }
    else
    {
      v17 = vnegq_f64((float64x2_t)vextq_s8((int8x16_t)v15, (int8x16_t)v14, 8uLL));
      v18.f64[0] = *(float64_t *)(result + 24);
      v18.f64[1] = *(float64_t *)(result + 16);
    }
    v20 = vmlaq_f64(vmulq_f64(v18, (float64x2_t)vextq_s8((int8x16_t)v13, (int8x16_t)v13, 8uLL)), v13, v17);
    if (v20.f64[0] != 0.0 || v20.f64[1] != 0.0)
      v20 = vdivq_f64(v20, (float64x2_t)vdupq_lane_s64(COERCE__INT64(sqrt(vaddvq_f64(vmulq_f64(v20, v20)))), 0));
    v21 = vmlaq_n_f64(vnegq_f64(vmulq_laneq_f64(v14, v20, 1)), v15, v20.f64[0]);
    v22 = vmlaq_laneq_f64(vmulq_n_f64(v14, v20.f64[0]), v15, v20, 1);
    v32 = v22;
    v31 = v21;
    switch(v3)
    {
      case 4u:
        v23 = (_QWORD *)(result + 80);
        (*(void (**)(_QWORD, __n128))(**(_QWORD **)(result + 80) + 16))(*(_QWORD *)(result + 80), (__n128)vaddq_f64(*a2, v21));
        (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v23 + 24))(*v23, (__n128)vaddq_f64(*a2, v32));
        v25 = *a2;
        v26 = v31;
        break;
      case 2u:
        v23 = (_QWORD *)(result + 80);
        (*(void (**)(_QWORD, __n128))(**(_QWORD **)(result + 80) + 16))(*(_QWORD *)(result + 80), (__n128)vaddq_f64(vsubq_f64(v21, v22), *a2));
        v30 = vaddq_f64(v32, v31);
        (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v23 + 24))(*v23, (__n128)vaddq_f64(v30, *a2));
        (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v23 + 24))(*v23, (__n128)vaddq_f64(vsubq_f64(v32, v31), *a2));
        v25 = *a2;
        v26 = v30;
        break;
      case 1u:
        v23 = (_QWORD *)(result + 80);
        (*(void (**)(_QWORD, __n128))(**(_QWORD **)(result + 80) + 16))(*(_QWORD *)(result + 80), (__n128)vaddq_f64(*a2, v21));
        v24 = (float64x2_t)vdupq_n_s64(0x3FE1AC5111534A22uLL);
        v28 = vmulq_f64(v32, v24);
        v27 = vaddq_f64(v28, v31);
        v29 = vmulq_f64(v31, v24);
        (*(void (**)(_QWORD, __n128, __n128))(*(_QWORD *)*v23 + 40))(*v23, (__n128)vaddq_f64(v27, *a2), (__n128)vaddq_f64(vaddq_f64(*a2, v32), v29));
        (*(void (**)(_QWORD, __n128, __n128))(*(_QWORD *)*v23 + 40))(*v23, (__n128)vaddq_f64(vsubq_f64(v32, v29), *a2), (__n128)vaddq_f64(vsubq_f64(*a2, v31), v28));
        (*(void (**)(_QWORD, __n128, __n128))(*(_QWORD *)*v23 + 40))(*v23, (__n128)vsubq_f64(*a2, v27), (__n128)vsubq_f64(vsubq_f64(*a2, v32), v29));
        (*(void (**)(_QWORD, __n128, __n128))(*(_QWORD *)*v23 + 40))(*v23, (__n128)vaddq_f64(vsubq_f64(v29, v32), *a2), (__n128)vsubq_f64(vaddq_f64(*a2, v31), v28));
        return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v23 + 8))(*v23);
      default:
        abort();
    }
    (*(void (**)(_QWORD, __n128))(*(_QWORD *)*v23 + 24))(*v23, (__n128)vsubq_f64(v25, v26));
    return (*(uint64_t (**)(_QWORD))(*(_QWORD *)*v23 + 8))(*v23);
  }
  return result;
}

uint64_t CG::stroker::endpath(CG::stroker *this)
{
  if ((*((_DWORD *)this + 22) - 3) <= 1)
    CG::stroker::end_contour((uint64_t)this);
  return (***((uint64_t (****)(_QWORD))this + 10))(*((_QWORD *)this + 10));
}

uint64_t CG::stroker::add_cap(uint64_t a1, float64x2_t *a2, uint64_t a3, char a4)
{
  uint64_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  int v10;
  float64x2_t v11;
  float64x2_t v12;
  __n128 v14;
  __n128 v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;

  v6 = *(_QWORD *)(a3 + 8);
  v7 = *(float64x2_t *)(a1 + 8);
  v8 = *(float64x2_t *)(a1 + 24);
  v9 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v7, *(double *)&v6)), v8, *(double *)a3);
  v10 = *(_DWORD *)(a1 + 48);
  if (v10 && vaddvq_f64(vmulq_f64(v9, v9)) > 0.0025)
  {
    v11 = vmlaq_f64(vmulq_n_f64(v7, *(double *)a3), v8, (float64x2_t)vdupq_lane_s64(v6, 0));
    v20 = v9;
    switch(v10)
    {
      case 1:
        v12 = (float64x2_t)vdupq_n_s64(0x3FE1AC5111534A22uLL);
        v17 = vmulq_f64(v11, v12);
        v18 = v11;
        v16 = vmulq_f64(v9, v12);
        (*(void (**)(_QWORD, __n128, __n128))(**(_QWORD **)(a1 + 80) + 40))(*(_QWORD *)(a1 + 80), (__n128)vaddq_f64(v17, vaddq_f64(v9, *a2)), (__n128)vaddq_f64(vaddq_f64(*a2, v11), v16));
        return (*(uint64_t (**)(_QWORD, __n128, __n128))(**(_QWORD **)(a1 + 80) + 40))(*(_QWORD *)(a1 + 80), (__n128)vaddq_f64(vsubq_f64(v18, v16), *a2), (__n128)vaddq_f64(vsubq_f64(*a2, v20), v17));
      case 2:
        v19 = v11;
        (*(void (**)(__n128))(**(_QWORD **)(a1 + 80) + 24))((__n128)vaddq_f64(vaddq_f64(v11, v9), *a2));
        goto LABEL_9;
      case 3:
        goto LABEL_11;
      case 4:
        goto LABEL_8;
      case 5:
        if ((a4 & 1) == 0)
          goto LABEL_8;
        goto LABEL_11;
      case 6:
        if ((a4 & 1) != 0)
        {
LABEL_8:
          v19 = v11;
          (*(void (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 80) + 24))(*(_QWORD *)(a1 + 80), (__n128)vaddq_f64(vaddq_f64(v11, v9), *a2));
          (*(void (**)(__n128))(**(_QWORD **)(a1 + 80) + 24))(*(__n128 *)a2);
LABEL_9:
          v15 = (__n128)vaddq_f64(vsubq_f64(v19, v20), *a2);
        }
        else
        {
LABEL_11:
          v15 = (__n128)vaddq_f64(*a2, v11);
        }
        (*(void (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 80) + 24))(*(_QWORD *)(a1 + 80), v15);
        v14 = (__n128)vsubq_f64(*a2, v20);
        break;
      default:
        abort();
    }
  }
  else
  {
    v14 = (__n128)vsubq_f64(*a2, v9);
  }
  return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 80) + 24))(*(_QWORD *)(a1 + 80), v14);
}

uint64_t CG::stroker::add_bevel_join(uint64_t result, float64x2_t *a2, double *a3, double *a4)
{
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  uint64_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  Point v21[4];

  v4 = *(float64x2_t *)(result + 24);
  v5 = *(float64x2_t *)(result + 8);
  v6 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v5, *(double *)(result + 184))), v4, *(double *)(result + 176));
  v7 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v5, a4[1])), v4, *a4);
  v8 = vsubq_f64(v6, v7);
  if (vaddvq_f64(vmulq_f64(v8, v8)) >= *(double *)(result + 72) * *(double *)(result + 72))
  {
    v12 = result;
    *(float64x2_t *)(result + 208) = vsubq_f64(*a2, v7);
    v20 = v7;
    *(float64x2_t *)&v21[0].v = vsubq_f64(*a2, v6);
    v19 = v6;
    CG::stroker::push_opposite_element((CG::stroker *)result, kCGPathElementAddLineToPoint, v21);
    v13 = vmulq_f64(v19, v19);
    v14 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v13.f64[0], 0);
    v13.f64[0] = *(double *)(v12 + 168) * *(double *)(v12 + 168);
    v14.f64[0] = *(double *)(v12 + 160) * *(double *)(v12 + 160);
    v15 = vsqrtq_f64(vaddq_f64(v13, v14));
    if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v15, 1), v15)).u8[0] & 1) != 0
      || (v16 = vmulq_f64(v20, v20),
          v17 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v16.f64[0], 0),
          v16.f64[0] = a3[1] * a3[1],
          v17.f64[0] = *a3 * *a3,
          v18 = vsqrtq_f64(vaddq_f64(v16, v17)),
          (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v18, 1), v18)).u8[0] & 1) != 0))
    {
      if (-(*a4 * *(double *)(v12 + 184) - a4[1] * *(double *)(v12 + 176)) >= 0.0)
        (*(void (**)(_QWORD, __n128))(**(_QWORD **)(v12 + 80) + 24))(*(_QWORD *)(v12 + 80), *(__n128 *)a2);
      else
        CG::stroker::push_opposite_element((CG::stroker *)v12, kCGPathElementAddLineToPoint, (const Point *)a2);
    }
    return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(v12 + 80) + 24))(*(_QWORD *)(v12 + 80), (__n128)vaddq_f64(*a2, v20));
  }
  return result;
}

__n128 CG::stroker::push_opposite_element(CG::stroker *this, CGPathElementType a2, const Point *a3)
{
  uint64_t v5;
  uint64_t v6;
  __n128 result;
  _BYTE v8[20];

  *(_OWORD *)&v8[4] = *(_OWORD *)&a3->v;
  v5 = *((_QWORD *)this + 29);
  if (*((_QWORD *)this + 30) < (unint64_t)(v5 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)this + 224, v5 + 1);
    v5 = *((_QWORD *)this + 29);
  }
  v6 = *((_QWORD *)this + 28) + 24 * v5;
  *(_DWORD *)v6 = a2;
  result = *(__n128 *)v8;
  *(_OWORD *)(v6 + 4) = *(_OWORD *)v8;
  *(_DWORD *)(v6 + 20) = *(_DWORD *)&v8[16];
  ++*((_QWORD *)this + 29);
  return result;
}

uint64_t CG::stroker::add_miter_join(CG::stroker *this, float64x2_t *a2, double *a3, double *a4)
{
  double v8;
  double v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  __n128 v28;
  float64x2_t v29;
  __int128 v30;
  __int128 v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  __int128 v41;
  Point v42[4];
  __int128 v43;
  _BYTE v44[8];
  __n128 v45;

  v9 = *((double *)this + 22);
  v8 = *((double *)this + 23);
  v10 = *(float64x2_t *)((char *)this + 24);
  v11 = *(float64x2_t *)((char *)this + 8);
  v12 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v11, v8)), v10, v9);
  v13 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v11, a4[1])), v10, *a4);
  v14 = vsubq_f64(v12, v13);
  if (vaddvq_f64(vmulq_f64(v14, v14)) < 0.05)
    return CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
  *((float64x2_t *)this + 13) = vsubq_f64(*a2, v13);
  if (*((double *)this + 7) * *((double *)this + 7) * (*a4 * v9 + 1.0 + a4[1] * v8) < 2.0)
    return CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
  v38 = v12;
  v39 = v13;
  *(float64x2_t *)&v42[0].v = vsubq_f64(*a2, v12);
  CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v42);
  if (-(*a4 * *((double *)this + 23) - a4[1] * *((double *)this + 22)) >= 0.0)
  {
    v29 = *a2;
    v30 = *((_OWORD *)this + 10);
    *(float64x2_t *)&v42[0].v = vsubq_f64(*a2, v38);
    v43 = v30;
    v31 = *(_OWORD *)a3;
    v40 = vsubq_f64(v29, v39);
    v41 = v31;
    CG::intersection((double *)&v42[0].v, v40.f64, (uint64_t)v44);
    if (v44[0])
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)&v45);
    v32 = vmulq_f64(v38, v38);
    v33 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.f64[0], 0);
    v32.f64[0] = *((double *)this + 21) * *((double *)this + 21);
    v33.f64[0] = *((double *)this + 20) * *((double *)this + 20);
    v34 = vsqrtq_f64(vaddq_f64(v32, v33));
    if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v34, 1), v34)).u8[0] & 1) == 0)
    {
      v35 = vmulq_f64(v39, v39);
      v36 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v35.f64[0], 0);
      v35.f64[0] = a3[1] * a3[1];
      v36.f64[0] = *a3 * *a3;
      v37 = vsqrtq_f64(vaddq_f64(v35, v36));
      if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v37, 1), v37)).u8[0] & 1) == 0)
        return (*(uint64_t (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), (__n128)vaddq_f64(*a2, v39));
    }
    v27 = *((_QWORD *)this + 10);
    v28 = *(__n128 *)a2;
  }
  else
  {
    v17 = v38;
    v16 = v39;
    v18 = vmulq_f64(v17, v17);
    v19 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v18.f64[0], 0);
    v18.f64[0] = *((double *)this + 21) * *((double *)this + 21);
    v19.f64[0] = *((double *)this + 20) * *((double *)this + 20);
    v20 = vsqrtq_f64(vaddq_f64(v18, v19));
    if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v20, 1), v20)).u8[0] & 1) != 0
      || (v21 = vmulq_f64(v39, v39),
          v22 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v21.f64[0], 0),
          v21.f64[0] = a3[1] * a3[1],
          v22.f64[0] = *a3 * *a3,
          v23 = vsqrtq_f64(vaddq_f64(v21, v22)),
          (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v23, 1), v23)).u8[0] & 1) != 0))
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
      v17 = v38;
      v16 = v39;
    }
    v24 = *a2;
    v25 = *((_OWORD *)this + 10);
    *(float64x2_t *)&v42[0].v = vaddq_f64(*a2, v17);
    v43 = v25;
    v26 = *(_OWORD *)a3;
    v40 = vaddq_f64(v24, v16);
    v41 = v26;
    CG::intersection((double *)&v42[0].v, v40.f64, (uint64_t)v44);
    if (!v44[0])
      return (*(uint64_t (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), (__n128)vaddq_f64(*a2, v39));
    v27 = *((_QWORD *)this + 10);
    v28 = v45;
  }
  (*(void (**)(uint64_t, __n128))(*(_QWORD *)v27 + 24))(v27, v28);
  return (*(uint64_t (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), (__n128)vaddq_f64(*a2, v39));
}

uint64_t CG::stroker::add_round_join(CG::stroker *this, float64x2_t *a2, double *a3, double *a4)
{
  double v7;
  double v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  float64x2_t v22;
  float64x2_t v23;
  float64_t v25;
  double v32;
  __n128 v33;
  __n128 v34;
  __n128 v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  Point v46[4];

  v8 = *((double *)this + 22);
  v7 = *((double *)this + 23);
  v9 = *(float64x2_t *)((char *)this + 24);
  v10 = *(float64x2_t *)((char *)this + 8);
  v11 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, v7)), v9, v8);
  v12 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, a4[1])), v9, *a4);
  v13 = vsubq_f64(v11, v12);
  if (vaddvq_f64(vmulq_f64(v13, v13)) < 0.05)
    return CG::stroker::add_bevel_join((uint64_t)this, a2, a3, a4);
  *((float64x2_t *)this + 13) = vsubq_f64(*a2, v12);
  v15 = *a4;
  v16 = a4[1];
  v17 = *a4 + v8;
  v18 = v16 + v7;
  v19 = sqrt(v17 * v17 + v18 * v18);
  if (v19 >= 0.001)
  {
    v21 = 2.66666667 / v19;
    if (vabdd_f64(v7, v16) <= vabdd_f64(v8, v15))
      v20 = (1.33333333 - v21) * v18 / (v8 - v15);
    else
      v20 = (v21 + -1.33333333) * v17 / (v7 - v16);
  }
  else
  {
    v20 = -1.33333333;
  }
  v22 = vmlaq_n_f64(vmulq_n_f64(v10, -(v7 - v20 * v8)), v9, v8 + v20 * v7);
  v23 = vmlaq_n_f64(vnegq_f64(vmulq_n_f64(v10, v16 + v20 * v15)), v9, v15 - v20 * v16);
  v43 = v22;
  v44 = v12;
  v45 = v11;
  if (-(v15 * v7 - v16 * v8) >= 0.0 || v19 < 0.001)
  {
    *(float64x2_t *)&v46[0].v = vsubq_f64(*a2, v23);
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v46);
    *(float64x2_t *)&v46[0].v = vsubq_f64(*a2, v43);
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v46);
    *(float64x2_t *)&v46[0].v = vsubq_f64(*a2, v45);
    CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v46);
    v36 = vmulq_f64(v45, v45);
    v37 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v36.f64[0], 0);
    v36.f64[0] = *((double *)this + 21) * *((double *)this + 21);
    v37.f64[0] = *((double *)this + 20) * *((double *)this + 20);
    v38 = vsqrtq_f64(vaddq_f64(v36, v37));
    if ((vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v38, 1), v38)).u8[0] & 1) != 0
      || (v39 = vmulq_f64(v44, v44),
          v40 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v39.f64[0], 0),
          v39.f64[0] = a3[1] * a3[1],
          v40.f64[0] = *a3 * *a3,
          v41 = vsqrtq_f64(vaddq_f64(v39, v40)),
          (vmovn_s64(vcgtq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v41, 1), v41)).u8[0] & 1) != 0))
    {
      (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), *(__n128 *)a2);
    }
    return (*(uint64_t (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), (__n128)vaddq_f64(*a2, v44));
  }
  else
  {
    v42 = v23;
    _D8 = v11.f64[1];
    v25 = a2->f64[1] - v11.f64[1];
    *(double *)&v46[0].v = a2->f64[0] - v11.f64[0];
    *(float64_t *)&v46[2].v = v25;
    CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, v46);
    _V2.D[1] = v45.f64[1];
    __asm { FMLA            D1, D8, V2.D[1] }
    if (sqrt(*((double *)this + 20) * *((double *)this + 20) + *((double *)this + 21) * *((double *)this + 21)) < sqrt(_D1)
      || sqrt(*a3 * *a3 + a3[1] * a3[1]) < sqrt(vaddvq_f64(vmulq_f64(v44, v44))))
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)a2);
    }
    v32 = a2->f64[1];
    v33.n128_f64[0] = a2->f64[0] + v43.f64[0];
    v33.n128_f64[1] = v32 + v43.f64[1];
    v34.n128_f64[0] = a2->f64[0] + v42.f64[0];
    v34.n128_f64[1] = v32 + v42.f64[1];
    v35.n128_f64[0] = a2->f64[0] + v44.f64[0];
    v35.n128_f64[1] = v32 + v44.f64[1];
    return (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**((_QWORD **)this + 10) + 40))(*((_QWORD *)this + 10), v33, v34, v35);
  }
}

double CG::stroker::offset_normal(double *a1, CG::Cubic *this, double *a3, double a4)
{
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;

  v6 = CG::Cubic::derivative(this, a4);
  if (a3)
  {
    *a3 = v6;
    a3[1] = v7;
  }
  v8 = a1[1];
  v9 = a1[2];
  v11 = a1[3];
  v10 = a1[4];
  if (-(v11 * v9 - v10 * v8) >= 0.0)
  {
    v14 = -v9;
    v15 = -v11;
    v12 = a1[4];
    v13 = a1[1];
  }
  else
  {
    v12 = -v10;
    v13 = -v8;
    v14 = a1[2];
    v15 = a1[3];
  }
  v16 = v12 * v6 + v15 * v7;
  v17 = v14 * v6 + v13 * v7;
  v18 = -v17;
  if (v17 != 0.0 || v16 != 0.0)
  {
    v19 = sqrt(v16 * v16 + v17 * v17);
    v18 = v18 / v19;
    v16 = v16 / v19;
  }
  return v18 * v8 + v16 * v11;
}

void CG::stroker::path_stroke_round_cube_offset(CG::stroker *this, float64x2_t *a2, int a3, int a4)
{
  double v7;
  double v8;
  double v9;
  double v10;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  float64x2_t *v26;
  float64x2_t *v27;
  BOOL v28;
  int v29;
  uint64_t v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  double v37;
  BOOL v38;
  _BOOL4 v39;
  double v40;
  double v41;
  double v42;
  double v43;
  const CG::Cubic *v44;
  __n128 v45;
  __int128 v46;
  _BYTE v47[112];
  Point v48[2];
  double v49;
  float64x2_t v50;
  __int128 v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  Point v59[4];
  char v60[8];
  uint64_t v61;
  Point v62[4];
  char v63[8];
  uint64_t v64;
  float64x2_t v65;
  __int128 v66;
  Point v67[4];
  __int128 v68;
  Point v69[4];
  __int128 v70;

  v7 = a2[3].f64[0];
  v8 = a2[3].f64[1];
  v9 = a2->f64[0];
  v10 = a2->f64[1];
  if ((v7 - a2->f64[0]) * (v7 - a2->f64[0]) + (v8 - v10) * (v8 - v10) <= 0.00000001)
  {
    v45.n128_f64[0] = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, 1.0) + v7;
    v45.n128_f64[1] = v40 + v8;
    if (a4 < 0)
    {
      CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)&v45);
      v41 = a2->f64[0];
      v42 = a2->f64[1];
      *((double *)this + 26) = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, 0.0) + v41;
      *((double *)this + 27) = v43 + v42;
    }
    else
    {
      (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), v45);
    }
  }
  else
  {
    v70 = 0uLL;
    v12 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v70, 0.0) + v9;
    v14 = v13 + v10;
    *(double *)&v69[0].v = v12;
    *(double *)&v69[2].v = v13 + v10;
    v68 = 0uLL;
    v15 = a2[3].f64[0];
    v16 = a2[3].f64[1];
    v17 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v68, 1.0) + v15;
    v19 = v18 + v16;
    *(double *)&v67[0].v = v17;
    *(double *)&v67[2].v = v18 + v16;
    v66 = 0uLL;
    v20 = CG::Cubic::evaluate(a2, 0.5);
    v22 = v21;
    v23 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, (double *)&v66, 0.5) + v20;
    v25 = v24 + v22;
    v65.f64[0] = v23 + -(v12 + v17 - v23 * 2.0) * 0.166666667;
    v65.f64[1] = v24 + v22 + -(v14 + v19 - (v24 + v22) * 2.0) * 0.166666667;
    v45 = *(__n128 *)&v69[0].v;
    v46 = v70;
    v50 = v65;
    v51 = v66;
    CG::intersection(v45.n128_f64, v50.f64, (uint64_t)v63);
    if (v63[0])
      v26 = (float64x2_t *)&v64;
    else
      v26 = &v65;
    *(float64x2_t *)&v62[0].v = *v26;
    v45 = *(__n128 *)&v67[0].v;
    v46 = v68;
    v50 = v65;
    v51 = v66;
    CG::intersection(v45.n128_f64, v50.f64, (uint64_t)v60);
    if (v60[0])
      v27 = (float64x2_t *)&v61;
    else
      v27 = &v65;
    *(float64x2_t *)&v59[0].v = *v27;
    v28 = __OFSUB__(a3, 1);
    v29 = a3 - 1;
    if (v29 < 0 != v28)
    {
LABEL_32:
      if (a4 < 0)
      {
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v62);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v59);
        CG::stroker::push_opposite_element(this, kCGPathElementAddCurveToPoint, v67);
        *((_OWORD *)this + 13) = *(_OWORD *)&v69[0].v;
      }
      else
      {
        (*(void (**)(_QWORD, __n128, __n128, __n128))(**((_QWORD **)this + 10) + 40))(*((_QWORD *)this + 10), *(__n128 *)&v62[0].v, *(__n128 *)&v59[0].v, *(__n128 *)&v67[0].v);
      }
    }
    else
    {
      CG::Cubic::Cubic((CG::Cubic *)&v50, v69, v62, v59, v67);
      v30 = 0;
      while (1)
      {
        v31 = *(double *)&CG::stroker::path_stroke_round_cube_offset(CG::Cubic const&,int,int)::samples[v30];
        v32 = v25;
        v33 = v23;
        if (v30 * 8)
        {
          v34 = CG::Cubic::evaluate(a2, *(double *)&CG::stroker::path_stroke_round_cube_offset(CG::Cubic const&,int,int)::samples[v30]);
          v36 = v35;
          v33 = CG::stroker::offset_normal((double *)this, (CG::Cubic *)a2, 0, v31) + v34;
          v32 = v37 + v36;
        }
        *(double *)&v48[0].v = v33;
        v49 = v32;
        v38 = (*(_QWORD *)&v33 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000
           && (*(_QWORD *)&v32 & 0x7FFFFFFFFFFFFFFFuLL) < 0x7FF0000000000000;
        v39 = v38;
        if ((*(_QWORD *)&v50.f64[0] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*(_QWORD *)&v50.f64[1] & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && ((unint64_t)v51 & 0x7FFFFFFFFFFFFFFFLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (*((_QWORD *)&v51 + 1) & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v52 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v53 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v54 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v55 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v56 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (v57 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && v39
          && (v58 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL
          && (CG::Cubic::is_near(&v50, v48, v31, *((double *)this + 9)) & 1) == 0)
        {
          break;
        }
        if (++v30 == 5)
          goto LABEL_32;
      }
      CG::Cubic::split(a2, 0.5, (float64x2_t *)&v45);
      if (a4 < 0)
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)v47, v29, a4);
        v44 = (const CG::Cubic *)&v45;
      }
      else
      {
        CG::stroker::path_stroke_round_cube_offset(this, (const CG::Cubic *)&v45, v29, a4);
        v44 = (const CG::Cubic *)v47;
      }
      CG::stroker::path_stroke_round_cube_offset(this, v44, v29, a4);
    }
  }
}

double CG::stroker::path_stroke_round_cube_chord(CG::stroker *this, const CG::Cubic *a2)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  __n128 v12;
  double result;
  double v14[2];

  v4 = *(double *)a2;
  v5 = *((double *)a2 + 1);
  v14[0] = v4 - CG::stroker::offset_normal((double *)this, a2, 0, 0.0);
  v14[1] = v5 - v6;
  CG::stroker::push_opposite_element(this, kCGPathElementAddLineToPoint, (const Point *)v14);
  v7 = *((double *)a2 + 6);
  v8 = *((double *)a2 + 7);
  v9 = CG::stroker::offset_normal((double *)this, a2, 0, 1.0);
  v11 = v10;
  v12.n128_f64[0] = v9 + v7;
  v12.n128_f64[1] = v10 + v8;
  (*(void (**)(_QWORD, __n128))(**((_QWORD **)this + 10) + 24))(*((_QWORD *)this + 10), v12);
  result = v7 - v9;
  *((double *)this + 26) = v7 - v9;
  *((double *)this + 27) = v8 - v11;
  return result;
}

void CG::stroker::path_stroke_round_cube(CG::stroker *this, float64x2_t *a2)
{
  const Point *v4;
  double v5;
  double v6;
  const Point *v7;
  double v8;
  double v9;
  const Point *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  float64x2_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23[14];

  v4 = (const Point *)&a2[1];
  v5 = a2[1].f64[0];
  v6 = a2[1].f64[1];
  v7 = (const Point *)&a2[2];
  v8 = a2[2].f64[0];
  v9 = a2[2].f64[1];
  v10 = (const Point *)&a2[3];
  v11 = v5 - a2->f64[0];
  v12 = v6 - a2->f64[1];
  v13 = v8 - v5;
  v14 = v9 - v6;
  v15 = a2[3].f64[0] - v8;
  if (v13 * v11 + (v9 - v6) * v12 >= 0.0 && v15 * v13 + (a2[3].f64[1] - v9) * v14 >= 0.0)
  {
    CG::stroker::path_stroke_round_cube_offset(this, a2, 4, 1);
    CG::Cubic::Cubic((CG::Cubic *)&v16, v10, v7, v4, (const Point *)a2);
    CG::stroker::path_stroke_round_cube_offset(this, &v16, 4, -1);
  }
  else if (v11 * v11 + v12 * v12 <= 0.00000001
         && v13 * v13 + v14 * v14 <= 0.00000001
         && v15 * v15 + (a2[3].f64[1] - v9) * (a2[3].f64[1] - v9) <= 0.00000001)
  {
    CG::stroker::path_stroke_round_cube_chord(this, (const CG::Cubic *)a2);
  }
  else
  {
    CG::Cubic::split(a2, 0.5, &v16);
    if (a2->f64[0] != v16.f64[0]
      || a2->f64[1] != v16.f64[1]
      || *(double *)&v4->v != v17
      || a2[1].f64[1] != v18
      || *(double *)&v7->v != v19
      || a2[2].f64[1] != v20
      || *(double *)&v10->v != v21
      || a2[3].f64[1] != v22)
    {
      CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)&v16);
      if (a2->f64[0] != v23[0]
        || a2->f64[1] != v23[1]
        || *(double *)&v4->v != v23[2]
        || a2[1].f64[1] != v23[3]
        || *(double *)&v7->v != v23[4]
        || a2[2].f64[1] != v23[5]
        || *(double *)&v10->v != v23[6]
        || a2[3].f64[1] != v23[7])
      {
        CG::stroker::path_stroke_round_cube(this, (const CG::Cubic *)v23);
      }
    }
  }
}

int8x16_t RB::Fill::Gradient::concat(RB::Fill::Gradient *this, float64x2_t *a2, RB::Heap *a3)
{
  int8x16_t result;
  float64x2_t *v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  unint64_t v9;
  float64x2_t v10;
  const RB::AffineTransform *v11;

  result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a2[2]));
  result.i64[0] = vandq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)result, 1), result).u64[0];
  if ((result.i64[0] & 0x8000000000000000) == 0)
  {
    v5 = (float64x2_t *)*((_QWORD *)this + 2);
    if (v5)
    {
      *(double *)result.i64 = RB::operator*(a2, v5);
      v6 = *((_QWORD *)this + 2);
      *(int8x16_t *)v6 = result;
      *(_OWORD *)(v6 + 16) = v7;
      *(_OWORD *)(v6 + 32) = v8;
    }
    else
    {
      v9 = (*((_QWORD *)a3 + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
      if (v9 + 48 > *((_QWORD *)a3 + 3))
      {
        v11 = (const RB::AffineTransform *)a2;
        v9 = RB::Heap::alloc_slow((size_t *)a3, 0x30uLL, 15);
        a2 = (float64x2_t *)v11;
      }
      else
      {
        *((_QWORD *)a3 + 2) = v9 + 48;
      }
      result = *(int8x16_t *)a2;
      v10 = a2[2];
      *(float64x2_t *)(v9 + 16) = a2[1];
      *(float64x2_t *)(v9 + 32) = v10;
      *(int8x16_t *)v9 = result;
      *((_QWORD *)this + 2) = v9;
    }
  }
  return result;
}

void RB::Fill::Gradient::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  int v6;
  uint64_t v8;
  unint64_t v9;
  uint16x4_t v10;
  __int16 v11;
  BOOL v18;
  uint16x4_t v19;
  __int16 v20;

  v6 = HIBYTE(a4);
  *(_BYTE *)(a1 + 55) = 1;
  if (*(_QWORD *)a1)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = *(uint16x4_t *)(*(_QWORD *)(a1 + 8) + v8);
      v11 = *(_WORD *)(a1 + 53);
      v19 = v10;
      v20 = v11;
      if (v6)
        RB::Fill::Color::convert((uint64_t)&v19, a4, v10);
      RB::operator*=((uint64_t)&v19, a2);
      *(uint16x4_t *)(*(_QWORD *)(a1 + 8) + v8) = v19;
      _H0 = v19.i16[3];
      __asm { FCVT            S0, H0 }
      v18 = _S0 == 1.0 && *(_BYTE *)(a1 + 55) != 0;
      *(_BYTE *)(a1 + 55) = v18;
      ++v9;
      v8 += 16;
    }
    while (v9 < *(_QWORD *)a1);
  }
  if (v6)
    *(_WORD *)(a1 + 53) = a4;
}

uint64_t RB::Fill::Gradient::can_mix(RB::Fill::Gradient *this, const RB::Fill::Gradient *a2, const RB::AffineTransform *a3)
{
  uint64_t result;
  uint64_t v6;
  uint32x2_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  if (*((unsigned __int8 *)this + 52) != *((unsigned __int8 *)a2 + 52)
    || ((*((_DWORD *)a2 + 12) ^ *((_DWORD *)this + 12)) & 0x3C7) != 0)
  {
    return 0;
  }
  result = RB::can_mix(*((float64x2_t **)this + 2), *((float64x2_t **)a2 + 2), a3);
  if (result >= 4u)
  {
    v6 = *(_QWORD *)this;
    if (*(_QWORD *)this != *(_QWORD *)a2)
    {
      if (((*((_DWORD *)a2 + 12) | *((_DWORD *)this + 12)) & 0x300) != 0)
        return 0;
      return 2;
    }
    v7 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)((char *)this + 32), *(float32x2_t *)((char *)a2 + 32)), (int8x8_t)vceq_f32(*(float32x2_t *)((char *)this + 24), *(float32x2_t *)((char *)a2 + 24)));
    if ((vpmin_u32(v7, v7).u32[0] & 0x80000000) != 0 && *((float *)this + 10) == *((float *)a2 + 10))
    {
      v8 = *((float *)this + 11) == *((float *)a2 + 11);
      if (!v6)
        goto LABEL_21;
    }
    else
    {
      v8 = 0;
      if (!v6)
        goto LABEL_21;
    }
    v9 = 0;
    v10 = *((_QWORD *)a2 + 1);
    do
    {
      v8 = v8
        && (v11 = *((_QWORD *)this + 1),
            (vminv_u16((uint16x4_t)vmovn_s32(vceqq_f32(vcvtq_f32_f16(*(float16x4_t *)(v11 + v9)), vcvtq_f32_f16(*(float16x4_t *)(v10 + v9))))) & 0x8000) != 0)&& (v12 = v11 + v9, *(float *)(v12 + 8) == *(float *)(v10 + v9 + 8))&& *(_DWORD *)(v12 + 12) == *(_DWORD *)(v10 + v9 + 12);
      v9 += 16;
      --v6;
    }
    while (v6);
LABEL_21:
    if (v8)
      return 4;
    return 2;
  }
  return result;
}

void RB::Fill::Gradient::mix(RB::Fill::Gradient *this, const RB::DisplayList::Interpolator::Op *a2, const RB::Fill::Gradient *a3, int8x16_t a4, RB::Heap *a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  if ((*(_QWORD *)a2 & 0xELL) == 2)
    RB::Fill::Gradient::mix(this, a3, a4, a5, a6, a7, a8, a9, a10);
}

void RB::Fill::Gradient::mix(RB::Fill::Gradient *this, const RB::Fill::Gradient *a2, int8x16_t a3, RB::Heap *a4, int8x16_t a5, double a6, double a7, double a8, int8x16_t a9)
{
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  __int128 v16;
  CGAffineTransform *v17;
  float64x2_t *v18;
  uint64_t v19;
  unsigned int v20;
  float32x2_t v21;
  unint64_t v22;
  int v23;
  uint64_t v24;
  unint64_t v25;
  float32x2_t v26;
  float32x2_t v27;
  int8x8_t v28;
  float32x2_t v33;
  uint64_t v34;
  uint64_t v35;
  __int16 v36;
  __int16 v37;
  BOOL v41;
  float v42;
  uint32x2_t v43;
  float32x2_t v44;
  uint32x2_t v45;
  int32x2_t v46;
  uint32x2_t v47;
  float32x2_t v48;
  int32x2_t v49;
  float v50;
  float v51;
  int v52;
  float32x2_t v53;
  float32x2_t v54;
  uint32x2_t v55;
  float v56;
  int v57;
  float32x2_t v58;
  unint64_t v59;
  unint64_t v60;
  unsigned int v61;
  BOOL v62;
  BOOL v63;
  char v64;
  float v65;
  float v66;
  __int16 v67;
  __int16 v68;
  __int16 v69;
  uint64_t v70;
  uint64_t v71;
  __int16 v72;
  double v73;
  float32x2_t v74;
  uint64_t v75;
  uint64_t v76;
  __int16 v77;
  double v78;
  float32x2_t v79;
  float16x4_t v80;
  float16x4_t v81;
  __int16 v82;
  float16x4_t v83;
  uint64_t v84;
  float16x4_t *p_dst;
  float16x4_t *v86;
  unint64_t v89;
  unint64_t v90;
  void *v91;
  float16x4_t *v92;
  int8x16_t v93;
  float16x4_t v94;
  __int16 v95;
  float16x4_t v96;
  __int16 v97;
  float16x4_t v98;
  __int16 v99;
  float16x4_t v100;
  __int16 v101;
  float16x4_t __dst;
  __int16 v103;
  void *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;

  v107 = *MEMORY[0x24BDAC8D0];
  v12 = *(float32x2_t *)((char *)this + 24);
  v13 = *(float32x2_t *)((char *)this + 32);
  v14 = vsub_f32(*(float32x2_t *)((char *)a2 + 24), v12);
  *((float32x2_t *)this + 3) = vmla_n_f32(v12, v14, *(float *)a3.i32);
  *((float32x2_t *)this + 4) = vmla_n_f32(v13, vsub_f32(*(float32x2_t *)((char *)a2 + 32), v13), *(float *)a3.i32);
  v15 = *(float32x2_t *)((char *)this + 40);
  *(float32x2_t *)a5.i8 = vsub_f32(*(float32x2_t *)((char *)a2 + 40), v15);
  v93 = a3;
  *(float32x2_t *)&v16 = vmla_n_f32(v15, *(float32x2_t *)a5.i8, *(float *)a3.i32);
  *((_QWORD *)this + 5) = v16;
  v17 = (CGAffineTransform *)*((_QWORD *)this + 2);
  if (v17)
  {
    v18 = (float64x2_t *)*((_QWORD *)a2 + 2);
    if (v18)
    {
      RB::mix(v17, v18, a4, *(float *)a3.i32);
      v19 = *((_QWORD *)this + 2);
      *(int8x16_t *)v19 = a3;
      *(int8x16_t *)(v19 + 16) = a5;
      *(_OWORD *)(v19 + 32) = v16;
    }
  }
  v20 = *((_DWORD *)this + 12);
  v21 = *(float32x2_t *)this;
  v22 = *(_QWORD *)a2;
  if (*(_QWORD *)this == *(_QWORD *)a2)
  {
    v23 = *((_DWORD *)a2 + 12) | v20;
    *((_BYTE *)this + 55) = 1;
    if (v21)
    {
      v24 = 0;
      v25 = 0;
      v26 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v93.i8, 0);
      v27 = (float32x2_t)vdup_n_s32(0x3B808081u);
      v28 = (int8x8_t)vdup_n_s32(0x437F8000u);
      __asm { FMOV            V11.2S, #1.0 }
      v33 = (float32x2_t)vdup_n_s32(0x437F0000u);
      do
      {
        v34 = *((_QWORD *)this + 1);
        v35 = *((_QWORD *)a2 + 1);
        v36 = *(_WORD *)((char *)this + 53);
        __dst = *(float16x4_t *)(v34 + v24);
        v103 = v36;
        v37 = *(_WORD *)((char *)a2 + 53);
        v100 = *(float16x4_t *)(v35 + v24);
        v101 = v37;
        RB::Fill::Color::mix(&__dst, &v100, 0, v93, a5, *(double *)&v16, *(double *)&v14, a8, a9);
        *(float16x4_t *)(v34 + v24) = __dst;
        _H0 = __dst.i16[3];
        __asm { FCVT            S0, H0 }
        v41 = _S0 == 1.0 && *((_BYTE *)this + 55) != 0;
        *((_BYTE *)this + 55) = v41;
        if ((v23 & 0x10000) != 0)
        {
          v42 = *(float *)(v34 + v24 + 8);
          *(float *)a5.i32 = *(float *)(v35 + v24 + 8) - v42;
          *(_QWORD *)&v16 = v93.i64[0];
          *(float *)(v34 + v24 + 8) = v42 + (float)(*(float *)a5.i32 * *(float *)v93.i32);
        }
        if ((v23 & 0x100) != 0)
        {
          v56 = *(float *)(v34 + v24 + 12);
          *(float *)a5.i32 = *(float *)(v35 + v24 + 12) - v56;
          *(_QWORD *)&v16 = v93.i64[0];
          *(float *)(v34 + v24 + 12) = v56 + (float)(*(float *)a5.i32 * *(float *)v93.i32);
        }
        else if ((v23 & 0x200) != 0)
        {
          v43.i32[0] = *(unsigned __int8 *)(v34 + v24 + 12);
          v43.i32[1] = *(unsigned __int8 *)(v34 + v24 + 13);
          v44 = vmul_f32(vcvt_f32_u32(v43), v27);
          v45.i32[0] = *(unsigned __int8 *)(v35 + v24 + 12);
          v45.i32[1] = *(unsigned __int8 *)(v35 + v24 + 13);
          v46 = (int32x2_t)vmla_f32(v44, v26, vmla_f32(vneg_f32(v44), v27, vcvt_f32_u32(v45)));
          v45.i32[0] = *(unsigned __int8 *)(v34 + v24 + 14);
          v45.i32[1] = *(unsigned __int8 *)(v34 + v24 + 15);
          v47.i32[0] = *(unsigned __int8 *)(v35 + v24 + 14);
          v47.i32[1] = *(unsigned __int8 *)(v35 + v24 + 15);
          v48 = vmul_f32(vcvt_f32_u32(v45), v27);
          *(float32x2_t *)&v16 = vcvt_f32_u32(v47);
          v49 = (int32x2_t)vmla_f32(v48, v26, vmla_f32(vneg_f32(v48), v27, *(float32x2_t *)&v16));
          a9.i32[0] = 0;
          if (*(float *)v46.i32 >= 0.0)
            v50 = *(float *)v46.i32;
          else
            v50 = 0.0;
          if (v50 <= 1.0)
            *(float *)&v16 = (float)(v50 * 255.0) + 0.5;
          else
            *(float *)&v16 = 255.5;
          if (*(float *)v49.i32 >= 0.0)
            *(float *)&a8 = *(float *)v49.i32;
          else
            *(float *)&a8 = 0.0;
          v51 = (float)(*(float *)&a8 * 255.0) + 0.5;
          if (*(float *)&a8 > 1.0)
            v51 = 255.5;
          v52 = (int)v51;
          v53 = (float32x2_t)vzip2_s32(v49, v46);
          v54 = (float32x2_t)vbic_s8((int8x8_t)v53, (int8x8_t)vcltz_f32(v53));
          *(int32x2_t *)a5.i8 = vcgt_f32(v54, _D11);
          v14 = vmla_f32((float32x2_t)0x3F0000003F000000, v33, v54);
          v55 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8(*(int8x8_t *)a5.i8, v28, (int8x8_t)v14)), (uint32x2_t)0x800000018);
          *(_DWORD *)(v34 + v24 + 12) = v55.i32[0] | (v52 << 16) | (int)*(float *)&v16 | v55.i32[1];
        }
        ++v25;
        v24 += 16;
      }
      while (v25 < *(_QWORD *)this);
    }
    if ((v23 & 0x10000) != 0)
      *((_DWORD *)this + 12) |= 0x10000u;
    if ((v23 & 0x100) != 0)
    {
      v57 = *((_DWORD *)this + 12) | 0x100;
    }
    else
    {
      if ((v23 & 0x200) == 0)
        return;
      v57 = *((_DWORD *)this + 12) | 0x200;
    }
    *((_DWORD *)this + 12) = v57;
    return;
  }
  v104 = 0;
  v105 = 0;
  v106 = 16;
  v58 = (float32x2_t)(*(_QWORD *)&v21 | v22);
  if (!(*(_QWORD *)&v21 | v22))
  {
    v64 = 1;
    goto LABEL_75;
  }
  v59 = 0;
  v60 = 0;
  v61 = 0x3010200u >> ((v20 >> 3) & 0x18);
  v62 = v22 != 0;
  v63 = *(_QWORD *)&v21 != 0;
  v64 = 1;
  do
  {
    if (v63)
    {
      v65 = *(float *)(*((_QWORD *)this + 1) + 16 * v60 + 8);
      if (!v62)
        goto LABEL_40;
    }
    else
    {
      v65 = INFINITY;
      if (!v62)
      {
LABEL_40:
        v66 = INFINITY;
        goto LABEL_43;
      }
    }
    v66 = *(float *)(*((_QWORD *)a2 + 1) + 16 * v59 + 8);
LABEL_43:
    v96 = (float16x4_t)0x3C00000000000000;
    v97 = 0;
    v94 = (float16x4_t)0x3C00000000000000;
    v95 = 0;
    if (v65 == v66)
    {
      v67 = *(_WORD *)((char *)this + 53);
      v96 = *(float16x4_t *)(*((_QWORD *)this + 1) + 16 * v60);
      v97 = v67;
      v68 = *(_WORD *)((char *)a2 + 53);
      v94 = *(float16x4_t *)(*((_QWORD *)a2 + 1) + 16 * v59);
      v95 = v68;
      ++v60;
      ++v59;
      goto LABEL_62;
    }
    if (v65 < v66)
    {
      v69 = *(_WORD *)((char *)this + 53);
      v96 = *(float16x4_t *)(*((_QWORD *)this + 1) + 16 * v60);
      v97 = v69;
      if (v59)
      {
        v70 = *((_QWORD *)a2 + 1);
        if (*(_QWORD *)a2 > v59)
        {
          v71 = v70 + 16 * v59;
          a3.i32[0] = *(_DWORD *)(v71 - 8);
          a5.i32[0] = *(_DWORD *)(v71 + 8);
          *(_QWORD *)&v16 = *(_QWORD *)(v71 - 16);
          v72 = *(_WORD *)((char *)a2 + 53);
          v100 = (float16x4_t)v16;
          v101 = v72;
          if (*(float *)a3.i32 != *(float *)a5.i32)
          {
            v98 = *(float16x4_t *)(v70 + 16 * v59);
            HIDWORD(v73) = v98.i32[1];
            v99 = v72;
            *(float *)&v73 = v65 - *(float *)a3.i32;
            *(float *)a5.i32 = *(float *)a5.i32 - *(float *)a3.i32;
            *(float32x2_t *)a3.i8 = vrecpe_f32((float32x2_t)a5.u32[0]);
            v74 = vrecps_f32((float32x2_t)a5.u32[0], *(float32x2_t *)a3.i8);
            *(float32x2_t *)a3.i8 = vmul_f32(v74, *(float32x2_t *)a3.i8);
            *(float32x2_t *)a5.i8 = vrecps_f32((float32x2_t)a5.u32[0], *(float32x2_t *)a3.i8);
            *(float32x2_t *)a3.i8 = vmul_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)a5.i8);
            *(float *)a3.i32 = *(float *)&v73 * *(float *)a3.i32;
            RB::Fill::Color::mix(&v100, &v98, v61, a3, a5, v73, *(double *)&v74, a8, a9);
            v72 = v101;
          }
          goto LABEL_58;
        }
        v80 = *(float16x4_t *)(v70 + 16 * *(_QWORD *)a2 - 16);
      }
      else
      {
        v80 = **((float16x4_t **)a2 + 1);
      }
      v72 = *(_WORD *)((char *)a2 + 53);
      v100 = v80;
LABEL_58:
      v94 = v100;
      v95 = v72;
      ++v60;
      goto LABEL_62;
    }
    if (v60)
    {
      v75 = *((_QWORD *)this + 1);
      if (*(_QWORD *)this > v60)
      {
        v76 = v75 + 16 * v60;
        a3.i32[0] = *(_DWORD *)(v76 - 8);
        a5.i32[0] = *(_DWORD *)(v76 + 8);
        *(_QWORD *)&v16 = *(_QWORD *)(v76 - 16);
        v77 = *(_WORD *)((char *)this + 53);
        v100 = (float16x4_t)v16;
        v101 = v77;
        if (*(float *)a3.i32 != *(float *)a5.i32)
        {
          v98 = *(float16x4_t *)(v75 + 16 * v60);
          HIDWORD(v78) = v98.i32[1];
          v99 = v77;
          *(float *)&v78 = v66 - *(float *)a3.i32;
          *(float *)a5.i32 = *(float *)a5.i32 - *(float *)a3.i32;
          *(float32x2_t *)a3.i8 = vrecpe_f32((float32x2_t)a5.u32[0]);
          v79 = vrecps_f32((float32x2_t)a5.u32[0], *(float32x2_t *)a3.i8);
          *(float32x2_t *)a3.i8 = vmul_f32(v79, *(float32x2_t *)a3.i8);
          *(float32x2_t *)a5.i8 = vrecps_f32((float32x2_t)a5.u32[0], *(float32x2_t *)a3.i8);
          *(float32x2_t *)a3.i8 = vmul_f32(*(float32x2_t *)a3.i8, *(float32x2_t *)a5.i8);
          *(float *)a3.i32 = *(float *)&v78 * *(float *)a3.i32;
          RB::Fill::Color::mix(&v100, &v98, v61, a3, a5, v78, *(double *)&v79, a8, a9);
          v77 = v101;
        }
        goto LABEL_61;
      }
      v81 = *(float16x4_t *)(v75 + 16 * *(_QWORD *)this - 16);
    }
    else
    {
      v81 = **((float16x4_t **)this + 1);
    }
    v77 = *(_WORD *)((char *)this + 53);
    v100 = v81;
LABEL_61:
    v96 = v100;
    v97 = v77;
    v82 = *(_WORD *)((char *)a2 + 53);
    v94 = *(float16x4_t *)(*((_QWORD *)a2 + 1) + 16 * v59);
    v95 = v82;
    ++v59;
    v65 = v66;
LABEL_62:
    RB::Fill::Color::mix(&v96, &v94, 0, v93, a5, *(double *)&v16, *(double *)&v14, a8, a9);
    v83 = v96;
    v84 = v105;
    if (v106 < v105 + 1)
    {
      RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(&__dst, v105 + 1);
      v84 = v105;
    }
    p_dst = (float16x4_t *)v104;
    if (!v104)
      p_dst = &__dst;
    v86 = &p_dst[2 * v84];
    *v86 = v83;
    *(float *)v86[1].i32 = v65;
    v86[1].i32[1] = 0;
    v58 = (float32x2_t)++v105;
    _H0 = v96.i16[3];
    __asm { FCVT            S0, H0 }
    v64 &= _S0 == 1.0;
    v62 = v59 < v22;
    v63 = v60 < *(_QWORD *)&v21;
  }
  while (v60 < *(_QWORD *)&v21 || v59 < v22);
  if (*(_QWORD *)&v58 <= *(_QWORD *)this)
  {
LABEL_75:
    *(float32x2_t *)this = v58;
    goto LABEL_76;
  }
  *(float32x2_t *)this = v58;
  v89 = (*((_QWORD *)a4 + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  v90 = v89 + 16 * *(_QWORD *)&v58;
  if (v90 > *((_QWORD *)a4 + 3))
  {
    v89 = RB::Heap::alloc_slow((size_t *)a4, 16 * *(_QWORD *)&v58, 7);
    v58 = *(float32x2_t *)this;
  }
  else
  {
    *((_QWORD *)a4 + 2) = v90;
  }
  *((_QWORD *)this + 1) = v89;
LABEL_76:
  v91 = v104;
  if (v58)
  {
    if (v104)
      v92 = (float16x4_t *)v104;
    else
      v92 = &__dst;
    memmove(*((void **)this + 1), v92, 16 * *(_QWORD *)&v58);
    v91 = v104;
  }
  *((_DWORD *)this + 12) |= 0x10000u;
  *((_BYTE *)this + 55) = v64;
  if (v91)
    free(v91);
}

void sub_209B67614(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,void *a52)
{
  if (a52)
    free(a52);
  _Unwind_Resume(exception_object);
}

BOOL RB::Fill::Gradient::get_alpha(RB::Fill::Gradient *this, float *a2)
{
  unint64_t v2;
  BOOL v3;
  uint64_t v4;
  float v5;
  __int16 *v6;
  char v7;

  v2 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v3 = 0;
    v4 = 0;
    v5 = *a2;
    v6 = (__int16 *)(*((_QWORD *)this + 1) + 6);
    v7 = 1;
    do
    {
      _H1 = *v6;
      __asm { FCVT            S1, H1 }
      if ((v7 & 1) != 0)
      {
        *a2 = _S1;
        v5 = _S1;
      }
      else if (v5 != _S1)
      {
        return v3;
      }
      v7 = 0;
      v3 = ++v4 >= v2;
      v6 += 8;
    }
    while (v2 != v4);
  }
  else
  {
    return 1;
  }
  return v3;
}

float RB::Fill::Gradient::interpolation_factor(uint64_t a1, uint64_t a2, uint64_t a3, float a4, double a5, double a6, double a7, float a8)
{
  float v8;
  float v9;
  unsigned int v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float v15;
  float result;
  int v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  _DWORD v26[6];

  v8 = *(float *)(a2 + 8);
  v9 = a4 - v8;
  *(float *)&v10 = *(float *)(a3 + 8) - v8;
  v11 = vrecpe_f32((float32x2_t)v10);
  v12 = vrecps_f32((float32x2_t)v10, v11);
  v13 = vmul_f32(v12, v11);
  v14 = vrecps_f32((float32x2_t)v10, v13);
  v15 = vmul_f32(v13, v14).f32[0];
  result = v9 * v15;
  v17 = *(_DWORD *)(a1 + 48);
  if ((v17 & 0x100) != 0)
  {
    v23 = *(float *)(a2 + 12);
    if (v23 != 0.5)
    {
      v24 = fmaxf(result, 0.0);
      if (v23 >= 1.0)
        v25 = 65536.0;
      else
        v25 = -0.69315 / logf(*(float *)(a2 + 12));
      return powf(v24, v25);
    }
  }
  else if ((v17 & 0x200) != 0)
  {
    LOBYTE(v15) = *(_BYTE *)(a2 + 12);
    v18 = (float)LODWORD(v15);
    v14.i8[0] = *(_BYTE *)(a2 + 13);
    v19 = (float)v14.u32[0];
    v12.i8[0] = *(_BYTE *)(a2 + 14);
    LOBYTE(a8) = *(_BYTE *)(a2 + 15);
    v20 = v18 * 0.011765;
    v21 = (float)((float)v12.u32[0] - v18) * 0.011765;
    *(float *)v26 = v20;
    *(float *)&v26[1] = v21 - v20;
    *(float *)&v26[2] = 1.0 - v21;
    *(float *)&v26[3] = v19 * 0.011765;
    v22 = (float)((float)LODWORD(a8) - v19) * 0.011765;
    *(float *)&v26[4] = v22 - (float)(v19 * 0.011765);
    *(float *)&v26[5] = 1.0 - v22;
    return RB::BezierTiming::eval((RB::BezierTiming *)v26, result);
  }
  return result;
}

unint64_t RB::Fill::Gradient::sample(RB::Fill::Gradient *this, float a2, double a3, double a4, double a5, float a6)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int16 *v11;
  int8x16_t v12;
  float16x4_t *v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  float16x4_t v23;
  __int16 v24;
  float16x4_t v25;
  __int16 v26;

  v6 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    v8 = 0;
    v9 = v6 - 1;
    v10 = *((_QWORD *)this + 1);
    while (--v6)
    {
      v11 = (unsigned __int16 *)(v10 + v8);
      if (*(float *)(v10 + v8 + 8) >= a2)
        goto LABEL_9;
      v8 += 16;
      LODWORD(a3) = *((_DWORD *)v11 + 6);
      if (*(float *)&a3 > a2)
      {
        *(float *)v12.i32 = RB::Fill::Gradient::interpolation_factor((uint64_t)this, v10 + v8 - 16, v10 + v8, a2, a3, a4, a5, a6);
        v13 = (float16x4_t *)(*((_QWORD *)this + 1) + v8);
        v25 = v13[-2];
        v26 = 0;
        v23 = *v13;
        *(float16x4_t *)v14.i8 = v23;
        v24 = 0;
        RB::Fill::Color::mix(&v25, &v23, (0x3010200u >> ((*((_DWORD *)this + 12) >> 3) & 0x18)) & 3, v12, v14, v15, v16, v17, v18);
        LODWORD(v6) = v25.u16[0];
        v19 = v25.u16[1];
        v20 = v25.u16[2];
        v21 = v25.u16[3];
        return (v20 << 32) | (v21 << 48) | ((unint64_t)v19 << 16) | v6;
      }
    }
    v11 = (unsigned __int16 *)(v10 + 16 * v9);
LABEL_9:
    LODWORD(v6) = *v11;
    v19 = v11[1];
    v20 = v11[2];
    v21 = v11[3];
  }
  else
  {
    v19 = 0;
    v20 = 0;
    v21 = 0;
  }
  return (v20 << 32) | (v21 << 48) | ((unint64_t)v19 << 16) | v6;
}

float RB::Fill::Gradient::sample_alpha(RB::Fill::Gradient *this, float a2, double a3, double a4, double a5, float a6)
{
  uint64_t v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  float result;

  v6 = *(_QWORD *)this;
  if (!*(_QWORD *)this)
    return 0.0;
  v8 = 0;
  v9 = v6 - 1;
  v10 = *((_QWORD *)this + 1);
  while (1)
  {
    if (!--v6)
    {
      _H0 = *(_WORD *)(v10 + 16 * v9 + 6);
      goto LABEL_10;
    }
    v11 = v10 + v8;
    if (*(float *)(v10 + v8 + 8) >= a2)
      break;
    v8 += 16;
    LODWORD(a3) = *(_DWORD *)(v11 + 24);
    if (*(float *)&a3 > a2)
    {
      v12 = RB::Fill::Gradient::interpolation_factor((uint64_t)this, v10 + v8 - 16, v10 + v8, a2, a3, a4, a5, a6);
      v13 = *((_QWORD *)this + 1) + v8;
      _H1 = *(_WORD *)(v13 - 10);
      _H2 = *(_WORD *)(v13 + 6);
      __asm
      {
        FCVT            S1, H1
        FCVT            S2, H2
      }
      return _S1 + (float)((float)(_S2 - _S1) * v12);
    }
  }
  _H0 = *(_WORD *)(v11 + 6);
LABEL_10:
  __asm { FCVT            S0, H0 }
  return result;
}

uint64_t RB::Fill::`anonymous namespace'::count_subdivided_cubic_stops(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  unsigned __int8 *v4;
  float32x2_t v5;
  uint32x2_t v11;
  uint32x2_t v12;
  uint32x2_t v13;

  v2 = result - 1;
  if (result != 1)
  {
    v3 = 0;
    v4 = (unsigned __int8 *)(a2 + 14);
    v5 = (float32x2_t)vdup_n_s32(0x3B808081u);
    __asm { FMOV            V1.2S, #1.0 }
    do
    {
      v11.i32[0] = *(v4 - 2);
      v11.i32[1] = *(v4 - 1);
      v12.i32[0] = *v4;
      v12.i32[1] = v4[1];
      v13 = (uint32x2_t)vorn_s8(vmvn_s8((int8x8_t)vceq_f32(vmul_f32(vcvt_f32_u32(v12), v5), _D1)), (int8x8_t)vceqz_f32(vmul_f32(vcvt_f32_u32(v11), v5)));
      if (vpmax_u32(v13, v13).i32[0] >= 0)
        ++v3;
      else
        v3 += 4;
      v4 += 16;
      --v2;
    }
    while (v2);
    return v3 + 1;
  }
  return result;
}

void RB::Fill::`anonymous namespace'::subdivide_cubic_stops(uint64_t a1, uint64_t a2, uint64_t a3, __int16 a4, int a5)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  float32x2_t v11;
  float16x4_t *v17;
  uint32x2_t v18;
  float32x2_t v19;
  uint32x2_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint16x4_t v25;
  int8x16_t v26;
  int8x16_t v27;
  __int128 v28;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  uint64_t v32;
  float v33;
  float v34;
  float v35;
  uint64_t v36;
  float v37;
  uint64_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  float v43;
  float32x2_t v44;
  float32x2_t v45;
  __int16 v46;
  __int128 v48;
  __int128 v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  float16x4_t v53;
  __int16 v54;
  uint16x4_t v55;
  __int16 v56;
  float16x4_t v57;
  __int16 v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  float32x2_t v62;

  if (a1)
  {
    v8 = 0;
    v9 = 0;
    v10 = a1 - 1;
    v46 = a4 | 0x100;
    v11 = (float32x2_t)vdup_n_s32(0x3B808081u);
    __asm { FMOV            V8.2S, #1.0 }
    do
    {
      v17 = (float16x4_t *)(a2 + 16 * v8);
      if (v8 < v10
        && (v18.i32[0] = v17[1].u8[4],
            v18.i32[1] = v17[1].u8[5],
            v19 = vmul_f32(vcvt_f32_u32(v18), v11),
            v18.i32[0] = v17[1].u8[6],
            v18.i32[1] = v17[1].u8[7],
            v20 = (uint32x2_t)vorn_s8(vmvn_s8((int8x8_t)vceq_f32(vmul_f32(vcvt_f32_u32(v18), v11), _D8)), (int8x8_t)vceqz_f32(v19)), (vpmax_u32(v20, v20).u32[0] & 0x80000000) != 0))
      {
        _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v59, 8);
        v57 = *v17;
        v58 = v46;
        v23 = v8 + 1;
        v24 = a2 + 16 * (v8 + 1);
        v55 = *(uint16x4_t *)v24;
        v56 = v46;
        RB::Fill::Color::convert((uint64_t)&v57, a5, v55);
        RB::Fill::Color::convert((uint64_t)&v55, a5, v25);
        v32 = 0;
        v33 = *(float *)(a2 + 16 * v8 + 8);
        v34 = *(float *)(v24 + 8) - v33;
        v35 = vmlas_n_f32(v33, v34, v59.f32[0]);
        v22 = v9 + 4;
        v36 = a3 + 16 * v9;
        do
        {
          *(float32x2_t *)v29.i8 = v59;
          *(float32x2_t *)&v28 = v60;
          *(float32x2_t *)v30.i8 = vadd_f32(v60, v59);
          v52 = v30;
          *(float32x2_t *)v27.i8 = v62;
          v49 = v28;
          v50 = v29;
          *(float32x2_t *)&v28 = vadd_f32(v61, v60);
          *(float32x2_t *)v26.i8 = vadd_f32(v62, v61);
          *(float32x2_t *)v30.i8 = vadd_f32(*(float32x2_t *)&v28, *(float32x2_t *)v30.i8);
          v51 = v30;
          v48 = v28;
          v59 = *(float32x2_t *)v30.i8;
          v60 = vadd_f32(*(float32x2_t *)v26.i8, *(float32x2_t *)&v28);
          *(float32x2_t *)v26.i8 = vadd_f32(*(float32x2_t *)v26.i8, v62);
          v61 = *(float32x2_t *)v26.i8;
          v53 = v57;
          v54 = v58;
          v37 = *(float *)&v29.i32[1];
          v26.i32[0] = v29.i32[1];
          RB::Fill::Color::mix(&v53, (float16x4_t *)&v55, 0, v26, v27, *(double *)&v60, *(double *)v29.i64, *(double *)v30.i64, v31);
          v30.i64[1] = v51.i64[1];
          v31 = v52;
          v38 = v36 + v32;
          *(float16x4_t *)v38 = v53;
          *(float *)(v38 + 8) = v35;
          *(float *)v26.i32 = (float)(*(float *)&v51.i32[1] - v37) * 0.5;
          if ((float)(*(float *)v26.i32 + v37) >= *(float *)&v52.i32[1])
          {
            v41 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v51.i32[1] - *(float *)&v52.i32[1]));
            v42 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v51.i32[1] - *(float *)&v52.i32[1]), v41), v41);
            *((_QWORD *)&v28 + 1) = *((_QWORD *)&v48 + 1);
            *(float *)v31.i32 = vmlas_n_f32(*(float *)v52.i32, (float)((float)(*(float *)v26.i32 + v37) - *(float *)&v52.i32[1]) * *(float *)&v48, vmul_f32(v42, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v51.i32[1] - *(float *)&v52.i32[1]), v42)).f32[0]);
          }
          else
          {
            v39 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v52.i32[1] - v37));
            v40 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v52.i32[1] - v37), v39), v39);
            *((_QWORD *)&v28 + 1) = *((_QWORD *)&v49 + 1);
            v31 = v50;
            *(float *)v31.i32 = vmlas_n_f32(*(float *)v50.i32, *(float *)v26.i32 * *(float *)&v49, vmul_f32(v40, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(*(float *)&v52.i32[1] - v37), v40)).f32[0]);
          }
          v43 = v33 + (float)(*(float *)v51.i32 * v34);
          v44 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v35));
          v45 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v35), v44), v44);
          *(float *)(v36 + v32 + 12) = (float)((float)(v33 - v35) + (float)(*(float *)v31.i32 * v34))
                                     * vmul_f32(v45, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v43 - v35), v45)).f32[0];
          v32 += 16;
          v35 = v43;
        }
        while (v32 != 64);
      }
      else
      {
        v21 = a3 + 16 * v9;
        *(_OWORD *)v21 = *(_OWORD *)v17->i8;
        *(_DWORD *)(v21 + 12) = 1056964608;
        v22 = v9 + 1;
        v23 = v8 + 1;
      }
      v8 = v23;
      v9 = v22;
    }
    while (v23 != a1);
  }
}

float RB::Fill::Gradient::angular_location_function(RB::Fill::Gradient *this)
{
  float v1;
  float v2;
  double v3;
  double v4;
  float v5;
  double v6;
  float v7;
  BOOL v8;
  float v9;
  float v10;

  v2 = *((float *)this + 10);
  v1 = *((float *)this + 11);
  v3 = vabds_f32(v1, v2);
  if (v3 <= 6.28318531)
  {
    v6 = v3 * 0.0795774715;
    v4 = 0.5 - v6;
    v5 = v6 + 0.5;
  }
  else
  {
    v4 = v3 * -0.159154943 + 1.0;
    v5 = 1.0;
  }
  v7 = v4;
  v8 = v2 <= v1;
  if (v2 <= v1)
    v9 = v7;
  else
    v9 = 1.0 - v7;
  if (v8)
    v10 = v5;
  else
    v10 = 1.0 - v5;
  return v10 - v9;
}

float32x2_t *RB::Fill::Gradient::set_fill_state(float32x2_t *result, int *a2, uint64_t a3, float a4)
{
  unsigned __int32 v4;
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint32x2_t v10;
  unint64_t v11;
  int v12;
  int v15;
  int v16;
  __int16 v17;
  uint32x2_t v18;
  __int16 v19;

  v4 = result[6].u32[0];
  if ((v4 & 7) >= 3)
    v5 = 3;
  else
    v5 = v4 & 7;
  v6 = HIWORD(v4) & 1;
  v7 = result[6].u8[4];
  if (v7 == 4)
  {
    v6 = 1;
    v8 = 2;
  }
  else
  {
    v8 = result[6].u8[4];
  }
  v9 = v5 | (4 * v8);
  if ((_DWORD)v8 == 1)
  {
    v10 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(result[3], result[4]));
    if (vpmax_u32(v10, v10).i32[0] < 0)
      v9 += 12;
  }
  v11 = (unint64_t)*result;
  if (v6)
    v12 = 256;
  else
    v12 = 384;
  if (v11 < 7)
    v12 = 128;
  if ((v4 & 0x10200) == 0 && v11 == 2 && v7 != 4)
    v12 = 0;
  v15 = (2 * v4) & 0x200 | (8 * (dword_209BD7394[v9] & 0xF)) | v12;
  v16 = result[6].i32[0] & 0xC0;
  if (v16 == 64)
    goto LABEL_28;
  if (v16 == 192)
  {
    LOWORD(v15) = v15 | 4;
LABEL_28:
    v17 = *(_BYTE *)(a3 + 124) & 1;
    goto LABEL_29;
  }
  if (v16 != 128)
    goto LABEL_30;
  v17 = (*(_BYTE *)(a3 + 124) & 1) == 0;
LABEL_29:
  LOWORD(v15) = v15 | v17;
LABEL_30:
  if ((v15 & 1) != 0)
  {
    if (a4 == 1.0
      && result[6].i8[7]
      && (v7 != 1 || (v18 = (uint32x2_t)vceq_f32(result[3], result[4]), (vpmin_u32(v18, v18).u32[0] & 0x80000000) != 0)))
    {
      v19 = 2;
    }
    else
    {
      v19 = 0;
    }
    LOWORD(v15) = v19 | v15 & 0xFFFD;
  }
  *a2 = *a2 & 0x3FFFFF | ((unsigned __int16)v15 << 22);
  return result;
}

double RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(uint64_t *a1, uint64_t a2, __int16 a3, double a4)
{
  float v4;
  _QWORD *v6;
  double v7;
  uint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  _QWORD *v20;
  uint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  uint64_t v28;
  unint64_t v29;
  _QWORD *v30;
  uint64_t v32;
  unint64_t v33;
  double result;
  uint64_t v35;
  __int16 v36;

  v4 = *(float *)&a4;
  v35 = a2;
  v36 = a3;
  RB::Fill::Color::convert((uint64_t)&v35, *((unsigned __int8 *)a1 + 16), *(uint16x4_t *)&a4);
  v6 = (_QWORD *)a1[1];
  v7 = v4;
  v8 = v6[1];
  v9 = v8 + 1;
  if (v6[2] < (unint64_t)(v8 + 1))
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(a1[1], v9);
    v8 = v6[1];
    v9 = v8 + 1;
  }
  *(double *)(*v6 + 8 * v8) = v7;
  v6[1] = v9;
  v10 = (_QWORD *)*a1;
  _H0 = v35;
  __asm { FCVT            D8, H0 }
  v18 = *(_QWORD *)(*a1 + 8);
  v17 = *(_QWORD *)(*a1 + 16);
  v19 = v18 + 1;
  if (v17 < v18 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(*a1, v19);
    v18 = v10[1];
    v20 = (_QWORD *)*a1;
    v17 = *(_QWORD *)(*a1 + 16);
    v19 = v18 + 1;
  }
  else
  {
    v20 = (_QWORD *)*a1;
  }
  *(_QWORD *)(*v10 + 8 * v18) = _D8;
  v10[1] = v19;
  _H0 = WORD1(v35);
  __asm { FCVT            D8, H0 }
  v23 = v20[1];
  v24 = v23 + 1;
  if (v17 < v23 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v20, v24);
    v23 = v20[1];
    v25 = (_QWORD *)*a1;
    v17 = *(_QWORD *)(*a1 + 16);
    v24 = v23 + 1;
  }
  else
  {
    v25 = v20;
  }
  *(_QWORD *)(*v20 + 8 * v23) = _D8;
  v20[1] = v24;
  _H0 = WORD2(v35);
  __asm { FCVT            D8, H0 }
  v28 = v25[1];
  v29 = v28 + 1;
  if (v17 < v28 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v25, v29);
    v28 = v25[1];
    v30 = (_QWORD *)*a1;
    v17 = v30[2];
    v29 = v28 + 1;
  }
  else
  {
    v30 = v25;
  }
  *(_QWORD *)(*v25 + 8 * v28) = _D8;
  v25[1] = v29;
  _H8 = HIWORD(v35);
  v32 = v30[1];
  v33 = v32 + 1;
  if (v17 < v32 + 1)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v30, v33);
    v32 = v30[1];
    v33 = v32 + 1;
  }
  __asm { FCVT            D0, H8 }
  *(double *)(*v30 + 8 * v32) = result;
  v30[1] = v33;
  return result;
}

void RB::Fill::`anonymous namespace'::subdivide_stop<RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)::$_0>(uint64_t a1, float16x4_t *a2, uint64_t a3, uint64_t *a4, unint64_t a5, int8x16_t a6, int8x16_t a7, double a8, double a9, double a10, int8x16_t a11)
{
  float v12;
  float v13;
  float v15;
  unint64_t v18;
  float16x4_t v21;
  __int16 v22;

  v12 = *(float *)a7.i32;
  v13 = *(float *)a6.i32;
  v15 = *(float *)a7.i32 - *(float *)a6.i32;
  if (v15 > 0.0624 && a5 <= 7 && (LODWORD(v15) & 0x7FFFFFFFu) < 0x7F800000)
  {
    v18 = a5;
    a7.i32[0] = 0.5;
    v21 = *(float16x4_t *)a1;
    v22 = *(_WORD *)(a1 + 8);
    a6.i32[0] = 0.5;
    RB::Fill::Color::mix(&v21, a2, a3, a6, a7, a8, a9, a10, a11);
  }
  else
  {
    *(float *)a6.i32 = v13;
    RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(a4, *(_QWORD *)a1, *(_WORD *)(a1 + 8), *(double *)a6.i64);
  }
}

size_t RB::Fill::Gradient::map_alpha(RB::Fill::Gradient *this, CGContextRef *a2, double a3, double a4, double a5, double a6, float a7)
{
  unint64_t v9;
  unint64_t v15;
  int v16;
  __int16 v17;
  uint16x4_t v18;
  float16x4_t v19;
  uint64_t v20;
  int8x16_t v21;
  __int32 v22;
  float32x4_t v24;
  float32x4_t v25;
  unint64_t v26;
  __int16 v27;
  int16x8_t v28;
  uint64_t v29;

  v9 = 0;
  v29 = *MEMORY[0x24BDAC8D0];
  __asm { FMOV            V1.4S, #1.0 }
  v24 = (float32x4_t)vdupq_n_s32(0x437F0000u);
  v25 = _Q1;
  do
  {
    v15 = RB::Fill::Gradient::sample(this, (float)v9 * 0.0039216, *(double *)_Q1.i64, a5, a6, a7);
    v16 = *((unsigned __int8 *)a2 + 8);
    v26 = v15;
    v27 = v17;
    RB::Fill::Color::convert((uint64_t)&v26, v16, v18);
    v19.i16[3] = 15360;
    LODWORD(a6) = HIDWORD(v26);
    v19.i32[0] = v26;
    v19.i16[2] = WORD2(v26);
    v20 = 0x3F0000003F000000;
    _Q1.i64[1] = 0x3F0000003F000000;
    v21 = (int8x16_t)vcvtq_u32_f32(vmlaq_f32(_Q1, v24, vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_n_s16(HIWORD(v26))), vcvtq_f32_f16(v19)))), (float32x4_t)0), v25)));
    _Q1.i64[0] = vextq_s8(v21, v21, 8uLL).u64[0];
    a5 = COERCE_DOUBLE(__PAIR64__(v21.u32[1], _Q1.u32[1]));
    v22 = v21.i32[0];
    *(uint32x2_t *)v21.i8 = vshl_u32((uint32x2_t)__PAIR64__(v21.u32[1], _Q1.u32[1]), (uint32x2_t)0x800000018);
    v28.i32[v9++] = v21.i32[2] | (v22 << 16) | v21.i32[0] | v21.i32[1];
  }
  while (v9 != 256);
  return RB::CGContext::apply_alpha_lut(a2, &v28);
}

_QWORD *RB::Fill::Gradient::encode(RB::Fill::Gradient *this, RB::Encoder *a2)
{
  RB::Fill::Gradient *v3;
  uint64_t v4;
  size_t v5;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  uint64_t v13;
  int *v14;
  _DWORD *v15;
  uint64_t v16;
  int v17;
  int v18;
  unint64_t v19;
  uint64_t v20;
  int32x4_t v21;
  unint64_t v22;
  size_t v23;
  char *v24;
  uint64_t v25;
  float *v26;
  float *v27;
  uint64_t v28;
  float v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  int v33;
  _QWORD *result;
  double v35;
  uint32x2_t v36;
  int v37;
  int v38;
  float64x2_t *v39;
  int64x2_t v40;
  int v41;
  unint64_t v42;
  float32x4_t v43;
  uint64_t v44;

  v3 = this;
  v44 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)this;
  if (!(*(_QWORD *)this >> 61))
  {
    v5 = 8 * v4;
    if ((unint64_t)(8 * v4) > 0x1000)
    {
      v6 = (char *)malloc_type_malloc(8 * v4, 0xB405AEA9uLL);
      if (!v6)
      {
LABEL_11:
        free(v6);
        goto LABEL_12;
      }
    }
    else
    {
      MEMORY[0x24BDAC7A8](this, a2);
      v6 = (char *)&v43 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v6, v5);
    }
    if (*(_QWORD *)v3)
    {
      v7 = 0;
      v8 = 0;
      do
      {
        *(_QWORD *)&v6[8 * v8++] = *(_QWORD *)(*((_QWORD *)v3 + 1) + v7);
        v9 = *(_QWORD *)v3;
        v7 += 16;
      }
      while (v8 < *(_QWORD *)v3);
    }
    else
    {
      v9 = 0;
    }
    this = (RB::Fill::Gradient *)RB::ProtobufEncoder::packed_fixed64_field(a2, 1, (const unint64_t *)v6, v9);
    if (v5 > 0x1000)
      goto LABEL_11;
  }
LABEL_12:
  if ((*((_BYTE *)v3 + 50) & 1) != 0)
  {
    v10 = *(_QWORD *)v3;
    if (!(*(_QWORD *)v3 >> 62))
    {
      v11 = 4 * v10;
      if ((unint64_t)(4 * v10) > 0x1000)
      {
        v12 = (char *)malloc_type_malloc(4 * v10, 0xE34A5342uLL);
        if (!v12)
        {
LABEL_21:
          free(v12);
          goto LABEL_22;
        }
      }
      else
      {
        MEMORY[0x24BDAC7A8](this, a2);
        v12 = (char *)&v43 - ((v11 + 15) & 0xFFFFFFFFFFFFFFF0);
        bzero(v12, v11);
      }
      v13 = *(_QWORD *)v3;
      if (*(_QWORD *)v3)
      {
        v14 = (int *)(*((_QWORD *)v3 + 1) + 8);
        v15 = v12;
        v16 = *(_QWORD *)v3;
        do
        {
          v17 = *v14;
          v14 += 4;
          *v15++ = v17;
          --v16;
        }
        while (v16);
      }
      this = (RB::Fill::Gradient *)RB::ProtobufEncoder::packed_fixed32_field(a2, 2, (const unsigned int *)v12, v13);
      if (v11 > 0x1000)
        goto LABEL_21;
    }
  }
LABEL_22:
  v18 = *((_DWORD *)v3 + 12);
  if ((v18 & 0x100) == 0)
  {
    if ((v18 & 0x200) != 0 && *(_QWORD *)v3 != 1)
    {
      v19 = 0;
      v20 = 12;
      v21 = vdupq_n_s32(0x3B808081u);
      v43 = (float32x4_t)v21;
      do
      {
        v21.i32[0] = *(_DWORD *)(*((_QWORD *)v3 + 1) + v20);
        RB::ProtobufEncoder::float4_field(a2, 15, vmulq_f32(vcvtq_f32_u32(vmovl_u16((uint16x4_t)*(_OWORD *)&vmovl_u8(*(uint8x8_t *)v21.i8))), v43));
        ++v19;
        v20 += 16;
      }
      while (v19 < *(_QWORD *)v3 - 1);
    }
    goto LABEL_37;
  }
  v22 = *(_QWORD *)v3 - 1;
  if (v22 >> 62)
    goto LABEL_37;
  v23 = 4 * v22;
  if (4 * v22 > 0x1000)
  {
    v24 = (char *)malloc_type_malloc(4 * v22, 0xF2738FECuLL);
    if (!v24)
    {
LABEL_36:
      free(v24);
      goto LABEL_37;
    }
  }
  else
  {
    MEMORY[0x24BDAC7A8](this, a2);
    v24 = (char *)&v43 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v24, v23);
  }
  v25 = *(_QWORD *)v3 - 1;
  if (*(_QWORD *)v3 != 1)
  {
    v26 = (float *)(*((_QWORD *)v3 + 1) + 12);
    v27 = (float *)v24;
    v28 = *(_QWORD *)v3 - 1;
    do
    {
      v29 = *v26;
      v26 += 4;
      *v27++ = 1.0 - v29;
      --v28;
    }
    while (v28);
  }
  RB::ProtobufEncoder::packed_fixed32_field(a2, 3, (const unsigned int *)v24, v25);
  if (v23 > 0x1000)
    goto LABEL_36;
LABEL_37:
  v30 = *((unsigned __int8 *)v3 + 52);
  if (*((_BYTE *)v3 + 52))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, v30);
  }
  v31 = *((_DWORD *)v3 + 12);
  v32 = v31 & 7;
  if ((v31 & 7) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, v32);
  }
  v33 = rb_color_space(*(_WORD *)((char *)v3 + 53));
  if (v33 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(a2, v33);
  }
  result = RB::ProtobufEncoder::float2_field(a2, 7, *((double *)v3 + 3));
  if (*((_BYTE *)v3 + 52) == 1)
  {
    v35 = *((double *)v3 + 4);
    v36 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)((char *)v3 + 24), *(float32x2_t *)&v35));
    if ((vpmax_u32(v36, v36).u32[0] & 0x80000000) == 0)
      goto LABEL_48;
  }
  else
  {
    v35 = *((double *)v3 + 4);
  }
  result = RB::ProtobufEncoder::float2_field(a2, 8, v35);
LABEL_48:
  v37 = *((int *)v3 + 10);
  if (*(float *)&v37 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x4DuLL);
    result = RB::ProtobufEncoder::encode_fixed32(a2, v37);
  }
  v38 = *((int *)v3 + 11);
  if (*(float *)&v38 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x55uLL);
    result = RB::ProtobufEncoder::encode_fixed32(a2, v38);
  }
  v39 = (float64x2_t *)*((_QWORD *)v3 + 2);
  if (v39)
  {
    v40 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v39[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v39, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v39[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v40, 1), (int8x16_t)v40).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x5AuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(v39->f64, a2);
      result = RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  v41 = *((_DWORD *)v3 + 12) & 0xC0;
  switch(v41)
  {
    case 64:
      v42 = 96;
      break;
    case 192:
      v42 = 112;
      break;
    case 128:
      v42 = 104;
      break;
    default:
      return result;
  }
  RB::ProtobufEncoder::encode_varint(a2, v42);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

void sub_209B68760(_Unwind_Exception *exception_object)
{
  void *v1;
  unint64_t v2;

  if (v2 > 0x1000)
    free(v1);
  _Unwind_Resume(exception_object);
}

void RB::Fill::Gradient::decode(unint64_t *a1, RB::Heap **this)
{
  char v4;
  int8x8_t v5;
  float32x2_t v11;
  unint64_t field;
  __n128 v13;
  double v14;
  unint64_t v15;
  _BYTE *v16;
  __n128 v17;
  int8x16_t v18;
  float v19;
  float v20;
  float v21;
  float v22;
  uint64_t v23;
  float32x2_t v24;
  uint32x2_t v25;
  _BYTE *v26;
  int v27;
  float v28;
  size_t v29;
  size_t v30;
  _BYTE *v31;
  unint64_t v32;
  float v33;
  size_t v34;
  size_t v35;
  _BYTE *v36;
  unsigned int v37;
  unint64_t v38;
  size_t v39;
  size_t v40;
  int v41;
  unint64_t v42;
  _BYTE *v43;
  _BYTE *v44;
  _BYTE *v45;
  _BYTE *v46;
  float v47;
  float v48;
  char v49;
  float v50;
  float32x4_t v51;
  float v52;
  float v53;
  int v54;
  int v55;
  RB *v56;
  int v57;
  _BYTE *v58;
  RB::Heap *v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  unint64_t v64;
  _BYTE *v65;
  int v66;
  uint64_t v67;
  float32x2_t v68;
  float32x2_t v69;
  float v70;
  _BYTE *v71;
  unint64_t v72;
  _BYTE *v73;
  int v74;
  __int16 v75;
  unsigned int v76;
  unsigned int v77;
  float v78;
  _BYTE *v79;
  int8x16_t v80;
  float64x2_t v81[2];
  uint64_t v82;
  uint64_t v83;
  _BYTE v84[64];
  void *v85;
  uint64_t v86;
  unint64_t v87;
  _BYTE v88[64];
  void *v89;
  size_t v90;
  unint64_t v91;
  _BYTE v92[64];
  void *v93;
  size_t v94;
  unint64_t v95;
  _BYTE __dst[128];
  void *v97;
  unint64_t v98;
  unint64_t v99;
  uint64_t v100;

  v4 = 0;
  v100 = *MEMORY[0x24BDAC8D0];
  v97 = 0;
  v98 = 0;
  v99 = 16;
  v93 = 0;
  v94 = 0;
  v95 = 16;
  v89 = 0;
  v90 = 0;
  v91 = 16;
  v85 = 0;
  v86 = 0;
  v87 = 16;
  *(_WORD *)((char *)a1 + 53) = 257;
  v5 = (int8x8_t)vdup_n_s32(0x437F8000u);
  __asm { FMOV            V14.2S, #1.0 }
  v11 = (float32x2_t)vdup_n_s32(0x437F0000u);
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v14 = RB::ProtobufDecoder::color_field((unint64_t *)this, field);
        v15 = v98;
        if (v99 < v98 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v98 + 1);
          v15 = v98;
        }
        v16 = v97;
        if (!v97)
          v16 = __dst;
        *(double *)&v16[8 * v15] = v14;
        ++v98;
        continue;
      case 2u:
        v33 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        v34 = v94;
        v35 = v94 + 1;
        if (v95 < v94 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(v92, v35);
          v34 = v94;
          v35 = v94 + 1;
        }
        v36 = v93;
        if (!v93)
          v36 = v92;
        *(float *)&v36[4 * v34] = v33;
        v94 = v35;
        continue;
      case 3u:
        v28 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        v29 = v90;
        v30 = v90 + 1;
        if (v91 < v90 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(v88, v30);
          v29 = v90;
          v30 = v90 + 1;
        }
        v31 = v89;
        if (!v89)
          v31 = v88;
        *(float *)&v31[4 * v29] = 1.0 - v28;
        v90 = v30;
        continue;
      case 4u:
        v32 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
        if (v32 <= 4)
          *((_BYTE *)a1 + 52) = v32;
        continue;
      case 5u:
        *((_DWORD *)a1 + 12) |= RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field) & 7;
        continue;
      case 6u:
        v37 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
        *(_WORD *)((char *)a1 + 53) = rb_color_space(v37);
        continue;
      case 7u:
        a1[3] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)this, field, v13).n128_u64[0];
        continue;
      case 8u:
        a1[4] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)this, field, v13).n128_u64[0];
        v4 = 1;
        continue;
      case 9u:
        *((float *)a1 + 10) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 0xAu:
        *((float *)a1 + 11) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        continue;
      case 0xBu:
        v81[0] = (float64x2_t)xmmword_209BD5290;
        v81[1] = (float64x2_t)xmmword_209BD52A0;
        v82 = 0;
        v83 = 0;
        if ((field & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::AffineTransform::decode((RB::AffineTransform *)v81, (RB::ProtobufDecoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        RB::Fill::Gradient::concat((RB::Fill::Gradient *)a1, v81, this[8]);
        continue;
      case 0xCu:
        *((_DWORD *)a1 + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field))
          v27 = 64;
        else
          v27 = 0;
        goto LABEL_51;
      case 0xDu:
        *((_DWORD *)a1 + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field))
          v27 = 128;
        else
          v27 = 0;
        goto LABEL_51;
      case 0xEu:
        *((_DWORD *)a1 + 12) &= 0xFFFFFF3F;
        if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field))
          v27 = 192;
        else
          v27 = 0;
LABEL_51:
        *((_DWORD *)a1 + 12) |= v27;
        break;
      case 0xFu:
        v17 = RB::ProtobufDecoder::float4_field((RB::ProtobufDecoder *)this, field);
        v18 = (int8x16_t)v17;
        if (v17.n128_f32[0] >= 0.0)
          v19 = v17.n128_f32[0];
        else
          v19 = 0.0;
        if (v19 <= 1.0)
          v20 = (float)(v19 * 255.0) + 0.5;
        else
          v20 = 255.5;
        if (v17.n128_f32[2] >= 0.0)
          v21 = v17.n128_f32[2];
        else
          v21 = 0.0;
        if (v21 <= 1.0)
          v22 = (float)(v21 * 255.0) + 0.5;
        else
          v22 = 255.5;
        v23 = v86;
        if (v87 < v86 + 1)
        {
          v80 = v18;
          RB::vector<float,16ul,unsigned long>::reserve_slow(v84, v86 + 1);
          v23 = v86;
          v18 = v80;
        }
        v18.i32[0] = vextq_s8(v18, v18, 8uLL).i32[1];
        v24 = (float32x2_t)vbic_s8(*(int8x8_t *)v18.i8, (int8x8_t)vcltz_f32(*(float32x2_t *)v18.i8));
        v25 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v24, _D14), v5, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v11, v24))), (uint32x2_t)0x800000018);
        v26 = v85;
        if (!v85)
          v26 = v84;
        *(_DWORD *)&v26[4 * v23] = v25.i32[0] | ((int)v22 << 16) | (int)v20 | v25.i32[1];
        ++v86;
        break;
      default:
        continue;
    }
  }
  v38 = v98;
  if (v98 < 2)
    goto LABEL_61;
  v39 = v94;
  if (v94)
  {
    if (v94 != v98)
      goto LABEL_61;
  }
  v40 = v90;
  if (v90)
  {
    if (v90 != v98 - 1 || v86)
      goto LABEL_61;
    goto LABEL_78;
  }
  if (!v86)
  {
LABEL_78:
    v41 = 1;
    goto LABEL_79;
  }
  if (v86 != v98 - 1)
  {
LABEL_61:
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
    goto LABEL_62;
  }
  v41 = 0;
LABEL_79:
  if (!((*((_BYTE *)a1 + 52) != 1) | v4 & 1))
    a1[4] = a1[3];
  v42 = 0;
  *a1 = v38;
  v43 = v97;
  if (!v97)
    v43 = __dst;
  v44 = v93;
  if (!v93)
    v44 = v92;
  v45 = v89;
  if (!v89)
    v45 = v88;
  v46 = v85;
  if (!v85)
    v46 = v84;
  v47 = -INFINITY;
  v48 = INFINITY;
  v49 = 1;
  *((_BYTE *)a1 + 55) = 1;
  v50 = 1.0 / (float)(v38 - 1);
  do
  {
    v51 = vcvtq_f32_f16(*(float16x4_t *)&v43[8 * v42]);
    v49 &= v51.f32[3] == 1.0;
    *((_BYTE *)a1 + 55) = v49;
    v52 = fminf(fminf(v51.f32[0], v51.f32[2]), v51.f32[1]);
    if (v52 < v48)
      v48 = v52;
    v53 = fmaxf(fmaxf(v51.f32[0], v51.f32[2]), v51.f32[1]);
    if (v47 < v53)
      v47 = v53;
    if (v39)
    {
      v54 = *((_DWORD *)a1 + 12);
      if ((v54 & 0x10000) == 0 && fabsf(*(float *)&v44[4 * v42] - (float)(v50 * (float)v42)) > 0.001)
        *((_DWORD *)a1 + 12) = v54 | 0x10000;
    }
    if (v40)
    {
      v55 = *((_DWORD *)a1 + 12);
      if ((v55 & 0x100) == 0
        && v42 + 1 < v38
        && fabsf(*(float *)&v45[4 * v42] + (float)((float)(-0.5 - (float)v42) * v50)) > 0.001)
      {
        *((_DWORD *)a1 + 12) = v55 | 0x100;
      }
    }
    if (v41)
    {
      v56 = (RB *)(v42 + 1);
    }
    else
    {
      v57 = *((_DWORD *)a1 + 12);
      v56 = (RB *)(v42 + 1);
      if ((v57 & 0x200) == 0 && (unint64_t)v56 < v38)
      {
        if (v46[4 * v42]
          || (v58 = &v46[4 * v42], v58[1])
          || v58[2] != 255
          || v46[4 * v42 + 3] != 255)
        {
          *((_DWORD *)a1 + 12) = v57 | 0x200;
        }
      }
    }
    v42 = (unint64_t)v56;
  }
  while (v56 != (RB *)v38);
  *((_BYTE *)a1 + 56) = RB::required_color_depth(v56, v48, v47);
  v59 = this[8];
  v60 = *a1;
  v61 = (*((_QWORD *)v59 + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  v62 = v61 + 16 * *a1;
  if (v62 > *((_QWORD *)v59 + 3))
  {
    v61 = RB::Heap::alloc_slow((size_t *)this[8], 16 * v60, 7);
    v60 = *a1;
  }
  else
  {
    *((_QWORD *)v59 + 2) = v62;
  }
  a1[1] = v61;
  if (v60)
  {
    v63 = 0;
    v64 = 0;
    do
    {
      v65 = v97;
      if (!v97)
        v65 = __dst;
      *(_QWORD *)(a1[1] + v63) = *(_QWORD *)&v65[8 * v64];
      v66 = *((_DWORD *)a1 + 12);
      if ((v66 & 0x10000) != 0)
      {
        v71 = v93;
        if (!v93)
          v71 = v92;
        v70 = *(float *)&v71[4 * v64];
      }
      else
      {
        v67 = *a1 - 1;
        v68 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v67));
        v69 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v67), v68), v68);
        v70 = (float)v64
            * vmul_f32(v69, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v67), v69)).f32[0];
      }
      v72 = a1[1];
      *(float *)(v72 + v63 + 8) = v70;
      if ((v66 & 0x100) != 0)
      {
        v78 = 0.5;
        if (v64 < *a1 - 1)
        {
          v79 = v89;
          if (!v89)
            v79 = v88;
          v78 = *(float *)&v79[4 * v64];
        }
        *(float *)(v72 + v63 + 12) = v78;
      }
      else if ((v66 & 0x200) != 0)
      {
        if (v64 >= *a1 - 1)
        {
          v75 = 0;
          LOBYTE(v74) = 0;
          v76 = 16711680;
          v77 = -16777216;
        }
        else
        {
          v73 = v85;
          if (!v85)
            v73 = v84;
          v74 = *(_DWORD *)&v73[4 * v64];
          v75 = v74 & 0xFF00;
          v76 = v74 & 0xFFFF0000;
          v77 = v74 & 0xFF000000;
        }
        *(_DWORD *)(v72 + v63 + 12) = v76 & 0xFF0000 | v77 | v75 & 0xFF00 | v74;
      }
      ++v64;
      v63 += 16;
    }
    while (v64 < *a1);
  }
LABEL_62:
  if (v85)
    free(v85);
  if (v89)
    free(v89);
  if (v93)
    free(v93);
  if (v97)
    free(v97);
}

void sub_209B68FC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *a70;

  if (a29)
    free(a29);
  if (a40)
    free(a40);
  if (a51)
    free(a51);
  if (a70)
    free(a70);
  _Unwind_Resume(a1);
}

void RB::Fill::Gradient::attributes(float32x2_t *this, RB::XML::Element *a2)
{
  float32x2_t v4;
  float32x2_t v5;
  const char *v6;
  float32x2_t v7;
  float32x2_t v8;
  uint32x2_t v9;
  double v10;
  double v11;
  float32x2_t v12;
  double v13;
  float32x2_t v14;
  double v15;
  double v16;
  float64x2_t *v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  int64x2_t v21;
  char *v22;
  int v23;
  void (**v24)(RB::XML::Value::Gradient *__hidden);
  void *v25[2];
  float64x2_t v26;
  float64x2_t v27;

  switch(this[6].i8[4])
  {
    case 0:
      v4 = this[3];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
      *(float64x2_t *)v25 = vcvtq_f64_f32(v4);
      RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"start-point", (uint64_t)&v24);
      v5 = this[4];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
      *(float64x2_t *)v25 = vcvtq_f64_f32(v5);
      RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"end-point", (uint64_t)&v24);
      v6 = "axial-gradient";
      break;
    case 1:
      v7 = this[3];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
      *(float64x2_t *)v25 = vcvtq_f64_f32(v7);
      RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"start-center", (uint64_t)&v24);
      v8 = this[4];
      v9 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(this[3], v8));
      if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
      {
        v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
        *(float64x2_t *)v25 = vcvtq_f64_f32(v8);
        RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"end-center", (uint64_t)&v24);
      }
      v10 = this[5].f32[0];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C229178;
      v25[0] = *(void **)&v10;
      RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"start-radius", (uint64_t)&v24);
      v11 = this[5].f32[1];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C229178;
      v25[0] = *(void **)&v11;
      RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"end-radius", (uint64_t)&v24);
      v6 = "radial-gradient";
      break;
    case 2:
      v12 = this[3];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
      *(float64x2_t *)v25 = vcvtq_f64_f32(v12);
      RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"center", (uint64_t)&v24);
      v13 = this[5].f32[0];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C229178;
      v25[0] = *(void **)&v13;
      RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"angle", (uint64_t)&v24);
      v6 = "conic-gradient";
      break;
    case 3:
      v6 = "alpha-gradient";
      break;
    case 4:
      v14 = this[3];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C2290B0;
      *(float64x2_t *)v25 = vcvtq_f64_f32(v14);
      RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"center", (uint64_t)&v24);
      v15 = this[5].f32[0];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C229178;
      v25[0] = *(void **)&v15;
      RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"start-angle", (uint64_t)&v24);
      v16 = this[5].f32[1];
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C229178;
      v25[0] = *(void **)&v16;
      RB::XML::Element::set<RB::XML::Value::Float>(a2, (uint64_t)"end-angle", (uint64_t)&v24);
      v6 = "angular-gradient";
      break;
    default:
      v6 = 0;
      break;
  }
  v17 = (float64x2_t *)this[2];
  if (v17)
  {
    v18 = *v17;
    v19 = v17[1];
    v20 = v17[2];
    v21 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v19, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v17, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v20));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v21, 1), (int8x16_t)v21).u64[0] & 0x8000000000000000) == 0)
    {
      v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C228EF8;
      *(float64x2_t *)v25 = v18;
      v26 = v19;
      v27 = v20;
      RB::XML::Element::set<RB::XML::Value::AffineMatrix>(a2, (uint64_t)"gradient-transform", (uint64_t)&v24);
    }
  }
  if ((this[6].i32[0] & 7u) - 1 <= 2)
  {
    v22 = off_24C22B230[(this[6].i32[0] & 7) - 1];
    v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C228F48;
    v25[0] = v22;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(a2, (uint64_t)"edge-mode", (uint64_t)&v24);
  }
  if (this[6].i8[6])
  {
    v23 = rb_color_space(this[6].u8[5] | 0x100u);
    v24 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C223D08;
    LODWORD(v25[0]) = v23;
    RB::XML::Element::set<RB::XML::Value::ColorSpace>(a2, (uint64_t)"color-space", (uint64_t)&v24);
  }
  RB::XML::Value::Gradient::Gradient((RB::XML::Value::Gradient *)&v24, (const RB::Fill::Gradient *)this);
  RB::XML::Element::set<RB::XML::Value::Gradient>(a2, (uint64_t)v6, (uint64_t)&v24);
  v24 = &off_24C229290;
  if (v25[0])
    free(v25[0]);
}

void sub_209B693D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11)
{
  if (a11)
    free(a11);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::AffineMatrix>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228EF8;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v6 + 24) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 40);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AffineMatrix,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::ColorSpace>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C223D08;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorSpace,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

uint64_t _ZN2RB13CubicIteratorIDv2_fEC2ES1_S1_S1_S1_i(uint64_t result, int a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, float32x2_t a6)
{
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  float v15;
  float32x2_t v17;
  float32x2_t v18;

  __asm { FMOV            V5.2S, #3.0 }
  v11 = vmul_f32(vsub_f32(a4, a3), _D5);
  v12 = vmla_f32(vneg_f32(v11), _D5, vsub_f32(a5, a4));
  v13 = vsub_f32(a6, vadd_f32(vadd_f32(v11, a3), v12));
  v14 = 1.0 / (float)a2;
  v15 = (float)(v14 * v14) * v14;
  __asm { FMOV            V7.2S, #6.0 }
  v17 = vmul_n_f32(vmul_f32(v13, _D7), v15);
  *(float32x2_t *)(result + 24) = v17;
  v18 = vmul_n_f32(v12, v14 * v14);
  *(double *)result = *(double *)&a3;
  *(float32x2_t *)(result + 8) = vmla_n_f32(vmla_n_f32(v18, v11, v14), v13, v15);
  *(float32x2_t *)(result + 16) = vmla_f32(v17, (float32x2_t)0x4000000040000000, v18);
  return result;
}

void *RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 32), __dst, 0x10uLL, (size_t *)__dst + 34, v3);
  *((_QWORD *)__dst + 32) = result;
  return result;
}

void *_ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 16), __dst, 0x10uLL, (size_t *)__dst + 18, v3);
  *((_QWORD *)__dst + 16) = result;
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AffineMatrix,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229A80;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B69698(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::AffineMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AffineMatrix>,std::allocator<RB::XML::Value::AffineMatrix>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::AffineMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AffineMatrix>,std::allocator<RB::XML::Value::AffineMatrix>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorSpace,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C223ED8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B69750(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ColorSpace *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorSpace>,std::allocator<RB::XML::Value::ColorSpace>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ColorSpace *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorSpace>,std::allocator<RB::XML::Value::ColorSpace>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t RB::TextureCache::take_available@<X0>(uint64_t result@<X0>, uint64_t a2@<X1>, int a3@<W2>, __int8 a4@<W3>, int a5@<W4>, int a6@<W5>, int a7@<W6>, int32x2_t **a8@<X8>, int32x2_t a9@<D0>)
{
  int v9;
  int32x2_t **v10;
  uint64_t v11;
  int32x2_t **v12;
  int32x2_t *v13;
  uint32x2_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;

  v9 = *(_DWORD *)(result + 80);
  if (v9)
  {
    v10 = *(int32x2_t ***)(result + 72);
    if (!v10)
      v10 = (int32x2_t **)(result + 64);
    v11 = *(unsigned int *)(result + 80);
    v12 = v10;
    while (1)
    {
      v13 = *v12;
      v14 = (uint32x2_t)vceq_s32((*v12)[8], a9);
      if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0
        && *(_QWORD *)&v13[7] == a2
        && v13[9].u8[4] == a3
        && v13[9].u8[6] == a5
        && v13[9].u8[7] == a6
        && ((v13[9].i8[5] & 2) == 0) != a7)
      {
        break;
      }
      ++v12;
      if (!--v11)
        goto LABEL_12;
    }
    v13[10].i8[0] = a4;
    *a8 = v13;
    *v12 = 0;
    v15 = v9 - 1;
    *v12 = v10[v9 - 1];
    v10[v9 - 1] = 0;
    *(_DWORD *)(result + 80) = v9 - 1;
    v16 = *(_QWORD *)(result + 72);
    if (!v16)
      v16 = result + 64;
    result = *(_QWORD *)(v16 + 8 * v15);
    if (result)
    {
      v17 = *(_DWORD *)(result + 8) - 1;
      *(_DWORD *)(result + 8) = v17;
      if (!v17)
        return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  else
  {
LABEL_12:
    *a8 = 0;
  }
  return result;
}

uint64_t RB::TextureCache::prepare_from_iosurface(uint64_t a1, uint64_t a2, IOSurfaceRef buffer, unsigned __int8 *a4, RB *a5, uint64_t a6)
{
  RB *v12;
  RB *v13;
  CFTypeID v14;
  const __CFString *v15;
  unsigned __int16 v16;
  RB *v17;
  CGColorSpace *v18;
  RB *v19;
  __int16 v20;
  _BOOL4 v21;
  CGColorSpace *v22;
  __int16 v25;
  int v26;
  int v27;
  unsigned int v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  MTLPixelFormat v32;
  OSType PixelFormat;
  uint64_t result;
  uint64_t v35;
  int v38;
  uint64_t v39;
  int32x2_t v40;
  const float *v41;
  int32x2_t v42;
  uint32x2_t v43;
  void *v44;
  MTLPixelFormat v45;
  unsigned int *v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned __int8 v53;
  __int16 v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  int v62;
  uint64_t v63;

  v12 = (RB *)IOSurfaceCopyValue(buffer, (CFStringRef)*MEMORY[0x24BDD8E88]);
  v13 = v12;
  if (v12)
  {
    v14 = CFGetTypeID(v12);
    if (v14 == CFStringGetTypeID())
    {
      v16 = RB::color_space_from_cg_name(v13, v15);
      if (v16 >= 0x100u)
      {
        v21 = 0;
        LODWORD(a5) = 6;
LABEL_41:
        CFRelease(v13);
        goto LABEL_42;
      }
    }
    v17 = CGColorSpaceCreateWithPropertyList(v13);
    v19 = v17;
    if (v17)
    {
      v20 = RB::color_space_from_cg(v17, v18);
      if ((v20 & 0xFF00) != 0)
        LODWORD(a5) = 6;
      else
        LODWORD(a5) = 1;
      if ((v20 & 0xFF00) != 0)
        LOBYTE(v16) = v20;
      else
        LOBYTE(v16) = 1;
      CFRelease(v19);
      v21 = 0;
      goto LABEL_41;
    }
  }
  v62 = 0;
  v60 = 0u;
  v61 = 0u;
  v58 = 0u;
  v59 = 0u;
  v56 = 0u;
  v57 = 0u;
  v55 = 0u;
  v63 = 116;
  v21 = IOSurfaceGetBulkAttachments() == 0;
  if (!v21 || BYTE11(v58) == 0 || BYTE12(v58) == 0)
  {
    if (a5)
    {
      v25 = RB::color_space_from_cg(a5, v22);
      if ((v25 & 0xFF00) != 0)
        LOBYTE(v16) = v25;
      else
        LOBYTE(v16) = 1;
      if ((v25 & 0xFF00) != 0)
        LODWORD(a5) = 6;
      else
        LODWORD(a5) = 1;
      if (v13)
        goto LABEL_41;
      goto LABEL_42;
    }
    LOBYTE(v16) = 1;
  }
  else
  {
    LOBYTE(v16) = 1;
    if (BYTE11(v58) - 1 < 2)
    {
LABEL_32:
      if (BYTE12(v58) - 1 >= 2 && BYTE12(v58) != 13)
      {
        if (BYTE12(v58) != 8)
        {
          LODWORD(a5) = 1;
          if (!v13)
            goto LABEL_42;
          goto LABEL_41;
        }
        LOBYTE(v16) = v16 & 2;
      }
      LODWORD(a5) = 6;
      if (!v13)
        goto LABEL_42;
      goto LABEL_41;
    }
    LODWORD(a5) = 1;
    if (BYTE11(v58) == 12)
    {
      LOBYTE(v16) = 3;
      goto LABEL_32;
    }
  }
  if (v13)
    goto LABEL_41;
LABEL_42:
  if ((_DWORD)a5 != 6 && (_DWORD)a5)
    return 0;
  v26 = 0;
  v27 = *(_DWORD *)(a1 + 16) & 1;
  if (!v27 && (v16 & 1) != 0)
    v26 = (a4[3] & 1) != 0 || !a4[1] || *a4 != v16;
  if (*(unsigned __int8 *)(*(_QWORD *)a2 + 283) > 2u)
    v26 |= 6u;
  if (*(_BYTE *)(*(_QWORD *)a2 + 286))
    v26 |= 8u;
  v28 = v26 | (16 * v27);
  v29 = v28 | 0x20;
  if (((1 << (a6 & 0x1F)) & 0x61) == 0)
    v29 = v28;
  if ((a6 & 0x1Fu) <= 6)
    v30 = v29;
  else
    v30 = v28;
  v54 = 0;
  v31 = a6 & 0xFF00000000;
  if ((a6 & 0xFF00000000) != 0)
    v32 = (unint64_t)v30;
  else
    v32 = (unint64_t)v28;
  v53 = 0;
  PixelFormat = IOSurfaceGetPixelFormat(buffer);
  result = RB::pixel_format_from_four_cc(PixelFormat, v32, (_BYTE *)&v54 + 1, &v54, (char *)&v53);
  if (!result)
    return result;
  v35 = result;
  if ((v54 & 1) == 0)
    LOBYTE(v16) = v16 & 0xFE;
  if (!HIBYTE(v54))
  {
    if (!v21)
    {
      v62 = 0;
      v60 = 0u;
      v61 = 0u;
      v58 = 0u;
      v59 = 0u;
      v56 = 0u;
      v57 = 0u;
      v55 = 0u;
      v63 = 116;
      if (IOSurfaceGetBulkAttachments() || v63 != 116)
        goto LABEL_78;
    }
    if (BYTE4(v61))
    {
      v38 = BYTE4(v61) == 1;
    }
    else
    {
LABEL_78:
      if (!v31)
        goto LABEL_81;
      v38 = (a6 & 0x1F) - 3 < 2;
    }
    LODWORD(v31) = v38 << 26;
    goto LABEL_81;
  }
  LODWORD(v31) = 0;
LABEL_81:
  v39 = *(_QWORD *)a2;
  v40 = *(int32x2_t *)(a1 + 8);
  if ((v35 & 0x80000000) != 0)
  {
    result = RB::Device::valid_texture_size_nonnative(v39, v35, v40);
    if (!(_DWORD)result)
      return result;
    v40 = *(int32x2_t *)(a1 + 8);
  }
  else
  {
    v41 = (const float *)(v39 + 288);
    v42 = (int32x2_t)vld1_dup_f32(v41);
    v43 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v42, v40), (int8x8_t)vcgtz_s32(v40));
    if ((vpmin_u32(v43, v43).u32[0] & 0x80000000) == 0)
      return 0;
  }
  v44 = (void *)objc_msgSend(MEMORY[0x24BDDD740], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v35, v40.i32[0], v40.i32[1], 0);
  v46 = RB::pixel_format_traits(v35, v45);
  if (((*v46 | ((unint64_t)*((unsigned __int16 *)v46 + 2) << 32)) & 0x40000000000) != 0)
    v47 = 17;
  else
    v47 = 1;
  objc_msgSend(v44, "setUsage:", v47);
  if (v53)
    RB::Texture::set_swizzle(v44, (const char *)v53);
  result = objc_msgSend(*(id *)(*(_QWORD *)a2 + 24), "newTextureWithDescriptor:iosurface:plane:", v44, buffer, 0);
  if (result)
  {
    v48 = result;
    v49 = operator new();
    RB::Texture::Texture(v49, v48, v16, 6, v53);
    v50 = *(_DWORD *)(a1 + 56);
    if (*(_DWORD *)(a1 + 60) < v50 + 1)
    {
      RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow((void *)(a1 + 32), v50 + 1);
      v50 = *(_DWORD *)(a1 + 56);
    }
    v51 = *(_QWORD *)(a1 + 48);
    if (!v51)
      v51 = a1 + 32;
    v52 = v51 + 16 * v50;
    *(_DWORD *)v52 = v31;
    *(_QWORD *)(v52 + 8) = v49;
    ++*(_DWORD *)(a1 + 56);
    return RB::TextureCache::prepare_from_cache(a1, a2, a4);
  }
  return result;
}

void sub_209B69D10(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::TextureCache::prepare_from_texture_data(int32x2_t *a1, uint64_t a2, uint64_t a3, unsigned __int8 *a4, RB *a5, uint64_t a6)
{
  unint64_t PixelFormat;
  MTLPixelFormat v12;
  unsigned int *v13;
  uint64_t v14;
  unsigned int *v15;
  RB *ColorSpace;
  CGColorSpace *v18;
  unsigned __int16 v19;
  unsigned __int8 v20;
  _BYTE *v21;
  unsigned int *v22;
  MTLPixelFormat v23;
  double v24;
  double v25;
  unsigned int v28;
  unint64_t NumberOfMipmaps;
  int v30;
  unsigned int *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  int v37;
  uint64_t v38;
  unsigned __int32 v39;
  int32x2_t *v40;
  int32x2_t *v41;
  uint64_t v42;
  int v43;
  int v44;
  unsigned __int8 *v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t *v51;
  uint64_t v52;
  uint64_t (*v53)(uint64_t, uint64_t);
  _DWORD *(*v54)(uint64_t);
  void *v55;
  uint64_t v56;

  PixelFormat = CGImageTextureDataGetPixelFormat();
  v13 = RB::pixel_format_traits(PixelFormat, v12);
  v14 = 0;
  if (PixelFormat != *v13)
    return v14;
  v15 = v13;
  if (*(unsigned __int8 *)(*(_QWORD *)a2 + 283) < *((unsigned __int8 *)v13 + 7)
    || *((_BYTE *)v13 + 8) != 0)
  {
    return 0;
  }
  ColorSpace = (RB *)CGImageTextureDataGetColorSpace();
  if (!ColorSpace)
    ColorSpace = a5;
  if (ColorSpace)
  {
    v19 = RB::color_space_from_cg(ColorSpace, v18);
    if (v19 < 0x100u)
      return 0;
    v20 = v19;
    if ((v19 & 1) == 0)
    {
      v21 = a4 + 3;
      goto LABEL_21;
    }
  }
  else
  {
    v20 = 1;
  }
  if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x1000000000) != 0)
  {
    PixelFormat = v15[6];
    if (!v15[6])
      return 0;
  }
  v21 = a4 + 3;
  if ((a4[3] & 1) != 0 || !a4[1] || *a4 != v20)
  {
    v22 = RB::pixel_format_traits(PixelFormat, (MTLPixelFormat)v18);
    if (*(unsigned int *)((char *)v22 + 18))
      PixelFormat = *(unsigned int *)((char *)v22 + 18);
  }
LABEL_21:
  CGImageTextureDataGetSize();
  if (v25 != (double)(int)*(_QWORD *)&a1[1] || v24 != (double)(int)HIDWORD(*(_QWORD *)&a1[1]))
    return 0;
  if ((*v21 & 2) != 0)
  {
    NumberOfMipmaps = CGImageTextureDataGetNumberOfMipmaps();
    if (!NumberOfMipmaps)
      return 0;
    v28 = NumberOfMipmaps;
    if (NumberOfMipmaps > RB::max_mipmap_levels(a1[1]))
      return 0;
  }
  else
  {
    v28 = 1;
  }
  if ((a6 & 0xFF00000000) != 0)
  {
    if ((a6 & 0x1Fu) > 6)
    {
      v32 = 0;
      goto LABEL_41;
    }
    v30 = 1 << (a6 & 0x1F);
    if ((v30 & 0x61) == 0)
    {
      v32 = 0;
      if ((v30 & 0x18) != 0)
        v32 = 0x4000000;
      goto LABEL_41;
    }
    v31 = RB::pixel_format_traits(PixelFormat, v23);
    if (((*v31 | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32)) & 0x100000000) != 0)
    {
      if (*(_BYTE *)(*(_QWORD *)a2 + 286))
      {
        v32 = 0;
        goto LABEL_41;
      }
      return 0;
    }
  }
  v32 = 0;
LABEL_41:
  v33 = v28;
  if (v28 == 1)
    CGImageTextureDataSupportsTiledLayout();
  v50 = 0;
  v51 = &v50;
  v52 = 0x3812000000;
  v53 = __Block_byref_object_copy__3;
  v54 = __Block_byref_object_dispose__3;
  v55 = &unk_209BEAE19;
  v56 = 0;
  v46 = 0;
  v47 = &v46;
  v48 = 0x2020000000;
  v49 = 0;
  if (!v28)
    goto LABEL_53;
  v44 = v32;
  v45 = a4;
  v34 = 0;
  do
  {
    CGImageTextureDataGetDataWithBlock();
    ++v34;
  }
  while (v33 != v34);
  v35 = v51;
  v36 = v51[6];
  if (v36 && v47[3] == v33)
  {
    v37 = *(unsigned __int8 *)(v36 + 76) > 1u;
    v38 = (uint64_t)a1;
    v39 = a1[7].u32[0];
    if (a1[7].i32[1] < v39 + 1)
    {
      RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&a1[4], v39 + 1);
      v38 = (uint64_t)a1;
      v39 = a1[7].u32[0];
    }
    v40 = *(int32x2_t **)(v38 + 48);
    if (!v40)
      v40 = a1 + 4;
    v41 = &v40[2 * v39];
    v41->i32[0] = v44 | (v37 << 25);
    v41[1] = (int32x2_t)v35[6];
    v35[6] = 0;
    ++*(_DWORD *)(v38 + 56);
    v14 = RB::TextureCache::prepare_from_cache(v38, a2, v45);
  }
  else
  {
LABEL_53:
    v14 = 0;
  }
  _Block_object_dispose(&v46, 8);
  _Block_object_dispose(&v50, 8);
  v42 = v56;
  if (v56)
  {
    v43 = *(_DWORD *)(v56 + 8) - 1;
    *(_DWORD *)(v56 + 8) = v43;
    if (!v43)
      (*(void (**)(uint64_t))(*(_QWORD *)v42 + 8))(v42);
  }
  return v14;
}

void sub_209B6A164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35)
{
  uint64_t v36;
  int v37;

  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
  v36 = a35;
  if (a35)
  {
    v37 = *(_DWORD *)(a35 + 8) - 1;
    *(_DWORD *)(a35 + 8) = v37;
    if (!v37)
      (*(void (**)(uint64_t))(*(_QWORD *)v36 + 8))(v36);
  }
  _Unwind_Resume(a1);
}

_DWORD **RB::refcounted_ptr<RB::Buffer>::operator=(_DWORD **a1, _DWORD *a2)
{
  _DWORD *v3;
  int v5;

  v3 = *a1;
  if (v3 != a2)
  {
    if (v3)
    {
      v5 = v3[2] - 1;
      v3[2] = v5;
      if (!v5)
        (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
    }
    if (a2)
      ++a2[2];
    *a1 = a2;
  }
  return a1;
}

uint64_t RB::TextureCache::prepare(uint64_t a1, uint64_t a2, __IOSurface *a3, unsigned __int8 *a4)
{
  if ((RB::TextureCache::prepare_from_cache(a1, a2, a4) & 1) != 0)
    return 1;
  else
    return RB::TextureCache::prepare_from_iosurface(a1, a2, a3, a4, 0, 0);
}

uint64_t RB::TextureCache::prepare(uint64_t a1, uint64_t a2, void *a3, unsigned __int8 *a4)
{
  unint64_t v9;
  MTLPixelFormat v10;
  unsigned int *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  int v20;

  if ((RB::TextureCache::prepare_from_cache(a1, a2, a4) & 1) != 0)
    return 1;
  v9 = objc_msgSend(a3, "pixelFormat");
  v11 = RB::pixel_format_traits(v9, v10);
  v12 = *((unsigned __int16 *)v11 + 2);
  v13 = *v11;
  v14 = operator new();
  RB::Texture::Texture(v14, a3, ((v13 | (v12 << 32)) & 0x1200000000) == 0, 6, 0);
  v15 = *(unsigned __int8 *)(v14 + 80);
  v16 = *(unsigned __int8 *)(v14 + 76);
  v17 = *(_DWORD *)(a1 + 56);
  if (*(_DWORD *)(a1 + 60) < v17 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow((void *)(a1 + 32), v17 + 1);
    v17 = *(_DWORD *)(a1 + 56);
  }
  v18 = *(_QWORD *)(a1 + 48);
  if (!v18)
    v18 = a1 + 32;
  v19 = v18 + 16 * v17;
  if (v16 >= 2)
    v20 = 33554688;
  else
    v20 = 256;
  *(_DWORD *)v19 = v20 | v15;
  *(_QWORD *)(v19 + 8) = v14;
  ++*(_DWORD *)(a1 + 56);
  return RB::TextureCache::prepare_from_cache(a1, a2, a4);
}

void sub_209B6A3B0(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

_DWORD *__Block_byref_object_dispose__3(uint64_t a1)
{
  _DWORD *result;
  int v2;

  result = *(_DWORD **)(a1 + 48);
  if (result)
  {
    v2 = result[2] - 1;
    result[2] = v2;
    if (!v2)
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void sub_209B6A6F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB12TextureCache25prepare_from_texture_dataERNS_11RenderFrameEP18CGImageTextureDataRKNS0_6ParamsEP12CGColorSpaceNSt3__18optionalIjEE_block_invoke_2()
{
  return CGImageTextureDataRelease();
}

uint64_t RB::TextureCache::prepare_from_base_level(int32x2_t *a1, uint64_t *a2, unsigned int *a3, uint64_t a4, unsigned int a5)
{
  int32x2_t *v6;
  unsigned int v8;
  int v9;
  unsigned __int8 v10;
  int v11;
  int v12;
  unint64_t v13;
  unsigned int *v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int v17;
  uint64_t result;
  int v19;
  unsigned int v27;
  char v28;
  int32x2_t v29;
  __int8 v30;
  MTLPixelFormat v31;
  __n128 v32;
  int32x2_t *v33;
  unint64_t v34;
  unsigned int *v35;
  uint64_t v36;
  int32x2_t v37;
  uint64_t v38;
  uint64_t v39;
  RB::Buffer *v40;
  uint64_t v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  unsigned __int32 v47;
  int32x2_t *v48;
  int32x2_t *v49;
  uint64_t v50;
  int32x2_t *v51;
  int v52;
  unsigned int v53;
  unint64_t v56;
  __int128 v57;
  _BYTE v58[80];
  uint64_t v59;
  int32x2_t v60[17];
  int v61;
  int32x2_t v62;
  int32x2_t v63;
  int v64;
  int32x2_t v65;
  int v66;
  char v67;
  _BYTE v68[32];
  int32x2_t *v69;
  RB::Buffer *v70;
  int64x2_t v71;

  v6 = (int32x2_t *)a4;
  v8 = *a3;
  v9 = *a3 & 0xFF00;
  if (v9)
    v10 = *a3;
  else
    v10 = 1;
  v11 = *(unsigned __int8 *)(a4 + 80);
  v12 = *(unsigned __int8 *)(a4 + 79);
  v13 = *(_QWORD *)(a4 + 56);
  v14 = RB::pixel_format_traits(v13, (MTLPixelFormat)a2);
  v15 = v14[8];
  if (!v14[8])
    v15 = v13;
  v16 = HIDWORD(*((_QWORD *)v14 + 3));
  if (!v16)
    v16 = v13;
  if (v12)
    v16 = v15;
  v56 = v16;
  v17 = HIWORD(v8);
  result = 1;
  if (a5 < BYTE2(v8))
  {
    v53 = v8 & 0xFD000000;
    if (v11 == v10)
      v19 = v9;
    else
      v19 = 0;
    __asm
    {
      FMOV            V11.2S, #1.0
      FMOV            V12.2S, #-1.0
      FMOV            V15.2S, #4.0
    }
    v52 = v19 | v8;
    while (1)
    {
      v27 = a5 + 1;
      v28 = v27 >= v17 ? 1 : 2;
      LOBYTE(a5) = v28 + a5;
      v29 = vmax_s32(vshl_s32(a1[1], vneg_s32(vdup_n_s32(a5))), (int32x2_t)0x100000001);
      v30 = v6[10].i8[0];
      RB::TextureCache::take_available((uint64_t)a1, v56, 1, v30, 1, 0, 0, &v69, v29);
      v33 = v69;
      if (!v69)
      {
        v32.n128_u64[0] = (unint64_t)v29;
        RB::Texture::alloc(*a2, v56, 1u, v30, 1, 0, (uint64_t *)v60, v32);
        v33 = (int32x2_t *)v60[0];
        if (!*(_QWORD *)v60)
          break;
      }
      v34 = (unint64_t)v33[7];
      v35 = RB::pixel_format_traits(v34, v31);
      RB::RenderParams::RenderParams((uint64_t)v68, (uint64_t)a2, v34, v30, v30, ((*v35 | ((unint64_t)*((unsigned __int16 *)v35 + 2) << 32)) & 0xA00000000) != 0, *(double *)&v29, 1.0);
      RB::RenderPass::RenderPass(v60, v68, v33, 0, 0, 0);
      RB::RenderPass::set_label((id *)v60, CFSTR("RB: Image downsampling"));
      v36 = v61 == 2;
      RB::Coverage::set_plane((float32x2_t *)&v57, (uint64_t)v60, v37);
      if (v27 >= v17)
      {
        v38 = 0x4000000040000000;
        v39 = 31;
      }
      else
      {
        *(_QWORD *)&v58[44] = 0x3F800000BF800000;
        *(_QWORD *)&v58[52] = _D11;
        *(_QWORD *)&v58[60] = _D12;
        *(_QWORD *)&v58[68] = 0xBF8000003F800000;
        v38 = _D15;
        v39 = 4194335;
        v59 = 0x3400340034003400;
      }
      *(_OWORD *)&v58[12] = (unint64_t)v38;
      *(_QWORD *)&v58[28] = 0;
      *(float32x2_t *)&v58[36] = vcvt_f32_s32(v6[8]);
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v60, (RB::Device *)0x68, 4uLL, 0, &v70);
      v40 = v70;
      if (v70)
      {
        v41 = *((_QWORD *)v70 + 7) + v71.i64[0];
        v42 = *(_OWORD *)&v58[16];
        v43 = v57;
        *(_OWORD *)(v41 + 16) = *(_OWORD *)v58;
        *(_OWORD *)(v41 + 32) = v42;
        v44 = *(_OWORD *)&v58[64];
        v45 = *(_OWORD *)&v58[48];
        v46 = *(_OWORD *)&v58[32];
        *(_QWORD *)(v41 + 96) = v59;
        *(_OWORD *)(v41 + 64) = v45;
        *(_OWORD *)(v41 + 80) = v44;
        *(_OWORD *)(v41 + 48) = v46;
        *(_OWORD *)v41 = v43;
      }
      else
      {
        v70 = 0;
        v71 = 0uLL;
      }
      v64 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v60, v40);
      v65 = vmovn_s64(v71);
      v66 = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v60, (uint64_t)v6);
      v67 = 2;
      RB::RenderPass::draw_indexed_primitives(v60, (const char *)(v39 | (v36 << 33)), 4, ***(_QWORD ***)v60 + 80, 0, 1uLL, v62, v63);
      v66 = 0;
      v67 = 0;
      RB::RenderPass::~RenderPass((RB::RenderPass *)v60);
      v47 = a1[7].u32[0];
      if (a1[7].i32[1] < v47 + 1)
      {
        RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&a1[4], v47 + 1);
        v47 = a1[7].u32[0];
      }
      v48 = (int32x2_t *)a1[6];
      if (!v48)
        v48 = a1 + 4;
      v49 = &v48[2 * v47];
      v49->i32[0] = v53 | (a5 << 16) | v52;
      v49[1] = (int32x2_t)v33;
      v50 = a1[7].u32[0];
      a1[7].i32[0] = v50 + 1;
      v51 = (int32x2_t *)a1[6];
      if (!v51)
        v51 = a1 + 4;
      v6 = (int32x2_t *)v51[2 * v50 + 1];
      v17 = *((unsigned __int8 *)a3 + 2);
      if (v17 <= a5)
        return 1;
    }
    return 0;
  }
  return result;
}

void sub_209B6AB14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,int a56,char a57)
{
  _DWORD *v57;
  int v59;

  v59 = v57[2] - 1;
  v57[2] = v59;
  if (!v59)
    (*(void (**)(_DWORD *))(*(_QWORD *)v57 + 8))(v57);
  _Unwind_Resume(exception_object);
}

BOOL RB::TextureCache::prune_caches(RB::TextureCache *this, int a2, unsigned int a3, unsigned int a4, unsigned int a5)
{
  uint64_t v7;
  unsigned int v8;
  unsigned int v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unsigned int v16;
  char *v17;
  int v18;
  unsigned int v19;
  char *v20;
  _DWORD *v21;
  int v22;
  const void *v24;
  _DWORD **v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  int v29;
  _BOOL8 result;

  v7 = *(_QWORD *)this;
  v8 = *((_DWORD *)this + 14);
  if (v8)
  {
    v12 = 0;
    do
    {
      if (*((_QWORD *)this + 6))
        v13 = (char *)*((_QWORD *)this + 6);
      else
        v13 = (char *)this + 32;
      v14 = &v13[16 * v12];
      v15 = *((_QWORD *)v14 + 1);
      if (*(_DWORD *)(v15 + 32) - a2 <= 0)
      {
        if (!v7 || (v16 = *(_DWORD *)(v15 + 36), v16 <= a4))
        {
LABEL_15:
          v17 = &v13[16 * v8 - 16];
          v18 = *(_DWORD *)v14;
          *(_DWORD *)v14 = *(_DWORD *)v17;
          *(_DWORD *)v17 = v18;
          *((_QWORD *)v14 + 1) = *((_QWORD *)v17 + 1);
          *((_QWORD *)v17 + 1) = v15;
          v19 = *((_DWORD *)this + 14) - 1;
          *((_DWORD *)this + 14) = v19;
          v20 = (char *)*((_QWORD *)this + 6);
          if (!v20)
            v20 = (char *)this + 32;
          v21 = *(_DWORD **)&v20[16 * v19 + 8];
          if (v21)
          {
            v22 = v21[2] - 1;
            v21[2] = v22;
            if (!v22)
              (*(void (**)(_DWORD *))(*(_QWORD *)v21 + 8))(v21);
          }
          goto LABEL_8;
        }
        if ((*(_BYTE *)(v15 + 77) & 1) != 0 || *(_BYTE *)(v15 + 78) == 6)
        {
          if (v16 <= a3)
            goto LABEL_15;
        }
        else
        {
          if ((*(_BYTE *)(v15 + 77) & 2) != 0)
            v15 = *(_QWORD *)(v15 + 24);
          if (v16 <= a5 && *(_BYTE *)(v15 + 44) == 0)
            RB::Resource::set_volatile((id *)v15, 1);
        }
      }
      ++v12;
LABEL_8:
      v8 = *((_DWORD *)this + 14);
    }
    while (v12 < v8);
  }
  v24 = (const void *)*((_QWORD *)this + 3);
  if (v24 && (!v7 || *((_DWORD *)this + 5) <= a3 - 210))
  {
    CFRelease(v24);
    *((_QWORD *)this + 3) = 0;
  }
  if (*((_QWORD *)this + 9))
    v25 = (_DWORD **)*((_QWORD *)this + 9);
  else
    v25 = (_DWORD **)((char *)this + 64);
  v26 = *((unsigned int *)this + 20);
  if ((_DWORD)v26)
  {
    v27 = 8 * v26;
    do
    {
      v28 = *v25;
      if (*v25)
      {
        v29 = v28[2] - 1;
        v28[2] = v29;
        if (!v29)
          (*(void (**)(_DWORD *))(*(_QWORD *)v28 + 8))(v28);
      }
      ++v25;
      v27 -= 8;
    }
    while (v27);
  }
  result = 0;
  *((_DWORD *)this + 20) = 0;
  if (!*((_DWORD *)this + 14))
    return *((_QWORD *)this + 3) == 0;
  return result;
}

void *RB::vector<RB::refcounted_ptr<RB::Texture>,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 5) + (*((_DWORD *)__dst + 5) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 5) + (*((_DWORD *)__dst + 5) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 1), __dst, 1u, (_DWORD *)__dst + 5, v3);
  *((_QWORD *)__dst + 1) = result;
  return result;
}

RB::Symbol::Animation::Timing *RB::Symbol::Animation::Timing::Timing(RB::Symbol::Animation::Timing *this, const RB::Animation *a2)
{
  const RB::Animation *v3;
  unsigned int v4;
  unsigned int v5;
  RB::Symbol::Animation::Timing *v6;
  uint64_t v7;
  _DWORD *v8;
  int v9;
  int v10;
  unint64_t v11;
  RB::Symbol::Animation::Timing *v12;
  RB::Symbol::Animation::Timing *v13;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0x600000000;
  if (*((_QWORD *)a2 + 3))
    v3 = (const RB::Animation *)*((_QWORD *)a2 + 3);
  else
    v3 = a2;
  v4 = *((_DWORD *)a2 + 8);
  v5 = v4;
  if (v4 >= 7)
  {
    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow(this, v4);
    v6 = (RB::Symbol::Animation::Timing *)*((_QWORD *)this + 3);
    v7 = *((unsigned int *)this + 8);
  }
  else
  {
    v6 = 0;
    if (!v4)
    {
      v10 = 0;
      goto LABEL_13;
    }
    v7 = 0;
  }
  if (!v6)
    v6 = this;
  v8 = (_DWORD *)((char *)v6 + 4 * v7);
  do
  {
    v9 = *(_DWORD *)v3;
    v3 = (const RB::Animation *)((char *)v3 + 4);
    *v8++ = v9;
    --v5;
  }
  while (v5);
  v10 = *((_DWORD *)this + 8);
  v6 = (RB::Symbol::Animation::Timing *)*((_QWORD *)this + 3);
LABEL_13:
  v11 = v10 + v4;
  *((_DWORD *)this + 8) = v11;
  if (v6)
    v12 = v6;
  else
    v12 = this;
  *((float *)this + 10) = RB::Animation::active_duration((uint64_t)v12, v11);
  if (*((_QWORD *)this + 3))
    v13 = (RB::Symbol::Animation::Timing *)*((_QWORD *)this + 3);
  else
    v13 = this;
  RB::Animation::prepare((uint64_t)v13, *((unsigned int *)this + 8), (uint64_t)this + 44);
  return this;
}

void sub_209B6AE60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 24);
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Symbol::Animation::Animation(uint64_t result, uint64_t a2, int a3, uint64_t a4, float a5)
{
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;

  do
    v5 = __ldxr((unsigned int *)&RB::Symbol::Animation::next_unique_id);
  while (__stxr(v5 + 1, (unsigned int *)&RB::Symbol::Animation::next_unique_id));
  *(_DWORD *)result = v5;
  *(_DWORD *)(result + 4) = a3;
  *(float *)(result + 8) = a5;
  *(_QWORD *)(result + 12) = *(_QWORD *)a4;
  *(_DWORD *)(result + 20) = *(_DWORD *)(a4 + 8);
  *(_DWORD *)(result + 24) = *(_DWORD *)(a4 + 20);
  *(_QWORD *)(result + 28) = *(_QWORD *)(a4 + 12);
  *(_DWORD *)(result + 36) = 0;
  *(_QWORD *)(result + 40) = *(_QWORD *)(a4 + 24);
  *(int64x2_t *)(result + 48) = vdupq_n_s64(0x7FF0000000000000uLL);
  v6 = (unsigned int *)(a2 + 8);
  *(_QWORD *)(result + 64) = 0;
  *(_QWORD *)(result + 72) = 0;
  do
    v7 = __ldxr(v6);
  while (__stxr(v7 + 1, v6));
  *(_QWORD *)(result + 80) = a2;
  if (*(float *)(result + 28) > 1.0)
    *(_DWORD *)(result + 12) |= 0x800u;
  return result;
}

void RB::Symbol::Animation::cancel(RB::Symbol::Animation *this, float32x2_t a2, const RB::Symbol::Model *a3)
{
  int v3;
  double v5;
  float32x2_t v6;
  float32x2_t v7;
  const RB::Symbol::Model *v8;
  float v9;
  float v10;
  float v11;
  double v12;
  float v13;
  float v14;
  float32x2_t v15;
  float32x2_t v16;
  float v17;
  float v18;
  float v19;

  v3 = *((_DWORD *)this + 3);
  if ((v3 & 0x1000) == 0)
  {
    if ((v3 & 0xC00) != 0)
    {
      v5 = *(double *)&a2;
      a2.i32[0] = *((_DWORD *)this + 6);
      v6 = vrecpe_f32(a2);
      v7 = vmul_f32(vrecps_f32(a2, v6), v6);
      v19 = vmul_f32(v7, vrecps_f32(a2, v7)).f32[0];
      v9 = RB::Symbol::Animation::local_duration(this, a3) * v19;
      v10 = 0.0;
      if (*((float *)this + 7) > 1.0)
        v10 = *((float *)this + 8);
      v11 = v10 + v9;
      v12 = v5 - *((double *)this + 6);
      v3 = *((_DWORD *)this + 3);
      if ((v3 & 0x200) != 0)
      {
        v18 = v11;
        v13 = RB::Symbol::Animation::intro_duration(this, v8);
        v11 = v18;
        v12 = v12 - (float)(v13 * v19);
      }
      v14 = v11;
      v15 = vrecpe_f32((float32x2_t)LODWORD(v11));
      v16 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v14), v15), v15);
      v17 = ceil(v12 * vmul_f32(v16, vrecps_f32((float32x2_t)LODWORD(v14), v16)).f32[0]);
      *((float *)this + 7) = v17;
    }
    *((_DWORD *)this + 3) = v3 | 0x1000;
  }
}

float RB::Symbol::Animation::local_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  uint64_t v3;
  float result;
  _BOOL4 v6;
  float *v7;
  unsigned int v8;
  unsigned int v9;

  v3 = *((_QWORD *)this + 9);
  if (v3 && (*((_BYTE *)this + 12) & 0x80) != 0)
    return *(float *)(v3 + 40);
  result = 0.0;
  switch(*((_DWORD *)this + 1))
  {
    case 0:
    case 7:
      return 0.33333;
    case 1:
      RB::Symbol::Model::glyph_info(a2);
      __asm { BR              X13 }
      return result;
    case 2:
      if (*((int *)this + 3) < 0)
        return (float)1;
      else
        return (float)2;
    case 3:
      v6 = (*((_BYTE *)this + 12) & 0x20) == 0;
      v7 = (float *)&unk_209BD7420;
      goto LABEL_21;
    case 4:
    case 5:
      return 0.25;
    case 6:
      v8 = *((_DWORD *)this + 3);
      v9 = ((v8 & 0xE000000) - 0x2000000) >> 25;
      result = 1.0;
      if (v9 - 2 >= 3)
      {
        if (v9)
        {
          if (v9 == 1)
          {
            return 0.7;
          }
          else
          {
            result = 0.5;
            if (v8 >> 30 == 3)
              return 0.25;
          }
        }
        else
        {
          return 0.66667;
        }
      }
      return result;
    case 9:
      return 0.16667;
    case 0xA:
      v6 = (*((_BYTE *)this + 12) & 0x20) == 0;
      v7 = (float *)&unk_209BD7418;
LABEL_21:
      result = v7[v6];
      break;
    case 0xB:
      result = 2.0;
      break;
    case 0xC:
      result = 3.0;
      break;
    default:
      return result;
  }
  return result;
}

float RB::Symbol::Animation::intro_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  int v2;
  BOOL v3;
  float result;

  v2 = *((_DWORD *)this + 1);
  if (v2 <= 9)
  {
    if (v2 == 1)
      return 0.33333;
    if (v2 == 3)
    {
      v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
      result = 0.43333;
      goto LABEL_11;
    }
    return 0.0;
  }
  if (v2 == 10)
  {
    v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
    result = 0.33333;
  }
  else
  {
    if (v2 != 11)
      return 0.0;
    v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
    result = 2.5;
  }
LABEL_11:
  if (v3)
    return 0.0;
  return result;
}

void RB::Symbol::Animation::send_completion(RB::Symbol::Animation *this, char a2)
{
  void *v2;
  int v4;
  _QWORD v5[4];
  id v6;
  int v7;
  char v8;

  v2 = (void *)*((_QWORD *)this + 8);
  if (v2)
  {
    *((_QWORD *)this + 8) = 0;
    v4 = *(_DWORD *)this;
    v5[0] = MEMORY[0x24BDAC760];
    v5[1] = 3321888768;
    v5[2] = ___ZN2RB6Symbol9Animation15send_completionEb_block_invoke;
    v5[3] = &__block_descriptor_45_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE_e5_v8__0l;
    v6 = v2;
    v8 = a2;
    v7 = v4;
    dispatch_async(MEMORY[0x24BDAC9B8], v5);

  }
}

void sub_209B6B3C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB6Symbol9Animation15send_completionEb_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(*(_QWORD *)(a1 + 32) + 16))(*(_QWORD *)(a1 + 32), *(unsigned __int8 *)(a1 + 44), *(unsigned int *)(a1 + 40));
}

id __copy_helper_block_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c41_ZTSN2RB8objc_ptrIU13block_pointerFvbjEEE(uint64_t a1)
{

}

double RB::Symbol::Animation::begin_time_after(RB::Symbol::Animation *this, double a2, const RB::Symbol::Model *a3, double a4, double a5)
{
  float32x2_t v7;
  float32x2_t v8;
  double v9;
  const RB::Symbol::Model *v10;
  float v11;
  float v12;
  double v13;
  float v15;

  if ((*((_QWORD *)this + 6) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL)
    return INFINITY;
  LODWORD(a5) = *((_DWORD *)this + 6);
  v7 = vrecpe_f32(*(float32x2_t *)&a5);
  v8 = vmul_f32(vrecps_f32(*(float32x2_t *)&a5, v7), v7);
  LODWORD(a5) = vmul_f32(v8, vrecps_f32(*(float32x2_t *)&a5, v8)).u32[0];
  v15 = *(float *)&a5;
  v9 = a2 - *((double *)this + 6);
  if ((*((_BYTE *)this + 13) & 2) != 0)
    v9 = v9 - (float)(RB::Symbol::Animation::intro_duration(this, a3) * *(float *)&a5);
  v11 = RB::Symbol::Animation::local_duration(this, a3) * v15;
  v12 = 0.0;
  if (*((float *)this + 7) > 1.0)
    v12 = *((float *)this + 8);
  v13 = *((double *)this + 6) + ceil(v9 / (float)(v12 + v11)) * (float)(v12 + v11);
  if ((*((_BYTE *)this + 13) & 4) != 0)
    return v13 + (float)(RB::Symbol::Animation::outro_duration(this, v10) * v15);
  return v13;
}

float RB::Symbol::Animation::outro_duration(RB::Symbol::Animation *this, const RB::Symbol::Model *a2)
{
  int v2;
  BOOL v3;
  float result;

  v2 = *((_DWORD *)this + 1);
  if (v2 <= 9)
  {
    if (v2 == 1)
      return 0.33333;
    if (v2 == 3)
    {
      v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
      result = 0.26667;
      goto LABEL_11;
    }
    return 0.0;
  }
  if (v2 == 10)
  {
    v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
    result = 0.41667;
  }
  else
  {
    if (v2 != 11)
      return 0.0;
    v3 = (*((_BYTE *)this + 12) & 0x20) == 0;
    result = 2.5;
  }
LABEL_11:
  if (v3)
    return 0.0;
  return result;
}

double RB::Symbol::Animation::end_time(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, float32x2_t a3)
{
  float32x2_t v5;
  float32x2_t v6;
  const RB::Symbol::Model *v7;
  double v8;
  int v9;
  uint64_t v11;
  const RB::Symbol::Glyph::Layer *v12;
  unsigned int v13;
  uint64_t v14;
  float v15;
  float v16;
  double v17;
  uint64_t v18;
  double v19;
  float v20;

  if ((*((_QWORD *)this + 6) & 0x7FFFFFFFFFFFFFFFuLL) > 0x7FEFFFFFFFFFFFFFLL
    || (*((_DWORD *)this + 7) & 0x7FFFFFFFu) > 0x7F7FFFFF)
  {
    return INFINITY;
  }
  a3.i32[0] = *((_DWORD *)this + 6);
  v5 = vrecpe_f32(a3);
  v6 = vmul_f32(vrecps_f32(a3, v5), v5);
  v20 = vmul_f32(v6, vrecps_f32(a3, v6)).f32[0];
  v8 = *((double *)this + 6)
     + (float)((float)((float)(*((float *)this + 7) * RB::Symbol::Animation::local_duration(this, a2)) * v20)
             + (float)(fmaxf(*((float *)this + 7) + -1.0, 0.0) * *((float *)this + 8)));
  v9 = *((_DWORD *)this + 3);
  if ((v9 & 0x40) != 0)
  {
    v11 = RB::Symbol::Model::glyph_info(a2);
    if (*(_QWORD *)(v11 + 376))
      v12 = *(const RB::Symbol::Glyph::Layer **)(v11 + 376);
    else
      v12 = (const RB::Symbol::Glyph::Layer *)(v11 + 112);
    v13 = *(_DWORD *)(v11 + 384);
    if (v13)
    {
      v14 = 88 * v13;
      v15 = 0.0;
      do
      {
        v16 = RB::Symbol::Animation::layer_delay(this, a2, v12);
        if (v15 < v16)
          v15 = v16;
        v12 = (const RB::Symbol::Glyph::Layer *)((char *)v12 + 88);
        v14 -= 88;
      }
      while (v14);
      v17 = v15;
    }
    else
    {
      v17 = 0.0;
    }
    v8 = v8 + v17;
    v9 = *((_DWORD *)this + 3);
    if ((v9 & 0x200) == 0)
    {
LABEL_5:
      if ((v9 & 0x400) == 0)
        goto LABEL_6;
LABEL_22:
      v8 = v8 + (float)(RB::Symbol::Animation::outro_duration(this, v7) * v20);
      if ((v9 & 0x80) != 0)
        return v8;
      goto LABEL_23;
    }
  }
  else if ((v9 & 0x200) == 0)
  {
    goto LABEL_5;
  }
  v8 = v8 + (float)(RB::Symbol::Animation::intro_duration(this, v7) * v20);
  if ((v9 & 0x400) != 0)
    goto LABEL_22;
LABEL_6:
  if ((v9 & 0x80) != 0)
    return v8;
LABEL_23:
  v18 = *((_QWORD *)this + 9);
  if (v18)
  {
    v19 = *(float *)(v18 + 40);
    if (v8 < *((double *)this + 6) + v19)
      return *((double *)this + 6) + v19;
  }
  return v8;
}

float RB::Symbol::Animation::layer_delay(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, const RB::Symbol::Glyph::Layer *a3)
{
  int v4;
  unsigned int v7;
  float v8;
  float result;
  unsigned int v10;
  float v11;
  unsigned int v12;
  float32x2_t v13;
  float32x2_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int v17;
  float32x2_t v18;
  float32x2_t v19;

  v4 = *((_DWORD *)this + 1);
  if (v4 == 10 || v4 == 3)
  {
    v7 = *(_DWORD *)(RB::Symbol::Model::glyph_info(a2) + 400);
    if (v7 >= 5)
    {
      *(float *)&v12 = (float)v7 + -1.0;
      v13 = vrecpe_f32((float32x2_t)v12);
      v14 = vmul_f32(vrecps_f32((float32x2_t)v12, v13), v13);
      v8 = 0.15 * vmul_f32(v14, vrecps_f32((float32x2_t)v12, v14)).f32[0];
    }
    else
    {
      v8 = 0.05;
    }
    v15 = *((_DWORD *)a3 + 17);
    if (*((_DWORD *)this + 1) == 3)
    {
      v16 = v7 + ~v15;
      if (*((int *)this + 3) < 0)
        v15 = v16;
    }
    v11 = (float)v15;
  }
  else
  {
    result = 0.0;
    if (v4 != 1)
      return result;
    v10 = *(_DWORD *)(RB::Symbol::Model::glyph_info(a2) + 396);
    if (v10 > 3)
    {
      *(float *)&v17 = (float)((float)((float)v10 * 0.083333) + 0.33333) + (float)((float)(2 * v10 - 8) * 0.016667);
      v18 = vrecpe_f32((float32x2_t)v17);
      v19 = vmul_f32(vrecps_f32((float32x2_t)v17, v18), v18);
      return (float)(0.11111 * (float)*((unsigned int *)a3 + 20))
           * vmul_f32(v19, vrecps_f32((float32x2_t)v17, v19)).f32[0];
    }
    v8 = (float)*((unsigned int *)a3 + 20);
    v11 = 0.33333;
  }
  return v8 * v11;
}

RB::Symbol::Model *RB::Symbol::Animation::style_mask(RB::Symbol::Animation *this)
{
  RB::Symbol::Model *result;

  result = (RB::Symbol::Model *)*((_QWORD *)this + 10);
  if (result)
    return (RB::Symbol::Model *)*(unsigned int *)(RB::Symbol::Model::glyph_info(result) + 392);
  return result;
}

uint64_t RB::Symbol::Animation::will_apply(uint64_t this, double a2)
{
  unsigned int v2;
  int v3;

  if (*(double *)(this + 56) != a2)
  {
    v2 = *(_DWORD *)(this + 36);
    if (v2 >= 2)
    {
      if (v2 != 2)
        return this;
      if ((*(_BYTE *)(this + 13) & 0x40) == 0 && a2 - *(double *)(this + 48) > 0.0333333333)
        *(double *)(this + 48) = a2 + -0.0333333333;
      v3 = 3;
    }
    else
    {
      if ((*(_BYTE *)(this + 13) & 0x40) == 0)
        *(double *)(this + 48) = a2;
      if (v2)
        v3 = 2;
      else
        v3 = 1;
    }
    *(_DWORD *)(this + 36) = v3;
  }
  return this;
}

void RB::Symbol::Animation::apply(RB::Symbol::Animation *this, double a2, const RB::Symbol::Model *a3, const RB::Symbol::Animator *a4, RB::Symbol::Presentation *a5, RB::Symbol::KeyframeStorage *a6)
{
  float v6;
  RB::Symbol::Presentation *v7;
  const RB::Symbol::Model *v8;
  float v11;
  int v12;
  uint64_t v13;
  char *v15;
  unsigned int v16;
  uint64_t v17;
  int v18;
  int v19;
  unsigned int v20;
  int v21;
  float v22;
  char *v23;
  int v24;
  RB::Symbol::KeyframeStorage *v25;
  double v26;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  int v35;
  int v36;
  float v37;
  unsigned int *v38;
  unsigned int *v39;
  char *v40;
  int v41;
  char *v42;
  float v43;
  unsigned int v44;
  int v45;
  unsigned int *v46;
  int v47;
  int v48;
  unsigned int v49;
  int v50;
  double v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int32x2_t v56;
  float v57;
  int32x2_t v58;
  int v59;
  int v60;
  int v61;
  float v62;
  float v63;
  int v64;
  int v65;
  int v66;
  float v67;
  float v68;
  int32x2_t v69;
  float32x2_t v70;
  float32x2_t v71;
  unsigned int v72;
  unsigned int v73;
  float32x2_t v74;
  RB::Symbol::Model *v75;
  unint64_t v76;
  float v77;
  unsigned int v78;
  unint64_t v79;
  float v80;
  float v81;
  float v82;
  uint64_t v83;
  char *v84;
  unsigned int v85;
  uint64_t v86;
  float v87;
  uint64_t v88;
  float v89;
  int32x2_t v90;
  unsigned int v91;
  char *v92;
  int v93;
  char *v94;
  uint64_t v95;
  int v96;
  char v97;
  unsigned int *v98;
  unsigned int v99;
  float32x2_t v100;
  float v101;
  float32x2_t v102;
  float32x2_t v103;
  double v104;
  uint64_t v105;
  __int32 v106;
  float32x2_t v107;
  int v108;
  float32x2_t v109;
  char *v110;
  uint64_t v111;
  int v112;
  float v113;
  char *v114;
  uint64_t v115;
  char *v116;
  unsigned int v117;
  char *v118;
  unsigned int *v119;
  unsigned int v120;
  char *v121;
  unsigned int v122;
  int32x2_t v123;
  char *v124;
  __int32 v125;
  __int32 v126;
  __int32 v127;
  __int32 v128;
  __int32 v129;
  unsigned int v130;
  char *v131;
  char *v132;
  int v134;
  _DWORD v137[3];
  float v138;
  int v139;
  uint64_t v140;
  uint64_t v141;
  int v142;
  int v143;
  unsigned __int8 v144;
  BOOL v145;
  int32x2_t v146;

  v7 = a5;
  v8 = a3;
  v11 = a2 - *((double *)this + 6);
  v12 = *((_DWORD *)a5 + 233);
  if (v12 == 2)
  {
    if (*((_QWORD *)a5 + 105))
      v23 = (char *)*((_QWORD *)a5 + 105);
    else
      v23 = (char *)a5 + 8;
    v24 = *((_DWORD *)a5 + 212);
    if (!v24)
      goto LABEL_137;
    v25 = a6;
    v131 = &v23[416 * v24];
    v26 = INFINITY;
    __asm { FMOV            V0.2S, #1.0 }
    v122 = HIDWORD(_D0);
    v123 = vdup_n_s32(0x3E99999Au);
    while (*(_DWORD *)(*(_QWORD *)v23 + 84) - *(_DWORD *)(*((_QWORD *)this + 10) + 84) < 0)
    {
LABEL_121:
      v23 += 416;
      if (v23 == v131)
        goto LABEL_138;
    }
    v31 = RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v23);
    v32 = 0;
    v33 = *(_DWORD *)(v31 + 396);
    v142 = 0;
    v143 = v33;
    LOBYTE(v33) = *(_BYTE *)(v31 + 404);
    v144 = v33 & 1;
    v145 = (v33 & 2) != 0;
    v34 = *((_QWORD *)this + 10);
    v35 = *(unsigned __int16 *)(v34 + 88) | (*(unsigned __int8 *)(v34 + 90) << 16);
    v36 = *((unsigned __int16 *)v8 + 44) | (*((unsigned __int8 *)v8 + 90) << 16);
    v130 = *(_DWORD *)(v31 + 24);
    v140 = v130;
    v141 = *(unsigned int *)(v31 + 400);
    v146 = vshr_n_s32(vshr_n_s32(vshl_n_s32(vshl_n_s32((int32x2_t)__PAIR64__(v36, v35), 8uLL), 8uLL), 8uLL), 0x10uLL);
    v132 = v23;
    if (*((_DWORD *)this + 1) == 6)
    {
      if (*(_QWORD *)v23 == v34)
      {
        v32 = 1;
      }
      else
      {
        if (*(const RB::Symbol::Model **)v23 != v8)
        {
LABEL_120:
          v23 = v132;
          v7 = a5;
          v8 = a3;
          goto LABEL_121;
        }
        v32 = 2;
      }
      HIDWORD(v140) = v32;
      HIDWORD(v141) = *(_DWORD *)(RB::Symbol::Model::glyph_info((RB::Symbol::Model *)v34) + 400);
      v142 = *(_DWORD *)(RB::Symbol::Model::glyph_info(v8) + 400);
    }
    if ((*((_BYTE *)this + 12) & 0x40) != 0)
    {
      v39 = 0;
    }
    else
    {
      RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)v137);
      v6 = *(float *)v137;
      v37 = v138;
      v38 = (unsigned int *)RB::Symbol::Animation::keyframes((uint64_t)this, &v140, v25, v139, v8);
      if (!v38)
        goto LABEL_138;
      v39 = v38;
      RB::Symbol::Presentation::record_keyframes((uint64_t)v7, (int *)this, v32, (uint64_t)v38, v25);
      if (*((double *)this + 6) + v37 < v26)
        v26 = *((double *)this + 6) + v37;
    }
    if (*((_QWORD *)v23 + 47))
      v40 = (char *)*((_QWORD *)v23 + 47);
    else
      v40 = v23 + 16;
    v41 = *((_DWORD *)v23 + 96);
    if (v41)
    {
      v124 = v23 + 16;
      v42 = &v40[120 * v41];
      while (1)
      {
        if (((*((_DWORD *)v40 + 29) >> *((_DWORD *)this + 1)) & 1) == 0)
        {
          if ((*((_BYTE *)this + 12) & 0x40) == 0)
            goto LABEL_49;
          RB::Symbol::Animation::local_time(this, v11, a3, *(const RB::Symbol::Glyph::Layer **)v40, (uint64_t)v137);
          v6 = *(float *)v137;
          v43 = v138;
          v39 = (unsigned int *)RB::Symbol::Animation::keyframes((uint64_t)this, &v140, v25, v139, a3);
          if (v39)
            break;
        }
LABEL_119:
        v40 += 120;
        if (v40 == v42)
          goto LABEL_120;
      }
      RB::Symbol::Presentation::record_keyframes((uint64_t)a5, (int *)this, v32, (uint64_t)v39, v25);
      if (*((double *)this + 6) + v43 < v26)
        v26 = *((double *)this + 6) + v43;
LABEL_49:
      v44 = *v39;
      v45 = *v39 & 0xF;
      if (v45)
      {
        v134 = v144;
        v46 = v39;
        do
        {
          v47 = *(_DWORD *)(*(_QWORD *)v40 + 68);
          v48 = *(_DWORD *)(*(_QWORD *)v40 + 80);
          v49 = *(_DWORD *)(*(_QWORD *)v40 + 84);
          v50 = RB::Symbol::Animation::layer_flagged((uint64_t)this, *(_QWORD *)v40, v45);
          if (*((_QWORD *)v46 + 1))
          {
            v52 = (v44 >> 4) & 7;
            if (!v52 || v52 == v32)
            {
              v53 = (v44 >> 7) & 3;
              if (!v53 || v53 == ((v49 >> 20) & 3))
              {
                v54 = (v44 >> 10) & 0x7FF;
                if (v54 == 2047 || v54 == v47)
                {
                  v55 = v44 >> 21;
                  if (v44 >> 21 == 2047)
                    goto LABEL_62;
                  if (v44 < 0x200000)
                    v55 = -1;
                  if (v55 == v48)
                  {
LABEL_62:
                    if (((v50 ^ 1) & (v44 >> 9) & 1) == 0)
                    {
                      *(float *)v56.i32 = RB::Symbol::Keyframes::eval((RB::Symbol::Keyframes *)v46, v6, a6, v51);
                      v58.i32[0] = v56.i32[0];
                      switch(*v46 & 0xF)
                      {
                        case 1u:
                          *((float *)v40 + 6) = *((float *)v40 + 6) * *(float *)v56.i32;
                          break;
                        case 2u:
                          v59 = *((unsigned __int16 *)a3 + 44);
                          v60 = v59 << 8;
                          v61 = (__int16)v59 << 8;
                          v62 = 1.25;
                          if ((v60 & 0xFF0000) == 0)
                            v62 = 1.0;
                          if (v61 < 0)
                            v62 = 0.5;
                          v63 = v62 * *(float *)v58.i32;
                          goto LABEL_75;
                        case 3u:
                          v64 = *((unsigned __int16 *)a3 + 44);
                          v65 = v64 << 8;
                          v66 = (__int16)v64 << 8;
                          v67 = 1.25;
                          if ((v65 & 0xFF0000) == 0)
                            v67 = 1.0;
                          if (v66 < 0)
                            v67 = 0.5;
                          v68 = *((float *)v40 + 9);
                          v62 = v67 - v68;
                          v63 = v68 + (float)(v62 * *(float *)v58.i32);
LABEL_75:
                          *((float *)v40 + 9) = v63;
                          RB::Symbol::Presentation::Layer::add_scale_velocity((float32x2_t *)v40, v62 * v57);
                          break;
                        case 4u:
                          v125 = v56.i32[0];
                          RB::Symbol::Presentation::Layer::add_scale_velocity((float32x2_t *)v40, v57);
                          *((_DWORD *)v40 + 10) = v125;
                          break;
                        case 5u:
                          v69 = *(int32x2_t *)((char *)this + 40);
                          *((float32x2_t *)v40 + 8) = vmla_n_f32(*(float32x2_t *)(v40 + 64), (float32x2_t)v69, *(float *)v58.i32);
                          *(float *)v69.i32 = v57 * *(float *)v58.i32;
                          RB::Symbol::Presentation::Layer::add_velocity((float32x2_t *)v40, COERCE_DOUBLE(vdup_lane_s32(v69, 0)));
                          break;
                        case 6u:
                          *((float *)v40 + 11) = *((float *)v40 + 11) + *(float *)v56.i32;
                          goto LABEL_80;
                        case 7u:
                          *((float *)v40 + 12) = *((float *)v40 + 12) + *(float *)v56.i32;
LABEL_80:
                          RBStrokeRef::clip(v40);
                          break;
                        case 8u:
                          *((_DWORD *)v40 + 6) = v56.i32[0];
                          *((_DWORD *)v40 + 7) = v56.i32[0];
                          break;
                        case 9u:
                          v70 = (float32x2_t)vdup_lane_s32(v58, 0);
                          v71 = (float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v70, *(float32x2_t *)(v40 + 24)), (int8x8_t)v70, *(int8x8_t *)(v40 + 24));
                          goto LABEL_116;
                        case 0xAu:
                          v56.i32[0] = 0;
                          if ((*((_DWORD *)this + 3) & 0x20000000) == 0)
                          {
                            *(float *)v56.i32 = 0.3;
                            if (v130 == 3)
                            {
                              v126 = v58.i32[0];
                              *(float *)v56.i32 = RB::Symbol::Model::alpha(a3, 2uLL, 0.3);
                              v58.i32[0] = v126;
                            }
                          }
                          *((float32x2_t *)v40 + 3) = vmla_n_f32(*(float32x2_t *)(v40 + 24), vsub_f32((float32x2_t)vdup_lane_s32(v56, 0), *(float32x2_t *)(v40 + 24)), *(float *)v58.i32);
                          break;
                        case 0xBu:
                          v72 = *((_DWORD *)a3 + 20);
                          v73 = *(_DWORD *)(*(_QWORD *)v40 + 80);
                          if ((v73 | v72) == 0xFFFFFFFF)
                          {
                            v128 = v56.i32[0];
                            v83 = RB::Symbol::Model::glyph_info(a3);
                            if (v83 != RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v132))
                              break;
                            v84 = (char *)*((_QWORD *)v132 + 47);
                            if (!v84)
                              v84 = v124;
                            v85 = -286331153 * ((unint64_t)(v40 - v84) >> 3);
                            v86 = RB::Symbol::Model::glyph_info(a3);
                            v88 = v86 + 112;
                            if (*(_QWORD *)(v86 + 376))
                              v88 = *(_QWORD *)(v86 + 376);
                            v89 = RB::Symbol::Model::alpha(a3, *(unsigned __int8 *)(v88 + 88 * v85 + 84), v87);
                            v58.i32[0] = v128;
                            v74 = (float32x2_t)__PAIR64__(v122, LODWORD(v89));
                          }
                          else
                          {
                            if (v72 >= v73)
                            {
                              v75 = a3;
                              v76 = 0;
                            }
                            else
                            {
                              v74 = (float32x2_t)v123;
                              if (v130 != 3)
                                goto LABEL_115;
                              v75 = a3;
                              v76 = 2;
                            }
                            v129 = v56.i32[0];
                            *(float *)v90.i32 = RB::Symbol::Model::alpha(v75, v76, *(float *)v56.i32);
                            v58.i32[0] = v129;
                            v74 = (float32x2_t)vdup_lane_s32(v90, 0);
                          }
LABEL_115:
                          v71 = vmla_n_f32(*(float32x2_t *)(v40 + 24), vsub_f32(v74, *(float32x2_t *)(v40 + 24)), *(float *)v58.i32);
LABEL_116:
                          *((float32x2_t *)v40 + 3) = v71;
                          break;
                        case 0xCu:
                          if (*((float *)v40 + 6) > 0.0)
                          {
                            v77 = 0.3;
                            if (!v134)
                            {
                              v77 = 0.3;
                              if ((*((_BYTE *)this + 12) & 0x10) != 0)
                              {
                                v77 = 0.3;
                                if (v130 == 3)
                                {
                                  v78 = *(unsigned __int8 *)(*(_QWORD *)v40 + 84);
                                  if (v78 <= 1)
                                    v79 = v78 + 1;
                                  else
                                    v79 = v78 - 1;
                                  v127 = v58.i32[0];
                                  v80 = RB::Symbol::Model::alpha(a3, v79, 0.3);
                                  v81 = RB::Symbol::Model::alpha(a3, *(unsigned __int8 *)(*(_QWORD *)v40 + 84), v80);
                                  v58.i32[0] = v127;
                                  v77 = v80 / v81;
                                }
                              }
                            }
                            *((float *)v40 + 6) = (float)(v77 + (float)((float)(1.0 - v77) * *(float *)v58.i32))
                                                * *((float *)v40 + 6);
                          }
                          v82 = *((float *)v40 + 7);
                          if (v82 > 0.0 && !v144 && (*((_BYTE *)this + 12) & 0x10) != 0)
                            *((float *)v40 + 7) = v82 * (float)((float)(*(float *)v58.i32 * 0.7) + 0.3);
                          break;
                        case 0xDu:
                          *((float *)v40 + 6) = *((float *)v40 + 6) * *(float *)v56.i32;
                          if (*(float *)v56.i32 <= 0.0)
                            *((_DWORD *)v40 + 7) = 0;
                          break;
                        case 0xEu:
                          *((_DWORD *)v40 + 13) = v56.i32[0];
                          break;
                        default:
                          break;
                      }
                    }
                  }
                }
              }
            }
          }
          v91 = v46[4];
          v46 += 4;
          v44 = v91;
          v45 = v91 & 0xF;
        }
        while ((v91 & 0xF) != 0);
      }
      *((_DWORD *)v40 + 29) |= *((_DWORD *)this + 5);
      v25 = a6;
      goto LABEL_119;
    }
    goto LABEL_120;
  }
  if (v12 == 1)
  {
    v92 = (char *)a5 + 8;
    if (*((_QWORD *)a5 + 105))
      v92 = (char *)*((_QWORD *)a5 + 105);
    v93 = *((_DWORD *)a5 + 212);
    if (v93)
    {
      v94 = &v92[416 * v93];
      do
      {
        v95 = *((_QWORD *)this + 10);
        if (*(_DWORD *)(*(_QWORD *)v92 + 84) - *(_DWORD *)(v95 + 84) >= 0)
        {
          v96 = *((_DWORD *)this + 1);
          if (v96)
          {
            if (v96 == 4 && !v92[409])
            {
              v97 = *(_BYTE *)(v95 + 89);
              v92[409] = 1;
              v92[408] = v97;
            }
          }
          else if (!*((_QWORD *)v92 + 1))
          {
            v98 = (unsigned int *)(v95 + 8);
            do
              v99 = __ldxr(v98);
            while (__stxr(v99 + 1, v98));
            *((_QWORD *)v92 + 1) = v95;
          }
        }
        v92 += 416;
      }
      while (v92 != v94);
    }
    goto LABEL_137;
  }
  if (v12
    || (v13 = *((_QWORD *)this + 10)) == 0
    || ((*(unsigned __int16 *)(v13 + 88) | (*(unsigned __int8 *)(v13 + 90) << 16)) & 0x10000) != 0
    || (*(_WORD *)(v13 + 88) != 0xFF ? (_ZF = *(_QWORD *)(v13 + 16) == 0) : (_ZF = 1), _ZF))
  {
LABEL_137:
    v26 = INFINITY;
LABEL_138:
    v100.i32[1] = 1064374545;
    if (v26 - a2 < 0.00416666667)
    {
      v101 = 0.05;
      if (*((_DWORD *)this + 1) >= 3u)
        v101 = 0.0;
      v100.i32[0] = *((_DWORD *)this + 6);
      v102 = vrecpe_f32(v100);
      v103 = vmul_f32(vrecps_f32(v100, v102), v102);
      v26 = (float)(v101 * vmul_f32(v103, vrecps_f32(v100, v103)).f32[0]) + a2;
    }
    v104 = *((double *)v7 + 114);
    if (v104 > v26)
      v104 = v26;
    *((double *)v7 + 114) = v104;
    return;
  }
  if (*((_QWORD *)a5 + 105))
    v15 = (char *)*((_QWORD *)a5 + 105);
  else
    v15 = (char *)a5 + 8;
  v16 = *((_DWORD *)a5 + 212);
  if (!v16)
  {
LABEL_17:
    v18 = *((_DWORD *)this + 1);
    if (v18 == 7)
    {
      if (v16)
      {
        v105 = RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>((RB::Symbol::Presentation *)((char *)a5 + 944));
        v140 = 0;
        v141 = 0;
        v142 = 0;
        v107 = RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)&v140);
        v106 = v141;
        v107.f32[0] = *(float *)&v141 * *(float *)&v140;
        *(float *)v105 = *(float *)&v141 * *(float *)&v140;
        *(_DWORD *)(v105 + 4) = v106;
        v108 = *((_DWORD *)this + 3);
        if (!*((_QWORD *)this + 9) || (v108 & 0x80) == 0)
        {
          v109.i32[0] = vdup_lane_s32((int32x2_t)v107, 0).u32[0];
          v109.i32[1] = v106;
          *(float32x2_t *)v105 = vmul_f32(vmul_n_f32(v109, v107.f32[0]), vmla_n_f32((float32x2_t)0x40C0000040400000, (float32x2_t)0xC0C00000C0000000, v107.f32[0]));
        }
        *(_BYTE *)(v105 + 8) = v108 >= 0;
        if (*((_QWORD *)v7 + 105))
          v110 = (char *)*((_QWORD *)v7 + 105);
        else
          v110 = (char *)v7 + 8;
        v16 = *((_DWORD *)v7 + 212);
        *(_QWORD *)&v110[416 * v16 - 24] = v105;
        *((_BYTE *)v7 + 928) = 1;
      }
      v26 = a2;
      goto LABEL_171;
    }
    if (v18 == 6)
    {
      RB::Symbol::Animation::infer_replace_subtype(this, (const RB::Symbol::Model *)v13, v8);
      v19 = *((_DWORD *)this + 3) & 0xE000000;
      v20 = (v19 - 0x2000000) >> 25;
      if (v20 - 2 < 3)
      {
        v21 = 2;
        v22 = 1.0;
LABEL_160:
        v111 = RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>((RB::Symbol::Presentation *)((char *)v7 + 944));
        v140 = 0;
        v141 = 0;
        v142 = 0;
        RB::Symbol::Animation::local_time(this, v11, v8, 0, (uint64_t)&v140);
        v112 = v141;
        v113 = (float)(*(float *)&v140 * v22) * *(float *)&v141;
        if (v113 < 0.0)
          v113 = 0.0;
        if (v113 > 1.0)
          v113 = 1.0;
        *(float *)v111 = v113;
        *(_DWORD *)(v111 + 4) = v112;
        *(_BYTE *)(v111 + 8) = 0;
        if (!*(_BYTE *)(v111 + 16))
          *(_BYTE *)(v111 + 16) = 1;
        *(_DWORD *)(v111 + 12) = v21;
        if (*((_QWORD *)v7 + 105))
          v114 = (char *)*((_QWORD *)v7 + 105);
        else
          v114 = (char *)v7 + 8;
        v16 = *((_DWORD *)v7 + 212);
        *(_QWORD *)&v114[416 * v16 - 24] = v111;
        *((_BYTE *)v7 + 928) = 1;
        goto LABEL_170;
      }
      if (v20 < 2)
      {
        if (v19 == 0x2000000)
          v22 = 2.0;
        else
          v22 = *(float *)"333@";
        v21 = 1;
        goto LABEL_160;
      }
      v16 = *((_DWORD *)v7 + 212);
    }
LABEL_170:
    v26 = INFINITY;
LABEL_171:
    v115 = *((_QWORD *)this + 10);
    if (*((_DWORD *)v7 + 213) < v16 + 1)
    {
      RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow((char *)v7 + 8, v16 + 1);
      v16 = *((_DWORD *)v7 + 212);
    }
    v116 = (char *)*((_QWORD *)v7 + 105);
    if (!v116)
      v116 = (char *)v7 + 8;
    v117 = v16;
    v118 = &v116[416 * v16];
    v119 = (unsigned int *)(v115 + 8);
    do
      v120 = __ldxr(v119);
    while (__stxr(v120 + 1, v119));
    *(_QWORD *)v118 = v115;
    v121 = &v116[416 * v117];
    *((_QWORD *)v121 + 1) = 0;
    *((_QWORD *)v121 + 47) = 0;
    *((_QWORD *)v121 + 48) = 0x300000000;
    *((_QWORD *)v121 + 49) = 0;
    *((_QWORD *)v121 + 50) = 0;
    *(_DWORD *)(v121 + 407) = 0;
    ++*((_DWORD *)v7 + 212);
    goto LABEL_138;
  }
  v17 = 416 * v16;
  while (*(_DWORD *)(v13 + 84) != *(_DWORD *)(*(_QWORD *)v15 + 84))
  {
    v15 += 416;
    v17 -= 416;
    if (!v17)
      goto LABEL_17;
  }
  *((_DWORD *)this + 3) |= 0x8000u;
}

void RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Animation *this, const RB::Symbol::Model *a2, const RB::Symbol::Model *a3)
{
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  _DWORD *v11;
  _DWORD *v12;
  int v13;
  _DWORD *v14;
  _DWORD *v15;
  _DWORD v16[4];
  void *v17;
  uint64_t v18;
  unsigned int v19[4];
  void *v20;
  uint64_t v21;
  _DWORD v22[4];
  void *v23;
  uint64_t v24;
  unsigned int v25[4];
  void *v26;
  uint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  *((_DWORD *)this + 3) &= 0xF1FFFFFF;
  v5 = RB::Symbol::Model::glyph_info(a2);
  v6 = RB::Symbol::Model::glyph_info(a3);
  if (*(_DWORD *)(v5 + 24) != *(_DWORD *)(v6 + 24))
    return;
  v7 = (_DWORD *)v6;
  if (*(float *)(v5 + 32) != *(float *)(v6 + 32))
    return;
  if (*(float *)(v5 + 36) != *(float *)(v6 + 36))
    return;
  if (*(float *)(v5 + 40) != *(float *)(v6 + 40))
    return;
  v8 = *(unsigned __int8 *)(v6 + 404) | *(unsigned __int8 *)(v5 + 404);
  v9 = (v8 >> 2) & 3;
  if (!v9)
    return;
  v10 = *((_DWORD *)this + 3);
  if ((v8 & 4) != 0 && (v10 & 0x20000000) != 0)
  {
    v26 = 0;
    v27 = 0x400000000;
    v23 = 0;
    v24 = 0x400000000;
    v20 = 0;
    v21 = 0x400000000;
    v17 = 0;
    v18 = 0x400000000;
    RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()((_DWORD *)v5, v22, v25, 1u);
    RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(v7, v16, v19, 1u);
    if (v23)
      v11 = v23;
    else
      v11 = v22;
    RB::Symbol::tags_subtract(v25, (uint64_t)v11, v24);
    if (v17)
      v12 = v17;
    else
      v12 = v16;
    RB::Symbol::tags_subtract(v19, (uint64_t)v12, v18);
    if ((_DWORD)v27 && RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v25, (uint64_t)v19))
    {
      if ((_DWORD)v24)
      {
        if (!(_DWORD)v18)
        {
          v13 = 0x4000000;
LABEL_48:
          *((_DWORD *)this + 3) |= v13;
          goto LABEL_49;
        }
      }
      else if ((_DWORD)v18)
      {
        v13 = 0x2000000;
        goto LABEL_48;
      }
    }
    if (v17)
      free(v17);
    if (v20)
      free(v20);
    if (v23)
      free(v23);
    if (v26)
      free(v26);
    v10 = *((_DWORD *)this + 3);
  }
  if (v9 < 2 || (v10 & 0x10000000) == 0)
    return;
  v26 = 0;
  v27 = 0x400000000;
  v23 = 0;
  v24 = 0x400000000;
  v20 = 0;
  v21 = 0x400000000;
  v17 = 0;
  v18 = 0x400000000;
  RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()((_DWORD *)v5, v22, v25, 2u);
  RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(v7, v16, v19, 2u);
  if (v23)
    v14 = v23;
  else
    v14 = v22;
  RB::Symbol::tags_subtract(v25, (uint64_t)v14, v24);
  if (v17)
    v15 = v17;
  else
    v15 = v16;
  RB::Symbol::tags_subtract(v19, (uint64_t)v15, v18);
  if (!(_DWORD)v27 || !RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v25, (uint64_t)v19))
    goto LABEL_49;
  if ((_DWORD)v24)
  {
    if (!(_DWORD)v18)
    {
      v13 = 0x8000000;
      goto LABEL_48;
    }
    if (!RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==((uint64_t)v22, (uint64_t)v16))
    {
      v13 = 167772160;
      goto LABEL_48;
    }
  }
  else if ((_DWORD)v18)
  {
    v13 = 100663296;
    goto LABEL_48;
  }
LABEL_49:
  if (v17)
    free(v17);
  if (v20)
    free(v20);
  if (v23)
    free(v23);
  if (v26)
    free(v26);
}

void sub_209B6C734(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  uint64_t v20;
  void *v22;

  if (a12)
    free(a12);
  if (a16)
    free(a16);
  if (a20)
    free(a20);
  v22 = *(void **)(v20 - 56);
  if (v22)
    free(v22);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::Symbol::Presentation::Interpolant>(RB::Heap *this)
{
  unint64_t v2;
  uint64_t result;

  v2 = *((_QWORD *)this + 3);
  result = (*((_QWORD *)this + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (result + 20 > v2)
    result = RB::Heap::alloc_slow((size_t *)this, 0x14uLL, 3);
  else
    *((_QWORD *)this + 2) = result + 20;
  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_DWORD *)(result + 16) = 0;
  *(_DWORD *)(result + 4) = 1065353216;
  *(_BYTE *)(result + 8) = 1;
  *(_BYTE *)(result + 16) = 0;
  return result;
}

float32x2_t RB::Symbol::Animation::local_time@<D0>(RB::Symbol::Animation *this@<X0>, float a2@<S0>, const RB::Symbol::Model *a3@<X1>, const RB::Symbol::Glyph::Layer *a4@<X2>, uint64_t a5@<X8>)
{
  float v7;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  int v17;
  float v18;
  float v19;
  const RB::Symbol::Model *v20;
  double v21;
  double v22;
  int v23;
  float v24;
  float v25;
  unsigned int v26;
  float32x2_t v27;
  float32x2_t v28;
  uint64_t v29;
  uint64_t v30;
  float v31;
  float v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t result;
  float v40;

  v7 = a2;
  v10 = *((_DWORD *)this + 3);
  if ((~v10 & 0x10040) == 0)
  {
    v7 = a2 - RB::Symbol::Animation::layer_delay(this, a3, a4);
    v10 = *((_DWORD *)this + 3);
  }
  if (v7 >= 0.0001)
    v11 = v7;
  else
    v11 = 0.0001;
  v12 = *((float *)this + 6);
  v13 = v11 * v12;
  if ((v10 & 0x200) != 0)
  {
    v15 = RB::Symbol::Animation::intro_duration(this, a3);
    v16 = v15;
    if (v13 < v15)
    {
      v17 = 0;
      v18 = 0.0;
      goto LABEL_38;
    }
    v19 = v13 - v15;
    if ((v10 & 0x10040) == 0x40)
      v19 = v19 - RB::Symbol::Animation::layer_delay(this, a3, a4);
    v14 = fmaxf(v19, 0.0001);
  }
  else
  {
    v14 = v11 * v12;
  }
  *(float *)&v21 = RB::Symbol::Animation::local_duration(this, a3);
  v16 = *(float *)&v21;
  v23 = *((_DWORD *)this + 3);
  if ((v23 & 0x400) != 0
    && (v13 = v14
            - (float)((float)(*(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8)))
                    * *((float *)this + 7)),
        v13 > 0.0))
  {
    v24 = RB::Symbol::Animation::outro_duration(this, v20);
    v16 = v24;
    if (v13 >= v24)
      v13 = v24;
    v18 = 0.0;
    v17 = 2;
  }
  else
  {
    v18 = 0.0;
    v13 = v14;
    if ((v23 & 0x800) != 0)
    {
      v25 = *((float *)this + 7);
      *(float *)&v26 = *(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8));
      v27 = vrecpe_f32((float32x2_t)v26);
      v28 = vmul_f32(vrecps_f32((float32x2_t)v26, v27), v27);
      v22 = COERCE_DOUBLE(vmul_f32(v28, vrecps_f32((float32x2_t)v26, v28)));
      *(float *)&v22 = v14 * *(float *)&v22;
      if (v25 >= *(float *)&v22)
        v25 = *(float *)&v22;
      v18 = floorf(v25);
      v13 = (float)(*(float *)&v22 - v18)
          * (float)(*(float *)&v21 + (float)(*((float *)this + 6) * *((float *)this + 8)));
    }
    if ((v23 & 0x80) != 0)
    {
      v29 = *((_QWORD *)this + 9);
      if (v29)
      {
        *(float *)&v21 = v13 * *(float *)&v21;
        if ((float)(v13 * v16) < 0.0)
          *(float *)&v21 = 0.0;
        LODWORD(v22) = 1.0;
        if (*(float *)&v21 > 1.0)
          *(float *)&v21 = 1.0;
        if (*(_QWORD *)(v29 + 24))
          v30 = *(_QWORD *)(v29 + 24);
        else
          v30 = *((_QWORD *)this + 9);
        v40 = v16;
        RB::Animation::eval(v30, *(unsigned int *)(v29 + 32), (int32x2_t *)(v29 + 44), v21, v22);
        v16 = v40;
        v13 = v31;
      }
    }
    if (v13 >= v16)
    {
      if ((*((_BYTE *)this + 13) & 8) != 0)
      {
        v32 = *((float *)this + 8);
        if (v32 > 0.0)
        {
          v33 = (float32x2_t)*((unsigned int *)this + 6);
          v34 = vrecpe_f32(v33);
          v35 = vmul_f32(vrecps_f32((float32x2_t)v33.u32[0], v34), v34);
          v11 = (float)((float)((float)(v16 + v14) - v13) + (float)(*((float *)this + 6) * v32))
              * vmul_f32(v35, vrecps_f32((float32x2_t)v33.u32[0], v35)).f32[0];
        }
      }
      v17 = 1;
      v13 = v16;
    }
    else
    {
      v17 = 1;
    }
  }
LABEL_38:
  v36 = 0.0;
  if (v13 >= 0.0)
    v36 = v13;
  if (v36 > v16)
    v36 = v16;
  *(float *)a5 = v36;
  *(float *)(a5 + 4) = v18;
  v37 = vrecpe_f32((float32x2_t)LODWORD(v16));
  v38 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v16), v37), v37);
  result = vmul_f32(v38, vrecps_f32((float32x2_t)LODWORD(v16), v38));
  *(_DWORD *)(a5 + 8) = result.i32[0];
  *(float *)(a5 + 12) = v11;
  *(_DWORD *)(a5 + 16) = v17;
  return result;
}

void *RB::Symbol::Animation::keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, int a4, RB::Symbol::Model *a5)
{
  uint64_t v5;
  int v6;
  int v8;
  unsigned int v9;
  void *v10;

  v5 = 0;
  v6 = *(_DWORD *)(a1 + 4);
  switch(v6)
  {
    case 0:
      return &RB::Symbol::Animation::variable_value_keyframes(void)const::keyframes;
    case 1:
      if (a4 == 1)
        return (void *)((uint64_t (*)(void))((char *)&loc_209B6CAB8 + 4
                                                                   * byte_209BD7544[(*(_DWORD *)(a1 + 12) >> 30) ^ 2]))();
      else
        return (void *)RB::Symbol::Animation::vc_intro_outro_keyframes(a1, (int)a2, this, a4);
    case 2:
      return (void *)RB::Symbol::Animation::pulse_keyframes(a1, (uint64_t)a2, this);
    case 3:
      return (void *)RB::Symbol::Animation::bounce_keyframes(a1, (uint64_t)a2, this, a4);
    case 4:
      return (void *)RB::Symbol::Animation::scale_keyframes(a1, a2, this);
    case 5:
    case 9:
      return (void *)RB::Symbol::Animation::appear_disappear_keyframes(a1, (_DWORD *)(v6 == 5), (uint64_t)a2, this);
    case 6:
      v8 = *(_DWORD *)(a1 + 12) & 0xE000000;
      v9 = (v8 - 0x2000000) >> 25;
      if (v9 - 2 >= 3)
      {
        if (v9 > 1)
          return (void *)RB::Symbol::Animation::replace_keyframes(a1, a2, this);
        v10 = &RB::Symbol::Animation::replace_slash_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::remove_keyframes;
        if (v8 != 0x4000000)
          v10 = 0;
        if (v8 == 0x2000000)
          return &RB::Symbol::Animation::replace_slash_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::add_keyframes;
        else
          return v10;
      }
      else
      {
        switch(v8)
        {
          case 100663296:
            return &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::add_keyframes;
          case 167772160:
            return &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::move_keyframes;
          case 134217728:
            return &RB::Symbol::Animation::replace_badge_keyframes(RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)const::remove_keyframes;
          default:
            return 0;
        }
      }
    case 10:
      return (void *)RB::Symbol::Animation::wiggle_keyframes(a1, (uint64_t)a2, this, a4, a5);
    case 11:
      return (void *)RB::Symbol::Animation::rotate_keyframes(a1, (uint64_t)a2, this, a4);
    case 12:
      return (void *)RB::Symbol::Animation::breathe_keyframes(a1, (uint64_t)a2, this);
    default:
      return (void *)v5;
  }
}

uint64_t RB::Symbol::Animation::layer_flagged(uint64_t a1, uint64_t a2, int a3)
{
  int v3;

  v3 = *(_DWORD *)(a1 + 4);
  if (v3 != 12)
  {
    if (v3 == 11)
    {
      if ((a3 & 0xFFFFFFFE) == 6)
        return *(_BYTE *)(a2 + 87) & 1;
      return 1;
    }
    if (v3 != 2)
      return 1;
  }
  if (a3 != 12)
    return 1;
  if (*(float *)(a2 + 72) > 0.0)
    return *(unsigned __int8 *)(a2 + 86) >> 7;
  else
    return 0;
}

uint64_t RB::Symbol::Animation::description@<X0>(uint64_t result@<X0>, int a2@<W1>, int a3@<W2>, char a4@<W3>, uint64_t a5@<X8>)
{
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;

  *(_QWORD *)a5 = 0;
  *(_DWORD *)(a5 + 8) = 0;
  *(_QWORD *)(a5 + 12) = 1065353216;
  *(_QWORD *)(a5 + 24) = 0;
  *(_DWORD *)(a5 + 20) = 1065353216;
  switch((int)result)
  {
    case 0:
      v5 = 262;
      goto LABEL_19;
    case 1:
      v6 = ~a3 & 0x604 | a2;
      *(_DWORD *)a5 = v6;
      v7 = a2 & 0xC0000000;
      if ((a2 & 0xC0000000) == 0x40000000 || !v7)
        goto LABEL_28;
      if (v7 != 0x80000000)
        return result;
      if ((a2 & 0x10000000) == 0 || (a4 & 1) != 0)
      {
LABEL_28:
        v12 = 1051372203;
LABEL_29:
        *(_DWORD *)(a5 + 16) = v12;
      }
      else
      {
        v8 = v6 | 0x40;
LABEL_20:
        *(_DWORD *)a5 = v8;
      }
      return result;
    case 2:
      *(_DWORD *)a5 = ~a3 & 0x14 | a2;
      *(_DWORD *)(a5 + 4) = 4100;
      *(_DWORD *)(a5 + 12) = 1077936128;
      return result;
    case 3:
      v11 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v11;
      *(_DWORD *)(a5 + 4) = 4104;
      if ((a2 & 0x20) == 0)
        return result;
      goto LABEL_23;
    case 4:
      v5 = 22;
      goto LABEL_19;
    case 5:
    case 9:
      v5 = 1073741845;
      goto LABEL_19;
    case 6:
      v5 = 1879048213;
      goto LABEL_19;
    case 7:
      v5 = 129;
LABEL_19:
      v8 = v5 & ~a3 | a2;
      goto LABEL_20;
    case 10:
      *(_QWORD *)(a5 + 24) = 1065353216;
      v11 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v11;
      *(_DWORD *)(a5 + 4) = 1024;
      if ((a2 & 0x20) == 0)
        goto LABEL_22;
LABEL_23:
      if ((v11 & 0x10) != 0)
        v13 = 67136;
      else
        v13 = 1536;
      v10 = v13 | v11;
      goto LABEL_27;
    case 11:
      v9 = ~a3 & 0x14 | a2;
      *(_DWORD *)a5 = v9;
      *(_DWORD *)(a5 + 4) = 2048;
      if ((a2 & 0x20) != 0)
      {
        v10 = v9 | 0x600;
LABEL_27:
        *(_DWORD *)a5 = v10;
        v12 = 2143289344;
      }
      else
      {
LABEL_22:
        v12 = 1065353216;
      }
      goto LABEL_29;
    case 12:
      *(_DWORD *)a5 = ~a3 & 0x14 | a2;
      *(_DWORD *)(a5 + 4) = 4108;
      return result;
    default:
      return result;
  }
}

uint64_t RB::Symbol::Animation::pulse_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this)
{
  unsigned int v5;
  int v6;
  float v7;
  __n128 v9;

  if (*(_BYTE *)(a2 + 24))
  {
    RB::Symbol::KeyframeStorage::clear((uint64_t)this);
    v5 = -1012;
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 12);
    RB::Symbol::KeyframeStorage::clear((uint64_t)this);
    if ((v6 & 0x10) != 0)
      v5 = -500;
    else
      v5 = -1012;
  }
  v9.n128_u64[0] = v5;
  v9.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
  RB::Symbol::KeyframeStorage::push_keyframes(this, &v9);
  if (*(int *)(a1 + 12) < 0)
    v7 = 0.5;
  else
    v7 = 1.0;
  RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v7);
  RB::Symbol::KeyframeStorage::push_value(this, 1, 0.0, v7);
  RB::Symbol::KeyframeStorage::push_value(this, 1.0);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::breathe_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this)
{
  int v6;
  unsigned int v7;
  float v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  float v12;
  unsigned int v13;
  unsigned int v14;
  float v15;
  unsigned int v16;
  __n128 v18;

  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  v6 = *(_DWORD *)(a1 + 12);
  v7 = *(_DWORD *)(a2 + 8);
  if ((v6 & 0x10) == 0)
    v7 = 1;
  if (v7 >= 2)
  {
    if ((float)(0.25 / (float)(v7 - 1)) <= 0.16667)
      v8 = 0.25 / (float)(v7 - 1);
    else
      v8 = 0.16667;
  }
  else
  {
    v8 = 0.0;
    if (!v7)
      return RB::Symbol::KeyframeStorage::commit(this);
  }
  v9 = 0;
  v10 = 0;
  v11 = v7 - 1;
  do
  {
    v12 = 3.0 - (float)((float)(v8 * (float)v10) + (float)(v8 * (float)v11));
    if ((*(_DWORD *)(a1 + 12) & 0x80000000) != 0)
    {
      v15 = v12 * 0.5;
      v13 = v9;
    }
    else
    {
      v13 = v10 << 10;
      v14 = (v9 + (((*(_BYTE *)(a2 + 24) & 1) == 0) << 9)) | 0xFFE0000C;
      if ((v6 & 0x10) == 0)
        v14 = -1012;
      v18.n128_u32[0] = v14;
      v18.n128_f32[1] = v8 * (float)v10;
      v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
      v15 = v12 * 0.5;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v15);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 0.0, v15);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    }
    v16 = v13 | 0xFFE00202;
    if ((v6 & 0x10) == 0)
      v16 = -1022;
    v18.n128_u32[0] = v16;
    v18.n128_f32[1] = v8 * (float)v10;
    v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
    RB::Symbol::KeyframeStorage::push_value(this, 2, 1.0, v15);
    RB::Symbol::KeyframeStorage::push_value(this, 2, 1.2, v15);
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    v9 += 1024;
    --v11;
    ++v10;
  }
  while (v11 != -1);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_intro_outro_keyframes(int a1, int a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  uint64_t v6;
  float v7;
  float v8;
  __n128 v10;

  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  v6 = (2 * *((unsigned int *)this + 194)) | 1;
  v10.n128_u64[0] = 4294966282;
  v10.n128_u64[1] = v6;
  RB::Symbol::KeyframeStorage::push_keyframes(this, &v10);
  if (a4)
    v7 = 1.0;
  else
    v7 = 0.0;
  if (a4)
    v8 = 0.0;
  else
    v8 = 1.0;
  RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
  RB::Symbol::KeyframeStorage::push_value(this, v8);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_cumulative_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v6;
  float v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  float v11;
  float v12;
  float32x2_t v13;
  float32x2_t v14;
  unsigned int v15;
  unsigned int v16;
  float v17;
  __n128 v19;

  v6 = a2[5];
  v7 = 0.0;
  if ((*(_BYTE *)(a1 + 15) & 0x20) == 0)
  {
    if (*a2 == 3)
      v7 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
    else
      v7 = 0.3;
  }
  v8 = 4193288;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  v9 = v6 - 1;
  if (v6 > 1)
  {
    if (v6 == 2)
      v11 = 0.66667;
    else
      v11 = 1.0;
    v12 = 0.33333;
    if (v6 >= 4)
    {
      v13 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9));
      v14 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v13), v13);
      v12 = (float)(v11 + -0.33333) * vmul_f32(v14, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v14)).f32[0];
    }
    v15 = 0;
    do
    {
      *(float *)&v16 = v12 * (float)v15;
      v17 = v11 - *(float *)&v16;
      ++v15;
      v19.n128_u64[0] = __PAIR64__(v16, v8);
      v19.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v19);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, v17);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v7);
      v8 += 0x200000;
    }
    while (v6 != v15);
  }
  else
  {
    if (v6)
      v10 = 4193288;
    else
      v10 = -1023;
    v19.n128_u64[0] = v10;
    v19.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v19);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, v7);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_cumulative_bounce_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v6;
  float v7;
  unsigned __int32 v8;
  unsigned int v9;
  unsigned int v10;
  float v11;
  float32x2_t v12;
  float32x2_t v13;
  unsigned int v14;
  int v15;
  unsigned int v16;
  __n128 v18;

  v6 = a2[5];
  v7 = 0.0;
  if ((*(_BYTE *)(a1 + 15) & 0x20) == 0)
  {
    if (*a2 == 3)
      v7 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
    else
      v7 = 0.3;
  }
  v8 = 4193288;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  v9 = v6 - 1;
  if (v6 > 1)
  {
    v11 = 0.33333;
    if (v6 >= 4)
    {
      v12 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9));
      v13 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v12), v12);
      v11 = 0.66667 * vmul_f32(v13, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v9), v13)).f32[0];
    }
    v14 = 0;
    v15 = -1;
    do
    {
      v16 = v14 + 1;
      v18.n128_u32[0] = v8;
      v18.n128_f32[1] = v11 * (float)v14;
      v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, (float)((float)(v11 + v11) * (float)(v6 + v15)) + 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v7);
      v8 += 0x200000;
      --v15;
      v14 = v16;
    }
    while (v6 != v16);
  }
  else
  {
    if (v6)
      v10 = 4193288;
    else
      v10 = -1023;
    v18.n128_u64[0] = v10;
    v18.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v18);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v7, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, v7);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_sequential_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  int v8;
  float v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  int v15;
  float v16;
  int v17;
  int v18;
  unsigned int v19;
  int v20;
  int v21;
  float v22;
  unsigned int v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;
  unsigned int v27;
  unsigned int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  __n128 v36;

  v8 = *(_DWORD *)(a1 + 12);
  v9 = 0.0;
  if ((v8 & 0x20000000) == 0)
  {
    if (*a2 == 3)
    {
      v9 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
      v8 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      v9 = 0.3;
    }
  }
  v10 = a2[5];
  v11 = v8 & 0x10000040;
  if ((v8 & 0x10000040) == 0x10000000)
    v12 = v10 + 1;
  else
    v12 = v10;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v12 > 3)
  {
    v22 = (float)((float)(2 * v12 - 8) * 0.016667) + 0.33333;
    *(float *)&v23 = v22 + (float)((float)v12 * 0.083333);
    v24 = vrecpe_f32((float32x2_t)v23);
    v25 = vmul_f32(vrecps_f32((float32x2_t)v23, v24), v24);
    v25.f32[0] = vmul_f32(v25, vrecps_f32((float32x2_t)v23, v25)).f32[0];
    v16 = 0.11111 * v25.f32[0];
    v26 = (float)(v22 * 1.3333) * v25.f32[0];
    if ((*(_BYTE *)(a1 + 12) & 0x40) != 0)
    {
      v34 = (2 * *((unsigned int *)this + 194)) | 1;
      v36.n128_u64[0] = 4294966280;
      v36.n128_u64[1] = v34;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
    }
    else
    {
      v27 = 0;
      v28 = v12 - 1;
      do
      {
        if (v28 == v27)
          v29 = 2096137;
        else
          v29 = 2096136;
        if (v28 == v27)
          v30 = 1;
        else
          v30 = v27 + 1;
        v31 = v27 + 1;
        if (v11 == 0x10000000)
        {
          v32 = v30;
        }
        else
        {
          v29 = 2096136;
          v32 = v27 + 1;
        }
        v36.n128_u32[0] = v29 | (v32 << 21);
        v36.n128_f32[1] = v16 * (float)v27;
        v36.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
        v27 = v31;
      }
      while (v31 != v12);
    }
  }
  else
  {
    if ((*(_BYTE *)(a1 + 12) & 0x40) != 0)
    {
      v33 = (2 * *((unsigned int *)this + 194)) | 1;
      v36.n128_u64[0] = 4294966280;
      v36.n128_u64[1] = v33;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
      v16 = 0.33333;
    }
    else
    {
      v13 = 0;
      v14 = v12 - 1;
      if (v12 <= 1)
        v15 = 1;
      else
        v15 = v12;
      v16 = 0.33333;
      do
      {
        if (v12)
        {
          if (v14 == v13)
            v17 = 2096137;
          else
            v17 = 2096136;
          if (v14 == v13)
            v18 = 1;
          else
            v18 = v13 + 1;
          v19 = v13 + 1;
          if (v11 == 0x10000000)
            v20 = v17;
          else
            v20 = 2096136;
          if (v11 == 0x10000000)
            v21 = v18;
          else
            v21 = v13 + 1;
        }
        else
        {
          v19 = v13 + 1;
          v21 = 2047;
          v20 = 2096129;
        }
        v36.n128_u32[0] = v20 | (v21 << 21);
        v36.n128_f32[1] = (float)v13 * 0.33333;
        v36.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v36);
        v13 = v19;
      }
      while (v19 != v15);
    }
    v26 = 0.33333;
  }
  RB::Symbol::KeyframeStorage::push_value(this, 1, v9, v16);
  RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v26);
  RB::Symbol::KeyframeStorage::push_value(this, v9);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::vc_sequential_bounce_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this, RB::Symbol::Model *a4, float a5)
{
  unsigned int v7;
  float v8;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  int v16;
  unsigned int v17;
  int v18;
  float v19;
  float v20;
  int v21;
  int v22;
  int v23;
  float v24;
  float v25;
  float v26;
  unsigned int v27;
  float v28;
  unsigned int v29;
  float32x2_t v30;
  float32x2_t v31;
  float v32;
  float v33;
  unsigned int v34;
  float v35;
  int v36;
  int v37;
  float v38;
  float v39;
  RB::Symbol::KeyframeStorage *v40;
  float v41;
  int v42;
  float v43;
  float v45;
  __n128 v46;

  v7 = *(_DWORD *)(a1 + 12);
  v8 = 0.0;
  if ((v7 & 0x20000000) == 0)
  {
    if (*a2 == 3)
    {
      v8 = RB::Symbol::Model::alpha(a4, 2uLL, a5);
      v7 = *(_DWORD *)(a1 + 12);
    }
    else
    {
      v8 = 0.3;
    }
  }
  v10 = a2[5];
  v11 = (v7 >> 28) & 1;
  v12 = v11 + v10;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  v13 = v12 - 2;
  if (v12 <= 2)
  {
    v14 = 0;
    v15 = v12 - 1;
    do
    {
      v16 = v14;
      if (v12)
      {
        if (v11)
        {
          if (v15 == v14)
            v17 = 2096137;
          else
            v17 = 2096136;
          ++v14;
          if (v15 == v16)
            v18 = 1;
          else
            v18 = v16 + 1;
        }
        else
        {
          ++v14;
          v17 = 2096136;
          v18 = v16 + 1;
        }
      }
      else
      {
        ++v14;
        v18 = 2047;
        v17 = 2096129;
      }
      v46.n128_u64[0] = v17 | (unint64_t)(v18 << 21);
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      if (v16)
        v19 = v8;
      else
        v19 = 1.0;
      if (v16)
        v20 = 1.0;
      else
        v20 = v8;
      RB::Symbol::KeyframeStorage::push_value(this, 1, v19, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v20, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v19);
    }
    while (v12 && !v16);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  if (v12 == 3)
  {
    v21 = 0;
    while (1)
    {
      if (v11)
      {
        v22 = v21 == 2 ? 2096137 : 2096136;
        v23 = v21 == 2 ? 1 : v21 + 1;
      }
      else
      {
        v23 = v21 + 1;
        v22 = 2096136;
      }
      v46.n128_u32[0] = v22 | (v23 << 21);
      v24 = v21 == 2 ? 0.33333 : 0.0;
      v46.n128_f32[1] = v24;
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      if (v21 == 1)
        break;
      if (v21)
      {
        RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
        v26 = 1.0;
        goto LABEL_44;
      }
      v25 = 1.0;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, 0, v8, 0.66667);
      v26 = v8;
LABEL_45:
      RB::Symbol::KeyframeStorage::push_value(this, 1, v26, 0.33333);
      RB::Symbol::KeyframeStorage::push_value(this, v25);
      if (++v21 == 3)
        return RB::Symbol::KeyframeStorage::commit(this);
    }
    RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
    v26 = 1.0;
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.33333);
    RB::Symbol::KeyframeStorage::push_value(this, 1, v8, 0.33333);
LABEL_44:
    v25 = v8;
    goto LABEL_45;
  }
  v27 = 0;
  v28 = (float)((float)(2 * v12 - 8) * 0.016667) + 0.33333;
  *(float *)&v29 = (float)(v28 + (float)((float)v13 * 0.083333)) + (float)(v28 + (float)((float)v13 * 0.083333));
  v30 = vrecpe_f32((float32x2_t)v29);
  v31 = vmul_f32(vrecps_f32((float32x2_t)v29, v30), v30);
  v31.f32[0] = vmul_f32(v31, vrecps_f32((float32x2_t)v29, v31)).f32[0];
  v32 = 0.20833 * v31.f32[0];
  v33 = (float)(v28 * 2.5) * v31.f32[0];
  v34 = v12 - 1;
  v35 = 0.41667 * v31.f32[0];
  v45 = v33 - (float)(0.20833 * v31.f32[0]);
  do
  {
    if (v11)
    {
      if (v13 == -1)
        v36 = 2096137;
      else
        v36 = 2096136;
      if (v13 == -1)
        v37 = 1;
      else
        v37 = v27 + 1;
    }
    else
    {
      v37 = v27 + 1;
      v36 = 2096136;
    }
    v46.n128_u32[0] = v36 | (v37 << 21);
    v38 = (float)v27 + -1.0;
    if (v38 < 0.0)
      v38 = 0.0;
    v46.n128_f32[1] = v38 * v32;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    if (v27)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 1, v8, v32);
      v39 = 1.0;
      v40 = this;
      if (v27 >= v34)
      {
        v41 = v45;
        v42 = 0;
      }
      else
      {
        RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
        RB::Symbol::KeyframeStorage::push_value(this, 0, v8, v35 * (float)v13);
        v40 = this;
        v39 = v8;
        v41 = v32;
        v42 = 1;
      }
      RB::Symbol::KeyframeStorage::push_value(v40, v42, v39, v41);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
      v43 = v8;
    }
    else
    {
      v43 = 1.0;
      RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, v33);
      RB::Symbol::KeyframeStorage::push_value(this, 0, v8, v35 * (float)v13);
      RB::Symbol::KeyframeStorage::push_value(this, 1, v8, v32);
    }
    RB::Symbol::KeyframeStorage::push_value(this, v43);
    ++v27;
    --v13;
  }
  while (v13 != -2);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::bounce_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  int v8;
  int v9;
  unsigned int v10;
  float v11;
  float v12;
  _BOOL4 v13;
  float v14;
  float v15;
  float v16;
  float v17;
  int v18;
  unsigned int v19;
  float v20;
  unsigned int v21;
  uint64_t v22;
  float v23;
  float v24;
  float v25;
  RB::Symbol::KeyframeStorage *v26;
  __n128 v28;

  v8 = *(_DWORD *)(a1 + 12);
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if ((v8 & 0x20) != 0)
  {
    v22 = (2 * *((unsigned int *)this + 194)) | 1;
    v28.n128_u64[0] = 4294966274;
    v28.n128_u64[1] = v22;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v28);
    v23 = flt_209BD7458[v8 >= 0];
    if (a4 == 2)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 5, v23, 0.26667);
      v23 = 1.0;
    }
    else
    {
      v24 = flt_209BD7450[v8 >= 0];
      if (a4 == 1)
      {
        v26 = this;
        v25 = flt_209BD7458[v8 >= 0];
      }
      else
      {
        if (a4)
          return RB::Symbol::KeyframeStorage::commit(this);
        v25 = 1.0;
        v26 = this;
      }
      RB::Symbol::KeyframeStorage::push_value(v26, 3, v25, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 4, v24, 0.21667);
    }
    RB::Symbol::KeyframeStorage::push_value(this, v23);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  v9 = *(_DWORD *)(a1 + 12);
  if ((v9 & 0x10) != 0)
    v10 = *(_DWORD *)(a2 + 8);
  else
    v10 = 1;
  v11 = (float)(v10 - 1);
  v12 = 0.0;
  if (v10 >= 2)
  {
    v12 = 0.15 / v11;
    if ((float)(0.15 / v11) > 0.05)
      v12 = 0.05;
  }
  v13 = v8 >= 0;
  v14 = v12 * v11;
  if (v8 < 0)
    v15 = -v12;
  else
    v15 = v12;
  if (v8 < 0)
    v16 = v14;
  else
    v16 = 0.0;
  if (v8 < 0)
    v17 = 0.75;
  else
    v17 = 1.25;
  if (v10)
  {
    v18 = 0;
    v19 = 0;
    v20 = flt_209BD7460[v13];
    do
    {
      v21 = v18 | 0xFFE00002;
      if ((v9 & 0x10) == 0)
        v21 = -1022;
      v28.n128_u32[0] = v21;
      v28.n128_f32[1] = v16 + (float)(v15 * (float)v19);
      v28.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v28);
      RB::Symbol::KeyframeStorage::push_value(this, 3, 1.0, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 4, v17, 0.21667);
      RB::Symbol::KeyframeStorage::push_value(this, 5, v20, 0.26667 - (float)(v16 + (float)(v15 * (float)v19)));
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      ++v19;
      v18 += 1024;
    }
    while (v10 != v19);
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::wiggle_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4, RB::Symbol::Model *a5)
{
  int v8;
  unsigned int v9;
  int v10;
  unsigned int v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;
  float v23;
  float v24;
  int v25;
  unsigned int i;
  int v27;
  float v28;
  float v29;
  RB::Symbol::KeyframeStorage *v30;
  int v31;
  RB::Symbol::KeyframeStorage *v32;
  float v33;
  float v34;
  int v35;
  __n128 v37;

  v8 = *(_DWORD *)(a1 + 12);
  if ((v8 & 0x10) != 0)
    v9 = *(_DWORD *)(a2 + 8);
  else
    v9 = 1;
  if ((v8 & 0x10) != 0)
    v10 = 7;
  else
    v10 = 6;
  if (v8 < 0)
    v11 = v10;
  else
    v11 = 5;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if ((v8 & 0x20) != 0)
  {
    v37.n128_u64[0] = v11 | 0xFFFFFC00;
    v37.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v37);
    if (v8 < 0)
    {
      v20 = 0.087266;
      v19 = -0.087266;
    }
    else
    {
      v18 = *(float *)(RB::Symbol::Model::glyph_info(a5) + 32);
      v19 = v18 * -0.025;
      v20 = v18 * 0.025;
    }
    if ((v8 & 0x40000000) != 0)
      v28 = -v19;
    else
      v28 = v19;
    if ((v8 & 0x40000000) != 0)
      v29 = -v20;
    else
      v29 = v20;
    if (a4 == 2)
    {
      RB::Symbol::KeyframeStorage::push_value(this, 8, 0.0, 0.083333);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v29, 0.16667);
      v32 = this;
      v33 = v28;
      v34 = 0.16667;
      v35 = 7;
    }
    else
    {
      if (a4 == 1)
      {
        v30 = this;
        v31 = 8;
      }
      else
      {
        if (a4)
          return RB::Symbol::KeyframeStorage::commit(this);
        v30 = this;
        v31 = 7;
      }
      RB::Symbol::KeyframeStorage::push_value(v30, v31, 0.0, 0.083333);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v29, 0.16667);
      v32 = this;
      v33 = v28;
      v34 = 0.083333;
      v35 = 9;
    }
    RB::Symbol::KeyframeStorage::push_value(v32, v35, v33, v34);
    RB::Symbol::KeyframeStorage::push_value(this, 0.0);
    return RB::Symbol::KeyframeStorage::commit(this);
  }
  v12 = 0.0;
  if (v9 >= 2)
  {
    if ((float)(0.15 / (float)(v9 - 1)) <= 0.05)
      v12 = 0.15 / (float)(v9 - 1);
    else
      v12 = 0.05;
  }
  if (v8 < 0)
  {
    v17 = -0.087266;
    v16 = 0.10472;
    v15 = -0.13963;
    v14 = 0.17453;
  }
  else
  {
    v13 = *(float *)(RB::Symbol::Model::glyph_info(a5) + 32);
    v14 = v13 * 0.06;
    v15 = v13 * -0.04;
    v16 = v13 * 0.03;
    v17 = v13 * -0.025;
  }
  if ((v8 & 0x40000000) != 0)
    v21 = -v14;
  else
    v21 = v14;
  if ((v8 & 0x40000000) != 0)
    v22 = -v15;
  else
    v22 = v15;
  if ((v8 & 0x40000000) != 0)
    v23 = -v16;
  else
    v23 = v16;
  if ((v8 & 0x40000000) != 0)
    v24 = -v17;
  else
    v24 = v17;
  if (v9)
  {
    v25 = 0;
    for (i = 0; i != v9; ++i)
    {
      if ((v8 & 0x10) != 0)
        v27 = v25;
      else
        v27 = 2096128;
      v37.n128_u32[0] = v11 | v27 | 0xFFE00000;
      v37.n128_f32[1] = v12 * (float)i;
      v37.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v37);
      RB::Symbol::KeyframeStorage::push_value(this, 6, 0.0, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v21, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v22, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v23, 0.167);
      RB::Symbol::KeyframeStorage::push_value(this, 7, v24, 0.267 - (float)(v12 * (float)i));
      RB::Symbol::KeyframeStorage::push_value(this, 0.0);
      v25 += 1024;
    }
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::rotate_keyframes(uint64_t a1, uint64_t a2, RB::Symbol::KeyframeStorage *this, int a4)
{
  int v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  int v10;
  float v11;
  float v12;
  float v13;
  unsigned int v14;
  float v15;
  float v16;
  int v17;
  int v18;
  __int16 v19;
  float v20;
  RB::Symbol::KeyframeStorage *v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  __n128 v27;

  v6 = *(_DWORD *)(a1 + 12);
  v7 = 6;
  if (*(_BYTE *)(a2 + 25))
  {
    LOBYTE(v8) = 0;
    v9 = 1;
  }
  else
  {
    v8 = (*(_DWORD *)(a1 + 12) & 0x10u) >> 4;
    if ((v6 & 0x10) != 0)
      v7 = 7;
    else
      v7 = 6;
    if ((v6 & 0x10) != 0)
      v9 = *(_DWORD *)(a2 + 8);
    else
      v9 = 1;
  }
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v6 >= 0)
    v10 = 2;
  else
    v10 = -2;
  v11 = (float)v10 * 3.1416;
  if ((v6 & 0x20) != 0)
  {
    if (!a4 && v9 >= 2)
    {
      v14 = 0;
      if ((float)(0.25 / (float)(v9 - 1)) <= 0.083333)
        v15 = 0.25 / (float)(v9 - 1);
      else
        v15 = 0.083333;
      v16 = (float)v10 * 0.52971;
      v17 = 512;
      do
      {
        if ((v8 & 1) != 0)
          v18 = v17;
        else
          v18 = 2096128;
        v27.n128_u32[0] = v7 | v18 | 0xFFE00000;
        v27.n128_f32[1] = v15 * (float)v14;
        v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
        RB::Symbol::KeyframeStorage::push_value(this, 11, 0.0, 0.66667);
        RB::Symbol::KeyframeStorage::push_value(this, 12, v16, 1.8333 - (float)(v15 * (float)v14));
        RB::Symbol::KeyframeStorage::push_value(this, v11);
        ++v14;
        v17 += 1024;
      }
      while (v9 != v14);
      return RB::Symbol::KeyframeStorage::commit(this);
    }
    if ((v8 & 1) != 0)
      v19 = 512;
    else
      v19 = 0;
    v27.n128_u64[0] = (unsigned __int16)(v7 | v19) | 0xFFFFFC00;
    v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
    if (a4 == 2)
    {
      v20 = 2.5;
      v21 = this;
      v22 = 13;
    }
    else if (a4 == 1)
    {
      v20 = 2.0;
      v21 = this;
      v22 = 12;
    }
    else
    {
      if (a4)
      {
LABEL_49:
        RB::Symbol::KeyframeStorage::push_value(this, v11);
        return RB::Symbol::KeyframeStorage::commit(this);
      }
      v20 = 2.5;
      v21 = this;
      v22 = 11;
    }
    RB::Symbol::KeyframeStorage::push_value(v21, v22, 0.0, v20);
    goto LABEL_49;
  }
  if (v9 >= 2)
  {
    if (v9 == 2)
    {
      v12 = 0.13333;
      v13 = 1.8667;
    }
    else
    {
      if ((float)(0.26667 / (float)(v9 - 1)) <= 0.13333)
        v12 = 0.26667 / (float)(v9 - 1);
      else
        v12 = 0.13333;
      v13 = 1.7333;
    }
  }
  else
  {
    if (!v9)
      return RB::Symbol::KeyframeStorage::commit(this);
    v12 = 0.0;
    v13 = 2.0;
  }
  v23 = 0;
  v24 = 512;
  do
  {
    if ((v8 & 1) != 0)
      v25 = v24;
    else
      v25 = 2096128;
    v27.n128_u32[0] = v7 | v25 | 0xFFE00000;
    v27.n128_f32[1] = v12 * (float)v23;
    v27.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v27);
    RB::Symbol::KeyframeStorage::push_value(this, 10, 0.0, v13);
    RB::Symbol::KeyframeStorage::push_value(this, v11);
    ++v23;
    v24 += 1024;
  }
  while (v9 != v23);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::scale_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  int v4;
  int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int v14;
  int v15;
  int v16;
  unsigned int i;
  unsigned int v18;
  __n128 v20;

  v4 = a2[7];
  v5 = a2[8];
  if (v4 >= v5)
  {
    if (v4 <= v5)
      return 0;
    if (v4 > 0)
      v6 = 2;
    else
      v6 = 3;
  }
  else
  {
    v6 = v5 > 0;
  }
  v7 = *(_DWORD *)(a1 + 12);
  if ((v7 & 0x10) != 0)
    v8 = a2[2];
  else
    v8 = 1;
  v9 = 0.0;
  if (v8 >= 2)
  {
    v9 = 0.15 / (float)(v8 - 1);
    if (v9 > 0.05)
      v9 = 0.05;
  }
  if (v6 <= 1)
    v10 = 0.0;
  else
    v10 = -v9;
  if (v6 <= 1)
    v11 = 0.0;
  else
    v11 = v9 * (float)(v8 - 1);
  if (v6 <= 1)
    v12 = v9;
  else
    v12 = 0.0;
  if (v6 <= 1)
    v13 = -(float)((float)(v9 * (float)(v8 - 1)) + -0.25);
  else
    v13 = 0.25;
  if (v6 == 3)
    v14 = 39;
  else
    v14 = 1;
  if (v6)
    v15 = v14;
  else
    v15 = 38;
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  if (v8)
  {
    v16 = 0;
    for (i = 0; i != v8; ++i)
    {
      v18 = v16 | 0xFFE00003;
      if ((v7 & 0x10) == 0)
        v18 = -1021;
      v20.n128_u32[0] = v18;
      v20.n128_f32[1] = v11 + (float)(v10 * (float)i);
      v20.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v20);
      RB::Symbol::KeyframeStorage::push_value(this, v15, 0.0, (float)(v13 + (float)(v12 * (float)i)) - (float)(v11 + (float)(v10 * (float)i)));
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      v16 += 1024;
    }
  }
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::appear_disappear_keyframes(uint64_t a1, _DWORD *a2, uint64_t a3, RB::Symbol::KeyframeStorage *this)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  RB::Symbol::Animation::make_appear_disappear_keyframes(a2, *(_DWORD *)(a1 + 12), a3, this);
  return RB::Symbol::KeyframeStorage::commit(this);
}

uint64_t RB::Symbol::Animation::replace_keyframes(uint64_t a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  RB::Symbol::KeyframeStorage::clear((uint64_t)this);
  RB::Symbol::Animation::make_replace_keyframes(*(_DWORD *)(a1 + 12), a2, this);
  return RB::Symbol::KeyframeStorage::commit(this);
}

_DWORD *RB::Symbol::Animation::make_appear_disappear_keyframes(_DWORD *result, int a2, uint64_t a3, RB::Symbol::KeyframeStorage *this)
{
  char v6;
  unsigned int v7;
  unsigned int v8;
  float v9;
  unsigned int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  unsigned int v15;
  float v16;
  float v17;
  float v18;
  int v19;
  unsigned int v20;
  float v21;
  float v22;
  float v23;
  float v24;
  float v25;
  int v26;
  float v27;
  float v28;
  int v29;
  float v30;
  float v31;
  __n128 v32;

  v6 = a2;
  v7 = a2 & 0xC0000000;
  if ((a2 & 0x10) != 0)
    v8 = *(_DWORD *)(a3 + 8);
  else
    v8 = 1;
  if ((_DWORD)result)
    v9 = 0.25;
  else
    v9 = 0.16667;
  v10 = v8 - 1;
  if (v8 > 1)
  {
    v12 = 0.05;
    if (!(_DWORD)result)
      v12 = 0.033333;
    v13 = 0.15;
    if (!(_DWORD)result)
      v13 = 0.1;
    v11 = (float)v10;
    v14 = v13 / (float)v10;
    if (v12 >= v14)
      v12 = v14;
  }
  else
  {
    v11 = (float)v10;
    v12 = 0.0;
  }
  v15 = (v7 == 0x80000000) ^ result;
  v16 = v12 * v11;
  if (v15)
    v17 = v12;
  else
    v17 = -v12;
  if (v15)
    v18 = 0.0;
  else
    v18 = v16;
  if (v8)
  {
    v19 = 0;
    v20 = 0;
    v21 = 1.25;
    if (v7 != 0x80000000)
      v21 = 1.0;
    if (v7 == 0x40000000)
      v22 = 0.75;
    else
      v22 = v21;
    v23 = (float)(result ^ 1);
    v24 = (float)result;
    if ((_DWORD)result)
      v25 = v22;
    else
      v25 = 1.0;
    if ((_DWORD)result)
      v26 = 15;
    else
      v26 = 16;
    if ((_DWORD)result)
      v27 = 1.0;
    else
      v27 = v22;
    v30 = v27;
    v31 = v25;
    do
    {
      v28 = v18 + (float)(v17 * (float)v20);
      if ((v6 & 0x10) != 0)
        v29 = v19 & 0x1FFC00;
      else
        v29 = 2096128;
      v32.n128_u32[0] = v29 & 0xFFFFFF8F | (16 * (*(_DWORD *)(a3 + 4) & 7)) | 0xFFE0000D;
      v32.n128_f32[1] = v18 + (float)(v17 * (float)v20);
      v32.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v32);
      RB::Symbol::KeyframeStorage::push_value(this, 14, v23, v9 - v28);
      result = RB::Symbol::KeyframeStorage::push_value(this, v24);
      if (v22 != 1.0)
      {
        v32.n128_u32[0] = v29 | 0xFFE00002 | (16 * (*(_DWORD *)(a3 + 4) & 7));
        v32.n128_f32[1] = v18 + (float)(v17 * (float)v20);
        v32.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v32);
        RB::Symbol::KeyframeStorage::push_value(this, v26, v31, v9 - v28);
        result = RB::Symbol::KeyframeStorage::push_value(this, v30);
      }
      ++v20;
      v19 += 1024;
    }
    while (v8 != v20);
  }
  return result;
}

_DWORD *RB::Symbol::Animation::infer_replace_subtype(RB::Symbol::Model const&,RB::Symbol::Model const&)::$_1::operator()(_DWORD *result, _DWORD *a2, _DWORD *a3, unsigned int a4)
{
  uint64_t v4;
  unsigned int v5;
  uint64_t v8;
  _DWORD *v10;
  uint64_t v11;

  if (*((_QWORD *)result + 47))
    v4 = *((_QWORD *)result + 47);
  else
    v4 = (uint64_t)(result + 28);
  v5 = result[96];
  if (v5)
  {
    v8 = v4 + 88 * v5;
    do
    {
      if (RB::Symbol::Glyph::Layer::contains(v4, a4))
        v10 = a2;
      else
        v10 = a3;
      if (*(_QWORD *)(v4 + 40))
        v11 = *(_QWORD *)(v4 + 40);
      else
        v11 = v4 + 24;
      result = RB::Symbol::tags_merge(v10, v11, *(unsigned int *)(v4 + 48), a4);
      v4 += 88;
    }
    while (v4 != v8);
  }
  return result;
}

BOOL RB::vector<RB::Symbol::Tag,4ul,unsigned int>::operator==(uint64_t a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v2 != *(_DWORD *)(a2 + 24))
    return 0;
  if (*(_QWORD *)(a1 + 16))
    a1 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(a2 + 16))
    a2 = *(_QWORD *)(a2 + 16);
  return memcmp((const void *)a1, (const void *)a2, 4 * v2) == 0;
}

void RB::Symbol::Animation::make_replace_keyframes(int a1, _DWORD *a2, RB::Symbol::KeyframeStorage *this)
{
  char v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  float v10;
  float v11;
  float v12;
  float v13;
  int v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  int v20;
  unsigned int i;
  float v22;
  int v23;
  uint64_t v24;
  unsigned int v25;
  float v26;
  float v27;
  float v28;
  unsigned int v29;
  float v30;
  float v31;
  float v32;
  float v33;
  float v34;
  int v35;
  int v36;
  unsigned int v37;
  float v38;
  int v39;
  int v40;
  unsigned int j;
  float v42;
  float v43;
  int v44;
  float v45;
  __n128 v46;

  v5 = a1;
  v6 = a1 & 0xC0000000;
  if (a2[1] == 2)
    goto LABEL_42;
  if (v6 == -1073741824)
  {
    v8 = (2 * *((unsigned int *)this + 194)) | 1;
    v46.n128_u64[0] = 4294966301;
    v46.n128_u64[1] = v8;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    goto LABEL_6;
  }
  if (!v6)
  {
    v7 = (2 * *((unsigned int *)this + 194)) | 1;
    v46.n128_u64[0] = 4294966301;
    v46.n128_u64[1] = v7;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 1, 1.0, 0.166);
    RB::Symbol::KeyframeStorage::push_value(this, 0, 0.2, 0.0);
LABEL_6:
    RB::Symbol::KeyframeStorage::push_value(this, 0.0);
    goto LABEL_41;
  }
  if ((a1 & 0x10) != 0)
    v9 = a2[3];
  else
    v9 = 1;
  v10 = 0.0;
  if (v9 >= 2)
  {
    v10 = 0.15 / (float)(v9 - 1);
    if (v10 > 0.05)
      v10 = 0.05;
  }
  v11 = (float)(v9 - 1);
  v12 = -(float)((float)(v10 * v11) + -0.25);
  v13 = v10 * v11;
  if (v6 == 0x40000000)
    v14 = 17;
  else
    v14 = 19;
  if (v6 == 0x40000000)
    v15 = 0.5;
  else
    v15 = 1.25;
  if (v6 == 0x40000000)
    v16 = -v10;
  else
    v16 = 0.0;
  if (v6 == 0x40000000)
    v17 = v13;
  else
    v17 = 0.0;
  if (v6 == 0x40000000)
    v18 = 0.0;
  else
    v18 = v10;
  if (v6 == 0x40000000)
    v19 = 0.25;
  else
    v19 = v12;
  if (v9)
  {
    v20 = 0;
    for (i = 0; i != v9; ++i)
    {
      v22 = (float)(v19 + (float)(v18 * (float)i)) - (float)(v17 + (float)(v16 * (float)i));
      if ((v5 & 0x10) != 0)
        v23 = v20 & 0x1FFC00;
      else
        v23 = 2096128;
      v46.n128_u32[0] = v23 | 0xFFE00012;
      v46.n128_f32[1] = v17 + (float)(v16 * (float)i);
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, v14, 1.0, v22);
      RB::Symbol::KeyframeStorage::push_value(this, v15);
      if (v6 == 0x80000000)
      {
        v46.n128_u32[0] = v23 | 0xFFE0001D;
        v46.n128_f32[1] = v17 + (float)(v16 * (float)i);
        v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        RB::Symbol::KeyframeStorage::push_value(this, 19, 1.0, v22);
        RB::Symbol::KeyframeStorage::push_value(this, 0.0);
      }
      v20 += 1024;
    }
  }
  if (v6 == 0x40000000)
  {
    v46.n128_u64[0] = 0x3E800000FFFFFC1DLL;
    v46.n128_u64[1] = (unint64_t)&RB::Symbol::Animation::make_replace_keyframes(unsigned int,RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)::alpha_values;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
  }
LABEL_41:
  if (a2[1] == 1)
    return;
LABEL_42:
  if (v6 != -1073741824)
  {
    if (!v6)
    {
      v24 = (2 * *((unsigned int *)this + 194)) | 1;
      v46.n128_u64[0] = 0x3E29FBE7FFFFFC2DLL;
      v46.n128_u64[1] = v24;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, 0, 0.0, 0.0);
      RB::Symbol::KeyframeStorage::push_value(this, 1, 0.2, 0.166);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      return;
    }
    if (v6 == 0x40000000)
      v28 = 0.25;
    else
      v28 = 0.167;
    if ((v5 & 0x10) != 0)
      v29 = a2[4];
    else
      v29 = 1;
    v30 = 0.0;
    v31 = 0.0;
    if (v29 >= 2)
    {
      v31 = 0.15 / (float)(v29 - 1);
      if (v31 > 0.05)
        v31 = 0.05;
    }
    if (v6 == 0x40000000)
    {
      v32 = -(float)((float)(v31 * (float)(v29 - 1)) + -0.25);
      v33 = 0.0;
      v34 = 0.5;
      v35 = 18;
      v30 = v31;
      if (!v29)
      {
LABEL_80:
        if (v6 == 0x40000000)
        {
          v46.n128_u64[0] = 0x3E800000FFFFFC2DLL;
          v46.n128_u64[1] = (unint64_t)&RB::Symbol::Animation::make_replace_keyframes(unsigned int,RB::Symbol::Animation::KeyframesArgs const&,RB::Symbol::KeyframeStorage &)::alpha_values;
          RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        }
        return;
      }
    }
    else
    {
      v35 = 20;
      v32 = 0.333;
      v34 = 0.4;
      v33 = v31;
      if (!v29)
        goto LABEL_80;
    }
    v40 = 0;
    for (j = 0; j != v29; ++j)
    {
      v42 = v33 * (float)j;
      v43 = (float)(v32 + (float)(v30 * (float)j)) - v42;
      if ((v5 & 0x10) != 0)
        v44 = v40 & 0x1FFC00;
      else
        v44 = 2096128;
      v46.n128_u32[0] = v44 | 0xFFE00022;
      v45 = v42 + v28;
      v46.n128_f32[1] = v42 + v28;
      v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
      RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
      RB::Symbol::KeyframeStorage::push_value(this, v35, v34, v43);
      RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      if (v6 == 0x80000000)
      {
        v46.n128_u32[0] = v44 | 0xFFE0002D;
        v46.n128_f32[1] = v45;
        v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
        RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
        RB::Symbol::KeyframeStorage::push_value(this, 20, 0.0, v43);
        RB::Symbol::KeyframeStorage::push_value(this, 1.0);
      }
      v40 += 1024;
    }
    goto LABEL_80;
  }
  if ((v5 & 0x10) != 0)
    v25 = a2[4];
  else
    v25 = 1;
  v26 = (float)(v25 - 1);
  if (v25 >= 2)
  {
    if ((float)(0.15 / v26) <= 0.05)
      v27 = 0.15 / v26;
    else
      v27 = 0.05;
  }
  else
  {
    v27 = 0.0;
    if (!v25)
      return;
  }
  v36 = 0;
  v37 = 0;
  v38 = -(float)((float)(v27 * v26) + -0.25);
  do
  {
    if ((v5 & 0x10) != 0)
      v39 = v36 & 0x1FFC00;
    else
      v39 = 2096128;
    v46.n128_u64[0] = v39 & 0xFFFFFF8F | (16 * (a2[1] & 7)) | 0xFFE00002;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 21, 0.5, v38 + (float)(v27 * (float)v37));
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    v46.n128_u64[0] = v39 & 0xFFFFFF8F | (16 * (a2[1] & 7)) | 0xFFE0000DLL;
    v46.n128_u64[1] = (2 * *((unsigned int *)this + 194)) | 1;
    RB::Symbol::KeyframeStorage::push_keyframes(this, &v46);
    RB::Symbol::KeyframeStorage::push_value(this, 22, 0.0, v38 + (float)(v27 * (float)v37));
    RB::Symbol::KeyframeStorage::push_value(this, 1.0);
    ++v37;
    v36 += 1024;
  }
  while (v25 != v37);
}

float RB::Symbol::Animation::eval_appear_disappear(_DWORD *a1, int a2, _DWORD *a3, float a4)
{
  RB::Symbol::Keyframes *v6;
  double v7;
  RB::Symbol::Keyframes *v8;
  float v9;
  unsigned int v10;
  float v11;
  float v12;
  int v13;
  BOOL v14;
  _BOOL4 v15;
  float v16;
  unsigned int v17;
  uint64_t v19;
  int v20;
  _QWORD v21[2];
  int v22;
  int v23;
  _BYTE v24[768];
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v19 = 255;
  v20 = a3[1];
  v22 = 0;
  v23 = 0;
  v21[0] = 0;
  *(_QWORD *)((char *)v21 + 6) = 0;
  v25 = 0;
  v26 = 0x4000000000;
  v27 = 0;
  v28 = 0x4000000000;
  v29 = 0;
  RB::Symbol::Animation::make_appear_disappear_keyframes(a1, a2, (uint64_t)&v19, (RB::Symbol::KeyframeStorage *)v24);
  v6 = (RB::Symbol::Keyframes *)RB::Symbol::KeyframeStorage::commit((RB::Symbol::KeyframeStorage *)v24);
  v8 = v6;
  if (a4 >= 0.0001)
    v9 = a4;
  else
    v9 = 0.0001;
  v10 = *(_DWORD *)v6;
  if ((*(_DWORD *)v6 & 0xF) != 0)
  {
    v11 = 1.0;
    v12 = 1.0;
    do
    {
      if ((v10 & 0x1F0) == 0 && *((_QWORD *)v8 + 1))
      {
        v13 = (v10 >> 10) & 0x7FF;
        v14 = v13 == 2047 || v13 == *a3;
        v15 = v14;
        if (!((v10 + 0x200000) >> 22) && v15)
        {
          v16 = RB::Symbol::Keyframes::eval(v8, v9, (const RB::Symbol::KeyframeStorage *)v24, v7);
          if ((*(_DWORD *)v8 & 0xF) == 0xD)
            *(float *)&v7 = v16;
          else
            *(float *)&v7 = v12;
          if ((*(_DWORD *)v8 & 0xF) == 2)
            v11 = v16;
          else
            v12 = *(float *)&v7;
        }
      }
      v17 = *((_DWORD *)v8 + 4);
      v8 = (RB::Symbol::Keyframes *)((char *)v8 + 16);
      v10 = v17;
    }
    while ((v17 & 0xF) != 0);
  }
  else
  {
    v11 = 1.0;
  }
  if (v27)
    free(v27);
  if (v25)
    free(v25);
  return v11;
}

void sub_209B6F2A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::Symbol::KeyframeStorage::~KeyframeStorage((RB::Symbol::KeyframeStorage *)va);
  _Unwind_Resume(a1);
}

float RB::Symbol::Animation::eval_replace(int a1, int a2, _DWORD *a3, float a4)
{
  int v7;
  RB::Symbol::Keyframes *v8;
  double v9;
  RB::Symbol::Keyframes *v10;
  float v11;
  unsigned int v12;
  float v13;
  float v14;
  _BOOL4 v15;
  int v16;
  BOOL v17;
  _BOOL4 v18;
  float v19;
  unsigned int v20;
  _DWORD v22[6];
  __int16 v23;
  uint64_t v24;
  _BYTE v25[768];
  void *v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  char v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  v22[0] = 255;
  v22[1] = a1;
  v7 = a3[1];
  v22[2] = 1;
  v22[3] = v7;
  v22[4] = v7;
  v22[5] = 0;
  v23 = 0;
  v24 = 0;
  v26 = 0;
  v27 = 0x4000000000;
  v28 = 0;
  v29 = 0x4000000000;
  v30 = 0;
  RB::Symbol::Animation::make_replace_keyframes(a2, v22, (RB::Symbol::KeyframeStorage *)v25);
  v8 = (RB::Symbol::Keyframes *)RB::Symbol::KeyframeStorage::commit((RB::Symbol::KeyframeStorage *)v25);
  v10 = v8;
  if (a4 >= 0.0001)
    v11 = a4;
  else
    v11 = 0.0001;
  v12 = *(_DWORD *)v8;
  if ((*(_DWORD *)v8 & 0xF) != 0)
  {
    v13 = 1.0;
    v14 = 1.0;
    do
    {
      if (*((_QWORD *)v10 + 1))
      {
        v15 = ((v12 >> 4) & 7) == a1 || ((v12 >> 4) & 7) == 0;
        if ((v12 & 0x180) == 0 && v15)
        {
          v16 = (v12 >> 10) & 0x7FF;
          v17 = v16 == 2047 || v16 == *a3;
          v18 = v17;
          if (!((v12 + 0x200000) >> 22) && v18)
          {
            v19 = RB::Symbol::Keyframes::eval(v10, v11, (const RB::Symbol::KeyframeStorage *)v25, v9);
            if ((*(_DWORD *)v10 & 0xF) == 0xD)
              *(float *)&v9 = v19;
            else
              *(float *)&v9 = v14;
            if ((*(_DWORD *)v10 & 0xF) == 2)
              v13 = v19;
            else
              v14 = *(float *)&v9;
          }
        }
      }
      v20 = *((_DWORD *)v10 + 4);
      v10 = (RB::Symbol::Keyframes *)((char *)v10 + 16);
      v12 = v20;
    }
    while ((v20 & 0xF) != 0);
  }
  else
  {
    v13 = 1.0;
  }
  if (v28)
    free(v28);
  if (v26)
    free(v26);
  return v13;
}

void sub_209B6F468(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::Symbol::KeyframeStorage::~KeyframeStorage((RB::Symbol::KeyframeStorage *)va);
  _Unwind_Resume(a1);
}

void RB::`anonymous namespace'::defaults_key(RB::_anonymous_namespace_ *this@<X0>, CFStringRef *a2@<X8>)
{
  size_t v5;
  size_t v6;
  char *v7;
  char v8;
  unsigned __int8 *v9;
  char v10;
  char *v11;
  int v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  v5 = strlen((const char *)this);
  v6 = v5;
  if (v5 > 0x1000)
  {
    v7 = (char *)malloc_type_malloc(v5, 0xFAE9C67AuLL);
    if (!v7)
    {
      *a2 = 0;
LABEL_20:
      free(v7);
      return;
    }
  }
  else
  {
    MEMORY[0x24BDAC7A8]();
    v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  v8 = *(_BYTE *)this;
  if (*(_BYTE *)this)
  {
    v9 = (unsigned __int8 *)this + 1;
    v10 = 1;
    v11 = v7;
    while (1)
    {
      if ((v8 - 65) >= 0x1A)
      {
        if (v8 == 95)
        {
          v10 = 0;
          goto LABEL_12;
        }
      }
      else if ((v10 & 1) == 0)
      {
        if (*(v9 - 2) != 95)
          v8 += 32;
        v10 &= *(v9 - 2) == 95;
      }
      *v11++ = v8;
LABEL_12:
      v12 = *v9++;
      v8 = v12;
      if (!v12)
        goto LABEL_17;
    }
  }
  v11 = v7;
LABEL_17:
  *a2 = CFStringCreateWithBytes(0, (const UInt8 *)v7, v11 - v7, 0x8000100u, 1u);
  if (v6 > 0x1000)
    goto LABEL_20;
}

uint64_t RB::Config::BOOL_value(const __CFString *this, const void *a2)
{
  uint64_t v2;
  _BOOL4 v3;

  v2 = RB::Config::int_value(this, a2);
  if ((_DWORD)v2)
    v3 = (v2 & 0xFF00000000) != 0;
  else
    v3 = 0;
  return v3 | (((v2 & 0xFF00000000) != 0) << 8);
}

void RB::render_stroke_coverage(uint64_t a1, float64x2_t *a2, __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, int a5, float a6)
{
  uint64_t v10;
  _BOOL4 may_discard_shape;
  uint64_t (**v12[2])(_QWORD, _QWORD *);
  float v13;

  v10 = *(_DWORD *)(a1 + 136) == 2;
  v12[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C22A488;
  v12[1] = (uint64_t (**)(_QWORD, _QWORD *))(((a5 & 0x3F) << 6) | 0x11u | (unint64_t)(v10 << 33));
  v13 = a6;
  may_discard_shape = RB::may_discard_shape(a5);
}

void RB::render_stroke(uint64_t a1, uint64_t (**a2)(_QWORD, _QWORD *), __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, float32x2_t *a5, __int32 a6, int a7, float a8)
{
  _BOOL4 v16;
  int8x8_t v17;
  _BOOL4 may_discard_shape;
  uint64_t (**v19[4])(_QWORD, _QWORD *);
  float v20;
  uint64_t (**v21)(_QWORD, _QWORD *);

  v16 = *(_DWORD *)(a1 + 136) == 2;
  LODWORD(v21) = 19;
  HIDWORD(v21) = 2 * v16;
  RB::Fill::Gradient::set_fill_state(a5, (int *)&v21, a1, a8);
  v17.i32[0] = (a7 & 0x3F) << 6;
  v17.i32[1] = a6;
  v21 = (uint64_t (**)(_QWORD, _QWORD *))vorr_s8(vand_s8((int8x8_t)v21, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v17);
  v19[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C22A428;
  v19[1] = v21;
  v19[2] = a2;
  v19[3] = (uint64_t (**)(_QWORD, _QWORD *))a5;
  v20 = a8;
  may_discard_shape = RB::may_discard_shape(a7);
  *(_QWORD *)(a1 + 224) = 0;
  *(_DWORD *)(a1 + 220) = 0;
}

void RB::render_stroke(_QWORD *a1, uint64_t (**a2)(_QWORD, _QWORD *), __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, uint64_t (**a5)(_QWORD, _QWORD *), char a6, int a7, float a8)
{
  uint64_t (**v8[3])(_QWORD, _QWORD *);
  char v9;
  float v10;
  int v11;

  v8[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C223F40;
  v8[1] = a2;
  v8[2] = a5;
  v9 = a6;
  v10 = a8;
  v11 = a7;
}

void RB::render_stroke(uint64_t a1, float64x2_t *a2, __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, uint64_t (**a5)(_QWORD, _QWORD *), uint64_t a6, __int32 a7, int a8)
{
  _BOOL4 v15;
  int8x8_t v16;
  _BOOL4 may_discard_shape;
  uint64_t (**v18[3])(_QWORD, _QWORD *);
  uint64_t (**v19)(_QWORD, _QWORD *);

  v15 = *(_DWORD *)(a1 + 136) == 2;
  LODWORD(v19) = 21;
  HIDWORD(v19) = 2 * v15;
  RB::RenderState::set_image((int *)&v19, (uint64_t)a5 + 44, *(unsigned __int8 *)(a1 + 124));
  v16.i32[0] = (a8 & 0x3F) << 6;
  v16.i32[1] = a7;
  v19 = (uint64_t (**)(_QWORD, _QWORD *))vorr_s8(vand_s8((int8x8_t)v19, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v16);
  v18[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C22A440;
  v18[1] = v19;
  v18[2] = a5;
  may_discard_shape = RB::may_discard_shape(a8);
}

void RB::render_stroke(uint64_t **a1, uint64_t (**a2)(_QWORD, _QWORD *), __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, RB::Fill::Custom *this, __int32 a6, int a7, float a8)
{
  uint64_t *v16;
  uint64_t *v17;
  _BOOL4 v18;
  int8x8_t v19;
  _BOOL4 may_discard_shape;
  uint64_t (**v21[5])(_QWORD, _QWORD *);
  float v22;
  uint64_t (**v23)(_QWORD, _QWORD *);

  v16 = RB::Fill::Custom::function(this, a1);
  if (v16)
  {
    v17 = v16;
    v18 = *((_DWORD *)a1 + 34) == 2;
    LODWORD(v23) = 22;
    HIDWORD(v23) = 2 * v18;
    RB::Fill::Custom::set_fill_state(this, (RB::RenderState *)&v23, (Function *)v16, (unint64_t **)a1);
    v19.i32[0] = (a7 & 0x3F) << 6;
    v19.i32[1] = a6;
    v23 = (uint64_t (**)(_QWORD, _QWORD *))vorr_s8(vand_s8((int8x8_t)v23, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v19);
    v21[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C22A410;
    v21[1] = v23;
    v21[2] = a2;
    v21[3] = (uint64_t (**)(_QWORD, _QWORD *))this;
    v21[4] = (uint64_t (**)(_QWORD, _QWORD *))v17;
    v22 = a8;
    may_discard_shape = RB::may_discard_shape(a7);
    RB::Fill::Custom::reset_custom(this, (RB::RenderPass *)a1);
  }
}

void RB::`anonymous namespace'::StrokeLines::~StrokeLines(RB::_anonymous_namespace_::StrokeLines *this)
{
  unint64_t v2;

  if (*((_QWORD *)this + 15))
  {
    RB::RenderFrame::commit_buffer_region_size(***((_QWORD ***)this + 2), (uint64_t)this + 120, *((_QWORD *)this + 18));
    v2 = *((_QWORD *)this + 14);
    if (v2)
    {
      *((_QWORD *)this + 14) = 0;
      *((_BYTE *)this + 288) = 0;
    }
    *(_OWORD *)((char *)this + 120) = 0u;
    *(_OWORD *)((char *)this + 136) = 0u;
  }
}

double RB::`anonymous namespace'::StrokeLines::closepath(uint64_t a1, int a2)
{
}

uint64_t RB::`anonymous namespace'::StrokeLines::skipto(uint64_t result, _QWORD *a2, double a3)
{
  *(_BYTE *)(result + 176) = 0;
  *(_BYTE *)(result + 249) = 1;
  *(double *)(result + 256) = a3;
  *(_QWORD *)(result + 264) = *a2;
  return result;
}

__n128 RB::`anonymous namespace'::StrokeLines::push_back(uint64_t a1, __n128 *a2)
{
  unsigned int v2;
  BOOL v3;
  int v4;
  __n128 result;

  if (!*(_BYTE *)(a1 + 288))
  {
    v2 = a2->n128_i16[7] + 2;
    v3 = v2 > 4;
    v4 = (1 << v2) & 0x15;
    if (!v3 && v4 != 0)
      *(_BYTE *)(a1 + 288) = 1;
  }
  result = *a2;
  *(__n128 *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144)) = *a2;
  *(_QWORD *)(a1 + 144) += 16;
  return result;
}

void RB::`anonymous namespace'::StrokeLines::new_buffer(uint64_t a1, __n128 *a2)
{
  _QWORD *v3;
  uint64_t v4;
  __n128 *v5;
  __n128 *v6;
  unint64_t v7;
  uint64_t v8;
  __int128 v9;

  v3 = (_QWORD *)(a1 + 120);
  if (*(_QWORD *)(a1 + 112))
  {
    v4 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144);
    v5 = (__n128 *)(v4 - 16);
    v6 = (__n128 *)(v4 - 32);
    if (*(_QWORD *)(a1 + 192))
    {
      ++*(_QWORD *)(a1 + 112);
    }
  }
  else
  {
    v5 = 0;
    v6 = 0;
    if (!*v3)
      goto LABEL_9;
  }
  RB::RenderFrame::commit_buffer_region_size(***(_QWORD ***)(a1 + 16), (uint64_t)v3, *(_QWORD *)(a1 + 144));
  v7 = *(_QWORD *)(a1 + 112);
  if (v7)
  {
    if (*(_QWORD *)(a1 + 208))
    {
    }
    else
    {
      *(_QWORD *)(a1 + 208) = *(_QWORD *)(a1 + 120);
      *(_OWORD *)(a1 + 216) = *(_OWORD *)(a1 + 128);
      *(_QWORD *)(a1 + 232) = *(_QWORD *)(a1 + 184);
      *(_QWORD *)(a1 + 240) = v7;
      *(_BYTE *)(a1 + 248) = *(_BYTE *)(a1 + 288);
    }
  }
LABEL_9:
  RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)(a1 + 16), (RB::Device *)0x800, 4uLL, 1, &v8);
  *(_QWORD *)(a1 + 120) = v8;
  *(_OWORD *)(a1 + 128) = v9;
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 184) = -1;
  *(_BYTE *)(a1 + 288) = 0;
  if (v6)
  {
    if (v5)
    {
      *(_QWORD *)(a1 + 112) = 2;
    }
  }
}

float *RB::`anonymous namespace'::StrokeParticles::add_particle(float *this, unint64_t a2, float32x2_t a3, float32x2_t a4, float a5, float a6)
{
  float *v8;
  uint64_t v9;
  uint64_t v10;
  float32x4_t v15;
  uint64_t v16;
  int32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float v20;
  float v21;
  float32x2_t v22;
  float64x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  BOOL v27;
  float32x2_t v28;
  float v29;
  float v30;

  v8 = this;
  v9 = *((_QWORD *)this + 15);
  if (!v9 || (v10 = *((_QWORD *)this + 18), (unint64_t)(v10 + 20) > *((_QWORD *)this + 17)))
  {
    v29 = a6;
    v30 = a5;
    v28 = a4;
    a4 = v28;
    a6 = v29;
    a5 = v30;
    v10 = *((_QWORD *)v8 + 18);
    v9 = *((_QWORD *)v8 + 15);
  }
  _S0 = (float)a2;
  __asm { FCVT            H0, S0 }
  *(float32x2_t *)v15.f32 = a4;
  v15.i64[1] = __PAIR64__(LODWORD(a5), LODWORD(a6));
  v16 = *(_QWORD *)(v9 + 56) + *((_QWORD *)v8 + 16) + v10;
  *(double *)v16 = *(double *)&a3;
  *(float16x4_t *)(v16 + 8) = vcvt_f16_f32(v15);
  *(_WORD *)(v16 + 16) = LOWORD(_S0);
  *((_QWORD *)v8 + 18) += 20;
  ++*((_QWORD *)v8 + 14);
  v17 = (int32x2_t)vmul_f32(a4, a4);
  v17.i32[0] = vadd_f32((float32x2_t)v17, (float32x2_t)vdup_lane_s32(v17, 1)).u32[0];
  v18 = vrsqrte_f32((float32x2_t)v17.u32[0]);
  v17.i32[0] = vmul_f32(vrsqrts_f32((float32x2_t)v17.u32[0], vmul_f32(v18, v18)), v18).u32[0];
  v19 = vrecpe_f32((float32x2_t)v17.u32[0]);
  LODWORD(v20) = vmul_f32(vrecps_f32((float32x2_t)v17.u32[0], v19), v19).u32[0];
  if (a6 >= 1.0)
    v21 = a6;
  else
    v21 = 1.0;
  v22 = vmul_n_f32(*(float32x2_t *)(v8 + 20), (float)(v8[38] * v21) * v20);
  v23 = vcvtq_f64_f32(a3);
  *(float32x2_t *)&v23.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(v8 + 16), *(float64x2_t *)(v8 + 8), v23.f64[0]), *(float64x2_t *)(v8 + 12), v23, 1));
  v24 = vminnm_f32(*(float32x2_t *)(v8 + 24), vsub_f32(*(float32x2_t *)&v23.f64[0], v22));
  v25 = vmaxnm_f32(*(float32x2_t *)(v8 + 26), vadd_f32(v22, *(float32x2_t *)&v23.f64[0]));
  *((float32x2_t *)v8 + 12) = v24;
  *((float32x2_t *)v8 + 13) = v25;
  v27 = a5 != 1.0 || *((_BYTE *)v8 + 88) != 0;
  *((_BYTE *)v8 + 88) = v27;
  return this;
}

uint64_t RB::`anonymous namespace'::StrokeParticles::flush(uint64_t this, int a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  int v6;
  uint64_t v7;
  int v8;
  int32x2_t v9;
  int32x2_t *v10;
  float32x2_t v11;
  float32x2_t v12;
  uint32x2_t v13;
  int8x8_t v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  int32x2_t v20[2];

  v3 = this;
  if (*(_QWORD *)(this + 120))
  {
    this = RB::RenderFrame::commit_buffer_region_size(***(_QWORD ***)(this + 16), this + 120, *(_QWORD *)(this + 144));
    if (*(_QWORD *)(v3 + 112))
    {
      v5 = *(_DWORD *)(v3 + 24);
      v4 = *(unsigned int *)(v3 + 28);
      v6 = *(unsigned __int8 *)(v3 + 88);
      v7 = *(_QWORD *)(v3 + 16);
      v8 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v7, *(RB::Buffer **)(v3 + 120));
      v9.i32[0] = 0;
      *(_DWORD *)(v7 + 196) = v8;
      *(int32x2_t *)(v7 + 200) = vmovn_s64(*(int64x2_t *)(v3 + 128));
      v10 = *(int32x2_t **)(v3 + 16);
      v12 = *(float32x2_t *)(v3 + 96);
      v11 = *(float32x2_t *)(v3 + 104);
      v13 = (uint32x2_t)vcgt_f32(v11, v12);
      v14 = (int8x8_t)vdup_lane_s32(vcgt_s32(v9, (int32x2_t)vpmin_u32(v13, v13)), 0);
      RB::Bounds::Bounds(v20, (float32x2_t)vand_s8((int8x8_t)v12, v14), (float32x2_t)vand_s8((int8x8_t)vsub_f32(v11, v12), v14));
      LODWORD(v15) = v5 | 0x40000;
      if (v6)
        v15 = v15;
      else
        v15 = v5;
      this = (uint64_t)RB::RenderPass::draw_indexed_primitives(v10, (const char *)(v15 | (v4 << 32)), 4, ***(_QWORD ***)v10 + 80, 0, *(_QWORD *)(v3 + 112), v20[0], v20[1]);
      *(_QWORD *)(v3 + 112) = 0;
      *(_QWORD *)(v7 + 200) = 0;
      *(_DWORD *)(v7 + 196) = 0;
    }
  }
  if (a2)
  {
    this = (uint64_t)RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)(v3 + 16), (RB::Device *)0xA00, 4uLL, 1, &v18);
    v16 = v18;
    v17 = v19;
  }
  else
  {
    v16 = 0;
    v17 = 0uLL;
  }
  *(_QWORD *)(v3 + 120) = v16;
  *(_OWORD *)(v3 + 128) = v17;
  *(_QWORD *)(v3 + 144) = 0;
  return this;
}

void sub_209B6FE88(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

uint64_t RB::render_stroke_coverage(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  uint32x2_t v7;
  int8x8_t v8;
  RB::Buffer *v14;
  _OWORD *v15;
  __int128 v16;
  __int128 v18;
  __int128 v19;
  RB::Buffer *v20;
  int64x2_t v21;

  a5.i32[0] = 0;
  v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v18, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  _S0 = *(_DWORD *)(a1 + 16);
  __asm { FCVT            H0, S0 }
  WORD6(v19) = _S0;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x20, 4uLL, 0, &v20);
  v14 = v20;
  if (v20)
  {
    v15 = (_OWORD *)(*((_QWORD *)v20 + 7) + v21.i64[0]);
    v16 = v19;
    *v15 = v18;
    v15[1] = v16;
  }
  else
  {
    v20 = 0;
    v21 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v14);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v21);
  return *(_QWORD *)(a1 + 8);
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Gradient const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  uint32x2_t v7;
  int8x8_t v8;
  double v9;
  RB::Buffer *v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v17;
  _OWORD v18[4];
  int v19;
  RB::Buffer *v20;
  int64x2_t v21;

  a5.i32[0] = 0;
  v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v17, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  LODWORD(v9) = *(_DWORD *)(a1 + 32);
  RB::Fill::Gradient::set_gradient(*(float32x2_t **)(a1 + 24), (uint64_t)v18 + 12, a2, *(float64x2_t **)(a1 + 16), v9);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x54, 4uLL, 0, &v20);
  v10 = v20;
  if (v20)
  {
    v11 = *((_QWORD *)v20 + 7) + v21.i64[0];
    v12 = v17;
    *(_OWORD *)(v11 + 16) = v18[0];
    v13 = v18[3];
    v14 = v18[2];
    v15 = v18[1];
    *(_DWORD *)(v11 + 80) = v19;
    *(_OWORD *)(v11 + 48) = v14;
    *(_OWORD *)(v11 + 64) = v13;
    *(_OWORD *)(v11 + 32) = v15;
    *(_OWORD *)v11 = v12;
  }
  else
  {
    v20 = 0;
    v21 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v10);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v21);
  return *(_QWORD *)(a1 + 8);
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::MeshGradient const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, RB::RenderPass *a2, int32x2_t a3, int32x2_t a4)
{
  int32x2_t v6[2];

  v6[0] = a3;
  v6[1] = a4;
  RB::render_mesh_gradient(a2, *(float64x2_t **)(a1 + 8), *(int32x2_t **)(a1 + 16), 0, *(unsigned __int8 *)(a1 + 24), *(_DWORD *)(a1 + 32), v6, *(float *)(a1 + 28));
  if (*((_DWORD *)a2 + 34) == 2)
    return 0x200000026;
  else
    return 38;
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Shader::Globals<RB::Shader::StrokeGlobals,RB::Shader::ImageGlobals> &,RB::Fill::ImageData const&,BOOL,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  uint32x2_t v7;
  int8x8_t v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Buffer *v13;
  _OWORD *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v21;
  _BYTE v22[96];
  RB::Buffer *v23;
  int64x2_t v24;

  a5.i32[0] = 0;
  v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  RB::Coverage::set_plane((float32x2_t *)&v21, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  v9 = *(_QWORD *)(a1 + 16);
  v10 = *(_OWORD *)(v9 + 44);
  *(_OWORD *)&v22[28] = *(_OWORD *)(v9 + 60);
  v11 = *(_OWORD *)(v9 + 76);
  v12 = *(_OWORD *)(v9 + 92);
  *(_OWORD *)&v22[76] = *(_OWORD *)(v9 + 108);
  *(_OWORD *)&v22[60] = v12;
  *(_DWORD *)&v22[92] = *(_DWORD *)(v9 + 124);
  *(_OWORD *)&v22[44] = v11;
  *(_OWORD *)&v22[12] = v10;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x70, 4uLL, 0, &v23);
  v13 = v23;
  if (v23)
  {
    v14 = (_OWORD *)(*((_QWORD *)v23 + 7) + v24.i64[0]);
    v15 = *(_OWORD *)&v22[16];
    v16 = v21;
    v14[1] = *(_OWORD *)v22;
    v14[2] = v15;
    v17 = *(_OWORD *)&v22[80];
    v18 = *(_OWORD *)&v22[48];
    v19 = *(_OWORD *)&v22[32];
    v14[5] = *(_OWORD *)&v22[64];
    v14[6] = v17;
    v14[3] = v19;
    v14[4] = v18;
    *v14 = v16;
  }
  else
  {
    v23 = 0;
    v24 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v24);
  return *(_QWORD *)(a1 + 8);
}

unint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Custom const&,BOOL,float,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4)
{
  int32x2_t v8;
  uint64_t v9;
  uint32x2_t v10;
  int8x8_t v11;
  unint64_t v12;
  uint64_t v13;
  RB::Buffer *v15;
  int64x2_t v16;

  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(*(unsigned int *)(*(_QWORD *)(a1 + 32) + 80) + 56), 4uLL, 0, &v15);
  if (v15
    && (v8.i32[0] = 0,
        v9 = *((_QWORD *)v15 + 7) + v16.i64[0],
        v10 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000),
        v11 = (int8x8_t)vdup_lane_s32(vcgt_s32(v8, (int32x2_t)vpmin_u32(v10, v10)), 0),
        RB::Coverage::set_plane((float32x2_t *)v9, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v11, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v11, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4)))), (RB::Fill::Custom::set_custom(*(_QWORD *)(a1 + 24), (float32x2_t *)(v9 + 28), *(_QWORD *)(a1 + 32), v9 + 56, a2, *(float32x4_t **)(a1 + 16), *(float *)(a1 + 40)) & 1) != 0))
  {
    *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v15);
    *(int32x2_t *)(a2 + 188) = vmovn_s64(v16);
    v12 = *(_QWORD *)(a1 + 8) & 0xFFFFFFFF00000000;
    v13 = *(_QWORD *)(a1 + 8);
  }
  else
  {
    v12 = (unint64_t)(*(_DWORD *)(a2 + 136) == 2) << 33;
    v13 = 38;
  }
  return v13 | v12;
}

uint64_t RB::DisplayList::State::operator=(uint64_t a1, uint64_t a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;

  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  v4 = *(_OWORD *)(a2 + 16);
  v5 = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(a1 + 32) = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 48) = v5;
  *(_OWORD *)(a1 + 16) = v4;
  v6 = *(_OWORD *)(a2 + 64);
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a2 + 80);
  *(_OWORD *)(a1 + 64) = v6;
  v7 = *(unsigned int **)(a1 + 88);
  v8 = *(unsigned int **)(a2 + 88);
  if (v7 != v8)
  {
    if (v7)
    {
      v9 = v7 + 2;
      do
      {
        v10 = __ldxr(v9);
        v11 = v10 - 1;
      }
      while (__stlxr(v11, v9));
      if (!v11)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
      }
      v8 = *(unsigned int **)(a2 + 88);
    }
    if (v8)
    {
      v12 = v8 + 2;
      do
        v13 = __ldxr(v12);
      while (__stxr(v13 + 1, v12));
    }
    *(_QWORD *)(a1 + 88) = v8;
  }
  *(_OWORD *)(a1 + 96) = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(a1 + 128) = *(_OWORD *)(a2 + 128);
  *(_QWORD *)(a1 + 144) = *(_QWORD *)(a2 + 144);
  *(_WORD *)(a1 + 156) = *(_WORD *)(a2 + 156);
  return a1;
}

float64x2_t RB::DisplayList::State::scale(float64x2_t *this, float64x2_t result, double a3)
{
  float64x2_t v4;

  if (result.f64[0] != 1.0 || a3 != 1.0)
  {
    result = vmulq_n_f64(this[1], result.f64[0]);
    v4 = vmulq_n_f64(this[2], a3);
    this[1] = result;
    this[2] = v4;
    this[7].f64[0] = 0.0;
    HIDWORD(this[9].f64[0]) = -1;
  }
  return result;
}

BOOL RB::DisplayList::State::set_numeric_value(uint64_t a1, float a2)
{
  _BOOL4 v2;

  v2 = *(float *)(a1 + 152) == a2;
  if (*(float *)(a1 + 152) != a2)
  {
    *(float *)(a1 + 152) = a2;
    *(_QWORD *)(a1 + 120) = 0;
  }
  return !v2;
}

uint64_t RB::DisplayList::State::set_animation_layer(uint64_t a1, _DWORD *a2)
{
  if (*(_DWORD *)(a1 + 168) == *a2 && *(_DWORD *)(a1 + 172) == a2[1])
    return 0;
  *(_QWORD *)(a1 + 168) = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 120) = 0;
  return 1;
}

uint64_t RB::DisplayList::State::set_text_run(RB::DisplayList::State *this, CFTypeRef cf, RB::DisplayList::Builder *a3)
{
  CFTypeRef v5;
  unsigned __int8 v6;
  unsigned __int8 v7;
  CFTypeID v8;
  unsigned int v9;
  const void *ValueAtIndex;
  void *v11;
  void *v12;
  unsigned int v13;
  unint64_t GlyphCount;
  uint64_t v15;
  uint64_t v16;
  size_t v17;
  _DWORD *v18;
  _DWORD *v20;
  int v21;
  size_t *v22;
  int *v23;
  int *v24;
  _QWORD v25[2];

  v25[1] = *MEMORY[0x24BDAC8D0];
  if (!cf)
    goto LABEL_17;
  v5 = cf;
  if ((v6 & 1) == 0
  {
    RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::run_type = CTRunGetTypeID();
  }
  if ((v7 & 1) == 0
  {
    RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::array_type = CFArrayGetTypeID();
  }
  v8 = CFGetTypeID(v5);
  if (v8 == RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::run_type)
  {
    v9 = 0;
LABEL_10:
    v13 = -1;
    goto LABEL_11;
  }
  if (v8 != RB::DisplayList::State::set_text_run(objc_object *,RB::DisplayList::Builder &)::array_type
    || CFArrayGetCount((CFArrayRef)v5) != 3)
  {
    v9 = 0;
    v5 = 0;
    goto LABEL_10;
  }
  ValueAtIndex = CFArrayGetValueAtIndex((CFArrayRef)v5, 0);
  v11 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v5, 1);
  v12 = (void *)CFArrayGetValueAtIndex((CFArrayRef)v5, 2);
  v9 = objc_msgSend(v11, "unsignedIntValue");
  v13 = objc_msgSend(v12, "unsignedIntValue");
  v5 = ValueAtIndex;
LABEL_11:
  GlyphCount = CTRunGetGlyphCount((CTRunRef)v5);
  if (GlyphCount > v9)
  {
    if (GlyphCount < v9 + v13)
      v13 = GlyphCount - v9;
    if (v13)
    {
      v16 = 4 * v13;
      v17 = v16 + 4;
      if (v13 > 0x3FF)
      {
        v18 = malloc_type_malloc(v16 + 4, 0xA05E671EuLL);
        if (!v18)
        {
          v21 = 1;
LABEL_32:
          free(v18);
          return this & (v21 ^ 1);
        }
      }
      else
      {
        MEMORY[0x24BDAC7A8](GlyphCount, v15);
        v18 = (_DWORD *)((char *)v25 - ((v17 + 15) & 0xFFFFFFFF0));
        bzero(v18, v17);
      }
      RB::TextIdentity::TextIdentity((RB::TextIdentity *)v18, (CTRunRef)v5, v9, v13);
      v20 = (_DWORD *)*((_QWORD *)this + 20);
      if (v20 && RB::TextIdentity::operator==(v18, v20))
      {
        v21 = 1;
      }
      else
      {
        v22 = (size_t *)*((_QWORD *)a3 + 1);
        v23 = (int *)((v22[4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
        if ((unint64_t)v23 + v17 > v22[5])
          v23 = (int *)RB::Heap::alloc_slow(v22 + 2, v17, 3);
        else
          v22[4] = (size_t)v23 + v17;
        v24 = RB::TextIdentity::TextIdentity(v23, v18, 0, *v18 >> 2);
        v21 = 0;
        if (*((int **)this + 20) == v24)
        {
          LODWORD(this) = 0;
        }
        else
        {
          *((_QWORD *)this + 20) = v24;
          *((_QWORD *)this + 15) = 0;
          LODWORD(this) = 1;
        }
      }
      if (v13 < 0x400)
        return this & (v21 ^ 1);
      goto LABEL_32;
    }
  }
LABEL_17:
  if (!*((_QWORD *)this + 20))
    return 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 15) = 0;
  return 1;
}

void sub_209B7076C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double RB::DisplayList::State::clip_bounds(RB::DisplayList::State *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 12);
  if (v1)
    return *(double *)(v1 + 16);
  else
    return -5.48612406e303;
}

uint64_t RB::DisplayList::State::push(RB::DisplayList::State *this, RB::DisplayList::Builder *a2, RB::DisplayList::Clip *a3)
{
  uint64_t result;
  uint64_t v7;
  const RB::DisplayList::Clip *v8;
  const RB::DisplayList::Clip *v9;

  v9 = a3;
  if (!*((_BYTE *)a2 + 272))
    goto LABEL_4;
  result = RB::DisplayList::ClipNode::elide_append((uint64_t *)this + 12, (float32x2_t *)a3);
  if ((result & 1) != 0)
    return result;
  if (!*((_BYTE *)a2 + 272))
  {
LABEL_4:
    *((_QWORD *)a3 + 4) = RB::DisplayList::State::copy_metadata(this, *((RB::DisplayList::Contents **)a2 + 1));
    *((_DWORD *)a3 + 10) = *((_DWORD *)this + 16);
  }
  result = RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(*((_QWORD *)a2 + 1) + 16), &v9, (const RB::DisplayList::ClipNode **)this + 12);
  *((_QWORD *)this + 12) = result;
  *((_DWORD *)this + 37) = -1;
  v7 = *((_QWORD *)a2 + 1);
  v8 = v9;
  *((_QWORD *)v9 + 1) = *(_QWORD *)(v7 + 312);
  *(_QWORD *)(v7 + 312) = v8;
  return result;
}

void RB::DisplayList::State::append(RB::DisplayList::State *this, RB::DisplayList::Builder *a2, const RB::DisplayList::ClipNode *a3, char a4)
{
  const RB::DisplayList::ClipNode *v4;
  uint64_t i;
  uint64_t v8;
  uint64_t v9;
  __int128 v10[2];
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[15];

  v16[14] = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v4 = a3;
    if ((a4 & 1) != 0)
    {
      v10[0] = xmmword_209BD5290;
      v10[1] = xmmword_209BD52A0;
      v11 = 0;
      v12 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v13, (uint64_t)a2, v10, 0, 0, 0);
      do
      {
        for (i = (*(uint64_t (**)(unint64_t, _BYTE *, _QWORD, uint64_t))(*(_QWORD *)(*((_QWORD *)v4 + 1) & 0xFFFFFFFFFFFFFFFELL)
                                                                                        + 24))(*((_QWORD *)v4 + 1) & 0xFFFFFFFFFFFFFFFELL, v13, 0, 1); i; i = *(_QWORD *)i)
        {
          v8 = *((_QWORD *)a2 + 1);
          v9 = *(_QWORD *)(i + 8);
          *(_QWORD *)(v9 + 8) = *(_QWORD *)(v8 + 312);
          *(_QWORD *)(v8 + 312) = v9;
          *((_QWORD *)this + 12) = RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(v8 + 16), (const RB::DisplayList::Clip **)(i + 8), (const RB::DisplayList::ClipNode **)this + 12);
        }
        v4 = *(const RB::DisplayList::ClipNode **)v4;
      }
      while (v4);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v16);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v15);
      RB::Heap::~Heap((RB::Heap *)&v14);
    }
    else
    {
      *((_QWORD *)this + 12) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)this + 12), a3);
    }
    *((_DWORD *)this + 37) = -1;
  }
}

void sub_209B709B8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  _Unwind_Resume(exception_object);
}

__n128 RB::DisplayList::State::add_style(__n128 *this, RB::DisplayList::Builder *a2, RB::DisplayList::Style *a3)
{
  uint64_t v6;
  __n128 result;
  uint64_t v8;

  RB::DisplayList::State::copy_ctm(this, (RB::Heap *)(*((_QWORD *)a2 + 1) + 16));
  *((_QWORD *)a3 + 2) = v6;
  *((_QWORD *)a3 + 3) = 0;
  if (!*((_BYTE *)a2 + 272))
  {
    *((_QWORD *)a3 + 5) = RB::DisplayList::State::copy_metadata((RB::DisplayList::State *)this, *((RB::DisplayList::Contents **)a2 + 1));
    *((_DWORD *)a3 + 12) = this[4].n128_u32[0];
  }
  result = this[6];
  *(__n128 *)((char *)a3 + 24) = result;
  this[6].n128_u64[0] = 0;
  this[6].n128_u64[1] = (unint64_t)a3;
  this[9].n128_u32[1] = -1;
  v8 = *((_QWORD *)a2 + 1);
  *((_QWORD *)a3 + 1) = *(_QWORD *)(v8 + 312);
  *(_QWORD *)(v8 + 312) = a3;
  return result;
}

_DWORD *RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain(_DWORD *result, uint64_t a2)
{
  unint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  _DWORD *v6;

  if (result)
  {
    v3 = (unint64_t)result;
    v4 = result + 2;
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
    v6 = *(_DWORD **)(a2 + 48);
    if (!v6)
    {
      RB::Heap::make_object_table((size_t *)(a2 + 16));
      v6 = *(_DWORD **)(a2 + 48);
    }
    return RB::ObjectTable::adopt(v6, v3);
  }
  return result;
}

void sub_209B70D24(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209B70D9C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209B70E04(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id __copy_helper_block_e8_32c29_ZTSN2RB8objc_ptrIP7RBLayerEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c29_ZTSN2RB8objc_ptrIP7RBLayerEE(uint64_t a1)
{

}

void sub_209B712B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18, id a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28)
{
  __cxa_guard_abort(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPNSt3__14pairIPN2RB7SurfaceEP13_CAImageQueueEEEEDajyT_E9log_stats);
  _Block_object_dispose(&a24, 8);
  _Unwind_Resume(a1);
}

id __copy_helper_block_e8_40c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE(uint64_t a1, uint64_t a2)
{
  id result;

  *(_QWORD *)(a1 + 40) = *(id *)(a2 + 40);
  result = *(id *)(a2 + 48);
  *(_QWORD *)(a1 + 48) = result;
  return result;
}

void sub_209B71370(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_40c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE(uint64_t a1)
{

}

void sub_209B716D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B71850(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  os_unfair_lock_s *v10;
  void *v11;

  os_unfair_lock_unlock(v10);
  RB::vector<RB::objc_ptr<RBLayer *>,0ul,unsigned long>::~vector((uint64_t)&a10);
  _Unwind_Resume(a1);
}

uint64_t RB::vector<RB::objc_ptr<RBLayer *>,0ul,unsigned long>::~vector(uint64_t a1)
{
  id *v2;
  unint64_t v3;

  v2 = *(id **)a1;
  if (*(_QWORD *)(a1 + 8))
  {
    v3 = 0;
    do

    while (v3 < *(_QWORD *)(a1 + 8));
    v2 = *(id **)a1;
  }
  if (v2)
    free(v2);
  return a1;
}

void sub_209B7198C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B71AAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v3 = (unsigned int *)(v1 + 8);
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
    RB::ImageProvider::add_to_pending(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B71BA0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v4;
  unsigned int v5;

  do
  {
    v4 = __ldxr(v2);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v2));
  if (!v5)
    -[RBLayer statistics].cold.1(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B71D10(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v3 = (unsigned int *)(v1 + 8);
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
    RB::ImageProvider::add_to_pending(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B722E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, unsigned int *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,id a22,id a23,uint64_t a24,uint64_t a25,id a26)
{
  void *v26;
  void *v27;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;

  if (a12)
  {
    v29 = a12 + 2;
    do
    {
      v30 = __ldxr(v29);
      v31 = v30 - 1;
    }
    while (__stlxr(v31, v29));
    if (!v31)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)a12 + 8))(a12);
    }
  }

  _Unwind_Resume(a1);
}

void sub_209B72884(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,id a30,id a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,id a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56)
{
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)&a56);

  _Block_object_dispose(&a43, 8);
  _Unwind_Resume(a1);
}

id __copy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 32);
  *(_QWORD *)(a1 + 32) = result;
  return result;
}

void __destroy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1)
{

}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 48) = *(_QWORD *)(a2 + 48);
  *(_QWORD *)(a2 + 48) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{

}

void sub_209B72C48(_Unwind_Exception *a1)
{
  const void *v1;
  void *v2;
  const void *v3;
  void *v4;

  v4 = v2;

  CFRelease(v3);
  if (v1)
    CFRelease(v1);
  _Unwind_Resume(a1);
}

CFTypeRef __copy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE40c27_ZTSN2RB6cf_ptrIP7CGImageEE(uint64_t a1, uint64_t a2)
{
  CFTypeRef result;

  *(_QWORD *)(a1 + 32) = *(id *)(a2 + 32);
  result = *(CFTypeRef *)(a2 + 40);
  if (result)
    result = CFRetain(result);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void sub_209B72CDC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE40c27_ZTSN2RB6cf_ptrIP7CGImageEE(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 40);
  if (v2)
    CFRelease(v2);

}

id __copy_helper_block_e8_64c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE72c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1, uint64_t a2)
{
  id result;

  *(_QWORD *)(a1 + 64) = *(id *)(a2 + 64);
  result = *(id *)(a2 + 72);
  *(_QWORD *)(a1 + 72) = result;
  return result;
}

void sub_209B72D54(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_64c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE72c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE(uint64_t a1)
{

}

id __copy_helper_block_e16_48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE80c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE88c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE104c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  id result;

  a1[6] = *(id *)(a2 + 48);
  a1[9] = *(id *)(a2 + 72);
  a1[10] = *(id *)(a2 + 80);
  v4 = *(_QWORD *)(a2 + 88);
  if (v4)
  {
    v5 = (unsigned int *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[11] = v4;
  result = *(id *)(a2 + 104);
  a1[13] = result;
  return result;
}

void sub_209B72E10(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 88);
  if (v3)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3(v3);

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e16_48c30_ZTSN2RB8objc_ptrIP8RBDeviceEE72c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE80c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7CGImageEEE88c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE104c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(unsigned int **)(a1 + 88);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }

}

void sub_209B72F58(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_BYTE *)(v1 + *(int *)(v2 + 3444)) = 0;
  _Unwind_Resume(a1);
}

void sub_209B73168(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t RB::Refcount<RB::SharedSurfaceClient,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::SharedSurfaceClient,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::SharedSurfaceClient::~SharedSurfaceClient(RB::SharedSurfaceClient *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t _ZZZZ59__RBLayer_copyImageInRect_options_completionQueue_handler__EUb0_EUb1_EN3__18__invokeIPvPKvmEEDaT_T0_T1_(int a1, void *a2, size_t a3)
{
  return munmap(a2, a3);
}

uint64_t OUTLINED_FUNCTION_1_0(uint64_t a1)
{
  __dmb(9u);
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

void OUTLINED_FUNCTION_2(id *a1)
{

}

void OUTLINED_FUNCTION_3(void *a1, NSObject *a2, uint64_t a3, const char *a4, uint8_t *a5)
{
  _os_log_fault_impl(a1, a2, OS_LOG_TYPE_FAULT, a4, a5, 0x18u);
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(uint64_t a1, unsigned int *a2, unint64_t a3)
{
  unsigned int *v4;
  unsigned int v6;
  unsigned int v7;
  _DWORD *v8;
  unint64_t v9;
  _DWORD *v10;
  unint64_t v11;
  unsigned int *v12;
  _DWORD *v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unint64_t v21;
  int v22;
  unsigned int *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unsigned int v27;
  _DWORD *v28;
  uint64_t v29;
  int *v30;
  int v31;
  unsigned int v32;
  uint64_t v33;
  _DWORD *v34;
  float v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  unsigned int v39;
  BOOL v40;
  unint64_t v41;
  unsigned int v43;
  _DWORD *v44;
  unsigned int v45;
  _QWORD *v46;

  if (!a3)
    return 0xFFFFFFFFLL;
  v4 = a2;
  v6 = RB::Animation::hash(a2, a3);
  v7 = v6;
  v8 = *(_DWORD **)(a1 + 80);
  v9 = *(unsigned int *)(a1 + 88);
  v10 = &v8[2 * v9];
  if ((_DWORD)v9)
  {
    do
    {
      v11 = v9 >> 1;
      v12 = &v8[2 * (v9 >> 1)];
      v14 = *v12;
      v13 = v12 + 2;
      v9 += ~(v9 >> 1);
      if (v14 < v6)
        v8 = v13;
      else
        v9 = v11;
    }
    while (v9);
    if (v8 != v10)
    {
      v10 = v8;
      while (*v10 == v7)
      {
        v15 = v10[1];
        v16 = *(_QWORD *)(a1 + 96);
        v17 = *(unsigned int *)(v16 + 40 * v15);
        if ((_DWORD)v17)
        {
          v18 = 0;
          v19 = (unsigned int *)(v16 + 40 * v15 + 8);
          do
          {
            v20 = *v19;
            v19 += 10;
            v18 += v20;
            --v17;
          }
          while (v17);
        }
        else
        {
          v18 = 0;
        }
        if (RB::Animation::equal(v4, a3, (_DWORD *)(*(_QWORD *)(a1 + 112) + 4 * *(unsigned int *)(v16 + 40 * v15 + 4)), v18))
        {
          return (v10[1] + 1);
        }
        v10 += 2;
        if (v10 == (_DWORD *)(*(_QWORD *)(a1 + 80) + 8 * *(unsigned int *)(a1 + 88)))
          break;
      }
    }
  }
  v44 = v10;
  v45 = v7;
  v21 = 0;
  v22 = 0;
  v43 = *(_DWORD *)(a1 + 104);
  v46 = (_QWORD *)(a1 + 112);
  do
  {
    v23 = v4;
    v24 = (uint64_t)&v4[v21];
    v25 = RB::Animation::size(v24, a3 - v21);
    v26 = *(unsigned int *)(a1 + 120);
    v27 = v26 + v25;
    if (v26 < (int)v26 + (int)v25 && *(_DWORD *)(a1 + 124) < v27)
      RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)v46, v27);
    *(_DWORD *)(a1 + 120) = v27;
    if (v25)
    {
      v28 = (_DWORD *)(*v46 + 4 * v26);
      v29 = 4 * v25;
      v30 = (int *)v24;
      do
      {
        v31 = *v30++;
        *v28++ = v31;
        v29 -= 4;
      }
      while (v29);
    }
    v32 = *(_DWORD *)(a1 + 104);
    if (*(_DWORD *)(a1 + 108) < v32 + 1)
    {
      RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow(a1 + 96, v32 + 1);
      v32 = *(_DWORD *)(a1 + 104);
    }
    v33 = *(_QWORD *)(a1 + 96) + 40 * v32;
    *(_QWORD *)(v33 + 32) = 0;
    *(_OWORD *)v33 = 0u;
    *(_OWORD *)(v33 + 16) = 0u;
    LODWORD(v33) = *(_DWORD *)(a1 + 104);
    *(_DWORD *)(a1 + 104) = v33 + 1;
    v34 = (_DWORD *)(*(_QWORD *)(a1 + 96) + 40 * v33);
    *v34 = 1;
    v34[1] = v26;
    v34[2] = v25;
    v35 = RB::Animation::active_duration(v24, v25);
    v36 = *(_QWORD *)(a1 + 96) + 40 * (*(_DWORD *)(a1 + 104) - 1);
    *(float *)(v36 + 12) = v35;
    RB::Animation::prepare(v24, v25, v36 + 16);
    v21 = (v25 + v21);
    ++v22;
    v4 = v23;
  }
  while (v21 < a3);
  *(_DWORD *)(*(_QWORD *)(a1 + 96) + 40 * v43) = v22;
  v37 = *(_QWORD *)(a1 + 80);
  v38 = ((uint64_t)v44 - v37) >> 3;
  v39 = *(_DWORD *)(a1 + 88);
  if (*(_DWORD *)(a1 + 92) < v39 + 1)
  {
    RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(a1 + 80, v39 + 1);
    v37 = *(_QWORD *)(a1 + 80);
    v39 = *(_DWORD *)(a1 + 88);
  }
  v40 = v39 > v38;
  v41 = v39 - v38;
  if (v40)
    memmove((void *)(v37 + 8 * v38 + 8), (const void *)(v37 + 8 * v38), 8 * v41);
  *(_QWORD *)(v37 + 8 * v38) = v45 | ((unint64_t)v43 << 32);
  ++*(_DWORD *)(a1 + 88);
  return v43 + 1;
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(RB::DisplayList::Interpolator::Contents *this, const RB::Animation *a2)
{
  unsigned int *v2;

  v2 = (unsigned int *)*((_QWORD *)a2 + 3);
  if (!v2)
    v2 = (unsigned int *)a2;
  return RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v2, *((unsigned int *)a2 + 8));
}

uint64_t RB::DisplayList::Interpolator::Contents::intern_animation(RB::DisplayList::Interpolator::Contents *this, const RB::Animation *a2, const RB::Animation *a3)
{
  const RB::Animation *v4;
  _BOOL4 v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  const RB::Animation *v9;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  _BYTE *v16;
  _DWORD *v17;
  uint64_t v18;
  int *v19;
  int v20;
  int v21;
  const RB::Animation *v22;
  unint64_t v23;
  uint64_t v24;
  size_t v25;
  const RB::Animation *v27;
  int *v28;
  _BYTE *v29;
  _DWORD *v30;
  uint64_t v31;
  int v32;
  unsigned int *v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int *v36;
  uint64_t v37;
  unsigned int *v38;
  RB::DisplayList::Interpolator::Contents *v40;
  _BYTE __dst[257];
  __int128 v42;
  unint64_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v4 = a2;
    if (!*((_DWORD *)a2 + 8))
      return 0xFFFFFFFFLL;
    v5 = a3 != 0;
    if (!a3)
    {
LABEL_46:
      if (v4)
      {
        if (*((_QWORD *)v4 + 3))
          v33 = (unsigned int *)*((_QWORD *)v4 + 3);
        else
          v33 = (unsigned int *)v4;
        v34 = *((unsigned int *)v4 + 8);
        return RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v33, v34);
      }
      if (v5)
      {
        if (*((_QWORD *)a3 + 3))
          v33 = (unsigned int *)*((_QWORD *)a3 + 3);
        else
          v33 = (unsigned int *)a3;
        v34 = *((unsigned int *)a3 + 8);
        return RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v33, v34);
      }
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
    if (!a3)
      return *((unsigned int *)this + 4);
    v4 = (const RB::Animation *)*((_QWORD *)this + 1);
    v5 = 1;
  }
  if (!v4)
    goto LABEL_46;
  v42 = 0u;
  v43 = 128;
  v6 = *((unsigned int *)a3 + 8);
  if (!(_DWORD)v6)
  {
    v35 = 0;
    v36 = 0;
    goto LABEL_53;
  }
  v40 = this;
  v7 = 0;
  do
  {
    if (!*((_DWORD *)v4 + 8))
      goto LABEL_30;
    v8 = 0;
    do
    {
      v9 = (const RB::Animation *)*((_QWORD *)v4 + 3);
      if (!v9)
        v9 = v4;
      v10 = (unsigned int *)((char *)v9 + 4 * v8);
      v11 = *v10;
      if ((unint64_t)(v11 - 11) >= 2)
      {
        if (v11 != 13)
          break;
      }
      else
      {
        v12 = RB::Animation::_term_args[v11];
        v13 = *((_QWORD *)&v42 + 1);
        v14 = v12 + *((_QWORD *)&v42 + 1) + 1;
        if (*((_QWORD *)&v42 + 1) < v14 && v43 < v14)
          RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(__dst, v12 + *((_QWORD *)&v42 + 1) + 1);
        *((_QWORD *)&v42 + 1) = v14;
        v16 = (_BYTE *)v42;
        if (!(_QWORD)v42)
          v16 = __dst;
        v17 = &v16[4 * v13];
        v18 = 4 * v12 + 4;
        v19 = (int *)v10;
        do
        {
          v20 = *v19++;
          *v17++ = v20;
          v18 -= 4;
        }
        while (v18);
        v11 = *v10;
        if ((_DWORD)v11 == 18)
        {
          v21 = 2 * v10[1] + 2;
          goto LABEL_28;
        }
      }
      v21 = RB::Animation::_term_args[v11];
LABEL_28:
      v8 += v21 + 1;
    }
    while (v8 < *((_DWORD *)v4 + 8));
    v6 = *((unsigned int *)a3 + 8);
LABEL_30:
    v22 = (const RB::Animation *)*((_QWORD *)a3 + 3);
    if (!v22)
      v22 = a3;
    v23 = RB::Animation::size((uint64_t)v22 + 4 * v7, v6 - v7);
    v24 = *((_QWORD *)&v42 + 1);
    v25 = *((_QWORD *)&v42 + 1) + v23;
    if (*((_QWORD *)&v42 + 1) < *((_QWORD *)&v42 + 1) + v23 && v43 < v25)
      RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(__dst, v25);
    *((_QWORD *)&v42 + 1) = v25;
    v27 = (const RB::Animation *)*((_QWORD *)a3 + 3);
    if (!v27)
      v27 = a3;
    if (v23)
    {
      v28 = (int *)((char *)v27 + 4 * v7);
      v29 = (_BYTE *)v42;
      if (!(_QWORD)v42)
        v29 = __dst;
      v30 = &v29[4 * v24];
      v31 = 4 * v23;
      do
      {
        v32 = *v28++;
        *v30++ = v32;
        v31 -= 4;
      }
      while (v31);
    }
    v7 += v23;
    v6 = *((unsigned int *)a3 + 8);
  }
  while (v7 < v6);
  v35 = *((_QWORD *)&v42 + 1);
  v36 = (unsigned int *)v42;
  this = v40;
LABEL_53:
  if (v36)
    v38 = v36;
  else
    v38 = (unsigned int *)__dst;
  v37 = RB::DisplayList::Interpolator::Contents::intern_animation((uint64_t)this, v38, v35);
  if ((_QWORD)v42)
    free((void *)v42);
  return v37;
}

void sub_209B73AC8(_Unwind_Exception *a1)
{
  if (STACK[0x208])
    free((void *)STACK[0x208]);
  _Unwind_Resume(a1);
}

float RB::DisplayList::Interpolator::Contents::animation_max_duration(RB::DisplayList::Interpolator::Contents *this, unsigned int a2)
{
  float result;
  uint64_t v3;
  uint64_t v4;
  float *v5;
  float v6;
  float v7;

  if (!a2)
    return 1.0;
  result = 0.0;
  if (a2 <= 0xFFFFFFFD)
  {
    v3 = *((_QWORD *)this + 12);
    v4 = *(unsigned int *)(v3 + 40 * (a2 - 1));
    if ((_DWORD)v4)
    {
      v5 = (float *)(v3 + 40 * (a2 - 1) + 12);
      do
      {
        v6 = *v5;
        v5 += 10;
        v7 = v6;
        if (result < v6)
          result = v7;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void RB::DisplayList::Interpolator::Contents::animation_time(RB::DisplayList::Interpolator::Contents *this, int a2, unsigned int a3, double a4, double a5)
{
  _DWORD *v5;
  unsigned int v6;

  if (a2 != -2 && a2 && a2 != -1)
  {
    v5 = (_DWORD *)(*((_QWORD *)this + 12) + 40 * (a2 - 1));
    v6 = *v5 - 1;
    if (v6 >= a3)
      v6 = a3;
    RB::Animation::eval(*((_QWORD *)this + 14) + 4 * v5[10 * v6 + 1], v5[10 * v6 + 2], (int32x2_t *)&v5[10 * v6 + 4], a4, a5);
  }
}

float RB::DisplayList::Interpolator::Contents::max_animation_speed(RB::DisplayList::Interpolator::Contents *this, double a2, double a3)
{
  uint64_t v3;
  int v4;
  uint64_t v6;
  int32x2_t *v7;
  float v8;

  v3 = *((unsigned int *)this + 26);
  if (!(_DWORD)v3)
    return 0.0;
  v4 = LODWORD(a2);
  v6 = 40 * v3;
  v7 = (int32x2_t *)(*((_QWORD *)this + 12) + 16);
  v8 = 0.0;
  do
  {
    LODWORD(a2) = v4;
    RB::Animation::speed(*((_QWORD *)this + 14) + 4 * v7[-2].u32[1], v7[-1].u32[0], v7, a2, a3);
    if (v8 < *(float *)&a2)
      v8 = *(float *)&a2;
    v7 += 5;
    v6 -= 40;
  }
  while (v6);
  return v8;
}

unint64_t *RB::DisplayList::Interpolator::Op::set_type(unint64_t *result, unsigned __int8 a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (a2 < 4u)
  {
    if (a2 == 3)
    {
      v2 = *result & 0xFFFFFFFFFFFFFFF0 | 4;
    }
    else
    {
      v3 = *result & 0xFFFFFFFFFFFFFFF0;
      v2 = v3 | 2;
      v4 = v3 | 3;
      if (a2 >= 2u)
        v2 = v4;
    }
  }
  else
  {
    v2 = *result & 0xFFFFFFFFFFFFFFF0 | 5;
  }
  *result = v2;
  return result;
}

unint64_t *RB::DisplayList::Interpolator::Op::set_type(unint64_t *result, unsigned __int8 a2, unsigned __int8 a3, unsigned __int8 a4)
{
  unsigned int v4;
  unsigned int v5;
  unint64_t v6;
  unint64_t v7;
  BOOL v8;
  uint64_t v9;

  v4 = a2;
  if (a3 < a2)
    v4 = a3;
  if (a4 >= v4)
    v5 = v4;
  else
    v5 = a4;
  if (v5)
  {
    if (v5 < 4)
    {
      v7 = *result & 0xFFFFFFFFFFFFFFF0;
      v8 = v4 >= 2;
      v6 = v7 | 2;
      v9 = v7 | 3;
      if (v8)
        v6 = v9;
    }
    else
    {
      v6 = *result & 0xFFFFFFFFFFFFFFF0 | 5;
    }
  }
  else
  {
    if (!v4)
      return result;
    if (v4 == 1)
      v6 = *result & 0xFFFFFFFFFFFFFFF0 | 6;
    else
      v6 = *result & 0xFFFFFFFFFFFFFFF0 | 7;
  }
  *result = v6;
  return result;
}

uint64_t RB::DisplayList::Interpolator::Op::get_type(RB::DisplayList::Interpolator::Op *this)
{
  if ((*(_QWORD *)this & 8) != 0)
    return 0;
  else
    return (0x201040302010000uLL >> (8 * (*(_BYTE *)this & 0xFu)));
}

const RB::Transition *RB::DisplayList::Interpolator::Layer::item_transition(RB::DisplayList::Interpolator::Layer *this, const RB::Transition *a2)
{
  if (!a2 || *((_BYTE *)a2 + 13) && !*(_BYTE *)(**(_QWORD **)this + 13))
    return **(const RB::Transition ***)this;
  return a2;
}

void RB::DisplayList::Interpolator::Layer::print(RB::DisplayList::Interpolator::Layer *this, std::string *a2)
{
  char *v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  float v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  char *v15;

  if (*((_BYTE *)this + 248))
  {
    if (*((_BYTE *)this + 250))
      RB::SexpString::print(a2, 0, "#:non-fade");
    if (*((_BYTE *)this + 251))
      RB::SexpString::print(a2, 0, "#:has-animations");
    RB::SexpString::printf(a2, 0, "#:active-duration %g", *((float *)this + 2));
    v4 = (char *)this + 16;
    if (*((_QWORD *)this + 22))
      v4 = (char *)*((_QWORD *)this + 22);
    v5 = *((unsigned int *)this + 46);
    if ((_DWORD)v5)
    {
      v6 = v4 + 20;
      v7 = 40 * v5;
      v8 = -1;
      do
      {
        v9 = *(_QWORD *)(v6 - 20);
        if (v8 != v9 >> 4)
        {
          if ((v8 & 0x80000000) == 0)
            RB::SexpString::pop(a2);
          RB::SexpString::push(a2, "group");
          RB::SexpString::printf(a2, 0, "#:id %u", *((_DWORD *)v6 - 5) >> 4);
          v9 = *(_QWORD *)(v6 - 20);
          v8 = v9 >> 4;
        }
        RB::SexpString::push(a2, (&RB::DisplayList::Interpolator::Layer::print(RB::SexpString &)const::types)[v9 & 0xF]);
        switch(*((_DWORD *)v6 - 5) & 0xF)
        {
          case 0:
            RB::SexpString::printf(a2, 0, "#:count %u #:from (%u . %u)");
            break;
          case 1:
          case 8:
            RB::SexpString::printf(a2, 0, "#:count %u #:to (%u . %u)");
            break;
          case 9:
            RB::SexpString::printf(a2, 0, "#:from %u #:from-count %u #:to %u #:to-count %u");
            break;
          default:
            RB::SexpString::printf(a2, 0, "#:count %u #:from (%u . %u) #:to (%u . %u)");
            break;
        }
        if (*((_DWORD *)v6 + 3))
          RB::SexpString::printf(a2, 0, "#:animation %d", *((_DWORD *)v6 + 3));
        v10 = *((float *)v6 + 4);
        if (v10 != 0.0)
          RB::SexpString::printf(a2, 0, "#:begin %g", v10);
        if (*(_QWORD *)(v6 + 4) != 0x100000000)
          RB::SexpString::printf(a2, 0, "#:rects (%u . %u)", *((_DWORD *)v6 + 1), *((_DWORD *)v6 + 2));
        if ((*(v6 - 16) & 8) != 0)
          RB::SexpString::print(a2, 0, "#:value-inverted");
        RB::SexpString::pop(a2);
        v6 += 40;
        v7 -= 40;
      }
      while (v7);
      if ((v8 & 0x80000000) == 0)
        RB::SexpString::pop(a2);
    }
    if (*((_DWORD *)this + 60))
    {
      RB::SexpString::push(a2, "rects");
      v11 = *((unsigned int *)this + 60);
      if ((_DWORD)v11)
      {
        v12 = 0;
        v13 = 0;
        v14 = 16 * v11;
        do
        {
          v15 = (char *)*((_QWORD *)this + 29);
          if (!v15)
            v15 = (char *)this + 200;
          RB::SexpString::printf(a2, 1, "#:%u [%g %g; %g %g]",
            v13++,
            COERCE_FLOAT(*(_QWORD *)&v15[v12]),
            COERCE_FLOAT(HIDWORD(*(_QWORD *)&v15[v12])),
            COERCE_FLOAT(*(_QWORD *)&v15[v12 + 8]),
            COERCE_FLOAT(HIDWORD(*(_QWORD *)&v15[v12 + 8])));
          v12 += 16;
        }
        while (v14 != v12);
      }
      RB::SexpString::pop(a2);
    }
  }
  else
  {
    RB::SexpString::print(a2, 0, "#:invalid");
  }
}

double RB::DisplayList::Interpolator::Layer::clear(RB::DisplayList::Interpolator::Layer *this)
{
  double result;

  *((_DWORD *)this + 46) = 0;
  *((_DWORD *)this + 48) = 0;
  *((_DWORD *)this + 60) = 0;
  *(_QWORD *)&result = 0x100000001;
  *((_DWORD *)this + 62) = 1;
  *((_DWORD *)this + 2) = 0;
  return result;
}

uint64_t RB::DisplayList::Interpolator::Layer::failed(uint64_t this)
{
  unsigned int v1;
  float v2;

  *(_DWORD *)(this + 184) = 0;
  *(_DWORD *)(this + 192) = 0;
  if (*(_DWORD *)(this + 240) >= 3u)
    *(_DWORD *)(this + 240) = 2;
  *(_BYTE *)(this + 249) = 0;
  v1 = *(_DWORD *)(*(_QWORD *)this + 16);
  if (v1)
  {
    v2 = 0.0;
    if (v1 <= 0xFFFFFFFD)
      v2 = *(float *)(*(_QWORD *)(*(_QWORD *)this + 96) + 40 * (v1 - 1) + 12);
  }
  else
  {
    v2 = 1.0;
  }
  *(float *)(this + 8) = v2;
  *(_BYTE *)(this + 248) = 0;
  return this;
}

BOOL RB::DisplayList::Interpolator::Layer::is_fade(RB::DisplayList::Interpolator::Layer *this)
{
  if (*((_BYTE *)this + 250))
    return 0;
  if (!*((_BYTE *)this + 248) || !*((_DWORD *)this + 46))
    return 1;
  if ((*((_DWORD *)this + 48) & 0xDC) != 0)
    return 0;
  return (*((_DWORD *)this + 48) & 0x20) == 0;
}

uint64_t RB::DisplayList::Interpolator::Layer::merge_tail(uint64_t this)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;
  unint64_t *v4;
  unsigned int v5;
  unint64_t v6;
  uint64_t v7;
  BOOL v8;

  v1 = *(_DWORD *)(this + 184);
  v2 = v1 - 2;
  if (v1 >= 2)
  {
    v3 = *(_QWORD *)(this + 176) ? *(_QWORD *)(this + 176) : this + 16;
    v4 = (unint64_t *)(v3 + 40 * v2);
    v5 = v1 - 1;
    v6 = *v4;
    v7 = *(_QWORD *)(v3 + 40 * v5);
    if (((v7 ^ *v4) & 0xFLL) == 0
      && *(_DWORD *)(v3 + 40 * v2 + 24) == *(_DWORD *)(v3 + 40 * v5 + 24)
      && *(_DWORD *)(v3 + 40 * v2 + 28) == *(_DWORD *)(v3 + 40 * v5 + 28)
      && *(_DWORD *)(v3 + 40 * v2 + 32) == *(_DWORD *)(v3 + 40 * v5 + 32)
      && *(float *)(v3 + 40 * v2 + 36) == *(float *)(v3 + 40 * v5 + 36))
    {
      v8 = (v7 & 0xF) == 1 || (v7 & 0xF) == 8;
      if ((v8
         || *(_DWORD *)(v3 + 40 * v5 + 8) == *(_DWORD *)(v3 + 40 * v2 + 8)
         && *(_DWORD *)(v3 + 40 * v5 + 12) == *(_DWORD *)(v3 + 40 * v2 + 12) + (v6 >> 36))
        && ((v7 & 0xF) == 0
         || *(_DWORD *)(v3 + 40 * v5 + 16) == *(_DWORD *)(v3 + 40 * v2 + 16)
         && *(_DWORD *)(v3 + 40 * v5 + 20) == *(_DWORD *)(v3 + 40 * v2 + 20) + (v6 >> 36)))
      {
        *v4 = ((v6 & 0xFFFFFFF000000000) + v7) & 0xFFFFFFF000000000 | v6 & 0xFFFFFFFFFLL;
        --*(_DWORD *)(this + 184);
      }
    }
  }
  return this;
}

float RB::DisplayList::Interpolator::State::effect_time(RB::DisplayList::Interpolator::State *this, const RB::Transition *a2, const Effect *a3, char a4, double a5, double a6, double a7, float a8)
{
  float result;
  __int16 v13;
  unsigned __int8 *p_begin_or_insert_animation;
  unsigned int v15;
  uint64_t v16;
  float v17;
  float v18;
  float v19;
  float32x2_t v20;
  float32x2_t v21;
  float v23;
  float v24;
  float32x2_t v25;
  float32x2_t v26;

  result = *((float *)this + 4);
  v13 = *(_WORD *)a3;
  if ((*(_WORD *)a3 & 0x80) != 0)
  {
    p_begin_or_insert_animation = &a3->begin_or_insert_animation;
    if ((a4 & 1) == 0)
      p_begin_or_insert_animation = &a3->dur_or_remove_animation;
    v15 = *p_begin_or_insert_animation;
    if (*p_begin_or_insert_animation)
    {
      if (*((unsigned __int8 *)this + 29) != v15
        || (result = *((float *)this + 6), (LODWORD(result) & 0x7FFFFFFFu) >= 0x7F800000))
      {
        *((_BYTE *)this + 29) = v15;
        v16 = *((_QWORD *)this + 1);
        LODWORD(a6) = *(_DWORD *)(v16 + 36);
        *(float *)&a5 = *((float *)this + 5) - *(float *)&a6;
        RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)this, *(_DWORD *)(v16 + 32), v15, a5, a6);
        *((float *)this + 6) = result;
        if (*((_BYTE *)this + 28))
        {
          result = 1.0 - result;
          *((float *)this + 6) = result;
        }
      }
      v13 = *(_WORD *)a3;
    }
  }
  v17 = 1.0 - result;
  if ((a4 & 1) == 0)
    result = 1.0 - result;
  if ((v13 & 0x80) == 0)
  {
    LOBYTE(v17) = a3->dur_or_remove_animation;
    v18 = (float)LODWORD(v17) * 0.0039216;
    if (v18 == 0.0)
    {
      if ((*(_BYTE *)(*((_QWORD *)this + 1) + 4) & 2) != 0)
      {
        LOBYTE(v18) = *((_BYTE *)a2 + 14);
        v23 = (float)LODWORD(v18) * 0.0039216;
        if (v23 != 0.0)
        {
          v24 = v23;
          v25 = vrecpe_f32((float32x2_t)LODWORD(v23));
          v26 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v24), v25), v25);
          return vmlas_n_f32(1.0, result - 1.0, vmul_f32(v26, vrecps_f32((float32x2_t)LODWORD(v24), v26)).f32[0]);
        }
      }
    }
    else
    {
      LOBYTE(a8) = a3->begin_or_insert_animation;
      v19 = (float)LODWORD(a8) * 0.0039216;
      v20 = vrecpe_f32((float32x2_t)LODWORD(v18));
      v21 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v18), v20), v20);
      result = (float)(result - v19) * vmul_f32(v21, vrecps_f32((float32x2_t)LODWORD(v18), v21)).f32[0];
      if (result < 0.0 && v19 > 0.0)
        result = 0.0;
      if ((float)(v19 + v18) < 1.0 && result > 1.0)
        return 1.0;
    }
  }
  return result;
}

void *RB::vector<RB::Animation::TermOrArg,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 66) + (*((_QWORD *)__dst + 66) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 66) + (*((_QWORD *)__dst + 66) >> 1);
  result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 64), __dst, 0x80uLL, (size_t *)__dst + 66, v3);
  *((_QWORD *)__dst + 64) = result;
  return result;
}

double *CG::intersection@<X0>(double *result@<X0>, double *a2@<X1>, uint64_t a3@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  char v8;
  double v9;
  double v10;

  v3 = a2[2];
  v4 = a2[3];
  v6 = result[2];
  v5 = result[3];
  v7 = -(v6 * v4 - v5 * v3);
  if (fabs(v7) >= 0.0001)
  {
    v9 = result[1];
    v10 = ((*result - *a2) * v4 + (a2[1] - v9) * v3) / v7;
    *(double *)(a3 + 8) = *result + v10 * v6;
    *(double *)(a3 + 16) = v9 + v10 * v5;
    v8 = 1;
  }
  else
  {
    v8 = 0;
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
  }
  *(_BYTE *)a3 = v8;
  return result;
}

uint64_t *RB::DisplayList::Metadata::identity_ns(uint64_t *this)
{
  uint64_t v1;

  if (this)
  {
    while (1)
    {
      v1 = *this;
      if ((*this & 7) == 0)
        break;
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0)
        return this;
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::transition(uint64_t *this)
{
  uint64_t v1;

  if (this)
  {
    while (1)
    {
      v1 = *this;
      if ((*this & 7) == 1)
        break;
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0)
        return this;
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::numeric_value(uint64_t *this)
{
  uint64_t v1;

  if (this)
  {
    while (1)
    {
      v1 = *this;
      if ((*this & 7) == 2)
        break;
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0)
        return this;
    }
    ++this;
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::text_identity(uint64_t *this)
{
  uint64_t v1;

  if (this)
  {
    while (1)
    {
      v1 = *this;
      if ((*this & 7) == 3)
        break;
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0)
        return this;
    }
    return (uint64_t *)this[1];
  }
  return this;
}

uint64_t *RB::DisplayList::Metadata::animation_layer(uint64_t *this)
{
  uint64_t v1;

  if (this)
  {
    while (1)
    {
      v1 = *this;
      if ((*this & 7) == 4)
        break;
      this = (uint64_t *)(v1 & 0xFFFFFFFFFFFFFFF8);
      if ((v1 & 0xFFFFFFFFFFFFFFF8) == 0)
        return this;
    }
    ++this;
  }
  return this;
}

int *RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)3>::retain(int *result, size_t *a2)
{
  _DWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  int *v5;

  v2 = *(_DWORD **)result;
  if (*(_QWORD *)result)
  {
    v3 = result;
    v4 = (*v2 & 0xFFFFFFFC) + 4;
    v5 = (int *)((a2[4] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    if ((unint64_t)v5 + v4 > a2[5])
      v5 = (int *)RB::Heap::alloc_slow(a2 + 2, (*v2 & 0xFFFFFFFC) + 4, 3);
    else
      a2[4] = (size_t)v5 + v4;
    result = RB::TextIdentity::TextIdentity(v5, v2, 0, *v2 >> 2);
    *v3 = result;
  }
  return result;
}

Class screen_init(void *a1)
{
  Class result;

  result = NSClassFromString(CFSTR("UIView"));
  uiview_cls = (uint64_t)result;
  return result;
}

uint64_t `anonymous namespace'::AnimationTimer::shared(_anonymous_namespace_::AnimationTimer *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v3 + 264) = 0;
    *(_QWORD *)(v3 + 272) = 0;
    *(_QWORD *)(v3 + 280) = 8;
    *(_QWORD *)(v3 + 320) = 0;
    *(_QWORD *)(v3 + 328) = 0;
    *(_QWORD *)(v3 + 336) = 2;
    *(_QWORD *)(v3 + 344) = 0x7FF0000000000000;
  }
}

void sub_209B7482C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void `anonymous namespace'::AnimationTimer::set_handler(uint64_t a1, void *a2, void *a3, double a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void **v26;
  _QWORD *v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  double v35;
  BOOL v36;
  double v37;
  dispatch_time_t v38;
  NSObject *global_queue;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v10 = *(_QWORD *)(a1 + 272);
  if (v10)
  {
    v11 = -v10;
    v12 = 32 * v10;
    do
    {
      if (*(_QWORD *)(a1 + 264))
        v13 = *(_QWORD *)(a1 + 264);
      else
        v13 = a1 + 8;
      if (*(void **)(v13 + v12 - 16) == a3)
      {

        v14 = *(_QWORD *)(a1 + 272);
        *(_QWORD *)(a1 + 272) = v14 - 1;
        if (v10 != v14)
          memmove((void *)(v13 + v12 - 32), (const void *)(v13 + v12), 32 * (v11 + v14));
      }
      v12 -= 32;
      --v10;
    }
    while (!__CFADD__(v11++, 1));
  }
  if ((*(_QWORD *)&a4 & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000)
  {
LABEL_37:
    os_unfair_lock_unlock((os_unfair_lock_t)a1);

    return;
  }
  v16 = *(_QWORD *)(a1 + 272);
  if (*(_QWORD *)(a1 + 280) < (unint64_t)(v16 + 1))
  {
    v16 = *(_QWORD *)(a1 + 272);
  }
  v17 = *(_QWORD *)(a1 + 264);
  if (!v17)
    v17 = a1 + 8;
  v18 = (_OWORD *)(v17 + 32 * v16);
  *v18 = 0u;
  v18[1] = 0u;
  v20 = *(_QWORD *)(a1 + 264);
  v19 = *(_QWORD *)(a1 + 272);
  *(_QWORD *)(a1 + 272) = v19 + 1;
  if (!v20)
    v20 = a1 + 8;
  v21 = v20 + 32 * v19;
  *(_QWORD *)v21 = a2;
  *(double *)(v21 + 8) = a4;
  v22 = *(void **)(v21 + 16);
  if (v22 != a3)
  {

    *(_QWORD *)(v21 + 16) = a3;
  }
  *(float *)(v21 + 24) = a5;
  v24 = *(_QWORD *)(a1 + 320);
  v23 = *(_QWORD *)(a1 + 328);
  if (!v24)
    v24 = a1 + 288;
  if (v23)
  {
    v25 = 16 * v23;
    v26 = (void **)(v24 + 8);
    while (!*(v26 - 1) || *v26 != a2)
    {
      v26 += 2;
      v25 -= 16;
      if (!v25)
        goto LABEL_27;
    }
    goto LABEL_37;
  }
LABEL_27:
  v27 = -[RBAnimationThread initWithScreen:]([RBAnimationThread alloc], a2);

  if (v27)
  {
    v28 = *(_QWORD *)(a1 + 328);
    if (*(_QWORD *)(a1 + 336) < (unint64_t)(v28 + 1))
    {
      v28 = *(_QWORD *)(a1 + 328);
    }
    v29 = *(_QWORD *)(a1 + 320);
    if (!v29)
      v29 = a1 + 288;
    v30 = (_QWORD *)(v29 + 16 * v28);
    *v30 = 0;
    v30[1] = 0;
    v32 = *(_QWORD *)(a1 + 320);
    v31 = *(_QWORD *)(a1 + 328);
    *(_QWORD *)(a1 + 328) = v31 + 1;
    if (!v32)
      v32 = a1 + 288;
    v33 = v32 + 16 * v31;
    if (*(_QWORD **)v33 != v27)
    {

      *(_QWORD *)v33 = v27;
    }
    *(_QWORD *)(v33 + 8) = a2;
  }
  else if (*(double *)(a1 + 344) - a4 >= 0.0166666667)
  {
    *(double *)(a1 + 344) = a4;
    v34 = a4 - CACurrentMediaTime();
    v35 = v34 * 1000000000.0;
    v36 = v34 <= 0.0166666667;
    v37 = 16666666.7;
    if (v36)
      v37 = v35;
    v38 = dispatch_time(0, (uint64_t)v37);
    global_queue = dispatch_get_global_queue(2, 0);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  -[RBAnimationThread startThread]((uint64_t)v27);

}

void sub_209B74B20(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);

  _Unwind_Resume(a1);
}

void sub_209B75010(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock, char a10)
{
  if (a10)
    os_unfair_lock_unlock(lock);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::AnimationTimer::dispatch_handlers(uint64_t a1, uint64_t a2, double a3, double a4)
{
  unint64_t v4;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  uint64_t v13;
  __int128 *v14;
  size_t v15;
  size_t v16;
  _BYTE *v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  id *v24;
  uint64_t v25;
  void **v26;
  uint64_t v27;
  void *v28;
  void *v29;
  _BYTE *v30;
  size_t i;
  __int128 v32;
  _BYTE __dst[64];
  void *v34;
  size_t v35;
  unint64_t v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v34 = 0;
  v35 = 0;
  v36 = 8;
  v4 = *(_QWORD *)(a1 + 272);
  if (!v4)
    goto LABEL_36;
  v8 = 0;
  v9 = 0;
  v10 = a1 + 8;
  v11 = a4 * 0.5;
  do
  {
    v12 = *(_QWORD *)(a1 + 264);
    if (v12)
      v13 = *(_QWORD *)(a1 + 264);
    else
      v13 = v10;
    v14 = (__int128 *)(v13 + v8);
    if (*(double *)(v13 + v8 + 8) - a3 < v11)
    {
      v15 = v35;
      v16 = v35 + 1;
      if (v36 < v35 + 1)
      {
        RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v16);
        v15 = v35;
        v12 = *(_QWORD *)(a1 + 264);
        v4 = *(_QWORD *)(a1 + 272);
        v16 = v35 + 1;
      }
      v17 = v34;
      if (!v34)
        v17 = __dst;
      *(_QWORD *)&v17[8 * v15] = *((_QWORD *)v14 + 2);
      v35 = v16;
      if (!v12)
        v12 = v10;
      v18 = v12 + 32 * v4;
      v32 = *v14;
      v19 = *v14;
      *((_QWORD *)v14 + 2) = 0;
      v20 = *(_DWORD *)(v13 + v8 + 24);
      *v14 = *(_OWORD *)(v18 - 32);
      *((_QWORD *)v14 + 2) = *(_QWORD *)(v18 - 16);
      *(_QWORD *)(v18 - 16) = 0;
      *(_DWORD *)(v13 + v8 + 24) = *(_DWORD *)(v18 - 8);
      *(_OWORD *)(v18 - 32) = v19;
      v21 = *(void **)(v18 - 16);
      *(_QWORD *)(v18 - 16) = 0;
      *(_DWORD *)(v18 - 8) = v20;

      v22 = *(_QWORD *)(a1 + 264);
      v23 = *(_QWORD *)(a1 + 272) - 1;
      *(_QWORD *)(a1 + 272) = v23;
      if (!v22)
        v22 = v10;

      v4 = *(_QWORD *)(a1 + 272);
    }
    ++v9;
    v8 += 32;
  }
  while (v9 < v4);
  if (!v35)
    goto LABEL_36;
  std::unique_lock<RB::spin_lock>::unlock(a2);
  objc_msgSend(MEMORY[0x24BDE57D8], "activateBackground:", 1);
  if (v34)
    v24 = (id *)v34;
  else
    v24 = (id *)__dst;
  if (v35)
  {
    v25 = 8 * v35;
    do
    {
      objc_msgSend(*v24++, "runAnimationAtTime:", a3, v32);
      v25 -= 8;
    }
    while (v25);
    v26 = (void **)(v34 ? v34 : __dst);
    if (v35)
    {
      v27 = 8 * v35;
      do
      {
        v28 = *v26++;

        v27 -= 8;
      }
      while (v27);
    }
  }
  v35 = 0;
  objc_msgSend(MEMORY[0x24BDE57D8], "flush", v32);
  std::unique_lock<RB::spin_lock>::lock(a2);
  v29 = v34;
  if (v34)
    v30 = v34;
  else
    v30 = __dst;
  if (v35)
  {
    for (i = 0; i < v35; ++i)

LABEL_36:
    v29 = v34;
  }
  if (v29)
    free(v29);
}

void sub_209B7528C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  RB::vector<RB::objc_ptr<objc_object  {objcproto18RBAnimationHandler}*>,8ul,unsigned long>::~vector((id *)va);
  _Unwind_Resume(a1);
}

void `anonymous namespace'::AnimationTimer::remove_thread_locked(_anonymous_namespace_::AnimationTimer *this, RBAnimationThread *a2)
{
  unint64_t v2;
  unint64_t v5;
  char *v6;
  char *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;

  v2 = *((_QWORD *)this + 41);
  if (v2)
  {
    v5 = 0;
    v6 = (char *)this + 288;
    do
    {
      if (*((_QWORD *)this + 40))
        v7 = (char *)*((_QWORD *)this + 40);
      else
        v7 = v6;
      v8 = &v7[16 * v5];
      if (*(RBAnimationThread **)v8 == a2)
      {
        v9 = &v7[16 * v2];
        *(_QWORD *)v8 = 0;
        v10 = *((_QWORD *)v8 + 1);
        *(_OWORD *)v8 = *((_OWORD *)v9 - 1);
        *((_QWORD *)v9 - 2) = a2;
        *((_QWORD *)v9 - 1) = v10;

        v11 = (char *)*((_QWORD *)this + 40);
        v12 = *((_QWORD *)this + 41) - 1;
        *((_QWORD *)this + 41) = v12;
        if (!v11)
          v11 = v6;

        v2 = *((_QWORD *)this + 41);
      }
      else
      {
        ++v5;
      }
    }
    while (v5 < v2);
  }
}

void *RB::vector<`anonymous namespace'::AnimationTimer::Handler,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1);
  result = RB::details::realloc_vector<unsigned long,32ul>(*((void **)__dst + 32), __dst, 8uLL, (size_t *)__dst + 34, v3);
  *((_QWORD *)__dst + 32) = result;
  return result;
}

void *RB::vector<`anonymous namespace'::AnimationTimer::Link,2ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 4), __dst, 2uLL, (size_t *)__dst + 6, v3);
  *((_QWORD *)__dst + 4) = result;
  return result;
}

void `anonymous namespace'::AnimationTimer::schedule_fallback_locked(double)::$_0::__invoke(uint64_t a1)
{
  double v2;
  os_unfair_lock_t lock;
  char v4;

  lock = (os_unfair_lock_t)a1;
  v4 = 1;
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  *(_QWORD *)(a1 + 344) = 0x7FF0000000000000;
  v2 = CACurrentMediaTime();
  if (v4)
    os_unfair_lock_unlock(lock);
}

void sub_209B7546C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock, char a10)
{
  if (a10)
    os_unfair_lock_unlock(lock);
  _Unwind_Resume(exception_object);
}

id *RB::vector<RB::objc_ptr<objc_object  {objcproto18RBAnimationHandler}*>,8ul,unsigned long>::~vector(id *a1)
{
  id *v2;
  id *v3;
  unint64_t v4;

  v2 = (id *)a1[8];
  if (v2)
    v3 = v2;
  else
    v3 = a1;
  if (a1[9])
  {
    v4 = 0;
    do

    while (v4 < (unint64_t)a1[9]);
    v2 = (id *)a1[8];
  }
  if (v2)
    free(v2);
  return a1;
}

uint64_t RB::ContextDelegate::finalize()
{
  uint64_t result;

  result = CGContextDelegateGetInfo();
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

float64x2_t RB::ContextDelegate::get_transform@<Q0>(float64x2_t *a1@<X8>)
{
  uint64_t Info;
  double v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t result;

  Info = CGContextDelegateGetInfo();
  v3 = *(double *)(Info + 448);
  v4 = vmulq_n_f64(*(float64x2_t *)(Info + 384), v3);
  v5 = vmulq_n_f64(*(float64x2_t *)(Info + 400), v3);
  result = vmulq_n_f64(*(float64x2_t *)(Info + 416), v3);
  *a1 = v4;
  a1[1] = v5;
  a1[2] = result;
  return result;
}

uint64_t RB::ContextDelegate::get_bounds()
{
  uint64_t Info;

  Info = CGContextDelegateGetInfo();
  return objc_msgSend((id)RBDrawingStateGetDisplayList(*(_QWORD *)(Info + 432)), "contentRect");
}

uint64_t RB::ContextDelegate::draw_rects(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5, uint64_t a6)
{
  uint64_t Info;
  _BOOL8 v14;
  double *v15;
  CGColor *FillColor;
  double v17;
  CGColor *StrokeColor;
  uint64_t v19;

  Info = CGContextDelegateGetInfo();
  if (a4 >= 2 && CGGStateGetLineDash())
    return 1006;
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if (a6)
  {
    v14 = a4 == 1 || a4 == 4;
    v15 = (double *)(a5 + 16);
    do
    {
      if (a4 == 2
        || (objc_msgSend(*(id *)(Info + 8), "setRect:", *(v15 - 2), *(v15 - 1), *v15, v15[1]),
            objc_msgSend(*(id *)(Info + 8), "setEOFill:", v14),
            FillColor = (CGColor *)CGGStateGetFillColor(),
            RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, a2, 1),
            a4 >= 2))
      {
        RBDrawingStateGetCTM(*(_QWORD *)(Info + 440), (uint64_t)&v19);
        CGGStateGetAdjustedLineWidth();
        objc_msgSend(*(id *)(Info + 8), "setStrokedRect:lineWidth:", *(v15 - 2), *(v15 - 1), *v15, v15[1], v17);
        StrokeColor = (CGColor *)CGGStateGetStrokeColor();
        RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, a2, 1);
      }
      v15 += 4;
      --a6;
    }
    while (a6);
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_path(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5)
{
  RB::ContextDelegate::draw_path_(a1, a2, a3, a4, a5, 0);
  return 0;
}

uint64_t RB::ContextDelegate::draw_path_direct(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5)
{
  RB::ContextDelegate::draw_path_(a1, a2, a3, a4, a5, 1);
  return 0;
}

uint64_t RB::ContextDelegate::draw_image(uint64_t a1, uint64_t a2, const char *a3, CGImage *a4, double a5, double a6, double a7, double a8)
{
  RB::ContextDelegate::draw_image_(a5, a6, a7, a8, a1, a2, a3, a4, 0);
  return 0;
}

uint64_t RB::ContextDelegate::draw_image_from_rect(uint64_t a1, uint64_t a2, const char *a3, CGImage *a4, double a5, double a6, double a7, double a8, float64_t a9, float64_t a10, double a11, double a12)
{
  float64x2_t v13;
  double v14;
  double v15;

  v13.f64[0] = a9;
  v13.f64[1] = a10;
  v14 = a11;
  v15 = a12;
  RB::ContextDelegate::draw_image_(a5, a6, a7, a8, a1, a2, a3, a4, &v13);
  return 0;
}

uint64_t RB::ContextDelegate::draw_images(uint64_t a1, uint64_t a2, const char *a3, uint64_t a4, CGImageRef *a5, uint64_t a6, uint64_t a7)
{
  uint64_t Info;
  unsigned int v14;
  unsigned int v15;
  double v16;
  float v17;
  unsigned int CompositeOperation;
  unsigned int v19;
  double *v20;
  double *v21;
  float v22;
  float v23;
  float v24;
  float v25;
  double v26;
  double v27;
  double v28;
  double v29;
  int v30;
  int v31;
  int v32;
  int v33;
  double v34;
  double v35;
  double v36;
  double v37;
  CGColor *FillColor;
  double v39;
  double v40;
  double v41;
  double v42;
  void *v43;
  CGImageRef v44;
  uint64_t v45;
  double v46;
  int v47;
  int v48;
  int v49;
  void *v50;
  CGImageRef v51;
  _QWORD *v53;
  int v54;
  float v55;
  unsigned int v56;
  _QWORD v57[6];
  double v58;
  _QWORD v59[6];

  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if (!a6)
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
  v14 = CGGStateGetInterpolationQuality() - 1;
  if (v14 > 3)
    v15 = 7;
  else
    v15 = dword_209BD77E0[v14];
  v56 = v15;
  CGGStateGetAlpha();
  v17 = v16;
  if (!*(_QWORD *)(Info + 360))
    v17 = *(float *)(Info + 456) * v17;
  CompositeOperation = CGGStateGetCompositeOperation();
  v54 = (int)a3;
  if (CompositeOperation <= 0x1B)
  {
    if (!a7)
      return 0;
    goto LABEL_12;
  }
  v19 = 0;
  if (a7)
  {
LABEL_12:
    v53 = v59;
    v20 = (double *)(a6 + 16);
    v21 = (double *)(a4 + 16);
    v55 = v17;
    while (1)
    {
      if (a6)
        objc_msgSend(*(id *)(Info + 8), "setRect:", *(v20 - 2), *(v20 - 1), *v20, v20[1]);
      v22 = *(v21 - 2);
      v23 = *(v21 - 1);
      v24 = *v21;
      v25 = v21[1];
      v26 = v24;
      v27 = (float)-v25;
      v28 = v22;
      v29 = (float)(v25 + v23);
      v30 = 1065353216;
      v31 = 1065353216;
      v32 = 1065353216;
      v33 = 1065353216;
      if (!CGImageIsMask(*a5))
        break;
      FillColor = (CGColor *)CGGStateGetFillColor();
      if (!CGColorGetPattern(FillColor))
      {
        v46 = RBColorFromCGColor2(FillColor, *(_DWORD *)(Info + 528));
        v30 = LODWORD(v46);
        v31 = v47;
        v32 = v48;
        v33 = v49;
        v45 = 1;
        goto LABEL_20;
      }
      v43 = *(void **)(Info + 16);
      v44 = *a5;
      *v53 = 0;
      v53[1] = 0;
      v58 = v26;
      *(double *)&v59[2] = v27;
      *(double *)&v59[3] = v28;
      *(double *)&v59[4] = v29;
      LODWORD(v39) = 1065353216;
      LODWORD(v40) = 1065353216;
      LODWORD(v41) = 1065353216;
      LODWORD(v42) = 1065353216;
      objc_msgSend(v43, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v44, &v58, v56, 0, 0.0, 0.0, 1.0, 1.0, v39, v40, v41, v42);
      RB::ContextDelegate::mask_color_in_shape(Info, FillColor, v54, a2, v19, v55);
LABEL_21:
      ++a5;
      v20 += 4;
      v21 += 4;
      if (!--a7)
        return 0;
    }
    v45 = 0;
LABEL_20:
    v50 = *(void **)(Info + 16);
    v51 = *a5;
    v57[1] = 0;
    v57[2] = 0;
    *(double *)v57 = v26;
    *(double *)&v57[3] = v27;
    *(double *)&v57[4] = v28;
    *(double *)&v57[5] = v29;
    LODWORD(v34) = v30;
    LODWORD(v35) = v31;
    LODWORD(v36) = v32;
    LODWORD(v37) = v33;
    objc_msgSend(v50, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v51, v57, v56, v45, 0.0, 0.0, 1.0, 1.0, v34, v35, v36, v37, v53);
    RBDrawingStateDrawShape(*(_QWORD *)(Info + 440), *(_QWORD *)(Info + 8), *(float16x4_t **)(Info + 16), v19, v55);
    goto LABEL_21;
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_shading(uint64_t a1, uint64_t a2, const char *a3, CGShading *a4)
{
  uint64_t Info;
  char v8;
  uint64_t result;
  float64_t v10;
  float64x2_t v11;
  float64_t v12;
  float64x2_t v13;
  float32x2_t v14;
  uint64_t Background;
  uint64_t v16;
  CGColorSpace *ColorSpace;
  float64_t v18;
  float64x2_t v19;
  double v20;
  float64x2_t v21;
  double v22;
  int32x4_t v23;
  uint32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  size_t v27;
  size_t v28;
  RB *v29;
  CGColorSpace *v30;
  CGContextRef v31;
  CGContext *v32;
  uint64_t CTM;
  __int128 v34;
  __int128 v35;
  float64x2_t v36;
  __int128 v37;
  __int128 v38;
  CGImageRef Image;
  int32x2_t v40;
  uint32x2_t v41;
  int8x8_t v42;
  int8x8_t v43;
  int8x8_t v44;
  __int128 v45;
  _BOOL4 v46;
  float64x2_t *v47;
  float64x2_t v48;
  float64x2_t *v49;
  float64x2_t v50;
  float64x2_t *v51;
  float64x2_t v52;
  float64x2_t v53;
  __int128 v54;
  __int128 v55;
  void *v56;
  double v57;
  int32x2_t v58;
  uint32x2_t v59;
  int8x8_t v60;
  int8x8_t v61;
  int8x8_t v62;
  RB::DisplayList::State *v63;
  float64x2_t v64;
  uint64_t v65;
  uint64_t v66;
  float16x4_t *v67;
  double v68;
  float v69;
  unsigned int CompositeOperation;
  unsigned int v71;
  float64x2_t v72[3];
  _OWORD v73[3];
  float64x2_t v74[3];
  float64x2_t v75;
  __int128 v76;
  __int128 v77;
  CGAffineTransform transform;
  float64x2_t v79;
  __int128 v80;
  __int128 v81;
  int32x2_t v82;
  int32x2_t v83;
  float32x2_t v84;
  float32x2_t v85;
  float64x2_t v86;
  __int128 v87;
  __int128 v88;

  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  objc_msgSend(*(id *)(Info + 8), "setInfinite");
  v8 = RB::ContextDelegate::draw_shading_in_shape(Info, (int)a3, a4, 0);
  result = 0;
  if ((v8 & 1) == 0)
  {
    RBDrawingStateGetDeviceClipBoundingBox(*(_QWORD *)(Info + 440));
    v11.f64[1] = v10;
    v13.f64[1] = v12;
    v14 = vcvt_f32_f64(v13);
    v84 = vcvt_f32_f64(v11);
    v85 = v14;
    Background = CGShadingGetBackground();
    if (Background)
    {
      v16 = Background;
      ColorSpace = (CGColorSpace *)CGShadingGetColorSpace();
      if (*(double *)(v16 + 8 * CGColorSpaceGetNumberOfComponents(ColorSpace)) == 0.0)
      {
        CGShadingGetBounds();
        v19.f64[1] = v18;
        v21.f64[1] = v20;
        RB::Rect::intersect(&v84, vcvt_f32_f64(v19), vcvt_f32_f64(v21), v21.f64[0], v20, v22, v23);
        v14 = v85;
      }
    }
    v24 = (uint32x2_t)vclez_f32(v14);
    if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) == 0)
    {
      v25 = RB::operator*((float64x2_t *)(Info + 384), v84, v14);
      RB::Bounds::Bounds(&v82, v25, v26);
      v27 = v83.i32[0];
      v28 = v83.i32[1];
      v30 = (CGColorSpace *)RB::srgb_colorspace(v29);
      v31 = CGBitmapContextCreate(0, v27, v28, 8uLL, 0, v30, 0x2002u);
      if (!v31)
        return 1000;
      v32 = v31;
      CTM = CGGStateGetCTM();
      v34 = *(_OWORD *)(CTM + 16);
      v35 = *(_OWORD *)(CTM + 32);
      v79 = *(float64x2_t *)CTM;
      v80 = v34;
      v81 = v35;
      v36.f64[0] = RB::operator*(&v79, (float64x2_t *)(Info + 384));
      v79 = v36;
      v80 = v37;
      v81 = v38;
      CGContextTranslateCTM(v32, (double)-v82.i32[0], (double)-v82.i32[1]);
      *(float64x2_t *)&transform.a = v79;
      *(_OWORD *)&transform.c = v80;
      *(_OWORD *)&transform.tx = v81;
      CGContextConcatCTM(v32, &transform);
      if (CGShadingGetType())
      {
        CGContextSetCompositeOperation();
      }
      else
      {
        CGContextSetCompositeOperation();
        CGContextClear();
      }
      CGContextDrawShading(v32, a4);
      Image = CGBitmapContextCreateImage(v32);
      v40.i32[0] = 0;
      v41 = (uint32x2_t)vceq_s32(v83, (int32x2_t)0x8000000080000000);
      v42 = (int8x8_t)vdup_lane_s32(vcgt_s32(v40, (int32x2_t)vpmin_u32(v41, v41)), 0);
      v43 = vbsl_s8(v42, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v83));
      v44 = vbsl_s8(v42, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v82));
      RBImageSimpleTransform((uint64_t)&v86, *(float *)v44.i32, *(float *)&v44.i32[1], *(float *)v43.i32, *(float *)&v43.i32[1]);
      v75 = v86;
      v76 = v87;
      v77 = v88;
      v45 = *(_OWORD *)(Info + 400);
      v86 = *(float64x2_t *)(Info + 384);
      v87 = v45;
      v88 = *(_OWORD *)(Info + 416);
      v46 = RB::AffineTransform::invert((RB::AffineTransform *)&v86);
      if (v46)
        v47 = &v86;
      else
        v47 = (float64x2_t *)(Info + 384);
      v48 = *v47;
      v49 = (float64x2_t *)&v87;
      if (!v46)
        v49 = (float64x2_t *)(Info + 400);
      v50 = *v49;
      v51 = (float64x2_t *)&v88;
      if (!v46)
        v51 = (float64x2_t *)(Info + 416);
      v52 = *v51;
      v74[0] = v48;
      v74[1] = v50;
      v74[2] = v52;
      v53.f64[0] = RB::operator*(&v75, v74);
      v75 = v53;
      v76 = v54;
      v77 = v55;
      v56 = *(void **)(Info + 16);
      v73[0] = v53;
      v73[1] = v54;
      v73[2] = v55;
      LODWORD(v53.f64[0]) = 1065353216;
      LODWORD(v54) = 1065353216;
      LODWORD(v55) = 1065353216;
      LODWORD(v57) = 1065353216;
      objc_msgSend(v56, "setImage:transform:interpolation:tintColor:flags:", Image, v73, 1, 0, v53.f64[0], *(double *)&v54, *(double *)&v55, v57);
      v58.i32[0] = 0;
      v59 = (uint32x2_t)vceq_s32(v83, (int32x2_t)0x8000000080000000);
      v60 = (int8x8_t)vdup_lane_s32(vcgt_s32(v58, (int32x2_t)vpmin_u32(v59, v59)), 0);
      v61 = vbsl_s8(v60, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v83));
      v62 = vbsl_s8(v60, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v82));
      objc_msgSend(*(id *)(Info + 8), "setRect:", *(float *)v62.i32, *(float *)&v62.i32[1], *(float *)v61.i32, *(float *)&v61.i32[1]);
      objc_msgSend(*(id *)(Info + 8), "setAntialiased:", 0);
      v63 = *(RB::DisplayList::State **)(Info + 440);
      v64 = *(float64x2_t *)(Info + 400);
      v72[0] = *(float64x2_t *)(Info + 384);
      v72[1] = v64;
      v72[2] = *(float64x2_t *)(Info + 416);
      RBDrawingStateSetCTM(v63, v72);
      v65 = *(_QWORD *)(Info + 440);
      v66 = *(_QWORD *)(Info + 8);
      v67 = *(float16x4_t **)(Info + 16);
      CGGStateGetAlpha();
      v69 = v68;
      if (!*(_QWORD *)(Info + 360))
        v69 = *(float *)(Info + 456) * v69;
      CompositeOperation = CGGStateGetCompositeOperation();
      if (CompositeOperation > 0x1B)
        v71 = 0;
      else
      RBDrawingStateDrawShape(v65, v66, v67, v71, v69);
      if (Image)
        CFRelease(Image);
      CFRelease(v32);
    }
    return 0;
  }
  return result;
}

void sub_209B75DFC(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  if (v2)
    CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::draw_linear_gradient(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, uint64_t a8, char a9)
{
  uint64_t Info;
  uint64_t LocationCount;
  unint64_t v19;
  uint64_t v20;
  char *v21;
  char v22;
  size_t v23;
  size_t v24;
  char *v25;
  _BOOL8 gradient;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  float16x4_t *v30;
  double v31;
  float v32;
  unsigned int CompositeOperation;
  unsigned int v34;
  _QWORD v36[2];

  v36[1] = *MEMORY[0x24BDAC8D0];
  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a7, a6, 0);
  LocationCount = CGGradientGetLocationCount();
  v19 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v19 >> 61)
      return 1000;
    v21 = 0;
  }
  else
  {
    if (16 * v19 > 0x1000)
    {
      LocationCount = (uint64_t)malloc_type_malloc(16 * v19, 0x33967FA3uLL);
      v21 = (char *)LocationCount;
      v22 = 0;
      goto LABEL_9;
    }
    MEMORY[0x24BDAC7A8](LocationCount, 16 * v19);
    v21 = (char *)v36 - ((v23 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v21, v23);
  }
  v22 = 1;
LABEL_9:
  if (v19 >= 0x201)
  {
    v25 = (char *)malloc_type_malloc(8 * v19, 0x51B89829uLL);
    if (!v21)
      goto LABEL_18;
  }
  else
  {
    MEMORY[0x24BDAC7A8](LocationCount, 8 * v19);
    v25 = (char *)v36 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v25, v24);
    if (!v21)
      goto LABEL_18;
  }
  if (v25)
  {
    gradient = RB::make_gradient(a8, (uint64_t)v21, (uint64_t)v25, *(unsigned int *)(Info + 528), a9);
    objc_msgSend(*(id *)(Info + 16), "setAxialGradientStartPoint:endPoint:stopCount:colors:locations:flags:", gradient, v21, v25, v27, a1, a2, a3, a4);
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
    v28 = *(_QWORD *)(Info + 440);
    v29 = *(_QWORD *)(Info + 8);
    v30 = *(float16x4_t **)(Info + 16);
    CGGStateGetAlpha();
    v32 = v31;
    if (!*(_QWORD *)(Info + 360))
      v32 = *(float *)(Info + 456) * v32;
    CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B)
      v34 = 0;
    else
    RBDrawingStateDrawShape(v28, v29, v30, v34, v32);
    v20 = 0;
    goto LABEL_21;
  }
LABEL_18:
  v20 = 1000;
LABEL_21:
  if (v19 >= 0x201)
    free(v25);
  if ((v22 & 1) == 0)
    free(v21);
  return v20;
}

void sub_209B7609C(_Unwind_Exception *exception_object)
{
  void *v1;
  void *v2;
  unint64_t v3;
  char v4;

  if (v3 >= 0x201)
    free(v2);
  if ((v4 & 1) == 0)
    free(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::draw_radial_gradient(double a1, double a2, double a3, double a4, double a5, double a6, uint64_t a7, uint64_t a8, const char *a9, uint64_t a10, char a11)
{
  uint64_t Info;
  uint64_t LocationCount;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  char v26;
  size_t v27;
  size_t v28;
  char *v29;
  _BOOL8 gradient;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float16x4_t *v34;
  double v35;
  float v36;
  unsigned int CompositeOperation;
  unsigned int v38;
  _QWORD v40[2];

  v40[1] = *MEMORY[0x24BDAC8D0];
  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a9, a8, 0);
  LocationCount = CGGradientGetLocationCount();
  v23 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v23 >> 61)
      return 1000;
    v25 = 0;
  }
  else
  {
    if (16 * v23 > 0x1000)
    {
      LocationCount = (uint64_t)malloc_type_malloc(16 * v23, 0x9FC2771EuLL);
      v25 = (char *)LocationCount;
      v26 = 0;
      goto LABEL_9;
    }
    MEMORY[0x24BDAC7A8](LocationCount, 16 * v23);
    v25 = (char *)v40 - ((v27 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v25, v27);
  }
  v26 = 1;
LABEL_9:
  if (v23 >= 0x201)
  {
    v29 = (char *)malloc_type_malloc(8 * v23, 0xAE24DE30uLL);
    if (!v25)
      goto LABEL_18;
  }
  else
  {
    MEMORY[0x24BDAC7A8](LocationCount, 8 * v23);
    v29 = (char *)v40 - ((v28 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v29, v28);
    if (!v25)
      goto LABEL_18;
  }
  if (v29)
  {
    gradient = RB::make_gradient(a10, (uint64_t)v25, (uint64_t)v29, *(unsigned int *)(Info + 528), a11);
    objc_msgSend(*(id *)(Info + 16), "setRadialGradientStartCenter:startRadius:endCenter:endRadius:stopCount:colors:locations:flags:", gradient, v25, v29, v31, a1, a2, a3, a4, a5, a6);
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
    v32 = *(_QWORD *)(Info + 440);
    v33 = *(_QWORD *)(Info + 8);
    v34 = *(float16x4_t **)(Info + 16);
    CGGStateGetAlpha();
    v36 = v35;
    if (!*(_QWORD *)(Info + 360))
      v36 = *(float *)(Info + 456) * v36;
    CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B)
      v38 = 0;
    else
    RBDrawingStateDrawShape(v32, v33, v34, v38, v36);
    v24 = 0;
    goto LABEL_21;
  }
LABEL_18:
  v24 = 1000;
LABEL_21:
  if (v23 >= 0x201)
    free(v29);
  if ((v26 & 1) == 0)
    free(v25);
  return v24;
}

void sub_209B7634C(_Unwind_Exception *exception_object)
{
  void *v1;
  void *v2;
  unint64_t v3;
  char v4;

  if (v3 >= 0x201)
    free(v2);
  if ((v4 & 1) == 0)
    free(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::draw_conic_gradient(double a1, double a2, double a3, uint64_t a4, uint64_t a5, const char *a6, uint64_t a7)
{
  uint64_t Info;
  uint64_t LocationCount;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  char v18;
  size_t v19;
  size_t v20;
  char *v21;
  _BOOL8 gradient;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float16x4_t *v26;
  double v27;
  float v28;
  unsigned int CompositeOperation;
  unsigned int v30;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x24BDAC8D0];
  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a6, a5, 0);
  LocationCount = CGGradientGetLocationCount();
  v15 = LocationCount + 2;
  if ((unint64_t)(LocationCount + 2) >> 60)
  {
    if (v15 >> 61)
      return 1000;
    v17 = 0;
  }
  else
  {
    if (16 * v15 > 0x1000)
    {
      LocationCount = (uint64_t)malloc_type_malloc(16 * v15, 0xC0B4ADF2uLL);
      v17 = (char *)LocationCount;
      v18 = 0;
      goto LABEL_9;
    }
    MEMORY[0x24BDAC7A8](LocationCount, 16 * v15);
    v17 = (char *)v32 - ((v19 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v17, v19);
  }
  v18 = 1;
LABEL_9:
  if (v15 >= 0x201)
  {
    v21 = (char *)malloc_type_malloc(8 * v15, 0xCC53BAE2uLL);
    if (!v17)
      goto LABEL_18;
  }
  else
  {
    MEMORY[0x24BDAC7A8](LocationCount, 8 * v15);
    v21 = (char *)v32 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v21, v20);
    if (!v17)
      goto LABEL_18;
  }
  if (v21)
  {
    gradient = RB::make_gradient(a7, (uint64_t)v17, (uint64_t)v21, *(unsigned int *)(Info + 528), 3);
    objc_msgSend(*(id *)(Info + 16), "setConicGradientCenter:angle:stopCount:colors:locations:flags:", gradient, v17, v21, v23, a1, a2, a3);
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
    v24 = *(_QWORD *)(Info + 440);
    v25 = *(_QWORD *)(Info + 8);
    v26 = *(float16x4_t **)(Info + 16);
    CGGStateGetAlpha();
    v28 = v27;
    if (!*(_QWORD *)(Info + 360))
      v28 = *(float *)(Info + 456) * v28;
    CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B)
      v30 = 0;
    else
    RBDrawingStateDrawShape(v24, v25, v26, v30, v28);
    v16 = 0;
    goto LABEL_21;
  }
LABEL_18:
  v16 = 1000;
LABEL_21:
  if (v15 >= 0x201)
    free(v21);
  if ((v18 & 1) == 0)
    free(v17);
  return v16;
}

void sub_209B765D8(_Unwind_Exception *exception_object)
{
  void *v1;
  void *v2;
  unint64_t v3;
  char v4;

  if (v3 >= 0x201)
    free(v2);
  if ((v4 & 1) == 0)
    free(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::ContextDelegate::operation(uint64_t a1, uint64_t a2, const char *a3, const void *a4, void *a5)
{
  uint64_t Info;
  double v10;
  double v11;
  double v12;
  double v13;
  void *v14;
  __int128 *v15;
  uint64_t result;
  const void *v17;
  CFTypeRef v18;
  void *v19;
  uint64_t CTM;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  double v26;
  double v27;
  float v28;
  float v29;
  float64x2_t v30[3];
  float64x2_t v31[3];

  Info = CGContextDelegateGetInfo();
  if (CFEqual(a4, CFSTR("kCGContextClear")))
  {
    RB::ContextDelegate::update(Info, a3, a2, 0);
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
    v14 = *(void **)(Info + 16);
    v15 = &RBColorClear;
LABEL_5:
    LODWORD(v10) = *(_DWORD *)v15;
    LODWORD(v11) = *((_DWORD *)v15 + 1);
    LODWORD(v12) = *((_DWORD *)v15 + 2);
    LODWORD(v13) = *((_DWORD *)v15 + 3);
    objc_msgSend(v14, "setColor:", v10, v11, v12, v13);
    RBDrawingStateDrawShape(*(_QWORD *)(Info + 440), *(_QWORD *)(Info + 8), *(float16x4_t **)(Info + 16), 0x11u, 1.0);
    return 0;
  }
  if (CFEqual(a4, CFSTR("kCGContextErase")))
  {
    RB::ContextDelegate::update(Info, a3, a2, 0);
    objc_msgSend(*(id *)(Info + 8), "setInfinite");
    v14 = *(void **)(Info + 16);
    v15 = &RBColorWhite;
    goto LABEL_5;
  }
  if (CFEqual(a4, CFSTR("RBDisplayListAttributeTextRun")))
  {
    v17 = *(const void **)(Info + 544);
    if (v17 == a5)
      return 0;
    if (v17)
      CFRelease(v17);
    if (a5)
      v18 = CFRetain(a5);
    else
      v18 = 0;
    result = 0;
    *(_QWORD *)(Info + 544) = v18;
  }
  else if (CFEqual(a4, CFSTR("RBShapeRenderingMode")))
  {
    result = objc_msgSend(a5, "objectForKeyedSubscript:", CFSTR("value"));
    if (result)
    {
      *(_DWORD *)(Info + 552) = objc_msgSend((id)result, "unsignedIntValue");
      result = objc_msgSend(a5, "objectForKeyedSubscript:", CFSTR("argument"));
      if (result)
      {
        v19 = (void *)result;
        CTM = CGGStateGetCTM();
        v21 = *(float64x2_t *)(CTM + 16);
        v22 = *(float64x2_t *)(CTM + 32);
        v30[0] = *(float64x2_t *)CTM;
        v30[1] = v21;
        v30[2] = v22;
        v23.f64[0] = RB::operator*(v30, (float64x2_t *)(Info + 384));
        v31[0] = v23;
        v31[1] = v24;
        v31[2] = v25;
        objc_msgSend(v19, "doubleValue");
        v27 = v26;
        v28 = RB::AffineTransform::scale(v31);
        result = 0;
        v29 = v27 * v28;
        *(float *)(Info + 556) = v29;
      }
    }
    else
    {
      *(_QWORD *)(Info + 552) = 0;
    }
  }
  else
  {
    return 1006;
  }
  return result;
}

uint64_t RB::ContextDelegate::begin_transparency_layer(uint64_t a1, uint64_t a2, const char *a3)
{
  uint64_t Info;
  RB::DisplayList::State *v7;
  float64x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  float64x2_t v17[3];

  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  v7 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(Info + 440), 0);
  v8 = *(float64x2_t *)(Info + 400);
  v17[0] = *(float64x2_t *)(Info + 384);
  v17[1] = v8;
  v17[2] = *(float64x2_t *)(Info + 416);
  RBDrawingStateSetCTM(v7, v17);
  v9 = *(_QWORD *)(Info + 360);
  if (*(_QWORD *)(Info + 368) < (unint64_t)(v9 + 1))
  {
    RB::vector<RB::ContextDelegate::Layer,4ul,unsigned long>::reserve_slow((void *)(Info + 32), v9 + 1);
    v9 = *(_QWORD *)(Info + 360);
  }
  v10 = *(_QWORD *)(Info + 352);
  if (!v10)
    v10 = Info + 32;
  v11 = v10 + 80 * v9;
  v12 = *(_DWORD *)(Info + 464);
  *(_OWORD *)v11 = *(_OWORD *)(Info + 432);
  v13 = *(_QWORD *)(Info + 472);
  *(_DWORD *)(v11 + 16) = v12;
  *(_QWORD *)(v11 + 20) = v13;
  v14 = *(_OWORD *)(Info + 480);
  v15 = *(_OWORD *)(Info + 512);
  *(_OWORD *)(v11 + 48) = *(_OWORD *)(Info + 496);
  *(_OWORD *)(v11 + 64) = v15;
  *(_OWORD *)(v11 + 32) = v14;
  ++*(_QWORD *)(Info + 360);
  *(_QWORD *)(Info + 432) = v7;
  *(_QWORD *)(Info + 440) = 0;
  *(_DWORD *)(Info + 464) = 0;
  *(_QWORD *)(Info + 472) = 0;
  return a1;
}

uint64_t RB::ContextDelegate::end_transparency_layer(uint64_t a1)
{
  _QWORD *Info;
  float *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  RB::DisplayList::State *v7;
  double v8;
  float v9;
  unsigned int CompositeOperation;
  unsigned int v11;
  const char *v12;
  _RBDrawingState *v13;
  RB::XML::Document *v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  __int128 v18;
  __int128 v19;

  Info = (_QWORD *)CGContextDelegateGetInfo();
  v3 = (float *)Info;
  v4 = Info + 4;
  v5 = (_QWORD *)Info[44];
  if (!v5)
    v5 = Info + 4;
  v6 = v5[10 * Info[45] - 9];
  v7 = (RB::DisplayList::State *)Info[54];
  CGGStateGetAlpha();
  v9 = v8;
  if (!*((_QWORD *)v3 + 45))
    v9 = v3[114] * v9;
  CompositeOperation = CGGStateGetCompositeOperation();
  if (CompositeOperation > 0x1B)
    v11 = 0;
  else
  RBDrawingStateDrawLayer(v6, v7, v11, v9);
  v14 = (RB::XML::Document *)*((_QWORD *)v3 + 55);
  if (v14)
    RBDrawingStateDestroy(v14, v12, v13);
  v15 = (_QWORD *)*((_QWORD *)v3 + 44);
  if (!v15)
    v15 = v4;
  v16 = *((_QWORD *)v3 + 45) - 1;
  v17 = &v15[10 * v16];
  v3[116] = *((float *)v17 + 4);
  *((_QWORD *)v3 + 59) = *(_QWORD *)((char *)v17 + 20);
  v18 = *((_OWORD *)v17 + 2);
  v19 = *((_OWORD *)v17 + 4);
  *((_OWORD *)v3 + 31) = *((_OWORD *)v17 + 3);
  *((_OWORD *)v3 + 32) = v19;
  *((_OWORD *)v3 + 30) = v18;
  *((_OWORD *)v3 + 27) = *(_OWORD *)v17;
  *((_QWORD *)v3 + 45) = v16;
  return a1;
}

uint64_t RB::ContextDelegate::create_layer(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4)
{
  float64x2_t *Info;
  uint64_t CTM;
  __int128 v6;
  __int128 v7;
  float64x2_t v8;
  __int128 v9;
  __int128 v10;
  double v11;
  RB::LayerContextDelegate *v12;
  uint64_t v13;
  float64x2_t v15;
  __int128 v16;
  __int128 v17;
  CGRect v18;

  v18.origin.x = a1;
  v18.origin.y = a2;
  v18.size.width = a3;
  v18.size.height = a4;
  Info = (float64x2_t *)CGContextDelegateGetInfo();
  CTM = CGGStateGetCTM();
  v6 = *(_OWORD *)(CTM + 16);
  v7 = *(_OWORD *)(CTM + 32);
  v15 = *(float64x2_t *)CTM;
  v16 = v6;
  v17 = v7;
  v8.f64[0] = RB::operator*(&v15, Info + 24);
  v15 = v8;
  v16 = v9;
  v17 = v10;
  v11 = Info[28].f64[0] * RB::AffineTransform::scale(&v15);
  v12 = (RB::LayerContextDelegate *)operator new();
  RB::LayerContextDelegate::LayerContextDelegate(v12, &v18, v11);
  v13 = CGContextDelegateCreate();
  CGContextDelegateSetCallbacks();
  return v13;
}

void sub_209B76AB0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10E1C40C37EBC0CLL);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::draw_layer(CGFloat a1, CGFloat a2, CGFloat a3, CGFloat a4, uint64_t a5, uint64_t a6, const char *a7)
{
  uint64_t Info;
  _OWORD *CTM;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  CGFloat v19;
  CGFloat v20;
  CGContext *v21;
  uint64_t v22;
  RB::DisplayList::State *v23;
  double v24;
  float64x2_t v25;
  uint64_t v26;
  double v27;
  float v28;
  unsigned int CompositeOperation;
  unsigned int v30;
  CGAffineTransform v32;
  CGAffineTransform v33;
  CGAffineTransform v34;
  CGAffineTransform v35;
  CGAffineTransform v36;
  CGRect v37;
  CGRect v38;

  Info = CGContextDelegateGetInfo();
  if ((uint64_t (*)())CGContextDelegateGetCallback() == RB::ContextDelegate::get_bounds)
  {
    v22 = CGContextDelegateGetInfo();
    RB::ContextDelegate::update(v22, a7, a6, 0);
    v23 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(v22 + 440), 0);
    v38.origin.x = a1;
    v38.origin.y = a2;
    v38.size.width = a3;
    v38.size.height = a4;
    if (!CGRectEqualToRect(v38, *(CGRect *)(Info + 568)))
    {
      RBDrawingStateTranslateCTM((uint64_t)v23, a1, a2);
      v25.f64[0] = *(double *)(Info + 584) / a3;
      RBDrawingStateScaleCTM((uint64_t)v23, v25, *(double *)(Info + 592) / a4);
      RBDrawingStateTranslateCTM((uint64_t)v23, -*(double *)(Info + 568), -*(double *)(Info + 576));
    }
    RBDrawingStateDrawDisplayList((uint64_t)v23, *(void **)(Info + 560), v24);
    v26 = *(_QWORD *)(v22 + 440);
    CGGStateGetAlpha();
    v28 = v27;
    if (!*(_QWORD *)(v22 + 360))
      v28 = *(float *)(v22 + 456) * v28;
    CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B)
      v30 = 0;
    else
    RBDrawingStateDrawLayer(v26, v23, v30, v28);
  }
  else
  {
    CTM = (_OWORD *)CGGStateGetCTM();
    v16 = CTM[1];
    v15 = CTM[2];
    *(_OWORD *)&v36.a = *CTM;
    *(_OWORD *)&v36.c = v16;
    *(_OWORD *)&v36.tx = v15;
    v17 = *CTM;
    v18 = CTM[2];
    *(_OWORD *)&v35.c = CTM[1];
    *(_OWORD *)&v35.tx = v18;
    *(_OWORD *)&v35.a = v17;
    CGAffineTransformTranslate(&v36, &v35, a1, a2);
    v33 = v36;
    CGAffineTransformScale(&v34, &v33, *(double *)(Info + 584) / a3, *(double *)(Info + 592) / a4);
    v36 = v34;
    *(_OWORD *)&v32.a = *(_OWORD *)&v34.a;
    *(_OWORD *)&v32.c = *(_OWORD *)&v34.c;
    v19 = -*(double *)(Info + 568);
    v20 = -*(double *)(Info + 576);
    *(_OWORD *)&v32.tx = *(_OWORD *)&v34.tx;
    CGAffineTransformTranslate(&v34, &v32, v19, v20);
    v36 = v34;
    CGGStateCreateCopy();
    CGGStateSetCTM();
    v21 = (CGContext *)CGContextCreateWithDelegate();
    CGGStateRelease();
    v37.origin.x = a1;
    v37.origin.y = a2;
    v37.size.width = a3;
    v37.size.height = a4;
    CGContextBeginTransparencyLayerWithRect(v21, v37, 0);
    objc_msgSend(*(id *)(Info + 560), "renderInContext:options:", v21, 0);
    CGContextEndTransparencyLayer(v21);
    if (v21)
      CFRelease(v21);
  }
  return 0;
}

void sub_209B76D70(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void RB::ContextDelegate::~ContextDelegate(RB::ContextDelegate *this)
{
  const void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C228D38;
  v2 = (const void *)*((_QWORD *)this + 68);
  if (v2)
    CFRelease(v2);

  v3 = (void *)*((_QWORD *)this + 44);
  if (v3)
    free(v3);

}

{
  RB::ContextDelegate::~ContextDelegate(this);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::ContextDelegate::set_stroked_clip(uint64_t a1, uint64_t a2)
{
  double v4;
  double v5;
  uint64_t LineCap;
  uint64_t LineJoin;
  double v8;
  double v9;
  uint64_t Pattern;
  double v11;
  uint64_t v12;
  void *v13;
  _OWORD v15[3];
  double v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v19 = 0u;
  v20 = 0u;
  v18 = 0u;
  CGClipStrokeGetMatrix();
  CGClipStrokeGetLineWidth();
  v5 = v4;
  LineCap = CGClipStrokeGetLineCap();
  LineJoin = CGClipStrokeGetLineJoin();
  CGClipStrokeGetMiterLimit();
  v9 = v8;
  v16 = 0.0;
  v17 = 0;
  if (CGClipStrokeGetDash())
  {
    Pattern = CGDashGetPattern();
    v11 = v16;
    v12 = v17;
  }
  else
  {
    v12 = 0;
    Pattern = 0;
    v11 = 0.0;
  }
  v13 = *(void **)(a1 + 8);
  v15[0] = v18;
  v15[1] = v19;
  v15[2] = v20;
  objc_msgSend(v13, "setStrokedPath:transform:lineWidth:lineCap:lineJoin:miterLimit:dashPhase:dashPattern:dashCount:", a2, v15, LineCap, LineJoin, Pattern, v12, v5, v9, v11);
  return objc_msgSend(*(id *)(a1 + 8), "setEOFill:", 0);
}

void RB::ContextDelegate::clip_soft_mask(uint64_t a1)
{
  CGColor *Background;
  uint64_t Transfer;
  CGContext *v4;
  RB::DisplayList::State *v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  RB::DisplayList::State *v9;
  RB::DisplayList::State *v10;
  RB::DisplayList::State *v11;
  const char *v12;
  _RBDrawingState *v13;
  float64_t v14;
  float64x2_t v15;
  float64_t v16;
  float64x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float64_t v20;
  float64x2_t v21;
  float64_t v22;
  float64x2_t v23;
  RB *v24;
  uint64_t v25;
  uint32x2_t v26;
  char *v27;
  uint32_t v28;
  CGContext *v29;
  CGContext *v30;
  CGFunction *v31;
  CGImageRef Image;
  int32x2_t v33;
  void *v34;
  uint32x2_t v35;
  int8x8_t v36;
  float32x2_t v37;
  int8x8_t v38;
  int8x8_t v39;
  float32x2_t v40;
  double v41;
  float32x2_t v42;
  float64x2_t v43;
  int32x2_t v44;
  uint32x2_t v45;
  int8x8_t v46;
  int8x8_t v47;
  int8x8_t v48;
  RB::DisplayList::State *v49;
  RB::DisplayList::State *v50;
  RB::DisplayList::State *v51;
  float64x2_t v52;
  float64x2_t v53[3];
  double v54[3];
  float64x2_t v55;
  double v56;
  CGAffineTransform v57;
  CGAffineTransform transform;
  int32x2_t v59[2];
  float64x2_t v60[3];
  _OWORD v61[3];
  float64x2_t v62;
  __int128 v63;
  __int128 v64;

  CGSoftMaskGetMatrix();
  v62 = (float64x2_t)v61[0];
  v63 = v61[1];
  v64 = v61[2];
  Background = (CGColor *)CGSoftMaskGetBackground();
  Transfer = CGSoftMaskGetTransfer();
  if (Transfer && (v4 = (CGContext *)Transfer, !CGFunctionIsIdentity()))
  {
    CGSoftMaskGetBounds();
    v15.f64[1] = v14;
    v17.f64[1] = v16;
    v18 = RB::operator*(&v62, vcvt_f32_f64(v15), vcvt_f32_f64(v17));
    RB::Bounds::Bounds((int32x2_t *)v61, v18, v19);
    RBDrawingStateGetDeviceClipBoundingBox(*(_QWORD *)(a1 + 440));
    v21.f64[1] = v20;
    v23.f64[1] = v22;
    RB::Bounds::Bounds(v59, vcvt_f32_f64(v21), vcvt_f32_f64(v23));
    v24 = (RB *)RB::Bounds::intersect((int32x2_t *)v61, v59[0], v59[1]);
    v25 = *((_QWORD *)&v61[0] + 1);
    v26 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)v61 + 8));
    if ((vpmax_u32(v26, v26).u32[0] & 0x80000000) == 0)
    {
      if (Background)
      {
        v27 = RB::gray_colorspace(v24);
        v28 = 0;
        v25 = *((_QWORD *)&v61[0] + 1);
      }
      else
      {
        v27 = 0;
        v28 = 7;
      }
      v29 = CGBitmapContextCreate(0, (int)v25, SHIDWORD(v25), 8uLL, 0, (CGColorSpaceRef)v27, v28);
      if (v29)
      {
        v30 = v29;
        if (Background)
        {
          CGContextBeginTransparencyLayer(v29, 0);
          CGContextSetFillColorWithColor(v30, Background);
          CGContextFillRect(v30, *MEMORY[0x24BDBF028]);
        }
        CGContextTranslateCTM(v30, (double)-LODWORD(v61[0]), (double)-DWORD1(v61[0]));
        *(float64x2_t *)&transform.a = v62;
        *(_OWORD *)&transform.c = v63;
        *(_OWORD *)&transform.tx = v64;
        CGContextConcatCTM(v30, &transform);
        CGContextGetCTM(&v57, v30);
        CGContextSetBaseCTM();
        CGContextGetDelegate();
        CGContextGetRenderingState();
        CGContextGetGState();
        CGSoftMaskDelegateDrawSoftMask();
        if (Background)
          CGContextEndTransparencyLayer(v30);
        RB::cg_mask_apply_transfer((vImage_Error)v30, v4, v31);
        Image = CGBitmapContextCreateImage(v30);
        if (Image)
        {
          v33.i32[0] = 0;
          v34 = *(void **)(a1 + 16);
          v35 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)v61 + 8), (int32x2_t)0x8000000080000000);
          v36 = (int8x8_t)vdup_lane_s32(vcgt_s32(v33, (int32x2_t)vpmin_u32(v35, v35)), 0);
          v37 = (float32x2_t)vbsl_s8(v36, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v61[0]));
          v38 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
          v39 = (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)v61 + 8));
          v40 = (float32x2_t)vbsl_s8(v36, v38, v39);
          *(float *)v39.i32 = -v40.f32[1];
          v41 = COERCE_FLOAT(vadd_f32(v37, v40).i32[1]);
          v54[0] = v40.f32[0];
          v42 = (float32x2_t)vdup_lane_s32((int32x2_t)v37, 0);
          v54[1] = 0.0;
          v54[2] = 0.0;
          v42.i32[0] = v39.i32[0];
          v43 = vcvtq_f64_f32(v42);
          v55 = v43;
          v56 = v41;
          LODWORD(v43.f64[0]) = 1065353216;
          v39.i32[0] = 1065353216;
          v37.i32[0] = 1065353216;
          LODWORD(v41) = 1065353216;
          objc_msgSend(v34, "setImage:transform:interpolation:tintColor:flags:", Image, v54, 1, 0, v43.f64[0], *(double *)&v39, *(double *)&v37, v41);
          v44.i32[0] = 0;
          v45 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)v61 + 8), (int32x2_t)0x8000000080000000);
          v46 = (int8x8_t)vdup_lane_s32(vcgt_s32(v44, (int32x2_t)vpmin_u32(v45, v45)), 0);
          v47 = vbsl_s8(v46, v38, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)v61 + 8)));
          v48 = vbsl_s8(v46, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v61[0]));
          objc_msgSend(*(id *)(a1 + 8), "setRect:", *(float *)v48.i32, *(float *)&v48.i32[1], *(float *)v47.i32, *(float *)&v47.i32[1]);
          objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", 0);
          v49 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
          v50 = v49;
          if (Background)
            RBDrawingStateAddLuminanceToAlphaFilter((uint64_t)v49, 0);
          v51 = *(RB::DisplayList::State **)(a1 + 440);
          v52 = *(float64x2_t *)(a1 + 400);
          v53[0] = *(float64x2_t *)(a1 + 384);
          v53[1] = v52;
          v53[2] = *(float64x2_t *)(a1 + 416);
          RBDrawingStateSetCTM(v51, v53);
          RBDrawingStateDrawShape((uint64_t)v50, *(_QWORD *)(a1 + 8), *(float16x4_t **)(a1 + 16), 0, 1.0);
          RBDrawingStateClipLayer(*(_QWORD *)(a1 + 440), v50, 0, 1.0);
          CFRelease(Image);
        }
        CFRelease(v30);
      }
    }
  }
  else
  {
    v5 = *(RB::DisplayList::State **)(a1 + 440);
    v6.f64[0] = RB::operator*(&v62, (float64x2_t *)(a1 + 384));
    v60[0] = v6;
    v60[1] = v7;
    v60[2] = v8;
    RBDrawingStateSetCTM(v5, v60);
    v9 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
    v10 = v9;
    v11 = v9;
    if (Background)
    {
      RBDrawingStateAddLuminanceToAlphaFilter((uint64_t)v9, 0);
      v11 = RBDrawingStateBeginLayer(v10, 0);
      objc_msgSend(*(id *)(a1 + 8), "setInfinite");
      objc_msgSend(*(id *)(a1 + 16), "setColor:", RBColorFromCGColor2(Background, *(_DWORD *)(a1 + 528)));
      RBDrawingStateDrawShape((uint64_t)v11, *(_QWORD *)(a1 + 8), *(float16x4_t **)(a1 + 16), 0, 1.0);
    }
    if (RBDrawingStateBeginCGContext((uint64_t)v11, *(_DWORD *)(a1 + 460), 1.0))
    {
      CGContextGetDelegate();
      CGContextGetRenderingState();
      CGContextGetGState();
      CGSoftMaskDelegateDrawSoftMask();
      RBDrawingStateEndCGContext((uint64_t)v11, v12, v13);
    }
    if (Background)
      RBDrawingStateDrawLayer((uint64_t)v10, v11, 0, 1.0);
    RBDrawingStateClipLayer(*(_QWORD *)(a1 + 440), v10, 0, 1.0);
  }
}

void sub_209B773A4(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;

  CFRelease(v2);
  CFRelease(v1);
  _Unwind_Resume(a1);
}

RB::XML::Document *RB::ContextDelegate::add_shadow_style(uint64_t a1)
{
  double *Data;
  CGColor *Color;
  double v4;
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  RB::XML::Document *result;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  double v21;
  __float2 v22;
  BOOL v23;

  Data = (double *)CGStyleGetData();
  Color = (CGColor *)CGStyleGetColor();
  v4 = RBColorFromCGColor2(Color, *(_DWORD *)(a1 + 528));
  v6 = *(float *)&v4;
  v8 = v7;
  v10 = v9;
  v11 = fabsf(*(float *)&v4 + 1.0);
  v12 = fabsf(v8 + 1.0);
  if (v11 < v12)
    v11 = v12;
  v13 = fabsf(v10 + 1.0);
  if (v11 >= v13)
    v13 = v11;
  if (v13 >= 0.001)
  {
    v15 = v5;
    v16 = Data[5];
    v17 = 0.0;
    v18 = fmaxf(v16 * 0.5, 0.0);
    v19 = Data[2] * 0.0174532925;
    v20 = Data[1] * 0.0174532925;
    if (v20 <= 1.5691)
    {
      if (v20 >= 0.0017453)
      {
        v21 = Data[4];
        v17 = v21 / tanf(v20);
      }
      else
      {
        v17 = 3.4028e38;
      }
    }
    v22 = __sincosf_stret(v19);
    v23 = CGStyleGetDrawOrdering() == 0;
    return RBDrawingStateAddShadowStyle(*(_QWORD *)(a1 + 440), 0, 2 * v23, v18, (float)-(float)(v17 * v22.__cosval), (float)-(float)(v17 * v22.__sinval), v6, v8, v10, v15);
  }
  else
  {
    result = (RB::XML::Document *)objc_msgSend((id)RBDrawingStateGetDisplayList(*(_QWORD *)(a1 + 440)), "CGStyleHandler");
    if (result)
      return (RB::XML::Document *)(*((uint64_t (**)(RB::XML::Document *, _QWORD, unint64_t))result + 2))(result, *(_QWORD *)(a1 + 440), (unint64_t)(Data[5] + 0.5));
  }
  return result;
}

RB::XML::DisplayList *RB::ContextDelegate::add_gaussian_blur_style(uint64_t a1)
{
  double v2;

  v2 = *(double *)(CGStyleGetData() + 8) * 0.5;
  return RBDrawingStateAddBlurFilter(*(__n128 **)(a1 + 440), 0, v2, *MEMORY[0x24BDBF070], *(CGFloat *)(MEMORY[0x24BDBF070] + 8), *(CGFloat *)(MEMORY[0x24BDBF070] + 16), *(CGFloat *)(MEMORY[0x24BDBF070] + 24));
}

RB::XML::DisplayList *RB::ContextDelegate::add_color_matrix_style(uint64_t a1)
{
  uint64_t Data;
  uint64_t v3;
  float64x2_t *v4;
  float64x2_t v5;
  float64x2_t v6;
  float v8[20];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  Data = CGStyleGetData();
  v3 = 0;
  v4 = (float64x2_t *)(Data + 8);
  do
  {
    v6 = *v4;
    v5 = v4[1];
    v4 += 2;
    *(float32x4_t *)&v8[v3] = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v6), v5);
    v3 += 4;
  }
  while (v3 != 20);
  return RBDrawingStateAddColorMatrixFilter(*(_QWORD *)(a1 + 440), v8, 0);
}

uint64_t RB::ContextDelegate::draw_shading_in_shape(uint64_t a1, int a2, CGShading *a3, float64x2_t *a4)
{
  uint64_t v6;
  double x;
  double y;
  double width;
  double height;
  BOOL IsInfinite;
  _RBDrawingState *v12;
  uint64_t *v13;
  float64x2_t v14;
  void *v15;
  uint64_t v16;
  float16x4_t *v17;
  double v18;
  float v19;
  unsigned int CompositeOperation;
  unsigned int v21;
  const char *v22;
  _RBDrawingState *v23;
  float64x2_t v25[3];
  CGRect v26;

  v6 = RB::ContextDelegate::set_shading((RB::ContextDelegate *)a1, a3, (const RB::AffineTransform *)a4);
  if ((_DWORD)v6)
  {
    CGShadingGetBounds();
    x = v26.origin.x;
    y = v26.origin.y;
    width = v26.size.width;
    height = v26.size.height;
    IsInfinite = CGRectIsInfinite(v26);
    v12 = *(_RBDrawingState **)(a1 + 440);
    v13 = (uint64_t *)(a1 + 8);
    if (!IsInfinite)
    {
      v12 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 440));
      RBDrawingStateClipShape((RB::DisplayList::State *)v12, *v13, 0);
      if (a4)
      {
        v14 = a4[1];
        v25[0] = *a4;
        v25[1] = v14;
        v25[2] = a4[2];
        RBDrawingStateSetCTM((RB::DisplayList::State *)v12, v25);
      }
      v13 = (uint64_t *)(a1 + 536);
      v15 = *(void **)(a1 + 536);
      if (!v15)
      {
        v15 = (void *)objc_opt_new();

        *v13 = (uint64_t)v15;
      }
      objc_msgSend(v15, "setRect:", x, y, width, height);
      RBDrawingStateClipShape((RB::DisplayList::State *)v12, *v13, 0);
      objc_msgSend((id)*v13, "setInfinite");
    }
    v16 = *v13;
    v17 = *(float16x4_t **)(a1 + 16);
    CGGStateGetAlpha();
    v19 = v18;
    if (!*(_QWORD *)(a1 + 360))
      v19 = *(float *)(a1 + 456) * v19;
    CompositeOperation = CGGStateGetCompositeOperation();
    if (CompositeOperation > 0x1B)
      v21 = 0;
    else
    RBDrawingStateDrawShape((uint64_t)v12, v16, v17, v21, v19);
    if (!IsInfinite)
      RBDrawingStateDestroy((RB::XML::Document *)v12, v22, v23);
  }
  return v6;
}

uint64_t RB::ContextDelegate::set_shading(RB::ContextDelegate *this, CGShading *a2, const RB::AffineTransform *a3)
{
  int Type;
  double *Descriptor;
  uint64_t v7;
  CGColorSpace *ColorSpace;
  size_t NumberOfComponents;
  unint64_t RangeDimension;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  float64x2_t *v15;
  size_t v16;
  double *Domain;
  double v18;
  double v19;
  unint64_t v20;
  _DWORD *v21;
  int v22;
  int v23;
  int v24;
  void *v25;
  __int128 v26;
  _OWORD v27[3];
  __int128 v28;
  _QWORD v29[4];
  __int128 v30;
  _QWORD v31[4];
  __int128 v32;
  _QWORD v33[4];
  __int128 v34;
  _QWORD v35[4];
  __int128 v36;
  const RB::AffineTransform *v37;
  double *v38;
  int v39;
  _OWORD *v40;
  _OWORD v41[3];
  double v42;
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  Type = CGShadingGetType();
  Descriptor = (double *)CGShadingGetDescriptor();
  if (Type == 3)
  {
    v39 = 3;
    v37 = a3;
    v38 = Descriptor;
  }
  else
  {
    if (Type != 2)
    {
      if (Type == 1 && *((_BYTE *)Descriptor + 16) && *((_BYTE *)Descriptor + 40))
      {
        v39 = 1;
        v37 = a3;
        v38 = Descriptor;
        goto LABEL_12;
      }
      return 0;
    }
    if (!*((_BYTE *)Descriptor + 24) || !*((_BYTE *)Descriptor + 56))
      return 0;
    v39 = 2;
    v37 = a3;
    v38 = Descriptor;
  }
LABEL_12:
  MEMORY[0x24BDAC7A8](Descriptor, v7);
  v36 = 0u;
  v34 = 0u;
  memset(v35, 0, sizeof(v35));
  memset(v33, 0, sizeof(v33));
  v32 = 0u;
  v30 = 0u;
  memset(v31, 0, sizeof(v31));
  memset(v29, 0, sizeof(v29));
  v28 = 0u;
  memset(v27, 0, sizeof(v27));
  ColorSpace = (CGColorSpace *)CGShadingGetColorSpace();
  NumberOfComponents = CGColorSpaceGetNumberOfComponents(ColorSpace);
  RangeDimension = CGFunctionGetRangeDimension();
  v12 = RangeDimension;
  if (RangeDimension <= NumberOfComponents + 1)
    v13 = NumberOfComponents + 1;
  else
    v13 = RangeDimension;
  MEMORY[0x24BDAC7A8](RangeDimension, 8 * v13);
  v15 = (float64x2_t *)((char *)v27 - v14);
  bzero((char *)v27 - v14, v16);
  Domain = (double *)CGFunctionGetDomain();
  if (Domain)
  {
    v18 = (Domain[1] - *Domain) * 0.0666666667;
    v19 = trunc(*Domain);
  }
  else
  {
    v19 = 0.0;
    v18 = 0.0666666667;
  }
  v20 = 0;
  v40 = v27;
  v21 = (_DWORD *)v27 + 2;
  do
  {
    v42 = v19 + v18 * (double)v20;
    CGFunctionEvaluate();
    if (v12 < NumberOfComponents + 1)
      v15->f64[NumberOfComponents] = 1.0;
    *(v21 - 2) = RBColorFromComponents2(ColorSpace, v15, *((_DWORD *)this + 132)).u32[0];
    *(v21 - 1) = v22;
    *v21 = v23;
    v21[1] = v24;
    v21 += 4;
    ++v20;
  }
  while (v20 != 16);
  switch(v39)
  {
    case 1:
      objc_msgSend(*((id *)this + 2), "setAxialGradientStartPoint:endPoint:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[3], v38[4], v27[0], *(_QWORD *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((_QWORD *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1], v29[3], v30,
        v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    case 2:
      objc_msgSend(*((id *)this + 2), "setRadialGradientStartCenter:startRadius:endCenter:endRadius:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[2], v38[4], v38[5], v38[6], v27[0], *(_QWORD *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((_QWORD *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1],
        v29[3],
        v30,
        v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    case 3:
      objc_msgSend(*((id *)this + 2), "setConicGradientCenter:angle:stopCount:colors:locations:flags:", 16, v40, 0, 0, *v38, v38[1], v38[2], v27[0], *(_QWORD *)&v27[1], *(_OWORD *)((char *)&v27[1] + 8), *((_QWORD *)&v27[2] + 1), v28, v29[0], *(_OWORD *)&v29[1], v29[3], v30, v31[0],
        *(_OWORD *)&v31[1],
        v31[3],
        v32,
        v33[0],
        *(_OWORD *)&v33[1],
        v33[3],
        v34,
        v35[0],
        *(_OWORD *)&v35[1],
        v35[3],
        v36);
      break;
    default:
      abort();
  }
  if (v37)
  {
    v25 = (void *)*((_QWORD *)this + 2);
    v26 = *((_OWORD *)v37 + 1);
    v41[0] = *(_OWORD *)v37;
    v41[1] = v26;
    v41[2] = *((_OWORD *)v37 + 2);
    objc_msgSend(v25, "concat:", v41);
  }
  return 1;
}

unsigned int *RB::ContextDelegate::mask_color_in_shape(uint64_t a1, CGColor *a2, int a3, uint64_t a4, unsigned int a5, float a6)
{
  _RBDrawingState *v12;
  RB::DisplayList::State *v13;
  const char *v14;
  _RBDrawingState *v15;

  v12 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 440));
  v13 = RBDrawingStateBeginLayer((RB::DisplayList::State *)v12, 0);
  RBDrawingStateDrawShape((uint64_t)v13, *(_QWORD *)(a1 + 8), *(float16x4_t **)(a1 + 16), 0, 1.0);
  RBDrawingStateClipLayer((uint64_t)v12, v13, 0, 1.0);
  RB::ContextDelegate::set_color_in_shape(a1, a2, a3, a4, 0);
  objc_msgSend(*(id *)(a1 + 8), "setInfinite");
  RBDrawingStateDrawShape((uint64_t)v12, *(_QWORD *)(a1 + 8), *(float16x4_t **)(a1 + 16), a5, a6);
  return RBDrawingStateDestroy((RB::XML::Document *)v12, v14, v15);
}

uint64_t RB::ContextDelegate::draw_path_(uint64_t a1, uint64_t a2, const char *a3, int a4, uint64_t a5, char a6)
{
  uint64_t Info;
  int8x16_t v12;
  int8x16_t *CTM;
  unint64_t v14;
  int8x16_t v15;
  void *v16;
  BOOL v17;
  _BOOL8 v18;
  CGColor *FillColor;
  uint64_t Pattern;
  double v21;
  double v22;
  void *v23;
  uint64_t LineCap;
  uint64_t LineJoin;
  double v26;
  CGColor *StrokeColor;
  int8x16_t v29;
  int8x16_t v30;
  int8x16_t v31;
  int8x16_t v32;
  int8x16_t v33;
  int8x16_t v34;
  _OWORD v35[3];
  _BYTE v36[48];
  double v37;
  _OWORD v38[3];
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;

  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a3, a2, 0);
  if ((a6 & 1) != 0)
  {
    v33 = (int8x16_t)xmmword_209BD52A0;
    v32 = (int8x16_t)xmmword_209BD5290;
    v12 = 0uLL;
  }
  else
  {
    CTM = (int8x16_t *)CGGStateGetCTM();
    v34 = *CTM;
    v29 = CTM[1];
    v30 = CTM[2];
    v39 = *CTM;
    v40 = v29;
    v41 = v30;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v39))
      v14 = -1;
    else
      v14 = 0;
    v15 = (int8x16_t)vdupq_n_s64(v14);
    v32 = vbslq_s8(v15, v39, v34);
    v33 = vbslq_s8(v15, v40, v29);
    v12 = vbslq_s8(v15, v41, v30);
  }
  v31 = v12;
  if (a4 == 2)
    goto LABEL_15;
  v16 = *(void **)(Info + 8);
  v38[0] = v32;
  v38[1] = v33;
  v38[2] = v12;
  objc_msgSend(v16, "setPath:transform:", a5, v38);
  v17 = a4 == 1 || a4 == 4;
  v18 = v17;
  objc_msgSend(*(id *)(Info + 8), "setEOFill:", v18, *(_OWORD *)&v29);
  FillColor = (CGColor *)CGGStateGetFillColor();
  RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, a2, 1);
  if (a4 >= 2)
  {
LABEL_15:
    v39.i64[0] = 0;
    v37 = 0.0;
    if (CGGStateGetLineDash())
      Pattern = CGDashGetPattern();
    else
      Pattern = 0;
    RBDrawingStateGetCTM(*(_QWORD *)(Info + 440), (uint64_t)v36);
    CGGStateGetAdjustedLineWidth();
    v22 = v21;
    v23 = *(void **)(Info + 8);
    v35[0] = v32;
    v35[1] = v33;
    v35[2] = v31;
    LineCap = CGGStateGetLineCap();
    LineJoin = CGGStateGetLineJoin();
    CGGStateGetMiterLimit();
    objc_msgSend(v23, "setStrokedPath:transform:lineWidth:lineCap:lineJoin:miterLimit:dashPhase:dashPattern:dashCount:", a5, v35, LineCap, LineJoin, Pattern, v39.i64[0], v22, v26, v37);
    objc_msgSend(*(id *)(Info + 8), "setEOFill:", 0);
    StrokeColor = (CGColor *)CGGStateGetStrokeColor();
    RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, a2, 1);
  }
  return 0;
}

uint64_t RB::ContextDelegate::draw_image_(double a1, double a2, double a3, double a4, uint64_t a5, uint64_t a6, const char *a7, CGImage *a8, float64x2_t *a9)
{
  uint64_t Info;
  __int128 v18;
  size_t Height;
  float32x2_t v20;
  float32x2_t v21;
  float v22;
  float32x2_t v23;
  float v24;
  float32x2_t v25;
  __int128 v26;
  float v27;
  float32x2_t v28;
  float v29;
  float v30;
  float v31;
  float v32;
  unsigned int v33;
  uint64_t v34;
  double v35;
  float v36;
  unsigned int CompositeOperation;
  unsigned int v38;
  double v39;
  double v40;
  double v41;
  double v42;
  double v43;
  double v44;
  CGColor *FillColor;
  double v46;
  double v47;
  double v48;
  double v49;
  void *v50;
  uint64_t v51;
  void *v52;
  __int128 v54;
  float v55;
  float Width;
  float v57;
  double v58[6];
  double v59[6];

  Info = CGContextDelegateGetInfo();
  RB::ContextDelegate::update(Info, a7, a6, 0);
  objc_msgSend(*(id *)(Info + 8), "setRect:", a1, a2, a3, a4);
  if (a9)
  {
    Width = (float)CGImageGetWidth(a8);
    Height = CGImageGetHeight(a8);
    v20.f32[0] = Width;
    v20.f32[1] = (float)Height;
    v21.f32[0] = a1;
    v22 = a2;
    v23.f32[0] = a3;
    v24 = a4;
    v25 = vcvt_f32_f64(a9[1]);
    v21.f32[1] = v22 + v24;
    v23.f32[1] = -v24;
    *(float32x2_t *)&v26 = vsub_f32(v21, vdiv_f32(vmul_f32(v23, vcvt_f32_f64(*a9)), v25));
    v54 = v26;
    v28 = vdiv_f32(vmul_f32(v20, v23), v25);
    v27 = v28.f32[1];
    v55 = v28.f32[0];
    v29 = *((float *)&v26 + 1);
  }
  else
  {
    *(float *)&v18 = a1;
    v54 = v18;
    v30 = a2;
    v31 = a3;
    v55 = v31;
    v32 = a4;
    v29 = v30 + v32;
    v27 = -v32;
  }
  v33 = CGGStateGetInterpolationQuality() - 1;
  if (v33 > 3)
    v34 = 7;
  else
    v34 = dword_209BD77E0[v33];
  CGGStateGetAlpha();
  v36 = v35;
  if (!*(_QWORD *)(Info + 360))
    v36 = *(float *)(Info + 456) * v36;
  v57 = v36;
  CompositeOperation = CGGStateGetCompositeOperation();
  if (CompositeOperation > 0x1B)
    v38 = 0;
  else
  v39 = v29;
  v40 = v27;
  if (!CGImageIsMask(a8))
  {
    v51 = 0;
    LODWORD(v41) = 1065353216;
    LODWORD(v42) = 1065353216;
    LODWORD(v43) = 1065353216;
    LODWORD(v44) = 1065353216;
LABEL_17:
    v52 = *(void **)(Info + 16);
    v58[0] = v55;
    v58[1] = 0.0;
    v58[2] = 0.0;
    v58[3] = v40;
    v58[4] = *(float *)&v54;
    v58[5] = v39;
    objc_msgSend(v52, "setImage:transform:interpolation:tintColor:flags:", a8, v58, v34, v51, v41, v42, v43, v44, v54);
    RBDrawingStateDrawShape(*(_QWORD *)(Info + 440), *(_QWORD *)(Info + 8), *(float16x4_t **)(Info + 16), v38, v57);
    return 0;
  }
  FillColor = (CGColor *)CGGStateGetFillColor();
  if (!CGColorGetPattern(FillColor))
  {
    v41 = RBColorFromCGColor2(FillColor, *(_DWORD *)(Info + 528));
    v51 = 1;
    goto LABEL_17;
  }
  v50 = *(void **)(Info + 16);
  v59[0] = v55;
  v59[1] = 0.0;
  v59[2] = 0.0;
  v59[3] = v40;
  v59[4] = *(float *)&v54;
  v59[5] = v39;
  LODWORD(v46) = 1065353216;
  LODWORD(v47) = 1065353216;
  LODWORD(v48) = 1065353216;
  LODWORD(v49) = 1065353216;
  objc_msgSend(v50, "setImage:transform:interpolation:tintColor:flags:", a8, v59, v34, 0, v46, v47, v48, v49);
  RB::ContextDelegate::mask_color_in_shape(Info, FillColor, (int)a7, a6, v38, v57);
  return 0;
}

uint64_t RB::ContextDelegate::draw_glyphs_removing_invalid(uint64_t a1, size_t size, uint64_t a3, uint64_t a4, unsigned __int16 *a5, _OWORD *a6, unint64_t a7)
{
  unint64_t v7;
  uint64_t v10;
  char *v14;
  char *v15;
  int v16;
  char *v17;
  size_t v18;
  char v19;
  size_t v20;
  uint64_t v21;
  __int16 v22;
  int v23;
  _QWORD v25[2];

  v7 = a7;
  v10 = a4;
  v25[1] = *MEMORY[0x24BDAC8D0];
  if ((a7 & 0x8000000000000000) != 0)
  {
    v17 = 0;
    v15 = 0;
    v16 = 0;
LABEL_13:
    v19 = 1;
    goto LABEL_14;
  }
  if (2 * a7 <= 0x1000)
  {
    MEMORY[0x24BDAC7A8](a1, 2 * a7);
    v15 = (char *)v25 - ((v18 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v15, v18);
    v16 = 0;
  }
  else
  {
    v14 = (char *)malloc_type_malloc(2 * a7, 0x856C0C27uLL);
    v15 = v14;
    v16 = 1;
  }
  if (v7 >> 60)
  {
    a4 = v10;
    v17 = 0;
    goto LABEL_13;
  }
  if (16 * v7 <= 0x1000)
  {
    MEMORY[0x24BDAC7A8](v14, 16 * v7);
    v17 = (char *)v25 - ((v20 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v17, v20);
    if (!v7)
      goto LABEL_22;
    a4 = v10;
    goto LABEL_13;
  }
  v17 = (char *)malloc_type_malloc(16 * v7, 0x6B60BCF5uLL);
  if (!v7)
  {
LABEL_21:
    free(v17);
    goto LABEL_22;
  }
  a4 = v10;
  v19 = 0;
LABEL_14:
  v21 = 0;
  do
  {
    v23 = *a5++;
    v22 = v23;
    if (v23 != 0xFFFF)
    {
      *(_WORD *)&v15[2 * v21] = v22;
      *(_OWORD *)&v17[16 * v21++] = *a6;
    }
    ++a6;
    --v7;
  }
  while (v7);
  if (v21)
    RB::ContextDelegate::draw_glyphs(a1, size, a3, a4, v15, v17);
  if ((v19 & 1) == 0)
    goto LABEL_21;
LABEL_22:
  if (v16)
    free(v15);
  return 0;
}

void sub_209B782A8(_Unwind_Exception *exception_object)
{
  void *v1;
  int v2;

  if (v2)
    free(v1);
  _Unwind_Resume(exception_object);
}

BOOL RB::make_gradient(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, char a5)
{
  _BOOL8 v6;

  v6 = (a5 & 3) != 3;
  CGGradientGetColorSpace();
  CGGradientApply();
  return v6;
}

RB::LayerContextDelegate *RB::LayerContextDelegate::LayerContextDelegate(RB::LayerContextDelegate *this, const CGRect *a2, double a3)
{
  void *v6;
  CGSize size;
  _RBDrawingState *State;

  *(_QWORD *)RB::ContextDelegate::ContextDelegate(this) = &off_24C228E38;
  v6 = (void *)objc_opt_new();
  *((_QWORD *)this + 70) = v6;
  size = a2->size;
  *(CGPoint *)((char *)this + 568) = a2->origin;
  *(CGSize *)((char *)this + 584) = size;
  objc_msgSend(v6, "setDefaultColorSpace:", 1);
  objc_msgSend(*((id *)this + 70), "setContentRect:", *((double *)this + 71), *((double *)this + 72), *((double *)this + 73), *((double *)this + 74));
  State = (_RBDrawingState *)RBDisplayListGetState(*((_QWORD *)this + 70));
  RB::ContextDelegate::begin(this, State, 1.0, a3, 0);
  return this;
}

void sub_209B78450(_Unwind_Exception *a1)
{
  RB::ContextDelegate *v1;

  RB::ContextDelegate::~ContextDelegate(v1);
  _Unwind_Resume(a1);
}

void RB::LayerContextDelegate::~LayerContextDelegate(id *this, const char *a2, _RBDrawingState *a3)
{
  *this = &off_24C228E38;
  RB::ContextDelegate::end((RB::ContextDelegate *)this, a2, a3);

  RB::ContextDelegate::~ContextDelegate((RB::ContextDelegate *)this);
}

{
  RB::LayerContextDelegate::~LayerContextDelegate(this, a2, a3);
  JUMPOUT(0x20BD16544);
}

void sub_209B784AC(_Unwind_Exception *a1)
{
  id *v1;

  RB::ContextDelegate::~ContextDelegate((RB::ContextDelegate *)v1);
  _Unwind_Resume(a1);
}

void RB::make_gradient(CGGradient *,RBColor *,double *,unsigned long,RBColorSpace,unsigned int)::$_1::__invoke(uint64_t **a1, float64x2_t *a2, double a3)
{
  unsigned __int32 v5;
  uint64_t *v6;
  uint64_t v7;
  unsigned __int32 *v8;
  unsigned __int32 v9;
  unsigned __int32 v10;
  unsigned __int32 v11;

  v5 = RBColorFromComponents2((CGColorSpace *)a1[3], a2, *((_DWORD *)a1 + 8)).u32[0];
  v6 = *a1;
  v7 = **a1;
  v8 = (unsigned __int32 *)&a1[1][2 * v7];
  *v8 = v5;
  v8[1] = v9;
  v8[2] = v10;
  v8[3] = v11;
  *(double *)&a1[2][v7] = a3;
  *v6 = v7 + 1;
}

void *RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 16), __dst, 8uLL, (size_t *)__dst + 18, v3);
  *((_QWORD *)__dst + 16) = result;
  return result;
}

void *RB::vector<RB::ContextDelegate::Layer,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 42) + (*((_QWORD *)__dst + 42) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 42) + (*((_QWORD *)__dst + 42) >> 1);
  result = RB::details::realloc_vector<unsigned long,80ul>(*((void **)__dst + 40), __dst, 4uLL, (unint64_t *)__dst + 42, v3);
  *((_QWORD *)__dst + 40) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,80ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 80 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(80 * a5);
    v9 = v8 / 0x50;
    if (v8 / 0x50 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 80 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void RB::ObjectTable::adopt(RB::ObjectTable *this, CFTypeRef cf)
{
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  const void **v8;
  CFTypeRef v9;
  unsigned int v10;

  if (cf)
  {
    v4 = *((unsigned int *)this + 2);
    v5 = v4 - 16;
    if (v4 < 0x10)
      v5 = 0;
    v6 = -v5;
    if (v4 <= -v5)
    {
LABEL_8:
      v10 = v4 + 1;
      if (*((_DWORD *)this + 3) < (v4 + 1))
      {
        RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow((uint64_t)this, v10);
        LODWORD(v4) = *((_DWORD *)this + 2);
        v10 = v4 + 1;
      }
      *(_QWORD *)(*(_QWORD *)this + 8 * v4) = cf;
      *((_DWORD *)this + 2) = v10;
    }
    else
    {
      v7 = v4 - v6;
      v8 = (const void **)(*(_QWORD *)this + 8 * v6);
      while (1)
      {
        v9 = *v8++;
        if (v9 == cf)
          break;
        if (!--v7)
          goto LABEL_8;
      }
      CFRelease(cf);
    }
  }
}

_DWORD *RB::ObjectTable::adopt(_DWORD *result, unint64_t a2)
{
  _DWORD *v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  unsigned int v10;

  if (a2)
  {
    v2 = result;
    v3 = a2 | 1;
    v4 = result[2];
    v5 = v4 - 16;
    if (v4 < 0x10)
      v5 = 0;
    v6 = -v5;
    if (v4 <= -v5)
    {
LABEL_8:
      v10 = v4 + 1;
      if (result[3] < (v4 + 1))
      {
        result = RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow((uint64_t)result, v10);
        LODWORD(v4) = v2[2];
        v10 = v4 + 1;
      }
      *(_QWORD *)(*(_QWORD *)v2 + 8 * v4) = v3;
      v2[2] = v10;
    }
    else
    {
      v7 = v4 - v6;
      v8 = (uint64_t *)(*(_QWORD *)result + 8 * v6);
      while (1)
      {
        v9 = *v8++;
        if (v9 == v3)
          return (_DWORD *)(**(uint64_t (***)(unint64_t))a2)(a2);
        if (!--v7)
          goto LABEL_8;
      }
    }
  }
  return result;
}

double RB::Fill::ImageData::concat(RB::Fill::ImageData *this, float64x2_t *a2)
{
  float *v4;
  float64x2_t v5;
  float64x2_t *v6;
  float64x2_t v7;
  float64x2_t v8;
  double result;
  __int128 v10;
  _OWORD v11[2];
  int v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;

  v4 = (float *)((char *)this + 32);
  v5 = a2[1];
  v13 = *a2;
  v14 = v5;
  v15 = a2[2];
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v13))
    v6 = &v13;
  else
    v6 = a2;
  v7 = v6[1];
  v8 = v6[2];
  v13 = *v6;
  v14 = v7;
  v15 = v8;
  RB::operator*(v4, &v13, (uint64_t)v11);
  result = *(double *)v11;
  v10 = v11[1];
  *((_OWORD *)this + 2) = v11[0];
  *((_OWORD *)this + 3) = v10;
  *((_DWORD *)this + 16) = v12;
  return result;
}

uint64_t RB::Fill::ImageData::can_append_color_matrix(int a1, float16x4_t *this, char a3, __int16 a4)
{
  if ((a4 & 0xFF00) != 0)
    return 0;
  if (RB::ColorMatrix::is_alpha_multiply(this, a3))
    return 1;
  return RB::ColorMatrix::is_diagonal(this);
}

float16x4_t RB::Fill::ImageData::append_color_matrix(uint64_t a1, RB::ColorMatrix *this, int a3)
{
  __n64 v7;
  float v15;
  float32x2_t v16;
  float32x2_t v17;
  float16x4_t v18;
  float v22;
  float32x2_t v23;
  float32x2_t v24;
  unint64_t v25;
  float16x4_t v32;
  float16x4_t result;

  if (RB::ColorMatrix::is_alpha_multiply((float16x4_t *)this, a3))
  {
    v7.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color(this, a3).n64_u64[0];
    if (a3)
    {
      _H1 = v7.n64_u16[3];
      __asm { FCVT            S1, H1 }
      if (_S1 == 0.0)
      {
        _D1.n64_u32[0] = 0;
      }
      else
      {
        v15 = _S1;
        v16 = vrecpe_f32((float32x2_t)LODWORD(_S1));
        v17 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v15), v16), v16);
        _D1.n64_u64[0] = (unint64_t)vmul_f32(v17, vrecps_f32((float32x2_t)LODWORD(v15), v17));
        __asm { FCVT            H1, S1 }
      }
      LODWORD(v25) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)_D1.n64_u64[0], 0)), vcvtq_f32_f16((float16x4_t)v7.n64_u64[0]))).u32[0];
      _H3 = v7.n64_u16[2];
      __asm
      {
        FCVT            S3, H3
        FCVT            S1, H1
      }
      _S1 = _S1 * _S3;
      __asm { FCVT            H1, S1 }
      WORD2(v25) = LOWORD(_S1);
      HIWORD(v25) = v7.n64_u16[3];
      v7.n64_u64[0] = v25;
    }
    _D1.n64_u16[0] = v7.n64_u16[3];
    _H2 = *(_WORD *)(a1 + 74);
    __asm
    {
      FCVT            S1, H1
      FCVT            S3, H2
    }
    _D1.n64_f32[0] = _D1.n64_f32[0] * _S3;
    __asm { FCVT            H1, S1 }
    v32 = (float16x4_t)vdup_lane_s16((int16x4_t)_D1.n64_u64[0], 0);
    v32.i16[3] = _H2;
    result = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v32), vcvtq_f32_f16((float16x4_t)v7.n64_u64[0])));
    *(float16x4_t *)(a1 + 68) = result;
    *(_WORD *)(a1 + 76) = 0;
    *(_WORD *)(a1 + 78) |= 0x1000u;
  }
  else
  {
    v18 = *(float16x4_t *)this;
    if (a3)
    {
      _H3 = WORD2(*((_QWORD *)this + 2));
      _H4 = HIWORD(*((_QWORD *)this + 3));
      __asm { FCVT            S4, H4 }
      if (_S4 == 0.0)
      {
        _D4.i32[0] = 0;
      }
      else
      {
        v22 = _S4;
        v23 = vrecpe_f32((float32x2_t)LODWORD(_S4));
        v24 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v22), v23), v23);
        _D4 = (int16x4_t)vmul_f32(v24, vrecps_f32((float32x2_t)LODWORD(v22), v24));
        __asm { FCVT            H4, S4 }
      }
      v18.i16[1] = WORD1(*((_QWORD *)this + 1));
      v18.i32[0] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D4, 0)), vcvtq_f32_f16(v18))).u32[0];
      __asm
      {
        FCVT            S2, H3
        FCVT            S3, H4
      }
      _S2 = _S3 * _S2;
      __asm { FCVT            H2, S2 }
      v18.i16[2] = LOWORD(_S2);
    }
    else
    {
      v18.i16[1] = WORD1(*((_QWORD *)this + 1));
      v18.i16[2] = WORD2(*((_QWORD *)this + 2));
    }
    v18.i16[3] = HIWORD(*((_QWORD *)this + 3));
    result = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*(float16x4_t *)(a1 + 68)), vcvtq_f32_f16(v18)));
    *(float16x4_t *)(a1 + 68) = result;
  }
  return result;
}

uint64_t RB::Fill::ImageData::can_mix(float32x2_t *this, float32x2_t *a2)
{
  uint32x2_t v2;

  v2 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(this[1], a2[1]), (int8x8_t)vceq_f32(*this, *a2));
  if ((vpmin_u32(v2, v2).u32[0] & 0x80000000) == 0 || this[9].u16[3] != a2[9].u16[3])
    return 0;
  if (this[2].f32[0] == a2[2].f32[0]
    && this[2].f32[1] == a2[2].f32[1]
    && this[3].f32[0] == a2[3].f32[0]
    && this[3].f32[1] == a2[3].f32[1]
    && RB::ProjectionMatrix::operator==((float *)&this[4], (float *)&a2[4])
    && (!this[9].i8[5] || !a2[9].i8[5] || this[9].u8[4] == a2[9].u8[4]))
  {
    _H0 = this[8].i16[2];
    _H1 = a2[8].i16[2];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (_S0 == _S1)
    {
      _H0 = this[8].i16[3];
      _H1 = a2[8].i16[3];
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (_S0 == _S1)
      {
        _H0 = this[9].i16[0];
        _H1 = a2[9].i16[0];
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        if (_S0 == _S1)
        {
          _H0 = this[9].i16[1];
          _H1 = a2[9].i16[1];
          __asm
          {
            FCVT            S1, H1
            FCVT            S0, H0
          }
          if (_S0 == _S1)
            return 4;
        }
      }
    }
  }
  return 2;
}

BOOL RB::ProjectionMatrix::operator==(float *a1, float *a2)
{
  return *a1 == *a2
      && a1[1] == a2[1]
      && a1[2] == a2[2]
      && a1[3] == a2[3]
      && a1[4] == a2[4]
      && a1[5] == a2[5]
      && a1[6] == a2[6]
      && a1[7] == a2[7]
      && a1[8] == a2[8];
}

void RB::Fill::ImageData::mix(RB::Fill::ImageData *this, const RB::DisplayList::Interpolator::Op *a2, const RB::Fill::ImageData *a3, int8x16_t a4)
{
  int8x16_t v6;
  double v7;
  double v8;
  double v9;
  int8x16_t v10;

  *((float32x4_t *)this + 1) = vmlaq_n_f32(*((float32x4_t *)this + 1), vsubq_f32(*((float32x4_t *)a3 + 1), *((float32x4_t *)this + 1)), *(float *)a4.i32);
  RB::ProjectionMatrix::mix((float32x4_t *)this + 2, (float32x4_t *)a3 + 2, *(float *)a4.i32);
  RB::Fill::Color::mix((float16x4_t *)((char *)this + 68), (float16x4_t *)((char *)a3 + 68), 0, a4, v6, v7, v8, v9, v10);
}

float RB::Fill::ImageData::min_scale(RB::Fill::ImageData *this, const RB::AffineTransform *a2)
{
  uint64_t v2;
  float result;

  v2 = (*((_BYTE *)this + 79) & 0xF) - 1;
  result = 1.0;
  if (v2 <= 8)
    return flt_209BD78DC[v2];
  return result;
}

void RB::Fill::ImageData::fill(_QWORD *a1, uint64_t a2, RB *a3, uint16x4_t a4)
{
  CGImage *v4;
  int v18;
  int32x2_t v19;
  size_t Width;
  size_t Height;
  uint64_t v22;
  CGImageRef Image;
  CGImageRef v25;
  const RB::Fill::Color *v27;
  char v41;
  int v42;
  CGInterpolationQuality v43;
  CGInterpolationQuality InterpolationQuality;
  __int16 v45;
  float64x2_t v46;
  float64x2_t v47;
  float64x2_t v48;
  int64x2_t v49;
  unint64_t v50;
  CGContext *v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  int64x2_t v55;
  unint64_t v56;
  CGContext *v57;
  uint32x2_t v59;
  size_t v60;
  size_t v61;
  float32x2_t v62;
  float32x2_t v63;
  float32x2_t v64;
  CGImageRef v65;
  float64x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  int64x2_t v70;
  unint64_t v71;
  CGContext *v72;
  CGImage *v73;
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  float64x2_t v79;
  float64x2_t v80;
  float64x2_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  CGAffineTransform v86;
  CFTypeRef cf;
  float32x2_t v88;
  uint64_t v89;
  CGAffineTransform c[18];
  uint64_t v91;
  CGRect v92;
  CGRect v93;
  CGRect v94;
  CGRect v95;

  v4 = a3;
  v91 = *MEMORY[0x24BDAC8D0];
  if ((*((_WORD *)a1 + 39) & 0x1000) != 0)
  {
    v4 = RB::cg_image_alpha_mask(a3, (CGImage *)a2);
    v27 = (const RB::Fill::Color *)((char *)a1 + 68);
    if (*(_BYTE *)(a2 + 121))
      _ZF = *((_BYTE *)a1 + 77) == 0;
    else
      _ZF = 1;
    if (!_ZF && *(unsigned __int8 *)(a2 + 120) != *((unsigned __int8 *)a1 + 76))
      goto LABEL_21;
    _H0 = *(_WORD *)(a2 + 112);
    _H1 = *(_WORD *)v27;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_21;
    _H0 = *(_WORD *)(a2 + 114);
    _H1 = *((_WORD *)a1 + 35);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_21;
    _H0 = *(_WORD *)(a2 + 116);
    _H1 = *((_WORD *)a1 + 36);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_21;
    _H0 = *(_WORD *)(a2 + 118);
    _H1 = *((_WORD *)a1 + 37);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
LABEL_21:
      RB::CGContext::set_fill_color_slow((RB::CGContext *)a2, v27, _D0);
    goto LABEL_22;
  }
  _H0 = *((_WORD *)a1 + 34);
  __asm { FCVT            S1, H0 }
  a4.i32[0] = 1.0;
  if (_S1 == 1.0)
  {
    _H1 = *((_WORD *)a1 + 35);
    __asm { FCVT            S1, H1 }
    if (_S1 == 1.0)
    {
      _H0 = *((_WORD *)a1 + 36);
      __asm { FCVT            S1, H0 }
      a4.i32[0] = 1.0;
      if (_S1 == 1.0)
      {
        _H1 = *((_WORD *)a1 + 37);
        __asm { FCVT            S1, H1 }
        if (_S1 == 1.0)
          goto LABEL_22;
      }
    }
  }
  v18 = *(unsigned __int8 *)(a2 + 8);
  c[0].a = *(CGFloat *)((char *)a1 + 68);
  LOWORD(c[0].b) = *((_WORD *)a1 + 38);
  RB::Fill::Color::convert((uint64_t)c, v18, a4);
  v19.i32[0] = LODWORD(c[0].a);
  v19.i32[1] = WORD1(c[0].a);
  RB::ColorMatrix::set_color(&v86, COERCE_DOUBLE(vmovn_s32(vmovn_hight_s64(v19, (int64x2_t)vshlq_u64((uint64x2_t)vdupq_n_s64(*(unint64_t *)&c[0].a), (uint64x2_t)xmmword_209BD78A0)))));
  if ((RB::ColorMatrix::is_identity((float16x4_t *)&v86) & 1) != 0
    || (Width = CGImageGetWidth(v4),
        Height = CGImageGetHeight(v4),
        *(float *)&v22 = (float)Width,
        *((float *)&v22 + 1) = (float)Height,
        v88 = 0,
        v89 = v22,
        RB::CGContext::begin_bitmap((int8x8_t *)a2, &v88, 2, 257, 0, 0, (CGContext **)&cf),
        !cf))
  {
LABEL_22:
    v25 = 0;
    goto LABEL_23;
  }
  __asm { FMOV            V0.2S, #1.0 }
  RB::CGContext::CGContext(c, cf, *(unsigned __int8 *)(a2 + 8), _D0);
  v92.origin.x = v88.f32[0];
  v92.origin.y = v88.f32[1];
  v92.size.width = *(float *)&v89;
  v92.size.height = *((float *)&v89 + 1);
  CGContextDrawImage(*(CGContextRef *)&c[0].a, v92, v4);
  RB::CGContext::apply_color_matrix((RB::_anonymous_namespace_ **)c, (float16x4_t *)&v86, 0);
  Image = CGBitmapContextCreateImage(*(CGContextRef *)&c[0].a);
  v25 = Image;
  if (Image)
    v4 = Image;
  RB::CGContext::~CGContext((RB::CGContext *)c);
  if (cf)
    CFRelease(cf);
LABEL_23:
  v41 = *((_BYTE *)a1 + 79);
  _ZF = (v41 & 0xF) == 0;
  v42 = 4 * ((v41 & 0xF) == 1);
  if (_ZF)
    v43 = kCGInterpolationNone;
  else
    v43 = v42;
  InterpolationQuality = CGContextGetInterpolationQuality(*(CGContextRef *)a2);
  if (v43 != InterpolationQuality)
    CGContextSetInterpolationQuality(*(CGContextRef *)a2, v43);
  if (*(_BYTE *)(a2 + 140) != 1)
    RB::CGContext::set_aliasing_mode_slow(a2, 1);
  v45 = *((_WORD *)a1 + 39);
  if (v45 <= 6u)
  {
    if (((1 << v45) & 0x13) != 0)
    {
      memset(&v86, 0, sizeof(v86));
      v52 = vcvtq_f64_f32((float32x2_t)a1[4]);
      v53 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      v54 = vaddq_f64(vcvtq_f64_f32((float32x2_t)a1[7]), v53);
      v55 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v53, (float64x2_t)xmmword_209BD7770), (int8x16_t)vceqq_f64(v52, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v54));
      v56 = vandq_s8((int8x16_t)vdupq_laneq_s64(v55, 1), (int8x16_t)v55).u64[0];
      if ((v56 & 0x8000000000000000) == 0)
      {
        v79 = v54;
        v83 = v52;
        v75 = v53;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        v86 = c[0];
        v57 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v83;
        *(float64x2_t *)&c[0].c = vnegq_f64(v75);
        *(float64x2_t *)&c[0].tx = v79;
        CGContextConcatCTM(v57, c);
      }
      v93.origin.x = 0.0;
      v93.origin.y = 0.0;
      v93.size.width = 1.0;
      v93.size.height = 1.0;
      CGContextDrawImage(*(CGContextRef *)a2, v93, v4);
      if ((v56 & 0x8000000000000000) == 0)
        goto LABEL_36;
    }
    else if (((1 << v45) & 0x60) != 0)
    {
      v46 = vcvtq_f64_f32((float32x2_t)a1[4]);
      v47 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      v48 = vmlaq_n_f64(vmlaq_f64(vcvtq_f64_f32((float32x2_t)a1[7]), (float64x2_t)0, v46), v47, *((float *)a1 + 3) + *((float *)a1 + 1) + *((float *)a1 + 1));
      memset(&v86, 0, sizeof(v86));
      v49 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v47, (float64x2_t)xmmword_209BD7770), (int8x16_t)vceqq_f64(v46, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v48));
      v50 = vandq_s8((int8x16_t)vdupq_laneq_s64(v49, 1), (int8x16_t)v49).u64[0];
      if ((v50 & 0x8000000000000000) == 0)
      {
        v74 = v47;
        v78 = v48;
        v82 = v46;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        v86 = c[0];
        v51 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v82;
        *(float64x2_t *)&c[0].c = vnegq_f64(v74);
        *(float64x2_t *)&c[0].tx = v78;
        CGContextConcatCTM(v51, c);
        v45 = *((_WORD *)a1 + 39);
      }
      RB::cg_draw_9_slice_image(*(CGContextRef *)a2, v4, (float32x4_t *)a1 + 1, (float32x2_t *)a1, v45 == 6, 1);
      if ((v50 & 0x8000000000000000) == 0)
      {
LABEL_36:
        c[0] = v86;
        CGContextSetCTM();
      }
    }
    else if (v45 == 2)
    {
      v80 = vcvtq_f64_f32(*(float32x2_t *)((char *)a1 + 44));
      v84 = vcvtq_f64_f32((float32x2_t)a1[4]);
      v76 = vcvtq_f64_f32((float32x2_t)a1[7]);
      __asm { FMOV            V2.2S, #1.0 }
      v59 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32((float32x2_t)a1[1], _D2), (int8x8_t)vceqz_f32(*(float32x2_t *)a1));
      if ((vpmin_u32(v59, v59).u32[0] & 0x80000000) != 0)
      {
        v65 = 0;
        v68 = v80;
        v67 = v84;
        v66 = v76;
      }
      else
      {
        v60 = CGImageGetWidth(v4);
        v61 = CGImageGetHeight(v4);
        v62.f32[0] = (float)v60;
        v62.f32[1] = (float)v61;
        v63 = vmul_f32(*(float32x2_t *)a1, v62);
        v64 = vmul_f32((float32x2_t)a1[1], v62);
        v94.origin.x = v63.f32[0];
        v94.origin.y = v63.f32[1];
        v94.size.width = v64.f32[0];
        v94.size.height = v64.f32[1];
        v65 = CGImageCreateWithImageInRect(v4, v94);
        v66 = vmlaq_n_f64(vmlaq_n_f64(v76, v84, COERCE_FLOAT(*a1)), v80, COERCE_FLOAT(HIDWORD(*a1)));
        v67 = vmulq_n_f64(v84, COERCE_FLOAT(a1[1]));
        v68 = vmulq_n_f64(v80, COERCE_FLOAT(HIDWORD(a1[1])));
      }
      v69 = vaddq_f64(v66, v68);
      v85 = v67;
      memset(&v86, 0, sizeof(v86));
      v81 = v68;
      v70 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v68, (float64x2_t)xmmword_209BD7770), (int8x16_t)vceqq_f64(v67, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v69));
      v71 = vandq_s8((int8x16_t)vdupq_laneq_s64(v70, 1), (int8x16_t)v70).u64[0];
      if ((v71 & 0x8000000000000000) == 0)
      {
        v77 = v69;
        CGContextGetCTM(c, *(CGContextRef *)a2);
        v86 = c[0];
        v72 = *(CGContext **)a2;
        *(float64x2_t *)&c[0].a = v85;
        *(float64x2_t *)&c[0].c = vnegq_f64(v81);
        *(float64x2_t *)&c[0].tx = v77;
        CGContextConcatCTM(v72, c);
      }
      if (v65)
        v73 = v65;
      else
        v73 = v4;
      v95.origin.x = 0.0;
      v95.origin.y = 0.0;
      v95.size.width = 1.0;
      v95.size.height = 1.0;
      CGContextDrawTiledImage(*(CGContextRef *)a2, v95, v73);
      if ((v71 & 0x8000000000000000) == 0)
      {
        c[0] = v86;
        CGContextSetCTM();
      }
      if (v65)
        CFRelease(v65);
    }
  }
  if (v43 != InterpolationQuality)
    CGContextSetInterpolationQuality(*(CGContextRef *)a2, InterpolationQuality);
  if (v25)
    CFRelease(v25);
}

void sub_209B79388(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,CFTypeRef cf,uint64_t a23,uint64_t a24,char a25)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Fill::ImageData::matches(RB::Fill::ImageData *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  if ((*((_WORD *)this + 39) & 0x1000) != 0)
    return RB::DisplayList::Predicate::matches_color(a2, (RB::Fill::ImageData *)((char *)this + 68), a3);
  else
    return RB::DisplayList::Predicate::matches_non_color(a2);
}

void RB::Fill::ImageData::apply_transform(RB::Fill::ImageData *this, const RB::DisplayList::Transform *a2, RB::Heap *a3, uint32x4_t a4)
{
  if ((*((_WORD *)this + 39) & 0x1000) != 0)
    RB::DisplayList::Transform::apply_to_color(a2, (float16x4_t *)((char *)this + 68), a4);
}

unint64_t RB::Fill::ImageData::can_get_image(uint64_t a1, float64x2_t *a2, double a3)
{
  uint32x2_t v9;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  int64x2_t v25;
  double v26;
  float64x2_t v27[3];

  __asm { FMOV            V2.2S, #1.0 }
  v9 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(a1 + 8), _D2), (int8x8_t)vceqz_f32(*(float32x2_t *)a1));
  if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) == 0)
    return 0;
  if (*(float *)(a1 + 16) != 0.0)
    return 0;
  if (*(float *)(a1 + 20) != 0.0)
    return 0;
  if (*(float *)(a1 + 24) != 0.0)
    return 0;
  if (*(float *)(a1 + 28) != 0.0)
    return 0;
  _H0 = *(_WORD *)(a1 + 68);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    return 0;
  _H1 = *(_WORD *)(a1 + 70);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    return 0;
  _H0 = *(_WORD *)(a1 + 72);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    return 0;
  _H1 = *(_WORD *)(a1 + 74);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    return 0;
  if ((*(_WORD *)(a1 + 78) & 0x10FF) != 0)
    return 0;
  if (*(float *)(a1 + 40) != 0.0)
    return 0;
  if (*(float *)(a1 + 52) != 0.0)
    return 0;
  v26 = a3;
  if (*(float *)(a1 + 64) != 1.0)
    return 0;
  v19 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 44));
  v20 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 56));
  v27[0] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 32));
  v27[1] = v19;
  v27[2] = v20;
  v21.f64[0] = RB::operator*(v27, a2);
  v22.f64[0] = 0.0;
  v22.f64[1] = (double)SHIDWORD(v26);
  v25 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v23, v22), vandq_s8((int8x16_t)vceqq_f64(v21, (float64x2_t)COERCE_UNSIGNED_INT64((double)SLODWORD(v26))), (int8x16_t)vceqzq_f64(v24)));
  return vandq_s8((int8x16_t)vdupq_laneq_s64(v25, 1), (int8x16_t)v25).u64[0] >> 63;
}

_QWORD *RB::Fill::ImageData::encode(RB::Fill::ImageData *this, RB::Encoder *a2, int32x4_t a3, int32x4_t a4)
{
  unint64_t v6;
  float32x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  uint32x2_t v23;
  float32x4_t v24;
  int v25;
  _QWORD *result;
  int v27;
  __int16 v28;
  _OWORD v29[3];

  v6 = *((unsigned __int8 *)this + 78);
  if (*((_BYTE *)this + 78))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    RB::ProtobufEncoder::encode_varint(a2, v6);
  }
  v7 = *(float32x2_t *)((char *)this + 32);
  if (v7.f32[0] != 1.0
    || v7.f32[1] != 0.0
    || *((float *)this + 10) != 0.0
    || *((float *)this + 11) != 0.0
    || *((float *)this + 12) != 1.0
    || *((float *)this + 13) != 0.0
    || *((float *)this + 14) != 0.0
    || *((float *)this + 15) != 0.0
    || *((float *)this + 16) != 1.0)
  {
    v8 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 44));
    v9 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 56));
    v29[0] = vcvtq_f64_f32(v7);
    v29[1] = v8;
    v29[2] = v9;
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::AffineTransform::encode((double *)v29, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  _H0 = *((_WORD *)this + 34);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_17;
  _H1 = *((_WORD *)this + 35);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    goto LABEL_17;
  _H0 = *((_WORD *)this + 36);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_17;
  _H1 = *((_WORD *)this + 37);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
  {
LABEL_17:
    RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::Fill::ImageData *)((char *)this + 68), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  __asm { FMOV            V3.2S, #1.0 }
  v23 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)((char *)this + 8), _D3), (int8x8_t)vceqz_f32(*(float32x2_t *)this));
  if ((vpmin_u32(v23, v23).u32[0] & 0x80000000) == 0)
    RB::ProtobufEncoder::float4_field(a2, 5, *(float32x4_t *)this);
  a3.i64[0] = *((_QWORD *)this + 2);
  *(int32x2_t *)a4.i8 = vceqz_f32(*(float32x2_t *)a3.i8);
  if ((a4.i32[0] & a4.i32[1] & 1) == 0 || *((float *)this + 6) != 0.0 || *((float *)this + 7) != 0.0)
  {
    a4.i32[0] = *((_DWORD *)this + 6);
    v24 = (float32x4_t)vzip1q_s32(a4, a3);
    v24.i32[2] = *((_DWORD *)this + 7);
    RB::ProtobufEncoder::float4_field(a2, 6, v24);
  }
  if (*((_WORD *)this + 39) == 4)
  {
    a3.i32[0] = *((_DWORD *)this + 10);
    a3.i32[1] = *((_DWORD *)this + 13);
    a3.i32[2] = *((_DWORD *)this + 16);
    RB::ProtobufEncoder::float3_field(a2, 7, (float32x4_t)a3);
    LOBYTE(v25) = *((_BYTE *)this + 79);
  }
  else
  {
    v25 = HIBYTE(*((unsigned __int16 *)this + 39));
  }
  result = (_QWORD *)rb_interpolation_mode(v25 & 0xF);
  if ((_DWORD)result != 1)
  {
    v27 = (int)result;
    RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, v27);
  }
  v28 = *((_WORD *)this + 39);
  if ((v28 & 0x1000) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v28 = *((_WORD *)this + 39);
    if ((v28 & 0x2000) == 0)
    {
LABEL_31:
      if ((v28 & 0x4000) == 0)
        return result;
      goto LABEL_32;
    }
  }
  else if ((*((_WORD *)this + 39) & 0x2000) == 0)
  {
    goto LABEL_31;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
  result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*((_WORD *)this + 39) & 0x4000) == 0)
    return result;
LABEL_32:
  RB::ProtobufEncoder::encode_varint(a2, 0x58uLL);
  return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
}

unint64_t RB::Fill::ImageData::decode@<X0>(RB::ProtobufDecoder *this@<X1>, uint64_t a2@<X0>, uint64_t a3@<X8>)
{
  unint64_t result;
  unint64_t v7;
  unint64_t v8;
  __int16 v9;
  double v10;
  double v11;
  double v12;
  double v13;
  int64x2_t v14;
  float v15;
  float v16;
  float v17;
  float v18;
  float v19;
  float v20;
  __n128 v21;
  __n128 v22;
  unsigned int v23;
  int v24;
  __int16 v25;
  __int16 v26;
  __int128 v27;
  __int128 v28;
  int64x2_t v29;
  int64x2_t v30;

  *(_QWORD *)(a3 + 16) = 0;
  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v7 = result;
    do
    {
      switch((v7 >> 3))
      {
        case 1u:
          v27 = *(_OWORD *)this;
          RB::ProtobufDecoder::skip_field(this, v7);
          *(_OWORD *)a3 = v27;
          *(_QWORD *)(a3 + 16) = v7;
          break;
        case 2u:
          v8 = RB::ProtobufDecoder::uint_field(this, v7);
          if (v8 <= 6)
          {
            v9 = v8 | (*(unsigned __int8 *)(a2 + 79) << 8);
            goto LABEL_28;
          }
          break;
        case 3u:
          v28 = xmmword_209BD5290;
          v29 = (int64x2_t)xmmword_209BD52A0;
          v30 = 0uLL;
          if ((v7 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(this);
            RB::AffineTransform::decode((RB::AffineTransform *)&v28, this);
            RB::ProtobufDecoder::end_message((uint64_t)this);
            v11 = *(double *)&v28;
            v10 = *(double *)v29.i64;
            v12 = *((double *)&v28 + 1);
            v13 = *(double *)v30.i64;
            v14 = vzip2q_s64(v30, v29);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *(_QWORD *)this = *((_QWORD *)this + 1);
            v12 = 0.0;
            v13 = 0.0;
            v14 = (int64x2_t)xmmword_209BD52A0;
            v11 = 1.0;
            v10 = 0.0;
          }
          v15 = v11;
          v16 = v12;
          *(float *)(a2 + 32) = v15;
          *(float *)(a2 + 36) = v16;
          v17 = v10;
          v18 = *(double *)&v14.i64[1];
          *(float *)(a2 + 44) = v17;
          *(float *)(a2 + 48) = v18;
          v19 = v13;
          v20 = *(double *)v14.i64;
          *(float *)(a2 + 56) = v19;
          *(float *)(a2 + 60) = v20;
          break;
        case 4u:
          if ((v7 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(this);
            RB::Fill::Color::decode(a2 + 68, this);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *(_QWORD *)this = *((_QWORD *)this + 1);
          }
          break;
        case 5u:
          *(__n128 *)a2 = RB::ProtobufDecoder::float4_field(this, v7);
          break;
        case 6u:
          v21 = RB::ProtobufDecoder::float4_field(this, v7);
          *(int32x4_t *)(a2 + 16) = vuzp2q_s32((int32x4_t)v21, vrev64q_s32((int32x4_t)v21));
          break;
        case 7u:
          v22 = RB::ProtobufDecoder::float3_field(this, v7);
          *(_DWORD *)(a2 + 40) = v22.n128_u32[0];
          *(_DWORD *)(a2 + 52) = v22.n128_u32[1];
          *(_DWORD *)(a2 + 64) = v22.n128_u32[2];
          break;
        case 8u:
          v23 = RB::ProtobufDecoder::uint_field(this, v7);
          v9 = *(_WORD *)(a2 + 78) & 0xF0FF | ((rb_interpolation_mode(v23) & 0xF) << 8);
          goto LABEL_28;
        case 9u:
          v24 = RB::ProtobufDecoder::BOOL_field(this, v7);
          v25 = *(_WORD *)(a2 + 78);
          if (v24)
            v26 = 4096;
          else
            v26 = 0;
          goto LABEL_27;
        case 0xAu:
          if (RB::ProtobufDecoder::BOOL_field(this, v7))
            v25 = 0x2000;
          else
            v25 = 0;
          goto LABEL_26;
        case 0xBu:
          if (RB::ProtobufDecoder::BOOL_field(this, v7))
            v25 = 0x4000;
          else
            v25 = 0;
LABEL_26:
          v26 = *(_WORD *)(a2 + 78);
LABEL_27:
          v9 = v25 | v26;
LABEL_28:
          *(_WORD *)(a2 + 78) = v9;
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v7);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v7 = result;
    }
    while (result);
  }
  return result;
}

uint64_t RB::Fill::ImageData::attributes(RB::Fill::ImageData *this, RB::XML::Element *a2)
{
  float64x2_t v4;
  int v5;
  char v6;
  float32x2_t v7;
  float32x2_t v8;
  uint32x2_t v14;
  float64_t v15;
  float64_t v16;
  float64_t v17;
  float64_t v18;
  float32x2_t v19;
  float32x2_t v20;
  uint64_t result;
  int v22;
  __int16 v31;
  void *v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;

  v32 = &unk_24C229330;
  v4 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 44));
  v33 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 32));
  v34 = v4;
  v35 = vcvtq_f64_f32(*(float32x2_t *)((char *)this + 56));
  RB::XML::Element::set<RB::XML::Value::Transform>(a2, (uint64_t)"image-transform", (uint64_t)&v32);
  v5 = *((unsigned __int8 *)this + 78);
  switch(v5)
  {
    case 2:
      v7 = *(float32x2_t *)this;
      v8 = *(float32x2_t *)((char *)this + 8);
      __asm { FMOV            V3.2S, #1.0 }
      v14 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(v8, _D3), (int8x8_t)vceqz_f32(*(float32x2_t *)this));
      if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) == 0)
      {
        v32 = &unk_24C229100;
        v33 = vcvtq_f64_f32(v7);
        v34 = vcvtq_f64_f32(v8);
        RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)"image-src", (uint64_t)&v32);
      }
LABEL_9:
      v32 = &unk_24C229010;
      LOBYTE(v33.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"repeated", (uint64_t)&v32);
      goto LABEL_10;
    case 5:
      v6 = 0;
      break;
    case 6:
      v6 = 1;
      break;
    default:
      goto LABEL_10;
  }
  v15 = *((float *)this + 6);
  v16 = *((float *)this + 4);
  v17 = *((float *)this + 7);
  v18 = *((float *)this + 5);
  v32 = &unk_24C229100;
  v33.f64[0] = v15;
  v33.f64[1] = v16;
  v34.f64[0] = v17;
  v34.f64[1] = v18;
  RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)"edge-insets", (uint64_t)&v32);
  v19 = *(float32x2_t *)this;
  v20 = *(float32x2_t *)((char *)this + 8);
  v32 = &unk_24C229100;
  v33 = vcvtq_f64_f32(v19);
  v34 = vcvtq_f64_f32(v20);
  RB::XML::Element::set<RB::XML::Value::Vec4>(a2, (uint64_t)"image-dest", (uint64_t)&v32);
  if ((v6 & 1) != 0)
    goto LABEL_9;
LABEL_10:
  result = *((_BYTE *)this + 79) & 0xF;
  if ((_DWORD)result != 1)
  {
    v22 = rb_interpolation_mode(result);
    v32 = &unk_24C228F98;
    LODWORD(v33.f64[0]) = v22;
    result = (uint64_t)RB::XML::Element::set<RB::XML::Value::InterpolationMode>(a2, (uint64_t)"interpolation", (uint64_t)&v32);
  }
  _H0 = *((_WORD *)this + 34);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_16;
  _H1 = *((_WORD *)this + 35);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    goto LABEL_16;
  _H0 = *((_WORD *)this + 36);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_16;
  _H1 = *((_WORD *)this + 37);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
  {
LABEL_16:
    RB::XML::Value::Color::Color((RB::XML::Value::Color *)&v32, (float16x4_t *)((char *)this + 68));
    result = (uint64_t)RB::XML::Element::set<RB::XML::Value::Color>(a2, (uint64_t)"tint-color", (uint64_t)&v32);
  }
  v31 = *((_WORD *)this + 39);
  if ((v31 & 0x1000) != 0)
  {
    v32 = &unk_24C229010;
    LOBYTE(v33.f64[0]) = 1;
    result = (uint64_t)RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"splat-alpha", (uint64_t)&v32);
    v31 = *((_WORD *)this + 39);
    if ((v31 & 0x2000) == 0)
    {
LABEL_19:
      if ((v31 & 0x4000) == 0)
        return result;
      goto LABEL_20;
    }
  }
  else if ((*((_WORD *)this + 39) & 0x2000) == 0)
  {
    goto LABEL_19;
  }
  v32 = &unk_24C229010;
  LOBYTE(v33.f64[0]) = 1;
  result = (uint64_t)RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"dither", (uint64_t)&v32);
  if ((*((_WORD *)this + 39) & 0x4000) == 0)
    return result;
LABEL_20:
  v32 = &unk_24C229010;
  LOBYTE(v33.f64[0]) = 1;
  return (uint64_t)RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"linear-color", (uint64_t)&v32);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::InterpolationMode>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228F98;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::InterpolationMode,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::InterpolationMode,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229B60;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B79EF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::InterpolationMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::InterpolationMode>,std::allocator<RB::XML::Value::InterpolationMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::InterpolationMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::InterpolationMode>,std::allocator<RB::XML::Value::InterpolationMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

RB::DisplayList::Predicate::Term *RB::DisplayList::Predicate::Term::Term(RB::DisplayList::Predicate::Term *this, const RB::DisplayList::Predicate *a2, char a3)
{
  RB::DisplayList::InvertiblePredicate *v6;

  *(_DWORD *)this = 3;
  v6 = (RB::DisplayList::InvertiblePredicate *)operator new();
  RB::DisplayList::InvertiblePredicate::InvertiblePredicate(v6, a2, a3);
  *((_QWORD *)this + 1) = v6;
  return this;
}

void sub_209B79FB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1020C4057BCEDDBLL);
  _Unwind_Resume(a1);
}

RB::DisplayList::Predicate::Term *RB::DisplayList::Predicate::Term::Term(RB::DisplayList::Predicate::Term *this, const RB::DisplayList::Predicate::Term *a2)
{
  int v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  const RB::DisplayList::Predicate::Term *v10;
  unsigned int v11;
  _QWORD *v12;
  unsigned int v13;
  RB::DisplayList::Predicate::Term *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;

  v4 = *(_DWORD *)a2;
  *(_DWORD *)this = *(_DWORD *)a2;
  v5 = (_QWORD *)((char *)this + 8);
  switch(v4)
  {
    case 3:
      v7 = (_QWORD *)operator new();
      v8 = v7;
      v9 = *((_QWORD *)a2 + 1);
      v7[3] = 0;
      v7[4] = 0x100000000;
      if (*(_QWORD *)(v9 + 24))
        v10 = *(const RB::DisplayList::Predicate::Term **)(v9 + 24);
      else
        v10 = (const RB::DisplayList::Predicate::Term *)v9;
      v11 = *(_DWORD *)(v9 + 32);
      if (v11 >= 2)
      {
        RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(v7, *(_DWORD *)(v9 + 32));
        v12 = (_QWORD *)v8[3];
        v13 = *((_DWORD *)v8 + 8);
      }
      else
      {
        if (!v11)
        {
          v17 = 0;
LABEL_18:
          *((_DWORD *)v8 + 8) = v17 + v11;
          *((_BYTE *)v8 + 40) = *(_BYTE *)(v9 + 40);
          *v5 = v8;
          return this;
        }
        v12 = 0;
        v13 = 0;
      }
      if (!v12)
        v12 = v8;
      v14 = (RB::DisplayList::Predicate::Term *)&v12[3 * v13];
      v15 = v11;
      do
      {
        v16 = RB::DisplayList::Predicate::Term::Term(v14, v10);
        v10 = (const RB::DisplayList::Predicate::Term *)((char *)v10 + 24);
        v14 = (RB::DisplayList::Predicate::Term *)(v16 + 24);
        --v15;
      }
      while (v15);
      v17 = *((_DWORD *)v8 + 8);
      goto LABEL_18;
    case 2:
      v6 = *((_QWORD *)a2 + 1);
      *((_WORD *)this + 8) = *((_WORD *)a2 + 8);
      *v5 = v6;
      break;
    case 1:
      *(_DWORD *)v5 = *((_DWORD *)a2 + 2);
      break;
  }
  return this;
}

void sub_209B7A114(_Unwind_Exception *a1)
{
  RB::DisplayList::Predicate::Term *v1;
  RB::DisplayList::Predicate::Term *v3;

  v3 = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::~vector(v1);
  MEMORY[0x20BD16544](v3, 0x1020C4057BCEDDBLL);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Predicate::Term::~Term(RB::DisplayList::Predicate::Term *this)
{
  uint64_t v1;
  void *v2;
  RB::DisplayList::Predicate::Term *v3;
  unint64_t v4;
  uint64_t v5;

  if (*(_DWORD *)this == 3)
  {
    v1 = *((_QWORD *)this + 1);
    if (v1)
    {
      v2 = *(void **)(v1 + 24);
      if (v2)
        v3 = *(RB::DisplayList::Predicate::Term **)(v1 + 24);
      else
        v3 = (RB::DisplayList::Predicate::Term *)*((_QWORD *)this + 1);
      if (*(_DWORD *)(v1 + 32))
      {
        v4 = 0;
        do
        {
          RB::DisplayList::Predicate::Term::~Term(v3);
          ++v4;
          v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
        }
        while (v4 < *(unsigned int *)(v1 + 32));
        v2 = *(void **)(v1 + 24);
      }
      if (v2)
        free(v2);
      MEMORY[0x20BD16544](v1, 0x1020C4057BCEDDBLL);
    }
  }
}

_QWORD *RB::DisplayList::Predicate::clear(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  if (this[3])
    this = (_QWORD *)this[3];
  v2 = *((unsigned int *)v1 + 8);
  if ((_DWORD)v2)
  {
    v3 = 24 * v2;
    do
    {
      RB::DisplayList::Predicate::Term::~Term((RB::DisplayList::Predicate::Term *)this);
      this = (_QWORD *)(v4 + 24);
      v3 -= 24;
    }
    while (v3);
  }
  *((_DWORD *)v1 + 8) = 0;
  return this;
}

_DWORD *RB::DisplayList::Predicate::add(_DWORD *this, int a2)
{
  _DWORD *v3;
  int v4;
  _DWORD *v5;
  _DWORD *v6;

  v3 = this;
  v4 = this[8];
  if (this[9] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    v4 = v3[8];
  }
  v5 = (_DWORD *)*((_QWORD *)v3 + 3);
  if (!v5)
    v5 = v3;
  v6 = &v5[6 * v4];
  *v6 = 1;
  v6[2] = a2;
  ++v3[8];
  return this;
}

_DWORD *RB::DisplayList::Predicate::add_color(_DWORD *this, const RB::Fill::Color *a2)
{
  _DWORD *v3;
  int v4;
  _DWORD *v5;
  _DWORD *v6;
  uint64_t v7;

  v3 = this;
  v4 = this[8];
  if (this[9] < (v4 + 1))
  {
    this = RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v4 + 1);
    v4 = v3[8];
  }
  v5 = (_DWORD *)*((_QWORD *)v3 + 3);
  if (!v5)
    v5 = v3;
  v6 = &v5[6 * v4];
  *v6 = 2;
  v7 = *(_QWORD *)a2;
  *((_WORD *)v6 + 8) = *((_WORD *)a2 + 4);
  *((_QWORD *)v6 + 1) = v7;
  ++v3[8];
  return this;
}

RB::DisplayList::Predicate::Term *RB::DisplayList::Predicate::add_predicate(RB::DisplayList::Predicate *this, const RB::DisplayList::Predicate *a2, char a3)
{
  unsigned int v6;
  RB::DisplayList::Predicate *v7;
  RB::DisplayList::Predicate::Term *result;

  v6 = *((_DWORD *)this + 8);
  if (*((_DWORD *)this + 9) < v6 + 1)
  {
    RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v6 + 1);
    v6 = *((_DWORD *)this + 8);
  }
  v7 = (RB::DisplayList::Predicate *)*((_QWORD *)this + 3);
  if (!v7)
    v7 = this;
  result = RB::DisplayList::Predicate::Term::Term((RB::DisplayList::Predicate *)((char *)v7 + 24 * v6), a2, a3);
  ++*((_DWORD *)this + 8);
  return result;
}

uint64_t RB::DisplayList::Predicate::matches_color(RB::DisplayList::Predicate *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  RB::DisplayList::Predicate *v3;
  uint64_t v4;
  RB::DisplayList::Predicate **v6;
  uint64_t v7;
  int v8;
  RB::DisplayList::Predicate *v9;

  if (*((_QWORD *)this + 3))
    v3 = (RB::DisplayList::Predicate *)*((_QWORD *)this + 3);
  else
    v3 = this;
  v4 = *((unsigned int *)this + 8);
  if (!(_DWORD)v4)
    return 1;
  v6 = (RB::DisplayList::Predicate **)((char *)v3 + 8);
  v7 = 24 * v4;
  while (1)
  {
    v8 = *((_DWORD *)v6 - 2);
    if (v8 != 3)
      break;
    v9 = *v6;
    if (RB::DisplayList::Predicate::matches_color(*v6, a2) == (*((_BYTE *)v9 + 40) != 0))
      return 0;
LABEL_11:
    v6 += 3;
    v7 -= 24;
    if (!v7)
      return 1;
  }
  if (v8 != 2 || (RB::Fill::Color::matches((float16x4_t *)v6, (float16x4_t *)a2, a3) & 1) != 0)
    goto LABEL_11;
  return 0;
}

uint64_t RB::DisplayList::Predicate::matches_non_color(RB::DisplayList::Predicate *this)
{
  RB::DisplayList::Predicate *v1;
  uint64_t v2;
  RB::DisplayList::Predicate **v3;
  uint64_t v4;
  int v5;
  RB::DisplayList::Predicate *v6;

  if (*((_QWORD *)this + 3))
    v1 = (RB::DisplayList::Predicate *)*((_QWORD *)this + 3);
  else
    v1 = this;
  v2 = *((unsigned int *)this + 8);
  if (!(_DWORD)v2)
    return 1;
  v3 = (RB::DisplayList::Predicate **)((char *)v1 + 8);
  v4 = 24 * v2;
  while (1)
  {
    v5 = *((_DWORD *)v3 - 2);
    if (v5 != 1)
      break;
    if (!*(_DWORD *)v3)
      return 0;
LABEL_13:
    v3 += 3;
    v4 -= 24;
    if (!v4)
      return 1;
  }
  if (v5 != 3)
  {
    if (v5 == 2)
      return 0;
    goto LABEL_13;
  }
  v6 = *v3;
  if (((RB::DisplayList::Predicate::matches_non_color(*v3) ^ (*((_BYTE *)v6 + 40) != 0)) & 1) != 0)
    goto LABEL_13;
  return 0;
}

uint64_t RB::DisplayList::Predicate::Term::can_mix(RB::DisplayList::InvertiblePredicate **this, const RB::DisplayList::InvertiblePredicate **a2)
{
  int v2;

  v2 = *(_DWORD *)this;
  if (*(_DWORD *)this != *(_DWORD *)a2)
    return 0;
  if (v2 == 3)
    return RB::DisplayList::InvertiblePredicate::can_mix(this[1], a2[1]);
  if (v2 != 2)
  {
    if (v2 != 1 || *((_DWORD *)this + 2) == *((_DWORD *)a2 + 2))
      return 4;
    return 0;
  }
  return RB::Fill::Color::can_mix((RB::Fill::Color *)(this + 1), (const RB::Fill::Color *)(a2 + 1));
}

uint64_t RB::DisplayList::InvertiblePredicate::can_mix(RB::DisplayList::InvertiblePredicate *this, const RB::DisplayList::InvertiblePredicate *a2)
{
  if (*((unsigned __int8 *)this + 40) == *((unsigned __int8 *)a2 + 40))
    return RB::DisplayList::Predicate::can_mix(this, a2);
  else
    return 0;
}

void RB::DisplayList::Predicate::Term::mix(RB::DisplayList::Predicate::Term *this, const RB::DisplayList::Predicate **a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  if (*(_DWORD *)this == 3)
  {
    RB::DisplayList::Predicate::mix(*((_QWORD *)this + 1), a2[1], *(float *)a3.i32);
  }
  else if (*(_DWORD *)this == 2)
  {
    RB::Fill::Color::mix((float16x4_t *)this + 1, (float16x4_t *)a2 + 1, 0, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t RB::DisplayList::Predicate::can_mix(RB::DisplayList::Predicate *this, const RB::DisplayList::Predicate *a2)
{
  uint64_t v2;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  RB::DisplayList::Predicate *v8;
  RB::DisplayList::InvertiblePredicate **v9;
  const RB::DisplayList::Predicate *v10;
  unsigned int can_mix;

  v2 = *((unsigned int *)this + 8);
  if ((_DWORD)v2 != *((_DWORD *)a2 + 8))
    return 0;
  if (!(_DWORD)v2)
    return 4;
  v5 = 0;
  v6 = 24 * v2;
  LOBYTE(v7) = 4;
  do
  {
    v8 = (RB::DisplayList::Predicate *)*((_QWORD *)this + 3);
    if (!v8)
      v8 = this;
    v9 = (RB::DisplayList::InvertiblePredicate **)((char *)v8 + v5);
    v10 = (const RB::DisplayList::Predicate *)*((_QWORD *)a2 + 3);
    if (!v10)
      v10 = a2;
    can_mix = RB::DisplayList::Predicate::Term::can_mix(v9, (const RB::DisplayList::InvertiblePredicate **)((char *)v10 + v5));
    if (can_mix >= v7)
      v7 = v7;
    else
      v7 = can_mix;
    if (!(_DWORD)v7)
      break;
    v5 += 24;
  }
  while (v6 != v5);
  return v7;
}

uint64_t RB::DisplayList::Predicate::mix(uint64_t this, const RB::DisplayList::Predicate *a2, float a3)
{
  uint64_t v3;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  RB::DisplayList::Predicate::Term *v10;
  const RB::DisplayList::Predicate *v11;

  v3 = *(unsigned int *)(this + 32);
  if ((_DWORD)v3)
  {
    v6 = this;
    v7 = 0;
    v8 = 24 * v3;
    do
    {
      v9 = *(_QWORD *)(v6 + 24);
      if (!v9)
        v9 = v6;
      v10 = (RB::DisplayList::Predicate::Term *)(v9 + v7);
      v11 = (const RB::DisplayList::Predicate *)*((_QWORD *)a2 + 3);
      if (!v11)
        v11 = a2;
      this = RB::DisplayList::Predicate::Term::mix(v10, (const RB::DisplayList::Predicate *)((char *)v11 + v7), a3);
      v7 += 24;
    }
    while (v8 != v7);
  }
  return this;
}

uint64_t RB::DisplayList::Predicate::xml_elements(uint64_t this, RB::XML::Document *a2)
{
  uint64_t v2;
  uint64_t v3;
  float16x4_t *v5;
  uint64_t i;
  __int32 v7;
  _QWORD *v8;
  RB::DisplayList::Predicate *v9;
  _QWORD *v10;
  void *v11;
  char v12;

  if (*(_QWORD *)(this + 24))
    v2 = *(_QWORD *)(this + 24);
  else
    v2 = this;
  v3 = *(unsigned int *)(this + 32);
  if ((_DWORD)v3)
  {
    v5 = (float16x4_t *)(v2 + 8);
    for (i = 24 * v3; i; i -= 24)
    {
      v7 = v5[-1].i32[0];
      if (v7 == 3)
      {
        RB::XML::Document::push(a2, "predicate");
        v9 = (RB::DisplayList::Predicate *)*v5;
        if (*(_BYTE *)(*(_QWORD *)v5 + 40))
        {
          v10 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
          v11 = &unk_24C229010;
          v12 = 1;
          RB::XML::Element::set<RB::XML::Value::Bool>(v10, (uint64_t)"inverts-result", (uint64_t)&v11);
          v9 = (RB::DisplayList::Predicate *)*v5;
        }
        RB::DisplayList::Predicate::xml_elements(v9, a2);
      }
      else if (v7 == 2)
      {
        RB::XML::Document::push(a2, "color");
        v8 = *(_QWORD **)(*((_QWORD *)a2 + 1) + 8 * *((_QWORD *)a2 + 2) - 8);
        RB::XML::Value::Color::Color((RB::XML::Value::Color *)&v11, v5);
        RB::XML::Element::set<RB::XML::Value::Color>(v8, (uint64_t)"color", (uint64_t)&v11);
      }
      else
      {
        if (v7 != 1 || v5->i32[0])
          goto LABEL_16;
        RB::XML::Document::push(a2, "monochrome");
      }
      this = RB::XML::Document::pop((uint64_t)a2);
LABEL_16:
      v5 += 3;
    }
  }
  return this;
}

uint64_t RB::DisplayList::Layer::matches(RB::DisplayList::Layer *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  uint64_t result;
  _QWORD *v6;
  int v7;
  uint64_t v8;
  uint16x4_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unsigned __int16 v12;
  uint64_t v14;
  __int16 v15;

  if (*((_BYTE *)this + 64) == 2)
    return (*(uint64_t (**)(_QWORD, const RB::DisplayList::Predicate *))(**((_QWORD **)this + 3) + 72))(*((_QWORD *)this + 3), a2);
  if ((*((_BYTE *)this + 60) & 8) != 0)
  {
    v14 = 0x3C003C003C003C00;
    v15 = 0;
    return RB::DisplayList::Predicate::matches_color(a2, (const RB::Fill::Color *)&v14, a3);
  }
  else
  {
    v6 = (_QWORD *)*((_QWORD *)this + 2);
    if (v6)
    {
      while (1)
      {
        v7 = (*(uint64_t (**)(_QWORD *))(*v6 + 40))(v6);
        if (v7 == 2)
          return RB::DisplayList::Predicate::matches_color(a2, (const RB::Fill::Color *)(v8 + 32), v9);
        if (v7 == 1)
          return RB::DisplayList::Predicate::matches_non_color(a2);
        v6 = (_QWORD *)v6[1];
        if (!v6)
          goto LABEL_8;
      }
    }
    else
    {
LABEL_8:
      v10 = *(_QWORD **)this;
      if (v10)
      {
        while (1)
        {
          v11 = (_QWORD *)v10[2];
          if (v11)
            break;
LABEL_16:
          result = (*(uint64_t (**)(_QWORD *, const RB::DisplayList::Predicate *))(*v10 + 192))(v10, a2);
          if (!(_DWORD)result)
          {
            v10 = (_QWORD *)v10[1];
            if (v10)
              continue;
          }
          return result;
        }
        while (1)
        {
          v12 = (*(uint64_t (**)(_QWORD *, const RB::DisplayList::Predicate *))(*v11 + 64))(v11, a2);
          if (v12 >= 0x100u && v12 != 0)
            return 1;
          v11 = (_QWORD *)v11[4];
          if (!v11)
            goto LABEL_16;
        }
      }
      else
      {
        return 0;
      }
    }
  }
}

uint64_t RB::DisplayList::LayerItem::matches(RB::DisplayList::Layer **this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Layer::matches(this[6], a2, a3);
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::matches(RB::DisplayList::BackdropColorMatrixItem *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

uint64_t RB::DisplayList::CustomItem::matches(RB::DisplayList::CustomItem *this, const RB::DisplayList::Predicate *a2)
{
  return RB::DisplayList::Predicate::matches_non_color(a2);
}

_QWORD *RB::DisplayList::Predicate::encode(_QWORD *this, RB::Encoder *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v5;

  if (this[3])
    v2 = (_QWORD *)this[3];
  else
    v2 = this;
  v3 = *((unsigned int *)this + 8);
  if ((_DWORD)v3)
  {
    v5 = 24 * v3;
    do
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::DisplayList::Predicate::Term::encode(v2, a2);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
      v2 += 3;
      v5 -= 24;
    }
    while (v5);
  }
  return this;
}

uint64_t RB::DisplayList::Predicate::decode(RB::DisplayList::Predicate *this, RB::Decoder *a2)
{
  RB::DisplayList::Predicate *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t result;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  RB::DisplayList::Predicate *v11;
  RB::DisplayList::Predicate::Term *v12;

  v3 = this;
  if (*((_QWORD *)this + 3))
    this = (RB::DisplayList::Predicate *)*((_QWORD *)this + 3);
  v4 = *((unsigned int *)v3 + 8);
  if ((_DWORD)v4)
  {
    v5 = 24 * v4;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(this);
      this = (RB::DisplayList::Predicate *)(v6 + 24);
      v5 -= 24;
    }
    while (v5);
  }
  *((_DWORD *)v3 + 8) = 0;
  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v8 = result;
    do
    {
      if ((v8 & 0x7FFFFFFF8) == 8)
      {
        v9 = *((_DWORD *)v3 + 8);
        v10 = v9 + 1;
        if (*((_DWORD *)v3 + 9) < v9 + 1)
        {
          RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(v3, v10);
          v9 = *((_DWORD *)v3 + 8);
          v10 = v9 + 1;
        }
        v11 = (RB::DisplayList::Predicate *)*((_QWORD *)v3 + 3);
        if (!v11)
          v11 = v3;
        v12 = (RB::DisplayList::Predicate *)((char *)v11 + 24 * v9);
        *(_DWORD *)v12 = 0;
        *((_DWORD *)v3 + 8) = v10;
        if ((v8 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Predicate::Term::decode(v12, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v8);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v8 = result;
    }
    while (result);
  }
  return result;
}

_QWORD *RB::DisplayList::InvertiblePredicate::encode(RB::DisplayList::InvertiblePredicate *this, RB::Encoder *a2)
{
  _QWORD *result;

  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Predicate::encode(this, a2);
  result = RB::ProtobufEncoder::end_length_delimited(a2);
  if (*((_BYTE *)this + 40))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return result;
}

unint64_t RB::DisplayList::InvertiblePredicate::decode(RB::DisplayList::InvertiblePredicate *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        *((_BYTE *)this + 40) = RB::ProtobufDecoder::BOOL_field(a2, v5);
      }
      else if ((v5 >> 3) == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          RB::DisplayList::Predicate::decode(this, a2);
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

_QWORD *RB::DisplayList::Predicate::Term::encode(_QWORD *this, RB::Encoder *a2)
{
  int v3;
  unint64_t v4;
  RB::DisplayList::Predicate *v5;
  RB::Fill::Color *v6;

  v3 = *(_DWORD *)this;
  if (*(_DWORD *)this == 3)
  {
    v5 = (RB::DisplayList::Predicate *)this[1];
    if (!v5)
      return this;
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Predicate::encode(v5, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    if (*((_BYTE *)v5 + 40))
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
      RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  if (v3 == 2)
  {
    v6 = (RB::Fill::Color *)(this + 1);
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode(v6, a2);
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  if (v3 == 1)
  {
    v4 = *((unsigned int *)this + 2);
    if ((int)v4 >= 1)
    {
      RB::ProtobufEncoder::encode_varint(a2, 8uLL);
      return RB::ProtobufEncoder::encode_varint(a2, v4);
    }
  }
  return this;
}

unint64_t RB::DisplayList::Predicate::Term::decode(RB::DisplayList::Predicate::Term *this, RB::Decoder *a2)
{
  _DWORD *v4;
  unint64_t result;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  RB::DisplayList::InvertiblePredicate *v9;

  RB::DisplayList::Predicate::Term::~Term(this);
  *v4 = 0;
  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v6 = result;
    do
    {
      v7 = v6 >> 3;
      if ((v6 >> 3) == 3)
      {
        RB::DisplayList::Predicate::Term::~Term(this);
        *(_DWORD *)this = 3;
        v8 = operator new();
        *(_QWORD *)(v8 + 24) = 0;
        *(_QWORD *)(v8 + 32) = 0x100000000;
        *(_BYTE *)(v8 + 40) = 0;
        *((_QWORD *)this + 1) = v8;
        if ((v6 & 7) != 2)
          goto LABEL_15;
        v9 = (RB::DisplayList::InvertiblePredicate *)v8;
        RB::ProtobufDecoder::begin_message(a2);
        RB::DisplayList::InvertiblePredicate::decode(v9, a2);
      }
      else
      {
        if ((_DWORD)v7 != 2)
        {
          if ((_DWORD)v7 == 1)
          {
            RB::DisplayList::Predicate::Term::~Term(this);
            *(_DWORD *)this = 1;
            *((_DWORD *)this + 2) = RB::ProtobufDecoder::uint_field(a2, v6);
          }
          else
          {
            RB::ProtobufDecoder::skip_field(a2, v6);
          }
          goto LABEL_13;
        }
        RB::DisplayList::Predicate::Term::~Term(this);
        *(_DWORD *)this = 2;
        if ((v6 & 7) != 2)
        {
LABEL_15:
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          goto LABEL_13;
        }
        RB::ProtobufDecoder::begin_message(a2);
        RB::Fill::Color::decode((uint64_t)this + 8, a2);
      }
      RB::ProtobufDecoder::end_message((uint64_t)a2);
LABEL_13:
      result = RB::ProtobufDecoder::next_field(a2);
      v6 = result;
    }
    while (result);
  }
  return result;
}

RB::DisplayList::InvertiblePredicate *RB::DisplayList::InvertiblePredicate::InvertiblePredicate(RB::DisplayList::InvertiblePredicate *this, const RB::DisplayList::Predicate *a2, char a3)
{
  const RB::DisplayList::Predicate::Term *v5;
  unsigned int v6;
  unsigned int v7;
  RB::DisplayList::InvertiblePredicate *v8;
  unsigned int v9;
  RB::DisplayList::Predicate::Term *v10;
  RB::DisplayList::Predicate::Term *v11;
  int v12;

  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0x100000000;
  if (*((_QWORD *)a2 + 3))
    v5 = (const RB::DisplayList::Predicate::Term *)*((_QWORD *)a2 + 3);
  else
    v5 = a2;
  v6 = *((_DWORD *)a2 + 8);
  v7 = v6;
  if (v6 >= 2)
  {
    RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(this, v6);
    v8 = (RB::DisplayList::InvertiblePredicate *)*((_QWORD *)this + 3);
    v9 = *((_DWORD *)this + 8);
  }
  else
  {
    if (!v6)
    {
      v12 = 0;
      goto LABEL_13;
    }
    v8 = 0;
    v9 = 0;
  }
  if (!v8)
    v8 = this;
  v10 = (RB::DisplayList::InvertiblePredicate *)((char *)v8 + 24 * v9);
  do
  {
    v11 = RB::DisplayList::Predicate::Term::Term(v10, v5);
    v5 = (const RB::DisplayList::Predicate::Term *)((char *)v5 + 24);
    v10 = (RB::DisplayList::Predicate::Term *)((char *)v11 + 24);
    --v7;
  }
  while (v7);
  v12 = *((_DWORD *)this + 8);
LABEL_13:
  *((_DWORD *)this + 8) = v12 + v6;
  *((_BYTE *)this + 40) = a3;
  return this;
}

void sub_209B7AF5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  RB::DisplayList::Predicate::Term *v4;
  unint64_t v5;
  uint64_t v6;

  v3 = *(void **)(v1 + 24);
  if (v3)
    v4 = *(RB::DisplayList::Predicate::Term **)(v1 + 24);
  else
    v4 = (RB::DisplayList::Predicate::Term *)v1;
  if (*(_DWORD *)(v1 + 32))
  {
    v5 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v4);
      ++v5;
      v4 = (RB::DisplayList::Predicate::Term *)(v6 + 24);
    }
    while (v5 < *(unsigned int *)(v1 + 32));
    v3 = *(void **)(v1 + 24);
  }
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Predicate::Term *RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::~vector(RB::DisplayList::Predicate::Term *a1)
{
  RB::DisplayList::Predicate::Term *v1;
  void *v2;
  unint64_t v3;
  uint64_t v4;

  v1 = a1;
  v2 = (void *)*((_QWORD *)a1 + 3);
  if (v2)
    a1 = (RB::DisplayList::Predicate::Term *)*((_QWORD *)a1 + 3);
  if (*((_DWORD *)v1 + 8))
  {
    v3 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(a1);
      ++v3;
      a1 = (RB::DisplayList::Predicate::Term *)(v4 + 24);
    }
    while (v3 < *((unsigned int *)v1 + 8));
    v2 = (void *)*((_QWORD *)v1 + 3);
  }
  if (v2)
    free(v2);
  return v1;
}

void *RB::vector<RB::DisplayList::Predicate::Term,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 9) + (*((_DWORD *)__dst + 9) >> 1);
  result = RB::details::realloc_vector<unsigned int,24ul>(*((void **)__dst + 3), __dst, 1u, (_DWORD *)__dst + 9, v3);
  *((_QWORD *)__dst + 3) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,24ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 24 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(24 * a5);
    v9 = v8 / 0x18;
    if (*a4 != (v8 / 0x18))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 24 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

void RB::CGContext::set_alpha(RB::CGContext *this, float a2)
{
  if (*((float *)this + 33) != a2)
  {
    *((float *)this + 33) = a2;
    CGContextSetAlpha(*(CGContextRef *)this, a2);
  }
}

double RB::CGContext::set_stroke_color_slow(RB::CGContext *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  uint64_t v4;
  double result;
  CGFloat components;
  uint64x2_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)a2;
  *((_WORD *)this + 65) = *((_WORD *)a2 + 4);
  *(_QWORD *)((char *)this + 122) = v4;
  LODWORD(v4) = *((unsigned __int8 *)this + 8);
  components = *(CGFloat *)a2;
  v16.i16[0] = *((_WORD *)a2 + 4);
  RB::Fill::Color::convert((uint64_t)&components, v4, a3);
  _Q0 = (uint64x2_t)vdupq_n_s64(*(unint64_t *)&components);
  _H1 = LOWORD(components);
  _S2 = HIWORD(*(_QWORD *)&components);
  __asm { FCVT            D1, H1 }
  components = _D1;
  *(int32x2_t *)_Q0.i8 = vmovn_s64((int64x2_t)vshlq_u64(_Q0, (uint64x2_t)xmmword_209BD7920));
  _Q0.i32[0] = vuzp1_s16(*(int16x4_t *)_Q0.i8, *(int16x4_t *)_Q0.i8).u32[0];
  LOWORD(_D1) = _Q0.i16[1];
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  _Q0.i64[1] = _D1;
  v16 = _Q0;
  __asm { FCVT            D0, H2 }
  v17 = _Q0.i64[0];
  CGContextSetStrokeColor(*(CGContextRef *)this, &components);
  return result;
}

void RB::CGContext::set_aliasing_mode_slow(uint64_t a1, int a2)
{
  *(_BYTE *)(a1 + 140) = a2;
  CGContextSetShouldAntialias(*(CGContextRef *)a1, a2 == 0);
}

uint64_t RB::CGContext::reset_ctm(uint64_t this)
{
  uint64_t v1;

  if (*(_QWORD *)(this + 80))
  {
    v1 = this;
    this = CGContextSetCTM();
    *(_QWORD *)(v1 + 80) = 0;
  }
  return this;
}

void RB::CGContext::begin_layer(uint64_t a1, float a2, int32x2_t a3, int32x2_t a4)
{
  __int128 v8;
  uint64_t v9;
  __int128 v10;
  __int128 v11;
  unsigned int v12;
  uint64_t v13;
  _OWORD *v14;
  float64x2_t v15;
  uint32x2_t v22;
  CGContext *v23;
  float32x2_t v24;
  float32x2_t v25;
  CGFloat components[2];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _BYTE v31[32];
  uint64_t v32;
  CGRect v33;

  v32 = *MEMORY[0x24BDAC8D0];
  v8 = *(_OWORD *)(a1 + 48);
  v9 = a1 + 432;
  *(_OWORD *)components = *(_OWORD *)(a1 + 32);
  v27 = v8;
  v10 = *(_OWORD *)(a1 + 80);
  v28 = *(_OWORD *)(a1 + 64);
  v29 = v10;
  v11 = *(_OWORD *)(a1 + 112);
  v30 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)v31 = v11;
  *(_OWORD *)&v31[14] = *(_OWORD *)(a1 + 126);
  v12 = *(_DWORD *)(a1 + 888);
  if (*(_DWORD *)(a1 + 892) < v12 + 1)
  {
    RB::vector<RB::CGContext::LayerState,4ul,unsigned int>::reserve_slow((void *)(a1 + 432), v12 + 1);
    v12 = *(_DWORD *)(a1 + 888);
  }
  v13 = *(_QWORD *)(a1 + 880);
  if (!v13)
    v13 = v9;
  v14 = (_OWORD *)(v13 + 112 * v12);
  v14[3] = v29;
  v14[4] = v30;
  v14[5] = *(_OWORD *)v31;
  v14[6] = *(_OWORD *)&v31[16];
  *v14 = *(_OWORD *)components;
  v14[1] = v27;
  v14[2] = v28;
  ++*(_DWORD *)(a1 + 888);
  *(_QWORD *)(a1 + 88) = 0;
  *(_QWORD *)(a1 + 132) = 0x23F800000;
  *(_BYTE *)(a1 + 141) = 0;
  if (a2 != 1.0)
  {
    v15 = vmulq_n_f64(*(float64x2_t *)(a1 + 48), a2);
    *(float64x2_t *)(a1 + 32) = vmulq_n_f64(*(float64x2_t *)(a1 + 32), a2);
    *(float64x2_t *)(a1 + 48) = v15;
    CGContextSetCTM();
    *(_QWORD *)(a1 + 80) = 0;
  }
  _H0 = *(_WORD *)(a1 + 118);
  __asm { FCVT            S0, H0 }
  if (_S0 != 1.0)
  {
    *(_OWORD *)components = xmmword_209BD7980;
    v27 = unk_209BD7990;
    CGContextSetFillColor(*(CGContextRef *)a1, components);
  }
  v22 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  v23 = *(CGContext **)a1;
  if ((vpmin_u32(v22, v22).u32[0] & 0x80000000) != 0)
  {
    CGContextBeginTransparencyLayer(v23, 0);
  }
  else
  {
    v24 = vcvt_f32_s32(a3);
    v25 = vcvt_f32_s32(a4);
    v33.origin.x = v24.f32[0];
    v33.origin.y = v24.f32[1];
    v33.size.width = v25.f32[0];
    v33.size.height = v25.f32[1];
    CGContextBeginTransparencyLayerWithRect(v23, v33, 0);
  }
}

double RB::CGContext::end_layer(CGContextRef *this)
{
  _OWORD *v2;
  char *v3;
  unsigned int v4;
  char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  CGContextRef v16;
  __int16 v17;

  v2 = this + 10;
  if (*((_BYTE *)this + 141))
    CGContextRestoreGState(*this);
  CGContextEndTransparencyLayer(*this);
  v3 = (char *)(this + 54);
  if (this[110])
    v3 = (char *)this[110];
  v4 = *((_DWORD *)this + 222) - 1;
  v5 = &v3[112 * v4];
  v7 = *((_OWORD *)v5 + 1);
  v6 = *((_OWORD *)v5 + 2);
  *((_OWORD *)this + 2) = *(_OWORD *)v5;
  *((_OWORD *)this + 3) = v7;
  *((_OWORD *)this + 4) = v6;
  _Q0 = *((_OWORD *)v5 + 3);
  v8 = *((_OWORD *)v5 + 4);
  v9 = *((_OWORD *)v5 + 5);
  *(_OWORD *)((char *)v2 + 46) = *(_OWORD *)(v5 + 94);
  v2[1] = v8;
  v2[2] = v9;
  *v2 = _Q0;
  *((_DWORD *)this + 222) = v4;
  LOWORD(_Q0) = *((_WORD *)this + 59);
  __asm { FCVT            S0, H0 }
  if (*(float *)&_Q0 != 1.0)
  {
    v16 = this[14];
    v17 = *((_WORD *)this + 60);
    *(double *)&_Q0 = RB::CGContext::set_fill_color_slow((RB::CGContext *)this, (const RB::Fill::Color *)&v16, *(uint16x4_t *)&_Q0);
  }
  return *(double *)&_Q0;
}

uint64_t RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_0::__invoke()
{
  CGContextGetDelegate();
  CGContextGetRenderingState();
  CGContextGetGState();
  return CGSoftMaskDelegateDrawSoftMask();
}

const void **RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_1::__invoke(const void **result)
{
  const void *v1;

  if (result)
  {
    v1 = *result;
    if (v1)
      CFRelease(v1);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_2::__invoke(CGLayerRef *a1, CGContextRef context)
{
  CGContextDrawLayerAtPoint(context, *MEMORY[0x24BDBEFB0], *a1);
}

const void **RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_3::__invoke(const void **result)
{
  const void *v1;

  if (result)
  {
    v1 = *result;
    if (v1)
      CFRelease(v1);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::CGContext::add_alpha_mask(RB::CGContext *this, CGImage *a2, float32x2_t *a3)
{
  int Type;
  float32x2_t v7;
  float32x2_t v8;
  CGContext *v9;
  CGFloat v10;
  CGFloat v11;
  CGFloat v12;
  CGFloat v13;
  CGImage *v14;
  _QWORD v15[2];
  CGRect v16;

  Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  if ((Type - 1) > 1)
  {
    v9 = *(CGContext **)this;
    v10 = COERCE_FLOAT(*a3);
    v11 = COERCE_FLOAT(HIDWORD(*(unint64_t *)a3));
    v12 = COERCE_FLOAT(*(_QWORD *)&a3[1]);
    v13 = COERCE_FLOAT(HIDWORD(*(_QWORD *)&a3[1]));
    v14 = RB::cg_image_alpha_mask(a2, a2);
    v16.origin.x = v10;
    v16.origin.y = v11;
    v16.size.width = v12;
    v16.size.height = v13;
    CGContextClipToMask(v9, v16, v14);
  }
  else
  {
    v7 = *a3;
    v8 = a3[1];
    v15[0] = a2;
    v15[1] = a3;
    RB::CGContext::add_soft_mask((uint64_t)this, 0, (uint64_t)v15, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v7, v8);
  }
}

float32x2_t RB::CGContext::begin_bitmap@<D0>(int8x8_t *a1@<X0>, float32x2_t *a2@<X1>, char a3@<W2>, __int16 a4@<W3>, int8x8_t a5@<X4>, unsigned __int8 a6@<W5>, CGContext **a7@<X8>)
{
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  char v15;
  char *v16;
  int v17;
  uint64_t v18;
  char *v19;
  size_t v20;
  size_t v21;
  size_t v22;
  uint32_t v23;
  CGContext *v24;
  int32x2_t v25;
  CGContext *v26;
  uint32x2_t v27;
  int8x8_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t result;
  int32x2_t v34;
  float32x2_t v35;
  int32x2_t v36;
  int32x2_t v37;

  *a7 = 0;
  v12 = (float32x2_t)vbsl_s8((int8x8_t)vceqd_s64(a6, 0), a1[2], a5);
  v13 = vmul_f32(*a2, v12);
  v35 = v12;
  v14 = vmul_f32(a2[1], v12);
  *a2 = v13;
  a2[1] = v14;
  RB::Bounds::Bounds(&v36, v13, v14);
  if ((a3 & 1) != 0)
  {
    v21 = v37.i32[0];
    v20 = v37.i32[1];
    v22 = 8;
    v19 = 0;
    v23 = 7;
  }
  else
  {
    if ((a4 & 0xFF00) == 0)
      LOBYTE(a4) = a1[1].i8[0];
    v15 = (a3 & 2 | a4 & 1) == 0;
    v34 = v37;
    v16 = (char *)a4;
    if (a3 & 2 | a4 & 1)
      v17 = 8194;
    else
      v17 = 4353;
    if (v15)
      v18 = 16;
    else
      v18 = 8;
    v19 = RB::cg_color_space(v16, v15);
    v20 = v34.i32[1];
    v21 = v34.i32[0];
    v22 = v18;
    v23 = v17;
  }
  v24 = CGBitmapContextCreate(0, v21, v20, v22, 0, (CGColorSpaceRef)v19, v23);
  v26 = v24;
  *a7 = v24;
  if (v24)
  {
    CGContextTranslateCTM(v24, (double)-v36.i32[0], (double)-v36.i32[1]);
    CGContextScaleCTM(v26, v35.f32[0], v35.f32[1]);
  }
  v25.i32[0] = 0;
  v27 = (uint32x2_t)vceq_s32(v37, (int32x2_t)0x8000000080000000);
  v28 = (int8x8_t)vdup_lane_s32(vcgt_s32(v25, (int32x2_t)vpmin_u32(v27, v27)), 0);
  v29 = (float32x2_t)vbsl_s8(v28, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v37));
  v30 = vrecpe_f32(v35);
  v31 = vmul_f32(vrecps_f32(v35, v30), v30);
  v32 = vmul_f32(v31, vrecps_f32(v35, v31));
  result = vmul_f32(v32, (float32x2_t)vbsl_s8(v28, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v36)));
  *a2 = result;
  a2[1] = vmul_f32(v32, v29);
  return result;
}

void sub_209B7B8A8(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

size_t RB::CGContext::apply_scale(RB::_anonymous_namespace_ **a1, RB::_anonymous_namespace_ *a2, double a3)
{
  size_t BitsPerComponent;
  size_t result;
  uint8_t backColor[4];
  vImage_AffineTransform transform;
  vImage_Buffer dest;
  vImage_Buffer src;

  memset(&src, 0, sizeof(src));
  memset(&dest, 0, sizeof(dest));
  BitsPerComponent = CGBitmapContextGetBitsPerComponent(*a1);
  result = CGBitmapContextGetBitsPerPixel(*a1);
  transform.a = *(float *)&a3;
  *(_QWORD *)&transform.b = 0;
  transform.d = *((float *)&a3 + 1);
  *(_QWORD *)&transform.tx = 0;
  if (BitsPerComponent == 8 && result == 32)
  {
    *(_DWORD *)backColor = 0;
    return vImageAffineWarp_ARGB8888(&src, &dest, 0, &transform, backColor, 8u);
  }
  else if (BitsPerComponent == 8 && result == 8)
  {
    return vImageAffineWarp_Planar8(&src, &dest, 0, &transform, 0, 8u);
  }
  return result;
}

size_t RB::`anonymous namespace'::vimage_buffer@<X0>(RB::_anonymous_namespace_ *this@<X0>, void **a2@<X8>)
{
  size_t result;

  *a2 = CGBitmapContextGetData(this);
  a2[1] = (void *)CGBitmapContextGetHeight(this);
  a2[2] = (void *)CGBitmapContextGetWidth(this);
  result = CGBitmapContextGetBytesPerRow(this);
  a2[3] = (void *)result;
  return result;
}

void RB::CGContext::apply_blur(uint64_t a1, char a2, CFTypeRef *a3, float a4)
{
  size_t BitsPerComponent;
  size_t BitsPerPixel;
  RB::_anonymous_namespace_ *v10;
  CGBitmapInfo BitmapInfo;
  char *v12;
  int v13;
  int v14;
  uint32_t v15;
  uint32_t v16;
  uint32_t v17;
  uint64_t v18;
  int8x16_t v19;
  int8x16_t v20;
  vImage_Buffer dest;
  vImage_Buffer src;
  Pixel_8 table[256];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  memset(&src, 0, sizeof(src));
  BitsPerComponent = CGBitmapContextGetBitsPerComponent(*(CGContextRef *)a1);
  BitsPerPixel = CGBitmapContextGetBitsPerPixel(*(CGContextRef *)a1);
  dest = src;
  if (a4 <= 0.0)
    goto LABEL_10;
  v10 = (RB::_anonymous_namespace_ *)*a3;
  if (*a3)
    goto LABEL_9;
  BitmapInfo = CGBitmapContextGetBitmapInfo(*(CGContextRef *)a1);
  if (BitmapInfo == 7)
    v12 = 0;
  else
    v12 = RB::cg_color_space((char *)*(unsigned __int8 *)(a1 + 8), BitsPerComponent > 8);
  v10 = CGBitmapContextCreate(0, src.width, src.height, BitsPerComponent, 0, (CGColorSpaceRef)v12, BitmapInfo);
  if (*a3)
    CFRelease(*a3);
  *a3 = v10;
  if (v10)
  {
LABEL_9:
LABEL_10:
    v13 = vcvtms_s32_f32((float)(a4 * 1.88) + 0.5);
    if (v13 <= 1)
      v14 = 1;
    else
      v14 = v13;
    v15 = v14 - 1;
    if ((v13 & 1) != 0)
      v16 = v13;
    else
      v16 = v15;
    v17 = v13 | 1;
    if (BitsPerComponent == 8 && BitsPerPixel == 32)
    {
      if (a4 > 0.0)
      {
        vImageTentConvolve_ARGB8888(&src, &dest, 0, 0, 0, v17, v13 | 1, 0, 8u);
        vImageBoxConvolve_ARGB8888(&dest, &src, 0, 0, 0, v16, v16, 0, 8u);
      }
      if ((a2 & 1) != 0)
      {
        vImageUnpremultiplyData_RGBA8888(&src, &src, 0);
        vImageOverwriteChannelsWithScalar_ARGB8888(0xFFu, &src, &src, 1u, 0);
      }
    }
    else if (BitsPerComponent == 8 && BitsPerPixel == 8)
    {
      if (a4 > 0.0)
      {
        vImageTentConvolve_Planar8(&src, &dest, 0, 0, 0, v17, v13 | 1, 0, 8u);
        vImageBoxConvolve_Planar8(&dest, &src, 0, 0, 0, v16, v16, 0, 8u);
      }
      if ((a2 & 2) != 0)
      {
        v18 = 0;
        v19 = (int8x16_t)xmmword_209BD7930;
        v20.i64[0] = 0x1010101010101010;
        v20.i64[1] = 0x1010101010101010;
        do
        {
          *(int8x16_t *)&table[v18] = vmvnq_s8(v19);
          v18 += 16;
          v19 = vaddq_s8(v19, v20);
        }
        while (v18 != 256);
        vImageTableLookUp_Planar8(&src, &src, table, 0);
      }
    }
  }
}

uint64_t RB::CGContext::apply_color_matrix(RB::_anonymous_namespace_ **this, float16x4_t *a2, int a3)
{
  uint64_t result;
  size_t BitsPerComponent;
  __n64 v8;
  int8x16_t *v9;
  int8x8_t v10;
  unsigned int v11;
  float32x4_t v12;
  int8x8_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float16x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x8_t v31;
  int8x8_t v32;
  float32x4_t v33;
  unsigned __int16 v34;
  unsigned __int16 v35;
  int32x4_t v36;
  int32x4_t v37;
  int8x16_t v38;
  int8x16_t *v39;
  vImage_Buffer v40;
  int8x16_t v41;
  int16_t matrix[4];
  int8x8_t v43;
  int8x8_t v44;
  int8x8_t v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  result = RB::ColorMatrix::is_identity(a2);
  if ((result & 1) == 0)
  {
    memset(&v40, 0, sizeof(v40));
    BitsPerComponent = CGBitmapContextGetBitsPerComponent(*this);
    result = CGBitmapContextGetBitsPerPixel(*this);
    if (BitsPerComponent == 8 && result == 32)
    {
      if (RB::ColorMatrix::is_alpha_multiply(a2, a3))
      {
        *(_QWORD *)matrix = 0;
        v43 = 0;
        v44 = 0;
        v8.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color((RB::ColorMatrix *)a2, a3).n64_u64[0];
        v9 = 0;
        v10 = (int8x8_t)vdup_lane_s16((int16x4_t)v8.n64_u64[0], 3);
        v10.i16[3] = unk_209BD7958;
        if (a3)
          v11 = -1;
        else
          v11 = 0;
        v12.i64[0] = 0x3F0000003F000000;
        v12.i64[1] = 0x3F0000003F000000;
        v13 = (int8x8_t)vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v12, (float32x4_t)vdupq_n_s32(0x43800000u), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)v8.n64_u64[0]), vcvtq_f32_f16((float16x4_t)vbsl_s8((int8x8_t)vdup_n_s16(v11), (int8x8_t)0x3C003C003C003C00, v10)))))))));
        v45 = vext_s8(v13, v13, 6uLL);
        goto LABEL_18;
      }
      if ((a3 & 1) == 0 && RB::ColorMatrix::is_alpha_identity((RB::ColorMatrix *)a2))
      {
        v9 = 0;
        v14 = (float32x4_t)vdupq_n_s32(0x43800000u);
        v15.i64[0] = 0x3F0000003F000000;
        v15.i64[1] = 0x3F0000003F000000;
        v16 = *a2;
        v17.i64[0] = 0x3F0000003F000000;
        v17.i64[1] = 0x3F0000003F000000;
        v18.i64[0] = 0x3F0000003F000000;
        v18.i64[1] = 0x3F0000003F000000;
        *(int16x4_t *)v15.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v15, v14, vcvtq_f32_f16(a2[2])))));
        *(int16x4_t *)v17.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v17, v14, vcvtq_f32_f16(a2[1])))));
        *(int8x8_t *)matrix = vext_s8(*(int8x8_t *)v15.f32, *(int8x8_t *)v15.f32, 6uLL);
        v43 = vext_s8(*(int8x8_t *)v17.f32, *(int8x8_t *)v17.f32, 6uLL);
        v19 = vcvtq_f32_f16(v16);
        v20.i64[0] = 0x3F0000003F000000;
        v20.i64[1] = 0x3F0000003F000000;
        *(int16x4_t *)v19.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v20, v14, v19))));
        *(float16x4_t *)v20.f32 = a2[4];
        v20.i16[3] = unk_209BD7958;
        *(int16x4_t *)v14.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(vmlaq_f32(v18, v14, vcvtq_f32_f16(*(float16x4_t *)v20.f32)))));
        v44 = vext_s8(*(int8x8_t *)v19.f32, *(int8x8_t *)v19.f32, 6uLL);
        v45 = vext_s8(*(int8x8_t *)v14.f32, *(int8x8_t *)v14.f32, 6uLL);
LABEL_18:
        vImageMatrixMultiply_ARGB8888(&v40, &v40, matrix, 256, 0, v9->i32, 0);
        return vImageClipToAlpha_RGBA8888(&v40, &v40, 0);
      }
      v21 = (float32x4_t)vdupq_n_s32(0x43800000u);
      v22.i64[0] = 0x3F0000003F000000;
      v22.i64[1] = 0x3F0000003F000000;
      v23 = vmlaq_f32(v22, v21, vcvtq_f32_f16(a2[2]));
      v24.i64[0] = 0x3F0000003F000000;
      v24.i64[1] = 0x3F0000003F000000;
      v25 = vmlaq_f32(v24, v21, vcvtq_f32_f16(a2[1]));
      v26.i64[0] = 0x3F0000003F000000;
      v26.i64[1] = 0x3F0000003F000000;
      v27 = vmlaq_f32(v26, v21, vcvtq_f32_f16(*a2));
      v28.i64[0] = 0x3F0000003F000000;
      v28.i64[1] = 0x3F0000003F000000;
      v29 = vmlaq_f32(v28, v21, vcvtq_f32_f16(a2[3]));
      v30.i64[0] = 0x3F0000003F000000;
      v30.i64[1] = 0x3F0000003F000000;
      v31 = (int8x8_t)vrev32_s16(vmovn_s32(vcvtq_s32_f32(v23)));
      *(int16x4_t *)v23.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v25)));
      *(int8x8_t *)matrix = vext_s8(v31, v31, 6uLL);
      v43 = vext_s8(*(int8x8_t *)v23.f32, *(int8x8_t *)v23.f32, 6uLL);
      v32 = (int8x8_t)vrev32_s16(vmovn_s32(vcvtq_s32_f32(v27)));
      *(int16x4_t *)v29.f32 = vrev32_s16(vmovn_s32(vcvtq_s32_f32(v29)));
      v44 = vext_s8(v32, v32, 6uLL);
      v45 = vext_s8(*(int8x8_t *)v29.f32, *(int8x8_t *)v29.f32, 6uLL);
      v33 = vcvtq_f32_f16(a2[4]);
      v34 = vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(v33))));
      v35 = v34;
      if ((v34 & 0x8000) != 0)
      {
        v36 = vcvtq_s32_f32(vmlaq_f32(v30, (float32x4_t)vdupq_n_s32(0x47800000u), v33));
        v37.i64[0] = 0x8000000080;
        v37.i64[1] = 0x8000000080;
        v38 = (int8x16_t)vrev64q_s32(vaddq_s32(v36, v37));
        v41 = vextq_s8(v38, v38, 0xCuLL);
      }
      if ((a3 & 1) != 0)
      {
        if ((v34 & 0x8000) != 0)
          v9 = &v41;
        else
          v9 = 0;
        goto LABEL_18;
      }
      vImageUnpremultiplyData_RGBA8888(&v40, &v40, 0);
      if ((v35 & 0x8000) != 0)
        v39 = &v41;
      else
        v39 = 0;
      vImageMatrixMultiply_ARGB8888(&v40, &v40, matrix, 256, 0, v39->i32, 0);
      return vImagePremultiplyData_RGBA8888(&v40, &v40, 0);
    }
  }
  return result;
}

void RB::CGContext::apply_luminance_curve(uint64_t a1, float16x4_t *a2, int32x4_t a3)
{
  size_t BitsPerComponent;
  int32x2_t v6;
  int32x2_t v7;
  unint64_t v9;
  int32x2_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  int16x8_t v19;
  int v21;
  uint16x4_t v22;
  int32x4_t v24;
  uint64_t v25;
  uint64_t v26;
  float32x4_t v29;
  int32x4_t v30;
  __int128 v34;
  unsigned int *v35;
  int32x4_t v36;
  unsigned int *v37;
  uint64_t i;
  int32x2_t v39;
  uint32x2_t v40;
  __int128 v42;
  __int128 v43;
  float16x4_t v44;
  __int16 v45;
  _BYTE v46[256];
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  if (CGBitmapContextGetBitmapInfo(*(CGContextRef *)a1) != 7)
  {
    BitsPerComponent = CGBitmapContextGetBitsPerComponent(*(CGContextRef *)a1);
    if (CGBitmapContextGetBitsPerPixel(*(CGContextRef *)a1) == 32 && BitsPerComponent == 8)
    {
      v9 = 0;
      v10 = (int32x2_t)vsubq_f32((float32x4_t)vdupq_laneq_s32(a3, 3), (float32x4_t)a3).u64[0];
      *(float *)v7.i32 = *(float *)v10.i32 + (float)((float)(*(float *)&a3.i32[1] - *(float *)&a3.i32[2]) * 3.0);
      *(float *)v6.i32 = (float)((float)(*(float *)&a3.i32[2] + *(float *)a3.i32)
                               - (float)(*(float *)&a3.i32[1] + *(float *)&a3.i32[1]))
                       * 3.0;
      *(float *)v10.i32 = (float)(*(float *)&a3.i32[1] - *(float *)a3.i32) * 3.0;
      v11 = (float32x4_t)vdupq_lane_s32(v7, 0);
      v12 = (float32x4_t)vdupq_lane_s32(v6, 0);
      v13 = (float32x4_t)vdupq_lane_s32(v10, 0);
      v14 = (float32x4_t)xmmword_209BD7940;
      v15 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)a3.i8, 0);
      v16 = (float32x4_t)vdupq_n_s32(0x437F0000u);
      v17 = (float32x4_t)vdupq_n_s32(0x3C808081u);
      do
      {
        v18.i64[0] = 0x3F0000003F000000;
        v18.i64[1] = 0x3F0000003F000000;
        v19 = (int16x8_t)vcvtq_u32_f32(vmlaq_f32(v18, v16, vmlaq_f32(v15, v14, vmlaq_f32(v13, v14, vmlaq_f32(v12, v11, v14)))));
        *(int16x4_t *)v19.i8 = vmovn_s32((int32x4_t)v19);
        *(_DWORD *)&v46[v9] = vmovn_s16(v19).u32[0];
        v14 = vaddq_f32(v14, v17);
        _CF = v9 >= 0xFC;
        v9 += 4;
      }
      while (!_CF);
      v42 = 0u;
      v43 = 0u;
      v21 = *(unsigned __int8 *)(a1 + 8);
      v44 = *a2;
      v45 = a2[1].i16[0];
      RB::Fill::Color::convert((uint64_t)&v44, v21, v22);
      v25 = *((_QWORD *)&v42 + 1);
      if (*((_QWORD *)&v42 + 1))
      {
        v26 = 0;
        _D1.i16[0] = v44.i16[3];
        __asm { FCVT            S1, H1 }
        *(float *)_D1.i32 = *(float *)_D1.i32 * 255.0;
        __asm { FCVT            H1, S1 }
        v29.i64[0] = 0x3F0000003F000000;
        v29.i64[1] = 0x3F0000003F000000;
        v30 = (int32x4_t)vcvtq_u32_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D1, 0)), vcvtq_f32_f16(v44)))), v29))));
        __asm { FCVT            S1, H1 }
        _S1 = 255.0 - _S1;
        __asm
        {
          FCVT            H1, S1
          FCVT            S1, H1
        }
        v34 = v43;
        v35 = (unsigned int *)v42;
        v36 = vdupq_n_s32((float)(_S1 + 0.5));
        do
        {
          v37 = v35;
          for (i = v34; i; --i)
          {
            *(int8x8_t *)v24.i8 = vand_s8((int8x8_t)vshl_u32((uint32x2_t)vdup_n_s32(*v37), (uint32x2_t)0xFFFFFFF8FFFFFFF0), (int8x8_t)0xFF000000FFLL);
            v39 = vmul_s32(*(int32x2_t *)v24.i8, (int32x2_t)0xB72500003666);
            v24.i32[2] = *v37;
            v24 = (int32x4_t)vshrq_n_u32((uint32x4_t)vmlaq_s32(vnegq_s32((int32x4_t)vmvnq_s8((int8x16_t)vmulq_s32(vdupq_n_s32(v46[(unint64_t)(v39.i32[1] + 4725 * v24.i32[2] + v39.i32[0]) >> 16]), v30))), v24, v36), 8uLL);
            v40 = vshl_u32(*(uint32x2_t *)v24.i8, (uint32x2_t)0x800000010);
            *v37 = v24.i32[2] | *v37 & 0xFF000000 | v40.i32[0] | v40.i32[1];
            ++v37;
          }
          ++v26;
          v35 = (unsigned int *)((char *)v35 + *((_QWORD *)&v34 + 1));
        }
        while (v26 != v25);
      }
    }
  }
}

size_t RB::CGContext::apply_alpha_lut(CGContextRef *this, int16x8_t *a2)
{
  size_t BitsPerComponent;
  size_t BitsPerPixel;
  size_t result;
  uint64_t j;
  uint32x4_t v10;
  uint32x4_t v11;
  uint32x4_t v12;
  uint32x4_t v13;
  uint64_t i;
  int16x8_t v15;
  int16x8_t v16;
  int16x8_t v17;
  int16x8_t v18;
  int8x16_t *v19;
  int8x16_t v20;
  int8x16_t v21;
  vImage_Buffer v22;
  Pixel_8 table[256];
  Pixel_8 v24[256];
  Pixel_8 v25[256];
  Pixel_8 v26[256];
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  BitsPerComponent = CGBitmapContextGetBitsPerComponent(*this);
  BitsPerPixel = CGBitmapContextGetBitsPerPixel(*this);
  memset(&v22, 0, sizeof(v22));
  if (BitsPerPixel == 32 && BitsPerComponent == 8)
  {
    vImagePermuteChannels_ARGB8888(&v22, &v22, RB::CGContext::apply_alpha_lut(unsigned int const*)::permute, 0);
    for (i = 0; i != 256; i += 16)
    {
      v16 = *a2;
      v15 = a2[1];
      v18 = a2[2];
      v17 = a2[3];
      v19 = (int8x16_t *)&table[i];
      *(uint16x4_t *)v20.i8 = vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v18), 8uLL);
      v20.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v17), 8uLL);
      *(uint16x4_t *)v21.i8 = vshr_n_u16((uint16x4_t)vmovn_s32(*(int32x4_t *)a2), 8uLL);
      v21.u64[1] = (unint64_t)vshr_n_u16((uint16x4_t)vmovn_s32((int32x4_t)v15), 8uLL);
      *v19 = vuzp1q_s8((int8x16_t)vuzp1q_s16(*a2, v15), (int8x16_t)vuzp1q_s16(v18, v17));
      v19[16] = vuzp1q_s8(v21, v20);
      v19[32] = vuzp1q_s8((int8x16_t)vuzp2q_s16(v16, v15), (int8x16_t)vuzp2q_s16(v18, v17));
      v19[48] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32((uint32x4_t)v16, 0x18uLL), (int16x8_t)vshrq_n_u32((uint32x4_t)v15, 0x18uLL)), (int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32((uint32x4_t)v18, 0x18uLL), (int16x8_t)vshrq_n_u32((uint32x4_t)v17, 0x18uLL)));
      a2 += 4;
    }
    return vImageTableLookUp_ARGB8888(&v22, &v22, table, v24, v25, v26, 0);
  }
  else if (BitsPerPixel == 8 && BitsPerComponent == 8)
  {
    for (j = 0; j != 256; j += 16)
    {
      v10 = (uint32x4_t)a2[2];
      v11 = (uint32x4_t)a2[3];
      v12 = *(uint32x4_t *)a2;
      v13 = (uint32x4_t)a2[1];
      a2 += 4;
      *(int8x16_t *)&table[j] = vuzp1q_s8((int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32(v12, 0x18uLL), (int16x8_t)vshrq_n_u32(v13, 0x18uLL)), (int8x16_t)vuzp1q_s16((int16x8_t)vshrq_n_u32(v10, 0x18uLL), (int16x8_t)vshrq_n_u32(v11, 0x18uLL)));
    }
    return vImageTableLookUp_Planar8(&v22, &v22, table, 0);
  }
  return result;
}

RB::CGContext::Raster *RB::CGContext::Raster::Raster(RB::CGContext::Raster *this, RB::_anonymous_namespace_ **a2)
{
  int v4;
  int v5;
  float64x2_t *v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  __int128 v11;
  __int128 v12;

  *(_OWORD *)this = xmmword_209BD5290;
  *((_OWORD *)this + 1) = xmmword_209BD52A0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  v11 = 0u;
  v12 = 0u;
  v4 = DWORD2(v11);
  *((_QWORD *)this + 6) = v11;
  v5 = DWORD2(v12);
  *((_DWORD *)this + 14) = v12;
  *((_DWORD *)this + 15) = v4;
  *((_DWORD *)this + 16) = v5;
  *((_BYTE *)this + 69) = CGBitmapContextGetBitsPerComponent(*a2);
  *((_BYTE *)this + 68) = CGBitmapContextGetBitsPerPixel(*a2);
  *((_BYTE *)this + 70) = *((_BYTE *)a2 + 8);
  v6 = (float64x2_t *)a2[10];
  if (!v6)
    v6 = (float64x2_t *)(a2 + 4);
  v7.f64[0] = 0.0;
  v7.f64[1] = (double)*((int *)this + 15);
  v8 = vmulq_f64(v6[1], (float64x2_t)xmmword_209BD52B0);
  v9 = vmlaq_f64(v7, (float64x2_t)xmmword_209BD52B0, v6[2]);
  *(float64x2_t *)this = vmulq_f64(*v6, (float64x2_t)xmmword_209BD52B0);
  *((float64x2_t *)this + 1) = v8;
  *((float64x2_t *)this + 2) = v9;
  return this;
}

float32x2_t RB::CGContext::Raster::fill_triangle(uint64_t a1, float16x4_t *a2, float16x4_t *a3, float16x4_t *a4, float32x2_t result, float32x2_t a6, float32x2_t a7)
{
  int v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float32x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float32x2_t v15;
  int16x4_t v16;
  int32x2_t v17;
  int32x2_t v18;
  uint32x2_t v19;
  int16x4_t v20;
  int v21;
  float16x4_t v22;
  float16x4_t v23;
  float16x4_t v24;
  __int32 v25;
  __int32 v26;
  float32x4_t v27;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int v36;
  uint64_t v37;
  int32x2_t v38;
  float32x2_t v39;
  int32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int32x2_t v43;
  int32x2_t v44;
  int32x2_t v45;
  int32x2_t v46;
  float32x2_t v47;
  int32x2_t v48;
  int32x2_t v49;
  float v50;
  uint64_t v51;
  uint64_t v52;
  float32x2_t v53;
  float32x2_t v54;
  uint64_t v55;
  float v56;
  float32x2_t v57;
  float32x4_t v58;
  uint32x4_t v59;
  int v60;
  int16x4_t v61;
  int16x4_t v62;
  int16x4_t v63;
  float16x4_t *v64;
  float16x4_t v65;
  float16x4_t v66;
  float16x4_t *v67;
  float16x4_t *v68;
  float16x4_t v69;
  int32x2_t v70;
  int32x2_t v71;
  int32x2_t v72;
  int32x2_t v73;
  int32x2_t v74;
  int32x2_t v75;
  float32x2_t v76;
  float32x2_t v77;
  float32x2_t v78;
  float32x2_t v79;
  float32x2_t v80;
  float32x2_t v81;
  float32x2_t v82;
  float32x2_t v83;
  float32x2_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  float16x4_t v88;
  __int16 v89;

  if (*(_QWORD *)(a1 + 48))
  {
    v8 = *(unsigned __int8 *)(a1 + 68);
    if ((v8 == 8 || v8 == 32) && *(_BYTE *)(a1 + 69) == 8)
    {
      v9 = vcvtq_f64_f32(result);
      v10 = *(float64x2_t *)(a1 + 16);
      result = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v9.f64[0]), v10, v9, 1));
      v11 = vcvtq_f64_f32(a6);
      v12 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v11.f64[0]), v10, v11, 1));
      v13 = vcvtq_f64_f32(a7);
      v14 = vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 32), *(float64x2_t *)a1, v13.f64[0]), v10, v13, 1);
      v15 = vcvt_f32_f64(v14);
      v16 = (int16x4_t)vcvt_s32_f32(vrndp_f32(vmaxnm_f32(vmaxnm_f32(result, v12), v15)));
      v17 = vmax_s32(vcvt_s32_f32(vrndm_f32(vminnm_f32(vminnm_f32(result, v12), v15))), 0);
      v18 = vmin_s32((int32x2_t)v16, *(int32x2_t *)(a1 + 56));
      v19 = (uint32x2_t)vcgt_s32(v18, v17);
      v20 = (int16x4_t)vpmin_u32(v19, v19);
      if (v20.i32[0] < 0)
      {
        v21 = *(unsigned __int8 *)(a1 + 70);
        if (a2[1].i8[1] && a2[1].u8[0] != v21)
        {
          v85 = a1;
          v88 = *a2;
          v89 = a2[1].i16[0];
          v67 = a4;
          v64 = a3;
          v79 = v15;
          v82 = result;
          v76 = v12;
          v73 = v18;
          v70 = v17;
          RB::Fill::Color::convert((uint64_t)&v88, v21, (uint16x4_t)result);
          v17 = v70;
          v18 = v73;
          v12 = v76;
          v15 = v79;
          result = v82;
          a3 = v64;
          a4 = v67;
          a1 = v85;
          v16.i32[0] = *(_QWORD *)&v88 >> 16;
          v22.i16[3] = 15360;
          v22.i32[0] = v88.i32[0];
          v22.i16[2] = v88.i16[2];
          v20.i32[0] = HIWORD(*(_QWORD *)&v88);
          v21 = *(unsigned __int8 *)(v85 + 70);
        }
        else
        {
          v22 = *a2;
          v22.i16[2] = a2->i16[2];
          v22.i16[3] = unk_209BD795A;
          v20.i16[0] = a2->i16[3];
        }
        if (a3[1].i8[1] && a3[1].u8[0] != v21)
        {
          v86 = a1;
          v88 = *a3;
          v89 = a3[1].i16[0];
          v68 = a4;
          v80 = v15;
          v83 = result;
          v77 = v12;
          v74 = v18;
          v71 = v17;
          v62 = v20;
          v65 = v22;
          RB::Fill::Color::convert((uint64_t)&v88, v21, (uint16x4_t)result);
          v17 = v71;
          v18 = v74;
          v12 = v77;
          v15 = v80;
          result = v83;
          a4 = v68;
          a1 = v86;
          v23.i16[3] = 15360;
          v23.i32[0] = v88.i32[0];
          v20 = v62;
          v22 = v65;
          v23.i16[2] = v88.i16[2];
          v16.i32[0] = HIWORD(*(_QWORD *)&v88);
          v21 = *(unsigned __int8 *)(v86 + 70);
        }
        else
        {
          v23 = *a3;
          v23.i16[2] = a3->i16[2];
          v23.i16[3] = unk_209BD795A;
          v16.i16[0] = a3->i16[3];
        }
        if (a4[1].i8[1] && a4[1].u8[0] != v21)
        {
          v87 = a1;
          v88 = *a4;
          v89 = a4[1].i16[0];
          v81 = v15;
          v84 = result;
          v78 = v12;
          v75 = v18;
          v69 = v23;
          v72 = v17;
          v63 = v20;
          v66 = v22;
          v61 = v16;
          RB::Fill::Color::convert((uint64_t)&v88, v21, (uint16x4_t)result);
          v22 = v66;
          v23 = v69;
          v17 = v72;
          v18 = v75;
          v12 = v78;
          v15 = v81;
          result = v84;
          a1 = v87;
          v24.i16[3] = 15360;
          v24.i32[0] = v88.i32[0];
          v24.i16[2] = v88.i16[2];
          v16 = v61;
          v20 = v63;
          LODWORD(v14.f64[0]) = HIWORD(*(_QWORD *)&v88);
        }
        else
        {
          v24 = *a4;
          v24.i16[2] = a4->i16[2];
          v24.i16[3] = unk_209BD795A;
          LOWORD(v14.f64[0]) = a4->i16[3];
        }
        v25 = v17.i32[1];
        v26 = v18.i32[1];
        if (v17.i32[1] < v18.i32[1])
        {
          v27 = vmaxnmq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v20, 0)), vcvtq_f32_f16(v22)))), (float32x4_t)0);
          __asm { FMOV            V7.4S, #1.0 }
          v33 = vminnmq_f32(v27, _Q7);
          v34 = vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v16, 0)), vcvtq_f32_f16(v23)))), (float32x4_t)0), _Q7);
          v35 = vminnmq_f32(vmaxnmq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)&v14.f64[0], 0)), vcvtq_f32_f16(v24)))), (float32x4_t)0), _Q7);
          v36 = *(_DWORD *)(a1 + 64);
          v37 = *(_QWORD *)(a1 + 48) + v36 * v17.i32[1];
          v38 = (int32x2_t)vsub_f32(v12, result);
          _Q7.f32[0] = -*(float *)&v38.i32[1];
          v39 = vsub_f32(v15, v12);
          v40 = (int32x2_t)vmul_f32((float32x2_t)vzip1_s32(*(int32x2_t *)_Q7.f32, v38), v39);
          v40.i32[0] = vadd_f32((float32x2_t)v40, (float32x2_t)vdup_lane_s32(v40, 1)).u32[0];
          *(float32x2_t *)_Q7.f32 = vrecpe_f32((float32x2_t)v40.u32[0]);
          *(float32x2_t *)_Q7.f32 = vmul_f32(vrecps_f32((float32x2_t)v40.u32[0], *(float32x2_t *)_Q7.f32), *(float32x2_t *)_Q7.f32);
          _Q7.i32[0] = vmul_f32(*(float32x2_t *)_Q7.f32, vrecps_f32((float32x2_t)v40.u32[0], *(float32x2_t *)_Q7.f32)).u32[0];
          v41 = vmul_n_f32((float32x2_t)v38, _Q7.f32[0]);
          v42 = vsub_f32(result, v15);
          v43 = (int32x2_t)vmul_n_f32(v42, _Q7.f32[0]);
          v44 = (int32x2_t)vmul_n_f32(v39, _Q7.f32[0]);
          v45 = (int32x2_t)vcvt_f32_s32(v17);
          v46 = (int32x2_t)vsub_f32(vadd_f32(v15, (float32x2_t)0xBF000000BF000000), (float32x2_t)v45);
          *(float *)v45.i32 = -*(float *)&v46.i32[1];
          v47 = (float32x2_t)vzip1_s32(v45, v46);
          v48 = (int32x2_t)vmul_f32(v47, v42);
          v49 = (int32x2_t)vmul_f32(v47, v39);
          result = vmul_n_f32(vadd_f32((float32x2_t)vzip1_s32(v48, v49), (float32x2_t)vzip2_s32(v48, v49)), _Q7.f32[0]);
          v50 = 1.0 - vaddv_f32(result);
          v51 = v17.u32[0];
          v52 = v18.i32[0];
          v53 = (float32x2_t)vzip1_s32(v43, v44);
          v54 = (float32x2_t)vzip2_s32(v43, v44);
          do
          {
            v55 = v51;
            v56 = v50;
            v57 = result;
            if ((int)v51 < (int)v52)
            {
              do
              {
                if (v57.f32[1] >= -0.00001 && v57.f32[0] >= -0.00001 && v56 >= -0.00001)
                {
                  v58.i64[0] = 0x3F0000003F000000;
                  v58.i64[1] = 0x3F0000003F000000;
                  v59 = vcvtq_u32_f32(vmlaq_n_f32(vmlaq_n_f32(vmlaq_n_f32(v58, v33, v57.f32[1] * 255.0), v34, v57.f32[0] * 255.0), v35, v56 * 255.0));
                  v60 = v59.i32[2] | (v59.i32[0] << 16) | (v59.i32[3] << 24) | (v59.i32[1] << 8);
                  if (*(_BYTE *)(a1 + 68) == 32)
                    *(_DWORD *)(v37 + 4 * v55) = v60;
                  else
                    *(_BYTE *)(v37 + v55) = HIBYTE(v60);
                }
                v57 = vsub_f32(v57, v54);
                v56 = v56 - v41.f32[1];
                ++v55;
              }
              while (v52 != v55);
              v36 = *(_DWORD *)(a1 + 64);
            }
            result = vadd_f32(result, v53);
            v50 = v50 + v41.f32[0];
            v37 += v36;
            ++v25;
          }
          while (v25 != v26);
        }
      }
    }
  }
  return result;
}

void RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _BYTE *v4;
  int v11;
  __int16 v12;
  __int16 v13;
  __int16 v14;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    do
    {
      v4 = (_BYTE *)(v2[1] & 0xFFFFFFFFFFFFFFFELL);
      if (v4[44] != 1 && (v4[45] & 1) == 0)
      {
        _S0 = (*(float (**)(unint64_t))(*(_QWORD *)v4 + 104))(v2[1] & 0xFFFFFFFFFFFFFFFELL);
        if (_S0 != 1.0)
        {
          __asm { FCVT            H0, S0 }
          v11 = 0;
          v12 = 0;
          v13 = _H0;
          v14 = 0;
          (*(void (**)(_BYTE *, uint64_t, int *))(*(_QWORD *)v4 + 96))(v4, a1, &v11);
        }
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
}

void *RB::vector<RB::CGContext::GState,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 67) + (*((_DWORD *)__dst + 67) >> 1);
  result = RB::details::realloc_vector<unsigned int,64ul>(*((void **)__dst + 32), __dst, 4u, (_DWORD *)__dst + 67, v3);
  *((_QWORD *)__dst + 32) = result;
  return result;
}

void *RB::vector<RB::CGContext::LayerState,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 115) + (*((_DWORD *)__dst + 115) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 115) + (*((_DWORD *)__dst + 115) >> 1);
  result = RB::details::realloc_vector<unsigned int,112ul>(*((void **)__dst + 56), __dst, 4u, (_DWORD *)__dst + 115, v3);
  *((_QWORD *)__dst + 56) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,112ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  uint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 112 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(112 * a5);
    v9 = ((v8 >> 4) * (unsigned __int128)0x2492492492492493uLL) >> 64;
    if (*a4 != (_DWORD)v9)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 112 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

double RB::CGContext::add_soft_mask<RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::add_alpha_mask(CGImage *,RB::Rect const&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(CGContextRef *a1, uint64_t a2)
{
  _QWORD *v2;
  double result;
  CGRect v4;

  v2 = *(_QWORD **)(a2 + 8);
  v4.origin.x = COERCE_FLOAT(*v2);
  v4.origin.y = COERCE_FLOAT(HIDWORD(*v2));
  v4.size.width = COERCE_FLOAT(v2[1]);
  v4.size.height = COERCE_FLOAT(HIDWORD(v2[1]));
  CGContextDrawImage(*a1, v4, *(CGImageRef *)a2);
  return result;
}

uint64_t RBColorModeHasExtendedRange(unsigned int a1)
{
  return (a1 < 0xE) & (0x3804u >> a1);
}

float RBColorMakeLinear(int8x16_t a1, float a2, float a3)
{
  uint64_t v3;
  float v4;
  float v5;
  int8x16_t v6;
  float result;
  int8x16_t v8;
  int8x16_t v9;

  v9 = a1;
  if (*(float *)a1.i32 <= 0.0)
    *(float *)a1.i32 = -*(float *)a1.i32;
  if (*(float *)a1.i32 <= 0.04045)
  {
    *(float *)a1.i32 = *(float *)a1.i32 * 0.077399;
    v8 = a1;
  }
  else
  {
    *(float *)&v3 = powf((float)(*(float *)a1.i32 * 0.94787) + 0.052133, 2.4);
    v8.i64[0] = v3;
  }
  v4 = -a2;
  if (a2 > 0.0)
    v4 = a2;
  if (v4 > 0.04045)
    powf((float)(v4 * 0.94787) + 0.052133, 2.4);
  v5 = -a3;
  if (a3 > 0.0)
    v5 = a3;
  if (v5 > 0.04045)
    powf((float)(v5 * 0.94787) + 0.052133, 2.4);
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v6, v8, v9).u32[0];
  return result;
}

double RBColorFromComponents(CGColorSpace *a1, float64x2_t *a2, int a3)
{
  unsigned int v3;
  double result;

  if (a3)
    v3 = 2;
  else
    v3 = 1;
  *(_QWORD *)&result = RBColorFromComponents2(a1, a2, v3).u64[0];
  return result;
}

double RBColorFromCGColor(CGColor *a1, int a2)
{
  CGColorSpace *ColorSpace;
  float64x2_t *Components;
  unsigned int v6;
  double result;

  ColorSpace = CGColorGetColorSpace(a1);
  Components = (float64x2_t *)CGColorGetComponents(a1);
  if (a2)
    v6 = 2;
  else
    v6 = 1;
  *(_QWORD *)&result = RBColorFromComponents2(ColorSpace, Components, v6).u64[0];
  return result;
}

CGColorRef RBColorCopyCGColor(unsigned int a1, float a2, float a3, float a4, float a5)
{
  BOOL v5;
  char v6;
  __int16 v7;
  unsigned __int8 v8;
  char *v9;
  CGFloat components[5];

  components[4] = *(CGFloat *)MEMORY[0x24BDAC8D0];
  components[0] = a2;
  components[1] = a3;
  components[2] = a4;
  components[3] = a5;
  v5 = a2 < 0.0;
  if (a2 > 1.0)
    v5 = 1;
  if (a3 < 0.0)
    v5 = 1;
  if (a3 > 1.0)
    v5 = 1;
  if (a4 < 0.0)
    v5 = 1;
  v6 = a4 > 1.0 || v5;
  v7 = rb_color_space(a1);
  if ((v7 & 0xFF00) != 0)
    v8 = v7;
  else
    v8 = 1;
  v9 = RB::cg_color_space((char *)v8, v6);
  return CGColorCreate((CGColorSpaceRef)v9, components);
}

float RBColorToLinear(int8x16_t a1, float a2, float a3)
{
  uint64_t v3;
  float v4;
  float v5;
  int8x16_t v6;
  float result;
  int8x16_t v8;
  int8x16_t v9;

  v9 = a1;
  if (*(float *)a1.i32 <= 0.0)
    *(float *)a1.i32 = -*(float *)a1.i32;
  if (*(float *)a1.i32 <= 0.04045)
  {
    *(float *)a1.i32 = *(float *)a1.i32 * 0.077399;
    v8 = a1;
  }
  else
  {
    *(float *)&v3 = powf((float)(*(float *)a1.i32 * 0.94787) + 0.052133, 2.4);
    v8.i64[0] = v3;
  }
  v4 = -a2;
  if (a2 > 0.0)
    v4 = a2;
  if (v4 > 0.04045)
    powf((float)(v4 * 0.94787) + 0.052133, 2.4);
  v5 = -a3;
  if (a3 > 0.0)
    v5 = a3;
  if (v5 > 0.04045)
    powf((float)(v5 * 0.94787) + 0.052133, 2.4);
  v6.i64[0] = 0x8000000080000000;
  v6.i64[1] = 0x8000000080000000;
  LODWORD(result) = vbslq_s8(v6, v8, v9).u32[0];
  return result;
}

float RBColorAdd(unsigned int a1, unsigned __int8 a2, __n128 a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, unsigned __int32 a17, __int32 a18)
{
  unsigned __int16 v27;
  unsigned __int8 v28;
  unsigned int v29;
  int8x16_t v42;
  double v43;
  int8x16_t v44;
  uint16x4_t v45;
  float result;
  __n128 v54;
  float16x4_t v55;
  unsigned __int16 v56;
  float16x4_t v57;
  unsigned __int16 v58;

  _S8 = a10;
  _S9 = a9;
  _S10 = a8;
  _S11 = a7;
  _S12 = a6;
  _S13 = a5;
  _S14 = a4;
  _S15 = a3.n128_u32[0];
  a3.n128_u32[0] = a17;
  v54 = a3;
  v27 = rb_color_space(a1);
  v28 = v27;
  v29 = v27;
  __asm
  {
    FCVT            H0, S15
    FCVT            H1, S14
    FCVT            H2, S13
    FCVT            H3, S12
  }
  v57.i16[0] = _H0;
  v57.i16[1] = _H1;
  v57.i16[2] = _H2;
  v57.i16[3] = _H3;
  v58 = v27;
  __asm
  {
    FCVT            H0, S11
    FCVT            H1, S10
    FCVT            H2, S9
    FCVT            H3, S8
  }
  v55.i16[0] = _H0;
  v55.i16[1] = _Q1.i16[0];
  v55.i16[2] = LOWORD(_D2);
  v55.i16[3] = LOWORD(_D3);
  v56 = v27;
  v42 = (int8x16_t)v54;
  v42.i32[1] = a18;
  RB::Fill::Color::mix(&v57, &v55, a2, v42, _Q1, _D2, _D3, v43, v44);
  if (v29 >= 0x100)
    RB::Fill::Color::convert((uint64_t)&v57, v28, v45);
  _H0 = v57.i16[0];
  __asm { FCVT            S0, H0 }
  _H1 = v57.i16[1];
  __asm { FCVT            S1, H1 }
  _H2 = v57.i16[2];
  __asm { FCVT            S2, H2 }
  _H3 = v57.i16[3];
  __asm { FCVT            S3, H3 }
  return result;
}

BOOL RBColorEqualToColor(float a1, float a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  return a1 == a5 && a2 == a6 && a3 == a7 && a4 == a8;
}

int32x2_t *RB::DisplayList::Builder::Builder(int32x2_t *this)
{
  RB::DisplayList::State *v2;
  __int32 v3;

  this[4] = 0;
  *(_OWORD *)this->i8 = 0u;
  *(_OWORD *)this[2].i8 = 0u;
  v2 = RB::DisplayList::State::State((RB::DisplayList::State *)&this[6], 0);
  v3 = this->i32[0];
  this[28] = 0;
  this[29] = 0;
  this[30] = (int32x2_t)0x100000001000000;
  this[31] = vdup_n_s32(0x7F7FFFFFu);
  this[32].i32[0] = v3;
  this[33] = (int32x2_t)v2;
  this[34].i8[0] = 0;
  return this;
}

void sub_209B7D154(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  _QWORD *v4;

  while (1)
  {
    v4 = *(_QWORD **)(v1 + 16);
    if (!v4)
      break;
    *(_QWORD *)(v1 + 16) = *v4;
    free(v4);
  }
  RB::DisplayList::Builder::Builder(v2);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Builder::~Builder(RB::DisplayList::Builder *this)
{
  char *v2;
  char *i;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  _QWORD *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;

  v2 = (char *)this + 48;
  for (i = (char *)*((_QWORD *)this + 33); i && i != v2; i = (char *)*((_QWORD *)this + 33))
  {
    *((_QWORD *)this + 33) = *(_QWORD *)i;
    v5 = (unsigned int *)*((_QWORD *)i + 11);
    if (v5)
    {
      v6 = v5 + 2;
      do
      {
        v7 = __ldxr(v6);
        v8 = v7 - 1;
      }
      while (__stlxr(v8, v6));
      if (!v8)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
      }
    }
    *(_QWORD *)i = *((_QWORD *)this + 2);
    *((_QWORD *)this + 2) = i;
  }
  v9 = (unsigned int *)*((_QWORD *)this + 17);
  if (v9)
  {
    v10 = v9 + 2;
    do
    {
      v11 = __ldxr(v10);
      v12 = v11 - 1;
    }
    while (__stlxr(v12, v10));
    if (!v12)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  while (1)
  {
    v13 = (_QWORD *)*((_QWORD *)this + 2);
    if (!v13)
      break;
    *((_QWORD *)this + 2) = *v13;
    free(v13);
  }
  v14 = (unsigned int *)*((_QWORD *)this + 1);
  if (v14)
  {
    v15 = v14 + 2;
    do
    {
      v16 = __ldxr(v15);
      v17 = v16 - 1;
    }
    while (__stlxr(v17, v15));
    if (!v17)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v14 + 8))(v14);
    }
  }
}

int32x2_t *RB::DisplayList::Builder::Builder(int32x2_t *this, RB::DisplayList::Contents *a2)
{
  RB::DisplayList::Contents *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int v9;
  int v10;

  v4 = (RB::DisplayList::Contents *)RB::DisplayList::Builder::Builder(this)[1];
  if (v4 != a2)
  {
    if (v4)
    {
      v5 = (unsigned int *)((char *)v4 + 8);
      do
      {
        v6 = __ldxr(v5);
        v7 = v6 - 1;
      }
      while (__stlxr(v7, v5));
      if (!v7)
      {
        __dmb(9u);
        (*(void (**)(RB::DisplayList::Contents *))(*(_QWORD *)v4 + 8))(v4);
      }
    }
    v8 = (unsigned int *)((char *)a2 + 8);
    do
      v9 = __ldxr(v8);
    while (__stxr(v9 + 1, v8));
    this[1] = (int32x2_t)a2;
  }
  this[34].i8[0] = *((_BYTE *)a2 + 400) ^ 1;
  this[28] = (int32x2_t)((char *)a2 + 320);
  v10 = this->i32[0] + 1;
  this->i32[0] = v10;
  this[32].i32[0] = v10;
  this[4] = (int32x2_t)&this[28];
  return this;
}

void sub_209B7D334(_Unwind_Exception *a1)
{
  RB::DisplayList::Builder *v1;

  RB::DisplayList::Builder::~Builder(v1);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::Builder::clear_caches(RB::DisplayList::Builder *this)
{
  _QWORD *result;

  for (result = (_QWORD *)*((_QWORD *)this + 2); result; result = (_QWORD *)*((_QWORD *)this + 2))
  {
    *((_QWORD *)this + 2) = *result;
    free(result);
  }
  return result;
}

unsigned int *RB::DisplayList::Builder::reset_contents(RB::DisplayList::Builder *this)
{
  RB::DisplayList::Contents *v2;
  unsigned int v3;
  unsigned int *result;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  int v9;
  uint64_t *v10;
  int v11;

  v2 = (RB::DisplayList::Contents *)operator new();
  v3 = *((_DWORD *)this + 1) + 1;
  *((_DWORD *)this + 1) = v3;
  RB::DisplayList::Contents::Contents(v2, v3);
  result = (unsigned int *)*((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = v2;
  if (result)
  {
    v5 = result + 2;
    do
    {
      v6 = __ldxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
    {
      __dmb(9u);
      result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 8))(result);
    }
  }
  v8 = *((_QWORD *)this + 1);
  *(_BYTE *)(v8 + 400) = *((_BYTE *)this + 272) ^ 1;
  *((_QWORD *)this + 28) = v8 + 320;
  v9 = *(_DWORD *)this + 1;
  *(_DWORD *)this = v9;
  *((_DWORD *)this + 64) = v9;
  *((_QWORD *)this + 4) = (char *)this + 224;
  v10 = (uint64_t *)*((_QWORD *)this + 33);
  if (v10)
  {
    v11 = *(_DWORD *)(v8 + 376);
    do
    {
      *((_DWORD *)v10 + 36) = v11;
      *((_DWORD *)v10 + 37) = -1;
      v10 = (uint64_t *)*v10;
    }
    while (v10);
  }
  return result;
}

void sub_209B7D450(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

double RB::DisplayList::Builder::move_contents@<D0>(RB::DisplayList::Builder *this@<X0>, const char *a2@<X1>, _QWORD *a3@<X8>)
{
  uint64_t v5;
  _QWORD *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  double result;
  __int128 v12;
  int v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v5 = *((_QWORD *)this + 1);
  if (v5
    && **((_QWORD **)this + 4) != v5 + 320
    && *((RB::DisplayList::Builder **)this + 33) == (RB::DisplayList::Builder *)((char *)this + 48))
  {
    RB::precondition_failure((RB *)"moving contents with an active layer or saved state", a2);
  }
  *((_DWORD *)this + 1) = 0;
  *((_QWORD *)this + 4) = 0;
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  if (v6)
  {
    do
      v6 = (_QWORD *)*v6;
    while (v6);
    *((_QWORD *)this + 3) = 0;
  }
  *((_OWORD *)this + 4) = xmmword_209BD5290;
  *((_OWORD *)this + 5) = xmmword_209BD52A0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  v12 = 0uLL;
  v13 = 0;
  uuid_clear((unsigned __int8 *)&v12 + 4);
  *((_OWORD *)this + 7) = v12;
  *((_DWORD *)this + 32) = v13;
  v7 = (unsigned int *)*((_QWORD *)this + 17);
  *((_QWORD *)this + 17) = 0;
  if (v7)
  {
    v8 = v7 + 2;
    do
    {
      v9 = __ldxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  result = 0.0;
  *((_OWORD *)this + 9) = 0u;
  *((_OWORD *)this + 10) = 0u;
  *((_DWORD *)this + 48) = *((_DWORD *)this + 1) + 1;
  *a3 = *((_QWORD *)this + 1);
  *((_QWORD *)this + 1) = 0;
  return result;
}

uint64_t RB::DisplayList::Builder::set_optimized(uint64_t this, int a2)
{
  uint64_t v2;

  *(_BYTE *)(this + 272) = a2;
  v2 = *(_QWORD *)(this + 8);
  if (v2 && (!a2 || !*(_QWORD *)(v2 + 320)))
    *(_BYTE *)(v2 + 400) = a2 ^ 1;
  return this;
}

void RB::DisplayList::Builder::save(RB::DisplayList::Builder *this)
{
  const RB::DisplayList::State *v2;
  RB::DisplayList::State *v3;
  _QWORD *v4;

  v2 = (const RB::DisplayList::State *)*((_QWORD *)this + 33);
  v3 = (RB::DisplayList::State *)*((_QWORD *)this + 2);
  if (v3)
    *((_QWORD *)this + 2) = *(_QWORD *)v3;
  else
    v3 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  RB::DisplayList::State::State(v3, v2);
  *v4 = *((_QWORD *)this + 33);
  *((_QWORD *)this + 33) = v4;
}

RB::DisplayList::State *RB::DisplayList::Builder::save(RB::DisplayList::Builder *this, LayerState *a2)
{
  int v4;
  const RB::DisplayList::State *v5;
  RB::DisplayList::State *v6;
  RB::DisplayList::State *result;
  uint64_t v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;

  v4 = *(_DWORD *)(*(_QWORD *)a2 + 56);
  v5 = (const RB::DisplayList::State *)*((_QWORD *)this + 33);
  v6 = (RB::DisplayList::State *)*((_QWORD *)this + 2);
  if (v6)
    *((_QWORD *)this + 2) = *(_QWORD *)v6;
  else
    v6 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  result = RB::DisplayList::State::State(v6, v4, v5);
  v8 = *(_QWORD *)a2;
  v9 = *((_QWORD *)this + 33);
  if ((*(_BYTE *)(v8 + 61) & 4) != 0)
  {
    result = (RB::DisplayList::State *)*((_QWORD *)v6 + 11);
    v10 = *(unsigned int **)(v9 + 88);
    if (result != (RB::DisplayList::State *)v10)
    {
      if (result)
      {
        v11 = (unsigned int *)((char *)result + 8);
        do
        {
          v12 = __ldxr(v11);
          v13 = v12 - 1;
        }
        while (__stlxr(v13, v11));
        if (!v13)
        {
          __dmb(9u);
          result = (RB::DisplayList::State *)(*(uint64_t (**)(RB::DisplayList::State *))(*(_QWORD *)result
                                                                                                 + 8))(result);
        }
        v10 = *(unsigned int **)(v9 + 88);
      }
      if (v10)
      {
        v14 = v10 + 2;
        do
          v15 = __ldxr(v14);
        while (__stxr(v15 + 1, v14));
      }
      *((_QWORD *)v6 + 11) = v10;
      v9 = *((_QWORD *)this + 33);
    }
  }
  *(_QWORD *)v6 = v9;
  *((_QWORD *)this + 33) = v6;
  return result;
}

unsigned int *RB::DisplayList::Builder::restore(RB::DisplayList::Builder *this, const char *a2)
{
  uint64_t *v2;
  uint64_t v3;
  unsigned int *result;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  v2 = (uint64_t *)*((_QWORD *)this + 33);
  v3 = *v2;
  if (!*v2)
    RB::precondition_failure((RB *)"too many gstate restores", a2);
  if ((a2 & 1) == 0 && *((_DWORD *)v2 + 36) != *(_DWORD *)(v3 + 144))
    RB::precondition_failure((RB *)"restoring out of layer", a2);
  *((_QWORD *)this + 33) = v3;
  result = (unsigned int *)v2[11];
  if (result)
  {
    v6 = result + 2;
    do
    {
      v7 = __ldxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
    {
      __dmb(9u);
      result = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)result + 8))(result);
    }
  }
  *v2 = *((_QWORD *)this + 2);
  *((_QWORD *)this + 2) = v2;
  return result;
}

double RB::DisplayList::Builder::copy_state(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  RB::DisplayList::State *v4;

  v4 = (RB::DisplayList::State *)*((_QWORD *)this + 2);
  if (v4)
    *((_QWORD *)this + 2) = *(_QWORD *)v4;
  else
    v4 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  return RB::DisplayList::State::State(v4, a2);
}

RB::DisplayList::State *RB::DisplayList::Builder::copy_state(RB::DisplayList::Builder *this, LayerState *a2, unsigned int **a3)
{
  int v5;
  RB::DisplayList::State *v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v12;
  unsigned int v13;

  v5 = *(_DWORD *)(*(_QWORD *)a2 + 56);
  v6 = (RB::DisplayList::State *)*((_QWORD *)this + 2);
  if (v6)
    *((_QWORD *)this + 2) = *(_QWORD *)v6;
  else
    v6 = (RB::DisplayList::State *)malloc_type_malloc(0xB0uLL, 0x9E39E26DuLL);
  RB::DisplayList::State::State(v6, v5, (const RB::DisplayList::State *)a3);
  if ((*(_BYTE *)(*(_QWORD *)a2 + 61) & 4) != 0)
  {
    v7 = (unsigned int *)*((_QWORD *)v6 + 11);
    v8 = a3[11];
    if (v7 != v8)
    {
      if (v7)
      {
        v9 = v7 + 2;
        do
        {
          v10 = __ldxr(v9);
          v11 = v10 - 1;
        }
        while (__stlxr(v11, v9));
        if (!v11)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
        }
        v8 = a3[11];
      }
      if (v8)
      {
        v12 = v8 + 2;
        do
          v13 = __ldxr(v12);
        while (__stxr(v13 + 1, v12));
      }
      *((_QWORD *)v6 + 11) = v8;
    }
  }
  return v6;
}

unsigned int *RB::DisplayList::Builder::delete_state(unsigned int *this, const RB::DisplayList::State *a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (a2)
  {
    v3 = (uint64_t)this;
    this = (unsigned int *)*((_QWORD *)a2 + 11);
    if (this)
    {
      v4 = this + 2;
      do
      {
        v5 = __ldxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
      {
        __dmb(9u);
        this = (unsigned int *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)this + 8))(this);
      }
    }
    *(_QWORD *)a2 = *(_QWORD *)(v3 + 16);
    *(_QWORD *)(v3 + 16) = a2;
  }
  return this;
}

float32x2_t *RB::DisplayList::Builder::set_crop(float32x2_t *result, float32x2_t a2, float32x2_t a3)
{
  uint32x2_t v3;
  int v4;

  v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(result[31], a3), (int8x8_t)vceq_f32(result[30], a2));
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    result[30] = a2;
    result[31] = a3;
    v4 = result->i32[0] + 1;
    result->i32[0] = v4;
    result[32].i32[0] = v4;
  }
  return result;
}

uint64_t RB::DisplayList::Builder::crop_bounds(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  uint64_t v4;
  RB::DisplayList::Style *v5;
  float32x2_t *v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float64x2_t v12[2];
  uint64_t v13;
  uint64_t v14;
  __int128 v15;

  if (!*((_QWORD *)this + 1))
    RB::DisplayList::Builder::reset_contents(this);
  v4 = *((_QWORD *)this + 4);
  if (*((_DWORD *)a2 + 37) != *(_DWORD *)(v4 + 32))
  {
    v15 = *(_OWORD *)(v4 + 16);
    v12[0] = (float64x2_t)xmmword_209BD5290;
    v12[1] = (float64x2_t)xmmword_209BD52A0;
    v13 = 0;
    v14 = 0;
    v5 = (RB::DisplayList::Style *)*((_QWORD *)a2 + 13);
    if (v5)
      RB::DisplayList::Style::roi(v5, (float32x2_t *)&v15, v12);
    v6 = (float32x2_t *)*((_QWORD *)a2 + 12);
    if (v6)
    {
      RB::Rect::move_identity((float32x2_t *)&v15, v12);
      RB::Rect::intersect((float32x2_t *)&v15, v6[2], v6[3], v7, v8, v9, v10);
    }
    RB::Rect::move((float32x2_t *)&v15, v12, (float64x2_t *)a2 + 1);
    *((_OWORD *)a2 + 8) = v15;
    *((_DWORD *)a2 + 37) = *(_DWORD *)(*((_QWORD *)this + 4) + 32);
  }
  return (uint64_t)a2 + 128;
}

uint64_t RB::DisplayList::Builder::culling_bounds(RB::DisplayList::Builder *this, RB::DisplayList::State *a2)
{
  uint64_t result;
  uint32x2_t v3;

  if (!*((_BYTE *)this + 272))
    return 0;
  result = RB::DisplayList::Builder::crop_bounds(this, a2);
  v3 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)(result + 8) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if (vpmax_u32(v3, v3).i32[0] < 0)
    return 0;
  return result;
}

uint64_t RB::DisplayList::Builder::make_layer(RB::DisplayList::Builder *this, int a2)
{
  int *v2;
  int v3;
  size_t *v4;
  int v6;

  v6 = a2;
  v2 = (int *)((char *)this + 4);
  v3 = *((_DWORD *)this + 1);
  v4 = (size_t *)(*((_QWORD *)this + 1) + 16);
  *v2 = v3 + 1;
  return RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v4, v2, &v6);
}

int32x2_t *RB::DisplayList::Builder::begin_layer(RB::DisplayList::Builder *this, const RB::DisplayList::State *a2, int a3)
{
  uint64_t v6;
  size_t *v7;
  uint64_t v8;
  size_t *v9;
  int v10;
  int32x2_t *v11;
  RB::DisplayList::Style *v12;
  float32x2_t *v13;
  double v14;
  double v15;
  double v16;
  int32x4_t v17;
  float64x2_t v19[2];
  uint64_t v20;
  uint64_t v21;
  __int128 v22;

  if (!*((_QWORD *)this + 1))
    RB::DisplayList::Builder::reset_contents(this);
  v6 = *((_QWORD *)this + 4);
  if (!v6 || *(_DWORD *)(*(_QWORD *)v6 + 56) != *((_DWORD *)a2 + 36))
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  LODWORD(v19[0].f64[0]) = a3;
  v7 = (size_t *)(*((_QWORD *)this + 1) + 16);
  ++*((_DWORD *)this + 1);
  v8 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v7, (int *)this + 1, (int *)v19);
  v9 = (size_t *)*((_QWORD *)this + 1);
  v10 = *(_DWORD *)this + 1;
  *(_DWORD *)this = v10;
  v11 = (int32x2_t *)*((_QWORD *)this + 3);
  if (v11)
  {
    *((int32x2_t *)this + 3) = *v11;
  }
  else
  {
    v11 = (int32x2_t *)((v9[4] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)&v11[5] > v9[5])
    {
      v11 = (int32x2_t *)RB::Heap::alloc_slow(v9 + 2, 0x28uLL, 7);
      v10 = *(_DWORD *)this;
    }
    else
    {
      v9[4] = (size_t)&v11[5];
    }
  }
  v11[2] = (int32x2_t)0x100000001000000;
  *v11 = (int32x2_t)v8;
  v11[1] = 0;
  v11[3] = vdup_n_s32(0x7F7FFFFFu);
  v11[4].i32[0] = v10;
  v22 = *(_OWORD *)(*((_QWORD *)this + 4) + 16);
  v19[0] = (float64x2_t)xmmword_209BD5290;
  v19[1] = (float64x2_t)xmmword_209BD52A0;
  v20 = 0;
  v21 = 0;
  v12 = (RB::DisplayList::Style *)*((_QWORD *)a2 + 13);
  if (v12)
    RB::DisplayList::Style::roi(v12, (float32x2_t *)&v22, v19);
  v13 = (float32x2_t *)*((_QWORD *)a2 + 12);
  if (v13)
  {
    RB::Rect::move_identity((float32x2_t *)&v22, v19);
    RB::Rect::intersect((float32x2_t *)&v22, v13[2], v13[3], v14, v15, v16, v17);
  }
  RB::Rect::move_identity((float32x2_t *)&v22, v19);
  *(_OWORD *)v11[2].i8 = v22;
  v11[1] = *(int32x2_t *)((char *)this + 32);
  *((_QWORD *)this + 4) = v11;
  return v11;
}

uint64_t RB::DisplayList::Builder::end_layer(RB::DisplayList::Builder *this, const RB::DisplayList::State *a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (_QWORD *)*((_QWORD *)this + 4);
  if (!v2 || (v3 = *v2, *(_DWORD *)(*v2 + 56) != *((_DWORD *)a2 + 36)))
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  v4 = v2[1];
  *v2 = *((_QWORD *)this + 3);
  *((_QWORD *)this + 3) = v2;
  *((_QWORD *)this + 4) = v4;
  return v3;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw_layer(uint64_t a1, uint64_t a2, int8x16_t *a3, int a4, float a5)
{
  int v7;
  unsigned int *v9;
  uint64_t v10;
  int8x16_t *v11;
  RB::DisplayList::Builder *result;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  float v18;
  uint64_t v19;

  v19 = a2;
  v18 = a5;
  v7 = *(_DWORD *)(a2 + 60);
  if ((v7 & 0x800) != 0)
    a4 = 24;
  v17 = a4;
  if ((v7 & 0x400) != 0)
  {
    v9 = (unsigned int *)a3[5].i64[1];
    a3[5].i64[1] = 0;
    v10 = a3[7].i64[1];
    a3[7].i64[1] = 0;
  }
  else
  {
    v9 = 0;
    v10 = 0;
  }
  RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>((size_t *)(*(_QWORD *)(a1 + 8) + 16), &v18, &v17, &v19);
  result = RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v11, a3);
  if ((*(_BYTE *)(v19 + 61) & 4) != 0)
  {
    v13 = a3[5].i64[1];
    a3[5].i64[1] = (uint64_t)v9;
    a3[7].i64[1] = v10;
    v9 = (unsigned int *)v13;
  }
  if (v9)
  {
    v14 = v9 + 2;
    do
    {
      v15 = __ldxr(v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, v14));
    if (!v16)
    {
      __dmb(9u);
      return (RB::DisplayList::Builder *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v9 + 8))(v9);
    }
  }
  return result;
}

void sub_209B7DD94(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    -[RBEncoderSet addDisplayList:].cold.1(v1);
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw(RB::DisplayList::Contents **this, int8x16_t *a2, int8x16_t *a3)
{
  RB::DisplayList::Layer **v6;
  RB::DisplayList::Layer *v7;

  if (!this[1])
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)this);
  v6 = (RB::DisplayList::Layer **)this[4];
  if (!v6 || (v7 = *v6, *((_DWORD *)*v6 + 14) != a3[9].i32[0]))
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", a2->i8);
  a2[1] = vextq_s8(a3[6], a3[6], 8uLL);
  if (!*((_BYTE *)this + 272))
  {
    a2[2].i64[0] = (uint64_t)RB::DisplayList::State::copy_metadata((RB::DisplayList::State *)a3, this[1]);
    a2[2].i32[2] = a3[4].i32[0];
    v7 = *(RB::DisplayList::Layer **)this[4];
  }
  return RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)this, (RB::DisplayList::Item *)a2, v7, 0);
}

void RB::DisplayList::Builder::clip_layer(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, __n128 *a3, uint64_t a4, float a5)
{
  uint64_t v8;
  unint64_t v10;
  const RB::DisplayList::ClipNode **v11;
  void *v12;
  RB::DisplayList::Clip **v13;
  uint64_t v14;
  RB::DisplayList::Clip *v15;
  unsigned int v16;
  float v17;
  RB::DisplayList::Layer *v18;
  _OWORD v19[2];
  __int128 v20;
  uint64_t v21;
  uint64_t v22;

  v8 = (uint64_t)a2;
  v22 = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  v17 = a5;
  v16 = a4;
  if (*((_BYTE *)this + 272))
  {
    if (a5 == 0.0)
    {
      RB::DisplayList::Layer::~Layer(a2);
      goto LABEL_21;
    }
    v8 = (uint64_t)RB::DisplayList::Builder::simplify_clip_layer(this, a2, a4);
    v10 = (unint64_t)v11;
    v18 = (RB::DisplayList::Layer *)v8;
  }
  else
  {
    v10 = 0;
  }
  if (!(v8 | v10))
  {
LABEL_21:
    if ((_DWORD)a4 != 1)
    {
      memset(v19, 0, sizeof(v19));
      LODWORD(v20) = 1065353216;
      *(_QWORD *)((char *)&v20 + 4) = 0;
      *(_DWORD *)((char *)&v20 + 11) = 0;
      RB::DisplayList::State::clip<RB::Coverage::Primitive>(a3, this, v19, a4, 1.0);
    }
    return;
  }
  if (v10)
  {
    RB::DisplayList::State::append((RB::DisplayList::State *)a3, this, *(const RB::DisplayList::ClipNode **)(v10 + 24), (_DWORD)a4 == 1);
    *(_QWORD *)(v10 + 24) = 0;
    v20 = 0uLL;
    v21 = 4;
    (*(void (**)(unint64_t, RB::DisplayList::Builder *, uint64_t, _OWORD *, float))(*(_QWORD *)v10 + 88))(v10, this, a4, v19, a5);
    v12 = (void *)v20;
    if ((_QWORD)v20)
      v13 = (RB::DisplayList::Clip **)v20;
    else
      v13 = (RB::DisplayList::Clip **)v19;
    if (*((_QWORD *)&v20 + 1))
    {
      v14 = 8 * *((_QWORD *)&v20 + 1);
      do
      {
        RB::DisplayList::State::push((RB::DisplayList::State *)a3, this, *v13++);
        v14 -= 8;
      }
      while (v14);
      v12 = (void *)v20;
    }
    if (v12)
      free(v12);
  }
  if (v8)
  {
    if (*((_BYTE *)this + 272))
      RB::DisplayList::Layer::discard_color(v8);
    v15 = (RB::DisplayList::Clip *)RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>((size_t *)(*((_QWORD *)this + 1) + 16), &v18, &v17, &v16);
    RB::DisplayList::State::push((RB::DisplayList::State *)a3, this, v15);
  }
}

void sub_209B7E024(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  if (a15)
    free(a15);
  _Unwind_Resume(exception_object);
}

RB::DisplayList::Layer *RB::DisplayList::Builder::simplify_clip_layer(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  RB::DisplayList::Layer *v3;
  int v6;
  char v7;
  _QWORD *v8;
  uint32x2_t v9;
  uint64_t v11;
  float32x2_t v12;

  v3 = a2;
  if (a2)
  {
    if (!*(_QWORD *)a2 && (*((_WORD *)a2 + 30) & 0x2001) == 0)
    {
      v7 = RB::DisplayList::Layer::effect_needs_zero_alpha(a2);
      if ((v7 & 1) != 0 || (v8 = (_QWORD *)*((_QWORD *)v3 + 2)) == 0)
      {
LABEL_13:
        if ((v7 & 1) == 0)
        {
LABEL_14:
          RB::DisplayList::Layer::~Layer(v3);
          return 0;
        }
      }
      else
      {
        while (1)
        {
          v11 = 0;
          v12 = 0;
          (*(void (**)(_QWORD *, uint64_t *))(*v8 + 56))(v8, &v11);
          v9 = (uint32x2_t)vcgtz_f32(v12);
          if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0)
            break;
          v8 = (_QWORD *)v8[1];
          if (!v8)
            goto LABEL_13;
        }
      }
    }
    RB::DisplayList::Builder::lower_color_filters(this, v3, 0);
    if (a3 == 1)
      v6 = 14;
    else
      v6 = 10;
    if (RB::DisplayList::Builder::merge_layer_item(this, v3, v6))
      goto LABEL_14;
  }
  return v3;
}

uint64_t RB::DisplayList::State::clip<RB::Coverage::Primitive>(__n128 *a1, RB::DisplayList::Builder *a2, _OWORD *a3, int a4, float a5)
{
  RB::Heap *v8;
  __n128 v9;
  uint64_t v10;
  RB::DisplayList::Clip *v11;
  uint64_t v13;
  int v14;
  float v15;

  v15 = a5;
  v14 = a4;
  v8 = (RB::Heap *)(*((_QWORD *)a2 + 1) + 16);
  v9 = RB::DisplayList::State::copy_ctm(a1, v8);
  v13 = v10;
  v11 = (RB::DisplayList::Clip *)RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>((size_t *)v8, (int8x16_t)v9, (uint64_t)v8, a3, (unsigned __int32 *)&v15, &v14, &v13);
  return RB::DisplayList::State::push((RB::DisplayList::State *)a1, a2, v11);
}

float *RB::DisplayList::Builder::make_layer_item(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3, float64x2_t *a4, float a5, float a6)
{
  char v6;
  float *v9;
  int64x2_t v11;
  float v12;
  uint64_t v13;
  uint64_t v14;
  int v16;
  float v17;
  RB::DisplayList::Layer *v18;
  _BYTE v19[8];
  uint64_t v20;
  uint64_t v21;
  _QWORD v22[15];

  v6 = a3;
  v9 = (float *)a2;
  v22[14] = *MEMORY[0x24BDAC8D0];
  v18 = a2;
  v17 = a5;
  v16 = a3;
  v11 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v11, 1), (int8x16_t)v11).u64[0] & 0x8000000000000000) == 0)
  {
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v19, (uint64_t)this, (__int128 *)a4, 0, 0, 0);
    RB::DisplayList::Layer::apply_transform((RB::DisplayList::Layer *)v9, (const RB::DisplayList::CachedTransform *)v19);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v22);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v21);
    RB::Heap::~Heap((RB::Heap *)&v20);
  }
  if (a6 > 0.0 && a6 < 1.0)
  {
    RB::DisplayList::Layer::min_scale((RB::DisplayList::Layer *)v9);
    if (v12 <= a6)
      v12 = a6;
    v9[12] = v12;
  }
  if (!*((_BYTE *)this + 272))
  {
    if (!v9)
      return v9;
    goto LABEL_14;
  }
  if (a5 == 0.0)
  {
    RB::DisplayList::Layer::~Layer((RB::DisplayList::Layer *)v9);
    return 0;
  }
  v18 = RB::DisplayList::Builder::simplify_clip_layer(this, (RB::DisplayList::Layer *)v9, 0);
  if (v18)
  {
LABEL_14:
    RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>((size_t *)(*((_QWORD *)this + 1) + 16), &v17, &v16, (uint64_t *)&v18);
    return (float *)v14;
  }
  v9 = (float *)v13;
  if (v13)
  {
    *(_WORD *)(v13 + 46) = *(_WORD *)(v13 + 46) & 0xFFC0 | v6 & 0x3F;
    RB::DisplayList::Item::apply_alpha(v13, a5);
  }
  return v9;
}

void sub_209B7E378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Layer *RB::DisplayList::Builder::simplify_item(RB::DisplayList::Layer *result, RB::DisplayList::Layer **a2, char a3)
{
  RB::DisplayList::Layer *v4;
  RB::DisplayList::Layer *v6;

  if (*((_BYTE *)result + 272))
  {
    v4 = *a2;
    if ((*((_WORD *)*a2 + 23) & 0x200) != 0)
    {
      result = RB::DisplayList::Builder::simplify_clip_layer(result, *((RB::DisplayList::Layer **)v4 + 6), 0);
      if (result)
      {
        if ((a3 & 1) != 0)
          return (RB::DisplayList::Layer *)RB::DisplayList::Layer::discard_color(*((_QWORD *)v4 + 6));
      }
      else
      {
        result = *a2;
        *a2 = v6;
        if (result)
          return (RB::DisplayList::Layer *)(**(uint64_t (***)(RB::DisplayList::Layer *))result)(result);
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::Builder::lower_color_filters(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  uint64_t result;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  int v10;
  int v11;

  result = *((_QWORD *)a2 + 2);
  if (result)
  {
    if (!*(_QWORD *)(result + 8) && (*((_WORD *)a2 + 30) & 0x2001) == 0)
    {
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 40))(result);
      if ((_DWORD)result == 1)
      {
        v8 = v7;
        v9 = (uint64_t)(v7 + 2);
        if ((*v7 & 1) != 0)
          LOWORD(v10) = 256;
        else
          v10 = ((*v7 & 2) << 7) | (*v7 >> 1) & 1;
        result = RB::DisplayList::Builder::can_lower_color_matrix((uint64_t *)a2, (uint64_t)(v7 + 2), (*v7 >> 2) & 1, v10, a3);
        if ((_DWORD)result)
        {
          if ((*v8 & 1) != 0)
            LOWORD(v11) = 256;
          else
            v11 = ((*v8 & 2) << 7) | (*v8 >> 1) & 1;
          RB::DisplayList::Builder::lower_color_matrix((uint64_t)this, (_QWORD **)a2, v9, (*v8 >> 2) & 1, v11, a3);
          result = (***((uint64_t (****)(_QWORD))a2 + 2))(*((_QWORD *)a2 + 2));
          *((_QWORD *)a2 + 2) = 0;
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, int a3)
{
  uint64_t v3;
  uint64_t result;
  __int16 v5;
  _QWORD *v8;
  char v9;
  unsigned int v10;
  int v11;
  uint64_t v12;
  float v13;
  float v14;
  unsigned int v15;
  float32x2_t v16;
  float32x2_t v17;
  unint64_t v18;
  __int128 v19;
  int v20;
  char v21;
  __int128 v23[2];
  uint64_t v24;
  uint64_t v25;
  int v26;
  _BYTE v27[1480];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)a2;
  if (!*(_QWORD *)a2)
    return 0;
  if (*(_QWORD *)(v3 + 8))
    return 0;
  v5 = *(_WORD *)(v3 + 46);
  if ((v5 & 0x1C0) != 0 || !RB::may_discard_dest(v5 & 0x3F))
    return 0;
  if (!*(_QWORD *)(v3 + 24))
  {
LABEL_13:
    if ((a3 & 8) == 0 || (*(unsigned int (**)(uint64_t))(*(_QWORD *)v3 + 80))(v3))
    {
      v9 = 1;
      if ((a3 & 1) == 0 && !*((_BYTE *)a2 + 64) && !*((_QWORD *)a2 + 2) && *((float *)a2 + 12) == 0.0)
      {
        v10 = *((_DWORD *)a2 + 15);
        v11 = (v10 >> 3) & 1;
        if ((a3 & 2) != 0)
          LOBYTE(v11) = 0;
        if ((v10 & 0x2207) != 0)
          v9 = 1;
        else
          v9 = v11;
      }
      v26 = a3;
      if ((*(_WORD *)(v3 + 46) & 0x200) != 0)
      {
        if ((v9 & 1) != 0)
        {
          v12 = *(_QWORD *)(v3 + 48);
          if (!v12
            || !RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Layer &,unsigned int)::$_0::operator()(&v26, (uint64_t)a2, *(_QWORD *)(v3 + 48)))
          {
            return 0;
          }
          RB::DisplayList::Layer::move_filters(v12, a2);
          if ((*((_BYTE *)a2 + 61) & 2) != 0)
            *(_DWORD *)(v12 + 60) |= 0x200u;
          v13 = *(float *)(v12 + 48);
          v14 = *((float *)a2 + 12);
          if (v13 != 0.0 || v14 != 0.0)
          {
            if (v14 != 0.0 && *(_QWORD *)(v3 + 24))
            {
              v15 = *((_DWORD *)a2 + 12);
              v16 = vrecpe_f32((float32x2_t)LODWORD(v14));
              v17 = vmul_f32(vrecps_f32((float32x2_t)v15, v16), v16);
              *(double *)&v18 = vmul_f32(v17, vrecps_f32((float32x2_t)v15, v17)).f32[0];
              *(_QWORD *)&v19 = 0;
              *((_QWORD *)&v19 + 1) = v18;
              v23[0] = v18;
              v23[1] = v19;
              v24 = 0;
              v25 = 0;
              RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v27, (uint64_t)this, v23, 0, 0, 0);
              *(_QWORD *)(v3 + 24) = RB::DisplayList::CachedTransform::transform_clip((RB::DisplayList::CachedTransform *)v27, *(_QWORD *)(v3 + 24), 0);
              RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)v27);
              v13 = *(float *)(v12 + 48);
              v14 = *((float *)a2 + 12);
            }
            if (v13 == 0.0)
              v13 = 1.0;
            if (v14 == 0.0)
              v14 = 1.0;
            *(float *)(v12 + 48) = v14 * v13;
          }
          if (*((_BYTE *)a2 + 64))
          {
            *(_BYTE *)(v12 + 64) = *((_BYTE *)a2 + 64);
            *(_QWORD *)(v12 + 24) = *((_QWORD *)a2 + 3);
          }
          v20 = *((_DWORD *)a2 + 15);
          if ((v20 & 0x2000) != 0)
          {
            v21 = *(_BYTE *)(v12 + 67);
            if (v21)
            {
              v20 &= ~0x2000u;
              *((_DWORD *)a2 + 15) = v20;
              *(_BYTE *)(v12 + 67) = v21 - 1;
            }
          }
          *(_DWORD *)(v12 + 60) |= v20;
        }
      }
      else if ((v9 & 1) != 0)
      {
        return 0;
      }
      *(_QWORD *)a2 = 0;
      return v3;
    }
    return 0;
  }
  result = 0;
  if ((a3 & 4) == 0 && !*((_BYTE *)a2 + 64))
  {
    v8 = (_QWORD *)*((_QWORD *)a2 + 2);
    if (v8)
    {
      while (((*(uint64_t (**)(_QWORD *))(*v8 + 64))(v8) & 1) != 0)
      {
        v8 = (_QWORD *)v8[1];
        if (!v8)
          goto LABEL_13;
      }
      return 0;
    }
    goto LABEL_13;
  }
  return result;
}

void sub_209B7E7B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

const RB::DisplayList::ClipNode *RB::DisplayList::Builder::join_clip_lists(uint64_t a1, _QWORD *a2, const RB::DisplayList::ClipNode *a3)
{
  _QWORD *v3;
  size_t *v5;
  const RB::DisplayList::ClipNode *v6;
  const RB::DisplayList::Clip *v8;
  const RB::DisplayList::ClipNode *v9;

  if (a2)
  {
    v3 = a2;
    if (a3)
    {
      v9 = a3;
      do
      {
        v5 = (size_t *)(*(_QWORD *)(a1 + 8) + 16);
        v8 = (const RB::DisplayList::Clip *)(v3[1] & 0xFFFFFFFFFFFFFFFELL);
        v6 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(v5, &v8, &v9);
        v9 = v6;
        v3 = (_QWORD *)*v3;
      }
      while (v3);
      return v6;
    }
    else
    {
      return (const RB::DisplayList::ClipNode *)a2;
    }
  }
  return a3;
}

float64x2_t RB::DisplayList::CachedTransform::CachedTransform(RB::DisplayList::CachedTransform *this, float64x2_t *a2, float a3, float a4, int a5)
{
  uint64_t v6;
  double v7;
  float64x2_t v8;
  float64x2_t v9;
  __int128 v10;
  float64x2_t *v11;
  float64x2_t result;
  __int128 v13[3];

  v6 = *(_QWORD *)&a2->f64[0];
  v7 = a3;
  v8 = vmulq_n_f64(a2[68], v7);
  v9 = vmulq_n_f64(a2[69], v7);
  v10 = (__int128)a2[70];
  v13[0] = (__int128)v8;
  v13[1] = (__int128)v9;
  v13[2] = v10;
  v11 = (float64x2_t *)RB::DisplayList::CachedTransform::CachedTransform((uint64_t)this, v6, v13, 0, 0, a5);
  result = vmulq_n_f64(v11[70], a4);
  v11[70] = result;
  return result;
}

void RB::DisplayList::CachedTransform::transform_scale(RB::DisplayList::CachedTransform *this)
{
  if (*((float *)this + 288) == 0.0)
    *((float *)this + 288) = RB::AffineTransform::scale((float64x2_t *)this + 68);
}

uint64_t RB::DisplayList::CachedTransform::transform_projection(RB::DisplayList::CachedTransform *this, const RB::ProjectionMatrix *a2)
{
  __int128 v4;
  _BOOL4 v5;
  float64x2_t *v6;
  float64x2_t v7;
  __int128 *v8;
  __int128 v9;
  __int128 *v10;
  __int128 v11;
  size_t *v12;
  uint64_t result;
  __int128 v14;
  __int128 v15;
  float v16[9];
  _OWORD v17[2];
  int v18;
  float64x2_t v19;
  __int128 v20;
  __int128 v21;

  if (*((const RB::ProjectionMatrix **)this + 154) == a2)
    return *((_QWORD *)this + 155);
  v4 = *((_OWORD *)this + 69);
  v19 = *((float64x2_t *)this + 68);
  v20 = v4;
  v21 = *((_OWORD *)this + 70);
  v5 = RB::AffineTransform::invert((RB::AffineTransform *)&v19);
  if (v5)
    v6 = &v19;
  else
    v6 = (float64x2_t *)((char *)this + 1088);
  v7 = *v6;
  if (v5)
    v8 = &v20;
  else
    v8 = (__int128 *)((char *)this + 1104);
  v9 = *v8;
  if (v5)
    v10 = &v21;
  else
    v10 = (__int128 *)((char *)this + 1120);
  v11 = *v10;
  v19 = v7;
  v20 = v9;
  v21 = v11;
  *((_QWORD *)this + 154) = a2;
  v12 = *(size_t **)(*(_QWORD *)this + 8);
  RB::operator*(&v19, (uint64_t)a2, (uint64_t)v16);
  RB::operator*(v16, (float64x2_t *)this + 68, (uint64_t)v17);
  result = (v12[4] + 3) & 0xFFFFFFFFFFFFFFFCLL;
  if (result + 36 > v12[5])
    result = RB::Heap::alloc_slow(v12 + 2, 0x24uLL, 3);
  else
    v12[4] = result + 36;
  v14 = v17[0];
  v15 = v17[1];
  *(_DWORD *)(result + 32) = v18;
  *(_OWORD *)result = v14;
  *(_OWORD *)(result + 16) = v15;
  *((_QWORD *)this + 155) = result;
  return result;
}

uint64_t RB::DisplayList::can_mix(uint64_t a1, _QWORD *a2, _QWORD *a3)
{
  _BOOL4 v3;
  _BOOL4 v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  int v12;
  unsigned int v13;
  BOOL v14;

  v3 = a2 != 0;
  v4 = a3 != 0;
  v5 = 4;
  if (a2 && (v6 = a3) != 0)
  {
    v7 = a2;
    while (v7 != v6)
    {
      v9 = v7[1] & 0xFFFFFFFFFFFFFFFELL;
      v10 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
      if (v9 != v10)
      {
        if (v9)
          v11 = v10 == 0;
        else
          v11 = 1;
        if (v11)
          return 0;
        v12 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v9 + 16))(v9);
        if (v12 != (*(unsigned int (**)(unint64_t))(*(_QWORD *)v10 + 16))(v10))
          return 0;
        v9 = v7[1] & 0xFFFFFFFFFFFFFFFELL;
        v10 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
      }
      v13 = (*(unsigned __int8 (**)(unint64_t, uint64_t, unint64_t))(*(_QWORD *)v9 + 64))(v9, a1, v10);
      if (v13 >= v5)
        v5 = v5;
      else
        v5 = v13;
      v7 = (_QWORD *)*v7;
      v6 = (_QWORD *)*v6;
      v3 = v7 != 0;
      v4 = v6 != 0;
      if ((_DWORD)v5)
        v14 = v7 == 0;
      else
        v14 = 1;
      if (v14 || v6 == 0)
        goto LABEL_23;
    }
  }
  else
  {
LABEL_23:
    if (v3 || v4)
      return 0;
    else
      return v5;
  }
  return v5;
}

uint64_t RB::DisplayList::can_mix(uint64_t a1, float32x2_t *a2, float32x2_t *a3, uint64_t a4, uint64_t a5)
{
  float32x2_t **v7;
  float32x2_t **v8;
  uint64_t v9;
  unint64_t v11;
  unint64_t v12;
  BOOL v13;
  int v14;
  unsigned int v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  float32x2_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  int32x4_t v28;
  float32x2_t v29;
  float32x2_t *v31;
  float32x2_t v32;
  double v33;
  double v34;

  v7 = (float32x2_t **)a3;
  v8 = (float32x2_t **)a2;
  v9 = 4;
  if (!a2 || !a3)
  {
LABEL_17:
    if (v8)
    {
LABEL_18:
      v16 = (*(double (**)(uint64_t, uint64_t))(*(_QWORD *)a4 + 144))(a4, 1);
      v33 = v16;
      v34 = v17;
      LODWORD(v16) = 1036831949;
      RB::Rect::inset((float32x2_t *)&v33, *(float32x2_t *)&v16, 0.1);
      while (1)
      {
        if ((v8[1] & 1) != 0)
        {
          v22 = (float32x2_t)v8[3];
          v31 = v8[2];
          v32 = v22;
          if ((RB::Rect::contains((float32x2_t *)&v31, *(float32x2_t *)&v33, *(float32x2_t *)&v34, v18, v19, v20, v21) & 1) != 0)
            break;
        }
        if ((*(unsigned int (**)(unint64_t, double, double))(*(_QWORD *)((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                              + 32))((unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL, v33, v34))
        {
          v8 = (float32x2_t **)*v8;
          if (v8)
            continue;
        }
        goto LABEL_23;
      }
      v8 = 0;
      if (!v7)
        goto LABEL_33;
    }
    else
    {
LABEL_23:
      if (!v7)
      {
LABEL_33:
        if ((unint64_t)v8 | (unint64_t)v7)
          return 0;
        else
          return v9;
      }
    }
    v23 = (*(double (**)(uint64_t, uint64_t))(*(_QWORD *)a5 + 144))(a5, 1);
    v33 = v23;
    v34 = v24;
    LODWORD(v23) = 1036831949;
    RB::Rect::inset((float32x2_t *)&v33, *(float32x2_t *)&v23, 0.1);
    while (1)
    {
      if ((v7[1] & 1) != 0)
      {
        v29 = (float32x2_t)v7[3];
        v31 = v7[2];
        v32 = v29;
        if ((RB::Rect::contains((float32x2_t *)&v31, *(float32x2_t *)&v33, *(float32x2_t *)&v34, v25, v26, v27, v28) & 1) != 0)
          break;
      }
      if ((*(unsigned int (**)(unint64_t, double, double))(*(_QWORD *)((unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                            + 32))((unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL, v33, v34))
      {
        v7 = (float32x2_t **)*v7;
        if (v7)
          continue;
      }
      goto LABEL_33;
    }
    v7 = 0;
    goto LABEL_33;
  }
  while (v8 != v7)
  {
    v11 = (unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL;
    v12 = (unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL;
    if (v11 != v12)
    {
      if (v11)
        v13 = v12 == 0;
      else
        v13 = 1;
      if (v13)
        goto LABEL_18;
      v14 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v11 + 16))(v11);
      if (v14 != (*(unsigned int (**)(unint64_t))(*(_QWORD *)v12 + 16))(v12))
        goto LABEL_18;
      v11 = (unint64_t)v8[1] & 0xFFFFFFFFFFFFFFFELL;
      v12 = (unint64_t)v7[1] & 0xFFFFFFFFFFFFFFFELL;
    }
    v15 = (*(unsigned __int8 (**)(unint64_t, uint64_t, unint64_t))(*(_QWORD *)v11 + 64))(v11, a1, v12);
    if (v15 >= v9)
      v9 = v9;
    else
      v9 = v15;
    if (!(_DWORD)v9)
      return v9;
    v8 = (float32x2_t **)*v8;
    v7 = (float32x2_t **)*v7;
    if (!v8 || !v7)
      goto LABEL_17;
  }
  return v9;
}

const RB::DisplayList::ClipNode *RB::DisplayList::CachedTransform::mix_clip(const RB::DisplayList::ClipNode **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::ClipNode *a3, const RB::DisplayList::ClipNode *a4, int a5)
{
  const RB::DisplayList::ClipNode *v7;
  const RB::DisplayList::ClipNode *v8;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  int v13;
  uint64_t v14;
  int v15;
  size_t v16;
  size_t v17;
  _BYTE *v18;
  const RB::DisplayList::ClipNode *v19;
  size_t v20;
  _BYTE *v21;
  const RB::DisplayList::Clip *v22;
  const RB::DisplayList::ClipNode *v23;
  uint64_t v24;
  const RB::DisplayList::Clip *v26;
  const RB::DisplayList::ClipNode *v27;
  _BYTE __dst[128];
  void *v29;
  size_t v30;
  unint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v29 = 0;
  v30 = 0;
  v31 = 16;
  if (a3)
  {
    v7 = a4;
    if (a4)
    {
      v8 = a3;
      do
      {
        v10 = *((_QWORD *)v8 + 1) & 0xFFFFFFFFFFFFFFFELL;
        v11 = *((_QWORD *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL;
        if (v10 != v11)
        {
          if (v10)
            v12 = v11 == 0;
          else
            v12 = 1;
          if (v12)
            break;
          v13 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v10 + 16))(v10);
          if (v13 != (*(unsigned int (**)(unint64_t))(*(_QWORD *)v11 + 16))(v11))
            break;
          v10 = *((_QWORD *)v8 + 1) & 0xFFFFFFFFFFFFFFFELL;
          v11 = *((_QWORD *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL;
        }
        v14 = (*(uint64_t (**)(unint64_t, const RB::DisplayList::Interpolator::State *, unint64_t, const RB::DisplayList::ClipNode **))(*(_QWORD *)v10 + 72))(v10, a2, v11, this);
        *(_QWORD *)(v14 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)this, *(const RB::DisplayList::Metadata **)((*((_QWORD *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL) + 32), *(_DWORD *)((*((_QWORD *)v7 + 1) & 0xFFFFFFFFFFFFFFFELL) + 40));
        *(_DWORD *)(v14 + 40) = v15;
        v16 = v30;
        v17 = v30 + 1;
        if (v31 < v30 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v17);
          v16 = v30;
          v17 = v30 + 1;
        }
        v18 = v29;
        if (!v29)
          v18 = __dst;
        *(_QWORD *)&v18[8 * v16] = v14;
        v30 = v17;
        v8 = *(const RB::DisplayList::ClipNode **)v8;
        if (!v8)
          break;
        v7 = *(const RB::DisplayList::ClipNode **)v7;
      }
      while (v7);
    }
  }
  if (a5)
    v19 = this[134];
  else
    v19 = 0;
  v27 = v19;
  if (!v30)
    goto LABEL_31;
  v20 = v30 - 1;
  do
  {
    v26 = 0;
    v21 = v29;
    if (!v29)
      v21 = __dst;
    v22 = *(const RB::DisplayList::Clip **)&v21[8 * v20];
    v26 = v22;
    v23 = *this;
    if (*((_BYTE *)*this + 272))
    {
      if ((RB::DisplayList::ClipNode::elide_append((uint64_t *)&v27, (float32x2_t *)v22) & 1) != 0)
      {
        (**(void (***)(const RB::DisplayList::Clip *))v26)(v26);
        goto LABEL_29;
      }
      v23 = *this;
      v22 = v26;
    }
    v24 = *((_QWORD *)v23 + 1);
    *((_QWORD *)v22 + 1) = *(_QWORD *)(v24 + 312);
    *(_QWORD *)(v24 + 312) = v22;
    v27 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(v24 + 16), &v26, &v27);
LABEL_29:
    --v20;
  }
  while (v20 != -1);
  v19 = v27;
LABEL_31:
  if (v29)
    free(v29);
  return v19;
}

void sub_209B7EF4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27)
    free(a27);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::CachedTransform::mix_clip_bounds(uint64_t a1, float32x2_t *a2, float32x2_t *a3, _QWORD *a4)
{
  uint64_t result;
  _QWORD *v6;
  float32x2_t *v7;
  unint64_t v9;
  unint64_t v10;
  int v12;
  float32x2_t v13;
  uint64_t v14;
  double v15;
  double v16;
  double v17;
  int32x4_t v18;
  uint32x2_t v19;
  _QWORD v20[2];
  float32x2_t v21;
  float32x2_t v22;

  *a2 = (float32x2_t)0x100000001000000;
  a2[1] = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  result = 1;
  if (a3)
  {
    v6 = a4;
    if (a4)
    {
      v7 = a3;
      while (1)
      {
        v9 = *(_QWORD *)&v7[1] & 0xFFFFFFFFFFFFFFFELL;
        v10 = v6[1] & 0xFFFFFFFFFFFFFFFELL;
        if (v9 != v10)
        {
          if (!v9 || v10 == 0)
            return 1;
          v12 = (*(uint64_t (**)(unint64_t))(*(_QWORD *)v9 + 16))(v9);
          if (v12 != (*(unsigned int (**)(unint64_t))(*(_QWORD *)v10 + 16))(v10))
            return 1;
        }
        v13 = v7[3];
        v21 = v7[2];
        v22 = v13;
        v14 = v6[3];
        v20[0] = v6[2];
        v20[1] = v14;
        if (((*(uint64_t (**)(unint64_t, uint64_t, float32x2_t *, _QWORD *, unint64_t))(*(_QWORD *)(*(_QWORD *)&v7[1] & 0xFFFFFFFFFFFFFFFELL) + 80))(*(_QWORD *)&v7[1] & 0xFFFFFFFFFFFFFFFELL, a1, &v21, v20, v6[1] & 0xFFFFFFFFFFFFFFFELL) & 1) == 0)break;
        RB::Rect::intersect(a2, v21, v22, v15, v16, v17, v18);
        v19 = (uint32x2_t)vclez_f32(a2[1]);
        if ((vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0)
          return 1;
        v7 = (float32x2_t *)*v7;
        result = 1;
        if (v7)
        {
          v6 = (_QWORD *)*v6;
          if (v6)
            continue;
        }
        return result;
      }
      return 0;
    }
  }
  return result;
}

uint64_t RB::DisplayList::can_mix(RB::DisplayList *this, RB::DisplayList::Interpolator::Contents *a2, uint64_t a3, const RB::DisplayList::Style *a4)
{
  const RB::DisplayList::Style *i;
  uint64_t v7;
  unsigned int v8;
  const RB::AffineTransform *v9;
  unsigned int can_mix;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  BOOL v14;
  const RB::DisplayList::Style *v15;
  unsigned int v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;

  for (i = a2; i; i = (const RB::DisplayList::Style *)*((_QWORD *)i + 4))
  {
    if ((*((_BYTE *)i + 52) & 1) == 0)
      break;
  }
  while (1)
  {
    if (!a3)
      goto LABEL_8;
    if ((*(_BYTE *)(a3 + 52) & 1) == 0)
      break;
    a3 = *(_QWORD *)(a3 + 32);
  }
  if (!i)
  {
LABEL_8:
    LODWORD(v7) = 4;
    while ((unint64_t)i | a3)
    {
      if (i)
      {
        v19 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, _QWORD, const RB::DisplayList::Style *))(*(_QWORD *)i + 80))(i, this, 0, a4);
        if (v19 >= v7)
          LODWORD(v7) = v7;
        else
          LODWORD(v7) = v19;
        do
          i = (const RB::DisplayList::Style *)*((_QWORD *)i + 4);
        while (i && (*((_BYTE *)i + 52) & 1) != 0);
      }
      if (a3)
      {
        v18 = (*(unsigned __int8 (**)(uint64_t, RB::DisplayList *, _QWORD, const RB::DisplayList::Style *))(*(_QWORD *)a3 + 80))(a3, this, 0, a4);
        if (v18 >= v7)
          LODWORD(v7) = v7;
        else
          LODWORD(v7) = v18;
        do
          a3 = *(_QWORD *)(a3 + 32);
        while (a3 && (*(_BYTE *)(a3 + 52) & 1) != 0);
      }
LABEL_67:
      if (!(_BYTE)v7)
      {
        LODWORD(v7) = 0;
        goto LABEL_85;
      }
    }
    a3 = 0;
    i = 0;
LABEL_85:
    if ((unint64_t)i | a3)
      return 0;
    else
      return v7;
  }
  v7 = 4;
  while (i != (const RB::DisplayList::Style *)a3)
  {
    if ((RB::same_identity_and_type<RB::DisplayList::Style>((uint64_t)i, a3) & 1) != 0)
    {
      v8 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, uint64_t))(*(_QWORD *)i + 80))(i, this, a3);
      if (v8 >= v7)
        v7 = v7;
      else
        v7 = v8;
      if ((_DWORD)v7)
      {
        can_mix = RB::DisplayList::can_mix((uint64_t)this, *((_QWORD **)i + 3), *(_QWORD **)(a3 + 24));
        v7 = can_mix >= v7 ? v7 : can_mix;
        if ((_DWORD)v7)
        {
          v11 = RB::can_mix(*((float64x2_t **)i + 2), *(float64x2_t **)(a3 + 16), v9);
          if (v11 >= v7)
            v7 = v7;
          else
            v7 = v11;
        }
      }
      do
        i = (const RB::DisplayList::Style *)*((_QWORD *)i + 4);
      while (i && (*((_BYTE *)i + 52) & 1) != 0);
      do
      {
        a3 = *(_QWORD *)(a3 + 32);
        if (!a3)
          goto LABEL_67;
      }
      while ((*(_BYTE *)(a3 + 52) & 1) != 0);
    }
    else
    {
      v12 = (uint64_t)i;
      if ((RB::same_identity_and_type<RB::DisplayList::Style>((uint64_t)i, a3) & 1) != 0)
      {
LABEL_30:
        if (i != (const RB::DisplayList::Style *)v12)
        {
          do
          {
            v13 = (*(unsigned __int8 (**)(const RB::DisplayList::Style *, RB::DisplayList *, _QWORD))(*(_QWORD *)i + 80))(i, this, 0);
            if (v13 >= v7)
              v7 = v7;
            else
              v7 = v13;
            do
              i = (const RB::DisplayList::Style *)*((_QWORD *)i + 4);
            while (i && (*((_BYTE *)i + 52) & 1) != 0);
            if ((_DWORD)v7)
              v14 = i == (const RB::DisplayList::Style *)v12;
            else
              v14 = 1;
          }
          while (!v14);
        }
      }
      else
      {
        while (1)
        {
          v12 = *(_QWORD *)(v12 + 32);
          if (!v12)
            break;
          if ((*(_BYTE *)(v12 + 52) & 1) == 0
            && RB::same_identity_and_type<RB::DisplayList::Style>(v12, a3))
          {
            goto LABEL_30;
          }
        }
        v15 = (const RB::DisplayList::Style *)a3;
        if ((RB::same_identity_and_type<RB::DisplayList::Style>(a3, (uint64_t)i) & 1) != 0)
        {
          v15 = (const RB::DisplayList::Style *)a3;
        }
        else
        {
          do
          {
            v15 = (const RB::DisplayList::Style *)*((_QWORD *)v15 + 4);
            if (!v15)
              goto LABEL_67;
          }
          while ((*((_BYTE *)v15 + 52) & 1) != 0
               || (RB::same_identity_and_type<RB::DisplayList::Style>((uint64_t)v15, (uint64_t)i) & 1) == 0);
        }
        if ((const RB::DisplayList::Style *)a3 != v15)
        {
          do
          {
            v16 = (*(unsigned __int8 (**)(uint64_t, RB::DisplayList *, _QWORD))(*(_QWORD *)a3 + 80))(a3, this, 0);
            if (v16 >= v7)
              v7 = v7;
            else
              v7 = v16;
            do
              a3 = *(_QWORD *)(a3 + 32);
            while (a3 && (*(_BYTE *)(a3 + 52) & 1) != 0);
            if ((_DWORD)v7)
              v17 = a3 == (_QWORD)v15;
            else
              v17 = 1;
          }
          while (!v17);
        }
      }
    }
    if (!(_BYTE)v7 || !i || !a3)
      goto LABEL_67;
  }
  return v7;
}

uint64_t RB::same_identity_and_type<RB::DisplayList::Style>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  int v5;

  result = RB::same_identity<RB::DisplayList::Style>(a1, a2);
  if ((_DWORD)result)
  {
    if (a1 == a2)
    {
      return 1;
    }
    else
    {
      result = 0;
      if (a1)
      {
        if (a2)
        {
          v5 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 16))(a1);
          return v5 == (*(unsigned int (**)(uint64_t))(*(_QWORD *)a2 + 16))(a2);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::CachedTransform *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::Style *a4, int a5)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const RB::AffineTransform *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  int v18;
  size_t v19;
  size_t v20;
  _BYTE *v21;
  uint64_t v22;
  uint64_t v23;
  RB::DisplayList::CachedTransform *v24;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  size_t v28;
  _QWORD *v29;
  __int128 v30;
  uint64_t v31;
  RB::DisplayList::CachedTransform *v32;
  int v33;
  _QWORD *v34;
  uint64_t v35;
  size_t v36;
  _QWORD *v37;
  BOOL v38;
  BOOL i;
  uint64_t v40;
  RB::DisplayList::CachedTransform *v41;
  int v42;
  _QWORD *v43;
  uint64_t v44;
  size_t v45;
  _QWORD *v46;
  __int128 v47;
  uint64_t v48;
  RB::DisplayList::CachedTransform *v49;
  int v50;
  _QWORD *v51;
  uint64_t v52;
  size_t v53;
  _QWORD *v54;
  uint64_t v55;
  void *v56;
  size_t v57;
  uint64_t v58;
  _BYTE *v59;
  uint64_t v60;
  _BYTE *v61;
  uint64_t v62;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  _QWORD v67[2];
  RB::DisplayList::CachedTransform *v68;
  BOOL v69;
  void *__dst;
  _BYTE v71[128];
  _BYTE *v72;
  size_t v73;
  unint64_t v74;
  uint64_t v75;

  v75 = *MEMORY[0x24BDAC8D0];
  v72 = 0;
  v73 = 0;
  v74 = 16;
  v69 = a5;
  __dst = v71;
  v67[0] = this;
  v67[1] = &v68;
  v68 = this;
  v9 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, (uint64_t)a3);
  v10 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, (uint64_t)a4);
  v11 = v10;
  if (v9 && v10)
  {
    while (1)
    {
      if (v9 != v11)
      {
        v12 = v9;
        if ((RB::same_identity_and_type<RB::DisplayList::Style>(v9, v11) & 1) == 0)
          break;
      }
      v14 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, uint64_t, RB::DisplayList::CachedTransform *))(*(_QWORD *)v9 + 88))(v9, a2, v11, this);
      if (v14)
      {
        RB::mix(*(CGAffineTransform **)(v9 + 16), *(float64x2_t **)(v11 + 16), v13, *((float *)a2 + 4));
        v64 = v15;
        v65 = v16;
        v66 = v17;
        *(_QWORD *)(v14 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, (const RB::AffineTransform *)&v64);
        *(_QWORD *)(v14 + 24) = RB::DisplayList::CachedTransform::mix_clip((const RB::DisplayList::ClipNode **)this, a2, *(const RB::DisplayList::ClipNode **)(v9 + 24), *(const RB::DisplayList::ClipNode **)(v11 + 24), a5);
        *(_QWORD *)(v14 + 40) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(v11 + 40), *(_DWORD *)(v11 + 48));
        *(_DWORD *)(v14 + 48) = v18;
        *(_DWORD *)(v14 + 52) = (*(_DWORD *)(v11 + 52) | *(_DWORD *)(v9 + 52)) & 1;
        v19 = v73;
        v20 = v73 + 1;
        if (v74 < v73 + 1)
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(v71, v20);
          v19 = v73;
          v20 = v73 + 1;
        }
        v21 = v72;
        if (!v72)
          v21 = v71;
        *(_QWORD *)&v21[8 * v19] = v14;
        v73 = v20;
      }
      v9 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v9 + 32));
      v11 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v11 + 32));
LABEL_12:
      if (!v9 || !v11)
        goto LABEL_41;
    }
    do
    {
      if (RB::same_identity_and_type<RB::DisplayList::Style>(v12, v11))
      {
        while (v9 != v12)
        {
          v23 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, _QWORD, RB::DisplayList::CachedTransform *))(*(_QWORD *)v9 + 88))(v9, a2, 0, this);
          if (v23)
          {
            v24 = v68;
            *(_QWORD *)(v23 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v68, *(const RB::AffineTransform **)(v9 + 16));
            *(_QWORD *)(v23 + 24) = RB::DisplayList::CachedTransform::transform_clip(v24, *(_QWORD *)(v9 + 24), v69);
            *(_QWORD *)(v23 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v24, *(const RB::DisplayList::Metadata **)(v9 + 40), *(_DWORD *)(v9 + 48));
            *(_DWORD *)(v23 + 48) = v25;
            *(_DWORD *)(v23 + 52) = *(_DWORD *)(v9 + 52) & 1;
            (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(_QWORD *)v23 + 32))(v23, v24, v69);
            v26 = __dst;
            v27 = *((_QWORD *)__dst + 17);
            v28 = v27 + 1;
            if (*((_QWORD *)__dst + 18) < (unint64_t)(v27 + 1))
            {
              _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v28);
              v27 = v26[17];
              v28 = v27 + 1;
            }
            v29 = (_QWORD *)v26[16];
            if (!v29)
              v29 = v26;
            v29[v27] = v23;
            v26[17] = v28;
          }
          v9 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v9 + 32));
        }
        v9 = v12;
        goto LABEL_12;
      }
      v12 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v12 + 32));
    }
    while (v12);
    v22 = v11;
    while ((RB::same_identity_and_type<RB::DisplayList::Style>(v22, v9) & 1) == 0)
    {
      v22 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v22 + 32));
      if (!v22)
        goto LABEL_41;
    }
    if (v22)
    {
      v30 = *((_OWORD *)a2 + 1);
      v64 = *(_OWORD *)a2;
      v65 = v30;
      *(_QWORD *)&v66 = *((_QWORD *)a2 + 4);
      *(float *)&v65 = 1.0 - *(float *)&v30;
      BYTE12(v65) = BYTE12(v30) ^ 1;
      while (v11 != v22)
      {
        v31 = (*(uint64_t (**)(uint64_t, __int128 *, _QWORD, RB::DisplayList::CachedTransform *))(*(_QWORD *)v11 + 88))(v11, &v64, 0, this);
        if (v31)
        {
          v32 = v68;
          *(_QWORD *)(v31 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v68, *(const RB::AffineTransform **)(v11 + 16));
          *(_QWORD *)(v31 + 24) = RB::DisplayList::CachedTransform::transform_clip(v32, *(_QWORD *)(v11 + 24), v69);
          *(_QWORD *)(v31 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v32, *(const RB::DisplayList::Metadata **)(v11 + 40), *(_DWORD *)(v11 + 48));
          *(_DWORD *)(v31 + 48) = v33;
          *(_DWORD *)(v31 + 52) = *(_DWORD *)(v11 + 52) & 1;
          (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(_QWORD *)v31 + 32))(v31, v32, v69);
          v34 = __dst;
          v35 = *((_QWORD *)__dst + 17);
          v36 = v35 + 1;
          if (*((_QWORD *)__dst + 18) < (unint64_t)(v35 + 1))
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v36);
            v35 = v34[17];
            v36 = v35 + 1;
          }
          v37 = (_QWORD *)v34[16];
          if (!v37)
            v37 = v34;
          v37[v35] = v31;
          v34[17] = v36;
        }
        v11 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v11 + 32));
      }
      v11 = v22;
      goto LABEL_12;
    }
  }
LABEL_41:
  v38 = v9 != 0;
  for (i = v11 != 0; v9 | v11; i = v11 != 0)
  {
    if (v38)
    {
      v40 = (*(uint64_t (**)(uint64_t, const RB::DisplayList::Interpolator::State *, _QWORD, RB::DisplayList::CachedTransform *))(*(_QWORD *)v9 + 88))(v9, a2, 0, this);
      if (v40)
      {
        v41 = v68;
        *(_QWORD *)(v40 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v68, *(const RB::AffineTransform **)(v9 + 16));
        *(_QWORD *)(v40 + 24) = RB::DisplayList::CachedTransform::transform_clip(v41, *(_QWORD *)(v9 + 24), v69);
        *(_QWORD *)(v40 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v41, *(const RB::DisplayList::Metadata **)(v9 + 40), *(_DWORD *)(v9 + 48));
        *(_DWORD *)(v40 + 48) = v42;
        *(_DWORD *)(v40 + 52) = *(_DWORD *)(v9 + 52) & 1;
        (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(_QWORD *)v40 + 32))(v40, v41, v69);
        v43 = __dst;
        v44 = *((_QWORD *)__dst + 17);
        v45 = v44 + 1;
        if (*((_QWORD *)__dst + 18) < (unint64_t)(v44 + 1))
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v45);
          v44 = v43[17];
          v45 = v44 + 1;
        }
        v46 = (_QWORD *)v43[16];
        if (!v46)
          v46 = v43;
        v46[v44] = v40;
        v43[17] = v45;
      }
      v9 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v9 + 32));
      if (i)
      {
LABEL_52:
        v47 = *((_OWORD *)a2 + 1);
        v64 = *(_OWORD *)a2;
        v65 = v47;
        *(_QWORD *)&v66 = *((_QWORD *)a2 + 4);
        *(float *)&v65 = 1.0 - *(float *)&v47;
        BYTE12(v65) = BYTE12(v47) ^ 1;
        v48 = (*(uint64_t (**)(uint64_t, __int128 *, _QWORD, RB::DisplayList::CachedTransform *))(*(_QWORD *)v11 + 88))(v11, &v64, 0, this);
        if (v48)
        {
          v49 = v68;
          *(_QWORD *)(v48 + 16) = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)v68, *(const RB::AffineTransform **)(v11 + 16));
          *(_QWORD *)(v48 + 24) = RB::DisplayList::CachedTransform::transform_clip(v49, *(_QWORD *)(v11 + 24), v69);
          *(_QWORD *)(v48 + 40) = RB::DisplayList::CachedTransform::transform_metadata(v49, *(const RB::DisplayList::Metadata **)(v11 + 40), *(_DWORD *)(v11 + 48));
          *(_DWORD *)(v48 + 48) = v50;
          *(_DWORD *)(v48 + 52) = *(_DWORD *)(v11 + 52) & 1;
          (*(void (**)(uint64_t, RB::DisplayList::CachedTransform *, BOOL))(*(_QWORD *)v48 + 32))(v48, v49, v69);
          v51 = __dst;
          v52 = *((_QWORD *)__dst + 17);
          v53 = v52 + 1;
          if (*((_QWORD *)__dst + 18) < (unint64_t)(v52 + 1))
          {
            _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v53);
            v52 = v51[17];
            v53 = v52 + 1;
          }
          v54 = (_QWORD *)v51[16];
          if (!v54)
            v54 = v51;
          v54[v52] = v48;
          v51[17] = v53;
        }
        v11 = RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(v67, *(_QWORD *)(v11 + 32));
        goto LABEL_59;
      }
    }
    else
    {
      v9 = 0;
      if (i)
        goto LABEL_52;
    }
    v11 = 0;
LABEL_59:
    v38 = v9 != 0;
  }
  if (a5)
    v55 = *((_QWORD *)this + 135);
  else
    v55 = 0;
  v56 = v72;
  v57 = v73;
  if (v73)
  {
    v58 = *(_QWORD *)(*(_QWORD *)this + 8);
    v59 = v71;
    if (v72)
      v59 = v72;
    v60 = *(_QWORD *)(v58 + 312);
    v61 = v59 - 8;
    do
    {
      v62 = *(_QWORD *)&v61[8 * v57];
      *(_QWORD *)(v62 + 8) = v60;
      *(_QWORD *)(v58 + 312) = v62;
      *(_QWORD *)(*(_QWORD *)&v61[8 * v57] + 32) = v55;
      v55 = *(_QWORD *)&v61[8 * v57];
      v60 = v62;
      --v57;
    }
    while (v57);
  }
  if (v56)
    free(v56);
  return v55;
}

void sub_209B7FAA8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  if (a37)
    free(a37);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::CachedTransform::mix_style(RB::DisplayList::Interpolator::State const&,RB::DisplayList::Style const*,RB::DisplayList::Style const*,BOOL)const::$_1::operator()(_QWORD *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float64x2_t *v8;
  int v9;
  _QWORD *v10;
  uint64_t v11;
  size_t v12;
  _QWORD *v13;

  v2 = a2;
  if (a2)
  {
    v4 = (_QWORD *)*a1;
    do
    {
      if ((*(_BYTE *)(v2 + 52) & 1) == 0)
        break;
      v5 = a1[1];
      v6 = (*(uint64_t (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 24))(v2, *v4);
      if (v6)
      {
        v7 = v6;
        v8 = *(float64x2_t **)v5;
        *(_QWORD *)(v6 + 16) = RB::DisplayList::CachedTransform::transform_ctm(*(float64x2_t **)v5, *(const RB::AffineTransform **)(v2 + 16));
        *(_QWORD *)(v7 + 24) = RB::DisplayList::CachedTransform::transform_clip((RB::DisplayList::CachedTransform *)v8, *(_QWORD *)(v2 + 24), *(unsigned __int8 *)(v5 + 8));
        *(_QWORD *)(v7 + 40) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)v8, *(const RB::DisplayList::Metadata **)(v2 + 40), *(_DWORD *)(v2 + 48));
        *(_DWORD *)(v7 + 48) = v9;
        *(_DWORD *)(v7 + 52) = *(_DWORD *)(v2 + 52) & 1;
        (*(void (**)(uint64_t, float64x2_t *, _QWORD))(*(_QWORD *)v7 + 32))(v7, v8, *(unsigned __int8 *)(v5 + 8));
        v10 = *(_QWORD **)(v5 + 16);
        v11 = v10[17];
        v12 = v11 + 1;
        if (v10[18] < (unint64_t)(v11 + 1))
        {
          _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(*(void **)(v5 + 16), v12);
          v11 = v10[17];
          v12 = v11 + 1;
        }
        v13 = (_QWORD *)v10[16];
        if (!v13)
          v13 = v10;
        v13[v11] = v7;
        v10[17] = v12;
      }
      v2 = *(_QWORD *)(v2 + 32);
    }
    while (v2);
  }
  return v2;
}

uint64_t RB::DisplayList::Builder::append(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3)
{
  unsigned int v5;
  int v11;
  int v12;
  _BOOL4 v13;
  uint64_t v15;

  v5 = *((unsigned __int16 *)a3 + 23);
  if (((v5 >> 6) & 7) != 0)
  {
    _H0 = *((_WORD *)a3 + 22);
    __asm { FCVT            S0, H0 }
    if (((_S0 != 1.0) & (v5 >> 6)) != 0)
    {
      v11 = 1;
    }
    else
    {
      v12 = v5 & 0x3F;
      v13 = v12 != 2;
      if (v12 == 24)
        v13 = 0;
      _ZF = v12 == 2 || v12 == 24;
      v11 = (v5 >> 7) & 1;
      if (_ZF)
        v11 = v13;
    }
    v15 = *((_QWORD *)a3 + 3);
    if (v15 && (*(_BYTE *)(v15 + 8) & 1) == 0)
    {
      if (((v11 | ((unsigned __int16)(v5 & 0x100) >> 8)) & 1) == 0)
        return RB::DisplayList::Layer::append(a2, this, a3);
      goto LABEL_16;
    }
    if (v11)
LABEL_16:
      a3 = RB::DisplayList::Builder::ensure_layer(this, a3, 0.0, 4);
  }
  return RB::DisplayList::Layer::append(a2, this, a3);
}

RB::DisplayList::Item *RB::DisplayList::Builder::ensure_layer(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, float a3, int a4)
{
  float v5;
  unsigned int v8;
  float v9;
  float v10;
  unsigned int v11;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  size_t *v18;
  uint64_t v19;
  int v20;
  __int128 v21;
  BOOL v22;
  size_t *v23;
  uint64_t v24;
  uint64_t v25;
  float v27;
  float v28;
  __int128 v29;
  float v30;
  RB::DisplayList::Layer *v31;
  __int128 v32;
  __int128 v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD v39[15];

  v5 = a3;
  v39[14] = *MEMORY[0x24BDAC8D0];
  v8 = (2 * a4) & 0x20 | a4;
  if (a3 == 0.0)
  {
    v10 = a3;
  }
  else
  {
    (*(void (**)(RB::DisplayList::Item *))(*(_QWORD *)a2 + 152))(a2);
    if ((a4 & 1) != 0)
    {
      v11 = 0;
      do
      {
        v10 = v5;
        v5 = v5 + v5;
      }
      while (v5 <= v9 && v11++ < 3);
    }
    else if (v9 <= v5)
    {
      v10 = v5;
    }
    else
    {
      v10 = v9;
    }
  }
  if ((*((_WORD *)a2 + 23) & 0x200) == 0)
    goto LABEL_14;
  v14 = *((_QWORD *)a2 + 6);
  if ((a4 & 0x84) == 0 && *((_QWORD *)a2 + 3))
    goto LABEL_23;
  if (*(_BYTE *)(v14 + 64) && (*(_BYTE *)(v14 + 64) != 1 || (a4 & 2) == 0))
    goto LABEL_23;
  v15 = *(_DWORD *)(v14 + 60);
  if ((v15 & 6) != 0 || ((a4 | (v8 >> 2)) & 8) == 0 && (v15 & 8) != 0)
    goto LABEL_23;
  if (v10 != 0.0)
  {
    v27 = *(float *)(v14 + 48);
    if (v27 == 0.0)
      v27 = 1.0;
    if (v10 != v27)
    {
      v28 = fminf(v10 / v27, 1.0);
      *(_QWORD *)&v29 = 0;
      *((double *)&v29 + 1) = v28;
      v32 = COERCE_UNSIGNED_INT64(v28);
      v33 = v29;
      v34 = 0;
      v35 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v36, (uint64_t)this, &v32, 0, 0, 0);
      RB::DisplayList::Layer::apply_transform_((RB::DisplayList::Layer *)v14, (const RB::DisplayList::CachedTransform *)&v36);
      RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)&v36);
      v30 = *(float *)(v14 + 48);
      if (v30 == 0.0)
        v30 = 1.0;
      *(float *)(v14 + 48) = v30 * v28;
    }
  }
  if ((a4 & 1) != 0)
  {
    *(_DWORD *)(v14 + 60) |= 0x200u;
    if ((a4 & 0x40) == 0)
    {
LABEL_53:
      if ((v8 & 0x20) == 0)
        goto LABEL_58;
      goto LABEL_57;
    }
  }
  else if ((a4 & 0x40) == 0)
  {
    goto LABEL_53;
  }
  *(_DWORD *)(v14 + 60) |= 0x40u;
  if ((v8 & 0x20) != 0)
LABEL_57:
    RB::DisplayList::Layer::discard_color(v14);
LABEL_58:
  if ((a4 & 0x10) == 0 || (*(_BYTE *)(v14 + 60) & 8) != 0)
    return a2;
LABEL_23:
  if ((*(_WORD *)(v14 + 60) & 0x2001) == 0 && (*((_WORD *)a2 + 23) & 0x400) == 0)
  {
LABEL_14:
    v13 = 0;
    goto LABEL_26;
  }
  v13 = *(unsigned __int8 *)(v14 + 67) + 1;
LABEL_26:
  v16 = 0;
  v17 = *((_QWORD *)a2 + 2);
  *((_QWORD *)a2 + 2) = 0;
  if ((a4 & 4) != 0)
  {
    v16 = *((_QWORD *)a2 + 3);
    *((_QWORD *)a2 + 3) = 0;
  }
  v36 = 0;
  v18 = (size_t *)(*((_QWORD *)this + 1) + 16);
  ++*((_DWORD *)this + 1);
  v19 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(v18, (int *)this + 1, &v36);
  v31 = (RB::DisplayList::Layer *)v19;
  if ((a4 & 1) == 0)
  {
    if ((a4 & 0x40) == 0)
      goto LABEL_30;
LABEL_33:
    *(_DWORD *)(v19 + 60) |= 0x40u;
    if (v13)
      goto LABEL_31;
    goto LABEL_34;
  }
  *(_DWORD *)(v19 + 60) |= 0x200u;
  if ((a4 & 0x40) != 0)
    goto LABEL_33;
LABEL_30:
  if (v13)
  {
LABEL_31:
    *(_DWORD *)(v19 + 60) |= 0x2000u;
    *(_BYTE *)(v19 + 67) = v13 - 1;
    v20 = 1;
    goto LABEL_37;
  }
LABEL_34:
  if (v10 == 0.0 || v10 == 1.0)
    goto LABEL_38;
  v20 = 0;
LABEL_37:
  *(float *)(v19 + 48) = v10;
  *(_QWORD *)&v21 = 0;
  *((double *)&v21 + 1) = v10;
  v32 = COERCE_UNSIGNED_INT64(v10);
  v33 = v21;
  v34 = 0;
  v35 = 0;
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v36, (uint64_t)this, &v32, 0, 0, v20);
  (*(void (**)(RB::DisplayList::Item *, int *, _QWORD))(*(_QWORD *)a2 + 32))(a2, &v36, 0);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v39);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v38);
  RB::Heap::~Heap((RB::Heap *)&v37);
LABEL_38:
  v22 = (a4 & 4) == 0;
  v23 = (size_t *)(*((_QWORD *)this + 1) + 16);
  v36 = *((_WORD *)a2 + 23) & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v23, (__int16 *)a2 + 22, &v36, (uint64_t *)&v31);
  v25 = v24;
  *(_QWORD *)(v24 + 32) = *((_QWORD *)a2 + 4);
  *(_DWORD *)(v24 + 40) = *((_DWORD *)a2 + 10);
  *(_QWORD *)(v24 + 16) = v17;
  if (!v22)
    *(_QWORD *)(v24 + 24) = v16;
  if ((v8 & 0x20) != 0)
    RB::DisplayList::Layer::discard_color((uint64_t)v31);
  *((_WORD *)a2 + 22) = 15360;
  *((_WORD *)a2 + 23) = *((_WORD *)a2 + 23) & 0xFFC0 | 2;
  *((_QWORD *)a2 + 4) = 0;
  *((_DWORD *)a2 + 10) = 0;
  RB::DisplayList::Layer::append(v31, this, a2);
  return (RB::DisplayList::Item *)v25;
}

void sub_209B8006C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Item *RB::DisplayList::Builder::apply_filter_(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::LayerFilter *a3, float64x2_t *a4, const RB::DisplayList::ClipNode *a5)
{
  int v10;
  _WORD *v11;
  _WORD *v12;
  int v13;
  float v14;
  int v15;
  float v16;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  double v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  __int128 v32[3];
  _BYTE v33[8];
  uint64_t v34;
  uint64_t v35;
  _QWORD v36[15];

  v36[14] = *MEMORY[0x24BDAC8D0];
  v10 = (*(uint64_t (**)(RB::DisplayList::LayerFilter *))(*(_QWORD *)a3 + 40))(a3);
  v12 = v11;
  if ((*(unsigned int (**)(RB::DisplayList::LayerFilter *))(*(_QWORD *)a3 + 64))(a3))
    v13 = 128;
  else
    v13 = 0;
  if (v10 == 5)
  {
    if (!*((_QWORD *)v12 + 4))
    {
      v15 = *((_DWORD *)v12 + 6);
      if ((v15 & 7) == 0)
      {
        if (((*(uint64_t (**)(RB::DisplayList::Item *, float64x2_t *, float))(*(_QWORD *)a2 + 112))(a2, a4, *(float *)v12) & 1) != 0)
        {
LABEL_25:
          *((_QWORD *)a2 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((_QWORD **)a2 + 3), a5);
          return a2;
        }
        v15 = *((_DWORD *)v12 + 6);
      }
      v13 |= (8 * v15) & 0x40 | 1;
    }
    v13 |= 8u;
    v16 = RB::AffineTransform::scale(a4);
    v14 = RB::Filter::GaussianBlur::layer_scale((RB::Filter::GaussianBlur *)v12, v16);
  }
  else
  {
    v14 = 0.0;
    if (v10 == 1)
    {
      if (RB::ColorMatrix::is_alpha_zero((RB::ColorMatrix *)(v12 + 4))
        && RB::may_discard_alpha(*((_WORD *)a2 + 23) & 0x3F))
      {
        (**(void (***)(RB::DisplayList::Item *))a2)(a2);
        return 0;
      }
      _H0 = v12[23];
      __asm { FCVT            S0, H0 }
      if (_S0 == 0.0)
      {
        v23 = (*(_DWORD *)v12 & 1) != 0 ? 256 : ((*(_DWORD *)v12 & 2) << 7) | (*(_DWORD *)v12 >> 1) & 1u;
        if ((*(unsigned int (**)(RB::DisplayList::Item *, _WORD *, _QWORD, uint64_t))(*(_QWORD *)a2 + 96))(a2, v12 + 4, (*(_DWORD *)v12 >> 2) & 1, v23)&& RB::may_discard_alpha(*((_WORD *)a2 + 23) & 0x3F))
        {
          if ((*(_DWORD *)v12 & 1) != 0)
            v24 = 256;
          else
            v24 = ((*(_DWORD *)v12 & 2) << 7) | (*(_DWORD *)v12 >> 1) & 1u;
          (*(void (**)(RB::DisplayList::Item *, _WORD *, _QWORD, uint64_t, RB::DisplayList::Builder *))(*(_QWORD *)a2 + 104))(a2, v12 + 4, (*(_DWORD *)v12 >> 2) & 1, v24, this);
          goto LABEL_25;
        }
      }
    }
  }
  a2 = RB::DisplayList::Builder::ensure_layer(this, a2, v14, v13);
  *((_QWORD *)a2 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((_QWORD **)a2 + 3), a5);
  v25 = *((_QWORD *)a2 + 6);
  v26 = *(float *)(v25 + 48);
  if (v26 == 0.0)
    v26 = 1.0;
  v27 = v26;
  v28 = vmulq_n_f64(*a4, v27);
  v29 = vmulq_n_f64(a4[1], v27);
  v30 = vmulq_n_f64(a4[2], v27);
  v32[0] = (__int128)v28;
  v32[1] = (__int128)v29;
  v32[2] = (__int128)v30;
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v33, (uint64_t)this, v32, 0, 0, 0);
  (*(void (**)(RB::DisplayList::LayerFilter *, _BYTE *))(*(_QWORD *)a3 + 24))(a3, v33);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v36);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v35);
  RB::Heap::~Heap((RB::Heap *)&v34);
  RB::DisplayList::Layer::append_filter(v25, a3);
  return a2;
}

void sub_209B80358(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Item *RB::DisplayList::Builder::apply_color_matrix(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, const RB::ColorMatrix *a3, int a4, float64x2_t *a5, const RB::DisplayList::ClipNode *a6)
{
  __int128 v12;
  RB::DisplayList::LayerFilter *v13;
  int v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;

  if ((RB::ColorMatrix::is_identity((float16x4_t *)a3) & 1) == 0)
  {
    v15 = a4;
    v12 = *((_OWORD *)a3 + 1);
    v16 = *(_OWORD *)a3;
    v17 = v12;
    v18 = *((_QWORD *)a3 + 4);
    RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix const&,RB::DisplayList::Builder &>((RB::Heap *)(*((_QWORD *)this + 1) + 16), (uint64_t)&v15);
    return RB::DisplayList::Builder::apply_filter_(this, a2, v13, a5, a6);
  }
  return a2;
}

void RB::DisplayList::Builder::draw(RB::DisplayList::Builder *this, const RB::DisplayList::Contents *a2, RB::DisplayList::State *a3, float a4, const RB::DisplayList::InvertiblePredicate *a5, void *a6)
{
  unsigned __int8 v12;
  uint64_t v13;
  int v14;
  std::string *v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  int v19;
  uint64_t v20;
  uint32x2_t v21;
  float32x2_t *v22;
  _BOOL4 v23;
  uint64_t v24;
  double v25;
  float32x2_t v26;
  double v27;
  double v28;
  double v29;
  int32x4_t v30;
  _QWORD *v31;
  unsigned __int16 v32;
  RB::DisplayList::Item *v34;
  uint64_t v35;
  unsigned int v36;
  std::string __p[2];
  uint64_t v38;
  void *v39;
  _QWORD v40[139];
  int v41;
  uint64_t v42;
  uint64_t v43;
  const RB::DisplayList::InvertiblePredicate *v44;
  char v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if ((v12 & 1) == 0
  {
    v35 = RB::debug_int((RB *)"RB_PRINT_TREE", (const char *)a2);
    v36 = (v35 >> 1) & 1;
    if ((v35 & 0xFF00000000) == 0)
      LOBYTE(v36) = 0;
    RB::DisplayList::Builder::draw(RB::DisplayList::Contents const&,RB::DisplayList::State &,float,RB::DisplayList::InvertiblePredicate const*,void *)::print_tree = v36;
  }
  if (RB::DisplayList::Builder::draw(RB::DisplayList::Contents const&,RB::DisplayList::State &,float,RB::DisplayList::InvertiblePredicate const*,void *)::print_tree)
  {
    memset(__p, 0, 41);
    RB::SexpString::push(__p, "draw");
    if (a5)
    {
      RB::SexpString::push(__p, "predicate");
      RB::XML::Document::Document((RB::XML::Document *)&v38);
      RB::DisplayList::Predicate::xml_elements((uint64_t)a5, (RB::XML::Document *)&v38);
      RB::XML::Document::print_children((RB::XML::Document *)&v38, __p, 0);
      RB::SexpString::pop(__p);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v40);
      if (v39)
        free(v39);
      v13 = v38;
      if (v38)
      {
        v14 = *(_DWORD *)(v38 + 8) - 1;
        *(_DWORD *)(v38 + 8) = v14;
        if (!v14)
          (*(void (**)(uint64_t))(*(_QWORD *)v13 + 8))(v13);
      }
    }
    RB::DisplayList::Contents::print(a2, __p);
    RB::SexpString::pop(__p);
    RB::SexpString::newline(__p);
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v15 = __p;
    else
      v15 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
    fputs((const char *)v15, (FILE *)*MEMORY[0x24BDAC8D8]);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (!*((_QWORD *)this + 1))
    RB::DisplayList::Builder::reset_contents(this);
  v16 = *((_QWORD *)this + 4);
  if (!v16 || *(_DWORD *)(*(_QWORD *)v16 + 56) != *((_DWORD *)a3 + 36))
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v38, (uint64_t)this, (__int128 *)a3 + 1, *((_QWORD *)a3 + 12), *((_QWORD *)a3 + 13), 0);
  if (*((_BYTE *)this + 272))
  {
    v44 = a5;
  }
  else
  {
    v17 = RB::DisplayList::State::copy_metadata(a3, *((RB::DisplayList::Contents **)this + 1));
    v18 = *((_DWORD *)a3 + 16);
    v40[138] = v17;
    v41 = v18;
    v19 = *((unsigned __int8 *)this + 272);
    v44 = a5;
    if (!v19)
    {
      v22 = 0;
LABEL_27:
      v23 = 0;
      goto LABEL_28;
    }
  }
  v20 = RB::DisplayList::Builder::crop_bounds(this, a3);
  v21 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)(v20 + 8) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if (vpmax_u32(v21, v21).i32[0] >= 0)
    v22 = (float32x2_t *)v20;
  else
    v22 = 0;
  if (!*((_BYTE *)this + 272))
    goto LABEL_27;
  v23 = *((_BYTE *)a2 + 400) != 0;
LABEL_28:
  v24 = *((_QWORD *)a2 + 40);
  if (v24 && (void *)v24 != a6)
  {
    while (1)
    {
      if (v23 && ((*(uint64_t (**)(uint64_t))(*(_QWORD *)v24 + 160))(v24) & 1) != 0)
        goto LABEL_47;
      if (v22)
      {
        v25 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v24);
        if (!RB::Rect::intersects(v22, *(float32x2_t *)&v25, v26, v27, v28, v29, v30))
          goto LABEL_47;
      }
      v45 = 0;
      if (!a5
        || (((*(unsigned int (**)(uint64_t, const RB::DisplayList::InvertiblePredicate *))(*(_QWORD *)v24 + 192))(v24, a5) ^ (*((_BYTE *)a5 + 40) != 0)) & 1) != 0)
      {
        goto LABEL_46;
      }
      v31 = *(_QWORD **)(v24 + 16);
      if (v31)
        break;
LABEL_43:
      if (v45)
        goto LABEL_46;
LABEL_47:
      v24 = *(_QWORD *)(v24 + 8);
      if (!v24 || (void *)v24 == a6)
        goto LABEL_49;
    }
    while (1)
    {
      v32 = (*(uint64_t (**)(_QWORD *, const RB::DisplayList::InvertiblePredicate *))(*v31 + 64))(v31, a5);
      if (v32 >= 0x100u && !(*((_BYTE *)a5 + 40) ? v32 != 0 : v32 == 0))
        break;
      v31 = (_QWORD *)v31[4];
      if (!v31)
        goto LABEL_43;
    }
    v45 = 1;
LABEL_46:
    v34 = (RB::DisplayList::Item *)(*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, _QWORD))(*(_QWORD *)v24 + 24))(v24, this, 0);
    RB::DisplayList::Item::apply_alpha((uint64_t)v34, a4);
    (*(void (**)(RB::DisplayList::Item *, uint64_t *, uint64_t))(*(_QWORD *)v34 + 32))(v34, &v38, 1);
    RB::DisplayList::Builder::draw(this, v34, **((RB::DisplayList::Layer ***)this + 4), 0);
    goto LABEL_47;
  }
LABEL_49:
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v43);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v42);
  RB::Heap::~Heap((RB::Heap *)&v39);
}

void sub_209B80810(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18)
{
  _Unwind_Resume(a1);
}

void RB::XML::Document::~Document(RB::XML::Document *this)
{
  void *v2;
  _DWORD *v3;
  int v4;

  RB::UntypedTable::~UntypedTable((RB::XML::Document *)((char *)this + 32));
  v2 = (void *)*((_QWORD *)this + 1);
  if (v2)
    free(v2);
  v3 = *(_DWORD **)this;
  if (*(_QWORD *)this)
  {
    v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4)
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
  }
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::Layer *a3, char a4)
{
  RB::DisplayList::Builder *v6;
  uint64_t v7;

  if (a2)
  {
    v6 = this;
    if (*((_BYTE *)this + 272))
    {
      v7 = *((_QWORD *)a2 + 2);
      if (v7)
      {
        *((_QWORD *)a2 + 2) = 0;
        return (RB::DisplayList::Builder *)(*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, RB::DisplayList::Layer *))(*(_QWORD *)v7 + 40))(v7, v6, a3);
      }
      else
      {
        return (RB::DisplayList::Builder *)RB::DisplayList::Builder::null_style_draw(v6, a2, a3, a4);
      }
    }
    else
    {
      return (RB::DisplayList::Builder *)RB::DisplayList::Builder::append(this, a3, a2);
    }
  }
  return this;
}

void RB::DisplayList::Builder::draw_interpolated(RB::DisplayList::Layer ***this, RB::DisplayList::State *a2, const RB::DisplayList::Interpolator::Layer *a3, float32_t a4, float a5, const RB::DisplayList::Contents *a6, const RB::DisplayList::Contents *a7, const RB::AffineTransform *a8)
{
  RB::DisplayList::Layer **v16;
  double v17;
  float32x2_t v18;
  unsigned int v19;
  RB::DisplayList::Layer *v20;
  uint64_t v21;
  uint32x2_t v22;
  float32x2_t *v23;
  const RB::Rect *v24;
  const RB::DisplayList::Item *v25;
  const RB::AffineTransform *v26;
  float64x2_t v27[80];
  uint64_t v28;
  _QWORD v29[15];

  v29[14] = *MEMORY[0x24BDAC8D0];
  if (!this[1])
    RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)this);
  v16 = this[4];
  if (!v16 || *((_DWORD *)*v16 + 14) != *((_DWORD *)a2 + 36))
    RB::precondition_failure((RB *)"current layer doesn't match drawing state", (const char *)a2);
  RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v27, (uint64_t)this, (__int128 *)a2 + 1, *((_QWORD *)a2 + 12), *((_QWORD *)a2 + 13), 0);
  v19 = *(_DWORD *)(*(_QWORD *)a3 + 16);
  v20 = *this[4];
  if (!*((_BYTE *)this + 272))
  {
    v23 = 0;
    if (a6)
      goto LABEL_10;
LABEL_13:
    v24 = 0;
    if (a7)
      goto LABEL_11;
LABEL_14:
    v25 = 0;
    goto LABEL_15;
  }
  v21 = RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)this, a2);
  v18 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  v22 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)(v21 + 8) & 0x7FFFFFFF7FFFFFFFLL), v18);
  v17 = COERCE_DOUBLE(vpmax_u32(v22, v22));
  if (SLODWORD(v17) >= 0)
    v23 = (float32x2_t *)v21;
  else
    v23 = 0;
  if (!a6)
    goto LABEL_13;
LABEL_10:
  v24 = (const RB::Rect *)*((_QWORD *)a6 + 40);
  if (!a7)
    goto LABEL_14;
LABEL_11:
  v25 = (const RB::DisplayList::Item *)*((_QWORD *)a7 + 40);
LABEL_15:
  *(float *)&v17 = a5;
  v18.f32[0] = a4;
  RB::DisplayList::apply_interpolator(a3, 0, v17, v19, v20, v27, *(double *)&v18, v23, v24, v25, a8, v26);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v29);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v28);
  RB::Heap::~Heap((RB::Heap *)&v27[0].f64[1]);
}

void sub_209B80AC0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11)
{
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::Builder::null_style_draw(RB::DisplayList::Builder *this, RB::DisplayList::Item *a2, RB::DisplayList::Layer *a3, char a4)
{
  __int16 v7;
  uint64_t v9;
  int v10;
  float v17;
  unsigned int v20;
  int v22;
  int may_discard_alpha;
  uint64_t v24;
  uint64_t v25;
  const RB::DisplayList::ClipNode *v28;
  const RB::DisplayList::ClipNode *v30;
  RB::DisplayList::Item *v31;
  uint64_t v32;
  const RB::DisplayList::ClipNode *v33;
  uint64_t v34;
  int v35;
  char v36;
  _QWORD *i;
  uint32x2_t v38;
  _QWORD *v39;
  float16x4_t *v40;
  float16x4_t *v41;
  int v42;
  size_t *v43;
  uint64_t v44;
  RB::DisplayList::Item *v45;
  _QWORD *v46;
  const RB::DisplayList::ClipNode *v47;
  const RB::DisplayList::ClipNode *v48;
  float16x4_t *v51;
  float32x2_t v52;
  int v53;

  v7 = *((_WORD *)a2 + 23);
  if ((v7 & 0x200) == 0 || !*((_BYTE *)this + 272))
    return RB::DisplayList::Builder::append(this, a3, a2);
  v9 = *((_QWORD *)a2 + 6);
  v10 = *(_DWORD *)(v9 + 60);
  if ((v10 & 0x800) != 0)
  {
    if ((v7 & 0x3F) == 0x18 && !*(_QWORD *)(v9 + 16) && !*(_BYTE *)(v9 + 64) && *(float *)(v9 + 48) == 0.0)
    {
      v45 = *(RB::DisplayList::Item **)v9;
      if (*(_QWORD *)v9)
      {
        v46 = 0;
        v47 = (const RB::DisplayList::ClipNode *)*((_QWORD *)a2 + 3);
        v48 = v47;
        do
        {
          *(_QWORD *)v9 = *((_QWORD *)v45 + 1);
          _H0 = *((_WORD *)a2 + 22);
          __asm { FCVT            S0, H0; float }
          RB::DisplayList::Item::apply_alpha((uint64_t)v45, _S0);
          if (v46 != *((_QWORD **)v45 + 3))
          {
            v46 = (_QWORD *)*((_QWORD *)v45 + 3);
            v48 = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, v46, v47);
          }
          *((_QWORD *)v45 + 3) = v48;
          RB::DisplayList::Builder::append(this, a3, v45);
          v45 = *(RB::DisplayList::Item **)v9;
        }
        while (*(_QWORD *)v9);
      }
      return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
    }
    *(_DWORD *)(v9 + 60) = v10 & 0xFFFFF7FF;
    v7 = *((_WORD *)a2 + 23);
    if ((v7 & 0x3F) == 0x18)
    {
      v7 = v7 & 0xFFC0 | 2;
      *((_WORD *)a2 + 23) = v7;
    }
  }
  if (*(_QWORD *)v9)
  {
    RB::DisplayList::Builder::lower_color_filters(this, (RB::DisplayList::Layer *)v9, 1);
    _H1 = *((_WORD *)a2 + 22);
    __asm { FCVT            S1, H1 }
    _S0 = v17 * _S1;
    __asm { FCVT            H0, S0 }
    *((_WORD *)a2 + 22) = _H0;
    v20 = *((_WORD *)a2 + 23) & 0x3F;
    if ((a4 & 1) == 0)
    {
      __asm { FCVT            S0, H0 }
      if (_S0 == 1.0 && (v20 == 24 || v20 == 2) && *(float *)(v9 + 48) == 0.0)
      {
        v22 = *(_DWORD *)(v9 + 60);
        if ((v22 & 1) == 0 && !*(_BYTE *)(v9 + 64) && (v22 & 0x11E) == 0 && !*(_QWORD *)(v9 + 16))
        {
          v30 = (const RB::DisplayList::ClipNode *)*((_QWORD *)a2 + 3);
          if (!v30)
          {
LABEL_27:
            RB::DisplayList::Layer::append_layer_items((uint64_t)a3, v9);
            return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
          }
          if ((*((_BYTE *)v30 + 8) & 1) != 0)
          {
            v31 = *(RB::DisplayList::Item **)v9;
            if (*(_QWORD *)v9)
            {
              v32 = 0;
              v33 = (const RB::DisplayList::ClipNode *)*((_QWORD *)a2 + 3);
              do
              {
                v34 = *((_QWORD *)v31 + 3);
                if (v32 != v34)
                {
                  v33 = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((_QWORD **)v31 + 3), v30);
                  v32 = v34;
                }
                *((_QWORD *)v31 + 3) = v33;
                v31 = (RB::DisplayList::Item *)*((_QWORD *)v31 + 1);
              }
              while (v31);
            }
            goto LABEL_27;
          }
        }
      }
    }
    may_discard_alpha = RB::may_discard_alpha(v20);
    v24 = RB::DisplayList::Builder::merge_layer_item(this, (RB::DisplayList::Layer *)v9, may_discard_alpha ^ 1u);
    if (v24)
    {
      v25 = v24;
      _H0 = *((_WORD *)a2 + 22);
      __asm { FCVT            S0, H0; float }
      RB::DisplayList::Item::apply_alpha(v24, _S0);
      *(_WORD *)(v25 + 46) = *(_WORD *)(v25 + 46) & 0xFFC0 | *((_WORD *)a2 + 23) & 0x3F;
      v28 = (const RB::DisplayList::ClipNode *)*((_QWORD *)a2 + 3);
      if (v28)
        *(_QWORD *)(v25 + 24) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *(_QWORD **)(v25 + 24), v28);
      RB::DisplayList::Builder::append(this, a3, (RB::DisplayList::Item *)v25);
      return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
    }
    return RB::DisplayList::Builder::append(this, a3, a2);
  }
  v35 = *(_DWORD *)(v9 + 60);
  if ((v35 & 0x2001) == 0 || *(float *)(v9 + 48) != 0.0)
    goto LABEL_36;
  v39 = *(_QWORD **)(v9 + 16);
  if (v39)
  {
    if (!v39[1] && !*(_BYTE *)(v9 + 64))
    {
      if ((*(unsigned int (**)(_QWORD *))(*v39 + 40))(v39) == 1)
      {
        v41 = v40;
        v51 = v40;
        if (RB::ColorMatrix::is_identity(v40 + 1))
        {
          v51 = 0;
          v7 = *((_WORD *)a2 + 23);
        }
        else
        {
          v7 = *((_WORD *)a2 + 23);
          if (v41)
          {
            v42 = v7 & 0x3F;
            goto LABEL_53;
          }
        }
LABEL_52:
        v42 = v7 & 0x3F;
        if (!v42)
          return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
LABEL_53:
        v43 = (size_t *)(*((_QWORD *)this + 1) + 16);
        v53 = v42;
        _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRPKNS_6Filter11ColorMatrixERDF16_NS_9BlendModeEEEEPT_DpOT0_(v43, (uint64_t *)&v51, (__int16 *)a2 + 22, &v53);
        *(_OWORD *)(v44 + 24) = *(_OWORD *)((char *)a2 + 24);
        *(_DWORD *)(v44 + 40) = *((_DWORD *)a2 + 10);
        RB::DisplayList::Builder::append(this, a3, (RB::DisplayList::Item *)v44);
        *(_QWORD *)(v9 + 16) = 0;
        return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
      }
      v35 = *(_DWORD *)(v9 + 60);
    }
  }
  else if (!*(_BYTE *)(v9 + 64))
  {
    v51 = 0;
    goto LABEL_52;
  }
LABEL_36:
  if ((v35 & 0x2001) != 0)
    return RB::DisplayList::Builder::append(this, a3, a2);
  v36 = RB::DisplayList::Layer::effect_needs_zero_alpha((RB::DisplayList::Layer *)v9);
  if ((v36 & 1) == 0)
  {
    for (i = *(_QWORD **)(v9 + 16); i; i = (_QWORD *)i[1])
    {
      v51 = 0;
      v52 = 0;
      (*(void (**)(_QWORD *, float16x4_t **))(*i + 56))(i, &v51);
      v38 = (uint32x2_t)vcgtz_f32(v52);
      if ((vpmin_u32(v38, v38).u32[0] & 0x80000000) != 0)
        return RB::DisplayList::Builder::append(this, a3, a2);
    }
  }
  if ((v36 & 1) != 0)
    return RB::DisplayList::Builder::append(this, a3, a2);
  return (**(uint64_t (***)(RB::DisplayList::Item *))a2)(a2);
}

RB::DisplayList::Builder *RB::DisplayList::Builder::draw_custom(uint64_t a1, void *a2, int a3, _OWORD *a4, __n128 *this, int a6, float a7)
{
  RB::Heap *v10;
  uint64_t v11;
  int8x16_t *v12;
  char v13;
  uint64_t v15;
  int v16;
  float v17;
  int v18;
  void *v19;

  v19 = a2;
  v18 = a3;
  v17 = a7;
  v16 = a6;
  v10 = (RB::Heap *)(*(_QWORD *)(a1 + 8) + 16);
  RB::DisplayList::State::copy_ctm(this, v10);
  v15 = v11;
  v12 = (int8x16_t *)RB::Heap::emplace<RB::DisplayList::CustomItem,void({block_pointer}&)(RBMetalRenderState *),unsigned int &,RB::AffineTransform const*,RB::Rect const&,float &,RB::BlendMode &>(v10, &v19, &v18, &v15, a4, &v17, &v16);
  v13 = v18;
  if ((v18 & 1) != 0)
  {
    if ((v18 & 2) != 0)
      goto LABEL_3;
  }
  else
  {
    v12[2].i16[7] |= 0x40u;
    if ((v13 & 2) != 0)
    {
LABEL_3:
      if ((v13 & 4) != 0)
        goto LABEL_4;
LABEL_9:
      v12[2].i16[7] |= 0x100u;
      if ((v13 & 8) == 0)
        return RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v12, (int8x16_t *)this);
      goto LABEL_5;
    }
  }
  v12[2].i16[7] |= 0x80u;
  if ((v13 & 4) == 0)
    goto LABEL_9;
LABEL_4:
  if ((v13 & 8) != 0)
LABEL_5:
    v12[2].i16[7] |= 0x100u;
  return RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)a1, v12, (int8x16_t *)this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::CustomItem,void({block_pointer}&)(RBMetalRenderState *),unsigned int &,RB::AffineTransform const*,RB::Rect const&,float &,RB::BlendMode &>(RB::Heap *this, void **a2, int *a3, uint64_t *a4, _OWORD *a5, float *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 88 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x58uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 88;
  return RB::DisplayList::CustomItem::CustomItem(v15, *a2, *a3, *a4, a5, *a7, *a6);
}

const RB::DisplayList::ClipNode *RB::DisplayList::Builder::MemoizedAddClip::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v5;
  const RB::DisplayList::ClipNode *result;

  v5 = *(_QWORD **)(a3 + 24);
  if (*(_QWORD **)(a1 + 8) == v5)
  {
    result = *(const RB::DisplayList::ClipNode **)(a1 + 16);
  }
  else
  {
    *(_QWORD *)(a1 + 8) = v5;
    result = RB::DisplayList::Builder::join_clip_lists(a2, v5, *(const RB::DisplayList::ClipNode **)a1);
    *(_QWORD *)(a1 + 16) = result;
  }
  *(_QWORD *)(a3 + 24) = result;
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList23BackdropColorMatrixItemEJRPKNS_6Filter11ColorMatrixERDF16_NS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t *a2, __int16 *a3, _DWORD *a4)
{
  uint64_t v7;
  double result;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v7 + 56;
  _H0 = *a3;
  __asm { FCVT            S0, H0 }
  *(_QWORD *)&result = RB::DisplayList::BackdropColorMatrixItem::BackdropColorMatrixItem(v7, *a2, *a4, _S0);
  return result;
}

BOOL RB::DisplayList::Builder::can_lower_color_matrix(uint64_t *a1, uint64_t a2, uint64_t a3, unsigned __int16 a4, int a5)
{
  __int128 v8;
  uint64_t v9;
  BOOL v10;
  _BOOL8 result;
  uint64_t v17;
  unsigned int v18;
  _OWORD v20[2];
  float16x4_t v21;

  v8 = *(_OWORD *)(a2 + 16);
  v20[0] = *(_OWORD *)a2;
  v20[1] = v8;
  v21 = *(float16x4_t *)(a2 + 32);
  v9 = *a1;
  if (*a1)
  {
    v10 = *(_QWORD *)(v9 + 8) == 0;
    if (!*(_QWORD *)(v9 + 8))
      goto LABEL_7;
  }
  else
  {
    v10 = 0;
  }
  if (a5)
    RB::ColorMatrix::remove_alpha_factor((float16x4_t *)v20, a3);
LABEL_7:
  _H0 = v21.i16[3];
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  if (v10)
  {
LABEL_14:
    v17 = *a1;
    if (!v17)
      return 1;
    while (1)
    {
      v18 = *(_WORD *)(v17 + 46) & 0x3F;
      _ZF = v18 < 0xB || v18 == 24;
      if (!_ZF
        || ((*(uint64_t (**)(uint64_t, _OWORD *, uint64_t, _QWORD))(*(_QWORD *)v17 + 96))(v17, v20, a3, a4) & 1) == 0)
      {
        break;
      }
      v17 = *(_QWORD *)(v17 + 8);
      if (!v17)
        return 1;
    }
    return 0;
  }
  result = RB::ColorMatrix::is_alpha_identity((RB::ColorMatrix *)v20);
  if (result)
  {
    if ((_DWORD)a3
      && (vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(vcvtq_f32_f16(v21))))) & 0x8000) != 0)
    {
      return 0;
    }
    goto LABEL_14;
  }
  return result;
}

float RB::DisplayList::Builder::lower_color_matrix(uint64_t a1, _QWORD **a2, uint64_t a3, uint64_t a4, unsigned __int16 a5, int a6)
{
  __int128 v10;
  _QWORD *v11;
  float v12;
  _OWORD v14[2];
  uint64_t v15;

  v10 = *(_OWORD *)(a3 + 16);
  v14[0] = *(_OWORD *)a3;
  v14[1] = v10;
  v15 = *(_QWORD *)(a3 + 32);
  v11 = *a2;
  if (!*a2)
  {
    v12 = 1.0;
    if (!a6)
      return v12;
    goto LABEL_6;
  }
  v12 = 1.0;
  if (v11[1] && (a6 & 1) != 0)
  {
LABEL_6:
    v12 = RB::ColorMatrix::remove_alpha_factor((float16x4_t *)v14, a4);
    v11 = *a2;
    if (!*a2)
      return v12;
    goto LABEL_7;
  }
  do
  {
LABEL_7:
    (*(void (**)(_QWORD *, _OWORD *, uint64_t, _QWORD, uint64_t))(*v11 + 104))(v11, v14, a4, a5, a1);
    v11 = (_QWORD *)v11[1];
  }
  while (v11);
  return v12;
}

BOOL RB::DisplayList::Builder::merge_layer_item(RB::DisplayList::Layer &,unsigned int)::$_0::operator()(_BYTE *a1, uint64_t a2, uint64_t a3)
{
  BOOL v3;
  int v4;

  if ((!*(_BYTE *)(a3 + 64) || (!*(_BYTE *)(a2 + 64) ? (v3 = *(_QWORD *)(a2 + 16) == 0) : (v3 = 0), v3))
    && ((v4 = *(_DWORD *)(a3 + 60) ^ *(_DWORD *)(a2 + 60), (*a1 & 2) != 0) || (v4 & 8) == 0))
  {
    return (v4 & 6 & ((v4 & 6) - 1)) == 0;
  }
  else
  {
    return 0;
  }
}

RB::DisplayList::State *RB::DisplayList::State::State(RB::DisplayList::State *this, int a2, const RB::DisplayList::State *a3)
{
  uint64_t v6;
  __int128 v7;
  __int128 v8;

  v6 = *((_QWORD *)a3 + 1);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = v6;
  v7 = *((_OWORD *)a3 + 1);
  v8 = *((_OWORD *)a3 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a3 + 2);
  *((_OWORD *)this + 3) = v8;
  *((_OWORD *)this + 1) = v7;
  *((_DWORD *)this + 16) = 0;
  uuid_clear((unsigned __int8 *)this + 68);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = *((_QWORD *)a3 + 14);
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = a2;
  *((_DWORD *)this + 37) = -1;
  *((_DWORD *)this + 38) = *((_DWORD *)a3 + 38);
  *((_WORD *)this + 78) = *((_WORD *)a3 + 78);
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = *((_QWORD *)a3 + 21);
  return this;
}

BOOL RB::same_identity<RB::DisplayList::Style>(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;
  uint64_t *v7;
  _BOOL8 result;
  uint64_t v9;
  uint64_t v10;

  v2 = *(_DWORD *)(a1 + 48);
  if (v2 != *(_DWORD *)(a2 + 48))
    return 0;
  v3 = *(uint64_t **)(a1 + 40);
  v4 = *(uint64_t **)(a2 + 40);
  if (v2)
    v5 = 0;
  else
    v5 = v3 == v4;
  if (v5)
    return 1;
  if (v3)
  {
    v6 = RB::DisplayList::Metadata::identity_ns(v3);
    if (v4)
    {
LABEL_8:
      v7 = RB::DisplayList::Metadata::identity_ns(v4);
      goto LABEL_12;
    }
  }
  else
  {
    v6 = 0;
    if (v4)
      goto LABEL_8;
  }
  v7 = 0;
LABEL_12:
  if (v6 == v7)
    return 1;
  result = 0;
  if (v6 && v7)
  {
    v10 = *v7;
    v9 = v7[1];
    return *v6 == v10 && v6[1] == v9;
  }
  return result;
}

_QWORD *RB::Path::BufferedTransform::closepath(_QWORD *this)
{
  _QWORD *v1;
  _QWORD *v2;
  uint64_t v3;
  size_t v4;
  _QWORD *v5;

  v1 = this;
  v2 = this + 1;
  v3 = this[18];
  v4 = v3 + 1;
  if (this[19] < (unint64_t)(v3 + 1))
  {
    this = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(this + 1, v4);
    v3 = v1[18];
    v4 = v3 + 1;
  }
  v5 = (_QWORD *)v1[17];
  if (!v5)
    v5 = v2;
  *((_BYTE *)v5 + v3) = 4;
  v1[18] = v4;
  return this;
}

_QWORD *RB::Path::BufferedTransform::moveto(_QWORD *result, __n128 a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  size_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  __n128 v10;
  __n128 v11;

  v2 = result;
  v3 = result + 1;
  v4 = result[18];
  v5 = v4 + 1;
  if (result[19] < (unint64_t)(v4 + 1))
  {
    v10 = a2;
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v5);
    a2 = v10;
    v4 = v2[18];
    v5 = v4 + 1;
  }
  v6 = (_QWORD *)v2[17];
  if (!v6)
    v6 = v3;
  *((_BYTE *)v6 + v4) = 0;
  v2[18] = v5;
  v7 = v2[533];
  v8 = v7 + 2;
  if (v7 <= 0xFFFFFFFFFFFFFFFDLL && v2[534] < v8)
  {
    v11 = a2;
    result = RB::vector<double,512ul,unsigned long>::reserve_slow(v2 + 20, v7 + 2);
    a2 = v11;
  }
  v2[533] = v8;
  v9 = (_QWORD *)v2[532];
  if (!v9)
    v9 = v2 + 20;
  *(__n128 *)&v9[v7] = a2;
  return result;
}

_QWORD *RB::Path::BufferedTransform::lineto(_QWORD *result, __n128 a2)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;
  size_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  __n128 v10;
  __n128 v11;

  v2 = result;
  v3 = result + 1;
  v4 = result[18];
  v5 = v4 + 1;
  if (result[19] < (unint64_t)(v4 + 1))
  {
    v10 = a2;
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v5);
    a2 = v10;
    v4 = v2[18];
    v5 = v4 + 1;
  }
  v6 = (_QWORD *)v2[17];
  if (!v6)
    v6 = v3;
  *((_BYTE *)v6 + v4) = 1;
  v2[18] = v5;
  v7 = v2[533];
  v8 = v7 + 2;
  if (v7 <= 0xFFFFFFFFFFFFFFFDLL && v2[534] < v8)
  {
    v11 = a2;
    result = RB::vector<double,512ul,unsigned long>::reserve_slow(v2 + 20, v7 + 2);
    a2 = v11;
  }
  v2[533] = v8;
  v9 = (_QWORD *)v2[532];
  if (!v9)
    v9 = v2 + 20;
  *(__n128 *)&v9[v7] = a2;
  return result;
}

_QWORD *RB::Path::BufferedTransform::quadto(_QWORD *result, __n128 a2, __n128 a3)
{
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  size_t v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  __n128 *v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;

  v3 = result;
  v4 = result + 1;
  v5 = result[18];
  v6 = v5 + 1;
  if (result[19] < (unint64_t)(v5 + 1))
  {
    v12 = a2;
    v14 = a3;
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v6);
    a2 = v12;
    a3 = v14;
    v5 = v3[18];
    v6 = v5 + 1;
  }
  v7 = (_QWORD *)v3[17];
  if (!v7)
    v7 = v4;
  *((_BYTE *)v7 + v5) = 2;
  v3[18] = v6;
  v8 = v3[533];
  v9 = v8 + 4;
  if (v8 <= 0xFFFFFFFFFFFFFFFBLL && v3[534] < v9)
  {
    v13 = a2;
    v15 = a3;
    result = RB::vector<double,512ul,unsigned long>::reserve_slow(v3 + 20, v8 + 4);
    a2 = v13;
    a3 = v15;
  }
  v3[533] = v9;
  v10 = (_QWORD *)v3[532];
  if (!v10)
    v10 = v3 + 20;
  v11 = (__n128 *)&v10[v8];
  *v11 = a2;
  v11[1] = a3;
  return result;
}

_QWORD *RB::Path::BufferedTransform::cubeto(_QWORD *result, __n128 a2, __n128 a3, __n128 a4)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  size_t v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  __n128 *v12;
  __n128 v13;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  __n128 v18;

  v4 = result;
  v5 = result + 1;
  v6 = result[18];
  v7 = v6 + 1;
  if (result[19] < (unint64_t)(v6 + 1))
  {
    v15 = a3;
    v17 = a4;
    v13 = a2;
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(result + 1, v7);
    a2 = v13;
    a3 = v15;
    a4 = v17;
    v6 = v4[18];
    v7 = v6 + 1;
  }
  v8 = (_QWORD *)v4[17];
  if (!v8)
    v8 = v5;
  *((_BYTE *)v8 + v6) = 3;
  v4[18] = v7;
  v9 = v4[533];
  v10 = v9 + 6;
  if (v9 <= 0xFFFFFFFFFFFFFFF9 && v4[534] < v10)
  {
    v16 = a3;
    v18 = a4;
    v14 = a2;
    result = RB::vector<double,512ul,unsigned long>::reserve_slow(v4 + 20, v9 + 6);
    a2 = v14;
    a3 = v16;
    a4 = v18;
  }
  v4[533] = v10;
  v11 = (_QWORD *)v4[532];
  if (!v11)
    v11 = v4 + 20;
  v12 = (__n128 *)&v11[v9];
  *v12 = a2;
  v12[1] = a3;
  v12[2] = a4;
  return result;
}

__n128 *RB::Path::BufferedTransform::apply(__n128 *result, uint64_t a2)
{
  uint64_t v2;
  unsigned __int8 *v3;
  __n128 *v5;
  __n128 v6;
  __n128 v7;
  __n128 v8;
  __n128 v9;

  v2 = result[9].n128_i64[0];
  if (result[8].n128_u64[1])
    v3 = (unsigned __int8 *)result[8].n128_u64[1];
  else
    v3 = &result->n128_u8[8];
  if (v2)
  {
    if (result[266].n128_u64[0])
      v5 = (__n128 *)result[266].n128_u64[0];
    else
      v5 = result + 10;
    do
    {
      switch(*v3)
      {
        case 0u:
          v6 = *v5++;
          result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)a2 + 16))(a2, v6);
          break;
        case 1u:
          v7 = *v5++;
          result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128))(*(_QWORD *)a2 + 24))(a2, v7);
          break;
        case 2u:
          v8 = *v5;
          v9 = v5[1];
          v5 += 2;
          result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128, __n128))(*(_QWORD *)a2 + 32))(a2, v8, v9);
          break;
        case 3u:
          result = (__n128 *)(*(uint64_t (**)(uint64_t, __n128, __n128, __n128))(*(_QWORD *)a2 + 40))(a2, *v5, v5[1], v5[2]);
          v5 += 3;
          break;
        case 4u:
          result = (__n128 *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a2 + 8))(a2);
          break;
        default:
          break;
      }
      ++v3;
      --v2;
    }
    while (v2);
  }
  return result;
}

void RB::Path::CGPathTransform::closepath(RB::Path::CGPathTransform *this)
{
  CGPath *v1;

  v1 = (CGPath *)*((_QWORD *)this + 1);
  if (v1)
    CGPathCloseSubpath(v1);
}

void RB::Path::CGPathTransform::moveto(RB::Path::CGPathTransform *this, __n128 a2)
{
  CGPath *v3;
  __n128 x;

  v3 = (CGPath *)*((_QWORD *)this + 1);
  if (!v3)
  {
    x = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = x;
    v3 = (CGPath *)*((_QWORD *)this + 1);
  }
  CGPathMoveToPoint(v3, 0, a2.n128_f64[0], a2.n128_f64[1]);
}

void RB::Path::CGPathTransform::reset(RB::Path::CGPathTransform *this)
{
  CGMutablePathRef Mutable;
  const void *v3;

  Mutable = CGPathCreateMutable();
  v3 = (const void *)*((_QWORD *)this + 1);
  if (v3)
    CFRelease(v3);
  *((_QWORD *)this + 1) = Mutable;
}

void RB::Path::CGPathTransform::lineto(RB::Path::CGPathTransform *this, __n128 a2)
{
  CGPath *v3;
  __n128 x;

  v3 = (CGPath *)*((_QWORD *)this + 1);
  if (!v3)
  {
    x = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = x;
    v3 = (CGPath *)*((_QWORD *)this + 1);
  }
  CGPathAddLineToPoint(v3, 0, a2.n128_f64[0], a2.n128_f64[1]);
}

void RB::Path::CGPathTransform::quadto(RB::Path::CGPathTransform *this, __n128 a2, __n128 a3)
{
  __n128 v3;
  CGPath *v5;
  __n128 v6;

  v3 = a3;
  v5 = (CGPath *)*((_QWORD *)this + 1);
  if (!v5)
  {
    v6 = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = v6;
    v3 = a3;
    v5 = (CGPath *)*((_QWORD *)this + 1);
  }
  CGPathAddQuadCurveToPoint(v5, 0, a2.n128_f64[0], a2.n128_f64[1], v3.n128_f64[0], v3.n128_f64[1]);
}

void RB::Path::CGPathTransform::cubeto(RB::Path::CGPathTransform *this, __n128 a2, __n128 a3, __n128 a4)
{
  __n128 v5;
  CGPath *v7;
  __n128 v8;
  __n128 x;

  v5 = a3;
  v7 = (CGPath *)*((_QWORD *)this + 1);
  if (!v7)
  {
    x = a4;
    v8 = a2;
    RB::Path::CGPathTransform::reset(this);
    a2 = v8;
    v5 = a3;
    a4 = x;
    v7 = (CGPath *)*((_QWORD *)this + 1);
  }
  CGPathAddCurveToPoint(v7, 0, a2.n128_f64[0], a2.n128_f64[1], v5.n128_f64[0], v5.n128_f64[1], a4.n128_f64[0], a4.n128_f64[1]);
}

uint64_t RB::Path::AffineTransformer::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  return (*(uint64_t (**)(_QWORD, __n128, __n128))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a3.f64[0]), *(float64x2_t *)(a1 + 32), a3, 1));
}

void RB::Path::Cutter::endpath(__n128 *this)
{
  __n128 v2;
  float v3;
  float v4;
  unint64_t v5;
  unsigned __int8 *v6;
  uint64_t v7;
  double v8;
  double v9;
  float64x2_t *v10;
  float v11;
  double v12;
  int64x2_t v13;
  float64x2_t v14;
  int v15;
  unint64_t v16;
  uint64_t *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double *v24;
  double *v25;
  float64x2_t v26;
  double v27;
  double v28;
  unint64_t v29;
  __n128 v30;
  char v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  unint64_t v37;
  float64x2_t v38;
  double v39;
  __n128 v40;
  int64x2_t v41;
  unint64_t v42;
  __n128 v43;
  float64x2_t v44;
  __int16 v45;
  BOOL v46;
  float64x2_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  Point v61[4];
  float64x2_t v62;
  float64x2_t v63;
  float64x2_t v64;
  __int128 v65;
  __int128 v66;
  __int128 v67;
  Point v68[4];
  Point v69[4];
  Point v70[4];
  Point v71[4];
  uint64_t (**v72)(RB::Path::_anonymous_namespace_::Lengths *__hidden);
  uint64_t v73;
  __int128 v74;
  uint64_t v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;
  uint64_t v79;

  v79 = *MEMORY[0x24BDAC8D0];
  if (this[268].n128_f32[0] <= 0.0 && this[268].n128_f32[1] >= 1.0)
  {
    RB::Path::BufferedTransform::apply(this, this[267].n128_i64[1]);
  }
  else
  {
    v74 = 0u;
    v72 = off_24C223DA0;
    v75 = 128;
    v76 = 0u;
    v77 = 0u;
    v78 = 0;
    RB::Path::BufferedTransform::apply(this, (uint64_t)&v72);
    v3 = this[268].n128_f32[0];
    v4 = this[268].n128_f32[1];
    v42 = this[267].n128_u64[1];
    v43 = 0u;
    v44 = 0u;
    v5 = this[9].n128_u64[0];
    if (this[8].n128_u64[1])
      v6 = (unsigned __int8 *)this[8].n128_u64[1];
    else
      v6 = &this->n128_u8[8];
    v45 = 257;
    v46 = 0;
    if (v5)
    {
      v7 = 0;
      v8 = *(double *)&v76 * v3;
      v9 = *(double *)&v76 * v4;
      if (this[266].n128_u64[0])
        v10 = (float64x2_t *)this[266].n128_u64[0];
      else
        v10 = (float64x2_t *)&this[10];
      v11 = 0.0;
      v12 = 1.0;
      v13 = vdupq_n_s64(0x3FD5555555555555uLL);
      v38 = (float64x2_t)v13;
      v39 = *(double *)&v76 * v4;
      while (1)
      {
        switch(*v6)
        {
          case 0u:
            v14 = *v10++;
            v43 = (__n128)v14;
            v13.i64[1] = *(_QWORD *)&v14.f64[1];
            v44 = v14;
            v45 = 257;
            goto LABEL_61;
          case 1u:
            v15 = 0;
            v16 = 1;
            goto LABEL_17;
          case 2u:
            v15 = 0;
            v16 = 2;
            goto LABEL_17;
          case 3u:
            v15 = 0;
            v16 = 3;
            goto LABEL_17;
          default:
            v16 = 0;
            v15 = 1;
LABEL_17:
            v17 = (uint64_t *)v74;
            if (!(_QWORD)v74)
              v17 = &v73;
            v18 = *(double *)&v17[v7];
            v19 = v11;
            v20 = 0.0;
            if (v8 > v19)
              v20 = fmax((v8 - v19) / v18, 0.0);
            v21 = v18 + v19;
            v22 = 1.0;
            if (v9 < v18 + v19)
              v22 = fmin((v9 - v19) / v18, v12);
            if ((_BYTE)v45)
            {
              v46 = v20 == 0.0;
              LOBYTE(v45) = 0;
            }
            if (v20 >= v22)
            {
              if (!v15)
              {
                v2 = (__n128)v10[v16 - 1];
                v44 = (float64x2_t)v2;
                goto LABEL_60;
              }
              v2 = v43;
              goto LABEL_59;
            }
            if (v16 >= 2)
            {
              if (v16 == 2)
              {
                v32 = *v10;
                v33 = v10[1];
                *(float64x2_t *)&v61[0].v = vmlaq_f64(*v10, v38, vsubq_f64(v44, *v10));
                *(float64x2_t *)&v70[0].v = v33;
                *(float64x2_t *)&v71[0].v = vmlaq_f64(v32, v38, vsubq_f64(v33, v32));
                CG::Cubic::Cubic((CG::Cubic *)&v47, (const Point *)&v44, v61, v71, v70);
                v34 = v48;
                v35 = v49;
                v36 = v50;
              }
              else
              {
                v34 = *v10;
                v35 = v10[1];
                v36 = v10[2];
              }
              *(float64x2_t *)&v70[0].v = v34;
              *(float64x2_t *)&v71[0].v = v44;
              *(float64x2_t *)&v68[0].v = v36;
              *(float64x2_t *)&v69[0].v = v35;
              if (v20 > 0.0 || v22 < v12)
              {
                CG::Cubic::Cubic((CG::Cubic *)v61, v71, v70, v69, v68);
                if (v20 > 0.00100000005)
                  v20 = CG::Cubic::index((CG::Cubic *)v61, v20 * v18, 0.5);
                if (v22 < 0.999000013)
                  v22 = CG::Cubic::index((CG::Cubic *)v61, v22 * v18, 0.5);
                if (v20 > 0.00100000005)
                {
                  CG::Cubic::split((float64x2_t *)v61, v20, &v47);
                  v65 = v58;
                  v66 = v59;
                  v67 = v60;
                  *(_OWORD *)&v61[0].v = v54;
                  v62 = v55;
                  v63 = v56;
                  v64 = v57;
                  v22 = (v22 - v20) / (v12 - v20);
                }
                if (v22 < 0.999000013)
                {
                  CG::Cubic::split((float64x2_t *)v61, v22, &v47);
                  v65 = v51;
                  v66 = v52;
                  v67 = v53;
                  *(float64x2_t *)&v61[0].v = v47;
                  v62 = v48;
                  v63 = v49;
                  v64 = v50;
                }
                *(float64x2_t *)&v70[0].v = v62;
                *(_OWORD *)&v71[0].v = *(_OWORD *)&v61[0].v;
                *(float64x2_t *)&v68[0].v = v64;
                *(float64x2_t *)&v69[0].v = v63;
              }
              v37 = v42;
              if (HIBYTE(v45))
              {
                HIBYTE(v45) = 0;
                (*(void (**)(unint64_t, __n128))(*(_QWORD *)v42 + 16))(v42, *(__n128 *)&v71[0].v);
                v37 = v42;
              }
              (*(void (**)(unint64_t, __n128, __n128, __n128))(*(_QWORD *)v37 + 40))(v37, *(__n128 *)&v70[0].v, *(__n128 *)&v69[0].v, *(__n128 *)&v68[0].v);
              v2 = *(__n128 *)&v68[0].v;
LABEL_59:
              v44 = (float64x2_t)v2;
              goto LABEL_60;
            }
            v23 = v8;
            v24 = &v10->f64[1];
            if (v15)
              v25 = (double *)&v43;
            else
              v25 = (double *)v10;
            if (v15)
              v24 = &v43.n128_f64[1];
            v26 = v44;
            v27 = *v25 - v44.f64[0];
            v28 = *v24 - v44.f64[1];
            v29 = v42;
            if (HIBYTE(v45))
            {
              v30.n128_f64[0] = v44.f64[0] + v27 * v20;
              HIBYTE(v45) = 0;
              v30.n128_f64[1] = v44.f64[1] + v28 * v20;
              (*(void (**)(unint64_t, __n128))(*(_QWORD *)v42 + 16))(v42, v30);
              v29 = v42;
            }
            v2.n128_f64[0] = v26.f64[0] + v27 * v22;
            *(double *)v13.i64 = v26.f64[1] + v28 * v22;
            v40 = v2;
            v41 = v13;
            v2.n128_f64[1] = *(double *)v13.i64;
            (*(void (**)(unint64_t, __n128))(*(_QWORD *)v29 + 24))(v29, v2);
            v13.i64[1] = v40.n128_i64[1];
            v2.n128_u64[1] = v41.u64[1];
            *(_QWORD *)&v44.f64[0] = v40.n128_u64[0];
            *(_QWORD *)&v44.f64[1] = v41.i64[0];
            v12 = 1.0;
            v31 = v15 ^ 1;
            if (v22 != 1.0)
              v31 = 1;
            v8 = v23;
            v9 = v39;
            if ((v31 & 1) == 0 && v46)
            {
              v46 = 0;
              (*(void (**)(unint64_t))(*(_QWORD *)v42 + 8))(v42);
            }
LABEL_60:
            v10 += v16;
            v11 = v21;
            ++v7;
LABEL_61:
            ++v6;
            if (!--v5)
              goto LABEL_62;
            break;
        }
      }
    }
LABEL_62:
    if ((_QWORD)v74)
      free((void *)v74);
  }
}

BOOL RB::Path::Projection::project(uint64_t a1, uint64_t a2, float64x2_t a3)
{
  uint64_t v3;
  uint64_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  double v11;
  double v12;
  uint64_t v13;
  double *v14;
  double v15;
  uint64_t v16;
  double v17;
  CG::Cubic *v18;
  unsigned int v19;
  double v20;
  double v21;
  double v22;
  float64x2_t v23;
  double v24;
  double v25;
  float64x2_t *v26;
  double v27;
  double v28;
  double v29;
  double *v30;
  double v31;
  double v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  double v38;
  double v39;
  float64x2_t v40;
  float64x2_t v41[2];
  uint64_t v42;
  uint64_t v43;

  v3 = *(_QWORD *)(a1 + 1976);
  if (v3)
  {
    v7 = a1 + 48;
    v8 = *(float64x2_t *)(a1 + 32);
    v9 = vsubq_f64(a3, *(float64x2_t *)(a1 + 16));
    v10 = vmulq_f64(v8, v9);
    v11 = vaddvq_f64(v10) * *(double *)(a1 + 2048);
    v10.f64[0] = -v9.f64[1];
    v12 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v10, (int64x2_t)v9), v8)) * *(double *)(a1 + 2040);
    v40 = a3;
    if (v11 <= 0.0000999999975 || v11 >= 0.999899983)
    {
      v13 = *(_QWORD *)(a1 + 1968);
      if (v11 < 0.5)
      {
        v19 = 0;
        if (v13)
          v18 = *(CG::Cubic **)(a1 + 1968);
        else
          v18 = (CG::Cubic *)(a1 + 48);
      }
      else
      {
LABEL_12:
        if (v13)
          v7 = v13;
        v18 = (CG::Cubic *)(v7 + 120 * v3 - 120);
        v19 = 1;
      }
      v23.f64[0] = CG::Cubic::derivative(v18, (double)v19);
      if (v23.f64[0] != 0.0 || v24 != 0.0)
      {
        v27 = sqrt(v23.f64[0] * v23.f64[0] + v24 * v24);
        v23.f64[0] = v23.f64[0] / v27;
        v24 = v24 / v27;
      }
      v28 = v11 + -1.0;
      if (!v19)
        v28 = v11;
      v29 = *(double *)(a1 + 2032) * v28;
      v30 = (double *)((char *)v18 + 48);
      if (!v19)
        v30 = (double *)v18;
      v31 = *v30 + v29 * v23.f64[0];
      v32 = v30[1] + v29 * v24;
      *(_OWORD *)a2 = xmmword_209BD5290;
      *(_OWORD *)(a2 + 16) = xmmword_209BD52A0;
      *(float64x2_t *)(a2 + 32) = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_209BD52A0, v32), (float64x2_t)xmmword_209BD5290, v31);
      v26 = (float64x2_t *)(a2 + 32);
    }
    else
    {
      v13 = *(_QWORD *)(a1 + 1968);
      if (v13)
        v14 = *(double **)(a1 + 1968);
      else
        v14 = (double *)(a1 + 48);
      v15 = *(double *)(a1 + 2032) * v11;
      v16 = 120 * v3;
      while (1)
      {
        v17 = v14[14];
        if (v15 < v17)
          break;
        v15 = v15 - v17;
        v14 += 15;
        v16 -= 120;
        if (!v16)
        {
          v11 = 1.0;
          goto LABEL_12;
        }
      }
      v20 = CG::Cubic::index((CG::Cubic *)v14, v15, 0.5);
      v21 = CG::Cubic::evaluate((float64x2_t *)v14, v20);
      v38 = v22;
      v39 = v21;
      v23.f64[0] = CG::Cubic::derivative((CG::Cubic *)v14, v20);
      if (v23.f64[0] != 0.0 || v24 != 0.0)
      {
        v25 = sqrt(v23.f64[0] * v23.f64[0] + v24 * v24);
        v23.f64[0] = v23.f64[0] / v25;
        v24 = v24 / v25;
      }
      *(_OWORD *)a2 = xmmword_209BD5290;
      *(_OWORD *)(a2 + 16) = xmmword_209BD52A0;
      *(float64x2_t *)(a2 + 32) = vmlaq_n_f64(vmulq_n_f64((float64x2_t)xmmword_209BD52A0, v38), (float64x2_t)xmmword_209BD5290, v39);
      v26 = (float64x2_t *)(a2 + 32);
    }
    v33.f64[0] = -v24;
    v33.f64[1] = v23.f64[0];
    v23.f64[1] = v24;
    v41[0] = v23;
    v41[1] = v33;
    v42 = 0;
    v43 = 0;
    v34.f64[0] = RB::operator*(v41, (float64x2_t *)a2);
    *(float64x2_t *)a2 = v34;
    *(float64x2_t *)(a2 + 16) = v35;
    *v26 = vmlsq_lane_f64(vmlsq_lane_f64(v36, v34, v40.f64[0], 0), v35, v12 + v40.f64[1], 0);
  }
  return v3 != 0;
}

double RB::Path::Projection::endpath(float64x2_t *this)
{
  double v1;
  double result;

  v1 = this[127].f64[0];
  this[2] = vmulq_n_f64(this[2], v1 / sqrt(vaddvq_f64(vmulq_f64(this[2], this[2]))));
  this[127].f64[1] = 1.0 / v1;
  result = 1.0 / (v1 * v1);
  this[128].f64[0] = result;
  return result;
}

float64x2_t RB::Path::Projection::closepath(float64x2_t *this)
{
  float64x2_t result;
  int8x16_t v2;

  result = this[126];
  v2 = (int8x16_t)vceqq_f64(this[125], result);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v2), 1), v2).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Path::Projection::lineto((uint64_t)this, result);
    result = this[126];
    this[125] = result;
  }
  return result;
}

float64x2_t RB::Path::Projection::lineto(uint64_t a1, float64x2_t result)
{
  float64x2_t v2;
  int8x16_t v3;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  double *v8;
  CG::Cubic *v9;
  uint64_t v10;
  uint64_t v11;
  float64x2_t v12;
  Point v13[4];
  Point v14[4];
  Point v15[4];
  Point v16[4];

  v2 = *(float64x2_t *)(a1 + 2000);
  v3 = (int8x16_t)vceqq_f64(v2, result);
  if ((vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3).u64[0] & 0x8000000000000000) != 0)
  {
    v5 = a1 + 48;
    v6 = *(_QWORD *)(a1 + 1976);
    v12 = result;
    if (*(_QWORD *)(a1 + 1984) < (unint64_t)(v6 + 1))
    {
      RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow((void *)(a1 + 48), v6 + 1);
      result = v12;
      v6 = *(_QWORD *)(a1 + 1976);
      v2 = *(float64x2_t *)(a1 + 2000);
    }
    v7 = *(_QWORD *)(a1 + 1968);
    if (!v7)
      v7 = v5;
    *(float64x2_t *)&v16[0].v = v2;
    v8 = (double *)(v7 + 120 * v6);
    *(float64x2_t *)&v14[0].v = result;
    *(float64x2_t *)&v15[0].v = v2;
    *(float64x2_t *)&v13[0].v = result;
    v9 = (CG::Cubic *)CG::Cubic::Cubic((CG::Cubic *)v8, v16, v15, v14, v13);
    v8[14] = CG::Cubic::length(v9, 0.5);
    v10 = *(_QWORD *)(a1 + 1976);
    *(_QWORD *)(a1 + 1976) = v10 + 1;
    v11 = *(_QWORD *)(a1 + 1968);
    if (!v11)
      v11 = v5;
    *(double *)(a1 + 2032) = *(double *)(a1 + 2032) + *(double *)(v11 + 120 * v10 + 112);
    result = v12;
    *(float64x2_t *)(a1 + 2000) = v12;
  }
  return result;
}

__n128 *RB::Path::Projection::moveto(__n128 *result, __n128 a2)
{
  result[125] = a2;
  result[126] = a2;
  return result;
}

double RB::Path::Projection::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4;
  float64x2_t v5;
  double result;

  v4 = vaddq_f64(a2, a2);
  v5 = (float64x2_t)vdupq_n_s64(0x3FD5555560000000uLL);
  *(_QWORD *)&result = RB::Path::Projection::cubeto((uint64_t)a1, (__n128)vmulq_f64(vaddq_f64(a1[125], v4), v5), (__n128)vmulq_f64(vaddq_f64(v4, a3), v5), (__n128)a3).n128_u64[0];
  return result;
}

__n128 RB::Path::Projection::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  double *v9;
  CG::Cubic *v10;
  uint64_t v11;
  uint64_t v12;
  __n128 result;
  __n128 v14;
  __n128 v15;
  __n128 v16;
  Point v17[4];
  Point v18[4];
  Point v19[4];
  Point v20[4];

  v5 = a1 + 48;
  v6 = *(_QWORD *)(a1 + 1976);
  v16 = a4;
  if (*(_QWORD *)(a1 + 1984) < (unint64_t)(v6 + 1))
  {
    v14 = a2;
    v15 = a3;
    RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow((void *)(a1 + 48), v6 + 1);
    a2 = v14;
    a3 = v15;
    a4 = v16;
    v6 = *(_QWORD *)(a1 + 1976);
  }
  v7 = *(_QWORD *)(a1 + 1968);
  if (!v7)
    v7 = v5;
  v8 = *(_OWORD *)(a1 + 2000);
  v9 = (double *)(v7 + 120 * v6);
  *(__n128 *)&v19[0].v = a2;
  *(_OWORD *)&v20[0].v = v8;
  *(__n128 *)&v17[0].v = a4;
  *(__n128 *)&v18[0].v = a3;
  v10 = (CG::Cubic *)CG::Cubic::Cubic((CG::Cubic *)v9, v20, v19, v18, v17);
  v9[14] = CG::Cubic::length(v10, 0.5);
  v11 = *(_QWORD *)(a1 + 1976);
  *(_QWORD *)(a1 + 1976) = v11 + 1;
  v12 = *(_QWORD *)(a1 + 1968);
  if (!v12)
    v12 = v5;
  *(double *)(a1 + 2032) = *(double *)(a1 + 2032) + *(double *)(v12 + 120 * v11 + 112);
  result = v16;
  *(__n128 *)(a1 + 2000) = v16;
  return result;
}

void RB::Path::BooleanTransform::endpath(RB::Path::BooleanTransform *this)
{
  const CGPath *v2;
  const CGPath *v3;
  CGPathRef CopyByIntersectingPath;
  const void *v5;
  CFTypeRef v6;
  const void *v7;
  const CGPath *v8;
  const CGPath *v9;
  const CGPath *v10;
  const CGPath *v11;
  const CGPath *v12;
  CGPathRef v13;
  const void *v14;

  v2 = (const CGPath *)*((_QWORD *)this + 4);
  if (v2)
  {
    switch(*((_BYTE *)this + 24))
    {
      case 1:
        v3 = (const CGPath *)*((_QWORD *)this + 1);
        if (!v3)
          goto LABEL_23;
        CopyByIntersectingPath = CGPathCreateCopyByIntersectingPath(v2, v3, *((_BYTE *)this + 25));
        goto LABEL_20;
      case 2:
        v8 = (const CGPath *)*((_QWORD *)this + 1);
        if (!v8)
          return;
        CopyByIntersectingPath = CGPathCreateCopyByUnioningPath(v2, v8, *((_BYTE *)this + 25));
        goto LABEL_20;
      case 3:
        v9 = (const CGPath *)*((_QWORD *)this + 1);
        if (!v9)
          return;
        CopyByIntersectingPath = CGPathCreateCopyBySubtractingPath(v2, v9, *((_BYTE *)this + 25));
        goto LABEL_20;
      case 4:
        v10 = (const CGPath *)*((_QWORD *)this + 1);
        if (!v10)
          return;
        CopyByIntersectingPath = CGPathCreateCopyBySymmetricDifferenceOfPath(v2, v10, *((_BYTE *)this + 25));
        goto LABEL_20;
      case 5:
        v11 = (const CGPath *)*((_QWORD *)this + 1);
        if (!v11)
          goto LABEL_23;
        CopyByIntersectingPath = CGPathCreateCopyOfLineByIntersectingPath(v2, v11, *((_BYTE *)this + 25));
        goto LABEL_20;
      case 6:
        v12 = (const CGPath *)*((_QWORD *)this + 1);
        if (v12)
        {
          CopyByIntersectingPath = CGPathCreateCopyOfLineBySubtractingPath(v2, v12, *((_BYTE *)this + 25));
LABEL_20:
          v13 = CopyByIntersectingPath;
          v14 = (const void *)*((_QWORD *)this + 4);
          if (v14)
            CFRelease(v14);
          *((_QWORD *)this + 4) = v13;
        }
        else
        {
LABEL_23:
          CFRelease(v2);
          *((_QWORD *)this + 4) = 0;
        }
        break;
      default:
        return;
    }
  }
  else if (*((_BYTE *)this + 24))
  {
    v5 = (const void *)*((_QWORD *)this + 1);
    if (v5)
    {
      v6 = CFRetain(v5);
      v7 = (const void *)*((_QWORD *)this + 1);
      *((_QWORD *)this + 4) = v6;
      if (v7)
        CFRelease(v7);
    }
    *((_QWORD *)this + 1) = 0;
  }
}

void RB::Path::BooleanTransform::commit(RB::Path::BooleanTransform *this)
{
  const CGPath *CopyByNormalizing;
  void (***v3)(_QWORD);
  const void *v4;
  _QWORD v5[2];

  if (*((_BYTE *)this + 24))
  {
    CopyByNormalizing = (const CGPath *)*((_QWORD *)this + 4);
    if (!CopyByNormalizing)
      return;
    goto LABEL_3;
  }
  CopyByNormalizing = CGPathCreateCopyByNormalizing(*((CGPathRef *)this + 1), *((_BYTE *)this + 25));
  v4 = (const void *)*((_QWORD *)this + 4);
  if (v4)
    CFRelease(v4);
  *((_QWORD *)this + 4) = CopyByNormalizing;
  if (CopyByNormalizing)
  {
LABEL_3:
    v3 = (void (***)(_QWORD))*((_QWORD *)this + 2);
    v5[0] = v3;
    v5[1] = 0;
    CGPathApply(CopyByNormalizing, v5, (CGPathApplierFunction)RB::Path::Iterator::callback_1);
    (**v3)(v3);
  }
}

void RB::Path::DilateGlyphTransform::endpath(RB::Path::DilateGlyphTransform *this, uint64_t a2)
{
  __n128 *v2;
  __n128 *v3;
  _BYTE v4[80];
  uint64_t (**v5)(RB::Path::Orientation *__hidden);
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  _QWORD v9[18];
  void *v10[2];
  uint64_t v11;
  void *v12[2];
  uint64_t v13;
  uint64_t v14;

  MEMORY[0x24BDAC7A8](this, a2);
  v3 = v2;
  v14 = *MEMORY[0x24BDAC8D0];
  v5 = off_24C222C00;
  v6 = 0u;
  v7 = 0u;
  v8 = 0;
  RB::Path::BufferedTransform::apply(v2, (uint64_t)&v5);
  RB::Path::Dilator::Dilator((uint64_t)v4, v3[267].n128_i64[1], v3[268]);
  if (*(double *)&v6 >= 0.0)
  {
    RB::Path::BufferedTransform::apply(v3, (uint64_t)v4);
    RB::Path::Dilator::endpath((RB::Path::Dilator *)v4);
  }
  else
  {
    v9[0] = off_24C222CC0;
    v9[1] = v4;
    *(_OWORD *)v10 = 0u;
    v11 = 128;
    *(_OWORD *)v12 = 0u;
    v13 = 256;
    RB::Path::BufferedTransform::apply(v3, (uint64_t)v9);
    RB::Path::Reverser::endpath((RB::Path::Reverser *)v9);
    if (v12[0])
      free(v12[0]);
    if (v10[0])
      free(v10[0]);
  }
}

__n128 RB::Path::`anonymous namespace'::Lengths::closepath(RB::Path::_anonymous_namespace_::Lengths *this)
{
  char *v2;
  __n128 *v3;
  __n128 *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  uint64_t v9;
  size_t v10;
  double v11;
  char *v12;
  __n128 result;

  v2 = (char *)this + 8;
  v3 = (__n128 *)((char *)this + 1064);
  v4 = (__n128 *)((char *)this + 1080);
  v5 = *((double *)this + 133);
  v6 = *((double *)this + 134);
  v7 = *((double *)this + 135);
  v8 = *((double *)this + 136);
  v9 = *((_QWORD *)this + 130);
  v10 = v9 + 1;
  if (*((_QWORD *)this + 131) < (unint64_t)(v9 + 1))
  {
    RB::vector<double,128ul,unsigned long>::reserve_slow((char *)this + 8, v10);
    v9 = *((_QWORD *)this + 130);
    v10 = v9 + 1;
  }
  v11 = sqrt((v7 - v5) * (v7 - v5) + (v8 - v6) * (v8 - v6));
  v12 = (char *)*((_QWORD *)this + 129);
  if (!v12)
    v12 = v2;
  *(double *)&v12[8 * v9] = v11;
  *((_QWORD *)this + 130) = v10;
  *((double *)this + 132) = *((double *)this + 132) + v11;
  result = *v4;
  *v3 = *v4;
  return result;
}

__n128 RB::Path::`anonymous namespace'::Lengths::moveto(uint64_t a1, __n128 a2)
{
  __n128 result;

  *(__n128 *)(a1 + 1064) = a2;
  result = *(__n128 *)(a1 + 1064);
  *(__n128 *)(a1 + 1080) = result;
  return result;
}

char *RB::Path::`anonymous namespace'::Lengths::lineto(char *result, __n128 a2)
{
  char *v2;
  char *v3;
  __n128 *v4;
  double v5;
  double v6;
  uint64_t v7;
  size_t v8;
  double v9;
  char *v10;
  __n128 v11;

  v2 = result;
  v3 = result + 8;
  v4 = (__n128 *)(result + 1064);
  v5 = *((double *)result + 133);
  v6 = *((double *)result + 134);
  v7 = *((_QWORD *)result + 130);
  v8 = v7 + 1;
  if (*((_QWORD *)result + 131) < (unint64_t)(v7 + 1))
  {
    v11 = a2;
    result = (char *)RB::vector<double,128ul,unsigned long>::reserve_slow(result + 8, v8);
    a2 = v11;
    v7 = *((_QWORD *)v2 + 130);
    v8 = v7 + 1;
  }
  v9 = sqrt((a2.n128_f64[0] - v5) * (a2.n128_f64[0] - v5) + (a2.n128_f64[1] - v6) * (a2.n128_f64[1] - v6));
  v10 = (char *)*((_QWORD *)v2 + 129);
  if (!v10)
    v10 = v3;
  *(double *)&v10[8 * v7] = v9;
  *((_QWORD *)v2 + 130) = v8;
  *((double *)v2 + 132) = *((double *)v2 + 132) + v9;
  *v4 = a2;
  return result;
}

double RB::Path::`anonymous namespace'::Lengths::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3)
{
  void *v4;
  _OWORD *v5;
  float64x2_t v6;
  float64x2_t v7;
  double v8;
  uint64_t v9;
  size_t v10;
  double *v11;
  double result;
  _BYTE v13[112];
  Point v14[4];
  Point v15[4];
  Point v16[4];

  *(float64x2_t *)&v14[0].v = a3;
  v4 = (void *)(a1 + 8);
  v5 = (_OWORD *)(a1 + 1064);
  v6 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  v7 = vmlaq_f64(a2, v6, vsubq_f64(*(float64x2_t *)(a1 + 1064), a2));
  *(float64x2_t *)&v15[0].v = vmlaq_f64(a2, v6, vsubq_f64(a3, a2));
  *(float64x2_t *)&v16[0].v = v7;
  CG::Cubic::Cubic((CG::Cubic *)v13, (const Point *)(a1 + 1064), v16, v15, v14);
  v8 = CG::Cubic::length((CG::Cubic *)v13, 0.5);
  v9 = *(_QWORD *)(a1 + 1040);
  v10 = v9 + 1;
  if (*(_QWORD *)(a1 + 1048) < (unint64_t)(v9 + 1))
  {
    RB::vector<double,128ul,unsigned long>::reserve_slow(v4, v10);
    v9 = *(_QWORD *)(a1 + 1040);
    v10 = v9 + 1;
  }
  v11 = *(double **)(a1 + 1032);
  if (!v11)
    v11 = (double *)v4;
  v11[v9] = v8;
  *(_QWORD *)(a1 + 1040) = v10;
  *(double *)(a1 + 1056) = *(double *)(a1 + 1056) + v11[v9];
  result = *(double *)&v14[0].v;
  *v5 = *(_OWORD *)&v14[0].v;
  return result;
}

double RB::Path::`anonymous namespace'::Lengths::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  void *v5;
  _OWORD *v6;
  double v7;
  uint64_t v8;
  size_t v9;
  double *v10;
  double result;
  _BYTE v12[112];
  Point v13[4];
  Point v14[4];
  Point v15[4];

  *(__n128 *)&v14[0].v = a3;
  *(__n128 *)&v15[0].v = a2;
  *(__n128 *)&v13[0].v = a4;
  v5 = (void *)(a1 + 8);
  v6 = (_OWORD *)(a1 + 1064);
  CG::Cubic::Cubic((CG::Cubic *)v12, (const Point *)(a1 + 1064), v15, v14, v13);
  v7 = CG::Cubic::length((CG::Cubic *)v12, 0.5);
  v8 = *(_QWORD *)(a1 + 1040);
  v9 = v8 + 1;
  if (*(_QWORD *)(a1 + 1048) < (unint64_t)(v8 + 1))
  {
    RB::vector<double,128ul,unsigned long>::reserve_slow(v5, v9);
    v8 = *(_QWORD *)(a1 + 1040);
    v9 = v8 + 1;
  }
  v10 = *(double **)(a1 + 1032);
  if (!v10)
    v10 = (double *)v5;
  v10[v8] = v7;
  *(_QWORD *)(a1 + 1040) = v9;
  *(double *)(a1 + 1056) = *(double *)(a1 + 1056) + v10[v8];
  result = *(double *)&v13[0].v;
  *v6 = *(_OWORD *)&v13[0].v;
  return result;
}

void *RB::vector<double,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 130) + (*((_QWORD *)__dst + 130) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 130) + (*((_QWORD *)__dst + 130) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 128), __dst, 0x80uLL, (size_t *)__dst + 130, v3);
  *((_QWORD *)__dst + 128) = result;
  return result;
}

void *RB::vector<double,512ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 514) + (*((_QWORD *)__dst + 514) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 514) + (*((_QWORD *)__dst + 514) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 512), __dst, 0x200uLL, (size_t *)__dst + 514, v3);
  *((_QWORD *)__dst + 512) = result;
  return result;
}

void *RB::vector<RB::Path::Projection::Segment,16ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 242) + (*((_QWORD *)__dst + 242) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 242) + (*((_QWORD *)__dst + 242) >> 1);
  result = RB::details::realloc_vector<unsigned long,120ul>(*((void **)__dst + 240), __dst, 0x10uLL, (unint64_t *)__dst + 242, v3);
  *((_QWORD *)__dst + 240) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,120ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 120 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(120 * a5);
    v9 = v8 / 0x78;
    if (v8 / 0x78 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 120 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::Contents::empty_contents(RB::DisplayList::Contents *this)
{
  unsigned __int8 v1;

  if ((v1 & 1) == 0
  {
    RB::DisplayList::Contents::empty_contents(void)::shared_empty = (uint64_t)RB::DisplayList::Contents::empty_contents(void)::$_0::operator()();
  }
  return RB::DisplayList::Contents::empty_contents(void)::shared_empty;
}

void sub_209B82D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

RB::DisplayList::Contents *RB::DisplayList::Contents::empty_contents(void)::$_0::operator()()
{
  RB::DisplayList::Contents *v0;

  v0 = (RB::DisplayList::Contents *)operator new();
  RB::DisplayList::Contents::Contents(v0, 0);
  *((_BYTE *)v0 + 400) = 0;
  return v0;
}

void sub_209B82D78(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Contents::intern_uuid(RB::DisplayList::Contents *this, const UUID *a2)
{
  uint64_t result;
  BOOL v5;

  if (!a2)
    return 0;
  result = *((_QWORD *)this + 49);
  if (!result
    || (*(_QWORD *)result == *(_QWORD *)a2 ? (v5 = *(_QWORD *)(result + 8) == *(_QWORD *)&(*a2)[8]) : (v5 = 0), !v5))
  {
    result = *((_QWORD *)this + 4);
    if ((unint64_t)(result + 16) > *((_QWORD *)this + 5))
      result = RB::Heap::alloc_slow((size_t *)this + 2, 0x10uLL, 0);
    else
      *((_QWORD *)this + 4) = result + 16;
    *(_OWORD *)result = *(_OWORD *)a2;
    *((_QWORD *)this + 49) = result;
  }
  return result;
}

uint64_t *RB::DisplayList::Contents::copy_atoms(RB::DisplayList::Contents *this, const RB::DisplayList::Metadata **a2, unsigned int a3, unsigned int a4)
{
  uint64_t *result;
  RB::Heap *v9;
  _DWORD *v10;

  result = (uint64_t *)*a2;
  if (*a2)
  {
    result = RB::DisplayList::Metadata::text_identity(result);
    if (result)
    {
      v9 = (RB::DisplayList::Contents *)((char *)this + 16);
      v10 = RB::TextIdentity::copy_atoms((RB::TextIdentity *)result, v9, a3, a4);
      result = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>(v9, a2, (uint64_t *)&v10);
      *a2 = (const RB::DisplayList::Metadata *)result;
    }
  }
  return result;
}

_QWORD *RB::DisplayList::Contents::get_cgimage(_QWORD *result, const void **a2, double a3)
{
  uint64_t v4;
  float64x2_t *v12;

  if (*((float *)result + 92) == 0.0)
  {
    v4 = result[40];
    if (v4)
    {
      if (!*(_QWORD *)(v4 + 8)
        && !result[42]
        && !*((_BYTE *)result + 384)
        && (*((_WORD *)result + 190) & 0x2001) == 0
        && !*(_QWORD *)(v4 + 24)
        && !*(_QWORD *)(v4 + 16))
      {
        _H0 = *(_WORD *)(v4 + 44);
        __asm { FCVT            S0, H0 }
        if (_S0 == 1.0 && (*(_WORD *)(v4 + 46) & 0x3F) == 2)
        {
          result = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)v4 + 16))(result[40]);
          if ((_DWORD)result == 12587009)
          {
            v12 = *(float64x2_t **)(v4 + 48);
            if (v12)
            {
              result = (_QWORD *)RB::Coverage::Primitive::contains((float32x2_t *)(v4 + 64), *(_QWORD *)(v4 + 48), 0, vcvt_f32_s32(*(int32x2_t *)&a3));
              if ((_DWORD)result)
                return RB::Fill::Image<RB::ImageTexture>::get_cgimage((RB::ImageTexture *)(v4 + 112), v12, a2, a3);
            }
          }
        }
      }
    }
  }
  return result;
}

const void *RB::Fill::Image<RB::ImageTexture>::get_cgimage(RB::ImageTexture *a1, float64x2_t *a2, const void **a3, double a4)
{
  const void *result;
  const void *v7;

  result = (const void *)RB::Fill::ImageData::can_get_image((uint64_t)a1 + 16, a2, a4);
  if ((_DWORD)result)
  {
    v7 = (const void *)RB::ImageTexture::cg_image(a1);
    result = *a3;
    if (*a3 != v7)
    {
      if (result)
        CFRelease(result);
      if (v7)
        result = CFRetain(v7);
      else
        result = 0;
      *a3 = result;
    }
  }
  return result;
}

void RB::DisplayList::Contents::print(RB::DisplayList::Contents *this, std::string *a2)
{
  RB::SexpString::push(a2, "display-list");
  if (!*((_BYTE *)this + 400))
    RB::SexpString::print(a2, 0, "optimized");
  RB::DisplayList::Layer::print((RB::DisplayList::Contents *)((char *)this + 320), a2);
  RB::SexpString::pop(a2);
}

uint64_t RB::Refcount<RB::DisplayList::Contents,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

_DWORD *RB::DisplayList::AtomizedItems::advance(_DWORD *this, int a2)
{
  int v2;
  int v3;
  _DWORD *v4;
  int v5;

  v2 = this[4];
  v3 = this[3] + a2;
  this[3] = v3;
  if (v3 == v2)
  {
    v4 = this;
    this = *(_DWORD **)(*(_QWORD *)this + 8);
    *(_QWORD *)v4 = this;
    *((_QWORD *)v4 + 1) = (v4[2] + 1);
    if (this)
      this = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)this + 40))(this);
    *((_BYTE *)v4 + 20) = (_DWORD)this != -1;
    if ((_DWORD)this == -1)
      v5 = 1;
    else
      v5 = (int)this;
    v4[4] = v5;
    *((_BYTE *)v4 + 88) = 0;
  }
  return this;
}

uint64_t RB::DisplayList::AtomizedItems::reset(uint64_t this, const RB::DisplayList::Item *a2, int a3, int a4)
{
  uint64_t v5;
  int v6;

  v5 = this;
  if (*(const RB::DisplayList::Item **)this != a2)
  {
    *(_QWORD *)this = a2;
    *(_DWORD *)(this + 8) = a3;
    if (a2)
      this = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(_QWORD *)a2 + 40))(a2);
    else
      this = 0;
    *(_BYTE *)(v5 + 20) = (_DWORD)this != -1;
    if ((_DWORD)this == -1)
      v6 = 1;
    else
      v6 = this;
    *(_DWORD *)(v5 + 16) = v6;
    *(_BYTE *)(v5 + 88) = 0;
  }
  *(_DWORD *)(v5 + 12) = a4;
  return this;
}

uint64_t RB::DisplayList::AtomizedItems::copy(RB::DisplayList::AtomizedItems *this, RB::DisplayList::Builder *a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, RB::DisplayList::Builder *, _QWORD, uint64_t, uint64_t))(**(_QWORD **)this
                                                                                                 + 48))(*(_QWORD *)this, a2, *((unsigned int *)this + 3), a3, a4);
}

uint64_t RB::DisplayList::AtomizedItems::mix(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::AtomizedItems *a3, RB::DisplayList::CachedTransform *a4)
{
  return (*(uint64_t (**)(_QWORD, const RB::DisplayList::Interpolator::State *, _QWORD, RB::DisplayList::CachedTransform *))(**(_QWORD **)this + 216))(*(_QWORD *)this, a2, *(_QWORD *)a3, a4);
}

const RB::DisplayList::ClipNode *RB::DisplayList::AtomizedItems::mix_clip_style(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::AtomizedItems *a3, RB::DisplayList::CachedTransform *a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const RB::DisplayList::Style *v11;
  const RB::DisplayList::Style *v12;
  uint64_t v13;
  const RB::DisplayList::ClipNode *result;

  v7 = *(_QWORD *)this;
  v8 = *(_QWORD *)(*(_QWORD *)this + 24);
  v9 = *(_QWORD *)a3;
  if (*((_QWORD *)this + 3) != v8)
  {
    v10 = *(_QWORD *)(v9 + 24);
LABEL_3:
    v11 = *(const RB::DisplayList::Style **)(v7 + 16);
    v12 = *(const RB::DisplayList::Style **)(v9 + 16);
    *((_QWORD *)this + 6) = v11;
    *((_QWORD *)this + 7) = v12;
    *((_QWORD *)this + 3) = v8;
    *((_QWORD *)this + 4) = v10;
    *((_WORD *)this + 56) = 256;
LABEL_9:
    v13 = RB::DisplayList::CachedTransform::mix_style(a4, a2, v11, v12, 1);
    *((_QWORD *)this + 8) = v13;
    result = RB::DisplayList::CachedTransform::mix_clip((const RB::DisplayList::ClipNode **)a4, a2, *((const RB::DisplayList::ClipNode **)this + 3), *((const RB::DisplayList::ClipNode **)this + 4), v13 == 0);
    *((_QWORD *)this + 5) = result;
    return result;
  }
  v10 = *((_QWORD *)this + 4);
  if (v10 == *(_QWORD *)(v9 + 24))
    goto LABEL_3;
  v11 = *(const RB::DisplayList::Style **)(v7 + 16);
  if (*((const RB::DisplayList::Style **)this + 6) != v11)
  {
    v12 = *(const RB::DisplayList::Style **)(v9 + 16);
LABEL_8:
    *((_QWORD *)this + 6) = v11;
    *((_QWORD *)this + 7) = v12;
    goto LABEL_9;
  }
  v12 = *(const RB::DisplayList::Style **)(v9 + 16);
  if (*((const RB::DisplayList::Style **)this + 7) != v12)
    goto LABEL_8;
  return (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 5);
}

uint64_t RB::DisplayList::AtomizedItems::clipped_bounds(RB::DisplayList::AtomizedItems *this)
{
  uint64_t v2;

  if (!*((_BYTE *)this + 88))
  {
    *((double *)this + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)this);
    *((_QWORD *)this + 10) = v2;
    *((_BYTE *)this + 88) = 1;
  }
  return (uint64_t)this + 72;
}

uint64_t RB::DisplayList::AtomizedItems::atom_bounds(RB::DisplayList::AtomizedItems *this, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t))(**(_QWORD **)this + 64))(*(_QWORD *)this, *((unsigned int *)this + 3), a2);
}

uint64_t RB::DisplayList::AtomizedItems::mix_clip_bounds(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, RB::Rect *a3, float32x2_t **a4)
{
  float32x2_t *v7;
  float32x2_t *v8;
  float32x2_t *v9;
  _QWORD *v10;
  uint64_t result;
  float32x2_t v12;
  _QWORD *v13;
  __int16 v14;

  v7 = (float32x2_t *)this[3];
  v8 = *(float32x2_t **)(*(_QWORD *)this + 24);
  v9 = *a4;
  if (v7 == v8)
  {
    v10 = (_QWORD *)this[4];
    v13 = (_QWORD *)v9[3];
    if (v10 != v13)
    {
      if (this[14].i8[1])
      {
        if (this[14].i8[0])
          goto LABEL_8;
      }
      else
      {
        v14 = RB::DisplayList::CachedTransform::mix_clip_bounds((uint64_t)a2, this + 12, v7, v13);
        this[14].i16[0] = v14 | 0x100;
        if ((v14 & 1) != 0)
          goto LABEL_8;
      }
      return 0;
    }
  }
  else
  {
    v10 = (_QWORD *)v9[3];
  }
  result = RB::DisplayList::CachedTransform::mix_clip_bounds((uint64_t)a2, this + 12, v8, v10);
  this[14].i16[0] = result | 0x100;
  v12 = (*a4)[3];
  this[3] = *(float32x2_t *)(*(_QWORD *)this + 24);
  this[4] = v12;
  this[6] = (float32x2_t)1;
  if ((_DWORD)result)
  {
LABEL_8:
    *(_OWORD *)a3 = *(_OWORD *)this[12].f32;
    return 1;
  }
  return result;
}

const RB::Transition *RB::DisplayList::AtomizedItems::transition(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = *(uint64_t **)(*(_QWORD *)this + 32);
  if (v3)
    v4 = RB::DisplayList::Metadata::transition(v3);
  else
    v4 = 0;
  return RB::DisplayList::Interpolator::Layer::item_transition(a2, (const RB::Transition *)v4);
}

unint64_t RB::DisplayList::AtomizedItems::animation_layer(RB::DisplayList::AtomizedItems *this)
{
  uint64_t *v1;
  uint64_t *v2;
  unint64_t v3;
  uint64_t v4;

  v1 = *(uint64_t **)(*(_QWORD *)this + 32);
  if (v1 && (v2 = RB::DisplayList::Metadata::animation_layer(v1)) != 0)
  {
    v3 = *v2 & 0xFFFFFFFF00000000;
    v4 = *v2;
  }
  else
  {
    v4 = 0;
    v3 = 0x100000000;
  }
  return v4 | v3;
}

uint64_t RB::DisplayList::AtomizedItems::apply_effects(uint64_t result, const RB::DisplayList::Interpolator::Layer *a2, uint64_t a3, unsigned int a4, float32x2_t **a5, uint64_t a6)
{
  const RB::DisplayList::Interpolator::Layer *v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  __int16 *v19;
  uint64_t *v20;
  unint64_t v21;
  char v22;
  char v23;
  __int16 v24;
  int v25;
  int v26;
  char *v27;
  float32x2_t *v28;
  double v29;
  float32x2_t *v30;
  int32x2_t v31;
  float32x2_t v32;
  uint64_t v33;
  float32x2_t v34;
  char v35;
  float32x2_t v36;
  int8x8_t v37;
  unsigned int v38;
  int8x8_t v39;
  float32x2_t v40;
  float v41;
  float32x2_t v42;
  float v43;
  uint64_t v44;
  uint64_t v45;
  BOOL v46;
  int v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  int v51;
  unsigned int v52;
  unsigned int v53;
  int v54;
  float v55;
  int v56;
  unsigned int v57;
  int v58;
  int v59;
  float v60;
  uint64_t v61;
  uint64_t v62;
  char *v63;
  float32x2_t v64;
  float v65;
  float64x2_t v66;
  float64x2_t v67;
  double v68;
  unsigned __int8 *v69;
  float v70;
  unsigned int v71;
  float32x2_t v72;
  float32x2_t v73;
  char v74;
  double v75;
  uint64_t v76;
  float32x2_t v77;
  double v78;
  double v79;
  double v80;
  int32x4_t v81;
  float32x2_t *v82;
  uint64_t v83;
  float32x2_t v84;
  double v85;
  double v86;
  int32x4_t v87;
  float32x2_t *v88;
  uint64_t v89;
  float32x2_t v90;
  double v91;
  int32x4_t v92;
  float32x2_t *v93;
  uint64_t v94;
  float32x2_t v95;
  double v96;
  int32x4_t v97;
  float32x2_t *v98;
  _QWORD *v99;
  uint64_t v100;
  double v101;
  int32x4_t v102;
  float32x2_t *v103;
  uint64_t v104;
  float32x2_t v105;
  char *v106;
  uint64_t v107;
  double *v108;
  double v109;
  double v110;
  uint64_t v111;
  char *v112;
  double v113;
  float32x2_t v114;
  double v115;
  float32x2_t v116;
  float32x2_t v117;
  float32x2_t v118;
  float32x2_t v119;
  float32x2_t v120;
  float32x2_t v121;
  float32x2_t v122;
  double v123;
  float64x2_t v124;
  float64x2_t v125;
  uint64_t v126;
  float32x2_t v127;
  int8x8_t v128;
  unsigned int v129;
  int8x8_t v130;
  uint64_t v131;
  uint64_t v132;
  unsigned int v133;
  float32x2_t v134;
  float64x2_t v135;
  float64x2_t v136;
  _OWORD *v137;
  int v138;
  const RB::DisplayList::Interpolator::Layer *v139;
  float32x2_t v140;
  double v141;
  double v142;
  float32x2_t v143;
  float v144;
  char *v145;
  RB::DisplayList::AtomizedItems *v147;
  float32x2_t v148[4];

  v147 = (RB::DisplayList::AtomizedItems *)result;
  if (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 32) != -1)
  {
    v9 = a2;
    result = (uint64_t)RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)result, a2);
    if (*(_DWORD *)(result + 48))
    {
      v14 = result;
      v15 = 0;
      v16 = result + 24;
      v137 = (_OWORD *)((char *)v147 + 72);
      v145 = (char *)v9 + 200;
      if ((a4 & 1) != 0)
        v17 = 2;
      else
        v17 = 1;
      v138 = v17;
      result = 16;
      v139 = v9;
      do
      {
        v18 = *(_QWORD *)(v14 + 40);
        if (!v18)
          v18 = v16;
        v19 = (__int16 *)(v18 + 4 * v15);
        v20 = *(uint64_t **)(a3 + 8);
        v21 = *v20;
        if ((*v20 & 0x100000000) != 0)
          v22 = 4;
        else
          v22 = 8;
        if ((v21 & 0x400000000) != 0)
          v23 = 16;
        else
          v23 = 32;
        v24 = *v19;
        if (((v22 | v23 | a4) & HIBYTE(*v19) & 0x3F) == a4)
        {
          v25 = v24 & 0x7F;
          v26 = (v21 >> 35) & (v24 < 0) ^ (a4 >> 1) & ((unsigned __int16)(v24 & 0x4000) >> 14);
          switch(v24 & 0x7F)
          {
            case 1:
              *(float *)v10.f64 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v10.f64[0], v11.f64[0], v12.f64[0], *(float *)v13.f64);
              result = 16;
              if (*(float *)v10.f64 < 0.0)
                *(float *)v10.f64 = 0.0;
              if (*(float *)v10.f64 > 1.0)
                *(float *)v10.f64 = 1.0;
              LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 56);
              *(float *)v10.f64 = *(float *)v10.f64 * *(float *)v11.f64;
              *(_DWORD *)(a6 + 56) = LODWORD(v10.f64[0]);
              break;
            case 2:
            case 6:
              if ((v24 & 0x7F) == 6)
              {
                if (a5)
                {
                  *(double *)&v33 = COERCE_DOUBLE(((uint64_t (*)(float32x2_t **, _QWORD, unsigned __int8 *))(*a5)[7])(a5, 0, RB::Transition::_effect_args));
                  if (!v35)
                  {
                    v148[0] = COERCE_FLOAT32X2_T(RB::DisplayList::Item::clipped_bounds(a5));
                    goto LABEL_157;
                  }
LABEL_89:
                  v75 = *(double *)&v33;
                }
                else
                {
                  *(double *)&v33 = COERCE_DOUBLE((*(uint64_t (**)(_QWORD, _QWORD, unsigned __int8 *))(**(_QWORD **)v147 + 56))(*(_QWORD *)v147, *((unsigned int *)v147 + 3), RB::Transition::_effect_args));
                  if (v74)
                    goto LABEL_89;
                  v99 = *(_QWORD **)(a3 + 8);
                  v100 = 20;
                  if ((a4 & 1) == 0)
                    v100 = 12;
                  if (*(_DWORD *)((char *)v99 + v100) || *((_DWORD *)v147 + 4) > (*v99 >> 36))
                  {
                    v148[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD))(**(_QWORD **)v147 + 64))(*(_QWORD *)v147));
                    v148[1] = v34;
                    v103 = *(float32x2_t **)(*(_QWORD *)v147 + 24);
                    if (v103)
                      RB::Rect::intersect(v148, v103[2], v103[3], v12.f64[0], v13.f64[0], v101, v102);
                  }
                  else
                  {
                    if (!*((_BYTE *)v147 + 88))
                    {
                      *((double *)v147 + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)v147);
                      *((float32x2_t *)v147 + 10) = v34;
                      *((_BYTE *)v147 + 88) = 1;
                    }
                    *(_OWORD *)v148[0].f32 = *v137;
                  }
LABEL_157:
                  v75 = *(double *)v148;
                }
                v141 = v75;
                goto LABEL_159;
              }
              if (a5)
              {
                v148[0] = COERCE_FLOAT32X2_T(RB::DisplayList::Item::clipped_bounds(a5));
                v148[1] = v72;
              }
              else
              {
                v94 = 20;
                if ((a4 & 1) == 0)
                  v94 = 12;
                if (*(_DWORD *)((char *)v20 + v94) || *((_DWORD *)v147 + 4) > v21 >> 36)
                {
                  v148[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD))(**(_QWORD **)v147 + 64))(*(_QWORD *)v147));
                  v148[1] = v95;
                  v98 = *(float32x2_t **)(*(_QWORD *)v147 + 24);
                  if (v98)
                    RB::Rect::intersect(v148, v98[2], v98[3], v12.f64[0], v13.f64[0], v96, v97);
                }
                else
                {
                  if (!*((_BYTE *)v147 + 88))
                  {
                    *((double *)v147 + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)v147);
                    *((_QWORD *)v147 + 10) = v132;
                    *((_BYTE *)v147 + 88) = 1;
                  }
                  *(_OWORD *)v148[0].f32 = *v137;
                }
              }
              v75 = *(double *)&v148[1];
              v34 = vmla_f32(v148[0], (float32x2_t)0x3F0000003F000000, v148[1]);
              v141 = *(double *)&v34;
LABEL_159:
              v34.i32[0] = *((_DWORD *)v19 + 1);
              if (v26)
              {
                v133 = *((_DWORD *)v19 + 1);
                v134 = vrecpe_f32((float32x2_t)v34.u32[0]);
                *(float32x2_t *)&v12.f64[0] = vrecps_f32((float32x2_t)v133, v134);
                v34 = vmul_f32(*(float32x2_t *)&v12.f64[0], v134);
                v75 = COERCE_DOUBLE(vmul_f32(v34, vrecps_f32((float32x2_t)v133, v34)));
                v144 = *(float *)&v75;
              }
              else
              {
                v144 = *((float *)v19 + 1);
              }
              *(float *)v10.f64 = fmaxf(v144+ (float)((float)(1.0 - v144)* RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v75, *(double *)&v34, v12.f64[0], *(float *)v13.f64)), 0.0);
              v135 = *(float64x2_t *)(a6 + 16);
              v13 = vmulq_n_f64(*(float64x2_t *)a6, *(float *)v10.f64);
              v11 = vmulq_n_f64(v135, *(float *)v10.f64);
              v12.f64[0] = (float)-*((float *)&v141 + 1);
              v136 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, *(float *)&v141), v135, *((float *)&v141 + 1)), v13, (float)-*(float *)&v141), v11, v12.f64[0]);
              *(float64x2_t *)a6 = v13;
              *(float64x2_t *)(a6 + 16) = v11;
              *(float64x2_t *)(a6 + 32) = v136;
              result = 16;
              if (*(_BYTE *)(a6 + 52))
              {
                LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 48);
                *(float *)v10.f64 = *(float *)v11.f64 * *(float *)v10.f64;
                goto LABEL_164;
              }
              break;
            case 3:
              v36 = *(float32x2_t *)(v19 + 2);
              v37 = (int8x8_t)vneg_f32(v36);
              if (v26)
                v38 = -1;
              else
                v38 = 0;
              v39 = (int8x8_t)vdup_n_s32(v38);
              v40 = (float32x2_t)vbsl_s8(v39, v37, (int8x8_t)v36);
              v41 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, *(double *)&v36, *(double *)&v37, *(double *)&v39, *(float *)v13.f64);
              result = 16;
              v42 = vmul_n_f32(v40, 1.0 - v41);
              goto LABEL_87;
            case 4:
              v43 = *((float *)v19 + 1);
              if (v43 > 0.0)
                goto LABEL_147;
              break;
            case 5:
              v45 = *((unsigned int *)v20 + 6);
              v44 = *((unsigned int *)v20 + 7);
              if (*((_DWORD *)v20 + 6))
                v46 = v44 == 1;
              else
                v46 = 1;
              v47 = v46;
              if (a5)
              {
                v148[0] = COERCE_FLOAT32X2_T(RB::DisplayList::Item::clipped_bounds(a5));
                v148[1] = v48;
              }
              else
              {
                v76 = 20;
                if ((a4 & 1) == 0)
                  v76 = 12;
                if (*(_DWORD *)((char *)v20 + v76) || *((_DWORD *)v147 + 4) > v21 >> 36)
                {
                  v148[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD))(**(_QWORD **)v147 + 64))(*(_QWORD *)v147));
                  v148[1] = v77;
                  v82 = *(float32x2_t **)(*(_QWORD *)v147 + 24);
                  if (v82)
                    RB::Rect::intersect(v148, v82[2], v82[3], v78, v79, v80, v81);
                }
                else
                {
                  if (!*((_BYTE *)v147 + 88))
                  {
                    *((double *)v147 + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)v147);
                    *((_QWORD *)v147 + 10) = v104;
                    *((_BYTE *)v147 + 88) = 1;
                  }
                  *(_OWORD *)v148[0].f32 = *v137;
                }
              }
              v105 = v148[1];
              v106 = (char *)*((_QWORD *)v139 + 29);
              if (!v106)
                v106 = v145;
              if (v47)
                v107 = 0;
              else
                v107 = v45;
              v108 = (double *)&v106[16 * v107];
              v110 = *v108;
              v109 = v108[1];
              if (v47)
                v111 = 1;
              else
                v111 = v44;
              v112 = &v106[16 * v111];
              v114 = *(float32x2_t *)v112;
              v113 = *((double *)v112 + 1);
              if ((a4 & 1) != 0)
              {
                v115 = v110;
                v116 = *(float32x2_t *)&v109;
              }
              else
              {
                v115 = *(double *)v112;
                v116 = *(float32x2_t *)(v112 + 8);
                v114 = *(float32x2_t *)&v110;
                v113 = v109;
              }
              v9 = v139;
              v140 = v148[0];
              v143 = vadd_f32(vdiv_f32(vmul_f32(vsub_f32(v148[0], v114), v116), *(float32x2_t *)&v113), *(float32x2_t *)&v115);
              v117 = vmul_f32(v116, v148[1]);
              v118 = vdiv_f32(v117, *(float32x2_t *)&v113);
              *(float *)v10.f64 = RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v113, *(double *)&v117, v115, v116.f32[0]);
              v119 = vadd_f32(v143, v118);
              v120 = vmla_n_f32(v143, vsub_f32(v140, v143), *(float *)v10.f64);
              *(float32x2_t *)&v11.f64[0] = vsub_f32(vmla_n_f32(v119, vsub_f32(vadd_f32(v105, v140), v119), *(float *)v10.f64), v120);
              *(float32x2_t *)&v10.f64[0] = vdiv_f32(*(float32x2_t *)&v11.f64[0], v105);
              v121 = vmla_f32(v140, (float32x2_t)0x3F0000003F000000, v105);
              v122 = vmla_f32(v120, (float32x2_t)0x3F0000003F000000, *(float32x2_t *)&v11.f64[0]);
              v11.f64[0] = v122.f32[0];
              v123 = v122.f32[1];
              v124 = *(float64x2_t *)(a6 + 16);
              v125 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v11.f64[0]), v124, v123);
              LODWORD(v11.f64[0]) = HIDWORD(v10.f64[0]);
              v12 = vmulq_n_f64(*(float64x2_t *)a6, *(float *)v10.f64);
              v13 = vmulq_n_f64(v124, *((float *)v10.f64 + 1));
              *(float64x2_t *)a6 = v12;
              *(float64x2_t *)(a6 + 16) = v13;
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(v125, v13, (float)-v121.f32[1]), v12, (float)-v121.f32[0]);
              result = 16;
              if (*(_BYTE *)(a6 + 52))
              {
                *(float *)v11.f64 = 0.5 * *(float *)(a6 + 48);
                *(float *)v10.f64 = (float)(*(float *)v10.f64 + *((float *)v10.f64 + 1)) * *(float *)v11.f64;
LABEL_164:
                *(_DWORD *)(a6 + 48) = LODWORD(v10.f64[0]);
              }
              break;
            case 7:
            case 8:
            case 9:
            case 0xA:
              v27 = (char *)*((_QWORD *)v9 + 29);
              if (!v27)
                v27 = v145;
              v28 = (float32x2_t *)&v27[16 * *((unsigned int *)v20 + 6)];
              v29 = *(double *)v28;
              v30 = (float32x2_t *)&v27[16 * *((unsigned int *)v20 + 7)];
              v31 = (int32x2_t)*v30;
              v32 = vsub_f32(*v30, *v28);
              if (v25 == 7)
              {
                v32.i32[1] = 0;
              }
              else
              {
                *(float32x2_t *)&v12.f64[0] = v28[1];
                v29 = COERCE_DOUBLE(vsub_f32(vadd_f32(v30[1], (float32x2_t)v31), vadd_f32(*(float32x2_t *)&v12.f64[0], *(float32x2_t *)&v29)));
                v31.i32[1] = HIDWORD(v29);
                v31.i32[0] = 0;
                v32.i32[0] = 0;
                HIDWORD(v29) = 0;
                if (v25 != 8)
                  v29 = *(double *)&v32;
                if (v25 == 10)
                  v32 = (float32x2_t)v31;
                else
                  *(double *)&v32 = v29;
              }
              if (*((float *)v20 + 9) == 0.0)
              {
                v70 = *(float *)(a3 + 16);
                goto LABEL_84;
              }
              v142 = *(double *)&v32;
              if ((a4 & 1) != 0)
              {
                if ((v24 & 0x80) == 0)
                {
LABEL_76:
                  v71 = 0;
                  goto LABEL_81;
                }
                v69 = (unsigned __int8 *)(v19 + 1);
              }
              else
              {
                if ((v24 & 0x80) == 0)
                  goto LABEL_76;
                v69 = (unsigned __int8 *)v19 + 3;
              }
              v71 = *v69;
LABEL_81:
              LODWORD(v29) = *(_DWORD *)(a3 + 20);
              RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)v9, *((_DWORD *)v20 + 8), v71, v29, *(double *)&v31);
              if (*(_BYTE *)(a3 + 28))
                v70 = 1.0 - v70;
              result = 16;
              *(double *)&v32 = v142;
LABEL_84:
              v31.i32[0] = 0;
              LODWORD(v12.f64[0]) = a4 & 2;
              v73 = (float32x2_t)vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vceq_s32(*(int32x2_t *)&v12.f64[0], v31)), 0), (int8x8_t)v32, (int8x8_t)vneg_f32(v32));
              if ((a4 & 1) != 0)
                v70 = 1.0 - v70;
              v42 = vmul_n_f32(v73, v70);
LABEL_87:
              v11.f64[0] = v42.f32[0];
              v10.f64[0] = v42.f32[1];
              v12 = *(float64x2_t *)a6;
              v13 = *(float64x2_t *)(a6 + 16);
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v11.f64[0]), v13, v10.f64[0]);
              break;
            case 0xF:
              if (a5)
              {
                v148[0] = COERCE_FLOAT32X2_T(RB::DisplayList::Item::clipped_bounds(a5));
                v148[1] = v49;
              }
              else
              {
                v83 = 20;
                if ((a4 & 1) == 0)
                  v83 = 12;
                if (*(_DWORD *)((char *)v20 + v83) || *((_DWORD *)v147 + 4) > v21 >> 36)
                {
                  v148[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD))(**(_QWORD **)v147 + 64))(*(_QWORD *)v147));
                  v148[1] = v84;
                  v88 = *(float32x2_t **)(*(_QWORD *)v147 + 24);
                  if (v88)
                    RB::Rect::intersect(v148, v88[2], v88[3], v85, v13.f64[0], v86, v87);
                }
                else
                {
                  if (!*((_BYTE *)v147 + 88))
                  {
                    *((double *)v147 + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)v147);
                    *((_QWORD *)v147 + 10) = v126;
                    *((_BYTE *)v147 + 88) = 1;
                  }
                  *(_OWORD *)v148[0].f32 = *v137;
                }
              }
              v127 = vmul_f32(*(float32x2_t *)(v19 + 2), v148[1]);
              v128 = (int8x8_t)vneg_f32(v127);
              if (v26)
                v129 = -1;
              else
                v129 = 0;
              v130 = (int8x8_t)vdup_n_s32(v129);
              *(float32x2_t *)&v10.f64[0] = vmul_n_f32((float32x2_t)vbsl_s8(v130, v128, (int8x8_t)v127), 1.0- RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, *(double *)&v127, *(double *)&v128, *(double *)&v130, *(float *)v13.f64));
              v11.f64[0] = *(float *)v10.f64;
              v10.f64[0] = *((float *)v10.f64 + 1);
              v12 = *(float64x2_t *)a6;
              v13 = *(float64x2_t *)(a6 + 16);
              *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v11.f64[0]), v13, v10.f64[0]);
              result = 16;
              break;
            case 0x10:
              if (a5)
              {
                v148[0] = COERCE_FLOAT32X2_T(RB::DisplayList::Item::clipped_bounds(a5));
                v148[1] = v50;
              }
              else
              {
                v89 = 20;
                if ((a4 & 1) == 0)
                  v89 = 12;
                if (*(_DWORD *)((char *)v20 + v89) || *((_DWORD *)v147 + 4) > v21 >> 36)
                {
                  v148[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD))(**(_QWORD **)v147 + 64))(*(_QWORD *)v147));
                  v148[1] = v90;
                  v93 = *(float32x2_t **)(*(_QWORD *)v147 + 24);
                  if (v93)
                    RB::Rect::intersect(v148, v93[2], v93[3], v12.f64[0], v13.f64[0], v91, v92);
                }
                else
                {
                  if (!*((_BYTE *)v147 + 88))
                  {
                    *((double *)v147 + 9) = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)v147);
                    *((_QWORD *)v147 + 10) = v131;
                    *((_BYTE *)v147 + 88) = 1;
                  }
                  *(_OWORD *)v148[0].f32 = *v137;
                }
              }
              v11.f64[0] = *(float64_t *)(v19 + 2);
              *(float32x2_t *)&v10.f64[0] = vmul_f32(*(float32x2_t *)&v11.f64[0], v148[1]);
              v43 = vaddv_f32(*(float32x2_t *)&v10.f64[0]);
              result = 16;
              if (v43 > 0.0)
              {
LABEL_147:
                *(float *)v10.f64 = fmaxf(v43- (float)(RB::DisplayList::Interpolator::State::effect_time((RB::DisplayList::Interpolator::State *)a3, (const RB::Transition *)v14, (const Effect *)v19, a4, v10.f64[0], v11.f64[0], v12.f64[0], *(float *)v13.f64)* v43), 0.0);
                if (*(_BYTE *)(a6 + 52))
                {
                  LODWORD(v11.f64[0]) = *(_DWORD *)(a6 + 48);
                  *(float *)v10.f64 = sqrtf((float)(*(float *)v10.f64 * *(float *)v10.f64)+ (float)(*(float *)v11.f64 * *(float *)v11.f64));
                }
                result = 16;
                *(_DWORD *)(a6 + 48) = LODWORD(v10.f64[0]);
                *(_BYTE *)(a6 + 52) = 1;
              }
              break;
            case 0x11:
              v51 = *((_DWORD *)v19 + 1);
              if ((v51 & 0xF) == 3)
                v52 = 0x80000000;
              else
                v52 = 0x40000000;
              if ((v51 & 0xF) == 1)
                v53 = 0;
              else
                v53 = v52;
              v54 = (v53 | v51 & 0x10) ^ 0x10;
              v55 = *((float *)v19 + 2) * *(float *)(a3 + 20);
              v148[0] = (float32x2_t)RB::DisplayList::AtomizedItems::animation_layer(v147);
              v9 = v139;
              *(float *)v10.f64 = RB::Symbol::Animation::eval_appear_disappear((_DWORD *)(a4 & 1), v54, v148, v55);
              goto LABEL_63;
            case 0x12:
              v56 = *((_DWORD *)v19 + 1);
              v57 = (v56 & 0xF) - 1;
              if (v57 >= 4)
                v58 = 0x40000000;
              else
                v58 = v57 << 30;
              v59 = (v58 | v56 & 0x10) ^ 0x10;
              v60 = *((float *)v19 + 2) * *(float *)(a3 + 20);
              v148[0] = (float32x2_t)RB::DisplayList::AtomizedItems::animation_layer(v147);
              *(float *)v10.f64 = RB::Symbol::Animation::eval_replace(v138, v59, v148, v60);
LABEL_63:
              LODWORD(v12.f64[0]) = *(_DWORD *)(a6 + 56);
              *(float *)v11.f64 = *(float *)v12.f64 * *(float *)v11.f64;
              *(_DWORD *)(a6 + 56) = LODWORD(v11.f64[0]);
              result = 16;
              if (*(float *)v10.f64 != 1.0)
              {
                v61 = 28;
                if ((a4 & 1) == 0)
                  v61 = 24;
                v62 = *(unsigned int *)(*(_QWORD *)(a3 + 8) + v61);
                v63 = (char *)*((_QWORD *)v9 + 29);
                if (!v63)
                  v63 = v145;
                v64 = vmla_f32(*(float32x2_t *)&v63[16 * v62], (float32x2_t)0x3F0000003F000000, *(float32x2_t *)&v63[16 * v62 + 8]);
                v65 = v64.f32[1];
                v66 = *(float64x2_t *)(a6 + 16);
                v67 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a6 + 32), *(float64x2_t *)a6, v64.f32[0]), v66, v64.f32[1]);
                v68 = *(float *)v10.f64;
                v12 = vmulq_n_f64(*(float64x2_t *)a6, v68);
                v10 = vmulq_n_f64(v66, v68);
                v11.f64[0] = (float)-v64.f32[0];
                v13.f64[0] = (float)-v65;
                *(float64x2_t *)a6 = v12;
                *(float64x2_t *)(a6 + 16) = v10;
                *(float64x2_t *)(a6 + 32) = vmlaq_n_f64(vmlaq_n_f64(v67, v12, v11.f64[0]), v10, v13.f64[0]);
              }
              break;
            default:
              break;
          }
        }
        v15 += RB::Transition::_effect_args[*v19 & 0x7F] + 1;
      }
      while (v15 < *(_DWORD *)(v14 + 48));
    }
  }
  return result;
}

void RB::DisplayList::AtomizedItems::effect_bounds(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2, const RB::DisplayList::Interpolator::State *a3, unsigned int a4)
{
  double v8;
  float32x2_t v9;
  float32x2_t v10;
  uint32x2_t v11;
  float64x2_t v12[2];
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v16;
  float v17;

  if (*((_BYTE *)this + 88))
  {
    v8 = *((double *)this + 9);
    v9 = *(float32x2_t *)((char *)this + 80);
  }
  else
  {
    v8 = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)this);
    v9 = v10;
    *((double *)this + 9) = v8;
    *((float32x2_t *)this + 10) = v10;
    *((_BYTE *)this + 88) = 1;
  }
  v11 = (uint32x2_t)vclez_f32(v9);
  if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0)
  {
    v12[0] = (float64x2_t)xmmword_209BD5290;
    v12[1] = (float64x2_t)xmmword_209BD52A0;
    v16 = 0;
    v13 = 0;
    v14 = 0;
    LOBYTE(v15) = 0;
    v17 = 1.0;
    RB::DisplayList::AtomizedItems::apply_effects((uint64_t)this, a2, (uint64_t)a3, a4, 0, (uint64_t)v12);
    if (v17 > 0.0)
      RB::operator*(v12, *(float32x2_t *)&v8, v9);
  }
}

uint64_t RB::DisplayList::AtomizedItems::effects_change_geometry(RB::DisplayList::AtomizedItems *this, const RB::DisplayList::Interpolator::Layer *a2, const RB::DisplayList::Interpolator::State *a3, int a4)
{
  const RB::Transition *v6;
  unsigned int v7;
  unsigned int v8;
  char *v9;
  uint64_t v10;
  char v11;
  char v12;
  unsigned __int8 v13;
  __int16 v14;

  v6 = RB::DisplayList::AtomizedItems::transition(this, a2);
  v7 = *((_DWORD *)v6 + 12);
  if (!v7)
    return 0;
  v8 = 0;
  v9 = (char *)v6 + 24;
  if (*((_QWORD *)v6 + 5))
    v9 = (char *)*((_QWORD *)v6 + 5);
  v10 = **((_QWORD **)a3 + 1);
  if ((v10 & 0x100000000) != 0)
    v11 = 4;
  else
    v11 = 8;
  if ((v10 & 0x400000000) != 0)
    v12 = 16;
  else
    v12 = 32;
  v13 = v11 | v12 | a4;
  while (1)
  {
    v14 = *(_WORD *)&v9[4 * v8];
    if ((v13 & HIBYTE(v14) & 0x3F) == a4
      && ((v14 & 0x7F) - 2) < 0x11u
      && ((0x1E1FFu >> ((v14 & 0x7F) - 2)) & 1) != 0)
    {
      break;
    }
    v8 += RB::Transition::_effect_args[v14 & 0x7F] + 1;
    if (v8 >= v7)
      return 0;
  }
  return 1;
}

void RB::Buffer::~Buffer(RB::Buffer *this)
{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

}

{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

  JUMPOUT(0x20BD16544);
}

char *RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector(char *a1)
{
  char *v2;
  char *v3;
  unint64_t v4;
  id *v5;

  v2 = (char *)*((_QWORD *)a1 + 6);
  if (v2)
    v3 = v2;
  else
    v3 = a1;
  if (*((_QWORD *)a1 + 7))
  {
    v4 = 0;
    v5 = (id *)(v3 + 16);
    do
    {

      ++v4;
      v5 += 3;
    }
    while (v4 < *((_QWORD *)a1 + 7));
    v2 = (char *)*((_QWORD *)a1 + 6);
  }
  if (v2)
    free(v2);
  return a1;
}

void RB::Device::~Device(RB::Device *this)
{
  _QWORD *i;
  uint64_t v3;
  uint64_t j;
  char *v5;
  void *v6;
  unint64_t v7;
  id *v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  int v12;
  _DWORD *v13;
  int v14;
  RB::Device *v15;

  *(_QWORD *)this = off_24C2296E8;
  dispatch_sync(*((dispatch_queue_t *)this + 5), &__block_literal_global_0);
  for (i = (_QWORD *)*((_QWORD *)this + 48); i != (_QWORD *)((char *)this + 376); i = (_QWORD *)i[1])
    *(_QWORD *)(i[2] + 48) = 0;
  if (*((_QWORD *)this + 121))
    CGGlyphLockRelease();
  v15 = this;
  RB::UntypedTable::for_each((uint64_t)this + 880, (void (*)(const void *, const void *, void *))RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::for_each<RB::Device::~Device()::$_0>(RB::Device::~Device()::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, &v15);
  v3 = *((_QWORD *)this + 122);
  *((_QWORD *)this + 122) = 0;
  if (v3)
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100]((uint64_t)this + 976, v3);
  std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100]((uint64_t *)this + 120, 0);
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 880));
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 800));
  for (j = 792; j != 600; j -= 8)

  do
  {

    j -= 8;
  }
  while (j != 552);
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table((uint64_t)this + 512);
  RB::UntypedTable::~UntypedTable((RB::Device *)((char *)this + 432));
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 50);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 47);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)this + 43);
  RB::Heap::~Heap((RB::Device *)((char *)this + 304));
  v5 = (char *)this + 200;
  v6 = (void *)*((_QWORD *)this + 31);
  if (v6)
    v5 = (char *)*((_QWORD *)this + 31);
  if (*((_QWORD *)this + 32))
  {
    v7 = 0;
    v8 = (id *)(v5 + 16);
    do
    {

      ++v7;
      v8 += 3;
    }
    while (v7 < *((_QWORD *)this + 32));
    v6 = (void *)*((_QWORD *)this + 31);
  }
  if (v6)
    free(v6);
  v9 = (_DWORD *)*((_QWORD *)this + 22);
  if (v9)
  {
    v10 = v9[2] - 1;
    v9[2] = v10;
    if (!v10)
      (*(void (**)(_DWORD *))(*(_QWORD *)v9 + 8))(v9);
  }
  v11 = (_DWORD *)*((_QWORD *)this + 21);
  if (v11)
  {
    v12 = v11[2] - 1;
    v11[2] = v12;
    if (!v12)
      (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 8))(v11);
  }
  v13 = (_DWORD *)*((_QWORD *)this + 20);
  if (v13)
  {
    v14 = v13[2] - 1;
    v13[2] = v14;
    if (!v14)
      (*(void (**)(_DWORD *))(*(_QWORD *)v13 + 8))(v13);
  }

}

{
  RB::Device::~Device(this);
  JUMPOUT(0x20BD16544);
}

void sub_209B84DA8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v4;

  v4 = *(_QWORD *)(v1 + 976);
  *(_QWORD *)(v1 + 976) = 0;
  if (v4)
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100](v1 + 976, v4);
  RB::Device::~Device(v1, v2);

  _Unwind_Resume(a1);
}

void *RB::Device::library_archive(void **this)
{
  RB::_anonymous_namespace_ *v2;
  void *bundle;
  uint64_t library_archive;

  if (*((_BYTE *)this + 282) && !this[7])
  {
    v2 = (RB::_anonymous_namespace_ *)MEMORY[0x20BD168EC]();

    this[7] = (void *)library_archive;
    if (!library_archive)
      *((_BYTE *)this + 282) = 0;
    objc_autoreleasePoolPop(v2);
  }
  return this[7];
}

void sub_209B84EAC(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::`anonymous namespace'::load_library_archive(void *a1, void *a2)
{
  uint64_t v3;
  uint64_t v4;
  void *v5;
  const char *v6;
  uint64_t v7;
  const char *v9;
  id v10;

  v3 = objc_msgSend(a1, "URLForResource:withExtension:", CFSTR("archive"), CFSTR("metallib"));
  if (!v3)
    return 0;
  v4 = v3;
  v5 = (void *)objc_opt_new();
  objc_msgSend(v5, "setUrl:", v4);
  objc_msgSend(v5, "setOptions:", objc_msgSend(v5, "options") | 0x20);
  v10 = 0;
  v7 = objc_msgSend(a2, "newBinaryArchiveWithDescriptor:error:", v5, &v10);
  if (v10 || !v7)
  {
    if (v10)
      v9 = (const char *)objc_msgSend((id)objc_msgSend(v10, "localizedDescription"), "UTF8String");
    else
      v9 = "unknown error";
    RB::non_fatal_precondition_failure((RB *)"unable to load binary archive: %s", v6, v9);
  }

  return v7;
}

void sub_209B84F98(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RB::Device::depth_stencil_format(RB::Device *this, char a2, int a3)
{
  _BOOL4 v3;
  int v4;
  uint64_t v5;
  BOOL v6;
  uint64_t v7;

  if ((a2 & 1) != 0)
  {
    v3 = 1;
    if (!a3)
      goto LABEL_3;
LABEL_6:
    v4 = !v3;
    goto LABEL_7;
  }
  v3 = *((_BYTE *)this + 280) != 0;
  if (a3)
    goto LABEL_6;
LABEL_3:
  v4 = !v3;
  if (!*((_BYTE *)this + 281))
  {
    v5 = 0;
    v4 = 1;
    goto LABEL_8;
  }
LABEL_7:
  v5 = 253;
LABEL_8:
  v6 = !v3;
  v7 = 252;
  if (v6)
    v7 = v5;
  if (v4)
    return v7;
  else
    return 260;
}

void RB::Device::add_frame_continuation(uint64_t a1, int a2, NSObject *a3, void *a4)
{
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v8 = (os_unfair_lock_s *)(a1 + 184);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 184));
  if (a2 - *(_DWORD *)(a1 + 192) < 1)
  {
    dispatch_async(a3, a4);
  }
  else
  {
    v9 = a1 + 200;
    v10 = *(_QWORD *)(a1 + 256);
    if (*(_QWORD *)(a1 + 264) < (unint64_t)(v10 + 1))
    {
      RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow((void *)(a1 + 200), v10 + 1);
      v10 = *(_QWORD *)(a1 + 256);
    }
    if (*(_QWORD *)(a1 + 248))
      v9 = *(_QWORD *)(a1 + 248);
    v11 = v9 + 24 * v10;
    *(_DWORD *)v11 = a2;
    *(_QWORD *)(v11 + 8) = a3;
    *(_QWORD *)(v11 + 16) = objc_msgSend(a4, "copy");
    ++*(_QWORD *)(a1 + 256);
  }
  os_unfair_lock_unlock(v8);
}

void sub_209B850E4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Device::alloc_shared_texture_view@<X0>(uint64_t result@<X0>, MTLPixelFormat a2@<X1>, RB *a3@<X2>, uint64_t a4@<X3>, uint64_t *a5@<X8>)
{
  MTLPixelFormat v5;
  RB *v7;
  uint64_t v10;
  unsigned int *v11;
  MTLPixelFormat v12;
  uint64_t *v13;
  uint64_t *i;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v5 = a2;
  v7 = *(RB **)(a2 + 56);
  if (v7 == a3)
  {
LABEL_2:
    ++*(_DWORD *)(v5 + 8);
    goto LABEL_14;
  }
  v10 = result;
  v11 = RB::pixel_format_traits(*(_QWORD *)(a2 + 56), a2);
  if (((*v11 | ((unint64_t)*((unsigned __int16 *)v11 + 2) << 32)) & 0x40000000000) != 0)
  {
    result = RB::Texture::has_view_usage((id *)v5);
    if (!(_DWORD)result)
    {
LABEL_13:
      v5 = MTLPixelFormatInvalid;
      goto LABEL_14;
    }
    v7 = *(RB **)(v5 + 56);
  }
  result = RB::pixel_formats_support_view_copy(v7, a3, v12);
  if (!(_DWORD)result)
    goto LABEL_13;
  v13 = (uint64_t *)(v10 + 400);
  for (i = *(uint64_t **)(v10 + 408); ; i = (uint64_t *)i[1])
  {
    if (i == v13)
    {
      v16 = objc_msgSend(*(id *)(v5 + 16), "newTextureViewWithPixelFormat:", a3);
      v17 = operator new();
      RB::Texture::Texture(v17, v16, a4, *(unsigned __int8 *)(v5 + 78), 0);
      *a5 = v17;
      *(_BYTE *)(v17 + 77) |= 1u;
      return (uint64_t)std::list<RB::refcounted_ptr<RB::Texture>>::emplace_back<RB::refcounted_ptr<RB::Texture>&>(v13, a5);
    }
    v15 = i[2];
    if (*(RB **)(v15 + 56) == a3 && *(unsigned __int8 *)(v15 + 80) == (_DWORD)a4)
    {
      result = objc_msgSend(*(id *)(v15 + 16), "parentTexture");
      if (result == *(_QWORD *)(v5 + 16))
        break;
    }
  }
  v5 = i[2];
  if (v5)
    goto LABEL_2;
LABEL_14:
  *a5 = v5;
  return result;
}

void sub_209B85254(_Unwind_Exception *exception_object)
{
  _DWORD **v1;
  _DWORD *v3;
  int v4;

  v3 = *v1;
  if (*v1)
  {
    v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4)
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::list<RB::refcounted_ptr<RB::Texture>>::emplace_back<RB::refcounted_ptr<RB::Texture>&>(uint64_t *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = operator new(0x18uLL);
  v5 = *a2;
  if (*a2)
    ++*(_DWORD *)(v5 + 8);
  v4[2] = v5;
  v6 = *a1;
  *v4 = *a1;
  v4[1] = a1;
  *(_QWORD *)(v6 + 8) = v4;
  *a1 = (uint64_t)v4;
  ++a1[2];
  return v4 + 2;
}

uint64_t RB::Device::invalid_texture(RB::Device *this)
{
  uint64_t v1;
  void *v4;
  void *v5;
  _DWORD *v6;
  int v7;
  const char *v8;
  _QWORD v9[3];
  int64x2_t v10;
  uint64_t v11;
  int v12;

  v1 = *((_QWORD *)this + 20);
  if (!v1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BDDD740], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 80, 1, 1, 0);
    objc_msgSend(v4, "setUsage:", 1);
    objc_msgSend(v4, "setStorageMode:", 0);
    v5 = (void *)objc_msgSend(*((id *)this + 3), "newTextureWithDescriptor:", v4);
    v12 = -256;
    memset(v9, 0, sizeof(v9));
    v10 = vdupq_n_s64(1uLL);
    v11 = 1;
    objc_msgSend(v5, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v9, 0, &v12, 4);
    v1 = operator new();
    RB::Texture::Texture(v1, v5, 1, 0, 0);
    v6 = (_DWORD *)*((_QWORD *)this + 20);
    *((_QWORD *)this + 20) = v1;
    if (v6)
    {
      v7 = v6[2] - 1;
      v6[2] = v7;
      if (!v7)
      {
        (*(void (**)(_DWORD *))(*(_QWORD *)v6 + 8))(v6);
        v1 = *((_QWORD *)this + 20);
        if (!v1)
          RB::precondition_failure((RB *)"unable to create invalid texture", v8);
      }
    }
  }
  return v1;
}

void sub_209B85424(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Device::clear_texture(RB::Device *this)
{
  uint64_t v1;
  void *v4;
  void *v5;
  _DWORD *v6;
  int v7;
  const char *v8;
  _QWORD v9[3];
  int64x2_t v10;
  uint64_t v11;
  int v12;

  v1 = *((_QWORD *)this + 21);
  if (!v1)
  {
    v4 = (void *)objc_msgSend(MEMORY[0x24BDDD740], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 80, 1, 1, 0);
    objc_msgSend(v4, "setUsage:", 1);
    objc_msgSend(v4, "setStorageMode:", 0);
    v5 = (void *)objc_msgSend(*((id *)this + 3), "newTextureWithDescriptor:", v4);
    v12 = 0;
    memset(v9, 0, sizeof(v9));
    v10 = vdupq_n_s64(1uLL);
    v11 = 1;
    objc_msgSend(v5, "replaceRegion:mipmapLevel:withBytes:bytesPerRow:", v9, 0, &v12, 4);
    v1 = operator new();
    RB::Texture::Texture(v1, v5, 1, 0, 0);
    v6 = (_DWORD *)*((_QWORD *)this + 21);
    *((_QWORD *)this + 21) = v1;
    if (v6)
    {
      v7 = v6[2] - 1;
      v6[2] = v7;
      if (!v7)
      {
        (*(void (**)(_DWORD *))(*(_QWORD *)v6 + 8))(v6);
        v1 = *((_QWORD *)this + 21);
        if (!v1)
          RB::precondition_failure((RB *)"unable to create clear texture", v8);
      }
    }
  }
  return v1;
}

void sub_209B85560(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Shader::Tables::shared(RB::Shader::Tables *this)
{
  unsigned __int8 v1;

  {
    RB::Shader::Tables::shared(void)::tables = (uint64_t)RB::Shader::Tables::shared(void)::$_0::operator()();
  }
  return RB::Shader::Tables::shared(void)::tables;
}

void sub_209B855DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

float16x4_t *RB::Shader::Tables::shared(void)::$_0::operator()()
{
  float16x4_t *v0;
  const char *v1;
  float16x4_t *v2;
  float16x4_t *v3;
  unint64_t v4;
  float16x4_t *v10;
  int8x8_t v11;
  int16x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  int8x16_t v38;
  float32x4_t v39;
  float32x4_t v40;

  v0 = (float16x4_t *)mmap(0, 0x6000uLL, 3, 4098, -1, 0);
  if (v0 == (float16x4_t *)-1)
    RB::precondition_failure((RB *)"memory allocation failed", v1);
  v2 = v0;
  v3 = v0 + 1024;
  v4 = -4;
  v35 = (float32x4_t)vdupq_n_s32(0x3ED555C5u);
  v36 = (float32x4_t)vdupq_n_s32(0x414EB852u);
  v33 = (float32x4_t)vdupq_n_s32(0xBD6147AE);
  v34 = (float32x4_t)vdupq_n_s32(0x3F870A3Du);
  v31 = (float32x4_t)vdupq_n_s32(0x3D9E8391u);
  v32 = (float32x4_t)vdupq_n_s32(0x3B4D2E1Cu);
  v29 = (float32x4_t)vdupq_n_s32(0x3D55891Au);
  v30 = (float32x4_t)vdupq_n_s32(0x3F72A76Fu);
  v27 = (float32x4_t)vdupq_n_s32(0x3D25AEE6u);
  v28 = (float32x4_t)vdupq_n_s32(0x4019999Au);
  v25 = (float32x4_t)vdupq_n_s32(0x4196D000u);
  v26 = (float32x4_t)vdupq_n_s32(0x3E232010u);
  v23 = (float32x4_t)vdupq_n_s32(0x41958000u);
  v24 = (float32x4_t)vdupq_n_s32(0x3F560000u);
  __asm { FMOV            V1.4S, #1.0 }
  v21 = (float32x4_t)vdupq_n_s32(0x429DB000u);
  v22 = _Q1;
  v10 = v0;
  do
  {
    v4 += 4;
    v11 = vorr_s8((int8x8_t)vdup_n_s32(v4), (int8x8_t)0x300000002);
    v12.i16[0] = v4;
    v12.i16[1] = v4 | 1;
    v12.i16[2] = v11.i16[0];
    v12.i16[3] = v11.i16[2];
    v13 = vcvtq_f32_f16((float16x4_t)(*(_QWORD *)&vshl_n_s16(v12, 3uLL) | 0x4000400040004));
    v38 = (int8x16_t)vmulq_f32(v13, v36);
    v40 = v13;
    v14 = (float32x4_t)_simd_log2_f4((simd_float4)v13);
    v39 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v32, v40), v38, (int8x16_t)vmlaq_f32(v33, v34, (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v14, v35))));
    v15 = (float32x4_t)_simd_log2_f4((simd_float4)vmlaq_f32(v29, v30, v40));
    v37 = (float32x4_t)vbslq_s8((int8x16_t)vcgeq_f32(v27, v40), (int8x16_t)vmulq_f32(v40, v31), (int8x16_t)_simd_exp2_f4((simd_float4)vmulq_f32(v15, v28)));
    v16 = (float32x4_t)_simd_log2_f4((simd_float4)v40);
    v17 = (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v16, v26));
    v18 = (float32x4_t)_simd_log2_f4((simd_float4)vdivq_f32(vmlaq_f32(v24, v25, v17), vmlaq_f32(v22, v23, v17)));
    v19 = (float32x4_t)_simd_exp2_f4((simd_float4)vmulq_f32(v18, v21));
    *v10 = vcvt_f16_f32(v39);
    v10[1024] = vcvt_f16_f32(v37);
    v10[2048] = vcvt_f16_f32(v19);
    ++v10;
  }
  while (v4 < 0xFFC);
  v2->i16[0] = 0;
  v2[480].i16[0] = 15360;
  v3->i16[0] = 0;
  v3[480].i16[0] = 15360;
  return v2;
}

uint64_t RB::Device::set_texture_cache(uint64_t a1, uint64_t a2, unsigned int a3, size_t *a4)
{
  size_t *v4;
  size_t **v5;

  v4 = (size_t *)(a3 | (unint64_t)(a2 << 32));
  v5 = (size_t **)(a1 + 800);
  if (a4)
    return RB::UntypedTable::insert(v5, v4, a4);
  else
    return RB::UntypedTable::remove((RB::UntypedTable *)v5, v4);
}

uint64_t *RB::Device::function_library(RB::Device *this, RB::CustomShader::Library *a2)
{
  size_t **v4;
  uint64_t *v5;
  id *v6;
  void *v8;

  v4 = (size_t **)((char *)this + 880);
  v8 = 0;
  v5 = RB::UntypedTable::lookup((RB::Device *)((char *)this + 880), (uint64_t *)a2, &v8);
  if (v8 == a2)
    return v5;
  v6 = (id *)operator new();
  RB::FunctionLibrary::FunctionLibrary((RB::FunctionLibrary *)v6, this, a2);
  if (!v6[1])
  {
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v6 + 4));

    MEMORY[0x20BD16544](v6, 0x10A0C400C0D2FE0);
    v6 = 0;
  }
  RB::UntypedTable::insert(v4, (size_t *)a2, (size_t *)v6);
  RB::CustomShader::Library::add_observer((os_unfair_lock_s *)a2, this, (void (*)(RB::CustomShader::Library *, void *))RB::Device::function_library(RB::CustomShader::Library &)::$_0::__invoke);
  return (uint64_t *)v6;
}

void sub_209B8596C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C400C0D2FE0);
  _Unwind_Resume(a1);
}

uint64_t *RB::Device::remove_function_library(RB::Device *this, RB::CustomShader::Library *a2)
{
  RB::UntypedTable *v4;
  uint64_t *result;
  NSObject *v6;
  _QWORD block[5];

  v4 = (RB::Device *)((char *)this + 880);
  result = RB::UntypedTable::lookup((RB::Device *)((char *)this + 880), (uint64_t *)a2, 0);
  if (result)
  {
    if (*((_BYTE *)result + 112))
    {
      v6 = *((_QWORD *)this + 5);
      block[0] = MEMORY[0x24BDAC760];
      block[1] = 3221225472;
      block[2] = ___ZN2RB6Device23remove_function_libraryERNS_12CustomShader7LibraryE_block_invoke;
      block[3] = &__block_descriptor_40_e5_v8__0l;
      block[4] = this;
      dispatch_sync(v6, block);
    }
    return (uint64_t *)RB::UntypedTable::remove(v4, a2);
  }
  return result;
}

uint64_t ___ZN2RB6Device23remove_function_libraryERNS_12CustomShader7LibraryE_block_invoke(uint64_t a1)
{
  char v2;

  return RB::UntypedTable::for_each(*(_QWORD *)(a1 + 32) + 432, (void (*)(const void *, const void *, void *))_ZZNK2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE8for_eachIZZNS4_23remove_function_libraryERNS_12CustomShader7LibraryEEUb_E4__10EEvT_ENUlPKvSF_PvE_8__invokeESF_SF_SG_, &v2);
}

BOOL RB::Device::should_compile_binary_functions(RB::Device *this)
{
  RB::_anonymous_namespace_ *v2;

  if (!*((_BYTE *)this + 287))
    return 0;
  if ((int)v2 < 1)
    return 0;
    return RB::Device::library_archive((void **)this) != 0;
  return 1;
}

uint64_t RB::`anonymous namespace'::use_uber_shader(RB::_anonymous_namespace_ *this)
{
  unsigned __int8 v1;
  const char *v3;
  uint64_t v4;
  int v5;

  if ((v1 & 1) == 0
  {
    v4 = RB::debug_int((RB *)"RB_UBER_SHADER", v3);
    if ((v4 & 0xFF00000000) != 0)
      v5 = v4;
    else
      v5 = 1;
  }
}

void sub_209B85B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::Device::valid_texture_size_nonnative(uint64_t a1, uint64_t a2, int32x2_t a3)
{
  const float *v4;
  int32x2_t v5;
  uint32x2_t v6;

  if ((unint64_t)(a2 - 2147483649) <= 2)
  {
    if (3 * a3.i32[0] != 3 * a3.i32[0])
      return 0;
    a3.i32[0] *= 3;
  }
  v4 = (const float *)(a1 + 288);
  v5 = (int32x2_t)vld1_dup_f32(v4);
  v6 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v5, a3), (int8x8_t)vcgtz_s32(a3));
  return vpmin_u32(v6, v6).u32[0] >> 31;
}

uint64_t RB::Device::render_pipeline_state(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  RB::UntypedTable *v6;
  uint64_t *v7;
  uint64_t *v8;
  RB::_anonymous_namespace_ *v9;
  RB::_anonymous_namespace_ *v10;
  id v11;
  void *v12;
  uint64_t library;
  void *bundle;
  uint64_t library_archive;
  RB::_anonymous_namespace_ *v16;
  const char *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  RB::_anonymous_namespace_ *v22;
  uint64_t *v23;
  uint64_t v24;
  int v25;
  uint64_t v26;
  RB::Device::RenderPipelineEntry::Queue *v27;
  uint64_t v28;
  char v29;
  BOOL v30;
  char v31;
  void *v32;
  uint64_t render_pipeline_descriptor;
  uint64_t v34;
  double v35;
  uint64_t v36;
  void *v37;
  RB *v38;
  RB::_anonymous_namespace_ *v39;
  double v40;
  const char *v41;
  const char *v42;
  char v43;
  BOOL v44;
  char v45;
  char v46;
  uint64_t *v47;
  void *v48;
  uint64_t v49;
  double v50;
  void *v51;
  RB *v52;
  RB *v53;
  double v54;
  BOOL v55;
  const char *v56;
  RB *v57;
  RB *v58;
  const char *v59;
  char v60;
  char v61;
  BOOL v62;
  char v63;
  double v64;
  NSObject *v65;
  void *v67;
  void *v68;
  RB *v69;
  const char *v70;
  void *v71;
  id v72;
  id v73;
  uint64_t v74;
  int v75;
  unint64_t v76;
  int v77;
  uint8_t buf[4];
  const char *v79;
  __int16 v80;
  unint64_t *v81;
  __int16 v82;
  double v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  int v87;
  uint64_t v88;

  v88 = *MEMORY[0x24BDAC8D0];
  v74 = a2;
  v75 = a3;
  v6 = (RB::UntypedTable *)(a1 + 432);
  v7 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 432), &v74, 0);
  v8 = v7;
  if (!v7 || !v7[3])
  {
    v9 = (RB::_anonymous_namespace_ *)MEMORY[0x20BD168EC]();
    v10 = v9;
    v11 = 0;
    v73 = 0;
    if (*(_QWORD *)(a1 + 48)
        ? (v11 = 0)
        : (0, v11 = v12),
          *(id *)(a1 + 48),
          (*(_QWORD *)(a1 + 48) = library) != 0))
    {
      if (*(_BYTE *)(a1 + 282) && !*(_QWORD *)(a1 + 56))
      {
        if (!v11)
        {
          if (bundle)
          {

            v11 = bundle;
          }
          else
          {
            v11 = 0;
          }
        }

        *(_QWORD *)(a1 + 56) = library_archive;
        if (!library_archive)
          *(_BYTE *)(a1 + 282) = 0;
      }
      v16 = (RB::_anonymous_namespace_ *)RB::RenderState::custom_shader_id((RB::RenderState *)&v74);
      if (!(_DWORD)v16)
      {
        v20 = 0;
        goto LABEL_25;
      }
      v18 = a4[1];
      if (v18)
      {
        v19 = *a4 + 24;
        while (1)
        {
          v20 = *(_QWORD *)v19;
          if ((*(_DWORD *)(*(_QWORD *)v19 + 4) | (8 * **(_DWORD **)v19)) == (_DWORD)v16)
            break;
          v19 += 8;
          if (!--v18)
            goto LABEL_22;
        }
LABEL_25:
          || !RB::RenderState::uber_compatible((RB::RenderState *)&v74))
        {
          goto LABEL_64;
        }
        if (v20 && !*(_BYTE *)(v20 + 104))
          goto LABEL_65;
        v77 = v75 & 0x67FFFFF;
        v23 = RB::UntypedTable::lookup(v6, (uint64_t *)&v76, 0);
        v21 = (uint64_t)v23;
        if (v23)
        {
LABEL_32:
          {
            v24 = operator new();
            v25 = v75;
            *(_QWORD *)v24 = v74;
            *(_DWORD *)(v24 + 8) = v25;
            *(_OWORD *)(v24 + 16) = 0u;
            *(_OWORD *)(v24 + 32) = 0u;
            *(_WORD *)(v24 + 48) = 0;
            v26 = operator new();
            RB::Device::RenderPipelineEntry::Loader::Loader(v26, (RB::Device *)a1, v74, v75, v20);
            *(_QWORD *)(v24 + 16) = v26;
            v27 = (RB::Device::RenderPipelineEntry::Queue *)RB::UntypedTable::insert((size_t **)v6, (size_t *)v24, (size_t *)v24);
            v28 = RB::Device::RenderPipelineEntry::Queue::shared(v27);
            RB::Device::RenderPipelineEntry::Queue::enqueue(v28, *(_QWORD *)(v24 + 16));
            if (*(_BYTE *)(a1 + 552))
            {
              std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1 + 512, (unsigned int *)&v74, (uint64_t)&v74);
              if (v29)
                v30 = 0;
              else
                v30 = *(_BYTE *)(a1 + 553) == 0;
              v31 = !v30;
              *(_BYTE *)(a1 + 553) = v31;
            }
          }
          *(_DWORD *)(v21 + 44) = *(_DWORD *)(a1 + 192);
          goto LABEL_99;
        }
        v32 = (void *)objc_opt_new();
        render_pipeline_descriptor = RB::Device::make_render_pipeline_descriptor(v76, v77, *(uint64_t **)(a1 + 48), *(uint64_t **)(a1 + 56), v32, 0, 0);
        if ((render_pipeline_descriptor & 1) == 0)
        {

          goto LABEL_64;
        }
        v72 = 0;
        v34 = *(_QWORD *)(a1 + 56);
        v35 = RB::current_time_seconds((RB *)render_pipeline_descriptor);
        v36 = 4 * (v34 != 0);
        v71 = 0;
        v37 = (void *)objc_msgSend(*(id *)(a1 + 24), "newRenderPipelineStateWithDescriptor:options:reflection:error:", v32, v36, 0, &v71);

        v72 = v37;
        v40 = RB::current_time_seconds(v38);
        if (!v34)
        if (!v72)
        {
          if (!*(_QWORD *)(a1 + 56))
          {
            v21 = 0;
            goto LABEL_53;
          }
          if ((int)v39 < 2)
          {
            v67 = v32;
          }
          else
          {
            v67 = (void *)objc_opt_new();

            v39 = (RB::_anonymous_namespace_ *)RB::Device::make_render_pipeline_descriptor(v76, v77, *(uint64_t **)(a1 + 48), 0, v67, 0, 0);
            if ((_DWORD)v39)
            {
              v35 = RB::current_time_seconds(v39);
              v68 = (void *)objc_msgSend(*(id *)(a1 + 24), "newRenderPipelineStateWithDescriptor:options:reflection:error:", v67, 0, 0, &v71);

              v72 = v68;
              v40 = RB::current_time_seconds(v69);
            }
            v36 = 0;
          }
          if (!v72)
          {
            v21 = 0;
            v32 = v67;
            goto LABEL_53;
          }
          v32 = v67;
        }
        if (RB::verbose_mode(v39))
        {
          if (v36)
            v41 = "loaded";
          else
            v41 = "built";
          v42 = RB::RenderState::name((RB::RenderState *)&v76);
          v86 = v76;
          v87 = v77;
          RB::FormattedRenderState::ID::formatted((uint64_t)&v86, (uint64_t)buf);
          printf("%s render pipeline %s-%s (%.2f ms)\n", v41, v42, (const char *)buf, (v40 - v35) * 1000.0);
          fflush((FILE *)*MEMORY[0x24BDAC8E8]);
        }
        v21 = operator new();
        RB::Device::RenderPipelineEntry::RenderPipelineEntry(v21, v76, v77, &v72);
        *(_BYTE *)(v21 + 49) = 1;
        RB::UntypedTable::insert((size_t **)v6, (size_t *)v21, (size_t *)v21);
LABEL_53:
        if (*(_BYTE *)(a1 + 552))
        {
          std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1 + 512, (unsigned int *)&v76, (uint64_t)&v76);
          if (v43)
            v44 = 0;
          else
            v44 = *(_BYTE *)(a1 + 553) == 0;
          v45 = !v44;
          *(_BYTE *)(a1 + 553) = v45;
        }

        if (v21)
          goto LABEL_32;
LABEL_64:
        if (!v20)
        {
          v47 = *(uint64_t **)(a1 + 56);
          v46 = 1;
LABEL_67:
          v48 = (void *)objc_opt_new();
          v49 = RB::Device::make_render_pipeline_descriptor(v74, v75, *(uint64_t **)(a1 + 48), v47, v48, 0, 0);
          if ((v49 & 1) == 0)
            goto LABEL_93;
          if ((v46 & 1) == 0)
          {
            v85 = *(_QWORD *)(v20 + 8);
            v49 = objc_msgSend((id)objc_msgSend(v48, "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v85, 1));
          }
          v72 = 0;
          v50 = RB::current_time_seconds((RB *)v49);
          v51 = (void *)objc_msgSend(*(id *)(a1 + 24), "newRenderPipelineStateWithDescriptor:options:reflection:error:", v48, 4 * (v47 != 0), 0, &v72);

          v73 = v51;
          v54 = RB::current_time_seconds(v52);
          if (v47)
          {
            v55 = v51 != 0;
            if (v51)
            {
              v56 = "loaded";
              goto LABEL_80;
            }
            v57 = (RB *)RB::Device::make_render_pipeline_descriptor(v74, v75, *(uint64_t **)(a1 + 48), 0, v48, 0, 0);
            if (!(_DWORD)v57)
              goto LABEL_93;
            if ((v46 & 1) == 0)
            {
              v84 = *(_QWORD *)(v20 + 8);
              v57 = (RB *)objc_msgSend((id)objc_msgSend(v48, "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v84, 1));
            }
            v50 = RB::current_time_seconds(v57);
            v51 = (void *)objc_msgSend(*(id *)(a1 + 24), "newRenderPipelineStateWithDescriptor:options:reflection:error:", v48, 0, 0, &v72);

            v73 = v51;
            v54 = RB::current_time_seconds(v58);
          }
          else
          {
          }
          v55 = 0;
          if (!v51)
          {
            v60 = 1;
            goto LABEL_84;
          }
          v56 = "built";
LABEL_80:
          v53 = (RB *)RB::verbose_mode(v53);
          if ((_DWORD)v53)
          {
            v59 = RB::RenderState::name((RB::RenderState *)&v74);
            v76 = v74;
            v77 = v75;
            RB::FormattedRenderState::ID::formatted((uint64_t)&v76, (uint64_t)buf);
            printf("%s render pipeline %s-%s (%.2f ms)\n", v56, v59, (const char *)buf, (v54 - v50) * 1000.0);
            v53 = (RB *)fflush((FILE *)*MEMORY[0x24BDAC8E8]);
          }
          v60 = 0;
LABEL_84:
          if (*(_BYTE *)(a1 + 552))
          {
            v53 = (RB *)std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1 + 512, (unsigned int *)&v74, (uint64_t)&v74);
            if (v61)
              v62 = 0;
            else
              v62 = *(_BYTE *)(a1 + 553) == 0;
            v63 = !v62;
            *(_BYTE *)(a1 + 553) = v63;
          }
          if ((v60 & 1) == 0)
          {
            v64 = v54 - v50;
            if (v64 > 0.5)
            {
              v65 = RB::error_log(v53);
              if (os_log_type_enabled(v65, OS_LOG_TYPE_FAULT))
              {
                v70 = RB::RenderState::name((RB::RenderState *)&v74);
                v86 = v74;
                v87 = v75;
                RB::FormattedRenderState::ID::formatted((uint64_t)&v86, (uint64_t)&v76);
                *(_DWORD *)buf = 136315650;
                v79 = v70;
                v80 = 2080;
                v81 = &v76;
                v82 = 2048;
                v83 = v64;
                _os_log_fault_impl(&dword_209ACA000, v65, OS_LOG_TYPE_FAULT, "building pipeline %s-%s took %f seconds", buf, 0x20u);
              }
            }
            v21 = operator new();
            RB::Device::RenderPipelineEntry::RenderPipelineEntry(v21, v74, v75, &v73);
            *(_BYTE *)(v21 + 48) = v55;
            RB::UntypedTable::insert((size_t **)v6, (size_t *)v21, (size_t *)v21);
            *(_DWORD *)(v21 + 44) = *(_DWORD *)(a1 + 192);
            goto LABEL_98;
          }
LABEL_93:
          v21 = 0;
LABEL_98:

          goto LABEL_99;
        }
LABEL_65:
        v46 = 0;
        v47 = 0;
        goto LABEL_67;
      }
LABEL_22:
      RB::non_fatal_precondition_failure((RB *)"missing custom function: %u", v17, v16);
    }
    v21 = 0;
LABEL_99:

    objc_autoreleasePoolPop(v10);
    return v21;
  }
  *((_DWORD *)v7 + 11) = *(_DWORD *)(a1 + 192);
  return (uint64_t)v8;
}

void sub_209B864D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id a14, id a15)
{
  void *v15;
  void *v16;
  void *v17;

  objc_autoreleasePoolPop(v15);
  _Unwind_Resume(a1);
}

uint64_t RB::Device::make_render_pipeline_descriptor(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, void *a5, uint64_t a6, id *a7)
{
  int v11;
  void *v12;
  MTLPixelFormat v13;
  unsigned int v14;
  void *v15;
  void *v16;
  unint64_t v17;
  MTLPixelFormat v18;
  unint64_t v19;
  unsigned int *v20;
  unint64_t v21;
  unsigned int *v22;
  MTLPixelFormat v23;
  id v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  __CFString **v29;
  void *v30;
  RB *v31;
  uint64_t v32;
  __CFString *v33;
  void *v34;
  RB *v35;
  void *v36;
  unsigned int v37;
  uint64_t v38;
  int v39;
  int v40;
  unsigned int v41;
  void *v42;
  uint64_t v43;
  unsigned int v44;
  void *v45;
  void *v46;
  unsigned int v47;
  id *v48;
  void *v50;
  id *v51;
  int v52;
  RB *v54;
  uint64_t *v55[4];
  uint64_t v56;
  unint64_t v57;
  unsigned int v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t *v61;
  _QWORD v62[6];

  v62[4] = *MEMORY[0x24BDAC8D0];
  v59 = a1;
  v60 = a2;
  v11 = RB::RenderState::uses_shader_blending((RB::RenderState *)&v59);
  v12 = (void *)objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 0);
  objc_msgSend(v12, "setPixelFormat:", v60 & 0x3FF);
  v14 = v60;
  if ((v60 & 0x200000) != 0)
  {
    v15 = (void *)objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 2);
    v17 = objc_msgSend(v12, "pixelFormat");
    v19 = v17;
    if ((v60 & 0x4000000) == 0)
    {
      v20 = RB::pixel_format_traits(v17, v18);
      if (v20[8])
        v19 = v20[8];
    }
    objc_msgSend(v15, "setPixelFormat:", v19);
    v14 = v60;
    if ((v60 & 0x100000) == 0)
      goto LABEL_3;
  }
  else
  {
    v15 = 0;
    if ((v60 & 0x100000) == 0)
    {
LABEL_3:
      v16 = 0;
      goto LABEL_9;
    }
  }
  v16 = (void *)objc_msgSend((id)objc_msgSend(a5, "colorAttachments"), "objectAtIndexedSubscript:", 1);
  objc_msgSend(v16, "setPixelFormat:", 65);
  v14 = v60;
LABEL_9:
  v21 = (v14 >> 10) & 0x3FF;
  v22 = RB::pixel_format_traits(v21, v13);
  if (((*v22 | ((unint64_t)*((unsigned __int16 *)v22 + 2) << 32)) & 0x4000000000) != 0)
  {
    objc_msgSend(a5, "setStencilAttachmentPixelFormat:", v21);
    v21 = ((unint64_t)v60 >> 10) & 0x3FF;
    v22 = RB::pixel_format_traits(v21, v23);
  }
  if (((*v22 | ((unint64_t)*((unsigned __int16 *)v22 + 2) << 32)) & 0x8000000000) != 0)
    objc_msgSend(a5, "setDepthAttachmentPixelFormat:", v21);
  if ((v59 & 0x400000000) != 0)
    objc_msgSend(a5, "setSupportAddingFragmentBinaryFunctions:", 1);
  v24 = (id)objc_opt_new();
  v50 = v16;
  v51 = a7;
  v52 = v11;
  v56 = v59;
  v57 = v60 | ((unint64_t)v58 << 32);
  objc_msgSend(v24, "setConstantValue:type:atIndex:", &v56, 36, 0);
  if (a6)
  {
    v25 = HIDWORD(v56);
    v27 = v57;
    v26 = HIDWORD(v57);
    v62[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v56);
    v62[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v25);
    v62[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v27);
    v62[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v26);
    RB::JSONPipelineData::set_const(a6, 0, 36, objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v62, 4));
  }
  if (!a3)
    goto LABEL_31;
  v55[0] = &v59;
  v55[1] = a3;
  v55[2] = a4;
  v28 = (uint64_t *)v24;
  v55[3] = v28;
  if (*v29)
  {
    v30 = (void *)objc_msgSend(MEMORY[0x24BDDD5B0], "functionDescriptor");
    v31 = v54;
    if (!v54)
      goto LABEL_35;
    objc_msgSend(a5, "setVertexFunction:", v54);
    if (a6 && *(void **)a6 != v30)
    {

      *(_QWORD *)a6 = v30;
    }

  }
  v33 = v29[2];
  v32 = (uint64_t)(v29 + 2);
  if (v33)
  {
    v34 = (void *)objc_msgSend(MEMORY[0x24BDDD5B0], "functionDescriptor");
    v35 = v54;
    if (v54)
    {
      objc_msgSend(a5, "setFragmentFunction:", v54);
      if (a6)
      {
        v36 = *(void **)(a6 + 8);
        if (v36 != v34)
        {

          *(_QWORD *)(a6 + 8) = v34;
        }
      }

      goto LABEL_30;
    }
LABEL_35:

    v43 = 0;
    goto LABEL_69;
  }
LABEL_30:

LABEL_31:
  v37 = v60;
  if ((v60 & 0x100000) != 0)
  {
    v38 = 0;
    v39 = 1;
    v40 = 0;
    v41 = 0;
    v42 = v50;
    switch(v59 & 0x3F)
    {
      case 0:
      case 1:
        v41 = 0;
        v40 = 1;
        v38 = 12;
        goto LABEL_44;
      case 2:
      case 3:
      case 5:
      case 6:
      case 7:
      case 8:
      case 0xBLL:
      case 0xCLL:
      case 0xDLL:
      case 0x1DLL:
      case 0x1ELL:
      case 0x1FLL:
        goto LABEL_40;
      case 4:
      case 0xALL:
        v39 = 0;
        v38 = 0;
        goto LABEL_40;
      case 9:
      case 0xELL:
      case 0xFLL:
      case 0x10:
      case 0x18:
      case 0x19:
      case 0x1ALL:
      case 0x1BLL:
        v40 = 0;
        v41 = (v59 >> 6) & 0x3F;
LABEL_34:
        v38 = 4;
        goto LABEL_44;
      case 0x11:
        v39 = 0;
        goto LABEL_39;
      case 0x12:
      case 0x13:
      case 0x14:
      case 0x15:
      case 0x16:
LABEL_39:
        v38 = 4;
        goto LABEL_40;
      case 0x17:
      case 0x1CLL:
      case 0x20:
        goto LABEL_44;
      default:
        v42 = v50;
LABEL_40:
        switch((v59 >> 6) & 0x3F)
        {
          case 0x13u:
          case 0x15u:
            v40 = 0;
            v38 |= 8uLL;
            v41 = 19;
            break;
          case 0x14u:
          case 0x16u:
            v40 = 0;
            v38 |= 8uLL;
            v41 = 20;
            break;
          case 0x17u:
            v40 = 0;
            v41 = 19;
            goto LABEL_34;
          default:
            v41 = 0;
            v40 = v39;
            break;
        }
LABEL_44:
        objc_msgSend(v42, "setWriteMask:", v38);
        if (v38)
        {
          if (v52)
            v44 = 48;
          else
            v44 = v41;
        }
        if (v40)
        {
          v37 = v60;
          goto LABEL_51;
        }
        objc_msgSend(v12, "setWriteMask:", 0);
        v48 = v51;
        objc_msgSend(v15, "setWriteMask:", 0);
        break;
    }
  }
  else
  {
LABEL_51:
    if ((v59 & 0x200000000) != 0)
      v45 = v15;
    else
      v45 = v12;
    if ((v59 & 0x200000000) != 0)
      v46 = v12;
    else
      v46 = v15;
    if (v52)
      v47 = 48;
    else
      v47 = (v59 >> 6) & 0x3F;
    v48 = v51;
    if ((v59 & 0x3F) != 0)
      objc_msgSend(v46, "setWriteMask:", 0);
  }
  if (a4)
  {
    v61 = a4;
    objc_msgSend(a5, "setBinaryArchives:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v61, 1));
  }
  objc_msgSend(a5, "setLabel:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", RB::RenderState::name((RB::RenderState *)&v59)));
  if (v48 && *v48 != v24)
  {

    *v48 = v24;
  }
  v43 = 1;
LABEL_69:

  return v43;
}

void sub_209B86B78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::`anonymous namespace'::check_error(RB *a1, void *a2, uint64_t a3, uint64_t a4, int a5)
{
  RB *v7;
  NSObject *v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  const char *v12;
  const char *v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint8_t buf[4];
  uint64_t v22;
  __int16 v23;
  const char *v24;
  __int16 v25;
  uint64_t *v26;
  __int16 v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v15 = a4;
  v16 = a5;
  if (a1)
  {
    v7 = (RB *)RB::verbose_mode(a1);
    if (a2 && (_DWORD)v7)
    {
      v8 = RB::error_log(v7);
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        v9 = RB::RenderState::name((RB::RenderState *)&v15);
        v17 = v15;
        v18 = v16;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v17, (uint64_t)&v19);
        v10 = objc_msgSend(a2, "localizedDescription");
        *(_DWORD *)buf = 136315906;
        v22 = a3;
        v23 = 2080;
        v24 = v9;
        v25 = 2080;
        v26 = &v19;
        v27 = 2112;
        v28 = v10;
        _os_log_error_impl(&dword_209ACA000, v8, OS_LOG_TYPE_ERROR, "shader warning: %s, %s-%s: %@", buf, 0x2Au);
      }
    }
  }
  else
  {
    v11 = RB::RenderState::name((RB::RenderState *)&v15);
    v19 = v15;
    v20 = v16;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v19, (uint64_t)buf);
    if (a2)
    {
      v14 = objc_msgSend((id)objc_msgSend(a2, "localizedDescription"), "UTF8String");
      RB::non_fatal_precondition_failure((RB *)"%s error: %s-%s: %s", v13, a3, v11, buf, v14);
    }
    else
    {
      RB::non_fatal_precondition_failure((RB *)"%s error: %s-%s: nil", v12, a3, v11, buf);
    }
  }
}

uint64_t RB::FormattedRenderState::uber_globals(RB::RenderState *a1, uint64_t a2, int a3)
{
  unsigned int *v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  int v10;
  _DWORD *v11;

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *((_DWORD *)a1 + 1) & 7 | (8 * a3);
  *(_DWORD *)(a2 + 8) = *((_DWORD *)a1 + 2);
  v5 = (unsigned int *)(a2 + 12);
  v6 = *(_QWORD *)a1;
  v7 = *((_DWORD *)a1 + 2);
  v8 = RB::RenderState::uses_shader_blending(a1);
  v10 = *(_DWORD *)a1;
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(v11 + 1);
  *(_DWORD *)(a2 + 24) = v11[3];
  *(_WORD *)(a2 + 28) = (unint64_t)(v10 & 0x3F) - 17 < 6;
  if (((0x3EE07C39EFuLL >> v10) & 1) != 0 && ((*(_DWORD *)a1 >> 6) & 0x3Fu) - 19 <= 4)
    *(_WORD *)(a2 + 24) = 1;
  return result;
}

void RB::Device::make_render_pipeline_descriptor(RB::FormattedRenderState,objc_object  {objcproto10MTLLibrary}*,objc_object  {objcproto16MTLBinaryArchive}*,MTLRenderPipelineDescriptor *,RB::JSONPipelineData *,RB::objc_ptr<MTLFunctionConstantValues *> *)::$_0::operator()<RB::`anonymous namespace'::shader_description::Fn,MTLFunctionDescriptor *>(uint64_t **a1@<X0>, int a2@<W1>, uint64_t a3@<X2>, void *a4@<X3>, RB **a5@<X8>)
{
  int v10;
  unsigned int v11;
  RB *v12;
  BOOL v13;
  const char *v14;
  uint64_t *v15;
  uint64_t v16;
  int v17;
  char v18[20];
  char __str[8];
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  objc_msgSend(a4, "setName:", *(_QWORD *)a3);
  if (*(_BYTE *)(a3 + 8))
  {
    v10 = *((_DWORD *)*a1 + 2);
    v16 = **a1;
    v17 = v10;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v16, (uint64_t)v18);
    snprintf(__str, 0x100uLL, "%c%s", a2, v18);
    objc_msgSend(a4, "setSpecializedName:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", __str));
    objc_msgSend(a4, "setConstantValues:", a1[3]);
  }
  if (a1[2])
  {
    v15 = a1[2];
    objc_msgSend(a4, "setBinaryArchives:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", &v15, 1));
  }
  v11 = 0;
  *(_QWORD *)__str = 0;
  do
  {
    v12 = (RB *)objc_msgSend(a1[1], "newFunctionWithDescriptor:error:", a4, __str);

    if (v12)
      v13 = 1;
    else
      v13 = v11 >= 2;
    ++v11;
  }
  while (!v13);
  if (a2 == 118)
    v14 = "vertex function";
  else
    v14 = "fragment function";
  *a5 = v12;

}

void sub_209B86FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RB::Device::RenderPipelineEntry::Loader::Loader(uint64_t a1, RB::Device *this, uint64_t a3, int a4, uint64_t a5)
{
  unsigned int *v7;
  unsigned int v8;
  id v9;
  void *v10;

  *(_QWORD *)a1 = 0;
  if (this)
  {
    v7 = (unsigned int *)((char *)this + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *(_QWORD *)(a1 + 8) = this;
  *(_QWORD *)(a1 + 16) = a3;
  *(_DWORD *)(a1 + 24) = a4;
  v9 = (id)RB::Device::library(this);
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 32) = v9;
  *(_BYTE *)(a1 + 80) = 0;
  *(_OWORD *)(a1 + 56) = 0u;
  if (a5)
  {
    v10 = *(void **)(a5 + 8);
    if (v10)
    {

      *(_QWORD *)(a1 + 40) = v10;
    }
  }
  return a1;
}

void sub_209B870A0(_Unwind_Exception *a1)
{
  uint64_t v1;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  v3 = *(unsigned int **)(v1 + 8);
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
    }
  }
  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::DeleteLoader::operator()(uint64_t a1, uint64_t a2)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (a2)
  {

    v3 = *(unsigned int **)(a2 + 8);
    if (v3)
    {
      v4 = v3 + 2;
      do
      {
        v5 = __ldxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
      }
    }
    JUMPOUT(0x20BD16544);
  }
}

id RB::Device::RenderPipelineEntry::function_table(uint64_t a1, const char *a2, _QWORD *a3, uint64_t a4)
{
  int v5;
  _QWORD *v6;
  uint64_t v7;
  unsigned int **v8;
  unsigned int *v9;
  unsigned int v10;
  void **v11;
  void ***v12;
  uint64_t v13;
  void **v14;
  void *v15;
  void *v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  char *v22;
  _DWORD *v23;
  int v24;
  int v25;
  uint64_t v26;
  int v27;
  unsigned int v29;
  _OWORD *v30;
  int v31;
  char *v32;
  uint64_t v33;
  char *v34;
  char *v35;
  id *v36;
  char *v37;
  unint64_t v38;
  char *v39;
  unint64_t v40;
  unsigned int *v41;
  char *v42;
  unsigned int v43;
  id v44;
  uint64_t v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  const char *v50;
  _BYTE *v51;
  unsigned int v52;
  char *v53;
  unint64_t v54;
  char *v55;
  RB *v56;
  const char *v57;
  int v58;
  const char *v59;
  int v60;
  void *v61;
  NSObject *v62;
  id v63;
  void *v64;
  void *v65;
  uint64_t v66;
  _QWORD *v67;
  id v68;
  id v69;
  uint64_t v70;
  int v71;
  uint8_t buf[32];
  _QWORD v73[2];

  v73[1] = *MEMORY[0x24BDAC8D0];
  if ((*(_BYTE *)(a1 + 4) & 4) == 0)
    return 0;
  v5 = (int)a2;
  v6 = (_QWORD *)a1;
  if ((_DWORD)a4 && (v7 = a3[1]) != 0)
  {
    v8 = (unsigned int **)(*a3 + 24);
    while (1)
    {
      v9 = *v8;
      v10 = **v8;
      if (((*v8)[1] | (8 * v10)) == (_DWORD)a4)
        break;
      ++v8;
      if (!--v7)
        goto LABEL_8;
    }
    if (!*((_BYTE *)v9 + 104))
      RB::precondition_failure((RB *)"missing binary function: %u", a2, a4);
  }
  else
  {
LABEL_8:
    v10 = 0;
    v9 = 0;
  }
  v12 = (void ***)(a1 + 32);
  v11 = *(void ***)(a1 + 32);
  if (!v11)
  {
    v13 = operator new();
    *(_OWORD *)v13 = 0u;
    *(_OWORD *)(v13 + 16) = 0u;
    *(_QWORD *)(v13 + 32) = 0;
    v14 = *v12;
    *v12 = (void **)v13;
    if (v14)
    {
      std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100]((uint64_t)(v6 + 4), (uint64_t)v14);
      v11 = *v12;
      v15 = **v12;
    }
    else
    {
      v11 = (void **)v13;
      v15 = 0;
    }
    v16 = (void *)v6[3];
    if (v15 != v16)
    {

      *v11 = v16;
      v11 = *v12;
    }
  }
  v17 = v11 + 1;
  v18 = *((unsigned int *)v11 + 4);
  if ((_DWORD)v18)
  {
    v19 = 0;
    v20 = (_DWORD *)*v17;
    v21 = *v17 + 8;
    while (1)
    {
      v22 = (char *)&v20[20 * v19];
      v25 = *((_DWORD *)v22 + 18);
      v23 = v22 + 72;
      v24 = v25;
      if (v25 == v5)
        break;
      if (v24 - *((_DWORD *)v6 + 11) <= 0)
      {
        LODWORD(v26) = 0;
        *v23 = v5;
        v35 = (char *)&v20[20 * v19];
        *(_OWORD *)(v35 + 8) = 0u;
        *(_OWORD *)(v35 + 24) = 0u;
        *(_OWORD *)(v35 + 40) = 0u;
        *(_OWORD *)(v35 + 56) = 0u;
LABEL_34:
        LODWORD(v18) = v19;
        goto LABEL_35;
      }
LABEL_29:
      ++v19;
      v21 += 80;
      if (v19 == v18)
        goto LABEL_30;
    }
    if (v10)
    {
      v26 = 0;
      while (1)
      {
        v27 = *(_DWORD *)(v21 + 4 * v26);
        if (v27 == v10 || v27 == 0)
          goto LABEL_34;
        if (++v26 == 16)
          goto LABEL_29;
      }
    }
    v36 = (id *)&v20[20 * v19];
    return *v36;
  }
LABEL_30:
  v67 = v6;
  v29 = *((_DWORD *)v11 + 4);
  if (*((_DWORD *)v11 + 5) < (v18 + 1))
  {
    RB::vector<RB::Device::RenderPipelineEntry::Functions::Table,0ul,unsigned int>::reserve_slow((uint64_t)(v11 + 1), v18 + 1);
    v29 = *((_DWORD *)v11 + 4);
  }
  v30 = (char *)v11[1] + 80 * v29;
  v30[3] = 0u;
  v30[4] = 0u;
  v30[1] = 0u;
  v30[2] = 0u;
  *v30 = 0u;
  v31 = *((_DWORD *)v11 + 4);
  *((_DWORD *)v11 + 4) = v31 + 1;
  v32 = (char *)v11[1];
  v26 = objc_opt_new();
  objc_msgSend((id)v26, "setFunctionCount:", 16);
  v33 = objc_msgSend((id)v6[3], "newVisibleFunctionTableWithDescriptor:stage:", v26, 2);
  v34 = &v32[80 * v31];

  *(_QWORD *)v34 = v33;
  *((_DWORD *)v34 + 18) = v5;
  *(_OWORD *)(v34 + 8) = 0u;
  *(_OWORD *)(v34 + 24) = 0u;
  *(_OWORD *)(v34 + 40) = 0u;
  *(_OWORD *)(v34 + 56) = 0u;

  LODWORD(v26) = 0;
  v6 = v67;
  v20 = v11[1];
LABEL_35:
  v36 = (id *)&v20[20 * v18];
  if (v10 && v20[20 * v18 + 2 + v26] != v10)
  {
    v66 = (uint64_t)&v20[20 * v18 + 2];
    v37 = (char *)v11[3];
    v38 = *((unsigned int *)v11 + 8);
    v39 = &v37[16 * v38];
    if ((_DWORD)v38)
    {
      do
      {
        v40 = v38 >> 1;
        v41 = (unsigned int *)&v37[16 * (v38 >> 1)];
        v43 = *v41;
        v42 = (char *)(v41 + 4);
        v38 += ~(v38 >> 1);
        if (v43 < v10)
          v37 = v42;
        else
          v38 = v40;
      }
      while (v38);
      if (v37 != v39)
      {
        if (*(_DWORD *)v37 == v10)
        {
          v44 = (id)*((_QWORD *)v37 + 1);
          v45 = v66;
LABEL_59:
          objc_msgSend(*v36, "setFunction:atIndex:", v44, v26);
          *(_DWORD *)(v45 + 4 * v26) = v10;
          return *v36;
        }
        v39 = v37;
      }
    }
    v46 = (void *)objc_opt_new();
    v73[0] = *((_QWORD *)v9 + 1);
    objc_msgSend(v46, "setFragmentAdditionalBinaryFunctions:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v73, 1));
    v69 = 0;
    v47 = (void *)objc_msgSend((id)v6[3], "newRenderPipelineStateWithAdditionalBinaryFunctions:error:", v46, &v69);
    v48 = v47;
    if (v47)
    {
      v64 = (void *)v6[3];
      v65 = v46;
      v6[3] = v47;
      v49 = (void *)objc_msgSend(v47, "functionHandleWithFunction:stage:", *((_QWORD *)v9 + 1), 2);
      v68 = v49;
      if (!v49)
        RB::precondition_failure((RB *)"unable to link function", v50);
      v63 = v49;
      v51 = v11[3];
      v52 = *((_DWORD *)v11 + 8);
      if (*((_DWORD *)v11 + 9) < v52 + 1)
      {
        RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(v11 + 3), v52 + 1);
        v53 = (char *)v11[3];
        v52 = *((_DWORD *)v11 + 8);
      }
      else
      {
        v53 = (char *)v11[3];
      }
      v54 = (v39 - v51) >> 4;
      if (v52 > v54)
      {
        memmove(&v53[16 * v54 + 16], &v53[16 * v54], 16 * (v52 - v54));
        v52 = *((_DWORD *)v11 + 8);
      }
      v55 = &v53[16 * v54];
      *(_DWORD *)v55 = v10;
      *((_QWORD *)v55 + 1) = v63;
      *((_DWORD *)v11 + 8) = v52 + 1;

      if (RB::verbose_mode(v56))
      {
        v57 = (const char *)objc_msgSend((id)objc_msgSend(*((id *)v9 + 1), "label"), "UTF8String");
        v58 = *v9;
        v59 = RB::RenderState::name((RB::RenderState *)v6);
        v60 = *((_DWORD *)v6 + 2);
        v70 = *v6;
        v71 = v60;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v70, (uint64_t)buf);
        printf("added function %s (@%d) to %s-%s\n", v57, v58, v59, (const char *)buf);
      }
      v46 = v65;
      v45 = v66;
      v61 = v64;
    }
    else
    {
      v45 = v66;
      v62 = RB::error_log(0);
      if (os_log_type_enabled(v62, OS_LOG_TYPE_ERROR))
        RB::Device::RenderPipelineEntry::function_table(objc_msgSend(v69, "localizedDescription"), buf, v62);
      v61 = 0;
      v68 = 0;
    }

    v44 = v68;
    if (!v48)
      return 0;
    goto LABEL_59;
  }
  return *v36;
}

void sub_209B876D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id a13, id a14, id a15)
{

  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::clear_custom_functions(RB::Device::RenderPipelineEntry *this)
{
  char *v2;
  _QWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;

  v4 = (_QWORD *)*((_QWORD *)this + 4);
  v2 = (char *)this + 32;
  v3 = v4;
  if (v4 && *v3)
  {
    v5 = *((_QWORD *)this + 3);
    *((_QWORD *)this + 3) = *v3;
    *v3 = v5;
    v6 = *((_QWORD *)this + 4);
    *((_QWORD *)this + 4) = 0;
    if (v6)
      std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100]((uint64_t)v2, v6);
  }
}

uint64_t RB::Device::glyph_path_cache(RB::Device *this)
{
  uint64_t result;
  uint64_t v3;
  uint64_t *v4;

  result = *((_QWORD *)this + 120);
  if (!result)
  {
    v3 = operator new();
    RB::UntypedTable::UntypedTable((RB::UntypedTable *)(v3 + 8), (unint64_t (*)(RB *, const void *))_ZZN2RB14GlyphPathCacheC1EvENUlT_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyEEEDaS1_, (BOOL (*)(RB *, RB *, const void *))_ZZN2RB14GlyphPathCacheC1EvENUlT_T0_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyES8_EEDaS1_S2_, 0, (void (*)(void *))_ZZN2RB14GlyphPathCacheC1EvENUlT_E0_8__invokeIPNS0_4PathEEEDaS1_, 0);
    v4 = (uint64_t *)((char *)this + 960);
    *(_QWORD *)(v3 + 88) = 0;
    *(_DWORD *)(v3 + 96) = -1;
    *(_QWORD *)(v3 + 104) = 0;
    *(_QWORD *)(v3 + 112) = 0;
    std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100](v4, v3);
    return *v4;
  }
  return result;
}

void sub_209B877FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C40197EAB39);
  _Unwind_Resume(a1);
}

uint64_t *std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v2 + 8));
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::Device::command_buffer_error(unsigned __int8 *a1, void *a2, void *a3)
{
  NSObject *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t i;
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 v22;
  void *v23;
  tm v24;
  time_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char v30[256];
  _BYTE v31[128];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v6 = RB::error_log((RB *)a1);
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      RB::Device::command_buffer_error(a2, v6);
      if (!a3)
        return;
    }
    else if (!a3)
    {
      return;
    }
    if ((a1[292] & 2) != 0)
    {
      v7 = (void *)objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
      objc_msgSend(v7, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", objc_msgSend(a2, "code")), CFSTR("errorCode"));
      v8 = objc_msgSend(a2, "localizedDescription");
      if (v8)
        objc_msgSend(v7, "setObject:forKeyedSubscript:", v8, CFSTR("errorString"));
      objc_msgSend(v7, "setObject:forKeyedSubscript:", RB::Device::device_info((RB::Device *)a1), CFSTR("deviceInfo"));
      v9 = (void *)objc_msgSend(a2, "userInfo");
      v10 = objc_msgSend(v9, "objectForKeyedSubscript:", *MEMORY[0x24BDDD128]);
      if (v10)
      {
        v11 = (void *)v10;
        v23 = a3;
        v12 = (void *)objc_msgSend(MEMORY[0x24BDBCEB8], "array");
        v26 = 0u;
        v27 = 0u;
        v28 = 0u;
        v29 = 0u;
        v13 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
        if (v13)
        {
          v14 = v13;
          v15 = *(_QWORD *)v27;
          do
          {
            for (i = 0; i != v14; ++i)
            {
              if (*(_QWORD *)v27 != v15)
                objc_enumerationMutation(v11);
              v17 = *(void **)(*((_QWORD *)&v26 + 1) + 8 * i);
              v18 = (void *)objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
              objc_msgSend(v18, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInteger:", objc_msgSend(v17, "errorState")), CFSTR("errorState"));
              v19 = objc_msgSend(v17, "label");
              if (v19)
                objc_msgSend(v18, "setObject:forKeyedSubscript:", v19, CFSTR("label"));
              v20 = objc_msgSend(v17, "debugSignposts");
              if (v20)
                objc_msgSend(v18, "setObject:forKeyedSubscript:", v20, CFSTR("signposts"));
              objc_msgSend(v12, "addObject:", v18);
            }
            v14 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v26, v31, 16);
          }
          while (v14);
        }
        objc_msgSend(v7, "setObject:forKeyedSubscript:", v12, CFSTR("encoders"));
        a3 = v23;
      }
      v25 = time(0);
      localtime_r(&v25, &v24);
      if (!strftime(v30, 0x100uLL, "RBDeviceError-%F-%H%M%S.rbar", &v24))
        snprintf_l(v30, 0x100uLL, 0, "RBDeviceError-%ld.rbar", v25);
      v21 = a1 + 292;
      RBArchiveToFileWithMetadata(a3, objc_msgSend(MEMORY[0x24BDD1608], "dataWithJSONObject:options:error:", v7, 0, 0), v30, 1);
      do
        v22 = __ldxr(v21);
      while (__stxr(v22 & 0xFD, v21));
    }
  }
}

uint64_t RB::Device::device_info(RB::Device *this)
{
  void *v2;
  _QWORD v4[6];
  _QWORD v5[6];
  _QWORD v6[9];
  _QWORD v7[10];

  v7[9] = *MEMORY[0x24BDAC8D0];
  v2 = (void *)*((_QWORD *)this + 3);
  v6[0] = CFSTR("name");
  v7[0] = objc_msgSend(v2, "name");
  v6[1] = CFSTR("featureProfile");
  v7[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInteger:", objc_msgSend(v2, "featureProfile"));
  v6[2] = CFSTR("bufferSize");
  v7[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *((_QWORD *)this + 34));
  v6[3] = CFSTR("useBinaryArchive");
  v7[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *((unsigned __int8 *)this + 282));
  v6[4] = CFSTR("isAGX");
  v7[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *((_BYTE *)this + 283) != 0);
  v6[5] = CFSTR("hasXR10Formats");
  v7[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *((unsigned __int8 *)this + 283) > 2u);
  v6[6] = CFSTR("hasYCbCrFormats");
  v7[6] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *((unsigned __int8 *)this + 283) > 2u);
  v6[7] = CFSTR("hasFBRead");
  v7[7] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", 1);
  v6[8] = CFSTR("limits");
  v4[0] = CFSTR("GPUFamilyApple");
  v5[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedChar:", *((unsigned __int8 *)this + 283));
  v4[1] = CFSTR("GPUFamilyMac");
  v5[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", 0);
  v4[2] = CFSTR("GPUFamilyCommon1");
  v5[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3001));
  v4[3] = CFSTR("GPUFamilyCommon2");
  v5[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3002));
  v4[4] = CFSTR("GPUFamilyCommon3");
  v5[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", objc_msgSend(v2, "supportsFamily:", 3003));
  v4[5] = CFSTR("readWriteTextureSupport");
  v5[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInteger:", objc_msgSend(v2, "readWriteTextureSupport"));
  v7[8] = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v5, v4, 6);
  return objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v7, v6, 9);
}

uint64_t RB::Refcount<RB::Device,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::Device,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_2::__invoke<RB::Device::RenderPipelineEntry *>(uint64_t result)
{
  uint64_t v1;
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if (result)
  {
    v1 = result;
    v4 = *(_QWORD *)(result + 32);
    v2 = (_QWORD *)(result + 32);
    v3 = v4;
    *v2 = 0;
    if (v4)
      std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100]((uint64_t)v2, v3);

    v6 = *(_QWORD *)(v1 + 16);
    *(_QWORD *)(v1 + 16) = 0;
    if (v6)
      RB::Device::RenderPipelineEntry::DeleteLoader::operator()(v5, v6);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

id *RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_3::__invoke<RB::TextureCache *>(id *result)
{
  if (result)
  {
    RB::TextureCache::~TextureCache(result);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::TextureCache::~TextureCache(id *location)
{
  id *v2;
  id *v3;
  id *v4;
  unint64_t v5;
  _DWORD *v6;
  int v7;
  id *v8;
  id v9;
  unint64_t v10;
  _DWORD **v11;
  _DWORD *v12;
  int v13;
  id v14;

  v2 = location + 8;
  v3 = (id *)location[9];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (*((_DWORD *)location + 20))
  {
    v5 = 0;
    do
    {
      v6 = v4[v5];
      if (v6)
      {
        v7 = v6[2] - 1;
        v6[2] = v7;
        if (!v7)
          (*(void (**)(_DWORD *))(*(_QWORD *)v6 + 8))(v6);
      }
      ++v5;
    }
    while (v5 < *((unsigned int *)location + 20));
    v3 = (id *)location[9];
  }
  if (v3)
    free(v3);
  v8 = location + 4;
  v9 = location[6];
  if (v9)
    v8 = (id *)location[6];
  if (*((_DWORD *)location + 14))
  {
    v10 = 0;
    v11 = (_DWORD **)(v8 + 1);
    do
    {
      v12 = *v11;
      if (*v11)
      {
        v13 = v12[2] - 1;
        v12[2] = v13;
        if (!v13)
          (*(void (**)(_DWORD *))(*(_QWORD *)v12 + 8))(v12);
      }
      ++v10;
      v11 += 2;
    }
    while (v10 < *((unsigned int *)location + 14));
    v9 = location[6];
  }
  if (v9)
    free(v9);
  v14 = location[3];
  if (v14)
    CFRelease(v14);
  objc_destroyWeak(location);
}

uint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_4::__invoke(uint64_t result)
{
  uint64_t v1;

  if (result)
  {
    v1 = result;
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(result + 32));

    JUMPOUT(0x20BD16544);
  }
  return result;
}

void std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = (uint64_t *)a1[1];
    v4 = *v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (uint64_t *)v2[1];
        std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)a1, v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>(int a1, _QWORD *__p)
{
  _DWORD *v3;
  int v4;

  v3 = (_DWORD *)__p[2];
  if (v3)
  {
    v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4)
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
  }
  operator delete(__p);
}

void RB::Device::function_library(RB::CustomShader::Library &)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  NSObject *v2;
  _QWORD v3[6];

  v2 = *(NSObject **)(a2 + 32);
  v3[0] = MEMORY[0x24BDAC760];
  v3[1] = 3221225472;
  v3[2] = ___ZZN2RB6Device16function_libraryERNS_12CustomShader7LibraryEENK3__0clES3_Pv_block_invoke;
  v3[3] = &__block_descriptor_48_e5_v8__0l;
  v3[4] = a2;
  v3[5] = a1;
  dispatch_sync(v2, v3);
}

uint64_t RB::Device::prune_caches(void)::$_2::__invoke(uint64_t *a1)
{
  uint64_t v2;
  uint64_t result;
  unsigned __int8 v4;
  _QWORD v5[2];

  v2 = *a1;
  v4 = 0;
  v5[0] = *((unsigned int *)a1 + 2);
  v5[1] = &v4;
  result = RB::UntypedTable::remove_if (v2 + 432, (BOOL (*)(const void *, const void *, void *))_ZZN2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE9remove_ifIZZNS4_12prune_cachesEvENK3__1clEvEUlT_PT0_E_EEvSA_ENUlPKvSF_PvE_8__invokeESF_SF_SG_, v5);
  *(_BYTE *)a1[2] = (*(unsigned __int8 *)a1[2] | v4) != 0;
  return result;
}

BOOL _ZZN2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE9remove_ifIZZNS4_12prune_cachesEvENK3__1clEvEUlT_PT0_E_EEvSA_ENUlPKvSF_PvE_8__invokeESF_SF_SG_(RB *a1, uint64_t *a2, int *a3)
{
  _BOOL8 v4;
  int v7;
  int v8;
  unsigned int v9;
  unsigned int v10;
  const char *v11;
  int v12;
  char *v13;
  BOOL v14;
  char v15;
  uint64_t v16;
  int v17;
  char v18[20];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  if (a2[2] || *((_BYTE *)a2 + 49))
    return 0;
  v7 = *a3;
  if (*((_BYTE *)a2 + 48))
    v8 = -60;
  else
    v8 = -1200;
  v9 = v8 + v7;
  v10 = *((_DWORD *)a2 + 10);
  v4 = v10 <= v8 + v7;
  if (v10 <= v8 + v7 && RB::verbose_mode(a1))
  {
    v11 = RB::RenderState::name((RB::RenderState *)a2);
    v12 = *((_DWORD *)a2 + 2);
    v16 = *a2;
    v17 = v12;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v16, (uint64_t)v18);
    printf("deleted render pipeline %s-%s\n", v11, v18);
    fflush((FILE *)*MEMORY[0x24BDAC8E8]);
  }
  v13 = (char *)*((_QWORD *)a3 + 1);
  if (*v13)
    v14 = 1;
  else
    v14 = v10 > v9;
  v15 = v14;
  *v13 = v15;
  return v4;
}

void RB::Device::RenderPipelineEntry::Loader::finished(void)::$_0::__invoke(uint64_t a1)
{
  RB::Device::install_render_pipeline_state(*(_QWORD *)(a1 + 8), *(_QWORD *)(a1 + 16), *(_DWORD *)(a1 + 24), a1);
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyEEEDaS1_(uint64_t a1)
{
  return *(unsigned int *)(a1 + 20);
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_T0_E_8__invokeIPKNS_21GlyphPathCacheDetails8GlyphKeyES8_EEDaS1_S2_(float32x2_t *a1, float32x2_t *a2)
{
  uint32x2_t v2;

  if (a1->i32[0] != a2->i32[0]
    || a1[2].u16[1] != a2[2].u16[1]
    || a1->f32[1] != a2->f32[1]
    || a1[2].u8[0] != a2[2].u8[0])
  {
    return 0;
  }
  v2 = (uint32x2_t)vceq_f32(a1[1], a2[1]);
  return vpmin_u32(v2, v2).u32[0] >> 31;
}

uint64_t _ZZN2RB14GlyphPathCacheC1EvENUlT_E0_8__invokeIPNS0_4PathEEEDaS1_(uint64_t result)
{
  void *v1;

  if (result)
  {
    v1 = *(void **)(result + 48);
    if (v1)
      free(v1);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (a2)
  {
    std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::clear((uint64_t *)(a2 + 24));
    v3 = *(unsigned int **)(a2 + 8);
    if (v3)
    {
      v4 = v3 + 2;
      do
      {
        v5 = __ldxr(v4);
        v6 = v5 - 1;
      }
      while (__stlxr(v6, v4));
      if (!v6)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
      }
    }
    JUMPOUT(0x20BD16544);
  }
}

void std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::clear(uint64_t *a1)
{
  uint64_t *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;

  if (a1[2])
  {
    v3 = *a1;
    v2 = (uint64_t *)a1[1];
    v4 = *v2;
    *(_QWORD *)(v4 + 8) = *(_QWORD *)(*a1 + 8);
    **(_QWORD **)(v3 + 8) = v4;
    a1[2] = 0;
    if (v2 != a1)
    {
      do
      {
        v5 = (uint64_t *)v2[1];
        std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>((int)a1, v2);
        v2 = v5;
      }
      while (v5 != a1);
    }
  }
}

void std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>(int a1, _QWORD *__p)
{
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  v3 = (unsigned int *)__p[2];
  if (v3)
  {
    v4 = v3 + 2;
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
    }
  }
  operator delete(__p);
}

void RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::for_each<RB::Device::~Device()::$_0>(RB::Device::~Device()::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(os_unfair_lock_s *a1, uint64_t a2, void **a3)
{
  RB::CustomShader::Library::remove_observer(a1, *a3);
}

void *RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 8) + (*((_QWORD *)__dst + 8) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 8) + (*((_QWORD *)__dst + 8) >> 1);
  result = RB::details::realloc_vector<unsigned long,24ul>(*((void **)__dst + 6), __dst, 2uLL, (unint64_t *)__dst + 8, v3);
  *((_QWORD *)__dst + 6) = result;
  return result;
}

void _ZZNK2RB5TableIPKNS_20FormattedRenderStateEPNS_6Device19RenderPipelineEntryEE8for_eachIZZNS4_23remove_function_libraryERNS_12CustomShader7LibraryEEUb_E4__10EEvT_ENUlPKvSF_PvE_8__invokeESF_SF_SG_(int a1, RB::Device::RenderPipelineEntry *this)
{
  RB::Device::RenderPipelineEntry::clear_custom_functions(this);
}

BOOL RB::Table<unsigned long,RB::TextureCache *>::remove_if<RB::Device::prune_caches(void)::$_0>(RB::Device::prune_caches(void)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(int a1, RB::TextureCache *this, uint64_t a3)
{
  return RB::TextureCache::prune_caches(this, *(_DWORD *)a3, *(_DWORD *)(a3 + 4), *(_DWORD *)(a3 + 8), *(_DWORD *)(a3 + 12));
}

uint64_t RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::remove_if<RB::Device::prune_caches(void)::$_3>(RB::Device::prune_caches(void)::$_3)::{lambda(void const*,void const*,void *)#1}::__invoke(int a1, RB::FunctionLibrary *this, int *a3)
{
  if (!this)
    return 0;
  if (!*((_BYTE *)this + 112) && *((_DWORD *)this + 6) <= *a3)
    return 1;
  RB::FunctionLibrary::prune_caches(this, *a3);
  return 0;
}

void *RB::vector<RB::FormattedRenderState,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,12ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,12ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(12 * a3);
    v6 = v5 / 0xC;
    if (v5 / 0xC != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *std::get_temporary_buffer[abi:nn180100]<RB::FormattedRenderState>(uint64_t a1)
{
  unint64_t v1;
  const std::nothrow_t *v2;
  void *result;
  BOOL v4;

  if (a1 < 1)
    return 0;
  if (a1 >= 0xAAAAAAAAAAAAAAALL)
    v1 = 0xAAAAAAAAAAAAAAALL;
  else
    v1 = a1;
  v2 = (const std::nothrow_t *)MEMORY[0x24BEDB6B8];
  while (1)
  {
    result = operator new(12 * v1, v2);
    if (result)
      break;
    v4 = v1 > 1;
    v1 >>= 1;
    if (!v4)
      return 0;
  }
  return result;
}

uint64_t std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, char *a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  int v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  uint64_t v33;
  unsigned int v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  unsigned int *v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unsigned int *v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int v55;
  unsigned int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  uint64_t v67;
  int v68;
  uint64_t v69;
  int v70;
  uint64_t v71;
  int v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  if (a3 < 2)
    return result;
  v6 = result;
  if (a3 == 2)
  {
    v7 = 0;
    v9 = a2 - 12;
    v8 = *(_QWORD *)(a2 - 12);
    v10 = *((_DWORD *)a2 - 1);
    v11 = *(_QWORD *)result;
    v12 = *(_DWORD *)(result + 8);
    v71 = v8;
    v72 = v10;
    v69 = v11;
    v70 = v12;
    while (1)
    {
      v13 = *((unsigned __int8 *)&v71 + v7);
      v14 = *((unsigned __int8 *)&v69 + v7);
      if (v13 != v14)
        break;
      if (++v7 == 12)
        goto LABEL_40;
    }
    if (v13 < v14)
    {
LABEL_47:
      v43 = *(_DWORD *)(result + 8);
      v44 = *(_QWORD *)result;
      v45 = *((_DWORD *)a2 - 1);
      *(_QWORD *)result = *(_QWORD *)v9;
      *(_DWORD *)(result + 8) = v45;
      *(_QWORD *)v9 = v44;
      *((_DWORD *)a2 - 1) = v43;
      return result;
    }
LABEL_40:
    v35 = 0;
    v67 = v8;
    v68 = v10;
    v65 = v11;
    v66 = v12;
    while (1)
    {
      v36 = *((unsigned __int8 *)&v67 + v35);
      v37 = *((unsigned __int8 *)&v65 + v35);
      if (v36 != v37)
        break;
      if (++v35 == 12)
        return result;
    }
    if (v36 >= v37)
      goto LABEL_47;
  }
  else if ((uint64_t)a3 > 128)
  {
    v39 = (unsigned int *)a4;
    v40 = a3 >> 1;
    v41 = result + 12 * (a3 >> 1);
    v42 = a3 >> 1;
    if ((uint64_t)a3 <= a5)
    {
      std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v41, v42, a4);
      v46 = (uint64_t)&v39[3 * v40];
      result = std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6 + 12 * (a3 >> 1), (uint64_t)a2, a3 - (a3 >> 1), v46);
      v47 = &v39[3 * a3];
      v48 = v46;
      while ((unsigned int *)v48 != v47)
      {
        result = 0;
        v49 = *(_QWORD *)v48;
        v50 = *(_DWORD *)(v48 + 8);
        v51 = *(_QWORD *)v39;
        v52 = v39[2];
        v71 = *(_QWORD *)v48;
        v72 = v50;
        v69 = v51;
        v70 = v52;
        while (1)
        {
          v53 = *((unsigned __int8 *)&v71 + result);
          v54 = *((unsigned __int8 *)&v69 + result);
          if (v53 != v54)
            break;
          if (++result == 12)
            goto LABEL_55;
        }
        if (v53 < v54)
        {
LABEL_61:
          v58 = *(_QWORD *)v48;
          *(_DWORD *)(v6 + 8) = *(_DWORD *)(v48 + 8);
          *(_QWORD *)v6 = v58;
          v48 += 12;
          goto LABEL_62;
        }
LABEL_55:
        result = 0;
        v67 = v49;
        v68 = v50;
        v65 = v51;
        v66 = v52;
        while (1)
        {
          v55 = *((unsigned __int8 *)&v67 + result);
          v56 = *((unsigned __int8 *)&v65 + result);
          if (v55 != v56)
            break;
          if (++result == 12)
            goto LABEL_60;
        }
        if (v55 >= v56)
          goto LABEL_61;
LABEL_60:
        v57 = *(_QWORD *)v39;
        *(_DWORD *)(v6 + 8) = v39[2];
        *(_QWORD *)v6 = v57;
        v39 += 3;
LABEL_62:
        v6 += 12;
        if (v39 == (unsigned int *)v46)
        {
          if ((unsigned int *)v48 != v47)
          {
            v59 = 0;
            do
            {
              v60 = v6 + v59;
              v61 = *(_QWORD *)(v48 + v59);
              *(_DWORD *)(v60 + 8) = *(_DWORD *)(v48 + v59 + 8);
              *(_QWORD *)v60 = v61;
              v59 += 12;
            }
            while ((unsigned int *)(v48 + v59) != v47);
          }
          return result;
        }
      }
      if (v39 != (unsigned int *)v46)
      {
        v62 = 0;
        do
        {
          v63 = v6 + v62 * 4;
          v64 = *(_QWORD *)&v39[v62];
          *(_DWORD *)(v63 + 8) = v39[v62 + 2];
          *(_QWORD *)v63 = v64;
          v62 += 3;
        }
        while (&v39[v62] != (unsigned int *)v46);
      }
    }
    else
    {
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v41, v42, a4, a5);
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6 + 12 * (a3 >> 1), a2, a3 - (a3 >> 1), v39, a5);
      return std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v6, (char *)(v6 + 12 * (a3 >> 1)), a2, a3 >> 1, a3 - (a3 >> 1), v39, a5);
    }
  }
  else if ((char *)result != a2)
  {
    v16 = result + 12;
    if ((char *)(result + 12) != a2)
    {
      v17 = result;
      while (1)
      {
        result = 0;
        v18 = v17;
        v17 = v16;
        v19 = *(_QWORD *)(v18 + 12);
        v20 = *(_DWORD *)(v18 + 20);
        v21 = *(_QWORD *)v18;
        v22 = *(_DWORD *)(v18 + 8);
        v71 = v19;
        v72 = v20;
        v69 = v21;
        v70 = v22;
        while (1)
        {
          v23 = *((unsigned __int8 *)&v71 + result);
          v24 = *((unsigned __int8 *)&v69 + result);
          if (v23 != v24)
            break;
          if (++result == 12)
            goto LABEL_17;
        }
        if (v23 < v24)
          break;
LABEL_17:
        result = 0;
        v67 = v19;
        v68 = v20;
        v65 = v21;
        v66 = v22;
        while (1)
        {
          v25 = *((unsigned __int8 *)&v67 + result);
          v26 = *((unsigned __int8 *)&v65 + result);
          if (v25 != v26)
            break;
          if (++result == 12)
            goto LABEL_37;
        }
        if (v25 >= v26)
          break;
LABEL_37:
        v16 = v17 + 12;
        if ((char *)(v17 + 12) == a2)
          return result;
      }
      v27 = v17;
      while (1)
      {
        v28 = v27;
        v27 = v18;
        *(_QWORD *)v28 = *(_QWORD *)v18;
        *(_DWORD *)(v28 + 8) = *(_DWORD *)(v18 + 8);
        if (v18 == v6)
          break;
        v29 = 0;
        v18 -= 12;
        v30 = *(_QWORD *)(v27 - 12);
        result = *(unsigned int *)(v27 - 4);
        v71 = v19;
        v72 = v20;
        v69 = v30;
        v70 = result;
        while (1)
        {
          v31 = *((unsigned __int8 *)&v71 + v29);
          v32 = *((unsigned __int8 *)&v69 + v29);
          if (v31 != v32)
            break;
          if (++v29 == 12)
            goto LABEL_29;
        }
        if (v31 < v32)
          continue;
LABEL_29:
        v33 = 0;
        v67 = v19;
        v68 = v20;
        v65 = v30;
        v66 = result;
        while (1)
        {
          v34 = *((unsigned __int8 *)&v67 + v33);
          result = *((unsigned __int8 *)&v65 + v33);
          if (v34 != (_DWORD)result)
            break;
          if (++v33 == 12)
            goto LABEL_36;
        }
        if (v34 < result)
          goto LABEL_36;
      }
      v27 = v6;
LABEL_36:
      *(_QWORD *)v27 = v19;
      *(_DWORD *)(v27 + 8) = v20;
      goto LABEL_37;
    }
  }
  return result;
}

uint64_t std::__stable_sort_move<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, uint64_t a2, unint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;
  unsigned int v30;
  BOOL v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  unsigned int v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  int v53;
  unsigned int v54;
  uint64_t v55;
  unsigned int v56;
  unsigned int v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  uint64_t v72;
  int v73;
  uint64_t v74;
  int v75;
  uint64_t v76;
  int v77;
  uint64_t v78;

  v78 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    v4 = a4;
    v7 = result;
    if (a3 == 2)
    {
      v9 = 0;
      v11 = (uint64_t *)(a2 - 12);
      v10 = *(_QWORD *)(a2 - 12);
      v12 = *(_DWORD *)(a2 - 4);
      v13 = *(_QWORD *)result;
      v14 = *(_DWORD *)(result + 8);
      v76 = v10;
      v77 = v12;
      v74 = v13;
      v75 = v14;
      while (1)
      {
        v15 = *((unsigned __int8 *)&v76 + v9);
        v16 = *((unsigned __int8 *)&v74 + v9);
        if (v15 != v16)
          break;
        if (++v9 == 12)
          goto LABEL_40;
      }
      if (v15 < v16)
      {
LABEL_65:
        v66 = *v11;
        *(_DWORD *)(a4 + 8) = *(_DWORD *)(a2 - 4);
        *(_QWORD *)a4 = v66;
        v64 = *(_QWORD *)result;
        v65 = *(_DWORD *)(result + 8);
        goto LABEL_66;
      }
LABEL_40:
      v44 = 0;
      v72 = v10;
      v73 = v12;
      v70 = v13;
      v71 = v14;
      while (1)
      {
        v45 = *((unsigned __int8 *)&v72 + v44);
        v46 = *((unsigned __int8 *)&v70 + v44);
        if (v45 != v46)
          break;
        if (++v44 == 12)
          goto LABEL_64;
      }
      if (v45 >= v46)
        goto LABEL_65;
LABEL_64:
      v63 = *(_QWORD *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(_QWORD *)a4 = v63;
      v64 = *v11;
      v65 = *(_DWORD *)(a2 - 4);
LABEL_66:
      *(_DWORD *)(a4 + 20) = v65;
      *(_QWORD *)(a4 + 12) = v64;
    }
    else if (a3 == 1)
    {
      v8 = *(_QWORD *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(_QWORD *)a4 = v8;
    }
    else if ((uint64_t)a3 > 8)
    {
      v47 = result + 12 * (a3 >> 1);
      std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(result, v47, a3 >> 1, a4, a3 >> 1);
      result = std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v7 + 12 * (a3 >> 1), a2, a3 - (a3 >> 1), v4 + 12 * (a3 >> 1), a3 - (a3 >> 1));
      v48 = v7 + 12 * (a3 >> 1);
      while (v48 != a2)
      {
        v49 = 0;
        v50 = *(_QWORD *)v48;
        v51 = *(_DWORD *)(v48 + 8);
        v52 = *(_QWORD *)v7;
        v53 = *(_DWORD *)(v7 + 8);
        v76 = *(_QWORD *)v48;
        v77 = v51;
        v74 = v52;
        v75 = v53;
        while (1)
        {
          result = *((unsigned __int8 *)&v76 + v49);
          v54 = *((unsigned __int8 *)&v74 + v49);
          if ((_DWORD)result != v54)
            break;
          if (++v49 == 12)
            goto LABEL_51;
        }
        if (result < v54)
        {
LABEL_57:
          v59 = *(_QWORD *)v48;
          *(_DWORD *)(v4 + 8) = *(_DWORD *)(v48 + 8);
          *(_QWORD *)v4 = v59;
          v48 += 12;
          goto LABEL_58;
        }
LABEL_51:
        v55 = 0;
        v72 = v50;
        v73 = v51;
        v70 = v52;
        v71 = v53;
        while (1)
        {
          v56 = *((unsigned __int8 *)&v72 + v55);
          v57 = *((unsigned __int8 *)&v70 + v55);
          if (v56 != v57)
            break;
          if (++v55 == 12)
            goto LABEL_56;
        }
        if (v56 >= v57)
          goto LABEL_57;
LABEL_56:
        v58 = *(_QWORD *)v7;
        *(_DWORD *)(v4 + 8) = *(_DWORD *)(v7 + 8);
        *(_QWORD *)v4 = v58;
        v7 += 12;
LABEL_58:
        v4 += 12;
        if (v7 == v47)
        {
          if (v48 != a2)
          {
            v60 = 0;
            do
            {
              v61 = v4 + v60;
              v62 = *(_QWORD *)(v48 + v60);
              *(_DWORD *)(v61 + 8) = *(_DWORD *)(v48 + v60 + 8);
              *(_QWORD *)v61 = v62;
              v60 += 12;
            }
            while (v48 + v60 != a2);
          }
          return result;
        }
      }
      if (v7 != v47)
      {
        v67 = 0;
        do
        {
          v68 = v4 + v67;
          v69 = *(_QWORD *)(v7 + v67);
          *(_DWORD *)(v68 + 8) = *(_DWORD *)(v7 + v67 + 8);
          *(_QWORD *)v68 = v69;
          v67 += 12;
        }
        while (v7 + v67 != v47);
      }
    }
    else if (result != a2)
    {
      v17 = *(_QWORD *)result;
      *(_DWORD *)(a4 + 8) = *(_DWORD *)(result + 8);
      *(_QWORD *)a4 = v17;
      v18 = result + 12;
      if (result + 12 != a2)
      {
        v19 = a4;
        while (1)
        {
          v20 = 0;
          v21 = v7;
          v22 = v19;
          v7 = v18;
          v19 += 12;
          v23 = *(_QWORD *)(v21 + 12);
          v24 = *(_DWORD *)(v21 + 20);
          result = *(_QWORD *)v22;
          v25 = *(_DWORD *)(v22 + 8);
          v76 = v23;
          v77 = v24;
          v74 = result;
          v75 = v25;
          while (1)
          {
            v26 = *((unsigned __int8 *)&v76 + v20);
            v27 = *((unsigned __int8 *)&v74 + v20);
            if (v26 != v27)
              break;
            if (++v20 == 12)
              goto LABEL_18;
          }
          if (v26 < v27)
            break;
LABEL_18:
          v28 = 0;
          v72 = v23;
          v73 = v24;
          v70 = result;
          v71 = v25;
          while (1)
          {
            v29 = *((unsigned __int8 *)&v72 + v28);
            v30 = *((unsigned __int8 *)&v70 + v28);
            v31 = v29 >= v30;
            if (v29 != v30)
              break;
            if (++v28 == 12)
            {
              v32 = v19;
              goto LABEL_37;
            }
          }
          v32 = v19;
          if (v31)
            break;
LABEL_37:
          v43 = *(_QWORD *)v7;
          *(_DWORD *)(v32 + 8) = *(_DWORD *)(v7 + 8);
          *(_QWORD *)v32 = v43;
          v18 = v7 + 12;
          if (v7 + 12 == a2)
            return result;
        }
        *(_QWORD *)v19 = *(_QWORD *)v22;
        *(_DWORD *)(v19 + 8) = *(_DWORD *)(v22 + 8);
        v32 = v4;
        if (v22 != v4)
        {
          while (2)
          {
            v33 = 0;
            v32 = v22;
            v34 = *(_QWORD *)v7;
            v36 = *(_QWORD *)(v22 - 12);
            v22 -= 12;
            v35 = v36;
            result = *(unsigned int *)(v21 + 20);
            v37 = *(_DWORD *)(v22 + 8);
            v76 = *(_QWORD *)v7;
            v77 = result;
            v74 = v36;
            v75 = v37;
            while (1)
            {
              v38 = *((unsigned __int8 *)&v76 + v33);
              v39 = *((unsigned __int8 *)&v74 + v33);
              if (v38 != v39)
                break;
              if (++v33 == 12)
                goto LABEL_30;
            }
            if (v38 < v39)
              goto LABEL_35;
LABEL_30:
            v40 = 0;
            v72 = v34;
            v73 = result;
            v70 = v35;
            v71 = v37;
            while (1)
            {
              v41 = *((unsigned __int8 *)&v72 + v40);
              v42 = *((unsigned __int8 *)&v70 + v40);
              if (v41 != v42)
                break;
              if (++v40 == 12)
                goto LABEL_37;
            }
            if (v41 < v42)
              goto LABEL_37;
LABEL_35:
            *(_QWORD *)v32 = *(_QWORD *)v22;
            *(_DWORD *)(v32 + 8) = *(_DWORD *)(v22 + 8);
            if (v22 != v4)
              continue;
            break;
          }
          v32 = v4;
        }
        goto LABEL_37;
      }
    }
  }
  return result;
}

uint64_t std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(uint64_t result, char *a2, char *a3, uint64_t a4, uint64_t a5, unsigned int *a6, uint64_t a7)
{
  uint64_t v8;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  int v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  int v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;
  unsigned int v37;
  unsigned int v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  int v43;
  uint64_t v44;
  unint64_t v45;
  unint64_t v46;
  uint64_t v47;
  int v48;
  unsigned int v49;
  unsigned int v50;
  uint64_t v51;
  unsigned int v52;
  unsigned int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  char *v57;
  uint64_t v58;
  uint64_t v59;
  char *v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  unint64_t v64;
  char *v65;
  uint64_t v66;
  unsigned int *v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  unsigned int v74;
  unsigned int v75;
  uint64_t v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  unint64_t v80;
  char *v81;
  uint64_t v82;
  unsigned int *v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  unsigned int v88;
  unsigned int v89;
  uint64_t v90;
  unsigned int v91;
  unsigned int v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  char *v99;
  uint64_t v100;
  uint64_t v101;
  char *v102;
  unsigned int *v103;
  uint64_t v104;
  uint64_t v105;
  int v106;
  uint64_t v107;
  int v108;
  uint64_t v109;
  int v110;
  uint64_t v111;
  int v112;
  uint64_t v113;

  v113 = *MEMORY[0x24BDAC8D0];
  if (a5)
  {
    v8 = a5;
    v11 = (char *)result;
    result = 12;
    while (2)
    {
      if (v8 <= a7 || a4 <= a7)
      {
        if (a4 <= v8)
        {
          if (v11 != a2)
          {
            v80 = 0;
            do
            {
              v81 = (char *)&a6[v80 / 4];
              v82 = *(_QWORD *)&v11[v80];
              *((_DWORD *)v81 + 2) = *(_DWORD *)&v11[v80 + 8];
              *(_QWORD *)v81 = v82;
              v80 += 12;
            }
            while (&v11[v80] != a2);
            if (v80)
            {
              v83 = a6;
              while (a2 != a3)
              {
                v84 = 0;
                v85 = *(_QWORD *)a2;
                v86 = *((_DWORD *)a2 + 2);
                v87 = *(_QWORD *)v83;
                result = v83[2];
                v111 = *(_QWORD *)a2;
                v112 = v86;
                v109 = v87;
                v110 = result;
                while (1)
                {
                  v88 = *((unsigned __int8 *)&v111 + v84);
                  v89 = *((unsigned __int8 *)&v109 + v84);
                  if (v88 != v89)
                    break;
                  if (++v84 == 12)
                    goto LABEL_97;
                }
                if (v88 < v89)
                {
LABEL_103:
                  v94 = *(_QWORD *)a2;
                  *((_DWORD *)v11 + 2) = *((_DWORD *)a2 + 2);
                  *(_QWORD *)v11 = v94;
                  a2 += 12;
                  goto LABEL_104;
                }
LABEL_97:
                v90 = 0;
                v107 = v85;
                v108 = v86;
                v105 = v87;
                v106 = result;
                while (1)
                {
                  v91 = *((unsigned __int8 *)&v107 + v90);
                  v92 = *((unsigned __int8 *)&v105 + v90);
                  if (v91 != v92)
                    break;
                  if (++v90 == 12)
                    goto LABEL_102;
                }
                if (v91 >= v92)
                  goto LABEL_103;
LABEL_102:
                v93 = *(_QWORD *)v83;
                *((_DWORD *)v11 + 2) = v83[2];
                *(_QWORD *)v11 = v93;
                v83 += 3;
LABEL_104:
                v11 += 12;
                if (&a6[v80 / 4] == v83)
                  return result;
              }
              return (uint64_t)memmove(v11, v83, (char *)a6 - (char *)v83 + v80);
            }
          }
        }
        else if (a2 != a3)
        {
          v64 = 0;
          do
          {
            v65 = (char *)&a6[v64 / 4];
            v66 = *(_QWORD *)&a2[v64];
            *((_DWORD *)v65 + 2) = *(_DWORD *)&a2[v64 + 8];
            *(_QWORD *)v65 = v66;
            v64 += 12;
          }
          while (&a2[v64] != a3);
          if (v64)
          {
            v67 = &a6[v64 / 4];
            while (a2 != v11)
            {
              v68 = 0;
              v69 = a2 - 12;
              v70 = *(_QWORD *)(a2 - 12);
              v71 = *(_QWORD *)(v67 - 3);
              v72 = *(v67 - 1);
              v73 = *((_DWORD *)a2 - 1);
              v111 = v71;
              v112 = v72;
              v109 = v70;
              v110 = v73;
              while (1)
              {
                v74 = *((unsigned __int8 *)&v111 + v68);
                v75 = *((unsigned __int8 *)&v109 + v68);
                if (v74 != v75)
                  break;
                if (++v68 == 12)
                  goto LABEL_78;
              }
              if (v74 < v75)
              {
                result = (uint64_t)(a2 - 12);
                goto LABEL_84;
              }
LABEL_78:
              v76 = 0;
              v107 = v71;
              v108 = v72;
              v105 = v70;
              v106 = v73;
              while (1)
              {
                v77 = *((unsigned __int8 *)&v107 + v76);
                v78 = *((unsigned __int8 *)&v105 + v76);
                if (v77 != v78)
                  break;
                if (++v76 == 12)
                  goto LABEL_83;
              }
              result = (uint64_t)(a2 - 12);
              if (v77 >= v78)
                goto LABEL_84;
LABEL_83:
              v69 = (char *)(v67 - 3);
              result = (uint64_t)a2;
              v67 -= 3;
LABEL_84:
              v79 = *((_DWORD *)v69 + 2);
              *(_QWORD *)(a3 - 12) = *(_QWORD *)v69;
              a3 -= 12;
              *((_DWORD *)a3 + 2) = v79;
              a2 = (char *)result;
              if (v67 == a6)
                return result;
            }
            v98 = 0;
            do
            {
              v99 = &a3[v98 * 4];
              v100 = *(_QWORD *)&v67[v98 - 3];
              *((_DWORD *)v99 - 1) = v67[v98 - 1];
              *(_QWORD *)(v99 - 12) = v100;
              v98 -= 3;
            }
            while (&v67[v98] != a6);
          }
        }
      }
      else if (a4)
      {
        while (2)
        {
          v12 = 0;
          v13 = *(_QWORD *)a2;
          v14 = *((_DWORD *)a2 + 2);
          v15 = *(_QWORD *)v11;
          v16 = *((_DWORD *)v11 + 2);
          v111 = *(_QWORD *)a2;
          v112 = v14;
          v109 = v15;
          v110 = v16;
          while (1)
          {
            v17 = *((unsigned __int8 *)&v111 + v12);
            v18 = *((unsigned __int8 *)&v109 + v12);
            if (v17 != v18)
              break;
            if (++v12 == 12)
              goto LABEL_11;
          }
          if (v17 >= v18)
          {
LABEL_11:
            v19 = 0;
            v107 = v13;
            v108 = v14;
            v105 = v15;
            v106 = v16;
            while (1)
            {
              v20 = *((unsigned __int8 *)&v107 + v19);
              v21 = *((unsigned __int8 *)&v105 + v19);
              if (v20 != v21)
                break;
              if (++v19 == 12)
                goto LABEL_16;
            }
            if (v20 >= v21)
              break;
LABEL_16:
            v11 += 12;
            if (--a4)
              continue;
            return result;
          }
          break;
        }
        v102 = a3;
        v103 = a6;
        v104 = a7;
        if (a4 >= v8)
        {
          if (a4 == 1)
          {
            v95 = *(_QWORD *)v11;
            v112 = *((_DWORD *)v11 + 2);
            v111 = v95;
            v96 = *(_QWORD *)a2;
            *((_DWORD *)v11 + 2) = *((_DWORD *)a2 + 2);
            *(_QWORD *)v11 = v96;
            v97 = v111;
            *((_DWORD *)a2 + 2) = v112;
            *(_QWORD *)a2 = v97;
            return result;
          }
          if (a4 >= 0)
            v39 = a4;
          else
            v39 = a4 + 1;
          v40 = v39 >> 1;
          v28 = &v11[12 * (v39 >> 1)];
          if (a3 != a2)
          {
            v41 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2);
            v42 = *(_QWORD *)v28;
            v43 = *((_DWORD *)v28 + 2);
            v24 = (uint64_t)a2;
            while (1)
            {
              v44 = 0;
              v45 = v41 >> 1;
              v46 = v24 + 12 * (v41 >> 1);
              v47 = *(_QWORD *)v46;
              v48 = *(_DWORD *)(v46 + 8);
              v111 = *(_QWORD *)v46;
              v112 = v48;
              v109 = v42;
              v110 = v43;
              while (1)
              {
                v49 = *((unsigned __int8 *)&v111 + v44);
                v50 = *((unsigned __int8 *)&v109 + v44);
                if (v49 != v50)
                  break;
                if (++v44 == 12)
                  goto LABEL_48;
              }
              if (v49 < v50)
                break;
LABEL_48:
              v51 = 0;
              v107 = v47;
              v108 = v48;
              v105 = v42;
              v106 = v43;
              while (1)
              {
                v52 = *((unsigned __int8 *)&v107 + v51);
                v53 = *((unsigned __int8 *)&v105 + v51);
                if (v52 != v53)
                  break;
                if (++v51 == 12)
                  goto LABEL_54;
              }
              if (v52 >= v53)
                break;
LABEL_54:
              v41 = v45;
              if (!v45)
                goto LABEL_59;
            }
            v24 = v46 + 12;
            v45 = v41 + ~v45;
            goto LABEL_54;
          }
          v24 = (uint64_t)a3;
LABEL_59:
          v23 = 0xAAAAAAAAAAAAAAABLL * ((v24 - (uint64_t)a2) >> 2);
        }
        else
        {
          if (v8 >= 0)
            v22 = v8;
          else
            v22 = v8 + 1;
          v23 = v22 >> 1;
          v24 = (uint64_t)&a2[12 * (v22 >> 1)];
          if (a2 == v11)
          {
            v28 = a2;
          }
          else
          {
            v25 = 0xAAAAAAAAAAAAAAABLL * ((a2 - v11) >> 2);
            v26 = *(_QWORD *)v24;
            v27 = *(_DWORD *)(v24 + 8);
            v28 = v11;
            do
            {
              v29 = 0;
              v30 = v25 >> 1;
              v31 = &v28[12 * (v25 >> 1)];
              v32 = *(_QWORD *)v31;
              v33 = *((_DWORD *)v31 + 2);
              v111 = v26;
              v112 = v27;
              v109 = v32;
              v110 = v33;
              while (1)
              {
                v34 = *((unsigned __int8 *)&v111 + v29);
                v35 = *((unsigned __int8 *)&v109 + v29);
                if (v34 != v35)
                  break;
                if (++v29 == 12)
                  goto LABEL_29;
              }
              if (v34 < v35)
                goto LABEL_35;
LABEL_29:
              v36 = 0;
              v107 = v26;
              v108 = v27;
              v105 = v32;
              v106 = v33;
              while (1)
              {
                v37 = *((unsigned __int8 *)&v107 + v36);
                v38 = *((unsigned __int8 *)&v105 + v36);
                if (v37 != v38)
                  break;
                if (++v36 == 12)
                  goto LABEL_34;
              }
              if (v37 >= v38)
                goto LABEL_35;
LABEL_34:
              v28 = v31 + 12;
              v30 = v25 + ~v30;
LABEL_35:
              v25 = v30;
            }
            while (v30);
          }
          v40 = 0xAAAAAAAAAAAAAAABLL * ((v28 - v11) >> 2);
        }
        v101 = v24;
        a4 -= v40;
        v54 = v8 - v23;
        v55 = v40;
        v56 = v23;
        v57 = std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *,RB::FormattedRenderState *>(v28, a2, v24);
        v58 = v56;
        v8 = v54;
        v59 = v55;
        a3 = v57;
        if (v58 + v59 >= v54 + a4)
        {
          v61 = v59;
          v62 = a4;
          v63 = v58;
          std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v57, v101, v102, v62, v8, v103, v104);
          a2 = v28;
          a6 = v103;
          v8 = v63;
          a4 = v61;
        }
        else
        {
          v60 = v28;
          a6 = v103;
          std::__inplace_merge<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>(v11, v60, v57, v59, v58, v103, v104);
          v11 = a3;
          a2 = (char *)v101;
          a3 = v102;
        }
        a7 = v104;
        result = 12;
        if (v8)
          continue;
      }
      break;
    }
  }
  return result;
}

char *std::__rotate[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *,RB::FormattedRenderState *>(char *__src, char *a2, uint64_t a3)
{
  char *v4;
  uint64_t v6;
  size_t v7;
  uint64_t v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = (char *)a3;
  if (__src != a2)
  {
    if (a2 == (char *)a3)
    {
      return __src;
    }
    else if (__src + 12 == a2)
    {
      v9 = *(_QWORD *)__src;
      v11 = *((_DWORD *)__src + 2);
      v6 = a3 - (_QWORD)a2;
      memmove(__src, a2, a3 - (_QWORD)a2);
      v4 = &__src[v6];
      *(_QWORD *)v4 = v9;
      *((_DWORD *)v4 + 2) = v11;
    }
    else if (a2 + 12 == (char *)a3)
    {
      v4 = __src + 12;
      v10 = *(_QWORD *)(a3 - 12);
      v12 = *(_DWORD *)(a3 - 4);
      v7 = a3 - 12 - (_QWORD)__src;
      if ((char *)(a3 - 12) != __src)
        memmove(__src + 12, __src, v7);
      *(_QWORD *)__src = v10;
      *((_DWORD *)__src + 2) = v12;
    }
    else
    {
      return (char *)std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *>((uint64_t)__src, (uint64_t)a2, a3);
    }
  }
  return v4;
}

uint64_t std::__rotate_gcd[abi:nn180100]<std::_ClassicAlgPolicy,RB::FormattedRenderState *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  _QWORD *v17;
  uint64_t v18;
  unint64_t v19;
  BOOL v20;
  char v21;
  uint64_t v22;
  uint64_t v24;
  int v25;

  v3 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 2);
  if (v3 == 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2))
  {
    if (a1 != a2 && a2 != a3)
    {
      v4 = 0;
      do
      {
        v5 = a2 + v4;
        v6 = a1 + v4;
        v7 = *(_DWORD *)(a1 + v4 + 8);
        v8 = *(_QWORD *)(a1 + v4);
        v9 = *(_DWORD *)(a2 + v4 + 8);
        *(_QWORD *)v6 = *(_QWORD *)(a2 + v4);
        *(_DWORD *)(v6 + 8) = v9;
        *(_QWORD *)v5 = v8;
        *(_DWORD *)(v5 + 8) = v7;
        if (a1 + v4 + 12 == a2)
          break;
        v4 += 12;
      }
      while (v5 + 12 != a3);
    }
  }
  else
  {
    v10 = 0xAAAAAAAAAAAAAAABLL * ((a3 - a2) >> 2);
    v11 = 0xAAAAAAAAAAAAAAABLL * ((a2 - a1) >> 2);
    do
    {
      v12 = v11;
      v11 = v10;
      v10 = v12 % v10;
    }
    while (v10);
    if (v11)
    {
      v13 = a1 + 12 * v11;
      do
      {
        v14 = *(_QWORD *)(v13 - 12);
        v13 -= 12;
        v24 = v14;
        v25 = *(_DWORD *)(v13 + 8);
        v15 = (_QWORD *)(v13 + 4 * ((a2 - a1) >> 2));
        v16 = (_QWORD *)v13;
        do
        {
          v17 = v16;
          v16 = v15;
          v18 = *v15;
          *((_DWORD *)v17 + 2) = *((_DWORD *)v16 + 2);
          *v17 = v18;
          v19 = 0xAAAAAAAAAAAAAAABLL * ((a3 - (uint64_t)v16) >> 2);
          v20 = __OFSUB__(v3, v19);
          v22 = v3 - v19;
          v21 = (v22 < 0) ^ v20;
          v15 = (_QWORD *)(a1 + 12 * v22);
          if (v21)
            v15 = (_QWORD *)((char *)v16 + 4 * ((a2 - a1) >> 2));
        }
        while (v15 != (_QWORD *)v13);
        *((_DWORD *)v16 + 2) = v25;
        *v16 = v24;
      }
      while (v13 != a1);
    }
    return a1 + 4 * ((a3 - a2) >> 2);
  }
  return a2;
}

void std::default_delete<RB::Device::RenderPipelineEntry::Functions>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void **v3;
  unint64_t v4;
  void **v5;
  void *v6;
  void **v7;
  unint64_t v8;
  void *v9;

  if (a2)
  {
    v3 = *(void ***)(a2 + 24);
    if (*(_DWORD *)(a2 + 32))
    {
      v4 = 0;
      v5 = v3 + 1;
      do
      {
        v6 = *v5;
        v5 += 2;

        ++v4;
      }
      while (v4 < *(unsigned int *)(a2 + 32));
      v3 = *(void ***)(a2 + 24);
    }
    if (v3)
      free(v3);
    v7 = *(void ***)(a2 + 8);
    if (*(_DWORD *)(a2 + 16))
    {
      v8 = 0;
      do
      {
        v9 = *v7;
        v7 += 10;

        ++v8;
      }
      while (v8 < *(unsigned int *)(a2 + 16));
      v7 = *(void ***)(a2 + 8);
    }
    if (v7)
      free(v7);

    JUMPOUT(0x20BD16544);
  }
}

void *RB::vector<RB::Device::RenderPipelineEntry::Functions::Table,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,80ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,80ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(80 * a3);
    v6 = v5 / 0x50;
    if (*a2 != (v5 / 0x50))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t OUTLINED_FUNCTION_0(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

BOOL RB::pointer_compare(RB *this, RB *a2, const void *a3)
{
  return this == a2;
}

void RB::UntypedTable::grow_buckets(RB::UntypedTable *this)
{
  unsigned int v1;
  _QWORD *v3;
  char v4;
  size_t *v5;
  RB::Heap *v6;
  size_t v7;
  void *v8;
  uint64_t v9;
  int v10;
  unint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  uint64_t v15;

  v1 = *((_DWORD *)this + 18);
  if (v1 > 0x1E)
    return;
  v3 = (_QWORD *)*((_QWORD *)this + 6);
  v4 = v1 + 1;
  *((_DWORD *)this + 18) = v1 + 1;
  if (v1 > 3)
  {
    v7 = 8 << v4;
    v9 = (uint64_t)malloc_type_malloc(8 << v4, 0x2004093837F09uLL);
  }
  else
  {
    v5 = (size_t *)*((_QWORD *)this + 4);
    if (!v5)
    {
      v6 = (RB::Heap *)operator new();
      v5 = (size_t *)RB::Heap::Heap(v6, 0, 0, 0x400uLL);
      *((_QWORD *)this + 4) = v5;
    }
    v7 = 8 << v4;
    v8 = (void *)((v5[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)v8 + v7 <= v5[3])
    {
      v5[2] = (size_t)v8 + v7;
      goto LABEL_9;
    }
    v9 = RB::Heap::alloc_slow(v5, v7, 7);
  }
  v8 = (void *)v9;
LABEL_9:
  bzero(v8, v7);
  v10 = *((_DWORD *)this + 18);
  if (v8)
  {
    v11 = 0;
    v12 = ~(-1 << v10);
    *((_QWORD *)this + 8) = v12;
    do
    {
      v13 = (_QWORD *)v3[v11];
      if (v13)
      {
        do
        {
          v14 = (_QWORD *)*v13;
          v15 = v13[3] & v12;
          *v13 = *((_QWORD *)v8 + v15);
          *((_QWORD *)v8 + v15) = v13;
          v13 = v14;
        }
        while (v14);
      }
      ++v11;
    }
    while (!(v11 >> v1));
    *((_QWORD *)this + 6) = v8;
    if (v1 > 4)
      free(v3);
  }
  else
  {
    *((_DWORD *)this + 18) = v10 - 1;
  }
}

uint64_t RB::UntypedTable::remove(RB::UntypedTable *this, void *a2)
{
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  _QWORD *v9;
  void (*v10)(_QWORD);
  void (*v11)(_QWORD);

  if (!*((_QWORD *)this + 7))
    return 0;
  if (*((_BYTE *)this + 77))
    return RB::UntypedTable::remove_ptr(this, a2);
  v5 = (*(uint64_t (**)(void *))this)(a2);
  v6 = (_QWORD *)(*((_QWORD *)this + 6) + 8 * (*((_QWORD *)this + 8) & v5));
  v7 = (_QWORD *)*v6;
  if (!*v6)
    return 0;
  v8 = v5;
  while (1)
  {
    v9 = v7;
    if (v7[3] == v8)
    {
      if ((*((unsigned int (**)(_QWORD, void *))this + 1))(v7[1], a2))
        break;
    }
    v7 = (_QWORD *)*v9;
    v6 = v9;
    if (!*v9)
      return 0;
  }
  *v6 = *v9;
  v10 = (void (*)(_QWORD))*((_QWORD *)this + 2);
  if (v10)
    v10(v9[1]);
  v11 = (void (*)(_QWORD))*((_QWORD *)this + 3);
  if (v11)
    v11(v9[2]);
  *v9 = *((_QWORD *)this + 5);
  *((_QWORD *)this + 5) = v9;
  --*((_QWORD *)this + 7);
  return 1;
}

uint64_t RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  unint64_t v4;
  unint64_t i;
  uint64_t v6;

  v2 = *(_QWORD **)(a1 + 32);
  if (v2)
    v3 = v2;
  else
    v3 = (_QWORD *)a1;
  v4 = *(unsigned int *)(a1 + 40);
  if ((_DWORD)v4)
  {
    for (i = 0; i < v4; ++i)
    {
      v6 = v3[i];
      v3[i] = 0;
      if (v6)
      {
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v2, v6);
        v4 = *(unsigned int *)(a1 + 40);
      }
    }
    v2 = *(_QWORD **)(a1 + 32);
  }
  if (v2)
    free(v2);
  return a1;
}

_QWORD **RB::shared_vector<RB::Function const*>::~shared_vector(_QWORD **a1)
{
  _QWORD *v2;

  v2 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(*a1);
  free(v2);
  return a1;
}

uint64_t RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  _QWORD *v9;

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v3)
  {
    v4 = v2 + 3;
    do
    {
      v6 = *v4++;
      v5 = v6;
      if ((v6 & 1) != 0)
      {
        v7 = (_DWORD *)(v5 & 0xFFFFFFFFFFFFFFFELL);
        v8 = *(_DWORD *)((v5 & 0xFFFFFFFFFFFFFFFELL) + 8) - 1;
        v7[2] = v8;
        if (!v8)
          (*(void (**)(_DWORD *))(*(_QWORD *)v7 + 8))(v7);
      }
      --v3;
    }
    while (v3);
  }
  v9 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v2);
  free(v9);
  return a1;
}

uint64_t RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(uint64_t a1)
{
  _QWORD *v2;
  uint64_t v3;
  _DWORD **v4;
  _DWORD *v5;
  int v6;
  _QWORD *v7;

  v2 = *(_QWORD **)a1;
  v3 = *(_QWORD *)(*(_QWORD *)a1 + 8);
  if (v3)
  {
    v4 = (_DWORD **)(v2 + 3);
    do
    {
      v5 = *v4;
      if (*v4)
      {
        v6 = v5[2] - 1;
        v5[2] = v6;
        if (!v6)
          (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 8))(v5);
      }
      ++v4;
      --v3;
    }
    while (v3);
  }
  v7 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v2);
  free(v7);
  return a1;
}

void RB::RenderFrame::add_continuation(uint64_t a1, NSObject *a2, void *a3)
{
  RB::Device::add_frame_continuation(*(_QWORD *)a1, *(_DWORD *)(a1 + 84), a2, a3);
}

void RB::RenderFrame::copy_texture(uint64_t *a1@<X0>, MTLPixelFormat a2@<X1>, uint64_t a3@<X2>, char a4@<W3>, uint64_t a5@<X4>, int32x2_t *a6@<X5>, _QWORD *a7@<X8>)
{
  int v13;
  RB *v14;
  int v15;
  _BOOL4 v16;
  RB *v17;
  RB *v18;
  BOOL v19;
  unsigned int *v20;
  MTLPixelFormat v21;
  uint64_t v22;
  int v23;
  unsigned int *v24;
  __n128 v25;
  unint64_t v26;
  RB *v27;
  unint64_t v28;
  uint32x2_t v29;
  unsigned int v30;
  int32x2_t v31;
  MTLPixelFormat v32;
  unsigned int *v33;
  RB::Buffer *v34;
  int v35;
  _OWORD *v36;
  __int128 v37;
  int v38;
  uint64_t v39;
  RB::Resource *v40;
  const char *v42;
  __int128 v43;
  __int128 v44;
  int32x2_t v45[17];
  int v46;
  int32x2_t v47;
  int32x2_t v48;
  int v49;
  int v50;
  int v51;
  int v52;
  char v53;
  RB::Buffer *v54;
  uint64_t v55;
  int v56;

  v13 = *(unsigned __int8 *)(a2 + 80);
  v14 = *(RB **)(a2 + 56);
  v15 = a4 & 2;
  if (v13 == (_DWORD)a3)
  {
    v16 = 0;
    v17 = *(RB **)(a2 + 56);
    if ((a4 & 2) != 0)
      goto LABEL_31;
  }
  else
  {
    if ((v13 & 0xFE) == (_DWORD)a3)
    {
      v18 = (RB *)*(unsigned int *)((char *)RB::pixel_format_traits(*(_QWORD *)(a2 + 56), a2) + 18);
    }
    else if ((v13 | 1) == (_DWORD)a3)
    {
      v18 = (RB *)RB::pixel_format_traits(*(_QWORD *)(a2 + 56), a2)[6];
    }
    else
    {
      v18 = 0;
    }
    v16 = v18 != 0;
    if (v18)
      v17 = v18;
    else
      v17 = v14;
    if (v15)
      goto LABEL_31;
  }
  if (!v17)
    v16 = 0;
  v19 = v13 != (_DWORD)a3 && !v16;
  if (v19 || (a4 & 1) != 0 && *(unsigned __int8 *)(a2 + 76) < 2u)
    goto LABEL_31;
  if (v14 == v17)
  {
    ++*(_DWORD *)(a2 + 8);
    *a7 = a2;
    return;
  }
  v20 = RB::pixel_format_traits((unint64_t)v14, a2);
  if (((*v20 | ((unint64_t)*((unsigned __int16 *)v20 + 2) << 32)) & 0x40000000000) != 0)
  {
    if (!RB::Texture::has_view_usage((id *)a2))
      goto LABEL_31;
    v14 = *(RB **)(a2 + 56);
  }
  if (RB::pixel_formats_support_view_copy(v14, v17, v21))
  {
    if ((*(_BYTE *)(a2 + 77) & 1) != 0 && (v22 = *(_QWORD *)(a2 + 24)) != 0 && *(RB **)(v22 + 56) == v17)
    {
      ++*(_DWORD *)(v22 + 8);
      *a7 = v22;
    }
    else
    {
      v39 = objc_msgSend(*(id *)(a2 + 16), "newTextureViewWithPixelFormat:", v17);
      v40 = (RB::Resource *)operator new();
      RB::Texture::Texture(v40, v39, a3, *(unsigned __int8 *)(a2 + 78), 0);
      *a7 = v40;
      RB::Resource::set_source(v40, (RB::Resource *)a2);
      *((_BYTE *)v40 + 77) |= 1u;
    }
    return;
  }
LABEL_31:
  v23 = *(unsigned __int8 *)(a2 + 79);
  v24 = RB::pixel_format_traits((unint64_t)v17, a2);
  v26 = v24[8];
  if (!v24[8])
    v26 = (unint64_t)v17;
  v27 = (RB *)HIDWORD(*((_QWORD *)v24 + 3));
  if (!v27)
    v27 = v17;
  if (v23)
    v28 = v26;
  else
    v28 = (unint64_t)v27;
  if (a6
    && *(_QWORD *)&a6[7] == v28
    && (v29 = (uint32x2_t)vceq_s32(a6[8], *(int32x2_t *)(a2 + 64)), (vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0)
    && ((a4 & 1) == 0) != a6[9].u8[4] > 1u
    && a6[9].i8[6] == 1)
  {
    ++a6[1].i32[0];
    a6[10].i8[0] = a3;
  }
  else
  {
    if ((a4 & 1) != 0)
      v30 = 0x7FFFFFFF;
    else
      v30 = 1;
    v25.n128_u64[0] = *(_QWORD *)(a2 + 64);
    RB::Texture::alloc(*a1, v28, v30, a3, 1, 0, (uint64_t *)v45, v25);
    a6 = (int32x2_t *)v45[0];
    if (!*(_QWORD *)v45)
    {
      *a7 = 0;
      return;
    }
  }
  RB::RenderPass::RenderPass(v45, a5, a6, 0, 1, 0);
  RB::RenderPass::set_label((id *)v45, CFSTR("RB: Color conversion"));
  RB::Coverage::set_plane((float32x2_t *)&v43, (uint64_t)v45, v31);
  LODWORD(v42) = 33;
  HIDWORD(v42) = 2 * (v46 == 2);
  RB::RenderState::set_color_conversion((int *)&v42, v13, a3, (_DWORD *)&v44 + 3);
  if (v15
    || (v33 = RB::pixel_format_traits(*(_QWORD *)(a2 + 56), v32),
        ((*v33 | ((unint64_t)*((unsigned __int16 *)v33 + 2) << 32)) & 0x100000000) == 0))
  {
    LODWORD(v42) = v42 & 0xF3FFFFFF | ((v15 & 3) << 26) | 0x4000000;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v45, (RB::Device *)0x20, 4uLL, 0, &v54);
  v34 = v54;
  if (v54)
  {
    v35 = v55;
    v36 = (_OWORD *)(*((_QWORD *)v54 + 7) + v55);
    v37 = v44;
    *v36 = v43;
    v36[1] = v37;
    v38 = v56;
  }
  else
  {
    v38 = 0;
    v35 = 0;
  }
  v49 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v45, v34);
  v50 = v35;
  v51 = v38;
  v52 = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v45, a2);
  v53 = 0;
  RB::RenderPass::draw_indexed_primitives(v45, v42, 4, ***(_QWORD ***)v45 + 80, 0, 1uLL, v47, v48);
  v52 = 0;
  v53 = 0;
  RB::RenderPass::~RenderPass((RB::RenderPass *)v45);
  if ((a4 & 1) != 0)
    RB::RenderFrame::invalidate_mipmaps(a1, (RB::Texture *)a6);
  *a7 = a6;
}

void sub_209B8A270(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,int a45,char a46)
{
  _DWORD *v46;
  int v48;

  v48 = v46[2] - 1;
  v46[2] = v48;
  if (!v48)
    (*(void (**)(_DWORD *))(*(_QWORD *)v46 + 8))(v46);
  _Unwind_Resume(exception_object);
}

RB::Resource *RB::Resource::set_source(RB::Resource *this, RB::Resource *a2)
{
  RB::Resource *result;
  int v5;

  result = (RB::Resource *)*((_QWORD *)this + 3);
  if (result != a2)
  {
    if (result)
    {
      v5 = *((_DWORD *)result + 2) - 1;
      *((_DWORD *)result + 2) = v5;
      if (!v5)
        result = (RB::Resource *)(*(uint64_t (**)(RB::Resource *))(*(_QWORD *)result + 8))(result);
    }
    if (a2)
      ++*((_DWORD *)a2 + 2);
    *((_QWORD *)this + 3) = a2;
  }
  return result;
}

_QWORD *RB::RenderFrame::invalidate_mipmaps(_QWORD *this, RB::Texture *a2)
{
  RB::Texture *v2;
  _QWORD *v3;
  uint64_t v4;

  if (*((_QWORD *)a2 + 3))
    v2 = (RB::Texture *)*((_QWORD *)a2 + 3);
  else
    v2 = a2;
  if (*((unsigned __int8 *)v2 + 76) >= 2u && (*((_BYTE *)v2 + 77) & 8) == 0)
  {
    v3 = this;
    *((_BYTE *)v2 + 77) |= 8u;
    RB::RenderFrame::texture_id((RB::RenderFrame *)this, (uint64_t)v2);
    v4 = v3[15];
    this = operator new(0x10uLL);
    *this = v4;
    this[1] = v2;
    v3[15] = this;
  }
  return this;
}

uint64_t RB::RenderFrame::will_render(void)::Encoder::dispatch(uint64_t a1)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD *v4;

  result = RB::RenderFrame::will_render(void)::Encoder::operator()(a1);
  if (a1)
  {
    v3 = *(_QWORD **)(a1 + 8);
    if (v3)
    {
      do
      {
        v4 = (_QWORD *)*v3;
        operator delete(v3);
        v3 = v4;
      }
      while (v4);
    }
    *(_QWORD *)(a1 + 8) = 0;
    JUMPOUT(0x20BD16544);
  }
  return result;
}

uint64_t RB::RenderFrame::will_render(void)::Encoder::operator()(uint64_t a1)
{
  void *blit_encoder;
  _QWORD *i;

  blit_encoder = (void *)RB::RenderFrame::make_blit_encoder(*(RB::RenderFrame **)a1);
  for (i = *(_QWORD **)(a1 + 8); i; i = (_QWORD *)*i)
    objc_msgSend(blit_encoder, "generateMipmapsForTexture:", *(_QWORD *)(i[1] + 16));
  return objc_msgSend(blit_encoder, "endEncoding");
}

uint64_t RB::RenderFrame::present(uint64_t a1, uint64_t a2, double a3)
{
  void *v3;

  v3 = *(void **)(a1 + 16);
  if (a3 == 0.0)
    return objc_msgSend(v3, "presentDrawable:", a2);
  else
    return objc_msgSend(v3, "presentDrawable:atTime:", a2);
}

id *RB::RenderFrame::signal_event(id *result, uint64_t a2, uint64_t a3)
{
  id *v5;

  if (a2)
  {
    v5 = result;
    RB::RenderFrame::end_encoding(result);
    return (id *)objc_msgSend(v5[2], "encodeSignalEvent:value:", a2, a3);
  }
  return result;
}

unint64_t RB::RenderFrame::add_function(unint64_t this, Function *a2)
{
  int v2;
  int v4;
  _QWORD *v5;
  unint64_t v6;

  v2 = *(_DWORD *)(this + 84);
  if (*((_DWORD *)a2 + 23) != v2)
  {
    v4 = *(_DWORD *)(this + 88);
    *((_DWORD *)a2 + 23) = v2;
    *((_DWORD *)a2 + 24) = v4;
    v5 = *(_QWORD **)(this + 112);
    v6 = v5[1];
    if (v6 >= v5[2])
    {
      this = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)(this + 112), v5);
      v5 = (_QWORD *)this;
    }
    v5[v6 + 3] = a2;
    atomic_store(v6 + 1, v5 + 1);
  }
  return this;
}

RB::Buffer *RB::RenderFrame::alloc_buffer_region@<X0>(RB::RenderFrame *this@<X0>, RB::Device *a2@<X1>, unint64_t a3@<X2>, char a4@<W3>, _QWORD *a5@<X8>)
{
  RB::Buffer *result;
  uint64_t v9;
  int v10;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  RB::Buffer *v19;

  result = *(RB::Buffer **)this;
  if (*((_QWORD *)result + 34) < (unint64_t)a2)
  {
    v9 = RB::Buffer::alloc((id *)result, a2);
    result = (RB::Buffer *)RB::RenderFrame::buffer_id(this, (RB::Buffer *)v9);
    *a5 = v9;
    a5[1] = 0;
    a5[2] = *(_QWORD *)(v9 + 48);
    v10 = *(_DWORD *)(v9 + 8) - 1;
    *(_DWORD *)(v9 + 8) = v10;
    if (!v10)
      return (RB::Buffer *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
    return result;
  }
  v12 = *((_QWORD *)this + 16);
  if (v12)
  {
    if (!a2)
    {
      a5[1] = 0;
      a5[2] = 0;
      *a5 = v12;
      return result;
    }
    v13 = *((_QWORD *)this + 17);
    if ((a4 & 2) == 0)
    {
      v14 = 4;
      if (!*((_BYTE *)result + 283))
        v14 = 256;
      if (v14 <= a3)
        v14 = a3;
      v13 = (v13 + v14 - 1) & -(uint64_t)v14;
    }
    v15 = *(_QWORD *)(v12 + 48) - v13;
  }
  else
  {
    v15 = 0;
    v13 = 0;
  }
  if (v15 >= (unint64_t)a2)
  {
    v17 = a4 & 1;
LABEL_26:
    if (v17)
    {
      *((_BYTE *)this + 144) = 1;
      *a5 = *((_QWORD *)this + 16);
      a5[1] = v13;
      a5[2] = v15;
    }
    else
    {
      *((_QWORD *)this + 17) = (char *)a2 + v13;
      *a5 = *((_QWORD *)this + 16);
      a5[1] = v13;
      a5[2] = a2;
    }
    return result;
  }
  RB::Device::alloc_shared_buffer(result, (uint64_t *)&v19);
  RB::RenderFrame::buffer_id(this, v19);
  if ((a4 & 1) != 0)
  {
    result = v19;
  }
  else
  {
    result = v19;
    if (*((_QWORD *)this + 16) && v15 > *((_QWORD *)v19 + 6) - (_QWORD)a2)
    {
      v16 = 0;
      *a5 = v19;
      a5[1] = 0;
      a5[2] = a2;
      goto LABEL_23;
    }
  }
  v13 = 0;
  *((_QWORD *)this + 16) = result;
  *((_QWORD *)this + 17) = 0;
  v16 = 1;
  v15 = *((_QWORD *)result + 6);
LABEL_23:
  v17 = a4 & 1;
  v18 = *((_DWORD *)result + 2) - 1;
  *((_DWORD *)result + 2) = v18;
  if (!v18)
    result = (RB::Buffer *)(*(uint64_t (**)(RB::Buffer *))(*(_QWORD *)result + 8))(result);
  if (v16)
    goto LABEL_26;
  return result;
}

void sub_209B8A6FC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _DWORD *a10)
{
  if (a10)
    RB::RenderFrame::alloc_buffer_region(a10);
  _Unwind_Resume(exception_object);
}

uint64_t RB::RenderFrame::make_blit_encoder(RB::RenderFrame *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 36);
  if (v2)
  {
    objc_msgSend(v2, "endEncoding");

    *((_QWORD *)this + 36) = 0;
  }
  return objc_msgSend(*((id *)this + 2), "blitCommandEncoder");
}

void RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke(RB::RenderQueue *this)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  uint64_t v5;

  v2 = *((_QWORD *)this + 1015);
  RB::RenderFrame::encode(v2, (uint64_t)this + 8120, this);

  os_unfair_lock_lock((os_unfair_lock_t)(v2 + 232));
  v3 = *(_DWORD *)(v2 + 280);
  v4 = v3 + 1;
  if (*(_DWORD *)(v2 + 284) < v3 + 1)
  {
    RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow((void *)(v2 + 240), v4);
    v3 = *(_DWORD *)(v2 + 280);
    v4 = v3 + 1;
  }
  v5 = *(_QWORD *)(v2 + 272);
  if (!v5)
    v5 = v2 + 240;
  *(_DWORD *)(v2 + 280) = v4;
  *(_QWORD *)(v5 + 8 * v3) = this;
  os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 232));
}

void sub_209B8A814(_Unwind_Exception *a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  uint64_t v4;

  os_unfair_lock_unlock(v2);
  RB::RenderFrame::QueueDeleter::operator()(v4, v1);
  _Unwind_Resume(a1);
}

void *RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 4), __dst, 4u, (_DWORD *)__dst + 11, v3);
  *((_QWORD *)__dst + 4) = result;
  return result;
}

void RB::RenderFrame::end_encoding(void)::$_0::__invoke(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 288);
  if (v2)
  {
    objc_msgSend(v2, "endEncoding");

    *(_QWORD *)(a1 + 288) = 0;
  }
}

unint64_t RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer(unint64_t *a1, _QWORD *a2)
{
  unint64_t v4;
  size_t v5;
  _QWORD *v6;
  const char *v7;
  unint64_t v8;
  unint64_t v9;

  v4 = a2[2] + (a2[2] >> 1);
  v5 = malloc_good_size(8 * v4 + 24);
  v6 = malloc_type_malloc(v5, 0x10E729FFuLL);
  if (!v6)
    RB::precondition_failure((RB *)"memory allocation failed", v7);
  v8 = (unint64_t)v6;
  v6[1] = 0;
  v6[2] = (v5 - 24) >> 3;
  *v6 = a2;
  v9 = a2[1];
  if (v9 >= v4)
    v9 = v4;
  v6[1] = v9;
  if (v9)
    memcpy(v6 + 3, a2 + 3, 8 * v9);
  atomic_store(v8, a1);
  return v8;
}

double RB::BinAllocator::dealloc(uint64_t a1, double a2, __n128 a3)
{
  __int16 *v4;
  unint64_t v5;
  unint64_t v6;
  __int16 *v7;
  __int16 *v8;
  int v9;
  __int16 *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  __int16 *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  double result;

  v4 = *(__int16 **)(a1 + 16);
  v5 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v5)
  {
    do
    {
      v6 = v5 >> 1;
      v7 = &v4[16 * (v5 >> 1)];
      v9 = *v7;
      v8 = v7 + 16;
      v5 += ~(v5 >> 1);
      if (SHIDWORD(a2) > v9)
        v4 = v8;
      else
        v5 = v6;
    }
    while (v5);
  }
  else
  {
    v4 += 16 * v5;
  }
  RB::BinAllocator::Shelf::dealloc((RB::BinAllocator::Shelf *)v4, SLOWORD(a2), a3.n128_i16[0]);
  if (v4[3] == v4[1])
  {
    v10 = *(__int16 **)(a1 + 16);
    v11 = (char *)v4 - (char *)v10;
    if (v4 == v10)
    {
      v10 = v4;
    }
    else if (*(v4 - 13) == *(v4 - 15))
    {
      *(v4 - 14) += v4[2];
      v12 = (unint64_t)v11 >> 5;
      v13 = v11 >> 5;
      v14 = (void *)*((_QWORD *)v4 + 2);
      if (v14)
        free(v14);
      v15 = (*(_DWORD *)(a1 + 24) - 1);
      *(_DWORD *)(a1 + 24) = v15;
      v16 = v15 - v13;
      if (v16)
        memmove(&v10[16 * v13], &v10[16 * v13 + 16], 32 * v16);
      v10 = *(__int16 **)(a1 + 16);
      v4 = &v10[16 * (v12 - 1)];
    }
    v17 = v4 + 16;
    v18 = *(unsigned int *)(a1 + 24);
    if (v4 + 16 != &v10[16 * v18] && v4[19] == v4[17])
    {
      v4[2] += v4[18];
      v19 = ((char *)v17 - (char *)v10) >> 5;
      v20 = (void *)*((_QWORD *)v17 + 2);
      if (v20)
      {
        free(v20);
        LODWORD(v18) = *(_DWORD *)(a1 + 24);
      }
      v21 = (v18 - 1);
      *(_DWORD *)(a1 + 24) = v21;
      v22 = v21 - v19;
      if (v22)
        memmove(&v10[16 * v19], &v10[16 * v19 + 16], 32 * v22);
    }
  }
  result = *(double *)a1;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)a1;
  return result;
}

_WORD *RB::BinAllocator::Shelf::dealloc(RB::BinAllocator::Shelf *this, int a2, int a3)
{
  unsigned __int16 v3;
  unsigned __int16 v4;
  _WORD *result;
  __int16 *v7;
  __int16 *v8;
  __int16 v9;
  unint64_t v10;
  __int16 *v11;
  unint64_t v12;
  unint64_t v13;
  __int16 *v14;
  __int16 *v15;
  int v16;
  __int16 v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  __int16 *v21;
  _WORD *v22;
  __int16 v23;
  int v24;
  int v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;

  v3 = a3;
  v4 = a2;
  v8 = (__int16 *)*((_QWORD *)this + 2);
  result = (_WORD *)((char *)this + 16);
  v7 = v8;
  v9 = *(result - 5) + a3;
  *(result - 5) = v9;
  *(result - 4) = v9;
  v10 = *((unsigned int *)result + 2);
  if (!(_DWORD)v10)
  {
LABEL_15:
    if (*((_DWORD *)this + 7) < (v10 + 1))
    {
      result = RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)result, (int)v10 + 1);
      v7 = (__int16 *)*((_QWORD *)this + 2);
      v10 = *((unsigned int *)this + 6);
    }
    *(_DWORD *)&v7[2 * v10] = v4 | (v3 << 16);
LABEL_27:
    ++*((_DWORD *)this + 6);
    return result;
  }
  v11 = v7;
  v12 = *((unsigned int *)result + 2);
  do
  {
    v13 = v12 >> 1;
    v14 = &v11[2 * (v12 >> 1)];
    v16 = *v14;
    v15 = v14 + 2;
    v12 += ~(v12 >> 1);
    if (v16 < a2)
      v11 = v15;
    else
      v12 = v13;
  }
  while (v12);
  if (v11 == &v7[2 * v10])
  {
    v21 = &v7[2 * (v10 - 1)];
    v24 = v21[1];
    v22 = v21 + 1;
    v23 = v24;
    if (v24 + v7[2 * (v10 - 1)] == a2)
    {
      *v22 = v23 + a3;
      return result;
    }
    goto LABEL_15;
  }
  if (a3 + a2 != *v11)
  {
    if (v11 != v7)
    {
      v25 = *(v11 - 1);
      if (v25 + *(v11 - 2) == a2)
      {
        *(v11 - 1) = v25 + a3;
        return result;
      }
    }
    v26 = ((char *)v11 - (char *)v7) >> 2;
    if (*((_DWORD *)this + 7) < (v10 + 1))
    {
      result = RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow((uint64_t)result, (int)v10 + 1);
      v7 = (__int16 *)*((_QWORD *)this + 2);
      v10 = *((unsigned int *)this + 6);
    }
    v27 = v10 > v26;
    v28 = v10 - v26;
    if (v27)
      result = memmove(&v7[2 * v26 + 2], &v7[2 * v26], 4 * v28);
    *(_DWORD *)&v7[2 * v26] = v4 | (v3 << 16);
    goto LABEL_27;
  }
  *v11 = a2;
  v17 = v11[1] + a3;
  v11[1] = v17;
  v18 = (char *)v11 - (char *)v7;
  if (v11 != v7)
  {
    v19 = *(v11 - 1);
    if (v19 + *(v11 - 2) == a2)
    {
      *(v11 - 1) = v19 + v17;
      v20 = (v10 - 1);
      *((_DWORD *)this + 6) = v20;
      if (v20 != v18 >> 2)
        return memmove(&v7[2 * (v18 >> 2)], &v7[2 * (v18 >> 2) + 2], 4 * (v20 - (v18 >> 2)));
    }
  }
  return result;
}

std::string *RB::BinAllocator::print(uint64_t a1, std::string *this)
{
  int v4;
  int v5;
  size_t v6;
  size_t v7;
  uint64_t v8;
  __int16 *v9;
  const char *v10;
  int v11;
  int v12;
  int v13;
  size_t v14;
  size_t v15;
  uint64_t v16;
  __int16 *v17;
  __int16 *v18;
  int v19;
  const char *v20;
  int v21;
  int v22;
  int v23;
  size_t v24;
  float v25;
  size_t v26;
  size_t v27;
  __int16 *v29;
  uint64_t v30;
  char __s[256];
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  std::string::append(this, "  <state>\n", 0xAuLL);
  v4 = HIDWORD(*(_QWORD *)a1);
  v5 = *(_QWORD *)a1;
  snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", 0, 0, v5, v4, "red");
  v6 = strlen(__s);
  std::string::append(this, __s, v6);
  snprintf_l(__s, 0x100uLL, 0, "    <draw stroked-rect=\"%g %g %d %d\" line-width=\"1\" color=\"black\"/>\n", 0.5, 0.5, v5 - 1, v4 - 1);
  v7 = strlen(__s);
  std::string::append(this, __s, v7);
  v30 = a1;
  v8 = *(unsigned int *)(a1 + 24);
  if ((_DWORD)v8)
  {
    v9 = *(__int16 **)(a1 + 16);
    v29 = &v9[16 * v8];
    v10 = "    <draw stroked-rect=\"%g %g %d %d\" line-width=\"1\" color=\"black\"/>\n";
    do
    {
      v11 = *v9;
      v12 = *(_QWORD *)v30;
      v13 = v9[2];
      snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", 0, v11, v12, v13, "#0080ff");
      v14 = strlen(__s);
      std::string::append(this, __s, v14);
      snprintf_l(__s, 0x100uLL, 0, v10, 0x3FE0000000000000, (float)((float)v11 + 0.5), (v12 - 1), (v13 - 1));
      v15 = strlen(__s);
      std::string::append(this, __s, v15);
      v16 = *((unsigned int *)v9 + 6);
      if ((_DWORD)v16)
      {
        v17 = (__int16 *)*((_QWORD *)v9 + 2);
        v18 = &v17[2 * v16];
        do
        {
          v19 = *v17;
          v20 = v10;
          v21 = *v9;
          v22 = v17[1];
          v23 = v9[2];
          snprintf_l(__s, 0x100uLL, 0, "    <draw rect=\"%d %d %d %d\" color=\"%s\"/>\n", v19, v21, v22, v23, "yellow");
          v24 = strlen(__s);
          std::string::append(this, __s, v24);
          v25 = (float)v21;
          v10 = v20;
          snprintf_l(__s, 0x100uLL, 0, v20, (float)((float)v19 + 0.5), (float)(v25 + 0.5), (v22 - 1), (v23 - 1));
          v26 = strlen(__s);
          std::string::append(this, __s, v26);
          v17 += 2;
        }
        while (v17 != v18);
      }
      v9 += 16;
    }
    while (v9 != v29);
  }
  std::string::append(this, "  </state>\n", 0xBuLL);
  snprintf_l(__s, 0x100uLL, 0, "  <transform translation=\"0 %d\"/>\n", *(_DWORD *)(v30 + 4) + 10);
  v27 = strlen(__s);
  return std::string::append(this, __s, v27);
}

uint64_t RB::XML::DisplayList::save(RB::XML::DisplayList *this, RB::XML::Document *a2)
{
  return RB::XML::Document::push(this, "state");
}

_QWORD *RB::XML::Element::set<RB::XML::Value::StateID>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  v7 = *(_QWORD *)(a3 + 8);
  *v6 = &unk_24C229240;
  v6[1] = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StateID,void>(v9 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

uint64_t RB::XML::DisplayList::device_scale(RB::XML::DisplayList *this, RB::XML::Document *a2, double a3)
{
  _QWORD *v5;
  _QWORD v7[2];

  RB::XML::Document::push(this, "device");
  v5 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v7[0] = &unk_24C229178;
  *(double *)&v7[1] = a3;
  RB::XML::Element::set<RB::XML::Value::Float>(v5, (uint64_t)"scale", (uint64_t)v7);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::draw_layer(RB::XML::Document *this, int a2, float a3)
{
  _QWORD *v5;
  _QWORD *v6;
  void *v8;
  double v9;

  if (a3 != 1.0)
  {
    v5 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v8 = &unk_24C229178;
    v9 = a3;
    RB::XML::Element::set<RB::XML::Value::Float>(v5, (uint64_t)"alpha", (uint64_t)&v8);
  }
  if (a2)
  {
    v6 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v8 = &unk_24C229308;
    LODWORD(v9) = a2;
    RB::XML::Element::set<RB::XML::Value::BlendMode>(v6, (uint64_t)"blend", (uint64_t)&v8);
  }
  return RB::XML::Document::pop((uint64_t)this);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::BlendMode>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229308;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::BlendMode,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

uint64_t RB::XML::DisplayList::clip_layer(uint64_t a1, int a2, float a3)
{
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  void *v10;
  double v11;

  v6 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * *(_QWORD *)(a1 + 16) - 8);
  v10 = &unk_24C229010;
  LOBYTE(v11) = 1;
  RB::XML::Element::set<RB::XML::Value::Bool>(v6, (uint64_t)"clip", (uint64_t)&v10);
  if (a3 != 1.0)
  {
    v7 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * *(_QWORD *)(a1 + 16) - 8);
    v10 = &unk_24C229178;
    v11 = a3;
    RB::XML::Element::set<RB::XML::Value::Float>(v7, (uint64_t)"alpha", (uint64_t)&v10);
  }
  if (a2)
  {
    v8 = *(_QWORD **)(*(_QWORD *)(a1 + 8) + 8 * *(_QWORD *)(a1 + 16) - 8);
    v10 = &unk_24C229268;
    LODWORD(v11) = a2;
    RB::XML::Element::set<RB::XML::Value::ClipMode>(v8, (uint64_t)"clip-mode", (uint64_t)&v10);
  }
  return RB::XML::Document::pop(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::ClipMode>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229268;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ClipMode,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

RB::XML::Document *RB::XML::DisplayList::concat_ctm(RB::XML::Document *this, _RBDrawingState *a2, float64x2_t *a3, const RB::AffineTransform *a4)
{
  int64x2_t v4;
  RB::XML::Document *v7;
  float64x2_t v8;
  float64x2_t v9;
  long double v10;
  BOOL v11;
  float64x2_t v12;
  int64x2_t v13;
  float64_t v14;
  _QWORD *v15;
  _QWORD *v16;
  float64x2_t v17;
  const char *v18;
  double v20;
  double v21;
  _QWORD *v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  void *v26;
  float64x2_t v27;
  float64_t v28;
  float64_t v29;
  float64x2_t v30;

  v4 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a3[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a3, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a3[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) == 0)
  {
    v7 = this;
    RB::XML::Document::push(this, "transform");
    RB::XML::Document::set_state(v7, a2);
    v8 = *a3;
    v9 = a3[1];
    v10 = a3->f64[1];
    if (a3->f64[0] == 1.0 && v10 == 0.0 && (v9.f64[0] == 0.0 ? (v11 = v9.f64[1] == 1.0) : (v11 = 0), v11))
    {
      v16 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
      v17 = a3[2];
      v26 = &unk_24C2290B0;
      v27 = v17;
      v18 = "translation";
    }
    else
    {
      v12 = a3[2];
      v13 = vceqzq_f64(v12);
      v14 = a3[1].f64[1];
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) == 0)
      {
LABEL_9:
        v15 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
        v26 = &unk_24C228EF8;
        v27 = v8;
        v28 = v9.f64[0];
        v29 = v14;
        v30 = v12;
        RB::XML::Element::set<RB::XML::Value::AffineMatrix>(v15, (uint64_t)"matrix", (uint64_t)&v26);
        return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v7);
      }
      if (v10 != 0.0 || v9.f64[0] != 0.0)
      {
        if (v8.f64[0] == v9.f64[1] && v10 == -v9.f64[0])
        {
          v24 = a3[1];
          v25 = *a3;
          v23 = a3[2];
          v20 = acos(a3->f64[0]);
          v21 = asin(v10);
          v12 = v23;
          v9.f64[0] = v24.f64[0];
          v8 = v25;
          if (vabdd_f64(v21, v20) < 0.0001)
          {
            v22 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
            v26 = &unk_24C229128;
            v27.f64[0] = v20;
            RB::XML::Element::set<RB::XML::Value::Angle>(v22, (uint64_t)"rotation", (uint64_t)&v26);
            return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v7);
          }
        }
        goto LABEL_9;
      }
      v16 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
      if (v8.f64[0] == v9.f64[1])
      {
        v26 = &unk_24C229178;
        v27.f64[0] = v8.f64[0];
        RB::XML::Element::set<RB::XML::Value::Float>(v16, (uint64_t)"scale", (uint64_t)&v26);
        return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v7);
      }
      v26 = &unk_24C2290B0;
      v27.f64[0] = v8.f64[0];
      v27.f64[1] = v9.f64[1];
      v18 = "scale";
    }
    RB::XML::Element::set<RB::XML::Value::Vec2>(v16, (uint64_t)v18, (uint64_t)&v26);
    return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v7);
  }
  return this;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Angle>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &unk_24C229128;
  v6[1] = *(_QWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Angle,void>(v8 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

RB::XML::Document *RB::XML::DisplayList::scale_ctm(RB::XML::Document *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, double a5)
{
  RB::XML::Document *v9;
  _QWORD *v10;
  void *v11;
  double v12;
  double v13;

  if (a4 != 1.0 || a5 != 1.0)
  {
    v9 = this;
    RB::XML::Document::push(this, "transform");
    RB::XML::Document::set_state(v9, a2);
    v10 = *(_QWORD **)(*((_QWORD *)v9 + 1) + 8 * *((_QWORD *)v9 + 2) - 8);
    if (a4 == a5)
    {
      v11 = &unk_24C229178;
      v12 = a4;
      RB::XML::Element::set<RB::XML::Value::Float>(v10, (uint64_t)"scale", (uint64_t)&v11);
    }
    else
    {
      v11 = &unk_24C2290B0;
      v12 = a4;
      v13 = a5;
      RB::XML::Element::set<RB::XML::Value::Vec2>(v10, (uint64_t)"scale", (uint64_t)&v11);
    }
    return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v9);
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::translate_ctm(RB::XML::Document *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, double a5)
{
  RB::XML::Document *v8;
  _QWORD *v9;
  _QWORD v10[3];

  v8 = this;
  if (a4 != 0.0 || a5 != 0.0)
  {
    RB::XML::Document::push(this, "transform");
    RB::XML::Document::set_state(v8, a2);
    v9 = *(_QWORD **)(*((_QWORD *)v8 + 1) + 8 * *((_QWORD *)v8 + 2) - 8);
    v10[0] = &unk_24C2290B0;
    *(double *)&v10[1] = a4;
    *(double *)&v10[2] = a5;
    RB::XML::Element::set<RB::XML::Value::Vec2>(v9, (uint64_t)"translation", (uint64_t)v10);
    return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v8);
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::rotate_ctm(RB::XML::Document *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  RB::XML::Document *v10;
  _QWORD *v11;
  _QWORD v12[8];

  if (a4 != 0.0)
  {
    v12[2] = v7;
    v12[3] = v6;
    v12[6] = v4;
    v12[7] = v5;
    v10 = this;
    RB::XML::Document::push(this, "transform");
    RB::XML::Document::set_state(v10, a2);
    v11 = *(_QWORD **)(*((_QWORD *)v10 + 1) + 8 * *((_QWORD *)v10 + 2) - 8);
    v12[0] = &unk_24C229128;
    *(double *)&v12[1] = a4;
    RB::XML::Element::set<RB::XML::Value::Angle>(v11, (uint64_t)"rotation", (uint64_t)v12);
    return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v10);
  }
  return this;
}

RB::XML::Document *RB::XML::DisplayList::set_identity(RB::XML::Document *this, _RBDrawingState *a2, uint64_t a3, unsigned int *a4)
{
  RB::XML::Document *v7;
  BOOL v8;
  _BOOL4 v10;
  uint64_t v11;
  BOOL v13;
  _QWORD *v14;
  _QWORD *v15;
  void *v16;
  __int128 v17;
  uint64_t v18;

  v7 = this;
  v18 = *MEMORY[0x24BDAC8D0];
  if (*(_DWORD *)a3 != *a4
    || (*(_QWORD *)(a3 + 4) == *(_QWORD *)(a4 + 1) ? (v8 = *(_QWORD *)(a3 + 12) == *(_QWORD *)(a4 + 3)) : (v8 = 0), !v8))
  {
    RB::XML::Document::push(this, "identity");
    RB::XML::Document::set_state(v7, a2);
    v10 = *(_QWORD *)(a3 + 4) != *(_QWORD *)(a4 + 1) || *(_QWORD *)(a3 + 12) != *(_QWORD *)(a4 + 3);
    v11 = *a4;
    if (v10 || *(_DWORD *)a3 != (_DWORD)v11)
    {
      v13 = !v10;
      v14 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
      v16 = &unk_24C228FE8;
      *(_QWORD *)&v17 = v11;
      RB::XML::Element::set<RB::XML::Value::Int>(v14, (uint64_t)"id", (uint64_t)&v16);
      if (!v13)
      {
        v15 = *(_QWORD **)(*((_QWORD *)v7 + 1) + 8 * *((_QWORD *)v7 + 2) - 8);
        v16 = &unk_24C229088;
        v17 = *(_OWORD *)(a4 + 1);
        RB::XML::Element::set<RB::XML::Value::UUID>(v15, (uint64_t)"ns", (uint64_t)&v16);
      }
    }
    return (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v7);
  }
  return this;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::UUID>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229088;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::UUID,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

uint64_t RB::XML::DisplayList::transition(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const RB::Transition *a4)
{
  const RB::Transition *v7;

  RB::XML::Document::push(this, "transition");
  RB::XML::Document::set_state(this, a2);
  return RB::XML::Document::pop((uint64_t)this);
}

RB::XML::Document *RB::XML::DisplayList::`anonymous namespace'::add_transition(RB::XML::Document *this, RB::XML::Document *a2, const RB::Transition *a3)
{
  RB::XML::Document *v3;
  RB::XML::Document *v4;
  char v5;
  _QWORD *v6;
  float64_t v7;
  char *v8;
  _QWORD *v9;
  char *v10;
  _QWORD *v11;
  unsigned int v12;
  char *v13;
  _QWORD *v14;
  unsigned int v15;
  const char *v16;
  char *v17;
  char *v18;
  char *v19;
  _QWORD *v20;
  char v21;
  unsigned int v22;
  unsigned int v23;
  float v24;
  float v25;
  _QWORD *v26;
  double v27;
  float64_t v28;
  _QWORD *v29;
  const char *v30;
  RB::XML::Document *v31;
  char *v32;
  char *v33;
  const char *v34;
  char *v35;
  char *v36;
  char *v37;
  float64_t v38;
  unsigned int v39;
  int v40;
  const char *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;
  _QWORD *v48;
  unsigned int v49;
  int v50;
  _QWORD *v51;
  _QWORD *v52;
  float64_t v53;
  float64_t v54;
  _QWORD *v55;
  float v56;
  _QWORD *v57;
  void *v58;
  float64x2_t v59;

  v3 = a2;
  v4 = this;
  v5 = *((_BYTE *)a2 + 12);
  if (v5)
  {
    v6 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v58 = &unk_24C228F70;
    LOBYTE(v59.f64[0]) = v5;
    this = (RB::XML::Document *)RB::XML::Element::set<RB::XML::Value::TransitionMethod>(v6, (uint64_t)"method", (uint64_t)&v58);
  }
  *(_QWORD *)&v7 = *((unsigned int *)v3 + 4);
  if (LODWORD(v7) != -1)
  {
    v9 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
    v58 = &unk_24C228FE8;
    v59.f64[0] = v7;
    this = (RB::XML::Document *)RB::XML::Element::set<RB::XML::Value::Int>(v9, (uint64_t)"max-changes", (uint64_t)&v58);
  }
  if (*((_BYTE *)v3 + 13))
  {
    v11 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
    v58 = &unk_24C229010;
    LOBYTE(v59.f64[0]) = 1;
    this = (RB::XML::Document *)RB::XML::Element::set<RB::XML::Value::Bool>(v11, (uint64_t)"implicit", (uint64_t)&v58);
  }
  v12 = *((unsigned __int8 *)v3 + 14);
  if (v12 != 32)
  {
    v14 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
    v58 = &unk_24C229178;
    v59.f64[0] = (float)((float)v12 * 0.0039216);
    this = (RB::XML::Document *)RB::XML::Element::set<RB::XML::Value::Float>(v14, (uint64_t)"add-remove-duration", (uint64_t)&v58);
  }
  if (*((_DWORD *)v3 + 22))
  {
    RB::XML::Document::push(v4, "animation");
    RB::Animation::xml_elements((uint64_t)v3 + 56, v4);
    this = (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v4);
  }
  if (*((_DWORD *)v3 + 12))
  {
    v15 = 0;
    v16 = "effect";
    v17 = (char *)v3 + 24;
    while (1)
    {
      v18 = (char *)*((_QWORD *)v3 + 5);
      if (!v18)
        v18 = v17;
      v19 = &v18[4 * v15];
      RB::XML::Document::push(v4, v16);
      v20 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v21 = *v19 & 0x7F;
      v58 = &unk_24C228FC0;
      LOBYTE(v59.f64[0]) = v21;
      RB::XML::Element::set<RB::XML::Value::TransitionEffectType>(v20, (uint64_t)"type", (uint64_t)&v58);
      if ((*(_WORD *)v19 & 0x80) == 0)
        break;
      *(_QWORD *)&v28 = v19[2];
      v29 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      if (LODWORD(v28) == v19[3])
      {
        v58 = v8 + 16;
        v59.f64[0] = v28;
        v30 = "animation-index";
      }
      else
      {
        v31 = v3;
        v32 = v10;
        v33 = v17;
        v34 = v16;
        v35 = v13;
        v36 = v8;
        v37 = v8 + 16;
        v58 = v37;
        v59.f64[0] = v28;
        RB::XML::Element::set<RB::XML::Value::Int>(v29, (uint64_t)"insert-animation-index", (uint64_t)&v58);
        v29 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
        if ((*(_WORD *)v19 & 0x80) != 0)
          *(_QWORD *)&v38 = v19[3];
        else
          v38 = 0.0;
        v58 = v37;
        v59.f64[0] = v38;
        v8 = v36;
        v13 = v35;
        v16 = v34;
        v17 = v33;
        v10 = v32;
        v3 = v31;
        v30 = "remove-animation-index";
      }
      RB::XML::Element::set<RB::XML::Value::Int>(v29, (uint64_t)v30, (uint64_t)&v58);
LABEL_29:
      v39 = *(unsigned __int16 *)v19;
      v40 = (v39 >> 8) & 3;
      if (v40 == 1)
      {
        v41 = "add";
      }
      else
      {
        if (v40 != 2)
          goto LABEL_34;
        v41 = "remove";
      }
      v42 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = &unk_24C228F48;
      *(_QWORD *)&v59.f64[0] = v41;
      RB::XML::Element::set<RB::XML::Value::ConstantString>(v42, (uint64_t)"events", (uint64_t)&v58);
      LOWORD(v39) = *(_WORD *)v19;
LABEL_34:
      if ((v39 & 0x400) != 0)
      {
        v43 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
        v58 = v10 + 16;
        LOBYTE(v59.f64[0]) = 1;
        RB::XML::Element::set<RB::XML::Value::Bool>(v43, (uint64_t)"not-if-all-changed", (uint64_t)&v58);
        LOWORD(v39) = *(_WORD *)v19;
        if ((*(_WORD *)v19 & 0x800) == 0)
        {
LABEL_36:
          if ((v39 & 0x1000) == 0)
            goto LABEL_37;
          goto LABEL_43;
        }
      }
      else if ((v39 & 0x800) == 0)
      {
        goto LABEL_36;
      }
      v44 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = v10 + 16;
      LOBYTE(v59.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(v44, (uint64_t)"only-if-all-changed", (uint64_t)&v58);
      LOWORD(v39) = *(_WORD *)v19;
      if ((*(_WORD *)v19 & 0x1000) == 0)
      {
LABEL_37:
        if ((v39 & 0x2000) == 0)
          goto LABEL_38;
        goto LABEL_44;
      }
LABEL_43:
      v45 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = v10 + 16;
      LOBYTE(v59.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(v45, (uint64_t)"not-if-empty", (uint64_t)&v58);
      LOWORD(v39) = *(_WORD *)v19;
      if ((*(_WORD *)v19 & 0x2000) == 0)
      {
LABEL_38:
        if ((v39 & 0x4000) == 0)
          goto LABEL_39;
        goto LABEL_45;
      }
LABEL_44:
      v46 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = v10 + 16;
      LOBYTE(v59.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(v46, (uint64_t)"only-if-empty", (uint64_t)&v58);
      LOWORD(v39) = *(_WORD *)v19;
      if ((*(_WORD *)v19 & 0x4000) == 0)
      {
LABEL_39:
        if ((v39 & 0x8000) == 0)
          goto LABEL_47;
        goto LABEL_46;
      }
LABEL_45:
      v47 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = v10 + 16;
      LOBYTE(v59.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(v47, (uint64_t)"remove-inverts", (uint64_t)&v58);
      LOWORD(v39) = *(_WORD *)v19;
      if ((*(_WORD *)v19 & 0x8000) == 0)
        goto LABEL_47;
LABEL_46:
      v48 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v58 = &unk_24C229010;
      LOBYTE(v59.f64[0]) = 1;
      RB::XML::Element::set<RB::XML::Value::Bool>(v48, (uint64_t)"inverts-by-value", (uint64_t)&v58);
      LOBYTE(v39) = *v19;
LABEL_47:
      v49 = v39 & 0x7F;
      if (v49 <= 0x12)
      {
        v50 = 1 << v49;
        if ((v50 & 0x54) != 0)
        {
          v52 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
          v53 = *((float *)v19 + 1);
          v58 = v13 + 16;
          v59.f64[0] = v53;
          RB::XML::Element::set<RB::XML::Value::Float>(v52, (uint64_t)"args", (uint64_t)&v58);
        }
        else if ((v50 & 0x18008) != 0)
        {
          v51 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
          v58 = &unk_24C2290B0;
          v59 = vcvtq_f64_f32(*(float32x2_t *)(v19 + 4));
          RB::XML::Element::set<RB::XML::Value::Vec2>(v51, (uint64_t)"args", (uint64_t)&v58);
        }
        else if ((v50 & 0x60000) != 0)
        {
          *(_QWORD *)&v54 = *((unsigned int *)v19 + 1);
          if (LODWORD(v54))
          {
            v55 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
            v58 = v8 + 16;
            v59.f64[0] = v54;
            RB::XML::Element::set<RB::XML::Value::Int>(v55, (uint64_t)"mode", (uint64_t)&v58);
          }
          v56 = *((float *)v19 + 2);
          if (v56 != 1.0)
          {
            v57 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
            v58 = &unk_24C228FE8;
            *(_QWORD *)&v59.f64[0] = (uint64_t)v56;
            RB::XML::Element::set<RB::XML::Value::Int>(v57, (uint64_t)"speed", (uint64_t)&v58);
          }
        }
      }
      this = (RB::XML::Document *)RB::XML::Document::pop((uint64_t)v4);
      v15 += RB::Transition::_effect_args[*(_WORD *)v19 & 0x7F] + 1;
      if (v15 >= *((_DWORD *)v3 + 12))
        return this;
    }
    LOBYTE(v22) = v19[3];
    v24 = (float)v22 * 0.0039216;
    if (v24 == 1.0)
      goto LABEL_29;
    LOBYTE(v23) = v19[2];
    v25 = (float)v23 * 0.0039216;
    v26 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
    if (v25 != 0.0)
    {
      v58 = &unk_24C229178;
      v59.f64[0] = v25;
      RB::XML::Element::set<RB::XML::Value::Float>(v26, (uint64_t)"begin", (uint64_t)&v58);
      v26 = *(_QWORD **)(*((_QWORD *)v4 + 1) + 8 * *((_QWORD *)v4 + 2) - 8);
      v27 = 1.0;
      if ((*(_WORD *)v19 & 0x80) != 0)
      {
LABEL_21:
        v58 = v13 + 16;
        v59.f64[0] = v27;
        RB::XML::Element::set<RB::XML::Value::Float>(v26, (uint64_t)"duration", (uint64_t)&v58);
        goto LABEL_29;
      }
      LOBYTE(v27) = v19[3];
      v24 = (float)LODWORD(v27) * 0.0039216;
    }
    v27 = v24;
    goto LABEL_21;
  }
  return this;
}

uint64_t RB::XML::DisplayList::attribute_value(RB::XML::Document *a1, _RBDrawingState *a2, int a3, void *a4)
{
  _QWORD *v8;
  float v9;
  _QWORD *v10;
  void *v12;
  double v13;

  RB::XML::Document::push(a1, "attributes");
  RB::XML::Document::set_state(a1, a2);
  if (a3 == 1)
  {
    v10 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v12 = &unk_24C228F48;
    v13 = COERCE_DOUBLE("elided");
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v10, (uint64_t)"text-run", (uint64_t)&v12);
  }
  else if (!a3)
  {
    v8 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    objc_msgSend(a4, "floatValue");
    v12 = &unk_24C229178;
    v13 = v9;
    RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"numeric-value", (uint64_t)&v12);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

_QWORD *RB::XML::DisplayList::draw_list(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, const RB::XML::Document *a4, float a5)
{
  _QWORD *result;
  int v9;
  _QWORD v10[2];
  _QWORD *v11;

  RB::XML::Document::snapshot((RB::XML::Element **)a3, (uint64_t *)&v11);
  if (a5 != 1.0)
  {
    v10[0] = &unk_24C229178;
    *(double *)&v10[1] = a5;
    RB::XML::Element::set<RB::XML::Value::Float>(v11, (uint64_t)"alpha", (uint64_t)v10);
  }
  RB::XML::Document::append(this, (uint64_t *)&v11, (uint64_t *)a2);
  result = v11;
  if (v11)
  {
    v9 = *((_DWORD *)v11 + 2) - 1;
    *((_DWORD *)v11 + 2) = v9;
    if (!v9)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

void sub_209B8C2F4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, _DWORD *a12)
{
  int v13;

  if (a12)
  {
    v13 = a12[2] - 1;
    a12[2] = v13;
    if (!v13)
      (*(void (**)(_DWORD *))(*(_QWORD *)a12 + 8))(a12);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::DisplayList::draw_interpolated(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, RBDisplayListInterpolator *a4, RB::XML::Element **a5, const RB::XML::Document *a6, float a7, float a8)
{
  _QWORD *v15;
  _QWORD *v16;
  void *v17;
  void *v18;
  uint64_t v19;
  RB::XML::Document *v20;
  const RB::Transition *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  _QWORD *result;
  int v27;
  uint64_t v28;
  _QWORD *v29;
  double v30;

  RB::XML::Document::push(this, "interpolation");
  RB::XML::Document::set_state(this, a2);
  v15 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v29 = &unk_24C229178;
  v30 = a8;
  RB::XML::Element::set<RB::XML::Value::Float>(v15, (uint64_t)"amount", (uint64_t)&v29);
  if (a7 != 1.0)
  {
    v16 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v29 = &unk_24C229178;
    v30 = a7;
    RB::XML::Element::set<RB::XML::Value::Float>(v16, (uint64_t)"alpha", (uint64_t)&v29);
  }
  v17 = (void *)-[_RBDrawingState options](a3, "options");
  if (v17)
  {
    v18 = v17;
    v19 = objc_msgSend(v17, "objectForKeyedSubscript:", RBDisplayListInterpolatorTransition);
    if (v19)
    {
      v20 = (RB::XML::Document *)-[RBDecodedFontMetadata fontUID](v19);
      RB::XML::Document::push(this, "transition");
      RB::XML::Document::pop((uint64_t)this);
    }
    v22 = objc_msgSend(v18, "objectForKeyedSubscript:", RBDisplayListInterpolatorAnimation);
    if (v22)
    {
      v23 = -[RBAnimation rb_animation](v22);
      RB::XML::Document::push(this, "animation");
      RB::Animation::xml_elements(v23, this);
      RB::XML::Document::pop((uint64_t)this);
    }
  }
  RB::XML::Document::snapshot(&a4->super.isa, (uint64_t *)&v29);
  RB::XML::Document::snapshot(a5, &v28);
  v29[2] = "from";
  *(_QWORD *)(v28 + 16) = "to";
  RB::XML::Document::append(this, (uint64_t *)&v29, (uint64_t *)a2);
  RB::XML::Document::append(this, &v28, (uint64_t *)a2);
  RB::XML::Document::pop((uint64_t)this);
  v24 = v28;
  if (v28)
  {
    v25 = *(_DWORD *)(v28 + 8) - 1;
    *(_DWORD *)(v28 + 8) = v25;
    if (!v25)
      (*(void (**)(uint64_t))(*(_QWORD *)v24 + 8))(v24);
  }
  result = v29;
  if (v29)
  {
    v27 = *((_DWORD *)v29 + 2) - 1;
    *((_DWORD *)v29 + 2) = v27;
    if (!v27)
      return (_QWORD *)(*(uint64_t (**)(_QWORD *))(*result + 8))(result);
  }
  return result;
}

void sub_209B8C538(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _DWORD *a11)
{
  int v12;

  if (a11)
  {
    v12 = a11[2] - 1;
    a11[2] = v12;
    if (!v12)
      (*(void (**)(_DWORD *))(*(_QWORD *)a11 + 8))(a11);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::XML::DisplayList::add_predicate_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const RB::DisplayList::InvertiblePredicate *a4)
{
  _QWORD *v7;
  void *v9;
  char v10;

  RB::XML::Document::push(this, "predicate-style");
  RB::XML::Document::set_state(this, a2);
  if (*((_BYTE *)a3 + 40))
  {
    v7 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v9 = &unk_24C229010;
    v10 = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(v7, (uint64_t)"inverts-result", (uint64_t)&v9);
  }
  RB::DisplayList::Predicate::xml_elements((uint64_t)a3, this);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_transform_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const RB::DisplayList::Transform *a4)
{
  RB::XML::Document::push(this, "transform-style");
  RB::XML::Document::set_state(this, a2);
  RB::DisplayList::Transform::xml_elements((uint64_t)a3, this);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_animation_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const RB::Animation *a4, const UUID *a5)
{
  __int16 v5;
  _QWORD *v10;
  const char *v11;
  _QWORD *v12;
  const char *v13;
  _QWORD *v14;
  const char *v15;
  _QWORD *v16;
  void *v18;
  __int128 v19;
  uint64_t v20;

  v5 = (__int16)a5;
  v20 = *MEMORY[0x24BDAC8D0];
  RB::XML::Document::push(this, "animation-style");
  RB::XML::Document::set_state(this, a2);
  if (a3)
    RB::Animation::xml_elements((uint64_t)a3, this);
  if (!uuid_is_null((const unsigned __int8 *)a4))
  {
    v10 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v18 = &unk_24C229088;
    v19 = *(_OWORD *)a4;
    RB::XML::Element::set<RB::XML::Value::UUID>(v10, (uint64_t)"value-id", (uint64_t)&v18);
  }
  if ((v5 & 0xF) == 2)
    v11 = "always";
  else
    v11 = 0;
  if ((v5 & 0xF) == 0)
    v11 = "never";
  if (v11)
  {
    v12 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v18 = &unk_24C228F48;
    *(_QWORD *)&v19 = v11;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v12, (uint64_t)"add", (uint64_t)&v18);
  }
  if ((v5 & 0xF0) == 0x20)
    v13 = "always";
  else
    v13 = 0;
  if ((v5 & 0xF0) == 0)
    v13 = "never";
  if (v13)
  {
    v14 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v18 = &unk_24C228F48;
    *(_QWORD *)&v19 = v13;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v14, (uint64_t)"remove", (uint64_t)&v18);
  }
  if ((v5 & 0xF00) == 0x200)
    v15 = "always";
  else
    v15 = 0;
  if ((v5 & 0xF00) == 0)
    v15 = "never";
  if (v15)
  {
    v16 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v18 = &unk_24C228F48;
    *(_QWORD *)&v19 = v15;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v16, (uint64_t)"change", (uint64_t)&v18);
  }
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_shadow_style(RB::XML::Document *a1, _RBDrawingState *a2, double *a3, __int128 *a4, int a5, int a6, char a7, double a8, float a9)
{
  _QWORD *v18;
  double v19;
  double v20;
  _QWORD *v21;
  _QWORD *v22;
  _QWORD *v23;
  _QWORD *v24;
  const char *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v29;
  _QWORD *v30;
  void (**v31)(RB::XML::Value::Color *__hidden);
  __int128 v32;
  int v33;

  RB::XML::Document::push(a1, "shadow");
  RB::XML::Document::set_state(a1, a2);
  v18 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229178;
  *(double *)&v32 = a8;
  RB::XML::Element::set<RB::XML::Value::Float>(v18, (uint64_t)"radius", (uint64_t)&v31);
  v19 = *a3;
  v20 = a3[1];
  if (*a3 != 0.0 || v20 != 0.0)
  {
    v21 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C2290B0;
    *(double *)&v32 = v19;
    *((double *)&v32 + 1) = v20;
    RB::XML::Element::set<RB::XML::Value::Vec2>(v21, (uint64_t)"offset", (uint64_t)&v31);
  }
  if (a9 != 0.5)
  {
    v22 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229178;
    *(double *)&v32 = a9;
    RB::XML::Element::set<RB::XML::Value::Float>(v22, (uint64_t)"midpoint", (uint64_t)&v31);
  }
  v23 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v31 = &off_24C229150;
  v32 = *a4;
  v33 = a5;
  RB::XML::Element::set<RB::XML::Value::Color>(v23, (uint64_t)"color", (uint64_t)&v31);
  if (a6)
  {
    v24 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229308;
    LODWORD(v32) = a6;
    RB::XML::Element::set<RB::XML::Value::BlendMode>(v24, (uint64_t)"blend", (uint64_t)&v31);
  }
  if ((a7 & 3) != 0)
  {
    v25 = "only";
    if ((a7 & 2) == 0)
      v25 = "above";
    v26 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C228F48;
    *(_QWORD *)&v32 = v25;
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v26, (uint64_t)"mode", (uint64_t)&v31);
  }
  if ((a7 & 4) == 0)
  {
    if ((a7 & 8) == 0)
      goto LABEL_14;
LABEL_18:
    v30 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229010;
    LOBYTE(v32) = 0;
    RB::XML::Element::set<RB::XML::Value::Bool>(v30, (uint64_t)"layer", (uint64_t)&v31);
    if ((a7 & 0x10) == 0)
      return RB::XML::Document::pop((uint64_t)a1);
    goto LABEL_15;
  }
  v29 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229010;
  LOBYTE(v32) = 1;
  RB::XML::Element::set<RB::XML::Value::Bool>(v29, (uint64_t)"inverse-alpha", (uint64_t)&v31);
  if ((a7 & 8) != 0)
    goto LABEL_18;
LABEL_14:
  if ((a7 & 0x10) != 0)
  {
LABEL_15:
    v27 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229010;
    LOBYTE(v32) = 0;
    RB::XML::Element::set<RB::XML::Value::Bool>(v27, (uint64_t)"dither", (uint64_t)&v31);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::XML::DisplayList::add_projection_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const float *a4)
{
  _QWORD *v7;
  void (**v9)(RB::XML::Value::FloatArray *__hidden);
  void *v10;

  RB::XML::Document::push(this, "projection");
  RB::XML::Document::set_state(this, a2);
  v7 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  RB::XML::Value::FloatArray::FloatArray<float>(&v9, (float *)a3, 9uLL);
  RB::XML::Element::set<RB::XML::Value::FloatArray>(v7, (uint64_t)"matrix", (uint64_t)&v9);
  v9 = &off_24C228E58;
  if (v10)
    free(v10);
  return RB::XML::Document::pop((uint64_t)this);
}

void sub_209B8CB58(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  if (a10)
    free(a10);
  _Unwind_Resume(exception_object);
}

uint64_t RB::XML::DisplayList::add_scale_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, CGSize a4, CGPoint a5)
{
  CGFloat y;
  CGFloat x;
  CGFloat height;
  CGFloat width;
  _QWORD *v11;
  _QWORD *v12;
  void *v14;
  CGFloat v15;
  CGFloat v16;

  y = a5.y;
  x = a5.x;
  height = a4.height;
  width = a4.width;
  RB::XML::Document::push(this, "scale-style");
  RB::XML::Document::set_state(this, a2);
  v11 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v14 = &unk_24C2290B0;
  v15 = width;
  v16 = height;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v11, (uint64_t)"scale", (uint64_t)&v14);
  v12 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v14 = &unk_24C2290B0;
  v15 = x;
  v16 = y;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v12, (uint64_t)"anchor", (uint64_t)&v14);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_translation_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, CGSize a4)
{
  CGFloat height;
  CGFloat width;
  _QWORD *v8;
  _QWORD v10[3];

  height = a4.height;
  width = a4.width;
  RB::XML::Document::push(this, "translation-style");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C2290B0;
  *(CGFloat *)&v10[1] = width;
  *(CGFloat *)&v10[2] = height;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v8, (uint64_t)"offset", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_rotation3d_style(RB::XML::Document *a1, _RBDrawingState *a2, double a3, float a4, float a5, float a6, float a7, float a8, float a9, float a10, float a11)
{
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  _QWORD *v29;
  _QWORD *v30;
  void *v33;
  double v34;
  double v35;
  double v36;

  RB::XML::Document::push(a1, "rotation-3d-style");
  RB::XML::Document::set_state(a1, a2);
  v26 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v33 = &unk_24C229178;
  v34 = a3;
  RB::XML::Element::set<RB::XML::Value::Float>(v26, (uint64_t)"angle", (uint64_t)&v33);
  v27 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v33 = &unk_24C2290D8;
  v34 = a4;
  v35 = a5;
  v36 = a6;
  RB::XML::Element::set<RB::XML::Value::Vec3>(v27, (uint64_t)"axis", (uint64_t)&v33);
  v28 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v33 = &unk_24C2290D8;
  v34 = a7;
  v35 = a8;
  v36 = a9;
  RB::XML::Element::set<RB::XML::Value::Vec3>(v28, (uint64_t)"anchor", (uint64_t)&v33);
  v29 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v33 = &unk_24C229178;
  v34 = a10;
  RB::XML::Element::set<RB::XML::Value::Float>(v29, (uint64_t)"perspective", (uint64_t)&v33);
  if ((LODWORD(a11) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    v30 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v33 = &unk_24C229178;
    v34 = a11;
    RB::XML::Element::set<RB::XML::Value::Float>(v30, (uint64_t)"flip-width", (uint64_t)&v33);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Vec3>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C2290D8;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  *(_QWORD *)(v6 + 24) = *(_QWORD *)(a3 + 24);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec3,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

uint64_t RB::XML::DisplayList::add_affine_transform_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, const RB::AffineTransform *a4)
{
  _QWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  void *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  RB::XML::Document::push(this, "affine-transform-style");
  RB::XML::Document::set_state(this, a2);
  v7 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v8 = *(_OWORD *)a3;
  v9 = *((_OWORD *)a3 + 1);
  v10 = *((_OWORD *)a3 + 2);
  v12 = &unk_24C228EF8;
  v13 = v8;
  v14 = v9;
  v15 = v10;
  RB::XML::Element::set<RB::XML::Value::AffineMatrix>(v7, (uint64_t)"transform", (uint64_t)&v12);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_path_projection_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, CGPoint a4, CGPoint a5, RBPath a6, const RB::AffineTransform *a7)
{
  char v7;
  RBPathCallbacks *callbacks;
  void *info;
  CGFloat y;
  CGFloat x;
  CGFloat v13;
  CGFloat v14;
  _QWORD *v17;
  _QWORD *v18;
  _QWORD *v19;
  float64_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  int64x2_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  void (**v29)(RB::XML::Value::Path *__hidden);
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;

  v7 = (char)a7;
  callbacks = a6.callbacks;
  info = a6.info;
  y = a5.y;
  x = a5.x;
  v13 = a4.y;
  v14 = a4.x;
  RB::XML::Document::push(this, "path-projection");
  RB::XML::Document::set_state(this, a2);
  v17 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v29 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C2290B0;
  v30.f64[0] = v14;
  v30.f64[1] = v13;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v17, (uint64_t)"start-point", (uint64_t)&v29);
  v18 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v29 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C2290B0;
  v30.f64[0] = x;
  v30.f64[1] = y;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v18, (uint64_t)"end-point", (uint64_t)&v29);
  v19 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v29 = &off_24C229060;
  *(_QWORD *)&v30.f64[0] = RBPathRetain((uint64_t)a3, (uint64_t)info);
  v30.f64[1] = v20;
  RB::XML::Element::set<RB::XML::Value::Path>(v19, (uint64_t)"path", (uint64_t)&v29);
  v29 = &off_24C229060;
  RBPathRelease(*(uint64_t *)&v30.f64[0], *(uint64_t *)&v30.f64[1]);
  v21 = *(float64x2_t *)callbacks;
  v22 = *((float64x2_t *)callbacks + 1);
  v23 = *((float64x2_t *)callbacks + 2);
  v24 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v22, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*(float64x2_t *)callbacks, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v23));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) == 0)
  {
    v25 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v29 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C228EF8;
    v30 = v21;
    v31 = v22;
    v32 = v23;
    RB::XML::Element::set<RB::XML::Value::AffineMatrix>(v25, (uint64_t)"transform", (uint64_t)&v29);
  }
  if ((v7 & 1) != 0)
  {
    v26 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v29 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229010;
    LOBYTE(v30.f64[0]) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(v26, (uint64_t)"disables-subpixel-quantization", (uint64_t)&v29);
  }
  if ((v7 & 2) == 0)
  {
    v27 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v29 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229010;
    LOBYTE(v30.f64[0]) = 0;
    RB::XML::Element::set<RB::XML::Value::Bool>(v27, (uint64_t)"atomization", (uint64_t)&v29);
  }
  return RB::XML::Document::pop((uint64_t)this);
}

void sub_209B8D1A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  RBPathRelease(a11, a12);
  _Unwind_Resume(a1);
}

uint64_t RB::XML::DisplayList::add_blur_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, CGRect a5)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGRect v14;

  height = a5.size.height;
  width = a5.size.width;
  y = a5.origin.y;
  x = a5.origin.x;
  RB::XML::Document::push(this, "blur");
  RB::XML::Document::set_state(this, a2);
  v14.origin.x = x;
  v14.origin.y = y;
  v14.size.width = width;
  v14.size.height = height;
  return RB::XML::Document::pop((uint64_t)this);
}

void RB::XML::DisplayList::`anonymous namespace'::set_blur_args(RB::XML::DisplayList::_anonymous_namespace_ *this, RB::XML::Element *a2, double a3, CGRect a4)
{
  int v4;
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  const char *v10;
  void *v11;
  double v12;
  CGFloat v13;
  CGFloat v14;
  CGFloat v15;
  CGRect v16;

  v4 = (int)a2;
  height = a4.size.height;
  width = a4.size.width;
  y = a4.origin.y;
  x = a4.origin.x;
  v11 = &unk_24C229178;
  v12 = a3;
  RB::XML::Element::set<RB::XML::Value::Float>(this, (uint64_t)"radius", (uint64_t)&v11);
  v16.origin.x = x;
  v16.origin.y = y;
  v16.size.width = width;
  v16.size.height = height;
  if (!CGRectIsInfinite(v16))
  {
    v11 = &unk_24C229100;
    v12 = x;
    v13 = y;
    v14 = width;
    v15 = height;
    RB::XML::Element::set<RB::XML::Value::Vec4>(this, (uint64_t)"bounds", (uint64_t)&v11);
  }
  if ((v4 & 1) != 0)
  {
    v11 = &unk_24C229010;
    LOBYTE(v12) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(this, (uint64_t)"opaque", (uint64_t)&v11);
  }
  if ((v4 & 8) != 0)
  {
    v11 = &unk_24C229010;
    LOBYTE(v12) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(this, (uint64_t)"dither", (uint64_t)&v11);
  }
  if ((v4 & 2) != 0)
  {
    *(double *)&v10 = COERCE_DOUBLE("linear");
  }
  else
  {
    if ((v4 & 4) == 0)
      goto LABEL_12;
    *(double *)&v10 = COERCE_DOUBLE("non-linear");
  }
  v11 = &unk_24C228F48;
  v12 = *(double *)&v10;
  RB::XML::Element::set<RB::XML::Value::ConstantString>(this, (uint64_t)"color-space", (uint64_t)&v11);
LABEL_12:
  __asm { BR              X11 }
}

_QWORD *sub_209B8D3B4()
{
  _QWORD *v0;
  uint64_t v1;
  _QWORD v3[15];

  v3[0] = v1 + 16;
  v3[1] = "medium";
  return RB::XML::Element::set<RB::XML::Value::ConstantString>(v0, (uint64_t)"blur-quality", (uint64_t)v3);
}

uint64_t RB::XML::DisplayList::add_variable_blur_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, float16x4_t *a3, double a4, RBFill *a5, CGRect a6)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  CGRect v16;

  height = a6.size.height;
  width = a6.size.width;
  y = a6.origin.y;
  x = a6.origin.x;
  RB::XML::Document::push(this, "variable-blur");
  RB::XML::Document::set_state(this, a2);
  v16.origin.x = x;
  v16.origin.y = y;
  v16.size.width = width;
  v16.size.height = height;
  -[RBFill _xmlAttributes:](a3, *(RB::XML::Element **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8));
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_variable_blur_layer(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, float a5, double a6, CGRect a7)
{
  CGFloat height;
  CGFloat width;
  CGFloat y;
  CGFloat x;
  _QWORD *v16;
  _QWORD *v17;
  void *v19;
  double v20;
  CGRect v21;

  height = a7.size.height;
  width = a7.size.width;
  y = a7.origin.y;
  x = a7.origin.x;
  *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8) + 16) = "variable-blur-layer";
  RB::XML::Document::set_state(this, a2);
  if (a4 != 0.0)
  {
    v16 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v19 = &unk_24C229178;
    v20 = a4;
    RB::XML::Element::set<RB::XML::Value::Float>(v16, (uint64_t)"scale", (uint64_t)&v19);
  }
  if (a5 != 1.0)
  {
    v17 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v19 = &unk_24C229178;
    v20 = a5;
    RB::XML::Element::set<RB::XML::Value::Float>(v17, (uint64_t)"alpha", (uint64_t)&v19);
  }
  v21.origin.x = x;
  v21.origin.y = y;
  v21.size.width = width;
  v21.size.height = height;
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_alpha_threshold_filter(RB::XML::Document *a1, _RBDrawingState *a2, int a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  _QWORD *v18;
  _QWORD *v19;
  _QWORD *v23;
  void (**v25)(RB::XML::Value::Color *__hidden);
  double v26;
  double v27;
  int v28;

  RB::XML::Document::push(a1, "alpha-threshold");
  RB::XML::Document::set_state(a1, a2);
  if (a5 >= 1.0)
  {
    if (a4 != 0.5)
    {
      v19 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
      v25 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229178;
      v26 = a4;
      RB::XML::Element::set<RB::XML::Value::Float>(v19, (uint64_t)"alpha", (uint64_t)&v25);
    }
  }
  else
  {
    v18 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v25 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C2290B0;
    v26 = a4;
    v27 = a5;
    RB::XML::Element::set<RB::XML::Value::Vec2>(v18, (uint64_t)"alpha", (uint64_t)&v25);
  }
  if (a6 != 1.0 || a7 != 1.0 || a8 != 1.0 || a9 != 1.0)
  {
    v23 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v25 = &off_24C229150;
    v26 = COERCE_DOUBLE(__PAIR64__(LODWORD(a7), LODWORD(a6)));
    v27 = COERCE_DOUBLE(__PAIR64__(LODWORD(a9), LODWORD(a8)));
    v28 = a3;
    RB::XML::Element::set<RB::XML::Value::Color>(v23, (uint64_t)"color", (uint64_t)&v25);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

void RB::XML::DisplayList::add_alpha_gradient_filter(uint64_t a1, uint64_t a2)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  _RBDrawingState *v12;
  _RBDrawingState *v13;
  RB::XML::Document *v14;
  RB::XML::Document *v15;
  __int16 v16;
  _QWORD *v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  void (**v22)(RB::XML::Value::Gradient *__hidden);
  void *v23;
  _BYTE v24[64];
  _BYTE v25[40];
  char v26[4096];
  uint64_t v27;

  MEMORY[0x24BDAC7A8](a1, a2);
  v3 = v2;
  v5 = v4;
  v7 = v6;
  v9 = v8;
  v11 = v10;
  v13 = v12;
  v15 = v14;
  v27 = *MEMORY[0x24BDAC8D0];
  RB::XML::Document::push(v14, "alpha-gradient");
  RB::XML::Document::set_state(v15, v13);
  RB::Heap::Heap((RB::Heap *)v25, v26, 4096, 0);
  v16 = rb_color_space(v7);
  RB::Fill::Gradient::Gradient((uint64_t)v24, (RB::Heap *)v25, 0, v11, v9, v16, v5, v3, 0.0, 0.0, 0.0, 0.0);
  v17 = *(_QWORD **)(*((_QWORD *)v15 + 1) + 8 * *((_QWORD *)v15 + 2) - 8);
  RB::XML::Value::Gradient::Gradient((RB::XML::Value::Gradient *)&v22, (const RB::Fill::Gradient *)v24);
  RB::XML::Element::set<RB::XML::Value::Gradient>(v17, (uint64_t)"gradient", (uint64_t)&v22);
  v22 = &off_24C229290;
  if (v23)
    free(v23);
  v18 = v3 & 7;
  switch(v18)
  {
    case 1:
      v20 = *(_QWORD **)(*((_QWORD *)v15 + 1) + 8 * *((_QWORD *)v15 + 2) - 8);
      v22 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C228F48;
      v23 = "repeat";
      RB::XML::Element::set<RB::XML::Value::ConstantString>(v20, (uint64_t)"edge-mode", (uint64_t)&v22);
      break;
    case 2:
      v21 = *(_QWORD **)(*((_QWORD *)v15 + 1) + 8 * *((_QWORD *)v15 + 2) - 8);
      v22 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C228F48;
      v23 = "mirror";
      RB::XML::Element::set<RB::XML::Value::ConstantString>(v21, (uint64_t)"edge-mode", (uint64_t)&v22);
      break;
    case 3:
      v19 = *(_QWORD **)(*((_QWORD *)v15 + 1) + 8 * *((_QWORD *)v15 + 2) - 8);
      v22 = (void (**)(RB::XML::Value::Gradient *__hidden))&unk_24C228F48;
      v23 = "unclamped";
      RB::XML::Element::set<RB::XML::Value::ConstantString>(v19, (uint64_t)"edge-mode", (uint64_t)&v22);
      break;
  }
  RB::XML::Document::pop((uint64_t)v15);
  RB::Heap::~Heap((RB::Heap *)v25);
}

void sub_209B8D960(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,char a23)
{
  RB::Heap::~Heap((RB::Heap *)&a23);
  _Unwind_Resume(a1);
}

uint64_t RB::XML::DisplayList::add_color_matrix_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, RB::XML::Document *a4)
{
  _QWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  void *v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  RB::XML::Document::push(this, "color-matrix");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v9 = *(_OWORD *)a3;
  v10 = *((_OWORD *)a3 + 2);
  v11 = *((_OWORD *)a3 + 3);
  v16 = *((_OWORD *)a3 + 1);
  v17 = v10;
  v12 = *((_OWORD *)a3 + 4);
  v18 = v11;
  v19 = v12;
  v14 = &unk_24C228ED0;
  v15 = v9;
  RB::XML::Element::set<RB::XML::Value::ColorMatrix>(v8, (uint64_t)"matrix", (uint64_t)&v14);
  return RB::XML::Document::pop((uint64_t)this);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::ColorMatrix>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228ED0;
  *(_OWORD *)(v6 + 24) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 40);
  *(_OWORD *)(v6 + 56) = *(_OWORD *)(a3 + 56);
  *(_OWORD *)(v6 + 72) = *(_OWORD *)(a3 + 72);
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorMatrix,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::DisplayList::`anonymous namespace'::add_color_filter_flags(_QWORD *this, RB::XML::Document *a2)
{
  char v2;
  _QWORD *v3;
  _QWORD *v4;
  const char *v5;
  _QWORD *v6;
  void *v7;
  const char *v8;

  v2 = (char)a2;
  v3 = this;
  if ((a2 & 1) != 0)
  {
    v4 = *(_QWORD **)(this[1] + 8 * this[2] - 8);
    v5 = "linear";
  }
  else
  {
    if ((a2 & 2) == 0)
      goto LABEL_6;
    v4 = *(_QWORD **)(this[1] + 8 * this[2] - 8);
    v5 = "non-linear";
  }
  v7 = &unk_24C228F48;
  v8 = v5;
  this = RB::XML::Element::set<RB::XML::Value::ConstantString>(v4, (uint64_t)"color-space", (uint64_t)&v7);
LABEL_6:
  if ((v2 & 4) != 0)
  {
    v6 = *(_QWORD **)(v3[1] + 8 * v3[2] - 8);
    v7 = &unk_24C229010;
    LOBYTE(v8) = 1;
    return RB::XML::Element::set<RB::XML::Value::Bool>(v6, (uint64_t)"premultiplied", (uint64_t)&v7);
  }
  return this;
}

uint64_t RB::XML::DisplayList::add_color_multiply_filter(RB::XML::Document *a1, _RBDrawingState *a2, int a3, RB::XML::Document *a4, float a5, float a6, float a7, float a8)
{
  _QWORD *v16;
  void (**v18)(RB::XML::Value::Color *__hidden);
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;

  RB::XML::Document::push(a1, "color-multiply");
  RB::XML::Document::set_state(a1, a2);
  v16 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v18 = &off_24C229150;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  v22 = a8;
  v23 = a3;
  RB::XML::Element::set<RB::XML::Value::Color>(v16, (uint64_t)"color", (uint64_t)&v18);
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::XML::DisplayList::add_alpha_multiply_filter(RB::XML::Document *a1, _RBDrawingState *a2, int a3, RB::XML::Document *a4, float a5, float a6, float a7, float a8)
{
  _QWORD *v16;
  void (**v18)(RB::XML::Value::Color *__hidden);
  float v19;
  float v20;
  float v21;
  float v22;
  int v23;

  RB::XML::Document::push(a1, "alpha-multiply");
  RB::XML::Document::set_state(a1, a2);
  v16 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v18 = &off_24C229150;
  v19 = a5;
  v20 = a6;
  v21 = a7;
  v22 = a8;
  v23 = a3;
  RB::XML::Element::set<RB::XML::Value::Color>(v16, (uint64_t)"color", (uint64_t)&v18);
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::XML::DisplayList::add_hue_rotation_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "hue-rotation");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C229128;
  *(double *)&v10[1] = a4;
  RB::XML::Element::set<RB::XML::Value::Angle>(v8, (uint64_t)"angle", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_saturation_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, float a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "saturation");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C229178;
  *(double *)&v10[1] = a4;
  RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"amount", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_brightness_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, float a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "brightness");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C229178;
  *(double *)&v10[1] = a4;
  RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"amount", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_contrast_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, float a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "contrast");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C229178;
  *(double *)&v10[1] = a4;
  RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"amount", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_luminance_to_alpha_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3)
{
  RB::XML::Document::push(this, "luminance-to-alpha");
  RB::XML::Document::set_state(this, a2);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_color_invert_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, float a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "color-invert");
  RB::XML::Document::set_state(this, a2);
  if (a4 != 1.0)
  {
    v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v10[0] = &unk_24C229178;
    *(double *)&v10[1] = a4;
    RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"amount", (uint64_t)v10);
  }
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_grayscale_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, float a4)
{
  _QWORD *v8;
  _QWORD v10[2];

  RB::XML::Document::push(this, "grayscale");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v10[0] = &unk_24C229178;
  *(double *)&v10[1] = a4;
  RB::XML::Element::set<RB::XML::Value::Float>(v8, (uint64_t)"amount", (uint64_t)v10);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_color_monochrome_filter(RB::XML::Document *a1, _RBDrawingState *a2, int a3, RB::XML::Document *a4, float a5, float a6, float a7, float a8, float a9, float a10)
{
  _QWORD *v20;
  _QWORD *v21;
  _QWORD *v22;
  void (**v24)(RB::XML::Value::Color *__hidden);
  double v25;
  float v26;
  float v27;
  int v28;

  RB::XML::Document::push(a1, "color-monochrome");
  RB::XML::Document::set_state(a1, a2);
  v20 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v24 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229178;
  v25 = a5;
  RB::XML::Element::set<RB::XML::Value::Float>(v20, (uint64_t)"amount", (uint64_t)&v24);
  v21 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v24 = &off_24C229150;
  v25 = COERCE_DOUBLE(__PAIR64__(LODWORD(a7), LODWORD(a6)));
  v26 = a8;
  v27 = a9;
  v28 = a3;
  RB::XML::Element::set<RB::XML::Value::Color>(v21, (uint64_t)"color", (uint64_t)&v24);
  v22 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v24 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229178;
  v25 = a10;
  RB::XML::Element::set<RB::XML::Value::Float>(v22, (uint64_t)"bias", (uint64_t)&v24);
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::XML::DisplayList::add_luminance_curve_filter(RB::XML::Document *a1, _RBDrawingState *a2, float32x2_t *a3, int a4, RB::XML::Document *a5, float a6, float a7, float a8, float a9)
{
  _QWORD *v18;
  float64x2_t v19;
  _QWORD *v20;
  void (**v22)(RB::XML::Value::Color *__hidden);
  float64x2_t v23;
  float64x2_t v24;

  RB::XML::Document::push(a1, "luminance-curve");
  RB::XML::Document::set_state(a1, a2);
  v18 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v22 = (void (**)(RB::XML::Value::Color *__hidden))&unk_24C229100;
  v19 = vcvtq_f64_f32(a3[1]);
  v23 = vcvtq_f64_f32(*a3);
  v24 = v19;
  RB::XML::Element::set<RB::XML::Value::Vec4>(v18, (uint64_t)"curve", (uint64_t)&v22);
  v20 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
  v22 = &off_24C229150;
  *(_QWORD *)&v23.f64[0] = __PAIR64__(LODWORD(a7), LODWORD(a6));
  *(_QWORD *)&v23.f64[1] = __PAIR64__(LODWORD(a9), LODWORD(a8));
  LODWORD(v24.f64[0]) = a4;
  RB::XML::Element::set<RB::XML::Value::Color>(v20, (uint64_t)"color", (uint64_t)&v22);
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::XML::DisplayList::add_rgba_curves_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, RB::XML::Document *a4)
{
  _QWORD *v8;
  float64x2_t v9;
  _QWORD *v10;
  float64x2_t v11;
  _QWORD *v12;
  float64x2_t v13;
  _QWORD *v14;
  float64_t v15;
  float64_t v16;
  void *v18;
  float64x2_t v19;
  float64x2_t v20;

  RB::XML::Document::push(this, "rgba-curves");
  RB::XML::Document::set_state(this, a2);
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v18 = &unk_24C229100;
  v9 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 8));
  v19 = vcvtq_f64_f32(*(float32x2_t *)a3);
  v20 = v9;
  RB::XML::Element::set<RB::XML::Value::Vec4>(v8, (uint64_t)"red-curve", (uint64_t)&v18);
  v10 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v18 = &unk_24C229100;
  v11 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 24));
  v19 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 16));
  v20 = v11;
  RB::XML::Element::set<RB::XML::Value::Vec4>(v10, (uint64_t)"green-curve", (uint64_t)&v18);
  v12 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v18 = &unk_24C229100;
  v13 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 40));
  v19 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 32));
  v20 = v13;
  RB::XML::Element::set<RB::XML::Value::Vec4>(v12, (uint64_t)"blue-curve", (uint64_t)&v18);
  v14 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v15 = *((float *)a3 + 14);
  v16 = *((float *)a3 + 3);
  v18 = &unk_24C229100;
  v19 = vcvtq_f64_f32(*(float32x2_t *)((char *)a3 + 48));
  v20.f64[0] = v15;
  v20.f64[1] = v16;
  RB::XML::Element::set<RB::XML::Value::Vec4>(v14, (uint64_t)"alpha-curve", (uint64_t)&v18);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t RB::XML::DisplayList::add_shader_filter(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, RBShader *a4, CGSize a5, const CGSize *a6, const CGRect *a7)
{
  char v7;
  double height;
  double width;
  _QWORD *v15;
  const char *v16;
  _QWORD *v17;
  double *v18;
  _QWORD *v20;
  Class isa;
  RBShaderLibrary *p;
  _QWORD *v23;
  _QWORD *v24;
  CGSize v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v29;
  _QWORD *v30;
  void (**v31)(RB::XML::Value::Shader *__hidden);
  id v32[2];
  CGSize v33;

  v7 = (char)a7;
  height = a5.height;
  width = a5.width;
  if (a4)
    *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8) + 16) = "custom-filter-layer";
  else
    RB::XML::Document::push(this, "custom-filter");
  RB::XML::Document::set_state(this, a2);
  switch(v7 & 0xF)
  {
    case 2:
      v15 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
      v16 = "warp";
      break;
    case 1:
      v15 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
      v16 = "color";
      break;
    case 0:
      v15 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
      v16 = "layer";
      break;
    default:
      goto LABEL_11;
  }
  v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C228F48;
  v32[0] = (id)v16;
  RB::XML::Element::set<RB::XML::Value::ConstantString>(v15, (uint64_t)"type", (uint64_t)&v31);
LABEL_11:
  v17 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v31 = &off_24C2291C8;
  v32[0] = a3;
  RB::XML::Element::set<RB::XML::Value::Shader>(v17, (uint64_t)"shader", (uint64_t)&v31);
  v31 = &off_24C2291C8;

  v18 = (double *)MEMORY[0x24BDBF148];
  if (width != *MEMORY[0x24BDBF148] || height != *(double *)(MEMORY[0x24BDBF148] + 8))
  {
    v20 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C2290B0;
    v32[0] = *(id *)&width;
    v32[1] = *(id *)&height;
    RB::XML::Element::set<RB::XML::Value::Vec2>(v20, (uint64_t)"border", (uint64_t)&v31);
  }
  if (a4)
  {
    isa = a4->super.isa;
    p = a4->_library._p;
    if (*(double *)&a4->super.isa != *v18 || *(double *)&p != v18[1])
    {
      v23 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
      v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C2290B0;
      v32[0] = isa;
      v32[1] = p;
      RB::XML::Element::set<RB::XML::Value::Vec2>(v23, (uint64_t)"layer-border", (uint64_t)&v31);
    }
  }
  if (a6 && !CGRectIsNull(*(CGRect *)&a6->width))
  {
    v24 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C229100;
    v25 = a6[1];
    *(CGSize *)v32 = *a6;
    v33 = v25;
    RB::XML::Element::set<RB::XML::Value::Vec4>(v24, (uint64_t)"bounds", (uint64_t)&v31);
  }
  if ((v7 & 0x20) != 0)
  {
    v26 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C228F48;
    v32[0] = "linear";
    RB::XML::Element::set<RB::XML::Value::ConstantString>(v26, (uint64_t)"color-space", (uint64_t)&v31);
  }
  if ((v7 & 0x10) == 0)
  {
    if ((v7 & 0x40) == 0)
      goto LABEL_27;
LABEL_31:
    v30 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C229010;
    LOBYTE(v32[0]) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(v30, (uint64_t)"alpha-only", (uint64_t)&v31);
    if ((v7 & 0x80) == 0)
      return RB::XML::Document::pop((uint64_t)this);
    goto LABEL_28;
  }
  v29 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C229010;
  LOBYTE(v32[0]) = 1;
  RB::XML::Element::set<RB::XML::Value::Bool>(v29, (uint64_t)"dither", (uint64_t)&v31);
  if ((v7 & 0x40) != 0)
    goto LABEL_31;
LABEL_27:
  if (v7 < 0)
  {
LABEL_28:
    v27 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v31 = (void (**)(RB::XML::Value::Shader *__hidden))&unk_24C229010;
    LOBYTE(v32[0]) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(v27, (uint64_t)"ignores-secondary-dod", (uint64_t)&v31);
  }
  return RB::XML::Document::pop((uint64_t)this);
}

void sub_209B8E814(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{

  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Shader>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &off_24C2291C8;
  v6[1] = *(id *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Shader,void>(v8 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

void sub_209B8E8D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::TransitionMethod>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228F70;
  *(_BYTE *)(v6 + 8) = *(_BYTE *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionMethod,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionMethod,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229B28;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8E9F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::TransitionMethod *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionMethod>,std::allocator<RB::XML::Value::TransitionMethod>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::TransitionMethod *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionMethod>,std::allocator<RB::XML::Value::TransitionMethod>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::TransitionEffectType>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228FC0;
  *(_BYTE *)(v6 + 8) = *(_BYTE *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionEffectType,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::TransitionEffectType,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229B98;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8EB4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::TransitionEffectType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionEffectType>,std::allocator<RB::XML::Value::TransitionEffectType>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::TransitionEffectType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::TransitionEffectType>,std::allocator<RB::XML::Value::TransitionEffectType>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StateID,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229F18;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8EC04(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::StateID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StateID>,std::allocator<RB::XML::Value::StateID>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::StateID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StateID>,std::allocator<RB::XML::Value::StateID>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::BlendMode,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229FF8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8ECBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::BlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::BlendMode>,std::allocator<RB::XML::Value::BlendMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::BlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::BlendMode>,std::allocator<RB::XML::Value::BlendMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ClipMode,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229F50;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8ED74(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ClipMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ClipMode>,std::allocator<RB::XML::Value::ClipMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ClipMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ClipMode>,std::allocator<RB::XML::Value::ClipMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Angle,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229D90;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8EE2C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Angle *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Angle>,std::allocator<RB::XML::Value::Angle>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Angle *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Angle>,std::allocator<RB::XML::Value::Angle>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::UUID,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229CB0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8EEE4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::UUID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::UUID>,std::allocator<RB::XML::Value::UUID>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::UUID *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::UUID>,std::allocator<RB::XML::Value::UUID>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec3,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229D20;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8EF9C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec3 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec3>,std::allocator<RB::XML::Value::Vec3>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec3 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec3>,std::allocator<RB::XML::Value::Vec3>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::ColorMatrix,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229A48;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8F054(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::ColorMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorMatrix>,std::allocator<RB::XML::Value::ColorMatrix>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::ColorMatrix *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::ColorMatrix>,std::allocator<RB::XML::Value::ColorMatrix>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Shader,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229E70;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B8F10C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Shader *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Shader>,std::allocator<RB::XML::Value::Shader>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Shader *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Shader>,std::allocator<RB::XML::Value::Shader>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

float RB::DisplayList::ShadowStyle::copy(RB::DisplayList::ShadowStyle *this, RB::DisplayList::Builder *a2)
{
  return _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (float *)this + 16, (int *)this + 17, (uint64_t *)this + 7, (uint64_t *)this + 9, (int *)this + 21, (int *)this + 22);
}

float _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_(RB::Heap *this, float *a2, int *a3, uint64_t *a4, uint64_t *a5, int *a6, int *a7)
{
  unint64_t v14;
  unint64_t v15;
  float result;
  int v17;
  uint64_t v18;
  uint64_t v19;
  __int16 v20;
  int v21;
  int v22;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 96 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 96;
  result = *a2;
  v17 = *a3;
  v18 = *a4;
  v19 = *a5;
  v20 = *((_WORD *)a5 + 4);
  v21 = *a6;
  v22 = *a7;
  *(_QWORD *)(v15 + 48) = 0;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_OWORD *)(v15 + 32) = 0u;
  *(_QWORD *)v15 = &off_24C2261D0;
  *(_QWORD *)(v15 + 56) = v18;
  *(float *)(v15 + 64) = result;
  *(_DWORD *)(v15 + 68) = v17;
  *(_QWORD *)(v15 + 72) = v19;
  *(_WORD *)(v15 + 80) = v20;
  *(_DWORD *)(v15 + 84) = v21;
  *(_DWORD *)(v15 + 88) = v22;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::ShadowStyle::draw(RB::DisplayList::ShadowStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Builder *result;
  __int16 v15;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v22;
  double v23;
  double v24;
  int16x4_t v25;
  RB::DisplayList::Item *v26;
  int v27;
  unsigned int v28;
  RB::DisplayList::Item *v29;
  float v30;
  float64x2_t *v31;
  RB::DisplayList::LayerFilter *v32;
  void (***v33)(_QWORD);
  unint64_t v34;
  float v35;
  float16x4_t v36;
  size_t *v37;
  unint64_t v38;
  RB::DisplayList::Item *v39;
  float32x2_t v40;
  uint32x2_t v41;
  float64x2_t v42;
  RB::DisplayList::Layer *layer;
  char v44;
  _QWORD *v45;
  _QWORD *v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  int v52;
  __int16 v53;
  int v54;
  __int128 v55;
  __int128 v56;
  float64x2_t v57;
  RB::DisplayList::Layer *v58;
  uint64_t v59;
  void (***v60)(_QWORD);
  uint64_t v61;
  _QWORD v62[15];

  v62[13] = *MEMORY[0x24BDAC8D0];
  _H0 = *((_WORD *)this + 39);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0 && RB::may_discard_alpha(*((_WORD *)a4 + 23) & 0x3F))
  {
    if ((*((_BYTE *)this + 88) & 2) != 0)
      return (RB::DisplayList::Builder *)(**(uint64_t (***)(RB::DisplayList::Item *))a4)(a4);
    *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
    *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)a4 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
    return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
  }
  v15 = *((_WORD *)a4 + 23);
  v54 = v15 & 0x3F;
  _H0 = *((_WORD *)a4 + 22);
  v53 = _H0;
  v17 = *((_QWORD *)a4 + 4);
  v18 = *((_DWORD *)a4 + 10);
  if ((*((_BYTE *)this + 88) & 0xA) == 0)
  {
    if ((v15 & 0x3F) == 2)
    {
      v20 = *((_DWORD *)this + 21);
      *((_WORD *)a4 + 23) = v15 & 0xFFC0 | 2;
      if (v20 == 2)
      {
        __asm { FCVT            S0, H0 }
        if (_S0 == 1.0)
        {
          v19 = 0;
          goto LABEL_14;
        }
      }
    }
    else
    {
      *((_WORD *)a4 + 23) = v15 & 0xFFC0 | 2;
    }
    *((_WORD *)a4 + 22) = 15360;
    *((_QWORD *)a4 + 4) = 0;
    *((_DWORD *)a4 + 10) = 0;
    v19 = 1;
    goto LABEL_14;
  }
  v19 = 0;
  *((_WORD *)a4 + 23) = v15 & 0xFFC0 | 2;
LABEL_14:
  v22 = (*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, RB::DisplayList::ShadowStyle *))(*(_QWORD *)a4 + 72))(a4, a2, this);
  if (v22)
  {
    v26 = (RB::DisplayList::Item *)v22;
    LOBYTE(v27) = 0;
  }
  else
  {
    v28 = *((_DWORD *)this + 22);
    v29 = a4;
    if ((v28 & 2) == 0)
      v29 = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, _QWORD))(*(_QWORD *)a4 + 24))(a4, a2, 0);
    v30 = *((float *)this + 16);
    if (fabsf(v30) > 0.01)
    {
      RB::Filter::GaussianBlur::GaussianBlur((uint64_t)&v58, v30, 0, 0, (*((_DWORD *)this + 22) >> 1) & 8);
      v31 = (float64x2_t *)*((_QWORD *)this + 2);
      v32 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)&v58, a2);
      v29 = RB::DisplayList::Builder::apply_filter_(a2, v29, v32, v31, 0);
      v33 = v60;
      v60 = 0;
      if (v33)
        (**v33)(v33);
    }
    *((_WORD *)v29 + 23) = *((_WORD *)v29 + 23) & 0xFFC0 | *((_WORD *)this + 42) & 0x3F;
    v34 = *((_DWORD *)this + 22) & 4;
    v35 = *((float *)this + 17);
    *(float *)&v23 = fabsf(v35 + -0.5);
    if (*(float *)&v23 >= 0.01)
    {
      *(_OWORD *)((char *)&v58 + 4 * v34) = RBColorClear;
      *((float32x4_t *)&v58 + ((v34 >> 2) ^ 1)) = vcvtq_f32_f16(*(float16x4_t *)((char *)this + 72));
      *(_QWORD *)&v55 = 0;
      if ((_DWORD)v34)
        v35 = 1.0 - v35;
      *((double *)&v55 + 1) = v35;
      *(_QWORD *)&v56 = 0x3FF0000000000000;
      v37 = (size_t *)(*((_QWORD *)a2 + 1) + 16);
      v52 = 2;
      v38 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,int,RBColor (&)[2],std::optional<RB::ColorSpace> const&,double (&)[3],unsigned int const&>(v37, (RB::Heap *)v37, &v52, (uint64_t)&v58, (__int16 *)this + 40, (uint64_t)&v55, &RB::Fill::Gradient::Flags::has_midpoints);
    }
    else
    {
      v36 = *(float16x4_t *)((char *)this + 72);
      if ((*((_DWORD *)this + 22) & 4) != 0)
        RB::ColorMatrix::set_inverse_alpha_multiply((uint64_t)&v58, 0, v36, v23, v24, v25);
      else
        RB::ColorMatrix::set_alpha_multiply((int8x8_t *)&v58, 0, (int8x8_t)v36);
      v39 = RB::DisplayList::Builder::apply_color_matrix(a2, v29, (const RB::ColorMatrix *)&v58, 0, *((float64x2_t **)this + 2), 0);
    }
    v26 = v39;
    v27 = (v28 >> 1) & 1;
  }
  v40 = *(float32x2_t *)((char *)this + 56);
  v41 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v40));
  if ((vpmax_u32(v41, v41).u32[0] & 0x80000000) != 0)
  {
    v42 = vmlaq_n_f64(vmulq_n_f64(*(float64x2_t *)*((_QWORD *)this + 2), v40.f32[0]), *(float64x2_t *)(*((_QWORD *)this + 2) + 16), v40.f32[1]);
    v55 = xmmword_209BD5290;
    v56 = xmmword_209BD52A0;
    v57 = v42;
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v58, (uint64_t)a2, &v55, 0, 0, 0);
    (*(void (**)(RB::DisplayList::Item *, RB::DisplayList::Layer **, _QWORD))(*(_QWORD *)v26 + 32))(v26, &v58, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v62);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v61);
    RB::Heap::~Heap((RB::Heap *)&v59);
  }
  *((_WORD *)v26 + 23) = *((_WORD *)v26 + 23) & 0xFFC0 | *((_WORD *)this + 42) & 0x3F;
  *((_QWORD *)v26 + 4) = v17;
  *((_DWORD *)v26 + 10) = v18;
  if (v19)
  {
    layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(a2, 0);
    v44 = 0;
  }
  else
  {
    v45 = (_QWORD *)*((_QWORD *)v26 + 3);
    *((_QWORD *)v26 + 2) = *((_QWORD *)this + 4);
    *((_QWORD *)v26 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v45, *((const RB::DisplayList::ClipNode **)this + 3));
    layer = a3;
    v44 = a5;
    if ((*((_BYTE *)this + 88) & 2) == 0)
    {
      v46 = (_QWORD *)*((_QWORD *)a4 + 3);
      *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
      *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v46, *((const RB::DisplayList::ClipNode **)this + 3));
      *((_WORD *)a4 + 23) = *((_WORD *)a4 + 23) & 0xFFC0 | v54 & 0x3F;
      *((_QWORD *)a4 + 4) = v17;
      *((_DWORD *)a4 + 10) = v18;
      layer = a3;
      v44 = a5;
    }
  }
  v58 = layer;
  if ((*((_DWORD *)this + 22) & 3) == 1)
  {
    RB::DisplayList::Builder::draw(a2, a4, layer, v44);
    result = RB::DisplayList::Builder::draw(a2, v26, layer, v44);
  }
  else if ((*((_DWORD *)this + 22) & 3) != 0)
  {
    result = RB::DisplayList::Builder::draw(a2, v26, layer, v44);
    if ((v27 & 1) == 0)
      result = (RB::DisplayList::Builder *)(**(uint64_t (***)(RB::DisplayList::Item *))a4)(a4);
  }
  else
  {
    RB::DisplayList::Builder::draw(a2, v26, layer, v44);
    result = RB::DisplayList::Builder::draw(a2, a4, v58, v44);
  }
  if (v19)
  {
    _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_((size_t *)(*((_QWORD *)a2 + 1) + 16), &v53, &v54, (uint64_t *)&v58);
    v48 = v47;
    v49 = *(_QWORD **)(v47 + 24);
    *(_QWORD *)(v47 + 16) = *((_QWORD *)this + 4);
    *(_QWORD *)(v47 + 24) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, v49, *((const RB::DisplayList::ClipNode **)this + 3));
    *(_QWORD *)(v48 + 32) = v17;
    *(_DWORD *)(v48 + 40) = v18;
    return RB::DisplayList::Builder::draw(a2, (RB::DisplayList::Item *)v48, a3, a5);
  }
  return result;
}

void sub_209B8F860(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,int,RBColor (&)[2],std::optional<RB::ColorSpace> const&,double (&)[3],unsigned int const&>(size_t *a1, RB::Heap *a2, int *a3, uint64_t a4, __int16 *a5, uint64_t a6, int *a7)
{
  unint64_t v13;

  v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  else
    a1[2] = v13 + 88;
  *(_QWORD *)v13 = &off_24C2278F8;
  RB::Fill::Gradient::Gradient(v13 + 16, a2, 3, *a3, a4, *a5, a6, *a7, 0.0, 0.0, 0.0, 0.0);
  *(_BYTE *)(v13 + 80) = 1;
  return v13;
}

RB::DisplayList::Item *RB::DisplayList::`anonymous namespace'::apply_alpha_gradient(RB::DisplayList::Builder *a1, RB::DisplayList::Item *a2, uint64_t a3)
{
  RB::DisplayList::Item *result;
  uint64_t v7;

  result = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t))(*(_QWORD *)a2 + 120))(a2, a1, a3 + 16);
  if (!result)
  {
    result = RB::DisplayList::Builder::ensure_layer(a1, a2, 0.0, 160);
    v7 = *((_QWORD *)result + 6);
    *(_BYTE *)(v7 + 64) = 2;
    *(_QWORD *)(v7 + 24) = a3;
  }
  return result;
}

void RB::DisplayList::ShadowStyle::make_primitive(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, int a5, float _S0, float a7)
{
  float v9;
  RB::Heap *v10;
  size_t *v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  int v28;
  float v29;
  uint64_t v30;
  _QWORD v31[3];
  __int128 v32;
  unint64_t v33;
  int v34;
  float v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v30 = a4;
  v29 = a7;
  v28 = a5;
  v9 = *(float *)(a1 + 68);
  if (v9 == 0.5)
  {
    v10 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
    __asm { FCVT            H0, S0 }
    LOWORD(v26) = *(_WORD *)(a1 + 72);
    *(_DWORD *)((char *)&v26 + 2) = *(_DWORD *)(a1 + 74);
    _H1 = *(_WORD *)(a1 + 78);
    __asm
    {
      FCVT            S0, H0
      FCVT            S1, H1
    }
    _S0 = _S1 * _S0;
    __asm { FCVT            H0, S0 }
    HIWORD(v26) = LOWORD(_S0);
    v27 = *(_WORD *)(a1 + 80);
    LOWORD(v32) = *(_WORD *)(*(_QWORD *)(a2 + 264) + 156);
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(v10, (uint64_t)v10, a3, (uint64_t)&v26, &v30, (int *)&v29, &v28, (__int16 *)&v32);
  }
  else
  {
    v32 = RBColorClear;
    _H2 = *(_WORD *)(a1 + 76);
    __asm { FCVT            S2, H2 }
    _H3 = *(_WORD *)(a1 + 78);
    __asm { FCVT            S3, H3 }
    v33 = vcvtq_f32_f16(*(float16x4_t *)(a1 + 72)).u64[0];
    v34 = _S2;
    v35 = _S3 * _S0;
    v31[0] = 0;
    *(double *)&v31[1] = v9;
    v31[2] = 0x3FF0000000000000;
    RB::Fill::Gradient::Gradient((uint64_t)&v26, (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), 3, 2uLL, (uint64_t)&v32, *(_WORD *)(a1 + 80), (uint64_t)v31, 256, 0.0, 0.0, 0.0, 0.0);
    v24 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
    v25 = *(_WORD *)(*(_QWORD *)(a2 + 264) + 156);
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(v24, (RB::Heap *)v24, a3, &v26, &v30, (int *)&v29, &v28, &v25);
  }
}

_QWORD *RB::DisplayList::ShadowStyle::encode(RB::DisplayList::ShadowStyle *this, RB::Encoder *a2)
{
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = *((int *)this + 16);
  if (*(float *)&v4 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 7));
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::DisplayList::ShadowStyle *)((char *)this + 72), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  v5 = rb_blend_mode(*((_DWORD *)this + 21));
  if (v5)
  {
    v6 = v5;
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, v6);
  }
  v7 = *((_DWORD *)this + 22);
  if ((v7 & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v7 = *((_DWORD *)this + 22);
    if ((v7 & 2) == 0)
    {
LABEL_7:
      if ((v7 & 4) == 0)
        goto LABEL_8;
      goto LABEL_16;
    }
  }
  else if ((v7 & 2) == 0)
  {
    goto LABEL_7;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v7 = *((_DWORD *)this + 22);
  if ((v7 & 4) == 0)
  {
LABEL_8:
    if ((v7 & 8) == 0)
      goto LABEL_9;
    goto LABEL_17;
  }
LABEL_16:
  RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v7 = *((_DWORD *)this + 22);
  if ((v7 & 8) == 0)
  {
LABEL_9:
    if ((v7 & 0x10) == 0)
      goto LABEL_11;
    goto LABEL_10;
  }
LABEL_17:
  RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
  RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*((_DWORD *)this + 22) & 0x10) != 0)
  {
LABEL_10:
    RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
LABEL_11:
  v8 = *((int *)this + 17);
  if (*(float *)&v8 != 0.5)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x55uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v8);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

_QWORD *RB::DisplayList::Style::encode(_QWORD *this, RB::Encoder *a2)
{
  _QWORD *v3;
  float64x2_t *v4;
  int64x2_t v5;
  uint64_t *v6;

  v3 = this;
  v4 = (float64x2_t *)this[2];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      RB::AffineTransform::encode(v4->f64, a2);
      this = RB::ProtobufEncoder::end_length_delimited(a2);
    }
  }
  v6 = (uint64_t *)v3[3];
  if (v6)
    this = RB::Encoder::shared_field_f(a2, 2, v6);
  if (v3[5])
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::encode_metadata(a2, (RB::Encoder *)v3[5], (const RB::DisplayList::Metadata *)*((unsigned int *)v3 + 12), 1);
    return RB::ProtobufEncoder::end_length_delimited(a2);
  }
  return this;
}

unint64_t RB::DisplayList::ShadowStyle::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  __n128 v5;
  unint64_t v6;
  unsigned int v7;
  int v8;
  int v9;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          *(float *)(a1 + 64) = RB::ProtobufDecoder::float_field(this, v6);
          break;
        case 2u:
          *(_QWORD *)(a1 + 56) = RB::ProtobufDecoder::float2_field(this, v6, v5).n128_u64[0];
          break;
        case 3u:
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(this);
            RB::Fill::Color::decode(a1 + 72, this);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *(_QWORD *)this = *((_QWORD *)this + 1);
          }
          break;
        case 4u:
          v7 = RB::ProtobufDecoder::uint_field(this, v6);
          *(_DWORD *)(a1 + 84) = rb_blend_mode(v7);
          break;
        case 5u:
          *(_DWORD *)(a1 + 88) &= ~1u;
          v8 = *(_DWORD *)(a1 + 88) | RB::ProtobufDecoder::BOOL_field(this, v6);
          goto LABEL_24;
        case 6u:
          *(_DWORD *)(a1 + 88) &= ~2u;
          if (RB::ProtobufDecoder::BOOL_field(this, v6))
            v9 = 2;
          else
            v9 = 0;
          goto LABEL_23;
        case 7u:
          *(_DWORD *)(a1 + 88) &= ~4u;
          if (RB::ProtobufDecoder::BOOL_field(this, v6))
            v9 = 4;
          else
            v9 = 0;
          goto LABEL_23;
        case 8u:
          *(_DWORD *)(a1 + 88) &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field(this, v6))
            v9 = 8;
          else
            v9 = 0;
          goto LABEL_23;
        case 9u:
          *(_DWORD *)(a1 + 88) &= ~0x10u;
          if (RB::ProtobufDecoder::BOOL_field(this, v6))
            v9 = 16;
          else
            v9 = 0;
LABEL_23:
          v8 = *(_DWORD *)(a1 + 88) | v9;
LABEL_24:
          *(_DWORD *)(a1 + 88) = v8;
          break;
        case 0xAu:
          *(float *)(a1 + 68) = RB::ProtobufDecoder::float_field(this, v6);
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v6);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::ShadowStyle::map_dod(float64x2_t **this, float32x2_t *a2, float64x2_t *a3)
{
  RB::DisplayList::ShadowStyle::bounds(this, a2, a3, 0);
}

uint64_t RB::DisplayList::ShadowStyle::matches(RB::DisplayList::ShadowStyle *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::DisplayList::ShadowStyle *)((char *)this + 72), a3) | 0x100;
}

uint64_t RB::DisplayList::ShadowStyle::apply_predicate(uint64_t this, const InvertiblePredicate *a2, int a3)
{
  if (a3)
    *(_DWORD *)(this + 88) |= 2u;
  return this;
}

uint64_t RB::DisplayList::ShadowStyle::can_mix(float32x2_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  uint64_t result;
  uint32x2_t v6;

  if (a3)
  {
    if (this[10].i32[1] == a3[10].i32[1] && this[11].i32[0] == a3[11].i32[0])
    {
      result = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[9], (const RB::Fill::Color *)&a3[9]);
      v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(this[7], a3[7]));
      if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0 || this[8].f32[0] != a3[8].f32[0])
        return result != 0;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    _H0 = this[9].i16[3];
    __asm { FCVT            S0, H0 }
    if (_S0 == 0.0)
      return 4;
    else
      return 1;
  }
  return result;
}

float16x4_t *RB::DisplayList::ShadowStyle::mix(RB::DisplayList::ShadowStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  float16x4_t *v6;
  int8x16_t v7;
  int8x16_t v8;
  double v9;
  int8x16_t v10;
  float16x4_t *v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  double v15;

  _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (float *)this + 16, (int *)this + 17, (uint64_t *)this + 7, (uint64_t *)this + 9, (int *)this + 21, (int *)this + 22);
  v11 = v6;
  if (a3)
  {
    v12 = (float32x2_t)v6[7];
    v13 = (float32x2_t)v6[8];
    *(float32x2_t *)v7.i8 = vsub_f32(*(float32x2_t *)((char *)a3 + 56), v12);
    v14 = COERCE_DOUBLE(vmla_n_f32(v12, *(float32x2_t *)v7.i8, COERCE_FLOAT(*((_QWORD *)a2 + 2))));
    *(double *)&v6[7] = v14;
    v7.i32[0] = *((_DWORD *)a2 + 4);
    *(float32x2_t *)v8.i8 = vsub_f32(*(float32x2_t *)((char *)a3 + 64), v13);
    v15 = COERCE_DOUBLE(vmla_n_f32(v13, *(float32x2_t *)v8.i8, *(float *)v7.i32));
    *(double *)&v6[8] = v15;
    RB::Fill::Color::mix(v6 + 9, (float16x4_t *)a3 + 9, 0, v7, v8, v14, v15, v9, v10);
  }
  else
  {
    _H0 = v6[9].i16[3];
    _S1 = *((_DWORD *)a2 + 4);
    __asm
    {
      FCVT            H1, S1
      FCVT            S0, H0
      FCVT            S1, H1
    }
    _S0 = _S0 - (float)(_S1 * _S0);
    __asm { FCVT            H0, S0 }
    v6[9].i16[3] = LOWORD(_S0);
  }
  return v11;
}

void RB::DisplayList::ShadowStyle::print(float32x2_t *this, std::string *a2)
{
  float v4;
  float32x2_t v5;
  uint32x2_t v6;
  unsigned int v7;
  const char *v8;
  __int32 v9;

  RB::SexpString::push(a2, "shadow");
  RB::SexpString::printf(a2, 1, "(radius %g)", this[8].f32[0]);
  v4 = this[8].f32[1];
  if (v4 != 0.5)
    RB::SexpString::printf(a2, 1, "(midpoint %g)", v4);
  v5 = this[7];
  v6 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v5));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) != 0)
    RB::SexpString::printf(a2, 1, "(offset %g %g)", v5.f32[0], v5.f32[1]);
  RB::Fill::Color::print((RB::Fill::Color *)&this[9], a2);
  v7 = this[10].u32[1];
  if (v7 != 2)
  {
    v8 = RB::blend_name(v7);
    RB::SexpString::printf(a2, 1, "(blend %s)", v8);
  }
  if (this[11].i32[0])
  {
    RB::SexpString::push(a2, "flags");
    v9 = this[11].i32[0];
    if ((v9 & 1) != 0)
    {
      RB::SexpString::print(a2, 0, "above");
      v9 = this[11].i32[0];
      if ((v9 & 2) == 0)
      {
LABEL_10:
        if ((v9 & 4) == 0)
          goto LABEL_11;
        goto LABEL_18;
      }
    }
    else if ((v9 & 2) == 0)
    {
      goto LABEL_10;
    }
    RB::SexpString::print(a2, 0, "only");
    v9 = this[11].i32[0];
    if ((v9 & 4) == 0)
    {
LABEL_11:
      if ((v9 & 8) == 0)
        goto LABEL_12;
      goto LABEL_19;
    }
LABEL_18:
    RB::SexpString::print(a2, 0, "inverse");
    v9 = this[11].i32[0];
    if ((v9 & 8) == 0)
    {
LABEL_12:
      if ((v9 & 0x10) == 0)
      {
LABEL_14:
        RB::SexpString::pop(a2);
        goto LABEL_15;
      }
LABEL_13:
      RB::SexpString::print(a2, 0, "dither");
      goto LABEL_14;
    }
LABEL_19:
    RB::SexpString::print(a2, 0, "no-layer");
    if ((this[11].i32[0] & 0x10) == 0)
      goto LABEL_14;
    goto LABEL_13;
  }
LABEL_15:
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

void RB::DisplayList::Style::print(const RB::AffineTransform **this, std::string *a2)
{
  const RB::AffineTransform *i;

  RB::SexpString::print_ctm(a2, this[2]);
  for (i = this[3]; i; i = *(const RB::AffineTransform **)i)
    (*(void (**)(unint64_t, std::string *))(*(_QWORD *)(*((_QWORD *)i + 1) & 0xFFFFFFFFFFFFFFFELL)
                                                            + 128))(*((_QWORD *)i + 1) & 0xFFFFFFFFFFFFFFFELL, a2);
  if (*((_DWORD *)this + 12))
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 12));
  if ((*((_BYTE *)this + 52) & 1) != 0)
    RB::SexpString::print(a2, 0, "disable-mix");
}

double RB::DisplayList::State::add_shadow(__n128 *a1, RB::DisplayList::Builder *a2, uint64_t *a3, int a4, int a5, float a6, float a7, double a8)
{
  RB::DisplayList::Style *v10;
  double result;
  int v12;
  int v13;
  double v14;
  float v15;
  float v16;

  v16 = a6;
  v15 = a7;
  v14 = a8;
  v12 = a5;
  v13 = a4;
  _ZN2RB4Heap7emplaceINS_11DisplayList11ShadowStyleEJRKfS5_RKDv2_fRKNS_4Fill5ColorERKNS_9BlendModeERKjEEEPT_DpOT0_((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), &v16, (int *)&v15, (uint64_t *)&v14, a3, &v13, &v12);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, a2, v10).n128_u64[0];
  return result;
}

_QWORD *RB::DisplayList::ProjectionStyle::encode(RB::DisplayList::ProjectionStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProjectionMatrix::encode((_QWORD *)this + 7, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

double RB::DisplayList::State::add_projection_matrix(__n128 *this, RB::DisplayList::Builder *a2, const RB::ProjectionMatrix *a3)
{
  RB::DisplayList::Style *v5;
  double result;

  RB::Heap::emplace<RB::DisplayList::ProjectionStyle,RB::ProjectionMatrix const&>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)a3);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(this, a2, v5).n128_u64[0];
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::ProjectionStyle,RB::ProjectionMatrix const&>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 96;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224150;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(v5 + 88) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  *(_QWORD *)v5 = &off_24C227F10;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::Builder::affine_style_draw(RB::DisplayList::Builder *this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3, char a4, float64x2_t *a5, const RB::AffineTransform *a6, const RB::DisplayList::ClipNode *a7)
{
  __int128 v14;
  float64x2_t *v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  __int128 v19;
  __int128 v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  int64x2_t v24;
  uint64_t v25;
  float64x2_t v27[3];
  __int128 v28[3];
  float64x2_t v29;
  __int128 v30;
  __int128 v31;
  uint64_t v32;
  _QWORD v33[15];

  v33[14] = *MEMORY[0x24BDAC8D0];
  v14 = *((_OWORD *)a6 + 1);
  v29 = *(float64x2_t *)a6;
  v30 = v14;
  v31 = *((_OWORD *)a6 + 2);
  if (RB::AffineTransform::invert((RB::AffineTransform *)&v29))
    v15 = &v29;
  else
    v15 = (float64x2_t *)a6;
  v16 = v15[1];
  v17 = v15[2];
  v27[0] = *v15;
  v27[1] = v16;
  v27[2] = v17;
  v18.f64[0] = RB::operator*(v27, a5);
  v29 = v18;
  v30 = v19;
  v31 = v20;
  v21.f64[0] = RB::operator*(&v29, (float64x2_t *)a6);
  v28[0] = (__int128)v21;
  v28[1] = (__int128)v22;
  v28[2] = (__int128)v23;
  v24 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v22, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v21, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v23));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) == 0)
  {
    v25 = *((_QWORD *)a3 + 2);
    *((_QWORD *)a3 + 2) = 0;
    RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v29, (uint64_t)this, v28, 0, 0, 0);
    (*(void (**)(RB::DisplayList::Item *, float64x2_t *, _QWORD))(*(_QWORD *)a3 + 32))(a3, &v29, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v33);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v32);
    RB::Heap::~Heap((RB::Heap *)&v29.f64[1]);
    *((_QWORD *)a3 + 2) = v25;
  }
  *((_QWORD *)a3 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((_QWORD **)a3 + 3), a7);
  return RB::DisplayList::Builder::draw(this, a3, a2, a4);
}

void sub_209B90730(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

void RB::DisplayList::affine_style_dod(RB::DisplayList *this, float64x2_t *a2, float64x2_t *a3, const RB::AffineTransform *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5;
  __int128 v9;
  float64x2_t *v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  __int128 v17;
  __int128 v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22[3];
  float64x2_t v23[3];
  float64x2_t v24;
  __int128 v25;
  __int128 v26;

  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*((_QWORD *)this + 1) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    v9 = *((_OWORD *)a4 + 1);
    v24 = *(float64x2_t *)a4;
    v25 = v9;
    v26 = *((_OWORD *)a4 + 2);
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v24))
      v10 = &v24;
    else
      v10 = (float64x2_t *)a4;
    v11 = v10[1];
    v12 = v10[2];
    v22[0] = *v10;
    v22[1] = v11;
    v22[2] = v12;
    v13.f64[0] = RB::operator*(v22, a3);
    v23[0] = v13;
    v23[1] = v14;
    v23[2] = v15;
    v16.f64[0] = RB::operator*(v23, (float64x2_t *)a4);
    v24 = v16;
    v25 = v17;
    v26 = v18;
    v19.f64[0] = RB::operator*(a2, &v24);
    *a2 = v19;
    a2[1] = v20;
    a2[2] = v21;
  }
}

RB::DisplayList::Builder *RB::DisplayList::Builder::projection_style_draw(size_t **this, RB::DisplayList::Layer *a2, RB::DisplayList::Item *a3, char a4, const RB::ProjectionMatrix *a5, float64x2_t *a6, const RB::DisplayList::ClipNode *a7)
{
  BOOL v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v18;
  float32x4_t *v19;
  float32x4_t v20;
  float32x4_t v21;
  RB::DisplayList::Item *v22;
  int8x16_t v23;
  int32x4_t v24;
  int32x4_t v25;
  uint64_t v26;
  size_t *v27;
  unint64_t v28;
  float32x4_t v29;
  float64x2_t v30;
  float v31[9];
  float32x4_t v32;
  float64x2_t v33;
  int v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;

  if (RB::may_discard_alpha(*((_WORD *)a3 + 23) & 0x3F)
    && *((float *)a5 + 2) == 0.0
    && (*((float *)a5 + 5) == 0.0 ? (v14 = *((float *)a5 + 8) == 1.0) : (v14 = 0), v14))
  {
    v15 = vcvtq_f64_f32(*(float32x2_t *)((char *)a5 + 12));
    v16 = vcvtq_f64_f32(*(float32x2_t *)((char *)a5 + 24));
    v35 = vcvtq_f64_f32(*(float32x2_t *)a5);
    v36 = v15;
    v37 = v16;
    return RB::DisplayList::Builder::affine_style_draw((RB::DisplayList::Builder *)this, a2, a3, a4, &v35, (const RB::AffineTransform *)a6, a7);
  }
  else
  {
    v18 = a6[1];
    v35 = *a6;
    v36 = v18;
    v37 = a6[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v35))
      v19 = (float32x4_t *)&v35;
    else
      v19 = (float32x4_t *)a6;
    v20 = v19[1];
    v21 = v19[2];
    v35 = *(float64x2_t *)v19;
    v36 = (float64x2_t)v20;
    v37 = (float64x2_t)v21;
    RB::operator*(&v35, (uint64_t)a5, (uint64_t)v31);
    RB::operator*(v31, a6, (uint64_t)&v32);
    v22 = RB::DisplayList::Builder::ensure_layer((RB::DisplayList::Builder *)this, a3, 0.0, 10);
    v26 = *((_QWORD *)v22 + 6);
    if (*(_BYTE *)(v26 + 64) == 1)
    {
      RB::operator*(*(_QWORD *)(v26 + 24), (uint64_t)&v32, (float32x4_t *)&v35, v23, v24, v25);
      v32 = (float32x4_t)v35;
      v33 = v36;
      v34 = LODWORD(v37.f64[0]);
    }
    *(_BYTE *)(v26 + 64) = 1;
    v27 = this[1];
    v28 = (v27[4] + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (v28 + 36 > v27[5])
      v28 = RB::Heap::alloc_slow(v27 + 2, 0x24uLL, 3);
    else
      v27[4] = v28 + 36;
    v29 = v32;
    v30 = v33;
    *(_DWORD *)(v28 + 32) = v34;
    *(float32x4_t *)v28 = v29;
    *(float64x2_t *)(v28 + 16) = v30;
    *(_QWORD *)(v26 + 24) = v28;
    *((_QWORD *)v22 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)this, *((_QWORD **)v22 + 3), a7);
    return RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)this, v22, a2, a4);
  }
}

float32x2_t RB::DisplayList::projection_style_roi(float32x2_t *this, float64x2_t *a2, RB::AffineTransform *a3, float64x2_t *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5;
  float32x2_t result;
  const RB::ProjectionMatrix *v9;

  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&this[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  result = (float32x2_t)vpmax_u32(v5, v5);
  if ((result.i32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(this, a2, a4);
    if (!RB::unapply(this, a3, v9))
    {
      result = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      *this = (float32x2_t)0x100000001000000;
      this[1] = result;
    }
  }
  return result;
}

void RB::DisplayList::projection_style_dod(float32x2_t *this, float64x2_t *a2, RB::AffineTransform *a3, float64x2_t *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5;
  float32x2_t v8;

  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&this[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(this, a2, a4);
    *this = RB::operator*((uint64_t)a3, *(double *)this, this[1]);
    this[1] = v8;
  }
}

double RB::DisplayList::State::add_path_projection(uint64_t a1, RB::DisplayList::Builder *a2, uint64_t a3, uint64_t a4, float64x2_t *a5, int a6, __n128 a7, __n128 a8)
{
  RB::DisplayList::Style *v11;
  int64x2_t v12;
  double result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  int v17;
  __n128 v18;
  __n128 v19;
  uint64_t v20[2];

  v20[0] = a3;
  v20[1] = a4;
  v19 = a7;
  v18 = a8;
  v17 = a6;
  v11 = (RB::DisplayList::Style *)_ZN2RB4Heap7emplaceINS_11DisplayList19PathProjectionStyleEJRDv2_dS5_R6RBPathRjEEEPT_DpOT0_((size_t *)(*((_QWORD *)a2 + 1) + 16), (__int128 *)&v19, (__int128 *)&v18, v20, &v17);
  v12 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a5[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a5, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a5[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) != 0)
  {
    *(_QWORD *)&result = RB::DisplayList::State::add_style((__n128 *)a1, a2, v11).n128_u64[0];
  }
  else
  {
    v14 = *(_OWORD *)(a1 + 16);
    v15 = *(_OWORD *)(a1 + 32);
    v16 = *(_OWORD *)(a1 + 48);
    RB::DisplayList::State::concat((float64x2_t *)a1, a5);
    RB::DisplayList::State::add_style((__n128 *)a1, a2, v11);
    *(_OWORD *)(a1 + 16) = v14;
    *(_OWORD *)(a1 + 32) = v15;
    result = *(double *)&v16;
    *(_OWORD *)(a1 + 48) = v16;
    *(_QWORD *)(a1 + 112) = 0;
    *(_DWORD *)(a1 + 148) = -1;
  }
  return result;
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList19PathProjectionStyleEJRDv2_dS5_R6RBPathRjEEEPT_DpOT0_(size_t *a1, __int128 *a2, __int128 *a3, uint64_t *a4, int *a5)
{
  unint64_t v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;

  v9 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v9 + 128 > a1[3])
    v9 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  else
    a1[2] = v9 + 128;
  v10 = *a2;
  v11 = *a3;
  v12 = *a4;
  v13 = a4[1];
  v14 = *a5;
  *(_QWORD *)(v9 + 48) = 0;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_QWORD *)v9 = &off_24C228790;
  *(_OWORD *)(v9 + 64) = v10;
  *(_OWORD *)(v9 + 80) = v11;
  *(_QWORD *)(v9 + 96) = RBPathRetain(v12, v13);
  *(_QWORD *)(v9 + 104) = v15;
  *(_DWORD *)(v9 + 112) = v14;
  return v9;
}

unint64_t RB::DisplayList::PathProjectionStyle::copy(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::PathProjectionStyle,RB::DisplayList::PathProjectionStyle const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), (uint64_t)this);
}

unint64_t RB::Heap::emplace<RB::DisplayList::PathProjectionStyle,RB::DisplayList::PathProjectionStyle const&>(size_t *a1, uint64_t a2)
{
  unint64_t v3;
  uint64_t v4;

  v3 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  else
    a1[2] = v3 + 128;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228790;
  *(_OWORD *)(v3 + 64) = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v3 + 80) = *(_OWORD *)(a2 + 80);
  *(_QWORD *)(v3 + 96) = RBPathRetain(*(_QWORD *)(a2 + 96), *(_QWORD *)(a2 + 104));
  *(_QWORD *)(v3 + 104) = v4;
  *(_DWORD *)(v3 + 112) = *(_DWORD *)(a2 + 112);
  return v3;
}

void RB::DisplayList::PathProjectionStyle::draw(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t v10;
  float64x2_t v11;
  RB::DisplayList::Item *v12;
  RB::DisplayList::Item *v13;
  _QWORD v14[3];
  uint64_t (*v15[2])(RB::Path::Mapper *__hidden);
  float64x2_t v16;
  float64x2_t v17;
  __int128 v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)this + 112) & 1) != 0)
    (*(void (**)(RB::DisplayList::Item *, _QWORD))(*(_QWORD *)a4 + 128))(a4, *((_QWORD *)this + 2));
  v10 = *((float64x2_t *)this + 4);
  v11 = *((float64x2_t *)this + 5);
  v15[0] = (uint64_t (*)(RB::Path::Mapper *__hidden))&unk_24C229388;
  v16 = v10;
  v17 = vsubq_f64(v11, v10);
  v18 = 0u;
  v19 = 16;
  v20 = 0u;
  v21 = 0u;
  v22 = 0;
  RBPathMap(*((CGPathRef *)this + 12), *((void **)this + 13), v15, 0);
  *((_QWORD *)a4 + 1) = 0;
  v12 = (RB::DisplayList::Item *)(*(uint64_t (**)(RB::DisplayList::Item *, RB::DisplayList::Builder *, uint64_t (**)(RB::Path::Mapper *__hidden), _QWORD, _QWORD))(*(_QWORD *)a4 + 232))(a4, a2, v15, *((_QWORD *)this + 2), *((unsigned int *)this + 28));
  v14[0] = *((_QWORD *)this + 3);
  v14[1] = 0;
  v14[2] = v14[0];
  while (v12)
  {
    v13 = (RB::DisplayList::Item *)*((_QWORD *)v12 + 1);
    *((_QWORD *)v12 + 2) = *((_QWORD *)this + 4);
    RB::DisplayList::Builder::MemoizedAddClip::operator()((uint64_t)v14, (uint64_t)a2, (uint64_t)v12);
    RB::DisplayList::Builder::draw(a2, v12, a3, a5);
    v12 = v13;
  }
  if ((_QWORD)v18)
    free((void *)v18);
}

void sub_209B90E4C(_Unwind_Exception *a1)
{
  if (STACK[0x7D0])
    free((void *)STACK[0x7D0]);
  _Unwind_Resume(a1);
}

int32x2_t RB::DisplayList::PathProjectionStyle::map_roi(RB::DisplayList::PathProjectionStyle *this, int32x2_t *a2, RB::AffineTransform *a3)
{
  int32x2_t result;

  result = vdup_n_s32(0x7F7FFFFFu);
  *a2 = (int32x2_t)0x100000001000000;
  a2[1] = result;
  return result;
}

int32x2_t RB::DisplayList::PathProjectionStyle::map_dod(RB::DisplayList::PathProjectionStyle *this, int32x2_t *a2, RB::AffineTransform *a3)
{
  int32x2_t result;

  result = vdup_n_s32(0x7F7FFFFFu);
  *a2 = (int32x2_t)0x100000001000000;
  a2[1] = result;
  return result;
}

uint64_t RB::DisplayList::PathProjectionStyle::can_mix(RB::DisplayList::PathProjectionStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  uint64_t result;
  int64x2_t v6;
  RBPath v7;
  RBPath v8;

  if (!a3)
    return 0;
  if (((*((_DWORD *)a3 + 28) ^ *((_DWORD *)this + 28)) & 2) != 0)
    return 0;
  v7.info = (void *)*((_QWORD *)this + 12);
  v7.callbacks = (RBPathCallbacks *)*((_QWORD *)this + 13);
  v8.info = (void *)*((_QWORD *)a3 + 12);
  v8.callbacks = (RBPathCallbacks *)*((_QWORD *)a3 + 13);
  LODWORD(result) = RBPathCanMix(v7, v8);
  v6 = (int64x2_t)vornq_s8(vmvnq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 5), *((float64x2_t *)a3 + 5))), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 4), *((float64x2_t *)a3 + 4)));
  if (vorrq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).i64[0] >= 0)
    return result;
  else
    return result != 0;
}

float64x2_t *RB::DisplayList::PathProjectionStyle::mix(float64x2_t *this, const RB::DisplayList::Interpolator::State *a2, float64x2_t *a3, const RB::DisplayList::CachedTransform *a4)
{
  float64x2_t *v7;
  float64x2_t *v8;
  float64_t v9;
  RBPathCallbacks *v10;
  float64_t v11;
  RBPathCallbacks *v12;
  float v13;
  CGAffineTransform *v14;
  float64x2_t *v15;
  const RB::AffineTransform *v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  uint64_t v20;
  uint64_t v21;
  float64x2_t v23[3];
  float64x2_t v24;
  RBPath v25;
  RBPath v26;

  if (!a3)
    return 0;
  RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16));
  v8 = v7;
  v7[4] = vmlaq_n_f64(this[4], vsubq_f64(a3[4], this[4]), *((float *)a2 + 4));
  v7[5] = vmlaq_n_f64(this[5], vsubq_f64(a3[5], this[5]), *((float *)a2 + 4));
  v9 = this[6].f64[0];
  v10 = *(RBPathCallbacks **)&this[6].f64[1];
  v11 = a3[6].f64[0];
  v12 = *(RBPathCallbacks **)&a3[6].f64[1];
  v13 = *((float *)a2 + 4);
  v14 = *(CGAffineTransform **)&this[1].f64[0];
  v15 = *(float64x2_t **)&a3[1].f64[0];
  RB::mix(v14, v15, v16, v13);
  v23[0] = v17;
  v23[1] = v18;
  v23[2] = v19;
  *(float64_t *)&v25.info = v9;
  v25.callbacks = v10;
  *(float64_t *)&v26.info = v11;
  v26.callbacks = v12;
  RBPathMix(v25, v26, v13, (float64x2_t *)v14, v15, v23, (uint64_t *)&v24);
  v20 = *(_QWORD *)&v8[6].f64[0];
  v21 = *(_QWORD *)&v8[6].f64[1];
  v8[6] = v24;
  *(_QWORD *)&v24.f64[0] = v20;
  *(_QWORD *)&v24.f64[1] = v21;
  RBPathRelease(v20, v21);
  LODWORD(v8[7].f64[0]) = LODWORD(a3[7].f64[0]);
  return v8;
}

double RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  else
    *((_QWORD *)this + 2) = v3 + 128;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228790;
  *(_OWORD *)(v3 + 64) = 0u;
  *(_OWORD *)(v3 + 80) = 0u;
  result = *(double *)&RBPathEmpty;
  *(_OWORD *)(v3 + 96) = RBPathEmpty;
  *(_DWORD *)(v3 + 112) = 0;
  return result;
}

_QWORD *RB::DisplayList::PathProjectionStyle::encode(RB::DisplayList::PathProjectionStyle *this, RB::Encoder *a2)
{
  int v4;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::float2_field(a2, 1, COERCE_DOUBLE(vcvt_f32_f64(*((float64x2_t *)this + 4))));
  RB::ProtobufEncoder::float2_field(a2, 2, COERCE_DOUBLE(vcvt_f32_f64(*((float64x2_t *)this + 5))));
  if (*((_QWORD *)this + 13) != 0x209BD98A8)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RBPathEncode(*((RBPath *)this + 6), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v4 = *((_DWORD *)this + 28);
  if ((v4 & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v4 = *((_DWORD *)this + 28);
  }
  if ((v4 & 2) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::PathProjectionStyle::decode(float64x2_t *this, RB::Decoder *a2)
{
  unint64_t result;
  __n128 v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  float64x2_t v11;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          this[4] = vcvtq_f64_f32((float32x2_t)RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0]);
          break;
        case 2u:
          this[5] = vcvtq_f64_f32((float32x2_t)RB::ProtobufDecoder::float2_field(a2, v6, v5).n128_u64[0]);
          break;
        case 3u:
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RBPathDecode(a2, (uint64_t *)&v11);
            v7 = *(_QWORD *)&this[6].f64[0];
            v8 = *(_QWORD *)&this[6].f64[1];
            this[6] = v11;
            *(_QWORD *)&v11.f64[0] = v7;
            *(_QWORD *)&v11.f64[1] = v8;
            RBPathRelease(v7, v8);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          break;
        case 4u:
          v9 = LODWORD(this[7].f64[0]) | RB::ProtobufDecoder::BOOL_field(a2, v6);
          goto LABEL_14;
        case 5u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v6))
            v10 = 2;
          else
            v10 = 0;
          v9 = LODWORD(this[7].f64[0]) | v10;
LABEL_14:
          LODWORD(this[7].f64[0]) = v9;
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v6);
          break;
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::PathProjectionStyle::print(const RB::AffineTransform **this, std::string *a2)
{
  RB::SexpString::print(a2, 0, "path-projection");
  RB::DisplayList::Style::print(this, a2);
}

double RB::DisplayList::State::add_alpha_threshold(__n128 *a1, RB::DisplayList::Builder *a2, uint64_t a3, __int16 a4, double a5)
{
  RB::Heap *v7;
  uint64_t v8;
  RB::DisplayList::Style *v9;
  double result;
  uint64_t v11;
  double v12;
  uint64_t v13;
  __int16 v14;

  v13 = a3;
  v14 = a4;
  v12 = a5;
  v7 = (RB::Heap *)(*((_QWORD *)a2 + 1) + 16);
  _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_20AlphaThresholdEffectEEEJRDv2_fRNS_4Fill5ColorEEEEPT_DpOT0_(v7, &v12, &v13);
  v11 = v8;
  RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(v7, &v11);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, a2, v9).n128_u64[0];
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_20AlphaThresholdEffectEEEJRDv2_fRNS_4Fill5ColorEEEEPT_DpOT0_(RB::Heap *this, double *a2, uint64_t *a3)
{
  unint64_t v6;
  unint64_t v7;
  double result;
  uint64_t v9;
  __int16 v10;

  v6 = *((_QWORD *)this + 3);
  v7 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 48 > v6)
    v7 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = v7 + 48;
  *(_QWORD *)v7 = &off_24C2279B8;
  result = *a2;
  v9 = *a3;
  v10 = *((_WORD *)a3 + 4);
  *(double *)(v7 + 16) = *a2;
  *(_QWORD *)(v7 + 24) = v9;
  *(_WORD *)(v7 + 32) = v10;
  *(_BYTE *)(v7 + 40) = 1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  v6 = *a2;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228570;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 56) = v6;
  return result;
}

double RB::DisplayList::AlphaThresholdStyle::copy(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Builder *a2)
{
  uint64_t v3;
  uint64_t v5;

  RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (__n128 *)(*((_QWORD *)this + 7) + 16));
  v5 = v3;
  return RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), &v5);
}

__n128 RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  __n128 *v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (__n128 *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5[3].n128_u64 > v4)
    v5 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 3;
  v5->n128_u64[0] = (unint64_t)&off_24C2279B8;
  result = *a2;
  v5[2].n128_u16[0] = a2[1].n128_u16[0];
  v5[1] = result;
  v5[2].n128_u8[8] = 1;
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::AlphaThresholdStyle::draw(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Item *v9;
  const RB::DisplayList::ClipNode *v10;
  uint64_t v11;

  v9 = RB::DisplayList::Builder::ensure_layer(a2, a4, 0.0, 160);
  v10 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 3);
  *((_QWORD *)v9 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)v9 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)v9 + 3), v10);
  v11 = *((_QWORD *)v9 + 6);
  *(_BYTE *)(v11 + 64) = 2;
  *(_QWORD *)(v11 + 24) = *((_QWORD *)this + 7);
  return RB::DisplayList::Builder::draw(a2, v9, a3, a5);
}

uint64_t RB::DisplayList::AlphaThresholdStyle::map_dod(uint64_t this, int32x2_t *a2, RB::AffineTransform *a3)
{
  float32x2_t v3;

  v3 = *(float32x2_t *)(*(_QWORD *)(this + 56) + 16);
  if ((vcgt_f32((float32x2_t)vdup_lane_s32((int32x2_t)v3, 1), v3).u8[0] & 1) != 0)
  {
    if (v3.f32[0] > 0.0)
    {
      *a2 = (int32x2_t)0x100000001000000;
      a2[1] = vdup_n_s32(0x7F7FFFFFu);
    }
  }
  else
  {
    *a2 = 0;
    a2[1] = 0;
  }
  return this;
}

uint64_t RB::DisplayList::AlphaThresholdStyle::can_mix(RB::DisplayList::AlphaThresholdStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3)
    return RB::AlphaThresholdEffect::can_mix((float32x2_t *)(*((_QWORD *)this + 7) + 16), (float32x2_t *)(*((_QWORD *)a3 + 7) + 16));
  else
    return 0;
}

void RB::DisplayList::AlphaThresholdStyle::mix(RB::DisplayList::AlphaThresholdStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  __n128 v7;
  uint64_t v8;
  int8x16_t v9;
  double v10;
  double v11;
  double v12;
  int8x16_t v13;
  uint64_t v14;

  if (a3)
  {
    v7 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>,RB::AlphaThresholdEffect const&,RB::DisplayList::Contents &>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (__n128 *)(*((_QWORD *)this + 7) + 16));
    v14 = v8;
    v7.n128_u32[0] = *((_DWORD *)a2 + 4);
    RB::AlphaThresholdEffect::mix((RB::AlphaThresholdEffect *)(v8 + 16), (const RB::AlphaThresholdEffect *)(*((_QWORD *)a3 + 7) + 16), (int8x16_t)v7, v9, v10, v11, v12, v13);
    RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), &v14);
  }
}

_QWORD *RB::DisplayList::AlphaThresholdStyle::encode(RB::DisplayList::AlphaThresholdStyle *this, RB::Encoder *a2)
{
  RB::AlphaThresholdEffect *v4;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = (RB::AlphaThresholdEffect *)(*((_QWORD *)this + 7) + 16);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::AlphaThresholdEffect::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::AlphaThresholdStyle::print(RB::DisplayList::AlphaThresholdStyle *this, std::string *a2)
{
  RB::AlphaThresholdEffect::print((RB::AlphaThresholdEffect *)(*((_QWORD *)this + 7) + 16), a2);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
}

double RB::DisplayList::State::add_alpha_gradient(__n128 *a1, RB::DisplayList::Builder *a2, unint64_t a3, uint64_t a4, unsigned __int16 a5, uint64_t a6, int a7)
{
  uint64_t v9;
  RB::Heap *v10;
  RB::DisplayList::Style *v11;
  double result;
  unint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;

  v16 = a4;
  v17 = a3;
  v15 = a6;
  v14 = a7;
  v9 = *((_QWORD *)a2 + 1);
  if ((a5 & 0xFF00) == 0)
    a5 = a1[9].n128_u16[6];
  v10 = (RB::Heap *)(v9 + 16);
  LOWORD(v13) = a5;
  v13 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,unsigned long &,RBColor const*&,std::optional<RB::ColorSpace>,double const*&,unsigned int &>((size_t *)(v9 + 16), (RB::Heap *)(v9 + 16), &v17, &v16, (__int16 *)&v13, &v15, &v14);
  RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(v10, (uint64_t *)&v13);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, a2, v11).n128_u64[0];
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::Heap&,unsigned long &,RBColor const*&,std::optional<RB::ColorSpace>,double const*&,unsigned int &>(size_t *a1, RB::Heap *a2, unint64_t *a3, uint64_t *a4, __int16 *a5, uint64_t *a6, int *a7)
{
  unint64_t v13;

  v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 88 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  else
    a1[2] = v13 + 88;
  *(_QWORD *)v13 = &off_24C2278F8;
  RB::Fill::Gradient::Gradient(v13 + 16, a2, 3, *a3, *a4, *a5, *a6, *a7, 0.0, 0.0, 0.0, 0.0);
  *(_BYTE *)(v13 + 80) = 1;
  return v13;
}

double RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(RB::Heap *this, uint64_t *a2)
{
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  double result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 64 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 64;
  v6 = *a2;
  result = 0.0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C2284E8;
  *(_QWORD *)(v5 + 48) = 0;
  *(_QWORD *)(v5 + 56) = v6;
  return result;
}

double RB::DisplayList::AlphaGradientStyle::copy(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Builder *a2)
{
  unint64_t v4;

  v4 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>((size_t *)(*((_QWORD *)a2 + 1) + 16), (uint64_t *)(*((_QWORD *)this + 7) + 16), *((_QWORD *)a2 + 1));
  return RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), (uint64_t *)&v4);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>(size_t *a1, uint64_t *a2, uint64_t a3)
{
  unint64_t v5;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 88 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x58uLL, 7);
  else
    a1[2] = v5 + 88;
  *(_QWORD *)v5 = &off_24C2278F8;
  RB::AlphaGradientEffect::AlphaGradientEffect((uint64_t *)(v5 + 16), a2, a3);
  *(_BYTE *)(v5 + 80) = 1;
  return v5;
}

RB::DisplayList::Builder *RB::DisplayList::AlphaGradientStyle::draw(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  RB::DisplayList::Item *v9;
  const RB::DisplayList::ClipNode *v10;

  v10 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 3);
  *((_QWORD *)v9 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)v9 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)v9 + 3), v10);
  return RB::DisplayList::Builder::draw(a2, v9, a3, a5);
}

int32x2_t RB::DisplayList::AlphaGradientStyle::map_dod(RB::DisplayList::AlphaGradientStyle *this, int32x2_t *a2, RB::AffineTransform *a3, double a4, double a5, double a6, double a7, float a8)
{
  int32x2_t result;

  *(float *)result.i32 = RB::Fill::Gradient::sample_alpha((RB::Fill::Gradient *)(*((_QWORD *)this + 7) + 16), 0.0, a5, a6, a7, a8);
  if (*(float *)result.i32 > 0.0)
  {
    result = vdup_n_s32(0x7F7FFFFFu);
    *a2 = (int32x2_t)0x100000001000000;
    a2[1] = result;
  }
  return result;
}

uint64_t RB::DisplayList::AlphaGradientStyle::can_mix(RB::DisplayList::AlphaGradientStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3)
    return RB::AlphaGradientEffect::can_mix((RB::AlphaGradientEffect *)(*((_QWORD *)this + 7) + 16), (const RB::AlphaGradientEffect *)(*((_QWORD *)a3 + 7) + 16));
  else
    return 0;
}

void RB::DisplayList::AlphaGradientStyle::mix(RB::DisplayList::AlphaGradientStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  unint64_t v7;

  if (a3)
  {
    v7 = RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>,RB::AlphaGradientEffect const&,RB::DisplayList::Contents &>((size_t *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (uint64_t *)(*((_QWORD *)this + 7) + 16), *(_QWORD *)(*(_QWORD *)a4 + 8));
    RB::AlphaGradientEffect::mix((RB::AlphaGradientEffect *)(v7 + 16), (const RB::AlphaGradientEffect *)(*((_QWORD *)a3 + 7) + 16), *((float *)a2 + 4), (RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16));
    RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (uint64_t *)&v7);
  }
}

_QWORD *RB::DisplayList::AlphaGradientStyle::encode(RB::DisplayList::AlphaGradientStyle *this, RB::Encoder *a2)
{
  RB::AlphaGradientEffect *v4;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  v4 = (RB::AlphaGradientEffect *)(*((_QWORD *)this + 7) + 16);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::AlphaGradientEffect::encode(v4, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::AlphaGradientStyle::print(RB::DisplayList::AlphaGradientStyle *this, std::string *a2)
{
  RB::AlphaGradientEffect::print((RB::AlphaGradientEffect *)(*((_QWORD *)this + 7) + 16), a2);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
}

unint64_t RB::DisplayList::CustomEffectStyle::copy(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Builder *a2)
{
  RB::DisplayList::Layer *v4;
  size_t *v5;
  RB::DisplayList::Layer *v7;

  v4 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
  if (v4)
    v4 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v4, a2, 0);
  v5 = (size_t *)(*((_QWORD *)a2 + 1) + 16);
  v7 = v4;
  return _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(v5, (RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (uint64_t *)&v7, (uint64_t *)this + 24, (uint64_t *)this + 25, (_OWORD *)this + 13, (int *)this + 56);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(size_t *a1, RB::CustomShader::Closure *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _OWORD *a6, int *a7)
{
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;

  v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 232 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0xE8uLL, 7);
  else
    a1[2] = v13 + 232;
  v14 = *a3;
  v15 = *a4;
  v16 = *a5;
  v17 = *a7;
  *(_QWORD *)(v13 + 48) = 0;
  *(_OWORD *)(v13 + 16) = 0u;
  *(_OWORD *)(v13 + 32) = 0u;
  *(_QWORD *)v13 = &off_24C228460;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v13 + 56), a2);
  *(_QWORD *)(v13 + 184) = v14;
  *(_QWORD *)(v13 + 192) = v15;
  *(_QWORD *)(v13 + 200) = v16;
  *(_OWORD *)(v13 + 208) = *a6;
  *(_DWORD *)(v13 + 224) = v17;
  return v13;
}

void RB::DisplayList::CustomEffectStyle::apply_transform(RB::DisplayList::CustomEffectStyle *this, const RB::DisplayList::CachedTransform *a2)
{
  RB::DisplayList::Layer *v2;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
  if (v2)
    RB::DisplayList::Layer::apply_transform(v2, a2);
}

RB::DisplayList::Builder *RB::DisplayList::CustomEffectStyle::draw(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float32x2_t v10;
  RB::DisplayList::Layer *v11;
  unint64_t v12;
  uint64_t v13;
  RB::DisplayList::Item *v14;
  uint64_t v15;
  uint64_t v16;
  RB::DisplayList::Layer *v18;
  float32x2_t v19;
  float32x2_t v20;

  v10 = *(float32x2_t *)((char *)this + 192);
  v19 = *(float32x2_t *)((char *)this + 200);
  v20 = v10;
  RB::CustomEffect::transform_border(&v20, *((float64x2_t **)this + 2));
  if (*((_QWORD *)this + 23))
  {
    RB::CustomEffect::transform_border(&v19, *((float64x2_t **)this + 2));
    v11 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
    if (v11)
      v11 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v11, a2, 0);
  }
  else
  {
    v11 = 0;
  }
  v18 = v11;
  v12 = _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_12CustomEffectEEEJRKNS_12CustomShader7ClosureERPNS2_5LayerERDv2_fSE_RKNS_4RectERKNS_15AffineTransformERKjEEEPT_DpOT0_((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (uint64_t *)&v18, (uint64_t *)&v20, (uint64_t *)&v19, (_OWORD *)this + 13, *((__int128 **)this + 2), (int *)this + 56);
  v13 = *((_QWORD *)a2 + 1);
  *(_QWORD *)(v12 + 8) = *(_QWORD *)(v13 + 312);
  *(_QWORD *)(v13 + 312) = v12;
  v14 = RB::DisplayList::Builder::ensure_layer(a2, a4, 0.0, (2 * *((_DWORD *)this + 56)) & 0x10);
  *((_QWORD *)v14 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)v14 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)v14 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
  v15 = *((_QWORD *)this + 23);
  if (v15 && (*(_WORD *)(v15 + 60) & 0x2001) != 0)
    *((_WORD *)v14 + 23) |= 0x400u;
  v16 = *((_QWORD *)v14 + 6);
  *(_BYTE *)(v16 + 64) = 2;
  *(_QWORD *)(v16 + 24) = v12;
  return RB::DisplayList::Builder::draw(a2, v14, a3, a5);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList13GenericEffectINS_12CustomEffectEEEJRKNS_12CustomShader7ClosureERPNS2_5LayerERDv2_fSE_RKNS_4RectERKNS_15AffineTransformERKjEEEPT_DpOT0_(size_t *a1, RB::CustomShader::Closure *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, _OWORD *a6, __int128 *a7, int *a8)
{
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  __int128 v21;

  v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 272 > a1[3])
    v15 = RB::Heap::alloc_slow(a1, 0x110uLL, 15);
  else
    a1[2] = v15 + 272;
  *(_QWORD *)v15 = &off_24C227838;
  v16 = *a3;
  v17 = *a4;
  v18 = *a5;
  v19 = *a8;
  RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)(v15 + 16), a2);
  *(_QWORD *)(v15 + 144) = v16;
  *(_QWORD *)(v15 + 152) = v17;
  *(_QWORD *)(v15 + 160) = v18;
  v20 = *a7;
  v21 = a7[2];
  *(_OWORD *)(v15 + 192) = a7[1];
  *(_OWORD *)(v15 + 208) = v21;
  *(_OWORD *)(v15 + 176) = v20;
  *(_OWORD *)(v15 + 224) = *a6;
  *(_DWORD *)(v15 + 240) = v19;
  *(_BYTE *)(v15 + 256) = 1;
  return v15;
}

void RB::DisplayList::CustomEffectStyle::map_roi(RB::DisplayList::CustomEffectStyle *this, float32x2_t *a2, float64x2_t *a3)
{
  uint32x2_t v3;
  int32x2_t v6;
  uint32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  int32x4_t v10;

  v3 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&a2[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    if (!*((_QWORD *)this + 23) || (*((_BYTE *)this + 224) & 0x10) != 0)
    {
      v7 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 192)));
      if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
        return;
      RB::Rect::move(a2, a3, *((float64x2_t **)this + 2));
      v8 = vabs_f32(*(float32x2_t *)((char *)this + 192));
      v9 = a2[1];
      *(int32x2_t *)v10.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v9);
      v10.i64[0] = vcltzq_s32(v10).u64[0];
      *a2 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vsub_f32(*a2, v8), (int8x8_t)*a2);
      v6 = (int32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vmla_f32(v9, (float32x2_t)0x4000000040000000, v8), (int8x8_t)v9);
    }
    else
    {
      *a2 = (float32x2_t)0x100000001000000;
      v6 = vdup_n_s32(0x7F7FFFFFu);
    }
    a2[1] = (float32x2_t)v6;
  }
}

void RB::DisplayList::CustomEffectStyle::map_dod(RB::DisplayList::CustomEffectStyle *this, float32x2_t *a2, float64x2_t *a3)
{
  uint32x2_t v3;
  uint32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  int32x4_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float64x2_t *v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t *v17;
  float64x2_t v18;
  float64x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int32x4_t v23;
  int32x4_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;

  v3 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&a2[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    v7 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 192)));
    if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0)
    {
      RB::Rect::move(a2, a3, *((float64x2_t **)this + 2));
      v8 = vabs_f32(*(float32x2_t *)((char *)this + 192));
      v9 = a2[1];
      *(int32x2_t *)v10.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v9);
      v10.i64[0] = vcltzq_s32(v10).u64[0];
      *a2 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vsub_f32(*a2, v8), (int8x8_t)*a2);
      a2[1] = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vmla_f32(v9, (float32x2_t)0x4000000040000000, v8), (int8x8_t)v9);
    }
    if (*((_QWORD *)this + 23) && (*((_BYTE *)this + 224) & 0x10) == 0)
    {
      RB::Rect::move(a2, a3, *((float64x2_t **)this + 2));
      v11 = RB::DisplayList::Layer::bounds(*((RB::DisplayList::Layer **)this + 23));
      v13 = v12;
      v14 = (float64x2_t *)*((_QWORD *)this + 2);
      v15 = *v14;
      v16 = v14[2];
      v26 = v14[1];
      v27 = v16;
      v25 = v15;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v25))
        v17 = &v25;
      else
        v17 = v14;
      v18 = v17[1];
      v19 = v17[2];
      v25 = *v17;
      v26 = v18;
      v27 = v19;
      v20 = RB::operator*(&v25, v11, v13);
      v21 = vabs_f32(*(float32x2_t *)((char *)this + 200));
      *(int32x2_t *)v23.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v22);
      v23.i64[0] = vcltzq_s32(v23).u64[0];
      *(float32x2_t *)v24.i8 = vmla_f32(v22, (float32x2_t)0x4000000040000000, v21);
      RB::Rect::Union(a2, (float32x2_t)vbsl_s8(*(int8x8_t *)v23.i8, (int8x8_t)vsub_f32(v20, v21), (int8x8_t)v20), (float32x2_t)vbsl_s8(*(int8x8_t *)v23.i8, *(int8x8_t *)v24.i8, (int8x8_t)v22), *(double *)&v21, *(double *)v23.i64, 2.00000048, v24);
    }
  }
}

BOOL RB::DisplayList::CustomEffectStyle::can_mix(RB::DisplayList::CustomEffectStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return a3
      && *((_DWORD *)this + 56) == *((_DWORD *)a3 + 56)
      && RB::CustomShader::Closure::can_mix((RB::DisplayList::CustomEffectStyle *)((char *)this + 56), (const Closure *)((char *)a3 + 56));
}

unint64_t RB::DisplayList::CustomEffectStyle::mix(float32x2_t *this, float32_t *a2, float32x2_t *a3, RB::DisplayList::Builder **a4)
{
  RB::DisplayList::Layer *v8;
  const RB::DisplayList::Layer *v9;
  size_t *v10;
  uint64_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  unint64_t v19;
  int8x16_t v20;
  double v21;
  double v22;
  double v23;
  int8x16_t v24;
  __int128 v26;
  float32x2_t v27;
  float32x2_t v28;
  RB::DisplayList::Layer *v29;

  if (!a3)
    return 0;
  v29 = 0;
  v8 = (RB::DisplayList::Layer *)this[23];
  if (v8)
  {
    v9 = (const RB::DisplayList::Layer *)a3[23];
    if (v9)
      v29 = RB::DisplayList::Layer::mix(v8, (const RB::DisplayList::Interpolator::State *)a2, v9, a4);
  }
  v10 = (size_t *)(*((_QWORD *)*a4 + 1) + 16);
  v11 = *((_QWORD *)a2 + 2);
  v12 = this[25];
  v13 = a3[25];
  v28 = vmla_n_f32(this[24], vsub_f32(a3[24], this[24]), *(float *)&v11);
  v27 = vmla_n_f32(v12, vsub_f32(v13, v12), *(float *)&v11);
  v14 = this[26];
  v15 = a3[26];
  v16 = vadd_f32(this[27], v14);
  v17 = vmla_n_f32(v14, vsub_f32(v15, v14), *(float *)&v11);
  v18 = vsub_f32(vmla_n_f32(v16, vadd_f32(vsub_f32(v15, v16), a3[27]), *(float *)&v11), v17);
  *(float32x2_t *)&v26 = v17;
  *((float32x2_t *)&v26 + 1) = v18;
  v19 = _ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_(v10, (RB::CustomShader::Closure *)&this[7], (uint64_t *)&v29, (uint64_t *)&v28, (uint64_t *)&v27, &v26, (int *)&this[28]);
  RB::CustomShader::Closure::mix((RB::CustomShader::Closure *)(v19 + 56), (const RB::CustomShader::Closure *)&a3[7], a2[4], v20, v21, v22, v23, v24);
  return v19;
}

uint64_t *RB::DisplayList::CustomEffectStyle::prepare_encode(RB::DisplayList::CustomEffectStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode(this, a2);
  return RB::CustomShader::Closure::prepare_encode((RB::DisplayList::CustomEffectStyle *)((char *)this + 56), a2);
}

uint64_t *RB::DisplayList::Style::prepare_encode(RB::DisplayList::Style *this, RB::Encoder *a2)
{
  uint64_t *result;
  _QWORD *v5;

  result = (uint64_t *)*((_QWORD *)this + 3);
  if (result)
  {
    RB::DisplayList::ClipNode::prepare_encode((unint64_t)result, (uint64_t)a2);
    return RB::Encoder::prepare_shared_f<void RB::Encoder::prepare_shared<RB::DisplayList::ClipNode>(RB::Encoder::SharedType,RB::DisplayList::ClipNode const&)::{lambda(RB::DisplayList::ClipNode&)#1}>((uint64_t *)a2, 4, *((uint64_t **)this + 3), &v5);
  }
  return result;
}

_QWORD *RB::DisplayList::CustomEffectStyle::encode(RB::DisplayList::CustomEffectStyle *this, RB::Encoder *a2)
{
  unint64_t v4;
  uint32x2_t v5;
  _QWORD **v6;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::CustomShader::Closure::encode((RB::CustomShader::Function **)this + 7, a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 24));
  v4 = *((_DWORD *)this + 56) & 3;
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  RB::ProtobufEncoder::encode_varint(a2, v4);
  if ((*((_BYTE *)this + 224) & 4) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  v5 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)((char *)this + 216));
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0)
    RB::ProtobufEncoder::float4_field(a2, 5, *((float32x4_t *)this + 13));
  if ((*((_BYTE *)this + 224) & 8) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  v6 = (_QWORD **)*((_QWORD *)this + 23);
  if (v6)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::DisplayList::Layer::encode(v6, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
    RB::ProtobufEncoder::float2_field(a2, 8, *((double *)this + 25));
  }
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::CustomEffectStyle::decode(__n128 *this, size_t **a2)
{
  unint64_t result;
  __n128 v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  int v9;
  int v10;
  uint64_t v11;
  RB::DisplayList::Layer *v12;
  RB::DisplayList::Layer *v13;
  int v14;
  int v15;

  result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
  if (result)
  {
    v6 = result;
    do
    {
      switch((v6 >> 3))
      {
        case 1u:
          if ((v6 & 7) != 2)
            goto LABEL_27;
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          RB::CustomShader::Closure::decode((RB::CustomShader::Closure *)&this[3].n128_i8[8], (RB::Decoder *)a2);
          goto LABEL_23;
        case 2u:
          this[12].n128_u64[0] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, v6, v5).n128_u64[0];
          break;
        case 3u:
          this[14].n128_u32[0] &= 0xFFFFFFFC;
          v7 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a2, v6);
          if (v7 > 2)
            break;
          v8 = this[14].n128_u32[0] | v7;
          goto LABEL_18;
        case 4u:
          this[14].n128_u32[0] &= ~4u;
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v6))
            v9 = 4;
          else
            v9 = 0;
          goto LABEL_17;
        case 5u:
          this[13] = RB::ProtobufDecoder::float4_field((RB::ProtobufDecoder *)a2, v6);
          break;
        case 6u:
          this[14].n128_u32[0] &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, v6))
            v9 = 8;
          else
            v9 = 0;
LABEL_17:
          v8 = this[14].n128_u32[0] | v9;
LABEL_18:
          this[14].n128_u32[0] = v8;
          break;
        case 7u:
          v10 = *((_DWORD *)a2 + 56) + 1;
          *((_DWORD *)a2 + 56) = v10;
          v14 = 0;
          v15 = v10;
          v11 = RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(a2[8], &v15, &v14);
          v12 = (RB::DisplayList::Layer *)this[11].n128_u64[1];
          this[11].n128_u64[1] = v11;
          if (v12)
            RB::DisplayList::Layer::~Layer(v12);
          if ((v6 & 7) == 2)
          {
            v13 = (RB::DisplayList::Layer *)this[11].n128_u64[1];
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
            RB::DisplayList::Layer::decode(v13, (RB::Decoder *)a2);
LABEL_23:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_27:
            *((_BYTE *)a2 + 56) = 1;
            *a2 = a2[1];
          }
          break;
        case 8u:
          this[12].n128_u64[1] = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, v6, v5).n128_u64[0];
          break;
        default:
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v6);
          break;
      }
      result = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::CustomEffectStyle::print(RB::DisplayList::CustomEffectStyle *this, std::string *a2)
{
  uint64_t v4;
  float32x2_t v5;
  uint32x2_t v6;
  const char *v7;
  RB::DisplayList::Layer *v8;

  v4 = *((_QWORD *)this + 7);
  if (v4)
    RB::SexpString::printf(a2, 0, "(shader %s)", (const char *)objc_msgSend(*(id *)(v4 + 24), "UTF8String"));
  v5 = *(float32x2_t *)((char *)this + 216);
  v6 = (uint32x2_t)vcgtz_f32(v5);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
    RB::SexpString::printf(a2, 0, "(bounds %g %g %g %g)", COERCE_FLOAT(*((_QWORD *)this + 26)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 26))), v5.f32[0], v5.f32[1]);
  if ((*((_DWORD *)this + 56) & 3) == 2)
    v7 = "warp";
  else
    v7 = "layer";
  RB::SexpString::printf(a2, 0, "(type %s)", v7);
  v8 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
  if (v8)
    RB::DisplayList::Layer::print(v8, a2);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
}

double RB::DisplayList::State::add_custom_effect(__n128 *a1, RB::DisplayList::Builder *a2, RB::CustomShader::Closure *a3, uint64_t a4, _OWORD *a5, int a6, double a7, double a8)
{
  RB::DisplayList::Style *v10;
  double result;
  int v12;
  double v13;
  double v14;
  uint64_t v15;

  v15 = a4;
  v13 = a8;
  v14 = a7;
  v12 = a6;
  v10 = (RB::DisplayList::Style *)_ZN2RB4Heap7emplaceINS_11DisplayList17CustomEffectStyleEJRKNS_12CustomShader7ClosureERPNS2_5LayerERKDv2_fSD_RKNS_4RectERKjEEEPT_DpOT0_((size_t *)(*((_QWORD *)a2 + 1) + 16), a3, &v15, (uint64_t *)&v14, (uint64_t *)&v13, a5, &v12);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, a2, v10).n128_u64[0];
  return result;
}

unint64_t RB::DisplayList::PredicateStyle::copy(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::DisplayList::PredicateStyle *)((char *)this + 56), (char *)this + 96);
}

unint64_t RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>(size_t *a1, RB::DisplayList::Predicate *a2, char *a3)
{
  unint64_t v5;
  char v6;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 104 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x68uLL, 7);
  else
    a1[2] = v5 + 104;
  v6 = *a3;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C227E00;
  RB::DisplayList::InvertiblePredicate::InvertiblePredicate((RB::DisplayList::InvertiblePredicate *)(v5 + 56), a2, v6);
  return v5;
}

RB::DisplayList::Builder *RB::DisplayList::PredicateStyle::draw(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  const RB::DisplayList::ClipNode *v10;

  if ((*(unsigned int (**)(RB::DisplayList::Item *, char *))(*(_QWORD *)a4 + 192))(a4, (char *)this + 56) == (*((_BYTE *)this + 96) != 0))
    return (RB::DisplayList::Builder *)(**(uint64_t (***)(RB::DisplayList::Item *))a4)(a4);
  v10 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 3);
  *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)a4 + 3), v10);
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::PredicateStyle::can_mix(RB::DisplayList::PredicateStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3)
    return RB::DisplayList::InvertiblePredicate::can_mix((RB::DisplayList::PredicateStyle *)((char *)this + 56), (const RB::DisplayList::Style *)((char *)a3 + 56));
  else
    return 0;
}

unint64_t RB::DisplayList::PredicateStyle::mix(RB::DisplayList::PredicateStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  unint64_t v6;

  if (!a3)
    return 0;
  v6 = RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (RB::DisplayList::PredicateStyle *)((char *)this + 56), (char *)this + 96);
  RB::DisplayList::InvertiblePredicate::mix((RB::DisplayList::InvertiblePredicate *)(v6 + 56), (const RB::DisplayList::Style *)((char *)a3 + 56), *((float *)a2 + 4));
  return v6;
}

_QWORD *RB::DisplayList::PredicateStyle::encode(RB::DisplayList::PredicateStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x42uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::InvertiblePredicate::encode((RB::DisplayList::PredicateStyle *)((char *)this + 56), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::DisplayList::PredicateStyle::print(RB::DisplayList::PredicateStyle *this, std::string *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  RB::SexpString::push(a2, "display-list-predicate");
  if (*((_BYTE *)this + 96))
    RB::SexpString::print(a2, 0, "inverts-result");
  RB::XML::Document::Document((RB::XML::Document *)&v6);
  RB::DisplayList::Predicate::xml_elements((uint64_t)this + 56, (RB::XML::Document *)&v6);
  RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
  if (v7)
    free(v7);
  result = v6;
  if (v6)
  {
    v5 = *(_DWORD *)(v6 + 8) - 1;
    *(_DWORD *)(v6 + 8) = v5;
    if (!v5)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void sub_209B92AB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RB::XML::Document::~Document((RB::XML::Document *)&a9);
  _Unwind_Resume(a1);
}

double RB::DisplayList::State::add_predicate(__n128 *this, RB::DisplayList::Builder *a2, const RB::DisplayList::Predicate *a3, char a4)
{
  RB::DisplayList::Style *v6;
  double result;
  char v8;

  v8 = a4;
  v6 = (RB::DisplayList::Style *)RB::Heap::emplace<RB::DisplayList::PredicateStyle,RB::DisplayList::Predicate const&,BOOL const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), a3, &v8);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(this, a2, v6).n128_u64[0];
  return result;
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::copy(RB::DisplayList::TransformStyle *this, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::DisplayList::TransformStyle *)((char *)this + 56));
}

RB::DisplayList::TransformStyle *RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>(size_t *a1, RB::DisplayList::Transform *a2)
{
  RB::DisplayList::TransformStyle *v3;

  v3 = (RB::DisplayList::TransformStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v3 + 104 > a1[3])
    v3 = (RB::DisplayList::TransformStyle *)RB::Heap::alloc_slow(a1, 0x68uLL, 7);
  else
    a1[2] = (size_t)v3 + 104;
  return RB::DisplayList::TransformStyle::TransformStyle(v3, a2);
}

RB::DisplayList::Builder *RB::DisplayList::TransformStyle::draw(RB::DisplayList::TransformStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  const RB::DisplayList::ClipNode *v10;

  v10 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 3);
  *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)a4 + 3), v10);
  (*(void (**)(RB::DisplayList::Item *, char *, _QWORD))(*(_QWORD *)a4 + 200))(a4, (char *)this + 56, *((_QWORD *)a2 + 1));
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::TransformStyle::can_mix(RB::DisplayList::TransformStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  if (a3)
    return RB::DisplayList::Transform::can_mix((RB::DisplayList::TransformStyle *)((char *)this + 56), (const RB::DisplayList::Style *)((char *)a3 + 56));
  else
    return 0;
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::mix(RB::DisplayList::TransformStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  RB::DisplayList::TransformStyle *v6;
  int8x16_t v7;
  int8x16_t v8;
  double v9;
  double v10;
  double v11;
  int8x16_t v12;

  if (!a3)
    return 0;
  v6 = RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), (RB::DisplayList::TransformStyle *)((char *)this + 56));
  v7.i32[0] = *((_DWORD *)a2 + 4);
  RB::DisplayList::Transform::mix((RB::DisplayList::TransformStyle *)((char *)v6 + 56), (const RB::DisplayList::Style *)((char *)a3 + 56), v7, v8, v9, v10, v11, v12);
  return v6;
}

_QWORD *RB::DisplayList::TransformStyle::encode(RB::DisplayList::TransformStyle *this, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x4AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::DisplayList::Transform::encode((int *)this + 14, a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

uint64_t RB::DisplayList::TransformStyle::print(const RB::AffineTransform **this, std::string *a2)
{
  uint64_t result;
  int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;

  RB::SexpString::push(a2, "display-list-transform");
  RB::XML::Document::Document((RB::XML::Document *)&v6);
  RB::DisplayList::Transform::xml_elements((uint64_t)(this + 7), (RB::XML::Document *)&v6);
  RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
  RB::DisplayList::Style::print(this, a2);
  RB::SexpString::pop(a2);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
  if (v7)
    free(v7);
  result = v6;
  if (v6)
  {
    v5 = *(_DWORD *)(v6 + 8) - 1;
    *(_DWORD *)(v6 + 8) = v5;
    if (!v5)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void sub_209B92D74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RB::XML::Document::~Document((RB::XML::Document *)&a9);
  _Unwind_Resume(a1);
}

double RB::DisplayList::State::add_transform(__n128 *this, RB::DisplayList::Builder *a2, const RB::DisplayList::Transform *a3)
{
  RB::DisplayList::Style *v5;
  double result;

  v5 = RB::Heap::emplace<RB::DisplayList::TransformStyle,RB::DisplayList::Transform const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), a3);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(this, a2, v5).n128_u64[0];
  return result;
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::AnimationStyle(RB::DisplayList::AnimationStyle *this, const RB::Animation *a2, const UUID *a3, int a4)
{
  const RB::Animation *v5;
  unsigned int v6;
  char *v7;
  uint64_t v8;
  char *v9;
  unsigned int v10;
  int v11;
  int v12;

  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_QWORD *)this = &off_24C227CF0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0x600000000;
  *((_OWORD *)this + 6) = *(_OWORD *)a3;
  *((_DWORD *)this + 28) = a4;
  if (a2)
  {
    *((_DWORD *)this + 22) = 0;
    if (*((_QWORD *)a2 + 3))
      v5 = (const RB::Animation *)*((_QWORD *)a2 + 3);
    else
      v5 = a2;
    v6 = *((_DWORD *)a2 + 8);
    if (v6 >= 7)
    {
      RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((char *)this + 56, *((_DWORD *)a2 + 8));
      v8 = *((unsigned int *)this + 22);
      v7 = (char *)*((_QWORD *)this + 10);
    }
    else
    {
      if (!v6)
      {
        v12 = 0;
LABEL_14:
        *((_DWORD *)this + 22) = v12 + v6;
        return this;
      }
      v7 = 0;
      v8 = 0;
    }
    if (!v7)
      v7 = (char *)this + 56;
    v9 = &v7[4 * v8];
    v10 = v6;
    do
    {
      v11 = *(_DWORD *)v5;
      v5 = (const RB::Animation *)((char *)v5 + 4);
      *(_DWORD *)v9 = v11;
      v9 += 4;
      --v10;
    }
    while (v10);
    v12 = *((_DWORD *)this + 22);
    goto LABEL_14;
  }
  return this;
}

void sub_209B92E9C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 80);
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::copy(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Builder *a2)
{
  size_t *v2;
  const RB::Animation *v4;

  v2 = (size_t *)(*((_QWORD *)a2 + 1) + 16);
  v4 = (RB::DisplayList::AnimationStyle *)((char *)this + 56);
  return RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>(v2, &v4, (UUID *)((uint8_t *)this + 6), (int *)this + 28);
}

RB::DisplayList::AnimationStyle *RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>(size_t *a1, const RB::Animation **a2, UUID *a3, int *a4)
{
  RB::DisplayList::AnimationStyle *v7;

  v7 = (RB::DisplayList::AnimationStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v7 + 120 > a1[3])
    v7 = (RB::DisplayList::AnimationStyle *)RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  else
    a1[2] = (size_t)v7 + 120;
  return RB::DisplayList::AnimationStyle::AnimationStyle(v7, *a2, a3, *a4);
}

RB::DisplayList::Builder *RB::DisplayList::AnimationStyle::draw(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  const RB::DisplayList::ClipNode *v9;

  v9 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 3);
  *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
  *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)a4 + 3), v9);
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::AnimationStyle::can_mix(RB::DisplayList::AnimationStyle *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return 4;
}

uint64_t RB::DisplayList::AnimationStyle::mix(RB::DisplayList::AnimationStyle *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Style *a3, const RB::DisplayList::CachedTransform *a4)
{
  if (a3)
    this = a3;
  return (*(uint64_t (**)(RB::DisplayList::AnimationStyle *, _QWORD))(*(_QWORD *)this + 24))(this, *(_QWORD *)a4);
}

_QWORD *RB::DisplayList::AnimationStyle::encode(RB::DisplayList::AnimationStyle *this, RB::Encoder *a2)
{
  unint64_t v4;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x5AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  if (*((_DWORD *)this + 22))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Animation::encode((_QWORD *)this + 7, a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::encode_data(a2, (char *)this + 96, 0x10uLL);
  v4 = *((unsigned int *)this + 28);
  if ((_DWORD)v4 != 273)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::AnimationStyle::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  _OWORD *v7;
  uint64_t v8;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *(_DWORD *)(a1 + 112) = RB::ProtobufDecoder::uint_field(this, v5);
      }
      else if ((_DWORD)v6 == 2)
      {
        v7 = (_OWORD *)RB::ProtobufDecoder::data_field(this, v5);
        if (v8 == 16)
          *(_OWORD *)(a1 + 96) = *v7;
      }
      else if ((_DWORD)v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::Animation::decode(a1 + 56, this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::AnimationStyle::print(RB::DisplayList::AnimationStyle *this, std::string *a2)
{
  uint64_t v4;
  int v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  char out[40];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  RB::SexpString::push(a2, "animation");
  if (*((_DWORD *)this + 28) != 273)
    RB::SexpString::printf(a2, 0, "(flags 0x%x)", *((_DWORD *)this + 28));
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)this + 96, out);
  RB::SexpString::printf(a2, 1, "(id %s)", out);
  if (*((_DWORD *)this + 22))
  {
    RB::XML::Document::Document((RB::XML::Document *)&v6);
    RB::Animation::xml_elements((uint64_t)this + 56, (RB::XML::Document *)&v6);
    RB::XML::Document::print_children((RB::XML::Document *)&v6, a2, 0);
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v8);
    if (v7)
      free(v7);
    v4 = v6;
    if (v6)
    {
      v5 = *(_DWORD *)(v6 + 8) - 1;
      *(_DWORD *)(v6 + 8) = v5;
      if (!v5)
        (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    }
  }
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

void sub_209B932BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, ...)
{
  va_list va;

  va_start(va, a3);
  RB::XML::Document::~Document((RB::XML::Document *)va);
  _Unwind_Resume(a1);
}

double RB::DisplayList::State::add_animation(__n128 *this, RB::DisplayList::Builder *a2, const RB::Animation *a3, UUID *a4, int a5)
{
  RB::DisplayList::Style *v7;
  double result;
  int v9;
  const RB::Animation *v10;

  v10 = a3;
  v9 = a5;
  v7 = RB::Heap::emplace<RB::DisplayList::AnimationStyle,RB::Animation const*,RB::UUID const&,unsigned int const&>((size_t *)(*((_QWORD *)a2 + 1) + 16), &v10, a4, &v9);
  *(_QWORD *)&result = RB::DisplayList::State::add_style(this, a2, v7).n128_u64[0];
  return result;
}

uint64_t RB::DisplayList::find_animation(RB::DisplayList *this, const RB::DisplayList::Item *a2, const RB::DisplayList::Item *a3)
{
  uint64_t i;
  uint64_t v5;
  RB::DisplayList *v6;
  unsigned int v7;
  int v8;
  uint64_t result;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  if (this && a2)
  {
    for (i = *((_QWORD *)this + 2); i; i = *(_QWORD *)(i + 32))
    {
      if ((*(_BYTE *)(i + 52) & 1) == 0)
        break;
    }
    v5 = *((_QWORD *)a2 + 2);
    if (!v5)
      return 0;
    while ((*(_BYTE *)(v5 + 52) & 1) != 0)
    {
      v5 = *(_QWORD *)(v5 + 32);
      if (!v5)
        return 0;
    }
    if (!i)
      return 0;
LABEL_29:
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)i + 16))(i) == 7)
    {
      v10 = v5;
LABEL_31:
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v10 + 16))(v10) != 7
        || !RB::same_identity<RB::DisplayList::Style>(i, v10))
      {
        while (1)
        {
          v10 = *(_QWORD *)(v10 + 32);
          if (!v10)
            break;
          if ((*(_BYTE *)(v10 + 52) & 1) == 0)
            goto LABEL_31;
        }
      }
      if (v10)
        v5 = v10;
      v12 = i;
      v11 = i;
      i = v10;
      goto LABEL_51;
    }
    if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v5 + 16))(v5) == 7)
    {
      v11 = i;
LABEL_38:
      if ((*(unsigned int (**)(uint64_t))(*(_QWORD *)v11 + 16))(v11) != 7
        || !RB::same_identity<RB::DisplayList::Style>(i, v11))
      {
        while (1)
        {
          v11 = *(_QWORD *)(v11 + 32);
          if (!v11)
            break;
          if ((*(_BYTE *)(v11 + 52) & 1) == 0)
            goto LABEL_38;
        }
      }
      if (v11)
        v12 = v11;
      else
        v12 = i;
      if (v11)
      {
LABEL_51:
        if (i)
        {
          if ((*(_DWORD *)(i + 112) & 0xF00) == 0x100)
          {
            v13 = v11 + 96;
            if (uuid_is_null((const unsigned __int8 *)v13) || uuid_is_null((const unsigned __int8 *)(i + 96)))
              return i + 56;
            if (*(_QWORD *)v13 != *(_QWORD *)(i + 96) || *(_QWORD *)(v13 + 8) != *(_QWORD *)(i + 104))
              return i + 56;
          }
          else if ((*(_DWORD *)(i + 112) & 0xF00) == 0x200)
          {
            return i + 56;
          }
        }
      }
    }
    else
    {
      v12 = i;
    }
    for (i = *(_QWORD *)(v12 + 32); i; i = *(_QWORD *)(i + 32))
    {
      if ((*(_BYTE *)(i + 52) & 1) == 0)
        break;
    }
    while (1)
    {
      v5 = *(_QWORD *)(v5 + 32);
      if (!v5)
        return 0;
      if ((*(_BYTE *)(v5 + 52) & 1) == 0)
      {
        result = 0;
        if (i)
          goto LABEL_29;
        return result;
      }
    }
  }
  if (this)
    v6 = this;
  else
    v6 = a2;
  if (v6)
  {
    i = *((_QWORD *)v6 + 2);
    if (i)
    {
      while ((*(_BYTE *)(i + 52) & 1) != 0)
      {
        i = *(_QWORD *)(i + 32);
        if (!i)
          return 0;
      }
LABEL_20:
      if ((*(unsigned int (**)(uint64_t, const RB::DisplayList::Item *, const RB::DisplayList::Item *))(*(_QWORD *)i + 16))(i, a2, a3) != 7)goto LABEL_18;
      v7 = *(_DWORD *)(i + 112);
      if (!a2)
        LOBYTE(v7) = v7 >> 4;
      v8 = v7 & 0xF;
      if (v8 != 1)
      {
        if (v8 != 2)
          goto LABEL_18;
        return i + 56;
      }
      if (uuid_is_null((const unsigned __int8 *)(i + 96)))
        return i + 56;
LABEL_18:
      while (1)
      {
        i = *(_QWORD *)(i + 32);
        if (!i)
          break;
        if ((*(_BYTE *)(i + 52) & 1) == 0)
          goto LABEL_20;
      }
    }
  }
  return 0;
}

float RB::DisplayList::CrossFadeStyle::copy(RB::DisplayList::CrossFadeStyle *this, RB::DisplayList::Builder *a2)
{
  uint64_t v4;
  uint64_t v6;

  v6 = 0;
  v4 = *((_QWORD *)this + 7);
  if (v4)
    v6 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, uint64_t))(*(_QWORD *)v4 + 24))(v4, a2, 4);
  return RB::Heap::emplace<RB::DisplayList::CrossFadeStyle,RB::DisplayList::Item *&,float const&,float const&>((RB::Heap *)(*((_QWORD *)a2 + 1) + 16), &v6, (float *)this + 16, (int *)this + 17);
}

float RB::Heap::emplace<RB::DisplayList::CrossFadeStyle,RB::DisplayList::Item *&,float const&,float const&>(RB::Heap *this, uint64_t *a2, float *a3, int *a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  float result;
  int v12;

  v8 = *((_QWORD *)this + 3);
  v9 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 72 > v8)
    v9 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v9 + 72;
  v10 = *a2;
  result = *a3;
  v12 = *a4;
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_QWORD *)v9 = &off_24C227D78;
  *(_QWORD *)(v9 + 48) = 0;
  *(_QWORD *)(v9 + 56) = v10;
  *(float *)(v9 + 64) = result;
  *(_DWORD *)(v9 + 68) = v12;
  return result;
}

uint64_t RB::DisplayList::CrossFadeStyle::apply_transform(RB::DisplayList::CrossFadeStyle *this, const RB::DisplayList::CachedTransform *a2)
{
  uint64_t result;

  result = *((_QWORD *)this + 7);
  if (result)
    return (*(uint64_t (**)(uint64_t, const RB::DisplayList::CachedTransform *))(*(_QWORD *)result + 32))(result, a2);
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::CrossFadeStyle::draw(RB::DisplayList::CrossFadeStyle *this, RB::DisplayList::Builder *a2, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  uint64_t v10;
  uint64_t v11;
  float v12;
  float32x2_t v19;
  float32x2_t v20;
  uint64_t v21;
  int v22;
  size_t *v23;
  uint64_t v24;
  float v26;
  int v27;
  RB::DisplayList::Layer *layer;
  int v29;

  v10 = *((_QWORD *)this + 7);
  if (v10)
  {
    v11 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, uint64_t))(*(_QWORD *)v10 + 24))(v10, a2, 4);
    RB::DisplayList::Item::apply_alpha(v11, 1.0 - *((float *)this + 16));
  }
  else
  {
    v11 = 0;
  }
  v12 = *((float *)this + 17);
  if (v12 == 0.0)
  {
    v26 = 0.0;
  }
  else
  {
    _H0 = *((_WORD *)a4 + 22);
    __asm { FCVT            S0, H0 }
    if (_S0 != 1.0)
      v12 = _S0 / v12;
    v26 = v12;
    v19 = vrecpe_f32((float32x2_t)LODWORD(v12));
    v20 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v12), v19), v19);
    RB::DisplayList::Item::apply_alpha((uint64_t)a4, *((float *)this + 16) * vmul_f32(v20, vrecps_f32((float32x2_t)LODWORD(v12), v20)).f32[0]);
  }
  *((_QWORD *)a4 + 2) = *((_QWORD *)this + 4);
  if (v11)
  {
    v29 = *((_WORD *)a4 + 23) & 0x3F;
    v21 = *((_QWORD *)a4 + 4);
    v22 = *((_DWORD *)a4 + 10);
    *(_WORD *)(v11 + 46) = *(_WORD *)(v11 + 46) & 0xFFC0 | 2;
    *(_QWORD *)(v11 + 32) = 0;
    *(_DWORD *)(v11 + 40) = 0;
    *((_WORD *)a4 + 23) = *((_WORD *)a4 + 23) & 0xFFC0 | 0xB;
    *((_QWORD *)a4 + 4) = 0;
    *((_DWORD *)a4 + 10) = 0;
    layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(a2, 0);
    RB::DisplayList::Builder::draw(a2, (RB::DisplayList::Item *)v11, layer, 0);
    RB::DisplayList::Builder::draw(a2, a4, layer, 0);
    v23 = (size_t *)(*((_QWORD *)a2 + 1) + 16);
    v27 = 1;
    RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(v23, &v27, &v29, (uint64_t *)&layer);
    a4 = (RB::DisplayList::Item *)v24;
    *(_QWORD *)(v24 + 32) = v21;
    *(_DWORD *)(v24 + 40) = v22;
  }
  RB::DisplayList::Item::apply_alpha((uint64_t)a4, v26);
  *((_QWORD *)a4 + 3) = RB::DisplayList::Builder::join_clip_lists((uint64_t)a2, *((_QWORD **)a4 + 3), *((const RB::DisplayList::ClipNode **)this + 3));
  return RB::DisplayList::Builder::draw(a2, a4, a3, a5);
}

uint64_t RB::DisplayList::CrossFadeStyle::prepare_encode(RB::DisplayList::CrossFadeStyle *this, RB::Encoder *a2)
{
  uint64_t result;

  RB::DisplayList::Style::prepare_encode(this, a2);
  result = *((_QWORD *)this + 7);
  if (result)
    return (*(uint64_t (**)(uint64_t, RB::Encoder *))(*(_QWORD *)result + 240))(result, a2);
  return result;
}

_QWORD *RB::DisplayList::CrossFadeStyle::encode(RB::DisplayList::CrossFadeStyle *this, RB::Encoder *a2)
{
  int v4;
  int v5;

  RB::DisplayList::Style::encode(this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x72uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  if (*((_QWORD *)this + 7))
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(_QWORD, RB::Encoder *))(**((_QWORD **)this + 7) + 248))(*((_QWORD *)this + 7), a2);
    RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v4 = *((int *)this + 16);
  if (*(float *)&v4 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  v5 = *((int *)this + 17);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::DisplayList::CrossFadeStyle::decode(RB::DisplayList::CrossFadeStyle *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;
  RB::Decoder *v7;
  uint64_t v8;
  uint64_t v9;
  void (***v10)(_QWORD);

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *((float *)this + 17) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if ((_DWORD)v6 == 2)
      {
        *((float *)this + 16) = RB::ProtobufDecoder::float_field(a2, v5);
      }
      else if ((_DWORD)v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(a2);
          v8 = RB::DisplayList::Item::decode(a2, v7);
          if (v8)
          {
            v9 = v8;
            v10 = (void (***)(_QWORD))*((_QWORD *)this + 7);
            *((_QWORD *)this + 7) = v9;
            if (v10)
              (**v10)(v10);
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::DisplayList::CrossFadeStyle::print(RB::DisplayList::CrossFadeStyle *this, std::string *a2)
{
  float v4;

  RB::SexpString::push(a2, "cross-fade");
  RB::SexpString::printf(a2, 0, "(t %g)", *((float *)this + 16));
  v4 = *((float *)this + 17);
  if (v4 != 1.0)
    RB::SexpString::printf(a2, 0, "(to-alpha %g)", v4);
  if (*((_QWORD *)this + 7))
  {
    RB::SexpString::push(a2, "from");
    (*(void (**)(_QWORD, std::string *))(**((_QWORD **)this + 7) + 256))(*((_QWORD *)this + 7), a2);
    RB::SexpString::pop(a2);
  }
  RB::DisplayList::Style::print((const RB::AffineTransform **)this, a2);
  RB::SexpString::pop(a2);
}

float32x2_t *RB::DisplayList::Style::dod(float32x2_t *this, float32x2_t *a2, float64x2_t *a3)
{
  float32x2_t *v5;
  float32x2_t *v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;

  if (this)
  {
    v5 = this;
    do
    {
      this = (float32x2_t *)(*(uint64_t (**)(float32x2_t *, float32x2_t *, float64x2_t *))(*(_QWORD *)v5 + 56))(v5, a2, a3);
      v6 = (float32x2_t *)v5[3];
      if (v6)
      {
        RB::Rect::move_identity(a2, a3);
        this = RB::Rect::intersect(a2, v6[2], v6[3], v7, v8, v9, v10);
      }
      v5 = (float32x2_t *)v5[4];
    }
    while (v5);
  }
  return this;
}

RB::DisplayList::AnimationStyle *RB::DisplayList::Style::decode(RB::Heap **this, RB::Decoder *a2)
{
  RB::DisplayList::AnimationStyle *v3;
  RB::DisplayList::AnimationStyle *v4;
  unint64_t field;
  uint64_t v6;
  RB::Heap *v7;
  RB::Decoder *v8;
  unsigned int *v9;
  RB::DisplayList::AnimationStyle *v10;
  RB::DisplayList::AnimationStyle *v11;
  unint64_t i;
  char v13;
  unint64_t v14;
  __n128 v15;
  __n128 v16;
  unint64_t v17;
  unint64_t v18;
  void (***v19)(_QWORD, __n128);
  void *v20;
  const void **v21;
  unint64_t j;
  unint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unint64_t v27;
  char v28;
  __n128 *v29;
  __n128 *v30;
  unint64_t v31;
  unint64_t v32;
  RB::DisplayList::AnimationStyle *v33;
  __n128 v34;
  unint64_t v35;
  unint64_t v36;
  RB::DisplayList::AnimationStyle *v37;
  __n128 *v38;
  RB::DisplayList::AnimationStyle *v39;
  RB::DisplayList::AnimationStyle *v40;
  unint64_t k;
  RB::DisplayList::AnimationStyle *v42;
  RB::DisplayList::AnimationStyle *v43;
  RB::DisplayList::AnimationStyle *v44;
  RB::DisplayList::AnimationStyle *v45;
  RB::DisplayList::AnimationStyle *v46;
  RB::DisplayList::AnimationStyle *v47;
  RB::DisplayList::AnimationStyle *v48;
  RB::DisplayList::AnimationStyle *v49;
  RB::DisplayList::AnimationStyle *v50;
  RB::DisplayList::AnimationStyle *v51;
  unint64_t m;
  __n128 *v53;
  __n128 *v54;
  __n128 *v55;
  __n128 *v56;
  __n128 *v57;
  __n128 *v58;
  RB::DisplayList::AnimationStyle *v59;
  uint64_t v60;
  uint64_t v62;
  _BYTE v63[12];
  _OWORD v64[2];
  uint64_t v65;
  uint64_t v66;
  __n128 v67;
  _QWORD v68[4];
  __int128 v69;
  __int128 v70;
  void *v71;
  unint64_t v72;
  uint64_t v73;
  __int128 v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  uint64_t v78;

  v3 = 0;
  v62 = 0;
  v78 = *MEMORY[0x24BDAC8D0];
  v64[0] = xmmword_209BD5290;
  v64[1] = xmmword_209BD52A0;
  v65 = 0;
  v66 = 0;
  memset(v63, 0, sizeof(v63));
  while (1)
  {
    v4 = v3;
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    v6 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) != 2)
          goto LABEL_153;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::AffineTransform::decode((RB::AffineTransform *)v64, (RB::ProtobufDecoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        continue;
      case 2u:
        v62 = RB::Decoder::shared_field_f<RB::DisplayList::ClipNode,RB::DisplayList::ClipNode const* RB::Decoder::shared_field<RB::DisplayList::ClipNode>(RB::ProtobufDecoder::Field,RB::Encoder::SharedType)::{lambda(RB::DisplayList::ClipNode&)#1}>((RB::ProtobufDecoder *)this, field, 4, (uint64_t)&v67);
        goto LABEL_7;
      case 3u:
        v7 = this[9];
        if (v7 && (v8 = (RB::Decoder *)(*(uint64_t (**)(RB::Heap *))(*(_QWORD *)v7 + 32))(v7)) != 0)
        {
          if ((v6 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
            RB::DisplayList::decode_metadata((RB::DisplayList *)this, v8, (RB::DisplayList::Contents *)&v63[4], (const RB::DisplayList::Metadata **)v63, v9);
            RB::ProtobufDecoder::end_message((uint64_t)this);
            v3 = v4;
          }
          else
          {
LABEL_153:
            *((_BYTE *)this + 56) = 1;
            *this = this[1];
LABEL_7:
            v3 = v4;
          }
        }
        else
        {
          RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v6);
          v3 = v4;
        }
        continue;
      case 4u:
        RB::Heap::emplace<RB::DisplayList::ShadowStyle>(this[8]);
        v3 = v10;
        if ((v6 & 7) != 2)
          goto LABEL_151;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::ShadowStyle::decode((uint64_t)v3, (RB::ProtobufDecoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_144;
      case 5u:
        RB::Heap::emplace<RB::DisplayList::PathProjectionStyle>(this[8]);
        v3 = v11;
        if ((v6 & 7) != 2)
          goto LABEL_151;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::PathProjectionStyle::decode((float64x2_t *)v3, (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_144;
      case 6u:
        if ((field & 7) != 2)
          goto LABEL_153;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
              ;
              i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this))
        {
          v13 = i;
          if (!i)
            break;
          switch((i >> 3))
          {
            case 1u:
              v67.n128_u32[0] = 0;
              RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v67.n128_i8[8]);
              if ((v13 & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::ColorMatrix::decode(&v67, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
              v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>(this[8], (uint64_t)&v67);
              goto LABEL_54;
            case 2u:
              v67.n128_u32[0] = 0;
              v68[0] = 0;
              v68[1] = 0;
              *(_QWORD *)((char *)&v68[1] + 6) = 0;
              *(_DWORD *)((char *)&v68[2] + 6) = 15360;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::LuminanceCurve::decode(&v67, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
              v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>(this[8], (uint64_t)&v67);
              goto LABEL_54;
            case 3u:
              v67.n128_u32[0] = 0;
              v68[2] = 0;
              v67.n128_u64[1] = 0;
              v68[0] = 0;
              LODWORD(v68[1]) = 0;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::GaussianBlur::decode((RB::Filter::GaussianBlur *)&v67, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
              v16 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>(this[8], (uint64_t)&v67);
              v18 = v17;
              if (v4)
                (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v16);
              v19 = (void (***)(_QWORD, __n128))v68[2];
              v68[2] = 0;
              if (v19)
                (**v19)(v19, v16);
              goto LABEL_56;
            case 4u:
              v67.n128_u32[0] = 0;
              v67.n128_u64[1] = 0;
              v71 = 0;
              v72 = 0;
              v73 = 4;
              v74 = xmmword_209BD5290;
              v75 = xmmword_209BD52A0;
              v76 = 0u;
              v77 = 0u;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::Custom::decode(&v67, (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
              v18 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom const&,RB::DisplayList::Builder &>((size_t *)this[8], (uint64_t)&v67);
              if (v4)
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              v20 = v71;
              if (v71)
                v21 = (const void **)v71;
              else
                v21 = (const void **)v68;
              if (v72)
              {
                for (j = 0; j < v72; ++j)
                {
                  RB::CustomShader::Value::reset_data(v21);
                  v21 += 3;
                }
                v20 = v71;
              }
              if (v20)
                free(v20);
              v23 = v67.n128_u64[1];
              if (v67.n128_u64[1])
              {
                v24 = (unsigned int *)(v67.n128_u64[1] + 8);
                do
                {
                  v25 = __ldxr(v24);
                  v26 = v25 - 1;
                }
                while (__stlxr(v26, v24));
                if (!v26)
                {
                  __dmb(9u);
                  (*(void (**)(unint64_t))(*(_QWORD *)v23 + 8))(v23);
                }
              }
              goto LABEL_56;
            case 5u:
              v67.n128_u32[0] = 0;
              memset(v68, 0, sizeof(v68));
              v69 = 0u;
              v70 = 0u;
              if ((i & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::Filter::RGBACurves::decode(&v67, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
              v15 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>(this[8], (uint64_t)&v67);
LABEL_54:
              v18 = v14;
              if (v4)
                (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v15);
LABEL_56:
              v4 = (RB::DisplayList::AnimationStyle *)v18;
              break;
            default:
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, i);
              break;
          }
        }
        goto LABEL_146;
      case 7u:
        if ((field & 7) != 2)
          goto LABEL_153;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        v27 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        while (2)
        {
          v28 = v27;
          if (v27)
          {
            switch((v27 >> 3))
            {
              case 1u:
                RB::Heap::emplace<RB::DisplayList::ProjectionStyle>(this[8]);
                v30 = v29;
                if ((v28 & 7) != 2)
                  goto LABEL_85;
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::ProjectionMatrix::decode((uint64_t)&v30[3].n128_i64[1], (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
                goto LABEL_80;
              case 2u:
                v67.n128_u64[0] = 0;
                RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect>>(this[8]);
                v32 = v31;
                v67.n128_u64[0] = v31;
                if ((v28 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::AlphaThresholdEffect::decode((float *)(v32 + 16), (RB::ProtobufDecoder *)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
                }
                else
                {
                  *((_BYTE *)this + 56) = 1;
                  *this = this[1];
                }
                v34.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::AlphaThresholdStyle,RB::DisplayList::GenericEffect<RB::AlphaThresholdEffect> *&>(this[8], (uint64_t *)&v67);
                goto LABEL_75;
              case 3u:
                v67.n128_u64[0] = 0;
                RB::Heap::emplace<RB::DisplayList::GenericEffect<RB::AlphaGradientEffect>>(this[8]);
                v36 = v35;
                v67.n128_u64[0] = v35;
                if ((v28 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::AlphaGradientEffect::decode((RB::AlphaGradientEffect *)(v36 + 16), (RB::Decoder *)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
                }
                else
                {
                  *((_BYTE *)this + 56) = 1;
                  *this = this[1];
                }
                v34.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::AlphaGradientStyle,RB::DisplayList::GenericEffect<RB::AlphaGradientEffect> *&>(this[8], (uint64_t *)&v67);
LABEL_75:
                v37 = v33;
                if (v4)
                  (**(void (***)(RB::DisplayList::AnimationStyle *, __n128))v4)(v4, v34);
                v4 = v37;
                goto LABEL_84;
              case 4u:
                RB::Heap::emplace<RB::DisplayList::CustomEffectStyle>(this[8]);
                v30 = v38;
                if ((v28 & 7) == 2)
                {
                  RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                  RB::DisplayList::CustomEffectStyle::decode(v30, (size_t **)this);
                  RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_80:
                  if (v4)
                    goto LABEL_81;
                }
                else
                {
LABEL_85:
                  *((_BYTE *)this + 56) = 1;
                  *this = this[1];
                  if (v4)
LABEL_81:
                    (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
                }
                v4 = (RB::DisplayList::AnimationStyle *)v30;
LABEL_84:
                v27 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
                continue;
              default:
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, v27);
                goto LABEL_84;
            }
          }
          break;
        }
LABEL_146:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        v3 = v4;
        break;
      case 8u:
        RB::Heap::emplace<RB::DisplayList::PredicateStyle>(this[8]);
        v3 = v39;
        if ((v6 & 7) != 2)
          goto LABEL_151;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::InvertiblePredicate::decode((RB::DisplayList::AnimationStyle *)((char *)v3 + 56), (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_144;
      case 9u:
        RB::Heap::emplace<RB::DisplayList::TransformStyle>(this[8]);
        v3 = v40;
        if ((v6 & 7) != 2)
          goto LABEL_151;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::Transform::decode((RB::DisplayList::AnimationStyle *)((char *)v3 + 56), (RB::Decoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_144;
      case 0xAu:
        if ((field & 7) != 2)
          goto LABEL_153;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (k = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this); k; v4 = v3)
        {
          switch((k >> 3))
          {
            case 1u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>>(this[8]);
              v43 = v42;
              if ((k & 7) != 2)
                goto LABEL_119;
              goto LABEL_97;
            case 2u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>>(this[8]);
              v43 = v46;
              if ((k & 7) != 2)
                goto LABEL_119;
LABEL_97:
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::ColorMultiply::decode((_DWORD *)v43 + 14, (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_115;
            case 3u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>>(this[8]);
              v43 = v44;
              if ((k & 7) == 2)
                goto LABEL_114;
              goto LABEL_119;
            case 4u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>>(this[8]);
              v43 = v47;
              if ((k & 7) == 2)
                goto LABEL_114;
              goto LABEL_119;
            case 5u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>>(this[8]);
              v43 = v45;
              if ((k & 7) == 2)
                goto LABEL_114;
              goto LABEL_119;
            case 6u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>>(this[8]);
              v43 = v48;
              if ((k & 7) == 2)
                goto LABEL_114;
              goto LABEL_119;
            case 7u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>>(this[8]);
              v43 = v49;
              if ((k & 7) != 2)
                goto LABEL_119;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::LuminanceToAlpha::decode((_DWORD *)v43 + 14, (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_115;
            case 8u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>>(this[8]);
              v43 = v50;
              if ((k & 7) != 2)
                goto LABEL_119;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::ColorStyle::ColorMonochrome::decode((uint64_t)v43 + 56, (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_115;
            case 9u:
              RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>>(this[8]);
              v43 = v51;
              if ((k & 7) == 2)
              {
LABEL_114:
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::ColorStyle::HueRotation::decode((uint64_t)v43 + 56, (RB::ProtobufDecoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
LABEL_119:
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
LABEL_115:
              v3 = v43;
              if (v4)
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              break;
            default:
              v3 = v4;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, k);
              break;
          }
          k = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        }
        goto LABEL_149;
      case 0xBu:
        v3 = RB::Heap::emplace<RB::DisplayList::AnimationStyle>((size_t *)this[8]);
        if ((v6 & 7) != 2)
          goto LABEL_151;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        RB::DisplayList::AnimationStyle::decode((uint64_t)v3, (RB::ProtobufDecoder *)this);
        RB::ProtobufDecoder::end_message((uint64_t)this);
        goto LABEL_144;
      case 0xDu:
        if ((field & 7) != 2)
          goto LABEL_153;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
        for (m = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this); m; v4 = v3)
        {
          switch((m >> 3))
          {
            case 1u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>>(this[8]);
              v54 = v53;
              if ((m & 7) != 2)
                goto LABEL_141;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Rotation::decode((uint64_t)&v54[3].n128_i64[1], (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_137;
            case 2u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>>(this[8]);
              v54 = v55;
              if ((m & 7) != 2)
                goto LABEL_141;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Scale::decode(&v54[3].n128_u64[1], (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_137;
            case 3u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>>(this[8]);
              v54 = v56;
              if ((m & 7) != 2)
                goto LABEL_141;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Rotation3D::decode(v54 + 4, (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_137;
            case 4u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>>(this[8]);
              v54 = v57;
              if ((m & 7) != 2)
                goto LABEL_141;
              RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
              RB::GeometryStyle::Translation::decode(&v54[3].n128_u64[1], (RB::ProtobufDecoder *)this);
              RB::ProtobufDecoder::end_message((uint64_t)this);
              goto LABEL_137;
            case 5u:
              RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>>(this[8]);
              v54 = v58;
              if ((m & 7) == 2)
              {
                RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
                RB::GeometryStyle::Affine::decode((RB::GeometryStyle::Affine *)&v54[4], (RB::Decoder *)this);
                RB::ProtobufDecoder::end_message((uint64_t)this);
              }
              else
              {
LABEL_141:
                *((_BYTE *)this + 56) = 1;
                *this = this[1];
              }
LABEL_137:
              v3 = (RB::DisplayList::AnimationStyle *)v54;
              if (v4)
                (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
              break;
            default:
              v3 = v4;
              RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, m);
              break;
          }
          m = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
        }
LABEL_149:
        RB::ProtobufDecoder::end_message((uint64_t)this);
        continue;
      case 0xEu:
        RB::Heap::emplace<RB::DisplayList::CrossFadeStyle>(this[8]);
        v3 = v59;
        if ((v6 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RB::DisplayList::CrossFadeStyle::decode(v3, (RB::Decoder *)this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
LABEL_144:
          if (v4)
          {
LABEL_145:
            (**(void (***)(RB::DisplayList::AnimationStyle *))v4)(v4);
            continue;
          }
        }
        else
        {
LABEL_151:
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
          if (v4)
            goto LABEL_145;
        }
        continue;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        continue;
    }
  }
  if (v3)
  {
    RB::Decoder::emplace<RB::AffineTransform,RB::AffineTransform&>((uint64_t)this, (uint64_t)v64);
    *((_QWORD *)v3 + 2) = v60;
    *((_QWORD *)v3 + 3) = v62;
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
  return v3;
}

void sub_209B9499C(_Unwind_Exception *a1)
{
  void (***v1)(_QWORD);

  (**v1)(v1);
  _Unwind_Resume(a1);
}

__n128 RB::Decoder::emplace<RB::AffineTransform,RB::AffineTransform&>(uint64_t a1, uint64_t a2)
{
  size_t *v3;
  unint64_t v4;
  __n128 result;
  __int128 v6;

  v3 = *(size_t **)(a1 + 64);
  v4 = (v3[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v4 + 48 > v3[3])
    v4 = RB::Heap::alloc_slow(v3, 0x30uLL, 15);
  else
    v3[2] = v4 + 48;
  result = *(__n128 *)a2;
  v6 = *(_OWORD *)(a2 + 32);
  *(_OWORD *)(v4 + 16) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v4 + 32) = v6;
  *(__n128 *)v4 = result;
  return result;
}

uint64_t RB::DisplayList::Style::can_mix(RB::DisplayList::Style *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Style *a3)
{
  return 0;
}

void RB::DisplayList::ShadowStyle::~ShadowStyle(RB::DisplayList::ShadowStyle *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ShadowStyle::type_id(RB::DisplayList::ShadowStyle *this)
{
  return 0;
}

void RB::DisplayList::CrossFadeStyle::~CrossFadeStyle(RB::DisplayList::CrossFadeStyle *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v2)
    (**v2)(v2);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 7);
  *((_QWORD *)this + 7) = 0;
  if (v2)
    (**v2)(v2);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::CrossFadeStyle::type_id(RB::DisplayList::CrossFadeStyle *this)
{
  return 10;
}

void RB::DisplayList::ProjectionStyle::~ProjectionStyle(RB::DisplayList::ProjectionStyle *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::type_id()
{
  return 24582;
}

double RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::copy(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)&result = RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a1 + 56).n128_u64[0];
  return result;
}

RB::DisplayList::Builder *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::draw(uint64_t a1, size_t **this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  __int128 v5;
  _OWORD v7[2];
  int v8;

  *((_QWORD *)a4 + 2) = *(_QWORD *)(a1 + 32);
  v5 = *(_OWORD *)(a1 + 72);
  v7[0] = *(_OWORD *)(a1 + 56);
  v7[1] = v5;
  v8 = *(_DWORD *)(a1 + 88);
  return RB::DisplayList::Builder::projection_style_draw(this, a3, a4, a5, (const RB::ProjectionMatrix *)v7, *(float64x2_t **)(a1 + 16), *(const RB::DisplayList::ClipNode **)(a1 + 24));
}

float32x2_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::map_roi(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  __int128 v3;
  uint32x2_t v4;
  float32x2_t result;
  const RB::ProjectionMatrix *v7;
  _OWORD v8[2];
  int v9;

  v3 = *(_OWORD *)(a1 + 72);
  v8[0] = *(_OWORD *)(a1 + 56);
  v8[1] = v3;
  v9 = *(_DWORD *)(a1 + 88);
  v4 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&this[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  result = (float32x2_t)vpmax_u32(v4, v4);
  if ((result.i32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
    if (!RB::unapply(this, (RB::Rect *)v8, v7))
    {
      result = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      *this = (float32x2_t)0x100000001000000;
      this[1] = result;
    }
  }
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::map_dod(uint64_t a1, float32x2_t *this, float64x2_t *a3, uint64_t a4, const RB::AffineTransform *a5)
{
  __int128 v5;
  _OWORD v6[2];
  int v7;

  v5 = *(_OWORD *)(a1 + 72);
  v6[0] = *(_OWORD *)(a1 + 56);
  v6[1] = v5;
  v7 = *(_DWORD *)(a1 + 88);
  RB::DisplayList::projection_style_dod(this, a3, (RB::AffineTransform *)v6, *(float64x2_t **)(a1 + 16), a5);
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a3 && RB::ProjectionMatrix::operator==((float *)(a1 + 56), (float *)(a3 + 56)))
    return 4;
  else
    return 1;
}

uint64_t RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;
  uint64_t v7;
  float32x4_t *v8;
  float32x4_t *v9;

  RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)a4 + 8) + 16), a1 + 56);
  v7 = v6;
  v8 = (float32x4_t *)(v6 + 56);
  if (a3)
    v9 = (float32x4_t *)(a3 + 56);
  else
    v9 = 0;
  RB::GeometryStyle::Projection::mix(v8, v9, *(float *)(a2 + 16));
  return v7;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "geometry");
  RB::GeometryStyle::Projection::print((RB::GeometryStyle::Projection *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

void RB::DisplayList::PathProjectionStyle::~PathProjectionStyle(RB::DisplayList::PathProjectionStyle *this)
{
  RBPathRelease(*((_QWORD *)this + 12), *((_QWORD *)this + 13));
}

{
  RBPathRelease(*((_QWORD *)this + 12), *((_QWORD *)this + 13));
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::PathProjectionStyle::type_id(RB::DisplayList::PathProjectionStyle *this)
{
  return 1;
}

void RB::DisplayList::AlphaThresholdStyle::~AlphaThresholdStyle(RB::DisplayList::AlphaThresholdStyle *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::AlphaThresholdStyle::type_id(RB::DisplayList::AlphaThresholdStyle *this)
{
  return 11;
}

void RB::DisplayList::AlphaGradientStyle::~AlphaGradientStyle(RB::DisplayList::AlphaGradientStyle *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::AlphaGradientStyle::type_id(RB::DisplayList::AlphaGradientStyle *this)
{
  return 12;
}

void RB::DisplayList::CustomEffectStyle::~CustomEffectStyle(RB::DisplayList::CustomEffectStyle *this)
{
  RB::DisplayList::Layer *v2;
  void *v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  v3 = (void *)*((_QWORD *)this + 20);
  if (v3)
    v4 = (const void **)*((_QWORD *)this + 20);
  else
    v4 = (const void **)((char *)this + 64);
  if (*((_QWORD *)this + 21))
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((_QWORD *)this + 21));
    v3 = (void *)*((_QWORD *)this + 20);
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)*((_QWORD *)this + 7);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
}

{
  RB::DisplayList::Layer *v2;
  void *v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 23);
  *((_QWORD *)this + 23) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  v3 = (void *)*((_QWORD *)this + 20);
  if (v3)
    v4 = (const void **)*((_QWORD *)this + 20);
  else
    v4 = (const void **)((char *)this + 64);
  if (*((_QWORD *)this + 21))
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((_QWORD *)this + 21));
    v3 = (void *)*((_QWORD *)this + 20);
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)*((_QWORD *)this + 7);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::CustomEffectStyle::type_id(RB::DisplayList::CustomEffectStyle *this)
{
  return 13;
}

void RB::DisplayList::PredicateStyle::~PredicateStyle(RB::DisplayList::PredicateStyle *this)
{
  void *v2;
  RB::DisplayList::Predicate::Term *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
    v3 = (RB::DisplayList::Predicate::Term *)*((_QWORD *)this + 10);
  else
    v3 = (RB::DisplayList::PredicateStyle *)((char *)this + 56);
  if (*((_DWORD *)this + 22))
  {
    v4 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v3);
      ++v4;
      v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
    }
    while (v4 < *((unsigned int *)this + 22));
    v2 = (void *)*((_QWORD *)this + 10);
  }
  if (v2)
    free(v2);
}

{
  void *v2;
  RB::DisplayList::Predicate::Term *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
    v3 = (RB::DisplayList::Predicate::Term *)*((_QWORD *)this + 10);
  else
    v3 = (RB::DisplayList::PredicateStyle *)((char *)this + 56);
  if (*((_DWORD *)this + 22))
  {
    v4 = 0;
    do
    {
      RB::DisplayList::Predicate::Term::~Term(v3);
      ++v4;
      v3 = (RB::DisplayList::Predicate::Term *)(v5 + 24);
    }
    while (v4 < *((unsigned int *)this + 22));
    v2 = (void *)*((_QWORD *)this + 10);
  }
  if (v2)
    free(v2);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::PredicateStyle::type_id(RB::DisplayList::PredicateStyle *this)
{
  return 3;
}

uint64_t RB::DisplayList::TransformStyle::type_id(RB::DisplayList::TransformStyle *this)
{
  return 4;
}

uint64_t RB::DisplayList::AnimationStyle::type_id(RB::DisplayList::AnimationStyle *this)
{
  return 7;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::~GeometryMatrixStyle()
{
  JUMPOUT(0x20BD16544);
}

_QWORD *RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>::encode(_QWORD *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode(a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x6AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::GeometryStyle::Projection::encode((RB::GeometryStyle::Projection *)(a1 + 7), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

RB::DisplayList::TransformStyle *RB::DisplayList::TransformStyle::TransformStyle(RB::DisplayList::TransformStyle *this, const RB::DisplayList::Transform *a2)
{
  char *v3;
  const RB::DisplayList::Transform::Term *v4;
  unsigned int v5;
  unsigned int v6;
  char *v7;
  uint64_t v8;
  RB::DisplayList::Transform::Term *v9;
  uint64_t v10;
  int v11;

  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_QWORD *)this = &off_24C227E88;
  v3 = (char *)this + 56;
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0x100000000;
  if (*((_QWORD *)a2 + 4))
    v4 = (const RB::DisplayList::Transform::Term *)*((_QWORD *)a2 + 4);
  else
    v4 = a2;
  v5 = *((_DWORD *)a2 + 10);
  v6 = v5;
  if (v5 >= 2)
  {
    RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow((char *)this + 56, v5);
    v7 = (char *)*((_QWORD *)this + 11);
    v8 = *((unsigned int *)this + 24);
  }
  else
  {
    if (!v5)
    {
      v11 = 0;
      goto LABEL_13;
    }
    v7 = 0;
    v8 = 0;
  }
  if (!v7)
    v7 = v3;
  v9 = (RB::DisplayList::Transform::Term *)&v7[32 * v8];
  do
  {
    v10 = RB::DisplayList::Transform::Term::Term(v9, v4);
    v4 = (const RB::DisplayList::Transform::Term *)((char *)v4 + 32);
    v9 = (RB::DisplayList::Transform::Term *)(v10 + 32);
    --v6;
  }
  while (v6);
  v11 = *((_DWORD *)this + 24);
LABEL_13:
  *((_DWORD *)this + 24) = v11 + v5;
  return this;
}

void sub_209B952D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  RB::DisplayList::Transform::Term *v2;
  void *v4;
  RB::DisplayList::Transform::Term *v5;
  unint64_t v6;
  uint64_t v7;

  v4 = *(void **)(v1 + 88);
  if (v4)
    v5 = *(RB::DisplayList::Transform::Term **)(v1 + 88);
  else
    v5 = v2;
  if (*(_DWORD *)(v1 + 96))
  {
    v6 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v5);
      ++v6;
      v5 = (RB::DisplayList::Transform::Term *)(v7 + 32);
    }
    while (v6 < *(unsigned int *)(v1 + 96));
    v4 = *(void **)(v1 + 88);
  }
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::DisplayList::Style const*,64ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 131) + (*((_DWORD *)__dst + 131) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 131) + (*((_DWORD *)__dst + 131) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 64), __dst, 0x40u, (_DWORD *)__dst + 131, v3);
  *((_QWORD *)__dst + 64) = result;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ShadowStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 96;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2261D0;
  *(_QWORD *)(v3 + 64) = 0x3F00000000000000;
  *(_QWORD *)(v3 + 72) = 0x3C00000000000000;
  *(_WORD *)(v3 + 80) = 0;
  *(_QWORD *)&result = 2;
  *(_QWORD *)(v3 + 84) = 2;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ProjectionStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 96;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_DWORD *)(v3 + 88) = 1065353216;
  *(_QWORD *)&result = 1065353216;
  *(_OWORD *)(v3 + 72) = xmmword_209BD5460;
  *(_OWORD *)(v3 + 56) = xmmword_209BD5460;
  *(_QWORD *)v3 = &off_24C227F10;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::CustomEffectStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 232 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0xE8uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 232;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_OWORD *)(v3 + 48) = 0u;
  *(_QWORD *)v3 = &off_24C228460;
  *(_OWORD *)(v3 + 160) = 0u;
  *(_QWORD *)(v3 + 176) = 4;
  *(_OWORD *)(v3 + 184) = 0u;
  *(_OWORD *)(v3 + 200) = 0u;
  *(_OWORD *)(v3 + 212) = 0u;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::PredicateStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 104 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 104;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C227E00;
  *(_QWORD *)(v3 + 80) = 0;
  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(v3 + 88) = 0x100000000;
  *(_BYTE *)(v3 + 96) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::TransformStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 104 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 104;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C227E88;
  *(_QWORD *)(v3 + 88) = 0;
  *(_QWORD *)&result = 0x100000000;
  *(_QWORD *)(v3 + 96) = 0x100000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 72;
  *(_QWORD *)(v3 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228240;
  *(_DWORD *)(v3 + 56) = 0;
  *(_QWORD *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 72;
  *(_QWORD *)(v3 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2281B8;
  *(_DWORD *)(v3 + 56) = 0;
  *(_QWORD *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228130;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228020;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0x3F80000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C227F98;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2283D8;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0x3F80000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  *(_QWORD *)(v3 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228350;
  *(_DWORD *)(v3 + 56) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 80 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 80;
  *(_QWORD *)(v3 + 48) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2282C8;
  *(_DWORD *)(v3 + 56) = 0;
  *(_QWORD *)(v3 + 60) = 0x3C003C003C003C00;
  *(_WORD *)(v3 + 68) = 0;
  *(_QWORD *)(v3 + 72) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2280A8;
  return result;
}

RB::DisplayList::AnimationStyle *RB::Heap::emplace<RB::DisplayList::AnimationStyle>(size_t *a1)
{
  RB::DisplayList::AnimationStyle *v1;

  v1 = (RB::DisplayList::AnimationStyle *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v1 + 120 > a1[3])
    v1 = (RB::DisplayList::AnimationStyle *)RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  else
    a1[2] = (size_t)v1 + 120;
  return RB::DisplayList::AnimationStyle::AnimationStyle(v1);
}

RB::DisplayList::AnimationStyle *RB::DisplayList::AnimationStyle::AnimationStyle(RB::DisplayList::AnimationStyle *this)
{
  *((_QWORD *)this + 6) = 0;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *(_QWORD *)this = &off_24C227CF0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0x600000000;
  uuid_clear((unsigned __int8 *)this + 96);
  *((_DWORD *)this + 28) = 273;
  return this;
}

void sub_209B959C0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 80);
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 72;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228680;
  __asm { FMOV            V0.2S, #1.0 }
  *(double *)(v3 + 56) = result;
  *(_QWORD *)(v3 + 64) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 72;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C228708;
  *(_QWORD *)(v3 + 64) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 64 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x40uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 64;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2241D8;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 128 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  else
    *((_QWORD *)this + 2) = v3 + 128;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C2285F8;
  *(_QWORD *)(v3 + 64) = 0;
  result = 0.0;
  *(_OWORD *)(v3 + 80) = xmmword_209BD95B0;
  *(_QWORD *)(v3 + 96) = 0;
  *(_QWORD *)(v3 + 104) = 0;
  *(_QWORD *)(v3 + 112) = 0x7FC0000000000000;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v3 + 112 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x70uLL, 15);
  else
    *((_QWORD *)this + 2) = v3 + 112;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C224260;
  result = 1.0;
  *(_OWORD *)(v3 + 64) = xmmword_209BD5290;
  *(_OWORD *)(v3 + 80) = xmmword_209BD52A0;
  *(_QWORD *)(v3 + 96) = 0;
  *(_QWORD *)(v3 + 104) = 0;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::CrossFadeStyle>(RB::Heap *this)
{
  unint64_t v2;
  unint64_t v3;
  double result;

  v2 = *((_QWORD *)this + 3);
  v3 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 72 > v2)
    v3 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v3 + 72;
  *(_QWORD *)(v3 + 48) = 0;
  *(_QWORD *)(v3 + 56) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C227D78;
  result = 0.0078125;
  *(_QWORD *)(v3 + 64) = 0x3F80000000000000;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Projection>,RB::GeometryStyle::Projection const&>(RB::Heap *this, uint64_t a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;
  __int128 v7;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x60uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 96;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224150;
  result = *(__n128 *)a2;
  v7 = *(_OWORD *)(a2 + 16);
  *(_DWORD *)(v5 + 88) = *(_DWORD *)(a2 + 32);
  *(_OWORD *)(v5 + 72) = v7;
  *(__n128 *)(v5 + 56) = result;
  return result;
}

int32x2_t *RB::render_masks_coverage(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, char a6, float a7)
{
  int32x2_t *v13;
  uint64_t v14;
  __int32 v15;
  __int32 v16;
  RB::Buffer *v17;
  float32x2_t v18;
  uint64_t v24;
  float32x2_t v25;
  RB::Buffer *v26;
  int64x2_t v27;

  if (a5)
  {
    _S8 = a7;
    v13 = result;
    v14 = result[17].i32[0] == 2;
    v25 = (float32x2_t)result[14];
    v15 = result[15].i32[0];
    result[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)result, *(RB::Buffer **)a4);
    v13[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    v16 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, a5);
    v13[26].i32[1] = 0;
    v13[27].i32[0] = 0;
    v13[26].i32[0] = v16;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v13, (RB::Device *)0x20, 4uLL, 0, &v26);
    v17 = v26;
    if (v26)
    {
      v18 = vneg_f32(v25);
      v18.i32[0] = 0;
      __asm { FCVT            H2, S8 }
      v24 = *((_QWORD *)v26 + 7) + v27.i64[0];
      *(_QWORD *)v24 = v25.u32[0];
      *(float32x2_t *)(v24 + 8) = v18;
      *(_QWORD *)(v24 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v24 + 24) = v15;
      *(_WORD *)(v24 + 28) = _H2;
    }
    else
    {
      v26 = 0;
      v27 = 0uLL;
    }
    v13[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v13, v17);
    *(int32x2_t *)((char *)v13 + 188) = vmovn_s64(v27);
    result = RB::RenderPass::draw_indexed_primitives(v13, (const char *)((v14 << 33) | ((a6 & 0x3F) << 6) | 0xAu), 4, ***(_QWORD ***)v13 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v13[24] + 4) = 0;
    *(int32x2_t *)((char *)&v13[25] + 4) = 0;
    *(int32x2_t *)((char *)&v13[26] + 4) = 0;
  }
  return result;
}

void sub_209B95E48(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, uint64_t a6, unsigned int a7, char a8)
{
  int32x2_t *v14;
  _BOOL8 v15;
  uint16x4_t v16;
  __int32 v17;
  int v18;
  RB::Buffer *v19;
  __int32 v20;
  RB::Buffer *v21;
  float32x2_t v22;
  uint64_t v23;
  float16x4_t v24;
  int16x4_t v25;
  float16x4_t v26;
  float32x2_t v27;
  RB::Buffer *v28;
  int64x2_t v29;

  if (a5)
  {
    v14 = result;
    v15 = result[17].i32[0] == 2;
    v16 = (uint16x4_t)result[14];
    v27 = (float32x2_t)v16;
    v17 = result[15].i32[0];
    if (*(_BYTE *)(a6 + 9) && (v18 = result[15].u8[4], *(unsigned __int8 *)(a6 + 8) != v18))
    {
      v28 = *(RB::Buffer **)a6;
      v29.i16[0] = *(_WORD *)(a6 + 8);
      RB::Fill::Color::convert((uint64_t)&v28, v18, v16);
      v24.i16[3] = 15360;
      v24.i32[0] = (int)v28;
      v24.i16[2] = WORD2(v28);
      v26 = v24;
      LODWORD(v19) = (unint64_t)v28 >> 48;
    }
    else
    {
      v19 = *(RB::Buffer **)a6;
      WORD2(v19) = *(_WORD *)(a6 + 4);
      HIWORD(v19) = unk_209BD95D0;
      v26 = (float16x4_t)v19;
      LOWORD(v19) = *(_WORD *)(a6 + 6);
    }
    v25 = (int16x4_t)v19;
    v14[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v14, *(RB::Buffer **)a4);
    v14[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    v20 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v14, a5);
    v14[26].i32[1] = 0;
    v14[27].i32[0] = 0;
    v14[26].i32[0] = v20;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v14, (RB::Device *)0x24, 4uLL, 0, &v28);
    v21 = v28;
    if (v28)
    {
      v22 = vneg_f32(v27);
      v22.i32[0] = 0;
      v23 = *((_QWORD *)v28 + 7) + v29.i64[0];
      *(_QWORD *)v23 = v27.u32[0];
      *(float32x2_t *)(v23 + 8) = v22;
      *(_QWORD *)(v23 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v23 + 24) = v17;
      *(float16x4_t *)(v23 + 28) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v25, 0)), vcvtq_f32_f16(v26)));
    }
    else
    {
      v28 = 0;
      v29 = 0uLL;
    }
    v14[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v14, v21);
    *(int32x2_t *)((char *)v14 + 188) = vmovn_s64(v29);
    result = RB::RenderPass::draw_indexed_primitives(v14, (const char *)(((a8 & 0x3F) << 6) | 0xBu | ((a7 | (unint64_t)(2 * v15)) << 32)), 4, ***(_QWORD ***)v14 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v14[24] + 4) = 0;
    *(int32x2_t *)((char *)&v14[25] + 4) = 0;
    *(int32x2_t *)((char *)&v14[26] + 4) = 0;
  }
  return result;
}

void sub_209B96084(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, float64x2_t *a6, float32x2_t *a7, __int32 a8, double a9, char a10)
{
  float v10;
  uint64_t v17;
  _BOOL4 v18;
  int8x8_t v19;
  int8x8_t v20;
  float32x2_t v21;
  float32x2_t v22;
  int v23;
  RB::Buffer *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  int8x8_t v30;
  __int128 v31;
  _OWORD v32[4];
  int v33;
  RB::Buffer *v34;
  int64x2_t v35;

  if (a5)
  {
    v10 = *(float *)&a9;
    v17 = (uint64_t)result;
    RB::Fill::Gradient::set_gradient(a7, (uint64_t)v32 + 12, (uint64_t)result, a6, a9);
    v18 = *(_DWORD *)(v17 + 136) == 2;
    v30.i32[0] = 12;
    v30.i32[1] = 2 * v18;
    RB::Fill::Gradient::set_fill_state(a7, (int *)&v30, v17, v10);
    v19.i32[0] = (a10 & 0x3F) << 6;
    v19.i32[1] = a8;
    v20 = vorr_s8(vand_s8(v30, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v19);
    v21 = *(float32x2_t *)(v17 + 112);
    v22 = vneg_f32(v21);
    v22.i32[0] = 0;
    v30 = v20;
    *(_QWORD *)&v31 = v21.u32[0];
    *((float32x2_t *)&v31 + 1) = v22;
    *(_QWORD *)&v32[0] = 0x3F800000BF800000;
    DWORD2(v32[0]) = *(_DWORD *)(v17 + 120);
    *(_DWORD *)(v17 + 196) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, *(RB::Buffer **)a4);
    *(int32x2_t *)(v17 + 200) = vmovn_s64(*(int64x2_t *)(a4 + 8));
    v23 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, a5);
    *(_DWORD *)(v17 + 212) = 0;
    *(_DWORD *)(v17 + 216) = 0;
    *(_DWORD *)(v17 + 208) = v23;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v17, (RB::Device *)0x54, 4uLL, 0, &v34);
    v24 = v34;
    if (v34)
    {
      v25 = *((_QWORD *)v34 + 7) + v35.i64[0];
      v26 = v31;
      *(_OWORD *)(v25 + 16) = v32[0];
      v28 = v32[2];
      v27 = v32[3];
      v29 = v32[1];
      *(_DWORD *)(v25 + 80) = v33;
      *(_OWORD *)(v25 + 48) = v28;
      *(_OWORD *)(v25 + 64) = v27;
      *(_OWORD *)(v25 + 32) = v29;
      *(_OWORD *)v25 = v26;
    }
    else
    {
      v34 = 0;
      v35 = 0uLL;
    }
    *(_DWORD *)(v17 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v17, v24);
    *(int32x2_t *)(v17 + 188) = vmovn_s64(v35);
    result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)v17, *(const char **)&v30, 4, ***(_QWORD ***)v17 + 80, 0, a3, *a2, a2[1]);
    *(_DWORD *)(v17 + 228) = 0;
    *(_OWORD *)(v17 + 196) = 0u;
    *(_OWORD *)(v17 + 212) = 0u;
  }
  return result;
}

void sub_209B96280(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5, int8x8_t *a6, uint64_t a7, __int32 a8, char a9)
{
  int32x2_t *v15;
  _BOOL4 v16;
  int8x8_t v17;
  __int32 v18;
  RB::Buffer *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  int8x8_t v26;
  RB::Buffer *v27;
  int64x2_t v28;

  if (a5)
  {
    v15 = result;
    v16 = result[17].i32[0] == 2;
    v26.i32[0] = 13;
    v26.i32[1] = 2 * v16;
    RB::RenderState::set_image((int *)&v26, (uint64_t)&a6[3] + 4, result[15].u8[4]);
    v17.i32[0] = (a9 & 0x3F) << 6;
    v17.i32[1] = a8;
    v26 = vorr_s8(vand_s8(v26, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v17);
    *a6 = (int8x8_t)*(_QWORD *)&v15[14];
    v17.i32[0] = 0;
    *(float *)&v17.i32[1] = -*(float *)&v15[14].i32[1];
    a6[1] = v17;
    a6[2] = (int8x8_t)0x3F800000BF800000;
    a6[3].i32[0] = v15[15].i32[0];
    v15[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, *(RB::Buffer **)a4);
    v15[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    v18 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, a5);
    v15[26].i32[1] = 0;
    v15[27].i32[0] = 0;
    v15[26].i32[0] = v18;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v15, (RB::Device *)0x70, 4uLL, 0, &v27);
    v19 = v27;
    if (v27)
    {
      v20 = (_OWORD *)(*((_QWORD *)v27 + 7) + v28.i64[0]);
      v21 = *(_OWORD *)a6[4].i8;
      v22 = *(_OWORD *)a6->i8;
      v20[1] = *(_OWORD *)a6[2].i8;
      v20[2] = v21;
      v23 = *(_OWORD *)a6[12].i8;
      v25 = *(_OWORD *)a6[6].i8;
      v24 = *(_OWORD *)a6[8].i8;
      v20[5] = *(_OWORD *)a6[10].i8;
      v20[6] = v23;
      v20[3] = v25;
      v20[4] = v24;
      *v20 = v22;
    }
    else
    {
      v27 = 0;
      v28 = 0uLL;
    }
    v15[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v15, v19);
    *(int32x2_t *)((char *)v15 + 188) = vmovn_s64(v28);
    result = RB::RenderPass::draw_indexed_primitives(v15, *(const char **)&v26, 4, ***(_QWORD ***)v15 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v15[24] + 4) = 0;
    *(int32x2_t *)((char *)&v15[25] + 4) = 0;
    *(int32x2_t *)((char *)&v15[26] + 4) = 0;
  }
  return result;
}

void sub_209B96458(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

void sub_209B96534(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

char *RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(char *a1)
{
  char *v2;
  char *v3;
  unint64_t v4;
  id *v5;

  v2 = (char *)*((_QWORD *)a1 + 8);
  if (v2)
    v3 = v2;
  else
    v3 = a1;
  if (*((_QWORD *)a1 + 9))
  {
    v4 = 0;
    v5 = (id *)(v3 + 8);
    do
    {

      ++v4;
      v5 += 2;
    }
    while (v4 < *((_QWORD *)a1 + 9));
    v2 = (char *)*((_QWORD *)a1 + 8);
  }
  if (v2)
    free(v2);
  return a1;
}

void sub_209B97378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  RB::Symbol::Presentation::~Presentation((RB::Symbol::Presentation *)va);
  _Unwind_Resume(a1);
}

void sub_209B9742C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

double RBSymbolUpdateBoundingRect(RB::Symbol::Presentation *a1, double a2, double a3, float64x2_t a4, int32x4_t a5)
{
  double v5;
  int32x4_t v6;
  float32x2_t v7;
  uint32x2_t v8;
  int32x4_t v9;
  double result;

  v5 = RB::Symbol::Presentation::bounding_rect(a1, a2, a3, a4, a5);
  v6.i32[0] = 0;
  v8 = (uint32x2_t)vcgtz_f32(v7);
  *(uint32x2_t *)v9.i8 = vpmin_u32(v8, v8);
  *(_QWORD *)&result = vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_s32(v6, v9), 0), (int8x16_t)vcvtq_f64_f32(*(float32x2_t *)&v5), *MEMORY[0x24BDBF070]).u64[0];
  return result;
}

double RBSymbolUpdateMaxVelocity(uint64_t a1)
{
  return *(float *)(a1 + 920);
}

float RBSymbolUpdateLayerColor(_QWORD *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  v2 = *(_QWORD *)(*a1 + 840);
  if (!v2)
    v2 = *a1 + 8;
  v3 = a1[2];
  v4 = *(_QWORD **)(v2 + 416 * v1 + 400);
  if (v4)
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  v5 = v2 + 416 * v1;
  v6 = v5 + 16;
  v7 = *(_QWORD *)(v5 + 376);
  if (!v7)
    v7 = v6;
  return *(float *)(v7 + 120 * v3 + 8);
}

float RBSymbolUpdateLayerErasingOpacity(_DWORD *a1)
{
  uint64_t v1;
  unsigned int v2;
  _DWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  float result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  float v19;

  v1 = *(_QWORD *)a1 + 8;
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~a1[2];
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v1 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v3 = (_DWORD *)*((_QWORD *)a1 + 2);
  v4 = *(_QWORD **)(v1 + 416 * v2 + 400);
  if (!v4)
    goto LABEL_6;
  v3 = (_DWORD *)(*v4 + 8 * *((_QWORD *)a1 + 2));
  v5 = v3[1];
  result = 0.0;
  if (!(_DWORD)v5)
    return result;
  LODWORD(v3) = *v3;
  if ((_DWORD)v5 != 1)
  {
    v12 = v1 + 416 * v2;
    v13 = v12 + 16;
    v14 = *(_QWORD *)(v12 + 376);
    if (!v14)
      v14 = v13;
    while (1)
    {
      v15 = v3;
      v16 = *(_QWORD *)(v14 + 120 * v3);
      if ((*(_BYTE *)(v16 + 86) & 0x40) != 0)
      {
        v17 = *(float *)(v16 + 72);
        v18 = v14 + 120 * v15;
        v19 = v17 <= 0.0 ? *(float *)(v18 + 32) * *(float *)(v18 + 28) : *(float *)(v18 + 32);
        if (v19 > 0.0)
          break;
      }
      LODWORD(v3) = v15 + 1;
      if (!--v5)
        return result;
    }
    return 1.0;
  }
  else
  {
LABEL_6:
    v7 = v1 + 416 * v2;
    v8 = v7 + 16;
    v9 = *(_QWORD *)(v7 + 376);
    if (!v9)
      v9 = v8;
    v10 = *(_QWORD *)(v9 + 120 * v3);
    result = 0.0;
    if ((*(_BYTE *)(v10 + 86) & 0x40) != 0)
    {
      v11 = v9 + 120 * v3;
      if (*(float *)(v10 + 72) <= 0.0)
        return *(float *)(v11 + 32) * *(float *)(v11 + 28);
      else
        return *(float *)(v11 + 32);
    }
  }
  return result;
}

uint64_t RBSymbolUpdateLayerDefaultColor(_QWORD *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  v2 = *(_QWORD *)(*a1 + 840);
  if (!v2)
    v2 = *a1 + 8;
  v3 = a1[2];
  v4 = *(_QWORD **)(v2 + 416 * v1 + 400);
  if (v4)
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  v5 = v2 + 416 * v1;
  v6 = v5 + 16;
  v7 = *(_QWORD *)(v5 + 376);
  if (!v7)
    v7 = v6;
  v8 = *(_QWORD *)(v7 + 120 * v3);
  if ((*(_DWORD *)(v8 + 84) & 0xF00) == 0x900)
    return *(_QWORD *)(v8 + 16);
  else
    return 0;
}

float RBSymbolUpdateLayerModelColor(_QWORD *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  v2 = *(_QWORD *)(*a1 + 840);
  if (!v2)
    v2 = *a1 + 8;
  v3 = a1[2];
  v4 = *(_QWORD **)(v2 + 416 * v1 + 400);
  if (v4)
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  v5 = v2 + 416 * v1;
  v6 = v5 + 16;
  v7 = *(_QWORD *)(v5 + 376);
  if (!v7)
    v7 = v6;
  return *(float *)(v7 + 120 * v3 + 8);
}

uint64_t RBSymbolUpdateLayerClip(uint64_t a1, _RBDrawingState *a2, int a3, char a4, float a5)
{
  RB::Symbol::Presentation *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  _DWORD *v11;
  unint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  float32x2_t *v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  uint64_t v26;
  float64x2_t v27;
  __int128 v28;
  __int128 v29;
  _RBDrawingState *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  uint64_t v34;
  unsigned int v35;
  uint64_t v36;
  float32x2_t *v37;
  float v38;
  float v39;
  uint64_t v40;
  float64x2_t v41;
  __int128 v42;
  __int128 v43;
  uint64_t v44;
  unsigned int *v46;
  uint64_t v47;
  unsigned int v48;
  unsigned int v49;
  _BOOL4 v51;
  uint64_t v52;
  float32x2_t v53;
  float64x2_t v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;

  v7 = *(RB::Symbol::Presentation **)a1;
  v8 = *(_QWORD *)a1 + 8;
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v47 = v8;
  v48 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~*(_DWORD *)(a1 + 8);
  v9 = v8 + 416 * v48;
  v10 = *(_QWORD **)(v9 + 400);
  if (v10)
  {
    v11 = (_DWORD *)(*v10 + 8 * *(_QWORD *)(a1 + 16));
    LODWORD(v52) = *v11;
    v49 = v11[1];
    v51 = v49 > 1;
  }
  else
  {
    v52 = *(_QWORD *)(a1 + 16);
    v51 = 0;
    v49 = 1;
  }
  v57 = *((_QWORD *)a2 + 21);
  if ((a4 & 1) != 0)
  {
    v12 = v52 + v49;
    v13 = v8 + 416 * v48;
    v14 = *(_DWORD *)(v13 + 384);
    if (v12 < v14)
    {
      v46 = (unsigned int *)(v13 + 384);
      v15 = v47 + 416 * v48;
      v16 = v15 + 16;
      v17 = (uint64_t *)(v15 + 376);
      v18 = 120 * (v52 + v49);
      do
      {
        if (*v17)
          v19 = *v17;
        else
          v19 = v16;
        v20 = (float32x2_t *)(v19 + v18);
        v21 = *(_QWORD *)(v19 + v18);
        if ((*(_BYTE *)(v21 + 86) & 0x40) != 0)
        {
          v22 = *(float *)(v21 + 72);
          v23 = v19 + v18;
          v24 = v22 <= 0.0 ? *(float *)(v23 + 32) * *(float *)(v23 + 28) : *(float *)(v23 + 32);
          if (v24 > 0.0)
          {
            RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)(v19 + v18), a2, (RB::Symbol::Model **)v9);
            v25 = v19 + v18;
            v26 = *(_QWORD *)(v19 + v18);
            v27.f64[0] = RB::Symbol::Presentation::Layer::transform(v20, (uint64_t)v7);
            v54 = v27;
            v55 = v28;
            v56 = v29;
            LODWORD(v28) = 0;
            DWORD1(v28) = *(_DWORD *)(v25 + 52);
            RB::Symbol::Glyph::Layer::clip(v26, (RB::DisplayList::State *)a2, 1, &v54, v7, v24, *(float32x2_t *)&v28);
            v14 = *v46;
          }
        }
        ++v12;
        v18 += 120;
      }
      while (v12 < v14);
    }
  }
  v30 = a2;
  if (v49 >= 2)
    v30 = (_RBDrawingState *)RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
  if (v52 < v52 + v49)
  {
    v31 = v47 + 416 * v48;
    v32 = v31 + 16;
    v33 = (uint64_t *)(v31 + 376);
    v34 = 120 * v52;
    v35 = v49;
    do
    {
      v36 = *v33;
      if (!*v33)
        v36 = v32;
      v37 = (float32x2_t *)(v36 + v34);
      v38 = a5;
      if (v51)
      {
        v39 = 0.0;
        if ((*(_BYTE *)(*(_QWORD *)v37 + 86) & 0x40) != 0)
        {
          v40 = v36 + v34;
          if (*(float *)(*(_QWORD *)v37 + 72) <= 0.0)
            v39 = *(float *)(v40 + 32) * *(float *)(v40 + 28);
          else
            v39 = *(float *)(v40 + 32);
        }
        v38 = v39 * a5;
      }
      v41.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, (uint64_t)v7);
      v54 = v41;
      v55 = v42;
      v56 = v43;
      LODWORD(v41.f64[0]) = 0;
      HIDWORD(v41.f64[0]) = v37[6].i32[1];
      v53 = *(float32x2_t *)&v41.f64[0];
      RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)v37, v30, (RB::Symbol::Model **)v9);
      v44 = (uint64_t)*v37;
      if (v30 == a2)
        RB::Symbol::Glyph::Layer::clip(v44, (RB::DisplayList::State *)a2, a3, &v54, v7, v38, v53);
      else
        RB::Symbol::Glyph::Layer::draw(v44, (RB::DisplayList::State *)v30, 0, &v54, v7, 1.0, 1.0, 1.0, 1.0, v38, v53);
      v34 += 120;
      --v35;
    }
    while (v35);
  }
  if (v49 > 1)
    RBDrawingStateClipLayer((uint64_t)a2, (RB::DisplayList::State *)v30, a3, 1.0);
  return RB::DisplayList::State::set_animation_layer((uint64_t)a2, &v57);
}

void std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    v2 = *(void **)(a2 + 24);
    if (v2)
      free(v2);
    JUMPOUT(0x20BD16544);
  }
}

void *RB::vector<objc_object  {objcproto24RBSymbolAnimatorObserver}*,2ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*((void **)__dst + 2), __dst, 2u, (_DWORD *)__dst + 7, v3);
  *((_QWORD *)__dst + 2) = result;
  return result;
}

void *RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 8), __dst, 4uLL, (size_t *)__dst + 10, v3);
  *((_QWORD *)__dst + 8) = result;
  return result;
}

_QWORD *std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>::pair[abi:nn180100](_QWORD *a1, id *a2)
{
  *a1 = *a2;
  a1[1] = a2[1];
  return a1;
}

void sub_209B97C40(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

int *RB::ColorStyle::Base::encode(int *this, RB::Encoder *a2)
{
  int *v3;
  int v4;

  v3 = this;
  v4 = *this;
  if ((*this & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
    this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v4 = *v3;
    if ((*v3 & 2) == 0)
    {
LABEL_3:
      if ((v4 & 4) == 0)
        return this;
LABEL_7:
      RB::ProtobufEncoder::encode_varint(a2, 0x50uLL);
      return (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
  }
  else if ((v4 & 2) == 0)
  {
    goto LABEL_3;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x48uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*v3 & 4) != 0)
    goto LABEL_7;
  return this;
}

uint64_t RB::ColorStyle::Base::decode_field(_DWORD *a1, RB::ProtobufDecoder *this, unint64_t a3)
{
  unint64_t v4;
  uint64_t result;
  int v6;
  BOOL v7;
  int v8;

  v4 = a3 >> 3;
  if ((a3 >> 3) == 10)
  {
    result = RB::ProtobufDecoder::BOOL_field(this, a3);
    v7 = (_DWORD)result == 0;
    v8 = 4;
LABEL_7:
    if (v7)
      v8 = 0;
    v6 = *a1 | v8;
    goto LABEL_11;
  }
  if ((_DWORD)v4 == 9)
  {
    result = RB::ProtobufDecoder::BOOL_field(this, a3);
    v7 = (_DWORD)result == 0;
    v8 = 2;
    goto LABEL_7;
  }
  if ((_DWORD)v4 == 8)
  {
    result = RB::ProtobufDecoder::BOOL_field(this, a3);
    v6 = *a1 | result;
LABEL_11:
    *a1 = v6;
    return result;
  }
  return (uint64_t)RB::ProtobufDecoder::skip_field(this, a3);
}

std::string *RB::ColorStyle::Base::print(std::string *this, std::string *a2)
{
  std::string *v3;
  const char *v4;

  v3 = this;
  if (((uint64_t)this->__r_.__value_.__l.__data_ & 1) != 0)
  {
    v4 = "linear";
  }
  else
  {
    if (((uint64_t)this->__r_.__value_.__l.__data_ & 2) == 0)
      goto LABEL_6;
    v4 = "non-linear";
  }
  this = RB::SexpString::print(a2, 0, v4);
LABEL_6:
  if ((v3->__r_.__value_.__s.__data_[0] & 4) != 0)
    return RB::SexpString::print(a2, 0, "premultiplied");
  return this;
}

double RB::ColorStyle::ColorMultiply::set_color_matrix(RB::ColorStyle::ColorMultiply *this, RB::ColorMatrix *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v5;
  unsigned __int8 v6;
  char *v7;
  unsigned int v8;
  __n64 v9;

  v5 = *(_DWORD *)this;
  if (*((_BYTE *)this + 13))
    v6 = *((_BYTE *)this + 12);
  else
    v6 = 1;
  v7 = (char *)this + 4;
  v8 = ((v5 & 2) << 7) | (v5 >> 1) & 1;
  if ((v5 & 1) != 0)
    v8 = 256;
  if (v8 >= 0x100)
    v6 = v8;
  v9.n64_u64[0] = RB::Fill::Color::prepare((uint64_t)v7, v6, (v5 >> 2) & 1, a3, a4).n64_u64[0];
  return RB::ColorMatrix::set_color(a2, v9.n64_f64[0]);
}

void RB::ColorStyle::ColorMultiply::mix(RB::ColorStyle::ColorMultiply *this, const RB::ColorStyle::ColorMultiply *a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  uint64_t v8;
  __int16 v9;

  if (a2)
  {
    v8 = *(_QWORD *)((char *)a2 + 4);
    v9 = *((_WORD *)a2 + 6);
  }
  else
  {
    v8 = 0x3C003C003C003C00;
    v9 = 0;
  }
  RB::Fill::Color::mix((float16x4_t *)((char *)this + 4), (float16x4_t *)&v8, 0, a3, a4, a5, a6, a7, a8);
}

_QWORD *RB::ColorStyle::ColorMultiply::encode(RB::ColorStyle::ColorMultiply *this, RB::Encoder *a2)
{
  RB::ColorStyle::Base::encode((int *)this, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::ColorStyle::ColorMultiply *)((char *)this + 4), a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

unint64_t RB::ColorStyle::ColorMultiply::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::Fill::Color::decode((uint64_t)(a1 + 1), this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else
      {
        RB::ColorStyle::Base::decode_field(a1, this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::ColorMultiply::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "color-multiply");
  RB::ColorStyle::Base::print(this, a2);
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

int8x8_t RB::ColorStyle::AlphaMultiply::set_color_matrix(RB::ColorStyle::AlphaMultiply *this, int8x8_t *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v5;
  unsigned __int8 v6;
  char *v7;
  unsigned int v8;
  int v9;
  __n64 v10;

  v5 = *(_DWORD *)this;
  if (*((_BYTE *)this + 13))
    v6 = *((_BYTE *)this + 12);
  else
    v6 = 1;
  v7 = (char *)this + 4;
  v8 = ((v5 & 2) << 7) | (v5 >> 1) & 1;
  if ((v5 & 1) != 0)
    v8 = 256;
  if (v8 >= 0x100)
    v6 = v8;
  v9 = (v5 >> 2) & 1;
  v10.n64_u64[0] = RB::Fill::Color::prepare((uint64_t)v7, v6, v9, a3, a4).n64_u64[0];
  return RB::ColorMatrix::set_alpha_multiply(a2, v9, (int8x8_t)v10.n64_u64[0]);
}

void RB::ColorStyle::AlphaMultiply::mix(RB::ColorStyle::AlphaMultiply *this, const RB::ColorStyle::AlphaMultiply *a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  float16x4_t v8;
  __int16 v9;

  if (a2)
  {
    v8 = *(float16x4_t *)((char *)a2 + 4);
    v9 = *((_WORD *)a2 + 6);
    RB::Fill::Color::mix((float16x4_t *)((char *)this + 4), &v8, 0, a3, a4, a5, a6, a7, a8);
  }
}

uint64_t RB::ColorStyle::AlphaMultiply::matches(RB::ColorStyle::AlphaMultiply *this, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::DisplayList::Predicate::matches_color(a2, (RB::ColorStyle::AlphaMultiply *)((char *)this + 4), a3);
}

void RB::ColorStyle::AlphaMultiply::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "alpha-multiply");
  RB::ColorStyle::Base::print(this, a2);
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

float RB::ColorStyle::HueRotation::mix(uint64_t a1, uint64_t a2, float a3)
{
  float v3;
  float result;

  if (a2)
    v3 = *(float *)(a2 + 4);
  else
    v3 = 0.0;
  result = *(float *)(a1 + 4) + (float)((float)(v3 - *(float *)(a1 + 4)) * a3);
  *(float *)(a1 + 4) = result;
  return result;
}

int *RB::ColorStyle::HueRotation::encode(RB::ColorStyle::HueRotation *this, RB::Encoder *a2)
{
  int *result;
  int v5;

  result = RB::ColorStyle::Base::encode((int *)this, a2);
  v5 = *((int *)this + 1);
  if (*(float *)&v5 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    return (int *)RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return result;
}

uint64_t RB::ColorStyle::HueRotation::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  uint64_t result;
  uint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 & 0x7FFFFFFF8) == 8)
        *(float *)(a1 + 4) = RB::ProtobufDecoder::float_field(this, v5);
      else
        RB::ColorStyle::Base::decode_field((_DWORD *)a1, this, v5);
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::HueRotation::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "hue-rotation");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(angle %g deg)", *((float *)this->__r_.__value_.__r.__words + 1) * 57.2957795);
  RB::SexpString::pop(a2);
}

float RB::ColorStyle::Saturation::mix(uint64_t a1, uint64_t a2, float a3)
{
  float v3;
  float result;

  if (a2)
    v3 = *(float *)(a2 + 4);
  else
    v3 = 1.0;
  result = *(float *)(a1 + 4) + (float)((float)(v3 - *(float *)(a1 + 4)) * a3);
  *(float *)(a1 + 4) = result;
  return result;
}

int *RB::ColorStyle::Saturation::encode(RB::ColorStyle::Saturation *this, RB::Encoder *a2)
{
  int *result;
  int v5;

  result = RB::ColorStyle::Base::encode((int *)this, a2);
  v5 = *((int *)this + 1);
  if (*(float *)&v5 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    return (int *)RB::ProtobufEncoder::encode_fixed32(a2, v5);
  }
  return result;
}

void RB::ColorStyle::Saturation::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "saturation");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::Brightness::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "brightness");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::Contrast::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "contrast");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

unint64_t RB::ColorStyle::LuminanceToAlpha::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      RB::ColorStyle::Base::decode_field(a1, this, v5);
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::LuminanceToAlpha::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "luminance-to-alpha");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::pop(a2);
}

double RB::ColorStyle::ColorMonochrome::set_color_matrix(RB::ColorStyle::ColorMonochrome *this, RB::ColorMatrix *a2, uint16x4_t a3, int8x8_t a4)
{
  unsigned int v6;
  unsigned __int8 v7;
  char *v8;
  unsigned int v9;
  unsigned __int32 v10;
  __n64 v11;
  int8x8_t v12;
  double v13;
  float32x4_t v14;
  double v15;
  float32x4_t v16;
  float32x4_t v17;
  double result;

  v6 = *(_DWORD *)this;
  if (*((_BYTE *)this + 13))
    v7 = *((_BYTE *)this + 12);
  else
    v7 = 1;
  v8 = (char *)this + 4;
  v9 = ((v6 & 2) << 7) | (v6 >> 1) & 1;
  if ((v6 & 1) != 0)
    v9 = 256;
  if (v9 >= 0x100)
    v7 = v9;
  v10 = *((_DWORD *)this + 4);
  v11.n64_u64[0] = RB::Fill::Color::prepare((uint64_t)v8, v7, (v6 >> 2) & 1, a3, a4).n64_u64[0];
  v12 = (int8x8_t)v11.n64_u64[0];
  v11.n64_u32[0] = v10;
  *(_QWORD *)&result = RB::ColorMatrix::set_color_monochrome(a2, v11.n64_f64[0], v12, *((float *)this + 5), v13, v14, v15, v16, v17);
  return result;
}

float RB::ColorStyle::ColorMonochrome::mix(RB::ColorStyle::ColorMonochrome *this, const RB::ColorStyle::ColorMonochrome *a2, int8x16_t a3, int8x16_t a4, double a5, double a6, double a7, int8x16_t a8)
{
  float v11;

  if (a2)
  {
    v11 = *(float *)a3.i32;
    RB::Fill::Color::mix((float16x4_t *)((char *)this + 4), (float16x4_t *)((char *)a2 + 4), 0, a3, a4, a5, a6, a7, a8);
    *(float32x2_t *)a3.i8 = vmla_n_f32(*(float32x2_t *)((char *)this + 16), vsub_f32(*(float32x2_t *)((char *)a2 + 16), *(float32x2_t *)((char *)this + 16)), v11);
    *((_QWORD *)this + 2) = a3.i64[0];
  }
  else
  {
    *(float *)a3.i32 = *((float *)this + 4) - (float)(*((float *)this + 4) * *(float *)a3.i32);
    *((_DWORD *)this + 4) = a3.i32[0];
  }
  return *(float *)a3.i32;
}

_QWORD *RB::ColorStyle::ColorMonochrome::encode(RB::ColorStyle::ColorMonochrome *this, RB::Encoder *a2)
{
  _QWORD *result;
  int v17;
  int v18;

  result = RB::ColorStyle::Base::encode((int *)this, a2);
  _H0 = *((_WORD *)this + 2);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_5;
  _H1 = *((_WORD *)this + 3);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    goto LABEL_5;
  _H0 = *((_WORD *)this + 4);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_5;
  _H1 = *((_WORD *)this + 5);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
  {
LABEL_5:
    RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::Fill::Color::encode((RB::ColorStyle::ColorMonochrome *)((char *)this + 4), a2);
    result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v17 = *((int *)this + 4);
  if (*(float *)&v17 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    result = RB::ProtobufEncoder::encode_fixed32(a2, v17);
  }
  v18 = *((int *)this + 5);
  if (*(float *)&v18 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, v18);
  }
  return result;
}

unint64_t RB::ColorStyle::ColorMonochrome::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = v5 >> 3;
      if ((v5 >> 3) == 3)
      {
        *(float *)(a1 + 20) = RB::ProtobufDecoder::float_field(this, v5);
      }
      else if ((_DWORD)v6 == 2)
      {
        *(float *)(a1 + 16) = RB::ProtobufDecoder::float_field(this, v5);
      }
      else if ((_DWORD)v6 == 1)
      {
        if ((v5 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message(this);
          RB::Fill::Color::decode(a1 + 4, this);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else
      {
        RB::ColorStyle::Base::decode_field((_DWORD *)a1, this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorStyle::ColorMonochrome::print(std::string *this, std::string *a2)
{
  float v4;

  RB::SexpString::push(a2, "color-monochrome");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *(float *)&this->__r_.__value_.__r.__words[2]);
  v4 = *((float *)&this->__r_.__value_.__r.__words[2] + 1);
  if (v4 != 0.0)
    RB::SexpString::printf(a2, 0, "(bias %g)", v4);
  RB::Fill::Color::print((RB::Fill::Color *)((char *)this->__r_.__value_.__r.__words + 4), a2);
  RB::SexpString::pop(a2);
}

void RB::ColorStyle::ColorInvert::print(std::string *this, std::string *a2)
{
  RB::SexpString::push(a2, "color-invert");
  RB::ColorStyle::Base::print(this, a2);
  RB::SexpString::printf(a2, 0, "(amount %g)", *((float *)this->__r_.__value_.__r.__words + 1));
  RB::SexpString::pop(a2);
}

uint64_t RB::Filter::GaussianBlur::GaussianBlur(uint64_t this, float a2, RB::DisplayList::Item *a3, const RB::Rect *a4, int a5)
{
  _OWORD *v5;
  int v6;

  *(float *)this = a2;
  v5 = (_OWORD *)(this + 8);
  if (a4)
  {
    *v5 = *(_OWORD *)a4;
    v6 = 256;
  }
  else
  {
    v6 = 0;
    *(_QWORD *)v5 = 0;
    *(_QWORD *)(this + 16) = 0;
  }
  *(_DWORD *)(this + 24) = v6 | a5;
  *(_QWORD *)(this + 32) = a3;
  return this;
}

RB::Filter::GaussianBlur *RB::Filter::GaussianBlur::GaussianBlur(RB::Filter::GaussianBlur *this, const RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  __int128 v4;
  RB::DisplayList::Layer **v5;
  uint64_t v6;
  uint64_t v8;
  RB::DisplayList::Layer *v9;
  BOOL v10;

  *(_DWORD *)this = *(_DWORD *)a2;
  v4 = *(_OWORD *)((char *)a2 + 8);
  *((_QWORD *)this + 4) = 0;
  v5 = (RB::DisplayList::Layer **)((char *)this + 32);
  *(_OWORD *)((char *)this + 8) = v4;
  *((_DWORD *)this + 6) = *((_DWORD *)a2 + 6);
  v6 = *((_QWORD *)a2 + 4);
  if (v6)
  {
    v8 = (*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, _QWORD))(*(_QWORD *)v6 + 24))(v6, a3, 0);
    v9 = *v5;
    *v5 = (RB::DisplayList::Layer *)v8;
    if (v9)
    {
      (**(void (***)(RB::DisplayList::Layer *))v9)(v9);
      v8 = (uint64_t)*v5;
    }
    if (v8)
      v10 = *((_BYTE *)a3 + 272) == 0;
    else
      v10 = 1;
    if (!v10)
      RB::DisplayList::Builder::simplify_item(a3, v5, 1);
  }
  return this;
}

void sub_209B98930(_Unwind_Exception *exception_object)
{
  void (****v1)(_QWORD);
  void (***v3)(_QWORD);

  v3 = *v1;
  *v1 = 0;
  if (v3)
    (**v3)(v3);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Filter::GaussianBlur::append(uint64_t a1, int a2, uint64_t a3)
{
  if (a2 != 5 || *(_DWORD *)(a1 + 24) != *(_DWORD *)(a3 + 24))
    return 0;
  *(float *)a1 = sqrtf((float)(*(float *)a3 * *(float *)a3) + (float)(*(float *)a1 * *(float *)a1));
  return 1;
}

float RB::Filter::GaussianBlur::layer_scale(RB::Filter::GaussianBlur *this, float a2)
{
  float v2;
  float v3;

  v2 = 1.0;
  if (!*((_QWORD *)this + 4))
  {
    v3 = 7.0;
    if ((*((_BYTE *)this + 24) & 0x20) == 0)
      v3 = 3.5;
    return fminf(v3 / (float)(*(float *)this * a2), 1.0);
  }
  return v2;
}

uint64_t RB::Filter::GaussianBlur::apply_transform(float32x2_t *this, float64x2_t *a2)
{
  float64x2_t *v4;
  float32x2_t v5;
  uint64_t result;

  v4 = a2 + 68;
  this->f32[0] = this->f32[0] * RB::AffineTransform::scale(a2 + 68);
  if ((this[3].i8[1] & 1) != 0)
  {
    this[1] = RB::operator*(v4, this[1], this[2]);
    this[2] = v5;
  }
  result = (uint64_t)this[4];
  if (result)
    return (*(uint64_t (**)(uint64_t, float64x2_t *, _QWORD))(*(_QWORD *)result + 32))(result, a2, 0);
  return result;
}

uint64_t RB::Filter::GaussianBlur::required_depth(uint64_t a1, unsigned int a2)
{
  unsigned int v2;

  if (a2 == 3)
    v2 = 2;
  else
    v2 = a2;
  if (a2 == 1)
    return 0;
  else
    return v2;
}

uint64_t RB::Filter::GaussianBlur::can_mix(float32x2_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  uint32x2_t v3;
  uint64_t v4;
  float32x2_t v5;
  float32x2_t v6;
  unsigned int type;
  _QWORD v9[3];
  int v10;
  uint64_t v11;
  int v12;

  if (a3)
  {
    if (this[3].i32[0] == a3[3].i32[0])
    {
      if (this->f32[0] == a3->f32[0]
        && (v3 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(this[2], a3[2]), (int8x8_t)vceq_f32(this[1], a3[1])),
            (vpmin_u32(v3, v3).u32[0] & 0x80000000) != 0))
      {
        v4 = 4;
      }
      else
      {
        v4 = 1;
      }
      v5 = this[4];
      v6 = a3[4];
      if (v5)
      {
        if (v6)
        {
          v9[1] = 0;
          v9[2] = 0;
          v9[0] = 0xFFFFFFF000000000;
          v10 = 0;
          v11 = 1;
          v12 = 0;
          (*(void (**)(float32x2_t, RB::DisplayList::Interpolator::Contents *, _QWORD *))(**(_QWORD **)&v5 + 208))(v5, a2, v9);
          type = RB::DisplayList::Interpolator::Op::get_type((RB::DisplayList::Interpolator::Op *)v9);
          if (type >= v4)
            return v4;
          else
            return type;
        }
      }
      else if (!*(_QWORD *)&v6)
      {
        return v4;
      }
    }
    return 0;
  }
  if (this->f32[0] == 0.0)
    return 4;
  else
    return 1;
}

float32_t RB::Filter::GaussianBlur::mix(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, const RB::DisplayList::CachedTransform *a4)
{
  float v6;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  void (***v15)(_QWORD);
  __int128 v17[2];
  uint64_t v18;
  uint64_t v19;
  _BYTE v20[8];
  uint64_t v21;
  uint64_t v22;
  _QWORD v23[15];

  v23[14] = *MEMORY[0x24BDAC8D0];
  v6 = this->f32[0];
  if (a3)
  {
    v8.i32[0] = *((_DWORD *)a2 + 4);
    this->f32[0] = v6 + (float)((float)(a3->f32[0] - v6) * v8.f32[0]);
    if ((this[3].i8[1] & 1) != 0)
    {
      v9 = this[1];
      v10 = a3[1];
      v11 = vadd_f32(this[2], v9);
      v12 = vmla_n_f32(v9, vsub_f32(v10, v9), v8.f32[0]);
      v8 = vsub_f32(vmla_n_f32(v11, vadd_f32(vsub_f32(v10, v11), a3[2]), v8.f32[0]), v12);
      this[1] = v12;
      this[2] = v8;
    }
    if (*(_QWORD *)&this[4] && *(_QWORD *)&a3[4])
    {
      v13 = *(_QWORD *)a4;
      v17[0] = xmmword_209BD5290;
      v17[1] = xmmword_209BD52A0;
      v18 = 0;
      v19 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v20, v13, v17, 0, 0, 0);
      v14 = (*(uint64_t (**)(_QWORD, const RB::DisplayList::Interpolator::State *, _QWORD, _BYTE *))(**(_QWORD **)&this[4] + 216))(*(_QWORD *)&this[4], a2, *(_QWORD *)&a3[4], v20);
      v15 = (void (***)(_QWORD))this[4];
      this[4] = (float32x2_t)v14;
      if (v15)
        (**v15)(v15);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v23);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v22);
      RB::Heap::~Heap((RB::Heap *)&v21);
    }
  }
  else
  {
    v8.f32[0] = v6 - (float)(*((float *)a2 + 4) * v6);
    this->i32[0] = v8.i32[0];
  }
  return v8.f32[0];
}

void sub_209B98CB0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

double RB::Filter::GaussianBlur::dod(RB::Filter::GaussianBlur *this, float32x2_t *a2, int32x4_t a3)
{
  float32x2_t v3;
  uint32x2_t v4;
  uint32x2_t v5;
  int32x2_t v6;
  int32x4_t v8;
  int8x8_t v9;
  float32x2_t v10;
  double v11;
  float32x2_t v12;
  float32x2_t v14;
  double v15;

  v3 = a2[1];
  v4 = (uint32x2_t)vcgtz_f32(v3);
  *(uint32x2_t *)a3.i8 = vpmin_u32(v4, v4);
  if (a3.i32[0] < 0)
  {
    *(int32x2_t *)a3.i8 = vdup_n_s32(0x7F7FFFFFu);
    v5 = (uint32x2_t)vcge_f32(vabs_f32(v3), *(float32x2_t *)a3.i8);
    v6 = (int32x2_t)vpmax_u32(v5, v5);
    if ((v6.i32[0] & 0x80000000) == 0)
    {
      *(float *)v6.i32 = ceilf(*(float *)this * 2.8);
      *(int32x2_t *)a3.i8 = vcgt_f32(*(float32x2_t *)a3.i8, v3);
      v8 = vcltzq_s32(a3);
      *(int8x8_t *)a3.i8 = vbsl_s8(*(int8x8_t *)v8.i8, (int8x8_t)vsub_f32(*a2, (float32x2_t)vdup_lane_s32(v6, 0)), (int8x8_t)*a2);
      v9 = (int8x8_t)vmla_n_f32(v3, (float32x2_t)0x4000000040000000, *(float *)v6.i32);
      v10 = (float32x2_t)vbsl_s8(*(int8x8_t *)v8.i8, v9, (int8x8_t)v3);
      *a2 = *(float32x2_t *)a3.i8;
      a2[1] = v10;
      if ((*((_BYTE *)this + 25) & 1) != 0)
      {
        v11 = *((double *)this + 2);
        v14 = *(float32x2_t *)((char *)this + 8);
        v15 = v11;
        RB::Rect::intersect(&v14, *(float32x2_t *)a3.i8, v10, *(double *)&v14, v11, *(double *)&v9, v8);
        *(float32x2_t *)a3.i8 = v14;
        v12 = *(float32x2_t *)&v15;
        *a2 = v14;
        a2[1] = v12;
      }
    }
  }
  return *(double *)a3.i64;
}

uint64_t RB::Filter::GaussianBlur::commutes_with_clip(RB::Filter::GaussianBlur *this)
{
  return *((_DWORD *)this + 6) & 1;
}

uint64_t RB::Filter::GaussianBlur::prepare(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 168))(result);
  return result;
}

void RB::Filter::GaussianBlur::render(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int32x2_t a5)
{
  double v9;
  uint64_t v10;
  float32x2_t *v11;
  unsigned int v12;
  int v13;
  float v14;
  float32x2_t v15;
  int v21;
  unsigned int v22;
  float32x2_t v23;
  int32x2_t v24;
  float32x2_t v25;
  double v26;
  int v27;
  char v28;
  int v29;
  double v30;
  double v31;
  int32x2_t v32;
  __int128 v33;

  if (*(float *)a1 >= 0.25)
  {
    if (*(_QWORD *)(a1 + 32))
    {
      RB::Filter::GaussianBlur::render_variable(a1, a2, (id ***)a3, a5);
    }
    else
    {
      v9 = *(double *)(a3 + 160);
      v32 = *(int32x2_t *)(a3 + 168);
      v10 = operator new();
      v11 = (float32x2_t *)v10;
      *(_QWORD *)v10 = &off_24C229718;
      v12 = *(_DWORD *)(a1 + 24);
      *(_BYTE *)(v10 + 8) = v12 & 1;
      v13 = v12 & 0x30;
      *(_BYTE *)(v10 + 9) = v13 == 48;
      v14 = *(float *)a1 * *(float *)a1;
      *(float *)(v10 + 12) = v14;
      *(_OWORD *)(v10 + 24) = (unint64_t)v32;
      v15 = vcvt_f32_s32(v32);
      __asm { FMOV            V1.2S, #1.0 }
      *(float32x2_t *)(v10 + 40) = v15;
      *(_QWORD *)(v10 + 48) = _D1;
      *(_WORD *)(v10 + 56) = 256;
      *(_DWORD *)(v10 + 92) = 0;
      v21 = vcvtps_s32_f32((float)(v14 * 0.081633) + -0.001);
      if (v21 <= 1)
        v22 = 1;
      else
        v22 = v21;
      *(_DWORD *)(v10 + 16) = v22;
      if ((v12 & 0x100) != 0)
      {
        v24 = vsub_s32(a5, *(int32x2_t *)&v9);
        v33 = *(_OWORD *)(a1 + 8);
        v23.i32[1] = DWORD1(v33);
        v23.f32[0] = (float)v24.i32[0];
        RB::Rect::translate((float32x2_t *)&v33, v23, (float)v24.i32[1]);
        v25 = vminnm_f32(v15, vadd_f32(*(float32x2_t *)((char *)&v33 + 8), *(float32x2_t *)&v33));
        v11[4] = vmaxnm_f32(*(float32x2_t *)&v33, 0);
        v11[5] = v25;
        v12 = *(_DWORD *)(a1 + 24);
      }
      v26 = *(double *)&v32;
      v27 = *(unsigned __int8 *)(a3 + 124);
      v28 = v27 & 0xFE;
      v29 = (v12 >> 2) & 1 | v27;
      if ((v12 & 2) != 0)
        LOBYTE(v29) = v28;
      if (v22 < 7)
      {
        if (v22 >= 3)
        {
          HIDWORD(v31) = v32.i32[1];
          if (v13 != 48)
            HIDWORD(v31) = (v32.i32[1] + 1) >> 1;
          LODWORD(v31) = (v32.i32[0] + 1) >> 1;
          v26 = v31;
        }
      }
      else
      {
        v30 = COERCE_DOUBLE(vshr_n_s32(vadd_s32(v32, (int32x2_t)0x300000003), 2uLL));
        LODWORD(v26) = (v32.i32[0] + 1) >> 1;
        if (v13 != 48)
          v26 = v30;
      }
      RB::Filter::RenderGroup::add_multipass_renderer(a4, a3, (uint64_t)v11, v29, v12 & 1, v9, v26);
    }
  }
}

void RB::Filter::GaussianBlur::render_variable(uint64_t a1, uint64_t a2, id ***a3, int32x2_t a4)
{
  uint64_t v7;
  float v8;
  int32x2_t v9;
  int32x2_t v10;
  float32x2_t v11;
  unsigned int v12;
  int8x8_t v13;
  float32x2_t v14;
  int32x2_t v15;
  __int16 v16;
  __n128 v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  RB::RenderPass *v23;
  RB::RenderPass *v24;
  RB::RenderPass *v25;
  float32x2_t v26;
  uint64_t v27;
  int32x2_t *v28;
  int32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  int32x2_t v32;
  __n128 v33;
  int32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  int v40;
  RB::Buffer *v41;
  uint64_t v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  RB::Texture *v48;
  uint64_t v49;
  int32x2_t v50;
  int32x2_t v51;
  int8x8_t v52;
  RB::RenderPass *v53;
  int32x2_t v54;
  RB::RenderPass *v55;
  float32x2_t v57;
  float32x2_t v58;
  int v63;
  uint64_t v64;
  RB::Buffer *v65;
  uint64_t v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  __int128 v71;
  double v72;
  float v73;
  RB::Texture *v74;
  int v75;
  RB::RenderPass *v76;
  float32x2_t v77;
  float v78;
  float32x2_t v79;
  uint64_t v80;
  __n128 v81;
  _BYTE v82[96];
  uint64_t v83;
  __int128 v84;
  _BYTE v85[64];
  __int128 v86;
  uint64_t v87;
  uint64_t v88;
  unint64_t v89;
  int v90;
  int32x2_t v91;
  int v92;
  char v93;
  RB::Texture *v94;
  RB::Buffer *v95;
  int64x2_t v96;
  RB::RenderPass *v97[2];
  char v98;
  uint64_t v99;

  v7 = a1;
  v99 = *MEMORY[0x24BDAC8D0];
  v8 = *(float *)a1;
  v9 = (int32x2_t)a3[20];
  v10 = (int32x2_t)a3[21];
  v11 = vcvt_f32_s32(v10);
  v12 = *(_DWORD *)(a1 + 24);
  if ((v12 & 0x100) != 0)
  {
    v15 = vsub_s32(a4, v9);
    *(_OWORD *)v97 = *(_OWORD *)(a1 + 8);
    v14.i32[1] = HIDWORD(v97[0]);
    v14.f32[0] = (float)v15.i32[0];
    RB::Rect::translate((float32x2_t *)v97, v14, (float)v15.i32[1]);
    v13 = (int8x8_t)vmaxnm_f32((float32x2_t)v97[0], 0);
    v11 = vminnm_f32(v11, vadd_f32((float32x2_t)v97[1], (float32x2_t)v97[0]));
    v12 = *(_DWORD *)(v7 + 24);
  }
  else
  {
    v13 = 0;
  }
  if ((v12 & 2) != 0)
    v16 = 256;
  else
    v16 = ((v12 & 4) << 6) | (v12 >> 2) & 1;
  RB::RenderPass::WorkingSpace::WorkingSpace((uint64_t)v97, (MTLPixelFormat)a3, v16, v12 & 1, 0);
  _S8 = v8 * 0.61;
  v18.n128_u64[0] = (unint64_t)vsub_s32((int32x2_t)(*(_QWORD *)&vshr_n_s32(vadd_s32(vadd_s32(v9, v10), (int32x2_t)0x7F0000007FLL), 1uLL) & 0xFFFFFFC0FFFFFFC0), (int32x2_t)(*(_QWORD *)&vshr_n_s32(vadd_s32(v9, (int32x2_t)0x7E0000007ELL), 1uLL) & 0xFFFFFFC0FFFFFFC0));
  v81 = v18;
  v19 = v18.n128_u32[1];
  if (v18.n128_i32[1] <= v18.n128_i32[0])
    v19 = v18.n128_u32[0];
  v20 = 32 - __clz(v19);
  v21 = vcvtps_u32_f32(log2f(_S8));
  if (v20 <= v21)
    v22 = v21;
  else
    v22 = v20;
  RB::Device::alloc_shared_texture(***a3, (RB *)a3[2], v22, v98, 1, (int32x2_t **)&v94, v81);
  RB::RenderFrame::flush_pass(**a3, (RB::RenderPass *)a3, 1);
  v24 = v97[0];
  v23 = v97[1];
  if (v97[1])
    v25 = v97[1];
  else
    v25 = v97[0];
  v26 = vcvt_f32_s32(v9);
  if (v22)
  {
    v78 = _S8;
    v80 = v7;
    v27 = 0;
    v28 = (int32x2_t *)*((_QWORD *)v25 + 1);
    v29 = v28[8];
    v77 = v26;
    v79 = v11;
    v30 = v11;
    v31 = (float32x2_t)v13;
    do
    {
      RB::RenderPass::RenderPass(&v84, *a3, v94, v27, 1, 0);
      v32 = vshl_s32(vadd_s32(*(int32x2_t *)((char *)v94 + 64), vdup_n_s32(~(-1 << v27))), vneg_s32(vdup_n_s32(v27)));
      v33.n128_u64[0] = (unint64_t)vmin_s32(vadd_s32(v32, (int32x2_t)0x100000001), v32);
      v88 = 0;
      v89 = v33.n128_u64[0];
      RB::RenderPass::set_extra_attachments((uint64_t)&v84, MTLPixelFormatInvalid, v33);
      RB::RenderPass::set_label((id *)&v84, CFSTR("RB: Variable blur downsample"));
      RB::Coverage::set_plane((float32x2_t *)v82, (uint64_t)&v84, v34);
      v35 = vcvt_f32_s32(v29);
      v36 = vrecpe_f32(v35);
      v37 = vmul_f32(vrecps_f32(v35, v36), v36);
      v38 = vmul_f32(v37, vrecps_f32(v35, v37));
      *(float32x2_t *)&v82[28] = vadd_f32(v38, v38);
      *(float32x2_t *)&v82[36] = vmul_f32(v38, v26);
      *(float32x2_t *)&v82[44] = vmul_f32(v38, vadd_f32(vadd_f32(v31, v26), (float32x2_t)0x3F0000003F000000));
      *(float32x2_t *)&v82[52] = vmul_f32(v38, vadd_f32(vadd_f32(v30, v26), (float32x2_t)0xBF000000BF000000));
      *(_DWORD *)&v82[92] = v27 - ((_DWORD)v27 != 0);
      *(_QWORD *)&v82[60] = COERCE_UNSIGNED_INT(-v38.f32[0]);
      v39 = vneg_f32(v38);
      v39.i32[0] = 0;
      *(float32x2_t *)&v82[68] = v39;
      v39.i32[0] = v38.i32[0];
      v38.i32[0] = 0;
      *(_QWORD *)&v82[76] = v39.u32[0];
      *(float32x2_t *)&v82[84] = v38;
      v83 = 0x3400340034003400;
      v40 = *((_DWORD *)a3 + 34);
      RB::RenderFrame::alloc_buffer_region(*(RB::RenderFrame **)v84, (RB::Device *)0x68, 4uLL, 0, &v95);
      v41 = v95;
      if (v95)
      {
        v42 = *((_QWORD *)v95 + 7) + v96.i64[0];
        v43 = *(_OWORD *)&v82[32];
        v44 = *(_OWORD *)v82;
        *(_OWORD *)(v42 + 16) = *(_OWORD *)&v82[16];
        *(_OWORD *)(v42 + 32) = v43;
        v46 = *(_OWORD *)&v82[64];
        v45 = *(_OWORD *)&v82[80];
        v47 = *(_OWORD *)&v82[48];
        *(_QWORD *)(v42 + 96) = v83;
        *(_OWORD *)(v42 + 64) = v46;
        *(_OWORD *)(v42 + 80) = v45;
        *(_OWORD *)(v42 + 48) = v47;
        *(_OWORD *)v42 = v44;
      }
      else
      {
        v95 = 0;
        v96 = 0uLL;
      }
      v90 = RB::RenderFrame::buffer_id(*(RB::RenderFrame **)v84, v41);
      v91 = vmovn_s64(v96);
      if ((_DWORD)v27)
        v48 = v94;
      else
        v48 = (RB::Texture *)v28;
      v92 = RB::RenderFrame::texture_id(*(RB::RenderFrame **)v84, (uint64_t)v48);
      v93 = 0;
      if (v40 == 2)
        v49 = 0x20080001FLL;
      else
        v49 = 8388639;
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)&v84, (const char *)v49, 4, **(_QWORD **)v84 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
      v50.i32[0] = 0;
      v51.i32[0] = v27;
      v52 = (int8x8_t)vdup_lane_s32(vceq_s32(v51, v50), 0);
      v26 = (float32x2_t)vbsl_s8(v52, v13, (int8x8_t)vrndm_f32(vmul_f32(v26, (float32x2_t)0x3F0000003F000000)));
      v29 = (int32x2_t)vbsl_s8(v52, (int8x8_t)v81.n128_u64[0], (int8x8_t)vshr_n_s32(vadd_s32(v29, (int32x2_t)0x100000001), 1uLL));
      v31 = vrndm_f32(vmul_f32(v31, (float32x2_t)0x3F0000003F000000));
      v30 = vrndp_f32(vmul_f32(v30, (float32x2_t)0x3F0000003F000000));
      v92 = 0;
      v93 = 0;
      RB::RenderPass::~RenderPass((RB::RenderPass *)&v84);
      v27 = (v27 + 1);
    }
    while (v22 != (_DWORD)v27);
    v24 = v97[0];
    v23 = v97[1];
    v7 = v80;
    v11 = v79;
    _S8 = v78;
    v26 = v77;
  }
  if (v23)
    v53 = v23;
  else
    v53 = v24;
  (*(void (**)(_QWORD, uint64_t, RB::RenderPass *, _QWORD, uint64_t, double))(**(_QWORD **)(v7 + 32) + 176))(*(_QWORD *)(v7 + 32), a2, v53, 0, 19, *(double *)&a4);
  if (v97[1])
    v55 = v97[1];
  else
    v55 = v97[0];
  RB::Coverage::set_plane((float32x2_t *)&v84, (uint64_t)v55, v54);
  *(_QWORD *)&v85[12] = 0x3F0000003F000000;
  *(float32x2_t *)&v85[20] = vmul_f32(v26, (float32x2_t)0xBF000000BF000000);
  *(int8x8_t *)&v85[28] = v13;
  *(float32x2_t *)&v85[36] = v11;
  _D0 = vcvt_f32_s32(*(int32x2_t *)((char *)v94 + 64));
  v57 = vrecpe_f32(_D0);
  v58 = vmul_f32(vrecps_f32(_D0, v57), v57);
  *(float32x2_t *)&v85[44] = vmul_f32(v58, vrecps_f32(_D0, v58));
  HIDWORD(v86) = 0;
  __asm { FCVT            H0, S8 }
  LOWORD(v87) = _D0.i16[0];
  v63 = *(_DWORD *)(v7 + 24);
  v64 = *((_DWORD *)v55 + 34) == 2;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v55, (RB::Device *)0x68, 4uLL, 0, v82);
  v65 = *(RB::Buffer **)v82;
  if (*(_QWORD *)v82)
  {
    v66 = *(_QWORD *)(*(_QWORD *)v82 + 56) + *(_QWORD *)&v82[8];
    v67 = *(_OWORD *)&v85[16];
    v68 = v84;
    *(_OWORD *)(v66 + 16) = *(_OWORD *)v85;
    *(_OWORD *)(v66 + 32) = v67;
    v70 = *(_OWORD *)&v85[48];
    v69 = v86;
    v71 = *(_OWORD *)&v85[32];
    *(_QWORD *)(v66 + 96) = v87;
    *(_OWORD *)(v66 + 64) = v70;
    *(_OWORD *)(v66 + 80) = v69;
    *(_OWORD *)(v66 + 48) = v71;
    *(_OWORD *)v66 = v68;
  }
  else
  {
    memset(v82, 0, 24);
  }
  *((_DWORD *)v55 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v55, v65);
  *(int32x2_t *)((char *)v55 + 188) = vmovn_s64(*(int64x2_t *)&v82[8]);
  *((_DWORD *)v55 + 58) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)v55, (uint64_t)v94);
  *((_BYTE *)v55 + 236) = 0;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)v55, (const char *)((v64 << 33) | (v63 << 24) & 0x8000000 | ((v63 & 1) << 26) | 0x100001Fu), 4, ***(_QWORD ***)v55 + 80, 0, 1uLL, v9, v10);
  *((_DWORD *)v55 + 58) = 0;
  *((_BYTE *)v55 + 236) = 0;
  v73 = RB::RenderPass::WorkingSpace::commit((RB::RenderPass::WorkingSpace *)v97, v72);
  v74 = v94;
  if (v94)
  {
    v75 = *((_DWORD *)v94 + 2) - 1;
    *((_DWORD *)v94 + 2) = v75;
    if (!v75)
      (*(void (**)(RB::Texture *, float))(*(_QWORD *)v74 + 8))(v74, v73);
  }
  v76 = v97[1];
  v97[1] = 0;
  if (v76)
    RB::RenderPass::~RenderPass(v76);
}

void sub_209B99630(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  _DWORD *a65;
  RB::RenderPass *a70;
  uint64_t v70;
  int v72;

  *(_DWORD *)(v70 + 232) = 0;
  *(_BYTE *)(v70 + 236) = 0;
  if (a65)
  {
    v72 = a65[2] - 1;
    a65[2] = v72;
    if (!v72)
      (*(void (**)(_DWORD *))(*(_QWORD *)a65 + 8))(a65);
  }
  if (a70)
    RB::RenderPass::~RenderPass(a70);
  _Unwind_Resume(a1);
}

uint64_t RB::Filter::GaussianBlur::prepare_encode(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 240))(result);
  return result;
}

int *RB::Filter::GaussianBlur::encode(int *this, RB::Encoder *a2)
{
  int *v3;
  int v4;
  int v5;
  uint64_t v6;
  unint64_t v7;

  v3 = this;
  v4 = *this;
  if (*(float *)this != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    this = (int *)RB::ProtobufEncoder::encode_fixed32(a2, v4);
  }
  v5 = v3[6];
  if ((v5 & 0x100) != 0)
  {
    this = (int *)RB::ProtobufEncoder::float4_field(a2, 2, *(float32x4_t *)(v3 + 2));
    v5 = v3[6];
    if ((v5 & 1) == 0)
    {
LABEL_5:
      if ((v5 & 2) == 0)
        goto LABEL_6;
      goto LABEL_15;
    }
  }
  else if ((v5 & 1) == 0)
  {
    goto LABEL_5;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v5 = v3[6];
  if ((v5 & 2) == 0)
  {
LABEL_6:
    if ((v5 & 4) == 0)
      goto LABEL_7;
    goto LABEL_16;
  }
LABEL_15:
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  v5 = v3[6];
  if ((v5 & 4) == 0)
  {
LABEL_7:
    if ((v5 & 8) == 0)
      goto LABEL_9;
    goto LABEL_8;
  }
LABEL_16:
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((v3[6] & 8) != 0)
  {
LABEL_8:
    RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
    this = (int *)RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
LABEL_9:
  v6 = *((_QWORD *)v3 + 4);
  if (v6)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x3AuLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    (*(void (**)(uint64_t, RB::Encoder *))(*(_QWORD *)v6 + 248))(v6, a2);
    this = (int *)RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v7 = (v3[6] >> 4) & 3;
  if ((_DWORD)v7)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x40uLL);
    return (int *)RB::ProtobufEncoder::encode_varint(a2, v7);
  }
  return this;
}

unint64_t RB::Filter::GaussianBlur::decode(RB::Filter::GaussianBlur *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  __n128 v6;
  int v7;
  int v8;
  RB::Decoder *v9;
  uint64_t v10;
  uint64_t v11;
  void (***v12)(_QWORD);
  unint64_t v13;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          *(float *)this = RB::ProtobufDecoder::float_field(a2, v5);
          goto LABEL_27;
        case 2u:
          v6 = RB::ProtobufDecoder::float4_field(a2, v5);
          if ((vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32((float32x4_t)v6))) & 0x80000000) != 0)
          {
            *(__n128 *)((char *)this + 8) = v6;
            v7 = *((_DWORD *)this + 6) | 0x100;
            goto LABEL_26;
          }
          goto LABEL_27;
        case 3u:
          v7 = *((_DWORD *)this + 6) | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_26;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5))
            v8 = 2;
          else
            v8 = 0;
          goto LABEL_25;
        case 5u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5))
            v8 = 4;
          else
            v8 = 0;
          goto LABEL_25;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field(a2, v5))
            v8 = 8;
          else
            v8 = 0;
          goto LABEL_25;
        case 7u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            v10 = RB::DisplayList::Item::decode(a2, v9);
            if (v10)
            {
              v11 = v10;
              v12 = (void (***)(_QWORD))*((_QWORD *)this + 4);
              *((_QWORD *)this + 4) = v11;
              if (v12)
                (**v12)(v12);
            }
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          goto LABEL_27;
        case 8u:
          *((_DWORD *)this + 6) &= 0xFFFFFFCF;
          v13 = RB::ProtobufDecoder::uint_field(a2, v5);
          if (v13 > 3)
            goto LABEL_27;
          v8 = 16 * v13;
LABEL_25:
          v7 = *((_DWORD *)this + 6) | v8;
LABEL_26:
          *((_DWORD *)this + 6) = v7;
LABEL_27:
          result = RB::ProtobufDecoder::next_field(a2);
          v5 = result;
          if (!result)
            return result;
          continue;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          goto LABEL_27;
      }
    }
  }
  return result;
}

void RB::Filter::GaussianBlur::print(RB::Filter::GaussianBlur *this, std::string *a2)
{
  int v4;
  const char *v5;
  int v6;

  RB::SexpString::push(a2, "blur");
  v4 = *((_DWORD *)this + 6);
  if ((v4 & 2) != 0)
  {
    v5 = "linear";
  }
  else
  {
    if ((v4 & 4) == 0)
      goto LABEL_6;
    v5 = "non-linear";
  }
  RB::SexpString::print(a2, 0, v5);
LABEL_6:
  v6 = *((_DWORD *)this + 6);
  if ((v6 & 1) != 0)
  {
    RB::SexpString::print(a2, 0, "opaque");
    v6 = *((_DWORD *)this + 6);
    if ((v6 & 8) == 0)
    {
LABEL_8:
      if ((v6 & 0x100) == 0)
        goto LABEL_10;
      goto LABEL_9;
    }
  }
  else if ((v6 & 8) == 0)
  {
    goto LABEL_8;
  }
  RB::SexpString::print(a2, 0, "dither");
  if ((*((_DWORD *)this + 6) & 0x100) != 0)
LABEL_9:
    RB::SexpString::printf(a2, 1, "(bounds %g %g %g %g)", COERCE_FLOAT(*((_QWORD *)this + 1)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1))), COERCE_FLOAT(*((_QWORD *)this + 2)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 2))));
LABEL_10:
  RB::SexpString::printf(a2, 1, "(radius %g)", *(float *)this);
  if (*((_QWORD *)this + 4))
  {
    RB::SexpString::push(a2, "variable-mask");
    (*(void (**)(_QWORD, std::string *))(**((_QWORD **)this + 4) + 256))(*((_QWORD *)this + 4), a2);
    RB::SexpString::pop(a2);
  }
  RB::SexpString::pop(a2);
}

void RB::Filter::`anonymous namespace'::BlurRenderer::~BlurRenderer(RB::Filter::_anonymous_namespace_::BlurRenderer *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::Filter::`anonymous namespace'::BlurRenderer::render(uint64_t a1, uint64_t a2, char a3, uint64_t a4, int32x2_t a5, int32x2_t a6)
{
  int v12;
  int v13;
  uint64_t v20;
  char v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  double v29;
  double v30;
  double v31;
  long double v32;
  uint64_t i;
  double v34;
  double v35;
  double v36;
  double v37;
  double v38;
  double v39;
  float v40;
  float v41;
  float v42;
  float v43;
  float v44;
  float v45;
  float v46;
  float v47;
  int32x2_t v48;
  uint64_t v49;
  uint64_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;
  int v55;
  _DWORD *v56;
  _DWORD *v57;
  uint64_t v58;
  int v59;
  _QWORD *v60;
  uint64_t v62;
  uint64_t v63;
  RB::Buffer *v64;
  uint64_t v65;
  __int128 v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  float32x2_t v71;
  float32x2_t v72;
  float32x2_t v73;
  int32x2_t v74;
  float32x2_t v75;
  uint64_t v76;
  RB::Buffer *v77;
  uint64_t v78;
  __int128 v79;
  __int128 v80;
  __int128 v81;
  __int128 v82;
  __int128 v83;
  float32x2_t v84;
  float32x2_t v85;
  float32x2_t v86;
  float32x2_t v87;
  int v88;
  uint64_t result;
  float32x2_t v90;
  float32x2_t v91;
  float32x2_t v92;
  float32x2_t v93;
  float32x2_t v94;
  int v95;
  RB::Buffer *v96;
  uint64_t v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  uint32x2_t v103;
  uint64_t v104;
  RB::Buffer *v105;
  int64x2_t v106;
  __int128 v107;
  _OWORD v108[5];
  _QWORD v109[4];

  v109[3] = *MEMORY[0x24BDAC8D0];
  v12 = *(_DWORD *)(a1 + 16);
  if (v12 > 2 || *(_BYTE *)(a1 + 56))
  {
    RB::Coverage::set_plane((float32x2_t *)&v107, a2, a5);
    v13 = *(_DWORD *)(a1 + 16);
    if (v13 < 7)
    {
      if (v13 < 3)
      {
        __asm { FMOV            V0.2S, #1.0 }
        v20 = 31;
        _D12 = _D0;
        goto LABEL_38;
      }
      if (!*(_BYTE *)(a1 + 9))
      {
        *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.25) + -0.76562;
        _D12 = (float32x2_t)0x3F0000003F000000;
        _D0 = (float32x2_t)0x4000000040000000;
        v20 = 31;
        goto LABEL_38;
      }
    }
    else if (!*(_BYTE *)(a1 + 9))
    {
      *(_QWORD *)((char *)&v108[2] + 12) = 0x3F800000BF800000;
      __asm { FMOV            V0.2S, #1.0 }
      *(_QWORD *)((char *)&v108[3] + 4) = _D0;
      __asm { FMOV            V0.2S, #-1.0 }
      *(_QWORD *)((char *)&v108[3] + 12) = _D0;
      *(_QWORD *)((char *)&v108[4] + 4) = 0xBF8000003F800000;
      v109[0] = 0x3400340034003400;
      *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.0625) + -0.47266;
      v20 = 4194335;
      __asm
      {
        FMOV            V12.2S, #0.25
        FMOV            V0.2S, #4.0
      }
      goto LABEL_38;
    }
    v23 = *(_BYTE *)(a1 + 57);
    if (v23)
    {
      _D12 = (float32x2_t)0x3F8000003F000000;
      _D0 = (float32x2_t)0x3F80000040000000;
      v24 = 1086026033;
      v25 = 1081725962;
      v26 = 1073333521;
    }
    else
    {
      *(float *)(a1 + 12) = (float)(*(float *)(a1 + 12) * 0.25) + -2.56;
      _D12 = (float32x2_t)0x3F0000003F800000;
      _D0 = (float32x2_t)0x400000003F800000;
      v24 = 0x40BB713100000000;
      v25 = 0x4079D40A00000000;
      v26 = 0x3FF9C51100000000;
    }
    v20 = 12582943;
    HIDWORD(v108[2]) = 0;
    LODWORD(v108[3]) = 0;
    *(_QWORD *)((char *)&v108[3] + 4) = v26;
    *(_QWORD *)((char *)&v108[3] + 12) = v25;
    *(_QWORD *)((char *)&v108[4] + 4) = v24;
    v109[0] = 0x29D62F9132B4300ELL;
    *(_BYTE *)(a1 + 57) = v23 ^ 1;
LABEL_38:
    v71 = vcvt_f32_s32(a6);
    v72 = vadd_f32(v71, (float32x2_t)0x3F0000003F000000);
    v73 = vadd_f32(v71, (float32x2_t)0xBF000000BF000000);
    v74 = vcvt_s32_f32(vrndp_f32(vmul_f32(_D12, vcvt_f32_s32(*(int32x2_t *)(a1 + 24)))));
    *(double *)(a2 + 160) = *(double *)&a5;
    *(int32x2_t *)(a2 + 168) = v74;
    *(float32x2_t *)((char *)v108 + 12) = _D0;
    *(float32x2_t *)((char *)&v108[1] + 4) = vmls_f32(v71, vcvt_f32_s32(a5), _D0);
    v75 = *(float32x2_t *)(a1 + 40);
    *(float32x2_t *)((char *)&v108[1] + 12) = vadd_f32(v72, *(float32x2_t *)(a1 + 32));
    *(float32x2_t *)((char *)&v108[2] + 4) = vadd_f32(v73, v75);
    HIDWORD(v108[4]) = 0;
    v76 = *(_DWORD *)(a2 + 136) == 2;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v105);
    v77 = v105;
    if (v105)
    {
      v78 = *((_QWORD *)v105 + 7) + v106.i64[0];
      v79 = v108[1];
      v80 = v107;
      *(_OWORD *)(v78 + 16) = v108[0];
      *(_OWORD *)(v78 + 32) = v79;
      v82 = v108[3];
      v81 = v108[4];
      v83 = v108[2];
      *(_QWORD *)(v78 + 96) = v109[0];
      *(_OWORD *)(v78 + 64) = v82;
      *(_OWORD *)(v78 + 80) = v81;
      *(_OWORD *)(v78 + 48) = v83;
      *(_OWORD *)v78 = v80;
    }
    else
    {
      v105 = 0;
      v106 = 0uLL;
    }
    *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v77);
    *(int32x2_t *)(a2 + 188) = vmovn_s64(v106);
    *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
    *(_BYTE *)(a2 + 236) = 0;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)((v76 << 33) | v20), 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
    v84 = *(float32x2_t *)(a1 + 40);
    v85 = vrndm_f32(vmul_f32(*(float32x2_t *)(a1 + 32), _D12));
    *(int32x2_t *)(a1 + 24) = v74;
    *(float32x2_t *)(a1 + 32) = v85;
    v86 = vrndp_f32(vmul_f32(v84, _D12));
    v87 = vmul_f32(*(float32x2_t *)(a1 + 48), _D12);
    *(float32x2_t *)(a1 + 40) = v86;
    *(float32x2_t *)(a1 + 48) = v87;
    if (*(_BYTE *)(a1 + 57))
    {
      v88 = vcvtps_s32_f32((float)(*(float *)(a1 + 12) * 0.081633) + -0.001);
      if (v88 <= 1)
        v88 = 1;
      *(_DWORD *)(a1 + 16) = v88;
      *(_BYTE *)(a1 + 56) = a3 & 1;
    }
    goto LABEL_45;
  }
  if (v12 >= 1)
  {
    if (!*(_DWORD *)(a1 + 92))
    {
      v27 = 0;
      v28 = (float)(*(float *)(a1 + 12) / (float)v12);
      v29 = 1.0 / v28;
      v30 = 1.0 / sqrt(v28 * 6.28318531);
      v31 = 0.0;
      do
      {
        v32 = exp((double)((int)v27 - 7) * (double)((int)v27 - 7) * -0.5 * v29) * v30;
        *((long double *)&v108[-1] + v27) = v32;
        v31 = v32 + v31;
        ++v27;
      }
      while (v27 != 15);
      for (i = 0; i != 120; i += 8)
        *(double *)((char *)&v108[-1] + i) = *(double *)((char *)&v108[-1] + i) * (1.0 / v31);
      v34 = *(double *)&v108[1] + *((double *)&v108[1] + 1);
      v35 = *(double *)v108 + *((double *)v108 + 1);
      v36 = *(double *)&v107 + *((double *)&v107 + 1);
      v37 = *(double *)&v108[1] / (*(double *)&v108[1] + *((double *)&v108[1] + 1)) + 2.0;
      v38 = *(double *)v108 / (*(double *)v108 + *((double *)v108 + 1)) + 4.0;
      v39 = *(double *)&v107 / (*(double *)&v107 + *((double *)&v107 + 1)) + 6.0;
      if (*(double *)&v108[1] + *((double *)&v108[1] + 1) < 0.002)
      {
        v34 = 0.0;
        v37 = 0.0;
      }
      if (v35 < 0.002)
      {
        v35 = 0.0;
        v38 = 0.0;
      }
      if (v36 < 0.002)
      {
        v36 = 0.0;
        v39 = 0.0;
      }
      v40 = *(double *)&v108[2] / (*(double *)&v108[2] + *((double *)&v108[2] + 1) * 0.5);
      v41 = v37;
      *(float *)(a1 + 76) = v40;
      *(float *)(a1 + 80) = v41;
      v42 = v38;
      v43 = v39;
      *(float *)(a1 + 84) = v42;
      *(float *)(a1 + 88) = v43;
      v44 = 0.5 - (v34 + v35 + v36);
      v45 = v34;
      *(float *)(a1 + 60) = v44;
      *(float *)(a1 + 64) = v45;
      v46 = v35;
      v47 = v36;
      *(float *)(a1 + 68) = v46;
      *(float *)(a1 + 72) = v47;
      *(_DWORD *)(a1 + 92) = 7;
    }
    v48 = *(int32x2_t *)(a1 + 24);
    *(double *)(a2 + 160) = *(double *)&a5;
    *(int32x2_t *)(a2 + 168) = v48;
    RB::Coverage::set_plane((float32x2_t *)&v107, a2, v48);
    v49 = 0;
    v50 = 0;
    v51 = vcvt_f32_s32(a6);
    *(float32x2_t *)((char *)&v108[1] + 4) = vsub_f32(v51, vcvt_f32_s32(a5));
    v52 = *(float32x2_t *)(a1 + 40);
    v53 = vadd_f32(vadd_f32(v51, (float32x2_t)0x3F0000003F000000), *(float32x2_t *)(a1 + 32));
    __asm { FMOV            V10.2S, #1.0 }
    *(float32x2_t *)((char *)v108 + 12) = _D10;
    *(float32x2_t *)((char *)&v108[1] + 12) = v53;
    *(float32x2_t *)((char *)&v108[2] + 4) = vadd_f32(vadd_f32(v51, (float32x2_t)0xBF000000BF000000), v52);
    HIDWORD(v108[4]) = 0;
    v55 = *(unsigned __int8 *)(a1 + 57);
    v56 = (_DWORD *)&v108[2] + 3;
    v57 = (_DWORD *)(a1 + 76);
    do
    {
      if (v55)
      {
        LODWORD(v58) = *v57;
        *v56 = *v57;
        v59 = 0;
        v60 = v56;
      }
      else
      {
        v60 = (_QWORD *)((char *)&v108[2] + 8 * v50 + 12);
        LODWORD(v58) = 0;
        *v56 = 0;
        v59 = *v57;
      }
      HIDWORD(v58) = v59;
      *v60 = v58;
      _S0 = *(v57 - 4);
      __asm { FCVT            H0, S0 }
      *(_WORD *)((char *)v109 + v49) = _S0;
      ++v50;
      v49 += 2;
      v56 += 2;
      ++v57;
    }
    while (v49 != 8);
    if (!v55)
      --*(_DWORD *)(a1 + 16);
    v62 = 12582943;
    if (*(_BYTE *)(a1 + 8) && !*(_DWORD *)(a1 + 16))
      v62 = 79691807;
    v63 = *(_DWORD *)(a2 + 136) == 2;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v105);
    v64 = v105;
    if (v105)
    {
      v65 = *((_QWORD *)v105 + 7) + v106.i64[0];
      v66 = v108[1];
      v67 = v107;
      *(_OWORD *)(v65 + 16) = v108[0];
      *(_OWORD *)(v65 + 32) = v66;
      v69 = v108[3];
      v68 = v108[4];
      v70 = v108[2];
      *(_QWORD *)(v65 + 96) = v109[0];
      *(_OWORD *)(v65 + 64) = v69;
      *(_OWORD *)(v65 + 80) = v68;
      *(_OWORD *)(v65 + 48) = v70;
      *(_OWORD *)v65 = v67;
    }
    else
    {
      v105 = 0;
      v106 = 0uLL;
    }
    *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v64);
    *(int32x2_t *)(a2 + 188) = vmovn_s64(v106);
    *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
    *(_BYTE *)(a2 + 236) = 0;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)((v63 << 33) | v62), 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
    *(_BYTE *)(a1 + 57) ^= 1u;
    if (!*(_DWORD *)(a1 + 16))
    {
      v103 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 48), _D10);
      result = vpmin_u32(v103, v103).u32[0] >> 31;
      goto LABEL_46;
    }
LABEL_45:
    result = 0;
LABEL_46:
    *(_DWORD *)(a2 + 232) = 0;
    *(_BYTE *)(a2 + 236) = 0;
    return result;
  }
  RB::Coverage::set_plane((float32x2_t *)&v107, a2, a5);
  v90 = vcvt_f32_s32(a6);
  v91 = vadd_f32(v90, (float32x2_t)0x3F0000003F000000);
  v92 = vadd_f32(v90, (float32x2_t)0xBF000000BF000000);
  v93 = vmls_f32(v90, vcvt_f32_s32(a5), *(float32x2_t *)(a1 + 48));
  *(_QWORD *)((char *)v108 + 12) = *(_QWORD *)(a1 + 48);
  *(float32x2_t *)((char *)&v108[1] + 4) = v93;
  v94 = *(float32x2_t *)(a1 + 40);
  *(float32x2_t *)((char *)&v108[1] + 12) = vadd_f32(v91, *(float32x2_t *)(a1 + 32));
  *(float32x2_t *)((char *)&v108[2] + 4) = vadd_f32(v92, v94);
  memset((char *)&v108[2] + 12, 0, 36);
  memset_pattern16(v109, &unk_209BD9670, 8uLL);
  v95 = *(_DWORD *)(a2 + 136);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x68, 4uLL, 0, &v105);
  v96 = v105;
  if (v105)
  {
    v97 = *((_QWORD *)v105 + 7) + v106.i64[0];
    v98 = v108[1];
    v99 = v107;
    *(_OWORD *)(v97 + 16) = v108[0];
    *(_OWORD *)(v97 + 32) = v98;
    v101 = v108[3];
    v100 = v108[4];
    v102 = v108[2];
    *(_QWORD *)(v97 + 96) = v109[0];
    *(_OWORD *)(v97 + 64) = v101;
    *(_OWORD *)(v97 + 80) = v100;
    *(_OWORD *)(v97 + 48) = v102;
    *(_OWORD *)v97 = v99;
  }
  else
  {
    v105 = 0;
    v106 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v96);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v106);
  *(_DWORD *)(a2 + 232) = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, a4);
  *(_BYTE *)(a2 + 236) = 0;
  if (v95 == 2)
    v104 = 0x20000001FLL;
  else
    v104 = 31;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)v104, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
  *(_DWORD *)(a2 + 232) = 0;
  *(_BYTE *)(a2 + 236) = 0;
  return 1;
}

void sub_209B9A3F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_DWORD *)(v1 + 232) = 0;
  *(_BYTE *)(v1 + 236) = 0;
  _Unwind_Resume(a1);
}

double RB::GeometryStyle::Rotation::mix(float32x2_t *this, const RB::GeometryStyle::Rotation *a2, double result)
{
  double v3;

  v3 = *(double *)this;
  if (a2)
  {
    *(double *)this = v3 + (*(double *)a2 - v3) * *(float *)&result;
    this[1] = vmla_n_f32(this[1], vsub_f32(*(float32x2_t *)((char *)a2 + 8), this[1]), *(float *)&result);
  }
  else
  {
    result = v3 - v3 * *(float *)&result;
    *(double *)this = result;
  }
  return result;
}

_QWORD *RB::GeometryStyle::Rotation::encode(RB::GeometryStyle::Rotation *this, RB::Encoder *a2)
{
  double v4;

  v4 = *(double *)this;
  if (*(double *)this != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 9uLL);
    RB::ProtobufEncoder::encode_fixed64(a2, *(uint64_t *)&v4);
  }
  return RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 1));
}

unint64_t RB::GeometryStyle::Rotation::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  __n128 v5;
  unint64_t v6;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v6 = result;
    do
    {
      if ((v6 >> 3) == 2)
      {
        *(_QWORD *)(a1 + 8) = RB::ProtobufDecoder::float2_field(this, v6, v5).n128_u64[0];
      }
      else if ((v6 >> 3) == 1)
      {
        *(double *)a1 = RB::ProtobufDecoder::double_field(this, v6);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v6);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Rotation::print(RB::GeometryStyle::Rotation *this, std::string *a2)
{
  RB::SexpString::push(a2, "rotation");
  RB::SexpString::printf(a2, 0, "(angle %g)", *(double *)this);
  RB::SexpString::printf(a2, 0, "(anchor %g %g)", COERCE_FLOAT(*((_QWORD *)this + 1)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1))));
  RB::SexpString::pop(a2);
}

double RB::GeometryStyle::Scale::set_affine_transform(float32x2_t *this, float64x2_t *a2)
{
  float32x2_t v2;
  float64x2_t v3;
  unint64_t v4;
  double result;

  v2 = this[1];
  v3.f64[0] = 0.0;
  *(double *)&v4 = COERCE_FLOAT(*this);
  v3.f64[1] = COERCE_FLOAT(HIDWORD(*(unint64_t *)this));
  result = (float)-v2.f32[0];
  *a2 = (float64x2_t)v4;
  a2[1] = v3;
  a2[2] = vmlaq_n_f64(vmlaq_n_f64(vcvtq_f64_f32(v2), v3, (float)-v2.f32[1]), (float64x2_t)v4, result);
  return result;
}

float32x2_t *RB::GeometryStyle::Scale::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  float32x2_t v3;

  v3 = *this;
  if (a2)
  {
    *this = vmla_n_f32(v3, vsub_f32(*a2, v3), a3);
    this[1] = vmla_n_f32(this[1], vsub_f32(a2[1], this[1]), a3);
  }
  else
  {
    __asm { FMOV            V2.2S, #1.0 }
    *this = vmla_n_f32(v3, vsub_f32(_D2, v3), a3);
  }
  return this;
}

_QWORD *RB::GeometryStyle::Scale::encode(RB::GeometryStyle::Scale *this, RB::Encoder *a2)
{
  RB::ProtobufEncoder::float2_field(a2, 1, *(double *)this);
  return RB::ProtobufEncoder::float2_field(a2, 2, *((double *)this + 1));
}

unint64_t RB::GeometryStyle::Scale::decode(_QWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  __n128 v5;
  unint64_t v6;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v6 = result;
    do
    {
      if ((v6 >> 3) == 2)
      {
        a1[1] = RB::ProtobufDecoder::float2_field(this, v6, v5).n128_u64[0];
      }
      else if ((v6 >> 3) == 1)
      {
        *a1 = RB::ProtobufDecoder::float2_field(this, v6, v5).n128_u64[0];
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v6);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Scale::print(RB::GeometryStyle::Scale *this, std::string *a2)
{
  RB::SexpString::push(a2, "scale");
  RB::SexpString::printf(a2, 0, "(scale %g %g)", COERCE_FLOAT(*(_QWORD *)this), COERCE_FLOAT(HIDWORD(*(_QWORD *)this)));
  RB::SexpString::printf(a2, 0, "(anchor %g %g)", COERCE_FLOAT(*((_QWORD *)this + 1)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1))));
  RB::SexpString::pop(a2);
}

float64x2_t RB::GeometryStyle::Translation::set_affine_transform(float32x2_t *this, RB::AffineTransform *a2)
{
  float64x2_t result;

  result = vcvtq_f64_f32(*this);
  *(_OWORD *)a2 = xmmword_209BD5290;
  *((_OWORD *)a2 + 1) = xmmword_209BD52A0;
  *((float64x2_t *)a2 + 2) = result;
  return result;
}

float32x2_t *RB::GeometryStyle::Translation::mix(float32x2_t *this, float32x2_t *a2, float a3)
{
  float32x2_t v3;

  if (a2)
    v3 = *a2;
  else
    v3 = 0;
  *this = vmla_n_f32(*this, vsub_f32(v3, *this), a3);
  return this;
}

_QWORD *RB::GeometryStyle::Translation::encode(RB::GeometryStyle::Translation *this, RB::Encoder *a2)
{
  return RB::ProtobufEncoder::float2_field(a2, 1, *(double *)this);
}

uint64_t RB::GeometryStyle::Translation::decode(_QWORD *a1, RB::ProtobufDecoder *this)
{
  uint64_t result;
  __n128 v5;
  uint64_t v6;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v6 = result;
    do
    {
      if ((v6 & 0x7FFFFFFF8) == 8)
        *a1 = RB::ProtobufDecoder::float2_field(this, v6, v5).n128_u64[0];
      else
        RB::ProtobufDecoder::skip_field(this, v6);
      result = RB::ProtobufDecoder::next_field(this);
      v6 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Translation::print(RB::GeometryStyle::Translation *this, std::string *a2)
{
  RB::SexpString::printf(a2, 0, "(translation %g %g)", COERCE_FLOAT(*(_QWORD *)this), COERCE_FLOAT(HIDWORD(*(_QWORD *)this)));
}

BOOL RB::GeometryStyle::Rotation3D::operator==(uint64_t a1, uint64_t a2)
{
  uint32x4_t v2;

  if (*(double *)a1 == *(double *)a2
    && *(float *)(a1 + 48) == *(float *)(a2 + 48)
    && (v2 = (uint32x4_t)vandq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(a1 + 32), *(float32x4_t *)(a2 + 32)), (int8x16_t)vceqq_f32(*(float32x4_t *)(a1 + 16), *(float32x4_t *)(a2 + 16))), v2.i32[3] = v2.i32[2], (vminvq_u32(v2) & 0x80000000) != 0))
  {
    return *(float *)(a1 + 52) == *(float *)(a2 + 52);
  }
  else
  {
    return 0;
  }
}

double RB::GeometryStyle::Rotation3D::set_projection_matrix(RB::GeometryStyle::Rotation3D *this, float32x4_t *a2)
{
  __int128 v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  CATransform3D *v8;
  CATransform3D *v9;
  int32x4_t v10;
  int32x4_t v11;
  float64x2_t v12;
  double m44;
  int8x16_t v14;
  float32x4_t v15;
  float32x4_t v16;
  int8x16_t v17;
  int32x4_t v18;
  int32x4_t v19;
  float32x4_t v20;
  float32x4_t v22[2];
  float32x4_t v23[2];
  __int32 v24;
  __int128 v25;
  uint64_t v26;
  __int32 v27;
  uint64_t v28;
  CATransform3D v29;
  _OWORD v30[5];
  __int128 v31;
  __int128 v32;
  __int128 v33;

  v4 = *(_OWORD *)(MEMORY[0x24BDE5598] + 80);
  v30[4] = *(_OWORD *)(MEMORY[0x24BDE5598] + 64);
  v31 = v4;
  v5 = *(_OWORD *)(MEMORY[0x24BDE5598] + 112);
  v32 = *(_OWORD *)(MEMORY[0x24BDE5598] + 96);
  v33 = v5;
  v6 = *(_OWORD *)(MEMORY[0x24BDE5598] + 16);
  v30[0] = *MEMORY[0x24BDE5598];
  v30[1] = v6;
  v7 = *(_OWORD *)(MEMORY[0x24BDE5598] + 48);
  v30[2] = *(_OWORD *)(MEMORY[0x24BDE5598] + 32);
  v30[3] = v7;
  *((double *)&v31 + 1) = (float)(-1.0 / *((float *)this + 12));
  CATransform3DMakeTranslation_(MEMORY[0x24BDE5598], *((float *)this + 8), *((float *)this + 9), *((float *)this + 10));
  MEMORY[0x20BD15140](&v29, v30, &v29);
  CATransform3DRotate_(v8, &v29, *(CGFloat *)this, *((float *)this + 4), *((float *)this + 5), *((float *)this + 6));
  CATransform3DTranslate_(v9, &v29, (float)-*((float *)this + 8), (float)-*((float *)this + 9), (float)-*((float *)this + 10));
  v16 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)&v29.m11), *(float64x2_t *)&v29.m14);
  v12.f64[0] = v29.m22;
  m44 = v29.m44;
  v12.f64[1] = v29.m24;
  v14 = *(int8x16_t *)&v29.m41;
  v15 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v12), *(float64x2_t *)&v29.m41);
  *a2 = v16;
  a2[1] = v15;
  v16.f32[0] = m44;
  a2[2].i32[0] = v16.i32[0];
  v16.i32[0] = *((_DWORD *)this + 13);
  if ((v16.i32[0] & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    v28 = 0x3F80000000000000;
    v26 = 1065353216;
    v25 = xmmword_209BD96B0;
    v27 = v16.i32[0];
    RB::operator*((uint64_t)&v25, (uint64_t)a2, v22, v14, v10, v11);
    RB::operator*((uint64_t)v22, (uint64_t)&v25, v23, v17, v18, v19);
    v16.i64[0] = v23[0].i64[0];
    v20 = v23[1];
    *a2 = v23[0];
    a2[1] = v20;
    a2[2].i32[0] = v24;
  }
  return *(double *)v16.i64;
}

BOOL RB::GeometryStyle::Rotation3D::can_mix(RB::GeometryStyle::Rotation3D *this, const RB::GeometryStyle::Rotation3D *a2)
{
  return !a2 || (*((_DWORD *)this + 13) & 0x7FFFFFFFu) < 0x7F800000 == (*((_DWORD *)a2 + 13) & 0x7FFFFFFFu) < 0x7F800000;
}

double RB::GeometryStyle::Rotation3D::mix(RB::GeometryStyle::Rotation3D *this, float32x4_t *a2, double result)
{
  double v3;
  float32x4_t v4;
  float v5;

  v3 = *(double *)this;
  if (a2)
  {
    *(double *)this = v3 + (*(double *)a2->i64 - v3) * *(float *)&result;
    v4 = *((float32x4_t *)this + 2);
    *((float32x4_t *)this + 1) = vmlaq_n_f32(*((float32x4_t *)this + 1), vsubq_f32(a2[1], *((float32x4_t *)this + 1)), *(float *)&result);
    *((float32x4_t *)this + 2) = vmlaq_n_f32(v4, vsubq_f32(a2[2], v4), *(float *)&result);
    v5 = *((float *)this + 13);
    *((float *)this + 12) = *((float *)this + 12)
                          + (float)((float)(a2[3].f32[0] - *((float *)this + 12)) * *(float *)&result);
    if ((LODWORD(v5) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    {
      *(float *)&result = v5 + (float)((float)(a2[3].f32[1] - v5) * *(float *)&result);
      *((_DWORD *)this + 13) = LODWORD(result);
    }
  }
  else
  {
    result = v3 - v3 * *(float *)&result;
    *(double *)this = result;
  }
  return result;
}

_QWORD *RB::GeometryStyle::Rotation3D::encode(float32x4_t *this, RB::Encoder *a2)
{
  uint64_t v4;
  _QWORD *result;
  int v6;
  int v7;

  v4 = this->i64[0];
  if (*(double *)this->i64 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 9uLL);
    RB::ProtobufEncoder::encode_fixed64(a2, v4);
  }
  RB::ProtobufEncoder::float3_field(a2, 2, this[1]);
  result = RB::ProtobufEncoder::float3_field(a2, 3, this[2]);
  v6 = this[3].i32[0];
  if (*(float *)&v6 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    result = RB::ProtobufEncoder::encode_fixed32(a2, v6);
  }
  v7 = this[3].i32[1];
  if (*(float *)&v7 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    return RB::ProtobufEncoder::encode_fixed32(a2, v7);
  }
  return result;
}

unint64_t RB::GeometryStyle::Rotation3D::decode(__n128 *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          a1->n128_f64[0] = RB::ProtobufDecoder::double_field(this, v5);
          break;
        case 2u:
          a1[1] = RB::ProtobufDecoder::float3_field(this, v5);
          break;
        case 3u:
          a1[2] = RB::ProtobufDecoder::float3_field(this, v5);
          break;
        case 4u:
          a1[3].n128_f32[0] = RB::ProtobufDecoder::float_field(this, v5);
          break;
        case 5u:
          a1[3].n128_f32[1] = RB::ProtobufDecoder::float_field(this, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::GeometryStyle::Rotation3D::print(RB::GeometryStyle::Rotation3D *this, std::string *a2)
{
  RB::SexpString::push(a2, "rotation3d");
  RB::SexpString::printf(a2, 0, "(angle %g)", *(double *)this);
  RB::SexpString::printf(a2, 0, "(axis %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6));
  RB::SexpString::printf(a2, 0, "(anchor %g %g %g)", *((float *)this + 8), *((float *)this + 9), *((float *)this + 10));
  RB::SexpString::printf(a2, 0, "(perspective %g)", *((float *)this + 12));
  if ((*((_DWORD *)this + 13) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
    RB::SexpString::printf(a2, 0, "(flip-width %g)", *((float *)this + 13));
  RB::SexpString::pop(a2);
}

BOOL RB::GeometryStyle::Affine::can_mix(RB *a1, const RB::AffineTransform *a2, const RB::AffineTransform *a3)
{
  return !a2 || RB::can_mix(a1, a2, a3) != 0;
}

CGAffineTransform *RB::GeometryStyle::Affine::mix(CGAffineTransform *this, uint64_t a2, const RB::AffineTransform *a3, float a4)
{
  __int128 v5;
  CGAffineTransform *result;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  float64x2_t v10;
  __int128 v11;
  __int128 v12;

  if (a2)
  {
    v5 = *(_OWORD *)(a2 + 16);
    v10 = *(float64x2_t *)a2;
    v11 = v5;
    v12 = *(_OWORD *)(a2 + 32);
  }
  else
  {
    v10 = (float64x2_t)xmmword_209BD5290;
    v11 = xmmword_209BD52A0;
    v12 = 0uLL;
  }
  result = RB::mix(this, &v10, a3, a4);
  *(_OWORD *)&this->a = v7;
  *(_OWORD *)&this->c = v8;
  *(_OWORD *)&this->tx = v9;
  return result;
}

void RB::GeometryStyle::Affine::print(RB::GeometryStyle::Affine *this, std::string *a2)
{
  RB::SexpString::printf(a2, 0, "(affine %g %g %g %g %g %g)", *(double *)this, *((double *)this + 1), *((double *)this + 2), *((double *)this + 3), *((double *)this + 4), *((double *)this + 5));
}

float32_t RB::GeometryStyle::Projection::mix(float32x4_t *a1, float32x4_t *a2, float a3)
{
  uint64_t v3;
  uint64_t v4;
  float32x4_t v6[2];
  int v7;
  uint64_t v8;
  uint64_t v9;

  if (a2)
    return RB::ProjectionMatrix::mix(a1, a2, a3);
  v8 = v3;
  v9 = v4;
  v7 = 1065353216;
  v6[0] = (float32x4_t)xmmword_209BD5460;
  v6[1] = (float32x4_t)xmmword_209BD5460;
  return RB::ProjectionMatrix::mix(a1, v6, a3);
}

void RB::GeometryStyle::Projection::print(RB::GeometryStyle::Projection *this, std::string *a2)
{
  RB::SexpString::printf(a2, 1, "(projection %g %g %g; %g %g %g; %g %g %g)",
    *(float *)this,
    *((float *)this + 1),
    *((float *)this + 2),
    *((float *)this + 3),
    *((float *)this + 4),
    *((float *)this + 5),
    *((float *)this + 6),
    *((float *)this + 7),
    *((float *)this + 8));
}

void RB::DisplayList::PackedTexture::render(RB::DisplayList::PackedTexture *this, _QWORD ***a2)
{
  __n128 v4;
  uint64_t v5;
  __n128 v6;
  int32x2_t *v7;
  int32x2_t *v8;
  int v9;
  uint64_t v10;
  __n128 v11;
  uint64_t v12;
  MTLPixelFormat v13;
  uint64_t v14;
  int32x2_t *v15[33];
  _BYTE v16[30];
  char v17;

  while (1)
  {
    RB::RenderTaskTexture::render_dependencies(this, a2);
    v5 = *((_QWORD *)this + 4);
    if (!*((_QWORD *)this + 2))
      break;
LABEL_8:
    RB::RenderParams::RenderParams((uint64_t)v16, (uint64_t)*a2, v5, *((_BYTE *)this + 40), *((_BYTE *)a2 + 29), *((_BYTE *)a2 + 30) & 1, *((double *)this + 6), *((float *)a2 + 6));
    v10 = *((_QWORD *)this + 2);
    v17 = v17 & 0xF7 | (2 * *(_BYTE *)(v10 + 77)) & 8;
    RB::RenderPass::RenderPass(v15, v16, v10, 0, 1, 0);
    RB::RenderPass::set_label((id *)v15, CFSTR("RB: Packed layer"));
    v12 = *((_QWORD *)this + 3);
    if (v12)
    {
      v13 = 5;
      v14 = *((_QWORD *)this + 3);
      do
      {
        v13 |= ((unint64_t)*(unsigned __int8 *)(v14 + 128) >> 1) & 8 | ((unint64_t)*(unsigned __int8 *)(v14 + 128) >> 2) & 2;
        v14 = *(_QWORD *)(v14 + 48);
      }
      while (v14 && *(_DWORD *)(v12 + 12) == *(_DWORD *)(v14 + 12));
    }
    else
    {
      v13 = MTLPixelFormatInvalid;
    }
    if (RB::RenderPass::set_extra_attachments((uint64_t)v15, v13, v11))
      RB::RenderTaskTexture::render_all_tasks(this, (RB::RenderPass *)v15, a2);
    RB::RenderPass::~RenderPass((RB::RenderPass *)v15);
    if (!*((_QWORD *)this + 3))
      return;
  }
  v4.n128_u64[0] = *((_QWORD *)this + 6);
  v6 = RB::Device::alloc_shared_texture(**a2, (RB *)*((_QWORD *)this + 4), 1u, *((_BYTE *)this + 40), 1, v15, v4);
  v7 = (int32x2_t *)*((_QWORD *)this + 2);
  v8 = v15[0];
  *((int32x2_t **)this + 2) = v15[0];
  v15[0] = v7;
  if (v7)
  {
    v9 = v7[1].i32[0] - 1;
    v7[1].i32[0] = v9;
    if (!v9)
    {
      (*(void (**)(int32x2_t *, __n128))(*(_QWORD *)v7 + 8))(v7, v6);
      v8 = (int32x2_t *)*((_QWORD *)this + 2);
    }
  }
  if (v8)
  {
    v5 = *((_QWORD *)this + 4);
    if (v5 == 25)
    {
      v8[9].i8[5] |= 4u;
      v5 = *((_QWORD *)this + 4);
    }
    goto LABEL_8;
  }
}

void sub_209B9B0DC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RB::RenderPass::~RenderPass((RB::RenderPass *)va);
  _Unwind_Resume(a1);
}

void RB::DisplayList::Layer::blit(uint64_t a1, int32x2_t *a2, int32x2_t *a3, int a4, __int128 **a5, uint64_t a6, int a7, unsigned int a8, float32x2_t a9, float32x2_t a10, double a11, float32x2_t a12, __n128 a13, float a14, char a15, unsigned __int8 a16)
{
  __int128 *v27;
  uint32x2_t v28;
  int v29;
  int v30;
  __int128 v31;
  int v32;
  int v33;
  int v34;
  __n64 v35;
  int32x4_t v36;
  __int128 v37;
  int8x16_t v38;
  int32x4_t v39;
  double v40;
  int32x4_t v41;
  char v42;
  int32x2_t v43;
  uint32x2_t v44;
  int8x8_t v45;
  float32x2_t v46;
  float32x2_t v47;
  int8x8_t v48;
  float32x2_t v49;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  int32x2_t v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  float32x2_t v62;
  float32x2_t v63;
  double v64;
  __int16 v65;
  __int128 *v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  int v70;
  float v71[6];
  uint64_t v72;
  __n128 v73;
  int v74;
  int32x4_t v75;
  float64x2_t v76[2];
  uint64_t v77;
  uint64_t v78;
  int32x2_t *v79;
  _QWORD v80[4];
  __int128 v81;
  __int128 v82;
  int v83;
  uint64_t v84;
  __int16 v85;
  __int16 v86;
  _BYTE v87[40];
  float32x2_t v88;
  float32x2_t v89;
  __int128 v90;
  __int128 v91;
  int v92;
  _QWORD v93[5];
  int v94;
  char v95;
  __int16 v96;
  double v97;
  uint64_t v98;
  _OWORD v99[5];
  float32x2_t v100[10];
  int v101;
  uint64_t v102;

  v74 = a7;
  v73 = a13;
  v72 = a1;
  v27 = 0;
  v102 = *MEMORY[0x24BDAC8D0];
  v97 = 0.0;
  v98 = 0;
  if (a4 == 1)
  {
    v28 = (uint32x2_t)vtst_s32((int32x2_t)v73.n128_u64[0], (int32x2_t)v73.n128_u64[0]);
    if ((vpmax_u32(v28, v28).u32[0] & 0x80000000) != 0)
    {
      MEMORY[0x24BDAC7A8](a1, a2);
      v27 = &v68;
      v70 = 0;
      v68 = 0u;
      v69 = 0u;
      v30 = v29;
      v31 = (*a5)[1];
      v32 = *((_DWORD *)*a5 + 8);
      v68 = **a5;
      v69 = v31;
      v70 = v32;
      v34 = v33;
      RB::ProjectionMatrix::translate((RB::ProjectionMatrix *)&v68, (float)-v29, (float)-v33);
      v35.n64_f32[0] = (float)v30;
      RB::ProjectionMatrix::translate_right((RB::ProjectionMatrix *)&v68, v35, (float)v34);
    }
    else
    {
      v27 = *a5;
    }
  }
  if (!RB::may_discard_alpha(a8))
  {
    v36.i32[0] = 0;
    v43 = a2[21];
    v44 = (uint32x2_t)vceq_s32(v43, (int32x2_t)0x8000000080000000);
    v45 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)v36.i8, (int32x2_t)vpmin_u32(v44, v44)), 0);
    *(int8x8_t *)&v37 = vbsl_s8(v45, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v43));
    *(int8x8_t *)v36.i8 = vbsl_s8(v45, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
    v97 = *(double *)v36.i64;
    v42 = 1;
    goto LABEL_11;
  }
  switch(a4)
  {
    case 2:
      goto LABEL_9;
    case 1:
      *(float32x2_t *)v36.i8 = RB::operator*((uint64_t)v27, a11, a12);
      v97 = *(double *)v36.i64;
      v42 = 2;
      goto LABEL_11;
    case 0:
LABEL_9:
      v97 = a11;
      v42 = 2;
      *(float32x2_t *)&v37 = a12;
      *(double *)v36.i64 = a11;
LABEL_11:
      v98 = v37;
      goto LABEL_12;
  }
  v42 = 2;
  *(_QWORD *)&v37 = 0;
  v36.i64[0] = 0;
LABEL_12:
  v93[0] = v36.i64[0];
  v93[1] = v37;
  v93[2] = 0;
  v93[3] = 0;
  v93[4] = 1065353216;
  v94 = 0;
  v95 = v42;
  v96 = 1;
  if (a3)
    *(float32x2_t *)v36.i8 = vcvt_f32_s32(a3[8]);
  else
    v36.i64[0] = 0;
  v75 = v36;
  *(float32x2_t *)&v37 = vdiv_f32(vmul_f32(*(float32x2_t *)v36.i8, a12), a10);
  v46 = vdiv_f32(vmul_f32(a12, a9), a10);
  LODWORD(v90) = v37;
  *(_QWORD *)((char *)&v90 + 4) = 0;
  *(_OWORD *)v71 = v37;
  *(_QWORD *)&v91 = DWORD1(v37);
  v47 = vsub_f32(*(float32x2_t *)&a11, v46);
  HIDWORD(v90) = 0;
  *((float32x2_t *)&v91 + 1) = v47;
  v92 = 1065353216;
  v88 = a9;
  v89 = a10;
  if (a15)
  {
    *(int32x2_t *)v36.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), a10);
    v48 = (int8x8_t)vcltzq_s32(v36).u64[0];
    v49 = (float32x2_t)vbsl_s8(v48, (int8x8_t)vadd_f32(a9, (float32x2_t)0xBF000000BF000000), (int8x8_t)a9);
    __asm { FMOV            V1.2S, #1.0 }
    v55 = (float32x2_t)vbsl_s8(v48, (int8x8_t)vadd_f32(a10, _D1), (int8x8_t)a10);
  }
  else
  {
    v46.i32[0] = 0.5;
    RB::Rect::inset(&v88, v46, 0.5);
    v49 = v88;
    v55 = v89;
  }
  v56 = vrecpe_f32((float32x2_t)v75.u32[0]);
  v57 = vmul_f32(vrecps_f32((float32x2_t)v75.u32[0], v56), v56);
  v58 = (int32x2_t)vmul_f32(v57, vrecps_f32((float32x2_t)v75.u32[0], v57));
  v59 = vrecpe_f32((float32x2_t)v75.u32[1]);
  v60 = vrecps_f32((float32x2_t)v75.u32[1], v59);
  v61 = vmul_f32(v60, v59);
  *(float32x2_t *)v39.i8 = vrecps_f32((float32x2_t)v75.u32[1], v61);
  *(float32x2_t *)v38.i8 = vmul_f32(v61, *(float32x2_t *)v39.i8);
  v62 = (float32x2_t)vzip1_s32(v58, *(int32x2_t *)v38.i8);
  v63 = vmul_f32(v62, v49);
  v64 = COERCE_DOUBLE(vmul_f32(v55, v62));
  v88 = v63;
  v89 = *(float32x2_t *)&v64;
  if (a4 == 2)
  {
    v66 = *a5;
    *(_QWORD *)&v67 = 0;
    *((double *)&v67 + 1) = v71[1];
    v99[0] = COERCE_UNSIGNED_INT64(v71[0]);
    v99[1] = v67;
    v99[2] = vcvtq_f64_f32(v47);
    (*(void (**)(__int128 *, uint64_t, int32x2_t *, double *, int32x2_t *, uint64_t, _OWORD *, float32x2_t *, __n128, float, _BYTE))(*(_QWORD *)v66 + 128))(v66, v72, a2, &v97, a3, a6, v99, &v88, v73, a14, v74);
  }
  else
  {
    if (a4 == 1)
    {
      RB::operator*=((uint64_t)&v90, (uint64_t)v27, *(double *)&v63, v64, *(double *)&v62, v38, v39, *(double *)&v60, v40, v41);
      v65 = 4;
    }
    else
    {
      v65 = a4 == 0;
    }
    RB::Heap::Heap((RB::Heap *)v87, 0, 0, 0);
    v81 = v90;
    v82 = v91;
    v83 = v92;
    v79 = a3;
    v80[0] = v88;
    v80[1] = v89;
    v80[2] = 0;
    v80[3] = 0;
    v84 = 0x3C003C003C003C00;
    v85 = 0;
    v86 = v65 & 0xF0FF | ((a6 & 0xF) << 8) | (a16 << 12);
    v76[0] = (float64x2_t)xmmword_209BD5290;
    v76[1] = (float64x2_t)xmmword_209BD52A0;
    v77 = 0;
    v78 = 0;
    RB::Fill::set_image(v100, (uint64_t)a2, (uint64_t)a3, v76, (uint64_t)v80, a14);
    v101 &= ~0x100u;
    RB::render_primitive((uint64_t)a2, v76, (uint64_t)v93, (uint64_t)v99, (uint64_t)v80, v74, a8);
    a2[29].i32[0] = 0;
    a2[29].i8[4] = 0;
    RB::Heap::~Heap((RB::Heap *)v87);
  }
}

void sub_209B9B588(_Unwind_Exception *a1)
{
  uint64_t v1;

  RB::Heap::~Heap((RB::Heap *)(v1 + 224));
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::LayerTask::ClipInfo::ClipInfo(uint64_t a1, MTLPixelFormat a2, _QWORD *a3, int a4, double a5, double a6)
{
  _QWORD *v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  int v11;

  *(_QWORD *)a1 = a3;
  *(_QWORD *)(a1 + 8) = -1;
  *(double *)(a1 + 16) = a5;
  *(double *)(a1 + 24) = a6;
  *(_DWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 36) = a4;
  *(_DWORD *)(a1 + 40) = a4;
  *(_WORD *)(a1 + 44) = 0;
  if (a3)
  {
    v7 = a3;
    v8 = 0;
    v9 = *(_QWORD *)(a2 + 8);
    do
    {
      v10 = v7[1] & 0xFFFFFFFFFFFFFFFELL;
      if ((*(_BYTE *)(v10 + 45) & 2) != 0)
      {
        if ((*(_BYTE *)(*(_QWORD *)(v10 + 48) + 60) & 8) != 0)
          v11 = 1;
        else
          v11 = *((unsigned __int8 *)RB::pixel_format_traits(v9, a2) + 6);
        v8 += v11;
        *(_BYTE *)(a1 + 44) = v8;
      }
      v7 = (_QWORD *)*v7;
    }
    while (v7);
  }
  return a1;
}

uint64_t RB::DisplayList::LayerTask::add_task(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  _QWORD *v12;

  result = *a4;
  if (*a4)
  {
    RB::RenderTask::set_parent(result, a1);
    v9 = *a4;
    v10 = *(_DWORD *)(a1 + 184);
    v11 = v10 + 1;
    if (*(_DWORD *)(a1 + 188) < v10 + 1)
    {
      RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(a1 + 176, v11);
      v10 = *(_DWORD *)(a1 + 184);
      result = *a4;
      v11 = v10 + 1;
    }
    else
    {
      result = *a4;
    }
    v12 = (_QWORD *)(*(_QWORD *)(a1 + 176) + 24 * v10);
    *v12 = a2;
    v12[1] = a3;
    v12[2] = v9;
    *(_DWORD *)(a1 + 184) = v11;
  }
  return result;
}

uint64_t RB::DisplayList::LayerTask::find_task(RB::DisplayList::LayerTask *this, unint64_t a2, unint64_t a3)
{
  unint64_t v3;
  _QWORD *v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t *v7;
  char v8;
  unint64_t v9;
  BOOL v10;
  _QWORD *v11;
  BOOL v12;

  v3 = *((unsigned int *)this + 46);
  if (!(_DWORD)v3)
    return 0;
  v4 = (_QWORD *)*((_QWORD *)this + 22);
  v5 = &v4[3 * v3];
  do
  {
    v6 = v3 >> 1;
    v7 = &v4[3 * (v3 >> 1)];
    if (*v7 >= a2)
      v8 = 1;
    else
      v8 = -1;
    if (*v7 == a2)
    {
      v9 = v7[1];
      v10 = v9 == a3;
      v8 = v9 >= a3 ? 1 : -1;
      if (v10)
        v8 = 0;
    }
    v11 = v7 + 3;
    v3 += ~v6;
    if (v8 < 0)
      v4 = v11;
    else
      v3 = v6;
  }
  while (v3);
  if (v4 != v5 && (*v4 == a2 ? (v12 = v4[1] == a3) : (v12 = 0), v12))
    return v4[2];
  else
    return 0;
}

uint64_t RB::DisplayList::LayerTask::find_clip_index(RB::DisplayList::LayerTask *this, const RB::DisplayList::Item *a2)
{
  unint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  unint64_t *v6;
  _QWORD *v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  unsigned int v11;

  v2 = *((unsigned int *)this + 50);
  if (!(_DWORD)v2)
    goto LABEL_9;
  v3 = (_QWORD *)*((_QWORD *)this + 24);
  v4 = &v3[2 * v2];
  do
  {
    v5 = v2 >> 1;
    v6 = &v3[2 * (v2 >> 1)];
    v8 = *v6;
    v7 = v6 + 2;
    v2 += ~(v2 >> 1);
    if (v8 < (unint64_t)a2)
      v3 = v7;
    else
      v2 = v5;
  }
  while (v2);
  if (v3 != v4 && (const RB::DisplayList::Item *)*v3 == a2)
  {
    v9 = *((_DWORD *)v3 + 2);
    v11 = v9 & 0xFFFFFF00;
    v9 = v9;
    v10 = 0x100000000;
  }
  else
  {
LABEL_9:
    v9 = 0;
    v10 = 0;
    v11 = 0;
  }
  return v10 | v11 | v9;
}

void RB::DisplayList::LayerTask::render(int32x2_t *a1, uint64_t a2, int32x2_t *a3, int a4, unsigned int a5, double a6, float a7, double a8, __n128 a9)
{
  float v15;
  float v16;
  int32x2_t v17;
  uint32x2_t v18;
  unsigned __int32 v19;
  int8x8_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  int32x2_t v25;
  int32x2_t v26;
  int v27;
  BOOL v28;
  int32x2_t v29;
  uint32x2_t v30;
  int8x8_t v31;
  float32x2_t v32;
  float32x2_t v33;
  uint64_t v34;
  float v35;
  __n128 v36;
  double v37;
  float32x2_t v38;

  if (*(_QWORD *)(*(_QWORD *)&a1[11] + 16))
  {
    a9.n128_f64[0] = a6;
    v15 = *(float *)(*(_QWORD *)&a1[12] + 48);
    if (v15 == 0.0)
      v16 = 1.0;
    else
      v16 = 1.0 / v15;
    v17 = a1[15];
    v18 = (uint32x2_t)vceq_s32(v17, (int32x2_t)0x8000000080000000);
    v19 = vpmin_u32(v18, v18).u32[0];
    v20 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    v21 = (float32x2_t)v20;
    v22 = (float32x2_t)0x100000001000000;
    if ((v19 & 0x80000000) == 0)
    {
      v22 = vcvt_f32_s32(a1[14]);
      v21 = vcvt_f32_s32(v17);
    }
    v23 = vmul_n_f32(v22, v16);
    v37 = *(double *)&v23;
    v38 = vmul_n_f32(v21, v16);
    v23.f32[0] = (float)a9.n128_i32[0];
    v35 = v16;
    v36 = a9;
    v24 = RB::Rect::translate((float32x2_t *)&v37, v23, (float)a9.n128_i32[1]);
    v24.i32[0] = 0;
    v25 = vsub_s32(vadd_s32(a1[8], a1[14]), a1[13]);
    v26 = a1[12];
    v27 = *(unsigned __int8 *)(*(_QWORD *)&v26 + 64);
    v28 = v27 != 1 && v35 == 1.0;
    v29 = a1[15];
    v30 = (uint32x2_t)vceq_s32(v29, (int32x2_t)0x8000000080000000);
    v31 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v24, (int32x2_t)vpmin_u32(v30, v30)), 0);
    v32 = (float32x2_t)vbsl_s8(v31, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v25));
    v33 = (float32x2_t)vbsl_s8(v31, v20, (int8x8_t)vcvt_f32_s32(v29));
    if (v28)
      v34 = 0;
    else
      v34 = 7;
    RB::DisplayList::Layer::blit(a2, a3, *(int32x2_t **)(*(_QWORD *)&a1[11] + 16), v27, (__int128 **)(*(_QWORD *)&v26 + 24), v34, a4, a5, v32, v33, v37, v38, v36, a7, a1[16].i8[0] & 1, (*(_BYTE *)(*(_QWORD *)&v26 + 60) >> 5) & 2);
  }
}

void RB::DisplayList::render_many(__int128 *a1, uint64_t a2, unint64_t a3, int32x2_t *a4)
{
  __int128 v7;
  unsigned __int8 v8;
  int32x2_t *v9;
  int32x2_t v10;
  unint64_t v11;
  uint32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  void **v15;
  std::string *v16;
  uint32x2_t v17;
  int v18;
  const char *v19;
  _DWORD *v20;
  double v21;
  int32x2_t v22;
  uint64_t v23;
  __n128 *v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  unsigned __int32 v30;
  unsigned int v31;
  __n128 *v32;
  _DWORD *v33;
  uint64_t v34;
  std::string *v35;
  int v36;
  RB::RenderTask **v37;
  int v38;
  void *v39;
  unint64_t v40;
  std::string *v41;
  unint64_t v42;
  _DWORD *v43;
  int v44;
  const char *v45;
  uint64_t v46;
  char v47;
  _QWORD v48[2];
  void *__p[2];
  char v50;
  uint64_t v51;
  std::string __dst[2];
  void *v53;
  uint64_t v54;
  unint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  _BYTE v61[40];
  char v62[1024];
  uint64_t v63;

  v63 = *MEMORY[0x24BDAC8D0];
  v51 = a2;
  if (!a3)
    return;
  v7 = a1[1];
  v56 = *a1;
  v57 = v7;
  v58 = 0u;
  v59 = 0u;
  v60 = 0u;
  RB::Heap::Heap((RB::Heap *)v61, v62, 1024, 0);
  if ((v8 & 1) == 0
  {
    v46 = RB::debug_int((RB *)"RB_PRINT_TREE", v45);
    v47 = v46 & 1;
    if ((v46 & 0xFF00000000) == 0)
      v47 = 0;
    RB::DisplayList::render_many(RB::RenderParams const&,objc_object  {objcproto10MTLTexture}*({block_pointer})(void),unsigned long,RB::DisplayList::Renderable const*)::print_tree = v47;
  }
  if (RB::DisplayList::render_many(RB::RenderParams const&,objc_object  {objcproto10MTLTexture}*({block_pointer})(void),unsigned long,RB::DisplayList::Renderable const*)::print_tree)
  {
    memset(__dst, 0, 41);
    RB::SexpString::push(__dst, "render");
    v9 = a4 + 3;
    v10 = vdup_n_s32(0x7F7FFFFFu);
    v11 = a3;
    do
    {
      RB::SexpString::push(__dst, "root-layer");
      v12 = (uint32x2_t)vceq_s32(*v9, (int32x2_t)0x8000000080000000);
      if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) != 0)
      {
        v13 = (float32x2_t)0x100000001000000;
        v14 = (float32x2_t)v10;
      }
      else
      {
        v13 = vcvt_f32_s32(v9[-1]);
        v14 = vcvt_f32_s32(*v9);
      }
      v48[0] = v13;
      v48[1] = v14;
      RB::Rect::operator std::string(v48, __p);
      if (v50 >= 0)
        v15 = __p;
      else
        v15 = (void **)__p[0];
      RB::SexpString::print(__dst, 0, (const char *)v15);
      if (v50 < 0)
        operator delete(__p[0]);
      RB::DisplayList::Contents::print(*(RB::DisplayList::Contents **)&v9[-3], __dst);
      RB::SexpString::pop(__dst);
      v9 += 8;
      --v11;
    }
    while (v11);
    RB::SexpString::pop(__dst);
    RB::SexpString::newline(__dst);
    if ((__dst[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v16 = __dst;
    else
      v16 = (std::string *)__dst[0].__r_.__value_.__r.__words[0];
    fputs((const char *)v16, (FILE *)*MEMORY[0x24BDAC8D8]);
    if (SHIBYTE(__dst[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__dst[0].__r_.__value_.__l.__data_);
  }
  v53 = 0;
  v54 = 0;
  v55 = 8;
  if (a3 == 1 && (v17 = (uint32x2_t)vceq_s32(a4[3], (int32x2_t)a1[1]), (vpmin_u32(v17, v17).u32[0] & 0x80000000) != 0))
    v18 = a4[5].i32[0];
  else
    v18 = 1;
  LODWORD(v48[0]) = v18;
  v20 = (_DWORD *)RB::Heap::emplace<RB::DisplayList::RootTexture,objc_object  {objcproto10MTLTexture}*({block_pointer}&)(void),RB::RenderPass::InitialState &>((RB::Heap *)v61, &v51, (int *)v48);
  if (a3 <= 1)
    v23 = 1;
  else
    v23 = a3;
  v24 = (__n128 *)&a4[6];
  do
  {
    v25 = v24[-3].n128_i64[0];
    if (!v25)
      v25 = RB::DisplayList::Contents::empty_contents(0);
    if (*(_BYTE *)(v25 + 400))
      RB::precondition_failure((RB *)"unable to render unoptimized content", v19);
    v26 = v24[-3].n128_u64[1];
    v27 = v25 + 320;
    if (v26)
      v28 = (uint64_t *)(v26 + 8);
    else
      v28 = (uint64_t *)v27;
    v29 = *v28;
    v30 = v24[-1].n128_u32[2];
    if (!v29)
    {
      if (v30 != 2)
        goto LABEL_51;
      v31 = LODWORD(v48[0]) == 2;
LABEL_37:
      v32 = v24;
      goto LABEL_38;
    }
    v31 = LODWORD(v48[0]) == 2;
    if (v30 == 2)
      goto LABEL_37;
    v32 = 0;
LABEL_38:
    RB::DisplayList::Layer::make_task(v27, (MTLPixelFormat)&v56, 0, v31, v29, v32, (uint64_t *)__p, v24[-2].n128_f64[0], v24[-2].n128_f64[1], v21, v22);
    v33 = __p[0];
    RB::RenderTask::set_texture((_DWORD *)__p[0], v20, v24[-1].n128_f64[0]);
    if (v33)
      ++v33[2];
    v34 = v54;
    v19 = (const char *)(v54 + 1);
    if (v55 < v54 + 1)
    {
      RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, (size_t)v19);
      v34 = v54;
    }
    if (v53)
      v35 = (std::string *)v53;
    else
      v35 = __dst;
    if (v33)
    {
      v36 = v33[2];
      v35->__r_.__value_.__r.__words[v34] = (std::string::size_type)v33;
      v54 = v34 + 1;
      if (!v36)
      {
        (*(void (**)(_DWORD *))(*(_QWORD *)v33 + 8))(v33);
        v36 = v33[2];
      }
      v33[2] = v36 - 1;
      if (v36 == 1)
        (*(void (**)(_DWORD *))(*(_QWORD *)v33 + 8))(v33);
    }
    else
    {
      v35->__r_.__value_.__r.__words[v34] = 0;
      v54 = v34 + 1;
    }
LABEL_51:
    v24 += 4;
    --v23;
  }
  while (v23);
  if (v54)
  {
    if (v53)
      v37 = (RB::RenderTask **)v53;
    else
      v37 = (RB::RenderTask **)__dst;
    RB::RenderTask::schedule_many(v54, v37, (uint64_t)&v56, *(double *)&v57);
    (*(void (**)(_DWORD *, __int128 *))(*(_QWORD *)v20 + 32))(v20, &v56);
LABEL_58:
    v38 = v20[2] - 1;
    v20[2] = v38;
    if (!v38)
      (*(void (**)(_DWORD *))(*(_QWORD *)v20 + 8))(v20);
    v39 = v53;
    v40 = v54;
    if (v53)
      v41 = (std::string *)v53;
    else
      v41 = __dst;
    if (v54)
    {
      v42 = 0;
      do
      {
        v43 = (_DWORD *)*((_QWORD *)&v41->__r_.__value_.__l.__data_ + v42);
        if (v43)
        {
          v44 = v43[2] - 1;
          v43[2] = v44;
          if (!v44)
          {
            (*(void (**)(_DWORD *))(*(_QWORD *)v43 + 8))(v43);
            v40 = v54;
          }
        }
        ++v42;
      }
      while (v42 < v40);
      goto LABEL_69;
    }
  }
  else
  {
    if (v20)
      goto LABEL_58;
LABEL_69:
    v39 = v53;
  }
  if (v39)
    free(v39);
  RB::Heap::~Heap((RB::Heap *)v61);
}

void sub_209B9BDCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, int a13, __int16 a14, char a15, char a16, uint64_t a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  RB::Heap *v23;

  RB::Heap::~Heap(v23);
  _Unwind_Resume(a1);
}

_QWORD *RB::vector<RB::refcounted_ptr<RB::RenderTask>,8ul,unsigned long>::~vector(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  _QWORD *v4;
  unint64_t i;
  _DWORD *v6;
  int v7;

  v2 = (_QWORD *)a1[8];
  v3 = a1[9];
  if (v2)
    v4 = v2;
  else
    v4 = a1;
  if (v3)
  {
    for (i = 0; i < v3; ++i)
    {
      v6 = (_DWORD *)v4[i];
      if (v6)
      {
        v7 = v6[2] - 1;
        v6[2] = v7;
        if (!v7)
        {
          (*(void (**)(_DWORD *))(*(_QWORD *)v6 + 8))(v6);
          v3 = a1[9];
        }
      }
    }
    v2 = (_QWORD *)a1[8];
  }
  if (v2)
    free(v2);
  return a1;
}

void RB::DisplayList::render(const RB::DisplayList::Contents *a1, __int128 *a2, uint64_t a3, int a4, uint64_t a5, int32x2_t a6, int32x2_t a7, __n128 a8)
{
  uint32x2_t v9;
  int32x2_t v14;
  uint32x2_t v15;
  int8x8_t v16;
  const char *v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  int32x2_t v22;
  int32x2_t v23[5];
  int v24;
  __n128 v25;
  float32x2_t v26[38];

  v26[37] = *(float32x2_t *)MEMORY[0x24BDAC8D0];
  v9 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a7);
  if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
  {
    v23[0] = (int32x2_t)a1;
    v23[1] = (int32x2_t)a5;
    v23[2] = a6;
    v23[3] = a7;
    v23[4] = 0;
    v24 = a4;
    v25 = a8;
    if (*((_BYTE *)a1 + 400))
    {
      RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)v26);
      RB::DisplayList::Builder::set_optimized((uint64_t)v26, 1);
      v14.i32[0] = 0;
      v15 = (uint32x2_t)vceq_s32(a7, (int32x2_t)0x8000000080000000);
      v16 = (int8x8_t)vdup_lane_s32(vcgt_s32(v14, (int32x2_t)vpmin_u32(v15, v15)), 0);
      RB::DisplayList::Builder::set_crop(v26, (float32x2_t)vbsl_s8(v16, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a6)), (float32x2_t)vbsl_s8(v16, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a7)));
      RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)v26, a1, *(RB::DisplayList::State **)&v26[33], 1.0, 0, 0);
      RB::DisplayList::Builder::move_contents((RB::DisplayList::Builder *)v26, v17, &v22);
      v18 = (unsigned int *)v22;
      v23[0] = v22;
      RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)v26);
    }
    else
    {
      v18 = 0;
    }
    RB::DisplayList::render_many(a2, a3, 1uLL, v23);
    if (v18)
    {
      v19 = v18 + 2;
      do
      {
        v20 = __ldxr(v19);
        v21 = v20 - 1;
      }
      while (__stlxr(v21, v19));
      if (!v21)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 8))(v18);
      }
    }
  }
}

void sub_209B9C0C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Layer::compute_roi(RB::DisplayList::Layer *this, int32x2_t *a2, int32x2_t *a3, BOOL *a4, __n128 *a5, __n128 a6)
{
  __n128 *v10;
  int v11;
  int32x2_t v12;
  uint32x2_t v13;
  int8x8_t v14;
  int32x2_t v15;
  uint32x2_t v16;
  int8x8_t v17;
  float v18;
  int32x2_t v19;
  uint32x2_t v20;
  int8x8_t v21;
  int32x2_t v22;
  uint32x2_t v23;
  int8x8_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  uint32x2_t v30;
  int32x2_t v31;
  double v32;
  int32x4_t v33;
  float32x2_t *v34;
  float32x2_t **v35;
  float32x2_t **v36;
  int32x2_t v38;
  uint32x2_t v39;
  int8x8_t v40;
  int8x8_t v41;
  int8x8_t v42;
  double v43;
  float32x2_t *v44;
  uint32x2_t v45;
  int32x2_t v46[2];
  int32x2_t v47[2];
  float32x2_t v48;
  float32x2_t v49;
  int32x2_t v50[2];
  __int128 v51;
  __n128 v52;
  __int128 v53;
  _QWORD *v54;
  unint64_t v55;
  char v56[512];
  uint64_t v57;

  v10 = 0;
  v57 = *MEMORY[0x24BDAC8D0];
  v52 = 0uLL;
  if (a5 && (*((_DWORD *)this + 15) & 0x2001) != 0)
  {
    a6 = *a5;
    v52 = *a5;
    v10 = a5;
  }
  v11 = *((unsigned __int8 *)this + 64);
  if (v11 == 2)
  {
    a6.n128_u32[0] = 0;
    v15 = a2[1];
    v16 = (uint32x2_t)vceq_s32(v15, (int32x2_t)0x8000000080000000);
    v17 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v16, v16)), 0);
    *(int8x8_t *)&v53 = vbsl_s8(v17, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2));
    *((int8x8_t *)&v53 + 1) = vbsl_s8(v17, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v15));
    (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)this + 3) + 32))(*((_QWORD *)this + 3), &v53);
    RB::Bounds::Bounds((int32x2_t *)&v51, *(float32x2_t *)&v53, *(float32x2_t *)((char *)&v53 + 8));
    a6.n128_u32[1] = DWORD1(v51);
    *(_OWORD *)a2->i8 = v51;
  }
  else
  {
    if (v11 != 1)
      goto LABEL_12;
    a6.n128_u32[0] = 0;
    v12 = a2[1];
    v13 = (uint32x2_t)vceq_s32(v12, (int32x2_t)0x8000000080000000);
    v14 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v13, v13)), 0);
    *(int8x8_t *)&v53 = vbsl_s8(v14, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2));
    *((int8x8_t *)&v53 + 1) = vbsl_s8(v14, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v12));
    if (RB::unapply((float32x2_t *)&v53, *((RB::Rect **)this + 3), (const RB::ProjectionMatrix *)a3))
    {
      RB::Bounds::Bounds((int32x2_t *)&v51, *(float32x2_t *)&v53, *(float32x2_t *)((char *)&v53 + 8));
      a6.n128_u32[1] = DWORD1(v51);
      *(_OWORD *)a2->i8 = v51;
    }
    else
    {
      a6.n128_u64[0] = (unint64_t)vdup_n_s32(0xC0000001);
      *a2 = (int32x2_t)a6.n128_u64[0];
      a2[1] = (int32x2_t)0x8000000080000000;
    }
    v10 = 0;
  }
  *a4 = 1;
LABEL_12:
  if (*((float *)this + 12) == 0.0)
    v18 = 1.0;
  else
    v18 = *((float *)this + 12);
  if (v18 != 1.0)
  {
    a6.n128_u32[0] = 0;
    v19 = a2[1];
    v20 = (uint32x2_t)vceq_s32(v19, (int32x2_t)0x8000000080000000);
    v21 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)a6.n128_u64[0], (int32x2_t)vpmin_u32(v20, v20)), 0);
    RB::Bounds::Bounds((int32x2_t *)&v53, vmul_n_f32((float32x2_t)vbsl_s8(v21, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*a2)), v18), vmul_n_f32((float32x2_t)vbsl_s8(v21, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v19)), v18));
    v22.i32[1] = DWORD1(v53);
    *(_OWORD *)a2->i8 = v53;
    if (v10)
    {
      v22.i32[0] = 0;
      v23 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v52.n128_i8[8], (int32x2_t)0x8000000080000000);
      v24 = (int8x8_t)vdup_lane_s32(vcgt_s32(v22, (int32x2_t)vpmin_u32(v23, v23)), 0);
      v25 = (float32x2_t)vbsl_s8(v24, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v52.n128_i8[8]));
      v26 = (float32x2_t)vbsl_s8(v24, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v52.n128_u64[0]));
      v27 = *((float *)this + 12);
      if (v27 == 0.0)
        v27 = 1.0;
      RB::Bounds::Bounds((int32x2_t *)&v52, vmul_n_f32(v26, v27), vmul_n_f32(v25, v27));
    }
    *a4 = 1;
  }
  if (v10)
  {
    v29 = COERCE_FLOAT32X2_T(RB::DisplayList::Layer::compute_bounds_(this, (int32x2_t *)&v52));
    *(float32x2_t *)&v51 = v29;
    *((float32x2_t *)&v51 + 1) = v28;
  }
  else
  {
    RB::DisplayList::Layer::compute_bounds(this);
    v51 = *((_OWORD *)this + 2);
    v28 = *(float32x2_t *)((char *)&v51 + 8);
    v29 = (float32x2_t)v51;
  }
  RB::Bounds::Bounds(v50, v29, v28);
  RB::Bounds::intersect(a2, v50[0], v50[1]);
  v30 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, a2[1]);
  if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) != 0)
    return 0;
  *(_OWORD *)a3->i8 = *(_OWORD *)a2->i8;
  if (*((_QWORD *)this + 2))
  {
    RB::Heap::Heap((RB::Heap *)&v53, v56, 512, 0);
    v34 = (float32x2_t *)*((_QWORD *)this + 2);
    if (v34)
    {
      v35 = 0;
      do
      {
        v36 = (float32x2_t **)(((unint64_t)v54 + 7) & 0xFFFFFFFFFFFFFFF8);
        if ((unint64_t)(v36 + 4) > v55)
          v36 = (float32x2_t **)RB::Heap::alloc_slow((size_t *)&v53, 0x20uLL, 7);
        else
          v54 = v36 + 4;
        *v36 = v34;
        v36[3] = (float32x2_t *)v35;
        v34 = (float32x2_t *)v34[1];
        v35 = v36;
      }
      while (v34);
    }
    else
    {
      v36 = 0;
    }
    v31.i32[0] = 0;
    v38 = a3[1];
    v39 = (uint32x2_t)vceq_s32(v38, (int32x2_t)0x8000000080000000);
    v40 = (int8x8_t)vdup_lane_s32(vcgt_s32(v31, (int32x2_t)vpmin_u32(v39, v39)), 0);
    v41 = vbsl_s8(v40, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v38));
    v42 = (int8x8_t)vcvt_f32_s32(*a3);
    v43 = 7.29112205e-304;
    v48 = (float32x2_t)vbsl_s8(v40, (int8x8_t)0x100000001000000, v42);
    v49 = (float32x2_t)v41;
    v44 = (float32x2_t *)&v51;
    if (v36)
    {
      do
      {
        RB::Rect::intersect(&v48, *v44, v44[1], *(double *)&v42, v43, v32, v33);
        RB::Bounds::Bounds(v47, v48, v49);
        RB::Bounds::Union(a2, v47[0], v47[1]);
        (*(void (**)(float32x2_t *, float32x2_t *))(*(_QWORD *)*v36 + 48))(*v36, &v48);
        v44 = *v36 + 2;
        v36 = (float32x2_t **)v36[3];
      }
      while (v36);
      v29 = *v44;
    }
    RB::Rect::intersect(&v48, v29, v44[1], *(double *)&v42, v43, v32, v33);
    RB::Bounds::Bounds(v46, v48, v49);
    RB::Bounds::Union(a2, v46[0], v46[1]);
    RB::Heap::~Heap((RB::Heap *)&v53);
  }
  v45 = (uint32x2_t)vcgtz_s32(a2[1]);
  return vpmin_u32(v45, v45).u32[0] >> 31;
}

void sub_209B9C554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Layer::prepare(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  _QWORD *i;

  v3 = result;
  if (*(_BYTE *)(result + 64) == 2)
    result = (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(result + 24) + 120))(*(_QWORD *)(result + 24), a2);
  for (i = *(_QWORD **)(v3 + 16); i; i = (_QWORD *)i[1])
    result = (*(uint64_t (**)(_QWORD *, uint64_t))(*i + 96))(i, a2);
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>(RB::Heap *this, uint64_t a2, uint64_t *a3, unsigned __int8 *a4, uint64_t a5, uint64_t *a6, char *a7)
{
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unsigned __int8 v17;
  double result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 224 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xE0uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 224;
  v16 = *a3;
  v17 = *a4;
  result = *(double *)a5;
  v19 = *(_QWORD *)(a5 + 8);
  v20 = *a6;
  v21 = a6[1];
  v22 = *a7;
  *(_DWORD *)(v15 + 8) = 1;
  *(_OWORD *)(v15 + 16) = 0u;
  *(_OWORD *)(v15 + 32) = 0u;
  *(_QWORD *)(v15 + 56) = v19;
  *(_QWORD *)(v15 + 64) = 0;
  *(_WORD *)(v15 + 72) = v17;
  *(_BYTE *)(v15 + 74) = 0;
  *(_QWORD *)(v15 + 80) = v16;
  *(_QWORD *)(v15 + 88) = 0;
  *(_QWORD *)v15 = &off_24C222BB8;
  *(_QWORD *)(v15 + 96) = a2;
  *(double *)(v15 + 104) = result;
  *(_QWORD *)(v15 + 112) = v20;
  *(_QWORD *)(v15 + 120) = v21;
  *(_BYTE *)(v15 + 128) = *(_BYTE *)(v15 + 128) & 0xE0 | v22;
  *(_OWORD *)(v15 + 144) = 0u;
  *(_OWORD *)(v15 + 160) = 0u;
  *(_OWORD *)(v15 + 176) = 0u;
  *(_OWORD *)(v15 + 192) = 0u;
  *(_OWORD *)(v15 + 208) = 0u;
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::SpillItem,RB::Shader::SpillMode,unsigned int &,int,RB::BlendMode,RB::Bounds &,decltype(nullptr)>(RB::Heap *this, int *a2, int *a3, int *a4, _WORD *a5, __n128 *a6)
{
  unint64_t v12;
  unint64_t v13;
  int v14;
  int v15;
  char v17;
  __n128 result;

  v12 = *((_QWORD *)this + 3);
  v13 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 80 > v12)
    v13 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  else
    *((_QWORD *)this + 2) = v13 + 80;
  v14 = *a2;
  v15 = *a3;
  _S0 = (float)*a4;
  v17 = *a5;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = LOWORD(_S0);
  *(_WORD *)(v13 + 46) = v17 & 0x3F;
  *(_QWORD *)v13 = &off_24C223BC8;
  result = *a6;
  *(__n128 *)(v13 + 48) = *a6;
  *(_DWORD *)(v13 + 64) = v14;
  *(_DWORD *)(v13 + 68) = v15;
  *(_QWORD *)(v13 + 72) = 0;
  return result;
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList9SpillItemEJNS_6Shader9SpillModeERjRKDF16_RKNS_9BlendModeERNS_6BoundsERPNS2_11LayerFilterEEEEPT_DpOT0_(RB::Heap *this, int *a2, int *a3, __int16 *a4, _WORD *a5, __n128 *a6, uint64_t *a7)
{
  unint64_t v14;
  unint64_t v15;
  int v16;
  int v17;
  __int16 v18;
  char v19;
  uint64_t v20;
  __n128 result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 80 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x50uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 80;
  v16 = *a2;
  v17 = *a3;
  v18 = *a4;
  v19 = *a5;
  v20 = *a7;
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = v18;
  *(_WORD *)(v15 + 46) = v19 & 0x3F;
  *(_QWORD *)v15 = &off_24C223BC8;
  result = *a6;
  *(__n128 *)(v15 + 48) = *a6;
  *(_DWORD *)(v15 + 64) = v16;
  *(_DWORD *)(v15 + 68) = v17;
  *(_QWORD *)(v15 + 72) = v20;
  return result;
}

_QWORD *_ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fENK3__2clES9_(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unint64_t v5;
  _QWORD *result;

  v4 = *a1;
  v5 = *(_QWORD *)(*a1 + 104);
  result = (_QWORD *)((*(_QWORD *)(*a1 + 96) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > v5)
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)(v4 + 80), 0x10uLL, 7);
  else
    *(_QWORD *)(v4 + 96) = result + 2;
  *result = 0;
  result[1] = a2;
  **(_QWORD **)a1[1] = result;
  *(_QWORD *)a1[1] = result;
  ++*(_DWORD *)a1[2];
  return result;
}

void *RB::DisplayList::LayerTask::append_task(void *result, uint64_t a2, _QWORD **a3, unsigned int *a4)
{
  uint64_t v5;
  unsigned int v6;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int v13;
  __int128 *v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t *v25;
  unsigned int v26;
  uint64_t v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  __int128 *v32;
  unsigned int v33;
  int32x2_t v34;
  uint64_t v35;
  _OWORD *v36;
  __int128 v37;
  __int128 v38;
  unsigned int v39;
  uint64_t v40;
  char v41;

  v5 = (uint64_t)result;
  v6 = *a4;
  **a3 = *(_QWORD *)(a2 + 160);
  v7 = *(_QWORD **)(a2 + 160);
  if (v7)
  {
    v8 = v6;
    do
    {
      *a3 = v7;
      ++v8;
      v7 = (_QWORD *)*v7;
    }
    while (v7);
    *a4 = v8;
  }
  v9 = *(_DWORD *)(a2 + 184);
  if (v9)
  {
    v10 = *(_QWORD *)(a2 + 32);
    *(_QWORD *)(a2 + 32) = 0;
    if (v10)
    {
      do
      {
        *(_QWORD *)(v10 + 16) = 0;
        v11 = *(_QWORD *)(v10 + 40);
        *(_QWORD *)(v10 + 40) = 0;
        result = RB::RenderTask::set_parent(v10, v5);
        v12 = *(_DWORD *)(v10 + 8) - 1;
        *(_DWORD *)(v10 + 8) = v12;
        if (!v12)
          result = (void *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)v10 + 8))(v10);
        v10 = v11;
      }
      while (v11);
      v9 = *(_DWORD *)(a2 + 184);
    }
    v13 = v9 + *(_DWORD *)(v5 + 184);
    if (*(_DWORD *)(v5 + 188) < v13)
    {
      result = RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(v5 + 176, v13);
      v9 = *(_DWORD *)(a2 + 184);
      if (!v9)
        goto LABEL_19;
    }
    else if (!v9)
    {
      goto LABEL_19;
    }
    v14 = *(__int128 **)(a2 + 176);
    v15 = v9;
    v16 = *(_DWORD *)(v5 + 184);
    v17 = 24 * v15;
    do
    {
      if (*(_DWORD *)(v5 + 188) < v16 + 1)
      {
        result = RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(v5 + 176, v16 + 1);
        v16 = *(_DWORD *)(v5 + 184);
      }
      v18 = *(_QWORD *)(v5 + 176) + 24 * v16;
      v19 = *v14;
      *(_QWORD *)(v18 + 16) = *((_QWORD *)v14 + 2);
      *(_OWORD *)v18 = v19;
      v16 = *(_DWORD *)(v5 + 184) + 1;
      *(_DWORD *)(v5 + 184) = v16;
      v14 = (__int128 *)((char *)v14 + 24);
      v17 -= 24;
    }
    while (v17);
  }
LABEL_19:
  v20 = *(_DWORD *)(v5 + 216);
  v21 = *(_DWORD *)(a2 + 200) + *(_DWORD *)(v5 + 200);
  if (*(_DWORD *)(v5 + 204) < v21)
    result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v5 + 192, v21);
  v22 = *(_DWORD *)(a2 + 216) + v20;
  if (*(_DWORD *)(v5 + 220) < v22)
    result = RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(v5 + 208, v22);
  v23 = *(unsigned int *)(a2 + 200);
  if ((_DWORD)v23)
  {
    v24 = *(uint64_t **)(a2 + 192);
    v25 = &v24[2 * v23];
    v26 = *(_DWORD *)(v5 + 200);
    do
    {
      v27 = *v24;
      v28 = *((_DWORD *)v24 + 2);
      v29 = v26 + 1;
      if (*(_DWORD *)(v5 + 204) < v26 + 1)
      {
        result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v5 + 192, v29);
        v26 = *(_DWORD *)(v5 + 200);
        v29 = v26 + 1;
      }
      v30 = *(_QWORD *)(v5 + 192) + 16 * v26;
      *(_QWORD *)v30 = v27;
      *(_DWORD *)(v30 + 8) = v28 + v20;
      *(_DWORD *)(v5 + 200) = v29;
      v24 += 2;
      v26 = v29;
    }
    while (v24 != v25);
  }
  v31 = *(unsigned int *)(a2 + 216);
  if ((_DWORD)v31)
  {
    v32 = *(__int128 **)(a2 + 208);
    v33 = *(_DWORD *)(v5 + 216);
    v34 = vdup_n_s32(v6);
    v35 = 48 * v31;
    do
    {
      if (*(_DWORD *)(v5 + 220) < v33 + 1)
      {
        result = RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(v5 + 208, v33 + 1);
        v33 = *(_DWORD *)(v5 + 216);
      }
      v36 = (_OWORD *)(*(_QWORD *)(v5 + 208) + 48 * v33);
      v37 = *v32;
      v38 = v32[2];
      v36[1] = v32[1];
      v36[2] = v38;
      *v36 = v37;
      v39 = *(_DWORD *)(v5 + 216);
      v33 = v39 + 1;
      *(_DWORD *)(v5 + 216) = v39 + 1;
      v40 = *(_QWORD *)(v5 + 208) + 48 * v39;
      *(int32x2_t *)(v40 + 36) = vadd_s32(*(int32x2_t *)(v40 + 36), v34);
      v32 += 3;
      v35 -= 48;
    }
    while (v35);
  }
  if ((*(_BYTE *)(v5 + 128) & 0x10) != 0)
    v41 = 16;
  else
    v41 = *(_BYTE *)(a2 + 128) & 0x10;
  *(_BYTE *)(v5 + 128) = v41 | *(_BYTE *)(v5 + 128) & 0xEF;
  return result;
}

void sub_209B9CB7C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  if (v2)
    RB::DisplayList::LayerTask::append_task(v2);
  RB::DisplayList::LayerTask::append_task(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::LayerTask::make_texture(uint64_t a1@<X0>, uint64_t a2@<X1>, _QWORD *a3@<X8>, double a4@<D0>)
{
  uint64_t v5;
  double v6;

  v6 = a4;
  _ZN2RB4Heap7emplaceINS_11DisplayList13PackedTextureEJRK14MTLPixelFormatRKNS_10ColorSpaceERDv2_iEEEPT_DpOT0_((RB::Heap *)(a2 + 80), (uint64_t *)(a1 + 80), (char *)(a1 + 72), &v6);
  *a3 = v5;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList13PackedTextureEJRK14MTLPixelFormatRKNS_10ColorSpaceERDv2_iEEEPT_DpOT0_(RB::Heap *this, uint64_t *a2, char *a3, double *a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  char v11;
  double result;

  v8 = *((_QWORD *)this + 3);
  v9 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 56 > v8)
    v9 = RB::Heap::alloc_slow((size_t *)this, 0x38uLL, 7);
  else
    *((_QWORD *)this + 2) = v9 + 56;
  v10 = *a2;
  v11 = *a3;
  result = *a4;
  *(_DWORD *)(v9 + 8) = 1;
  *(_QWORD *)(v9 + 16) = 0;
  *(_QWORD *)(v9 + 24) = 0;
  *(_QWORD *)v9 = &off_24C227CB8;
  *(_QWORD *)(v9 + 32) = v10;
  *(_BYTE *)(v9 + 40) = v11;
  *(double *)(v9 + 48) = result;
  return result;
}

void RB::DisplayList::LayerTask::render(RB::DisplayList::LayerTask *this, int32x2_t *a2, char *a3, double a4, __n128 a5, double a6, double a7, double a8, int32x4_t a9)
{
  RB::DisplayList::LayerTask *v11;
  int32x2_t *v12;
  int32x2_t v13;
  int32x2_t v14;
  uint64_t v15;
  int32x2_t *v16;
  RB::DisplayList::LayerTask *v17;
  RB::DisplayList::LayerTask *v18;
  float v19;
  int v20;
  float v21;
  int32x2_t *v22;
  int32x2_t *v23;
  int32x2_t v24;
  uint32x2_t v25;
  int8x8_t v26;
  float32x2_t v27;
  float v28;
  uint32x2_t v29;
  int8x8_t v30;
  int8x8_t v31;
  float32x2_t v32;
  float32x2_t v33;
  unsigned int v34;
  uint64_t v35;
  _QWORD *v36;
  int8x8_t v37;
  const RB::DisplayList::Item *v38;
  float32x2_t *v39;
  int32x2_t v40;
  uint32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;
  uint32x2_t v44;
  uint64_t clip_index;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  int v49;
  uint64_t v50;
  int32x2_t v51;
  __n128 v52;
  float v53;
  int32x2_t *v54;
  int32x2_t v55;
  _QWORD *v56;
  uint64_t v57;
  _QWORD *v58;
  uint64_t v59;
  char v60;
  unint64_t v61;
  BOOL v62;
  unsigned int v63;
  unsigned int v64;
  uint64_t v65;
  int32x2_t *task;
  int32x2_t v67;
  double v68;
  __n128 v69;
  int32x2_t v70;
  uint32x2_t v71;
  int8x8_t v72;
  int v73;
  int32x2_t *v74;
  int32x2_t v75;
  unsigned int *v76;
  float v77;
  RB::DisplayList::LayerTask *v78;
  __n128 v79;
  float64x2_t v80[2];
  uint64_t v81;
  uint64_t v82;
  float32x2_t v83;
  float32x2_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  int v88;
  __int16 v89;
  char v90;
  int32x2_t v91[2];
  int32x2_t v92[2];
  __int128 v93;
  uint64_t v94;
  __int16 v95;

  v11 = this;
  *((_QWORD *)a3 + 4) = this;
  a5.n128_u64[0] = *((_QWORD *)this + 7);
  *((_QWORD *)a3 + 5) = *((_QWORD *)this + 13);
  *((_QWORD *)a3 + 6) = a5.n128_u64[0];
  v12 = (int32x2_t *)(a3 + 56);
  *(_OWORD *)(a3 + 56) = *(_OWORD *)(a3 + 40);
  v13 = *(int32x2_t *)((char *)this + 64);
  a5.n128_u64[0] = (unint64_t)vsub_s32(v13, *(int32x2_t *)((char *)this + 104));
  v79 = a5;
  if ((*((_BYTE *)this + 128) & 2) != 0
    || (*(_BYTE *)(*((_QWORD *)this + 12) + 60) & 1) != 0 && !*((_QWORD *)this + 3))
  {
    v14 = *(int32x2_t *)(a3 + 64);
    a2[20] = v13;
    a2[21] = v14;
    v15 = *((_QWORD *)this + 12);
    if ((*(_BYTE *)(v15 + 60) & 1) != 0)
    {
      v16 = (int32x2_t *)*((_QWORD *)this + 2);
      if (!v16)
      {
        v17 = this;
        v18 = this;
        while (1)
        {
          v18 = (RB::DisplayList::LayerTask *)*((_QWORD *)v18 + 6);
          if (!v18)
            break;
          if (*((RB::DisplayList::LayerTask **)v18 + 3) == v17)
          {
            v16 = (int32x2_t *)*((_QWORD *)v18 + 2);
            v17 = v18;
            if (v16)
              goto LABEL_13;
          }
        }
        v16 = 0;
      }
LABEL_13:
      if (*(float *)(v15 + 48) == 0.0)
        v19 = 1.0;
      else
        v19 = *(float *)(v15 + 48);
      if (v16 && (v20 = *(unsigned __int8 *)(v15 + 67)) != 0)
      {
        while (1)
        {
          v21 = *(float *)(*(_QWORD *)&v16[12] + 48);
          if (v21 == 0.0)
            v21 = 1.0;
          v22 = (int32x2_t *)v16[2];
          if (!v22)
            break;
LABEL_21:
          v19 = v21 * v19;
          v16 = v22;
          if (!--v20)
            goto LABEL_29;
        }
        v23 = v16;
        while (1)
        {
          v23 = (int32x2_t *)v23[6];
          if (!v23)
            break;
          if ((int32x2_t *)v23[3] == v16)
          {
            v22 = (int32x2_t *)v23[2];
            v16 = v23;
            if (v22)
              goto LABEL_21;
          }
        }
      }
      else
      {
        v22 = v16;
        if (v16)
        {
LABEL_29:
          if (*(_QWORD *)(*(_QWORD *)&v22[11] + 16))
          {
            v75 = vsub_s32(v22[8], v22[13]);
            v24 = *(int32x2_t *)(a3 + 64);
            v25 = (uint32x2_t)vceq_s32(v24, (int32x2_t)0x8000000080000000);
            v26 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
            v27 = (float32x2_t)v26;
            a9.i64[0] = 0x100000001000000;
            if ((vpmin_u32(v25, v25).u32[0] & 0x80000000) == 0)
            {
              *(float32x2_t *)a9.i8 = vcvt_f32_s32(*v12);
              v27 = vcvt_f32_s32(v24);
            }
            v24.i32[0] = 0;
            v77 = v19;
            v28 = 1.0 / v19;
            v83 = vmul_n_f32(*(float32x2_t *)a9.i8, v28);
            v84 = vmul_n_f32(v27, v28);
            *(int32x2_t *)a9.i8 = v22[15];
            v29 = (uint32x2_t)vceq_s32(*(int32x2_t *)a9.i8, (int32x2_t)0x8000000080000000);
            v30 = (int8x8_t)vdup_lane_s32(vcgt_s32(v24, (int32x2_t)vpmin_u32(v29, v29)), 0);
            v31 = (int8x8_t)vcvt_f32_s32(*(int32x2_t *)a9.i8);
            RB::Rect::intersect(&v83, (float32x2_t)vbsl_s8(v30, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v22[14])), (float32x2_t)vbsl_s8(v30, v26, v31), *(double *)&v30, *(double *)&v31, *(double *)&v22[14], a9);
            v32 = vmul_n_f32(v83, v77);
            *(float32x2_t *)&v80[0].f64[0] = v32;
            *(float32x2_t *)&v80[0].f64[1] = vmul_n_f32(v84, v77);
            v32.f32[0] = (float)v75.i32[0];
            v33 = RB::Rect::translate(&v83, v32, (float)v75.i32[1]);
            v33.f32[0] = (float)v79.n128_i32[0];
            RB::Rect::translate((float32x2_t *)v80, v33, (float)v79.n128_i32[1]);
            if (fabsf(v77 + -1.0) < 0.25)
              v34 = 1;
            else
              v34 = 7;
            if (v77 == 1.0)
              v35 = 0;
            else
              v35 = v34;
            RB::DisplayList::Layer::blit((uint64_t)a3, a2, *(int32x2_t **)(*(_QWORD *)&v22[11] + 16), 0, 0, v35, 0, 0, v83, v84, v80[0].f64[0], *(float32x2_t *)&v80[0].f64[1], (__n128)0, 1.0, 0, 0);
            *(float *)a2[15].i32 = *(float *)a2[15].i32 + 1.0;
          }
        }
      }
    }
    else
    {
      RB::RenderPass::fill((uint64_t)a2, *((float32x4_t *)this + 9));
    }
  }
  v36 = (_QWORD *)*((_QWORD *)v11 + 20);
  if (v36)
  {
    v37 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    while (1)
    {
      v38 = (const RB::DisplayList::Item *)v36[1];
      v39 = (float32x2_t *)*((_QWORD *)v38 + 3);
      if (!v39)
        break;
      v93 = *(_OWORD *)v12->i8;
      RB::Bounds::Bounds(v92, v39[2], v39[3]);
      RB::Bounds::intersect((int32x2_t *)&v93, v92[0], v92[1]);
      v40 = *(int32x2_t *)((char *)&v93 + 8);
      v41 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v93 + 8));
      if ((vpmax_u32(v41, v41).u32[0] & 0x80000000) == 0)
      {
        if ((v39[1].i8[0] & 1) != 0)
          goto LABEL_49;
        *(double *)&v42 = (*(double (**)(const RB::DisplayList::Item *, _QWORD))(*(_QWORD *)v38 + 144))(v38, 0);
        RB::Bounds::Bounds(v91, v42, v43);
        RB::Bounds::intersect((int32x2_t *)&v93, v91[0], v91[1]);
        v40 = *(int32x2_t *)((char *)&v93 + 8);
        v44 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v93 + 8));
        if ((vpmax_u32(v44, v44).u32[0] & 0x80000000) == 0)
        {
          clip_index = RB::DisplayList::LayerTask::find_clip_index(v11, v38);
          if ((clip_index & 0xFF00000000) != 0)
          {
            v46 = *((_QWORD *)v11 + 26);
            v47 = v46 + 48 * clip_index;
            v49 = *(unsigned __int8 *)(v47 + 45);
            v48 = (_BYTE *)(v47 + 45);
            if (v49)
            {
              v50 = 1;
              goto LABEL_50;
            }
            v74 = v12;
            v78 = v11;
            v53 = *(float *)a2[15].i32;
            v54 = (int32x2_t *)(v46 + 48 * clip_index);
            *(float *)a2[15].i32 = v53 + (float)(v54[5].i32[0] + ~v54[4].i32[1]);
            v55 = v54[3];
            a2[20] = vadd_s32(v54[2], (int32x2_t)v79.n128_u64[0]);
            a2[21] = v55;
            v52 = v79;
            v56 = (_QWORD *)*((_QWORD *)v38 + 3);
            if (v56)
            {
              v57 = v46 + 48 * clip_index;
              v58 = (_QWORD *)(v57 + 8);
              v76 = (unsigned int *)(v57 + 32);
              v59 = 1;
              v60 = 1;
              do
              {
                v61 = v56[1] & 0xFFFFFFFFFFFFFFFELL;
                if ((*(_BYTE *)(v61 + 45) & 1) != 0 || (*v58 & v59) != 0)
                  goto LABEL_75;
                v62 = (v60 & 1) == 0;
                if ((v60 & 1) != 0)
                  v63 = 21;
                else
                  v63 = 22;
                if (v62)
                  v64 = 20;
                else
                  v64 = 19;
                if (*(_BYTE *)(v61 + 44))
                  v64 = 0;
                if (*(_BYTE *)(v61 + 44) == 1)
                  v65 = v63;
                else
                  v65 = v64;
                if ((*(_BYTE *)(v61 + 45) & 2) != 0)
                {
                  task = (int32x2_t *)RB::DisplayList::LayerTask::find_task(v78, *(_QWORD *)(v61 + 48), *v76);
                  if (!task)
                  {
                    v67.i32[0] = 0;
                    v70 = a2[21];
                    v71 = (uint32x2_t)vceq_s32(v70, (int32x2_t)0x8000000080000000);
                    v72 = (int8x8_t)vdup_lane_s32(vcgt_s32(v67, (int32x2_t)vpmin_u32(v71, v71)), 0);
                    v83 = (float32x2_t)vbsl_s8(v72, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a2[20]));
                    v84 = (float32x2_t)vbsl_s8(v72, v37, (int8x8_t)vcvt_f32_s32(v70));
                    v85 = 0;
                    v86 = 0;
                    v87 = 1065353216;
                    v88 = 0;
                    v89 = 257;
                    v90 &= 0xF8u;
                    v80[0] = (float64x2_t)xmmword_209BD5290;
                    v80[1] = (float64x2_t)xmmword_209BD52A0;
                    v81 = 0;
                    v82 = 0;
                    v95 = 0;
                    v94 = 0;
                    RB::render_primitive((uint64_t)a2, v80, (uint64_t)&v83, (uint64_t)&v94, 0, v65);
                    v60 = 0;
                    v52 = v79;
                    goto LABEL_75;
                  }
                  RB::DisplayList::LayerTask::render(task, (uint64_t)a3, a2, 0, v65, v79.n128_f64[0], *(float *)(v61 + 56), v68, v69);
                }
                else
                {
                  (*(void (**)(unint64_t, char *, int32x2_t *, uint64_t, __n128))(*(_QWORD *)v61 + 56))(v56[1] & 0xFFFFFFFFFFFFFFFELL, a3, a2, v65, v52);
                }
                v52 = v79;
                v60 = 0;
LABEL_75:
                v59 *= 2;
                v56 = (_QWORD *)*v56;
              }
              while (v56);
            }
            v50 = 1;
            *v48 = 1;
            *(float *)a2[15].i32 = v53;
            v40 = *(int32x2_t *)((char *)&v93 + 8);
            v11 = v78;
            v12 = v74;
          }
          else
          {
LABEL_49:
            v50 = 0;
LABEL_50:
            v52 = v79;
          }
          a2[20] = vadd_s32(*(int32x2_t *)&v93, (int32x2_t)v52.n128_u64[0]);
          a2[21] = v40;
LABEL_52:
          (*(void (**)(const RB::DisplayList::Item *, char *, int32x2_t *, uint64_t, _QWORD, __n128))(*(_QWORD *)v38 + 176))(v38, a3, a2, v50, *((_WORD *)v38 + 23) & 0x3F, v52);
          *(float *)a2[15].i32 = *(float *)a2[15].i32 + 1.0;
        }
      }
      v36 = (_QWORD *)*v36;
      if (!v36)
        goto LABEL_79;
    }
    v50 = 0;
    v51 = *(int32x2_t *)(a3 + 64);
    a2[20] = vadd_s32(*(int32x2_t *)(a3 + 56), (int32x2_t)v79.n128_u64[0]);
    a2[21] = v51;
    v52 = v79;
    goto LABEL_52;
  }
LABEL_79:
  if (*((_QWORD *)v11 + 21))
    LOBYTE(v73) = 1;
  else
    v73 = (*((unsigned __int8 *)v11 + 128) >> 2) & 1;
  *((_BYTE *)v11 + 74) = v73;
  *((_QWORD *)a3 + 4) = 0;
}

void RB::DisplayList::LayerTask::postprocess(int32x2_t *this, int32x2_t *a2, RB::Filter::RenderGroup *a3, _QWORD *a4)
{
  int32x2_t v7;
  int32x2_t v8;
  int32x2_t v9;
  _QWORD *v10;
  double v12;
  uint64_t v13;

  a4[4] = this;
  v7 = this[13];
  v9 = this[7];
  v8 = this[8];
  a2[20] = v8;
  a2[21] = v9;
  v10 = (_QWORD *)this[21];
  if (v10)
  {
    v12 = COERCE_DOUBLE(vsub_s32(v8, v7));
    while (1)
    {
      *((_QWORD *)a3 + 4) = v10;
      (*(void (**)(_QWORD *, _QWORD *, int32x2_t *, RB::Filter::RenderGroup *, double))(*v10 + 104))(v10, a4, a2, a3, v12);
      *((_QWORD *)a3 + 4) = 0;
      *(float *)v7.i32 = *(float *)a2[15].i32 + 1.0;
      a2[15].i32[0] = v7.i32[0];
      v13 = *((_QWORD *)a3 + 2);
      if (v13)
      {
        if (*(_QWORD **)(*((_QWORD *)a3 + 1) + 56 * v13 - 56) == v10)
          break;
      }
      v10 = (_QWORD *)v10[1];
      if (!v10)
        goto LABEL_6;
    }
    this[21] = (int32x2_t)v10[1];
    this[9].i8[2] = 1;
    a4[4] = 0;
  }
  else
  {
LABEL_6:
    this[21] = 0;
    a4[4] = 0;
    if ((this[16].i8[0] & 4) != 0)
    {
      RB::RenderPass::resolve_srgb_alpha((RB::RenderPass *)a2, v7);
      this[16].i8[0] &= ~4u;
    }
  }
}

uint64_t RB::DisplayList::LayerItem::prepare(uint64_t a1, uint64_t a2)
{
  return RB::DisplayList::Layer::prepare(*(_QWORD *)(a1 + 48), a2);
}

void RB::DisplayList::LayerItem::render(unint64_t a1, uint64_t a2, int32x2_t *a3, int a4, unsigned int a5, double a6)
{
  RB::DisplayList::LayerTask *v10;
  int32x2_t *task;
  double v14;
  __n128 v15;
  __n128 v16;
  uint64_t v23;
  int32x2_t v26;
  int32x2_t v27;
  uint32x2_t v28;
  float64x2_t v30[2];
  uint64_t v31;
  uint64_t v32;
  _QWORD v33[5];
  int v34;
  __int16 v35;
  char v36;
  int v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;

  v10 = *(RB::DisplayList::LayerTask **)(a2 + 32);
  if (!v10)
    goto LABEL_6;
  task = (int32x2_t *)RB::DisplayList::LayerTask::find_task(v10, a1, 0);
  if (task)
  {
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S1, H0 }
    RB::DisplayList::LayerTask::render(task, a2, a3, a4, a5, a6, _S1, v14, v15);
    return;
  }
  v23 = *(_QWORD *)(a1 + 48);
  if (*(_BYTE *)(v23 + 64) == 2)
  {
    _H0 = *(_WORD *)(a1 + 44);
    __asm { FCVT            S5, H0 }
    v16.n128_f64[0] = a6;
    RB::DisplayList::Layer::blit(a2, a3, 0, 2, (__int128 **)(v23 + 24), 0, a4, a5, 0, 0, 0.0, 0, v16, _S5, 0, (*(_BYTE *)(v23 + 60) >> 5) & 2);
  }
  else
  {
LABEL_6:
    if ((RB::may_discard_alpha(a5) & 1) == 0)
    {
      v26.i32[0] = 0;
      v27 = a3[21];
      v28 = (uint32x2_t)vceq_s32(v27, (int32x2_t)0x8000000080000000);
      _D0 = (int8x8_t)vdup_lane_s32(vcgt_s32(v26, (int32x2_t)vpmin_u32(v28, v28)), 0);
      v33[0] = vbsl_s8(_D0, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3[20]));
      v33[1] = vbsl_s8(_D0, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v27));
      v33[2] = 0;
      v33[3] = 0;
      v33[4] = 1065353216;
      v34 = 0;
      v35 = 257;
      v36 = 0;
      v30[0] = (float64x2_t)xmmword_209BD5290;
      v30[1] = (float64x2_t)xmmword_209BD52A0;
      v31 = 0;
      v32 = 0;
      _D0.i16[0] = *(_WORD *)(a1 + 44);
      v37 = 0;
      v38 = 0;
      __asm { FCVT            S0, H0 }
      *(float *)_D0.i32 = *(float *)_D0.i32 * 0.0;
      __asm { FCVT            H0, S0 }
      v39 = _D0.i16[0];
      v40 = 0;
      RB::render_primitive((uint64_t)a3, v30, (uint64_t)v33, (uint64_t)&v37, a4, a5);
    }
  }
}

uint64_t RB::DisplayList::LayerClip::prepare(uint64_t a1, uint64_t a2)
{
  return RB::DisplayList::Layer::prepare(*(_QWORD *)(a1 + 48), a2);
}

void RB::DisplayList::LayerClip::render()
{
  abort();
}

uint64_t RB::DisplayList::BackdropColorMatrixItem::render(uint64_t a1, uint64_t a2, MTLPixelFormat a3, unsigned int a4, int a5)
{
  _BYTE *v10;
  _BYTE v18[56];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v10 = *(_BYTE **)(a1 + 48);
  if (!v10)
  {
    MEMORY[0x24BDAC7A8](a1, a2);
    v10 = v18;
    memset(v18, 0, 48);
    RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v18[8]);
  }
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  return RB::Filter::ColorMatrix::render((uint64_t)v10, a3, a2, a5, a4, _S0);
}

uint64_t RB::DisplayList::ItemClip::prepare(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 48) + 168))(*(_QWORD *)(a1 + 48));
}

uint64_t RB::DisplayList::ItemClip::render(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, _QWORD, uint64_t))(**(_QWORD **)(a1 + 48) + 176))(*(_QWORD *)(a1 + 48), a2, a3, 0, a4);
}

unsigned __int8 *RB::DisplayList::CustomItem::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, char a6)
{
  uint64_t v8;
  uint64_t v9;
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  int32x2_t v23[2];
  float64x2_t v24[3];

  v8 = ((a6 & 0x3F) << 6) | 0x26u;
  v9 = a5 | (2 * (*(_DWORD *)(a4 + 136) == 2));
  v10 = *(float64x2_t **)(a1 + 56);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  v12 = v10[1];
  v13 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v24[0] = *v10;
  v24[1] = v12;
  v24[2] = v13;
  v14 = RB::operator*(v24, *(float32x2_t *)(a1 + 64), *(float32x2_t *)(a1 + 72));
  RB::Bounds::Bounds(v23, v14, v15);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  return RB::RenderPass::draw_custom(a4, (const char *)(v8 | (v9 << 32)), *(_QWORD *)(a1 + 48), v24, *(_DWORD *)(a1 + 80), v23[0], v23[1], _S2);
}

int32x2_t *RB::DisplayList::SpillItem::render(int32x2_t *a1, uint64_t a2, RB::RenderPass *this, unsigned int a4, char a5, int32x2_t a6)
{
  __int32 v12;
  _QWORD *v13;
  void *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  int32x2_t v19;
  int32x2_t v20;
  int32x2_t v21;
  uint32x2_t v22;
  int8x8_t v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  RB::Buffer *v27;
  _OWORD *v28;
  __int128 v29;
  int32x2_t *result;
  void *v31[2];
  __int128 v32;
  RB::Buffer *v33;
  int64x2_t v34;

  v12 = a1[8].i32[0];
  if (v12 == 2)
  {
    v13 = (_QWORD *)a1[9];
    if (v13)
    {
      v31[0] = (void *)a2;
      v31[1] = 0;
      v32 = 0uLL;
      do
      {
        (*(void (**)(_QWORD *, uint64_t))(*v13 + 96))(v13, a2);
        (*(void (**)(_QWORD *, uint64_t, RB::RenderPass *, void **, double))(*v13 + 104))(v13, a2, this, v31, *(double *)&a6);
        v13 = (_QWORD *)v13[1];
      }
      while (v13);
      v14 = v31[1];
      v15 = v32;
      if ((_QWORD)v32)
      {
        v16 = 0;
        v17 = (uint64_t *)((char *)v31[1] + 8);
        do
        {
          v18 = *v17;
          *v17 = 0;
          if (v18)
          {
            (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
            v15 = v32;
          }
          ++v16;
          v17 += 7;
        }
        while (v16 < v15);
        v14 = v31[1];
      }
      if (v14)
        free(v14);
    }
    RB::RenderPass::pop_layer((uint64_t)this);
  }
  else
  {
    RB::RenderPass::push_layer((uint64_t)this);
  }
  v19.i32[0] = 0;
  v20 = a1[7];
  v21 = vadd_s32(a1[6], a6);
  v22 = (uint32x2_t)vceq_s32(v20, (int32x2_t)0x8000000080000000);
  v23 = (int8x8_t)vdup_lane_s32(vcgt_s32(v19, (int32x2_t)vpmin_u32(v22, v22)), 0);
  RB::Coverage::set_plane((float32x2_t *)v31, (float32x2_t *)this, (float32x2_t)vbsl_s8(v23, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v21)), COERCE_DOUBLE(vbsl_s8(v23, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v20))));
  v24 = 0;
  WORD6(v32) = a1[5].i16[2];
  if (v12 == 2)
    v24 = ((unsigned __int32)a1[8].i32[1] >> 4) & 4;
  v25 = ((a5 & 0x3F) << 6) | ((v24 | a1[8].i32[0] & 3) << 22) | 0x23u;
  v26 = a4 | (2 * (*((_DWORD *)this + 34) == 2));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)this, (RB::Device *)0x20, 4uLL, 0, &v33);
  v27 = v33;
  if (v33)
  {
    v28 = (_OWORD *)(*((_QWORD *)v33 + 7) + v34.i64[0]);
    v29 = v32;
    *v28 = *(_OWORD *)v31;
    v28[1] = v29;
  }
  else
  {
    v33 = 0;
    v34 = 0uLL;
  }
  *((_DWORD *)this + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)this, v27);
  *(int32x2_t *)((char *)this + 188) = vmovn_s64(v34);
  result = RB::RenderPass::draw_indexed_primitives((int32x2_t *)this, (const char *)(v25 | (v26 << 32)), 4, ***(_QWORD ***)this + 80, 0, 1uLL, v21, v20);
  if (v12 != 2)
    return RB::Bounds::intersect((int32x2_t *)(a2 + 56), a1[6], a1[7]);
  *(_OWORD *)(a2 + 56) = *(_OWORD *)(a2 + 40);
  return result;
}

void sub_209B9D970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RB::Filter::RenderGroup::~RenderGroup((RB::Filter::RenderGroup *)&a9);
  _Unwind_Resume(a1);
}

void RB::DisplayList::SpillItem::print(RB::DisplayList::SpillItem *this, std::string *a2)
{
  int v4;
  const char *v5;
  const char *v6;

  RB::SexpString::push(a2, "spill");
  v4 = *((_DWORD *)this + 16);
  v5 = "unspill";
  if (v4 == 1)
    v5 = "spill-copy";
  if (v4)
    v6 = v5;
  else
    v6 = "spill-clear";
  RB::SexpString::printf(a2, 0, "(mode %s)", v6);
  RB::DisplayList::Item::print(this, a2);
  RB::SexpString::pop(a2);
}

_QWORD *RB::Filter::RenderGroup::add_multipass_renderer(_QWORD *result, uint64_t a2, uint64_t a3, char a4, char a5, double a6, double a7)
{
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v12 = result;
  v13 = *(_QWORD *)(a2 + 160);
  v14 = *(_QWORD *)(a2 + 168);
  v15 = result[2];
  if (result[3] < (unint64_t)(v15 + 1))
  {
    result = RB::vector<RB::Filter::RenderGroup::MultipassInfo,0ul,unsigned long>::reserve_slow((uint64_t)(result + 1), v15 + 1);
    v15 = v12[2];
  }
  v16 = v12[1] + 56 * v15;
  *(_QWORD *)v16 = v12[4];
  *(_QWORD *)(v16 + 8) = a3;
  *(double *)(v16 + 16) = a6;
  *(_QWORD *)(v16 + 24) = v13;
  *(_QWORD *)(v16 + 32) = v14;
  *(double *)(v16 + 40) = a7;
  *(_BYTE *)(v16 + 48) = a4;
  *(_BYTE *)(v16 + 49) = a5;
  *(_BYTE *)(v16 + 50) = 0;
  ++v12[2];
  return result;
}

void RB::Filter::RenderGroup::resolve(RB::Filter::RenderGroup *this, RB::RenderPass *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  MTLPixelFormat v8;
  __n128 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unint64_t v14;
  RB::RenderPass *v15;
  unsigned __int8 v16;
  RB::RenderParams *v17;
  unsigned int *v18;
  MTLPixelFormat v19;
  unsigned int *v20;
  RB *v21;
  RB *v22;
  RB *v23;
  int v24;
  MTLPixelFormat v25;
  unsigned int *v26;
  uint64_t i;
  int32x2_t *v28;
  int32x2_t v29;
  int32x2_t v30;
  _BOOL4 v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  BOOL v37;
  char *v38;
  uint64_t j;
  int32x2_t *v40;
  int32x2_t v41;
  int32x2_t v42;
  uint64_t v43;
  uint64_t v44;
  __n128 v45;
  uint64_t v46;
  char v47;
  char v48;
  MTLPixelFormat v49;
  RB::Resource *v50;
  int v51;
  __n128 v52;
  uint64_t v53;
  uint64_t *v54;
  RB::RenderPass *v55;
  uint64_t *v56;
  __CFString *v57;
  __n128 v58;
  __n128 v59;
  uint64_t *v60;
  char v61;
  uint64_t v62;
  unint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  char v66;
  uint64_t k;
  int32x2_t *v68;
  int32x2_t v69;
  int32x2_t v70;
  uint64_t m;
  int32x2_t *v72;
  int32x2_t v73;
  int32x2_t v74;
  int v75;
  int32x2_t *v76;
  __int32 v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  char *v81;
  char *v82;
  uint64_t v83;
  uint64_t v84;
  RB *v85;
  char *v86;
  uint64_t v87[33];
  int32x2_t *v88;
  _BYTE v89[1096];
  uint64_t v90;
  uint64_t v91;

  v91 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 2))
  {
    RB::BinPacker::BinPacker((RB::BinPacker *)v89, *((_QWORD *)a2 + 13), HIDWORD(*((_QWORD *)a2 + 13)));
    v5 = *((_QWORD *)this + 2);
    if (v5)
    {
      v6 = *((_QWORD *)this + 1);
      v7 = 56 * v5;
      do
      {
        RB::BinPacker::add((uint64_t)v89, *(_QWORD *)(v6 + 40), HIDWORD(*(_QWORD *)(v6 + 40)), (void *)v6, *(unsigned __int8 *)(v6 + 48));
        v6 += 56;
        v7 -= 56;
      }
      while (v7);
    }
    RB::BinPacker::pack((RB::BinPacker *)v89, v4);
    v10 = v90;
    if (v90)
    {
      v11 = *((_QWORD *)a2 + 20);
      v12 = *((_QWORD *)a2 + 21);
      v81 = (char *)a2 + 8;
      v13 = *((unsigned __int8 *)a2 + 124);
      v14 = *((_QWORD *)a2 + 2);
      v15 = a2;
      v82 = (char *)a2 + 8;
      v83 = 0;
      v85 = (RB *)v14;
      v86 = (char *)a2 + 8;
      v84 = v13;
      do
      {
        v16 = *(_BYTE *)(v10 + 8);
        v17 = *(RB::RenderParams **)a2;
        if ((*(_BYTE *)(*(_QWORD *)a2 + 30) & 8) != 0 || *((unsigned __int8 *)a2 + 124) == v16)
        {
          if (v15 != a2)
            RB::RenderPass::~RenderPass(v15);
          v22 = (RB *)v14;
          v15 = a2;
        }
        else
        {
          v18 = RB::pixel_format_traits(v14, v8);
          v20 = (unsigned int *)((char *)v18 + 18);
          if ((v16 & 1) != 0)
            v20 = v18 + 6;
          v21 = (RB *)*v20;
          if (v21)
            v22 = v21;
          else
            v22 = (RB *)v14;
          v23 = (RB *)v14;
          v24 = RB::RenderParams::srgb_alpha(v17, v19);
          v26 = RB::pixel_format_traits((unint64_t)v22, v25);
          if (v22 == v23)
          {
            for (i = *(_QWORD *)(v10 + 16); i; i = *(_QWORD *)(i + 40))
            {
              v28 = *(int32x2_t **)(i + 16);
              v29 = v28[3];
              v30 = v28[4];
              *((int32x2_t *)a2 + 20) = v29;
              *((int32x2_t *)a2 + 21) = v30;
              if (v24)
                v31 = (v28[6].i8[1] & 1) == 0;
              else
                v31 = 0;
              RB::RenderPass::color_convert((uint64_t)a2, *((unsigned __int8 *)a2 + 124), v16, v31, v29);
            }
            RB::RenderPass::set_color_space((id ***)a2, v16);
            v14 = (unint64_t)v85;
            v22 = v85;
          }
          else
          {
            v32 = *((unsigned __int16 *)v26 + 2);
            v33 = *v26;
            if (v83 && *(RB **)(v83 + 56) == v22)
            {
              v13 = v84;
              v14 = (unint64_t)v85;
            }
            else
            {
              RB::Device::alloc_shared_texture_view(***(_QWORD ***)a2, *((MTLPixelFormat *)a2 + 1), v22, v16, v87);
              v34 = v87[0];
              v35 = v83;
              v87[0] = v83;
              if (v83)
              {
                v36 = *(_DWORD *)(v83 + 8) - 1;
                *(_DWORD *)(v83 + 8) = v36;
                if (!v36)
                  (*(void (**)(uint64_t))(*(_QWORD *)v35 + 8))(v35);
              }
              if (!v34)
                goto LABEL_82;
              v37 = v24 == (((v33 | (unint64_t)(v32 << 32)) >> 36) & 1);
              v38 = v81;
              v14 = (unint64_t)v85;
              if (!v37)
              {
                for (j = *(_QWORD *)(v10 + 16); j; j = *(_QWORD *)(j + 40))
                {
                  v40 = *(int32x2_t **)(j + 16);
                  if ((v40[6].i8[1] & 1) == 0)
                  {
                    v41 = v40[3];
                    v42 = v40[4];
                    *((int32x2_t *)a2 + 20) = v41;
                    *((int32x2_t *)a2 + 21) = v42;
                    RB::RenderPass::resolve_srgb_alpha(a2, v41);
                  }
                }
                HIDWORD(v84) = 1;
              }
              if (v15 == a2)
              {
                RB::RenderFrame::flush_pass(**(id ***)a2, a2, 1);
                MEMORY[0x24BDAC7A8](v43, v44);
                v15 = (RB::RenderPass *)(&v80 - 34);
                *(&v80 - 2) = 0;
                *((_OWORD *)&v80 - 3) = 0u;
                *((_OWORD *)&v80 - 2) = 0u;
                *((_OWORD *)&v80 - 5) = 0u;
                *((_OWORD *)&v80 - 4) = 0u;
                *((_OWORD *)&v80 - 7) = 0u;
                *((_OWORD *)&v80 - 6) = 0u;
                *((_OWORD *)&v80 - 9) = 0u;
                *((_OWORD *)&v80 - 8) = 0u;
                *((_OWORD *)&v80 - 11) = 0u;
                *((_OWORD *)&v80 - 10) = 0u;
                *((_OWORD *)&v80 - 13) = 0u;
                *((_OWORD *)&v80 - 12) = 0u;
                *((_OWORD *)&v80 - 15) = 0u;
                *((_OWORD *)&v80 - 14) = 0u;
                *((_OWORD *)&v80 - 16) = 0u;
                *((_OWORD *)&v80 - 17) = 0u;
              }
              else
              {
                RB::RenderPass::~RenderPass(v15);
              }
              RB::RenderPass::RenderPass(v15, *(_QWORD *)a2, v34, 0, 1, 0);
              v46 = 0;
              v47 = 1;
              do
              {
                v48 = v47;
                v49 = *((int *)&RB::Filter::RenderGroup::resolve(RB::RenderPass &)::aux_attachments + v46);
                v50 = *(RB::Resource **)&v38[24 * (int)v49];
                if (v50)
                  RB::RenderPass::set_attachment((uint64_t)v15, v49, v50, 0, 0);
                v47 = 0;
                v46 = 1;
              }
              while ((v48 & 1) != 0);
              RB::RenderPass::set_extra_attachments((uint64_t)v15, (MTLPixelFormat)(v82 & 0xF0), v45);
              v82 = (char *)(v82 & 0xFFFFFFF0);
              v83 = v34;
              v13 = v84;
            }
          }
        }
        v9.n128_u64[0] = *(_QWORD *)v10;
        v9 = RB::Device::alloc_shared_texture((_QWORD *)***(_QWORD ***)a2, v22, 1u, v16, 1, &v88, v9);
        if (v88)
        {
          RB::RenderPass::RenderPass(v87, *(_QWORD *)a2, v88, 0, 1, 0);
          v51 = (int)v86;
          RB::RenderPass::set_extra_attachments((uint64_t)v87, (MTLPixelFormat)(v86 & 0xF0), v52);
          v53 = 0;
          v86 = (char *)(v51 & 0xFFFFFFF0);
          v54 = v87;
          v55 = v15;
          do
          {
            v56 = v54;
            RB::RenderFrame::flush_pass(**(id ***)a2, v55, 1);
            if ((v53 & 1) != 0)
              v57 = CFSTR("RB: Packed filters [odd]");
            else
              v57 = CFSTR("RB: Packed filters [even]");
            RB::RenderPass::set_label((id *)v56, &v57->isa);
            v60 = *(uint64_t **)(v10 + 16);
            if (!v60)
              break;
            v61 = 0;
            do
            {
              v62 = v60[2];
              if (!*(_BYTE *)(v62 + 50))
              {
                v59.n128_u64[0] = v60[4];
                if (v56 == (uint64_t *)v15)
                {
                  v63 = *(_QWORD *)(v62 + 24);
                  v64 = (uint64_t *)(v62 + 32);
                  v58.n128_u64[0] = *(_QWORD *)(v62 + 16);
                }
                else
                {
                  v63 = v60[4];
                  v64 = v60;
                  v58.n128_u64[0] = v63;
                  v59.n128_u64[0] = *(_QWORD *)(v62 + 16);
                }
                v65 = *v64;
                v56[20] = v63;
                v56[21] = v65;
                v66 = (*(uint64_t (**)(_QWORD, uint64_t *, uint64_t, _QWORD, __n128, __n128))(**(_QWORD **)(v62 + 8) + 16))(*(_QWORD *)(v62 + 8), v56, v53, *((_QWORD *)v55 + 1), v58, v59);
                *(_BYTE *)(v62 + 50) = v66;
                *((float *)v56 + 30) = *((float *)v56 + 30) + 1.0;
                v61 = v61 & 1 | ((v66 & 1) == 0);
              }
              v60 = (uint64_t *)v60[5];
            }
            while (v60);
            v53 = (v53 + 1);
            v54 = (uint64_t *)v55;
            v55 = (RB::RenderPass *)v56;
          }
          while ((v61 & 1) != 0);
          RB::RenderPass::~RenderPass((RB::RenderPass *)v87);
          v13 = v84;
          v14 = (unint64_t)v85;
        }
        if ((v84 & 0x100000000) != 0)
        {
          for (k = *(_QWORD *)(v10 + 16); k; k = *(_QWORD *)(k + 40))
          {
            v68 = *(int32x2_t **)(k + 16);
            if ((v68[6].i8[1] & 1) == 0)
            {
              v69 = v68[3];
              v70 = v68[4];
              *((int32x2_t *)v15 + 20) = v69;
              *((int32x2_t *)v15 + 21) = v70;
              v9.n128_f32[0] = RB::RenderPass::resolve_srgb_alpha(v15, v69);
            }
          }
        }
        else if (*((unsigned __int8 *)a2 + 124) != v13)
        {
          for (m = *(_QWORD *)(v10 + 16); m; m = *(_QWORD *)(m + 40))
          {
            v72 = *(int32x2_t **)(m + 16);
            v73 = v72[3];
            v74 = v72[4];
            *((int32x2_t *)a2 + 20) = v73;
            *((int32x2_t *)a2 + 21) = v74;
            v75 = (*(_BYTE *)(*(_QWORD *)a2 + 30) & 1) != 0 && (v72[6].i8[1] & 1) == 0;
            RB::RenderPass::color_convert((uint64_t)a2, *((unsigned __int8 *)a2 + 124), v13, v75, v73);
          }
          RB::RenderPass::set_color_space((id ***)a2, v13);
        }
        v76 = v88;
        if (v88)
        {
          v77 = v88[1].i32[0] - 1;
          v88[1].i32[0] = v77;
          if (!v77)
            (*(void (**)(int32x2_t *, __n128))(*(_QWORD *)v76 + 8))(v76, v9);
        }
        v10 = *(_QWORD *)(v10 + 24);
      }
      while (v10);
      if (v15 != a2)
        RB::RenderPass::~RenderPass(v15);
      *((_QWORD *)a2 + 20) = v11;
      *((_QWORD *)a2 + 21) = v12;
      v78 = v83;
      if (v83)
      {
        v79 = *(_DWORD *)(v83 + 8) - 1;
        *(_DWORD *)(v83 + 8) = v79;
        if (!v79)
          (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
      }
    }
LABEL_82:
    RB::Heap::~Heap((RB::Heap *)v89);
  }
}

void sub_209B9E0AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  RB::Heap::~Heap((RB::Heap *)(v1 + 328));
  _Unwind_Resume(a1);
}

_DWORD *RB::Refcount<RB::RenderTask,unsigned int>::release(_DWORD *result)
{
  int v1;

  v1 = result[2] - 1;
  result[2] = v1;
  if (!v1)
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  return result;
}

void RB::DisplayList::LayerTask::~LayerTask(RB::DisplayList::LayerTask *this)
{
  RB::DisplayList::LayerTask::~LayerTask(this);
  JUMPOUT(0x20BD16544);
}

{
  void *v2;
  void *v3;
  void *v4;
  _DWORD *v5;
  int v6;
  _DWORD *v7;
  int v8;
  _DWORD *v9;
  int v10;
  _DWORD *v11;
  int v12;

  v2 = (void *)*((_QWORD *)this + 26);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 24);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 22);
  if (v4)
    free(v4);
  *(_QWORD *)this = off_24C224400;
  v5 = (_DWORD *)*((_QWORD *)this + 11);
  if (v5)
  {
    v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 8))(v5);
  }
  v7 = (_DWORD *)*((_QWORD *)this + 5);
  if (v7)
  {
    v8 = v7[2] - 1;
    v7[2] = v8;
    if (!v8)
      (*(void (**)(_DWORD *))(*(_QWORD *)v7 + 8))(v7);
  }
  v9 = (_DWORD *)*((_QWORD *)this + 4);
  if (v9)
  {
    v10 = v9[2] - 1;
    v9[2] = v10;
    if (!v10)
      (*(void (**)(_DWORD *))(*(_QWORD *)v9 + 8))(v9);
  }
  v11 = (_DWORD *)*((_QWORD *)this + 3);
  if (v11)
  {
    v12 = v11[2] - 1;
    v11[2] = v12;
    if (!v12)
      (*(void (**)(_DWORD *))(*(_QWORD *)v11 + 8))(v11);
  }
}

_DWORD *RB::Refcount<RB::RenderTaskTexture,unsigned int>::release(_DWORD *result)
{
  int v1;

  v1 = result[2] - 1;
  result[2] = v1;
  if (!v1)
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  return result;
}

void RB::DisplayList::RootTexture::~RootTexture(RB::DisplayList::RootTexture *this)
{
  _DWORD *v1;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  v1 = (_DWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2)
      (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  }
}

{
  _DWORD *v1;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  v1 = (_DWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2)
      (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  }
  JUMPOUT(0x20BD16544);
}

_DWORD *RB::DisplayList::PackedTexture::finalize(RB::DisplayList::PackedTexture *this)
{
  _DWORD *result;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  result = (_DWORD *)*((_QWORD *)this + 2);
  if (result)
  {
    v2 = result[2] - 1;
    result[2] = v2;
    if (!v2)
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void RB::DisplayList::PackedTexture::~PackedTexture(RB::DisplayList::PackedTexture *this)
{
  _DWORD *v1;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  v1 = (_DWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2)
      (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  }
}

{
  _DWORD *v1;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  v1 = (_DWORD *)*((_QWORD *)this + 2);
  if (v1)
  {
    v2 = v1[2] - 1;
    v1[2] = v2;
    if (!v2)
      (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  }
  JUMPOUT(0x20BD16544);
}

void RB::DisplayList::SpillItem::~SpillItem(RB::DisplayList::SpillItem *this)
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::SpillItem::type_id(RB::DisplayList::SpillItem *this)
{
  return 4;
}

float32x2_t RB::DisplayList::SpillItem::bounds(int32x2_t *this)
{
  uint32x2_t v1;

  v1 = (uint32x2_t)vceq_s32(this[7], (int32x2_t)0x8000000080000000);
  if ((vpmin_u32(v1, v1).u32[0] & 0x80000000) != 0)
    return (float32x2_t)0x100000001000000;
  else
    return vcvt_f32_s32(this[6]);
}

float RB::DisplayList::SpillItem::min_scale(RB::DisplayList::SpillItem *this)
{
  return 1.0;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(uint64_t result, unint64_t *a2, uint64_t a3, uint64_t a4, char a5)
{
  unint64_t *v7;
  uint64_t *v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  unint64_t *v17;
  __int128 v18;
  unint64_t v19;
  uint64_t *v20;
  char v21;
  BOOL v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;

  v7 = (unint64_t *)result;
LABEL_2:
  v8 = (uint64_t *)(a2 - 3);
  v9 = v7;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v7 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = 0xAAAAAAAAAAAAAAABLL * (a2 - v9);
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v8, v9);
        if ((result & 0x80) != 0)
        {
          v23 = *v9;
          *v9 = *(a2 - 3);
          *(a2 - 3) = v23;
          v24 = v9[1];
          v25 = v9[2];
          v26 = *(a2 - 1);
          v9[1] = *(a2 - 2);
          v9[2] = v26;
          *(a2 - 2) = v24;
          *(a2 - 1) = v25;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9, (uint64_t *)v9 + 3, v8);
      case 4uLL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9, (uint64_t *)v9 + 3, (uint64_t *)v9 + 6, v8);
      case 5uLL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9, (uint64_t *)v9 + 3, (uint64_t *)v9 + 6, (uint64_t *)v9 + 9, v8);
      default:
        if (v12 <= 575)
        {
          if ((a5 & 1) != 0)
            return std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)v9, a2);
          else
            return std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)v9, a2);
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = (uint64_t *)&v9[3 * (v13 >> 1)];
          if ((unint64_t)v12 < 0xC01)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)&v9[3 * (v13 >> 1)], (uint64_t *)v9, v8);
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9, (uint64_t *)&v9[3 * (v13 >> 1)], v8);
            v16 = v8;
            v17 = &v9[3 * v14];
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9 + 3, (uint64_t *)v17 - 3, (uint64_t *)a2 - 6);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9 + 6, (uint64_t *)&v9[3 * v14 + 3], (uint64_t *)a2 - 9);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v17 - 3, v15, (uint64_t *)&v9[3 * v14 + 3]);
            v18 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v18;
            v19 = v9[2];
            v9[2] = v17[2];
            v17[2] = v19;
            v8 = v16;
          }
          if ((a5 & 1) == 0
            && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v9 - 3, v9) & 0x80) == 0)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(v9, (uint64_t *)a2);
            v9 = (unint64_t *)result;
            goto LABEL_17;
          }
          v20 = (uint64_t *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(v9, a2);
          if ((v21 & 1) == 0)
            goto LABEL_15;
          v22 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t *)v9, v20);
          v9 = (unint64_t *)(v20 + 3);
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(v20 + 3, (uint64_t *)a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v22)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(v7, v20, a3, -v11, a5 & 1);
            v9 = (unint64_t *)(v20 + 3);
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = (unint64_t *)v20;
          if (v22)
            return result;
          goto LABEL_2;
        }
        if (v9 != a2)
          return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(v9, a2, a2, a3);
        return result;
    }
  }
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, unint64_t *a2)
{
  unint64_t *v3;
  unint64_t *v4;
  uint64_t v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v16;
  BOOL v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;

  if ((unint64_t *)result != a2)
  {
    v3 = (unint64_t *)result;
    v4 = (unint64_t *)(result + 24);
    if ((unint64_t *)(result + 24) != a2)
    {
      v5 = 0;
      v6 = (unint64_t *)result;
      do
      {
        v7 = v4;
        result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v4, v6);
        if ((result & 0x80) != 0)
        {
          v8 = *v7;
          v9 = v6[4];
          v10 = v6[5];
          v11 = v5;
          v12 = *v6;
          while (1)
          {
            v13 = (unint64_t *)((char *)v3 + v11);
            v14 = *(unint64_t *)((char *)v3 + v11 + 8);
            v15 = *(unint64_t *)((char *)v3 + v11 + 16);
            v13[3] = v12;
            v13[4] = v14;
            v13[5] = v15;
            if (!v11)
            {
              v16 = v3;
              goto LABEL_14;
            }
            v16 = v6;
            v12 = *(v13 - 3);
            v17 = v8 < v12;
            if (v8 == v12)
            {
              v18 = *(unint64_t *)((char *)v3 + v11 - 16);
              v19 = v9 == v18;
              v17 = v9 < v18;
              if (v19)
              {
                v20 = *(unint64_t *)((char *)v3 + v11 - 8);
                v19 = v10 == v20;
                v17 = v10 < v20;
                if (v19)
                  break;
              }
            }
            v6 -= 3;
            v11 -= 24;
            if (!v17)
              goto LABEL_14;
          }
          v16 = (unint64_t *)((char *)v3 + v11);
LABEL_14:
          *v16 = v8;
          v16[1] = v9;
          v16[2] = v10;
        }
        v4 = v7 + 3;
        v5 += 24;
        v6 = v7;
      }
      while (v7 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, unint64_t *a2)
{
  unint64_t *v3;
  unint64_t *v4;
  unint64_t *v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;

  if ((unint64_t *)result != a2)
  {
    v3 = (unint64_t *)result;
    v4 = (unint64_t *)(result + 24);
    if ((unint64_t *)(result + 24) != a2)
    {
      v5 = (unint64_t *)(result + 8);
      do
      {
        v6 = v4;
        result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v4, v3);
        if ((result & 0x80) != 0)
        {
          v7 = *v6;
          v8 = v3[4];
          v9 = v3[5];
          v10 = v5;
          v11 = *v3;
          do
          {
            v12 = v10;
            v13 = *v10;
            v14 = v10[1];
            v12[2] = v11;
            v12[3] = v13;
            v12[4] = v14;
            v11 = *(v12 - 4);
            v15 = v7 < v11;
            if (v7 == v11)
            {
              v16 = *(v12 - 3);
              v17 = v8 == v16;
              v15 = v8 < v16;
              if (v17)
              {
                v18 = *(v12 - 2);
                v17 = v9 == v18;
                v15 = v9 < v18;
                if (v17)
                  break;
              }
            }
            v10 = v12 - 3;
          }
          while (v15);
          *(v12 - 1) = v7;
          *v12 = v8;
          v12[1] = v9;
        }
        v4 = v6 + 3;
        v5 += 3;
        v3 = v6;
      }
      while (v6 + 3 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3)
{
  char v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v6 = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
  v7 = (char)std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
  if ((v6 & 0x80) == 0)
  {
    if ((v7 & 0x80000000) == 0)
      return 0;
    v17 = *a2;
    *a2 = *a3;
    *a3 = v17;
    v18 = a2[1];
    v19 = a3[2];
    a2[1] = a3[1];
    v16 = a2 + 2;
    v20 = a2[2];
    a2[2] = v19;
    a3[1] = v18;
    a3[2] = v20;
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1) & 0x80) == 0)return 1;
    v22 = *a1;
    *a1 = *a2;
    *a2 = v22;
    v23 = a1[1];
    a1[1] = a2[1];
    a2[1] = v23;
    v10 = a1 + 2;
LABEL_11:
    result = 2;
    goto LABEL_12;
  }
  v10 = a1 + 2;
  v9 = *a1;
  if ((v7 & 0x80000000) == 0)
  {
    *a1 = *a2;
    *a2 = v9;
    v10 = a2 + 2;
    v11 = a2[2];
    v12 = a1[1];
    v13 = a1[2];
    a1[1] = a2[1];
    a2[1] = v12;
    a1[2] = v11;
    a2[2] = v13;
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2) & 0x80) == 0)return 1;
    v14 = *a2;
    *a2 = *a3;
    *a3 = v14;
    v15 = a2[1];
    a2[1] = a3[1];
    a3[1] = v15;
    v16 = a3 + 2;
    goto LABEL_11;
  }
  *a1 = *a3;
  *a3 = v9;
  v21 = a1[1];
  a1[1] = a3[1];
  a3[1] = v21;
  v16 = a3 + 2;
  result = 1;
LABEL_12:
  v24 = *v10;
  *v10 = *v16;
  *v16 = v24;
  return result;
}

uint64_t *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(unint64_t *a1, uint64_t *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  unint64_t v7;
  unint64_t *v8;
  uint64_t *v9;
  char v10;
  unint64_t v11;
  BOOL v12;
  unint64_t v13;
  BOOL v14;
  unint64_t *v15;
  unint64_t v16;
  BOOL v17;
  char v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  BOOL v22;
  unint64_t *v23;
  BOOL v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  unint64_t v33;
  BOOL v34;
  char v35;
  unint64_t v36;
  BOOL v37;
  unint64_t v38;
  BOOL v39;
  unint64_t *v40;
  BOOL v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;

  v2 = *a1;
  v3 = a1[1];
  v4 = a1[2];
  v5 = *(a2 - 3);
  v12 = *a1 == v5;
  v6 = *a1 < v5;
  if (v12 && (v7 = *(a2 - 2), v12 = v3 == v7, v6 = v3 < v7, v12))
  {
    if (v4 < *(a2 - 1))
      goto LABEL_25;
  }
  else if (v6)
  {
LABEL_25:
    v15 = a1;
    v9 = (uint64_t *)a1;
    do
    {
      v16 = v9[3];
      v9 += 3;
      v17 = v2 == v16;
      if (v2 < v16)
        v18 = -1;
      else
        v18 = 1;
      if (v17)
      {
        v19 = v15[4];
        v20 = v3 == v19;
        v18 = v3 < v19 ? -1 : 1;
        if (v20)
        {
          v21 = v15[5];
          v22 = v4 == v21;
          v18 = v4 < v21 ? -1 : 1;
          if (v22)
            v18 = 0;
        }
      }
      v15 = (unint64_t *)v9;
    }
    while ((v18 & 0x80) == 0);
    goto LABEL_42;
  }
  v8 = a1 + 3;
  do
  {
    v9 = (uint64_t *)v8;
    if (v8 >= (unint64_t *)a2)
      break;
    if (v2 < *v8)
      v10 = -1;
    else
      v10 = 1;
    if (v2 == *v8)
    {
      v11 = v8[1];
      v12 = v3 == v11;
      v10 = v3 < v11 ? -1 : 1;
      if (v12)
      {
        v13 = v8[2];
        v14 = v4 == v13;
        v10 = v4 < v13 ? -1 : 1;
        if (v14)
          v10 = 0;
      }
    }
    v8 += 3;
  }
  while ((v10 & 0x80) == 0);
LABEL_42:
  if (v9 < a2)
  {
    v23 = (unint64_t *)(a2 - 3);
    do
    {
      a2 = (uint64_t *)v23;
      v24 = v2 < *v23;
      if (v2 == *v23)
      {
        v25 = v23[1];
        v12 = v3 == v25;
        v24 = v3 < v25;
        if (v12)
        {
          v26 = v23[2];
          v12 = v4 == v26;
          v24 = v4 < v26;
          if (v12)
            break;
        }
      }
      v23 -= 3;
    }
    while (v24);
  }
  if (v9 < a2)
  {
    v27 = *v9;
    v28 = *a2;
    do
    {
      *v9 = v28;
      *a2 = v27;
      v29 = v9[1];
      v30 = v9[2];
      v31 = a2[2];
      v9[1] = a2[1];
      v9[2] = v31;
      a2[1] = v29;
      a2[2] = v30;
      do
      {
        v32 = v9;
        v33 = v9[3];
        v9 += 3;
        v27 = v33;
        v34 = v2 == v33;
        if (v2 < v33)
          v35 = -1;
        else
          v35 = 1;
        if (v34)
        {
          v36 = v32[4];
          v37 = v3 == v36;
          v35 = v3 < v36 ? -1 : 1;
          if (v37)
          {
            v38 = v32[5];
            v39 = v4 == v38;
            v35 = v4 < v38 ? -1 : 1;
            if (v39)
              v35 = 0;
          }
        }
      }
      while ((v35 & 0x80) == 0);
      v40 = (unint64_t *)(a2 - 3);
      do
      {
        a2 = (uint64_t *)v40;
        v28 = *v40;
        v41 = v2 < *v40;
        if (v2 == *v40)
        {
          v42 = v40[1];
          v12 = v3 == v42;
          v41 = v3 < v42;
          if (v12)
          {
            v43 = v40[2];
            v12 = v4 == v43;
            v41 = v4 < v43;
            if (v12)
              break;
          }
        }
        v40 -= 3;
      }
      while (v41);
    }
    while (v9 < a2);
  }
  if (v9 - 3 != (uint64_t *)a1)
  {
    *a1 = *(v9 - 3);
    v44 = *(v9 - 1);
    a1[1] = *(v9 - 2);
    a1[2] = v44;
  }
  *(v9 - 3) = v2;
  *(v9 - 2) = v3;
  *(v9 - 1) = v4;
  return v9;
}

unint64_t *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::__less<void,void> &>(unint64_t *a1, _QWORD *a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  char *v7;
  unint64_t v8;
  BOOL v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  BOOL v15;
  char v16;
  unint64_t v17;
  BOOL v18;
  unint64_t v19;
  BOOL v20;
  unint64_t v21;
  BOOL v22;
  char v23;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  unint64_t *v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t *v34;
  BOOL v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  char v41;
  unint64_t v42;
  BOOL v43;
  unint64_t v44;
  BOOL v45;
  unint64_t v46;

  v2 = 0;
  v3 = *a1;
  v4 = a1[1];
  v5 = a1[2];
  do
  {
    v6 = v2;
    v7 = (char *)a1 + v2;
    v8 = *((_QWORD *)v7 + 3);
    v9 = v8 < v3;
    if (v8 == v3)
    {
      v10 = *((_QWORD *)v7 + 4);
      v15 = v10 == v4;
      v9 = v10 < v4;
      if (v15)
      {
        v11 = *(unint64_t *)((char *)a1 + v6 + 40);
        v15 = v11 == v5;
        v9 = v11 < v5;
        if (v15)
          break;
      }
    }
    v2 = v6 + 24;
  }
  while (v9);
  v12 = (unint64_t)a1 + v6 + 24;
  if (v6)
  {
    v13 = a2;
    do
    {
      v14 = *(v13 - 3);
      v13 -= 3;
      v15 = v14 == v3;
      if (v14 < v3)
        v16 = -1;
      else
        v16 = 1;
      if (v15)
      {
        v17 = *(a2 - 2);
        v18 = v17 == v4;
        v16 = v17 < v4 ? -1 : 1;
        if (v18)
        {
          v19 = *(a2 - 1);
          v20 = v19 == v5;
          v16 = v19 < v5 ? -1 : 1;
          if (v20)
            v16 = 0;
        }
      }
      a2 = v13;
    }
    while ((v16 & 0x80) == 0);
  }
  else
  {
    while (v12 < (unint64_t)a2)
    {
      v13 = a2 - 3;
      v21 = *(a2 - 3);
      v22 = v21 == v3;
      if (v21 < v3)
        v23 = -1;
      else
        v23 = 1;
      if (v22)
      {
        v24 = *(a2 - 2);
        v25 = v24 == v4;
        v23 = v24 < v4 ? -1 : 1;
        if (v25)
        {
          v26 = *(a2 - 1);
          v27 = v26 == v5;
          v23 = v26 < v5 ? -1 : 1;
          if (v27)
            v23 = 0;
        }
      }
      a2 -= 3;
      if (v23 < 0)
        goto LABEL_44;
    }
    v13 = a2;
  }
LABEL_44:
  if (v12 >= (unint64_t)v13)
  {
    v29 = (unint64_t *)v12;
  }
  else
  {
    v28 = *v13;
    v29 = (unint64_t *)v12;
    v30 = v13;
    do
    {
      *v29 = v28;
      *v30 = v8;
      v31 = v29[1];
      v32 = v29[2];
      v33 = v30[2];
      v29[1] = v30[1];
      v29[2] = v33;
      v30[1] = v31;
      v30[2] = v32;
      v34 = v29 + 3;
      do
      {
        v29 = v34;
        v8 = *v34;
        v35 = *v34 < v3;
        if (*v34 == v3)
        {
          v36 = v34[1];
          v15 = v36 == v4;
          v35 = v36 < v4;
          if (v15)
          {
            v37 = v34[2];
            v15 = v37 == v5;
            v35 = v37 < v5;
            if (v15)
              break;
          }
        }
        v34 += 3;
      }
      while (v35);
      do
      {
        v38 = v30;
        v39 = *(v30 - 3);
        v30 -= 3;
        v28 = v39;
        v40 = v39 == v3;
        if (v39 < v3)
          v41 = -1;
        else
          v41 = 1;
        if (v40)
        {
          v42 = *(v38 - 2);
          v43 = v42 == v4;
          v41 = v42 < v4 ? -1 : 1;
          if (v43)
          {
            v44 = *(v38 - 1);
            v45 = v44 == v5;
            v41 = v44 < v5 ? -1 : 1;
            if (v45)
              v41 = 0;
          }
        }
      }
      while ((v41 & 0x80) == 0);
    }
    while (v29 < v30);
  }
  if (v29 - 3 != a1)
  {
    *a1 = *(v29 - 3);
    v46 = *(v29 - 1);
    a1[1] = *(v29 - 2);
    a1[2] = v46;
  }
  *(v29 - 3) = v3;
  *(v29 - 2) = v4;
  *(v29 - 1) = v5;
  return v29 - 3;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2)
{
  unint64_t v4;
  _BOOL8 result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  int v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  _QWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *v22;
  BOOL v23;
  unint64_t v24;
  BOOL v25;
  unint64_t v26;

  v4 = 0xAAAAAAAAAAAAAAABLL * (a2 - a1);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2 - 3, a1) & 0x80) != 0)
      {
        v6 = *a1;
        *a1 = *(a2 - 3);
        *(a2 - 3) = v6;
        v7 = a1[1];
        v8 = a1[2];
        v9 = *(a2 - 1);
        a1[1] = *(a2 - 2);
        a1[2] = v9;
        *(a2 - 2) = v7;
        *(a2 - 1) = v8;
      }
      return 1;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a2 - 3);
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6, a2 - 3);
      return 1;
    case 5uLL:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6, a1 + 9, a2 - 3);
      return 1;
    default:
      v10 = a1 + 6;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a1 + 3, a1 + 6);
      v11 = a1 + 9;
      if (a1 + 9 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v11, v10) & 0x80) != 0)
    {
      v14 = *v11;
      v15 = v11[1];
      v16 = v11[2];
      v17 = v12;
      v18 = *v10;
      while (1)
      {
        v19 = (uint64_t *)((char *)a1 + v17);
        v20 = *(uint64_t *)((char *)a1 + v17 + 56);
        v21 = *(uint64_t *)((char *)a1 + v17 + 64);
        v19[9] = v18;
        v19[10] = v20;
        v19[11] = v21;
        if (v17 == -48)
        {
          v22 = a1;
          goto LABEL_16;
        }
        v22 = v10;
        v18 = v19[3];
        v23 = v14 < v18;
        if (v14 == v18)
        {
          v24 = *(uint64_t *)((char *)a1 + v17 + 32);
          v25 = v15 == v24;
          v23 = v15 < v24;
          if (v25)
          {
            v26 = *(uint64_t *)((char *)a1 + v17 + 40);
            v25 = v16 == v26;
            v23 = v16 < v26;
            if (v25)
              break;
          }
        }
        v10 -= 3;
        v17 -= 24;
        if (!v23)
          goto LABEL_16;
      }
      v22 = (uint64_t *)((char *)a1 + v17 + 48);
LABEL_16:
      *v22 = v14;
      v22[1] = v15;
      v22[2] = v16;
      if (++v13 == 8)
        return v11 + 3 == a2;
    }
    v10 = v11;
    v12 += 24;
    v11 += 3;
    if (v11 == a2)
      return 1;
  }
}

uint64_t std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(_QWORD *a1, _QWORD *a2)
{
  BOOL v3;
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  BOOL v9;
  unsigned int v10;

  v3 = *a1 == *a2;
  if (*a1 < *a2)
    result = 0xFFFFFFFFLL;
  else
    result = 1;
  if (v3)
  {
    v5 = a1[1];
    v6 = a2[1];
    result = v5 < v6 ? 0xFFFFFFFFLL : 1;
    if (v5 == v6)
    {
      v7 = a1[2];
      v8 = a2[2];
      v9 = v7 == v8;
      if (v7 < v8)
        v10 = -1;
      else
        v10 = 1;
      if (v9)
        return 0;
      else
        return v10;
    }
  }
  return result;
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a2, a3);
  result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a4, a3);
  if ((result & 0x80) != 0)
  {
    v9 = *a3;
    *a3 = *a4;
    *a4 = v9;
    v10 = a3[1];
    v11 = a3[2];
    v12 = a4[2];
    a3[1] = a4[1];
    a3[2] = v12;
    a4[1] = v10;
    a4[2] = v11;
    result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
    if ((result & 0x80) != 0)
    {
      v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      v14 = a2[1];
      v15 = a2[2];
      v16 = a3[2];
      a2[1] = a3[1];
      a2[2] = v16;
      a3[1] = v14;
      a3[2] = v15;
      result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
      if ((result & 0x80) != 0)
      {
        v17 = *a1;
        *a1 = *a2;
        *a2 = v17;
        v18 = a1[1];
        v19 = a1[2];
        v20 = a2[2];
        a1[1] = a2[1];
        a1[2] = v20;
        a2[1] = v18;
        a2[2] = v19;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4, uint64_t *a5)
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a2, a3, a4);
  result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a5, a4);
  if ((result & 0x80) != 0)
  {
    v11 = *a4;
    *a4 = *a5;
    *a5 = v11;
    v12 = a4[1];
    v13 = a4[2];
    v14 = a5[2];
    a4[1] = a5[1];
    a4[2] = v14;
    a5[1] = v12;
    a5[2] = v13;
    result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a4, a3);
    if ((result & 0x80) != 0)
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      v16 = a3[1];
      v17 = a3[2];
      v18 = a4[2];
      a3[1] = a4[1];
      a3[2] = v18;
      a4[1] = v16;
      a4[2] = v17;
      result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a3, a2);
      if ((result & 0x80) != 0)
      {
        v19 = *a2;
        *a2 = *a3;
        *a3 = v19;
        v20 = a2[1];
        v21 = a2[2];
        v22 = a3[2];
        a2[1] = a3[1];
        a2[2] = v22;
        a3[1] = v20;
        a3[2] = v21;
        result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(a2, a1);
        if ((result & 0x80) != 0)
        {
          v23 = *a1;
          *a1 = *a2;
          *a2 = v23;
          v24 = a1[1];
          v25 = a1[2];
          v26 = a2[2];
          a1[1] = a2[1];
          a1[2] = v26;
          a2[1] = v24;
          a2[2] = v25;
        }
      }
    }
  }
  return result;
}

unint64_t *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(unint64_t *a1, unint64_t *a2, unint64_t *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t *v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  int64_t v19;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;

  if (a1 != a2)
  {
    v8 = (char *)a2 - (char *)a1;
    v9 = ((char *)a2 - (char *)a1) / 24;
    if ((char *)a2 - (char *)a1 >= 25)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[3 * v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, a4, v9, v12);
        v12 -= 3;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if ((std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v14, a1) & 0x80) != 0)
        {
          v15 = *v14;
          *v14 = *a1;
          *a1 = v15;
          v16 = v14[1];
          v17 = v14[2];
          v18 = a1[2];
          v14[1] = a1[1];
          v14[2] = v18;
          a1[1] = v16;
          a1[2] = v17;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, a4, v9, a1);
        }
        v14 += 3;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 25)
    {
      v19 = v8 / 0x18uLL;
      v20 = a2 - 3;
      do
      {
        v22 = *a1;
        v21 = a1[1];
        v23 = a1[2];
        v24 = std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(a1, a4, v19);
        if (v20 == v24)
        {
          *v24 = v22;
          v24[1] = v21;
          v24[2] = v23;
        }
        else
        {
          *v24 = *v20;
          v25 = v20[2];
          v24[1] = v20[1];
          v24[2] = v25;
          *v20 = v22;
          v20[1] = v21;
          v20[2] = v23;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>((uint64_t)a1, (uint64_t)(v24 + 3), a4, 0xAAAAAAAAAAAAAAABLL * (v24 + 3 - a1));
        }
        v20 -= 3;
      }
      while (v19-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, uint64_t a2, uint64_t a3, unint64_t *a4)
{
  unint64_t v4;
  unint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  unint64_t *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  char v17;
  unint64_t v18;
  BOOL v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  unint64_t v23;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (uint64_t)(0xAAAAAAAAAAAAAAABLL * (((uint64_t)a4 - result) >> 3)))
    {
      v9 = (0x5555555555555556 * (((uint64_t)a4 - result) >> 3)) | 1;
      v10 = (unint64_t *)(result + 24 * v9);
      v11 = 0x5555555555555556 * (((uint64_t)a4 - result) >> 3) + 2;
      if (v11 < a3
        && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>((_QWORD *)(result + 24 * v9), v10 + 3) & 0x80u) != 0)
      {
        v10 += 3;
        v9 = v11;
      }
      result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v10, v5);
      if ((result & 0x80) == 0)
      {
        v12 = *v5;
        v22 = v5[2];
        v23 = v5[1];
        v13 = *v10;
        do
        {
          v14 = v5;
          v5 = v10;
          *v14 = v13;
          v15 = v10[2];
          v14[1] = v10[1];
          v14[2] = v15;
          if (v7 < v9)
            break;
          v16 = (2 * v9) | 1;
          v10 = (unint64_t *)(v6 + 24 * v16);
          if (2 * v9 + 2 >= a3)
          {
            v9 = (2 * v9) | 1;
          }
          else
          {
            result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>((_QWORD *)(v6 + 24 * v16), v10 + 3);
            if ((result & 0x80u) == 0)
            {
              v9 = (2 * v9) | 1;
            }
            else
            {
              v10 += 3;
              v9 = 2 * v9 + 2;
            }
          }
          v13 = *v10;
          if (*v10 < v12)
            v17 = -1;
          else
            v17 = 1;
          if (*v10 == v12)
          {
            v18 = v10[1];
            v19 = v18 == v23;
            v17 = v18 < v23 ? -1 : 1;
            if (v19)
            {
              v20 = v10[2];
              v21 = v20 == v22;
              if (v20 < v22)
                v17 = -1;
              else
                v17 = 1;
              if (v21)
                v17 = 0;
            }
          }
        }
        while ((v17 & 0x80) == 0);
        *v5 = v12;
        v5[1] = v23;
        v5[2] = v22;
      }
    }
  }
  return result;
}

_QWORD *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v5 = 0;
  v6 = a3 - 2;
  if (a3 < 2)
    v6 = a3 - 1;
  v7 = v6 >> 1;
  do
  {
    v8 = &a1[3 * v5 + 3];
    v9 = (2 * v5) | 1;
    v10 = 2 * v5 + 2;
    if (v10 < a3
      && (std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(&a1[3 * v5 + 3], &a1[3 * v5 + 6]) & 0x80u) != 0)
    {
      v8 += 3;
      v9 = v10;
    }
    *a1 = *v8;
    v11 = v8[2];
    a1[1] = v8[1];
    a1[2] = v11;
    a1 = v8;
    v5 = v9;
  }
  while (v9 <= v7);
  return v8;
}

uint64_t std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  BOOL v15;
  unint64_t v16;
  BOOL v17;
  unint64_t v18;

  if (a4 >= 2)
  {
    v5 = result;
    v6 = (unint64_t)(a4 - 2) >> 1;
    v7 = (unint64_t *)(result + 24 * v6);
    v8 = (unint64_t *)(a2 - 24);
    result = std::operator<=>[abi:nn180100]<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *,std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>(v7, (_QWORD *)(a2 - 24));
    if ((result & 0x80) != 0)
    {
      v9 = *(_QWORD *)(a2 - 24);
      v10 = *(_QWORD *)(a2 - 16);
      v11 = *(_QWORD *)(a2 - 8);
      v12 = *v7;
      do
      {
        v13 = v8;
        v8 = v7;
        *v13 = v12;
        v14 = v7[2];
        v13[1] = v7[1];
        v13[2] = v14;
        if (!v6)
          break;
        v6 = (v6 - 1) >> 1;
        v7 = (unint64_t *)(v5 + 24 * v6);
        v12 = *v7;
        v15 = *v7 < v9;
        if (*v7 == v9)
        {
          v16 = v7[1];
          v17 = v16 == v10;
          v15 = v16 < v10;
          if (v17)
          {
            v18 = *(_QWORD *)(v5 + 24 * v6 + 16);
            v17 = v18 == v11;
            v15 = v18 < v11;
            if (v17)
              break;
          }
        }
      }
      while (v15);
      *v8 = v9;
      v8[1] = v10;
      v8[2] = v11;
    }
  }
  return result;
}

unint64_t _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(unint64_t result, unint64_t a2, uint64_t a3, char a4)
{
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  int v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t *v23;
  int v24;
  unint64_t v25;
  unint64_t v26;
  BOOL v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  int v32;
  unint64_t v33;
  unint64_t v34;
  int v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  int v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  int v46;
  int v47;
  unint64_t v48;
  int v49;
  unint64_t v50;
  int v51;
  unint64_t v52;
  BOOL v54;
  uint64_t v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  unint64_t v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  int64_t v64;
  int64_t v65;
  int64_t v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  BOOL v70;
  unint64_t v71;
  unint64_t v72;
  int v73;
  uint64_t v74;
  uint64_t v75;
  unint64_t v76;
  int v77;
  unint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  uint64_t v82;
  unint64_t v83;
  uint64_t v84;
  uint64_t v85;
  unint64_t v86;
  int v87;
  uint64_t v88;
  _DWORD *v90;
  uint64_t v91;
  unint64_t v92;
  unint64_t v93;
  int v94;
  _DWORD *v95;
  _DWORD *v96;
  int v97;

  v7 = result;
LABEL_2:
  v8 = v7;
  while (2)
  {
    v7 = v8;
    v9 = a2 - v8;
    v10 = (uint64_t)(a2 - v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v38 = *(_QWORD *)(a2 - 16);
        v39 = *(_QWORD *)v8;
        if (v38 < *(_QWORD *)v8)
        {
          *(_QWORD *)v8 = v38;
          *(_QWORD *)(a2 - 16) = v39;
          v40 = *(_DWORD *)(v8 + 8);
          *(_DWORD *)(v8 + 8) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(a2 - 8) = v40;
        }
        return result;
      case 3uLL:
        return (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)v8, (unint64_t *)(v8 + 16), (unint64_t *)(a2 - 16));
      case 4uLL:
        return (unint64_t)_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(v8, v8 + 16, v8 + 32, a2 - 16);
      case 5uLL:
        result = (unint64_t)_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(v8, v8 + 16, v8 + 32, v8 + 48);
        v41 = *(_QWORD *)(a2 - 16);
        v42 = *(_QWORD *)(v8 + 48);
        if (v41 < v42)
        {
          *(_QWORD *)(v8 + 48) = v41;
          *(_QWORD *)(a2 - 16) = v42;
          v43 = *(_DWORD *)(v8 + 56);
          *(_DWORD *)(v8 + 56) = *(_DWORD *)(a2 - 8);
          *(_DWORD *)(a2 - 8) = v43;
          v44 = *(_QWORD *)(v8 + 48);
          v45 = *(_QWORD *)(v8 + 32);
          if (v44 < v45)
          {
            *(_QWORD *)(v8 + 32) = v44;
            *(_QWORD *)(v8 + 48) = v45;
            v46 = *(_DWORD *)(v8 + 40);
            v47 = *(_DWORD *)(v8 + 56);
            *(_DWORD *)(v8 + 40) = v47;
            *(_DWORD *)(v8 + 56) = v46;
            v48 = *(_QWORD *)(v8 + 16);
            if (v44 < v48)
            {
              *(_QWORD *)(v8 + 16) = v44;
              *(_QWORD *)(v8 + 32) = v48;
              v49 = *(_DWORD *)(v8 + 24);
              *(_DWORD *)(v8 + 24) = v47;
              *(_DWORD *)(v8 + 40) = v49;
              v50 = *(_QWORD *)v8;
              if (v44 < *(_QWORD *)v8)
              {
                *(_QWORD *)v8 = v44;
                *(_QWORD *)(v8 + 16) = v50;
                v51 = *(_DWORD *)(v8 + 8);
                *(_DWORD *)(v8 + 8) = v47;
                *(_DWORD *)(v8 + 24) = v51;
              }
            }
          }
        }
        return result;
      default:
        if (v9 <= 383)
        {
          v52 = v8 + 16;
          v54 = v8 == a2 || v52 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v54)
            {
              v55 = 0;
              v56 = v8;
              do
              {
                v57 = v52;
                v58 = *(_QWORD *)(v56 + 16);
                v59 = *(_QWORD *)v56;
                if (v58 < *(_QWORD *)v56)
                {
                  v60 = *(_DWORD *)(v56 + 24);
                  v61 = v55;
                  while (1)
                  {
                    v62 = v8 + v61;
                    *(_QWORD *)(v62 + 16) = v59;
                    *(_DWORD *)(v62 + 24) = *(_DWORD *)(v8 + v61 + 8);
                    if (!v61)
                      break;
                    v59 = *(_QWORD *)(v62 - 16);
                    v61 -= 16;
                    if (v58 >= v59)
                    {
                      v63 = v8 + v61 + 16;
                      goto LABEL_79;
                    }
                  }
                  v63 = v8;
LABEL_79:
                  *(_QWORD *)v63 = v58;
                  *(_DWORD *)(v63 + 8) = v60;
                }
                v52 = v57 + 16;
                v55 += 16;
                v56 = v57;
              }
              while (v57 + 16 != a2);
            }
          }
          else if (!v54)
          {
            v90 = (_DWORD *)(v8 + 24);
            do
            {
              v91 = v52;
              v92 = *(_QWORD *)(v7 + 16);
              v93 = *(_QWORD *)v7;
              if (v92 < *(_QWORD *)v7)
              {
                v94 = *(_DWORD *)(v7 + 24);
                v95 = v90;
                do
                {
                  v96 = v95;
                  *((_QWORD *)v95 - 1) = v93;
                  v97 = *(v95 - 4);
                  v95 -= 4;
                  *v96 = v97;
                  v93 = *((_QWORD *)v96 - 5);
                }
                while (v92 < v93);
                *((_QWORD *)v95 - 1) = v92;
                *v95 = v94;
              }
              v52 = v91 + 16;
              v90 += 4;
              v7 = v91;
            }
            while (v91 + 16 != a2);
          }
          return result;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v64 = (v10 - 2) >> 1;
            v65 = v64;
            do
            {
              v66 = v65;
              if (v64 >= v65)
              {
                v67 = (2 * v65) | 1;
                v68 = v8 + 16 * v67;
                if (2 * v66 + 2 >= (uint64_t)v10)
                {
                  v69 = *(_QWORD *)v68;
                }
                else
                {
                  v69 = *(_QWORD *)(v68 + 16);
                  v70 = *(_QWORD *)v68 >= v69;
                  if (*(_QWORD *)v68 < v69)
                    v68 += 16;
                  else
                    v69 = *(_QWORD *)v68;
                  if (!v70)
                    v67 = 2 * v66 + 2;
                }
                v71 = v8 + 16 * v66;
                v72 = *(_QWORD *)v71;
                if (v69 >= *(_QWORD *)v71)
                {
                  v73 = *(_DWORD *)(v71 + 8);
                  do
                  {
                    result = v71;
                    v71 = v68;
                    *(_QWORD *)result = v69;
                    *(_DWORD *)(result + 8) = *(_DWORD *)(v68 + 8);
                    if (v64 < v67)
                      break;
                    result = (2 * v67) | 1;
                    v68 = v8 + 16 * result;
                    v67 = 2 * v67 + 2;
                    if (v67 >= (uint64_t)v10)
                    {
                      v69 = *(_QWORD *)v68;
                      v67 = result;
                    }
                    else
                    {
                      v69 = *(_QWORD *)v68;
                      if (*(_QWORD *)v68 >= *(_QWORD *)(v68 + 16))
                      {
                        v67 = result;
                      }
                      else
                      {
                        v69 = *(_QWORD *)(v68 + 16);
                        v68 += 16;
                      }
                    }
                  }
                  while (v69 >= v72);
                  *(_QWORD *)v71 = v72;
                  *(_DWORD *)(v71 + 8) = v73;
                }
              }
              v65 = v66 - 1;
            }
            while (v66);
            v74 = (unint64_t)v9 >> 4;
            do
            {
              v75 = 0;
              v76 = *(_QWORD *)v8;
              v77 = *(_DWORD *)(v8 + 8);
              v78 = v8;
              do
              {
                v79 = v78 + 16 * v75 + 16;
                v80 = (2 * v75) | 1;
                v75 = 2 * v75 + 2;
                if (v75 >= v74)
                {
                  v81 = *(_QWORD *)v79;
                  v75 = v80;
                }
                else
                {
                  v81 = *(_QWORD *)v79;
                  result = *(_QWORD *)(v79 + 16);
                  if (*(_QWORD *)v79 >= result)
                  {
                    v75 = v80;
                  }
                  else
                  {
                    v81 = *(_QWORD *)(v79 + 16);
                    v79 += 16;
                  }
                }
                *(_QWORD *)v78 = v81;
                *(_DWORD *)(v78 + 8) = *(_DWORD *)(v79 + 8);
                v78 = v79;
              }
              while (v75 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
              if (v79 == a2 - 16)
              {
                *(_QWORD *)v79 = v76;
                *(_DWORD *)(v79 + 8) = v77;
              }
              else
              {
                *(_QWORD *)v79 = *(_QWORD *)(a2 - 16);
                *(_DWORD *)(v79 + 8) = *(_DWORD *)(a2 - 8);
                *(_QWORD *)(a2 - 16) = v76;
                *(_DWORD *)(a2 - 8) = v77;
                v82 = v79 - v8 + 16;
                if (v82 >= 17)
                {
                  v83 = (((unint64_t)v82 >> 4) - 2) >> 1;
                  v84 = v8 + 16 * v83;
                  v85 = *(_QWORD *)v84;
                  v86 = *(_QWORD *)v79;
                  if (*(_QWORD *)v84 < *(_QWORD *)v79)
                  {
                    v87 = *(_DWORD *)(v79 + 8);
                    do
                    {
                      v88 = v79;
                      v79 = v84;
                      *(_QWORD *)v88 = v85;
                      *(_DWORD *)(v88 + 8) = *(_DWORD *)(v84 + 8);
                      if (!v83)
                        break;
                      v83 = (v83 - 1) >> 1;
                      v84 = v8 + 16 * v83;
                      v85 = *(_QWORD *)v84;
                    }
                    while (*(_QWORD *)v84 < v86);
                    *(_QWORD *)v79 = v86;
                    *(_DWORD *)(v79 + 8) = v87;
                  }
                }
              }
              a2 -= 16;
            }
            while (v74-- > 2);
          }
          return result;
        }
        v11 = v10 >> 1;
        v12 = v8 + 16 * (v10 >> 1);
        if ((unint64_t)v9 < 0x801)
        {
          result = (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v7 + 16 * (v10 >> 1)), (unint64_t *)v7, (unint64_t *)(a2 - 16));
        }
        else
        {
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)v7, (unint64_t *)(v7 + 16 * (v10 >> 1)), (unint64_t *)(a2 - 16));
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v7 + 16), (unint64_t *)(v12 - 16), (unint64_t *)(a2 - 32));
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v7 + 32), (unint64_t *)(v7 + 16 + 16 * v11), (unint64_t *)(a2 - 48));
          result = (unint64_t)_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)(v12 - 16), (unint64_t *)v12, (unint64_t *)(v7 + 16 + 16 * v11));
          v13 = *(_QWORD *)v7;
          *(_QWORD *)v7 = *(_QWORD *)v12;
          *(_QWORD *)v12 = v13;
          LODWORD(v13) = *(_DWORD *)(v7 + 8);
          *(_DWORD *)(v7 + 8) = *(_DWORD *)(v12 + 8);
          *(_DWORD *)(v12 + 8) = v13;
        }
        --a3;
        v14 = *(_QWORD *)v7;
        if ((a4 & 1) == 0 && *(_QWORD *)(v7 - 16) >= v14)
        {
          if (v14 >= *(_QWORD *)(a2 - 16))
          {
            v29 = v7 + 16;
            do
            {
              v8 = v29;
              if (v29 >= a2)
                break;
              v29 += 16;
            }
            while (v14 >= *(_QWORD *)v8);
          }
          else
          {
            v8 = v7;
            do
            {
              v28 = *(_QWORD *)(v8 + 16);
              v8 += 16;
            }
            while (v14 >= v28);
          }
          v30 = a2;
          if (v8 < a2)
          {
            v30 = a2;
            do
            {
              v31 = *(_QWORD *)(v30 - 16);
              v30 -= 16;
            }
            while (v14 < v31);
          }
          v32 = *(_DWORD *)(v7 + 8);
          if (v8 < v30)
          {
            v33 = *(_QWORD *)v8;
            v34 = *(_QWORD *)v30;
            do
            {
              *(_QWORD *)v8 = v34;
              *(_QWORD *)v30 = v33;
              v35 = *(_DWORD *)(v8 + 8);
              *(_DWORD *)(v8 + 8) = *(_DWORD *)(v30 + 8);
              *(_DWORD *)(v30 + 8) = v35;
              do
              {
                v36 = *(_QWORD *)(v8 + 16);
                v8 += 16;
                v33 = v36;
              }
              while (v14 >= v36);
              do
              {
                v37 = *(_QWORD *)(v30 - 16);
                v30 -= 16;
                v34 = v37;
              }
              while (v14 < v37);
            }
            while (v8 < v30);
          }
          if (v8 - 16 != v7)
          {
            *(_QWORD *)v7 = *(_QWORD *)(v8 - 16);
            *(_DWORD *)(v7 + 8) = *(_DWORD *)(v8 - 8);
          }
          a4 = 0;
          *(_QWORD *)(v8 - 16) = v14;
          *(_DWORD *)(v8 - 8) = v32;
          continue;
        }
        v15 = 0;
        v16 = *(_DWORD *)(v7 + 8);
        do
        {
          v17 = *(_QWORD *)(v7 + v15 + 16);
          v15 += 16;
        }
        while (v17 < v14);
        v18 = v7 + v15;
        v19 = (unint64_t *)a2;
        if (v15 == 16)
        {
          v19 = (unint64_t *)a2;
          do
          {
            if (v18 >= (unint64_t)v19)
              break;
            v21 = *(v19 - 2);
            v19 -= 2;
          }
          while (v21 >= v14);
        }
        else
        {
          do
          {
            v20 = *(v19 - 2);
            v19 -= 2;
          }
          while (v20 >= v14);
        }
        if (v18 >= (unint64_t)v19)
        {
          v8 = v7 + v15;
        }
        else
        {
          v22 = *v19;
          v8 = v7 + v15;
          v23 = v19;
          do
          {
            *(_QWORD *)v8 = v22;
            *v23 = v17;
            v24 = *(_DWORD *)(v8 + 8);
            *(_DWORD *)(v8 + 8) = *((_DWORD *)v23 + 2);
            *((_DWORD *)v23 + 2) = v24;
            do
            {
              v25 = *(_QWORD *)(v8 + 16);
              v8 += 16;
              v17 = v25;
            }
            while (v25 < v14);
            do
            {
              v26 = *(v23 - 2);
              v23 -= 2;
              v22 = v26;
            }
            while (v26 >= v14);
          }
          while (v8 < (unint64_t)v23);
        }
        if (v8 - 16 != v7)
        {
          *(_QWORD *)v7 = *(_QWORD *)(v8 - 16);
          *(_DWORD *)(v7 + 8) = *(_DWORD *)(v8 - 8);
        }
        *(_QWORD *)(v8 - 16) = v14;
        *(_DWORD *)(v8 - 8) = v16;
        if (v18 < (unint64_t)v19)
        {
LABEL_32:
          result = _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(v7, v8 - 16, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v27 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(v7, v8 - 16);
        result = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(v8, a2);
        if (!(_DWORD)result)
        {
          if (v27)
            continue;
          goto LABEL_32;
        }
        a2 = v8 - 16;
        if (!v27)
          goto LABEL_2;
        return result;
    }
  }
}

unint64_t *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_(unint64_t *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  unint64_t v8;
  int v9;
  int v10;

  v3 = *a2;
  v4 = *result;
  v5 = *a3;
  if (*a2 >= *result)
  {
    if (v5 < v3)
    {
      *a2 = v5;
      *a3 = v3;
      v7 = *((_DWORD *)a2 + 2);
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a3 + 2) = v7;
      v8 = *result;
      if (*a2 < *result)
      {
        *result = *a2;
        *a2 = v8;
        v9 = *((_DWORD *)result + 2);
        *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
        *((_DWORD *)a2 + 2) = v9;
      }
    }
  }
  else if (v5 >= v3)
  {
    *result = v3;
    *a2 = v4;
    v10 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = *((_DWORD *)a2 + 2);
    *((_DWORD *)a2 + 2) = v10;
    if (*a3 < v4)
    {
      *a2 = *a3;
      *a3 = v4;
      *((_DWORD *)a2 + 2) = *((_DWORD *)a3 + 2);
      *((_DWORD *)a3 + 2) = v10;
    }
  }
  else
  {
    *result = v5;
    *a3 = v4;
    v6 = *((_DWORD *)result + 2);
    *((_DWORD *)result + 2) = *((_DWORD *)a3 + 2);
    *((_DWORD *)a3 + 2) = v6;
  }
  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEbT1_SL_T0_(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  int v25;
  unint64_t v26;
  int v27;
  unint64_t v28;
  int v29;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(_QWORD *)(a2 - 16);
      v7 = *(_QWORD *)a1;
      if (v6 < *(_QWORD *)a1)
      {
        *(_QWORD *)a1 = v6;
        *(_QWORD *)(a2 - 16) = v7;
        v8 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v8;
      }
      return result;
    case 3:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a2 - 16));
      return 1;
    case 4:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(a1, a1 + 16, a1 + 32, a1 + 48);
      v19 = *(_QWORD *)(a2 - 16);
      v20 = *(_QWORD *)(a1 + 48);
      if (v19 < v20)
      {
        *(_QWORD *)(a1 + 48) = v19;
        *(_QWORD *)(a2 - 16) = v20;
        v21 = *(_DWORD *)(a1 + 56);
        *(_DWORD *)(a1 + 56) = *(_DWORD *)(a2 - 8);
        *(_DWORD *)(a2 - 8) = v21;
        v22 = *(_QWORD *)(a1 + 48);
        v23 = *(_QWORD *)(a1 + 32);
        if (v22 < v23)
        {
          *(_QWORD *)(a1 + 32) = v22;
          *(_QWORD *)(a1 + 48) = v23;
          v24 = *(_DWORD *)(a1 + 40);
          v25 = *(_DWORD *)(a1 + 56);
          *(_DWORD *)(a1 + 40) = v25;
          *(_DWORD *)(a1 + 56) = v24;
          v26 = *(_QWORD *)(a1 + 16);
          if (v22 < v26)
          {
            *(_QWORD *)(a1 + 16) = v22;
            *(_QWORD *)(a1 + 32) = v26;
            v27 = *(_DWORD *)(a1 + 24);
            *(_DWORD *)(a1 + 24) = v25;
            *(_DWORD *)(a1 + 40) = v27;
            v28 = *(_QWORD *)a1;
            if (v22 < *(_QWORD *)a1)
            {
              *(_QWORD *)a1 = v22;
              *(_QWORD *)(a1 + 16) = v28;
              v29 = *(_DWORD *)(a1 + 8);
              *(_DWORD *)(a1 + 8) = v25;
              *(_DWORD *)(a1 + 24) = v29;
            }
          }
        }
      }
      return 1;
    default:
      v9 = (unint64_t *)(a1 + 32);
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)(a1 + 16), (unint64_t *)(a1 + 32));
      v10 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(_QWORD *)v10;
    v14 = *v9;
    if (*(_QWORD *)v10 < *v9)
    {
      v15 = *(_DWORD *)(v10 + 8);
      v16 = v11;
      while (1)
      {
        v17 = a1 + v16;
        *(_QWORD *)(v17 + 48) = v14;
        *(_DWORD *)(v17 + 56) = *(_DWORD *)(a1 + v16 + 40);
        if (v16 == -32)
          break;
        v14 = *(_QWORD *)(v17 + 16);
        v16 -= 16;
        if (v13 >= v14)
        {
          v18 = a1 + v16 + 48;
          goto LABEL_13;
        }
      }
      v18 = a1;
LABEL_13:
      *(_QWORD *)v18 = v13;
      *(_DWORD *)(v18 + 8) = v15;
      if (++v12 == 8)
        return v10 + 16 == a2;
    }
    v9 = (unint64_t *)v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2)
      return 1;
  }
}

unint64_t *_ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEvT1_SL_SL_SL_T0_(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t *result;
  unint64_t v9;
  int v10;
  unint64_t v11;
  int v12;
  unint64_t v13;
  int v14;

  result = _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEEEEjT1_SL_SL_T0_((unint64_t *)a1, (unint64_t *)a2, (unint64_t *)a3);
  v9 = *(_QWORD *)a3;
  if (*(_QWORD *)a4 < *(_QWORD *)a3)
  {
    *(_QWORD *)a3 = *(_QWORD *)a4;
    *(_QWORD *)a4 = v9;
    v10 = *(_DWORD *)(a3 + 8);
    *(_DWORD *)(a3 + 8) = *(_DWORD *)(a4 + 8);
    *(_DWORD *)(a4 + 8) = v10;
    v11 = *(_QWORD *)a2;
    if (*(_QWORD *)a3 < *(_QWORD *)a2)
    {
      *(_QWORD *)a2 = *(_QWORD *)a3;
      *(_QWORD *)a3 = v11;
      v12 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)(a2 + 8) = *(_DWORD *)(a3 + 8);
      *(_DWORD *)(a3 + 8) = v12;
      v13 = *(_QWORD *)a1;
      if (*(_QWORD *)a2 < *(_QWORD *)a1)
      {
        *(_QWORD *)a1 = *(_QWORD *)a2;
        *(_QWORD *)a2 = v13;
        v14 = *(_DWORD *)(a1 + 8);
        *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
        *(_DWORD *)(a2 + 8) = v14;
      }
    }
  }
  return result;
}

uint64_t RB::Refcount<RB::RenderTask,unsigned int>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t RB::Refcount<RB::RenderTaskTexture,unsigned int>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t _ZZNK2RB5TableIPKNS_11DisplayList5LayerEPNS_6BoundsEE8for_eachIZNKS2_9make_taskERNS1_11RenderStateES5_PKS5_jPKNS1_4ItemEPKDv4_fE3__4EEvT_ENUlPKvSM_PvE_8__invokeESM_SM_SN_(uint64_t a1, double *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;
  int v7;
  uint64_t v8;

  v4 = *(unsigned int *)(a3 + 24);
  v5 = *(_QWORD *)a3;
  RB::DisplayList::Layer::make_task(&v8, a1, *(_QWORD *)(a3 + 16), *(_QWORD *)(a3 + 8), 2, 0, 0, *a2, a2[1]);
  RB::DisplayList::LayerTask::add_task(v5, a1, v4, &v8);
  result = v8;
  if (v8)
  {
    v7 = *(_DWORD *)(v8 + 8) - 1;
    *(_DWORD *)(v8 + 8) = v7;
    if (!v7)
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void sub_209BA03A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    RB::DisplayList::LayerTask::append_task(a10);
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,48ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::vector<RB::Filter::RenderGroup::MultipassInfo,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,56ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,56ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(56 * a3);
    v6 = v5 / 0x38;
    if (v5 / 0x38 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t OUTLINED_FUNCTION_0_0(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

uint64_t RB::ProtobufEncoder::uuid_field(RB::ProtobufEncoder *this, uint64_t a2, const UUID *uu)
{
  uint64_t result;

  result = uuid_is_null((const unsigned __int8 *)uu);
  if (!(_DWORD)result)
  {
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    return (uint64_t)RB::ProtobufEncoder::encode_data(this, uu, 0x10uLL);
  }
  return result;
}

void RB::ProtobufDecoder::uuid_field(RB::ProtobufDecoder *a1, uint64_t a2, _OWORD *a3)
{
  uint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  char in[16];
  __int128 v11;
  int v12;
  char v13;
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v4 = RB::ProtobufDecoder::data_field(a1, a2);
  if (v5 == 36)
  {
    v7 = *(_OWORD *)v4;
    v8 = *(_OWORD *)(v4 + 16);
    v12 = *(_DWORD *)(v4 + 32);
    *(_OWORD *)in = v7;
    v11 = v8;
    v13 = 0;
    if (uuid_parse(in, (unsigned __int8 *)&v9))
      uuid_clear((unsigned __int8 *)&v9);
    v6 = v9;
  }
  else
  {
    if (v5 != 16)
      return;
    v6 = *(_OWORD *)v4;
  }
  *a3 = v6;
}

unsigned int *RB::Identity::encode(unsigned int *this, RB::Encoder *a2)
{
  unint64_t v2;
  unsigned int *v4;

  v2 = *this;
  if ((_DWORD)v2)
  {
    v4 = this;
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    RB::ProtobufEncoder::encode_varint(a2, v2);
    return (unsigned int *)RB::ProtobufEncoder::uuid_field(a2, 2, (const UUID *)(v4 + 1));
  }
  return this;
}

__n128 RB::Identity::decode(uint64_t a1, RB::ProtobufDecoder *this)
{
  uint64_t field;
  unint64_t v5;
  char v6;
  __n128 result;

  field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
LABEL_12:
    result = *((__n128 *)this + 13);
    *(__n128 *)(a1 + 4) = result;
    return result;
  }
  v5 = field;
  v6 = 0;
  do
  {
    while ((v5 >> 3) != 1)
    {
      if ((v5 >> 3) != 2)
      {
        RB::ProtobufDecoder::skip_field(this, v5);
        goto LABEL_7;
      }
      RB::ProtobufDecoder::uuid_field(this, v5, (_OWORD *)(a1 + 4));
      v5 = RB::ProtobufDecoder::next_field(this);
      v6 = 1;
      if (!v5)
        return result;
    }
    *(_DWORD *)a1 = RB::ProtobufDecoder::uint_field(this, v5);
LABEL_7:
    v5 = RB::ProtobufDecoder::next_field(this);
  }
  while (v5);
  if ((v6 & 1) == 0)
    goto LABEL_12;
  return result;
}

RB::TextIdentity *RB::TextIdentity::TextIdentity(RB::TextIdentity *this, CTRunRef run, unsigned int a3, unsigned int a4)
{
  char Status;
  const CFIndex *StringIndicesPtr;
  const CFIndex *v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  size_t v14;
  char *v15;
  uint64_t v16;
  _DWORD *v17;
  _QWORD v19[2];
  CFRange v20;

  v19[1] = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)this = 4 * a4;
  Status = CTRunGetStatus(run);
  if ((Status & 1) != 0)
    *(_DWORD *)this |= 1u;
  if ((Status & 2) != 0)
    *(_DWORD *)this |= 2u;
  StringIndicesPtr = CTRunGetStringIndicesPtr(run);
  if (!StringIndicesPtr)
  {
    if (a4 >= 0x201)
    {
      v15 = (char *)malloc_type_malloc(8 * a4, 0xBB718847uLL);
      if (!v15)
      {
        bzero((char *)this + 4, 4 * (a4 - 1) + 4);
        goto LABEL_19;
      }
    }
    else
    {
      MEMORY[0x24BDAC7A8](0, 8 * a4);
      v15 = (char *)v19 - ((v14 + 15) & 0xFFFFFFFF0);
      bzero(v15, v14);
    }
    v20.location = a3;
    v20.length = a4;
    CTRunGetStringIndices(run, v20, (CFIndex *)v15);
    if (!a4)
      return this;
    v16 = 0;
    v17 = (_DWORD *)((char *)this + 4);
    do
    {
      *v17++ = *(_QWORD *)&v15[v16];
      v16 += 8;
    }
    while (8 * a4 != v16);
    if (a4 < 0x201)
      return this;
LABEL_19:
    free(v15);
    return this;
  }
  if (a4)
  {
    v10 = &StringIndicesPtr[a3];
    v11 = (_DWORD *)((char *)this + 4);
    v12 = 8 * a4;
    do
    {
      v13 = *v10++;
      *v11++ = v13;
      v12 -= 8;
    }
    while (v12);
  }
  return this;
}

int *RB::TextIdentity::TextIdentity(int *a1, _DWORD *a2, int a3, unsigned int a4)
{
  *a1 = *a2 & 3 | (4 * a4);
  if (a4)
    memmove(a1 + 1, &a2[a3 + 1], 4 * a4);
  return a1;
}

BOOL RB::TextIdentity::operator==(_DWORD *a1, _DWORD *a2)
{
  return *a1 == *a2 && memcmp(a1 + 1, a2 + 1, *a1 & 0xFFFFFFFC) == 0;
}

_DWORD *RB::TextIdentity::copy_atoms(RB::TextIdentity *this, RB::Heap *a2, unsigned int a3, unsigned int a4)
{
  unsigned int v4;
  BOOL v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v10;
  _DWORD *v11;
  _DWORD *v12;

  v4 = *(_DWORD *)this >> 2;
  v5 = v4 >= a3;
  v6 = v4 - a3;
  if (v6 == 0 || !v5)
    return 0;
  v7 = v6 >= a4 ? a4 : v6;
  if (!v7)
    return 0;
  v10 = v7;
  v11 = (_DWORD *)((*((_QWORD *)a2 + 2) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  v12 = &v11[v10 + 1];
  if ((unint64_t)v12 > *((_QWORD *)a2 + 3))
    v11 = (_DWORD *)RB::Heap::alloc_slow((size_t *)a2, v10 * 4 + 4, 3);
  else
    *((_QWORD *)a2 + 2) = v12;
  *v11 = 4 * v7;
  memmove(v11 + 1, (char *)this + 4 * a3 + 4, 4 * v7);
  return v11;
}

_QWORD *RB::TextIdentity::encode(RB::TextIdentity *this, RB::Encoder *a2)
{
  _QWORD *result;
  unsigned int v5;

  result = RB::ProtobufEncoder::packed_uint32_field(a2, 1, (unsigned int *)this + 1, (unint64_t)*(unsigned int *)this >> 2);
  v5 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v5 = *(_DWORD *)this;
  }
  if ((v5 & 2) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  return result;
}

_DWORD *RB::TextIdentity::decode(size_t **this)
{
  int v2;
  unint64_t field;
  unint64_t v4;
  int v5;
  int v6;
  _BYTE *v7;
  int v8;
  int v9;
  _DWORD *v10;
  size_t *v11;
  size_t v12;
  _BYTE *v13;
  _BYTE __dst[1024];
  void *v16;
  uint64_t v17;
  uint64_t v18;

  v2 = 0;
  v18 = *MEMORY[0x24BDAC8D0];
  v16 = 0;
  v17 = 0x10000000000;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    if (!field)
      break;
    v4 = field >> 3;
    if ((field >> 3) == 1)
    {
      v5 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
      v6 = v17;
      if (HIDWORD(v17) < (v17 + 1))
      {
        RB::vector<unsigned int,256ul,unsigned int>::reserve_slow(__dst, v17 + 1);
        v6 = v17;
      }
      v7 = v16;
      if (!v16)
        v7 = __dst;
      *(_DWORD *)&v7[4 * v6] = v5;
      LODWORD(v17) = v17 + 1;
    }
    else if ((_DWORD)v4 == 2)
    {
      v2 |= RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
    }
    else if ((_DWORD)v4 == 3)
    {
      if (RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field))
        v8 = 2;
      else
        v8 = 0;
      v2 |= v8;
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
    }
  }
  v9 = v17;
  if (v17 | v2)
  {
    v11 = this[8];
    v12 = 4 * v17 + 4;
    v10 = (_DWORD *)((v11[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    if ((unint64_t)v10 + v12 > v11[3])
      v10 = (_DWORD *)RB::Heap::alloc_slow(v11, v12, 3);
    else
      v11[2] = (size_t)v10 + v12;
    *v10 = v2 & 3 | (4 * v9);
    if ((_DWORD)v17)
    {
      if (v16)
        v13 = v16;
      else
        v13 = __dst;
      memmove(v10 + 1, v13, 4 * v17);
    }
  }
  else
  {
    v10 = 0;
  }
  if (v16)
    free(v16);
  return v10;
}

void sub_209BA0C0C(_Unwind_Exception *a1)
{
  if (STACK[0x408])
    free((void *)STACK[0x408]);
  _Unwind_Resume(a1);
}

void RB::TextIdentity::print(RB::TextIdentity *this, std::string *a2)
{
  unsigned int v4;
  unsigned int v5;
  char *v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  std::string::size_type size;
  size_t v13;
  std::string *v14;
  std::string v15;
  char __s[64];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  RB::SexpString::push(a2, "text-identity");
  v4 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 1) != 0)
  {
    RB::SexpString::print(a2, 0, "right-to-left");
    v4 = *(_DWORD *)this;
  }
  if ((v4 & 2) != 0)
  {
    RB::SexpString::print(a2, 0, "non-contiguous");
    v4 = *(_DWORD *)this;
  }
  if (v4 >= 4)
  {
    v5 = 0;
    memset(&v15, 0, sizeof(v15));
    v6 = (char *)this + 4;
    v7 = v4 >> 2;
    do
    {
      if (v5 + 1 >= v7)
        goto LABEL_15;
      v8 = v7;
      v9 = v5;
      v10 = *(_DWORD *)&v6[4 * v5] + 1;
      v11 = v5;
      while (v10 == *((_DWORD *)this + v11 + 2))
      {
        ++v11;
        ++v10;
        if (v8 - 1 == v11)
          goto LABEL_13;
      }
      LODWORD(v8) = v11 + 1;
LABEL_13:
      if (v8 <= v5 + 1)
      {
LABEL_15:
        snprintf_l(__s, 0x40uLL, 0, "%u", *(_DWORD *)&v6[4 * v5]);
      }
      else
      {
        v5 = v8 - 1;
        snprintf_l(__s, 0x40uLL, 0, "(%u . %u)", *(_DWORD *)&v6[4 * v9], *(_DWORD *)&v6[4 * (v8 - 1)]);
      }
      size = HIBYTE(v15.__r_.__value_.__r.__words[2]);
      if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
        size = v15.__r_.__value_.__l.__size_;
      if (size)
        std::string::push_back(&v15, 32);
      v13 = strlen(__s);
      std::string::append(&v15, __s, v13);
      ++v5;
      v7 = *(_DWORD *)this >> 2;
    }
    while (v5 < v7);
    v14 = (std::string *)v15.__r_.__value_.__r.__words[0];
    if ((v15.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v14 = &v15;
    RB::SexpString::printf(a2, 0, "(char-indices %s)", (const char *)v14);
    if (SHIBYTE(v15.__r_.__value_.__r.__words[2]) < 0)
      operator delete(v15.__r_.__value_.__l.__data_);
  }
  RB::SexpString::pop(a2);
}

void sub_209BA0E40(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, int a13, __int16 a14, char a15, char a16)
{
  if (a16 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::AnimationLayer::encode(_QWORD *this, RB::Encoder *a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;

  v3 = this;
  v4 = *(unsigned int *)this;
  if ((_DWORD)v4)
  {
    RB::ProtobufEncoder::encode_varint(a2, 8uLL);
    this = RB::ProtobufEncoder::encode_varint(a2, v4);
  }
  v5 = *((unsigned int *)v3 + 1);
  if ((_DWORD)v5 != 1)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    return RB::ProtobufEncoder::encode_varint(a2, v5);
  }
  return this;
}

unint64_t RB::AnimationLayer::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      if ((v5 >> 3) == 2)
      {
        a1[1] = RB::ProtobufDecoder::uint_field(this, v5);
      }
      else if ((v5 >> 3) == 1)
      {
        *a1 = RB::ProtobufDecoder::uint_field(this, v5);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v5);
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void *RB::vector<unsigned int,256ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 259) + (*((_DWORD *)__dst + 259) >> 1);
  result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 128), __dst, 0x100u, (_DWORD *)__dst + 259, v3);
  *((_QWORD *)__dst + 128) = result;
  return result;
}

void sub_209BA126C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_209BA1490(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401E2E3159);
  _Unwind_Resume(a1);
}

void sub_209BA18F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RBUUIDInitFromNSUUID(void *a1)
{
  _QWORD v2[3];

  v2[2] = *MEMORY[0x24BDAC8D0];
  objc_msgSend(a1, "getUUIDBytes:", v2);
  return v2[0];
}

RB::Transition *RB::Transition::Transition(RB::Transition *this, const RB::Transition *a2)
{
  char *v4;
  int *v5;
  unsigned int v6;
  unsigned int v7;
  char *v8;
  uint64_t v9;
  char *v10;
  int v11;
  int v12;
  int *v13;
  unsigned int v14;
  char *v15;
  uint64_t v16;
  char *v17;
  unsigned int v18;
  int v19;
  int v20;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = off_24C224008;
  *(_QWORD *)((char *)this + 12) = *(_QWORD *)((char *)a2 + 12);
  v4 = (char *)this + 24;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0x400000000;
  if (*((_QWORD *)a2 + 5))
    v5 = (int *)*((_QWORD *)a2 + 5);
  else
    v5 = (int *)((char *)a2 + 24);
  v6 = *((_DWORD *)a2 + 12);
  v7 = v6;
  if (v6 >= 5)
  {
    RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((char *)this + 24, v6);
    v8 = (char *)*((_QWORD *)this + 5);
    v9 = *((unsigned int *)this + 12);
  }
  else
  {
    if (!v6)
    {
      v12 = 0;
      goto LABEL_13;
    }
    v8 = 0;
    v9 = 0;
  }
  if (!v8)
    v8 = v4;
  v10 = &v8[4 * v9];
  do
  {
    v11 = *v5++;
    *(_DWORD *)v10 = v11;
    v10 += 4;
    --v7;
  }
  while (v7);
  v12 = *((_DWORD *)this + 12);
LABEL_13:
  *((_DWORD *)this + 12) = v12 + v6;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 0x600000000;
  if (*((_QWORD *)a2 + 10))
    v13 = (int *)*((_QWORD *)a2 + 10);
  else
    v13 = (int *)((char *)a2 + 56);
  v14 = *((_DWORD *)a2 + 22);
  if (v14 >= 7)
  {
    RB::vector<RB::Animation::TermOrArg,6ul,unsigned int>::reserve_slow((char *)this + 56, v14);
    v15 = (char *)*((_QWORD *)this + 10);
    v16 = *((unsigned int *)this + 22);
  }
  else
  {
    if (!v14)
    {
      v20 = 0;
      goto LABEL_25;
    }
    v15 = 0;
    v16 = 0;
  }
  if (!v15)
    v15 = (char *)this + 56;
  v17 = &v15[4 * v16];
  v18 = v14;
  do
  {
    v19 = *v13++;
    *(_DWORD *)v17 = v19;
    v17 += 4;
    --v18;
  }
  while (v18);
  v20 = *((_DWORD *)this + 22);
LABEL_25:
  *((_DWORD *)this + 22) = v20 + v14;
  return this;
}

void sub_209BA1D08(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 80);
  if (v3)
    free(v3);
  v4 = *(void **)(v1 + 40);
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Symbol::Animator::flips_rtl(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = (*(unsigned __int8 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 90) >> 1) & 1;
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RB::Symbol::Animator::set_flips_rtl(os_unfair_lock_s *this, int a2)
{
  int v4;

  os_unfair_lock_lock(this);
  v4 = (((*(unsigned __int16 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88) | (*(unsigned __int8 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 90) << 16)) & 0x20000) == 0) ^ a2;
  if ((v4 & 1) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&this[2]);
    RB::Symbol::Model::set_flips_rtl(*(RB::Symbol::Model **)&this[2]._os_unfair_lock_opaque, a2);
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v4 ^ 1u;
}

void sub_209BA1DEC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

double RB::Symbol::Animator::transform(os_unfair_lock_s *this)
{
  double v2;

  os_unfair_lock_lock(this);
  v2 = *(double *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 64);
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_transform(os_unfair_lock_s *this, const Transform *a2)
{
  uint32x2_t v4;
  signed __int32 v5;

  os_unfair_lock_lock(this);
  v4 = (uint32x2_t)vand_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 72), *(float32x2_t *)&a2->_terms._p[8]), (int8x8_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 64), *(float32x2_t *)a2->_terms._p));
  v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&this[2]);
    *(_OWORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 64) = *(_OWORD *)a2->_terms._p;
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v5 >= 0;
}

void sub_209BA1EC0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

float RB::Symbol::Animator::color(uint64_t a1, int a2)
{
  unsigned int v3;
  uint64_t v4;
  __int128 *v5;
  float v6;

  v3 = RB::Symbol::Model::style_color_index(a2);
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(_QWORD *)(a1 + 8);
  if (v3 >= *(_DWORD *)(v4 + 32))
    v5 = &RBColorNull;
  else
    v5 = (__int128 *)(*(_QWORD *)(v4 + 24) + 16 * v3);
  v6 = *(float *)v5;
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v6;
}

uint64_t RB::Symbol::Animator::set_color(os_unfair_lock_s *a1, int a2, float32x4_t *a3)
{
  unsigned int v5;
  unsigned int v6;
  uint64_t v7;
  os_unfair_lock_s *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unsigned int i;
  unsigned int *v13;

  v5 = RB::Symbol::Model::style_color_index(a2);
  if (v5 != -1)
  {
    v6 = v5;
    os_unfair_lock_lock(a1);
    v8 = a1 + 2;
    v7 = *(_QWORD *)&a1[2]._os_unfair_lock_opaque;
    if (v6 >= *(_DWORD *)(v7 + 32))
    {
      if (a3->f32[3] == -32768.0)
        goto LABEL_4;
    }
    else if ((vmaxv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(*(float32x4_t *)(*(_QWORD *)(v7 + 24) + 16 * v6), *a3))), 0xFuLL))) & 1) == 0)
    {
LABEL_4:
      v9 = 0;
LABEL_9:
      os_unfair_lock_unlock(a1);
      return v9;
    }
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&a1[2]);
    v10 = *(_QWORD *)&v8->_os_unfair_lock_opaque;
    v11 = (_QWORD *)(*(_QWORD *)&v8->_os_unfair_lock_opaque + 24);
    v13 = (unsigned int *)(*(_QWORD *)&v8->_os_unfair_lock_opaque + 32);
    for (i = *v13; v6 >= *v13; i = *v13)
    {
      if (*(_DWORD *)(v10 + 36) < i + 1)
      {
        RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)v11, i + 1);
        i = *v13;
      }
      *(_OWORD *)(*v11 + 16 * i) = RBColorNull;
      ++*v13;
      v10 = *(_QWORD *)&v8->_os_unfair_lock_opaque;
      v11 = (_QWORD *)(*(_QWORD *)&v8->_os_unfair_lock_opaque + 24);
      v13 = (unsigned int *)(*(_QWORD *)&v8->_os_unfair_lock_opaque + 32);
    }
    *(float32x4_t *)(*v11 + 16 * v6) = *a3;
    ++*(_DWORD *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 84);
    ++a1[15]._os_unfair_lock_opaque;
    v9 = 1;
    goto LABEL_9;
  }
  return 0;
}

void sub_209BA20C8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_alpha(os_unfair_lock_t lock, const float *a2, unint64_t a3)
{
  unint64_t v4;
  unint64_t v5;
  int v6;
  int v7;
  int v8;
  int v10;

  v4 = 0;
  v5 = 4;
  if (a3 < 4)
    v5 = a3;
  do
  {
    if (v4 >= v5)
    {
      if (v4)
        LOBYTE(v6) = *((_BYTE *)&v10 + v4 - 1);
      else
        LOBYTE(v6) = 1;
    }
    else
    {
      v6 = (int)(float)((float)(a2[v4] * 255.0) + 0.5);
    }
    *((_BYTE *)&v10 + v4++) = v6;
  }
  while (v4 != 4);
  os_unfair_lock_lock(lock);
  v7 = *(_DWORD *)(*(_QWORD *)&lock[2]._os_unfair_lock_opaque + 91);
  v8 = v10;
  if (v7 != v10)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&lock[2]);
    *(_DWORD *)(*(_QWORD *)&lock[2]._os_unfair_lock_opaque + 91) = v10;
    ++lock[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(lock);
  return v7 != v8;
}

void sub_209BA21B8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::hidden(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = *(_BYTE *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 90) & 1;
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RB::Symbol::Animator::set_hidden(os_unfair_lock_s *this, int a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  unsigned int v10;

  os_unfair_lock_lock(this);
  v4 = (((*(unsigned __int16 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88) | (*(unsigned __int8 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 90) << 16)) & 0x10000) == 0) ^ a2;
  if ((v4 & 1) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&this[2]);
    v5 = *(_QWORD *)&this[2]._os_unfair_lock_opaque;
    v7 = *(unsigned __int16 *)(v5 + 88);
    v6 = v5 + 88;
    v8 = v7 | (*(unsigned __int8 *)(v6 + 2) << 16);
    if (a2)
      v9 = 0x10000;
    else
      v9 = 0;
    v10 = v8 & 0xFFFEFFFF;
    *(_WORD *)v6 = v10;
    *(_BYTE *)(v6 + 2) = (v10 | v9) >> 16;
    ++*(_DWORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 84);
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v4 ^ 1u;
}

void sub_209BA22B4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::scale_level(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = (*(__int16 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88) >> 8);
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_scale_level(os_unfair_lock_s *this, int a2)
{
  int v4;

  os_unfair_lock_lock(this);
  v4 = *(__int16 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88) >> 8;
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&this[2]);
    *(_WORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88) = *(_WORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque
                                                                                              + 88) | (unsigned __int16)((_WORD)a2 << 8);
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v4 != a2;
}

void sub_209BA2378(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

double RB::Symbol::Animator::anchor_point(os_unfair_lock_s *this)
{
  double v2;

  os_unfair_lock_lock(this);
  v2 = *(double *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 40);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::position(os_unfair_lock_s *this)
{
  double v2;

  os_unfair_lock_lock(this);
  v2 = *(double *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 48);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::size(os_unfair_lock_s *this)
{
  double v2;

  os_unfair_lock_lock(this);
  v2 = *(double *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 56);
  os_unfair_lock_unlock(this);
  return v2;
}

double RB::Symbol::Animator::presentation_position(os_unfair_lock_s *this)
{
  double v2;

  os_unfair_lock_lock(this);
  v2 = *(double *)&this[12]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(this);
  return v2;
}

BOOL RB::Symbol::Animator::set_current_time(os_unfair_lock_s *this, double a2)
{
  double v4;
  _BOOL8 v5;

  os_unfair_lock_lock(this);
  v4 = *(double *)&this[10]._os_unfair_lock_opaque;
  if (v4 != a2)
  {
    *(double *)&this[10]._os_unfair_lock_opaque = a2;
    ++this[15]._os_unfair_lock_opaque;
  }
  v5 = v4 != a2;
  os_unfair_lock_unlock(this);
  return v5;
}

uint64_t RB::Symbol::Animator::add_animation(uint64_t a1, unsigned int *a2)
{
  float v4;
  uint32x2_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  float v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t v28;
  RB::Symbol::Animation::Timing *v29;
  const RB::Animation *v30;
  uint64_t *v31;
  uint64_t v32;
  _BYTE v34[12];
  float v35;
  float v36;
  unsigned int v37;
  uint64_t v38;

  RB::Symbol::Animation::description(*a2, a2[1], a2[2], *((float *)a2 + 6) > 0.0, (uint64_t)v34);
  v37 = a2[4];
  v35 = ceilf(*((float *)a2 + 5));
  if (v35 <= 0.0)
    return 0;
  v4 = *((float *)a2 + 6);
  if ((LODWORD(v4) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
  {
    if (v4 < 0.0)
      v4 = 0.0;
    v36 = v4;
  }
  v5 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)(a2 + 8)));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    v38 = *((_QWORD *)a2 + 4);
  os_unfair_lock_lock((os_unfair_lock_t)a1);
  if ((v34[1] & 1) != 0)
  {
    v6 = *(_QWORD *)(a1 + 24);
    v7 = 88 * v6;
    while (v6)
    {
      --v6;
      v8 = *(_QWORD *)(a1 + 16);
      v9 = *(_DWORD *)(v8 + v7 - 84);
      v7 -= 88;
      if (v9 == *a2)
      {
        if (*(_QWORD *)(v8 + v7 + 80) == *(_QWORD *)(a1 + 8))
          RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)a1, v6, 0);
        break;
      }
    }
  }
  v11 = *(_QWORD *)(a1 + 16);
  v10 = *(_QWORD *)(a1 + 24);
  v12 = v11 + 88 * v10;
  if (v10)
  {
    v13 = *(_QWORD *)(a1 + 16);
    v14 = *(_QWORD *)(a1 + 24);
    do
    {
      v15 = v14 >> 1;
      v16 = v13 + 88 * (v14 >> 1);
      v17 = *(float *)(v16 + 8);
      v18 = v16 + 88;
      v14 += ~(v14 >> 1);
      if (v17 < *((float *)a2 + 3))
        v13 = v18;
      else
        v14 = v15;
    }
    while (v14);
    if (v13 != v12)
    {
      while (*(float *)(v13 + 8) == *((float *)a2 + 3))
      {
        v13 += 88;
        if (v13 == v12)
          goto LABEL_26;
      }
      v12 = v13;
    }
  }
LABEL_26:
  v20 = *(_QWORD *)(a1 + 8);
  v21 = *(_QWORD *)(a1 + 16);
  if (*(_QWORD *)(a1 + 32) < v10 + 1)
  {
    RB::vector<RB::Symbol::Animation,0ul,unsigned long>::reserve_slow(a1 + 16, v10 + 1);
    v21 = *(_QWORD *)(a1 + 16);
    v10 = *(_QWORD *)(a1 + 24);
  }
  v22 = 0x2E8BA2E8BA2E8BA3 * ((v12 - v11) >> 3);
  v23 = v10 > v22;
  v24 = v10 - v22;
  if (v23)
    memmove((void *)(v21 + 88 * v22 + 88), (const void *)(v21 + 88 * v22), 88 * v24);
  RB::Symbol::Animation::Animation(v21 + 88 * v22, v20, *a2, v34, *((float *)a2 + 3));
  v25 = *(_QWORD *)(a1 + 16);
  ++*(_QWORD *)(a1 + 24);
  ++*(_DWORD *)(a1 + 60);
  v26 = (void *)*((_QWORD *)a2 + 6);
  if (v26)
  {
    v27 = objc_msgSend(v26, "copy");
    v28 = v25 + 88 * v22;

    *(_QWORD *)(v28 + 64) = v27;
  }
  if (*((_QWORD *)a2 + 5))
  {
    v29 = (RB::Symbol::Animation::Timing *)operator new();
    v30 = (const RB::Animation *)-[RBAnimation rb_animation](*((_QWORD *)a2 + 5));
    RB::Symbol::Animation::Timing::Timing(v29, v30);
    v31 = (uint64_t *)(v25 + 88 * v22 + 72);
    v32 = *v31;
    *v31 = (uint64_t)v29;
    if (v32)
      std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)v31, v32);
  }
  v19 = *(unsigned int *)(v25 + 88 * v22);
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v19;
}

void sub_209BA27C0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::Symbol::Animator::remove_animation_at_index(RB::Symbol::Animator *this, uint64_t a2, char a3)
{
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v5 = 88 * a2;
  RB::Symbol::Animation::send_completion((RB::Symbol::Animation *)(*((_QWORD *)this + 2) + 88 * a2), a3);
  v6 = *((_QWORD *)this + 2);
  v7 = (_QWORD *)(v6 + v5);
  v8 = (unsigned int *)v7[10];
  if (v8)
  {
    v9 = v8 + 2;
    do
    {
      v10 = __ldxr(v9);
      v11 = v10 - 1;
    }
    while (__stlxr(v11, v9));
    if (!v11)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
    }
  }
  v12 = v6 + 88 * a2;
  v15 = *(_QWORD *)(v12 + 72);
  v13 = (_QWORD *)(v12 + 72);
  v14 = v15;
  *v13 = 0;
  if (v15)
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)v13, v14);

  v16 = *((_QWORD *)this + 3) - 1;
  *((_QWORD *)this + 3) = v16;
  v17 = v16 - a2;
  if (v17)
    memmove(v7, v7 + 11, 88 * v17);
  ++*((_DWORD *)this + 15);
}

void RB::Symbol::Animator::remove_finished_animations_locked(RB::Symbol::Animator *this)
{
  unint64_t v1;
  unint64_t v3;

  v1 = *((_QWORD *)this + 3);
  if (v1)
  {
    v3 = 0;
    do
    {
      if ((*(_BYTE *)(*((_QWORD *)this + 2) + 88 * v3 + 13) & 0x20) != 0)
      {
        RB::Symbol::Animator::remove_animation_at_index(this, v3, 1);
        v1 = *((_QWORD *)this + 3);
      }
      else
      {
        ++v3;
      }
    }
    while (v3 < v1);
  }
}

BOOL RB::Symbol::Animator::remove_animation_by_id(os_unfair_lock_s *this, int a2)
{
  unint64_t v4;
  _DWORD *v5;
  unint64_t v6;
  _BOOL8 v7;
  int *v8;
  int v9;

  os_unfair_lock_lock(this);
  v4 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (!v4)
  {
LABEL_9:
    v7 = 0;
    goto LABEL_10;
  }
  v5 = *(_DWORD **)&this[4]._os_unfair_lock_opaque;
  if (*v5 != a2)
  {
    v6 = 0;
    v8 = v5 + 22;
    while (v4 - 1 != v6)
    {
      v9 = *v8;
      v8 += 22;
      ++v6;
      if (v9 == a2)
      {
        v7 = v6 < v4;
        goto LABEL_8;
      }
    }
    goto LABEL_9;
  }
  v6 = 0;
  v7 = 1;
LABEL_8:
  RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)this, v6, 0);
LABEL_10:
  os_unfair_lock_unlock(this);
  return v7;
}

void sub_209BA29D0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::remove_animations_by_mask(os_unfair_lock_s *this, unsigned int a2)
{
  unint64_t v4;
  char v5;

  os_unfair_lock_lock(this);
  v4 = 0;
  v5 = 0;
  while (v4 < *(_QWORD *)&this[6]._os_unfair_lock_opaque)
  {
    if (((a2 >> *(_DWORD *)(*(_QWORD *)&this[4]._os_unfair_lock_opaque + 88 * v4 + 4)) & 1) != 0)
    {
      v5 = 1;
      RB::Symbol::Animator::remove_animation_at_index((RB::Symbol::Animator *)this, v4, 0);
    }
    else
    {
      ++v4;
    }
  }
  os_unfair_lock_unlock(this);
  return v5 & 1;
}

void sub_209BA2A70(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::cancel_animation_at_index(RB::Symbol::Animator *this, uint64_t a2)
{
  uint64_t v2;
  double v3;
  _BOOL8 v4;
  RB::Symbol::Animation *v5;
  const RB::Symbol::Model **v6;

  v2 = *((_QWORD *)this + 2);
  v3 = *((double *)this + 5);
  v4 = *(double *)(v2 + 88 * a2 + 48) > v3 || v3 == 0.0;
  if (v4)
  {
    RB::Symbol::Animator::remove_animation_at_index(this, a2, 0);
  }
  else
  {
    v5 = (RB::Symbol::Animation *)(v2 + 88 * a2);
    if ((unint64_t)(a2 + 1) >= *((_QWORD *)this + 3))
      v6 = (const RB::Symbol::Model **)((char *)this + 8);
    else
      v6 = (const RB::Symbol::Model **)((char *)v5 + 168);
    RB::Symbol::Animation::cancel(v5, *(float32x2_t *)&v3, *v6);
  }
  return v4;
}

uint64_t RB::Symbol::Animator::cancel_animation_by_id(os_unfair_lock_s *this, int a2)
{
  _BOOL4 v4;
  unint64_t v5;
  _DWORD *v6;
  unint64_t v7;
  _BOOL4 v8;
  int *v9;
  int v10;
  uint64_t v11;

  os_unfair_lock_lock(this);
  v5 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (!v5)
  {
LABEL_9:
    v8 = 0;
    goto LABEL_10;
  }
  v6 = *(_DWORD **)&this[4]._os_unfair_lock_opaque;
  if (*v6 != a2)
  {
    v7 = 0;
    v9 = v6 + 22;
    while (v5 - 1 != v7)
    {
      v10 = *v9;
      v9 += 22;
      ++v7;
      if (v10 == a2)
      {
        v8 = v7 < v5;
        goto LABEL_8;
      }
    }
    goto LABEL_9;
  }
  v7 = 0;
  v8 = 1;
LABEL_8:
  v4 = RB::Symbol::Animator::cancel_animation_at_index((RB::Symbol::Animator *)this, v7);
LABEL_10:
  v11 = v8 & v4;
  os_unfair_lock_unlock(this);
  return v11;
}

void sub_209BA2B98(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::cancel_animations_by_mask(os_unfair_lock_s *this, unsigned int a2)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;

  os_unfair_lock_lock(this);
  v4 = 0;
  v5 = 0;
LABEL_2:
  v6 = v5;
  while (1)
  {
    v5 = v6;
    if (v4 >= *(_QWORD *)&this[6]._os_unfair_lock_opaque)
      break;
    if (((a2 >> *(_DWORD *)(*(_QWORD *)&this[4]._os_unfair_lock_opaque + 88 * v4 + 4)) & 1) != 0)
    {
      v7 = RB::Symbol::Animator::cancel_animation_at_index((RB::Symbol::Animator *)this, v4);
      v6 = 1;
      if (v7)
        continue;
    }
    ++v4;
    goto LABEL_2;
  }
  os_unfair_lock_unlock(this);
  return v5 & 1;
}

void sub_209BA2C3C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Animator::set_priority_by_id(os_unfair_lock_s *this, int a2, float a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  float v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;

  os_unfair_lock_lock(this);
  v6 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (!v6)
    goto LABEL_22;
  v7 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  v8 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
  while (*(_DWORD *)v8 != a2)
  {
    v8 += 88;
    if (!--v7)
      goto LABEL_22;
  }
  if (*(float *)(v8 + 8) == a3)
    goto LABEL_22;
  v9 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
  v10 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  do
  {
    v11 = v10 >> 1;
    v12 = v9 + 88 * (v10 >> 1);
    v13 = *(float *)(v12 + 8);
    v14 = v12 + 88;
    v10 += ~(v10 >> 1);
    if (v13 < a3)
      v9 = v14;
    else
      v10 = v11;
  }
  while (v10);
  v15 = *(_QWORD *)&this[4]._os_unfair_lock_opaque + 88 * v6;
  if (v9 != v15)
  {
    while (*(float *)(v9 + 8) == a3)
    {
      v9 += 88;
      if (v9 == v15)
      {
        v9 = v15;
        break;
      }
    }
  }
  *(float *)(v8 + 8) = a3;
  if (v9 >= v8)
  {
    if (v9 > v8)
    {
      if (v8 + 88 != v9)
        std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>((__int128 *)v8, (__int128 *)(v8 + 88), (__int128 *)v9);
      goto LABEL_21;
    }
LABEL_22:
    v16 = 0;
    goto LABEL_23;
  }
  std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>((__int128 *)v9, (__int128 *)v8, (__int128 *)(v8 + 88));
LABEL_21:
  v16 = 1;
LABEL_23:
  os_unfair_lock_unlock(this);
  return v16;
}

void sub_209BA2D74(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

__int128 *std::__rotate_forward[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Animation *>(__int128 *a1, __int128 *a2, __int128 *a3)
{
  __int128 *v4;
  __int128 *v6;
  __int128 *i;
  __int128 *v8;
  __int128 *v9;

  v4 = a2;
  std::swap[abi:nn180100]<RB::Symbol::Animation>(a1, a2);
  v6 = (__int128 *)((char *)a1 + 88);
  for (i = (__int128 *)((char *)v4 + 88); i != a3; i = (__int128 *)((char *)i + 88))
  {
    if (v6 == v4)
      v4 = i;
    std::swap[abi:nn180100]<RB::Symbol::Animation>(v6, i);
    v6 = (__int128 *)((char *)v6 + 88);
  }
  if (v6 != v4)
  {
    v8 = v6;
    v9 = v4;
    do
    {
      while (1)
      {
        std::swap[abi:nn180100]<RB::Symbol::Animation>(v8, v4);
        v8 = (__int128 *)((char *)v8 + 88);
        v4 = (__int128 *)((char *)v4 + 88);
        if (v4 == a3)
          break;
        if (v8 == v9)
          v9 = v4;
      }
      v4 = v9;
    }
    while (v8 != v9);
  }
  return v6;
}

void std::swap[abi:nn180100]<RB::Symbol::Animation>(__int128 *a1, __int128 *a2)
{
  __int128 v4;
  unsigned int *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  id v25;
  uint64_t v26;
  unsigned int *v27;

  v21 = *a1;
  v22 = a1[1];
  v23 = a1[2];
  v24 = a1[3];
  v4 = a1[4];
  a1[4] = 0u;
  v5 = (unsigned int *)*((_QWORD *)a1 + 10);
  *((_QWORD *)a1 + 10) = 0;
  v6 = a2[3];
  v8 = *a2;
  v7 = a2[1];
  a1[2] = a2[2];
  a1[3] = v6;
  *a1 = v8;
  a1[1] = v7;
  *((_QWORD *)a1 + 8) = *((_QWORD *)a2 + 8);
  v10 = (uint64_t)a2 + 72;
  v9 = *((_QWORD *)a2 + 9);
  a2[4] = 0u;
  v13 = *((_QWORD *)a1 + 9);
  v11 = (_QWORD *)a1 + 9;
  v12 = v13;
  v27 = v5;
  *v11 = v9;
  if (v13)
  {
    v20 = v4;
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)v11, v12);
    v4 = v20;
  }
  v14 = (unsigned int *)*((_QWORD *)a1 + 10);
  *((_QWORD *)a1 + 10) = *((_QWORD *)a2 + 10);
  *((_QWORD *)a2 + 10) = v14;
  *a2 = v21;
  a2[1] = v22;
  a2[2] = v23;
  a2[3] = v24;
  v15 = *((_QWORD *)a2 + 9);
  v25 = (id)*((_QWORD *)a2 + 8);
  v26 = 0;
  a2[4] = v4;
  if (v15)
  {
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100](v10, v15);
    v14 = (unsigned int *)*((_QWORD *)a2 + 10);
  }
  *((_QWORD *)a2 + 10) = v5;
  v27 = v14;
  if (v14)
  {
    v16 = v14 + 2;
    do
    {
      v17 = __ldxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v14 + 8))(v14);
    }
  }
  v19 = v26;
  v26 = 0;
  if (v19)
    std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100]((uint64_t)&v26, v19);

}

void *RB::vector<RB::Symbol::Animation,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,88ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,88ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(88 * a3);
    v6 = v5 / 0x58;
    if (v5 / 0x58 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::DisplayList::Layer::make_cgimage(RB::DisplayList::Layer *this@<X0>, RB::CGContext *a2@<X1>, float32x2_t *a3@<X2>, char *a4@<X3>, CGImage **a5@<X8>)
{
  int32x2_t v10;
  uint32x2_t v11;
  int8x8_t v12;
  int8x8_t v13;
  unsigned int v14;
  unsigned int v15;
  unsigned __int8 v16;
  char v17;
  __int16 v18;
  size_t Width;
  size_t Height;
  __int128 v26;
  __int128 v27;
  float32x2_t v28;
  float v29;
  double v30;
  float32x2_t v31;
  int v32;
  int32x2_t v33;
  _QWORD *i;
  float v35;
  CFTypeRef v36;
  CGFloat a;
  CGImage *v38;
  int32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  CGImage *v43;
  int32x2_t v44;
  uint32x2_t v45;
  int8x8_t v46;
  float32x2_t v47;
  CGImageRef v49;
  float32x2_t v50;
  float32x2_t v51;
  CGImage *Image;
  int32x2_t v53;
  unsigned __int8 v54;
  CGContextRef v55;
  CGAffineTransform v56;
  CFTypeRef cf;
  CFTypeRef v58;
  __n128 v59;
  __n128 v60;
  BOOL v61;
  CGAffineTransform context[18];
  CGContextRef c[4];
  float64x2_t v64[3];
  uint64_t v65;
  uint64_t v66;
  int32x2_t v67[4];
  float v68;
  int v69;
  uint64_t v70;
  CGRect v71;
  CGRect v72;
  CGRect v73;

  v70 = *MEMORY[0x24BDAC8D0];
  v61 = 0;
  RB::Bounds::Bounds((int32x2_t *)&v60, *a3, a3[1]);
  v59 = v60;
  if ((RB::DisplayList::Layer::compute_roi(this, (int32x2_t *)&v60, (int32x2_t *)&v59, &v61, 0, v60) & 1) == 0)
    goto LABEL_23;
  v10.i32[0] = 0;
  v11 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v60.n128_i8[8], (int32x2_t)0x8000000080000000);
  v12 = (int8x8_t)vdup_lane_s32(vcgt_s32(v10, (int32x2_t)vpmin_u32(v11, v11)), 0);
  v13 = vbsl_s8(v12, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v60.n128_i8[8]));
  *a3 = (float32x2_t)vbsl_s8(v12, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v60.n128_u64[0]));
  a3[1] = (float32x2_t)v13;
  v14 = *((_DWORD *)this + 15);
  v15 = ((v14 & 4) << 6) | (v14 >> 2) & 1;
  if ((v14 & 2) != 0)
    v15 = 256;
  v16 = v15 >= 0x100 ? v15 : *((_BYTE *)a2 + 8);
  if ((v14 & 8) != 0)
    v17 = 1;
  else
    v17 = *((_QWORD *)this + 2) || *((_BYTE *)this + 64) ? 2 : 0;
  v18 = v16 | 0x100;
  RB::CGContext::begin_bitmap((int8x8_t *)a2, a3, v17, v18, 0, 0, (CGContext **)&v58);
  if (!v58)
  {
LABEL_23:
    *a5 = 0;
    return;
  }
  v54 = v16;
  __asm { FMOV            V0.2S, #1.0 }
  RB::CGContext::CGContext(c, v58, v16, _D0);
  if ((*((_BYTE *)this + 60) & 1) != 0 && *(char **)this == a4)
  {
    Image = CGBitmapContextCreateImage(*(CGContextRef *)a2);
    Width = CGImageGetWidth(Image);
    Height = CGImageGetHeight(Image);
    v26 = *((_OWORD *)a2 + 3);
    *(_OWORD *)&context[0].a = *((_OWORD *)a2 + 2);
    v27 = *((_OWORD *)a2 + 4);
    *(_OWORD *)&context[0].c = v26;
    *(_OWORD *)&context[0].tx = v27;
    RB::AffineTransform::invert((RB::AffineTransform *)context);
    v29 = *((float *)this + 12);
    if (v29 == 0.0)
      v29 = 1.0;
    v30 = v29;
    *(float64x2_t *)&context[0].a = vmulq_n_f64(*(float64x2_t *)&context[0].a, v30);
    *(float64x2_t *)&context[0].c = vmulq_n_f64(*(float64x2_t *)&context[0].c, v30);
    v28.f32[1] = (float)Height;
    v28.f32[0] = (float)Width;
    v50 = RB::operator*((float64x2_t *)context, 0, v28);
    v51 = v31;
    RB::Bounds::Bounds((int32x2_t *)&v56, v50, v31);
    if (v66 || !RB::Bounds::contains(v67, *(int32x2_t *)&v56.a, *(int32x2_t *)&v56.b))
    {
      v32 = 0;
    }
    else
    {
      v32 = 1;
      if (!v65 && v68 == 1.0 && !v69)
      {
LABEL_26:
        v71.origin.x = v50.f32[0];
        v71.origin.y = v50.f32[1];
        v71.size.width = v51.f32[0];
        v71.size.height = v51.f32[1];
        CGContextDrawImage(c[0], v71, Image);
        if (Image)
          CFRelease(Image);
        goto LABEL_28;
      }
    }
    RB::CGContext::update_state_slow((uint64_t)c, 0, 0, 0, &v56, v32, 1.0);
    goto LABEL_26;
  }
LABEL_28:
  RB::DisplayList::Layer::render_items((_QWORD **)this, (RB::CGContext *)c, a4);
  cf = 0;
  for (i = (_QWORD *)*((_QWORD *)this + 2); i; i = (_QWORD *)i[1])
    (*(void (**)(_QWORD *, CGContextRef *, CFTypeRef *))(*i + 112))(i, c, &cf);
  if (*((float *)this + 12) == 0.0)
    v35 = 1.0;
  else
    v35 = *((float *)this + 12);
  if (v35 < 0.9)
  {
    *(float *)v33.i32 = 1.0 / v35;
    v53 = v33;
    RB::CGContext::begin_bitmap((int8x8_t *)a2, a3, v17, v18, (int8x8_t)vmul_n_f32(*(float32x2_t *)((char *)a2 + 16), 1.0 / v35), 1u, (CGContext **)context);
    v36 = cf;
    a = context[0].a;
    cf = *(CFTypeRef *)&context[0].a;
    *(_QWORD *)&context[0].a = v36;
    if (v36)
    {
      CFRelease(v36);
      a = *(double *)&cf;
    }
    if (a != 0.0)
    {
      RB::CGContext::apply_scale(c, *(RB::_anonymous_namespace_ **)&a, COERCE_DOUBLE(vdup_lane_s32(v53, 0)));
      v38 = CGBitmapContextCreateImage((CGContextRef)cf);
      CGContextGetCTM(&v56, (CGContextRef)cf);
      context[0] = v56;
      v39 = RB::AffineTransform::scale2((float64x2_t *)context);
      if (v38)
        goto LABEL_39;
    }
  }
  v38 = CGBitmapContextCreateImage(c[0]);
  v39 = RB::AffineTransform::scale2(v64);
  if (v38)
  {
LABEL_39:
    v40.f32[0] = (float)v59.n128_i32[0] - COERCE_FLOAT(*a3);
    v40.f32[1] = (float)(a3[1].f32[1] + COERCE_FLOAT(HIDWORD(*(unint64_t *)a3)))
               - (float)vadd_s32(*(int32x2_t *)(&v59 + 8), *(int32x2_t *)&v59).i32[1];
    v41 = vmul_f32(v40, (float32x2_t)v39);
    v42 = vmul_f32((float32x2_t)v39, vcvt_f32_s32(*(int32x2_t *)&v59.n128_i8[8]));
    v72.origin.x = v41.f32[0];
    v72.origin.y = v41.f32[1];
    v72.size.width = v42.f32[0];
    v72.size.height = v42.f32[1];
    v43 = CGImageCreateWithImageInRect(v38, v72);
    v44.i32[0] = 0;
    *a5 = v43;
    v45 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v59.n128_i8[8], (int32x2_t)0x8000000080000000);
    v46 = (int8x8_t)vdup_lane_s32(vcgt_s32(v44, (int32x2_t)vpmin_u32(v45, v45)), 0);
    v47 = (float32x2_t)vbsl_s8(v46, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v59.n128_i8[8]));
    *a3 = vmul_n_f32((float32x2_t)vbsl_s8(v46, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v59.n128_u64[0])), 1.0 / v35);
    a3[1] = vmul_n_f32(v47, 1.0 / v35);
    if (*((_BYTE *)this + 64) == 2)
    {
      if ((v17 & 1) != 0)
      {
        *(_OWORD *)&v56.a = *(_OWORD *)a3->f32;
        RB::CGContext::begin_bitmap((int8x8_t *)a2, (float32x2_t *)&v56, 2, v18, 0, 0, &v55);
        v73.origin.x = COERCE_FLOAT(*a3);
        v73.origin.y = COERCE_FLOAT(HIDWORD(*(unint64_t *)a3));
        v73.size.width = COERCE_FLOAT(*(_QWORD *)&a3[1]);
        v73.size.height = COERCE_FLOAT(HIDWORD(*(_QWORD *)&a3[1]));
        CGContextDrawImage(v55, v73, v43);
        __asm { FMOV            V0.2S, #1.0 }
        RB::CGContext::CGContext(context, v55, v54, _D0);
        (*(void (**)(_QWORD, CGAffineTransform *))(**((_QWORD **)this + 3) + 136))(*((_QWORD *)this + 3), context);
        v49 = CGBitmapContextCreateImage(*(CGContextRef *)&context[0].a);
        if (v43)
          CFRelease(v43);
        *a5 = v49;
        *(_OWORD *)a3->f32 = *(_OWORD *)&v56.a;
        RB::CGContext::~CGContext((RB::CGContext *)context);
        if (v55)
          CFRelease(v55);
      }
      else
      {
        (*(void (**)(_QWORD, CGContextRef *))(**((_QWORD **)this + 3) + 136))(*((_QWORD *)this + 3), c);
      }
    }
    CFRelease(v38);
  }
  else
  {
    *a5 = 0;
  }
  if (cf)
    CFRelease(cf);
  RB::CGContext::~CGContext((RB::CGContext *)c);
  if (v58)
    CFRelease(v58);
}

void sub_209BA35F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, CFTypeRef cf, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,CFTypeRef a23,CFTypeRef a24)
{
  const void *v24;
  const void *v25;

  if (cf)
    CFRelease(cf);
  if (v25)
    CFRelease(v25);
  CFRelease(v24);
  if (a23)
    CFRelease(a23);
  RB::CGContext::~CGContext((RB::CGContext *)&STACK[0x430]);
  if (a24)
    CFRelease(a24);
  _Unwind_Resume(a1);
}

void RB::DisplayList::render(RB::DisplayList *this, const RB::DisplayList::Contents *a2, RB::CGContext *a3, void *a4)
{
  const char *v7;
  void *v8;
  unsigned __int8 v9;
  CGFloat y;
  CGFloat height;
  void **v12;
  std::string *v13;
  int v14;
  CGFloat v15;
  CGFloat v16;
  const void *v17;
  const char *v18;
  uint64_t v19;
  char v20;
  _QWORD v21[2];
  void *__p[2];
  char v23;
  std::string v24[11];
  RB::DisplayList::State *v25;
  uint64_t v26;
  CGRect ClipBoundingBox;
  CGRect v28;
  CGRect v29;

  v26 = *MEMORY[0x24BDAC8D0];
  if (*((_BYTE *)this + 400))
  {
    RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)v24);
    RB::DisplayList::Builder::set_optimized((uint64_t)v24, 1);
    RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)v24, this, v25, 1.0, 0, a3);
    if (*(_BYTE *)(v24[0].__r_.__value_.__l.__size_ + 400))
      RB::precondition_failure((RB *)"internal error", v7);
    RB::DisplayList::render((RB::DisplayList *)v24[0].__r_.__value_.__l.__size_, a2, 0, v8);
    RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)v24);
  }
  else
  {
    if ((v9 & 1) == 0
    {
      v19 = RB::debug_int((RB *)"RB_PRINT_TREE", v18);
      v20 = v19 & 1;
      if ((v19 & 0xFF00000000) == 0)
        v20 = 0;
      RB::DisplayList::render(RB::DisplayList::Contents const&,RB::CGContext &,void *)::print_tree = v20;
    }
    if (RB::DisplayList::render(RB::DisplayList::Contents const&,RB::CGContext &,void *)::print_tree)
    {
      memset(v24, 0, 41);
      RB::SexpString::push(v24, "render-cg");
      ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
      y = ClipBoundingBox.origin.y;
      height = ClipBoundingBox.size.height;
      v21[0] = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
      v21[1] = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
      RB::Rect::operator std::string(v21, __p);
      if (v23 >= 0)
        v12 = __p;
      else
        v12 = (void **)__p[0];
      RB::SexpString::print(v24, 0, (const char *)v12);
      if (v23 < 0)
        operator delete(__p[0]);
      RB::DisplayList::Contents::print(this, v24);
      RB::SexpString::pop(v24);
      RB::SexpString::newline(v24);
      if ((v24[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
        v13 = v24;
      else
        v13 = (std::string *)v24[0].__r_.__value_.__r.__words[0];
      fputs((const char *)v13, (FILE *)*MEMORY[0x24BDAC8D8]);
      if (SHIBYTE(v24[0].__r_.__value_.__r.__words[2]) < 0)
        operator delete(v24[0].__r_.__value_.__l.__data_);
    }
    if (*((_QWORD *)this + 42)
      || *((_BYTE *)this + 384)
      || (v14 = *((_DWORD *)this + 95), (v14 & 1) != 0)
      || !RB::CGContext::compatible_layer_flags(a2, v14))
    {
      RB::CGContext::reset_ctm((uint64_t)a2);
      v28 = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
      v15 = v28.origin.y;
      v16 = v28.size.height;
      v24[0].__r_.__value_.__l.__data_ = (std::string::pointer)vcvt_f32_f64((float64x2_t)v28.origin);
      v24[0].__r_.__value_.__r.__words[1] = (std::string::size_type)vcvt_f32_f64((float64x2_t)v28.size);
      RB::DisplayList::Layer::make_cgimage((RB::DisplayList *)((char *)this + 320), a2, (float32x2_t *)v24, (char *)a3, (CGImage **)__p);
      v17 = __p[0];
      if (__p[0])
      {
        v29.origin.x = *(float *)&v24[0].__r_.__value_.__l.__data_;
        v29.origin.y = *((float *)v24[0].__r_.__value_.__r.__words + 1);
        v29.size.width = *(float *)&v24[0].__r_.__value_.__r.__words[1];
        v29.size.height = *((float *)&v24[0].__r_.__value_.__r.__words[1] + 1);
        CGContextDrawImage(*(CGContextRef *)a2, v29, (CGImageRef)__p[0]);
        CFRelease(v17);
      }
    }
    else
    {
      RB::DisplayList::Layer::render_items((_QWORD **)this + 40, a2, (char *)a3);
    }
  }
}

void sub_209BA396C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *a18, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  _Unwind_Resume(a1);
}

void RB::DisplayList::LayerItem::render(RB::DisplayList::LayerItem *this, int32x2_t *a2)
{
  float32x2_t *v4;
  unsigned int v10;
  float32x2_t v11;
  float32x2_t v12;
  int v13;
  uint64_t v15;
  int v16;
  float *v17;
  float v18;
  float32x2_t v19;
  float32x2_t v20;
  CGFloat y;
  CGFloat height;
  CGImageRef v23;
  CGImageRef image;
  int32x2_t v25[2];
  __int128 v26;
  CGRect ClipBoundingBox;
  CGRect v28;

  v4 = (float32x2_t *)*((_QWORD *)this + 3);
  _H0 = *((_WORD *)this + 22);
  __asm { FCVT            S8, H0 }
  v10 = *((_WORD *)this + 23) & 0x3F;
  v11 = RB::DisplayList::LayerItem::bounds((RB::DisplayList::Layer **)this);
  RB::Bounds::Bounds((int32x2_t *)&v26, v11, v12);
  v13 = 0;
  if ((float32x2_t *)a2[11] != v4)
    goto LABEL_10;
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v26, *(int32x2_t *)((char *)&v26 + 8)))
  {
    v13 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, 0, v4, v10, &v26, v13, _S8);
    goto LABEL_11;
  }
  v13 = 1;
  if (a2[10])
    goto LABEL_10;
  if (*(float *)&a2[16].i32[1] != _S8 || a2[17].i32[0] != v10)
    goto LABEL_10;
LABEL_11:
  v15 = *((_QWORD *)this + 6);
  if (*(_QWORD *)(v15 + 16)
    || *(_BYTE *)(v15 + 64)
    || (v16 = *(_DWORD *)(v15 + 60), (v16 & 1) != 0)
    || !RB::CGContext::compatible_layer_flags((RB::CGContext *)a2, v16))
  {
    RB::CGContext::reset_ctm((uint64_t)a2);
    ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
    y = ClipBoundingBox.origin.y;
    height = ClipBoundingBox.size.height;
    *(float32x2_t *)&v26 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
    *((float32x2_t *)&v26 + 1) = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
    RB::DisplayList::Layer::make_cgimage(*((RB::DisplayList::Layer **)this + 6), (RB::CGContext *)a2, (float32x2_t *)&v26, 0, &image);
    v23 = image;
    if (image)
    {
      v28.origin.x = *(float *)&v26;
      v28.origin.y = *((float *)&v26 + 1);
      v28.size.width = *((float *)&v26 + 2);
      v28.size.height = *((float *)&v26 + 3);
      CGContextDrawImage(*(CGContextRef *)a2, v28, image);
      CFRelease(v23);
    }
  }
  else
  {
    v17 = (float *)*((_QWORD *)this + 6);
    if (v17[12] == 0.0)
      v18 = 1.0;
    else
      v18 = v17[12];
    v19 = RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)v17);
    RB::Bounds::Bounds(v25, v19, v20);
    RB::CGContext::begin_layer((uint64_t)a2, v18, v25[0], v25[1]);
    RB::DisplayList::Layer::render_items(*((_QWORD ***)this + 6), (RB::CGContext *)a2, 0);
    RB::CGContext::end_layer((CGContextRef *)a2);
  }
}

void sub_209BA3B8C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

double RB::DisplayList::Clip::fill(RB::DisplayList::Clip *this, RB::CGContext *a2, const RB::Fill::Color *a3)
{
  double result;
  CGRect v24;
  CGRect v25;

  RB::CGContext::save(a2);
  if ((*((_BYTE *)this + 45) & 1) != 0)
  {
    if (*((_BYTE *)a2 + 140) != 1)
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, 1);
    v24.origin.x = COERCE_FLOAT(*((_QWORD *)this + 2));
    v24.origin.y = COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 2)));
    v24.size.width = COERCE_FLOAT(*((_QWORD *)this + 3));
    v24.size.height = COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 3)));
    CGContextClipToRect(*(CGContextRef *)a2, v24);
  }
  else
  {
    (*(void (**)(RB::DisplayList::Clip *, RB::CGContext *))(*(_QWORD *)this + 88))(this, a2);
  }
  if (*((_BYTE *)a2 + 121))
    _ZF = *((_BYTE *)a3 + 9) == 0;
  else
    _ZF = 1;
  if (!_ZF && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
    goto LABEL_15;
  _H0 = *((_WORD *)a2 + 56);
  _H1 = *(_WORD *)a3;
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (*(float *)_D0.i32 != _S1)
    goto LABEL_15;
  _H0 = *((_WORD *)a2 + 57);
  _H1 = *((_WORD *)a3 + 1);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (*(float *)_D0.i32 != _S1)
    goto LABEL_15;
  _H0 = *((_WORD *)a2 + 58);
  _H1 = *((_WORD *)a3 + 2);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (*(float *)_D0.i32 != _S1)
    goto LABEL_15;
  _H0 = *((_WORD *)a2 + 59);
  _H1 = *((_WORD *)a3 + 3);
  __asm
  {
    FCVT            S1, H1
    FCVT            S0, H0
  }
  if (*(float *)_D0.i32 != _S1)
LABEL_15:
    RB::CGContext::set_fill_color_slow(a2, a3, _D0);
  v25.origin.x = COERCE_FLOAT(*((_QWORD *)this + 2));
  v25.origin.y = COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 2)));
  v25.size.width = COERCE_FLOAT(*((_QWORD *)this + 3));
  v25.size.height = COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 3)));
  CGContextFillRect(*(CGContextRef *)a2, v25);
  *(_QWORD *)&result = RB::CGContext::restore(a2).n128_u64[0];
  return result;
}

void RB::DisplayList::LayerClip::clip(RB::DisplayList::LayerClip *this, CGContextRef *a2)
{
  CGFloat y;
  CGFloat height;
  double v6;
  int32x4_t v7;
  uint32x2_t v8;
  uint64_t v9;
  _QWORD *v10;
  float16x4_t *v11;
  int v12;
  CGImage *v13;
  CGImage *v14;
  float32x2_t v15;
  float32x2_t v16;
  CGRect ClipBoundingBox;

  RB::CGContext::reset_ctm((uint64_t)a2);
  ClipBoundingBox = CGContextGetClipBoundingBox(*a2);
  y = ClipBoundingBox.origin.y;
  height = ClipBoundingBox.size.height;
  v15 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  v16 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  RB::Rect::intersect(&v15, *(float32x2_t *)((char *)this + 16), *(float32x2_t *)((char *)this + 24), ClipBoundingBox.size.width, ClipBoundingBox.size.height, v6, v7);
  v8 = (uint32x2_t)vclez_f32(v16);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0)
  {
    CGContextClipToRect(*a2, *MEMORY[0x24BDBF070]);
    return;
  }
  v9 = *((_QWORD *)this + 6);
  v10 = *(_QWORD **)(v9 + 16);
  if (!v10)
    goto LABEL_7;
  if (!v10[1]
    && (*(unsigned int (**)(_QWORD *))(*v10 + 40))(v10) == 1
    && RB::ColorMatrix::is_luminance_to_alpha(v11 + 1))
  {
    v9 = *((_QWORD *)this + 6);
LABEL_7:
    v12 = *(_DWORD *)(v9 + 60);
    if ((v12 & 1) == 0
      && !*(_BYTE *)(v9 + 64)
      && RB::CGContext::compatible_layer_flags((RB::CGContext *)a2, v12))
    {
      v14 = this;
      RB::CGContext::add_soft_mask((uint64_t)a2, v10 != 0, (uint64_t)&v14, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v15, v16);
      return;
    }
  }
  RB::DisplayList::Layer::make_cgimage(*((RB::DisplayList::Layer **)this + 6), (RB::CGContext *)a2, &v15, 0, &v14);
  v13 = v14;
  if (v14)
  {
    RB::CGContext::add_alpha_mask((RB::CGContext *)a2, v14, &v15);
    CFRelease(v13);
  }
}

void sub_209BA3E30(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::ItemClip::clip(float32x2_t *this, CGContextRef *a2)
{
  CGFloat y;
  CGFloat height;
  double v6;
  int32x4_t v7;
  uint32x2_t v8;
  float32x2_t *v9;
  float32x2_t v10;
  float32x2_t v11;
  CGRect ClipBoundingBox;

  RB::CGContext::reset_ctm((uint64_t)a2);
  ClipBoundingBox = CGContextGetClipBoundingBox(*a2);
  y = ClipBoundingBox.origin.y;
  height = ClipBoundingBox.size.height;
  v10 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  v11 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  RB::Rect::intersect(&v10, this[2], this[3], ClipBoundingBox.size.width, ClipBoundingBox.size.height, v6, v7);
  v8 = (uint32x2_t)vclez_f32(v11);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0)
  {
    CGContextClipToRect(*a2, *MEMORY[0x24BDBF070]);
  }
  else
  {
    v9 = this;
    RB::CGContext::add_soft_mask((uint64_t)a2, 0, (uint64_t)&v9, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v10, v11);
  }
}

void RB::DisplayList::BackdropColorMatrixItem::render(RB::DisplayList::BackdropColorMatrixItem *this, int32x2_t *a2)
{
  float32x2_t *v4;
  __int16 v6;
  unsigned int v11;
  int v12;
  CGFloat y;
  CGFloat height;
  double v16;
  float32x2_t v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  uint32x2_t v22;
  CGImage *Image;
  CGImage *v24;
  size_t Width;
  size_t v26;
  __int128 v27;
  _BOOL4 v28;
  float32x2_t v29;
  CGContextRef *v30;
  __int128 v31;
  int32x2_t *v32;
  __int128 v33;
  int32x2_t *v34;
  __int128 v35;
  float32x2_t v36;
  float16x4_t *v37;
  CGImage *v38;
  float32x2_t v40;
  float32x2_t v41;
  CFTypeRef cf[2];
  __int128 v43;
  __int128 v44;
  float32x2_t v45;
  float32x2_t v46;
  CGContextRef c[2];
  __int128 v48;
  __int128 v49;
  uint64_t v50;
  CGRect ClipBoundingBox;
  CGRect v52;
  CGRect v53;

  v50 = *MEMORY[0x24BDAC8D0];
  v4 = (float32x2_t *)*((_QWORD *)this + 3);
  _H8 = *((_WORD *)this + 22);
  v6 = *((_WORD *)this + 23);
  RB::Bounds::Bounds((int32x2_t *)c, (float32x2_t)0xFEFFFFFFFEFFFFFFLL, (float32x2_t)0x7F7FFFFF7F7FFFFFLL);
  __asm { FCVT            S8, H8 }
  v11 = v6 & 0x3F;
  if ((float32x2_t *)a2[11] != v4 || !RB::Bounds::contains(a2 + 12, (int32x2_t)c[0], (int32x2_t)c[1]))
  {
    v12 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, 0, v4, v11, c, v12, _S8);
    goto LABEL_11;
  }
  v12 = 1;
  if (a2[10])
    goto LABEL_10;
  if (*(float *)&a2[16].i32[1] != _S8 || a2[17].i32[0] != v11)
    goto LABEL_10;
LABEL_11:
  ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
  y = ClipBoundingBox.origin.y;
  height = ClipBoundingBox.size.height;
  v45 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
  v46 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
  v16 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)this);
  RB::Rect::intersect(&v45, *(float32x2_t *)&v16, v17, v18, v19, v20, v21);
  v22 = (uint32x2_t)vclez_f32(v46);
  if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) == 0)
  {
    Image = CGBitmapContextCreateImage(*(CGContextRef *)a2);
    v24 = Image;
    if (Image)
    {
      Width = CGImageGetWidth(Image);
      v26 = CGImageGetHeight(v24);
      v27 = *(_OWORD *)a2[6].i8;
      *(_OWORD *)c = *(_OWORD *)a2[4].i8;
      v48 = v27;
      v49 = *(_OWORD *)a2[8].i8;
      v28 = RB::AffineTransform::invert((RB::AffineTransform *)c);
      v30 = (CGContextRef *)&a2[4];
      if (v28)
        v30 = c;
      v31 = *(_OWORD *)v30;
      v32 = (int32x2_t *)&v48;
      if (!v28)
        v32 = a2 + 6;
      v33 = *(_OWORD *)v32->i8;
      v34 = (int32x2_t *)&v49;
      if (!v28)
        v34 = a2 + 8;
      v35 = *(_OWORD *)v34->i8;
      *(_OWORD *)cf = v31;
      v43 = v33;
      v44 = v35;
      v29.f32[1] = (float)v26;
      v29.f32[0] = (float)Width;
      v41 = RB::operator*((float64x2_t *)cf, 0, v29);
      v40 = v36;
      v37 = (float16x4_t *)*((_QWORD *)this + 6);
      if (!v37 || (RB::ColorMatrix::is_identity(v37 + 1) & 1) != 0)
      {
        v38 = v24;
        goto LABEL_22;
      }
      RB::CGContext::begin_bitmap((int8x8_t *)a2, &v45, 2, 0, 0, 0, (CGContext **)cf);
      if (!cf[0])
        goto LABEL_23;
      __asm { FMOV            V0.2S, #1.0 }
      RB::CGContext::CGContext(c, cf[0], a2[1].u8[0], _D0);
      v53.origin.x = v41.f32[0];
      v53.origin.y = v41.f32[1];
      v53.size.width = v40.f32[0];
      v53.size.height = v40.f32[1];
      CGContextDrawImage(c[0], v53, v24);
      RB::CGContext::apply_color_matrix(c, (float16x4_t *)(*((_QWORD *)this + 6) + 8), (**((_DWORD **)this + 6) >> 2) & 1);
      v38 = CGBitmapContextCreateImage(c[0]);
      CFRelease(v24);
      v41 = v45;
      v40 = v46;
      RB::CGContext::~CGContext((RB::CGContext *)c);
      if (cf[0])
        CFRelease(cf[0]);
      if (v38)
      {
LABEL_22:
        v52.origin.x = v41.f32[0];
        v52.origin.y = v41.f32[1];
        v52.size.width = v40.f32[0];
        v52.size.height = v40.f32[1];
        CGContextDrawImage(*(CGContextRef *)a2, v52, v38);
        v24 = v38;
LABEL_23:
        CFRelease(v24);
      }
    }
  }
}

void sub_209BA41D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, CFTypeRef cf, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21)
{
  const void *v21;

  if (cf)
    CFRelease(cf);
  CFRelease(v21);
  _Unwind_Resume(a1);
}

uint64_t RB::Filter::ColorMatrix::render(float16x4_t *a1, RB::_anonymous_namespace_ **this)
{
  return RB::CGContext::apply_color_matrix(this, a1 + 1, ((unsigned __int32)a1->i32[0] >> 2) & 1);
}

void RB::Filter::LuminanceCurve::render(uint64_t a1, uint64_t a2)
{
  RB::CGContext::apply_luminance_curve(a2, (float16x4_t *)(a1 + 32), *(int32x4_t *)(a1 + 16));
}

uint64_t RB::Filter::RGBACurves::render(uint64_t a1, uint64_t a2)
{
  return RBStrokeRef::clip(a2);
}

void RB::Filter::GaussianBlur::render(uint64_t a1, float64x2_t *a2, CFTypeRef *a3)
{
  int v5;
  float v6;
  float v7;

  v5 = *(_DWORD *)(a1 + 24) & 1;
  v6 = *(float *)a1;
  v7 = RB::AffineTransform::scale(a2 + 2) * v6;
  RB::CGContext::apply_blur((uint64_t)a2, v5, a3, v7);
}

void RB::CGContext::add_soft_mask<RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::LayerClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(RB::CGContext *a1, uint64_t *a2)
{
  uint64_t v3;
  float *v4;
  float v5;
  float32x2_t v6;
  float32x2_t v7;
  int32x2_t v8[2];

  v3 = *a2;
  v4 = *(float **)(*a2 + 48);
  if (v4[12] == 0.0)
    v5 = 1.0;
  else
    v5 = v4[12];
  v6 = RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)v4);
  RB::Bounds::Bounds(v8, v6, v7);
  RB::CGContext::begin_layer((uint64_t)a1, v5, v8[0], v8[1]);
  RB::DisplayList::Layer::render_items(*(_QWORD ***)(v3 + 48), a1, 0);
  RB::CGContext::end_layer((CGContextRef *)a1);
}

uint64_t RB::CGContext::add_soft_mask<RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::DisplayList::ItemClip::clip(RB::CGContext&)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(_QWORD, uint64_t))(**(_QWORD **)(*(_QWORD *)a2 + 48) + 184))(*(_QWORD *)(*(_QWORD *)a2 + 48), a1);
}

void RB::render_mesh_gradient(RB::RenderPass *a1, float64x2_t *a2, int32x2_t *this, __int16 a4, __int32 a5, char a6, int32x2_t *a7, float a8)
{
  _BOOL4 v15;
  int8x8_t v16;
  float64x2_t v17;
  float64x2_t *v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float32x2_t v22;
  unsigned int buffers;
  int32x2_t v24;
  unsigned int v25;
  uint64_t v26;
  char v27;
  _BYTE *v28;
  uint64_t v29;
  _BYTE *v30;
  unsigned int v31;
  RB::Buffer *v32;
  char *v33;
  __int128 v34;
  __int128 v35;
  __int128 v36;
  _BOOL4 v37;
  uint32x2_t v38;
  int8x8_t v39;
  __int16 v40;
  __int16 v41;
  __int8 v42;
  int v48;
  int v49;
  float16x4_t v50;
  RB::Buffer *v51;
  uint64_t v52;
  __int128 v53;
  __int128 v54;
  RB::Buffer *v55[5];
  __int128 v56;
  _OWORD v57[2];
  int v58;
  __int128 v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v62;
  int8x8_t v63;
  RB::Buffer *v64;
  int64x2_t v65;
  _BYTE v66[128];
  void *v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v15 = *((_DWORD *)a1 + 34) == 2;
  v63.i32[0] = ((a4 & 0x3FF) << 12) | 0x14;
  v63.i32[1] = 2 * v15;
  RB::Fill::MeshGradient::set_fill_state((uint64_t)this, (RB::RenderState *)&v63, a1, a8, 0);
  v16.i32[0] = (a6 & 0x3F) << 6;
  v16.i32[1] = a5;
  v63 = vorr_s8(vand_s8(v63, (int8x8_t)0xFFFFFFFEFFFFF03FLL), v16);
  v17 = a2[1];
  v60 = *a2;
  v61 = v17;
  v62 = a2[2];
  v18 = (float64x2_t *)this[2];
  if (v18)
  {
    v19.f64[0] = RB::operator*(v18, &v60);
    v60 = v19;
    v61 = v20;
    v62 = v21;
  }
  v59 = *(_OWORD *)a7->i8;
  RB::Bounds::intersect((int32x2_t *)&v59, *(int32x2_t *)((char *)a1 + 160), *(int32x2_t *)((char *)a1 + 168));
  v22 = *(float32x2_t *)((char *)a1 + 112);
  v22.i32[1] = vneg_f32(v22).i32[1];
  *(float32x2_t *)&v56 = vmul_f32(v22, vcvt_f32_f64(v60));
  *((float32x2_t *)&v56 + 1) = vmul_f32(v22, vcvt_f32_f64(v61));
  *(float32x2_t *)&v57[0] = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v62), v22);
  DWORD2(v57[0]) = *((_DWORD *)a1 + 30);
  v67 = 0;
  v68 = 0x400000000;
  buffers = RB::Fill::MeshGradient::make_buffers(this, (uint64_t)v66, (uint64_t)v57 + 12, (RB::RenderFrame ***)a1, &v60, a7, a8);
  if ((_DWORD)v68)
  {
    v25 = buffers;
    v26 = RB::Fill::MeshGradient::primitive_type((RB::Fill::MeshGradient *)this);
    if (v27)
    {
      if (v67)
        v28 = v67;
      else
        v28 = v66;
      if ((_DWORD)v68)
      {
        v29 = v26;
        v30 = &v28[32 * v68];
        v31 = v25 - 1;
        do
        {
          HIDWORD(v57[0]) = v31;
          RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x34, 4uLL, 0, v55);
          v32 = v55[0];
          if (v55[0])
          {
            v33 = (char *)v55[1] + *((_QWORD *)v55[0] + 7);
            v34 = v56;
            v35 = v57[0];
            v36 = v57[1];
            *((_DWORD *)v33 + 12) = v58;
            *((_OWORD *)v33 + 1) = v35;
            *((_OWORD *)v33 + 2) = v36;
            *(_OWORD *)v33 = v34;
          }
          else
          {
            memset(v55, 0, 24);
          }
          *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v32);
          *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(*(int64x2_t *)&v55[1]);
          *((_DWORD *)a1 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, *(RB::Buffer **)v28);
          *((int32x2_t *)a1 + 25) = vmovn_s64(*(int64x2_t *)(v28 + 8));
          *((_DWORD *)a1 + 55) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, *(RB::Buffer **)v28);
          *((int32x2_t *)a1 + 28) = vmovn_s64(*(int64x2_t *)(v28 + 8));
          RB::RenderPass::draw_primitives((int32x2_t *)a1, *(const char **)&v63, v29, 0, *((unsigned int *)v28 + 7), 1, *(int32x2_t *)&v59, *(int32x2_t *)((char *)&v59 + 8));
          v28 += 32;
        }
        while (v28 != v30);
      }
    }
    else
    {
      v55[0] = (RB::Buffer *)&v56;
      v55[1] = (RB::Buffer *)v66;
      v55[2] = a1;
      v55[3] = (RB::Buffer *)&v59;
      v37 = *((_DWORD *)a1 + 34) == 2;
      LODWORD(v64) = 28;
      HIDWORD(v64) = 2 * v37;
      RB::Fill::MeshGradient::set_fill_state((uint64_t)this, (RB::RenderState *)&v64, a1, a8, 1);
      *((_WORD *)a1 + 88) = 517;
      *((_DWORD *)a1 + 45) = 0;
      RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()((int32x2_t *)v55, (const char **)&v64, 0);
      *((_WORD *)a1 + 88) = 262;
      *((_DWORD *)a1 + 45) = 0;
      RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()((int32x2_t *)v55, (const char **)&v63, 1);
      *((_BYTE *)a1 + 177) = 0;
      *((float *)a1 + 30) = *((float *)a1 + 30) + (float)v25;
    }
    v24.i32[1] = 0;
    *(_QWORD *)((char *)a1 + 196) = 0;
    *((_DWORD *)a1 + 51) = 0;
    *(_QWORD *)((char *)a1 + 220) = 0;
    *((_DWORD *)a1 + 57) = 0;
  }
  v24.i32[0] = 0;
  v38 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)&v59 + 8), (int32x2_t)0x8000000080000000);
  v39 = (int8x8_t)vdup_lane_s32(vcgt_s32(v24, (int32x2_t)vpmin_u32(v38, v38)), 0);
  RB::Coverage::set_plane((float32x2_t *)v55, (float32x2_t *)a1, (float32x2_t)vbsl_s8(v39, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v59)), COERCE_DOUBLE(vbsl_s8(v39, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)&v59 + 8)))));
  v40 = this[3].i16[3];
  v41 = this[4].i16[0];
  _D0.i16[0] = this[4].i16[1];
  v42 = this[4].i8[5];
  __asm { FCVT            S0, H0 }
  *(float *)_D0.i32 = *(float *)_D0.i32 * a8;
  __asm { FCVT            H0, S0 }
  if (v42 && (v48 = this[4].u8[4], v49 = *((unsigned __int8 *)a1 + 124), v48 != v49))
  {
    LOWORD(v64) = this[3].i16[2];
    WORD1(v64) = v40;
    WORD2(v64) = v41;
    HIWORD(v64) = _D0.i16[0];
    v65.i8[0] = v48;
    v65.i8[1] = v42;
    RB::Fill::Color::convert((uint64_t)&v64, v49, (uint16x4_t)_D0);
    v50.i16[3] = 15360;
    v50.i32[0] = (int)v64;
    v50.i16[2] = WORD2(v64);
    _D0.i32[0] = (unint64_t)v64 >> 48;
  }
  else
  {
    v50.i16[3] = 15360;
    v50.i32[0] = this[3].i32[1];
    v50.i16[2] = this[4].i16[0];
  }
  *(float16x4_t *)((char *)&v55[3] + 4) = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D0, 0)), vcvtq_f32_f16(v50)));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v64);
  v51 = v64;
  if (v64)
  {
    v52 = *((_QWORD *)v64 + 7) + v65.i64[0];
    v53 = *(_OWORD *)v55;
    v54 = *(_OWORD *)&v55[2];
    *(_DWORD *)(v52 + 32) = v55[4];
    *(_OWORD *)v52 = v53;
    *(_OWORD *)(v52 + 16) = v54;
  }
  else
  {
    v64 = 0;
    v65 = 0uLL;
  }
  *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v51);
  *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(v65);
  v63.i32[0] = v63.i32[0] & 0x3FFFC0 | 0x12;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)&v63, 4, ***(_QWORD ***)a1 + 80, 0, 1uLL, *(int32x2_t *)&v59, *(int32x2_t *)((char *)&v59 + 8));
  if (v67)
    free(v67);
}

void sub_209BA485C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,void *a50)
{
  if (a50)
    free(a50);
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::render_mesh_gradient(RB::RenderPass &,RB::AffineTransform const&,RB::Fill::MeshGradient const&,RB::Shader::AccumulatorCoverageState,BOOL,float,RB::BlendMode,RB::Bounds const&)::$_0::operator()(int32x2_t *result, const char **a2, int a3)
{
  int v3;
  int32x2_t *v6;
  int v7;
  unsigned int v8;
  int32x2_t v9;
  int32x2_t v10;
  uint64_t v11;
  uint64_t v12;
  int32x2_t v13;
  unsigned int v14;
  int32x2_t v15;
  RB::Buffer *v16;
  uint64_t v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  int32x2_t v21;
  int32x2_t v22;
  RB::Buffer *v23;
  int64x2_t v24;

  v3 = *(_DWORD *)(*(_QWORD *)&result[1] + 136);
  if (v3)
  {
    v6 = result;
    v7 = *(_DWORD *)(*(_QWORD *)result + 36) + 1;
    v8 = v3 - 1;
    do
    {
      v9 = v6[1];
      if (*(_QWORD *)(*(_QWORD *)&v9 + 128))
        v10 = *(int32x2_t *)(*(_QWORD *)&v9 + 128);
      else
        v10 = v6[1];
      v11 = v8;
      if (!a3 || *(_DWORD *)(*(_QWORD *)&v9 + 136) != 1)
      {
        v12 = *(_QWORD *)&v10 + 32 * v8;
        v13 = v6[2];
        v14 = *(_DWORD *)(v12 + 24);
        v15 = *v6;
        *(float *)(*(_QWORD *)&v15 + 24) = *(float *)(*(_QWORD *)&v13 + 120) + (float)v14;
        *(_DWORD *)(*(_QWORD *)&v15 + 28) = (*(_DWORD *)(v12 + 28) + v14) * v7 - 1;
        *(_WORD *)(*(_QWORD *)&v15 + 40) = v14;
        RB::RenderFrame::alloc_buffer_region(***(RB::RenderFrame ****)&v13, (RB::Device *)0x34, 4uLL, 0, &v23);
        v16 = v23;
        if (v23)
        {
          v17 = *((_QWORD *)v23 + 7) + v24.i64[0];
          v18 = *(_OWORD *)*(_QWORD *)&v15;
          v19 = *(_OWORD *)(*(_QWORD *)&v15 + 16);
          v20 = *(_OWORD *)(*(_QWORD *)&v15 + 32);
          *(_DWORD *)(v17 + 48) = *(_DWORD *)(*(_QWORD *)&v15 + 48);
          *(_OWORD *)(v17 + 16) = v19;
          *(_OWORD *)(v17 + 32) = v20;
          *(_OWORD *)v17 = v18;
        }
        else
        {
          v23 = 0;
          v24 = 0uLL;
        }
        *(_DWORD *)(*(_QWORD *)&v13 + 184) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v13, v16);
        *(int32x2_t *)(*(_QWORD *)&v13 + 188) = vmovn_s64(v24);
        v21 = v6[2];
        *(_DWORD *)(*(_QWORD *)&v21 + 196) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v21, *(RB::Buffer **)v12);
        *(int32x2_t *)(*(_QWORD *)&v21 + 200) = vmovn_s64(*(int64x2_t *)(v12 + 8));
        v22 = v6[2];
        *(_DWORD *)(*(_QWORD *)&v22 + 220) = RB::RenderFrame::buffer_id(***(RB::RenderFrame ****)&v22, *(RB::Buffer **)v12);
        *(int32x2_t *)(*(_QWORD *)&v22 + 224) = vmovn_s64(*(int64x2_t *)(v12 + 8));
      }
      result = RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)&v6[2], *a2, 4, ****(_QWORD ****)&v6[2] + 80, 0, (*(_DWORD *)(*(_QWORD *)&v10 + 32 * v8-- + 28) * v7), *(int32x2_t *)v6[3], *(int32x2_t *)(*(_QWORD *)&v6[3] + 8));
    }
    while (v11);
  }
  return result;
}

uint64_t RB::disable_workaround(RB *this, const char *a2)
{
  unsigned __int8 v3;
  uint64_t v4;
  const char **v5;
  uint64_t v6;
  const char *v7;

  {
    RB::disable_workaround(char const*)::names = (uint64_t)RB::disable_workaround(char const*)::$_0::operator()();
  }
  if (!RB::disable_workaround(char const*)::names)
    return 0;
  v4 = *(_QWORD *)(RB::disable_workaround(char const*)::names + 8);
  if (!v4)
    return 0;
  v5 = *(const char ***)RB::disable_workaround(char const*)::names;
  v6 = 8 * v4;
  while (1)
  {
    v7 = *v5;
    if (**v5 == 10 && !v7[1])
      break;
    if (!strcasecmp(v7, (const char *)this))
      break;
    ++v5;
    v6 -= 8;
    if (!v6)
      return 0;
  }
  return 1;
}

_QWORD *RB::disable_workaround(char const*)::$_0::operator()()
{
  const void *v0;
  unsigned __int16 v1;
  CFTypeID v2;
  CFTypeID TypeID;
  uint64_t v4;
  const __CFString *v5;
  _QWORD *v6;
  const char *v7;
  unint64_t v8;
  int64_t v9;
  const char *v10;
  char *v11;
  unint64_t v12;
  uint64_t v13;
  char v15[4096];
  const __CFString *v16[2];

  v16[1] = *(const __CFString **)MEMORY[0x24BDAC8D0];
  RB::Config::debug_value((RB::Config *)"RB_DISABLE_WORKAROUNDS", v16);
  if (!v16[0])
    return 0;
  v1 = RB::Config::BOOL_value(v16[0], v0);
  if (v1 >= 0x100u)
  {
    if ((_BYTE)v1)
    {
      v6 = (_QWORD *)operator new();
      v6[1] = 0;
      v6[2] = 0;
      *v6 = 0;
      RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v6, 1uLL);
      v13 = v6[1];
      *(_QWORD *)(*v6 + 8 * v13) = "\n";
      v6[1] = v13 + 1;
      goto LABEL_17;
    }
  }
  else
  {
    v2 = CFGetTypeID(v16[0]);
    TypeID = CFStringGetTypeID();
    if (v2 == TypeID)
    {
      v5 = v16[0];
      MEMORY[0x24BDAC7A8](TypeID, v4);
      bzero(v15, 0x1000uLL);
      if (CFStringGetCString(v5, v15, 4096, 0x8000100u))
      {
        v6 = (_QWORD *)operator new();
        v6[1] = 0;
        v6[2] = 0;
        *v6 = 0;
        v7 = &v15[strspn(v15, ", \t\n\f\r")];
        if (*v7)
        {
          v8 = 0;
          do
          {
            v9 = strcspn(v7, ", \t\n\f\r");
            v10 = &v7[v9];
            if (v9 >= 1)
            {
              *v10 = 0;
              v11 = strdup(v7);
              v12 = v8 + 1;
              if (v6[2] < v8 + 1)
              {
                RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)v6, v12);
                v8 = v6[1];
                v12 = v8 + 1;
              }
              *(_QWORD *)(*v6 + 8 * v8) = v11;
              v6[1] = v12;
              v8 = v12;
            }
            v7 = &v10[strspn(v10 + 1, ", \t\n\f\r") + 1];
          }
          while (*v7);
        }
        goto LABEL_17;
      }
    }
  }
  v6 = 0;
LABEL_17:
  if (v16[0])
    CFRelease(v16[0]);
  return v6;
}

float RB::bezier_flatness(RB *a1)
{
  char v1;
  float result;

  v1 = (char)a1;
  result = RB::bezier_flatness(a1);
  if ((v1 & 0xFE) == 2)
    return result * 0.5;
  return result;
}

double RB::max_cached_glyph_mask_area(RB *this)
{
  unsigned __int8 v1;
  unint64_t v2;
  int v4;
  const char *v5;
  uint64_t v6;
  double v7;

  v2 = 0x253EAE000uLL;
  if ((v1 & 1) == 0)
  {
    v2 = 0x253EAE000;
    if (v4)
    {
      v6 = RB::debug_float((RB *)"RB_MAX_GLYPH_MASK_AREA", v5);
      v7 = *(float *)&v6;
      if ((v6 & 0xFF00000000) == 0)
        v7 = 20000.0;
      RB::max_cached_glyph_mask_area(void)::max_cached_area = *(_QWORD *)&v7;
      v2 = 0x253EAE000;
    }
  }
  return *(double *)(v2 + 3800);
}

const char *RB::parse_byte_size(RB *this, const char *a2, unint64_t a3, unint64_t a4)
{
  double v8;
  unsigned int v9;
  unint64_t v10;
  char *v12;

  if (!this)
    return a2;
  v12 = 0;
  v8 = strtod((const char *)this, &v12);
  if (v12 == (char *)this)
    return a2;
  v9 = *v12 - 71;
  if (v9 <= 0x26)
  {
    if (((1 << v9) & 0x100000001) != 0)
    {
      v8 = v8 * 1024.0;
    }
    else
    {
      if (((1 << v9) & 0x1000000010) != 0)
      {
LABEL_10:
        v8 = v8 * 1024.0;
        goto LABEL_11;
      }
      if (((1 << v9) & 0x4000000040) == 0)
        goto LABEL_11;
    }
    v8 = v8 * 1024.0;
    goto LABEL_10;
  }
LABEL_11:
  v10 = (unint64_t)v8;
  if ((unint64_t)v8 >= a4)
    v10 = a4;
  if (v10 <= a3)
    return (const char *)a3;
  else
    return (const char *)v10;
}

const char *RB::blend_name(unsigned int a1)
{
  if (a1 > 0x2F)
    return "unknown";
  else
    return (&off_24C22B9F8)[a1];
}

uint64_t RB::interpolation_mode_without_mipmaps(int a1)
{
  int v1;
  unsigned int v2;

  if (a1 == 3)
    v1 = 2;
  else
    v1 = a1;
  if (a1 == 6)
    v2 = 5;
  else
    v2 = v1;
  if (a1 == 9)
    return 8;
  else
    return v2;
}

const char *RB::color_space_name(int a1)
{
  if ((a1 - 1) > 4)
    return "sRGBLinear";
  else
    return (&off_24C22BB78)[(char)(a1 - 1)];
}

char *RB::linear_srgb_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::linear_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF308]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[339];
}

uint64_t RB::extended_linear_srgb_colorspace(RB *this)
{
  unsigned __int8 v1;
  unint64_t v2;
  int v4;

  v2 = 0x253EAE000uLL;
  if ((v1 & 1) == 0)
  {
    v2 = 0x253EAE000;
    if (v4)
    {
      RB::extended_linear_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF270]);
      v2 = 0x253EAE000;
    }
  }
  return *(_QWORD *)(v2 + 3944);
}

char *RB::display_p3_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF228]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[273];
}

char *RB::extended_display_p3_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::extended_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF240]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[341];
}

char *RB::extended_linear_display_p3_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::extended_linear_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF258]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[343];
}

char *RB::linear_display_p3_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::linear_display_p3_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF2F0]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[345];
}

char *RB::pq_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::pq_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF2D0]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[347];
}

char *RB::gray_colorspace(RB *this)
{
  unsigned __int8 v1;
  char **p_name;
  int v4;

  p_name = &OBJC_PROTOCOL___RBDecodable.name;
  if ((v1 & 1) == 0)
  {
    p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    if (v4)
    {
      RB::gray_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF290]);
      p_name = (char **)(&OBJC_PROTOCOL___RBDecodable + 8);
    }
  }
  return p_name[349];
}

uint64_t RB::color_space_from_cg_name(RB *this, const __CFString *a2)
{
  int v3;
  int v4;

  if (!this)
  {
    v3 = 0;
    v4 = 0;
    return v3 | (v4 << 8);
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF318]) || CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF278]))
  {
    v3 = 1;
LABEL_5:
    v4 = 1;
    return v3 | (v4 << 8);
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF308]) || CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF270]))
  {
    v3 = 0;
    goto LABEL_5;
  }
  if (CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF228]) || CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF240]))
  {
    v4 = 1;
    v3 = 3;
  }
  else if (CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF2F0]))
  {
    v4 = 1;
    v3 = 2;
  }
  else
  {
    v4 = CFEqual(this, (CFTypeRef)*MEMORY[0x24BDBF258]) != 0;
    v3 = 2 * v4;
  }
  return v3 | (v4 << 8);
}

uint64_t RB::color_space_from_cg(RB *this, CGColorSpace *a2)
{
  RB *Name;
  const __CFString *v3;
  int v4;

  if (this)
  {
    Name = (RB *)CGColorSpaceGetName(this);
    LOWORD(this) = RB::color_space_from_cg_name(Name, v3);
    v4 = BYTE1(this);
  }
  else
  {
    v4 = 0;
  }
  return this | (v4 << 8);
}

RB *RB::cg_image_alpha_mask(RB *this, CGImage *a2)
{
  const void *Property;
  unint64_t Width;
  unint64_t Height;
  CGContext *v6;
  CGContext *v7;
  CGRect v9;
  CGRect v10;

  if (CGImageIsMask(this))
    return this;
  Property = (const void *)CGImageGetProperty();
  if (!Property)
  {
    Width = CGImageGetWidth(this);
    Height = CGImageGetHeight(this);
    v6 = CGBitmapContextCreate(0, Width, Height, 8uLL, 0, 0, 7u);
    if (v6)
    {
      v7 = v6;
      v9.origin.x = 0.0;
      v9.origin.y = 0.0;
      v9.size.width = (double)Width;
      v9.size.height = (double)Height;
      CGContextClearRect(v6, v9);
      CGContextSetBlendMode(v7, kCGBlendModeCopy);
      v10.origin.x = 0.0;
      v10.origin.y = 0.0;
      v10.size.width = (double)Width;
      v10.size.height = (double)Height;
      CGContextDrawImage(v7, v10, this);
      Property = CGBitmapContextCreateImage(v7);
      if (Property)
      {
        CGImageSetProperty();
        CFRelease(Property);
      }
      CFRelease(v7);
    }
    else
    {
      return 0;
    }
  }
  return (RB *)Property;
}

CGImageRef RB::cg_image_create_placeholder(RB *this, size_t a2, size_t a3, int a4)
{
  _QWORD *v8;
  unint64_t v9;
  RB *v10;
  CGDataProvider *v11;
  CGBitmapInfo v12;
  size_t v13;
  CGColorSpace *v14;
  CGImageRef v15;
  CGDataProviderDirectCallbacks callbacks;

  v8 = (_QWORD *)operator new();
  *v8 = this;
  v8[1] = a2;
  v8[2] = a3;
  *((_BYTE *)v8 + 24) = a4;
  v9 = (4 * a2 + 63) & 0xFFFFFFFFFFFFFFC0;
  v8[4] = v9;
  v8[5] = v9 * a3;
  v8[6] = 0;
  *(_OWORD *)&callbacks.version = xmmword_24C22B9D0;
  *(_OWORD *)&callbacks.releaseBytePointer = unk_24C22B9E0;
  callbacks.releaseInfo = (CGDataProviderReleaseInfoCallback)RB::cg_image_create_placeholder(unsigned long,unsigned long,unsigned long,BOOL)::$_1::__invoke;
  v10 = CGDataProviderCreateDirect(v8, v9 * a3, &callbacks);
  v11 = v10;
  if (a4)
    v12 = 8194;
  else
    v12 = 8198;
  v13 = v8[4];
  v14 = (CGColorSpace *)RB::srgb_colorspace(v10);
  v15 = CGImageCreate(a2, a3, 8uLL, 0x20uLL, v13, v14, v12, v11, 0, 1, kCGRenderingIntentDefault);
  if (v11)
    CFRelease(v11);
  return v15;
}

unint64_t RB::cg_image_create_placeholder(unsigned long,unsigned long,unsigned long,BOOL)::$_0::__invoke(uint64_t a1)
{
  unint64_t *v1;
  char *v4;
  uint64_t v5;
  char v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  unint64_t i;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t *v19;
  char *v20;
  unsigned __int16 v21[3];
  _BYTE v22[3];
  char v23;
  char v24;
  char v25;
  uint64_t v26;

  v26 = *MEMORY[0x24BDAC8D0];
  v1 = (unint64_t *)(a1 + 48);
  if (!*(_QWORD *)(a1 + 48))
  {
    v4 = (char *)malloc_type_malloc(*(_QWORD *)(a1 + 40), 0x88224499uLL);
    if (v4)
    {
      v20 = v4;
      v5 = 0;
      v21[0] = *(_WORD *)a1;
      v21[1] = 33 * v21[0];
      v21[2] = 1089 * v21[0];
      do
        v22[v5++] = (int)(erand48(v21) * 255.0 + 0.5);
      while (v5 != 6);
      v24 = v23;
      if (*(_BYTE *)(a1 + 24))
        v6 = 127;
      else
        v6 = -1;
      v7 = *(_QWORD *)(a1 + 8);
      v8 = *(_QWORD *)(a1 + 16);
      if (v7 <= v8)
        v9 = *(_QWORD *)(a1 + 16);
      else
        v9 = *(_QWORD *)(a1 + 8);
      v23 = -1;
      v25 = v6;
      v10 = 64;
      v11 = 6;
      v19 = v1;
      while (v10 >= v9 >> 1)
      {
        v10 = 1 << --v11;
        if (v11 <= 2)
        {
          LOBYTE(v11) = 2;
          break;
        }
      }
      v12 = v20;
      if (v8)
      {
        for (i = 0; i < v8; i += v10)
        {
          if (v7)
          {
            v14 = 0;
            v15 = 0;
            v16 = (i >> v11) & 1;
            v17 = &v12[*(_QWORD *)(a1 + 32) * i];
            do
            {
              CGBlt_fillBytes();
              v15 += v10;
              v16 ^= 1uLL;
              v7 = *(_QWORD *)(a1 + 8);
              v17 += 4 * v10;
              v14 -= v10;
            }
            while (v15 < v7);
            v8 = *(_QWORD *)(a1 + 16);
            v12 = v20;
          }
        }
      }
      v1 = v19;
      while (!__ldaxr(v19))
      {
        if (!__stlxr((unint64_t)v12, v19))
          return *v1;
      }
      __clrex();
      free(v12);
    }
  }
  return *v1;
}

uint64_t RB::cg_image_create_placeholder(unsigned long,unsigned long,unsigned long,BOOL)::$_1::__invoke(uint64_t result)
{
  if (result)
  {
    free(*(void **)(result + 48));
    JUMPOUT(0x20BD16544);
  }
  return result;
}

double RB::cg_draw_9_slice_image(CGContextRef c, CGImageRef image, float32x4_t *a3, float32x2_t *a4, int a5, int a6)
{
  float32x2_t v6;
  float32x2_t v17;
  uint32x2_t v18;
  size_t Height;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  __int128 v29;
  __int128 v30;
  float v31;
  float v32;
  float v33;
  float v34;
  uint64_t v35;
  float v36;
  float32x2_t v37;
  uint64_t v38;
  float v39;
  uint64_t v40;
  __int128 v41;
  float v42;
  float v43;
  uint64_t v44;
  int8x8_t v45;
  CGImage *v46;
  float v47;
  __int128 v48;
  float32x2_t v49;
  double v50;
  double v51;
  __int128 v52;
  double result;
  __int128 v54;
  float32x2_t v56;
  float32x2_t v57;
  __int32 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  float32x2_t v65;
  __int128 v66;
  float Width;
  __int128 v68;
  float v69;
  __int32 v70;
  float v71;
  float v72;
  __int32 v73;
  int v74;
  float v75;
  float v76;
  __int32 v77;
  _DWORD v78[4];
  _DWORD v79[3];
  float v80;
  uint64_t v81;
  CGRect v82;
  CGRect v83;
  CGRect v84;
  CGRect v85;

  v81 = *MEMORY[0x24BDAC8D0];
  __asm { FMOV            V8.2S, #1.0 }
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*a3)))) & 1) == 0
    && (v17 = a4[1], v18 = (uint32x2_t)vceq_f32(v17, _D8), (vpmin_u32(v18, v18).u32[0] & 0x80000000) != 0))
  {
    v85.origin.x = COERCE_FLOAT(*a4);
    v85.origin.y = COERCE_FLOAT(HIDWORD(*(unint64_t *)a4));
    v85.size.width = v17.f32[0];
    v85.size.height = v17.f32[1];
    CGContextDrawImage(c, v85, image);
  }
  else
  {
    CGContextSaveGState(c);
    CGContextBeginTransparencyLayer(c, 0);
    CGContextSetBlendMode(c, kCGBlendModeCopy);
    CGContextSetShouldAntialias(c, 0);
    Width = (float)CGImageGetWidth(image);
    Height = CGImageGetHeight(image);
    *(float *)&v24 = (float)Height;
    v25.f32[0] = Width;
    v54 = v24;
    v79[0] = 0;
    v80 = Width;
    LODWORD(v24) = a3->i32[0];
    LODWORD(v29) = a3->i32[1];
    *(float *)&v79[1] = a3->f32[0] * Width;
    *(float *)&v79[2] = v80 - (float)(*(float *)&v29 * v80);
    v26 = *a4;
    v27 = vadd_f32(a4[1], *a4);
    v28 = COERCE_FLOAT(*a4) + *(float *)&v24;
    *(float *)&v29 = v27.f32[0] - *(float *)&v29;
    if (v28 < COERCE_FLOAT(*a4))
      LODWORD(v28) = *(float32x2_t *)a4->f32;
    if (v28 > v27.f32[0])
      v28 = v27.f32[0];
    v74 = (int)*a4;
    v75 = v28;
    v56 = v26;
    if (*(float *)&v29 < v26.f32[0])
      *(float *)&v29 = v26.f32[0];
    if (*(float *)&v29 > v27.f32[0])
      *(float *)&v29 = v27.f32[0];
    v76 = *(float *)&v29;
    v77 = v27.i32[0];
    if (v28 > *(float *)&v29)
    {
      v75 = (float)(*(float *)&v29 + v28) * 0.5;
      v76 = v75;
    }
    v78[0] = 0;
    v30 = v54;
    v78[3] = v54;
    v31 = a3->f32[2];
    v32 = a3->f32[3];
    *(float *)&v78[1] = v31 * *(float *)&v54;
    *(float *)&v78[2] = *(float *)&v30 - (float)(v32 * *(float *)&v30);
    v70 = v56.i32[1];
    v33 = v56.f32[1];
    v73 = v27.i32[1];
    v27.f32[0] = v31 + v56.f32[1];
    v34 = v27.f32[1] - v32;
    if (v27.f32[0] < v56.f32[1])
      v27.f32[0] = v56.f32[1];
    if (v27.f32[0] > v27.f32[1])
      v27.f32[0] = v27.f32[1];
    if (v34 < v56.f32[1])
      v34 = v56.f32[1];
    if (v34 > v27.f32[1])
      v34 = v27.f32[1];
    v71 = v27.f32[0];
    v72 = v34;
    if (v27.f32[0] > v34)
    {
      v71 = (float)(v34 + v27.f32[0]) * 0.5;
      v72 = v71;
    }
    v35 = 0;
    v25.f32[1] = (float)Height;
    v37 = vdiv_f32(_D8, v25);
    v57 = v37;
    v6.i32[0] = 0;
    v36 = 1.0;
    v37.i32[0] = 0;
    do
    {
      LODWORD(v30) = 0;
      DWORD1(v30) = v37.i32[0];
      v38 = v35 + 1;
      LODWORD(v21) = 0;
      *((float *)&v21 + 1) = *(float *)&v78[v35 + 1] - v37.f32[0];
      v58 = v78[v35 + 1];
      if (*((float *)&v21 + 1) <= 0.0)
      {
        *((float *)&v21 + 1) = v36;
        *((float *)&v30 + 1) = v37.f32[0] + -0.5;
      }
      v39 = *((float *)&v70 + v38);
      if ((float)(v39 - v33) > 0.0)
      {
        if (a6)
        {
          *((_QWORD *)&v29 + 1) = *((_QWORD *)&v54 + 1);
          *((float *)&v30 + 1) = *(float *)&v54
                               - COERCE_FLOAT(vadd_f32(*(float32x2_t *)&v30, *(float32x2_t *)&v21).i32[1]);
        }
        v40 = 0;
        LODWORD(v41) = 0;
        *((float *)&v41 + 1) = v33;
        LODWORD(v29) = 0;
        *((float *)&v29 + 1) = v39 - v33;
        v42 = 0.0;
        v43 = v56.f32[0];
        do
        {
          *(_QWORD *)&v23 = v41;
          *(float *)&v22 = v43;
          *(float *)&v30 = v42;
          v44 = v40 + 1;
          v42 = *(float *)&v79[v40 + 1];
          v37.f32[0] = v42 - *(float *)&v30;
          *(float *)&v21 = v42 - *(float *)&v30;
          v37 = (float32x2_t)vdup_lane_s32(vcgt_f32(v37, v6), 0);
          v45.i32[1] = DWORD1(v30);
          *(float *)v45.i32 = *(float *)&v30 + -0.5;
          *(int8x8_t *)&v30 = vbsl_s8((int8x8_t)v37, *(int8x8_t *)&v30, v45);
          *(int8x8_t *)&v21 = vbsl_s8((int8x8_t)v37, *(int8x8_t *)&v21, (int8x8_t)__PAIR64__(DWORD1(v21), LODWORD(v36)));
          v41 = v23;
          *(float *)&v41 = v43;
          v43 = *((float *)&v74 + v40 + 1);
          *(float *)&v20 = v43 - *(float *)&v41;
          if ((float)(v43 - *(float *)&v41) > 0.0)
          {
            v59 = v41;
            v60 = v20;
            v61 = v30;
            v62 = v21;
            v63 = v29;
            if (a5 && ((v40 | v35) & 1) != 0)
            {
              v82.origin.x = *(float *)&v30;
              v82.origin.y = *((float *)&v30 + 1);
              v82.size.width = *(float *)&v21;
              v82.size.height = *((float *)&v21 + 1);
              v64 = v22;
              v69 = *((float *)&v23 + 1);
              v46 = CGImageCreateWithImageInRect(image, v82);
              CGContextSaveGState(c);
              v83.origin.x = *(float *)&v64;
              v83.origin.y = v69;
              v83.size.width = *(float *)&v60;
              v83.size.height = *((float *)&v63 + 1);
              CGContextClipToRect(c, v83);
              v47 = v69 + *((float *)&v63 + 1);
              if (v69 < (float)(v69 + *((float *)&v63 + 1)))
              {
                v48 = v59;
                v49 = vmul_f32(*(float32x2_t *)&v62, v57);
                v50 = v49.f32[0];
                v51 = v49.f32[1];
                v65 = v49;
                do
                {
                  v52 = v64;
                  LODWORD(v48) = v64;
                  if (*(float *)&v64 < v43)
                  {
                    do
                    {
                      v66 = v48;
                      v68 = v52;
                      v84.origin.x = *(float *)&v52;
                      v84.origin.y = *((float *)&v48 + 1);
                      v84.size.width = v50;
                      v84.size.height = v51;
                      CGContextDrawImage(c, v84, v46);
                      v48 = v66;
                      v52 = v68;
                      v49 = v65;
                      *(float *)&v52 = *(float *)&v68 + v65.f32[0];
                      *(float *)&v48 = *(float *)&v68 + v65.f32[0];
                    }
                    while ((float)(*(float *)&v68 + v65.f32[0]) < v43);
                  }
                  DWORD1(v48) = vadd_f32(*(float32x2_t *)&v48, v49).i32[1];
                }
                while (*((float *)&v48 + 1) < v47);
              }
              CGContextRestoreGState(c);
              CGImageRelease(v46);
              v36 = 1.0;
              v30 = v61;
              v21 = v62;
              v29 = v63;
              *(_QWORD *)&v41 = v59;
              v20 = v60;
            }
            else
            {
              CGContextDrawImageFromRect();
              v20 = v60;
              v30 = v61;
              v21 = v62;
              v29 = v63;
              v36 = 1.0;
              *(_QWORD *)&v41 = v59;
            }
          }
          LODWORD(v29) = v20;
          v40 = v44;
        }
        while (v44 != 3);
      }
      v33 = v39;
      v37.i32[0] = v58;
      ++v35;
    }
    while (v38 != 3);
    CGContextEndTransparencyLayer(c);
    CGContextSaveGState(c);
  }
  return result;
}

void RB::cg_font_create_with_name(const __CFString *this@<X0>, CGFontRef *a2@<X8>)
{
  const __CFString *v3;
  CFIndex Length;
  CFStringRef v6;
  CFStringRef v7;
  const __CTFont *v8;
  const __CTFont *v9;
  CGFontRef v10;
  CFRange v11;

  v3 = this;
  if (CFStringHasPrefix(this, CFSTR(".SFNS")))
  {
    Length = CFStringGetLength(CFSTR(".SFNS"));
    v11.length = CFStringGetLength(v3) - Length;
    v11.location = Length;
    v6 = CFStringCreateWithSubstring(0, v3, v11);
    v7 = CFStringCreateWithFormat(0, 0, CFSTR("%@%@"), CFSTR(".SFUI"), v6);
    if (v6)
      CFRelease(v6);
    v3 = v7;
  }
  else
  {
    v7 = 0;
  }
  v8 = CTFontCreateWithNameAndOptions(v3, 0.0, 0, 0x20000uLL);
  if (v8)
  {
    v9 = v8;
    v10 = CTFontCopyGraphicsFont(v8, 0);
    CFRelease(v9);
  }
  else
  {
    v10 = 0;
  }
  *a2 = v10;
  if (v7)
    CFRelease(v7);
}

void *RB::cg_font_get_normalized_path_cache(RB *this, CGFont *a2)
{
  void *AssociatedObject;

  AssociatedObject = objc_getAssociatedObject(this, "com.apple.RenderBox.normalizedGlyphPaths");
  if (!AssociatedObject)
  {
    AssociatedObject = CFDictionaryCreateMutable(0, 0, 0, MEMORY[0x24BDBD6B0]);
    objc_setAssociatedObject(this, "com.apple.RenderBox.normalizedGlyphPaths", AssociatedObject, (void *)1);
    CFRelease(AssociatedObject);
  }
  return AssociatedObject;
}

uint64_t RB::cg_font_get_path_cache_for_stroking(RB *this, CGFont *a2)
{
  CGFontGetVariationAxes();
  return 0;
}

void RB::cg_font_get_glyph_path(RB *this@<X0>, CGFont *a2@<X1>, const __CFDictionary *a3@<X2>, _QWORD *a4@<X8>)
{
  unsigned int v5;
  unint64_t v9;
  const CGPath *v10;
  const char *v11;
  const CGPath *GlyphPath;
  double v13;
  const CGPath *v14;
  CGPathRef CopyByNormalizing;
  const void *v16[4];
  __int128 v17;
  __int128 v18;
  int v19;
  __int16 v20;
  uint64_t v21;

  v5 = a2;
  v21 = *MEMORY[0x24BDAC8D0];
  if (!a3)
  {
    *a4 = CGFontCreateGlyphPath();
    return;
  }
  v9 = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  v16[0] = 0;
  if (CFDictionaryGetValueIfPresent(a3, (const void *)v5, v16))
  {
    v10 = (const CGPath *)v16[0];
    if (v16[0] == (const void *)*MEMORY[0x24BDBD430])
    {
      v10 = 0;
      v16[0] = 0;
    }
    *a4 = CGPathRetain(v10);
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
    return;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  *a4 = 0;
  GlyphPath = (const CGPath *)CGFontCreateGlyphPath();
  if (GlyphPath)
  {
    if ((RB::disable_workaround((RB *)"jitter-glyph-paths", v11) & 1) == 0)
    {
      v13 = 0.0625 / (double)CGFontGetUnitsPerEm(this);
      v16[0] = CGPathCreateMutable();
      v16[1] = *(const void **)&v13;
      *(double *)&v16[2] = v13 * -0.5;
      v17 = 0u;
      v18 = 0u;
      v19 = 1450709556;
      v20 = -25924;
      v14 = (const CGPath *)v16[0];
      CFRelease(GlyphPath);
      GlyphPath = v14;
    }
    CopyByNormalizing = CGPathCreateCopyByNormalizing(GlyphPath, 0);
    *a4 = CopyByNormalizing;
    os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
    if (CopyByNormalizing)
      goto LABEL_14;
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  }
  CopyByNormalizing = (CGPathRef)*MEMORY[0x24BDBD430];
LABEL_14:
  CFDictionarySetValue(a3, (const void *)v9, CopyByNormalizing);
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::cg_font_get_glyph_path(CGFont *,unsigned short,__CFDictionary *)::cache_lock);
  if (GlyphPath)
    CFRelease(GlyphPath);
}

vImage_Error RB::cg_mask_apply_transfer(vImage_Error this, CGContext *a2, CGFunction *a3)
{
  CGContext *v3;
  uint64_t i;
  vImage_Buffer v5;
  uint64_t v6;
  Pixel_8 table[256];
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    v3 = (CGContext *)this;
    this = CGFunctionIsIdentity();
    if ((this & 1) == 0)
    {
      for (i = 0; i != 256; ++i)
      {
        *(double *)&v5.data = (double)(int)i * 0.00392156863;
        v6 = 0;
        CGFunctionEvaluate();
        table[i] = 0;
      }
      v5.data = CGBitmapContextGetData(v3);
      v5.height = CGBitmapContextGetHeight(v3);
      v5.width = CGBitmapContextGetWidth(v3);
      v5.rowBytes = CGBitmapContextGetBytesPerRow(v3);
      return vImageTableLookUp_Planar8(&v5, &v5, table, 0);
    }
  }
  return this;
}

uint64_t RB::error_log(RB *this)
{
  unsigned __int8 v1;
  unint64_t v2;
  int v4;

  v2 = 0x253EAE000uLL;
  if ((v1 & 1) == 0)
  {
    v2 = 0x253EAE000;
    if (v4)
    {
      RB::error_log(void)::log = (uint64_t)os_log_create("com.apple.renderbox", "error");
      v2 = 0x253EAE000;
    }
  }
  return *(_QWORD *)(v2 + 3744);
}

void RB::precondition_failure(RB *this, const char *a2, ...)
{
  RB *v2;
  NSObject *v3;
  _BYTE buf[12];
  char *v5[2];
  va_list va;

  va_start(va, a2);
  va_copy((va_list)&v5[1], va);
  v5[0] = 0;
  v2 = (RB *)vasprintf(v5, (const char *)this, va);
  if (v5[0])
  {
    v3 = RB::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136315138;
      *(char **)&buf[4] = v5[0];
      _os_log_error_impl(&dword_209ACA000, v3, OS_LOG_TYPE_ERROR, "precondition failure: %s", buf, 0xCu);
    }
    if (!qword_2545AD810)
    {
      *(_QWORD *)buf = 0;
      asprintf((char **)buf, "RenderBox precondition failure: %s.\n", v5[0]);
      qword_2545AD810 = *(_QWORD *)buf;
    }
    free(v5[0]);
  }
  abort();
}

void RB::non_fatal_precondition_failure(RB *this, const char *a2, ...)
{
  RB *v2;
  NSObject *v3;
  void *v4[2];
  va_list va;

  va_start(va, a2);
  v4[0] = 0;
  va_copy((va_list)&v4[1], va);
  v2 = (RB *)vasprintf((char **)v4, (const char *)this, va);
  if (v4[0])
  {
    v3 = RB::error_log(v2);
    if (os_log_type_enabled(v3, OS_LOG_TYPE_FAULT))
      RB::non_fatal_precondition_failure((uint64_t *)v4, v3);
    free(v4[0]);
  }
}

void RB::`anonymous namespace'::cg_path_create_copy_by_jittering_points(CGPath const*,double)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  double *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  CGFloat v10;
  __int128 v11;
  __int128 v12;
  double *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  CGFloat v19;
  __int128 v20;
  double *v21;
  double v22;
  double v23;
  CGFloat v24;
  CGFloat v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  CGFloat v32;
  __int128 v33;
  double *v34;
  double v35;
  double v36;
  CGFloat v37;
  CGFloat v38;
  uint64_t v39;
  double v40;
  double v41;
  __int128 v42;
  uint64_t v43;
  double v44;
  double v45;
  double v46;
  double v47;
  double v48;
  double v49;
  CGFloat v50;
  CGFloat v51;
  __int128 v52;
  __int128 v53;

  switch(*(_DWORD *)a2)
  {
    case 0:
      v4 = *(double **)(a2 + 8);
      v5 = *v4;
      v6 = v4[1];
      v7 = erand48((unsigned __int16 *)(a1 + 64));
      v8 = *(double *)(a1 + 8);
      v9 = *(double *)(a1 + 16);
      v10 = v9 + v6 + v8 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&v11 = v9 + v5 + v8 * v7;
      *((CGFloat *)&v11 + 1) = v10;
      v52 = v11;
      CGPathMoveToPoint(*(CGMutablePathRef *)a1, 0, *(CGFloat *)&v11, v10);
      v12 = v52;
      *(_OWORD *)(a1 + 48) = v52;
      goto LABEL_8;
    case 1:
      v13 = *(double **)(a2 + 8);
      v14 = *v13;
      v15 = v13[1];
      v16 = erand48((unsigned __int16 *)(a1 + 64));
      v17 = *(double *)(a1 + 8);
      v18 = *(double *)(a1 + 16);
      v19 = v18 + v15 + v17 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&v20 = v18 + v14 + v17 * v16;
      *((CGFloat *)&v20 + 1) = v19;
      v53 = v20;
      CGPathAddLineToPoint(*(CGMutablePathRef *)a1, 0, *(CGFloat *)&v20, v19);
      goto LABEL_6;
    case 2:
      v21 = *(double **)(a2 + 8);
      v22 = *v21;
      v23 = v21[1];
      v24 = *(double *)(a1 + 16) + v22 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      v25 = *(double *)(a1 + 16) + v23 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      v26 = *(_QWORD *)(a2 + 8);
      v27 = *(double *)(v26 + 16);
      v28 = *(double *)(v26 + 24);
      v29 = erand48((unsigned __int16 *)(a1 + 64));
      v30 = *(double *)(a1 + 8);
      v31 = *(double *)(a1 + 16);
      v32 = v31 + v28 + v30 * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&v33 = v31 + v27 + v30 * v29;
      *((CGFloat *)&v33 + 1) = v32;
      v53 = v33;
      CGPathAddQuadCurveToPoint(*(CGMutablePathRef *)a1, 0, v24, v25, *(CGFloat *)&v33, v32);
      goto LABEL_6;
    case 3:
      v34 = *(double **)(a2 + 8);
      v35 = *v34;
      v36 = v34[1];
      v37 = *(double *)(a1 + 16) + v35 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      v38 = *(double *)(a1 + 16) + v36 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      v39 = *(_QWORD *)(a2 + 8);
      v40 = *(double *)(v39 + 16);
      v41 = *(double *)(v39 + 24);
      v50 = *(double *)(a1 + 16) + v40 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      v51 = *(double *)(a1 + 16) + v41 + *(double *)(a1 + 8) * erand48((unsigned __int16 *)(a1 + 64));
      *(double *)&v42 = v50;
      *((CGFloat *)&v42 + 1) = v51;
      v53 = v42;
      v43 = *(_QWORD *)(a2 + 8);
      v44 = *(double *)(v43 + 32);
      v45 = *(double *)(v43 + 40);
      v46 = erand48((unsigned __int16 *)(a1 + 64));
      v47 = *(double *)(a1 + 8);
      v48 = *(double *)(a1 + 16);
      v49 = erand48((unsigned __int16 *)(a1 + 64));
      CGPathAddCurveToPoint(*(CGMutablePathRef *)a1, 0, v37, v38, v50, v51, v48 + v44 + v47 * v46, *(double *)(a1 + 16) + v45 + *(double *)(a1 + 8) * v49);
LABEL_6:
      v12 = v53;
      goto LABEL_8;
    case 4:
      CGPathCloseSubpath(*(CGMutablePathRef *)a1);
      v12 = *(_OWORD *)(a1 + 48);
LABEL_8:
      *(_OWORD *)(a1 + 32) = v12;
      break;
    default:
      return;
  }
}

uint64_t RB::ImageTexture::cg_image(RB::ImageTexture *this)
{
  uint64_t result;
  int v3;

  result = *(_QWORD *)this;
  if (result)
  {
    v3 = *((_DWORD *)this + 2);
    if ((v3 - 1) < 2 || v3)
      return 0;
  }
  return result;
}

uint64_t RB::ImageTexture::can_mix(RB::ImageTexture *this, const RB::ImageTexture *a2)
{
  if (*(_QWORD *)this == *(_QWORD *)a2 && *((_DWORD *)this + 2) == *((_DWORD *)a2 + 2))
    return 4;
  else
    return 0;
}

uint64_t *RB::ImageTexture::prepare_encode(uint64_t **this, RB::Encoder *a2)
{
  return RB::Encoder::prepare_image((uint64_t *)a2, *((unsigned int *)this + 2), *this);
}

RB::Encoder *RB::ImageTexture::encode(RB::ImageTexture *this, RB::Encoder *a2)
{
  return RB::Encoder::image_field(a2, 1, *((_DWORD *)this + 2), *(uint64_t **)this);
}

uint64_t RB::ImageTexture::decode(uint64_t result, RB::ProtobufDecoder *this, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  CGImage *v6;
  __int128 v7;

  v4 = result;
  v5 = *(_QWORD *)(a3 + 16);
  if (v5)
  {
    v7 = *(_OWORD *)this;
    *(_OWORD *)this = *(_OWORD *)a3;
    result = RB::Decoder::image_field(this, v5);
    if (v6)
    {
      *(_DWORD *)(v4 + 8) = result;
      *(_QWORD *)v4 = v6;
      result = RB::ImageTexture::update_image(v4, v6);
    }
    *(_OWORD *)this = v7;
  }
  if (!*(_QWORD *)v4)
  {
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
  }
  return result;
}

void RB::ImageTexture::attributes(RB::ImageTexture *this, RB::XML::Element *a2)
{
  int v3;
  const void *v4;
  void (**v5)(RB::XML::Value::Image *__hidden);
  int v6;
  CFTypeRef cf;

  v3 = *((_DWORD *)this + 2);
  v4 = *(const void **)this;
  v5 = &off_24C2291A0;
  v6 = v3;
  if (v4)
    CFRetain(v4);
  cf = v4;
  RB::XML::Element::set<RB::XML::Value::Image>(a2, (uint64_t)"image", (uint64_t)&v5);
  v5 = &off_24C2291A0;
  if (cf)
    CFRelease(cf);
}

void sub_209BA67F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RB::RetainedImageTexture::RetainedImageTexture(uint64_t a1, uint64_t a2)
{
  CFTypeRef v4;

  *(_QWORD *)(a1 + 6) = 0;
  *(_QWORD *)a1 = 0;
  v4 = *(CFTypeRef *)a2;
  if (*(_QWORD *)a2)
    v4 = CFRetain(v4);
  *(_QWORD *)a1 = v4;
  *(_DWORD *)(a1 + 8) = *(_DWORD *)(a2 + 8);
  *(_WORD *)(a1 + 12) = *(_WORD *)(a2 + 12);
  return a1;
}

void RB::RetainedImageTexture::~RetainedImageTexture(const void **this)
{
  const void *v1;

  v1 = *this;
  if (v1)
    CFRelease(v1);
}

RB::ImageDescription *RB::ImageDescription::ImageDescription(RB::ImageDescription *this, const void *a2, RB *a3)
{
  CGImage *v5;
  OSType PixelFormat;
  char v7;
  double v8;
  double v9;
  unint64_t v10;
  MTLPixelFormat v11;
  char v13;
  __int16 v14;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_BYTE *)this + 24) = 0;
  *((_QWORD *)this + 2) = 0;
  switch((int)a2)
  {
    case 0:
      *(_QWORD *)this = CGImageGetIdentifier();
      *((_QWORD *)this + 1) = CGImageGetWidth(a3);
      *((_QWORD *)this + 2) = CGImageGetHeight(a3);
      *((_BYTE *)this + 24) = RB::cg_image_has_alpha(a3, v5);
      break;
    case 1:
      *(_QWORD *)this = IOSurfaceGetID(a3);
      *((_QWORD *)this + 1) = IOSurfaceGetWidth(a3);
      *((_QWORD *)this + 2) = IOSurfaceGetHeight(a3);
      PixelFormat = IOSurfaceGetPixelFormat(a3);
      if (PixelFormat)
      {
        v14 = 0;
        v13 = 0;
        RB::pixel_format_from_four_cc(PixelFormat, MTLPixelFormatInvalid, (_BYTE *)&v14 + 1, &v14, &v13);
        v7 = HIBYTE(v14) ^ 1;
        goto LABEL_7;
      }
      break;
    case 2:
      *(_QWORD *)this = (int)a3;
      -[RB size](a3, "size");
      *((_QWORD *)this + 1) = (unint64_t)v8;
      -[RB size](a3, "size");
      *((_QWORD *)this + 2) = (unint64_t)v9;
      break;
    case 4:
      *(_QWORD *)this = (int)RB::pointer_hash(a3, a2);
      *((_QWORD *)this + 1) = -[RB width](a3, "width");
      *((_QWORD *)this + 2) = -[RB height](a3, "height");
      v10 = -[RB pixelFormat](a3, "pixelFormat");
      v7 = RB::pixel_format_traits(v10, v11)[1] & 1;
LABEL_7:
      *((_BYTE *)this + 24) = v7;
      break;
    default:
      return this;
  }
  return this;
}

CGImageRef RBImageCopyCGImage(int a1, CGImageRef image)
{
  if (a1)
    return 0;
  else
    return CGImageRetain(image);
}

BOOL RB::Stroke::Dasher::validate_pattern(RB::Stroke::Dasher *this, float *a2, float *a3)
{
  float v3;
  BOOL v4;
  unint64_t v5;

  if ((this & 1) != 0)
  {
    return 0;
  }
  else if (this)
  {
    v3 = *a2;
    v4 = 0;
    if (*a2 >= 0.0)
    {
      v5 = 1;
      do
      {
        if ((LODWORD(v3) & 0x7FFFFFFFu) >= 0x7F800000)
          break;
        v4 = v5 >= (unint64_t)this;
        if (this == (RB::Stroke::Dasher *)v5)
          break;
        v3 = a2[v5++];
      }
      while (v3 >= 0.0);
    }
  }
  else
  {
    return 1;
  }
  return v4;
}

double RB::Stroke::Dasher::closepath(uint64_t a1)
{
  double result;

  if (!*(_BYTE *)(a1 + 160))
  {
    if ((*(_BYTE *)(a1 + 80) & 4) != 0)
      (*(void (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, *(double *)(a1 + 72));
    *(_BYTE *)(a1 + 80) = 0;
  }
  *(_QWORD *)(a1 + 128) = *(_QWORD *)(a1 + 88);
  *(_BYTE *)(a1 + 120) = *(_BYTE *)(a1 + 81);
  *(_BYTE *)(a1 + 160) = 1;
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a1 + 96);
  result = *(double *)(a1 + 104);
  *(double *)(a1 + 144) = result;
  *(_QWORD *)(a1 + 152) = *(_QWORD *)(a1 + 112);
  return result;
}

void RB::Stroke::Dasher::skipto()
{
  abort();
}

uint64_t RBPathMakeWithCGPath(const void *a1)
{
  if (a1)
    return (uint64_t)CFRetain(a1);
  else
    return 1;
}

uint64_t RBPathMakeRect(_OWORD *a1, double a2, double a3, double a4, double a5)
{
}

uint64_t `anonymous namespace'::make_rect(_OWORD *a1, char a2, double a3, double a4, double a5, double a6)
{
  uint64_t result;
  __int128 v13;
  __int128 v14;
  CGAffineTransform v15;

  if (CGRectIsNull(*(CGRect *)&a3))
    return 0;
  if (a1
    && (v13 = a1[1],
        *(_OWORD *)&v15.a = *a1,
        *(_OWORD *)&v15.c = v13,
        *(_OWORD *)&v15.tx = a1[2],
        !CGAffineTransformIsIdentity(&v15)))
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(_BYTE *)(result + 48) = a2;
    *(_DWORD *)(result + 49) = 0;
    *(_DWORD *)(result + 52) = 0;
    *(_BYTE *)(result + 56) = 1;
    *(_QWORD *)result = off_24C22A2D8;
    v14 = a1[1];
    *(_OWORD *)(result + 64) = *a1;
    *(_OWORD *)(result + 80) = v14;
    *(_OWORD *)(result + 96) = a1[2];
  }
  else
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(_QWORD *)result = off_24C22A308;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(_BYTE *)(result + 48) = a2;
    *(_QWORD *)(result + 49) = 0;
  }
  return result;
}

uint64_t RBPathMakeEllipse(_OWORD *a1, double a2, double a3, double a4, double a5)
{
  uint64_t result;
  __int128 v11;
  __int128 v12;
  CGAffineTransform v13;

  if (CGRectIsNull(*(CGRect *)&a2))
    return 0;
  if (a1
    && (v11 = a1[1],
        *(_OWORD *)&v13.a = *a1,
        *(_OWORD *)&v13.c = v11,
        *(_OWORD *)&v13.tx = a1[2],
        !CGAffineTransformIsIdentity(&v13)))
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(double *)(result + 16) = a2;
    *(double *)(result + 24) = a3;
    *(double *)(result + 32) = a4;
    *(double *)(result + 40) = a5;
    *(_BYTE *)(result + 48) = 1;
    *(_QWORD *)result = off_24C22A1B8;
    v12 = a1[1];
    *(_OWORD *)(result + 56) = *a1;
    *(_OWORD *)(result + 72) = v12;
    *(_OWORD *)(result + 88) = a1[2];
  }
  else
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(_QWORD *)result = off_24C22A1E8;
    *(double *)(result + 16) = a2;
    *(double *)(result + 24) = a3;
    *(double *)(result + 32) = a4;
    *(double *)(result + 40) = a5;
    *(_BYTE *)(result + 48) = 0;
  }
  return result;
}

uint64_t RBPathMakeUnevenRoundedRect(int a1, _OWORD *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  uint64_t result;
  BOOL v21;
  __int128 v22;
  __int128 v23;
  CGAffineTransform v24;

  if (a7 == 0.0 && a8 == 0.0 && a9 == 0.0 && a10 == 0.0)
  if (CGRectIsNull(*(CGRect *)&a3))
    return 0;
  v21 = a1 == 1;
  if (a2
    && (v22 = a2[1],
        *(_OWORD *)&v24.a = *a2,
        *(_OWORD *)&v24.c = v22,
        *(_OWORD *)&v24.tx = a2[2],
        !CGAffineTransformIsIdentity(&v24)))
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(double *)(result + 48) = a7;
    *(double *)(result + 56) = a8;
    *(double *)(result + 64) = a9;
    *(double *)(result + 72) = a10;
    *(_BYTE *)(result + 80) = v21;
    *(_DWORD *)(result + 81) = 0;
    *(_DWORD *)(result + 84) = 0;
    *(_BYTE *)(result + 88) = 1;
    *(_QWORD *)result = off_24C22A278;
    v23 = a2[1];
    *(_OWORD *)(result + 96) = *a2;
    *(_OWORD *)(result + 112) = v23;
    *(_OWORD *)(result + 128) = a2[2];
  }
  else
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(_QWORD *)result = off_24C22A2A8;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(double *)(result + 48) = a7;
    *(double *)(result + 56) = a8;
    *(double *)(result + 64) = a9;
    *(double *)(result + 72) = a10;
    *(_BYTE *)(result + 80) = v21;
    *(_QWORD *)(result + 81) = 0;
  }
  return result;
}

uint64_t RBPathEqualToPath(void *a1, uint64_t a2, uint64_t a3, void *a4)
{
  unint64_t v8;
  _BOOL8 v9;
  uint64_t (*v10)(void *, uint64_t);
  uint64_t (*v12)(void *, uint64_t, uint64_t);
  uint64_t v14;
  unsigned int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  RBPath v19;

  v18 = *MEMORY[0x24BDAC8D0];
  if ((void *)a2 == a4)
  {
    if (a1 != (void *)a3)
    {
      if ((*(_BYTE *)(a2 + 2) & 1) != 0)
      {
        v12 = *(uint64_t (**)(void *, uint64_t, uint64_t))(a2 + 32);
        if (v12)
          return v12(a1, a3, a2);
      }
      else
      {
        v10 = *(uint64_t (**)(void *, uint64_t))(a2 + 32);
        if (v10)
          return v10(a1, a3);
      }
LABEL_4:
      RB::Path::Storage::Storage((uint64_t)&v14, (const char *)0x440);
      v17 = 0;
      v19.info = a1;
      v19.callbacks = (RBPathCallbacks *)a2;
      RB::Path::Storage::append_path((RB::Path::Storage *)&v14, v19);
      if (RBPathApplyElements(a3, (uint64_t)a4, (uint64_t)&v14, (uint64_t)RBPathEqualToPath::$_0::__invoke<void *,RBPathElement,double const*,void const*>))
      {
        if ((v15 & 1) != 0)
          v8 = v16;
        else
          v8 = ((unint64_t)v15 >> 8) & 0xFFF;
        v9 = v17 >= v8;
      }
      else
      {
        v9 = 0;
      }
      RB::Path::Storage::~Storage((RB::Path::Storage *)&v14);
      return v9;
    }
    return 1;
  }
  if ((_UNKNOWN *)a2 == &empty_path_callbacks)
  {
    if (a1 != (void *)1)
      return RBPathIsEmpty(a3, (uint64_t)a4);
    return a3 == 1 && a4 == &empty_path_callbacks;
  }
  if (a4 != &empty_path_callbacks)
    goto LABEL_4;
  if (a3 == 1)
    return 0;
  return RBPathIsEmpty((uint64_t)a1, a2);
}

void sub_209BA711C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RB::Path::Storage::~Storage((RB::Path::Storage *)&a9);
  _Unwind_Resume(a1);
}

uint64_t RBPathApply(const CGPath *a1, void *a2, uint64_t a3, uint64_t (*a4)(RB::Path::Mapper *__hidden this), uint64_t (*a5)(RB::Path::Mapper *__hidden this))
{
  float64x2_t *v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  _OWORD v10[3];
  uint64_t (*v11[3])(RB::Path::Mapper *__hidden);
  unsigned __int8 v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    MEMORY[0x24BDAC7A8](a1, a2);
    v5 = (float64x2_t *)v10;
    v7 = v6[1];
    v8 = v6[2];
    v10[0] = *v6;
    v10[1] = v7;
    v10[2] = v8;
  }
  else
  {
    v5 = 0;
  }
  v11[0] = (uint64_t (*)(RB::Path::Mapper *__hidden))off_24C22A068;
  v11[1] = a4;
  v11[2] = a5;
  v12 = 1;
  RBPathMap(a1, a2, v11, v5);
  return v12;
}

uint64_t RBPathApplyLines(const CGPath *a1, void *a2, uint64_t (*a3)(RB::Path::Mapper *__hidden this), uint64_t (*a4)(RB::Path::Mapper *__hidden this), double a5)
{
  unsigned int v5;
  float v6;
  float32x2_t v7;
  float32x2_t v8;
  uint64_t (*v10[4])(RB::Path::Mapper *__hidden);
  __int128 v11;
  __int128 v12;
  float v13;
  unsigned __int8 v14;
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v10[0] = (uint64_t (*)(RB::Path::Mapper *__hidden))off_24C222D00;
  v10[1] = a3;
  v10[2] = a4;
  *(float *)&v5 = a5;
  v6 = *(float *)&v5;
  v7 = vrecpe_f32((float32x2_t)v5);
  v8 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v6), v7), v7);
  v11 = 0u;
  v12 = 0u;
  v13 = 0.75 * vmul_f32(v8, vrecps_f32((float32x2_t)LODWORD(v6), v8)).f32[0];
  v14 = 1;
  RBPathMap(a1, a2, v10, 0);
  return v14;
}

uint64_t RBPathContainsPoint(RBPath a1, int a2, double a3, double a4)
{
  _QWORD v5[2];

  *(double *)v5 = a3;
  *(double *)&v5[1] = a4;
  return RBPathContainsPoints(a1, 1uLL, (uint64_t)v5, a2, 0) & 1;
}

uint64_t RBPathContainsPoints(RBPath a1, unint64_t a2, uint64_t a3, int a4, float64x2_t *a5)
{
  RBPathCallbacks *callbacks;
  void *info;
  unint64_t v9;
  unint64_t v10;
  float64x2_t *v11;
  unsigned __int8 v12;
  unint64_t v13;
  _BYTE *v14;
  double *v15;
  _DWORD *v16;
  _DWORD *v17;
  unint64_t v18;
  float32x2_t v19;
  unint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  float64x2_t v24;
  double v25;
  int32x4_t v26;
  int32x4_t v27;
  float64_t v28;
  float64x2_t v29;
  double v30;
  char v31;
  uint64_t v32;
  unint64_t v33;
  void *v34;
  int32x4_t *v35;
  unint64_t v36;
  int8x16_t v37;
  int32x4_t v38;
  int32x4_t v39;
  int8x16_t v40;
  unsigned int v41;
  int8x16_t v42;
  int32x4_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float32x2_t v52[2];
  uint64_t (**v53)(RBPathContainsPoints::Winding *__hidden);
  _DWORD v54[64];
  void *v55;
  unint64_t v56;
  uint64_t v57;
  _DWORD v58[64];
  void *v59;
  unint64_t v60;
  uint64_t v61;
  _BYTE v62[256];
  void *v63[2];
  uint64_t v64;
  float32x2_t v65;
  float32x2_t v66;
  __int128 v67;
  uint64_t v68;
  RBPath v69;

  v68 = *MEMORY[0x24BDAC8D0];
  if (!a2)
    return 0;
  callbacks = a1.callbacks;
  info = a1.info;
  v9 = 0;
  if (a2 >= 0x40)
    v10 = 64;
  else
    v10 = a2;
  v11 = (float64x2_t *)MEMORY[0x24BDBD8B8];
  if (a5)
    v11 = a5;
  v50 = v11[1];
  v51 = *v11;
  v49 = v11[2];
  v53 = off_24C22A0E8;
  v59 = 0;
  v61 = 16;
  *(_OWORD *)v63 = 0u;
  v64 = 16;
  v65 = (float32x2_t)vdup_n_s32(0x7F800000u);
  v66 = (float32x2_t)0x7F0000007FLL;
  v12 = v10 + 3;
  v13 = (v10 + 3) >> 2;
  v67 = 0u;
  v57 = 16;
  v55 = 0;
  v56 = v13;
  v60 = v13;
  if (v13 >= 0x11)
  {
    RB::vector<RB::Fill::Gradient::Stop,16ul,unsigned long>::reserve_slow(v62, (v10 + 3) >> 2);
    v9 = (unint64_t)v63[1];
  }
  if (v13 > v9)
  {
    v14 = v63[0];
    if (!v63[0])
      v14 = v62;
    bzero(&v14[16 * v9], 16 * (v13 - v9));
  }
  v63[1] = (void *)((v10 + 3) >> 2);
  v15 = (double *)(a3 + 8);
  v16 = v54;
  v17 = v58;
  v18 = v10;
  do
  {
    v19 = vcvt_f32_f64(vmlaq_n_f64(vmlaq_n_f64(v49, v51, *(v15 - 1)), v50, *v15));
    v65 = vminnm_f32(v65, v19);
    v66 = vmaxnm_f32(v66, v19);
    *v16++ = v19.i32[0];
    *v17++ = v19.i32[1];
    v15 += 2;
    --v18;
  }
  while (v18);
  v20 = v10 - (v12 & 0xFC);
  if (v10 < (v12 & 0xFCu))
  {
    v21 = &v58[v10];
    v22 = &v54[v10];
    do
    {
      *v22++ = 0;
      *v21++ = 0;
    }
    while (!__CFADD__(v20++, 1));
  }
  v69.info = info;
  v69.callbacks = callbacks;
  *(_QWORD *)&v24.f64[0] = *(_OWORD *)&RBPathBoundingRect(v69, 0);
  v24.f64[1] = v28;
  v29.f64[1] = v25;
  v52[0] = vcvt_f32_f64(v24);
  v52[1] = vcvt_f32_f64(v29);
  *(int32x2_t *)&v29.f64[0] = vceq_f32(v65, v66);
  v30 = COERCE_DOUBLE(vpmin_u32(*(uint32x2_t *)&v29.f64[0], *(uint32x2_t *)&v29.f64[0]));
  if ((LODWORD(v30) & 0x80000000) != 0)
    v31 = RB::Rect::contains(v52, v65, *(double *)&v66, v30, v25, v26);
  else
    v31 = RB::Rect::intersects(v52, v65, vsub_f32(v66, v65), v30, v25, *(double *)v26.i64, v27);
  if ((v31 & 1) == 0)
  {
    v32 = 0;
    v34 = v63[0];
    if (!v63[0])
      goto LABEL_34;
    goto LABEL_33;
  }
  RBPathMap((CGPathRef)info, callbacks, (uint64_t (**)(RB::Path::Mapper *__hidden))&v53, 0);
  v33 = 0;
  v32 = 0;
  v34 = v63[0];
  if (v63[0])
    v35 = (int32x4_t *)v63[0];
  else
    v35 = (int32x4_t *)v62;
  v36 = 1;
  v37.i64[0] = 0x100000001;
  v37.i64[1] = 0x100000001;
  do
  {
    v38 = *v35++;
    v39 = v38;
    v40 = (int8x16_t)vtstq_s32(v39, v39);
    if (a4)
      v41 = -1;
    else
      v41 = 0;
    v42 = (int8x16_t)vdupq_n_s32(v41);
    v43 = vceqzq_s32((int32x4_t)vorrq_s8(vandq_s8(vandq_s8((int8x16_t)v39, v37), v42), vbicq_s8(v40, v42)));
    v44.i64[0] = v43.i32[0];
    v44.i64[1] = v43.i32[1];
    v45 = v44;
    v44.i64[0] = v43.i32[2];
    v44.i64[1] = v43.i32[3];
    v46.i64[0] = v36;
    v46.i64[1] = 2 * v36;
    v47 = vorrq_s8(vbicq_s8(v46, v45), vbicq_s8((int8x16_t)vshlq_u64((uint64x2_t)vdupq_n_s64(v36), (uint64x2_t)xmmword_209BD6EE0), v44));
    v32 |= *(_QWORD *)&vorr_s8(*(int8x8_t *)v47.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v47, v47, 8uLL));
    v33 += 4;
    v36 *= 16;
  }
  while (v33 < v10);
  if (v63[0])
LABEL_33:
    free(v34);
LABEL_34:
  if (v59)
    free(v59);
  if (v55)
    free(v55);
  return v32;
}

void sub_209BA75D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51)
{
  if (STACK[0x390])
    free((void *)STACK[0x390]);
  if (STACK[0x270])
    free((void *)STACK[0x270]);
  if (a51)
    free(a51);
  _Unwind_Resume(a1);
}

void RBPathContainsPoints::Winding::~Winding(RBPathContainsPoints::Winding *this)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)*((_QWORD *)this + 106);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 70);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 34);
  if (v4)
    free(v4);
}

uint64_t RBPathCopyStrokedPath(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4, uint64_t *a5, uint64_t a6, double a7, double a8, double a9)
{
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t (*v23)(uint64_t);
  uint64_t *v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v28;
  unint64_t v29;
  uint64_t v30;
  __int128 v31;
  __int128 v32;
  _QWORD *v33;
  unint64_t v34;
  unint64_t v35;

  v17 = a1;
  if ((RBPathIsEmpty(a1, a2) & 1) != 0)
    return 0;
  *(double *)&v31 = a7;
  *((double *)&v31 + 1) = a8;
  *(double *)&v32 = a9;
  *((_QWORD *)&v32 + 1) = __PAIR64__(a4, a3);
  v34 = 0;
  v35 = 0;
  v33 = 0;
  if (a6)
  {
    v19 = 0;
    v20 = 0;
    do
    {
      v21 = v20 + 1;
      if (v35 < v20 + 1)
      {
        RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)&v33, v21);
        v19 = v33;
        v20 = v34;
        v21 = v34 + 1;
      }
      v22 = *a5++;
      v19[v20] = v22;
      v34 = v21;
      v20 = v21;
      --a6;
    }
    while (a6);
  }
  v18 = operator new();
  *(_DWORD *)(v18 + 8) = 1;
  *(_QWORD *)v18 = off_24C22A128;
  v23 = *(uint64_t (**)(uint64_t))(a2 + 8);
  if (v23)
    v17 = v23(v17);
  *(_QWORD *)(v18 + 64) = 0;
  *(_QWORD *)(v18 + 16) = v17;
  *(_QWORD *)(v18 + 24) = a2;
  *(_OWORD *)(v18 + 32) = v31;
  *(_OWORD *)(v18 + 48) = v32;
  *(_QWORD *)(v18 + 72) = 0;
  *(_QWORD *)(v18 + 80) = 0;
  v24 = v33;
  v25 = v34;
  if (v34)
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(v18 + 64, v34);
    v26 = *(_QWORD *)(v18 + 72);
    v28 = (_QWORD *)(*(_QWORD *)(v18 + 64) + 8 * v26);
    v29 = v25;
    do
    {
      v30 = *v24++;
      *v28++ = v30;
      --v29;
    }
    while (v29);
    v24 = v33;
  }
  else
  {
    v26 = 0;
  }
  *(_QWORD *)(v18 + 72) = v26 + v25;
  if (v24)
    free(v24);
  return v18;
}

void sub_209BA7804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  uint64_t v14;
  void **v15;
  void (*v17)(_QWORD);

  if (*v15)
    free(*v15);
  v17 = *(void (**)(_QWORD))(*(_QWORD *)(v14 + 24) + 16);
  if (v17)
    v17(*(_QWORD *)(v14 + 16));
  MEMORY[0x20BD16544](v14, 0x10E1C4000811C3ELL);
  if (a14)
    free(a14);
  _Unwind_Resume(a1);
}

uint64_t RBPathCopyTrimmedPath(uint64_t a1, uint64_t a2, double a3, double a4)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t (*v9)(uint64_t);

  v7 = a1;
  if ((RBPathIsEmpty(a1, a2) & 1) != 0)
    return 0;
  v8 = operator new();
  *(_DWORD *)(v8 + 8) = 1;
  *(_QWORD *)v8 = off_24C22A158;
  v9 = *(uint64_t (**)(uint64_t))(a2 + 8);
  if (v9)
    v7 = v9(v7);
  *(_QWORD *)(v8 + 16) = v7;
  *(_QWORD *)(v8 + 24) = a2;
  *(double *)(v8 + 32) = a3;
  *(double *)(v8 + 40) = a4;
  return v8;
}

void sub_209BA7910(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10E1C404749101FLL);
  _Unwind_Resume(a1);
}

uint64_t RBPathCanMix(RBPath a1, RBPath a2)
{
  RBPathCallbacks *callbacks;
  void *info;
  RBPathCallbacks *v4;
  void *v5;
  uint64_t v6;
  size_t v7;
  size_t v8;
  _BYTE *v9;
  unsigned int v10;
  _QWORD v12[19];
  void *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE v16[16];
  void *v17;
  size_t v18;
  unint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  callbacks = a2.callbacks;
  info = a2.info;
  v4 = a1.callbacks;
  v5 = a1.info;
  v26 = *MEMORY[0x24BDAC8D0];
  if ((RBPathEqualToPath(a1.info, (uint64_t)a1.callbacks, (uint64_t)a2.info, a2.callbacks) & 1) != 0)
    return 4;
  v13 = 0;
  v14 = 0;
  memset(v12, 0, 24);
  v15 = 128;
  v17 = 0;
  v18 = 0;
  v19 = 16;
  v20 = 0;
  v21 = 0;
  v22 = 8;
  v23 = 0;
  v24 = 0;
  v25 = 4;
  RBPathApplyElements((uint64_t)v5, (uint64_t)v4, (uint64_t)v12, (uint64_t)RBPathCanMix(RBPath,RBPath)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  v7 = v18;
  v8 = v18 + 1;
  if (v19 < v18 + 1)
  {
    RB::vector<BOOL,16ul,unsigned long>::reserve_slow(v16, v8);
    v7 = v18;
    v8 = v18 + 1;
  }
  v9 = v17;
  if (!v17)
    v9 = v16;
  v9[v7] = 0;
  v18 = v8;
  v10 = RBPathApplyElements((uint64_t)info, (uint64_t)callbacks, (uint64_t)v12, (uint64_t)RBPathCanMix(RBPath,RBPath)::$_1::__invoke<void *,RBPathElement,double const*,void const*>);
  if (v12[0] == v14)
    v6 = v10;
  else
    v6 = 0;
  if (v23)
    free(v23);
  if (v20)
    free(v20);
  if (v17)
    free(v17);
  if (v13)
    free(v13);
  return v6;
}

void sub_209BA7A9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  RBPathCanMix(RBPath,RBPath)::Info::~Info(&a9);
  _Unwind_Resume(a1);
}

_QWORD *RBPathCanMix(RBPath,RBPath)::Info::~Info(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v2 = (void *)a1[40];
  if (v2)
    free(v2);
  v3 = (void *)a1[29];
  if (v3)
    free(v3);
  v4 = (void *)a1[24];
  if (v4)
    free(v4);
  v5 = (void *)a1[19];
  if (v5)
    free(v5);
  return a1;
}

void *RBPathMix@<X0>(RBPath a1@<0:X0, 8:X1>, RBPath a2@<0:X2, 8:X3>, float a3@<S0>, float64x2_t *this@<X4>, float64x2_t *a5@<X5>, float64x2_t *a6@<X6>, uint64_t *a7@<X8>)
{
  RBPathCallbacks *callbacks;
  void *info;
  RBPathCallbacks *v12;
  void *v13;
  uint64_t (*v14)(void *);
  uint64_t (*v15)(void *);
  uint64_t v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  void *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  _BYTE v27[64];
  _DWORD v28[4];
  __int128 v29;
  __int128 v30;
  void *v31[2];
  uint64_t v32;
  __int128 v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;

  callbacks = a1.callbacks;
  info = a1.info;
  v38 = *MEMORY[0x24BDAC8D0];
  if (a3 == 0.0 || (v12 = a2.callbacks, v13 = a2.info, a1.info == a2.info) && a1.callbacks == a2.callbacks)
  {
    v14 = (uint64_t (*)(void *))*((_QWORD *)a1.callbacks + 1);
    if (v14)
    {
      a1.info = (void *)v14(a1.info);
      info = a1.info;
    }
    *a7 = (uint64_t)info;
    a7[1] = (uint64_t)callbacks;
  }
  else if (a3 == 1.0)
  {
    v15 = (uint64_t (*)(void *))*((_QWORD *)a2.callbacks + 1);
    if (v15)
    {
      a1.info = (void *)v15(a2.info);
      v13 = a1.info;
    }
    *a7 = (uint64_t)v13;
    a7[1] = (uint64_t)v12;
  }
  else
  {
    *(float *)v28 = a3;
    v28[1] = RB::AffineTransform::scale(this);
    v28[2] = RB::AffineTransform::scale(a5);
    *(float *)&v28[3] = 1.0 / RB::AffineTransform::scale(a6);
    *(_OWORD *)v31 = 0u;
    v29 = 0u;
    v30 = 0u;
    v33 = 0u;
    v32 = 128;
    v34 = 256;
    v35 = 0;
    v37 = 0;
    v36 = 0;
    RBPathApplyElements((uint64_t)info, (uint64_t)callbacks, (uint64_t)v28, (uint64_t)RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
    v16 = operator new();
    *(_DWORD *)(v16 + 8) = 1;
    *(_QWORD *)v16 = off_24C229608;
    RB::Path::Storage::Storage((uint64_t)v27, (const char *)0x90);
    RB::Path::Storage::Storage((RB::Path::Storage *)(v16 + 16), (const char *)0x90, (const RB::Path::Storage *)v27);
    RB::Path::Storage::~Storage((RB::Path::Storage *)v27);
    v17 = (unsigned int *)*((_QWORD *)&v30 + 1);
    *((_QWORD *)&v30 + 1) = v16;
    if (v17)
    {
      v18 = v17 + 2;
      do
      {
        v19 = __ldxr(v18);
        v20 = v19 - 1;
      }
      while (__stlxr(v20, v18));
      if (!v20)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v17 + 8))(v17);
      }
    }
    if ((RBPathApplyElements((uint64_t)v13, (uint64_t)v12, (uint64_t)v28, (uint64_t)RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_1::__invoke<void *,RBPathElement,double const*,void const*>) & 1) != 0)
    {
      v21 = *((_QWORD *)&v30 + 1);
      *((_QWORD *)&v30 + 1) = 0;
      v22 = &RB::Path::Object::callbacks;
    }
    else
    {
      v22 = &empty_path_callbacks;
      v21 = 1;
    }
    *a7 = v21;
    a7[1] = (uint64_t)v22;
    if (v35)
      free(v35);
    if ((_QWORD)v33)
      free((void *)v33);
    if (v31[0])
      free(v31[0]);
    a1.info = (void *)*((_QWORD *)&v30 + 1);
    if (*((_QWORD *)&v30 + 1))
    {
      v23 = (unsigned int *)(*((_QWORD *)&v30 + 1) + 8);
      do
      {
        v24 = __ldxr(v23);
        v25 = v24 - 1;
      }
      while (__stlxr(v25, v23));
      if (!v25)
      {
        __dmb(9u);
        a1.info = (void *)(*(uint64_t (**)(void *))(*(_QWORD *)a1.info + 8))(a1.info);
      }
    }
  }
  return a1.info;
}

void sub_209BA7D84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::Info::~Info((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::Info::~Info(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;

  v2 = (void *)a1[284];
  if (v2)
    free(v2);
  v3 = (void *)a1[281];
  if (v3)
    free(v3);
  v4 = (void *)a1[22];
  if (v4)
    free(v4);
  v5 = (unsigned int *)a1[5];
  if (v5)
  {
    v6 = v5 + 2;
    do
    {
      v7 = __ldxr(v6);
      v8 = v7 - 1;
    }
    while (__stlxr(v8, v6));
    if (!v8)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v5 + 8))(v5);
    }
  }
  return a1;
}

BOOL RBPathCanInterpolate(RBPath a1, RBPath a2)
{
  return RBPathCanMix(a1, a2) != 0;
}

uint64_t RBPathCopyInterpolatedPath(RBPath a1, RBPath a2, float a3)
{
  uint64_t v4;
  float64x2_t v5[2];
  uint64_t v6;
  uint64_t v7;

  v5[0] = (float64x2_t)xmmword_209BD5290;
  v5[1] = (float64x2_t)xmmword_209BD52A0;
  v6 = 0;
  v7 = 0;
  RBPathMix(a1, a2, a3, v5, v5, v5, &v4);
  return v4;
}

void RBPathEncode(RBPath a1, RB::ProtobufEncoder *a2)
{
  void *v3;
  uint64_t *v4;
  const unsigned int *v5;
  const unint64_t *v6;
  RB::ProtobufEncoder *v7;
  uint64_t v8;
  void *v9[2];
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  if (a1.callbacks != (RBPathCallbacks *)&empty_path_callbacks)
  {
    v7 = a2;
    *(_OWORD *)v9 = 0u;
    v10 = 64;
    v12 = 0u;
    v13 = 384;
    v16 = 0;
    v15 = 0;
    v17 = 32;
    RBPathApplyElements((uint64_t)a1.info, (uint64_t)a1.callbacks, (uint64_t)&v7, (uint64_t)RBPathEncode(RBPath,RB::ProtobufEncoder &)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
    v3 = v9[1];
    if (v9[0])
      v4 = (uint64_t *)v9[0];
    else
      v4 = &v8;
    if (v9[1])
    {
      RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
      RB::ProtobufEncoder::encode_data(a2, v4, (unint64_t)v3);
    }
    if (*((_QWORD *)&v12 + 1))
    {
      if ((_QWORD)v12)
        v5 = (const unsigned int *)v12;
      else
        v5 = (const unsigned int *)&v11;
      RB::ProtobufEncoder::packed_fixed32_field(a2, 2, v5, *((uint64_t *)&v12 + 1));
    }
    if (v16)
    {
      if (v15)
        v6 = (const unint64_t *)v15;
      else
        v6 = (const unint64_t *)&v14;
      RB::ProtobufEncoder::packed_fixed64_field(a2, 5, v6, v16);
    }
    if (v15)
      free(v15);
    if ((_QWORD)v12)
      free((void *)v12);
    if (v9[0])
      free(v9[0]);
  }
}

void sub_209BA8000(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RBPathEncode(RBPath,RB::ProtobufEncoder &)::Context::~Context((uint64_t *)va);
  _Unwind_Resume(a1);
}

_QWORD *RBPathEncode(RBPath,RB::ProtobufEncoder &)::Context::~Context(_QWORD *a1)
{
  void *v2;
  void *v3;
  void *v4;

  v2 = (void *)a1[239];
  if (v2)
    free(v2);
  v3 = (void *)a1[204];
  if (v3)
    free(v3);
  v4 = (void *)a1[9];
  if (v4)
    free(v4);
  return a1;
}

uint64_t RBPathDecode@<X0>(RB::Decoder *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  unsigned int *v5;
  uint64_t result;
  void *v7;
  unsigned int v8;
  _BYTE v9[64];

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  v5 = (unsigned int *)(v4 + 8);
  *(_QWORD *)v4 = off_24C229608;
  RB::Path::Storage::Storage((uint64_t)v9, (const char *)0x90);
  RB::Path::Storage::Storage((RB::Path::Storage *)(v4 + 16), (const char *)0x90, (const RB::Path::Storage *)v9);
  RB::Path::Storage::~Storage((RB::Path::Storage *)v9);
  result = RB::Path::Storage::decode((RB::Path::Storage *)(v4 + 16), a1);
  if ((result & 1) != 0)
  {
    v7 = &RB::Path::Object::callbacks;
  }
  else
  {
    do
      v8 = __ldxr(v5);
    while (__stlxr(v8 - 1, v5));
    if (v8 == 1)
    {
      __dmb(9u);
      result = (*(uint64_t (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
    }
    v7 = &empty_path_callbacks;
    v4 = 1;
  }
  *a2 = v4;
  a2[1] = (uint64_t)v7;
  return result;
}

void sub_209BA814C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;

  RB::Path::Storage::~Storage((RB::Path::Storage *)&a9);
  MEMORY[0x20BD16544](v9, 0x10F1C40860659AFLL);
  _Unwind_Resume(a1);
}

uint64_t RBPathXMLDescription(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v5;
  int v6;

  v5 = a3;
  v6 = a4;
  return RBPathApplyElements(a1, a2, (uint64_t)&v5, (uint64_t)RBPathXMLDescription(RBPath,std::string &,unsigned int)::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
}

CFDataRef RBPathCopyData(RBPath a1)
{
  CFIndex *v1;
  const __CFAllocator *v2;
  CFDataRef v3;
  CFAllocatorContext context;
  void *v6[4];
  __int128 v7;
  char v8;

  v8 = 0;
  v7 = 0u;
  memset(v6, 0, sizeof(v6));
  RBPathEncode(a1, (RB::ProtobufEncoder *)v6);
  v1 = (CFIndex *)operator new();
  *v1 = (CFIndex)v6[0];
  *(_OWORD *)(v1 + 1) = *(_OWORD *)&v6[1];
  memset(v6, 0, 24);
  context.version = 0;
  context.info = v1;
  memset(&context.retain, 0, 40);
  context.deallocate = (CFAllocatorDeallocateCallBack)RBPathCopyData::$_0::__invoke;
  context.preferredSize = 0;
  v2 = CFAllocatorCreate(0, &context);
  v3 = CFDataCreateWithBytesNoCopy(0, (const UInt8 *)*v1, v1[1], v2);
  if (v2)
    CFRelease(v2);
  if (v6[3])
    free(v6[3]);
  if (v6[0])
    free(v6[0]);
  return v3;
}

void sub_209BA8288(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19)
{
  const void *v19;

  if (v19)
    CFRelease(v19);
  RB::ProtobufEncoder::~ProtobufEncoder((RB::ProtobufEncoder *)&a19);
  _Unwind_Resume(a1);
}

uint64_t RBPathMakeWithData(const __CFData *a1)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  uint64_t v4;
  uint64_t v6;
  _BYTE v7[40];
  _QWORD v8[4];
  void *v9;
  uint64_t v10;
  uint64_t v11;
  char v12;
  _BYTE *v13;
  uint64_t v14;
  _BYTE v15[80];
  __int128 v16;
  _BYTE v17[32];
  unsigned __int8 v18[16];
  int v19;
  char v20;
  uint64_t v21;

  v21 = *MEMORY[0x24BDAC8D0];
  RB::Heap::Heap((RB::Heap *)v7, 0, 0, 0);
  BytePtr = CFDataGetBytePtr(a1);
  Length = CFDataGetLength(a1);
  v8[0] = BytePtr;
  v8[1] = &BytePtr[Length];
  v8[2] = 0;
  v9 = 0;
  v10 = 0;
  v11 = 0;
  v12 = 0;
  v13 = v7;
  v14 = 0;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)v15, 0, 0, 0, 0, 0);
  memset(v17, 0, sizeof(v17));
  v16 = 0u;
  uuid_clear(v18);
  v19 = 0;
  v20 = 1;
  RBPathDecode((RB::Decoder *)v8, &v6);
  v4 = v6;
  RB::ObjectTable::~ObjectTable((RB::ObjectTable *)&v17[8]);
  if ((_QWORD)v16)
    free((void *)v16);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v15);
  if (v9)
    free(v9);
  RB::Heap::~Heap((RB::Heap *)v7);
  return v4;
}

void sub_209BA83F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  RB::Decoder::~Decoder((RB::Decoder *)&a17);
  RB::Heap::~Heap((RB::Heap *)&a12);
  _Unwind_Resume(a1);
}

__CFString *RBPathCopyDebugDescription(uint64_t a1, uint64_t a2)
{
  __CFString *Mutable;

  Mutable = CFStringCreateMutable(0, 0);
  CFStringAppendCString(Mutable, "RBPath:", 0x8000100u);
  RBPathApplyElements(a1, a2, (uint64_t)Mutable, (uint64_t)RBPathCopyDebugDescription::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  CFStringAppendCString(Mutable, "\n", 0x8000100u);
  return Mutable;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD, uint64_t, uint64_t))
{
  uint64_t v3;

  if (*(_BYTE *)(a1 + 56))
    v3 = a1 + 64;
  else
    v3 = 0;
  return a3(a2, *(unsigned __int8 *)(a1 + 48), a1 + 16, v3);
}

BOOL `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  CGAffineTransform v8;
  CGAffineTransform t1;

  v2 = *(unsigned __int8 *)(a1 + 56);
  if (v2 != *(unsigned __int8 *)(a2 + 56) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x28uLL))
    return 0;
  if (!v2)
    return 1;
  v6 = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&t1.a = *(_OWORD *)(a1 + 64);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a1 + 96);
  v7 = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v8.a = *(_OWORD *)(a2 + 64);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tx = *(_OWORD *)(a2 + 96);
  result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result)
    return 1;
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 1;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
  JUMPOUT(0x20BD16544);
}

void `anonymous namespace'::make_single_element_path<`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs>(`anonymous namespace'::make_rect(CGRect,CGAffineTransform const*,RBPathElement)::RectArgs &&,CGAffineTransform const*)::Info::~Info()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RBPathIsEmpty::$_0::__invoke<void *,RBPathElement,double const*,void const*>(_BYTE *a1)
{
  *a1 = 0;
  return 0;
}

uint64_t RBPathEqualToPath::$_0::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t a1, unsigned int a2, double *a3, unsigned __int8 *a4)
{
  BOOL v7;
  uint64_t v9;
  double *v10;
  uint64_t v11;
  int *v12;
  __int128 v13;
  _OWORD *v14;
  __int128 v15;
  void *v16;
  int v17;
  int v18;
  unint64_t v19;
  double *v20;
  double *v21;
  uint64_t v22;
  unsigned __int8 *v23;
  unsigned __int8 v24;
  unsigned __int8 v25;
  _DWORD *v26;
  int v27;
  int v28;
  unint64_t v29;
  double *v30;
  uint64_t v31;
  BOOL v32;
  float *v33;
  float *v34;
  unint64_t v35;
  float v36;
  float v37;
  float v38;
  CGAffineTransform v40;
  CGAffineTransform t1;
  char __dst[65];
  char v43;
  int v44;
  int v45;
  unint64_t v46;
  double *v47;
  void *v48;
  uint64_t v49;
  uint64_t v50;

  v50 = *MEMORY[0x24BDAC8D0];
  v48 = 0;
  v49 = 0x400000000;
  v7 = RB::Path::Storage::Iterator::next((uint64_t *)(a1 + 1088), a1, __dst);
  if (__dst[64] == a2 && v7)
  {
    if (a2 <= 0x18 && __RBPathElementArgumentCount[a2])
    {
      v9 = 8 * __RBPathElementArgumentCount[a2];
      v10 = (double *)__dst;
      while (*a3 == *v10)
      {
        ++a3;
        ++v10;
        v9 -= 8;
        if (!v9)
          goto LABEL_10;
      }
    }
    else
    {
LABEL_10:
      if (!a4 && !v43)
      {
LABEL_13:
        v11 = 1;
        goto LABEL_78;
      }
      switch(a2)
      {
        case 0x10u:
        case 0x12u:
        case 0x16u:
        case 0x17u:
          goto LABEL_13;
        case 0x11u:
        case 0x15u:
          goto LABEL_15;
        case 0x13u:
          v11 = 0;
          v16 = &default_stroke_transform;
          if (a4)
            v16 = a4;
          v17 = v44;
          if (!v43)
            v17 = 0;
          if (v17 != *(_DWORD *)v16)
            goto LABEL_78;
          v11 = 0;
          v18 = v45;
          if (!v43)
            v18 = 0;
          if (v18 != *((_DWORD *)v16 + 1))
            goto LABEL_78;
          v19 = v46;
          if (!v43)
            v19 = 0;
          if (v19 != *((_QWORD *)v16 + 1))
            goto LABEL_77;
          if (v43)
            v20 = v47;
          else
            v20 = 0;
          if (!v19)
            goto LABEL_13;
          v21 = (double *)*((_QWORD *)v16 + 2);
          v22 = 8 * v19;
          break;
        case 0x14u:
          v11 = 0;
          v23 = (unsigned __int8 *)&default_BOOL_transform;
          if (a4)
            v23 = a4;
          v24 = v44;
          if (!v43)
            v24 = 0;
          if (*v23 == v24)
          {
            v11 = 0;
            v25 = v43 ? BYTE1(v44) : 0;
            if (v23[1] == v25)
              goto LABEL_13;
          }
          goto LABEL_78;
        case 0x18u:
          v11 = 0;
          if (a4)
            v26 = a4;
          else
            v26 = &default_clip_stroke_transform;
          v27 = v44;
          if (!v43)
            v27 = 0;
          if (v27 != *v26)
            goto LABEL_78;
          v28 = v45;
          if (!v43)
            v28 = 1;
          if (v28 != v26[1])
            goto LABEL_77;
          v29 = v46;
          if (!v43)
            v29 = 0;
          if (v29 != *((_QWORD *)v26 + 1))
            goto LABEL_77;
          if (v29)
          {
            v30 = v47;
            if (!v43)
              v30 = 0;
            v31 = *((_QWORD *)v26 + 2);
            if (*(_DWORD *)v30 != *(_DWORD *)v31
              || *((float *)v30 + 1) != *(float *)(v31 + 4)
              || *((float *)v30 + 2) != *(float *)(v31 + 8))
            {
              goto LABEL_77;
            }
            v32 = 0;
            v33 = (float *)(v31 + 24);
            v34 = (float *)(v30 + 3);
            v35 = 1;
            do
            {
              if (*(v34 - 3) != *(v33 - 3))
                break;
              v32 = v35 >= v29;
              if (v29 == v35)
                break;
              if (*((_DWORD *)v34 - 2) != *((_DWORD *)v33 - 2))
                break;
              if (*(v34 - 1) != *(v33 - 1))
                break;
              v36 = *v34;
              v34 += 4;
              v37 = v36;
              v38 = *v33;
              v33 += 4;
              ++v35;
            }
            while (v37 == v38);
            if (!v32)
              goto LABEL_77;
          }
          goto LABEL_13;
        default:
          if (a2 == 4)
            goto LABEL_13;
LABEL_15:
          if (v43)
            v12 = &v44;
          else
            v12 = (int *)MEMORY[0x24BDBD8B8];
          v13 = *((_OWORD *)v12 + 1);
          if (a4)
            v14 = a4;
          else
            v14 = (_OWORD *)MEMORY[0x24BDBD8B8];
          *(_OWORD *)&t1.a = *(_OWORD *)v12;
          *(_OWORD *)&t1.c = v13;
          *(_OWORD *)&t1.tx = *((_OWORD *)v12 + 2);
          v15 = v14[1];
          *(_OWORD *)&v40.a = *v14;
          *(_OWORD *)&v40.c = v15;
          *(_OWORD *)&v40.tx = v14[2];
          if (!CGAffineTransformEqualToTransform(&t1, &v40))
            goto LABEL_77;
          goto LABEL_13;
      }
      while (*v20 == *v21)
      {
        ++v20;
        ++v21;
        v22 -= 8;
        if (!v22)
          goto LABEL_13;
      }
    }
  }
LABEL_77:
  v11 = 0;
LABEL_78:
  if (v48)
    free(v48);
  return v11;
}

void sub_209BA89D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{
  if (a40)
    free(a40);
  _Unwind_Resume(exception_object);
}

uint64_t RBPathApply::Context::closepath(uint64_t this)
{
  uint64_t v1;
  __int128 v2;

  if (*(_BYTE *)(this + 24))
  {
    v1 = this;
    v2 = xmmword_209BD9830;
    this = (*(uint64_t (**)(_QWORD, __int128 *))(this + 16))(*(_QWORD *)(this + 8), &v2);
    *(_BYTE *)(v1 + 24) = this;
  }
  return this;
}

uint64_t RBPathApply::Context::moveto(uint64_t result, __n128 a2)
{
  uint64_t v2;
  _QWORD v3[2];
  __n128 v4;

  if (*(_BYTE *)(result + 24))
  {
    v2 = result;
    v4 = a2;
    v3[0] = 0;
    v3[1] = &v4;
    result = (*(uint64_t (**)(_QWORD, _QWORD *))(result + 16))(*(_QWORD *)(result + 8), v3);
    *(_BYTE *)(v2 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::lineto(uint64_t result, __n128 a2)
{
  uint64_t v2;
  _QWORD v3[2];
  __n128 v4;

  if (*(_BYTE *)(result + 24))
  {
    v2 = result;
    v4 = a2;
    v3[1] = &v4;
    v3[0] = 1;
    result = (*(uint64_t (**)(_QWORD, _QWORD *))(result + 16))(*(_QWORD *)(result + 8), v3);
    *(_BYTE *)(v2 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::quadto(uint64_t result, __n128 a2, __n128 a3)
{
  uint64_t v3;
  _QWORD v4[2];
  _OWORD v5[2];
  uint64_t v6;

  v6 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(result + 24))
  {
    v3 = result;
    v5[0] = a2;
    v5[1] = a3;
    v4[1] = v5;
    v4[0] = 2;
    result = (*(uint64_t (**)(_QWORD, _QWORD *))(result + 16))(*(_QWORD *)(result + 8), v4);
    *(_BYTE *)(v3 + 24) = result;
  }
  return result;
}

uint64_t RBPathApply::Context::cubeto(uint64_t result, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v4;
  _QWORD v5[2];
  _OWORD v6[3];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(result + 24))
  {
    v4 = result;
    v6[0] = a2;
    v6[1] = a3;
    v6[2] = a4;
    v5[1] = v6;
    v5[0] = 3;
    result = (*(uint64_t (**)(_QWORD, _QWORD *))(result + 16))(*(_QWORD *)(result + 8), v5);
    *(_BYTE *)(v4 + 24) = result;
  }
  return result;
}

__n128 RBPathApplyLines::Flattener::closepath(__n128 *this)
{
  __n128 result;
  uint64_t v3;

  if (this[4].n128_u8[4])
  {
    v3 = 0;
    this[4].n128_u8[4] = ((uint64_t (*)(unint64_t, uint64_t, uint64_t *))this[1].n128_u64[0])(this->n128_u64[1], 2, &v3);
  }
  result = this[2];
  this[3] = result;
  return result;
}

uint64_t RBPathApplyLines::Flattener::moveto(uint64_t result, __n128 a2)
{
  __n128 *v2;
  __n128 v3;
  __n128 v4;
  uint64_t v5;

  v2 = (__n128 *)result;
  v5 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(result + 68))
  {
    v3 = a2;
    v4 = a2;
    result = (*(uint64_t (**)(_QWORD, _QWORD, __n128 *))(result + 16))(*(_QWORD *)(result + 8), 0, &v4);
    a2 = v3;
    v2[4].n128_u8[4] = result;
  }
  v2[2] = a2;
  v2[3] = a2;
  return result;
}

uint64_t RBPathApplyLines::Flattener::lineto(uint64_t result, __n128 a2)
{
  __n128 *v2;
  __n128 v3;
  __n128 v4;
  uint64_t v5;

  v2 = (__n128 *)result;
  v5 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(result + 68))
  {
    v3 = a2;
    v4 = a2;
    result = (*(uint64_t (**)(_QWORD, uint64_t, __n128 *))(result + 16))(*(_QWORD *)(result + 8), 1, &v4);
    a2 = v3;
    v2[4].n128_u8[4] = result;
  }
  v2[3] = a2;
  return result;
}

double RBPathApplyLines::Flattener::quadto(float64x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4;
  float64x2_t v5;
  double result;

  v4 = vaddq_f64(a2, a2);
  v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  *(_QWORD *)&result = RBPathApplyLines::Flattener::cubeto((uint64_t)a1, (__n128)vmulq_f64(vaddq_f64(a1[3], v4), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3).n128_u64[0];
  return result;
}

__n128 RBPathApplyLines::Flattener::cubeto(uint64_t a1, __n128 result, float64x2_t a3, float64x2_t a4)
{
  float64x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float v10;
  uint32x2_t v12;
  unsigned int v13;
  int v14;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float64x2_t v22;
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  if (!*(_BYTE *)(a1 + 68))
    goto LABEL_10;
  v7 = (float64x2_t)result;
  result.n128_u64[0] = (unint64_t)vcvt_f32_f64(*(float64x2_t *)(a1 + 48));
  *(float32x2_t *)&v7.f64[0] = vcvt_f32_f64(v7);
  *(float32x2_t *)&a3.f64[0] = vcvt_f32_f64(a3);
  v8 = vcvt_f32_f64(a4);
  v9 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(*(float32x2_t *)&a3.f64[0], vadd_f32(*(float32x2_t *)&v7.f64[0], *(float32x2_t *)&v7.f64[0])), (float32x2_t)result.n128_u64[0])), vabs_f32(vadd_f32(vsub_f32(*(float32x2_t *)&v7.f64[0], vadd_f32(*(float32x2_t *)&a3.f64[0], *(float32x2_t *)&a3.f64[0])), v8)));
  v10 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v9, v9)))) * *(float *)(a1 + 64));
  if (((LODWORD(v10) & 0x7FFFFFFFu) - 0x800000) >> 24 >= 0x7F && (LODWORD(v10) & 0x7FFFFFFF) != 0)
  {
LABEL_10:
    *(float64x2_t *)(a1 + 48) = a4;
    return result;
  }
  if (v10 < 1.0)
  {
    v12 = (uint32x2_t)vceq_f32((float32x2_t)result.n128_u64[0], v8);
    result.n128_u64[0] = (unint64_t)vpmin_u32(v12, v12);
    if ((result.n128_u32[0] & 0x80000000) != 0)
      return result;
LABEL_18:
    v17 = a4;
    v19 = a4;
    *(_BYTE *)(a1 + 68) = (*(uint64_t (**)(_QWORD, uint64_t, float64x2_t *))(a1 + 16))(*(_QWORD *)(a1 + 8), 1, &v19);
    result = (__n128)v17;
    *(float64x2_t *)(a1 + 48) = v17;
    return result;
  }
  if (v10 > 1024.0)
    v10 = 1024.0;
  v13 = (int)v10;
  if ((int)v10 < 2)
    goto LABEL_18;
  v16 = a4;
  _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v19, (int)v10);
  if (*(_BYTE *)(a1 + 68))
  {
    do
    {
      *(float32x2_t *)&v19.f64[0] = vadd_f32(*(float32x2_t *)&v19.f64[0], *(float32x2_t *)&v19.f64[1]);
      *(float32x2_t *)&v19.f64[1] = vadd_f32(v20, *(float32x2_t *)&v19.f64[1]);
      v20 = vadd_f32(v21, v20);
      v18 = vcvtq_f64_f32(*(float32x2_t *)&v19.f64[0]);
      v22 = v18;
      v14 = (*(uint64_t (**)(_QWORD, uint64_t, float64x2_t *))(a1 + 16))(*(_QWORD *)(a1 + 8), 1, &v22);
      *(_BYTE *)(a1 + 68) = v14;
      result = (__n128)v18;
      *(float64x2_t *)(a1 + 48) = v18;
      if (!v14)
        break;
    }
    while (v13-- > 2);
    a4 = v16;
    if (v14)
      goto LABEL_18;
  }
  return result;
}

uint64_t RBPathApplyShape::$_0::__invoke<void *,RBPathElement,double const*,void const*>(_QWORD *a1, int a2, __int128 *a3, uint64_t *a4)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  uint64_t v27;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  _BOOL4 v36;
  RBPath v37;
  RBPath v38;
  RBPath v39;

  switch(a2)
  {
    case 5:
    case 6:
    case 7:
      v5 = a3[1];
      v32 = *a3;
      v33 = v5;
      if (a4)
      {
        v6 = *((_OWORD *)a4 + 1);
        v29 = *(_OWORD *)a4;
        v30 = v6;
        v7 = *((_OWORD *)a4 + 2);
      }
      else
      {
        v15 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
        v29 = *MEMORY[0x24BDBD8B8];
        v30 = v15;
        v7 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      }
      v31 = v7;
      ((void (*)(_QWORD, BOOL, __int128 *))a1[1])(*a1, a2 == 7, &v29);
      goto LABEL_26;
    case 8:
    case 9:
      v8 = a3[1];
      v32 = *a3;
      v33 = v8;
      v34 = a3[2];
      LODWORD(v35) = a2 != 8;
      if (a4)
      {
        v9 = *((_OWORD *)a4 + 1);
        v29 = *(_OWORD *)a4;
        v30 = v9;
        v10 = *((_OWORD *)a4 + 2);
      }
      else
      {
        v25 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
        v29 = *MEMORY[0x24BDBD8B8];
        v30 = v25;
        v10 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      }
      v31 = v10;
      ((void (*)(_QWORD, uint64_t, __int128 *))a1[1])(*a1, 3, &v29);
      goto LABEL_26;
    case 10:
    case 11:
      v11 = a3[1];
      v32 = *a3;
      v33 = v11;
      v12 = a3[3];
      v34 = a3[2];
      v35 = v12;
      v36 = a2 != 10;
      if (a4)
      {
        v13 = *((_OWORD *)a4 + 1);
        v29 = *(_OWORD *)a4;
        v30 = v13;
        v14 = *((_OWORD *)a4 + 2);
      }
      else
      {
        v24 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
        v29 = *MEMORY[0x24BDBD8B8];
        v30 = v24;
        v14 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      }
      v31 = v14;
      ((void (*)(_QWORD, uint64_t, __int128 *))a1[1])(*a1, 4, &v29);
      goto LABEL_26;
    case 17:
      if (a4)
      {
        v16 = *((_OWORD *)a4 + 1);
        v30 = *(_OWORD *)a4;
        v31 = v16;
        v17 = *((_OWORD *)a4 + 2);
      }
      else
      {
        v26 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
        v30 = *MEMORY[0x24BDBD8B8];
        v31 = v26;
        v17 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
      }
      v32 = v17;
      v39.info = (void *)a1[2];
      v39.callbacks = (RBPathCallbacks *)a1[3];
      *(_QWORD *)&v29 = RBPathGetNestedPath(v39);
      *((_QWORD *)&v29 + 1) = v27;
      ((void (*)(_QWORD, uint64_t, __int128 *))a1[1])(*a1, 5, &v29);
      goto LABEL_26;
    case 18:
      v30 = *a3;
      v37.info = (void *)a1[2];
      v37.callbacks = (RBPathCallbacks *)a1[3];
      *(_QWORD *)&v29 = RBPathGetNestedPath(v37);
      *((_QWORD *)&v29 + 1) = v18;
      ((void (*)(_QWORD, uint64_t, __int128 *))a1[1])(*a1, 7, &v29);
      goto LABEL_26;
    case 19:
      if (a4)
        v19 = a4;
      else
        v19 = (uint64_t *)&default_stroke_transform;
      v20 = *v19;
      *(_QWORD *)&v30 = *(_QWORD *)a3;
      *((_QWORD *)&v30 + 1) = v20;
      v31 = *(__int128 *)((char *)a3 + 8);
      v21 = v19[1];
      if (!v21 || (v22 = (void *)v19[2]) == 0)
      {
        v21 = 0;
        v22 = &_ZZZ16RBPathApplyShapeENK3__0clIPv13RBPathElementPKdPKvEEDaT_T0_T1_T2_E4zero;
      }
      *(_QWORD *)&v32 = v21;
      *((_QWORD *)&v32 + 1) = v22;
      v38.info = (void *)a1[2];
      v38.callbacks = (RBPathCallbacks *)a1[3];
      *(_QWORD *)&v29 = RBPathGetNestedPath(v38);
      *((_QWORD *)&v29 + 1) = v23;
      ((void (*)(_QWORD, uint64_t, __int128 *))a1[1])(*a1, 6, &v29);
LABEL_26:
      *((_BYTE *)a1 + 32) = 1;
      break;
    default:
      return 0;
  }
  return 0;
}

uint64_t RBPathApplyShape::$_1::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t a1, int a2, float64x2_t *a3, float64x2_t *a4)
{
  uint64_t v4;
  float64x2_t v5;

  if (a2)
  {
    if (a2 == 1)
    {
      v4 = *(_QWORD *)(a1 + 32);
      goto LABEL_6;
    }
    return 0;
  }
  if (*(_QWORD *)(a1 + 32) > 1uLL)
    return 0;
  v4 = 0;
  *(_QWORD *)(a1 + 32) = 0;
LABEL_6:
  if (v4 != a2)
    return 0;
  v5 = *a3;
  if (a4)
    v5 = vmlaq_laneq_f64(vmlaq_n_f64(a4[2], *a4, v5.f64[0]), a4[1], v5, 1);
  *(_QWORD *)(a1 + 32) = v4 + 1;
  *(float64x2_t *)(a1 + 16 * v4) = v5;
  return 1;
}

float32x2_t *RBPathContainsPoints::Winding::endpath(float32x2_t *this)
{
  float32x2_t v1;
  uint32x2_t v2;

  v1 = this[112];
  v2 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v1, this[113]));
  if ((vpmax_u32(v2, v2).u32[0] & 0x80000000) != 0)
    return RBPathContainsPoints::Winding::lineto_float(this, v1);
  return this;
}

float32x2_t *RBPathContainsPoints::Winding::closepath(float32x2_t *this)
{
  float32x2_t v1;
  uint32x2_t v2;

  v1 = this[112];
  v2 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v1, this[113]));
  if ((vpmax_u32(v2, v2).u32[0] & 0x80000000) != 0)
    return RBPathContainsPoints::Winding::lineto_float(this, v1);
  return this;
}

float32x2_t RBPathContainsPoints::Winding::moveto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t v4;
  uint32x2_t v5;
  float32x2_t result;
  float64x2_t v7;

  v4 = a1[112];
  v5 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v4, a1[113]));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    v7 = a2;
    RBPathContainsPoints::Winding::lineto_float(a1, v4);
    a2 = v7;
  }
  result = vcvt_f32_f64(a2);
  a1[113] = result;
  a1[112] = result;
  return result;
}

float32x2_t *RBPathContainsPoints::Winding::lineto(float32x2_t *a1, float64x2_t a2)
{
  return RBPathContainsPoints::Winding::lineto_float(a1, vcvt_f32_f64(a2));
}

float32x2_t *RBPathContainsPoints::Winding::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float64x2_t v4;
  float64x2_t v5;

  v4 = vaddq_f64(a2, a2);
  v5 = (float64x2_t)vdupq_n_s64(0x3FD5555555555555uLL);
  return RBPathContainsPoints::Winding::cubeto(a1, vmulq_f64(vaddq_f64(v4, vcvtq_f64_f32(a1[113])), v5), vmulq_f64(vaddq_f64(v4, a3), v5), a3);
}

float32x2_t *RBPathContainsPoints::Winding::cubeto(float32x2_t *result, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  float32x2_t *v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  int32x2_t v12;
  uint32x2_t v13;
  float32x2_t v14;
  float v15;
  uint32x2_t v18;
  int v19;
  float32x2_t v23;
  int32x2_t v24;
  uint32x2_t v25;
  int32x2_t v26;
  float32x2_t v27;
  uint64_t v28;
  unsigned int v29;
  float32x2_t v30;
  float32x2_t v31;
  float v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int8x16_t v36;
  float32x2_t *v37;
  float32x4_t v38;
  float32x2_t *v39;
  float32x4_t v40;
  int8x16_t v41;
  int8x16_t v42;
  float32x2_t *v43;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;

  v7 = result;
  v8 = result[113];
  v9 = vcvt_f32_f64(a2);
  v10 = vcvt_f32_f64(a3);
  v11 = vcvt_f32_f64(a4);
  v12 = vcgt_f32(vminnm_f32(vminnm_f32(v8, v9), vminnm_f32(v10, v11)), result[111]);
  if ((v12.i8[4] & 1) != 0)
    goto LABEL_16;
  v13 = (uint32x2_t)vcgt_f32(result[110], vmaxnm_f32(vmaxnm_f32(v8, v9), vmaxnm_f32(v10, v11)));
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0)
    goto LABEL_16;
  if ((v12.i8[0] & 1) != 0)
    return RBPathContainsPoints::Winding::lineto_float(result, v11);
  v14 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v10, vadd_f32(v9, v9)), v8)), vabs_f32(vadd_f32(vsub_f32(v9, vadd_f32(v10, v10)), v11)));
  v15 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v14, v14)))));
  _CF = SLODWORD(v15) <= -1 || ((LODWORD(v15) & 0x7FFFFFFFu) - 0x800000) >> 24 >= 0x7F;
  if (_CF && LODWORD(v15) != 0)
  {
LABEL_16:
    result[113] = v11;
    return result;
  }
  if (v15 >= 1.0)
  {
    if (v15 > 1024.0)
      v15 = 1024.0;
    v19 = (int)v15;
    if ((int)v15 >= 2)
    {
      _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v45, (int)v15);
      __asm { FMOV            V1.4S, #1.0 }
      do
      {
        v23 = vadd_f32(v45, v46);
        v45 = v23;
        v46 = vadd_f32(v47, v46);
        v47 = vadd_f32(v48, v47);
        v24 = (int32x2_t)v7[113];
        v7[113] = v23;
        if (COERCE_FLOAT(vminnm_f32(*(float32x2_t *)&v24, v23).i32[1]) <= v7[111].f32[1])
        {
          v25 = (uint32x2_t)vcgt_f32(v7[110], vmaxnm_f32((float32x2_t)v24, v23));
          if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) == 0)
          {
            v26 = (int32x2_t)vsub_f32(v23, (float32x2_t)v24);
            if (fabsf(*(float *)&v26.i32[1]) >= 0.0001)
            {
              v27 = v7[35];
              if (v27)
              {
                v28 = 0;
                if (*(float *)&v26.i32[1] > 0.0)
                  v29 = 1;
                else
                  v29 = -1;
                v30 = vrecpe_f32((float32x2_t)v26.u32[1]);
                v31 = vmul_f32(vrecps_f32((float32x2_t)v26.u32[1], v30), v30);
                LODWORD(v32) = vmul_f32(v31, vrecps_f32((float32x2_t)v26.u32[1], v31)).u32[0];
                v33 = (float32x4_t)vdupq_lane_s32(v24, 1);
                v34 = (float32x4_t)vdupq_lane_s32(v24, 0);
                v35 = (float32x4_t)vdupq_lane_s32(v26, 0);
                v36 = (int8x16_t)vdupq_n_s32(v29);
                do
                {
                  v37 = (float32x2_t *)v7[34];
                  if (!v37)
                    v37 = v7 + 2;
                  v38 = *(float32x4_t *)v37[2 * v28].f32;
                  v39 = (float32x2_t *)v7[70];
                  if (!v39)
                    v39 = v7 + 38;
                  v40 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)v39[2 * v28].f32, v33), v32);
                  v41 = (int8x16_t)vcgtq_f32(vmlaq_f32(v34, v35, v40), v38);
                  v42 = vandq_s8(v36, vandq_s8((int8x16_t)vcgezq_f32(v40), (int8x16_t)vcgeq_f32(_Q1, v40)));
                  v43 = (float32x2_t *)v7[106];
                  if (!v43)
                    v43 = v7 + 74;
                  *(int32x4_t *)v43[2 * v28].f32 = vaddq_s32((int32x4_t)vandq_s8(v42, v41), *(int32x4_t *)v43[2 * v28].f32);
                  ++v28;
                }
                while (*(_QWORD *)&v27 != v28);
              }
            }
          }
        }
      }
      while (v19-- > 2);
    }
    return RBPathContainsPoints::Winding::lineto_float(v7, v11);
  }
  v18 = (uint32x2_t)vceq_f32(v8, v11);
  if ((vpmin_u32(v18, v18).u32[0] & 0x80000000) == 0)
    return RBPathContainsPoints::Winding::lineto_float(v7, v11);
  return result;
}

float32x2_t *RBPathContainsPoints::Winding::lineto_float(float32x2_t *result, float32x2_t a2)
{
  float32x2_t v2;
  uint32x2_t v3;
  int32x2_t v4;
  float32x2_t v5;
  uint64_t v6;
  unsigned int v7;
  float32x2_t v8;
  float32x2_t v9;
  float v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  int8x16_t v14;
  float32x2_t *v20;
  float32x4_t v21;
  float32x2_t *v22;
  float32x4_t v23;
  int8x16_t v24;
  int8x16_t v25;
  float32x2_t *v26;

  v2 = result[113];
  result[113] = a2;
  if (COERCE_FLOAT(vminnm_f32(v2, a2).i32[1]) <= result[111].f32[1])
  {
    v3 = (uint32x2_t)vcgt_f32(result[110], vmaxnm_f32(v2, a2));
    if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
    {
      v4 = (int32x2_t)vsub_f32(a2, v2);
      if (fabsf(*(float *)&v4.i32[1]) >= 0.0001)
      {
        v5 = result[35];
        if (v5)
        {
          v6 = 0;
          if (*(float *)&v4.i32[1] > 0.0)
            v7 = 1;
          else
            v7 = -1;
          v8 = vrecpe_f32((float32x2_t)v4.u32[1]);
          v9 = vmul_f32(vrecps_f32((float32x2_t)v4.u32[1], v8), v8);
          LODWORD(v10) = vmul_f32(v9, vrecps_f32((float32x2_t)v4.u32[1], v9)).u32[0];
          v11 = (float32x4_t)vdupq_lane_s32((int32x2_t)v2, 1);
          v12 = (float32x4_t)vdupq_lane_s32((int32x2_t)v2, 0);
          v13 = (float32x4_t)vdupq_lane_s32(v4, 0);
          v14 = (int8x16_t)vdupq_n_s32(v7);
          __asm { FMOV            V5.4S, #1.0 }
          do
          {
            v20 = (float32x2_t *)result[34];
            if (!v20)
              v20 = result + 2;
            v21 = *(float32x4_t *)v20[2 * v6].f32;
            v22 = (float32x2_t *)result[70];
            if (!v22)
              v22 = result + 38;
            v23 = vmulq_n_f32(vsubq_f32(*(float32x4_t *)v22[2 * v6].f32, v11), v10);
            v24 = (int8x16_t)vcgtq_f32(vmlaq_f32(v12, v13, v23), v21);
            v25 = vandq_s8(v14, vandq_s8((int8x16_t)vcgezq_f32(v23), (int8x16_t)vcgeq_f32(_Q5, v23)));
            v26 = (float32x2_t *)result[106];
            if (!v26)
              v26 = result + 74;
            *(int32x4_t *)v26[2 * v6].f32 = vaddq_s32((int32x4_t)vandq_s8(v25, v24), *(int32x4_t *)v26[2 * v6].f32);
            ++v6;
          }
          while (*(_QWORD *)&v5 != v6);
        }
      }
    }
  }
  return result;
}

void RBPathCopyCGPath::Accumulator::quadto(uint64_t a1, __n128 a2, __n128 a3)
{
  CGPathAddQuadCurveToPoint(*(CGMutablePathRef *)(a1 + 8), 0, a2.n128_f64[0], a2.n128_f64[1], a3.n128_f64[0], a3.n128_f64[1]);
}

uint64_t RBPathCanMix(RBPath,RBPath)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(_QWORD *a1, int a2, uint64_t *a3, uint64_t *a4)
{
  _QWORD *v8;
  uint64_t v9;
  size_t v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  _QWORD *v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  _QWORD *v21;

  v8 = a1 + 3;
  v9 = a1[20];
  v10 = v9 + 1;
  if (a1[21] < (unint64_t)(v9 + 1))
  {
    RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 3, v10);
    v9 = a1[20];
    v10 = v9 + 1;
  }
  v11 = (_QWORD *)a1[19];
  if (!v11)
    v11 = v8;
  *((_BYTE *)v11 + v9) = a2;
  a1[20] = v10;
  if (a2 == 24)
  {
    v15 = (uint64_t *)&default_clip_stroke_transform;
    if (a4)
      v15 = a4;
    v16 = *a3;
    v17 = *v15;
    v18 = a1[41];
    v19 = v18 + 1;
    if (a1[42] < (unint64_t)(v18 + 1))
    {
      RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::reserve_slow(a1 + 32, v19);
      v18 = a1[41];
      v19 = v18 + 1;
    }
    v20 = (_QWORD *)a1[40];
    if (!v20)
      v20 = a1 + 32;
    v21 = &v20[2 * v18];
    *v21 = v16;
    v21[1] = v17;
    a1[41] = v19;
  }
  else if (a2 == 20)
  {
    if (a4)
      v12 = a4;
    else
      v12 = (uint64_t *)&default_BOOL_transform;
    v13 = a1[30];
    if (a1[31] < (unint64_t)(v13 + 1))
    {
      RB::vector<RBPathBooleanTransform,8ul,unsigned long>::reserve_slow(a1 + 27, v13 + 1);
      v13 = a1[30];
    }
    v14 = (_QWORD *)a1[29];
    if (!v14)
      v14 = a1 + 27;
    *((_WORD *)v14 + v13) = *(_WORD *)v12;
    ++a1[30];
  }
  return 1;
}

void *RB::vector<RBPathBooleanTransform,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 4) + (*((_QWORD *)__dst + 4) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 4) + (*((_QWORD *)__dst + 4) >> 1);
  result = RB::details::realloc_vector<unsigned long,2ul>(*((void **)__dst + 2), __dst, 8uLL, (size_t *)__dst + 4, v3);
  *((_QWORD *)__dst + 2) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,2ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 2 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(2 * a5);
    v9 = v8 >> 1;
    if (v8 >> 1 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 2 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

BOOL RBPathCanMix(RBPath,RBPath)::$_1::__invoke<void *,RBPathElement,double const*,void const*>(uint64_t *a1, unsigned int a2, double *a3, int *a4)
{
  _QWORD *v8;
  uint64_t v9;
  _QWORD *v10;
  int v11;
  BOOL v13;
  size_t v14;
  uint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int v18;
  _QWORD *v19;
  _QWORD *v20;
  uint64_t v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  int v25;
  BOOL v27;
  unint64_t v29;
  BOOL v31;
  _QWORD *v32;
  uint64_t v33;
  int *v34;
  int v35;
  int v36;
  double v37;

  if (a2 <= 0x18)
  {
    if (((1 << a2) & 0x1DE0000) != 0)
    {
      v8 = (_QWORD *)a1[24];
      v9 = a1[25];
      if (v8)
        v10 = (_QWORD *)a1[24];
      else
        v10 = a1 + 22;
      v11 = *((unsigned __int8 *)v10 + v9 - 1);
      v13 = a2 == 18 || v11 != 0;
      v14 = v9 + 1;
      if (a1[26] < (unint64_t)(v9 + 1))
      {
        RB::vector<BOOL,16ul,unsigned long>::reserve_slow(a1 + 22, v14);
        v8 = (_QWORD *)a1[24];
        v9 = a1[25];
        v14 = v9 + 1;
      }
      if (!v8)
        v8 = a1 + 22;
      *((_BYTE *)v8 + v9) = v13;
      a1[25] = v14;
    }
    else if (a2 == 16)
    {
      v29 = a1[25];
      if (v29 >= 2)
        a1[25] = v29 - 1;
    }
  }
  v15 = *a1;
  if (*a1 >= (unint64_t)a1[20])
    return 0;
  v16 = a1 + 3;
  v17 = v15 + 1;
  if (a1[19])
    v16 = (_QWORD *)a1[19];
  v18 = *((unsigned __int8 *)v16 + v15);
  *a1 = v17;
  v19 = a1 + 22;
  if (a1[24])
    v19 = (_QWORD *)a1[24];
  if (v18 != a2)
  {
    v25 = *((unsigned __int8 *)v19 + a1[25] - 1);
    v27 = v18 != 5 || v25 != 0;
    if (v18 != 6 && v27)
    {
      if ((v18 & 0xFC) == 8)
      {
        if (a2 != 6)
          return a2 == 5 && v25 == 0;
        return 1;
      }
      return 0;
    }
    v31 = a2 != 5 || v25 != 0;
    if ((a2 & 0xFC) != 8 && a2 != 6 && v31)
      return 0;
  }
  if (a2 == 24)
  {
    v32 = a1 + 32;
    v33 = a1[2];
    a1[2] = v33 + 1;
    if (a1[40])
      v32 = (_QWORD *)a1[40];
    v34 = (int *)&default_clip_stroke_transform;
    if (a4)
      v34 = a4;
    v35 = v32[2 * v33 + 1];
    v36 = *v34;
    if (((*v34 ^ v35) & 1) != 0)
    {
      v37 = *(double *)&v32[2 * v33];
      if ((v37 < 0.0001 || v37 > 0.9999) && fabs(v37 + *a3 + -1.0) < 0.0001)
      {
        v35 &= ~1u;
        v36 &= ~1u;
      }
    }
    if (v35 == v36)
    {
      v23 = HIDWORD(v32[2 * v33 + 1]);
      v24 = v34[1];
      return v23 == v24;
    }
    return 0;
  }
  if (a2 != 20)
    return 1;
  v20 = a1 + 27;
  v21 = a1[1];
  a1[1] = v21 + 1;
  if (a1[29])
    v20 = (_QWORD *)a1[29];
  v22 = (unsigned __int8 *)&default_BOOL_transform;
  if (a4)
    v22 = (unsigned __int8 *)a4;
  if (*((unsigned __int8 *)v20 + 2 * v21) != *v22)
    return 0;
  v23 = *((unsigned __int8 *)v20 + 2 * v21 + 1);
  v24 = v22[1];
  return v23 == v24;
}

uint64_t RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(_QWORD *a1, unsigned int a2, uint64_t *a3, _OWORD *a4)
{
  char v6;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  size_t v11;
  size_t v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v17;
  uint64_t v18;
  _OWORD *v19;
  __int128 v20;
  __int128 v21;
  CGAffineTransform v22;

  v6 = a2;
  if (a2 > 0x18)
  {
    v8 = 0;
    if (!a4)
      goto LABEL_7;
  }
  else
  {
    v8 = __RBPathElementArgumentCount[a2];
    if (!a4)
      goto LABEL_7;
  }
  if (a2 > 0x18 || ((1 << a2) & 0x1DD0010) == 0)
  {
    v17 = a4[1];
    *(_OWORD *)&v22.a = *a4;
    *(_OWORD *)&v22.c = v17;
    *(_OWORD *)&v22.tx = a4[2];
    if (!CGAffineTransformIsIdentity(&v22))
    {
      v18 = a1[285];
      if (a1[286] < (unint64_t)(v18 + 1))
      {
        RB::vector<RB::CustomShader::Closure::marshal_args(RB::RenderPass &,RB::Function &,RB::Rect const*,unsigned char *,RB::BufferRegion &,RB::Texture *&)::PendingArg,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 284), v18 + 1);
        v18 = a1[285];
      }
      v19 = (_OWORD *)(a1[284] + 48 * v18);
      v20 = *a4;
      v21 = a4[2];
      v19[1] = a4[1];
      v19[2] = v21;
      *v19 = v20;
      ++a1[285];
      v6 |= 0x80u;
    }
  }
LABEL_7:
  v9 = a1[23];
  if (a1[24] < (unint64_t)(v9 + 1))
  {
    RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 6, v9 + 1);
    v9 = a1[23];
  }
  v10 = (_QWORD *)a1[22];
  if (!v10)
    v10 = a1 + 6;
  *((_BYTE *)v10 + v9) = v6;
  ++a1[23];
  if (v8)
  {
    v11 = a1[282];
    do
    {
      v12 = v11 + 1;
      if (a1[283] < v11 + 1)
      {
        RB::vector<double,256ul,unsigned long>::reserve_slow(a1 + 25, v12);
        v11 = a1[282];
        v12 = v11 + 1;
      }
      v13 = (_QWORD *)a1[281];
      v14 = *a3++;
      v15 = v14;
      if (!v13)
        v13 = a1 + 25;
      v13[v11] = v15;
      a1[282] = v12;
      v11 = v12;
      --v8;
    }
    while (v8);
  }
  return 1;
}

void *RB::vector<double,256ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 258) + (*((_QWORD *)__dst + 258) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 258) + (*((_QWORD *)__dst + 258) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 256), __dst, 0x100uLL, (size_t *)__dst + 258, v3);
  *((_QWORD *)__dst + 256) = result;
  return result;
}

uint64_t RBPathMix(RBPath,RBPath,float,RB::AffineTransform const&,RB::AffineTransform const&,RB::AffineTransform const&)::$_1::operator()<void *,RBPathElement,double const*,void const*>(uint64_t result, const char *a2, const RB::AffineTransform *__src, __n128 *a4)
{
  __n128 *v4;
  float64x2_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  float64x2_t *v15;
  __n128 v16;
  uint64_t v17;
  int8x16_t *v18;
  size_t v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  float64x2_t v23;
  float64x2_t v24;
  double v25;
  float64x2_t *v26;
  float64x2_t *v27;
  int8x16_t *v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  uint64_t v34;
  uint64_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  double v39;
  float64x2_t v40;
  float64x2_t v41;
  float v42;
  double v43;
  float64x2_t v44;
  double v45;
  float64x2_t v46;
  float64x2_t v47;
  int8x16_t v48;
  double v49;
  __n128 v50;
  __n128 *v51;
  __n128 v52;
  unint64_t v53;
  uint64_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  CGAffineTransform *v61;
  uint64_t v62;
  __int128 v63;
  __int128 v64;
  __n128 v65;
  __int128 v66;
  __int128 v67;
  float64x2_t v68[3];
  CGAffineTransform v69;
  CGAffineTransform v70;
  uint64_t v71;

  v4 = a4;
  v5 = (float64x2_t *)__src;
  v6 = (uint64_t)a2;
  v7 = result;
  v71 = *MEMORY[0x24BDAC8D0];
  v8 = result + 48;
  v9 = *(_QWORD *)(result + 16);
  *(_QWORD *)(result + 16) = v9 + 1;
  if (*(_QWORD *)(result + 176))
    v8 = *(_QWORD *)(result + 176);
  v10 = *(unsigned __int8 *)(v8 + v9);
  if (a2 > 0x18 || ((1 << (char)a2) & 0x1DD0010) == 0)
  {
    if (a4)
    {
      v50 = a4[1];
      *(__n128 *)&v70.a = *a4;
      *(__n128 *)&v70.c = v50;
      *(__n128 *)&v70.tx = a4[2];
      result = CGAffineTransformIsIdentity(&v70);
      if ((_DWORD)result)
        v51 = 0;
      else
        v51 = v4;
      if ((v10 & 0x80) == 0)
        goto LABEL_48;
    }
    else
    {
      v51 = 0;
      if ((v10 & 0x80) == 0)
        goto LABEL_48;
    }
    v53 = *(_QWORD *)(v7 + 32);
    if (v53 < *(_QWORD *)(v7 + 2280))
    {
      *(_QWORD *)(v7 + 32) = v53 + 1;
      v54 = *(_QWORD *)(v7 + 2272) + 48 * v53;
      goto LABEL_49;
    }
LABEL_48:
    v54 = 0;
LABEL_49:
    if ((unint64_t)v51 | v54)
    {
      v55 = (float64x2_t)xmmword_209BD52A0;
      v56 = (float64x2_t)xmmword_209BD5290;
      v57 = 0uLL;
      v58 = xmmword_209BD5290;
      v59 = xmmword_209BD52A0;
      v60 = 0uLL;
      if (v54)
      {
        v58 = *(_OWORD *)v54;
        v59 = *(_OWORD *)(v54 + 16);
        v60 = *(_OWORD *)(v54 + 32);
      }
      *(_OWORD *)&v69.a = v58;
      *(_OWORD *)&v69.c = v59;
      *(_OWORD *)&v69.tx = v60;
      if (v51)
      {
        v56 = *(float64x2_t *)v51;
        v55 = (float64x2_t)v51[1];
        v57 = (float64x2_t)v51[2];
      }
      v68[0] = v56;
      v68[1] = v55;
      v68[2] = v57;
      v61 = RB::mix(&v69, v68, __src, *(float *)v7);
      v4 = &v65;
      v65 = MEMORY[0x24BDAC7A8](v61, v62);
      v66 = v63;
      v67 = v64;
    }
  }
  v11 = v10 & 0x7F;
  if ((v10 & 0x7Fu) > 0x18)
    v12 = 0;
  else
    v12 = __RBPathElementArgumentCount[v11];
  v13 = *(_QWORD *)(v7 + 24);
  if (v13 + v12 > *(_QWORD *)(v7 + 2256))
  {
LABEL_28:
    RB::Path::Storage::append_element((RB::Path::Storage *)(*(_QWORD *)(v7 + 40) + 16), (const char *)v6, v5->f64, (int *)v4);
    return 1;
  }
  v14 = v7 + 200;
  if (*(_QWORD *)(v7 + 2248))
    v14 = *(_QWORD *)(v7 + 2248);
  v15 = (float64x2_t *)(v14 + 8 * v13);
  *(_QWORD *)(v7 + 24) = v13 + v12;
  if ((_DWORD)v11 == (_DWORD)v6)
    goto LABEL_16;
  if ((v10 - 133) < 2 || (v10 - 5) <= 1)
  {
    if ((v6 & 0xFC) == 8)
    {
      MEMORY[0x24BDAC7A8](result, a2);
      v16 = (__n128)v15[1];
      v68[-4] = *v15;
      v65 = v16;
      v66 = 0u;
      v67 = 0u;
      v12 = __RBPathElementArgumentCount[v6];
      v15 = &v68[-4];
LABEL_16:
      v11 = v6;
LABEL_17:
      MEMORY[0x24BDAC7A8](result, 8 * v12);
      v18 = (int8x16_t *)((char *)v68 - v17);
      bzero((char *)v68 - v17, v19);
      v20 = 2 * path_element_leading_vec2s[v11];
      if (v20)
      {
        v21 = 0;
        v22 = *(float *)(v7 + 4);
        v23 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)(v7 + 8)), 0);
        v24 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)v7), 0);
        v25 = *(float *)(v7 + 12);
        v26 = v15;
        v27 = v5;
        v28 = v18;
        do
        {
          v29 = *v26++;
          v30 = v29;
          v31 = *v27++;
          v32 = vmulq_n_f64(v30, v22);
          v33 = vmulq_n_f64(vmlaq_f64(v32, v24, vmlaq_f64(vnegq_f64(v32), v31, v23)), v25);
          *v28++ = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v33), (int8x16_t)vcgezq_f64(v33)), (int8x16_t)v33, (int8x16_t)v30);
          v21 += 2;
        }
        while (v21 < v20);
      }
      else
      {
        v21 = 0;
      }
      if ((v11 & 0xFE) == 0xA)
      {
        v34 = (8 * v21) | 8;
        v35 = 8 * v21 + 16;
        v36 = *(float64x2_t *)((char *)v15 + v35);
        v37.f64[0] = v15->f64[v21];
        v37.f64[1] = *(float64_t *)((char *)v15->f64 + v34);
        v38.f64[0] = v5->f64[v21];
        v38.f64[1] = *(float64_t *)((char *)v5->f64 + v34);
        v39 = *(float *)(v7 + 4);
        v40 = vmulq_n_f64(v36, v39);
        v41 = vmulq_n_f64(v37, v39);
        v42 = *(float *)(v7 + 12);
        v43 = *(float *)(v7 + 8);
        v44 = vmlaq_n_f64(vnegq_f64(v41), v38, v43);
        v45 = *(float *)v7;
        v46 = vmulq_n_f64(vmlaq_n_f64(v40, vmlaq_n_f64(vnegq_f64(v40), *(float64x2_t *)((char *)v5 + v35), v43), v45), v42);
        v47 = vmulq_n_f64(vmlaq_n_f64(v41, v44, v45), v42);
        v48 = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v47), (int8x16_t)vcgezq_f64(v47)), (int8x16_t)v47, (int8x16_t)v37);
        v18->i64[v21] = v48.i64[0];
        *(uint64_t *)((char *)v18->i64 + v34) = v48.i64[1];
        *(int8x16_t *)((char *)v18 + v35) = vbslq_s8(vorrq_s8((int8x16_t)vcltzq_f64(v46), (int8x16_t)vcgezq_f64(v46)), (int8x16_t)v46, (int8x16_t)v36);
        v21 += 4;
      }
      if (v21 < v12)
      {
        v49 = *(float *)v7;
        do
        {
          *(double *)&v18->i64[v21] = v15->f64[v21] + (v5->f64[v21] - v15->f64[v21]) * v49;
          ++v21;
        }
        while (v12 != v21);
      }
      v5 = (float64x2_t *)v18;
      v6 = v11;
      goto LABEL_28;
    }
    if ((v10 & 0x7C) != 8)
    {
      if (((v10 - 5) < 2 || (v10 - 133) < 2) && (v6 - 5) <= 1u)
        goto LABEL_17;
      return 0;
    }
LABEL_42:
    if ((v6 - 5) <= 1u)
    {
      MEMORY[0x24BDAC7A8](result, a2);
      v52 = (__n128)v5[1];
      v68[-4] = *v5;
      v65 = v52;
      v66 = 0u;
      v67 = 0u;
      v5 = &v68[-4];
      goto LABEL_17;
    }
    return 0;
  }
  if ((v10 & 0x7C) == 8)
    goto LABEL_42;
  result = 0;
  if ((v6 - 5) <= 1u && (_DWORD)v11 == 5)
  {
    v11 = 5;
    goto LABEL_17;
  }
  return result;
}

uint64_t RBPathEncode(RBPath,RB::ProtobufEncoder &)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(RB::ProtobufEncoder **a1, unsigned int a2, double *a3, int *a4)
{
  char v6;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  RB::ProtobufEncoder *v11;
  RB::ProtobufEncoder *v12;
  RB::ProtobufEncoder **v13;
  RB::ProtobufEncoder *v14;
  RB::ProtobufEncoder *v15;
  float *v16;
  uint64_t v17;
  double v18;
  float v19;
  RB::ProtobufEncoder *v20;
  double *v21;
  uint64_t v22;
  double v23;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  RB::ProtobufEncoder *v28;
  RB::ProtobufEncoder *v29;
  unint64_t v30;
  int v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  int v37;
  int v38;
  RB::ProtobufEncoder *v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  CGFloat tx;
  CGFloat ty;
  unint64_t v45;
  uint64_t v46;
  CGFloat v47;
  CGAffineTransform *p_dst;
  float v49;
  RB::ProtobufEncoder *v50;
  unint64_t v51;
  _OWORD v52[3];
  CGAffineTransform __dst;
  unint64_t v54;
  uint64_t v55;

  v6 = a2;
  v55 = *MEMORY[0x24BDAC8D0];
  if (a2 > 0x18)
  {
    v8 = 0;
    if (!a4)
      goto LABEL_6;
  }
  else
  {
    v8 = __RBPathElementArgumentCount[a2];
    if (!a4)
      goto LABEL_6;
  }
  switch(a2)
  {
    case 0x10u:
    case 0x12u:
    case 0x16u:
    case 0x17u:
      goto LABEL_6;
    case 0x11u:
    case 0x15u:
      goto LABEL_32;
    case 0x13u:
      if (*a4 || a4[1] || *((_QWORD *)a4 + 1))
      {
        v39 = *a1;
        RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
        RB::ProtobufEncoder::begin_length_delimited(v39);
        RB::ProtobufEncoder::encode_varint(v39, 0x12uLL);
        RB::ProtobufEncoder::begin_length_delimited(v39);
        v40 = *a4;
        if ((_DWORD)v40)
        {
          RB::ProtobufEncoder::encode_varint(v39, 8uLL);
          RB::ProtobufEncoder::encode_varint(v39, v40);
        }
        v41 = a4[1];
        if ((_DWORD)v41)
        {
          RB::ProtobufEncoder::encode_varint(v39, 0x10uLL);
          RB::ProtobufEncoder::encode_varint(v39, v41);
        }
        v42 = *((_QWORD *)a4 + 1);
        if (v42 && *((_QWORD *)a4 + 2))
        {
          tx = 0.0;
          ty = 0.0;
          v45 = 0;
          __dst.tx = 0.0;
          __dst.ty = 0.0;
          v54 = 8;
          do
          {
            v46 = *((_QWORD *)a4 + 2);
            *(_QWORD *)&v47 = *(_QWORD *)&ty + 1;
            if (v54 < *(_QWORD *)&ty + 1)
            {
              RB::vector<RB::Function::Param,8ul,unsigned long>::reserve_slow(&__dst, *(_QWORD *)&ty + 1);
              tx = __dst.tx;
              ty = __dst.ty;
              *(_QWORD *)&v47 = *(_QWORD *)&__dst.ty + 1;
              v42 = *((_QWORD *)a4 + 1);
            }
            if (tx == 0.0)
              p_dst = &__dst;
            else
              p_dst = *(CGAffineTransform **)&tx;
            v49 = *(double *)(v46 + 8 * v45);
            *((float *)&p_dst->a + *(_QWORD *)&ty) = v49;
            __dst.ty = v47;
            ++v45;
            ty = v47;
          }
          while (v45 < v42);
          RB::ProtobufEncoder::packed_fixed32_field(v39, 3, (const unsigned int *)p_dst, *(uint64_t *)&v47);
          if (*(_QWORD *)&__dst.tx)
            free(*(void **)&__dst.tx);
        }
        RB::ProtobufEncoder::end_length_delimited(v39);
        RB::ProtobufEncoder::end_length_delimited(v39);
        v6 = -109;
      }
      else
      {
        v6 = 19;
      }
      goto LABEL_6;
    case 0x14u:
      if (*(_BYTE *)a4 || *((_BYTE *)a4 + 1))
      {
        v50 = *a1;
        RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
        RB::ProtobufEncoder::begin_length_delimited(v50);
        RB::ProtobufEncoder::encode_varint(v50, 0x1AuLL);
        RB::ProtobufEncoder::begin_length_delimited(v50);
        v51 = *(unsigned __int8 *)a4;
        if (*(_BYTE *)a4)
        {
          RB::ProtobufEncoder::encode_varint(v50, 8uLL);
          RB::ProtobufEncoder::encode_varint(v50, v51);
        }
        if (*((_BYTE *)a4 + 1))
        {
          RB::ProtobufEncoder::encode_varint(v50, 0x10uLL);
          RB::ProtobufEncoder::encode_varint(v50, 1uLL);
        }
        RB::ProtobufEncoder::end_length_delimited(v50);
        RB::ProtobufEncoder::end_length_delimited(v50);
        v6 = -108;
      }
      else
      {
        v6 = 20;
      }
      goto LABEL_6;
    case 0x18u:
      if (a4[1] == 1 && !*((_QWORD *)a4 + 1))
      {
        v6 = 24;
        goto LABEL_6;
      }
      v29 = *a1;
      RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v29);
      RB::ProtobufEncoder::encode_varint(v29, 0x22uLL);
      RB::ProtobufEncoder::begin_length_delimited(v29);
      v30 = a4[1];
      if ((_DWORD)v30 != 1)
      {
        RB::ProtobufEncoder::encode_varint(v29, 8uLL);
        RB::ProtobufEncoder::encode_varint(v29, v30);
      }
      v31 = *a4;
      if ((*a4 & 4) != 0)
      {
        RB::ProtobufEncoder::encode_varint(v29, 0x10uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
        v31 = *a4;
        if ((*a4 & 1) == 0)
        {
LABEL_40:
          if ((v31 & 2) == 0)
            goto LABEL_42;
          goto LABEL_41;
        }
      }
      else if ((v31 & 1) == 0)
      {
        goto LABEL_40;
      }
      RB::ProtobufEncoder::encode_varint(v29, 0x18uLL);
      RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      if ((*a4 & 2) != 0)
      {
LABEL_41:
        RB::ProtobufEncoder::encode_varint(v29, 0x20uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      }
LABEL_42:
      if (*((_QWORD *)a4 + 1) && *((_QWORD *)a4 + 2))
      {
        v32 = 0;
        v33 = 0;
        do
        {
          v34 = *((_QWORD *)a4 + 2);
          RB::ProtobufEncoder::encode_varint(v29, 0x2AuLL);
          RB::ProtobufEncoder::begin_length_delimited(v29);
          v35 = *(int *)(v34 + v32 + 4);
          if (*(float *)&v35 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0xDuLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v35);
          }
          v36 = *(int *)(v34 + v32 + 8);
          if (*(float *)&v36 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x15uLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v36);
          }
          v37 = *(int *)(v34 + v32 + 12);
          if (*(float *)&v37 != 0.0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x1DuLL);
            RB::ProtobufEncoder::encode_fixed32(v29, v37);
          }
          v38 = *(_DWORD *)(v34 + v32);
          if ((v38 & 1) != 0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x20uLL);
            RB::ProtobufEncoder::encode_varint(v29, 1uLL);
            v38 = *(_DWORD *)(v34 + v32);
          }
          if ((v38 & 2) != 0)
          {
            RB::ProtobufEncoder::encode_varint(v29, 0x28uLL);
            RB::ProtobufEncoder::encode_varint(v29, 1uLL);
          }
          RB::ProtobufEncoder::end_length_delimited(v29);
          ++v33;
          v32 += 16;
        }
        while (v33 < *((_QWORD *)a4 + 1));
      }
      if ((*(_BYTE *)a4 & 8) != 0)
      {
        RB::ProtobufEncoder::encode_varint(v29, 0x30uLL);
        RB::ProtobufEncoder::encode_varint(v29, 1uLL);
      }
      RB::ProtobufEncoder::end_length_delimited(v29);
      RB::ProtobufEncoder::end_length_delimited(v29);
      v6 = -104;
LABEL_6:
      if (v8)
      {
        v9 = a3;
        v10 = v8;
        while (fabs(*v9) <= 32767.0)
        {
          ++v9;
          if (!--v10)
            goto LABEL_12;
        }
        v6 |= 0x40u;
      }
LABEL_12:
      v11 = a1[10];
      if (a1[11] < (RB::ProtobufEncoder *)((char *)v11 + 1))
      {
        RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(a1 + 1, (size_t)v11 + 1);
        v11 = a1[10];
      }
      v12 = a1[9];
      if (!v12)
        v12 = (RB::ProtobufEncoder *)(a1 + 1);
      *((_BYTE *)v11 + (_QWORD)v12) = v6;
      a1[10] = (RB::ProtobufEncoder *)((char *)a1[10] + 1);
      if ((v6 & 0x40) != 0)
      {
        v13 = a1 + 240;
        v14 = a1[240];
        if (a1[241] < (RB::ProtobufEncoder *)((char *)v14 + v8))
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(a1 + 207, (size_t)v14 + v8);
          v14 = *v13;
          if (!v8)
            goto LABEL_30;
        }
        else if (!v8)
        {
          goto LABEL_30;
        }
        v20 = a1[239];
        if (!v20)
          v20 = (RB::ProtobufEncoder *)(a1 + 207);
        v21 = (double *)((char *)v20 + 8 * (_QWORD)v14);
        v22 = v8;
        do
        {
          v23 = *a3++;
          *v21++ = v23;
          --v22;
        }
        while (v22);
      }
      else
      {
        v13 = a1 + 205;
        v14 = a1[205];
        if (a1[206] < (RB::ProtobufEncoder *)((char *)v14 + v8))
        {
          RB::vector<float,384ul,unsigned long>::reserve_slow(a1 + 12, (size_t)v14 + v8);
          v14 = *v13;
          if (!v8)
            goto LABEL_30;
        }
        else if (!v8)
        {
          goto LABEL_30;
        }
        v15 = a1[204];
        if (!v15)
          v15 = (RB::ProtobufEncoder *)(a1 + 12);
        v16 = (float *)((char *)v15 + 4 * (_QWORD)v14);
        v17 = v8;
        do
        {
          v18 = *a3++;
          v19 = v18;
          *v16++ = v19;
          --v17;
        }
        while (v17);
      }
LABEL_30:
      *v13 = (RB::ProtobufEncoder *)((char *)v14 + v8);
      return 1;
    default:
      if (a2 != 4)
      {
LABEL_32:
        v25 = *((_OWORD *)a4 + 1);
        *(_OWORD *)&__dst.a = *(_OWORD *)a4;
        *(_OWORD *)&__dst.c = v25;
        *(_OWORD *)&__dst.tx = *((_OWORD *)a4 + 2);
        if (!CGAffineTransformIsIdentity(&__dst))
        {
          v26 = *((_OWORD *)a4 + 1);
          v27 = *((_OWORD *)a4 + 2);
          v52[0] = *(_OWORD *)a4;
          v52[1] = v26;
          v52[2] = v27;
          v28 = *a1;
          RB::ProtobufEncoder::encode_varint(*a1, 0x22uLL);
          RB::ProtobufEncoder::begin_length_delimited(v28);
          RB::ProtobufEncoder::encode_varint(v28, 0xAuLL);
          RB::ProtobufEncoder::begin_length_delimited(v28);
          RB::AffineTransform::encode((double *)v52, v28);
          RB::ProtobufEncoder::end_length_delimited(v28);
          RB::ProtobufEncoder::end_length_delimited(v28);
          v6 |= 0x80u;
        }
      }
      goto LABEL_6;
  }
}

void sub_209BAA828(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19)
    free(a19);
  _Unwind_Resume(exception_object);
}

uint64_t RBPathXMLDescription(RBPath,std::string &,unsigned int)::$_0::__invoke<void *,RBPathElement,double const*,void const*>(std::string **a1, unsigned int a2, uint64_t a3, int *a4)
{
  uint64_t v8;
  int v9;
  std::string *v10;
  std::string::size_type size;
  __int128 v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  std::string *v24;
  std::string::size_type v25;
  int v26;
  const char *v27;
  const char *v28;
  size_t v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  size_t v35;
  uint64_t v36;
  size_t v37;
  char *v38;
  size_t v39;
  size_t v40;
  unint64_t v41;
  size_t v42;
  uint64_t v43;
  double v44;
  double v45;
  std::string *v46;
  size_t v47;
  std::string *v48;
  std::string::size_type v49;
  size_t v50;
  uint64_t v52;
  char *v53;
  CGAffineTransform v54;
  char __s[256];
  uint64_t v56;

  v56 = *MEMORY[0x24BDAC8D0];
  if (a2 <= 0x18)
  {
    v8 = a2;
    v9 = *((_DWORD *)a1 + 2);
    if (a4)
    {
      switch(a2)
      {
        case 0x10u:
        case 0x12u:
        case 0x16u:
        case 0x17u:
          break;
        case 0x11u:
        case 0x15u:
          goto LABEL_9;
        case 0x13u:
          if (*a4 > 6 || a4[1] > 2)
          {
            v36 = __RBPathElementArgumentCount[a2];
            goto LABEL_60;
          }
          v10 = *a1;
          if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0)
            size = v10->__r_.__value_.__l.__size_;
          else
            size = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
          if (size)
          {
            std::string::push_back(v10, 32);
            v10 = *a1;
          }
          std::string::append(v10, "{s ", 3uLL);
          std::string::push_back(*a1, 32);
          if (*((_QWORD *)a4 + 1))
          {
            v41 = 0;
            do
            {
              snprintf_l(__s, 0x40uLL, 0, " %g", *(double *)(*((_QWORD *)a4 + 2) + 8 * v41));
              v42 = strlen(__s);
              std::string::append(*a1, __s, v42);
              ++v41;
            }
            while (v41 < *((_QWORD *)a4 + 1));
          }
          std::string::push_back(*a1, 125);
          break;
        case 0x14u:
          switch(*(_BYTE *)a4)
          {
            case 0:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[N";
              v28 = "[n";
              goto LABEL_47;
            case 1:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[I";
              v28 = "[i";
              goto LABEL_47;
            case 2:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[U";
              v28 = "[u";
              goto LABEL_47;
            case 3:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[R";
              v28 = "[r";
              goto LABEL_47;
            case 4:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[X";
              v28 = "[x";
              goto LABEL_47;
            case 5:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[lI";
              v28 = "[li";
              goto LABEL_47;
            case 6:
              v26 = *((unsigned __int8 *)a4 + 1);
              v27 = "[lR";
              v28 = "[lr";
LABEL_47:
              if (v26)
                v38 = (char *)v27;
              else
                v38 = (char *)v28;
              v53 = v38;
              break;
            default:
              break;
          }
          v36 = __RBPathElementArgumentCount[a2];
          goto LABEL_65;
        case 0x18u:
          v52 = a2;
          std::string::append(*a1, "{k ", 3uLL);
          if ((*(_BYTE *)a4 & 1) != 0)
            std::string::append(*a1, " inverse", 8uLL);
          if (*((_QWORD *)a4 + 1))
          {
            v30 = 0;
            v31 = 0;
            do
            {
              v32 = *((_QWORD *)a4 + 2) + v30;
              v33 = "^";
              if ((*(_DWORD *)v32 & 1) == 0)
                v33 = "";
              v34 = "*";
              if ((*(_DWORD *)v32 & 2) == 0)
                v34 = "";
              snprintf_l(__s, 0x40uLL, 0, " %s%s%g:%g,%g", v33, v34, *(float *)(v32 + 4), *(float *)(v32 + 8), *(float *)(v32 + 12));
              v35 = strlen(__s);
              std::string::append(*a1, __s, v35);
              ++v31;
              v30 += 16;
            }
            while (v31 < *((_QWORD *)a4 + 1));
          }
          std::string::push_back(*a1, 125);
          v8 = v52;
          break;
        default:
          if (a2 == 4)
            break;
LABEL_9:
          v12 = *((_OWORD *)a4 + 1);
          *(_OWORD *)&v54.a = *(_OWORD *)a4;
          *(_OWORD *)&v54.c = v12;
          *(_OWORD *)&v54.tx = *((_OWORD *)a4 + 2);
          if (!CGAffineTransformIsIdentity(&v54))
          {
            v13 = *(double *)a4;
            v14 = *((double *)a4 + 1);
            v15 = round(*(double *)a4 * 32.0) * 0.03125;
            if ((v9 & 2) != 0)
              v13 = v15;
            v16 = round(v14 * 32.0) * 0.03125;
            if ((v9 & 2) != 0)
              v14 = v16;
            v17 = *((double *)a4 + 2);
            v18 = *((double *)a4 + 3);
            v19 = round(v17 * 32.0) * 0.03125;
            if ((v9 & 2) != 0)
              v17 = v19;
            v20 = round(v18 * 32.0) * 0.03125;
            if ((v9 & 2) != 0)
              v18 = v20;
            v21 = *((double *)a4 + 4);
            v22 = round(v21 * 32.0) * 0.03125;
            if ((v9 & 2) != 0)
              v21 = v22;
            v23 = round(*((double *)a4 + 5) * 32.0) * 0.03125;
            if ((v9 & 2) == 0)
              v23 = *((double *)a4 + 5);
            snprintf_l(__s, 0x100uLL, 0, "%g %g %g %g %g %g t", v13, v14, v17, v18, v21, v23);
            v24 = *a1;
            if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0)
              v25 = v24->__r_.__value_.__l.__size_;
            else
              v25 = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
            if (v25)
            {
              std::string::push_back(*a1, 32);
              v24 = *a1;
            }
            v37 = strlen(__s);
            std::string::append(v24, __s, v37);
          }
          break;
      }
    }
    v36 = __RBPathElementArgumentCount[v8];
    if (a2 == 19)
    {
LABEL_60:
      if (!a4 || *(double *)(a3 + 16) == 0.0)
      {
        if (*(double *)(a3 + 8) == 10.0)
          v36 -= 2;
        else
          --v36;
      }
    }
LABEL_65:
    if (v36)
    {
      v43 = 0;
      while (1)
      {
        v44 = *(double *)(a3 + 8 * v43);
        v45 = round(v44 * 32.0) * 0.03125;
        if ((v9 & 2) != 0)
          v44 = v45;
        snprintf_l(__s, 0x40uLL, 0, "%g", v44);
        v46 = *a1;
        if (v43)
          goto LABEL_72;
        if (SHIBYTE(v46->__r_.__value_.__r.__words[2]) < 0)
          break;
        if (*((_BYTE *)&v46->__r_.__value_.__s + 23))
          goto LABEL_72;
LABEL_73:
        v47 = strlen(__s);
        std::string::append(v46, __s, v47);
        if (v36 == ++v43)
          goto LABEL_77;
      }
      if (!v46->__r_.__value_.__l.__size_)
        goto LABEL_73;
LABEL_72:
      std::string::push_back(*a1, 32);
      v46 = *a1;
      goto LABEL_73;
    }
LABEL_77:
    v48 = *a1;
    if (SHIBYTE((*a1)->__r_.__value_.__r.__words[2]) < 0)
      v49 = v48->__r_.__value_.__l.__size_;
    else
      v49 = HIBYTE((*a1)->__r_.__value_.__r.__words[2]);
    if (a2 != 16 && v49)
    {
      std::string::push_back(*a1, 32);
      v48 = *a1;
    }
    v50 = strlen(v53);
    std::string::append(v48, v53, v50);
  }
  return 1;
}

void RBPathCopyData::$_0::__invoke(RBPathCopyData::$_0 *this, void **a2, void *a3)
{
  if (a2)
  {
    if (*a2)
      free(*a2);
    JUMPOUT(0x20BD16544);
  }
}

uint64_t RBPathCopyDebugDescription::$_0::__invoke<void *,RBPathElement,double const*,void const*>(__CFString *a1, unsigned int a2, uint64_t *a3, unsigned int *a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  const char *v13;
  const char *v14;
  uint64_t v15;
  const char *v16;
  uint64_t v17;
  unint64_t v18;
  float *v19;
  float v20;
  const char *v21;
  const char *v22;
  const char *v23;
  unint64_t v24;
  const char *v25;

  CFStringAppendCString(a1, "\n  ", 0x8000100u);
  if (a2 > 0x18)
    v8 = 0;
  else
    v8 = __RBPathElementArgumentCount[a2];
  for (; v8; --v8)
  {
    v9 = *a3++;
    CFStringAppendFormat(a1, 0, CFSTR(" %g"), v9);
  }
  if (a4)
  {
    switch(a2)
    {
      case 0x10u:
      case 0x12u:
      case 0x16u:
      case 0x17u:
        return 1;
      case 0x11u:
      case 0x15u:
        goto LABEL_11;
      case 0x13u:
        v10 = *a4;
        if (v10 > 6)
          v11 = "unknown";
        else
        v15 = a4[1];
        if (v15 > 2)
          v16 = "unknown";
        else
        CFStringAppendFormat(a1, 0, CFSTR(" %s %s ["), v11, v16);
        if (*((_QWORD *)a4 + 1))
        {
          v24 = 0;
          do
          {
            if (v24)
              v25 = ", ";
            else
              v25 = "";
            CFStringAppendFormat(a1, 0, CFSTR("%s%g"), v25, *(_QWORD *)(*((_QWORD *)a4 + 2) + 8 * v24++));
          }
          while (v24 < *((_QWORD *)a4 + 1));
        }
        goto LABEL_42;
      case 0x14u:
        if (*((_BYTE *)a4 + 1))
          v14 = "even-odd";
        else
          v14 = "non-zero";
        return 1;
      case 0x18u:
        v12 = a4[1];
        if (v12 > 6)
          v13 = "unknown";
        else
        CFStringAppendFormat(a1, 0, CFSTR(" %s ["), v13);
        if (*((_QWORD *)a4 + 1))
        {
          v17 = 0;
          v18 = 0;
          do
          {
            v19 = (float *)(*((_QWORD *)a4 + 2) + v17);
            v20 = *v19;
            if (v18)
              v21 = ", ";
            else
              v21 = "";
            if ((LOBYTE(v20) & 1) != 0)
              v22 = "^";
            else
              v22 = "";
            if ((LOBYTE(v20) & 2) != 0)
              v23 = "*";
            else
              v23 = "";
            CFStringAppendFormat(a1, 0, CFSTR("%s%s%s%g:%g,%g"), v21, v22, v23, v19[1], v19[2], v19[3]);
            ++v18;
            v17 += 16;
          }
          while (v18 < *((_QWORD *)a4 + 1));
        }
LABEL_42:
        CFStringAppendCString(a1, "]", 0x8000100u);
        break;
      default:
        if (a2 != 4)
LABEL_11:
          CFStringAppendFormat(a1, 0, CFSTR(" affine(%g %g; %g %g; %g %g)"),
            *(_QWORD *)a4,
            *((_QWORD *)a4 + 1),
            *((_QWORD *)a4 + 2),
            *((_QWORD *)a4 + 3),
            *((_QWORD *)a4 + 4),
            *((_QWORD *)a4 + 5));
        break;
    }
  }
  return 1;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v3;

  if (*(_BYTE *)(a1 + 48))
    v3 = a1 + 56;
  else
    v3 = 0;
  return a3(a2, 7, a1 + 16, v3);
}

BOOL `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  BOOL v2;
  BOOL v3;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  CGAffineTransform v8;
  CGAffineTransform t1;

  if (*(unsigned __int8 *)(a1 + 48) != *(unsigned __int8 *)(a2 + 48))
    return 0;
  v2 = *(_QWORD *)(a1 + 16) == *(_QWORD *)(a2 + 16) && *(_QWORD *)(a1 + 24) == *(_QWORD *)(a2 + 24);
  v3 = v2 && *(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32);
  if (!v3 || *(_QWORD *)(a1 + 40) != *(_QWORD *)(a2 + 40))
    return 0;
  if (!*(_BYTE *)(a1 + 48))
    return 1;
  v6 = *(_OWORD *)(a1 + 72);
  *(_OWORD *)&t1.a = *(_OWORD *)(a1 + 56);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a1 + 88);
  v7 = *(_OWORD *)(a2 + 72);
  *(_OWORD *)&v8.a = *(_OWORD *)(a2 + 56);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tx = *(_OWORD *)(a2 + 88);
  result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result)
    return 1;
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
  JUMPOUT(0x20BD16544);
}

void `anonymous namespace'::make_single_element_path<RBPathMakeEllipse::EllipseArgs>(RBPathMakeEllipse::EllipseArgs &&,CGAffineTransform const*)::Info::~Info()
{
  JUMPOUT(0x20BD16544);
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

BOOL `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  CGAffineTransform v8;
  CGAffineTransform t1;

  v2 = *(unsigned __int8 *)(a1 + 72);
  if (v2 != *(unsigned __int8 *)(a2 + 72) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x38uLL))
    return 0;
  if (!v2)
    return 1;
  v6 = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&t1.a = *(_OWORD *)(a1 + 80);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a1 + 112);
  v7 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)&v8.a = *(_OWORD *)(a2 + 80);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tx = *(_OWORD *)(a2 + 112);
  result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result)
    return 1;
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
  JUMPOUT(0x20BD16544);
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v4;
  uint64_t v5;

  if (*(_BYTE *)(a1 + 88))
    v4 = a1 + 96;
  else
    v4 = 0;
  if (*(_BYTE *)(a1 + 80))
    v5 = 11;
  else
    v5 = 10;
  return a3(a2, v5, a1 + 16, v4);
}

BOOL `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  int v2;
  _BOOL8 result;
  __int128 v6;
  __int128 v7;
  CGAffineTransform v8;
  CGAffineTransform t1;

  v2 = *(unsigned __int8 *)(a1 + 88);
  if (v2 != *(unsigned __int8 *)(a2 + 88) || memcmp((const void *)(a1 + 16), (const void *)(a2 + 16), 0x48uLL))
    return 0;
  if (!v2)
    return 1;
  v6 = *(_OWORD *)(a1 + 112);
  *(_OWORD *)&t1.a = *(_OWORD *)(a1 + 96);
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = *(_OWORD *)(a1 + 128);
  v7 = *(_OWORD *)(a2 + 112);
  *(_OWORD *)&v8.a = *(_OWORD *)(a2 + 96);
  *(_OWORD *)&v8.c = v7;
  *(_OWORD *)&v8.tx = *(_OWORD *)(a2 + 128);
  result = CGAffineTransformEqualToTransform(&t1, &v8);
  if (result)
    return 1;
  return result;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#5}::__invoke()
{
  return 3;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::TransformInfo::~TransformInfo()
{
  JUMPOUT(0x20BD16544);
}

void `anonymous namespace'::make_single_element_path<RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs>(RBPathMakeUnevenRoundedRect::UnevenRoundedRectArgs &&,CGAffineTransform const*)::Info::~Info()
{
  JUMPOUT(0x20BD16544);
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  if (!memcmp((const void *)(a1 + 32), (const void *)(a2 + 32), 0x30uLL))
    return RBPathEqualToPath(*(void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 16), *(void **)(a2 + 24));
  else
    return 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

_QWORD *`anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info::~Info(_QWORD *a1)
{
  void (*v2)(_QWORD);

  *a1 = off_24C22A188;
  v2 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v2)
    v2(a1[2]);
  return a1;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t *, _QWORD *))
{
  uint64_t *v6;
  uint64_t v7;
  uint64_t result;
  _QWORD v9[3];

  v6 = a1 + 4;
  v9[0] = a1[7];
  v7 = a1[8];
  v9[1] = a1[9];
  v9[2] = v7;
  result = a3(a2, 19, a1 + 4, v9);
  if ((_DWORD)result)
  {
    result = RBPathApplyElements(a1[2], a1[3], a2, (uint64_t)a3);
    if ((_DWORD)result)
      return a3(a2, 16, v6, 0);
  }
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  if (!memcmp((const void *)(a1 + 32), (const void *)(a2 + 32), 0x38uLL))
    return RBPathEqualToPath(*(void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 16), *(void **)(a2 + 24));
  else
    return 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

_QWORD *`anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info::~Info(_QWORD *a1)
{
  void *v2;
  void (*v3)(_QWORD);

  *a1 = off_24C22A128;
  v2 = (void *)a1[8];
  if (v2)
    free(v2);
  v3 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v3)
    v3(a1[2]);
  return a1;
}

void `anonymous namespace'::make_wrapped_path<RBPathCopyStrokedPath::StrokeArgs>(RBPath,RBPathCopyStrokedPath::StrokeArgs &&)::Info::~Info(_QWORD *a1)
{
  void *v2;
  void (*v3)(_QWORD);

  *a1 = off_24C22A128;
  v2 = (void *)a1[8];
  if (v2)
    free(v2);
  v3 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v3)
    v3(a1[2]);
  JUMPOUT(0x20BD16544);
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#1}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;

  v1 = (unsigned int *)(result + 8);
  do
    v2 = __ldxr(v1);
  while (__stxr(v2 + 1, v1));
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _QWORD))
{
  uint64_t v5;

  v5 = a1 + 32;
  if (a3(a2, 18, a1 + 32, 0)
    && RBPathApplyElements(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2, (uint64_t)a3))
  {
    return a3(a2, 16, v5, 0);
  }
  else
  {
    return 0;
  }
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*,void const)#1}::__invoke(uint64_t a1, uint64_t a2)
{
  if (*(_QWORD *)(a1 + 32) == *(_QWORD *)(a2 + 32) && *(_QWORD *)(a1 + 40) == *(_QWORD *)(a2 + 40))
    return RBPathEqualToPath(*(void **)(a1 + 16), *(_QWORD *)(a1 + 24), *(_QWORD *)(a2 + 16), *(void **)(a2 + 24));
  else
    return 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#3}::__invoke()
{
  return 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

_QWORD *`anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info::~Info(_QWORD *a1)
{
  void (*v2)(_QWORD);

  *a1 = off_24C22A158;
  v2 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v2)
    v2(a1[2]);
  return a1;
}

void `anonymous namespace'::make_wrapped_path<RBPathCopyTrimmedPath::TrimArgs>(RBPath,RBPathCopyTrimmedPath::TrimArgs &&)::Info::~Info(_QWORD *a1)
{
  void (*v1)(_QWORD);

  *a1 = off_24C22A158;
  v1 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v1)
    v1(a1[2]);
  JUMPOUT(0x20BD16544);
}

void *RB::vector<BOOL,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 4) + (*((_QWORD *)__dst + 4) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 4) + (*((_QWORD *)__dst + 4) >> 1);
  result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 2), __dst, 0x10uLL, (size_t *)__dst + 4, v3);
  *((_QWORD *)__dst + 2) = result;
  return result;
}

uint64_t RB::RenderPass::push_layer(uint64_t this)
{
  *(_DWORD *)(this + 136) = 2;
  return this;
}

uint64_t RB::RenderPass::pop_layer(uint64_t this)
{
  *(_DWORD *)(this + 136) = 0;
  return this;
}

void RB::RenderPass::set_color_space(id ***a1, int a2)
{
  char v2;

  if (*((unsigned __int8 *)a1 + 124) != a2)
  {
    v2 = a2;
    if (a1[19])
      RB::RenderFrame::flush_pass(**a1, (RB::RenderPass *)a1, 0);
    *((_BYTE *)a1 + 124) = v2;
  }
}

BOOL RB::RenderPass::set_extra_attachments(uint64_t a1, MTLPixelFormat a2, __n128 a3)
{
  unsigned __int8 v3;
  RB::Device **v5;
  RB::Device *v6;
  int v7;
  unsigned int v8;
  RB::Resource *v10;
  int v11;
  RB *v12;
  unsigned int *v13;
  RB::Resource *v14;
  int v15;
  RB *v16;
  __n128 v17;
  RB::Resource *v18;
  int v19;
  RB::Resource *v20;

  v3 = a2;
  v5 = **(RB::Device ****)a1;
  v6 = *v5;
  v7 = *((unsigned __int8 *)*v5 + 283);
  if (((a2 & 1) != 0 || *((_BYTE *)*v5 + 283)) && !*(_QWORD *)(a1 + 32))
  {
    a3.n128_u64[0] = *(_QWORD *)(a1 + 104);
    a3 = RB::Device::alloc_shared_texture(v6, (RB *)0x41, 1u, 0, 4, (int32x2_t **)&v20, a3);
    if (v20)
    {
      RB::RenderPass::set_attachment(a1, MTLPixelFormatA8Unorm, v20, 0, 0);
      v10 = v20;
      if (v20)
      {
        v11 = *((_DWORD *)v20 + 2) - 1;
        *((_DWORD *)v20 + 2) = v11;
        if (!v11)
          (*(void (**)(RB::Resource *))(*(_QWORD *)v10 + 8))(v10);
      }
    }
    else if ((v3 & 1) != 0)
    {
      return 0;
    }
  }
  v8 = v3;
  if (((v3 & 2) != 0 || v7) && !*(_QWORD *)(a1 + 56))
  {
    if (!*(_QWORD *)(a1 + 8))
      goto LABEL_28;
    v12 = *(RB **)(a1 + 16);
    if ((*(_BYTE *)(*(_QWORD *)a1 + 30) & 8) == 0)
    {
      v13 = RB::pixel_format_traits(*(_QWORD *)(a1 + 16), a2);
      if (v13[8])
        v12 = (RB *)v13[8];
    }
    a3.n128_u64[0] = *(_QWORD *)(a1 + 104);
    RB::Device::alloc_shared_texture(v6, v12, 1u, *(_BYTE *)(a1 + 124), 5, (int32x2_t **)&v20, a3);
    if (v20)
    {
      RB::RenderPass::set_attachment(a1, (MTLPixelFormat)2uLL, v20, 0, 0);
      v14 = v20;
      if (v20)
      {
        v15 = *((_DWORD *)v20 + 2) - 1;
        *((_DWORD *)v20 + 2) = v15;
        if (!v15)
          (*(void (**)(RB::Resource *))(*(_QWORD *)v14 + 8))(v14);
      }
    }
    else
    {
LABEL_28:
      if ((v8 & 2) != 0)
        return 0;
    }
  }
  if ((v8 & 0xC) == 0 && !v7 || *(_QWORD *)(a1 + 80))
    return 1;
  v16 = (RB *)RB::Device::depth_stencil_format(v6, (v8 & 8) != 0, (v8 >> 2) & 1);
  v17.n128_u64[0] = *(_QWORD *)(a1 + 104);
  RB::Device::alloc_shared_texture(v6, v16, 1u, 1, 3, (int32x2_t **)&v20, v17);
  if (v20)
  {
    RB::RenderPass::set_attachment(a1, (MTLPixelFormat)3uLL, v20, 0, 0);
    v18 = v20;
    if (v20)
    {
      v19 = *((_DWORD *)v20 + 2) - 1;
      *((_DWORD *)v20 + 2) = v19;
      if (!v19)
        (*(void (**)(RB::Resource *))(*(_QWORD *)v18 + 8))(v18);
    }
    return 1;
  }
  return (v8 & 0xC) == 0;
}

void sub_209BABDAC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  if (a10)
    RB::RenderPass::set_extra_attachments();
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::RenderPass::draw_primitives(int32x2_t *result, const char *a2, uint64_t a3, __int32 a4, unint64_t a5, uint64_t a6, int32x2_t a7, int32x2_t a8)
{
  id ***v13;
  uint32x2_t v14;
  int32x2_t v15;
  int32x2_t v16;

  v15 = a7;
  v16 = a8;
  if (a5 && a6)
  {
    if ((a6 | a5) >> 32)
      RB::precondition_failure((RB *)"invalid vertex or instance count", a2, *(_QWORD *)&v15, *(_QWORD *)&v16);
    v13 = (id ***)result;
    result = RB::Bounds::intersect(&v15, result[20], result[21]);
    v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v16);
    if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
    {
      result = (int32x2_t *)RB::RenderPass::draw(v13, a2, (int8x8_t *)&v15, 0);
      result[5].i8[2] = a3;
      result[3].i32[0] = a4;
      result[3].i32[1] = a5;
      result[4].i32[0] = a6;
      result[4].i32[1] = 0;
      if (a3 == 4)
        (**v13)[4] = (char *)(**v13)[4] + (a5 - 2) * a6;
    }
  }
  return result;
}

unsigned __int8 *RB::RenderPass::draw_custom(uint64_t a1, const char *a2, uint64_t a3, _OWORD *a4, int a5, int32x2_t a6, int32x2_t a7, float a8)
{
  unsigned __int8 *result;
  uint32x2_t v15;
  __int128 v16;
  unint64_t v17;
  uint64_t v18;
  __int128 v19;
  int32x2_t v20;
  int32x2_t v21;
  _BYTE v22[56];
  uint64_t v23;

  v23 = *MEMORY[0x24BDAC8D0];
  v20 = a6;
  v21 = a7;
  result = (unsigned __int8 *)RB::Bounds::intersect(&v20, *(int32x2_t *)(a1 + 160), *(int32x2_t *)(a1 + 168));
  v15 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v21);
  if ((vpmax_u32(v15, v15).u32[0] & 0x80000000) == 0)
  {
    v16 = a4[1];
    *(_OWORD *)&v22[8] = *a4;
    *(_OWORD *)&v22[24] = v16;
    *(_OWORD *)&v22[40] = a4[2];
    result = (unsigned __int8 *)RB::RenderPass::draw((id ***)a1, a2, (int8x8_t *)&v20, 80);
    v17 = (unint64_t)(result + 49);
    if ((result[48] & 1) != 0)
      v17 = ((unint64_t)(result + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    v18 = v17 + 12 * result[47] + 8 * result[46];
    *(_OWORD *)(v18 + 40) = *(_OWORD *)&v22[32];
    v19 = *(_OWORD *)v22;
    *(_OWORD *)(v18 + 24) = *(_OWORD *)&v22[16];
    *(_QWORD *)v18 = a3;
    *(_QWORD *)(v18 + 56) = *(_QWORD *)&v22[48];
    *(_OWORD *)(v18 + 8) = v19;
    *(float *)(v18 + 64) = a8;
    *(_DWORD *)(v18 + 68) = a5;
  }
  return result;
}

float RB::RenderPass::color_convert(uint64_t a1, int a2, int a3, int a4, int32x2_t a5)
{
  _BOOL4 v9;
  float result;
  RB::Buffer *v11;
  _OWORD *v12;
  __int128 v13;
  MTLPixelFormat v14;
  unsigned int *v15;
  const char *v16;
  __int128 v17;
  __int128 v18;
  RB::Buffer *v19;
  int64x2_t v20;

  RB::Coverage::set_plane((float32x2_t *)&v17, a1, a5);
  v9 = *(_DWORD *)(a1 + 136) == 2;
  LODWORD(v16) = 34;
  HIDWORD(v16) = 2 * v9;
  if (RB::RenderState::set_color_conversion((int *)&v16, a2, a3, (_DWORD *)&v18 + 3))
  {
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x20, 4uLL, 0, &v19);
    v11 = v19;
    if (v19)
    {
      v12 = (_OWORD *)(*((_QWORD *)v19 + 7) + v20.i64[0]);
      v13 = v18;
      *v12 = v17;
      v12[1] = v13;
    }
    else
    {
      v19 = 0;
      v20 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v11);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v20);
    if (!a4
      || (v15 = RB::pixel_format_traits(*(_QWORD *)(a1 + 16), v14),
          ((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x100000000) == 0))
    {
      LODWORD(v16) = v16 | 0x4000000;
    }
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v16, 4, ***(_QWORD ***)a1 + 80, 0, 1uLL, 0, *(int32x2_t *)(a1 + 104));
    result = *(float *)(a1 + 120) + 1.0;
    *(float *)(a1 + 120) = result;
  }
  return result;
}

float RB::RenderPass::resolve_srgb_alpha(RB::RenderPass *this, int32x2_t a2)
{
  RB::Buffer *v3;
  _OWORD *v4;
  __int128 v5;
  uint64_t v6;
  float result;
  __int128 v8;
  __int128 v9;
  RB::Buffer *v10;
  int64x2_t v11;

  RB::Coverage::set_plane((float32x2_t *)&v8, (uint64_t)this, a2);
  HIDWORD(v9) = 1065353216;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)this, (RB::Device *)0x20, 4uLL, 0, &v10);
  v3 = v10;
  if (v10)
  {
    v4 = (_OWORD *)(*((_QWORD *)v10 + 7) + v11.i64[0]);
    v5 = v9;
    *v4 = v8;
    v4[1] = v5;
  }
  else
  {
    v10 = 0;
    v11 = 0uLL;
  }
  *((_DWORD *)this + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)this, v3);
  *(int32x2_t *)((char *)this + 188) = vmovn_s64(v11);
  if (*((_DWORD *)this + 34) == 2)
    v6 = 0x200001022;
  else
    v6 = 4130;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)this, (const char *)v6, 4, ***(_QWORD ***)this + 80, 0, 1uLL, 0, *(int32x2_t *)((char *)this + 104));
  result = *((float *)this + 30) + 1.0;
  *((float *)this + 30) = result;
  return result;
}

void RB::RenderPass::resolve_framebuffer(RB::RenderPass *this, int32x2_t *a2, int32x2_t *a3, const RB::RenderTask *a4, int32x2_t a5, double a6, __n128 a7, __n128 a8)
{
  uint64_t v12;
  RB *v13;
  RB *v14;
  unint64_t v15;
  int v16;
  int v17;
  int v18;
  __int16 v19;
  int v20;
  float v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  RB::RenderFrame *v26;
  int v27;
  int v28;
  RB::RenderPass *v29;
  unsigned int *v31;
  uint64_t v32;
  uint64_t v33;
  int8x8_t v34;
  uint32x2_t v35;
  int8x8_t v36;
  RB::Buffer *v37;
  _OWORD *v38;
  __int128 v39;
  int v40;
  unsigned int *v41;
  unsigned __int8 v42;
  RB *v43;
  char *v44;
  MTLPixelFormat v45;
  char *v46;
  MTLPixelFormat v47;
  char *v48;
  const char *v49;
  const char *v50;
  int v51;
  const char *v52;
  const char *v53;
  const char *v54;
  uint64_t v55;
  float v56;
  _QWORD v57[33];
  __n128 v58;
  __n128 v59;
  __int128 v60;
  __int128 v61;
  RB::Buffer *v62;
  int64x2_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  v12 = *(_QWORD *)this;
  v13 = *(RB **)(*(_QWORD *)this + 8);
  v14 = (RB *)a2[7];
  v15 = (unint64_t)a3[7];
  v16 = a3[10].u8[0];
  v17 = 8;
  v18 = 3;
  v19 = 128;
  switch((unint64_t)v13)
  {
    case 0x80000001uLL:
      if (v14 != (RB *)10 || v15 != 80)
        goto LABEL_81;
      goto LABEL_27;
    case 0x80000002uLL:
      if (v14 != (RB *)10 || v15 != 81)
        goto LABEL_81;
      v19 = 2;
      v17 = 17;
      goto LABEL_38;
    case 0x80000003uLL:
      if (v14 != (RB *)25 || v15 != 115)
        goto LABEL_81;
LABEL_27:
      v19 = 2;
      v17 = 16;
      goto LABEL_38;
    case 0x80000004uLL:
      v20 = 1;
LABEL_14:
      if (v14 == (RB *)40)
        goto LABEL_17;
      if (v14 != (RB *)23)
        goto LABEL_81;
      v19 = 35;
      goto LABEL_18;
    case 0x80000005uLL:
      v20 = 1;
LABEL_10:
      if (v14 == (RB *)43)
      {
LABEL_17:
        v19 = 32;
      }
      else
      {
        if (v14 != (RB *)23)
        {
LABEL_81:
          v43 = (RB *)a3[7];
          v44 = RB::pixel_format_name(v13, (MTLPixelFormat)a2);
          v46 = RB::pixel_format_name(v14, v45);
          v48 = RB::pixel_format_name(v43, v47);
          RB::precondition_failure((RB *)"unexpected framebuffer resolve: %s, %s, %s", v49, v44, v46, v48);
        }
        v19 = 36;
      }
LABEL_18:
      v17 = v20 | 0x18;
      goto LABEL_38;
    case 0x80000006uLL:
      v17 = 9;
LABEL_29:
      if (v14 != (RB *)42)
        goto LABEL_81;
LABEL_37:
      v19 = 0;
LABEL_38:
      v18 = a2[10].u8[0];
      break;
    case 0x80000007uLL:
    case 0x80000009uLL:
      break;
    case 0x80000008uLL:
    case 0x8000000AuLL:
      v18 = 2;
      break;
    case 0x8000000BuLL:
    case 0x8000000CuLL:
      if (a2 != a3 || v14 != (RB *)115)
        goto LABEL_81;
      v17 = 0;
      v19 = 0;
      v16 = *(unsigned __int8 *)(v12 + 29);
      v18 = 5;
      break;
    default:
      v20 = 0;
      switch((unint64_t)v13)
      {
        case '(':
          goto LABEL_14;
        case ')':
          if (v14 != (RB *)41)
            goto LABEL_81;
          v20 = 0;
          goto LABEL_17;
        case '*':
          goto LABEL_29;
        case '+':
          goto LABEL_10;
        default:
          if (v14 != v13 || v15 != (_QWORD)v13)
            goto LABEL_81;
          v17 = 0;
          goto LABEL_37;
      }
  }
  v22 = 1.0;
  if (v18 != v16)
  {
    if (v16 == 1 || v16 == 3)
    {
      v31 = RB::pixel_format_traits(v15, (MTLPixelFormat)a2);
      if (((*v31 | ((unint64_t)*((unsigned __int16 *)v31 + 2) << 32)) & 0x1000000000) == 0)
        v17 |= 4u;
    }
    else if (v16 == 5)
    {
      v50 = RB::color_space_name(v18);
      v51 = 5;
      goto LABEL_84;
    }
    v40 = v18 | (v16 << 8) | 0x101;
    if (v40 == 261)
    {
      v19 |= 0x18u;
LABEL_74:
      if (v18 != 1)
      {
        if (v18 == 5)
        {
          if ((v42 & 1) == 0
          {
            v55 = RB::debug_float((RB *)"RB_PQ_WHITE", v54);
            v56 = *(float *)&v55;
            if ((v55 & 0xFF00000000) == 0)
              v56 = 203.0;
            RB::RenderPass::resolve_framebuffer(RB::Texture *,RB::Texture *,RB::RenderTask const*)::reference_white = LODWORD(v56);
          }
          v17 = v17 & 0x1C | 2;
          v22 = *(float *)&RB::RenderPass::resolve_framebuffer(RB::Texture *,RB::Texture *,RB::RenderTask const*)::reference_white
              * 0.0001;
          goto LABEL_40;
        }
        if (v18 != 3)
          goto LABEL_40;
      }
      v41 = RB::pixel_format_traits((unint64_t)v13, (MTLPixelFormat)a2);
      if (((*v41 | ((unint64_t)*((unsigned __int16 *)v41 + 2) << 32)) & 0x1000000000) == 0)
        v17 = v17 & 0x1C | 1;
      goto LABEL_40;
    }
    if (v40 == 259)
    {
      v19 = v19 & 0xFFE7 | 0x10;
      goto LABEL_74;
    }
    v50 = RB::color_space_name(v18);
    v51 = v16;
LABEL_84:
    v52 = RB::color_space_name(v51);
    RB::precondition_failure((RB *)"unexpected framebuffer colorspace: %s, %s", v53, v50, v52);
  }
LABEL_40:
  v23 = *((_DWORD *)this + 34) == 2;
  if (a3 == a2)
    v24 = 34;
  else
    v24 = 32;
  v25 = v24 & 0xFFC00FFF | ((v19 & 0x3FF) << 12) | (v17 << 22);
  if (a3 == a2)
  {
    v28 = 1;
    v29 = this;
    if (!a4)
      goto LABEL_66;
    goto LABEL_61;
  }
  v26 = **(RB::RenderFrame ***)this;
  if (*(_BYTE *)(*(_QWORD *)v26 + 285))
  {
    v27 = RB::RenderFrame::texture_id(v26, (uint64_t)a2);
    v28 = 1;
    v29 = this;
  }
  else
  {
    RB::RenderFrame::flush_pass((id *)v26, this, 1);
    MEMORY[0x24BDAC7A8](v32, v33);
    v29 = (RB::RenderPass *)v57;
    memset(v57, 0, sizeof(v57));
    RB::RenderPass::RenderPass((uint64_t)v57, *(_QWORD *)this, a2, 0, 0, (uint64_t)v14);
    if ((v19 & 7) == 2)
      v28 = 3;
    else
      v28 = 1;
    v27 = RB::RenderFrame::texture_id(*(RB::RenderFrame **)v57[0], (uint64_t)a3);
    v25 = v25 & 0x7FFF000 | 0x21;
  }
  *((_DWORD *)v29 + 58) = v27;
  if (a4)
  {
LABEL_61:
    v34 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
    do
    {
      a5.i32[0] = 0;
      a8.n128_u64[0] = *((_QWORD *)a4 + 7);
      a7.n128_u64[0] = *((_QWORD *)a4 + 8);
      a7.n128_u32[0] *= v28;
      a8.n128_u32[0] *= v28;
      v35 = (uint32x2_t)vceq_s32((int32x2_t)a8.n128_u64[0], (int32x2_t)0x8000000080000000);
      v36 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v35, v35)), 0);
      v58 = a8;
      v59 = a7;
      RB::Coverage::set_plane((float32x2_t *)&v60, (float32x2_t *)v29, (float32x2_t)vbsl_s8(v36, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a7.n128_u64[0])), COERCE_DOUBLE(vbsl_s8(v36, v34, (int8x8_t)vcvt_f32_s32((int32x2_t)a8.n128_u64[0]))));
      *((float *)&v61 + 3) = v22;
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v29, (RB::Device *)0x20, 4uLL, 0, &v62);
      v37 = v62;
      if (v62)
      {
        v38 = (_OWORD *)(*((_QWORD *)v62 + 7) + v63.i64[0]);
        v39 = v61;
        *v38 = v60;
        v38[1] = v39;
      }
      else
      {
        v62 = 0;
        v63 = 0uLL;
      }
      *((_DWORD *)v29 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v29, v37);
      *(int32x2_t *)((char *)v29 + 188) = vmovn_s64(v63);
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)v29, (const char *)((v23 << 33) | v25), 4, ***(_QWORD ***)v29 + 80, 0, 1uLL, (int32x2_t)v59.n128_u64[0], (int32x2_t)v58.n128_u64[0]);
      a4 = (const RB::RenderTask *)*((_QWORD *)a4 + 6);
    }
    while (a4);
  }
LABEL_66:
  if (v29 == this)
  {
    *((_DWORD *)this + 58) = 0;
    *((_BYTE *)this + 236) = 0;
  }
  else
  {
    RB::RenderPass::~RenderPass(v29);
  }
}

void sub_209BAC7D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::RenderPass::WorkingSpace::WorkingSpace(uint64_t a1, MTLPixelFormat a2, __int16 a3, char a4, unsigned __int8 a5)
{
  int v6;
  RB::RenderParams *v7;
  unsigned __int8 v8;
  MTLPixelFormat v12;
  unsigned int *v13;
  MTLPixelFormat v14;
  int32x2_t v15;
  _DWORD *v16;
  MTLPixelFormat v17;
  uint64_t v18;
  int v19;
  MTLPixelFormat v20;
  int32x2_t v21;
  uint64_t v22;
  __n128 v23;
  RB::RenderPass *v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  int v28;
  uint64_t v30;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = 0;
  v6 = *(unsigned __int8 *)(a2 + 124);
  *(_BYTE *)(a1 + 16) = v6;
  *(_BYTE *)(a1 + 17) = a4;
  *(_BYTE *)(a1 + 18) = 0;
  v7 = *(RB::RenderParams **)a2;
  if ((*(_BYTE *)(*(_QWORD *)a2 + 30) & 8) == 0)
  {
    v8 = a3;
    if ((a3 & 0xFF00) != 0)
    {
      *(_BYTE *)(a1 + 16) = a3;
      if (v6 != a3)
      {
        v12 = *(_QWORD *)(a2 + 8);
        v13 = RB::pixel_format_traits(*(_QWORD *)(v12 + 56), a2);
        v16 = (unsigned int *)((char *)v13 + 18);
        if ((v8 & 1) != 0)
          v16 = v13 + 6;
        if (*v16)
        {
          RB::Device::alloc_shared_texture_view(**(_QWORD **)v7, v12, (RB *)*v16, v8, &v30);
          v18 = v30;
          if (v30)
          {
            if ((a4 & 1) == 0)
            {
              v19 = RB::RenderParams::srgb_alpha(*(RB::RenderParams **)a2, v17);
              if (v19 != ((*((unsigned __int16 *)RB::pixel_format_traits(*(_QWORD *)(v18 + 56), v20) + 2) >> 4) & 1))
              {
                RB::RenderPass::resolve_srgb_alpha((RB::RenderPass *)a2, v21);
                *(_BYTE *)(a1 + 18) = 1;
              }
            }
            v22 = RB::RenderPass::RenderPass(a1 + 24, *(_QWORD *)a2, (int32x2_t *)v18, 0, 1, 0);
            v24 = *(RB::RenderPass **)(a1 + 8);
            *(_QWORD *)(a1 + 8) = v22;
            if (v24)
            {
              RB::RenderPass::~RenderPass(v24);
              v22 = *(_QWORD *)(a1 + 8);
            }
            RB::RenderPass::set_extra_attachments(v22, (MTLPixelFormat)a5, v23);
            v25 = *(_QWORD *)(a1 + 8);
            v26 = *(_QWORD *)(a2 + 168);
            *(_QWORD *)(v25 + 160) = *(_QWORD *)(a2 + 160);
            *(_QWORD *)(v25 + 168) = v26;
            RB::RenderPass::set_label(*(id **)(a1 + 8), CFSTR("RB: working color space"));
            v27 = *(_DWORD *)(v18 + 8) - 1;
            *(_DWORD *)(v18 + 8) = v27;
            if (!v27)
              (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
          }
        }
        else
        {
          if ((a4 & 1) != 0)
          {
            v28 = 0;
          }
          else
          {
            v28 = RB::RenderParams::srgb_alpha(v7, v14);
            v8 = *(_BYTE *)(a1 + 16);
          }
          RB::RenderPass::color_convert(a2, v6, v8, v28, v15);
        }
      }
    }
    else
    {
      *(_BYTE *)(a1 + 16) = v6;
    }
  }
  return a1;
}

{
  return RB::RenderPass::WorkingSpace::WorkingSpace(a1, a2, a3, a4, a5);
}

void sub_209BAC9A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  RB::RenderPass *v3;

  v3 = *(RB::RenderPass **)(v1 + 8);
  *(_QWORD *)(v1 + 8) = 0;
  if (v3)
    RB::RenderPass::~RenderPass(v3);
  _Unwind_Resume(exception_object);
}

float RB::RenderPass::WorkingSpace::commit(RB::RenderPass::WorkingSpace *this, double a2)
{
  id ***v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;

  v3 = (id ***)*((_QWORD *)this + 1);
  if (v3)
  {
    if (*((_BYTE *)this + 18))
    {
      RB::RenderPass::resolve_srgb_alpha(*((RB::RenderPass **)this + 1), *(int32x2_t *)&a2);
      v3 = (id ***)*((_QWORD *)this + 1);
    }
    RB::RenderFrame::flush_pass(**v3, (RB::RenderPass *)v3, 1);
  }
  else
  {
    v4 = *(_QWORD *)this;
    v5 = *(unsigned __int8 *)(*(_QWORD *)this + 124);
    v6 = *((unsigned __int8 *)this + 16);
    if (v5 != v6)
    {
      if (*((_BYTE *)this + 17))
        v7 = 0;
      else
        v7 = *(_BYTE *)(*(_QWORD *)v4 + 30) & 1;
      *(float *)&a2 = RB::RenderPass::color_convert(v4, v6, v5, v7, *(int32x2_t *)&a2);
    }
  }
  return *(float *)&a2;
}

__n128 RB::Stroke::ParticleGenerator::moveto(uint64_t a1, uint64_t a2, double a3)
{
  __n128 result;
  __int128 v4;

  *(double *)(a1 + 48) = a3;
  result = *(__n128 *)a2;
  v4 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 72) = v4;
  *(__n128 *)(a1 + 56) = result;
  return result;
}

__n128 RB::Stroke::ParticleGenerator::lineto(uint64_t a1, float32x2_t *a2, unsigned int *a3, float32x2_t a4, __n128 a5)
{
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  float32x2_t v13;
  int32x2_t v14;
  float v15;
  float32x2_t v16;
  float32x2_t v17;
  float v18;
  int32x2_t v19;
  uint64_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  __int128 v26;
  float v27;
  float v28;
  uint32x2_t v29;
  uint32x2_t v30;
  float v31;
  float32x2_t v32;
  __float2 v33;
  float32x2_t v34;
  float v35;
  float v36;
  float v37;
  float v38;
  RB::Stroke::_anonymous_namespace_ *v39;
  uint64_t v40;
  uint64_t v41;
  float v42;
  float v43;
  __n128 result;
  __int128 v45;
  float32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  int32x2_t v50;
  float v51;
  int v52;
  int v53;
  float32x2_t v54;
  float v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  __int128 v61;
  __int128 v62;
  unsigned int v63;

  v13 = *(float32x2_t *)(a1 + 48);
  v14 = (int32x2_t)vsub_f32(a4, v13);
  v15 = sqrtf(vaddv_f32(vmul_f32((float32x2_t)v14, (float32x2_t)v14)));
  if (v15 <= 0.0001)
  {
    *(double *)(a1 + 48) = *(double *)&a4;
    v20 = a1 + 56;
  }
  else
  {
    v16 = vrecpe_f32((float32x2_t)LODWORD(v15));
    v17 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v15), v16), v16);
    LODWORD(v18) = vmul_f32(v17, vrecps_f32((float32x2_t)LODWORD(v15), v17)).u32[0];
    v19 = (int32x2_t)vmul_n_f32((float32x2_t)v14, v18);
    if (*(_BYTE *)(a1 + 40))
    {
      *(float *)v14.i32 = -*(float *)&v19.i32[1];
      a5.n128_u64[0] = (unint64_t)vzip1_s32(v14, v19);
    }
    else
    {
      a5.n128_u64[0] = 0x3F80000000000000;
    }
    v54 = (float32x2_t)a5.n128_u64[0];
    v20 = a1 + 56;
    *(_QWORD *)&v5 = *(_QWORD *)(a1 + 56);
    LODWORD(v10) = *(_DWORD *)(a1 + 100);
    *(_QWORD *)&v6 = *(_QWORD *)(a1 + 64);
    *(_QWORD *)&v7 = *(_QWORD *)(a1 + 72);
    *(_QWORD *)&v8 = *(_QWORD *)(a1 + 80);
    *(_QWORD *)&v9 = *(_QWORD *)(a1 + 88);
    v21 = vmul_n_f32(vsub_f32(*a2, *(float32x2_t *)&v5), v18);
    v22 = vmul_n_f32(vsub_f32(a2[1], *(float32x2_t *)&v6), v18);
    v23 = vmul_n_f32(vsub_f32(a2[2], *(float32x2_t *)&v7), v18);
    v24 = vmul_n_f32(vsub_f32(a2[3], *(float32x2_t *)&v8), v18);
    v25 = vmul_n_f32(vsub_f32(a2[4], *(float32x2_t *)&v9), v18);
    if (*(float *)&v10 != 0.0)
    {
      v13 = vmla_n_f32(v13, (float32x2_t)v19, *(float *)&v10);
      *(float32x2_t *)&v5 = vmla_n_f32(*(float32x2_t *)&v5, v21, *(float *)&v10);
      *(float32x2_t *)&v6 = vmla_n_f32(*(float32x2_t *)&v6, v22, *(float *)&v10);
      *(float32x2_t *)&v7 = vmla_n_f32(*(float32x2_t *)&v7, v23, *(float *)&v10);
      *(float32x2_t *)&v8 = vmla_n_f32(*(float32x2_t *)&v8, v24, *(float *)&v10);
      *(float32x2_t *)&v9 = vmla_n_f32(*(float32x2_t *)&v9, v25, *(float *)&v10);
    }
    if (*(float *)&v10 < v15)
    {
      *((_QWORD *)&v26 + 1) = a5.n128_u64[1];
      *(int32x2_t *)&v26 = vdup_lane_s32((int32x2_t)a5.n128_u64[0], 0);
      v47 = (float32x2_t)v26;
      v48 = v23;
      v27 = fmaxf((float)(v15 - *(float *)&v10) * 0.00097656, 1.0);
      v28 = 0.5 * v21.f32[0];
      v50 = v19;
      v51 = v15;
      v49 = v21;
      do
      {
        if (*(float *)&v5 >= v27)
          *(float *)&v26 = *(float *)&v5;
        else
          *(float *)&v26 = v27;
        v29 = (uint32x2_t)vcgt_f32(v13, *(float32x2_t *)(a1 + 32));
        if ((vpmax_u32(v29, v29).u32[0] & 0x80000000) == 0)
        {
          v30 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 24), v13);
          if ((vpmax_u32(v30, v30).u32[0] & 0x80000000) == 0)
          {
            v56 = v26;
            v57 = v10;
            v60 = v5;
            v63 = *(_DWORD *)(a1 + 96);
            v61 = v6;
            v59 = v8;
            v62 = v9;
            v58 = v7;
            if (*((float *)&v7 + 1) == 0.0)
            {
              v31 = *(float *)&v7;
            }
            else
            {
              *(_QWORD *)&v6 = v61;
              *(_QWORD *)&v9 = v62;
              *(_QWORD *)&v8 = v59;
            }
            v32 = v54;
            if (fabsf(v31) > 0.005)
            {
              v33 = __sincosf_stret(v31);
              *(_QWORD *)&v6 = v61;
              *(_QWORD *)&v9 = v62;
              *(_QWORD *)&v8 = v59;
              v34.f32[0] = -v33.__sinval;
              v34.i32[1] = LODWORD(v33.__cosval);
              v32 = vmla_f32(vmul_lane_f32(v34, v54, 1), v47, (float32x2_t)__PAIR64__(LODWORD(v33.__sinval), LODWORD(v33.__cosval)));
            }
            if (*((float *)&v8 + 1) == 0.0)
            {
              v55 = *(float *)&v8;
            }
            else
            {
              *(_QWORD *)&v6 = v61;
              *(_QWORD *)&v9 = v62;
              v55 = v35;
            }
            if (*((float *)&v6 + 1) != 0.0)
            {
              *(_QWORD *)&v9 = v62;
              *(float *)&v6 = v36;
            }
            if (*((float *)&v9 + 1) == 0.0)
            {
              v37 = *(float *)&v9;
            }
            else
            {
              v52 = v6;
              LODWORD(v6) = v52;
              v37 = v38;
            }
            v39 = *(RB::Stroke::_anonymous_namespace_ **)(a1 + 16);
            if (v39 == (RB::Stroke::_anonymous_namespace_ *)1)
            {
              v40 = 0;
            }
            else
            {
              v53 = v6;
              LODWORD(v6) = v53;
              v40 = v41;
            }
            (***(void (****)(_QWORD, uint64_t, double, double, float, float))(a1 + 8))(*(_QWORD *)(a1 + 8), v40, COERCE_DOUBLE(vmla_n_f32(v13, v32, v55)), COERCE_DOUBLE(vmul_n_f32(v32, *(float *)&v6)), v37, *((float *)&v60 + 1));
            v8 = v59;
            v5 = v60;
            v19 = v50;
            v15 = v51;
            v6 = v61;
            v9 = v62;
            v10 = v57;
            v7 = v58;
            v21 = v49;
            v23 = v48;
            v26 = v56;
          }
        }
        v42 = *(float *)&v26 + v28;
        v43 = *(float *)&v10 + (float)(*(float *)&v26 + v28);
        if (v43 == *(float *)&v10)
          break;
        v13 = vmla_n_f32(v13, (float32x2_t)v19, v42);
        LODWORD(v5) = v26;
        *(float32x2_t *)&v5 = vmla_n_f32(*(float32x2_t *)&v5, v21, v42);
        *(float32x2_t *)&v6 = vmla_n_f32(*(float32x2_t *)&v6, v22, v42);
        *(float32x2_t *)&v7 = vmla_n_f32(*(float32x2_t *)&v7, v23, v42);
        *(float32x2_t *)&v8 = vmla_n_f32(*(float32x2_t *)&v8, v24, v42);
        *(float32x2_t *)&v9 = vmla_n_f32(*(float32x2_t *)&v9, v25, v42);
        *(_DWORD *)(a1 + 96) = 1664525 * *(_DWORD *)(a1 + 96) + 1013904223;
        *(float *)&v10 = *(float *)&v10 + (float)(*(float *)&v26 + v28);
      }
      while (v43 < v15);
    }
    *(float *)(a1 + 100) = *(float *)&v10 - v15;
    *(double *)(a1 + 48) = *(double *)&a4;
  }
  result = *(__n128 *)a2->f32;
  v45 = *(_OWORD *)a2[2].f32;
  *(float32x2_t *)(v20 + 32) = a2[4];
  *(__n128 *)v20 = result;
  *(_OWORD *)(v20 + 16) = v45;
  return result;
}

void RB::Stroke::ParticleGenerator::skipto()
{
  abort();
}

float RB::Stroke::`anonymous namespace'::sample_slow(unsigned int *a1, double _D0)
{
  unsigned int v2;
  float result;

  v2 = 73189 * *a1 + 101513;
  *a1 = v2;
  _S1 = (float)((float)HIWORD(v2) * 0.000015259) + -0.5;
  __asm { FMLA            S0, S1, V0.S[1] }
  return result;
}

uint64_t RB::Stroke::`anonymous namespace'::sample_index_slow(RB::Stroke::_anonymous_namespace_ *this, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  float v4;

  v3 = 73189 * *a2 + 101513;
  v4 = (float)((float)(unint64_t)this * 0.000015259) * (float)HIWORD(v3);
  *a2 = v3;
  if ((unint64_t)this - 1 >= (int)v4)
    return (int)v4;
  else
    return (uint64_t)this - 1;
}

uint64_t RB::ColorMatrix::operator==(float16x4_t *a1, float16x4_t *a2)
{
  uint16x4_t v2;

  v2 = (uint16x4_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8(vandq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(a1[1]), vcvtq_f32_f16(a2[1])), (int8x16_t)vceqq_f32(vcvtq_f32_f16(*a1), vcvtq_f32_f16(*a2))), vandq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(a1[2]), vcvtq_f32_f16(a2[2])), (int8x16_t)vceqq_f32(vcvtq_f32_f16(a1[3]), vcvtq_f32_f16(a2[3])))), (int8x16_t)vceqq_f32(vcvtq_f32_f16(a1[4]), vcvtq_f32_f16(a2[4]))));
  v2.i16[0] = vminv_u16(v2);
  return ((unsigned __int32)v2.i32[0] >> 15) & 1;
}

uint64_t RB::ColorMatrix::is_identity(float16x4_t *this)
{
  uint16x4_t v2;

  if ((vminv_u16((uint16x4_t)vmovn_s32(vceqq_f32(vcvtq_f32_f16(*this), (float32x4_t)xmmword_209BD5460))) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vmovn_s32(vceqq_f32(vcvtq_f32_f16(this[1]), (float32x4_t)xmmword_209BD9A40))) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vmovn_s32(vceqq_f32(vcvtq_f32_f16(this[2]), (float32x4_t)xmmword_209BD95B0))) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vmovn_s32(vceqq_f32(vcvtq_f32_f16(this[3]), (float32x4_t)xmmword_209BD9A50))) & 0x8000) == 0)
  {
    return 0;
  }
  v2 = (uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(this[4])));
  v2.i16[0] = vminv_u16(v2);
  return ((unsigned __int32)v2.i32[0] >> 15) & 1;
}

BOOL RB::ColorMatrix::has_alpha(float16x4_t *this)
{
  if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(this[3]), (float32x4_t)xmmword_209BD9A50)))) & 0x8000) != 0)return 1;
  _H0 = this->i16[3];
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 1;
  _H0 = this[1].i16[3];
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 1;
  _H0 = this[2].i16[3];
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 1;
  _H0 = this[4].i16[3];
  __asm { FCVT            S0, H0 }
  return _S0 != 0.0;
}

BOOL RB::ColorMatrix::is_alpha_identity(RB::ColorMatrix *this)
{
  _H0 = *((_WORD *)this + 3);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 7);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 11);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 15);
  __asm { FCVT            S0, H0 }
  if (_S0 != 1.0)
    return 0;
  _H0 = *((_WORD *)this + 19);
  __asm { FCVT            S0, H0 }
  return _S0 == 0.0;
}

BOOL RB::ColorMatrix::is_alpha_zero(RB::ColorMatrix *this)
{
  _H0 = *((_WORD *)this + 3);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 7);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 11);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 15);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 0;
  _H0 = *((_WORD *)this + 19);
  __asm { FCVT            S0, H0 }
  return _S0 == 0.0;
}

uint64_t RB::ColorMatrix::is_diagonal(float16x4_t *this)
{
  uint64_t result;
  uint16x4_t v31;

  result = 0;
  _H0 = this->i16[1];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
  {
    _H0 = this->i16[2];
    __asm { FCVT            S0, H0 }
    if (_S0 == 0.0)
    {
      _H0 = this->i16[3];
      __asm { FCVT            S0, H0 }
      if (_S0 == 0.0)
      {
        result = 0;
        _H0 = this[1].i16[0];
        __asm { FCVT            S0, H0 }
        if (_S0 == 0.0)
        {
          _H0 = this[1].i16[2];
          __asm { FCVT            S0, H0 }
          if (_S0 == 0.0)
          {
            _H0 = this[1].i16[3];
            __asm { FCVT            S0, H0 }
            if (_S0 == 0.0)
            {
              result = 0;
              _H0 = this[2].i16[0];
              __asm { FCVT            S0, H0 }
              if (_S0 == 0.0)
              {
                _H0 = this[2].i16[1];
                __asm { FCVT            S0, H0 }
                if (_S0 == 0.0)
                {
                  _H0 = this[2].i16[3];
                  __asm { FCVT            S0, H0 }
                  if (_S0 == 0.0)
                  {
                    result = 0;
                    _H0 = this[3].i16[0];
                    __asm { FCVT            S0, H0 }
                    if (_S0 == 0.0)
                    {
                      _H0 = this[3].i16[1];
                      __asm { FCVT            S0, H0 }
                      if (_S0 == 0.0)
                      {
                        _H0 = this[3].i16[2];
                        __asm { FCVT            S0, H0 }
                        if (_S0 == 0.0)
                        {
                          v31 = (uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(this[4])));
                          v31.i16[0] = vminv_u16(v31);
                          return ((unsigned __int32)v31.i32[0] >> 15) & 1;
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
  return result;
}

BOOL RB::ColorMatrix::is_alpha_multiply(float16x4_t *this, char a2)
{
  uint64_t v2;
  uint16x4_t v4;

  if ((vminv_u16((uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(*this)))) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(this[1])))) & 0x8000) == 0
    || (vminv_u16((uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(this[2])))) & 0x8000) == 0)
  {
    return 0;
  }
  if ((a2 & 1) != 0)
  {
    v4 = (uint16x4_t)vmovn_s32(vceqzq_f32(vcvtq_f32_f16(this[4])));
    v4.i16[0] = vminv_u16(v4);
    return ((unsigned __int32)v4.i32[0] >> 15) & 1;
  }
  else
  {
    v2 = 0;
    _H0 = this[3].i16[0];
    __asm { FCVT            S0, H0 }
    if (_S0 == 0.0)
    {
      _H0 = this[3].i16[1];
      __asm { FCVT            S0, H0 }
      if (_S0 == 0.0)
      {
        _H0 = this[3].i16[2];
        __asm { FCVT            S0, H0 }
        if (_S0 == 0.0)
        {
          _H0 = this[4].i16[3];
          __asm { FCVT            S0, H0 }
          return _S0 == 0.0;
        }
      }
    }
  }
  return v2;
}

BOOL RB::ColorMatrix::is_alpha_color_dependent(RB::ColorMatrix *this)
{
  _H0 = *((_WORD *)this + 3);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 1;
  _H0 = *((_WORD *)this + 7);
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
    return 1;
  _H0 = *((_WORD *)this + 11);
  __asm { FCVT            S0, H0 }
  return _S0 != 0.0;
}

double RB::ColorMatrix::set_identity(RB::ColorMatrix *this)
{
  double result;

  *(_QWORD *)this = 15360;
  *((_QWORD *)this + 1) = 1006632960;
  *((_QWORD *)this + 2) = 0x3C0000000000;
  *((_QWORD *)this + 3) = 0x3C00000000000000;
  result = 0.0;
  *((_QWORD *)this + 4) = 0;
  return result;
}

float16x4_t RB::ColorMatrix::set_color_matrix(float16x4_t *this, float32_t *a2)
{
  float32x4_t v2;
  float16x4_t result;

  v2.f32[0] = *a2;
  v2.f32[1] = a2[5];
  v2.f32[2] = a2[10];
  v2.f32[3] = a2[15];
  *this = vcvt_f16_f32(v2);
  v2.f32[0] = a2[1];
  v2.f32[1] = a2[6];
  v2.f32[2] = a2[11];
  v2.f32[3] = a2[16];
  this[1] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[2];
  v2.f32[1] = a2[7];
  v2.f32[2] = a2[12];
  v2.f32[3] = a2[17];
  this[2] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[3];
  v2.f32[1] = a2[8];
  v2.f32[2] = a2[13];
  v2.f32[3] = a2[18];
  this[3] = vcvt_f16_f32(v2);
  v2.f32[0] = a2[4];
  v2.f32[1] = a2[9];
  v2.f32[2] = a2[14];
  v2.f32[3] = a2[19];
  result = vcvt_f16_f32(v2);
  this[4] = result;
  return result;
}

double RB::ColorMatrix::set_color(_QWORD *a1, double a2)
{
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  double result;

  LOWORD(v2) = 0;
  HIWORD(v2) = WORD1(a2);
  *a1 = LOWORD(a2);
  a1[1] = v2;
  v3 = 0;
  WORD2(v3) = WORD2(a2);
  v4 = 0;
  HIWORD(v4) = HIWORD(a2);
  result = 0.0;
  a1[2] = v3;
  a1[3] = v4;
  a1[4] = 0;
  return result;
}

int8x8_t RB::ColorMatrix::set_alpha_multiply(int8x8_t *a1, int a2, int8x8_t a3)
{
  unsigned int v3;
  int8x8_t v4;
  int8x8_t v5;
  int8x8_t result;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
    v3 = -1;
  else
    v3 = 0;
  v4 = (int8x8_t)vdup_n_s16(v3);
  v5 = vand_s8(a3, v4);
  v5.i16[3] = a3.i16[3];
  a3.i16[3] = 0;
  result = vbic_s8(a3, v4);
  a1[3] = v5;
  a1[4] = result;
  return result;
}

uint64_t RB::ColorMatrix::set_inverse_alpha_multiply(uint64_t result, char a2, float16x4_t a3, double a4, double a5, int16x4_t _D3)
{
  float32x4_t v13;
  uint64_t v18;
  double v19;

  *(_QWORD *)result = 0;
  *(_QWORD *)(result + 8) = 0;
  *(_QWORD *)(result + 16) = 0;
  _H1 = a3.i16[3];
  if ((a2 & 1) != 0)
  {
    __asm { FCVT            S2, H1 }
    _S1 = -_S2;
    __asm { FCVT            H3, S1 }
    v13 = vcvtq_f32_f16(a3);
    LODWORD(v18) = vcvt_f16_f32(vmulq_f32(v13, vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D3, 0)))).u32[0];
    _H5 = a3.i16[2];
    __asm
    {
      FCVT            S5, H5
      FCVT            S6, H3
    }
    _S6 = _S5 * _S6;
    __asm { FCVT            H6, S6 }
    WORD2(v18) = LOWORD(_S6);
    HIWORD(v18) = _D3.i16[0];
    LODWORD(v19) = vcvt_f16_f32(vmulq_f32(v13, vcvtq_f32_f16((float16x4_t)vdup_lane_s16((int16x4_t)a3, 3)))).u32[0];
    _S2 = _S5 * _S2;
    __asm { FCVT            H2, S2 }
    WORD2(v19) = LOWORD(_S2);
    HIWORD(v19) = a3.i16[3];
    *(double *)&a3 = v19;
  }
  else
  {
    __asm { FCVT            S1, H1 }
    _S1 = -_S1;
    __asm { FCVT            H2, S1 }
    v18 = 0;
    HIWORD(v18) = _H2;
  }
  *(_QWORD *)(result + 24) = v18;
  *(double *)(result + 32) = *(double *)&a3;
  return result;
}

__n64 RB::ColorMatrix::alpha_multiply_color(RB::ColorMatrix *this, char a2)
{
  __n64 result;

  if ((a2 & 1) != 0)
  {
    return *(__n64 *)((char *)this + 24);
  }
  else
  {
    result.n64_u64[0] = *(_QWORD *)((unint64_t)this + 32);
    result.n64_u16[3] = HIWORD(*((_QWORD *)this + 3));
  }
  return result;
}

__int16 RB::ColorMatrix::set_hue_rotate@<H0>(float32x2_t *this@<X0>, float a2@<S0>)
{
  __float2 v3;
  float32x4_t v9;
  float v10;
  float32x2_t v11;
  float32x2_t v13;
  float32x2_t v14;
  float32x4_t v15;
  float32x2_t v17;
  float32x2_t v20;
  __int16 result;

  this[3] = (float32x2_t)0x3C00000000000000;
  this[4] = 0;
  v3 = __sincosf_stret(a2);
  _S2 = (float)((float)(v3.__cosval * 0.7873) + 0.2126) + (float)(v3.__sinval * -0.2126);
  __asm { FCVT            H2, S2 }
  v9.f32[0] = 0.0722 - (float)(v3.__cosval * 0.0722);
  v10 = (float)(v3.__cosval * -0.2126) + 0.2126;
  v11.i32[0] = 1060575065;
  _D6 = vmul_n_f32((float32x2_t)0x3E91D14E3F371759, v3.__cosval);
  v13 = vsub_f32(v11, _D6);
  v14 = vmul_n_f32((float32x2_t)0x3E0F5C293F371759, v3.__sinval);
  v15.i32[0] = vsub_f32(v13, v14).u32[0];
  v13.i32[1] = vadd_f32(_D6, (float32x2_t)vdup_n_s32(0x3F371759u)).i32[1];
  _D6.f32[0] = v10 + (float)(v3.__sinval * 0.143);
  _D16 = vadd_f32(v13, v14);
  v15.i32[1] = _D16.i32[1];
  v13.i32[0] = vcvt_f16_f32(v15).u32[0];
  __asm { FCVT            H16, S16 }
  v13.i32[1] = _D16.u16[0];
  v17 = vmul_n_f32((float32x2_t)0x3E90E5603F6D844DLL, v3.__sinval);
  *(int32x2_t *)v15.f32 = vdup_lane_s32(*(int32x2_t *)v9.f32, 0);
  v9.i32[0] = vadd_f32(*(float32x2_t *)v9.f32, v17).u32[0];
  v9.i32[1] = vsub_f32(*(float32x2_t *)&v15, v17).i32[1];
  v9.i32[0] = vcvt_f16_f32(v9).u32[0];
  _S1 = (float)((float)(v3.__cosval * 0.9278) + 0.0722) + (float)(v3.__sinval * 0.0722);
  __asm { FCVT            H1, S1 }
  v9.i32[1] = LOWORD(_S1);
  __asm { FCVT            H1, S6 }
  _S0 = v10 - (float)(v3.__sinval * 0.7873);
  v20.i16[3] = 0;
  v20.i16[0] = LOWORD(_S2);
  v20.i16[1] = LOWORD(_S1);
  __asm { FCVT            H0, S0 }
  v20.i16[2] = result;
  *this = v20;
  this[1] = v13;
  this[2] = *(float32x2_t *)v9.f32;
  return result;
}

__int16 RB::ColorMatrix::set_saturate@<H0>(float32x2_t *this@<X0>, float a2@<S0>, double a3@<D1>, double a4@<D2>, double a5@<D3>, double a6@<D4>, float32x4_t a7@<Q5>, float32x4_t a8@<Q6>)
{
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v12;
  __int16 result;

  v8.i16[3] = 0;
  this[4] = 0;
  if (a2 < 0.0)
    a2 = 0.0;
  v9 = vmul_n_f32((float32x2_t)0x3E59B3D03F498C7ELL, a2);
  a7.i32[0] = 1046066128;
  *(int32x2_t *)a8.f32 = vdup_n_s32(0x3E59B3D0u);
  a7.i32[0] = vadd_f32(v9, *(float32x2_t *)a7.f32).u32[0];
  a7.i32[1] = vsub_f32(*(float32x2_t *)&a8, v9).i32[1];
  v10 = vmul_n_f32((float32x2_t)0x3E91D14E3F371759, a2);
  a8.i32[0] = 1060575065;
  a8.i32[0] = vsub_f32(*(float32x2_t *)a8.f32, v10).u32[0];
  _S7 = 0.0722 - (float)(a2 * 0.0722);
  v12.i32[0] = vcvt_f16_f32(a7).u32[0];
  __asm { FCVT            H7, S7 }
  v12.i32[1] = v12.u16[1];
  a8.i32[1] = vadd_f32(v10, (float32x2_t)vdup_n_s32(0x3F371759u)).i32[1];
  v10.i32[0] = vcvt_f16_f32(a8).u32[0];
  v10.i32[1] = v10.u16[0];
  *this = v12;
  this[1] = v10;
  _S0 = (float)(a2 * 0.9278) + 0.0722;
  __asm { FCVT            H0, S0 }
  v8.i16[0] = LOWORD(_S7);
  v8.i16[1] = LOWORD(_S7);
  v8.i16[2] = result;
  this[2] = v8;
  this[3] = (float32x2_t)0x3C00000000000000;
  return result;
}

__n64 RB::ColorMatrix::set_brightness(__n64 *this, int16x4_t _D0)
{
  __n64 result;

  this->n64_u64[0] = 15360;
  this[1].n64_u64[0] = 1006632960;
  this[2].n64_u64[0] = 0x3C0000000000;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S0 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

__n64 RB::ColorMatrix::set_contrast(__n64 *this, float _S0)
{
  unint64_t v8;
  unsigned int v9;
  __n64 result;

  _S1 = 0.5 - (float)(_S0 * 0.5);
  __asm { FCVT            H0, S0 }
  v8 = 0;
  LOWORD(v9) = 0;
  HIWORD(v9) = _H0;
  this->n64_u64[0] = _H0;
  this[1].n64_u64[0] = v9;
  WORD2(v8) = _H0;
  _D0 = (int16x4_t)0x3C00000000000000;
  this[2].n64_u64[0] = v8;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S1 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

double RB::ColorMatrix::set_luminance_to_alpha(RB::ColorMatrix *this)
{
  double result;

  result = 0.0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *(_QWORD *)this = 0x32CE000000000000;
  *((_QWORD *)this + 1) = 0x39B9000000000000;
  *((_QWORD *)this + 2) = 0x2C9F000000000000;
  return result;
}

uint64_t RB::ColorMatrix::is_luminance_to_alpha(float16x4_t *this)
{
  uint16x4_t v1;

  v1 = (uint16x4_t)vmovn_s32((int32x4_t)vandq_s8(vandq_s8(vandq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(this[1]), (float32x4_t)xmmword_209BD9A70), (int8x16_t)vceqq_f32(vcvtq_f32_f16(*this), (float32x4_t)xmmword_209BD9A60)), vandq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(this[2]), (float32x4_t)xmmword_209BD9A80), (int8x16_t)vceqzq_f32(vcvtq_f32_f16(this[3])))), (int8x16_t)vceqzq_f32(vcvtq_f32_f16(this[4]))));
  v1.i16[0] = vminv_u16(v1);
  return ((unsigned __int32)v1.i32[0] >> 15) & 1;
}

__int16 RB::ColorMatrix::set_color_monochrome@<H0>(_QWORD *a1@<X0>, double a2@<D0>, int8x8_t _D1@<D1>, float a4@<S2>, double a5@<D3>, float32x4_t _Q4@<Q4>, double a7@<D5>, float32x4_t a8@<Q6>, float32x4_t a9@<Q7>)
{
  float32x2_t v9;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v26;
  __int16 result;

  __asm { FCVT            S4, H1 }
  _H3 = _D1.i16[3];
  __asm { FCVT            S3, H3 }
  _D1 = vmul_n_f32((float32x2_t)*(_OWORD *)&vcvtq_f32_f16((float16x4_t)vext_s8(_D1, *(int8x8_t *)&a2, 2uLL)), *(float *)&a2);
  *(int32x2_t *)a8.f32 = vdup_lane_s32((int32x2_t)_D1, 0);
  a8.i32[0] = _Q4.i32[0];
  v9.i32[0] = 1060575065;
  *(int32x2_t *)_Q4.f32 = vdup_lane_s32((int32x2_t)v9, 0);
  _Q4.i32[0] = LODWORD(a2);
  *(float32x2_t *)_Q4.f32 = vmul_f32(*(float32x2_t *)a8.f32, *(float32x2_t *)_Q4.f32);
  a9.i32[0] = vmul_f32(*(float32x2_t *)_Q4.f32, v9).u32[0];
  _S17 = vmuls_lane_f32(0.7152, _D1, 1);
  v9.f32[1] = 1.0 - *(float *)&a2;
  _S0 = (float)(1.0 - *(float *)&a2) + (float)(_S3 * *(float *)&a2);
  _S3 = vmlas_n_f32(v9.f32[1], 0.2126, _Q4.f32[0]);
  __asm { FCVT            H3, S3 }
  a9.i32[1] = vadd_f32(*(float32x2_t *)&_Q4, v9).i32[1];
  LODWORD(v20) = vcvt_f16_f32(a9).u32[0];
  *(int32x2_t *)_Q4.f32 = vzip1_s32(*(int32x2_t *)_Q4.f32, (int32x2_t)_D1);
  *(float32x2_t *)a8.f32 = vmul_f32(*(float32x2_t *)_Q4.f32, (float32x2_t)vdup_n_s32(0x3D93DD98u));
  LODWORD(v21) = vcvt_f16_f32(a8).u32[0];
  *(float32x2_t *)_Q4.f32 = vmul_n_f32(*(float32x2_t *)_Q4.f32, a4);
  LODWORD(v22) = vcvt_f16_f32(_Q4).u32[0];
  *(float32x2_t *)a9.f32 = vmul_f32(_D1, (float32x2_t)vdup_n_s32(0x3E59B3D0u));
  __asm { FCVT            H16, S17 }
  _S17 = 1033100696;
  __asm
  {
    FMLA            S18, S17, V1.S[1]
    FCVT            H17, S18
  }
  _D1.f32[0] = vmuls_lane_f32(a4, _D1, 1);
  __asm { FCVT            H1, S1 }
  v26 = 0;
  HIWORD(_D18) = 0;
  LOWORD(_D18) = LOWORD(_S3);
  *(_DWORD *)((char *)&_D18 + 2) = vcvt_f16_f32(a9).u32[0];
  HIDWORD(v20) = _H16;
  *a1 = _D18;
  a1[1] = v20;
  HIDWORD(v21) = (unsigned __int16)_S17;
  __asm { FCVT            H0, S0 }
  HIWORD(v26) = result;
  a1[2] = v21;
  a1[3] = v26;
  HIDWORD(v22) = _D1.u16[0];
  a1[4] = v22;
  return result;
}

__n64 RB::ColorMatrix::set_color_invert(__n64 *this, double _D0)
{
  unint64_t v7;
  unsigned int v8;
  __n64 result;

  _S1 = (float)(*(float *)&_D0 * -2.0) + 1.0;
  __asm { FCVT            H1, S1 }
  v7 = 0;
  LOWORD(v8) = 0;
  HIWORD(v8) = LOWORD(_S1);
  this->n64_u64[0] = LOWORD(_S1);
  this[1].n64_u64[0] = v8;
  WORD2(v7) = LOWORD(_S1);
  this[2].n64_u64[0] = v7;
  this[3].n64_u64[0] = 0x3C00000000000000;
  __asm { FCVT            H0, S0 }
  result.n64_u64[0] = (unint64_t)vdup_lane_s16(*(int16x4_t *)&_D0, 0);
  result.n64_u16[3] = 0;
  this[4].n64_u64[0] = result.n64_u64[0];
  return result;
}

float16x4_t RB::ColorMatrix::multiply_color(float16x4_t *this, float a2, float a3, float a4, float32_t a5, int a6)
{
  float v6;
  float32x4_t v7;
  float32x4_t v8;
  float16x4_t v9;
  float16x4_t v10;
  float16x4_t result;

  v6 = 1.0;
  if (a6)
    v6 = a5;
  v7.f32[0] = v6 * a2;
  v7.f32[1] = v6 * a3;
  v7.f32[2] = v6 * a4;
  v7.f32[3] = a5;
  v8 = vcvtq_f32_f16(vcvt_f16_f32(v7));
  v9 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(this[1]), v8));
  *this = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(*this), v8));
  this[1] = v9;
  v10 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(this[3]), v8));
  this[2] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(this[2]), v8));
  this[3] = v10;
  result = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(this[4]), v8));
  this[4] = result;
  return result;
}

float RB::ColorMatrix::remove_alpha_factor(float16x4_t *this, char a2)
{
  _BOOL4 is_alpha_multiply;
  float result;

  if ((RB::ColorMatrix::is_diagonal(this) & 1) != 0
    || (is_alpha_multiply = RB::ColorMatrix::is_alpha_multiply(this, a2), result = 1.0, is_alpha_multiply))
  {
    _H0 = this[3].i16[3];
    this[3].i16[3] = 15360;
    __asm { FCVT            S0, H0 }
  }
  return result;
}

float16x4_t RB::operator*@<D0>(float16x4_t *a1@<X0>, int16x4_t *a2@<X1>, float16x4_t *a3@<X8>)
{
  int16x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  int16x4_t v8;
  int16x4_t v9;
  int16x4_t v10;
  float16x4_t result;

  v3 = a2[1];
  v4 = vcvtq_f32_f16(*a1);
  v5 = vcvtq_f32_f16(a1[1]);
  v6 = vcvtq_f32_f16(a1[2]);
  v7 = vcvtq_f32_f16(a1[3]);
  *a3 = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*a2, 0)), v4))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(v5, vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*a2, 1)))))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(v6, vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*a2, 2)))))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(v7, vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*a2, 3)))))));
  a3[1] = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v3, 0)), v4))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v3, 1)), v5)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v3, 2)), v6)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v3, 3)), v7)))));
  v8 = a2[2];
  v9 = a2[3];
  a3[2] = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v8, 0)), v4))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v8, 1)), v5)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v8, 2)), v6)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v8, 3)), v7)))));
  a3[3] = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v9, 0)), v4))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v9, 1)), v5)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v9, 2)), v6)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v9, 3)), v7)))));
  v10 = a2[4];
  result = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v10, 0)), v4))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v10, 1)), v5)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v10, 2)), v6)))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v10, 3)), v7)))))), vcvtq_f32_f16(a1[4])));
  a3[4] = result;
  return result;
}

float16x4_t RB::operator*=(uint64_t a1, float16x4_t *a2)
{
  int16x4_t v2;
  float16x4_t result;

  v2 = *(int16x4_t *)(a1 + 2);
  result = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v2, 0)), vcvtq_f32_f16(a2[1])))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)a1, 0)), vcvtq_f32_f16(*a2))))))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(a2[2]), vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v2, 1)))))))), vcvtq_f32_f16(a2[4])))), vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(a2[3]), vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v2, 2)))))));
  *(_QWORD *)a1 = ((unint64_t)result.u16[2] << 32) | ((unint64_t)result.u16[3] << 48) | ((unint64_t)result.u16[1] << 16) | result.u16[0];
  *(_WORD *)(a1 + 8) = v2.i16[3];
  return result;
}

_QWORD *RB::ColorMatrix::encode(_QWORD *this, RB::ProtobufEncoder *a2)
{
  _QWORD *v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD v14[5];

  v3 = this;
  v4 = 0;
  v14[0] = 15360;
  v14[1] = 1006632960;
  v14[2] = 0x3C0000000000;
  v14[3] = 0x3C00000000000000;
  v14[4] = 0;
  v5 = 13;
  do
  {
    _H0 = *(_WORD *)((char *)v3 + v4);
    _H1 = *(_WORD *)((char *)v14 + v4);
    __asm
    {
      FCVT            S1, H1
      FCVT            S8, H0
    }
    if (*(float *)&_S8 != _S1)
    {
      RB::ProtobufEncoder::encode_varint(a2, v5);
      this = RB::ProtobufEncoder::encode_fixed32(a2, _S8);
    }
    v4 += 2;
    v5 += 8;
  }
  while (v4 != 40);
  return this;
}

unint64_t RB::ColorMatrix::decode(RB::ColorMatrix *this, RB::ProtobufDecoder *a2)
{
  unint64_t result;
  unint64_t v5;
  unint64_t v6;

  *(_QWORD *)this = 15360;
  *((_QWORD *)this + 1) = 1006632960;
  *((_QWORD *)this + 2) = 0x3C0000000000;
  *((_QWORD *)this + 3) = 0x3C00000000000000;
  *((_QWORD *)this + 4) = 0;
  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      v6 = v5 >> 3;
      if ((v5 >> 3) - 1 > 0x13)
      {
        RB::ProtobufDecoder::skip_field(a2, v5);
      }
      else
      {
        _S0 = RB::ProtobufDecoder::float_field(a2, v5);
        __asm { FCVT            H0, S0 }
        *((_WORD *)this + (v6 - 1)) = LOWORD(_S0);
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::ColorMatrix::print(float16x4_t *this, std::string *a2)
{
  const char *v13;

  if (RB::ColorMatrix::is_diagonal(this))
  {
    RB::SexpString::push(a2, "color-multiply");
    _D0 = *this;
    __asm { FCVT            D0, H0 }
    _H1 = this[1].i16[1];
    __asm { FCVT            D1, H1 }
    _H2 = this[2].i16[2];
  }
  else
  {
    if (RB::ColorMatrix::is_alpha_multiply(this, 0))
    {
      v13 = "alpha-multiply";
    }
    else
    {
      if (!RB::ColorMatrix::is_alpha_multiply(this, 1))
      {
        RB::SexpString::push(a2, "color-matrix");
        _D0 = *this;
        _D1 = this[1];
        __asm
        {
          FCVT            D0, H0
          FCVT            D1, H1
        }
        _D2 = this[2];
        _D3 = this[3];
        __asm
        {
          FCVT            D2, H2
          FCVT            D3, H3
        }
        _D4 = this[4];
        __asm { FCVT            D4, H4 }
        RB::SexpString::printf(a2, 1, "(row0 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
        _H0 = this->i16[1];
        __asm { FCVT            D0, H0 }
        _H1 = this[1].i16[1];
        __asm { FCVT            D1, H1 }
        _H2 = this[2].i16[1];
        __asm { FCVT            D2, H2 }
        _H3 = this[3].i16[1];
        __asm { FCVT            D3, H3 }
        _H4 = this[4].i16[1];
        __asm { FCVT            D4, H4 }
        RB::SexpString::printf(a2, 1, "(row1 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
        _H0 = this->i16[2];
        __asm { FCVT            D0, H0 }
        _H1 = this[1].i16[2];
        __asm { FCVT            D1, H1 }
        _H2 = this[2].i16[2];
        __asm { FCVT            D2, H2 }
        _H3 = this[3].i16[2];
        __asm { FCVT            D3, H3 }
        _H4 = this[4].i16[2];
        __asm { FCVT            D4, H4 }
        RB::SexpString::printf(a2, 1, "(row2 %g %g %g %g; %g)", _D0, _D1, _D2, _D3, _D4);
        _H0 = this->i16[3];
        __asm { FCVT            D0, H0 }
        _H1 = this[1].i16[3];
        __asm { FCVT            D1, H1 }
        _H2 = this[2].i16[3];
        __asm { FCVT            D2, H2 }
        _H3 = this[3].i16[3];
        __asm { FCVT            D3, H3 }
        _H4 = this[4].i16[3];
        __asm { FCVT            D4, H4 }
        RB::SexpString::printf(a2, 1, "(row3 %g %g %g %g; %g)");
        goto LABEL_9;
      }
      v13 = "alpha-multiply*";
    }
    RB::SexpString::push(a2, v13);
    _H0 = this[4].i16[0];
    __asm { FCVT            D0, H0 }
    _H1 = this[4].i16[1];
    __asm { FCVT            D1, H1 }
    _H2 = this[4].i16[2];
  }
  __asm { FCVT            D2, H2 }
  _H3 = this[3].i16[3];
  __asm { FCVT            D3, H3 }
  RB::SexpString::printf(a2, 0, "[%g %g %g %g]");
LABEL_9:
  RB::SexpString::pop(a2);
}

uint64_t RB::Stroke::flatten_points(void *a1, uint64_t (**a2)(_QWORD), char a3, char a4, float64x2_t a5, double a6, float32x2_t a7, float a8, float a9, float a10)
{
  float v10;
  uint32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float v14;
  float v15;
  uint64_t (**v17[4])(_QWORD);
  char v18;
  char v19;
  float v20;
  float v21;
  float v22;
  BOOL v23;
  int v24;
  uint64_t v25;
  char v26;
  int v27;
  uint64_t v28;
  uint64_t v29;

  v17[0] = (uint64_t (**)(_QWORD))off_24C2297F0;
  v17[1] = a2;
  v17[2] = *(uint64_t (***)(_QWORD))&a6;
  v17[3] = (uint64_t (**)(_QWORD))vadd_f32(a7, *(float32x2_t *)&a6);
  v18 = a3;
  v19 = a4;
  v10 = a8 * a8;
  v11 = (uint32x2_t)vcge_f32(vabs_f32(a7), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  v23 = vpmax_u32(v11, v11).i32[0] >= 0;
  v24 = 0;
  v25 = 0x3F80000000000000;
  v26 = 1;
  v27 = 0;
  v28 = 0x3F80000000000000;
  v29 = 0x3F80000000000000;
  v22 = a9;
  v12 = vrecpe_f32((float32x2_t)LODWORD(a9));
  v13 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a9), v12), v12);
  LODWORD(v14) = vmul_f32(v13, vrecps_f32((float32x2_t)LODWORD(a9), v13)).u32[0];
  v15 = 0.75;
  if ((float)(a10 * 0.05) > 1.0)
    v15 = a10 * 0.0375;
  v20 = v10;
  v21 = v15 * v14;
  return RB::Stroke::stroke_points(a1, v17, a5);
}

uint64_t RB::Stroke::flatten_particles(void *a1, uint64_t (**a2)(_QWORD), float64x2_t a3, double a4, float32x2_t a5, float a6, float a7)
{
  uint32x2_t v7;
  signed __int32 v8;
  float32x2_t v14;
  float32x2_t v15;
  float v16;
  float v17;
  uint64_t (**v19[4])(_QWORD);
  __int16 v20;
  int v21;
  float v22;
  float v23;
  BOOL v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  char v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;

  v19[2] = *(uint64_t (***)(_QWORD))&a4;
  v19[3] = (uint64_t (**)(_QWORD))vadd_f32(a5, *(float32x2_t *)&a4);
  v7 = (uint32x2_t)vcge_f32(vabs_f32(a5), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  v8 = vpmax_u32(v7, v7).u32[0];
  __asm { FMOV            V1.2S, #1.0 }
  v26 = _D1;
  v27 = 1065353216;
  v30 = 1065353216;
  v33 = _D1;
  v34 = 1065353216;
  v37 = 1065353216;
  v38 = _D1;
  v39 = 1065353216;
  v42 = 1065353216;
  v14 = vrecpe_f32((float32x2_t)LODWORD(a6));
  v15 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a6), v14), v14);
  v19[0] = (uint64_t (**)(_QWORD))off_24C229830;
  v19[1] = a2;
  v20 = 256;
  v21 = 1120403456;
  v24 = v8 >= 0;
  v25 = 0;
  v28 = 0;
  v29 = 0;
  v31 = 1;
  v32 = 0;
  v35 = 0;
  v36 = 0;
  v40 = 0;
  v41 = 0;
  LODWORD(v16) = vmul_f32(v15, vrecps_f32((float32x2_t)LODWORD(a6), v15)).u32[0];
  v17 = a7 * 0.0375;
  if ((float)(a7 * 0.05) <= 1.0)
    v17 = 0.75;
  v22 = v17 * v16;
  v23 = a6;
  return RB::Stroke::stroke_particles(a1, v19, a3);
}

void RB::Stroke::LineBounds::quadto(float32x2_t *a1, float32x2_t a2, float32x2_t a3, float a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  float32x2_t v11;
  float32x2_t v12;

  *(float32x2_t *)a6.i8 = vadd_f32(a2, a2);
  v11 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  v12 = vmul_f32(vadd_f32(a1[3], *(float32x2_t *)a6.i8), v11);
  *(float32x2_t *)a6.i8 = vadd_f32(*(float32x2_t *)a6.i8, a3);
  RB::Stroke::LineBounds::cubeto((uint64_t)a1, v12, vmul_f32(*(float32x2_t *)a6.i8, v11), a3, a4, a6, a7, a8, a9);
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::closepath(uint64_t a1)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::closepath(a1 + 8);
}

double RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3)
{
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  double result;

  v3 = vcvt_f32_f64(a2);
  v4 = vcvt_f32_f64(a3);
  v5 = vadd_f32(v3, v3);
  v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Point>::cubeto((uint64_t)&a1[1], a1 + 17, vmul_f32(vadd_f32(a1[15], v5), v6), vmul_f32(vadd_f32(v5, v4), v6), *(double *)&v4);
  return result;
}

void RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::cubeto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  RB::Stroke::Flattener<RB::Stroke::Point>::cubeto((uint64_t)&a1[1], a1 + 17, vcvt_f32_f64(a2), vcvt_f32_f64(a3), COERCE_DOUBLE(vcvt_f32_f64(a4)));
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::closepath(uint64_t a1)
{
  RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1, (_QWORD *)(a1 + 104), *(double *)(a1 + 88));
  RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0, *(float32x2_t *)(a1 + 96));
  return (***(uint64_t (****)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 8));
}

void RB::Stroke::Flattener<RB::Stroke::Point>::quadto(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, double a4)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = vadd_f32(a3, a3);
  v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Point>::cubeto((uint64_t)a1, a2, vmul_f32(vadd_f32(a1[14], v5), v6), vmul_f32(vadd_f32(v5, *(float32x2_t *)&a4), v6), a4);
}

void RB::Stroke::Flattener<RB::Stroke::Point>::cubeto(uint64_t a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, double a5)
{
  float32x2_t v10;
  float32x2_t v11;
  uint32x2_t v12;
  uint32x2_t v13;
  uint32x2_t v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  int32x4_t v22;
  int32x4_t v23;
  int32x4_t v24;
  int v25;
  double v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  uint32x2_t v32;
  uint32x2_t v33;
  uint32x2_t v34;
  uint32x2_t v35;
  int v36;
  uint32x2_t v37;
  int v38;
  int v39;
  float32x2_t v40;
  float v41;
  uint32x2_t v44;
  uint64_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;
  int v49;
  float32x2_t v50;
  uint32x2_t v51;
  uint32x2_t v52;
  __int32 v53;
  float v54;
  uint32x2_t v55;
  uint32x2_t v56;
  char v57;
  float32x2_t v58;
  float32x2_t v59;
  float32x2_t v60;
  float32x2_t v61;
  double v62;
  unint64_t v63;
  char v64;

  v10 = *(float32x2_t *)(a1 + 112);
  v11 = *(float32x2_t *)(a1 + 120);
  v12 = (uint32x2_t)vceq_f32(v10, a3);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) != 0)
  {
    v13 = (uint32x2_t)vceq_f32(a3, a4);
    if ((vpmin_u32(v13, v13).u32[0] & 0x80000000) != 0)
    {
      v14 = (uint32x2_t)vceq_f32(a4, *(float32x2_t *)&a5);
      if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0)
      {
        RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1, a2, a5);
        return;
      }
    }
  }
  v15 = COERCE_DOUBLE(vsub_f32(a3, v10));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15)) < 0.00001)
  {
    v16 = COERCE_DOUBLE(vsub_f32(a4, v10));
    v17 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v10));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v16, *(float32x2_t *)&v16)) < 0.00001)
      v15 = v17;
    else
      v15 = v16;
  }
  v18 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a4));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v18, *(float32x2_t *)&v18)) < 0.00001)
  {
    v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a3));
    v20 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v10));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001)
      v18 = v20;
    else
      v18 = v19;
  }
  *(double *)(a1 + 112) = a5;
  *(float32x2_t *)(a1 + 120) = *a2;
  *(_BYTE *)(a1 + 50) = 0;
  RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 0, *(float32x2_t *)&v15);
  v25 = *(unsigned __int8 *)(a1 + 48);
  if (*(_BYTE *)(a1 + 48))
  {
    v26 = COERCE_DOUBLE(vminnm_f32(v10, *(float32x2_t *)&a5));
    v27 = vmaxnm_f32(v10, *(float32x2_t *)&a5);
    v28 = vminnm_f32(a3, a4);
    v29 = vmaxnm_f32(a3, a4);
    v31 = *(float32x2_t *)(a1 + 16);
    v30 = *(float32x2_t *)(a1 + 24);
    *(int32x2_t *)v24.i8 = vcgt_f32(v31, vmaxnm_f32(v27, v29));
    v32 = (uint32x2_t)vorr_s8(*(int8x8_t *)v24.i8, (int8x8_t)vcgt_f32(vminnm_f32(*(float32x2_t *)&v26, v28), v30));
    *(uint32x2_t *)v23.i8 = vpmax_u32(v32, v32);
    if (v23.i32[0] < 0)
      goto LABEL_23;
    *(int32x2_t *)v22.i8 = vcge_f32(v27, v29);
    v33 = (uint32x2_t)vand_s8(*(int8x8_t *)v22.i8, (int8x8_t)vcge_f32(v28, *(float32x2_t *)&v26));
    *(uint32x2_t *)v21.i8 = vpmin_u32(v33, v33);
    if ((v21.i32[0] & 0x80000000) == 0)
    {
      v26 = RB::Path::cubic_bounds_slow(v10, a3, a4, *(float32x2_t *)&a5, v21, v22, v23, v24);
      v31 = *(float32x2_t *)(a1 + 16);
      v30 = *(float32x2_t *)(a1 + 24);
    }
    v34 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v31, v27), (int8x8_t)vcgt_f32(*(float32x2_t *)&v26, v30));
    if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) != 0)
    {
LABEL_23:
      *(_BYTE *)(a1 + 72) = 0;
      (*(void (**)(_QWORD, float32x2_t *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), a2, a5);
      return;
    }
    v35 = (uint32x2_t)vcge_f32(*(float32x2_t *)&v26, v31);
    v36 = vpmin_u32(v35, v35).u32[0];
    v37 = (uint32x2_t)vcge_f32(v30, v27);
    if (vpmin_u32(v37, v37).i32[0] >= 0)
      v38 = v25;
    else
      v38 = 0;
    if (v36 < 0)
      v39 = v38;
    else
      v39 = 1;
  }
  else
  {
    v39 = 0;
  }
  v40 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(a4, vadd_f32(a3, a3)), v10)), vabs_f32(vadd_f32(vsub_f32(a3, vadd_f32(a4, a4)), *(float32x2_t *)&a5)));
  v41 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v40, v40))) * *(float *)(a1 + 40)));
  if (v41 >= 0.0 && ((LODWORD(v41) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v41) == 0)
  {
    if (v41 >= 1.0)
    {
      if (v41 > 1024.0)
        v41 = 1024.0;
      v45 = (int)v41;
      v63 = 0x3F80000000000000;
      v64 = 0;
      if ((int)v45 >= 2)
      {
        _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v58, v45);
        v46 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v45));
        v47 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v45), v46), v46);
        v48 = vmul_n_f32(vsub_f32(*a2, v11), vmul_f32(v47, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v45), v47)).f32[0]);
        v49 = v45 - 1;
        do
        {
          v50 = v58;
          v10 = vadd_f32(v59, v58);
          v58 = v10;
          v59 = vadd_f32(v60, v59);
          v60 = vadd_f32(v61, v60);
          v11 = vadd_f32(v11, v48);
          if (v39
            && ((v51 = (uint32x2_t)vcgt_f32(vminnm_f32(v50, v10), *(float32x2_t *)(a1 + 24)),
                 (vpmax_u32(v51, v51).u32[0] & 0x80000000) != 0)
             || (v52 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v50, v10)),
                 (vpmax_u32(v52, v52).u32[0] & 0x80000000) != 0)))
          {
            v64 = 1;
            v62 = *(double *)&v10;
            v63 = (unint64_t)v11;
            *(_BYTE *)(a1 + 72) = 0;
          }
          else
          {
            if (*(_BYTE *)(a1 + 49))
            {
              (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
              *(_BYTE *)(a1 + 49) = 0;
              *(_BYTE *)(a1 + 52) = 1;
            }
            if (v64)
            {
              *(_BYTE *)(a1 + 72) = 0;
              (*(void (**)(_QWORD, unint64_t *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v63, v62);
              v64 = 0;
            }
            if (*(_BYTE *)(a1 + 72) && !*(_DWORD *)(a1 + 76))
            {
              *(double *)(a1 + 96) = v15;
              (*(void (**)(_QWORD, _QWORD, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0, v15);
              *(_BYTE *)(a1 + 72) = 0;
            }
            *(_BYTE *)(a1 + 51) = 0;
            *(_BYTE *)(a1 + 49) = 1;
            *(_BYTE *)(a1 + 53) = 1;
            *(float32x2_t *)(a1 + 56) = v10;
            *(float32x2_t *)(a1 + 64) = v11;
          }
          --v49;
        }
        while (v49);
      }
    }
    else
    {
      v44 = (uint32x2_t)vceq_f32(v10, *(float32x2_t *)&a5);
      if ((vpmin_u32(v44, v44).u32[0] & 0x80000000) != 0)
        return;
      v63 = 0x3F80000000000000;
      v64 = 0;
    }
    v54 = a2->f32[0];
    v53 = a2->i32[1];
    if (v39
      && ((v55 = (uint32x2_t)vcgt_f32(vminnm_f32(v10, *(float32x2_t *)&a5), *(float32x2_t *)(a1 + 24)),
           (vpmax_u32(v55, v55).u32[0] & 0x80000000) != 0)
       || (v56 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v10, *(float32x2_t *)&a5)),
           (vpmax_u32(v56, v56).u32[0] & 0x80000000) != 0)))
    {
      v64 = 1;
      v62 = a5;
      v63 = __PAIR64__(v53, LODWORD(v54));
      *(_BYTE *)(a1 + 72) = 0;
    }
    else
    {
      if (*(_BYTE *)(a1 + 49))
      {
        (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
        *(_BYTE *)(a1 + 49) = 0;
        *(_BYTE *)(a1 + 52) = 1;
      }
      if (v64)
      {
        *(_BYTE *)(a1 + 72) = 0;
        (*(void (**)(_QWORD, unint64_t *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v63, v62);
        v64 = 0;
      }
      if (*(_BYTE *)(a1 + 72) && !*(_DWORD *)(a1 + 76))
      {
        *(double *)(a1 + 96) = v15;
        (*(void (**)(_QWORD, _QWORD, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0, v15);
        *(_BYTE *)(a1 + 72) = 0;
      }
      v57 = 1;
      if (v54 > *(float *)(a1 + 44))
        v57 = *(_BYTE *)(a1 + 33);
      *(_BYTE *)(a1 + 51) = 0;
      *(_BYTE *)(a1 + 49) = 1;
      *(_BYTE *)(a1 + 53) = v57;
      *(double *)(a1 + 56) = a5;
      *(float *)(a1 + 64) = v54;
      *(_DWORD *)(a1 + 68) = v53;
      if (!v64)
      {
        *(_BYTE *)(a1 + 72) = 1;
        *(_DWORD *)(a1 + 76) = 1;
        *(double *)(a1 + 80) = v18;
        return;
      }
    }
    if (*(_BYTE *)(a1 + 49))
    {
      (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
      *(_BYTE *)(a1 + 49) = 0;
      *(_BYTE *)(a1 + 52) = 1;
    }
    (*(void (**)(_QWORD, unint64_t *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v63, v62);
  }
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::endpath(uint64_t a1)
{
  uint64_t result;

  result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 1);
  if (*(_BYTE *)(a1 + 104))
  {
    if (*(_DWORD *)(a1 + 108) == 1)
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, *(double *)(a1 + 112));
      *(_BYTE *)(a1 + 104) = 0;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::closepath(uint64_t a1)
{
  RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(a1, (__int128 *)(a1 + 136), *(double *)(a1 + 120));
  RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0, *(float32x2_t *)(a1 + 128));
  return (***(uint64_t (****)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 8));
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::moveto(uint64_t a1, __int128 *a2, double a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 1);
  if (*(_BYTE *)(a1 + 104) && *(_DWORD *)(a1 + 108) == 1)
    (*(void (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, *(double *)(a1 + 112));
  *(double *)(a1 + 120) = a3;
  v6 = *a2;
  v7 = a2[1];
  *(_QWORD *)(a1 + 168) = *((_QWORD *)a2 + 4);
  *(_OWORD *)(a1 + 152) = v7;
  *(_OWORD *)(a1 + 136) = v6;
  *(_QWORD *)(a1 + 128) = 0;
  *(double *)(a1 + 176) = a3;
  v8 = *a2;
  v9 = a2[1];
  *(_QWORD *)(a1 + 216) = *((_QWORD *)a2 + 4);
  *(_OWORD *)(a1 + 200) = v9;
  *(_OWORD *)(a1 + 184) = v8;
  *(_WORD *)(a1 + 50) = 1;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 104) = 1;
  *(_DWORD *)(a1 + 108) = 0;
  return (*(uint64_t (**)(_QWORD, __int128 *, double))(**(_QWORD **)(a1 + 8) + 8))(*(_QWORD *)(a1 + 8), a2, a3);
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(uint64_t result, __int128 *a2, double a3)
{
  uint64_t v4;
  float32x2_t v5;
  uint32x2_t v6;
  __int128 v8;
  __int128 v9;
  float32x2_t v10;
  uint32x2_t v11;
  uint32x2_t v12;
  char v13;
  __int128 v14;
  __int128 v15;

  v4 = result;
  v5 = *(float32x2_t *)(result + 176);
  v6 = (uint32x2_t)vceq_f32(v5, *(float32x2_t *)&a3);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    if (*(_BYTE *)(result + 50) && !*(_BYTE *)(result + 32))
      *(_BYTE *)(result + 51) = 1;
  }
  else
  {
    *(double *)(result + 176) = a3;
    v8 = *a2;
    v9 = a2[1];
    *(_QWORD *)(result + 216) = *((_QWORD *)a2 + 4);
    *(_OWORD *)(result + 200) = v9;
    *(_OWORD *)(result + 184) = v8;
    *(_BYTE *)(result + 50) = 0;
    v10 = vsub_f32(*(float32x2_t *)&a3, v5);
    result = RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(result, 0, v10);
    if (*(_BYTE *)(v4 + 48)
      && ((v11 = (uint32x2_t)vcgt_f32(vminnm_f32(v5, *(float32x2_t *)&a3), *(float32x2_t *)(v4 + 24)),
           (vpmax_u32(v11, v11).u32[0] & 0x80000000) != 0)
       || (v12 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v4 + 16), vmaxnm_f32(v5, *(float32x2_t *)&a3)),
           (vpmax_u32(v12, v12).u32[0] & 0x80000000) != 0)))
    {
      *(_BYTE *)(v4 + 104) = 0;
      return (*(uint64_t (**)(_QWORD, __int128 *, double))(**(_QWORD **)(v4 + 8) + 24))(*(_QWORD *)(v4 + 8), a2, a3);
    }
    else
    {
      if (*(_BYTE *)(v4 + 104))
      {
        if (!*(_DWORD *)(v4 + 108))
        {
          *(float32x2_t *)(v4 + 128) = v10;
          result = (*(uint64_t (**)(_QWORD, _QWORD, double))(**(_QWORD **)(v4 + 8) + 32))(*(_QWORD *)(v4 + 8), 0, *(double *)&v10);
          *(_BYTE *)(v4 + 104) = 0;
        }
      }
      v13 = *(_BYTE *)(v4 + 33);
      *(_BYTE *)(v4 + 51) = 0;
      *(_BYTE *)(v4 + 49) = 1;
      *(_BYTE *)(v4 + 53) = v13;
      *(double *)(v4 + 56) = a3;
      v15 = *a2;
      v14 = a2[1];
      *(_QWORD *)(v4 + 96) = *((_QWORD *)a2 + 4);
      *(_OWORD *)(v4 + 64) = v15;
      *(_OWORD *)(v4 + 80) = v14;
      *(_BYTE *)(v4 + 104) = 1;
      *(_DWORD *)(v4 + 108) = 1;
      *(float32x2_t *)(v4 + 112) = v10;
    }
  }
  return result;
}

void RB::Stroke::Flattener<RB::Stroke::Particle>::quadto(float32x2_t *a1, uint64_t a2, float32x2_t a3, double a4)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = vadd_f32(a3, a3);
  v6 = (float32x2_t)vdup_n_s32(0x3EAAAAABu);
  RB::Stroke::Flattener<RB::Stroke::Particle>::cubeto((uint64_t)a1, a2, vmul_f32(vadd_f32(a1[22], v5), v6), vmul_f32(vadd_f32(v5, *(float32x2_t *)&a4), v6), a4);
}

void RB::Stroke::Flattener<RB::Stroke::Particle>::cubeto(uint64_t a1, uint64_t a2, float32x2_t a3, float32x2_t a4, double a5)
{
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  uint32x2_t v14;
  uint32x2_t v15;
  uint32x2_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  __int128 v21;
  __int128 v22;
  double v23;
  int32x4_t v24;
  int32x4_t v25;
  int32x4_t v26;
  int32x4_t v27;
  int v28;
  double v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  uint32x2_t v36;
  uint32x2_t v37;
  uint32x2_t v38;
  uint32x2_t v39;
  int v40;
  uint32x2_t v41;
  int v42;
  int v43;
  float32x2_t v44;
  float v45;
  uint32x2_t v48;
  uint64_t v49;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  int v58;
  float32x2_t v59;
  uint32x2_t v60;
  uint32x2_t v61;
  uint32x2_t v62;
  uint32x2_t v63;
  BOOL v64;
  __int128 v65;
  char v66;
  double v67;
  double v68;
  double v69;
  float32x2_t v70;
  float32x2_t v71;
  float32x2_t v73;
  __int128 v74;
  __int128 v75;
  uint64_t v76;
  float32x2_t v77;
  float32x2_t v78;
  float32x2_t v79;
  float32x2_t v80;
  double v81;
  __int128 v82;
  __int128 v83;
  uint64_t v84;
  char v85;

  v8 = *(float32x2_t *)(a1 + 184);
  v9 = *(float32x2_t *)(a1 + 176);
  v11 = *(float32x2_t *)(a1 + 192);
  v10 = *(float32x2_t *)(a1 + 200);
  v13 = *(float32x2_t *)(a1 + 208);
  v12 = *(float32x2_t *)(a1 + 216);
  v14 = (uint32x2_t)vceq_f32(v9, a3);
  if ((vpmin_u32(v14, v14).u32[0] & 0x80000000) != 0)
  {
    v15 = (uint32x2_t)vceq_f32(a3, a4);
    if ((vpmin_u32(v15, v15).u32[0] & 0x80000000) != 0)
    {
      v16 = (uint32x2_t)vceq_f32(a4, *(float32x2_t *)&a5);
      if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)
      {
        RB::Stroke::Flattener<RB::Stroke::Particle>::lineto(a1, (__int128 *)a2, a5);
        return;
      }
    }
  }
  v17 = COERCE_DOUBLE(vsub_f32(a3, v9));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) < 0.00001)
  {
    v17 = COERCE_DOUBLE(vsub_f32(a4, v9));
    v18 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v9));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) < 0.00001)
      v17 = v18;
  }
  v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a4));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001)
  {
    v20 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, a3));
    v19 = COERCE_DOUBLE(vsub_f32(*(float32x2_t *)&a5, v9));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v20, *(float32x2_t *)&v20)) >= 0.00001)
      v19 = v20;
  }
  v68 = v19;
  v69 = v17;
  *(double *)(a1 + 176) = a5;
  v22 = *(_OWORD *)a2;
  v21 = *(_OWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 216) = *(_QWORD *)(a2 + 32);
  *(_OWORD *)(a1 + 184) = v22;
  *(_OWORD *)(a1 + 200) = v21;
  *(_BYTE *)(a1 + 50) = 0;
  v23 = a5;
  RB::Stroke::Flattener<RB::Stroke::Particle>::flush_lineto(a1, 0, *(float32x2_t *)&v17);
  v28 = *(unsigned __int8 *)(a1 + 48);
  if (*(_BYTE *)(a1 + 48))
  {
    v29 = COERCE_DOUBLE(vminnm_f32(v9, *(float32x2_t *)&v23));
    v30 = vmaxnm_f32(v9, *(float32x2_t *)&v23);
    v31 = a4;
    v32 = vminnm_f32(a3, a4);
    v33 = vmaxnm_f32(a3, a4);
    v34 = *(float32x2_t *)(a1 + 16);
    v35 = *(float32x2_t *)(a1 + 24);
    *(int32x2_t *)v27.i8 = vcgt_f32(v34, vmaxnm_f32(v30, v33));
    v36 = (uint32x2_t)vorr_s8(*(int8x8_t *)v27.i8, (int8x8_t)vcgt_f32(vminnm_f32(*(float32x2_t *)&v29, v32), v35));
    *(uint32x2_t *)v26.i8 = vpmax_u32(v36, v36);
    if (v26.i32[0] < 0)
      goto LABEL_21;
    *(int32x2_t *)v25.i8 = vcge_f32(v30, v33);
    v37 = (uint32x2_t)vand_s8(*(int8x8_t *)v25.i8, (int8x8_t)vcge_f32(v32, *(float32x2_t *)&v29));
    *(uint32x2_t *)v24.i8 = vpmin_u32(v37, v37);
    if ((v24.i32[0] & 0x80000000) == 0)
    {
      v29 = RB::Path::cubic_bounds_slow(v9, a3, a4, *(float32x2_t *)&v23, v24, v25, v26, v27);
      v31 = a4;
      v34 = *(float32x2_t *)(a1 + 16);
      v35 = *(float32x2_t *)(a1 + 24);
    }
    v38 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v34, v30), (int8x8_t)vcgt_f32(*(float32x2_t *)&v29, v35));
    if ((vpmax_u32(v38, v38).u32[0] & 0x80000000) != 0)
    {
LABEL_21:
      *(_BYTE *)(a1 + 104) = 0;
      (*(void (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), a2, v23);
      return;
    }
    v39 = (uint32x2_t)vcge_f32(*(float32x2_t *)&v29, v34);
    v40 = vpmin_u32(v39, v39).u32[0];
    v41 = (uint32x2_t)vcge_f32(v35, v30);
    if (vpmin_u32(v41, v41).i32[0] >= 0)
      v42 = v28;
    else
      v42 = 0;
    if (v40 < 0)
      v43 = v42;
    else
      v43 = 1;
  }
  else
  {
    v43 = 0;
    v31 = a4;
  }
  v44 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v31, vadd_f32(a3, a3)), v9)), vabs_f32(vadd_f32(vsub_f32(a3, vadd_f32(v31, v31)), *(float32x2_t *)&v23)));
  v45 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v44, v44))) * *(float *)(a1 + 40)));
  if (v45 >= 0.0 && ((LODWORD(v45) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v45) == 0)
  {
    if (v45 >= 1.0)
    {
      if (v45 > 1024.0)
        v45 = 1024.0;
      v49 = (int)v45;
    }
    else
    {
      v48 = (uint32x2_t)vceq_f32(v9, *(float32x2_t *)&v23);
      if ((vpmin_u32(v48, v48).u32[0] & 0x80000000) != 0)
        return;
      v49 = 1;
    }
    __asm { FMOV            V1.2S, #1.0 }
    *(_QWORD *)&v82 = _D1;
    *((_QWORD *)&v82 + 1) = 1065353216;
    v83 = 0uLL;
    v84 = 1065353216;
    v85 = 0;
    if ((int)v49 >= 2)
    {
      v67 = v23;
      _ZN2RB13CubicIteratorIDv2_fEC1ES1_S1_S1_S1_i(&v77, v49);
      v54 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v49));
      v55 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v49), v54), v54);
      v55.i32[0] = vmul_f32(v55, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)v49), v55)).u32[0];
      v71 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 8), v11), v55.f32[0]);
      v73 = vmul_n_f32(vsub_f32(*(float32x2_t *)a2, v8), v55.f32[0]);
      v70 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 16), v10), v55.f32[0]);
      v56 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 24), v13), v55.f32[0]);
      v57 = vmul_n_f32(vsub_f32(*(float32x2_t *)(a2 + 32), v12), v55.f32[0]);
      v58 = v49 - 1;
      do
      {
        v59 = v77;
        v9 = vadd_f32(v78, v77);
        v77 = v9;
        v78 = vadd_f32(v79, v78);
        v79 = vadd_f32(v80, v79);
        v8 = vadd_f32(v8, v73);
        v11 = vadd_f32(v11, v71);
        v10 = vadd_f32(v10, v70);
        v13 = vadd_f32(v13, v56);
        v12 = vadd_f32(v12, v57);
        if (v43
          && ((v60 = (uint32x2_t)vcgt_f32(vminnm_f32(v59, v9), *(float32x2_t *)(a1 + 24)),
               (vpmax_u32(v60, v60).u32[0] & 0x80000000) != 0)
           || (v61 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v59, v9)),
               (vpmax_u32(v61, v61).u32[0] & 0x80000000) != 0)))
        {
          v85 = 1;
          v81 = *(double *)&v9;
          *(float32x2_t *)&v82 = v8;
          *((float32x2_t *)&v82 + 1) = v11;
          *(float32x2_t *)&v83 = v10;
          *((float32x2_t *)&v83 + 1) = v13;
          v84 = (uint64_t)v12;
          *(_BYTE *)(a1 + 104) = 0;
        }
        else
        {
          if (*(_BYTE *)(a1 + 49))
          {
            (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
            *(_BYTE *)(a1 + 49) = 0;
            *(_BYTE *)(a1 + 52) = 1;
          }
          if (v85)
          {
            *(_BYTE *)(a1 + 104) = 0;
            (*(void (**)(_QWORD, __int128 *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v82, v81);
            v85 = 0;
          }
          if (*(_BYTE *)(a1 + 104) && !*(_DWORD *)(a1 + 108))
          {
            *(double *)(a1 + 128) = v69;
            (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0);
            *(_BYTE *)(a1 + 104) = 0;
          }
          *(_BYTE *)(a1 + 51) = 0;
          *(_BYTE *)(a1 + 49) = 1;
          *(_BYTE *)(a1 + 53) = 1;
          *(double *)(a1 + 56) = *(double *)&v9;
          *(float32x2_t *)(a1 + 64) = v8;
          *(float32x2_t *)(a1 + 72) = v11;
          *(float32x2_t *)(a1 + 80) = v10;
          *(float32x2_t *)(a1 + 88) = v13;
          *(float32x2_t *)(a1 + 96) = v12;
        }
        --v58;
      }
      while (v58);
      v23 = v67;
    }
    v74 = *(_OWORD *)a2;
    v75 = *(_OWORD *)(a2 + 16);
    v76 = *(_QWORD *)(a2 + 32);
    if (v43
      && ((v62 = (uint32x2_t)vcgt_f32(vminnm_f32(v9, *(float32x2_t *)&v23), *(float32x2_t *)(a1 + 24)),
           (vpmax_u32(v62, v62).u32[0] & 0x80000000) != 0)
       || (v63 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 16), vmaxnm_f32(v9, *(float32x2_t *)&v23)),
           (vpmax_u32(v63, v63).u32[0] & 0x80000000) != 0)))
    {
      v85 = 1;
      v81 = v23;
      v65 = *(_OWORD *)(a2 + 16);
      v82 = *(_OWORD *)a2;
      v83 = v65;
      v84 = *(_QWORD *)(a2 + 32);
      *(_BYTE *)(a1 + 104) = 0;
      if (!*(_BYTE *)(a1 + 49))
        goto LABEL_70;
    }
    else
    {
      if (*(_BYTE *)(a1 + 49))
      {
        (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
        *(_BYTE *)(a1 + 49) = 0;
        *(_BYTE *)(a1 + 52) = 1;
      }
      if (v85)
      {
        *(_BYTE *)(a1 + 104) = 0;
        (*(void (**)(_QWORD, __int128 *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v82, v81);
        v85 = 0;
      }
      if (*(_BYTE *)(a1 + 104) && !*(_DWORD *)(a1 + 108))
      {
        *(double *)(a1 + 128) = v69;
        (*(void (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0);
        *(_BYTE *)(a1 + 104) = 0;
        v64 = v85 == 0;
      }
      else
      {
        v64 = 1;
      }
      v66 = *(_BYTE *)(a1 + 33);
      *(_BYTE *)(a1 + 51) = 0;
      *(_BYTE *)(a1 + 49) = 1;
      *(_BYTE *)(a1 + 53) = v66;
      *(double *)(a1 + 56) = v23;
      *(_OWORD *)(a1 + 64) = v74;
      *(_OWORD *)(a1 + 80) = v75;
      *(_QWORD *)(a1 + 96) = v76;
      if (v64)
      {
        *(_BYTE *)(a1 + 104) = 1;
        *(_DWORD *)(a1 + 108) = 1;
        *(double *)(a1 + 112) = v68;
        return;
      }
    }
    (*(void (**)(_QWORD, uint64_t, _QWORD, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 64, *(unsigned __int8 *)(a1 + 53), *(double *)(a1 + 56));
    *(_BYTE *)(a1 + 49) = 0;
    *(_BYTE *)(a1 + 52) = 1;
LABEL_70:
    (*(void (**)(_QWORD, __int128 *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v82, v81);
  }
}

