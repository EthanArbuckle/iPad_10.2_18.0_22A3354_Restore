RB::XML::Document *RBDrawingStateClipShape(RB::DisplayList::State *a1, uint64_t a2, int a3)
{
  return RBDrawingStateClipShape2(a1, a2, a3, 1.0);
}

double RBSymbolUpdateNextTime(uint64_t a1)
{
  return *(double *)(a1 + 912);
}

uint64_t RBSymbolUpdateGroupCount(uint64_t a1)
{
  return *(unsigned int *)(a1 + 848);
}

uint64_t RBDisplayListGetState(uint64_t a1)
{
  return *(_QWORD *)(a1 + 280);
}

uint64_t RBDrawingStateGetIdentifier(uint64_t a1)
{
  return *(unsigned int *)(a1 + 64);
}

uint64_t RBPathStorageIsSingleElement(uint64_t a1)
{
  return (*(unsigned __int8 *)(a1 + 8) >> 3) & 1;
}

void `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info::~Info()
{
  JUMPOUT(0x20BD16544);
}

uint64_t ___ZNK3__0clEPKvPvPFbS2_13RBPathElementPKdS1_E_block_invoke(uint64_t a1, unsigned __int8 *a2, _BYTE *a3)
{
  uint64_t result;

  result = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD, _QWORD))(a1 + 40))(*(_QWORD *)(a1 + 48), *a2, *((_QWORD *)a2 + 1), 0);
  if ((result & 1) == 0)
  {
    *a3 = 1;
    *(_BYTE *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = 1;
  }
  return result;
}

uint64_t RB::Path::`anonymous namespace'::append_element_callback(RB::Path::Storage *a1, const char *a2, double *a3, int *a4)
{
  RB::Path::Storage::append_element(a1, a2, a3, a4);
  return 1;
}

_DWORD *RB::Path::Storage::append_element(RB::Path::Storage *this, const char *a2, double *__src, int *a4)
{
  unsigned int v4;
  RB::Path::Storage *v7;
  uint64_t v8;
  unsigned int v9;
  os_unfair_lock_s *v10;
  const void *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  size_t v15;
  char v16;
  double *v17;
  uint64_t v18;
  double v19;
  int v20;
  int v21;
  char v22;
  unint64_t v23;
  double *v24;
  double v25;
  int64x2_t v26;
  uint64_t v27;
  double v28;
  char v29;
  int v30;
  unint64_t v31;
  char v32;
  uint64_t v33;
  char *v34;
  char *v35;
  int v36;
  _DWORD *result;
  uint64_t v38;
  void *v39;
  char v40;
  uint64_t *v41;
  double *v42;
  size_t v43;
  unint64_t v44;
  int v45;
  uint64_t v46;
  unint64_t v47;
  unint64_t v48;
  uint64_t v49;
  unint64_t v50;
  unint64_t v51;
  int v52;
  uint64_t v53;
  unint64_t v54;
  int v55;
  uint64_t v56;
  char *v57;
  unsigned int v58;
  uint64_t v59;
  int v60;
  int v61;
  uint64_t v62;
  char *v63;
  unsigned int v64;
  int v65;
  uint64_t v66;
  unint64_t v67;
  int v68;
  uint64_t v69;
  unint64_t v70;
  int v71;
  uint64_t v72;
  char *v73;
  unsigned int v74;
  int v75;
  uint64_t v76;
  char *v77;
  unsigned int v78;
  uint64_t v79;
  int v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  int v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  char *v90;
  unsigned int v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  unint64_t v95;
  uint64_t v96;
  int v97;
  uint64_t v98;
  char *v99;
  unsigned int v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  char *v104;
  char *v105;
  uint64_t v106;

  v4 = a2;
  if (a2 >= 0x19)
    RB::precondition_failure((RB *)"invalid path element: %d", a2, __src, a2);
  v7 = this;
  if ((int)a2 > 18)
  {
    if ((_DWORD)a2 == 19)
    {
      if (a4 && (*a4 == 1 || a4[1] == 1))
        *((_DWORD *)this + 2) |= 4u;
      v4 = 0x13u;
    }
    else if ((_DWORD)a2 == 24)
    {
      if (a4 && a4[1] == 1)
        *((_DWORD *)this + 2) |= 4u;
      v4 = 0x18u;
    }
  }
  else if ((((_DWORD)a2 - 8) < 2
          || ((_DWORD)a2 - 10) < 2 && __src[6] == 0.0 && __src[7] == 0.0)
         && __src[4] == 0.0)
  {
    if (__src[5] == 0.0)
      v4 = 6;
    else
      v4 = a2;
  }
  v8 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    *(_QWORD *)this = 0;
    if ((v8 & 1) != 0)
    {
      this = (RB::Path::Storage *)(v8 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v8 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        this = (RB::Path::Storage *)MEMORY[0x20BD1652C](this, 0x1000C8052888210);
    }
  }
  v9 = *((_DWORD *)v7 + 2);
  if ((v9 & 0x20) != 0)
  {
    v10 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v10, v7);
    v9 = *((_DWORD *)v7 + 2);
  }
  if ((v9 & 1) != 0)
  {
    v11 = (const void *)*((_QWORD *)v7 + 7);
    if (v11)
    {
      *((_QWORD *)v7 + 7) = 0;
      CFRelease(v11);
      v9 = *((_DWORD *)v7 + 2);
    }
  }
  v12 = (v9 >> 8) & 0xFFF;
  if ((v9 & 1) != 0)
    v13 = *((_QWORD *)v7 + 3);
  else
    v13 = (v9 >> 8) & 0xFFF;
  v14 = RB::Path::Storage::append_element(RBPathElement,double const*,void const*)::elt_flags[4 * v4] | v9 & 0xFFFFFFF7 | (8 * (v13 == 0));
  *((_DWORD *)v7 + 2) = v14;
  v15 = __RBPathElementArgumentCount[v4];
  if (__RBPathElementArgumentCount[v4])
  {
    v16 = 96;
    v17 = __src;
    v18 = __RBPathElementArgumentCount[v4];
    while (1)
    {
      v19 = fabs(*v17);
      if (v19 > 32767.0)
        break;
      if ((v16 & 0x20) != 0 && vabdd_f64(floor(v19 + 0.5), v19) > 0.00000999999975)
        v16 &= ~0x20u;
      ++v17;
      if (!--v18)
      {
        if (a4)
          goto LABEL_46;
        goto LABEL_68;
      }
    }
    v16 = 0;
    if (!a4)
      goto LABEL_68;
  }
  else
  {
    v16 = 96;
    if (!a4)
    {
LABEL_68:
      v20 = 0;
LABEL_69:
      v22 = v4;
      goto LABEL_77;
    }
  }
LABEL_46:
  v20 = 0;
  v21 = 3;
  v22 = v4;
  switch(v4)
  {
    case 0x10u:
    case 0x12u:
    case 0x16u:
    case 0x17u:
      goto LABEL_77;
    case 0x11u:
    case 0x15u:
      goto LABEL_59;
    case 0x13u:
      v23 = *((_QWORD *)a4 + 1);
      if (v23 >= 0x1000)
        v23 = 4096;
      v20 = 2;
      if (!v16 || !v23)
        goto LABEL_76;
      v24 = (double *)*((_QWORD *)a4 + 2);
      while (1)
      {
        v25 = fabs(*v24);
        if (v25 > 32767.0)
          break;
        if ((v16 & 0x20) != 0 && vabdd_f64(floor(v25 + 0.5), v25) > 0.00000999999975)
          v16 &= ~0x20u;
        ++v24;
        if (!--v23)
          goto LABEL_75;
      }
      v16 = 0;
LABEL_75:
      v20 = 2;
      goto LABEL_76;
    case 0x14u:
      goto LABEL_71;
    case 0x18u:
      v21 = 4;
LABEL_71:
      v22 = v4 | 0x80;
      v20 = v21;
      goto LABEL_77;
    default:
      if (v4 == 4)
        goto LABEL_69;
LABEL_59:
      v26 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)a4 + 1), (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*(float64x2_t *)a4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(*((float64x2_t *)a4 + 2)));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v26, 1), (int8x16_t)v26).u64[0] & 0x8000000000000000) != 0)
        goto LABEL_68;
      if (!v16)
        goto LABEL_72;
      v27 = 0;
      break;
  }
  while (1)
  {
    v28 = fabs(*(double *)&a4[v27]);
    if (v28 > 32767.0)
      break;
    if ((v16 & 0x20) != 0 && vabdd_f64(floor(v28 + 0.5), v28) > 0.00000999999975)
      v16 &= ~0x20u;
    v27 += 2;
    if (v27 == 12)
      goto LABEL_73;
  }
LABEL_72:
  v16 = 0;
LABEL_73:
  v20 = 1;
LABEL_76:
  v22 = v4 | 0x80;
LABEL_77:
  v29 = v16 & 0x40;
  if ((v16 & 0x20) != 0)
    v29 = 32;
  v30 = v14 & 1;
  if ((v14 & 1) != 0)
  {
    v12 = *((_QWORD *)v7 + 3);
    v31 = *((_QWORD *)v7 + 4);
  }
  else
  {
    v31 = v9 >> 20;
  }
  v32 = v29 | v22;
  v33 = v12 + 1;
  if (v31 < v12 + 1)
  {
    RB::Path::Storage::reserve_slow(v7, v12 + 1);
    v30 = *((_DWORD *)v7 + 2) & 1;
  }
  v34 = (char *)v7 + 16;
  v35 = (char *)v7 + 16;
  if (v30)
    v35 = *(char **)v34;
  v35[v12] = v32;
  v36 = *((_DWORD *)v7 + 2);
  if ((v36 & 1) != 0)
    *((_QWORD *)v7 + 3) = v33;
  else
    *((_DWORD *)v7 + 2) = v36 & 0xFFF000FF | ((v33 & 0xFFF) << 8);
  result = RB::Path::Storage::push_values((uint64_t *)v7, v32, __src, v15);
  switch(v20)
  {
    case 1:
      v40 = v32;
      v41 = (uint64_t *)v7;
      v42 = (double *)a4;
      v43 = 6;
      goto LABEL_166;
    case 2:
      v44 = *((unsigned int *)v7 + 2);
      v45 = *((_DWORD *)v7 + 2) & 1;
      if ((v44 & 1) != 0)
      {
        v46 = *((_QWORD *)v7 + 3);
        v47 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v46 = (v44 >> 8) & 0xFFF;
        v47 = v44 >> 20;
      }
      v55 = *a4;
      v56 = v46 + 1;
      if (v47 < v46 + 1)
      {
        RB::Path::Storage::reserve_slow(v7, v46 + 1);
        v45 = *((_DWORD *)v7 + 2) & 1;
      }
      v57 = (char *)v7 + 16;
      if (v45)
        v57 = *(char **)v34;
      v57[v46] = v55;
      v58 = *((_DWORD *)v7 + 2);
      if ((v58 & 1) != 0)
      {
        *((_QWORD *)v7 + 3) = v56;
      }
      else
      {
        v58 = v58 & 0xFFF000FF | ((v56 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v58;
      }
      v65 = v58 & 1;
      if ((v58 & 1) != 0)
      {
        v66 = *((_QWORD *)v7 + 3);
        v67 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v66 = (v58 >> 8) & 0xFFF;
        v67 = v58 >> 20;
      }
      v71 = a4[1];
      v72 = v66 + 1;
      if (v67 < v66 + 1)
      {
        RB::Path::Storage::reserve_slow(v7, v66 + 1);
        v65 = *((_DWORD *)v7 + 2) & 1;
      }
      v73 = (char *)v7 + 16;
      if (v65)
        v73 = *(char **)v34;
      v73[v66] = v71;
      v74 = *((_DWORD *)v7 + 2);
      if ((v74 & 1) != 0)
      {
        *((_QWORD *)v7 + 3) = v72;
      }
      else
      {
        v74 = v74 & 0xFFF000FF | ((v72 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v74;
      }
      if (*((_QWORD *)a4 + 1) >= 0x1000uLL)
        v79 = 4096;
      else
        v79 = *((_QWORD *)a4 + 1);
      v80 = v74 & 1;
      if ((v74 & 1) != 0)
      {
        v81 = *((_QWORD *)v7 + 3);
        v82 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v81 = (v74 >> 8) & 0xFFF;
        v82 = v74 >> 20;
      }
      v87 = v81 + 2;
      if (v82 >= v81 + 2)
      {
        if (!v80)
          goto LABEL_154;
        goto LABEL_153;
      }
      RB::Path::Storage::reserve_slow(v7, v81 + 2);
      if ((*((_DWORD *)v7 + 2) & 1) != 0)
LABEL_153:
        v34 = *(char **)v34;
LABEL_154:
      *(_WORD *)&v34[v81] = v79;
      v88 = *((_DWORD *)v7 + 2);
      if ((v88 & 1) != 0)
        *((_QWORD *)v7 + 3) = v87;
      else
        *((_DWORD *)v7 + 2) = v88 & 0xFFF000FF | ((v87 & 0xFFF) << 8);
      v42 = (double *)*((_QWORD *)a4 + 2);
      v40 = v32;
      v41 = (uint64_t *)v7;
      v43 = v79;
LABEL_166:
      result = RB::Path::Storage::push_values(v41, v40, v42, v43);
      goto LABEL_167;
    case 3:
      v48 = *((unsigned int *)v7 + 2);
      if ((v48 & 1) != 0)
      {
        v49 = *((_QWORD *)v7 + 3);
        v50 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v49 = (v48 >> 8) & 0xFFF;
        v50 = v48 >> 20;
      }
      v59 = v49 + 2;
      if (v50 >= v49 + 2)
      {
        if ((*((_DWORD *)v7 + 2) & 1) == 0)
          goto LABEL_108;
        goto LABEL_107;
      }
      result = RB::Path::Storage::reserve_slow(v7, v49 + 2);
      if ((*((_DWORD *)v7 + 2) & 1) != 0)
LABEL_107:
        v34 = *(char **)v34;
LABEL_108:
      *(_WORD *)&v34[v49] = *(_WORD *)a4;
      v60 = *((_DWORD *)v7 + 2);
      if ((v60 & 1) != 0)
        *((_QWORD *)v7 + 3) = v59;
      else
        *((_DWORD *)v7 + 2) = v60 & 0xFFF000FF | ((v59 & 0xFFF) << 8);
LABEL_167:
      if (v4 == 16 || v4 == 4)
        return RB::Path::Storage::update_single_element(v7, v38, v39);
      return result;
    case 4:
      v51 = *((unsigned int *)v7 + 2);
      v52 = *((_DWORD *)v7 + 2) & 1;
      if ((v51 & 1) != 0)
      {
        v53 = *((_QWORD *)v7 + 3);
        v54 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v53 = (v51 >> 8) & 0xFFF;
        v54 = v51 >> 20;
      }
      v61 = *a4;
      v62 = v53 + 1;
      if (v54 < v53 + 1)
      {
        result = RB::Path::Storage::reserve_slow(v7, v53 + 1);
        v52 = *((_DWORD *)v7 + 2) & 1;
      }
      v63 = (char *)v7 + 16;
      if (v52)
        v63 = *(char **)v34;
      v63[v53] = v61;
      v64 = *((_DWORD *)v7 + 2);
      if ((v64 & 1) != 0)
      {
        *((_QWORD *)v7 + 3) = v62;
      }
      else
      {
        v64 = v64 & 0xFFF000FF | ((v62 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v64;
      }
      v68 = v64 & 1;
      if ((v64 & 1) != 0)
      {
        v69 = *((_QWORD *)v7 + 3);
        v70 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v69 = (v64 >> 8) & 0xFFF;
        v70 = v64 >> 20;
      }
      v75 = a4[1];
      v76 = v69 + 1;
      if (v70 < v69 + 1)
      {
        result = RB::Path::Storage::reserve_slow(v7, v69 + 1);
        v68 = *((_DWORD *)v7 + 2) & 1;
      }
      v77 = (char *)v7 + 16;
      if (v68)
        v77 = *(char **)v34;
      v77[v69] = v75;
      v78 = *((_DWORD *)v7 + 2);
      if ((v78 & 1) != 0)
      {
        *((_QWORD *)v7 + 3) = v76;
      }
      else
      {
        v78 = v78 & 0xFFF000FF | ((v76 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v78;
      }
      if (*((_QWORD *)a4 + 1) >= 0x800uLL)
        v83 = 2048;
      else
        v83 = *((_QWORD *)a4 + 1);
      v84 = v78 & 1;
      if ((v78 & 1) != 0)
      {
        v85 = *((_QWORD *)v7 + 3);
        v86 = *((_QWORD *)v7 + 4);
      }
      else
      {
        v85 = (v78 >> 8) & 0xFFF;
        v86 = v78 >> 20;
      }
      v89 = v85 + 2;
      if (v86 < v85 + 2)
      {
        result = RB::Path::Storage::reserve_slow(v7, v85 + 2);
        v84 = *((_DWORD *)v7 + 2) & 1;
      }
      v90 = (char *)v7 + 16;
      if (v84)
        v90 = *(char **)v34;
      *(_WORD *)&v90[v85] = v83;
      v91 = *((_DWORD *)v7 + 2);
      if ((v91 & 1) != 0)
      {
        *((_QWORD *)v7 + 3) = v89;
        if (!v83)
          goto LABEL_167;
      }
      else
      {
        v91 = v91 & 0xFFF000FF | ((v89 & 0xFFF) << 8);
        *((_DWORD *)v7 + 2) = v91;
        if (!v83)
          goto LABEL_167;
      }
      v92 = 0;
      v93 = 16 * v83;
      break;
    default:
      goto LABEL_167;
  }
  while (1)
  {
    if ((v91 & 1) != 0)
    {
      v94 = *((_QWORD *)v7 + 3);
      v95 = *((_QWORD *)v7 + 4);
    }
    else
    {
      v94 = (v91 >> 8) & 0xFFF;
      v95 = v91 >> 20;
    }
    v96 = *((_QWORD *)a4 + 2);
    v97 = *(_DWORD *)(v96 + v92);
    v98 = v94 + 1;
    if (v95 < v94 + 1)
    {
      result = RB::Path::Storage::reserve_slow(v7, v94 + 1);
      v91 = *((_DWORD *)v7 + 2);
    }
    v99 = (char *)v7 + 16;
    if ((v91 & 1) != 0)
      v99 = *(char **)v34;
    v99[v94] = v97;
    v100 = *((_DWORD *)v7 + 2);
    if ((v100 & 1) != 0)
    {
      *((_QWORD *)v7 + 3) = v98;
    }
    else
    {
      v100 = v100 & 0xFFF000FF | ((v98 & 0xFFF) << 8);
      *((_DWORD *)v7 + 2) = v100;
      if ((v100 & 1) == 0)
      {
        v102 = (v100 >> 8) & 0xFFF;
        v101 = v100 >> 20;
        goto LABEL_184;
      }
    }
    v102 = *((_QWORD *)v7 + 3);
    v101 = *((_QWORD *)v7 + 4);
LABEL_184:
    v103 = v102 + 12;
    if (v101 < v102 + 12)
    {
      result = RB::Path::Storage::reserve_slow(v7, v102 + 12);
      v100 = *((_DWORD *)v7 + 2);
    }
    v104 = (char *)v7 + 16;
    if ((v100 & 1) != 0)
      v104 = *(char **)v34;
    v105 = &v104[v102];
    v106 = *(_QWORD *)(v96 + v92 + 4);
    *((_DWORD *)v105 + 2) = *(_DWORD *)(v96 + v92 + 12);
    *(_QWORD *)v105 = v106;
    v91 = *((_DWORD *)v7 + 2);
    if ((v91 & 1) != 0)
    {
      *((_QWORD *)v7 + 3) = v103;
    }
    else
    {
      v91 = v91 & 0xFFF000FF | ((v103 & 0xFFF) << 8);
      *((_DWORD *)v7 + 2) = v91;
    }
    v92 += 16;
    if (v93 == v92)
      goto LABEL_167;
  }
}

uint64_t *RB::Path::Storage::push_values(uint64_t *this, char a2, double *__src, size_t __n)
{
  size_t v4;
  uint64_t *v6;
  size_t v7;
  unint64_t v8;
  int v9;
  uint64_t v10;
  size_t v11;
  unint64_t v12;
  uint64_t v13;
  size_t v14;
  size_t v15;
  uint64_t v16;
  size_t v17;
  _QWORD *v18;
  float *v19;
  double v20;
  float v21;
  _QWORD *v22;
  int v23;
  _QWORD *v24;
  _WORD *v25;
  double v26;

  v4 = __n;
  v6 = this;
  if ((a2 & 0x40) != 0)
  {
    v12 = *((unsigned int *)this + 2);
    if ((v12 & 1) != 0)
    {
      v13 = this[3];
      v15 = this[4];
      v14 = v13 + 4 * __n;
    }
    else
    {
      v13 = (v12 >> 8) & 0xFFF;
      v14 = v13 + 4 * __n;
      v15 = v12 >> 20;
    }
    if (v15 < v14)
    {
      this = (uint64_t *)RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v14);
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
    v18 = v6 + 2;
    if ((v12 & 1) != 0)
      v18 = (_QWORD *)*v18;
    if (v4)
    {
      v19 = (float *)((char *)v18 + v13);
      do
      {
        v20 = *__src++;
        v21 = v20;
        *v19++ = v21;
        --v4;
      }
      while (v4);
      goto LABEL_33;
    }
  }
  else
  {
    if ((a2 & 0x20) == 0)
    {
      v7 = 8 * __n;
      v8 = *((unsigned int *)this + 2);
      v9 = this[1] & 1;
      if ((v8 & 1) != 0)
      {
        v10 = this[3];
        v11 = this[4];
      }
      else
      {
        v10 = (v8 >> 8) & 0xFFF;
        v11 = v8 >> 20;
      }
      v14 = v10 + v7;
      if (v11 < v10 + v7)
      {
        RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v10 + v7);
        v9 = v6[1] & 1;
      }
      v22 = v6 + 2;
      if (v9)
        v22 = (_QWORD *)*v22;
      this = (uint64_t *)memcpy((char *)v22 + v10, __src, v7);
      v23 = *((_DWORD *)v6 + 2);
      if ((v23 & 1) == 0)
      {
        *((_DWORD *)v6 + 2) = v23 & 0xFFF000FF | ((v14 & 0xFFF) << 8);
        return this;
      }
      goto LABEL_36;
    }
    v12 = *((unsigned int *)this + 2);
    if ((v12 & 1) != 0)
    {
      v16 = this[3];
      v17 = this[4];
      v14 = v16 + 2 * __n;
    }
    else
    {
      v16 = (v12 >> 8) & 0xFFF;
      v14 = v16 + 2 * __n;
      v17 = v12 >> 20;
    }
    if (v17 < v14)
    {
      this = (uint64_t *)RB::Path::Storage::reserve_slow((RB::Path::Storage *)this, v14);
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
    v24 = v6 + 2;
    if ((v12 & 1) != 0)
      v24 = (_QWORD *)*v24;
    if (v4)
    {
      v25 = (_WORD *)((char *)v24 + v16);
      do
      {
        v26 = *__src++;
        *v25++ = vcvtmd_s64_f64(v26 + 0.5);
        --v4;
      }
      while (v4);
LABEL_33:
      LODWORD(v12) = *((_DWORD *)v6 + 2);
    }
  }
  if ((v12 & 1) == 0)
  {
    *((_DWORD *)v6 + 2) = v12 & 0xFFF000FF | ((v14 & 0xFFF) << 8);
    return this;
  }
LABEL_36:
  v6[3] = v14;
  return this;
}

_DWORD *RB::Path::Storage::update_single_element(_DWORD *this, uint64_t a2, void *a3)
{
  int v3;
  _DWORD *v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;

  v3 = this[2];
  if ((v3 & 0x10) == 0)
  {
    v4 = this;
    v6 = 0;
    v7 = 0;
    v9 = 0;
    v8 = 0;
    this = (_DWORD *)RB::Path::NestedCallbacks::single_element_fast((RB::Path::NestedCallbacks *)this, (const RB::Path::Storage *)&v6, a3);
    v4[2] = v3 & 0xFFFFFFF7;
    if (!v7)
    {
      if (v8)
      {
        v5 = v3 & 0xFFFFFFE7 | 0x10;
        if (v8 == 1)
          v5 = v3 | 8;
        v4[2] = v5;
      }
    }
  }
  return this;
}

void *RB::Path::Storage::reserve_slow(RB::Path::Storage *this, size_t a2)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  void *v9;
  const char *v10;
  void *v11;
  unint64_t v12;
  size_t v13;
  char *v14;
  void *result;

  v3 = *((unsigned int *)this + 2);
  if ((v3 & 1) != 0)
    v4 = *((_QWORD *)this + 4);
  else
    v4 = v3 >> 20;
  v5 = 2 * v4;
  if (v5 <= a2)
    v6 = a2;
  else
    v6 = v5;
  v7 = malloc_good_size(v6);
  v8 = v7;
  if ((*((_BYTE *)this + 8) & 1) != 0)
  {
    result = malloc_type_realloc(*((void **)this + 2), v7, 0x64C53627uLL);
    v11 = result;
    if (result)
      goto LABEL_15;
LABEL_12:
    RB::precondition_failure((RB *)"allocation failure", v10);
  }
  v9 = malloc_type_malloc(v7, 0x4E39F373uLL);
  if (!v9)
    goto LABEL_12;
  v11 = v9;
  v12 = *((unsigned int *)this + 2);
  if ((v12 & 1) != 0)
  {
    v14 = (char *)*((_QWORD *)this + 2);
    v13 = *((_QWORD *)this + 3);
  }
  else
  {
    v13 = (v12 >> 8) & 0xFFF;
    v14 = (char *)this + 16;
  }
  result = memcpy(v9, v14, v13);
  *((_DWORD *)this + 2) |= 1u;
  *((_QWORD *)this + 3) = v13;
  *((_QWORD *)this + 7) = 0;
LABEL_15:
  *((_QWORD *)this + 2) = v11;
  *((_QWORD *)this + 4) = v8;
  return result;
}

uint64_t RB::Path::NestedCallbacks::first_element(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  _BOOL4 v6;
  uint64_t result;
  uint64_t v8;
  unsigned __int8 v9;

  v9 = 0;
  v6 = RB::Path::Storage::Iterator::next_type(a2, a1, &v9);
  result = 0;
  if (v6)
  {
    v8 = 0;
    while (1)
    {
      if (v9 <= 0x18u)
      {
        if (((1 << v9) & 0x1DE0000) != 0)
        {
          if (++v8 == a3)
            return 1;
        }
        else if (v9 == 16)
        {
          return 0;
        }
      }
      if (!RB::Path::Storage::Iterator::next_type(a2, a1, &v9))
        return 0;
    }
  }
  return result;
}

uint64_t RB::Path::NestedCallbacks::single_element_fast(RB::Path::NestedCallbacks *this, const RB::Path::Storage *a2, void *a3)
{
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unsigned __int8 v12;
  uint64_t v13;

  v13 = 0;
  v5 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    if (!RB::Path::NestedCallbacks::first_element((uint64_t)this, &v13, v5))
      return 0;
    *((_QWORD *)a2 + 1) = v5;
  }
  v12 = 0;
  v6 = *((_QWORD *)a2 + 2);
  v7 = 1;
  if (v6 <= 1)
  {
    do
    {
      if (!RB::Path::Storage::Iterator::next_type(&v13, (uint64_t)this, &v12))
        break;
      v8 = v12;
      switch(v12)
      {
        case 0u:
        case 1u:
        case 2u:
        case 3u:
        case 0xCu:
        case 0xDu:
        case 0xEu:
        case 0xFu:
          if (*((_QWORD *)a2 + 1) == v5)
          {
            *((_BYTE *)a2 + 24) = 1;
            goto LABEL_9;
          }
          break;
        case 4u:
          if (*((_QWORD *)a2 + 1) == v5 && *((_BYTE *)a2 + 24))
          {
            *((_BYTE *)a2 + 24) = 0;
            goto LABEL_9;
          }
          break;
        case 0x10u:
          v10 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = v10 - 1;
          if (v10 == v5)
            return 0;
          break;
        case 0x11u:
        case 0x12u:
        case 0x13u:
        case 0x14u:
        case 0x16u:
        case 0x17u:
        case 0x18u:
          v9 = *((_QWORD *)a2 + 1);
          *((_QWORD *)a2 + 1) = v9 + 1;
          if (v9 == v5)
          {
            *((_QWORD *)a2 + 2) = ++v6;
            *((_BYTE *)a2 + 24) = v8 != 19;
          }
          break;
        default:
          if (*((_QWORD *)a2 + 1) == v5)
LABEL_9:
            *((_QWORD *)a2 + 2) = ++v6;
          break;
      }
    }
    while (v6 < 2);
    return 1;
  }
  return v7;
}

BOOL RB::Path::Storage::Iterator::next_type(uint64_t *a1, uint64_t a2, _BYTE *a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  char v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;

  v3 = *a1;
  v4 = *(unsigned int *)(a2 + 8);
  v5 = (v4 >> 8) & 0xFFF;
  if ((v4 & 1) != 0)
    v5 = *(_QWORD *)(a2 + 24);
  if (v3 < v5)
  {
    v8 = *(_QWORD *)(a2 + 16);
    v6 = a2 + 16;
    v7 = v8;
    if ((v4 & 1) == 0)
      v7 = v6;
    *a1 = v3 + 1;
    v9 = *(_BYTE *)(v7 + v3) & 0x1F;
    if ((*(_BYTE *)(v7 + v3) & 0x80) != 0)
    {
      v11 = 0;
      v10 = 1;
      switch(*(_BYTE *)(v7 + v3) & 0x1F)
      {
        case 0x10:
        case 0x12:
        case 0x16:
        case 0x17:
          goto LABEL_17;
        case 0x11:
        case 0x15:
          goto LABEL_8;
        case 0x13:
          v11 = 2;
          goto LABEL_17;
        case 0x14:
          v11 = 3;
          goto LABEL_17;
        case 0x18:
          v11 = 4;
          goto LABEL_17;
        default:
          if ((_DWORD)v9 == 4)
            goto LABEL_17;
          goto LABEL_8;
      }
    }
    v10 = 0;
LABEL_8:
    if (v9 > 0x18)
    {
      v12 = 0;
    }
    else
    {
      v11 = v10;
LABEL_17:
      v12 = __RBPathElementArgumentCount[v9];
      v10 = v11;
    }
    if ((*(_BYTE *)(v7 + v3) & 0x40) != 0)
      v13 = 2;
    else
      v13 = 3;
    if ((*(_BYTE *)(v7 + v3) & 0x20) != 0)
      v14 = 1;
    else
      v14 = v13;
    v15 = (v12 << v14) + v3 + 1;
    *a1 = v15;
    switch(v10)
    {
      case 1:
        v16 = v15 + (6 << v14);
        goto LABEL_30;
      case 2:
        v17 = v15 + ((unint64_t)*(unsigned __int16 *)(v15 + v7 + 2) << v14);
        goto LABEL_29;
      case 3:
        v16 = v15 + 2;
        goto LABEL_30;
      case 4:
        v17 = v15 + 13 * *(unsigned __int16 *)(v15 + v7 + 2);
LABEL_29:
        v16 = v17 + 4;
LABEL_30:
        *a1 = v16;
        break;
      default:
        break;
    }
    *a3 = v9;
  }
  return v3 < v5;
}

unint64_t RBUUIDInitFromHash(uint64_t a1, uint64_t a2, char a3)
{
  return a1 & 0xFFFFFFFFFFFF0FFFLL | ((a3 & 0xF) << 12);
}

uint64_t RBSymbolUpdateGroupSize(uint64_t a1, int a2)
{
  uint64_t v2;
  unsigned int v3;
  uint64_t v4;

  v2 = a1 + 8;
  v3 = *(_DWORD *)(a1 + 848) + ~a2;
  if (*(_QWORD *)(a1 + 840))
    v2 = *(_QWORD *)(a1 + 840);
  v4 = *(_QWORD *)(v2 + 416 * v3 + 400);
  if (v4)
    return *(_QWORD *)(v4 + 8);
  else
    return *(unsigned int *)(v2 + 416 * v3 + 384);
}

BOOL RB::Symbol::Animator::animating(os_unfair_lock_s *this)
{
  _BOOL8 v2;

  os_unfair_lock_lock(this);
  v2 = *(_QWORD *)&this[6]._os_unfair_lock_opaque != 0;
  os_unfair_lock_unlock(this);
  return v2;
}

void RB::Fill::Gradient::fill(uint64_t a1, RB::CGContext *a2, double a3, double a4, double a5, float64x2_t a6, float64x2_t a7, int8x16_t a8, int8x16_t a9)
{
  float32x2_t *v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unsigned int v15;
  unsigned __int8 *v16;
  unsigned __int8 *v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  __int32 v22;
  float v23;
  float v24;
  float v25;
  unint64_t v26;
  int8x16_t v27;
  unint64_t v28;
  int8x16_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  uint64_t v33;
  int64x2_t v34;
  int8x16_t v35;
  int8x16_t v36;
  int8x16_t v37;
  int8x16_t v38;
  int8x16_t v39;
  unint64_t v40;
  uint64_t v41;
  int64x2_t v42;
  int8x16_t v43;
  int8x16_t v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  uint64_t v48;
  int64x2_t v49;
  int8x16_t v50;
  int8x16_t v51;
  int8x16_t v52;
  int8x16_t v53;
  int8x16_t v54;
  unint64_t v55;
  float v56;
  double *v57;
  float64x2_t *v58;
  uint64_t v59;
  uint64_t v65;
  uint64_t v66;
  float v67;
  float64x2_t v68;
  float64x2_t v69;
  CGFloat *v70;
  size_t v71;
  CGFloat *v72;
  uint64_t v73;
  double *v74;
  CGFloat *v75;
  __int16 v79;
  double v83;
  unsigned __int16 v86;
  unsigned __int16 v87;
  int8x16_t v90;
  int8x16_t v91;
  int64x2_t v92;
  unint64_t v93;
  RB::CGContext *v94;
  BOOL v95;
  unsigned __int8 *v96;
  char *v97;
  CGGradient *v98;
  CGContext *v99;
  _OWORD *v100;
  __int128 v101;
  CGPoint v102;
  CGPoint v103;
  CGFloat y;
  CGFloat v105;
  CGPoint v106;
  CGPoint v107;
  CGFloat v108;
  CGFloat v109;
  float v110;
  float v111;
  float v112;
  float32x2_t v113;
  _BOOL4 v114;
  double v115;
  CGPoint v116;
  CGFloat v117;
  CGFloat height;
  CGImage *Image;
  CGFloat v121;
  uint64_t v122;
  unint64_t v123;
  int v124;
  RB::CGContext *v125;
  float32x2_t *v126;
  float16x4_t *v127;
  float16x4_t *v128;
  unsigned int v129;
  unsigned __int8 *v130;
  int v131;
  int8x16_t v132;
  CGPoint v133;
  CGContext *v134;
  CGAffineTransform v135;
  int8x16_t v136;
  uint64_t v137[2];
  unsigned __int8 v138;
  CGFloat *v139;
  size_t v140;
  uint64_t v141;
  CGFloat *v142;
  uint64_t v143;
  uint64_t v144;
  _OWORD v145[56];
  uint64_t v146;
  CGRect ClipBoundingBox;
  CGRect v148;

  v10 = (float32x2_t *)a1;
  v11 = 0;
  v12 = 0;
  v146 = *MEMORY[0x24BDAC8D0];
  v14 = *(_QWORD *)a1;
  v13 = *(_QWORD *)(a1 + 8);
  v15 = *(_DWORD *)(a1 + 48);
  v16 = (unsigned __int8 *)a2 + 8;
  v17 = (unsigned __int8 *)(a1 + 53);
  if (!*(_BYTE *)(a1 + 54))
    v17 = (unsigned __int8 *)a2 + 8;
  v18 = *v17;
  if ((v15 & 0x200) != 0 && v14 >= 2)
  {
    if (v19 >> 60)
      return;
    v20 = v19;
    if (16 * v19 <= 0x1000)
    {
      MEMORY[0x24BDAC7A8](v19, 16 * v19);
      v12 = (unint64_t)&v122 - ((v21 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero((void *)v12, v21);
      v11 = 0;
    }
    else
    {
      v12 = (unint64_t)malloc_type_malloc(16 * v19, 0xD12F0EA0uLL);
      if (!v12)
      {
LABEL_86:
        free((void *)v12);
        return;
      }
      v11 = 1;
    }
    v125 = a2;
    v130 = v16;
    v18 = *v16;
    v22 = v10[6].i32[0];
    v131 = 256;
    v14 = v20;
    v15 = v22;
    v13 = v12;
  }
  else
  {
    v130 = (unsigned __int8 *)a2 + 8;
    v125 = a2;
    v131 = v15;
  }
  v142 = 0;
  v143 = 0;
  v144 = 0;
  v139 = 0;
  v140 = 0;
  v141 = 0;
  v137[0] = (uint64_t)&v142;
  v137[1] = (uint64_t)&v139;
  v138 = *v130;
  if (v10[6].i8[4] == 4)
  {
    v23 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)v10);
    v25 = v24;
  }
  else
  {
    v25 = 0.0;
    v23 = 1.0;
  }
  v129 = 0x3010200u >> ((v15 >> 3) & 0x18);
  v126 = v10;
  if (v14)
  {
    HIDWORD(v122) = v15;
    v124 = v11;
    v123 = v12;
    v26 = v18 << 32;
    v127 = (float16x4_t *)((char *)v136.i64 + 4);
    v128 = (float16x4_t *)((char *)v145 + 4);
    v18 = v14 - 2;
    v27 = (int8x16_t)vdupq_n_s64(v26);
    v28 = 1;
    v29 = (int8x16_t)vdupq_n_s64(0x10000000000uLL);
    v132 = v29;
    v133 = (CGPoint)v27;
    v30 = v14;
    do
    {
      v31 = v28 - 1;
      v32 = v30 - 1;
      if (v23 <= 0.0)
        v31 = v30 - 1;
      v33 = v13 + 16 * v31;
      *(float *)v27.i32 = *(float *)(v33 + 8) * v23;
      *(float *)v29.i32 = *(float *)v27.i32 + v25;
      v34.i64[0] = WORD1(*(_QWORD *)v33);
      v34.i64[1] = (unsigned __int16)WORD2(*(_QWORD *)v33);
      v35.i64[0] = 0xFFFFLL;
      v35.i64[1] = 0xFFFFLL;
      *(_QWORD *)&a7.f64[1] = (unint64_t)(unsigned __int16)HIWORD(*(_QWORD *)v33) << 16;
      v36.i64[0] = vshlq_n_s64(v34, 0x30uLL).u64[0];
      v36.i64[1] = vorrq_s8(*(int8x16_t *)&a7, vandq_s8(*(int8x16_t *)&v34, v35)).i64[1];
      v37.i64[1] = v132.i64[1];
      v35.i64[1] = *(_QWORD *)&v133.y;
      v35.i64[0] = (unint64_t)(unsigned __int16)*(_QWORD *)v33 << 32;
      v37.i64[0] = COERCE_UNSIGNED_INT(*(float *)v27.i32 + v25);
      v38 = vorrq_s8(v35, v37);
      v39 = vorrq_s8(v36, v38);
      v145[0] = v39;
      if ((float)(*(float *)v27.i32 + v25) >= 0.0)
      {
        if (*(float *)v29.i32 > 1.0)
        {
          if (v28 != 1)
          {
            if (v23 > 0.0)
              v30 = v28 - 2;
            v48 = v13 + 16 * v30;
            *(float *)v29.i32 = *(float *)(v48 + 8) * v23;
            v49.i64[0] = WORD1(*(_QWORD *)v48);
            v49.i64[1] = (unsigned __int16)WORD2(*(_QWORD *)v48);
            v50.i64[0] = 0xFFFFLL;
            v50.i64[1] = 0xFFFFLL;
            a8.i64[1] = (unint64_t)(unsigned __int16)HIWORD(*(_QWORD *)v48) << 16;
            v51.i64[0] = vshlq_n_s64(v49, 0x30uLL).u64[0];
            v51.i64[1] = vorrq_s8(a8, vandq_s8(*(int8x16_t *)&v49, v50)).i64[1];
            v52.i64[1] = v132.i64[1];
            v50.i64[1] = *(_QWORD *)&v133.y;
            v50.i64[0] = (unint64_t)(unsigned __int16)*(_QWORD *)v48 << 32;
            v52.i64[0] = COERCE_UNSIGNED_INT(*(float *)v29.i32 + v25);
            v53 = vorrq_s8(v50, v52);
            v54 = vorrq_s8(v51, v53);
            v136 = v54;
            if ((float)(*(float *)v29.i32 + v25) <= 1.0)
            {
              *(float *)v39.i32 = (float)(*(float *)v29.i32 + v25) - 1.0;
              *(float *)v29.i32 = (float)(*(float *)v39.i32 / (float)(*(float *)v27.i32 - *(float *)v29.i32)) + 1.0;
              RB::Fill::Color::mix(v128, v127, v129, v29, v27, *(double *)v39.i64, *(double *)v54.i64, *(double *)v53.i64, v52);
            }
          }
          LODWORD(v145[0]) = 1065353216;
          v29.i32[0] = 1.0;
        }
      }
      else
      {
        if (v28 < v14)
        {
          v40 = v30 - 2;
          if (v23 > 0.0)
            v40 = v28;
          v41 = v13 + 16 * v40;
          *(float *)v39.i32 = *(float *)(v41 + 8) * v23;
          v42.i64[0] = WORD1(*(_QWORD *)v41);
          v42.i64[1] = (unsigned __int16)WORD2(*(_QWORD *)v41);
          v43.i64[0] = 0xFFFFLL;
          v43.i64[1] = 0xFFFFLL;
          a9.i64[1] = (unint64_t)(unsigned __int16)HIWORD(*(_QWORD *)v41) << 16;
          v44.i64[0] = vshlq_n_s64(v42, 0x30uLL).u64[0];
          v44.i64[1] = vorrq_s8(a9, vandq_s8(*(int8x16_t *)&v42, v43)).i64[1];
          v45.i64[1] = v132.i64[1];
          v43.i64[1] = *(_QWORD *)&v133.y;
          v43.i64[0] = (unint64_t)(unsigned __int16)*(_QWORD *)v41 << 32;
          v45.i64[0] = COERCE_UNSIGNED_INT(*(float *)v39.i32 + v25);
          v46 = vorrq_s8(v43, v45);
          v47 = vorrq_s8(v44, v46);
          v136 = v47;
          if ((float)(*(float *)v39.i32 + v25) >= 0.0)
          {
            *(float *)v27.i32 = *(float *)v27.i32 - *(float *)v39.i32;
            *(float *)v29.i32 = *(float *)v29.i32 / *(float *)v27.i32;
            *(float *)v38.i32 = *(float *)v39.i32 + v25;
            RB::Fill::Color::mix(v128, v127, v129, v29, v27, *(double *)v39.i64, *(double *)v38.i64, *(double *)v47.i64, v46);
          }
        }
        LODWORD(v145[0]) = 0;
        v29.i32[0] = 0;
      }
      v12 = v12 & 0xFFFFFFFFFFFF0000 | WORD6(v145[0]);
      *(double *)v29.i64 = RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v137, *(uint64_t *)((char *)v145 + 4), v12, *(double *)v29.i64);
      if ((v131 & 0x100) != 0 && v28 < v14)
      {
        v29.i32[0] = v145[0];
        v11 &= 0xFFFFFFFFFFFF0000;
        *(double *)v29.i64 = RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v137, 0, v11, *(double *)v29.i64);
      }
      ++v28;
      v30 = v32;
    }
    while (v28 - v14 != 1);
    v12 = v123;
    LODWORD(v11) = v124;
    v10 = v126;
    LOBYTE(v15) = BYTE4(v122);
    if ((v131 & 0x100) != 0)
    {
      v55 = v14 - 1;
      if (v14 > 1)
      {
        if (v23 > 0.0)
          v55 = 0;
        v56 = v25 + (float)(*(float *)(v13 + 16 * v55 + 8) * v23);
        v57 = v139 + 1;
        v58 = (float64x2_t *)(v142 + 6);
        v59 = 1;
        __asm { FMOV            V0.2D, #0.5 }
        do
        {
          v65 = v59 - 1;
          if (v23 <= 0.0)
            v66 = v18;
          else
            v66 = v59;
          if (v23 <= 0.0)
            v65 = v18 + 1;
          v67 = v25 + (float)(*(float *)(v13 + 16 * v66 + 8) * v23);
          *v57 = (float)(v56 + (float)((float)(v67 - v56) * *(float *)(v13 + 16 * v65 + 12)));
          v57 += 2;
          v68 = v58[-3];
          v69 = v58[-2];
          a8 = (int8x16_t)v58[2];
          a7 = vsubq_f64(v58[1], v68);
          v58[-1] = vmlaq_f64(v68, _Q0, a7);
          a6 = vmlaq_f64(v69, _Q0, vsubq_f64((float64x2_t)a8, v69));
          *v58 = a6;
          v58 += 4;
          --v18;
          ++v59;
          v56 = v67;
        }
        while (v59 != v14);
      }
    }
  }
  if ((v15 & 0x40) != 0)
  {
    v70 = v142;
    v143 = 0;
    v144 = 0;
    v141 = 0;
    v142 = 0;
    v72 = v139;
    v71 = v140;
    v139 = 0;
    v140 = 0;
    if (v71)
    {
      v73 = 0;
      v133 = (CGPoint)xmmword_209BD7360;
      v74 = v72;
      v75 = v70;
      do
      {
        if (++v73 >= v71)
        {
          v83 = *v74;
          *(float *)&v83 = *v74;
          _D1 = *(_QWORD *)v75;
          _D2 = *((_QWORD *)v75 + 1);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          v86 = _D1;
          v87 = _D2;
          _Q1 = *((_OWORD *)v75 + 1);
          _D2 = *((_QWORD *)v75 + 3);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          WORD1(_Q1) = _D2;
          *(_QWORD *)&_Q1 = vmovl_u16(*(uint16x4_t *)&_Q1).u64[0];
          v90.i64[0] = _Q1;
          v90.i64[1] = DWORD1(_Q1);
          v91.i64[0] = 0xFFFFLL;
          v91.i64[1] = 0xFFFFLL;
          v92 = (int64x2_t)vshlq_u64((uint64x2_t)vandq_s8(v90, v91), (uint64x2_t)v133);
          v93 = v18 & 0xFFFFFFFFFFFF0000 | *v130;
          v18 = v93 | 0x100;
          RB::Fill::Gradient::fill(RB::CGContext &,RB::Bounds)const::$_0::operator()(v137, vorrq_s8((int8x16_t)vdupq_laneq_s64(v92, 1), (int8x16_t)v92).u64[0] | ((unint64_t)v87 << 16) | v86, v93 | 0x100, v83);
        }
        else
        {
          _Q1 = *(_OWORD *)v75;
          _Q0 = *((_OWORD *)v75 + 1);
          _D2 = *((_QWORD *)v75 + 1);
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          WORD1(_Q1) = _D2;
          v79 = *v130 | 0x100;
          __asm { FCVT            H2, D0 }
          WORD2(_Q1) = _D2;
          *(CGFloat *)&_Q0 = v75[3];
          __asm { FCVT            H0, D0 }
          WORD3(_Q1) = _Q0;
          *(_QWORD *)&v145[0] = _Q1;
          WORD4(v145[0]) = v79;
          _Q1 = *(int8x16_t *)(v75 + 4);
          _Q0 = *(int8x16_t *)(v75 + 6);
          _D2 = v75[5];
          __asm
          {
            FCVT            H2, D2
            FCVT            H1, D1
          }
          _Q1.i16[1] = LOWORD(_D2);
          __asm { FCVT            H2, D0 }
          _Q1.i16[2] = LOWORD(_D2);
          _Q0.i64[0] = (uint64_t)v75[7];
          __asm { FCVT            H0, D0 }
          _Q1.i16[3] = _Q0.i16[0];
          v136.i64[0] = _Q1.i64[0];
          v136.i16[4] = v79;
          _Q0.i64[0] = *(uint64_t *)v74;
          _Q1.i64[0] = (uint64_t)v74[1];
          *(float *)_Q0.i32 = *v74;
          *(float *)_Q1.i32 = *(double *)_Q1.i64;
        }
        v75 += 4;
        ++v74;
      }
      while (v71 != v73);
    }
    else if (!v72)
    {
      goto LABEL_58;
    }
    free(v72);
LABEL_58:
    v10 = v126;
    if (v70)
      free(v70);
  }
  v94 = v125;
  v95 = RB::CGContext::printing_context(v125);
  v96 = v130;
  v97 = RB::cg_color_space((char *)*v130, !v95);
  v98 = CGGradientCreateWithColorComponents((CGColorSpaceRef)v97, v142, v139, v140);
  if (v10[2])
  {
    RB::CGContext::save(v94);
    v99 = *(CGContext **)v94;
    v100 = (_OWORD *)v10[2];
    v101 = v100[1];
    *(_OWORD *)&v135.a = *v100;
    *(_OWORD *)&v135.c = v101;
    *(_OWORD *)&v135.tx = v100[2];
    CGContextConcatCTM(v99, &v135);
  }
  switch(v10[6].i8[4])
  {
    case 0:
      v102 = (CGPoint)vcvtq_f64_f32(v10[3]);
      v103 = (CGPoint)vcvtq_f64_f32(v10[4]);
      y = v102.y;
      v105 = v103.y;
      CGContextDrawLinearGradient(*(CGContextRef *)v94, v98, v102, v103, 3u);
      break;
    case 1:
      v106 = (CGPoint)vcvtq_f64_f32(v10[3]);
      v107 = (CGPoint)vcvtq_f64_f32(v10[4]);
      v108 = v106.y;
      v109 = v107.y;
      CGContextDrawRadialGradient(*(CGContextRef *)v94, v98, v106, v10[5].f32[0], v107, v10[5].f32[1], 3u);
      break;
    case 2:
      v110 = v10[5].f32[0];
      goto LABEL_70;
    case 4:
      v111 = v10[5].f32[0];
      v110 = v10[5].f32[1];
      v112 = vabds_f32(v110, v111);
      if (v112 <= 6.2832)
      {
        if (v110 < v111)
          v111 = v10[5].f32[1];
        v110 = (float)(v111 + -3.1416) + (float)(v112 * 0.5);
      }
LABEL_70:
      v113 = v10[3];
      v114 = RB::CGContext::printing_context(v94);
      v115 = v110;
      v116 = (CGPoint)vcvtq_f64_f32(v113);
      if (v114)
      {
        v133 = v116;
        ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)v94);
        v117 = ClipBoundingBox.origin.y;
        height = ClipBoundingBox.size.height;
        *(float32x2_t *)v136.i8 = vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin);
        v136.u64[1] = (unint64_t)vcvt_f32_f64((float64x2_t)ClipBoundingBox.size);
        RB::CGContext::begin_bitmap((int8x8_t *)v94, (float32x2_t *)&v136, 0, 0, 0, 0, &v134);
        if (v134)
        {
          __asm { FMOV            V0.2S, #1.0 }
          RB::CGContext::CGContext(v145, v134, *v96, _D0);
          CGContextDrawConicGradient(*(CGContextRef *)&v145[0], v98, v133, v115);
          Image = CGBitmapContextCreateImage(*(CGContextRef *)&v145[0]);
          if (Image)
          {
            v148.origin.x = *(float *)v136.i32;
            v148.origin.y = *(float *)&v136.i32[1];
            v148.size.width = *(float *)&v136.i32[2];
            v148.size.height = *(float *)&v136.i32[3];
            CGContextDrawImage(*(CGContextRef *)v94, v148, Image);
            CFRelease(Image);
          }
          RB::CGContext::~CGContext((RB::CGContext *)v145);
          if (v134)
            CFRelease(v134);
        }
      }
      else
      {
        v121 = v116.y;
        CGContextDrawConicGradient(*(CGContextRef *)v94, v98, v116, v115);
      }
      break;
    default:
      break;
  }
  if (v10[2])
    RB::CGContext::restore(v94);
  if (v98)
    CFRelease(v98);
  if (v139)
    free(v139);
  if (v142)
    free(v142);
  if ((_DWORD)v11)
    goto LABEL_86;
}

void sub_209ACCCF8(_Unwind_Exception *a1)
{
  uint64_t v1;
  const void *v2;
  const void *v3;
  uint64_t v4;
  int v5;
  const void *v7;
  void *v8;
  void *v9;

  *(_DWORD *)(v1 + 20) = v5;
  *(_QWORD *)(v1 + 8) = v4;
  CFRelease(v3);
  RB::CGContext::~CGContext((RB::CGContext *)(v1 + 272));
  v7 = *(const void **)(v1 + 120);
  if (v7)
    CFRelease(v7);
  if (v2)
    CFRelease(v2);
  v8 = *(void **)(v1 + 224);
  if (v8)
    free(v8);
  v9 = *(void **)(v1 + 248);
  if (v9)
    free(v9);
  if (*(_DWORD *)(v1 + 20))
    free(*(void **)(v1 + 8));
  _Unwind_Resume(a1);
}

void RB::Fill::Color::convert(uint64_t a1, int a2, uint16x4_t a3)
{
  __int16 v3;
  RB::Shader::Tables *v5;
  double v6;

  v3 = a2;
  if (*(_BYTE *)(a1 + 9))
  {
    v5 = (RB::Shader::Tables *)*(unsigned __int8 *)(a1 + 8);
    if ((_DWORD)v5 == a2)
      return;
    a3.i32[0] = *(_DWORD *)a1;
    a3.i16[2] = *(_WORD *)(a1 + 4);
    v6 = RB::Fill::Color::convert_color(v5, a2, a3);
    *(_DWORD *)a1 = LODWORD(v6);
    *(_WORD *)(a1 + 4) = WORD2(v6);
  }
  *(_WORD *)(a1 + 8) = v3 | 0x100;
}

void RB::Fill::Color::mix(float16x4_t *a1, float16x4_t *a2, int a3, int8x16_t a4, int8x16_t a5, double a6, double a7, double a8, int8x16_t a9)
{
  *(float *)a5.i32 = 1.0 - *(float *)a4.i32;
  a5.i32[1] = a4.i32[0];
  a4.i64[0] = a5.i64[0];
  RB::Fill::Color::mix(a1, a2, a3, a4, a5, a6, a7, a8, a9);
}

void *RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,8ul>(void *a1, size_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(8 * a3);
    v6 = v5 >> 3;
    if (v5 >> 3 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::Path::Mapper::add_rounded_rect(__n128 *this, float64x2_t *a2, float64x2_t *a3, int a4, float64x2_t *a5, float64x2_t a6, float64_t a7, float64_t a8, float64_t a9)
{
  float64x2_t v11;
  float64x2_t v12;
  int64x2_t v13;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  float64x2_t v19;
  float v20;
  float v21;
  float v22;
  float v23;
  double v24;
  double v25;
  double v26;
  float v27;
  float v28;
  float v29;
  double v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float v48;
  float v49;
  float v50;
  float v51;
  double v52;
  double v53;
  double v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v65;
  float64x2_t v68;
  float64x2_t v70;
  float v72;
  float v73;
  float v74;
  double v75;
  double v76;
  double v77;
  float64x2_t v78;
  float64x2_t v79;
  float64x2_t v80;
  float64x2_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  float64x2_t v86;
  float64x2_t v87;
  float v88;
  float v89;
  float v90;
  double v91;
  double v92;
  double v93;
  float64x2_t v94;
  float64x2_t v95;
  float64x2_t v96;
  float64x2_t v97;
  float64x2_t v98;
  float64x2_t v99;
  float64x2_t v100;
  float64x2_t v101;
  float64x2_t v102;
  float64x2_t v103;
  float v104;
  float64x2_t v105;
  float64x2_t v106;
  float64x2_t v107;
  __n128 *v108;
  float64x2_t v110;
  float64x2_t v112;
  float64x2_t v115;
  float64x2_t v116;
  float64x2_t v117;
  float64x2_t v120;
  float64x2_t v123;
  float64x2_t v124;
  float64x2_t v125;
  float64x2_t v126;
  float64x2_t v127;
  float64x2_t v128;
  float64x2_t v129;
  float64x2_t v130;
  float v133;
  float v134;
  double v135;
  float v137;
  double v138;
  double v139;
  double v141;
  double v142;
  double v143;
  float64x2_t v144;
  double v145;
  float64x2_t v146;
  float64x2_t v147;
  double v148;
  float64x2_t v149;
  float64x2_t v150;

  v11 = *a3;
  v12 = a3[1];
  v13 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqzq_f64(*a3), (int8x16_t)vceqzq_f64(*a2)), vandq_s8((int8x16_t)vceqzq_f64(v12), (int8x16_t)vceqzq_f64(a2[1])));
  if ((vandq_s8((int8x16_t)v13, (int8x16_t)vdupq_laneq_s64(v13, 1)).u64[0] & 0x8000000000000000) != 0)
    return RB::Path::Mapper::add_rect(this, *(CGRect *)a6.f64, a5, 0);
  v144 = a2[1];
  v146 = *a2;
  a6.f64[1] = a7;
  v15.f64[0] = a8;
  v15.f64[1] = a9;
  v16 = vaddq_f64(a6, v15);
  v17 = vmaxnmq_f64(a6, v16);
  v149 = vminnmq_f64(a6, v16);
  v18 = a3->f64[1];
  v148 = v17.f64[1];
  v142 = v149.f64[1] + v11.f64[1];
  v138 = v17.f64[1] - v12.f64[0];
  v150 = v17;
  v19.f64[0] = v17.f64[0];
  v19.f64[1] = (v17.f64[1] - v12.f64[0] + v149.f64[1] + v11.f64[1]) * 0.5;
  v145 = a3->f64[0];
  v147 = a3[1];
  RB::Path::Mapper::elt_moveto(this, a5, v19);
  if ((a4 & 0xFFFFFFFD) == 9)
  {
    v135 = v18;
    v20 = v18;
    v21 = v147.f64[0];
    v22 = a9;
    v133 = fabsf(v22);
    v23 = (float)(v133 - (float)(v21 + v20)) / (float)((float)(v21 + v20) * 0.52866);
    v24 = 0.868407011;
    v25 = 1.08849001;
    v26 = 1.52866495;
    v143 = 1.52866495;
    v141 = 1.08849001;
    v139 = 0.868407011;
    if (v23 < 1.0)
    {
      v27 = 0.0;
      if (v23 >= 0.0)
        v27 = v23;
      if (v27 > 1.0)
        v27 = 1.0;
      v28 = (float)(v27 * 0.12849) + 0.96;
      v29 = (float)(v27 * 0.048407) + 0.82;
      v26 = (float)((float)(v27 * 0.52866) + 1.0);
      v25 = v28;
      v24 = v29;
    }
    v134 = v23;
    v30 = v148 - v26 * v147.f64[0];
    v31.f64[0] = v150.f64[0];
    v31.f64[1] = v30;
    RB::Path::Mapper::elt_lineto(this, a5, v31);
    v32.f64[0] = v150.f64[0];
    v32.f64[1] = v148 - v25 * v147.f64[0];
    v33.f64[0] = v150.f64[0];
    v33.f64[1] = v148 - v24 * v147.f64[0];
    _D9 = 0x3FB32D64C0000000;
    _D3 = v144.f64[0];
    __asm { FMLS            D2, D9, V3.D[0] }
    _D14 = 0x3FE43532E0000000;
    _Q2.f64[1] = v148 - v147.f64[0] * 0.631493986;
    RB::Path::Mapper::elt_cubeto(this, a5, v32, v33, _Q2);
    _D10 = 0x3FC5A3C220000000;
    _D3 = v144.f64[0];
    __asm { FMLS            D0, D10, V3.D[0] }
    _D11 = 0x3FD7DC5940000000;
    _Q0.f64[1] = v148 - v147.f64[0] * 0.372824013;
    __asm { FMLS            D1, D11, V3.D[0] }
    _Q1.f64[1] = v148 - v147.f64[0] * 0.169060007;
    __asm { FMLS            D2, D14, V3.D[0] }
    _Q2.f64[1] = v148 - v147.f64[0] * 0.0749114007;
    RB::Path::Mapper::elt_cubeto(this, a5, _Q0, _Q1, _Q2);
    v48 = v144.f64[0];
    v49 = v144.f64[1];
    v50 = a8;
    v137 = fabsf(v50);
    v51 = (float)(v137 - (float)(v49 + v48)) / (float)((float)(v49 + v48) * 0.52866);
    v52 = 1.52866495;
    v53 = 1.08849001;
    v54 = 0.868407011;
    if (v51 < 1.0)
    {
      if (v51 < 0.0)
        v51 = 0.0;
      if (v51 > 1.0)
        v51 = 1.0;
      v54 = (float)((float)(v51 * 0.048407) + 0.82);
      v53 = (float)((float)(v51 * 0.12849) + 0.96);
      v52 = (float)((float)(v51 * 0.52866) + 1.0);
    }
    v55.f64[1] = v150.f64[1];
    v55.f64[0] = v150.f64[0] - v54 * v144.f64[0];
    v56.f64[1] = v150.f64[1];
    v56.f64[0] = v150.f64[0] - v53 * v144.f64[0];
    v57.f64[1] = v150.f64[1];
    v57.f64[0] = v150.f64[0] - v52 * v144.f64[0];
    RB::Path::Mapper::elt_cubeto(this, a5, v55, v56, v57);
    v58.f64[1] = v150.f64[1];
    v58.f64[0] = v149.f64[0] + v52 * v144.f64[1];
    RB::Path::Mapper::elt_lineto(this, a5, v58);
    v59.f64[1] = v150.f64[1];
    v59.f64[0] = v149.f64[0] + v53 * v144.f64[1];
    v60.f64[1] = v150.f64[1];
    v60.f64[0] = v149.f64[0] + v54 * v144.f64[1];
    v61.f64[0] = v149.f64[0] + v144.f64[1] * 0.631493986;
    _D13 = v147.f64[1];
    _D9 = 0x3FB32D64C0000000;
    __asm { FMLS            D3, D9, V4.D[1] }
    v61.f64[1] = _D3;
    RB::Path::Mapper::elt_cubeto(this, a5, v59, v60, v61);
    v65.f64[0] = v149.f64[0] + v144.f64[1] * 0.372824013;
    _V5.D[1] = v147.f64[1];
    __asm { FMLS            D1, D10, V5.D[1] }
    v65.f64[1] = _D1;
    v68.f64[0] = v149.f64[0] + v144.f64[1] * 0.169060007;
    __asm { FMLS            D2, D11, V5.D[1] }
    v68.f64[1] = _D2;
    v70.f64[0] = v149.f64[0] + v144.f64[1] * 0.0749114007;
    __asm { FMLS            D3, D14, V5.D[1] }
    v70.f64[1] = _D3;
    RB::Path::Mapper::elt_cubeto(this, a5, v65, v68, v70);
    v72 = v147.f64[1];
    v73 = v145;
    v74 = (float)(v133 - (float)(v73 + v72)) / (float)((float)(v73 + v72) * 0.52866);
    v75 = 1.52866495;
    v76 = 1.08849001;
    v77 = 0.868407011;
    if (v74 < 1.0)
    {
      if (v74 < 0.0)
        v74 = 0.0;
      if (v74 > 1.0)
        v74 = 1.0;
      v77 = (float)((float)(v74 * 0.048407) + 0.82);
      v76 = (float)((float)(v74 * 0.12849) + 0.96);
      v75 = (float)((float)(v74 * 0.52866) + 1.0);
    }
    v78.f64[0] = v149.f64[0];
    v78.f64[1] = v148 - v77 * v147.f64[1];
    v79.f64[0] = v149.f64[0];
    v79.f64[1] = v148 - v76 * v147.f64[1];
    v80.f64[0] = v149.f64[0];
    v80.f64[1] = v148 - v75 * v147.f64[1];
    RB::Path::Mapper::elt_cubeto(this, a5, v78, v79, v80);
    v81.f64[0] = v149.f64[0];
    v81.f64[1] = v149.f64[1] + v75 * v145;
    RB::Path::Mapper::elt_lineto(this, a5, v81);
    v82.f64[0] = v149.f64[0];
    v82.f64[1] = v149.f64[1] + v76 * v145;
    v83.f64[0] = v149.f64[0];
    v83.f64[1] = v149.f64[1] + v77 * v145;
    v84.f64[0] = vmlad_n_f64(v149.f64[0], 0.0749114007, v146.f64[0]);
    v84.f64[1] = v149.f64[1] + v145 * 0.631493986;
    RB::Path::Mapper::elt_cubeto(this, a5, v82, v83, v84);
    v85.f64[0] = vmlad_n_f64(v149.f64[0], 0.169060007, v146.f64[0]);
    v85.f64[1] = v149.f64[1] + v145 * 0.372824013;
    v86.f64[0] = vmlad_n_f64(v149.f64[0], 0.372824013, v146.f64[0]);
    v86.f64[1] = v149.f64[1] + v145 * 0.169060007;
    v87.f64[0] = vmlad_n_f64(v149.f64[0], 0.631493986, v146.f64[0]);
    v87.f64[1] = v149.f64[1] + v145 * 0.0749114007;
    RB::Path::Mapper::elt_cubeto(this, a5, v85, v86, v87);
    v88 = v146.f64[0];
    v89 = v146.f64[1];
    v90 = (float)(v137 - (float)(v89 + v88)) / (float)((float)(v89 + v88) * 0.52866);
    v91 = 1.52866495;
    v92 = 1.08849001;
    v93 = 0.868407011;
    if (v90 < 1.0)
    {
      if (v90 < 0.0)
        v90 = 0.0;
      if (v90 > 1.0)
        v90 = 1.0;
      v93 = (float)((float)(v90 * 0.048407) + 0.82);
      v92 = (float)((float)(v90 * 0.12849) + 0.96);
      v91 = (float)((float)(v90 * 0.52866) + 1.0);
    }
    v94.f64[1] = v149.f64[1];
    v94.f64[0] = v149.f64[0] + v93 * v146.f64[0];
    v95.f64[1] = v149.f64[1];
    v95.f64[0] = v149.f64[0] + v92 * v146.f64[0];
    v96.f64[1] = v149.f64[1];
    v96.f64[0] = v149.f64[0] + v91 * v146.f64[0];
    RB::Path::Mapper::elt_cubeto(this, a5, v94, v95, v96);
    v97.f64[1] = v149.f64[1];
    v97.f64[0] = v150.f64[0] - v91 * v146.f64[1];
    RB::Path::Mapper::elt_lineto(this, a5, v97);
    v98.f64[1] = v149.f64[1];
    v99.f64[1] = v149.f64[1];
    v99.f64[0] = v150.f64[0] - v92 * v146.f64[1];
    v98.f64[0] = v150.f64[0] - v93 * v146.f64[1];
    v100 = v98;
    v98.f64[0] = v150.f64[0] - v146.f64[1] * 0.631493986;
    v98.f64[1] = v149.f64[1] + v135 * 0.0749114007;
    RB::Path::Mapper::elt_cubeto(this, a5, v99, v100, v98);
    v101.f64[0] = v150.f64[0] - v146.f64[1] * 0.372824013;
    v101.f64[1] = v149.f64[1] + v135 * 0.169060007;
    v102.f64[0] = v150.f64[0] - v146.f64[1] * 0.169060007;
    v102.f64[1] = v149.f64[1] + v135 * 0.372824013;
    v103.f64[0] = v150.f64[0] - v146.f64[1] * 0.0749114007;
    v103.f64[1] = v149.f64[1] + v135 * 0.631493986;
    RB::Path::Mapper::elt_cubeto(this, a5, v101, v102, v103);
    if (v134 < 1.0)
    {
      v104 = 0.0;
      if (v134 >= 0.0)
        v104 = v134;
      if (v104 > 1.0)
        v104 = 1.0;
      v139 = (float)((float)(v104 * 0.048407) + 0.82);
      v141 = (float)((float)(v104 * 0.12849) + 0.96);
      v143 = (float)((float)(v104 * 0.52866) + 1.0);
    }
    v107.f64[0] = v150.f64[0];
    v105.f64[0] = v150.f64[0];
    v105.f64[1] = v149.f64[1] + v139 * v135;
    v106.f64[0] = v150.f64[0];
    v106.f64[1] = v149.f64[1] + v141 * v135;
    v107.f64[1] = v149.f64[1] + v143 * v135;
    v108 = this;
  }
  else
  {
    v110.f64[0] = v150.f64[0];
    v110.f64[1] = v138;
    RB::Path::Mapper::elt_lineto(this, a5, v110);
    _D10 = 0x3FDCA75DDD61E2A2;
    v112.f64[0] = v150.f64[0];
    v112.f64[1] = v148 - v147.f64[0] * 0.44771525;
    _D3 = v144.f64[0];
    __asm { FMLS            D2, D10, V3.D[0] }
    v115.f64[1] = v150.f64[1];
    v115.f64[0] = _D2;
    v116.f64[1] = v150.f64[1];
    v116.f64[0] = v150.f64[0] - v144.f64[0];
    RB::Path::Mapper::elt_cubeto(this, a5, v112, v115, v116);
    v117.f64[1] = v150.f64[1];
    v117.f64[0] = v149.f64[0] + v144.f64[1];
    RB::Path::Mapper::elt_lineto(this, a5, v117);
    _V0.D[1] = v144.f64[1];
    __asm { FMLA            D1, D10, V0.D[1] }
    v120.f64[1] = v150.f64[1];
    v120.f64[0] = _D1;
    _D1 = v147.f64[1];
    __asm { FMLS            D2, D10, V5.D[1] }
    v123.f64[0] = v149.f64[0];
    v123.f64[1] = _D2;
    v124.f64[0] = v149.f64[0];
    v124.f64[1] = v148 - v147.f64[1];
    RB::Path::Mapper::elt_cubeto(this, a5, v120, v123, v124);
    v125.f64[0] = v149.f64[0];
    v125.f64[1] = v149.f64[1] + v145;
    RB::Path::Mapper::elt_lineto(this, a5, v125);
    v126.f64[0] = v149.f64[0];
    v126.f64[1] = vmlad_n_f64(v149.f64[1], 0.44771525, v145);
    v127.f64[1] = v149.f64[1];
    v127.f64[0] = vmlad_n_f64(v149.f64[0], 0.44771525, v146.f64[0]);
    v128.f64[1] = v149.f64[1];
    v128.f64[0] = v149.f64[0] + v146.f64[0];
    RB::Path::Mapper::elt_cubeto(this, a5, v126, v127, v128);
    v129.f64[1] = v149.f64[1];
    v129.f64[0] = v150.f64[0] - v146.f64[1];
    RB::Path::Mapper::elt_lineto(this, a5, v129);
    v130.f64[1] = v149.f64[1];
    v107.f64[0] = v150.f64[0];
    _V1.D[1] = v146.f64[1];
    __asm { FMLS            D0, D10, V1.D[1] }
    v130.f64[0] = _D0;
    v106.f64[0] = v150.f64[0];
    v106.f64[1] = v149.f64[1] + v18 * 0.44771525;
    v107.f64[1] = v142;
    v108 = this;
    v105 = v130;
  }
  RB::Path::Mapper::elt_cubeto(v108, a5, v105, v106, v107);
  return RB::Path::Mapper::elt_closepath((uint64_t)this);
}

BOOL RB::Path::Storage::apply_elements_(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, _BYTE *, __int128 *))
{
  unint64_t v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  char v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  float *v15;
  double *v16;
  uint64_t v17;
  float v18;
  double *v19;
  uint64_t v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unsigned int v25;
  _BYTE *v27;
  unint64_t v28;
  _BYTE *v29;
  uint64_t v30;
  __int128 *v31;
  float *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  uint64_t v36;
  _BYTE *v38;
  double *v39;
  float *v40;
  size_t v41;
  uint64_t i;
  uint64_t v43;
  float v44;
  uint64_t j;
  uint64_t v46;
  int v47;
  _BYTE __dst[64];
  unsigned __int8 v52;
  char v53;
  __int128 v54;
  __int128 v55;
  __int128 v56;
  _BYTE v57[32];
  void *v58;
  uint64_t v59;
  uint64_t v60;

  v4 = 0;
  v60 = *MEMORY[0x24BDAC8D0];
  v58 = 0;
  v59 = 0x400000000;
  v5 = (_QWORD *)(a1 + 16);
  while (2)
  {
    v6 = v4;
    v7 = *(unsigned int *)(a1 + 8);
    if ((v7 & 1) != 0)
      v8 = *(_QWORD *)(a1 + 24);
    else
      v8 = (v7 >> 8) & 0xFFF;
    if (v4 < v8)
    {
      v9 = v5;
      if ((v7 & 1) != 0)
        v9 = (_QWORD *)*v5;
      ++v4;
      v10 = *((_BYTE *)v9 + v6);
      v11 = v10 & 0x1F;
      if (v10 < 0)
      {
        v13 = 0;
        v12 = 1;
        switch(v10 & 0x1F)
        {
          case 0x10:
          case 0x12:
          case 0x16:
          case 0x17:
            goto LABEL_13;
          case 0x11:
          case 0x15:
            goto LABEL_10;
          case 0x13:
            v13 = 2;
            goto LABEL_13;
          case 0x14:
            v13 = 3;
            goto LABEL_13;
          case 0x18:
            v13 = 4;
            goto LABEL_13;
          default:
            if ((_DWORD)v11 == 4)
              goto LABEL_13;
            goto LABEL_10;
        }
      }
      v12 = 0;
LABEL_10:
      if (v11 >= 0x19)
      {
        v52 = v10 & 0x1F;
      }
      else
      {
        v13 = v12;
LABEL_13:
        v14 = __RBPathElementArgumentCount[v11];
        v52 = v10 & 0x1F;
        if (v14)
        {
          v15 = (float *)((char *)v9 + v4);
          if ((v10 & 0x40) != 0)
          {
            v16 = (double *)__dst;
            v17 = v14;
            do
            {
              v18 = *v15++;
              *v16++ = v18;
              --v17;
            }
            while (v17);
            v4 += 4 * v14;
          }
          else if ((v10 & 0x20) != 0)
          {
            v19 = (double *)__dst;
            v20 = v14;
            do
            {
              v21 = *(__int16 *)v15;
              v15 = (float *)((char *)v15 + 2);
              *v19++ = (double)v21;
              --v20;
            }
            while (v20);
            v4 += 2 * v14;
          }
          else
          {
            memcpy(__dst, v15, 8 * v14);
            v4 += 8 * v14;
          }
        }
        v12 = v13;
      }
      switch(v12)
      {
        case 0:
          v53 = 0;
          v22 = v52;
          goto LABEL_40;
        case 1:
          v32 = (float *)((char *)v9 + v4);
          if ((v10 & 0x40) != 0)
          {
            for (i = 0; i != 6; ++i)
              *((double *)&v54 + i) = v32[i];
            v35 = 24;
          }
          else if ((v10 & 0x20) != 0)
          {
            for (j = 0; j != 6; ++j)
              *((double *)&v54 + j) = (double)*((__int16 *)v32 + j);
            v35 = 12;
          }
          else
          {
            v33 = *(_OWORD *)v32;
            v34 = *((_OWORD *)v32 + 2);
            v55 = *((_OWORD *)v32 + 1);
            v56 = v34;
            v54 = v33;
            v35 = 48;
          }
          v24 = v4 + v35;
          goto LABEL_78;
        case 2:
          LODWORD(v54) = *((unsigned __int8 *)v9 + v4);
          DWORD1(v54) = *((unsigned __int8 *)v9 + v4 + 1);
          v36 = *(unsigned __int16 *)((char *)v9 + v4 + 2);
          v24 = v4 + 4;
          *((_QWORD *)&v54 + 1) = v36;
          if (v36)
          {
            if (v59 < v36 && HIDWORD(v59) < v36)
              RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(v57, v36);
            LODWORD(v59) = v36;
            v38 = v58;
            if (v58)
              v39 = (double *)v58;
            else
              v39 = (double *)v57;
            v40 = (float *)((char *)v9 + v24);
            if ((v10 & 0x40) != 0)
            {
              v43 = v36;
              do
              {
                v44 = *v40++;
                *v39++ = v44;
                --v43;
              }
              while (v43);
              v41 = 4 * v36;
            }
            else if ((v10 & 0x20) != 0)
            {
              v46 = v36;
              do
              {
                v47 = *(__int16 *)v40;
                v40 = (float *)((char *)v40 + 2);
                *v39++ = (double)v47;
                --v46;
              }
              while (v46);
              v41 = 2 * v36;
            }
            else
            {
              v41 = 8 * v36;
              memcpy(v39, v40, v41);
              v38 = v58;
            }
            v24 += v41;
            if (!v38)
              v38 = v57;
            *(_QWORD *)&v55 = v38;
          }
          goto LABEL_78;
        case 3:
          LOWORD(v54) = *(_WORD *)((char *)v9 + v4);
          v24 = v4 + 2;
          goto LABEL_78;
        case 4:
          LODWORD(v54) = *((unsigned __int8 *)v9 + v4);
          DWORD1(v54) = *((unsigned __int8 *)v9 + v4 + 1);
          v23 = *(unsigned __int16 *)((char *)v9 + v4 + 2);
          v24 = v4 + 4;
          *((_QWORD *)&v54 + 1) = v23;
          if (!v23)
            goto LABEL_78;
          v25 = 2 * v23;
          if (v59 >= 2 * (int)v23 || HIDWORD(v59) >= v25)
          {
            LODWORD(v59) = 2 * v23;
            v27 = v57;
            if (v58)
              v27 = v58;
            *(_QWORD *)&v55 = v27;
LABEL_36:
            v28 = 0;
            v29 = v27 + 4;
            do
            {
              *((_DWORD *)v29 - 1) = *((unsigned __int8 *)v9 + v4 + 4);
              v30 = *(_QWORD *)((char *)v9 + v4 + 5);
              *((_DWORD *)v29 + 2) = *(_DWORD *)((char *)v9 + v4 + 13);
              *(_QWORD *)v29 = v30;
              v29 += 16;
              ++v28;
              v4 += 13;
            }
            while (v28 < *((_QWORD *)&v54 + 1));
            v24 = v4 + 4;
            goto LABEL_78;
          }
          RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(v57, 2 * v23);
          LODWORD(v59) = v25;
          v27 = v58;
          if (!v58)
            v27 = v57;
          *(_QWORD *)&v55 = v27;
          if (*((_QWORD *)&v54 + 1))
            goto LABEL_36;
LABEL_78:
          v53 = 1;
          v22 = v52;
          v4 = v24;
LABEL_79:
          v31 = &v54;
LABEL_80:
          if ((a3(a2, v22, __dst, v31) & 1) == 0)
            break;
          continue;
        default:
          v22 = v52;
          if (v53)
            goto LABEL_79;
LABEL_40:
          v31 = 0;
          goto LABEL_80;
      }
    }
    break;
  }
  if (v58)
    free(v58);
  return v6 >= v8;
}

uint64_t RB::Path::Mapper::apply_callback(__n128 *this, int a2, uint64_t a3, float64x2_t *a4, float64x2_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  float64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  float64x2_t *v21;
  float64x2_t *v22;
  __int128 v23;
  __int128 v24;
  unint64_t v25;
  _OWORD v27[2];
  _OWORD v28[2];
  __int128 v29;
  __int128 v30;
  float64x2_t v31;
  __int128 v32;
  _OWORD v33[2];
  _OWORD v34[2];
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;

  v35 = v7;
  v36 = v6;
  v37 = v5;
  v38 = v8;
  v39 = v9;
  switch(a2)
  {
    case 0:
      RB::Path::Mapper::elt_moveto(this, a4, *(float64x2_t *)a3);
      break;
    case 1:
      RB::Path::Mapper::elt_lineto(this, a4, *(float64x2_t *)a3);
      break;
    case 2:
      RB::Path::Mapper::elt_quadto((uint64_t)this, a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16));
      break;
    case 3:
      RB::Path::Mapper::elt_cubeto(this, a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16), *(float64x2_t *)(a3 + 32));
      break;
    case 4:
      RB::Path::Mapper::elt_closepath((uint64_t)this);
      break;
    case 5:
    case 6:
      RB::Path::Mapper::add_rect(this, *(CGRect *)a3, a4, a2 == 5);
      break;
    case 7:
      RB::Path::Mapper::add_ellipse(this, *(CGRect *)a3, 0, (const CGAffineTransform *)a4);
      break;
    case 8:
    case 9:
      a5.f64[0] = *(float64_t *)a3;
      v13 = *(double *)(a3 + 8);
      v14 = *(double *)(a3 + 16);
      v15 = *(double *)(a3 + 24);
      v16 = *(double *)(a3 + 32);
      v17 = *(double *)(a3 + 40);
      v18 = fabs(v14);
      v19 = fabs(v15);
      if (v19 < v18)
        v18 = v19;
      v20 = v18 * 0.5;
      if (v16 < 0.0)
        v16 = 0.0;
      if (v16 > v20)
        v16 = v20;
      if (v17 < 0.0)
        v17 = 0.0;
      if (v17 > v20)
        v17 = v20;
      v34[0] = vdupq_lane_s64(*(uint64_t *)&v16, 0);
      v34[1] = v34[0];
      v33[0] = vdupq_lane_s64(*(uint64_t *)&v17, 0);
      v33[1] = v33[0];
      v21 = (float64x2_t *)v34;
      v22 = (float64x2_t *)v33;
      goto LABEL_15;
    case 10:
    case 11:
      v23 = *(_OWORD *)(a3 + 16);
      v31 = *(float64x2_t *)a3;
      v32 = v23;
      v24 = *(_OWORD *)(a3 + 48);
      v29 = *(_OWORD *)(a3 + 32);
      v30 = v24;
      RB::clamp_corner_radii((uint64_t)&v29, (double *)&v32);
      v13 = v31.f64[1];
      a5.f64[0] = v31.f64[0];
      v15 = *((double *)&v32 + 1);
      v14 = *(double *)&v32;
      v28[0] = v29;
      v28[1] = v30;
      v27[0] = v29;
      v27[1] = v30;
      v21 = (float64x2_t *)v28;
      v22 = (float64x2_t *)v27;
LABEL_15:
      RB::Path::Mapper::add_rounded_rect(this, v21, v22, a2, a4, a5, v13, v14, v15);
      break;
    case 12:
      RB::Path::Mapper::add_relative_arc(this, a4, *(float64x2_t *)a3, *(double *)(a3 + 16), *(double *)(a3 + 24), *(double *)(a3 + 32));
      break;
    case 13:
    case 14:
      RB::Path::Mapper::add_arc(this, a2 == 13, (CGAffineTransform *)a4, *(float64x2_t *)a3, *(double *)(a3 + 16), *(double *)(a3 + 24), *(double *)(a3 + 32));
      break;
    case 15:
      RB::Path::Mapper::add_arc_to_point(this, (int8x16_t *)a4, *(float64x2_t *)a3, *(float64x2_t *)(a3 + 16), *(double *)(a3 + 32));
      break;
    case 16:
      RB::Path::Mapper::pop((RB::Path::Mapper *)this);
      break;
    case 17:
      RB::Path::Mapper::push_affine((RB::Path::Mapper *)this, (const CGAffineTransform *)a4);
      break;
    case 18:
      RB::Path::Mapper::push_cut((RB::Path::Mapper *)this, *(double *)a3, *(double *)(a3 + 8));
      break;
    case 19:
      RB::Path::Mapper::push_stroke(this->n128_u64, (uint64_t)a4, *(double *)a3, *(double *)(a3 + 8), *(double *)(a3 + 16));
      break;
    case 20:
      RB::Path::Mapper::push_BOOLean(this->n128_u64, (char *)a4);
      break;
    case 21:
      v25 = this[20].n128_u64[1];
      if (v25)
        (***(void (****)(_QWORD))(v25 + 16))(*(_QWORD *)(v25 + 16));
      break;
    case 22:
      RB::Path::Mapper::push_dilate_glyph(this->n128_u64, *(__n128 *)a3);
      break;
    case 23:
      RB::Path::Mapper::push_offset((RB::Path::Mapper *)this, *(double *)a3);
      break;
    case 24:
      RB::Path::Mapper::push_clip_stroke(this->n128_u64, (unsigned int *)a4, *(double *)a3);
      break;
    default:
      return 1;
  }
  return 1;
}

uint64_t RB::Path::Mapper::elt_cubeto(__n128 *a1, float64x2_t *a2, float64x2_t a3, float64x2_t a4, float64x2_t a5)
{
  float64x2_t v5;
  __n128 *v6;
  float64x2_t *v7;
  float64x2_t v8;
  unint64_t v9;

  if (a2)
  {
    v5 = a2[1];
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a4.f64[0]), v5, a4, 1);
    a5 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a5.f64[0]), v5, a5, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), v5, a3, 1);
  }
  v6 = (__n128 *)a1[20].n128_u64[1];
  if (v6)
  {
    v6[2] = (__n128)a5;
    v6[4].n128_u8[0] = 0;
    v9 = v6[1].n128_u64[0];
  }
  else
  {
    a1[21] = (__n128)a5;
    a1[23].n128_u8[0] = 0;
    v7 = (float64x2_t *)a1[20].n128_u64[0];
    if (v7)
    {
      v8 = v7[1];
      a3 = vmlaq_laneq_f64(vmlaq_n_f64(v7[2], *v7, a3.f64[0]), v8, a3, 1);
      a4 = vmlaq_laneq_f64(vmlaq_n_f64(v7[2], *v7, a4.f64[0]), v8, a4, 1);
      a5 = vmlaq_laneq_f64(vmlaq_n_f64(v7[2], *v7, a5.f64[0]), v8, a5, 1);
    }
    v9 = a1[19].n128_u64[1];
  }
  return (*(uint64_t (**)(unint64_t, float64x2_t, float64x2_t, float64x2_t))(*(_QWORD *)v9 + 40))(v9, a3, a4, a5);
}

uint64_t RB::Path::Mapper::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  float64x2_t *v4;
  float64x2_t v5;

  *(float64x2_t *)(a1 + 336) = a4;
  *(_BYTE *)(a1 + 368) = 0;
  v4 = *(float64x2_t **)(a1 + 320);
  if (v4)
  {
    v5 = v4[1];
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a2.f64[0]), v5, a2, 1);
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v5, a3, 1);
    a4 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a4.f64[0]), v5, a4, 1);
  }
  return (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**(_QWORD **)(a1 + 312) + 40))(*(_QWORD *)(a1 + 312), (__n128)a2, (__n128)a3, (__n128)a4);
}

void RBPathCopyCGPath::Accumulator::cubeto(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  CGPathAddCurveToPoint(*(CGMutablePathRef *)(a1 + 8), 0, a2.n128_f64[0], a2.n128_f64[1], a3.n128_f64[0], a3.n128_f64[1], a4.n128_f64[0], a4.n128_f64[1]);
}

uint64_t RB::Path::Mapper::elt_lineto(__n128 *a1, float64x2_t *a2, float64x2_t a3)
{
  __n128 *v3;
  float64x2_t *v4;
  unint64_t v5;

  if (a2)
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), a2[1], a3, 1);
  v3 = (__n128 *)a1[20].n128_u64[1];
  if (v3)
  {
    v3[2] = (__n128)a3;
    v3[4].n128_u8[0] = 0;
    v5 = v3[1].n128_u64[0];
  }
  else
  {
    a1[21] = (__n128)a3;
    a1[23].n128_u8[0] = 0;
    v4 = (float64x2_t *)a1[20].n128_u64[0];
    if (v4)
      a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v4[1], a3, 1);
    v5 = a1[19].n128_u64[1];
  }
  return (*(uint64_t (**)(unint64_t, float64x2_t))(*(_QWORD *)v5 + 24))(v5, a3);
}

void RBPathCopyCGPath::Accumulator::lineto(uint64_t a1, __n128 a2)
{
  CGPathAddLineToPoint(*(CGMutablePathRef *)(a1 + 8), 0, a2.n128_f64[0], a2.n128_f64[1]);
}

float32x2_t RB::Path::BoundingRect::cubeto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  double v14;
  float32x2_t v15;
  uint32x2_t v16;
  float32x2_t result;
  float32x2_t v18;

  v10 = vcvt_f32_f64(a2);
  v11 = vcvt_f32_f64(a3);
  v12 = vcvt_f32_f64(a4);
  *(float32x2_t *)&a4.f64[0] = a1[3];
  v14 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&a4.f64[0], v12));
  v15 = vmaxnm_f32(*(float32x2_t *)&a4.f64[0], v12);
  *(int32x2_t *)a8.i8 = vcge_f32(v15, vmaxnm_f32(v10, v11));
  v16 = (uint32x2_t)vand_s8(*(int8x8_t *)a8.i8, (int8x8_t)vcge_f32(vminnm_f32(v10, v11), *(float32x2_t *)&v14));
  *(uint32x2_t *)a7.i8 = vpmin_u32(v16, v16);
  if ((a7.i32[0] & 0x80000000) == 0)
    v14 = RB::Path::cubic_bounds_slow(a1[3], v10, v11, v12, (int32x4_t)a4, a7, a8, a9);
  result = vminnm_f32(a1[1], *(float32x2_t *)&v14);
  v18 = vmaxnm_f32(a1[2], v15);
  a1[1] = result;
  a1[2] = v18;
  a1[3] = v12;
  return result;
}

uint64_t RB::Path::Mapper::elt_closepath(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  _BYTE *v3;

  v1 = *(_QWORD *)(this + 328);
  if (!v1)
  {
    v2 = this;
    if (*(_BYTE *)(this + 368))
      return this;
    v3 = (_BYTE *)(this + 368);
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(this + 312) + 8))(*(_QWORD *)(this + 312));
    *(_OWORD *)(v2 + 336) = *(_OWORD *)(v2 + 352);
    goto LABEL_4;
  }
  v3 = (_BYTE *)(v1 + 64);
  if (!*(_BYTE *)(v1 + 64))
  {
    *(_OWORD *)(v1 + 32) = *(_OWORD *)(v1 + 48);
    this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v1 + 16) + 8))(*(_QWORD *)(v1 + 16));
LABEL_4:
    *v3 = 1;
  }
  return this;
}

uint64_t RB::Path::Mapper::elt_moveto(__n128 *a1, float64x2_t *a2, float64x2_t a3)
{
  __n128 *v3;
  float64x2_t *v4;
  unint64_t v5;

  if (a2)
    a3 = vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, a3.f64[0]), a2[1], a3, 1);
  v3 = (__n128 *)a1[20].n128_u64[1];
  if (v3)
  {
    v3[2] = (__n128)a3;
    v3[4].n128_u8[0] = 0;
    v5 = v3[1].n128_u64[0];
  }
  else
  {
    a1[21] = (__n128)a3;
    a1[23].n128_u8[0] = 0;
    v4 = (float64x2_t *)a1[20].n128_u64[0];
    if (v4)
      a3 = vmlaq_laneq_f64(vmlaq_n_f64(v4[2], *v4, a3.f64[0]), v4[1], a3, 1);
    v5 = a1[19].n128_u64[1];
  }
  return (*(uint64_t (**)(unint64_t, float64x2_t))(*(_QWORD *)v5 + 16))(v5, a3);
}

void RBPathCopyCGPath::Accumulator::moveto(uint64_t a1, __n128 a2)
{
  CGPathMoveToPoint(*(CGMutablePathRef *)(a1 + 8), 0, a2.n128_f64[0], a2.n128_f64[1]);
}

void RBPathCopyCGPath::Accumulator::closepath(CGMutablePathRef *this)
{
  CGPathCloseSubpath(this[1]);
}

uint64_t RB::Path::AffineTransformer::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4)
{
  return (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a3.f64[0]), *(float64x2_t *)(a1 + 32), a3, 1), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a4.f64[0]), *(float64x2_t *)(a1 + 32), a4, 1));
}

float32x2_t RB::Path::BoundingRect::lineto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t result;
  float32x2_t v3;

  result = vcvt_f32_f64(a2);
  v3 = vmaxnm_f32(a1[2], result);
  a1[1] = vminnm_f32(a1[1], result);
  a1[2] = v3;
  a1[3] = result;
  return result;
}

uint64_t RB::Path::Mapper::lineto(uint64_t a1, float64x2_t a2)
{
  float64x2_t *v2;

  *(float64x2_t *)(a1 + 336) = a2;
  *(_BYTE *)(a1 + 368) = 0;
  v2 = *(float64x2_t **)(a1 + 320);
  if (v2)
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v2[2], *v2, a2.f64[0]), v2[1], a2, 1);
  return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 312) + 24))(*(_QWORD *)(a1 + 312), (__n128)a2);
}

uint64_t RB::Path::AffineTransformer::lineto(uint64_t a1, float64x2_t a2)
{
  return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1));
}

void RB::Stroke::FixedWidthLineBounds::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  RB::Stroke::LineBounds::cubeto(a1 + 16, vcvt_f32_f64(a2), vcvt_f32_f64(a3), vcvt_f32_f64(a4), *(float *)(a1 + 8), a6, a7, a8, a9);
}

void RB::Stroke::LineBounds::cubeto(uint64_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, float a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  float32x2_t v20;
  float32x2_t v21;
  uint32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;

  v14 = *(double *)(a1 + 24);
  v15 = COERCE_DOUBLE(vsub_f32(a2, *(float32x2_t *)&v14));
  v16 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&v15, *(float32x2_t *)&v15));
  if (vaddv_f32(*(float32x2_t *)&v16) < 0.00001)
  {
    v17 = COERCE_DOUBLE(vsub_f32(a3, *(float32x2_t *)&v14));
    v15 = COERCE_DOUBLE(vsub_f32(a4, *(float32x2_t *)&v14));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v17, *(float32x2_t *)&v17)) >= 0.00001)
      v15 = v17;
  }
  v18 = COERCE_DOUBLE(vsub_f32(a4, a3));
  if (vaddv_f32(vmul_f32(*(float32x2_t *)&v18, *(float32x2_t *)&v18)) < 0.00001)
  {
    v19 = COERCE_DOUBLE(vsub_f32(a4, a2));
    v16 = COERCE_DOUBLE(vsub_f32(a4, *(float32x2_t *)&v14));
    if (vaddv_f32(vmul_f32(*(float32x2_t *)&v19, *(float32x2_t *)&v19)) < 0.00001)
      v18 = v16;
    else
      v18 = v19;
  }
  if (*(_BYTE *)(a1 + 64))
  {
    *(double *)(a1 + 40) = v15;
    *(_BYTE *)(a1 + 64) = 0;
  }
  else
  {
    LODWORD(v16) = *(_DWORD *)(a1 + 56);
    RB::Stroke::LineBounds::add_join((float32x2_t *)a1, *(float32x2_t *)&v14, v16, *(float32x2_t *)(a1 + 48), *(float32x2_t *)&v15);
    v14 = *(double *)(a1 + 24);
  }
  v20 = vminnm_f32(*(float32x2_t *)&v14, a4);
  v21 = vmaxnm_f32(*(float32x2_t *)&v14, a4);
  *(int32x2_t *)a6.i8 = vcge_f32(v21, vmaxnm_f32(a2, a3));
  v22 = (uint32x2_t)vand_s8(*(int8x8_t *)a6.i8, (int8x8_t)vcge_f32(vminnm_f32(a2, a3), v20));
  if ((vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0)
  {
    v14 = RB::Path::cubic_bounds_slow(*(float32x2_t *)&v14, a2, a3, a4, a6, a7, a8, a9);
    v20 = *(float32x2_t *)&v14;
  }
  LODWORD(v14) = *(_DWORD *)(a1 + 56);
  if (*(float *)&v14 < a5)
    *(float *)&v14 = a5;
  v23 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v14, 0);
  v24 = vminnm_f32(*(float32x2_t *)(a1 + 8), vsub_f32(v20, v23));
  v25 = vmaxnm_f32(*(float32x2_t *)(a1 + 16), vadd_f32(v23, v21));
  *(float32x2_t *)(a1 + 8) = v24;
  *(float32x2_t *)(a1 + 16) = v25;
  *(double *)(a1 + 24) = *(double *)&a4;
  *(float *)(a1 + 56) = a5;
  *(double *)(a1 + 48) = v18;
  v26 = *(float *)(a1 + 68);
  if (v26 < a5)
    v26 = a5;
  *(float *)(a1 + 68) = v26;
}

float32x2_t *RB::Stroke::LineBounds::add_join(float32x2_t *result, float32x2_t a2, double a3, float32x2_t a4, float32x2_t a5)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  int32x2_t v12;
  int32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float v34;
  float v35;
  float v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;
  float32x2_t v41;
  float32x2_t v42;
  int32x2_t v43;
  int32x2_t v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  float32x2_t v51;

  if (!result->i8[1])
  {
    v26 = vmul_f32(a4, a4);
    v26.i32[0] = vadd_f32(v26, (float32x2_t)vdup_lane_s32((int32x2_t)v26, 1)).u32[0];
    v27 = vrsqrte_f32((float32x2_t)v26.u32[0]);
    v28 = vmul_f32(vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v27, v27)), v27);
    v29 = vmul_n_f32(a4, vmul_f32(v28, vrsqrts_f32((float32x2_t)v26.u32[0], vmul_f32(v28, v28))).f32[0]);
    v30 = vmul_f32(a5, a5);
    v30.i32[0] = vadd_f32(v30, (float32x2_t)vdup_lane_s32((int32x2_t)v30, 1)).u32[0];
    v31 = vrsqrte_f32((float32x2_t)v30.u32[0]);
    v32 = vmul_f32(vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v31, v31)), v31);
    v33 = vmul_n_f32(a5, vmul_f32(v32, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v32, v32))).f32[0]);
    v34 = vaddv_f32(vmul_f32(v33, v29));
    if (v34 < 0.99 && fabsf(v34) > 0.00001)
    {
      v35 = v34 + 1.0;
      if ((float)(result->f32[1] * v35) >= 2.0)
      {
        v36 = v35;
        v37 = vrsqrte_f32((float32x2_t)LODWORD(v35));
        v38 = vmul_f32(vrsqrts_f32((float32x2_t)LODWORD(v36), vmul_f32(v37, v37)), v37);
        v38.f32[0] = vmul_f32(v38, vrsqrts_f32((float32x2_t)LODWORD(v36), vmul_f32(v38, v38))).f32[0];
        v39 = vadd_f32(v33, v29);
        v40 = vmul_f32(v39, v39);
        v40.i32[0] = vadd_f32(v40, (float32x2_t)vdup_lane_s32((int32x2_t)v40, 1)).u32[0];
        v41 = vrsqrte_f32((float32x2_t)v40.u32[0]);
        v42 = vmul_f32(vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v41, v41)), v41);
        v43 = (int32x2_t)vmul_f32(v42, vrsqrts_f32((float32x2_t)v40.u32[0], vmul_f32(v42, v42)));
        v44 = (int32x2_t)vmul_n_f32(v39, *(float *)v43.i32);
        *(float *)v43.i32 = -*(float *)&v44.i32[1];
        v45 = vmul_n_f32((float32x2_t)vzip1_s32(v43, v44), (float)(*(float *)&a3 * 1.4142) * v38.f32[0]);
        v46 = vsub_f32(a2, v45);
        v47 = vadd_f32(v45, a2);
        v48 = vminnm_f32(result[1], vminnm_f32(v46, v47));
        v49 = vmaxnm_f32(result[2], vmaxnm_f32(v46, v47));
        result[1] = v48;
        result[2] = v49;
      }
    }
    goto LABEL_8;
  }
  if (result->i8[1] != 2)
  {
LABEL_8:
    v50 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0);
    v51 = vminnm_f32(result[1], vsub_f32(a2, v50));
    v25 = vmaxnm_f32(result[2], vadd_f32(v50, a2));
    result[1] = v51;
    goto LABEL_9;
  }
  v5 = vmul_f32(a4, a4);
  v5.i32[0] = vadd_f32(v5, (float32x2_t)vdup_lane_s32((int32x2_t)v5, 1)).u32[0];
  v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  v7 = vmul_f32(vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)), v6);
  v5.i32[0] = vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).u32[0];
  v8 = vmul_f32(a5, a5);
  v9 = (int32x2_t)vmul_n_f32(a4, v5.f32[0]);
  v5.i32[0] = vadd_f32(v8, (float32x2_t)vdup_lane_s32((int32x2_t)v8, 1)).u32[0];
  v10 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  v11 = vmul_f32(vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v10, v10)), v10);
  v12 = (int32x2_t)vmul_f32(v11, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v11, v11)));
  v13 = (int32x2_t)vmul_n_f32(a5, *(float *)v12.i32);
  *(float *)v12.i32 = -*(float *)&v9.i32[1];
  v14 = vmul_n_f32((float32x2_t)vzip1_s32(v12, v9), *(float *)&a3);
  v15 = vsub_f32(a2, v14);
  v16 = vminnm_f32(result[1], v15);
  v17 = vmaxnm_f32(result[2], v15);
  v18 = vadd_f32(v14, a2);
  v19 = vminnm_f32(v16, v18);
  v20 = vmaxnm_f32(v17, v18);
  v17.f32[0] = -*(float *)&v13.i32[1];
  v21 = vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)v17, v13), *(float *)&a3);
  v22 = vsub_f32(a2, v21);
  v23 = vadd_f32(v21, a2);
  v24 = vminnm_f32(vminnm_f32(v19, v22), v23);
  v25 = vmaxnm_f32(vmaxnm_f32(v20, v22), v23);
  result[1] = v24;
LABEL_9:
  result[2] = v25;
  return result;
}

void *RBPathGetNestedPath(RBPath a1)
{
  void *info;
  uint64_t (*v2)(void *);

  info = a1.info;
  if ((*((_BYTE *)a1.callbacks + 2) & 1) != 0)
  {
    v2 = (uint64_t (*)(void *))*((_QWORD *)a1.callbacks + 10);
    if (v2)
      return (void *)v2(a1.info);
LABEL_5:
    RB::Path::NestedCallbacks::get((RB::Path::NestedCallbacks *)a1.callbacks, (const RBPathCallbacks *)1);
    return info;
  }
  v2 = (uint64_t (*)(void *))*((_QWORD *)a1.callbacks + 10);
  if (!v2)
    goto LABEL_5;
  return (void *)v2(a1.info);
}

double RB::Path::cubic_bounds_slow(float32x2_t a1, float32x2_t a2, float32x2_t a3, float32x2_t a4, int32x4_t a5, int32x4_t a6, int32x4_t a7, int32x4_t a8)
{
  int8x16_t v8;
  int32x4_t v9;
  float32x2_t v15;
  float32x2_t v17;
  float32x2_t v19;
  float32x2_t v20;
  int8x8_t v21;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  int8x16_t v26;
  int8x16_t v27;
  float32x2_t v28;
  int8x16_t v29;
  float32x2_t v30;
  float32x2_t v32;

  __asm { FMOV            V4.2S, #-3.0 }
  *(float32x2_t *)a8.i8 = vmla_f32(vsub_f32(a4, vmla_f32(a1, _D4, a2)), _D4, a3);
  v15 = vadd_f32(vsub_f32(a1, vadd_f32(a2, a2)), a3);
  *(float32x2_t *)v8.i8 = vadd_f32(v15, v15);
  *(float32x2_t *)a5.i8 = vsub_f32(a2, a1);
  __asm { FMOV            V5.2S, #-4.0 }
  v17 = vmla_f32(vmul_f32(vmul_f32(*(float32x2_t *)a5.i8, _D5), *(float32x2_t *)a8.i8), *(float32x2_t *)v8.i8, *(float32x2_t *)v8.i8);
  *(int32x2_t *)a6.i8 = vcltz_f32(v17);
  if ((vpmin_u32(*(uint32x2_t *)a6.i8, *(uint32x2_t *)a6.i8).u32[0] & 0x80000000) != 0)
  {
    *(float32x2_t *)a5.i8 = vminnm_f32(a1, a4);
  }
  else
  {
    __asm { FMOV            V6.2S, #1.0 }
    *(float32x2_t *)v8.i8 = vmul_f32(vmla_f32(*(float32x2_t *)v8.i8, (float32x2_t)vorr_s8(vand_s8(*(int8x8_t *)v8.i8, (int8x8_t)0x8000000080000000), (int8x8_t)_D6), vsqrt_f32(v17)), (float32x2_t)0xBF000000BF000000);
    v19 = vrecpe_f32(*(float32x2_t *)a8.i8);
    v20 = vmul_f32(vrecps_f32(*(float32x2_t *)a8.i8, v19), v19);
    v21 = (int8x8_t)vmul_f32(vmul_f32(vrecps_f32(*(float32x2_t *)a8.i8, v20), *(float32x2_t *)v8.i8), v20);
    *(int8x8_t *)a8.i8 = vorr_s8(*(int8x8_t *)a6.i8, (int8x8_t)vceqz_f32(*(float32x2_t *)a8.i8));
    __asm { FMOV            V18.2S, #-1.0 }
    v23 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a8), _D18, v21);
    v24 = vrecpe_f32(*(float32x2_t *)v8.i8);
    v25 = vmul_f32(vrecps_f32(*(float32x2_t *)v8.i8, v24), v24);
    *(int8x8_t *)a6.i8 = vorr_s8((int8x8_t)vceqz_f32(*(float32x2_t *)v8.i8), *(int8x8_t *)a6.i8);
    v26 = (int8x16_t)vcltzq_s32(a6);
    *(int8x8_t *)a5.i8 = vbsl_s8(*(int8x8_t *)v26.i8, _D18, (int8x8_t)vmul_f32(vrecps_f32(*(float32x2_t *)v8.i8, v25), vmul_f32(*(float32x2_t *)a5.i8, v25)));
    *(float32x2_t *)v26.i8 = vminnm_f32(v23, *(float32x2_t *)a5.i8);
    *(float32x2_t *)v8.i8 = vmaxnm_f32(v23, *(float32x2_t *)a5.i8);
    *(int32x2_t *)a8.i8 = vdup_n_s32(0x358637BDu);
    *(int32x2_t *)a5.i8 = vcgt_f32(*(float32x2_t *)a8.i8, *(float32x2_t *)v26.i8);
    v27 = (int8x16_t)vcltzq_s32(a5);
    v28 = (float32x2_t)vbslq_s8(v27, v8, v26).u64[0];
    *(float32x2_t *)a5.i8 = vminnm_f32(a1, a4);
    *(int8x8_t *)v9.i8 = vand_s8((int8x8_t)vcgt_f32(v28, *(float32x2_t *)a8.i8), (int8x8_t)vcgt_f32((float32x2_t)vdup_n_s32(0x3F7FFFEFu), v28));
    if ((vpmax_u32(*(uint32x2_t *)v9.i8, *(uint32x2_t *)v9.i8).u32[0] & 0x80000000) != 0)
    {
      v29.i64[0] = 0x4000000040000000;
      v29.i64[1] = 0x4000000040000000;
      v30 = (float32x2_t)vbslq_s8(v27, v29, v8).u64[0];
      *(float32x2_t *)v29.i8 = vsub_f32(_D6, v28);
      __asm { FMOV            V17.2S, #3.0 }
      *(float32x2_t *)v29.i8 = vminnm_f32(*(float32x2_t *)a5.i8, vmla_f32(vmul_f32(vmul_f32(v28, a4), vmul_f32(v28, v28)), *(float32x2_t *)v29.i8, vmla_f32(vmul_f32(vmul_f32(*(float32x2_t *)v29.i8, *(float32x2_t *)v29.i8), a1), vmla_f32(vmul_f32(v28, a3), a2, *(float32x2_t *)v29.i8), vmul_f32(v28, _D17))));
      a5.i64[0] = vbslq_s8((int8x16_t)vcltzq_s32(v9), v29, (int8x16_t)a5).u64[0];
      v32 = vsub_f32(_D6, v30);
      *(int32x2_t *)a7.i8 = vcgt_f32(v32, *(float32x2_t *)a8.i8);
      if ((vpmax_u32(*(uint32x2_t *)a7.i8, *(uint32x2_t *)a7.i8).u32[0] & 0x80000000) != 0)
        *(int8x8_t *)a5.i8 = vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a7), (int8x8_t)vminnm_f32(*(float32x2_t *)a5.i8, vmla_f32(vmul_f32(vmul_f32(v30, a4), vmul_f32(v30, v30)), v32, vmla_f32(vmul_f32(vmul_f32(v32, v32), a1), vmla_f32(vmul_f32(v30, a3), a2, v32), vmul_f32(v30, _D17)))), *(int8x8_t *)a5.i8);
    }
  }
  return *(double *)a5.i64;
}

float32x2_t RB::Path::BoundingRect::moveto(float32x2_t *a1, float64x2_t a2)
{
  float32x2_t result;
  float32x2_t v3;

  result = vcvt_f32_f64(a2);
  v3 = vmaxnm_f32(a1[2], result);
  a1[1] = vminnm_f32(a1[1], result);
  a1[2] = v3;
  a1[3] = result;
  return result;
}

float32x2_t *RB::Stroke::LineBounds::lineto(float32x2_t *result, float32x2_t a2, double a3)
{
  float v3;
  float32x2_t *v5;
  float32x2_t v6;
  float32x2_t v7;
  float v8;

  v3 = *(float *)&a3;
  v5 = result;
  v6 = result[3];
  v7 = vsub_f32(a2, v6);
  if (result[8].i8[0])
  {
    result[5] = v7;
    result[8].i8[0] = 0;
  }
  else
  {
    LODWORD(a3) = result[7].i32[0];
    result = RB::Stroke::LineBounds::add_join(result, v6, a3, result[6], v7);
  }
  v5[3] = a2;
  v5[7].f32[0] = v3;
  v5[6] = v7;
  v8 = v5[8].f32[1];
  if (v8 < v3)
    v8 = v3;
  v5[8].f32[1] = v8;
  return result;
}

float32x2_t *RB::Stroke::FixedWidthLineBounds::lineto(float32x2_t *a1, float64x2_t a2, double a3)
{
  LODWORD(a3) = a1[1].i32[0];
  return RB::Stroke::LineBounds::lineto(a1 + 2, vcvt_f32_f64(a2), a3);
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#5}::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

__n128 RB::Path::Mapper::closepath(RB::Path::Mapper *this)
{
  __n128 result;

  if (!*((_BYTE *)this + 368))
  {
    (*(void (**)(_QWORD))(**((_QWORD **)this + 39) + 8))(*((_QWORD *)this + 39));
    result = *((__n128 *)this + 22);
    *((__n128 *)this + 21) = result;
    *((_BYTE *)this + 368) = 1;
  }
  return result;
}

uint64_t RB::Path::Mapper::moveto(uint64_t a1, float64x2_t a2)
{
  float64x2_t *v2;

  *(float64x2_t *)(a1 + 336) = a2;
  *(_BYTE *)(a1 + 368) = 0;
  v2 = *(float64x2_t **)(a1 + 320);
  if (v2)
    a2 = vmlaq_laneq_f64(vmlaq_n_f64(v2[2], *v2, a2.f64[0]), v2[1], a2, 1);
  return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 312) + 16))(*(_QWORD *)(a1 + 312), (__n128)a2);
}

uint64_t RB::Path::AffineTransformer::closepath(RB::Path::AffineTransformer *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 1) + 8))(*((_QWORD *)this + 1));
}

uint64_t RB::Path::AffineTransformer::moveto(uint64_t a1, float64x2_t a2)
{
  return (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), (__n128)vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 48), *(float64x2_t *)(a1 + 16), a2.f64[0]), *(float64x2_t *)(a1 + 32), a2, 1));
}

uint64_t RB::Path::NestedCallbacks::get(RB::Path::NestedCallbacks *this, const RBPathCallbacks *a2)
{
  unsigned __int8 v4;
  os_unfair_lock_s *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  RB::Path::NestedCallbacks **v10;
  char v11;
  const RBPathCallbacks *v12;
  BOOL v13;
  _QWORD *v14;
  uint64_t v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  BOOL v21;
  unint64_t v22;
  _QWORD *v23;
  uint64_t v25;

  if ((v4 & 1) == 0
  {
    v25 = operator new();
    *(_QWORD *)(v25 + 8) = 0;
    *(_QWORD *)(v25 + 16) = 0;
    *(_QWORD *)v25 = 0;
    *(_DWORD *)(v25 + 24) = 0;
    RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table = v25;
  }
  v5 = (os_unfair_lock_s *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24);
  os_unfair_lock_lock((os_unfair_lock_t)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24));
  v6 = *(_QWORD *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table;
  v7 = *(_QWORD *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 8);
  v8 = *(_QWORD *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 24 * v7;
  if (v7)
  {
    do
    {
      v9 = v7 >> 1;
      v10 = (RB::Path::NestedCallbacks **)(v6 + 24 * (v7 >> 1));
      if (*v10 >= this)
        v11 = 1;
      else
        v11 = -1;
      if (*v10 == this)
      {
        v12 = (const RBPathCallbacks *)v10[1];
        v13 = v12 == a2;
        v11 = v12 >= a2 ? 1 : -1;
        if (v13)
          v11 = 0;
      }
      v14 = v10 + 3;
      v7 += ~v9;
      if (v11 < 0)
        v6 = (uint64_t)v14;
      else
        v7 = v9;
    }
    while (v7);
    if (v6 != v8)
    {
      if (*(RB::Path::NestedCallbacks **)v6 == this && *(_QWORD *)(v6 + 8) == (_QWORD)a2)
      {
        v16 = *(_QWORD *)(v6 + 16);
        goto LABEL_28;
      }
      v8 = v6;
    }
  }
  v16 = operator new();
  *(_QWORD *)(v16 + 96) = a2;
  *(_OWORD *)v16 = 0u;
  *(_OWORD *)(v16 + 16) = 0u;
  *(_OWORD *)(v16 + 48) = 0u;
  *(_OWORD *)(v16 + 64) = 0u;
  *(_OWORD *)(v16 + 32) = 0u;
  *(_DWORD *)v16 = 0x10000;
  *(_OWORD *)(v16 + 8) = *(_OWORD *)((char *)this + 8);
  *(_QWORD *)(v16 + 24) = RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_0::__invoke;
  *(_QWORD *)(v16 + 48) = RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_1::__invoke;
  *(_QWORD *)(v16 + 56) = RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_2::__invoke;
  *(_QWORD *)(v16 + 80) = RB::Path::NestedCallbacks::NestedCallbacks(RBPathCallbacks const*,unsigned long)::$_3::__invoke;
  *(_QWORD *)(v16 + 88) = this;
  v17 = (uint64_t *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table;
  v19 = *(_QWORD *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table;
  v18 = *(_QWORD *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 8);
  v20 = 0xAAAAAAAAAAAAAAABLL
      * ((v8 - *(_QWORD *)RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table) >> 3);
  if (*(_QWORD *)(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table + 16) < v18 + 1)
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow(RB::Path::NestedCallbacks::get(RBPathCallbacks const*,unsigned long)::table, v18 + 1);
    v19 = *v17;
    v18 = v17[1];
  }
  v21 = v18 > v20;
  v22 = v18 - v20;
  if (v21)
    memmove((void *)(v19 + 24 * v20 + 24), (const void *)(v19 + 24 * v20), 24 * v22);
  v23 = (_QWORD *)(v19 + 24 * v20);
  *v23 = this;
  v23[1] = a2;
  v23[2] = v16;
  ++v17[1];
LABEL_28:
  os_unfair_lock_unlock(v5);
  return v16;
}

void RB::Path::Mapper::pop(RB::Path::Mapper *this)
{
  RB::Path::Mapper::StackItem *v1;
  void (***v3)(_QWORD);

  v1 = (RB::Path::Mapper::StackItem *)*((_QWORD *)this + 41);
  if (v1)
  {
    v3 = (void (***)(_QWORD))*((_QWORD *)v1 + 2);
    *((_QWORD *)this + 41) = *((_QWORD *)v1 + 1);
    (**v3)(v3);
    RB::Path::Mapper::StackItem::~StackItem(v1);
    *(_QWORD *)v1 = *((_QWORD *)this + 38);
    *((_QWORD *)this + 38) = v1;
  }
}

void RB::Path::Mapper::StackItem::~StackItem(RB::Path::Mapper::StackItem *this)
{
  RB::Path::BooleanTransform *v1;
  unsigned int v2;
  RB::Path::BooleanTransform *v3;
  void *v4;
  void *v5;
  RB::Path::BooleanTransform *v6;
  void *v7;
  RB::Path::BooleanTransform *v8;
  void *v9;
  void *v10;
  RB::Path::BooleanTransform *v11;
  const void *v12;
  const void *v13;
  unsigned int v14;
  RB::Path::BooleanTransform *v15;
  void *v16;
  void *v17;
  uint64_t v18;
  RB::Path::BooleanTransform *v19;
  void *v20;

  switch(*((_BYTE *)this + 65))
  {
    case 0:
      v1 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v1)
      {
        v2 = -221838953;
        goto LABEL_34;
      }
      break;
    case 1:
      v3 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v3)
      {
        *(_QWORD *)v3 = &unk_24C229508;
        v4 = (void *)*((_QWORD *)v3 + 532);
        if (v4)
          free(v4);
        v5 = (void *)*((_QWORD *)v3 + 17);
        if (v5)
          free(v5);
        v1 = v3;
        v2 = -733151764;
        goto LABEL_34;
      }
      break;
    case 2:
      v1 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v1)
      {
        v2 = 1875108758;
        goto LABEL_34;
      }
      break;
    case 3:
      v6 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v6)
      {
        v7 = (void *)*((_QWORD *)v6 + 28);
        if (v7)
          free(v7);
        v1 = v6;
        v2 = 548042431;
        goto LABEL_34;
      }
      break;
    case 4:
      v8 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v8)
      {
        v9 = (void *)*((_QWORD *)v8 + 38);
        if (v9)
          free(v9);
        v10 = (void *)*((_QWORD *)v8 + 29);
        if (v10)
          free(v10);
        v1 = v8;
        v2 = -986321111;
        goto LABEL_34;
      }
      break;
    case 5:
      v11 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      RB::Path::BooleanTransform::commit(v11);
      if (v11)
      {
        v12 = (const void *)*((_QWORD *)v11 + 4);
        if (v12)
          CFRelease(v12);
        *(_QWORD *)v11 = &unk_24C229448;
        v13 = (const void *)*((_QWORD *)v11 + 1);
        if (v13)
          CFRelease(v13);
        v1 = v11;
        v14 = -217717331;
        goto LABEL_39;
      }
      break;
    case 6:
      v15 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v15)
      {
        *(_QWORD *)v15 = &unk_24C229508;
        v16 = (void *)*((_QWORD *)v15 + 532);
        if (v16)
          free(v16);
        v17 = (void *)*((_QWORD *)v15 + 17);
        if (v17)
          free(v17);
        v1 = v15;
        v2 = -18588592;
LABEL_34:
        v18 = v2 | 0x10A1C4000000000;
        goto LABEL_40;
      }
      break;
    case 7:
      v19 = (RB::Path::BooleanTransform *)*((_QWORD *)this + 2);
      if (v19)
      {
        v20 = (void *)*((_QWORD *)v19 + 43);
        if (v20)
          free(v20);
        v1 = v19;
        v14 = 590185972;
LABEL_39:
        v18 = v14 | 0x10E1C4000000000;
LABEL_40:
        MEMORY[0x20BD16544](v1, v18);
      }
      break;
    default:
      return;
  }
}

double RB::Path::Mapper::push_affine(RB::Path::Mapper *this, const CGAffineTransform *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  RB::Path::Mapper *v7;
  const CGAffineTransform *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  unint64_t v12;
  double result;

  v4 = operator new();
  v5 = v4;
  v6 = *((_QWORD *)this + 41);
  if (v6)
    v7 = (RB::Path::Mapper *)*((_QWORD *)this + 41);
  else
    v7 = this;
  v8 = (const CGAffineTransform *)MEMORY[0x24BDBD8B8];
  if (a2)
    v8 = a2;
  v9 = *(_OWORD *)&v8->a;
  v10 = *(_OWORD *)&v8->c;
  v11 = *(_OWORD *)&v8->tx;
  *(_QWORD *)v4 = &unk_24C2294C8;
  *(_QWORD *)(v4 + 8) = v7;
  *(_OWORD *)(v4 + 16) = v9;
  *(_OWORD *)(v4 + 32) = v10;
  *(_OWORD *)(v4 + 48) = v11;
  v12 = *((_QWORD *)this + 38);
  if (v12)
  {
    *((_QWORD *)this + 38) = *(_QWORD *)v12;
  }
  else
  {
    v12 = (*((_QWORD *)this + 3) + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v12 + 80 > *((_QWORD *)this + 4))
    {
      v12 = RB::Heap::alloc_slow((size_t *)this + 1, 0x50uLL, 15);
      v6 = *((_QWORD *)this + 41);
    }
    else
    {
      *((_QWORD *)this + 3) = v12 + 80;
    }
  }
  *(_QWORD *)v12 = off_24C229588;
  *(_QWORD *)(v12 + 8) = v6;
  *(_QWORD *)(v12 + 16) = v5;
  result = 0.0;
  *(_OWORD *)(v12 + 32) = 0u;
  *(_OWORD *)(v12 + 48) = 0u;
  *(_WORD *)(v12 + 64) = 1;
  *((_QWORD *)this + 41) = v12;
  return result;
}

void RB::Coverage::`anonymous namespace'::simplify_shape_callback(void (****a1)(uint64_t (***)(_QWORD, uint64_t *), uint64_t *), int a2, uint64_t a3)
{
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _BOOL4 v11;
  uint64_t (***v14)(_QWORD, uint64_t *);
  float64x2_t *v15;
  char v16;
  float v17;
  float64x2_t *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  _BOOL4 v24;
  float v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  _BOOL4 v33;
  float v36;
  char v37;
  __int128 v38;
  __int128 v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  double v43;
  __int128 v44;
  __int128 v45;
  double v46;
  double v47;
  BOOL v48;
  double v49;
  double v50;
  float v51;
  void (***v52)(_QWORD, float64x2_t *);
  float64x2_t v53;
  __int128 v54;
  __int128 v55;

  switch(a2)
  {
    case 0:
    case 1:
      v6 = *(_OWORD *)(a3 + 16);
      v7 = *(_OWORD *)(a3 + 32);
      v53 = *(float64x2_t *)a3;
      v54 = v6;
      v55 = v7;
      *(double *)&v8 = RB::operator*(&v53, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v8;
      *((_OWORD *)a1 + 2) = v9;
      *((_OWORD *)a1 + 3) = v10;
      v11 = *(double *)&v8 == 0.0;
      if (*((double *)&v9 + 1) != 0.0)
        v11 = 0;
      if (*(double *)&v9 == 0.0 && *((double *)&v8 + 1) == 0.0 || v11)
      {
        v14 = (uint64_t (***)(_QWORD, uint64_t *))*a1;
        v15 = (float64x2_t *)(a3 + 48);
        v16 = *((_BYTE *)a1 + 64);
        v17 = *((double *)a1 + 11);
        v18 = (float64x2_t *)(a1 + 2);
        if (a2)
        else
        goto LABEL_53;
      }
      break;
    case 3:
      v19 = *(_OWORD *)(a3 + 16);
      v20 = *(_OWORD *)(a3 + 32);
      v53 = *(float64x2_t *)a3;
      v54 = v19;
      v55 = v20;
      *(double *)&v21 = RB::operator*(&v53, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v21;
      *((_OWORD *)a1 + 2) = v22;
      *((_OWORD *)a1 + 3) = v23;
      v24 = *(double *)&v21 == 0.0;
      if (*((double *)&v22 + 1) != 0.0)
        v24 = 0;
      if (*(double *)&v22 == 0.0 && *((double *)&v21 + 1) == 0.0 || v24)
      {
        v27 = *((double *)a1 + 11);
LABEL_53:
        *((_BYTE *)a1 + 96) = 1;
      }
      break;
    case 4:
      v28 = *(_OWORD *)(a3 + 16);
      v29 = *(_OWORD *)(a3 + 32);
      v53 = *(float64x2_t *)a3;
      v54 = v28;
      v55 = v29;
      *(double *)&v30 = RB::operator*(&v53, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v30;
      *((_OWORD *)a1 + 2) = v31;
      *((_OWORD *)a1 + 3) = v32;
      v33 = *(double *)&v30 == 0.0;
      if (*((double *)&v31 + 1) != 0.0)
        v33 = 0;
      if (*(double *)&v31 == 0.0 && *((double *)&v30 + 1) == 0.0 || v33)
      {
        v36 = *((double *)a1 + 11);
        goto LABEL_33;
      }
      break;
    case 5:
      v38 = *(_OWORD *)(a3 + 32);
      v39 = *(_OWORD *)(a3 + 48);
      v53 = *(float64x2_t *)(a3 + 16);
      v54 = v38;
      v55 = v39;
      *(double *)&v40 = RB::operator*(&v53, (float64x2_t *)a1 + 1);
      *((_OWORD *)a1 + 1) = v40;
      *((_OWORD *)a1 + 2) = v41;
      *((_OWORD *)a1 + 3) = v42;
      break;
    case 6:
      if (*((unsigned __int8 *)a1 + 64) <= 1u)
      {
        a1[9] = (void (***)(uint64_t (***)(_QWORD, uint64_t *), uint64_t *))a3;
        v43 = *(double *)(a3 + 16);
        if (v43 <= 0.0)
        {
          v52 = (void (***)(_QWORD, float64x2_t *))*a1;
          v53 = 0u;
          v54 = 0u;
          LODWORD(v55) = 1065353216;
          *(_QWORD *)((char *)&v55 + 4) = 0;
          BYTE12(v55) = 0;
          *(_WORD *)((char *)&v55 + 13) = 1;
          (**v52)(v52, &v53);
          *((_BYTE *)a1 + 96) = 1;
        }
        else
        {
          if (!*(_QWORD *)(a3 + 48))
          {
            if ((v44 = *((_OWORD *)a1 + 1),
                  v45 = *((_OWORD *)a1 + 2),
                  v46 = *((double *)a1 + 5),
                  v47 = *((double *)a1 + 3),
                  *(double *)&v44 == v46)
              && v47 == 0.0
              && *(double *)&v45 == 0.0
              || v46 == 0.0 && (*(double *)&v44 == 0.0 ? (v48 = v47 == *(double *)&v45) : (v48 = 0), v48))
            {
              v49 = fabs(*(double *)&v44);
              v50 = fabs(v47);
              if (v47 != 0.0)
                v49 = v50;
              v51 = v49;
              *((double *)a1 + 10) = v43 * v51;
            }
          }
          if (!*((_BYTE *)a1 + 96))
          {
LABEL_33:
            *((_BYTE *)a1 + 96) = v37;
          }
        }
      }
      break;
    default:
      return;
  }
}

float64_t RB::clamp_corner_radii(uint64_t a1, double *a2)
{
  double v2;
  double v3;
  uint64_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  double v10;
  double v11;
  double v12;
  float64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  float64_t v20;
  double v21;
  double v22;
  double v23;

  v2 = fabs(*a2);
  v3 = fabs(a2[1]);
  if (v2 >= v3)
    *(double *)&v4 = v2;
  else
    *(double *)&v4 = v3;
  v5 = (float64x2_t)vbicq_s8(*(int8x16_t *)a1, (int8x16_t)vcltzq_f64(*(float64x2_t *)a1));
  v6 = (float64x2_t)vdupq_lane_s64(v4, 0);
  v7 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v5, v6), (int8x16_t)v6, (int8x16_t)v5);
  v8 = (float64x2_t)vbicq_s8(*(int8x16_t *)(a1 + 16), (int8x16_t)vcltzq_f64(*(float64x2_t *)(a1 + 16)));
  v9 = (float64x2_t)vbslq_s8((int8x16_t)vcgtq_f64(v8, v6), (int8x16_t)v6, (int8x16_t)v8);
  *(float64x2_t *)a1 = v7;
  *(float64x2_t *)(a1 + 16) = v9;
  v10 = v7.f64[1];
  v11 = v2 - vaddvq_f64(v7);
  if (v7.f64[0] != v7.f64[1] && v11 < 0.0)
  {
    v12 = v7.f64[1] - v7.f64[0];
    if (v7.f64[1] - v7.f64[0] <= 0.0)
    {
      if (v11 >= v12)
        v12 = v11;
      v7.f64[0] = v12 + v7.f64[0];
      *(float64_t *)a1 = v7.f64[0];
    }
    else
    {
      v12 = -v12;
      if (v11 >= v12)
        v12 = v11;
      v10 = v12 + v7.f64[1];
      *(double *)(a1 + 8) = v12 + v7.f64[1];
    }
    v11 = v11 - v12;
  }
  if (v11 < 0.0)
  {
    v13 = v7.f64[0] * v11 / (v10 + v7.f64[0]);
    v7.f64[0] = v13 + v7.f64[0];
    v10 = v10 + v11 - v13;
    *(float64_t *)a1 = v7.f64[0];
    *(double *)(a1 + 8) = v10;
  }
  v14 = v9.f64[1];
  v15 = v2 - vaddvq_f64(v9);
  if (v9.f64[1] != v9.f64[0] && v15 < 0.0)
  {
    v16 = v9.f64[0] - v9.f64[1];
    if (v9.f64[0] - v9.f64[1] <= 0.0)
    {
      if (v15 >= v16)
        v16 = v15;
      v14 = v16 + v9.f64[1];
      *(double *)(a1 + 24) = v16 + v9.f64[1];
    }
    else
    {
      v16 = -v16;
      if (v15 >= v16)
        v16 = v15;
      v9.f64[0] = v16 + v9.f64[0];
      *(float64_t *)(a1 + 16) = v9.f64[0];
    }
    v15 = v15 - v16;
  }
  if (v15 < 0.0)
  {
    v17 = v14 * v15 / (v9.f64[0] + v14);
    v14 = v17 + v14;
    v9.f64[0] = v9.f64[0] + v15 - v17;
    *(float64_t *)(a1 + 16) = v9.f64[0];
    *(double *)(a1 + 24) = v14;
  }
  v18 = v3 - (v7.f64[0] + v14);
  if (v7.f64[0] != v14 && v18 < 0.0)
  {
    v19 = v14 - v7.f64[0];
    if (v14 - v7.f64[0] <= 0.0)
    {
      if (v18 >= v19)
        v19 = v3 - (v7.f64[0] + v14);
      v7.f64[0] = v19 + v7.f64[0];
      *(float64_t *)a1 = v7.f64[0];
    }
    else
    {
      v19 = -v19;
      if (v18 >= v19)
        v19 = v3 - (v7.f64[0] + v14);
      v14 = v19 + v14;
      *(double *)(a1 + 24) = v14;
    }
    v18 = v18 - v19;
  }
  if (v18 < 0.0)
  {
    v20 = v7.f64[0] * v18 / (v14 + v7.f64[0]);
    *(float64_t *)a1 = v20 + v7.f64[0];
    *(double *)(a1 + 24) = v14 + v18 - v20;
  }
  v21 = v3 - (v10 + v9.f64[0]);
  if (v10 != v9.f64[0] && v21 < 0.0)
  {
    v22 = v9.f64[0] - v10;
    if (v9.f64[0] - v10 <= 0.0)
    {
      if (v21 >= v22)
        v22 = v21;
      v10 = v22 + v10;
      *(double *)(a1 + 8) = v10;
    }
    else
    {
      v22 = -v22;
      if (v21 >= v22)
        v22 = v21;
      v9.f64[0] = v22 + v9.f64[0];
      *(float64_t *)(a1 + 16) = v9.f64[0];
    }
    v21 = v21 - v22;
  }
  if (v21 < 0.0)
  {
    v23 = v10 * v21 / (v9.f64[0] + v10);
    v9.f64[0] = v9.f64[0] + v21 - v23;
    *(double *)(a1 + 8) = v23 + v10;
    *(float64_t *)(a1 + 16) = v9.f64[0];
  }
  return v9.f64[0];
}

BOOL RB::corners_are_uneven_pill(double *a1, double *a2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  BOOL v8;
  BOOL v9;
  BOOL v10;
  _BOOL8 result;

  v2 = *a1;
  v3 = a1[1];
  v4 = v3 + *a1;
  v6 = a1[2];
  v5 = a1[3];
  if (v4 < v6 + v5)
    v4 = v6 + v5;
  if (v5 + *a1 >= v6 + v3)
    v7 = v5 + *a1;
  else
    v7 = v6 + v3;
  result = 0;
  if (v4 * 1.52866495 > fabs(*a2) || v7 * 1.52866495 > fabs(a2[1]))
  {
    v8 = v3 == v6 && v2 == v3;
    v9 = v8 && v4 == v7;
    v10 = v9 && v5 == v2;
    if (!v10 || v6 != v5)
      return 1;
  }
  return result;
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Path>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), a3, *(_QWORD *)(a1 + 8), a2, (unsigned __int32 *)(*(_QWORD *)(a1 + 16) + 88), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, int8x16_t a2, uint64_t a3, _OWORD *a4, unsigned __int32 *a5, _DWORD *a6, uint64_t *a7)
{
  uint64_t v11;
  char v12;
  uint64_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int32x4_t v16;

  v11 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v11 + 128 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  else
    a1[2] = v11 + 128;
  a2.i32[0] = *a5;
  v12 = *a6;
  v13 = *a7;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v12;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224A20;
  *(_QWORD *)(v11 + 48) = v13;
  v14 = *(int8x16_t *)a4;
  v15 = *((int8x16_t *)a4 + 1);
  v16 = *(int32x4_t *)((char *)a4 + 31);
  *(int32x4_t *)(v11 + 95) = v16;
  *(int8x16_t *)(v11 + 64) = v14;
  *(int8x16_t *)(v11 + 80) = v15;
  *(_DWORD *)(v11 + 112) = a2.i32[0];
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v11, a2, *(double *)v14.i64, v15, v16);
  return v11;
}

float32x2_t *RB::Stroke::FixedWidthLineBounds::moveto(float32x2_t *a1, float64x2_t a2, double a3)
{
  LODWORD(a3) = a1[1].i32[0];
  return RB::Stroke::LineBounds::moveto(a1 + 2, COERCE_DOUBLE(vcvt_f32_f64(a2)), a3);
}

float32x2_t *RB::Stroke::LineBounds::moveto(float32x2_t *result, double a2, double a3)
{
  float v3;
  float32x2_t *v5;
  double v6;
  float v7;

  v3 = *(float *)&a3;
  v5 = result;
  if (!result[8].i8[0])
  {
    LODWORD(a3) = result[7].i32[1];
    RB::Stroke::LineBounds::add_cap(result, 0, result[4], a3, (int8x8_t)result[5]);
    LODWORD(v6) = v5[7].i32[0];
    result = RB::Stroke::LineBounds::add_cap(v5, 1, v5[3], v6, (int8x8_t)v5[6]);
    v5[8].i8[0] = 1;
  }
  *(double *)&v5[3] = a2;
  *(double *)&v5[4] = a2;
  v5[7].f32[0] = v3;
  v5[7].f32[1] = v3;
  v7 = v5[8].f32[1];
  if (v7 < v3)
    v7 = v3;
  v5[8].f32[1] = v7;
  return result;
}

float32x2_t *RB::Stroke::FixedWidthLineBounds::closepath(float32x2_t *this, double a2, double a3)
{
  return RB::Stroke::LineBounds::closepath(this + 2, a2, a3);
}

float32x2_t *RB::Stroke::LineBounds::closepath(float32x2_t *this, double a2, double a3)
{
  float32x2_t *v3;
  double v4;

  if (!this[8].i8[0])
  {
    v3 = this;
    LODWORD(a3) = this[7].i32[1];
    RB::Stroke::LineBounds::lineto(this, this[4], a3);
    LODWORD(v4) = v3[7].i32[1];
    this = RB::Stroke::LineBounds::add_join(v3, v3[4], v4, v3[6], v3[5]);
    v3[8].i8[0] = 1;
  }
  return this;
}

BOOL RB::CGContext::printing_context(RB::CGContext *this)
{
  int Type;

  Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  return (Type - 1) < 2;
}

void sub_209ACF970(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  char *v9;
  char *v11;

  v11 = RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(v9);
  MEMORY[0x20BD16544](v11, 0x1020C40894D135BLL);
  RB::vector<std::pair<RB::objc_ptr<RBSymbolAnimator *>,RB::objc_ptr<objc_object  {objcproto24RBSymbolAnimatorObserver}*>>,4ul,unsigned long>::~vector(&a9);
  _Unwind_Resume(a1);
}

double RBDrawingStateSetIdentifier2(uint64_t a1, int a2, uint64_t a3, uint64_t a4)
{
  const RB::Identity *v6;
  int v8;
  __int128 v9;
  unsigned __int8 uu[8];
  uint64_t v11;
  uint64_t v12;

  v12 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)uu = a3;
  v11 = a4;
  uuid_clear((unsigned __int8 *)&v9);
  v8 = a2;
  if (uuid_is_null(uu))
    v9 = *(_OWORD *)(a1 + 68);
  else
    uuid_copy((unsigned __int8 *)&v9, uu);
}

double `anonymous namespace'::set_identity(_anonymous_namespace_ *this, _RBDrawingState *a2, const RB::Identity *a3)
{
  char *v5;
  BOOL v6;
  uint64_t v7;
  RB::XML::Document *v8;
  double result;

  v5 = (char *)this + 64;
  if (*((_DWORD *)this + 16) != *(_DWORD *)a2
    || (*(_QWORD *)((char *)this + 68) == *(_QWORD *)((char *)a2 + 4)
      ? (v6 = *(_QWORD *)((char *)this + 76) == *(_QWORD *)((char *)a2 + 12))
      : (v6 = 0),
        !v6))
  {
    v7 = *((_QWORD *)this + 1);
    if (!*(_QWORD *)(v7 + 24))
      make_contents(*((unsigned int **)this + 1));
    v8 = *(RB::XML::Document **)(v7 + 304);
    if (v8)
      RB::XML::DisplayList::set_identity(v8, (_RBDrawingState *)this, (uint64_t)v5, (unsigned int *)a2);
    *(_QWORD *)&result = RB::DisplayList::State::set_identity((uint64_t)this, (uint64_t)a2).n128_u64[0];
  }
  return result;
}

__n128 RB::DisplayList::State::set_identity(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  __n128 *v3;
  uint64_t v4;
  __n128 result;

  v2 = *(_QWORD *)(a1 + 68);
  *(_DWORD *)(a1 + 64) = *(_DWORD *)a2;
  v4 = *(_QWORD *)(a2 + 4);
  v3 = (__n128 *)(a2 + 4);
  if (v2 != v4 || *(_QWORD *)(a1 + 76) != v3->n128_u64[1])
  {
    result = *v3;
    *(__n128 *)(a1 + 68) = *v3;
    *(_QWORD *)(a1 + 120) = 0;
  }
  return result;
}

double RB::DisplayList::Layer::compute_bounds_(RB::DisplayList::Layer *this, int32x2_t *a2)
{
  int32x2_t v3;
  uint32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  uint64_t i;
  unsigned int v8;
  BOOL v9;
  int v10;
  double v12;
  float32x2_t v13;
  double v14;
  double v15;
  double v16;
  int32x4_t v17;
  uint64_t j;
  __int128 v20;

  v20 = 0uLL;
  if ((*((_WORD *)this + 30) & 0x2001) != 0)
  {
    if (a2)
    {
      v3 = a2[1];
      v4 = (uint32x2_t)vceq_s32(v3, (int32x2_t)0x8000000080000000);
      if ((vpmin_u32(v4, v4).u32[0] & 0x80000000) != 0)
      {
        v6 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
        v5 = (float32x2_t)0x100000001000000;
      }
      else
      {
        v5 = vcvt_f32_s32(*a2);
        v6 = vcvt_f32_s32(v3);
      }
    }
    else
    {
      v5 = (float32x2_t)0xFEFFFFFFFEFFFFFFLL;
      v6 = (float32x2_t)0x7F7FFFFF7F7FFFFFLL;
    }
    *(float32x2_t *)&v20 = v5;
    *((float32x2_t *)&v20 + 1) = v6;
  }
  else
  {
    for (i = *(_QWORD *)this; i; i = *(_QWORD *)(i + 8))
    {
      v8 = *(_WORD *)(i + 46) & 0x3F;
      v9 = v8 > 8;
      v10 = (1 << v8) & 0x1AA;
      if (v9 || v10 == 0)
      {
        v12 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)i);
        RB::Rect::Union((float32x2_t *)&v20, *(float32x2_t *)&v12, v13, v14, v15, v16, v17);
      }
    }
  }
  for (j = *((_QWORD *)this + 2); j; j = *(_QWORD *)(j + 8))
  {
    *(_OWORD *)(j + 16) = v20;
    (*(void (**)(uint64_t, __int128 *))(*(_QWORD *)j + 56))(j, &v20);
  }
  return *(double *)&v20;
}

double RB::DisplayList::Item::clipped_bounds(float32x2_t **this)
{
  float32x2_t v2;
  double v3;
  double v4;
  double v5;
  int32x4_t v6;
  float32x2_t *v7;
  float32x2_t *v8;
  float64x2_t v10[2];
  uint64_t v11;
  uint64_t v12;
  float32x2_t v13[2];

  v13[0] = COERCE_FLOAT32X2_T(((double (*)(float32x2_t **))(*this)[18])(this));
  v13[1] = v2;
  v7 = this[3];
  if (v7)
    RB::Rect::intersect(v13, v7[2], v7[3], v3, v4, v5, v6);
  v8 = this[2];
  if (v8)
  {
    v10[0] = (float64x2_t)xmmword_209BD5290;
    v10[1] = (float64x2_t)xmmword_209BD52A0;
    v11 = 0;
    v12 = 0;
    RB::DisplayList::Style::dod(v8, v13, v10);
    RB::Rect::move_identity(v13, v10);
  }
  return *(double *)v13;
}

int32x2_t *RB::Bounds::intersect(int32x2_t *result, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3;
  uint32x2_t v4;
  uint32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;
  uint32x2_t v8;

  v3 = result[1];
  v4 = (uint32x2_t)vceqz_s32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    v5 = (uint32x2_t)vceqz_s32(a3);
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    {
      *result = a2;
      result[1] = a3;
    }
    else
    {
      v6 = vmax_s32(*result, a2);
      v7 = vsub_s32(vmin_s32(vadd_s32(*result, v3), vadd_s32(a3, a2)), v6);
      v8 = (uint32x2_t)vcgtz_s32(v7);
      if ((vpmin_u32(v8, v8).u32[0] & 0x80000000) != 0)
      {
        *result = v6;
        result[1] = v7;
      }
      else
      {
        *result = 0;
        result[1] = 0;
      }
    }
  }
  return result;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::bounds(uint64_t a1)
{
  RBPath v2;

  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

int32x2_t *RB::Bounds::Union(int32x2_t *result, int32x2_t a2, int32x2_t a3)
{
  uint32x2_t v3;
  int32x2_t v4;
  uint32x2_t v5;
  int32x2_t v6;
  int32x2_t v7;

  v3 = (uint32x2_t)vceqz_s32(a3);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    v4 = result[1];
    v5 = (uint32x2_t)vceqz_s32(v4);
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    {
      *result = a2;
    }
    else
    {
      v6 = vmin_s32(*result, a2);
      v7 = vmax_s32(vadd_s32(*result, v4), vadd_s32(a3, a2));
      *result = v6;
      a3 = vsub_s32(v7, v6);
    }
    result[1] = a3;
  }
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

uint64_t RBDrawingStateDrawShape(uint64_t a1, uint64_t a2, float16x4_t *a3, unsigned int a4, float a5)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t result;
  RB::Heap *v13;
  uint64_t v14;
  __int16 v15;
  uint64_t v16;
  float32x2_t *v17;
  double v18;
  double v19;
  int8x16_t v20;
  int32x4_t v21;
  int v22;
  _QWORD v23[2];
  float v24;
  unsigned int v25;
  __int16 v26;
  uint64_t v27;
  uint64_t v28;
  char v29;
  RB::DisplayList::Item *v30;

  v10 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v10 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v11 = rb_blend_mode(a4);
  if (!*(_BYTE *)(v10 + 288)
    || a5 != 0.0 && !RBFillIsClear((RBFill *)a3)
    || (result = RB::may_discard_alpha(v11), (result & 1) == 0))
  {
    v22 = a4;
    v13 = (RB::Heap *)(*(_QWORD *)(v10 + 24) + 16);
    RB::DisplayList::State::copy_ctm((__n128 *)a1, v13);
    v14 = a2;
    v15 = *(_WORD *)(a1 + 156);
    v23[0] = v13;
    v23[1] = v16;
    v24 = a5;
    v25 = v11;
    v26 = v15;
    v27 = -[RBShape shapeData]((uint64_t)a3);
    v28 = RB::DisplayList::Builder::culling_bounds((RB::DisplayList::Builder *)(v10 + 16), (RB::DisplayList::State *)a1);
    v30 = 0;
    v29 = *(_BYTE *)(v10 + 288);
    v17 = (float32x2_t *)-[RBShape shapeData](v14);
    RBShapeData::apply<RB::DisplayList::ItemFactory>(v17, (uint64_t)v23, v18, v19, v20, v21);
    if (v30)
      RB::DisplayList::Builder::draw((RB::DisplayList::Contents **)(v10 + 16), (int8x16_t *)v30, (int8x16_t *)a1);
    result = *(_QWORD *)(v10 + 304);
    if (result)
      return RB::XML::DisplayList::draw_shape((RB::XML::Document *)result, (_RBDrawingState *)a1, v14, a3, v22, a5);
  }
  return result;
}

uint64_t RB::DisplayList::Layer::append_item(RB::DisplayList::Layer *this, RB::DisplayList::Item *a2)
{
  uint64_t v4;
  RB::DisplayList::Layer *v5;
  unsigned int v6;
  int v7;
  unsigned int v9;
  int v10;
  uint64_t result;

  *((_QWORD *)a2 + 1) = 0;
  v4 = *((_QWORD *)this + 1);
  if (v4)
    v5 = (RB::DisplayList::Layer *)(v4 + 8);
  else
    v5 = this;
  *(_QWORD *)v5 = a2;
  *((_QWORD *)this + 1) = a2;
  v6 = *((unsigned __int16 *)a2 + 23);
  if (((v6 >> 6) & 0x10) != 0)
  {
    if (((v6 >> 6) & 8) != 0 && *(_BYTE *)(*((_QWORD *)a2 + 6) + 67))
    {
      *((_BYTE *)this + 67) = *(_BYTE *)(*((_QWORD *)a2 + 6) + 67) - 1;
      v6 = 0x2000;
    }
    else
    {
      v6 = 16;
    }
    *((_DWORD *)this + 15) |= v6;
    LOWORD(v6) = *((_WORD *)a2 + 23);
  }
  if ((v6 & 0x2000) != 0)
  {
    *((_DWORD *)this + 15) |= 0x80u;
    LOWORD(v6) = *((_WORD *)a2 + 23);
  }
  v7 = v6 & 0x3F;
  if (v7 != 2 && v7 != 24)
  {
    *((_DWORD *)this + 15) |= 0x100u;
    if ((RB::pdf_blend(*((_WORD *)a2 + 23) & 0x3F) & 1) == 0)
      *((_DWORD *)this + 15) |= 0x1000u;
  }
  v9 = *((unsigned __int8 *)this + 65);
  v10 = (*(uint64_t (**)(RB::DisplayList::Item *))(*(_QWORD *)a2 + 136))(a2);
  result = RB::max_color_depth(v9, v10);
  *((_BYTE *)this + 65) = result;
  return result;
}

uint64_t RB::max_color_depth(unsigned int a1, int a2)
{
  unsigned int v3;
  unsigned int v4;

  if (a2 == 4 || a1 == 0)
    v3 = 0;
  else
    v3 = a1;
  v4 = v3 | a2;
  if (!a2)
    v4 = a1;
  if (a1 == 4)
    return 4;
  else
    return v4;
}

uint64_t RB::required_color_depth(RB *this, float a2, float a3)
{
  float v3;
  float v4;
  unsigned int v6;

  v3 = a2 + 0.001;
  v4 = a3 + -0.001;
  if (v4 > 1.251 || v3 < -0.75294)
    v6 = 4;
  else
    v6 = 2;
  if (v4 > 1.0 || v3 < 0.0)
    return v6;
  else
    return 0;
}

uint64_t RB::Fill::Color::required_depth(float16x4_t *this)
{
  float32x4_t v1;
  float32x4_t v2;
  float32x4_t v3;

  v1 = vcvtq_f32_f16(*this);
  v2.i64[0] = 0xC7000000C7000000;
  v2.i64[1] = 0xC7000000C7000000;
  v3 = (float32x4_t)vbicq_s8((int8x16_t)v1, (int8x16_t)vceqq_f32(v1, v2));
  return RB::required_color_depth((RB *)this, vminvq_f32(v3), vmaxvq_f32(v3));
}

__n128 RB::DisplayList::State::copy_ctm(__n128 *this, RB::Heap *a2)
{
  unint64_t v3;
  __n128 result;
  __n128 v5;

  if (!this[7].n128_u64[0])
  {
    v3 = (*((_QWORD *)a2 + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v3 + 48 > *((_QWORD *)a2 + 3))
      v3 = RB::Heap::alloc_slow((size_t *)a2, 0x30uLL, 15);
    else
      *((_QWORD *)a2 + 2) = v3 + 48;
    result = this[1];
    v5 = this[3];
    *(__n128 *)(v3 + 16) = this[2];
    *(__n128 *)(v3 + 32) = v5;
    *(__n128 *)v3 = result;
    this[7].n128_u64[0] = v3;
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 11);
}

uint64_t rb_blend_mode(unsigned int a1)
{
  if (a1 <= 0x1B)
    return rb_blend_mode(RBBlendMode)::cg_table[a1];
  if (a1 - 1000 <= 0xD)
    return rb_blend_mode(RBBlendMode)::custom_table[a1 - 1000];
  if (a1 == 2000)
    return 24;
  return 2;
}

{
  if (a1 > 0x2F)
    return 0;
  else
    return dword_209BD6FC0[a1];
}

void RBShapeData::apply<RB::DisplayList::ItemFactory>(float32x2_t *a1, uint64_t a2, double a3, double a4, int8x16_t a5, int32x4_t a6)
{
  switch(a1->i32[0])
  {
    case 1:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>(a2, a1 + 2, a3, a4, a5, a6);
      break;
    case 2:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Path>(a2, (RB::Coverage::Path *)&a1[2]);
      break;
    case 3:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(a2, (uint64_t)&a1[2]);
      break;
    case 4:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Glyphs>(a2, a1 + 2);
      break;
    case 5:
      RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(a2, &a1[2]);
      break;
    default:
      return;
  }
}

_QWORD *RB::DisplayList::State::copy_metadata(RB::DisplayList::State *this, RB::DisplayList::Contents *a2)
{
  _QWORD *v2;
  _QWORD *v5;
  _QWORD *v6;
  uint64_t v8;
  _QWORD *v9;

  v2 = (_QWORD *)*((_QWORD *)this + 15);
  if (!v2)
  {
    v9 = 0;
    LODWORD(v8) = *((_DWORD *)this + 38);
    RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (float *)&v8);
    v9 = v5;
    if (*((_QWORD *)this + 21) != 0x100000000)
      v9 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (_QWORD *)this + 21);
    if (*((_QWORD *)this + 20))
      v9 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, (uint64_t *)this + 20);
    if (*((_QWORD *)this + 11))
    {
      v8 = *((_QWORD *)this + 11);
      v6 = RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>((RB::DisplayList::Contents *)((char *)a2 + 16), &v9, &v8);
      RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain((_DWORD *)v6[1], (uint64_t)a2);
      v9 = v6;
    }
    if (uuid_is_null((const unsigned __int8 *)this + 68))
    {
      v2 = v9;
    }
    else
    {
      v2 = (_QWORD *)((*((_QWORD *)a2 + 4) + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v2 + 2) > *((_QWORD *)a2 + 5))
        v2 = (_QWORD *)RB::Heap::alloc_slow((size_t *)a2 + 2, 0x10uLL, 7);
      else
        *((_QWORD *)a2 + 4) = v2 + 2;
      *v2 = v9;
      v2[1] = (char *)this + 68;
      v2[1] = RB::DisplayList::Contents::intern_uuid(a2, (const UUID *)((char *)this + 68));
    }
    *((_QWORD *)this + 15) = v2;
  }
  return v2;
}

uint64_t RB::DisplayList::Item::apply_alpha(uint64_t this, float a2)
{
  RB::DisplayList::Item **v3;
  RB::DisplayList::Item *i;

  if (a2 != 1.0)
  {
    if ((*(_WORD *)(this + 46) & 0x23F) == 0x218)
    {
      v3 = *(RB::DisplayList::Item ***)(this + 48);
      if (v3)
      {
        for (i = *v3; i; i = (RB::DisplayList::Item *)*((_QWORD *)i + 1))
          this = RB::DisplayList::Item::apply_alpha(i, a2);
      }
    }
    else
    {
      _H0 = *(_WORD *)(this + 44);
      __asm { FCVT            S0, H0 }
      _S0 = _S0 * a2;
      __asm { FCVT            H0, S0 }
      *(_WORD *)(this + 44) = LOWORD(_S0);
    }
  }
  return this;
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Path>(uint64_t a1, RB::Coverage::Path *this)
{
  float32x2_t *v4;
  double v5;
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  uint64_t result;
  _OWORD v12[2];
  uint64_t v13;
  uint64_t v14;
  RBPath v15;

  v4 = *(float32x2_t **)(a1 + 40);
  if (!v4)
    goto LABEL_3;
  v12[0] = xmmword_209BD5290;
  v12[1] = xmmword_209BD52A0;
  v13 = 0;
  v14 = 0;
  v15.callbacks = (RBPathCallbacks *)v12;
  v15.info = this;
  v5 = RB::Coverage::Path::bounds(v15);
  result = RB::Rect::intersects(v4, *(float32x2_t *)&v5, v6, v7, v8, v9, v10);
  if ((result & 1) != 0)
  {
LABEL_3:
    *(_QWORD *)&v12[0] = a1;
    *((_QWORD *)&v12[0] + 1) = this;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>>(*(_QWORD **)(a1 + 32), (uint64_t *)v12);
  }
  return result;
}

_QWORD *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>>(_QWORD *result, uint64_t *a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Color>(a2, (uint64_t)(result + 2));
      break;
    case 2:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Gradient>(a2, result + 2);
      break;
    case 3:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t)(result + 2));
      break;
    case 4:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 2));
      break;
    case 5:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 2));
      break;
    default:
      return result;
  }
  return result;
}

BOOL RB::Bounds::intersects(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  uint32x2_t v3;
  int32x2_t v4;
  uint32x2_t v5;
  uint32x2_t v6;

  v3 = (uint32x2_t)vceqz_s32(a3);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    return 0;
  v4 = a1[1];
  v5 = (uint32x2_t)vceqz_s32(v4);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
    return 0;
  v6 = (uint32x2_t)vcge_s32(vmax_s32(*a1, a2), vmin_s32(vadd_s32(*a1, v4), vadd_s32(a3, a2)));
  return vpmax_u32(v6, v6).i32[0] >= 0;
}

void RB::UntypedTable::~UntypedTable(RB::UntypedTable *this)
{
  unint64_t v2;
  int v3;
  _QWORD *i;
  void (*v5)(_QWORD);
  void (*v6)(_QWORD);
  RB::Heap *v7;

  if ((*((_QWORD *)this + 2) || *((_QWORD *)this + 3)) && *((_QWORD *)this + 7))
  {
    v2 = 0;
    v3 = *((_DWORD *)this + 18);
    do
    {
      for (i = *(_QWORD **)(*((_QWORD *)this + 6) + 8 * v2); i; i = (_QWORD *)*i)
      {
        v5 = (void (*)(_QWORD))*((_QWORD *)this + 2);
        if (v5)
          v5(i[1]);
        v6 = (void (*)(_QWORD))*((_QWORD *)this + 3);
        if (v6)
          v6(i[2]);
      }
      ++v2;
    }
    while (!(v2 >> v3));
  }
  if (*((_DWORD *)this + 18) >= 5u)
    free(*((void **)this + 6));
  if (*((_BYTE *)this + 76))
  {
    v7 = (RB::Heap *)*((_QWORD *)this + 4);
    if (v7)
    {
      RB::Heap::~Heap(v7);
      MEMORY[0x20BD16544]();
    }
  }
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Color>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[3];

  v4 = *a1;
  if (*(_BYTE *)(*a1 + 48))
  {
    v6[0] = off_24C226098;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    v4 = *a1;
  }
  result = *(_QWORD **)(v4 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    v4 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 104 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 104;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C224AB8;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 104 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x68uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 104;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C224AB8;
  return result;
}

uint64_t RB::Coverage::Primitive::contains(float32x2_t *a1, uint64_t a2, float32x2_t a3, float32x2_t a4)
{
  __int128 v6;
  __int128 v7;
  int v8;
  uint64_t result;
  char v11;
  float32x4_t v12;
  float v13;
  __int128 v14;
  __int128 v15;
  _OWORD v16[3];

  v6 = *(_OWORD *)(a2 + 16);
  v7 = *(_OWORD *)(a2 + 32);
  v16[0] = vmulq_n_f64(*(float64x2_t *)a2, a1[4].f32[0]);
  v16[1] = v6;
  v16[2] = v7;
  v8 = a1[5].u8[4];
  if (!a1[5].i8[4])
    return 0;
  if (v8 == 1)
    return 1;
  v11 = a1[5].i8[6];
  if ((v11 & 4) != 0)
    return 0;
  result = 0;
  if ((v11 & 1) == 0 && a1[4].f32[1] <= 0.0)
  {
    if (a1[5].u8[5] <= 1u)
    {
      if ((v8 - 3) >= 3)
      {
        if (v8 == 2)
          return RB::Rect::contains(a1, (uint64_t)v16, a3, a4);
        if ((v8 - 9) < 3)
          abort();
      }
      else
      {
        v12 = *(float32x4_t *)a1[2].f32;
        v13 = vmaxvq_f32(v12);
        v15 = *(_OWORD *)a1->f32;
        v12.i32[0] = 0;
        if (RB::Rect::inset((float32x2_t *)&v15, *(float32x2_t *)v12.f32, v13)
          && (RB::Rect::contains((float32x2_t *)&v15, (uint64_t)v16, a3, a4) & 1) != 0)
        {
          return 1;
        }
        v14 = *(_OWORD *)a1->f32;
        if (RB::Rect::inset((float32x2_t *)&v14, (float32x2_t)__PAIR64__(DWORD1(v14), LODWORD(v13)), 0.0)
          && (RB::Rect::contains((float32x2_t *)&v14, (uint64_t)v16, a3, a4) & 1) != 0)
        {
          return 1;
        }
      }
    }
    return 0;
  }
  return result;
}

uint64_t RB::Rect::contains(float32x2_t *a1, uint64_t a2, float32x2_t a3, float32x2_t a4)
{
  __int128 v6;
  float32x2_t v7;
  float32x2_t v8;
  int32x4_t v9;
  uint32x2_t v10;
  int32x4_t v11;
  float32x2_t v12;
  float32x2_t v13;
  unsigned __int32 v14;
  int32x2_t v15;
  int32x2_t v16;
  unint64_t i;
  float32x2_t v18;
  int32x2_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  float32x2_t *v23;
  int32x2_t v24;
  int32x2_t v25;
  uint32x2_t v26;
  float32x2_t v28[4];
  float32x2_t v29;
  float32x2_t v30[5];

  v30[4] = *(float32x2_t *)MEMORY[0x24BDAC8D0];
  v6 = *(_OWORD *)(a2 + 16);
  if (*(double *)(a2 + 8) == 0.0 && *(double *)&v6 == 0.0 || *(double *)a2 == 0.0 && *((double *)&v6 + 1) == 0.0)
  {
    v7 = RB::operator*((float64x2_t *)a2, *a1, a1[1]);
    v10 = (uint32x2_t)vceqz_f32(v8);
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) == 0
      && (*(int32x2_t *)v9.i8 = vcltz_f32(v8),
          v11 = vcltzq_s32(v9),
          v12 = (float32x2_t)vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vadd_f32(v7, v8), (int8x8_t)v7),
          *(int32x2_t *)v11.i8 = vcltz_f32(a4),
          v13 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v11), (int8x8_t)vadd_f32(a4, a3), (int8x8_t)a3),
          *(int32x2_t *)v11.i8 = vcge_f32(v13, v12),
          (vpmin_u32(*(uint32x2_t *)v11.i8, *(uint32x2_t *)v11.i8).u32[0] & 0x80000000) != 0))
    {
      v26 = (uint32x2_t)vcge_f32(vadd_f32(v12, (float32x2_t)(*(_QWORD *)&v8 & 0x7FFFFFFF7FFFFFFFLL)), vadd_f32(v13, vabs_f32(a4)));
      v14 = vpmin_u32(v26, v26).u32[0] >> 31;
    }
    else
    {
      LOBYTE(v14) = 0;
    }
  }
  else
  {
    for (i = 0; i != 4; ++i)
      v30[i] = vadd_f32((float32x2_t)vand_s8((int8x8_t)a4, (int8x8_t)vcltz_s32(vshl_n_s32((int32x2_t)__PAIR64__(i > 1, (i - 1) < 2), 0x1FuLL))), a3);
    v18 = v30[0];
    v19 = (int32x2_t)vsub_f32(v30[0], v28[0]);
    *(float *)v15.i32 = -*(float *)&v19.i32[1];
    LOBYTE(v14) = 0;
    if (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v15, v19), v29)) <= 0.0)
    {
      v20 = 0;
      do
      {
        v21 = 0;
        do
        {
          v22 = v21;
          if (v21 == 3)
            break;
          v23 = &v28[v21];
          v24 = (int32x2_t)vsub_f32(v18, v23[1]);
          v15 = (int32x2_t)v23[5];
          *(float *)v16.i32 = -*(float *)&v24.i32[1];
          v21 = v22 + 1;
        }
        while (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v16, v24), (float32x2_t)v15)) <= 0.0);
        if (v22 <= 2)
          break;
        LOBYTE(v14) = v20 > 2;
        if (v20 == 3)
          break;
        v18 = v30[v20 + 1];
        v25 = (int32x2_t)vsub_f32(v18, v28[0]);
        *(float *)v15.i32 = -*(float *)&v25.i32[1];
        ++v20;
      }
      while (vaddv_f32(vmul_f32((float32x2_t)vzip1_s32(v15, v25), v29)) <= 0.0);
    }
  }
  return v14 & 1;
}

RB::DisplayList::Contents *RB::DisplayList::Contents::Contents(RB::DisplayList::Contents *this, int a2)
{
  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = &off_24C228970;
  RB::Heap::Heap((RB::DisplayList::Contents *)((char *)this + 16), (char *)this + 56, 256, 0);
  *((_QWORD *)this + 39) = 0;
  RB::DisplayList::Layer::Layer((uint64_t)this + 320, a2, 32);
  *((_QWORD *)this + 49) = 0;
  *((_BYTE *)this + 400) = 1;
  return this;
}

void sub_209AD0BFC(_Unwind_Exception *a1)
{
  RB::Heap *v1;

  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 14);
}

uint64_t RB::Heap::alloc_slow(size_t *this, size_t a2, uint64_t a3)
{
  size_t v5;
  size_t v6;
  _QWORD *v7;
  uint64_t result;
  size_t v10;
  void *v11;
  const char *v12;
  void *v13;
  size_t v14;
  unint64_t v15;
  size_t v16;
  size_t v17;
  _QWORD *v18;

  v5 = *this;
  v6 = this[2];
  if (a2 + a3 + 23 <= *this)
  {
    result = (v6 + a3) & ~a3;
    v10 = result + a2;
    if (result + a2 > this[3])
    {
      v11 = malloc_type_malloc(v5, 0xC90CD2B6uLL);
      if (!v11)
        RB::precondition_failure((RB *)"memory allocation failed: %lu", v12, *this);
      v13 = v11;
      v14 = *this;
      v15 = (unint64_t)v11 + *this;
      this[2] = (size_t)v11;
      this[3] = v15;
      v16 = (size_t)v11;
      if (!(v14 >> 16))
      {
        if (2 * v14 >= 0x10000)
          v17 = 0x10000;
        else
          v17 = 2 * v14;
        *this = malloc_good_size(v17);
        v16 = this[2];
        v15 = this[3];
      }
      v18 = (_QWORD *)((v16 + 7) & 0xFFFFFFFFFFFFFFF8);
      this[2] = (size_t)(v18 + 2);
      if ((unint64_t)(v18 + 2) > v15)
        RB::precondition_failure((RB *)"invalid heap state, %u, %u, %p, %p", v12, a2, a3, v18 + 2, v15);
      *v18 = this[1];
      v18[1] = v13;
      this[1] = (size_t)v18;
      result = ((unint64_t)v18 + a3 + 16) & ~a3;
      v10 = result + a2;
    }
    this[2] = v10;
  }
  else
  {
    v7 = (_QWORD *)((v6 + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v7 + 2) > this[3])
      v7 = (_QWORD *)RB::Heap::alloc_slow((RB::Heap *)this, 0x10uLL, 7uLL);
    else
      this[2] = (size_t)(v7 + 2);
    result = (uint64_t)malloc_type_malloc(a2, 0xD6F0D335uLL);
    if (result)
    {
      *v7 = this[1];
      v7[1] = result;
      this[1] = (size_t)v7;
    }
  }
  return result;
}

void RB::Rect::move(float32x2_t *this, float64x2_t *a2, float64x2_t *a3)
{
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  int64x2_t v6;
  float32x2_t v10;
  float32x2_t v11;
  float64x2_t v12;
  double v13;
  double v14;
  int8x16_t v15;
  float64x2_t v16;
  double v17;
  double v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float32x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28[3];
  float64x2_t v29[3];

  v4 = *a3;
  v3 = a3[1];
  v5 = a3[2];
  v6 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v3, a2[1]), (int8x16_t)vceqq_f64(*a3, *a2)), (int8x16_t)vceqq_f64(v5, a2[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) == 0)
  {
    v10 = *this;
    v11 = this[1];
    v12 = vmulq_f64((float64x2_t)vextq_s8((int8x16_t)v3, (int8x16_t)v3, 8uLL), v4);
    v13 = vsubq_f64(v12, (float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1)).f64[0];
    if (v13 != 0.0)
    {
      v14 = 1.0 / v13;
      v15 = (int8x16_t)vmulq_n_f64(v4, v14);
      v16.f64[0] = vmuld_lane_f64(v14, v3, 1);
      v17 = vmuld_lane_f64(v14 * v3.f64[0], v5, 1);
      v18 = -(v14 * v3.f64[0]);
      v19 = (float64x2_t)vextq_s8(v15, v15, 8uLL);
      v20 = vmulq_f64(v19, v5);
      v21 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v20.f64[0], 0);
      v21.f64[0] = v17;
      v20.f64[0] = v16.f64[0] * v5.f64[0];
      v5 = vsubq_f64(v21, v20);
      v16.f64[1] = -*(double *)&v15.i64[1];
      v19.f64[0] = v18;
      v3 = v19;
      v4 = v16;
    }
    v28[0] = v4;
    v28[1] = v3;
    v28[2] = v5;
    v22.f64[0] = RB::operator*(a2, v28);
    v29[0] = v22;
    v29[1] = v23;
    v29[2] = v24;
    *this = RB::operator*(v29, v10, v11);
    this[1] = v25;
    v26 = *a3;
    v27 = a3[2];
    a2[1] = a3[1];
    a2[2] = v27;
    *a2 = v26;
  }
}

uint64_t RB::Coverage::Primitive::set_globals(uint64_t a1, uint64_t a2, float32x2_t *a3, float64x2_t *a4, unsigned int a5, int *a6, uint64_t a7, uint64_t a8)
{
  int may_discard_alpha;
  uint64_t v16;
  int v17;
  int v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  _BOOL4 v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float32x4_t v26;
  float64x2_t v27;
  double v28;
  float64x2_t v29;
  unsigned int v30;
  float32x2_t v31;
  float32x2_t v32;
  int32x2_t v33;
  float64_t v34;
  float32x2_t v35;
  int64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  uint64_t v39;
  float32x2_t v40;
  float32x2_t v41;
  int v48;
  char v49;
  float64_t v50;
  int32x2_t v51;
  double v52;
  int32x4_t v53;
  int32x2_t v54;
  uint32x2_t v55;
  int8x8_t v56;
  int8x8_t v57;
  int8x8_t v58;
  uint64_t v59;
  int32x2_t v60;
  uint32x2_t v61;
  int8x8_t v62;
  float32x2_t v63;
  float32x2_t v64;
  _BOOL4 v65;
  float64x2_t *v66;
  float64x2_t v67;
  float64x2_t *v68;
  float64x2_t v69;
  float64x2_t *v70;
  float64x2_t v71;
  double v72;
  double v73;
  uint64_t v74;
  _QWORD **v75;
  char v76;
  float64x2_t v77;
  float64x2_t v78;
  int64x2_t v79;
  int64x2_t v80;
  float32x4_t v81;
  int32x2_t v82;
  float32x4_t *v83;
  float32x4_t v84;
  char v85;
  int v86;
  int v87;
  int v88;
  int v89;
  float32x2_t v90;
  uint32x2_t v92;
  float v93;
  float32x2_t v94;
  float32x2_t v95;
  float32x2_t v97;
  float32x2_t v98;
  float v99;
  int v101;
  float v102;
  float v103;
  float v104;
  float v105;
  float v106;
  float32x2_t v107;
  float32x2_t v108;
  float v109;
  BOOL v110;
  float32x2_t v113;
  int8x8_t v114;
  float32x2_t v115;
  float32x2_t v116;
  float32x2_t v117;
  float32x2_t v118;
  int32x2_t v119;
  int32x2_t v120;
  float32x4_t v121;
  float32x4_t v122;
  int32x2_t v123;
  uint32x2_t v124;
  int8x8_t v125;
  float32x2_t v126;
  float32x2_t v127;
  _BOOL4 v128;
  float64x2_t *v129;
  float64x2_t v130;
  float64x2_t *v131;
  float64x2_t v132;
  float64x2_t *v133;
  float64x2_t v134;
  uint64_t v135;
  double v136;
  double v137;
  double v138;
  int32x4_t v139;
  int32x2_t v140;
  _QWORD **v141;
  uint64_t v142;
  uint64_t v144;
  float32x2_t v146;
  float32x4_t v147;
  int32x2_t v148;
  float32x4_t v149;
  float32x4_t v150;
  float32x4_t v151;
  int8x8_t v152;
  uint64_t v153;
  uint64_t v154;
  int v155;
  float32x2_t v156;
  __int32 v157;
  double v158;
  __int128 v159;
  float64x2_t v160;
  float64x2_t v161;
  float64x2_t v162;
  __int128 v163;
  float64x2_t v164;
  float64x2_t v165;
  _OWORD v166[2];

  if ((*(_BYTE *)(a1 + 46) & 2) != 0)
    may_discard_alpha = RB::may_discard_alpha(a5);
  else
    may_discard_alpha = RB::may_discard_shape(a5);
  v17 = may_discard_alpha;
  *a6 = *(unsigned __int8 *)(a1 + 44);
  *(_DWORD *)(a2 + 68) = a3[15].i32[0];
  *(_QWORD *)(a2 + 72) = 0x3C0000000000;
  v18 = *(unsigned __int8 *)(a1 + 44);
  v19 = a4[1];
  v20 = vmulq_n_f64(*a4, *(float *)(a1 + 32));
  v21 = a4[2];
  v160 = v20;
  v161 = v19;
  v162 = v21;
  if (*(float *)(a1 + 40) <= 0.0)
    v22 = 0;
  else
    v22 = (*(_BYTE *)(a1 + 46) & 4) != 0 || *(unsigned __int8 *)(a1 + 45) > 1u;
  v24 = *(float32x2_t *)a1;
  v23 = *(float32x2_t *)(a1 + 8);
  v25 = *(float *)(a1 + 36);
  v26 = *(float32x4_t *)(a1 + 16);
  v27 = vabsq_f64(v20);
  v27.f64[0] = vpmaxq_f64(v27);
  v28 = vpmaxq_f64(vabsq_f64(v19));
  if (v27.f64[0] < v28)
    v27.f64[0] = v28;
  *(float *)&v16 = v27.f64[0];
  if ((v18 - 6) < 3)
  {
    v29 = vmlaq_n_f64(vmlaq_n_f64(v21, v20, v24.f32[0]), v19, v24.f32[1]);
    v161 = v19;
    v162 = v29;
    *(float32x2_t *)&v19.f64[0] = vmul_f32(v23, v23);
    *(float *)v29.f64 = sqrtf(vaddv_f32(*(float32x2_t *)&v19.f64[0]));
    v157 = LODWORD(v29.f64[0]);
    if (*(float *)v29.f64 > 0.00001)
    {
      v30 = LODWORD(v29.f64[0]);
      v31 = vrecpe_f32((float32x2_t)LODWORD(v29.f64[0]));
      v32 = vmul_f32(vrecps_f32((float32x2_t)v30, v31), v31);
      v33 = (int32x2_t)vmul_n_f32(v23, vmul_f32(v32, vrecps_f32((float32x2_t)v30, v32)).f32[0]);
      v32.i32[0] = v33.i32[1];
      v34 = *(float *)&v33.i32[1];
      v35 = (float32x2_t)vdup_lane_s32(v33, 0);
      v35.f32[0] = -v32.f32[0];
      v36 = (int64x2_t)vcvtq_f64_f32(v35);
      *(_QWORD *)&v37.f64[0] = vdupq_laneq_s64(v36, 1).u64[0];
      v37.f64[1] = v34;
      v164 = v37;
      v165 = (float64x2_t)v36;
      v166[0] = 0uLL;
      v150 = v26;
      v153 = v16;
      v19.f64[0] = RB::operator*(&v164, &v160);
      v26 = v150;
      v16 = v153;
      v160 = v19;
      v161 = v29;
      v162 = v38;
      if (*(_BYTE *)(a1 + 44) != 7)
      {
        v18 = 2;
LABEL_21:
        v40.i32[1] = 0;
        v41 = vrecpe_f32((float32x2_t)v16);
        v28 = COERCE_DOUBLE(vmul_f32(vrecps_f32((float32x2_t)v16, v41), v41));
        *(float32x2_t *)&v27.f64[0] = vmul_f32(*(float32x2_t *)&v28, vrecps_f32((float32x2_t)v16, *(float32x2_t *)&v28));
        *(float *)v29.f64 = 0.5 * *(float *)v27.f64;
        if ((float)(0.5 * *(float *)v27.f64) <= (float)(v25 * 0.5))
          *(float *)v29.f64 = v25 * 0.5;
        _S2 = 1.0;
        if ((float)(0.5 * *(float *)v27.f64) > (float)(v25 * 0.5))
          _S2 = v25 * *(float *)&v16;
        __asm { FCVT            H2, S2 }
        *(_WORD *)(a2 + 76) = _H2;
        v24.i32[0] = 0;
        v24.f32[1] = -*(float *)v29.f64;
        v23.i32[0] = v157;
        v23.f32[1] = *(float *)v29.f64 + *(float *)v29.f64;
        v48 = *(unsigned __int8 *)(a1 + 44);
        if (v48 != 6)
        {
          *(int32x2_t *)&v27.f64[0] = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v23);
          v28 = COERCE_DOUBLE(vsub_f32(v24, (float32x2_t)LODWORD(v29.f64[0])));
          *(_QWORD *)&v27.f64[0] = vcltzq_s32((int32x4_t)v27).u64[0];
          v24 = (float32x2_t)vbsl_s8(*(int8x8_t *)&v27.f64[0], *(int8x8_t *)&v28, (int8x8_t)v24);
          v40.f32[0] = *(float *)v29.f64 + *(float *)v29.f64;
          v23 = (float32x2_t)vbsl_s8(*(int8x8_t *)&v27.f64[0], (int8x8_t)vadd_f32(v23, v40), (int8x8_t)v23);
          if (v48 == 7)
            v26 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v29.f64[0], 0);
        }
        *a6 = v18;
        v25 = 0.0;
LABEL_29:
        v49 = v25 > 0.0 || v22;
        v154 = v16;
        v156 = v24;
        v158 = *(double *)&v23;
        if (v18 != 2 || ((v17 ^ 1) & 1) != 0 || (v49 & 1) != 0)
        {
          if ((v18 - 2) > 2)
            goto LABEL_65;
        }
        else
        {
          v151 = v26;
          *(float32x2_t *)&v164.f64[0] = RB::operator*(&v160, v24, v23);
          v164.f64[1] = v50;
          if (*(_BYTE *)(a1 + 45) == 1)
            goto LABEL_42;
          if ((v19 = v161, v160.f64[1] == 0.0) && v161.f64[0] == 0.0
            || v160.f64[0] == 0.0 && (HIDWORD(v19.f64[0]) = HIDWORD(v161.f64[1]), v161.f64[1] == 0.0))
          {
            LODWORD(v19.f64[0]) = 1000593162;
            if ((RB::Rect::is_integral((float32x2_t *)&v164, *(int32x2_t *)&v19.f64[0]) & 1) != 0
              || (v51.i32[0] = 0,
                  v54 = (int32x2_t)a3[21],
                  v55 = (uint32x2_t)vceq_s32(v54, (int32x2_t)0x8000000080000000),
                  v56 = (int8x8_t)vdup_lane_s32(vcgt_s32(v51, (int32x2_t)vpmin_u32(v55, v55)), 0),
                  v57 = (int8x8_t)vcvt_f32_s32(v54),
                  v58 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu),
                  RB::Rect::contains((float32x2_t *)&v164, (float32x2_t)vbsl_s8(v56, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20])), (float32x2_t)vbsl_s8(v56, v58, v57), *(double *)&v58, *(double *)&v56, v52, v53)))
            {
LABEL_42:
              v39 = 1;
              *a6 = 1;
              v59 = ***(_QWORD ***)a3;
              *(_QWORD *)a7 = *(_QWORD *)(v59 + 80);
              *(_OWORD *)(a7 + 8) = *(_OWORD *)(v59 + 88);
              RB::Bounds::Bounds((int32x2_t *)&v163, *(float32x2_t *)&v164.f64[0], *(float32x2_t *)&v164.f64[1]);
              *(_OWORD *)a8 = v163;
              return v39;
            }
          }
          LODWORD(v16) = v154;
          v24 = v156;
          v23 = *(float32x2_t *)&v158;
          v26 = v151;
        }
        if (*(_BYTE *)(a1 + 45) == 1)
          v76 = 1;
        else
          v76 = v49;
        if ((v76 & 1) == 0)
        {
          v77 = vmulq_n_f64(v160, v23.f32[0]);
          v78 = vmulq_n_f64(v161, v23.f32[1]);
          v79 = (int64x2_t)vmulq_f64(v77, v77);
          v80 = (int64x2_t)vmulq_f64(v78, v78);
          v19 = vaddq_f64((float64x2_t)vzip1q_s64(v80, v79), (float64x2_t)vzip2q_s64(v80, v79));
          if (v19.f64[0] >= v19.f64[1])
            v19.f64[0] = v19.f64[1];
          if (v19.f64[0] < 6.25)
          {
            *a6 = 11;
            *(float32x2_t *)(a2 + 24) = vmul_f32(v23, (float32x2_t)0x3F0000003F000000);
            v81 = 0uLL;
            *(_OWORD *)(a2 + 32) = 0u;
            *(_OWORD *)(a2 + 48) = 0u;
            goto LABEL_87;
          }
        }
LABEL_65:
        v82 = (int32x2_t)vmul_f32(v23, (float32x2_t)0x3F0000003F000000);
        v81 = 0uLL;
        *(_OWORD *)(a2 + 32) = 0u;
        v83 = (float32x4_t *)(a2 + 32);
        *(int32x2_t *)(a2 + 24) = v82;
        *(_OWORD *)(a2 + 48) = 0u;
        if ((v18 - 3) >= 3)
        {
          if ((v18 - 6) < 5)
            abort();
        }
        else
        {
          v84 = (float32x4_t)vdupq_n_s32(0x3C23D70Au);
          v81 = vmaxnmq_f32(v26, (float32x4_t)0);
          v85 = (vminvq_u32((uint32x4_t)vcgtq_f32(v84, v81)) & 0x80000000) == 0 || v22;
          if ((v85 & 1) != 0)
          {
            *v83 = v81;
            if ((vminvq_u32((uint32x4_t)vcgtq_f32(v84, vabdq_f32(v81, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v81.f32, 0)))) & 0x80000000) != 0)
            {
              if (v18 != 4)
                goto LABEL_86;
              v90.f32[0] = *(float *)(a1 + 32) * (float)(v81.f32[0] * 0.78431);
              v90.f32[1] = v81.f32[0] * 0.78431;
              *(float *)v27.f64 = v81.f32[0] * 0.41464;
              *(float32x2_t *)&v27.f64[0] = vdiv_f32(vsub_f32((float32x2_t)v82, v90), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v27.f64[0], 0));
              __asm { FMOV            V2.2S, #1.0 }
              v92 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(*(float32x2_t *)&v27.f64[0], (float32x2_t)vdup_n_s32(0xB8D1B717)), (int8x8_t)vcgt_f32(_D2, *(float32x2_t *)&v27.f64[0]));
              v28 = COERCE_DOUBLE(vpmax_u32(v92, v92));
              if ((LODWORD(v28) & 0x80000000) != 0)
              {
                v146 = vmaxnm_f32(*(float32x2_t *)&v27.f64[0], 0);
                *a6 = 10;
                v147 = *v83;
                v147.f32[1] = v81.f32[0] * 0.78431;
                *(int32x2_t *)&v147.u32[2] = vrev64_s32((int32x2_t)vsub_f32(_D2, vminnm_f32(v146, _D2)));
                *v83 = v147;
              }
              else
              {
LABEL_86:
                *(float32x2_t *)(a2 + 24) = vsub_f32((float32x2_t)v82, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v81.f32, 0));
              }
            }
            else
            {
              *(float *)v82.i32 = fminf(v23.f32[0], v23.f32[1]) * 0.5;
              v19 = (float64x2_t)vcgtq_f32(v81, (float32x4_t)vdupq_lane_s32(v82, 0));
              v86 = vmaxvq_u32((uint32x4_t)v19);
              if (v18 == 4)
                v87 = 7;
              else
                v87 = 6;
              if (v18 == 4)
                v88 = 9;
              else
                v88 = 8;
              if (v86 >= 0)
                v89 = v87;
              else
                v89 = v88;
              *a6 = v89;
            }
          }
          else
          {
            *a6 = 2;
            v81 = 0uLL;
          }
        }
LABEL_87:
        v149 = v81;
        if (v22)
        {
          v93 = *(float *)(a1 + 40);
          v94 = vrecpe_f32((float32x2_t)LODWORD(v93));
          v95 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v93), v94), v94);
          LODWORD(_S1) = vmul_f32(v95, vrecps_f32((float32x2_t)LODWORD(v93), v95)).u32[0];
          if ((*(_BYTE *)(a1 + 46) & 4) != 0)
          {
            _S1 = _S1 * 0.16956;
          }
          else if (*(_BYTE *)(a1 + 45) == 2)
          {
            _S1 = -_S1;
          }
          __asm { FCVT            H1, S1 }
          *(_WORD *)(a2 + 78) = _H1;
          if ((*(_BYTE *)(a1 + 46) & 4) == 0)
          {
            v101 = *(unsigned __int8 *)(a1 + 45);
            v102 = 0.0;
            if (v101 == 3)
              v99 = v93;
            else
              v99 = 0.0;
            if (v101 != 3)
              v102 = v93;
LABEL_103:
            v103 = v25 * 0.5;
            v104 = -0.0;
            if (v25 > 0.0)
              v104 = v25 * 0.5;
            v105 = v99 + v104;
            if ((LODWORD(v105) & 0x7FFFFFFFu) >= 0x7F800000)
              *(float *)&v28 = 0.0;
            else
              *(float *)&v28 = v105;
            if ((LODWORD(v102) & 0x7FFFFFFFu) >= 0x7F800000)
              v106 = 0.0;
            else
              v106 = v102;
            if (v25 > 0.0)
            {
              if (*(_BYTE *)(a1 + 45) == 1)
              {
                *(float *)(a2 + 72) = v103;
              }
              else
              {
                v107 = vrecpe_f32((float32x2_t)v16);
                v108 = vmul_f32(vrecps_f32((float32x2_t)v16, v107), v107);
                v109 = 0.5 * vmul_f32(v108, vrecps_f32((float32x2_t)v16, v108)).f32[0];
                v110 = v109 > v103;
                if (v109 > v103)
                  v103 = v109;
                _S1 = 1.0;
                if (v110)
                  _S1 = v25 * *(float *)&v16;
                *(float *)(a2 + 72) = v103;
                __asm { FCVT            H0, S1 }
                *(_WORD *)(a2 + 76) = _H0;
              }
            }
            v113 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
            *(int32x2_t *)&v19.f64[0] = vcgt_f32(v113, v23);
            v114 = (int8x8_t)vcltzq_s32((int32x4_t)v19).u64[0];
            v115 = (float32x2_t)vbsl_s8(v114, (int8x8_t)vsub_f32(v24, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v28, 0)), (int8x8_t)v24);
            v148 = *(int32x2_t *)&v28;
            v152 = v114;
            v116 = (float32x2_t)vbsl_s8(v114, (int8x8_t)vmla_n_f32(v23, (float32x2_t)0x4000000040000000, *(float *)&v28), (int8x8_t)v23);
            v117 = RB::operator*(&v160, v115, v116);
            v119 = (int32x2_t)RB::Bounds::Bounds((int32x2_t *)&v159, v117, v118);
            if (v17
              && ((*(_BYTE *)(a1 + 46) & 1) == 0
               || (RB::Bounds::contains((int32x2_t *)&v159, (int32x2_t)a3[20], (int32x2_t)a3[21]) & 1) != 0))
            {
              v120.i32[1] = HIDWORD(v154);
              if ((float)(vmuls_lane_f32(*(float *)&v154, *(float32x2_t *)&v158, 1) * *(float *)&v158) > 4096.0)
              {
                v121 = (float32x4_t)vdupq_lane_s32((int32x2_t)COERCE_UNSIGNED_INT(*(float *)v148.i32 + v106), 0);
                v122 = vaddq_f32(vmaxnmq_f32(vmulq_f32(vsubq_f32(v149, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)(a2 + 72), 0)), (float32x4_t)vdupq_n_s32(0x3E95F61Au)), (float32x4_t)0), v121);
                v121.f32[0] = fminf(*(float *)&v158, *((float *)&v158 + 1)) * 0.5;
                if ((vminvq_u32((uint32x4_t)vcgtq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v121.f32, 0), v122)) & 0x80000000) != 0)
                {
                  v144 = ***(_QWORD ***)a3;
                  *(_QWORD *)a7 = *(_QWORD *)(v144 + 104);
                  *(_OWORD *)(a7 + 8) = *(_OWORD *)(v144 + 112);
                  if (v25 <= 0.0 && (*(_BYTE *)(a1 + 46) & 1) == 0)
                  {
                    *(_QWORD *)(a7 + 24) = *(_QWORD *)(v144 + 128);
                    *(_OWORD *)(a7 + 32) = *(_OWORD *)(v144 + 136);
                  }
                  *(float *)v120.i32 = *((float *)&v158 + 1) + (float)(*(float *)v148.i32 * 2.0);
                  __asm { FMOV            V2.4S, #1.0 }
                  *(float32x4_t *)(a2 + 48) = vmulq_f32(vaddq_f32(v122, (float32x4_t)vdupq_lane_s32(v148, 0)), vdivq_f32(_Q2, (float32x4_t)vdupq_lane_s32(v120, 0)));
                  *(_OWORD *)a8 = v159;
                  return 1;
                }
              }
              *(_OWORD *)a8 = v159;
            }
            else
            {
              v119.i32[0] = 0;
              v155 = *a6;
              v123 = (int32x2_t)a3[21];
              v124 = (uint32x2_t)vceq_s32(v123, (int32x2_t)0x8000000080000000);
              v125 = (int8x8_t)vdup_lane_s32(vcgt_s32(v119, (int32x2_t)vpmin_u32(v124, v124)), 0);
              v126 = (float32x2_t)vbsl_s8(v125, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20]));
              v127 = (float32x2_t)vbsl_s8(v125, (int8x8_t)v113, (int8x8_t)vcvt_f32_s32(v123));
              v164 = v160;
              v165 = v161;
              v166[0] = v162;
              v128 = RB::AffineTransform::invert((RB::AffineTransform *)&v164);
              if (v128)
                v129 = &v164;
              else
                v129 = &v160;
              v130 = *v129;
              if (v128)
                v131 = &v165;
              else
                v131 = &v161;
              v132 = *v131;
              if (v128)
                v133 = (float64x2_t *)v166;
              else
                v133 = &v162;
              v134 = *v133;
              v164 = v130;
              v165 = v132;
              v166[0] = v134;
              *(float32x2_t *)&v163 = RB::operator*(&v164, v126, v127);
              *((_QWORD *)&v163 + 1) = v135;
              RB::Rect::Union((float32x2_t *)&v163, v156, *(float32x2_t *)&v158, v136, v137, v138, v139);
              *(float *)v140.i32 = fmaxf(*((float *)&v163 + 2), *((float *)&v163 + 3));
              v141 = (_QWORD **)a3[21];
              *(float32x2_t *)a8 = a3[20];
              *(_QWORD *)(a8 + 8) = v141;
            }
            v142 = ***(_QWORD ***)a3;
            *(_QWORD *)a7 = *(_QWORD *)(v142 + 80);
            *(_OWORD *)(a7 + 8) = *(_OWORD *)(v142 + 88);
            return 1;
          }
          v99 = (float)(v93 * 2.8) + 1.0;
        }
        else
        {
          v97 = vrecpe_f32((float32x2_t)v16);
          v98 = vmul_f32(vrecps_f32((float32x2_t)v16, v97), v97);
          LODWORD(v99) = vmul_f32(v98, vrecps_f32((float32x2_t)v16, v98)).u32[0];
        }
        v102 = 0.0;
        goto LABEL_103;
      }
LABEL_20:
      v18 = 3;
      goto LABEL_21;
    }
    if (v18 == 7)
      goto LABEL_20;
    *a6 = 0;
    if ((may_discard_alpha & 1) == 0)
      goto LABEL_46;
    return 0;
  }
  if (v18 != 1)
  {
    if (v18)
      goto LABEL_29;
    if ((may_discard_alpha & 1) != 0)
      return 0;
  }
LABEL_46:
  LODWORD(v19.f64[0]) = 0;
  v60 = (int32x2_t)a3[21];
  v61 = (uint32x2_t)vceq_s32(v60, (int32x2_t)0x8000000080000000);
  v62 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)&v19.f64[0], (int32x2_t)vpmin_u32(v61, v61)), 0);
  v63 = (float32x2_t)vbsl_s8(v62, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)a3[20]));
  v64 = (float32x2_t)vbsl_s8(v62, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v60));
  v164 = v160;
  v165 = v161;
  v166[0] = v162;
  v65 = RB::AffineTransform::invert((RB::AffineTransform *)&v164);
  if (v65)
    v66 = &v164;
  else
    v66 = &v160;
  v67 = *v66;
  if (v65)
    v68 = &v165;
  else
    v68 = &v161;
  v69 = *v68;
  if (v65)
    v70 = (float64x2_t *)v166;
  else
    v70 = &v162;
  v71 = *v70;
  v164 = v67;
  v165 = v69;
  v166[0] = v71;
  *(float32x2_t *)&v72 = RB::operator*(&v164, v63, v64);
  v39 = 1;
  v74 = ***(_QWORD ***)a3;
  *(_QWORD *)a7 = *(_QWORD *)(v74 + 80);
  *(_OWORD *)(a7 + 8) = *(_OWORD *)(v74 + 88);
  v75 = (_QWORD **)a3[21];
  *(float32x2_t *)a8 = a3[20];
  *(_QWORD *)(a8 + 8) = v75;
  return v39;
}

float32x2_t RB::Coverage::Primitive::bounds(float32x2_t *this, float64x2_t *a2, int8x16_t a3, double a4, int8x16_t _Q2, int32x4_t a6)
{
  float32x2_t v10;
  int32x4_t v11;
  uint64_t v12;
  float32x2_t result;
  uint32x2_t v14;
  unsigned __int32 v15;
  int8x8_t v16;

  switch(this[5].i8[4])
  {
    case 1:
      return (float32x2_t)0x100000001000000;
    case 2:
    case 3:
    case 4:
    case 5:
    case 7:
      goto LABEL_2;
    case 6:
    case 8:
      if ((this[5].i8[6] & 1) == 0)
      {
        v14 = (uint32x2_t)vceqz_f32(this[1]);
        v15 = vpmin_u32(v14, v14).u32[0];
        result = 0;
        if ((v15 & 0x80000000) != 0)
          return result;
      }
LABEL_2:
      if ((this[5].i8[6] & 1) != 0)
        return (float32x2_t)0x100000001000000;
      __asm { FMOV            V2.2S, #1.0 }
      _Q2.i32[0] = this[4].i32[0];
      *(float32x2_t *)a3.i8 = vmul_f32(*this, *(float32x2_t *)_Q2.i8);
      v10 = vmul_f32(this[1], *(float32x2_t *)_Q2.i8);
      *(float32x2_t *)_Q2.i8 = vadd_f32(v10, *(float32x2_t *)a3.i8);
      *(int32x2_t *)a6.i8 = vcltz_f32(v10);
      v11 = vcltzq_s32(a6);
      a3.i64[0] = vbslq_s8((int8x16_t)v11, _Q2, a3).u64[0];
      v12 = *(_QWORD *)&v10 & 0x7FFFFFFF7FFFFFFFLL;
      _Q2.i32[0] = this[4].i32[1];
      if (*(float *)_Q2.i32 > 0.0)
      {
        v11.i32[0] = 1060439283;
        if (this[5].i8[4] != 8)
          *(float *)v11.i32 = 0.5;
        *(float *)_Q2.i32 = *(float *)_Q2.i32 * *(float *)v11.i32;
        *(int32x2_t *)v11.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), (float32x2_t)v12);
        v11 = vcltzq_s32(v11);
        *(int8x8_t *)a3.i8 = vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vsub_f32(*(float32x2_t *)a3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q2.i8, 0)), *(int8x8_t *)a3.i8);
        v12 = (uint64_t)vbsl_s8(*(int8x8_t *)v11.i8, (int8x8_t)vmla_n_f32((float32x2_t)v12, (float32x2_t)0x4000000040000000, *(float *)_Q2.i32), (int8x8_t)v12);
      }
      if ((this[5].i8[6] & 4) != 0)
      {
        *(float *)_Q2.i32 = this[5].f32[0] * 2.8;
      }
      else
      {
        if (this[5].i8[5] != 3)
          return RB::operator*(a2, *(float32x2_t *)a3.i8, (float32x2_t)v12);
        _Q2.i32[0] = this[5].i32[0];
      }
      *(int32x2_t *)v11.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), (float32x2_t)v12);
      v16 = (int8x8_t)vcltzq_s32(v11).u64[0];
      *(int8x8_t *)a3.i8 = vbsl_s8(v16, (int8x8_t)vsub_f32(*(float32x2_t *)a3.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)_Q2.i8, 0)), *(int8x8_t *)a3.i8);
      v12 = (uint64_t)vbsl_s8(v16, (int8x8_t)vmla_n_f32((float32x2_t)v12, (float32x2_t)0x4000000040000000, *(float *)_Q2.i32), (int8x8_t)v12);
      return RB::operator*(a2, *(float32x2_t *)a3.i8, (float32x2_t)v12);
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      return 0;
  }
}

float32x2_t RB::operator*(float64x2_t *a1, float32x2_t result, float32x2_t a3)
{
  uint32x2_t v3;
  uint32x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;

  v3 = (uint32x2_t)vcge_f32(vabs_f32(a3), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    return result;
  v4 = (uint32x2_t)vclez_f32(a3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0)
  {
    v8 = vcvtq_f64_f32(result);
    return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], *a1, v8.f64[0]), a1[1], v8, 1));
  }
  v5 = *a1;
  if (a1->f64[1] != 0.0)
  {
    v6 = a1[1];
    goto LABEL_13;
  }
  v6 = a1[1];
  if (v6.f64[0] != 0.0)
  {
LABEL_13:
    v9 = vcvtq_f64_f32(result);
    v10 = vcvtq_f64_f32(vadd_f32((float32x2_t)a3.u32[0], result));
    v11 = vcvtq_f64_f32(vadd_f32(a3, result));
    a3.i32[0] = 0;
    v12 = vcvtq_f64_f32(vadd_f32(a3, result));
    return vminnm_f32(vminnm_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v9.f64[0]), v6, v9, 1)), vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v10.f64[0]), v6, v10, 1))), vminnm_f32(vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v11.f64[0]), v6, v11, 1)), vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a1[2], v5, v12.f64[0]), v6, v12, 1))));
  }
  if (v5.f64[0] == 1.0 && v6.f64[1] == 1.0)
  {
    return vadd_f32(result, vcvt_f32_f64(a1[2]));
  }
  else
  {
    v5.f64[1] = a1[1].f64[1];
    return vminnm_f32(vcvt_f32_f64(vmlaq_f64(a1[2], vcvtq_f64_f32(result), v5)), vcvt_f32_f64(vmlaq_f64(a1[2], vcvtq_f64_f32(vadd_f32(a3, result)), v5)));
  }
}

double RB::Coverage::Path::bounds(RBPath this)
{
  RBPathCallbacks *callbacks;
  void *info;
  float64x2_t *v3;
  float64x2_t v4;
  __int128 v5;
  __int128 v6;
  float32x2_t v7;
  __int128 v8;
  float64x2_t v9;
  float32x2_t v10;
  float v11;
  int32x2_t v12;
  int32x4_t v13;
  CGFloat y;
  CGFloat x;
  CGFloat height;
  CGFloat width;
  float64x2_t v19;
  __int128 v20;
  __int128 v21;
  CGRect v22;

  callbacks = this.callbacks;
  this.callbacks = (RBPathCallbacks *)*((_QWORD *)this.info + 1);
  if (this.callbacks == (RBPathCallbacks *)&empty_path_callbacks)
    return 0.0;
  info = this.info;
  v3 = (float64x2_t *)*((_QWORD *)this.info + 2);
  if (v3)
  {
    v4.f64[0] = RB::operator*(v3, (float64x2_t *)callbacks);
    v19 = v4;
    v20 = v5;
    v21 = v6;
    this.callbacks = (RBPathCallbacks *)*((_QWORD *)info + 1);
  }
  else
  {
    v8 = *((_OWORD *)callbacks + 1);
    v19 = *(float64x2_t *)callbacks;
    v20 = v8;
    v21 = *((_OWORD *)callbacks + 2);
  }
  this.info = *(void **)info;
  *(_QWORD *)&v22.origin.x = *(_OWORD *)&RBPathBoundingRect(this, (const RB::AffineTransform *)&v19);
  y = v22.origin.y;
  x = v22.origin.x;
  height = v22.size.height;
  width = v22.size.width;
  *(double *)&v7 = 0.0;
  if (!CGRectIsNull(v22))
  {
    v9.f64[0] = x;
    v9.f64[1] = y;
    v7 = vcvt_f32_f64(v9);
    v9.f64[0] = width;
    v9.f64[1] = height;
    v10 = vcvt_f32_f64(v9);
    if (*((_BYTE *)info + 29) == 3)
    {
      if (*((float *)info + 6) >= 0.0)
        v11 = *((float *)info + 6);
      else
        v11 = 0.0;
      *(float *)v12.i32 = v11 * RB::AffineTransform::scale((float64x2_t *)callbacks);
      *(int32x2_t *)v13.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
      v7 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v13), (int8x8_t)vsub_f32(v7, (float32x2_t)vdup_lane_s32(v12, 0)), (int8x8_t)v7);
    }
  }
  return *(double *)&v7;
}

float32x2_t RB::Bounds::Bounds(int32x2_t *a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v3;
  float32x2_t result;
  uint32x2_t v5;
  uint32x2_t v6;

  v3 = vrndm_f32(a2);
  result = vsub_f32(vrndp_f32(vadd_f32(a3, a2)), v3);
  v5 = (uint32x2_t)vcgt_f32((float32x2_t)vdup_n_s32(0x4E800000u), result);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    *a1 = vcvt_s32_f32(v3);
    v6 = (uint32x2_t)vcgtz_f32(result);
    if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
    {
      result = (float32x2_t)vcvt_s32_f32(result);
      a1[1] = (int32x2_t)result;
    }
    else
    {
      a1[1] = 0;
    }
  }
  else
  {
    result = (float32x2_t)vdup_n_s32(0xC0000001);
    *a1 = (int32x2_t)result;
    a1[1] = (int32x2_t)0x8000000080000000;
  }
  return result;
}

double RB::operator*(float64x2_t *a1, float64x2_t *a2)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vmlaq_laneq_f64(vmulq_n_f64(*a2, a1->f64[0]), a2[1], *a1, 1);
  return result;
}

float64x2_t RBPathBoundingRect(RBPath a1, const RB::AffineTransform *a2)
{
  RBPathCallbacks *callbacks;
  const CGPath *info;
  void (*v5)(void *);
  float64x2_t result;
  __int128 v10;
  uint64_t (*v11)(void *);
  __int128 v12;
  void (*v13)(void *, const RB::AffineTransform *, RBPathCallbacks *);
  unsigned int (*v14)(void *, RBPathCallbacks *);
  CGAffineTransform v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  float64_t v19;
  char v20;
  uint64_t v21;

  callbacks = a1.callbacks;
  info = (const CGPath *)a1.info;
  v21 = *MEMORY[0x24BDAC8D0];
  if ((*((_BYTE *)a1.callbacks + 2) & 1) != 0)
  {
    v13 = (void (*)(void *, const RB::AffineTransform *, RBPathCallbacks *))*((_QWORD *)a1.callbacks + 8);
    if (v13)
    {
      v13(a1.info, a2, a1.callbacks);
      return result;
    }
    v14 = (unsigned int (*)(void *, RBPathCallbacks *))*((_QWORD *)a1.callbacks + 6);
    if (!v14 || !v14(a1.info, a1.callbacks))
      goto LABEL_16;
    goto LABEL_7;
  }
  v5 = (void (*)(void *))*((_QWORD *)a1.callbacks + 8);
  if (v5)
  {
    v5(a1.info);
    if (a2)
    {
      v10 = *((_OWORD *)a2 + 1);
      *(_OWORD *)&v15.a = *(_OWORD *)a2;
      *(_OWORD *)&v15.c = v10;
      *(_OWORD *)&v15.tx = *((_OWORD *)a2 + 2);
      *(_QWORD *)&result.f64[0] = (unint64_t)CGRectApplyAffineTransform(*(CGRect *)result.f64, &v15);
    }
    return result;
  }
  v11 = (uint64_t (*)(void *))*((_QWORD *)a1.callbacks + 6);
  if (v11 && (v11(a1.info) & 1) != 0)
  {
LABEL_7:
    if (a2)
    {
      v12 = *((_OWORD *)a2 + 1);
      v16 = *(_OWORD *)a2;
      v17 = v12;
      v18 = *((_OWORD *)a2 + 2);
    }
    else
    {
      v16 = xmmword_209BD5290;
      v17 = xmmword_209BD52A0;
      v18 = 0uLL;
    }
    v20 = 0;
    if (v20)
    {
      result.f64[0] = v19;
      return result;
    }
  }
LABEL_16:
  *(_QWORD *)&v16 = &unk_24C229408;
  *((int32x2_t *)&v16 + 1) = vdup_n_s32(0x7F800000u);
  *(_QWORD *)&v17 = 0x7F0000007FLL;
  RBPathMap(info, callbacks, (uint64_t (**)(RB::Path::Mapper *__hidden))&v16, (float64x2_t *)a2);
  if ((DWORD2(v16) & 0x7FFFFFFFu) > 0x7F7FFFFF)
    return *(float64x2_t *)MEMORY[0x24BDBF070];
  else
    return vcvtq_f64_f32(*(float32x2_t *)((char *)&v16 + 8));
}

void RB::Path::Storage::bounding_rect(RBPath this)
{
  unint64_t *info;
  int v3;
  double BoundingRect;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned __int8 *v15;
  int v16;
  float v17;
  float v18;
  float v19;
  float v20;
  unint64_t v21;
  float *v22;
  char v24;

  info = (unint64_t *)this.info;
  if (atomic_load((unint64_t *)this.info))
    return;
  v3 = *((_DWORD *)this.info + 2);
  if ((v3 & 8) != 0)
  {
    v15 = (unsigned __int8 *)this.info + 16;
    if ((v3 & 1) != 0)
      v15 = (unsigned __int8 *)*((_QWORD *)this.info + 2);
    v16 = *v15;
    if ((v16 - 69) < 7 || (v16 - 37) < 7 || (v16 - 5) <= 6)
      return;
  }
  this.callbacks = (RBPathCallbacks *)&RB::Path::Storage::bounding_rect(void)const::callbacks;
  BoundingRect = RBPathGetBoundingRect(this);
  v8 = BoundingRect;
  v9 = v5;
  v10 = v6;
  v11 = v7;
  v12 = *((unsigned int *)info + 2);
  if ((v12 & 1) != 0)
  {
    v17 = BoundingRect;
    v18 = v5;
    v19 = v6;
    v14 = 42;
    v20 = v7;
LABEL_17:
    v21 = (unint64_t)info + v14;
    goto LABEL_18;
  }
  v13 = ((unint64_t)info + ((v12 >> 8) & 0xFFF) + 19) & 0xFFFFFFFFFFFFFFFCLL;
  if ((unint64_t)info + (v12 >> 20) - v13 + 16 < 0x10)
    v14 = operator new[]() | 1;
  else
    v14 = (v13 - (_QWORD)info) | 2;
  v17 = v8;
  v18 = v9;
  v19 = v10;
  v21 = v14;
  v20 = v11;
  if ((v14 & 2) != 0)
    goto LABEL_17;
LABEL_18:
  v22 = (float *)(v21 & 0xFFFFFFFFFFFFFFFCLL);
  *v22 = v17;
  v22[1] = v18;
  v22[2] = v19;
  v22[3] = v20;
  while (!__ldaxr(info))
  {
    if (!__stlxr(v14, info))
    {
      v24 = 1;
      if ((v14 & 1) == 0)
        return;
      goto LABEL_24;
    }
  }
  v24 = 0;
  __clrex();
  if ((v14 & 1) == 0)
    return;
LABEL_24:
  if ((v24 & 1) == 0 && (v14 & 0xFFFFFFFFFFFFFFFCLL) != 0)
    MEMORY[0x20BD1652C](v14 & 0xFFFFFFFFFFFFFFFCLL, 0x1000C8052888210);
}

uint64_t RB::Path::Object::$_12::__invoke(RB::Path::Object::$_12 *this, const void *a2)
{
  int v2;
  uint64_t v3;

  v2 = *((_DWORD *)this + 6);
  v3 = 1;
  if ((v2 & 2) != 0)
    v3 = 2;
  if ((v2 & 4) != 0)
    return 3;
  else
    return v3;
}

BOOL RB::may_discard_shape(int a1)
{
  return (a1 - 24) < 0xFFFFFFFB;
}

uint64_t RB::Coverage::`anonymous namespace'::set_primitive_rect(uint64_t result, float32x2_t *a2, float64x2_t *a3, int a4, double a5, double a6)
{
  float64x2_t v6;
  float64x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x4_t v19;
  int8x16_t v20;

  v6 = a3[1];
  v7 = vmlaq_n_f64(vmlaq_n_f64(a3[2], *a3, *(float *)&a5), v6, *((float *)&a5 + 1));
  v8 = a2[14];
  v8.i32[1] = vneg_f32(v8).i32[1];
  *(float32x2_t *)result = vmul_f32(v8, vcvt_f32_f64(vmulq_n_f64(*a3, *(float *)&a6)));
  *(float32x2_t *)(result + 8) = vmul_f32(v8, vcvt_f32_f64(vmulq_n_f64(v6, *((float *)&a6 + 1))));
  v9 = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v7), v8);
  v10 = vrecpe_f32((float32x2_t)HIDWORD(a6));
  v11 = vmul_f32(vrecps_f32((float32x2_t)HIDWORD(a6), v10), v10);
  v12 = vmul_f32(v11, vrecps_f32((float32x2_t)HIDWORD(a6), v11));
  *(_DWORD *)(result + 64) = vmul_f32(v12, *(float32x2_t *)&a6).u32[0];
  _D2 = vmul_n_f32(*(float32x2_t *)(result + 24), v12.f32[0]);
  *(float32x2_t *)(result + 16) = v9;
  *(float32x2_t *)(result + 24) = _D2;
  *(float *)(result + 72) = *(float *)(result + 72) * v12.f32[0];
  _D2.i16[0] = *(_WORD *)(result + 78);
  __asm { FCVT            S2, H2 }
  _S1 = vmuls_lane_f32(_D2.f32[0], *(float32x2_t *)&a6, 1);
  __asm { FCVT            H1, S1 }
  *(_WORD *)(result + 78) = LOWORD(_S1);
  if ((a4 - 6) < 4)
  {
    v19 = vmulq_n_f32(*(float32x4_t *)(result + 32), v12.f32[0]);
LABEL_5:
    *(float32x4_t *)(result + 32) = v19;
    return result;
  }
  if ((a4 - 3) < 3)
  {
    *(float *)(result + 32) = *(float *)(result + 32) * v12.f32[0];
    return result;
  }
  if (a4 == 10)
  {
    v20 = *(int8x16_t *)(result + 32);
    *(float32x2_t *)v19.f32 = vmul_n_f32(*(float32x2_t *)v20.i8, v12.f32[0]);
    v19.i64[1] = vextq_s8(v20, v20, 8uLL).u64[0];
    goto LABEL_5;
  }
  return result;
}

BOOL RB::Rect::inset(float32x2_t *this, float32x2_t a2, float32_t a3)
{
  float32x2_t v3;
  uint32x2_t v4;
  int32x2_t v5;
  float32x2_t v6;
  uint32x2_t v7;
  int32x2_t v8;
  __int32 v9;
  int8x8_t v10;
  _BOOL8 v11;

  v3 = this[1];
  v4 = (uint32x2_t)vceq_f32(v3, (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  v5 = (int32x2_t)vpmax_u32(v4, v4);
  if (v5.i32[0] < 0)
    return 1;
  a2.f32[1] = a3;
  v6 = vmla_f32(v3, (float32x2_t)0xC0000000C0000000, a2);
  v7 = (uint32x2_t)vcltz_f32(v6);
  v8 = (int32x2_t)vpmax_u32(v7, v7);
  v5.i32[0] = -1;
  v9 = v8.i32[0];
  v10 = (int8x8_t)vdup_lane_s32(vcgt_s32(v8, v5), 0);
  v11 = v9 >= 0;
  *this = vadd_f32(*this, (float32x2_t)vbsl_s8(v10, (int8x8_t)a2, (int8x8_t)vmul_f32(v6, (float32x2_t)0x3F0000003F000000)));
  this[1] = (float32x2_t)vand_s8((int8x8_t)v6, v10);
  return v11;
}

uint64_t RB::Rect::is_integral(float32x2_t *this, int32x2_t a2)
{
  float32x2_t v2;
  uint32x2_t v3;
  float32x2_t v5;
  uint32x2_t v6;

  v2 = (float32x2_t)vdup_lane_s32(a2, 0);
  v3 = (uint32x2_t)vcge_f32(v2, vabd_f32(*this, vrndm_f32(*this)));
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0)
    return 0;
  v5 = vadd_f32(this[1], *this);
  v6 = (uint32x2_t)vcge_f32(v2, vabd_f32(v5, vrndm_f32(v5)));
  return vpmin_u32(v6, v6).u32[0] >> 31;
}

RB::UntypedTable *RB::UntypedTable::UntypedTable(RB::UntypedTable *this, unint64_t (*a2)(RB *this, const void *a2), BOOL (*a3)(RB *this, RB *a2, const void *a3), void (*a4)(void *), void (*a5)(void *), RB::Heap *a6)
{
  unint64_t (*v9)(RB *, const void *);
  BOOL (*v10)(RB *, RB *, const void *);
  RB::Heap *v11;
  RB::Heap *v12;
  BOOL v13;
  char v14;

  v9 = RB::pointer_hash;
  if (a2)
    v9 = a2;
  if (a3)
    v10 = a3;
  else
    v10 = RB::pointer_compare;
  *(_QWORD *)this = v9;
  *((_QWORD *)this + 1) = v10;
  *((_QWORD *)this + 2) = a4;
  *((_QWORD *)this + 3) = a5;
  v11 = a6;
  if (!a6)
  {
    v12 = (RB::Heap *)operator new();
    v11 = RB::Heap::Heap(v12, 0, 0, 0x200uLL);
  }
  *((_QWORD *)this + 4) = v11;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *((_DWORD *)this + 18) = 0;
  *((_BYTE *)this + 76) = a6 == 0;
  if (a3)
    v13 = a3 == RB::pointer_compare;
  else
    v13 = 1;
  v14 = v13;
  *((_BYTE *)this + 77) = v14;
  return this;
}

unsigned int *make_contents(unsigned int *result)
{
  if (!*((_QWORD *)result + 3))
    return RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)(result + 4));
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 168);
}

double RBPathGetBoundingRect(RBPath a1)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&RBPathBoundingRect(a1, 0);
  return result;
}

BOOL RBFillIsClear(RBFill *a1)
{
  _BOOL8 result;

  switch(a1->_data.type)
  {
    case 1:
      _H0 = *(_WORD *)&a1->_data.data[18];
      __asm { FCVT            S0, H0 }
      result = _S0 == 0.0;
      break;
    case 2:
    case 3:
    case 4:
    case 5:
      result = 0;
      break;
    default:
      result = 1;
      break;
  }
  return result;
}

void RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>(uint64_t a1, float32x2_t *this, double a3, double a4, int8x16_t a5, int32x4_t a6)
{
  float32x2_t *v8;
  float32x2_t v9;
  float32x2_t v10;
  double v11;
  double v12;
  double v13;
  int32x4_t v14;
  float64x2_t v15[2];
  uint64_t v16;
  uint64_t v17;

  v8 = *(float32x2_t **)(a1 + 40);
  if (!v8
    || (v15[0] = (float64x2_t)xmmword_209BD5290,
        v15[1] = (float64x2_t)xmmword_209BD52A0,
        v16 = 0,
        v17 = 0,
        v9 = RB::Coverage::Primitive::bounds(this, v15, (int8x16_t)xmmword_209BD5290, 0.0, a5, a6),
        (RB::Rect::intersects(v8, v9, v10, v11, v12, v13, v14) & 1) != 0))
  {
    *(_QWORD *)&v15[0].f64[0] = a1;
    *(_QWORD *)&v15[0].f64[1] = this;
    RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>>(*(_QWORD *)(a1 + 32), (__int128 **)v15);
  }
}

void RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>>(uint64_t a1, __int128 **a2)
{
  switch(*(_DWORD *)a1)
  {
    case 1:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Color>(a2, a1 + 16);
      break;
    case 2:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Gradient>(a2, (uint64_t *)(a1 + 16));
      break;
    case 3:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::MeshGradient>(a2, a1 + 16);
      break;
    case 4:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (RB::ImageTexture *)(a1 + 16));
      break;
    case 5:
      RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Custom>(a2, a1 + 16);
      break;
    default:
      return;
  }
}

uint64_t RB::Rect::contains(float32x2_t *a1, float32x2_t a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v7;
  uint32x2_t v8;
  int32x4_t v9;
  float32x2_t v10;
  float32x2_t v11;
  uint32x2_t v12;
  uint32x2_t v14;

  v7 = a1[1];
  v8 = (uint32x2_t)vceqz_f32(v7);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0)
    return 0;
  *(int32x2_t *)a7.i8 = vcltz_f32(v7);
  v9 = vcltzq_s32(a7);
  v10 = (float32x2_t)vbsl_s8(*(int8x8_t *)v9.i8, (int8x8_t)vadd_f32(*a1, v7), (int8x8_t)*a1);
  *(int32x2_t *)v9.i8 = vcltz_f32(a3);
  v11 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v9), (int8x8_t)vadd_f32(a3, a2), (int8x8_t)a2);
  v12 = (uint32x2_t)vcge_f32(v11, v10);
  if ((vpmin_u32(v12, v12).u32[0] & 0x80000000) == 0)
    return 0;
  v14 = (uint32x2_t)vcge_f32(vadd_f32(v10, (float32x2_t)(*(_QWORD *)&v7 & 0x7FFFFFFF7FFFFFFFLL)), vadd_f32(v11, vabs_f32(a3)));
  return vpmin_u32(v14, v14).u32[0] >> 31;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Gradient>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[3];

  v4 = *a1;
  if (*(_BYTE *)(*a1 + 48))
  {
    v6[0] = off_24C2260F8;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    v4 = *a1;
  }
  result = *(_QWORD **)(v4 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    v4 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

float32x2_t *RB::Rect::intersect(float32x2_t *result, float32x2_t a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  float32x2_t v7;
  uint32x2_t v8;
  uint32x2_t v9;
  int32x4_t v10;
  float32x2_t v11;
  float32x2_t v12;
  uint32x2_t v13;

  v7 = result[1];
  v8 = (uint32x2_t)vceqz_f32(v7);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) == 0)
  {
    v9 = (uint32x2_t)vceqz_f32(a3);
    if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
      goto LABEL_6;
    *(int32x2_t *)a7.i8 = vcltz_f32(v7);
    v10 = vcltzq_s32(a7);
    v11 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vadd_f32(*result, v7), (int8x8_t)*result);
    *(int32x2_t *)v10.i8 = vcltz_f32(a3);
    v12 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v10), (int8x8_t)vadd_f32(a3, a2), (int8x8_t)a2);
    a2 = vmaxnm_f32(v11, v12);
    a3 = vsub_f32(vminnm_f32(vadd_f32(v11, vabs_f32(v7)), vadd_f32(v12, (float32x2_t)(*(_QWORD *)&a3 & 0x7FFFFFFF7FFFFFFFLL))), a2);
    v13 = (uint32x2_t)vcgtz_f32(a3);
    if ((vpmin_u32(v13, v13).u32[0] & 0x80000000) != 0)
    {
LABEL_6:
      *result = a2;
      result[1] = a3;
    }
    else
    {
      *result = 0;
      result[1] = 0;
    }
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>(size_t *a1, const RB::DisplayList::Clip **a2, const RB::DisplayList::ClipNode **a3)
{
  RB::DisplayList::ClipNode *v5;

  v5 = (RB::DisplayList::ClipNode *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v5 + 32 > a1[3])
    v5 = (RB::DisplayList::ClipNode *)RB::Heap::alloc_slow(a1, 0x20uLL, 7);
  else
    a1[2] = (size_t)v5 + 32;
  return RB::DisplayList::ClipNode::ClipNode(v5, *a2, *a3);
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

double _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  __int16 v16;
  char v17;
  __int128 v18;
  __int128 v19;
  __int16 v20;
  double result;

  v13 = *((_QWORD *)this + 3);
  v14 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v14 + 128 > v13)
    v14 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  else
    *((_QWORD *)this + 2) = v14 + 128;
  v15 = *a5;
  v16 = *a6;
  v17 = *a7;
  *(_QWORD *)(v14 + 16) = 0;
  *(_QWORD *)(v14 + 24) = 0;
  *(_DWORD *)(v14 + 40) = 0;
  *(_QWORD *)(v14 + 32) = 0;
  *(_WORD *)(v14 + 44) = v16;
  *(_WORD *)(v14 + 46) = v17 & 0x3F | 0x4000;
  *(_QWORD *)v14 = off_24C2273D8;
  *(_QWORD *)(v14 + 48) = v15;
  v18 = *a3;
  v19 = a3[1];
  *(_OWORD *)(v14 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v14 + 64) = v18;
  *(_OWORD *)(v14 + 80) = v19;
  if (*(_BYTE *)(a4 + 9))
    v20 = *(_WORD *)(a4 + 8);
  else
    v20 = 0;
  result = *(double *)a4;
  *(_QWORD *)(v14 + 112) = *(_QWORD *)a4;
  *(_WORD *)(v14 + 120) = v20;
  *(_QWORD *)v14 = &off_24C225C38;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 14);
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

void RB::DisplayList::Style::roi(RB::DisplayList::Style *this, float32x2_t *a2, float64x2_t *a3)
{
  RB::DisplayList::Style *v5;
  int v6;
  unsigned int v7;
  _BYTE *v8;
  uint64_t i;
  _BYTE *v10;
  _QWORD *v11;
  float32x2_t *v12;
  double v13;
  double v14;
  double v15;
  int32x4_t v16;
  _BYTE __dst[512];
  void *v18;
  uint64_t v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  v18 = 0;
  v19 = 0x4000000000;
  if (this)
  {
    v5 = this;
    v6 = 0;
    do
    {
      v7 = v6 + 1;
      if (HIDWORD(v19) < v6 + 1)
      {
        RB::vector<RB::DisplayList::Style const*,64ul,unsigned int>::reserve_slow(__dst, v7);
        v6 = v19;
        v7 = v19 + 1;
      }
      v8 = v18;
      if (!v18)
        v8 = __dst;
      *(_QWORD *)&v8[8 * v6] = v5;
      LODWORD(v19) = v7;
      v5 = (RB::DisplayList::Style *)*((_QWORD *)v5 + 4);
      v6 = v7;
    }
    while (v5);
  }
  else
  {
    v7 = 0;
  }
  for (i = 8 * v7 - 8; i != -8; i -= 8)
  {
    v10 = v18;
    if (!v18)
      v10 = __dst;
    v11 = *(_QWORD **)&v10[i];
    v12 = (float32x2_t *)v11[3];
    if (v12)
    {
      RB::Rect::move_identity(a2, a3);
      RB::Rect::intersect(a2, v12[2], v12[3], v13, v14, v15, v16);
    }
    (*(void (**)(_QWORD *, float32x2_t *, float64x2_t *))(*v11 + 48))(v11, a2, a3);
  }
  if (v18)
    free(v18);
}

void sub_209AD2A78(_Unwind_Exception *a1)
{
  if (STACK[0x208])
    free((void *)STACK[0x208]);
  _Unwind_Resume(a1);
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Gradient>(__int128 **a1, uint64_t *a2)
{
  __int128 *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Glyphs>(uint64_t a1, float32x2_t *this)
{
  float32x2_t *v4;
  double v5;
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  unint64_t result;
  float64x2_t v12[2];
  uint64_t v13;
  uint64_t v14;

  v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_209BD5290,
        v12[1] = (float64x2_t)xmmword_209BD52A0,
        v13 = 0,
        v14 = 0,
        v5 = RB::Coverage::Glyphs::bounds(this, v12, 0),
        result = RB::Rect::intersects(v4, *(float32x2_t *)&v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(_QWORD *)&v12[0].f64[0] = a1;
    *(_QWORD *)&v12[0].f64[1] = this;
    return RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>>(*(_QWORD *)(a1 + 32), (RB::Coverage::Glyphs **)v12);
  }
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Color>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  RB::Coverage::Glyphs *v3;
  _QWORD *result;

  v3 = *a1;
  result = (_QWORD *)*((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

unint64_t RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>>(unint64_t result, RB::Coverage::Glyphs **a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      result = (unint64_t)RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Color>(a2, result + 16);
      break;
    case 2:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Gradient>(a2, (uint64_t *)(result + 16));
      break;
    case 3:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::MeshGradient>(a2, result + 16);
      break;
    case 4:
      result = (unint64_t)RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 16));
      break;
    case 5:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Custom>(a2, result + 16);
      break;
    default:
      return result;
  }
  return result;
}

void RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>::map_roi(uint64_t a1, RB::DisplayList *a2, float64x2_t *a3)
{
  const RB::AffineTransform *v6;
  float64x2_t v7[2];
  uint64_t v8;
  uint64_t v9;

  v7[0] = (float64x2_t)xmmword_209BD5290;
  v7[1] = (float64x2_t)xmmword_209BD52A0;
  v8 = 0;
  v9 = 0;
  RB::GeometryStyle::Rotation::set_affine_transform((RB::GeometryStyle::Rotation *)(a1 + 56), v7);
  RB::DisplayList::affine_style_roi(a2, a3, v7, *(int8x16_t **)(a1 + 16), v6);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 18);
}

uint64_t RB::DisplayList::Layer::append_layer_items(uint64_t result, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  _QWORD *v5;

  if (*(_QWORD *)a2)
  {
    v3 = result;
    v4 = *(_QWORD *)(result + 8);
    if (v4)
      v5 = (_QWORD *)(v4 + 8);
    else
      v5 = (_QWORD *)result;
    *v5 = *(_QWORD *)a2;
    *(_QWORD *)(result + 8) = *(_QWORD *)(a2 + 8);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(result + 60) |= *(_DWORD *)(a2 + 60) & 0x1190;
    *(_DWORD *)(a2 + 60) &= 0xFFFFEE6F;
    result = RB::max_color_depth(*(unsigned __int8 *)(result + 65), *(unsigned __int8 *)(a2 + 65));
    *(_BYTE *)(v3 + 65) = result;
    *(_BYTE *)(a2 + 65) = 0;
  }
  return result;
}

void RB::DisplayList::ShadowStyle::map_roi(float64x2_t **this, float32x2_t *a2, float64x2_t *a3)
{
  RB::DisplayList::ShadowStyle::bounds(this, a2, a3, 1);
}

uint64_t RB::may_discard_alpha(unsigned int a1)
{
  return (a1 > 0x17) | (0x6FD64u >> a1) & 1;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 160 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 160;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C2257D8;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::`anonymous namespace'::TransformedRect::TransformedRect(uint64_t a1, float64x2_t *a2, float32x2_t a3, int8x8_t a4)
{
  unint64_t i;
  uint64_t j;
  float64x2_t v6;
  float64x2_t v7;
  uint64_t v8;
  uint64_t v9;
  float32x2_t result;
  uint64_t v11;
  uint64_t v12;

  for (i = 0; i != 4; ++i)
    *(float32x2_t *)(a1 + 8 * i) = vadd_f32((float32x2_t)vand_s8(a4, (int8x8_t)vcltz_s32(vshl_n_s32((int32x2_t)__PAIR64__(i > 1, (i - 1) < 2), 0x1FuLL))), a3);
  for (j = 0; j != 32; j += 8)
  {
    v6 = vcvtq_f64_f32(*(float32x2_t *)(a1 + j));
    v7 = a2[1];
    *(float32x2_t *)(a1 + j) = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, v6.f64[0]), v7, v6, 1));
  }
  v8 = 0;
  v9 = 3;
  do
  {
    *(float32x2_t *)(a1 + 8 * v9 + 32) = vsub_f32(*(float32x2_t *)(a1 + 8 * v8), *(float32x2_t *)(a1 + 8 * v9));
    v9 = v8++;
  }
  while (v8 != 4);
  v7.f64[0] = -a2->f64[1];
  *(double *)&result = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v7, *(int64x2_t *)a2), a2[1]))
                     * vmul_lane_f32((float32x2_t)a4, (float32x2_t)a4, 1).f32[0];
  if (*(double *)&result < 0.0)
  {
    v11 = 0;
    v12 = a1 + 32;
    do
    {
      result = vneg_f32(*(float32x2_t *)(v12 + v11));
      *(double *)(v12 + v11) = *(double *)&result;
      v11 += 8;
    }
    while (v11 != 32);
  }
  return result;
}

uint64_t RB::XML::DisplayList::draw_shape(RB::XML::Document *a1, _RBDrawingState *a2, uint64_t a3, float16x4_t *a4, int a5, float a6)
{
  double v12;
  double v13;
  int8x16_t v14;
  _QWORD *v15;
  _QWORD *v16;
  void *v18;
  double v19;

  RB::XML::Document::push(a1, "draw");
  RB::XML::Document::set_state(a1, a2);
  -[RBShape _xmlAttributes:](a3, *(RB::XML::Element **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8), v12, v13, v14);
  -[RBFill _xmlAttributes:](a4, *(RB::XML::Element **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8));
  if (a6 != 1.0)
  {
    v15 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v18 = &unk_24C229178;
    v19 = a6;
    RB::XML::Element::set<RB::XML::Value::Float>(v15, (uint64_t)"alpha", (uint64_t)&v18);
  }
  if (a5)
  {
    v16 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v18 = &unk_24C229308;
    LODWORD(v19) = a5;
    RB::XML::Element::set<RB::XML::Value::BlendMode>(v16, (uint64_t)"blend", (uint64_t)&v18);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

void render_contents(CGContext *a1, NSDictionary *a2, const RB::DisplayList::Contents *a3, _RBDrawingState *a4)
{
  id v8;
  RB::DisplayList::State *v9;
  uint64_t v10;
  BOOL v11;
  int v12;
  unsigned int **v13;
  unsigned int *v14;
  const RB::XML::Document *v15;
  RB::XML::DisplayList *v16;
  BOOL v17;
  id v18;
  unsigned int v19;
  id v20;
  const char *v21;
  int32x2_t v22;
  int32x2_t v23;
  __int16 v24;
  unsigned __int8 v25;
  void *v26;
  CGAffineTransform v27;
  float64x2_t v28[56];
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  v8 = -[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", CFSTR("disablePassthrough"));
  if (v8 && (objc_msgSend(v8, "BOOLValue") & 1) != 0
    || (LODWORD(v28[0].f64[0]) = 0,
        LODWORD(v27.a) = 0,
        v9 = (RB::DisplayList::State *)RB::ContextDelegate::state_ref((uint64_t)a1, (float *)v28, &v27),
        (v10 = (uint64_t)v9) == 0))
  {
    v18 = -[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", RBDisplayListRenderColorSpace);
    if (v18)
      v19 = objc_msgSend(v18, "unsignedIntValue");
    else
      v19 = 0;
    v20 = -[NSDictionary objectForKeyedSubscript:](a2, "objectForKeyedSubscript:", RBDisplayListRenderRasterizationScale);
    if (v20)
    {
      objc_msgSend(v20, "floatValue");
      if (*(float *)v22.i32 <= 0.0)
        RB::precondition_failure((RB *)"invalid rasterization scale: %g", v21, *(float *)v22.i32);
      v23 = vdup_lane_s32(v22, 0);
    }
    else
    {
      CGContextGetCTM(&v27, a1);
      v28[0] = *(float64x2_t *)&v27.a;
      v28[1] = *(float64x2_t *)&v27.c;
      v28[2] = *(float64x2_t *)&v27.tx;
      v23 = RB::AffineTransform::scale2(v28);
    }
    v24 = rb_color_space(v19);
    if ((v24 & 0xFF00) != 0)
      v25 = v24;
    else
      v25 = 1;
    RB::CGContext::CGContext(v28, a1, v25, *(double *)&v23);
    RB::DisplayList::render(a3, (const RB::DisplayList::Contents *)v28, 0, v26);
    RB::CGContext::~CGContext((RB::CGContext *)v28);
  }
  else
  {
    v11 = *(float *)v28[0].f64 == 1.0 && LODWORD(v27.a) == 0;
    v12 = !v11;
    v13 = (unsigned int **)v9;
    if (!v11)
      v13 = (unsigned int **)RBDrawingStateBeginLayer(v9, 0);
    v14 = v13[1];
    if (!*((_QWORD *)v14 + 3))
      make_contents(v13[1]);
    RB::DisplayList::Builder::draw((RB::DisplayList::Builder *)(v14 + 4), a3, (RB::DisplayList::State *)v13, 1.0, 0, 0);
    v16 = (RB::XML::DisplayList *)*((_QWORD *)v14 + 38);
    if (v16)
      v17 = a4 == 0;
    else
      v17 = 1;
    if (!v17)
      RB::XML::DisplayList::draw_list(v16, (RB::XML::Document *)v13, a4, v15, 1.0);
    if (v12)
      RBDrawingStateDrawLayer(v10, (RB::DisplayList::State *)v13, LODWORD(v27.a), *(float *)v28[0].f64);
  }
}

void sub_209AD3374(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::CGContext::~CGContext((RB::CGContext *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::state_ref(uint64_t a1, float *a2, _DWORD *a3)
{
  uint64_t result;
  uint64_t Info;
  uint64_t v7;
  const char *GState;
  uint64_t RenderingState;
  double v10;
  float v11;
  unsigned int CompositeOperation;
  int v13;

  result = CGContextGetDelegate();
  if (result)
  {
    if ((uint64_t (*)())CGContextDelegateGetCallback() == RB::ContextDelegate::get_bounds
      && (Info = CGContextDelegateGetInfo(), *(_QWORD *)(Info + 432)))
    {
      v7 = Info;
      GState = (const char *)CGContextGetGState();
      RenderingState = CGContextGetRenderingState();
      RB::ContextDelegate::update(v7, GState, RenderingState, 0);
      if (a2)
      {
        CGGStateGetAlpha();
        v11 = v10;
        if (!*(_QWORD *)(v7 + 360))
          v11 = *(float *)(v7 + 456) * v11;
        *a2 = v11;
      }
      if (a3)
      {
        CompositeOperation = CGGStateGetCompositeOperation();
        if (CompositeOperation > 0x1B)
          v13 = 0;
        else
        *a3 = v13;
      }
      return *(_QWORD *)(v7 + 440);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void RB::DisplayList::Contents::finalize(RB::DisplayList::Contents *this)
{
  _QWORD *v2;
  NSObject *global_queue;

  v2 = (_QWORD *)*((_QWORD *)this + 3);
  if (v2 && *v2)
  {
    global_queue = dispatch_get_global_queue(0, 0);
    dispatch_async_f(global_queue, this, (dispatch_function_t)RB::DisplayList::Contents::finalize(void)::$_0::__invoke);
  }
  else
  {
    (*(void (**)(RB::DisplayList::Contents *))(*(_QWORD *)this + 24))(this);
  }
}

void RB::DisplayList::Contents::~Contents(RB::DisplayList::Contents *this)
{
  RB::DisplayList::Contents::~Contents(this);
  JUMPOUT(0x20BD16544);
}

{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C228970;
  v2 = *((_QWORD *)this + 39);
  if (v2)
  {
    do
    {
      v3 = *(_QWORD *)(v2 + 8);
      (**(void (***)(uint64_t))v2)(v2);
      v2 = v3;
    }
    while (v3);
  }
  RB::DisplayList::Layer::~Layer((RB::DisplayList::Contents *)((char *)this + 320));
  RB::Heap::~Heap((RB::DisplayList::Contents *)((char *)this + 16));
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::~GenericClip(uint64_t a1)
{
  RBPathRelease(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
  return a1;
}

void RB::DisplayList::Layer::~Layer(RB::DisplayList::Layer *this)
{
  uint64_t i;
  uint64_t j;

  for (i = *(_QWORD *)this; i; i = *(_QWORD *)(i + 8))
    (**(void (***)(uint64_t))i)(i);
  for (j = *((_QWORD *)this + 2); j; j = *(_QWORD *)(j + 8))
    (**(void (***)(uint64_t))j)(j);
}

void RB::CGContext::~CGContext(CGContextRef *this)
{
  CGContextRef v2;
  CGContextRef v3;

  if (*((_BYTE *)this + 141))
    CGContextRestoreGState(*this);
  v2 = this[110];
  if (v2)
    free(v2);
  v3 = this[51];
  if (v3)
    free(v3);
}

void sub_209AD3630(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 880);
  if (v3)
    free(v3);
  v4 = *(void **)(v1 + 408);
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

uint64_t RB::CGContext::CGContext(uint64_t a1, CGContextRef c, char *a3, double a4)
{
  __int128 v6;
  __int128 v7;
  CGContext *v8;
  __int128 v9;
  CGContext *v10;
  char *v11;
  CGContext *v12;
  char *v13;
  CGAffineTransform v15;
  CGAffineTransform v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)a1 = c;
  *(_BYTE *)(a1 + 8) = (_BYTE)a3;
  *(double *)(a1 + 16) = a4;
  CGContextGetCTM(&v16, c);
  v6 = *(_OWORD *)&v16.c;
  v7 = *(_OWORD *)&v16.tx;
  *(_OWORD *)(a1 + 32) = *(_OWORD *)&v16.a;
  *(_OWORD *)(a1 + 48) = v6;
  *(_OWORD *)(a1 + 64) = v7;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  *(int32x2_t *)(a1 + 96) = vdup_n_s32(0xC0000001);
  *(_QWORD *)(a1 + 104) = 0x8000000080000000;
  *(_QWORD *)(a1 + 112) = 0x3C00000000000000;
  *(_WORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 122) = 0x3C00000000000000;
  *(_WORD *)(a1 + 130) = 0;
  *(_QWORD *)(a1 + 132) = 0x23F800000;
  *(_WORD *)(a1 + 140) = 0;
  *(_DWORD *)(a1 + 144) = -1;
  *(_QWORD *)(a1 + 408) = 0;
  *(_QWORD *)(a1 + 416) = 0x400000000;
  *(_QWORD *)(a1 + 880) = 0;
  *(_QWORD *)(a1 + 888) = 0x400000000;
  CGContextSetAlpha(*(CGContextRef *)a1, 1.0);
  CGContextSetBlendMode(*(CGContextRef *)a1, kCGBlendModeNormal);
  CGContextSetShouldAntialias(*(CGContextRef *)a1, 1);
  CGContextSetFontSize(*(CGContextRef *)a1, 1.0);
  v8 = *(CGContext **)a1;
  v9 = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 16);
  *(_OWORD *)&v15.a = *MEMORY[0x24BDBD8B8];
  *(_OWORD *)&v15.c = v9;
  *(_OWORD *)&v15.tx = *(_OWORD *)(MEMORY[0x24BDBD8B8] + 32);
  CGContextSetTextMatrix(v8, &v15);
  v10 = *(CGContext **)a1;
  v11 = RB::cg_color_space(a3, 1);
  CGContextSetFillColorSpace(v10, (CGColorSpaceRef)v11);
  v12 = *(CGContext **)a1;
  v13 = RB::cg_color_space(a3, 1);
  CGContextSetStrokeColorSpace(v12, (CGColorSpaceRef)v13);
  *(_OWORD *)&v16.a = xmmword_209BD7960;
  *(_OWORD *)&v16.c = unk_209BD7970;
  CGContextSetFillColor(*(CGContextRef *)a1, &v16.a);
  CGContextSetStrokeColor(*(CGContextRef *)a1, &v16.a);
  return a1;
}

void sub_209AD37E8(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t RB::extended_srgb_colorspace(RB *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      RB::extended_srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF278]);
    }
  }
  return v2[36];
}

char *RB::cg_color_space(char *result, char a2)
{
  switch((int)result)
  {
    case 0:
      if ((a2 & 1) != 0)
        result = (char *)RB::extended_linear_srgb_colorspace((RB *)result);
      else
        result = RB::linear_srgb_colorspace((RB *)result);
      break;
    case 1:
      if ((a2 & 1) != 0)
        result = (char *)RB::extended_srgb_colorspace((RB *)result);
      else
        result = (char *)RB::srgb_colorspace((RB *)result);
      break;
    case 2:
      if ((a2 & 1) != 0)
        result = RB::extended_linear_display_p3_colorspace((RB *)result);
      else
        result = RB::linear_display_p3_colorspace((RB *)result);
      break;
    case 3:
      if ((a2 & 1) != 0)
        result = RB::extended_display_p3_colorspace((RB *)result);
      else
        result = RB::display_p3_colorspace((RB *)result);
      break;
    case 4:
      abort();
    case 5:
      result = RB::pq_colorspace((RB *)result);
      break;
    default:
      return result;
  }
  return result;
}

RB::DisplayList::State *RB::DisplayList::State::State(RB::DisplayList::State *this, int a2)
{
  RB::AffineTransform *v4;

  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_OWORD *)this + 1) = xmmword_209BD5290;
  *((_OWORD *)this + 2) = xmmword_209BD52A0;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  *((_DWORD *)this + 16) = 0;
  uuid_clear((unsigned __int8 *)this + 68);
  *((_QWORD *)this + 11) = 0;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = RB::AffineTransform::identity(v4);
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 16) = 0;
  *((_QWORD *)this + 17) = 0;
  *((_DWORD *)this + 36) = a2;
  *(_QWORD *)((char *)this + 148) = 0x7FC00000FFFFFFFFLL;
  *((_WORD *)this + 78) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0x100000000;
  return this;
}

void sub_209AD39B4(_Unwind_Exception *exception_object)
{
  uint64_t *v1;

  if (*v1)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3(*v1);
  _Unwind_Resume(exception_object);
}

__int128 *RB::AffineTransform::identity(RB::AffineTransform *this)
{
  unsigned __int8 v1;

  {
    RB::AffineTransform::identity(void)::identity = xmmword_209BD5290;
    *(_OWORD *)algn_253EAF210 = xmmword_209BD52A0;
    qword_253EAF220 = 0;
    unk_253EAF228 = 0;
  }
  return &RB::AffineTransform::identity(void)::identity;
}

CGPathRef RBPathCopyCGPath(const CGPath *a1, uint64_t a2)
{
  uint64_t (*v4)(const CGPath *);
  const CGPath *v5;
  uint64_t (*v7)(const CGPath *, uint64_t);
  uint64_t (**v8)(RBPathCopyCGPath::Accumulator *__hidden);
  CGMutablePathRef Mutable;

  if ((*(_BYTE *)(a2 + 2) & 1) != 0)
  {
    v7 = *(uint64_t (**)(const CGPath *, uint64_t))(a2 + 72);
    if (v7)
    {
      v5 = (const CGPath *)v7(a1, a2);
      if (v5)
        return CGPathRetain(v5);
    }
  }
  else
  {
    v4 = *(uint64_t (**)(const CGPath *))(a2 + 72);
    if (v4)
    {
      v5 = (const CGPath *)v4(a1);
      if (v5)
        return CGPathRetain(v5);
    }
  }
  v8 = off_24C22A0A8;
  Mutable = CGPathCreateMutable();
  RBPathMap(a1, (void *)a2, (uint64_t (**)(RB::Path::Mapper *__hidden))&v8, 0);
  return Mutable;
}

void sub_209AD3B08(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Coverage::Path::simplify(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  __int128 *v5;
  __int128 v6;
  __int128 v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  char v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  char v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)result)
  {
    v8 = a2;
    v5 = *(__int128 **)(a1 + 16);
    if (v5)
    {
      v6 = *v5;
      v7 = v5[2];
      v10 = v5[1];
      v11 = v7;
      v9 = v6;
    }
    else
    {
      v9 = xmmword_209BD5290;
      v10 = xmmword_209BD52A0;
      v11 = 0uLL;
    }
    v12 = *(_BYTE *)(a1 + 29);
    v13 = 0;
    v14 = 0;
    v15 = *(float *)(a1 + 24);
    v16 = 0;
  }
  return result;
}

uint64_t RBPathApplyShape(uint64_t a1, void *a2, char a3, uint64_t a4, void (*a5)(uint64_t, uint64_t, __int128 *))
{
  uint64_t result;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  char v17;
  double v18;
  double v19;
  int v20;

  if (a2 != &RBPathCGPathCallbacks)
  {
    if (RBPathIsSingleElement(a1, (uint64_t)a2))
    {
      *(_QWORD *)&v15 = a4;
      *((_QWORD *)&v15 + 1) = a5;
      *(_QWORD *)&v16 = a1;
      *((_QWORD *)&v16 + 1) = a2;
      v17 = 0;
      RBPathApplyElements(a1, (uint64_t)a2, (uint64_t)&v15, (uint64_t)RBPathApplyShape::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
      return v17 != 0;
    }
    if ((a3 & 1) != 0)
      return 0;
    v14 = 0;
    if (!RBPathApplyElements(a1, (uint64_t)a2, (uint64_t)v13, (uint64_t)RBPathApplyShape::$_1::__invoke<void *,RBPathElement,double const*,void const*>)|| v14 != 2)
    {
      return 0;
    }
    v15 = v13[0];
    v16 = v13[1];
    v12 = a4;
    v11 = 2;
    goto LABEL_19;
  }
  result = CGPathIsPrimitive();
  if (!(_DWORD)result)
    return result;
  if ((CGPathIsRectWithTransform() & 1) == 0)
  {
    if ((CGPathIsEllipseWithTransform() & 1) != 0)
    {
      v11 = 1;
      goto LABEL_18;
    }
    result = CGPathIsRoundedRectWithTransform();
    if (!(_DWORD)result)
      return result;
    if (v18 != 0.0 || v19 != 0.0)
    {
      v20 = 0;
      v11 = 3;
      goto LABEL_18;
    }
  }
  v11 = 0;
LABEL_18:
  v12 = a4;
LABEL_19:
  a5(v12, v11, &v15);
  return 1;
}

uint64_t RBPathIsSingleElement(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  _QWORD v4[2];
  uint64_t v5;
  char v6;

  if ((*(_BYTE *)(a2 + 2) & 1) != 0)
  {
    v2 = *(uint64_t (**)(void))(a2 + 48);
    if (v2)
      return v2();
  }
  else
  {
    v2 = *(uint64_t (**)(void))(a2 + 48);
    if (v2)
      return v2();
  }
  v4[0] = 0;
  v4[1] = 0;
  v6 = 0;
  v5 = 0;
  RBPathApplyElements(a1, a2, (uint64_t)v4, (uint64_t)RB::Path::NestedCallbacks::single_element_callback);
  return v5 == 1;
}

void RBShapeData::apply<RB::DestroyAny>(int *a1)
{
  int v1;

  v1 = *a1;
  if (*a1 == 5)
  {
    *((_QWORD *)a1 + 2) = off_24C229900;

  }
  else if (v1 == 3)
  {
    *((_QWORD *)a1 + 2) = off_24C229920;
    RBPathRelease(*((_QWORD *)a1 + 3), *((_QWORD *)a1 + 4));
  }
  else if (v1 == 2)
  {
    RBPathRelease(*((_QWORD *)a1 + 2), *((_QWORD *)a1 + 3));
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  uint64_t v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int16 v23;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C226258;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(a1 + 64) = v18;
  v19 = *(__int128 **)(a3 + 16);
  if (v19)
  {
    v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3])
      v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v20 + 3);
    v21 = *v19;
    v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *v20 = v21;
  }
  else
  {
    v20 = 0;
  }
  *(_QWORD *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  if (*(_BYTE *)(a4 + 9))
    v23 = *(_WORD *)(a4 + 8);
  else
    v23 = a7;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)a4;
  *(_WORD *)(a1 + 96) = v23;
  return a1;
}

void sub_209AD3F70(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

uint64_t RBPathRetain(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  uint64_t result;

  v2 = *(uint64_t (**)(void))(a2 + 8);
  if (v2)
    return v2();
  return result;
}

void RBPathMap(CGPathRef path, void *a2, uint64_t (**a3)(RB::Path::Mapper *__hidden this), float64x2_t *a4)
{
  void (__cdecl *v8)(void *, const CGPathElement *);
  int64x2_t v9;
  uint64_t (**v10)(RB::Path::Mapper *__hidden);
  float64x2_t *v11;
  char v12[256];
  uint64_t v13;
  uint64_t (**v14)(RB::Path::Mapper *__hidden);
  float64x2_t *v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int16 v19;
  uint64_t v20;

  v20 = *MEMORY[0x24BDAC8D0];
  if (a2 == &RBPathCGPathCallbacks)
  {
    v10 = a3;
    v11 = a4;
    v8 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
    if (a4)
    {
      v9 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a4[2]));
      if (vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9).i64[0] >= 0)
        v8 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
    }
    CGPathApply(path, &v10, v8);
    (*(void (**)(uint64_t (**)(RB::Path::Mapper *__hidden)))*a3)(a3);
  }
  else
  {
    v10 = off_24C2295C8;
    RB::Heap::Heap((RB::Heap *)&v11, v12, 256, 0);
    v13 = 0;
    v14 = a3;
    v16 = 0u;
    v17 = 0u;
    v15 = a4;
    v18 = 0;
    v19 = 1;
    RBPathApplyElements((uint64_t)path, (uint64_t)a2, (uint64_t)&v10, (uint64_t)RB::Path::Mapper::apply_callback);
    (*(void (**)(uint64_t (**)(RB::Path::Mapper *__hidden)))*a3)(a3);
    RB::Path::Mapper::~Mapper((RB::Path::Mapper *)&v10);
  }
}

RB::Heap *RB::Heap::Heap(RB::Heap *this, char *a2, uint64_t a3, unint64_t a4)
{
  uint64_t v5;

  *((_QWORD *)this + 4) = 0;
  v5 = 512;
  if (a4 > 0x200)
    v5 = a4;
  if (!a4)
    v5 = 0x2000;
  *(_QWORD *)this = v5;
  *((_QWORD *)this + 1) = 0;
  RB::Heap::reset(this, a2, a3);
  return this;
}

void RB::Heap::reset(RB::Heap *this, char *a2, uint64_t a3)
{
  RB::ObjectTable *v6;
  void *v7;
  _QWORD *v8;

  v6 = (RB::ObjectTable *)*((_QWORD *)this + 4);
  if (v6)
  {
    RB::ObjectTable::~ObjectTable(v6);
    *((_QWORD *)this + 4) = 0;
  }
  while (1)
  {
    v8 = (_QWORD *)*((_QWORD *)this + 1);
    if (!v8)
      break;
    v7 = (void *)v8[1];
    *((_QWORD *)this + 1) = *v8;
    free(v7);
  }
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = &a2[a3];
}

uint64_t RBPathApplyElements(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t (*v4)(uint64_t, uint64_t, uint64_t);
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, uint64_t);

  if ((*(_BYTE *)(a2 + 2) & 1) != 0)
  {
    v6 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v6)
      return v6(a1, a3, a4, a2);
  }
  else
  {
    v4 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a2 + 24);
    if (v4)
      return v4(a1, a3, a4);
  }
  return 1;
}

uint64_t RB::Path::Storage::apply_elements(RB::Path::Storage *a1, RB::Path::Storage *this, void *a3)
{
  BOOL v5;
  os_unfair_lock_s *v7;

  {
    RB::Path::Storage::append_storage(this, a1);
    return 1;
  }
  else if (a3 == RB::Path::NestedCallbacks::apply_elements_callback)
  {
    return RB::Path::NestedCallbacks::apply_elements_fast(a1, this, a3);
  }
  else if (a3 == RB::Path::NestedCallbacks::single_element_callback)
  {
    return RB::Path::NestedCallbacks::single_element_fast(a1, this, a3);
  }
  else
  {
    v5 = a3 != RB::Path::Mapper::apply_callback || (*((_DWORD *)a1 + 2) & 0x20) == 0;
    if (v5 || *((_BYTE *)this + 369))
    {
      return RB::Path::Storage::apply_elements_((uint64_t)a1, (uint64_t)this, (uint64_t (*)(uint64_t, uint64_t, _BYTE *, __int128 *))a3);
    }
    else
    {
      v7 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(a1);
      return RB::Path::Storage::MapCache::apply(v7, (uint64_t)a1, this, (uint64_t)RB::Path::Mapper::apply_callback, 0);
    }
  }
}

void RB::Path::Mapper::~Mapper(RB::Path::Mapper *this)
{
  while (*((_QWORD *)this + 41))
    RB::Path::Mapper::pop(this);
  RB::Heap::~Heap((RB::Path::Mapper *)((char *)this + 8));
}

void RB::Heap::~Heap(RB::Heap *this)
{
  RB::ObjectTable *v2;
  uint64_t **v3;
  uint64_t *v4;

  v2 = (RB::ObjectTable *)*((_QWORD *)this + 4);
  if (v2)
  {
    RB::ObjectTable::~ObjectTable(v2);
    *((_QWORD *)this + 4) = 0;
  }
  v3 = (uint64_t **)*((_QWORD *)this + 1);
  if (v3)
  {
    do
    {
      v4 = *v3;
      free(v3[1]);
      v3 = (uint64_t **)v4;
    }
    while (v4);
  }
}

uint64_t RB::Coverage::`anonymous namespace'::enable_path_primitives(RB::Coverage::_anonymous_namespace_ *this)
{
  unsigned __int8 v1;
  const char *v3;
  unsigned __int16 v4;
  BOOL v5;
  char v6;

  if ((v1 & 1) == 0
  {
    v4 = RB::debug_BOOL((RB *)"RB_PATH_PRIMITIVES", v3);
    if ((_BYTE)v4)
      v5 = 0;
    else
      v5 = v4 >= 0x100u;
    v6 = !v5;
  }
}

void sub_209AD43D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226258;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

uint64_t RBPathRelease(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  uint64_t result;

  v2 = *(uint64_t (**)(void))(a2 + 16);
  if (v2)
    return v2();
  return result;
}

uint64_t RB::Path::Object::$_6::__invoke(uint64_t this, const void *a2)
{
  unsigned int *v2;
  unsigned int v3;

  v2 = (unsigned int *)(this + 8);
  do
    v3 = __ldxr(v2);
  while (__stxr(v3 + 1, v2));
  return this;
}

BOOL RB::Path::Object::$_10::__invoke(RB::Path::Object::$_10 *this, const void *a2)
{
  unint64_t v2;
  uint64_t v3;

  v2 = *((unsigned int *)this + 6);
  if ((v2 & 1) != 0)
    v3 = *((_QWORD *)this + 5);
  else
    v3 = (v2 >> 8) & 0xFFF;
  return v3 == 0;
}

uint64_t RB::Path::Accumulator::begin_subpath(uint64_t this)
{
  *(_QWORD *)(this + 288) = *(_QWORD *)(this + 272);
  *(_DWORD *)(this + 300) = *(_DWORD *)(this + 296);
  return this;
}

uint64_t RB::Path::Flattener::closepath(float32x2_t *this)
{
  float32x2_t v2;
  uint32x2_t v3;
  float32x2_t v4;
  float32x2_t v5;
  uint32x2_t v6;
  float32x2_t v7;

  v2 = this[9];
  v3 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v2, this[10]));
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    RB::Path::Flattener::lineto((uint64_t)this, vcvtq_f64_f32(v2));
  v4 = this[7];
  v5 = this[8];
  v6 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(this[3], v5), (int8x8_t)vcgt_f32(v4, this[4]));
  if ((vpmax_u32(v6, v6).u32[0] & 0x80000000) == 0)
    goto LABEL_6;
  if (((*(uint64_t (**)(_QWORD))(**(_QWORD **)&this[1] + 8))(*(_QWORD *)&this[1]) & 1) == 0)
  {
    v4 = this[7];
    v5 = this[8];
LABEL_6:
    v7 = this[6];
    this[5] = vminnm_f32(this[5], v4);
    this[6] = vmaxnm_f32(v7, v5);
  }
  this[7] = (float32x2_t)vdup_n_s32(0x7F800000u);
  this[8] = (float32x2_t)0x7F0000007FLL;
  this[11].i8[0] = 0;
  return (***(uint64_t (****)(_QWORD))&this[1])(*(_QWORD *)&this[1]);
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, _OWORD *))
{
  uint64_t v6;
  __int128 v7;
  uint64_t result;
  _OWORD v9[3];

  v6 = a1 + 32;
  v7 = *(_OWORD *)(a1 + 48);
  v9[0] = *(_OWORD *)(a1 + 32);
  v9[1] = v7;
  v9[2] = *(_OWORD *)(a1 + 64);
  result = a3(a2, 17, a1 + 32, v9);
  if ((_DWORD)result)
  {
    result = RBPathApplyElements(*(_QWORD *)(a1 + 16), *(_QWORD *)(a1 + 24), a2, (uint64_t)a3);
    if ((_DWORD)result)
      return a3(a2, 16, v6, 0);
  }
  return result;
}

BOOL RB::Path::Storage::apply_elements_at_depth(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;
  char __dst[64];
  unsigned __int8 v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  if (!a4)
    return RB::Path::Storage::apply_elements_(a1, a2, (uint64_t (*)(uint64_t, uint64_t, _BYTE *, __int128 *))a3);
  v11 = 0;
  if (!RB::Path::NestedCallbacks::first_element(a1, &v11, a4))
    return 0;
  v14 = 0;
  v15 = 0x400000000;
  v8 = a4;
  while (RB::Path::Storage::Iterator::next(&v11, a1, __dst))
  {
    if (v13 <= 0x18u)
    {
      if (((1 << v13) & 0x1DE0000) != 0)
      {
        ++v8;
      }
      else if (v13 == 16)
      {
        if (v8 == a4)
          break;
        --v8;
      }
    }
    if ((a3(a2) & 1) == 0)
    {
      v10 = 0;
      goto LABEL_16;
    }
  }
  v10 = 1;
LABEL_16:
  if (v14)
    free(v14);
  return v10;
}

BOOL RB::Path::Storage::Iterator::next(uint64_t *a1, uint64_t a2, char *__dst)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char v13;
  uint64_t v14;
  int v15;
  int v16;
  uint64_t v17;
  float *v18;
  double *v19;
  uint64_t v20;
  float v21;
  double *v22;
  uint64_t v23;
  int v24;
  char v25;
  double *v26;
  float *v27;
  __int128 v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  char *v34;
  double *v35;
  uint64_t v36;
  float *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  char *v43;
  unint64_t v44;
  uint64_t v45;
  char *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  uint64_t i;
  uint64_t v50;
  float v51;
  uint64_t j;
  uint64_t v53;
  int v54;
  uint64_t v56;

  v3 = *a1;
  v4 = *(unsigned int *)(a2 + 8);
  if ((v4 & 1) != 0)
    v5 = *(_QWORD *)(a2 + 24);
  else
    v5 = (v4 >> 8) & 0xFFF;
  if (v3 >= v5)
    return v3 < v5;
  v10 = *(_QWORD *)(a2 + 16);
  v8 = a2 + 16;
  v9 = v10;
  if ((v4 & 1) != 0)
    v11 = v9;
  else
    v11 = v8;
  v12 = v3 + 1;
  *a1 = v3 + 1;
  v13 = *(_BYTE *)(v11 + v3);
  v14 = v13 & 0x1F;
  if (v13 < 0)
  {
    v16 = 0;
    v15 = 1;
    switch(v13 & 0x1F)
    {
      case 0x10:
      case 0x12:
      case 0x16:
      case 0x17:
        goto LABEL_13;
      case 0x11:
      case 0x15:
        goto LABEL_10;
      case 0x13:
        v16 = 2;
        goto LABEL_13;
      case 0x14:
        v16 = 3;
        goto LABEL_13;
      case 0x18:
        v16 = 4;
        goto LABEL_13;
      default:
        if ((_DWORD)v14 == 4)
          goto LABEL_13;
        goto LABEL_10;
    }
  }
  v15 = 0;
LABEL_10:
  if (v14 >= 0x19)
  {
    __dst[64] = v14;
    v16 = v15;
  }
  else
  {
    v16 = v15;
LABEL_13:
    v17 = __RBPathElementArgumentCount[v14];
    __dst[64] = v14;
    if (v17)
    {
      v18 = (float *)(v11 + v12);
      if ((v13 & 0x40) != 0)
      {
        v19 = (double *)__dst;
        v20 = v17;
        do
        {
          v21 = *v18++;
          *v19++ = v21;
          --v20;
        }
        while (v20);
        v12 += 4 * v17;
      }
      else if ((v13 & 0x20) != 0)
      {
        v22 = (double *)__dst;
        v23 = v17;
        do
        {
          v24 = *(__int16 *)v18;
          v18 = (float *)((char *)v18 + 2);
          *v22++ = (double)v24;
          --v23;
        }
        while (v23);
        v12 += 2 * v17;
      }
      else
      {
        memcpy(__dst, v18, 8 * v17);
        v12 = *a1 + 8 * v17;
      }
      *a1 = v12;
    }
  }
  v25 = 0;
  switch(v16)
  {
    case 0:
      goto LABEL_77;
    case 1:
      v26 = (double *)(__dst + 72);
      v27 = (float *)(v11 + v12);
      if ((v13 & 0x40) != 0)
      {
        for (i = 0; i != 6; ++i)
          v26[i] = v27[i];
        v30 = v12 + 24;
      }
      else if ((v13 & 0x20) != 0)
      {
        for (j = 0; j != 6; ++j)
          v26[j] = (double)*((__int16 *)v27 + j);
        v30 = v12 + 12;
      }
      else
      {
        v28 = *(_OWORD *)v27;
        v29 = *((_OWORD *)v27 + 2);
        *(_OWORD *)(__dst + 88) = *((_OWORD *)v27 + 1);
        *(_OWORD *)(__dst + 104) = v29;
        *(_OWORD *)v26 = v28;
        v30 = *a1 + 48;
      }
      goto LABEL_69;
    case 2:
      *a1 = v12 + 1;
      *((_DWORD *)__dst + 18) = *(unsigned __int8 *)(v11 + v12);
      v31 = (*a1)++;
      *((_DWORD *)__dst + 19) = *(unsigned __int8 *)(v11 + v31);
      v32 = *(unsigned __int16 *)(v11 + *a1);
      *a1 += 2;
      *((_QWORD *)__dst + 10) = v32;
      if (v32)
      {
        if (*((_DWORD *)__dst + 40) < v32 && *((_DWORD *)__dst + 41) < v32)
          RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(__dst + 120, v32);
        *((_DWORD *)__dst + 40) = v32;
        v34 = (char *)*((_QWORD *)__dst + 19);
        if (v34)
          v35 = (double *)*((_QWORD *)__dst + 19);
        else
          v35 = (double *)(__dst + 120);
        v36 = *a1;
        v37 = (float *)(v11 + *a1);
        if ((v13 & 0x40) != 0)
        {
          v50 = v32;
          do
          {
            v51 = *v37++;
            *v35++ = v51;
            --v50;
          }
          while (v50);
          v38 = v36 + 4 * v32;
        }
        else if ((v13 & 0x20) != 0)
        {
          v53 = v32;
          do
          {
            v54 = *(__int16 *)v37;
            v37 = (float *)((char *)v37 + 2);
            *v35++ = (double)v54;
            --v53;
          }
          while (v53);
          v38 = v36 + 2 * v32;
        }
        else
        {
          memcpy(v35, v37, 8 * v32);
          v38 = *a1 + 8 * v32;
          v34 = (char *)*((_QWORD *)__dst + 19);
        }
        *a1 = v38;
        if (!v34)
          v34 = __dst + 120;
        *((_QWORD *)__dst + 11) = v34;
      }
      goto LABEL_76;
    case 3:
      *((_WORD *)__dst + 36) = *(_WORD *)(v11 + v12);
      v30 = *a1 + 2;
LABEL_69:
      *a1 = v30;
      goto LABEL_76;
    case 4:
      *a1 = v12 + 1;
      *((_DWORD *)__dst + 18) = *(unsigned __int8 *)(v11 + v12);
      v39 = (*a1)++;
      *((_DWORD *)__dst + 19) = *(unsigned __int8 *)(v11 + v39);
      v40 = *(unsigned __int16 *)(v11 + *a1);
      *a1 += 2;
      *((_QWORD *)__dst + 10) = v40;
      if (!v40)
        goto LABEL_76;
      v41 = 2 * v40;
      if (*((_DWORD *)__dst + 40) >= (2 * v40) || *((_DWORD *)__dst + 41) >= v41)
      {
        *((_DWORD *)__dst + 40) = v41;
        if (*((_QWORD *)__dst + 19))
          v43 = (char *)*((_QWORD *)__dst + 19);
        else
          v43 = __dst + 120;
        *((_QWORD *)__dst + 11) = v43;
LABEL_52:
        v44 = 0;
        v45 = *a1;
        v46 = v43 + 4;
        do
        {
          v47 = (unsigned __int8 *)(v11 + v45);
          *((_DWORD *)v46 - 1) = *v47;
          v48 = *(_QWORD *)(v47 + 1);
          *((_DWORD *)v46 + 2) = *(_DWORD *)(v47 + 9);
          *(_QWORD *)v46 = v48;
          v46 += 16;
          v45 = *a1 + 13;
          *a1 = v45;
          ++v44;
        }
        while (v44 < *((_QWORD *)__dst + 10));
        goto LABEL_76;
      }
      RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::reserve_slow(__dst + 120, 2 * v40);
      v56 = *((_QWORD *)__dst + 10);
      *((_DWORD *)__dst + 40) = v41;
      v43 = (char *)*((_QWORD *)__dst + 19);
      if (!v43)
        v43 = __dst + 120;
      *((_QWORD *)__dst + 11) = v43;
      if (v56)
        goto LABEL_52;
LABEL_76:
      v25 = 1;
LABEL_77:
      __dst[65] = v25;
      return v3 < v5;
    default:
      return v3 < v5;
  }
}

uint64_t RB::Path::NestedCallbacks::apply_elements_fast(RB::Path::NestedCallbacks *this, const RB::Path::Storage *a2, void *a3)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t);
  os_unfair_lock_s *v8;

  if ((*((_BYTE *)this + 8) & 0x20) == 0)
  {
    v5 = *(_QWORD *)a2;
    v6 = (uint64_t (*)(uint64_t))*((_QWORD *)a2 + 1);
    return RB::Path::Storage::apply_elements_at_depth((uint64_t)this, v5, v6, *((_QWORD *)a2 + 2));
  }
  v5 = *(_QWORD *)a2;
  v6 = (uint64_t (*)(uint64_t))*((_QWORD *)a2 + 1);
  if ((char *)v6 != (char *)RB::Path::Mapper::apply_callback)
    return RB::Path::Storage::apply_elements_at_depth((uint64_t)this, v5, v6, *((_QWORD *)a2 + 2));
  if (*(_BYTE *)(v5 + 369))
  {
    v6 = (uint64_t (*)(uint64_t))RB::Path::Mapper::apply_callback;
    return RB::Path::Storage::apply_elements_at_depth((uint64_t)this, v5, v6, *((_QWORD *)a2 + 2));
  }
  v8 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
  return RB::Path::Storage::MapCache::apply(v8, (uint64_t)this, *(RB::Path::Storage **)a2, *((_QWORD *)a2 + 1), *((_QWORD *)a2 + 2));
}

BOOL RB::Path::Accumulator::cull_subpath(RB::Path::Accumulator *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 36);
  if ((v1 & 0x8000000000000000) == 0)
  {
    *((_QWORD *)this + 34) = v1;
    *((_DWORD *)this + 74) = *((_DWORD *)this + 75);
    *((_QWORD *)this + 36) = -1;
  }
  return v1 >= 0;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#4}::__invoke()
{
  return 1;
}

uint64_t RB::CGContext::compatible_layer_flags(RB::CGContext *this, __int16 a2)
{
  int Type;

  if ((a2 & 0x10) != 0)
    return 0;
  if ((a2 & 0x100) == 0)
    return 1;
  Type = *((_DWORD *)this + 36);
  if (Type < 0)
  {
    Type = CGContextGetType();
    *((_DWORD *)this + 36) = Type;
  }
  if (Type == 4)
  {
    if (CGBitmapContextGetAlphaInfo(*(CGContextRef *)this) != kCGImageAlphaOnly)
      return 1;
  }
  else if (Type != 2 && (Type != 1 || (a2 & 0x1000) == 0))
  {
    return 1;
  }
  return 0;
}

_QWORD **RB::DisplayList::Layer::render_items(_QWORD **this, RB::CGContext *a2, char *a3)
{
  _QWORD **v3;
  _QWORD *v4;
  _QWORD *v6;
  int32x2_t *v7;
  float32x2_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  double v11;
  float32x2_t v12;
  _QWORD *v13;
  float32x2_t v14;
  float32x2_t v15;
  double v16;
  double v17;
  double v18;
  int32x4_t v19;
  float v20;
  unsigned int v21;
  int v22;
  __int128 v23;
  double v24;
  float32x2_t v25;

  v3 = (_QWORD **)(a3 + 8);
  if (!a3)
    v3 = this;
  v4 = *v3;
  if (*v3)
  {
    v6 = 0;
    v7 = (int32x2_t *)((char *)a2 + 96);
    do
    {
      if (v6)
      {
        if (v6 == v4)
          v6 = 0;
      }
      else
      {
        v8 = (float32x2_t *)v4[3];
        if (!v8)
          goto LABEL_24;
        v9 = (_QWORD *)v4[1];
        if (!v9)
          goto LABEL_24;
        v10 = v4;
        do
        {
          v6 = v10;
          v10 = v9;
          if ((float32x2_t *)v6[3] != v8)
            break;
          v9 = (_QWORD *)v9[1];
          v6 = v10;
        }
        while (v9);
        if (v6 != v4)
        {
          v11 = (*(double (**)(_QWORD *, _QWORD))(*v4 + 144))(v4, 0);
          v24 = v11;
          v25 = v12;
          v13 = (_QWORD *)v4[1];
          if (v13 != v6)
          {
            do
            {
              *(double *)&v14 = (*(double (**)(_QWORD *, _QWORD))(*v13 + 144))(v13, 0);
              RB::Rect::Union((float32x2_t *)&v24, v14, v15, v16, v17, v18, v19);
              v13 = (_QWORD *)v13[1];
            }
            while (v13 != v6);
            v11 = v24;
            v12 = v25;
          }
          v20 = *((float *)a2 + 33);
          v21 = *((_DWORD *)a2 + 34);
          RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v11, v12);
          if (*((float32x2_t **)a2 + 11) == v8
            && RB::Bounds::contains(v7, *(int32x2_t *)&v23, *(int32x2_t *)((char *)&v23 + 8)))
          {
            v22 = 1;
            if (!*((_QWORD *)a2 + 10) && *((float *)a2 + 33) == v20 && *((_DWORD *)a2 + 34) == v21)
              goto LABEL_27;
          }
          else
          {
            v22 = 0;
          }
          RB::CGContext::update_state_slow((uint64_t)a2, 0, v8, v21, &v23, v22, v20);
        }
        else
        {
LABEL_24:
          v6 = 0;
        }
      }
LABEL_27:
      this = (_QWORD **)(*(uint64_t (**)(_QWORD *, RB::CGContext *))(*v4 + 184))(v4, a2);
      v4 = (_QWORD *)v4[1];
    }
    while (v4);
  }
  return this;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  __int128 v16;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v16, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v16, *(int32x2_t *)((char *)&v16 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v16, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2, (const RB::Fill::Color *)(a1 + 88));
}

void RB::Coverage::Path::fill(RB::Coverage::Path *this, CGContextRef *a2, const RB::Fill::Color *a3)
{
  float64x2_t v6;
  float64x2_t *v7;
  float64x2_t v8;
  float64x2_t v9;
  int64x2_t v10;
  unint64_t v11;
  CGContext *v12;
  int v13;
  CGPathRef v31;
  CGPathRef v32;
  CGAffineTransform v33;
  CGAffineTransform v34;
  CGAffineTransform transform;

  if (*((_QWORD *)this + 1) != 0x209BD98A8)
  {
    v6 = 0uLL;
    memset(&v34, 0, sizeof(v34));
    v7 = (float64x2_t *)*((_QWORD *)this + 2);
    v8 = (float64x2_t)xmmword_209BD52A0;
    v9 = (float64x2_t)xmmword_209BD5290;
    if (v7)
    {
      v9 = *v7;
      v8 = v7[1];
      v6 = v7[2];
    }
    v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v8, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqzq_f64(v6)), (int8x16_t)vceqq_f64(v9, (float64x2_t)xmmword_209BD5290));
    v11 = vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0];
    if ((v11 & 0x8000000000000000) == 0)
    {
      *(float64x2_t *)&v33.c = v8;
      *(float64x2_t *)&v33.tx = v6;
      *(float64x2_t *)&v33.a = v9;
      CGContextGetCTM(&v34, *a2);
      v12 = *a2;
      transform = v33;
      CGContextConcatCTM(v12, &transform);
    }
    v13 = rb_clip_mode(*((unsigned __int8 *)this + 29));
    if (*((unsigned __int8 *)a2 + 140) != v13)
      RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v13);
    if (*((_BYTE *)a2 + 121) && *((_BYTE *)a3 + 9) && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
      goto LABEL_15;
    _H0 = *((_WORD *)a2 + 56);
    _H1 = *(_WORD *)a3;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_15;
    _H0 = *((_WORD *)a2 + 57);
    _H1 = *((_WORD *)a3 + 1);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_15;
    _H0 = *((_WORD *)a2 + 58);
    _H1 = *((_WORD *)a3 + 2);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_15;
    _H0 = *((_WORD *)a2 + 59);
    _H1 = *((_WORD *)a3 + 3);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
LABEL_15:
      RB::CGContext::set_fill_color_slow((RB::CGContext *)a2, a3, _D0);
    v31 = RBPathCopyCGPath(*(const CGPath **)this, *((_QWORD *)this + 1));
    if (v31)
    {
      v32 = v31;
      CGContextDrawPathDirect();
      CFRelease(v32);
    }
    if ((v11 & 0x8000000000000000) == 0)
    {
      transform = v34;
      CGContextSetCTM();
    }
  }
}

void sub_209AD50A4(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Bounds::contains(int32x2_t *a1, int32x2_t a2, int32x2_t a3)
{
  int32x2_t v3;
  uint32x2_t v4;
  int8x8_t v5;
  uint32x2_t v6;
  uint32x2_t v7;

  v3 = a1[1];
  v4 = (uint32x2_t)vceqz_s32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0)
    return 0;
  v5 = (int8x8_t)vcge_s32(a2, *a1);
  v6 = (uint32x2_t)vcge_s32(vadd_s32(*a1, v3), vadd_s32(a3, a2));
  v7 = (uint32x2_t)vcltz_s32(vshl_n_s32((int32x2_t)vand_s8((int8x8_t)vdup_n_s32(vpmin_u32(v6, v6).i32[0] < 0), v5), 0x1FuLL));
  return vpmin_u32(v7, v7).u32[0] >> 31;
}

void RB::CGContext::update_state_slow(uint64_t a1, float64x2_t *a2, float32x2_t *a3, unsigned int a4, _OWORD *a5, int a6, float a7)
{
  char v7;
  int v14;
  _OWORD *v15;
  uint64_t v16;
  unint64_t v17;
  int32x2_t v18;
  unint64_t v19;
  uint64_t v20;
  __int16 v21;
  uint64_t v22;
  __int16 v23;
  float v24;
  int v25;
  char v26;
  __int128 v27;
  _OWORD *v28;
  char v29;
  char v30;
  float32x2_t *v31;
  unint64_t v32;
  CGFloat y;
  CGFloat height;
  uint32x2_t v35;
  int32x2_t v36;
  uint32x2_t v37;
  int8x8_t v38;
  float32x2_t v39;
  float32x2_t v40;
  CGContext *v41;
  CGBlendMode v42;
  float64x2_t **v43;
  float32x2_t *v44;
  int32x2_t v45[2];
  int32x2_t v46[2];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  int32x2_t v50[4];
  CGRect v51;
  CGRect ClipBoundingBox;

  v7 = a6;
  if (a6)
  {
    v14 = *(unsigned __int8 *)(a1 + 141);
    goto LABEL_11;
  }
  v15 = (_OWORD *)(a1 + 80);
  if (*(_BYTE *)(a1 + 141))
  {
    CGContextRestoreGState(*(CGContextRef *)a1);
    v14 = *(_DWORD *)(a1 + 416);
    if (v14)
    {
      v16 = a1 + 152;
      if (*(_QWORD *)(a1 + 408))
        v16 = *(_QWORD *)(a1 + 408);
      v17 = v16 + ((unint64_t)(v14 - 1) << 6);
      *(_OWORD *)v50[0].i8 = *(_OWORD *)v17;
      v18 = *(int32x2_t *)(v17 + 16);
      v19 = *(_QWORD *)(v17 + 24);
      v20 = *(_QWORD *)(v17 + 32);
      v21 = *(_WORD *)(v17 + 40);
      v22 = *(_QWORD *)(v17 + 42);
      v23 = *(_WORD *)(v17 + 50);
      v24 = *(float *)(v17 + 52);
      v25 = *(_DWORD *)(v17 + 56);
      v26 = *(_BYTE *)(v17 + 60);
      v14 = *(unsigned __int8 *)(v17 + 61);
    }
    else
    {
      v26 = 0;
      v23 = 0;
      v21 = 0;
      v18 = vdup_n_s32(0xC0000001);
      *(_OWORD *)v50[0].i8 = 0uLL;
      v22 = 0x3C00000000000000;
      v19 = 0x8000000080000000;
      v25 = 2;
      v24 = 1.0;
      v20 = 0x3C00000000000000;
    }
    *v15 = *(_OWORD *)v50[0].i8;
    *(int32x2_t *)(a1 + 96) = v18;
    *(_QWORD *)(a1 + 104) = v19;
    *(_QWORD *)(a1 + 112) = v20;
    *(_WORD *)(a1 + 120) = v21;
    *(_QWORD *)(a1 + 122) = v22;
    *(_WORD *)(a1 + 130) = v23;
    *(float *)(a1 + 132) = v24;
    *(_DWORD *)(a1 + 136) = v25;
    *(_BYTE *)(a1 + 140) = v26;
    *(_BYTE *)(a1 + 141) = v14;
LABEL_11:
    v43 = (float64x2_t **)(a1 + 80);
    if (v14)
      goto LABEL_13;
    goto LABEL_12;
  }
  v43 = (float64x2_t **)(a1 + 80);
LABEL_12:
  CGContextSaveGState(*(CGContextRef *)a1);
  *(_BYTE *)(a1 + 141) = 1;
LABEL_13:
  if ((v7 & 1) != 0)
    goto LABEL_37;
  *(int32x2_t *)(a1 + 96) = vdup_n_s32(0xC0000001);
  *(_QWORD *)(a1 + 88) = a3;
  *(_QWORD *)(a1 + 104) = 0x8000000080000000;
  if (*(_QWORD *)(a1 + 80))
  {
    v27 = *(_OWORD *)(a1 + 48);
    v47 = *(_OWORD *)(a1 + 32);
    v48 = v27;
    v49 = *(_OWORD *)(a1 + 64);
    CGContextSetCTM();
    *(_QWORD *)(a1 + 80) = 0;
  }
  v28 = a5;
  if (!a3)
  {
    v30 = 0;
    v29 = 0;
    goto LABEL_31;
  }
  v29 = 0;
  v30 = 0;
  v31 = a3;
  do
  {
    v32 = *(_QWORD *)&v31[1] & 0xFFFFFFFFFFFFFFFELL;
    if (*(_BYTE *)(v32 + 44) == 1)
    {
      v29 = 1;
    }
    else if ((*(_BYTE *)(v32 + 45) & 1) != 0)
    {
      if (*(_BYTE *)(a1 + 140) != 1)
      {
        *(_BYTE *)(a1 + 140) = 1;
        CGContextSetShouldAntialias(*(CGContextRef *)a1, 0);
      }
      v51.origin.x = COERCE_FLOAT(*(_QWORD *)(v32 + 16));
      v51.origin.y = COERCE_FLOAT(HIDWORD(*(_QWORD *)(v32 + 16)));
      v51.size.width = COERCE_FLOAT(*(_QWORD *)(v32 + 24));
      v51.size.height = COERCE_FLOAT(HIDWORD(*(_QWORD *)(v32 + 24)));
      CGContextClipToRect(*(CGContextRef *)a1, v51);
    }
    else if ((*(float (**)(unint64_t))(*(_QWORD *)v32 + 104))(*(_QWORD *)&v31[1] & 0xFFFFFFFFFFFFFFFELL) == 1.0)
    {
      (*(void (**)(unint64_t, uint64_t))(*(_QWORD *)v32 + 88))(v32, a1);
    }
    else
    {
      v30 = 1;
    }
    v31 = (float32x2_t *)*v31;
  }
  while (v31);
  if ((v29 & 1) == 0)
  {
LABEL_31:
    if ((v30 & 1) == 0)
      goto LABEL_37;
  }
  *(_OWORD *)(a1 + 96) = *v28;
  *(_OWORD *)v50[0].i8 = *v28;
  RB::Bounds::Bounds(v46, a3[2], a3[3]);
  RB::Bounds::intersect(v50, v46[0], v46[1]);
  ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a1);
  y = ClipBoundingBox.origin.y;
  height = ClipBoundingBox.size.height;
  RB::Bounds::Bounds(v45, vcvt_f32_f64((float64x2_t)ClipBoundingBox.origin), vcvt_f32_f64((float64x2_t)ClipBoundingBox.size));
  RB::Bounds::intersect(v50, v45[0], v45[1]);
  v35 = (uint32x2_t)vcgtz_s32(v50[1]);
  v36 = (int32x2_t)vpmin_u32(v35, v35);
  if (v36.i32[0] < 0)
  {
    v36.i32[0] = 0;
    v37 = (uint32x2_t)vceq_s32(v50[1], (int32x2_t)0x8000000080000000);
    v38 = (int8x8_t)vdup_lane_s32(vcgt_s32(v36, (int32x2_t)vpmin_u32(v37, v37)), 0);
    v39 = (float32x2_t)vbsl_s8(v38, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v50[1]));
    v40 = (float32x2_t)vbsl_s8(v38, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v50[0]));
    if ((v29 & 1) != 0)
    {
      v44 = a3;
      RB::CGContext::add_soft_mask(a1, 2, (uint64_t)&v44, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v40, v39);
    }
    if ((v30 & 1) != 0)
    {
      v44 = a3;
      RB::CGContext::add_soft_mask(a1, 0, (uint64_t)&v44, (void (*)(CGContextRef *, uint64_t))RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_1 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke, v40, v39);
    }
  }
LABEL_37:
  if (*v43 != a2)
  {
    *(_QWORD *)(a1 + 80) = a2;
    if (a2)
      RB::operator*(a2, (float64x2_t *)(a1 + 32));
    CGContextSetCTM();
  }
  if (*(float *)(a1 + 132) != a7)
  {
    *(float *)(a1 + 132) = a7;
    CGContextSetAlpha(*(CGContextRef *)a1, a7);
  }
  if (*(_DWORD *)(a1 + 136) != a4)
  {
    *(_DWORD *)(a1 + 136) = a4;
    v41 = *(CGContext **)a1;
    v42 = RB::cg_blend_mode(a4);
    CGContextSetBlendMode(v41, v42);
  }
}

double RB::CGContext::set_fill_color_slow(RB::CGContext *this, const RB::Fill::Color *a2, uint16x4_t a3)
{
  uint64_t v4;
  double result;
  CGFloat components;
  uint64x2_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v4 = *(_QWORD *)a2;
  *((_WORD *)this + 60) = *((_WORD *)a2 + 4);
  *((_QWORD *)this + 14) = v4;
  LODWORD(v4) = *((unsigned __int8 *)this + 8);
  components = *(CGFloat *)a2;
  v16.i16[0] = *((_WORD *)a2 + 4);
  RB::Fill::Color::convert((uint64_t)&components, v4, a3);
  _Q0 = (uint64x2_t)vdupq_n_s64(*(unint64_t *)&components);
  _H1 = LOWORD(components);
  _S2 = HIWORD(*(_QWORD *)&components);
  __asm { FCVT            D1, H1 }
  components = _D1;
  *(int32x2_t *)_Q0.i8 = vmovn_s64((int64x2_t)vshlq_u64(_Q0, (uint64x2_t)xmmword_209BD7920));
  _Q0.i32[0] = vuzp1_s16(*(int16x4_t *)_Q0.i8, *(int16x4_t *)_Q0.i8).u32[0];
  LOWORD(_D1) = _Q0.i16[1];
  __asm
  {
    FCVT            D1, H1
    FCVT            D0, H0
  }
  _Q0.i64[1] = _D1;
  v16 = _Q0;
  __asm { FCVT            D0, H2 }
  v17 = _Q0.i64[0];
  CGContextSetFillColor(*(CGContextRef *)this, &components);
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Gradient>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, __int128 *a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  __int128 v17;
  __int128 v18;

  v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 176 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0xB0uLL, 15);
  else
    a1[2] = v13 + 176;
  v14 = *a5;
  v15 = *a6;
  v16 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C227720;
  *(_QWORD *)(v13 + 48) = v14;
  v17 = *a3;
  v18 = a3[1];
  *(_OWORD *)(v13 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v13 + 64) = v17;
  *(_OWORD *)(v13 + 80) = v18;
  RB::Fill::Gradient::Gradient((uint64_t *)(v13 + 112), a4, 0, a2);
  *(_QWORD *)v13 = &off_24C225F80;
  return v13;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, __int128 *a3, uint64_t *a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15;
  uint64_t v16;
  char v18;
  __int16 v19;
  __int128 v24;
  __int128 v25;

  v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 176 > a1[3])
    v15 = RB::Heap::alloc_slow(a1, 0xB0uLL, 15);
  else
    a1[2] = v15 + 176;
  v16 = *a5;
  _S0 = *a6;
  v18 = *a7;
  v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F;
  *(_QWORD *)v15 = off_24C227720;
  *(_QWORD *)(v15 + 48) = v16;
  v24 = *a3;
  v25 = a3[1];
  *(_OWORD *)(v15 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v15 + 64) = v24;
  *(_OWORD *)(v15 + 80) = v25;
  RB::Fill::Gradient::Gradient((uint64_t *)(v15 + 112), a4, v19, a2);
  *(_QWORD *)v15 = &off_24C225F80;
  return v15;
}

uint64_t *RB::Fill::Gradient::Gradient(uint64_t *a1, uint64_t *a2, __int16 a3, RB::Heap *this)
{
  uint64_t v8;
  char *v9;
  char *v10;
  __int16 v11;
  __int128 *v12;
  _OWORD *v13;
  __int128 v14;
  __int128 v15;

  v8 = *a2;
  *a1 = *a2;
  v9 = (char *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  v10 = &v9[16 * v8];
  if ((unint64_t)v10 > *((_QWORD *)this + 3))
  {
    v9 = (char *)RB::Heap::alloc_slow((size_t *)this, 16 * v8, 7);
    v8 = *a1;
  }
  else
  {
    *((_QWORD *)this + 2) = v10;
  }
  a1[1] = (uint64_t)v9;
  a1[2] = 0;
  a1[3] = a2[3];
  a1[4] = a2[4];
  a1[5] = a2[5];
  *((_DWORD *)a1 + 12) = *((_DWORD *)a2 + 12);
  *((_BYTE *)a1 + 52) = *((_BYTE *)a2 + 52);
  if (*((_BYTE *)a2 + 54))
    v11 = *(_WORD *)((char *)a2 + 53);
  else
    v11 = a3;
  *(_WORD *)((char *)a1 + 53) = v11;
  *(_WORD *)((char *)a1 + 55) = *(_WORD *)((char *)a2 + 55);
  if (v8)
    memmove(v9, (const void *)a2[1], 16 * v8);
  v12 = (__int128 *)a2[2];
  if (v12)
  {
    v13 = (_OWORD *)((*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v13 + 3) > *((_QWORD *)this + 3))
      v13 = (_OWORD *)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 15);
    else
      *((_QWORD *)this + 2) = v13 + 3;
    v14 = *v12;
    v15 = v12[2];
    v13[1] = v12[1];
    v13[2] = v15;
    *v13 = v14;
    a1[2] = (uint64_t)v13;
  }
  return a1;
}

uint64_t *RB::Fill::Gradient::Gradient(uint64_t *a1, uint64_t *a2, __int16 a3, RB::Heap *a4)
{
  return RB::Fill::Gradient::Gradient(a1, a2, a3, a4);
}

void RB::CGContext::add_soft_mask(uint64_t a1, int a2, uint64_t a3, void (*a4)(CGContextRef *, uint64_t), float32x2_t a5, float32x2_t a6)
{
  float32x2_t v10;
  CGSize v11;
  CGFloat height;
  CGLayer *v13;
  CGLayer *v14;
  CGContext *Context;
  int Type;
  const void *SoftMask;
  double v18;
  float v19;
  double v20;
  float v21;
  unint64_t v22;
  int8x16_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  int64x2_t v29;
  _QWORD *v30;
  const void *v31;
  uint16x4_t v37;
  CGContext *v38;
  CFStringRef *v39;
  const void *v40;
  int8x16_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float32x2_t v45;
  float64x2_t v46[3];
  __int128 v47;
  float64x2_t v48;
  float64x2_t v49;
  CGContextRef c[18];
  int v51;
  uint64_t v52;
  CGRect ClipBoundingBox;

  v52 = *MEMORY[0x24BDAC8D0];
  v10 = vrndm_f32(a5);
  v11 = (CGSize)vcvtq_f64_f32(vsub_f32(vrndp_f32(vadd_f32(a6, a5)), v10));
  v45 = v10;
  height = v11.height;
  v13 = CGLayerCreateWithContext(0, v11, 0);
  if (v13)
  {
    v14 = v13;
    Context = CGLayerGetContext(v13);
    CGContextTranslateCTM(Context, (float)-v45.f32[0], (float)-v45.f32[1]);
    RB::CGContext::CGContext((uint64_t)c, Context, (char *)*(unsigned __int8 *)(a1 + 8), *(double *)(a1 + 16));
    Type = *(_DWORD *)(a1 + 144);
    if (Type < 0)
    {
      Type = CGContextGetType();
      *(_DWORD *)(a1 + 144) = Type;
    }
    v51 = Type;
    SoftMask = (const void *)CGContextGetSoftMask();
    if (SoftMask)
    {
      CGSoftMaskGetMatrix();
      v43 = v48;
      v44 = (float64x2_t)v47;
      v42 = v49;
      CGSoftMaskGetBounds();
      v19 = v18;
      v21 = v20;
      v41 = (int8x16_t)vmlaq_n_f64(vmlaq_n_f64(v49, (float64x2_t)v47, (float)-v19), v48, (float)-v21);
      v49 = (float64x2_t)v41;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v47))
        v22 = -1;
      else
        v22 = 0;
      v23 = (int8x16_t)vdupq_n_s64(v22);
      v46[0] = (float64x2_t)vbslq_s8(v23, (int8x16_t)v47, (int8x16_t)v44);
      v46[1] = (float64x2_t)vbslq_s8(v23, (int8x16_t)v48, (int8x16_t)v43);
      v46[2] = (float64x2_t)vbslq_s8(v23, (int8x16_t)v49, v41);
      v24 = *(float64x2_t *)(a1 + 48);
      v25 = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a1 + 32), v45.f32[0]), v24, v45.f32[1]);
      v47 = *(_OWORD *)(a1 + 32);
      v48 = v24;
      v49 = v25;
      v26.f64[0] = RB::operator*(v46, (float64x2_t *)&v47);
      v29 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v27, v43), (int8x16_t)vceqq_f64(v26, v44)), (int8x16_t)vceqq_f64(v28, v42));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v29, 1), (int8x16_t)v29).u64[0] & 0x8000000000000000) != 0)
      {
        CGContextSetSoftMask();
      }
      else
      {
        v47 = xmmword_24C22B480;
        *(_QWORD *)&v48.f64[0] = RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_1::__invoke;
        v30 = (_QWORD *)operator new();
        CFRetain(SoftMask);
        *v30 = SoftMask;
        CGSoftMaskGetBackground();
        CGSoftMaskGetTransfer();
        v31 = (const void *)CGSoftMaskCreate();
        CGContextSetSoftMask();
        if (v31)
          CFRelease(v31);
      }
      if (a2 == 2)
      {
        *(_QWORD *)&v47 = 0x3C003C003C003C00;
        WORD4(v47) = 0;
        __asm { FMOV            V1.4S, #1.0 }
        v37 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16((float16x4_t)c[14]), _Q1)));
        v37.i16[0] = vmaxv_u16(v37);
        if ((v37.i8[0] & 1) != 0)
          RB::CGContext::set_fill_color_slow((RB::CGContext *)c, (const RB::Fill::Color *)&v47, v37);
        v38 = c[0];
        ClipBoundingBox = CGContextGetClipBoundingBox(c[0]);
        CGContextFillRect(v38, ClipBoundingBox);
        a2 = 1;
      }
    }
    a4(c, a3);
    v47 = xmmword_24C22B498;
    *(_QWORD *)&v48.f64[0] = RB::CGContext::add_soft_mask(RB::CGContext::SoftMaskMode,RB::Rect,void const*,void (*)(RB::CGContext&,void const*))::$_3::__invoke;
    *(_QWORD *)operator new() = v14;
    if (a2)
    {
      v39 = (CFStringRef *)MEMORY[0x24BDBF200];
      if (a2 != 1)
        v39 = (CFStringRef *)MEMORY[0x24BDBF330];
      CGColorGetConstantColor(*v39);
    }
    v40 = (const void *)CGSoftMaskCreate();
    CGContextSetSoftMask();
    if (v40)
      CFRelease(v40);
    RB::CGContext::~CGContext(c);
  }
}

void sub_209AD5D64(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,CGContextRef a45)
{
  const void *v45;

  RB::CGContext::~CGContext(&a45);
  CFRelease(v45);
  _Unwind_Resume(a1);
}

uint64_t RB::CGContext::add_soft_mask<RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0>(RB::CGContext::SoftMaskMode,RB::Rect,RB::CGContext::update_state_slow(RB::AffineTransform const*,RB::DisplayList::ClipNode const*,float,RB::BlendMode,RB::Bounds const&,BOOL)::$_0 const&)::{lambda(RB::CGContext&,void const*)#1}::__invoke(uint64_t result, _QWORD *a2)
{
  _QWORD *v2;
  uint64_t v3;
  _BYTE *v4;
  int v10;
  __int16 v11;
  __int16 v12;
  __int16 v13;

  v2 = (_QWORD *)*a2;
  if (*a2)
  {
    v3 = result;
    do
    {
      v4 = (_BYTE *)(v2[1] & 0xFFFFFFFFFFFFFFFELL);
      if (v4[44] == 1)
      {
        _S0 = (*(float (**)(unint64_t))(*(_QWORD *)v4 + 104))(v2[1] & 0xFFFFFFFFFFFFFFFELL);
        __asm { FCVT            H0, S0 }
        v10 = 0;
        v11 = 0;
        v12 = LOWORD(_S0);
        v13 = 0;
        result = (*(uint64_t (**)(_BYTE *, uint64_t, int *))(*(_QWORD *)v4 + 96))(v4, v3, &v10);
      }
      v2 = (_QWORD *)*v2;
    }
    while (v2);
  }
  return result;
}

float RB::DisplayList::GenericClip<RB::Coverage::Path>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 88);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::fill(uint64_t a1, CGContextRef *a2, RB::Fill::Color *a3)
{
  float64x2_t *v6;
  int64x2_t v7;
  CGContext *v8;
  float64x2_t v9;
  CGAffineTransform v10;
  CGAffineTransform transform;

  memset(&v10, 0, sizeof(v10));
  v6 = *(float64x2_t **)(a1 + 48);
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v6[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), a2, a3);
  }
  else
  {
    CGContextGetCTM(&v10, *a2);
    v8 = *a2;
    v9 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v9;
    *(float64x2_t *)&transform.tx = v6[2];
    CGContextConcatCTM(v8, &transform);
    RB::Coverage::Path::fill((RB::Coverage::Path *)(a1 + 56), a2, a3);
    transform = v10;
    CGContextSetCTM();
  }
}

float32x2_t *RB::Stroke::FixedWidthLineBounds::endpath(float32x2_t *this, double a2, double a3)
{
  return RB::Stroke::LineBounds::endpath(this + 2, a2, a3);
}

float32x2_t *RB::Stroke::LineBounds::endpath(float32x2_t *this, double a2, double a3)
{
  uint64_t v3;
  double v4;

  if (!this[8].i8[0])
  {
    v3 = (uint64_t)this;
    LODWORD(a3) = this[7].i32[1];
    RB::Stroke::LineBounds::add_cap(this, 0, this[4], a3, (int8x8_t)this[5]);
    LODWORD(v4) = *(_DWORD *)(v3 + 56);
    return RB::Stroke::LineBounds::add_cap((float32x2_t *)v3, 1, *(float32x2_t *)(v3 + 24), v4, *(int8x8_t *)(v3 + 48));
  }
  return this;
}

void RB::ObjectTable::~ObjectTable(const void ***this)
{
  const void **v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;

  v2 = *this;
  v3 = *((unsigned int *)this + 2);
  if ((_DWORD)v3)
  {
    v4 = 8 * v3;
    do
    {
      v5 = (unint64_t)*v2;
      if (*v2)
      {
        if ((v5 & 1) != 0)
          (**(void (***)(unint64_t))(v5 & 0xFFFFFFFFFFFFFFFELL))(v5 & 0xFFFFFFFFFFFFFFFELL);
        else
          CFRelease((CFTypeRef)v5);
      }
      ++v2;
      v4 -= 8;
    }
    while (v4);
    v2 = *this;
  }
  if (v2)
    free(v2);
}

float32x2_t *RB::Stroke::LineBounds::add_cap(float32x2_t *result, int a2, float32x2_t a3, double a4, int8x8_t a5)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  unsigned int v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  int32x2_t v13;
  float32x2_t v14;
  int8x8_t v15;
  unsigned int v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int8x8_t v27;
  unsigned int v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float32x2_t v37;
  float32x2_t v38;
  float32x2_t v39;
  float32x2_t v40;

  switch(result->i8[0])
  {
    case 0:
      v5 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0);
      v6 = vminnm_f32(result[1], vsub_f32(a3, v5));
      v7 = vmaxnm_f32(result[2], vadd_f32(v5, a3));
      result[1] = v6;
      goto LABEL_19;
    case 1:
    case 4:
      goto LABEL_8;
    case 2:
      if (a2)
        v8 = -1;
      else
        v8 = 0;
      v9 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v8), a5, (int8x8_t)vneg_f32((float32x2_t)a5));
      v10 = vmul_f32(v9, v9);
      v10.i32[0] = vadd_f32(v10, (float32x2_t)vdup_lane_s32((int32x2_t)v10, 1)).u32[0];
      v11 = vrsqrte_f32((float32x2_t)v10.u32[0]);
      v12 = vmul_f32(vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(v11, v11)), v11);
      v13 = (int32x2_t)vmul_f32(v12, vrsqrts_f32((float32x2_t)v10.u32[0], vmul_f32(v12, v12)));
      v14 = vmul_n_f32(v9, *(float *)v13.i32);
      goto LABEL_12;
    case 3:
      goto LABEL_14;
    case 5:
      if ((a2 & 1) == 0)
        goto LABEL_8;
      goto LABEL_14;
    case 6:
      if ((a2 & 1) != 0)
      {
LABEL_8:
        v15 = (int8x8_t)vneg_f32((float32x2_t)a5);
        if (a2)
          v16 = -1;
        else
          v16 = 0;
        v17 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v16), a5, v15);
        v18 = vmul_f32(v17, v17);
        v18.i32[0] = vadd_f32(v18, (float32x2_t)vdup_lane_s32((int32x2_t)v18, 1)).u32[0];
        v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
        v20 = vmul_f32(vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)), v19);
        v13 = (int32x2_t)vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20)));
        v14 = vmul_n_f32(v17, *(float *)v13.i32);
        a3 = vmla_n_f32(a3, v14, *(float *)&a4);
LABEL_12:
        *(float *)v13.i32 = -v14.f32[1];
        v21 = vmul_n_f32((float32x2_t)vzip1_s32(v13, (int32x2_t)v14), *(float *)&a4);
        v22 = vadd_f32(v21, a3);
        v23 = vminnm_f32(result[1], v22);
        v24 = vmaxnm_f32(result[2], v22);
        v25 = vsub_f32(a3, v21);
        v26 = vminnm_f32(v23, v25);
      }
      else
      {
LABEL_14:
        v27 = (int8x8_t)vneg_f32((float32x2_t)a5);
        if (a2)
          v28 = -1;
        else
          v28 = 0;
        v29 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v28), a5, v27);
        v30 = vmul_f32(v29, v29);
        v30.i32[0] = vadd_f32(v30, (float32x2_t)vdup_lane_s32((int32x2_t)v30, 1)).u32[0];
        v31 = vrsqrte_f32((float32x2_t)v30.u32[0]);
        v32 = vmul_f32(vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v31, v31)), v31);
        v33 = vmul_n_f32(v29, vmul_f32(v32, vrsqrts_f32((float32x2_t)v30.u32[0], vmul_f32(v32, v32))).f32[0]);
        v34 = vmla_n_f32(a3, v33, *(float *)&a4);
        v35 = result[2];
        v36 = vminnm_f32(result[1], v34);
        v37 = vmaxnm_f32(v35, v34);
        v35.f32[0] = -v33.f32[1];
        v38 = vmul_n_f32((float32x2_t)vzip1_s32((int32x2_t)v35, (int32x2_t)v33), *(float *)&a4);
        v39 = vadd_f32(v38, a3);
        v40 = vminnm_f32(v36, v39);
        v24 = vmaxnm_f32(v37, v39);
        v25 = vsub_f32(a3, v38);
        v26 = vminnm_f32(v40, v25);
      }
      v7 = vmaxnm_f32(v24, v25);
      result[1] = v26;
LABEL_19:
      result[2] = v7;
      break;
    default:
      return result;
  }
  return result;
}

uint64_t $_3::__invoke($_3 *this, const void *a2)
{
  return 0;
}

float64x2_t RB::Coverage::`anonymous namespace'::simplify_stroked_shape_callback(uint64_t (****a1)(_QWORD, uint64_t *), unsigned int a2, uint64_t a3)
{
  uint64_t (***v4)(_QWORD, uint64_t *);
  uint64_t v5;
  float64x2_t result;
  __int128 v9;
  __int128 v10;
  __int128 v12;
  __int128 v13;
  _BOOL4 v14;
  unsigned int v15;
  unsigned int v16;
  void (***v17)(_QWORD, float64x2_t *);
  unsigned int v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float32x2_t v22;
  unsigned int v23;
  __int128 v24;
  __int128 v25;
  BOOL v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  char v30;
  float v31;
  float v32;
  float v33;
  float v34;
  double v35;
  double v36;
  double v37;
  float v38;
  float v39;
  double v40;
  float v41;
  float v42;
  __int128 v43;
  __int128 v44;
  float64x2_t v45;
  float64x2_t v46;
  __int128 v47;
  __int128 v48;

  v4 = a1[9];
  v5 = (uint64_t)(a1 + 2);
  v43 = *((_OWORD *)a1 + 1);
  v44 = *((_OWORD *)a1 + 2);
  result = *((float64x2_t *)a1 + 3);
  v45 = result;
  if (a2 > 5)
    goto LABEL_52;
  if (((1 << a2) & 0x1B) == 0)
  {
    if (a2 != 2)
    {
      result = *(float64x2_t *)(a3 + 16);
      v24 = *(_OWORD *)(a3 + 32);
      v25 = *(_OWORD *)(a3 + 48);
      v46 = result;
      v47 = v24;
      v48 = v25;
      if (result.f64[0] == *((double *)&v24 + 1) && result.f64[1] == 0.0 && *(double *)&v24 == 0.0
        || *((double *)&v24 + 1) == 0.0
        && (result.f64[0] == 0.0 ? (v26 = result.f64[1] == *(double *)&v24) : (v26 = 0), v26))
      {
        *(double *)&v27 = RB::operator*(&v46, (float64x2_t *)v5);
        *((_OWORD *)a1 + 1) = v27;
        *((_OWORD *)a1 + 2) = v28;
        *((_OWORD *)a1 + 3) = v29;
      }
      goto LABEL_52;
    }
    v15 = *((unsigned __int8 *)a1 + 64);
    if (v15 > 1 || (v16 = *((_DWORD *)v4 + 6), v16 > 2))
    {
      v30 = 0;
LABEL_51:
      *((_BYTE *)a1 + 96) = v30;
      goto LABEL_52;
    }
    v17 = (void (***)(_QWORD, float64x2_t *))*a1;
    *(float *)&v18 = *((double *)a1 + 10);
    v19 = *((float64x2_t *)a1 + 1);
    v20 = *((float64x2_t *)a1 + 2);
    v21 = vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)a1 + 3), v19, *(double *)a3), v20, *(double *)(a3 + 8));
    v22 = vcvt_f32_f64(vsubq_f64(vmlaq_n_f64(vmlaq_n_f64(*((float64x2_t *)a1 + 3), v19, *(double *)(a3 + 16)), v20, *(double *)(a3 + 24)), v21));
    *(float *)&v23 = *((double *)a1 + 11);
    *(float32x2_t *)&v46.f64[0] = vcvt_f32_f64(v21);
    *(float32x2_t *)&v46.f64[1] = v22;
    v47 = 0uLL;
    LODWORD(v48) = 1065353216;
    *(_QWORD *)((char *)&v48 + 4) = __PAIR64__(v23, v18);
    BYTE12(v48) = v16 + 6;
    *(_WORD *)((char *)&v48 + 13) = v15;
    (**v17)(v17, &v46);
LABEL_50:
    v30 = 1;
    goto LABEL_51;
  }
  result = *(float64x2_t *)a3;
  v9 = *(_OWORD *)(a3 + 16);
  v10 = *(_OWORD *)(a3 + 32);
  v46 = result;
  v47 = v9;
  v48 = v10;
  if (result.f64[0] != *((double *)&v9 + 1) || result.f64[1] != 0.0 || *(double *)&v9 != 0.0)
  {
    if (*((double *)&v9 + 1) != 0.0)
      goto LABEL_52;
    if (result.f64[0] != 0.0 || result.f64[1] != *(double *)&v9)
      goto LABEL_52;
  }
  result.f64[0] = RB::operator*(&v46, (float64x2_t *)v5);
  *((float64x2_t *)a1 + 1) = result;
  *((_OWORD *)a1 + 2) = v12;
  *((_OWORD *)a1 + 3) = v13;
  *(_QWORD *)&result.f64[0] = v4[2];
  if (result.f64[0] >= 1.5)
  {
    if (*((_DWORD *)v4 + 7))
    {
      LOBYTE(v14) = 0;
      goto LABEL_35;
    }
    *(_QWORD *)&result.f64[0] = v4[4];
    v14 = result.f64[0] >= 1.41421354;
    if (a2)
      goto LABEL_35;
  }
  else
  {
    v14 = 1;
    if (a2)
      goto LABEL_35;
  }
  if (v14)
  {
    v31 = *((double *)a1 + 10);
    v32 = *((double *)a1 + 11);
    goto LABEL_50;
  }
LABEL_35:
  if (a2 != 4)
  {
    if (a2 == 3)
    {
      result.f64[0] = *(float64_t *)(a3 + 80);
      v40 = *(double *)(a3 + 88);
      if (result.f64[0] != v40 || *(_DWORD *)(a3 + 96))
        goto LABEL_52;
      v41 = *((double *)a1 + 10);
      v42 = *((double *)a1 + 11);
    }
    else
    {
      if (a2 != 1)
        goto LABEL_52;
      result.f64[0] = *(float64_t *)(a3 + 64);
      if (result.f64[0] != *(double *)(a3 + 72))
        goto LABEL_52;
      v33 = *((double *)a1 + 10);
      v34 = *((double *)a1 + 11);
    }
    goto LABEL_50;
  }
  if (!*(_DWORD *)(a3 + 112))
  {
    result.f64[0] = *(float64_t *)(a3 + 80);
    v35 = *(double *)(a3 + 88);
    v36 = *(double *)(a3 + 96);
    v37 = *(double *)(a3 + 104);
    if (v14 || result.f64[0] != 0.0 && v35 != 0.0 && v36 != 0.0 && v37 != 0.0)
    {
      v38 = *((double *)a1 + 10);
      v39 = *((double *)a1 + 11);
    }
  }
LABEL_52:
  if (!*((_BYTE *)a1 + 96))
  {
    *(_OWORD *)v5 = v43;
    *(_OWORD *)(v5 + 16) = v44;
    result = v45;
    *(float64x2_t *)(v5 + 32) = v45;
  }
  return result;
}

RB::Path::Storage::MapCache *RB::Path::Storage::append_storage(RB::Path::Storage::MapCache *this, const RB::Path::Storage *a2)
{
  unint64_t v2;
  uint64_t v3;
  RB::Path::Storage::MapCache *v5;
  uint64_t v6;
  unsigned int v7;
  os_unfair_lock_s *v8;
  const void *v9;
  unsigned int v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  size_t v15;
  int v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  _QWORD *v20;
  int v21;

  v2 = *((unsigned int *)a2 + 2);
  if ((v2 & 1) != 0)
    v3 = *((_QWORD *)a2 + 3);
  else
    v3 = (v2 >> 8) & 0xFFF;
  if (!v3)
    return this;
  v5 = this;
  v6 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    *(_QWORD *)this = 0;
    if ((v6 & 1) != 0)
    {
      this = (RB::Path::Storage::MapCache *)(v6 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v6 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        this = (RB::Path::Storage::MapCache *)MEMORY[0x20BD1652C](this, 0x1000C8052888210);
    }
  }
  v7 = *((_DWORD *)v5 + 2);
  if ((v7 & 0x20) != 0)
  {
    v8 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v8, v5);
    v7 = *((_DWORD *)v5 + 2);
  }
  if ((v7 & 1) != 0)
  {
    v9 = (const void *)*((_QWORD *)v5 + 7);
    if (v9)
    {
      *((_QWORD *)v5 + 7) = 0;
      CFRelease(v9);
      v7 = *((_DWORD *)v5 + 2);
    }
  }
  if ((v7 & 1) != 0)
  {
    if (*((_QWORD *)v5 + 3))
      goto LABEL_19;
  }
  else if (((v7 >> 8) & 0xFFF) != 0)
  {
    goto LABEL_19;
  }
  if ((*((_BYTE *)a2 + 8) & 8) != 0)
  {
    v10 = v7 | 8;
    goto LABEL_20;
  }
LABEL_19:
  v10 = v7 & 0xFFFFFFF7;
LABEL_20:
  *((_DWORD *)v5 + 2) = v10;
  *((_DWORD *)v5 + 2) = *((_DWORD *)a2 + 2) & 0x26 | v10;
  v11 = *((unsigned int *)a2 + 2);
  v12 = (char *)*((_QWORD *)a2 + 2);
  v13 = *((_QWORD *)a2 + 3);
  v14 = (char *)a2 + 16;
  if ((v11 & 1) != 0)
  {
    v14 = v12;
    v15 = v13;
  }
  else
  {
    v15 = (v11 >> 8) & 0xFFF;
  }
  v16 = v10 & 1;
  if ((v10 & 1) != 0)
  {
    v17 = *((_QWORD *)v5 + 3);
    v18 = *((_QWORD *)v5 + 4);
  }
  else
  {
    v17 = (v10 >> 8) & 0xFFF;
    v18 = v10 >> 20;
  }
  v19 = v17 + v15;
  if (v18 < v17 + v15)
  {
    RB::Path::Storage::reserve_slow(v5, v17 + v15);
    v16 = *((_DWORD *)v5 + 2) & 1;
  }
  v20 = (_QWORD *)((char *)v5 + 16);
  if (v16)
    v20 = (_QWORD *)*v20;
  this = (RB::Path::Storage::MapCache *)memcpy((char *)v20 + v17, v14, v15);
  v21 = *((_DWORD *)v5 + 2);
  if ((v21 & 1) != 0)
    *((_QWORD *)v5 + 3) = v19;
  else
    *((_DWORD *)v5 + 2) = v21 & 0xFFF000FF | ((v19 & 0xFFF) << 8);
  return this;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226F78;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::endpath(uint64_t a1)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::endpath(a1 + 8);
}

BOOL RB::Symbol::Animator::set_presentation_position(uint64_t a1, float32x2_t a2)
{
  uint32x2_t v4;
  signed __int32 v5;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(a1 + 48), a2);
  v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    *(double *)(a1 + 48) = *(double *)&a2;
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v5 >= 0;
}

RB::Symbol::Animator *RB::Symbol::Animator::Animator(RB::Symbol::Animator *this)
{
  uint64_t v2;

  *(_DWORD *)this = 0;
  v2 = operator new();
  *(_OWORD *)v2 = 0u;
  *(_OWORD *)(v2 + 16) = 0u;
  *(_OWORD *)(v2 + 32) = 0u;
  *(_OWORD *)(v2 + 48) = 0u;
  *(_OWORD *)(v2 + 64) = 0u;
  *(_OWORD *)(v2 + 80) = 0u;
  *(_DWORD *)(v2 + 8) = 1;
  *(_QWORD *)v2 = off_24C229870;
  *(_QWORD *)(v2 + 16) = 0;
  *(_QWORD *)(v2 + 24) = 0;
  *(_QWORD *)(v2 + 32) = 0;
  *(_QWORD *)(v2 + 40) = 0x3F0000003F000000;
  __asm { FMOV            V1.2S, #1.0 }
  *(int32x2_t *)(v2 + 56) = vdup_n_s32(0x7F800000u);
  *(_QWORD *)(v2 + 64) = _D1;
  *(_DWORD *)(v2 + 80) = -1;
  *(_BYTE *)(v2 + 90) = 0;
  *(_WORD *)(v2 + 88) = 0;
  *(_DWORD *)(v2 + 91) = 775913471;
  *(_QWORD *)(v2 + 96) = 0;
  *((_QWORD *)this + 1) = v2;
  *((_OWORD *)this + 1) = 0u;
  *((_OWORD *)this + 2) = 0u;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 2139095040;
  *((_DWORD *)this + 16) = 0;
  return this;
}

RB::XML::Document *RBDrawingStateTranslateCTM(uint64_t a1, double a2, double a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::Document *result;

  v6 = *(_QWORD *)(a1 + 8);
  RB::DisplayList::State::translate(a1, a2, a3);
  result = *(RB::XML::Document **)(v6 + 304);
  if (result)
    return RB::XML::DisplayList::translate_ctm(result, (_RBDrawingState *)a1, v7, a2, a3);
  return result;
}

uint64_t RB::DisplayList::State::translate(uint64_t this, double a2, double a3)
{
  if (a2 != 0.0 || a3 != 0.0)
  {
    *(float64x2_t *)(this + 48) = vmlaq_n_f64(vmlaq_n_f64(*(float64x2_t *)(this + 48), *(float64x2_t *)(this + 16), a2), *(float64x2_t *)(this + 32), a3);
    *(_QWORD *)(this + 112) = 0;
    *(_DWORD *)(this + 148) = -1;
  }
  return this;
}

void RBDrawingStateSetIdentifier(uint64_t a1, int a2, void *a3)
{
  const RB::Identity *v6;
  uint64_t v7;
  int v8;
  __int128 v9;
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  if (a3)
  {
    uuid_clear((unsigned __int8 *)&v9);
    v8 = a2;
    objc_msgSend(a3, "getUUIDBytes:", &v9);
LABEL_3:
    return;
  }
  v7 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v7 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  if (*(_QWORD *)(v7 + 304))
  {
    uuid_clear((unsigned __int8 *)&v9);
    v8 = a2;
    v9 = *(_OWORD *)(a1 + 68);
    goto LABEL_3;
  }
  *(_DWORD *)(a1 + 64) = a2;
}

uint64_t RBDrawingStateGetIdentifierNamespace2(uint64_t a1)
{
  unsigned __int8 v2[24];
  uuid_t dst;
  uint64_t v4;

  v4 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v2 = *(_OWORD *)(a1 + 68);
  uuid_copy(dst, v2);
  return *(_QWORD *)dst;
}

double RBColorFromLinear(int8x16_t a1, float a2, float a3)
{
  float v3;
  float v4;
  int8x16_t v5;
  double result;
  int8x16_t v7;
  int8x16_t v8;

  v8 = a1;
  if (*(float *)a1.i32 <= 0.0)
    *(float *)a1.i32 = -*(float *)a1.i32;
  if (*(float *)a1.i32 <= 0.0031308)
    *(float *)a1.i32 = *(float *)a1.i32 * 12.92;
  else
    *(float *)a1.i32 = (float)(powf(*(float *)a1.i32, 0.41667) * 1.055) + -0.055;
  v7 = a1;
  v3 = -a2;
  if (a2 > 0.0)
    v3 = a2;
  if (v3 > 0.0031308)
    powf(v3, 0.41667);
  v4 = -a3;
  if (a3 > 0.0)
    v4 = a3;
  if (v4 > 0.0031308)
    powf(v4, 0.41667);
  v5.i64[0] = 0x8000000080000000;
  v5.i64[1] = 0x8000000080000000;
  *(_QWORD *)&result = vbslq_s8(v5, v7, v8).u64[0];
  return result;
}

void ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke(uint64_t a1, void *a2)
{
  RB::Device::RenderPipelineEntry::Loader::pipeline(*(RB::Device::RenderPipelineEntry::Loader **)(a1 + 32), a2);
}

uint64_t RBSymbolUpdateLayerStyle(_DWORD *a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v1 = *(_QWORD *)a1 + 8;
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~a1[2];
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v1 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v3 = *((_QWORD *)a1 + 2);
  v4 = *(_QWORD **)(v1 + 416 * v2 + 400);
  if (v4)
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * *((_QWORD *)a1 + 2));
  v5 = v1 + 416 * v2;
  v6 = v5 + 16;
  v7 = *(_QWORD *)(v5 + 376);
  if (!v7)
    v7 = v6;
  if (*(float *)(v7 + 120 * v3 + 20) == -32768.0)
    return (*(_DWORD *)(*(_QWORD *)(v7 + 120 * v3) + 84) >> 8) & 0xF;
  else
    return 11;
}

RB::Path::Storage *RBPathStorageInit(RB::Path::Storage *result, const char *a2, const RB::Path::Storage *a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;

  if (a3)
    return RB::Path::Storage::Storage(result, a2, a3);
  *(_QWORD *)result = 0;
  if ((unint64_t)a2 <= 0x3F)
    RB::precondition_failure((RB *)"invalid capacity", a2);
  v3 = (_DWORD)a2 - 16;
  if ((unint64_t)(a2 - 16) >= 0xFFF)
    v3 = 4095;
  *((_DWORD *)result + 2) = v3 << 20;
  do
  {
    v4 = __ldxr(&RB::Path::Storage::_last_identifier);
    v5 = v4 + 1;
  }
  while (__stxr(v5, &RB::Path::Storage::_last_identifier));
  *((_DWORD *)result + 3) = v5;
  return result;
}

void RBXMLRecorderMarkCGFrame(void *a1, CGContextRef c)
{
  CGRect ClipBoundingBox;

  if (RB::XMLRecorder::enabled)
  {
    ClipBoundingBox = CGContextGetClipBoundingBox(c);
    RBXMLRecorderMarkFrame(c, a1, 1, ClipBoundingBox.size.width, ClipBoundingBox.size.height);
  }
}

uint64_t RB::Symbol::Animator::set_variable_value(os_unfair_lock_s *this, float a2)
{
  RB::Symbol::Model *v4;
  int v5;
  uint64_t v6;

  os_unfair_lock_lock(this);
  if (*(float *)&this[14]._os_unfair_lock_opaque == a2
    || (v4 = *(RB::Symbol::Model **)&this[2]._os_unfair_lock_opaque,
        *(float *)&this[14]._os_unfair_lock_opaque = a2,
        v5 = RB::Symbol::Model::glyph_value_index(v4, a2),
        *(_DWORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 80) == v5))
  {
    v6 = 0;
  }
  else
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&this[2]);
    *(_DWORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 80) = v5;
    ++this[15]._os_unfair_lock_opaque;
    v6 = 1;
  }
  os_unfair_lock_unlock(this);
  return v6;
}

void sub_209AD6E70(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RBPathStorageIsEmpty(uint64_t a1)
{
  unint64_t v1;
  uint64_t v2;

  v1 = *(unsigned int *)(a1 + 8);
  if ((v1 & 1) != 0)
    v2 = *(_QWORD *)(a1 + 24);
  else
    v2 = (v1 >> 8) & 0xFFF;
  return v2 == 0;
}

void `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info::~Info(_QWORD *a1)
{
  void (*v1)(_QWORD);

  *a1 = off_24C22A188;
  v1 = *(void (**)(_QWORD))(a1[3] + 16);
  if (v1)
    v1(a1[2]);
  JUMPOUT(0x20BD16544);
}

BOOL RB::Symbol::Animator::set_size(os_unfair_lock_s *a1, float32x2_t a2)
{
  uint32x2_t v4;
  signed __int32 v5;

  os_unfair_lock_lock(a1);
  v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 56), a2);
  v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&a1[2]);
    *(double *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 56) = *(double *)&a2;
    ++a1[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(a1);
  return v5 >= 0;
}

void sub_209AD7080(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_anchor_point(os_unfair_lock_s *a1, float32x2_t a2)
{
  uint32x2_t v4;
  signed __int32 v5;

  os_unfair_lock_lock(a1);
  v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 40), a2);
  v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&a1[2]);
    *(double *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 40) = *(double *)&a2;
    ++a1[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(a1);
  return v5 >= 0;
}

void sub_209AD7144(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_glyph(RB::Symbol::Animator *this, CUINamedVectorGlyph *a2)
{
  CUINamedVectorGlyph *v4;

  os_unfair_lock_lock((os_unfair_lock_t)this);
  v4 = *(CUINamedVectorGlyph **)(*((_QWORD *)this + 1) + 16);
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write((RB::Symbol::Animator *)((char *)this + 8));
    RB::Symbol::Model::set_glyph(*((RB::Symbol::Model **)this + 1), a2, *((float *)this + 14));
    ++*((_DWORD *)this + 15);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)this);
  return v4 != a2;
}

void sub_209AD7208(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Animator::set_position(os_unfair_lock_s *a1, float32x2_t a2)
{
  uint32x2_t v4;
  signed __int32 v5;

  os_unfair_lock_lock(a1);
  v4 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 48), a2);
  v5 = vpmin_u32(v4, v4).u32[0];
  if ((v5 & 0x80000000) == 0)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)&a1[2]);
    *(double *)(*(_QWORD *)&a1[2]._os_unfair_lock_opaque + 48) = *(double *)&a2;
    ++a1[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(a1);
  return v5 >= 0;
}

void sub_209AD72CC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const RB::Symbol::Model *RB::Symbol::Model::copy_on_write(const RB::Symbol::Model *result)
{
  const RB::Symbol::Model **v1;
  RB::Symbol::Model *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  if (*(_DWORD *)(*(_QWORD *)result + 8) == 1)
  {
    __dmb(9u);
  }
  else
  {
    v1 = (const RB::Symbol::Model **)result;
    v2 = (RB::Symbol::Model *)operator new();
    RB::Symbol::Model::Model(v2, *v1);
    result = *v1;
    *v1 = v2;
    if (result)
    {
      v3 = (unsigned int *)((char *)result + 8);
      do
      {
        v4 = __ldxr(v3);
        v5 = v4 - 1;
      }
      while (__stlxr(v5, v3));
      if (!v5)
      {
        __dmb(9u);
        return (const RB::Symbol::Model *)(*(uint64_t (**)(const RB::Symbol::Model *))(*(_QWORD *)result + 8))(result);
      }
    }
  }
  return result;
}

void sub_209AD7374(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10E1C403E811B8FLL);
  _Unwind_Resume(a1);
}

CUINamedVectorGlyph *RB::Symbol::Model::set_glyph(RB::Symbol::Model *this, CUINamedVectorGlyph *a2, float a3)
{
  CUINamedVectorGlyph *result;

  result = (CUINamedVectorGlyph *)*((_QWORD *)this + 2);
  if (result != a2)
  {

    *((_QWORD *)this + 2) = a2;
    ++*((_DWORD *)this + 21);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
    result = (CUINamedVectorGlyph *)RB::Symbol::Model::glyph_value_index(this, a3);
    *((_DWORD *)this + 20) = (_DWORD)result;
  }
  return result;
}

uint64_t RB::Symbol::Model::glyph_value_index(RB::Symbol::Model *this, float a2)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  uint64_t result;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  float v11;
  _BOOL4 v12;

  if ((LODWORD(a2) & 0x7FFFFFFFu) > 0x7F7FFFFF)
    return 0xFFFFFFFFLL;
  v3 = RB::Symbol::Model::glyph_info(this);
  v4 = *(_QWORD *)(v3 + 376);
  if (!v4)
    v4 = v3 + 112;
  v5 = *(_DWORD *)(v3 + 384);
  if (!v5)
    return 0;
  result = 0;
  v7 = 88 * v5;
  v8 = (unsigned int *)(v4 + 80);
  do
  {
    v9 = *v8;
    if (*v8 != -1 && v9 > result)
    {
      v11 = *((float *)v8 - 4);
      if ((LODWORD(v11) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        v12 = v11 > a2;
        if (v11 <= 0.0)
          v12 = v11 >= a2;
        if (v12)
          result = result;
        else
          result = v9;
      }
    }
    v8 += 22;
    v7 -= 88;
  }
  while (v7);
  return result;
}

void RB::Symbol::Model::~Model(RB::Symbol::Model *this)
{
  void *v2;

  *(_QWORD *)this = off_24C229870;
  std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
    free(v2);

  JUMPOUT(0x20BD16544);
}

{
  void *v2;

  *(_QWORD *)this = off_24C229870;
  std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
    free(v2);

}

void RB::Symbol::GlyphCache::unref(os_unfair_lock_s *this, const RB::Symbol::Glyph *a2)
{
  int v4;

  os_unfair_lock_lock(this);
  v4 = *((_DWORD *)a2 + 7) - 1;
  *((_DWORD *)a2 + 7) = v4;
  if (!v4)
  {
    RB::UntypedTable::remove_ptr((RB::UntypedTable *)&this[12], a2);
    os_unfair_lock_unlock(this);
    RB::Symbol::Glyph::~Glyph((id *)a2);
    JUMPOUT(0x20BD16544);
  }
  os_unfair_lock_unlock(this);
}

void sub_209AD758C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::Symbol::Glyph::~Glyph(id *this)
{
  id v2;
  RB::Symbol::Glyph::Layer *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = this[47];
  if (v2)
    v3 = (RB::Symbol::Glyph::Layer *)this[47];
  else
    v3 = (RB::Symbol::Glyph::Layer *)(this + 14);
  if (*((_DWORD *)this + 96))
  {
    v4 = 0;
    do
    {
      RB::Symbol::Glyph::Layer::~Layer(v3);
      ++v4;
      v3 = (RB::Symbol::Glyph::Layer *)(v5 + 88);
    }
    while (v4 < *((unsigned int *)this + 96));
    v2 = this[47];
  }
  if (v2)
    free(v2);
}

void sub_209AD7614(_Unwind_Exception *a1)
{
  uint64_t v1;

  RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector((RB::Symbol::Glyph::Layer *)(v1 + 112));
  _Unwind_Resume(a1);
}

void RB::Symbol::Glyph::Layer::~Layer(RB::Symbol::Glyph::Layer *this)
{
  int v2;
  uint64_t *v3;
  void *v4;
  const void *v5;

  v2 = (*((_DWORD *)this + 21) >> 18) & 3;
  switch(v2)
  {
    case 3:

      break;
    case 2:
      std::unique_ptr<RB::Symbol::Glyph::Sublayers>::reset[abi:nn180100]((uint64_t *)this, 0);
      break;
    case 1:
      v3 = *(uint64_t **)this;
      *(_QWORD *)this = 0;
      if (v3)
        std::default_delete<RB::Symbol::Glyph::Shape>::operator()[abi:nn180100]((uint64_t)this, v3);
      break;
  }
  v4 = (void *)*((_QWORD *)this + 5);
  if (v4)
    free(v4);
  v5 = (const void *)*((_QWORD *)this + 2);
  if (v5)
    CFRelease(v5);

}

uint64_t RB::Refcount<RB::Path::Object,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Path::Object::~Object(RB::Path::Object *this)
{
  *(_QWORD *)this = off_24C229608;
  RB::Path::Storage::~Storage((RB::Path::Object *)((char *)this + 16));
  JUMPOUT(0x20BD16544);
}

{
  *(_QWORD *)this = off_24C229608;
  RB::Path::Storage::~Storage((RB::Path::Object *)((char *)this + 16));
}

uint64_t RB::UntypedTable::remove_ptr(RB::UntypedTable *this, void *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  void (*v6)(_QWORD);
  void (*v7)(_QWORD);

  if (*((_QWORD *)this + 7))
  {
    v4 = (_QWORD *)(*((_QWORD *)this + 6) + 8 * (*((_QWORD *)this + 8) & (*(uint64_t (**)(void *))this)(a2)));
    while (1)
    {
      v5 = v4;
      v4 = (_QWORD *)*v4;
      if (!v4)
        break;
      if ((void *)v4[1] == a2)
      {
        *v5 = *v4;
        v6 = (void (*)(_QWORD))*((_QWORD *)this + 2);
        if (v6)
          v6(v4[1]);
        v7 = (void (*)(_QWORD))*((_QWORD *)this + 3);
        if (v7)
          v7(v4[2]);
        *v4 = *((_QWORD *)this + 5);
        *((_QWORD *)this + 5) = v4;
        --*((_QWORD *)this + 7);
        return 1;
      }
    }
  }
  return 0;
}

float64x2_t **RB::Path::Iterator::callback_0(float64x2_t **this, double **a2, const CGPathElement *a3)
{
  double *v3;
  float64x2_t *v4;
  double *v5;
  float64x2_t *v6;

  switch(*(_DWORD *)a2)
  {
    case 0:
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t))(*(_QWORD *)&(*this)->f64[0] + 16))(*this, vmlaq_n_f64(vmlaq_n_f64(this[1][2], *this[1], *a2[1]), this[1][1], a2[1][1]));
      break;
    case 1:
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t))(*(_QWORD *)&(*this)->f64[0] + 24))(*this, vmlaq_n_f64(vmlaq_n_f64(this[1][2], *this[1], *a2[1]), this[1][1], a2[1][1]));
      break;
    case 2:
      v3 = a2[1];
      v4 = this[1];
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t, float64x2_t))(*(_QWORD *)&(*this)->f64[0]
                                                                                                + 32))(*this, vmlaq_n_f64(vmlaq_n_f64(v4[2], *v4, *v3), v4[1], v3[1]), vmlaq_n_f64(vmlaq_n_f64(v4[2], *v4, v3[2]), v4[1], v3[3]));
      break;
    case 3:
      v5 = a2[1];
      v6 = this[1];
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *, float64x2_t, float64x2_t, float64x2_t))(*(_QWORD *)&(*this)->f64[0] + 40))(*this, vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, *v5), v6[1], v5[1]), vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, v5[2]), v6[1], v5[3]), vmlaq_n_f64(vmlaq_n_f64(v6[2], *v6, v5[4]), v6[1], v5[5]));
      break;
    case 4:
      this = (float64x2_t **)(*(uint64_t (**)(float64x2_t *))(*(_QWORD *)&(*this)->f64[0] + 8))(*this);
      break;
    default:
      return this;
  }
  return this;
}

BOOL RB::Symbol::Animator::set_rendering_mode(uint64_t a1, int a2)
{
  int v4;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(unsigned __int8 *)(*(_QWORD *)(a1 + 8) + 88);
  if (v4 != a2)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)(a1 + 8));
    RB::Symbol::Model::set_rendering_mode(*(_QWORD *)(a1 + 8), a2, *(float *)(a1 + 56));
    ++*(_DWORD *)(a1 + 60);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
  return v4 != a2;
}

void sub_209AD7988(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Model::set_rendering_mode(uint64_t result, int a2, float a3)
{
  int v3;
  int v4;
  RB::Symbol::Model *v6;

  v3 = *(unsigned __int16 *)(result + 88);
  v4 = v3 | (*(unsigned __int8 *)(result + 90) << 16);
  if (a2 != v3)
  {
    v6 = (RB::Symbol::Model *)result;
    *(_BYTE *)(result + 90) = BYTE2(v4);
    *(_WORD *)(result + 88) = v4 & 0xFF00 | a2;
    ++*(_DWORD *)(result + 84);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::GlyphCache *)(result + 96), 0);
    result = RB::Symbol::Model::glyph_value_index(v6, a3);
    *((_DWORD *)v6 + 20) = result;
  }
  return result;
}

uint64_t RBSymbolUpdateTemplateImage(uint64_t a1, _QWORD *a2, float *a3)
{
  uint64_t result;
  _QWORD v6[2];
  float v7;

  RB::Symbol::Presentation::template_image(a1, (uint64_t)v6);
  result = v6[0];
  if (v6[0])
  {
    if (a2)
      *a2 = v6[1];
    if (a3)
    {
      *a3 = v7;
    }
    else if (v7 != 1.0)
    {
      return 0;
    }
  }
  return result;
}

float32x2_t **RB::Symbol::Presentation::Presentation(float32x2_t **a1, uint64_t a2, uint64_t a3, char a4, int a5, char a6, float32x2_t a7)
{
  unsigned __int8 v14;
  float64x2_t v15;
  int32x4_t v16;
  int32x4_t v17;
  int32x2_t v18;
  float32x2_t *v19;
  RB::Symbol::Model *v20;
  unsigned int *v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int *v24;
  unsigned int v25;
  int v26;
  float32x2_t v27;
  uint32x2_t v28;
  float64x2_t v29;
  uint32x2_t v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  int32x2_t v34;
  int8x8_t v35;
  int8x16_t v36;
  float64x2_t v37;
  int32x4_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  double *v50;
  uint64_t v51;
  _DWORD *v52;
  unsigned int *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  RB::Symbol::Animation *v57;
  const RB::Symbol::Model **v58;
  double v59;
  unsigned int v60;
  double v61;
  BOOL v62;
  float *v63;
  float64x2_t v64;
  int i;
  float32x2_t *v66;
  unsigned int v68;
  float32x2_t *v69;
  unsigned int v70;
  float32x2_t **v71;
  unsigned int *v72;
  unsigned int v73;
  float32x2_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  float32x2_t **v79;
  unsigned int v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  RB::Symbol::Animation *v84;
  unsigned int v85;
  const RB::Symbol::Model **v86;
  BOOL v87;
  int v88;
  unsigned int v89;
  float32x2_t *v90;
  RB::Symbol::Presentation::Symbol *v91;
  uint64_t v92;
  float32x2_t *v93;
  float32x2_t *v94;
  uint64_t v95;
  float v96;
  uint64_t v97;
  float32x2_t *v98;
  float32x2_t v99;
  float v100;
  uint64_t v101;
  uint64_t v102;
  int v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  const RB::Symbol::Model **v108;
  double v109;
  std::string *v110;
  const char *v112;
  uint64_t v113;
  int v114;
  uint64_t *v115;
  char v116;
  float32x2_t **__dst;
  unsigned int v118;
  float64x2_t v119;
  uint64_t v120;
  float64x2_t v121;
  uint64_t v122;
  RB::Symbol::Model **v123;
  std::string __p[2];
  char v125[768];
  void *v126;
  uint64_t v127;
  void *v128;
  uint64_t v129;
  char v130;
  uint64_t v131;

  v131 = *MEMORY[0x24BDAC8D0];
  *a1 = 0;
  a1[105] = 0;
  __dst = a1 + 1;
  a1[106] = (float32x2_t *)0x200000000;
  v119 = (float64x2_t)xmmword_209BD52A0;
  v121 = (float64x2_t)xmmword_209BD5290;
  *((_OWORD *)a1 + 54) = xmmword_209BD5290;
  *((_OWORD *)a1 + 55) = xmmword_209BD52A0;
  a1[113] = 0;
  a1[112] = 0;
  a1[114] = (float32x2_t *)0x7FF0000000000000;
  *((_DWORD *)a1 + 233) = 0;
  *((_BYTE *)a1 + 936) = 0;
  a1[115] = 0;
  *((_BYTE *)a1 + 928) = 0;
  RB::Heap::Heap((RB::Heap *)(a1 + 118), (char *)a1 + 984, 1024, 0);
  v115 = (uint64_t *)(a1 + 253);
  a1[259] = 0;
  *(_OWORD *)(a1 + 255) = 0u;
  *(_OWORD *)(a1 + 257) = 0u;
  *(_OWORD *)(a1 + 251) = 0u;
  *(_OWORD *)(a1 + 253) = 0u;
  v14 = atomic_load((unsigned __int8 *)&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols);
  v116 = a6;
  if ((v14 & 1) == 0
    && __cxa_guard_acquire(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols))
  {
    v113 = RB::debug_int((RB *)"RB_PRINT_SYMBOLS", v112);
    if ((v113 & 0xFF00000000) != 0)
      v114 = v113;
    else
      v114 = 0;
    _ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols = v114;
    __cxa_guard_release(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols);
  }
  os_unfair_lock_lock((os_unfair_lock_t)a2);
  v19 = *(float32x2_t **)(a2 + 8);
  v123 = (RB::Symbol::Model **)(a2 + 8);
  v20 = (RB::Symbol::Model *)*a1;
  if (*a1 == v19)
    goto LABEL_14;
  if (v20)
  {
    v21 = (unsigned int *)((char *)v20 + 8);
    do
    {
      v22 = __ldxr(v21);
      v23 = v22 - 1;
    }
    while (__stlxr(v23, v21));
    if (!v23)
    {
      __dmb(9u);
      (*(void (**)(RB::Symbol::Model *))(*(_QWORD *)v20 + 8))(v20);
    }
    v20 = *v123;
    if (!*v123)
      goto LABEL_13;
    goto LABEL_11;
  }
  v20 = *(RB::Symbol::Model **)(a2 + 8);
  if (v19)
  {
LABEL_11:
    v24 = (unsigned int *)((char *)v20 + 8);
    do
      v25 = __ldxr(v24);
    while (__stxr(v25 + 1, v24));
  }
LABEL_13:
  *a1 = (float32x2_t *)v20;
LABEL_14:
  v26 = a6 & 7;
  if (a4 || v26)
  {
    v27 = *(float32x2_t *)((char *)v20 + 56);
    *(int32x2_t *)v16.i8 = vceq_f32(vabs_f32(v27), (float32x2_t)vdup_n_s32(0x7F800000u));
    v28 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v27), (int8x8_t)vcgez_f32(v27)), *(int8x8_t *)v16.i8);
    *(uint32x2_t *)&v29.f64[0] = vpmin_u32(v28, v28);
    if ((LODWORD(v29.f64[0]) & 0x80000000) == 0)
      v27 = *(float32x2_t *)(RB::Symbol::Model::glyph_info(v20) + 80);
    if (a4)
    {
      HIDWORD(v29.f64[0]) = HIDWORD(a3);
      v30 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v27, (float32x2_t)a3));
      *(uint32x2_t *)v16.i8 = vpmax_u32(v30, v30);
      if (v16.i32[0] < 0)
      {
        v31 = vrecpe_f32(v27);
        v32 = vmul_f32(vrecps_f32(v27, v31), v31);
        v33 = vmul_f32(vrecps_f32(v27, v32), vmul_f32((float32x2_t)a3, v32));
        v17.i64[1] = 0;
        v121 = vmulq_n_f64((float64x2_t)xmmword_209BD5290, v33.f32[0]);
        v16 = (int32x4_t)xmmword_209BD52A0;
        v29 = vmulq_n_f64((float64x2_t)xmmword_209BD52A0, v33.f32[1]);
        v119 = v29;
      }
    }
    if (v26)
    {
      LODWORD(v29.f64[0]) = 0;
      v16.i32[0] = 0;
      v17.i32[1] = 1056964608;
      v34 = (int32x2_t)vmul_f32(v27, (float32x2_t)0x3F0000003F000000);
      v17.i32[0] = v116 & 1;
      v18.i32[0] = v17.i32[0];
      v35 = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v18, *(int32x2_t *)&v29.f64[0]), 0), (int8x8_t)v34, (int8x8_t)vrev64_s32(v34));
      v36 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v17, v16), 0);
      v37 = (float64x2_t)vbslq_s8(v36, (int8x16_t)v119, (int8x16_t)xmmword_209BD5290);
      v38 = (int32x4_t)xmmword_209BD6C00;
      v39 = (float64x2_t)vbslq_s8(v36, (int8x16_t)v121, (int8x16_t)xmmword_209BD6C00);
      v38.i32[0] = v116 & 2;
      v40 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v38, v16), 0), (int8x16_t)v39, (int8x16_t)vnegq_f64(v39));
      LODWORD(v39.f64[0]) = v116 & 4;
      v41 = (float64x2_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32((int32x4_t)v39, v16), 0), (int8x16_t)v37, (int8x16_t)vnegq_f64(v37));
      v16 = (int32x4_t)v40;
      v42 = vmlaq_n_f64(vmlaq_n_f64(vmlaq_n_f64(vmulq_n_f64(v121, *(float *)v34.i32), v119, *(float *)&v34.i32[1]), v40, (float)-*(float *)v35.i32), v41, (float)-*(float *)&v35.i32[1]);
      v15 = v41;
    }
    else
    {
      v42 = 0uLL;
      v15 = v119;
      v16 = (int32x4_t)v121;
    }
    *((int32x4_t *)a1 + 54) = v16;
    *((float64x2_t *)a1 + 55) = v15;
    *((float64x2_t *)a1 + 56) = v42;
  }
  if ((v116 & 0x20) != 0)
    *((_BYTE *)a1 + 936) = 1;
  if ((v116 & 8) != 0
    || _ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols >= 2)
  {
    v43 = (_QWORD *)operator new();
    *v43 = 0;
    v43[1] = 0;
    v43[2] = 0;
    v44 = *v115;
    *v115 = (uint64_t)v43;
    if (v44)
      std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100]((uint64_t)v115, v44);
  }
  if (a5 != 255 && (*a1)[11].u8[0] != a5)
  {
    RB::Symbol::Model::copy_on_write((const RB::Symbol::Model *)a1);
    RB::Symbol::Model::set_rendering_mode((uint64_t)*a1, a5, *(float *)(a2 + 56));
  }
  v45 = *(_QWORD *)(a2 + 24);
  if (v45)
  {
    v46 = 0;
    v47 = v45 - 1;
    v48 = 88 * v45;
    do
    {
      v118 = v46;
      v49 = v45 - 1;
      v122 = *(_QWORD *)(a2 + 16);
      v120 = v122 + 88 * (v45 - 1);
      v50 = (double *)(v120 + 48);
      if ((*(_QWORD *)(v120 + 48) & 0x7FFFFFFFFFFFFFFFuLL) >= 0x7FF0000000000000 && v45 - 2 >= 0)
      {
        v51 = v122 + 88 * v49;
        v52 = (_DWORD *)(v51 + 16);
        v53 = (unsigned int *)(v51 + 12);
        v54 = v48;
        v55 = v47;
        while (1)
        {
          v56 = *(_QWORD *)(a2 + 16) + v54;
          if (((*v52 >> *(_DWORD *)(v56 - 172)) & 1) != 0)
          {
            v57 = (RB::Symbol::Animation *)(v56 - 176);
            v58 = (const RB::Symbol::Model **)(v56 - 8);
            if ((unint64_t)v55 >= *(_QWORD *)(a2 + 24))
              v58 = (const RB::Symbol::Model **)(a2 + 8);
            v59 = RB::Symbol::Animation::begin_time_after(v57, *(double *)(a2 + 40), *v58, v15.f64[0], *(double *)v16.i64);
            *v50 = v59;
            v60 = *v53 & 0xFFFFFDFF;
            *v53 = v60;
            if ((*(_QWORD *)&v59 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL)
              break;
          }
          --v55;
          v54 -= 88;
          if (v55 <= 0)
            goto LABEL_46;
        }
        *v53 = v60 | 0x4000;
      }
LABEL_46:
      RB::Symbol::Animation::will_apply(v120, *(double *)(a2 + 40));
      v61 = *v50;
      v15.f64[0] = *(float64_t *)(a2 + 40);
      v62 = (*(_QWORD *)v50 & 0x7FFFFFFFFFFFFFFFuLL) <= 0x7FEFFFFFFFFFFFFFLL && v15.f64[0] < v61;
      v46 = v118;
      if (v62)
      {
        *(_DWORD *)(v122 + 88 * v49 + 12) |= 0x8000u;
        *(_QWORD *)&v15.f64[0] = a1[114];
        if (v15.f64[0] <= v61)
          v61 = *((double *)a1 + 114);
        *((double *)a1 + 114) = v61;
      }
      else if (((v118 >> *(_DWORD *)(v122 + 88 * v49 + 4)) & 1) != 0)
      {
        *(_DWORD *)(v122 + 88 * v49 + 12) |= 0x8000u;
      }
      else
      {
        v46 = *(_DWORD *)(v122 + 88 * v49 + 16) | v118;
      }
      --v47;
      v48 -= 88;
      v45 = v49;
    }
    while (v49);
  }
  v63 = (float *)(a1 + 115);
  v126 = 0;
  HIDWORD(v64.f64[0]) = 64;
  v127 = 0x4000000000;
  v128 = 0;
  v129 = 0x4000000000;
  v130 = 0;
  for (i = *((_DWORD *)a1 + 233); ; *((_DWORD *)a1 + 233) = i)
  {
    if (i == 2)
    {
      if (a1[105])
        v79 = (float32x2_t **)a1[105];
      else
        v79 = __dst;
      v80 = *((_DWORD *)a1 + 212);
      if (v80)
      {
        v81 = 416 * v80;
        do
        {
          RB::Symbol::Presentation::Symbol::make_layers(v79, a1);
          v79 += 52;
          v81 -= 416;
        }
        while (v81);
      }
LABEL_80:
      v75 = *(_QWORD *)(a2 + 24);
      if (v75 < 1)
        goto LABEL_91;
      v76 = 0;
      v78 = 0;
      v77 = 1;
LABEL_82:
      v82 = 88 * v76;
      do
      {
        v83 = *(_QWORD *)(a2 + 16);
        v84 = (RB::Symbol::Animation *)(v83 + v82);
        v85 = *(_DWORD *)(v83 + v82 + 12);
        if ((v85 & 0x8000) == 0 && ((v85 >> *((_DWORD *)a1 + 233)) & 1) != 0)
        {
          v86 = (const RB::Symbol::Model **)(v83 + v82 + 168);
          if ((unint64_t)(v76 + 1) >= *(_QWORD *)(a2 + 24))
            v86 = (const RB::Symbol::Model **)(a2 + 8);
          RB::Symbol::Animation::apply(v84, *(double *)(a2 + 40), *v86, (const RB::Symbol::Animator *)a2, (RB::Symbol::Presentation *)a1, (RB::Symbol::KeyframeStorage *)v125);
        }
        v76 += v77;
        v87 = v76 < v75;
        if (v78)
          v87 = v76 >= 0;
        v82 += 88 * (int)v77;
      }
      while (v87);
      goto LABEL_91;
    }
    if (i)
      goto LABEL_80;
    v66 = *a1;
    if ((((*a1)[11].u16[0] | ((*a1)[11].u8[2] << 16)) & 0x10000) == 0
      && (*a1)[11].i16[0] != 0xFF
      && *(_QWORD *)&v66[2] != 0)
    {
      v68 = *((_DWORD *)a1 + 212);
      if (*((_DWORD *)a1 + 213) < v68 + 1)
      {
        RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::reserve_slow(__dst, v68 + 1);
        v68 = *((_DWORD *)a1 + 212);
      }
      v69 = a1[105];
      if (!v69)
        v69 = (float32x2_t *)__dst;
      v70 = v68;
      v71 = (float32x2_t **)&v69[52 * v68];
      v72 = (unsigned int *)&v66[1];
      do
        v73 = __ldxr(v72);
      while (__stxr(v73 + 1, v72));
      *v71 = v66;
      v74 = &v69[52 * v70];
      v74[1] = 0;
      v74[47] = 0;
      v74[48] = (float32x2_t)0x300000000;
      v74[49] = 0;
      v74[50] = 0;
      *(__int32 *)((char *)&v74[50].i32[1] + 3) = 0;
      ++*((_DWORD *)a1 + 212);
    }
    v75 = *(_QWORD *)(a2 + 24);
    if (v75 > 0)
    {
      v76 = v75 - 1;
      v77 = -1;
      v78 = 1;
      goto LABEL_82;
    }
LABEL_91:
    v88 = *((_DWORD *)a1 + 233);
    if (v88 == 2)
      break;
    i = v88 + 1;
  }
  v89 = *((_DWORD *)a1 + 212);
  if (v89 >= 2)
  {
    v64 = vaddq_f64(*((float64x2_t *)a1 + 56), vcvtq_f64_f32(vsub_f32((*a1)[6], vadd_f32(*(float32x2_t *)(a2 + 48), a7))));
    *((float64x2_t *)a1 + 56) = v64;
  }
  if (*((_BYTE *)a1 + 928))
  {
    RB::Symbol::Presentation::apply_interpolations((RB::Symbol::Presentation *)a1);
    v89 = *((_DWORD *)a1 + 212);
  }
  v90 = a1[105];
  if ((v116 & 0x10) != 0)
  {
    if (v90)
      v91 = (RB::Symbol::Presentation::Symbol *)a1[105];
    else
      v91 = (RB::Symbol::Presentation::Symbol *)__dst;
    if (v89)
    {
      v92 = 416 * v89;
      do
      {
        RB::Symbol::Presentation::Symbol::merge_layers(v91, (size_t *)a1);
        v91 = (RB::Symbol::Presentation::Symbol *)((char *)v91 + 416);
        v92 -= 416;
      }
      while (v92);
      v90 = a1[105];
      v89 = *((_DWORD *)a1 + 212);
      goto LABEL_105;
    }
  }
  else
  {
LABEL_105:
    if (!v90)
      v90 = (float32x2_t *)__dst;
    if (v89)
    {
      v93 = &v90[52 * v89];
      do
      {
        v94 = (float32x2_t *)v90[47];
        if (!v94)
          v94 = v90 + 2;
        v95 = v90[48].u32[0];
        if ((_DWORD)v95)
        {
          v96 = *v63;
          v97 = 120 * v95;
          v98 = v94 + 13;
          do
          {
            v99 = *v98;
            v98 += 15;
            v100 = fmaxf(v99.f32[0], v99.f32[1]);
            if (v96 < v100)
              v96 = v100;
            *v63 = v96;
            v97 -= 120;
          }
          while (v97);
        }
        v90 += 52;
      }
      while (v90 != v93);
    }
  }
  *(float *)v64.f64 = *((float *)a1 + 230) + (float)((float)(*(float *)(a2 + 64) - *((float *)a1 + 230)) * 0.35);
  *((_DWORD *)a1 + 231) = LODWORD(v64.f64[0]);
  *(_DWORD *)(a2 + 64) = LODWORD(v64.f64[0]);
  v101 = *(_QWORD *)(a2 + 24);
  if (v101)
  {
    v102 = 0;
    v103 = 0;
    v104 = 0;
    while (1)
    {
      v105 = *(_QWORD *)(a2 + 16);
      v106 = v105 + v102;
      v107 = *(_DWORD *)(v105 + v102 + 12);
      ++v104;
      if ((v107 & 0x2000) != 0)
      {
        v109 = *(double *)(a2 + 40);
      }
      else
      {
        v108 = (const RB::Symbol::Model **)(a2 + 8);
        if (v104 < *(_QWORD *)(a2 + 24))
          v108 = (const RB::Symbol::Model **)(v106 + 168);
        v64.f64[0] = RB::Symbol::Animation::end_time((RB::Symbol::Animation *)(v105 + v102), *v108, *(float32x2_t *)&v64.f64[0]);
        v109 = *(double *)(a2 + 40);
        if (v109 >= v64.f64[0])
        {
          v107 = *(_DWORD *)(v106 + 12) | 0x2000;
LABEL_129:
          *(_DWORD *)(v106 + 12) = v107;
          goto LABEL_130;
        }
        v107 = *(_DWORD *)(v106 + 12);
        if (((unint64_t)a1[114] & 0x7FFFFFFFFFFFFFFFLL) >= 0x7FF0000000000000)
        {
          if (*((double *)a1 + 114) <= v64.f64[0])
            *(_QWORD *)&v64.f64[0] = a1[114];
          a1[114] = *(float32x2_t **)&v64.f64[0];
          v107 |= 0x4000u;
          goto LABEL_129;
        }
      }
LABEL_130:
      *(_DWORD *)(v106 + 12) = v107 & 0xFFFF7FFF;
      *(double *)(v105 + v102 + 56) = v109;
      v103 |= (unsigned __int16)(v107 & 0x2000) >> 13;
      v102 += 88;
      if (v101 == v104)
        goto LABEL_133;
    }
  }
  LOBYTE(v103) = 0;
LABEL_133:
  if (_ZZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols > 0
    && ((memset(__p, 0, 41),
         RB::Symbol::Presentation::print((RB::Symbol::Presentation *)a1, __p, (os_unfair_lock_t)a2, 1),
         (__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      ? (v110 = __p)
      : (v110 = (std::string *)__p[0].__r_.__value_.__r.__words[0]),
        printf("\n%s\n", (const char *)v110),
        SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0))
  {
    operator delete(__p[0].__r_.__value_.__l.__data_);
    if ((v103 & 1) != 0)
LABEL_139:
      RB::Symbol::Animator::remove_finished_animations_locked((RB::Symbol::Animator *)a2);
  }
  else if ((v103 & 1) != 0)
  {
    goto LABEL_139;
  }
  if (v128)
    free(v128);
  if (v126)
    free(v126);
  os_unfair_lock_unlock((os_unfair_lock_t)a2);
  return a1;
}

void sub_209AD8498(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, RB::Heap *a10, uint64_t *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,int a23,__int16 a24,char a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  uint64_t v31;
  uint64_t v33;
  unsigned int *v34;
  unsigned int *v35;
  unsigned int v36;
  unsigned int v37;

  __cxa_guard_abort(&_ZGVZN2RB6Symbol12PresentationC1ERNS0_8AnimatorEDv2_fNSt3__18optionalIS4_EE21RBSymbolRenderingModejE13print_symbols);
  RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::~vector(v31 + 2064);
  RB::vector<RB::path_ptr,0ul,unsigned int>::~vector(v31 + 2048);
  RB::vector<RB::refcounted_ptr<RB::Symbol::Model const>,0ul,unsigned int>::~vector(v31 + 2032);
  v33 = *a11;
  *a11 = 0;
  if (v33)
    std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100]((uint64_t)a11, v33);

  RB::Heap::~Heap(a10);
  RB::vector<RB::Symbol::Presentation::Symbol,2ul,unsigned int>::~vector(a13);
  v34 = *(unsigned int **)v31;
  if (*(_QWORD *)v31)
  {
    v35 = v34 + 2;
    do
    {
      v36 = __ldxr(v35);
      v37 = v36 - 1;
    }
    while (__stlxr(v37, v35));
    if (!v37)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v34 + 8))(v34);
    }
  }
  _Unwind_Resume(a1);
}

void RB::Symbol::Presentation::Symbol::merge_layers(RB::Symbol::Presentation::Symbol *this, size_t *size)
{
  uint64_t v3;
  size_t v5;
  char *v6;
  uint64_t v7;
  unsigned int v8;
  char v9;
  unsigned int i;
  RB::Symbol::Presentation::Symbol *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  char *v19;
  size_t *v20;
  size_t *v21;
  size_t v22;
  char *v23;
  char *v24;
  _QWORD *v25;
  uint64_t v26;
  size_t *v27;
  uint64_t v28;
  uint64_t v29;

  v29 = *MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 50))
    return;
  v3 = *((unsigned int *)this + 96);
  if (v3 < 2)
    return;
  if (v3 > 0x200)
  {
    v6 = (char *)malloc_type_malloc(8 * v3, 0x98DC86EBuLL);
    if (!v6)
      goto LABEL_35;
  }
  else
  {
    MEMORY[0x24BDAC7A8](this, 8 * v3);
    v6 = (char *)&v26 - ((v5 + 15) & 0xFFFFFFFF0);
    bzero(v6, v5);
  }
  v27 = size;
  v28 = v3;
  v7 = 0;
  v8 = 0;
  v9 = 0;
  for (i = 1; i < *((_DWORD *)this + 96); ++i)
  {
    v11 = *((_QWORD *)this + 47)
        ? (RB::Symbol::Presentation::Symbol *)*((_QWORD *)this + 47)
        : (RB::Symbol::Presentation::Symbol *)((char *)this + 16);
    v12 = (char *)v11 + 120 * v8;
    v13 = (char *)v11 + 120 * i;
    v14 = *(_QWORD *)v12;
    v15 = *(_DWORD *)(*(_QWORD *)v12 + 84);
    v16 = *(_QWORD *)v13;
    v17 = *(_DWORD *)(*(_QWORD *)v13 + 84);
    if ((((unsigned __int16)v17 ^ (unsigned __int16)v15) & 0xF00) != 0
      || ((v17 | v15) & 0x400000) != 0 && (*(float *)(v14 + 72) != 0.0 || *(float *)(v16 + 72) != 0.0))
    {
      break;
    }
    if ((vminv_u16((uint16x4_t)vcltz_s16(vshl_n_s16(vmovn_s32(vceqq_f32(*(float32x4_t *)((char *)v11 + 120 * v8 + 8), *(float32x4_t *)((char *)v11 + 120 * i + 8))), 0xFuLL))) & 1) == 0)break;
    if ((*(_DWORD *)(*(_QWORD *)v12 + 84) & 0xF00) == 0x900)
    {
      if (!CGColorEqualToColor(*(CGColorRef *)(v14 + 16), *(CGColorRef *)(v16 + 16))
        || !objc_msgSend(*(id *)(*(_QWORD *)v12 + 8), "isEqualToString:", *(_QWORD *)(*(_QWORD *)v13 + 8)))
      {
        break;
      }
      v14 = *(_QWORD *)v12;
      v15 = *(_DWORD *)(*(_QWORD *)v12 + 84);
    }
    if ((v15 & 0xF00) == 0xC00 && *(_QWORD *)(v14 + 16) != *(_QWORD *)(*(_QWORD *)v13 + 16))
      break;
LABEL_20:
    ;
  }
  v18 = i - v8;
  if (i != v8)
  {
    v19 = &v6[8 * v7++];
    *(_DWORD *)v19 = v8;
    *((_DWORD *)v19 + 1) = v18;
    v9 |= v18 > 1;
  }
  if (i != *((_DWORD *)this + 96))
  {
    v8 = i;
    goto LABEL_20;
  }
  if ((v9 & 1) != 0)
  {
    v20 = v27;
    v21 = v27 + 118;
    v22 = 8 * v7;
    v23 = (char *)((v27[120] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    v24 = &v23[8 * v7];
    if ((unint64_t)v24 > v27[121])
    {
      v23 = (char *)RB::Heap::alloc_slow(v27 + 118, 8 * v7, 3);
      v22 = 8 * v7;
      v20 = v27;
    }
    else
    {
      v27[120] = (size_t)v24;
    }
    memcpy(v23, v6, v22);
    v25 = (_QWORD *)((v20[120] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v25 + 2) > v20[121])
      v25 = (_QWORD *)RB::Heap::alloc_slow(v21, 0x10uLL, 7);
    else
      v20[120] = (size_t)(v25 + 2);
    *v25 = v23;
    v25[1] = v7;
    *((_QWORD *)this + 50) = v25;
  }
  if (v28 >= 0x201)
LABEL_35:
    free(v6);
}

void sub_209AD886C(_Unwind_Exception *exception_object)
{
  void *v1;
  uint64_t v2;

  if (*(_QWORD *)(v2 - 96) >= 0x201)
    free(v1);
  _Unwind_Resume(exception_object);
}

void RB::Symbol::Presentation::Symbol::make_layers(float32x2_t **this, float32x2_t **a2)
{
  float32x2_t *v4;
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  RB::Symbol::Model *v8;
  float32x2_t v9;
  float32x2_t *v10;
  int v11;
  float v12;
  float v13;
  float32x2_t v14;
  float32x2_t v15;
  uint32x2_t v16;
  float32x2_t v17;
  uint32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float v21;
  unsigned __int32 v22;
  unsigned int v23;
  unint64_t v24;
  uint64_t v25;
  float32x2_t *v32;
  unsigned int v33;
  float32x2_t *v34;
  char *v35;
  unsigned int v36;
  float32x2_t *v37;
  float32x2_t *v38;
  unsigned __int32 v39;
  float v40;
  uint64_t v41;
  uint64_t v42;
  char *v43;
  RB::Symbol::Model *v44;
  unsigned int v45;
  unsigned int v46;
  RB::Symbol::Model *v47;
  uint64_t v48;
  unint64_t v49;
  __int128 v50;

  v4 = (float32x2_t *)RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*this);
  v6 = v4[12];
  v5 = v4[13];
  v7 = v4[11];
  v8 = (RB::Symbol::Model *)*this;
  v9 = (*this)[9];
  if (*this != *a2)
  {
    v10 = (float32x2_t *)RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*a2);
    v8 = (RB::Symbol::Model *)*this;
    v9 = vneg_f32(vmla_f32(vsub_f32(vneg_f32(vmla_f32(vsub_f32(v9, (*a2)[6]), v10[10], (*a2)[5])), (*this)[6]), (*this)[5], v4[10]));
  }
  if (*((_BYTE *)this + 409))
  {
    v11 = *((unsigned __int8 *)this + 408);
  }
  else
  {
    v11 = *((unsigned __int8 *)v8 + 89);
    *((_WORD *)this + 204) = v11 | 0x100;
  }
  v12 = 1.25;
  if (!v11)
    v12 = 1.0;
  if ((v11 & 0x80u) == 0)
    v13 = v12;
  else
    v13 = 0.5;
  v14 = *(float32x2_t *)((char *)v8 + 56);
  v15 = *(float32x2_t *)((char *)v8 + 64);
  v16 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v14), (int8x8_t)vcgez_f32(v14)), (int8x8_t)vceq_f32(vabs_f32(v14), (float32x2_t)vdup_n_s32(0x7F800000u)));
  if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0)
  {
    v17 = v4[10];
    v18 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v14, v17));
    if ((vpmax_u32(v18, v18).u32[0] & 0x80000000) != 0)
    {
      v19 = vrecpe_f32(v17);
      v20 = vmul_f32(vrecps_f32(v17, v19), v19);
      v15 = vmul_f32(vmul_f32(vmul_f32(v14, v15), v20), vrecps_f32(v17, v20));
    }
  }
  if (*((_BYTE *)a2 + 936))
    v21 = v4[10].f32[1] - v4[8].f32[1];
  else
    v21 = 0.0;
  v22 = v4[48].u32[0];
  v23 = v22 + *((_DWORD *)this + 96);
  if (*((_DWORD *)this + 97) < v23)
  {
    RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(this + 2, v23);
    v22 = v4[48].u32[0];
    if (v22)
      goto LABEL_19;
  }
  else if (v22)
  {
LABEL_19:
    v24 = 0;
    v25 = 88 * v22;
    __asm { FMOV            V0.4S, #1.0 }
    v50 = _Q0;
    __asm { FMOV            V15.2S, #1.0 }
    while (1)
    {
      if (v4[47])
        v32 = (float32x2_t *)v4[47];
      else
        v32 = v4 + 14;
      v33 = *((_DWORD *)this + 96);
      if (*((_DWORD *)this + 97) < v33 + 1)
      {
        RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(this + 2, v33 + 1);
        v33 = *((_DWORD *)this + 96);
      }
      v34 = this[47];
      if (!v34)
        v34 = (float32x2_t *)(this + 2);
      v35 = (char *)&v34[15 * v33];
      *(_QWORD *)v35 = &v32[v24 / 8];
      *(_OWORD *)(v35 + 8) = RBColorNull;
      *(_OWORD *)(v35 + 24) = v50;
      *(_OWORD *)(v35 + 40) = xmmword_209BD6C10;
      *((_OWORD *)v35 + 4) = 0u;
      *((_OWORD *)v35 + 5) = 0u;
      *((_QWORD *)v35 + 12) = _D15;
      *((_QWORD *)v35 + 13) = 0;
      *((_QWORD *)v35 + 14) = 0;
      v36 = *((_DWORD *)this + 96);
      *((_DWORD *)this + 96) = v36 + 1;
      if (this[47])
        v37 = this[47];
      else
        v37 = (float32x2_t *)(this + 2);
      v38 = &v37[15 * v36];
      v38[4].f32[1] = v13;
      v38[7] = v4[10];
      v38[8] = v9;
      v38[14].f32[0] = v21;
      v38[9] = v7;
      v38[10] = v6;
      v38[11] = v5;
      v38[12] = v15;
      v39 = RB::Symbol::Model::style_color_index((*(_DWORD *)(*(_QWORD *)v38 + 84) >> 8) & 0xF);
      if (v39 < (*this)[4].i32[0])
      {
        v41 = *(_QWORD *)&(*this)[3] + 16 * v39;
        v40 = *(float *)(v41 + 12);
        if (v40 != -32768.0)
        {
          v42 = *(_QWORD *)v41;
          v43 = (char *)&v37[15 * v36];
          *((_DWORD *)v43 + 4) = *(_DWORD *)(v41 + 8);
          *((_QWORD *)v43 + 1) = v42;
          *((float *)v43 + 5) = v40;
        }
      }
      v44 = (RB::Symbol::Model *)this[1];
      if (!v44)
        v44 = (RB::Symbol::Model *)*this;
      v45 = *((_DWORD *)v44 + 20);
      v46 = *(_DWORD *)(*(_QWORD *)v38 + 80);
      if ((v46 | v45) != 0xFFFFFFFF)
        break;
      v37[15 * v36 + 3].f32[0] = v37[15 * v36 + 3].f32[0]
                               * RB::Symbol::Model::alpha((RB::Symbol::Model *)*this, *(unsigned __int8 *)(*(_QWORD *)v38 + 84), v40);
LABEL_43:
      v24 += 88;
      if (v25 == v24)
        return;
    }
    v47 = (RB::Symbol::Model *)*this;
    if (v45 >= v46)
    {
      v49 = 0;
    }
    else
    {
      v48 = RB::Symbol::Model::glyph_info((RB::Symbol::Model *)*this);
      v40 = 0.3;
      if (*(_DWORD *)(v48 + 24) != 3)
      {
LABEL_42:
        v37[15 * v36 + 3] = vmul_n_f32(v37[15 * v36 + 3], v40);
        goto LABEL_43;
      }
      v49 = 2;
    }
    v40 = RB::Symbol::Model::alpha(v47, v49, v40);
    goto LABEL_42;
  }
}

float RB::Symbol::Model::alpha(RB::Symbol::Model *this, unint64_t a2, float a3)
{
  uint64_t v3;

  v3 = 3;
  if (a2 < 3)
    v3 = a2;
  LOBYTE(a3) = *((_BYTE *)this + v3 + 91);
  return (float)LODWORD(a3) * 0.0039216;
}

uint64_t RB::Symbol::Presentation::template_image@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  RB::Symbol::Model **v3;
  int64x2_t v4;
  uint64_t v5;
  uint64_t v6;
  float32x2_t *v8;
  unsigned int v9;
  float32x2_t *v10;
  float32x2_t *v11;
  float v12;
  float32x2_t *v17;
  float32x2_t v18;
  float v19;
  float v20;
  float v21;
  uint32x2_t v22;
  uint32x2_t v23;
  float v24;

  if (*(_DWORD *)(this + 848) != 1)
    goto LABEL_31;
  v3 = (RB::Symbol::Model **)this;
  v4 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)(this + 880), (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*(float64x2_t *)(this + 864), (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(*(float64x2_t *)(this + 896)));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v4, 1), (int8x16_t)v4).u64[0] & 0x8000000000000000) == 0)
    goto LABEL_31;
  v5 = *(_QWORD *)(this + 840) ? *(_QWORD *)(this + 840) : this + 8;
  v6 = RB::Symbol::Model::glyph_info(*(RB::Symbol::Model **)v5);
  this = RB::Symbol::Model::glyph_info(*v3);
  if (v6 != this || *(_BYTE *)(v5 + 410) != 0)
    goto LABEL_31;
  v8 = *(float32x2_t **)(v5 + 376);
  if (!v8)
    v8 = (float32x2_t *)(v5 + 16);
  v9 = *(_DWORD *)(v5 + 384);
  if (v9)
  {
    v10 = &v8[15 * v9];
    v11 = v8 + 8;
    v12 = 0.0;
    __asm { FMOV            V1.2S, #1.0 }
    while (1)
    {
      v17 = v11 - 8;
      v18 = v11[-8];
      v19 = v11[-5].f32[0] * v11[-4].f32[0];
      v20 = v19 * *(float *)(*(_QWORD *)&v18 + 72);
      if (v20 <= 0.0)
      {
        v21 = v12;
      }
      else
      {
        if (v12 == 0.0)
        {
          v21 = v19 * *(float *)(*(_QWORD *)&v18 + 72);
        }
        else
        {
          v21 = 1.0;
          if (v12 != 1.0 || v20 != 1.0)
            goto LABEL_31;
        }
        if ((*(_BYTE *)(*(_QWORD *)&v18 + 85) & 0xF) != 0)
          goto LABEL_31;
        if (v11[-4].f32[1] != 1.0)
          goto LABEL_31;
        v22 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*v11));
        if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0)
          goto LABEL_31;
        v23 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v11[4], _D1));
        if ((vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0 || *(float *)(*(_QWORD *)&v18 + 60) != 0.0)
          goto LABEL_31;
      }
      v11 += 15;
      v12 = v21;
      if (&v17[15] == v10)
        goto LABEL_29;
    }
  }
  v21 = 0.0;
LABEL_29:
  this = RB::Symbol::Glyph::has_template_image((os_unfair_lock_s *)v6, *(const RB::Symbol::Model **)v5);
  if ((this & 1) != 0)
  {
    this = objc_msgSend((id)RB::Symbol::Glyph::copied_glyph((RB::Symbol::Glyph *)v6), "image");
    v24 = *(float *)(v6 + 44);
    *(_QWORD *)a2 = this;
    *(double *)(a2 + 8) = v24;
    *(float *)(a2 + 16) = v21;
  }
  else
  {
LABEL_31:
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
  }
  return this;
}

uint64_t RB::Symbol::Animator::style_mask(os_unfair_lock_s *this)
{
  RB::Symbol::Model *v2;
  uint64_t v3;
  uint64_t v4;
  RB::Symbol::Animation *v5;
  uint64_t v6;

  os_unfair_lock_lock(this);
  v2 = *(RB::Symbol::Model **)&this[2]._os_unfair_lock_opaque;
  if (v2)
    v3 = *(unsigned int *)(RB::Symbol::Model::glyph_info(v2) + 392);
  else
    v3 = 0;
  v4 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v4)
  {
    v5 = *(RB::Symbol::Animation **)&this[4]._os_unfair_lock_opaque;
    v6 = 88 * v4;
    do
    {
      v3 = RB::Symbol::Animation::style_mask(v5) | v3;
      v5 = (RB::Symbol::Animation *)((char *)v5 + 88);
      v6 -= 88;
    }
    while (v6);
  }
  os_unfair_lock_unlock(this);
  return v3;
}

void sub_209AD8E98(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Model::glyph_info(RB::Symbol::Model *this)
{
  uint64_t result;
  RB::Symbol::GlyphCache *v3;
  os_unfair_lock_s *v4;
  uint64_t v5;

  v3 = (RB::Symbol::Model *)((char *)this + 96);
  result = *((_QWORD *)this + 12);
  if (!result)
  {
    v4 = (os_unfair_lock_s *)RB::Symbol::GlyphCache::shared(0);
    v5 = RB::Symbol::GlyphCache::ref(v4, *((void **)this + 2), *((unsigned __int8 *)this + 88), (*((_BYTE *)this + 90) & 2) != 0);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100](v3, v5);
    return *((_QWORD *)this + 12);
  }
  return result;
}

uint64_t RB::Symbol::GlyphCache::shared(RB::Symbol::GlyphCache *this)
{
  unsigned __int8 v1;
  RB::Symbol::GlyphCache *v3;

  {
    v3 = (RB::Symbol::GlyphCache *)operator new();
    RB::Symbol::GlyphCache::GlyphCache(v3);
    RB::Symbol::GlyphCache::shared(void)::shared_cache = (uint64_t)v3;
  }
  return RB::Symbol::GlyphCache::shared(void)::shared_cache;
}

void sub_209AD8F74(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10B0C40EE9E74E3);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Glyph::has_template_image(os_unfair_lock_s *this, const RB::Symbol::Model *a2)
{
  os_unfair_lock_s *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  double v7;
  double v8;
  uint64_t v9;
  double v10;
  uint64_t os_unfair_lock_opaque_low;

  v3 = this + 102;
  os_unfair_lock_lock(this + 102);
  if (!BYTE1(this[103]._os_unfair_lock_opaque))
  {
    LOWORD(this[103]._os_unfair_lock_opaque) = 256;
    if (this[6]._os_unfair_lock_opaque == 1)
    {
      v4 = (void *)objc_msgSend(*(id *)&this->_os_unfair_lock_opaque, "knownAvailableVectorSizes");
      v5 = v4;
      if (v4)
      {
        v6 = objc_msgSend(v4, "count");
        objc_msgSend(*(id *)&this->_os_unfair_lock_opaque, "pointSize");
        if (v6)
        {
          v8 = v7;
          v9 = 0;
          while (1)
          {
            objc_msgSend((id)objc_msgSend(v5, "objectAtIndexedSubscript:", v9), "doubleValue");
            if (v10 == v8)
              break;
            if (v6 == ++v9)
              goto LABEL_10;
          }
          LOWORD(this[103]._os_unfair_lock_opaque) = 257;
        }
      }
    }
  }
LABEL_10:
  os_unfair_lock_opaque_low = LOBYTE(this[103]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v3);
  return os_unfair_lock_opaque_low;
}

void sub_209AD9078(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

float32x2_t *RB::Symbol::Glyph::Glyph(uint64_t a1, __int128 *a2)
{
  float32x2_t *v2;
  __int128 v3;
  float32x2_t *v5;
  id v6;
  double v7;
  double v8;
  double v9;
  double v10;
  float64_t v11;
  float64x2_t v12;
  float64_t v13;
  float64x2_t v14;
  double v15;
  float32_t v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  float32x4_t v22;
  BOOL v23;
  double v24;
  float32x2_t v29;
  float32x2_t v30;
  char v31;
  id v32;
  float64_t v33;
  float64x2_t v34;
  float32x2_t v35;
  float32x2_t v36;
  float v37;
  double v38;
  double v39;
  double v40;
  double v41;
  double v42;
  float v43;
  unsigned int v44;
  float64_t v45;
  float64x2_t v46;
  float32x2_t v47;
  int v48;
  float32x2_t v49;
  float v50;
  float32x2_t v51;
  __int32 v52;
  uint64_t v53;
  RB::Symbol::_anonymous_namespace_ *v54;
  NSArray *v55;
  void *v56;
  __int32 v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  void *v61;
  void *v62;
  void *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  int v67;
  RB::Symbol::_anonymous_namespace_ *v68;
  NSArray *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t i;
  void *v74;
  unsigned __int32 v75;
  float32x2_t *v76;
  unsigned __int32 v77;
  RB::Symbol::Glyph::Layer *v78;
  unsigned __int32 v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  unsigned int v84;
  int v85;
  float32x2_t v86;
  uint64_t v87;
  unsigned int v88;
  int v89;
  int v90;
  unsigned int v91;
  __int8 v92;
  char v93;
  uint64_t v94;
  int v95;
  int v96;
  unint64_t v97;
  size_t v98;
  _BYTE *v99;
  _DWORD *v100;
  int *v101;
  int *v102;
  unint64_t v103;
  int *v104;
  double v105;
  double v106;
  float64x2_t v107;
  int32x4_t v108;
  float32x2_t v109;
  float32x2_t v110;
  double v111;
  double v112;
  double v113;
  int32x4_t v114;
  float32x2_t v115;
  int v116;
  uint32x2_t v117;
  float32x2_t v118;
  uint8x8_t v119;
  int v121;
  int v122;
  float32x2_t *v123;
  unsigned __int32 v124;
  uint64_t v125;
  _DWORD *v126;
  int *v127;
  _BYTE *v128;
  _BYTE *v129;
  float32x2_t *v130;
  __int32 v131;
  float v132;
  float v133;
  unsigned int v134;
  __int32 v135;
  float32x2_t *v136;
  unsigned __int32 v137;
  uint64_t v138;
  unsigned int *v139;
  unsigned int v140;
  unsigned int v141;
  float32x2_t *v142;
  unsigned __int32 v143;
  uint64_t v144;
  unsigned int *v145;
  unsigned int v146;
  int v147;
  int v148;
  uint64_t v150;
  int v151;
  uint64_t v152;
  float32x2_t *v153;
  float v155;
  char v156;
  __int128 v157;
  __int128 v158;
  __int128 v159;
  __int128 v160;
  __int128 v161;
  __int128 v162;
  __int128 v163;
  __int128 v164;
  __int128 v165;
  __int128 v166;
  __int128 v167;
  __int128 v168;
  _BYTE __dst[256];
  void *v170;
  size_t v171;
  unint64_t v172;
  _BYTE v173[128];
  float32x2_t v174;
  float32x2_t v175;
  uint64_t v176;

  v2 = (float32x2_t *)a1;
  v176 = *MEMORY[0x24BDAC8D0];
  v3 = *a2;
  *(_QWORD *)(a1 + 16) = *((_QWORD *)a2 + 2);
  *(_OWORD *)a1 = v3;
  *(_DWORD *)(a1 + 24) = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 28) = 0;
  *(_OWORD *)(a1 + 32) = xmmword_209BD6B10;
  *(_DWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 376) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 384) = xmmword_209BD6B20;
  *(_DWORD *)(a1 + 400) = 0;
  *(_BYTE *)(a1 + 404) = *(_BYTE *)(a1 + 404) & 0xF0 | 3;
  *(_DWORD *)(a1 + 408) = 0;
  *(_WORD *)(a1 + 412) = 0;
  *(_QWORD *)(a1 + 416) = 0;
  if (!*(_QWORD *)a1)
    return v2;
  v5 = (float32x2_t *)(a1 + 112);
  v6 = *(id *)a1;
  if (!v2[3].i32[0])
    v2[3].i32[0] = objc_msgSend(*(id *)a2, "preferredRenderingMode");
  objc_msgSend(*(id *)v2, "pointSize");
  *(float *)&v7 = v7;
  v2[4].i32[0] = LODWORD(v7);
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(*(id *)v2, "glyphContinuousSize");
    *(float *)&v8 = v8;
    v2[4].i32[1] = LODWORD(v8);
    objc_msgSend(*(id *)v2, "glyphContinuousWeight");
    *(float *)&v9 = v9;
    v2[5].i32[0] = LODWORD(v9);
  }
  objc_msgSend(*(id *)v2, "scale");
  *(float *)&v10 = v10;
  v2[5].i32[1] = LODWORD(v10);
  objc_msgSend(*(id *)v2, "alignmentRectUnrounded");
  v12.f64[1] = v11;
  v14.f64[1] = v13;
  v2[7] = vcvt_f32_f64(v12);
  v2[8] = vcvt_f32_f64(v14);
  if (v2[2].i8[4])
  {
    objc_msgSend(*(id *)v2, "contentBoundsUnrounded");
    v16 = v15 - (float)(COERCE_FLOAT(*(_QWORD *)&v2[8]) + COERCE_FLOAT(*(_QWORD *)&v2[7]));
    v2[7].f32[0] = v16;
  }
  objc_msgSend(*(id *)v2, "pointSize");
  v18 = v17;
  objc_msgSend(*(id *)v2, "referencePointSize");
  v20 = v19;
  objc_msgSend(*(id *)v2, "fontMatchingScaleFactor");
  v22.i64[0] = 1.0;
  v23 = v20 < 1.0 || v18 < 1.0;
  if (!v23)
    *(double *)v22.i64 = v18 / v20;
  v24 = v21 * *(double *)v22.i64;
  *(float *)&v24 = v24;
  v2[6].i32[0] = LODWORD(v24);
  LODWORD(v24) = v2[5].i32[1];
  *(float32x2_t *)v22.f32 = vmul_n_f32(v2[7], *(float *)&v24);
  __asm { FMOV            V2.2S, #1.0 }
  v29 = vdiv_f32(_D2, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v24, 0));
  v30 = vmul_f32(vrndp_f32(vmul_n_f32(v2[8], *(float *)&v24)), v29);
  v2[9] = vmul_f32((float32x2_t)*(_OWORD *)&vrndaq_f32(v22), v29);
  v2[10] = v30;
  v31 = objc_opt_respondsToSelector();
  v32 = (id)*v2;
  if ((v31 & 1) == 0)
  {
    objc_msgSend(v32, "contentBoundsUnrounded");
    v39 = v38;
    objc_msgSend(*(id *)v2, "capHeightUnrounded");
    v41 = v40;
    objc_msgSend(*(id *)v2, "baselineOffsetUnrounded");
    v43 = -(COERCE_FLOAT(*(_QWORD *)&v2[7]) - v39 * 0.5);
    *(float *)&v44 = v42 + v41 * 0.5;
    v35 = (float32x2_t)__PAIR64__(v44, LODWORD(v43));
    if (v2[2].i8[4])
    {
      v35.f32[0] = COERCE_FLOAT(*(_QWORD *)&v2[8]) - v43;
      LODWORD(v37) = HIDWORD(*(_QWORD *)&v2[8]);
      goto LABEL_19;
    }
LABEL_18:
    v37 = v2[8].f32[1];
    goto LABEL_19;
  }
  objc_msgSend(v32, "metricCenter");
  v34.f64[1] = v33;
  v35 = vcvt_f32_f64(v34);
  if (!v2[2].i8[4])
    goto LABEL_18;
  v36.i32[0] = vsub_f32(v2[8], v35).u32[0];
  v36.i32[1] = v35.i32[1];
  LODWORD(v37) = HIDWORD(*(_QWORD *)&v2[8]);
  v35 = v36;
LABEL_19:
  v35.f32[1] = v37 - v35.f32[1];
  v2[11] = v35;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    objc_msgSend(*(id *)v2, "rotationAnchor");
    v46.f64[1] = v45;
    v47 = vcvt_f32_f64(v46);
    v48 = v2[2].u8[4];
    if (v2[2].i8[4])
    {
      v49.i32[0] = vsub_f32(v2[8], v47).u32[0];
      v49.i32[1] = v47.i32[1];
      LODWORD(v50) = HIDWORD(*(_QWORD *)&v2[8]);
      v47 = v49;
    }
    else
    {
      v50 = v2[8].f32[1];
    }
    v47.f32[1] = v50 - v47.f32[1];
  }
  else
  {
    v47 = v2[11];
    v48 = v2[2].u8[4];
  }
  v2[13] = v47;
  if (v48)
    v51 = v2[10];
  else
    v51.i32[0] = 0;
  v155 = v51.f32[0];
  v52 = v2[3].i32[0];
  switch(v52)
  {
    case 0:
    case 1:
      v53 = objc_msgSend(*(id *)v2, "monochromeLayers");
      goto LABEL_56;
    case 2:
      v53 = objc_msgSend(*(id *)v2, "multicolorLayers");
LABEL_56:
      v56 = (void *)v53;
      v67 = 0;
      goto LABEL_61;
    case 3:
      goto LABEL_31;
    case 4:
      goto LABEL_52;
    default:
      if ((v52 - 128) >= 2)
      {
        if (v52 != 130)
        {
          v67 = 0;
          v56 = 0;
          goto LABEL_63;
        }
LABEL_52:
        v68 = (RB::Symbol::_anonymous_namespace_ *)objc_msgSend(*(id *)v2, "paletteLayers");
        v56 = v68;
        v57 = v2[3].i32[0];
        if (v57 != 130)
          goto LABEL_54;
        v2[3].i32[0] = 4;
LABEL_59:
        v67 = v70;
        goto LABEL_61;
      }
LABEL_31:
      v54 = (RB::Symbol::_anonymous_namespace_ *)objc_msgSend(*(id *)v2, "hierarchicalLayers");
      v56 = v54;
      v57 = v2[3].i32[0];
      if (v57 == 129)
      {
        v2[3].i32[0] = 3;
        goto LABEL_59;
      }
      if (v57 != 128)
      {
LABEL_54:
        v67 = 0;
        goto LABEL_62;
      }
      v165 = 0u;
      v166 = 0u;
      v167 = 0u;
      v168 = 0u;
      v58 = -[RB::Symbol::_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v54, "countByEnumeratingWithState:objects:count:", &v165, __dst, 16);
      if (!v58)
      {
LABEL_50:
        v67 = 0;
        v2[3].i32[0] = 3;
        goto LABEL_63;
      }
      v59 = *(_QWORD *)v166;
      v150 = *(_QWORD *)v166;
LABEL_35:
      v60 = 0;
      while (1)
      {
        if (*(_QWORD *)v166 != v59)
          objc_enumerationMutation(v56);
        v61 = *(void **)(*((_QWORD *)&v165 + 1) + 8 * v60);
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v62 = (void *)objc_msgSend(v61, "tags");
          v63 = v62;
          if (v62)
          {
            v163 = 0u;
            v164 = 0u;
            v161 = 0u;
            v162 = 0u;
            v64 = objc_msgSend(v62, "countByEnumeratingWithState:objects:count:", &v161, &v174, 16);
            if (v64)
              break;
          }
        }
LABEL_48:
        if (++v60 == v58)
        {
          v58 = objc_msgSend(v56, "countByEnumeratingWithState:objects:count:", &v165, __dst, 16);
          v5 = v2 + 14;
          if (!v58)
            goto LABEL_50;
          goto LABEL_35;
        }
      }
      v65 = *(_QWORD *)v162;
LABEL_42:
      v66 = 0;
      while (1)
      {
        if (*(_QWORD *)v162 != v65)
          objc_enumerationMutation(v63);
        if ((objc_msgSend(*(id *)(*((_QWORD *)&v161 + 1) + 8 * v66), "isEqualToString:", CFSTR("_slash"), v150) & 1) != 0)
          break;
        if (v64 == ++v66)
        {
          v64 = objc_msgSend(v63, "countByEnumeratingWithState:objects:count:", &v161, &v174, 16);
          v59 = v150;
          if (!v64)
            goto LABEL_48;
          goto LABEL_42;
        }
      }
      v56 = 0;
      v67 = 0;
      v5 = v2 + 14;
LABEL_61:
      v57 = v2[3].i32[0];
LABEL_62:
      if (v57 == 1)
        goto LABEL_65;
LABEL_63:
      if (!objc_msgSend(v56, "count", v150))
      {
        v56 = (void *)objc_msgSend(*(id *)v2, "monochromeLayers");
        v2[3].i32[0] = 1;
      }
LABEL_65:
      v159 = 0u;
      v160 = 0u;
      v157 = 0u;
      v158 = 0u;
      v71 = objc_msgSend(v56, "countByEnumeratingWithState:objects:count:", &v157, v173, 16);
      if (v71)
      {
        v72 = *(_QWORD *)v158;
        while (2)
        {
          for (i = 0; i != v71; ++i)
          {
            if (*(_QWORD *)v158 != v72)
              objc_enumerationMutation(v56);
            v74 = *(void **)(*((_QWORD *)&v157 + 1) + 8 * i);
            v75 = v2[48].u32[0];
            if (v2[48].i32[1] < v75 + 1)
            {
              RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow(v5, v75 + 1);
              v75 = v2[48].u32[0];
            }
            v76 = (float32x2_t *)v2[47];
            if (!v76)
              v76 = v5;
            RB::Symbol::Glyph::Layer::Layer((uint64_t *)&v76[11 * v75], (uint64_t)*v2, v74, v2[3].i32[0], v2[6].f32[0], v155);
            v77 = v2[48].u32[0];
            v2[48].i32[0] = v77 + 1;
            if (v2[47])
              v78 = (RB::Symbol::Glyph::Layer *)v2[47];
            else
              v78 = (RB::Symbol::Glyph::Layer *)v5;
            if ((*((_BYTE *)v78 + 88 * v77 + 86) & 0xC) == 0)
            {
              if (v77 != -1)
              {
                v80 = 88 * (v77 + 1);
                do
                {
                  RB::Symbol::Glyph::Layer::~Layer(v78);
                  v78 = (RB::Symbol::Glyph::Layer *)(v81 + 88);
                  v80 -= 88;
                }
                while (v80);
              }
              v2 = (float32x2_t *)a1;
              *(_DWORD *)(a1 + 384) = 0;
              goto LABEL_86;
            }
          }
          v71 = objc_msgSend(v56, "countByEnumeratingWithState:objects:count:", &v157, v173, 16);
          if (v71)
            continue;
          break;
        }
      }
      v79 = v2[48].u32[0];
      if (v79)
      {
        v170 = 0;
        v171 = 0;
        v172 = 32;
        v174 = 0;
        v175 = 0;
        goto LABEL_87;
      }
LABEL_86:
      v2[3].i32[0] = *((_DWORD *)a2 + 4);
      RB::Symbol::Glyph::make_legacy_layers((RB::Symbol::Glyph *)v2, v155);
      v79 = v2[48].u32[0];
      v170 = 0;
      v171 = 0;
      v172 = 32;
      v174 = 0;
      v175 = 0;
      if (v79)
      {
LABEL_87:
        v151 = v67;
        v153 = v5;
        v82 = 0;
        v83 = 0;
        v84 = 0;
        v85 = 0;
        v152 = v79;
        do
        {
          if (v2[47])
            v86 = v2[47];
          else
            v86 = (float32x2_t)v153;
          v87 = *(_QWORD *)&v86 + v82;
          v88 = *(_DWORD *)(*(_QWORD *)&v86 + v82 + 84);
          if ((v88 & 0xF00) == 0x900)
          {
            v89 = objc_msgSend(*(id *)(v87 + 8), "isEqualToString:", CFSTR("tintColor"));
            v88 = *(_DWORD *)(v87 + 84);
            if (v89)
            {
              v88 &= 0xFFFFF0FF;
              *(_DWORD *)(v87 + 84) = v88;
            }
          }
          v90 = (v88 >> 8) & 0xF;
          if (v90 != 10)
          {
            v2[49].i32[0] |= 1 << v90;
            v88 = *(_DWORD *)(v87 + 84);
          }
          v91 = v2[50].u8[4];
          v92 = v91 & (((v88 & 0x800000) == 0) | 0xFE);
          v2[50].i8[4] = v92;
          if ((((*(_DWORD *)(v87 + 84) & 0x1000000) == 0) & (v91 >> 1)) != 0)
            v93 = 2;
          else
            v93 = 0;
          v2[50].i8[4] = v92 & 0xFD | v93;
          v94 = *(_QWORD *)&v86 + v82;
          v95 = *(_DWORD *)(v94 + 68);
          v156 = *(_BYTE *)(v87 + 84);
          v96 = *(_DWORD *)(v94 + 64);
          if ((v96 & 0x7FFFFFFFu) <= 0x7F7FFFFF)
          {
            v97 = v171;
            v98 = v171 + 1;
            if (v172 < v171 + 1)
            {
              RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(__dst, v98);
              v97 = v171;
              v96 = *(_DWORD *)(v94 + 64);
              v98 = v171 + 1;
            }
            v99 = v170;
            if (!v170)
              v99 = __dst;
            v100 = &v99[8 * v97];
            *v100 = v96;
            v100[1] = v83;
            v171 = v98;
          }
          v101 = *(int **)(v94 + 40);
          if (v101)
            v102 = *(int **)(v94 + 40);
          else
            v102 = (int *)(v94 + 24);
          v103 = *(unsigned int *)(v94 + 48);
          if (RB::Symbol::tags_contains(v102, v103, 1u))
          {
            *(_BYTE *)(a1 + 404) |= 4u;
            v101 = *(int **)(v94 + 40);
            v103 = *(unsigned int *)(v94 + 48);
          }
          if (v101)
            v104 = v101;
          else
            v104 = (int *)(v94 + 24);
          v2 = (float32x2_t *)a1;
          if (RB::Symbol::tags_contains(v104, v103, 2u))
          {
            *(_BYTE *)(a1 + 404) |= 8u;
            v109 = (float32x2_t)RB::Symbol::Glyph::Layer::content_bounds((float32x2_t **)v87, v105, v106, v107, v108);
            RB::Rect::Union(&v174, v109, v110, v111, v112, v113, v114);
          }
          v84 |= 1 << v95;
          v85 |= 1 << v156;
          ++v83;
          v82 += 88;
        }
        while (v152 != v83);
        v115 = v175;
        v116 = v85 & 2;
        v5 = v153;
        v67 = v151;
        goto LABEL_118;
      }
      v116 = 0;
      v84 = 0;
      v115 = 0;
LABEL_118:
      v117 = (uint32x2_t)vcgtz_f32(v115);
      if ((vpmin_u32(v117, v117).u32[0] & 0x80000000) != 0)
        v118 = vmla_f32(v174, (float32x2_t)0x3F0000003F000000, v115);
      else
        v118 = v2[11];
      v2[12] = v118;
      v115.i32[0] = v84;
      v119 = (uint8x8_t)vcnt_s8((int8x8_t)v115);
      v119.i16[0] = vaddlv_u8(v119);
      v2[50].i32[0] = v119.i32[0];
      if (v84 != ~(-1 << v119.i8[0]) && v84 != 0)
      {
        v121 = 0;
        v122 = 0;
        do
        {
          if ((v84 & 1) != 0)
          {
            if (v122 != v121)
            {
              v123 = *(_QWORD *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
              v124 = v2[48].u32[0];
              if (v124)
              {
                v125 = 88 * v124;
                v126 = (_DWORD *)&v123[8] + 1;
                do
                {
                  if (*v126 == v122)
                    *v126 = v121;
                  v126 += 22;
                  v125 -= 88;
                }
                while (v125);
              }
            }
            ++v121;
          }
          ++v122;
          v23 = v84 > 1;
          v84 >>= 1;
        }
        while (v23);
      }
      if (v171)
      {
        if (v170)
          v127 = (int *)v170;
        else
          v127 = (int *)__dst;
        std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(v127, (float *)&v127[2 * v171], (uint64_t)&v165, 126 - 2 * __clz(v171), 1);
        v128 = v170;
        if (!v170)
          v128 = __dst;
        v2 = (float32x2_t *)a1;
        if (v171)
        {
          v129 = &v128[8 * v171];
          v130 = *(float32x2_t **)(a1 + 376);
          if (!v130)
            v130 = v5;
          v131 = *(_DWORD *)(a1 + 396);
          v132 = INFINITY;
          do
          {
            v133 = v132;
            v132 = *(float *)v128;
            v134 = *((_DWORD *)v128 + 1);
            if (*(float *)v128 != v133)
              *(_DWORD *)(a1 + 396) = ++v131;
            v130[11 * v134 + 10].i32[0] = v131;
            v128 += 8;
          }
          while (v128 != v129);
        }
      }
      if (v67)
      {
        v135 = v2[3].i32[0];
        if (v135 != 4)
        {
          if (v135 == 3 && v116)
          {
            v136 = *(_QWORD *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
            v137 = v2[48].u32[0];
            if (v137)
            {
              v138 = 88 * v137;
              v139 = (unsigned int *)&v136[10] + 1;
              while (1)
              {
                v140 = *v139;
                if ((*v139 & 0xF00) == 0)
                {
                  if (*v139 == 1)
                  {
                    v141 = v140 & 0xFFFFFF00;
                    goto LABEL_165;
                  }
                  if (!*v139)
                  {
                    v141 = v140 & 0xFFFFFF00 | 1;
LABEL_165:
                    *v139 = v141;
                  }
                }
                v139 += 22;
                v138 -= 88;
                if (!v138)
                  goto LABEL_182;
              }
            }
          }
          goto LABEL_182;
        }
        if ((v2[49].i16[0] & 0x1E0) != 0)
        {
          v2[49].i32[0] = 0;
          v142 = *(_QWORD *)&v2[47] ? *(float32x2_t **)&v2[47] : v5;
          v143 = v2[48].u32[0];
          if (v143)
          {
            v144 = 88 * v143;
            v145 = (unsigned int *)&v142[10] + 1;
            while (1)
            {
              v146 = *v145;
              v147 = (*v145 >> 8) & 0xF;
              if ((v147 - 5) < 4)
                break;
              if (!v147)
              {
                v146 = v146 & 0xFFFFF0FF | 0x500;
                goto LABEL_178;
              }
LABEL_179:
              v148 = (v146 >> 8) & 0xF;
              if (v148 != 10)
                v2[49].i32[0] |= 1 << v148;
              v145 += 22;
              v144 -= 88;
              if (!v144)
                goto LABEL_182;
            }
            v146 &= 0xFFFFF0FF;
LABEL_178:
            *v145 = v146;
            goto LABEL_179;
          }
        }
      }
LABEL_182:
      if (v170)
        free(v170);
      return v2;
  }
}

void sub_209AD9C10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, RB::Symbol::Glyph::Layer *a11, uint64_t a12)
{

  RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector(a11);
  _Unwind_Resume(a1);
}

void RB::Path::Storage::~Storage(RB::Path::Storage *this)
{
  RB::Path::Storage *v1;
  uint64_t v2;
  int v3;
  os_unfair_lock_s *v4;
  const void *v5;

  v1 = this;
  v2 = *(_QWORD *)this;
  if (*(_QWORD *)this)
  {
    *(_QWORD *)this = 0;
    if ((v2 & 1) != 0)
    {
      this = (RB::Path::Storage *)(v2 & 0xFFFFFFFFFFFFFFFCLL);
      if ((v2 & 0xFFFFFFFFFFFFFFFCLL) != 0)
        this = (RB::Path::Storage *)MEMORY[0x20BD1652C](this, 0x1000C8052888210);
    }
  }
  v3 = *((_DWORD *)v1 + 2);
  if ((v3 & 0x20) != 0)
  {
    v4 = (os_unfair_lock_s *)RB::Path::Storage::MapCache::shared(this);
    RB::Path::Storage::MapCache::remove(v4, v1);
    v3 = *((_DWORD *)v1 + 2);
  }
  if ((v3 & 1) != 0)
  {
    v5 = (const void *)*((_QWORD *)v1 + 7);
    if (!v5 || (*((_QWORD *)v1 + 7) = 0, CFRelease(v5), (*((_BYTE *)v1 + 8) & 1) != 0))
      free(*((void **)v1 + 2));
  }
}

BOOL $_0::__invoke()
{
  _BOOL8 v0;
  uint64_t v2;
  uint64_t *v3;
  uint64_t v4;
  char v5;

  v2 = 0;
  v3 = &v2;
  v4 = 0x2020000000;
  v5 = 0;
  CGPathApplyWithBlock2();
  v0 = *((_BYTE *)v3 + 24) == 0;
  _Block_object_dispose(&v2, 8);
  return v0;
}

void sub_209AD9DAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Block_object_dispose((const void *)(v1 - 48), 8);
  _Unwind_Resume(a1);
}

RB::Path::Storage *RB::Path::Storage::Storage(RB::Path::Storage *this, const char *a2, const RB::Path::Storage *a3)
{
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  char *v8;
  const void *v9;
  size_t v10;
  const void *v11;
  size_t v12;
  _QWORD *v13;
  int v14;

  *(_QWORD *)this = 0;
  if ((unint64_t)a2 <= 0x3F)
    RB::precondition_failure((RB *)"invalid capacity", a2, a3);
  v4 = (unint64_t)(a2 - 16);
  if ((unint64_t)(a2 - 16) >= 0xFFF)
    v4 = 4095;
  *((_DWORD *)this + 2) = (_DWORD)v4 << 20;
  do
  {
    v5 = __ldxr(&RB::Path::Storage::_last_identifier);
    v6 = v5 + 1;
  }
  while (__stxr(v6, &RB::Path::Storage::_last_identifier));
  *((_DWORD *)this + 3) = v6;
  *((_DWORD *)this + 2) = *((_DWORD *)a3 + 2) & 0x3E | ((_DWORD)v4 << 20);
  v7 = *((unsigned int *)a3 + 2);
  v9 = (const void *)*((_QWORD *)a3 + 2);
  v10 = *((_QWORD *)a3 + 3);
  v8 = (char *)a3 + 16;
  if ((v7 & 1) != 0)
    v11 = v9;
  else
    v11 = v8;
  if ((v7 & 1) != 0)
    v12 = v10;
  else
    v12 = (v7 >> 8) & 0xFFF;
  if (v4 < v12)
  {
    RB::Path::Storage::reserve_slow(this, v12);
    v13 = (_QWORD *)((char *)this + 16);
    if ((*((_BYTE *)this + 8) & 1) != 0)
      v13 = (_QWORD *)*v13;
  }
  else
  {
    v13 = (_QWORD *)((char *)this + 16);
  }
  memcpy(v13, v11, v12);
  v14 = *((_DWORD *)this + 2);
  if ((v14 & 1) != 0)
    *((_QWORD *)this + 3) = v12;
  else
    *((_DWORD *)this + 2) = v14 & 0xFFF000FF | ((v12 & 0xFFF) << 8);
  return this;
}

uint64_t RB::Path::Storage::Storage(uint64_t this, const char *a2)
{
  int v2;
  unsigned int v3;
  unsigned int v4;

  *(_QWORD *)this = 0;
  if ((unint64_t)a2 <= 0x3F)
    RB::precondition_failure((RB *)"invalid capacity", a2);
  v2 = (_DWORD)a2 - 16;
  if ((unint64_t)(a2 - 16) >= 0xFFF)
    v2 = 4095;
  *(_DWORD *)(this + 8) = v2 << 20;
  do
  {
    v3 = __ldxr(&RB::Path::Storage::_last_identifier);
    v4 = v3 + 1;
  }
  while (__stxr(v4, &RB::Path::Storage::_last_identifier));
  *(_DWORD *)(this + 12) = v4;
  return this;
}

uint64_t RB::Path::Storage::append_path(RB::Path::Storage *this, RBPath a2)
{
}

void *RB::vector<RB::Symbol::Presentation::Layer,3ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 93) + (*((_DWORD *)__dst + 93) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 93) + (*((_DWORD *)__dst + 93) >> 1);
  result = RB::details::realloc_vector<unsigned int,120ul>(*((void **)__dst + 45), __dst, 3u, (_DWORD *)__dst + 93, v3);
  *((_QWORD *)__dst + 45) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,64ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, (unint64_t)a5 << 6);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size((unint64_t)a5 << 6);
    v9 = v8 >> 6;
    if (*a4 != (v8 >> 6))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, (unint64_t)*a4 << 6);
      goto LABEL_8;
    }
  }
  return v7;
}

void *RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 69) + (*((_DWORD *)__dst + 69) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 69) + (*((_DWORD *)__dst + 69) >> 1);
  result = RB::details::realloc_vector<unsigned int,88ul>(*((void **)__dst + 33), __dst, 3u, (_DWORD *)__dst + 69, v3);
  *((_QWORD *)__dst + 33) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,56ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 56 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(56 * a5);
    v9 = v8 / 0x38;
    if (*a4 != (v8 / 0x38))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 56 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::Symbol::Glyph::copied_glyph(RB::Symbol::Glyph *this)
{
  os_unfair_lock_s *v2;
  uint64_t v3;
  void *v4;

  v2 = (os_unfair_lock_s *)((char *)this + 408);
  os_unfair_lock_lock((os_unfair_lock_t)this + 102);
  v3 = *((_QWORD *)this + 52);
  if (!v3)
  {
    v4 = (void *)objc_msgSend(*(id *)this, "copy");

    *((_QWORD *)this + 52) = v4;
    objc_msgSend(v4, "setVariableMinValue:", INFINITY);
    objc_msgSend(*((id *)this + 52), "setVariableMaxValue:", INFINITY);
    v3 = *((_QWORD *)this + 52);
  }
  os_unfair_lock_unlock(v2);
  return v3;
}

void sub_209ADA498(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(int *a1, float *a2, uint64_t a3, uint64_t a4, char a5)
{
  int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  int *v15;
  int v16;
  int v17;
  int *v18;
  char v19;
  BOOL v20;
  int v21;
  int v22;

LABEL_1:
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 3;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(a2 - 2), (uint64_t)v9))
        {
          v21 = *v9;
          *v9 = *((_DWORD *)a2 - 2);
          *((_DWORD *)a2 - 2) = v21;
          v22 = v9[1];
          v9[1] = *((_DWORD *)a2 - 1);
          *((_DWORD *)a2 - 1) = v22;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9, v9 + 2, (int *)a2 - 2, a3);
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9, v9 + 2, v9 + 4, (int *)a2 - 2, a3);
        return;
      case 5uLL:
        std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9, v9 + 2, v9 + 4, v9 + 6, (int *)a2 - 2, a3);
        return;
      default:
        if (v12 <= 191)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((uint64_t)v9, a2, a3);
          else
            std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((uint64_t)v9, a2, a3);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x401)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(&v9[2 * (v13 >> 1)], v9, (int *)a2 - 2, a3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9, &v9[2 * (v13 >> 1)], (int *)a2 - 2, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9 + 2, v15 - 2, (int *)a2 - 4, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9 + 4, &v9[2 * v14 + 2], (int *)a2 - 6, a3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v15 - 2, v15, &v9[2 * v14 + 2], a3);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            v17 = v9[1];
            v9[1] = v15[1];
            v15[1] = v17;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (!std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(v9 - 2), (uint64_t)v9))
          {
            v9 = (int *)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>((unint64_t)v9, a2);
            goto LABEL_16;
          }
LABEL_11:
          v18 = (int *)std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>((uint64_t)v9, a2);
          if ((v19 & 1) == 0)
            goto LABEL_14;
          v20 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v9, v18, a3);
          v9 = v18 + 2;
          if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(v18 + 2, (int *)a2, a3))
          {
            v10 = v11 + 1;
            if (v20)
              continue;
LABEL_14:
            std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,false>(a1, v18, a3, -v11, a5 & 1);
            v9 = v18 + 2;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (float *)v18;
          if (v20)
            return;
          goto LABEL_1;
        }
        if (v9 != (int *)a2)
          std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>((char *)v9, (char *)a2, (char *)a2, a3);
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)v8) >> 3);
    switch(v10)
    {
      case 0:
      case 1:
        return;
      case 2:
        v45 = *(a2 - 10);
        v44 = a2 - 10;
        if (v45 < (unint64_t)*v8)
        {
          v141 = *((_QWORD *)v8 + 4);
          v125 = *(_OWORD *)v8;
          v134 = *((_OWORD *)v8 + 1);
          v46 = *(_OWORD *)v44;
          v47 = *((_OWORD *)v44 + 1);
          v8[8] = v44[8];
          *(_OWORD *)v8 = v46;
          *((_OWORD *)v8 + 1) = v47;
          v44[8] = v141;
          *(_OWORD *)v44 = v125;
          *((_OWORD *)v44 + 1) = v134;
        }
        return;
      case 3:
        _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(v8, v8 + 10, a2 - 10);
        return;
      case 4:
        _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(v8, v8 + 10, v8 + 20, a2 - 10);
        return;
      case 5:
        v48 = v8 + 10;
        v49 = v8 + 20;
        v50 = v8 + 30;
        _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(v8, v8 + 10, v8 + 20, v8 + 30);
        v52 = *(a2 - 10);
        v51 = a2 - 10;
        if (v52 < (unint64_t)v8[30])
        {
          v53 = *(_OWORD *)v50;
          v135 = *(_OWORD *)(v8 + 34);
          v54 = *((_QWORD *)v8 + 19);
          v56 = *(_OWORD *)v51;
          v55 = *((_OWORD *)v51 + 1);
          v8[38] = v51[8];
          *(_OWORD *)v50 = v56;
          *(_OWORD *)(v8 + 34) = v55;
          v51[8] = v54;
          *(_OWORD *)v51 = v53;
          *((_OWORD *)v51 + 1) = v135;
          if (*v50 < (unint64_t)*v49)
          {
            v57 = *((_QWORD *)v8 + 14);
            v59 = *(_OWORD *)v49;
            v58 = *((_OWORD *)v8 + 6);
            v60 = *(_OWORD *)(v8 + 34);
            *(_OWORD *)v49 = *(_OWORD *)v50;
            *((_OWORD *)v8 + 6) = v60;
            v8[28] = v8[38];
            *(_OWORD *)v50 = v59;
            *(_OWORD *)(v8 + 34) = v58;
            v8[38] = v57;
            if (*v49 < (unint64_t)*v48)
            {
              v61 = *((_QWORD *)v8 + 9);
              v63 = *(_OWORD *)v48;
              v62 = *(_OWORD *)(v8 + 14);
              v64 = *((_OWORD *)v8 + 6);
              *(_OWORD *)v48 = *(_OWORD *)v49;
              *(_OWORD *)(v8 + 14) = v64;
              v8[18] = v8[28];
              *(_OWORD *)v49 = v63;
              *((_OWORD *)v8 + 6) = v62;
              v8[28] = v61;
              if (v8[10] < (unint64_t)*v8)
              {
                v142 = *((_QWORD *)v8 + 4);
                v126 = *(_OWORD *)v8;
                v136 = *((_OWORD *)v8 + 1);
                v65 = *(_OWORD *)(v8 + 14);
                *(_OWORD *)v8 = *(_OWORD *)v48;
                *((_OWORD *)v8 + 1) = v65;
                v8[8] = v8[18];
                *(_OWORD *)v48 = v126;
                *(_OWORD *)(v8 + 14) = v136;
                v8[18] = v142;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 959)
        {
          v66 = v8 + 10;
          v68 = v8 == a2 || v66 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v68)
            {
              v69 = 0;
              v70 = v8;
              do
              {
                v71 = v66;
                v72 = v70[10] | ((unint64_t)*((unsigned __int16 *)v70 + 22) << 32);
                v73 = v70[10];
                if (v73 < *v70)
                {
                  *(_OWORD *)v127 = *(_OWORD *)((char *)v70 + 46);
                  *(_OWORD *)&v127[16] = *(_OWORD *)((char *)v70 + 62);
                  v74 = v69;
                  while (1)
                  {
                    v75 = (char *)v8 + v74;
                    v76 = *(_OWORD *)((char *)v8 + v74 + 16);
                    *(_OWORD *)(v75 + 40) = *(_OWORD *)((char *)v8 + v74);
                    *(_OWORD *)(v75 + 56) = v76;
                    *((_DWORD *)v75 + 18) = *(unsigned int *)((char *)v8 + v74 + 32);
                    if (!v74)
                      break;
                    v74 -= 40;
                    if (v73 >= *((unsigned int *)v75 - 10))
                    {
                      v77 = (uint64_t)v8 + v74 + 40;
                      goto LABEL_76;
                    }
                  }
                  v77 = (uint64_t)v8;
LABEL_76:
                  *(_DWORD *)v77 = v72;
                  *(_WORD *)(v77 + 4) = WORD2(v72);
                  *(_OWORD *)(v77 + 20) = *(_OWORD *)&v127[14];
                  *(_OWORD *)(v77 + 6) = *(_OWORD *)v127;
                }
                v66 = v71 + 10;
                v69 += 40;
                v70 = v71;
              }
              while (v71 + 10 != a2);
            }
          }
          else if (!v68)
          {
            do
            {
              v113 = v66;
              v114 = a1[10] | ((unint64_t)*((unsigned __int16 *)a1 + 22) << 32);
              v115 = a1[10];
              if (v115 < *a1)
              {
                *(_OWORD *)v130 = *(_OWORD *)((char *)a1 + 46);
                *(_OWORD *)&v130[16] = *(_OWORD *)((char *)a1 + 62);
                v116 = v113;
                do
                {
                  v117 = *(_OWORD *)(v116 - 6);
                  *(_OWORD *)v116 = *(_OWORD *)(v116 - 10);
                  *((_OWORD *)v116 + 1) = v117;
                  v116[8] = *(v116 - 2);
                  v118 = *(v116 - 20);
                  v116 -= 10;
                }
                while (v115 < v118);
                *v116 = v114;
                *((_WORD *)v116 + 2) = WORD2(v114);
                *(_OWORD *)(v116 + 5) = *(_OWORD *)&v130[14];
                *(_OWORD *)((char *)v116 + 6) = *(_OWORD *)v130;
              }
              v66 = v113 + 10;
              a1 = v113;
            }
            while (v113 + 10 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v78 = (unint64_t)(v10 - 2) >> 1;
            v79 = v78;
            do
            {
              v80 = v79;
              if (v78 >= v79)
              {
                v81 = (2 * v79) | 1;
                v82 = &v8[10 * v81];
                if (2 * v80 + 2 >= v10)
                {
                  v84 = *v82;
                }
                else
                {
                  v83 = *v82;
                  v84 = v82[10];
                  v85 = v83 >= v84;
                  if (v83 < v84)
                    v82 += 10;
                  else
                    v84 = *v82;
                  if (!v85)
                    v81 = 2 * v80 + 2;
                }
                v86 = &v8[10 * v80];
                v87 = *v86 | ((unint64_t)*((unsigned __int16 *)v86 + 2) << 32);
                v88 = *v86;
                if (v88 <= v84)
                {
                  *(_OWORD *)v128 = *(_OWORD *)((char *)v86 + 6);
                  *(_OWORD *)&v128[16] = *(_OWORD *)((char *)v86 + 22);
                  do
                  {
                    v89 = v86;
                    v86 = v82;
                    v90 = *(_OWORD *)v82;
                    v91 = *((_OWORD *)v82 + 1);
                    v89[8] = v82[8];
                    *(_OWORD *)v89 = v90;
                    *((_OWORD *)v89 + 1) = v91;
                    if (v78 < v81)
                      break;
                    v92 = (2 * v81) | 1;
                    v82 = &v8[10 * v92];
                    v81 = 2 * v81 + 2;
                    if (v81 >= v10)
                    {
                      v93 = *v82;
                      v81 = v92;
                    }
                    else
                    {
                      v93 = *v82;
                      if (*v82 >= (unint64_t)v82[10])
                      {
                        v81 = v92;
                      }
                      else
                      {
                        v93 = v82[10];
                        v82 += 10;
                      }
                    }
                  }
                  while (v88 <= v93);
                  *v86 = v87;
                  *((_WORD *)v86 + 2) = WORD2(v87);
                  *(_OWORD *)(v86 + 5) = *(_OWORD *)&v128[14];
                  *(_OWORD *)((char *)v86 + 6) = *(_OWORD *)v128;
                }
              }
              v79 = v80 - 1;
            }
            while (v80);
            v94 = v9 / 0x28uLL;
            do
            {
              v95 = 0;
              v143 = *((_QWORD *)v8 + 4);
              v129 = *(_OWORD *)v8;
              v137 = *((_OWORD *)v8 + 1);
              v96 = v8;
              do
              {
                v97 = &v96[10 * v95 + 10];
                v98 = (2 * v95) | 1;
                v99 = 2 * v95 + 2;
                if (v99 < v94 && *v97 < (unint64_t)v97[10])
                {
                  v97 += 10;
                  v98 = v99;
                }
                v100 = *(_OWORD *)v97;
                v101 = *((_OWORD *)v97 + 1);
                v96[8] = v97[8];
                *(_OWORD *)v96 = v100;
                *((_OWORD *)v96 + 1) = v101;
                v96 = v97;
                v95 = v98;
              }
              while (v98 <= (uint64_t)((unint64_t)(v94 - 2) >> 1));
              a2 -= 10;
              if (v97 == a2)
              {
                v97[8] = v143;
                *(_OWORD *)v97 = v129;
                *((_OWORD *)v97 + 1) = v137;
              }
              else
              {
                v102 = *(_OWORD *)a2;
                v103 = *((_OWORD *)a2 + 1);
                v97[8] = a2[8];
                *(_OWORD *)v97 = v102;
                *((_OWORD *)v97 + 1) = v103;
                a2[8] = v143;
                *(_OWORD *)a2 = v129;
                *((_OWORD *)a2 + 1) = v137;
                v104 = (char *)v97 - (char *)v8 + 40;
                if (v104 >= 41)
                {
                  v105 = (v104 / 0x28uLL - 2) >> 1;
                  v106 = &v8[10 * v105];
                  v107 = *v97;
                  v108 = v107 | ((unint64_t)*((unsigned __int16 *)v97 + 2) << 32);
                  if (*v106 < (unint64_t)v107)
                  {
                    *(_OWORD *)v121 = *(_OWORD *)((char *)v97 + 6);
                    *(_OWORD *)&v121[16] = *(_OWORD *)((char *)v97 + 22);
                    do
                    {
                      v109 = v97;
                      v97 = v106;
                      v110 = *(_OWORD *)v106;
                      v111 = *((_OWORD *)v106 + 1);
                      v109[8] = v106[8];
                      *(_OWORD *)v109 = v110;
                      *((_OWORD *)v109 + 1) = v111;
                      if (!v105)
                        break;
                      v105 = (v105 - 1) >> 1;
                      v106 = &v8[10 * v105];
                    }
                    while (*v106 < (unint64_t)v108);
                    *v97 = v108;
                    *((_WORD *)v97 + 2) = WORD2(v108);
                    *(_OWORD *)(v97 + 5) = *(_OWORD *)&v121[14];
                    *(_OWORD *)((char *)v97 + 6) = *(_OWORD *)v121;
                  }
                }
              }
            }
            while (v94-- > 2);
          }
          return;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = &v8[10 * ((unint64_t)v10 >> 1)];
        if ((unint64_t)v9 < 0x1401)
        {
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(v12, a1, a2 - 10);
        }
        else
        {
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, v12, a2 - 10);
          v13 = 5 * v11;
          v14 = &a1[10 * v11 - 10];
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1 + 10, v14, a2 - 20);
          v15 = &a1[2 * v13 + 10];
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1 + 20, v15, a2 - 30);
          _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(v14, v12, v15);
          v138 = *((_QWORD *)a1 + 4);
          v122 = *(_OWORD *)a1;
          v131 = *((_OWORD *)a1 + 1);
          v16 = *(_OWORD *)v12;
          v17 = *((_OWORD *)v12 + 1);
          a1[8] = v12[8];
          *(_OWORD *)a1 = v16;
          *((_OWORD *)a1 + 1) = v17;
          v12[8] = v138;
          *(_OWORD *)v12 = v122;
          *((_OWORD *)v12 + 1) = v131;
        }
        --a3;
        v18 = *a1 | ((unint64_t)*((unsigned __int16 *)a1 + 2) << 32);
        if ((a4 & 1) == 0)
        {
          v19 = *a1;
          if (*(a1 - 10) < v19)
            goto LABEL_11;
          *(_OWORD *)v120 = *(_OWORD *)((char *)a1 + 6);
          *(_OWORD *)&v120[16] = *(_OWORD *)((char *)a1 + 22);
          if (v19 >= *(a2 - 10))
          {
            v35 = a1 + 10;
            do
            {
              v8 = v35;
              if (v35 >= a2)
                break;
              v35 += 10;
            }
            while (v19 >= *v8);
          }
          else
          {
            v8 = a1;
            do
            {
              v34 = v8[10];
              v8 += 10;
            }
            while (v19 >= v34);
          }
          v36 = (unint64_t)a2;
          if (v8 < a2)
          {
            v36 = (unint64_t)a2;
            do
            {
              v37 = *(_DWORD *)(v36 - 40);
              v36 -= 40;
            }
            while (v19 < v37);
          }
          while ((unint64_t)v8 < v36)
          {
            v140 = *((_QWORD *)v8 + 4);
            v124 = *(_OWORD *)v8;
            v133 = *((_OWORD *)v8 + 1);
            v38 = *(_OWORD *)v36;
            v39 = *(_OWORD *)(v36 + 16);
            v8[8] = *(_DWORD *)(v36 + 32);
            *(_OWORD *)v8 = v38;
            *((_OWORD *)v8 + 1) = v39;
            *(_DWORD *)(v36 + 32) = v140;
            *(_OWORD *)v36 = v124;
            *(_OWORD *)(v36 + 16) = v133;
            do
            {
              v40 = v8[10];
              v8 += 10;
            }
            while (v19 >= v40);
            do
            {
              v41 = *(_DWORD *)(v36 - 40);
              v36 -= 40;
            }
            while (v19 < v41);
          }
          if (v8 - 10 != a1)
          {
            v42 = *(_OWORD *)(v8 - 10);
            v43 = *(_OWORD *)(v8 - 6);
            a1[8] = *(v8 - 2);
            *(_OWORD *)a1 = v42;
            *((_OWORD *)a1 + 1) = v43;
          }
          a4 = 0;
          *(v8 - 10) = v18;
          *((_WORD *)v8 - 18) = WORD2(v18);
          *(_OWORD *)(v8 - 5) = *(_OWORD *)&v120[14];
          *(_OWORD *)((char *)v8 - 34) = *(_OWORD *)v120;
          continue;
        }
        v19 = *a1;
LABEL_11:
        v20 = 0;
        *(_OWORD *)v119 = *(_OWORD *)((char *)a1 + 6);
        *(_OWORD *)&v119[16] = *(_OWORD *)((char *)a1 + 22);
        do
        {
          v21 = a1[v20 + 10];
          v20 += 10;
        }
        while (v21 < v19);
        v22 = &a1[v20];
        v23 = a2;
        if (v20 == 10)
        {
          v23 = a2;
          do
          {
            if (v22 >= v23)
              break;
            v25 = *(v23 - 10);
            v23 -= 10;
          }
          while (v25 >= v19);
        }
        else
        {
          do
          {
            v24 = *(v23 - 10);
            v23 -= 10;
          }
          while (v24 >= v19);
        }
        v8 = &a1[v20];
        if (v22 < v23)
        {
          v26 = (unint64_t)v23;
          do
          {
            v139 = *((_QWORD *)v8 + 4);
            v123 = *(_OWORD *)v8;
            v132 = *((_OWORD *)v8 + 1);
            v27 = *(_OWORD *)v26;
            v28 = *(_OWORD *)(v26 + 16);
            v8[8] = *(_DWORD *)(v26 + 32);
            *(_OWORD *)v8 = v27;
            *((_OWORD *)v8 + 1) = v28;
            *(_DWORD *)(v26 + 32) = v139;
            *(_OWORD *)v26 = v123;
            *(_OWORD *)(v26 + 16) = v132;
            do
            {
              v29 = v8[10];
              v8 += 10;
            }
            while (v29 < v19);
            do
            {
              v30 = *(_DWORD *)(v26 - 40);
              v26 -= 40;
            }
            while (v30 >= v19);
          }
          while ((unint64_t)v8 < v26);
        }
        if (v8 - 10 != a1)
        {
          v31 = *(_OWORD *)(v8 - 10);
          v32 = *(_OWORD *)(v8 - 6);
          a1[8] = *(v8 - 2);
          *(_OWORD *)a1 = v31;
          *((_OWORD *)a1 + 1) = v32;
        }
        *(v8 - 10) = v18;
        *((_WORD *)v8 - 18) = WORD2(v18);
        *(_OWORD *)(v8 - 5) = *(_OWORD *)&v119[14];
        *(_OWORD *)((char *)v8 - 34) = *(_OWORD *)v119;
        if (v22 < v23)
        {
LABEL_30:
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(a1, v8 - 10, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v33 = _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(a1, v8 - 10);
        if (!_ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(v8, a2))
        {
          if (v33)
            continue;
          goto LABEL_30;
        }
        a2 = v8 - 10;
        if (!v33)
          goto LABEL_1;
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = a2 - v8;
    v10 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(a2 - v8) >> 3);
    switch(v10)
    {
      case 0:
      case 1:
        return;
      case 2:
        v44 = *(_QWORD *)(a2 - 40);
        v43 = a2 - 40;
        if (v44 < *(_QWORD *)v8)
        {
          v141 = *(_QWORD *)(v8 + 32);
          v122 = *(_OWORD *)v8;
          v131 = *(_OWORD *)(v8 + 16);
          v45 = *(_OWORD *)v43;
          v46 = *(_OWORD *)(v43 + 16);
          *(_QWORD *)(v8 + 32) = *(_QWORD *)(v43 + 32);
          *(_OWORD *)v8 = v45;
          *(_OWORD *)(v8 + 16) = v46;
          *(_QWORD *)(v43 + 32) = v141;
          *(_OWORD *)v43 = v122;
          *(_OWORD *)(v43 + 16) = v131;
        }
        return;
      case 3:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)v8, (unint64_t *)(v8 + 40), (unint64_t *)(a2 - 40));
        return;
      case 4:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v8, v8 + 40, v8 + 80, a2 - 40);
        return;
      case 5:
        v47 = (__int128 *)(v8 + 40);
        v48 = (__int128 *)(v8 + 80);
        v49 = (__int128 *)(v8 + 120);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v8, v8 + 40, v8 + 80, v8 + 120);
        v51 = *(_QWORD *)(a2 - 40);
        v50 = a2 - 40;
        if (v51 < *(_QWORD *)(v8 + 120))
        {
          v52 = *v49;
          v132 = *(_OWORD *)(v8 + 136);
          v53 = *(_QWORD *)(v8 + 152);
          v55 = *(_OWORD *)v50;
          v54 = *(_OWORD *)(v50 + 16);
          *(_QWORD *)(v8 + 152) = *(_QWORD *)(v50 + 32);
          *v49 = v55;
          *(_OWORD *)(v8 + 136) = v54;
          *(_QWORD *)(v50 + 32) = v53;
          *(_OWORD *)v50 = v52;
          *(_OWORD *)(v50 + 16) = v132;
          if (*(_QWORD *)v49 < *(_QWORD *)v48)
          {
            v56 = *(_QWORD *)(v8 + 112);
            v58 = *v48;
            v57 = *(_OWORD *)(v8 + 96);
            v59 = *(_OWORD *)(v8 + 136);
            *v48 = *v49;
            *(_OWORD *)(v8 + 96) = v59;
            *(_QWORD *)(v8 + 112) = *(_QWORD *)(v8 + 152);
            *v49 = v58;
            *(_OWORD *)(v8 + 136) = v57;
            *(_QWORD *)(v8 + 152) = v56;
            if (*(_QWORD *)v48 < *(_QWORD *)v47)
            {
              v60 = *(_QWORD *)(v8 + 72);
              v62 = *v47;
              v61 = *(_OWORD *)(v8 + 56);
              v63 = *(_OWORD *)(v8 + 96);
              *v47 = *v48;
              *(_OWORD *)(v8 + 56) = v63;
              *(_QWORD *)(v8 + 72) = *(_QWORD *)(v8 + 112);
              *v48 = v62;
              *(_OWORD *)(v8 + 96) = v61;
              *(_QWORD *)(v8 + 112) = v60;
              if (*(_QWORD *)(v8 + 40) < *(_QWORD *)v8)
              {
                v142 = *(_QWORD *)(v8 + 32);
                v123 = *(_OWORD *)v8;
                v133 = *(_OWORD *)(v8 + 16);
                v64 = *(_OWORD *)(v8 + 56);
                *(_OWORD *)v8 = *v47;
                *(_OWORD *)(v8 + 16) = v64;
                *(_QWORD *)(v8 + 32) = *(_QWORD *)(v8 + 72);
                *v47 = v123;
                *(_OWORD *)(v8 + 56) = v133;
                *(_QWORD *)(v8 + 72) = v142;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 959)
        {
          v65 = v8 + 40;
          v67 = v8 == a2 || v65 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v67)
            {
              v68 = 0;
              v69 = v8;
              do
              {
                v70 = v65;
                v71 = *(_QWORD *)(v69 + 40);
                if (v71 < *(_QWORD *)v69)
                {
                  v124 = *(_OWORD *)(v69 + 48);
                  v134 = *(_OWORD *)(v69 + 64);
                  v72 = v68;
                  while (1)
                  {
                    v73 = v8 + v72;
                    v74 = *(_OWORD *)(v8 + v72 + 16);
                    *(_OWORD *)(v73 + 40) = *(_OWORD *)(v8 + v72);
                    *(_OWORD *)(v73 + 56) = v74;
                    *(_QWORD *)(v73 + 72) = *(_QWORD *)(v8 + v72 + 32);
                    if (!v72)
                      break;
                    v72 -= 40;
                    if (v71 >= *(_QWORD *)(v73 - 40))
                    {
                      v75 = v8 + v72 + 40;
                      goto LABEL_75;
                    }
                  }
                  v75 = v8;
LABEL_75:
                  *(_QWORD *)v75 = v71;
                  *(_OWORD *)(v75 + 24) = v134;
                  *(_OWORD *)(v75 + 8) = v124;
                }
                v65 = v70 + 40;
                v68 += 40;
                v69 = v70;
              }
              while (v70 + 40 != a2);
            }
          }
          else if (!v67)
          {
            do
            {
              v109 = v65;
              v110 = *(_QWORD *)(a1 + 40);
              if (v110 < *(_QWORD *)a1)
              {
                v127 = *(_OWORD *)(a1 + 48);
                v137 = *(_OWORD *)(a1 + 64);
                do
                {
                  v111 = *(_OWORD *)(v65 - 24);
                  *(_OWORD *)v65 = *(_OWORD *)(v65 - 40);
                  *(_OWORD *)(v65 + 16) = v111;
                  *(_QWORD *)(v65 + 32) = *(_QWORD *)(v65 - 8);
                  v112 = *(_QWORD *)(v65 - 80);
                  v65 -= 40;
                }
                while (v110 < v112);
                *(_QWORD *)v65 = v110;
                *(_OWORD *)(v65 + 24) = v137;
                *(_OWORD *)(v65 + 8) = v127;
              }
              v65 = v109 + 40;
              a1 = v109;
            }
            while (v109 + 40 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v76 = (unint64_t)(v10 - 2) >> 1;
            v77 = v76;
            do
            {
              v78 = v77;
              if (v76 >= v77)
              {
                v79 = (2 * v77) | 1;
                v80 = v8 + 40 * v79;
                if (2 * v78 + 2 >= v10)
                {
                  v81 = *(_QWORD *)v80;
                }
                else
                {
                  v81 = *(_QWORD *)(v80 + 40);
                  v82 = *(_QWORD *)v80 >= v81;
                  if (*(_QWORD *)v80 > v81)
                    v81 = *(_QWORD *)v80;
                  if (!v82)
                  {
                    v80 += 40;
                    v79 = 2 * v78 + 2;
                  }
                }
                v83 = v8 + 40 * v78;
                v84 = *(_QWORD *)v83;
                if (v81 >= *(_QWORD *)v83)
                {
                  v125 = *(_OWORD *)(v83 + 8);
                  v135 = *(_OWORD *)(v83 + 24);
                  do
                  {
                    v85 = v83;
                    v83 = v80;
                    v86 = *(_OWORD *)v80;
                    v87 = *(_OWORD *)(v80 + 16);
                    *(_QWORD *)(v85 + 32) = *(_QWORD *)(v80 + 32);
                    *(_OWORD *)v85 = v86;
                    *(_OWORD *)(v85 + 16) = v87;
                    if (v76 < v79)
                      break;
                    v88 = (2 * v79) | 1;
                    v80 = v8 + 40 * v88;
                    v79 = 2 * v79 + 2;
                    if (v79 >= v10)
                    {
                      v89 = *(_QWORD *)v80;
                      v79 = v88;
                    }
                    else
                    {
                      v89 = *(_QWORD *)v80;
                      v90 = *(_QWORD *)(v80 + 40);
                      if (*(_QWORD *)v80 <= v90)
                        v89 = *(_QWORD *)(v80 + 40);
                      if (*(_QWORD *)v80 >= v90)
                        v79 = v88;
                      else
                        v80 += 40;
                    }
                  }
                  while (v89 >= v84);
                  *(_QWORD *)v83 = v84;
                  *(_OWORD *)(v83 + 24) = v135;
                  *(_OWORD *)(v83 + 8) = v125;
                }
              }
              v77 = v78 - 1;
            }
            while (v78);
            v91 = v9 / 0x28uLL;
            do
            {
              v92 = 0;
              v143 = *(_QWORD *)(v8 + 32);
              v126 = *(_OWORD *)v8;
              v136 = *(_OWORD *)(v8 + 16);
              v93 = v8;
              do
              {
                v94 = v93 + 40 * v92 + 40;
                v95 = (2 * v92) | 1;
                v96 = 2 * v92 + 2;
                if (v96 < v91 && *(_QWORD *)v94 < *(_QWORD *)(v94 + 40))
                {
                  v94 += 40;
                  v95 = v96;
                }
                v97 = *(_OWORD *)v94;
                v98 = *(_OWORD *)(v94 + 16);
                *(_QWORD *)(v93 + 32) = *(_QWORD *)(v94 + 32);
                *(_OWORD *)v93 = v97;
                *(_OWORD *)(v93 + 16) = v98;
                v93 = v94;
                v92 = v95;
              }
              while (v95 <= (uint64_t)((unint64_t)(v91 - 2) >> 1));
              a2 -= 40;
              if (v94 == a2)
              {
                *(_QWORD *)(v94 + 32) = v143;
                *(_OWORD *)v94 = v126;
                *(_OWORD *)(v94 + 16) = v136;
              }
              else
              {
                v99 = *(_OWORD *)a2;
                v100 = *(_OWORD *)(a2 + 16);
                *(_QWORD *)(v94 + 32) = *(_QWORD *)(a2 + 32);
                *(_OWORD *)v94 = v99;
                *(_OWORD *)(v94 + 16) = v100;
                *(_QWORD *)(a2 + 32) = v143;
                *(_OWORD *)a2 = v126;
                *(_OWORD *)(a2 + 16) = v136;
                v101 = v94 - v8 + 40;
                if (v101 >= 41)
                {
                  v102 = (v101 / 0x28uLL - 2) >> 1;
                  v103 = v8 + 40 * v102;
                  v104 = *(_QWORD *)v94;
                  if (*(_QWORD *)v103 < *(_QWORD *)v94)
                  {
                    v115 = *(_OWORD *)(v94 + 8);
                    v118 = *(_OWORD *)(v94 + 24);
                    do
                    {
                      v105 = v94;
                      v94 = v103;
                      v106 = *(_OWORD *)v103;
                      v107 = *(_OWORD *)(v103 + 16);
                      *(_QWORD *)(v105 + 32) = *(_QWORD *)(v103 + 32);
                      *(_OWORD *)v105 = v106;
                      *(_OWORD *)(v105 + 16) = v107;
                      if (!v102)
                        break;
                      v102 = (v102 - 1) >> 1;
                      v103 = v8 + 40 * v102;
                    }
                    while (*(_QWORD *)v103 < v104);
                    *(_QWORD *)v94 = v104;
                    *(_OWORD *)(v94 + 24) = v118;
                    *(_OWORD *)(v94 + 8) = v115;
                  }
                }
              }
            }
            while (v91-- > 2);
          }
          return;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = v8 + 40 * ((unint64_t)v10 >> 1);
        if ((unint64_t)v9 < 0x1401)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)v12, (unint64_t *)a1, (unint64_t *)(a2 - 40));
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)a1, (unint64_t *)v12, (unint64_t *)(a2 - 40));
          v13 = 5 * v11;
          v14 = (unint64_t *)(a1 + 40 * v11 - 40);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)(a1 + 40), v14, (unint64_t *)(a2 - 80));
          v15 = (unint64_t *)(a1 + 40 + 8 * v13);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)(a1 + 80), v15, (unint64_t *)(a2 - 120));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)v14, (unint64_t *)v12, v15);
          v138 = *(_QWORD *)(a1 + 32);
          v119 = *(_OWORD *)a1;
          v128 = *(_OWORD *)(a1 + 16);
          v16 = *(_OWORD *)v12;
          v17 = *(_OWORD *)(v12 + 16);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v12 + 32);
          *(_OWORD *)a1 = v16;
          *(_OWORD *)(a1 + 16) = v17;
          *(_QWORD *)(v12 + 32) = v138;
          *(_OWORD *)v12 = v119;
          *(_OWORD *)(v12 + 16) = v128;
        }
        --a3;
        v18 = *(_QWORD *)a1;
        if ((a4 & 1) == 0 && *(_QWORD *)(a1 - 40) >= v18)
        {
          v114 = *(_OWORD *)(a1 + 8);
          v117 = *(_OWORD *)(a1 + 24);
          if (v18 >= *(_QWORD *)(a2 - 40))
          {
            v34 = a1 + 40;
            do
            {
              v8 = v34;
              if (v34 >= a2)
                break;
              v34 += 40;
            }
            while (v18 >= *(_QWORD *)v8);
          }
          else
          {
            v8 = a1;
            do
            {
              v33 = *(_QWORD *)(v8 + 40);
              v8 += 40;
            }
            while (v18 >= v33);
          }
          v35 = a2;
          if (v8 < a2)
          {
            v35 = a2;
            do
            {
              v36 = *(_QWORD *)(v35 - 40);
              v35 -= 40;
            }
            while (v18 < v36);
          }
          while (v8 < v35)
          {
            v140 = *(_QWORD *)(v8 + 32);
            v121 = *(_OWORD *)v8;
            v130 = *(_OWORD *)(v8 + 16);
            v37 = *(_OWORD *)v35;
            v38 = *(_OWORD *)(v35 + 16);
            *(_QWORD *)(v8 + 32) = *(_QWORD *)(v35 + 32);
            *(_OWORD *)v8 = v37;
            *(_OWORD *)(v8 + 16) = v38;
            *(_QWORD *)(v35 + 32) = v140;
            *(_OWORD *)v35 = v121;
            *(_OWORD *)(v35 + 16) = v130;
            do
            {
              v39 = *(_QWORD *)(v8 + 40);
              v8 += 40;
            }
            while (v18 >= v39);
            do
            {
              v40 = *(_QWORD *)(v35 - 40);
              v35 -= 40;
            }
            while (v18 < v40);
          }
          if (v8 - 40 != a1)
          {
            v41 = *(_OWORD *)(v8 - 40);
            v42 = *(_OWORD *)(v8 - 24);
            *(_QWORD *)(a1 + 32) = *(_QWORD *)(v8 - 8);
            *(_OWORD *)a1 = v41;
            *(_OWORD *)(a1 + 16) = v42;
          }
          a4 = 0;
          *(_QWORD *)(v8 - 40) = v18;
          *(_OWORD *)(v8 - 32) = v114;
          *(_OWORD *)(v8 - 16) = v117;
          continue;
        }
        v19 = 0;
        v113 = *(_OWORD *)(a1 + 8);
        v116 = *(_OWORD *)(a1 + 24);
        do
        {
          v20 = *(_QWORD *)(a1 + v19 + 40);
          v19 += 40;
        }
        while (v20 < v18);
        v21 = a1 + v19;
        v22 = a2;
        if (v19 == 40)
        {
          v22 = a2;
          do
          {
            if (v21 >= v22)
              break;
            v24 = *(_QWORD *)(v22 - 40);
            v22 -= 40;
          }
          while (v24 >= v18);
        }
        else
        {
          do
          {
            v23 = *(_QWORD *)(v22 - 40);
            v22 -= 40;
          }
          while (v23 >= v18);
        }
        v8 = a1 + v19;
        if (v21 < v22)
        {
          v25 = v22;
          do
          {
            v139 = *(_QWORD *)(v8 + 32);
            v120 = *(_OWORD *)v8;
            v129 = *(_OWORD *)(v8 + 16);
            v26 = *(_OWORD *)v25;
            v27 = *(_OWORD *)(v25 + 16);
            *(_QWORD *)(v8 + 32) = *(_QWORD *)(v25 + 32);
            *(_OWORD *)v8 = v26;
            *(_OWORD *)(v8 + 16) = v27;
            *(_QWORD *)(v25 + 32) = v139;
            *(_OWORD *)v25 = v120;
            *(_OWORD *)(v25 + 16) = v129;
            do
            {
              v28 = *(_QWORD *)(v8 + 40);
              v8 += 40;
            }
            while (v28 < v18);
            do
            {
              v29 = *(_QWORD *)(v25 - 40);
              v25 -= 40;
            }
            while (v29 >= v18);
          }
          while (v8 < v25);
        }
        if (v8 - 40 != a1)
        {
          v30 = *(_OWORD *)(v8 - 40);
          v31 = *(_OWORD *)(v8 - 24);
          *(_QWORD *)(a1 + 32) = *(_QWORD *)(v8 - 8);
          *(_OWORD *)a1 = v30;
          *(_OWORD *)(a1 + 16) = v31;
        }
        *(_QWORD *)(v8 - 40) = v18;
        *(_OWORD *)(v8 - 32) = v113;
        *(_OWORD *)(v8 - 16) = v116;
        if (v21 < v22)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(a1, v8 - 40, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v32 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, v8 - 40);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(v8, a2))
        {
          if (v32)
            continue;
          goto LABEL_29;
        }
        a2 = v8 - 40;
        if (!v32)
          goto LABEL_1;
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = a2 - v8;
    v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a2 - v8) >> 3);
    switch(v10)
    {
      case 0:
      case 1:
        return;
      case 2:
        v39 = *(double *)(a2 - 24);
        v38 = a2 - 24;
        if (v39 < *(double *)v8)
        {
          v108 = *(_QWORD *)(v8 + 16);
          v99 = *(_OWORD *)v8;
          v40 = *(_OWORD *)v38;
          *(_QWORD *)(v8 + 16) = *(_QWORD *)(v38 + 16);
          *(_OWORD *)v8 = v40;
          *(_QWORD *)(v38 + 16) = v108;
          *(_OWORD *)v38 = v99;
        }
        return;
      case 3:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>((__int128 *)v8, (__int128 *)(v8 + 24), (__int128 *)(a2 - 24));
        return;
      case 4:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>(v8, v8 + 24, v8 + 48, (unint64_t *)(a2 - 24));
        return;
      case 5:
        v41 = (__int128 *)(v8 + 24);
        v42 = (__int128 *)(v8 + 48);
        v43 = (__int128 *)(v8 + 72);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>(v8, v8 + 24, v8 + 48, (unint64_t *)(v8 + 72));
        v45 = *(double *)(a2 - 24);
        v44 = a2 - 24;
        if (v45 < *(double *)(v8 + 72))
        {
          v46 = *v43;
          v47 = *(_QWORD *)(v8 + 88);
          v48 = *(_QWORD *)(v44 + 16);
          *v43 = *(_OWORD *)v44;
          *(_QWORD *)(v8 + 88) = v48;
          *(_QWORD *)(v44 + 16) = v47;
          *(_OWORD *)v44 = v46;
          if (*(double *)v43 < *(double *)v42)
          {
            v49 = *(_QWORD *)(v8 + 64);
            v50 = *v42;
            *v42 = *v43;
            *(_QWORD *)(v8 + 64) = *(_QWORD *)(v8 + 88);
            *v43 = v50;
            *(_QWORD *)(v8 + 88) = v49;
            if (*(double *)v42 < *(double *)v41)
            {
              v51 = *(_QWORD *)(v8 + 40);
              v52 = *v41;
              *v41 = *v42;
              *(_QWORD *)(v8 + 40) = *(_QWORD *)(v8 + 64);
              *v42 = v52;
              *(_QWORD *)(v8 + 64) = v51;
              if (*(double *)(v8 + 24) < *(double *)v8)
              {
                v109 = *(_QWORD *)(v8 + 16);
                v100 = *(_OWORD *)v8;
                *(_OWORD *)v8 = *v41;
                *(_QWORD *)(v8 + 16) = *(_QWORD *)(v8 + 40);
                *v41 = v100;
                *(_QWORD *)(v8 + 40) = v109;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 575)
        {
          v53 = v8 + 24;
          v55 = v8 == a2 || v53 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v55)
            {
              v56 = 0;
              v57 = v8;
              do
              {
                v58 = v53;
                v59 = *(double *)(v57 + 24);
                if (v59 < *(double *)v57)
                {
                  v101 = *(_OWORD *)(v57 + 32);
                  v60 = v56;
                  while (1)
                  {
                    v61 = v8 + v60;
                    *(_OWORD *)(v61 + 24) = *(_OWORD *)(v8 + v60);
                    *(_QWORD *)(v61 + 40) = *(_QWORD *)(v8 + v60 + 16);
                    if (!v60)
                      break;
                    v60 -= 24;
                    if (v59 >= *(double *)(v61 - 24))
                    {
                      v62 = v8 + v60 + 24;
                      goto LABEL_75;
                    }
                  }
                  v62 = v8;
LABEL_75:
                  *(double *)v62 = v59;
                  *(_OWORD *)(v62 + 8) = v101;
                }
                v53 = v58 + 24;
                v56 += 24;
                v57 = v58;
              }
              while (v58 + 24 != a2);
            }
          }
          else if (!v55)
          {
            do
            {
              v89 = v53;
              v90 = *(double *)(a1 + 24);
              if (v90 < *(double *)a1)
              {
                v104 = *(_OWORD *)(a1 + 32);
                v91 = v53;
                do
                {
                  *(_OWORD *)v91 = *(_OWORD *)(v91 - 24);
                  *(_QWORD *)(v91 + 16) = *(_QWORD *)(v91 - 8);
                  v92 = *(double *)(v91 - 48);
                  v91 -= 24;
                }
                while (v90 < v92);
                *(double *)v91 = v90;
                *(_OWORD *)(v91 + 8) = v104;
              }
              v53 += 24;
              a1 = v89;
            }
            while (v89 + 24 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v63 = (unint64_t)(v10 - 2) >> 1;
            v64 = v63;
            do
            {
              v65 = v64;
              if (v63 >= v64)
              {
                v66 = (2 * v64) | 1;
                v67 = v8 + 24 * v66;
                if (2 * v65 + 2 < v10 && *(double *)v67 < *(double *)(v67 + 24))
                {
                  v67 += 24;
                  v66 = 2 * v65 + 2;
                }
                v68 = v8 + 24 * v65;
                v69 = *(double *)v68;
                if (*(double *)v67 >= *(double *)v68)
                {
                  v102 = *(_OWORD *)(v68 + 8);
                  do
                  {
                    v70 = v68;
                    v68 = v67;
                    v71 = *(_OWORD *)v67;
                    *(_QWORD *)(v70 + 16) = *(_QWORD *)(v67 + 16);
                    *(_OWORD *)v70 = v71;
                    if (v63 < v66)
                      break;
                    v72 = 2 * v66;
                    v66 = (2 * v66) | 1;
                    v67 = v8 + 24 * v66;
                    v73 = v72 + 2;
                    if (v73 < v10 && *(double *)v67 < *(double *)(v67 + 24))
                    {
                      v67 += 24;
                      v66 = v73;
                    }
                  }
                  while (*(double *)v67 >= v69);
                  *(double *)v68 = v69;
                  *(_OWORD *)(v68 + 8) = v102;
                }
              }
              v64 = v65 - 1;
            }
            while (v65);
            v74 = v9 / 0x18uLL;
            do
            {
              v75 = 0;
              v110 = *(_QWORD *)(v8 + 16);
              v103 = *(_OWORD *)v8;
              v76 = v8;
              do
              {
                v77 = v76;
                v76 += 24 * v75 + 24;
                v78 = 2 * v75;
                v75 = (2 * v75) | 1;
                v79 = v78 + 2;
                if (v79 < v74 && *(double *)v76 < *(double *)(v76 + 24))
                {
                  v76 += 24;
                  v75 = v79;
                }
                v80 = *(_OWORD *)v76;
                *(_QWORD *)(v77 + 16) = *(_QWORD *)(v76 + 16);
                *(_OWORD *)v77 = v80;
              }
              while (v75 <= (uint64_t)((unint64_t)(v74 - 2) >> 1));
              a2 -= 24;
              if (v76 == a2)
              {
                *(_QWORD *)(v76 + 16) = v110;
                *(_OWORD *)v76 = v103;
              }
              else
              {
                v81 = *(_OWORD *)a2;
                *(_QWORD *)(v76 + 16) = *(_QWORD *)(a2 + 16);
                *(_OWORD *)v76 = v81;
                *(_QWORD *)(a2 + 16) = v110;
                *(_OWORD *)a2 = v103;
                v82 = v76 - v8 + 24;
                if (v82 >= 25)
                {
                  v83 = (v82 / 0x18uLL - 2) >> 1;
                  v84 = v8 + 24 * v83;
                  v85 = *(double *)v76;
                  if (*(double *)v84 < *(double *)v76)
                  {
                    v95 = *(_OWORD *)(v76 + 8);
                    do
                    {
                      v86 = v76;
                      v76 = v84;
                      v87 = *(_OWORD *)v84;
                      *(_QWORD *)(v86 + 16) = *(_QWORD *)(v84 + 16);
                      *(_OWORD *)v86 = v87;
                      if (!v83)
                        break;
                      v83 = (v83 - 1) >> 1;
                      v84 = v8 + 24 * v83;
                    }
                    while (*(double *)v84 < v85);
                    *(double *)v76 = v85;
                    *(_OWORD *)(v76 + 8) = v95;
                  }
                }
              }
            }
            while (v74-- > 2);
          }
          return;
        }
        v11 = (unint64_t)v10 >> 1;
        v12 = v8 + 24 * ((unint64_t)v10 >> 1);
        if ((unint64_t)v9 < 0xC01)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>((__int128 *)(a1 + 24 * v11), (__int128 *)a1, (__int128 *)(a2 - 24));
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>((__int128 *)a1, (__int128 *)(a1 + 24 * v11), (__int128 *)(a2 - 24));
          v13 = 3 * v11;
          v14 = (__int128 *)(a1 + 24 * v11 - 24);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>((__int128 *)(a1 + 24), v14, (__int128 *)(a2 - 48));
          v15 = (__int128 *)(a1 + 24 + 8 * v13);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>((__int128 *)(a1 + 48), v15, (__int128 *)(a2 - 72));
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>(v14, (__int128 *)v12, v15);
          v105 = *(_QWORD *)(a1 + 16);
          v96 = *(_OWORD *)a1;
          v16 = *(_QWORD *)(v12 + 16);
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_QWORD *)(a1 + 16) = v16;
          *(_QWORD *)(v12 + 16) = v105;
          *(_OWORD *)v12 = v96;
        }
        --a3;
        v17 = *(double *)a1;
        if ((a4 & 1) == 0 && *(double *)(a1 - 24) >= v17)
        {
          v94 = *(_OWORD *)(a1 + 8);
          if (v17 >= *(double *)(a2 - 24))
          {
            v31 = a1 + 24;
            do
            {
              v8 = v31;
              if (v31 >= a2)
                break;
              v31 += 24;
            }
            while (v17 >= *(double *)v8);
          }
          else
          {
            v8 = a1;
            do
            {
              v30 = *(double *)(v8 + 24);
              v8 += 24;
            }
            while (v17 >= v30);
          }
          v32 = a2;
          if (v8 < a2)
          {
            v32 = a2;
            do
            {
              v33 = *(double *)(v32 - 24);
              v32 -= 24;
            }
            while (v17 < v33);
          }
          while (v8 < v32)
          {
            v107 = *(_QWORD *)(v8 + 16);
            v98 = *(_OWORD *)v8;
            v34 = *(_OWORD *)v32;
            *(_QWORD *)(v8 + 16) = *(_QWORD *)(v32 + 16);
            *(_OWORD *)v8 = v34;
            *(_QWORD *)(v32 + 16) = v107;
            *(_OWORD *)v32 = v98;
            do
            {
              v35 = *(double *)(v8 + 24);
              v8 += 24;
            }
            while (v17 >= v35);
            do
            {
              v36 = *(double *)(v32 - 24);
              v32 -= 24;
            }
            while (v17 < v36);
          }
          if (v8 - 24 != a1)
          {
            v37 = *(_OWORD *)(v8 - 24);
            *(_QWORD *)(a1 + 16) = *(_QWORD *)(v8 - 8);
            *(_OWORD *)a1 = v37;
          }
          a4 = 0;
          *(double *)(v8 - 24) = v17;
          *(_OWORD *)(v8 - 16) = v94;
          continue;
        }
        v18 = 0;
        v93 = *(_OWORD *)(a1 + 8);
        do
        {
          v19 = *(double *)(a1 + v18 + 24);
          v18 += 24;
        }
        while (v19 < v17);
        v20 = a1 + v18;
        v21 = a2;
        if (v18 == 24)
        {
          v21 = a2;
          do
          {
            if (v20 >= v21)
              break;
            v23 = *(double *)(v21 - 24);
            v21 -= 24;
          }
          while (v23 >= v17);
        }
        else
        {
          do
          {
            v22 = *(double *)(v21 - 24);
            v21 -= 24;
          }
          while (v22 >= v17);
        }
        v8 = a1 + v18;
        if (v20 < v21)
        {
          v24 = v21;
          do
          {
            v106 = *(_QWORD *)(v8 + 16);
            v97 = *(_OWORD *)v8;
            v25 = *(_OWORD *)v24;
            *(_QWORD *)(v8 + 16) = *(_QWORD *)(v24 + 16);
            *(_OWORD *)v8 = v25;
            *(_QWORD *)(v24 + 16) = v106;
            *(_OWORD *)v24 = v97;
            do
            {
              v26 = *(double *)(v8 + 24);
              v8 += 24;
            }
            while (v26 < v17);
            do
            {
              v27 = *(double *)(v24 - 24);
              v24 -= 24;
            }
            while (v27 >= v17);
          }
          while (v8 < v24);
        }
        if (v8 - 24 != a1)
        {
          v28 = *(_OWORD *)(v8 - 24);
          *(_QWORD *)(a1 + 16) = *(_QWORD *)(v8 - 8);
          *(_OWORD *)a1 = v28;
        }
        *(double *)(v8 - 24) = v17;
        *(_OWORD *)(v8 - 16) = v93;
        if (v20 < v21)
        {
LABEL_29:
          std::__introsort<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*,false>(a1, v8 - 24, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v29 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>(a1, v8 - 24);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Path::ClipStroke::make_keyframes(std::span<RB::Path::ClipStroke::Keyframe const,18446744073709551615ul>,RB::Path::ClipStroke::Subpath const&,RB::vector<RB::Path::ClipStroke::SingleKeyframe,0ul,unsigned long> &,double &)::$_0 &,RB::Path::ClipStroke::SingleKeyframe*>(v8, a2))
        {
          if (v29)
            continue;
          goto LABEL_29;
        }
        a2 = v8 - 24;
        if (!v29)
          goto LABEL_1;
        return;
    }
  }
}

  v8 = a1;
  while (2)
  {
    a1 = v8;
    v9 = (char *)a2 - (char *)v8;
    v10 = ((char *)a2 - (char *)v8) >> 4;
    switch(v10)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        if (*(a2 - 3) < v8[1])
        {
          v91 = *(_OWORD *)v8;
          *(_OWORD *)v8 = *((_OWORD *)a2 - 1);
          *((_OWORD *)a2 - 1) = v91;
        }
        return;
      case 3uLL:
        std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(v8, v8 + 4, a2 - 4);
        return;
      case 4uLL:
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(v8, (uint64_t)(v8 + 4), (uint64_t)(v8 + 8), (uint64_t)(a2 - 4));
        return;
      case 5uLL:
        v39 = (__int128 *)(v8 + 4);
        v40 = (__int128 *)(v8 + 8);
        v41 = (__int128 *)(v8 + 12);
        std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(v8, (uint64_t)(v8 + 4), (uint64_t)(v8 + 8), (uint64_t)(v8 + 12));
        if (*(a2 - 3) < v8[13])
        {
          v42 = *v41;
          *v41 = *((_OWORD *)a2 - 1);
          *((_OWORD *)a2 - 1) = v42;
          if (v8[13] < v8[9])
          {
            v43 = *v40;
            *v40 = *v41;
            *v41 = v43;
            if (v8[9] < v8[5])
            {
              v44 = *v39;
              *v39 = *v40;
              *v40 = v44;
              if (v8[5] < v8[1])
              {
                v92 = *(_OWORD *)v8;
                *(_OWORD *)v8 = *v39;
                *v39 = v92;
              }
            }
          }
        }
        return;
      default:
        if (v9 <= 383)
        {
          v45 = v8 + 4;
          v47 = v8 == a2 || v45 == a2;
          if ((a4 & 1) != 0)
          {
            if (!v47)
            {
              v48 = 0;
              v49 = v8;
              do
              {
                v50 = v45;
                v51 = v49[5];
                if (v51 < v49[1])
                {
                  v52 = *(_DWORD *)v45;
                  v53 = *((_QWORD *)v49 + 3);
                  v54 = v48;
                  while (1)
                  {
                    *(_OWORD *)((char *)v8 + v54 + 16) = *(_OWORD *)((char *)v8 + v54);
                    if (!v54)
                      break;
                    v55 = *(float *)((char *)v8 + v54 - 12);
                    v54 -= 16;
                    if (v51 >= v55)
                    {
                      v56 = (uint64_t)v8 + v54 + 16;
                      goto LABEL_79;
                    }
                  }
                  v56 = (uint64_t)v8;
LABEL_79:
                  *(_DWORD *)v56 = v52;
                  *(float *)(v56 + 4) = v51;
                  *(_QWORD *)(v56 + 8) = v53;
                }
                v45 = v50 + 4;
                v48 += 16;
                v49 = v50;
              }
              while (v50 + 4 != a2);
            }
          }
          else if (!v47)
          {
            do
            {
              v82 = v45;
              v83 = a1[5];
              if (v83 < a1[1])
              {
                v84 = *(_DWORD *)v45;
                v85 = *((_QWORD *)a1 + 3);
                v86 = v82;
                do
                {
                  *(_OWORD *)v86 = *((_OWORD *)v86 - 1);
                  v87 = *(v86 - 7);
                  v86 -= 4;
                }
                while (v83 < v87);
                *(_DWORD *)v86 = v84;
                v86[1] = v83;
                *((_QWORD *)v86 + 1) = v85;
              }
              v45 = v82 + 4;
              a1 = v82;
            }
            while (v82 + 4 != a2);
          }
          return;
        }
        if (!a3)
        {
          if (v8 != a2)
          {
            v57 = (v10 - 2) >> 1;
            v58 = v57;
            do
            {
              v59 = v58;
              if (v57 >= v58)
              {
                v60 = (2 * v58) | 1;
                v61 = &v8[4 * v60];
                if (2 * v59 + 2 < (uint64_t)v10 && v61[1] < v61[5])
                {
                  v61 += 4;
                  v60 = 2 * v59 + 2;
                }
                v62 = v8[4 * v59 + 1];
                if (v61[1] >= v62)
                {
                  v63 = &v8[4 * v59];
                  v64 = *(_DWORD *)v63;
                  v65 = *((_QWORD *)v63 + 1);
                  do
                  {
                    v66 = v63;
                    v63 = v61;
                    *(_OWORD *)v66 = *(_OWORD *)v61;
                    if (v57 < v60)
                      break;
                    v67 = 2 * v60;
                    v60 = (2 * v60) | 1;
                    v61 = &v8[4 * v60];
                    v68 = v67 + 2;
                    if (v68 < (uint64_t)v10 && v61[1] < v61[5])
                    {
                      v61 += 4;
                      v60 = v68;
                    }
                  }
                  while (v61[1] >= v62);
                  *(_DWORD *)v63 = v64;
                  v63[1] = v62;
                  *((_QWORD *)v63 + 1) = v65;
                }
              }
              v58 = v59 - 1;
            }
            while (v59);
            v69 = (unint64_t)v9 >> 4;
            do
            {
              v70 = 0;
              v93 = *(_OWORD *)v8;
              v71 = v8;
              do
              {
                v72 = v71;
                v71 += 4 * v70 + 4;
                v73 = 2 * v70;
                v70 = (2 * v70) | 1;
                v74 = v73 + 2;
                if (v74 < v69 && v71[1] < v71[5])
                {
                  v71 += 4;
                  v70 = v74;
                }
                *(_OWORD *)v72 = *(_OWORD *)v71;
              }
              while (v70 <= (uint64_t)((unint64_t)(v69 - 2) >> 1));
              a2 -= 4;
              if (v71 == a2)
              {
                *(_OWORD *)v71 = v93;
              }
              else
              {
                *(_OWORD *)v71 = *(_OWORD *)a2;
                *(_OWORD *)a2 = v93;
                v75 = (char *)v71 - (char *)v8 + 16;
                if (v75 >= 17)
                {
                  v76 = (((unint64_t)v75 >> 4) - 2) >> 1;
                  v77 = v71[1];
                  if (v8[4 * v76 + 1] < v77)
                  {
                    v78 = *(_DWORD *)v71;
                    v79 = *((_QWORD *)v71 + 1);
                    do
                    {
                      v80 = v71;
                      v71 = &v8[4 * v76];
                      *(_OWORD *)v80 = *(_OWORD *)v71;
                      if (!v76)
                        break;
                      v76 = (v76 - 1) >> 1;
                    }
                    while (v8[4 * v76 + 1] < v77);
                    *(_DWORD *)v71 = v78;
                    v71[1] = v77;
                    *((_QWORD *)v71 + 1) = v79;
                  }
                }
              }
            }
            while (v69-- > 2);
          }
          return;
        }
        v11 = v10 >> 1;
        v12 = &v8[4 * (v10 >> 1)];
        if ((unint64_t)v9 < 0x801)
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(&a1[4 * (v10 >> 1)], a1, a2 - 4);
        }
        else
        {
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(a1, &a1[4 * (v10 >> 1)], a2 - 4);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(a1 + 4, v12 - 4, a2 - 8);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(a1 + 8, &a1[4 * v11 + 4], a2 - 12);
          std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(v12 - 4, v12, &a1[4 * v11 + 4]);
          v88 = *(_OWORD *)a1;
          *(_OWORD *)a1 = *(_OWORD *)v12;
          *(_OWORD *)v12 = v88;
        }
        --a3;
        if ((a4 & 1) == 0)
        {
          v13 = a1[1];
          if (*(a1 - 3) < v13)
            goto LABEL_11;
          if (v13 >= *(a2 - 3))
          {
            v30 = a1 + 4;
            do
            {
              v8 = v30;
              if (v30 >= a2)
                break;
              v31 = v30[1];
              v30 += 4;
            }
            while (v13 >= v31);
          }
          else
          {
            v28 = a1;
            do
            {
              v8 = v28 + 4;
              v29 = v28[5];
              v28 += 4;
            }
            while (v13 >= v29);
          }
          v32 = a2;
          if (v8 < a2)
          {
            v33 = a2;
            do
            {
              v32 = v33 - 4;
              v34 = *(v33 - 3);
              v33 -= 4;
            }
            while (v13 < v34);
          }
          v35 = *a1;
          v36 = *((_QWORD *)a1 + 1);
          while (v8 < v32)
          {
            v90 = *(_OWORD *)v8;
            *(_OWORD *)v8 = *(_OWORD *)v32;
            *(_OWORD *)v32 = v90;
            do
            {
              v37 = v8[5];
              v8 += 4;
            }
            while (v13 >= v37);
            do
            {
              v38 = *(v32 - 3);
              v32 -= 4;
            }
            while (v13 < v38);
          }
          if (v8 - 4 != a1)
            *(_OWORD *)a1 = *((_OWORD *)v8 - 1);
          a4 = 0;
          *(v8 - 4) = v35;
          *(v8 - 3) = v13;
          *((_QWORD *)v8 - 1) = v36;
          continue;
        }
        v13 = a1[1];
LABEL_11:
        v14 = 0;
        v15 = *a1;
        v16 = *((_QWORD *)a1 + 1);
        do
        {
          v17 = a1[v14 + 5];
          v14 += 4;
        }
        while (v17 < v13);
        v18 = &a1[v14];
        v19 = a2;
        if (v14 == 4)
        {
          v22 = a2;
          while (v18 < v22)
          {
            v20 = v22 - 4;
            v23 = *(v22 - 3);
            v22 -= 4;
            if (v23 < v13)
              goto LABEL_21;
          }
          v20 = v22;
        }
        else
        {
          do
          {
            v20 = v19 - 4;
            v21 = *(v19 - 3);
            v19 -= 4;
          }
          while (v21 >= v13);
        }
LABEL_21:
        v8 = v18;
        if (v18 < v20)
        {
          v24 = v20;
          do
          {
            v89 = *(_OWORD *)v8;
            *(_OWORD *)v8 = *(_OWORD *)v24;
            *(_OWORD *)v24 = v89;
            do
            {
              v25 = v8[5];
              v8 += 4;
            }
            while (v25 < v13);
            do
            {
              v26 = *(v24 - 3);
              v24 -= 4;
            }
            while (v26 >= v13);
          }
          while (v8 < v24);
        }
        if (v8 - 4 != a1)
          *(_OWORD *)a1 = *((_OWORD *)v8 - 1);
        *(v8 - 4) = v15;
        *(v8 - 3) = v13;
        *((_QWORD *)v8 - 1) = v16;
        if (v18 < v20)
        {
LABEL_32:
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *,false>(a1, v8 - 4, a3, a4 & 1);
          a4 = 0;
          continue;
        }
        v27 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(a1, v8 - 4);
        if (!std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::DisplayList::EditAdaptor::finalize_group(RB::DisplayList::Interpolator::Layer &,RB::Transition::Method,unsigned int,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int,RB::DisplayList::EditAdaptor::Element *,unsigned int)::SequenceElement *>(v8, a2))
        {
          if (v27)
            continue;
          goto LABEL_32;
        }
        a2 = v8 - 4;
        if (!v27)
          goto LABEL_1;
        return;
    }
  }
}

void RB::Path::Flattener::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  double v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  double v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  uint32x2_t v20;
  uint32x2_t v21;
  float32x2_t v22;
  uint32x2_t v23;
  float32x2_t v24;
  float v25;
  uint32x2_t v28;
  uint64_t v29;
  float32x2_t v30;

  v10 = *(double *)(a1 + 80);
  v11 = vcvt_f32_f64(a2);
  v12 = vcvt_f32_f64(a3);
  v13 = vcvt_f32_f64(a4);
  *(float32x2_t *)(a1 + 80) = v13;
  v14 = COERCE_DOUBLE(vminnm_f32(*(float32x2_t *)&v10, v13));
  v15 = vmaxnm_f32(*(float32x2_t *)&v10, v13);
  *(float32x2_t *)a8.i8 = vminnm_f32(v11, v12);
  *(float32x2_t *)a9.i8 = vmaxnm_f32(v11, v12);
  v16 = vminnm_f32(*(float32x2_t *)&v14, *(float32x2_t *)a8.i8);
  v17 = vmaxnm_f32(v15, *(float32x2_t *)a9.i8);
  v19 = *(float32x2_t *)(a1 + 24);
  v18 = *(float32x2_t *)(a1 + 32);
  v20 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v19, v17), (int8x8_t)vcgt_f32(v16, v18));
  if ((vpmax_u32(v20, v20).u32[0] & 0x80000000) != 0)
  {
    v30 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v17);
    *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), v16);
    *(float32x2_t *)(a1 + 64) = v30;
LABEL_17:
    RB::Path::Flattener::push_cropped(a1, v10, v13);
    return;
  }
  *(int32x2_t *)a7.i8 = vcge_f32(v15, *(float32x2_t *)a9.i8);
  v21 = (uint32x2_t)vand_s8(*(int8x8_t *)a7.i8, (int8x8_t)vcge_f32(*(float32x2_t *)a8.i8, *(float32x2_t *)&v14));
  *(uint32x2_t *)a6.i8 = vpmin_u32(v21, v21);
  if ((a6.i32[0] & 0x80000000) == 0)
  {
    v14 = RB::Path::cubic_bounds_slow(*(float32x2_t *)&v10, v11, v12, v13, a6, a7, a8, a9);
    v19 = *(float32x2_t *)(a1 + 24);
    v18 = *(float32x2_t *)(a1 + 32);
  }
  v22 = vmaxnm_f32(*(float32x2_t *)(a1 + 64), v15);
  *(float32x2_t *)(a1 + 56) = vminnm_f32(*(float32x2_t *)(a1 + 56), *(float32x2_t *)&v14);
  *(float32x2_t *)(a1 + 64) = v22;
  v23 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(v19, v15), (int8x8_t)vcgt_f32(*(float32x2_t *)&v14, v18));
  if ((vpmax_u32(v23, v23).u32[0] & 0x80000000) != 0)
    goto LABEL_17;
  v24 = vmaxnm_f32(vabs_f32(vadd_f32(vsub_f32(v12, vadd_f32(v11, v11)), *(float32x2_t *)&v10)), vabs_f32(vadd_f32(vsub_f32(v11, vadd_f32(v12, v12)), v13)));
  v25 = ceilf(sqrtf(sqrtf(vaddv_f32(vmul_f32(v24, v24))) * *(float *)(a1 + 16)));
  if (v25 >= 0.0 && ((LODWORD(v25) & 0x7FFFFFFFu) - 0x800000) >> 24 <= 0x7E || LODWORD(v25) == 0)
  {
    if (v25 >= 1.0)
    {
      if (v25 > 1024.0)
        v25 = 1024.0;
      v29 = (int)v25;
    }
    else
    {
      v28 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v10, v13);
      if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0)
        return;
      v29 = 1;
    }
    (*(void (**)(_QWORD, uint64_t, double, double, double, double))(**(_QWORD **)(a1 + 8) + 40))(*(_QWORD *)(a1 + 8), v29, v10, *(double *)&v11, *(double *)&v12, *(double *)&v13);
    *(_BYTE *)(a1 + 88) = 0;
  }
}

uint64_t RB::Path::Flattener::lineto(uint64_t result, float64x2_t a2)
{
  double v3;
  float32x2_t v4;
  uint32x2_t v5;
  uint64_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  uint32x2_t v10;

  v3 = *(double *)(result + 80);
  v4 = vcvt_f32_f64(a2);
  *(float32x2_t *)(result + 80) = v4;
  v5 = (uint32x2_t)vceq_f32(*(float32x2_t *)&v3, v4);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    v6 = result;
    v7 = vminnm_f32(*(float32x2_t *)&v3, v4);
    v8 = vmaxnm_f32(*(float32x2_t *)&v3, v4);
    v9 = vmaxnm_f32(*(float32x2_t *)(result + 64), v8);
    *(float32x2_t *)(result + 56) = vminnm_f32(*(float32x2_t *)(result + 56), v7);
    *(float32x2_t *)(result + 64) = v9;
    v10 = (uint32x2_t)vorr_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(result + 24), v8), (int8x8_t)vcgt_f32(v7, *(float32x2_t *)(result + 32)));
    if ((vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0)
    {
      return RB::Path::Flattener::push_cropped(result, v3, v4);
    }
    else
    {
      result = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(result + 8) + 24))(*(_QWORD *)(result + 8));
      *(_BYTE *)(v6 + 88) = 0;
    }
  }
  return result;
}

_BYTE *RB::Path::Accumulator::push_back(_BYTE *this, unsigned int a2, float32x2_t a3, double a4, double a5, double a6)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  uint32x2_t v19;
  int32x2_t v20;
  unsigned int v21;

  v11 = (uint64_t)this;
  if (!this[280])
    goto LABEL_8;
  if (this[281] != 4
    || ((v12 = *((_QWORD *)this + 34), v13 = 32 * v12, v14 = *((_QWORD *)this + 31), v15 = *((_QWORD *)this + 32), v14)
      ? (v16 = (char *)*((_QWORD *)this + 31))
      : (v16 = this + 120),
        v17 = v15 - 1,
        (unint64_t)(32 * v12 + 64) > *(_QWORD *)&v16[32 * v15 - 16]))
  {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)this);
LABEL_8:
    *(_BYTE *)(v11 + 281) = 4;
    this = RB::Path::Accumulator::new_buffer((RB::RenderFrame **)v11);
    v12 = *(_QWORD *)(v11 + 272);
    v14 = *(_QWORD *)(v11 + 248);
    v17 = *(_QWORD *)(v11 + 256) - 1;
    v13 = 32 * v12;
  }
  if (!v14)
    v14 = v11 + 120;
  v18 = *(_QWORD *)(*(_QWORD *)(v14 + 32 * v17) + 56) + *(_QWORD *)(v14 + 32 * v17 + 8) + v13;
  if (!v12
    || (v19 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(v18 - 8), a3)),
        (vpmax_u32(v19, v19).u32[0] & 0x80000000) != 0))
  {
    *(_DWORD *)v18 = *(_DWORD *)(v11 + 296);
    *(_DWORD *)(v18 + 4) = 0;
    v20 = vdup_n_s32(0x7F800000u);
    *(int32x2_t *)(v18 + 8) = v20;
    *(int32x2_t *)(v18 + 16) = v20;
    *(double *)(v18 + 24) = *(double *)&a3;
    v18 += 32;
    ++*(_QWORD *)(v11 + 272);
  }
  *(_DWORD *)v18 = *(_DWORD *)(v11 + 296);
  *(float *)(v18 + 4) = 1.0 / (float)a2;
  *(double *)(v18 + 8) = a4;
  *(double *)(v18 + 16) = a5;
  *(double *)(v18 + 24) = a6;
  ++*(_QWORD *)(v11 + 272);
  *(_DWORD *)(v11 + 296) += a2;
  v21 = *(_DWORD *)(v11 + 304);
  if (v21 <= a2)
    v21 = a2;
  *(_DWORD *)(v11 + 304) = v21;
  return this;
}

uint64_t RB::Path::FlattenedConsumer::push_back(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, 1);
}

char *RB::Path::Accumulator::push_back(char *this, double a2, double a3)
{
  RB::RenderFrame **v5;
  RB::RenderFrame *v6;
  uint64_t v7;
  RB::RenderFrame *v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  int32x2_t *v12;
  double *v13;
  uint64_t v14;

  v5 = (RB::RenderFrame **)this;
  if (this[281] != 2)
    return (char *)RB::Path::FlattenedConsumer::push_back((uint64_t)this);
  if (!this[280])
    goto LABEL_8;
  v6 = (RB::RenderFrame *)*((_QWORD *)this + 34);
  v7 = 8 * (_QWORD)v6;
  v8 = (RB::RenderFrame *)*((_QWORD *)this + 31);
  v9 = *((_QWORD *)this + 32);
  if (v8)
    v10 = (char *)*((_QWORD *)this + 31);
  else
    v10 = this + 120;
  v11 = v9 - 1;
  if ((unint64_t)(8 * (_QWORD)v6 + 24) > *(_QWORD *)&v10[32 * v9 - 16])
  {
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)this);
LABEL_8:
    this = (char *)RB::Path::Accumulator::new_buffer(v5);
    v6 = v5[34];
    v8 = v5[31];
    v11 = (uint64_t)v5[32] - 1;
    v7 = 8 * (_QWORD)v6;
  }
  if (!v8)
    v8 = (RB::RenderFrame *)(v5 + 15);
  v12 = (int32x2_t *)(*(_QWORD *)(*((_QWORD *)v8 + 4 * v11) + 56) + *((_QWORD *)v8 + 4 * v11 + 1) + v7);
  if (!v6)
  {
    v14 = 1;
    v13 = (double *)v12;
    goto LABEL_16;
  }
  if (v5[36] == v6)
  {
    *v12 = vdup_n_s32(0x7F800000u);
    v13 = (double *)&v12[1];
    v14 = 2;
LABEL_16:
    v12 += v14;
    *v13 = a2;
    v5[34] = (RB::RenderFrame *)((char *)v5[34] + v14);
  }
  *(double *)v12 = a3;
  v5[34] = (RB::RenderFrame *)((char *)v5[34] + 1);
  return this;
}

void *RB::Path::Accumulator::new_buffer(RB::RenderFrame **this)
{
  void *result;
  uint64_t v3;
  RB::RenderFrame *v4;
  size_t v5;
  RB::RenderFrame *v6;
  char *v7;
  char v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;

  result = RB::RenderFrame::alloc_buffer_region(this[1], (RB::Device *)0x200, 0, 1, &v10);
  v3 = v10;
  if (v10)
  {
    v4 = this[32];
    v5 = (size_t)v4 + 1;
    if (this[33] < (RB::RenderFrame *)((char *)v4 + 1))
    {
      result = RB::vector<RB::Path::Buffer,4ul,unsigned long>::reserve_slow(this + 15, v5);
      v4 = this[32];
      v3 = v10;
      v5 = (size_t)v4 + 1;
    }
    v6 = this[31];
    if (!v6)
      v6 = (RB::RenderFrame *)(this + 15);
    v7 = (char *)v6 + 32 * (_QWORD)v4;
    v8 = *((_BYTE *)this + 281);
    *(_QWORD *)v7 = v3;
    *(_OWORD *)(v7 + 8) = v11;
    *((_DWORD *)v7 + 6) = 0;
    v7[28] = v8;
    this[32] = (RB::RenderFrame *)v5;
    if (this[36] == this[34])
      v9 = 0;
    else
      v9 = -1;
    this[36] = (RB::RenderFrame *)v9;
    this[37] = 0;
    this[34] = 0;
    *((_BYTE *)this + 280) = 1;
    *((_DWORD *)this + 76) = 0;
  }
  return result;
}

void sub_209ADAED0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::Presentation::shared(RB::Symbol::Presentation *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    v3 = operator new();
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v3 + 8) = 0;
    RB::Symbol::Presentation::shared(void)::shared = v3;
  }
  return RB::Symbol::Presentation::shared(void)::shared;
}

void sub_209ADAF9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RB::Symbol::Presentation::~Presentation(RB::Symbol::Presentation *this)
{
  _QWORD *v2;
  unint64_t v3;
  unint64_t i;
  RB::Symbol::Glyph::Layer *v5;
  uint64_t *v6;
  unint64_t v7;
  uint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  unsigned int *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  void *v16;
  char *v17;
  unint64_t v18;
  unsigned int **v19;
  unsigned int *v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;

  v2 = (_QWORD *)*((_QWORD *)this + 258);
  v3 = *((unsigned int *)this + 518);
  if ((_DWORD)v3)
  {
    for (i = 0; i < v3; ++i)
    {
      v5 = (RB::Symbol::Glyph::Layer *)v2[i];
      v2[i] = 0;
      if (v5)
      {
        RB::Symbol::Glyph::Layer::~Layer(v5);
        v3 = *((unsigned int *)this + 518);
      }
    }
    v2 = (_QWORD *)*((_QWORD *)this + 258);
  }
  if (v2)
    free(v2);
  v6 = (uint64_t *)*((_QWORD *)this + 256);
  if (*((_DWORD *)this + 514))
  {
    v7 = 0;
    v8 = v6 + 1;
    do
    {
      RBPathRelease(*(v8 - 1), *v8);
      ++v7;
      v8 += 2;
    }
    while (v7 < *((unsigned int *)this + 514));
    v6 = (uint64_t *)*((_QWORD *)this + 256);
  }
  if (v6)
    free(v6);
  v9 = (_QWORD *)*((_QWORD *)this + 254);
  if (*((_DWORD *)this + 510))
  {
    v10 = 0;
    do
    {
      v11 = (unsigned int *)v9[v10];
      if (v11)
      {
        v12 = v11 + 2;
        do
        {
          v13 = __ldxr(v12);
          v14 = v13 - 1;
        }
        while (__stlxr(v14, v12));
        if (!v14)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v11 + 8))(v11);
        }
      }
      ++v10;
    }
    while (v10 < *((unsigned int *)this + 510));
    v9 = (_QWORD *)*((_QWORD *)this + 254);
  }
  if (v9)
    free(v9);
  v15 = *((_QWORD *)this + 253);
  *((_QWORD *)this + 253) = 0;
  if (v15)
    std::default_delete<RB::vector<RB::Symbol::Presentation::KeyframeInfo,0ul,unsigned long>>::operator()[abi:nn180100]((uint64_t)this + 2024, v15);

  RB::Heap::~Heap((RB::Symbol::Presentation *)((char *)this + 944));
  v16 = (void *)*((_QWORD *)this + 105);
  if (v16)
    v17 = (char *)*((_QWORD *)this + 105);
  else
    v17 = (char *)this + 8;
  if (*((_DWORD *)this + 212))
  {
    v18 = 0;
    do
    {
      v19 = (unsigned int **)&v17[416 * v18];
      v19[49] = 0;
      v20 = v19[47];
      if (v20)
        free(v20);
      v21 = *(unsigned int **)&v17[416 * v18 + 8];
      if (v21)
      {
        v22 = v21 + 2;
        do
        {
          v23 = __ldxr(v22);
          v24 = v23 - 1;
        }
        while (__stlxr(v24, v22));
        if (!v24)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v21 + 8))(v21);
        }
      }
      v25 = *v19;
      if (*v19)
      {
        v26 = v25 + 2;
        do
        {
          v27 = __ldxr(v26);
          v28 = v27 - 1;
        }
        while (__stlxr(v28, v26));
        if (!v28)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v25 + 8))(v25);
        }
      }
      ++v18;
    }
    while (v18 < *((unsigned int *)this + 212));
    v16 = (void *)*((_QWORD *)this + 105);
  }
  if (v16)
    free(v16);
  v29 = *(unsigned int **)this;
  if (*(_QWORD *)this)
  {
    v30 = v29 + 2;
    do
    {
      v31 = __ldxr(v30);
      v32 = v31 - 1;
    }
    while (__stlxr(v32, v30));
    if (!v32)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v29 + 8))(v29);
    }
  }
}

uint64_t RB::Symbol::Animator::glyph(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = *(_QWORD *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 16);
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t RBPathIsEmpty(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  char v4;

  if ((_UNKNOWN *)a2 == &empty_path_callbacks)
    return 1;
  if ((*(_BYTE *)(a2 + 2) & 1) != 0)
  {
    v2 = *(uint64_t (**)(void))(a2 + 40);
    if (v2)
      return v2();
  }
  else
  {
    v2 = *(uint64_t (**)(void))(a2 + 40);
    if (v2)
      return v2();
  }
  v4 = 1;
  RBPathApplyElements(a1, a2, (uint64_t)&v4, (uint64_t)RBPathIsEmpty::$_0::__invoke<void *,RBPathElement,double const*,void const*>);
  return v4 != 0;
}

void RB::Device::RenderPipelineEntry::Loader::finished(RB::Device::RenderPipelineEntry::Loader *this)
{
  RB *v2;
  double v3;
  const char *v4;
  const char *v5;
  int v6;
  uint64_t v7;
  int v8;
  char v9[20];
  uint64_t v10;

  v10 = *MEMORY[0x24BDAC8D0];
  *((_BYTE *)this + 80) = 1;
  v2 = (RB *)RB::verbose_mode(this);
  if ((_DWORD)v2)
  {
    v3 = RB::current_time_seconds(v2) - *((double *)this + 9);
    if (*((_QWORD *)this + 8))
      v4 = "finished";
    else
      v4 = "failed";
    v5 = RB::RenderState::name((RB::Device::RenderPipelineEntry::Loader *)((char *)this + 16));
    v6 = *((_DWORD *)this + 6);
    v7 = *((_QWORD *)this + 2);
    v8 = v6;
    RB::FormattedRenderState::ID::formatted((uint64_t)&v7, (uint64_t)v9);
    printf("%s building render pipeline %s-%s (%.2f ms)\n", v4, v5, v9, v3 * 1000.0);
    fflush((FILE *)*MEMORY[0x24BDAC8E8]);
  }
  dispatch_async_f(*(dispatch_queue_t *)(*((_QWORD *)this + 1) + 40), this, (dispatch_function_t)RB::Device::RenderPipelineEntry::Loader::finished(void)::$_0::__invoke);
}

void RB::RenderQueue::encode(unsigned int *a1, uint64_t a2)
{
  int32x2_t v4;
  uint64_t v5;
  void *v6;
  int v7;
  int v8;
  int v9;
  int32x2_t v10;
  uint64_t v11;
  int v12;
  id *v13;
  id v14;
  id *v15;
  int32x2_t v16;
  int32x2_t *v17;
  int32x2_t *v18;
  int32x2_t v19;
  int32x2_t v20;
  uint32x2_t v21;
  uint32x2_t v22;
  __int128 v23;
  __int128 v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  int v32;
  _BOOL4 v33;
  int v34;
  unint64_t v35;
  double v36;
  __int128 v37;
  __int128 v38;
  void *v39;
  const char *v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  unsigned int *v44;
  _DWORD *v45;
  uint64_t v46;
  uint64_t v47;
  char v48;
  uint64_t v49;
  char v50;
  uint64_t v51;
  uint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unint64_t v56;
  _BYTE *v57;
  _BYTE *v58;
  uint64_t v59;
  unint64_t v60;
  char v61;
  uint64_t v62;
  MTLPixelFormat v63;
  int v64;
  uint64_t v65;
  uint64_t v66;
  BOOL v67;
  uint64_t v68;
  uint64_t v69;
  _BOOL4 v70;
  id v71;
  id v72;
  id *v73;
  _QWORD *v74;
  const char *v75;
  void *v76;
  uint64_t v77;
  id v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  int *v82;
  int v83;
  uint64_t v84;
  char v85;
  char v86;
  unint64_t v87;
  uint64_t v88;
  unint64_t v89;
  uint64_t v90;
  int32x2_t v91;
  uint32x2_t v92;
  uint32x2_t v93;
  __int128 v94;
  char *v95;
  _QWORD *v96;
  unint64_t v97;
  int v98;
  int v99;
  int v100;
  unsigned int *v101;
  int32x2_t *v102;
  uint64_t v103;
  __int128 v104;
  uint64_t v105;
  int v106;
  __int128 v107;
  uint64_t v108;
  int32x2_t v109;
  int32x2_t v110;
  __int128 v111;
  void *v112;
  _OWORD v113[3];
  _OWORD v114[2];
  uint64_t v115;
  int v116;
  id v117[3];
  void (*v118)(id, char *, char *);
  void (*v119)(id, char *, _QWORD);
  void (*v120)(id, char *, uint64_t);
  void (*v121)(id, char *);
  void (*v122)(id, char *, char *, uint64_t, uint64_t);
  void (*v123)(id, char *, uint64_t, _QWORD, uint64_t);
  void (*v124)(id, char *);
  void (*v125)(id, char *, char *, uint64_t, uint64_t);
  void (*v126)(id, char *, uint64_t, _QWORD, uint64_t);
  void (*v127)(id, char *, uint64_t, uint64_t);
  void (*v128)(id, char *, id, uint64_t);
  void (*v129)(id, char *, uint64_t, uint64_t);
  uint64_t v130;
  int v131;
  char v132[20];
  char __str[16];
  __int128 v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  __int128 v138;
  __int128 v139;
  __int128 v140;
  uint64_t v141;

  v141 = *MEMORY[0x24BDAC8D0];
  RB::DirectRenderCommandEncoder::reset(v117, **(void ***)(a2 + 40));
  v115 = *(_QWORD *)(a2 + 48);
  v116 = *(_DWORD *)(a2 + 56);
  LODWORD(v115) = v115 & 0xFFFFFFC0 | 0x26;
  v4 = *(int32x2_t *)(a2 + 64);
  v102 = (int32x2_t *)(a2 + 64);
  v138 = 0u;
  v139 = 0u;
  v140 = 0u;
  v136 = 0;
  v137 = 0;
  v135 = 0;
  if (*a1)
  {
    v5 = 0;
    v6 = 0;
    v103 = 0;
    v7 = 0;
    v106 = 0;
    v96 = (_QWORD *)(a2 + 112);
    v8 = *(unsigned __int8 *)(a2 + 131);
    v9 = -1;
    v98 = 1;
    v10 = vdup_n_s32(0xC0000001);
    v109 = 0;
    v101 = a1;
    while (1)
    {
      v108 = v5;
      v11 = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v5);
      if (v8)
      {
        v12 = v106;
        if ((*(_BYTE *)(*(_QWORD *)a2 + 292) & 4) != 0)
        {
          objc_msgSend(**(id **)(a2 + 40), "endEncoding");
          v13 = *(id **)(a2 + 40);

          *v13 = 0;
          objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "colorAttachments"), "objectAtIndexedSubscript:", 1), "setLoadAction:", 1);
          if (*(_BYTE *)(a2 + 130))
            objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "colorAttachments"), "objectAtIndexedSubscript:", 2), "setLoadAction:", 1);
          if (*(_BYTE *)(a2 + 128))
            objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "stencilAttachment"), "setLoadAction:", 1);
          if (*(_BYTE *)(a2 + 129))
            objc_msgSend((id)objc_msgSend(*(id *)(a2 + 24), "depthAttachment"), "setLoadAction:", 1);
          v14 = (id)objc_msgSend(*(id *)(a2 + 16), "renderCommandEncoderWithDescriptor:", *(_QWORD *)(a2 + 24));
          v15 = *(id **)(a2 + 40);
          if (*v15 != v14)
          {

            *v15 = v14;
            v14 = **(id **)(a2 + 40);
          }
          RB::DirectRenderCommandEncoder::reset(v117, v14);
          if (*(_QWORD *)(a2 + 32))
            objc_msgSend(**(id **)(a2 + 40), "setLabel:");
          v12 = 0;
          v7 = 0;
          v103 = 0;
          LODWORD(v115) = v115 & 0xFFFFFFC0 | 0x26;
          v4 = *(int32x2_t *)(a2 + 64);
          v138 = 0u;
          v139 = 0u;
          v140 = 0u;
          v136 = 0;
          v137 = 0;
          v135 = 0;
          *(_BYTE *)(a2 + 131) = 0;
          v109 = 0;
          v98 = 1;
          v9 = -1;
        }
      }
      else
      {
        v12 = v106;
      }
      if ((*(_BYTE *)(v11 + 48) & 1) != 0)
      {
        v18 = (int32x2_t *)((v11 + 56) & 0xFFFFFFFFFFFFFFF8);
        v19 = *v18;
        v17 = v18 + 1;
        v16 = v19;
      }
      else
      {
        v16 = 0;
        v17 = (int32x2_t *)(a2 + 64);
      }
      v20 = *v17;
      v21 = (uint32x2_t)vceq_s32(v16, v109);
      if ((vpmin_u32(v21, v21).u32[0] & 0x80000000) == 0
        || (v22 = (uint32x2_t)vceq_s32(v20, v4), (vpmin_u32(v22, v22).u32[0] & 0x80000000) == 0))
      {
        *(_QWORD *)&v23 = v16.i32[0];
        *((_QWORD *)&v23 + 1) = v16.i32[1];
        v24 = v23;
        v110 = v16;
        *(_QWORD *)&v23 = v20.i32[0];
        *((_QWORD *)&v23 + 1) = v20.i32[1];
        *(_OWORD *)__str = v24;
        v134 = v23;
        v118(v117[0], sel_setScissorRect_, __str);
        v4 = v20;
        v109 = v110;
      }
      v25 = *(unsigned __int8 *)(v11 + 45);
      v26 = *(unsigned __int8 *)(v11 + 43);
      if (v25 != v7 || v26 != v12)
      {
        v27 = RB::Device::depth_stencil_state(*(_QWORD *)a2, v25, v26);
        v120(v117[0], sel_setDepthStencilState_, v27);
        v7 = *(unsigned __int8 *)(v11 + 45);
        v12 = *(unsigned __int8 *)(v11 + 43);
      }
      if ((_BYTE)v12 && v9 != *(unsigned __int8 *)(v11 + 44))
      {
        v121(v117[0], sel_setStencilReferenceValue_);
        v9 = *(unsigned __int8 *)(v11 + 44);
      }
      if ((*(_DWORD *)v11 & 0x3F) != 0x26)
        break;
      v28 = v11 + 49;
      if ((*(_BYTE *)(v11 + 48) & 1) != 0)
        v28 = ((v11 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
      v29 = v28 + 12 * *(unsigned __int8 *)(v11 + 47) + 8 * *(unsigned __int8 *)(v11 + 46);
      v30 = *(_QWORD *)v29;
      v111 = *(_OWORD *)(v29 + 16);
      v104 = *(_OWORD *)(v29 + 48);
      v107 = *(_OWORD *)(v29 + 32);
      v31 = *(_DWORD *)(v29 + 64);
      v32 = *(_DWORD *)(v29 + 68);
      v33 = (*(_BYTE *)(a2 + 72) & 1) == 0;
      v34 = *(_DWORD *)(v11 + 4);
      if ((*(_DWORD *)(a2 + 56) & 0x100000) != 0)
        v35 = 16777619
            * ((16777619
              * ((16777619 * (*(_DWORD *)(a2 + 56) & 0x3FF ^ 0x811C9DC5)) ^ ((unint64_t)*(unsigned int *)(a2 + 56) >> 10) & 0x3FF)) ^ 0x41);
      else
        v35 = 16777619
            * ((16777619 * (*(_DWORD *)(a2 + 56) & 0x3FF ^ 0x811C9DC5)) ^ ((unint64_t)*(unsigned int *)(a2 + 56) >> 10) & 0x3FF);
      if (!v6)
      {
        v6 = (void *)objc_opt_new();

      }
      objc_msgSend(v6, "setFlags:", v33 & 0xFFFFFFFD | (2 * (v34 & 1)));
      objc_msgSend(v6, "setBlendMode:", rb_blend_mode((*(_DWORD *)v11 >> 6) & 0x3F));
      LODWORD(v36) = v31;
      objc_msgSend(v6, "setAlpha:", v36);
      objc_msgSend(v6, "setCommandBuffer:", *(_QWORD *)(a2 + 16));
      objc_msgSend(v6, "setDescriptor:", *(_QWORD *)(a2 + 24));
      objc_msgSend(v6, "setFormatKey:", v35);
      objc_msgSend(v6, "setEncoder:", **(_QWORD **)(a2 + 40));
      objc_msgSend(v6, "setSize:", (double)v102->i32[0], (double)(int)HIDWORD(*(unint64_t *)v102));
      *(_QWORD *)&v37 = v109.u32[0];
      *((_QWORD *)&v37 + 1) = v109.u32[1];
      v38 = v37;
      *(_QWORD *)&v37 = v4.u32[0];
      *((_QWORD *)&v37 + 1) = v4.u32[1];
      v114[0] = v38;
      v114[1] = v37;
      objc_msgSend(v6, "setBounds:", v114);
      v113[0] = v111;
      v113[1] = v107;
      v113[2] = v104;
      v39 = (void *)MEMORY[0x20BD168EC](objc_msgSend(v6, "setCTM:", v113));
      (*(void (**)(uint64_t, void *))(v30 + 16))(v30, v6);
      if ((v32 & 8) != 0)
      {
        if (!objc_msgSend(v6, "encoder"))
        {
          v95 = "drawing op didn't return render pass encoder";
LABEL_148:
          RB::precondition_failure((RB *)v95, v40);
        }
        v72 = (id)objc_msgSend(v6, "encoder");
        v73 = *(id **)(a2 + 40);
        if (*v73 != v72)
        {

          *v73 = v72;
          v72 = **(id **)(a2 + 40);
        }
        RB::DirectRenderCommandEncoder::reset(v117, v72);
      }
      else if (objc_msgSend(v6, "encoder") != **(_QWORD **)(a2 + 40))
      {
        v95 = "drawing op changed render pass encoder";
        goto LABEL_148;
      }
      objc_autoreleasePoolPop(v39);
      v9 = 0;
      v103 = 0;
      v138 = 0u;
      v139 = 0u;
      v140 = 0u;
      v136 = 0;
      v137 = 0;
      v135 = 0;
      LODWORD(v115) = v115 & 0xFFFFFFC0 | 0x26;
      v98 = 1;
      v4 = (int32x2_t)0x8000000080000000;
      v7 = 3;
      v106 = 8;
      v109 = v10;
LABEL_113:
      v8 = (*(_BYTE *)(a2 + 131) | *(_BYTE *)(v11 + 41));
      *(_BYTE *)(a2 + 131) |= *(_BYTE *)(v11 + 41);
      v5 = v108 + 1;
      a1 = v101;
      if (v108 + 1 >= (unint64_t)*v101)
        goto LABEL_139;
    }
    v106 = v12;
    v99 = v9;
    v100 = v7;
    v41 = *(unsigned __int8 *)(v11 + 47);
    v112 = v6;
    if (*(_BYTE *)(v11 + 47))
    {
      v42 = 0;
      v43 = v11 + 49;
      if ((*(_BYTE *)(v11 + 48) & 1) != 0)
        v43 = ((v11 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
      v44 = (unsigned int *)(v43 + 4);
      v45 = (_DWORD *)&v138 + 1;
      do
      {
        v46 = *(v44 - 1);
        if ((_DWORD)v46)
        {
          if ((_DWORD)v46 == *(v45 - 1))
          {
            v47 = *v44;
            if (v47 != *v45)
            {
              v48 = RB::RenderQueue::encode(RB::RenderQueue::EncoderState &)::buffer_masks[v42];
              if ((v48 & 1) != 0)
              {
                v124(v117[0], sel_setVertexBufferOffset_atIndex_);
                v47 = *v44;
              }
              if ((v48 & 2) != 0)
              {
                v127(v117[0], sel_setFragmentBufferOffset_atIndex_, v47, v42);
                LODWORD(v47) = *v44;
              }
              *v45 = v47;
            }
          }
          else
          {
            v49 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 8 * v46 + 24);
            v50 = RB::RenderQueue::encode(RB::RenderQueue::EncoderState &)::buffer_masks[v42];
            if ((v50 & 1) != 0)
            {
              if (v49)
                v51 = *(_QWORD *)(v49 + 16);
              else
                v51 = 0;
              v123(v117[0], sel_setVertexBuffer_offset_atIndex_, v51, *v44, v42);
            }
            if ((v50 & 2) != 0)
            {
              if (v49)
                v52 = *(_QWORD *)(v49 + 16);
              else
                v52 = 0;
              v126(v117[0], sel_setFragmentBuffer_offset_atIndex_, v52, *v44, v42);
            }
            *(_QWORD *)(v45 - 1) = *(_QWORD *)(v44 - 1);
            v45[1] = v44[1];
          }
        }
        ++v42;
        v45 += 3;
        v44 += 3;
      }
      while (v41 != v42);
    }
    v105 = *(_QWORD *)v11;
    v53 = *(unsigned int *)(a2 + 56);
    v54 = *(unsigned __int8 *)(v11 + 46);
    if (*(_BYTE *)(v11 + 46))
    {
      v55 = 0;
      v56 = v11 + 49;
      if ((*(_BYTE *)(v11 + 48) & 1) != 0)
        v56 = ((v11 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
      v57 = (_BYTE *)(v56 + 12 * *(unsigned __int8 *)(v11 + 47) + 4);
      v58 = (char *)&v135 + 4;
      while (1)
      {
        v59 = *((unsigned int *)v57 - 1);
        if (!(_DWORD)v59)
          goto LABEL_82;
        v60 = *(_QWORD *)(*(_QWORD *)(a2 + 80) + 8 * v59 + 24) & 0xFFFFFFFFFFFFFFFELL;
        if (!v60)
          goto LABEL_82;
        if (!v55)
          break;
        if (v55 == 1)
        {
          v61 = 24;
          v62 = 4278190079;
LABEL_74:
          v53 = ((((unint64_t)*(unsigned __int8 *)(v60 + 77) >> 2) & 1) << v61) | v53 & v62;
        }
        if ((_DWORD)v59 != *((_DWORD *)v58 - 1))
        {
          v128(v117[0], sel_setFragmentTexture_atIndex_, *(id *)(v60 + 16), v55);
          v64 = 0;
          *v58 = 0;
          v63 = (unint64_t)*v57;
LABEL_79:
          if ((_DWORD)v63 != v64)
          {
            v65 = RB::Device::sampler_state(*(_QWORD *)a2, v63, v60);
            v129(v117[0], sel_setFragmentSamplerState_atIndex_, v65, v55);
            LOBYTE(v64) = *v57;
          }
          *((_DWORD *)v58 - 1) = *((_DWORD *)v57 - 1);
          *v58 = v64;
          goto LABEL_82;
        }
        v63 = (unint64_t)*v57;
        v64 = *v58;
        if ((_DWORD)v63 != v64)
          goto LABEL_79;
LABEL_82:
        ++v55;
        v57 += 8;
        v58 += 8;
        if (v54 == v55)
          goto LABEL_83;
      }
      v61 = 23;
      v62 = 4286578687;
      goto LABEL_74;
    }
LABEL_83:
    v66 = v105;
    v67 = (_DWORD)v115 == (_DWORD)v105 && HIDWORD(v115) == HIDWORD(v105);
    v9 = v99;
    if (v67 && ((v116 ^ v53) & 0xFBFFFFFF) == 0)
    {
      v70 = 0;
      v7 = v100;
LABEL_92:
      v6 = v112;
      if (!(_DWORD)v103)
      {
        if (RB::RenderState::reads_noise((RB::RenderState *)v11))
        {
          v71 = RB::Device::noise_texture(*(RB::Device **)a2);
          v128(v117[0], sel_setFragmentTexture_atIndex_, v71, 3);
          LODWORD(v103) = 1;
        }
        else
        {
          LODWORD(v103) = 0;
        }
      }
      if (!HIDWORD(v103))
      {
        if (RB::RenderState::reads_tables((RB::RenderState *)v11, (*(_BYTE *)(a2 + 72) & 1) == 0))
        {
          v74 = RB::Device::tables_buffer(*(id **)a2);
          v126(v117[0], sel_setFragmentBuffer_offset_atIndex_, v74[2], 0, 4);
          HIDWORD(v103) = 1;
        }
        else
        {
          HIDWORD(v103) = 0;
        }
      }
      if ((*(_BYTE *)(*(_QWORD *)a2 + 292) & 1) != 0)
      {
        v130 = v66;
        v131 = v53;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v130, (uint64_t)v132);
        v75 = "";
        if (v70)
          v75 = "U/";
        snprintf(__str, 0x100uLL, "Draw [%d] %s%s P:%d,%ux%u@%u S:%d,%u D:%d T:%d B:%d", v108, v75, v132, *(unsigned __int8 *)(v11 + 42), *(_DWORD *)(v11 + 32), *(_DWORD *)(v11 + 28), *(_DWORD *)(v11 + 24), *(unsigned __int8 *)(v11 + 43), *(unsigned __int8 *)(v11 + 44), *(unsigned __int8 *)(v11 + 45), *(unsigned __int8 *)(v11 + 46), *(unsigned __int8 *)(v11 + 47));
        v76 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", __str, 1);
        objc_msgSend(**(id **)(a2 + 40), "insertDebugSignpost:", v76);

      }
      v77 = *(unsigned int *)(v11 + 36);
      if ((_DWORD)v77)
        ((void (*)(id, char *, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD, _QWORD))v117[2])(v117[0], sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_, *(unsigned __int8 *)(v11 + 42), *(unsigned int *)(v11 + 28), 0, *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a2 + 96) + 8 * v77 + 24) + 16), *(unsigned int *)(v11 + 24), *(unsigned int *)(v11 + 32));
      else
        ((void (*)(id, char *, _QWORD, _QWORD, _QWORD, _QWORD))v117[1])(v117[0], sel_drawPrimitives_vertexStart_vertexCount_instanceCount_, *(unsigned __int8 *)(v11 + 42), *(unsigned int *)(v11 + 24), *(unsigned int *)(v11 + 28), *(unsigned int *)(v11 + 32));
      goto LABEL_113;
    }
    v115 = v105;
    v116 = v53;
    v97 = v97 & 0xFFFFFFFF00000000 | v53;
    v68 = RB::Device::render_pipeline_state(*(_QWORD *)a2, v105, v53, v96);
    v7 = v100;
    v69 = v68;
    if (v68)
    {
      v70 = *(_BYTE *)(v68 + 49) != 0;
      if (*(_BYTE *)(v68 + 49))
      {
        v78 = RB::Device::RenderPipelineEntry::function_table(v68, (const char *)*(unsigned int *)(a2 + 8), v96, HIDWORD(v115) >> 3);
        RB::FormattedRenderState::uber_globals((RB::RenderState *)&v115, (uint64_t)__str, v79);
        v122(v117[0], sel_setVertexBytes_length_atIndex_, __str, 32, 5);
        v125(v117[0], sel_setFragmentBytes_length_atIndex_, __str, 32, 5);
        if (*(_BYTE *)(*(_QWORD *)a2 + 287))
          objc_msgSend(v117[0], "setFragmentVisibleFunctionTable:atBufferIndex:", v78, 6);
        if (v98)
        {
          v80 = *(_QWORD *)(*(_QWORD *)(a2 + 96) + 32);
          if (v80)
          {
            v81 = 0;
            v82 = (int *)&v138;
            do
            {
              v83 = *v82;
              v82 += 3;
              if (!v83)
              {
                if ((v81 & 0x7FFFFFFFFFFFFFFELL) == 2
                  || (v123(v117[0], sel_setVertexBuffer_offset_atIndex_, *(_QWORD *)(v80 + 16), 0, v81), v81 != 1))
                {
                  v126(v117[0], sel_setFragmentBuffer_offset_atIndex_, *(_QWORD *)(v80 + 16), 0, v81);
                }
              }
              ++v81;
            }
            while (v81 != 4);
            if (!HIDWORD(v103))
              v126(v117[0], sel_setFragmentBuffer_offset_atIndex_, *(_QWORD *)(v80 + 16), 0, 4);
          }
        }
        v84 = 0;
        v85 = 1;
        do
        {
          v86 = v85;
          v87 = (unint64_t)(&v135 + v84);
          if (!*(_BYTE *)(v87 + 4))
          {
            v88 = RB::Device::sampler_state(*(_QWORD *)a2, (MTLPixelFormat)2uLL, 0);
            v129(v117[0], sel_setFragmentSamplerState_atIndex_, v88, v84);
            *(_BYTE *)(v87 | 4) = 2;
          }
          v85 = 0;
          v84 = 1;
        }
        while ((v86 & 1) != 0);
        v7 = v100;
        v66 = v105;
        if ((*(_DWORD *)v11 & 0x3F) == 0x20 && ((*(_DWORD *)v11 >> 12) & 7u) - 3 <= 1)
        {
          v89 = v11 + 49;
          if ((*(_BYTE *)(v11 + 48) & 1) != 0)
            v89 = ((v11 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
          v128(v117[0], sel_setFragmentTexture_atIndex_, *(id *)((*(_QWORD *)(*(_QWORD *)(a2 + 80)+ 8 * *(unsigned int *)(v89 + 12 * *(unsigned __int8 *)(v11 + 47))+ 24) & 0xFFFFFFFFFFFFFFFELL)+ 16), 1);
          v128(v117[0], sel_setFragmentTexture_atIndex_, 0, 0);
          LODWORD(v135) = 0;
          LODWORD(v136) = 0;
        }
        v98 = 0;
      }
      *(_DWORD *)(v69 + 40) = *(_DWORD *)(a2 + 12);
      v119(v117[0], sel_setRenderPipelineState_, *(_QWORD *)(v69 + 24));
      goto LABEL_92;
    }
    v6 = v112;
LABEL_139:
    if (v7 | v106)
    {
      v90 = RB::Device::depth_stencil_state(*(_QWORD *)a2, 0, 0);
      v120(v117[0], sel_setDepthStencilState_, v90);
    }
    if (v9 != -1)
      ((void (*)(id, char *, uint64_t))v121)(v117[0], sel_setStencilReferenceValue_, 0xFFFFFFFFLL);
  }
  else
  {
    v6 = 0;
    v109 = 0;
  }
  v91 = *v102;
  v92 = (uint32x2_t)vceqz_s32(v109);
  if ((vpmin_u32(v92, v92).u32[0] & 0x80000000) == 0
    || (v93 = (uint32x2_t)vceq_s32(v4, v91), (vpmin_u32(v93, v93).u32[0] & 0x80000000) == 0))
  {
    memset(__str, 0, sizeof(__str));
    *(_QWORD *)&v94 = v91.u32[0];
    *((_QWORD *)&v94 + 1) = v91.u32[1];
    v134 = v94;
    v118(v117[0], sel_setScissorRect_, __str);
  }

}

void sub_209ADC29C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,id a51)
{

  _Unwind_Resume(a1);
}

uint64_t RB::RenderState::reads_tables(RB::RenderState *this, int a2)
{
  unsigned int v2;
  int v3;
  int v4;
  int v5;

  v2 = *(_DWORD *)this;
  LOBYTE(v3) = 1;
  switch(*(_DWORD *)this & 0x3F)
  {
    case 0:
    case 1:
      return v3 & 1;
    case 3:
    case 7:
    case 0xD:
    case 0x15:
      v4 = (v2 >> 26) & 3;
      v5 = a2 ^ 1 | (v2 >> 26);
      if (v4 == (a2 ^ 1))
        LOBYTE(v3) = 0;
      else
        LOBYTE(v3) = v5;
      break;
    case 6:
    case 0xC:
    case 0x13:
    case 0x14:
      v3 = (v2 >> 22) & 1;
      break;
    case 0x1D:
    case 0x1E:
      v3 = (v2 >> 23) & 1;
      break;
    case 0x20:
    case 0x21:
    case 0x22:
      LOBYTE(v3) = (*(_DWORD *)this & 0x7000) == 4096;
      if ((v2 & 0x1C00000) != 0)
        LOBYTE(v3) = 1;
      break;
    case 0x24:
      v3 = (v2 >> 22) & 1;
      if ((v2 & 0x1000) == 0)
        LOBYTE(v3) = 0;
      break;
    default:
      LOBYTE(v3) = 0;
      break;
  }
  return v3 & 1;
}

uint64_t RB::RenderState::reads_noise(RB::RenderState *this)
{
  unsigned int v1;
  uint64_t result;

  v1 = *(_DWORD *)this;
  result = 1;
  switch(v1 & 0x3F)
  {
    case 0u:
    case 1u:
    case 6u:
    case 0xCu:
    case 0x13u:
    case 0x14u:
      return result;
    case 3u:
    case 7u:
    case 0xDu:
    case 0x15u:
      result = v1 >> 31;
      break;
    case 8u:
    case 0x16u:
      result = (v1 >> 22) & 1;
      break;
    case 0x1Du:
    case 0x1Eu:
      result = (v1 >> 29) & 1;
      break;
    case 0x1Fu:
      result = (v1 >> 27) & 1;
      break;
    case 0x20u:
    case 0x21u:
    case 0x22u:
      result = (v1 >> 25) & 1;
      break;
    case 0x23u:
      result = HIBYTE(v1) & 1;
      break;
    case 0x24u:
    case 0x25u:
      result = (v1 >> 12) & 1;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

double RB::time_seconds(RB *this)
{
  unsigned __int8 v1;
  double *v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  RB *v8;
  mach_timebase_info info;

  if ((v1 & 1) == 0)
  {
    v8 = this;
    v5 = v4;
    this = v8;
    if (v5)
    {
      mach_timebase_info(&info);
      LODWORD(v6) = info.numer;
      LODWORD(v7) = info.denom;
      *(double *)&RB::time_seconds(unsigned long long)::time_scale = (double)v6 * 0.000000001 / (double)v7;
      this = v8;
    }
  }
  return v2[20] * (double)(unint64_t)this;
}

double RB::current_time_seconds(RB *this)
{
  RB *v1;

  v1 = (RB *)mach_absolute_time();
  return RB::time_seconds(v1);
}

RB::XML::Document *RBDrawingStateClipShape2(RB::DisplayList::State *this, uint64_t a2, int a3, float a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int8x16_t v14;
  RB::XML::Document *result;
  uint64_t v16;
  float v17;
  _BOOL4 v18;
  uint64_t v19;
  char v20;
  RB::DisplayList::Clip *v21;

  v8 = *((_QWORD *)this + 1);
  v9 = *(_QWORD *)(v8 + 24);
  if (!v9)
  {
    make_contents(*((unsigned int **)this + 1));
    v9 = *(_QWORD *)(v8 + 24);
  }
  v10 = v9 + 16;
  RB::DisplayList::State::copy_ctm((__n128 *)this, (RB::Heap *)(v9 + 16));
  v12 = v11;
  v16 = v10;
  v17 = a4;
  v18 = rb_clip_mode(a3);
  v19 = v12;
  v21 = 0;
  v20 = *(_BYTE *)(v8 + 288);
  v13 = -[RBShape shapeData](a2);
  RBShapeData::apply<RB::DisplayList::ClipFactory>(v13, (uint64_t)&v16, v14);
  RB::DisplayList::State::push(this, (RB::DisplayList::Builder *)(v8 + 16), v21);
  result = *(RB::XML::Document **)(v8 + 304);
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::clip_shape(result, (_RBDrawingState *)this, a2, a3, a4);
  return result;
}

uint64_t RBShapeData::apply<RB::DisplayList::ClipFactory>(uint64_t result, uint64_t a2, int8x16_t a3)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Primitive>(a2, (_OWORD *)(result + 16), a3);
      break;
    case 2:
      result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Path>(a2, result + 16);
      break;
    case 3:
      result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(a2, result + 16);
      break;
    case 4:
      result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Glyphs>(a2, (RB::Coverage::Glyphs *)(result + 16));
      break;
    case 5:
      result = RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(a2, result + 16);
      break;
    default:
      return result;
  }
  return result;
}

BOOL rb_clip_mode(int a1)
{
  return a1 == 1;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Path>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD v5[2];

  if (*(_BYTE *)(a1 + 24))
  {
    v5[0] = off_24C224560;
    v5[1] = a1;
    RB::Coverage::Path::simplify(a2, (uint64_t)v5);
  }
  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(size_t **)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_BYTE *)(a1 + 24))
    *(_BYTE *)(result + 45) |= 4u;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v11 + 96;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C2247C0;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(v11 + 64) = v15;
  v16 = *(__int128 **)(a3 + 16);
  if (v16)
  {
    v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3])
      v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v17 + 3);
    v18 = *v16;
    v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *v17 = v18;
  }
  else
  {
    v17 = 0;
  }
  *(_QWORD *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_209ADC7FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(uint64_t a1)
{
  uint64_t v2;
  RBPath v3;

  if (*(_BYTE *)(a1 + 44) == 1)
  {
    *(_QWORD *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    if (*(float *)(a1 + 88) == 0.0)
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
    else
    {
      v3.info = (void *)(a1 + 56);
      v3.callbacks = *(RBPathCallbacks **)(a1 + 48);
      *(double *)(a1 + 16) = RB::Coverage::Path::bounds(v3);
      *(_QWORD *)(a1 + 24) = v2;
    }
  }
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Path>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  size_t *v7;
  int v8;
  _OWORD *v9;
  uint64_t v10;
  char v11;
  int v12;
  _QWORD *result;
  _QWORD v14[3];
  int v15;
  _OWORD *v16;
  uint64_t v17;
  _OWORD *v18;
  int v19;

  v7 = (size_t *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16);
  if (a4)
    v8 = *(_BYTE *)(a1 + 44) == 0;
  else
    v8 = *(char *)(a1 + 44);
  v19 = v8;
  v9 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  v18 = v9;
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
  {
    v11 = *(_BYTE *)(a1 + 45) & 4;
  }
  else if (*(_BYTE *)(*(_QWORD *)this + 272))
  {
    v14[0] = off_24C228818;
    v14[1] = v7;
    v14[2] = a1;
    v15 = v8;
    v16 = v9;
    v17 = 0;
    RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v14);
    v10 = v17;
    v11 = 4;
    if (v17)
      goto LABEL_11;
  }
  else
  {
    v11 = 0;
  }
  v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, v7, a1 + 56, (int *)(a1 + 88), &v19, (uint64_t *)&v18);
LABEL_11:
  *(_QWORD *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v12;
  *(_BYTE *)(v10 + 45) |= v11;
  result = (_QWORD *)((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((_QWORD *)this + 4))
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  else
    *((_QWORD *)this + 3) = result + 2;
  *result = a3;
  result[1] = v10;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

_OWORD *RB::DisplayList::CachedTransform::transform_ctm(float64x2_t *this, const RB::AffineTransform *a2)
{
  __int128 v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  int64x2_t v7;
  __int128 v8;
  size_t *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  _OWORD *result;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  float64x2_t v17;
  __int128 v18;
  float64x2_t v19;

  if (a2)
  {
    v3 = *((_OWORD *)a2 + 1);
    v17 = *(float64x2_t *)a2;
    v18 = v3;
    v19 = *((float64x2_t *)a2 + 2);
    v4 = v17;
    v5 = (float64x2_t)v3;
    v6 = v19;
  }
  else
  {
    v4 = (float64x2_t)xmmword_209BD5290;
    v5 = (float64x2_t)xmmword_209BD52A0;
    v17 = (float64x2_t)xmmword_209BD5290;
    v18 = xmmword_209BD52A0;
    v6 = 0uLL;
    v19 = 0u;
  }
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(this[74], v5), (int8x16_t)vceqq_f64(this[73], v4)), (int8x16_t)vceqq_f64(this[75], v6));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
    return *(_OWORD **)&this[76].f64[0];
  v8 = v18;
  this[73] = v17;
  this[74] = (float64x2_t)v8;
  this[75] = v19;
  v9 = *(size_t **)(*(_QWORD *)&this->f64[0] + 8);
  *(double *)&v10 = RB::operator*(&v17, this + 68);
  result = (_OWORD *)((v9[4] + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((unint64_t)(result + 3) > v9[5])
  {
    v15 = v11;
    v16 = v10;
    v14 = v12;
    result = (_OWORD *)RB::Heap::alloc_slow(v9 + 2, 0x30uLL, 15);
    v12 = v14;
    v11 = v15;
    v10 = v16;
  }
  else
  {
    v9[4] = (size_t)(result + 3);
  }
  *result = v10;
  result[1] = v11;
  result[2] = v12;
  *(_QWORD *)&this[76].f64[0] = result;
  return result;
}

int *RB::DisplayList::Item::apply_transform(RB::DisplayList::Item *this, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  unsigned int v3;
  unint64_t v6;
  BOOL v7;
  uint64_t *v8;
  unint64_t v9;
  BOOL v10;
  unsigned int v11;
  int *result;
  int v13;

  v3 = a3;
  v6 = *((_QWORD *)this + 2);
  if (v6)
    v7 = 0;
  else
    v7 = (_DWORD)a3 == 0;
  if (v7)
  {
    v8 = 0;
  }
  else
  {
    v8 = RB::DisplayList::CachedTransform::transform_style(a2, v6, a3);
    *((_QWORD *)this + 2) = v8;
  }
  v9 = *((_QWORD *)this + 3);
  if (v9)
    v10 = 0;
  else
    v10 = v3 == 0;
  if (!v10)
  {
    if (v8)
      v11 = 0;
    else
      v11 = v3;
    *((_QWORD *)this + 3) = RB::DisplayList::CachedTransform::transform_clip(a2, v9, v11);
  }
  result = RB::DisplayList::CachedTransform::transform_metadata(a2, *((const RB::DisplayList::Metadata **)this + 4), *((_DWORD *)this + 10));
  *((_QWORD *)this + 4) = result;
  *((_DWORD *)this + 10) = v13;
  return result;
}

int *RB::DisplayList::CachedTransform::transform_metadata(RB::DisplayList::CachedTransform *this, const RB::DisplayList::Metadata *a2, int a3)
{
  int *v6;
  int v8;
  const RB::DisplayList::Metadata *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int *v20;
  uint64_t v21;
  size_t *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  const UUID *v27;
  size_t *v28;
  int *v29;
  size_t *v30;
  uint64_t v31;
  int *v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;

  v39 = *MEMORY[0x24BDAC8D0];
  if (*(_BYTE *)(*(_QWORD *)this + 272) || !a2 && !*((_QWORD *)this + 142))
    return 0;
  v8 = *((_DWORD *)this + 287) != 0;
  if (*((const RB::DisplayList::Metadata **)this + 156) != a2 || *((unsigned __int8 *)this + 1256) != v8)
  {
    v38 = 0;
    v36 = 0u;
    v37 = 0u;
    if (a2)
    {
      v10 = a2;
      do
      {
        v11 = *(_QWORD *)v10;
        v12 = *(_QWORD *)v10 & 7;
        if (*((_QWORD *)&v36 + v12))
          v10 = (const RB::DisplayList::Metadata *)*((_QWORD *)&v36 + v12);
        *((_QWORD *)&v36 + v12) = v10;
        v10 = (const RB::DisplayList::Metadata *)(v11 & 0xFFFFFFFFFFFFFFF8);
      }
      while ((v11 & 0xFFFFFFFFFFFFFFF8) != 0);
    }
    v13 = (uint64_t *)*((_QWORD *)this + 142);
    v33 = 0uLL;
    v34 = 0uLL;
    v35 = 0;
    if (v13)
    {
      do
      {
        v14 = *v13;
        v15 = *v13 & 7;
        if (*((_QWORD *)&v33 + v15))
          v13 = (uint64_t *)*((_QWORD *)&v33 + v15);
        *((_QWORD *)&v33 + v15) = v13;
        v13 = (uint64_t *)(v14 & 0xFFFFFFFFFFFFFFF8);
      }
      while ((v14 & 0xFFFFFFFFFFFFFFF8) != 0);
    }
    v6 = 0;
    v32 = 0;
    v16 = 4;
    while (2)
    {
      switch(v16)
      {
        case 0:
          if (a3 && (v25 = v36) != 0
            || ((v25 = v33, *((_DWORD *)this + 287)) ? (v26 = (_QWORD)v33 == 0) : (v26 = 1), !v26))
          {
            v27 = *(const UUID **)(v25 + 8);
            if (v27)
            {
              v28 = *(size_t **)(*(_QWORD *)this + 8);
              v29 = (int *)((v28[4] + 7) & 0xFFFFFFFFFFFFFFF8);
              if ((unint64_t)(v29 + 4) > v28[5])
              {
                v30 = *(size_t **)(*(_QWORD *)this + 8);
                v29 = (int *)RB::Heap::alloc_slow(v28 + 2, 0x10uLL, 7);
                v28 = v30;
                v6 = v32;
              }
              else
              {
                v28[4] = (size_t)(v29 + 4);
              }
              *(_QWORD *)v29 = v6;
              *((_QWORD *)v29 + 1) = v27;
              *((_QWORD *)v29 + 1) = RB::DisplayList::Contents::intern_uuid((RB::DisplayList::Contents *)v28, v27);
              v6 = v29;
            }
          }
          *((_QWORD *)this + 156) = a2;
          *((_BYTE *)this + 1256) = v8;
          *((_QWORD *)this + 158) = v6;
          return v6;
        case 1:
          if (*((_QWORD *)&v36 + 1))
          {
            v17 = *(_QWORD *)(*((_QWORD *)&v36 + 1) + 8);
            v31 = v17;
            v18 = *((_QWORD *)&v33 + 1);
            if (!*((_QWORD *)&v33 + 1))
              goto LABEL_38;
            if (v17 && !*(_BYTE *)(v17 + 13))
            {
LABEL_39:
              v24 = *(_QWORD *)(*(_QWORD *)this + 8);
              v6 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)1>,RB::DisplayList::Metadata const*&,RB::Transition *&>((RB::Heap *)(v24 + 16), &v32, &v31);
              RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)1>::retain(*((_DWORD **)v6 + 1), v24);
              goto LABEL_40;
            }
          }
          else
          {
            v18 = *((_QWORD *)&v33 + 1);
            if (!*((_QWORD *)&v33 + 1))
              goto LABEL_41;
          }
          v17 = *(_QWORD *)(v18 + 8);
          v31 = v17;
LABEL_38:
          if (!v17)
            goto LABEL_41;
          goto LABEL_39;
        case 2:
          v19 = v37;
          if (!(_QWORD)v37)
          {
            v19 = v34;
            if (!(_QWORD)v34)
              goto LABEL_41;
          }
          RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)2>,RB::DisplayList::Metadata const*&,float>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16), &v32, (float *)(v19 + 8));
          goto LABEL_35;
        case 3:
          v21 = *((_QWORD *)&v37 + 1);
          if (*((_QWORD *)&v37 + 1) || (v21 = *((_QWORD *)&v34 + 1)) != 0)
          {
            v22 = *(size_t **)(*(_QWORD *)this + 8);
            v6 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)3>,RB::DisplayList::Metadata const*&,RB::TextIdentity const*&>((RB::Heap *)(v22 + 2), &v32, (uint64_t *)(v21 + 8));
            RB::DisplayList::Metadata::Traits<(RB::DisplayList::Metadata::Type)3>::retain(v6 + 2, v22);
LABEL_40:
            v32 = v6;
          }
          goto LABEL_41;
        case 4:
          v23 = v38;
          if (!v38)
          {
            v23 = v35;
            if (!v35)
              goto LABEL_41;
          }
          v20 = (int *)RB::Heap::emplace<RB::DisplayList::MetadataValue<(RB::DisplayList::Metadata::Type)4>,RB::DisplayList::Metadata const*&,RB::AnimationLayer &>((RB::Heap *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16), &v32, (_QWORD *)(v23 + 8));
LABEL_35:
          v6 = v20;
          v32 = v20;
LABEL_41:
          --v16;
          continue;
        default:
          goto LABEL_41;
      }
    }
  }
  return (int *)*((_QWORD *)this + 158);
}

const RB::DisplayList::ClipNode *RB::DisplayList::CachedTransform::transform_clip(RB::DisplayList::CachedTransform *this, unint64_t a2, unsigned int a3)
{
  unint64_t v4;
  const RB::DisplayList::ClipNode *v5;
  const RB::DisplayList::ClipNode *v7;
  uint64_t v8;
  uint64_t v9;
  _BYTE *v10;
  _BYTE *v11;
  uint64_t v12;
  uint64_t *v13;
  size_t *v14;
  uint64_t v15;
  size_t v16;
  size_t *v17;
  size_t v18;
  const RB::DisplayList::ClipNode *v20;
  _BYTE __dst[128];
  void *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v4 = a3 | a2;
  if (*((_QWORD *)this + 159) == v4)
    return (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 160);
  v7 = (const RB::DisplayList::ClipNode *)a2;
  v22 = 0;
  v23 = 0;
  v24 = 16;
  if (a2)
  {
    v8 = 0;
    do
    {
      v9 = v8 + 1;
      if (v24 < v8 + 1)
      {
        _ZN2RB6vectorIDv4_DF16_Lm16EmE12reserve_slowEm(__dst, v8 + 1);
        v8 = v23;
        v9 = v23 + 1;
      }
      v10 = v22;
      if (!v22)
        v10 = __dst;
      *(_QWORD *)&v10[8 * v8] = v7;
      v23 = v9;
      v7 = *(const RB::DisplayList::ClipNode **)v7;
      v8 = v9;
    }
    while (v7);
  }
  else
  {
    v9 = 0;
  }
  if (a3)
    v5 = (const RB::DisplayList::ClipNode *)*((_QWORD *)this + 134);
  else
    v5 = 0;
  v20 = v5;
  if (v9)
  {
    do
    {
      --v9;
      v11 = v22;
      if (!v22)
        v11 = __dst;
      v12 = *(_QWORD *)&v11[8 * v9];
      if (!*(_BYTE *)(*(_QWORD *)this + 272)
        || (RB::DisplayList::ClipNode::elide_append((uint64_t *)&v20, (float32x2_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL)) & 1) == 0)
      {
        v13 = RB::UntypedTable::lookup((RB::DisplayList::CachedTransform *)((char *)this + 1288), (uint64_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL), 0);
        if (v13)
          goto LABEL_34;
        v14 = (size_t *)(*(uint64_t (**)(unint64_t, RB::DisplayList::CachedTransform *, _QWORD, _QWORD))(*(_QWORD *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL) + 24))(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL, this, 0, 0);
        v13 = (uint64_t *)v14;
        if (v14)
        {
          v15 = *(_QWORD *)(*(_QWORD *)this + 8);
          v16 = *(_QWORD *)(v15 + 312);
          v17 = v14;
          do
          {
            v18 = v16;
            v16 = v17[1];
            *(_QWORD *)(v16 + 8) = v18;
            v17 = (size_t *)*v17;
          }
          while (v17);
          *(_QWORD *)(v15 + 312) = v16;
        }
        RB::UntypedTable::insert((size_t **)this + 161, (size_t *)(*(_QWORD *)(v12 + 8) & 0xFFFFFFFFFFFFFFFELL), v14);
        if (v13)
        {
LABEL_34:
          do
          {
            v20 = (const RB::DisplayList::ClipNode *)RB::Heap::emplace<RB::DisplayList::ClipNode,RB::DisplayList::Clip const*&,RB::DisplayList::ClipNode*&>((size_t *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16), (const RB::DisplayList::Clip **)v13 + 1, &v20);
            v13 = (uint64_t *)*v13;
          }
          while (v13);
        }
      }
    }
    while (v9);
    v5 = v20;
  }
  *((_QWORD *)this + 159) = v4;
  *((_QWORD *)this + 160) = v5;
  if (v22)
    free(v22);
  return v5;
}

void sub_209ADD0A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  if (a27)
    free(a27);
  _Unwind_Resume(exception_object);
}

uint64_t *RB::DisplayList::CachedTransform::transform_style(RB::DisplayList::CachedTransform *this, unint64_t a2, uint64_t a3)
{
  const RB::DisplayList::Style *v4;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned __int16 v9;
  size_t v11;
  size_t v12;
  void **v13;
  uint64_t *v14;
  size_t v15;
  void **v16;
  const RB::AffineTransform **v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  void *v23[8];
  void *v24;
  size_t v25;
  unint64_t i;
  uint64_t v27;

  v4 = (const RB::DisplayList::Style *)a2;
  v27 = *MEMORY[0x24BDAC8D0];
  if (!a2 && (!(_DWORD)a3 || !*((_QWORD *)this + 135)))
    return 0;
  v6 = (uint64_t *)(a3 | a2 | *((unsigned __int8 *)this + 1456));
  v23[0] = 0;
  v7 = RB::UntypedTable::lookup((RB::DisplayList::CachedTransform *)((char *)this + 1368), v6, v23);
  if (v6 != v23[0])
  {
    v24 = 0;
    v25 = 0;
    for (i = 8; v4; v4 = (const RB::DisplayList::Style *)*((_QWORD *)v4 + 4))
    {
      v8 = *((_QWORD *)this + 181);
      if (v8)
      {
        v9 = (*(uint64_t (**)(const RB::DisplayList::Style *, _QWORD))(*(_QWORD *)v4 + 64))(v4, *((_QWORD *)this + 181));
        if (v9 >= 0x100u && (*(_BYTE *)(v8 + 40) ? v9 != 0 : v9 == 0))
          continue;
      }
      v11 = v25;
      v12 = v25 + 1;
      if (i < v25 + 1)
      {
        RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(v23, v12);
        v11 = v25;
        v12 = v25 + 1;
      }
      v13 = (void **)v24;
      if (!v24)
        v13 = v23;
      v13[v11] = v4;
      v25 = v12;
    }
    if ((a3 & 1) != 0)
      v14 = (uint64_t *)*((_QWORD *)this + 135);
    else
      v14 = 0;
    if (v25)
    {
      v15 = v25 - 1;
      do
      {
        v16 = (void **)v24;
        if (!v24)
          v16 = v23;
        v17 = (const RB::AffineTransform **)v16[v15];
        v18 = (*((uint64_t (**)(const RB::AffineTransform **, _QWORD))*v17 + 3))(v17, *(_QWORD *)this);
        v7 = (uint64_t *)v18;
        if (v18)
        {
          v19 = *((_QWORD *)this + 181);
          if (v19)
            (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v18 + 72))(v18, v19, *((unsigned __int8 *)this + 1456));
          v7[2] = (uint64_t)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, v17[2]);
          v7[3] = (uint64_t)RB::DisplayList::CachedTransform::transform_clip(this, (unint64_t)v17[3], a3);
          v7[5] = (uint64_t)RB::DisplayList::CachedTransform::transform_metadata(this, v17[5], *((_DWORD *)v17 + 12));
          *((_DWORD *)v7 + 12) = v20;
          *((_DWORD *)v7 + 13) = *((_DWORD *)v17 + 13) & 1;
          (*(void (**)(uint64_t *, RB::DisplayList::CachedTransform *, uint64_t))(*v7 + 32))(v7, this, a3);
          v7[4] = (uint64_t)v14;
          v21 = *(_QWORD *)(*(_QWORD *)this + 8);
          v7[1] = *(_QWORD *)(v21 + 312);
          *(_QWORD *)(v21 + 312) = v7;
          v14 = v7;
        }
        else
        {
          v7 = v14;
        }
        --v15;
      }
      while (v15 != -1);
    }
    else
    {
      v7 = v14;
    }
    RB::UntypedTable::insert((size_t **)this + 171, (size_t *)v6, (size_t *)v7);
    if (v24)
      free(v24);
  }
  return v7;
}

void sub_209ADD34C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17)
    free(a17);
  _Unwind_Resume(exception_object);
}

uint64_t *RB::UntypedTable::lookup(RB::UntypedTable *this, uint64_t *a2, void **a3)
{
  uint64_t v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t *result;

  if (*((_QWORD *)this + 7))
  {
    v6 = (*(uint64_t (**)(uint64_t *))this)(a2);
    v7 = *(uint64_t ***)(*((_QWORD *)this + 6) + 8 * (*((_QWORD *)this + 8) & v6));
    if (*((_BYTE *)this + 77))
    {
      if (v7)
      {
        while (v7[1] != a2)
        {
          v7 = (uint64_t **)*v7;
          if (!v7)
            goto LABEL_12;
        }
        if (a3)
          *a3 = a2;
        return v7[2];
      }
    }
    else if (v7)
    {
      v8 = v6;
      while (v7[3] != (uint64_t *)v8 || !(*((unsigned int (**)(uint64_t *, uint64_t *))this + 1))(v7[1], a2))
      {
        v7 = (uint64_t **)*v7;
        if (!v7)
          goto LABEL_12;
      }
      if (a3)
        *a3 = v7[1];
      return v7[2];
    }
  }
LABEL_12:
  result = 0;
  if (a3)
    *a3 = 0;
  return result;
}

unint64_t RB::pointer_hash(RB *this, const void *a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;

  v2 = ((unint64_t)this + ~((_QWORD)this << 32)) ^ (((unint64_t)this + ~((_QWORD)this << 32)) >> 22);
  v3 = 9 * ((v2 + ~(v2 << 13)) ^ ((v2 + ~(v2 << 13)) >> 8));
  v4 = (v3 ^ (v3 >> 15)) + ~((v3 ^ (v3 >> 15)) << 27);
  return v4 ^ (v4 >> 31);
}

uint64_t RB::UntypedTable::insert(size_t **this, size_t *a2, size_t *a3)
{
  uint64_t v6;
  _QWORD *v7;
  size_t *v8;
  RB::Heap *v9;
  size_t **v10;
  size_t *v11;
  uint64_t v12;
  size_t *v13;
  uint64_t result;
  size_t *v15;
  size_t *v16;

  if (!this[6])
    RB::UntypedTable::create_buckets((RB::UntypedTable *)this);
  v6 = ((uint64_t (*)(size_t *))*this)(a2);
  v7 = (_QWORD *)this[6][(unint64_t)this[8] & v6];
  if (v7)
  {
    while (v7[3] != v6 || !((unsigned int (*)(_QWORD, size_t *))this[1])(v7[1], a2))
    {
      v7 = (_QWORD *)*v7;
      if (!v7)
        goto LABEL_7;
    }
    v15 = this[2];
    if (v15)
      ((void (*)(_QWORD))v15)(v7[1]);
    v16 = this[3];
    if (v16)
      ((void (*)(_QWORD))v16)(v7[2]);
    result = 0;
    v7[1] = a2;
    v7[2] = a3;
  }
  else
  {
LABEL_7:
    if ((unint64_t)this[7] + 1 > 4 << *((_DWORD *)this + 18))
      RB::UntypedTable::grow_buckets((RB::UntypedTable *)this);
    v8 = this[4];
    if (!v8)
    {
      v9 = (RB::Heap *)operator new();
      v8 = (size_t *)RB::Heap::Heap(v9, 0, 0, 0x400uLL);
      this[4] = v8;
    }
    v10 = (size_t **)this[5];
    if (v10)
    {
      this[5] = *v10;
    }
    else
    {
      v10 = (size_t **)((v8[2] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v10 + 4) > v8[3])
        v10 = (size_t **)RB::Heap::alloc_slow(v8, 0x20uLL, 7);
      else
        v8[2] = (size_t)(v10 + 4);
    }
    v10[1] = a2;
    v10[2] = a3;
    v10[3] = (size_t *)v6;
    v11 = this[7];
    v12 = (unint64_t)this[8] & v6;
    v13 = this[6];
    *v10 = (size_t *)v13[v12];
    v13[v12] = (size_t)v10;
    this[7] = (size_t *)((char *)v11 + 1);
    return 1;
  }
  return result;
}

float32x2_t *RB::DisplayList::ClipNode::ClipNode(float32x2_t *a1, uint64_t a2, float32x2_t *a3, double a4, double a5, double a6, double a7, double a8, int32x4_t a9)
{
  float32x2_t *v10;

  *a1 = (float32x2_t)a3;
  a1[1] = (float32x2_t)a2;
  *(_OWORD *)a1[2].f32 = *(_OWORD *)(a2 + 16);
  if ((*(_BYTE *)(a2 + 45) & 1) != 0)
  {
    a2 |= 1uLL;
    a1[1] = (float32x2_t)a2;
  }
  if (a3)
  {
    v10 = a1 + 2;
    if ((a3[1].i8[0] & 1) == 0)
      a1[1] = (float32x2_t)(a2 & 0xFFFFFFFFFFFFFFFELL);
    RB::Rect::intersect(v10, a3[2], a3[3], a6, a7, a8, a9);
  }
  return a1;
}

double RB::UntypedTable::create_buckets(RB::UntypedTable *this)
{
  size_t *v2;
  RB::Heap *v3;
  _OWORD *v4;
  double result;

  if (!*((_QWORD *)this + 6))
  {
    *((_DWORD *)this + 18) = 4;
    *((_QWORD *)this + 8) = 15;
    v2 = (size_t *)*((_QWORD *)this + 4);
    if (!v2)
    {
      v3 = (RB::Heap *)operator new();
      v2 = (size_t *)RB::Heap::Heap(v3, 0, 0, 0x400uLL);
      *((_QWORD *)this + 4) = v2;
    }
    v4 = (_OWORD *)((v2[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(v4 + 8) > v2[3])
      v4 = (_OWORD *)RB::Heap::alloc_slow(v2, 0x80uLL, 7);
    else
      v2[2] = (size_t)(v4 + 8);
    *((_QWORD *)this + 6) = v4;
    result = 0.0;
    v4[6] = 0u;
    v4[7] = 0u;
    v4[4] = 0u;
    v4[5] = 0u;
    v4[2] = 0u;
    v4[3] = 0u;
    *v4 = 0u;
    v4[1] = 0u;
  }
  return result;
}

unint64_t RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_0::__invoke<RB::FormattedRenderState const*>(unsigned int *a1)
{
  return *a1 ^ (unint64_t)(33 * a1[2]);
}

BOOL RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_1::__invoke<RB::FormattedRenderState const*,RB::FormattedRenderState const>(_DWORD *a1, _DWORD *a2)
{
  return *a2 == *a1 && a1[1] == a2[1] && ((a2[2] ^ a1[2]) & 0xFBFFFFFF) == 0;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v11 + 96;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C2247C0;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(v11 + 64) = v15;
  v16 = *(__int128 **)(a3 + 16);
  if (v16)
  {
    v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3])
      v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v17 + 3);
    v18 = *v16;
    v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *v17 = v18;
  }
  else
  {
    v17 = 0;
  }
  *(_QWORD *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_209ADD894(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Primitive>(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)a1, a3, *(_QWORD *)a1, a2, (unsigned __int32 *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_BYTE *)(a1 + 24))
    *(_BYTE *)(result + 45) |= 4u;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  uint64_t v6;

  if (*(_BYTE *)(a1 + 44) == 1)
  {
    *(_QWORD *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    a2.i32[0] = *(_DWORD *)(a1 + 112);
    if (*(float *)a2.i32 == 0.0)
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
      *(_QWORD *)(a1 + 24) = v6;
      if (*(float *)(a1 + 112) == 1.0)
      {
        if (RB::Coverage::Primitive::rectangular((RB::Coverage::Primitive *)(a1 + 64), *(const RB::AffineTransform **)(a1 + 48)))*(_BYTE *)(a1 + 45) |= 1u;
      }
    }
  }
}

uint64_t RB::Coverage::Primitive::rectangular(RB::Coverage::Primitive *this, const RB::AffineTransform *a2)
{
  unsigned int v2;
  uint64_t result;
  unsigned int v5;
  float v6;
  unsigned int v7;
  uint32x2_t v8;
  __int128 v9;
  __int128 v10;
  float32x2_t v11;
  int32x4_t v12;
  int32x2_t v13;
  int8x16_t v14;
  int8x8_t v15;
  __int128 v16;

  v2 = *((unsigned __int8 *)this + 44);
  if (v2 < 2)
    return 1;
  if ((*((_BYTE *)this + 46) & 5) != 0)
    return 0;
  v5 = *((unsigned __int8 *)this + 45);
  if (v5 > 1)
    return 0;
  v6 = *((float *)this + 9);
  if (v6 > 0.0 && v6 < fmaxf(COERCE_FLOAT(*((_QWORD *)this + 1)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1)))))
    return 0;
  result = 0;
  switch(v2)
  {
    case 3u:
    case 4u:
      v7 = vmaxvq_u32((uint32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(*((float32x4_t *)this + 1))));
      goto LABEL_10;
    case 5u:
    case 7u:
      return result;
    case 6u:
    case 8u:
      v8 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(*(float32x2_t *)((char *)this + 8)));
      v7 = vpmax_u32(v8, v8).u32[0];
LABEL_10:
      if ((v7 & 0x80000000) == 0)
        goto LABEL_11;
      return 0;
    case 9u:
    case 0xAu:
    case 0xBu:
      abort();
    default:
LABEL_11:
      v9 = *((_OWORD *)a2 + 1);
      if (*((double *)a2 + 1) != 0.0 || *(double *)&v9 != 0.0)
      {
        result = 0;
        if (*(double *)a2 != 0.0 || *((double *)&v9 + 1) != 0.0)
          return result;
      }
      if (v5 == 1)
        return 1;
      *(float32x2_t *)&v10 = RB::operator*((float64x2_t *)a2, *(float32x2_t *)this, *(float32x2_t *)((char *)this + 8));
      *(_QWORD *)&v16 = v10;
      *((float32x2_t *)&v16 + 1) = v11;
      v13.i32[0] = *((_DWORD *)this + 9);
      if (*(float *)v13.i32 > 0.0)
      {
        *(float *)v13.i32 = *(float *)v13.i32 * 0.5;
        *(int32x2_t *)v12.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v11);
        v14 = (int8x16_t)vcltzq_s32(v12);
        v15 = (int8x8_t)vmvnq_s8(v14).u64[0];
        *(int8x8_t *)&v10 = vorr_s8(vand_s8((int8x8_t)vsub_f32(*(float32x2_t *)&v10, (float32x2_t)vdup_lane_s32(v13, 0)), *(int8x8_t *)v14.i8), vand_s8(*(int8x8_t *)&v10, v15));
        *((int8x8_t *)&v10 + 1) = vorr_s8(vand_s8((int8x8_t)vmla_n_f32(v11, (float32x2_t)0x4000000040000000, *(float *)v13.i32), *(int8x8_t *)v14.i8), vand_s8((int8x8_t)v11, v15));
        v16 = v10;
      }
      LODWORD(v10) = 981668463;
      result = RB::Rect::is_integral((float32x2_t *)&v16, *(int32x2_t *)&v10);
      break;
  }
  return result;
}

uint64_t RB::verbose_mode(RB *this)
{
  unsigned __int8 v1;
  unint64_t v2;
  int v4;
  const char *v5;
  uint64_t v6;
  int v7;

  v2 = 0x253EAE000uLL;
  if ((v1 & 1) == 0)
  {
    v2 = 0x253EAE000;
    if (v4)
    {
      v6 = RB::debug_int((RB *)"RB_VERBOSE", v5);
      if ((v6 & 0xFF00000000) != 0)
        v7 = v6;
      else
        v7 = 0;
      RB::verbose_mode(void)::value = v7;
      v2 = 0x253EAE000;
    }
  }
  return *(unsigned int *)(v2 + 3752);
}

uint64_t RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_0::__invoke<RB::RenderFrame::RegionKey const*>(unsigned int *a1)
{
  return 33 * *a1 + a1[1];
}

uint64_t RB::Device::RenderPipelineEntry::Queue::shared(RB::Device::RenderPipelineEntry::Queue *this)
{
  unsigned __int8 v1;
  _QWORD *v3;

  if ((v1 & 1) == 0
  {
    v3 = (_QWORD *)operator new();
    *v3 = 0;
    v3[1] = 0;
    v3[2] = 0;
    RB::Device::RenderPipelineEntry::Queue::shared(void)::shared_queue = (uint64_t)v3;
  }
  return RB::Device::RenderPipelineEntry::Queue::shared(void)::shared_queue;
}

void sub_209ADDC14(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::Device::depth_stencil_state(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v8;
  void *v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  uint64_t v16;
  const char *v17;

  v3 = a2;
  v4 = a1 + ((unint64_t)a2 << 6) + 8 * a3;
  v5 = *(_QWORD *)(v4 + 608);
  if (v5)
    return v5;
  v8 = a3;
  v9 = (void *)objc_opt_new();
  v11 = *((_QWORD *)v10 + 1);
  v13 = *((unsigned int *)v10 + 6);
  v12 = *((unsigned int *)v10 + 7);
  objc_msgSend(v9, "setStencilCompareFunction:", *(_QWORD *)v10);
  objc_msgSend(v9, "setStencilFailureOperation:", 0);
  objc_msgSend(v9, "setDepthFailureOperation:", 0);
  objc_msgSend(v9, "setDepthStencilPassOperation:", v11);
  objc_msgSend(v9, "setReadMask:", v13);
  objc_msgSend(v9, "setWriteMask:", v12);
  v14 = (void *)objc_opt_new();
  objc_msgSend(v14, "setFrontFaceStencil:", v9);
  objc_msgSend(v14, "setBackFaceStencil:", v9);
  switch(a2)
  {
    case 0u:
      v16 = 7;
      goto LABEL_8;
    case 1u:
      v16 = 6;
LABEL_8:
      objc_msgSend(v14, "setDepthCompareFunction:", v16);
      v15 = 0;
      goto LABEL_9;
    case 2u:
      objc_msgSend(v14, "setDepthCompareFunction:", 6);
      v15 = 1;
LABEL_9:
      objc_msgSend(v14, "setDepthWriteEnabled:", v15);
      break;
  }
  v5 = objc_msgSend(*(id *)(a1 + 24), "newDepthStencilStateWithDescriptor:", v14);

  *(_QWORD *)(v4 + 608) = v5;
  if (!v5)
    RB::precondition_failure((RB *)"unable to allocate depth-stencil state: %d, %d", v17, v3, v8);

  return v5;
}

void sub_209ADDDA8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

BOOL RB::RenderState::uber_compatible(RB::RenderState *this)
{
  unsigned int v1;

  v1 = *(_DWORD *)this & 0x3F;
  if (v1 < 2 || v1 == 38)
    return 0;
  if (v1 == 33)
    return (*(_DWORD *)this & 0x6000) == 0;
  return 1;
}

uint64_t RB::FormattedRenderState::ID::formatted@<X0>(uint64_t this@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  uint64_t i;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;

  v2 = 0;
  for (i = 0; i != 12; ++i)
  {
    if (i % 3u == 2)
    {
      v7 = *(unsigned __int8 *)(this + i);
      v6 = v2 + 1;
      *(_BYTE *)(a2 + v2) = RB::FormattedRenderState::ID::formatted(void)const::table[((unint64_t)(v7 | (*(unsigned __int8 *)(this + i - 1) << 8)) >> 6) & 0x3F];
      v4 = v7 & 0x3F;
      v5 = 2;
    }
    else
    {
      if (i % 3u == 1)
      {
        v4 = ((unint64_t)(*(unsigned __int8 *)(this + i) | (*(unsigned __int8 *)(this + i - 1) << 8)) >> 4) & 0x3F;
      }
      else
      {
        if (i % 3u)
          continue;
        v4 = (unint64_t)*(unsigned __int8 *)(this + i) >> 2;
      }
      v5 = 1;
      v6 = v2;
    }
    v2 += v5;
    *(_BYTE *)(a2 + v6) = RB::FormattedRenderState::ID::formatted(void)const::table[v4];
  }
  *(_BYTE *)(a2 + v2) = 0;
  return this;
}

uint64_t RB::Device::library(RB::Device *this)
{
  uint64_t result;
  RB::_anonymous_namespace_ *v3;
  void *bundle;
  uint64_t library;

  result = *((_QWORD *)this + 6);
  if (!result)
  {
    v3 = (RB::_anonymous_namespace_ *)MEMORY[0x20BD168EC]();

    *((_QWORD *)this + 6) = library;
    objc_autoreleasePoolPop(v3);
    return *((_QWORD *)this + 6);
  }
  return result;
}

void sub_209ADDF20(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::Queue::enqueue(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;

  os_unfair_lock_lock((os_unfair_lock_t)a1);
  v4 = *(_QWORD **)(a1 + 16);
  if (!v4)
    v4 = (_QWORD *)(a1 + 8);
  *v4 = a2;
  *(_QWORD *)(a1 + 16) = a2;
  os_unfair_lock_unlock((os_unfair_lock_t)a1);
}

BOOL RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_1::__invoke<RB::RenderFrame::RegionKey const*,RB::RenderFrame::RegionKey const*>(_QWORD *a1, _QWORD *a2)
{
  return *a1 == *a2;
}

uint64_t RB::Device::sampler_state(uint64_t a1, MTLPixelFormat a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unint64_t v7;
  void *v8;
  uint64_t v9;
  char *v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  const char *v14;

  v3 = a1 + 8 * a2;
  v4 = *(_QWORD *)(v3 + 560);
  if (!v4)
  {
    v5 = a2;
    if ((_DWORD)a2 == 4)
    {
      if (a3)
        v7 = *(_QWORD *)(a3 + 56);
      else
        v7 = 0;
      if (*(unsigned __int8 *)(a1 + 283) >= *((unsigned __int8 *)RB::pixel_format_traits(v7, a2) + 9))
        v5 = 4;
      else
        v5 = 2;
    }
    else if ((_DWORD)a2 == 3)
    {
      if (a3 && *(unsigned __int8 *)(a3 + 76) > 1u)
        v5 = 3;
      else
        v5 = 2;
    }
    v8 = (void *)objc_opt_new();
    v9 = v5;
    v11 = *v10;
    v13 = *((_QWORD *)v10 + 2);
    v12 = *((_QWORD *)v10 + 3);
    objc_msgSend(v8, "setSAddressMode:", 0);
    objc_msgSend(v8, "setTAddressMode:", 0);
    objc_msgSend(v8, "setNormalizedCoordinates:", v11 & 1);
    objc_msgSend(v8, "setMinFilter:", v13);
    objc_msgSend(v8, "setMagFilter:", v13);
    objc_msgSend(v8, "setMipFilter:", v12);
    objc_msgSend(v8, "setLodAverage:", 1);
    v4 = objc_msgSend(*(id *)(a1 + 24), "newSamplerStateWithDescriptor:", v8);

    *(_QWORD *)(v3 + 560) = v4;
    if (!v4)
      RB::precondition_failure((RB *)"unable to allocate sampler state: %d", v14, v9);

  }
  return v4;
}

void sub_209ADE0EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RB::DirectRenderCommandEncoder::reset(_QWORD *a1, void *a2)
{
  uint64_t result;

  *a1 = a2;
  a1[1] = objc_msgSend(a2, "methodForSelector:", sel_drawPrimitives_vertexStart_vertexCount_instanceCount_);
  a1[2] = objc_msgSend(a2, "methodForSelector:", sel_drawIndexedPrimitives_indexCount_indexType_indexBuffer_indexBufferOffset_instanceCount_);
  a1[3] = objc_msgSend(a2, "methodForSelector:", sel_setScissorRect_);
  a1[4] = objc_msgSend(a2, "methodForSelector:", sel_setRenderPipelineState_);
  a1[5] = objc_msgSend(a2, "methodForSelector:", sel_setDepthStencilState_);
  a1[6] = objc_msgSend(a2, "methodForSelector:", sel_setStencilReferenceValue_);
  a1[7] = objc_msgSend(a2, "methodForSelector:", sel_setVertexBytes_length_atIndex_);
  a1[8] = objc_msgSend(a2, "methodForSelector:", sel_setVertexBuffer_offset_atIndex_);
  a1[9] = objc_msgSend(a2, "methodForSelector:", sel_setVertexBufferOffset_atIndex_);
  a1[10] = objc_msgSend(a2, "methodForSelector:", sel_setFragmentBytes_length_atIndex_);
  a1[11] = objc_msgSend(a2, "methodForSelector:", sel_setFragmentBuffer_offset_atIndex_);
  a1[12] = objc_msgSend(a2, "methodForSelector:", sel_setFragmentBufferOffset_atIndex_);
  a1[13] = objc_msgSend(a2, "methodForSelector:", sel_setFragmentTexture_atIndex_);
  result = objc_msgSend(a2, "methodForSelector:", sel_setFragmentSamplerState_atIndex_);
  a1[14] = result;
  return result;
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Primitive>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  size_t *v7;
  int v8;
  int8x16_t v9;
  char v10;
  uint64_t v11;
  int v12;
  _QWORD *result;
  _OWORD *v14;
  int v15;

  v7 = (size_t *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16);
  v8 = *(char *)(a1 + 44);
  if (a4)
    v8 = *(_BYTE *)(a1 + 44) == 0;
  v15 = v8;
  v14 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
    v10 = *(_BYTE *)(a1 + 45) & 4;
  else
    v10 = 4 * *(_BYTE *)(*(_QWORD *)this + 272);
  v11 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, v9, (uint64_t)v7, (_OWORD *)(a1 + 64), (unsigned __int32 *)(a1 + 112), &v15, (uint64_t *)&v14);
  *(_QWORD *)(v11 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v11 + 40) = v12;
  *(_BYTE *)(v11 + 45) |= v10;
  result = (_QWORD *)((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((_QWORD *)this + 4))
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  else
    *((_QWORD *)this + 3) = result + 2;
  *result = a3;
  result[1] = v11;
  return result;
}

uint64_t RB::Device::RenderPipelineEntry::RenderPipelineEntry(uint64_t a1, uint64_t a2, int a3, id *a4)
{
  id v5;

  *(_QWORD *)a1 = a2;
  *(_DWORD *)(a1 + 8) = a3;
  *(_QWORD *)(a1 + 16) = 0;
  v5 = *a4;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 24) = v5;
  *(_WORD *)(a1 + 48) = 0;
  return a1;
}

void sub_209ADE380(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 16);
  *(_QWORD *)(v1 + 16) = 0;
  if (v3)
    RB::Device::RenderPipelineEntry::DeleteLoader::operator()((uint64_t)exception_object, v3);
  _Unwind_Resume(exception_object);
}

id RB::Device::tables_buffer(id *this)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _DWORD *v6;
  int v7;

  if (!this[22])
  {
    v3 = objc_msgSend(this[3], "newBufferWithBytesNoCopy:length:options:deallocator:", RB::Shader::Tables::shared((RB::Shader::Tables *)this), 24576, 0, 0);
    if (v3)
    {
      v4 = v3;
      v5 = operator new();
      RB::Buffer::Buffer(v5, v4, 24576);
      v6 = this[22];
      this[22] = (id)v5;
      if (v6)
      {
        v7 = v6[2] - 1;
        v6[2] = v7;
        if (!v7)
          (*(void (**)(_DWORD *))(*(_QWORD *)v6 + 8))(v6);
      }
    }
  }
  return this[22];
}

void sub_209ADE444(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

RB::ImageTexture *RB::ImageTexture::ImageTexture(RB::ImageTexture *this, const RB::ImageTexture *a2, RB::Heap *a3)
{
  const void *v4;
  unsigned int *v5;

  v4 = *(const void **)a2;
  *(_QWORD *)this = *(_QWORD *)a2;
  *((_DWORD *)this + 2) = *((_DWORD *)a2 + 2);
  *((_WORD *)this + 6) = *((_WORD *)a2 + 6);
  v5 = (unsigned int *)*((_QWORD *)a3 + 4);
  if (!v5)
  {
    RB::Heap::make_object_table((size_t *)a3);
    v5 = (unsigned int *)*((_QWORD *)a3 + 4);
  }
  RB::ObjectTable::retain(v5, v4);
  return this;
}

void RBDrawingStateEndCGContext(uint64_t a1, const char *a2, _RBDrawingState *a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  const void *v9;

  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(_DWORD *)(v3 + 344);
  if (!v4)
    RB::precondition_failure((RB *)"no active CGContext", a2);
  v5 = *(_QWORD *)(v3 + 336);
  if (!v5)
    v5 = v3 + 320;
  v6 = v5 + 16 * (v4 - 1);
  RB::ContextDelegate::end(*(RB::ContextDelegate **)(v6 + 8), a2, a3);
  RB::ContextDelegate::release_context((_QWORD *)v6);
  v7 = *(_DWORD *)(v3 + 344) - 1;
  *(_DWORD *)(v3 + 344) = v7;
  v8 = *(_QWORD *)(v3 + 336);
  if (!v8)
    v8 = v3 + 320;
  v9 = *(const void **)(v8 + 16 * v7);
  if (v9)
    CFRelease(v9);
}

void RB::ContextDelegate::end(RB::ContextDelegate *this, const char *a2, _RBDrawingState *a3)
{
  RB::XML::Document *v4;
  const void *v5;

  v4 = (RB::XML::Document *)*((_QWORD *)this + 55);
  if (v4)
  {
    RBDrawingStateDestroy(v4, a2, a3);
    *((_QWORD *)this + 55) = 0;
  }
  *((_QWORD *)this + 54) = 0;
  v5 = (const void *)*((_QWORD *)this + 68);
  if (v5)
    CFRelease(v5);
  *((_QWORD *)this + 68) = 0;
  *((_QWORD *)this + 69) = 0;
}

void RB::ContextDelegate::release_context(_QWORD *a1)
{
  _QWORD *v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  os_unfair_lock_lock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  v2 = (_QWORD *)RB::ContextDelegate::_contexts;
  if (RB::ContextDelegate::_contexts)
  {
    v3 = *(_QWORD *)(RB::ContextDelegate::_contexts + 144);
  }
  else
  {
    v2 = (_QWORD *)operator new();
    v2[16] = 0;
    v2[17] = 0;
    v3 = 8;
    v2[18] = 8;
    RB::ContextDelegate::_contexts = (uint64_t)v2;
  }
  v4 = v2[17];
  v5 = (uint64_t)v2;
  if (v3 < v4 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,8ul,unsigned long>::reserve_slow(v2, v4 + 1);
    v4 = v2[17];
    v5 = RB::ContextDelegate::_contexts;
  }
  v6 = (_QWORD *)v2[16];
  if (!v6)
    v6 = v2;
  v7 = &v6[2 * v4];
  *v7 = 0;
  v7[1] = 0;
  ++v2[17];
  v8 = *(_QWORD *)(v5 + 136);
  if (*(_QWORD *)(v5 + 128))
    v5 = *(_QWORD *)(v5 + 128);
  v9 = v5 + 16 * v8;
  v10 = *(_QWORD *)(v9 - 16);
  *(_QWORD *)(v9 - 16) = *a1;
  *a1 = v10;
  v11 = *(_QWORD *)(v9 - 8);
  *(_QWORD *)(v9 - 8) = a1[1];
  a1[1] = v11;
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
}

void sub_209ADE694(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  _Unwind_Resume(a1);
}

uint64_t RB::ContextDelegate::draw_glyphs(uint64_t a1, size_t a2, const char *a3, uint64_t a4, unsigned __int16 *a5, float64x2_t *a6, unint64_t a7)
{
  unint64_t v7;
  unsigned __int16 *v9;
  unsigned __int16 *v12;
  uint64_t v13;
  unsigned int TextDrawingMode;
  unsigned int v15;
  uint64_t Info;
  float64x2_t v17;
  float64x2_t v18;
  uint64_t CTM;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  int v29;
  int FontRenderingStyle;
  int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t ShouldDrawBitmapRuns;
  uint64_t v37;
  int v38;
  unint64_t v39;
  float64x2_t *v40;
  int v42;
  RB::DisplayList::State *v43;
  __n128 v44;
  __n128 v45;
  float v46;
  float v47;
  float32x2_t v48;
  float32x2_t v49;
  __n128 *v50;
  float64x2_t *v51;
  unint64_t v52;
  double v53;
  float64x2_t v54;
  CGColor *FillColor;
  RB::DisplayList::State *v56;
  float64x2_t v57;
  double v58;
  double v59;
  uint64_t LineCap;
  uint64_t LineJoin;
  double v62;
  double v63;
  uint64_t Pattern;
  CGFont *v65;
  const __CFDictionary *path_cache_for_stroking;
  double v67;
  float64x2_t v68;
  float64x2_t v69;
  float64_t *v70;
  void *v71;
  CGColor *StrokeColor;
  float64x2_t v73;
  float64x2_t v74;
  float64x2_t v75;
  float64x2_t v76;
  float64x2_t v77;
  RB *Font;
  size_t v79;
  float64x2_t v80;
  float64x2_t v81;
  _OWORD v82[6];
  float64x2_t v83[3];
  float64x2_t v84[3];
  float64x2_t v85[3];
  float64x2_t v86[3];
  float64x2_t v87;
  float64x2_t v88;
  float64x2_t v89;
  uint64_t v90;

  v7 = a7;
  v9 = a5;
  v79 = a2;
  v90 = *MEMORY[0x24BDAC8D0];
  v12 = a5;
  if (a7)
  {
    v13 = 2 * a7;
    v12 = a5;
    while ((__int16)*v12 != -1)
    {
      ++v12;
      v13 -= 2;
      if (!v13)
      {
        v12 = &a5[a7];
        break;
      }
    }
  }
  if (a7 != v12 - a5)
  {
    RB::ContextDelegate::draw_glyphs_removing_invalid(a1, v79, (uint64_t)a3, a4, a5, a6, a7);
    return 0;
  }
  TextDrawingMode = CGGStateGetTextDrawingMode();
  if ((TextDrawingMode & 0xFFFFFFFB) != 3)
  {
    v15 = TextDrawingMode;
    Info = CGContextDelegateGetInfo();
    RB::ContextDelegate::update(Info, a3, v79, 1);
    v17 = *(float64x2_t *)(a4 + 16);
    v18 = *(float64x2_t *)(a4 + 32);
    v86[0] = *(float64x2_t *)a4;
    v86[1] = v17;
    v86[2] = v18;
    CTM = CGGStateGetCTM();
    v20 = *(float64x2_t *)(CTM + 16);
    v21 = *(float64x2_t *)(CTM + 32);
    v85[0] = *(float64x2_t *)CTM;
    v85[1] = v20;
    v85[2] = v21;
    v22.f64[0] = RB::operator*(v86, v85);
    v87 = v22;
    v88 = v23;
    v89 = v24;
    v25.f64[0] = RB::operator*(&v87, (float64x2_t *)(Info + 384));
    v76 = v26;
    v77 = v25;
    v75 = v27;
    Font = (RB *)CGGStateGetFont();
    CGGStateGetFontSize();
    v81 = v28;
    if (v15 <= 5)
    {
      v29 = 1 << v15;
      if (((1 << v15) & 0x15) == 0)
      {
        v42 = 34;
        goto LABEL_28;
      }
      FontRenderingStyle = CGGStateGetFontRenderingStyle();
      v31 = MEMORY[0x20BD16184](v79);
      CGGStateGetFontDilation();
      v33 = v32;
      v35 = v34;
      ShouldDrawBitmapRuns = CGGStateGetShouldDrawBitmapRuns();
      LODWORD(v80.f64[0]) = ShouldDrawBitmapRuns;
      if ((*(_BYTE *)(Info + 460) & 4) != 0)
        v38 = v31 & FontRenderingStyle & 0xFFFFFFF7;
      else
        v38 = v31 & FontRenderingStyle;
      if (v7 >> 60)
      {
LABEL_27:
        v29 = 1 << v15;
        v42 = 38;
LABEL_28:
        if ((v29 & v42) != 0)
        {
          v56 = *(RB::DisplayList::State **)(Info + 440);
          v57 = *(float64x2_t *)(MEMORY[0x24BDBD8B8] + 16);
          v83[0] = *(float64x2_t *)MEMORY[0x24BDBD8B8];
          v83[1] = v57;
          v83[2] = *(float64x2_t *)(MEMORY[0x24BDBD8B8] + 32);
          objc_msgSend(*(id *)(Info + 8), "setEOFill:", 0, RBDrawingStateSetCTM(v56, v83));
          if (objc_msgSend(*(id *)(Info + 8), "renderingMode") >= 2)
            objc_msgSend(*(id *)(Info + 8), "setRenderingModeArgument:", *(float *)(Info + 556));
          v82[3] = v77;
          v82[4] = v76;
          v82[5] = v75;
          CGGStateGetAdjustedLineWidth();
          v59 = v58;
          LineCap = CGGStateGetLineCap();
          LineJoin = CGGStateGetLineJoin();
          CGGStateGetMiterLimit();
          v63 = v62;
          v87.f64[0] = 0.0;
          v86[0].f64[0] = 0.0;
          if (CGGStateGetLineDash())
            Pattern = CGDashGetPattern();
          else
            Pattern = 0;
          LODWORD(v80.f64[0]) = CGFontGetUnitsPerEm(Font);
          if ((*(_BYTE *)(Info + 460) & 8) != 0)
          {
            path_cache_for_stroking = 0;
            if (!v7)
              return 0;
          }
          else
          {
            path_cache_for_stroking = (const __CFDictionary *)RB::cg_font_get_path_cache_for_stroking(Font, v65);
            if (!v7)
              return 0;
          }
          v67 = v81.f64[0] / (double)SLODWORD(v80.f64[0]);
          v68 = vmulq_n_f64(v76, v67);
          v69 = vmulq_n_f64(v77, v67);
          v73 = v69;
          v74 = v68;
          v70 = &a6->f64[1];
          do
          {
            v69.f64[0] = *(v70 - 1);
            v80 = v69;
            v69.f64[0] = *v70;
            v81 = v69;
            RB::cg_font_get_glyph_path(Font, (CGFont *)*v9, path_cache_for_stroking, v85);
            if (*(_QWORD *)&v85[0].f64[0])
            {
              v71 = *(void **)(Info + 8);
              v82[0] = v73;
              v82[1] = v74;
              v82[2] = vmlaq_n_f64(vmlaq_n_f64(v75, v77, v80.f64[0]), v76, v81.f64[0]);
              objc_msgSend(v71, "setStrokedPath:transform:lineWidth:lineCap:lineJoin:miterLimit:dashPhase:dashPattern:dashCount:", *(_QWORD *)&v85[0].f64[0], v82, LineCap, LineJoin, Pattern, *(_QWORD *)&v87.f64[0], v59, v63, v86[0].f64[0]);
              StrokeColor = (CGColor *)CGGStateGetStrokeColor();
              RB::ContextDelegate::set_color_in_shape(Info, StrokeColor, (int)a3, v79, 1);
              if (*(_QWORD *)&v85[0].f64[0])
                CFRelease(*(CFTypeRef *)&v85[0].f64[0]);
            }
            ++v9;
            v70 += 2;
            --v7;
          }
          while (v7);
        }
        return 0;
      }
      v39 = 16 * v7;
      if (16 * v7 > 0x1000)
      {
        v40 = (float64x2_t *)malloc_type_malloc(16 * v7, 0x5DE33983uLL);
        if (!v40)
        {
LABEL_26:
          free(v40);
          goto LABEL_27;
        }
      }
      else
      {
        MEMORY[0x24BDAC7A8](ShouldDrawBitmapRuns, v37);
        v40 = (float64x2_t *)((char *)&v73 - ((v39 + 15) & 0xFFFFFFFFFFFFFFF0));
        bzero(v40, 16 * v7);
      }
      v87 = vmulq_n_f64(v77, v81.f64[0]);
      v88 = vmulq_n_f64(v76, v81.f64[0]);
      v89 = v75;
      v43 = *(RB::DisplayList::State **)(Info + 440);
      v84[0] = v87;
      v84[1] = v88;
      v84[2] = v75;
      if (objc_msgSend(*(id *)(Info + 8), "renderingMode", RBDrawingStateSetCTM(v43, v84)) >= 2)
      {
        v46 = *(float *)(Info + 556);
        v47 = RB::AffineTransform::scale(&v87);
        v48 = vrecpe_f32((float32x2_t)LODWORD(v47));
        v49 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v47), v48), v48);
        objc_msgSend(*(id *)(Info + 8), "setRenderingModeArgument:", (float)(v46 * vmul_f32(v49, vrecps_f32((float32x2_t)LODWORD(v47), v49)).f32[0]));
      }
      if (v7)
      {
        v50 = (__n128 *)v40;
        v51 = a6;
        v52 = v7;
        v53 = 1.0 / v81.f64[0];
        do
        {
          v54 = *v51++;
          v45 = (__n128)vmulq_n_f64(v54, v53);
          *v50++ = v45;
          --v52;
        }
        while (v52);
      }
      v44.n128_u64[0] = v33;
      v45.n128_u64[0] = v35;
      -[RBShape setGlyphs:positions:count:font:renderingStyle:dilation:shouldDrawBitmapRuns:](*(_QWORD *)(Info + 8), (size_t)v9, v40, v7, Font, v38, SLOBYTE(v80.f64[0]), v44, v45);
      objc_msgSend(*(id *)(Info + 8), "setEOFill:", 0);
      FillColor = (CGColor *)CGGStateGetFillColor();
      RB::ContextDelegate::set_color_in_shape(Info, FillColor, (int)a3, v79, 1);
      if (v39 <= 0x1000)
        goto LABEL_27;
      goto LABEL_26;
    }
  }
  return 0;
}

void sub_209ADED48(_Unwind_Exception *exception_object)
{
  void *v1;
  unint64_t v2;

  if (v2 > 0x1000)
    free(v1);
  _Unwind_Resume(exception_object);
}

void RB::ContextDelegate::update(uint64_t a1, const char *a2, uint64_t a3, char a4)
{
  uint64_t ClipStack;
  uint64_t SoftMask;
  uint64_t Style;
  int Identifier;
  int v10;
  int v11;
  uint64_t AllowsAntialiasing;
  float64x2_t *BaseCTM;
  int64x2_t v14;
  _RBDrawingState *v15;
  uint64_t v16;
  uint64_t v17;
  RB::DisplayList::State *v18;
  double x;
  double y;
  double width;
  double height;
  uint64_t Count;
  uint64_t v24;
  uint64_t i;
  uint64_t ShouldAntialias;
  unsigned int Mode;
  void *v28;
  uint64_t Path;
  uint64_t Image;
  uint64_t v31;
  double v32;
  double v33;
  float32x2_t v34;
  double v35;
  unint64_t v36;
  float64_t v37;
  float64x2_t v38;
  void *v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  double v43;
  void *v44;
  float32x2_t v45;
  float v46;
  float v47;
  RB::DisplayList::State *v48;
  uint64_t v49;
  const void *v50;
  CGPathRef v51;
  _OWORD *v52;
  __int128 v53;
  __int128 v54;
  RB::DisplayList::State *v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  int Type;
  uint64_t CTM;
  __int128 v61;
  __int128 v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  RB::DisplayList::State *v66;
  float v67;
  float v68;
  float32x2_t v69;
  float32x2_t v70;
  void *v71;
  uint64_t v72;
  char v73;
  uint64_t v74;
  float32x2_t v75;
  float32x2_t v76;
  float64x2_t v77[3];
  float64x2_t v78[3];
  _OWORD v79[6];
  float64x2_t v80;
  __int128 v81;
  __int128 v82;
  float64x2_t v83;
  float64x2_t v84;
  float64x2_t v85;
  CGRect v86;
  CGRect v87;

  if (!*(_QWORD *)(a1 + 432))
    RB::precondition_failure((RB *)"inactive drawing context", a2);
  ClipStack = CGGStateGetClipStack();
  SoftMask = CGGStateGetSoftMask();
  Style = CGGStateGetStyle();
  Identifier = CGClipStackGetIdentifier();
  v74 = SoftMask;
  if (SoftMask)
  {
    v10 = CGSoftMaskGetIdentifier();
    if (Style)
      goto LABEL_4;
LABEL_7:
    AllowsAntialiasing = CGRenderingStateGetAllowsAntialiasing();
    v11 = 0;
    goto LABEL_8;
  }
  v10 = 0;
  if (!Style)
    goto LABEL_7;
LABEL_4:
  v11 = CGStyleGetIdentifier();
  AllowsAntialiasing = CGRenderingStateGetAllowsAntialiasing();
  BaseCTM = (float64x2_t *)CGRenderingStateGetBaseCTM();
  v14 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 496), BaseCTM[1]), (int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 480), *BaseCTM)), (int8x16_t)vceqq_f64(*(float64x2_t *)(a1 + 512), BaseCTM[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v14, 1), (int8x16_t)v14).u64[0] & 0x8000000000000000) == 0)
    *(_DWORD *)(a1 + 476) = 0;
LABEL_8:
  if (*(_DWORD *)(a1 + 464) == Identifier
    && (!ClipStack || *(unsigned __int8 *)(a1 + 468) == (_DWORD)AllowsAntialiasing)
    && *(_DWORD *)(a1 + 472) == v10
    && *(_DWORD *)(a1 + 476) == v11)
  {
    if (!*(_QWORD *)(a1 + 440))
    {
      v15 = RBDrawingStateInit(*(RB::DisplayList::State **)(a1 + 432));
      *(_QWORD *)(a1 + 440) = v15;
      if (!*(_DWORD *)(a1 + 528))
      {
        v16 = 1;
        RBDrawingStateSetDefaultColorSpace((uint64_t)v15, 1u);
        if ((AllowsAntialiasing & 1) == 0)
          goto LABEL_66;
        goto LABEL_63;
      }
    }
    goto LABEL_58;
  }
  v18 = *(RB::DisplayList::State **)(a1 + 432);
  v17 = *(_QWORD *)(a1 + 440);
  v72 = Style;
  if (v17)
    RBDrawingStateAssign(v17, (uint64_t)v18);
  else
    *(_QWORD *)(a1 + 440) = RBDrawingStateInit(v18);
  v73 = a4;
  if (!*(_DWORD *)(a1 + 528))
    RBDrawingStateSetDefaultColorSpace(*(_QWORD *)(a1 + 440), 1u);
  *(_DWORD *)(a1 + 464) = Identifier;
  *(_BYTE *)(a1 + 468) = AllowsAntialiasing;
  *(_DWORD *)(a1 + 472) = v10;
  *(_DWORD *)(a1 + 476) = v11;
  if ((CGClipStackIsInfinite() & 1) == 0)
  {
    CGClipStackGetRect();
    x = v86.origin.x;
    y = v86.origin.y;
    width = v86.size.width;
    height = v86.size.height;
    if (!CGRectIsInfinite(v86))
    {
      objc_msgSend(*(id *)(a1 + 8), "setRect:", x, y, width, height);
      objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", AllowsAntialiasing);
      RBDrawingStateClipShape(*(RB::DisplayList::State **)(a1 + 440), *(_QWORD *)(a1 + 8), 0);
    }
    Count = CGClipStackGetCount();
    if (Count)
    {
      v24 = Count;
      for (i = 0; i != v24; ++i)
      {
        CGClipStackGetClipAtIndex();
        if ((_DWORD)AllowsAntialiasing)
          ShouldAntialias = CGClipGetShouldAntialias();
        else
          ShouldAntialias = 0;
        Mode = CGClipGetMode();
        switch(CGClipGetType())
        {
          case 0u:
            if (Mode > 1)
            {
              if (Mode == 2)
              {
                CGClipGetRect();
                v51 = CGPathCreateWithRect(v87, 0);
                CGClipGetStroke();
                RB::ContextDelegate::set_stroked_clip(a1, (uint64_t)v51);
                if (v51)
                  CFRelease(v51);
              }
            }
            else
            {
              v28 = *(void **)(a1 + 8);
              CGClipGetRect();
              objc_msgSend(v28, "setRect:");
            }
            goto LABEL_45;
          case 2u:
            Path = CGClipGetPath();
            if (Mode > 1)
            {
              if (Mode == 2)
              {
                CGClipGetStroke();
                RB::ContextDelegate::set_stroked_clip(a1, Path);
              }
            }
            else
            {
              objc_msgSend(*(id *)(a1 + 8), "setPath:", Path);
              objc_msgSend(*(id *)(a1 + 8), "setEOFill:", Mode == 1);
            }
LABEL_45:
            objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", ShouldAntialias);
            RBDrawingStateClipShape(*(RB::DisplayList::State **)(a1 + 440), *(_QWORD *)(a1 + 8), 0);
            break;
          case 3u:
            CGClipGetMask();
            Image = CGClipMaskGetImage();
            if (Image)
            {
              v31 = Image;
              CGClipMaskGetRect();
              *(float *)&v32 = v32;
              *(float *)&v33 = v33;
              v34.f32[0] = *(double *)&v34;
              *(float *)&v35 = v35;
              v76 = (float32x2_t)__PAIR64__(LODWORD(v33), LODWORD(v32));
              *(double *)&v36 = v34.f32[0];
              v34.i32[1] = LODWORD(v35);
              v75 = v34;
              v37 = (float)-*(float *)&v35;
              *((float *)&v32 + 1) = *(float *)&v33 + *(float *)&v35;
              v38.f64[0] = 0.0;
              v38.f64[1] = v37;
              v83 = (float64x2_t)v36;
              v84 = v38;
              v85 = vcvtq_f64_f32(*(float32x2_t *)&v32);
              CGClipMaskGetMatrix();
              v80 = (float64x2_t)v79[3];
              v81 = v79[4];
              v82 = v79[5];
              v39 = *(void **)(a1 + 16);
              *(double *)&v40 = RB::operator*(&v83, &v80);
              v79[0] = v40;
              v79[1] = v41;
              v79[2] = v42;
              LODWORD(v40) = 1065353216;
              LODWORD(v41) = 1065353216;
              LODWORD(v42) = 1065353216;
              LODWORD(v43) = 1065353216;
              objc_msgSend(v39, "setImage:transform:interpolation:tintColor:flags:", v31, v79, 1, 0, *(double *)&v40, *(double *)&v41, *(double *)&v42, v43);
              v44 = *(void **)(a1 + 8);
              v45 = RB::operator*(&v80, v76, v75);
              objc_msgSend(v44, "setRect:", v45.f32[0], v45.f32[1], v46, v47);
              objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", ShouldAntialias);
              v48 = RBDrawingStateBeginLayer(*(RB::DisplayList::State **)(a1 + 440), 0);
              RBDrawingStateDrawShape((uint64_t)v48, *(_QWORD *)(a1 + 8), *(float16x4_t **)(a1 + 16), 0, 1.0);
              RBDrawingStateClipLayer(*(_QWORD *)(a1 + 440), v48, 0, 1.0);
            }
            break;
          case 4u:
            CGClipGetTextClipping();
            v49 = CGTextClippingCreatePath();
            if (v49)
            {
              v50 = (const void *)v49;
              if (Mode > 1)
              {
                if (Mode == 2)
                {
                  CGClipGetStroke();
                  RB::ContextDelegate::set_stroked_clip(a1, (uint64_t)v50);
                }
              }
              else
              {
                objc_msgSend(*(id *)(a1 + 8), "setPath:", v49);
                objc_msgSend(*(id *)(a1 + 8), "setEOFill:", Mode == 1);
              }
              objc_msgSend(*(id *)(a1 + 8), "setAntialiased:", ShouldAntialias);
              RBDrawingStateClipShape(*(RB::DisplayList::State **)(a1 + 440), *(_QWORD *)(a1 + 8), 0);
              CFRelease(v50);
            }
            break;
          default:
            continue;
        }
      }
    }
  }
  if (v74)
    RB::ContextDelegate::clip_soft_mask(a1);
  a4 = v73;
  if (!v72)
    goto LABEL_58;
  v52 = (_OWORD *)CGRenderingStateGetBaseCTM();
  v53 = v52[1];
  v54 = v52[2];
  *(_OWORD *)(a1 + 480) = *v52;
  *(_OWORD *)(a1 + 496) = v53;
  *(_OWORD *)(a1 + 512) = v54;
  v55 = *(RB::DisplayList::State **)(a1 + 440);
  v56.f64[0] = RB::operator*((float64x2_t *)(a1 + 480), (float64x2_t *)(a1 + 384));
  v78[0] = v56;
  v78[1] = v57;
  v78[2] = v58;
  RBDrawingStateSetCTM(v55, v78);
  Type = CGStyleGetType();
  if (Type == 4)
  {
    RB::ContextDelegate::add_color_matrix_style(a1);
    if ((AllowsAntialiasing & 1) == 0)
      goto LABEL_65;
    goto LABEL_63;
  }
  if (Type != 3)
  {
    if (Type == 1)
    {
      RB::ContextDelegate::add_shadow_style(a1);
      if ((AllowsAntialiasing & 1) == 0)
        goto LABEL_65;
      goto LABEL_63;
    }
LABEL_58:
    if (!(_DWORD)AllowsAntialiasing)
      goto LABEL_65;
    goto LABEL_63;
  }
  RB::ContextDelegate::add_gaussian_blur_style(a1);
  if ((AllowsAntialiasing & 1) == 0)
  {
LABEL_65:
    v16 = 1;
    goto LABEL_66;
  }
LABEL_63:
  if (!CGGStateGetShouldAntialias())
    goto LABEL_65;
  v16 = *(unsigned int *)(a1 + 552);
LABEL_66:
  objc_msgSend(*(id *)(a1 + 8), "setRenderingMode:", v16);
  if ((a4 & 1) == 0)
  {
    CTM = CGGStateGetCTM();
    v61 = *(_OWORD *)(CTM + 16);
    v62 = *(_OWORD *)(CTM + 32);
    v80 = *(float64x2_t *)CTM;
    v81 = v61;
    v82 = v62;
    v63.f64[0] = RB::operator*(&v80, (float64x2_t *)(a1 + 384));
    v83 = v63;
    v84 = v64;
    v85 = v65;
    v66 = *(RB::DisplayList::State **)(a1 + 440);
    v77[0] = v63;
    v77[1] = v64;
    v77[2] = v65;
    RBDrawingStateSetCTM(v66, v77);
    if (v16 >= 2)
    {
      v67 = *(float *)(a1 + 556);
      v68 = RB::AffineTransform::scale(&v83);
      v69 = vrecpe_f32((float32x2_t)LODWORD(v68));
      v70 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v68), v69), v69);
      objc_msgSend(*(id *)(a1 + 8), "setRenderingModeArgument:", (float)(v67 * vmul_f32(v70, vrecps_f32((float32x2_t)LODWORD(v68), v70)).f32[0]));
    }
  }
  v71 = *(void **)(a1 + 544);
  if (v71)
    RBDrawingStateSetAttribute(*(RB::DisplayList::State **)(a1 + 440), v71, 1);
}

void sub_209ADF488(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

double RBDrawingStateSetCTM(RB::DisplayList::State *this, float64x2_t *a2)
{
  RB::XML::Document *v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  double result;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  int64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  const RB::AffineTransform *v18;
  float64x2_t v19[3];
  float64x2_t v20[3];
  float64x2_t v21[3];
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;

  v4 = *(RB::XML::Document **)(*((_QWORD *)this + 1) + 304);
  v5 = *a2;
  if (v4)
  {
    v9 = *((float64x2_t *)this + 2);
    v22 = *((float64x2_t *)this + 1);
    v23 = v9;
    v24 = *((float64x2_t *)this + 3);
    v10 = a2[1];
    v11 = a2[2];
    v12 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v23, v10), (int8x16_t)vceqq_f64(v22, v5)), (int8x16_t)vceqq_f64(v24, v11));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v12, 1), (int8x16_t)v12).u64[0] & 0x8000000000000000) == 0)
    {
      v20[0] = v5;
      v20[1] = v10;
      v20[2] = v11;
      v19[0] = (float64x2_t)RB::AffineTransform::inverse((RB::AffineTransform *)&v22);
      v19[1] = v13;
      v19[2] = v14;
      v15.f64[0] = RB::operator*(v20, v19);
      v21[0] = v15;
      v21[1] = v16;
      v21[2] = v17;
      RB::XML::DisplayList::concat_ctm(v4, (_RBDrawingState *)this, v21, v18);
      v5 = *a2;
    }
  }
  v6 = a2[1];
  v7 = a2[2];
  v22 = v5;
  v23 = v6;
  v24 = v7;
  *(_QWORD *)&result = RB::DisplayList::State::set_ctm(this, (const RB::AffineTransform *)&v22).n128_u64[0];
  return result;
}

__n128 RB::DisplayList::State::set_ctm(RB::DisplayList::State *this, const RB::AffineTransform *a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 1);
  *((_OWORD *)this + 3) = v3;
  *((__n128 *)this + 1) = result;
  *((_QWORD *)this + 14) = 0;
  *((_DWORD *)this + 37) = -1;
  return result;
}

void RB::ContextDelegate::set_color_in_shape(uint64_t a1, CGColorRef color, int a3, uint64_t a4, int a5)
{
  CGPatternRef Pattern;
  CGPattern *v9;
  uint64_t CTM;
  float64x2_t v11;
  __int128 v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  uint64_t BaseCTM;
  float64x2_t v17;
  __int128 v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  uint64_t Shading;
  CGShading *v23;
  int64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  _BOOL4 v28;
  float64x2_t *v29;
  float64x2_t v30;
  float64x2_t *v31;
  float64x2_t v32;
  float64x2_t *v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  uint64_t v38;
  uint64_t v39;
  float16x4_t *v40;
  double v41;
  float v42;
  unsigned int v43;
  unsigned int v44;
  int IsColored;
  int v46;
  int v47;
  int v48;
  float v49;
  CGColor *PatternBaseColor;
  double v51;
  int v52;
  int v53;
  float v54;
  float v55;
  double v56;
  double v57;
  double v58;
  double v59;
  CGImage *Image;
  __int128 v61;
  CGImage *v62;
  float v63;
  float Width;
  float Height;
  float32x2_t v66;
  float64x2_t v67;
  float64x2_t v68;
  float64x2_t v69;
  float64x2_t v70;
  double v71;
  double v72;
  double v73;
  int64x2_t v74;
  int8x16_t v75;
  float64x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  _BOOL4 v79;
  float64x2_t *v80;
  float64x2_t v81;
  float64x2_t *v82;
  float64x2_t v83;
  float64x2_t *v84;
  float64x2_t v85;
  void *v86;
  uint64_t v87;
  uint64_t v88;
  float16x4_t *v89;
  double v90;
  float v91;
  unsigned int CompositeOperation;
  unsigned int v93;
  float64_t v94;
  float64x2_t v95;
  float64_t v96;
  float64x2_t v97;
  float64_t v98;
  float64_t v99;
  float64x2_t v100;
  double v101;
  float64x2_t v102;
  double v103;
  int32x4_t v104;
  RB *v105;
  size_t v106;
  size_t v107;
  uint32_t v108;
  CGColorSpace *v109;
  CGContext *v110;
  CGContext *v111;
  int32x2_t v112;
  int64x2_t v113;
  RB *v114;
  CGColorSpace *v115;
  CGColorSpace *v116;
  CGColor *v117;
  int32x2_t v118;
  uint32x2_t v119;
  int8x8_t v120;
  int8x8_t v121;
  int8x8_t v122;
  int8x8_t v123;
  int32x2_t v124;
  uint32x2_t v125;
  int8x8_t v126;
  float32x2_t v127;
  float32x2_t v128;
  float v129;
  unint64_t v130;
  float64x2_t v131;
  _BOOL4 v132;
  float64x2_t *v133;
  float64x2_t v134;
  float64x2_t *v135;
  float64x2_t v136;
  float64x2_t *v137;
  float64x2_t v138;
  float64x2_t v139;
  float64x2_t v140;
  float64x2_t v141;
  CGImageRef v142;
  void *v143;
  double v144;
  double v145;
  uint64_t v146;
  uint64_t v147;
  float16x4_t *v148;
  double v149;
  float v150;
  unsigned int v151;
  unsigned int v152;
  __int128 v153;
  _OWORD v155[6];
  int32x2_t v156;
  int32x2_t v157;
  _OWORD v158[3];
  float64x2_t v159[3];
  float64x2_t v160;
  float64x2_t v161;
  float64x2_t v162;
  float64x2_t v163;
  float64x2_t v164;
  float64x2_t v165;
  float64x2_t v166;
  float64x2_t v167;
  float64x2_t v168;
  float64x2_t v169;
  float64x2_t v170;
  float64x2_t v171;
  float64x2_t v172;
  float64x2_t v173;
  _OWORD v174[2];
  CGSize v175;
  CGRect v176;
  CGRect v177;

  Pattern = CGColorGetPattern(color);
  if (Pattern)
  {
    v9 = Pattern;
    CTM = CGGStateGetCTM();
    v11 = *(float64x2_t *)(CTM + 16);
    v12 = *(_OWORD *)(CTM + 32);
    v172 = *(float64x2_t *)CTM;
    v173 = v11;
    v174[0] = v12;
    v13.f64[0] = RB::operator*(&v172, (float64x2_t *)(a1 + 384));
    v169 = v13;
    v170 = v14;
    v171 = v15;
    BaseCTM = CGRenderingStateGetBaseCTM();
    v17 = *(float64x2_t *)(BaseCTM + 16);
    v18 = *(_OWORD *)(BaseCTM + 32);
    v172 = *(float64x2_t *)BaseCTM;
    v173 = v17;
    v174[0] = v18;
    v19.f64[0] = RB::operator*(&v172, (float64x2_t *)(a1 + 384));
    v166 = v19;
    v167 = v20;
    v168 = v21;
    Shading = CGPatternGetShading();
    if (Shading)
    {
      v23 = (CGShading *)Shading;
      CGPatternGetMatrix();
      v163 = v172;
      v164 = v173;
      v165 = (float64x2_t)v174[0];
      v24 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v167, v170), (int8x16_t)vceqq_f64(v166, v169)), (int8x16_t)vceqq_f64(v168, v171));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v24, 1), (int8x16_t)v24).u64[0] & 0x8000000000000000) == 0)
      {
        v25.f64[0] = RB::operator*(&v163, &v166);
        v160 = v25;
        v161 = v26;
        v162 = v27;
        v172 = v169;
        v173 = v170;
        v174[0] = v171;
        v28 = RB::AffineTransform::invert((RB::AffineTransform *)&v172);
        v29 = &v172;
        if (!v28)
          v29 = &v169;
        v30 = *v29;
        if (v28)
          v31 = &v173;
        else
          v31 = &v170;
        v32 = *v31;
        if (v28)
          v33 = (float64x2_t *)v174;
        else
          v33 = &v171;
        v34 = *v33;
        v172 = v30;
        v173 = v32;
        v174[0] = v34;
        v35.f64[0] = RB::operator*(&v160, &v172);
        v163 = v35;
        v164 = v36;
        v165 = v37;
      }
      if (a5)
      {
        if ((RB::ContextDelegate::draw_shading_in_shape(a1, a3, v23, &v163) & 1) != 0)
          return;
      }
      else
      {
        CGShadingGetBounds();
        if (CGRectIsInfinite(v176)
          && (RB::ContextDelegate::set_shading((RB::ContextDelegate *)a1, v23, (const RB::AffineTransform *)&v163) & 1) != 0)
        {
          return;
        }
      }
    }
    IsColored = CGPatternIsColored();
    v46 = 1065353216;
    v47 = 1065353216;
    v48 = 1065353216;
    v49 = 1.0;
    if ((IsColored & 1) == 0)
    {
      PatternBaseColor = (CGColor *)CGColorGetPatternBaseColor();
      if (PatternBaseColor)
      {
        v51 = RBColorFromCGColor2(PatternBaseColor, *(_DWORD *)(a1 + 528));
        v46 = LODWORD(v51);
        v47 = v52;
        v48 = v53;
        v49 = v54;
      }
    }
    v55 = CGColorGetAlpha(color) * v49;
    CGGStateGetPatternPhase();
    v57 = v56;
    v59 = v58;
    Image = (CGImage *)CGPatternGetImage();
    if (Image)
    {
      v62 = Image;
      *(float *)&v61 = v57;
      v153 = v61;
      Width = (float)CGImageGetWidth(Image);
      Height = (float)CGImageGetHeight(v62);
      CGPatternGetMatrix();
      v163 = v172;
      v164 = v173;
      v165 = (float64x2_t)v174[0];
      v66.i32[0] = v153;
      v63 = v59;
      v66.f32[1] = Height + v63;
      v67.f64[0] = 0.0;
      v67.f64[1] = (float)-Height;
      v172 = (float64x2_t)COERCE_UNSIGNED_INT64(Width);
      v173 = v67;
      v174[0] = vcvtq_f64_f32(v66);
      v68.f64[0] = RB::operator*(&v172, &v163);
      HIDWORD(v72) = HIDWORD(v170.f64[0]);
      v160 = v68;
      v161 = v69;
      v162 = v70;
      HIDWORD(v73) = HIDWORD(v171.f64[0]);
      v74 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v167, v170), (int8x16_t)vceqq_f64(v166, v169)), (int8x16_t)vceqq_f64(v168, v171));
      v75 = (int8x16_t)vdupq_laneq_s64(v74, 1);
      if ((vandq_s8(v75, (int8x16_t)v74).u64[0] & 0x8000000000000000) == 0)
      {
        v76.f64[0] = RB::operator*(&v160, &v166);
        v159[0] = v76;
        v159[1] = v77;
        v159[2] = v78;
        v172 = v169;
        v173 = v170;
        v174[0] = v171;
        v79 = RB::AffineTransform::invert((RB::AffineTransform *)&v172);
        if (v79)
          v80 = &v172;
        else
          v80 = &v169;
        v81 = *v80;
        if (v79)
          v82 = &v173;
        else
          v82 = &v170;
        v83 = *v82;
        if (v79)
          v84 = (float64x2_t *)v174;
        else
          v84 = &v171;
        v85 = *v84;
        v172 = v81;
        v173 = v83;
        v174[0] = v85;
        v68.f64[0] = RB::operator*(v159, &v172);
        v160 = v68;
        v161 = v69;
        v162 = v70;
      }
      v86 = *(void **)(a1 + 16);
      v158[0] = v68;
      v158[1] = v69;
      v158[2] = v70;
      v75.i32[0] = v46;
      LODWORD(v73) = v47;
      LODWORD(v72) = v48;
      *(float *)&v71 = v55;
      objc_msgSend(v86, "setTiledImage:transform:sourceRect:interpolation:tintColor:flags:", v62, v158, 1, IsColored ^ 1u, 0.0, 0.0, 1.0, 1.0, *(double *)v75.i64, v73, v72, v71, v153);
      if (a5)
      {
        v87 = *(_QWORD *)(a1 + 440);
        v88 = *(_QWORD *)(a1 + 8);
        v89 = *(float16x4_t **)(a1 + 16);
        CGGStateGetAlpha();
        v91 = v90;
        if (!*(_QWORD *)(a1 + 360))
          v91 = *(float *)(a1 + 456) * v91;
        CompositeOperation = CGGStateGetCompositeOperation();
        if (CompositeOperation > 0x1B)
          v93 = 0;
        else
        RBDrawingStateDrawShape(v87, v88, v89, v93, v91);
      }
    }
    else
    {
      objc_msgSend(*(id *)(a1 + 8), "boundingRect");
      v95.f64[1] = v94;
      v97.f64[1] = v96;
      *(float32x2_t *)&v159[0].f64[0] = RB::operator*(&v169, vcvt_f32_f64(v95), vcvt_f32_f64(v97));
      v159[0].f64[1] = v98;
      RBDrawingStateGetDeviceClipBoundingBox(*(_QWORD *)(a1 + 440));
      v100.f64[1] = v99;
      v102.f64[1] = v101;
      RB::Rect::intersect((float32x2_t *)v159, vcvt_f32_f64(v100), vcvt_f32_f64(v102), v102.f64[0], v101, v103, v104);
      RB::Bounds::Bounds(&v156, *(float32x2_t *)&v159[0].f64[0], *(float32x2_t *)&v159[0].f64[1]);
      v106 = v157.i32[0];
      v107 = v157.i32[1];
      if (IsColored)
      {
        v108 = 8194;
        v109 = (CGColorSpace *)RB::srgb_colorspace(v105);
      }
      else
      {
        v109 = 0;
        v108 = 7;
      }
      v110 = CGBitmapContextCreate(0, v106, v107, 8uLL, 0, v109, v108);
      if (v110)
      {
        v111 = v110;
        CGContextTranslateCTM(v110, (double)-v156.i32[0], (double)-v156.i32[1]);
        v112 = vneg_s32(v156);
        v113.i64[0] = v112.i32[0];
        v113.i64[1] = v112.i32[1];
        v155[3] = v166;
        v155[4] = v167;
        v155[5] = vaddq_f64(v168, vcvtq_f64_s64(v113));
        CGContextSetBaseCTM();
        v175.width = v57;
        v175.height = v59;
        CGContextSetPatternPhase(v111, v175);
        v114 = (RB *)CGContextSetCompositeOperation();
        if ((IsColored & 1) != 0)
          v115 = 0;
        else
          v115 = (CGColorSpace *)RB::srgb_colorspace(v114);
        v116 = CGColorSpaceCreatePattern(v115);
        v117 = CGColorCreateWithPattern(v116, v9, RB::ContextDelegate::set_color_in_shape(CGColor *,CGGState *,CGRenderingState *,BOOL)::components);
        CGContextSetFillColorWithColor(v111, v117);
        v118.i32[0] = 0;
        v119 = (uint32x2_t)vceq_s32(v157, (int32x2_t)0x8000000080000000);
        v120 = (int8x8_t)vdup_lane_s32(vcgt_s32(v118, (int32x2_t)vpmin_u32(v119, v119)), 0);
        v121 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
        v122 = vbsl_s8(v120, v121, (int8x8_t)vcvt_f32_s32(v157));
        v123 = vbsl_s8(v120, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v156));
        v177.origin.x = *(float *)v123.i32;
        v177.origin.y = *(float *)&v123.i32[1];
        v177.size.width = *(float *)v122.i32;
        v177.size.height = *(float *)&v122.i32[1];
        CGContextFillRect(v111, v177);
        v124.i32[0] = 0;
        v125 = (uint32x2_t)vceq_s32(v157, (int32x2_t)0x8000000080000000);
        v126 = (int8x8_t)vdup_lane_s32(vcgt_s32(v124, (int32x2_t)vpmin_u32(v125, v125)), 0);
        v127 = (float32x2_t)vbsl_s8(v126, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v156));
        v128 = (float32x2_t)vbsl_s8(v126, v121, (int8x8_t)vcvt_f32_s32(v157));
        v129 = -v128.f32[1];
        v127.i32[1] = vadd_f32(v127, v128).i32[1];
        *(double *)&v130 = v128.f32[0];
        v131.f64[0] = 0.0;
        v131.f64[1] = v129;
        v163 = (float64x2_t)v130;
        v164 = v131;
        v165 = vcvtq_f64_f32(v127);
        v172 = v169;
        v173 = v170;
        v174[0] = v171;
        v132 = RB::AffineTransform::invert((RB::AffineTransform *)&v172);
        if (v132)
          v133 = &v172;
        else
          v133 = &v169;
        v134 = *v133;
        v135 = &v173;
        if (!v132)
          v135 = &v170;
        v136 = *v135;
        v137 = &v171;
        if (v132)
          v137 = (float64x2_t *)v174;
        v138 = *v137;
        v160 = v134;
        v161 = v136;
        v162 = v138;
        v139.f64[0] = RB::operator*(&v163, &v160);
        v163 = v139;
        v164 = v140;
        v165 = v141;
        v142 = CGBitmapContextCreateImage(v111);
        v143 = *(void **)(a1 + 16);
        v155[0] = v163;
        v155[1] = v164;
        v155[2] = v165;
        LODWORD(v144) = v48;
        *(float *)&v145 = v55;
        objc_msgSend(v143, "setImage:transform:interpolation:tintColor:flags:", v142, v155, 1, IsColored ^ 1u, COERCE_DOUBLE(__PAIR64__(HIDWORD(v165.f64[0]), v46)), COERCE_DOUBLE(__PAIR64__(HIDWORD(v164.f64[0]), v47)), v144, v145);
        if (a5)
        {
          v146 = *(_QWORD *)(a1 + 440);
          v147 = *(_QWORD *)(a1 + 8);
          v148 = *(float16x4_t **)(a1 + 16);
          CGGStateGetAlpha();
          v150 = v149;
          if (!*(_QWORD *)(a1 + 360))
            v150 = *(float *)(a1 + 456) * v150;
          v151 = CGGStateGetCompositeOperation();
          if (v151 > 0x1B)
            v152 = 0;
          else
          RBDrawingStateDrawShape(v146, v147, v148, v152, v150);
        }
        if (v142)
          CFRelease(v142);
        if (v117)
          CFRelease(v117);
        if (v116)
          CFRelease(v116);
        CFRelease(v111);
      }
    }
  }
  else
  {
    objc_msgSend(*(id *)(a1 + 16), "setColor:", RBColorFromCGColor2(color, *(_DWORD *)(a1 + 528)));
    if (a5)
    {
      v38 = *(_QWORD *)(a1 + 440);
      v39 = *(_QWORD *)(a1 + 8);
      v40 = *(float16x4_t **)(a1 + 16);
      CGGStateGetAlpha();
      v42 = v41;
      if (!*(_QWORD *)(a1 + 360))
        v42 = *(float *)(a1 + 456) * v42;
      v43 = CGGStateGetCompositeOperation();
      if (v43 > 0x1B)
        v44 = 0;
      else
      RBDrawingStateDrawShape(v38, v39, v40, v44, v42);
    }
  }
}

void sub_209ADFE14(_Unwind_Exception *a1)
{
  const void *v1;
  const void *v2;
  const void *v3;

  if (v1)
  {
    CFRelease(v1);
    if (!v3)
      goto LABEL_6;
  }
  else if (!v3)
  {
LABEL_6:
    CFRelease(v2);
    _Unwind_Resume(a1);
  }
  CFRelease(v3);
  goto LABEL_6;
}

float32x4_t RBColorFromComponents2(CGColorSpace *a1, float64x2_t *a2, unsigned int a3)
{
  CFStringRef Name;
  float32x4_t v7;
  unsigned __int8 v8;
  uint64_t v9;
  unsigned __int8 v10;
  float32x4_t v11;
  float32_t v12;
  int v13;
  int32x2_t v14;
  RB::Shader::Tables *v20;
  float32_t v21;
  __int16 v22;
  unsigned __int8 v23;
  int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  RB *v32;
  uint64_t v33;
  float32x4_t v34;
  const __CFString *v35;
  float64x2_t v36;
  double v37;

  Name = CGColorSpaceGetName(a1);
  if (Name)
  {
    if ((v8 & 1) == 0)
    {
      v35 = Name;
      Name = v35;
      if (v25)
      {
        v26 = *MEMORY[0x24BDBF278];
        RBColorFromComponents2::named_spaces[0] = *MEMORY[0x24BDBF318];
        unk_253EAF140 = v26;
        word_253EAF148 = 769;
        v27 = *MEMORY[0x24BDBF270];
        qword_253EAF150 = *MEMORY[0x24BDBF308];
        unk_253EAF158 = v27;
        word_253EAF160 = 768;
        v28 = *MEMORY[0x24BDBF240];
        qword_253EAF168 = *MEMORY[0x24BDBF228];
        unk_253EAF170 = v28;
        word_253EAF178 = 771;
        v29 = *MEMORY[0x24BDBF258];
        qword_253EAF180 = *MEMORY[0x24BDBF2F0];
        unk_253EAF188 = v29;
        word_253EAF190 = 770;
        v30 = *MEMORY[0x24BDBF248];
        qword_253EAF198 = *MEMORY[0x24BDBF290];
        unk_253EAF1A0 = v30;
        word_253EAF1A8 = 257;
        v31 = *MEMORY[0x24BDBF260];
        qword_253EAF1B0 = *MEMORY[0x24BDBF2F8];
        unk_253EAF1B8 = v31;
        word_253EAF1C0 = 256;
        Name = v35;
      }
    }
    v9 = 0;
    while (Name != (CFStringRef)RBColorFromComponents2::named_spaces[v9]
         && Name != (CFStringRef)RBColorFromComponents2::named_spaces[v9 + 1])
    {
      v9 += 3;
      if (v9 == 18)
        goto LABEL_7;
    }
    v13 = BYTE1(RBColorFromComponents2::named_spaces[v9 + 2]);
    if (v13 == 3)
    {
      *(float32x2_t *)v7.f32 = vcvt_f32_f64(*a2);
      v21 = a2[1].f64[0];
      v7.f32[2] = v21;
      v34 = v7;
    }
    else
    {
      if (v13 != 1)
        abort();
      v14 = *(int32x2_t *)&a2->f64[0];
      *(float *)v14.i32 = a2->f64[0];
      v34 = (float32x4_t)vdupq_lane_s32(v14, 0);
    }
    v20 = (RB::Shader::Tables *)LOBYTE(RBColorFromComponents2::named_spaces[v9 + 2]);
  }
  else
  {
LABEL_7:
    if ((v10 & 1) == 0)
    {
      if ((_DWORD)v32)
      {
        v33 = RB::extended_linear_srgb_colorspace(v32);
        RBColorFromComponents2::transform = MEMORY[0x20BD1565C](v33, 0);
      }
    }
    if (CGColorTransformConvertColorComponents())
    {
      *(float32x2_t *)v11.f32 = vcvt_f32_f64(v36);
      v12 = v37;
      v11.f32[2] = v12;
      v34 = v11;
    }
    else
    {
      __asm { FMOV            V0.4S, #1.0 }
      v34 = _Q0;
    }
    CGColorSpaceGetNumberOfComponents(a1);
    v20 = 0;
  }
  v22 = rb_color_space(a3);
  if ((v22 & 0xFF00) != 0)
    v23 = v22;
  else
    v23 = 1;
  if ((_DWORD)v20 != v23)
    return vcvtq_f32_f16(COERCE_FLOAT16X4_T(RB::Fill::Color::convert_color(v20, v23, (uint16x4_t)vcvt_f16_f32(v34))));
  return v34;
}

void sub_209AE0208(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double RBColorFromCGColor2(CGColor *a1, unsigned int a2)
{
  CGColorSpace *ColorSpace;
  float64x2_t *Components;
  double result;

  ColorSpace = CGColorGetColorSpace(a1);
  Components = (float64x2_t *)CGColorGetComponents(a1);
  *(_QWORD *)&result = RBColorFromComponents2(ColorSpace, Components, a2).u64[0];
  return result;
}

void sub_209AE0414(_Unwind_Exception *exception_object)
{
  unsigned int v1;
  void *v2;

  if (v1 >= 0x201)
    free(v2);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 128 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 128;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C224F18;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 128 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 128;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C224F18;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __int16 v16;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  __asm { FCVT            H0, S0 }
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C2266B8;
  *(_QWORD *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  if (*(_BYTE *)(a4 + 9))
    v16 = *(_WORD *)(a4 + 8);
  else
    v16 = a7;
  *(_QWORD *)(a1 + 112) = *(_QWORD *)a4;
  *(_WORD *)(a1 + 120) = v16;
  return a1;
}

__n128 RB::Coverage::Glyphs::Glyphs(RB::Coverage::Glyphs *this, const RB::Coverage::Glyphs *a2, RB::Heap *a3)
{
  __n128 *v4;
  __n128 result;

  v4 = (__n128 *)RB::Coverage::Glyphs::Glyphs((uint64_t)this, a3, *(CFTypeRef *)a2, *((_DWORD *)a2 + 4), (const void *)(*((_QWORD *)a2 + 1) + 8 * *((unsigned int *)a2 + 4)), *((const void **)a2 + 1), *((_DWORD *)a2 + 5), *((_BYTE *)a2 + 52), *((double *)a2 + 3), *((float *)a2 + 12), *((_BYTE *)a2 + 53));
  result = *((__n128 *)a2 + 2);
  v4[2] = result;
  return result;
}

unsigned int *RB::ObjectTable::retain(unsigned int *this, CFTypeRef cf)
{
  uint64_t v2;
  uint64_t v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  const void **v7;
  CFTypeRef v8;
  void *v9;
  unsigned int v10;
  unsigned int v11;

  if (cf)
  {
    v2 = (uint64_t)this;
    v3 = this[2];
    v4 = v3 - 16;
    if (v3 < 0x10)
      v4 = 0;
    v5 = -v4;
    if (v3 <= v5)
    {
LABEL_8:
      this = (unsigned int *)CFRetain(cf);
      v9 = this;
      v10 = *(_DWORD *)(v2 + 8);
      v11 = v10 + 1;
      if (*(_DWORD *)(v2 + 12) < v10 + 1)
      {
        this = (unsigned int *)RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(v2, v11);
        v10 = *(_DWORD *)(v2 + 8);
        v11 = v10 + 1;
      }
      *(_QWORD *)(*(_QWORD *)v2 + 8 * v10) = v9;
      *(_DWORD *)(v2 + 8) = v11;
    }
    else
    {
      v6 = v3 - v5;
      v7 = (const void **)(*(_QWORD *)this + 8 * v5);
      while (1)
      {
        v8 = *v7++;
        if (v8 == cf)
          break;
        if (!--v6)
          goto LABEL_8;
      }
    }
  }
  return this;
}

void *RB::vector<std::unique_ptr<RB::Symbol::Glyph::Layer,RB::Destroy<RB::Symbol::Glyph::Layer>>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,8ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,8ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(8 * a3);
    v6 = v5 >> 3;
    if (*a2 != (v5 >> 3))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

_QWORD *RB::Heap::make_object_table(size_t *this)
{
  _QWORD *result;

  result = RB::Heap::emplace<RBImage>(this);
  this[4] = (size_t)result;
  return result;
}

_QWORD *RB::Heap::emplace<RBImage>(size_t *a1)
{
  _QWORD *v1;

  v1 = (_QWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v1 + 2) > a1[3])
    v1 = (_QWORD *)RB::Heap::alloc_slow(a1, 0x10uLL, 7);
  else
    a1[2] = (size_t)(v1 + 2);
  *v1 = 0;
  v1[1] = 0;
  return v1;
}

uint64_t RBSymbolUpdateLayerPath(_DWORD *a1, float64x2_t *a2, char a3)
{
  const RB::Symbol::Presentation *v4;
  uint64_t v5;
  unsigned int v6;
  _DWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float32x2_t *v12;
  int v13;
  __int128 *v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  char v19;
  uint64_t *v20;
  unsigned int *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  float *v25;
  uint64_t v26;
  float v27;
  uint64_t v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  uint64_t v33;
  uint64_t v34;
  float32x2_t *v35;
  uint64_t v36;
  uint64_t v37;
  float v38;
  uint64_t info;
  float64x2_t v40;
  float64x2_t v41;
  float64x2_t v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  uint64_t v46;
  int v47;
  float32x2_t v48;
  int64x2_t v49;
  unsigned int *v51;
  unsigned int *v52;
  unsigned int v53;
  unsigned int v54;
  float64_t v55;
  unsigned int *v56;
  unsigned int v57;
  unsigned int v58;
  unsigned int *v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v62;
  path_ptr v63;

  v4 = *(const RB::Symbol::Presentation **)a1;
  v5 = *(_QWORD *)a1 + 8;
  v6 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~a1[2];
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v5 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v7 = (_DWORD *)*((_QWORD *)a1 + 2);
  v8 = *(_QWORD **)(v5 + 416 * v6 + 400);
  if (v8)
  {
    v7 = (_DWORD *)(*v8 + 8 * *((_QWORD *)a1 + 2));
    if (v7[1] != 1)
      goto LABEL_56;
    LODWORD(v7) = *v7;
  }
  v9 = v5 + 416 * v6;
  v10 = v9 + 16;
  if (*(_QWORD *)(v9 + 376))
    v11 = *(_QWORD *)(v9 + 376);
  else
    v11 = v9 + 16;
  v12 = (float32x2_t *)(v11 + 120 * v7);
  v13 = (*(_DWORD *)(*(_QWORD *)v12 + 84) >> 18) & 3;
  switch(v13)
  {
    case 3:
      goto LABEL_56;
    case 2:
      if ((a3 & 2) == 0)
        goto LABEL_56;
      break;
    case 0:
      v14 = &RBPathEmpty;
      return *(_QWORD *)v14;
  }
  v15 = v7;
  if ((a3 & 1) != 0)
  {
    v16 = v5 + 416 * v6;
    v17 = *(_DWORD *)(v16 + 384);
    v18 = ((_DWORD)v7 + 1);
    if (v18 < v17)
    {
      v19 = 0;
      v20 = (uint64_t *)(v9 + 376);
      v21 = (unsigned int *)(v16 + 384);
      v22 = -v17;
      v23 = ((_DWORD)v7 + 1);
      while (2)
      {
        v24 = 0;
        v25 = (float *)(v11 + 32 + 120 * v23);
        while (1)
        {
          v26 = *((_QWORD *)v25 - 4);
          if ((*(_BYTE *)(v26 + 86) & 0x40) != 0)
          {
            v27 = *(float *)(v26 + 72) <= 0.0 ? *v25 * *(v25 - 1) : *v25;
            if (v27 > 0.0)
              break;
          }
          ++v24;
          v25 += 30;
          if (!(v22 + (_DWORD)v23 + (_DWORD)v24))
          {
            if ((v19 & 1) == 0)
              goto LABEL_48;
            goto LABEL_29;
          }
        }
        if (v27 != 1.0)
          goto LABEL_56;
        v28 = v23 + v24 + 1;
        v29 = v22 + v23 + v24;
        v19 = 1;
        v23 = v28;
        if (v29 != -1)
          continue;
        break;
      }
LABEL_29:
      if ((a3 & 2) != 0)
      {
        v30 = operator new();
        *(_DWORD *)(v30 + 8) = 1;
        *(_QWORD *)v30 = off_24C229608;
        RB::Path::Storage::Storage((uint64_t)&v63, (const char *)0x90);
        RB::Path::Storage::Storage((RB::Path::Storage *)(v30 + 16), (const char *)0x90, (const RB::Path::Storage *)&v63);
        RB::Path::Storage::~Storage((RB::Path::Storage *)&v63);
        *(_QWORD *)&v60.f64[0] = v30;
        LOWORD(v63._p.info) = 3;
        RB::Path::Storage::append_element((RB::Path::Storage *)(v30 + 16), (const char *)0x14, 0, (int *)&v63);
        v31 = *v20;
        if (!*v20)
          v31 = v10;
        if (RB::Symbol::Presentation::Layer::append_path((float32x2_t *)(v31 + 120 * v15), (RB::Path::Storage *)(v30 + 16), v4))
        {
          v32 = *v21;
          if (v18 < *v21)
          {
            v33 = 120 * v18;
            do
            {
              v34 = *v20;
              if (!*v20)
                v34 = v10;
              v35 = (float32x2_t *)(v34 + v33);
              v36 = *(_QWORD *)(v34 + v33);
              if ((*(_BYTE *)(v36 + 86) & 0x40) != 0)
              {
                v37 = v34 + v33;
                v38 = *(float *)(v36 + 72) <= 0.0 ? *(float *)(v37 + 32) * *(float *)(v37 + 28) : *(float *)(v37 + 32);
                if (v38 > 0.0)
                {
                  RB::Path::Storage::append_element((RB::Path::Storage *)(*(_QWORD *)&v60.f64[0] + 16), (const char *)0x15, 0, 0);
                  if (!RB::Symbol::Presentation::Layer::append_path(v35, (RB::Path::Storage *)(*(_QWORD *)&v60.f64[0] + 16), v4))goto LABEL_67;
                  v32 = *v21;
                }
              }
              ++v18;
              v33 += 120;
            }
            while (v18 < v32);
          }
          RB::Path::Storage::append_element((RB::Path::Storage *)(*(_QWORD *)&v60.f64[0] + 16), (const char *)0x10, 0, 0);
          if (a2)
          {
            a2->f64[0] = 1.0;
            a2->f64[1] = 0.0;
            a2[1].f64[0] = 0.0;
            a2[1].f64[1] = 1.0;
            a2[2].f64[0] = 0.0;
            a2[2].f64[1] = 0.0;
          }
          info = RB::Symbol::Presentation::take_path((uint64_t)v4, (uint64_t *)&v60);
        }
        else
        {
LABEL_67:
          info = 1;
        }
        v55 = v60.f64[0];
        if (*(_QWORD *)&v60.f64[0])
        {
          v56 = (unsigned int *)(*(_QWORD *)&v60.f64[0] + 8);
          do
          {
            v57 = __ldxr(v56);
            v58 = v57 - 1;
          }
          while (__stlxr(v58, v56));
          if (!v58)
          {
            __dmb(9u);
            (*(void (**)(float64_t))(**(_QWORD **)&v55 + 8))(COERCE_FLOAT64_T(*(_QWORD *)&v55));
          }
        }
        return info;
      }
LABEL_56:
      v14 = &RBPathNull;
      return *(_QWORD *)v14;
    }
  }
LABEL_48:
  v40.f64[0] = RB::Symbol::Presentation::Layer::transform(v12, (uint64_t)v4);
  v60 = v40;
  v61 = v41;
  v62 = v42;
  v43.f64[0] = RB::Symbol::Glyph::Layer::content_transform(*(RB::Symbol::Glyph::Layer **)v12, &v60);
  v60 = v43;
  v61 = v44;
  v62 = v45;
  if (a2)
  {
    *a2 = v43;
    a2[1] = v44;
    a2[2] = v45;
  }
  else
  {
    v49 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v44, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v43, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v45));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v49, 1), (int8x16_t)v49).u64[0] & 0x8000000000000000) == 0)
      goto LABEL_56;
  }
  v46 = (uint64_t)*v12;
  v47 = (*(_DWORD *)(*(_QWORD *)v12 + 84) >> 18) & 3;
  if (v47 != 2)
  {
    if (v47 == 1)
    {
      LOBYTE(v59) = 0;
      v48.i32[0] = 0;
      v48.i32[1] = *(_DWORD *)(v11 + 120 * v15 + 52);
      RB::Symbol::Glyph::Layer::copy_path(v46, &v59, (uint64_t *)&v63, v48);
      if ((_BYTE)v59)
        RB::Symbol::Presentation::take_path(v4, &v63);
      info = (uint64_t)v63._p.info;
      RBPathRelease((uint64_t)v63._p.info, (uint64_t)v63._p.callbacks);
      return info;
    }
    goto LABEL_56;
  }
  v51 = (unsigned int *)operator new();
  v51[2] = 1;
  *(_QWORD *)v51 = off_24C229608;
  RB::Path::Storage::Storage((uint64_t)&v63, (const char *)0x90);
  RB::Path::Storage::Storage((RB::Path::Storage *)(v51 + 4), (const char *)0x90, (const RB::Path::Storage *)&v63);
  RB::Path::Storage::~Storage((RB::Path::Storage *)&v63);
  v59 = v51;
  if ((RB::Symbol::Glyph::Sublayers::append_path(**(RB::Symbol::Glyph::Sublayers ****)v12, (RB::Path::Storage *)(v51 + 4), *(_DWORD *)(**(_QWORD **)v12 + 272)) & 1) != 0)
  {
    info = RB::Symbol::Presentation::take_path((uint64_t)v4, (uint64_t *)&v59);
    v51 = v59;
    if (!v59)
      return info;
  }
  else
  {
    info = 1;
  }
  v52 = v51 + 2;
  do
  {
    v53 = __ldxr(v52);
    v54 = v53 - 1;
  }
  while (__stlxr(v54, v52));
  if (!v54)
  {
    __dmb(9u);
    (*(void (**)(unsigned int *))(*(_QWORD *)v51 + 8))(v51);
  }
  return info;
}

void sub_209AE0D4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, unsigned int *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;

  if (a11)
  {
    v19 = a11 + 2;
    do
    {
      v20 = __ldxr(v19);
      v21 = v20 - 1;
    }
    while (__stlxr(v21, v19));
    if (!v21)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)a11 + 8))(a11);
    }
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::Fill::Gradient::Gradient(uint64_t a1, RB::Heap *this, char a3, unint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, double a9, double a10, float a11, float a12)
{
  unint64_t v23;
  unint64_t v24;
  unsigned int v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  float v30;
  float32x4_t v35;
  int8x16_t v36;
  unint64_t v37;
  float v38;
  float v39;
  float v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  int16x8_t v44;
  unint64_t v45;
  float v46;
  float v47;
  float32x2_t v49;
  int8x8_t v50;
  uint64_t v51;
  uint64_t v52;
  float32x4_t v53;
  BOOL v55;
  float v56;
  float v57;
  int v58;
  uint64_t v59;
  float32x2_t v60;
  float32x2_t v61;
  float v62;
  double v63;
  unint64_t v64;
  double *v65;
  float v66;
  float64_t *v67;
  float64x2_t v68;
  float v69;
  float v70;
  int v71;
  float v72;
  float v73;
  float32x2_t v74;
  float32x2_t v75;
  uint32x2_t v76;
  float v77;

  *(_QWORD *)a1 = a4;
  v23 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  v24 = v23 + 16 * a4;
  if (v24 > *((_QWORD *)this + 3))
    v23 = RB::Heap::alloc_slow((size_t *)this, 16 * a4, 7);
  else
    *((_QWORD *)this + 2) = v24;
  *(_QWORD *)(a1 + 8) = v23;
  *(_QWORD *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = a9;
  *(double *)(a1 + 32) = a10;
  *(float *)(a1 + 40) = a11;
  *(float *)(a1 + 44) = a12;
  v25 = a8 & 0xFFFFFCFF;
  *(_BYTE *)(a1 + 52) = a3;
  *(_WORD *)(a1 + 53) = a6;
  *(_DWORD *)(a1 + 48) = a8 & 0xFFFFFCFF;
  if ((a8 & 0x300 & ((a8 & 0x300) - 1)) != 0)
    v26 = 0;
  else
    v26 = a7;
  *(_WORD *)(a1 + 55) = 1;
  if (v26)
  {
    v27 = 0;
    v28 = 0;
    v29 = 0;
    v30 = 1.0 / (float)(a4 - 1);
    __asm { FMOV            V3.4S, #1.0 }
    v35 = (float32x4_t)vdupq_n_s32(0x437F0000u);
    v36 = (int8x16_t)vdupq_n_s32(0x437F8000u);
    do
    {
      if (a4 == v29)
        break;
      if ((a8 & 0x200) != 0)
        v37 = v27;
      else
        v37 = v29;
      if ((a8 & 0x100) != 0)
        v37 = v28;
      v38 = v30 * (float)v29;
      v39 = *(double *)(v26 + 8 * v37);
      if (vabds_f32(v39, v38) > 0.001)
      {
        v25 |= 0x10000u;
        *(_DWORD *)(a1 + 48) = v25;
      }
      ++v29;
      if ((a8 & 0x100) != 0 && v29 < a4)
      {
        v40 = *(double *)(v26 + 8 * v37 + 8);
        if (fabsf((float)((float)(v30 * -0.5) - v38) + v40) > 0.001)
        {
          v25 |= 0x100u;
          *(_DWORD *)(a1 + 48) = v25;
        }
      }
      if ((a8 & 0x200) != 0 && v29 < a4)
      {
        v41 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*(float64x2_t *)(v26 + 8 * v37 + 8)), *(float64x2_t *)(v26 + 8 * v37 + 24));
        v42 = (float32x4_t)vbicq_s8((int8x16_t)v41, (int8x16_t)vcltzq_f32(v41));
        v43.i64[0] = 0x3F0000003F000000;
        v43.i64[1] = 0x3F0000003F000000;
        v44 = (int16x8_t)vcvtq_s32_f32((float32x4_t)vbslq_s8((int8x16_t)vcgtq_f32(v42, _Q3), v36, (int8x16_t)vmlaq_f32(v43, v35, v42)));
        *(int16x4_t *)v44.i8 = vmovn_s32((int32x4_t)v44);
        if (vmovn_s16(v44).u32[0] != -65536)
        {
          v25 |= 0x200u;
          *(_DWORD *)(a1 + 48) = v25;
        }
      }
      v28 += 2;
      v27 += 5;
    }
    while (((v25 ^ (a8 | 0x10000)) & 0x10300) != 0);
  }
  if (a4)
  {
    v45 = 0;
    v46 = -INFINITY;
    v47 = INFINITY;
    __asm { FMOV            V6.2S, #1.0 }
    v49 = (float32x2_t)vdup_n_s32(0x437F0000u);
    v50 = (int8x8_t)vdup_n_s32(0x437F8000u);
    while (1)
    {
      v51 = *(_QWORD *)(a1 + 8);
      v52 = 16 * v45;
      v53 = *(float32x4_t *)(a5 + 16 * v45);
      *(float16x4_t *)(v51 + 16 * v45) = vcvt_f16_f32(v53);
      v55 = v53.f32[3] == 1.0 && *(_BYTE *)(a1 + 55) != 0;
      *(_BYTE *)(a1 + 55) = v55;
      v56 = fminf(fminf(v53.f32[0], v53.f32[2]), v53.f32[1]);
      if (v56 < v47)
        v47 = v56;
      v57 = fmaxf(fmaxf(v53.f32[0], v53.f32[2]), v53.f32[1]);
      if (v46 < v57)
        v46 = v57;
      v58 = *(_DWORD *)(a1 + 48);
      if ((v58 & 0x10000) != 0)
        break;
      v59 = *(_QWORD *)a1 - 1;
      v60 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v59));
      v61 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v59), v60), v60);
      v62 = (float)v45
          * vmul_f32(v61, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(unint64_t)v59), v61)).f32[0];
LABEL_45:
      *(float *)(v51 + 16 * v45 + 8) = v62;
      v64 = v45 + 1;
      if ((v58 & 0x100) != 0)
      {
        if (v64 >= a4)
        {
          *(_DWORD *)(v51 + 16 * v45 + 12) = 1056964608;
        }
        else
        {
          v77 = (*(double *)(v26 + 16 * v45 + 8) - *(double *)(v26 + 16 * v45))
              / (*(double *)(v26 + 16 * v45 + 16) - *(double *)(v26 + 16 * v45));
          *(float *)(v51 + 16 * v45 + 12) = v77;
        }
      }
      else if ((v58 & 0x200) != 0)
      {
        if (v64 >= a4)
        {
          *(_DWORD *)(v51 + 16 * v45 + 12) = -65536;
        }
        else
        {
          v65 = (double *)(v26 + 40 * v45);
          v66 = v65[1];
          v67 = v65 + 2;
          v68.f64[0] = v65[4];
          v69 = v65[3];
          if (v66 < 0.0)
            v66 = 0.0;
          if (v66 <= 1.0)
            v70 = (float)(v66 * 255.0) + 0.5;
          else
            v70 = 255.5;
          v71 = (int)v70;
          if (v69 >= 0.0)
            v72 = v69;
          else
            v72 = 0.0;
          if (v72 <= 1.0)
            v73 = (float)(v72 * 255.0) + 0.5;
          else
            v73 = 255.5;
          v23 = (int)v73;
          v68.f64[1] = *v67;
          v74 = vcvt_f32_f64(v68);
          v75 = (float32x2_t)vbic_s8((int8x8_t)v74, (int8x8_t)vcltz_f32(v74));
          v76 = vshl_u32((uint32x2_t)vcvt_s32_f32((float32x2_t)vbsl_s8((int8x8_t)vcgt_f32(v75, _D6), v50, (int8x8_t)vmla_f32((float32x2_t)0x3F0000003F000000, v49, v75))), (uint32x2_t)0x800000018);
          *(_DWORD *)(v51 + 16 * v45 + 12) = v76.i32[0] | ((_DWORD)v23 << 16) | v71 | v76.i32[1];
        }
      }
      ++v45;
      if (v64 == a4)
        goto LABEL_67;
    }
    if ((a8 & 0x100) == 0)
    {
      if ((a8 & 0x200) == 0)
      {
        v63 = *(double *)(v26 + 8 * v45);
LABEL_44:
        v62 = v63;
        goto LABEL_45;
      }
      v52 = 40 * v45;
    }
    v63 = *(double *)(v26 + v52);
    goto LABEL_44;
  }
  v47 = INFINITY;
  v46 = -INFINITY;
LABEL_67:
  *(_BYTE *)(a1 + 56) = RB::required_color_depth((RB *)v23, v47, v46);
  return a1;
}

uint64_t RB::Fill::Gradient::Gradient(uint64_t a1, RB::Heap *a2, char a3, unint64_t a4, uint64_t a5, __int16 a6, uint64_t a7, int a8, double a9, double a10, float a11, float a12)
{
  return RB::Fill::Gradient::Gradient(a1, a2, a3, a4, a5, a6, a7, a8, a9, a10, a11, a12);
}

uint64_t set_gradient_color(uint64_t a1, uint64_t a2, float *a3, unsigned int a4)
{
  if (a2)
  {
    if (a2 != 1)
      return 0;
  }
  else
  {
    a3 = (float *)&RBColorClear;
  }
  -[RBFill _setColor:colorSpace:](a1, a4, *a3, a3[1], a3[2], a3[3]);
  return 1;
}

unsigned int *RBSymbolUpdateLayerDraw(uint64_t a1, RB::DisplayList::State *a2, uint64_t a3, char a4, float a5, float a6, float a7, float a8, float a9)
{
  RB::Symbol::Presentation *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;
  _DWORD *v21;
  unsigned int v22;
  const char *v23;
  _RBDrawingState *v24;
  _RBDrawingState *v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  unint64_t v31;
  uint64_t v32;
  uint64_t v33;
  float32x2_t *v34;
  uint64_t v35;
  float v36;
  uint64_t v37;
  float v38;
  RB::Symbol::Model **v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float64x2_t v44;
  __int128 v45;
  __int128 v46;
  _DWORD *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t *v50;
  uint64_t v51;
  uint64_t v52;
  float *v53;
  float v54;
  uint64_t v55;
  float64x2_t v56;
  __int128 v57;
  __int128 v58;
  float32x2_t v59;
  unsigned int v61;
  uint64_t v62;
  uint64_t v63;
  unsigned int *v64;
  uint64_t v65;
  unsigned int v66;
  unsigned int v67;
  _BOOL4 v68;
  float64x2_t v69;
  __int128 v70;
  __int128 v71;

  v16 = *(RB::Symbol::Presentation **)a1;
  v17 = *(_QWORD *)a1 + 8;
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v17 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v65 = v17;
  v66 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~*(_DWORD *)(a1 + 8);
  v18 = v17 + 416 * v66;
  v19 = *(_QWORD *)(a1 + 16);
  v20 = *(_QWORD **)(v18 + 400);
  if (v20)
  {
    v21 = (_DWORD *)(*v20 + 8 * *(_QWORD *)(a1 + 16));
    LODWORD(v19) = *v21;
    v22 = v21[1];
    v68 = v22 > 1;
  }
  else
  {
    v68 = 0;
    v22 = 1;
  }
  v25 = RBDrawingStateInit(a2);
  v61 = v19;
  v67 = v19 + v22;
  if ((a4 & 1) != 0)
  {
    v26 = v65 + 416 * v66;
    v27 = *(_DWORD *)(v26 + 384);
    if (v67 < v27)
    {
      v63 = v18;
      v64 = (unsigned int *)(v26 + 384);
      v28 = v65 + 416 * v66;
      v29 = v28 + 16;
      v30 = (_QWORD *)(v28 + 376);
      v31 = v19 + v22;
      v32 = 120 * v31;
      v62 = v28 + 16;
      do
      {
        if (*v30)
          v33 = *v30;
        else
          v33 = v29;
        v34 = (float32x2_t *)(v33 + v32);
        v35 = *(_QWORD *)(v33 + v32);
        if ((*(_BYTE *)(v35 + 86) & 0x40) != 0)
        {
          v36 = *(float *)(v35 + 72);
          v37 = v33 + v32;
          v38 = v36 <= 0.0 ? *(float *)(v37 + 32) * *(float *)(v37 + 28) : *(float *)(v37 + 32);
          if (v38 > 0.0)
          {
            v39 = (RB::Symbol::Model **)v18;
            v40 = v30;
            RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)(v33 + v32), v25, v39);
            v41 = a3;
            v42 = v33 + v32;
            v43 = *(_QWORD *)(v33 + v32);
            v44.f64[0] = RB::Symbol::Presentation::Layer::transform(v34, (uint64_t)v16);
            v69 = v44;
            v70 = v45;
            v71 = v46;
            v47 = (_DWORD *)(v42 + 52);
            a3 = v41;
            LODWORD(v45) = 0;
            DWORD1(v45) = *v47;
            RB::Symbol::Glyph::Layer::clip(v43, (RB::DisplayList::State *)v25, 1, &v69, v16, v38, *(float32x2_t *)&v45);
            v30 = v40;
            v29 = v62;
            v18 = v63;
            v27 = *v64;
          }
        }
        ++v31;
        v32 += 120;
      }
      while (v31 < v27);
    }
  }
  if (v61 < v67)
  {
    v48 = v65 + 416 * v66;
    v49 = v48 + 16;
    v50 = (uint64_t *)(v48 + 376);
    v51 = 120 * v61;
    do
    {
      v52 = *v50;
      if (!*v50)
        v52 = v49;
      v53 = (float *)(v52 + v51);
      v54 = a9;
      if (v68)
        v54 = (float)(*(float *)(*(_QWORD *)v53 + 72) * (float)(a9 * v53[6])) * v53[8];
      RB::Symbol::Presentation::Layer::set_animation_layer((RB::Symbol::Presentation::Layer *)v53, v25, (RB::Symbol::Model **)v18);
      v55 = *(_QWORD *)v53;
      v56.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)v53, (uint64_t)v16);
      v69 = v56;
      v70 = v57;
      v71 = v58;
      v59.i32[0] = 0;
      v59.f32[1] = v53[13];
      RB::Symbol::Glyph::Layer::draw(v55, (RB::DisplayList::State *)v25, a3, &v69, v16, a5, a6, a7, a8, v54, v59);
      v51 += 120;
      --v22;
    }
    while (v22);
  }
  return RBDrawingStateDestroy((RB::XML::Document *)v25, v23, v24);
}

void RB::Symbol::Presentation::draw(uint64_t a1, RB::DisplayList::State *a2, uint64_t a3)
{
  unsigned int v5;
  BOOL v6;
  size_t v7;
  _RBDrawingState *v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  RB::DisplayList::State *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t *v20;
  unsigned int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  float v26;
  RB::DisplayList::State *v27;
  _BYTE *v28;
  _RBDrawingState *v29;
  uint64_t v30;
  float64x2_t v31;
  __int128 v32;
  __int128 v33;
  size_t v34;
  _BYTE *v35;
  uint64_t v36;
  float32x2_t *v37;
  uint64_t v38;
  uint64_t v39;
  float32x2_t v40;
  float v41;
  uint64_t v42;
  float64x2_t v43;
  __int128 v44;
  __int128 v45;
  float32x2_t v46;
  _BYTE *v47;
  float v48;
  RB::DisplayList::State *v49;
  _BYTE *v50;
  uint64_t v51;
  float64x2_t v52;
  __int128 v53;
  __int128 v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  RB::Symbol::Model **v60;
  _QWORD v61[8];
  float64x2_t v62;
  __int128 v63;
  __int128 v64;
  _QWORD v65[6];
  __int128 v66;
  int v67;
  CFTypeRef cf;
  _BYTE __dst[64];
  _BYTE *v70;
  size_t v71;
  unint64_t v72;
  uint64_t v73;

  v73 = *MEMORY[0x24BDAC8D0];
  v5 = objc_msgSend((id)RBDrawingStateGetDisplayList((uint64_t)a2), "profile");
  v6 = rb_profile_supports_porter_duff_blending(v5);
  v65[0] = 0;
  v65[1] = v65;
  v65[2] = 0x6012000000;
  v65[3] = __Block_byref_object_copy__0;
  v65[4] = __Block_byref_object_dispose__0;
  v66 = RBColorWhite;
  v67 = 10;
  cf = 0;
  v9 = *(unsigned int *)(a1 + 848);
  if ((_DWORD)v9)
  {
    v10 = v6;
    v56 = a3;
    v55 = v6;
    do
    {
      v11 = v9 - 1;
      if (*(_QWORD *)(a1 + 840))
        v12 = *(_QWORD *)(a1 + 840);
      else
        v12 = a1 + 8;
      v13 = v11;
      v60 = (RB::Symbol::Model **)(v12 + 416 * v11);
      v70 = 0;
      v71 = 0;
      v72 = 8;
      v14 = v11;
      v58 = v11;
      if (v10)
      {
        v15 = v12;
        v16 = RBDrawingStateBeginLayer(a2, 0);
        v12 = v15;
      }
      else
      {
        v17 = v12 + 416 * v11;
        v18 = *(_DWORD *)(v17 + 384);
        v16 = a2;
        if (v18)
        {
          v7 = 0;
          v19 = v17 + 16;
          v57 = v12;
          v20 = (uint64_t *)(v12 + 416 * v13 + 376);
          v21 = v18 - 1;
          do
          {
            if (*v20)
              v22 = *v20;
            else
              v22 = v19;
            v23 = v21;
            v24 = (uint64_t *)(v22 + 120 * v21);
            if ((*(_BYTE *)(*v24 + 86) & 0x40) != 0)
            {
              v25 = v22 + 120 * v21;
              v26 = *(float *)(*v24 + 72) <= 0.0 ? *(float *)(v25 + 32) * *(float *)(v25 + 28) : *(float *)(v25 + 32);
              if (v26 > 0.0)
              {
                v27 = a2;
                if (v7)
                {
                  v28 = v70;
                  if (!v70)
                    v28 = __dst;
                  v27 = *(RB::DisplayList::State **)&v28[8 * v7 - 8];
                }
                v29 = RBDrawingStateInit(v27);
                LODWORD(v62.f64[0]) = *(_DWORD *)(*v24 + 68);
                HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
                RB::DisplayList::State::set_animation_layer((uint64_t)v29, &v62);
                v30 = *v24;
                v31.f64[0] = RB::Symbol::Presentation::Layer::transform((float32x2_t *)(v22 + 120 * v21), a1);
                v62 = v31;
                v63 = v32;
                v64 = v33;
                LODWORD(v32) = 0;
                DWORD1(v32) = *(_DWORD *)(v22 + 120 * v21 + 52);
                RB::Symbol::Glyph::Layer::clip(v30, (RB::DisplayList::State *)v29, 1, &v62, (RB::Symbol::Presentation *)a1, v26, *(float32x2_t *)&v32);
                v34 = v71;
                v7 = v71 + 1;
                v13 = v14;
                if (v72 < v71 + 1)
                {
                  RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v7);
                  v34 = v71;
                  v7 = v71 + 1;
                }
                v35 = v70;
                if (!v70)
                  v35 = __dst;
                *(_QWORD *)&v35[8 * v34] = v29;
                v71 = v7;
              }
            }
            --v21;
          }
          while (v23);
          v16 = a2;
          a3 = v56;
          v12 = v57;
          v10 = v55;
        }
      }
      v36 = v12 + 416 * v13;
      if (*(_QWORD *)(v36 + 376))
        v37 = *(float32x2_t **)(v36 + 376);
      else
        v37 = (float32x2_t *)(v36 + 16);
      v38 = *(unsigned int *)(v36 + 384);
      if ((_DWORD)v38)
      {
        v39 = 120 * v38;
        do
        {
          v40 = *v37;
          if ((*(_BYTE *)(*(_QWORD *)v37 + 86) & 0x40) != 0)
          {
            v41 = *(float *)(*(_QWORD *)&v40 + 72) <= 0.0 ? v37[4].f32[0] * v37[3].f32[1] : v37[4].f32[0];
            if (v41 > 0.0)
            {
              if (v10)
              {
                LODWORD(v62.f64[0]) = *(_DWORD *)(*(_QWORD *)&v40 + 68);
                HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
                RB::DisplayList::State::set_animation_layer((uint64_t)v16, &v62);
                v42 = (uint64_t)*v37;
                v43.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, a1);
                v62 = v43;
                v63 = v44;
                v64 = v45;
                v46.i32[0] = 0;
                v46.i32[1] = v37[6].i32[1];
                RB::Symbol::Glyph::Layer::draw(v42, v16, 0x17u, &v62, (RB::Symbol::Presentation *)a1, 1.0, 1.0, 1.0, 1.0, v41, v46);
                v13 = v14;
              }
              else
              {
                v47 = v70;
                if (!v70)
                  v47 = __dst;
                RBDrawingStateDestroy(*(RB::XML::Document **)&v47[8 * v71-- - 8], (const char *)v7, v8);
              }
            }
          }
          v48 = (float)(v37[3].f32[0] * v37[4].f32[0]) * *(float *)(*(_QWORD *)v37 + 72);
          if (v48 > 0.0)
          {
            v61[0] = MEMORY[0x24BDAC760];
            v61[1] = 3221225472;
            v61[2] = ___ZNK2RB6Symbol12Presentation4drawEP15_RBDrawingStateU13block_pointerF7RBColor13RBSymbolStyleP8NSStringE_block_invoke;
            v61[3] = &unk_24C22AC68;
            v61[6] = a1;
            v61[7] = v37;
            v61[4] = a3;
            v61[5] = v65;
            v49 = v16;
            if (v71)
            {
              v50 = v70;
              if (!v70)
                v50 = __dst;
              v49 = *(RB::DisplayList::State **)&v50[8 * v71 - 8];
            }
            LODWORD(v62.f64[0]) = *(_DWORD *)(*(_QWORD *)v37 + 68);
            HIDWORD(v62.f64[0]) = *(_DWORD *)(RB::Symbol::Model::glyph_info(*v60) + 400);
            RB::DisplayList::State::set_animation_layer((uint64_t)v49, &v62);
            v51 = (uint64_t)*v37;
            v52.f64[0] = RB::Symbol::Presentation::Layer::transform(v37, a1);
            v62 = v52;
            v63 = v53;
            v64 = v54;
            LODWORD(v53) = 0;
            DWORD1(v53) = v37[6].i32[1];
            RB::Symbol::Glyph::Layer::draw(v51, v49, 0, &v62, (RB::Symbol::Presentation *)a1, (uint64_t)v61, v48, *(float32x2_t *)&v53);
            v13 = v14;
          }
          v37 += 15;
          v39 -= 120;
        }
        while (v39);
      }
      if (v10)
        RBDrawingStateDrawLayer((uint64_t)a2, v16, 0, 1.0);
      v9 = v58;
      if (v70)
        free(v70);
    }
    while (v13);
  }
  _Block_object_dispose(v65, 8);
  if (cf)
    CFRelease(cf);
}

void sub_209AE1BA0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,CFTypeRef cf)
{
  uint64_t v43;
  void *v45;

  v45 = *(void **)(v43 - 168);
  if (v45)
    free(v45);
  _Block_object_dispose(&a32, 8);
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(a1);
}

_RBDrawingState *RBDrawingStateInit(RB::DisplayList::State *a1)
{
  uint64_t v2;
  _RBDrawingState *v3;
  _RBDrawingState *v4;
  _RBDrawingState *v5;
  RB::XML::DisplayList *v6;

  v2 = *((_QWORD *)a1 + 1);
  if (!*(_QWORD *)(v2 + 24))
    make_contents(*((unsigned int **)a1 + 1));
  RB::DisplayList::Builder::copy_state((RB::DisplayList::Builder *)(v2 + 16), a1);
  v5 = v4;
  ++*(_DWORD *)(v2 + 352);
  v6 = *(RB::XML::DisplayList **)(v2 + 304);
  if (v6)
    RB::XML::DisplayList::copy_state(v6, a1, v5, v3);
  return v5;
}

double RB::DisplayList::State::State(RB::DisplayList::State *this, const RB::DisplayList::State *a2)
{
  uint64_t v2;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  double result;

  v2 = *((_QWORD *)a2 + 1);
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = v2;
  v3 = *((_OWORD *)a2 + 1);
  v4 = *((_OWORD *)a2 + 3);
  *((_OWORD *)this + 2) = *((_OWORD *)a2 + 2);
  *((_OWORD *)this + 3) = v4;
  *((_OWORD *)this + 1) = v3;
  v5 = *((_OWORD *)a2 + 4);
  *((_DWORD *)this + 20) = *((_DWORD *)a2 + 20);
  *((_OWORD *)this + 4) = v5;
  v6 = *((_QWORD *)a2 + 11);
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  *((_QWORD *)this + 11) = v6;
  *((_OWORD *)this + 6) = *((_OWORD *)a2 + 6);
  *((_OWORD *)this + 7) = *((_OWORD *)a2 + 7);
  *((_OWORD *)this + 8) = *((_OWORD *)a2 + 8);
  result = *((double *)a2 + 18);
  *((double *)this + 18) = result;
  *((_DWORD *)this + 38) = *((_DWORD *)a2 + 38);
  *((_WORD *)this + 78) = *((_WORD *)a2 + 78);
  *((_QWORD *)this + 20) = *((_QWORD *)a2 + 20);
  *((_QWORD *)this + 21) = *((_QWORD *)a2 + 21);
  return result;
}

unsigned int *RBDrawingStateDestroy(RB::XML::Document *a1, const char *a2, _RBDrawingState *a3)
{
  uint64_t v3;
  RB::XML::DisplayList *v5;
  unsigned int *result;

  v3 = *((_QWORD *)a1 + 1);
  if (!*(_DWORD *)(v3 + 352))
    RB::precondition_failure((RB *)"invalid state delete", a2);
  v5 = *(RB::XML::DisplayList **)(v3 + 304);
  if (v5)
    RB::XML::DisplayList::destroy_state(v5, a1, a3);
  result = RB::DisplayList::Builder::delete_state((unsigned int *)(v3 + 16), a1);
  --*(_DWORD *)(v3 + 352);
  return result;
}

float64_t RB::Symbol::Presentation::Layer::transform(float32x2_t *a1, uint64_t a2)
{
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  float32x2_t v6;
  float64x2_t v7;
  float32x2_t v8;
  uint32x2_t v14;
  float64x2_t v15;
  float v16;
  float v17;
  float32x2_t v18;
  float v19;
  float64x2_t v20;
  __float2 v21;
  int64x2_t v22;
  float v23;
  float64x2_t v24;
  __float2 v25;
  int64x2_t v26;
  float v27;
  int64x2_t v29;
  int64x2_t v30;
  uint64_t v31;
  uint64_t v32;
  __int128 v33;
  float64x2_t v34;
  float64x2_t v35;

  if (a2)
  {
    v3 = *(float64x2_t *)(a2 + 880);
    v33 = *(_OWORD *)(a2 + 864);
    v34 = v3;
    v35 = *(float64x2_t *)(a2 + 896);
    v4 = (float64x2_t)v33;
    v5 = v35;
  }
  else
  {
    v4 = (float64x2_t)xmmword_209BD5290;
    v33 = xmmword_209BD5290;
    v3 = (float64x2_t)xmmword_209BD52A0;
    v5 = 0uLL;
  }
  v6 = a1[8];
  v6.f32[1] = v6.f32[1] + a1[14].f32[0];
  v7 = vcvtq_f64_f32(v6);
  v8 = a1[12];
  __asm { FMOV            V5.2S, #1.0 }
  v14 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v8, _D5));
  if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0)
  {
    v4 = vmulq_n_f64(v4, v8.f32[0]);
    v3 = vmulq_n_f64(v3, v8.f32[1]);
    v33 = (__int128)v4;
  }
  v15 = vaddq_f64(v5, v7);
  v16 = a1[4].f32[1];
  v17 = a1[5].f32[1];
  if (v16 != 1.0 || v17 != 0.0)
  {
    v18 = a1[9];
    v19 = v18.f32[1];
    v20 = vmlaq_n_f64(vmlaq_n_f64(v15, v4, v18.f32[0]), v3, v18.f32[1]);
    v34 = v3;
    v35 = v20;
    if (v17 != 0.0)
    {
      v21 = __sincosf_stret(v17);
      *(double *)v22.i64 = (float)-v21.__sinval;
      v29 = (int64x2_t)vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(v21.__sinval), LODWORD(v21.__cosval)));
      v30 = vzip1q_s64(v22, v29);
      v31 = 0;
      v32 = 0;
      v4.f64[0] = RB::operator*((float64x2_t *)&v29, (float64x2_t *)&v33);
      v16 = a1[4].f32[1];
      v18 = a1[9];
      v19 = v18.f32[1];
    }
    v4 = vmulq_n_f64(v4, v16);
    v3 = vmulq_n_f64(v3, v16);
    v15 = vmlaq_n_f64(vmlaq_n_f64(v20, v4, (float)-v18.f32[0]), v3, (float)-v19);
    v33 = (__int128)v4;
  }
  v23 = a1[6].f32[0];
  if (v23 != 0.0)
  {
    v24 = vmlaq_n_f64(vmlaq_n_f64(v15, v4, COERCE_FLOAT(*(_QWORD *)&a1[11])), v3, COERCE_FLOAT(HIDWORD(*(_QWORD *)&a1[11])));
    v34 = v3;
    v35 = v24;
    v25 = __sincosf_stret(v23);
    *(double *)v26.i64 = (float)-v25.__sinval;
    v29 = (int64x2_t)vcvtq_f64_f32((float32x2_t)__PAIR64__(LODWORD(v25.__sinval), LODWORD(v25.__cosval)));
    v30 = vzip1q_s64(v26, v29);
    v31 = 0;
    v32 = 0;
    v4.f64[0] = RB::operator*((float64x2_t *)&v29, (float64x2_t *)&v33);
  }
  v27 = a1[5].f32[0];
  if (v27 != 1.0)
    *(_QWORD *)&v4.f64[0] = *(_OWORD *)&vmulq_n_f64(v4, v27);
  return v4.f64[0];
}

uint64_t RB::Symbol::Presentation::shape(RB::Symbol::Presentation *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 251);
  if (!v1)
  {
    v1 = objc_opt_new();

    *((_QWORD *)this + 251) = v1;
  }
  return v1;
}

uint64_t RB::Symbol::Presentation::fill(RB::Symbol::Presentation *this)
{
  uint64_t v1;

  v1 = *((_QWORD *)this + 252);
  if (!v1)
  {
    v1 = objc_opt_new();

    *((_QWORD *)this + 252) = v1;
  }
  return v1;
}

unint64_t rb_color_space(unsigned int a1)
{
  if (a1 >= 5)
    return 0;
  else
    return (0x203000100uLL >> (8 * a1)) & 3 | ((0x101010100uLL >> (8 * a1)) << 8);
}

uint64_t RBDrawingStateGetDisplayList(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

void RB::Symbol::ResolvedColor::commit_update(uint64_t a1, float a2, float a3, float a4, float a5)
{
  CGColor *v6;
  double v7;
  int v8;
  int v9;
  int v10;
  const void *v11;
  const void *v12;
  CFTypeRef v13;
  const void *v14;

  if (a5 == -32768.0)
  {
    v6 = *(CGColor **)(a1 + 32);
    if (v6)
    {
      v7 = RBColorFromCGColor(v6, 0);
      *(_DWORD *)a1 = LODWORD(v7);
      *(_DWORD *)(a1 + 4) = v8;
      *(_DWORD *)(a1 + 8) = v9;
      *(_DWORD *)(a1 + 12) = v10;
      v12 = *(const void **)(a1 + 32);
      v11 = *(const void **)(a1 + 40);
      if (v11 != v12)
      {
        if (v11)
          CFRelease(v11);
        if (v12)
          v13 = CFRetain(v12);
        else
          v13 = 0;
        *(_QWORD *)(a1 + 40) = v13;
      }
      return;
    }
    a3 = 0.0;
    a2 = 1.0;
    a4 = 1.0;
    a5 = 1.0;
  }
  *(float *)a1 = a2;
  *(float *)(a1 + 4) = a3;
  *(float *)(a1 + 8) = a4;
  *(float *)(a1 + 12) = a5;
  v14 = *(const void **)(a1 + 40);
  if (v14)
    CFRelease(v14);
  *(_QWORD *)(a1 + 40) = 0;
}

BOOL rb_profile_supports_porter_duff_blending(unsigned int a1)
{
  return a1 > 3 || (a1 & 0xF) == 2;
}

float RBSymbolUpdateLayerDrawingOpacity(_DWORD *a1)
{
  uint64_t v1;
  unsigned int v2;
  _DWORD *v3;
  _QWORD *v4;
  uint64_t v5;
  float result;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v1 = *(_QWORD *)a1 + 8;
  v2 = *(_DWORD *)(*(_QWORD *)a1 + 848) + ~a1[2];
  if (*(_QWORD *)(*(_QWORD *)a1 + 840))
    v1 = *(_QWORD *)(*(_QWORD *)a1 + 840);
  v3 = (_DWORD *)*((_QWORD *)a1 + 2);
  v4 = *(_QWORD **)(v1 + 416 * v2 + 400);
  if (!v4)
    goto LABEL_6;
  v3 = (_DWORD *)(*v4 + 8 * *((_QWORD *)a1 + 2));
  v5 = v3[1];
  result = 0.0;
  if (!(_DWORD)v5)
    return result;
  LODWORD(v3) = *v3;
  if ((_DWORD)v5 != 1)
  {
    v10 = v1 + 416 * v2;
    v11 = v10 + 16;
    v12 = *(_QWORD *)(v10 + 376);
    if (!v12)
      v12 = v11;
    while ((float)((float)(*(float *)(v12 + 120 * v3 + 24)
                          * *(float *)(v12 + 120 * v3 + 32))
                  * *(float *)(*(_QWORD *)(v12 + 120 * v3) + 72)) <= 0.0)
    {
      LODWORD(v3) = (_DWORD)v3 + 1;
      if (!--v5)
        return result;
    }
    return 1.0;
  }
  else
  {
LABEL_6:
    v7 = v1 + 416 * v2;
    v8 = v7 + 16;
    v9 = *(_QWORD *)(v7 + 376);
    if (!v9)
      v9 = v8;
    return (float)(*(float *)(v9 + 120 * v3 + 24) * *(float *)(v9 + 120 * v3 + 32))
         * *(float *)(*(_QWORD *)(v9 + 120 * v3) + 72);
  }
}

void ___ZN2RB6Device19RenderPipelineEntry6Loader7load_fnENS2_8FunctionE_block_invoke(uint64_t a1, uint64_t a2)
{
  id *v3;
  int v4;

  v3 = *(id **)(a1 + 32);
  v4 = *(_DWORD *)(a1 + 40);
  if (v4 == 1)
  {
    RB::Device::RenderPipelineEntry::Loader::fragment_fn(v3, a2);
  }
  else if (!v4)
  {
    RB::Device::RenderPipelineEntry::Loader::vertex_fn(v3, a2);
  }
}

uint64_t RBColorModeWorkingColorSpace(unsigned int a1)
{
  if (a1 > 0xD)
    return 0;
  else
    return dword_209BD7A10[a1];
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Path::Flattener::moveto(uint64_t a1, float64x2_t a2)
{
  float32x2_t v3;

  RB::Path::Flattener::closepath((float32x2_t *)a1);
  v3 = vcvt_f32_f64(a2);
  *(float32x2_t *)(a1 + 72) = v3;
  *(float32x2_t *)(a1 + 80) = v3;
  *(_BYTE *)(a1 + 88) = 0;
  return (***(uint64_t (****)(_QWORD))(a1 + 8))(*(_QWORD *)(a1 + 8));
}

void RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::visit(uint64_t a1, __int128 *a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *v4;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = v4;
}

void RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Color>::visit(uint64_t a1, __int128 *a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *v4;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = v4;
}

void RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Color>(__int128 **a1, uint64_t a2)
{
  __int128 *v3;
  uint64_t v4;

  v3 = *a1;
  v4 = *((_QWORD *)*a1 + 7);
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(_QWORD *)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = v4;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(v4 + 46) |= 0x1000u;
}

double RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  char v19;
  __int16 v20;
  __int128 v25;
  __int128 v26;
  __int16 v27;
  double result;

  v15 = *((_QWORD *)this + 3);
  v16 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v16 + 128 > v15)
    v16 = RB::Heap::alloc_slow((size_t *)this, 0x80uLL, 15);
  else
    *((_QWORD *)this + 2) = v16 + 128;
  v17 = *a5;
  _S0 = *a6;
  v19 = *a7;
  v20 = *a8;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v16 + 16) = 0;
  *(_QWORD *)(v16 + 24) = 0;
  *(_DWORD *)(v16 + 40) = 0;
  *(_QWORD *)(v16 + 32) = 0;
  *(_WORD *)(v16 + 44) = _S0;
  *(_WORD *)(v16 + 46) = v19 & 0x3F | 0x4000;
  *(_QWORD *)v16 = off_24C2273D8;
  *(_QWORD *)(v16 + 48) = v17;
  v25 = *a3;
  v26 = a3[1];
  *(_OWORD *)(v16 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v16 + 64) = v25;
  *(_OWORD *)(v16 + 80) = v26;
  if (*(_BYTE *)(a4 + 9))
    v27 = *(_WORD *)(a4 + 8);
  else
    v27 = v20;
  result = *(double *)a4;
  *(_QWORD *)(v16 + 112) = *(_QWORD *)a4;
  *(_WORD *)(v16 + 120) = v27;
  *(_QWORD *)v16 = &off_24C225C38;
  return result;
}

float RB::Symbol::Animator::variable_value(os_unfair_lock_s *this)
{
  float v2;

  os_unfair_lock_lock(this);
  v2 = *(float *)&this[14]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(this);
  return v2;
}

float32x2_t RB::DisplayList::Layer::bounds(RB::DisplayList::Layer *this)
{
  uint64_t v2;
  int v3;
  uint64_t v6;
  float v7;
  float v8;
  float32x2_t v9;
  float32x2_t v10;
  __int128 v11;

  if (!*((_BYTE *)this + 66))
  {
    *((_BYTE *)this + 66) = 1;
    *((double *)this + 4) = RB::DisplayList::Layer::compute_bounds_(this, 0);
    *((_QWORD *)this + 5) = v2;
  }
  v3 = *((unsigned __int8 *)this + 64);
  if (*((float *)this + 12) == 0.0 && v3 == 0)
  {
    return *(float32x2_t *)((char *)this + 32);
  }
  else
  {
    v11 = 0uLL;
    switch(v3)
    {
      case 2:
        v11 = *((_OWORD *)this + 2);
        (*(void (**)(_QWORD, __int128 *))(**((_QWORD **)this + 3) + 40))(*((_QWORD *)this + 3), &v11);
        break;
      case 1:
        *(float32x2_t *)&v11 = RB::operator*(*((_QWORD *)this + 3), *((double *)this + 4), *(float32x2_t *)((char *)this + 40));
        *((_QWORD *)&v11 + 1) = v6;
        break;
      case 0:
        v11 = *((_OWORD *)this + 2);
        break;
    }
    v7 = *((float *)this + 12);
    if (v7 == 0.0)
      v7 = 1.0;
    v8 = v7;
    v9 = vrecpe_f32((float32x2_t)LODWORD(v7));
    v10 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v8), v9), v9);
    return vmul_n_f32(*(float32x2_t *)&v11, vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(v8), v10)).f32[0]);
  }
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::lineto(uint64_t result, _QWORD *a2, double a3)
{
  uint64_t v4;
  float32x2_t v5;
  uint32x2_t v6;
  float32x2_t v8;
  uint32x2_t v9;
  uint32x2_t v10;
  char v11;

  v4 = result;
  v5 = *(float32x2_t *)(result + 112);
  v6 = (uint32x2_t)vceq_f32(v5, *(float32x2_t *)&a3);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
  {
    if (*(_BYTE *)(result + 50) && !*(_BYTE *)(result + 32))
      *(_BYTE *)(result + 51) = 1;
  }
  else
  {
    *(double *)(result + 112) = a3;
    *(_QWORD *)(result + 120) = *a2;
    *(_BYTE *)(result + 50) = 0;
    v8 = vsub_f32(*(float32x2_t *)&a3, v5);
    result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(result, 0, v8);
    if (*(_BYTE *)(v4 + 48)
      && ((v9 = (uint32x2_t)vcgt_f32(vminnm_f32(v5, *(float32x2_t *)&a3), *(float32x2_t *)(v4 + 24)),
           (vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
       || (v10 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(v4 + 16), vmaxnm_f32(v5, *(float32x2_t *)&a3)),
           (vpmax_u32(v10, v10).u32[0] & 0x80000000) != 0)))
    {
      *(_BYTE *)(v4 + 72) = 0;
      return (*(uint64_t (**)(_QWORD, _QWORD *, double))(**(_QWORD **)(v4 + 8) + 24))(*(_QWORD *)(v4 + 8), a2, a3);
    }
    else
    {
      if (*(_BYTE *)(v4 + 72) && !*(_DWORD *)(v4 + 76))
      {
        *(float32x2_t *)(v4 + 96) = v8;
        result = (*(uint64_t (**)(_QWORD, _QWORD, double))(**(_QWORD **)(v4 + 8) + 32))(*(_QWORD *)(v4 + 8), 0, *(double *)&v8);
        *(_BYTE *)(v4 + 72) = 0;
      }
      v11 = 1;
      if (*(float *)a2 > *(float *)(v4 + 44))
        v11 = *(_BYTE *)(v4 + 33);
      *(_BYTE *)(v4 + 51) = 0;
      *(_BYTE *)(v4 + 49) = 1;
      *(_BYTE *)(v4 + 53) = v11;
      *(double *)(v4 + 56) = a3;
      *(_QWORD *)(v4 + 64) = *a2;
      *(_BYTE *)(v4 + 72) = 1;
      *(_DWORD *)(v4 + 76) = 1;
      *(float32x2_t *)(v4 + 80) = v8;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::moveto(uint64_t a1, uint64_t *a2, double a3)
{
  uint64_t v6;

  RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 1);
  if (*(_BYTE *)(a1 + 72) && *(_DWORD *)(a1 + 76) == 1)
    (*(void (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, *(double *)(a1 + 80));
  *(double *)(a1 + 88) = a3;
  v6 = *a2;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = v6;
  *(double *)(a1 + 112) = a3;
  *(_QWORD *)(a1 + 120) = *a2;
  *(_WORD *)(a1 + 50) = 1;
  *(_BYTE *)(a1 + 52) = 0;
  *(_BYTE *)(a1 + 72) = 1;
  *(_DWORD *)(a1 + 76) = 0;
  return (*(uint64_t (**)(_QWORD, uint64_t *, double))(**(_QWORD **)(a1 + 8) + 8))(*(_QWORD *)(a1 + 8), a2, a3);
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::endpath(uint64_t a1)
{
  uint64_t result;

  result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(a1, 1);
  if (*(_BYTE *)(a1 + 72))
  {
    if (*(_DWORD *)(a1 + 76) == 1)
    {
      result = (*(uint64_t (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, *(double *)(a1 + 80));
      *(_BYTE *)(a1 + 72) = 0;
    }
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(uint64_t result, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = result;
  if (!a2)
  {
    if (!*(_BYTE *)(result + 49))
      return result;
    v3 = *(unsigned __int8 *)(result + 53);
    goto LABEL_7;
  }
  result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(result);
  if ((result & 1) == 0 && *(_BYTE *)(v2 + 49))
  {
    v3 = 1;
LABEL_7:
    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, double))(**(_QWORD **)(v2 + 8) + 16))(*(_QWORD *)(v2 + 8), v2 + 64, v3, *(double *)(v2 + 56));
    *(_BYTE *)(v2 + 49) = 0;
    *(_BYTE *)(v2 + 52) = 1;
  }
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(uint64_t a1)
{
  uint64_t v2;

  if (!*(_BYTE *)(a1 + 50) || !*(_BYTE *)(a1 + 51))
    return 0;
  (*(void (**)(_QWORD, _QWORD, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0, COERCE_DOUBLE(1065353216));
  v2 = 1;
  (*(void (**)(_QWORD, uint64_t, uint64_t, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), a1 + 104, 1, *(double *)(a1 + 88));
  (*(void (**)(_QWORD, uint64_t, double))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, COERCE_DOUBLE(1065353216));
  *(_BYTE *)(a1 + 72) = 0;
  *(_WORD *)(a1 + 51) = 256;
  return v2;
}

uint64_t RB::Stroke::Dasher::tangent(uint64_t result, int a2, double a3)
{
  double *v3;
  char v4;

  if (a2 == 1)
  {
    v3 = (double *)(result + 64);
    v4 = 2;
  }
  else
  {
    if (a2)
      return result;
    *(double *)(result + 56) = a3;
    v3 = (double *)(result + 72);
    v4 = 5;
  }
  *v3 = a3;
  *(_BYTE *)(result + 80) |= v4;
  return result;
}

uint64_t RB::Stroke::Flattener<RB::Stroke::Point>::flush_lineto(uint64_t result, int a2, float32x2_t a3)
{
  uint64_t v3;
  uint64_t v4;
  float32x2_t v5;
  int32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  int32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float v12;

  v3 = result;
  if (!a2)
  {
    if (!*(_BYTE *)(result + 49))
      return result;
    v4 = *(unsigned __int8 *)(result + 53);
    if (!*(_BYTE *)(result + 53))
    {
      if (*(_BYTE *)(result + 72) && *(_DWORD *)(result + 76) == 1)
      {
        v5 = *(float32x2_t *)(result + 80);
        v6 = (int32x2_t)vmul_f32(v5, v5);
        v6.i32[0] = vadd_f32((float32x2_t)v6, (float32x2_t)vdup_lane_s32(v6, 1)).u32[0];
        v7 = vrsqrte_f32((float32x2_t)v6.u32[0]);
        v8 = vmul_f32(vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v7, v7)), v7);
        v9 = (int32x2_t)vmul_f32(a3, a3);
        v9.i32[0] = vadd_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)).u32[0];
        v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
        v11 = vmul_f32(vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)), v10);
        v12 = vaddv_f32(vmul_n_f32(vmul_f32(v5, a3), vmul_f32(vmul_f32(vmul_f32(v8, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))), v11), vrsqrts_f32((float32x2_t)v6.u32[0], vmul_f32(v8, v8))).f32[0]));
        if (v12 > 0.99)
          v4 = 1;
        else
          v4 = 2 * ((float)((float)(v12 + 1.0) * *(float *)(result + 36)) < 2.0);
      }
      else
      {
        v4 = 0;
      }
    }
    goto LABEL_13;
  }
  result = RB::Stroke::Flattener<RB::Stroke::Point>::flush_empty_line(result);
  if ((result & 1) == 0 && *(_BYTE *)(v3 + 49))
  {
    v4 = 1;
LABEL_13:
    result = (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, double))(**(_QWORD **)(v3 + 8) + 16))(*(_QWORD *)(v3 + 8), v3 + 64, v4, *(double *)(v3 + 56));
    *(_BYTE *)(v3 + 49) = 0;
    *(_BYTE *)(v3 + 52) = 1;
  }
  return result;
}

void RB::`anonymous namespace'::draw_stroke(_QWORD *a1, __n128 (***a2)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a3, uint64_t (***a4)(_QWORD, _QWORD *), float64x2_t *a5, int a6)
{
  float64x2_t v11;
  _BOOL4 v12;
  float64x2_t *v13;
  float64x2_t *v14;
  unint64_t v15;
  MTLPixelFormat v16;
  unsigned int *v17;
  unint64_t v18;
  int32x2_t *v19;
  unint64_t v20;
  float32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;
  __int32 v26;
  RB::Buffer *v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  float32x2_t v31;
  double v32;
  double v33;
  float32x2_t *v34;
  float32_t v35;
  int v36;
  float64x2_t v37;
  int v38;
  int v39;
  float32x2_t v40;
  float32x2_t v41;
  float v42;
  int32x2_t v43;
  int32x2_t v44;
  float32x2_t v45;
  float32x2_t v46;
  int32x2_t v47;
  int32x2_t v48;
  uint32x2_t v49;
  int8x8_t v50;
  __n128 v51;
  int8x8_t v52;
  uint32x2_t v53;
  int8x8_t v54;
  int8x8_t v55;
  uint64_t v56;
  uint64_t v57;
  unint64_t v58;
  float32x2_t v59;
  float32x2_t v60;
  float v61;
  int32x2_t v62;
  int32x2_t v63;
  int32x2_t v64;
  int32x2_t v65;
  uint32x2_t v66;
  int8x8_t v67;
  __n128 v68;
  uint32x2_t v69;
  uint32x2_t v70;
  uint64_t v71;
  const char *v72;
  float v73;
  __int32 v74;
  float64x2_t v75;
  float32x2_t v76;
  float64x2_t v77;
  float64x2_t v78;
  float64x2_t v79;
  int8x16_t v80;
  float64x2_t v81;
  int8x16_t v82;
  float64x2_t v83;
  __n128 v84;
  __n128 v85;
  int32x2_t v86[2];
  int8x16_t v87;
  float64x2_t v88;
  float64x2_t v89;
  _BYTE v90[32];
  float64x2_t v91;
  float64x2_t v92;
  float64x2_t v93;
  int32x2_t v94;
  char v95;
  int32x2_t v96;
  float32x2_t v97;
  __int128 v98;
  __int128 v99;
  uint64_t v100;
  float v101;
  float v102;
  float32x2_t v103;
  char v104;
  __int128 v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  __int128 v110;
  __int16 v111;
  uint64_t v112;
  unsigned __int8 v113;
  uint64_t v114;

  v114 = *MEMORY[0x24BDAC8D0];
  v11 = a5[1];
  v87 = *(int8x16_t *)a5;
  v88 = v11;
  v89 = 0uLL;
  v81 = a5[2];
  v82 = v87;
  *(int8x16_t *)v90 = v87;
  *(float64x2_t *)&v90[16] = v11;
  v91 = 0uLL;
  v12 = RB::AffineTransform::invert((RB::AffineTransform *)v90);
  v13 = &v88;
  v14 = &v89;
  v80 = *(int8x16_t *)v90;
  if (v12)
    v15 = -1;
  else
    v15 = 0;
  if (v12)
    v13 = (float64x2_t *)&v90[16];
  v79 = *v13;
  if (v12)
    v14 = &v91;
  v83 = *v14;
  v73 = RB::AffineTransform::scale((float64x2_t *)&v87);
  v17 = RB::pixel_format_traits(a1[11], v16);
  v18 = *v17 | ((unint64_t)*((unsigned __int16 *)v17 + 2) << 32);
  if ((v18 & 0x4000000000) != 0 && a6)
  {
    *((_BYTE *)a1 + 176) = 1;
    *((_DWORD *)a1 + 45) = 1;
  }
  v19 = *(int32x2_t **)(a3 + 32);
  if (v19)
  {
    v20 = *(_QWORD *)(a3 + 24);
    v21 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20));
    v22 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20), v21), v21);
    v23 = vmul_f32(v22, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v20), v22));
    v24 = vcvt_f32_s32(v19[8]);
    v74 = v23.i32[0];
    v23.i32[0] = vmul_f32(v23, v24).u32[0];
    v23.i32[1] = v24.i32[1];
    v25 = vmul_n_f32(v23, COERCE_FLOAT(*(_QWORD *)(a3 + 20)));
  }
  else
  {
    v74 = 0;
    v25 = 0;
  }
  v76 = (float32x2_t)a1[14];
  v77 = (float64x2_t)v87;
  v78 = v88;
  v75 = v89;
  v26 = *((_DWORD *)a1 + 30);
  RB::RenderFrame::alloc_buffer_region(*(RB::RenderFrame **)*a1, (RB::Device *)0x2C, 4uLL, 0, v90);
  v27 = *(RB::Buffer **)v90;
  if (*(_QWORD *)v90)
  {
    v28.i32[0] = v76.i32[0];
    v28.i32[1] = vneg_f32(v76).i32[1];
    v29 = vmul_f32(v28, vcvt_f32_f64(v77));
    v30 = vmul_f32(v28, vcvt_f32_f64(v78));
    v31 = vmla_f32((float32x2_t)0x3F800000BF800000, vcvt_f32_f64(v75), v28);
    v32 = vpmaxq_f64(vabsq_f64(v77));
    v33 = vpmaxq_f64((float64x2_t)vandq_s8((int8x16_t)v78, (int8x16_t)vdupq_n_s64(0x7FFFFFFFFFFFFFFFuLL)));
    if (v32 >= v33)
      v33 = v32;
    v34 = (float32x2_t *)(*(_QWORD *)(*(_QWORD *)v90 + 56) + *(_QWORD *)&v90[8]);
    *v34 = v29;
    v34[1] = v30;
    v34[2] = v31;
    v34[3] = v25;
    v35 = 1.0 / v33;
    v34[4].i32[0] = v26;
    v34[4].i32[1] = v74;
    v34[5].f32[0] = v35;
  }
  else
  {
    memset(v90, 0, 24);
  }
  v36 = RB::RenderFrame::buffer_id(*(RB::RenderFrame **)*a1, v27);
  v37 = vmlaq_laneq_f64(vmlaq_n_f64(v83, (float64x2_t)vbslq_s8((int8x16_t)vdupq_n_s64(v15), v80, v82), v81.f64[0]), v79, v81, 1);
  *((_DWORD *)a1 + 46) = v36;
  *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(*(int64x2_t *)&v90[8]);
  v38 = 2 * (*((_DWORD *)a1 + 34) == 2);
  v39 = ((*(_BYTE *)(a3 + 4) & 7 | (8 * (*(_BYTE *)(a3 + 5) & 3))) << 12) | ((*(_BYTE *)(a3 + 12) == 1) << 17) | ((*(_DWORD *)(a3 + 8) & 0x3F) << 6);
  v40 = 0;
  if (*(_DWORD *)a3 == 1)
  {
    v56 = *(_QWORD *)(a3 + 32);
    v41 = 0;
    if (v56)
    {
      v85 = (__n128)v37;
      *((_DWORD *)a1 + 58) = RB::RenderFrame::texture_id(*(RB::RenderFrame **)*a1, v56);
      *((_BYTE *)a1 + 236) = 0;
      v57 = *(_QWORD *)(a3 + 32);
      if (v57)
      {
        v58 = *(_QWORD *)(a3 + 24);
        v59 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v58));
        v60 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v58), v59), v59);
        v61 = (float)(*(float *)(a3 + 20) * 0.5)
            * fmaxf((float)(int)*(_QWORD *)(v57 + 64)* vmul_f32(v60, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)v58), v60)).f32[0], (float)(int)HIDWORD(*(_QWORD *)(v57 + 64)));
      }
      else
      {
        v61 = 0.0;
      }
      *(_QWORD *)&v90[16] = a1;
      *(_DWORD *)&v90[24] = v39 | 0x10;
      *(_DWORD *)&v90[28] = v38;
      v91 = (float64x2_t)v87;
      v92 = v88;
      v93 = v89;
      v62 = RB::AffineTransform::scale2((float64x2_t *)&v87);
      v63.i32[0] = 0;
      v94 = v62;
      v96 = vdup_n_s32(0x7F800000u);
      v97 = (float32x2_t)0x7F0000007FLL;
      v98 = 0u;
      v99 = 0u;
      v64 = (int32x2_t)a1[20];
      v65 = (int32x2_t)a1[21];
      v66 = (uint32x2_t)vceq_s32(v65, (int32x2_t)0x8000000080000000);
      v95 = 0;
      v100 = 0;
      *(_QWORD *)v90 = &off_24C228CC0;
      v67 = (int8x8_t)vdup_lane_s32(vcgt_s32(v63, (int32x2_t)vpmin_u32(v66, v66)), 0);
      v101 = v61;
      v68 = (*a2)[1](a2, v90, *a1, (float64x2_t *)&v87, v85, COERCE_DOUBLE(vbsl_s8(v67, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v64))), COERCE_DOUBLE(vbsl_s8(v67, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v65))));
      v68.n128_u32[0] = 0;
      v69 = (uint32x2_t)vcgt_f32(v97, (float32x2_t)v96);
      v68.n128_u64[0] = (unint64_t)vdup_lane_s32(vcgt_s32((int32x2_t)v68.n128_u64[0], (int32x2_t)vpmin_u32(v69, v69)), 0);
      v41 = (float32x2_t)vand_s8((int8x8_t)vsub_f32(v97, (float32x2_t)v96), (int8x8_t)v68.n128_u64[0]);
      v40 = (float32x2_t)vand_s8((int8x8_t)v96, (int8x8_t)v68.n128_u64[0]);
      *((_DWORD *)a1 + 58) = 0;
      *((_BYTE *)a1 + 236) = 0;
    }
  }
  else
  {
    v41 = 0;
    if (!*(_DWORD *)a3)
    {
      v84 = (__n128)v37;
      v42 = *(float *)(a3 + 16);
      *(_QWORD *)&v90[16] = a1;
      *(_DWORD *)&v90[24] = v39 | 0xE;
      *(_DWORD *)&v90[28] = v38;
      v91 = (float64x2_t)v87;
      v92 = v88;
      v93 = v89;
      v43 = RB::AffineTransform::scale2((float64x2_t *)&v87);
      v44.i32[0] = 0;
      v45 = vrecpe_f32((float32x2_t)LODWORD(v73));
      v46 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v73), v45), v45);
      v94 = v43;
      v95 = 0;
      v96 = vdup_n_s32(0x7F800000u);
      v97 = (float32x2_t)0x7F0000007FLL;
      v98 = 0u;
      v99 = 0u;
      v100 = 0;
      *(_QWORD *)v90 = off_24C228C48;
      v101 = vmul_f32(v46, vrecps_f32((float32x2_t)LODWORD(v73), v46)).f32[0] * 0.01;
      v102 = fmaxf(v42, 1.0);
      v103 = vmul_f32((float32x2_t)v43, (float32x2_t)vdup_n_s32(0x3FB504F3u));
      v104 = 0;
      v105 = xmmword_209BD7730;
      v106 = 0x3F80000000000000;
      v108 = 0;
      v109 = 0;
      v107 = 0;
      v110 = xmmword_209BD7730;
      v111 = 0;
      v112 = 0x3F80000000000000;
      v47 = (int32x2_t)a1[20];
      v48 = (int32x2_t)a1[21];
      v49 = (uint32x2_t)vceq_s32(v48, (int32x2_t)0x8000000080000000);
      v50 = (int8x8_t)vdup_lane_s32(vcgt_s32(v44, (int32x2_t)vpmin_u32(v49, v49)), 0);
      v113 = 0;
      v51 = (**a2)(a2, v90, *a1, (float64x2_t *)&v87, v84, COERCE_DOUBLE(vbsl_s8(v50, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(v47))), COERCE_DOUBLE(vbsl_s8(v50, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v48))));
      v51.n128_u32[0] = 0;
      v52 = (int8x8_t)v96;
      v53 = (uint32x2_t)vcgt_f32(v97, (float32x2_t)v96);
      v54 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v51.n128_u64[0], (int32x2_t)vpmin_u32(v53, v53)), 0);
      v55 = (int8x8_t)vsub_f32(v97, (float32x2_t)v96);
      if (*((_QWORD *)&v98 + 1))
      {
        RB::RenderFrame::commit_buffer_region_size(***(_QWORD ***)&v90[16], (uint64_t)&v98 + 8, v100);
        if ((_QWORD)v98)
      }
      v41 = (float32x2_t)vand_s8(v55, v54);
      v40 = (float32x2_t)vand_s8(v52, v54);
    }
  }
  v70 = (uint32x2_t)vcgtz_f32(v41);
  if ((vpmin_u32(v70, v70).u32[0] & 0x80000000) != 0)
  {
    v71 = a1[21];
    *(_QWORD *)v90 = a1[20];
    *(_QWORD *)&v90[8] = v71;
    if (a6)
    {
      if ((v18 & 0x4000000000) != 0)
      {
        *((_BYTE *)a1 + 176) = 6;
        *((_DWORD *)a1 + 45) = 0;
      }
      RB::Bounds::Bounds(v86, v40, v41);
      RB::Bounds::intersect((int32x2_t *)v90, v86[0], v86[1]);
    }
    v72 = (const char *)(**a4)(a4, a1);
    if ((v72 & 0x3F) != 0x26)
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v72, 4, **(_QWORD **)*a1 + 80, 0, 1uLL, *(int32x2_t *)v90, *(int32x2_t *)&v90[8]);
  }
  if ((v18 & 0x4000000000) != 0)
  {
    *((_BYTE *)a1 + 176) = 0;
    *((_DWORD *)a1 + 45) = 0;
  }
}

void sub_209AE32A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39)
{
  uint64_t v39;

  *(_DWORD *)(v39 + 232) = 0;
  *(_BYTE *)(v39 + 236) = 0;
  _Unwind_Resume(a1);
}

int32x2_t RB::AffineTransform::scale2(float64x2_t *this)
{
  float64x2_t v1;
  float64x2_t v2;
  double v3;
  double v4;
  double v6;
  double v7;
  int64x2_t v9;
  int64x2_t v10;
  float32x2_t v11;
  BOOL v12;
  int8x8_t v13;
  unsigned int v14;

  v1 = *this;
  v2 = this[1];
  v3 = this[1].f64[1];
  v4 = this->f64[1];
  if (this->f64[0] == v3 && v4 == 0.0 && v2.f64[0] == 0.0
    || v3 == 0.0 && (v1.f64[0] == 0.0 ? (_ZF = v4 == v2.f64[0]) : (_ZF = 0), _ZF))
  {
    v6 = fabs(v1.f64[0]);
    v7 = fabs(v4);
    if (v4 != 0.0)
      v6 = v7;
    *(float *)&v6 = v6;
    return vdup_lane_s32(*(int32x2_t *)&v6, 0);
  }
  else
  {
    v9 = (int64x2_t)vmulq_f64(v1, v1);
    v10 = (int64x2_t)vmulq_f64(v2, v2);
    v11 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v9, v10), (float64x2_t)vzip2q_s64(v9, v10)));
    v12 = v11.f32[1] == 1.0 && v11.f32[0] == 1.0;
    v13 = (int8x8_t)vsqrt_f32(v11);
    if (v12)
      v14 = -1;
    else
      v14 = 0;
    __asm { FMOV            V2.2S, #1.0 }
    return (int32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v14), _D2, v13);
  }
}

uint64_t RB::render_stroke(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::StrokeGenerator const&,RB::Coverage::StrokeInfo const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::operator()(uint64_t a1, uint64_t a2, int32x2_t a3, int32x2_t a4, int32x2_t a5)
{
  uint32x2_t v7;
  int8x8_t v8;
  uint16x4_t v9;
  int16x4_t v10;
  uint64_t v11;
  int v12;
  float16x4_t v13;
  RB::Buffer *v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  RB::Buffer *v19;
  __int128 v20;
  _BYTE v21[20];
  RB::Buffer *v22;
  int64x2_t v23;

  a5.i32[0] = 0;
  v7 = (uint32x2_t)vceq_s32(a4, (int32x2_t)0x8000000080000000);
  v8 = (int8x8_t)vdup_lane_s32(vcgt_s32(a5, (int32x2_t)vpmin_u32(v7, v7)), 0);
  *(float *)v9.i32 = RB::Coverage::set_plane((float32x2_t *)&v20, (float32x2_t *)a2, (float32x2_t)vbsl_s8(v8, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(a3)), COERCE_DOUBLE(vbsl_s8(v8, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(a4))));
  v11 = *(_QWORD *)(a1 + 16);
  if (*(_BYTE *)(v11 + 9) && (v12 = *(unsigned __int8 *)(a2 + 124), *(unsigned __int8 *)(v11 + 8) != v12))
  {
    v19 = *(RB::Buffer **)v11;
    v23.i16[0] = *(_WORD *)(v11 + 8);
    v22 = v19;
    RB::Fill::Color::convert((uint64_t)&v22, v12, v9);
    v13.i16[3] = 15360;
    v13.i32[0] = (int)v22;
    v13.i16[2] = WORD2(v22);
    v10.i32[0] = (unint64_t)v22 >> 48;
  }
  else
  {
    v13.i32[0] = *(_DWORD *)v11;
    v13.i16[2] = *(_WORD *)(v11 + 4);
    v13.i16[3] = unk_209BD7740;
    v10.i16[0] = *(_WORD *)(v11 + 6);
  }
  *(float16x4_t *)&v21[12] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v10, 0)), vcvtq_f32_f16(v13)));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x24, 4uLL, 0, &v22);
  v14 = v22;
  if (v22)
  {
    v15 = *((_QWORD *)v22 + 7) + v23.i64[0];
    v16 = v20;
    v17 = *(_OWORD *)v21;
    *(_DWORD *)(v15 + 32) = *(_DWORD *)&v21[16];
    *(_OWORD *)v15 = v16;
    *(_OWORD *)(v15 + 16) = v17;
  }
  else
  {
    v22 = 0;
    v23 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v14);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v23);
  return *(_QWORD *)(a1 + 8);
}

void RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::generate(uint64_t a1, uint64_t (*a2)(RB::Path::Mapper *__hidden this), uint64_t a3, uint64_t a4, float64x2_t a5, float32x2_t a6, float32x2_t a7)
{
  RB::Coverage::StrokeablePath::map(a1 + 8, a1, a2, a5, a6, a7, a3, a4);
}

void RB::Coverage::StrokeablePath::map(uint64_t a1, uint64_t a2, uint64_t (*a3)(RB::Path::Mapper *__hidden this), float64x2_t a4, float32x2_t a5, float32x2_t a6, uint64_t a7, uint64_t a8)
{
  float v14;
  float v15;
  float v16;
  __int128 v17;
  float64x2_t *v18;
  float64x2_t v19;
  float64x2_t v20;
  float32x2_t v21;
  float32x2_t v22;
  _BOOL8 v23;
  _OWORD *v24;
  __int128 v25;
  __int128 v26;
  float64x2_t v27;
  const CGPath *v28;
  void *v29;
  double v30;
  float32x2_t v31;
  char v32;
  char v33;
  float v34;
  uint64_t v35;
  float v36;
  int v37;
  float v38;
  float v39;
  float32x2_t v40;
  float32x2_t v41;
  double v42;
  double v44;
  float32x2_t v45;
  float64x2_t v46;
  __int128 v47;
  float64x2_t v48;

  if (*(_QWORD *)(a1 + 8) != 0x209BD98A8)
  {
    v14 = *(float *)(a1 + 24);
    v15 = v14 * 0.70711;
    if (!*(_BYTE *)(a2 + 74))
    {
      v16 = (float)(v14 * 0.5) * fmaxf(*(float *)(a2 + 80), 1.0);
      if (v15 < v16)
        v15 = v16;
    }
    v17 = *(_OWORD *)(a8 + 16);
    v46 = *(float64x2_t *)a8;
    v47 = v17;
    v48 = *(float64x2_t *)(a8 + 32);
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v46))
      v18 = &v46;
    else
      v18 = (float64x2_t *)a8;
    v19 = v18[1];
    v20 = v18[2];
    v46 = *v18;
    v47 = (__int128)v19;
    v48 = v20;
    v21 = RB::operator*(&v46, a5, a6);
    v44 = *(double *)&v21;
    v45 = v22;
    v21.f32[0] = -v15;
    v23 = RB::Rect::inset((float32x2_t *)&v44, v21, -v15);
    v24 = *(_OWORD **)(a1 + 16);
    if (v24)
    {
      v25 = *v24;
      v26 = v24[1];
      v27 = *((float64x2_t *)v24 + 2);
    }
    else
    {
      v25 = xmmword_209BD5290;
      v26 = xmmword_209BD52A0;
      v27 = 0uLL;
    }
    v28 = *(const CGPath **)a1;
    v29 = *(void **)(a1 + 8);
    v46 = (float64x2_t)v25;
    v47 = v26;
    v48 = vaddq_f64(v27, a4);
    v30 = v44;
    v31 = v45;
    v32 = *(_BYTE *)(a2 + 73);
    v33 = *(_BYTE *)(a2 + 74);
    v34 = *(float *)(a2 + 80);
    v35 = *(_QWORD *)(a1 + 32);
    v36 = *(float *)(a1 + 24);
    v37 = *(_DWORD *)(a1 + 28);
    v38 = RB::bezier_flatness((RB *)v23);
    v39 = RB::AffineTransform::scale((float64x2_t *)a8);
    v40 = vrecpe_f32((float32x2_t)LODWORD(v39));
    v41 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v39), v40), v40);
    LODWORD(v42) = v37;
    RB::Stroke::flatten_points(v28, v29, &v46, a3, v32, v33, v35, v30, v31, v36, v34, v42, v38 * vmul_f32(v41, vrecps_f32((float32x2_t)LODWORD(v39), v41)).f32[0]);
  }
}

float32x2_t *RB::Stroke::Dasher::lineto(float32x2_t *result, float *a2, uint64_t a3, __n128 a4, double a5, double a6, double a7, __n128 a8)
{
  unint64_t v10;
  uint64_t v11;
  float32x2_t v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  int v19;
  float v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  float v26;
  float v27;

  v10 = a4.n128_u64[0];
  v11 = (uint64_t)result;
  v12 = vsub_f32((float32x2_t)a4.n128_u64[0], result[18]);
  v13 = *a2 - result[19].f32[0];
  v14 = a2[1] - result[19].f32[1];
  v15 = sqrtf(vaddv_f32(vmul_f32(v12, v12)));
  v16 = result[17].f32[0];
  if (v15 <= v16)
  {
    if (result[15].i8[0])
    {
      a8.n128_u32[0] = 1.0;
      a4.n128_u64[0] = (unint64_t)v12;
      result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment((uint64_t)result, a3, a4, *a2 - result[19].f32[0], a2[1] - result[19].f32[1], 0.0, a8);
      *(_BYTE *)(v11 + 160) = 0;
      v16 = *(float *)(v11 + 136);
    }
    v27 = v16 - v15;
    goto LABEL_18;
  }
  if (v15 < (float)(result[4].f32[0] * 8192.0))
  {
    v17 = 0.0;
    v18 = 1.0 / v15;
    if (v16 >= v15)
    {
      v26 = result[17].f32[0];
    }
    else
    {
      v19 = result[15].u8[0];
      v20 = 0.0;
      do
      {
        v17 = v16;
        if (v19)
        {
          a8.n128_f32[0] = v16 * v18;
          if (v16 == v15)
            v21 = a3;
          else
            v21 = 1;
          a4.n128_u64[0] = (unint64_t)v12;
          result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment(v11, v21, a4, v13, v14, v20 * v18, a8);
          v19 = *(unsigned __int8 *)(v11 + 120);
        }
        v22 = *(_QWORD *)(v11 + 128);
        v23 = *(_QWORD *)(v11 + 24);
        v24 = *(_QWORD *)(v11 + 16) - 1;
        v19 ^= 1u;
        *(_BYTE *)(v11 + 120) = v19;
        if (v22 == v24)
          v25 = 0;
        else
          v25 = v22 + 1;
        v26 = *(float *)(v23 + 4 * v25);
        *(_QWORD *)(v11 + 128) = v25;
        *(float *)(v11 + 136) = v26;
        *(_BYTE *)(v11 + 160) = 1;
        v16 = v26 + v17;
        v20 = v17;
      }
      while ((float)(v26 + v17) < v15);
    }
    if (v17 < v15)
    {
      if (*(_BYTE *)(v11 + 120))
      {
        a8.n128_u32[0] = 1.0;
        a4.n128_u64[0] = (unint64_t)v12;
        result = (float32x2_t *)RB::Stroke::Dasher::add_dash_segment(v11, a3, a4, v13, v14, v17 * v18, a8);
        *(_BYTE *)(v11 + 160) = 0;
        v26 = *(float *)(v11 + 136);
      }
      v27 = (float)(v17 - v15) + v26;
LABEL_18:
      *(float *)(v11 + 136) = v27;
    }
  }
  *(_QWORD *)(v11 + 144) = v10;
  *(_QWORD *)(v11 + 152) = *(_QWORD *)a2;
  return result;
}

uint64_t RB::Stroke::Dasher::add_dash_segment(uint64_t a1, uint64_t a2, __n128 a3, float32_t a4, float32_t a5, float a6, __n128 a7)
{
  float32x2_t v8;
  double v9;
  float32x2_t v11;
  float32x2_t v12;
  uint32x2_t v13;
  uint32x2_t v14;
  float v17;
  float32x2_t v20;

  v8.f32[0] = a4;
  v9 = a3.n128_f64[0];
  v11 = vmla_n_f32(*(float32x2_t *)(a1 + 144), (float32x2_t)a3.n128_u64[0], a6);
  v12 = vmla_n_f32(*(float32x2_t *)(a1 + 144), (float32x2_t)a3.n128_u64[0], a7.n128_f32[0]);
  if (*(_BYTE *)(a1 + 160))
  {
    v17 = a5;
    if (a6 < 0.00001 && (*(_BYTE *)(a1 + 80) & 1) != 0)
      a3.n128_u64[0] = *(_QWORD *)(a1 + 56);
    (*(void (**)(_QWORD, _QWORD, __n128))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 0, a3);
    v20 = vmla_n_f32(*(float32x2_t *)(a1 + 152), (float32x2_t)__PAIR64__(LODWORD(v17), LODWORD(a4)), a6);
    (*(void (**)(_QWORD, float32x2_t *, double))(**(_QWORD **)(a1 + 8) + 8))(*(_QWORD *)(a1 + 8), &v20, *(double *)&v11);
    a5 = v17;
    v8.f32[0] = a4;
  }
  v8.f32[1] = a5;
  v20 = vmla_n_f32(*(float32x2_t *)(a1 + 152), v8, a7.n128_f32[0]);
  v13 = (uint32x2_t)vcgt_f32(vminnm_f32(v11, v12), *(float32x2_t *)(a1 + 48));
  if ((vpmax_u32(v13, v13).u32[0] & 0x80000000) != 0
    || (v14 = (uint32x2_t)vcgt_f32(*(float32x2_t *)(a1 + 40), vmaxnm_f32(v11, v12)),
        (vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0))
  {
    (*(void (**)(_QWORD, float32x2_t *, double))(**(_QWORD **)(a1 + 8) + 24))(*(_QWORD *)(a1 + 8), &v20, *(double *)&v12);
  }
  else
  {
    (*(void (**)(_QWORD, float32x2_t *, uint64_t, double))(**(_QWORD **)(a1 + 8) + 16))(*(_QWORD *)(a1 + 8), &v20, a2, *(double *)&v12);
  }
  if (a7.n128_f32[0] > 0.99999 && (*(_BYTE *)(a1 + 80) & 2) != 0)
    v9 = *(double *)(a1 + 64);
  return (*(uint64_t (**)(_QWORD, uint64_t, double, __n128))(**(_QWORD **)(a1 + 8) + 32))(*(_QWORD *)(a1 + 8), 1, v9, a7);
}

uint64_t RB::`anonymous namespace'::StrokeLines::tangent(uint64_t result, int a2, double a3)
{
  if (a2 == 1)
  {
    *(double *)(result + 280) = a3;
  }
  else if (!a2)
  {
    *(double *)(result + 272) = a3;
  }
  return result;
}

void RB::`anonymous namespace'::StrokeLines::moveto(uint64_t a1, _QWORD *a2, double a3)
{
  *(double *)(a1 + 168) = a3;
  *(_QWORD *)(a1 + 200) = *a2;
  *(_BYTE *)(a1 + 176) = 1;
  *(_BYTE *)(a1 + 249) = 0;
}

double RB::`anonymous namespace'::StrokeLines::finish_subpath(uint64_t a1, int a2, int a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _OWORD *v18;
  uint64_t v19;
  float32x2_t v20;
  int32x2_t v21;
  float32x2_t v22;
  float32x2_t v23;
  int32x2_t v24;
  float32x2_t v25;
  float32x2_t v26;
  int32x2_t v27;
  unsigned __int32 v28;
  float32x2_t v29;
  int32x2_t v30;
  float32x2_t v31;
  int32x2_t v32;
  int32x2_t v33;
  float32x2_t v34;
  float v35;
  float v36;
  float32x2_t v38;
  float v39;
  float32x2_t v40;
  float v42;
  float v43;
  float32x2_t *v50;
  float32x2_t v51;
  __int32 *v52;
  __int16 *v53;
  __int16 v54;
  uint64_t v55;
  __int128 v56;
  BOOL v58;
  __int32 v59;
  __int16 v60;
  float32x2_t *v61;
  _QWORD *v62;
  double result;

  v4 = *(_QWORD *)(a1 + 120);
  if (v4)
  {
    v5 = *(_QWORD *)(a1 + 192);
    if (v5)
    {
      if (v5 == 2)
      {
        if ((*(_DWORD *)(a1 + 24) & 0x7000) == 0x2000)
          goto LABEL_11;
        v7 = (_QWORD *)(*(_QWORD *)(v4 + 56) + *(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144));
        v8 = *(v7 - 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000;
        *v7 = *(v7 - 2);
        v9 = 1;
      }
      else
      {
        if (v5 != 1)
          goto LABEL_11;
        v6 = *(_QWORD *)(a1 + 144);
        if ((*(_BYTE *)(a1 + 25) & 0x70) != 0)
        {
          *(_QWORD *)(a1 + 144) = v6 - 16;
          --*(_QWORD *)(a1 + 112);
          *(_QWORD *)(a1 + 192) = 0;
          goto LABEL_41;
        }
        v10 = (_QWORD *)(*(_QWORD *)(v4 + 56) + *(_QWORD *)(a1 + 128) + v6);
        v11 = *(v10 - 2);
        v8 = *(v10 - 1) & 0xFFFFFFFFFFFFLL | 0x1000000000000;
        *v10 = v11;
        v10[1] = v8;
        v12 = *(_QWORD *)(a1 + 144) + 16;
        *(_QWORD *)(a1 + 144) = v12;
        v7 = (_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + v12);
        *v7 = v11;
        v9 = 2;
      }
      v7[1] = v8;
      *(_QWORD *)(a1 + 144) += 16;
      *(_QWORD *)(a1 + 112) += v9;
      *(_QWORD *)(a1 + 192) += v9;
LABEL_11:
      v13 = *(_QWORD *)(a1 + 144);
      v14 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128);
      v15 = v14 + v13;
      if (a2)
      {
        v16 = *(_QWORD *)(a1 + 208);
        v17 = 232;
        if (!v16)
          v17 = 184;
        if ((*(_QWORD *)(a1 + v17) & 0x8000000000000000) == 0)
        {
          v18 = (_OWORD *)(v15 - 32);
          if (v16)
          {
            v14 = *(_QWORD *)(v16 + 56);
            v19 = *(_QWORD *)(a1 + 216) + *(_QWORD *)(a1 + 232);
          }
          else
          {
            v19 = *(_QWORD *)(a1 + 184);
          }
          v55 = v14 + v19;
          if (*(__int16 *)(v55 + 30) == -2)
          {
            v56 = *(_OWORD *)(v55 + 16);
            *(_OWORD *)(v55 + 16) = *(_OWORD *)v55;
            *(_OWORD *)(v55 + 32) = v56;
            *(_WORD *)(v55 + 14) = -1;
            v55 += 16;
          }
          *(_OWORD *)v55 = *v18;
          v54 = -1;
          *(_WORD *)(v55 + 14) = -1;
          *(_WORD *)(v55 + 30) = a3;
          v58 = a3 != 1 || *(_BYTE *)(a1 + 288) != 0;
          *(_BYTE *)(a1 + 288) = v58;
          v51 = *(float32x2_t *)(v55 + 32);
          v52 = (__int32 *)(v55 + 40);
          v53 = (__int16 *)(v55 + 44);
          v13 = *(_QWORD *)(a1 + 144);
          goto LABEL_40;
        }
        *(_WORD *)(v15 - 2) = 1;
      }
      else
      {
        *(_WORD *)(v15 - 2) = 1;
        if (!*(_BYTE *)(a1 + 249) && (*(_DWORD *)(a1 + 24) & 0x7000) == 0x2000)
        {
          v20 = *(float32x2_t *)(a1 + 280);
          v21 = (int32x2_t)vmul_f32(v20, v20);
          v21.i32[0] = vadd_f32((float32x2_t)v21, (float32x2_t)vdup_lane_s32(v21, 1)).u32[0];
          v22 = vrsqrte_f32((float32x2_t)v21.u32[0]);
          v23 = vmul_f32(vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v22, v22)), v22);
          v24 = (int32x2_t)vmul_n_f32(v20, vmul_f32(v23, vrsqrts_f32((float32x2_t)v21.u32[0], vmul_f32(v23, v23))).f32[0]);
          v25 = *(float32x2_t *)(v15 - 16);
          v26 = vsub_f32(v25, *(float32x2_t *)(v15 - 32));
          v27 = (int32x2_t)vmul_f32(v26, v26);
          v28 = vadd_f32((float32x2_t)v27, (float32x2_t)vdup_lane_s32(v27, 1)).u32[0];
          v29 = vrsqrte_f32((float32x2_t)v28);
          v30 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v28, vmul_f32(v29, v29)), v29);
          v31 = vmul_n_f32(v26, vmul_f32((float32x2_t)v30, vrsqrts_f32((float32x2_t)v28, vmul_f32((float32x2_t)v30, (float32x2_t)v30))).f32[0]);
          *(float *)v30.i32 = -*(float *)&v24.i32[1];
          v32 = (int32x2_t)vmul_f32(v31, (float32x2_t)vzip1_s32(v30, v24));
          v33 = (int32x2_t)vmul_f32(v31, (float32x2_t)v24);
          v34 = vadd_f32((float32x2_t)vzip1_s32(v32, v33), (float32x2_t)vzip2_s32(v32, v33));
          v35 = (float)(*(float *)(a1 + 200) * v34.f32[0]) / v34.f32[1];
          if (COERCE_UNSIGNED_INT(fabs(v35)) <= 0x7F7FFFFF)
          {
            v36 = sqrtf(vaddv_f32((float32x2_t)v27));
            *(float *)v27.i32 = fabsf(v35);
            if (*(float *)v27.i32 > *(float *)(a1 + 152) && *(float *)v27.i32 < v36)
            {
              v38 = vmls_lane_f32(v25, v31, (float32x2_t)v27, 0);
              v39 = v36;
              v40 = vrecpe_f32((float32x2_t)LODWORD(v36));
              _D3 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v39), v40), v40);
              _D3.f32[0] = *(float *)v27.i32 * vmul_f32(_D3, vrecps_f32((float32x2_t)LODWORD(v39), _D3)).f32[0];
              v42 = *(float *)(v15 - 8);
              v43 = v42 + (float)((float)(*(float *)(v15 - 24) - v42) * _D3.f32[0]);
              _H2 = *(_WORD *)(v15 - 4);
              _H6 = *(_WORD *)(v15 - 20);
              __asm
              {
                FCVT            H3, S3
                FCVT            S7, H2
                FCVT            S6, H6
                FCVT            S3, H3
              }
              _D3.f32[0] = _S7 + (float)((float)(_S6 - _S7) * _D3.f32[0]);
              __asm { FCVT            H3, S3 }
              *(float32x2_t *)(v15 - 16) = v38;
              *(float *)(v15 - 8) = v43;
              *(_WORD *)(v15 - 4) = _D3.i16[0];
              *(_WORD *)(v15 - 2) = 2;
              if (!*(_BYTE *)(a1 + 288))
                *(_BYTE *)(a1 + 288) = 1;
              v50 = (float32x2_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56)
                                  + *(_QWORD *)(a1 + 128)
                                  + *(_QWORD *)(a1 + 144));
              *v50 = v25;
              v50[1].f32[0] = v42;
              v50[1].i16[2] = _H2;
              v50[1].i16[3] = -2;
              v13 = *(_QWORD *)(a1 + 144) + 16;
              *(_QWORD *)(a1 + 144) = v13;
              ++*(_QWORD *)(a1 + 112);
            }
          }
        }
      }
      v51 = vadd_f32(*(float32x2_t *)(a1 + 280), *(float32x2_t *)(v15 - 16));
      v52 = (__int32 *)(v15 - 8);
      v53 = (__int16 *)(v15 - 4);
      v54 = -3;
LABEL_40:
      v59 = *v52;
      v60 = *v53;
      v61 = (float32x2_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + v13);
      *v61 = v51;
      v61[1].i32[0] = v59;
      v61[1].i16[2] = v60;
      v61[1].i16[3] = v54;
      *(_QWORD *)(a1 + 144) += 16;
      ++*(_QWORD *)(a1 + 112);
    }
  }
LABEL_41:
  v62 = (_QWORD *)(a1 + 208);
  if (*(_QWORD *)(a1 + 208))
  {
    *v62 = 0;
    *(_QWORD *)(a1 + 216) = 0;
    *(_QWORD *)(a1 + 224) = 0;
    *(_OWORD *)(a1 + 232) = xmmword_209BD7730;
  }
  result = NAN;
  *(_OWORD *)(a1 + 184) = xmmword_209BD7730;
  return result;
}

void RB::`anonymous namespace'::StrokeLines::lineto(uint64_t a1, float *a2, int a3, double a4)
{
  float32x2_t v8;
  int32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  int32x2_t v12;
  float32x2_t v13;
  int32x2_t v14;
  unsigned __int32 v15;
  float32x2_t v16;
  int32x2_t v17;
  float32x2_t v18;
  float v19;
  int32x2_t v20;
  int32x2_t v21;
  float32x2_t v22;
  float v23;
  float v24;
  float v25;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float v30;

  if (*(_BYTE *)(a1 + 176))
  {
    *(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 144) - 16;
    *(_BYTE *)(a1 + 176) = 0;
    if (!*(_BYTE *)(a1 + 249) && (*(_DWORD *)(a1 + 24) & 0x7000) == 0x2000)
    {
      v8 = *(float32x2_t *)(a1 + 272);
      v9 = (int32x2_t)vmul_f32(v8, v8);
      v9.i32[0] = vadd_f32((float32x2_t)v9, (float32x2_t)vdup_lane_s32(v9, 1)).u32[0];
      v10 = vrsqrte_f32((float32x2_t)v9.u32[0]);
      v11 = vmul_f32(vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v10, v10)), v10);
      v12 = (int32x2_t)vmul_n_f32(v8, vmul_f32(v11, vrsqrts_f32((float32x2_t)v9.u32[0], vmul_f32(v11, v11))).f32[0]);
      v13 = vsub_f32(*(float32x2_t *)&a4, *(float32x2_t *)(a1 + 168));
      v14 = (int32x2_t)vmul_f32(v13, v13);
      v15 = vadd_f32((float32x2_t)v14, (float32x2_t)vdup_lane_s32(v14, 1)).u32[0];
      v16 = vrsqrte_f32((float32x2_t)v15);
      v17 = (int32x2_t)vmul_f32(vrsqrts_f32((float32x2_t)v15, vmul_f32(v16, v16)), v16);
      v18 = vmul_n_f32(v13, vmul_f32((float32x2_t)v17, vrsqrts_f32((float32x2_t)v15, vmul_f32((float32x2_t)v17, (float32x2_t)v17))).f32[0]);
      v19 = *(float *)(a1 + 200);
      *(float *)v17.i32 = -*(float *)&v12.i32[1];
      v20 = (int32x2_t)vmul_f32(v18, (float32x2_t)vzip1_s32(v17, v12));
      v21 = (int32x2_t)vmul_f32(v18, (float32x2_t)v12);
      v22 = vadd_f32((float32x2_t)vzip1_s32(v20, v21), (float32x2_t)vzip2_s32(v20, v21));
      v23 = (float)(v19 * v22.f32[0]) / v22.f32[1];
      if ((LODWORD(v23) & 0x7FFFFFFFu) <= 0x7F7FFFFF)
      {
        v24 = sqrtf(vaddv_f32((float32x2_t)v14));
        v25 = fabsf(v23);
        if (v25 > *(float *)(a1 + 152) && v25 < v24)
        {
          *(_WORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144) - 2) = -2;
          *(_BYTE *)(a1 + 288) = 1;
          v27 = v24;
          v28 = vrecpe_f32((float32x2_t)LODWORD(v24));
          v29 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v27), v28), v28);
          v30 = v25 * vmul_f32(v29, vrecps_f32((float32x2_t)LODWORD(v27), v29)).f32[0];
        }
      }
    }
  }
  if (*(_BYTE *)(a1 + 249))
  {
    *(_BYTE *)(a1 + 249) = 0;
  }
}

void RB::`anonymous namespace'::StrokeLines::add_point(uint64_t a1, int a2, double a3, float a4, float _S2)
{
  uint32x2_t v9;
  float32x2_t v10;
  float64x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  unint64_t v18;
  uint64_t v19;
  __n128 v20;

  if (a4 > 0.0 && a2 != -3)
  {
    if (*(_QWORD *)(a1 + 192))
    {
      v9 = (uint32x2_t)vceq_f32(*(float32x2_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 120) + 56)+ *(_QWORD *)(a1 + 128)+ *(_QWORD *)(a1 + 144)- 16), *(float32x2_t *)&a3);
      if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0)
        return;
    }
    v10 = vmul_n_f32(*(float32x2_t *)(a1 + 160), a4);
    if (!a2)
      v10 = vmul_n_f32(v10, *(float *)(a1 + 156));
    v11 = vcvtq_f64_f32(*(float32x2_t *)&a3);
    *(float32x2_t *)&v11.f64[0] = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(a1 + 64), *(float64x2_t *)(a1 + 32), v11.f64[0]), *(float64x2_t *)(a1 + 48), v11, 1));
    v12 = vminnm_f32(*(float32x2_t *)(a1 + 96), vsub_f32(*(float32x2_t *)&v11.f64[0], v10));
    v13 = vmaxnm_f32(*(float32x2_t *)(a1 + 104), vadd_f32(v10, *(float32x2_t *)&v11.f64[0]));
    *(float32x2_t *)(a1 + 96) = v12;
    *(float32x2_t *)(a1 + 104) = v13;
    if (_S2 != 1.0)
      *(_BYTE *)(a1 + 88) = 1;
  }
  v20.n128_f64[0] = a3;
  v20.n128_f32[2] = a4;
  __asm { FCVT            H0, S2 }
  v20.n128_u16[6] = _H0;
  v20.n128_u16[7] = a2;
  if (!*(_QWORD *)(a1 + 120) || (unint64_t)(*(_QWORD *)(a1 + 144) + 64) > *(_QWORD *)(a1 + 136))
  if (!*(_BYTE *)(a1 + 288) && (a2 + 2) <= 4 && ((1 << (a2 + 2)) & 0x15) != 0)
    *(_BYTE *)(a1 + 288) = 1;
  v18 = v20.n128_u64[1];
  v19 = *(_QWORD *)(*(_QWORD *)(a1 + 120) + 56) + *(_QWORD *)(a1 + 128) + *(_QWORD *)(a1 + 144);
  *(double *)v19 = a3;
  *(_QWORD *)(v19 + 8) = v18;
  *(_QWORD *)(a1 + 144) += 16;
  ++*(_QWORD *)(a1 + 112);
  ++*(_QWORD *)(a1 + 192);
}

void RB::Stroke::flatten_points(CGPathRef path, void *a2, float64x2_t *a3, uint64_t (*a4)(RB::Path::Mapper *__hidden this), char a5, char a6, uint64_t a7, double a8, float32x2_t a9, float a10, float a11, double a12, float a13)
{
  float v22;
  float v23;
  uint64_t v24;
  uint32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float v28;
  float v29;
  float v30;
  uint64_t (*v31[5])(RB::Path::Mapper *__hidden);
  char v32;
  char v33;
  float v34;
  float v35;
  float v36;
  BOOL v37;
  int v38;
  uint64_t v39;
  char v40;
  int v41;
  uint64_t v42;
  uint64_t v43;
  float v44;
  int v45;
  uint64_t v46;

  v46 = *MEMORY[0x24BDAC8D0];
  if (a7)
  {
    MEMORY[0x24BDAC7A8](path, a2);
    v30 = v22;
    v24 = RB::Stroke::Dasher::Dasher(v23);
    a13 = v30;
    a9 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    a8 = 7.29112205e-304;
    a4 = (uint64_t (*)(RB::Path::Mapper *__hidden))v24;
  }
  v31[0] = (uint64_t (*)(RB::Path::Mapper *__hidden))off_24C22A518;
  v31[1] = (uint64_t (*)(RB::Path::Mapper *__hidden))off_24C2297F0;
  v31[2] = a4;
  v31[3] = *(uint64_t (**)(RB::Path::Mapper *__hidden))&a8;
  v31[4] = (uint64_t (*)(RB::Path::Mapper *__hidden))vadd_f32(*(float32x2_t *)&a8, a9);
  v32 = a5;
  v33 = a6;
  v25 = (uint32x2_t)vcge_f32(vabs_f32(a9), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  v37 = vpmax_u32(v25, v25).i32[0] >= 0;
  v38 = 0;
  v39 = 0x3F80000000000000;
  v40 = 1;
  v41 = 0;
  v42 = 0x3F80000000000000;
  v43 = 0x3F80000000000000;
  v26 = vrecpe_f32((float32x2_t)LODWORD(a13));
  v27 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a13), v26), v26);
  LODWORD(v28) = vmul_f32(v27, vrecps_f32((float32x2_t)LODWORD(a13), v27)).u32[0];
  v29 = a10 * 0.0375;
  if ((float)(a10 * 0.05) <= 1.0)
    v29 = 0.75;
  v34 = a11 * a11;
  v35 = v29 * v28;
  v36 = a13;
  v45 = 1065353216;
  v44 = a10 * 0.5;
  RBPathMap(path, a2, v31, a3);
}

uint64_t RB::Stroke::Dasher::Dasher(uint64_t a1, uint64_t a2, uint64_t a3, float *a4, float a5, float32x2_t a6, float32x2_t a7)
{
  float v10;
  float *v11;
  uint64_t v12;
  float v13;
  float v14;
  float v15;
  unint64_t v16;
  int v17;

  *(_QWORD *)a1 = off_24C2297B8;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 16) = a3;
  *(_QWORD *)(a1 + 24) = a4;
  *(_DWORD *)(a1 + 32) = 0;
  *(double *)(a1 + 40) = *(double *)&a6;
  *(float32x2_t *)(a1 + 48) = vadd_f32(a7, a6);
  *(_BYTE *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 112) = 0x3F80000000000000;
  *(_QWORD *)(a1 + 152) = 0x3F80000000000000;
  v10 = 0.0;
  if (a3)
  {
    v11 = a4;
    v12 = a3;
    do
    {
      v13 = *v11++;
      v10 = v10 + v13;
      *(float *)(a1 + 32) = v10;
      --v12;
    }
    while (v12);
  }
  v14 = fmodf(a5, v10);
  if ((LODWORD(v14) & 0x7FFFFFFFu) >= 0x7F800000)
    v14 = 0.0;
  while (v14 < 0.0)
    v14 = v14 + v10;
  *(_QWORD *)(a1 + 88) = 0;
  *(_BYTE *)(a1 + 81) = 1;
  v15 = *a4;
  if (v14 >= *a4)
  {
    v16 = 0;
    v17 = 1;
    do
    {
      if (v14 == 0.0 && v15 == 0.0)
        break;
      v14 = v14 - v15;
      v17 ^= 1u;
      *(_BYTE *)(a1 + 81) = v17;
      if (v16 < a3 - 1)
        ++v16;
      else
        v16 = 0;
      *(_QWORD *)(a1 + 88) = v16;
      v15 = a4[v16];
    }
    while (v14 >= v15);
  }
  *(float *)(a1 + 96) = v15 - v14;
  return a1;
}

void RB::`anonymous namespace'::StrokeLines::draw_buffer(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v8;
  int v9;
  int32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  uint32x2_t v13;
  int8x8_t v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  int32x2_t v18;
  int32x2_t v19;

  v8 = *(_QWORD *)(a1 + 16);
  v9 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v8, *(RB::Buffer **)a2);
  v10.i32[0] = 0;
  *(_DWORD *)(v8 + 196) = v9;
  *(int32x2_t *)(v8 + 200) = vmovn_s64(*(int64x2_t *)(a2 + 8));
  v12 = *(float32x2_t *)(a1 + 96);
  v11 = *(float32x2_t *)(a1 + 104);
  v13 = (uint32x2_t)vcgt_f32(v11, v12);
  v14 = (int8x8_t)vdup_lane_s32(vcgt_s32(v10, (int32x2_t)vpmin_u32(v13, v13)), 0);
  RB::Bounds::Bounds(&v18, (float32x2_t)vand_s8((int8x8_t)v12, v14), (float32x2_t)vand_s8((int8x8_t)vsub_f32(v11, v12), v14));
  v15 = *(_DWORD *)(a1 + 24);
  v16 = *(unsigned int *)(a1 + 28);
  if (*(_BYTE *)(a1 + 88))
    v17 = v15 | 0x40000;
  else
    v17 = v15;
  if (a3 > 3)
    RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)(a1 + 16), (const char *)(v17 | (v16 << 32)), 4, ****(_QWORD ****)(a1 + 16) + 80, 0, a3 - 3, v18, v19);
  if (a3 >= 3 && a4)
    RB::RenderPass::draw_indexed_primitives(*(int32x2_t **)(a1 + 16), (const char *)(v17 & 0xFFFFFFC0 | 0xF | (v16 << 32)), 4, ****(_QWORD ****)(a1 + 16) + 80, 0, a3 - 2, v18, v19);
  *(_QWORD *)(v8 + 200) = 0;
  *(_DWORD *)(v8 + 196) = 0;
}

void sub_209AE4640(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

int32x2_t *RB::render_masks_accumulate(int32x2_t *result, int32x2_t *a2, unint64_t a3, uint64_t a4, RB::Buffer *a5)
{
  int32x2_t *v9;
  __int32 v10;
  __int32 v11;
  __int32 v12;
  RB::Buffer *v13;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  float32x2_t v17;
  RB::Buffer *v18;
  int64x2_t v19;

  if (a5)
  {
    v9 = result;
    v10 = result[17].i32[0];
    v17 = (float32x2_t)result[14];
    v11 = result[15].i32[0];
    result[24].i32[1] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)result, *(RB::Buffer **)a4);
    v9[25] = vmovn_s64(*(int64x2_t *)(a4 + 8));
    v12 = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, a5);
    v9[26].i32[1] = 0;
    v9[27].i32[0] = 0;
    v9[26].i32[0] = v12;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)v9, (RB::Device *)0x1C, 4uLL, 0, &v18);
    v13 = v18;
    if (v18)
    {
      v14 = vneg_f32(v17);
      v14.i32[0] = 0;
      v15 = *((_QWORD *)v18 + 7) + v19.i64[0];
      *(_QWORD *)v15 = v17.u32[0];
      *(float32x2_t *)(v15 + 8) = v14;
      *(_QWORD *)(v15 + 16) = 0x3F800000BF800000;
      *(_DWORD *)(v15 + 24) = v11;
    }
    else
    {
      v18 = 0;
      v19 = 0uLL;
    }
    v9[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)v9, v13);
    *(int32x2_t *)((char *)v9 + 188) = vmovn_s64(v19);
    if (v10 == 2)
      v16 = 0x2000003C9;
    else
      v16 = 969;
    result = RB::RenderPass::draw_indexed_primitives(v9, (const char *)v16, 4, ***(_QWORD ***)v9 + 80, 0, a3, *a2, a2[1]);
    *(int32x2_t *)((char *)&v9[24] + 4) = 0;
    *(int32x2_t *)((char *)&v9[25] + 4) = 0;
    *(int32x2_t *)((char *)&v9[26] + 4) = 0;
  }
  return result;
}

void sub_209AE47CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  *(_QWORD *)(v1 + 200) = 0;
  *(_DWORD *)(v1 + 196) = 0;
  _Unwind_Resume(a1);
}

void RB::DisplayList::affine_style_roi(RB::DisplayList *this, float64x2_t *a2, float64x2_t *a3, int8x16_t *a4, const RB::AffineTransform *a5)
{
  uint32x2_t v5;
  int8x16_t v9;
  int8x16_t *v10;
  float64x2_t v11;
  float64x2_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int8x16_t v16;
  int8x16_t v17;
  int8x16_t v18;
  unint64_t v19;
  int8x16_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  int8x16_t v24;
  int8x16_t v25;
  int8x16_t v26;
  float64x2_t v27[3];
  int8x16_t v28;
  int8x16_t v29;
  int8x16_t v30;

  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*((_QWORD *)this + 1) & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    v9 = a4[1];
    v28 = *a4;
    v29 = v9;
    v30 = a4[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v28))
      v10 = &v28;
    else
      v10 = a4;
    v11 = (float64x2_t)v10[1];
    v12 = (float64x2_t)v10[2];
    v27[0] = *(float64x2_t *)v10;
    v27[1] = v11;
    v27[2] = v12;
    *(double *)v13.i64 = RB::operator*(v27, a3);
    v28 = v13;
    v29 = v14;
    v30 = v15;
    *(double *)v16.i64 = RB::operator*((float64x2_t *)&v28, (float64x2_t *)a4);
    v24 = v17;
    v25 = v16;
    v26 = v18;
    v28 = v16;
    v29 = v17;
    v30 = v18;
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v28))
      v19 = -1;
    else
      v19 = 0;
    v20 = (int8x16_t)vdupq_n_s64(v19);
    v28 = vbslq_s8(v20, v28, v25);
    v29 = vbslq_s8(v20, v29, v24);
    v30 = vbslq_s8(v20, v30, v26);
    v21.f64[0] = RB::operator*(a2, (float64x2_t *)&v28);
    *a2 = v21;
    a2[1] = v22;
    a2[2] = v23;
  }
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v17[3];
  __int16 v18;
  int v19;
  __int16 v20;
  __int16 v21;

  v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v17[0] = *v6;
  v17[1] = v8;
  v17[2] = _Q0;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  v18 = *(_WORD *)(a1 + 112);
  v19 = *(_DWORD *)(a1 + 114);
  _H1 = *(_WORD *)(a1 + 118);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  *(float *)_Q0.f64 = _S1 * *(float *)_Q0.f64;
  __asm { FCVT            H0, S0 }
  v20 = LOWORD(_Q0.f64[0]);
  v21 = *(_WORD *)(a1 + 120);
  return RB::render_primitive(a4, v17, a1 + 64, (uint64_t)&v18, a5, a6);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v15[3];

  v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v15[0] = *v6;
  v15[1] = v8;
  v15[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  return RB::render_primitive(a4, v15, (uint64_t)&a1[8], a1 + 14, a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, int a5)
{
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  float64x2_t v9;
  float v10;
  _OWORD v11[3];
  _BYTE v12[8];
  uint64_t v13;
  void *v14;
  char v15;
  int32x2_t *v16[6];

  v16[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v6 = *(_QWORD *)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  v8 = *(_OWORD *)(v6 + 16);
  v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v11[0] = *(_OWORD *)v6;
  v11[1] = v8;
  v11[2] = v9;
  v10 = *(float *)(a1 + 88);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v12, a3, (const RB::AffineTransform *)v11, (const RB::Coverage::Path *)(a1 + 56));
  RB::Path::Renderer::render_coverage(v16, a5, v10);
  if (v15)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v13);
  if (v14)
    free(v14);
}

void sub_209AE4AA0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47)
    free(a47);
  _Unwind_Resume(exception_object);
}

float RB::AffineTransform::scale(float64x2_t *this)
{
  float64x2_t v1;
  float64x2_t v2;
  double v3;
  double v4;
  BOOL v5;
  double v6;
  double v7;
  float result;
  int64x2_t v9;
  int64x2_t v10;
  float32x2_t v11;

  v1 = *this;
  v2 = this[1];
  v3 = this[1].f64[1];
  v4 = this->f64[1];
  if (this->f64[0] == v3 && v4 == 0.0 && v2.f64[0] == 0.0
    || v3 == 0.0 && (v1.f64[0] == 0.0 ? (v5 = v4 == v2.f64[0]) : (v5 = 0), v5))
  {
    v6 = fabs(v1.f64[0]);
    v7 = fabs(v4);
    if (v4 != 0.0)
      return v7;
    return v6;
  }
  else
  {
    v9 = (int64x2_t)vmulq_f64(v1, v1);
    v10 = (int64x2_t)vmulq_f64(v2, v2);
    v11 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v10, v9), (float64x2_t)vzip2q_s64(v10, v9)));
    result = 1.0;
    if (v11.f32[1] != 1.0 || v11.f32[0] != 1.0)
      return vaddv_f32(vsqrt_f32(v11)) * 0.5;
  }
  return result;
}

void RB::Coverage::Path::map(uint64_t a1, uint64_t (**a2)(RB::Path::Mapper *__hidden this), float64x2_t *a3)
{
  void *v4;
  float64x2_t *v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10[3];

  v4 = *(void **)(a1 + 8);
  if (v4 != &empty_path_callbacks)
  {
    v6 = *(float64x2_t **)(a1 + 16);
    if (v6)
    {
      v7.f64[0] = RB::operator*(v6, a3);
      v10[0] = v7;
      v10[1] = v8;
      v10[2] = v9;
      RBPathMap(*(CGPathRef *)a1, *(void **)(a1 + 8), a2, v10);
    }
    else
    {
      RBPathMap(*(CGPathRef *)a1, v4, a2, a3);
    }
  }
}

uint64_t $_4::__invoke($_4 *this, const void *a2)
{
  unint64_t NumberOfPoints;

  NumberOfPoints = CGPathGetNumberOfPoints();
  if (NumberOfPoints <= CGPathGetNumberOfElements())
    return 1;
  else
    return 3;
}

uint64_t RB::Path::Flattener::Flattener(uint64_t a1, void (***a2)(_QWORD), float a3, float32x2_t a4, float32x2_t a5)
{
  int32x2_t v6;
  float32x2_t v8;
  float32x2_t v9;

  v6 = vdup_n_s32(0x7F800000u);
  *(float32x2_t *)(a1 + 32) = vadd_f32(a5, a4);
  *(int32x2_t *)(a1 + 40) = v6;
  *(_QWORD *)(a1 + 48) = 0x7F0000007FLL;
  *(int32x2_t *)(a1 + 56) = v6;
  *(_QWORD *)(a1 + 64) = 0x7F0000007FLL;
  v8 = vrecpe_f32((float32x2_t)LODWORD(a3));
  v9 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a3), v8), v8);
  *(_QWORD *)a1 = off_24C229678;
  *(_QWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_BYTE *)(a1 + 88) = 0;
  *(float32x2_t *)(a1 + 16) = vmul_n_f32((float32x2_t)0x3F0000003F400000, vmul_f32(v9, vrecps_f32((float32x2_t)LODWORD(a3), v9)).f32[0]);
  *(double *)(a1 + 24) = *(double *)&a4;
  (**a2)(a2);
  return a1;
}

void RB::Path::Renderer::render_coverage(int32x2_t **a1, int a2, float a3)
{
  _BOOL4 may_discard_shape;
  uint64_t (**v5)();
  float v6;
  int v7;

  v5 = &off_24C22A4A0;
  v6 = a3;
  v7 = a2;
  may_discard_shape = RB::may_discard_shape(a2);
  RB::Path::Renderer::resolve(a1, (MTLPixelFormat)&v5, may_discard_shape);
}

uint64_t RB::Path::Accumulator::commit_buffer(RB::Path::Accumulator *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t result;

  v2 = *((_QWORD *)this + 32);
  if (*((_QWORD *)this + 31))
    v3 = (char *)*((_QWORD *)this + 31);
  else
    v3 = (char *)this + 120;
  v4 = v2 - 1;
  v5 = (uint64_t)&v3[32 * v2 - 32];
  v6 = *(unsigned __int8 *)(v5 + 28);
  if (v6 == 4)
  {
    if (*((_DWORD *)this + 76) != 1)
      goto LABEL_9;
    RB::Path::Accumulator::convert_to_lines((uint64_t)this, (uint64_t)&v3[32 * v2 - 32]);
    v6 = *(unsigned __int8 *)(v5 + 28);
  }
  if (v6 == 2)
  {
    v7 = *((_QWORD *)this + 34);
    v8 = 8 * v7;
    v9 = v7 - 1;
    goto LABEL_10;
  }
LABEL_9:
  v10 = *((_QWORD *)this + 34);
  *(_DWORD *)(*(_QWORD *)(*(_QWORD *)v5 + 56) + *(_QWORD *)(v5 + 8)) = v10 - 1;
  v8 = 32 * v10;
  v9 = *((_DWORD *)this + 74);
LABEL_10:
  *(_DWORD *)&v3[32 * v4 + 24] = v9;
  result = RB::RenderFrame::commit_buffer_region_size(*((_QWORD *)this + 1), v5, v8);
  *((_BYTE *)this + 280) = 0;
  if (!v8)
    --*((_QWORD *)this + 32);
  return result;
}

uint64_t RB::RenderFrame::commit_buffer_region_size(uint64_t result, uint64_t a2, uint64_t a3)
{
  *(_QWORD *)(a2 + 16) = a3;
  if (*(_BYTE *)(result + 144))
  {
    *(_QWORD *)(result + 136) = *(_QWORD *)(a2 + 8) + a3;
    *(_BYTE *)(result + 144) = 0;
  }
  return result;
}

uint64_t RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, float32x2_t *a4, int a5, unsigned int a6, float a7)
{
  unsigned int v7;
  uint64_t result;
  double v15;
  int is_opaque;
  BOOL v17;
  int v18;
  RB::Buffer *v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  _BOOL4 v27;
  unsigned int v28;
  unsigned int v29;
  int v30;
  unsigned int v31;
  int32x2_t v32;
  int32x2_t v33;
  _OWORD v34[3];
  int v35;
  _OWORD v36[5];
  _OWORD v37[3];
  uint64_t v38;
  RB::Buffer *v39;
  int64x2_t v40;

  v7 = a6;
  v35 = 0;
  memset(v34, 0, sizeof(v34));
  v32 = 0;
  v33 = 0;
  result = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v36, (float32x2_t *)a1, a2, a6, &v35, (uint64_t)v34, (uint64_t)&v32);
  if ((_DWORD)result)
  {
    if (a7 == 1.0)
      is_opaque = RB::Fill::Gradient::is_opaque(a4);
    else
      is_opaque = 0;
    if (v35 == 1)
    {
      v17 = v7 == 2 || v7 == 24;
      v18 = is_opaque ^ 1;
      if (!v17)
        v18 = 1;
      if (!v18)
        LOBYTE(v7) = 0;
    }
    *(float *)&v15 = a7;
    RB::Fill::Gradient::set_gradient(a4, (uint64_t)v37, a1, a2, v15);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x88, 4uLL, 0, &v39);
    v19 = v39;
    if (v39)
    {
      v20 = *((_QWORD *)v39 + 7) + v40.i64[0];
      v21 = v36[4];
      v23 = v36[1];
      v22 = v36[2];
      *(_OWORD *)(v20 + 48) = v36[3];
      *(_OWORD *)(v20 + 64) = v21;
      *(_OWORD *)(v20 + 16) = v23;
      *(_OWORD *)(v20 + 32) = v22;
      v25 = v37[1];
      v24 = v37[2];
      v26 = v37[0];
      *(_QWORD *)(v20 + 128) = v38;
      *(_OWORD *)(v20 + 96) = v25;
      *(_OWORD *)(v20 + 112) = v24;
      *(_OWORD *)(v20 + 80) = v26;
      *(_OWORD *)v20 = v36[0];
    }
    else
    {
      v39 = 0;
      v40 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v19);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v40);
    v31 = v35 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, &v31);
    v27 = *(_DWORD *)(a1 + 136) == 2;
    LODWORD(v39) = ((v31 & 0x3FF) << 12) | ((v7 & 0x3F) << 6) | 6;
    HIDWORD(v39) = a5 | (2 * v27);
    RB::Fill::Gradient::set_fill_state(a4, (int *)&v39, a1, a7);
    result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v39, 4, (uint64_t)v34, 0, 1uLL, v32, v33);
    if (*((_QWORD *)&v34[1] + 1))
    {
      v31 = v31 & 0xFFFFFFF0 | 1;
      v28 = v39;
      v29 = (v31 << 12) & 0x3FF000 | v39 & 0xFFC00FFF;
      LODWORD(v39) = v29;
      if (is_opaque)
      {
        v30 = (v28 >> 6) & 0x3F;
        if (v30 == 24 || v30 == 2)
          LODWORD(v39) = v29 & 0xFFFF103F;
      }
      result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v39, 4, (uint64_t)&v34[1] + 8, 0, 1uLL, v32, v33);
    }
    *(_QWORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 204) = 0;
    *(_QWORD *)(a1 + 220) = 0;
    *(_DWORD *)(a1 + 228) = 0;
  }
  return result;
}

uint64_t RB::Fill::Gradient::is_opaque(float32x2_t *this)
{
  uint32x2_t v1;

  if (!this[6].i8[7])
    return 0;
  if (this[6].i8[4] != 1)
    return 1;
  v1 = (uint32x2_t)vceq_f32(this[3], this[4]);
  return vpmin_u32(v1, v1).u32[0] >> 31;
}

float32x2_t RB::Fill::Gradient::set_gradient_geometry(float32x2_t *a1, float32x2_t *a2, float64x2_t *a3, uint64_t a4)
{
  float64x2_t v7;
  float64x2_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  int8x16_t v12;
  int8x16_t v13;
  int8x16_t v14;
  int8x16_t v15;
  float32x2_t v16;
  float32x2_t v17;
  int32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  uint64_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float32x2_t v28;
  uint32x2_t v29;
  float v30;
  float32x2_t v31;
  float v32;
  float v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float v38;
  int8x16_t v39;
  unsigned __int32 v40;
  float v41;
  float v42;
  uint64_t v43;
  float v44;
  int8x16_t v45;
  float v46;
  float v47;
  float32x2_t v48;
  uint32x2_t v49;
  float32x2_t v50;
  int32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  uint64_t v55;
  int8x16_t v56;
  int8x16_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;
  int32x2_t v61;
  float v62;
  float32x2_t v64;
  float v65;
  double v66;
  int32x2_t v67;
  double v68;
  float64x2_t v69;
  float v70;
  uint64_t v71;
  int64x2_t v72;
  float64x2_t v77;
  float64x2_t v78;
  float64x2_t v79;
  float32x2_t result;
  float v81;
  float v82;
  float64x2_t v83;
  int8x16_t v84;
  uint64_t v85;
  uint64_t v86;
  float64x2_t v87;
  float64x2_t v88;
  float64x2_t v89;

  v7 = a3[1];
  v87 = *a3;
  v88 = v7;
  v89 = a3[2];
  v8 = (float64x2_t *)a1[2];
  if (v8)
  {
    v9.f64[0] = RB::operator*(v8, &v87);
    v87 = v9;
    v88 = v10;
    v89 = v11;
  }
  RB::AffineTransform::invert((RB::AffineTransform *)&v87);
  switch(a1[6].i8[4])
  {
    case 0:
      v16 = a1[3];
      v17 = vsub_f32(a1[4], v16);
      v18 = (int32x2_t)vmul_f32(v17, v17);
      v18.i32[0] = vadd_f32((float32x2_t)v18, (float32x2_t)vdup_lane_s32(v18, 1)).u32[0];
      v19 = vrsqrte_f32((float32x2_t)v18.u32[0]);
      v20 = vmul_f32(vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v19, v19)), v19);
      *(float *)v18.i32 = vmul_f32(v20, vrsqrts_f32((float32x2_t)v18.u32[0], vmul_f32(v20, v20))).f32[0];
      v21 = vmul_n_f32(v17, *(float *)v18.i32);
      v89 = vsubq_f64(v89, vcvtq_f64_f32(v16));
      *(double *)&v22 = vmuls_lane_f32(-*(float *)v18.i32, v21, 1);
      v23 = (int8x16_t)vcvtq_f64_f32(vmul_n_f32(v21, *(float *)v18.i32));
      v24 = vextq_s8(v23, v23, 8uLL);
      v23.i64[1] = v22;
      v83 = (float64x2_t)v23;
      v84 = v24;
      v85 = 0;
      v86 = 0;
      v25.f64[0] = RB::operator*(&v87, &v83);
      v87 = v25;
      v88 = v26;
      v89 = v27;
      break;
    case 1:
      v28 = a1[3];
      *(float32x2_t *)v12.i8 = a1[4];
      v29 = (uint32x2_t)vceq_f32(v28, *(float32x2_t *)v12.i8);
      if ((vpmin_u32(v29, v29).u32[0] & 0x80000000) != 0)
      {
        v89 = vsubq_f64(v89, vcvtq_f64_f32(v28));
        v37 = a1[5].f32[0];
        v38 = a1[5].f32[1];
        *(float *)v12.i32 = v37 - v38;
        v13.i64[0] = 0x3C0000003C000000;
        v39.i64[0] = 0x8000000080000000;
        v39.i64[1] = 0x8000000080000000;
        v40 = vbslq_s8(v39, v13, v12).u32[0];
        if (vabds_f32(v37, v38) >= 0.0078125)
          v41 = v37 - v38;
        else
          v41 = *(float *)&v40;
        v36 = v37 / v41;
        a2[3].f32[0] = -1.0 / v41;
        goto LABEL_16;
      }
      v30 = a1[5].f32[1];
      if (v30 == 0.0)
      {
        v31 = a1[3];
        v28 = a1[4];
        v32 = a1[5].f32[1];
      }
      else
      {
        v32 = a1[5].f32[0];
        v31 = a1[4];
      }
      v42 = fabsf(v32);
      v43 = 11;
      if (v30 == 0.0)
        v43 = 10;
      v44 = fabsf(a1->f32[v43]);
      *(float *)v14.i32 = v42 - v44;
      v15.i64[0] = 0x3C0000003C000000;
      v45.i64[0] = 0x8000000080000000;
      v45.i64[1] = 0x8000000080000000;
      LODWORD(v46) = vbslq_s8(v45, v15, v14).u32[0];
      if (vabds_f32(v42, v44) < 0.0078125)
        *(float *)v14.i32 = v46;
      v47 = v42 / *(float *)v14.i32;
      v48 = vmla_n_f32(v28, vsub_f32(v31, v28), v42 / *(float *)v14.i32);
      v49 = (uint32x2_t)vceq_f32(v48, v31);
      if ((vpmin_u32(v49, v49).u32[0] & 0x80000000) == 0)
      {
        v50 = vsub_f32(v31, v48);
        v51 = (int32x2_t)vmul_f32(v50, v50);
        v51.i32[0] = vadd_f32((float32x2_t)v51, (float32x2_t)vdup_lane_s32(v51, 1)).u32[0];
        v52 = vrsqrte_f32((float32x2_t)v51.u32[0]);
        v53 = vmul_f32(vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v52, v52)), v52);
        *(float *)v51.i32 = vmul_f32(v53, vrsqrts_f32((float32x2_t)v51.u32[0], vmul_f32(v53, v53))).f32[0];
        v54 = vmul_n_f32(v50, *(float *)v51.i32);
        *(double *)&v55 = vmuls_lane_f32(-*(float *)v51.i32, v54, 1);
        v56 = (int8x16_t)vcvtq_f64_f32(vmul_n_f32(v54, *(float *)v51.i32));
        v57 = vextq_s8(v56, v56, 8uLL);
        v56.i64[1] = v55;
        v89 = vsubq_f64(v89, vcvtq_f64_f32(v48));
        v83 = (float64x2_t)v56;
        v84 = v57;
        v81 = v44 * *(float *)v51.i32;
        v82 = v47;
        v85 = 0;
        v86 = 0;
        v58.f64[0] = RB::operator*(&v87, &v83);
        v47 = v82;
        v44 = 1.0;
        *(float *)v61.i32 = (float)(v81 * v81) + -1.0;
        v62 = fabsf(*(float *)v61.i32);
        _NF = v62 < 0.0001;
        v64 = (float32x2_t)__PAIR64__(COERCE_UNSIGNED_INT(sqrtf(v62)), LODWORD(v81));
        v65 = vabds_f32(1.0, v82);
        v66 = COERCE_DOUBLE(vdiv_f32(vmul_n_f32(v64, v65), (float32x2_t)vdup_lane_s32(v61, 0)));
        *(float *)v67.i32 = v65 * 0.5;
        v68 = COERCE_DOUBLE(vdup_lane_s32(v67, 0));
        if (_NF)
          v66 = v68;
        else
          v44 = v81;
        v69 = vcvtq_f64_f32(*(float32x2_t *)&v66);
        v87 = vmulq_f64(v58, v69);
        v88 = vmulq_f64(v59, v69);
        v89 = vmulq_f64(v60, v69);
      }
      a2[3].f32[0] = v47;
      a2[3].f32[1] = v44;
      v70 = 0.0;
      if (v30 == 0.0)
        v70 = 1.0;
      a2[4].f32[0] = v70;
      break;
    case 2:
      v33 = a1[5].f32[0];
      goto LABEL_13;
    case 4:
      v34 = a1[5].f32[0];
      v33 = a1[5].f32[1];
      v35 = vabds_f32(v33, v34);
      if (v35 <= 6.2832)
      {
        if (v33 >= v34)
          v33 = a1[5].f32[0];
        v33 = (float)(v33 + -3.1416) + (float)(v35 * 0.5);
      }
LABEL_13:
      v89 = vsubq_f64(v89, vcvtq_f64_f32(a1[3]));
      v36 = v33 + (float)(floorf(v33 * 0.15915) * -6.2832);
      if (v36 > 3.1416)
        v36 = v36 + -6.2832;
      a2[3].f32[0] = v36 * -0.15915;
LABEL_16:
      a2[3].f32[1] = v36;
      break;
    default:
      break;
  }
  v71 = *(_QWORD *)(a4 + 104);
  v72.i64[0] = (int)v71;
  v72.i64[1] = SHIDWORD(v71);
  __asm { FMOV            V1.2D, #0.5 }
  v77 = vmulq_f64(vcvtq_f64_s64(v72), _Q1);
  v78 = vmulq_n_f64(v87, v77.f64[0]);
  v79 = vmlaq_laneq_f64(vaddq_f64(v78, v89), v88, v77, 1);
  *(float32x2_t *)&v77.f64[0] = vcvt_f32_f64(v78);
  *(float32x2_t *)&v78.f64[0] = vcvt_f32_f64(vmulq_n_f64(v88, -v77.f64[1]));
  *a2 = *(float32x2_t *)&v77.f64[0];
  a2[1] = *(float32x2_t *)&v78.f64[0];
  result = vcvt_f32_f64(v79);
  a2[2] = result;
  return result;
}

BOOL RB::AffineTransform::invert(RB::AffineTransform *this)
{
  int8x16_t v1;
  float64x2_t v2;
  double v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;

  v1 = *((int8x16_t *)this + 1);
  v2 = vmulq_f64((float64x2_t)vextq_s8(v1, v1, 8uLL), *(float64x2_t *)this);
  v3 = vsubq_f64(v2, (float64x2_t)vdupq_laneq_s64((int64x2_t)v2, 1)).f64[0];
  if (v3 != 0.0)
  {
    v4 = *((float64x2_t *)this + 2);
    v5 = (float64x2_t)vextq_s8((int8x16_t)v4, (int8x16_t)v4, 8uLL);
    v6.f64[0] = *((float64_t *)this + 2);
    v6.f64[1] = *((float64_t *)this + 1);
    v7 = vmulq_n_f64(v6, 1.0 / v3);
    v8 = vmulq_n_f64((float64x2_t)vextq_s8(v1, *(int8x16_t *)this, 8uLL), 1.0 / v3);
    v9 = vnegq_f64(vmulq_f64(v4, v8));
    v4.f64[0] = v8.f64[0];
    v4.f64[1] = vnegq_f64(v7).f64[1];
    v8.f64[0] = -v7.f64[0];
    *(float64x2_t *)this = v4;
    *((float64x2_t *)this + 1) = v8;
    *((float64x2_t *)this + 2) = vmlaq_f64(v9, v7, v5);
  }
  return v3 != 0.0;
}

float32x2_t RB::Fill::Gradient::set_gradient(float32x2_t *a1, uint64_t a2, uint64_t a3, float64x2_t *a4, double a5)
{
  RB::Fill::Gradient::set_gradient_color((uint64_t)a1, (float16x4_t *)(a2 + 36), a3, a5);
  return RB::Fill::Gradient::set_gradient_geometry(a1, (float32x2_t *)a2, a4, a3);
}

void RB::Fill::Gradient::set_gradient_color(uint64_t a1, float16x4_t *a2, uint64_t a3, double _D0)
{
  float v4;
  float16x4_t *v5;
  int v7;
  int v8;
  unsigned int v9;
  int v10;
  int v11;
  float *v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  float *v17;
  __int16 v18;
  int v19;
  int v20;
  float16x4_t *v21;
  float v22;
  uint64_t v23;
  size_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  float v28;
  float v29;
  char v30;
  uint64_t v31;
  RB::RenderFrame ***v32;
  RB::Buffer *v34;
  __int16 v35;
  uint64_t v36;
  float *v37;
  uint16x4_t *v38;
  float v39;
  float v40;
  float v48;
  uint64_t v49;
  int8x16_t v50;
  int8x16_t v51;
  double v52;
  double v53;
  double v54;
  int8x16_t v55;
  float16x4_t v56;
  const __int16 *v57;
  float16x4_t v58;
  uint64_t v59;
  uint64_t v60;
  size_t v61;
  char *v63;
  __int16 v64;
  unint64_t v65;
  unsigned __int16 *v66;
  uint64_t v67;
  int8x16_t v68;
  int8x16_t v69;
  double v70;
  double v71;
  double v72;
  int8x16_t v73;
  float16x4_t v74;
  const __int16 *v75;
  float16x4_t v76;
  float v77;
  RB::RenderFrame ***v79;
  __int16 v81;
  uint64_t v82;
  int8x16_t v83;
  int8x16_t v84;
  double v85;
  double v86;
  double v87;
  int8x16_t v88;
  float16x4_t v89;
  const __int16 *v90;
  float16x4_t v91;
  uint64_t v93;
  int8x16_t v94;
  int8x16_t v95;
  double v96;
  double v97;
  double v98;
  int8x16_t v99;
  float16x4_t v100;
  const __int16 *v102;
  float16x4_t v103;
  float v104;
  uint64_t v106;
  float16x4_t *v107;
  int v108;
  uint64_t v109;
  RB::RenderFrame ***v110;
  int v111;
  RB::Buffer *v112;
  int64x2_t v113;
  unint64_t v114;
  __int16 v115;
  uint64_t v116;

  v4 = *(float *)&_D0;
  v5 = a2;
  v116 = *MEMORY[0x24BDAC8D0];
  v7 = *(unsigned __int8 *)(a3 + 124);
  if (*(_BYTE *)(a1 + 54))
    v8 = *(unsigned __int8 *)(a1 + 53);
  else
    v8 = *(unsigned __int8 *)(a3 + 124);
  v9 = *(_DWORD *)(a1 + 48);
  v10 = v9 & 0xC0;
  v110 = (RB::RenderFrame ***)a3;
  switch(v10)
  {
    case 64:
      v111 = 0;
LABEL_12:
      v11 = v7 & 0xFE;
      goto LABEL_13;
    case 192:
      v111 = 1;
      goto LABEL_12;
    case 128:
      v11 = v7 | 1;
      break;
    default:
      v11 = v7;
      break;
  }
  v111 = 0;
LABEL_13:
  v13 = *(_QWORD *)a1;
  v12 = *(float **)(a1 + 8);
  v14 = HIWORD(v9) & 1;
  if ((v9 & 0x200) != 0 && v13 >= 2)
  {
    if (v15 >> 60)
      return;
    v16 = v15;
    if (16 * v15 <= 0x1000)
    {
      v18 = v8;
      MEMORY[0x24BDAC7A8](v15, 16 * v15);
      v17 = (float *)((char *)&v106 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v17, v24);
      v19 = 0;
      goto LABEL_28;
    }
    v17 = (float *)malloc_type_malloc(16 * v15, 0x5006145EuLL);
    if (v17)
    {
      v18 = v8;
      v19 = 1;
LABEL_28:
      v21 = (float16x4_t *)(a1 + 52);
      if (*(_BYTE *)(a1 + 52) != 4)
      {
        v20 = 1;
        LODWORD(v109) = v11;
        goto LABEL_45;
      }
      *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
      if (!v16)
      {
        v23 = -1;
        LODWORD(v109) = v11;
        v21 = (float16x4_t *)(a1 + 52);
        goto LABEL_41;
      }
      v20 = 1;
      LODWORD(v109) = v11;
      v13 = v16;
      v21 = (float16x4_t *)(a1 + 52);
LABEL_34:
      v25 = 2;
      v26 = v13;
      do
      {
        v17[v25] = v22 + (float)(v17[v25] * *(float *)&_D0);
        v25 += 4;
        --v26;
      }
      while (v26);
      if (v20)
      {
        v23 = v13 - 1;
        if (v13 == 1)
        {
          v20 = 1;
          v16 = 1;
LABEL_44:
          LOBYTE(v14) = 1;
          goto LABEL_45;
        }
        v16 = v13;
LABEL_41:
        v27 = 0;
        v28 = v17[2];
        do
        {
          v29 = v17[v27 + 6];
          v17[v27 + 3] = (float)((float)(v22 - v28)
                               + (float)((float)(v17[v27 + 3]
                                               + (float)((float)(*(float *)(*(_QWORD *)(a1 + 8) + v27 * 4 + 8)
                                                               - v17[v27 + 3])
                                                       * *(float *)(*(_QWORD *)(a1 + 8) + v27 * 4 + 24)))
                                       * *(float *)&_D0))
                       / (float)(v29 - v28);
          v27 += 4;
          v28 = v29;
          --v23;
        }
        while (v23);
        v20 = 1;
        goto LABEL_44;
      }
      LOBYTE(v14) = 1;
      v16 = v13;
LABEL_45:
      v12 = v17;
      goto LABEL_46;
    }
LABEL_97:
    free(v17);
    return;
  }
  v20 = (v9 >> 8) & 1;
  v21 = (float16x4_t *)(a1 + 52);
  if (*(_BYTE *)(a1 + 52) == 4)
  {
    if (v13 >> 60)
      return;
    v107 = (float16x4_t *)(a1 + 52);
    LODWORD(v109) = v8;
    if (16 * v13 <= 0x1000)
    {
      MEMORY[0x24BDAC7A8](a1, a2);
      v17 = (float *)((char *)&v106 - ((16 * v13 + 15) & 0xFFFFFFFFFFFFFFF0));
      bzero(v17, 16 * v13);
      v108 = 0;
      if (!v13)
        goto LABEL_24;
    }
    else
    {
      v17 = (float *)malloc_type_malloc(16 * v13, 0x9067789DuLL);
      if (!v17)
        goto LABEL_97;
      v108 = 1;
      if (!v13)
      {
LABEL_24:
        *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
        if ((v9 & 0x100) == 0)
        {
          v20 = 0;
          LOBYTE(v14) = 1;
          v12 = v17;
          v19 = v108;
          v16 = 0;
          v21 = v107;
          goto LABEL_46;
        }
        v23 = -1;
        v19 = v108;
        v16 = 0;
        v21 = v107;
        goto LABEL_41;
      }
    }
    memmove(v17, v12, 16 * v13);
    *(float *)&_D0 = RB::Fill::Gradient::angular_location_function((RB::Fill::Gradient *)a1);
    v19 = v108;
    v21 = v107;
    goto LABEL_34;
  }
  LODWORD(v109) = v8;
  v17 = 0;
  v19 = 0;
  v16 = v13;
LABEL_46:
  if (*(_QWORD *)a1 != 2 || (*(_DWORD *)(a1 + 48) & 0x10200) != 0 || v21->i8[0] == 4)
  {
    if (v16 < 7)
      v30 = 1;
    else
      v30 = v14;
    if ((v30 & 1) != 0)
    {
      v31 = 6;
      if (v16 > 6)
        v31 = v16;
      v32 = v110;
      RB::RenderFrame::alloc_buffer_region(**v110, (RB::Device *)(14 * v31), 4uLL, 0, &v112);
      v34 = v112;
      if (v112)
      {
        if ((uint64_t)(v16 - 1) >= 0)
        {
          v108 = v19;
          v107 = v5;
          v35 = v109 | 0x100;
          v36 = v16;
          v37 = &v12[4 * v16 - 2];
          v38 = (uint16x4_t *)(v113.i64[0] + 14 * v36 + *((_QWORD *)v112 + 7) - 6);
          v109 = v36;
          v39 = 1.0;
          do
          {
            v40 = v39;
            v39 = *v37;
            _S0 = 1.0 / (float)(v40 - *v37);
            if ((LODWORD(_S0) & 0x7FFFFFFFu) >= 0x7F800000)
              _S0 = 65504.0;
            __asm { FCVT            H1, S0 }
            v38->i16[0] = _H1;
            _S0 = -(float)(v39 * _S0);
            __asm { FCVT            H0, S0 }
            v38->i16[1] = LOWORD(_S0);
            _D0.i32[0] = 1.0;
            if (v20)
            {
              v48 = v37[1];
              if (v48 >= 1.0)
                _D0.i32[0] = 1199570944;
              else
                *(float *)_D0.i32 = -0.69315 / logf(v48);
            }
            __asm { FCVT            H0, S0 }
            v38->i16[2] = _D0.i16[0];
            v49 = *((unsigned __int16 *)v37 - 1);
            v114 = *((unsigned int *)v37 - 2) | ((unint64_t)*((unsigned __int16 *)v37 - 2) << 32) | (v49 << 48);
            v115 = v35;
            _D0.i16[0] = v49;
            __asm { FCVT            S0, H0 }
            *(float *)_D0.i32 = *(float *)_D0.i32 * v4;
            __asm { FCVT            H0, S0 }
            HIWORD(v114) = _D0.i16[0];
            RB::Fill::Color::convert((uint64_t)&v114, v11, _D0);
            if (v111)
              RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v114, v50, v51, v52, v53, v54, v55);
            v56.i32[0] = v114;
            v56.i16[2] = WORD2(v114);
            v56.i16[3] = 15360;
            v57 = (const __int16 *)&v114 + 3;
            v58 = (float16x4_t)vld1_dup_s16(v57);
            _D0 = (uint16x4_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v58), vcvtq_f32_f16(v56)));
            v38[-1] = _D0;
            --v36;
            v37 -= 4;
            v38 = (uint16x4_t *)((char *)v38 - 14);
          }
          while (v36 > 0);
          v34 = v112;
          v5 = v107;
          v19 = v108;
          LOWORD(v16) = v109;
          v32 = v110;
        }
        *((_DWORD *)v32 + 55) = RB::RenderFrame::buffer_id(**v32, v34);
        v32[28] = (RB::RenderFrame **)vmovn_s64(v113);
      }
    }
    else
    {
      if (v20)
        v59 = -5;
      else
        v59 = -4;
      v60 = 4;
      if (v20)
        v60 = 5;
      v61 = 2 * v60;
      RB::RenderFrame::alloc_buffer_region(**v110, (RB::Device *)(2 * v60 * v16 + 2 * v60), 4uLL, 0, &v112);
      if (v112)
      {
        v106 = v59;
        v107 = v5;
        v108 = v19;
        v63 = (char *)(*((_QWORD *)v112 + 7) + v113.i64[0]);
        v64 = v109 | 0x100;
        v65 = v16;
        v66 = (unsigned __int16 *)v12 + 3;
        v109 = v65;
        do
        {
          v67 = *v66;
          v114 = *(unsigned int *)(v66 - 3) | ((unint64_t)*(v66 - 1) << 32) | (v67 << 48);
          v115 = v64;
          _D0.i16[0] = v67;
          __asm { FCVT            S0, H0 }
          *(float *)_D0.i32 = *(float *)_D0.i32 * v4;
          __asm { FCVT            H0, S0 }
          HIWORD(v114) = _D0.i16[0];
          RB::Fill::Color::convert((uint64_t)&v114, v11, _D0);
          if (v111)
            RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v114, v68, v69, v70, v71, v72, v73);
          v74.i32[0] = v114;
          v74.i16[2] = WORD2(v114);
          v74.i16[3] = 15360;
          v75 = (const __int16 *)&v114 + 3;
          v76 = (float16x4_t)vld1_dup_s16(v75);
          _D0 = (uint16x4_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v76), vcvtq_f32_f16(v74)));
          *(uint16x4_t *)v63 = _D0;
          if (v20)
          {
            v77 = *(float *)(v66 + 3);
            if (v77 >= 1.0)
              _D0.i32[0] = 1199570944;
            else
              *(float *)_D0.i32 = -0.69315 / logf(v77);
            __asm { FCVT            H0, S0 }
            *((_WORD *)v63 + 4) = _H0;
          }
          v66 += 8;
          v63 += v61;
          --v65;
        }
        while (v65);
        memcpy(v63, &v63[2 * v106], v61);
        LOWORD(v16) = v109;
        v79 = v110;
        _S0 = (float)(unint64_t)(v109 - 1);
        __asm { FCVT            H0, S0 }
        v5 = v107;
        v107[2].i16[0] = LOWORD(_S0);
        *((_DWORD *)v79 + 55) = RB::RenderFrame::buffer_id(**v79, v112);
        v79[28] = (RB::RenderFrame **)vmovn_s64(v113);
        v19 = v108;
      }
    }
  }
  else
  {
    v81 = v109 | 0x100;
    v82 = *((unsigned __int16 *)v12 + 3);
    v112 = (RB::Buffer *)(*(unsigned int *)v12 | ((unint64_t)*((unsigned __int16 *)v12 + 2) << 32) | (v82 << 48));
    v113.i16[0] = v109 | 0x100;
    LOWORD(_D0) = v82;
    __asm { FCVT            S0, H0 }
    *(float *)&_D0 = *(float *)&_D0 * v4;
    __asm { FCVT            H0, S0 }
    HIWORD(v112) = LOWORD(_D0);
    RB::Fill::Color::convert((uint64_t)&v112, v11, *(uint16x4_t *)&_D0);
    if (v111)
      RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v112, v83, v84, v85, v86, v87, v88);
    v89.i32[0] = (int)v112;
    v89.i16[2] = WORD2(v112);
    v89.i16[3] = 15360;
    v90 = (const __int16 *)&v112 + 3;
    v91 = (float16x4_t)vld1_dup_s16(v90);
    _D0 = (uint16x4_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v91), vcvtq_f32_f16(v89)));
    *v5 = (float16x4_t)_D0;
    v93 = *((unsigned __int16 *)v12 + 11);
    v112 = (RB::Buffer *)(*((unsigned int *)v12 + 4) | ((unint64_t)*((unsigned __int16 *)v12 + 10) << 32) | (v93 << 48));
    v113.i16[0] = v81;
    _D0.i16[0] = v93;
    __asm { FCVT            S0, H0 }
    *(float *)_D0.i32 = *(float *)_D0.i32 * v4;
    __asm { FCVT            H0, S0 }
    HIWORD(v112) = _D0.i16[0];
    RB::Fill::Color::convert((uint64_t)&v112, v11, _D0);
    if (v111)
      RB::Fill::Color::convert_to_oklab((RB::Fill::Color *)&v112, v94, v95, v96, v97, v98, v99);
    v100.i32[0] = (int)v112;
    v100.i16[2] = WORD2(v112);
    _H0 = 15360;
    v100.i16[3] = 15360;
    v102 = (const __int16 *)&v112 + 3;
    v103 = (float16x4_t)vld1_dup_s16(v102);
    v5[1] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v103), vcvtq_f32_f16(v100)));
    if (v20)
    {
      v104 = v12[3];
      if (v104 >= 1.0)
      {
        _H0 = 31744;
      }
      else
      {
        _S0 = -0.69315 / logf(v104);
        __asm { FCVT            H0, S0 }
      }
    }
    v5[2].i16[0] = _H0;
  }
  v5[2].i16[1] = v16;
  if (v19)
    goto LABEL_97;
}

void sub_209AE5DB0(_Unwind_Exception *exception_object)
{
  void *v1;
  int v2;
  uint64_t v3;

  *(_DWORD *)(v3 - 204) = v2;
  if (*(_DWORD *)(v3 - 204))
    free(v1);
  _Unwind_Resume(exception_object);
}

__int16 RB::Fill::Color::convert_to_oklab@<H0>(RB::Fill::Color *this@<X0>, int8x16_t _Q0@<Q0>, int8x16_t a3@<Q1>, double a4@<D2>, double a5@<D3>, double a6@<D4>, int8x16_t a7@<Q5>)
{
  int8x16_t v18;
  int8x16_t v21;
  int8x16_t v24;
  __int16 result;
  int8x16_t v26;
  int8x16_t v27;
  int8x16_t v28;

  _Q0.i16[0] = *(_WORD *)this;
  __asm { FCVT            S0, H0 }
  _H2 = *((_WORD *)this + 1);
  __asm { FCVT            S2, H2 }
  _H3 = *((_WORD *)this + 2);
  __asm { FCVT            S3, H3 }
  *(float *)a7.i32 = (float)((float)(*(float *)_Q0.i32 * 0.41222) + (float)(_S2 * 0.53633)) + (float)(_S3 * 0.051446);
  v26 = a7;
  *(float *)a3.i32 = (float)((float)(*(float *)_Q0.i32 * 0.2119) + (float)(_S2 * 0.6807)) + (float)(_S3 * 0.1074);
  v27 = a3;
  *(float *)_Q0.i32 = (float)((float)(*(float *)_Q0.i32 * 0.088302) + (float)(_S2 * 0.28172)) + (float)(_S3 * 0.62998);
  v28 = _Q0;
  _S0 = powf(fabsf(*(float *)a7.i32), 0.33333);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  v18.i64[0] = 0x8000000080000000;
  v18.i64[1] = 0x8000000080000000;
  _Q0.i32[0] = vbslq_s8(v18, _Q0, v26).u32[0];
  __asm { FCVT            H0, S0 }
  *(_WORD *)this = _Q0.i16[0];
  _S0 = powf(fabsf(*(float *)v27.i32), 0.33333);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  v21.i64[0] = 0x8000000080000000;
  v21.i64[1] = 0x8000000080000000;
  _Q0.i32[0] = vbslq_s8(v21, _Q0, v27).u32[0];
  __asm { FCVT            H0, S0 }
  *((_WORD *)this + 1) = _Q0.i16[0];
  _S0 = powf(fabsf(*(float *)v28.i32), 0.33333);
  __asm
  {
    FCVT            H0, S0
    FCVT            S0, H0
  }
  v24.i64[0] = 0x8000000080000000;
  v24.i64[1] = 0x8000000080000000;
  _Q0.i32[0] = vbslq_s8(v24, _Q0, v28).u32[0];
  __asm { FCVT            H0, S0 }
  *((_WORD *)this + 2) = result;
  return result;
}

void RB::Path::Renderer::resolve(int32x2_t **a1, MTLPixelFormat a2, int a3)
{
  uint64_t v6;
  unsigned int *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  __int128 v13;
  float32x2_t v14;
  double v15;
  int32x2_t v16;
  unint64_t v17;
  unint64_t v18;
  float32x2_t v19;
  uint64_t v20;
  char *v21;
  int32x2_t *v22;
  int32x2_t v23;
  int32x4_t v24;
  double v25;
  int32x4_t v26;
  float32x2_t v27;
  float32x2_t v28;
  uint32x2_t v29;
  int8x8_t v30;
  int32x2_t v31;
  uint32x2_t v32;
  int8x8_t v33;
  float32x2_t v34;
  int8x8_t v35;
  float32x2_t v36;
  RB::RenderFrame ***v37;
  int32x2_t v38;
  __int32 v39;
  float32x2_t v40;
  float32x2_t v41;
  float v42;
  float32x2_t v43;
  float32x2_t v44;
  float32x2_t v45;
  float v46;
  float32x2_t v47;
  float32x2_t *v48;
  int32x2_t *v49;
  uint32x2_t v50;
  unsigned int v51;
  int v52;
  int v53;
  unint64_t v54;
  int v55;
  char *v56;
  int32x2_t *v57;
  uint32x2_t v58;
  int32x2_t *v59;
  int32x2_t *v60;
  uint64_t v61;
  unint64_t v62;
  int32x2_t v63;
  uint64_t v64;
  RB::RenderFrame ***v65;
  int32x2_t *v66;
  uint64_t v67;
  uint64_t v68;
  int32x2_t *v69;
  uint64_t v70;
  uint64_t v71;
  int32x2_t *v72;
  unint64_t v73;
  int v74;
  int32x2_t *v75;
  int32x2_t *v76;
  char *v77;
  uint64_t v78;
  uint64_t v79;
  uint32x2_t v80;
  int8x8_t v81;
  RB::RenderFrame ***v82;
  RB::Buffer *v83;
  _OWORD *v84;
  __int128 v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  unsigned int v89;
  int v90;
  uint32x2_t v91;
  RB::RenderFrame ***v92;
  int32x2_t *v93;
  uint64_t v94;
  unint64_t v95;
  int32x2_t v96;
  uint64_t v97;
  RB::RenderFrame ***v98;
  double v99;
  double v100;
  int32x2_t v101;
  RB::RenderFrame ***v102;
  uint64_t v103;
  uint64_t v104;
  __int128 v105;
  RB::RenderFrame ***v106;
  char v107;
  uint64_t v108;
  RB::RenderFrame ***v109;
  uint64_t v110;
  unint64_t v111;
  void (***v112)(_QWORD, int32x2_t **, uint64_t, double, double);
  uint64_t v113;
  int v114;
  char *v115;
  float64x2_t v116;
  float64x2_t v117;
  float64x2_t v118;
  float32x2_t v119[4];
  __int128 v120;
  float32x2_t v121[4];
  uint64_t v122;

  v122 = *MEMORY[0x24BDAC8D0];
  v6 = ***(_QWORD ***)*a1;
  v7 = RB::pixel_format_traits(*(_QWORD *)&(*a1)[11], a2);
  v9 = (unint64_t)a1[2];
  if (is_mul_ok(v9, 0x28uLL))
  {
    v114 = a3;
    v112 = (void (***)(_QWORD, int32x2_t **, uint64_t, double, double))a2;
    v10 = *((unsigned __int16 *)v7 + 2);
    v11 = *v7;
    v12 = 40 * v9;
    if (40 * v9 > 0x1000)
    {
      v115 = (char *)malloc_type_malloc(40 * v9, 0x1A2214C2uLL);
      if (!v115)
      {
        v115 = 0;
LABEL_98:
        free(v115);
        return;
      }
      v9 = (unint64_t)a1[2];
    }
    else
    {
      MEMORY[0x24BDAC7A8](v7, v8);
      v115 = (char *)&v110 - ((v12 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v115, 40 * v9);
    }
    v120 = 0uLL;
    if (v9)
    {
      v17 = v12;
      v18 = 0;
      v19 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      v20 = 4;
      v21 = v115;
      do
      {
        v22 = a1[3];
        v23 = (int32x2_t)RB::operator*((float64x2_t *)&v22[v20], (float32x2_t)v22[v20 - 2], (float32x2_t)v22[v20 - 1]);
        v27 = (float32x2_t)v23;
        v28 = *(float32x2_t *)v24.i8;
        if (*((_BYTE *)a1 + 9) == 3)
        {
          v29 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)v24.i8);
          v23 = (int32x2_t)vpmin_u32(v29, v29);
          if (v23.i32[0] < 0)
          {
            v23.i32[0] = *((_DWORD *)a1 + 3);
            *(int32x2_t *)v24.i8 = vcgt_f32(v19, *(float32x2_t *)v24.i8);
            v30 = (int8x8_t)vcltzq_s32(v24).u64[0];
            v27 = (float32x2_t)vbsl_s8(v30, (int8x8_t)vsub_f32(v27, (float32x2_t)vdup_lane_s32(v23, 0)), (int8x8_t)v27);
            v28 = (float32x2_t)vbsl_s8(v30, (int8x8_t)vmla_n_f32(v28, (float32x2_t)0x4000000040000000, *(float *)v23.i32), (int8x8_t)v28);
          }
        }
        v23.i32[0] = 0;
        v31 = (*a1)[21];
        v32 = (uint32x2_t)vceq_s32(v31, (int32x2_t)0x8000000080000000);
        v33 = (int8x8_t)vdup_lane_s32(vcgt_s32(v23, (int32x2_t)vpmin_u32(v32, v32)), 0);
        v34 = (float32x2_t)vbsl_s8(v33, (int8x8_t)v19, (int8x8_t)vcvt_f32_s32(v31));
        v35 = (int8x8_t)vcvt_f32_s32((*a1)[20]);
        v36 = (float32x2_t)vbsl_s8(v33, (int8x8_t)0x100000001000000, v35);
        v121[0] = v36;
        v121[1] = v34;
        if (v114)
        {
          RB::Rect::intersect(v121, v27, v28, *(double *)&v35, 7.29112205e-304, v25, v26);
          v34 = v121[1];
          v36 = v121[0];
        }
        RB::Bounds::Bounds((int32x2_t *)v119, v36, v34);
        *(_OWORD *)v21 = *(_OWORD *)v119[0].f32;
        if (v18)
          RB::Bounds::Union((int32x2_t *)&v120, *(int32x2_t *)v21, *(int32x2_t *)(v21 + 8));
        else
          v120 = *(_OWORD *)v115;
        v118 = *(float64x2_t *)v22[v20].i8;
        v117 = *(float64x2_t *)v22[v20 + 2].i8;
        v116 = *(float64x2_t *)v22[v20 + 4].i8;
        v37 = (RB::RenderFrame ***)*a1;
        v38 = (*a1)[14];
        v39 = (*a1)[15].i32[0];
        v40 = (float32x2_t)v22[v20 - 2];
        v41 = (float32x2_t)v22[v20 - 1];
        if (*((unsigned __int8 *)a1 + 9) < 2u)
        {
          v46 = 0.0;
        }
        else
        {
          v42 = *((float *)a1 + 3);
          v43 = (float32x2_t)COERCE_UNSIGNED_INT(RB::AffineTransform::scale((float64x2_t *)&v22[v20]));
          v44 = vrecpe_f32(v43);
          v45 = vmul_f32(vrecps_f32((float32x2_t)v43.u32[0], v44), v44);
          v46 = v42 * vmul_f32(v45, vrecps_f32((float32x2_t)v43.u32[0], v45)).f32[0];
          v37 = (RB::RenderFrame ***)*a1;
        }
        RB::RenderFrame::alloc_buffer_region(**v37, (RB::Device *)0x34, 4uLL, 0, v119);
        v47 = v119[0];
        if (v119[0])
        {
          v14 = vcvt_f32_f64(v117);
          v15 = COERCE_DOUBLE(vcvt_f32_f64(v116));
          v16 = (int32x2_t)vadd_f32(v28, v27);
          v48 = (float32x2_t *)(*(_QWORD *)(*(_QWORD *)v119 + 56) + *(_QWORD *)&v119[1]);
          *v48 = vcvt_f32_f64(v118);
          v48[1] = v14;
          *(double *)&v48[2] = v15;
          v48[3] = (float32x2_t)v38;
          v48[4] = vmla_f32(v40, (float32x2_t)0x3F0000003F000000, v41);
          v48[5].i32[0] = v39;
          v48[5].i32[1] = v16.i32[0];
          v48[6].f32[0] = v46;
          v47 = v119[0];
          v13 = *(_OWORD *)v119[1].f32;
        }
        else
        {
          v13 = 0uLL;
        }
        *((float32x2_t *)v21 + 2) = v47;
        *(_OWORD *)(v21 + 24) = v13;
        ++v18;
        v49 = a1[2];
        v20 += 10;
        v21 += 40;
      }
      while (v18 < (unint64_t)v49);
      v12 = v17;
    }
    else
    {
      v49 = 0;
    }
    if ((v114 & 1) != 0)
    {
      v14 = (float32x2_t)0x100000001;
      v50 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)((char *)&v120 + 8));
      *(uint32x2_t *)&v13 = vpmax_u32(v50, v50);
      if ((v13 & 0x80000000) != 0)
      {
LABEL_97:
        if (v12 <= 0x1000)
          return;
        goto LABEL_98;
      }
    }
    v113 = v11 | (v10 << 32);
    v51 = *((unsigned __int8 *)a1 + 9);
    if (v51 - 2 >= 2)
    {
      if (!*((_BYTE *)a1 + 9))
      {
LABEL_29:
        if ((v113 & 0x4000000000) == 0
          || (*(int32x2_t *)&v13 = vmul_lane_s32(*(int32x2_t *)((char *)&v120 + 8), *(int32x2_t *)((char *)&v120 + 8), 1), (int)v13 < 0x4000))
        {
          v52 = 1;
          if (!v49)
            goto LABEL_57;
LABEL_35:
          LODWORD(v118.f64[0]) = v52;
          v111 = v12;
          v53 = 0;
          v54 = 0;
          v55 = v114 ^ 1;
          if ((v113 & 0x4000000000) == 0)
            v55 = 1;
          LODWORD(v117.f64[0]) = v55;
          *(_QWORD *)&v116.f64[0] = v6 + 80;
          do
          {
            v56 = v115;
            v57 = (int32x2_t *)&v115[40 * v54];
            v58 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v57[1]);
            *(uint32x2_t *)&v13 = vpmax_u32(v58, v58);
            if ((v13 & 0x80000000) == 0)
            {
              v59 = *a1;
              v59[23].i32[0] = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)&v115[40 * v54 + 16]);
              *(int32x2_t *)&v13 = vmovn_s64(*(int64x2_t *)&v56[40 * v54 + 24]);
              *(int32x2_t *)((char *)&v59[23] + 4) = (int32x2_t)v13;
              v60 = a1[3];
              if (v60[10 * v54])
              {
                v61 = 0;
                v62 = 0;
                do
                {
                  v63 = v60[10 * v54 + 1];
                  v64 = *(_QWORD *)&v63 + v61;
                  if (*(_DWORD *)(*(_QWORD *)&v63 + v61 + 24))
                  {
                    v65 = (RB::RenderFrame ***)*a1;
                    *((_DWORD *)v65 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)(*(_QWORD *)&v63 + v61));
                    v65[25] = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)(*(_QWORD *)&v63 + v61 + 8));
                    if (LODWORD(v118.f64[0]) == 1)
                    {
                      v69 = *a1;
                      v70 = (*a1)[17].i32[0] == 2;
                      v71 = *(unsigned __int8 *)(*(_QWORD *)&v63 + v61 + 28);
                      if ((LOBYTE(v117.f64[0]) & 1) == 0)
                      {
                        v53 = 1;
                        v69[22].i8[0] = 1;
                        v69[22].i32[1] = 1;
                      }
                      RB::RenderPass::draw_indexed_primitives(v69, (const char *)((v71 << 12) | (v70 << 33) | 0x2D9), 4, ***(_QWORD ***)v69 + 80, 0, *(unsigned int *)(v64 + 24), *v57, v57[1]);
                    }
                    else if (LODWORD(v118.f64[0]))
                    {
                      v72 = *a1;
                      v73 = (unint64_t)((*a1)[17].i32[0] == 2) << 33;
                      v74 = *(unsigned __int8 *)(*(_QWORD *)&v63 + v61 + 28);
                      v72[22].i8[0] = 1;
                      v72[22].i32[1] = 1;
                      RB::RenderPass::draw_primitives(v72, (const char *)(v73 | ((unint64_t)v74 << 12) | 0x17), 1, 0, 2uLL, *(unsigned int *)(v64 + 24), *v57, v57[1]);
                      v74 <<= 12;
                      v75 = *a1;
                      v75[22].i8[0] = 7;
                      v75[22].i32[1] = 2;
                      RB::RenderPass::draw_indexed_primitives(v75, (const char *)(v73 | v74 | 0x2D8u), 4, *(uint64_t *)&v116.f64[0], 3, *(unsigned int *)(v64 + 24), *v57, v57[1]);
                      v76 = *a1;
                      v76[22].i8[0] = 7;
                      v76[22].i32[1] = 3;
                      RB::RenderPass::draw_indexed_primitives(v76, (const char *)(v73 | v74 | 0x2D9u), 4, ***(_QWORD ***)v76 + 80, 0, *(unsigned int *)(v64 + 24), *v57, v57[1]);
                      v53 = 1;
                    }
                    else
                    {
                      v66 = *a1;
                      v67 = (*a1)[17].i32[0] == 2;
                      v68 = *(unsigned __int8 *)(*(_QWORD *)&v63 + v61 + 28);
                      if ((LOBYTE(v117.f64[0]) & 1) == 0)
                      {
                        v53 = 1;
                        v66[22].i8[0] = 1;
                        v66[22].i32[1] = 1;
                      }
                      RB::RenderPass::draw_indexed_primitives(v66, (const char *)((v68 << 12) | (v67 << 33) | 0x2D8), 4, *(uint64_t *)&v116.f64[0], 3, *(unsigned int *)(v64 + 24), *v57, v57[1]);
                    }
                    v65[25] = 0;
                    *((_DWORD *)v65 + 49) = 0;
                    v60 = a1[3];
                  }
                  ++v62;
                  v61 += 32;
                }
                while (v62 < *(_QWORD *)&v60[10 * v54]);
              }
            }
            ++v54;
          }
          while (v54 < (unint64_t)a1[2]);
          v51 = *((unsigned __int8 *)a1 + 9);
          v12 = v111;
          goto LABEL_58;
        }
        v52 = 2;
        if (v49)
          goto LABEL_35;
LABEL_57:
        v53 = 0;
LABEL_58:
        if (v51 <= 1 || (LODWORD(v13) = *((_DWORD *)a1 + 3), v77 = v115, *(float *)&v13 <= 0.0))
        {
          v86 = 1;
        }
        else
        {
          v111 = v12;
          LODWORD(v13) = 0;
          if (*((_BYTE *)a1 + 8) == 1)
            v78 = 12288;
          else
            v78 = 4096;
          v79 = (*a1)[17].i32[0] == 2;
          v80 = (uint32x2_t)vceq_s32(*(int32x2_t *)((char *)&v120 + 8), (int32x2_t)0x8000000080000000);
          v81 = (int8x8_t)vdup_lane_s32(vcgt_s32(*(int32x2_t *)&v13, (int32x2_t)vpmin_u32(v80, v80)), 0);
          RB::Coverage::set_plane(v119, (float32x2_t *)*a1, (float32x2_t)vbsl_s8(v81, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v120)), COERCE_DOUBLE(vbsl_s8(v81, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(*(int32x2_t *)((char *)&v120 + 8)))));
          v82 = (RB::RenderFrame ***)*a1;
          RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)*a1, (RB::Device *)0x1C, 4uLL, 0, v121);
          v83 = (RB::Buffer *)v121[0];
          if (v121[0])
          {
            v84 = (_OWORD *)(*(_QWORD *)(*(_QWORD *)v121 + 56) + *(_QWORD *)&v121[1]);
            v85 = *(_OWORD *)v119[0].f32;
            *(_OWORD *)((char *)v84 + 12) = *(_OWORD *)&v119[1].i32[1];
            *v84 = v85;
          }
          else
          {
            memset(v121, 0, 24);
          }
          *((_DWORD *)v82 + 46) = RB::RenderFrame::buffer_id(**v82, v83);
          *(RB::RenderFrame ***)((char *)v82 + 188) = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)v121[1].f32);
          v87 = 26;
          if (v51 == 3)
            v87 = 32794;
          RB::RenderPass::draw_indexed_primitives(*a1, (const char *)(v87 | v78 | (v79 << 33)), 4, ***(_QWORD ***)*a1 + 80, 0, 1uLL, *(int32x2_t *)&v120, *(int32x2_t *)((char *)&v120 + 8));
          if (a1[2])
          {
            v88 = 0;
            v89 = vcvtps_s32_f32(*((float *)a1 + 3));
            v90 = v114 ^ 1;
            if ((v113 & 0x4000000000) == 0)
              v90 = 1;
            LODWORD(v117.f64[0]) = v90;
            LODWORD(v116.f64[0]) = -v89;
            do
            {
              *(_QWORD *)&v118.f64[0] = &v77[40 * v88];
              v91 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)(*(_QWORD *)&v118.f64[0] + 8));
              *(uint32x2_t *)&v13 = vpmax_u32(v91, v91);
              if ((v13 & 0x80000000) == 0)
              {
                v92 = (RB::RenderFrame ***)*a1;
                *((_DWORD *)v92 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)&v77[40 * v88 + 16]);
                *(int32x2_t *)&v13 = vmovn_s64(*(int64x2_t *)&v77[40 * v88 + 24]);
                *(RB::RenderFrame ***)((char *)v92 + 188) = (RB::RenderFrame **)v13;
                v93 = a1[3];
                if (v93[10 * v88])
                {
                  v94 = 0;
                  v95 = 0;
                  do
                  {
                    v96 = v93[10 * v88 + 1];
                    v97 = *(_QWORD *)&v96 + v94;
                    if (*(_DWORD *)(*(_QWORD *)&v96 + v94 + 24))
                    {
                      v98 = (RB::RenderFrame ***)*a1;
                      *((_DWORD *)v98 + 49) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)*a1, *(RB::Buffer **)(*(_QWORD *)&v96 + v94));
                      v98[25] = (RB::RenderFrame **)vmovn_s64(*(int64x2_t *)(*(_QWORD *)&v96 + v94 + 8));
                      v102 = (RB::RenderFrame ***)*a1;
                      v103 = (*a1)[17].i32[0] == 2;
                      v104 = *(unsigned __int8 *)(*(_QWORD *)&v96 + v94 + 28);
                      if ((LOBYTE(v117.f64[0]) & 1) == 0)
                      {
                        *((_BYTE *)v102 + 176) = 5;
                        *((_DWORD *)v102 + 45) = 0;
                        v53 = 1;
                      }
                      v105 = **(_OWORD **)&v118.f64[0];
                      *(_OWORD *)v121[0].f32 = **(_OWORD **)&v118.f64[0];
                      if (*((_BYTE *)a1 + 9) != 3)
                      {
                        RB::Bounds::inset((int32x2_t *)v121, LODWORD(v116.f64[0]), LODWORD(v116.f64[0]), *(double *)&v105, v99, v100, v101);
                        v102 = (RB::RenderFrame ***)*a1;
                      }
                      RB::RenderPass::draw_indexed_primitives((int32x2_t *)v102, (const char *)((v104 << 12) | (v103 << 33) | 0x41B), 4, *(_QWORD *)**v102 + 80, 0, *(unsigned int *)(v97 + 24), (int32x2_t)v121[0], (int32x2_t)v121[1]);
                      v98[25] = 0;
                      *((_DWORD *)v98 + 49) = 0;
                      v93 = a1[3];
                    }
                    ++v95;
                    v94 += 32;
                  }
                  while (v95 < *(_QWORD *)&v93[10 * v88]);
                }
              }
              ++v88;
              v77 = v115;
            }
            while (v88 < (unint64_t)a1[2]);
          }
          v86 = 0;
          v12 = v111;
        }
        if ((v113 & 0x4000000000) != 0)
        {
          if (((v114 | v53) & 1) != 0)
          {
            v106 = (RB::RenderFrame ***)*a1;
            if (v114)
              v107 = 6;
            else
              v107 = 2;
            *((_BYTE *)v106 + 176) = v107;
            *((_DWORD *)v106 + 45) = 0;
          }
          RB::Bounds::inset((int32x2_t *)&v120, 0xFFFFFFFF, 0xFFFFFFFF, *(double *)&v13, *(double *)&v14, v15, v16);
        }
        if (*((_BYTE *)a1 + 9) == 3)
          v108 = 8 * (*((float *)a1 + 3) > 0.0);
        else
          v108 = 0;
        (**v112)(v112, a1, v86 | (2 * (*((_BYTE *)a1 + 8) == 1)) | v108, *(double *)&v120, *((double *)&v120 + 1));
        if ((v113 & 0x4000000000) != 0)
        {
          v109 = (RB::RenderFrame ***)*a1;
          *((_BYTE *)v109 + 176) = 0;
          *((_DWORD *)v109 + 45) = 0;
        }
        goto LABEL_97;
      }
    }
    else
    {
      LODWORD(v13) = *((_DWORD *)a1 + 3);
      if (*(float *)&v13 <= 0.0)
        goto LABEL_29;
    }
    v52 = 0;
    if (v49)
      goto LABEL_35;
    goto LABEL_57;
  }
}

void sub_209AE6A08(_Unwind_Exception *exception_object)
{
  unint64_t v1;
  uint64_t v2;

  if (v1 > 0x1000)
    free(*(void **)(v2 - 296));
  _Unwind_Resume(exception_object);
}

unsigned int *RB::pixel_format_traits(unint64_t this, MTLPixelFormat a2)
{
  unint64_t v3;
  unsigned int *result;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;

  if ((this & 0x80000000) != 0)
  {
    if ((this & 0xFFFFFFFF7FFFFFFFLL) < 0xD)
                            + 40 * (this & 0xFFFFFFFF7FFFFFFFLL));
    return (unsigned int *)&RB::pixel_format_traits(MTLPixelFormat)::default_traits;
  }
  if (RB::pixel_format_traits(MTLPixelFormat)::once != -1)
    dispatch_once_f(&RB::pixel_format_traits(MTLPixelFormat)::once, 0, (dispatch_function_t)RB::pixel_format_traits(MTLPixelFormat)::$_0::__invoke);
  v3 = 124;
  result = (unsigned int *)RB::pixel_format_traits(MTLPixelFormat)::sorted_traits;
  do
  {
    v5 = v3 >> 1;
    v6 = &result[10 * (v3 >> 1)];
    v8 = *v6;
    v7 = v6 + 10;
    v3 += ~(v3 >> 1);
    if (v8 < this)
      result = v7;
    else
      v3 = v5;
  }
  while (v3);
  if ((unint64_t)result >= RB::pixel_format_traits(MTLPixelFormat)::sorted_traits + 4960 || *result != this)
    return (unsigned int *)&RB::pixel_format_traits(MTLPixelFormat)::default_traits;
  return result;
}

uint64_t RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  unsigned int v6;
  uint64_t result;
  uint16x4_t v12;
  int v14;
  RB::Buffer *v15;
  int16x4_t v16;
  unsigned int v23;
  char v24;
  int v25;
  RB::Buffer *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  RB::Buffer *v30;
  char *v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  int64x2_t v36;
  uint64_t v37;
  unsigned int v38;
  unsigned int v39;
  RB::Buffer *v40[5];
  int32x2_t v41;
  int32x2_t v42;
  _OWORD v43[3];
  int v44;
  _OWORD v45[5];
  RB::Buffer *v46;
  RB::Buffer *v47;
  int64x2_t v48;

  v6 = a6;
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v41 = 0;
  v42 = 0;
  result = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v45, (float32x2_t *)a1, a2, a6, &v44, (uint64_t)v43, (uint64_t)&v41);
  if ((_DWORD)result)
  {
    if (*(_BYTE *)(a4 + 9) && (v14 = *(unsigned __int8 *)(a1 + 124), *(unsigned __int8 *)(a4 + 8) != v14))
    {
      v40[0] = *(RB::Buffer **)a4;
      LOWORD(v40[1]) = *(_WORD *)(a4 + 8);
      RB::Fill::Color::convert((uint64_t)v40, v14, v12);
      HIWORD(v15) = 15360;
      LODWORD(v15) = v40[0];
      WORD2(v15) = WORD2(v40[0]);
      v16.i32[0] = (unint64_t)v40[0] >> 48;
      _D1.i16[0] = *(_WORD *)(a4 + 6);
    }
    else
    {
      v15 = *(RB::Buffer **)a4;
      WORD2(v15) = *(_WORD *)(a4 + 4);
      HIWORD(v15) = unk_209BD6A88;
      _D1.i16[0] = *(_WORD *)(a4 + 6);
      v16 = _D1;
    }
    v46 = (RB::Buffer *)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v16, 0)), vcvtq_f32_f16((float16x4_t)v15)));
    __asm { FCVT            S8, H1 }
    if ((v6 == 24 || v6 == 2) && _S8 == 1.0)
      v23 = 0;
    else
      v23 = v6;
    if (v44 == 1)
      v6 = v23;
    v24 = (v44 == 1) & (v6 < 0x19) & ~(_BYTE)a5;
    if (v24)
      v25 = 2;
    else
      v25 = 5;
    if (_S8 == 1.0 && ((v44 == 1) & (v6 < 0x19) & ~(_BYTE)a5) != 0)
    {
      if (v6 == 24 || v6 == 2)
        LOBYTE(v6) = 0;
      v25 = 2;
    }
    if ((v24 & 1) != 0)
    {
      RB::Coverage::set_plane((uint64_t)v40, (uint64_t)v45);
      *(RB::Buffer **)((char *)&v40[3] + 4) = v46;
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v47);
      v26 = v47;
      if (v47)
      {
        v27 = *((_QWORD *)v47 + 7) + v48.i64[0];
        v28 = *(_OWORD *)v40;
        v29 = *(_OWORD *)&v40[2];
        *(_DWORD *)(v27 + 32) = v40[4];
        *(_OWORD *)v27 = v28;
        *(_OWORD *)(v27 + 16) = v29;
      }
      else
      {
        v47 = 0;
        v48 = 0uLL;
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v26);
      v36 = v48;
    }
    else
    {
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x58, 4uLL, 0, v40);
      v30 = v40[0];
      if (v40[0])
      {
        v31 = (char *)v40[1] + *((_QWORD *)v40[0] + 7);
        v32 = v45[0];
        *((_OWORD *)v31 + 1) = v45[1];
        v34 = v45[3];
        v33 = v45[4];
        v35 = v45[2];
        *((_QWORD *)v31 + 10) = v46;
        *((_OWORD *)v31 + 3) = v34;
        *((_OWORD *)v31 + 4) = v33;
        *((_OWORD *)v31 + 2) = v35;
        *(_OWORD *)v31 = v32;
      }
      else
      {
        memset(v40, 0, 24);
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v30);
      v36 = *(int64x2_t *)&v40[1];
    }
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v36);
    LODWORD(v40[0]) = v44 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, v40);
    v37 = a5 | (2 * (*(_DWORD *)(a1 + 136) == 2));
    v38 = v25 & 0xFFFFF03F | ((v6 & 0x3F) << 6);
    result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)(v38 & 0xFFC00FFF | (((uint64_t)v40[0] & 0x3FF) << 12) | ((unint64_t)(v37 & 3) << 32)), 4, (uint64_t)v43, 0, 1uLL, v41, v42);
    if (*((_QWORD *)&v43[1] + 1))
    {
      LODWORD(v40[0]) = (uint64_t)v40[0] & 0xFFFFFFF0 | 1;
      v39 = (LODWORD(v40[0]) << 12) & 0x3FF000 | v38;
      if (_S8 == 1.0 && ((v6 & 0x3F) == 0x18 || (v6 & 0x3F) == 2))
        v39 = (LODWORD(v40[0]) << 12) & 0x3F1000 | v38 & 0x3F1007;
      result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((v37 << 32) | v39), 4, (uint64_t)&v43[1] + 8, 0, 1uLL, v41, v42);
    }
    *(_QWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 196) = 0;
  }
  return result;
}

int32x2_t *RB::RenderPass::draw_indexed_primitives(int32x2_t *result, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, unint64_t a6, int32x2_t a7, int32x2_t a8)
{
  uint64_t v8;
  id ***v13;
  uint32x2_t v14;
  uint64_t v15;
  RB::Buffer *v16;
  int32x2_t v17;
  int32x2_t v18;

  v17 = a7;
  v18 = a8;
  if (a5)
    v8 = a5;
  else
    v8 = *(_QWORD *)(a4 + 16) >> 1;
  if (a6 && v8)
  {
    if ((v8 | a6) >> 32)
      RB::precondition_failure((RB *)"invalid index or instance count", a2, *(_QWORD *)&v17, *(_QWORD *)&v18);
    v13 = (id ***)result;
    result = RB::Bounds::intersect(&v17, result[20], result[21]);
    v14 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, v18);
    if ((vpmax_u32(v14, v14).u32[0] & 0x80000000) == 0)
    {
      v15 = RB::RenderPass::draw(v13, a2, (int8x8_t *)&v17, 0);
      *(_BYTE *)(v15 + 42) = a3;
      v16 = *(RB::Buffer **)a4;
      *(_DWORD *)(v15 + 24) = *(_QWORD *)(a4 + 8);
      *(_DWORD *)(v15 + 28) = v8;
      *(_DWORD *)(v15 + 32) = a6;
      result = (int32x2_t *)RB::RenderFrame::buffer_id((RB::RenderFrame *)**v13, v16);
      *(_DWORD *)(v15 + 36) = (_DWORD)result;
      if (a3 == 4)
        (**v13)[4] = (char *)(**v13)[4] + (v8 - 2) * a6;
    }
  }
  return result;
}

uint64_t RB::RenderFrame::buffer_id(RB::RenderFrame *this, RB::Buffer *a2)
{
  uint64_t v4;
  _QWORD *v5;
  unint64_t v6;

  if (!a2)
    return 0;
  RB::Resource::set_frame_id((uint64_t)a2, *((_DWORD *)this + 21), *((_DWORD *)this + 22));
  v4 = *((unsigned int *)a2 + 10);
  if (!(_DWORD)v4)
  {
    v4 = *(_QWORD *)(*((_QWORD *)this + 12) + 8);
    ++*((_DWORD *)a2 + 2);
    v5 = (_QWORD *)*((_QWORD *)this + 12);
    v6 = v5[1];
    if (v6 >= v5[2])
      v5 = (_QWORD *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 12, v5);
    v5[v6 + 3] = a2;
    atomic_store(v6 + 1, v5 + 1);
    *((_DWORD *)a2 + 10) = v4;
    *((_QWORD *)this + 6) += *((_QWORD *)a2 + 6);
  }
  return v4;
}

void sub_209AE7070(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Resource::set_frame_id(uint64_t this, int a2, int a3)
{
  do
  {
    if (*(_DWORD *)(this + 32) == a2)
      break;
    *(_DWORD *)(this + 32) = a2;
    *(_DWORD *)(this + 36) = a3;
    *(_DWORD *)(this + 40) = 0;
    this = *(_QWORD *)(this + 24);
  }
  while (this);
  return this;
}

uint64_t RB::RenderPass::draw(id ***a1, const char *a2, int8x8_t *a3, uint64_t a4)
{
  int32x2_t *v4;
  uint32x2_t v5;
  id **v9;
  uint32x2_t v10;
  unsigned __int32 v11;
  uint32x2_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  size_t *v17;
  uint64_t v18;
  uint64_t v19;
  size_t v20;
  uint64_t v21;
  size_t v22;
  uint64_t v23;
  unint64_t v24;
  _QWORD **v25;
  uint64_t v26;
  unint64_t v27;
  _QWORD *v28;
  uint64_t *v29;
  uint64_t v30;
  int v31;
  int v32;
  id *v33;
  const char *v35;

  v35 = a2;
  v4 = (int32x2_t *)(a1 + 20);
  v5 = (uint32x2_t)vcgt_s32((int32x2_t)vorr_s8((int8x8_t)a1[20], *a3), (int32x2_t)-1);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
    RB::precondition_failure((RB *)"invalid bounds or scissor", a2);
  if (((unsigned __int16)a2 & 0xFC0) == 0xAC0)
    RB::RenderState::simplify_plus_lighter((unsigned int *)&v35, (unint64_t)a1[2]);
  v9 = a1[19];
  if (!v9 || *(_DWORD *)v9 >= 0x400u && (RB::RenderFrame::flush_pass(**a1, (RB::RenderPass *)a1, 0), !a1[19]))
    RB::RenderFrame::acquire_queue((uint64_t)**a1, (uint64_t *)a1 + 19);
  v10 = (uint32x2_t)vceqz_s32(*v4);
  if ((vpmin_u32(v10, v10).u32[0] & 0x80000000) != 0)
  {
    v12 = (uint32x2_t)vceq_s32((int32x2_t)a1[21], (int32x2_t)a1[13]);
    v11 = vpmin_u32(v12, v12).u32[0] >> 31;
  }
  else
  {
    v11 = 0;
  }
  v13 = 4;
  v14 = 220;
  do
  {
    if (*(_DWORD *)((char *)a1 + v14))
      break;
    v14 -= 12;
    --v13;
  }
  while (v13);
  v15 = 3;
  v16 = 31;
  do
  {
    if (LODWORD(a1[v16]))
      break;
    --v16;
    --v15;
  }
  while (v15);
  v17 = (size_t *)a1[19];
  if (*(_DWORD *)v17 == *((_DWORD *)v17 + 1))
    RB::RenderQueue::grow_ops((RB::RenderQueue *)v17);
  if (v11)
    v18 = 3;
  else
    v18 = 7;
  v19 = 72;
  if (v11)
    v19 = 49;
  v20 = v19 + a4 + 12 * v13 + 8 * v15;
  v21 = (v18 + v17[4]) & ~v18;
  if (v21 + v20 > v17[5])
    v21 = RB::Heap::alloc_slow(v17 + 2, v20, v18);
  else
    v17[4] = v21 + v20;
  *(_BYTE *)(v21 + 48) = *(_BYTE *)(v21 + 48) & 0xFE | v11 ^ 1 | 4;
  *(_BYTE *)(v21 + 47) = v13;
  *(_BYTE *)(v21 + 46) = v15;
  v22 = v17[1];
  v23 = *(unsigned int *)v17;
  *(_DWORD *)v17 = v23 + 1;
  *(_QWORD *)(v22 + 8 * v23) = v21;
  if ((v11 & 1) == 0)
    *(_OWORD *)((v21 + 56) & 0xFFFFFFFFFFFFFFF8) = *(_OWORD *)v4->i8;
  if (v13)
  {
    v24 = v21 + 49;
    if ((*(_BYTE *)(v21 + 48) & 1) != 0)
      v24 = ((v21 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    v25 = a1 + 23;
    do
    {
      v26 = (uint64_t)*v25;
      *(_DWORD *)(v24 + 8) = *((_DWORD *)v25 + 2);
      *(_QWORD *)v24 = v26;
      v24 += 12;
      v25 = (_QWORD **)((char *)v25 + 12);
      --v13;
    }
    while (v13);
  }
  if (v15)
  {
    v27 = v21 + 49;
    if ((*(_BYTE *)(v21 + 48) & 1) != 0)
      v27 = ((v21 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
    v28 = (_QWORD *)(v27 + 12 * *(unsigned __int8 *)(v21 + 47));
    v29 = (uint64_t *)(a1 + 29);
    do
    {
      v30 = *v29++;
      *v28++ = v30;
      --v15;
    }
    while (v15);
  }
  v31 = *((unsigned __int8 *)a1 + 177);
  *(_BYTE *)(v21 + 45) = v31;
  v32 = *((unsigned __int8 *)a1 + 176);
  *(_BYTE *)(v21 + 43) = v32;
  *(_BYTE *)(v21 + 44) = *((_DWORD *)a1 + 45);
  *(_QWORD *)v21 = v35;
  *(_DWORD *)(v21 + 8) = *a3;
  *(_DWORD *)(v21 + 12) = a3->i32[1];
  *(_DWORD *)(v21 + 16) = *(_QWORD *)&a3[1] + *(_QWORD *)a3;
  *(_DWORD *)(v21 + 20) = a3[1].i32[1] + a3->i32[1];
  *(_WORD *)(v21 + 40) = RB::RenderState::render_mask((unsigned int *)&v35, v31, v32);
  v33 = **a1;
  v33[7] = (char *)v33[7]
         + (int)RB::RenderState::fill_rate((RB::RenderState *)v21, (*(_DWORD *)(v21 + 20) - *(_DWORD *)(v21 + 12)) * (*(_DWORD *)(v21 + 16) - *(_DWORD *)(v21 + 8)));
  return v21;
}

uint64_t RB::RenderState::fill_rate(RB::RenderState *this, int a2)
{
  return ((RB::RenderState::fill_rate(int)const::blend_rate[((unint64_t)*(unsigned int *)this >> 6) & 0x3F]
                       + RB::RenderState::fill_rate(int)const::function_rate[*(_DWORD *)this & 0x3FLL])
                      * a2);
}

float32_t RB::Coverage::set_plane(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, double a4)
{
  float64x2_t v4;
  unint64_t v5;
  float32x2_t v6;
  float32_t result;

  v4.f64[0] = 0.0;
  *(double *)&v5 = *(float *)&a4;
  v4.f64[1] = *((float *)&a4 + 1);
  v6 = a2[14];
  v6.i32[1] = vneg_f32(v6).i32[1];
  *a1 = vmul_f32(v6, vcvt_f32_f64((float64x2_t)v5));
  a1[1] = vmul_f32(v6, vcvt_f32_f64(v4));
  a1[2] = vmla_f32((float32x2_t)0x3F800000BF800000, a3, v6);
  result = a2[15].f32[0];
  a1[3].f32[0] = result;
  return result;
}

BOOL RB::Bounds::inset(int32x2_t *this, unsigned int a2, unsigned int a3, double a4, double a5, double a6, int32x2_t a7)
{
  int32x2_t v7;
  uint32x2_t v8;
  int32x2_t v9;
  uint32x2_t v10;
  int32x2_t v11;
  __int32 v12;
  int8x8_t v13;
  _BOOL8 v14;

  v7 = this[1];
  v8 = (uint32x2_t)vceq_s32(v7, (int32x2_t)0x8000000080000000);
  if ((vpmax_u32(v8, v8).u32[0] & 0x80000000) != 0)
    return 1;
  v9 = vsub_s32(v7, vadd_s32((int32x2_t)__PAIR64__(a3, a2), (int32x2_t)__PAIR64__(a3, a2)));
  v10 = (uint32x2_t)vcltz_s32(v9);
  v11 = (int32x2_t)vpmax_u32(v10, v10);
  a7.i32[0] = -1;
  v12 = v11.i32[0];
  v13 = (int8x8_t)vdup_lane_s32(vcgt_s32(v11, a7), 0);
  v14 = v12 >= 0;
  *this = vadd_s32(*this, (int32x2_t)vbsl_s8(v13, (int8x8_t)__PAIR64__(a3, a2), (int8x8_t)vshr_n_s32(v9, 1uLL)));
  this[1] = (int32x2_t)vand_s8((int8x8_t)v9, v13);
  return v14;
}

float RB::bezier_flatness(RB *this)
{
  unsigned __int8 v1;
  float result;
  const char *v3;

  {
    RB::bezier_flatness(void)::flatness = RB::debug_float((RB *)"RB_FLATNESS", v3);
  }
  result = *(float *)&RB::bezier_flatness(void)::flatness;
  if (*(float *)&RB::bezier_flatness(void)::flatness < 0.01)
    result = 0.01;
  if (!BYTE4(RB::bezier_flatness(void)::flatness))
    return 0.25;
  return result;
}

uint64_t RBPathGetBezierOrder(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(void);
  uint64_t (*v4)(void);

  if ((*(_BYTE *)(a2 + 2) & 1) != 0)
  {
    v4 = *(uint64_t (**)(void))(a2 + 56);
    if (v4)
      return v4();
  }
  else
  {
    v2 = *(uint64_t (**)(void))(a2 + 56);
    if (v2)
      return v2();
  }
  return 3;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  float64x2_t *v5;
  int64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v10[3];

  v5 = *(float64x2_t **)(a1 + 48);
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  v7 = v5[1];
  v8 = vaddq_f64(v5[2], vcvtq_f64_s64(v6));
  v10[0] = *v5;
  v10[1] = v7;
  v10[2] = v8;
  return RB::render_primitive_coverage(a4, v10, a1 + 64, a5, *(float *)(a1 + 112));
}

uint64_t RB::render_primitive_coverage(uint64_t a1, float64x2_t *a2, uint64_t a3, unsigned int a4, float a5)
{
}

char *RB::RenderQueue::grow_ops(RB::RenderQueue *this)
{
  unsigned int v2;
  unsigned int v3;
  size_t v4;
  void *v5;
  char *result;
  unint64_t v7;

  v2 = *((_DWORD *)this + 1);
  if (v2)
  {
    v3 = v2 + (v2 >> 1);
    v4 = 8 * v3;
    if (v2 == 64)
    {
      v5 = malloc_type_malloc(v4, 0xCCA35843uLL);
      result = (char *)memcpy(v5, *((const void **)this + 1), v4);
    }
    else
    {
      result = (char *)malloc_type_realloc(*((void **)this + 1), 8 * (v2 + (v2 >> 1)), 0xD0DD158AuLL);
      v5 = result;
    }
    if (!v5)
      abort();
    *((_QWORD *)this + 1) = v5;
    *((_DWORD *)this + 1) = v3;
  }
  else
  {
    *((_DWORD *)this + 1) = 64;
    v7 = *((_QWORD *)this + 5);
    result = (char *)((*((_QWORD *)this + 4) + 7) & 0xFFFFFFFFFFFFFFF8);
    if ((unint64_t)(result + 512) > v7)
      result = (char *)RB::Heap::alloc_slow((size_t *)this + 2, 0x200uLL, 7);
    else
      *((_QWORD *)this + 4) = result + 512;
    *((_QWORD *)this + 1) = result;
  }
  return result;
}

float RB::RenderPass::fill(uint64_t a1, float32x4_t a2)
{
  RB::Buffer *v3;
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  float result;
  __int128 v9;
  _BYTE v10[20];
  RB::Buffer *v11;
  int64x2_t v12;

  *(float16x4_t *)&v10[12] = vcvt_f16_f32(a2);
  RB::Coverage::set_plane((float32x2_t *)&v9, a1, *(int32x2_t *)&v10[12]);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x24, 4uLL, 0, &v11);
  v3 = v11;
  if (v11)
  {
    v4 = *((_QWORD *)v11 + 7) + v12.i64[0];
    v5 = v9;
    v6 = *(_OWORD *)v10;
    *(_DWORD *)(v4 + 32) = *(_DWORD *)&v10[16];
    *(_OWORD *)v4 = v5;
    *(_OWORD *)(v4 + 16) = v6;
  }
  else
  {
    v11 = 0;
    v12 = 0uLL;
  }
  *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v3);
  *(int32x2_t *)(a1 + 188) = vmovn_s64(v12);
  if (*(_DWORD *)(a1 + 136) == 2)
    v7 = 0x200000002;
  else
    v7 = 2;
  RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)v7, 4, ***(_QWORD ***)a1 + 80, 0, 1uLL, 0, *(int32x2_t *)(a1 + 104));
  result = *(float *)(a1 + 120) + 1.0;
  *(float *)(a1 + 120) = result;
  return result;
}

float32_t RB::Coverage::set_plane(float32x2_t *a1, uint64_t a2, int32x2_t a3)
{
  int32x2_t v3;
  uint32x2_t v4;
  int8x8_t v5;
  float32x2_t v6;
  int8x8_t v7;
  float64x2_t v8;
  unint64_t v9;
  float32x2_t v10;
  float32_t result;

  a3.i32[0] = 0;
  v3 = *(int32x2_t *)(a2 + 168);
  v4 = (uint32x2_t)vceq_s32(v3, (int32x2_t)0x8000000080000000);
  v5 = (int8x8_t)vdup_lane_s32(vcgt_s32(a3, (int32x2_t)vpmin_u32(v4, v4)), 0);
  v6 = (float32x2_t)vbsl_s8(v5, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)(a2 + 160)));
  v7 = vbsl_s8(v5, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v3));
  v8.f64[0] = 0.0;
  *(double *)&v9 = *(float *)v7.i32;
  v8.f64[1] = *(float *)&v7.i32[1];
  v10 = *(float32x2_t *)(a2 + 112);
  v10.i32[1] = vneg_f32(v10).i32[1];
  *a1 = vmul_f32(v10, vcvt_f32_f64((float64x2_t)v9));
  a1[1] = vmul_f32(v10, vcvt_f32_f64(v8));
  a1[2] = vmla_f32((float32x2_t)0x3F800000BF800000, v6, v10);
  result = *(float *)(a2 + 120);
  a1[3].f32[0] = result;
  return result;
}

void RB::RenderFrame::acquire_queue(uint64_t a1, uint64_t *a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  RB::Heap *v13;
  uint64_t v14;

  if (!*a2)
  {
    v4 = (os_unfair_lock_s *)(a1 + 232);
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 232));
    v6 = *(_DWORD *)(a1 + 280);
    if (v6)
    {
      v7 = a1 + 240;
      v8 = *(_QWORD *)(a1 + 272);
      if (!v8)
        v8 = a1 + 240;
      v9 = v6 - 1;
      v10 = *(_QWORD *)(v8 + 8 * v9);
      *(_QWORD *)(v8 + 8 * v9) = *a2;
      *a2 = v10;
      *(_DWORD *)(a1 + 280) = v9;
      if (*(_QWORD *)(a1 + 272))
        v7 = *(_QWORD *)(a1 + 272);
      v11 = *(_QWORD *)(v7 + 8 * v9);
      *(_QWORD *)(v7 + 8 * v9) = 0;
      if (v11)
        RB::RenderFrame::QueueDeleter::operator()(v5, v11);
      os_unfair_lock_unlock(v4);
    }
    else
    {
      os_unfair_lock_unlock(v4);
      v12 = (char *)malloc_type_malloc(0x2020uLL, 0x10B00405DA38DC0uLL);
      *(_QWORD *)v12 = 0;
      *((_QWORD *)v12 + 1) = 0;
      v13 = RB::Heap::Heap((RB::Heap *)(v12 + 16), v12 + 56, 8064, 0);
      v14 = *a2;
      *a2 = (uint64_t)v12;
      if (v14)
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v13, v14);
    }
  }
}

__int16 RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::render@<H0>(uint64_t a1@<X0>, double a2@<D0>, uint64_t a3@<X1>, uint64_t a4@<X2>, char a5@<W3>, int a6@<W4>)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  __int16 result;
  float64x2_t v17[3];
  __int16 v18;
  int v19;
  __int16 v20;
  __int16 v21;

  v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v17[0] = *v6;
  v17[1] = v8;
  v17[2] = _Q0;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  v18 = *(_WORD *)(a1 + 112);
  v19 = *(_DWORD *)(a1 + 114);
  _H1 = *(_WORD *)(a1 + 118);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  *(float *)_Q0.f64 = _S1 * *(float *)_Q0.f64;
  __asm { FCVT            H0, S0 }
  v20 = LOWORD(_Q0.f64[0]);
  v21 = *(_WORD *)(a1 + 120);
  RB::render_glyphs(a4, v17, (float32x2_t *)(a1 + 56), (uint64_t)&v18, a5, a6);
  return result;
}

void RB::render_glyphs(uint64_t a1, float64x2_t *a2, float32x2_t *a3, uint64_t a4, char a5, int a6)
{
  BOOL v15;
  char v17;
  _BOOL4 may_discard_shape;
  _QWORD v19[2];
  char v20;
  int v21;

  v19[0] = &off_24C22A338;
  v19[1] = a4;
  v20 = a5;
  v21 = a6;
  if (a3[2].i32[0] < 2u)
  {
    v17 = 0;
  }
  else
  {
    _H0 = *(_WORD *)(a4 + 6);
    __asm { FCVT            S0, H0 }
    v15 = a6 != 2 && a6 != 24;
    v17 = _S0 != 1.0 || (a3[6].i8[5] & 1) != 0 || v15;
  }
  may_discard_shape = RB::may_discard_shape(a6);
}

void RB::Device::alloc_shared_buffer(RB::Device *this@<X0>, uint64_t *a2@<X8>)
{
  id *v4;
  unsigned int v5;
  uint64_t *i;
  uint64_t v7;
  id *v8;
  int v9;
  int v10;
  uint64_t *v11;
  uint64_t *v12;
  uint64_t v13;
  RB *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  NSObject *v19;

  v4 = 0;
  *a2 = 0;
  v5 = *((_DWORD *)this + 48);
  for (i = (uint64_t *)((char *)this + 344);
        *((_QWORD *)this + 45);
        std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)i, v11))
  {
    v7 = *((_QWORD *)this + 44);
    v8 = *(id **)(v7 + 16);
    if (*((_DWORD *)v8 + 8) > v5)
      break;
    if (v4 != v8)
    {
      if (!v4
        || (v9 = *((_DWORD *)v4 + 2) - 1, (*((_DWORD *)v4 + 2) = v9) != 0)
        || ((*((void (**)(id *))*v4 + 1))(v4), (v8 = *(id **)(v7 + 16)) != 0))
      {
        ++*((_DWORD *)v8 + 2);
      }
      *a2 = (uint64_t)v8;
      v4 = v8;
    }
    v10 = RB::Resource::set_volatile(v4, 0);
    v11 = (uint64_t *)*((_QWORD *)this + 44);
    v12 = (uint64_t *)v11[1];
    if (v10 != 2)
    {
      if (v11 != v12)
      {
        v16 = *v12;
        v17 = *v11;
        *(_QWORD *)(v17 + 8) = *(_QWORD *)(v16 + 8);
        **(_QWORD **)(v16 + 8) = v17;
        v18 = *i;
        *(_QWORD *)(v18 + 8) = v11;
        *v11 = v18;
        *i = v16;
        *(_QWORD *)(v16 + 8) = i;
      }
      RB::Resource::set_frame_id((uint64_t)v4, 0, 0);
      return;
    }
    v13 = *v11;
    *(_QWORD *)(v13 + 8) = v12;
    *(_QWORD *)v11[1] = v13;
    --*((_QWORD *)this + 45);
  }
  v14 = (RB *)RB::Buffer::alloc((id *)this, *((RB::Device **)this + 34));
  *a2 = (uint64_t)v14;
  if (v4 && (v15 = *((_DWORD *)v4 + 2) - 1, (*((_DWORD *)v4 + 2) = v15) == 0))
  {
    (*((void (**)(id *))*v4 + 1))(v4);
    v14 = (RB *)*a2;
    if (*a2)
      goto LABEL_15;
  }
  else if (v14)
  {
LABEL_15:
    std::list<RB::refcounted_ptr<RB::Buffer>>::push_back(i, a2);
    *((_QWORD *)this + 46) += *((_QWORD *)this + 34);
    return;
  }
  v19 = RB::error_log(v14);
  if (os_log_type_enabled(v19, OS_LOG_TYPE_FAULT))
    RB::Device::alloc_shared_buffer((uint64_t *)this + 34, v19);
}

void sub_209AE7C08(_Unwind_Exception *exception_object)
{
  _DWORD **v1;
  _DWORD *v3;
  int v4;

  v3 = *v1;
  if (*v1)
  {
    v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4)
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
  }
  _Unwind_Resume(exception_object);
}

__int16 RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::render@<H0>(uint64_t a1@<X0>, double a2@<D0>, uint64_t a3@<X1>, uint64_t a4@<X2>, int a5@<W3>, int a6@<W4>)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  __int16 result;
  float64x2_t v20[3];
  uint64_t (*v21)(_QWORD, _QWORD *);
  __int16 v22;
  int v23;
  __int16 v24;
  int v25;
  char v26;
  int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;

  v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  v9 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v20[0] = *v6;
  v20[1] = v8;
  v20[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  v23 = *(unsigned __int8 *)(a1 + 128);
  v24 = *(_WORD *)(a1 + 129);
  v25 = *(unsigned __int8 *)(a1 + 131);
  v26 = *(_BYTE *)(a1 + 132);
  v27 = *(_DWORD *)(a1 + 136);
  v28 = 1065353216;
  v29 = 1;
  v30 = 0;
  if (v23 == 1)
    abort();
  LOWORD(v21) = *(_WORD *)(a1 + 144);
  *(_DWORD *)((char *)&v21 + 2) = *(_DWORD *)(a1 + 146);
  _H1 = *(_WORD *)(a1 + 150);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  HIWORD(v21) = LOWORD(_S0);
  v22 = *(_WORD *)(a1 + 152);
  RB::render_stroke(a4, v20, (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56), (uint64_t)&v23, &v21, a5, a6);
  return result;
}

void RB::render_stroke(uint64_t a1, float64x2_t *a2, __n128 (***a3)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double), uint64_t a4, uint64_t (**a5)(_QWORD, _QWORD *), int a6, int a7)
{
  _BOOL4 v11;
  _BOOL4 may_discard_shape;
  uint64_t (**v13[3])(_QWORD, _QWORD *);

  v11 = *(_DWORD *)(a1 + 136) == 2;
  v13[0] = (uint64_t (**)(_QWORD, _QWORD *))&off_24C22A3F8;
  v13[1] = (uint64_t (**)(_QWORD, _QWORD *))(((a7 & 0x3F) << 6) | 0x12u | ((unint64_t)(a6 | (2 * v11)) << 32));
  v13[2] = a5;
  may_discard_shape = RB::may_discard_shape(a7);
}

_QWORD *std::list<RB::refcounted_ptr<RB::Buffer>>::push_back(uint64_t *a1, uint64_t *a2)
{
  _QWORD *result;
  uint64_t v5;
  uint64_t v6;

  result = operator new(0x18uLL);
  v5 = *a2;
  if (*a2)
    ++*(_DWORD *)(v5 + 8);
  result[1] = a1;
  result[2] = v5;
  v6 = *a1;
  *result = *a1;
  *(_QWORD *)(v6 + 8) = result;
  *a1 = (uint64_t)result;
  ++a1[2];
  return result;
}

uint64_t RB::Symbol::Animator::rendering_mode(os_unfair_lock_s *this)
{
  uint64_t v2;

  os_unfair_lock_lock(this);
  v2 = *(unsigned __int8 *)(*(_QWORD *)&this[2]._os_unfair_lock_opaque + 88);
  os_unfair_lock_unlock(this);
  return v2;
}

uint64_t RBPathCopyTransformedPath(uint64_t a1, uint64_t a2, __int128 *a3)
{
  uint64_t v5;
  uint64_t (*v6)(uint64_t);
  __int128 v8;
  __int128 v9;
  __int128 v10;

  if ((_UNKNOWN *)a2 != &empty_path_callbacks)
  {
    v8 = *a3;
    v9 = a3[1];
    v10 = a3[2];
    v5 = operator new();
    *(_DWORD *)(v5 + 8) = 1;
    *(_QWORD *)v5 = off_24C22A188;
    v6 = *(uint64_t (**)(uint64_t))(a2 + 8);
    if (v6)
      a1 = v6(a1);
    *(_QWORD *)(v5 + 16) = a1;
    *(_QWORD *)(v5 + 24) = a2;
    *(_OWORD *)(v5 + 32) = v8;
    *(_OWORD *)(v5 + 48) = v9;
    *(_OWORD *)(v5 + 64) = v10;
    return v5;
  }
  return a1;
}

void sub_209AE7F00(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10E1C404703BB35);
  _Unwind_Resume(a1);
}

RB::XML::Document *RBDrawingStateAddShadowStyle(uint64_t a1, unsigned int a2, char a3, double a4, double a5, double a6, float a7, float a8, float a9, float a10)
{
  return RBDrawingStateAddShadowStyle3(a1, 0, a2, a3, a4, 0.5, a5, a6, a7, a8, a9, a10);
}

uint64_t RBPathStorageAppendPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
}

RB::ContextDelegate *RBDrawingStateBeginCGContext(uint64_t a1, int a2, float a3)
{
  double v6;

  objc_msgSend(*(id *)(a1 + 8), "deviceScale");
  return begin_cgcontext((_RBDrawingState *)a1, a3, v6, a2);
}

void RB::Device::RenderPipelineEntry::Loader::vertex_fn(id *this, uint64_t a2)
{
  if (a2)
  {
    objc_msgSend(this[6], "setVertexFunction:", a2);
    RB::Device::RenderPipelineEntry::Loader::load_fn((RB::Device::RenderPipelineEntry::Loader *)this, (Function *)1);
  }
  else
  {
    RB::Device::RenderPipelineEntry::Loader::finished((RB::Device::RenderPipelineEntry::Loader *)this);
  }
}

void RB::Device::RenderPipelineEntry::Loader::fragment_fn(id *this, uint64_t a2)
{
  void *v3;
  id v4;
  _QWORD v5[5];

  if (a2)
  {
    objc_msgSend(this[6], "setFragmentFunction:", a2);
    v3 = (void *)*((_QWORD *)this[1] + 3);
    v4 = this[6];
    v5[0] = MEMORY[0x24BDAC760];
    v5[1] = 3221225472;
    v5[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke;
    v5[3] = &__block_descriptor_40_e46_v24__0___MTLRenderPipelineState__8__NSError_16l;
    v5[4] = this;
    objc_msgSend(v3, "newRenderPipelineStateWithDescriptor:completionHandler:", v4, v5);
  }
  else
  {
    RB::Device::RenderPipelineEntry::Loader::finished((RB::Device::RenderPipelineEntry::Loader *)this);
  }
}

uint64_t RB::Refcount<RB::Symbol::Model,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Device::RenderPipelineEntry::Loader::pipeline(RB::Device::RenderPipelineEntry::Loader *this, void *a2)
{
  void *v3;

  v3 = (void *)*((_QWORD *)this + 8);
  if (v3 != a2)
  {

    *((_QWORD *)this + 8) = a2;
  }
  RB::Device::RenderPipelineEntry::Loader::finished(this);
}

char **RB::SharedSurfaceGroup::render_updates_device(os_unfair_lock_s *this)
{
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;
  os_unfair_lock_s *v4;
  os_unfair_lock_s *v5;
  unsigned int *v6;
  int v7;
  char *v8;
  char *v9;
  unsigned int *v10;
  unsigned int v11;
  int v12;
  int v13;
  char *v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  MTLPixelFormat v22;
  uint64_t v23;
  char *v24;
  char *v25;
  uint64_t v26;
  size_t v27;
  int32x2_t *v28;
  char v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  int v34;
  uint64_t v35;
  int32x2_t v36;
  int32x2_t v37;
  int32x2_t v38;
  int v39;
  __int128 v40;
  int32x2_t *v41;
  char v42;
  void *v43;
  char *v44;
  char *v45;
  int32x2_t v46;
  RB::Surface *v52;
  unsigned int *v53;
  const char *v54;
  void *blit_encoder;
  uint64_t v56;
  __int128 v57;
  uint64_t v58;
  uint64_t v59;
  _QWORD *v60;
  uint64_t v61;
  void *v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  __int128 v66;
  _DWORD *v67;
  MTLPixelFormat v68;
  id v69;
  __n128 v70;
  uint64_t v71;
  _QWORD *v72;
  uint64_t v73;
  int32x2_t v74;
  int32x2_t v75;
  int32x2_t v76;
  int32x2_t v77;
  _DWORD *v78;
  MTLPixelFormat v79;
  id v80;
  float32x2_t v81;
  float32x2_t v82;
  int v83;
  int v84;
  char v85;
  uint32_t v86;
  char *v87;
  uint64_t v88;
  os_unfair_lock_s *v89;
  os_unfair_lock_s *v90;
  _QWORD *v91;
  uint64_t v93;
  int v94;
  char *v95;
  RB::Device **v96;
  char **__ptr32 *v97;
  char *v98;
  float64x2_t v99;
  float64x2_t v100;
  float32x2_t *v101;
  __int128 v102;
  __int128 v103;
  __int128 v104;
  float64x2_t v105[2];
  uint64_t v106;
  uint64_t v107;
  _DWORD *v108;
  _QWORD v109[4];
  __int32 v110;
  uint64_t v111;
  int v112;
  __int32 v113;
  int v114;
  float32x2_t v115;
  int v116;
  uint64_t v117;
  int v118;
  _BYTE v119[40];
  _QWORD v120[5];
  int v121;
  __int16 v122;
  char v123;
  _BYTE v124[28];
  unsigned __int8 v125;
  __int128 v126;
  uint64_t v127;
  __int128 v128;
  uint64_t v129;
  __int128 v130;
  uint64_t v131;
  _QWORD v132[5];
  char *v133;
  uint64_t v134;
  int v135;
  int v136;
  int v137;
  __int128 v138[10];
  uint64_t v139;
  int32x2_t v140;
  int v141;
  char v142;
  id v143[11];
  uint32_t v144;
  uint64_t v145;

  v145 = *MEMORY[0x24BDAC8D0];
  v134 = 0;
  v133 = 0;
  v2 = this + 4;
  os_unfair_lock_lock(this + 4);
  v3 = this + 6;
  v96 = (RB::Device **)this;
  v4 = *(os_unfair_lock_s **)&this[8]._os_unfair_lock_opaque;
  if (v4 != &this[6])
  {
    while (1)
    {
      v5 = (os_unfair_lock_s *)(*(_QWORD *)&v4[4]._os_unfair_lock_opaque + 112);
      os_unfair_lock_lock(v5);
      v6 = *(unsigned int **)&v4[4]._os_unfair_lock_opaque;
      if (!v6[32] && !v6[36])
        goto LABEL_10;
      v7 = v134;
      if (HIDWORD(v134) >= (v134 + 1))
        break;
      RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow((uint64_t)&v133, v134 + 1);
      v7 = v134;
      v6 = *(unsigned int **)&v4[4]._os_unfair_lock_opaque;
      v8 = v133;
      v9 = &v133[40 * v134];
      if (v6)
        goto LABEL_6;
      v12 = v134;
      v13 = v134;
LABEL_9:
      *(_QWORD *)v9 = v6;
      v14 = &v8[40 * v7];
      *(_OWORD *)(v14 + 8) = 0u;
      *(_OWORD *)(v14 + 24) = 0u;
      LODWORD(v134) = v13 + 1;
      v15 = &v8[40 * v12];
      v16 = *(_QWORD *)&v4[4]._os_unfair_lock_opaque;
      v17 = *((_QWORD *)v15 + 1);
      *((_QWORD *)v15 + 1) = *(_QWORD *)(v16 + 120);
      *(_QWORD *)(v16 + 120) = v17;
      LODWORD(v17) = *((_DWORD *)v15 + 4);
      *((_DWORD *)v15 + 4) = *(_DWORD *)(v16 + 128);
      *(_DWORD *)(v16 + 128) = v17;
      LODWORD(v17) = *((_DWORD *)v15 + 5);
      *((_DWORD *)v15 + 5) = *(_DWORD *)(v16 + 132);
      *(_DWORD *)(v16 + 132) = v17;
      v18 = &v133[40 * (v134 - 1)];
      v19 = *(_QWORD *)&v4[4]._os_unfair_lock_opaque;
      v20 = *((_QWORD *)v18 + 3);
      *((_QWORD *)v18 + 3) = *(_QWORD *)(v19 + 136);
      *(_QWORD *)(v19 + 136) = v20;
      LODWORD(v20) = *((_DWORD *)v18 + 8);
      *((_DWORD *)v18 + 8) = *(_DWORD *)(v19 + 144);
      *(_DWORD *)(v19 + 144) = v20;
      LODWORD(v20) = *((_DWORD *)v18 + 9);
      *((_DWORD *)v18 + 9) = *(_DWORD *)(v19 + 148);
      *(_DWORD *)(v19 + 148) = v20;
      *(_BYTE *)(*(_QWORD *)&v4[4]._os_unfair_lock_opaque + 172) = 1;
LABEL_10:
      os_unfair_lock_unlock(v5);
      v4 = *(os_unfair_lock_s **)&v4[2]._os_unfair_lock_opaque;
      if (v4 == v3)
        goto LABEL_14;
    }
    v8 = v133;
    v9 = &v133[40 * v134];
LABEL_6:
    v10 = v6 + 2;
    do
      v11 = __ldxr(v10);
    while (__stxr(v11 + 1, v10));
    v12 = v134;
    v13 = v134;
    goto LABEL_9;
  }
LABEL_14:
  os_unfair_lock_unlock(v2);
  if (!(_DWORD)v134)
  {
    RB::Drawable::end_frame(v96[1], 0.0);
    v86 = 0;
    v85 = 0;
    goto LABEL_65;
  }
  v21 = RB::RenderFrame::RenderFrame((RB::RenderFrame *)v143, *v96, v96[1], 1u);
  if (!(_DWORD)v134)
  {
LABEL_62:
    v85 = 0;
    goto LABEL_63;
  }
  LOBYTE(v23) = 0;
  v24 = v133;
  v25 = &v133[40 * v134];
  *(_QWORD *)&v104 = v25;
  do
  {
    v26 = *((unsigned int *)v24 + 4);
    if (!(_DWORD)v26)
      goto LABEL_29;
    if (v26 >= 0x41)
    {
      v28 = (int32x2_t *)malloc_type_malloc(v26 << 6, 0xD88273D9uLL);
      if (!v28)
        goto LABEL_28;
    }
    else
    {
      MEMORY[0x24BDAC7A8](v21, v26 << 6);
      v28 = (int32x2_t *)((char *)&v93 - ((v27 + 15) & 0x7FFFFFFFF0));
      bzero(v28, v27);
    }
    v29 = v23;
    v30 = *((unsigned int *)v24 + 4);
    if ((_DWORD)v30)
    {
      v31 = 0;
      v32 = v30 << 6;
      do
      {
        v33 = *((_QWORD *)v24 + 1) + v31;
        v34 = *(_DWORD *)(v33 + 52);
        v35 = objc_msgSend(*(id *)v33, "_rb_contents");
        v36 = vdup_n_s32(v34 << 30 >> 31);
        v38 = *(int32x2_t *)(v33 + 8);
        v37 = *(int32x2_t *)(v33 + 16);
        if ((v34 & 4) != 0)
          v39 = 2;
        else
          v39 = 1;
        v40 = *(_OWORD *)(v33 + 32);
        v41 = &v28[v31 / 8];
        *v41 = (int32x2_t)v35;
        v41[1] = 0;
        v41[2] = v36;
        v41[3] = v37;
        v41[4] = v38;
        v41[5].i32[0] = v39;
        *(_OWORD *)v41[6].i8 = v40;
        v31 += 64;
      }
      while (v32 != v31);
    }
    v23 = *(_QWORD *)(*(_QWORD *)v24 + 24);
    RB::RenderParams::RenderParams((uint64_t)v138, (uint64_t)v143, v23, *(float *)(*(_QWORD *)v24 + 64));
    v132[0] = MEMORY[0x24BDAC760];
    v132[1] = 3221225472;
    v132[2] = ___ZN2RB18SharedSurfaceGroup21render_updates_deviceEv_block_invoke;
    v132[3] = &__block_descriptor_40_e19____MTLTexture__8__0l;
    v132[4] = v23;
    RB::DisplayList::render_many(v138, (uint64_t)v132, *((unsigned int *)v24 + 4), v28);
    LOBYTE(v23) = v29;
    v25 = (char *)v104;
    if (v26 >= 0x41)
LABEL_28:
      free(v28);
LABEL_29:
    LODWORD(v23) = (v23 & 1) != 0 || *((_DWORD *)v24 + 8) != 0;
    v24 += 40;
  }
  while (v24 != v25);
  if ((v23 & 1) == 0)
    goto LABEL_62;
  v42 = *((_BYTE *)*v96 + 292);
  if ((_DWORD)v134)
  {
    v94 = v23;
    v43 = 0;
    v44 = v133;
    v45 = &v133[40 * v134];
    v101 = (float32x2_t *)&v136;
    v46 = vdup_n_s32(0x7F7FFFFFu);
    __asm { FMOV            V12.2S, #1.0 }
    v100 = (float64x2_t)xmmword_209BD5290;
    v99 = (float64x2_t)xmmword_209BD52A0;
    v97 = &off_209BD5000;
    v95 = v45;
    do
    {
      v52 = *(RB::Surface **)(*(_QWORD *)v44 + 24);
      v53 = RB::pixel_format_traits(*((_QWORD *)v52 + 4), v22);
      if (((*v53 | ((unint64_t)*((unsigned __int16 *)v53 + 2) << 32)) & 0x40000000000) != 0
        && !RB::disable_workaround((RB *)"blit-planar-texture", v54))
      {
        if (v43)
          objc_msgSend(v43, "endEncoding");
        RB::RenderParams::RenderParams((uint64_t)v124, (uint64_t)v143, (uint64_t)v52, *(float *)(*(_QWORD *)v44 + 64));
        v67 = (_DWORD *)operator new();
        v69 = (id)RB::Surface::texture(v52, v68);
        RB::Texture::Texture(v67, v69, v125, 1, 0);
        RB::RenderPass::RenderPass(v138, v124, v67, 0, 1, 0);
        RB::RenderPass::set_label((id *)v138, CFSTR("RB: Shared surface copy"));
        RB::RenderPass::set_extra_attachments((uint64_t)v138, (MTLPixelFormat)(v97 & 0xF0), v70);
        v71 = *((unsigned int *)v44 + 8);
        if ((_DWORD)v71)
        {
          v72 = (_QWORD *)*((_QWORD *)v44 + 3);
          v73 = 48 * v71;
          do
          {
            v74 = (int32x2_t)v72[4];
            v139 = v72[3];
            v140 = v74;
            v120[0] = 0x100000001000000;
            v120[1] = v46;
            v120[2] = 0;
            v120[3] = 0;
            v120[4] = 1065353216;
            v121 = 0;
            v122 = 257;
            v123 &= 0xF8u;
            v75 = *(int32x2_t *)(*(_QWORD *)(*v72 + 24) + 24);
            v77 = (int32x2_t)v72[2];
            v76 = (int32x2_t)v72[3];
            v78 = (_DWORD *)operator new();
            v80 = (id)RB::Surface::texture(*(RB::Surface **)(*v72 + 24), v79);
            RB::Texture::Texture(v78, v80, v125, 1, 0);
            RB::Heap::Heap((RB::Heap *)v119, 0, 0, 0);
            v81 = vcvt_f32_s32(v74);
            v82 = vdiv_f32(vmul_f32(vcvt_f32_s32(v75), v81), v81);
            v108 = v78;
            v109[0] = 0;
            v109[1] = _D12;
            v109[2] = 0;
            v109[3] = 0;
            v110 = v82.i32[0];
            v111 = 0;
            v112 = 0;
            v113 = v82.i32[1];
            v114 = 0;
            v115 = vsub_f32(vcvt_f32_s32(v76), vdiv_f32(vmul_f32(vcvt_f32_s32(v77), v81), v81));
            v116 = 1065353216;
            v117 = 0x3C003C003C003C00;
            v118 = 0;
            v105[0] = v100;
            v105[1] = v99;
            v106 = 0;
            v107 = 0;
            RB::Fill::set_image(v101, (uint64_t)v138, (uint64_t)v78, v105, (uint64_t)v109, 1.0);
            v137 &= ~0x100u;
            RB::render_primitive((uint64_t)v138, v105, (uint64_t)v120, (uint64_t)&v135, (uint64_t)v109, 0, 0);
            v141 = 0;
            v142 = 0;
            RB::Heap::~Heap((RB::Heap *)v119);
            v83 = v78[2] - 1;
            v78[2] = v83;
            if (!v83)
              (*(void (**)(_DWORD *))(*(_QWORD *)v78 + 8))(v78);
            v72 += 6;
            v73 -= 48;
          }
          while (v73);
        }
        RB::RenderPass::~RenderPass((RB::RenderPass *)v138);
        v84 = v67[2] - 1;
        v67[2] = v84;
        if (!v84)
          (*(void (**)(_DWORD *))(*(_QWORD *)v67 + 8))(v67);
        v43 = 0;
        v97 = (char **__ptr32 *)(v97 & 0xFFFFFFF0);
      }
      else
      {
        if (!v43)
        {
          RB::RenderFrame::end_encoding(v143);
          blit_encoder = (void *)RB::RenderFrame::make_blit_encoder((RB::RenderFrame *)v143);
          v43 = blit_encoder;
          if ((v42 & 1) != 0)
            objc_msgSend(blit_encoder, "setLabel:", CFSTR("RB: Shared surface blit"));
        }
        v56 = RB::Surface::texture(v52, (MTLPixelFormat)v54);
        v58 = *((unsigned int *)v44 + 8);
        if ((_DWORD)v58)
        {
          v59 = v56;
          v98 = v44;
          v60 = (_QWORD *)*((_QWORD *)v44 + 3);
          v61 = 48 * v58;
          do
          {
            *(_QWORD *)&v57 = v60[2];
            v103 = v57;
            *(_QWORD *)&v57 = v60[3];
            v102 = v57;
            *(_QWORD *)&v57 = v60[4];
            v104 = v57;
            if ((v42 & 1) != 0)
            {
              snprintf((char *)v138, 0x100uLL, "Blit [%d %d, %d] [%d, %d, %d] [%d %d] [%d %d] [%d %d]", *(_QWORD *)(*(_QWORD *)(*v60 + 24) + 32), *(_QWORD *)(*(_QWORD *)(*v60 + 24) + 24), HIDWORD(*(_QWORD *)(*(_QWORD *)(*v60 + 24) + 24)), *((_QWORD *)v52 + 4), *((_QWORD *)v52 + 3), HIDWORD(*((_QWORD *)v52 + 3)), (_DWORD)v103, DWORD1(v103), (_DWORD)v104, DWORD1(v104), (_DWORD)v102, DWORD1(v102));
              v62 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", v138, 1);
              objc_msgSend(v43, "insertDebugSignpost:", v62);

            }
            v63 = RB::Surface::texture(*(RB::Surface **)(*v60 + 24), v22);
            *(_QWORD *)&v64 = (int)v103;
            *((_QWORD *)&v64 + 1) = SDWORD1(v103);
            v65 = v64;
            *(_QWORD *)&v64 = (int)v102;
            *((_QWORD *)&v64 + 1) = SDWORD1(v102);
            v66 = v64;
            v130 = v65;
            *(_QWORD *)&v64 = (int)v104;
            *((_QWORD *)&v64 + 1) = SDWORD1(v104);
            v131 = 0;
            v128 = v64;
            v129 = 1;
            v126 = v66;
            v127 = 0;
            objc_msgSend(v43, "copyFromTexture:sourceSlice:sourceLevel:sourceOrigin:sourceSize:toTexture:destinationSlice:destinationLevel:destinationOrigin:", v63, 0, 0, &v130, &v128, v59, 0, 0, &v126);
            if ((v42 & 4) != 0)
            {
              objc_msgSend(v43, "endEncoding");
              v43 = 0;
            }
            v60 += 6;
            v61 -= 48;
          }
          while (v61);
          v44 = v98;
          v45 = v95;
        }
      }
      v44 += 40;
    }
    while (v44 != v45);
    v85 = v94;
    if (v43)
      objc_msgSend(v43, "endEncoding");
  }
  else
  {
    v85 = 1;
  }
LABEL_63:
  v86 = v144;
  RB::RenderFrame::~RenderFrame((RB::RenderFrame *)v143);
LABEL_65:
  if ((_DWORD)v134)
  {
    v87 = v133;
    v88 = 40 * v134;
    do
    {
      v89 = (os_unfair_lock_s *)(*(_QWORD *)v87 + 112);
      os_unfair_lock_lock(v89);
      v90 = *(os_unfair_lock_s **)v87;
      *(_BYTE *)(*(_QWORD *)v87 + 172) = 0;
      if (v86)
        v90[42]._os_unfair_lock_opaque = v86;
      os_unfair_lock_unlock(v89);
      v87 += 40;
      v88 -= 40;
    }
    while (v88);
  }
  if ((v85 & 1) != 0)
  {
    v91 = (_QWORD *)operator new();
    *v91 = v133;
    v133 = 0;
    v91[1] = v134;
    v134 = 0;
    dispatch_async_f(MEMORY[0x24BDAC9B8], v91, (dispatch_function_t)RB::SharedSurfaceGroup::render_updates_device(void)::$_1::__invoke);
    objc_msgSend(*((id *)*v96 + 2), "collectResources");
  }
  return RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector(&v133);
}

void sub_209AE8BC8(_Unwind_Exception *a1)
{
  uint64_t v1;
  os_unfair_lock_s *v2;
  os_unfair_lock_s *v3;

  os_unfair_lock_unlock(v3);
  os_unfair_lock_unlock(v2);
  RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector((char **)(v1 + 528));
  _Unwind_Resume(a1);
}

void sub_209AE9804(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,id a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,id a46)
{
  void *v46;
  void *v47;
  uint64_t v48;

  if (*(_BYTE *)(v48 - 200))
    os_unfair_lock_unlock(*(os_unfair_lock_t *)(v48 - 208));

  _Unwind_Resume(a1);
}

uint64_t RBXMLRecorderInstalled(void)
{
  if (RBXMLRecorderInstalled(void)::once != -1)
    dispatch_once(&RBXMLRecorderInstalled(void)::once, &__block_literal_global);
  return RB::XMLRecorder::installed;
}

uint64_t RB::Device::shared_surfaces(RB::Device *this)
{
  return *((_QWORD *)this + 122);
}

void std::unique_lock<RB::spin_lock>::unlock(uint64_t a1)
{
  _RBDrawingState *v2;
  int v3;
  float v4;
  double v5;

  if (*(_BYTE *)(a1 + 8))
  {
    os_unfair_lock_unlock(*(os_unfair_lock_t *)a1);
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::unlock: not locked");
    begin_cgcontext(v2, v4, v5, v3);
  }
}

RB::ContextDelegate *begin_cgcontext(_RBDrawingState *a1, float a2, double a3, int a4)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  RB::ContextDelegate **v14;

  v8 = *((_QWORD *)a1 + 1);
  v9 = *(_DWORD *)(v8 + 344);
  if (*(_DWORD *)(v8 + 348) < v9 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow((void *)(v8 + 320), v9 + 1);
    v9 = *(_DWORD *)(v8 + 344);
  }
  v10 = *(_QWORD *)(v8 + 336);
  if (!v10)
    v10 = v8 + 320;
  v11 = (_QWORD *)(v10 + 16 * v9);
  *v11 = 0;
  v11[1] = 0;
  v12 = *(unsigned int *)(v8 + 344);
  *(_DWORD *)(v8 + 344) = v12 + 1;
  v13 = *(_QWORD *)(v8 + 336);
  if (!v13)
    v13 = v8 + 320;
  v14 = (RB::ContextDelegate **)(v13 + 16 * v12);
  RB::ContextDelegate::borrow_context((uint64_t)v14);
  RB::ContextDelegate::begin(v14[1], a1, a2, a3, a4);
  return *v14;
}

uint64_t RB::ContextDelegate::begin(RB::ContextDelegate *this, _RBDrawingState *a2, float a3, double a4, int a5)
{
  __int128 v10;
  __int128 v11;
  uint64_t result;
  _OWORD v13[3];

  RBDrawingStateGetCTM((uint64_t)a2, (uint64_t)v13);
  v10 = v13[1];
  v11 = v13[2];
  *((_OWORD *)this + 24) = v13[0];
  *((_OWORD *)this + 25) = v10;
  *((_OWORD *)this + 26) = v11;
  *((_QWORD *)this + 54) = a2;
  *((_QWORD *)this + 55) = 0;
  *((float *)this + 114) = a3;
  *((double *)this + 56) = a4;
  *((_DWORD *)this + 115) = a5;
  *((_DWORD *)this + 116) = 0;
  *((_QWORD *)this + 59) = 0;
  result = RBDrawingStateGetDefaultColorSpace((uint64_t)a2);
  *((_DWORD *)this + 132) = result;
  return result;
}

__n128 RBDrawingStateGetCTM@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __n128 result;

  v2 = *(_OWORD *)(a1 + 32);
  *(_OWORD *)a2 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)(a2 + 16) = v2;
  result = *(__n128 *)(a1 + 48);
  *(__n128 *)(a2 + 32) = result;
  return result;
}

uint64_t rb_color_space(__int16 a1)
{
  if ((a1 & 0xFF00) == 0)
    return 0;
  if ((a1 - 1) > 4u)
    return 2;
  return dword_209BD70F0[(char)(a1 - 1)];
}

void RB::ContextDelegate::borrow_context(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const void *v10;
  RB::ContextDelegate *v11;
  const void *v12;
  uint64_t v13;

  os_unfair_lock_lock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  v2 = RB::ContextDelegate::_contexts;
  if (RB::ContextDelegate::_contexts && (v3 = *(_QWORD *)(RB::ContextDelegate::_contexts + 136)) != 0)
  {
    if (*(_QWORD *)(RB::ContextDelegate::_contexts + 128))
      v2 = *(_QWORD *)(RB::ContextDelegate::_contexts + 128);
    v4 = v2 + 16 * v3;
    v5 = *(CFTypeRef *)a1;
    *(_QWORD *)a1 = *(_QWORD *)(v4 - 16);
    *(_QWORD *)(v4 - 16) = v5;
    v6 = *(_QWORD *)(a1 + 8);
    *(_QWORD *)(a1 + 8) = *(_QWORD *)(v4 - 8);
    *(_QWORD *)(v4 - 8) = v6;
    v7 = RB::ContextDelegate::_contexts;
    v8 = *(_QWORD *)(RB::ContextDelegate::_contexts + 128);
    v9 = *(_QWORD *)(RB::ContextDelegate::_contexts + 136) - 1;
    *(_QWORD *)(RB::ContextDelegate::_contexts + 136) = v9;
    if (v8)
      v7 = v8;
    v10 = *(const void **)(v7 + 16 * v9);
    if (v10)
      CFRelease(v10);
    CGContextResetState();
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  }
  else
  {
    os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
    v11 = (RB::ContextDelegate *)operator new();
    RB::ContextDelegate::ContextDelegate(v11);
    *(_QWORD *)(a1 + 8) = v11;
    v12 = (const void *)CGContextDelegateCreate();
    CGContextDelegateSetCallbacks();
    v13 = CGContextCreateWithDelegate();
    if (*(_QWORD *)a1)
      CFRelease(*(CFTypeRef *)a1);
    *(_QWORD *)a1 = v13;
    if (v12)
      CFRelease(v12);
  }
}

void sub_209AE9E30(_Unwind_Exception *a1)
{
  os_unfair_lock_unlock((os_unfair_lock_t)&RB::ContextDelegate::_contexts_lock);
  _Unwind_Resume(a1);
}

uint64_t RBDrawingStateGetDefaultColorSpace(uint64_t a1)
{
  return rb_color_space(*(_WORD *)(a1 + 156));
}

void sub_209AE9EF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Layer::output_depth(RB::DisplayList::Layer *this)
{
  uint64_t result;
  _QWORD *i;

  result = *((unsigned __int8 *)this + 65);
  for (i = (_QWORD *)*((_QWORD *)this + 2); i; i = (_QWORD *)i[1])
    result = (*(uint64_t (**)(_QWORD *, _QWORD))(*i + 72))(i, result);
  return result;
}

uint64_t RB::ColorMode::ColorMode(uint64_t a1, int a2)
{
  int v3;
  int v4;
  unsigned __int8 v5;
  char v6;
  int v7;
  uint64_t v9;
  const char *v10;
  int v11;

  *(_BYTE *)a1 = 0;
  *(_DWORD *)(a1 + 4) = 0;
  v3 = 0;
  v4 = 16;
  switch(a2)
  {
    case -1:
      abort();
    case 1:
    case 6:
    case 7:
    case 8:
      v3 = 1;
      *(_DWORD *)(a1 + 4) = 1;
      goto LABEL_6;
    case 2:
    case 13:
      v3 = 1;
      *(_DWORD *)(a1 + 4) = 1;
      goto LABEL_5;
    case 3:
LABEL_7:
      v4 = v3 | 2;
      goto LABEL_12;
    case 4:
LABEL_8:
      v4 = v3 | 4;
      goto LABEL_12;
    case 5:
LABEL_9:
      v4 = v3 | 0xC;
      goto LABEL_12;
    case 9:
      goto LABEL_12;
    case 10:
      v4 = 17;
LABEL_12:
      *(_DWORD *)(a1 + 4) = v4;
      break;
    case 11:
    case 12:
      v3 = 0;
LABEL_5:
      *(_BYTE *)a1 = 4;
LABEL_6:
      switch(a2)
      {
        case 3:
        case 6:
          goto LABEL_7;
        case 4:
        case 7:
          goto LABEL_8;
        case 5:
        case 8:
          goto LABEL_9;
        case 12:
        case 13:
          v4 = v3 | 0x20;
          goto LABEL_12;
        default:
          goto LABEL_13;
      }
    default:
      break;
  }
LABEL_13:
  if ((v5 & 1) == 0)
  {
    if ((_DWORD)v9)
    {
      RB::ColorMode::ColorMode(RBColorMode)::overrides = RB::ColorMode::ColorMode(RBColorMode)::$_0::operator()(v9, v10);
      dword_253EAEFD8 = v11;
    }
  }
  v6 = dword_253EAEFD8;
  v7 = BYTE1(dword_253EAEFD8);
  *(_DWORD *)(a1 + 4) = *(_DWORD *)(a1 + 4) & ~(_DWORD)RB::ColorMode::ColorMode(RBColorMode)::overrides | HIDWORD(RB::ColorMode::ColorMode(RBColorMode)::overrides);
  if (v7)
    *(_BYTE *)a1 = v6;
  return a1;
}

void sub_209AEA090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL RB::SharedSurfaceGroup::preflight_subsurface(RB::SharedSurfaceGroup *a1, int32x2_t a2)
{
  int v2;
  RB::SharedSurfaceGroup *v3;
  uint32x2_t v5;

  v2 = vmul_lane_s32(a2, a2, 1).u32[0];
  v3 = (RB::SharedSurfaceGroup *)RB::SharedSurfaceGroup::max_subsurface_area(a1);
  if (v2 > (int)v3)
    return 0;
  v5 = (uint32x2_t)vcgt_s32(a2, vdup_n_s32(RB::SharedSurfaceGroup::max_subsurface_size(v3)));
  return vpmax_u32(v5, v5).i32[0] >= 0;
}

uint64_t RB::SharedSurfaceGroup::max_subsurface_area(RB::SharedSurfaceGroup *this)
{
  unsigned __int8 v1;
  const __CFString *v3;
  uint64_t v4;
  int v5;

  if ((v1 & 1) == 0
  {
    v4 = RB::prefs_int(CFSTR("RBMaxSubsurfaceArea"), v3);
    if ((v4 & 0xFF00000000) != 0)
      v5 = v4;
    else
      v5 = 0x10000;
    RB::SharedSurfaceGroup::max_subsurface_area(void)::value = v5;
  }
  return RB::SharedSurfaceGroup::max_subsurface_area(void)::value;
}

void sub_209AEA178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

RBDevice *current_device_locked(RBLayer *a1)
{
  RBDevice *result;
  void *v3;

  result = (RBDevice *)*((_QWORD *)a1 + 5);
  if (!result)
  {
    v3 = (void *)-[RBLayer delegate](a1, "delegate");
    if ((objc_opt_respondsToSelector() & 1) == 0)
      return +[RBDevice sharedDefaultDevice](RBDevice, "sharedDefaultDevice");
    result = (RBDevice *)objc_msgSend(v3, "RBLayerDefaultDevice:", a1);
    if (!result)
      return +[RBDevice sharedDefaultDevice](RBDevice, "sharedDefaultDevice");
  }
  return result;
}

void sub_209AEA3DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

RB::XML::Document *RBDrawingStateConcatCTM(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  const RB::AffineTransform *v7;
  RB::XML::Document *result;
  __int128 v9;
  __int128 v10;
  float64x2_t v11;
  __int128 v12;
  __int128 v13;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_OWORD *)(a2 + 16);
  v6 = *(_OWORD *)(a2 + 32);
  v11 = *(float64x2_t *)a2;
  v12 = v5;
  v13 = v6;
  RB::DisplayList::State::concat((float64x2_t *)a1, &v11);
  result = *(RB::XML::Document **)(v4 + 304);
  if (result)
  {
    v9 = *(_OWORD *)(a2 + 16);
    v10 = *(_OWORD *)(a2 + 32);
    v11 = *(float64x2_t *)a2;
    v12 = v9;
    v13 = v10;
    return RB::XML::DisplayList::concat_ctm(result, (_RBDrawingState *)a1, &v11, v7);
  }
  return result;
}

void RB::DisplayList::State::concat(float64x2_t *this, float64x2_t *a2)
{
  int64x2_t v2;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;

  v2 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a2[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v2, 1), (int8x16_t)v2).u64[0] & 0x8000000000000000) == 0)
  {
    v4.f64[0] = RB::operator*(a2, this + 1);
    this[1] = v4;
    this[2] = v5;
    this[3] = v6;
    this[7].f64[0] = 0.0;
    HIDWORD(this[9].f64[0]) = -1;
  }
}

void RBXMLRecorderMarkFrame(const void *a1, void *a2, int a3, double a4, double a5)
{
  unsigned __int8 v10;
  uint64_t v11;
  objc_class *v12;
  __CFString *v13;
  CFTypeID v14;
  double v15;
  FILE *v16;
  const char *v17;
  void **v18;
  size_t v19;
  void **v20;
  uint64_t v21;
  const char *v22;
  uint64_t v23;
  int v24;
  void *v25[2];
  unsigned __int8 v26;
  void *__p[2];
  char v28;
  char v29[8];
  _QWORD v30[10];
  char v31;
  _QWORD v32[20];

  v32[19] = *MEMORY[0x24BDAC8D0];
  if ((v10 & 1) == 0
  {
    if (os_variant_has_internal_diagnostics())
    {
      v23 = RB::debug_int((RB *)"RB_SAVE_ARCHIVES", v22);
      if ((v23 & 0xFF00000000) != 0)
        v24 = v23;
      else
        v24 = 0;
    }
    else
    {
      v24 = 0;
    }
    RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives = v24;
  }
  if (RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives >= 1)
  {
    snprintf_l(v29, 0x100uLL, 0, "RBDisplayList-%d.rbar", ++RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::counter);
    RBArchiveToFile(a2, v29, RBXMLRecorderMarkFrame(objc_object *,objc_object  {objcproto22_RBDisplayListContents}*,CGSize,RB::ColorSpace)::save_archives == 1);
  }
  if (RB::XMLRecorder::enabled)
  {
    v11 = objc_msgSend(a2, "_rb_xml_document");
    if (v11)
    {
      std::ostringstream::basic_ostringstream[abi:nn180100]((uint64_t)v29);
      RB::XML::Document::print(v11, v29, (~a3 << 31), a4, a5);
      v12 = (objc_class *)objc_opt_class();
      v13 = (__CFString *)NSStringFromClass(v12);
      if (-[__CFString isEqualToString:](v13, "isEqualToString:", CFSTR("__NSCFType")))
      {
        v14 = CFGetTypeID(a1);
        v13 = (id)CFCopyTypeIDDescription(v14);
      }
      v15 = CACurrentMediaTime();
      if (RB::XMLRecorder::log_file)
      {
        v16 = fopen((const char *)objc_msgSend((id)RB::XMLRecorder::log_file, "UTF8String"), "a");
        if (v16)
        {
          v17 = (const char *)-[__CFString UTF8String](v13, "UTF8String");
          std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v30, __p);
          if (v28 >= 0)
            v18 = __p;
          else
            v18 = (void **)__p[0];
          fprintf(v16, "** %s %p: frame at time %f **\n\n%s\n", v17, a1, v15, (const char *)v18);
          if (v28 < 0)
            operator delete(__p[0]);
          fclose(v16);
        }
      }
      else
      {
        snprintf((char *)__p, 0x100uLL, "\n** %s %p frame at time %f: **\n\n", (const char *)-[__CFString UTF8String](v13, "UTF8String"), a1, v15);
        v19 = strlen((const char *)__p);
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)__p, v19);
        std::stringbuf::str[abi:nn180100]<std::allocator<char>>((uint64_t)v30, v25);
        if ((v26 & 0x80u) == 0)
          v20 = v25;
        else
          v20 = (void **)v25[0];
        if ((v26 & 0x80u) == 0)
          v21 = v26;
        else
          v21 = (uint64_t)v25[1];
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)v20, v21);
        if ((char)v26 < 0)
          operator delete(v25[0]);
        std::ostream::flush();
      }
      *(_QWORD *)v29 = *MEMORY[0x24BEDB800];
      *(_QWORD *)&v29[*(_QWORD *)(*(_QWORD *)v29 - 24)] = *(_QWORD *)(MEMORY[0x24BEDB800] + 24);
      v30[0] = MEMORY[0x24BEDB848] + 16;
      if (v31 < 0)
        operator delete((void *)v30[8]);
      std::streambuf::~streambuf();
      std::ostream::~ostream();
      MEMORY[0x20BD16520](v32);
    }
  }
}

void sub_209AEAA64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52)
{
  _Unwind_Resume(a1);
}

uint64_t RB::SharedSurfaceGroup::max_subsurface_size(RB::SharedSurfaceGroup *this)
{
  unsigned __int8 v1;
  const __CFString *v3;
  uint64_t v4;
  int v5;

  if ((v1 & 1) == 0
  {
    v4 = RB::prefs_int(CFSTR("RBMaxSubsurfaceSize"), v3);
    if ((v4 & 0xFF00000000) != 0)
      v5 = v4;
    else
      v5 = 512;
    RB::SharedSurfaceGroup::max_subsurface_size(void)::value = v5;
  }
  if (RB::SharedSurfaceGroup::max_subsurface_size(void)::value >= 2048)
    return 2048;
  else
    return RB::SharedSurfaceGroup::max_subsurface_size(void)::value;
}

void sub_209AEAB44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *RB::vector<RB::DisplayList::Interpolator::Contents::AnimationTableItem,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,40ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,40ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(40 * a3);
    v6 = v5 / 0x28;
    if (*a2 != (v5 / 0x28))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::RenderParams::RenderParams(uint64_t a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v8;
  uint64_t v9;
  unsigned __int8 v10;
  char v11;
  MTLPixelFormat v12;
  unsigned int v13;
  int v14;

  v8 = *(_QWORD *)(a3 + 32);
  v9 = *(_QWORD *)(a3 + 24);
  v10 = *(_BYTE *)(a3 + 44);
  v11 = RB::color_space_to_srgb(v10);
  v13 = *((unsigned __int16 *)RB::pixel_format_traits(*(_QWORD *)(a3 + 32), v12) + 2);
  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = v8;
  *(_QWORD *)(a1 + 16) = v9;
  *(float *)(a1 + 24) = a4;
  *(_BYTE *)(a1 + 28) = v10;
  *(_BYTE *)(a1 + 29) = v11;
  v14 = *(_BYTE *)(a1 + 30) & 0xFE | (v13 >> 1) & 1;
  *(_BYTE *)(a1 + 30) = *(_BYTE *)(a1 + 30) & 0xFE | ((v13 & 2) != 0);
  LOBYTE(v13) = v14 & 0xF1 | (2 * (*(_BYTE *)(*(_QWORD *)a2 + 283) != 0));
  *(_BYTE *)(a1 + 30) = v13;
  *(_BYTE *)(a1 + 30) = v13 & 0xF7 | (8 * ((*(_BYTE *)(a3 + 40) & 4) != 0));
  return a1;
}

unint64_t RB::color_space_to_srgb(unsigned int a1)
{
  unint64_t v1;

  v1 = 0x10001000100uLL >> (8 * a1);
  if (a1 >= 6)
    LOBYTE(v1) = 0;
  return v1 & 1;
}

void sub_209AEAE34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v14;

  MEMORY[0x20BD16544](v12, 0x10A0C4070508A9ALL);
  v14 = a12;
  a12 = 0;
  if (v14)
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a12, v14);
  _Unwind_Resume(a1);
}

void sub_209AEAFC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::Fill::Color::matches(float16x4_t *this, float16x4_t *a2, uint16x4_t a3)
{
  float32x4_t v3;
  float32x4_t v4;
  int8x16_t v6;
  unsigned int v7;
  int v8;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v18;

  v3 = vcvtq_f32_f16(*this);
  v4.i64[0] = 0xC7000000C7000000;
  v4.i64[1] = 0xC7000000C7000000;
  if ((vminvq_u32((uint32x4_t)vceqq_f32(v3, v4)) & 0x80000000) != 0)
    return 1;
  v6 = (int8x16_t)v3;
  if (a2[1].i8[1])
  {
    v7 = this[1].u16[0];
    v6 = (int8x16_t)v3;
    if (v7 >= 0x100)
    {
      v8 = a2[1].u8[0];
      v6 = (int8x16_t)v3;
      if (v8 != v7)
      {
        a3.i16[2] = this->i16[2];
        v18 = v3;
        a3.i32[0] = this->i32[0];
        _D0 = RB::Fill::Color::convert_color((RB::Shader::Tables *)this[1].i16[0], v8, a3);
        v3 = v18;
        __asm { FCVT            S1, H0 }
        v6 = vextq_s8(vextq_s8(_Q1, _Q1, 4uLL), (int8x16_t)vcvtq_f32_f16((float16x4_t)vext_s8(*(int8x8_t *)&_D0, *(int8x8_t *)&_D0, 2uLL)), 0xCuLL);
        v6.i32[3] = v18.i32[3];
      }
    }
  }
  v15.i64[0] = 0xC7000000C7000000;
  v15.i64[1] = 0xC7000000C7000000;
  v16 = vcvtq_f32_f16(*a2);
  return vminvq_u32((uint32x4_t)vcgtq_f32((float32x4_t)vdupq_n_s32(0x3B008081u), vabdq_f32((float32x4_t)vbslq_s8((int8x16_t)vceqq_f32(v3, v15), (int8x16_t)v16, v6), v16))) >> 31;
}

char **RB::vector<RB::SharedSurfaceGroup::render_updates_device(void)::SurfaceData,0ul,unsigned int>::~vector(char **a1)
{
  char *v2;
  unint64_t v3;
  char *v4;
  _QWORD *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  char *v11;
  void **v12;
  char *v13;
  void **v14;
  unint64_t v15;
  void *v16;
  unsigned int *v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;

  v2 = *a1;
  if (*((_DWORD *)a1 + 2))
  {
    v3 = 0;
    do
    {
      v4 = &v2[40 * v3];
      v5 = (_QWORD *)*((_QWORD *)v4 + 3);
      if (*((_DWORD *)v4 + 8))
      {
        v6 = 0;
        do
        {
          v7 = (unsigned int *)v5[6 * v6];
          if (v7)
          {
            v8 = v7 + 2;
            do
            {
              v9 = __ldxr(v8);
              v10 = v9 - 1;
            }
            while (__stlxr(v10, v8));
            if (!v10)
            {
              __dmb(9u);
              (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
            }
          }
          ++v6;
        }
        while (v6 < *((unsigned int *)v4 + 8));
        v5 = (_QWORD *)*((_QWORD *)v4 + 3);
      }
      if (v5)
        free(v5);
      v11 = &v2[40 * v3];
      v14 = (void **)*((_QWORD *)v11 + 1);
      v13 = v11 + 8;
      v12 = v14;
      if (*((_DWORD *)v13 + 2))
      {
        v15 = 0;
        do
        {
          v16 = *v12;
          v12 += 8;

          ++v15;
        }
        while (v15 < *((unsigned int *)v13 + 2));
        v12 = *(void ***)v13;
      }
      if (v12)
        free(v12);
      v17 = *(unsigned int **)v4;
      if (*(_QWORD *)v4)
      {
        v18 = v17 + 2;
        do
        {
          v19 = __ldxr(v18);
          v20 = v19 - 1;
        }
        while (__stlxr(v20, v18));
        if (!v20)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v17 + 8))(v17);
        }
      }
      ++v3;
    }
    while (v3 < *((unsigned int *)a1 + 2));
    v2 = *a1;
  }
  if (v2)
    free(v2);
  return a1;
}

void RB::SharedSurfaceGroup::render_updates(RB::SharedSurfaceGroup *this)
{
  os_unfair_lock_s *v2;
  _QWORD *i;
  os_unfair_lock_s *v4;
  uint64_t v5;
  int v6;

  v2 = (os_unfair_lock_s *)((char *)this + 16);
  os_unfair_lock_lock((os_unfair_lock_t)this + 4);
  for (i = (_QWORD *)*((_QWORD *)this + 4); ; i = (_QWORD *)i[1])
  {
    if (i == (_QWORD *)((char *)this + 24))
    {
      os_unfair_lock_unlock(v2);
      return;
    }
    v4 = (os_unfair_lock_s *)(i[2] + 112);
    os_unfair_lock_lock(v4);
    v5 = i[2];
    if (*(_BYTE *)(v5 + 172) || *(_DWORD *)(v5 + 128))
      break;
    v6 = *(_DWORD *)(v5 + 144);
    os_unfair_lock_unlock(v4);
    if (v6)
      goto LABEL_9;
  }
  os_unfair_lock_unlock(v4);
LABEL_9:
  os_unfair_lock_unlock(v2);
  RB::Drawable::begin_frame(*((RB::Drawable **)this + 1));
  dispatch_sync_f(*(dispatch_queue_t *)(*(_QWORD *)this + 32), this, (dispatch_function_t)RB::SharedSurfaceGroup::render_updates(void)::$_0::__invoke);
}

NSObject *RB::Drawable::begin_frame(RB::Drawable *this)
{
  NSObject *result;

  result = *((_QWORD *)this + 2);
  if (result)
    return dispatch_semaphore_wait(result, 0xFFFFFFFFFFFFFFFFLL);
  return result;
}

void sub_209AEB3A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

RB::ContextDelegate *RB::ContextDelegate::ContextDelegate(RB::ContextDelegate *this)
{
  *(_QWORD *)this = &off_24C228D38;
  *((_QWORD *)this + 1) = objc_opt_new();
  *((_QWORD *)this + 2) = objc_opt_new();
  *((_QWORD *)this + 44) = 0;
  *((_QWORD *)this + 45) = 0;
  *((_QWORD *)this + 46) = 4;
  *((_OWORD *)this + 24) = xmmword_209BD5290;
  *((_OWORD *)this + 25) = xmmword_209BD52A0;
  *((_OWORD *)this + 26) = 0u;
  *((_OWORD *)this + 30) = xmmword_209BD5290;
  *((_OWORD *)this + 31) = xmmword_209BD52A0;
  *((_OWORD *)this + 32) = 0u;
  *((_QWORD *)this + 67) = 0;
  *((_QWORD *)this + 69) = 0;
  *((_QWORD *)this + 68) = 0;
  return this;
}

void sub_209AEB444(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void RB::Drawable::reset_statistics(os_unfair_lock_s *this, uint64_t a2, double a3)
{
  os_unfair_lock_s *v6;
  BOOL v7;
  double v8;
  double *p_os_unfair_lock_opaque;

  v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  v7 = a3 <= 1.0 && a3 > 0.0;
  v8 = 0.1;
  *(_QWORD *)&this[10]._os_unfair_lock_opaque = a2;
  p_os_unfair_lock_opaque = (double *)&this[10]._os_unfair_lock_opaque;
  if (v7)
    v8 = a3;
  p_os_unfair_lock_opaque[1] = v8;
  *((_OWORD *)p_os_unfair_lock_opaque + 1) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 2) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 3) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 4) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 5) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 6) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 7) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 8) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 9) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 10) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 11) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 12) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 13) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 14) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 15) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 16) = 0u;
  *((_OWORD *)p_os_unfair_lock_opaque + 17) = 0u;
  os_unfair_lock_unlock(v6);
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::moveto(uint64_t a1, float64x2_t a2)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::moveto(a1 + 8, (uint64_t *)(a1 + 136), COERCE_DOUBLE(vcvt_f32_f64(a2)));
}

uint64_t RB::Stroke::flatten_points(RBPath,RB::AffineTransform const&,RB::Stroke::LineConsumer<RB::Stroke::Point> &,RB::Rect,float,RB::LineCap,RB::LineJoin,float,unsigned long,float const*,float,float)::Adaptor::lineto(uint64_t a1, float64x2_t a2)
{
  return RB::Stroke::Flattener<RB::Stroke::Point>::lineto(a1 + 8, (_QWORD *)(a1 + 136), COERCE_DOUBLE(vcvt_f32_f64(a2)));
}

uint64_t RBSymbolUpdateLayerColorName(_QWORD *a1)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v1 = *(_DWORD *)(*a1 + 848) + ~*((_DWORD *)a1 + 2);
  v2 = *(_QWORD *)(*a1 + 840);
  if (!v2)
    v2 = *a1 + 8;
  v3 = a1[2];
  v4 = *(_QWORD **)(v2 + 416 * v1 + 400);
  if (v4)
    LODWORD(v3) = *(_DWORD *)(*v4 + 8 * a1[2]);
  v5 = v2 + 416 * v1;
  v6 = v5 + 16;
  v7 = *(_QWORD *)(v5 + 376);
  if (!v7)
    v7 = v6;
  v8 = *(_QWORD *)(v7 + 120 * v3);
  if ((*(_DWORD *)(v8 + 84) & 0xF00) == 0x900)
    return *(_QWORD *)(v8 + 8);
  else
    return 0;
}

uint64_t __copy_helper_block_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  unsigned int *v3;
  unsigned int v4;

  v2 = *(_QWORD *)(a2 + 32);
  if (v2)
  {
    v3 = (unsigned int *)(v2 + 8);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  *(_QWORD *)(result + 32) = v2;
  return result;
}

void ___Z22RBXMLRecorderInstalledv_block_invoke(uint64_t a1, const char *a2)
{
  uint64_t v2;
  const char *v3;
  int v4;
  NSString *v5;
  NSObject *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  unsigned int v11;
  NSString *v12;
  NSString *v13;
  RB *v14;
  NSObject *v15;
  uint8_t buf[4];
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v2 = RB::debug_int((RB *)"RB_XML_RECORDER", a2);
  if ((v2 & 0xFF00000000) != 0)
    v4 = v2;
  else
    v4 = 0;
  if (v4 >= 1)
  {
    RB::XMLRecorder::installed = 1;
    std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"RBXMLRecorder installed.\n", 25);
    if (v4 != 1)
    {
      RBXMLRecorderStart();
      if (RB::XMLRecorder::enabled)
        std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"RBXMLRecorder logging enabled.\n", 31);
      if (v4 >= 3)
      {
        if (os_variant_has_internal_diagnostics())
        {
          v5 = NSTemporaryDirectory();
          RB::XMLRecorder::log_file = -[NSString copy](-[NSString stringByAppendingPathComponent:](v5, "stringByAppendingPathComponent:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("rb-xml-%d.txt"), getpid())), "copy");
          v6 = RB::misc_log((RB *)RB::XMLRecorder::log_file);
          if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 138412290;
            v17 = RB::XMLRecorder::log_file;
            _os_log_impl(&dword_209ACA000, v6, OS_LOG_TYPE_DEFAULT, "Logging RenderBox frames to %@", buf, 0xCu);
          }
        }
      }
    }
  }
  v7 = RB::debug_string((RB *)"RB_XML_SAVE_IMAGES", v3);
  if (v7)
  {
    if (*v7 == 47)
    {
      v8 = objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithUTF8String:", v7);
      goto LABEL_17;
    }
    if (atoi(v7))
    {
      v9 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("rb-xml-%d"), getpid());
      v8 = -[NSString copy](-[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", v9), "copy");
LABEL_17:
      RB::XMLRecorder::resource_path = v8;
      if (!v8)
        goto LABEL_19;
      goto LABEL_18;
    }
    if (RB::XMLRecorder::resource_path)
LABEL_18:
      RB::XMLRecorder::image_names = objc_opt_new();
  }
LABEL_19:
  if (os_variant_has_internal_diagnostics())
  {
    v11 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_REDIRECT_OUTPUT", v10);
    if (v11 <= 0x100)
      LOBYTE(v11) = 0;
    if ((_BYTE)v11)
    {
      v12 = NSTemporaryDirectory();
      v13 = -[NSString stringByAppendingPathComponent:](v12, "stringByAppendingPathComponent:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("rb-log-%d.txt"), getpid()));
      close(1);
      openat(1, -[NSString UTF8String](v13, "UTF8String"), 521, 420);
      close(2);
      dup2(1, 2);
      setlinebuf((FILE *)*MEMORY[0x24BDAC8E8]);
      v14 = (RB *)setlinebuf((FILE *)*MEMORY[0x24BDAC8D8]);
      v15 = RB::misc_log(v14);
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 138412290;
        v17 = (uint64_t)v13;
        _os_log_impl(&dword_209ACA000, v15, OS_LOG_TYPE_DEFAULT, "Redirected output to %@", buf, 0xCu);
      }
    }
  }
}

char *RB::debug_string(RB *this, const char *a2)
{
  RB::Config *v2;
  const void *v3;
  char *v4;
  RB::Config *v6;

  RB::Config::debug_value(this, &v6);
  v2 = v6;
  v4 = RB::Config::string_value(v6, v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

char *RB::Config::string_value(RB::Config *this, const void *a2)
{
  char *result;
  const __CFString *v3;
  CFTypeID v4;
  char buffer[4096];
  uint64_t v6;

  result = (char *)MEMORY[0x24BDAC7A8](this, a2);
  v6 = *MEMORY[0x24BDAC8D0];
  if (result)
  {
    v3 = (const __CFString *)result;
    v4 = CFGetTypeID(result);
    if (v4 != CFStringGetTypeID())
      return 0;
    result = (char *)CFStringGetCStringPtr(v3, 0x8000100u);
    if (result)
      return result;
    if (CFStringGetCString(v3, buffer, 4096, 0x8000100u))
      return strdup(buffer);
    else
      return 0;
  }
  return result;
}

uint64_t RB::Device::Device(uint64_t a1, uint64_t a2, void *a3)
{
  NSObject *v4;
  NSObject *v5;
  unsigned __int8 *v6;
  unsigned __int8 *v7;
  const char **v8;
  uint64_t i;
  const char *v10;
  unsigned __int16 v11;
  const char *v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  _QWORD *v22;
  char *v23;
  const void *v24;
  uint64_t v25;
  const char *v26;
  unsigned __int16 v27;
  const char *v28;
  BOOL v29;
  char v30;
  __int16 v31;
  const char *v32;
  int v33;
  char v34;
  uint64_t v35;
  unsigned __int16 v36;
  const char *v37;
  char v38;
  unsigned __int16 v39;
  const char *v40;
  BOOL v41;
  uint64_t v42;
  const char *v43;
  unsigned __int16 v44;
  char v45;
  RB::SharedSurfaceGroup *v46;
  const char *v47;
  unint64_t v48;
  unsigned __int8 v49;
  FILE *v50;
  const char *v51;
  const char *v52;
  const char *v53;
  const char *v54;
  const char *v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  id v64;
  char __str[16];
  __int128 v66;
  __int128 v67;
  uint64_t v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_24C2296E8;
  *(_QWORD *)(a1 + 16) = a2;
  v64 = a3;
  *(_QWORD *)(a1 + 24) = a3;
  v4 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  *(_QWORD *)(a1 + 32) = dispatch_queue_create("com.apple.RenderBox.Device", v4);
  v5 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INTERACTIVE, 0);
  *(_QWORD *)(a1 + 40) = dispatch_queue_create("com.apple.RenderBox.Encoder", v5);
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 112) = 0u;
  *(_OWORD *)(a1 + 128) = 0u;
  *(_OWORD *)(a1 + 144) = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_DWORD *)(a1 + 192) = 0;
  *(_QWORD *)(a1 + 264) = 2;
  *(_QWORD *)(a1 + 272) = RB::debug_byte_size((RB *)"RB_BUFFER_SIZE", (const char *)0x10000, 0x4000uLL, 0x400000uLL);
  *(_WORD *)(a1 + 280) = 256;
  *(_BYTE *)(a1 + 282) = 1;
  v6 = (unsigned __int8 *)(a1 + 283);
  *(_BYTE *)(a1 + 287) = 0;
  *(_DWORD *)(a1 + 283) = 0;
  *(_QWORD *)(a1 + 288) = 0x2000;
  *(_BYTE *)(a1 + 296) = 0;
  RB::Heap::Heap((RB::Heap *)(a1 + 304), 0, 0, 0x400uLL);
  *(_QWORD *)(a1 + 344) = a1 + 344;
  *(_QWORD *)(a1 + 352) = a1 + 344;
  *(_QWORD *)(a1 + 360) = 0;
  *(_QWORD *)(a1 + 368) = 0;
  *(_QWORD *)(a1 + 376) = a1 + 376;
  *(_QWORD *)(a1 + 384) = a1 + 376;
  *(_QWORD *)(a1 + 392) = 0;
  *(_QWORD *)(a1 + 400) = a1 + 400;
  *(_QWORD *)(a1 + 416) = 0;
  *(_QWORD *)(a1 + 424) = 0;
  *(_QWORD *)(a1 + 408) = a1 + 400;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 432), (unint64_t (*)(RB *, const void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_0::__invoke<RB::FormattedRenderState const*>, (BOOL (*)(RB *, RB *, const void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_1::__invoke<RB::FormattedRenderState const*,RB::FormattedRenderState const>, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_2::__invoke<RB::Device::RenderPipelineEntry *>, (RB::Heap *)(a1 + 304));
  *(_OWORD *)(a1 + 512) = 0u;
  *(_OWORD *)(a1 + 528) = 0u;
  *(_DWORD *)(a1 + 544) = 1065353216;
  *(_WORD *)(a1 + 552) = 0;
  *(_OWORD *)(a1 + 560) = 0u;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_OWORD *)(a1 + 592) = 0u;
  *(_OWORD *)(a1 + 608) = 0u;
  *(_OWORD *)(a1 + 624) = 0u;
  *(_OWORD *)(a1 + 640) = 0u;
  *(_OWORD *)(a1 + 656) = 0u;
  *(_OWORD *)(a1 + 672) = 0u;
  *(_OWORD *)(a1 + 688) = 0u;
  *(_OWORD *)(a1 + 704) = 0u;
  *(_OWORD *)(a1 + 720) = 0u;
  *(_OWORD *)(a1 + 736) = 0u;
  *(_OWORD *)(a1 + 752) = 0u;
  *(_OWORD *)(a1 + 768) = 0u;
  *(_OWORD *)(a1 + 784) = 0u;
  v62 = a1 + 800;
  v63 = a1 + 432;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 800), 0, 0, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_3::__invoke<RB::TextureCache *>, (RB::Heap *)(a1 + 304));
  v60 = a1 + 400;
  v61 = a1 + 376;
  v59 = a1 + 880;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 880), 0, 0, 0, (void (*)(void *))RB::Device::Device(RBDevice *,objc_object  {objcproto9MTLDevice}*)::$_4::__invoke, (RB::Heap *)(a1 + 304));
  v7 = (unsigned __int8 *)(a1 + 292);
  v57 = a1 + 960;
  v58 = a1 + 344;
  v8 = (const char **)(a1 + 976);
  *(_QWORD *)(a1 + 976) = 0;
  *(_OWORD *)(a1 + 960) = 0u;
  for (i = 1001; i != 1008; ++i)
  {
    if ((objc_msgSend(*(id *)(a1 + 24), "supportsFamily:", i, v57, v58, v59, v60, v61, v62, v63) & 1) == 0)
      break;
    *v6 = i + 24;
  }
  v11 = RB::debug_BOOL((RB *)"RB_USE_BINARY_ARCHIVE", v10);
  if (v11 >= 0x100u)
    v13 = v11 != 0;
  else
    v13 = objc_msgSend((id)objc_msgSend(MEMORY[0x24BDDD500], "sharedCaptureManager"), "supportsDestination:", 2) ^ 1;
  *(_BYTE *)(a1 + 282) = v13;
  v14 = RB::debug_BOOL((RB *)"RB_LOG_PIPELINES", v12);
  v16 = v14;
  v17 = 256;
  if ((unsigned __int16)v14 <= 0x100u)
    v16 = 0;
  *(_BYTE *)(a1 + 552) = v16 != 0;
  v18 = -4;
  if (*(_BYTE *)(a1 + 283))
    v17 = 4;
  else
    v18 = -256;
  v19 = (v17 + 7) & v18;
  v20 = (v19 + v17 + 16) & v18;
  MEMORY[0x24BDAC7A8](v14, v15);
  v22 = (uint64_t *)((char *)&v57 - v21);
  bzero((char *)&v57 - v21, v20 + 8);
  *v22 = 0x3000200000001;
  v23 = (char *)v22 + v19;
  *(_OWORD *)v23 = xmmword_209BD7B30;
  *((_DWORD *)v23 + 4) = 4;
  *(_QWORD *)((char *)v22 + v20) = 0x7000600040005;
  v25 = RB::Buffer::alloc((id *)a1, (RB::Device *)(v20 + 8), (uint64_t)v22, v24);
  if (!v25)
    RB::precondition_failure((RB *)"unable to create quad buffer", v26);
  *(_QWORD *)(a1 + 80) = v25;
  *(_OWORD *)(a1 + 88) = xmmword_209BD7B40;
  *(_QWORD *)(a1 + 104) = v25;
  *(_QWORD *)(a1 + 112) = v19;
  *(_QWORD *)(a1 + 120) = 20;
  *(_QWORD *)(a1 + 128) = v25;
  *(_QWORD *)(a1 + 136) = v20;
  *(_QWORD *)(a1 + 144) = 8;
  v27 = RB::debug_BOOL((RB *)"RB_STENCIL_BUFFER", v26);
  if ((_BYTE)v27)
    v29 = 0;
  else
    v29 = v27 >= 0x100u;
  v30 = !v29;
  *(_BYTE *)(a1 + 281) = v30;
  v31 = RB::debug_BOOL((RB *)"RB_DEPTH_BUFFER", v28);
  v33 = *(unsigned __int8 *)(a1 + 283);
  if ((v31 & 0xFF00) != 0)
    v34 = v31;
  else
    v34 = *(_BYTE *)(a1 + 283);
  *(_BYTE *)(a1 + 280) = v34 != 0;
  if (v33)
  {
    v35 = 0;
    *(_BYTE *)(a1 + 284) = 1;
    while (1)
    {
      v68 = 0;
      v66 = 0u;
      v67 = 0u;
      *(_OWORD *)__str = 0u;
      MTLPixelFormatGetInfoForDevice();
      if ((__str[8] & 2) == 0)
        break;
      v35 += 8;
      if (v35 == 24)
        goto LABEL_28;
    }
    *(_BYTE *)(a1 + 284) = 0;
  }
LABEL_28:
  v36 = RB::debug_BOOL((RB *)"RB_FRAGMENT_WRITES", v32);
  if (v36 >= 0x100u)
  {
    v38 = v36 != 0;
  }
  else if (*v6 <= 3u)
  {
    v38 = objc_msgSend(*(id *)(a1 + 24), "supportsFamily:", 3003);
  }
  else
  {
    v38 = 1;
  }
  *(_BYTE *)(a1 + 285) = v38;
  v39 = RB::debug_BOOL((RB *)"RB_TEXTURE_SWIZZLE", v37);
  if (v39 >= 0x100u)
    v41 = v39 != 0;
  else
    v41 = *v6 > 2u;
  *(_BYTE *)(a1 + 286) = v41;
  v42 = RB::debug_int((RB *)"RB_MAX_TEXTURE_SIZE", v40);
  if ((v42 & 0xFF00000000) == 0)
  {
    if (*v6 <= 2u)
      LODWORD(v42) = 0x2000;
    else
      LODWORD(v42) = 0x4000;
  }
  *(_DWORD *)(a1 + 288) = v42;
  v44 = RB::debug_BOOL((RB *)"RB_FUNCTION_POINTERS", v43);
  if (v44 >= 0x100u)
  {
    v45 = v44 != 0;
  }
  else if (*v6 < 6u)
  {
    v45 = 0;
  }
  else
  {
    v45 = objc_msgSend(v64, "supportsFunctionPointersFromRender");
  }
  *(_BYTE *)(a1 + 287) = v45;
  v46 = (RB::SharedSurfaceGroup *)operator new();
  RB::SharedSurfaceGroup::SharedSurfaceGroup(v46, (RB::Device *)a1);
  v47 = *v8;
  *v8 = (const char *)v46;
  if (v47)
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100](a1 + 976, (uint64_t)v47);
  v48 = RB::debug_int((RB *)"RB_DEBUG_ERRORS", v47);
  if ((v48 & 0xFF00000000) != 0)
  {
    do
      v49 = __ldxr(v7);
    while (__stxr(v49 | v48, v7));
  }
  if (RB::verbose_mode((RB *)v48))
  {
    if (*v6)
      snprintf(__str, 0x20uLL, "%d", *v6);
    v50 = (FILE *)*MEMORY[0x24BDAC8D8];
    v51 = (const char *)objc_msgSend((id)objc_msgSend(v64, "vendorName"), "UTF8String");
    v52 = "memoryless ";
    v53 = "";
    if (!*(_BYTE *)(a1 + 283))
      v52 = "";
    v54 = "fragment-writes ";
    if (!*(_BYTE *)(a1 + 285))
      v54 = "";
    if (*(unsigned __int8 *)(a1 + 283) <= 2u)
      v55 = "";
    else
      v55 = "xr10-formats ";
    if (*(_BYTE *)(a1 + 284))
      v53 = "16bpp-formats";
    fprintf(v50, "RBDevice %p, vendor %s%s %s%s%s%s%s\n", (const void *)a1, v51, __str, v52, "fb-read ", v54, v55, v53);
  }
  return a1;
}

void sub_209AEC16C(_Unwind_Exception *a1)
{
  uint64_t v1;
  RB::Heap *v2;
  uint64_t *v3;
  uint64_t v4;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t i;
  uint64_t j;
  _DWORD *v12;
  int v13;
  _DWORD *v14;
  int v15;
  _DWORD *v16;
  int v17;

  v6 = *v3;
  *v3 = 0;
  v7 = *(uint64_t **)(v4 - 200);
  if (v6)
    std::default_delete<RB::SharedSurfaceGroup>::operator()[abi:nn180100]((uint64_t)v3, v6);
  std::unique_ptr<RB::GlyphPathCache>::reset[abi:nn180100](*(uint64_t **)(v4 - 208), 0);
  RB::UntypedTable::~UntypedTable(*(RB::UntypedTable **)(v4 - 192));
  RB::UntypedTable::~UntypedTable(*(RB::UntypedTable **)(v4 - 168));
  v9 = *(uint64_t **)(v4 - 184);
  v8 = *(uint64_t **)(v4 - 176);
  for (i = 0; i != -192; i -= 8)

  for (j = 0; j != -48; j -= 8)
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(v1 + 512);
  RB::UntypedTable::~UntypedTable(*(RB::UntypedTable **)(v4 - 160));
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v9);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v8);
  std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear(v7);
  RB::Heap::~Heap(v2);
  RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector((char *)(v1 + 200));
  v12 = *(_DWORD **)(v1 + 176);
  if (v12)
  {
    v13 = v12[2] - 1;
    v12[2] = v13;
    if (!v13)
      (*(void (**)(_DWORD *))(*(_QWORD *)v12 + 8))(v12);
  }
  v14 = *(_DWORD **)(v1 + 168);
  if (v14)
  {
    v15 = v14[2] - 1;
    v14[2] = v15;
    if (!v15)
      (*(void (**)(_DWORD *))(*(_QWORD *)v14 + 8))(v14);
  }
  v16 = *(_DWORD **)(v1 + 160);
  if (v16)
  {
    v17 = v16[2] - 1;
    v16[2] = v17;
    if (!v17)
      (*(void (**)(_DWORD *))(*(_QWORD *)v16 + 8))(v16);
  }

  _Unwind_Resume(a1);
}

uint64_t RB::debug_BOOL(RB *this, const char *a2)
{
  RB::Config *v2;
  const void *v3;
  uint64_t v4;
  _BOOL4 v5;
  RB::Config *v7;

  RB::Config::debug_value(this, &v7);
  v2 = v7;
  v4 = RB::Config::int_value((const __CFString *)v7, v3);
  if (v2)
    CFRelease(v2);
  if ((_DWORD)v4)
    v5 = (v4 & 0xFF00000000) != 0;
  else
    v5 = 0;
  return v5 | (((v4 & 0xFF00000000) != 0) << 8);
}

uint64_t RB::debug_int(RB *this, const char *a2)
{
  RB::Config *v2;
  const void *v3;
  uint64_t v4;
  RB::Config *v6;

  RB::Config::debug_value(this, &v6);
  v2 = v6;
  v4 = RB::Config::int_value((const __CFString *)v6, v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

uint64_t RB::Config::int_value(const __CFString *this, const void *a2)
{
  CFTypeID v3;
  Boolean Value;
  unsigned int v5;
  uint64_t v6;
  int CharacterAtIndex;
  SInt32 IntValue;
  int valuePtr;

  if (!this)
    goto LABEL_19;
  v3 = CFGetTypeID(this);
  if (v3 != CFBooleanGetTypeID())
  {
    if (v3 == CFNumberGetTypeID())
    {
      valuePtr = 0;
      if (CFNumberGetValue((CFNumberRef)this, kCFNumberIntType, &valuePtr))
      {
        Value = valuePtr;
        v5 = valuePtr & 0xFFFFFF00;
        goto LABEL_8;
      }
    }
    else if (v3 == CFStringGetTypeID())
    {
      Value = 1;
      if (CFStringCompare(this, CFSTR("yes"), 1uLL) == kCFCompareEqualTo)
        goto LABEL_4;
      Value = 1;
      if (CFStringCompare(this, CFSTR("true"), 1uLL) == kCFCompareEqualTo)
      {
        v5 = 0;
        v6 = 0x100000000;
        return v6 | v5 | Value;
      }
      if (CFStringCompare(this, CFSTR("no"), 1uLL) == kCFCompareEqualTo
        || CFStringCompare(this, CFSTR("false"), 1uLL) == kCFCompareEqualTo)
      {
        Value = 0;
        goto LABEL_4;
      }
      if (CFStringGetLength(this) >= 1)
      {
        CharacterAtIndex = CFStringGetCharacterAtIndex(this, 0);
        if (CharacterAtIndex == 43 || CharacterAtIndex == 45 || (CharacterAtIndex - 48) <= 9)
        {
          IntValue = CFStringGetIntValue(this);
          Value = IntValue;
          v5 = IntValue & 0xFFFFFF00;
          goto LABEL_8;
        }
      }
    }
LABEL_19:
    v6 = 0;
    Value = 0;
    v5 = 0;
    return v6 | v5 | Value;
  }
  Value = CFBooleanGetValue((CFBooleanRef)this);
LABEL_4:
  v5 = 0;
LABEL_8:
  v6 = 0x100000000;
  return v6 | v5 | Value;
}

void RB::Config::debug_value(RB::Config *this@<X0>, _QWORD *a2@<X8>)
{
  char *v5;
  const UInt8 *v6;
  size_t v7;
  unsigned __int8 v8;
  const __CFString *v9;
  const __CFString *v10;
  const __CFString *v11;
  CFPropertyListRef v12;
  CFPropertyListRef v13;
  CFStringRef key;

  v5 = getenv((const char *)this);
  if (v5)
  {
    v6 = (const UInt8 *)v5;
    v7 = strlen(v5);
    *a2 = CFStringCreateWithBytesNoCopy(0, v6, v7, 0x8000100u, 1u, (CFAllocatorRef)*MEMORY[0x24BDBD258]);
  }
  else
  {
    {
      RB::Config::debug_value(char const*)::allow_defaults = RB::Config::debug_value(char const*)::$_0::operator()();
    }
    if (RB::Config::debug_value(char const*)::allow_defaults)
    {
      v9 = key;
      v10 = (const __CFString *)*MEMORY[0x24BDBD590];
      v11 = (const __CFString *)*MEMORY[0x24BDBD570];
      v12 = CFPreferencesCopyValue(key, (CFStringRef)*MEMORY[0x24BDBD580], (CFStringRef)*MEMORY[0x24BDBD590], (CFStringRef)*MEMORY[0x24BDBD570]);
      *a2 = v12;
      if (!v12)
      {
        v13 = CFPreferencesCopyValue(v9, (CFStringRef)*MEMORY[0x24BDBD568], v10, v11);
        *a2 = v13;
        if (!v13)
          *a2 = CFPreferencesCopyValue(v9, CFSTR("com.apple.RenderBox"), v10, v11);
      }
      if (v9)
        CFRelease(v9);
    }
    else
    {
      *a2 = 0;
    }
  }
}

BOOL RB::Config::debug_value(char const*)::$_0::operator()()
{
  const __CFString *v0;
  const void *v1;
  uint64_t v2;

  v0 = (const __CFString *)CFPreferencesCopyValue(CFSTR("RBAllowDebuggingDefaults"), (CFStringRef)*MEMORY[0x24BDBD568], (CFStringRef)*MEMORY[0x24BDBD590], (CFStringRef)*MEMORY[0x24BDBD570]);
  v2 = RB::Config::int_value(v0, v1);
  if (v0)
    CFRelease(v0);
  return (v2 & 0xFF00000000) != 0 && (_DWORD)v2 != 0;
}

uint64_t RB::Buffer::alloc(id *this, RB::Device *a2, uint64_t a3, const void *a4)
{
  uint64_t v5;
  void *v6;
  uint64_t v7;

  v5 = objc_msgSend(this[3], "newBufferWithBytes:length:options:", a3, a2, 0);
  if (!v5)
    return 0;
  v6 = (void *)v5;
  v7 = operator new();
  RB::Buffer::Buffer(v7, v6, (uint64_t)a2);
  return v7;
}

void sub_209AEC784(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

uint64_t RB::Buffer::alloc(id *this, RB::Device *a2)
{
  uint64_t v3;
  void *v4;
  uint64_t v5;

  v3 = objc_msgSend(this[3], "newBufferWithLength:options:", a2, 0);
  if (!v3)
    return 0;
  v4 = (void *)v3;
  v5 = operator new();
  RB::Buffer::Buffer(v5, v4, (uint64_t)a2);
  return v5;
}

void sub_209AEC818(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C40C08ACA79);
  _Unwind_Resume(a1);
}

uint64_t RB::Buffer::Buffer(uint64_t a1, void *a2, uint64_t a3)
{
  *(_QWORD *)RB::Resource::Resource(a1, (uint64_t)a2) = off_24C2296B8;
  if (!a3)
    a3 = objc_msgSend(a2, "length");
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 56) = objc_msgSend(a2, "contents");
  return a1;
}

void sub_209AEC89C(_Unwind_Exception *a1)
{
  RB::Resource *v1;

  RB::Resource::~Resource(v1);
  _Unwind_Resume(a1);
}

RB::SharedSurfaceGroup *RB::SharedSurfaceGroup::SharedSurfaceGroup(RB::SharedSurfaceGroup *this, RB::Device *a2)
{
  RB::Drawable *v3;

  *(_QWORD *)this = a2;
  v3 = (RB::Drawable *)operator new();
  RB::Drawable::Drawable(v3, 3u);
  *((_QWORD *)this + 1) = v3;
  *((_DWORD *)this + 4) = 0;
  *((_QWORD *)this + 3) = (char *)this + 24;
  *((_QWORD *)this + 4) = (char *)this + 24;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0;
  *(_QWORD *)((char *)this + 54) = 0;
  return this;
}

void sub_209AEC910(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

RB::Drawable *RB::Drawable::Drawable(RB::Drawable *this, intptr_t value)
{
  dispatch_semaphore_t v3;

  *(_QWORD *)this = off_24C229940;
  *((_DWORD *)this + 2) = 1;
  *((_DWORD *)this + 3) = value;
  if ((_DWORD)value)
    v3 = dispatch_semaphore_create(value);
  else
    v3 = 0;
  *((_QWORD *)this + 2) = v3;
  *((_QWORD *)this + 3) = 0;
  *((_DWORD *)this + 8) = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 6) = 0x3FB999999999999ALL;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 104) = 0u;
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_OWORD *)((char *)this + 168) = 0u;
  *(_OWORD *)((char *)this + 184) = 0u;
  *(_OWORD *)((char *)this + 200) = 0u;
  *(_OWORD *)((char *)this + 216) = 0u;
  *(_OWORD *)((char *)this + 232) = 0u;
  *(_OWORD *)((char *)this + 248) = 0u;
  *((_QWORD *)this + 41) = 0;
  *(_OWORD *)((char *)this + 264) = 0u;
  *(_OWORD *)((char *)this + 280) = 0u;
  *(_OWORD *)((char *)this + 296) = 0u;
  *(_OWORD *)((char *)this + 312) = 0u;
  return this;
}

const char *RB::debug_byte_size(RB *this, const char *a2, unint64_t a3, unint64_t a4)
{
  RB::Config *v7;
  const char *v8;
  RB::Config *v10;

  RB::Config::debug_value(this, &v10);
  v7 = v10;
  v8 = RB::Config::byte_size_value((const __CFString *)v10, a2, a3, a4);
  if (v7)
    CFRelease(v7);
  return v8;
}

const char *RB::Config::byte_size_value(const __CFString *this, const char *a2, unint64_t a3, unint64_t a4)
{
  CFTypeID v8;
  _QWORD valuePtr[33];

  valuePtr[32] = *MEMORY[0x24BDAC8D0];
  if (this)
  {
    v8 = CFGetTypeID(this);
    if (v8 == CFNumberGetTypeID())
    {
      valuePtr[0] = 0;
      if (CFNumberGetValue((CFNumberRef)this, kCFNumberLongType, valuePtr))
        return (const char *)valuePtr[0];
    }
    else if (v8 == CFStringGetTypeID() && CFStringGetCString(this, (char *)valuePtr, 256, 0x8000100u))
    {
      return RB::parse_byte_size((RB *)valuePtr, a2, a3, a4);
    }
  }
  return a2;
}

void RB::Device::RenderPipelineEntry::Loader::start_loading(RB::Device::RenderPipelineEntry::Loader *this)
{
  void *v2;
  void *v3;
  uint64_t v4;
  RB *v5;
  RB *v6;
  const char *v7;
  int v8;
  uint64_t v9;
  int v10;
  char v11[20];
  _QWORD v12[2];

  v12[1] = *MEMORY[0x24BDAC8D0];
  if (!*((_QWORD *)this + 6))
  {
    v2 = (void *)MEMORY[0x20BD168EC]();
    v3 = (void *)objc_opt_new();

    v4 = *((_QWORD *)this + 2);
    *((_QWORD *)this + 6) = v3;
    if ((RB::Device::make_render_pipeline_descriptor(v4, *((_DWORD *)this + 6), 0, 0, v3, 0, (id *)this + 7) & 1) != 0)
    {
      if (*((_QWORD *)this + 5))
      {
        v12[0] = *((_QWORD *)this + 5);
        objc_msgSend((id)objc_msgSend(*((id *)this + 6), "fragmentLinkedFunctions"), "setPrivateFunctions:", objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v12, 1));
      }
      RB::Device::RenderPipelineEntry::Loader::load_fn(this, 0);
      *((double *)this + 9) = RB::current_time_seconds(v5);
      if (RB::verbose_mode(v6))
      {
        v7 = RB::RenderState::name((RB::Device::RenderPipelineEntry::Loader *)((char *)this + 16));
        v8 = *((_DWORD *)this + 6);
        v9 = *((_QWORD *)this + 2);
        v10 = v8;
        RB::FormattedRenderState::ID::formatted((uint64_t)&v9, (uint64_t)v11);
        printf("started building render pipeline %s-%s\n", v7, v11);
        fflush((FILE *)*MEMORY[0x24BDAC8E8]);
      }
    }
    else
    {
      RB::Device::RenderPipelineEntry::Loader::finished(this);
    }
    objc_autoreleasePoolPop(v2);
  }
}

void sub_209AECC94(_Unwind_Exception *a1)
{
  void *v1;

  objc_autoreleasePoolPop(v1);
  _Unwind_Resume(a1);
}

void RB::Device::RenderPipelineEntry::Loader::load_fn(RB::Device::RenderPipelineEntry::Loader *this, Function *a2)
{
  int v3;
  __CFString **v4;
  __CFString *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  void *v9;
  _QWORD v10[5];
  int v11;
  _QWORD v12[5];

  while (1)
  {
    v3 = (int)a2;
    v4 = (_DWORD)a2
    v5 = *v4;
    if (*v4)
      break;
    LODWORD(a2) = 1;
    if (v3)
    {
      v6 = *(void **)(*((_QWORD *)this + 1) + 24);
      v7 = *((_QWORD *)this + 6);
      v12[0] = MEMORY[0x24BDAC760];
      v12[1] = 3221225472;
      v12[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader13load_pipelineEv_block_invoke;
      v12[3] = &__block_descriptor_40_e46_v24__0___MTLRenderPipelineState__8__NSError_16l;
      v12[4] = this;
      objc_msgSend(v6, "newRenderPipelineStateWithDescriptor:completionHandler:", v7, v12);
      return;
    }
  }
  v8 = (void *)objc_opt_new();
  objc_msgSend(v8, "setName:", v5);
  if (*((_BYTE *)v4 + 8))
    objc_msgSend(v8, "setConstantValues:", *((_QWORD *)this + 7));
  v9 = (void *)*((_QWORD *)this + 4);
  v10[0] = MEMORY[0x24BDAC760];
  v10[1] = 3221225472;
  v10[2] = ___ZN2RB6Device19RenderPipelineEntry6Loader7load_fnENS2_8FunctionE_block_invoke;
  v10[3] = &__block_descriptor_44_e35_v24__0___MTLFunction__8__NSError_16l;
  v10[4] = this;
  v11 = v3;
  objc_msgSend(v9, "newFunctionWithDescriptor:completionHandler:", v8, v10);

}

void sub_209AECDD8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::RenderFrame::encode(uint64_t a1, uint64_t a2, RB::RenderQueue *this)
{
  id *v6;
  id v7;
  id v8;
  int v9;
  void *v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  char v16[20];
  char __str[8];
  uint64_t v18;
  uint64_t v19;
  __int128 v20;
  id *v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  char v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  BOOL v29;
  BOOL v30;
  BOOL v31;
  char v32;
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v6 = (id *)(a1 + 288);
  if (!*(_QWORD *)(a1 + 288))
  {
    v7 = (id)objc_msgSend(*(id *)(a1 + 16), "renderCommandEncoderWithDescriptor:", *(_QWORD *)(a2 + 8));
    v8 = *(id *)(a1 + 288);
    if (v8 != v7)
    {

      v7 = v7;
      *v6 = v7;
    }
    *(_BYTE *)(a1 + 296) = 0;
    if (*(_QWORD *)(a2 + 16))
      objc_msgSend(v7, "setLabel:");
    if ((*(_BYTE *)(*(_QWORD *)a1 + 292) & 1) != 0)
    {
      v13 = *(_QWORD *)(a2 + 88);
      v9 = *(_DWORD *)(a2 + 80);
      v14 = *(_QWORD *)(a2 + 72);
      v15 = v9;
      RB::FormattedRenderState::ID::formatted((uint64_t)&v14, (uint64_t)v16);
      snprintf(__str, 0x100uLL, "Encoder [%d, %d] %s C:%d D:%d S:%d F:%d", v13, HIDWORD(v13), v16, *(unsigned __int8 *)(a2 + 96), (*(unsigned __int8 *)(a2 + 97) >> 1) & 1, (*(unsigned __int8 *)(a2 + 97) >> 2) & 1, (*(unsigned __int8 *)(a2 + 97) >> 4) & 1);
      v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", __str, 1);
      objc_msgSend(*v6, "insertDebugSignpost:", v10);

    }
    objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(a2 + 8), "colorAttachments"), "objectAtIndexedSubscript:", 0), "setLoadAction:", 1);
  }
  *(_BYTE *)(a1 + 296) |= *(_BYTE *)(a2 + 98);
  if (*(_DWORD *)this)
  {
    RB::RenderQueue::schedule(this, *(_QWORD *)a1, (*(unsigned __int8 *)(a2 + 97) >> 1) & 1);
    *(_QWORD *)__str = *(_QWORD *)a1;
    v18 = *(_QWORD *)(a1 + 84);
    v19 = *(_QWORD *)(a1 + 16);
    v20 = *(_OWORD *)(a2 + 8);
    v11 = *(_QWORD *)(a2 + 72);
    v21 = v6;
    v22 = v11;
    v23 = *(_DWORD *)(a2 + 80);
    v24 = *(_QWORD *)(a2 + 88);
    v25 = *(_BYTE *)(a2 + 96);
    v12 = *(_OWORD *)(a2 + 40);
    v26 = *(_OWORD *)(a2 + 24);
    v27 = v12;
    v28 = *(_OWORD *)(a2 + 56);
    LOBYTE(v11) = *(_BYTE *)(a2 + 97);
    v29 = (v11 & 4) != 0;
    v30 = (v11 & 2) != 0;
    v31 = (v11 & 8) != 0;
    v32 = *(_BYTE *)(a1 + 296);
    RB::RenderQueue::encode((unsigned int *)this, (uint64_t)__str);
    if (*((_DWORD *)this + 1) >= 0x41u)
      free(*((void **)this + 1));
    *(_QWORD *)this = 0;
    *((_QWORD *)this + 1) = 0;
    RB::Heap::reset((RB::RenderQueue *)((char *)this + 16), (char *)this + 56, 8064);
    *(_BYTE *)(a1 + 296) = v32;
  }
  if ((*(_BYTE *)(a2 + 97) & 0x10) != 0)
  {
    if (*v6)
    {
      objc_msgSend(*v6, "endEncoding");

      *v6 = 0;
    }
  }
}

void sub_209AED06C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::RenderQueue::schedule(RB::RenderQueue *this, size_t size, int a3)
{
  RB::RenderQueue *v4;
  unsigned __int8 v5;
  unsigned __int8 v6;
  unsigned int v7;
  uint64_t v8;
  unsigned int v9;
  size_t v10;
  char *v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  unint64_t v21;
  unsigned __int8 *v22;
  int v23;
  int v24;
  char *v25;
  int v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  char v32;
  char v33;
  BOOL v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  unint64_t v47;
  unsigned __int8 *v48;
  int v49;
  int v50;
  char *v51;
  uint64_t v52;
  int v53;
  int v54;
  int *v55;
  uint64_t v56;
  int v57;
  uint64_t v58;
  unint64_t v59;
  unsigned __int8 *v60;
  int v61;
  int v62;
  char *v63;
  unsigned int v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  char *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  char *v72;
  char *v73;
  int v74;
  char *v75;
  int32x2_t **v76;
  _WORD *v77;
  unint64_t v78;
  int v79;
  int32x2_t v80;
  int32x2_t v81;
  char *v82;
  int v83;
  int v84;
  int32x2_t *v85;
  int32x4_t v86;
  uint64_t v87;
  int32x2_t *v88;
  unint64_t v89;
  int32x2_t *v90;
  unint64_t v91;
  uint64_t v92;
  unint64_t v93;
  char *v94;
  int32x2_t *v95;
  int32x4_t v96;
  __int16 v97;
  uint64_t v98;
  char *v99;
  int32x2_t **v100;
  BOOL v101;
  char *v102;
  uint64_t v103;
  int v104;
  uint64_t v105;
  char *v106;
  char *v107;
  int v108;
  int32x2_t **v109;
  _WORD *v110;
  int32x2_t *v111;
  int32x2_t v112;
  int32x2_t v113;
  unsigned int v114;
  int v115;
  uint64_t v116;
  unint64_t v117;
  int32x2_t **v118;
  int32x4_t v119;
  unsigned __int8 v120;
  int32x2_t *v121;
  uint64_t v122;
  unint64_t v123;
  char *v124;
  char *v125;
  uint64_t v126;
  uint64_t v127;
  int32x2_t *v128;
  int32x4_t v129;
  BOOL v130;
  unsigned int v131;
  __int16 v132;
  char *v133;
  uint64_t v134;
  __int128 v135;
  uint64_t v136;
  char *v137;
  char *v138;
  char *v139;
  uint64_t v140;
  char *v141;
  uint64_t v142;
  unsigned int v143;
  const char *v144;
  const char *v146;
  uint64_t v147;
  int v148;
  const char *v149;
  uint64_t v150;
  int v151;
  uint64_t v152;
  uint64_t v153;
  char *v154;
  char *v155;
  char *v156;
  int32x2_t *v157;
  int v158;
  uint64_t v159;

  v4 = this;
  v159 = *MEMORY[0x24BDAC8D0];
  if ((v5 & 1) == 0)
  {
    if ((_DWORD)this)
    {
      v147 = RB::debug_int((RB *)"RB_SCHEDULER", v146);
      if (*(_BYTE *)(size + 283))
        v148 = 5;
      else
        v148 = 7;
      if ((v147 & 0xFF00000000) != 0)
        v148 = v147;
      RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes = v148;
    }
  }
  if ((v6 & 1) == 0)
  {
    if ((_DWORD)this)
    {
      v150 = RB::debug_int((RB *)"RB_PRINT_QUEUE", v149);
      if ((v150 & 0xFF00000000) != 0)
        v151 = v150;
      else
        v151 = 0;
      RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity = v151;
    }
  }
  v7 = RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes;
  if (!a3)
    v7 = RB::RenderQueue::schedule(RB::Device *,BOOL)::default_enabled_passes & 0xFFFFFFFE;
  v8 = *(unsigned int *)v4;
  if (v8 >= 2)
    v9 = v7;
  else
    v9 = 0;
  if (!(v9 | RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity))
    return;
  if (v8 > 0x800)
  {
    v11 = (char *)malloc_type_malloc(16 * v8, 0xE1815A1EuLL);
    if (!v11)
      goto LABEL_169;
  }
  else
  {
    MEMORY[0x24BDAC7A8](this, 16 * v8);
    v11 = (char *)&v152 - ((v10 + 15) & 0x1FFFFFFFF0);
    bzero(v11, v10);
  }
  v12 = *(unsigned int *)v4;
  v153 = v8;
  if ((v9 & 1) != 0)
  {
    v26 = 0;
    if (v12)
    {
      v27 = 0;
      v28 = v12;
      do
      {
        if (v27 >= v12)
        {
          v29 = 0;
        }
        else
        {
          v29 = 0;
          v30 = v27;
          while (1)
          {
            v31 = *(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v30);
            v32 = *(_BYTE *)(v31 + 48);
            *(_BYTE *)(v31 + 48) = v32 & 0xFD;
            if ((*(_DWORD *)v31 & 0x3F) == 0x26)
              break;
            v33 = *(_BYTE *)(v31 + 40);
            if (v33)
              v34 = 0;
            else
              v34 = *(_BYTE *)(v31 + 41) == 2;
            if (v34)
            {
              *(_BYTE *)(v31 + 45) = 2;
              *(_WORD *)(v31 + 40) = 8736;
              *(_BYTE *)(v31 + 48) = v32 | 2;
              ++v29;
            }
            else if (!*(_BYTE *)(v31 + 45))
            {
              *(_BYTE *)(v31 + 45) = 1;
              *(_BYTE *)(v31 + 40) = v33 | 0x20;
            }
            if (++v30 >= *(unsigned int *)v4)
              goto LABEL_47;
          }
          v28 = v30;
        }
LABEL_47:
        if (v27 < v28)
        {
          v35 = v29 + v27;
          v36 = v29 + v27;
          do
          {
            v37 = *(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v27);
            v38 = v35 - 1;
            if ((*(_BYTE *)(v37 + 48) & 2) != 0)
              v39 = v36;
            else
              v39 = v36 + 1;
            if ((*(_BYTE *)(v37 + 48) & 2) != 0)
              --v35;
            else
              v38 = v36;
            if ((*(_BYTE *)(v37 + 48) & 2) != 0)
              v40 = -(int)v27;
            else
              LOWORD(v40) = v27;
            v41 = 84696351;
            if ((*(_BYTE *)(v37 + 48) & 1) != 0)
              v41 = 16777619
                  * ((16777619
                    * ((16777619
                      * ((16777619 * (*(_QWORD *)((v37 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(_QWORD *)((v37 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(_QWORD *)(((v37 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(_QWORD *)(((v37 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
            v42 = (16777619
                 * (((*(unsigned __int8 *)(v37 + 45) << 16) | (*(unsigned __int8 *)(v37 + 44) << 8) | *(unsigned __int8 *)(v37 + 43)) ^ v41)) ^ *(_DWORD *)(v37 + 36);
            if (*(_BYTE *)(v37 + 47))
            {
              v43 = (int *)(v37 + 49);
              if ((*(_BYTE *)(v37 + 48) & 1) != 0)
                v43 = (int *)(((v37 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
              v44 = *(unsigned __int8 *)(v37 + 47);
              do
              {
                v45 = *v43;
                v43 += 3;
                v42 = v45 ^ (16777619 * v42);
                --v44;
              }
              while (v44);
            }
            v46 = *(unsigned __int8 *)(v37 + 46);
            if (*(_BYTE *)(v37 + 46))
            {
              if ((*(_BYTE *)(v37 + 48) & 1) != 0)
                v47 = ((v37 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
              else
                v47 = v37 + 49;
              v48 = (unsigned __int8 *)(v47 + 12 * *(unsigned __int8 *)(v37 + 47) + 4);
              do
              {
                v49 = 33 * *((_DWORD *)v48 - 1);
                v50 = *v48;
                v48 += 8;
                v42 = (v49 + v50) ^ (16777619 * v42);
                --v46;
              }
              while (v46);
            }
            v51 = &v11[16 * v38];
            *((_DWORD *)v51 + 2) = (16777619 * v42) ^ *(_DWORD *)v37;
            *(_QWORD *)v51 = v37;
            *((_WORD *)v51 + 6) = v40;
            *((_WORD *)v51 + 7) = *(_WORD *)(v37 + 40);
            ++v27;
            v36 = v39;
          }
          while (v27 != v28);
        }
        while (1)
        {
          v12 = *(unsigned int *)v4;
          if (v28 >= v12)
            break;
          v52 = *(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v28);
          if ((*(_DWORD *)v52 & 0x3F) != 0x26)
            break;
          v53 = 84696351;
          if ((*(_BYTE *)(v52 + 48) & 1) != 0)
            v53 = 16777619
                * ((16777619
                  * ((16777619
                    * ((16777619 * (*(_QWORD *)((v52 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(_QWORD *)((v52 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(_QWORD *)(((v52 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(_QWORD *)(((v52 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
          v54 = (16777619
               * (((*(unsigned __int8 *)(v52 + 45) << 16) | (*(unsigned __int8 *)(v52 + 44) << 8) | *(unsigned __int8 *)(v52 + 43)) ^ v53)) ^ *(_DWORD *)(v52 + 36);
          if (*(_BYTE *)(v52 + 47))
          {
            v55 = (int *)(v52 + 49);
            if ((*(_BYTE *)(v52 + 48) & 1) != 0)
              v55 = (int *)(((v52 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
            v56 = *(unsigned __int8 *)(v52 + 47);
            do
            {
              v57 = *v55;
              v55 += 3;
              v54 = v57 ^ (16777619 * v54);
              --v56;
            }
            while (v56);
          }
          v58 = *(unsigned __int8 *)(v52 + 46);
          if (*(_BYTE *)(v52 + 46))
          {
            if ((*(_BYTE *)(v52 + 48) & 1) != 0)
              v59 = ((v52 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
            else
              v59 = v52 + 49;
            v60 = (unsigned __int8 *)(v59 + 12 * *(unsigned __int8 *)(v52 + 47) + 4);
            do
            {
              v61 = 33 * *((_DWORD *)v60 - 1);
              v62 = *v60;
              v60 += 8;
              v54 = (v61 + v62) ^ (16777619 * v54);
              --v58;
            }
            while (v58);
          }
          v63 = &v11[16 * v28];
          *((_DWORD *)v63 + 2) = (16777619 * v54) ^ *(_DWORD *)v52;
          *(_QWORD *)v63 = v52;
          *((_WORD *)v63 + 6) = v28;
          *((_WORD *)v63 + 7) = *(_WORD *)(v52 + 40);
          ++v28;
        }
        v27 = v28;
        v26 += v29;
        v28 = *(unsigned int *)v4;
      }
      while (v27 < v12);
    }
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 1)
    {
      puts("\n== after depth partition ==");
    }
  }
  else
  {
    if (v12)
    {
      v13 = 0;
      do
      {
        v14 = *(_QWORD *)(*((_QWORD *)v4 + 1) + 8 * v13);
        v15 = 84696351;
        if ((*(_BYTE *)(v14 + 48) & 1) != 0)
          v15 = 16777619
              * ((16777619
                * ((16777619
                  * ((16777619 * (*(_QWORD *)((v14 + 56) & 0xFFFFFFFFFFFFFFF8) ^ 0x50C5D1F)) ^ HIDWORD(*(_QWORD *)((v14 + 56) & 0xFFFFFFFFFFFFFFF8)))) ^ *(_QWORD *)(((v14 + 56) & 0xFFFFFFFFFFFFFFF8) + 8))) ^ HIDWORD(*(_QWORD *)(((v14 + 56) & 0xFFFFFFFFFFFFFFF8) + 8)));
        v16 = (16777619
             * (((*(unsigned __int8 *)(v14 + 45) << 16) | (*(unsigned __int8 *)(v14 + 44) << 8) | *(unsigned __int8 *)(v14 + 43)) ^ v15)) ^ *(_DWORD *)(v14 + 36);
        if (*(_BYTE *)(v14 + 47))
        {
          v17 = (int *)(v14 + 49);
          if ((*(_BYTE *)(v14 + 48) & 1) != 0)
            v17 = (int *)(((v14 + 56) & 0xFFFFFFFFFFFFFFF8) + 16);
          v18 = *(unsigned __int8 *)(v14 + 47);
          do
          {
            v19 = *v17;
            v17 += 3;
            v16 = v19 ^ (16777619 * v16);
            --v18;
          }
          while (v18);
        }
        v20 = *(unsigned __int8 *)(v14 + 46);
        if (*(_BYTE *)(v14 + 46))
        {
          if ((*(_BYTE *)(v14 + 48) & 1) != 0)
            v21 = ((v14 + 56) & 0xFFFFFFFFFFFFFFF8) + 16;
          else
            v21 = v14 + 49;
          v22 = (unsigned __int8 *)(v21 + 12 * *(unsigned __int8 *)(v14 + 47) + 4);
          do
          {
            v23 = 33 * *((_DWORD *)v22 - 1);
            v24 = *v22;
            v22 += 8;
            v16 = (v23 + v24) ^ (16777619 * v16);
            --v20;
          }
          while (v20);
        }
        v25 = &v11[16 * v13];
        *((_DWORD *)v25 + 2) = (16777619 * v16) ^ *(_DWORD *)v14;
        *(_QWORD *)v25 = v14;
        *((_WORD *)v25 + 6) = v13;
        *((_WORD *)v25 + 7) = *(_WORD *)(v14 + 40);
        ++v13;
      }
      while (v13 < *(unsigned int *)v4);
    }
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 1)
    {
      puts("\n== before scheduling ==");
    }
    v26 = 0;
  }
  v64 = *(_DWORD *)v4;
  if (v26 >= *(_DWORD *)v4)
    goto LABEL_160;
  v155 = v11 + 15;
  v156 = v11 - 8;
  v65 = v11 + 16;
  v154 = v11 + 8;
  do
  {
    v66 = v26;
    if (v26 + 80 >= (unint64_t)v64)
      v67 = v64 - v26;
    else
      v67 = 64;
    v68 = &v11[16 * v26];
    if ((v9 & 2) != 0)
    {
      v69 = (int)v67 - 1;
      *(_WORD *)&v68[16 * v69 + 12] = v67 + v26 - 1;
      v70 = (v67 - 2);
      if ((int)v67 >= 2)
      {
        v71 = 0;
        v72 = &v156[16 * v26 + 16 * v67];
        v73 = &v65[16 * v26 + 16 * v70];
        v74 = v67;
        v75 = &v155[16 * v26];
        while (1)
        {
          v76 = (int32x2_t **)&v68[16 * v70];
          *((_WORD *)v76 + 6) = v67 + v66 - 1;
          v77 = (_WORD *)v76 + 6;
          LOWORD(v78) = v67 + v66 - 1;
          if (v70 >= v67 - 1)
            goto LABEL_118;
          v79 = v74;
          v80 = (*v76)[1];
          v81 = (*v76)[2];
          v82 = v72;
          v83 = v71;
          LOWORD(v78) = v67 + v66 - 1;
          v84 = v70;
          while (1)
          {
            v85 = (int32x2_t *)*((_QWORD *)v82 - 1);
            *(int32x2_t *)v86.i8 = vsub_s32(v85[1], v81);
            v86.u64[1] = (unint64_t)vsub_s32(v80, v85[2]);
            if ((vminvq_u32((uint32x4_t)vcltzq_s32(v86)) & 0x80000000) != 0)
              break;
LABEL_107:
            v84 = v67 + v83 - 1;
            v82 += 16;
            ++v83;
            ++v79;
            if (v83 == 1)
              goto LABEL_118;
          }
          v78 = *(_QWORD *)v82;
          v87 = HIBYTE(*(_QWORD *)v82);
          v88 = v76[1];
          if (((v87 | HIWORD(*(_QWORD *)v82)) & ((unint64_t)v88 >> 56)) != 0)
          {
            v89 = HIDWORD(v78);
LABEL_110:
            LOWORD(v78) = v89 - 1;
            *v77 = v89 - 1;
            goto LABEL_118;
          }
          if (((((unint64_t)v88 >> 56) | ((unint64_t)v88 >> 48)) & v87) == 0)
            break;
          LOWORD(v78) = WORD2(v78) - 1;
          *v77 = WORD2(v78) - 1;
          if (v84 + 2 < (int)v67)
          {
            v90 = v76[1];
            v91 = (unint64_t)v90 >> 56;
            v92 = (int)v67 + v83;
            v93 = (unint64_t)v90 >> 32;
            v78 = (unint64_t)v90 >> 32;
            v94 = &v75[16 * v79];
            while (1)
            {
              if (((*v94 | *(v94 - 1)) & v91) != 0)
              {
                v95 = *(int32x2_t **)(v94 - 15);
                *(int32x2_t *)v96.i8 = vsub_s32(v80, v95[2]);
                v96.u64[1] = (unint64_t)vsub_s32(v95[1], v81);
                if ((vminvq_u32((uint32x4_t)vcltzq_s32(v96)) & 0x80000000) != 0)
                  break;
              }
              ++v92;
              v94 += 16;
              if (v92 >= v67)
                goto LABEL_118;
            }
            LODWORD(v89) = *(__int16 *)(v94 - 3);
            if ((int)v89 <= (__int16)v93)
              goto LABEL_110;
          }
LABEL_118:
          v157 = *v76;
          v158 = *((_DWORD *)v76 + 2);
          v97 = *((_WORD *)v76 + 7);
          if ((_DWORD)v67 == 2)
          {
            LODWORD(v98) = 1;
          }
          else
          {
            v99 = v73;
            v98 = 1;
            while (*((__int16 *)v99 + 6) < (__int16)v78)
            {
              *((_OWORD *)v99 - 1) = *(_OWORD *)v99;
              v99 += 16;
              if (v69 == ++v98)
              {
                LODWORD(v98) = v67 - 1;
                break;
              }
            }
          }
          v100 = &v76[2 * (int)v98 - 2];
          *v100 = v157;
          *((_DWORD *)v100 + 2) = v158;
          *((_WORD *)v100 + 6) = v78;
          *((_WORD *)v100 + 7) = v97;
          --v74;
          --v71;
          v72 -= 16;
          v73 -= 16;
          v101 = v70-- <= 0;
          if (v101)
            goto LABEL_126;
        }
        v78 = (unint64_t)v88 >> 32;
        goto LABEL_107;
      }
    }
LABEL_126:
    if ((v9 & 4) == 0)
      goto LABEL_159;
    v102 = &v11[16 * v66];
    *((_WORD *)v102 + 6) = v66;
    if ((int)v67 < 2)
      goto LABEL_159;
    v103 = 0;
    v104 = -1;
    v105 = 1;
    v106 = &v154[16 * v66];
    v107 = &v65[16 * v66];
    do
    {
      v108 = v105;
      v109 = (int32x2_t **)&v68[16 * v105];
      *((_WORD *)v109 + 6) = v66;
      v110 = (_WORD *)v109 + 6;
      v111 = *v109;
      v112 = (*v109)[1];
      v113 = (*v109)[2];
      v114 = v104;
      v115 = v103;
      v116 = v103;
      LOWORD(v117) = v66;
      while (1)
      {
        v118 = (int32x2_t **)&v68[16 * v116];
        *(int32x2_t *)v119.i8 = vsub_s32((*v118)[1], v113);
        v119.u64[1] = (unint64_t)vsub_s32(v112, (*v118)[2]);
        if ((vminvq_u32((uint32x4_t)vcltzq_s32(v119)) & 0x80000000) != 0)
          break;
LABEL_134:
        v122 = v116-- + 1;
        --v115;
        --v114;
        if (v122 <= 1)
          goto LABEL_146;
      }
      v117 = (unint64_t)v118[1];
      v120 = *((_BYTE *)v109 + 15) | *((_BYTE *)v109 + 14);
      if ((v120 & HIBYTE(v117)) != 0)
      {
        v123 = HIDWORD(v117);
LABEL_137:
        LOWORD(v117) = v123 + 1;
        *v110 = v123 + 1;
        goto LABEL_146;
      }
      v121 = v109[1];
      if (((HIBYTE(v117) | HIWORD(v117)) & ((unint64_t)v121 >> 56)) == 0)
      {
        v117 = (unint64_t)v121 >> 32;
        goto LABEL_134;
      }
      LODWORD(v117) = (__int16)(WORD2(v117) + 1);
      *v110 = WORD2(v117) + 1;
      if ((int)v116 + 1 >= 2)
      {
        v124 = &v106[16 * v114];
        v125 = v124;
        while (1)
        {
          v127 = *(_QWORD *)v125;
          v125 -= 16;
          v126 = v127;
          if ((HIBYTE(v127) & v120) != 0)
          {
            v128 = (int32x2_t *)*((_QWORD *)v124 - 1);
            *(int32x2_t *)v129.i8 = vsub_s32(v128[1], v113);
            v129.u64[1] = (unint64_t)vsub_s32(v112, v128[2]);
            if ((vminvq_u32((uint32x4_t)vcltzq_s32(v129)) & 0x80000000) != 0)
              break;
          }
          v124 = v125;
          v130 = __OFSUB__(v115--, 1);
          if ((v115 < 0) ^ v130 | (v115 == 0))
            goto LABEL_146;
        }
        if ((int)v117 <= SWORD2(v126))
        {
          v123 = v126 << 16 >> 48;
          goto LABEL_137;
        }
      }
LABEL_146:
      ++v105;
      v131 = *((_DWORD *)v109 + 2);
      v132 = *((_WORD *)v109 + 7);
      v133 = v107;
      v134 = v103;
      while (*(__int16 *)&v68[16 * v134 + 12] > (__int16)v117)
      {
        v135 = *(_OWORD *)&v68[16 * v134];
        v136 = v134-- + 1;
        *(_OWORD *)v133 = v135;
        v133 -= 16;
        --v108;
        if (v136 <= 1)
        {
LABEL_155:
          LODWORD(v134) = -1;
          goto LABEL_156;
        }
      }
      v137 = &v102[16 * v108];
      while (1)
      {
        v138 = &v68[16 * v134];
        if (*((unsigned __int16 *)v138 + 6) != (unsigned __int16)v117
          || v131 <= *(_DWORD *)&v68[16 * v134 + 8])
        {
          break;
        }
        *(_OWORD *)v137 = *(_OWORD *)v138;
        v137 -= 16;
        v101 = (int)v134 <= 0;
        LODWORD(v134) = v134 - 1;
        if (v101)
          goto LABEL_155;
      }
LABEL_156:
      v139 = &v68[16 * (int)v134 + 16];
      *(_QWORD *)v139 = v111;
      *((_DWORD *)v139 + 2) = v131;
      *((_WORD *)v139 + 6) = v117;
      *((_WORD *)v139 + 7) = v132;
      ++v104;
      ++v103;
      v107 += 16;
    }
    while (v105 != v67);
LABEL_159:
    v26 = v67 + v66;
    v64 = *(_DWORD *)v4;
  }
  while (v26 < *(_DWORD *)v4);
LABEL_160:
  if (v64)
  {
    v140 = 0;
    v141 = v11;
    do
    {
      v142 = *(_QWORD *)v141;
      v141 += 16;
      *(_QWORD *)(*((_QWORD *)v4 + 1) + v140) = v142;
      v140 += 8;
    }
    while (8 * v64 != v140);
  }
  v143 = v153;
  if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity > 0)
  {
    if (RB::RenderQueue::schedule(RB::Device *,BOOL)::verbosity == 1)
      v144 = "render pass";
    else
      v144 = "after scheduling";
    printf("\n== %s ==\n", v144);
  }
  if (v143 >= 0x801)
LABEL_169:
    free(v11);
}

void sub_209AEDC78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::RenderPass::set_attachment(uint64_t a1, MTLPixelFormat a2, RB::Resource *this, unsigned int a4, uint64_t a5)
{
  uint64_t v5;
  int v8;
  void *v10;
  int v11;
  uint64_t v12;
  char v13;
  void *v14;
  unsigned int *v15;
  void *v16;
  MTLPixelFormat v17;
  void *v18;
  void *v19;
  int v20;
  RB::Resource **v21;
  RB::Resource *v22;
  int v23;
  uint64_t v24;

  v5 = a5;
  v8 = a2;
  if (!a5)
    v5 = *((_QWORD *)this + 7);
  switch((int)a2)
  {
    case 0:
      v10 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 144), "colorAttachments"), "objectAtIndexedSubscript:", 0);
      objc_msgSend(v10, "setTexture:", *((_QWORD *)this + 2));
      objc_msgSend(v10, "setLevel:", a4);
      v11 = *(_DWORD *)(a1 + 128);
      if (v11 == 2)
        v12 = 2;
      else
        v12 = v11 != 0;
      objc_msgSend(v10, "setLoadAction:", v12);
      objc_msgSend(v10, "setStoreAction:", *((unsigned __int8 *)this + 78) != 2);
      if (*(_DWORD *)(a1 + 128) == 2)
      {
        v13 = *(_BYTE *)(a1 + 132) | 2;
        goto LABEL_15;
      }
      break;
    case 1:
      v19 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 144), "colorAttachments"), "objectAtIndexedSubscript:", 1);
      objc_msgSend(v19, "setTexture:", *((_QWORD *)this + 2));
      objc_msgSend(v19, "setLevel:", a4);
      objc_msgSend(v19, "setLoadAction:", 2);
      objc_msgSend(v19, "setStoreAction:", ((unint64_t)*(unsigned __int8 *)(***(_QWORD ***)a1 + 292) >> 2) & 1);
      objc_msgSend(v19, "setClearColor:", 0.0, 0.0, 0.0, 0.0);
      v13 = *(_BYTE *)(a1 + 132) | 0x18;
LABEL_15:
      *(_BYTE *)(a1 + 132) = v13;
      break;
    case 2:
      v14 = (void *)objc_msgSend((id)objc_msgSend(*(id *)(a1 + 144), "colorAttachments"), "objectAtIndexedSubscript:", 2);
      objc_msgSend(v14, "setTexture:", *((_QWORD *)this + 2));
      objc_msgSend(v14, "setLevel:", a4);
      objc_msgSend(v14, "setLoadAction:", 0);
      objc_msgSend(v14, "setStoreAction:", 0);
      break;
    case 3:
      v15 = RB::pixel_format_traits(*((_QWORD *)this + 7), a2);
      if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x4000000000) != 0)
      {
        v16 = (void *)objc_msgSend(*(id *)(a1 + 144), "stencilAttachment");
        objc_msgSend(v16, "setTexture:", *((_QWORD *)this + 2));
        objc_msgSend(v16, "setLevel:", a4);
        objc_msgSend(v16, "setLoadAction:", 2);
        objc_msgSend(v16, "setStoreAction:", ((unint64_t)*(unsigned __int8 *)(***(_QWORD ***)a1 + 292) >> 2) & 1);
        objc_msgSend(v16, "setClearStencil:", 0);
        *(_BYTE *)(a1 + 132) |= 1u;
        v15 = RB::pixel_format_traits(*((_QWORD *)this + 7), v17);
      }
      if (((*v15 | ((unint64_t)*((unsigned __int16 *)v15 + 2) << 32)) & 0x8000000000) != 0)
      {
        v18 = (void *)objc_msgSend(*(id *)(a1 + 144), "depthAttachment");
        objc_msgSend(v18, "setTexture:", *((_QWORD *)this + 2));
        objc_msgSend(v18, "setLevel:", a4);
        objc_msgSend(v18, "setLoadAction:", 2);
        objc_msgSend(v18, "setStoreAction:", ((unint64_t)*(unsigned __int8 *)(***(_QWORD ***)a1 + 292) >> 2) & 1);
        objc_msgSend(v18, "setClearDepth:", 0.0);
      }
      break;
    default:
      break;
  }
  v20 = v8;
  v21 = (RB::Resource **)(a1 + 8 + 24 * v8);
  v22 = *v21;
  if (*v21 != this)
  {
    if (v22)
    {
      v23 = *((_DWORD *)v22 + 2) - 1;
      *((_DWORD *)v22 + 2) = v23;
      if (!v23)
        (*(void (**)(RB::Resource *))(*(_QWORD *)v22 + 8))(v22);
    }
    if (this)
      ++*((_DWORD *)this + 2);
    *v21 = this;
  }
  v24 = a1 + 8 + 24 * v20;
  *(_QWORD *)(v24 + 8) = v5;
  *(_DWORD *)(v24 + 16) = a4;
  return RB::Resource::set_frame_id((uint64_t)this, *(_DWORD *)(**(_QWORD **)a1 + 84), *(_DWORD *)(**(_QWORD **)a1 + 88));
}

__n128 RB::Device::alloc_shared_texture@<Q0>(_QWORD *a1@<X0>, RB *a2@<X1>, unsigned int a3@<W2>, char a4@<W3>, int a5@<W4>, int32x2_t **a6@<X8>, __n128 a7@<Q0>)
{
  uint64_t *v13;
  uint64_t *i;
  int32x2_t *v15;
  uint32x2_t v16;
  uint64_t v17;
  id *v18;
  __n128 result;
  int v20;
  int32x2_t *v21;
  RB *v22;
  NSObject *v23;
  MTLPixelFormat v24;
  char *v25;
  _BYTE buf[12];
  __int16 v28;
  unsigned __int32 v29;
  __int16 v30;
  unsigned __int32 v31;
  __int16 v32;
  unsigned int v33;
  __int16 v34;
  int v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  *a6 = 0;
  v13 = a1 + 47;
  for (i = (uint64_t *)a1[48]; ; i = (uint64_t *)a1[48])
  {
    while (1)
    {
      if (i == v13)
        goto LABEL_15;
      v15 = (int32x2_t *)i[2];
      if ((RB *)v15[7] == a2)
      {
        v16 = (uint32x2_t)vceq_s32(v15[8], (int32x2_t)a7.n128_u64[0]);
        if ((vpmin_u32(v16, v16).u32[0] & 0x80000000) != 0 && v15[9].u8[4] == a3 && v15[9].u8[6] == a5)
          break;
      }
      i = (uint64_t *)i[1];
    }
    ++v15[1].i32[0];
    *a6 = v15;
    v17 = *i;
    *(_QWORD *)(v17 + 8) = i[1];
    *(_QWORD *)i[1] = v17;
    --a1[49];
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((int)v13, i);
    a1[53] -= v15[9].u32[0];
    v18 = (id *)v15;
    if ((v15[9].i8[5] & 2) != 0)
      v18 = (id *)v15[3];
    if (RB::Resource::set_volatile(v18, 0) != 2)
      break;
    *a6 = 0;
    v20 = v15[1].i32[0] - 1;
    v15[1].i32[0] = v20;
    if (!v20)
      (*(void (**)(int32x2_t *))(*(_QWORD *)v15 + 8))(v15);
  }
  v15[9].i8[5] = 0;
  v15[10].i8[0] = a4;
  v21 = *a6;
  if (*a6)
  {
LABEL_16:
    v21[6] = (int32x2_t)a1;
    return result;
  }
LABEL_15:
  v22 = (RB *)RB::Texture::alloc((uint64_t)a1, (unint64_t)a2, a3, a4, a5, 0, (uint64_t *)buf, a7);
  v21 = *(int32x2_t **)buf;
  *a6 = *(int32x2_t **)buf;
  if (v21)
    goto LABEL_16;
  v23 = RB::error_log(v22);
  if (os_log_type_enabled(v23, OS_LOG_TYPE_FAULT))
  {
    v25 = RB::pixel_format_name(a2, v24);
    *(_DWORD *)buf = 136316162;
    *(_QWORD *)&buf[4] = v25;
    v28 = 1024;
    v29 = a7.n128_u32[0];
    v30 = 1024;
    v31 = a7.n128_u32[1];
    v32 = 1024;
    v33 = a3;
    v34 = 1024;
    v35 = a5;
    _os_log_fault_impl(&dword_209ACA000, v23, OS_LOG_TYPE_FAULT, "unable to create texture: %s, [%d, %d, %u], %d", buf, 0x24u);
  }
  return result;
}

void sub_209AEE1EC(_Unwind_Exception *exception_object)
{
  _DWORD **v1;

  if (*v1)
    RB::Device::alloc_shared_texture(*v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Resource::set_volatile(id *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;

  v2 = a2;
  if (*((unsigned __int8 *)this + 44) != (_DWORD)a2)
  {
    if (*((_BYTE *)this + 45))
    {
      if ((_DWORD)a2)
        v4 = 3;
      else
        v4 = 2;
      v5 = objc_msgSend(this[2], "setPurgeableState:", v4);
      if ((v2 & 1) == 0 && objc_msgSend(this[2], "setPurgeableState:", 1) != 2)
        return 2;
    }
    else
    {
      v5 = 2;
    }
    *((_BYTE *)this + 44) = v2;
    if (v5 == 4)
      return 1;
    else
      return v2;
  }
  return v2;
}

uint64_t RB::Resource::Resource(uint64_t result, uint64_t a2)
{
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)result = off_24C229970;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)(result + 32) = 0;
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 37) = 0;
  *(_BYTE *)(result + 45) = 1;
  return result;
}

uint64_t RB::max_mipmap_levels(int32x2_t a1)
{
  uint32x2_t v1;
  uint64_t result;
  uint32x2_t v3;

  v1 = (uint32x2_t)vcgt_s32(a1, (int32x2_t)0x100000001);
  result = 1;
  if ((vpmax_u32(v1, v1).u32[0] & 0x80000000) != 0)
  {
    do
    {
      v3 = (uint32x2_t)vcgt_s32(a1, (int32x2_t)0x300000003);
      a1 = vshr_n_s32(a1, 1uLL);
      result = (result + 1);
    }
    while ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0);
  }
  return result;
}

uint64_t RB::RenderState::uses_shader_blending(RB::RenderState *this)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t result;
  int v4;
  unsigned int v5;
  BOOL v6;
  unsigned int v7;

  v1 = *(_DWORD *)this & 0x3F;
  if (v1 < 0x20 && ((0x8000000F >> v1) & 1) != 0)
    return v1 == 0;
  v2 = (*(_DWORD *)this >> 6) & 0x3F;
  if (v2 > 0x18 || ((*(_DWORD *)this >> 6) & 0x3D | 2) == 0x16 && v1 - 18 < 5)
    return 1;
  if ((*((_BYTE *)this + 4) & 1) != 0)
    goto LABEL_17;
  v4 = *(_DWORD *)this;
  v5 = *(_DWORD *)this & 0x3F;
  if (v5 > 0x25)
    goto LABEL_17;
  if (((1 << v5) & 0x3FFF81C00CLL) != 0)
    return 0;
  if (((1 << v5) & 0x1F0) == 0)
    goto LABEL_17;
  if ((*(_DWORD *)this & 0xF000) == 0x1000)
    return 0;
  result = 0;
  if ((v4 & 0x100000) == 0 && (v4 & 0x30000) != 0x10000)
  {
LABEL_17:
    v6 = v2 >= 0x19;
    v7 = (0x1429Bu >> v2) & 1;
    if (v6)
      return 1;
    else
      return v7;
  }
  return result;
}

uint64_t RB::`anonymous namespace'::make_derived_state(unsigned int *a1, uint64_t a2, unsigned int a3, int a4)
{
  int v5;
  MTLPixelFormat v6;
  int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unint64_t v11;
  BOOL v12;
  unsigned int v13;
  int v14;
  uint64_t result;
  int v16;
  uint64_t v17;
  unsigned int v18;

  v17 = a2;
  v18 = a3;
  *a1 = *a1 & 0xFFFFFFFC | a4 | (2 * (((a2 >> 6) & 0x3F) - 21 < 2));
  if (RB::RenderState::can_discard_shape((RB::RenderState *)&v17))
    v5 = 4;
  else
    v5 = 0;
  *a1 = *a1 & 0xFFFFFFFB | v5;
  if (RB::RenderState::can_discard_alpha((RB::RenderState *)&v17))
    v7 = 8;
  else
    v7 = 0;
  v8 = *a1 & 0xFFFFFFF7 | v7;
  *a1 = v8;
  v9 = v18;
  v10 = RB::pixel_format_traits(v18 & 0x3FF, v6);
  v11 = *v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32);
  v12 = (v11 & 0xA00000000) == 0;
  v13 = v8 & 0xFFFFFFEF | (16 * ((v11 & 0xA00000000) != 0));
  *a1 = v13;
  v14 = (16 * *((unsigned __int16 *)v10 + 2)) & 0x20;
  if (v12)
    v14 = 0;
  *a1 = v14 | v13 & 0xFFFFFFDF;
  result = RB::RenderState::reads_tables((RB::RenderState *)&v17, (v9 >> 25) & 1);
  if ((_DWORD)result)
    v16 = 64;
  else
    v16 = 0;
  *a1 = v16 & 0xFFFFFFC0 | *a1 & 0x3F;
  return result;
}

BOOL RB::RenderState::can_discard_shape(RB::RenderState *this)
{
  return ((*(_DWORD *)this >> 6) & 0x3Fu) - 24 < 0xFFFFFFFB && (*(_DWORD *)this & 0x3Fu) - 23 < 0xFFFFFFFA;
}

BOOL RB::RenderState::can_discard_alpha(RB::RenderState *this)
{
  unsigned int v1;

  v1 = (*(_DWORD *)this >> 6) & 0x3F;
  return (v1 >= 0x18 || ((0xF9029Bu >> v1) & 1) == 0) && (*(_DWORD *)this & 0x3Fu) - 23 < 0xFFFFFFFA;
}

uint64_t RB::`anonymous namespace'::set_blend_state(void *a1, unsigned int a2, int a3)
{
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  if (a2 - 25 <= 0xFFFFFFE7)
    return objc_msgSend(a1, "setBlendingEnabled:", 0);
  v6 = *v5;
  v7 = v5[1];
  v8 = v5 + 2;
  v9 = v5[3];
  v10 = v5 + 4;
  v11 = v5[5];
  if (a3)
  {
    v12 = 0;
  }
  else
  {
    v12 = v9;
  }
  if (a3)
  {
    v13 = 0;
  }
  else
  {
    v13 = v11;
  }
  if (a3)
    v14 = v7;
  else
    v14 = v6;
  v15 = *v8;
  v16 = *v10;
  objc_msgSend(a1, "setBlendingEnabled:", 1);
  objc_msgSend(a1, "setRgbBlendOperation:", v14);
  objc_msgSend(a1, "setAlphaBlendOperation:", v7);
  objc_msgSend(a1, "setSourceRGBBlendFactor:", v15);
  objc_msgSend(a1, "setSourceAlphaBlendFactor:", v12);
  objc_msgSend(a1, "setDestinationRGBBlendFactor:", v16);
  return objc_msgSend(a1, "setDestinationAlphaBlendFactor:", v13);
}

const char *RB::RenderState::name(RB::RenderState *this)
{
  if ((*(_DWORD *)this & 0x3Fu) > 0x26)
    return "plane_color";
  else
    return off_24C22C1A8[*(_DWORD *)this & 0x3F];
}

uint64_t RB::Refcount<RBPath `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::Info,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

RB::DisplayList::State *RBDrawingStateBeginLayer(RB::DisplayList::State *a1, _RBDrawingState *a2)
{
  _QWORD *v4;
  unsigned int v5;
  LayerState *v6;
  RB::DisplayList::State *v7;
  RB::XML::DisplayList *v8;

  v4 = (_QWORD *)*((_QWORD *)a1 + 1);
  if (!v4[3])
    make_contents(*((unsigned int **)a1 + 1));
  v5 = (a2 >> 1) & 4;
  if ((a2 & 4) != 0)
    v5 = 2;
  v6 = (LayerState *)RB::DisplayList::Builder::begin_layer((RB::DisplayList::Builder *)(v4 + 2), a1, a2 & 1 | (8 * ((a2 >> 1) & 1)) & 0xFFFFF3FF | (((a2 >> 4) & 3) << 10) | v5);
  v7 = RB::DisplayList::Builder::copy_state((RB::DisplayList::Builder *)(v4 + 2), v6, (unsigned int **)a1);
  v8 = (RB::XML::DisplayList *)v4[38];
  if (v8)
    RB::XML::DisplayList::begin_layer(v8, (_RBDrawingState *)a1, a2);
  return v7;
}

int8x16_t RB::Rect::move_identity(float32x2_t *this, float64x2_t *a2)
{
  int8x16_t result;
  float32x2_t v5;

  result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a2[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a2, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a2[2]));
  result.i64[0] = vandq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)result, 1), result).u64[0];
  if ((result.i64[0] & 0x8000000000000000) == 0)
  {
    *this = RB::operator*(a2, *this, this[1]);
    this[1] = v5;
    result = (int8x16_t)xmmword_209BD52A0;
    *a2 = (float64x2_t)xmmword_209BD5290;
    a2[1] = (float64x2_t)xmmword_209BD52A0;
    a2[2].f64[0] = 0.0;
    a2[2].f64[1] = 0.0;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::Layer,unsigned int,int>(size_t *a1, int *a2, int *a3)
{
  uint64_t v5;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x48uLL, 7);
  else
    a1[2] = v5 + 72;
  return RB::DisplayList::Layer::Layer(v5, *a2, *a3);
}

uint64_t RBPathMakeRoundedRect(int a1, _OWORD *a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  uint64_t result;
  BOOL v17;
  __int128 v18;
  __int128 v19;
  CGAffineTransform v20;

  if (a7 == 0.0 && a8 == 0.0)
  if (CGRectIsNull(*(CGRect *)&a3))
    return 0;
  v17 = a1 == 1;
  if (a2
    && (v18 = a2[1],
        *(_OWORD *)&v20.a = *a2,
        *(_OWORD *)&v20.c = v18,
        *(_OWORD *)&v20.tx = a2[2],
        !CGAffineTransformIsIdentity(&v20)))
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(double *)(result + 48) = a7;
    *(double *)(result + 56) = a8;
    *(_BYTE *)(result + 64) = v17;
    *(_DWORD *)(result + 65) = 0;
    *(_DWORD *)(result + 68) = 0;
    *(_BYTE *)(result + 72) = 1;
    *(_QWORD *)result = off_24C22A218;
    v19 = a2[1];
    *(_OWORD *)(result + 80) = *a2;
    *(_OWORD *)(result + 96) = v19;
    *(_OWORD *)(result + 112) = a2[2];
  }
  else
  {
    result = operator new();
    *(_DWORD *)(result + 8) = 1;
    *(_QWORD *)result = off_24C22A248;
    *(double *)(result + 16) = a3;
    *(double *)(result + 24) = a4;
    *(double *)(result + 32) = a5;
    *(double *)(result + 40) = a6;
    *(double *)(result + 48) = a7;
    *(double *)(result + 56) = a8;
    *(_BYTE *)(result + 64) = v17;
    *(_QWORD *)(result + 65) = 0;
  }
  return result;
}

_QWORD *RB::Path::Iterator::callback_1(_QWORD *this, _QWORD *a2, const CGPathElement *a3)
{
  switch(*(_DWORD *)a2)
  {
    case 0:
      this = (_QWORD *)(*(uint64_t (**)(_QWORD, __n128))(*(_QWORD *)*this + 16))(*this, *(__n128 *)a2[1]);
      break;
    case 1:
      this = (_QWORD *)(*(uint64_t (**)(_QWORD, __n128))(*(_QWORD *)*this + 24))(*this, *(__n128 *)a2[1]);
      break;
    case 2:
      this = (_QWORD *)(*(uint64_t (**)(_QWORD, __n128, __n128))(*(_QWORD *)*this + 32))(*this, *(__n128 *)a2[1], *(__n128 *)(a2[1] + 16));
      break;
    case 3:
      this = (_QWORD *)(*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(*(_QWORD *)*this + 40))(*this, *(__n128 *)a2[1], *(__n128 *)(a2[1] + 16), *(__n128 *)(a2[1] + 32));
      break;
    case 4:
      this = (_QWORD *)(*(uint64_t (**)(_QWORD))(*(_QWORD *)*this + 8))(*this);
      break;
    default:
      return this;
  }
  return this;
}

void ___ZN2RB18SharedSurfaceGroup16schedule_updatesEv_block_invoke(uint64_t a1)
{
  RB::SharedSurfaceGroup *v1;

  v1 = (RB::SharedSurfaceGroup *)RB::Device::shared_surfaces(*(RB::Device **)(a1 + 32));
  *((_QWORD *)v1 + 6) = 0;
  RB::SharedSurfaceGroup::render_updates(v1);
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(uint64_t a1, uint64_t a2)
{
  float32x2_t *v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  uint64_t result;
  float64x2_t v12[2];
  uint64_t v13;
  uint64_t v14;

  v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_209BD5290,
        v12[1] = (float64x2_t)xmmword_209BD52A0,
        v13 = 0,
        v14 = 0,
        v5 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a2, v12),
        result = RB::Rect::intersects(v4, v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(_QWORD *)&v12[0].f64[0] = a1;
    *(_QWORD *)&v12[0].f64[1] = a2;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>>(*(_QWORD **)(a1 + 32), (uint64_t)v12);
  }
  return result;
}

float32x2_t RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(uint64_t a1, float64x2_t *a2)
{
  float32x2_t v4;
  uint32x2_t v5;
  float32x2_t v6;

  v4 = *(float32x2_t *)(a1 + 64);
  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&v4 & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    RB::Coverage::StrokeablePath::bounds(a1 + 8, a1);
    *(float32x2_t *)(a1 + 56) = v6;
    *(float32x2_t *)(a1 + 64) = v4;
  }
  else
  {
    v6 = *(float32x2_t *)(a1 + 56);
  }
  return RB::operator*(a2, v6, v4);
}

void RB::Coverage::StrokeablePath::bounds(uint64_t a1, uint64_t a2)
{
  __int128 *v3;
  __int128 v4;
  __int128 v5;
  float v6;
  __int16 v7;
  float v8;
  uint64_t (**v9)(RB::Stroke::FixedWidthLineBounds *__hidden);
  float v10;
  __int16 v11;
  float v12;
  int32x2_t v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  char v18;
  int v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  if (*(_QWORD *)(a1 + 8) != 0x209BD98A8)
  {
    v3 = *(__int128 **)(a1 + 16);
    if (v3)
    {
      v4 = *v3;
      v5 = v3[2];
      v21 = v3[1];
      v22 = v5;
      v20 = v4;
    }
    else
    {
      v20 = xmmword_209BD5290;
      v21 = xmmword_209BD52A0;
      v22 = 0uLL;
    }
    v6 = *(float *)(a1 + 24);
    v7 = *(_WORD *)(a2 + 73);
    v8 = *(float *)(a2 + 80);
    v9 = off_24C229778;
    v10 = v6 * (float)(0.5 * RB::AffineTransform::scale((float64x2_t *)&v20));
    v11 = v7;
    v12 = v8 * v8;
    v13 = vdup_n_s32(0x7F800000u);
    v14 = 0x7F0000007FLL;
    v15 = 0u;
    v16 = 0u;
    v17 = 0;
    v18 = 1;
    v19 = 0;
    RBPathMap(*(CGPathRef *)a1, *(void **)(a1 + 8), (uint64_t (**)(RB::Path::Mapper *__hidden))&v9, *(float64x2_t **)(a1 + 16));
  }
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Color>(uint64_t a1, uint64_t (**a2)(_QWORD, __int128 *))
{
  uint64_t (*v4)(_QWORD, __int128 *);
  _QWORD *result;
  uint64_t (**v6[3])(_QWORD, __int128 *);

  v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C226118;
    v6[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(_QWORD *)(a1 + 8) + 8, *(_QWORD *)(a1 + 8), v6);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  }
  result = (_QWORD *)*((_QWORD *)v4 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(_QWORD *)v4, *(_QWORD *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
    *(_QWORD *)(*(_QWORD *)a1 + 56) = result;
  }
  if (*((_BYTE *)v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

uint64_t RB::Coverage::StrokeablePath::simplify(uint64_t a1, uint64_t a2, uint64_t (***a3)(_QWORD, __int128 *))
{
  uint64_t result;
  float v7;
  uint64_t v8;
  __int128 v9;
  double v10;
  double v11;
  BOOL v12;
  __int128 *v13;
  __int128 v14;
  __int128 v15;
  _QWORD v16[3];
  int v17;
  int v18;
  double v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  char v27;
  _QWORD *v28;
  double v29;
  uint64_t v30;
  char v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  if ((_DWORD)result)
  {
    v7 = *(float *)(a1 + 24);
    if (v7 <= 0.0)
    {
      v23 = 0u;
      v24 = 0u;
      LODWORD(v25) = 1065353216;
      *(_QWORD *)((char *)&v25 + 4) = 0;
      BYTE12(v25) = 0;
      *(_WORD *)((char *)&v25 + 13) = 1;
      return (**a3)(a3, &v23);
    }
    else if (!*(_QWORD *)(a1 + 32))
    {
      if ((v8 = *(_QWORD *)(a1 + 16)) == 0
        || (v9 = *(_OWORD *)(v8 + 16), v10 = *(double *)(v8 + 24), v11 = *(double *)(v8 + 8), *(double *)v8 == v10)
        && v11 == 0.0
        && *(double *)&v9 == 0.0
        || v10 == 0.0 && (*(double *)v8 == 0.0 ? (v12 = v11 == *(double *)&v9) : (v12 = 0), v12))
      {
        v16[0] = 0;
        v16[1] = 0;
        *(double *)&v16[2] = v7;
        v17 = rb_line_cap(*(unsigned __int8 *)(a2 + 73));
        v18 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 74));
        v19 = *(float *)(a2 + 80);
        v21 = 0;
        v22 = 0;
        v20 = 0;
        *(_QWORD *)&v23 = a3;
        v13 = *(__int128 **)(a1 + 16);
        if (v13)
        {
          v14 = *v13;
          v15 = v13[2];
          v25 = v13[1];
          v26 = v15;
          v24 = v14;
        }
        else
        {
          v24 = xmmword_209BD5290;
          v25 = xmmword_209BD52A0;
          v26 = 0uLL;
        }
        v27 = *(_BYTE *)(a2 + 76);
        v28 = v16;
        v29 = *(float *)(a1 + 24);
        v30 = 0;
        v31 = 0;
      }
    }
  }
  return result;
}

_QWORD *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>>(_QWORD *result, uint64_t a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Color>(a2, (uint64_t (**)(_QWORD, __int128 *))result + 2);
      break;
    case 2:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Gradient>(a2, (uint64_t (**)(_QWORD, __int128 *))result + 2);
      break;
    case 3:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t (**)(_QWORD, __int128 *))result + 2);
      break;
    case 4:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (uint64_t (**)(_QWORD, __int128 *))result + 2);
      break;
    case 5:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Custom>(a2, (uint64_t (**)(_QWORD, __int128 *))result + 2);
      break;
    default:
      return result;
  }
  return result;
}

uint64_t rb_line_cap(unsigned int a1)
{
  if (a1 > 6)
    return 0;
  else
    return dword_209BD7080[(char)a1];
}

{
  if (a1 > 6)
    return 0;
  else
    return rb_line_cap(RBLineCap)::types[a1];
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 160 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 160;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C2257D8;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::GenericItem1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __int16 v17;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C226F78;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(a1 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(a1 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  if (*(_BYTE *)(a4 + 9))
    v17 = *(_WORD *)(a4 + 8);
  else
    v17 = a7;
  *(_QWORD *)(a1 + 144) = *(_QWORD *)a4;
  *(_WORD *)(a1 + 152) = v17;
  return a1;
}

void sub_209AEF420(_Unwind_Exception *exception_object)
{
  void *v1;
  int v2;

  if (v2)
    free(v1);
  _Unwind_Resume(exception_object);
}

void `anonymous namespace'::ShapeBounds::apply_shape_callback(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v11;
  __int128 v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  int64x2_t v16;
  CGFloat v17;
  CGFloat v18;
  CGFloat v19;
  float v20;
  char v21;
  char v22;
  double v23;
  float v24;
  uint32x2_t v25;
  float64x2_t *v26;
  float64x2_t v27;
  float64x2_t v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  float64x2_t v34;
  __int128 v35;
  _BYTE v36[48];
  char v37;
  int v38;
  CGAffineTransform v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  CGRect v46;
  CGRect v47;

  if (a2 <= 6)
  {
    v40 = v8;
    v41 = v7;
    v42 = v6;
    v43 = v5;
    v44 = v3;
    v45 = v4;
    if (((1 << a2) & 0x1B) != 0)
    {
      v11 = *(_OWORD *)(a3 + 16);
      v12 = *(_OWORD *)(a3 + 32);
      v34 = *(float64x2_t *)a3;
      v35 = v11;
      *(_OWORD *)v36 = v12;
      v13.f64[0] = RB::operator*(&v34, (float64x2_t *)a1);
      *(float64x2_t *)a1 = v13;
      *(float64x2_t *)(a1 + 16) = v14;
      *(float64x2_t *)(a1 + 32) = v15;
      v16 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v14, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v13, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v15));
      if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v16, 1), (int8x16_t)v16).u64[0] & 0x8000000000000000) == 0)
      {
        v18 = *(double *)(a3 + 48);
        v17 = *(double *)(a3 + 56);
        v19 = *(double *)(a3 + 64);
        v46.size.height = *(CGFloat *)(a3 + 72);
        *(float64x2_t *)&v39.a = v13;
        *(float64x2_t *)&v39.c = v14;
        *(float64x2_t *)&v39.tx = v15;
        v46.origin.x = v18;
        v46.origin.y = v17;
        v46.size.width = v19;
        v47 = CGRectApplyAffineTransform(v46, &v39);
LABEL_13:
        *(CGRect *)(a1 + 48) = v47;
        goto LABEL_14;
      }
      v26 = (float64x2_t *)(a3 + 48);
    }
    else
    {
      if (a2 == 5)
      {
        v29 = *(_OWORD *)(a3 + 32);
        v30 = *(_OWORD *)(a3 + 48);
        v34 = *(float64x2_t *)(a3 + 16);
        v35 = v29;
        *(_OWORD *)v36 = v30;
        *(double *)&v31 = RB::operator*(&v34, (float64x2_t *)a1);
        *(_OWORD *)a1 = v31;
        *(_OWORD *)(a1 + 16) = v32;
        *(_OWORD *)(a1 + 32) = v33;
        RBPathBoundingRect(*(RBPath *)a3, (const RB::AffineTransform *)a1);
        goto LABEL_13;
      }
      if (a2 != 6)
        return;
      v20 = *(double *)(a3 + 16);
      v21 = rb_line_cap(*(_DWORD *)(a3 + 24));
      v22 = rb_line_join((CGLineJoin)*(_DWORD *)(a3 + 28));
      v23 = *(double *)(a3 + 32);
      *(_QWORD *)&v34.f64[0] = off_24C229778;
      *(float *)&v34.f64[1] = v20 * (float)(0.5 * RB::AffineTransform::scale((float64x2_t *)a1));
      v24 = v23;
      LOBYTE(v35) = v21;
      BYTE1(v35) = v22;
      *((float *)&v35 + 1) = v24 * v24;
      *((int32x2_t *)&v35 + 1) = vdup_n_s32(0x7F800000u);
      *(_QWORD *)v36 = 0x7F0000007FLL;
      memset(&v36[8], 0, 40);
      v37 = 1;
      v38 = 0;
      RBPathMap(*(CGPathRef *)a3, *(void **)(a3 + 8), (uint64_t (**)(RB::Path::Mapper *__hidden))&v34, (float64x2_t *)a1);
      v25 = (uint32x2_t)vcgt_f32(*(float32x2_t *)v36, *(float32x2_t *)((char *)&v35 + 8));
      if ((vpmin_u32(v25, v25).u32[0] & 0x80000000) != 0)
      {
        v27 = vcvtq_f64_f32(*(float32x2_t *)((char *)&v35 + 8));
        v28 = vcvtq_f64_f32(vsub_f32(*(float32x2_t *)v36, *(float32x2_t *)((char *)&v35 + 8)));
        goto LABEL_11;
      }
      v26 = (float64x2_t *)MEMORY[0x24BDBF070];
    }
    v27 = *v26;
    v28 = v26[1];
LABEL_11:
    *(float64x2_t *)(a1 + 48) = v27;
    *(float64x2_t *)(a1 + 64) = v28;
LABEL_14:
    *(_BYTE *)(a1 + 80) = 1;
  }
}

uint64_t rb_line_join(CGLineJoin a1)
{
  if (a1 == kCGLineJoinBevel)
    return 2;
  else
    return a1 != kCGLineJoinMiter;
}

uint64_t *RB::Coverage::StrokeablePath::StrokeablePath(uint64_t *a1, uint64_t a2, size_t *a3)
{
  uint64_t v6;
  uint64_t v7;
  __int128 *v8;
  _OWORD *v9;
  __int128 v10;
  __int128 v11;
  char *v12;
  char *v13;

  *a1 = RBPathRetain(*(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  a1[1] = v6;
  a1[2] = 0;
  a1[3] = *(_QWORD *)(a2 + 24);
  v7 = *(_QWORD *)(a2 + 32);
  a1[4] = v7;
  a1[5] = 0;
  v8 = *(__int128 **)(a2 + 16);
  if (v8)
  {
    v9 = (_OWORD *)((a3[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v9 + 3) > a3[3])
      v9 = (_OWORD *)RB::Heap::alloc_slow(a3, 0x30uLL, 15);
    else
      a3[2] = (size_t)(v9 + 3);
    v10 = *v8;
    v11 = v8[2];
    v9[1] = v8[1];
    v9[2] = v11;
    *v9 = v10;
    a1[2] = (uint64_t)v9;
    v7 = a1[4];
  }
  if (v7)
  {
    v12 = (char *)((a3[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
    v13 = &v12[4 * v7];
    if ((unint64_t)v13 > a3[3])
    {
      v12 = (char *)RB::Heap::alloc_slow(a3, 4 * v7, 3);
      v7 = a1[4];
      if (!v7)
        goto LABEL_9;
    }
    else
    {
      a3[2] = (size_t)v13;
    }
    memmove(v12, *(const void **)(a2 + 40), 4 * v7);
LABEL_9:
    a1[5] = (uint64_t)v12;
  }
  return a1;
}

void sub_209AEF784(_Unwind_Exception *a1)
{
  uint64_t *v1;

  RBPathRelease(*v1, v1[1]);
  _Unwind_Resume(a1);
}

uint64_t RB::Stroke::Dasher::prepare_pattern(uint64_t this, char *a2, float *a3)
{
  float v3;
  float v4;
  float v5;

  if ((this & 1) != 0)
    RB::precondition_failure((RB *)"dash pattern counts must be even", a2, a3);
  if (this)
  {
    v3 = 0.0;
    do
    {
      v4 = fabsf(*(float *)a2);
      if ((*(_DWORD *)a2 & 0x7FFFFFFFu) >= 0x7F800000)
        v5 = 0.0;
      else
        v5 = v4;
      *(float *)a2 = v5;
      a2 += 4;
      v3 = v5 + v3;
      --this;
    }
    while (this);
    return v3 > 0.00000011921;
  }
  return this;
}

void *RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,24ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,24ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(24 * a3);
    v6 = v5 / 0x18;
    if (v5 / 0x18 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t `anonymous namespace'::make_wrapped_path<RBPathCopyTransformedPath::TransformArgs>(RBPath,RBPathCopyTransformedPath::TransformArgs &&)::{lambda(void const*)#2}::__invoke(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void RB::DisplayList::Layer::make_task(uint64_t a1@<X0>, MTLPixelFormat a2@<X1>, __n128 *a3@<X2>, unsigned int a4@<W3>, uint64_t a5@<X4>, __n128 *a6@<X5>, uint64_t *a7@<X8>, double a8@<D0>, double a9@<D1>, double a10@<D2>, int32x2_t a11@<D3>)
{
  char v12;
  uint64_t *v14;
  __n128 v15;
  int v16;
  char v18;
  unsigned __int8 v19;
  int v20;
  uint64_t v21;
  RB::DisplayList::Layer *v22;
  int v23;
  uint32x2_t v24;
  uint32x2_t v25;
  int v26;
  BOOL v27;
  unsigned int *v28;
  int8x8_t v29;
  char v30;
  uint64_t v31;
  __n128 *v32;
  MTLPixelFormat v33;
  __n128 v34;
  uint64_t v35;
  float32x2_t *v36;
  uint64_t v37;
  float32x2_t v38;
  float32x2_t v39;
  uint32x2_t v40;
  unsigned __int32 v41;
  float32x2_t v42;
  float32x2_t v43;
  uint64_t v44;
  float v45;
  float v46;
  float32x2_t v47;
  float32x2_t v48;
  uint32x2_t v49;
  int8x8_t v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  int32x2_t v56;
  uint64_t v57;
  __int16 v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  const char *v62;
  unsigned __int8 v63;
  int32x2_t v64;
  char v65;
  unsigned int v66;
  int *v67;
  int v68;
  uint64_t v69;
  int v70;
  _QWORD *v71;
  uint64_t v72;
  uint64_t v73;
  char v74;
  _BYTE *v75;
  uint32x2_t v76;
  int8x8_t v77;
  unsigned int v78;
  unint64_t v79;
  unsigned int v80;
  uint64_t *v81;
  int *v82;
  int v83;
  signed __int32 v84;
  int32x2_t *v85;
  int32x2_t v86;
  int32x2_t v87;
  uint64_t v88;
  unsigned int v89;
  int v90;
  unsigned int v91;
  unsigned int v92;
  unsigned int v93;
  int *v94;
  uint64_t v95;
  __n128 *v96;
  __n128 **v97;
  int *v98;
  _QWORD *v99;
  int v100;
  RB::Heap *v101;
  unint64_t v102;
  float32x2_t *v103;
  RB::Heap *v104;
  RB::Heap *v105;
  int *v106;
  uint64_t v107;
  uint64_t v108;
  int *v109;
  unsigned __int16 v110;
  BOOL v111;
  char v112;
  unsigned int *v113;
  int v114;
  unsigned int v115;
  uint64_t v116;
  uint64_t v117;
  _QWORD *v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t *v121;
  uint64_t *v122;
  size_t *v123;
  unint64_t v124;
  unint64_t v125;
  _DWORD *v126;
  int v127;
  RB::DisplayList::Layer *v128;
  _QWORD *v129;
  uint64_t v130;
  unint64_t v131;
  int v132;
  uint64_t v133;
  char v134;
  unsigned int *v135;
  _BYTE v136[104];
  uint64_t *v137;
  int v138;
  uint64_t v139;
  int v140;
  uint64_t *v141;
  char *v142;
  RB::Heap *v143;
  __n128 *v144;
  unsigned __int8 *v145;
  RB::DisplayList::Layer *v146;
  unint64_t *n128_u64;
  __n128 *v148;
  uint64_t *v149;
  __n128 *v150;
  int *v151;
  int v152;
  int *v153;
  uint64_t v154;
  int *v155;
  _QWORD v156[3];
  int v157;
  __n128 v158[5];
  int v159;
  int v160;
  int v161;
  int32x2_t v162[2];
  int32x2_t v163[2];
  int32x2_t v164[2];
  int32x2_t v165[2];
  int32x2_t v166[2];
  int32x2_t v167[2];
  size_t *v168;
  __n128 **v169;
  int *v170;
  __n128 *v171;
  int v172;
  __n128 v173;
  BOOL v174;
  __n128 v175;
  __n128 v176;
  size_t *v177;
  unint64_t v178;
  _QWORD v179[131];

  v148 = a6;
  v149 = a7;
  v12 = a4;
  v179[129] = *MEMORY[0x24BDAC8D0];
  v14 = (uint64_t *)(a2 + 8);
  v139 = *(_QWORD *)(a2 + 8);
  v138 = *(unsigned __int8 *)(a2 + 28);
  v145 = (unsigned __int8 *)(a2 + 28);
  v146 = (RB::DisplayList::Layer *)a1;
  v175.n128_f64[0] = a8;
  v175.n128_f64[1] = a9;
  v174 = (a4 & 2) != 0;
  v15 = v175;
  v173 = v175;
  v16 = *(_DWORD *)(a1 + 60);
  if ((v16 & 0x20) != 0)
  {
    *(_BYTE *)(a2 + 28) = *(_BYTE *)(a2 + 29);
    if (((a4 >> 1) & 1) == 0)
      goto LABEL_18;
    goto LABEL_17;
  }
  if ((v16 & 8) != 0)
  {
    v19 = 1;
    v21 = 25;
    v22 = v146;
  }
  else
  {
    if ((v16 & 2) != 0)
    {
      v19 = *(_BYTE *)(a2 + 29) & 0xFE;
      v20 = 1;
    }
    else
    {
      v18 = *(_BYTE *)(a2 + 29);
      if ((v16 & 4) != 0)
        v19 = v18 | 1;
      else
        v19 = *(_BYTE *)(a2 + 29);
      v20 = (v16 & 4) == 0 && (v18 & 1) == 0;
    }
    v22 = v146;
    v23 = RB::DisplayList::Layer::max_depth(v146);
    v21 = RB::color_depth_layer_format(v23, v20, **(_QWORD **)a2);
  }
  *v14 = v21;
  *v145 = v19;
  a1 = RB::DisplayList::Layer::compute_roi(v22, (int32x2_t *)&v175, (int32x2_t *)&v173, &v174, a3, v15);
  if (!(_DWORD)a1)
  {
    *v14 = v139;
    *v145 = v138;
LABEL_24:
    *v149 = 0;
    return;
  }
  if (v174)
LABEL_17:
    a1 = RB::Bounds::inset((int32x2_t *)&v175, 0xFFFFFFFF, 0xFFFFFFFF, v15.n128_f64[0], a9, a10, a11);
LABEL_18:
  v24 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v175.n128_i8[8]);
  if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0)
    goto LABEL_24;
  v25 = (uint32x2_t)vcgt_s32(*(int32x2_t *)&v175.n128_i8[8], (int32x2_t)0x800000008000);
  if ((vpmax_u32(v25, v25).u32[0] & 0x80000000) != 0)
    goto LABEL_24;
  *v149 = 0;
  v152 = *((_DWORD *)v146 + 15);
  if ((v152 & 0x10) != 0)
  {
    MEMORY[0x24BDAC7A8](a1, a2);
    memset(v136, 0, 96);
    v153 = (int *)v136;
    RB::BoundsAccumulator::reset((RB::BoundsAccumulator *)v136);
    if ((v12 & 1) != 0)
    {
      RB::BoundsAccumulator::add(v153, (int32x2_t *)&v175);
      v26 = 1;
      if (a5)
        goto LABEL_22;
    }
    else
    {
      v26 = 0;
      if (a5)
        goto LABEL_22;
    }
  }
  else
  {
    v153 = 0;
    v26 = v12 & 1;
    if (a5)
    {
LABEL_22:
      v27 = v148 != 0;
LABEL_28:
      v28 = 0;
      v140 = 2 * v26;
      v142 = (char *)v179;
      v143 = (RB::Heap *)(a2 + 80);
      v29 = (int8x8_t)vdup_n_s32(0x7F7FFFFFu);
      v30 = v152;
      v141 = v14;
      while (1)
      {
        LODWORD(v31) = 6 * *(_QWORD *)(a2 + 16) * HIDWORD(*(_QWORD *)(a2 + 16));
        if ((int)v31 <= 0x400000)
          v31 = 0x400000;
        else
          v31 = v31;
        v154 = v31;
        v172 = 0;
        v34.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>(v143, (uint64_t)v146, v14, v145, (uint64_t)&v175, (uint64_t *)&v173, (char *)&v174);
        if (!v28)
        {
          v32[8].n128_u8[0] = (v32[8].n128_u8[0] & 0xFD | v140) ^ 2;
          if (v27)
          {
            v34 = *v148;
            v148 = 0;
            v32[9] = v34;
          }
          else
          {
            v148 = 0;
          }
        }
        v150 = v32 + 10;
        v168 = (size_t *)a2;
        v169 = &v171;
        v170 = &v172;
        v171 = v32 + 10;
        n128_u64 = v32[12].n128_u64;
        v155 = (int *)v32;
        if (a5)
        {
          v35 = 0;
          v144 = v32 + 13;
          while (v35 < v154 && v172 <= 19999)
          {
            v34.n128_u64[1] = v175.n128_u64[1];
            v176 = v175;
            v36 = *(float32x2_t **)(a5 + 24);
            if (v36)
            {
              RB::Bounds::Bounds(v167, v36[2], v36[3]);
              RB::Bounds::intersect((int32x2_t *)&v176, v167[0], v167[1]);
              v37 = *(_QWORD *)&v36[1] & 1;
              v34.n128_u64[0] = (unint64_t)vcgtz_s32(*(int32x2_t *)&v176.n128_i8[8]);
              if ((vpmin_u32((uint32x2_t)v34.n128_u64[0], (uint32x2_t)v34.n128_u64[0]).u32[0] & 0x80000000) != 0
                && !v37)
              {
                *(double *)&v38 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a5 + 144))(a5, 0);
                RB::Bounds::Bounds(v166, v38, v39);
                RB::Bounds::intersect((int32x2_t *)&v176, v166[0], v166[1]);
                LODWORD(v37) = 0;
              }
            }
            else
            {
              LODWORD(v37) = 1;
            }
            v40 = (uint32x2_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v176.n128_i8[8]);
            v34.n128_u64[0] = (unint64_t)vpmax_u32(v40, v40);
            v41 = v34.n128_u32[0];
            if ((v34.n128_u32[0] & 0x80000000) == 0 && (_DWORD)v37)
            {
              if ((*(_WORD *)(a5 + 46) & 0x200) == 0)
                goto LABEL_50;
              *(double *)&v42 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a5 + 144))(a5, 0);
              RB::Bounds::Bounds(v165, v42, v43);
              RB::Bounds::intersect((int32x2_t *)&v176, v165[0], v165[1]);
              v34.n128_u64[0] = (unint64_t)vcgt_s32((int32x2_t)0x100000001, *(int32x2_t *)&v176.n128_i8[8]);
              v34.n128_u64[0] = (unint64_t)vpmax_u32((uint32x2_t)v34.n128_u64[0], (uint32x2_t)v34.n128_u64[0]);
              v41 = v34.n128_u32[0];
            }
            if ((v41 & 0x80000000) != 0)
            {
              a5 = *(_QWORD *)(a5 + 8);
              if (!a5)
                break;
            }
            else
            {
LABEL_50:
              if ((*(_WORD *)(a5 + 46) & 0x200) != 0)
              {
                v44 = *(_QWORD *)(a5 + 48);
                if ((*(_WORD *)(v44 + 60) & 0x2001) != 0)
                {
                  if ((v30 & 0x10) != 0)
                  {
                    v158[0] = v176;
                    v164[0] = 0;
                    v164[1] = 0;
                    if (RB::DisplayList::Layer::compute_roi((RB::DisplayList::Layer *)v44, (int32x2_t *)v158, v164, (BOOL *)&v161, &v175, v176))
                    {
                      v34.n128_u32[0] = 0;
                      v45 = *(float *)(v44 + 48);
                      if (v45 == 0.0)
                        v45 = 1.0;
                      v46 = v45;
                      v47 = vrecpe_f32((float32x2_t)LODWORD(v45));
                      v48 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v46), v47), v47);
                      v48.i32[0] = vmul_f32(v48, vrecps_f32((float32x2_t)LODWORD(v46), v48)).u32[0];
                      v49 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v158[0].n128_i8[8], (int32x2_t)0x8000000080000000);
                      v50 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v34.n128_u64[0], (int32x2_t)vpmin_u32(v49, v49)), 0);
                      *(float32x2_t *)&v51 = RB::Bounds::Bounds(v163, vmul_n_f32((float32x2_t)vbsl_s8(v50, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v158[0].n128_u64[0])), v48.f32[0]), vmul_n_f32((float32x2_t)vbsl_s8(v50, v29, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v158[0].n128_i8[8])), v48.f32[0]));
                      if (RB::BoundsAccumulator::intersects((RB::BoundsAccumulator *)v153, v163, v51, v52, v53, v54, v55, v56))
                      {
                        break;
                      }
                    }
                  }
                  else if (v150->n128_u64[0])
                  {
                    break;
                  }
                }
                if (*(_BYTE *)(v44 + 64) == 2
                  && ((*(uint64_t (**)(_QWORD, __n128 *, int *))(**(_QWORD **)(v44 + 24) + 112))(*(_QWORD *)(v44 + 24), &v176, v153) & 1) != 0)
                {
                  break;
                }
              }
              v57 = *(_QWORD *)(a5 + 8);
              if ((v30 & 0x10) != 0)
                RB::BoundsAccumulator::add(v153, (int32x2_t *)&v176);
              v58 = *(_WORD *)(a5 + 46);
              if ((v58 & 0x200) != 0)
              {
                v60 = *(_QWORD *)(a5 + 48);
                if (RB::may_discard_alpha(v58 & 0x3F))
                  v61 = 0;
                else
                  v61 = 2;
                RB::DisplayList::Layer::make_task(v164, v60, a2, &v175, v61, 0, 0, v176.n128_f64[0], v176.n128_f64[1]);
                if (v164[0])
                {
                  v63 = atomic_load((unsigned __int8 *)&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline);
                  if ((v63 & 1) == 0
                    && __cxa_guard_acquire(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline))
                  {
                    v110 = RB::debug_BOOL((RB *)"RB_INLINE_LAYERS", v62);
                    if ((_BYTE)v110)
                      v111 = 0;
                    else
                      v111 = v110 >= 0x100u;
                    v112 = !v111;
                    _ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline = v112;
                    __cxa_guard_release(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline);
                  }
                  v64 = v164[0];
                  if ((*(_BYTE *)(a2 + 30) & 2) == 0)
                    goto LABEL_86;
                  if (!_ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline)
                    goto LABEL_86;
                  v65 = *(_BYTE *)(*(_QWORD *)v164 + 128);
                  if ((v65 & 8) != 0)
                    goto LABEL_86;
                  if (*(_QWORD *)(*(_QWORD *)v164 + 24))
                    goto LABEL_86;
                  v67 = (int *)(v60 + 60);
                  v66 = *(_DWORD *)(v60 + 60);
                  if ((v66 & 0x10) != 0 || (v66 & 1) != 0 && *(_BYTE *)(v60 + 67))
                    goto LABEL_86;
                  if ((v66 & 6) != 0)
                  {
                    v68 = (v66 >> 2) & 1;
                    if ((v66 & 2) != 0)
                      v68 = 0;
                    if (v68 != *((unsigned __int8 *)v155 + 72))
                      goto LABEL_86;
                  }
                  if ((*((_DWORD *)v146 + 15) ^ *(_DWORD *)(v60 + 60)) & 8 | *(_DWORD *)(v60 + 60) & 0x80
                    || *(_BYTE *)(v60 + 64)
                    || *(float *)(v60 + 48) != 0.0)
                  {
                    goto LABEL_86;
                  }
                  v99 = *(_QWORD **)(v60 + 16);
                  v137 = (uint64_t *)(v60 + 16);
                  v151 = (int *)(v60 + 60);
                  if (v99)
                  {
                    while (1)
                    {
                      v100 = (*(uint64_t (**)(_QWORD *))(*v99 + 88))(v99);
                      v67 = v151;
                      if (!v100)
                        break;
                      v99 = (_QWORD *)v99[1];
                      if (!v99)
                      {
                        v65 = *(_BYTE *)(*(_QWORD *)&v64 + 128);
                        goto LABEL_122;
                      }
                    }
LABEL_86:
                    v69 = RB::RenderTask::bytes(*(RB::RenderTask **)&v64, (MTLPixelFormat)v62);
                    RB::DisplayList::LayerTask::add_task((uint64_t)v155, a5, 0, (uint64_t *)v164);
                    v35 += v69;
                    v59 = a5;
                    if (v64)
                    {
LABEL_87:
                      v70 = *(_DWORD *)(*(_QWORD *)&v64 + 8) - 1;
                      *(_DWORD *)(*(_QWORD *)&v64 + 8) = v70;
                      if (!v70)
                        (*(void (**)(int32x2_t))(**(_QWORD **)&v64 + 8))(v64);
                    }
                  }
                  else
                  {
LABEL_122:
                    v101 = v143;
                    if ((v65 & 1) != 0)
                    {
                      v158[0] = v176;
                      v103 = *(float32x2_t **)(a5 + 24);
                      if (v103)
                      {
                        RB::Bounds::Bounds(v162, v103[2], v103[3]);
                        RB::Bounds::intersect((int32x2_t *)v158, v162[0], v162[1]);
                        v67 = v151;
                      }
                    }
                    else
                    {
                      v102 = *(_QWORD *)(*(_QWORD *)&v64 + 56);
                      v158[0].n128_u64[0] = *(_QWORD *)(*(_QWORD *)&v64 + 104);
                      v158[0].n128_u64[1] = v102;
                    }
                    v161 = *v67 & 1;
                    v160 = 1;
                    v159 = 0;
                    v163[0] = 0;
                    v104 = v101;
                    v105 = v101;
                    v106 = v67;
                    RB::Heap::emplace<RB::DisplayList::SpillItem,RB::Shader::SpillMode,unsigned int &,int,RB::BlendMode,RB::Bounds &,decltype(nullptr)>(v104, &v161, v67, &v160, &v159, v158);
                    v151 = (int *)v107;
                    v163[0].i32[0] = 2;
                    v161 = *(_WORD *)(a5 + 46) & 0x3F;
                    _ZN2RB4Heap7emplaceINS_11DisplayList9SpillItemEJNS_6Shader9SpillModeERjRKDF16_RKNS_9BlendModeERNS_6BoundsERPNS2_11LayerFilterEEEEPT_DpOT0_(v105, (int *)v163, v106, (__int16 *)(a5 + 44), &v161, v158, v137);
                    v59 = v108;
                    *(_QWORD *)(v108 + 24) = *(_QWORD *)(a5 + 24);
                    _ZZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fENK3__2clES9_((uint64_t *)&v168, (uint64_t)v151);
                    v109 = v155;
                    v64 = v164[0];
                    RB::DisplayList::LayerTask::append_task(v155, *(_QWORD *)v164, (_QWORD **)&v171, (unsigned int *)&v172);
                    *((_BYTE *)v109 + 128) |= 8u;
                    if (v64)
                      goto LABEL_87;
                  }
                  v30 = v152;
                }
                else
                {
                  v59 = a5;
                }
                if (*(_BYTE *)(v60 + 64) == 2)
                {
                  *(_QWORD *)(a2 + 32) = v155;
                  (*(void (**)(_QWORD, MTLPixelFormat, __n128 *, double, double))(**(_QWORD **)(v60 + 24)
                                                                                           + 104))(*(_QWORD *)(v60 + 24), a2, &v175, v176.n128_f64[0], v176.n128_f64[1]);
                  *(_QWORD *)(a2 + 32) = 0;
                  v35 += *(_QWORD *)(a2 + 72);
                  *(_QWORD *)(a2 + 72) = 0;
                }
                goto LABEL_93;
              }
              v59 = a5;
LABEL_93:
              if ((v37 & 1) == 0)
              {
                v71 = *(_QWORD **)(v59 + 24);
                if (v71)
                {
                  v151 = (int *)v57;
                  v72 = 1;
                  v73 = -1;
                  v74 = 1;
                  do
                  {
                    v75 = (_BYTE *)(v71[1] & 0xFFFFFFFFFFFFFFFELL);
                    if ((v75[45] & 1) == 0)
                    {
                      v34.n128_u32[0] = 0;
                      v76 = (uint32x2_t)vceq_s32(*(int32x2_t *)&v176.n128_i8[8], (int32x2_t)0x8000000080000000);
                      v77 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v34.n128_u64[0], (int32x2_t)vpmin_u32(v76, v76)), 0);
                      if (((*(uint64_t (**)(_BYTE *, double, double))(*(_QWORD *)v75 + 32))(v75, COERCE_DOUBLE(vbsl_s8(v77, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32((int32x2_t)v176.n128_u64[0]))), COERCE_DOUBLE(vbsl_s8(v77, v29, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)&v176.n128_i8[8])))) & 1) == 0)
                      {
                        v74 = 0;
                        v73 &= ~v72;
                      }
                    }
                    v72 *= 2;
                    v71 = (_QWORD *)*v71;
                  }
                  while (v71);
                  if ((v74 & 1) == 0)
                  {
                    v78 = v155[54];
                    if (v78
                      && (v79 = v144->n128_u64[0],
                          v80 = v78 - 1,
                          *(_QWORD *)(v144->n128_u64[0] + 48 * (v78 - 1)) == *(_QWORD *)(v59 + 24)))
                    {
                      v81 = v14;
                      v85 = (int32x2_t *)(v79 + 48 * v80);
                      v86 = v85[3];
                      v85 += 3;
                      RB::Bounds::Union(v85 - 1, (int32x2_t)v176.n128_u64[0], *(int32x2_t *)&v176.n128_i8[8]);
                      v87 = vmul_s32(vzip1_s32(*v85, v86), vzip2_s32(*v85, v86));
                      v84 = vsub_s32(v87, vdup_lane_s32(v87, 1)).u32[0];
                      *(_DWORD *)(v79 + 48 * v80 + 40) = v172;
                      v82 = v155;
                      v83 = v155[54];
                    }
                    else
                    {
                      v81 = v14;
                      v82 = v155;
                      if (v155[55] < v78 + 1)
                      {
                        RB::vector<RB::DisplayList::LayerTask::ClipInfo,0ul,unsigned int>::reserve_slow((uint64_t)v144, v78 + 1);
                        v82 = v155;
                        v78 = v155[54];
                      }
                      RB::DisplayList::LayerTask::ClipInfo::ClipInfo(*((_QWORD *)v82 + 26) + 48 * v78, a2, *(_QWORD **)(v59 + 24), v172, v176.n128_f64[0], v176.n128_f64[1]);
                      v83 = v82[54] + 1;
                      v82[54] = v83;
                      v84 = vmul_lane_s32(*(int32x2_t *)&v176.n128_i8[8], *(int32x2_t *)&v176.n128_i8[8], 1).u32[0];
                    }
                    v88 = *((_QWORD *)v82 + 26);
                    v89 = v83 - 1;
                    v90 = *(unsigned __int8 *)(v88 + 48 * (v83 - 1) + 44);
                    v91 = v82[50];
                    v92 = v91 + 1;
                    if (v82[51] < v91 + 1)
                    {
                      RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)n128_u64, v92);
                      v14 = v81;
                      v91 = v155[50];
                      v88 = *((_QWORD *)v155 + 26);
                      v92 = v91 + 1;
                      v93 = v155[54] - 1;
                    }
                    else
                    {
                      v93 = v89;
                      v14 = v81;
                    }
                    v94 = v155;
                    v95 = *((_QWORD *)v155 + 24) + 16 * v91;
                    *(_QWORD *)v95 = v59;
                    *(_DWORD *)(v95 + 8) = v89;
                    v94[50] = v92;
                    v35 += v90 * (uint64_t)v84;
                    *(_QWORD *)(v88 + 48 * v93 + 8) &= v73;
                  }
                  v30 = v152;
                  v57 = (uint64_t)v151;
                }
              }
              (*(void (**)(uint64_t, MTLPixelFormat))(*(_QWORD *)v59 + 168))(v59, a2);
              if ((*(_WORD *)(v59 + 46) & 0x4000) != 0)
                *((_BYTE *)v155 + 128) |= 0x10u;
              v96 = (__n128 *)((v168[12] + 7) & 0xFFFFFFFFFFFFFFF8);
              if ((unint64_t)v96[1].n128_u64 > v168[13])
                v96 = (__n128 *)RB::Heap::alloc_slow(v168 + 10, 0x10uLL, 7);
              else
                v168[12] = (size_t)v96[1].n128_u64;
              v96->n128_u64[0] = 0;
              v96->n128_u64[1] = v59;
              v97 = v169;
              v98 = v170;
              (*v169)->n128_u64[0] = (unint64_t)v96;
              *v97 = v96;
              ++*v98;
              a5 = v57;
              if (!v57)
                break;
            }
          }
        }
        v113 = (unsigned int *)v155;
        if (v155[54])
        {
          v114 = *(_DWORD *)(*(_QWORD *)a2 + 92) + 1;
          *(_DWORD *)(*(_QWORD *)a2 + 92) = v114;
          RB::Heap::Heap((RB::Heap *)&v176, v142, 1024, 0);
          RB::UntypedTable::UntypedTable((RB::UntypedTable *)v158, 0, 0, 0, 0, (RB::Heap *)&v176);
          v115 = v113[54];
          if (v115)
          {
            v116 = *((_QWORD *)v155 + 26);
            v117 = v116 + 48 * v115;
            do
            {
              if (!*(_DWORD *)(v116 + 32))
              {
                *(_DWORD *)(v116 + 32) = v114;
                v118 = *(_QWORD **)v116;
                if (*(_QWORD *)v116)
                {
                  v119 = 1;
                  do
                  {
                    if ((*(_QWORD *)(v116 + 8) & v119) == 0)
                    {
                      v120 = v118[1] & 0xFFFFFFFFFFFFFFFELL;
                      if ((*(_BYTE *)(v120 + 45) & 2) != 0)
                      {
                        v121 = *(uint64_t **)(v120 + 48);
                        v122 = RB::UntypedTable::lookup((RB::UntypedTable *)v158, v121, 0);
                        if (v122)
                        {
                          RB::Bounds::Union((int32x2_t *)v122, *(int32x2_t *)(v116 + 16), *(int32x2_t *)(v116 + 24));
                        }
                        else
                        {
                          v123 = (size_t *)(((unint64_t)v177 + 7) & 0xFFFFFFFFFFFFFFF8);
                          if ((unint64_t)(v123 + 2) > v178)
                            v123 = (size_t *)RB::Heap::alloc_slow(v176.n128_u64, 0x10uLL, 7);
                          else
                            v177 = v123 + 2;
                          *(_OWORD *)v123 = *(_OWORD *)(v116 + 16);
                          RB::UntypedTable::insert((size_t **)v158, (size_t *)v121, v123);
                        }
                      }
                      else
                      {
                        (*(void (**)(unint64_t, MTLPixelFormat))(*(_QWORD *)v120 + 48))(v120, a2);
                      }
                    }
                    v119 *= 2;
                    v118 = (_QWORD *)*v118;
                  }
                  while (v118);
                }
              }
              v116 += 48;
            }
            while (v116 != v117);
          }
          v113 = (unsigned int *)v155;
          v156[0] = v155;
          v156[1] = &v175;
          v156[2] = a2;
          v157 = v114;
          RB::UntypedTable::for_each((uint64_t)v158, (void (*)(const void *, const void *, void *))_ZZNK2RB5TableIPKNS_11DisplayList5LayerEPNS_6BoundsEE8for_eachIZNKS2_9make_taskERNS1_11RenderStateES5_PKS5_jPKNS1_4ItemEPKDv4_fE3__4EEvT_ENUlPKvSM_PvE_8__invokeESM_SM_SN_, v156);
          RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v158);
          RB::Heap::~Heap((RB::Heap *)&v176);
          v14 = v141;
          v30 = v152;
        }
        v124 = v113[46];
        if ((_DWORD)v124)
          std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *> *,false>(*((_QWORD *)v113 + 22), (unint64_t *)(*((_QWORD *)v113 + 22) + 24 * v124), (uint64_t)&v176, 126 - 2 * __clz(v124), 1);
        v125 = v113[50];
        if ((_DWORD)v125)
          _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZNK2RB11DisplayList5Layer9make_taskERNS3_11RenderStateENS2_6BoundsEPKS7_jPKNS3_4ItemEPKDv4_fE3__0PNS_4pairISC_jEELb0EEEvT1_SL_T0_NS_15iterator_traitsISL_E15difference_typeEb(*n128_u64, *n128_u64 + 16 * v125, 126 - 2 * __clz(v125), 1);
        v126 = (_DWORD *)*v149;
        if (*v149)
          break;
        *v149 = (uint64_t)v113;
        if ((v30 & 0x10) != 0)
          goto LABEL_167;
LABEL_168:
        v27 = v148 != 0;
        v28 = v113;
        if (!(a5 | (unint64_t)v148))
          goto LABEL_169;
      }
      v34.n128_f64[0] = RB::RenderTask::set_continuation(*v149, (uint64_t)v113);
      *v149 = (uint64_t)v113;
      v127 = v126[2] - 1;
      v126[2] = v127;
      if (!v127)
        (*(void (**)(_DWORD *, double))(*(_QWORD *)v126 + 8))(v126, v34.n128_f64[0]);
      if ((v30 & 0x10) == 0)
        goto LABEL_168;
LABEL_167:
      v34.n128_f64[0] = RB::BoundsAccumulator::reset((RB::BoundsAccumulator *)v153);
      goto LABEL_168;
    }
  }
  a5 = *(_QWORD *)v146;
  v27 = v148 != 0;
  if (*(_QWORD *)v146 | (unint64_t)v148)
    goto LABEL_28;
  v34.n128_f64[0] = RB::Heap::emplace<RB::DisplayList::LayerTask,RB::DisplayList::Layer const&,MTLPixelFormat &,RB::ColorSpace &,RB::Bounds &,RB::Bounds &,BOOL &>((RB::Heap *)(a2 + 80), (uint64_t)v146, v14, v145, (uint64_t)&v175, (uint64_t *)&v173, (char *)&v174);
  v113 = v135;
  *v149 = (uint64_t)v135;
  *((_BYTE *)v135 + 128) = (v135[32] & 0xFD | (2 * v26)) ^ 2;
LABEL_169:
  v128 = v146;
  v129 = (_QWORD *)*((_QWORD *)v146 + 2);
  if (v129)
  {
    do
    {
      if ((*(unsigned int (**)(_QWORD *, __n128))(*v129 + 40))(v129, v34) == 5)
      {
        v130 = *(_QWORD *)(v33 + 32);
        if (v130)
        {
          if ((*(_WORD *)(v130 + 46) & 0x200) != 0)
          {
            RB::DisplayList::Layer::make_task(&v176, *(_QWORD *)(v130 + 48), a2, &v175, 0, 0, 0, v175.n128_f64[0], v175.n128_f64[1]);
            RB::DisplayList::LayerTask::add_task((uint64_t)v113, v130, 0, (uint64_t *)&v176);
            v131 = v176.n128_u64[0];
            if (v176.n128_u64[0])
            {
              v132 = *(_DWORD *)(v176.n128_u64[0] + 8) - 1;
              *(_DWORD *)(v176.n128_u64[0] + 8) = v132;
              if (!v132)
                (*(void (**)(unint64_t))(*(_QWORD *)v131 + 8))(v131);
            }
          }
        }
      }
      v129 = (_QWORD *)v129[1];
    }
    while (v129);
    v128 = v146;
    v133 = *((_QWORD *)v146 + 2);
    v113 = (unsigned int *)*v149;
  }
  else
  {
    v133 = 0;
  }
  *((_QWORD *)v113 + 21) = v133;
  if ((*((_BYTE *)v128 + 60) & 0x20) != 0)
  {
    if ((*(_BYTE *)(a2 + 30) & 4) != 0)
    {
      if (RB::RenderParams::srgb_alpha((RB::RenderParams *)a2, v33))
        v134 = 4;
      else
        v134 = 0;
    }
    else
    {
      v134 = 0;
    }
    *((_BYTE *)v113 + 128) = v113[32] & 0xFB | v134;
  }
  *v14 = v139;
  *v145 = v138;
}

void sub_209AF0790(_Unwind_Exception *a1)
{
  uint64_t v1;
  _DWORD *v3;
  int v4;
  _DWORD *v5;
  int v6;

  __cxa_guard_abort(&_ZGVZNK2RB11DisplayList5Layer9make_taskERNS0_11RenderStateENS_6BoundsEPKS4_jPKNS0_4ItemEPKDv4_fE12allow_inline);
  v3 = *(_DWORD **)(v1 + 328);
  if (v3)
  {
    v4 = v3[2] - 1;
    v3[2] = v4;
    if (!v4)
      (*(void (**)(_DWORD *))(*(_QWORD *)v3 + 8))(v3);
  }
  v5 = **(_DWORD ***)(v1 + 104);
  if (v5)
  {
    v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
      (*(void (**)(_DWORD *))(*(_QWORD *)v5 + 8))(v5);
  }
  _Unwind_Resume(a1);
}

void *RB::vector<RBColor,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,16ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,16ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(16 * a3);
    v6 = v5 >> 4;
    if (*a2 != (v5 >> 4))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::details::realloc_vector<unsigned int,48ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(48 * a3);
    v6 = v5 / 0x30;
    if (*a2 != (v5 / 0x30))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::UntypedTable::for_each(uint64_t this, void (*a2)(const void *, const void *, void *), void *a3)
{
  uint64_t v5;
  unint64_t v6;
  int v7;
  _QWORD *i;

  if (*(_QWORD *)(this + 56))
  {
    v5 = this;
    v6 = 0;
    v7 = *(_DWORD *)(this + 72);
    do
    {
      for (i = *(_QWORD **)(*(_QWORD *)(v5 + 48) + 8 * v6); i; i = (_QWORD *)*i)
        this = ((uint64_t (*)(_QWORD, _QWORD, void *))a2)(i[1], i[2], a3);
      ++v6;
    }
    while (!(v6 >> v7));
  }
  return this;
}

_DWORD *RB::RenderTask::set_texture(_DWORD *result, _DWORD *a2, double a3)
{
  _DWORD *v5;
  int v6;

  if (result)
  {
    v5 = result;
    while (1)
    {
      result = (_DWORD *)*((_QWORD *)v5 + 11);
      if (result != a2)
        break;
LABEL_9:
      *((double *)v5 + 8) = a3;
      v5 = (_DWORD *)*((_QWORD *)v5 + 3);
      if (!v5)
        return result;
    }
    if (result && (v6 = result[2] - 1, (result[2] = v6) == 0))
    {
      result = (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
      if (!a2)
        goto LABEL_8;
    }
    else if (!a2)
    {
LABEL_8:
      *((_QWORD *)v5 + 11) = a2;
      goto LABEL_9;
    }
    ++a2[2];
    goto LABEL_8;
  }
  return result;
}

void RB::Texture::~Texture(RB::Texture *this)
{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

  JUMPOUT(0x20BD16544);
}

{
  _DWORD *v2;
  int v3;

  *(_QWORD *)this = off_24C229970;
  v2 = (_DWORD *)*((_QWORD *)this + 3);
  if (v2)
  {
    v3 = v2[2] - 1;
    v2[2] = v3;
    if (!v3)
      (*(void (**)(_DWORD *))(*(_QWORD *)v2 + 8))(v2);
  }

}

uint64_t RB::Heap::emplace<RB::DisplayList::RootTexture,objc_object  {objcproto10MTLTexture}*({block_pointer}&)(void),RB::RenderPass::InitialState &>(RB::Heap *this, uint64_t *a2, int *a3)
{
  unint64_t v6;
  uint64_t result;
  uint64_t v8;
  int v9;

  v6 = *((_QWORD *)this + 3);
  result = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 48 > v6)
    result = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 48;
  v8 = *a2;
  v9 = *a3;
  *(_DWORD *)(result + 8) = 1;
  *(_QWORD *)(result + 16) = 0;
  *(_QWORD *)(result + 24) = 0;
  *(_QWORD *)result = &off_24C226198;
  *(_QWORD *)(result + 32) = v8;
  *(_DWORD *)(result + 40) = v9;
  *(_WORD *)(result + 44) = 0;
  return result;
}

_DWORD *RB::DisplayList::RootTexture::finalize(RB::DisplayList::RootTexture *this)
{
  _DWORD *result;
  int v2;

  *(_QWORD *)this = off_24C228D58;
  result = (_DWORD *)*((_QWORD *)this + 2);
  if (result)
  {
    v2 = result[2] - 1;
    result[2] = v2;
    if (!v2)
      return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

void RB::DisplayList::RootTexture::render(RB::DisplayList::RootTexture *this, unsigned __int8 *a2)
{
  __n128 v4;
  uint64_t v5;
  MTLPixelFormat v6;
  uint64_t v7;
  __n128 *v8;
  double v9;
  __n128 v10;
  __n128 v11;
  int32x2_t *v12;
  int32x2_t v13;
  void *v14;
  int32x2_t *v15;
  int32x2_t *v16;
  int32x2_t v17;
  double v18;
  __n128 v19;
  __n128 v20;
  int v21;
  NSObject *v22;
  uint8_t v23;
  _BYTE v24[7];
  id v25[20];
  uint64_t v26;
  int32x2_t v27;

  do
  {
    RB::RenderTaskTexture::render_dependencies(this, a2);
    if (!RB::DisplayList::RootTexture::make_texture((uint64_t)this, (MTLPixelFormat)a2))
      break;
    RB::RenderPass::RenderPass(v25, a2, *((_QWORD *)this + 2), 0, *((unsigned int *)this + 10), 0);
    RB::RenderPass::set_label(v25, CFSTR("RB: Root layer"));
    v5 = *((_QWORD *)this + 3);
    if (v5)
    {
      v6 = 5;
      v7 = *((_QWORD *)this + 3);
      do
      {
        v6 |= ((unint64_t)*(unsigned __int8 *)(v7 + 128) >> 1) & 8 | ((unint64_t)*(unsigned __int8 *)(v7 + 128) >> 2) & 2;
        v7 = *(_QWORD *)(v7 + 48);
      }
      while (v7 && *(_DWORD *)(v5 + 12) == *(_DWORD *)(v7 + 12));
    }
    else
    {
      v6 = MTLPixelFormatInvalid;
    }
    if (!RB::RenderPass::set_extra_attachments((uint64_t)v25, v6, v4))
    {
      RB::RenderPass::~RenderPass((RB::RenderPass *)v25);
      return;
    }
    v8 = (__n128 *)*((_QWORD *)this + 3);
    if (v8 && *((_DWORD *)this + 10) == 2)
    {
      RB::RenderPass::set_clear_color((uint64_t)v25, v8[9]);
      v8[8].n128_u8[0] &= ~2u;
      v8 = (__n128 *)*((_QWORD *)this + 3);
    }
    *((_DWORD *)this + 10) = 1;
    RB::RenderTaskTexture::render_all_tasks(this, (RB::RenderPass *)v25, a2);
    if (!*((_QWORD *)this + 3) && *((_BYTE *)this + 44))
    {
      if (*((_BYTE *)this + 45))
      {
        v12 = (int32x2_t *)*((_QWORD *)this + 2);
        v13 = v12[8];
        v26 = 0;
        v27 = v13;
        RB::RenderPass::resolve_framebuffer((RB::RenderPass *)v25, v12, v12, (const RB::RenderTask *)v8, v13, v9, v10, v11);
      }
      else
      {
        v14 = (void *)(*(uint64_t (**)(void))(*((_QWORD *)this + 4) + 16))();
        if (v14)
        {
          v15 = (int32x2_t *)operator new();
          RB::Texture::Texture(v15, v14, a2[29], 1, 0);
          v16 = (int32x2_t *)*((_QWORD *)this + 2);
          v17 = v16[8];
          v26 = 0;
          v27 = v17;
          RB::RenderPass::resolve_framebuffer((RB::RenderPass *)v25, v15, v16, (const RB::RenderTask *)v8, v17, v18, v19, v20);
          v21 = v15[1].i32[0] - 1;
          v15[1].i32[0] = v21;
          if (!v21)
            (*(void (**)(int32x2_t *))(*(_QWORD *)v15 + 8))(v15);
        }
        else
        {
          v22 = RB::error_log(0);
          if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
            RB::DisplayList::RootTexture::render(&v23, v24, v22);
        }
      }
    }
    RB::RenderPass::~RenderPass((RB::RenderPass *)v25);
  }
  while (*((_QWORD *)this + 3));
}

void sub_209AF0E6C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RB::RenderPass::~RenderPass((RB::RenderPass *)va);
  _Unwind_Resume(a1);
}

_QWORD *RB::RenderTaskTexture::render_dependencies(_QWORD *this, void *a2)
{
  uint64_t v2;
  int v4;
  uint64_t i;

  v2 = this[3];
  if (v2)
  {
    v4 = *(_DWORD *)(v2 + 12);
    do
    {
      if (*(_DWORD *)(v2 + 12) != v4)
        break;
      for (i = *(_QWORD *)(v2 + 32); i; i = *(_QWORD *)(i + 40))
      {
        this = *(_QWORD **)(i + 88);
        if (this)
        {
          if (!this[2])
            this = (_QWORD *)(*(uint64_t (**)(_QWORD *, void *))(*this + 32))(this, a2);
        }
      }
      v2 = *(_QWORD *)(v2 + 48);
    }
    while (v2);
  }
  return this;
}

void RB::RenderTaskTexture::render_all_tasks(RB::RenderTaskTexture *this, RB::RenderPass *a2, void *a3)
{
  uint64_t v4;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  BOOL v13;
  void *v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  unint64_t v21;
  uint64_t v22;

  v4 = *((_QWORD *)this + 3);
  if (v4)
  {
    LOBYTE(v7) = 0;
    do
    {
      v8 = *(_QWORD *)(v4 + 48);
      (*(void (**)(uint64_t, RB::RenderPass *, void *))(*(_QWORD *)v4 + 32))(v4, a2, a3);
      v7 = v7 || *(_BYTE *)(v4 + 74) != 0;
      v9 = *(_QWORD *)(v4 + 32);
      *(_QWORD *)(v4 + 32) = 0;
      if (v9)
      {
        do
        {
          v10 = *(_QWORD *)(v9 + 40);
          *(_QWORD *)(v9 + 40) = 0;
          *(_QWORD *)(v9 + 16) = 0;
          v11 = *(_DWORD *)(v9 + 8) - 1;
          *(_DWORD *)(v9 + 8) = v11;
          if (!v11)
            (*(void (**)(uint64_t))(*(_QWORD *)v9 + 8))(v9);
          v9 = v10;
        }
        while (v10);
      }
      if (!v8)
        break;
      v4 = v8;
    }
    while (*(_DWORD *)(v8 + 12) == *(_DWORD *)(*((_QWORD *)this + 3) + 12));
    if (v7)
    {
      do
      {
        v19 = *(_QWORD *)a2;
        v21 = 0;
        v22 = 0;
        v20 = 0;
        v12 = *((_QWORD *)this + 3);
        if (v12 == v8)
        {
          v13 = 0;
        }
        else
        {
          v13 = 0;
          do
          {
            if (*(_BYTE *)(v12 + 74))
            {
              *(_BYTE *)(v12 + 74) = 0;
              (*(void (**)(uint64_t, RB::RenderPass *, uint64_t *, void *))(*(_QWORD *)v12 + 40))(v12, a2, &v19, a3);
              v13 = v13 || *(_BYTE *)(v12 + 74) != 0;
            }
            v12 = *(_QWORD *)(v12 + 48);
          }
          while (v12 != v8);
        }
        RB::Filter::RenderGroup::resolve((RB::Filter::RenderGroup *)&v19, a2);
        v14 = v20;
        v15 = v21;
        if (v21)
        {
          v16 = 0;
          v17 = (uint64_t *)((char *)v20 + 8);
          do
          {
            v18 = *v17;
            *v17 = 0;
            if (v18)
            {
              (*(void (**)(uint64_t))(*(_QWORD *)v18 + 8))(v18);
              v15 = v21;
            }
            ++v16;
            v17 += 7;
          }
          while (v16 < v15);
          v14 = v20;
        }
        if (v14)
          free(v14);
      }
      while (v13);
    }
  }
  else
  {
    v8 = 0;
  }
  *((_QWORD *)this + 3) = v8;
}

void sub_209AF1138(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RB::Filter::RenderGroup::~RenderGroup((RB::Filter::RenderGroup *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::RootTexture::make_texture(uint64_t a1, MTLPixelFormat a2)
{
  uint64_t result;
  unint64_t v5;
  uint64_t v6;
  unsigned int *v7;
  __n128 v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  _DWORD *v12;
  int v13;
  unsigned __int8 v14;
  NSObject *v15;
  _BOOL4 v16;
  RB *v17;
  __n128 v18;
  int32x2_t *v19;
  int32x2_t *v20;
  int v21;
  int32x2_t *v22;
  uint8_t buf[16];

  if (*(_QWORD *)(a1 + 16))
    return 1;
  v5 = *(_QWORD *)(a2 + 8);
  v6 = **(_QWORD **)a2;
  v7 = RB::pixel_format_traits(v5, a2);
  if (((*v7 | ((unint64_t)*((unsigned __int16 *)v7 + 2) << 32)) & 0x10000000000) != 0)
  {
    *(_BYTE *)(a1 + 44) = 1;
    *(_BYTE *)(a1 + 45) = (v7[1] & 0x200) != 0;
  }
  else if (*(unsigned __int8 *)(a2 + 28) >= 2u)
  {
    *(_BYTE *)(a1 + 44) = 1;
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    goto LABEL_11;
  }
  if (!*(_BYTE *)(a1 + 45))
  {
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 24) + 73) & 1) != 0)
    {
      v14 = 1;
    }
    else
    {
      v14 = 1;
      if (*(_BYTE *)(v6 + 285))
      {
        if (*(_DWORD *)(a1 + 40) == 1)
          v14 = 1;
        else
          v14 = 2;
      }
    }
    if (v7[8])
      v17 = (RB *)v7[8];
    else
      v17 = (RB *)v5;
    v8.n128_u64[0] = *(_QWORD *)(a2 + 16);
    v18 = RB::Device::alloc_shared_texture((_QWORD *)v6, v17, 1u, *(_BYTE *)(a2 + 29), v14, &v22, v8);
    v19 = *(int32x2_t **)(a1 + 16);
    v20 = v22;
    *(_QWORD *)(a1 + 16) = v22;
    v22 = v19;
    if (v19)
    {
      v21 = v19[1].i32[0] - 1;
      v19[1].i32[0] = v21;
      if (!v21)
      {
        (*(void (**)(int32x2_t *, __n128))(*(_QWORD *)v19 + 8))(v19, v18);
        v20 = *(int32x2_t **)(a1 + 16);
      }
    }
    if (v20)
      goto LABEL_30;
    return 0;
  }
LABEL_11:
  v9 = (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (v9)
  {
    v10 = (void *)v9;
    v11 = operator new();
    RB::Texture::Texture(v11, v10, *(unsigned __int8 *)(a2 + 29), 1, 0);
    v12 = *(_DWORD **)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v11;
    if (v12)
    {
      v13 = v12[2] - 1;
      v12[2] = v13;
      if (!v13)
        (*(void (**)(_DWORD *))(*(_QWORD *)v12 + 8))(v12);
    }
LABEL_30:
    if ((*(_BYTE *)(a2 + 30) & 8) != 0)
      *(_BYTE *)(*(_QWORD *)(a1 + 16) + 77) |= 4u;
    return 1;
  }
  v15 = RB::error_log(0);
  v16 = os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v16)
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_209ACA000, v15, OS_LOG_TYPE_DEFAULT, "RBDrawable: no surface, dropping frame", buf, 2u);
    return 0;
  }
  return result;
}

void sub_209AF135C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A1C401006C202);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::texture(RB::Surface *this, MTLPixelFormat a2)
{
  uint64_t v2;
  unint64_t v4;
  int v5;
  unsigned int *v6;
  const char *v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  int v12;

  v2 = *((_QWORD *)this + 7);
  if (!v2)
  {
    if (*((_QWORD *)this + 2))
    {
      v4 = *((_QWORD *)this + 4);
      v12 = HIDWORD(*((_QWORD *)this + 3));
      v5 = *((_QWORD *)this + 3);
      v6 = RB::pixel_format_traits(v4, a2);
      if (((*v6 | ((unint64_t)*((unsigned __int16 *)v6 + 2) << 32)) & 0x10000000000) != 0)
      {
        v9 = v4 - 2147483649u;
        v4 = 23;
        v8 = 7;
        switch(v9)
        {
          case 0uLL:
          case 1uLL:
            v5 *= 3;
            v4 = 10;
            goto LABEL_13;
          case 2uLL:
            v5 *= 3;
            v4 = 25;
            goto LABEL_13;
          case 3uLL:
          case 4uLL:
          case 5uLL:
            break;
          case 6uLL:
          case 7uLL:
            v4 = 80;
            goto LABEL_13;
          case 8uLL:
          case 9uLL:
            v4 = 70;
            goto LABEL_13;
          case 0xAuLL:
          case 0xBuLL:
            v4 = 115;
LABEL_13:
            v8 = 7;
            break;
          default:
            RB::precondition_failure((RB *)"unhandled resolved format: %d", v7, 23);
        }
      }
      else
      {
        v8 = 5;
      }
      v10 = (void *)objc_msgSend(MEMORY[0x24BDDD740], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", v4, v5, v12, 0);
      objc_msgSend(v10, "setUsage:", v8);
      v2 = objc_msgSend(*(id *)(*((_QWORD *)this + 2) + 24), "newTextureWithDescriptor:iosurface:plane:", v10, *((_QWORD *)this + 6), 0);

      *((_QWORD *)this + 7) = v2;
    }
    else
    {
      return 0;
    }
  }
  return v2;
}

void RB::RenderTask::schedule_many(uint64_t a1, RB::RenderTask **a2, uint64_t a3, double a4)
{
  RB::RenderTask **v4;
  uint64_t v5;
  std::string *v7;
  std::string::size_type *v8;
  uint64_t v9;
  std::string::size_type v10;
  std::string::size_type v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _BYTE *v15;
  _BYTE *v16;
  std::string::size_type v17;
  int v18;
  std::string::size_type v19;
  std::string::size_type v20;
  int v21;
  std::string *v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  unsigned __int8 v35;
  std::string *v36;
  const char *v37;
  uint64_t v38;
  int v39;
  uint64_t v41;
  std::string __p[45];
  uint64_t v43;
  _BYTE __dst[256];
  void *v45;
  uint64_t v46;
  uint64_t v47;

  v4 = a2;
  v5 = a1;
  v47 = *MEMORY[0x24BDAC8D0];
  v45 = 0;
  v46 = 0x2000000000;
  __p[0].__r_.__value_.__r.__words[0] = 0;
  if (a1)
  {
    v7 = __p;
    v8 = (std::string::size_type *)a2;
    v9 = a1;
    do
    {
      v10 = *v8++;
      v7->__r_.__value_.__r.__words[0] = v10;
      *(_QWORD *)(v10 + 48) = 0;
      *(_DWORD *)(v10 + 12) = 0;
      v7 = (std::string *)(v10 + 48);
      --v9;
    }
    while (v9);
    v11 = __p[0].__r_.__value_.__r.__words[0];
    if (__p[0].__r_.__value_.__r.__words[0])
    {
      v12 = 0;
      do
      {
        __p[0].__r_.__value_.__r.__words[0] = *(_QWORD *)(v11 + 48);
        if (!__p[0].__r_.__value_.__r.__words[0])
          v7 = __p;
        v13 = *(_DWORD *)(v11 + 12);
        if (v12 <= v13)
        {
          v14 = v12 + 1;
          if (HIDWORD(v46) < v12 + 1)
          {
            RB::vector<RB::RenderTask *,32ul,unsigned int>::reserve_slow(__dst, v14);
            v12 = v46;
            v13 = *(_DWORD *)(v11 + 12);
            v14 = v46 + 1;
          }
          v15 = v45;
          if (!v45)
            v15 = __dst;
          *(_QWORD *)&v15[8 * v12] = 0;
          LODWORD(v46) = v14;
          v12 = v14;
        }
        v16 = v45;
        if (!v45)
          v16 = __dst;
        *(_QWORD *)(v11 + 48) = *(_QWORD *)&v16[8 * v13];
        *(_QWORD *)&v16[8 * v13] = v11;
        v17 = *(_QWORD *)(v11 + 32);
        if (v17)
        {
          do
          {
            v18 = *(_DWORD *)(v11 + 12) + 1;
            v7->__r_.__value_.__r.__words[0] = v17;
            *(_QWORD *)(v17 + 48) = 0;
            v7 = (std::string *)(v17 + 48);
            *(_DWORD *)(v17 + 12) = v18;
            v19 = v17;
            v17 = *(_QWORD *)(v17 + 40);
          }
          while (v17);
        }
        else
        {
          v19 = 0;
        }
        v20 = *(_QWORD *)(v11 + 24);
        if (v20)
        {
          if (!v19)
            v19 = v11;
          v21 = *(_DWORD *)(v19 + 12) + 1;
          v7->__r_.__value_.__r.__words[0] = v20;
          *(_QWORD *)(v20 + 48) = 0;
          v22 = (std::string *)(v20 + 48);
          HIDWORD(v22[-2].__r_.__value_.__r.__words[1]) = v21;
          v7 = v22;
        }
        v11 = __p[0].__r_.__value_.__r.__words[0];
      }
      while (__p[0].__r_.__value_.__r.__words[0]);
      if (v12)
      {
        v23 = 0;
        v24 = v12;
        while (1)
        {
          RB::BinPacker::BinPacker((RB::BinPacker *)__p, SLODWORD(a4), SHIDWORD(a4));
          v26 = v45;
          if (!v45)
            v26 = __dst;
          v27 = *(_QWORD *)&v26[8 * v23];
          if (v27)
          {
            do
            {
              v28 = *(_QWORD *)(v27 + 48);
              v29 = *(_QWORD *)(v27 + 88);
              if (v29)
              {
                *(_QWORD *)(v27 + 48) = *(_QWORD *)(v29 + 24);
                *(_QWORD *)(v29 + 24) = v27;
              }
              else
              {
                RB::BinPacker::add((uint64_t)__p, *(_QWORD *)(v27 + 56), HIDWORD(*(_QWORD *)(v27 + 56)), (void *)v27, *(_QWORD *)(v27 + 80) ^ ((unint64_t)*(unsigned __int8 *)(v27 + 72) << 16));
              }
              v27 = v28;
            }
            while (v28);
          }
          RB::BinPacker::pack((RB::BinPacker *)__p, v25);
          v30 = v43;
          if (v43)
            break;
LABEL_42:
          RB::Heap::~Heap((RB::Heap *)__p);
          if (++v23 == v24)
            goto LABEL_43;
        }
        while (1)
        {
          (*(void (**)(uint64_t *__return_ptr, _QWORD, uint64_t, double))(**(_QWORD **)(*(_QWORD *)(v30 + 16)
                                                                                               + 16)
                                                                                 + 48))(&v41, *(_QWORD *)(*(_QWORD *)(v30 + 16) + 16), a3, *(double *)v30);
          v31 = *(_QWORD *)(v30 + 16);
          v32 = v41;
          if (v31)
            break;
          if (v41)
            goto LABEL_39;
LABEL_41:
          v30 = *(_QWORD *)(v30 + 24);
          if (!v30)
            goto LABEL_42;
        }
        do
        {
          v33 = *(_QWORD *)(v31 + 16);
          RB::RenderTask::set_texture((_DWORD *)v33, (_DWORD *)v32, *(double *)(v31 + 32));
          v32 = v41;
          *(_QWORD *)(v33 + 48) = *(_QWORD *)(v41 + 24);
          *(_QWORD *)(v32 + 24) = v33;
          v31 = *(_QWORD *)(v31 + 40);
        }
        while (v31);
LABEL_39:
        v34 = *(_DWORD *)(v32 + 8) - 1;
        *(_DWORD *)(v32 + 8) = v34;
        if (!v34)
          (*(void (**)(uint64_t))(*(_QWORD *)v32 + 8))(v32);
        goto LABEL_41;
      }
    }
  }
LABEL_43:
  v35 = atomic_load((unsigned __int8 *)&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks);
  if ((v35 & 1) == 0 && __cxa_guard_acquire(&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks))
  {
    v38 = RB::debug_int((RB *)"RB_PRINT_TASKS", v37);
    if ((v38 & 0xFF00000000) != 0)
      v39 = v38;
    else
      v39 = 0;
    _ZZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks = v39;
    __cxa_guard_release(&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks);
  }
  if (_ZZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks >= 1)
  {
    memset(__p, 0, 41);
    RB::SexpString::push(__p, "tasks");
    for (; v5; --v5)
      RB::RenderTask::print(*v4++, __p);
    RB::SexpString::pop(__p);
    RB::SexpString::newline(__p);
    if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
      v36 = __p;
    else
      v36 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
    fputs((const char *)v36, (FILE *)*MEMORY[0x24BDAC8E8]);
    if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
      operator delete(__p[0].__r_.__value_.__l.__data_);
  }
  if (v45)
    free(v45);
}

void sub_209AF18A8(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_ZGVZN2RB10RenderTask13schedule_manyEmPKPS0_Dv2_iPvE11print_tasks);
  if (STACK[0x580])
    free((void *)STACK[0x580]);
  _Unwind_Resume(a1);
}

double RB::BinPacker::BinPacker(RB::BinPacker *this, int a2, int a3)
{
  RB::Heap *v5;
  double result;

  v5 = RB::Heap::Heap(this, (char *)this + 40, 1024, 0);
  *((_DWORD *)v5 + 266) = (a2 & 0xFFFFFFC0) + 64;
  *((_DWORD *)v5 + 267) = (a3 & 0xFFFFFFC0) + 64;
  *((_QWORD *)v5 + 134) = 0x8000000080;
  *((_DWORD *)v5 + 270) = 0;
  result = 0.0;
  *((_OWORD *)v5 + 68) = 0u;
  *((_BYTE *)v5 + 1104) = 0;
  return result;
}

void RB::BinPacker::pack(RB::BinPacker *this, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  int v7;
  int v8;
  int v9;
  uint64_t *v10;
  uint64_t *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  size_t *v16[10];
  uint64_t v17;
  uint64_t v18[5];
  char v19[4096];
  uint64_t v20;

  v2 = MEMORY[0x24BDAC7A8](this, a2);
  v20 = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(v2 + 1088);
  if (v3)
  {
    v4 = v2;
    v5 = *(_DWORD *)(v2 + 1072);
    v6 = *(int *)(v2 + 1064) >> 1;
    if (v6 >= v5)
    {
      v7 = *(_DWORD *)(v2 + 1080) + (*(int *)(v2 + 1080) >> 2);
      v8 = *(_DWORD *)(v2 + 1068);
      v9 = *(_DWORD *)(v2 + 1076);
      do
      {
        v8 >>= 1;
        if (v8 < v9)
          break;
        if (v8 * v6 < v7)
          break;
        *(_DWORD *)(v2 + 1064) = v6;
        *(_DWORD *)(v2 + 1068) = v8;
        v6 >>= 1;
      }
      while (v6 >= v5);
    }
    v10 = (uint64_t *)(v2 + 1088);
    v11 = (uint64_t *)(v2 + 1088);
    do
    {
      while (1)
      {
        v12 = *(_DWORD *)(v3 + 4);
        if (*(_DWORD *)v3 <= *(_DWORD *)(v4 + 1064) && v12 <= *(_DWORD *)(v4 + 1068))
          break;
        v13 = *(_QWORD *)(v3 + 8);
        LODWORD(v16[0]) = ((*(_DWORD *)v3 - 1) & 0xFFFFFFC0) + 64;
        LODWORD(v17) = ((v12 - 1) & 0xFFFFFFC0) + 64;
        v18[0] = v13;
        v14 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>((RB::Heap *)v4, v16, (int *)&v17, v18);
        *(_QWORD *)(v14 + 24) = *(_QWORD *)(v4 + 1096);
        *(_QWORD *)(v4 + 1096) = v14;
        RB::BinPacker::append_packed((RB::Heap *)v4, v3, 0, 0);
        v3 = *(_QWORD *)(v3 + 24);
        *v11 = v3;
        if (!v3)
          goto LABEL_13;
      }
      v11 = (uint64_t *)(v3 + 24);
      v3 = *(_QWORD *)(v3 + 24);
    }
    while (v3);
LABEL_13:
    if (*v10)
    {
      if (*(_BYTE *)(v4 + 1104))
      {
        RB::Heap::Heap((RB::Heap *)v18, v19, 4096, 0);
        RB::UntypedTable::UntypedTable((RB::UntypedTable *)v16, 0, 0, 0, 0, (RB::Heap *)v18);
        while (1)
        {
          v15 = *v10;
          if (!*v10)
            break;
          *v10 = *(_QWORD *)(v15 + 24);
          *(_QWORD *)(v15 + 24) = RB::UntypedTable::lookup((RB::UntypedTable *)v16, *(uint64_t **)(v15 + 8), 0);
          RB::UntypedTable::insert(v16, *(size_t **)(v15 + 8), (size_t *)v15);
        }
        v17 = v4;
        RB::UntypedTable::for_each((uint64_t)v16, (void (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::BinPacker::item *>::for_each<RB::BinPacker::pack(void)::$_0>(RB::BinPacker::pack(void)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, &v17);
        RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v16);
        RB::Heap::~Heap((RB::Heap *)v18);
      }
      else
      {
        RB::BinPacker::pack((RB::Heap *)v4, *v10);
      }
    }
  }
}

void RB::RenderPass::~RenderPass(RB::RenderPass *this)
{
  uint64_t v2;
  uint64_t i;
  _DWORD *v4;
  int v5;

  RB::RenderFrame::flush_pass(**(id ***)this, this, 1);

  v2 = *((_QWORD *)this + 19);
  *((_QWORD *)this + 19) = 0;
  if (v2)
    RB::RenderFrame::QueueDeleter::operator()((uint64_t)this + 152, v2);

  for (i = 80; i != -16; i -= 24)
  {
    v4 = *(_DWORD **)((char *)this + i);
    if (v4)
    {
      v5 = v4[2] - 1;
      v4[2] = v5;
      if (!v5)
        (*(void (**)(_DWORD *))(*(_QWORD *)v4 + 8))(v4);
    }
  }
}

void sub_209AF1C44(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 152);
  *(_QWORD *)(v1 + 152) = 0;
  if (v3)
    RB::RenderFrame::QueueDeleter::operator()(v1 + 152, v3);
  RB::RenderPass::~RenderPass(v1);
  _Unwind_Resume(a1);
}

_QWORD *RB::Texture::finalize(RB::Texture *this)
{
  RB::Device *v2;

  v2 = (RB::Device *)*((_QWORD *)this + 6);
  if (!v2)
    return (_QWORD *)(*(uint64_t (**)(RB::Texture *))(*(_QWORD *)this + 24))(this);
  *((_QWORD *)this + 6) = 0;
  return RB::Device::recycle_texture(v2, this);
}

_QWORD *RB::Device::recycle_texture(RB::Device *this, RB::Texture *a2)
{
  char *v4;
  _QWORD *result;
  uint64_t v6;

  ++*((_DWORD *)a2 + 2);
  v4 = (char *)this + 376;
  result = operator new(0x18uLL);
  result[1] = v4;
  result[2] = a2;
  v6 = *((_QWORD *)this + 47);
  *result = v6;
  *(_QWORD *)(v6 + 8) = result;
  *((_QWORD *)this + 47) = result;
  ++*((_QWORD *)this + 49);
  *((_QWORD *)this + 53) += *((unsigned int *)a2 + 18);
  return result;
}

void RB::RenderFrame::flush_pass(id *this, RB::RenderPass *a2, int a3)
{
  _DWORD **v6;
  _DWORD *v7;
  NSObject *v8;

  v6 = (_DWORD **)((char *)a2 + 152);
  if (!*((_QWORD *)a2 + 19))
  {
    if (*((_DWORD *)a2 + 32) != 2)
    {
      if (a3)
        RB::RenderFrame::end_encoding(this);
      return;
    }
    RB::RenderFrame::acquire_queue((uint64_t)this, (uint64_t *)a2 + 19);
  }
  RB::RenderFrame::will_render((RB::RenderFrame *)this);
  v7 = *v6;
  *v6 = 0;
  if ((a3 & 1) == 0 && *v7 >= 0x400u)
    *((_DWORD *)this + 20) |= 2u;
  RB::RenderFrame::EncoderData::EncoderData((uint64_t)(v7 + 2030), (unint64_t *)this, (uint64_t)a2, a3);
  *((_DWORD *)a2 + 32) = 1;
  *((_BYTE *)a2 + 132) = 0;
  v8 = *((_QWORD *)*this + 5);
  if (((_BYTE)this[10] & 2) != 0)
  {
    dispatch_async_f(v8, v7, (dispatch_function_t)RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke);
    if (!a3)
      return;
  }
  else
  {
    dispatch_sync_f(v8, v7, (dispatch_function_t)RB::RenderFrame::flush_pass(RB::RenderPass &,BOOL)::$_0::__invoke);
    if (!a3)
      return;
  }
  this[8] = (char *)this[8] + 1;
}

void sub_209AF1E14(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    RB::RenderFrame::QueueDeleter::operator()((uint64_t)exception_object, v1);
  _Unwind_Resume(exception_object);
}

void RB::RenderFrame::will_render(RB::RenderFrame *this)
{
  _QWORD *v1;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD v7[2];

  v1 = (_QWORD *)*((_QWORD *)this + 15);
  if (v1)
  {
    if ((*((_BYTE *)this + 80) & 2) != 0)
    {
      v5 = (_QWORD *)operator new();
      v6 = (_QWORD *)*((_QWORD *)this + 15);
      *((_QWORD *)this + 15) = 0;
      *v5 = this;
      for (v5[1] = v6; v6; v6 = (_QWORD *)*v6)
        *(_BYTE *)(v6[1] + 77) &= ~8u;
      dispatch_async_f(*(dispatch_queue_t *)(*(_QWORD *)this + 40), v5, (dispatch_function_t)RB::RenderFrame::will_render(void)::Encoder::dispatch);
    }
    else
    {
      *((_QWORD *)this + 15) = 0;
      v3 = v1;
      v7[0] = this;
      v7[1] = v1;
      do
      {
        *(_BYTE *)(v3[1] + 77) &= ~8u;
        v3 = (_QWORD *)*v3;
      }
      while (v3);
      RB::RenderFrame::will_render(void)::Encoder::operator()((uint64_t)v7);
      do
      {
        v4 = (_QWORD *)*v1;
        operator delete(v1);
        v1 = v4;
      }
      while (v4);
    }
  }
}

void sub_209AF1F10(_Unwind_Exception *a1)
{
  _QWORD *v1;
  _QWORD *v3;

  do
  {
    v3 = (_QWORD *)*v1;
    operator delete(v1);
    v1 = v3;
  }
  while (v3);
  _Unwind_Resume(a1);
}

uint64_t RB::RenderFrame::EncoderData::EncoderData(uint64_t a1, unint64_t *a2, uint64_t a3, int a4)
{
  const char *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char v17;
  uint64_t v18;
  int v19;
  int v20;
  _BOOL4 v21;
  int v22;
  unsigned int v23;
  MTLPixelFormat v24;
  unsigned int v25;
  char v26;
  int v27;
  int v28;

  *(_QWORD *)a1 = a2;
  *(_QWORD *)(a1 + 8) = *(id *)(a3 + 144);
  *(_QWORD *)(a1 + 16) = *(id *)(a3 + 256);
  v9 = atomic_load(a2 + 13);
  *(_QWORD *)(a1 + 24) = v9;
  v10 = atomic_load((unint64_t *)(v9 + 8));
  *(_QWORD *)(a1 + 32) = v10;
  v11 = atomic_load(a2 + 12);
  *(_QWORD *)(a1 + 40) = v11;
  v12 = atomic_load((unint64_t *)(v11 + 8));
  *(_QWORD *)(a1 + 48) = v12;
  v13 = atomic_load(a2 + 14);
  *(_QWORD *)(a1 + 56) = v13;
  v14 = atomic_load((unint64_t *)(v13 + 8));
  *(_QWORD *)(a1 + 64) = v14;
  v15 = *(_QWORD *)(a3 + 16);
  v16 = *(_QWORD *)(a3 + 88);
  v17 = *(_BYTE *)(*(_QWORD *)a3 + 30);
  v18 = 38;
  if (*(_DWORD *)(a3 + 136) == 2)
    v18 = 0x200000026;
  *(_QWORD *)(a1 + 72) = v18;
  v19 = *(_DWORD *)(a1 + 80) & 0xFFFFFC00 | v15 & 0x3FF;
  *(_DWORD *)(a1 + 80) = v19;
  if (v15 > 0x3FF || (*(_DWORD *)(a1 + 80) = v19 & 0xFFF003FF | ((v16 & 0x3FF) << 10), v16 >= 0x400))
    RB::precondition_failure((RB *)"invalid pixel format", v8);
  v20 = v15 & 0x3FF | ((((v17 & 8) >> 3) & 1) << 26) | ((v16 & 0x3FF) << 10);
  *(_DWORD *)(a1 + 80) = v20;
  *(_QWORD *)(a1 + 88) = *(_QWORD *)(a3 + 104);
  *(_BYTE *)(a1 + 96) = *(_BYTE *)(a3 + 124);
  v21 = *(_DWORD *)(a3 + 128) == 2;
  v22 = *(_BYTE *)(a1 + 97) & 0xFE | v21;
  *(_BYTE *)(a1 + 97) = *(_BYTE *)(a1 + 97) & 0xFE | v21;
  v23 = v22 & 0xFFFFFFFD | (2
                          * ((*((unsigned __int16 *)RB::pixel_format_traits(*(_QWORD *)(a3 + 88), (MTLPixelFormat)v8) + 2) >> 7) & 1));
  *(_BYTE *)(a1 + 97) = v23;
  v25 = v23 & 0xFFFFFFFB | (4
                          * ((*((unsigned __int16 *)RB::pixel_format_traits(*(_QWORD *)(a3 + 88), v24) + 2) >> 6) & 1));
  *(_BYTE *)(a1 + 97) = v25;
  if (a4)
    v26 = 16;
  else
    v26 = 0;
  *(_BYTE *)(a1 + 97) = v26 | (8 * (*(_QWORD *)(a3 + 56) != 0)) | v25 & 0xE7;
  *(_BYTE *)(a1 + 98) = *(_BYTE *)(a3 + 132);
  v27 = v20 | ((*(_QWORD *)(a3 + 32) != 0) << 20);
  *(_DWORD *)(a1 + 80) = v27;
  v28 = v27 | ((*(_QWORD *)(a3 + 56) != 0) << 21) | 0x400000;
  *(_DWORD *)(a1 + 80) = v28;
  *(_DWORD *)(a1 + 80) = (v28 & 0xFDFFFFFF | ((*(_BYTE *)(a3 + 124) & 1) << 25)) ^ 0x2000000;
  return a1;
}

void sub_209AF2114(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

uint64_t RB::RenderPass::RenderPass(uint64_t a1, uint64_t a2, int32x2_t *a3, unsigned int a4, int a5, uint64_t a6)
{
  uint64_t i;
  uint64_t v11;
  int32x2_t v12;
  __int8 v13;
  id *v14;
  id v15;

  *(_QWORD *)a1 = a2;
  for (i = 8; i != 104; i += 24)
  {
    v11 = a1 + i;
    *(_QWORD *)v11 = 0;
    *(_QWORD *)(v11 + 8) = 0;
    *(_DWORD *)(v11 + 16) = 0;
  }
  v12 = vshl_s32(vadd_s32(a3[8], vdup_n_s32(~(-1 << a4))), vneg_s32(vdup_n_s32(a4)));
  *(int32x2_t *)(a1 + 104) = v12;
  *(float32x2_t *)(a1 + 112) = vdiv_f32((float32x2_t)0x4000000040000000, vcvt_f32_s32(v12));
  v13 = a3[10].i8[0];
  *(_QWORD *)(a1 + 152) = 0;
  *(_DWORD *)(a1 + 120) = 1065353216;
  *(_BYTE *)(a1 + 124) = v13;
  *(_DWORD *)(a1 + 128) = a5;
  *(_BYTE *)(a1 + 132) = 0;
  *(_DWORD *)(a1 + 136) = 0;
  *(_QWORD *)(a1 + 144) = 0;
  v14 = (id *)(a1 + 144);
  *(_QWORD *)(a1 + 160) = 0;
  *(int32x2_t *)(a1 + 168) = v12;
  *(_WORD *)(a1 + 176) = 0;
  *(_DWORD *)(a1 + 180) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  v15 = (id)objc_msgSend(MEMORY[0x24BDDD690], "renderPassDescriptor");
  if (*v14 != v15)
  {

    *v14 = v15;
  }
  RB::RenderPass::set_attachment(a1, MTLPixelFormatInvalid, (RB::Resource *)a3, a4, a6);
  *(_QWORD *)(a1 + 248) = 0;
  *(_OWORD *)(a1 + 232) = 0u;
  *(_OWORD *)(a1 + 216) = 0u;
  *(_OWORD *)(a1 + 200) = 0u;
  *(_OWORD *)(a1 + 184) = 0u;
  return a1;
}

void sub_209AF2284(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  id *v5;
  uint64_t v7;

  v7 = *(_QWORD *)(v2 + 152);
  *(_QWORD *)(v2 + 152) = 0;
  if (v7)
    RB::RenderFrame::QueueDeleter::operator()(v4, v7);
  RB::RenderPass::RenderPass(v5, v3, v1);
  _Unwind_Resume(a1);
}

void RB::RenderPass::set_label(id *this, NSString *a2)
{
  uint64_t v3;

  if ((*(_BYTE *)(**(_QWORD **)*this + 292) & 1) != 0)
  {
    v3 = -[NSString copy](a2, "copy");

    this[32] = (id)v3;
  }
}

uint64_t ___ZN2RB18SharedSurfaceGroup21render_updates_deviceEv_block_invoke(uint64_t a1, MTLPixelFormat a2)
{
  return RB::Surface::texture(*(RB::Surface **)(a1 + 32), a2);
}

unint64_t RB::RenderParams::srgb_alpha(RB::RenderParams *this, MTLPixelFormat a2)
{
  unsigned int *v3;
  unint64_t v4;

  if (*((_BYTE *)this + 28))
    return 0;
  v3 = RB::pixel_format_traits(*((_QWORD *)this + 1), a2);
  v4 = *v3 | ((unint64_t)*((unsigned __int16 *)v3 + 2) << 32);
  if ((v4 & 0x100000000) == 0)
    return 0;
  if ((v4 & 0x1000000000) != 0)
    return 1;
  return (v4 >> 33) & ((*((_BYTE *)this + 30) & 1) == 0);
}

uint64_t RB::RenderPass::set_clear_color(uint64_t result, __n128 a2)
{
  if (*(_DWORD *)(result + 128) == 2)
    return objc_msgSend((id)objc_msgSend((id)objc_msgSend(*(id *)(result + 144), "colorAttachments"), "objectAtIndexedSubscript:", 0), "setClearColor:", a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2], a2.n128_f32[3]);
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::render(float32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  int8x16_t v16;
  int32x4_t v17;
  float32x2_t v18;
  float32x2_t v19;
  double v20;
  float64x2_t v21;
  float64x2_t v22;
  int8x16_t v23;
  int8x16_t v24;
  float64x2_t v25[2];
  uint64_t v26;
  uint64_t v27;
  int32x2_t v28[2];

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(float32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v25, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v25[0].f64[0], *(int32x2_t *)&v25[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v25, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v25[0] = (float64x2_t)xmmword_209BD5290;
  v25[1] = (float64x2_t)xmmword_209BD52A0;
  v26 = 0;
  v27 = 0;
  v18 = RB::Coverage::Primitive::bounds(a1 + 8, v25, (int8x16_t)xmmword_209BD5290, 0.0, v16, v17);
  RB::Bounds::Bounds(v28, v18, v19);
  RB::Fill::Gradient::fill((uint64_t)&a1[14], (RB::CGContext *)a2, *(double *)v28, *(double *)&v28[1], v20, v21, v22, v23, v24);
  RB::CGContext::restore((RB::CGContext *)a2);
}

void RB::Coverage::Primitive::clip(float32x2_t *this, CGContext **a2)
{
  CGContext *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  CGImageRef v9;
  int v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  int32x4_t v16;
  float32x2_t v22;
  float32x2_t v23;
  RB::CGContext *v24;
  float v25;
  CGImageRef mask;
  float v27;
  float v28;
  float v29;
  float v30;
  CGRect v31;

  if (this[5].i8[4] != 1)
  {
    if (!this[5].i8[4])
    {
      v3 = *a2;
LABEL_4:
      v4 = *MEMORY[0x24BDBF090];
      v5 = *(double *)(MEMORY[0x24BDBF090] + 8);
      v6 = *(double *)(MEMORY[0x24BDBF090] + 16);
      v7 = *(double *)(MEMORY[0x24BDBF090] + 24);
LABEL_5:
      CGContextClipToRect(v3, *(CGRect *)&v4);
      return;
    }
    if ((this[5].i8[6] & 5) != 0)
    {
      RB::Coverage::Primitive::make_image_mask(this, (RB::CGContext *)a2, &mask);
      v9 = mask;
      v3 = *a2;
      if (!mask)
        goto LABEL_4;
      v31.origin.x = v27;
      v31.origin.y = v28;
      v31.size.width = v29;
      v31.size.height = v30;
      CGContextClipToMask(v3, v31, mask);
      CFRelease(v9);
    }
    else
    {
      v10 = rb_clip_mode(this[5].u8[5]);
      if (*((unsigned __int8 *)a2 + 140) != v10)
        RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v10);
      if (this[5].i8[4] == 2)
      {
        LODWORD(v11) = this[4].i32[1];
        if (*(float *)&v11 == 0.0)
        {
          __asm { FMOV            V2.2S, #1.0 }
          _D2.i32[0] = this[4].i32[0];
          v22 = vmul_f32(*this, _D2);
          v23 = vmul_f32(this[1], _D2);
          v3 = *a2;
          v4 = v22.f32[0];
          v5 = v22.f32[1];
          v6 = v23.f32[0];
          v7 = v23.f32[1];
          goto LABEL_5;
        }
      }
      RB::Coverage::Primitive::add_path(this, a2, v11, v12, v13, v14, v15, v16);
      v25 = this[4].f32[1];
      if (v25 != 0.0)
      {
        CGContextReplacePathWithStrokedPath(*a2);
      }
      CGContextClip(*a2);
    }
  }
}

void sub_209AF2760(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

__n128 RB::CGContext::restore(RB::CGContext *this)
{
  char *v2;
  uint64_t v3;
  char *v4;
  __n128 result;
  __int128 v6;
  __int128 v7;

  CGContextRestoreGState(*(CGContextRef *)this);
  v2 = (char *)this + 152;
  if (*((_QWORD *)this + 51))
    v2 = (char *)*((_QWORD *)this + 51);
  v3 = (*((_DWORD *)this + 104) - 1);
  v4 = &v2[64 * v3];
  v6 = *((_OWORD *)v4 + 1);
  result = *((__n128 *)v4 + 2);
  v7 = *(_OWORD *)v4;
  *(_OWORD *)((char *)this + 126) = *(_OWORD *)(v4 + 46);
  *((_OWORD *)this + 6) = v6;
  *((__n128 *)this + 7) = result;
  *((_OWORD *)this + 5) = v7;
  *((_DWORD *)this + 104) = v3;
  return result;
}

void RB::CGContext::save(RB::CGContext *this)
{
  char *v2;
  unsigned int v3;
  char *v4;
  char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;

  v2 = (char *)this + 152;
  v3 = *((_DWORD *)this + 104);
  if (*((_DWORD *)this + 105) < v3 + 1)
  {
    RB::vector<RB::CGContext::GState,4ul,unsigned int>::reserve_slow((char *)this + 152, v3 + 1);
    v3 = *((_DWORD *)this + 104);
  }
  v4 = (char *)*((_QWORD *)this + 51);
  if (!v4)
    v4 = v2;
  v5 = &v4[64 * (unint64_t)v3];
  v6 = *((_OWORD *)this + 5);
  v7 = *((_OWORD *)this + 6);
  v8 = *((_OWORD *)this + 8);
  *((_OWORD *)v5 + 2) = *((_OWORD *)this + 7);
  *((_OWORD *)v5 + 3) = v8;
  *(_OWORD *)v5 = v6;
  *((_OWORD *)v5 + 1) = v7;
  ++*((_DWORD *)this + 104);
  CGContextSaveGState(*(CGContextRef *)this);
  *((_BYTE *)this + 141) = 1;
}

uint64_t __destroy_helper_block_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE(uint64_t a1)
{
  uint64_t result;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    v2 = (unsigned int *)(result + 8);
    do
    {
      v3 = __ldxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      __dmb(9u);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  return result;
}

uint64_t RB::Stroke::Dasher::moveto(uint64_t result, uint64_t *a2, double a3)
{
  uint64_t v3;

  *(double *)(result + 104) = a3;
  v3 = *a2;
  *(_QWORD *)(result + 112) = *a2;
  *(_QWORD *)(result + 128) = *(_QWORD *)(result + 88);
  *(_BYTE *)(result + 120) = *(_BYTE *)(result + 81);
  *(_BYTE *)(result + 160) = 1;
  *(_DWORD *)(result + 136) = *(_DWORD *)(result + 96);
  *(double *)(result + 144) = a3;
  *(_QWORD *)(result + 152) = v3;
  return result;
}

BOOL RB::Symbol::Animator::remove_all_animations(os_unfair_lock_s *this)
{
  uint64_t v2;
  RB::Symbol::Animation *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;

  os_unfair_lock_lock(this);
  v2 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v2)
  {
    v3 = *(RB::Symbol::Animation **)&this[4]._os_unfair_lock_opaque;
    v4 = 88 * v2;
    do
    {
      RB::Symbol::Animation::send_completion(v3, 0);
      v3 = (RB::Symbol::Animation *)((char *)v3 + 88);
      v4 -= 88;
    }
    while (v4);
    v5 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
    if (v5)
    {
      v6 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
      v7 = v6 + 88 * v5;
      do
      {
        v8 = *(unsigned int **)(v6 + 80);
        if (v8)
        {
          v9 = v8 + 2;
          do
          {
            v10 = __ldxr(v9);
            v11 = v10 - 1;
          }
          while (__stlxr(v11, v9));
          if (!v11)
          {
            __dmb(9u);
            (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
          }
        }
        v12 = *(_QWORD *)(v6 + 72);
        *(_QWORD *)(v6 + 72) = 0;
        if (v12)
          std::default_delete<RB::Symbol::Animation::Timing>::operator()[abi:nn180100](v6 + 72, v12);

        v6 += 88;
      }
      while (v6 != v7);
    }
    *(_QWORD *)&this[6]._os_unfair_lock_opaque = 0;
    ++this[15]._os_unfair_lock_opaque;
  }
  os_unfair_lock_unlock(this);
  return v2 != 0;
}

void sub_209AF2A8C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209AF2B94(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::render(float32x2_t *a1, int32x2_t *a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v15;
  __int128 v17;

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(float32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  v14 = 0;
  if ((float32x2_t *)a2[11] != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, v4, v5, v11, &v17, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if ((float64x2_t *)a2[10] != v4)
    goto LABEL_10;
  LODWORD(v15) = a2[16].i32[1];
  if (*(float *)&v15 != _S8 || a2[17].i32[0] != v11)
    goto LABEL_10;
LABEL_11:
  RB::Coverage::Glyphs::fill(a1 + 7, (RB::CGContext *)a2, (const RB::Fill::Color *)&a1[14], v15);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

void RB::DisplayList::ShadowStyle::bounds(float64x2_t **this, float32x2_t *a2, float64x2_t *a3, int a4)
{
  float32x2_t v4;
  uint32x2_t v5;
  int32x2_t v9;
  int32x4_t v10;
  int8x16_t v11;
  int8x8_t v12;
  __int128 v13;
  float32x2_t v14;
  int8x8_t v15;
  unsigned int v16;
  float32x2_t v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  __int128 v22;

  v4 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&a2[1] & 0x7FFFFFFF7FFFFFFFLL), v4);
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
  {
    RB::Rect::move(a2, a3, this[2]);
    *(float *)v9.i32 = *((float *)this + 16) * 2.8;
    v22 = *(_OWORD *)a2->f32;
    *(int32x2_t *)v10.i8 = vcgt_f32(v4, *(float32x2_t *)((char *)&v22 + 8));
    v11 = (int8x16_t)vcltzq_s32(v10);
    v12 = (int8x8_t)vmvnq_s8(v11).u64[0];
    *(int8x8_t *)&v13 = vorr_s8(vand_s8((int8x8_t)vsub_f32(*(float32x2_t *)&v22, (float32x2_t)vdup_lane_s32(v9, 0)), *(int8x8_t *)v11.i8), vand_s8(*(int8x8_t *)&v22, v12));
    *((int8x8_t *)&v13 + 1) = vorr_s8(vand_s8((int8x8_t)vmla_n_f32(*(float32x2_t *)((char *)&v22 + 8), (float32x2_t)0x4000000040000000, *(float *)v9.i32), *(int8x8_t *)v11.i8), vand_s8(*(int8x8_t *)((char *)&v22 + 8), v12));
    v22 = v13;
    v14 = (float32x2_t)this[7];
    v15 = (int8x8_t)vneg_f32(v14);
    if (a4)
      v16 = -1;
    else
      v16 = 0;
    v17 = (float32x2_t)vbsl_s8((int8x8_t)vdup_n_s32(v16), v15, (int8x8_t)v14);
    RB::Rect::translate((float32x2_t *)&v22, v17, v17.f32[1]);
    if (((_BYTE)this[11] & 2) != 0)
      *(_OWORD *)a2->f32 = v22;
    else
      RB::Rect::Union(a2, *(float32x2_t *)&v22, *(float32x2_t *)((char *)&v22 + 8), v18, v19, v20, v21);
  }
}

void RB::`anonymous namespace'::render_glyphs(_BOOL8 a1, uint64_t a2, float64x2_t *a3, float32x2_t *this, char a5, int a6)
{
  uint64_t v11;
  double v12;
  float32x2_t v13;
  int32x2_t *v14;
  BOOL v15;
  int64x2_t v16;
  uint64_t v17;
  double v18;
  int64x2_t v19;
  double v20;
  char v21;
  uint64_t v22;
  size_t v23;
  char *v24;
  MTLPixelFormat v25;
  unsigned int *v26;
  __n128 v27;
  __n128 v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  RB::Buffer *v35;
  char *v36;
  unint64_t v37;
  RB::Buffer *v38;
  uint64_t v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  _BYTE *v45;
  unint64_t v46;
  _DWORD **v47;
  _DWORD *v48;
  int v49;
  char v50;
  int32x2_t v51;
  uint32x2_t v52;
  int8x8_t v53;
  uint64_t v54;
  int v55;
  float64x2_t v56;
  int64x2_t v57;
  int32x2_t v58[2];
  _QWORD v59[3];
  int32x2_t v60[3];
  unint64_t v61;
  float32x2_t v62;
  float32x2_t v63;
  uint64_t v64;

  v64 = *MEMORY[0x24BDAC8D0];
  if (this[2].i32[0])
  {
    v11 = a1;
    if (!a6
      || (v12 = RB::Coverage::Glyphs::bounds(this, a3, 0),
          RB::Bounds::Bounds(v60, *(float32x2_t *)&v12, v13),
          a1 = RB::Bounds::intersects(v14, *(int32x2_t *)(a2 + 160), *(int32x2_t *)(a2 + 168))))
    {
      v15 = (this[2].i32[1] & 8) == 0;
      v16 = *(int64x2_t *)a3;
      v56 = a3[1];
      v57 = v16;
      v18 = RB::max_cached_glyph_mask_area((RB *)a1);
      *(double *)v19.i64 = -*(double *)&v57.i64[1];
      v20 = fabs(vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v19, v57), v56)));
      v21 = v20 > v18 || v15;
      if ((v21 & 1) != 0 || this[6].u8[4] >= 2u)
      {
        return;
      }
      v62 = 0;
      v63 = 0;
      v22 = this[2].u32[0];
      if (v22 > 0x80)
      {
        v24 = (char *)malloc_type_malloc(32 * v22, 0x3AECBCuLL);
        if (!v24)
        {
LABEL_70:
          free(v24);
          return;
        }
      }
      else
      {
        MEMORY[0x24BDAC7A8](v17, 32 * v22);
        v24 = (char *)&v54 - ((v23 + 15) & 0x3FFFFFFFF0);
        bzero(v24, v23);
      }
      v60[0] = (int32x2_t)v24;
      v60[1] = (int32x2_t)&v61;
      v60[2] = (int32x2_t)&v62;
      v61 = 0;
      if (v61)
      {
        v26 = RB::pixel_format_traits(*(_QWORD *)(a2 + 88), v25);
        v29 = *((unsigned __int16 *)v26 + 2);
        v30 = *v26;
        if ((a5 & 1) != 0)
          v31 = 1;
        else
          v31 = (**(uint64_t (***)(uint64_t))v11)(v11) ^ 1;
        if (v31 && ((v30 | (v29 << 32)) & 0x4000000000) != 0 && ((a6 ^ 1) & 1) == 0)
        {
          *(_BYTE *)(a2 + 176) = 1;
          *(_DWORD *)(a2 + 180) = 1;
        }
        v55 = a6 ^ 1;
        *(_QWORD *)&v56.f64[0] = v30 | (v29 << 32);
        v32 = v61;
        if (v61)
        {
          v33 = 0;
          v57.i64[0] = (uint64_t)(v24 + 24);
          while (v32)
          {
            v34 = 0;
            v35 = 0;
            v36 = v24;
            v37 = v32;
            do
            {
              if (!v36[24])
              {
                if (v35)
                  v38 = v35;
                else
                  v38 = *(RB::Buffer **)v36;
                if (v35)
                  v39 = v34;
                else
                  v39 = 1;
                if (v35)
                  v40 = v34 + 1;
                else
                  v40 = v34;
                if (*(RB::Buffer **)v36 == v35)
                {
                  v34 = v40;
                }
                else
                {
                  v35 = v38;
                  v34 = v39;
                }
              }
              v36 += 32;
              --v37;
            }
            while (v37);
            v41 = v32;
            if (v34)
            {
              RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)(16 * v34), 4uLL, 0, v59);
              if (v59[0])
              {
                v42 = v61;
                if (v61)
                {
                  v43 = 0;
                  v44 = *(_QWORD *)(v59[0] + 56) + v59[1];
                  v45 = (_BYTE *)v57.i64[0];
                  do
                  {
                    if (!*v45 && *((RB::Buffer **)v45 - 3) == v35)
                    {
                      *(_OWORD *)(v44 + 16 * v43++) = *((_OWORD *)v45 - 1);
                      *v45 = 1;
                    }
                    v45 += 32;
                    --v42;
                  }
                  while (v42);
                }
                RB::Bounds::Bounds(v58, v62, v63);
                if ((v31 & 1) != 0)
                  RB::render_masks_accumulate((int32x2_t *)a2, v58, v34, (uint64_t)v59, v35);
                else
                  (*(void (**)(uint64_t, uint64_t, unint64_t, _QWORD *, RB::Buffer *, double, double))(*(_QWORD *)v11 + 8))(v11, a2, v34, v59, v35, *(double *)v58, *(double *)&v58[1]);
                v33 += v34;
              }
              v32 = v61;
              v41 = v33;
              if (v33 != v61)
                continue;
            }
            if (v41)
            {
              v46 = 0;
              v47 = (_DWORD **)v24;
              do
              {
                v48 = *v47;
                if (*v47)
                {
                  v49 = v48[2] - 1;
                  v48[2] = v49;
                  if (!v49)
                  {
                    (*(void (**)(_DWORD *))(*(_QWORD *)v48 + 8))(v48);
                    v41 = v61;
                  }
                }
                ++v46;
                v47 += 4;
              }
              while (v46 < v41);
            }
            break;
          }
        }
        if ((v31 & 1) != 0)
        {
          if ((*(_QWORD *)&v56.f64[0] & 0x4000000000) != 0)
            v50 = v55;
          else
            v50 = 1;
          if ((v50 & 1) == 0)
          {
            *(_BYTE *)(a2 + 176) = 6;
            *(_DWORD *)(a2 + 180) = 0;
          }
          if (a6)
          {
            v27.n128_u64[0] = (unint64_t)v62;
            v28.n128_u64[0] = (unint64_t)v63;
          }
          else
          {
            v27.n128_u32[0] = 0;
            v51 = *(int32x2_t *)(a2 + 168);
            v52 = (uint32x2_t)vceq_s32(v51, (int32x2_t)0x8000000080000000);
            v53 = (int8x8_t)vdup_lane_s32(vcgt_s32((int32x2_t)v27.n128_u64[0], (int32x2_t)vpmin_u32(v52, v52)), 0);
            v28.n128_u64[0] = (unint64_t)vbsl_s8(v53, (int8x8_t)vdup_n_s32(0x7F7FFFFFu), (int8x8_t)vcvt_f32_s32(v51));
            v27.n128_u64[0] = (unint64_t)vbsl_s8(v53, (int8x8_t)0x100000001000000, (int8x8_t)vcvt_f32_s32(*(int32x2_t *)(a2 + 160)));
          }
          (*(void (**)(uint64_t, uint64_t, __n128, __n128))(*(_QWORD *)v11 + 16))(v11, a2, v27, v28);
          if ((v50 & 1) == 0)
          {
            *(_BYTE *)(a2 + 176) = 0;
            *(_DWORD *)(a2 + 180) = 0;
          }
        }
      }
      if (v22 >= 0x81)
        goto LABEL_70;
    }
  }
}

void sub_209AF31D8(_Unwind_Exception *exception_object)
{
  void *v1;
  unsigned int v2;

  if (v2 >= 0x81)
    free(v1);
  _Unwind_Resume(exception_object);
}

double RB::Coverage::Glyphs::bounds(float32x2_t *this, float64x2_t *a2, char a3)
{
  int v4;
  float32x2_t v5;
  double v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  int32x4_t v12;
  int8x8_t v18;
  float v19;
  int32x2_t v20;
  int32x4_t v21;

  v4 = this[2].i32[0];
  v5 = 0;
  if (v4 && *(_QWORD *)this)
  {
    v8 = RB::Coverage::Glyphs::glyph_bounds(this, 0, v4);
    v5 = RB::operator*(a2, *(float32x2_t *)&v8, v9);
    v11 = v10;
    *(int32x2_t *)v12.i8 = vcgtz_f32(v10);
    if ((vpmin_u32(*(uint32x2_t *)v12.i8, *(uint32x2_t *)v12.i8).u32[0] & 0x80000000) != 0
      && (a3 & 1) == 0
      && (this[2].i32[1] & 8) != 0)
    {
      *(int32x2_t *)v12.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
      __asm { FMOV            V1.2S, #-1.0 }
      v18 = (int8x8_t)vcltzq_s32(v12).u64[0];
      v5 = (float32x2_t)vbsl_s8(v18, (int8x8_t)vadd_f32(v5, _D1), (int8x8_t)v5);
      v11 = (float32x2_t)vbsl_s8(v18, (int8x8_t)vadd_f32(v11, (float32x2_t)0x4000000040000000), (int8x8_t)v11);
    }
    if (this[6].i8[4] == 3)
    {
      if (this[6].f32[0] >= 0.0)
        v19 = this[6].f32[0];
      else
        v19 = 0.0;
      *(float *)v20.i32 = v19 * RB::AffineTransform::scale(a2);
      *(int32x2_t *)v21.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v11);
      v5 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v21), (int8x8_t)vsub_f32(v5, (float32x2_t)vdup_lane_s32(v20, 0)), (int8x8_t)v5);
    }
  }
  return *(double *)&v5;
}

double RB::Coverage::Glyphs::glyph_bounds(float32x2_t *this, unsigned int a2, int a3)
{
  __int32 v3;
  unsigned int v4;
  double v5;
  CGFont *v8;
  size_t v10;
  uint32x2_t v11;
  float32x2_t *v12;
  uint64_t UnitsPerEm;
  float32x2_t v14;
  float32x2_t v15;
  __int128 v16;
  CGRect *v17;
  int v18;
  size_t v19;
  unint64_t v20;
  char v21;
  float32x2_t v22;
  uint64_t v23;
  uint64_t v24;
  float32x2_t v25;
  float32x2_t v26;
  float32x2_t v27;
  uint32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  uint64_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  CGFloat y;
  CGFloat height;
  __int128 v38;
  uint64_t v39;
  CGRect FontBBox;

  v39 = *MEMORY[0x24BDAC8D0];
  v3 = a3 + a2;
  v4 = this[2].u32[0];
  if (v4 < a3 + a2)
    v3 = this[2].i32[0];
  v5 = 0.0;
  if (v4 > a2 && v3 != a2)
  {
    v8 = (CGFont *)*this;
    if (v8)
    {
      v10 = v3 - a2;
      if (!a2 && (_DWORD)v10 == v4)
      {
        v11 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&this[5] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
        if ((vpmax_u32(v11, v11).u32[0] & 0x80000000) == 0)
          return *(double *)&this[4];
      }
      v12 = (float32x2_t *)(*(_QWORD *)&this[1] + 8 * a2);
      UnitsPerEm = CGFontGetUnitsPerEm(v8);
      v14 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm));
      v15 = vmul_f32(vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm), v14), v14);
      *(float32x2_t *)&v16 = vmul_f32(v15, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT((float)(int)UnitsPerEm), v15));
      v38 = v16;
      if (v10 <= 0x80)
      {
        MEMORY[0x24BDAC7A8](UnitsPerEm, 32 * v10);
        v17 = (CGRect *)((char *)&v38 - ((v19 + 15) & 0x3FFFFFFFF0));
        bzero(v17, v19);
        v18 = 0;
      }
      else
      {
        v17 = (CGRect *)malloc_type_malloc(32 * v10, 0x22E1B91FuLL);
        v18 = 1;
        if (!v17)
          goto LABEL_29;
      }
      if (CGFontGetGlyphBBoxes(*(CGFontRef *)this, (const CGGlyph *)(*(_QWORD *)&this[1] + 8 * this[2].u32[0] + 2 * a2), v10, v17))
      {
        v20 = 0;
        v21 = 0;
        v22 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v38, 0);
        if (v10 <= 1)
          v23 = 1;
        else
          v23 = v10;
        v24 = 32 * v23;
        v25 = (float32x2_t)vdup_n_s32(0x7F800000u);
        v26 = (float32x2_t)0x7F0000007FLL;
        do
        {
          v27 = vcvt_f32_f64((float64x2_t)v17[v20 / 0x20].size);
          v28 = (uint32x2_t)vcgtz_f32(v27);
          if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0)
          {
            v29 = vmla_f32(*v12, vcvt_f32_f64((float64x2_t)v17[v20 / 0x20].origin), v22);
            v25 = vminnm_f32(v25, v29);
            v26 = vmaxnm_f32(v26, vmla_f32(v29, v27, v22));
            v21 = 1;
          }
          v20 += 32;
          ++v12;
        }
        while (v24 != v20);
        v5 = 0.0;
        v30 = 0;
        if ((v21 & 1) == 0)
        {
          if (!a2)
          {
LABEL_36:
            if ((_DWORD)v10 == this[2].i32[0])
            {
              *(double *)&this[4] = v5;
              this[5] = v30;
            }
          }
LABEL_38:
          if (v18)
            free(v17);
          return v5;
        }
LABEL_35:
        v30 = vsub_f32(v26, v25);
        v5 = *(double *)&v25;
        if (!a2)
          goto LABEL_36;
        goto LABEL_38;
      }
LABEL_29:
      if (v10 <= 1)
        v31 = 1;
      else
        v31 = v10;
      v32 = (float32x2_t)vdup_n_s32(0x7F800000u);
      v33 = (float32x2_t)0x7F0000007FLL;
      do
      {
        v34 = *v12++;
        v32 = vminnm_f32(v32, v34);
        v33 = vmaxnm_f32(v33, v34);
        --v31;
      }
      while (v31);
      FontBBox = CGFontGetFontBBox((CGFontRef)*(_QWORD *)this);
      y = FontBBox.origin.y;
      height = FontBBox.size.height;
      *(float32x2_t *)&FontBBox.origin.y = vcvt_f32_f64((float64x2_t)FontBBox.size);
      *(float32x2_t *)&FontBBox.size.width = vmul_n_f32(vcvt_f32_f64((float64x2_t)FontBBox.origin), *(float *)&v38);
      v25 = vadd_f32(*(float32x2_t *)&FontBBox.size.width, v32);
      v26 = vadd_f32(vmla_n_f32(v33, *(float32x2_t *)&FontBBox.origin.y, *(float *)&v38), *(float32x2_t *)&FontBBox.size.width);
      goto LABEL_35;
    }
  }
  return v5;
}

void sub_209AF35BC(_Unwind_Exception *exception_object)
{
  void *v1;
  int v2;

  if (v2)
    free(v1);
  _Unwind_Resume(exception_object);
}

int32x2_t *RB::render_glyphs(RB::RenderPass &,RB::AffineTransform const&,RB::Coverage::Glyphs const&,RB::Fill::Color const&,BOOL,RB::BlendMode)::Renderer::draw_mask(uint64_t a1, uint64_t a2, float32x2_t a3, double a4)
{
  uint16x4_t v8;
  int16x4_t v9;
  uint64_t v10;
  int v11;
  float16x4_t v12;
  RB::Buffer *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  const char *v17;
  RB::Buffer *v19;
  int32x2_t v20[2];
  __int128 v21;
  _BYTE v22[20];
  RB::Buffer *v23;
  int64x2_t v24;

  *(float *)v8.i32 = RB::Coverage::set_plane((float32x2_t *)&v21, (float32x2_t *)a2, a3, a4);
  v10 = *(_QWORD *)(a1 + 8);
  if (*(_BYTE *)(v10 + 9) && (v11 = *(unsigned __int8 *)(a2 + 124), *(unsigned __int8 *)(v10 + 8) != v11))
  {
    v19 = *(RB::Buffer **)v10;
    v24.i16[0] = *(_WORD *)(v10 + 8);
    v23 = v19;
    RB::Fill::Color::convert((uint64_t)&v23, v11, v8);
    v12.i16[3] = 15360;
    v12.i32[0] = (int)v23;
    v12.i16[2] = WORD2(v23);
    v9.i32[0] = (unint64_t)v23 >> 48;
  }
  else
  {
    v12.i32[0] = *(_DWORD *)v10;
    v12.i16[2] = *(_WORD *)(v10 + 4);
    v12.i16[3] = unk_209BD6ED0;
    v9.i16[0] = *(_WORD *)(v10 + 6);
  }
  *(float16x4_t *)&v22[12] = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v9, 0)), vcvtq_f32_f16(v12)));
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x24, 4uLL, 0, &v23);
  v13 = v23;
  if (v23)
  {
    v14 = *((_QWORD *)v23 + 7) + v24.i64[0];
    v15 = v21;
    v16 = *(_OWORD *)v22;
    *(_DWORD *)(v14 + 32) = *(_DWORD *)&v22[16];
    *(_OWORD *)v14 = v15;
    *(_OWORD *)(v14 + 16) = v16;
  }
  else
  {
    v23 = 0;
    v24 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v13);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v24);
  v17 = (const char *)(((unint64_t)(*(unsigned __int8 *)(a1 + 16) | (2
                                                                          * (*(_DWORD *)(a2 + 136) == 2))) << 32) | ((unint64_t)(*(_DWORD *)(a1 + 20) & 0x3F) << 6) | 0x12);
  RB::Bounds::Bounds(v20, a3, *(float32x2_t *)&a4);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, v17, 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, v20[0], v20[1]);
}

float32x2_t *RB::Rect::Union(float32x2_t *result, float32x2_t a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  uint32x2_t v7;
  float32x2_t v8;
  uint32x2_t v9;
  int32x4_t v10;
  float32x2_t v11;
  float32x2_t v12;

  v7 = (uint32x2_t)vceqz_f32(a3);
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
  {
    v8 = result[1];
    v9 = (uint32x2_t)vceqz_f32(v8);
    if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) == 0)
    {
      *(int32x2_t *)a7.i8 = vcltz_f32(v8);
      v10 = vcltzq_s32(a7);
      v11 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vadd_f32(*result, v8), (int8x8_t)*result);
      *(int32x2_t *)v10.i8 = vcltz_f32(a3);
      v12 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v10), (int8x8_t)vadd_f32(a3, a2), (int8x8_t)a2);
      a2 = vminnm_f32(v11, v12);
      a3 = vsub_f32(vmaxnm_f32(vadd_f32(v11, vabs_f32(v8)), vadd_f32(v12, (float32x2_t)(*(_QWORD *)&a3 & 0x7FFFFFFF7FFFFFFFLL))), a2);
    }
    *result = a2;
    result[1] = a3;
  }
  return result;
}

uint64_t *RB::RenderFrame::cached_region@<X0>(uint64_t a1@<X0>, unsigned int a2@<W1>, unsigned int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t *result;
  unint64_t v6;

  v6 = __PAIR64__(a3, a2);
  result = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 152), (uint64_t *)&v6, 0);
  if (result)
  {
    *(_QWORD *)a4 = result[1];
    *(_OWORD *)(a4 + 8) = *((_OWORD *)result + 1);
  }
  else
  {
    *(_QWORD *)a4 = 0;
    *(_QWORD *)(a4 + 8) = 0;
    *(_QWORD *)(a4 + 16) = 0;
  }
  return result;
}

uint64_t RB::RenderFrame::set_cached_region(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  RB::Heap *v8;
  size_t *v9;
  unint64_t v11;

  v8 = *(RB::Heap **)(a1 + 184);
  if (!v8)
  {
    v8 = (RB::Heap *)operator new();
    RB::Heap::Heap(v8, 0, 0, 0x400uLL);
    *(_QWORD *)(a1 + 184) = v8;
  }
  v11 = __PAIR64__(a3, a2);
  RB::Heap::emplace<RB::RenderFrame::RegionEntry,RB::RenderFrame::RegionKey,RB::BufferRegion const&>(v8, &v11, a4);
  return RB::UntypedTable::insert((size_t **)(a1 + 152), v9, v9);
}

void sub_209AF38E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1030C4075D23742);
  _Unwind_Resume(a1);
}

__n128 RB::Heap::emplace<RB::RenderFrame::RegionEntry,RB::RenderFrame::RegionKey,RB::BufferRegion const&>(RB::Heap *this, unint64_t *a2, uint64_t a3)
{
  unint64_t v6;
  __n128 *v7;
  unint64_t v8;
  __n128 result;

  v6 = *((_QWORD *)this + 3);
  v7 = (__n128 *)((*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)v7[2].n128_u64 > v6)
    v7 = (__n128 *)RB::Heap::alloc_slow((size_t *)this, 0x20uLL, 7);
  else
    *((_QWORD *)this + 2) = v7 + 2;
  v8 = *(_QWORD *)a3;
  result = *(__n128 *)(a3 + 8);
  v7->n128_u64[0] = *a2;
  v7->n128_u64[1] = v8;
  v7[1] = result;
  return result;
}

uint64_t RB::Device::glyph_lock(RB::Device *this)
{
  uint64_t result;

  result = *((_QWORD *)this + 121);
  if (!result)
  {
    result = CGGlyphLockCreate();
    *((_QWORD *)this + 121) = result;
  }
  return result;
}

float32x2_t RB::Rect::translate(float32x2_t *this, float32x2_t result, float32_t a3)
{
  float32x2_t v3;
  uint32x2_t v4;
  uint32x2_t v5;

  v3 = this[1];
  v4 = (uint32x2_t)vclez_f32(v3);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    v5 = (uint32x2_t)vceq_f32(v3, (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
    {
      result.f32[1] = a3;
      result = vadd_f32(*this, result);
      *this = result;
    }
  }
  return result;
}

void RB::Coverage::Glyphs::show(float32x2_t **this, uint64_t size, int a3)
{
  uint64_t v6;
  size_t v7;
  CGPoint *v8;
  uint64_t v9;
  float32x2_t *v10;
  float64x2_t *v11;
  float32x2_t v12;
  int v13;
  CGTextDrawingMode v14;
  _QWORD v15[2];

  v15[1] = *MEMORY[0x24BDAC8D0];
  v6 = *((unsigned int *)this + 4);
  if (v6 > 0x100)
  {
    v8 = (CGPoint *)malloc_type_malloc(16 * v6, 0x9432FFD9uLL);
    if (!v8)
    {
LABEL_13:
      free(v8);
      return;
    }
  }
  else
  {
    MEMORY[0x24BDAC7A8](this, 16 * v6);
    v8 = (CGPoint *)((char *)v15 - ((v7 + 15) & 0x1FFFFFFFF0));
    bzero(v8, v7);
  }
  v9 = *((unsigned int *)this + 4);
  if ((_DWORD)v9)
  {
    v10 = this[1];
    v11 = (float64x2_t *)v8;
    do
    {
      v12 = *v10++;
      *v11++ = vcvtq_f64_f32(v12);
      --v9;
    }
    while (v9);
  }
  v13 = rb_clip_mode(*((unsigned __int8 *)this + 52));
  if (*(unsigned __int8 *)(size + 140) != v13)
    RB::CGContext::set_aliasing_mode_slow(size, v13);
  CGContextSetFont(*(CGContextRef *)size, (CGFontRef)*this);
  CGContextSetFontRenderingStyle();
  if (a3)
    v14 = kCGTextClip;
  else
    v14 = kCGTextFill;
  CGContextSetTextDrawingMode(*(CGContextRef *)size, v14);
  CGContextSetShouldDrawBitmapRuns();
  CGContextShowGlyphsAtPositions(*(CGContextRef *)size, (const CGGlyph *)&this[1][*((unsigned int *)this + 4)], v8, *((unsigned int *)this + 4));
  if (v6 >= 0x101)
    goto LABEL_13;
}

void RB::Coverage::Glyphs::fill(float32x2_t *this, RB::CGContext *a2, const RB::Fill::Color *a3, double _D0)
{
  double v16;
  float32x2_t v17;
  BOOL v29;
  float64x2_t v42[2];
  uint64_t v43;
  uint64_t v44;
  int32x2_t v45[2];

  if (this[2].i32[0] < 2u)
    goto LABEL_31;
  _H0 = *((_WORD *)a3 + 3);
  __asm { FCVT            S0, H0 }
  _ZF = _S0 == 1.0;
  LODWORD(_D0) = *((_DWORD *)a2 + 33);
  _ZF = _ZF && *(float *)&_D0 == 1.0;
  if (_ZF && *((_DWORD *)a2 + 34) == 2)
  {
LABEL_31:
    if (*((_BYTE *)a2 + 121))
      v29 = *((_BYTE *)a3 + 9) == 0;
    else
      v29 = 1;
    if (!v29 && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
      goto LABEL_27;
    _H0 = *((_WORD *)a2 + 56);
    _H1 = *(_WORD *)a3;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)&_D0 != _S1)
      goto LABEL_27;
    _H0 = *((_WORD *)a2 + 57);
    _H1 = *((_WORD *)a3 + 1);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)&_D0 != _S1)
      goto LABEL_27;
    _H0 = *((_WORD *)a2 + 58);
    _H1 = *((_WORD *)a3 + 2);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)&_D0 != _S1)
      goto LABEL_27;
    _H0 = *((_WORD *)a2 + 59);
    _H1 = *((_WORD *)a3 + 3);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)&_D0 != _S1)
LABEL_27:
      RB::CGContext::set_fill_color_slow(a2, a3, *(uint16x4_t *)&_D0);
    RB::Coverage::Glyphs::show((float32x2_t **)this, (uint64_t)a2, 0);
  }
  else
  {
    RB::CGContext::save(a2);
    _H1 = *((_WORD *)a3 + 3);
    __asm { FCVT            S1, H1 }
    RB::CGContext::set_alpha(a2, *((float *)a2 + 33) * _S1);
    v42[0] = (float64x2_t)xmmword_209BD5290;
    v42[1] = (float64x2_t)xmmword_209BD52A0;
    v43 = 0;
    v44 = 0;
    v16 = RB::Coverage::Glyphs::bounds(this, v42, 0);
    RB::Bounds::Bounds(v45, *(float32x2_t *)&v16, v17);
    RB::CGContext::begin_layer((uint64_t)a2, 1.0, v45[0], v45[1]);
    v42[0].f64[0] = *(float64_t *)a3;
    LOWORD(v42[0].f64[1]) = *((_WORD *)a3 + 4);
    _D0.i16[0] = 15360;
    HIWORD(v42[0].f64[0]) = 15360;
    if (*((_BYTE *)a2 + 121) && BYTE1(v42[0].f64[1]) && *((unsigned __int8 *)a2 + 120) != LOBYTE(v42[0].f64[1]))
      goto LABEL_16;
    _H0 = *((_WORD *)a2 + 56);
    _H1 = LOWORD(v42[0].f64[0]);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_16;
    _H0 = *((_WORD *)a2 + 57);
    _H1 = WORD1(v42[0].f64[0]);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_16;
    _H0 = *((_WORD *)a2 + 58);
    _H1 = WORD2(v42[0].f64[0]);
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_16;
    _H0 = *((_WORD *)a2 + 59);
    __asm { FCVT            S0, H0 }
    if (*(float *)_D0.i32 != 1.0)
LABEL_16:
      RB::CGContext::set_fill_color_slow(a2, (const RB::Fill::Color *)v42, _D0);
    RB::Coverage::Glyphs::show((float32x2_t **)this, (uint64_t)a2, 0);
    RB::CGContext::end_layer((CGContextRef *)a2);
    RB::CGContext::restore(a2);
  }
}

uint64_t RB::debug_float(RB *this, const char *a2)
{
  RB::Config *v2;
  const void *v3;
  uint64_t v4;
  RB::Config *v6;

  RB::Config::debug_value(this, &v6);
  v2 = v6;
  v4 = RB::Config::float_value((const __CFString *)v6, v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

uint64_t RB::Config::float_value(const __CFString *this, const void *a2)
{
  float DoubleValue;
  CFTypeID v4;
  uint64_t v5;
  float valuePtr;

  DoubleValue = 0.0;
  if (!this)
    goto LABEL_8;
  v4 = CFGetTypeID(this);
  if (v4 != CFNumberGetTypeID())
  {
    if (v4 == CFStringGetTypeID())
    {
      DoubleValue = CFStringGetDoubleValue(this);
      goto LABEL_7;
    }
LABEL_8:
    v5 = 0;
    return v5 | LODWORD(DoubleValue);
  }
  valuePtr = 0.0;
  if (!CFNumberGetValue((CFNumberRef)this, kCFNumberFloatType, &valuePtr))
    goto LABEL_8;
  DoubleValue = valuePtr;
LABEL_7:
  v5 = 0x100000000;
  return v5 | LODWORD(DoubleValue);
}

RB::XML::Document *RBDrawingStateDrawLayer(uint64_t a1, RB::DisplayList::State *a2, unsigned int a3, float a4)
{
  unsigned int *v8;
  uint64_t v9;
  int v10;
  RB::XML::Document *result;

  v8 = *(unsigned int **)(a1 + 8);
  if (!*((_QWORD *)v8 + 3))
    make_contents(*(unsigned int **)(a1 + 8));
  if (v8 != *((unsigned int **)a2 + 1))
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  v9 = RB::DisplayList::Builder::end_layer((RB::DisplayList::Builder *)(v8 + 4), a2);
  RB::DisplayList::Builder::delete_state(v8 + 4, a2);
  v10 = rb_blend_mode(a3);
  RB::DisplayList::Builder::draw_layer((uint64_t)(v8 + 4), v9, (int8x16_t *)a1, v10, a4);
  result = (RB::XML::Document *)*((_QWORD *)v8 + 38);
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::draw_layer(result, a3, a4);
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,float &,RB::BlendMode &,RB::DisplayList::Layer *&>(size_t *a1, float *a2, _DWORD *a3, uint64_t *a4)
{
  uint64_t v7;
  double result;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v7 + 56;
  *(_QWORD *)&result = RB::DisplayList::LayerItem::LayerItem(v7, *a3, *a4, *a2);
  return result;
}

void RB::DisplayList::LayerItem::~LayerItem(RB::DisplayList::LayerItem *this)
{
  RB::DisplayList::Layer *v2;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
}

{
  RB::DisplayList::Layer *v2;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  JUMPOUT(0x20BD16544);
}

float64x2_t RB::GeometryStyle::Rotation::set_affine_transform(RB::GeometryStyle::Rotation *this, float64x2_t *a2)
{
  float64x2_t v4;
  __double2 v5;
  float64x2_t v6;
  float64x2_t result;

  v5 = __sincos_stret(*(double *)this);
  v4.f64[0] = v5.__cosval;
  v6.f64[0] = -v5.__sinval;
  v6.f64[1] = v5.__cosval;
  v4.f64[1] = v5.__sinval;
  result = vmlaq_n_f64(vmlaq_n_f64(vcvtq_f64_f32(*(float32x2_t *)((char *)this + 8)), v6, (float)-COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1)))), v4, (float)-COERCE_FLOAT(*((_QWORD *)this + 1)));
  *a2 = v4;
  a2[1] = v6;
  a2[2] = result;
  return result;
}

uint64_t RB::Coverage::Primitive::make_shadow(RB::Coverage::Primitive *this, float64x2_t *a2, float a3, float *a4, int a5, RB::Coverage::Primitive *a6)
{
  float v13;
  float v14;
  __int128 v15;
  __int128 v16;
  float32x4_t v17;
  float v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  float v26;
  float v27;

    return 0;
  v13 = 0.0;
  if (a3 < 0.0)
    a3 = 0.0;
  v14 = RB::AffineTransform::scale(a2) * a3;
  switch(*((_BYTE *)this + 44))
  {
    case 0:
    case 1:
      v19 = *(_OWORD *)this;
      v20 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v19;
      *((_OWORD *)a6 + 1) = v20;
      goto LABEL_16;
    case 2:
      if (*((float *)this + 9) > 0.0)
        return 0;
      v22 = *(_OWORD *)this;
      v23 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v22;
      *((_OWORD *)a6 + 1) = v23;
      *((_BYTE *)a6 + 44) = 3;
      *(_QWORD *)&v22 = *((_QWORD *)this + 1);
      v13 = fminf(*(float *)&v22, *((float *)&v22 + 1));
      *(float *)&v22 = sqrtf((float)(v14 + v14) * (float)(v14 + v14));
      v17 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v22, 0);
      goto LABEL_9;
    case 3:
    case 4:
      if (*((float *)this + 8) != 1.0 || *((float *)this + 9) > 0.0)
        return 0;
      v21 = *(_OWORD *)this;
      v16 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v21;
      *((_OWORD *)a6 + 1) = v16;
      v13 = fminf(COERCE_FLOAT(*((_QWORD *)this + 1)), COERCE_FLOAT(HIDWORD(*((_QWORD *)this + 1))));
LABEL_8:
      *(float *)&v16 = (float)(v14 + v14) * (float)(v14 + v14);
      v17 = vsqrtq_f32(vmlaq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)&v16, 0), *((float32x4_t *)a6 + 1), *((float32x4_t *)a6 + 1)));
LABEL_9:
      *((float32x4_t *)a6 + 1) = v17;
      break;
    case 5:
      if (*((float *)this + 8) != 1.0)
        return 0;
      v24 = *(_OWORD *)this;
      v25 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v24;
      *((_OWORD *)a6 + 1) = v25;
      v26 = *((float *)this + 9);
      if ((float)(*((float *)this + 4) + *((float *)this + 4)) >= v26)
        v27 = *((float *)this + 9);
      else
        v27 = *((float *)this + 4) + *((float *)this + 4);
      if (v26 > 0.0)
        v13 = v27;
      else
        v13 = *((float *)this + 4) + *((float *)this + 4);
      break;
    case 6:
    case 7:
    case 8:
      v15 = *(_OWORD *)this;
      v16 = *((_OWORD *)this + 1);
      *(_OWORD *)((char *)a6 + 31) = *(_OWORD *)((char *)this + 31);
      *(_OWORD *)a6 = v15;
      *((_OWORD *)a6 + 1) = v16;
      v13 = *((float *)this + 9);
      goto LABEL_8;
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      break;
  }
  if ((*((_BYTE *)this + 46) & 4) != 0)
  {
    v14 = sqrtf((float)(v14 * v14) + (float)(*((float *)a6 + 10) * *((float *)a6 + 10)));
    *((float *)a6 + 10) = v14;
  }
  else
  {
    *((float *)a6 + 10) = v14;
    *((_BYTE *)a6 + 46) |= 4u;
  }
  v18 = v14 + v14;
  if (v13 < v18)
    *a4 = (float)(*a4 * v13) / v18;
LABEL_16:
  if (a5)
  {
    if (*((_BYTE *)a6 + 44))
    {
      if (*((_BYTE *)a6 + 44) == 1)
        *((_BYTE *)a6 + 44) = 0;
      else
        *((_BYTE *)a6 + 46) ^= 1u;
    }
    else
    {
      *((_BYTE *)a6 + 44) = 1;
    }
  }
  *((_BYTE *)a6 + 46) |= 2u;
  return 1;
}

uint64_t RB::Coverage::`anonymous namespace'::exact_blur(RB::Coverage::_anonymous_namespace_ *this)
{
  unsigned __int8 v1;
  const char *v3;
  unsigned int v4;

  if ((v1 & 1) == 0
  {
    v4 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_EXACT_BLUR", v3);
    if (v4 <= 0x100)
      LOBYTE(v4) = 0;
  }
}

void sub_209AF42FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

RB::XML::DisplayList *RBDrawingStateAddRotationStyle(__n128 *a1, double a2, float64_t a3, float64_t a4)
{
  unint64_t v6;
  float64x2_t v7;
  _RBDrawingState *v8;
  RB::XML::DisplayList *result;
  double v10;
  double v11;
  __n128 v12;
  CGPoint v13;

  v6 = a1->n128_u64[1];
  v10 = a3;
  v11 = a4;
  if (!*(_QWORD *)(v6 + 24))
  {
    make_contents((unsigned int *)v6);
    a3 = v10;
    a4 = v11;
  }
  v7.f64[0] = a3;
  v7.f64[1] = a4;
  v12.n128_f64[0] = a2;
  *(float32x2_t *)&v12.n128_i8[8] = vcvt_f32_f64(v7);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation>(a1, v6 + 16, &v12);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
  {
    v13.x = v10;
    v13.y = v11;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_rotation_style(result, (_RBDrawingState *)a1, v8, a2, v13);
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddShadowStyle2(uint64_t a1, unsigned int a2, unsigned int a3, char a4, double a5, double a6, double a7, float a8, float a9, float a10, float a11)
{
  return RBDrawingStateAddShadowStyle3(a1, a2, a3, a4, a5, 0.5, a6, a7, a8, a9, a10, a11);
}

RB::XML::DisplayList *RBDrawingStateAddTransformStyle(RB::DisplayList::State *this, uint64_t a2)
{
  _QWORD *v4;
  const RB::DisplayList::Transform *v5;
  const RB::DisplayList::Transform *v6;
  RB::XML::DisplayList *result;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v4[3])
    make_contents(*((unsigned int **)this + 1));
  if (a2)
    v5 = (const RB::DisplayList::Transform *)(a2 + 8);
  else
    v5 = 0;
  RB::DisplayList::State::add_transform((__n128 *)this, (RB::DisplayList::Builder *)(v4 + 2), v5);
  result = (RB::XML::DisplayList *)v4[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_transform_style(result, (_RBDrawingState *)this, (_RBDrawingState *)v5, v6);
  return result;
}

__n128 RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>(RB::Heap *this, __n128 *a2)
{
  unint64_t v4;
  unint64_t v5;
  __n128 result;

  v4 = *((_QWORD *)this + 3);
  v5 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 72 > v4)
    v5 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v5 + 72;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C228708;
  result = *a2;
  *(__n128 *)(v5 + 56) = *a2;
  return result;
}

id __copy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int *v7;
  unsigned int v8;
  id result;

  v3 = *(_QWORD *)(a2 + 32);
  if (v3)
  {
    v4 = (unsigned int *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  a1[4] = v3;
  v6 = *(_QWORD *)(a2 + 40);
  if (v6)
  {
    v7 = (unsigned int *)(v6 + 8);
    do
      v8 = __ldxr(v7);
    while (__stxr(v8 + 1, v7));
  }
  a1[5] = v6;
  result = *(id *)(a2 + 48);
  a1[6] = result;
  return result;
}

void sub_209AF45A8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t *v2;
  uint64_t v4;

  v4 = *(_QWORD *)(v1 + 40);
  if (v4)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3(v4);
  RB::DisplayList::Builder::Builder(v2);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::queue_id(RB::Surface *this, _CAImageQueue *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  size_t v11;
  char *v12;
  char *v13;

  if (!a2)
    return 0;
  v4 = (char *)this + 64;
  v5 = (char *)*((_QWORD *)this + 12);
  v6 = *((_QWORD *)this + 13);
  if (!v5)
    v5 = (char *)this + 64;
  if (v6)
  {
    v7 = v5 + 8;
    v8 = 16 * v6;
    while (*((_CAImageQueue **)v7 - 1) != a2)
    {
      v7 += 16;
      v8 -= 16;
      if (!v8)
        goto LABEL_8;
    }
    return *(_QWORD *)v7;
  }
  else
  {
LABEL_8:
    v9 = CAImageQueueRegisterIOSurfaceBuffer();
    v10 = *((_QWORD *)this + 13);
    v11 = v10 + 1;
    if (*((_QWORD *)this + 14) < (unint64_t)(v10 + 1))
    {
      v10 = *((_QWORD *)this + 13);
      v11 = v10 + 1;
    }
    v12 = (char *)*((_QWORD *)this + 12);
    if (!v12)
      v12 = v4;
    v13 = &v12[16 * v10];
    *(_QWORD *)v13 = a2;
    *((_QWORD *)v13 + 1) = v9;
    *((_QWORD *)this + 13) = v11;
  }
  return v9;
}

uint64_t RB::RenderParams::RenderParams(uint64_t result, uint64_t a2, uint64_t a3, char a4, char a5, char a6, double a7, float a8)
{
  char v8;

  *(_QWORD *)result = a2;
  *(_QWORD *)(result + 8) = a3;
  *(double *)(result + 16) = a7;
  *(float *)(result + 24) = a8;
  *(_BYTE *)(result + 28) = a4;
  *(_BYTE *)(result + 29) = a5;
  v8 = *(_BYTE *)(result + 30) & 0xFE | a6;
  *(_BYTE *)(result + 30) = v8;
  *(_BYTE *)(result + 30) = v8 & 0xF1 | (2 * (*(_BYTE *)(*(_QWORD *)a2 + 283) != 0));
  return result;
}

void RB::SurfacePool::collect_async(RB::SurfacePool *this)
{
  os_unfair_lock_lock((os_unfair_lock_t)this);
  if (*((_BYTE *)this + 128))
  {
    os_unfair_lock_unlock((os_unfair_lock_t)this);
  }
  else
  {
    *((_BYTE *)this + 128) = 1;
    os_unfair_lock_unlock((os_unfair_lock_t)this);
    dispatch_async_f(*((dispatch_queue_t *)this + 1), this, (dispatch_function_t)RB::SurfacePool::AsyncCollection::~AsyncCollection()::$_0::__invoke);
  }
}

void sub_209AF4ADC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, char a11)
{
  uint64_t v11;

  MEMORY[0x20BD16544](v11, 0x10A0C405E99A6A3);
  if (a11)
    os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

uint64_t RB::BinAllocator::BinAllocator(uint64_t a1, double a2)
{
  _QWORD *v3;
  uint64_t v4;

  *(double *)a1 = a2;
  *(double *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  v3 = (_QWORD *)(a1 + 16);
  RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(a1 + 16, 1u);
  v4 = *v3 + 32 * *(unsigned int *)(a1 + 24);
  *(_WORD *)v4 = 0;
  *(int16x4_t *)(v4 + 2) = vuzp1_s16(*(int16x4_t *)&a2, vdup_lane_s16(*(int16x4_t *)&a2, 0));
  *(_QWORD *)(v4 + 24) = 0;
  *(_QWORD *)(v4 + 16) = 0;
  RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(v4 + 16, 1u);
  *(_DWORD *)(*(_QWORD *)(v4 + 16) + 4 * (*(_DWORD *)(v4 + 24))++) = LOWORD(a2) << 16;
  ++*(_DWORD *)(a1 + 24);
  return a1;
}

uint64_t RB::SharedSurfaceGroup::add_subsurface(os_unfair_lock_s *this, RB::SharedSurfaceClient *a2, uint64_t a3, int a4, int a5, void *a6, unsigned __int32 a7, void (**a8)(_QWORD, _QWORD), double a9, float a10, __n128 a11)
{
  int v20;
  RB::SharedSurfaceGroup *v21;
  uint32x2_t v22;
  os_unfair_lock_s *v23;
  uint64_t v24;
  __int128 v25;
  os_unfair_lock_s *v26;
  os_unfair_lock_s *v27;
  char v28;
  uint64_t v29;
  uint64_t v30;
  int32x2_t v31;
  __int128 v32;
  int32x2_t v33;
  uint32x2_t v34;
  int i;
  double v36;
  int j;
  os_unfair_lock_s *v38;
  RB::Surface *v39;
  int32x2_t *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int *v44;
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v46;
  unsigned int v47;
  unsigned int *v48;
  unsigned int v49;
  unsigned int *v50;
  unsigned int v51;
  unint64_t v52;
  unsigned int v53;
  uint64_t v54;
  id v55;
  unint64_t v56;
  unsigned int v57;
  os_unfair_lock_s *v58;
  __n128 *v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  uint64_t v63;
  __int128 v64;
  __int128 v65;
  RB::SharedSurfaceClient *v66;
  unsigned int *v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  void (**v72)(_QWORD, _QWORD);
  __int128 v74;
  double v75;
  _QWORD v77[5];
  id v78;
  unint64_t v79;
  double v80;
  uint64_t v81;
  unsigned int v82;
  BOOL v83;
  unint64_t v84;
  RB::SharedSurfaceClient *v85;
  id v86;
  unint64_t v87;
  double v88;
  uint64_t v89;
  unsigned int v90;
  BOOL v91;
  id v92;
  id v93;
  __int128 v94;
  _BYTE v95[32];
  uint64_t v96;

  v96 = *MEMORY[0x24BDAC8D0];
  if ((a7 & 1) == 0)
  {
    v20 = vmul_lane_s32(*(int32x2_t *)&a9, *(int32x2_t *)&a9, 1).u32[0];
    v21 = (RB::SharedSurfaceGroup *)RB::SharedSurfaceGroup::max_subsurface_area((RB::SharedSurfaceGroup *)this);
    if (v20 > (int)v21)
      return 0;
    v22 = (uint32x2_t)vcgt_s32(*(int32x2_t *)&a9, vdup_n_s32(RB::SharedSurfaceGroup::max_subsurface_size(v21)));
    if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) != 0)
      return 0;
  }
  if (*((_DWORD *)a2 + 8))
    RB::SharedSurfaceGroup::cancel_async_updates(this, a2);
  if (!RB::SharedSurfaceGroup::wait_for_allocations((RB::SharedSurfaceGroup *)this, a2))
    return 0;
  v72 = a8;
  v84 = 0;
  v23 = this + 4;
  os_unfair_lock_lock(this + 4);
  v26 = this + 6;
  v27 = *(os_unfair_lock_s **)&this[8]._os_unfair_lock_opaque;
  if (v27 == &this[6])
  {
    v33 = (int32x2_t)0x10000000100;
    goto LABEL_21;
  }
  v28 = 0;
  *(_QWORD *)&v25 = 0x10000000100;
  v74 = v25;
  while (1)
  {
    v29 = *(_QWORD *)&v27[4]._os_unfair_lock_opaque;
    v30 = *(_QWORD *)(v29 + 24);
    if (*(_QWORD *)(v30 + 32) != a3
      || *(unsigned __int8 *)(v30 + 44) != a4
      || *(_DWORD *)(v30 + 40) != a5
      || *(float *)(v29 + 64) != a10)
    {
      goto LABEL_15;
    }
    v31 = *(int32x2_t *)(v29 + 32);
    v24 = RB::BinAllocator::alloc((int32x2_t *)(v29 + 32), &v84, *(int32x2_t *)&a9);
    *((_QWORD *)&v32 + 1) = *((_QWORD *)&v74 + 1);
    *(int32x2_t *)&v32 = vmax_s32(*(int32x2_t *)&v74, v31);
    v74 = v32;
    if ((v24 & 1) != 0)
      break;
    v28 = 1;
LABEL_15:
    v27 = *(os_unfair_lock_s **)&v27[2]._os_unfair_lock_opaque;
    if (v27 == v26)
    {
      v23 = this + 4;
      v33 = (int32x2_t)v74;
      if ((v28 & 1) == 0)
        goto LABEL_21;
      goto LABEL_17;
    }
  }
  ++*(_DWORD *)(v29 + 104);
  v43 = *(_QWORD *)&v27[4]._os_unfair_lock_opaque;
  v23 = this + 4;
  v33 = (int32x2_t)v32;
  if (v43)
    goto LABEL_31;
LABEL_17:
  v34 = (uint32x2_t)vcgt_s32((int32x2_t)0x80000000800, v33);
  if ((vpmax_u32(v34, v34).u32[0] & 0x80000000) != 0)
  {
    if (v33.i32[1] <= v33.i32[0])
      v33.i32[1] *= 2;
    else
      v33.i32[0] *= 2;
  }
LABEL_21:
  for (i = v33.i32[0]; i < SLODWORD(a9); v33.i32[0] = i)
    i *= 2;
  v36 = *(double *)&v33;
  for (j = v33.i32[1]; j < SHIDWORD(a9); HIDWORD(v36) = j)
    j *= 2;
  v75 = v36;
  v38 = (os_unfair_lock_s *)RB::SurfacePool::shared((RB::SurfacePool *)v24);
  v39 = (RB::Surface *)RB::SurfacePool::alloc(v38, *(_QWORD *)&this->_os_unfair_lock_opaque, a3, a4, a5, 0, v75, 0);
  if (!v39)
  {
    os_unfair_lock_unlock(v23);
    return 0;
  }
  v40 = (int32x2_t *)operator new();
  RB::SharedSurface::SharedSurface((RB::SharedSurface *)v40, (RB::SharedSurfaceGroup *)this, v39, a10);
  v41 = operator new(0x18uLL);
  v41[1] = v26;
  v41[2] = v40;
  v42 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  *v41 = v42;
  *(_QWORD *)(v42 + 8) = v41;
  *(_QWORD *)&this[6]._os_unfair_lock_opaque = v41;
  ++*(_QWORD *)&this[10]._os_unfair_lock_opaque;
  if (RB::BinAllocator::alloc(v40 + 4, &v84, *(int32x2_t *)&a9))
    ++v40[13].i32[0];
  v43 = v41[2];
LABEL_31:
  v44 = (unsigned int *)((char *)a2 + 32);
  p_os_unfair_lock_opaque = &this[14]._os_unfair_lock_opaque;
  do
  {
    v46 = __ldxr(p_os_unfair_lock_opaque);
    v47 = v46 + 1;
  }
  while (__stxr(v46 + 1, p_os_unfair_lock_opaque));
  v48 = (unsigned int *)((char *)a2 + 24);
  do
    v49 = __ldxr(v48);
  while (__stxr(v49 + 1, v48));
  v50 = (unsigned int *)((char *)a2 + 8);
  do
    v51 = __ldxr(v50);
  while (__stxr(v51 + 1, v50));
  v52 = v84;
  v53 = *(_DWORD *)(v43 + 80);
  if (*(_DWORD *)(v43 + 84) < v53 + 1)
  {
    RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(v43 + 72, v53 + 1);
    v53 = *(_DWORD *)(v43 + 80);
  }
  v54 = *(_QWORD *)(v43 + 72) + 32 * v53;
  *(_QWORD *)v54 = a2;
  *(_QWORD *)(v54 + 8) = v52;
  *(double *)(v54 + 16) = a9;
  *(_DWORD *)(v54 + 24) = v47;
  *(_BYTE *)(v54 + 28) = (a7 & 2) != 0;
  *(_BYTE *)(v54 + 29) = 0;
  ++*(_DWORD *)(v43 + 80);
  LOBYTE(this[15]._os_unfair_lock_opaque) = 1;
  os_unfair_lock_unlock(this + 4);
  v81 = 0;
  v78 = (id)v43;
  v79 = v84;
  v80 = a9;
  v82 = v47;
  v83 = (a7 & 2) != 0;
  os_unfair_lock_lock((os_unfair_lock_t)(v43 + 112));
  v55 = a6;
  v56 = v84;
  if ((a7 & 8) != 0)
  {
    v72 = (void (**)(_QWORD, _QWORD))objc_msgSend(v72, "copy");
    v58 = this + 4;
    do
      v60 = __ldxr(v50);
    while (__stxr(v60 + 1, v50));
    v85 = a2;
    v86 = v78;
    v87 = v79;
    v88 = v80;
    v89 = 0;
    v90 = v82;
    v91 = v83;
    v78 = 0;
    v92 = v72;
    v93 = v55;
    *(_QWORD *)&v94 = v56;
    *((double *)&v94 + 1) = a9;
    *(__n128 *)&v95[8] = a11;
    v61 = *(_DWORD *)(v43 + 160);
    v62 = *(_DWORD *)(v43 + 164);
    *(_DWORD *)&v95[24] = v47;
    *(_DWORD *)&v95[28] = a7;
    if (v62 < v61 + 1)
    {
      RB::vector<RB::SharedSurface::AsyncUpdate,0ul,unsigned int>::reserve_slow(v43 + 152, v61 + 1);
      v61 = *(_DWORD *)(v43 + 160);
      a2 = v85;
      v58 = this + 4;
    }
    v63 = *(_QWORD *)(v43 + 152) + 144 * v61;
    *(_QWORD *)v63 = a2;
    v85 = 0;
    *(_QWORD *)(v63 + 8) = v86;
    *(_QWORD *)(v63 + 16) = v87;
    *(double *)(v63 + 24) = v88;
    *(_QWORD *)(v63 + 32) = 0;
    *(_DWORD *)(v63 + 56) = v90;
    *(_BYTE *)(v63 + 60) = v91;
    v86 = 0;
    *(_QWORD *)(v63 + 64) = v92;
    v92 = 0;
    *(_QWORD *)(v63 + 80) = v93;
    v93 = 0;
    v64 = v94;
    v65 = *(_OWORD *)v95;
    *(_OWORD *)(v63 + 120) = *(_OWORD *)&v95[16];
    *(_OWORD *)(v63 + 104) = v65;
    *(_OWORD *)(v63 + 88) = v64;
    ++*(_DWORD *)(v43 + 160);

    RB::SharedSubsurface::~SharedSubsurface(&v86);
    v66 = v85;
    if (v85)
    {
      v67 = (unsigned int *)((char *)v85 + 8);
      do
      {
        v68 = __ldxr(v67);
        v69 = v68 - 1;
      }
      while (__stlxr(v69, v67));
      if (!v69)
      {
        __dmb(9u);
        (*(void (**)(RB::SharedSurfaceClient *))(*(_QWORD *)v66 + 8))(v66);
      }
    }
    do
      v70 = __ldxr(v44);
    while (__stxr(v70 + 1, v44));
  }
  else
  {
    v57 = *(_DWORD *)(v43 + 128);
    v58 = this + 4;
    if (*(_DWORD *)(v43 + 132) < v57 + 1)
    {
      RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::reserve_slow(v43 + 120, v57 + 1);
      v57 = *(_DWORD *)(v43 + 128);
    }
    v59 = (__n128 *)(*(_QWORD *)(v43 + 120) + ((unint64_t)v57 << 6));
    v59->n128_u64[0] = (unint64_t)v55;
    v59->n128_u64[1] = v56;
    v59[1].n128_f64[0] = a9;
    v59[2] = a11;
    v59[3].n128_u32[0] = v47;
    v59[3].n128_u32[1] = a7;
    ++*(_DWORD *)(v43 + 128);
  }

  os_unfair_lock_unlock((os_unfair_lock_t)(v43 + 112));
  if ((a7 & 8) != 0)
  {
    os_unfair_lock_lock(v58);
    if (BYTE1(this[15]._os_unfair_lock_opaque))
    {
      os_unfair_lock_unlock(v58);
    }
    else
    {
      BYTE1(this[15]._os_unfair_lock_opaque) = 1;
      os_unfair_lock_unlock(v58);
      v77[0] = MEMORY[0x24BDAC760];
      v77[1] = 3221225472;
      v77[2] = ___ZN2RB18SharedSurfaceGroup14add_subsurfaceERNS_19SharedSurfaceClientE14MTLPixelFormatNS_10ColorSpaceEjDv2_ifPU33objcproto22_RBDisplayListContents11objc_objectjDv4_fU13block_pointerFvRNS_16SharedSubsurfaceEE_block_invoke;
      v77[3] = &__block_descriptor_40_e5_v8__0l;
      v77[4] = this;
      if (objc_msgSend(MEMORY[0x24BDE57D8], "currentPhase") + 1 >= 4)
        ___ZN2RB18SharedSurfaceGroup14add_subsurfaceERNS_19SharedSurfaceClientE14MTLPixelFormatNS_10ColorSpaceEjDv2_ifPU33objcproto22_RBDisplayListContents11objc_objectjDv4_fU13block_pointerFvRNS_16SharedSubsurfaceEE_block_invoke((uint64_t)v77);
      else
        objc_msgSend(MEMORY[0x24BDE57D8], "addCommitHandler:forPhase:", v77, 3);
    }
  }
  else
  {
    ((void (**)(_QWORD, id *))v72)[2](v72, &v78);
  }
  RB::SharedSubsurface::~SharedSubsurface(&v78);
  return v43;
}

void sub_209AF5254(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, os_unfair_lock_t lock, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,id a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,id a31)
{
  os_unfair_lock_s *v31;

  RB::SharedSurface::AsyncUpdate::~AsyncUpdate(&a31);

  os_unfair_lock_unlock(v31);
  RB::SharedSubsurface::~SharedSubsurface(&a23);
  _Unwind_Resume(a1);
}

uint64_t RB::BinAllocator::alloc(int32x2_t *a1, _DWORD *a2, int32x2_t a3)
{
  uint32x2_t v3;
  uint64_t v5;
  unint64_t v6;
  __int32 v7;
  unsigned int v8;
  int v9;
  __int32 v10;
  int v11;
  __int128 v12;
  int32x2_t v13;
  unsigned int v14;
  __int16 *v15;
  int v16;
  int v17;
  __int16 v18;
  BOOL v19;
  unint64_t v20;
  unint64_t v21;
  int16x4_t v22;
  __int32 v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 *v29;
  int v30;
  uint64_t result;
  int v32;
  uint64_t v33;
  __int16 v34;
  uint64_t v35;
  uint64_t v36;
  __int32 v38;
  int v39;
  __int128 v40;

  v3 = (uint32x2_t)vcgt_s32(a3, a1[1]);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    return 0;
  v5 = a1[3].u32[0];
  if ((_DWORD)v5)
  {
    v6 = 0;
    v36 = (uint64_t)&a1[2];
    v7 = a3.i32[1];
    v8 = (a3.i32[1] + 15) & 0xFFFFFFF0;
    v9 = a3.i32[1] >> 1;
    v10 = a3.i32[0];
    v11 = a3.i16[0];
    v12 = 0uLL;
    v13 = a1[2];
    v14 = v5;
    v38 = a3.i32[0];
    v39 = a3.i32[1] >> 1;
    while (1)
    {
      v15 = (__int16 *)(*(_QWORD *)&v13 + 32 * v6);
      v16 = (unsigned __int16)v15[3];
      if (v16 == (unsigned __int16)v15[1])
      {
        v17 = v15[2] - v8;
        if (v17 >= v9)
        {
          v18 = *v15;
          *v15 += v8;
          v15[2] = v17;
          v40 = v12;
          if (a1[3].i32[1] < v14 + 1)
          {
            RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(v36, v14 + 1);
            v13 = a1[2];
            v14 = a1[3].u32[0];
          }
          v19 = v14 > v6;
          v20 = v14 - v6;
          if (v19)
            memmove((void *)(*(_QWORD *)&v13 + 32 * v6 + 32), (const void *)(*(_QWORD *)&v13 + 32 * v6), 32 * v20);
          v21 = *(_QWORD *)&v13 + 32 * v6;
          a3.i16[0] = v16;
          a3.i16[1] = v8;
          v22 = vdup_lane_s16((int16x4_t)a3, 0);
          v22.i16[1] = v8;
          *(_WORD *)v21 = v18;
          *(int16x4_t *)(v21 + 2) = v22;
          *(_QWORD *)(v21 + 24) = 0;
          *(_QWORD *)(v21 + 16) = 0;
          RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(v21 + 16, 1u);
          *(_DWORD *)(*(_QWORD *)(v21 + 16) + 4 * (*(_DWORD *)(v21 + 24))++) = v16 << 16;
          v14 = a1[3].i32[0] + 1;
          a1[3].i32[0] = v14;
          v13 = a1[2];
          v15 = (__int16 *)(*(_QWORD *)&v13 + 32 * v6);
          v12 = v40;
          v10 = v38;
          v9 = v39;
        }
      }
      v23 = v15[2];
      v24 = v23 - v7;
      if (v23 - v7 >= 0 && (v24 < 0x11 || (int)(v24 * v10) < 4096 || v15[3] == v15[1]) && v15[4] >= v11)
      {
        v25 = *((unsigned int *)v15 + 6);
        if ((_DWORD)v25)
        {
          v26 = 0;
          v27 = 0;
          v28 = *((_QWORD *)v15 + 2);
          while (1)
          {
            v29 = (__int16 *)(v28 + v26);
            v30 = *(__int16 *)(v28 + v26 + 2);
            if (v30 >= v11)
              break;
            if (v27 <= v30)
              v27 = *(_WORD *)(v28 + v26 + 2);
            v26 += 4;
            if (4 * v25 == v26)
              goto LABEL_25;
          }
          v32 = *v29;
          v29[1] = v30 - v11;
          if (v30 == v11)
          {
            v33 = (v25 - 1);
            *((_DWORD *)v15 + 6) = v33;
            if (v33 != v26 >> 2)
              memmove((void *)(v28 + 4 * (v26 >> 2)), (const void *)(v28 + 4 * (v26 >> 2) + 4), 4 * (v33 - (v26 >> 2)));
          }
          else
          {
            *(_WORD *)(v28 + v26) = v32 + v11;
          }
          v34 = v15[3] - v11;
          v15[3] = v34;
          v15[4] = v34;
          *a2 = v32;
          LODWORD(v35) = v32;
          HIDWORD(v35) = *v15;
          *(_QWORD *)a2 = v35;
          return 1;
        }
        v27 = 0;
LABEL_25:
        v15[4] = v27;
      }
      a3.i32[0] = v15[4];
      a3.i32[1] = v23;
      *(int32x2_t *)&v12 = vmax_s32(*(int32x2_t *)&v12, a3);
      if (++v6 == v5)
        goto LABEL_34;
    }
  }
  *(_QWORD *)&v12 = 0;
LABEL_34:
  result = 0;
  a1[1] = (int32x2_t)v12;
  return result;
}

void *RB::vector<RB::Animation::TermOrArg,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,4ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,4ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(4 * a3);
    v6 = v5 >> 2;
    if (*a2 != (v5 >> 2))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,64ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,64ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size((unint64_t)a3 << 6);
    v6 = v5 >> 6;
    if (*a2 != (v5 >> 6))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::vector<RB::BinAllocator::Shelf,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,32ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,32ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(32 * a3);
    v6 = v5 >> 5;
    if (*a2 != (v5 >> 5))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::SharedSurfaceGroup::wait_for_allocations(RB::SharedSurfaceGroup *this, RB::SharedSurfaceClient *a2)
{
  unsigned int v3;
  os_unfair_lock_s *v4;
  char *v5;
  int v6;
  int v7;
  uint64_t i;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  _QWORD *v12;
  __n128 v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int *v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  int v24;
  os_unfair_lock_s *lock;
  useconds_t v27;
  unsigned int v29;

  v3 = 0;
  v4 = (os_unfair_lock_s *)((char *)this + 16);
  v5 = (char *)this + 24;
  v6 = 1;
  v27 = 100;
  lock = (os_unfair_lock_s *)((char *)this + 16);
  while (1)
  {
    v7 = *((_DWORD *)a2 + 7);
    if ((v7 + *((_DWORD *)a2 + 6)) < 3)
    {
      v24 = 1;
      v23 = 1;
      return v24 & v23;
    }
    if (((v7 == 0) & ~v6) != 0)
      break;
    if ((v6 & 1) != 0)
    {
      v29 = v3;
    }
    else
    {
      usleep(v27);
      v29 = v27 + v3;
      v27 += v27 >> 1;
    }
    os_unfair_lock_lock(v4);
    for (i = *((_QWORD *)this + 4); (char *)i != v5; i = *(_QWORD *)(i + 8))
    {
      v9 = *(_QWORD *)(i + 16);
      if (*(_DWORD *)(v9 + 96))
      {
        v10 = 0;
        do
        {
          v11 = *(_QWORD *)(v9 + 88);
          v12 = (_QWORD *)(v11 + 56 * v10);
          if ((RB::SharedSurfaceClient *)*v12 == a2
            && RB::SharedSurfaceTimestamp::test((RB::SharedSurfaceTimestamp *)(v11 + 56 * v10 + 32)))
          {
            v14 = (unsigned int *)(*v12 + 28);
            do
              v15 = __ldxr(v14);
            while (__stxr(v15 - 1, v14));
            v16 = v11 + 56 * v10;
            v13.n128_u64[0] = *(_QWORD *)(v16 + 16);
            RB::BinAllocator::dealloc(v9 + 32, *(double *)(v16 + 8), v13);
            --*(_DWORD *)(v9 + 104);
            v17 = *(_QWORD *)(v9 + 88) + 56 * v10;

            v18 = *(unsigned int **)v17;
            if (*(_QWORD *)v17)
            {
              v19 = v18 + 2;
              do
              {
                v20 = __ldxr(v19);
                v21 = v20 - 1;
              }
              while (__stlxr(v21, v19));
              if (!v21)
              {
                __dmb(9u);
                (*(void (**)(unsigned int *))(*(_QWORD *)v18 + 8))(v18);
              }
            }
            v22 = (*(_DWORD *)(v9 + 96) - 1);
            *(_DWORD *)(v9 + 96) = v22;
            if (v10 != (_DWORD)v22)
              memmove((void *)v17, (const void *)(v17 + 56), 56 * (v22 - v10));
          }
          else
          {
            ++v10;
          }
        }
        while (v10 < *(_DWORD *)(v9 + 96));
      }
    }
    v4 = lock;
    os_unfair_lock_unlock(lock);
    v6 = 0;
    v24 = 0;
    v3 = v29;
    if (v29 >= 0x3D090)
      return v24 & v23;
  }
  v23 = 0;
  v24 = 1;
  return v24 & v23;
}

void sub_209AF5A44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void sub_209AF5BE8(_Unwind_Exception *exception_object)
{
  char v1;
  os_unfair_lock_s *v2;

  if ((v1 & 1) == 0)
    os_unfair_lock_unlock(v2);
  _Unwind_Resume(exception_object);
}

void RB::SharedSurfaceGroup::schedule_updates(RB::SharedSurfaceGroup *this)
{
  unint64_t v1;
  unsigned int *v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  void (*v16)(uint64_t);
  void *v17;
  unsigned int *v18;

  v1 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) - 224;
  if (*((_QWORD *)this + 6) != v1)
  {
    if (objc_msgSend(MEMORY[0x24BDE57D8], "currentPhase") + 1 >= 4)
    {
      RB::SharedSurfaceGroup::render_updates(this);
      return;
    }
    *((_QWORD *)this + 6) = v1;
    v3 = *(unsigned int **)this;
    if (v3)
    {
      v4 = v3 + 2;
      do
        v5 = __ldxr(v4);
      while (__stxr(v5 + 1, v4));
      v15 = 3321888768;
      v16 = ___ZN2RB18SharedSurfaceGroup16schedule_updatesEv_block_invoke;
      v17 = &__block_descriptor_40_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE_e5_v8__0l;
      do
        v6 = __ldxr(v4);
      while (__stxr(v6 + 1, v4));
    }
    else
    {
      v15 = 3321888768;
      v16 = ___ZN2RB18SharedSurfaceGroup16schedule_updatesEv_block_invoke;
      v17 = &__block_descriptor_40_e8_32c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE_e5_v8__0l;
    }
    v14 = MEMORY[0x24BDAC760];
    v18 = v3;
    objc_msgSend(MEMORY[0x24BDE57D8], "addCommitHandler:forPhase:", &v14, 3);
    v7 = v18;
    if (!v18)
      goto LABEL_14;
    v8 = v18 + 2;
    do
    {
      v9 = __ldxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
      if (!v3)
        return;
    }
    else
    {
LABEL_14:
      if (!v3)
        return;
    }
    v11 = v3 + 2;
    do
    {
      v12 = __ldxr(v11);
      v13 = v12 - 1;
    }
    while (__stlxr(v13, v11));
    if (!v13)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v3 + 8))(v3);
    }
  }
}

void sub_209AF5D78(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;

  if (a14)
    RB::SharedSurfaceGroup::schedule_updates(a14);
  RB::SharedSurfaceGroup::schedule_updates(v14 == 0, v14);
  _Unwind_Resume(a1);
}

void RB::SharedSubsurface::~SharedSubsurface(id *this)
{
  RB::SharedSubsurface::reset((RB::SharedSubsurface *)this);

}

void sub_209AF5FD4(_Unwind_Exception *a1)
{
  uint64_t v1;

  _Unwind_Resume(a1);
}

void RB::SharedSubsurface::reset(RB::SharedSubsurface *this)
{
  os_unfair_lock_s *v2;

  if (*(_QWORD *)this)
  {
    v2 = *(os_unfair_lock_s **)(*(_QWORD *)this + 16);
    if (v2)
      RB::SharedSurfaceGroup::remove_subsurface(v2, this, 1);
  }
}

uint64_t RB::SharedSubsurface::contents(RB::SharedSubsurface *this)
{
  if (*(_QWORD *)this)
    return *(_QWORD *)(*(_QWORD *)(*(_QWORD *)this + 24) + 48);
  else
    return 0;
}

id RB::SharedSurfaceTimestamp::attach(uint64_t a1, id a2)
{
  id result;

  result = *(id *)a1;
  if (result != a2)
  {

    result = a2;
    *(_DWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = result;
    *(_QWORD *)(a1 + 8) = 0;
  }
  return result;
}

uint64_t RB::SurfacePool::shared(RB::SurfacePool *this)
{
  if (RB::SurfacePool::_shared_once != -1)
    dispatch_once_f(&RB::SurfacePool::_shared_once, 0, (dispatch_function_t)RB::SurfacePool::shared(void)::$_0::__invoke<void *>);
  return RB::SurfacePool::_shared_pool;
}

uint64_t RB::SurfacePool::alloc(os_unfair_lock_s *this, uint64_t a2, uint64_t a3, int a4, int a5, _CAImageQueue *a6, double a7, int8x8_t a8)
{
  const float *v16;
  int32x2_t v17;
  uint32x2_t v18;
  uint64_t v19;
  os_unfair_lock_s *v21;
  uint64_t v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint32x2_t v28;
  uint64_t v29;
  uint64_t v30;
  _CAImageQueue **v31;
  uint64_t v32;
  uint64_t v33;
  unsigned int *v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  double v38;
  uint64_t v39;
  unsigned int *v40;
  unsigned int v41;
  unsigned int *v42;
  unsigned int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  os_unfair_lock_t lock;
  char v49;

  if ((a3 & 0x80000000) != 0)
  {
    if (!RB::Device::valid_texture_size_nonnative(a2, a3, *(int32x2_t *)&a7))
      return 0;
  }
  else
  {
    v16 = (const float *)(a2 + 288);
    v17 = (int32x2_t)vld1_dup_f32(v16);
    v18 = (uint32x2_t)vand_s8((int8x8_t)vcge_s32(v17, *(int32x2_t *)&a7), (int8x8_t)vcgtz_s32(*(int32x2_t *)&a7));
    if ((vpmin_u32(v18, v18).u32[0] & 0x80000000) == 0)
      return 0;
  }
  if (a6 && !RB::SurfacePool::wait_image_queue(this, a6))
    return 0;
  lock = this;
  v49 = 1;
  os_unfair_lock_lock(this);
  v21 = this + 4;
  v22 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (!v22)
    goto LABEL_40;
  v23 = 0;
  v47 = 0;
  v24 = 0;
  v25 = 0;
  do
  {
    --v22;
    v26 = *(_QWORD *)&v21->_os_unfair_lock_opaque;
    v27 = *(_QWORD *)(*(_QWORD *)&v21->_os_unfair_lock_opaque + 8 * v22);
    if (!*(_QWORD *)(v27 + 120))
    {
      v28 = (uint32x2_t)vceq_s32(*(int32x2_t *)(v27 + 24), *(int32x2_t *)&a7);
      if ((vpmin_u32(v28, v28).u32[0] & 0x80000000) != 0
        && *(_QWORD *)(v27 + 32) == a3
        && *(unsigned __int8 *)(v27 + 44) == a4
        && *(_DWORD *)(v27 + 40) == a5
        && *(_QWORD *)(v27 + 16) == a2)
      {
        if (*(_BYTE *)(v27 + 140))
        {
          v44 = v23;
          v45 = v24;
          v46 = v25;
          if (IOSurfaceIsInUse(*(IOSurfaceRef *)(v27 + 48)))
          {
            v25 = v46;
            v23 = v44;
            v24 = v45;
            if (*(_BYTE *)(v27 + 140))
              continue;
          }
          else
          {
            *(_BYTE *)(v27 + 140) = 0;
            v25 = v46;
            v23 = v44;
            v24 = v45;
          }
        }
        v29 = *(_QWORD *)(v26 + 8 * v22);
        if (*(_BYTE *)(v29 + 45))
        {
          if (!v24)
            v25 = v22;
          v24 = 1;
        }
        else
        {
          if (a6)
          {
            v30 = *(_QWORD *)(v29 + 104);
            v31 = *(_QWORD *)(v29 + 96) ? *(_CAImageQueue ***)(v29 + 96) : (_CAImageQueue **)(v29 + 64);
            if (v30)
            {
              v32 = 16 * v30;
              while (*v31 != a6)
              {
                v31 += 2;
                v32 -= 16;
                if (!v32)
                  goto LABEL_33;
              }
              goto LABEL_44;
            }
          }
LABEL_33:
          v33 = v47;
          if (!v23)
            v33 = v22;
          v47 = v33;
          v23 = 1;
        }
      }
    }
  }
  while (v22);
  v22 = v47;
  if (v23)
    goto LABEL_44;
  if (v24)
  {
    v22 = v25;
    RB::Surface::set_volatile(*(_QWORD *)(*(_QWORD *)&v21->_os_unfair_lock_opaque + 8 * v25), 0);
    goto LABEL_44;
  }
LABEL_40:
  std::unique_lock<RB::spin_lock>::unlock((uint64_t)&lock);
  v34 = (unsigned int *)operator new();
  RB::Surface::Surface((uint64_t)v34, a2, (RB *)a3, a4, a5, a7);
  std::unique_lock<RB::spin_lock>::lock((uint64_t)&lock);
  if (*((_QWORD *)v34 + 6))
  {
    v22 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
    v35 = v22 + 1;
    if (*(_QWORD *)&this[8]._os_unfair_lock_opaque < (unint64_t)(v22 + 1))
    {
      RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)&this[4], v35);
      v36 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
      v35 = v36 + 1;
    }
    else
    {
      v36 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
    }
    *(_QWORD *)(*(_QWORD *)&this[4]._os_unfair_lock_opaque + 8 * v36) = v34;
    *(_QWORD *)&this[6]._os_unfair_lock_opaque = v35;
LABEL_44:
    v37 = *(_QWORD *)&v21->_os_unfair_lock_opaque;
    RB::Surface::set_padding(*(_QWORD *)(*(_QWORD *)&v21->_os_unfair_lock_opaque + 8 * v22), a8);
    v38 = CACurrentMediaTime();
    if (a6)
      v39 = (uint64_t)a6;
    else
      v39 = 1;
    *(_QWORD *)(*(_QWORD *)(v37 + 8 * v22) + 120) = v39;
    v19 = *(_QWORD *)(v37 + 8 * v22);
    *(double *)(v19 + 128) = v38;
    v40 = (unsigned int *)(v19 + 8);
    do
      v41 = __ldxr(v40);
    while (__stxr(v41 + 1, v40));
  }
  else
  {
    v42 = v34 + 2;
    do
      v43 = __ldxr(v42);
    while (__stlxr(v43 - 1, v42));
    if (v43 == 1)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v34 + 8))(v34);
    }
    v19 = 0;
  }
  if (v49)
    os_unfair_lock_unlock(lock);
  return v19;
}

void sub_209AF63C4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, os_unfair_lock_t lock, char a14)
{
  if (a14)
    os_unfair_lock_unlock(lock);
  _Unwind_Resume(exception_object);
}

void std::unique_lock<RB::spin_lock>::lock(uint64_t a1)
{
  os_unfair_lock_s *v2;
  int v3;
  int v4;
  RB *v5;

  v2 = *(os_unfair_lock_s **)a1;
  if (v2)
  {
    if (!*(_BYTE *)(a1 + 8))
    {
      os_unfair_lock_lock(v2);
      *(_BYTE *)(a1 + 8) = 1;
      return;
    }
  }
  else
  {
    std::__throw_system_error(1, "unique_lock::lock: references null mutex");
  }
  std::__throw_system_error(11, "unique_lock::lock: already locked");
  RB::Surface::Surface(v3, v4, v5);
}

uint64_t RB::Surface::Surface(uint64_t a1, uint64_t a2, RB *this, int a4, int a5, double a6)
{
  CFTypeRef *v8;
  char v9;
  char v10;
  __IOSurface *iosurface;

  *(_DWORD *)(a1 + 8) = 1;
  *(_QWORD *)a1 = off_24C2298A0;
  *(_QWORD *)(a1 + 16) = a2;
  *(double *)(a1 + 24) = a6;
  *(_QWORD *)(a1 + 32) = this;
  *(_DWORD *)(a1 + 40) = a5;
  *(_BYTE *)(a1 + 44) = a4;
  *(_QWORD *)(a1 + 48) = 0;
  v8 = (CFTypeRef *)(a1 + 48);
  *(_QWORD *)(a1 + 56) = 0;
  *(_BYTE *)(a1 + 45) = 0;
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 2;
  v9 = a5 & 0x87;
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 133) = 0;
  switch(a4)
  {
    case 0:
      v9 |= 8u;
      break;
    case 1:
      v10 = 72;
      goto LABEL_7;
    case 2:
      v9 |= 0x10u;
      break;
    case 3:
      v10 = 80;
LABEL_7:
      v9 |= v10;
      break;
    case 4:
      abort();
    case 5:
      v9 |= 0x20u;
      break;
    default:
      break;
  }
  iosurface = RB::create_iosurface(this, (MTLPixelFormat)LODWORD(a6), HIDWORD(a6), v9);
  if (*v8)
    CFRelease(*v8);
  *(_QWORD *)(a1 + 48) = iosurface;
  return a1;
}

void sub_209AF6598(_Unwind_Exception *a1)
{
  CFTypeRef *v1;
  id *v2;
  void **v3;

  if (*v3)
    free(*v3);
  RB::Surface::Surface(v2, v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::set_padding(uint64_t result, int8x8_t a2)
{
  int32x2_t v2;
  int16x4_t v3;
  uint64_t v4;

  v2.i32[0] = *(unsigned __int16 *)(result + 136);
  v2.i32[1] = *(unsigned __int16 *)(result + 138);
  v3 = (int16x4_t)vmvn_s8((int8x8_t)vceq_s32(v2, (int32x2_t)vand_s8(a2, (int8x8_t)0xFFFF0000FFFFLL)));
  if ((vmaxv_u16((uint16x4_t)vuzp1_s16(v3, v3)) & 0x8000) != 0)
  {
    v4 = result;
    RB::Surface::destroy_queue_ids(result);
    result = IOSurfaceSetBulkAttachments2();
    *(_WORD *)(v4 + 138) = a2.i16[2];
    *(_WORD *)(v4 + 136) = a2.i16[0];
  }
  return result;
}

__IOSurface *RB::create_iosurface(RB *this, MTLPixelFormat a2, uint64_t a3, char a4)
{
  MTLPixelFormat v6;
  unsigned int *v8;
  unsigned int *v9;
  char v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v15;
  unint64_t *v16;
  void *v17;
  uint64_t v18;
  unint64_t *v19;
  uint64_t plane_dict;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t Default;
  __IOSurface *v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unsigned __int8 v49;
  uint64_t *v50;
  unsigned __int8 v52;
  unsigned __int8 v53;
  unsigned __int8 v54;
  unsigned __int8 v55;
  unsigned __int8 v56;
  unsigned __int8 v57;
  RB *v58;
  CGColorSpace *v59;
  __guard *v60;
  RB *v61;
  char *v62;
  RB *v63;
  char *v64;
  RB *v65;
  CGColorSpace *v66;
  RB *v67;
  CGColorSpace *v68;
  RB *v69;
  char *v70;
  RB *v71;
  char *v72;
  _QWORD v73[2];
  _QWORD v74[2];
  _QWORD v75[2];
  _QWORD v76[2];
  unsigned int v77[2];
  _QWORD v78[2];

  v6 = a2;
  v78[1] = *MEMORY[0x24BDAC8D0];
  v8 = RB::pixel_format_traits((unint64_t)this, a2);
  v9 = v8;
  if (((*v8 | ((unint64_t)*((unsigned __int16 *)v8 + 2) << 32)) & 0x30000000000) == 0x10000000000)
    v10 = a4 | 2;
  else
    v10 = a4;
  if (this == (RB *)10)
    v11 = 1093677112;
  else
    v11 = 0;
  if ((v10 & 4) != 0)
    v12 = v11;
  else
    v12 = v8[3];
  if ((v10 & 3) == 0 && (_DWORD)v12 != 0 && (_DWORD)v12 != 1599226420)
  {
    Default = CAIOSurfaceCreateDefault();
    v41 = (__IOSurface *)Default;
    if (Default)
      goto LABEL_60;
  }
  v17 = (void *)objc_msgSend(MEMORY[0x24BDBCED8], "dictionary");
  if ((uint64_t)this > 539)
  {
    switch((unint64_t)this)
    {
      case 0x21CuLL:
        goto LABEL_38;
      case 0x21DuLL:
        goto LABEL_42;
      case 0x21EuLL:
        goto LABEL_34;
      case 0x21FuLL:
      case 0x220uLL:
      case 0x221uLL:
      case 0x222uLL:
      case 0x223uLL:
      case 0x224uLL:
      case 0x225uLL:
        goto LABEL_51;
      case 0x226uLL:
      case 0x227uLL:
        if (!plane_dict)
          return 0;
        if (!v21)
          return 0;
        v22 = *(_QWORD *)v77 + v78[0];
        if (__CFADD__(*(_QWORD *)v77, v78[0]))
          return 0;
        v73[0] = plane_dict;
        v73[1] = v21;
        v23 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v73, 2);
        objc_msgSend(v17, "setObject:forKeyedSubscript:", v23, *MEMORY[0x24BDD8F88]);
        goto LABEL_46;
      default:
        if ((unint64_t)this - 0x80000001 < 2)
        {
          v22 = 0;
          v6 = (unint64_t)(3 * v6);
          v24 = 1;
          goto LABEL_53;
        }
        if (this != (RB *)2147483651)
          goto LABEL_51;
        v22 = 0;
        v6 = (unint64_t)(3 * v6);
        v24 = 2;
        break;
    }
    goto LABEL_53;
  }
  if ((uint64_t)this > 519)
  {
    if (this != (RB *)520)
    {
      if (this != (RB *)522)
      {
        if (this != (RB *)523)
          goto LABEL_51;
LABEL_34:
        if (!v27)
          return 0;
        if (!v28)
          return 0;
        v22 = *(_QWORD *)v77 + v78[0];
        if (__CFADD__(*(_QWORD *)v77, v78[0]))
          return 0;
        v74[0] = v27;
        v74[1] = v28;
        v29 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v74, 2);
        objc_msgSend(v17, "setObject:forKeyedSubscript:", v29, *MEMORY[0x24BDD8F88]);
        goto LABEL_46;
      }
      goto LABEL_42;
    }
  }
  else if (this != (RB *)500)
  {
    if (this != (RB *)502)
    {
      if (this != (RB *)503)
      {
LABEL_51:
        v24 = *((unsigned __int8 *)v9 + 6);
        if (*((_BYTE *)v9 + 6))
        {
          v22 = 0;
          goto LABEL_53;
        }
        return 0;
      }
      goto LABEL_34;
    }
LABEL_42:
    if (!v37)
      return 0;
    if (!v38)
      return 0;
    v22 = *(_QWORD *)v77 + v78[0];
    if (__CFADD__(*(_QWORD *)v77, v78[0]))
      return 0;
    v75[0] = v37;
    v75[1] = v38;
    v39 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v75, 2);
    objc_msgSend(v17, "setObject:forKeyedSubscript:", v39, *MEMORY[0x24BDD8F88]);
    goto LABEL_46;
  }
LABEL_38:
  if (!v32)
    return 0;
  if (!v33)
    return 0;
  v22 = *(_QWORD *)v77 + v78[0];
  if (__CFADD__(*(_QWORD *)v77, v78[0]))
    return 0;
  v76[0] = v32;
  v76[1] = v33;
  v34 = objc_msgSend(MEMORY[0x24BDBCE30], "arrayWithObjects:count:", v76, 2);
  objc_msgSend(v17, "setObject:forKeyedSubscript:", v34, *MEMORY[0x24BDD8F88]);
LABEL_46:
  v24 = 0;
LABEL_53:
  v42 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v6);
  objc_msgSend(v17, "setObject:forKeyedSubscript:", v42, *MEMORY[0x24BDD8FD0]);
  v43 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a3);
  objc_msgSend(v17, "setObject:forKeyedSubscript:", v43, *MEMORY[0x24BDD8EB0]);
  if ((_DWORD)v12)
  {
    v44 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v12);
    objc_msgSend(v17, "setObject:forKeyedSubscript:", v44, *MEMORY[0x24BDD8EF8]);
  }
  if ((_DWORD)v24)
  {
    v45 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", v24);
    objc_msgSend(v17, "setObject:forKeyedSubscript:", v45, *MEMORY[0x24BDD8E30]);
  }
  if (v22)
  {
    v46 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v22);
    objc_msgSend(v17, "setObject:forKeyedSubscript:", v46, *MEMORY[0x24BDD8E18]);
  }
  v47 = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", v10 & 1);
  objc_msgSend(v17, "setObject:forKeyedSubscript:", v47, *MEMORY[0x24BDD8F00]);
  v41 = IOSurfaceCreate((CFDictionaryRef)v17);
LABEL_60:
  if ((v10 & 0x78) != 0 && v41 != 0)
  {
    if ((v10 & 8) != 0)
    {
      if (((*v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32)) & 0x200000000) != 0)
      {
        if ((v10 & 0x40) != 0)
        {
          if ((v56 & 1) != 0)
          {
            goto LABEL_87;
          }
          if ((_DWORD)v67)
          {
            v68 = (CGColorSpace *)RB::extended_srgb_colorspace(v67);
            goto LABEL_103;
          }
        }
        else
        {
          if ((v54 & 1) != 0)
          {
            goto LABEL_87;
          }
          if ((_DWORD)v65)
          {
            v66 = (CGColorSpace *)RB::extended_linear_srgb_colorspace(v65);
            goto LABEL_103;
          }
        }
      }
      else
      {
        if ((v52 & 1) != 0)
        {
          goto LABEL_87;
        }
        if ((_DWORD)v58)
        {
          v59 = (CGColorSpace *)RB::srgb_colorspace(v58);
LABEL_103:
          __cxa_guard_release(v60);
        }
      }
    }
    else if ((v10 & 0x10) != 0)
    {
      if (((*v9 | ((unint64_t)*((unsigned __int16 *)v9 + 2) << 32)) & 0x200000000) != 0)
      {
        if ((v10 & 0x40) != 0)
        {
          if ((v57 & 1) != 0)
          {
            goto LABEL_87;
          }
          if ((_DWORD)v71)
          {
            v72 = RB::extended_display_p3_colorspace(v71);
            goto LABEL_103;
          }
        }
        else
        {
          if ((v55 & 1) != 0)
          {
            goto LABEL_87;
          }
          if ((_DWORD)v69)
          {
            v70 = RB::extended_linear_display_p3_colorspace(v69);
            goto LABEL_103;
          }
        }
      }
      else
      {
        if ((v53 & 1) != 0)
        {
          goto LABEL_87;
        }
        if ((_DWORD)v63)
        {
          v64 = RB::display_p3_colorspace(v63);
          goto LABEL_103;
        }
      }
    }
    else
    {
      if ((v10 & 0x20) == 0)
        return v41;
      if ((v49 & 1) != 0)
      {
        goto LABEL_87;
      }
      if ((_DWORD)v61)
      {
        v62 = RB::pq_colorspace(v61);
        goto LABEL_103;
      }
    }
LABEL_87:
    if (*v50)
      IOSurfaceSetValue(v41, (CFStringRef)*MEMORY[0x24BDD8E88], (CFTypeRef)*v50);
  }
  return v41;
}

void sub_209AF6DCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

RB::SharedSurface *RB::SharedSurface::SharedSurface(RB::SharedSurface *this, RB::SharedSurfaceGroup *a2, RB::Surface *a3, float a4)
{
  RB *v6;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = off_24C228D08;
  *((_QWORD *)this + 2) = a2;
  *((_QWORD *)this + 3) = a3;
  v6 = (RB *)RB::BinAllocator::BinAllocator((char *)this + 32, *((double *)a3 + 3));
  *(_OWORD *)((char *)this + 120) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((float *)this + 16) = a4;
  *(_OWORD *)((char *)this + 88) = 0u;
  *(_OWORD *)((char *)this + 100) = 0u;
  *(_OWORD *)((char *)this + 136) = 0u;
  *(_OWORD *)((char *)this + 152) = 0u;
  *(_QWORD *)((char *)this + 165) = 0;
  *((_DWORD *)this + 42) = (uint64_t)(RB::current_time_seconds(v6) * 60.0 + 0.5);
  return this;
}

void sub_209AF6EF4(_Unwind_Exception *a1)
{
  RB::BinAllocator *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  RB::vector<RB::SharedSurface::AsyncUpdate,0ul,unsigned int>::~vector((char **)(v2 + 152));
  RB::vector<RB::SharedSurface::Copy,0ul,unsigned int>::~vector(v2 + 136);
  RB::vector<RB::SharedSurface::Update,0ul,unsigned int>::~vector(v4);
  RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::~vector((char **)(v2 + 88));
  RB::vector<RB::SharedSurface::Allocation,0ul,unsigned int>::~vector(v3);
  RB::BinAllocator::~BinAllocator(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::srgb_colorspace(RB *this)
{
  unsigned __int8 v1;
  _QWORD *v2;
  int v4;

  if ((v1 & 1) == 0)
  {
    if (v4)
    {
      RB::srgb_colorspace(void)::r = (uint64_t)CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x24BDBF318]);
    }
  }
  return v2[21];
}

void sub_209AF70B4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10B1C40F2BC6277);
  _Unwind_Resume(a1);
}

uint64_t RB::Surface::destroy_queue_ids(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  v1 = this;
  v2 = *(_QWORD *)(this + 104);
  if (*(_QWORD *)(this + 96))
    v3 = *(_QWORD *)(this + 96);
  else
    v3 = this + 64;
  if (v2)
  {
    v4 = v3 + 16 * v2;
    do
    {
      v3 += 16;
      this = CAImageQueueUnregisterBuffer();
    }
    while (v3 != v4);
  }
  *(_QWORD *)(v1 + 104) = 0;
  return this;
}

uint64_t RB::SurfacePool::wait_image_queue(os_unfair_lock_s *this, _CAImageQueue *a2)
{
  uint64_t result;
  RB *LastUpdateHostTime;
  double v6;
  double v7;
  RB *v8;
  NSObject *v9;
  _BOOL4 v10;
  const char *v11;
  useconds_t v12;
  RB *v13;
  _BOOL4 v14;
  int v15;
  _CAImageQueue *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  os_unfair_lock_lock(this);
  RB::SurfacePool::remove_watched_queue_locked((RB::SurfacePool *)this, a2, 0);
  os_unfair_lock_unlock(this);
  if (CAImageQueueCollect())
    return 1;
  LastUpdateHostTime = (RB *)CAImageQueueGetLastUpdateHostTime();
  v6 = RB::time_seconds(LastUpdateHostTime);
  v7 = CACurrentMediaTime();
  if (v7 - v6 > 0.2)
  {
    v8 = (RB *)CAImageQueueConsumeUnconsumedInRange();
    if (!v8 || (v8 = (RB *)CAImageQueueCollect()) == 0)
    {
      v9 = RB::error_log(v8);
      v10 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
      result = 0;
      if (v10)
      {
        v15 = 134217984;
        v16 = a2;
        v11 = "RBLayer: stale image queue, %p";
LABEL_19:
        _os_log_impl(&dword_209ACA000, v9, OS_LOG_TYPE_DEFAULT, v11, (uint8_t *)&v15, 0xCu);
        return 0;
      }
      return result;
    }
    return 1;
  }
  if (CAImageQueueCollect())
    return 1;
  v12 = 100;
  while (1)
  {
    CAImageQueueSetFlags();
    CAImageQueueSetFlags();
    if (CACurrentMediaTime() - v7 >= 0.1)
      break;
    usleep(v12);
    if (2 * v12 >= 0x7D0)
      v12 = 2000;
    else
      v12 *= 2;
    if (CAImageQueueCollect())
      return 1;
  }
  v9 = RB::error_log(v13);
  v14 = os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT);
  result = 0;
  if (v14)
  {
    v15 = 134217984;
    v16 = a2;
    v11 = "RBLayer: full image queue, %p";
    goto LABEL_19;
  }
  return result;
}

void sub_209AF731C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void RB::SurfacePool::remove_watched_queue_locked(RB::SurfacePool *this, _CAImageQueue *a2, int a3)
{
  unint64_t v3;
  unint64_t v7;
  NSObject *v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  id v13;

  v3 = *((_QWORD *)this + 13);
  if (v3)
  {
    v7 = 0;
    v8 = MEMORY[0x24BDAC9B8];
    do
    {
      v9 = *((_QWORD *)this + 12);
      if (*(_CAImageQueue **)(v9 + 16 * v7) == a2)
      {
        v10 = v9 + 16 * v7;
        v11 = *(void **)(v10 + 8);
        v12 = v9 + 16 * v3;
        *(_OWORD *)v10 = *(_OWORD *)(v12 - 16);
        *(_QWORD *)(v12 - 16) = a2;
        *(_QWORD *)(v12 - 8) = v11;
        --*((_QWORD *)this + 13);
        if (a3)
        {
          v13 = v11;
          if (objc_msgSend(v13, "retainCount") == 1)

          else
            dispatch_async_f(v8, v13, (dispatch_function_t)RB::SurfacePool::remove_watched_queue_locked(_CAImageQueue *,BOOL)::$_0::__invoke);
        }
      }
      else
      {
        ++v7;
      }
      v3 = *((_QWORD *)this + 13);
    }
    while (v7 < v3);
  }
}

RB::RenderFrame *RB::RenderFrame::RenderFrame(RB::RenderFrame *this, RB::Device *a2, RB::Drawable *a3, int a4)
{
  id *v7;
  double v8;
  int v9;
  size_t v10;
  _QWORD *v11;
  const char *v12;
  char *v13;
  size_t v14;
  _QWORD *v15;
  const char *v16;
  char *v17;
  size_t v18;
  _QWORD *v19;
  const char *v20;
  void *v21;
  id v22;
  id v23;
  _QWORD *v24;
  unint64_t v25;
  _QWORD *v26;
  unint64_t v27;

  *(_QWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  *((_QWORD *)this + 2) = 0;
  v7 = (id *)((char *)this + 16);
  *((_QWORD *)this + 3) = 0;
  v8 = RB::current_time_seconds(this);
  *((double *)this + 9) = v8;
  v9 = *((_DWORD *)a2 + 47) + 1;
  *((_DWORD *)a2 + 47) = v9;
  *((_DWORD *)this + 20) = a4;
  *((_DWORD *)this + 21) = v9;
  *((_QWORD *)this + 11) = (uint64_t)(v8 * 60.0 + 0.5);
  v10 = malloc_good_size(0x58uLL);
  v11 = malloc_type_malloc(v10, 0x10E729FFuLL);
  if (!v11)
    RB::precondition_failure((RB *)"memory allocation failed", v12);
  v13 = (char *)this + 96;
  *v11 = 0;
  v11[1] = 0;
  v11[2] = (v10 - 24) >> 3;
  *((_QWORD *)this + 12) = v11;
  v14 = malloc_good_size(0x58uLL);
  v15 = malloc_type_malloc(v14, 0x10E729FFuLL);
  if (!v15)
    RB::precondition_failure((RB *)"memory allocation failed", v16);
  v17 = (char *)this + 104;
  *v15 = 0;
  v15[1] = 0;
  v15[2] = (v14 - 24) >> 3;
  *((_QWORD *)this + 13) = v15;
  v18 = malloc_good_size(0x58uLL);
  v19 = malloc_type_malloc(v18, 0x10E729FFuLL);
  if (!v19)
    RB::precondition_failure((RB *)"memory allocation failed", v20);
  *v19 = 0;
  v19[1] = 0;
  v19[2] = (v18 - 24) >> 3;
  *((_QWORD *)this + 15) = 0;
  *((_QWORD *)this + 14) = v19;
  *((_BYTE *)this + 144) = 0;
  *((_QWORD *)this + 16) = 0;
  RB::UntypedTable::UntypedTable((RB::RenderFrame *)((char *)this + 152), (unint64_t (*)(RB *, const void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_0::__invoke<RB::RenderFrame::RegionKey const*>, (BOOL (*)(RB *, RB *, const void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_1::__invoke<RB::RenderFrame::RegionKey const*,RB::RenderFrame::RegionKey const*>, 0, (void (*)(void *))RB::RenderFrame::RenderFrame(RB::Device *,RB::Drawable *,unsigned int)::$_2::__invoke<RB::RenderFrame::RegionEntry const*>, 0);
  *((_DWORD *)this + 58) = 0;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 35) = 0x400000000;
  *((_QWORD *)this + 36) = 0;
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_QWORD *)this + 8) = 0;
  objc_msgSend((id)RB::Device::capture_scope(a2), "beginScope");
  if (*((_BYTE *)a2 + 292))
  {
    v21 = (void *)objc_opt_new();
    objc_msgSend(v21, "setErrorOptions:", 1);
    v22 = (id)objc_msgSend(RB::Device::command_queue((id *)a2), "commandBufferWithDescriptor:", v21);
    if (*v7 != v22)
    {

      *v7 = v22;
    }

    v23 = *v7;
  }
  else
  {
    v23 = (id)objc_msgSend(RB::Device::command_queue((id *)a2), "commandBuffer");
    if (*v7 != v23)
    {

      v23 = v23;
      *v7 = v23;
    }
  }
  objc_msgSend(v23, "enqueue");
  v24 = *(_QWORD **)v13;
  v25 = *(_QWORD *)(*(_QWORD *)v13 + 8);
  if (v25 >= *(_QWORD *)(*(_QWORD *)v13 + 16))
    v24 = (_QWORD *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 12, v24);
  v24[v25 + 3] = 0;
  atomic_store(v25 + 1, v24 + 1);
  v26 = *(_QWORD **)v17;
  v27 = *(_QWORD *)(*(_QWORD *)v17 + 8);
  if (v27 >= *(_QWORD *)(*(_QWORD *)v17 + 16))
    v26 = (_QWORD *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 13, v26);
  v26[v27 + 3] = 0;
  atomic_store(v27 + 1, v26 + 1);
  return this;
}

void sub_209AF77D8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  RB::UntypedTable *v4;
  _QWORD **v5;
  _QWORD *v7;
  _QWORD *v8;

  RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(v1 + 240);
  RB::UntypedTable::~UntypedTable(v4);
  v7 = *v5;
  if (*v5)
  {
    do
    {
      v8 = (_QWORD *)*v7;
      operator delete(v7);
      v7 = v8;
    }
    while (v8);
  }
  *v5 = 0;
  RB::shared_vector<RB::Function const*>::~shared_vector((_QWORD **)(v1 + 112));
  RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(v3);
  RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(v2);

  _Unwind_Resume(a1);
}

id RB::Device::command_queue(id *this)
{
  void *v2;
  const char *v3;
  __int16 *v4;
  id v5;
  __int16 *v6;
  id v7;

  if (!this[8])
  {
    v2 = (void *)objc_msgSend(this[3], "newCommandQueue");

    this[8] = v2;
    if (!v2)
      RB::precondition_failure((RB *)"unable to create command queue", v3);
    this[124] = (id)objc_msgSend(v2, "getGPUPriority");
    this[123] = (id)objc_msgSend(v2, "getBackgroundGPUPriority");
  }
  if (*((_BYTE *)this + 296))
  {
    v4 = (__int16 *)((char *)this + 295);
  }
  else
  {
    v4 = &RB::Device::default_gpu_priority;
    if (!HIBYTE(RB::Device::default_gpu_priority))
      goto LABEL_9;
  }
  v5 = (id)*(unsigned __int8 *)v4;
  if (this[124] != v5)
  {
    this[124] = v5;
    objc_msgSend(this[8], "setGPUPriority:");
  }
LABEL_9:
  if (*((_BYTE *)this + 294))
  {
    v6 = (__int16 *)((char *)this + 293);
  }
  else
  {
    v6 = &RB::Device::default_bg_gpu_priority;
    if (!HIBYTE(RB::Device::default_bg_gpu_priority))
      return this[8];
  }
  v7 = (id)*(unsigned __int8 *)v6;
  if (this[123] != v7)
  {
    this[123] = v7;
    objc_msgSend(this[8], "setBackgroundGPUPriority:");
  }
  return this[8];
}

void RB::RenderFrame::~RenderFrame(RB::RenderFrame *this)
{
  id *v2;
  unsigned int *v3;
  unsigned int v4;
  os_unfair_lock_s *v5;
  unsigned int *p_os_unfair_lock_opaque;
  unsigned int v7;
  id v8;
  void *v9;
  int v10;
  void *v11;
  unsigned int *v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  void *v16;
  uint64_t v17;
  double v18;
  id *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  os_unfair_lock_s *v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  void *v33;
  char *v34;
  unint64_t v35;
  unint64_t i;
  uint64_t v37;
  _QWORD *v38;
  _QWORD *v39;
  _QWORD *v40;
  _QWORD *v41;
  uint64_t v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t v45;
  _DWORD *v46;
  int v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  _DWORD **v51;
  _DWORD *v52;
  int v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  void (*v57)(uint64_t, void *);
  void *v58;
  os_unfair_lock_s *v59;
  id *v60;
  id v61;
  int v62;

  RB::RenderFrame::will_render(this);
  RB::RenderFrame::end_encoding((id *)this);
  v2 = *(id **)this;
  if (*(_QWORD *)this)
  {
    v3 = (unsigned int *)(v2 + 1);
    do
      v4 = __ldxr(v3);
    while (__stxr(v4 + 1, v3));
  }
  v5 = (os_unfair_lock_s *)*((_QWORD *)this + 1);
  if (v5)
  {
    p_os_unfair_lock_opaque = &v5[2]._os_unfair_lock_opaque;
    do
      v7 = __ldxr(p_os_unfair_lock_opaque);
    while (__stxr(v7 + 1, p_os_unfair_lock_opaque));
  }
  v8 = *((id *)this + 3);
  v9 = v8;
  v10 = *((_DWORD *)this + 21);
  v11 = (void *)*((_QWORD *)this + 2);
  v55 = MEMORY[0x24BDAC760];
  v56 = 3321888768;
  v57 = ___ZN2RB11RenderFrameD2Ev_block_invoke;
  v58 = &__block_descriptor_60_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE_e28_v16__0___MTLCommandBuffer__8l;
  if (v5)
  {
    v12 = &v5[2]._os_unfair_lock_opaque;
    do
      v13 = __ldxr(v12);
    while (__stxr(v13 + 1, v12));
  }
  v59 = v5;
  if (v2)
  {
    v14 = (unsigned int *)(v2 + 1);
    do
      v15 = __ldxr(v14);
    while (__stxr(v15 + 1, v14));
  }
  v60 = v2;
  v62 = v10;
  v61 = v8;
  objc_msgSend(v11, "addCompletedHandler:", &v55);
  v16 = (void *)*((_QWORD *)this + 2);
  if ((*((_BYTE *)this + 80) & 1) != 0)
  {
    v17 = objc_msgSend(v16, "commitAndWaitUntilSubmitted", v55, v56, v57, v58);
  }
  else
  {
    objc_msgSend(v16, "commit", v55, v56, v57, v58);
    v17 = 0;
  }
  if ((*((_BYTE *)this + 80) & 1) != 0 && (v17 & 1) == 0)
    v17 = objc_msgSend(*((id *)this + 2), "waitUntilScheduled");
  if (v5)
  {
    v18 = RB::current_time_seconds((RB *)v17);
    RB::Drawable::submit_frame(v5, (const unint64_t *)this + 4, v18 - *((double *)this + 9));
  }
  objc_msgSend((id)RB::Device::capture_scope((RB::Device *)v2), "endScope");
  if (RB::Device::prune_caches((dispatch_queue_t *)v2))
    objc_msgSend(v2[2], "collectResources");

  v19 = v60;
  if (v60)
  {
    v20 = (unsigned int *)(v60 + 1);
    do
    {
      v21 = __ldxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
    {
      __dmb(9u);
      (*((void (**)(id *))*v19 + 1))(v19);
    }
  }
  v23 = v59;
  if (v59)
  {
    v24 = &v59[2]._os_unfair_lock_opaque;
    do
    {
      v25 = __ldxr(v24);
      v26 = v25 - 1;
    }
    while (__stlxr(v26, v24));
    if (!v26)
    {
      __dmb(9u);
      (*(void (**)(os_unfair_lock_s *))(*(_QWORD *)&v23->_os_unfair_lock_opaque + 8))(v23);
    }
  }

  if (!v5)
    goto LABEL_37;
  v27 = &v5[2]._os_unfair_lock_opaque;
  do
  {
    v28 = __ldxr(v27);
    v29 = v28 - 1;
  }
  while (__stlxr(v29, v27));
  if (!v29)
  {
    __dmb(9u);
    (*(void (**)(os_unfair_lock_s *))(*(_QWORD *)&v5->_os_unfair_lock_opaque + 8))(v5);
    if (!v2)
      goto LABEL_42;
  }
  else
  {
LABEL_37:
    if (!v2)
      goto LABEL_42;
  }
  v30 = (unsigned int *)(v2 + 1);
  do
  {
    v31 = __ldxr(v30);
    v32 = v31 - 1;
  }
  while (__stlxr(v32, v30));
  if (!v32)
  {
    __dmb(9u);
    (*((void (**)(id *))*v2 + 1))(v2);
  }
LABEL_42:

  v33 = (void *)*((_QWORD *)this + 34);
  if (v33)
    v34 = (char *)*((_QWORD *)this + 34);
  else
    v34 = (char *)this + 240;
  v35 = *((unsigned int *)this + 70);
  if ((_DWORD)v35)
  {
    for (i = 0; i < v35; ++i)
    {
      v37 = *(_QWORD *)&v34[8 * i];
      *(_QWORD *)&v34[8 * i] = 0;
      if (v37)
      {
        RB::RenderFrame::QueueDeleter::operator()((uint64_t)v33, v37);
        v35 = *((unsigned int *)this + 70);
      }
    }
    v33 = (void *)*((_QWORD *)this + 34);
  }
  if (v33)
    free(v33);
  RB::UntypedTable::~UntypedTable((RB::RenderFrame *)((char *)this + 152));
  v38 = (_QWORD *)*((_QWORD *)this + 15);
  if (v38)
  {
    do
    {
      v39 = (_QWORD *)*v38;
      operator delete(v38);
      v38 = v39;
    }
    while (v39);
  }
  *((_QWORD *)this + 15) = 0;
  v40 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(*((_QWORD **)this + 14));
  free(v40);
  v41 = (_QWORD *)*((_QWORD *)this + 13);
  v42 = v41[1];
  if (v42)
  {
    v43 = v41 + 3;
    do
    {
      v45 = *v43++;
      v44 = v45;
      if ((v45 & 1) != 0)
      {
        v46 = (_DWORD *)(v44 & 0xFFFFFFFFFFFFFFFELL);
        v47 = *(_DWORD *)((v44 & 0xFFFFFFFFFFFFFFFELL) + 8) - 1;
        v46[2] = v47;
        if (!v47)
          (*(void (**)(_DWORD *))(*(_QWORD *)v46 + 8))(v46);
      }
      --v42;
    }
    while (v42);
  }
  v48 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v41);
  free(v48);
  v49 = (_QWORD *)*((_QWORD *)this + 12);
  v50 = v49[1];
  if (v50)
  {
    v51 = (_DWORD **)(v49 + 3);
    do
    {
      v52 = *v51;
      if (*v51)
      {
        v53 = v52[2] - 1;
        v52[2] = v53;
        if (!v53)
          (*(void (**)(_DWORD *))(*(_QWORD *)v52 + 8))(v52);
      }
      ++v51;
      --v50;
    }
    while (v50);
  }
  v54 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(v49);
  free(v54);

}

void sub_209AF7CFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, unsigned int *a13, unsigned int *a14, id a15)
{
  uint64_t v15;
  unsigned int *v16;
  unsigned int *v17;
  void *v18;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  unsigned int *v29;
  unsigned int v30;
  unsigned int v31;
  _QWORD *v32;
  _QWORD *v33;

  if (a14)
  {
    v20 = a14 + 2;
    do
    {
      v21 = __ldxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)a14 + 8))(a14);
    }
  }
  if (a13)
  {
    v23 = a13 + 2;
    do
    {
      v24 = __ldxr(v23);
      v25 = v24 - 1;
    }
    while (__stlxr(v25, v23));
    if (!v25)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)a13 + 8))(a13);
    }
  }

  if (!v17)
    goto LABEL_15;
  v26 = v17 + 2;
  do
  {
    v27 = __ldxr(v26);
    v28 = v27 - 1;
  }
  while (__stlxr(v28, v26));
  if (!v28)
  {
    __dmb(9u);
    (*(void (**)(unsigned int *))(*(_QWORD *)v17 + 8))(v17);
    if (!v16)
      goto LABEL_20;
  }
  else
  {
LABEL_15:
    if (!v16)
      goto LABEL_20;
  }
  v29 = v16 + 2;
  do
  {
    v30 = __ldxr(v29);
    v31 = v30 - 1;
  }
  while (__stlxr(v31, v29));
  if (!v31)
  {
    __dmb(9u);
    (*(void (**)(unsigned int *))(*(_QWORD *)v16 + 8))(v16);
  }
LABEL_20:

  RB::vector<std::unique_ptr<RB::RenderQueue,RB::RenderFrame::QueueDeleter>,4ul,unsigned int>::~vector(v15 + 240);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(v15 + 152));
  v32 = *(_QWORD **)(v15 + 120);
  if (v32)
  {
    do
    {
      v33 = (_QWORD *)*v32;
      operator delete(v32);
      v32 = v33;
    }
    while (v33);
  }
  *(_QWORD *)(v15 + 120) = 0;
  RB::shared_vector<RB::Function const*>::~shared_vector((_QWORD **)(v15 + 112));
  RB::shared_vector<RB::RenderFrame::TextureRef>::~shared_vector(v15 + 104);
  RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::~shared_vector(v15 + 96);

  _Unwind_Resume(a1);
}

uint64_t RB::Device::capture_scope(RB::Device *this)
{
  uint64_t result;
  void *v3;

  result = *((_QWORD *)this + 9);
  if (!result)
  {
    v3 = (void *)objc_msgSend((id)objc_msgSend(MEMORY[0x24BDDD500], "sharedCaptureManager"), "newCaptureScopeWithCommandQueue:", RB::Device::command_queue((id *)this));

    *((_QWORD *)this + 9) = v3;
    if (v3)
    {
      objc_msgSend(v3, "setLabel:", CFSTR("RenderBox"));
      return *((_QWORD *)this + 9);
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void RB::SharedSurfaceGroup::remove_subsurface(os_unfair_lock_s *this, RB::SharedSubsurface *a2, int a3)
{
  void *v6;
  __n128 v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  unsigned int *v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  uint64_t v17;
  __int128 v18;
  unsigned int *v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  int v29;
  unsigned int v30;
  uint64_t v31;
  unsigned int *v32;
  unsigned int v33;
  unsigned int v34;
  _BYTE v35[24];
  int v36;

  if (*(_QWORD *)a2)
  {
    if (a3)
    {
      v6 = (void *)*((_QWORD *)a2 + 3);
      if (v6)
      {
        *((_DWORD *)a2 + 10) = objc_msgSend(v6, "commitId") + 1;
        *((CFTimeInterval *)a2 + 4) = CACurrentMediaTime() + 0.0666666667;
      }
    }
    os_unfair_lock_lock(this + 4);
    v8 = *(_QWORD *)a2;
    *(_QWORD *)a2 = 0;
    v9 = *(_DWORD *)(v8 + 80);
    if (v9)
    {
      v10 = 0;
      v11 = *(_QWORD *)(v8 + 72);
      v12 = *(_DWORD *)(v8 + 80);
      while (*(_DWORD *)(v11 + v10 + 24) != *((_DWORD *)a2 + 12))
      {
        v10 += 32;
        if (!--v12)
          goto LABEL_9;
      }
      v13 = *(unsigned int **)(v11 + v10);
      *(_QWORD *)(v11 + v10) = 0;
      v14 = *(_QWORD *)(v8 + 72);
      v15 = (uint64_t *)(v14 + v10);
      v16 = (uint64_t *)(v14 + 32 * (v9 - 1));
      v17 = *v15;
      *v15 = 0;
      *(_OWORD *)v35 = *(_OWORD *)(v15 + 1);
      *(_QWORD *)&v35[14] = *(uint64_t *)((char *)v15 + 22);
      *v15 = *v16;
      v18 = *(_OWORD *)(v16 + 1);
      *(uint64_t *)((char *)v15 + 22) = *(uint64_t *)((char *)v16 + 22);
      *(_OWORD *)(v15 + 1) = v18;
      *v16 = v17;
      *(uint64_t *)((char *)v16 + 22) = *(_QWORD *)&v35[14];
      *(_OWORD *)(v16 + 1) = *(_OWORD *)v35;
      LODWORD(v16) = *(_DWORD *)(v8 + 80) - 1;
      *(_DWORD *)(v8 + 80) = (_DWORD)v16;
      v19 = *(unsigned int **)(*(_QWORD *)(v8 + 72) + 32 * v16);
      if (v19)
      {
        v20 = v19 + 2;
        do
        {
          v21 = __ldxr(v20);
          v22 = v21 - 1;
        }
        while (__stlxr(v22, v20));
        if (!v22)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v19 + 8))(v19);
        }
      }
    }
    else
    {
LABEL_9:
      v13 = 0;
    }
    v23 = v13 + 6;
    do
      v24 = __ldxr(v23);
    while (__stxr(v24 - 1, v23));
    if (a3)
    {
      v25 = v13 + 7;
      do
        v26 = __ldxr(v25);
      while (__stxr(v26 + 1, v25));
      *(_QWORD *)&v35[8] = *((_QWORD *)a2 + 1);
      *(_QWORD *)&v35[16] = *((_QWORD *)a2 + 2);
      v36 = *((_DWORD *)a2 + 12);
      v27 = *((_QWORD *)a2 + 3);
      *((_QWORD *)a2 + 3) = 0;
      v28 = *((_QWORD *)a2 + 4);
      v29 = *((_DWORD *)a2 + 10);
      v30 = *(_DWORD *)(v8 + 96);
      if (*(_DWORD *)(v8 + 100) < v30 + 1)
      {
        RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(v8 + 88, v30 + 1);
        v30 = *(_DWORD *)(v8 + 96);
      }
      v31 = *(_QWORD *)(v8 + 88) + 56 * v30;
      *(_QWORD *)v31 = v13;
      *(_QWORD *)v35 = 0;
      *(_OWORD *)(v31 + 8) = *(_OWORD *)&v35[8];
      *(_DWORD *)(v31 + 24) = v36;
      *(_QWORD *)(v31 + 32) = v27;
      *(_QWORD *)(v31 + 40) = v28;
      *(_DWORD *)(v31 + 48) = v29;
      ++*(_DWORD *)(v8 + 96);

      v13 = 0;
    }
    else
    {
      v7.n128_u64[0] = *((_QWORD *)a2 + 2);
      RB::BinAllocator::dealloc(v8 + 32, *((double *)a2 + 1), v7);
      --*(_DWORD *)(v8 + 104);
    }
    LOBYTE(this[15]._os_unfair_lock_opaque) = 1;
    objc_msgSend(*(id *)(*(_QWORD *)&this->_os_unfair_lock_opaque + 16), "collectResources", *(_QWORD *)v35);
    if (v13)
    {
      v32 = v13 + 2;
      do
      {
        v33 = __ldxr(v32);
        v34 = v33 - 1;
      }
      while (__stlxr(v34, v32));
      if (!v34)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v13 + 8))(v13);
      }
    }
    os_unfair_lock_unlock(this + 4);
  }
}

void sub_209AF81F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  os_unfair_lock_s *v9;

  RB::SharedSurface::Remove::~Remove(&a9);
  os_unfair_lock_unlock(v9);
  _Unwind_Resume(a1);
}

void RB::RenderFrame::QueueDeleter::operator()(uint64_t a1, uint64_t a2)
{
  if (*(_DWORD *)(a2 + 4) >= 0x41u)
    free(*(void **)(a2 + 8));
  RB::Heap::~Heap((RB::Heap *)(a2 + 16));
  free((void *)a2);
}

void RB::Drawable::submit_frame(os_unfair_lock_s *this, const unint64_t *a2, double a3)
{
  os_unfair_lock_s *v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  unint64_t v14;
  os_unfair_lock_s *v15;
  double v16;
  double *p_os_unfair_lock_opaque;
  double v18;
  double v19;

  v6 = this + 8;
  os_unfair_lock_lock(this + 8);
  v7 = *(_QWORD *)&this[10]._os_unfair_lock_opaque;
  if ((v7 & 1) != 0)
  {
    if (!*(_QWORD *)&this[14]._os_unfair_lock_opaque)
    {
      *(double *)&this[18]._os_unfair_lock_opaque = a3;
      *(double *)&this[34]._os_unfair_lock_opaque = a3;
      *(double *)&this[50]._os_unfair_lock_opaque = a3;
      *(double *)&this[66]._os_unfair_lock_opaque = a3;
      if ((v7 & 4) == 0)
        goto LABEL_19;
      goto LABEL_9;
    }
    *(double *)&this[18]._os_unfair_lock_opaque = *(double *)&this[18]._os_unfair_lock_opaque + a3;
    v8 = *(double *)&this[34]._os_unfair_lock_opaque;
    if (v8 > a3)
      v8 = a3;
    *(double *)&this[34]._os_unfair_lock_opaque = v8;
    v9 = *(double *)&this[50]._os_unfair_lock_opaque;
    if (v9 < a3)
      v9 = a3;
    *(double *)&this[50]._os_unfair_lock_opaque = v9;
    *(double *)&this[66]._os_unfair_lock_opaque = a3
                                                + (*(double *)&this[66]._os_unfair_lock_opaque - a3)
                                                * *(double *)&this[12]._os_unfair_lock_opaque;
  }
  if ((v7 & 4) == 0)
    goto LABEL_19;
LABEL_9:
  v10 = (double)a2[2] * 0.00000000519565863
      + (double)a2[3] * 1.98319745e-11
      + (double)a2[4] * 0.000100953793
      + (double)a2[1] * 4.31643348e-11
      + (double)*a2 * 0.00000000753195849;
  if (*(_QWORD *)&this[14]._os_unfair_lock_opaque)
  {
    *(double *)&this[22]._os_unfair_lock_opaque = *(double *)&this[22]._os_unfair_lock_opaque + v10;
    v11 = *(double *)&this[38]._os_unfair_lock_opaque;
    if (v10 < v11)
      v11 = v10;
    *(double *)&this[38]._os_unfair_lock_opaque = v11;
    v12 = *(double *)&this[54]._os_unfair_lock_opaque;
    if (v12 < v10)
      v12 = v10;
    *(double *)&this[54]._os_unfair_lock_opaque = v12;
    v10 = v10 + (*(double *)&this[70]._os_unfair_lock_opaque - v10) * *(double *)&this[12]._os_unfair_lock_opaque;
  }
  else
  {
    *(double *)&this[22]._os_unfair_lock_opaque = v10;
    *(double *)&this[38]._os_unfair_lock_opaque = v10;
    *(double *)&this[54]._os_unfair_lock_opaque = v10;
  }
  *(double *)&this[70]._os_unfair_lock_opaque = v10;
LABEL_19:
  v13 = *(_QWORD *)&this[14]._os_unfair_lock_opaque;
  if ((v7 & 8) != 0)
  {
    v14 = 0;
    v15 = this + 40;
    while (1)
    {
      v16 = (double)a2[v14 / 2];
      p_os_unfair_lock_opaque = (double *)&v15[v14]._os_unfair_lock_opaque;
      if (v13)
        break;
      *(p_os_unfair_lock_opaque - 8) = v16;
      *p_os_unfair_lock_opaque = v16;
      p_os_unfair_lock_opaque[8] = v16;
LABEL_28:
      p_os_unfair_lock_opaque[16] = v16;
      v14 += 2;
      if (v14 == 10)
        goto LABEL_29;
    }
    *(p_os_unfair_lock_opaque - 8) = *(p_os_unfair_lock_opaque - 8) + v16;
    v18 = *(double *)&v15[v14]._os_unfair_lock_opaque;
    if (v18 <= v16)
    {
      v19 = v16;
      if (v18 < v16)
      {
LABEL_27:
        p_os_unfair_lock_opaque = (double *)&v15[v14]._os_unfair_lock_opaque;
        *(double *)&v15[v14 + 16]._os_unfair_lock_opaque = v19;
        v16 = v16
            + (*(double *)&v15[v14 + 32]._os_unfair_lock_opaque - v16) * *(double *)&this[12]._os_unfair_lock_opaque;
        goto LABEL_28;
      }
    }
    else
    {
      *(double *)&v15[v14]._os_unfair_lock_opaque = v16;
      v18 = v16;
    }
    v19 = v18;
    goto LABEL_27;
  }
LABEL_29:
  *(_QWORD *)&this[14]._os_unfair_lock_opaque = v13 + 1;
  os_unfair_lock_unlock(v6);
}

uint64_t RB::Device::prune_caches(dispatch_queue_t *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  dispatch_queue_t v5;
  unsigned int v6;
  char *i;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;
  dispatch_queue_t v11;
  Class isa;
  unsigned int v13;
  char *v14;
  dispatch_queue_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  dispatch_queue_t v19;
  Class v20;
  RB::Device *v21;
  _DWORD *v22;
  RB::Device *v23;
  RB::Device **v24;
  uint64_t v26;
  RB::Device *v27;
  int v28;
  os_unfair_lock_s *v29;
  RB::GlyphPathCache *v30;
  dispatch_queue_t v31;
  uint64_t v32;
  char *v33;
  char *v34;
  void *v35;
  uint64_t v36;
  uint64_t v37;
  char *v38;
  char *v39;
  uint64_t v40;
  int v41;
  size_t v42;
  std::string *v43;
  size_t size;
  FILE **v45;
  os_unfair_lock_s *v46;
  std::string v48;
  void *v49;
  uint64_t v50;
  unint64_t v51;
  RB::Device *context;
  RB::Device **p_context;
  unsigned __int8 *v54;
  unsigned __int8 v55;
  uint64_t v56;
  int v57;
  char __s[20];
  uint64_t v59;

  v59 = *MEMORY[0x24BDAC8D0];
  v2 = *((unsigned int *)this + 48);
  v55 = 0;
  v3 = (uint64_t)(RB::current_time_seconds((RB *)this) * 60.0 + 0.5);
  v4 = (v3 - 30);
  v5 = this[45];
  if ((unint64_t)this[46] <= 0x4000000)
    v6 = v3 - 600;
  else
    v6 = v3 - 30;
  for (i = (char *)(this + 43); v5; v5 = this[45])
  {
    v8 = (uint64_t *)this[44];
    v9 = v8[2];
    if (*(_DWORD *)(v9 + 36) > v6)
      break;
    this[46] = (dispatch_queue_t)((char *)this[46] - *(_QWORD *)(v9 + 48));
    v10 = *v8;
    *(_QWORD *)(v10 + 8) = v8[1];
    *(_QWORD *)v8[1] = v10;
    this[45] = (dispatch_queue_t)((char *)v5 - 1);
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((_DWORD)this + 344, v8);
  }
  v11 = this[44];
  if (v11 != (dispatch_queue_t)i)
  {
    do
    {
      isa = v11[2].isa;
      if (*((_DWORD *)isa + 8) - (int)v2 > 0)
        break;
      RB::Resource::set_volatile((id *)isa, 1);
      v11 = (dispatch_queue_t)v11[1].isa;
    }
    while (v11 != (dispatch_queue_t)i);
    v5 = this[45];
  }
  if (v5)
    v55 = 1;
  if ((unint64_t)this[53] <= 0x8000000)
    v13 = v3 - 600;
  else
    v13 = v3 - 30;
  v14 = (char *)(this + 47);
  while (1)
  {
    v15 = this[49];
    if (!v15)
      break;
    v16 = (uint64_t *)this[48];
    v17 = v16[2];
    if (*(_DWORD *)(v17 + 36) > v13)
      break;
    this[53] = (dispatch_queue_t)((char *)this[53] - *(unsigned int *)(v17 + 72));
    v18 = *v16;
    *(_QWORD *)(v18 + 8) = v16[1];
    *(_QWORD *)v16[1] = v18;
    this[49] = (dispatch_queue_t)((char *)v15 - 1);
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::__delete_node[abi:nn180100]<>((_DWORD)this + 376, v16);
  }
  v19 = this[48];
  if (v19 != (dispatch_queue_t)v14)
  {
    do
    {
      v20 = v19[2].isa;
      if (*((_DWORD *)v20 + 8) - (int)v2 > 0)
        break;
      if ((*((_BYTE *)v20 + 77) & 2) != 0)
        v20 = (Class)*((_QWORD *)v20 + 3);
      RB::Resource::set_volatile((id *)v20, 1);
      v19 = (dispatch_queue_t)v19[1].isa;
    }
    while (v19 != (dispatch_queue_t)v14);
    v15 = this[49];
  }
  if (v15)
    v55 = 1;
  if (this[52])
  {
    context = (RB::Device *)&context;
    p_context = &context;
    v54 = 0;
    v21 = (RB::Device *)this[51];
    if (v21 == (RB::Device *)(this + 50))
      goto LABEL_42;
    do
    {
      v23 = (RB::Device *)*((_QWORD *)v21 + 1);
      v22 = (_DWORD *)*((_QWORD *)v21 + 2);
      if (v22)
        ++v22[2];
      if (v22[9] <= v4)
      {
        v24 = p_context;
        if (p_context != (RB::Device **)v21 && v23 != (RB::Device *)p_context)
        {
          v26 = *(_QWORD *)v21;
          *(_QWORD *)(v26 + 8) = v23;
          **((_QWORD **)v21 + 1) = v26;
          v27 = *v24;
          *((_QWORD *)v27 + 1) = v21;
          *(_QWORD *)v21 = v27;
          *v24 = v21;
          *((_QWORD *)v21 + 1) = v24;
          this[52] = (dispatch_queue_t)((char *)this[52] - 1);
          ++v54;
        }
      }
      v28 = v22[2] - 1;
      v22[2] = v28;
      if (!v28)
        (*(void (**)(_DWORD *))(*(_QWORD *)v22 + 8))(v22);
      v21 = v23;
    }
    while (v23 != (RB::Device *)(this + 50));
    if (this[52])
LABEL_42:
      v55 = 1;
    std::__list_imp<RB::refcounted_ptr<RB::Texture>>::clear((uint64_t *)&context);
  }
  context = (RB::Device *)(v2 | (v4 << 32));
  p_context = (RB::Device **)(((v3 - 600) | (unint64_t)(v3 << 32)) - 0x200000000);
  RB::UntypedTable::remove_if ((uint64_t)(this + 100), (BOOL (*)(const void *, const void *, void *))RB::Table<unsigned long,RB::TextureCache *>::remove_if<RB::Device::prune_caches(void)::$_0>(RB::Device::prune_caches(void)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, &context);
  if (this[107])
    v55 = 1;
  context = (RB::Device *)this;
  LODWORD(p_context) = v3 - 600;
  v54 = &v55;
  dispatch_sync_f(this[5], &context, (dispatch_function_t)RB::Device::prune_caches(void)::$_2::__invoke);
  LODWORD(v49) = v3 - 600;
  RB::UntypedTable::remove_if ((uint64_t)(this + 110), (BOOL (*)(const void *, const void *, void *))RB::Table<RB::CustomShader::Library *,RB::FunctionLibrary *>::remove_if<RB::Device::prune_caches(void)::$_3>(RB::Device::prune_caches(void)::$_3)::{lambda(void const*,void const*,void *)#1}::__invoke, &v49);
  v29 = (os_unfair_lock_s *)this[122];
  if (v29 && RB::SharedSurfaceGroup::prune_caches(v29, v3))
    v55 = 1;
  v30 = (RB::GlyphPathCache *)this[120];
  if (v30)
  {
    v30 = (RB::GlyphPathCache *)RB::GlyphPathCache::prune(v30, v3);
    if ((_DWORD)v30)
      v55 = 1;
  }
  if (*((_BYTE *)this + 553))
  {
    v49 = 0;
    v50 = 0;
    v51 = 0;
    v31 = this[66];
    if (v31)
    {
      v32 = 0;
      do
      {
        v48.__r_.__value_.__l.__data_ = (std::string::pointer)v31[2].isa;
        LODWORD(v48.__r_.__value_.__r.__words[1]) = v31[3].isa;
        if (v51 < v32 + 1)
        {
          RB::vector<RB::FormattedRenderState,0ul,unsigned long>::reserve_slow((uint64_t)&v49, v32 + 1);
          v32 = v50;
        }
        v33 = (char *)v49 + 12 * v32;
        *(_QWORD *)v33 = v48.__r_.__value_.__r.__words[0];
        *((_DWORD *)v33 + 2) = v48.__r_.__value_.__r.__words[1];
        v32 = ++v50;
        v31 = (dispatch_queue_t)v31->isa;
      }
      while (v31);
      v31 = (dispatch_queue_t)v49;
      v34 = (char *)v49 + 12 * v32;
      if (v32 >= 129)
      {
        v35 = std::get_temporary_buffer[abi:nn180100]<RB::FormattedRenderState>(v32);
        v37 = v36;
LABEL_62:
        std::__stable_sort<std::_ClassicAlgPolicy,RB::Device::prune_caches(void)::$_4 &,RB::FormattedRenderState *>((uint64_t)v31, v34, v32, (uint64_t)v35, v37);
        if (v35)
          operator delete(v35);
        memset(&v48, 0, sizeof(v48));
        std::string::append(&v48, "RenderBox pipelines:", 0x14uLL);
        if (v50)
        {
          v38 = (char *)v49;
          v39 = (char *)v49 + 12 * v50;
          do
          {
            v40 = *(_QWORD *)v38;
            v41 = *((_DWORD *)v38 + 2);
            std::string::push_back(&v48, 32);
            v56 = v40;
            v57 = v41;
            RB::FormattedRenderState::ID::formatted((uint64_t)&v56, (uint64_t)__s);
            v42 = strlen(__s);
            std::string::append(&v48, __s, v42);
            v38 += 12;
          }
          while (v38 != v39);
        }
        std::string::push_back(&v48, 10);
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          v43 = &v48;
        else
          v43 = (std::string *)v48.__r_.__value_.__r.__words[0];
        if ((v48.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
          size = HIBYTE(v48.__r_.__value_.__r.__words[2]);
        else
          size = v48.__r_.__value_.__l.__size_;
        v45 = (FILE **)MEMORY[0x24BDAC8E8];
        fwrite(v43, 1uLL, size, (FILE *)*MEMORY[0x24BDAC8E8]);
        fflush(*v45);
        *((_BYTE *)this + 553) = 0;
        if (SHIBYTE(v48.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v48.__r_.__value_.__l.__data_);
        v30 = (RB::GlyphPathCache *)v49;
        if (v49)
          free(v49);
        goto LABEL_77;
      }
    }
    else
    {
      v34 = 0;
      v32 = 0;
    }
    v35 = 0;
    v37 = 0;
    goto LABEL_62;
  }
LABEL_77:
  v46 = (os_unfair_lock_s *)RB::Device::RenderPipelineEntry::Queue::shared(v30);
  os_unfair_lock_lock(v46);
  RB::Device::RenderPipelineEntry::Queue::load_next_locked((RB::Device::RenderPipelineEntry::Queue *)v46);
  os_unfair_lock_unlock(v46);
  return v55;
}

void sub_209AF8A34(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, int a12, __int16 a13, char a14, char a15, void *a16)
{
  if (a16)
    free(a16);
  _Unwind_Resume(exception_object);
}

uint64_t RB::UntypedTable::remove_if (uint64_t this, BOOL (*a2)(const void *, const void *, void *), void *a3)
{
  _QWORD *v5;
  unint64_t v6;
  int v7;
  _QWORD **v8;
  _QWORD *v9;
  uint64_t (*v10)(_QWORD);
  uint64_t (*v11)(_QWORD);

  if (*(_QWORD *)(this + 56))
  {
    v5 = (_QWORD *)this;
    v6 = 0;
    v7 = *(_DWORD *)(this + 72);
    do
    {
      v8 = (_QWORD **)(v5[6] + 8 * v6);
      while (1)
      {
        v9 = *v8;
        if (!*v8)
          break;
        this = ((uint64_t (*)(_QWORD, _QWORD, void *))a2)(v9[1], v9[2], a3);
        if ((_DWORD)this)
        {
          *v8 = (_QWORD *)*v9;
          v10 = (uint64_t (*)(_QWORD))v5[2];
          if (v10)
            this = v10(v9[1]);
          v11 = (uint64_t (*)(_QWORD))v5[3];
          if (v11)
            this = v11(v9[2]);
          *v9 = v5[5];
          v5[5] = v9;
          --v5[7];
        }
        else
        {
          v8 = (_QWORD **)v9;
        }
      }
      ++v6;
    }
    while (!(v6 >> v7));
  }
  return this;
}

uint64_t RB::SharedSurfaceGroup::prune_caches(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;

  v4 = this + 4;
  os_unfair_lock_lock(this + 4);
  RB::SharedSurfaceGroup::collect_removed_locked((RB::SharedSurfaceGroup *)this);
  v5 = RB::SharedSurfaceGroup::prune_caches_locked((uint64_t)this, a2);
  os_unfair_lock_unlock(v4);
  return v5;
}

void sub_209AF8BA0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::SharedSurfaceGroup::prune_caches_locked(uint64_t this, int a2)
{
  uint64_t v2;
  char *v3;
  uint64_t *v4;
  char v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned __int32 v18;
  int v19;
  RB *v20;
  uint64_t i;
  int32x2_t *v22;
  unsigned __int32 v23;
  int v24;
  int32x2_t *v25;
  int v26;
  IOSurfaceID ID;
  uint64_t v28;
  int v29;
  int v30;
  MTLPixelFormat v31;
  char *v32;
  int v33;
  FILE **v34;
  uint64_t j;
  std::string *v36;
  char v38;
  std::string v39;

  v2 = this;
  v3 = (char *)(this + 24);
  v4 = *(uint64_t **)(this + 32);
  if (v4 == (uint64_t *)(this + 24))
  {
    v6 = 0;
  }
  else
  {
    v6 = 0;
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = v4[2];
      if (*(_DWORD *)(v9 + 104))
      {
        this = RB::BinAllocator::free_space(v9 + 32);
        v10 = this;
        if (!v7 || (int)this > v8)
        {
          this = RB::SharedSurface::is_idle((os_unfair_lock_s *)v4[2], a2);
          if ((_DWORD)this)
          {
            v7 = v4[2];
            v8 = v10;
          }
          else
          {
            v6 = 1;
          }
        }
        v4 = (uint64_t *)v4[1];
      }
      else
      {
        v11 = *v4;
        v12 = (uint64_t *)v4[1];
        *(_QWORD *)(v11 + 8) = v12;
        *(_QWORD *)v4[1] = v11;
        --*(_QWORD *)(v2 + 40);
        std::__list_imp<RB::refcounted_ptr<RB::SharedSurface>>::__delete_node[abi:nn180100]<>((int)v3, v4);
        *(_BYTE *)(v2 + 60) = 1;
        v4 = v12;
      }
    }
    while (v4 != (uint64_t *)v3);
    if (v7)
    {
      this = +[RBDevice isRunningInBackground](RBDevice, "isRunningInBackground");
      if ((this & 1) == 0)
      {
        v13 = vmul_lane_s32(*(int32x2_t *)(v7 + 32), *(int32x2_t *)(v7 + 32), 1).u32[0];
        v14 = *(_QWORD *)(v2 + 32);
        if ((char *)v14 == v3)
        {
          v15 = 0;
        }
        else
        {
          v15 = 0;
          do
          {
            this = *(_QWORD *)(v14 + 16);
            if (this != v7)
            {
              v16 = *(_QWORD *)(this + 24);
              v17 = *(_QWORD *)(v7 + 24);
              if (*(_QWORD *)(v16 + 32) == *(_QWORD *)(v17 + 32)
                && *(unsigned __int8 *)(v16 + 44) == *(unsigned __int8 *)(v17 + 44)
                && *(_DWORD *)(v16 + 40) == *(_DWORD *)(v17 + 40)
                && *(float *)(this + 64) == *(float *)(v7 + 64))
              {
                v18 = vmul_lane_s32(*(int32x2_t *)(this + 32), *(int32x2_t *)(this + 32), 1).u32[0];
                this = RB::BinAllocator::free_space(this + 32);
                v15 = v15 - this + v18;
              }
            }
            v14 = *(_QWORD *)(v14 + 8);
          }
          while ((char *)v14 != v3);
        }
        if (v13 - (v13 >> 2) <= v15)
          v19 = v15;
        else
          v19 = v13 - (v13 >> 2);
        if (v8 > v19)
          RB::SharedSurfaceGroup::relocate_surface((RB::SharedSurfaceGroup *)v2, (RB::SharedSurface *)v7, v8 > v13 - (v13 >> 3));
      }
    }
  }
  if (RB::verbose_mode((RB *)this) && *(_QWORD *)(v2 + 40) && *(_BYTE *)(v2 + 60))
  {
    v38 = v6;
    v20 = (RB *)puts("\n** Shared surfaces **\n");
    for (i = *(_QWORD *)(v2 + 32); (char *)i != v3; i = *(_QWORD *)(i + 8))
    {
      v22 = *(int32x2_t **)(i + 16);
      v23 = vmul_lane_s32(v22[4], v22[4], 1).u32[0];
      v24 = v23 - RB::BinAllocator::free_space((uint64_t)&v22[4]);
      v25 = *(int32x2_t **)(i + 16);
      v26 = vmul_lane_s32(v25[4], v25[4], 1).u32[0];
      ID = IOSurfaceGetID(*(IOSurfaceRef *)(*(_QWORD *)&v25[3] + 48));
      v28 = *(_QWORD *)(i + 16);
      v29 = HIDWORD(*(_QWORD *)(v28 + 32));
      v30 = *(_QWORD *)(v28 + 32);
      v32 = RB::pixel_format_name(*(RB **)(*(_QWORD *)(v28 + 24) + 32), v31);
      v20 = (RB *)printf("  %08x  %4d x %4d  %-16s -- %d%% used, %d/%d (%d+%d).\n", ID, v30, v29, v32, (int)(float)((float)((float)((float)v24 * 100.0) / (float)v26) + 0.5), v24, v26, *(_DWORD *)(*(_QWORD *)(i + 16) + 80), *(_DWORD *)(*(_QWORD *)(i + 16) + 108) + *(_DWORD *)(*(_QWORD *)(i + 16) + 96));
    }
    v33 = RB::verbose_mode(v20);
    v34 = (FILE **)MEMORY[0x24BDAC8E8];
    v6 = v38;
    if (v33 > 1)
    {
      memset(&v39, 0, sizeof(v39));
      std::string::append(&v39, "\n<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n", 0x28uLL);
      std::string::append(&v39, "<display-list xmlns=\"http://www.apple.com/RenderBox/1.0\">\n", 0x3AuLL);
      std::string::append(&v39, "  <transform scale=\"0.5\"/>\n", 0x1BuLL);
      for (j = *(_QWORD *)(v2 + 32); (char *)j != v3; j = *(_QWORD *)(j + 8))
        RB::BinAllocator::print(*(_QWORD *)(j + 16) + 32, &v39);
      std::string::append(&v39, "</display-list>\n", 0x10uLL);
      v36 = (v39.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0
          ? &v39
          : (std::string *)v39.__r_.__value_.__r.__words[0];
      fputs((const char *)v36, *v34);
      if (SHIBYTE(v39.__r_.__value_.__r.__words[2]) < 0)
        operator delete(v39.__r_.__value_.__l.__data_);
    }
    fflush(*v34);
    *(_BYTE *)(v2 + 60) = 0;
  }
  return v6 & 1;
}

void sub_209AF8F4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *__p,uint64_t a21,int a22,__int16 a23,char a24,char a25)
{
  if (a25 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t RB::BinAllocator::free_space(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  __int16 *v5;

  v1 = *(unsigned int *)(this + 24);
  if (!(_DWORD)v1)
    return 0;
  v2 = this;
  LODWORD(this) = 0;
  v3 = *(_QWORD *)(v2 + 16);
  v4 = 32 * v1;
  v5 = (__int16 *)(v3 + 6);
  do
  {
    this = (this + *(v5 - 1) * *v5);
    v5 += 16;
    v4 -= 32;
  }
  while (v4);
  return this;
}

BOOL RB::SharedSurface::is_idle(os_unfair_lock_s *this, int a2)
{
  os_unfair_lock_s *v4;
  _BOOL8 v5;

  v4 = this + 28;
  os_unfair_lock_lock(this + 28);
  v5 = !LOBYTE(this[43]._os_unfair_lock_opaque)
    && !this[32]._os_unfair_lock_opaque
    && !this[36]._os_unfair_lock_opaque
    && !this[40]._os_unfair_lock_opaque
    && !this[24]._os_unfair_lock_opaque
    && !this[27]._os_unfair_lock_opaque
    && this[42]._os_unfair_lock_opaque < a2 - 12;
  os_unfair_lock_unlock(v4);
  return v5;
}

void RB::SharedSurfaceGroup::collect_removed_locked(RB::SharedSurfaceGroup *this)
{
  char *v1;
  char *v2;
  uint64_t v4;
  int v5;
  unsigned int v6;
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  _QWORD *v11;
  void *v12;
  NSObject *global_queue;
  char *v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  unint64_t v20;
  id *v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  void *v26;
  uint64_t v27;

  v26 = 0;
  v27 = 0;
  v1 = (char *)this + 24;
  v2 = (char *)*((_QWORD *)this + 4);
  if (v2 != (char *)this + 24)
  {
    do
    {
      v4 = *((_QWORD *)v2 + 2);
      v5 = *(_DWORD *)(v4 + 96);
      if (v5)
      {
        *(_DWORD *)(v4 + 108) += v5;
        v6 = v27;
        if (HIDWORD(v27) < (v27 + 1))
        {
          RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow((uint64_t)&v26, v27 + 1);
          v6 = v27;
        }
        v7 = (char *)v26 + 24 * v6;
        v7[1] = 0;
        v7[2] = 0;
        *v7 = v4;
        LODWORD(v7) = v27;
        LODWORD(v27) = v27 + 1;
        v8 = *((_QWORD *)v2 + 2);
        v9 = (char *)v26 + 24 * v7;
        v10 = *(_QWORD *)(v8 + 88);
        *(_QWORD *)(v8 + 88) = *((_QWORD *)v9 + 1);
        *((_QWORD *)v9 + 1) = v10;
        LODWORD(v10) = *(_DWORD *)(v8 + 96);
        *(_DWORD *)(v8 + 96) = *((_DWORD *)v9 + 4);
        *((_DWORD *)v9 + 4) = v10;
        LODWORD(v10) = *(_DWORD *)(v8 + 100);
        *(_DWORD *)(v8 + 100) = *((_DWORD *)v9 + 5);
        *((_DWORD *)v9 + 5) = v10;
      }
      v2 = (char *)*((_QWORD *)v2 + 1);
    }
    while (v2 != v1);
    if ((_DWORD)v27)
    {
      v11 = (_QWORD *)operator new();
      v12 = v26;
      *v11 = this;
      v11[1] = v12;
      v11[2] = v27;
      v26 = 0;
      v27 = 0;
      global_queue = dispatch_get_global_queue(2, 0);
      dispatch_async_f(global_queue, v11, (dispatch_function_t)RB::SharedSurfaceGroup::collect_removed_locked(void)::$_0::__invoke);
      v14 = (char *)v26;
      if (!(_DWORD)v27)
        goto LABEL_23;
      v15 = 0;
      do
      {
        v16 = &v14[24 * v15];
        v19 = (char *)*((_QWORD *)v16 + 1);
        v18 = v16 + 8;
        v17 = v19;
        if (*((_DWORD *)v18 + 2))
        {
          v20 = 0;
          do
          {
            v21 = (id *)&v17[56 * v20];

            v22 = (unsigned int *)*v21;
            if (*v21)
            {
              v23 = v22 + 2;
              do
              {
                v24 = __ldxr(v23);
                v25 = v24 - 1;
              }
              while (__stlxr(v25, v23));
              if (!v25)
              {
                __dmb(9u);
                (*(void (**)(unsigned int *))(*(_QWORD *)v22 + 8))(v22);
              }
            }
            ++v20;
          }
          while (v20 < *((unsigned int *)v18 + 2));
          v17 = *(char **)v18;
        }
        if (v17)
          free(v17);
        ++v15;
      }
      while (v15 < v27);
    }
  }
  v14 = (char *)v26;
LABEL_23:
  if (v14)
    free(v14);
}

void sub_209AF923C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char *a9, uint64_t a10, char *a11)
{
  RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::~vector(&a9);
  RB::vector<std::pair<RB::SharedSurface *,RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>>,0ul,unsigned int>::~vector(&a11);
  _Unwind_Resume(a1);
}

void *RB::vector<std::pair<std::pair<unsigned long,unsigned long>,RB::DisplayList::LayerTask *>,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,24ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,24ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(24 * a3);
    v6 = v5 / 0x18;
    if (*a2 != (v5 / 0x18))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

_QWORD *RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer(_QWORD *a1)
{
  void *v2;

  if (*a1)
  {
    v2 = (void *)RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::buffer::~buffer();
    free(v2);
  }
  return a1;
}

void RB::RenderFrame::end_encoding(id *this)
{
  id v2;

  if (((_BYTE)this[10] & 2) != 0)
  {
    dispatch_sync_f(*((dispatch_queue_t *)*this + 5), this, (dispatch_function_t)RB::RenderFrame::end_encoding(void)::$_0::__invoke);
  }
  else
  {
    v2 = this[36];
    if (v2)
    {
      objc_msgSend(v2, "endEncoding");

      this[36] = 0;
    }
  }
}

void RB::SharedSurface::update_removes(uint64_t a1)
{
  uint64_t *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  unsigned int v8;
  unsigned __int8 v9;
  uint64_t v10;
  RB::SharedSurfaceTimestamp *v11;
  void *v12;
  unsigned int v13;

  v2 = *(uint64_t **)a1;
  v3 = *(unsigned int *)(a1 + 8);
  v4 = 126 - 2 * __clz(v3);
  if ((_DWORD)v3)
    v5 = v4;
  else
    v5 = 0;
  std::__introsort<std::_ClassicAlgPolicy,RB::SharedSurface::update_removes(RB::vector<RB::SharedSurface::Remove,0ul,unsigned int> &)::$_0 &,RB::SharedSurface::Remove*,false>(v2, (uint64_t)&v2[7 * v3], v5, 1);
  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = 0;
    v9 = 0;
    v10 = 56 * v6;
    v11 = (RB::SharedSurfaceTimestamp *)(*(_QWORD *)a1 + 32);
    do
    {
      v12 = *(void **)v11;
      if (*(_QWORD *)v11)
      {
        v13 = *((_DWORD *)v11 + 4);
        if (v12 != v7)
          goto LABEL_8;
        if (v13 != v8)
        {
          if (((v13 < v8) & v9) != 0)
          {
LABEL_13:

            *(_QWORD *)v11 = 0;
            goto LABEL_14;
          }
LABEL_8:
          v9 = RB::SharedSurfaceTimestamp::test(v11);
          v8 = v13;
          v7 = v12;
          goto LABEL_14;
        }
        if ((v9 & 1) != 0)
          goto LABEL_13;
        v9 = 0;
      }
LABEL_14:
      v11 = (RB::SharedSurfaceTimestamp *)((char *)v11 + 56);
      v10 -= 56;
    }
    while (v10);
  }
}

uint64_t RB::SharedSurfaceTimestamp::test(RB::SharedSurfaceTimestamp *this)
{
  unsigned int v2;
  uint64_t result;

  if (!*(_QWORD *)this)
    return 1;
  if (CACurrentMediaTime() > *((double *)this + 1))
    goto LABEL_6;
  v2 = *((_DWORD *)this + 4);
  if (v2 > objc_msgSend(*(id *)this, "commitId"))
    return 0;
  result = objc_msgSend(*(id *)this, "waitForCommitId:timeout:", *((unsigned int *)this + 4), 0.0);
  if ((_DWORD)result)
  {
LABEL_6:

    *(_QWORD *)this = 0;
    return 1;
  }
  return result;
}

void RB::SharedSurfaceGroup::commit_removed(uint64_t a1, uint64_t **a2)
{
  RB *v4;
  __n128 v5;
  unsigned int v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t *v11;
  uint64_t *v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  __int128 v20;
  uint64_t v21;
  unsigned int *v22;
  void *v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int *v27;
  unsigned int v28;
  double v29;
  os_unfair_lock_s *lock;
  __int128 v31;
  int v32;

  lock = (os_unfair_lock_s *)(a1 + 16);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 16));
  v6 = *((_DWORD *)a2 + 2);
  if (v6)
  {
    v7 = *a2;
    v8 = (uint64_t)&(*a2)[3 * v6];
    do
    {
      v9 = *v7;
      v10 = *((_DWORD *)v7 + 4);
      *(_DWORD *)(*v7 + 108) -= v10;
      if (v10)
      {
        v11 = (uint64_t *)v7[1];
        v12 = &v11[7 * v10];
        do
        {
          if (v11[4])
          {
            v13 = *(_DWORD *)(v9 + 96);
            if (*(_DWORD *)(v9 + 100) < v13 + 1)
            {
              RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(v9 + 88, v13 + 1);
              v13 = *(_DWORD *)(v9 + 96);
            }
            v14 = *(_QWORD *)(v9 + 88) + 56 * v13;
            *(_QWORD *)(v14 + 48) = 0;
            *(_OWORD *)(v14 + 16) = 0u;
            *(_OWORD *)(v14 + 32) = 0u;
            *(_OWORD *)v14 = 0u;
            LODWORD(v14) = *(_DWORD *)(v9 + 96);
            *(_DWORD *)(v9 + 96) = v14 + 1;
            v15 = *(_QWORD *)(v9 + 88) + 56 * v14;
            v16 = *v11;
            *v11 = 0;
            v31 = *(_OWORD *)(v11 + 1);
            v32 = *((_DWORD *)v11 + 6);
            v17 = v11[4];
            v11[4] = 0;
            v18 = v11[5];
            v19 = *((_DWORD *)v11 + 12);
            *v11 = *(_QWORD *)v15;
            *(_QWORD *)v15 = 0;
            v20 = *(_OWORD *)(v15 + 8);
            *((_DWORD *)v11 + 6) = *(_DWORD *)(v15 + 24);
            *(_OWORD *)(v11 + 1) = v20;
            v21 = v11[4];
            v11[4] = *(_QWORD *)(v15 + 32);
            *(_QWORD *)(v15 + 32) = v21;
            v11[5] = *(_QWORD *)(v15 + 40);
            *((_DWORD *)v11 + 12) = *(_DWORD *)(v15 + 48);
            v22 = *(unsigned int **)v15;
            *(_QWORD *)v15 = v16;
            *(_OWORD *)(v15 + 8) = v31;
            *(_DWORD *)(v15 + 24) = v32;
            v23 = *(void **)(v15 + 32);
            *(_QWORD *)(v15 + 32) = v17;
            *(_QWORD *)(v15 + 40) = v18;
            *(_DWORD *)(v15 + 48) = v19;

            if (v22)
            {
              v24 = v22 + 2;
              do
              {
                v25 = __ldxr(v24);
                v26 = v25 - 1;
              }
              while (__stlxr(v26, v24));
              if (!v26)
              {
                __dmb(9u);
                v4 = (RB *)(*(uint64_t (**)(unsigned int *))(*(_QWORD *)v22 + 8))(v22);
              }
            }
          }
          else
          {
            v27 = (unsigned int *)(*v11 + 28);
            do
              v28 = __ldxr(v27);
            while (__stxr(v28 - 1, v27));
            v5.n128_u64[0] = v11[2];
            RB::BinAllocator::dealloc(v9 + 32, *((double *)v11 + 1), v5);
            --*(_DWORD *)(v9 + 104);
            *(_BYTE *)(a1 + 60) = 1;
          }
          v11 += 7;
        }
        while (v11 != v12);
      }
      v7 += 3;
    }
    while (v7 != (uint64_t *)v8);
  }
  v29 = RB::current_time_seconds(v4);
  RB::SharedSurfaceGroup::prune_caches_locked(a1, (uint64_t)(v29 * 60.0 + 0.5));
  os_unfair_lock_unlock(lock);
}

void sub_209AF9774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void *RB::vector<RB::SharedSurface::Remove,0ul,unsigned int>::reserve_slow(uint64_t a1, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_DWORD *)(a1 + 12) + (*(_DWORD *)(a1 + 12) >> 1);
  result = RB::details::realloc_vector<unsigned int,56ul>(*(void **)a1, (_DWORD *)(a1 + 12), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,56ul>(void *a1, _DWORD *a2, unsigned int a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(56 * a3);
    v6 = v5 / 0x38;
    if (*a2 != (v5 / 0x38))
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void RB::Device::install_render_pipeline_state(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t *v5;
  uint64_t *v6;
  uint64_t v7;
  RB::Device::RenderPipelineEntry::Queue *v8;
  uint64_t v9;
  os_unfair_lock_s *v10;
  uint64_t v11;
  int v12;

  v11 = a2;
  v12 = a3;
  v5 = RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 432), &v11, 0);
  if (v5)
  {
    v6 = v5;
    if (v5[2] == a4)
    {
      v7 = v5[3];
      v5[3] = *(_QWORD *)(a4 + 64);
      *(_QWORD *)(a4 + 64) = v7;
      *((_DWORD *)v5 + 10) = (uint64_t)(RB::current_time_seconds((RB *)v5) * 60.0 + 0.5);
      v9 = v6[2];
      v6[2] = 0;
      if (v9)
        RB::Device::RenderPipelineEntry::DeleteLoader::operator()((uint64_t)v8, v9);
      v10 = (os_unfair_lock_s *)RB::Device::RenderPipelineEntry::Queue::shared(v8);
      RB::Device::RenderPipelineEntry::Queue::retire_and_load_next(v10);
    }
  }
}

void RB::Device::RenderPipelineEntry::Queue::retire_and_load_next(os_unfair_lock_s *this)
{
  os_unfair_lock_lock(this);
  --this[1]._os_unfair_lock_opaque;
  RB::Device::RenderPipelineEntry::Queue::load_next_locked((RB::Device::RenderPipelineEntry::Queue *)this);
  os_unfair_lock_unlock(this);
}

void RB::Device::RenderPipelineEntry::Queue::load_next_locked(RB::Device::RenderPipelineEntry::Queue *this)
{
  uint64_t *i;
  unsigned int v3;
  uint64_t v4;

  for (i = (uint64_t *)*((_QWORD *)this + 1); i; i = (uint64_t *)*((_QWORD *)this + 1))
  {
    v3 = *((_DWORD *)this + 1);
    if (v3 > 3)
      break;
    v4 = *i;
    *((_QWORD *)this + 1) = *i;
    if (!v4)
      *((_QWORD *)this + 2) = 0;
    *((_DWORD *)this + 1) = v3 + 1;
    dispatch_async_f(*(dispatch_queue_t *)(i[1] + 40), i, (dispatch_function_t)RB::Device::RenderPipelineEntry::Queue::load_next_locked(void)::$_0::__invoke);
  }
}

void ___ZN2RB11RenderFrameD2Ev_block_invoke(uint64_t a1, void *a2)
{
  double v4;
  double v5;
  double v6;
  RB::Drawable *v7;

  objc_msgSend(a2, "GPUEndTime");
  v5 = v4;
  objc_msgSend(a2, "GPUStartTime");
  v7 = *(RB::Drawable **)(a1 + 32);
  if (v7)
    RB::Drawable::end_frame(v7, v5 - v6);
  RB::Device::retire_frame_id(*(os_unfair_lock_s **)(a1 + 40), *(_DWORD *)(a1 + 56));
  if (objc_msgSend(a2, "status") == 5)
    RB::Device::command_buffer_error(*(unsigned __int8 **)(a1 + 40), (void *)objc_msgSend(a2, "error"), *(void **)(a1 + 48));
}

void RB::Drawable::end_frame(RB::Drawable *this, double a2)
{
  os_unfair_lock_s *v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  double v8;
  id v9;
  NSObject *v10;

  *((double *)this + 3) = *((double *)this + 3) + a2;
  v4 = (os_unfair_lock_s *)((char *)this + 32);
  os_unfair_lock_lock((os_unfair_lock_t)this + 8);
  v5 = *((_QWORD *)this + 5);
  v6 = *((_QWORD *)this + 8);
  if ((v5 & 2) != 0)
  {
    if (v6)
    {
      *((double *)this + 10) = *((double *)this + 10) + a2;
      v7 = *((double *)this + 18);
      if (v7 > a2)
        v7 = a2;
      *((double *)this + 18) = v7;
      v8 = *((double *)this + 26);
      if (v8 < a2)
        v8 = a2;
      *((double *)this + 26) = v8;
      *((double *)this + 34) = a2 + (*((double *)this + 34) - a2) * *((double *)this + 6);
    }
    else
    {
      *((double *)this + 10) = a2;
      *((double *)this + 18) = a2;
      *((double *)this + 26) = a2;
      *((double *)this + 34) = a2;
    }
  }
  *((_QWORD *)this + 8) = v6 + 1;
  v9 = *((id *)this + 41);

  os_unfair_lock_unlock(v4);
  v10 = *((_QWORD *)this + 2);
  if (v10)
    dispatch_semaphore_signal(v10);
  if (v5 && v9)
    objc_msgSend(v9, "_RBDrawableStatisticsDidChange");

}

void sub_209AF9B44(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::Device::retire_frame_id(os_unfair_lock_s *this, uint32_t os_unfair_lock_opaque)
{
  os_unfair_lock_s *v4;
  unint64_t v5;
  unint64_t v6;
  os_unfair_lock_s *v7;
  os_unfair_lock_s *v8;
  char *v9;
  int v10;
  unint64_t v11;
  unint64_t v12;
  _BYTE *v13;
  _BYTE *v14;
  char *v15;
  char *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  os_unfair_lock_s *v20;
  uint64_t v21;
  char *v22;
  void *v23;
  _BYTE *v24;
  _QWORD *v25;
  uint64_t v26;
  NSObject *v27;
  void (**v28)(_QWORD);
  _BYTE *v29;
  unint64_t v30;
  id *v31;
  _BYTE v32[48];
  void *v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;

  v36 = *MEMORY[0x24BDAC8D0];
  v33 = 0;
  v34 = 0;
  v35 = 2;
  v4 = this + 46;
  os_unfair_lock_lock(this + 46);
  if ((int)(os_unfair_lock_opaque - this[48]._os_unfair_lock_opaque) < 1)
    os_unfair_lock_opaque = this[48]._os_unfair_lock_opaque;
  else
    this[48]._os_unfair_lock_opaque = os_unfair_lock_opaque;
  v5 = *(_QWORD *)&this[64]._os_unfair_lock_opaque;
  if (v5)
  {
    v6 = 0;
    do
    {
      v7 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
      if (v7)
        v8 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
      else
        v8 = this + 50;
      v9 = (char *)&v8[6 * v6];
      v10 = *(_DWORD *)v9;
      if ((int)(*(_DWORD *)v9 - os_unfair_lock_opaque) < 1)
      {
        v11 = v34;
        v12 = v34 + 1;
        if (v35 < v34 + 1)
        {
          RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::reserve_slow(v32, v12);
          v11 = v34;
          v10 = *(_DWORD *)v9;
          v7 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
          v5 = *(_QWORD *)&this[64]._os_unfair_lock_opaque;
          v12 = v34 + 1;
        }
        v13 = v33;
        if (!v33)
          v13 = v32;
        v14 = &v13[24 * v11];
        *(_DWORD *)v14 = v10;
        v15 = (char *)&v8[6 * v6];
        *(_OWORD *)(v14 + 8) = *(_OWORD *)(v15 + 8);
        *((_QWORD *)v15 + 1) = 0;
        *((_QWORD *)v15 + 2) = 0;
        v34 = v12;
        if (!v7)
          v7 = this + 50;
        v16 = (char *)&v7[6 * v5];
        v17 = *(_DWORD *)v9;
        *(_DWORD *)v9 = *((_DWORD *)v16 - 6);
        *((_DWORD *)v16 - 6) = v17;
        v18 = *((_QWORD *)v15 + 1);
        *((_QWORD *)v15 + 1) = *((_QWORD *)v16 - 2);
        *((_QWORD *)v16 - 2) = v18;
        v19 = *((_QWORD *)v15 + 2);
        *((_QWORD *)v15 + 2) = *((_QWORD *)v16 - 1);
        *((_QWORD *)v16 - 1) = v19;
        v20 = *(os_unfair_lock_s **)&this[62]._os_unfair_lock_opaque;
        v21 = *(_QWORD *)&this[64]._os_unfair_lock_opaque - 1;
        *(_QWORD *)&this[64]._os_unfair_lock_opaque = v21;
        if (!v20)
          v20 = this + 50;
        v22 = (char *)&v20[6 * v21];

        v5 = *(_QWORD *)&this[64]._os_unfair_lock_opaque;
      }
      else
      {
        ++v6;
      }
    }
    while (v6 < v5);
  }
  os_unfair_lock_unlock(v4);
  v23 = v33;
  v24 = v32;
  if (v33)
    v24 = v33;
  if (v34)
  {
    v25 = v24 + 16;
    v26 = 24 * v34;
    do
    {
      v27 = *(v25 - 1);
      v28 = (void (**)(_QWORD))*v25;
      if (v27)
        dispatch_async(v27, v28);
      else
        v28[2](*v25);
      v25 += 3;
      v26 -= 24;
    }
    while (v26);
    v23 = v33;
    v29 = v32;
    if (v33)
      v29 = v33;
    if (v34)
    {
      v30 = 0;
      v31 = (id *)(v29 + 16);
      do
      {

        ++v30;
        v31 += 3;
      }
      while (v30 < v34);
      v23 = v33;
    }
  }
  if (v23)
    free(v23);
}

void sub_209AF9DB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  os_unfair_lock_s *v9;

  os_unfair_lock_unlock(v9);
  RB::vector<RB::Device::FrameContinuation,2ul,unsigned long>::~vector(&a9);
  _Unwind_Resume(a1);
}

void sub_209AF9F20(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::AllLayers::shared(_anonymous_namespace_::AllLayers *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  if ((v1 & 1) == 0
  {
    v3 = operator new();
    *(_DWORD *)v3 = 0;
    *(_QWORD *)(v3 + 16) = 0;
    *(_QWORD *)(v3 + 24) = 0;
    *(_QWORD *)(v3 + 8) = 0;
  }
}

void sub_209AF9FAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::texture_cache_params(uint64_t a1, uint64_t a2, float64x2_t *a3, char a4, int32x2_t a5)
{
  int32x2_t v8;
  int v9;
  int v10;
  int v11;
  unsigned __int8 v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  BOOL v16;
  int v17;
  float64x2_t v19;
  float64x2_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  float v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint32x2_t v30;
  int v31;
  int v32;
  uint32x2_t v33;
  float64x2_t v34[3];
  int v35[4];
  __int128 v36;
  __int128 v37;

  v8 = a5;
  v9 = *(unsigned __int8 *)(a1 + 29);
  v10 = RB::Fill::ImageData::image_filter_uses_mipmaps(a2, a3, a5);
  v11 = v10;
  v12 = 0;
  v13 = *(unsigned __int16 *)(a2 + 78);
  v14 = *(_WORD *)(a2 + 78) == 4 || a3 == 0;
  if (!v14 && (v10 & 1) == 0)
  {
    v15 = (v13 >> 8) & 0xF;
    v16 = v15 > 8;
    v17 = (1 << v15) & 0x124;
    if (v16 || v17 == 0)
      goto LABEL_11;
    v19 = vcvtq_f64_f32(*(float32x2_t *)(a2 + 44));
    v20 = vcvtq_f64_f32(*(float32x2_t *)(a2 + 56));
    v34[0] = vcvtq_f64_f32(*(float32x2_t *)(a2 + 32));
    v34[1] = v19;
    v34[2] = v20;
    *(double *)&v21 = RB::operator*(v34, a3);
    *(_OWORD *)v35 = v21;
    v36 = v22;
    v37 = v23;
    v24 = vaddv_f32(vdiv_f32((float32x2_t)RB::AffineTransform::scale2((float64x2_t *)v35), vcvt_f32_s32(v8))) * 0.5;
    if (v24 > 0.5)
    {
LABEL_11:
      v12 = 0;
    }
    else
    {
      v35[0] = 0;
      frexpf(v24, v35);
      v12 = 0;
      v30 = (uint32x2_t)vcgt_s32(v8, (int32x2_t)0x1000000010);
      if ((vpmin_u32(v30, v30).u32[0] & 0x80000000) != 0 && v35[0] < 0)
      {
        v12 = 0;
        v31 = v35[0] + 1;
        do
        {
          v32 = v31;
          ++v12;
          v33 = (uint32x2_t)vcgt_s32(v8, (int32x2_t)0x2100000021);
          if ((vpmin_u32(v33, v33).u32[0] & 0x80000000) == 0)
            break;
          v8 = vshr_n_s32(v8, 1uLL);
          ++v31;
        }
        while (v32);
      }
    }
  }
  if (v11)
    v25 = 2;
  else
    v25 = 0;
  v26 = ((v13 & 0xF00) != 0) & (v13 >> 14);
  v27 = (8 * (a4 & 1)) | v25 | v26;
  v28 = v9 & 0xFE;
  if (!v26)
    v28 = v9;
  return v28 | (v27 << 24) | (v12 << 16) | 0x100u;
}

uint64_t RB::Fill::ImageData::image_filter_uses_mipmaps(uint64_t a1, float64x2_t *a2, int32x2_t a3)
{
  uint64_t result;

  result = RB::interpolation_mode_uses_mipmaps(*(_BYTE *)(a1 + 79) & 0xF);
  if ((_DWORD)result)
    return RB::Fill::ImageData::image_filter(a1, a2, a3) == 2;
  return result;
}

uint64_t RB::interpolation_mode_uses_mipmaps(unsigned int a1)
{
  return (a1 < 0xA) & (0x248u >> a1);
}

uint64_t __destroy_helper_block_e8_32c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE40c38_ZTSN2RB14refcounted_ptrINS_6DeviceEEE48c59_ZTSN2RB8objc_ptrIPU22objcproto11RBEncodable11objc_objectEE(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t result;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = *(unsigned int **)(a1 + 40);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  result = *(_QWORD *)(a1 + 32);
  if (result)
  {
    v7 = (unsigned int *)(result + 8);
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
    }
  }
  return result;
}

uint64_t RB::prefs_int(const __CFString *this, const __CFString *a2)
{
  RB::Config *v2;
  const void *v3;
  uint64_t v4;
  RB::Config *v6;

  RB::Config::prefs_value(this, &v6);
  v2 = v6;
  v4 = RB::Config::int_value((const __CFString *)v6, v3);
  if (v2)
    CFRelease(v2);
  return v4;
}

CFPropertyListRef RB::Config::prefs_value@<X0>(const __CFString *this@<X0>, _QWORD *a2@<X8>)
{
  const __CFString *v5;
  const __CFString *v6;
  CFPropertyListRef result;
  const __CFString *v8;
  const __CFString *v9;

  v5 = (const __CFString *)*MEMORY[0x24BDBD580];
  v6 = (const __CFString *)*MEMORY[0x24BDBD570];
  result = CFPreferencesCopyValue(this, (CFStringRef)*MEMORY[0x24BDBD580], (CFStringRef)*MEMORY[0x24BDBD578], (CFStringRef)*MEMORY[0x24BDBD570]);
  *a2 = result;
  if (!result)
  {
    v8 = (const __CFString *)*MEMORY[0x24BDBD590];
    result = CFPreferencesCopyValue(this, v5, (CFStringRef)*MEMORY[0x24BDBD590], v6);
    *a2 = result;
    if (!result)
    {
      v9 = (const __CFString *)*MEMORY[0x24BDBD568];
      result = CFPreferencesCopyValue(this, (CFStringRef)*MEMORY[0x24BDBD568], v8, (CFStringRef)*MEMORY[0x24BDBD588]);
      *a2 = result;
      if (!result)
      {
        result = CFPreferencesCopyValue(this, v9, v8, v6);
        *a2 = result;
      }
    }
  }
  return result;
}

void _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(unsigned int *a1, unsigned int *a2, uint64_t a3, char a4)
{
  unsigned int *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int *v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  unint64_t v26;
  __int128 v27;
  __int128 v28;
  unsigned int v29;
  unsigned int v30;
  __int128 v31;
  __int128 v32;
  BOOL v33;
  unsigned int v34;
  unsigned int *v35;
  unint64_t v36;
  unsigned int v37;
  __int128 v38;
  __int128 v39;
  unsigned int v40;
  unsigned int v41;
  __int128 v42;
  __int128 v43;
  unsigned int *v44;
  unsigned int v45;
  __int128 v46;
  __int128 v47;
  unsigned int *v48;
  unsigned int *v49;
  unsigned int *v50;
  unsigned int *v51;
  unsigned int v52;
  __int128 v53;
  unsigned int v54;
  __int128 v55;
  __int128 v56;
  uint64_t v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  uint64_t v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  __int128 v65;
  unsigned int *v66;
  BOOL v68;
  uint64_t v69;
  unsigned int *v70;
  unsigned int *v71;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  char *v75;
  __int128 v76;
  uint64_t v77;
  int64_t v78;
  int64_t v79;
  int64_t v80;
  uint64_t v81;
  unsigned int *v82;
  unint64_t v83;
  unsigned int v84;
  BOOL v85;
  unsigned int *v86;
  unint64_t v87;
  unint64_t v88;
  unsigned int *v89;
  __int128 v90;
  __int128 v91;
  uint64_t v92;
  unsigned int v93;
  int64_t v94;
  uint64_t v95;
  unsigned int *v96;
  unsigned int *v97;
  uint64_t v98;
  uint64_t v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  __int128 v103;
  uint64_t v104;
  unint64_t v105;
  unsigned int *v106;
  uint64_t v107;
  unint64_t v108;
  unsigned int *v109;
  __int128 v110;
  __int128 v111;
  unsigned int *v113;
  unint64_t v114;
  unint64_t v115;
  unsigned int *v116;
  __int128 v117;
  unint64_t v118;
  _BYTE v119[32];
  _BYTE v120[32];
  _BYTE v121[32];
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  _BYTE v127[32];
  _BYTE v128[32];
  __int128 v129;
  _BYTE v130[32];
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;

void init_background_notifications(void *a1)
{
  void *v2;
  uint64_t v3;
  NSObject *v4;
  NSObject *v5;
  uint8_t buf[4];
  int v7;
  uint64_t v8;

  v8 = *MEMORY[0x24BDAC8D0];
  v2 = (void *)objc_msgSend(MEMORY[0x24BDD16D0], "defaultCenter");
  objc_msgSend(v2, "addObserver:selector:name:object:", a1, sel_didEnterBackground_, CFSTR("UIApplicationDidEnterBackgroundNotification"), 0);
  objc_msgSend(v2, "addObserver:selector:name:object:", a1, sel_willEnterForeground_, CFSTR("UIApplicationWillEnterForegroundNotification"), 0);
  v3 = proc_pidoriginatorinfo();
  if ((_DWORD)v3)
  {
    is_running_in_background = 0;
  }
  else
  {
    v4 = RB::error_log((RB *)v3);
    v3 = os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
    if ((_DWORD)v3)
      init_background_notifications(v4);
  }
  v5 = RB::misc_log((RB *)v3);
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 67109120;
    v7 = is_running_in_background;
    _os_log_impl(&dword_209ACA000, v5, OS_LOG_TYPE_INFO, "RBDevice: initialized bg state: %{BOOL}d", buf, 8u);
  }
}

uint64_t RB::misc_log(RB *this)
{
  unsigned __int8 v1;
  unint64_t v2;
  int v4;

  v2 = 0x253EAE000uLL;
  if ((v1 & 1) == 0)
  {
    v2 = 0x253EAE000;
    if (v4)
    {
      RB::misc_log(void)::log = (uint64_t)os_log_create("com.apple.renderbox", "misc");
      v2 = 0x253EAE000;
    }
  }
  return *(_QWORD *)(v2 + 4080);
}

void sub_209AFB04C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x80C40B8603338);
  _Unwind_Resume(a1);
}

uint64_t RB::`anonymous namespace'::load_library(void *a1, void *a2)
{
  uint64_t v4;
  const char *v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v9;
  const char *v10;
  const char *v11;
  id v12;

  v4 = objc_msgSend(a1, "URLForResource:withExtension:", CFSTR("default"), CFSTR("metallib"));
  if (!v4)
  {
    v9 = objc_msgSend((id)objc_msgSend(a1, "bundlePath"), "UTF8String");
    RB::precondition_failure((RB *)"unable to find default.metallib in %s", v10, v9);
  }
  v12 = 0;
  v6 = objc_msgSend(a2, "newLibraryWithURL:error:", v4, &v12);
  if (v12)
    v7 = 1;
  else
    v7 = v6 == 0;
  if (v7)
  {
    if (v12)
      v11 = (const char *)objc_msgSend((id)objc_msgSend(v12, "localizedDescription"), "UTF8String");
    else
      v11 = "unknown error";
    RB::non_fatal_precondition_failure((RB *)"unable to load shader library: %s", v5, v11);
  }
  return v6;
}

RB::SurfacePool *RB::SurfacePool::shared(void)::$_0::__invoke<void *>()
{
  RB::SurfacePool *v0;
  RB::SurfacePool *result;

  v0 = (RB::SurfacePool *)operator new();
  result = RB::SurfacePool::SurfacePool(v0);
  RB::SurfacePool::_shared_pool = (uint64_t)result;
  return result;
}

RB::SurfacePool *RB::SurfacePool::SurfacePool(RB::SurfacePool *this)
{
  NSObject *v2;

  *(_DWORD *)this = 0;
  v2 = dispatch_queue_attr_make_with_qos_class(0, QOS_CLASS_USER_INITIATED, 0);
  *((_QWORD *)this + 1) = dispatch_queue_create("com.apple.RenderBox.SurfacePool", v2);
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 9) = 0;
  *((_QWORD *)this + 10) = 0;
  *((_QWORD *)this + 11) = 2;
  *((_QWORD *)this + 12) = 0;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 0x7FF0000000000000;
  *((_BYTE *)this + 128) = 0;
  return this;
}

void RB::pixel_format_traits(MTLPixelFormat)::$_0::__invoke()
{
  unsigned int *v0;

  v0 = (unsigned int *)malloc_type_malloc(0x1360uLL, 0x1000040A4BEB60DuLL);
  RB::pixel_format_traits(MTLPixelFormat)::sorted_traits = (uint64_t)v0;
  _ZNSt3__111__introsortINS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsELb0EEEvT1_SG_S9_NS_15iterator_traitsISG_E15difference_typeEb(v0, v0 + 1240, 12, 1);
}

uint64_t RB::DisplayList::Contents::finalize(void)::$_0::__invoke(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

uint64_t RB::`anonymous namespace'::find_bundle(RB::_anonymous_namespace_ *this)
{
  char *v1;
  char *v2;
  char *v3;
  uint64_t v4;
  int64_t v5;
  size_t v6;
  char *v7;
  size_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t result;
  const char *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  v1 = (char *)dyld_image_path_containing_address();
  if (!v1)
    goto LABEL_11;
  v2 = v1;
  v3 = strstr(v1, "/RenderBox.framework");
  if (!v3)
    goto LABEL_11;
  v5 = v3 - v2;
  v6 = v3 - v2 + 21;
  if (v6 > 0x1000)
  {
    v7 = (char *)malloc_type_malloc(v3 - v2 + 21, 0xCEA400B3uLL);
    if (!v7)
    {
      v10 = 0;
      goto LABEL_10;
    }
  }
  else
  {
    MEMORY[0x24BDAC7A8](v3, v4);
    v7 = (char *)v13 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v7, v6);
  }
  v8 = v5 + 20;
  memcpy(v7, v2, v8);
  v7[v8] = 0;
  v9 = objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:", v7, 1, 0);
  v10 = v9;
  if (v6 <= 0x1000)
  {
    if (v9)
      goto LABEL_12;
    goto LABEL_11;
  }
LABEL_10:
  free(v7);
  if (v10)
    goto LABEL_12;
LABEL_11:
  v10 = objc_msgSend(MEMORY[0x24BDBCF48], "fileURLWithFileSystemRepresentation:isDirectory:relativeToURL:", "/System/Library/PrivateFrameworks/RenderBox.framework", 1, 0);
  if (v10)
  {
LABEL_12:
    result = objc_msgSend(MEMORY[0x24BDD1488], "bundleWithURL:", v10);
    if (result)
      return result;
  }
  result = objc_msgSend(MEMORY[0x24BDD1488], "bundleWithIdentifier:", CFSTR("com.apple.RenderBox"));
  if (!result)
    RB::precondition_failure((RB *)"unable to find bundle: com.apple.RenderBox", v12);
  return result;
}

void ensure_drawable_locked(RBLayer *a1)
{
  unsigned int v2;
  RB::Drawable *v3;
  unsigned int *v4;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  RBLayer *v8;

  if (!*((_QWORD *)a1 + 6))
  {
    v2 = -[RBLayer maxDrawableCount](a1, "maxDrawableCount");
    v3 = (RB::Drawable *)operator new();
    RB::Drawable::Drawable(v3, v2);
    v4 = (unsigned int *)*((_QWORD *)a1 + 6);
    *((_QWORD *)a1 + 6) = v3;
    if (v4)
    {
      v5 = v4 + 2;
      do
      {
        v6 = __ldxr(v5);
        v7 = v6 - 1;
      }
      while (__stlxr(v7, v5));
      if (!v7)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v4 + 8))(v4);
      }
    }
    if (*((_QWORD *)a1 + 18))
    {
      if (*((_QWORD *)a1 + 20))
        v8 = a1;
      else
        v8 = 0;
    }
    else
    {
      v8 = 0;
    }
    RB::Drawable::set_delegate(*((_QWORD *)a1 + 6), (uint64_t)v8);
    RB::Drawable::reset_statistics(*((os_unfair_lock_s **)a1 + 6), *((_QWORD *)a1 + 18), *((double *)a1 + 19));
  }
}

void sub_209AFB4EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x1081C40A869C1B6);
  _Unwind_Resume(a1);
}

void RB::Drawable::set_delegate(uint64_t a1, uint64_t a2)
{
  os_unfair_lock_s *v4;

  v4 = (os_unfair_lock_s *)(a1 + 32);
  os_unfair_lock_lock((os_unfair_lock_t)(a1 + 32));
  *(_QWORD *)(a1 + 328) = a2;
  os_unfair_lock_unlock(v4);
}

id RB::Device::noise_texture(RB::Device *this)
{
  id v1;
  void *v3;
  void *v4;
  RB *v5;
  NSObject *v6;
  id v7;
  _QWORD v9[3];
  int64x2_t v10;
  uint64_t v11;

  v1 = (id)*((_QWORD *)this + 19);
  if (!v1)
  {
    v3 = (void *)objc_msgSend(MEMORY[0x24BDDD740], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 80, 32, 32, 0);
    objc_msgSend(v3, "setUsage:", 1);
    objc_msgSend(v3, "setStorageMode:", 0);
    v4 = (void *)objc_msgSend(*((id *)this + 3), "newTextureWithDescriptor:", v3);

    *((_QWORD *)this + 19) = v4;
    if (v4)
    {
      memset(v9, 0, sizeof(v9));
      v10 = vdupq_n_s64(0x20uLL);
      v11 = 1;
      return (id)*((_QWORD *)this + 19);
    }
    else
    {
      v6 = RB::error_log(v5);
      if (os_log_type_enabled(v6, OS_LOG_TYPE_FAULT))
        RB::Device::noise_texture(v6);
      v1 = *(id *)(RB::Device::invalid_texture(this) + 16);
      v7 = (id)*((_QWORD *)this + 19);
      if (v7 != v1)
      {

        v1 = v1;
        *((_QWORD *)this + 19) = v1;
      }
    }
  }
  return v1;
}

void RB::SurfacePool::collect(os_unfair_lock_s *this)
{
  double v2;
  unint64_t v3;
  unint64_t v4;
  double v5;
  os_unfair_lock_s *v6;
  char *v7;
  _QWORD *v8;
  double v9;
  double v10;
  uint64_t v11;
  os_unfair_lock_s *v12;
  unint64_t v13;
  double *p_os_unfair_lock_opaque;
  uint64_t v15;
  os_unfair_lock_s *v16;
  const void *v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  size_t v29;
  size_t v30;
  _BYTE *v31;
  void *v32;
  _BYTE *v33;
  uint64_t v34;
  size_t v35;
  _QWORD *v36;
  size_t v37;
  const void *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  uint64_t v44;
  size_t v45;
  size_t v46;
  _BYTE *v47;
  void *v48;
  _BYTE *v49;
  uint64_t v50;
  RB *LastUpdateHostTime;
  double v52;
  size_t v53;
  _BYTE *v54;
  size_t v55;
  const void *v56;
  unint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  unint64_t v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  double v68;
  int v69;
  unsigned int *v70;
  unsigned int v71;
  unsigned int v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  double v76;
  double v77;
  dispatch_time_t v78;
  NSObject *v79;
  _QWORD block[5];
  _BYTE __dst[64];
  void *v82;
  size_t v83;
  unint64_t v84;
  uint64_t v85;

  v85 = *MEMORY[0x24BDAC8D0];
  v2 = CACurrentMediaTime();
  v82 = 0;
  v83 = 0;
  v84 = 8;
  os_unfair_lock_lock(this);
  v3 = *(_QWORD *)&this[20]._os_unfair_lock_opaque;
  if (v3)
  {
    v4 = 0;
    v5 = INFINITY;
    do
    {
      if (*(_QWORD *)&this[18]._os_unfair_lock_opaque)
        v6 = *(os_unfair_lock_s **)&this[18]._os_unfair_lock_opaque;
      else
        v6 = this + 10;
      v7 = (char *)&v6[4 * v4];
      v9 = *((double *)v7 + 1);
      v8 = v7 + 8;
      v10 = v9;
      if (v2 >= v9)
      {
        v11 = *(_QWORD *)&v6[4 * v4]._os_unfair_lock_opaque;
        *(_QWORD *)&v6[4 * v4]._os_unfair_lock_opaque = 0;
        v12 = *(os_unfair_lock_s **)&this[18]._os_unfair_lock_opaque;
        if (!v12)
          v12 = this + 10;
        v13 = v3 - 1;
        p_os_unfair_lock_opaque = (double *)&v12[4 * v13]._os_unfair_lock_opaque;
        v15 = 4 * v13;
        *(double *)&v6[4 * v4]._os_unfair_lock_opaque = *p_os_unfair_lock_opaque;
        *p_os_unfair_lock_opaque = 0.0;
        *v8 = *((_QWORD *)p_os_unfair_lock_opaque + 1);
        p_os_unfair_lock_opaque[1] = v10;
        *(_QWORD *)&this[20]._os_unfair_lock_opaque = v13;
        v16 = *(os_unfair_lock_s **)&this[18]._os_unfair_lock_opaque;
        if (!v16)
          v16 = this + 10;
        v17 = *(const void **)&v16[v15]._os_unfair_lock_opaque;
        if (v17)
          CFRelease(v17);
        v18 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
        if (v18)
        {
          v19 = *(uint64_t **)&this[4]._os_unfair_lock_opaque;
          v20 = &v19[v18];
          do
          {
            v21 = *v19;
            v22 = *(_QWORD *)(*v19 + 104);
            if (v22)
            {
              v23 = 0;
              do
              {
                v24 = *(_QWORD *)(v21 + 96);
                if (!v24)
                  v24 = v21 + 64;
                v25 = (_QWORD *)(v24 + 16 * v23);
                if (*v25 == v11)
                {
                  v26 = v24 + 16 * v22;
                  v27 = v25[1];
                  v28 = *(_QWORD *)(v26 - 8);
                  *v25 = *(_QWORD *)(v26 - 16);
                  v25[1] = v28;
                  *(_QWORD *)(v26 - 16) = v11;
                  *(_QWORD *)(v26 - 8) = v27;
                  v21 = *v19;
                  v22 = *(_QWORD *)(*v19 + 104) - 1;
                  *(_QWORD *)(*v19 + 104) = v22;
                }
                else
                {
                  ++v23;
                }
              }
              while (v23 < v22);
            }
            ++v19;
          }
          while (v19 != v20);
        }
        v29 = v83;
        v30 = v83 + 1;
        if (v84 < v83 + 1)
        {
          RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v30);
          v29 = v83;
          v30 = v83 + 1;
        }
        v31 = v82;
        if (!v82)
          v31 = __dst;
        v83 = v30;
        *(_QWORD *)&v31[8 * v29] = v11;
        v3 = *(_QWORD *)&this[20]._os_unfair_lock_opaque;
      }
      else
      {
        if (v10 < v5)
          v5 = v10;
        ++v4;
      }
    }
    while (v4 < v3);
  }
  else
  {
    v5 = INFINITY;
  }
  os_unfair_lock_unlock(this);
  v32 = v82;
  if (v82)
    v33 = v82;
  else
    v33 = __dst;
  if (v83)
  {
    v34 = 8 * v83;
    do
    {
      CAImageQueueInvalidate();
      v33 += 8;
      v34 -= 8;
    }
    while (v34);
    v32 = v82;
    v35 = v83;
    v36 = v82 ? v82 : __dst;
    if (v83)
    {
      v37 = 0;
      do
      {
        v38 = (const void *)v36[v37];
        if (v38)
        {
          CFRelease(v38);
          v35 = v83;
        }
        ++v37;
      }
      while (v37 < v35);
      v32 = v82;
    }
  }
  if (v32)
    free(v32);
  v82 = 0;
  v83 = 0;
  v84 = 8;
  os_unfair_lock_lock(this);
  v39 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v39)
  {
    v40 = *(_QWORD *)&this[4]._os_unfair_lock_opaque;
    v41 = v40 + 8 * v39;
    do
    {
      v42 = *(_QWORD *)(*(_QWORD *)v40 + 120);
      if (v42 >= 2)
      {
        v43 = v82;
        if (!v82)
          v43 = __dst;
        if (v83)
        {
          v44 = 8 * v83;
          while (*v43 != v42)
          {
            ++v43;
            v44 -= 8;
            if (!v44)
              goto LABEL_61;
          }
          if (v2 - *(double *)(*(_QWORD *)v40 + 128) < 1.0 && v2 + 0.1 < v5)
            v5 = v2 + 0.1;
        }
        else
        {
LABEL_61:
          CFRetain(*(CFTypeRef *)(*(_QWORD *)v40 + 120));
          v45 = v83;
          v46 = v83 + 1;
          if (v84 < v83 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(__dst, v46);
            v45 = v83;
            v46 = v83 + 1;
          }
          v47 = v82;
          if (!v82)
            v47 = __dst;
          *(_QWORD *)&v47[8 * v45] = v42;
          v83 = v46;
        }
      }
      v40 += 8;
    }
    while (v40 != v41);
  }
  os_unfair_lock_unlock(this);
  v48 = v82;
  if (v82)
    v49 = v82;
  else
    v49 = __dst;
  if (v83)
  {
    v50 = 8 * v83;
    do
    {
      LastUpdateHostTime = (RB *)CAImageQueueGetLastUpdateHostTime();
      v52 = CACurrentMediaTime();
      if (v52 - RB::time_seconds(LastUpdateHostTime) > 1.0)
        CAImageQueueConsumeUnconsumedInRange();
      CAImageQueueCollect();
      v49 += 8;
      v50 -= 8;
    }
    while (v50);
    v48 = v82;
    v53 = v83;
    if (v82)
      v54 = v82;
    else
      v54 = __dst;
    if (v83)
    {
      v55 = 0;
      do
      {
        v56 = *(const void **)&v54[8 * v55];
        if (v56)
        {
          CFRelease(v56);
          v53 = v83;
        }
        ++v55;
      }
      while (v55 < v53);
      v48 = v82;
    }
  }
  if (v48)
    free(v48);
  os_unfair_lock_lock(this);
  v57 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
  if (v57)
  {
    v58 = 0;
    v59 = *(uint64_t **)&this[4]._os_unfair_lock_opaque;
    v60 = 8 * v57;
    do
    {
      v61 = *v59++;
      if (*(_QWORD *)(v61 + 120))
        ++v58;
      v60 -= 8;
    }
    while (v60);
    v62 = 0;
    v63 = 3 * v58;
    v64 = 6 * v58;
    do
    {
      v65 = *(_QWORD *)&this[4]._os_unfair_lock_opaque + 8 * v62;
      v66 = *(_QWORD *)v65;
      if (!*(_QWORD *)(*(_QWORD *)v65 + 120))
      {
        v67 = v57 - v58;
        if (v63 >= v67)
          v68 = 10.0;
        else
          v68 = 0.2;
        if (v64 < v67)
          v68 = 0.0;
        if (*(double *)(v66 + 128) + v68 + 0.01 <= v2)
        {
          v70 = (unsigned int *)(v66 + 8);
          do
          {
            v71 = __ldxr(v70);
            v72 = v71 - 1;
          }
          while (__stlxr(v72, v70));
          if (!v72)
          {
            __dmb(9u);
            (*(void (**)(uint64_t))(*(_QWORD *)v66 + 8))(v66);
          }
          v73 = *(_QWORD *)&this[6]._os_unfair_lock_opaque - 1;
          *(_QWORD *)&this[6]._os_unfair_lock_opaque = v73;
          v74 = v73 - v62;
          if (v74)
            memmove((void *)v65, (const void *)(v65 + 8), 8 * v74);
          goto LABEL_99;
        }
        if (!*(_BYTE *)(v66 + 140))
          goto LABEL_121;
        if (!IOSurfaceIsInUse(*(IOSurfaceRef *)(v66 + 48)))
        {
          *(_BYTE *)(v66 + 140) = 0;
          v66 = *(_QWORD *)v65;
LABEL_121:
          if (!*(_BYTE *)(v66 + 45))
          {
            RB::Surface::set_volatile(v66, 1u);
            v66 = *(_QWORD *)v65;
          }
          v75 = *(_QWORD *)&this[6]._os_unfair_lock_opaque - v58;
          if (v63 >= v75)
            v76 = 10.0;
          else
            v76 = 0.2;
          if (v64 < v75)
            v76 = 0.0;
          if (v76 + *(double *)(v66 + 128) < v5)
            v5 = v76 + *(double *)(v66 + 128);
          goto LABEL_98;
        }
        v69 = *(unsigned __int8 *)(v66 + 140);
        v66 = *(_QWORD *)v65;
        if (!v69)
          goto LABEL_121;
        if (v2 - *(double *)(v66 + 128) < 1.0 && v2 + 0.1 < v5)
          v5 = v2 + 0.1;
      }
LABEL_98:
      ++v62;
LABEL_99:
      v57 = *(_QWORD *)&this[6]._os_unfair_lock_opaque;
    }
    while (v62 < v57);
  }
  if (v5 < *(double *)&this[30]._os_unfair_lock_opaque)
  {
    v77 = 100000000.0;
    if (v5 - v2 >= 0.1)
      v77 = (v5 - v2) * 1000000000.0;
    v78 = dispatch_time(0, (uint64_t)v77);
    v79 = *(NSObject **)&this[2]._os_unfair_lock_opaque;
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZN2RB11SurfacePool7collectEv_block_invoke;
    block[3] = &__block_descriptor_40_e5_v8__0l;
    block[4] = this;
    dispatch_after(v78, v79, block);
    *(double *)&this[30]._os_unfair_lock_opaque = v5;
  }
  os_unfair_lock_unlock(this);
}

void sub_209AFBCB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  os_unfair_lock_s *v24;
  const void *v25;

  CFRelease(v25);
  os_unfair_lock_unlock(v24);
  RB::vector<RB::cf_ptr<_CAImageQueue *>,8ul,unsigned long>::~vector(&a15);
  _Unwind_Resume(a1);
}

void __destroy_helper_block_e16_64c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE72c30_ZTSN2RB8objc_ptrIP8RBDeviceEE88c29_ZTSN2RB8objc_ptrIP7RBLayerEE96c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE112c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v2 = *(unsigned int **)(a1 + 96);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }

}

id __copy_helper_block_e16_64c40_ZTSN2RB8objc_ptrIP17RBImageQueueLayerEE72c30_ZTSN2RB8objc_ptrIP8RBDeviceEE88c29_ZTSN2RB8objc_ptrIP7RBLayerEE96c40_ZTSN2RB14refcounted_ptrINS_8DrawableEEE112c36_ZTSN2RB8objc_ptrIP13RBDisplayListEE(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int *v5;
  unsigned int v6;
  id result;

  a1[8] = *(id *)(a2 + 64);
  a1[9] = *(id *)(a2 + 72);
  a1[11] = *(id *)(a2 + 88);
  v4 = *(_QWORD *)(a2 + 96);
  if (v4)
  {
    v5 = (unsigned int *)(v4 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  a1[12] = v4;
  result = *(id *)(a2 + 112);
  a1[14] = result;
  return result;
}

void sub_209AFBE38(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v3;

  v3 = *(_QWORD *)(v1 + 96);
  if (v3)
    -[RBDrawable renderWithFlags:items:count:displayList:].cold.3(v3);

  _Unwind_Resume(a1);
}

uint64_t ___ZN2RB11SurfacePool7collectEv_block_invoke(uint64_t a1)
{
  RB::SurfacePool *v1;

  v1 = *(RB::SurfacePool **)(a1 + 32);
  *((_QWORD *)v1 + 15) = 0x7FF0000000000000;
  return RB::SurfacePool::collect(v1);
}

void _ZZZ38__RBLayer_displayWithBounds_callback__EUb_EN3__08__invokeIPvEEDajyT_(uint64_t ReleasedImageInfo, uint64_t a2, uint64_t a3)
{
  int v5;
  unsigned __int8 v6;
  const char *v7;
  const char *v8;
  os_unfair_lock_s *v9;
  const char *v10;
  unsigned int v11;

  v5 = ReleasedImageInfo;
  v6 = atomic_load((unsigned __int8 *)&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
  if ((v6 & 1) == 0)
  {
    ReleasedImageInfo = __cxa_guard_acquire(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
    if ((_DWORD)ReleasedImageInfo)
    {
      v11 = (unsigned __int16)RB::debug_BOOL((RB *)"RB_PRINT_FRAME_STATS", v10);
      if (v11 <= 0x100)
        LOBYTE(v11) = 0;
      _ZZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats = v11 != 0;
      __cxa_guard_release(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
    }
  }
  if (v5)
  {
    if (_ZZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats)
    {
      ReleasedImageInfo = CAImageQueueGetReleasedImageInfo();
      if (ReleasedImageInfo)
      {
        if (*(_BYTE *)(ReleasedImageInfo + 16))
          v7 = ", flushed";
        else
          v7 = "";
        if (*(_BYTE *)(ReleasedImageInfo + 17))
          v8 = ", consumed";
        else
          v8 = "";
        ReleasedImageInfo = printf("RBLayer frame: count %u (%.1f F), id %llx%s%s\n", *(_DWORD *)ReleasedImageInfo, (double)*(unsigned int *)ReleasedImageInfo * (60.0 * *(double *)(ReleasedImageInfo + 32)), a2, v7, v8);
      }
    }
  }
  v9 = (os_unfair_lock_s *)RB::SurfacePool::shared((RB::SurfacePool *)ReleasedImageInfo);
  RB::SurfacePool::dealloc(v9, *(RB::Surface **)a3, *(_CAImageQueue **)(a3 + 8));
  JUMPOUT(0x20BD16544);
}

void sub_209AFBFB4(_Unwind_Exception *a1)
{
  __cxa_guard_abort(&_ZGVZZZ38__RBLayer_displayWithBounds_callback__EUb_ENK3__0clIPvEEDajyT_E9log_stats);
  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::make_single_element_path<RBPathMakeRoundedRect::RoundedRectArgs>(RBPathMakeRoundedRect::RoundedRectArgs &&,CGAffineTransform const*)::{lambda(void const*,void *,BOOL (*)(void const*,RBPathElement,double const*,void const))#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v4;
  uint64_t v5;

  if (*(_BYTE *)(a1 + 72))
    v4 = a1 + 80;
  else
    v4 = 0;
  if (*(_BYTE *)(a1 + 64))
    v5 = 9;
  else
    v5 = 8;
  return a3(a2, v5, a1 + 16, v4);
}

void RB::Coverage::Primitive::add_path(float32x2_t *this, CGContextRef *a2, double a3, double a4, double a5, double a6, double a7, int32x4_t a8)
{
  int v8;
  float v11;
  float32x2_t v17;
  float32x2_t v18;
  CGContext *v19;
  int v20;
  CGLineCap v21;
  float32x2_t v22;
  float32x4_t v23;
  int32x4_t v24;
  float32x4_t v25;
  _BOOL4 v26;
  uint64_t RoundedRect;
  uint64_t v28;
  uint64_t v29;
  CGContext *v30;
  double v31;
  double v32;
  double v33;
  double v34;
  CGContext *v35;
  uint64_t v36;
  const CGPath *v37;
  CGContext *v38;
  const CGPath *v39;
  CGRect v40;

  v8 = this[5].u8[4];
  v11 = this[4].f32[0];
  __asm { FMOV            V2.2S, #1.0 }
  _D2.f32[0] = v11;
  v17 = vmul_f32(*this, _D2);
  v18 = vmul_f32(this[1], _D2);
  switch(this[5].i8[4])
  {
    case 0:
      v30 = *a2;
      v31 = *MEMORY[0x24BDBF070];
      v32 = *(double *)(MEMORY[0x24BDBF070] + 8);
      v33 = *(double *)(MEMORY[0x24BDBF070] + 16);
      v34 = *(double *)(MEMORY[0x24BDBF070] + 24);
      goto LABEL_15;
    case 1:
      v35 = *a2;
      *(CGRect *)&v31 = CGContextGetClipBoundingBox(*a2);
      v30 = v35;
      goto LABEL_15;
    case 2:
      goto LABEL_12;
    case 3:
    case 4:
      v23 = *(float32x4_t *)this[2].f32;
      v24 = vceqzq_f32(v23);
      if ((vminvq_u32((uint32x4_t)v24) & 0x80000000) != 0)
      {
LABEL_12:
        v30 = *a2;
        v31 = v17.f32[0];
        v32 = v17.f32[1];
        v33 = v18.f32[0];
        v34 = v18.f32[1];
LABEL_15:
        CGContextAddRect(v30, *(CGRect *)&v31);
      }
      else
      {
        v24.i32[0] = 3;
        a8.i32[0] = this[5].u8[4];
        v25 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vceqq_s32(a8, v24)), 0), (int8x16_t)vmulq_f32(v23, (float32x4_t)vdupq_n_s32(0x3F48C8C9u)), (int8x16_t)v23);
        v26 = v8 != 3;
        if (v11 != 1.0
          || (vminvq_u32((uint32x4_t)vceqq_f32(v25, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v25.f32, 0))) & 0x80000000) != 0)
        {
          RoundedRect = RBPathMakeRoundedRect(v26, 0, v17.f32[0], v17.f32[1], v18.f32[0], v18.f32[1], (float)(v11 * v25.f32[0]), v25.f32[0]);
          v29 = v28;
          RBPathRelease(0, 0x209BD98A8);
        }
        else
        {
          RoundedRect = RBPathMakeUnevenRoundedRect(v26, 0, v17.f32[0], v17.f32[1], v18.f32[0], v18.f32[1], v25.f32[0], v25.f32[1], v25.f32[2], v25.f32[3]);
          v29 = v36;
          RBPathRelease(0, 0x209BD98A8);
        }
        v37 = (const CGPath *)RoundedRect;
        v38 = *a2;
        v39 = RBPathCopyCGPath(v37, v29);
        CGContextAddPath(v38, v39);
        if (v39)
          CFRelease(v39);
        RBPathRelease((uint64_t)v37, v29);
      }
      break;
    case 5:
      v40.origin.x = v17.f32[0];
      v40.origin.y = v17.f32[1];
      v40.size.width = v18.f32[0];
      v40.size.height = v18.f32[1];
      CGContextAddEllipseInRect(*a2, v40);
      break;
    case 6:
    case 7:
    case 8:
      v19 = *a2;
      if (v8 == 7)
        v20 = 1;
      else
        v20 = 2;
      if (v8 == 6)
        v21 = kCGLineCapButt;
      else
        v21 = v20;
      CGContextSetLineCap(v19, v21);
      CGContextMoveToPoint(*a2, COERCE_FLOAT(*this), COERCE_FLOAT(HIDWORD(*(unint64_t *)this)));
      v22 = vadd_f32(this[1], *this);
      CGContextAddLineToPoint(*a2, v22.f32[0], v22.f32[1]);
      break;
    case 9:
    case 0xA:
    case 0xB:
      abort();
    default:
      return;
  }
}

void sub_209AFC2B8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  RBPathRelease(v1, v2);
  _Unwind_Resume(a1);
}

void RB::Coverage::Primitive::fill(float32x2_t *this, RB::CGContext *a2, const RB::Fill::Color *a3, double _D0)
{
  CGContext *v23;
  CGContext *v24;
  CGImage *v26;
  CGFloat v39;
  CGFloat v40;
  CGFloat v41;
  CGFloat v42;
  CGPathDrawingMode v55;
  int v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  int32x4_t v78;
  float32x2_t v80;
  float32x2_t v81;
  CGImageRef v82;
  float v83;
  float v84;
  float v85;
  float v86;
  CGRect ClipBoundingBox;
  CGRect v88;
  CGRect v89;

  if (this[5].i8[4])
  {
    if (this[5].i8[4] == 1)
    {
      if (*((_BYTE *)a2 + 121))
        _ZF = *((_BYTE *)a3 + 9) == 0;
      else
        _ZF = 1;
      if (!_ZF && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
        goto LABEL_12;
      _H0 = *((_WORD *)a2 + 56);
      _H1 = *(_WORD *)a3;
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)&_D0 != _S1)
        goto LABEL_12;
      _H0 = *((_WORD *)a2 + 57);
      _H1 = *((_WORD *)a3 + 1);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)&_D0 != _S1)
        goto LABEL_12;
      _H0 = *((_WORD *)a2 + 58);
      _H1 = *((_WORD *)a3 + 2);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)&_D0 != _S1)
        goto LABEL_12;
      _H0 = *((_WORD *)a2 + 59);
      _H1 = *((_WORD *)a3 + 3);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)&_D0 != _S1)
LABEL_12:
        RB::CGContext::set_fill_color_slow(a2, a3, *(uint16x4_t *)&_D0);
      if ((this[5].i8[6] & 2) != 0)
        CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
      v23 = *(CGContext **)a2;
      ClipBoundingBox = CGContextGetClipBoundingBox((CGContextRef)*(_QWORD *)a2);
      v24 = v23;
      goto LABEL_16;
    }
    if ((this[5].i8[6] & 5) == 0)
    {
      LODWORD(_D0) = this[4].i32[1];
      if (*(float *)&_D0 == 0.0)
      {
        if (*((_BYTE *)a2 + 121)
          && *((_BYTE *)a3 + 9)
          && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
        {
          goto LABEL_43;
        }
        _H0 = *((_WORD *)a2 + 56);
        _H1 = *(_WORD *)a3;
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        if (*(float *)&_D0 != _S1)
          goto LABEL_43;
        _H0 = *((_WORD *)a2 + 57);
        _H1 = *((_WORD *)a3 + 1);
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        if (*(float *)&_D0 != _S1)
          goto LABEL_43;
        _H0 = *((_WORD *)a2 + 58);
        _H1 = *((_WORD *)a3 + 2);
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        if (*(float *)&_D0 != _S1)
          goto LABEL_43;
        _H0 = *((_WORD *)a2 + 59);
        _H1 = *((_WORD *)a3 + 3);
        __asm
        {
          FCVT            S1, H1
          FCVT            S0, H0
        }
        if (*(float *)&_D0 != _S1)
LABEL_43:
          RB::CGContext::set_fill_color_slow(a2, a3, *(uint16x4_t *)&_D0);
        v55 = kCGPathFill;
      }
      else
      {
        if (*((_BYTE *)a2 + 131)
          && *((_BYTE *)a3 + 9)
          && *((unsigned __int8 *)a2 + 130) != *((unsigned __int8 *)a3 + 8))
        {
          goto LABEL_52;
        }
        _H1 = *((_WORD *)a2 + 61);
        _H2 = *(_WORD *)a3;
        __asm
        {
          FCVT            S2, H2
          FCVT            S1, H1
        }
        if (_S1 != _S2)
          goto LABEL_52;
        _H1 = *((_WORD *)a2 + 62);
        _H2 = *((_WORD *)a3 + 1);
        __asm
        {
          FCVT            S2, H2
          FCVT            S1, H1
        }
        if (_S1 != _S2)
          goto LABEL_52;
        _H1 = *((_WORD *)a2 + 63);
        _H2 = *((_WORD *)a3 + 2);
        __asm
        {
          FCVT            S2, H2
          FCVT            S1, H1
        }
        if (_S1 != _S2)
          goto LABEL_52;
        _H1 = *((_WORD *)a2 + 64);
        _H2 = *((_WORD *)a3 + 3);
        __asm
        {
          FCVT            S2, H2
          FCVT            S1, H1
        }
        if (_S1 != _S2)
        {
LABEL_52:
          RB::CGContext::set_stroke_color_slow(a2, a3, *(uint16x4_t *)&_D0);
          LODWORD(_D0) = this[4].i32[1];
        }
        v55 = kCGPathStroke;
      }
      v72 = rb_clip_mode(this[5].u8[5]);
      if (*((unsigned __int8 *)a2 + 140) != v72)
        RB::CGContext::set_aliasing_mode_slow((uint64_t)a2, v72);
      if (this[5].i8[4] != 2)
      {
        RB::Coverage::Primitive::add_path(this, (CGContextRef *)a2, v73, v74, v75, v76, v77, v78);
        if ((this[5].i8[6] & 2) != 0)
          CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
        CGContextDrawPath(*(CGContextRef *)a2, v55);
        goto LABEL_17;
      }
      if ((this[5].i8[6] & 2) != 0)
        CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
      __asm { FMOV            V0.2S, #1.0 }
      _D0.i32[0] = this[4].i32[0];
      v80 = vmul_f32(*this, _D0);
      v81 = vmul_f32(this[1], _D0);
      v24 = *(CGContext **)a2;
      ClipBoundingBox.origin.x = v80.f32[0];
      ClipBoundingBox.origin.y = v80.f32[1];
      ClipBoundingBox.size.width = v81.f32[0];
      ClipBoundingBox.size.height = v81.f32[1];
      if (this[4].f32[1] != 0.0)
      {
        CGContextStrokeRect(v24, ClipBoundingBox);
LABEL_17:
        if ((this[5].i8[6] & 2) != 0)
          CGContextEndTransparencyLayer(*(CGContextRef *)a2);
        return;
      }
LABEL_16:
      CGContextFillRect(v24, ClipBoundingBox);
      goto LABEL_17;
    }
    RB::Coverage::Primitive::make_image_mask(this, a2, &v82);
    v26 = v82;
    if (v82)
    {
      if (*((_BYTE *)a2 + 121) && *((_BYTE *)a3 + 9) && *((unsigned __int8 *)a2 + 120) != *((unsigned __int8 *)a3 + 8))
        goto LABEL_28;
      _H0 = *((_WORD *)a2 + 56);
      _H1 = *(_WORD *)a3;
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)_D0.i32 != _S1)
        goto LABEL_28;
      _H0 = *((_WORD *)a2 + 57);
      _H1 = *((_WORD *)a3 + 1);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)_D0.i32 != _S1)
        goto LABEL_28;
      _H0 = *((_WORD *)a2 + 58);
      _H1 = *((_WORD *)a3 + 2);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)_D0.i32 != _S1)
        goto LABEL_28;
      _H0 = *((_WORD *)a2 + 59);
      _H1 = *((_WORD *)a3 + 3);
      __asm
      {
        FCVT            S1, H1
        FCVT            S0, H0
      }
      if (*(float *)_D0.i32 != _S1)
LABEL_28:
        RB::CGContext::set_fill_color_slow(a2, a3, _D0);
      if ((this[5].i8[6] & 2) != 0)
        CGContextBeginTransparencyLayer(*(CGContextRef *)a2, 0);
      CGContextSaveGState(*(CGContextRef *)a2);
      v39 = v83;
      v40 = v84;
      v41 = v85;
      v42 = v86;
      v88.origin.x = v83;
      v88.origin.y = v84;
      v88.size.width = v85;
      v88.size.height = v86;
      CGContextClipToMask(*(CGContextRef *)a2, v88, v26);
      v89.origin.x = v39;
      v89.origin.y = v40;
      v89.size.width = v41;
      v89.size.height = v42;
      CGContextFillRect(*(CGContextRef *)a2, v89);
      CGContextRestoreGState(*(CGContextRef *)a2);
      if ((this[5].i8[6] & 2) != 0)
        CGContextEndTransparencyLayer(*(CGContextRef *)a2);
      CFRelease(v26);
    }
  }
}

void sub_209AFC758(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Fill::ImageData::image_filter(uint64_t a1, float64x2_t *a2, int32x2_t a3)
{
  uint64_t v3;
  uint32x2_t v5;
  unsigned __int8 *v6;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  int64x2_t v13;
  int32x2_t v14;
  int64x2_t v15;
  int64x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v23;
  uint32x2_t v24;
  float32x2_t v26;
  uint32x2_t v27;
  double v28;
  double v30;
  BOOL v31;
  float64x2_t v33[3];

  v3 = HIBYTE(*(unsigned __int16 *)(a1 + 78)) & 0xF;
  if (v3 > 9)
    return 0;
  if (!a2 || *(_WORD *)(a1 + 78) == 4)
  {
    return *v6;
  }
  v5 = (uint32x2_t)vcgt_s32(a3, (int32x2_t)0x100000001);
  if ((vpmin_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    v8 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 44));
    v9 = vcvtq_f64_f32(*(float32x2_t *)(a1 + 56));
    v33[0] = vcvtq_f64_f32(*(float32x2_t *)(a1 + 32));
    v33[1] = v8;
    v33[2] = v9;
    v10.f64[0] = RB::operator*(v33, a2);
    if (!(_DWORD)v3)
      goto LABEL_13;
    if (*(unsigned __int8 *)(a1 + 78) > 2u)
      goto LABEL_13;
    v13 = vceqq_f64(vrndmq_f64(v12), v12);
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v13, 1), (int8x16_t)v13).u64[0] & 0x8000000000000000) == 0)
      goto LABEL_13;
    if (v10.f64[1] == 0.0 && v11.f64[0] == 0.0)
    {
      v14 = a3;
      v28 = fabs((double)a3.i32[1]);
      if (v10.f64[0] != fabs((double)a3.i32[0]) || v11.f64[1] != v28)
        goto LABEL_14;
    }
    else
    {
      if (v10.f64[0] != 0.0)
      {
LABEL_13:
        v14 = a3;
        goto LABEL_14;
      }
      v14 = a3;
      if (v11.f64[1] != 0.0
        || ((v30 = fabs((double)a3.i32[0]), v10.f64[1] == fabs((double)a3.i32[1]))
          ? (v31 = v11.f64[0] == v30)
          : (v31 = 0),
            !v31))
      {
LABEL_14:
        v15 = (int64x2_t)vmulq_f64(v10, v10);
        v16 = (int64x2_t)vmulq_f64(v11, v11);
        v17 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v15, v16), (float64x2_t)vzip2q_s64(v15, v16)));
        v18 = vcvt_f32_s32(v14);
        __asm { FMOV            V2.2S, #0.75 }
        v23 = vmul_f32(v18, _D2);
        v3 = v3;
        v24 = (uint32x2_t)vcgt_f32(vmul_f32(v23, v23), v17);
        if ((vpmax_u32(v24, v24).u32[0] & 0x80000000) != 0)
        {
          return *v6;
        }
        __asm { FMOV            V2.2S, #1.25 }
        v26 = vmul_f32(v18, _D2);
        v27 = (uint32x2_t)vcgt_f32(vmul_f32(v26, v26), v17);
        if ((vpmax_u32(v27, v27).u32[0] & 0x80000000) != 0)
        {
          return *v6;
        }
        goto LABEL_6;
      }
    }
    LODWORD(v3) = 0;
    goto LABEL_14;
  }
LABEL_6:
  return *v6;
}

uint64_t RB::Fill::Image<RB::ImageTexture>::set_image(uint64_t a1, float32x2_t *a2, uint64_t ***a3, float64x2_t *a4, float a5)
{
  uint64_t v10;
  uint64_t v11;
  uint64_t result;
  int v13;

  v10 = a1 + 16;
  v11 = RB::ImageTexture::texture((CGImage **)a1, *a3, (const RB::Fill::ImageData *)(a1 + 16), a4, 0);
  result = RB::Fill::set_image(a2, (uint64_t)a3, v11, a4, v10, a5);
  if (a5 == 1.0)
    v13 = *(unsigned __int8 *)(a1 + 12) << 8;
  else
    v13 = 0;
  a2[10].i32[0] = a2[10].i32[0] & 0xFFFFFEFF | v13;
  return result;
}

uint64_t RB::TextureCache::find_entry(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v2;
  uint64_t result;
  unsigned __int16 *v5;
  unsigned __int16 *v6;
  int v7;
  int v8;
  unsigned int v9;

  v2 = *(unsigned int *)(a1 + 56);
  if (!(_DWORD)v2)
    return 0xFFFFFFFFLL;
  result = 0;
  v5 = (unsigned __int16 *)(a1 + 32);
  v6 = *(unsigned __int16 **)(a1 + 48);
  if (!v6)
    v6 = v5;
  v7 = a2[3];
  while (1)
  {
    if (*((unsigned __int8 *)v6 + 2) == a2[2])
    {
      v8 = *((unsigned __int8 *)v6 + 3);
      if (((v7 ^ v8) & 4) == 0 && ((v8 & 2) != 0 || (v7 & 2) == 0))
      {
        if ((v7 & 8) != 0)
        {
          LOBYTE(v9) = *(_BYTE *)(*((_QWORD *)v6 + 1) + 80);
        }
        else
        {
          v9 = *v6;
          if (v9 < 0x100)
            return result;
        }
        if (!a2[1] || *a2 == v9)
          break;
      }
    }
    v6 += 8;
    if (v2 == ++result)
      return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t RB::ImageTexture::texture(CGImage **this, uint64_t **a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  CGImage *v6;
  uint64_t result;

  v6 = *this;
  if (!*this)
    return 0;
  switch(*((_DWORD *)this + 2))
  {
    case 0:
      result = (uint64_t)RBGetCachedImageTexture(a2, v6, a3, a4, a5);
      break;
    case 1:
      result = (uint64_t)RBGetCachedIOSurfaceTexture(a2, v6, a3, a4, a5);
      break;
    case 2:
      result = RBSurfaceGetTexture((uint64_t)*this);
      break;
    case 4:
      result = (uint64_t)RBGetCachedMTLTexture(a2, v6, (uint64_t)a3, a4, a5);
      break;
    default:
      return 0;
  }
  return result;
}

uint64_t RB::ImageTexture::prepare(uint64_t this, uint64_t **a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  CGImage *v6;

  v6 = *(CGImage **)this;
  if (*(_QWORD *)this)
  {
    switch(*(_DWORD *)(this + 8))
    {
      case 0:
        this = RBMakeCachedImageTexture(a2, v6, a3, a4, a5);
        break;
      case 1:
        this = RBMakeCachedIOSurfaceTexture(a2, v6, a3, a4, a5);
        break;
      case 2:
        this = RBSurfacePrepareTexture(*(_QWORD *)this, (RB::Device ***)a2);
        break;
      case 4:
        this = RBMakeCachedMTLTexture((uint64_t *)a2, v6, (uint64_t)a3, a4, a5);
        break;
      default:
        return this;
    }
  }
  return this;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 112, a2, (const RB::Fill::ImageData *)(a1 + 128), *(float64x2_t **)(a1 + 48), 0);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5, unsigned int a6)
{
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  uint64_t v14;
  uint64_t result;
  float64x2_t v20[3];
  _BYTE v21[80];
  float32x2_t v22[10];

  v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v20[0] = *v10;
  v20[1] = v12;
  v20[2] = _Q0;
  v14 = a1 + 64;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 112, v22, (uint64_t ***)a4, v20, *(float *)_Q0.f64);
  result = RB::render_primitive(a4, v20, v14, (uint64_t)v21, a1 + 128, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(_BYTE *)(a4 + 236) = 0;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 125);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::render(float32x2_t *a1, int32x2_t *a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v15;
  __int128 v17;

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(float32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  v14 = 0;
  if ((float32x2_t *)a2[11] != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains(a2 + 12, *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow((uint64_t)a2, v4, v5, v11, &v17, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if ((float64x2_t *)a2[10] != v4)
    goto LABEL_10;
  LODWORD(v15) = a2[16].i32[1];
  if (*(float *)&v15 != _S8 || a2[17].i32[0] != v11)
    goto LABEL_10;
LABEL_11:
  RB::Coverage::Primitive::fill(a1 + 8, (RB::CGContext *)a2, (const RB::Fill::Color *)&a1[14], v15);
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Primitive>::operator()<RB::Fill::Image<RB::ImageTexture>>(__int128 **a1, RB::ImageTexture *a2)
{
  __int128 *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

uint64_t RB::pdf_blend(unsigned int a1)
{
  return (a1 < 0x28) & (0xF3FF005004uLL >> a1);
}

float RB::Coverage::set_plane(uint64_t a1, uint64_t a2)
{
  float result;

  *(_QWORD *)a1 = *(_QWORD *)a2;
  *(_QWORD *)(a1 + 8) = *(_QWORD *)(a2 + 8);
  *(_QWORD *)(a1 + 16) = *(_QWORD *)(a2 + 16);
  result = *(float *)(a2 + 68);
  *(float *)(a1 + 24) = result;
  return result;
}

uint64_t RB::Surface::set_volatile(uint64_t this, uint32_t a2)
{
  char v2;
  uint64_t v3;
  uint32_t oldState;

  if (*(unsigned __int8 *)(this + 45) != a2)
  {
    v2 = a2;
    v3 = this;
    oldState = 0;
    this = IOSurfaceSetPurgeable(*(IOSurfaceRef *)(this + 48), a2, &oldState);
    if (!(_DWORD)this)
      *(_BYTE *)(v3 + 45) = v2;
  }
  return this;
}

uint64_t *RB::Device::texture_cache(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 800), (uint64_t *)(a3 | (unint64_t)(a2 << 32)), 0);
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, __int128 *a3, RB::ImageTexture *a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15;
  uint64_t v16;
  char v18;
  __int16 v19;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;

  v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 208 > a1[3])
    v15 = RB::Heap::alloc_slow(a1, 0xD0uLL, 15);
  else
    a1[2] = v15 + 208;
  v16 = *a5;
  _S0 = *a6;
  v18 = *a7;
  v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F;
  *(_QWORD *)v15 = off_24C2274F0;
  *(_QWORD *)(v15 + 48) = v16;
  v24 = *a3;
  v25 = a3[1];
  *(_OWORD *)(v15 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v15 + 64) = v24;
  *(_OWORD *)(v15 + 80) = v25;
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(v15 + 112), a4, a2);
  v26 = *((_OWORD *)a4 + 2);
  v27 = *((_OWORD *)a4 + 3);
  v28 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(v15 + 192) = *((_OWORD *)a4 + 5);
  v29 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v15 + 160) = v27;
  *(_OWORD *)(v15 + 176) = v28;
  *(_OWORD *)(v15 + 128) = v29;
  *(_OWORD *)(v15 + 144) = v26;
  if (!*(_BYTE *)(v15 + 205))
    *(_WORD *)(v15 + 204) = v19;
  *(_QWORD *)v15 = &off_24C225D50;
  return v15;
}

uint64_t RB::Fill::set_image(float32x2_t *a1, uint64_t a2, uint64_t a3, float64x2_t *a4, uint64_t a5, float a6)
{
  uint64_t v9;
  int v12;
  int v13;
  uint64_t v14;
  int64x2_t v15;
  float64x2_t v20;
  float64x2_t v21;
  __int32 v22;
  float32x2_t v23;
  __int32 v24;
  char v25;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  uint64_t v32;
  int64x2_t v33;
  float64x2_t v35;
  int32x4_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float32x2_t v39;
  float32x2_t v41;
  float32x2_t v42;
  float32x2_t v43;
  float32x2_t v44;
  float32x2_t v45;
  uint32x2_t v46;
  int v47;
  _BOOL4 v49;
  float32x2_t v50;
  float32x2_t v51;
  float32x2_t v52;
  float32x2_t v53;
  float32x2_t v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x2_t v57;
  __int16 v59;
  __int16 v60;
  unsigned int v64;
  int v65;
  float16x4_t v66;
  float16x4_t v67;
  uint16x4_t v69;
  unsigned int v70;
  int v71;
  int v72;
  unsigned int v73;
  MTLPixelFormat v74;
  char v75;
  int v76;
  char v77;
  float32x2_t v78;
  uint64_t result;
  _BYTE v80[32];
  float64x2_t v81;
  float64x2_t v82;
  float64x2_t v83;
  float64x2_t v84;
  _OWORD v85[2];
  int v86;

  _S8 = a6;
  v9 = a3;
  v12 = *(unsigned __int8 *)(a5 + 78);
  if (v12 == 4 && *(float *)(a5 + 40) == 0.0 && *(float *)(a5 + 52) == 0.0)
  {
    if (*(float *)(a5 + 64) == 1.0)
      v12 = 1;
    else
      v12 = 4;
  }
  if (a3)
    v13 = v12;
  else
    v13 = 0;
  if (v13 == 4)
  {
    RB::operator*((float *)(a5 + 32), a4, (uint64_t)v80);
    RB::ProjectionMatrix::invert((RB::ProjectionMatrix *)v80);
    v14 = *(_QWORD *)(a2 + 104);
    v15.i64[0] = (int)v14;
    v15.i64[1] = SHIDWORD(v14);
    __asm { FMOV            V1.2D, #0.5 }
    v20 = vmulq_f64(vcvtq_f64_s64(v15), _Q1);
    v21 = vnegq_f64(v20);
    v84 = v20;
    v21.f64[0] = 0.0;
    v82 = (float64x2_t)*(unint64_t *)&v20.f64[0];
    v83 = v21;
    RB::operator*(&v82, (uint64_t)v80, (uint64_t)v85);
    *(_OWORD *)v80 = v85[0];
    *(_OWORD *)&v80[16] = v85[1];
    LODWORD(v81.f64[0]) = v86;
    v22 = DWORD2(v85[0]);
    v23 = *(float32x2_t *)&v80[12];
    *a1 = *(float32x2_t *)&v85[0];
    a1[1] = v23;
    v24 = *(_DWORD *)&v80[20];
    a1[6].i32[0] = v22;
    a1[6].i32[1] = v24;
    a1[2] = *(float32x2_t *)&v80[24];
    a1[7].i32[0] = LODWORD(v81.f64[0]);
LABEL_12:
    v25 = 0;
    a1[4] = *(float32x2_t *)a5;
    _D0 = (int16x4_t)vadd_f32(*(float32x2_t *)(a5 + 8), *(float32x2_t *)a5);
    a1[5] = (float32x2_t)_D0;
    goto LABEL_28;
  }
  v27 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 44));
  v28 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 56));
  *(float64x2_t *)v80 = vcvtq_f64_f32(*(float32x2_t *)(a5 + 32));
  *(float64x2_t *)&v80[16] = v27;
  v81 = v28;
  v29.f64[0] = RB::operator*((float64x2_t *)v80, a4);
  v82 = v29;
  v83 = v30;
  v84 = v31;
  RB::AffineTransform::invert((RB::AffineTransform *)&v82);
  v32 = *(_QWORD *)(a2 + 104);
  v33.i64[0] = (int)v32;
  v33.i64[1] = SHIDWORD(v32);
  __asm { FMOV            V1.2D, #0.5 }
  v35 = vmulq_f64(vcvtq_f64_s64(v33), _Q1);
  v36.i64[1] = *(_QWORD *)&v83.f64[1];
  v38 = vmulq_n_f64(v82, v35.f64[0]);
  v37 = vmlaq_laneq_f64(vaddq_f64(v38, v84), v83, v35, 1);
  *(float32x2_t *)&v35.f64[0] = vcvt_f32_f64(v38);
  *(float32x2_t *)&v38.f64[0] = vcvt_f32_f64(vmulq_n_f64(v83, -v35.f64[1]));
  *a1 = *(float32x2_t *)&v35.f64[0];
  a1[1] = *(float32x2_t *)&v38.f64[0];
  _D0 = (int16x4_t)vcvt_f32_f64(v37);
  a1[2] = (float32x2_t)_D0;
  if ((v13 - 5) < 2)
  {
    a1[4] = *(float32x2_t *)a5;
    v39 = *(float32x2_t *)(a5 + 16);
    v39.i32[1] = *(_DWORD *)(a5 + 24);
    a1[5] = v39;
    __asm { FMOV            V1.2S, #1.0 }
    a1[6] = vsub_f32(_D1, vadd_f32(*(float32x2_t *)a5, *(float32x2_t *)(a5 + 8)));
    v41 = *(float32x2_t *)(a5 + 20);
    v41.i32[1] = *(_DWORD *)(a5 + 28);
    a1[7] = vsub_f32(*(float32x2_t *)(a5 + 8), v41);
    v42 = *(float32x2_t *)(a5 + 16);
    v42.i32[1] = *(_DWORD *)(a5 + 24);
    v43 = *(float32x2_t *)(a5 + 20);
    v43.i32[1] = *(_DWORD *)(a5 + 28);
    v44 = vadd_f32(v43, v42);
    v45 = vsub_f32(_D1, v44);
    v46 = (uint32x2_t)vceqz_f32(v45);
    v47 = vpmin_u32(v46, v46).u32[0];
    v49 = v13 == 6 && v47 < 0;
    if (v13 == 5 || v49)
    {
      v38.f64[0] = *(float64_t *)(a5 + 8);
      v53 = vsub_f32(*(float32x2_t *)&v38.f64[0], v44);
      v54 = vrecpe_f32(v53);
      v55 = vmul_f32(vrecps_f32(v53, v54), v54);
      *(int32x2_t *)&v38.f64[0] = vcgt_f32((float32x2_t)vdup_n_s32(0x3727C5ACu), vabd_f32(*(float32x2_t *)&v38.f64[0], v44));
      v56 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32((int32x4_t)v38), (int8x8_t)vdup_n_s32(0x47C35000u), (int8x8_t)vmul_f32(v55, vrecps_f32(v53, v55)));
      a1[8] = vmul_f32(v56, v45);
      v57 = *(float32x2_t *)(a5 + 16);
      v57.i32[1] = *(_DWORD *)(a5 + 24);
      _D0 = (int16x4_t)vmul_f32(v56, vmla_f32(vneg_f32(vmla_f32(v57, *(float32x2_t *)a5, v45)), *(float32x2_t *)(a5 + 8), v57));
      a1[9] = (float32x2_t)_D0;
      v25 = 1;
      LOBYTE(v13) = 5;
    }
    else
    {
      v50 = (float32x2_t)vdup_n_s32(0x3727C5ACu);
      *(int32x2_t *)v36.i8 = vcgt_f32(v50, vabs_f32(v45));
      v51 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v36), (int8x8_t)v50, (int8x8_t)v45);
      v52 = vneg_f32(v51);
      _D0 = (int16x4_t)vdiv_f32(_D1, v51);
      a1[8] = v52;
      a1[9] = (float32x2_t)_D0;
      v25 = 1;
      LOBYTE(v13) = 6;
    }
    goto LABEL_28;
  }
  if (v13 == 1)
    goto LABEL_12;
  if (v13 == 2)
  {
    a1[4] = *(float32x2_t *)a5;
    _D0 = *(int16x4_t *)(a5 + 8);
    a1[5] = (float32x2_t)_D0;
  }
  v25 = 1;
LABEL_28:
  __asm { FCVT            H0, S8 }
  v59 = *(_WORD *)(a5 + 70);
  v60 = *(_WORD *)(a5 + 72);
  _H1 = *(_WORD *)(a5 + 74);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  *(float *)_D0.i32 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v64 = *(unsigned __int16 *)(a5 + 76);
  if (v64 < 0x100 || (v65 = *(unsigned __int8 *)(a2 + 124), v65 == v64))
  {
    v66.i16[3] = 15360;
    v66.i32[0] = *(_DWORD *)(a5 + 68);
    v66.i16[2] = *(_WORD *)(a5 + 72);
  }
  else
  {
    LOWORD(v82.f64[0]) = *(_WORD *)(a5 + 68);
    WORD1(v82.f64[0]) = v59;
    WORD2(v82.f64[0]) = v60;
    HIWORD(v82.f64[0]) = _D0.i16[0];
    LOWORD(v82.f64[1]) = v64;
    RB::Fill::Color::convert((uint64_t)&v82, v65, (uint16x4_t)_D0);
    v66.i16[3] = 15360;
    v66.i32[0] = LODWORD(v82.f64[0]);
    v66.i16[2] = WORD2(v82.f64[0]);
    _D0.i32[0] = HIWORD(*(_QWORD *)&v82.f64[0]);
  }
  v67 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D0, 0)), vcvtq_f32_f16(v66)));
  a1[3] = (float32x2_t)v67;
  __asm { FMOV            V1.4S, #1.0 }
  v69 = (uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqq_f32(vcvtq_f32_f16(v67), _Q1)));
  v69.i16[0] = vmaxv_u16(v69);
  v70 = v13 & 7 | ((((unsigned __int32)v69.i32[0] >> 15) & 1) << 6);
  a1[10].i32[0] = v70;
  v71 = v70 | (*(unsigned __int16 *)(a5 + 78) >> 5) & 0x80;
  a1[10].i32[0] = v71;
  v72 = v71 | (*(unsigned __int16 *)(a5 + 78) >> 4) & 0x200;
  a1[10].i32[0] = v72;
  if (v9)
  {
    a1[10].i32[0] = v72 | (16 * (*(_BYTE *)(v9 + 80) & 3));
    v73 = RB::Fill::ImageData::image_filter(a5, a4, *(int32x2_t *)(v9 + 64));
    if (v73 == 4)
    {
      a1[10].i32[0] |= 8u;
    }
    else if (v73 == 3)
    {
      if (*(unsigned __int8 *)(***(_QWORD ***)a2 + 283) < *((unsigned __int8 *)RB::pixel_format_traits(*(_QWORD *)(v9 + 56), v74)+ 9))v73 = 1;
      else
        v73 = 3;
    }
    v76 = RB::image_filter_sampler(v73);
    if (v76 == 5)
      v77 = v25;
    else
      v77 = 1;
    if ((v77 & 1) != 0)
    {
      v75 = v76;
    }
    else
    {
      v78 = a1[5];
      a1[4] = vmul_f32(a1[4], vcvt_f32_s32(*(int32x2_t *)(v9 + 64)));
      a1[5] = vmul_f32(v78, vcvt_f32_s32(*(int32x2_t *)(v9 + 64)));
      v75 = 5;
    }
  }
  else
  {
    v9 = RB::Device::invalid_texture(***(RB::Device ****)a2);
    v75 = 1;
  }
  result = RB::RenderFrame::texture_id(**(RB::RenderFrame ***)a2, v9);
  *(_DWORD *)(a2 + 232) = result;
  *(_BYTE *)(a2 + 236) = v75;
  return result;
}

__n128 RB::Fill::set_image_stretch(_OWORD *a1, uint64_t a2)
{
  __n128 result;
  __int128 v3;

  result = *(__n128 *)a2;
  v3 = *(_OWORD *)(a2 + 16);
  *a1 = *(_OWORD *)a2;
  a1[1] = v3;
  return result;
}

uint64_t RB::XML::DisplayList::add_rotation_style(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3, double a4, CGPoint a5)
{
  CGFloat y;
  CGFloat x;
  _QWORD *v10;
  _QWORD *v11;
  void *v13;
  double v14;
  CGFloat v15;

  y = a5.y;
  x = a5.x;
  RB::XML::Document::push(this, "rotation-style");
  RB::XML::Document::set_state(this, a2);
  v10 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v13 = &unk_24C229178;
  v14 = a4;
  RB::XML::Element::set<RB::XML::Value::Float>(v10, (uint64_t)"angle", (uint64_t)&v13);
  v11 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v13 = &unk_24C2290B0;
  v14 = x;
  v15 = y;
  RB::XML::Element::set<RB::XML::Value::Vec2>(v11, (uint64_t)"anchor", (uint64_t)&v13);
  return RB::XML::Document::pop((uint64_t)this);
}

uint64_t *RB::XML::DisplayList::begin_layer(RB::XML::DisplayList *this, _RBDrawingState *a2, _RBDrawingState *a3)
{
  char v3;
  uint64_t *result;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  _QWORD *v10;
  const char *v11;
  _QWORD *v12;
  void *v13;
  const char *v14;

  v3 = (char)a3;
  RB::XML::Document::push(this, "layer");
  result = RB::XML::Document::set_state(this, a2);
  if ((v3 & 1) == 0)
  {
    if ((v3 & 2) == 0)
      goto LABEL_3;
LABEL_10:
    v9 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v13 = &unk_24C229010;
    LOBYTE(v14) = 1;
    result = RB::XML::Element::set<RB::XML::Value::Bool>(v9, (uint64_t)"alpha-only", (uint64_t)&v13);
    if ((v3 & 4) == 0)
      goto LABEL_4;
LABEL_11:
    v10 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v11 = "linear";
    goto LABEL_13;
  }
  v8 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v13 = &unk_24C229010;
  LOBYTE(v14) = 1;
  result = RB::XML::Element::set<RB::XML::Value::Bool>(v8, (uint64_t)"needs-background", (uint64_t)&v13);
  if ((v3 & 2) != 0)
    goto LABEL_10;
LABEL_3:
  if ((v3 & 4) != 0)
    goto LABEL_11;
LABEL_4:
  if ((v3 & 8) == 0)
  {
    if ((v3 & 0x10) == 0)
      goto LABEL_6;
    goto LABEL_14;
  }
  v10 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v11 = "non-linear";
LABEL_13:
  v13 = &unk_24C228F48;
  v14 = v11;
  result = RB::XML::Element::set<RB::XML::Value::ConstantString>(v10, (uint64_t)"color-space", (uint64_t)&v13);
  if ((v3 & 0x10) == 0)
  {
LABEL_6:
    if ((v3 & 0x20) == 0)
      return result;
    goto LABEL_7;
  }
LABEL_14:
  v12 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v13 = &unk_24C229010;
  LOBYTE(v14) = 1;
  result = RB::XML::Element::set<RB::XML::Value::Bool>(v12, (uint64_t)"lowers-transition", (uint64_t)&v13);
  if ((v3 & 0x20) == 0)
    return result;
LABEL_7:
  v7 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
  v13 = &unk_24C229010;
  LOBYTE(v14) = 1;
  return RB::XML::Element::set<RB::XML::Value::Bool>(v7, (uint64_t)"only-metadata", (uint64_t)&v13);
}

size_t *RB::XML::DisplayList::copy_state(RB::XML::DisplayList *this, RB::XML::Document *a2, _RBDrawingState *a3, _RBDrawingState *a4)
{
  RB::UntypedTable *v6;
  uint64_t *v7;
  uint64_t *v8;
  size_t *v9;
  BOOL v10;
  size_t *result;
  _QWORD *v12;
  _QWORD *v13;
  void *v14;
  void *v15;

  v6 = (RB::XML::DisplayList *)((char *)this + 32);
  v7 = RB::UntypedTable::lookup((RB::XML::DisplayList *)((char *)this + 32), (uint64_t *)a2, 0);
  v8 = RB::UntypedTable::lookup(v6, (uint64_t *)a3, 0);
  if (v8)
  {
    v9 = (size_t *)v8;
    RB::XML::Document::push(this, "copy-state");
    if (!v7)
      goto LABEL_8;
    v10 = 1;
LABEL_7:
    v12 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v14 = &unk_24C229240;
    v15 = v7;
    RB::XML::Element::set<RB::XML::Value::StateID>(v12, (uint64_t)"from", (uint64_t)&v14);
    if (!v10)
      return (size_t *)RB::XML::Document::pop((uint64_t)this);
LABEL_8:
    v13 = *(_QWORD **)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2) - 8);
    v14 = &unk_24C229240;
    v15 = v9;
    RB::XML::Element::set<RB::XML::Value::StateID>(v13, (uint64_t)"to", (uint64_t)&v14);
    return (size_t *)RB::XML::Document::pop((uint64_t)this);
  }
  result = RB::XML::Document::add_state(this, a3);
  v9 = result;
  v10 = result != 0;
  if (v7 || result)
  {
    RB::XML::Document::push(this, "copy-state");
    if (!v7)
    {
      if (!v9)
        return (size_t *)RB::XML::Document::pop((uint64_t)this);
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  return result;
}

uint64_t RB::XML::DisplayList::clip_shape(RB::XML::Document *a1, _RBDrawingState *a2, uint64_t a3, int a4, float a5)
{
  double v10;
  double v11;
  int8x16_t v12;
  _QWORD *v13;
  _QWORD *v14;
  void *v16;
  double v17;

  RB::XML::Document::push(a1, "clip");
  RB::XML::Document::set_state(a1, a2);
  -[RBShape _xmlAttributes:](a3, *(RB::XML::Element **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8), v10, v11, v12);
  if (a5 != 1.0)
  {
    v13 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v16 = &unk_24C229178;
    v17 = a5;
    RB::XML::Element::set<RB::XML::Value::Float>(v13, (uint64_t)"alpha", (uint64_t)&v16);
  }
  if (a4)
  {
    v14 = *(_QWORD **)(*((_QWORD *)a1 + 1) + 8 * *((_QWORD *)a1 + 2) - 8);
    v16 = &unk_24C229268;
    LODWORD(v17) = a4;
    RB::XML::Element::set<RB::XML::Value::ClipMode>(v14, (uint64_t)"clip-mode", (uint64_t)&v16);
  }
  return RB::XML::Document::pop((uint64_t)a1);
}

uint64_t RB::cg_image_required_depth(RB *this, CGImage *a2)
{
  CGColorSpace *ColorSpace;
  _BOOL4 v5;

  ColorSpace = CGImageGetColorSpace(this);
  if (CGColorSpaceUsesExtendedRange(ColorSpace))
    return 4;
  v5 = CGImageGetBitsPerComponent(this) > 8;
  if (CGColorSpaceIsWideGamutRGB(ColorSpace))
    return v5 | 2u;
  else
    return v5;
}

uint64_t RB::image_filter_sampler(unsigned int a1)
{
  if (a1 > 4)
    return 1;
  else
    return RB::image_filter_sampler(RB::ImageFilter)::sampler_states[a1];
}

BOOL RB::cg_image_has_alpha(RB *this, CGImage *a2)
{
  return (CGImageHasAlpha() & 1) != 0 || CGImageIsMask(this) || CGImageGetMask() || CGImageGetMaskingColors() != 0;
}

uint64_t RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, int a6, unsigned int a7)
{
  uint64_t result;
  unsigned int v15;
  char v18;
  RB::Buffer *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  RB::Buffer *v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  __int128 v33;
  int v34;
  _BOOL4 v35;
  unsigned int v36;
  unsigned int v37;
  int v38;
  _BYTE v39[32];
  _OWORD v40[2];
  int32x2_t v41;
  int32x2_t v42;
  _OWORD v43[3];
  int v44;
  RB::Buffer *v45;
  int64x2_t v46;

  v44 = 0;
  memset(v43, 0, sizeof(v43));
  v41 = 0;
  v42 = 0;
  result = RB::Coverage::Primitive::set_globals(a3, a4, (float32x2_t *)a1, a2, a7, &v44, (uint64_t)v43, (uint64_t)&v41);
  if (!(_DWORD)result)
    return result;
  if (v44 == 1)
  {
    if (a7 != 24 && a7 != 2 || (*(_DWORD *)(a4 + 160) & 0x100) == 0)
      v15 = a7;
    else
      v15 = 0;
    if (!a6 && v15 <= 0x18 && (*(_DWORD *)(a4 + 160) & 7) == 0)
    {
      if (v15 == 24 || v15 == 2)
        v18 = 0;
      else
        v18 = v15;
      if ((*(_DWORD *)(a4 + 160) & 0x100) != 0)
        LOBYTE(v15) = v18;
      else
        LOBYTE(v15) = a7;
      RB::Coverage::set_plane((uint64_t)v39, a4);
      RB::Fill::set_image_stretch(&v39[28], a4 + 80);
      RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x3C, 4uLL, 0, &v45);
      v19 = v45;
      if (v45)
      {
        v20 = (_OWORD *)(*((_QWORD *)v45 + 7) + v46.i64[0]);
        v21 = *(_OWORD *)v39;
        v22 = *(_OWORD *)&v39[16];
        v23 = v40[0];
        *(_OWORD *)((char *)v20 + 44) = *(_OWORD *)((char *)v40 + 12);
        v20[1] = v22;
        v20[2] = v23;
        *v20 = v21;
      }
      else
      {
        v45 = 0;
        v46 = 0uLL;
      }
      *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v19);
      *(int32x2_t *)(a1 + 188) = vmovn_s64(v46);
      v34 = 3;
      goto LABEL_36;
    }
  }
  else
  {
    LOBYTE(v15) = a7;
  }
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0xA4, 4uLL, 0, v39);
  v24 = *(RB::Buffer **)v39;
  if (*(_QWORD *)v39)
  {
    v25 = *(_QWORD *)(*(_QWORD *)v39 + 56) + *(_QWORD *)&v39[8];
    v26 = *(_OWORD *)(a4 + 32);
    v27 = *(_OWORD *)a4;
    *(_OWORD *)(v25 + 16) = *(_OWORD *)(a4 + 16);
    *(_OWORD *)(v25 + 32) = v26;
    v28 = *(_OWORD *)(a4 + 96);
    v30 = *(_OWORD *)(a4 + 48);
    v29 = *(_OWORD *)(a4 + 64);
    *(_OWORD *)(v25 + 80) = *(_OWORD *)(a4 + 80);
    *(_OWORD *)(v25 + 96) = v28;
    *(_OWORD *)(v25 + 48) = v30;
    *(_OWORD *)(v25 + 64) = v29;
    v32 = *(_OWORD *)(a4 + 128);
    v31 = *(_OWORD *)(a4 + 144);
    v33 = *(_OWORD *)(a4 + 112);
    *(_DWORD *)(v25 + 160) = *(_DWORD *)(a4 + 160);
    *(_OWORD *)(v25 + 128) = v32;
    *(_OWORD *)(v25 + 144) = v31;
    *(_OWORD *)(v25 + 112) = v33;
    *(_OWORD *)v25 = v27;
  }
  else
  {
    memset(v39, 0, 24);
  }
  *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v24);
  *(int32x2_t *)(a1 + 188) = vmovn_s64(*(int64x2_t *)&v39[8]);
  v34 = 7;
LABEL_36:
  LODWORD(v45) = v44 & 0xF;
  RB::Coverage::Primitive::set_coverage_state(a3, &v45);
  v35 = *(_DWORD *)(a1 + 136) == 2;
  *(_DWORD *)v39 = (((unsigned __int16)v45 & 0x3FF) << 12) | ((v15 & 0x3F) << 6) | v34;
  *(_DWORD *)&v39[4] = a6 | (2 * v35);
  RB::RenderState::set_image((int *)v39, a4 + 80, *(unsigned __int8 *)(a1 + 124));
  result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)v39, 4, (uint64_t)v43, 0, 1uLL, v41, v42);
  if (*((_QWORD *)&v43[1] + 1))
  {
    LODWORD(v45) = v45 & 0xFFFFFFF0 | 1;
    v36 = *(_DWORD *)v39;
    v37 = ((_DWORD)v45 << 12) & 0x3FF000 | *(_DWORD *)v39 & 0xFFC00FFF;
    *(_DWORD *)v39 = v37;
    if ((*(_BYTE *)(a4 + 161) & 1) != 0)
    {
      v38 = (v36 >> 6) & 0x3F;
      if (v38 == 24 || v38 == 2)
        *(_DWORD *)v39 = v37 & 0xFFFF103F;
    }
    result = (uint64_t)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, *(const char **)v39, 4, (uint64_t)&v43[1] + 8, 0, 1uLL, v41, v42);
  }
  *(_QWORD *)(a1 + 200) = 0;
  *(_DWORD *)(a1 + 196) = 0;
  return result;
}

uint64_t RB::cg_blend_mode(unsigned int a1)
{
  if (a1 <= 0x2C && ((0x70C01FFA004uLL >> a1) & 1) == 0)
    return dword_209BD9754[a1];
  if (a1)
    return 0;
  return 17;
}

uint64_t RB::TextureCache::use_entry(RB::TextureCache *this, unsigned int a2)
{
  char *v3;
  char *v4;
  uint64_t v5;
  uint64_t v6;
  id *v7;
  int v8;
  char *v9;
  char *v10;
  int v11;
  unsigned int v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;
  uint64_t v19;
  unsigned int v20;
  char *v21;
  _DWORD *v22;
  int v23;
  char *v25;

  v3 = (char *)this + 32;
  v4 = (char *)*((_QWORD *)this + 6);
  if (!v4)
    v4 = (char *)this + 32;
  v5 = a2;
  v6 = *(_QWORD *)&v4[16 * a2 + 8];
  if ((*(_BYTE *)(v6 + 77) & 1) != 0)
  {
    v14 = *(_QWORD *)(v6 + 24);
    if ((*(_BYTE *)(v14 + 77) & 2) != 0)
      v14 = *(_QWORD *)(v14 + 24);
    if (*(_BYTE *)(v14 + 44))
      goto LABEL_18;
  }
  else
  {
    v7 = *(id **)&v4[16 * a2 + 8];
    if ((*(_BYTE *)(v6 + 77) & 2) != 0)
      v7 = *(id **)(v6 + 24);
    v8 = RB::Resource::set_volatile(v7, 0);
    if (v8)
    {
      if (v8 == 1)
      {
        v9 = (char *)*((_QWORD *)this + 6);
        if (!v9)
          v9 = v3;
        v10 = &v9[16 * v5 + 8];
        v11 = *((_DWORD *)this + 20);
        v12 = v11 + 1;
        if (*((_DWORD *)this + 21) < (v11 + 1))
        {
          v25 = v10;
          RB::vector<RB::refcounted_ptr<RB::Texture>,1ul,unsigned int>::reserve_slow((char *)this + 64, v12);
          v10 = v25;
          v11 = *((_DWORD *)this + 20);
          v12 = v11 + 1;
        }
        v13 = (char *)*((_QWORD *)this + 9);
        if (!v13)
          v13 = (char *)this + 64;
        *(_QWORD *)&v13[8 * v11] = *(_QWORD *)v10;
        *(_QWORD *)v10 = 0;
        *((_DWORD *)this + 20) = v12;
      }
LABEL_18:
      v15 = (char *)*((_QWORD *)this + 6);
      if (!v15)
        v15 = v3;
      v16 = &v15[16 * v5];
      v17 = &v15[16 * (*((_DWORD *)this + 14) - 1)];
      v18 = *(_DWORD *)v16;
      *(_DWORD *)v16 = *(_DWORD *)v17;
      *(_DWORD *)v17 = v18;
      v19 = *((_QWORD *)v16 + 1);
      *((_QWORD *)v16 + 1) = *((_QWORD *)v17 + 1);
      *((_QWORD *)v17 + 1) = v19;
      v20 = *((_DWORD *)this + 14) - 1;
      *((_DWORD *)this + 14) = v20;
      v21 = (char *)*((_QWORD *)this + 6);
      if (!v21)
        v21 = v3;
      v22 = *(_DWORD **)&v21[16 * v20 + 8];
      if (v22)
      {
        v23 = v22[2] - 1;
        v22[2] = v23;
        if (!v23)
          (*(void (**)(_DWORD *))(*(_QWORD *)v22 + 8))(v22);
      }
      return 0;
    }
  }
  return v6;
}

uint64_t RB::TextureCache::prepare(int32x2_t *a1, uint64_t *a2, CGImage *a3, unsigned __int8 *a4)
{
  uint64_t v8;
  unsigned int Width;
  RB *ColorSpace;
  CGBitmapInfo BitmapInfo;
  __n128 v12;
  int32x2_t v13;
  unsigned int v14;
  unsigned int v15;
  size_t BitsPerComponent;
  _BOOL4 IsWideGamutRGB;
  unint64_t v18;
  char v19;
  uint64_t v20;
  unsigned __int8 v21;
  int v22;
  MTLPixelFormat v23;
  int v24;
  MTLPixelFormat v25;
  unsigned int v26;
  BOOL v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  size_t v31;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v35;
  BOOL v36;
  RB::Texture *v37;
  uint64_t v38;
  _DWORD *v39;
  int v40;
  int v41;
  vImage_Flags v42;
  unsigned __int16 *v43;
  char *v44;
  CGBitmapInfo v45;
  __IOSurface *Property;
  __IOSurface *v47;
  CFTypeID v48;
  __IOSurface *v49;
  const void *v50;
  uint64_t v51;
  const void *v52;
  char v53;
  CGContext *v54;
  const char *v55;
  CGContext *v56;
  CGContext *v57;
  unsigned __int16 *v58;
  unsigned __int16 *v59;
  int8x16_t v60;
  uint64_t v61;
  CGBitmapInfo v62;
  uint32x2_t v63;
  unsigned int Type;
  CGContext *v65;
  const char *v66;
  CGContext *v67;
  int8x16_t v68;
  unsigned int v69;
  RB::Texture *v70;
  int v71;
  RB::Texture *v72;
  unsigned __int32 v73;
  int32x2_t *v74;
  int32x2_t *v75;
  RB::Texture *v76;
  int v77;
  uint64_t v78;
  int v79;
  unsigned int v81;
  NSObject *v82;
  MTLPixelFormat v83;
  char *v84;
  unsigned __int8 v85;
  const char *v86;
  uint64_t v87;
  size_t v88;
  uint64_t v89;
  unsigned int v90;
  __int8 v91;
  int32x2_t v92;
  __n128 v93;
  RB::Texture *v94;
  int v95[2];
  vImage_Buffer data;
  vImage_CGImageFormat format;
  uint64_t v98;
  CGRect v99;
  CGRect v100;
  CGRect v101;

  v98 = *MEMORY[0x24BDAC8D0];
  if ((RB::TextureCache::prepare_from_cache((uint64_t)a1, (uint64_t)a2, a4) & 1) != 0)
    return 1;
  Width = CGImageGetWidth(a3);
  v92 = (int32x2_t)__PAIR64__(CGImageGetHeight(a3), Width);
  ColorSpace = CGImageGetColorSpace(a3);
  BitmapInfo = CGImageGetBitmapInfo(a3);
  v12.n128_u64[0] = (unint64_t)vceq_s32(v92, a1[1]);
  if ((vpmin_u32((uint32x2_t)v12.n128_u64[0], (uint32x2_t)v12.n128_u64[0]).u32[0] & 0x80000000) != 0)
  {
    v45 = BitmapInfo;
    Property = (__IOSurface *)CGImageGetProperty();
    if (Property)
    {
      v47 = Property;
      v48 = CFGetTypeID(Property);
      if (v48 == IOSurfaceGetTypeID()
        && (RB::TextureCache::prepare_from_iosurface((uint64_t)a1, (uint64_t)a2, v47, a4, ColorSpace, v45 | 0x100000000) & 1) != 0)
      {
        return 1;
      }
    }
    if (CGImageGetImageProvider())
    {
      v49 = (__IOSurface *)a1[3];
      if (v49)
        goto LABEL_58;
      v49 = (__IOSurface *)CGImageProviderCopyIOSurface();
      v50 = (const void *)a1[3];
      if (v50)
        CFRelease(v50);
      a1[3] = (int32x2_t)v49;
      if (v49)
      {
LABEL_58:
        if ((RB::TextureCache::prepare_from_iosurface((uint64_t)a1, (uint64_t)a2, v49, a4, ColorSpace, v45 | 0x100000000) & 1) != 0)return 1;
      }
      v51 = CGImageProviderCopyImageTextureData();
      if (v51)
      {
        v52 = (const void *)v51;
        v53 = RB::TextureCache::prepare_from_texture_data(a1, (uint64_t)a2, v51, a4, ColorSpace, v45 | 0x100000000);
        CFRelease(v52);
        if ((v53 & 1) != 0)
          return 1;
      }
    }
  }
  v13 = vshl_s32(a1[1], vneg_s32(vdup_n_s32(a4[2])));
  v14 = *(_DWORD *)a4;
  if ((*(_DWORD *)a4 & 0xFF00) != 0)
    v15 = *(_DWORD *)a4;
  else
    LOBYTE(v15) = 1;
  v91 = v15;
  if ((a1[2].i8[0] & 1) != 0)
  {
    LOBYTE(v90) = 0;
    v18 = 1;
    v19 = 1;
  }
  else
  {
    v90 = v14 >> 8;
    if (CGColorSpaceUsesExtendedRange(ColorSpace))
      goto LABEL_10;
    BitsPerComponent = CGImageGetBitsPerComponent(a3);
    IsWideGamutRGB = CGColorSpaceIsWideGamutRGB(ColorSpace);
    if (BitsPerComponent > 8)
      goto LABEL_10;
    if (IsWideGamutRGB)
    {
      if ((a4[3] & 8) != 0)
      {
LABEL_10:
        v18 = 115;
        v19 = v91;
        goto LABEL_12;
      }
      v19 = 3;
      LOBYTE(v90) = 0;
      v91 = 2;
      v18 = 81;
    }
    else
    {
      if ((v91 & 1) != 0)
        v18 = 80;
      else
        v18 = 81;
      v19 = 1;
    }
  }
LABEL_12:
  v12.n128_u64[0] = (unint64_t)vmax_s32(v13, (int32x2_t)0x100000001);
  memset(&data, 0, sizeof(data));
  v20 = *a2;
  *(_QWORD *)v95 = 0;
  v21 = a4[3];
  v93 = v12;
  if ((v21 & 2) != 0)
    v22 = RB::max_mipmap_levels((int32x2_t)v12.n128_u64[0]);
  else
    v22 = 1;
  RB::TextureCache::take_available((uint64_t)a1, v18, v22, v91, 0, 0, (v21 & 2) == 0, (int32x2_t **)&v94, (int32x2_t)v93.n128_u64[0]);
  if ((v21 & 2) != 0)
  {
    v42 = 0;
  }
  else
  {
    v24 = objc_msgSend(*(id *)(v20 + 24), "minimumLinearTextureAlignmentForPixelFormat:", v18);
    v8 = 0;
    v26 = *((unsigned __int8 *)RB::pixel_format_traits(v18, v25) + 6);
    v27 = v93.n128_i32[0] < 0;
    if (v93.n128_i32[0] >= 0)
      v28 = v93.n128_u32[0];
    else
      v28 = -v93.n128_u32[0];
    v29 = v26 * (unint64_t)v28;
    if (!(_DWORD)v29)
      v27 = 0;
    if ((v29 & 0xFFFFFFFF00000000) != 0)
      goto LABEL_115;
    v89 = v20;
    if (v27)
      goto LABEL_115;
    v8 = 0;
    if (v93.n128_i32[0] >= 0)
      v30 = v29;
    else
      v30 = -(int)v29;
    v31 = (v24 + v30 - 1) & -v24;
    v32 = v93.n128_u32[1];
    if (v93.n128_i32[1] < 0)
      v32 = -v93.n128_u32[1];
    v88 = v31;
    v33 = v32 * (unint64_t)v31;
    v34 = v93.n128_i32[1] >= 0 ? v33 : -(int)v33;
    v35 = (v33 & 0xFFFFFFFF00000000) != 0;
    v36 = (_DWORD)v33 && v93.n128_i32[1] < 0;
    if (v35 || v36)
      goto LABEL_115;
    v37 = v94;
    if (v94 && (*((_BYTE *)v94 + 77) & 2) != 0)
    {
      RB::refcounted_ptr<RB::Buffer>::operator=((_DWORD **)v95, *((_DWORD **)v94 + 3));
    }
    else
    {
      v38 = objc_msgSend(*(id *)(v89 + 24), "newBufferWithLength:options:", v34, 0);
      if (v38)
      {
        v87 = operator new();
        RB::Buffer::Buffer(v87, v38, v34);
        v39 = *(_DWORD **)v95;
        *(_QWORD *)v95 = v87;
        if (v39)
        {
          v40 = v39[2] - 1;
          v39[2] = v40;
          if (!v40)
            (*(void (**)(_DWORD *))(*(_QWORD *)v39 + 8))(v39);
        }
      }
      v94 = 0;
      if (v37)
      {
        v41 = *((_DWORD *)v37 + 2) - 1;
        *((_DWORD *)v37 + 2) = v41;
        if (!v41)
          (*(void (**)(RB::Texture *))(*(_QWORD *)v37 + 8))(v37);
      }
    }
    if (*(_QWORD *)v95)
    {
      data.data = *(void **)(*(_QWORD *)v95 + 56);
      data.rowBytes = v88;
      v60.i64[0] = v93.n128_i32[0];
      v60.i64[1] = v93.n128_i32[1];
      *(int8x16_t *)&data.height = vextq_s8(v60, v60, 8uLL);
      v42 = 512;
    }
    else
    {
      v42 = 0;
    }
    v20 = v89;
  }
  if ((a1[2].i8[0] & 1) != 0)
  {
    v54 = CGBitmapContextCreate(data.data, v93.n128_i32[0], v93.n128_i32[1], 8uLL, data.rowBytes, 0, 7u);
    v56 = v54;
    if (!v54)
      RB::precondition_failure((RB *)"CGContext creation failure", v55);
    CGContextSetBlendMode(v54, kCGBlendModeCopy);
    CGContextSetRGBFillColor(v56, 1.0, 1.0, 1.0, 1.0);
    v99.origin.x = 0.0;
    v99.origin.y = 0.0;
    v99.size.width = (double)v93.n128_i32[0];
    v99.size.height = (double)v93.n128_i32[1];
    CGContextClipToMask(v56, v99, a3);
    v100.origin.x = 0.0;
    v100.origin.y = 0.0;
    v57 = v56;
    v100.size.width = (double)v93.n128_i32[0];
    v100.size.height = (double)v93.n128_i32[1];
    CGContextFillRect(v56, v100);
  }
  else
  {
    memset(&format, 0, sizeof(format));
    switch(v19)
    {
      case 0:
        v59 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v59[2] << 32) & 0xA00000000) != 0)
          v44 = (char *)RB::extended_linear_srgb_colorspace((RB *)v59);
        else
          v44 = RB::linear_srgb_colorspace((RB *)v59);
        goto LABEL_83;
      case 1:
        v58 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v58[2] << 32) & 0xA00000000) != 0)
          v44 = (char *)RB::extended_srgb_colorspace((RB *)v58);
        else
          v44 = (char *)RB::srgb_colorspace((RB *)v58);
        goto LABEL_83;
      case 2:
      case 3:
        v43 = (unsigned __int16 *)RB::pixel_format_traits(v18, v23);
        if ((((unint64_t)v43[2] << 32) & 0xA00000000) != 0)
          v44 = RB::extended_display_p3_colorspace((RB *)v43);
        else
          v44 = RB::display_p3_colorspace((RB *)v43);
LABEL_83:
        format.colorSpace = (CGColorSpaceRef)v44;
        goto LABEL_84;
      case 4:
      case 5:
        goto LABEL_136;
      default:
LABEL_84:
        format.renderingIntent = kCGRenderingIntentDefault;
        if (v18 - 80 >= 2)
        {
          if (v18 != 115)
LABEL_136:
            abort();
          v61 = 0x4000000010;
          v62 = 4353;
        }
        else
        {
          v61 = 0x2000000008;
          v62 = 8194;
        }
        *(_QWORD *)&format.bitsPerComponent = v61;
        format.bitmapInfo = v62;
        v63 = (uint32x2_t)vceq_s32((int32x2_t)v93.n128_u64[0], v92);
        if ((vpmin_u32(v63, v63).u32[0] & 0x80000000) != 0
          && (Type = CGColorSpaceGetType(), Type <= 6)
          && ((1 << Type) & 0x5B) != 0
          && !vImageBuffer_InitWithCGImage(&data, &format, 0, a3, v42))
        {
          v67 = 0;
        }
        else
        {
          v65 = CGBitmapContextCreate(data.data, v93.n128_i32[0], v93.n128_i32[1], format.bitsPerComponent, data.rowBytes, format.colorSpace, format.bitmapInfo);
          v67 = v65;
          if (!v65)
            RB::precondition_failure((RB *)"CGContext creation failure", v66);
          CGContextSetBlendMode(v65, kCGBlendModeCopy);
          CGContextSetRGBFillColor(v67, 1.0, 1.0, 1.0, 1.0);
          v101.size.width = (double)v93.n128_i32[0];
          v101.size.height = (double)v93.n128_i32[1];
          v101.origin.x = 0.0;
          v101.origin.y = 0.0;
          CGContextDrawImage(v67, v101, a3);
        }
        v57 = v67;
        break;
    }
  }
  if (!*(_QWORD *)v95 && v57)
  {
    data.data = CGBitmapContextGetData(v57);
    data.rowBytes = CGBitmapContextGetBytesPerRow(v57);
    v68.i64[0] = v93.n128_i32[0];
    v68.i64[1] = v93.n128_i32[1];
    *(int8x16_t *)&data.height = vextq_s8(v68, v68, 8uLL);
  }
  if (data.data)
  {
    v69 = HIBYTE(v14);
    v70 = v94;
    v71 = v95[0];
    if (v94)
    {
      if (*(_QWORD *)v95)
        goto LABEL_107;
LABEL_105:
      RB::Texture::replace(v70, v71, data.data, data.rowBytes);
      if (!v57)
        free(data.data);
LABEL_107:
      v72 = v94;
      if (*((unsigned __int8 *)v94 + 76) >= 2u)
        RB::RenderFrame::invalidate_mipmaps(a2, v94);
      v73 = a1[7].u32[0];
      if (a1[7].i32[1] < v73 + 1)
      {
        RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(&a1[4], v73 + 1);
        v73 = a1[7].u32[0];
      }
      v74 = (int32x2_t *)a1[6];
      if (!v74)
        v74 = a1 + 4;
      v75 = &v74[2 * v73];
      v75->i32[0] = v14 & 0xFF0000 | (v69 << 24) | (v90 << 8) | v14;
      v75[1] = (int32x2_t)v72;
      v94 = 0;
      ++a1[7].i32[0];
      v8 = RB::TextureCache::prepare_from_cache((uint64_t)a1, (uint64_t)a2, a4);
      if (!v57)
        goto LABEL_115;
      goto LABEL_114;
    }
    if (*(_QWORD *)v95)
    {
      RB::Texture::alloc((float *)v20, *(uint64_t *)v95, v18, data.rowBytes, v91, 0, 0, (uint64_t *)&format, (int32x2_t)v93.n128_u64[0]);
      v70 = *(RB::Texture **)&format.bitsPerComponent;
      v94 = *(RB::Texture **)&format.bitsPerComponent;
      v69 &= ~2u;
      if (*(_QWORD *)&format.bitsPerComponent)
        goto LABEL_104;
    }
    else
    {
      if ((a4[3] & 2) != 0)
        v81 = 0x7FFFFFFF;
      else
        v81 = 1;
      RB::Texture::alloc(v20, v18, v81, v91, 0, 0, (uint64_t *)&format, v93);
      v70 = *(RB::Texture **)&format.bitsPerComponent;
      v94 = *(RB::Texture **)&format.bitsPerComponent;
      if (*(_QWORD *)&format.bitsPerComponent)
      {
LABEL_104:
        v71 = v95[0];
        if (*(_QWORD *)v95)
          goto LABEL_107;
        goto LABEL_105;
      }
    }
    v82 = RB::error_log(v70);
    if (os_log_type_enabled(v82, OS_LOG_TYPE_FAULT))
    {
      v84 = RB::pixel_format_name((RB *)v18, v83);
      v85 = a4[3];
      format.bitsPerComponent = 136315906;
      if ((v85 & 2) != 0)
        v86 = " mipmapped";
      else
        v86 = "";
      *(_QWORD *)&format.bitsPerPixel = v84;
      WORD2(format.colorSpace) = 1024;
      *(_DWORD *)((char *)&format.colorSpace + 6) = v93.n128_u32[0];
      HIWORD(format.bitmapInfo) = 1024;
      format.version = v93.n128_u32[1];
      LOWORD(format.decode) = 2080;
      *(const CGFloat **)((char *)&format.decode + 2) = (const CGFloat *)v86;
      _os_log_fault_impl(&dword_209ACA000, v82, OS_LOG_TYPE_FAULT, "unable to create image texture: %s, [%d, %d]%s", (uint8_t *)&format, 0x22u);
    }
  }
  v8 = 0;
  if (v57)
LABEL_114:
    CFRelease(v57);
LABEL_115:
  v76 = v94;
  if (v94)
  {
    v77 = *((_DWORD *)v94 + 2) - 1;
    *((_DWORD *)v94 + 2) = v77;
    if (!v77)
      (*(void (**)(RB::Texture *))(*(_QWORD *)v76 + 8))(v76);
  }
  v78 = *(_QWORD *)v95;
  if (*(_QWORD *)v95)
  {
    v79 = *(_DWORD *)(*(_QWORD *)v95 + 8) - 1;
    *(_DWORD *)(*(_QWORD *)v95 + 8) = v79;
    if (!v79)
      (*(void (**)(uint64_t))(*(_QWORD *)v78 + 8))(v78);
  }
  return v8;
}

void sub_209AFE7DC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, _DWORD *a19, _DWORD *a20)
{
  int v21;
  int v22;

  if (a19)
  {
    v21 = a19[2] - 1;
    a19[2] = v21;
    if (!v21)
      (*(void (**)(_DWORD *))(*(_QWORD *)a19 + 8))(a19);
  }
  if (a20)
  {
    v22 = a20[2] - 1;
    a20[2] = v22;
    if (!v22)
      (*(void (**)(_DWORD *))(*(_QWORD *)a20 + 8))(a20);
  }
  _Unwind_Resume(exception_object);
}

uint64_t RB::TextureCache::prepare_from_cache(uint64_t a1, uint64_t a2, unsigned __int8 *a3)
{
  unsigned __int8 *v3;
  uint64_t *v4;
  unsigned int entry;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned __int8 *v11;
  uint64_t v12;
  unsigned __int8 *v13;
  int32x2_t *v14;
  MTLPixelFormat v15;
  unsigned __int8 *v16;
  int v17;
  BOOL v18;
  int32x2_t *v19;
  unsigned __int8 v20;
  unsigned __int8 v21;
  uint64_t v22;
  int32x2_t v23;
  int v24;
  uint64_t v25;
  MTLPixelFormat v26;
  unsigned __int8 v27;
  unsigned __int8 *v28;
  unsigned __int8 *v29;
  unsigned int v30;
  unint64_t v31;
  double v32;
  unsigned int *v33;
  int32x2_t *v34;
  int v35;
  int v36;
  unsigned __int8 v37;
  unsigned int v38;
  unsigned int v39;
  uint64_t v40;
  unsigned int v41;
  unsigned __int8 *v42;
  unsigned __int8 *v43;
  int v44;
  uint64_t v45;
  uint64_t *v46;
  unsigned __int8 *v47;
  uint64_t v48;
  __int16 v49;
  unsigned __int8 v50;
  char v51;
  int32x2_t *v52;

  v3 = a3;
  v4 = (uint64_t *)a2;
  *(_DWORD *)(a1 + 20) = *(_DWORD *)(a2 + 88);
  entry = RB::TextureCache::find_entry(a1, a3);
  if ((entry & 0x80000000) == 0 && RB::TextureCache::use_entry((RB::TextureCache *)a1, entry))
    return 1;
  v8 = *(unsigned int *)(a1 + 56);
  if (!(_DWORD)v8)
  {
LABEL_34:
    v37 = v3[2];
    if (!v37)
      return 0;
    while (1)
    {
      v38 = *(_DWORD *)v3;
      v49 = *(_DWORD *)v3;
      v50 = --v37;
      v51 = HIBYTE(v38) & 0xFD;
      v39 = RB::TextureCache::find_entry(a1, (unsigned __int8 *)&v49);
      if ((v39 & 0x80000000) == 0)
      {
        v40 = RB::TextureCache::use_entry((RB::TextureCache *)a1, v39);
        if (v40)
          break;
      }
      if (!v37)
        return 0;
    }
    return RB::TextureCache::prepare_from_base_level((int32x2_t *)a1, v4, (unsigned int *)v3, v40, v37);
  }
  v9 = 0;
  v10 = 0;
  v11 = (unsigned __int8 *)(a1 + 32);
  v12 = 16 * v8;
  v46 = v4;
  v47 = v3;
  v45 = 16 * v8;
  while (1)
  {
    v13 = *(unsigned __int8 **)(a1 + 48);
    if (!v13)
      v13 = v11;
    if (v13[v9 + 2] != v3[2])
      goto LABEL_33;
    v14 = (int32x2_t *)RB::TextureCache::use_entry((RB::TextureCache *)a1, v10);
    if (!v14)
      goto LABEL_33;
    v15 = (MTLPixelFormat)v14;
    v16 = *(unsigned __int8 **)(a1 + 48);
    if (!v16)
      v16 = v11;
    v17 = v16[v9 + 1];
    if (v3[1])
      v18 = v17 == 0;
    else
      v18 = 1;
    v19 = v14 + 10;
    if (!v18)
      v19 = (int32x2_t *)v3;
    v20 = v19->i8[0];
    if ((v3[3] & 1) != 0)
      v21 = v20 & 0xFE;
    else
      v21 = v20;
    v22 = (uint64_t)v14[7];
    v23 = v14[8];
    if ((v3[3] & 2) != 0)
      v24 = RB::max_mipmap_levels(v14[8]);
    else
      v24 = 1;
    v25 = v21;
    RB::TextureCache::take_available(a1, v22, v24, v21, 1, 0, 0, &v52, v23);
    v27 = v47[3];
    v28 = *(unsigned __int8 **)(a1 + 48);
    v29 = v11;
    if (!v28)
      v28 = v11;
    v30 = v28[v9 + 3];
    v31 = *(_QWORD *)(v15 + 56);
    v32 = *(double *)(v15 + 64);
    v33 = RB::pixel_format_traits(v31, v26);
    v4 = v46;
    RB::RenderParams::RenderParams((uint64_t)&v49, (uint64_t)v46, v31, v25, v25, ((*v33 | ((unint64_t)*((unsigned __int16 *)v33 + 2) << 32)) & 0xA00000000) != 0, v32, 1.0);
    v34 = v52;
    RB::RenderFrame::copy_texture(v46, v15, v25, (v30 >> 1) & 2 | ((v27 & 2) != 0), (uint64_t)&v49, v52, &v48);
    v11 = v29;
    if (!v48)
    {
LABEL_28:
      if (v34)
        goto LABEL_29;
      goto LABEL_32;
    }
    if (v48 != v15)
      break;
    v35 = *(_DWORD *)(v15 + 8) - 1;
    *(_DWORD *)(v15 + 8) = v35;
    if (v35)
      goto LABEL_28;
    (*(void (**)(MTLPixelFormat))(*(_QWORD *)v15 + 8))(v15);
    if (v34)
    {
LABEL_29:
      v36 = v34[1].i32[0] - 1;
      v34[1].i32[0] = v36;
      if (!v36)
        (*(void (**)(int32x2_t *))(*(_QWORD *)v34 + 8))(v34);
    }
LABEL_32:
    v3 = v47;
    v12 = v45;
LABEL_33:
    v9 += 16;
    ++v10;
    if (v12 == v9)
      goto LABEL_34;
  }
  v41 = *(_DWORD *)(a1 + 56);
  if (*(_DWORD *)(a1 + 60) < v41 + 1)
  {
    RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(v29, v41 + 1);
    v41 = *(_DWORD *)(a1 + 56);
    v11 = v29;
  }
  v42 = *(unsigned __int8 **)(a1 + 48);
  if (!v42)
    v42 = v11;
  v43 = &v42[16 * v41];
  *(_DWORD *)v43 = *(_DWORD *)v47;
  *((_QWORD *)v43 + 1) = v48;
  ++*(_DWORD *)(a1 + 56);
  if (v34)
  {
    v44 = v34[1].i32[0] - 1;
    v34[1].i32[0] = v44;
    if (!v44)
      (*(void (**)(int32x2_t *))(*(_QWORD *)v34 + 8))(v34);
  }
  return 1;
}

void sub_209AFEBF4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _DWORD *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  _DWORD *v18;
  int v20;
  int v21;

  if (a13)
  {
    v20 = a13[2] - 1;
    a13[2] = v20;
    if (!v20)
      (*(void (**)(_DWORD *))(*(_QWORD *)a13 + 8))(a13);
  }
  if (v18)
  {
    v21 = v18[2] - 1;
    v18[2] = v21;
    if (!v21)
      (*(void (**)(_DWORD *))(*(_QWORD *)v18 + 8))(v18);
  }
  _Unwind_Resume(exception_object);
}

RB::ImageTexture *RB::ImageTexture::ImageTexture(RB::ImageTexture *this, CGImage *a2, const void *a3)
{
  *(_QWORD *)this = a3;
  *((_DWORD *)this + 2) = (_DWORD)a2;
  *((_WORD *)this + 6) = 0;
  RB::ImageTexture::update_image((unint64_t)this, a2);
  return this;
}

unint64_t RB::ImageTexture::update_image(unint64_t this, CGImage *a2)
{
  _BYTE *v2;
  unint64_t v3;
  RB *v4;
  CGImage *v5;
  OSType PixelFormat;
  MTLPixelFormat v7;
  RB *v8;
  BOOL v9;
  unsigned int *v10;
  __int16 v11;

  *(_WORD *)(this + 12) = 0;
  v2 = (_BYTE *)(this + 12);
  v3 = this;
  switch(*(_DWORD *)(this + 8))
  {
    case 0:
      v4 = *(RB **)this;
      *(_BYTE *)(this + 13) = RB::cg_image_required_depth(*(RB **)this, a2);
      this = RB::cg_image_has_alpha(v4, v5);
      *(_BYTE *)(v3 + 12) = this ^ 1;
      break;
    case 1:
      v11 = 0;
      PixelFormat = IOSurfaceGetPixelFormat(*(IOSurfaceRef *)this);
      this = RB::pixel_format_from_four_cc(PixelFormat, MTLPixelFormatInvalid, v2, (_BYTE *)&v11 + 1, (char *)&v11);
      goto LABEL_6;
    case 2:
      this = RBSurfaceIsOpaque(*(_QWORD *)this);
      *(_BYTE *)(v3 + 12) = this;
      break;
    case 4:
      this = objc_msgSend(*(id *)this, "pixelFormat");
LABEL_6:
      v8 = (RB *)this;
      if (this)
      {
        if (*v2)
        {
          v9 = 1;
        }
        else
        {
          v10 = RB::pixel_format_traits(this, v7);
          v9 = ((*v10 | ((unint64_t)*((unsigned __int16 *)v10 + 2) << 32)) & 0x100000000) == 0;
        }
        *(_BYTE *)(v3 + 12) = v9;
        this = RB::pixel_format_required_depth(v8, v7);
        *(_BYTE *)(v3 + 13) = this;
      }
      break;
    default:
      return this;
  }
  return this;
}

void RB::SurfacePool::dealloc(os_unfair_lock_t lock, RB::Surface *a2, _CAImageQueue *a3)
{
  uint64_t v6;
  int v7;
  CFTimeInterval v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  RB::Surface **v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;

  if (a2)
  {
    if (a3)
      v6 = (uint64_t)a3;
    else
      v6 = 1;
    if (v6 == *((_QWORD *)a2 + 15))
    {
      os_unfair_lock_lock(lock);
      v8 = CACurrentMediaTime();
      *((_QWORD *)a2 + 15) = 0;
      *((CFTimeInterval *)a2 + 16) = v8;
      if (!a3)
        *((_BYTE *)a2 + 140) = 1;
      v9 = *(_QWORD *)&lock[4]._os_unfair_lock_opaque;
      v10 = *(_QWORD *)&lock[6]._os_unfair_lock_opaque;
      if (v10)
      {
        v11 = 8 * v10;
        v12 = *(RB::Surface ***)&lock[4]._os_unfair_lock_opaque;
        while (*v12 != a2)
        {
          ++v12;
          v11 -= 8;
          if (!v11)
          {
            v12 = (RB::Surface **)(v9 + 8 * v10);
            break;
          }
        }
      }
      else
      {
        v12 = *(RB::Surface ***)&lock[4]._os_unfair_lock_opaque;
      }
      v13 = ((uint64_t)v12 - v9) >> 3;
      if (v13 != v10)
      {
        v14 = (uint64_t *)(v9 + 8 * v13);
        v15 = *v14;
        *v14 = 0;
        v16 = ((uint64_t)v14 - *(_QWORD *)&lock[4]._os_unfair_lock_opaque) >> 3;
        v17 = *(_QWORD *)&lock[6]._os_unfair_lock_opaque - 1;
        *(_QWORD *)&lock[6]._os_unfair_lock_opaque = v17;
        v18 = v17 - v16;
        if (v18)
        {
          memmove(v14, v14 + 1, 8 * v18);
          v16 = *(_QWORD *)&lock[6]._os_unfair_lock_opaque;
        }
        v19 = v16 + 1;
        if (*(_QWORD *)&lock[8]._os_unfair_lock_opaque < (unint64_t)(v16 + 1))
        {
          RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)&lock[4], v19);
          v16 = *(_QWORD *)&lock[6]._os_unfair_lock_opaque;
          v19 = v16 + 1;
        }
        *(_QWORD *)(*(_QWORD *)&lock[4]._os_unfair_lock_opaque + 8 * v16) = v15;
        *(_QWORD *)&lock[6]._os_unfair_lock_opaque = v19;
      }
      RB::SurfacePool::remove_watched_queue_locked((RB::SurfacePool *)lock, a3, 1);
      if (LOBYTE(lock[32]._os_unfair_lock_opaque))
      {
        v7 = 0;
      }
      else
      {
        v7 = 1;
        LOBYTE(lock[32]._os_unfair_lock_opaque) = 1;
      }
      os_unfair_lock_unlock(lock);
    }
    else
    {
      v7 = 0;
    }
    v20 = (unsigned int *)((char *)a2 + 8);
    do
    {
      v21 = __ldxr(v20);
      v22 = v21 - 1;
    }
    while (__stlxr(v22, v20));
    if (!v22)
    {
      __dmb(9u);
      (*(void (**)(RB::Surface *))(*(_QWORD *)a2 + 8))(a2);
    }
    if (v7)
      dispatch_async_f(*(dispatch_queue_t *)&lock[2]._os_unfair_lock_opaque, lock, (dispatch_function_t)RB::SurfacePool::AsyncCollection::~AsyncCollection()::$_0::__invoke);
  }
}

void sub_209AFEF90(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  unsigned int *v2;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  if (v2)
  {
    v4 = v2 + 2;
    do
    {
      v5 = __ldxr(v4);
      v6 = v5 - 1;
    }
    while (__stlxr(v6, v4));
    if (!v6)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

int *RB::RenderState::set_image(int *result, uint64_t a2, int a3)
{
  unsigned int v3;
  int v4;
  __int16 v5;

  v3 = *(_DWORD *)(a2 + 80);
  v4 = (v3 >> 7) & 1;
  if (((v3 >> 4) & 3) != a3)
    v4 = 1;
  if (v4)
    v5 = 256;
  else
    v5 = 0;
  if ((v3 & 0x100) == 0)
    v5 = 0;
  *result = *result & 0x3FFFFF | ((unsigned __int16)(v5 | v3 & 0xFEFF) << 22);
  return result;
}

uint64_t RB::RenderFrame::texture_id(RB::RenderFrame *this, uint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  _QWORD *v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;

  if (!a2)
    return 0;
  RB::Resource::set_frame_id(a2, *((_DWORD *)this + 21), *((_DWORD *)this + 22));
  result = *(unsigned int *)(a2 + 40);
  if (!(_DWORD)result)
  {
    result = *(_QWORD *)(*((_QWORD *)this + 13) + 8);
    v5 = *(_QWORD *)(a2 + 48);
    v6 = (_QWORD *)*((_QWORD *)this + 13);
    v7 = v6[1];
    if (v7 >= v6[2])
    {
      v9 = *(_QWORD *)(a2 + 48);
      v10 = v6[1];
      v11 = *(_QWORD *)(*((_QWORD *)this + 13) + 8);
      v8 = RB::shared_vector<RB::refcounted_ptr<RB::Buffer>>::realloc_buffer((unint64_t *)this + 13, v6);
      v5 = v9;
      v7 = v10;
      v6 = (_QWORD *)v8;
      result = v11;
    }
    v6[v7 + 3] = (v5 == 0) | (unint64_t)a2;
    if (!v5)
      ++*(_DWORD *)(a2 + 8);
    atomic_store(v7 + 1, v6 + 1);
    *(_DWORD *)(a2 + 40) = result;
    *((_QWORD *)this + 5) += *(unsigned int *)(a2 + 72);
  }
  return result;
}

const Transition *RB::DisplayList::State::set_transition(RB::DisplayList::State *this, const Transition *a2)
{
  const Transition *v3;
  const Transition *result;
  unsigned int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int v9;

  if (*((_BYTE *)a2 + 12))
    v3 = a2;
  else
    v3 = 0;
  result = (const Transition *)*((_QWORD *)this + 11);
  if (result != v3)
  {
    if (!result)
      goto LABEL_9;
    v5 = (unsigned int *)((char *)result + 8);
    do
    {
      v6 = __ldxr(v5);
      v7 = v6 - 1;
    }
    while (__stlxr(v7, v5));
    if (!v7)
    {
      __dmb(9u);
      result = (const Transition *)(*(uint64_t (**)(const Transition *))(*(_QWORD *)result + 8))(result);
      if (v3)
      {
LABEL_10:
        v8 = (unsigned int *)((char *)v3 + 8);
        do
          v9 = __ldxr(v8);
        while (__stxr(v9 + 1, v8));
      }
    }
    else
    {
LABEL_9:
      if (v3)
        goto LABEL_10;
    }
    *((_QWORD *)this + 11) = v3;
    *((_QWORD *)this + 15) = 0;
  }
  return result;
}

void RB::DisplayList::TransformStyle::~TransformStyle(RB::DisplayList::TransformStyle *this)
{
  void *v2;
  RB::DisplayList::Transform::Term *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
    v3 = (RB::DisplayList::Transform::Term *)*((_QWORD *)this + 11);
  else
    v3 = (RB::DisplayList::TransformStyle *)((char *)this + 56);
  if (*((_DWORD *)this + 24))
  {
    v4 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v3);
      ++v4;
      v3 = (RB::DisplayList::Transform::Term *)(v5 + 32);
    }
    while (v4 < *((unsigned int *)this + 24));
    v2 = (void *)*((_QWORD *)this + 11);
  }
  if (v2)
    free(v2);
}

{
  void *v2;
  RB::DisplayList::Transform::Term *v3;
  unint64_t v4;
  uint64_t v5;

  v2 = (void *)*((_QWORD *)this + 11);
  if (v2)
    v3 = (RB::DisplayList::Transform::Term *)*((_QWORD *)this + 11);
  else
    v3 = (RB::DisplayList::TransformStyle *)((char *)this + 56);
  if (*((_DWORD *)this + 24))
  {
    v4 = 0;
    do
    {
      RB::DisplayList::Transform::Term::~Term(v3);
      ++v4;
      v3 = (RB::DisplayList::Transform::Term *)(v5 + 32);
    }
    while (v4 < *((unsigned int *)this + 24));
    v2 = (void *)*((_QWORD *)this + 11);
  }
  if (v2)
    free(v2);
  JUMPOUT(0x20BD16544);
}

void RB::DisplayList::AnimationStyle::~AnimationStyle(RB::DisplayList::AnimationStyle *this)
{
  void *v1;

  v1 = (void *)*((_QWORD *)this + 10);
  if (v1)
    free(v1);
}

{
  void *v1;

  v1 = (void *)*((_QWORD *)this + 10);
  if (v1)
    free(v1);
  JUMPOUT(0x20BD16544);
}

uint64_t collect_resources(uint64_t result)
{
  void *v1;
  unsigned int *v2;
  unsigned int v3;

  v1 = (void *)result;
  v2 = (unsigned int *)(result + 16);
  do
  {
    v3 = __ldaxr(v2);
    if (v3 != 1)
    {
      __clrex();
      return result;
    }
  }
  while (__stlxr(0, v2));
  result = RB::Device::prune_caches(*(dispatch_queue_t **)(result + 8));
  if ((_DWORD)result)
    return objc_msgSend(v1, "collectResources");
  return result;
}

float set_rounded_rect(uint64_t a1, int a2, float64x2_t a3, float64_t a4, float64x2_t a5, double a6, double a7, double a8, double a9)
{
  float v11;
  char v12;
  double v13;
  double v14;
  BOOL v15;
  double v16;
  double v17;
  float32x2_t v18;
  float32x2_t v19;
  int v20;
  float result;
  float v22;
  int32x4_t v23;

  v11 = 1.0;
  v12 = 2;
  if (a7 > 0.0 && a8 > 0.0)
  {
    if (a6 >= a5.f64[0])
      v13 = a5.f64[0];
    else
      v13 = a6;
    v14 = v13 * 0.5;
    if (v14 < a7)
      a7 = v14;
    if (v14 < a8)
      a8 = v14;
    if (a2 == 1)
    {
      a7 = a7 * 1.27499998;
      a8 = a8 * 1.27499998;
      v12 = 4;
    }
    else
    {
      if (a2)
        abort();
      if (a5.f64[0] == a6 && (a7 == v14 ? (v15 = a8 == v14) : (v15 = 0), v15))
        v12 = 5;
      else
        v12 = 3;
    }
    if (a7 == a8)
    {
      v16 = 1.0;
    }
    else
    {
      v17 = a7 / a8;
      v16 = 1.0 / (a7 / a8);
      v11 = v17;
    }
    a3.f64[0] = v16 * a3.f64[0];
    a5.f64[0] = v16 * a5.f64[0];
  }
  a3.f64[1] = a4;
  a5.f64[1] = a6;
  v18 = vcvt_f32_f64(a3);
  v19 = vcvt_f32_f64(a5);
  *(float *)a3.f64 = a8;
  v23 = vdupq_lane_s32(*(int32x2_t *)&a3.f64[0], 0);
  v20 = *(_DWORD *)(a1 + 428);
  RBShapeData::apply<RB::DestroyAny>((int *)(a1 + 16));
  result = a9;
  v22 = *(double *)(a1 + 432);
  *(float32x2_t *)(a1 + 32) = v18;
  *(float32x2_t *)(a1 + 40) = v19;
  *(int32x4_t *)(a1 + 48) = v23;
  *(float *)(a1 + 64) = v11;
  *(float *)(a1 + 68) = result;
  *(float *)(a1 + 72) = v22;
  *(_BYTE *)(a1 + 76) = v12;
  *(_BYTE *)(a1 + 77) = v20;
  *(_BYTE *)(a1 + 78) &= 0xF8u;
  *(_DWORD *)(a1 + 16) = 1;
  return result;
}

uint64_t RBMakeCachedImageTexture(uint64_t **a1, CGImage *a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v10;
  unsigned int Identifier;
  uint64_t *v12;
  int Width;
  int Height;
  id *v15;
  int32x2_t v16;
  _BOOL4 v19;
  int32x2_t v20;
  int v21;

  v10 = **a1;
  Identifier = CGImageGetIdentifier();
  v12 = RB::Device::texture_cache(v10, 0, Identifier);
  if (!v12)
  {
    Width = CGImageGetWidth(a2);
    Height = CGImageGetHeight(a2);
    v19 = CGImageIsMask(a2) || CGImageGetAlphaInfo(a2) == kCGImageAlphaOnly;
    v15 = (id *)operator new();
    v12 = (uint64_t *)v15;
    if (Width > 0x2000 || Height > 0x2000 || Height * Width >= 16777217)
    {
      v16 = (int32x2_t)__PAIR64__(Height, Width);
      do
      {
        do
          v16 = vshr_n_s32(vadd_s32(v16, (int32x2_t)0x100000001), 1uLL);
        while (v16.i32[0] > 0x2000);
      }
      while (v16.i32[1] > 0x2000 || v16.i32[0] * v16.i32[1] > 0x1000000);
    }
    else
    {
      v16 = (int32x2_t)__PAIR64__(Height, Width);
    }
    v20 = v16;
    objc_initWeakOrNil(v15, a2);
    v12[1] = (uint64_t)v20;
    *((_DWORD *)v12 + 4) = v19;
    *((_DWORD *)v12 + 5) = 0;
    v12[3] = 0;
    v12[6] = 0;
    v12[7] = 0x100000000;
    v12[9] = 0;
    v12[10] = 0x100000000;
    RB::Device::set_texture_cache(v10, 0, Identifier, (size_t *)v12);
  }
  return RB::TextureCache::prepare((int32x2_t *)v12, *a1, a2, (unsigned __int8 *)&v21);
}

void sub_209AFF590(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C400DFC61FBLL);
  _Unwind_Resume(a1);
}

uint64_t *RBGetCachedImageTexture(uint64_t **a1, CGImage *a2, const RB::Fill::ImageData *a3, float64x2_t *a4, char a5)
{
  uint64_t v9;
  unsigned int Identifier;
  uint64_t *result;
  uint64_t v12;
  unsigned int entry;
  uint64_t v14;
  int v15;

  v9 = **a1;
  Identifier = CGImageGetIdentifier();
  result = RB::Device::texture_cache(v9, 0, Identifier);
  if (result)
  {
    v12 = (uint64_t)result;
    entry = RB::TextureCache::find_entry(v12, (unsigned __int8 *)&v15);
    if ((entry & 0x80000000) != 0)
    {
      return 0;
    }
    else
    {
      v14 = v12 + 32;
      if (*(_QWORD *)(v12 + 48))
        v14 = *(_QWORD *)(v12 + 48);
      return *(uint64_t **)(v14 + 16 * entry + 8);
    }
  }
  return result;
}

uint64_t rb_interpolation_mode(unsigned int a1)
{
  if (a1 > 0xC)
    return 1;
  else
    return byte_209BD70B8[a1];
}

{
  if (a1 > 9)
    return 1;
  else
    return dword_209BD70C8[(char)a1];
}

double RBImageSimpleTransform@<D0>(uint64_t a1@<X8>, double a2@<D0>, double a3@<D1>, double a4@<D2>, double a5@<D3>)
{
  float v5;
  float v6;
  float v7;
  float v8;
  double result;

  v5 = a2;
  v6 = a3;
  v7 = a4;
  v8 = a5;
  result = v5;
  *(double *)a1 = v7;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  *(double *)(a1 + 24) = v8;
  *(double *)(a1 + 32) = result;
  *(double *)(a1 + 40) = v6;
  return result;
}

uint64_t RBImageMakeCGImage()
{
  return 0;
}

uint64_t RBDrawingStateSetTransition(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  _RBDrawingState *v3;
  uint64_t v4;
  BOOL v5;
  const RB::Transition *v6;
  uint64_t v7;

  if (!a2)
    return result;
  v2 = result;
  result = -[RBDecodedFontMetadata fontUID](a2);
  v3 = (_RBDrawingState *)result;
  v4 = *(_QWORD *)(v2 + 88);
  if (!*(_BYTE *)(result + 13))
  {
LABEL_11:
    if (v4 == result)
      return result;
    goto LABEL_12;
  }
  if (v4)
  {
    if (*(_BYTE *)(v4 + 12))
    {
      if (*(_BYTE *)(v4 + 13))
        v5 = v4 == result;
      else
        v5 = 1;
      if (v5)
        return result;
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_12:
  RB::DisplayList::State::set_transition((RB::DisplayList::State *)v2, (const Transition *)result);
  v7 = *(_QWORD *)(v2 + 8);
  if (!*(_QWORD *)(v7 + 24))
    make_contents(*(unsigned int **)(v2 + 8));
  result = *(_QWORD *)(v7 + 304);
  if (result)
    return RB::XML::DisplayList::transition((RB::XML::DisplayList *)result, (_RBDrawingState *)v2, v3, v6);
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAnimationStyle(uint64_t a1, const RB::Animation *a2, uint64_t a3, uint64_t a4)
{
  return RBDrawingStateAddAnimationStyle2(a1, a2, a3, a4, (const UUID *)0x111);
}

void sub_209AFF924(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209AFF9C0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CFDataRef RB::ProtobufEncoder::take_data@<X0>(RB::ProtobufEncoder *this@<X0>, CFDataRef *a2@<X8>)
{
  CFDataRef result;
  const UInt8 *v4;
  CFIndex v5;

  if (*((_BYTE *)this + 48))
  {
    result = 0;
  }
  else
  {
    v4 = *(const UInt8 **)this;
    v5 = *((_QWORD *)this + 1);
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
    *(_QWORD *)this = 0;
    result = CFDataCreateWithBytesNoCopy(0, v4, v5, (CFAllocatorRef)*MEMORY[0x24BDBD248]);
  }
  *a2 = result;
  return result;
}

uint64_t *RB::Encoder::local_namespace(RB::Encoder *this)
{
  unsigned __int8 v1;
  uint64_t v3;

  {
    RB::Encoder::local_namespace(void)::local_ns = RB::Encoder::local_namespace(void)::$_0::operator()();
    *(_QWORD *)algn_253EAEFC8 = v3;
  }
  return &RB::Encoder::local_namespace(void)::local_ns;
}

void sub_209AFFCA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t RB::Encoder::local_namespace(void)::$_0::operator()()
{
  uuid_t uu;
  uint64_t v2;

  v2 = *MEMORY[0x24BDAC8D0];
  uuid_clear(uu);
  MEMORY[0x20BD16BEC](uu);
  return *(_QWORD *)uu;
}

_QWORD *RB::ProtobufEncoder::encode_varint(_QWORD *this, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  unint64_t v4;
  unsigned __int8 v5;
  uint64_t v6;
  size_t v7;
  _BYTE *v8;
  BOOL v9;
  char v10;
  char v11;

  v2 = a2;
  v3 = this;
  if (a2 > 0x7F)
  {
    v5 = 70 - __clz(a2);
    v6 = (((v5 - ((unsigned __int16)(37 * v5) >> 8)) >> 1) + ((37 * v5) >> 8)) >> 2;
    v4 = this[1];
  }
  else
  {
    v4 = this[1];
    if (this[2] > v4)
    {
      *(_BYTE *)(*this + v4) = a2;
      ++this[1];
      return this;
    }
    v6 = 1;
  }
  v7 = v4 + v6;
  if (v4 < v4 + v6 && this[2] < v7)
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v7);
  v3[1] = v7;
  v8 = (_BYTE *)(*v3 + v4);
  do
  {
    v9 = v2 > 0x7F;
    v10 = v2 > 0x7F;
    v11 = v2 & 0x7F;
    v2 >>= 7;
    *v8++ = v11 | (v10 << 7);
  }
  while (v9);
  return this;
}

_QWORD *RB::ProtobufEncoder::encode_fixed32(_QWORD *this, int a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;

  v3 = this;
  v4 = this[1];
  v5 = v4 + 4;
  if (v4 <= 0xFFFFFFFFFFFFFFFBLL && this[2] < v5)
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v4 + 4);
  v3[1] = v5;
  *(_DWORD *)(*v3 + v4) = a2;
  return this;
}

_QWORD *RB::ProtobufEncoder::encode_fixed64(_QWORD *this, uint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;
  unint64_t v5;

  v3 = this;
  v4 = this[1];
  v5 = v4 + 8;
  if (v4 <= 0xFFFFFFFFFFFFFFF7 && this[2] < v5)
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v4 + 8);
  v3[1] = v5;
  *(_QWORD *)(*v3 + v4) = a2;
  return this;
}

_QWORD *RB::ProtobufEncoder::encode_data(RB::ProtobufEncoder *this, const void *a2, unint64_t a3)
{
  _QWORD *result;
  unint64_t v7;
  unint64_t v8;

  result = RB::ProtobufEncoder::encode_varint(this, a3);
  if (a3)
  {
    v7 = *((_QWORD *)this + 1);
    v8 = v7 + a3;
    if (v7 < v7 + a3 && *((_QWORD *)this + 2) < v8)
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v7 + a3);
    *((_QWORD *)this + 1) = v8;
    return memcpy((void *)(*(_QWORD *)this + v7), a2, a3);
  }
  return result;
}

_QWORD *RB::ProtobufEncoder::begin_length_delimited(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  v1 = this;
  v2 = this[1];
  v3 = v2 + 1;
  if (v2 != -1 && this[2] < v3)
    this = RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v2 + 1);
  v1[1] = v3;
  v4 = v1[4];
  if (v1[5] < (unint64_t)(v4 + 1))
  {
    this = RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)(v1 + 3), v4 + 1);
    v4 = v1[4];
  }
  *(_QWORD *)(v1[3] + 8 * v4) = v2;
  ++v1[4];
  return this;
}

_QWORD *RB::ProtobufEncoder::end_length_delimited(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  size_t v4;
  uint64_t v5;
  unint64_t v6;
  char v7;
  uint64_t v8;
  size_t v9;
  _BYTE *v10;
  BOOL v11;
  char v12;
  char v13;
  uint64_t v14;
  uint64_t v15;

  v1 = this;
  v2 = this[4] - 1;
  v3 = *(_QWORD *)(this[3] + 8 * v2);
  this[4] = v2;
  v4 = this[1];
  v5 = v3 + 1;
  v6 = v4 - (v3 + 1);
  if (v6 > 0x7F)
  {
    v7 = __clz(v6);
    v8 = (((70 - v7 - ((unsigned __int16)(37 * (70 - v7)) >> 8)) >> 1)
        + ((37 * (70 - v7)) >> 8)) >> 2;
    v9 = v4 + v8 - 1;
    if (v4 < v9 && this[2] < v9)
    {
      v15 = v4 + v8 - 1;
      v14 = v8;
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)this, v9);
      v8 = v14;
      v5 = v3 + 1;
      v9 = v15;
    }
    v1[1] = v9;
    this = memmove((void *)(*v1 + v3 + v8), (const void *)(*v1 + v5), v6);
    v10 = (_BYTE *)(*v1 + v3);
    do
    {
      v11 = v6 > 0x7F;
      v12 = v6 > 0x7F;
      v13 = v6 & 0x7F;
      v6 >>= 7;
      *v10++ = v13 | (v12 << 7);
    }
    while (v11);
  }
  else
  {
    *(_BYTE *)(*this + v3) = v6;
  }
  return this;
}

_QWORD *RB::ProtobufEncoder::packed_uint32_field(_QWORD *this, uint64_t a2, unsigned int *a3, uint64_t a4)
{
  uint64_t v4;
  _QWORD *v6;
  unsigned int v7;

  if (a4)
  {
    v4 = a4;
    v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v6);
    do
    {
      v7 = *a3++;
      RB::ProtobufEncoder::encode_varint(v6, v7);
      --v4;
    }
    while (v4);
    return RB::ProtobufEncoder::end_length_delimited(v6);
  }
  return this;
}

_QWORD *RB::ProtobufEncoder::packed_fixed32_field(_QWORD *this, uint64_t a2, const unsigned int *a3, uint64_t a4)
{
  _QWORD *v6;
  size_t v7;
  size_t v8;
  size_t v9;

  if (a4)
  {
    v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    v7 = 4 * a4;
    RB::ProtobufEncoder::encode_varint(v6, 4 * a4);
    v8 = v6[1];
    v9 = v8 + 4 * a4;
    if (v8 < v9 && v6[2] < v9)
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)v6, v9);
    v6[1] = v9;
    return memcpy((void *)(*v6 + v8), a3, v7);
  }
  return this;
}

_QWORD *RB::ProtobufEncoder::packed_fixed64_field(_QWORD *this, uint64_t a2, const unint64_t *a3, uint64_t a4)
{
  _QWORD *v6;
  size_t v7;
  size_t v8;
  size_t v9;

  if (a4)
  {
    v6 = this;
    RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
    v7 = 8 * a4;
    RB::ProtobufEncoder::encode_varint(v6, 8 * a4);
    v8 = v6[1];
    v9 = v8 + 8 * a4;
    if (v8 < v9 && v6[2] < v9)
      RB::vector<unsigned char,0ul,unsigned long>::reserve_slow((uint64_t)v6, v9);
    v6[1] = v9;
    return memcpy((void *)(*v6 + v8), a3, v7);
  }
  return this;
}

_QWORD *RB::ProtobufEncoder::float2_field(_QWORD *result, uint64_t a2, double a3)
{
  uint32x2_t v3;
  _QWORD *v4;

  v3 = (uint32x2_t)vceqz_f32(*(float32x2_t *)&a3);
  if ((vpmin_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v4);
    if (*(float *)&a3 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, SLODWORD(a3));
    }
    if (*((float *)&a3 + 1) != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v4, SHIDWORD(a3));
    }
    return RB::ProtobufEncoder::end_length_delimited(v4);
  }
  return result;
}

_QWORD *RB::ProtobufEncoder::float3_field(_QWORD *result, uint64_t a2, float32x4_t a3)
{
  uint32x4_t v3;
  _QWORD *v4;

  v3 = (uint32x4_t)vceqzq_f32(a3);
  v3.i32[3] = v3.i32[2];
  if ((vminvq_u32(v3) & 0x80000000) == 0)
  {
    v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v4);
    if (a3.f32[0] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[0]);
    }
    if (a3.f32[1] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[1]);
    }
    if (a3.f32[2] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v4, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v4, a3.i32[2]);
    }
    return RB::ProtobufEncoder::end_length_delimited(v4);
  }
  return result;
}

_QWORD *RB::ProtobufEncoder::float4_field(_QWORD *result, uint64_t a2, float32x4_t a3)
{
  _QWORD *v3;
  float v4;
  int v5;

  if ((vminvq_u32((uint32x4_t)vceqzq_f32(a3)) & 0x80000000) == 0)
  {
    v3 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 2);
    RB::ProtobufEncoder::begin_length_delimited(v3);
    if (a3.f32[0] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0xDuLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[0]);
    }
    if (a3.f32[1] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x15uLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[1]);
    }
    v4 = a3.f32[3];
    if (a3.f32[2] != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(v3, a3.i32[2]);
      v4 = a3.f32[3];
    }
    v5 = LODWORD(v4);
    if (v4 != 0.0)
    {
      RB::ProtobufEncoder::encode_varint(v3, 0x25uLL);
      RB::ProtobufEncoder::encode_fixed32(v3, v5);
    }
    return RB::ProtobufEncoder::end_length_delimited(v3);
  }
  return result;
}

_QWORD *RB::ProtobufEncoder::color_field(_QWORD *result, uint64_t a2, double a3)
{
  _QWORD *v4;

  if (a3 != 1.08420217e-19)
  {
    v4 = result;
    RB::ProtobufEncoder::encode_varint(result, (8 * a2) | 1);
    return RB::ProtobufEncoder::encode_fixed64(v4, *(uint64_t *)&a3);
  }
  return result;
}

_QWORD *RB::Encoder::shared_field_f(RB::Encoder *this, uint64_t a2, uint64_t *a3)
{
  uint64_t *v5;
  void *v7;

  RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(this);
  v7 = 0;
  v5 = RB::UntypedTable::lookup((RB::Encoder *)((char *)this + 80), a3, &v7);
  if (v7 != a3)
    *((_BYTE *)this + 48) = 1;
  RB::ProtobufEncoder::encode_varint(this, 8uLL);
  RB::ProtobufEncoder::encode_varint(this, (unint64_t)v5);
  return RB::ProtobufEncoder::end_length_delimited(this);
}

uint64_t *RB::Encoder::prepare_image(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  size_t *v7;
  const UInt8 *BytePtr;
  CFIndex Length;
  CFDataRef theData;

  if (a3)
  {
    v3 = (uint64_t)result;
    if ((*((_BYTE *)result + 164) & 1) == 0)
    {
      v4 = result[7];
      if (v4)
      {
        theData = 0;
        result = RB::UntypedTable::lookup((RB::UntypedTable *)(result + 10), a3, (void **)&theData);
        if (a3 != (uint64_t *)theData)
        {
          v7 = *(size_t **)(v3 + 72);
          *(_QWORD *)(v3 + 72) = (char *)v7 + 1;
          RB::UntypedTable::insert((size_t **)(v3 + 80), (size_t *)a3, v7);
          RB::ProtobufEncoder::encode_varint((_QWORD *)v3, 0x7AuLL);
          RB::ProtobufEncoder::begin_length_delimited((_QWORD *)v3);
          if (v7)
          {
            RB::ProtobufEncoder::encode_varint((_QWORD *)v3, 8uLL);
            RB::ProtobufEncoder::encode_varint((_QWORD *)v3, (unint64_t)v7);
          }
          RB::ProtobufEncoder::encode_varint((_QWORD *)v3, 0x12uLL);
          RB::ProtobufEncoder::begin_length_delimited((_QWORD *)v3);
          (*(void (**)(CFDataRef *__return_ptr, uint64_t, uint64_t, uint64_t *))(*(_QWORD *)v4 + 32))(&theData, v4, a2, a3);
          if (theData)
          {
            BytePtr = CFDataGetBytePtr(theData);
            Length = CFDataGetLength(theData);
            if (Length)
            {
              RB::ProtobufEncoder::encode_varint((_QWORD *)v3, 0xAuLL);
              RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)v3, BytePtr, Length);
            }
            if (theData)
              CFRelease(theData);
          }
          else
          {
            *(_BYTE *)(v3 + 48) = 1;
          }
          RB::ProtobufEncoder::end_length_delimited((_QWORD *)v3);
          return RB::ProtobufEncoder::end_length_delimited((_QWORD *)v3);
        }
      }
      else
      {
        *((_BYTE *)result + 48) = 1;
      }
    }
  }
  return result;
}

void sub_209B00710(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

RB::Encoder *RB::Encoder::image_field(RB::Encoder *result, uint64_t a2, int a3, uint64_t *a4)
{
  if (a4)
    return (RB::Encoder *)RB::Encoder::shared_field_f(result, a2, a4);
  return result;
}

uint64_t RB::Encoder::prepare_glyphs(RB::Encoder *this, CGFont *a2, unint64_t a3, const unsigned __int16 *a4)
{
  uint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int Identifier;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t result;
  int v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *v19;

  if (!*((_QWORD *)this + 8))
  {
    v6 = operator new();
    *(_DWORD *)(v6 + 8) = 1;
    *(_QWORD *)v6 = off_24C2242E8;
    *(_OWORD *)(v6 + 16) = 0u;
    *(_OWORD *)(v6 + 32) = 0u;
    *(_DWORD *)(v6 + 48) = 1065353216;
    v7 = (unsigned int *)*((_QWORD *)this + 8);
    *((_QWORD *)this + 8) = v6;
    if (v7)
    {
      v8 = v7 + 2;
      do
      {
        v9 = __ldxr(v8);
        v10 = v9 - 1;
      }
      while (__stlxr(v10, v8));
      if (!v10)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
      }
    }
  }
  Identifier = CGFontGetIdentifier();
  v12 = *((_QWORD *)this + 8) + 16;
  v18 = Identifier;
  v19 = &v18;
  v13 = std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(v12, &v18, (uint64_t)std::piecewise_construct, &v19);
  v14 = v13;
  if (a2 && !*(_QWORD *)(v13 + 24))
    *(_QWORD *)(v13 + 24) = CFRetain(a2);
  result = CGFontIndexSetAddIndexes();
  if ((*((_BYTE *)this + 164) & 1) == 0)
  {
    v16 = *((_DWORD *)this + 40);
    if (*(_DWORD *)(v14 + 56) != v16)
    {
      *(_DWORD *)(v14 + 56) = v16;
      v17 = *((_QWORD *)this + 9);
      *((_QWORD *)this + 9) = v17 + 1;
      *(_QWORD *)(v14 + 64) = v17;
    }
  }
  return result;
}

void RB::Encoder::prepare_fonts(RB::Encoder *this)
{
  uint64_t v1;
  uint64_t *i;
  unint64_t v4;
  const UInt8 *BytePtr;
  CFIndex Length;
  unint64_t v7;

  v1 = *((_QWORD *)this + 8);
  if (v1)
  {
    if ((*((_BYTE *)this + 164) & 1) == 0)
    {
      for (i = *(uint64_t **)(v1 + 32); i; i = (uint64_t *)*i)
      {
        RB::Encoder::FontSet::Font::ensure_data((RB::Encoder::FontSet::Font *)(i + 3), this);
        if (*((_DWORD *)i + 14) == *((_DWORD *)this + 40) && i[4])
        {
          RB::ProtobufEncoder::encode_varint(this, 0x7AuLL);
          RB::ProtobufEncoder::begin_length_delimited(this);
          v4 = i[8];
          if (v4)
          {
            RB::ProtobufEncoder::encode_varint(this, 8uLL);
            RB::ProtobufEncoder::encode_varint(this, v4);
          }
          RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
          RB::ProtobufEncoder::begin_length_delimited(this);
          BytePtr = CFDataGetBytePtr((CFDataRef)i[4]);
          Length = CFDataGetLength((CFDataRef)i[4]);
          if (Length)
          {
            v7 = Length;
            RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
            RB::ProtobufEncoder::encode_data(this, BytePtr, v7);
          }
          RB::ProtobufEncoder::end_length_delimited(this);
          RB::ProtobufEncoder::end_length_delimited(this);
        }
        else
        {
          *((_BYTE *)this + 48) = 1;
        }
      }
    }
  }
}

void RB::Encoder::FontSet::Font::ensure_data(RB::Encoder::FontSet::Font *this, RB::Encoder *a2)
{
  uint64_t v2;
  int FontSubsetFormat;
  int v5;
  const void *Property;
  const void *FontSubset;
  const char *Name;
  const char *PostScriptName;
  BOOL v10;
  uint64_t Count;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  __int16 *v18;
  int v19;
  __int16 *v20;
  uint64_t v21;
  char v22;
  char *v24;
  char *v25;
  char *v26[2];

  v26[1] = *(char **)MEMORY[0x24BDAC8D0];
  if (*((_QWORD *)this + 1))
    return;
  v2 = *((_QWORD *)a2 + 7);
  if (!v2)
    return;
  if (!(*(unsigned int (**)(uint64_t, _QWORD))(*(_QWORD *)v2 + 8))(v2, *(_QWORD *)this))
    goto LABEL_35;
  FontSubsetFormat = CGFontGetFontSubsetFormat();
  if (!FontSubsetFormat)
    goto LABEL_35;
  v5 = FontSubsetFormat;
  if (FontSubsetFormat != 1)
  {
    Property = (const void *)CGFontGetProperty();
    if (Property)
    {
      FontSubset = CFRetain(Property);
      if (FontSubset)
        goto LABEL_32;
    }
  }
  v26[0] = 0;
  Name = (const char *)CGFontIndexSetGetName();
  PostScriptName = (const char *)CGFontGetPostScriptName();
  asprintf(v26, "%s+%s", Name, PostScriptName);
  *((_QWORD *)this + 3) = CGFontIndexMapCreate();
  FontSubset = (const void *)CGFontCreateFontSubset();
  free(v26[0]);
  v10 = v5 == 1;
  if (!FontSubset)
    v10 = 1;
  if (!v10)
  {
    Count = CGFontIndexSetGetCount();
    v13 = Count;
    if (Count < 0)
    {
LABEL_32:
      (*(void (**)(char **__return_ptr, uint64_t, _QWORD, const void *, _QWORD, _QWORD))(*(_QWORD *)v2 + 24))(v26, v2, *(_QWORD *)this, FontSubset, *((_QWORD *)this + 2), *((_QWORD *)this + 3));
      v24 = (char *)*((_QWORD *)this + 1);
      *((char **)this + 1) = v26[0];
      v26[0] = v24;
      if (v24)
        CFRelease(v24);
      CFRelease(FontSubset);
      goto LABEL_35;
    }
    v14 = 2 * Count;
    if ((unint64_t)(2 * Count) > 0x1000)
    {
      v15 = (char *)malloc_type_malloc(2 * Count, 0xF07D14F5uLL);
      v20 = (__int16 *)malloc_type_malloc(2 * v13, 0x5FE3BA16uLL);
      v18 = v20;
      v19 = 1;
      if (!v15 || !v20)
      {
LABEL_28:
        free(v18);
LABEL_29:
        if (v19)
          free(v15);
        goto LABEL_31;
      }
    }
    else
    {
      MEMORY[0x24BDAC7A8](Count, v12);
      v15 = (char *)v26 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v15, 2 * v13);
      MEMORY[0x24BDAC7A8](v16, v17);
      v18 = (__int16 *)v15;
      bzero(v15, 2 * v13);
      v19 = 0;
    }
    CGFontIndexSetGetIndexes();
    CGFontIndexMapGetValues();
    if (!v13)
      goto LABEL_29;
    v21 = 0;
    v22 = 0;
    do
    {
      while (v18[v21] == -1)
      {
        v18[v21] = v21 + 1;
        v22 = 1;
        if (v13 - 1 == v21++)
          goto LABEL_26;
      }
      ++v21;
    }
    while (v13 != v21);
    if ((v22 & 1) == 0)
      goto LABEL_27;
LABEL_26:
    CGFontIndexMapAddIndexes();
LABEL_27:
    if (v14 <= 0x1000)
      goto LABEL_29;
    goto LABEL_28;
  }
LABEL_31:
  if (FontSubset)
    goto LABEL_32;
LABEL_35:
  if (!*((_QWORD *)this + 1))
  {
    (*(void (**)(char **__return_ptr, uint64_t, _QWORD))(*(_QWORD *)v2 + 16))(v26, v2, *(_QWORD *)this);
    v25 = (char *)*((_QWORD *)this + 1);
    *((char **)this + 1) = v26[0];
    v26[0] = v25;
    if (v25)
      CFRelease(v25);
  }
}

void sub_209B00CB0(_Unwind_Exception *a1)
{
  const void *v1;
  void *v2;
  unint64_t v3;
  void *v4;

  if (v3 > 0x1000)
  {
    free(v4);
    free(v2);
  }
  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::Encoder::FontSet::Font::~Font(RB::Encoder::FontSet::Font *this)
{
  const void *v2;

  if (*((_QWORD *)this + 2))
    CGFontIndexSetRelease();
  if (*((_QWORD *)this + 3))
    CGFontIndexMapRelease();
  v2 = (const void *)*((_QWORD *)this + 1);
  if (v2)
    CFRelease(v2);
  if (*(_QWORD *)this)
    CFRelease(*(CFTypeRef *)this);
}

void sub_209B00D50(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 + 8);
  if (v3)
    CFRelease(v3);
  if (*(_QWORD *)v1)
    CFRelease(*(CFTypeRef *)v1);
  _Unwind_Resume(exception_object);
}

uint64_t *RB::Encoder::cgfont_field(RB::Encoder *this, uint64_t a2, CGFont *a3)
{
  unsigned int Identifier;
  _QWORD *v6;
  uint64_t *result;
  uint64_t v8;
  RB::Encoder::FontSet::Font *v9;
  unint64_t v10;
  unsigned int v11;

  if (!a3)
    return 0;
  if (*((_QWORD *)this + 8))
  {
    Identifier = CGFontGetIdentifier();
    v6 = (_QWORD *)(*((_QWORD *)this + 8) + 16);
    v11 = Identifier;
    result = std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::find<unsigned int>(v6, &v11);
    if (result)
    {
      v8 = (uint64_t)result;
      v9 = (RB::Encoder::FontSet::Font *)(result + 3);
      RB::ProtobufEncoder::encode_varint(this, (8 * a2) | 2);
      RB::ProtobufEncoder::begin_length_delimited(this);
      v10 = *(_QWORD *)(v8 + 64);
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v10);
      RB::ProtobufEncoder::end_length_delimited(this);
      RB::Encoder::FontSet::Font::ensure_data(v9, this);
      return *(uint64_t **)(v8 + 48);
    }
  }
  else
  {
    result = 0;
  }
  *((_BYTE *)this + 48) = 1;
  return result;
}

uint64_t RB::ProtobufDecoder::decode_varint(RB::ProtobufDecoder *this)
{
  unint64_t v2;
  uint64_t v3;
  char v4;
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  v3 = *(_QWORD *)this;
  v2 = *((_QWORD *)this + 1);
  if (*(_QWORD *)this >= v2)
  {
LABEL_5:
    result = 0;
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = v2;
  }
  else
  {
    v4 = 0;
    result = 0;
    v6 = v2 - v3;
    v7 = v3 + 1;
    while (1)
    {
      *(_QWORD *)this = v7;
      result |= (unint64_t)(*(_BYTE *)(v7 - 1) & 0x7F) << v4;
      if ((*(_BYTE *)(v7 - 1) & 0x80) == 0)
        break;
      v4 += 7;
      ++v7;
      if (!--v6)
        goto LABEL_5;
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::decode_data(RB::ProtobufDecoder *this)
{
  uint64_t v2;
  uint64_t result;
  unint64_t v4;

  v2 = RB::ProtobufDecoder::decode_varint(this);
  result = *(_QWORD *)this;
  v4 = *((_QWORD *)this + 1);
  if (__CFADD__(*(_QWORD *)this, v2) || *(_QWORD *)this + v2 > v4)
  {
    result = 0;
    *((_BYTE *)this + 56) = 1;
  }
  else
  {
    v4 = *(_QWORD *)this + v2;
  }
  *(_QWORD *)this = v4;
  return result;
}

uint64_t RB::ProtobufDecoder::begin_message(RB::ProtobufDecoder *this)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v5;
  unint64_t v6;

  v2 = *((_QWORD *)this + 5);
  v3 = v2 + 1;
  if (*((_QWORD *)this + 6) < (unint64_t)(v2 + 1))
  {
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)this + 32, v3);
    v2 = *((_QWORD *)this + 5);
    v3 = v2 + 1;
  }
  *(_QWORD *)(*((_QWORD *)this + 4) + 8 * v2) = *((_QWORD *)this + 1);
  *((_QWORD *)this + 5) = v3;
  result = RB::ProtobufDecoder::decode_varint(this);
  v5 = *((_QWORD *)this + 1);
  v6 = *(_QWORD *)this + result;
  if (__CFADD__(*(_QWORD *)this, result) || v6 > v5)
  {
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = v5;
  }
  else
  {
    *((_QWORD *)this + 1) = v6;
  }
  return result;
}

uint64_t RB::ProtobufDecoder::next_field(RB::ProtobufDecoder *this)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v5;

  v3 = *(_QWORD *)this;
  v2 = *((_QWORD *)this + 1);
  if (*(_QWORD *)this >= v2)
  {
    result = 0;
    *((_QWORD *)this + 2) = 0;
  }
  else
  {
    result = *((_QWORD *)this + 2);
    if (result)
    {
      v5 = *((_QWORD *)this + 3);
      if (v3 < v5)
        return result;
      if (v3 > v5)
      {
        *((_BYTE *)this + 56) = 1;
        *(_QWORD *)this = v2;
      }
      *((_QWORD *)this + 2) = 0;
    }
    result = RB::ProtobufDecoder::decode_varint(this);
    if ((result & 0x7FFFFFFF8) == 0)
    {
      result = 0;
      *((_BYTE *)this + 56) = 1;
      *(_QWORD *)this = *((_QWORD *)this + 1);
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::end_message(uint64_t this)
{
  if (!*(_BYTE *)(this + 56) && *(_QWORD *)this <= *(_QWORD *)(this + 8))
    *(_QWORD *)(this + 8) = *(_QWORD *)(*(_QWORD *)(this + 32) + 8 * *(_QWORD *)(this + 40) - 8);
  --*(_QWORD *)(this + 40);
  return this;
}

uint64_t RB::ProtobufDecoder::begin_packed(RB::ProtobufDecoder *a1, int a2, unint64_t a3)
{
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t result;

  v6 = RB::ProtobufDecoder::decode_varint(a1);
  v7 = *((_QWORD *)a1 + 1);
  v8 = *(_QWORD *)a1 + v6;
  if (__CFADD__(*(_QWORD *)a1, v6) || !v6 || v8 > v7)
  {
    result = 0;
    *((_BYTE *)a1 + 56) = 1;
    *(_QWORD *)a1 = v7;
  }
  else
  {
    *((_QWORD *)a1 + 2) = a2 & 0xFFFFFFF8 | a3;
    *((_QWORD *)a1 + 3) = v8;
    return 1;
  }
  return result;
}

RB::ProtobufDecoder *RB::ProtobufDecoder::skip_field(RB::ProtobufDecoder *result, uint64_t a2)
{
  uint64_t v2;

  if (a2)
  {
    switch(a2 & 7)
    {
      case 0:
        result = (RB::ProtobufDecoder *)RB::ProtobufDecoder::decode_varint(result);
        break;
      case 1:
        v2 = *(_QWORD *)result + 8;
        goto LABEL_7;
      case 2:
        result = (RB::ProtobufDecoder *)RB::ProtobufDecoder::decode_data(result);
        break;
      case 5:
        v2 = *(_QWORD *)result + 4;
LABEL_7:
        *(_QWORD *)result = v2;
        break;
      default:
        return result;
    }
  }
  return result;
}

uint64_t RB::ProtobufDecoder::BOOL_field(RB::ProtobufDecoder *this, uint64_t a2)
{
  unint64_t v3;
  BOOL v4;
  uint64_t result;

  if (!a2)
    return 0;
  switch(a2 & 7)
  {
    case 0:
      return RB::ProtobufDecoder::decode_varint(this) != 0;
    case 1:
      v3 = *(_QWORD *)this + 8;
      if (v3 > *((_QWORD *)this + 1))
        goto LABEL_9;
      v4 = **(_QWORD **)this == 0;
      goto LABEL_12;
    case 2:
      result = RB::ProtobufDecoder::begin_packed(this, a2, 0);
      if ((_DWORD)result)
        return RB::ProtobufDecoder::decode_varint(this) != 0;
      return result;
    case 5:
      v3 = *(_QWORD *)this + 4;
      if (v3 <= *((_QWORD *)this + 1))
      {
        v4 = **(_DWORD **)this == 0;
LABEL_12:
        result = !v4;
      }
      else
      {
LABEL_9:
        result = 0;
      }
LABEL_15:
      *(_QWORD *)this = v3;
      break;
    default:
      result = 0;
      *((_BYTE *)this + 56) = 1;
      v3 = *((_QWORD *)this + 1);
      goto LABEL_15;
  }
  return result;
}

uint64_t RB::ProtobufDecoder::uint_field(RB::ProtobufDecoder *this, uint64_t a2)
{
  unint64_t v3;
  uint64_t result;
  int v5;

  if (!a2)
    return 0;
  switch(a2 & 7)
  {
    case 0:
      return RB::ProtobufDecoder::decode_varint(this);
    case 1:
      v3 = *(_QWORD *)this + 8;
      if (v3 > *((_QWORD *)this + 1))
        goto LABEL_9;
      result = **(_QWORD **)this;
      break;
    case 2:
      v5 = RB::ProtobufDecoder::begin_packed(this, a2, 0);
      result = 0;
      if (v5)
        return RB::ProtobufDecoder::decode_varint(this);
      return result;
    case 5:
      v3 = *(_QWORD *)this + 4;
      if (v3 <= *((_QWORD *)this + 1))
        result = **(unsigned int **)this;
      else
LABEL_9:
        result = 0;
      break;
    default:
      result = 0;
      *((_BYTE *)this + 56) = 1;
      v3 = *((_QWORD *)this + 1);
      break;
  }
  *(_QWORD *)this = v3;
  return result;
}

float RB::ProtobufDecoder::float_field(RB::ProtobufDecoder *a1, uint64_t a2)
{
  float v2;
  int v4;
  unint64_t v5;

  v2 = 0.0;
  if (a2)
  {
    v4 = a2 & 7;
    if (v4 == 1)
    {
      v5 = *(_QWORD *)a1 + 8;
      if (v5 <= *((_QWORD *)a1 + 1))
        v2 = **(double **)a1;
      goto LABEL_11;
    }
    if (v4 == 5)
      goto LABEL_6;
    if (v4 != 2)
    {
      *((_BYTE *)a1 + 56) = 1;
      v5 = *((_QWORD *)a1 + 1);
LABEL_11:
      *(_QWORD *)a1 = v5;
      return v2;
    }
    if (RB::ProtobufDecoder::begin_packed(a1, a2, 5uLL))
    {
LABEL_6:
      v5 = *(_QWORD *)a1 + 4;
      if (v5 <= *((_QWORD *)a1 + 1))
        v2 = **(float **)a1;
      goto LABEL_11;
    }
  }
  return v2;
}

double RB::ProtobufDecoder::double_field(RB::ProtobufDecoder *a1, uint64_t a2)
{
  double v2;
  int v4;
  unint64_t v5;

  v2 = 0.0;
  if (a2)
  {
    v4 = a2 & 7;
    if (v4 == 1)
      goto LABEL_6;
    if (v4 == 5)
    {
      v5 = *(_QWORD *)a1 + 4;
      if (v5 <= *((_QWORD *)a1 + 1))
        v2 = **(float **)a1;
      goto LABEL_11;
    }
    if (v4 != 2)
    {
      *((_BYTE *)a1 + 56) = 1;
      v5 = *((_QWORD *)a1 + 1);
LABEL_11:
      *(_QWORD *)a1 = v5;
      return v2;
    }
    if (RB::ProtobufDecoder::begin_packed(a1, a2, 1uLL))
    {
LABEL_6:
      v5 = *(_QWORD *)a1 + 8;
      if (v5 <= *((_QWORD *)a1 + 1))
        v2 = **(double **)a1;
      goto LABEL_11;
    }
  }
  return v2;
}

__n128 RB::ProtobufDecoder::float2_field(RB::ProtobufDecoder *this, char a2, __n128 a3)
{
  uint64_t field;
  __int128 v5;
  unint64_t v6;
  float v7;
  __int128 v8;
  float v9;
  __int128 v11;

  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      v6 = field;
      *(_QWORD *)&v5 = 0;
      v11 = v5;
      while (1)
      {
        if ((v6 >> 3) == 2)
        {
          v9 = RB::ProtobufDecoder::float_field(this, v6);
          v8 = v11;
          *((float *)&v8 + 1) = v9;
        }
        else
        {
          if ((v6 >> 3) != 1)
          {
            RB::ProtobufDecoder::skip_field(this, v6);
            goto LABEL_10;
          }
          v7 = RB::ProtobufDecoder::float_field(this, v6);
          v8 = v11;
          *(float *)&v8 = v7;
        }
        v11 = v8;
LABEL_10:
        v6 = RB::ProtobufDecoder::next_field(this);
        if (!v6)
          goto LABEL_13;
      }
    }
    *(_QWORD *)&v5 = 0;
    v11 = v5;
LABEL_13:
    if (!*((_BYTE *)this + 56) && *(_QWORD *)this <= *((_QWORD *)this + 1))
      *((_QWORD *)this + 1) = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 5) - 8);
    --*((_QWORD *)this + 5);
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
    a3.n128_u64[0] = 0;
    return a3;
  }
  return (__n128)v11;
}

__n128 RB::ProtobufDecoder::float3_field(RB::ProtobufDecoder *this, char a2)
{
  uint64_t field;
  unint64_t v4;
  unint64_t v5;
  float v6;
  __int128 v7;
  float v8;
  float v9;
  __int128 v11;

  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      v4 = field;
      v11 = 0u;
      while (1)
      {
        v5 = v4 >> 3;
        if ((v4 >> 3) == 3)
        {
          v8 = RB::ProtobufDecoder::float_field(this, v4);
          v7 = v11;
          *((float *)&v7 + 2) = v8;
        }
        else if ((_DWORD)v5 == 2)
        {
          v9 = RB::ProtobufDecoder::float_field(this, v4);
          v7 = v11;
          *((float *)&v7 + 1) = v9;
        }
        else
        {
          if ((_DWORD)v5 != 1)
          {
            RB::ProtobufDecoder::skip_field(this, v4);
            goto LABEL_12;
          }
          v6 = RB::ProtobufDecoder::float_field(this, v4);
          v7 = v11;
          *(float *)&v7 = v6;
        }
        v11 = v7;
LABEL_12:
        v4 = RB::ProtobufDecoder::next_field(this);
        if (!v4)
          goto LABEL_15;
      }
    }
    v11 = 0u;
LABEL_15:
    if (!*((_BYTE *)this + 56) && *(_QWORD *)this <= *((_QWORD *)this + 1))
      *((_QWORD *)this + 1) = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 5) - 8);
    --*((_QWORD *)this + 5);
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
    return (__n128)0;
  }
  return (__n128)v11;
}

__n128 RB::ProtobufDecoder::float4_field(RB::ProtobufDecoder *this, char a2)
{
  uint64_t field;
  unint64_t v4;
  float v5;
  __int128 v6;
  float v7;
  float v8;
  float v9;
  __int128 v11;

  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message(this);
    field = RB::ProtobufDecoder::next_field(this);
    if (field)
    {
      v4 = field;
      v11 = 0u;
      do
      {
        switch((v4 >> 3))
        {
          case 1u:
            v5 = RB::ProtobufDecoder::float_field(this, v4);
            v6 = v11;
            *(float *)&v6 = v5;
            goto LABEL_10;
          case 2u:
            v7 = RB::ProtobufDecoder::float_field(this, v4);
            v6 = v11;
            *((float *)&v6 + 1) = v7;
            goto LABEL_10;
          case 3u:
            v8 = RB::ProtobufDecoder::float_field(this, v4);
            v6 = v11;
            *((float *)&v6 + 2) = v8;
            goto LABEL_10;
          case 4u:
            v9 = RB::ProtobufDecoder::float_field(this, v4);
            v6 = v11;
            *((float *)&v6 + 3) = v9;
LABEL_10:
            v11 = v6;
            break;
          default:
            RB::ProtobufDecoder::skip_field(this, v4);
            break;
        }
        v4 = RB::ProtobufDecoder::next_field(this);
      }
      while (v4);
    }
    else
    {
      v11 = 0u;
    }
    if (!*((_BYTE *)this + 56) && *(_QWORD *)this <= *((_QWORD *)this + 1))
      *((_QWORD *)this + 1) = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 5) - 8);
    --*((_QWORD *)this + 5);
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
    return (__n128)0;
  }
  return (__n128)v11;
}

double RB::ProtobufDecoder::color_field(unint64_t *a1, uint64_t a2)
{
  unint64_t v3;
  double v4;

  if (a2)
  {
    if ((a2 & 7) != 1)
    {
      if ((a2 & 7) != 2)
      {
        *((_BYTE *)a1 + 56) = 1;
        v3 = a1[1];
        v4 = 1.08420217e-19;
LABEL_10:
        *a1 = v3;
        return v4;
      }
      if (!RB::ProtobufDecoder::begin_packed((RB::ProtobufDecoder *)a1, a2, 1uLL))
        return 1.08420217e-19;
    }
    v3 = *a1 + 8;
    if (v3 <= a1[1])
      v4 = *(double *)*a1;
    else
      v4 = 0.0;
    goto LABEL_10;
  }
  return 1.08420217e-19;
}

uint64_t RB::ProtobufDecoder::data_field(RB::ProtobufDecoder *this, uint64_t a2)
{
  uint64_t result;

  if (!a2)
    return 0;
  if ((a2 & 7) == 2)
    return RB::ProtobufDecoder::decode_data(this);
  result = 0;
  *((_BYTE *)this + 56) = 1;
  *(_QWORD *)this = *((_QWORD *)this + 1);
  return result;
}

char *RB::Decoder::push_shared(char *this, char a2)
{
  char *v2;
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  unint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  __int128 v10;

  v2 = this;
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
    this = (char *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)v2);
    if (this)
    {
      v3 = (unint64_t)this;
      v4 = 0;
      v5 = 0;
      v6 = 0;
      do
      {
        switch((v3 >> 3))
        {
          case 1u:
            v4 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)v2, v3);
            break;
          case 2u:
            v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            v6 = v3;
            v5 = 2;
            break;
          case 3u:
            v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            v6 = v3;
            v5 = 3;
            break;
          case 4u:
            v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            v6 = v3;
            v5 = 4;
            break;
          case 5u:
            v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            v6 = v3;
            v5 = 5;
            break;
          case 6u:
            v10 = *(_OWORD *)v2;
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            v6 = v3;
            v5 = 6;
            break;
          default:
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)v2, v3);
            break;
        }
        this = (char *)RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)v2);
        v3 = (unint64_t)this;
      }
      while (this);
      if (v5)
      {
        v7 = v2[228];
        v8 = *((_QWORD *)v2 + 21);
        if (v7)
        {
          if (v8)
            v7 = v4 > *(_QWORD *)(*((_QWORD *)v2 + 20) + 40 * v8 - 40);
          else
            v7 = 1;
        }
        v2[228] = v7;
        if (*((_QWORD *)v2 + 22) < (unint64_t)(v8 + 1))
        {
          this = (char *)RB::vector<RB::Decoder::SharedField,0ul,unsigned long>::reserve_slow((uint64_t)(v2 + 160), v8 + 1);
          v8 = *((_QWORD *)v2 + 21);
        }
        v9 = *((_QWORD *)v2 + 20) + 40 * v8;
        *(_QWORD *)v9 = v4;
        *(_QWORD *)(v9 + 8) = v5;
        *(_OWORD *)(v9 + 16) = v10;
        *(_QWORD *)(v9 + 32) = v6;
        ++*((_QWORD *)v2 + 21);
      }
    }
    if (!v2[56] && *(_QWORD *)v2 <= *((_QWORD *)v2 + 1))
      *((_QWORD *)v2 + 1) = *(_QWORD *)(*((_QWORD *)v2 + 4) + 8 * *((_QWORD *)v2 + 5) - 8);
    --*((_QWORD *)v2 + 5);
  }
  else
  {
    this[56] = 1;
    *(_QWORD *)this = *((_QWORD *)this + 1);
  }
  return this;
}

void RB::Decoder::saved_shared_field(uint64_t a1@<X0>, uint64_t a2@<X1>, unint64_t a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  unint64_t *v16;
  _QWORD *v17;
  unint64_t v18;
  __int128 v19;

  if (!*(_BYTE *)(a1 + 228))
  {
    v8 = *(_QWORD *)(a1 + 160);
    v9 = *(_QWORD *)(a1 + 168);
    v10 = 126 - 2 * __clz(v9);
    if (v9)
      v11 = v10;
    else
      v11 = 0;
    std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(v8, v8 + 40 * v9, v11, 1);
    *(_BYTE *)(a1 + 228) = 1;
  }
  v12 = *(_QWORD *)(a1 + 168);
  if (!v12)
    goto LABEL_16;
  v13 = *(_QWORD **)(a1 + 160);
  v14 = &v13[5 * v12];
  do
  {
    v15 = v12 >> 1;
    v16 = &v13[5 * (v12 >> 1)];
    v18 = *v16;
    v17 = v16 + 5;
    v12 += ~(v12 >> 1);
    if (v18 < a3)
      v13 = v17;
    else
      v12 = v15;
  }
  while (v12);
  if (v13 != v14 && *v13 == a3 && v13[1] == a2)
  {
    v19 = *((_OWORD *)v13 + 1);
    *(_QWORD *)(a4 + 16) = v13[4];
    *(_OWORD *)a4 = v19;
  }
  else
  {
LABEL_16:
    *(_QWORD *)(a4 + 16) = 0;
  }
}

_QWORD *RB::Decoder::decode_image(RB::Decoder *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t field;
  int v5;
  CFTypeRef v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  CFTypeRef v10;
  _QWORD *result;
  uint64_t v12;
  CFTypeRef cf;

  v2 = *((_QWORD *)this + 9);
  if (v2 && (v3 = RB::ProtobufDecoder::next_field(this)) != 0)
  {
    field = v3;
    v5 = 0;
    v6 = 0;
    do
    {
      if ((field & 0x7FFFFFFF8) == 8)
      {
        if ((field & 7) == 2)
        {
          v7 = RB::ProtobufDecoder::decode_data(this);
          v9 = v8;
        }
        else
        {
          v7 = 0;
          v9 = 0;
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
        (*(void (**)(uint64_t *__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v2 + 16))(&v12, v2, v7, v9);
        v10 = cf;
        if (cf)
        {
          v5 = v12;
          cf = 0;
          RB::ObjectTable::adopt((RB::Decoder *)((char *)this + 184), v10);
          if (cf)
            CFRelease(cf);
          v6 = v10;
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *(_QWORD *)this = *((_QWORD *)this + 1);
        }
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, field);
      }
      field = RB::ProtobufDecoder::next_field(this);
    }
    while (field);
  }
  else
  {
    v6 = 0;
    v5 = 0;
  }
  result = RB::Heap::emplace<RBImage>(*((size_t **)this + 8));
  *(_DWORD *)result = v5;
  result[1] = v6;
  return result;
}

void sub_209B01C14(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Decoder::image_field(RB::ProtobufDecoder *this, char a2)
{
  uint64_t field;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  uint64_t result;
  __int128 v9;
  __int128 v10;
  uint64_t *v11;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  void *v15[2];
  uint64_t v16;

  if (!*((_QWORD *)this + 9))
    return 0;
  if ((a2 & 7) != 2)
    goto LABEL_29;
  RB::ProtobufDecoder::begin_message(this);
  field = RB::ProtobufDecoder::next_field(this);
  if (field)
  {
    v4 = field;
    v5 = 0;
    v6 = 0;
    do
    {
      if ((v4 >> 3) == 2)
      {
        v13 = *(_OWORD *)this;
        RB::ProtobufDecoder::skip_field(this, v4);
        v6 = v4;
      }
      else if ((v4 >> 3) == 1)
      {
        v5 = RB::ProtobufDecoder::uint_field(this, v4);
      }
      else
      {
        RB::ProtobufDecoder::skip_field(this, v4);
      }
      v4 = RB::ProtobufDecoder::next_field(this);
    }
    while (v4);
    if (v5 >> 61)
    {
      v7 = 0;
      goto LABEL_23;
    }
  }
  else
  {
    v5 = 0;
    v6 = 0;
  }
  v15[0] = 0;
  v7 = RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0x4000000000000000), v15);
  if ((void *)(v5 | 0x4000000000000000) != v15[0])
  {
    v9 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 2, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_22:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0x4000000000000000), (size_t *)v7);
        goto LABEL_23;
      }
      v9 = *(_OWORD *)v15;
    }
    v10 = *(_OWORD *)this;
    *(_OWORD *)this = v9;
    if ((v6 & 7) == 2)
    {
      v14 = v10;
      RB::ProtobufDecoder::begin_message(this);
      v11 = RB::Decoder::decode_image(this);
      v10 = v14;
      v7 = v11;
      --*((_QWORD *)this + 5);
    }
    else
    {
      *((_BYTE *)this + 56) = 1;
    }
    *(_OWORD *)this = v10;
    goto LABEL_22;
  }
LABEL_23:
  if (!*((_BYTE *)this + 56) && *(_QWORD *)this <= *((_QWORD *)this + 1))
    *((_QWORD *)this + 1) = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 5) - 8);
  --*((_QWORD *)this + 5);
  if (!v7)
  {
LABEL_29:
    result = 0;
    v12 = *((_QWORD *)this + 1);
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = v12;
    return result;
  }
  return *v7;
}

CFTypeRef RB::Decoder::decode_cgfont(RB::Decoder *this)
{
  uint64_t v1;
  uint64_t field;
  uint64_t v4;
  CFTypeRef v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  CFTypeRef v9;
  CFTypeRef cf;

  v1 = *((_QWORD *)this + 9);
  if (!v1)
    return 0;
  field = RB::ProtobufDecoder::next_field(this);
  if (!field)
    return 0;
  v4 = field;
  v5 = 0;
  do
  {
    if ((v4 & 0x7FFFFFFF8) == 8)
    {
      if ((v4 & 7) == 2)
      {
        v6 = RB::ProtobufDecoder::decode_data(this);
        v8 = v7;
      }
      else
      {
        v6 = 0;
        v8 = 0;
        *((_BYTE *)this + 56) = 1;
        *(_QWORD *)this = *((_QWORD *)this + 1);
      }
      (*(void (**)(CFTypeRef *__return_ptr, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v1 + 8))(&cf, v1, v6, v8);
      v9 = cf;
      if (cf)
      {
        cf = 0;
        RB::ObjectTable::adopt((RB::Decoder *)((char *)this + 184), v9);
        if (cf)
          CFRelease(cf);
        v5 = v9;
      }
      else
      {
        *((_BYTE *)this + 56) = 1;
        *(_QWORD *)this = *((_QWORD *)this + 1);
      }
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  return v5;
}

void sub_209B01F20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t *RB::Decoder::cgfont_field(RB::ProtobufDecoder *this, char a2)
{
  uint64_t field;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  uint64_t *v7;
  __int128 v8;
  __int128 v9;
  uint64_t *v10;
  uint64_t v12;
  __int128 v13;
  __int128 v14;
  void *v15[2];
  uint64_t v16;

  if (!*((_QWORD *)this + 9))
    return 0;
  if ((a2 & 7) != 2)
  {
LABEL_28:
    v7 = 0;
    v12 = *((_QWORD *)this + 1);
    *((_BYTE *)this + 56) = 1;
    *(_QWORD *)this = v12;
    return v7;
  }
  RB::ProtobufDecoder::begin_message(this);
  field = RB::ProtobufDecoder::next_field(this);
  if (!field)
  {
    v5 = 0;
    v6 = 0;
    goto LABEL_15;
  }
  v4 = field;
  v5 = 0;
  v6 = 0;
  do
  {
    if ((v4 >> 3) == 2)
    {
      v13 = *(_OWORD *)this;
      RB::ProtobufDecoder::skip_field(this, v4);
      v6 = v4;
    }
    else if ((v4 >> 3) == 1)
    {
      v5 = RB::ProtobufDecoder::uint_field(this, v4);
    }
    else
    {
      RB::ProtobufDecoder::skip_field(this, v4);
    }
    v4 = RB::ProtobufDecoder::next_field(this);
  }
  while (v4);
  if (!(v5 >> 61))
  {
LABEL_15:
    v15[0] = 0;
    v7 = RB::UntypedTable::lookup((RB::ProtobufDecoder *)((char *)this + 80), (uint64_t *)(v5 | 0x6000000000000000), v15);
    if ((void *)(v5 | 0x6000000000000000) == v15[0])
      goto LABEL_23;
    v8 = v13;
    if (!v6)
    {
      RB::Decoder::saved_shared_field((uint64_t)this, 3, v5, (uint64_t)v15);
      LOBYTE(v6) = v16;
      if (!v16)
      {
LABEL_22:
        RB::UntypedTable::insert((size_t **)this + 10, (size_t *)(v5 | 0x6000000000000000), (size_t *)v7);
        goto LABEL_23;
      }
      v8 = *(_OWORD *)v15;
    }
    v9 = *(_OWORD *)this;
    *(_OWORD *)this = v8;
    if ((v6 & 7) == 2)
    {
      v14 = v9;
      RB::ProtobufDecoder::begin_message(this);
      v10 = (uint64_t *)RB::Decoder::decode_cgfont(this);
      v9 = v14;
      v7 = v10;
      --*((_QWORD *)this + 5);
    }
    else
    {
      *((_BYTE *)this + 56) = 1;
    }
    *(_OWORD *)this = v9;
    goto LABEL_22;
  }
  v7 = 0;
LABEL_23:
  if (!*((_BYTE *)this + 56) && *(_QWORD *)this <= *((_QWORD *)this + 1))
    *((_QWORD *)this + 1) = *(_QWORD *)(*((_QWORD *)this + 4) + 8 * *((_QWORD *)this + 5) - 8);
  --*((_QWORD *)this + 5);
  if (!v7)
    goto LABEL_28;
  return v7;
}

int8x16_t RB::Decoder::affine_transform_field(size_t **this, char a2)
{
  float64x2_t *v3;
  int8x16_t result;
  size_t *v5;
  unint64_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;

  v8 = (float64x2_t)xmmword_209BD5290;
  v9 = (float64x2_t)xmmword_209BD52A0;
  v10 = 0uLL;
  if ((a2 & 7) == 2)
  {
    RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
    RB::AffineTransform::decode((RB::AffineTransform *)&v8, (RB::ProtobufDecoder *)this);
    if (!*((_BYTE *)this + 56) && *this <= this[1])
      this[1] = (size_t *)this[4][(_QWORD)this[5] - 1];
    this[5] = (size_t *)((char *)this[5] - 1);
  }
  else
  {
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
  v3 = (float64x2_t *)this[25];
  if (!v3
    || (result = vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v3[1], v9), (int8x16_t)vceqq_f64(*v3, v8)), (int8x16_t)vceqq_f64(v3[2], v10)), result.i64[0] = vandq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)result, 1), result).u64[0], (result.i64[0] & 0x8000000000000000) == 0))
  {
    v5 = this[8];
    v6 = (v5[2] + 15) & 0xFFFFFFFFFFFFFFF0;
    if (v6 + 48 > v5[3])
      v6 = RB::Heap::alloc_slow(this[8], 0x30uLL, 15);
    else
      v5[2] = v6 + 48;
    result = (int8x16_t)v8;
    v7 = v10;
    *(float64x2_t *)(v6 + 16) = v9;
    *(float64x2_t *)(v6 + 32) = v7;
    *(int8x16_t *)v6 = result;
    this[25] = (size_t *)v6;
  }
  return result;
}

uint64_t RB::Refcount<RB::Encoder::FontSet,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::Encoder::FontSet,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Encoder::FontSet::~FontSet(RB::Encoder::FontSet *this)
{
  *(_QWORD *)this = off_24C2242E8;
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table((uint64_t)this + 16);
}

{
  *(_QWORD *)this = off_24C2242E8;
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table((uint64_t)this + 16);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      RB::Encoder::FontSet::Font::~Font((RB::Encoder::FontSet::Font *)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *,false>(uint64_t a1, unint64_t a2, uint64_t a3, char a4)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t *v15;
  __int128 v16;
  __int128 v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  unint64_t v28;
  unint64_t v29;
  __int128 v30;
  __int128 v31;
  BOOL v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  unint64_t v40;
  __int128 v41;
  __int128 v42;
  unint64_t v43;
  unint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 *v47;
  __int128 *v48;
  __int128 *v49;
  unint64_t v50;
  unint64_t v51;
  __int128 v52;
  uint64_t v53;
  __int128 v54;
  __int128 v55;
  uint64_t v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  uint64_t v60;
  __int128 v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  unint64_t v65;
  BOOL v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  uint64_t v72;
  uint64_t v73;
  __int128 v74;
  uint64_t v75;
  int64_t v76;
  int64_t v77;
  int64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  BOOL v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  __int128 v86;
  __int128 v87;
  uint64_t v88;
  unint64_t v89;
  unint64_t v90;
  int64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  __int128 v97;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  unint64_t v104;
  uint64_t v105;
  __int128 v106;
  __int128 v107;
  uint64_t v109;
  unint64_t v110;
  __int128 v111;
  unint64_t v112;
  __int128 v113;
  __int128 v114;
  __int128 v115;
  __int128 v116;
  __int128 v117;
  __int128 v118;
  __int128 v119;
  __int128 v120;
  __int128 v121;
  __int128 v122;
  __int128 v123;
  __int128 v124;
  __int128 v125;
  __int128 v126;
  __int128 v127;
  __int128 v128;
  __int128 v129;
  __int128 v130;
  __int128 v131;
  __int128 v132;
  __int128 v133;
  __int128 v134;
  __int128 v135;
  __int128 v136;
  __int128 v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;

__int128 *std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(__int128 *result, unint64_t *a2, unint64_t *a3)
{
  unint64_t v3;
  unint64_t v4;
  __int128 v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  uint64_t v25;
  __int128 v26;

  v3 = *a2;
  v4 = *a3;
  if (*a2 >= *(_QWORD *)result)
  {
    if (v4 < v3)
    {
      v10 = *(_OWORD *)a2;
      v11 = *((_OWORD *)a2 + 1);
      v12 = a2[4];
      v13 = a3[4];
      v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v14;
      a2[4] = v13;
      a3[4] = v12;
      *(_OWORD *)a3 = v10;
      *((_OWORD *)a3 + 1) = v11;
      if (*a2 < *(_QWORD *)result)
      {
        v15 = *result;
        v16 = result[1];
        v17 = *((_QWORD *)result + 4);
        v18 = a2[4];
        v19 = *((_OWORD *)a2 + 1);
        *result = *(_OWORD *)a2;
        result[1] = v19;
        *((_QWORD *)result + 4) = v18;
        a2[4] = v17;
        *(_OWORD *)a2 = v15;
        *((_OWORD *)a2 + 1) = v16;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v20 = *result;
      v21 = result[1];
      v22 = *((_QWORD *)result + 4);
      v23 = a2[4];
      v24 = *((_OWORD *)a2 + 1);
      *result = *(_OWORD *)a2;
      result[1] = v24;
      *((_QWORD *)result + 4) = v23;
      a2[4] = v22;
      *(_OWORD *)a2 = v20;
      *((_OWORD *)a2 + 1) = v21;
      if (*a3 >= *a2)
        return result;
      v5 = *(_OWORD *)a2;
      v6 = *((_OWORD *)a2 + 1);
      v7 = a2[4];
      v25 = a3[4];
      v26 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v26;
      a2[4] = v25;
    }
    else
    {
      v5 = *result;
      v6 = result[1];
      v7 = *((_QWORD *)result + 4);
      v8 = a3[4];
      v9 = *((_OWORD *)a3 + 1);
      *result = *(_OWORD *)a3;
      result[1] = v9;
      *((_QWORD *)result + 4) = v8;
    }
    a3[4] = v7;
    *(_OWORD *)a3 = v5;
    *((_OWORD *)a3 + 1) = v6;
  }
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(uint64_t a1, uint64_t a2)
{
  unint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  __int128 v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v19;
  uint64_t v20;
  _QWORD *v21;
  _QWORD *v22;
  __int128 *v23;
  uint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  uint64_t v35;
  __int128 v36;
  __int128 v37;
  __int128 v38;
  uint64_t v39;
  __int128 v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;

  v4 = 0xCCCCCCCCCCCCCCCDLL * ((a2 - a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = (__int128 *)(a2 - 40);
      if (*(_QWORD *)(a2 - 40) < *(_QWORD *)a1)
      {
        v7 = *(_OWORD *)a1;
        v8 = *(_OWORD *)(a1 + 16);
        v9 = *(_QWORD *)(a1 + 32);
        v10 = *(_QWORD *)(a2 - 8);
        v11 = *(_OWORD *)(a2 - 24);
        *(_OWORD *)a1 = *v6;
        *(_OWORD *)(a1 + 16) = v11;
        *(_QWORD *)(a1 + 32) = v10;
        *(_QWORD *)(a2 - 8) = v9;
        *v6 = v7;
        *(_OWORD *)(a2 - 24) = v8;
      }
      return result;
    case 3uLL:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)a1, (unint64_t *)(a1 + 40), (unint64_t *)(a2 - 40));
      return 1;
    case 4uLL:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, a1 + 40, a1 + 80, a2 - 40);
      return 1;
    case 5uLL:
      v21 = (_QWORD *)(a1 + 40);
      v22 = (_QWORD *)(a1 + 80);
      v23 = (__int128 *)(a1 + 120);
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(a1, a1 + 40, a1 + 80, a1 + 120);
      v25 = *(_QWORD *)(a2 - 40);
      v24 = a2 - 40;
      if (v25 >= *(_QWORD *)(a1 + 120))
        return 1;
      v26 = *v23;
      v27 = *(_OWORD *)(a1 + 136);
      v28 = *(_QWORD *)(a1 + 152);
      v29 = *(_QWORD *)(v24 + 32);
      v30 = *(_OWORD *)(v24 + 16);
      *v23 = *(_OWORD *)v24;
      *(_OWORD *)(a1 + 136) = v30;
      *(_QWORD *)(a1 + 152) = v29;
      *(_QWORD *)(v24 + 32) = v28;
      *(_OWORD *)v24 = v26;
      *(_OWORD *)(v24 + 16) = v27;
      if (*(_QWORD *)v23 >= *v22)
        return 1;
      v31 = *(_QWORD *)(a1 + 112);
      v33 = *(_OWORD *)v22;
      v32 = *(_OWORD *)(a1 + 96);
      v34 = *(_OWORD *)(a1 + 136);
      *(_OWORD *)v22 = *v23;
      *(_OWORD *)(a1 + 96) = v34;
      *(_QWORD *)(a1 + 112) = *(_QWORD *)(a1 + 152);
      *v23 = v33;
      *(_OWORD *)(a1 + 136) = v32;
      *(_QWORD *)(a1 + 152) = v31;
      if (*v22 >= *v21)
        return 1;
      v35 = *(_QWORD *)(a1 + 72);
      v37 = *(_OWORD *)v21;
      v36 = *(_OWORD *)(a1 + 56);
      v38 = *(_OWORD *)(a1 + 96);
      *(_OWORD *)v21 = *(_OWORD *)v22;
      *(_OWORD *)(a1 + 56) = v38;
      *(_QWORD *)(a1 + 72) = *(_QWORD *)(a1 + 112);
      *(_OWORD *)v22 = v37;
      *(_OWORD *)(a1 + 96) = v36;
      *(_QWORD *)(a1 + 112) = v35;
      if (*(_QWORD *)(a1 + 40) >= *(_QWORD *)a1)
        return 1;
      v39 = *(_QWORD *)(a1 + 32);
      v41 = *(_OWORD *)a1;
      v40 = *(_OWORD *)(a1 + 16);
      v42 = *(_OWORD *)(a1 + 56);
      *(_OWORD *)a1 = *(_OWORD *)v21;
      *(_OWORD *)(a1 + 16) = v42;
      *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 72);
      *(_OWORD *)v21 = v41;
      *(_OWORD *)(a1 + 56) = v40;
      result = 1;
      *(_QWORD *)(a1 + 72) = v39;
      return result;
    default:
      v12 = (_QWORD *)(a1 + 80);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)a1, (unint64_t *)(a1 + 40), (unint64_t *)(a1 + 80));
      v13 = a1 + 120;
      if (a1 + 120 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    v16 = *(_QWORD *)v13;
    if (*(_QWORD *)v13 < *v12)
    {
      v43 = *(_OWORD *)(v13 + 8);
      v44 = *(_OWORD *)(v13 + 24);
      v17 = v14;
      while (1)
      {
        v18 = a1 + v17;
        v19 = *(_OWORD *)(a1 + v17 + 96);
        *(_OWORD *)(v18 + 120) = *(_OWORD *)(a1 + v17 + 80);
        *(_OWORD *)(v18 + 136) = v19;
        *(_QWORD *)(v18 + 152) = *(_QWORD *)(a1 + v17 + 112);
        if (v17 == -80)
          break;
        v17 -= 40;
        if (v16 >= *(_QWORD *)(v18 + 40))
        {
          v20 = a1 + v17 + 120;
          goto LABEL_13;
        }
      }
      v20 = a1;
LABEL_13:
      *(_QWORD *)v20 = v16;
      *(_OWORD *)(v20 + 8) = v43;
      *(_OWORD *)(v20 + 24) = v44;
      if (++v15 == 8)
        return v13 + 40 == a2;
    }
    v12 = (_QWORD *)v13;
    v14 += 40;
    v13 += 40;
    if (v13 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;
  __int128 v9;
  uint64_t v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  __int128 v20;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,RB::Decoder::saved_shared_field(RB::Encoder::SharedType,unsigned long)::$_0 &,RB::Decoder::SharedField *>((__int128 *)a1, (unint64_t *)a2, (unint64_t *)a3);
  if (*(_QWORD *)a4 < *(_QWORD *)a3)
  {
    result = *(__n128 *)a3;
    v9 = *(_OWORD *)(a3 + 16);
    v10 = *(_QWORD *)(a3 + 32);
    v11 = *(_QWORD *)(a4 + 32);
    v12 = *(_OWORD *)(a4 + 16);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)(a3 + 16) = v12;
    *(_QWORD *)(a3 + 32) = v11;
    *(_QWORD *)(a4 + 32) = v10;
    *(__n128 *)a4 = result;
    *(_OWORD *)(a4 + 16) = v9;
    if (*(_QWORD *)a3 < *(_QWORD *)a2)
    {
      result = *(__n128 *)a2;
      v13 = *(_OWORD *)(a2 + 16);
      v14 = *(_QWORD *)(a2 + 32);
      v15 = *(_QWORD *)(a3 + 32);
      v16 = *(_OWORD *)(a3 + 16);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)(a2 + 16) = v16;
      *(_QWORD *)(a2 + 32) = v15;
      *(_QWORD *)(a3 + 32) = v14;
      *(__n128 *)a3 = result;
      *(_OWORD *)(a3 + 16) = v13;
      if (*(_QWORD *)a2 < *(_QWORD *)a1)
      {
        result = *(__n128 *)a1;
        v17 = *(_OWORD *)(a1 + 16);
        v18 = *(_QWORD *)(a1 + 32);
        v19 = *(_QWORD *)(a2 + 32);
        v20 = *(_OWORD *)(a2 + 16);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(_OWORD *)(a1 + 16) = v20;
        *(_QWORD *)(a1 + 32) = v19;
        *(_QWORD *)(a2 + 32) = v18;
        *(__n128 *)a2 = result;
        *(_OWORD *)(a2 + 16) = v17;
      }
    }
  }
  return result;
}

void *RB::vector<unsigned char,0ul,unsigned long>::reserve_slow(uint64_t a1, size_t a2)
{
  size_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,1ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,1ul>(void *a1, size_t *a2, size_t size)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (size)
  {
    v5 = malloc_good_size(size);
    if (v5 != *a2)
    {
      v6 = v5;
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__emplace_unique_key_args<unsigned int,std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(uint64_t a1, unsigned int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  uint64_t *v9;
  uint64_t i;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  _QWORD *v18;
  unint64_t v19;
  uint64_t v21[3];

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 <= v6)
        v4 = v6 % v7;
    }
    else
    {
      v4 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(uint64_t **)(*(_QWORD *)a1 + 8 * v4);
    if (v9)
    {
      for (i = *v9; i; i = *(_QWORD *)i)
      {
        v11 = *(_QWORD *)(i + 8);
        if (v11 == v6)
        {
          if (*(_DWORD *)(i + 16) == (_DWORD)v6)
            return i;
        }
        else
        {
          if (v8.u32[0] > 1uLL)
          {
            if (v11 >= v7)
              v11 %= v7;
          }
          else
          {
            v11 &= v7 - 1;
          }
          if (v11 != v4)
            break;
        }
      }
    }
  }
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>(a1, *a2, a4, (uint64_t)v21);
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v4 = v6 % v7;
      else
        v4 = v6;
    }
    else
    {
      v4 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v18)
  {
    *(_QWORD *)v21[0] = *v18;
    *v18 = v21[0];
  }
  else
  {
    *(_QWORD *)v21[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v21[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = a1 + 16;
    if (*(_QWORD *)v21[0])
    {
      v19 = *(_QWORD *)(*(_QWORD *)v21[0] + 8);
      if ((v7 & (v7 - 1)) != 0)
      {
        if (v19 >= v7)
          v19 %= v7;
      }
      else
      {
        v19 &= v7 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v19) = v21[0];
    }
  }
  i = v21[0];
  v21[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](v21, 0);
  return i;
}

void sub_209B0334C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100]((uint64_t *)va, 0);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__construct_node_hash<std::piecewise_construct_t const&,std::tuple<unsigned int &&>,std::tuple<>>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, _DWORD **a3@<X3>, uint64_t a4@<X8>)
{
  uint64_t v7;
  _QWORD *v8;
  uint64_t result;

  v7 = a1 + 16;
  v8 = operator new(0x48uLL);
  *(_QWORD *)a4 = v8;
  *(_QWORD *)(a4 + 8) = v7;
  *(_BYTE *)(a4 + 16) = 0;
  *v8 = 0;
  v8[1] = a2;
  result = std::pair<unsigned int const,RB::Encoder::FontSet::Font>::pair[abi:nn180100]<unsigned int &&>((uint64_t)(v8 + 2), *a3);
  *(_BYTE *)(a4 + 16) = 1;
  return result;
}

void sub_209B033B8(_Unwind_Exception *a1)
{
  uint64_t *v1;

  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](v1, 0);
  _Unwind_Resume(a1);
}

void std::__throw_bad_array_new_length[abi:nn180100]()
{
  abort();
}

uint64_t std::pair<unsigned int const,RB::Encoder::FontSet::Font>::pair[abi:nn180100]<unsigned int &&>(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)a1 = *a2;
  *(_OWORD *)(a1 + 8) = 0u;
  *(_OWORD *)(a1 + 24) = 0u;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_QWORD *)(a1 + 24) = CGFontIndexSetCreate();
  *(_QWORD *)(a1 + 32) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 48) = 0;
  return a1;
}

void sub_209B03430(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  CFTypeRef *v2;
  const void *v4;

  v4 = *(const void **)(v1 + 16);
  if (v4)
    CFRelease(v4);
  if (*v2)
    CFRelease(*v2);
  _Unwind_Resume(exception_object);
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:nn180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,void *>>>>::reset[abi:nn180100](uint64_t *a1, uint64_t a2)
{
  uint64_t v2;

  v2 = *a1;
  *a1 = a2;
  if (v2)
  {
    if (*((_BYTE *)a1 + 16))
      RB::Encoder::FontSet::Font::~Font((RB::Encoder::FontSet::Font *)(v2 + 24));
    operator delete((void *)v2);
  }
}

uint64_t *std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::find<unsigned int>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

void *RB::vector<RB::Decoder::SharedField,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,40ul>(*(void **)a1, (unint64_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,40ul>(void *a1, unint64_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  unint64_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(40 * a3);
    v6 = v5 / 0x28;
    if (v5 / 0x28 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

uint64_t RB::Path::Accumulator::Accumulator(uint64_t a1, uint64_t a2, uint64_t *a3, float64x2_t *a4, float a5, float32x2_t a6, float32x2_t a7)
{
  char v14;

  if (RBPathGetBezierOrder(*a3, a3[1]) == 1)
    v14 = 2;
  else
    v14 = 4;
  *(_QWORD *)a1 = off_24C2293C8;
  *(_QWORD *)(a1 + 8) = a2;
  RB::Path::Flattener::Flattener(a1 + 16, (void (***)(_QWORD))a1, a5, a6, a7);
  *(_QWORD *)(a1 + 248) = 0;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = 4;
  *(_QWORD *)(a1 + 272) = 0;
  *(_BYTE *)(a1 + 280) = 0;
  *(_BYTE *)(a1 + 281) = v14;
  *(_QWORD *)(a1 + 288) = -1;
  *(_DWORD *)(a1 + 296) = 0;
  RB::Coverage::Path::map((uint64_t)a3, (uint64_t (**)(RB::Path::Mapper *__hidden))(a1 + 16), a4);
  if (*(_BYTE *)(a1 + 280))
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)a1);
  return a1;
}

void sub_209B03944(_Unwind_Exception *a1)
{
  RB::Path::Accumulator *v1;

  RB::Path::Accumulator::~Accumulator(v1);
  _Unwind_Resume(a1);
}

void RB::Path::Accumulator::~Accumulator(RB::Path::Accumulator *this)
{
  void *v2;

  if (*((_BYTE *)this + 280))
    RB::Path::Accumulator::commit_buffer(this);
  v2 = (void *)*((_QWORD *)this + 31);
  if (v2)
    free(v2);
}

void sub_209B03994(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 248);
  if (v3)
    free(v3);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Path::Accumulator::pop_back(RB::Path::Accumulator *this)
{
  uint64_t v1;
  char *v2;
  int *v3;
  int v4;
  int v5;

  if (!*((_BYTE *)this + 280))
    return 0;
  v1 = *((_QWORD *)this + 34);
  if (!v1)
    return 0;
  *((_QWORD *)this + 34) = v1 - 1;
  if (*((_BYTE *)this + 281) == 4)
  {
    v2 = (char *)this + 120;
    if (*((_QWORD *)this + 31))
      v2 = (char *)*((_QWORD *)this + 31);
    v3 = (int *)(*(_QWORD *)(*(_QWORD *)&v2[32 * *((_QWORD *)this + 32) - 32] + 56)
               + *(_QWORD *)&v2[32 * *((_QWORD *)this + 32) - 24]
               + 32 * (v1 - 1));
    v4 = *(v3 - 8);
    v5 = *v3;
    if (v4 == v5)
      *((_QWORD *)this + 34) = v1 - 2;
    *((_DWORD *)this + 74) = v5;
  }
  return 1;
}

uint64_t RB::Path::Accumulator::convert_to_lines(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float *v7;
  int32x2_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v2 = *(_QWORD *)(a2 + 8);
  v3 = *(_QWORD *)(*(_QWORD *)a2 + 56);
  v4 = *(_QWORD *)(result + 272);
  *(_QWORD *)(result + 272) = 0;
  if (v4)
  {
    v5 = 0;
    v6 = v3 + v2;
    v7 = (float *)(v2 + v3 + 24);
    v8 = vdup_n_s32(0x7F800000u);
    do
    {
      if (v5 && *(v7 - 5) == 0.0)
      {
        v9 = *(_QWORD *)(result + 272);
        *(_QWORD *)(result + 272) = v9 + 1;
        *(int32x2_t *)(v6 + 8 * v9) = v8;
      }
      v10 = *(_QWORD *)v7;
      v7 += 8;
      v11 = *(_QWORD *)(result + 272);
      *(_QWORD *)(result + 272) = v11 + 1;
      *(_QWORD *)(v6 + 8 * v11) = v10;
      ++v5;
    }
    while (v4 != v5);
  }
  *(_BYTE *)(a2 + 28) = 2;
  return result;
}

void *RB::vector<RB::Path::Buffer,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1);
  result = RB::details::realloc_vector<unsigned long,32ul>(*((void **)__dst + 16), __dst, 4uLL, (size_t *)__dst + 18, v3);
  *((_QWORD *)__dst + 16) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,32ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 32 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(32 * a5);
    v9 = v8 >> 5;
    if (v8 >> 5 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 32 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::Coverage::Glyphs::Glyphs(uint64_t a1, RB::Heap *this, CFTypeRef cf, unsigned int a4, const void *a5, const void *a6, int a7, char a8, double a9, float a10, char a11)
{
  unint64_t v20;
  unint64_t v21;
  CFTypeRef v22;
  unsigned int *v23;

  *(_QWORD *)a1 = cf;
  v20 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  v21 = v20 + 10 * a4;
  if (v21 > *((_QWORD *)this + 3))
  {
    v20 = RB::Heap::alloc_slow((size_t *)this, 10 * a4, 7);
    v22 = *(CFTypeRef *)a1;
  }
  else
  {
    v22 = cf;
    *((_QWORD *)this + 2) = v21;
  }
  *(_QWORD *)(a1 + 8) = v20;
  *(_DWORD *)(a1 + 16) = a4;
  *(_DWORD *)(a1 + 20) = a7;
  *(double *)(a1 + 24) = a9;
  *(_QWORD *)(a1 + 32) = 0x100000001000000;
  *(int32x2_t *)(a1 + 40) = vdup_n_s32(0x7F7FFFFFu);
  *(float *)(a1 + 48) = a10;
  *(_BYTE *)(a1 + 52) = a8;
  *(_BYTE *)(a1 + 53) = a11;
  v23 = (unsigned int *)*((_QWORD *)this + 4);
  if (!v23)
  {
    RB::Heap::make_object_table((size_t *)this);
    v23 = (unsigned int *)*((_QWORD *)this + 4);
  }
  RB::ObjectTable::retain(v23, v22);
  if (a4)
  {
    memmove((void *)(*(_QWORD *)(a1 + 8) + 8 * *(unsigned int *)(a1 + 16)), a5, 2 * a4);
    memmove(*(void **)(a1 + 8), a6, 8 * a4);
  }
  return a1;
}

{
  return RB::Coverage::Glyphs::Glyphs(a1, this, cf, a4, a5, a6, a7, a8, a9, a10, a11);
}

int32x2_t RB::Coverage::Glyphs::Glyphs(RB::Coverage::Glyphs *this, const RB::Coverage::Glyphs *a2, RB::Heap *a3, unsigned int a4, unsigned int a5)
{
  int32x2_t *v5;
  int32x2_t result;

  v5 = (int32x2_t *)RB::Coverage::Glyphs::Glyphs((uint64_t)this, a3, *(CFTypeRef *)a2, a5, (const void *)(*((_QWORD *)a2 + 1) + 8 * *((unsigned int *)a2 + 4) + 2 * a4), (const void *)(*((_QWORD *)a2 + 1) + 8 * a4), *((_DWORD *)a2 + 5), *((_BYTE *)a2 + 52), *((double *)a2 + 3), *((float *)a2 + 12), *((_BYTE *)a2 + 53));
  result = vdup_n_s32(0x7F7FFFFFu);
  v5[4] = (int32x2_t)0x100000001000000;
  v5[5] = result;
  return result;
}

void RB::Coverage::Glyphs::disable_subpixel_quantization(RB::Coverage::Glyphs *this, float64x2_t *a2, double a3, double a4, int64x2_t a5)
{
  int v5;
  uint64_t v8;
  float64x2_t v9;
  float64x2_t *v10;
  unint64_t v11;
  float32x2_t v12;
  int8x8_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float32x2_t v16[2];
  _OWORD v17[3];

  v5 = *((_DWORD *)this + 5);
  if ((v5 & 8) != 0)
  {
    v8 = *((_QWORD *)this + 1);
    v9 = a2[1];
    v17[0] = *a2;
    v17[1] = v9;
    v17[2] = a2[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)v17))
      v10 = (float64x2_t *)v17;
    else
      v10 = a2;
    if (*((_DWORD *)this + 4))
    {
      v11 = 0;
      v14 = v10[1];
      v15 = *v10;
      do
      {
        v12 = *(float32x2_t *)(v8 + 8 * v11);
        *(float32x2_t *)(v8 + 8 * v11++) = vadd_f32(v12, vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v15, *(float *)v13.i32), v14, *(float *)&v13.i32[1])));
      }
      while (v11 < *((unsigned int *)this + 4));
    }
    *((_DWORD *)this + 5) &= ~8u;
  }
}

float32x2_t *RB::Coverage::`anonymous namespace'::QuantizationLevel::QuantizationLevel(float32x2_t *this, float64x2_t *a2, char a3, double a4, double a5, int64x2_t a6)
{
  double v7;
  uint64_t QuantizationLevelWithStyle;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;

  *this = 0;
  this[1] = 0;
  if ((a3 & 8) != 0)
  {
    *(double *)a6.i64 = -a2->f64[1];
    v7 = fabs(vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(a6, *(int64x2_t *)a2), a2[1])));
    if (v7 <= RB::max_cached_glyph_mask_area((RB *)this))
    {
      QuantizationLevelWithStyle = CGFontGetQuantizationLevelWithStyle();
      v9.f32[0] = (float)(int)QuantizationLevelWithStyle;
      v9.f32[1] = (float)SHIDWORD(QuantizationLevelWithStyle);
      v10 = vrecpe_f32(v9);
      v11 = vmul_f32(vrecps_f32(v9, v10), v10);
      *this = v9;
      this[1] = vmul_f32(v11, vrecps_f32(v9, v11));
    }
  }
  return this;
}

int8x8_t RB::Coverage::`anonymous namespace'::QuantizationLevel::offset(float32x2_t *a1, float64x2_t *a2, float32x2_t a3)
{
  uint32x2_t v3;
  float32x4_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float32x2_t v7;

  v3 = (uint32x2_t)vceqz_f32(*a1);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
  {
    return 0;
  }
  else
  {
    v4 = (float32x4_t)vcvtq_f64_f32(a3);
    v5 = a2[1];
    *(float32x2_t *)v4.f32 = vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(a2[2], *a2, *(double *)v4.i64), v5, (float64x2_t)v4, 1));
    v6 = vaddq_f64(v5, *a2);
    *(int32x2_t *)&v6.f64[0] = vcltz_f32(vcvt_f32_f64(v6));
    *(_QWORD *)&v6.f64[0] = vcltzq_s32((int32x4_t)v6).u64[0];
    *(int8x8_t *)v4.f32 = vbsl_s8(*(int8x8_t *)&v6.f64[0], (int8x8_t)*(_OWORD *)&vnegq_f32(v4), *(int8x8_t *)v4.f32);
    *(float32x2_t *)&v5.f64[0] = vadd_f32(*(float32x2_t *)v4.f32, (float32x2_t)vdup_n_s32(0x3A83126Fu));
    v7 = vrndm_f32(*(float32x2_t *)&v5.f64[0]);
    *(float32x2_t *)v4.f32 = vmla_f32(vsub_f32(v7, *(float32x2_t *)v4.f32), vrnd_f32(vmul_f32(vsub_f32(*(float32x2_t *)&v5.f64[0], v7), *a1)), a1[1]);
    return vbsl_s8(*(int8x8_t *)&v6.f64[0], (int8x8_t)*(_OWORD *)&vnegq_f32(v4), *(int8x8_t *)v4.f32);
  }
}

float32x2_t RB::Coverage::Glyphs::resolved_dilation(float32x2_t *this, float a2)
{
}

float32x2_t RB::Coverage::`anonymous namespace'::font_dilation_parameters(__int16 a1, float32x2_t a2, float a3)
{
  float32x2_t v3;

  if ((a1 & 2) != 0)
  {
    switch(((a1 & 0x70u) - 16) >> 4)
    {
      case 1u:
LABEL_5:
        v3 = (float32x2_t)0x3C248B653C02D7B6;
        break;
      case 2u:
LABEL_7:
        v3 = (float32x2_t)0x3C77CED93C463F14;
        break;
      case 3u:
        v3 = (float32x2_t)0x3CA8826B3C8AC5C1;
        break;
      case 4u:
        v3 = (float32x2_t)0x3AEBEDFA3AA3D70ALL;
        break;
      case 5u:
        v3 = (float32x2_t)0x3C570A3D3DD70A3DLL;
        break;
      case 6u:
LABEL_6:
        v3 = vmul_f32(a2, (float32x2_t)vdup_n_s32(0x3E99999Au));
        break;
      default:
        v3 = 0;
        break;
    }
  }
  else
  {
    v3 = 0;
    switch(((a1 & 0xD80u) - 128) >> 7)
    {
      case 0u:
        goto LABEL_5;
      case 1u:
        v3 = (float32x2_t)0x3C4E2D1F3C248B65;
        break;
      case 2u:
        goto LABEL_7;
      case 7u:
      case 8u:
        goto LABEL_6;
      default:
        break;
    }
  }
  return vminnm_f32(vmul_n_f32(v3, a3), (float32x2_t)vdup_n_s32(0x3E99999Au));
}

void RB::Coverage::Glyphs::apply_transform(RB::Coverage::Glyphs *this, const RB::DisplayList::Transform *a2, RB::Heap *a3)
{
  CFTypeRef v6;
  CFTypeRef v7;
  RB::ObjectTable *v8;
  CFTypeRef cf;

  v6 = *(CFTypeRef *)this;
  if (*(_QWORD *)this)
    CFRetain(*(CFTypeRef *)this);
  cf = v6;
  RB::DisplayList::Transform::apply_to_font((uint64_t)a2, (CGFont **)&cf, (const CGGlyph *)(*((_QWORD *)this + 1) + 8 * *((unsigned int *)this + 4)), *((float **)this + 1), *((unsigned int *)this + 4));
  v7 = cf;
  if (cf != *(CFTypeRef *)this)
  {
    *(_QWORD *)this = cf;
    cf = 0;
    v8 = (RB::ObjectTable *)*((_QWORD *)a3 + 4);
    if (!v8)
    {
      RB::Heap::make_object_table((size_t *)a3);
      v8 = (RB::ObjectTable *)*((_QWORD *)a3 + 4);
    }
    RB::ObjectTable::adopt(v8, v7);
    v7 = cf;
  }
  if (v7)
    CFRelease(v7);
}

void sub_209B04110(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Coverage::Glyphs::can_mix(RB::Coverage::Glyphs *this, const RB::DisplayList::Interpolator::Op *a2, const RB::Coverage::Glyphs *a3)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  os_unfair_lock_s *v9;
  uint64_t result;
  unsigned __int32 v11;
  uint64_t v12;
  uint64_t v13;
  unsigned __int16 *v14;
  uint64_t v15;
  uint64_t v16;
  unsigned __int16 *v17;
  float32x2_t *v18;
  float32x2_t *v19;
  unint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint32x2_t v23;
  const __CFDictionary *v24[2];

  v3 = *(_QWORD *)a2 >> 36;
  v4 = *((_DWORD *)this + 4);
  if (v4 >= v3)
    v5 = v3;
  else
    v5 = v4;
  if (*((_DWORD *)a3 + 4) < v3)
    LODWORD(v3) = *((_DWORD *)a3 + 4);
  if ((_DWORD)v5 != (_DWORD)v3
    || ((*((_DWORD *)a3 + 5) ^ *((_DWORD *)this + 5)) & 0xFFFFFFF7) != 0
    || *((unsigned __int8 *)this + 52) != *((unsigned __int8 *)a3 + 52))
  {
    return 0;
  }
  v24[0] = 0;
  v24[1] = 0;
  v9 = (os_unfair_lock_s *)RB::FontMixer::shared(this);
  result = RB::FontMixer::can_mix(v9, *(CGFont **)this, *(CGFont **)a3, (uint64_t *)v24);
  if ((_DWORD)result)
  {
    v11 = *((float *)this + 12) == *((float *)a3 + 12);
    if ((_DWORD)v5)
    {
      v12 = *((_QWORD *)this + 1);
      v13 = *((unsigned int *)a2 + 3);
      v14 = (unsigned __int16 *)(v12 + 8 * *((unsigned int *)this + 4) + 2 * v13);
      v15 = *((_QWORD *)a3 + 1);
      v16 = *((unsigned int *)a2 + 5);
      v17 = (unsigned __int16 *)(v15 + 8 * *((unsigned int *)a3 + 4) + 2 * v16);
      v18 = (float32x2_t *)(v12 + 8 * v13);
      v19 = (float32x2_t *)(v15 + 8 * v16);
      while (1)
      {
        v21 = *v14++;
        v20 = v21;
        v22 = *v17++;
        result = RB::FontMixer::GlyphEquality::operator()(v24, (void *)v20, (void *)v22);
        if (!(_DWORD)result)
          break;
        if ((v11 & 1) != 0)
        {
          v23 = (uint32x2_t)vceq_f32(*v18, *v19);
          v11 = vpmin_u32(v23, v23).u32[0] >> 31;
        }
        else
        {
          v11 = 0;
        }
        ++v19;
        ++v18;
        if (!--v5)
          goto LABEL_17;
      }
    }
    else
    {
LABEL_17:
      if (v11)
      {
        if (*(_QWORD *)this == *(_QWORD *)a3)
          return 4;
        else
          return 2;
      }
      else
      {
        return 1;
      }
    }
  }
  return result;
}

void RB::Coverage::Glyphs::mix(float32x2_t *this, const RB::DisplayList::Interpolator::State *a2, const RB::Coverage::Glyphs *a3, float64x2_t *a4, float64x2_t *a5, float64x2_t *a6, RB::Heap *a7)
{
  os_unfair_lock_s *v14;
  float64_t v15;
  RB::ObjectTable *v16;
  unsigned int v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t *v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t *v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  double v33;
  double v34;
  int64x2_t v35;
  double v36;
  double v37;
  int64x2_t v38;
  uint64_t v39;
  float32x2_t v40;
  uint64_t v41;
  float32x2_t v42;
  float32x2_t v43;
  uint32x2_t v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x2_t v47;
  int8x8_t v48;
  float32x2_t v49;
  float32x2_t v50[2];
  float32x2_t v51[2];
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;

  v14 = (os_unfair_lock_s *)RB::FontMixer::shared((RB::FontMixer *)this);
  RB::FontMixer::mix(v14, *(CGFont **)this, *(CGFont **)a3, *((_DWORD *)a2 + 4), &v58);
  v15 = v58.f64[0];
  if (*(_QWORD *)&v58.f64[0])
  {
    *this = *(float32x2_t *)&v58.f64[0];
    v58.f64[0] = 0.0;
    v16 = (RB::ObjectTable *)*((_QWORD *)a7 + 4);
    if (!v16)
    {
      RB::Heap::make_object_table((size_t *)a7);
      v16 = (RB::ObjectTable *)*((_QWORD *)a7 + 4);
    }
    RB::ObjectTable::adopt(v16, *(CFTypeRef *)&v15);
    if (*(_QWORD *)&v58.f64[0])
      CFRelease(*(CFTypeRef *)&v58.f64[0]);
  }
  if ((**((_QWORD **)a2 + 1) & 0xBLL) == 2)
    v17 = ((*((_DWORD *)a3 + 5) | this[2].i32[1]) >> 3) & 1;
  else
    v17 = 0;
  v18 = a4[1];
  v58 = *a4;
  v59 = v18;
  v60 = a4[2];
  v19 = a5[1];
  v55 = *a5;
  v56 = v19;
  v57 = a5[2];
  v20 = (float64x2_t *)*((_QWORD *)a2 + 4);
  if (v20)
  {
    v21.f64[0] = RB::operator*(&v58, v20);
    v58 = v21;
    v59 = v22;
    v60 = v23;
    v24.f64[0] = RB::operator*(&v55, *((float64x2_t **)a2 + 4));
    v55 = v24;
    v56 = v25;
    v57 = v26;
    v27 = (float64x2_t *)*((_QWORD *)a2 + 4);
    v28 = a6[1];
    v52 = *a6;
    v53 = v28;
    v54 = a6[2];
    if (v27)
    {
      v29.f64[0] = RB::operator*(&v52, v27);
      v52 = v29;
      v53 = v30;
      v54 = v31;
    }
  }
  else
  {
    v32 = a6[1];
    v52 = *a6;
    v53 = v32;
    v54 = a6[2];
  }
  RB::AffineTransform::invert((RB::AffineTransform *)&v52);
  v51[0] = 0;
  v51[1] = 0;
  v50[0] = 0;
  v50[1] = 0;
  if (v17)
  {
  }
  if (this[2].i32[0])
  {
    v39 = 0;
    v40 = this[1];
    v41 = *((_QWORD *)a3 + 1) + 8 * *(unsigned int *)(*((_QWORD *)a2 + 1) + 20);
    while (1)
    {
      v42 = *(float32x2_t *)(*(_QWORD *)&v40 + 8 * v39);
      v43 = *(float32x2_t *)(v41 + 8 * v39);
      v44 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(v42, v43));
      if ((vpmax_u32(v44, v44).u32[0] & 0x80000000) != 0)
        break;
      if (v17)
        goto LABEL_19;
LABEL_20:
      if (++v39 >= (unint64_t)this[2].u32[0])
        goto LABEL_24;
    }
    v46 = vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v58, v42.f32[0]), v59, v42.f32[1]));
    v47 = vmla_n_f32(v46, vsub_f32(vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v55, v43.f32[0]), v56, v43.f32[1])), v46), COERCE_FLOAT(*((_QWORD *)a2 + 2)));
    v42 = vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v52, v47.f32[0]), v53, v47.f32[1]));
    *(float32x2_t *)(*(_QWORD *)&v40 + 8 * v39) = v42;
    if (!v17)
      goto LABEL_20;
LABEL_19:
    v49 = v42;
    *(float32x2_t *)(*(_QWORD *)&v40 + 8 * v39) = vadd_f32(v49, vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(v52, v45.f32[0]), v53, v45.f32[1])));
    goto LABEL_20;
  }
LABEL_24:
  this[3] = vmla_n_f32(this[3], vsub_f32(*(float32x2_t *)((char *)a3 + 24), this[3]), COERCE_FLOAT(*((_QWORD *)a2 + 2)));
  this[6].f32[0] = this[6].f32[0] + (float)((float)(*((float *)a3 + 12) - this[6].f32[0]) * *((float *)a2 + 4));
  this[4] = (float32x2_t)0x100000001000000;
  this[5] = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
  if ((v17 & 1) != 0)
    this[2].i32[1] &= ~8u;
}

void sub_209B045A0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 - 128);
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

void RB::Coverage::Glyphs::clip(float32x2_t **this, RB::CGContext *a2)
{
  RB::Coverage::Glyphs::show(this, (uint64_t)a2, 1);
}

uint64_t RB::Coverage::Glyphs::prepare_encode(uint64_t this, RB::Encoder *a2)
{
  if (*(_QWORD *)this)
    return RB::Encoder::prepare_glyphs(a2, *(CGFont **)this, *(unsigned int *)(this + 16), (const unsigned __int16 *)(*(_QWORD *)(this + 8) + 8 * *(unsigned int *)(this + 16)));
  return this;
}

_QWORD *RB::Coverage::Glyphs::encode(RB::Coverage::Glyphs *this, RB::Encoder *a2)
{
  uint64_t *v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int Value;
  float v11;
  int v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v17;

  if (*(_QWORD *)this)
    v4 = RB::Encoder::cgfont_field(a2, 1, *(CGFont **)this);
  else
    v4 = 0;
  v5 = *((unsigned int *)this + 4);
  if ((_DWORD)v5)
  {
    v6 = 0;
    v7 = *((_QWORD *)this + 1);
    v8 = v7 + 8 * v5;
    do
    {
      v9 = *(unsigned __int16 *)(v8 + 2 * v6);
      if (v4)
      {
        Value = CGFontIndexMapGetValue();
        if (Value != 0xFFFF)
          v9 = Value;
      }
      v17 = *(_QWORD *)(v7 + 8 * v6);
      RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(a2);
      if (v9)
      {
        RB::ProtobufEncoder::encode_varint(a2, 8uLL);
        RB::ProtobufEncoder::encode_varint(a2, v9);
      }
      v11 = *((float *)&v17 + 1);
      if (*(float *)&v17 != 0.0)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v17);
        v11 = *((float *)&v17 + 1);
      }
      v12 = LODWORD(v11);
      if (v11 != 0.0)
      {
        RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
        RB::ProtobufEncoder::encode_fixed32(a2, v12);
      }
      RB::ProtobufEncoder::end_length_delimited(a2);
      ++v6;
    }
    while (v6 < *((unsigned int *)this + 4));
  }
  v13 = *((unsigned int *)this + 5);
  if ((_DWORD)v13)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(a2, v13);
  }
  if ((*((_BYTE *)this + 53) & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  v14 = *((unsigned __int8 *)this + 52);
  RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
  RB::ProtobufEncoder::encode_varint(a2, v14);
  v15 = *((int *)this + 12);
  if (*(float *)&v15 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
    RB::ProtobufEncoder::encode_fixed32(a2, v15);
  }
  return RB::ProtobufEncoder::float2_field(a2, 7, *((double *)this + 3));
}

void RB::Coverage::Glyphs::decode(RB::Coverage::Glyphs *this, size_t **a2)
{
  unint64_t field;
  __n128 v5;
  char v6;
  uint64_t *v7;
  size_t *v8;
  unsigned int *v9;
  unint64_t v10;
  void *v11;
  _BYTE *v12;
  _QWORD *v13;
  void *v14;
  _BYTE *v15;
  unint64_t v16;
  float *v17;
  unint64_t v18;
  void *v19;
  size_t *v20;
  _QWORD *v21;
  char *v22;
  _WORD *v23;
  uint64_t v24;
  _BYTE *v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE v28[2048];
  void *v29[2];
  unint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x24BDAC8D0];
  *(_OWORD *)v29 = 0u;
  v30 = 128;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
    v6 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v7 = RB::Decoder::cgfont_field((RB::ProtobufDecoder *)a2, field);
        *(_QWORD *)this = v7;
        v8 = a2[8];
        v9 = (unsigned int *)v8[4];
        if (!v9)
        {
          RB::Heap::make_object_table(a2[8]);
          v9 = (unsigned int *)v8[4];
        }
        RB::ObjectTable::retain(v9, v7);
        break;
      case 2u:
        v11 = v29[1];
        if ((void *)v30 < (char *)v29[1] + 1)
        {
          v11 = v29[1];
        }
        v12 = v29[0];
        if (!v29[0])
          v12 = v28;
        v13 = &v12[16 * (_QWORD)v11];
        *v13 = 0;
        v13[1] = 0;
        v14 = v29[1]++;
        if (v29[0])
          v15 = v29[0];
        else
          v15 = v28;
        if ((v6 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a2);
          v16 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
          if (v16)
          {
            v17 = (float *)&v15[16 * (_QWORD)v14];
            do
            {
              v18 = v16 >> 3;
              if ((v16 >> 3) == 3)
              {
                v17[3] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v16);
              }
              else if ((_DWORD)v18 == 2)
              {
                v17[2] = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, v16);
              }
              else if ((_DWORD)v18 == 1)
              {
                *(_WORD *)v17 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a2, v16);
              }
              else
              {
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, v16);
              }
              v16 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a2);
            }
            while (v16);
          }
          RB::ProtobufDecoder::end_message((uint64_t)a2);
        }
        else
        {
          *((_BYTE *)a2 + 56) = 1;
          *a2 = a2[1];
        }
        break;
      case 3u:
        *((_DWORD *)this + 5) = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a2, field);
        break;
      case 4u:
        *((_BYTE *)this + 53) = *((_BYTE *)this + 53) & 0xFE | RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a2, field);
        break;
      case 5u:
        v10 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a2, field);
        if (v10 <= 3)
          *((_BYTE *)this + 52) = v10;
        break;
      case 6u:
        *((float *)this + 12) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a2, field);
        break;
      case 7u:
        *((_QWORD *)this + 3) = RB::ProtobufDecoder::float2_field((RB::ProtobufDecoder *)a2, field, v5).n128_u64[0];
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a2, field);
        break;
    }
  }
  v19 = v29[1];
  if (v29[1])
  {
    *((_DWORD *)this + 4) = v29[1];
    v20 = a2[8];
    v21 = (_QWORD *)((v20[2] + 7) & 0xFFFFFFFFFFFFFFF8);
    v22 = (char *)v21 + 10 * v19;
    if ((unint64_t)v22 > v20[3])
    {
      v21 = (_QWORD *)RB::Heap::alloc_slow(a2[8], 10 * v19, 7);
      v27 = *((unsigned int *)this + 4);
      v19 = v29[1];
      *((_QWORD *)this + 1) = v21;
      if (!v19)
        goto LABEL_41;
      v23 = &v21[v27];
    }
    else
    {
      v20[2] = (size_t)v22;
      *((_QWORD *)this + 1) = v21;
      v23 = &v21[v19];
    }
    v24 = 0;
    do
    {
      v25 = v29[0];
      if (!v29[0])
        v25 = v28;
      v26 = &v25[v24];
      *v23++ = *(_WORD *)v26;
      *v21++ = *((_QWORD *)v26 + 1);
      v24 += 16;
      v19 = (char *)v19 - 1;
    }
    while (v19);
  }
LABEL_41:
  if (v29[0])
    free(v29[0]);
}

void sub_209B04AE8(_Unwind_Exception *a1)
{
  if (STACK[0x800])
    free((void *)STACK[0x800]);
  _Unwind_Resume(a1);
}

_QWORD *RB::Coverage::Glyphs::attributes(RB::Coverage::Glyphs *this, RB::XML::Element *a2)
{
  CGFont *v4;
  const void *v5;
  float32x2_t v6;
  uint32x2_t v7;
  void (**v9)(RB::XML::Value::GlyphArray *__hidden);
  CFTypeRef cf[3];
  CFTypeRef v11;
  void *v12;

  v4 = *(CGFont **)this;
  if (*(_QWORD *)this)
  {
    v9 = &off_24C229038;
    cf[0] = CGFontRetain(v4);
    RB::XML::Element::set<RB::XML::Value::Font>(a2, (uint64_t)"font", (uint64_t)&v9);
    v9 = &off_24C229038;
    if (cf[0])
      CFRelease(cf[0]);
    RB::XML::Value::GlyphArray::GlyphArray((RB::XML::Value::GlyphArray *)&v9, v4, (const unsigned __int16 *)(*((_QWORD *)this + 1) + 8 * *((unsigned int *)this + 4)), *((unsigned int *)this + 4));
    RB::XML::Element::set<RB::XML::Value::GlyphArray>(a2, (uint64_t)"glyphs", (const RB::XML::Value::GlyphArray *)&v9);
    v9 = &off_24C228E80;
    if (v12)
      free(v12);
    if (v11)
      CFRelease(v11);
    v9 = &off_24C2292B8;
    if (cf[0])
      free((void *)cf[0]);
  }
  RB::XML::Value::FloatArray::FloatArray<float>(&v9, *((float **)this + 1), 2 * *((unsigned int *)this + 4));
  RB::XML::Element::set<RB::XML::Value::FloatArray>(a2, (uint64_t)"positions", (uint64_t)&v9);
  v9 = &off_24C228E58;
  if (cf[0])
    free((void *)cf[0]);
  v5 = (const void *)*((unsigned int *)this + 5);
  if ((_DWORD)v5)
  {
    v9 = (void (**)(RB::XML::Value::GlyphArray *__hidden))&unk_24C228FE8;
    cf[0] = v5;
    RB::XML::Element::set<RB::XML::Value::Int>(a2, (uint64_t)"rendering-style", (uint64_t)&v9);
  }
  v6 = *(float32x2_t *)((char *)this + 24);
  v7 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32(v6));
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0)
  {
    v9 = (void (**)(RB::XML::Value::GlyphArray *__hidden))&unk_24C2290B0;
    *(float64x2_t *)cf = vcvtq_f64_f32(v6);
    RB::XML::Element::set<RB::XML::Value::Vec2>(a2, (uint64_t)"dilation", (uint64_t)&v9);
  }
  if ((*((_BYTE *)this + 53) & 1) != 0)
  {
    v9 = (void (**)(RB::XML::Value::GlyphArray *__hidden))&unk_24C229010;
    LOBYTE(cf[0]) = 1;
    RB::XML::Element::set<RB::XML::Value::Bool>(a2, (uint64_t)"should-draw-bitmap-runs", (uint64_t)&v9);
  }
  return RB::XML::Element::set_rendering_mode(a2, *((unsigned __int8 *)this + 52), *((float *)this + 12));
}

void sub_209B04CEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  RB::XML::Value::GlyphArray::~GlyphArray((RB::XML::Value::GlyphArray *)&a9);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Font>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  CFTypeRef v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &off_24C229038;
  v7 = *(CFTypeRef *)(a3 + 8);
  if (v7)
    v7 = CFRetain(v7);
  v6[1] = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(v9 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

void sub_209B04DE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0xA1C40BD48D6D6);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::GlyphArray>(_QWORD *a1, uint64_t a2, const RB::XML::Value::GlyphArray *a3)
{
  RB::XML::Value::GlyphArray *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = (RB::XML::Value::GlyphArray *)operator new();
  RB::XML::Value::GlyphArray::GlyphArray(v6, a3);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::GlyphArray,void>(v8 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

void sub_209B04EA0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10B1C405BD735CELL);
  _Unwind_Resume(a1);
}

void RB::XML::Value::GlyphArray::~GlyphArray(RB::XML::Value::GlyphArray *this)
{
  void *v2;
  const void *v3;
  void *v4;

  *(_QWORD *)this = &off_24C228E80;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
    free(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)this = &off_24C2292B8;
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
    free(v4);
}

{
  void *v2;
  const void *v3;
  void *v4;

  *(_QWORD *)this = &off_24C228E80;
  v2 = (void *)*((_QWORD *)this + 5);
  if (v2)
    free(v2);
  v3 = (const void *)*((_QWORD *)this + 4);
  if (v3)
    CFRelease(v3);
  *(_QWORD *)this = &off_24C2292B8;
  v4 = (void *)*((_QWORD *)this + 1);
  if (v4)
    free(v4);
  JUMPOUT(0x20BD16544);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::FloatArray>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  _QWORD *result;
  uint64_t *v13;
  _QWORD *v14;
  unint64_t v15;
  uint64_t v16;

  v6 = (_QWORD *)operator new();
  v7 = (uint64_t)v6;
  v8 = 0;
  *v6 = &off_24C228E58;
  v6[1] = 0;
  v6[2] = 0;
  v6[3] = 0;
  v9 = *(_QWORD *)(a3 + 16);
  if (v9)
  {
    v13 = *(uint64_t **)(a3 + 8);
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)(v6 + 1), v9);
    v8 = *(_QWORD *)(v7 + 16);
    v14 = (_QWORD *)(*(_QWORD *)(v7 + 8) + 8 * v8);
    v15 = v9;
    do
    {
      v16 = *v13++;
      *v14++ = v16;
      --v15;
    }
    while (v15);
  }
  *(_QWORD *)(v7 + 16) = v8 + v9;
  v10 = a1[7];
  if (a1[8] < (unint64_t)(v10 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v10 + 1);
    v10 = a1[7];
  }
  v11 = (_QWORD *)(a1[6] + 24 * v10);
  *v11 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::FloatArray,void>(v11 + 1, v7);
  ++a1[7];
  return result;
}

void sub_209B0501C(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*v2)
    free(*v2);
  MEMORY[0x20BD16544](v1, 0x1081C404FE48876);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Int>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  v7 = *(_QWORD *)(a3 + 8);
  *v6 = &unk_24C228FE8;
  v6[1] = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Int,void>(v9 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Vec2>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C2290B0;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec2,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Bool>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229010;
  *(_BYTE *)(v6 + 8) = *(_BYTE *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Bool,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

double RBShapeGetFontQuantizationLevel(uint64_t a1, char a2)
{
  float64x2_t v2;
  int64x2_t v3;
  double result;
  float64x2_t v5[3];
  float32x2_t v6[2];

  v2 = *(float64x2_t *)(a1 + 16);
  v3 = *(int64x2_t *)(a1 + 32);
  v5[0] = *(float64x2_t *)a1;
  v5[1] = v2;
  v5[2] = (float64x2_t)v3;
  *(_QWORD *)&result = *(_OWORD *)&vcvtq_f64_f32(v6[0]);
  return result;
}

double RBShapeGetPredictedFontQuantizationError(float64x2_t *a1, float64x2_t a2, float64_t a3, float64x2_t a4, float64_t a5)
{
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  double result;
  float64x2_t v11[3];
  float32x2_t v12[2];

  a2.f64[1] = a3;
  v5 = vcvt_f32_f64(a2);
  v6 = vrecpe_f32(v5);
  v7 = vmul_f32(vrecps_f32(v5, v6), v6);
  v12[0] = v5;
  v12[1] = vmul_f32(v7, vrecps_f32(v5, v7));
  a4.f64[1] = a5;
  v8 = a1[1];
  v9 = a1[2];
  v11[0] = *a1;
  v11[1] = v8;
  v11[2] = v9;
  return result;
}

double RBShapeGetFontDilationParameters(float64x2_t a1, float64_t a2, uint64_t a3, float64x2_t *a4, __int16 a5)
{
  float32x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float v9;
  double result;
  float64x2_t v11[3];

  a1.f64[1] = a2;
  v6 = vcvt_f32_f64(a1);
  v7 = a4[1];
  v8 = a4[2];
  v11[0] = *a4;
  v11[1] = v7;
  v11[2] = v8;
  v9 = RB::AffineTransform::scale(v11);
  return result;
}

RB::XML::Value::GlyphArray *RB::XML::Value::GlyphArray::GlyphArray(RB::XML::Value::GlyphArray *this, CGFontRef font, const unsigned __int16 *a3, unint64_t a4)
{
  CGFontRef v7;
  unint64_t v9;
  unint64_t v10;
  __int16 v11;

  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  *(_QWORD *)this = &off_24C228E80;
  *((_QWORD *)this + 1) = 0;
  v7 = CGFontRetain(font);
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 4) = v7;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  if (a4)
  {
    RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, a4);
    v9 = *((_QWORD *)this + 6);
    do
    {
      v10 = v9 + 1;
      if (*((_QWORD *)this + 7) < v9 + 1)
      {
        RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, v10);
        v9 = *((_QWORD *)this + 6);
        v10 = v9 + 1;
      }
      v11 = *a3++;
      *(_WORD *)(*((_QWORD *)this + 5) + 2 * v9) = v11;
      *((_QWORD *)this + 6) = v10;
      v9 = v10;
      --a4;
    }
    while (a4);
  }
  return this;
}

void sub_209B053F4(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  const void *v4;
  void *v5;

  if (*v2)
    free(*v2);
  v4 = (const void *)v1[4];
  if (v4)
    CFRelease(v4);
  *v1 = &off_24C2292B8;
  v5 = (void *)v1[1];
  if (v5)
    free(v5);
  _Unwind_Resume(exception_object);
}

void *RB::vector<unsigned short,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,2ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,2ul>(void *a1, size_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(2 * a3);
    v6 = v5 >> 1;
    if (v5 >> 1 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

void *RB::vector<RB::Coverage::`anonymous namespace'::PositionedGlyph,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 258) + (*((_QWORD *)__dst + 258) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 258) + (*((_QWORD *)__dst + 258) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 256), __dst, 0x80uLL, (size_t *)__dst + 258, v3);
  *((_QWORD *)__dst + 256) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,16ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 16 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(16 * a5);
    v9 = v8 >> 4;
    if (v8 >> 4 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 16 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Font,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229C40;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B05668(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Font *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Font>,std::allocator<RB::XML::Value::Font>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Font *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Font>,std::allocator<RB::XML::Value::Font>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::GlyphArray,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C2299D8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B05720(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::GlyphArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::GlyphArray>,std::allocator<RB::XML::Value::GlyphArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::GlyphArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::GlyphArray>,std::allocator<RB::XML::Value::GlyphArray>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

RB::XML::Value::GlyphArray *RB::XML::Value::GlyphArray::GlyphArray(RB::XML::Value::GlyphArray *this, const RB::XML::Value::GlyphArray *a2)
{
  uint64_t v4;
  uint64_t v5;
  CFTypeRef v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  __int16 *v14;
  _WORD *v15;
  unint64_t v16;
  __int16 v17;

  v4 = 0;
  *(_QWORD *)this = &off_24C2292B8;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
  v5 = *((_QWORD *)a2 + 2);
  if (v5)
  {
    v10 = (uint64_t *)*((_QWORD *)a2 + 1);
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)this + 8, *((_QWORD *)a2 + 2));
    v11 = (_QWORD *)(*((_QWORD *)this + 1) + 8 * *((_QWORD *)this + 2));
    v12 = v5;
    do
    {
      v13 = *v10++;
      *v11++ = v13;
      --v12;
    }
    while (v12);
    v4 = *((_QWORD *)this + 2);
  }
  *((_QWORD *)this + 2) = v4 + v5;
  *(_QWORD *)this = &off_24C228E80;
  v6 = (CFTypeRef)*((_QWORD *)a2 + 4);
  if (v6)
    v6 = CFRetain(v6);
  v7 = 0;
  *((_QWORD *)this + 5) = 0;
  *((_QWORD *)this + 4) = v6;
  *((_QWORD *)this + 6) = 0;
  *((_QWORD *)this + 7) = 0;
  v8 = *((_QWORD *)a2 + 6);
  if (v8)
  {
    v14 = (__int16 *)*((_QWORD *)a2 + 5);
    RB::vector<unsigned short,0ul,unsigned long>::reserve_slow((uint64_t)this + 40, v8);
    v7 = *((_QWORD *)this + 6);
    v15 = (_WORD *)(*((_QWORD *)this + 5) + 2 * v7);
    v16 = v8;
    do
    {
      v17 = *v14++;
      *v15++ = v17;
      --v16;
    }
    while (v16);
  }
  *((_QWORD *)this + 6) = v7 + v8;
  return this;
}

void sub_209B0588C(_Unwind_Exception *exception_object)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;
  const void *v5;
  void *v6;

  if (*v2)
    free(*v2);
  v5 = (const void *)v1[4];
  if (v5)
    CFRelease(v5);
  *v1 = v3 + 16;
  v6 = (void *)v1[1];
  if (v6)
    free(v6);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Value::FloatArray::FloatArray<float>(_QWORD *a1, float *a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v6;
  unint64_t v8;
  unint64_t v9;
  float v10;

  *a1 = &off_24C228E58;
  a1[1] = 0;
  v4 = (uint64_t)(a1 + 1);
  a1[2] = 0;
  a1[3] = 0;
  if (a3)
  {
    v6 = a3;
    RB::vector<unsigned long,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 1), a3);
    v8 = a1[2];
    do
    {
      v9 = v8 + 1;
      if (a1[3] < v8 + 1)
      {
        RB::vector<unsigned long,0ul,unsigned long>::reserve_slow(v4, v9);
        v8 = a1[2];
        v9 = v8 + 1;
      }
      v10 = *a2++;
      *(double *)(a1[1] + 8 * v8) = v10;
      a1[2] = v9;
      v8 = v9;
      --v6;
    }
    while (v6);
  }
  return a1;
}

void sub_209B05984(_Unwind_Exception *exception_object)
{
  void **v1;

  if (*v1)
    free(*v1);
  _Unwind_Resume(exception_object);
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::FloatArray,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C2299A0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B059F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::FloatArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::FloatArray>,std::allocator<RB::XML::Value::FloatArray>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::FloatArray *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::FloatArray>,std::allocator<RB::XML::Value::FloatArray>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Int,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229BD0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B05AAC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Int *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Int>,std::allocator<RB::XML::Value::Int>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Int *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Int>,std::allocator<RB::XML::Value::Int>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Vec2,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229CE8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B05B64(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Vec2 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec2>,std::allocator<RB::XML::Value::Vec2>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Vec2 *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Vec2>,std::allocator<RB::XML::Value::Vec2>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Bool,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229C08;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B05C1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Bool *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Bool>,std::allocator<RB::XML::Value::Bool>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Bool *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Bool>,std::allocator<RB::XML::Value::Bool>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t RB::Rect::contains(float32x2_t *a1, float32x2_t a2, double a3, double a4, double a5, int32x4_t a6)
{
  float32x2_t v6;
  float32x2_t v7;
  uint32x2_t v8;

  v6 = a1[1];
  *(int32x2_t *)a6.i8 = vcltz_f32(v6);
  v7 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(a6), (int8x8_t)vadd_f32(*a1, v6), (int8x8_t)*a1);
  v8 = (uint32x2_t)vand_s8((int8x8_t)vcgt_f32(vadd_f32(v7, (float32x2_t)(*(_QWORD *)&v6 & 0x7FFFFFFF7FFFFFFFLL)), a2), (int8x8_t)vcge_f32(a2, v7));
  return vpmin_u32(v8, v8).u32[0] >> 31;
}

uint64_t RB::Rect::intersects(float32x2_t *a1, float32x2_t a2, float32x2_t a3, double a4, double a5, double a6, int32x4_t a7)
{
  uint32x2_t v7;
  float32x2_t v8;
  uint32x2_t v9;
  int32x4_t v10;
  float32x2_t v11;
  float32x2_t v12;
  uint32x2_t v13;

  v7 = (uint32x2_t)vceqz_f32(a3);
  if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) != 0)
    return 0;
  v8 = a1[1];
  v9 = (uint32x2_t)vceqz_f32(v8);
  if ((vpmax_u32(v9, v9).u32[0] & 0x80000000) != 0)
    return 0;
  *(int32x2_t *)a7.i8 = vcltz_f32(v8);
  v10 = vcltzq_s32(a7);
  v11 = (float32x2_t)vbsl_s8(*(int8x8_t *)v10.i8, (int8x8_t)vadd_f32(*a1, v8), (int8x8_t)*a1);
  *(int32x2_t *)v10.i8 = vcltz_f32(a3);
  v12 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v10), (int8x8_t)vadd_f32(a3, a2), (int8x8_t)a2);
  v13 = (uint32x2_t)vcgt_f32(vminnm_f32(vadd_f32(v11, vabs_f32(v8)), vadd_f32(v12, (float32x2_t)(*(_QWORD *)&a3 & 0x7FFFFFFF7FFFFFFFLL))), vmaxnm_f32(v11, v12));
  return vpmin_u32(v13, v13).u32[0] >> 31;
}

float32x2_t RB::Rect::round_outwards_by_scale(float32x2_t *this, float a2)
{
  float32x2_t v2;
  float32x2_t v3;
  float32x2_t v4;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t result;

  v2 = vmul_n_f32(*this, a2);
  v3 = vrndm_f32(v2);
  v4 = vsub_f32(vrndp_f32(vmla_n_f32(v2, this[1], a2)), v3);
  v6 = vrecpe_f32((float32x2_t)LODWORD(a2));
  v7 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(a2), v6), v6);
  v7.i32[0] = vmul_f32(v7, vrecps_f32((float32x2_t)LODWORD(a2), v7)).u32[0];
  v8 = vmul_n_f32(v3, v7.f32[0]);
  result = vmul_n_f32(v4, v7.f32[0]);
  *this = v8;
  this[1] = result;
  return result;
}

BOOL RB::AffineTransform::is_uniform(float64x2_t *this)
{
  int64x2_t v1;
  int64x2_t v2;

  v1 = (int64x2_t)vmulq_f64(*this, *this);
  v2 = (int64x2_t)vmulq_f64(this[1], this[1]);
  *(float32x2_t *)v1.i8 = vcvt_f32_f64(vaddq_f64((float64x2_t)vzip1q_s64(v1, v2), (float64x2_t)vzip2q_s64(v1, v2)));
  return fabsf(vsub_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1)).f32[0]) < 0.001;
}

uint64_t RB::can_mix(RB *this, const RB::AffineTransform *a2, const RB::AffineTransform *a3)
{
  int64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  int64x2_t v6;
  int64x2_t v7;
  int64x2_t v8;
  double v9;
  double v10;

  v3 = *(int64x2_t *)this;
  v4 = *((float64x2_t *)this + 1);
  v6 = *(int64x2_t *)a2;
  v5 = *((float64x2_t *)a2 + 1);
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4, v5), (int8x16_t)vceqq_f64(*(float64x2_t *)this, *(float64x2_t *)a2)), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 2), *((float64x2_t *)a2 + 2)));
  v8 = (int64x2_t)vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7);
  if (v8.i64[0] < 0)
    return 4;
  *(double *)v8.i64 = -*(double *)&v3.i64[1];
  v9 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v8, v3), v4));
  v4.f64[0] = -*(double *)&v6.i64[1];
  v10 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v4, v6), v5));
  if (v9 > 0.0 && v10 > 0.0)
    return 1;
  if (v10 < 0.0)
    return v9 < 0.0;
  return 0;
}

CGAffineTransform *RB::mix(CGAffineTransform *this, float64x2_t *a2, const RB::AffineTransform *a3, float a4)
{
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  int64x2_t v10;
  CGFloat v11;
  CGFloat v12;
  double height;
  double width;
  double rotation;
  double v16;
  float64x2_t v17;
  float64x2_t v18;
  CGAffineTransformComponents components;
  CGAffineTransform v20;
  CGAffineTransform v21;
  CGAffineTransformComponents v22;
  CGAffineTransform transform;
  CGAffineTransformComponents v24;

  v6 = *(float64x2_t *)&this->a;
  v7 = *(float64x2_t *)&this->c;
  v9 = *a2;
  v8 = a2[1];
  v10 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v7, v8), (int8x16_t)vceqq_f64(*(float64x2_t *)&this->a, *a2));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).u64[0] & 0x8000000000000000) == 0)
  {
    v11 = a2->f64[1];
    if (v6.f64[1] != 0.0 || v7.f64[0] != 0.0 || v9.f64[1] != 0.0 || v8.f64[0] != 0.0)
    {
      v12 = a2[1].f64[1];
      if (v6.f64[0] != 0.0 || v7.f64[1] != 0.0 || v9.f64[0] != 0.0 || v8.f64[1] != 0.0)
      {
        v17 = *a2;
        v18 = a2[1];
        *(_OWORD *)&transform.a = *(_OWORD *)&this->a;
        *(float64x2_t *)&transform.c = v7;
        *(_OWORD *)&transform.tx = *(_OWORD *)&this->tx;
        memset(&v24, 0, sizeof(v24));
        CGAffineTransformDecompose(&v24, &transform);
        v21.a = v17.f64[0];
        v21.b = v11;
        v21.c = v18.f64[0];
        v21.d = v12;
        *(float64x2_t *)&v21.tx = a2[2];
        memset(&v22, 0, sizeof(v22));
        CGAffineTransformDecompose(&v22, &v21);
        width = v24.scale.width;
        height = v24.scale.height;
        if ((v24.scale.width >= 0.0 || v22.scale.height >= 0.0) && (v24.scale.height >= 0.0 || v22.scale.width >= 0.0))
        {
          rotation = v24.rotation;
        }
        else
        {
          width = -v24.scale.width;
          height = -v24.scale.height;
          v24.scale.width = -v24.scale.width;
          v24.scale.height = -v24.scale.height;
          rotation = dbl_209BD5310[v24.rotation < 0.0] + v24.rotation;
          v24.rotation = rotation;
        }
        if (rotation == 0.0)
        {
          v24.rotation = 6.28318531;
          rotation = 6.28318531;
        }
        v16 = v22.rotation;
        if (v22.rotation == 0.0)
        {
          v22.rotation = 6.28318531;
          v16 = 6.28318531;
        }
        if (vabdd_f64(rotation, v16) > 3.14159265)
        {
          if (rotation <= v16)
          {
            v16 = v16 + -6.28318531;
            v22.rotation = v16;
          }
          else
          {
            rotation = rotation + -6.28318531;
            v24.rotation = rotation;
          }
        }
        components.scale.width = width + (v22.scale.width - width) * a4;
        components.scale.height = height + (v22.scale.height - height) * a4;
        components.horizontalShear = v24.horizontalShear + (v22.horizontalShear - v24.horizontalShear) * a4;
        components.rotation = rotation + (v16 - rotation) * a4;
        components.translation = (CGVector)vmlaq_n_f64((float64x2_t)v24.translation, vsubq_f64((float64x2_t)v22.translation, (float64x2_t)v24.translation), a4);
        return CGAffineTransformMakeWithComponents(&v20, &components);
      }
    }
  }
  return this;
}

uint64_t RB::can_mix(float64x2_t *this, float64x2_t *a2, const RB::AffineTransform *a3)
{
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  int64x2_t v9;
  int64x2_t v10;
  float64x2_t v11;
  double v12;
  double v13;

  if (this == a2)
    return 4;
  v3 = (float64x2_t)xmmword_209BD5290;
  v4 = (float64x2_t)xmmword_209BD52A0;
  v5 = 0uLL;
  v6 = 0uLL;
  v7 = (float64x2_t)xmmword_209BD52A0;
  v8 = (float64x2_t)xmmword_209BD5290;
  if (this)
  {
    v8 = *this;
    v7 = this[1];
    v6 = this[2];
  }
  if (a2)
  {
    v3 = *a2;
    v4 = a2[1];
    v5 = a2[2];
  }
  v9 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v7, v4), (int8x16_t)vceqq_f64(v6, v5)), (int8x16_t)vceqq_f64(v8, v3));
  v10 = (int64x2_t)vandq_s8((int8x16_t)vdupq_laneq_s64(v9, 1), (int8x16_t)v9);
  if (v10.i64[0] < 0)
    return 4;
  *(double *)v10.i64 = -v8.f64[1];
  v11 = (float64x2_t)vzip1q_s64(v10, (int64x2_t)v8);
  v12 = vaddvq_f64(vmulq_f64(v11, v7));
  v11.f64[0] = -v3.f64[1];
  v13 = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64((int64x2_t)v11, (int64x2_t)v3), v4));
  if (v12 > 0.0 && v13 > 0.0)
    return 1;
  if (v13 < 0.0)
    return v12 < 0.0;
  return 0;
}

CGFloat RB::mix(RB *this, const RB::AffineTransform ***a2, const RB::AffineTransform **a3, const RB::AffineTransform *a4, CGFloat result)
{
  const RB::AffineTransform **v5;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  const RB::AffineTransform **v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  CGAffineTransform v18;

  v5 = *a2;
  if (*a2 == a3)
    return result;
  if (!v5)
  {
    *(_OWORD *)&v18.a = xmmword_209BD5290;
    *(_OWORD *)&v18.c = xmmword_209BD52A0;
    *(_OWORD *)&v18.tx = 0uLL;
    if (a3)
      goto LABEL_4;
LABEL_6:
    v15 = xmmword_209BD5290;
    v16 = xmmword_209BD52A0;
    v17 = 0uLL;
    goto LABEL_7;
  }
  v8 = *((_OWORD *)v5 + 1);
  *(_OWORD *)&v18.a = *(_OWORD *)v5;
  *(_OWORD *)&v18.c = v8;
  *(_OWORD *)&v18.tx = *((_OWORD *)v5 + 2);
  if (!a3)
    goto LABEL_6;
LABEL_4:
  v9 = *((_OWORD *)a3 + 1);
  v15 = *(_OWORD *)a3;
  v16 = v9;
  v17 = *((_OWORD *)a3 + 2);
LABEL_7:
  RB::mix(&v18, (float64x2_t *)&v15, (const RB::AffineTransform *)a3, *(float *)&result);
  *(_OWORD *)&v18.a = v10;
  *(_OWORD *)&v18.c = v11;
  *(_OWORD *)&v18.tx = v12;
  v13 = (const RB::AffineTransform **)((*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0);
  if ((unint64_t)(v13 + 6) > *((_QWORD *)this + 3))
    v13 = (const RB::AffineTransform **)RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 15);
  else
    *((_QWORD *)this + 2) = v13 + 6;
  v14 = *(_OWORD *)&v18.c;
  *(_OWORD *)v13 = *(_OWORD *)&v18.a;
  *((_OWORD *)v13 + 1) = v14;
  result = v18.tx;
  *((_OWORD *)v13 + 2) = *(_OWORD *)&v18.tx;
  *a2 = v13;
  return result;
}

_QWORD *RB::Rect::operator std::string@<X0>(_QWORD *a1@<X0>, _QWORD *a2@<X8>)
{
  char __s[256];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  snprintf_l(__s, 0x100uLL, 0, "[%g %g; %g %g]",
    COERCE_FLOAT(*a1),
    COERCE_FLOAT(HIDWORD(*a1)),
    COERCE_FLOAT(a1[1]),
    COERCE_FLOAT(HIDWORD(a1[1])));
  return std::string::basic_string[abi:nn180100]<0>(a2, __s);
}

_QWORD *RB::AffineTransform::operator std::string@<X0>(double *a1@<X0>, _QWORD *a2@<X8>)
{
  char __s[256];
  uint64_t v5;

  v5 = *MEMORY[0x24BDAC8D0];
  snprintf_l(__s, 0x100uLL, 0, "[%g %g; %g %g; %g %g]", *a1, a1[1], a1[2], a1[3], a1[4], a1[5]);
  return std::string::basic_string[abi:nn180100]<0>(a2, __s);
}

double *RB::AffineTransform::encode(double *this, RB::ProtobufEncoder *a2)
{
  double *v3;
  int v4;
  double v5;
  int v6;
  int v7;
  int v8;
  int v9;
  int v10;

  v3 = this;
  *(float *)&v4 = *this;
  if (*(float *)&v4 == 1.0)
  {
    v5 = this[1];
  }
  else
  {
    RB::ProtobufEncoder::encode_varint(a2, 0xDuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v4);
    v5 = v3[1];
  }
  *(float *)&v6 = v5;
  if (*(float *)&v6 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x15uLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v6);
  }
  *(float *)&v7 = v3[2];
  if (*(float *)&v7 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x1DuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v7);
  }
  *(float *)&v8 = v3[3];
  if (*(float *)&v8 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x25uLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v8);
  }
  *(float *)&v9 = v3[4];
  if (*(float *)&v9 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x2DuLL);
    this = (double *)RB::ProtobufEncoder::encode_fixed32(a2, v9);
  }
  *(float *)&v10 = v3[5];
  if (*(float *)&v10 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x35uLL);
    return (double *)RB::ProtobufEncoder::encode_fixed32(a2, v10);
  }
  return this;
}

unint64_t RB::AffineTransform::decode(RB::AffineTransform *this, RB::ProtobufDecoder *a2)
{
  unint64_t result;
  unint64_t v5;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          *(double *)this = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 2u:
          *((double *)this + 1) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 3u:
          *((double *)this + 2) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 4u:
          *((double *)this + 3) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 5u:
          *((double *)this + 4) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        case 6u:
          *((double *)this + 5) = RB::ProtobufDecoder::float_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

_QWORD *std::string::basic_string[abi:nn180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    abort();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

std::string *RB::SexpString::newline(std::string *this)
{
  std::string *result;

  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    if (!this->__r_.__value_.__l.__size_)
      goto LABEL_4;
    goto LABEL_3;
  }
  if (*((_BYTE *)&this->__r_.__value_.__s + 23))
LABEL_3:
    std::string::push_back(this, 10);
LABEL_4:
  this[1].__r_.__value_.__s.__data_[16] = 0;
  this[1].__r_.__value_.__l.__size_ = 0;
  result = std::string::append(this, 2 * this[1].__r_.__value_.__r.__words[0], 32);
  this[1].__r_.__value_.__l.__size_ += 2 * this[1].__r_.__value_.__r.__words[0];
  return result;
}

size_t RB::SexpString::push(std::string *this, const char *a2)
{
  size_t v4;
  size_t result;
  uint64_t v6;

  RB::SexpString::newline(this);
  std::string::push_back(this, 40);
  v4 = strlen(a2);
  std::string::append(this, a2, v4);
  result = strlen(a2);
  v6 = result + this[1].__r_.__value_.__l.__size_ + 1;
  ++this[1].__r_.__value_.__r.__words[0];
  this[1].__r_.__value_.__l.__size_ = v6;
  return result;
}

void RB::SexpString::pop(std::string *this)
{
  --this[1].__r_.__value_.__r.__words[0];
  std::string::push_back(this, 41);
  ++this[1].__r_.__value_.__l.__size_;
}

std::string *RB::SexpString::print(std::string *this, char a2, const char *__s)
{
  size_t v6;
  size_t v7;
  size_t v8;
  std::string *result;
  std::string::size_type size;

  v6 = strlen(__s);
  v7 = v6;
  if (SHIBYTE(this->__r_.__value_.__r.__words[2]) < 0)
  {
    if (!this->__r_.__value_.__l.__size_)
      goto LABEL_8;
  }
  else if (!*((_BYTE *)&this->__r_.__value_.__s + 23))
  {
    goto LABEL_8;
  }
  if ((a2 & 1) != 0
    || this[1].__r_.__value_.__s.__data_[16]
    || (size = this[1].__r_.__value_.__l.__size_) != 0 && v6 + size - 79 <= 0xFFFFFFFFFFFFFFAFLL)
  {
    RB::SexpString::newline(this);
  }
  else
  {
    std::string::push_back(this, 32);
    ++this[1].__r_.__value_.__l.__size_;
  }
LABEL_8:
  v8 = strlen(__s);
  result = std::string::append(this, __s, v8);
  this[1].__r_.__value_.__l.__size_ += v7;
  this[1].__r_.__value_.__s.__data_[16] = 0;
  return result;
}

void RB::SexpString::vprintf(std::string *this, char a2, const char *a3, va_list a4)
{
  char *__s;

  __s = 0;
  vasprintf(&__s, a3, a4);
  if (__s)
  {
    RB::SexpString::print(this, a2, __s);
    free(__s);
  }
}

void RB::SexpString::printf(std::string *this, char a2, const char *a3, ...)
{
  va_list va;

  va_start(va, a3);
  RB::SexpString::vprintf(this, a2, a3, va);
}

void RB::SexpString::print_ctm(std::string *this, const RB::AffineTransform *a2)
{
  void **v3;
  void *__p[2];
  char v5;

  if (a2)
  {
    RB::AffineTransform::operator std::string((double *)a2, __p);
    if (v5 >= 0)
      v3 = __p;
    else
      v3 = (void **)__p[0];
    RB::SexpString::printf(this, 0, "(CTM %s)", (const char *)v3);
    if (v5 < 0)
      operator delete(__p[0]);
  }
}

float64_t RB::Path::Orientation::endpath(float64x2_t *this)
{
  float64x2_t v1;
  float64x2_t v2;
  int8x16_t v3;
  int64x2_t v4;

  v1 = this[1];
  v2 = this[2];
  v3 = (int8x16_t)vceqq_f64(v1, v2);
  v4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3);
  if (v4.i64[0] < 0)
  {
    *(double *)v4.i64 = -v2.f64[1];
    this->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v4, (int64x2_t)v2), v1)) + this->f64[1];
    this[2] = v1;
  }
  return v1.f64[0];
}

float64_t RB::Path::Orientation::closepath(float64x2_t *this)
{
  float64x2_t v1;
  float64x2_t v2;
  int8x16_t v3;
  int64x2_t v4;

  v1 = this[1];
  v2 = this[2];
  v3 = (int8x16_t)vceqq_f64(v1, v2);
  v4 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v3), 1), v3);
  if (v4.i64[0] < 0)
  {
    *(double *)v4.i64 = -v2.f64[1];
    this->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v4, (int64x2_t)v2), v1)) + this->f64[1];
    this[2] = v1;
  }
  return v1.f64[0];
}

float64_t RB::Path::Orientation::lineto(uint64_t a1, float64x2_t a2, double a3, int64x2_t a4)
{
  float64x2_t v4;

  *(double *)a4.i64 = -*(double *)(a1 + 40);
  v4 = vmulq_f64((float64x2_t)vzip1q_s64(a4, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)(a1 + 8) = v4.f64[1] + *(double *)(a1 + 8) + v4.f64[0];
  *(float64x2_t *)(a1 + 32) = a2;
  return a2.f64[0];
}

float64x2_t *RB::Path::Orientation::moveto(float64x2_t *result, float64x2_t a2)
{
  float64x2_t v2;
  float64x2_t v3;
  int8x16_t v4;
  int64x2_t v5;

  v2 = result[1];
  v3 = result[2];
  v4 = (int8x16_t)vceqq_f64(v2, v3);
  v5 = (int64x2_t)vornq_s8((int8x16_t)vdupq_laneq_s64((int64x2_t)vmvnq_s8(v4), 1), v4);
  if (v5.i64[0] < 0)
  {
    *(double *)v5.i64 = -v3.f64[1];
    result->f64[1] = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v5, (int64x2_t)v3), v2)) + result->f64[1];
  }
  result[1] = a2;
  result[2] = a2;
  return result;
}

double RB::Path::Orientation::quadto(uint64_t a1, float64x2_t a2, float64x2_t a3, double a4, int64x2_t a5, double a6, int64x2_t a7)
{
  float64x2_t v7;
  double result;

  *(double *)a5.i64 = -*(double *)(a1 + 40);
  v7 = vmulq_f64((float64x2_t)vzip1q_s64(a5, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)a7.i64 = -a2.f64[1];
  result = vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(a7, (int64x2_t)a2), a3))
         + *(double *)(a1 + 8)
         + v7.f64[1]
         + v7.f64[0];
  *(double *)(a1 + 8) = result;
  *(float64x2_t *)(a1 + 32) = a3;
  return result;
}

float64_t RB::Path::Orientation::cubeto(uint64_t a1, float64x2_t a2, float64x2_t a3, float64x2_t a4, double a5, int64x2_t a6, double a7, int64x2_t a8)
{
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64_t result;

  *(double *)a6.i64 = -*(double *)(a1 + 40);
  v8 = vmulq_f64((float64x2_t)vzip1q_s64(a6, *(int64x2_t *)(a1 + 32)), a2);
  *(double *)a8.i64 = -a2.f64[1];
  v9 = vmulq_f64((float64x2_t)vzip1q_s64(a8, (int64x2_t)a2), a3);
  *(double *)a8.i64 = -a3.f64[1];
  v10 = vmulq_f64((float64x2_t)vzip1q_s64(a8, (int64x2_t)a3), a4);
  result = vaddq_f64(vaddq_f64(v9, (float64x2_t)vdupq_laneq_s64((int64x2_t)v9, 1)), vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1), v10)).f64[0]+ *(double *)(a1 + 8)+ v8.f64[1]+ v8.f64[0];
  *(float64_t *)(a1 + 8) = result;
  *(float64x2_t *)(a1 + 32) = a4;
  return result;
}

_QWORD *RB::Path::Reverser::begin_subpath(_QWORD *this)
{
  _QWORD *v1;
  uint64_t v2;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;

  if (!this[19] && !this[535])
  {
    v1 = this + 22;
    if (this[536])
    {
      v2 = 0;
    }
    else
    {
      v4 = this + 22;
      v5 = this;
      _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(this + 22, 1uLL);
      v1 = v4;
      this = v5;
      v2 = v5[535];
    }
    if (this[534])
      v1 = (_QWORD *)this[534];
    v3 = &v1[2 * v2];
    *v3 = 0;
    v3[1] = 0;
    ++this[535];
  }
  return this;
}

uint64_t RB::Path::Reverser::flush_subpath(uint64_t this, char a2)
{
  uint64_t v2;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  __n128 v7;
  uint64_t v8;
  __n128 *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v2 = this;
  if (*(_QWORD *)(this + 152))
  {
    v4 = this + 176;
    if (*(_QWORD *)(this + 4272))
      v4 = *(_QWORD *)(this + 4272);
    v5 = v4 + 16 * *(_QWORD *)(this + 4280);
    v7 = *(__n128 *)(v5 - 16);
    v6 = v5 - 16;
    this = (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(this + 8) + 16))(*(_QWORD *)(this + 8), v7);
    v8 = *(_QWORD *)(v2 + 152);
    if (v8)
    {
      v9 = (__n128 *)(v6 - 16);
      v10 = v8 - 1;
      do
      {
        v11 = *(_QWORD *)(v2 + 144);
        if (!v11)
          v11 = v2 + 16;
        v12 = *(unsigned __int8 *)(v11 + v10);
        switch((_DWORD)v12)
        {
          case 3:
            this = (*(uint64_t (**)(_QWORD, __n128, __n128, __n128))(**(_QWORD **)(v2 + 8) + 40))(*(_QWORD *)(v2 + 8), *v9, v9[-1], v9[-2]);
            break;
          case 2:
            this = (*(uint64_t (**)(_QWORD, __n128, __n128))(**(_QWORD **)(v2 + 8) + 32))(*(_QWORD *)(v2 + 8), *v9, v9[-1]);
            break;
          case 1:
            this = (*(uint64_t (**)(_QWORD, __n128))(**(_QWORD **)(v2 + 8) + 24))(*(_QWORD *)(v2 + 8), *v9);
            break;
        }
        v9 -= v12;
        --v10;
      }
      while (v10 != -1);
    }
    if ((a2 & 1) != 0)
      this = (*(uint64_t (**)(_QWORD))(**(_QWORD **)(v2 + 8) + 8))(*(_QWORD *)(v2 + 8));
  }
  *(_QWORD *)(v2 + 4280) = 0;
  *(_QWORD *)(v2 + 152) = 0;
  return this;
}

uint64_t RB::Path::Reverser::endpath(RB::Path::Reverser *this)
{
  RB::Path::Reverser::flush_subpath((uint64_t)this, 0);
  return (***((uint64_t (****)(_QWORD))this + 1))(*((_QWORD *)this + 1));
}

uint64_t RB::Path::Reverser::closepath(RB::Path::Reverser *this)
{
  return RB::Path::Reverser::flush_subpath((uint64_t)this, 1);
}

__n128 RB::Path::Reverser::moveto(_QWORD *a1, __n128 a2)
{
  uint64_t v3;
  _QWORD *v4;
  __n128 result;

  RB::Path::Reverser::flush_subpath((uint64_t)a1, 0);
  v3 = a1[535];
  if (a1[536] < (unint64_t)(v3 + 1))
  {
    _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v3 + 1);
    v3 = a1[535];
  }
  v4 = (_QWORD *)a1[534];
  if (!v4)
    v4 = a1 + 22;
  result = a2;
  *(__n128 *)&v4[2 * v3] = a2;
  ++a1[535];
  return result;
}

void *RB::Path::Reverser::lineto(_QWORD *a1, __n128 a2)
{
  void *result;
  uint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;

  result = RB::Path::Reverser::begin_subpath(a1);
  v4 = a1[535];
  if (a1[536] < (unint64_t)(v4 + 1))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v4 + 1);
    v4 = a1[535];
  }
  v5 = (_QWORD *)a1[534];
  if (!v5)
    v5 = a1 + 22;
  *(__n128 *)&v5[2 * v4] = a2;
  ++a1[535];
  v6 = a1[19];
  if (a1[20] < (unint64_t)(v6 + 1))
  {
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v6 + 1);
    v6 = a1[19];
  }
  v7 = (_QWORD *)a1[18];
  if (!v7)
    v7 = a1 + 2;
  *((_BYTE *)v7 + v6) = 1;
  ++a1[19];
  return result;
}

void *RB::Path::Reverser::quadto(_QWORD *a1, __n128 a2, __n128 a3)
{
  void *result;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;

  result = RB::Path::Reverser::begin_subpath(a1);
  v5 = a1[535];
  if (a1[536] < (unint64_t)(v5 + 1))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v5 + 1);
    v5 = a1[535];
  }
  v6 = (_QWORD *)a1[534];
  if (!v6)
    v6 = a1 + 22;
  *(__n128 *)&v6[2 * v5] = a2;
  v7 = a1[535];
  v8 = v7 + 1;
  a1[535] = v7 + 1;
  if (a1[536] < (unint64_t)(v7 + 2))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v7 + 2);
    v8 = a1[535];
  }
  v9 = (_QWORD *)a1[534];
  if (!v9)
    v9 = a1 + 22;
  *(__n128 *)&v9[2 * v8] = a3;
  ++a1[535];
  v10 = a1[19];
  if (a1[20] < (unint64_t)(v10 + 1))
  {
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v10 + 1);
    v10 = a1[19];
  }
  v11 = (_QWORD *)a1[18];
  if (!v11)
    v11 = a1 + 2;
  *((_BYTE *)v11 + v10) = 2;
  ++a1[19];
  return result;
}

void *RB::Path::Reverser::cubeto(_QWORD *a1, __n128 a2, __n128 a3, __n128 a4)
{
  void *result;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;

  result = RB::Path::Reverser::begin_subpath(a1);
  v6 = a1[535];
  if (a1[536] < (unint64_t)(v6 + 1))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v6 + 1);
    v6 = a1[535];
  }
  v7 = (_QWORD *)a1[534];
  if (!v7)
    v7 = a1 + 22;
  *(__n128 *)&v7[2 * v6] = a2;
  v8 = a1[535];
  v9 = v8 + 1;
  a1[535] = v8 + 1;
  if (a1[536] < (unint64_t)(v8 + 2))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v8 + 2);
    v9 = a1[535];
  }
  v10 = (_QWORD *)a1[534];
  if (!v10)
    v10 = a1 + 22;
  *(__n128 *)&v10[2 * v9] = a3;
  v11 = a1[535];
  v12 = v11 + 1;
  a1[535] = v11 + 1;
  if (a1[536] < (unint64_t)(v11 + 2))
  {
    result = _ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(a1 + 22, v11 + 2);
    v12 = a1[535];
  }
  v13 = (_QWORD *)a1[534];
  if (!v13)
    v13 = a1 + 22;
  *(__n128 *)&v13[2 * v12] = a4;
  ++a1[535];
  v14 = a1[19];
  if (a1[20] < (unint64_t)(v14 + 1))
  {
    result = RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(a1 + 2, v14 + 1);
    v14 = a1[19];
  }
  v15 = (_QWORD *)a1[18];
  if (!v15)
    v15 = a1 + 2;
  *((_BYTE *)v15 + v14) = 3;
  ++a1[19];
  return result;
}

void RB::Path::normalized_map(const CGPath *a1, void (***a2)(float64x2_t *this), float64x2_t *a3)
{
  int64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  void (__cdecl *v9)(void *, const CGPathElement *);
  int64x2_t v10;
  void (**v11)(float64x2_t *);
  __int128 v12;
  __int128 v13;
  uint64_t v14;
  void (***info)(float64x2_t *);
  float64x2_t *v16;

  v11 = (void (**)(float64x2_t *))off_24C222C00;
  v12 = 0u;
  v13 = 0u;
  v14 = 0;
  info = &v11;
  v16 = 0;
  CGPathApply(a1, &info, (CGPathApplierFunction)RB::Path::Iterator::callback_1);
  (*v11)((float64x2_t *)&v11);
  if (a3)
  {
    v8 = *a3;
    v7 = a3[1];
    *(double *)v6.i64 = -a3->f64[1];
    if (vaddvq_f64(vmulq_f64((float64x2_t)vzip1q_s64(v6, *(int64x2_t *)a3), v7)) < 0.0)
    {
      if (*(double *)&v12 >= 0.0)
        goto LABEL_12;
      goto LABEL_8;
    }
    if (*(double *)&v12 >= 0.0)
    {
LABEL_8:
      info = a2;
      v16 = a3;
      v10 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v7, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v8, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a3[2]));
      if (vandq_s8((int8x16_t)vdupq_laneq_s64(v10, 1), (int8x16_t)v10).i64[0] >= 0)
        v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
      else
        v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
      goto LABEL_11;
    }
  }
  else if (*(double *)&v12 >= 0.0)
  {
    info = a2;
    v16 = 0;
    v9 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
LABEL_11:
    CGPathApply(a1, &info, v9);
    (**a2)((float64x2_t *)a2);
    return;
  }
LABEL_12:
  RB::Path::reverse_map((uint64_t)a1, (uint64_t)a2);
}

void RB::Path::reverse_map(uint64_t a1, uint64_t a2)
{
  const CGPath *v2;
  float64x2_t *v3;
  float64x2_t *v4;
  uint64_t v5;
  void (__cdecl *v6)(void *, const CGPathElement *);
  int64x2_t v7;
  _QWORD v8[2];
  _QWORD v9[18];
  void *v10[2];
  uint64_t v11;
  void *v12[2];
  uint64_t v13;
  uint64_t v14;

  v2 = (const CGPath *)MEMORY[0x24BDAC7A8](a1, a2);
  v4 = v3;
  v14 = *MEMORY[0x24BDAC8D0];
  v9[0] = off_24C222CC0;
  v9[1] = v5;
  *(_OWORD *)v10 = 0u;
  v11 = 128;
  *(_OWORD *)v12 = 0u;
  v13 = 256;
  v8[0] = v9;
  v8[1] = v3;
  v6 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_1;
  if (v4)
  {
    v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if (vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).i64[0] >= 0)
      v6 = (void (__cdecl *)(void *, const CGPathElement *))RB::Path::Iterator::callback_0;
  }
  CGPathApply(v2, v8, v6);
  (*(void (**)(_QWORD *))v9[0])(v9);
  if (v12[0])
    free(v12[0]);
  if (v10[0])
    free(v10[0]);
}

void *_ZN2RB6vectorIDv2_dLm256EmE12reserve_slowEm(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 514) + (*((_QWORD *)__dst + 514) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 514) + (*((_QWORD *)__dst + 514) >> 1);
  result = RB::details::realloc_vector<unsigned long,16ul>(*((void **)__dst + 512), __dst, 0x100uLL, (size_t *)__dst + 514, v3);
  *((_QWORD *)__dst + 512) = result;
  return result;
}

void *RB::vector<unsigned char,128ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 18) + (*((_QWORD *)__dst + 18) >> 1);
  result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 16), __dst, 0x80uLL, (size_t *)__dst + 18, v3);
  *((_QWORD *)__dst + 16) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,1ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t __n)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (__n <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, __n);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(__n);
    if (v8 != *a4)
    {
      v9 = v8;
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::Symbol::Model::style_color_index(int a1)
{
  unsigned int v1;

  if ((a1 - 5) >= 4)
    v1 = -1;
  else
    v1 = a1 - 4;
  if (a1)
    return v1;
  else
    return 0;
}

RB::Symbol::Model *RB::Symbol::Model::Model(RB::Symbol::Model *this, const RB::Symbol::Model *a2)
{
  id v4;
  int v5;
  int v6;
  unsigned int v7;
  int v8;
  int v9;
  int v10;
  unsigned int v11;
  __int128 *v13;
  _OWORD *v14;
  int v15;
  __int128 v16;

  *((_DWORD *)this + 2) = 1;
  *(_QWORD *)this = off_24C229870;
  v4 = *((id *)a2 + 2);
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 4) = 0;
  v5 = *((_DWORD *)a2 + 8);
  if (v5)
  {
    v13 = (__int128 *)*((_QWORD *)a2 + 3);
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)this + 24, *((_DWORD *)a2 + 8));
    v14 = (_OWORD *)(*((_QWORD *)this + 3) + 16 * *((unsigned int *)this + 8));
    v15 = v5;
    do
    {
      v16 = *v13++;
      *v14++ = v16;
      --v15;
    }
    while (v15);
    v6 = *((_DWORD *)this + 8);
  }
  else
  {
    v6 = 0;
  }
  *((_DWORD *)this + 8) = v6 + v5;
  *((_QWORD *)this + 5) = *((_QWORD *)a2 + 5);
  *((_QWORD *)this + 6) = *((_QWORD *)a2 + 6);
  *((_QWORD *)this + 7) = *((_QWORD *)a2 + 7);
  *((_OWORD *)this + 4) = *((_OWORD *)a2 + 4);
  *((_QWORD *)this + 10) = *((_QWORD *)a2 + 10);
  v7 = *(unsigned __int16 *)((char *)this + 89);
  v8 = *((unsigned __int8 *)a2 + 88) | (v7 << 8);
  *((_WORD *)this + 44) = v8;
  v7 >>= 8;
  *((_BYTE *)this + 90) = v7;
  v9 = v8 & 0xFF00FF | (*((unsigned __int8 *)a2 + 89) << 8);
  *((_BYTE *)this + 90) = v7;
  *((_WORD *)this + 44) = v9;
  v9 &= ~0x10000u;
  v10 = v9 | ((*((_BYTE *)a2 + 90) & 1) << 16);
  *((_WORD *)this + 44) = v9;
  *((_BYTE *)this + 90) = BYTE2(v10);
  v11 = v10 & 0xFFFDFFFF | (((*((unsigned __int8 *)a2 + 90) >> 1) & 1) << 17);
  *((_WORD *)this + 44) = v9;
  *((_BYTE *)this + 90) = BYTE2(v11);
  *(_DWORD *)((char *)this + 91) = *(_DWORD *)((char *)a2 + 91);
  *((_QWORD *)this + 12) = 0;
  return this;
}

void sub_209B07518(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*v2)
    free(*v2);

  _Unwind_Resume(a1);
}

void RB::Symbol::Model::set_flips_rtl(RB::Symbol::Model *this, int a2)
{
  int v2;
  int v3;
  unsigned int v4;

  v2 = *((unsigned __int16 *)this + 44) | (*((unsigned __int8 *)this + 90) << 16);
  if (((((v2 & 0x20000) == 0) ^ a2) & 1) == 0)
  {
    if (a2)
      v3 = 0x20000;
    else
      v3 = 0;
    v4 = v2 & 0xFFFDFFFF;
    *((_WORD *)this + 44) = v4;
    *((_BYTE *)this + 90) = (v4 | v3) >> 16;
    ++*((_DWORD *)this + 21);
    std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100]((RB::Symbol::Model *)((char *)this + 96), 0);
  }
}

void std::unique_ptr<RB::Symbol::Glyph const,RB::Symbol::GlyphCache::Unref>::reset[abi:nn180100](RB::Symbol::GlyphCache *a1, uint64_t a2)
{
  const RB::Symbol::Glyph *v2;
  os_unfair_lock_s *v3;

  v2 = *(const RB::Symbol::Glyph **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    v3 = (os_unfair_lock_s *)RB::Symbol::GlyphCache::shared(a1);
    RB::Symbol::GlyphCache::unref(v3, v2);
  }
}

uint64_t RB::Refcount<RB::Symbol::Model,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

float32x2_t RB::GlyphPathCache::glyph_dilation(float32x2_t *this, float64x2_t *a2, const RB::AffineTransform *a3)
{
  float v4;
  float v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;
  float32x2_t v9;
  float32x2_t v10;
  float v12;

  v4 = RB::AffineTransform::scale(a2);
  v5 = log2f(v4);
  v6 = vrecpe_f32((float32x2_t)1050989506);
  v7 = vmul_f32(vrecps_f32((float32x2_t)1050989506, v6), v6);
  v12 = exp2f(floorf(v5 * vmul_f32(v7, vrecps_f32((float32x2_t)1050989506, v7)).f32[0]) * 0.32193);
  v8 = RB::Coverage::Glyphs::resolved_dilation(this, v12);
  v9 = vrecpe_f32((float32x2_t)LODWORD(v12));
  v10 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v12), v9), v9);
  return vmul_n_f32(v8, vmul_f32(v10, vrecps_f32((float32x2_t)LODWORD(v12), v10)).f32[0]);
}

uint64_t RB::GlyphPathCache::lookup_glyph(uint64_t a1, RB *a2, CGFont *a3, float64x2_t *this, uint64_t a5, int a6, __n128 a7)
{
  uint32x2_t v13;
  unsigned __int32 v14;
  float v15;
  float v16;
  float v17;
  float32x2_t v18;
  float32x2_t v19;
  float v20;
  int v21;
  unsigned int v22;
  uint64_t v23;
  CGFont *v24;
  const __CFDictionary *normalized_path_cache;
  unsigned int v26;
  __int128 v27;
  float v28;
  unsigned int v29;
  float32x2_t v30;
  float32x2_t v31;
  uint64_t v32;
  uint64_t v33;
  int *v34;
  int32x2_t v35;
  __n128 v36;
  uint64_t v37;
  uint32x2_t v38;
  int8x8_t v39;
  int8x8_t v40;
  unsigned int v41;
  float64x2_t v42;
  _BYTE v44[80];
  __int128 v45;
  __n128 v46;
  int v47[10];
  float32x2_t v48;
  float32x2_t v49;
  void (**v50[3])(_QWORD);
  uint64_t v51;
  const CGPath *v52;
  __int128 v53;
  uint64_t v54;
  _QWORD info[3];

  info[2] = *MEMORY[0x24BDAC8D0];
  v46 = a7;
  v13 = (uint32x2_t)vmvn_s8((int8x8_t)vceqz_f32((float32x2_t)a7.n128_u64[0]));
  v14 = vpmax_u32(v13, v13).u32[0];
  v15 = RB::AffineTransform::scale(this);
  if ((v14 & 0x80000000) != 0)
  {
    v17 = log2f(v15);
    v18 = vrecpe_f32((float32x2_t)1050989506);
    v19 = vmul_f32(vrecps_f32((float32x2_t)1050989506, v18), v18);
    v16 = exp2f(floorf(v17 * vmul_f32(v19, vrecps_f32((float32x2_t)1050989506, v19)).f32[0]) * 0.32193);
  }
  else
  {
    v47[0] = 0;
    frexpf(v15, v47);
    v16 = scalbnf(1.0, v47[0]);
  }
  v20 = v16;
  LODWORD(v53) = CGFontGetIdentifier();
  *((float *)&v53 + 1) = v20;
  *((_QWORD *)&v53 + 1) = v46.n128_u64[0];
  LOBYTE(v54) = a6;
  WORD1(v54) = (_WORD)a3;
  v21 = v46.n128_u32[0] ^ a3 ^ v46.n128_u32[1] ^ LODWORD(v20) ^ ((_DWORD)v53 << 8);
  if (a6)
    v21 = -v21 ^ a6;
  v22 = 9 * ((v21 + ~(v21 << 15)) ^ ((v21 + ~(v21 << 15)) >> 10));
  HIDWORD(v54) = ((v22 ^ (v22 >> 6)) + ~((v22 ^ (v22 >> 6)) << 11)) ^ (((v22 ^ (v22 >> 6)) + ~((v22 ^ (v22 >> 6)) << 11)) >> 16);
  v23 = (uint64_t)RB::UntypedTable::lookup((RB::UntypedTable *)(a1 + 8), (uint64_t *)&v53, 0);
  if (v23)
  {
    ++*(_QWORD *)(a1 + 104);
    goto LABEL_19;
  }
  ++*(_QWORD *)(a1 + 112);
  v23 = operator new();
  normalized_path_cache = 0;
  *(_QWORD *)(v23 + 16) = v54;
  *(_DWORD *)(v23 + 24) = 1065353216;
  v26 = ++RB::GlyphPathCache::Path::last_id;
  *(_OWORD *)v23 = v53;
  *(_OWORD *)(v23 + 32) = 0u;
  *(_OWORD *)(v23 + 48) = 0u;
  *(_QWORD *)(v23 + 64) = 0;
  *(_QWORD *)(v23 + 76) = v26;
  if ((a6 & 2) != 0)
    normalized_path_cache = (const __CFDictionary *)RB::cg_font_get_normalized_path_cache(a2, v24);
  RB::cg_font_get_glyph_path(a2, a3, normalized_path_cache, &v52);
  if (v52)
  {
    *(float *)&v27 = (float)CGFontGetUnitsPerEm(a2);
    v45 = v27;
    *(float *)(v23 + 24) = 1.0 / *(float *)&v27;
    v28 = RB::bezier_flatness((RB *)(a6 & 2));
    *(float *)&v29 = *(float *)(v23 + 24) * v20;
    v30 = vrecpe_f32((float32x2_t)v29);
    v31 = vmul_f32(vrecps_f32((float32x2_t)v29, v30), v30);
    v50[0] = (void (**)(_QWORD))off_24C228C80;
    v50[1] = (void (**)(_QWORD))(v23 + 48);
    v50[2] = 0;
    v51 = 0;
    v32 = RB::Path::Flattener::Flattener((uint64_t)v47, v50, v28 * vmul_f32(v31, vrecps_f32((float32x2_t)v29, v31)).f32[0], (float32x2_t)0xFEFFFFFFFEFFFFFFLL, (float32x2_t)0x7F7FFFFF7F7FFFFFLL);
    if ((v14 & 0x80000000) != 0)
    {
      MEMORY[0x24BDAC7A8](v32, v33);
      v34 = (int *)v44;
      memset(v44, 0, sizeof(v44));
      RB::Path::Dilator::Dilator((uint64_t)v44, (uint64_t)v47, v36);
    }
    else
    {
      v34 = v47;
      if ((a6 & 1) == 0)
      {
        info[0] = v47;
        info[1] = 0;
        CGPathApply(v52, info, (CGPathApplierFunction)RB::Path::Iterator::callback_1);
        (**(void (***)(int *))v47)(v47);
LABEL_16:
        v35.i32[0] = 0;
        v37 = *(_QWORD *)(v23 + 56);
        **(_DWORD **)(v23 + 48) = v37 - 1;
        *(_DWORD *)(v23 + 72) = v51;
        v38 = (uint32x2_t)vcgt_f32(v49, v48);
        v39 = (int8x8_t)vdup_lane_s32(vcgt_s32(v35, (int32x2_t)vpmin_u32(v38, v38)), 0);
        v40 = vand_s8((int8x8_t)vsub_f32(v49, v48), v39);
        *(int8x8_t *)(v23 + 32) = vand_s8((int8x8_t)v48, v39);
        *(int8x8_t *)(v23 + 40) = v40;
        *(_QWORD *)(a1 + 88) += 32 * v37;
        goto LABEL_17;
      }
    }
    RB::Path::normalized_map(v52, (void (***)(float64x2_t *))v34, 0);
    goto LABEL_16;
  }
LABEL_17:
  RB::UntypedTable::insert((size_t **)(a1 + 8), (size_t *)v23, (size_t *)v23);
  if (v52)
    CFRelease(v52);
LABEL_19:
  v41 = *(_DWORD *)(*(_QWORD *)a5 + 88);
  *(_DWORD *)(v23 + 80) = v41;
  if (v41 >= *(_DWORD *)(a1 + 96))
    v41 = *(_DWORD *)(a1 + 96);
  *(_DWORD *)(a1 + 96) = v41;
  v42 = this[1];
  *this = vmulq_n_f64(*this, *(float *)(v23 + 24));
  this[1] = vmulq_n_f64(v42, *(float *)(v23 + 24));
  return v23;
}

void sub_209B07AD4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  const void *v3;

  v3 = *(const void **)(v1 - 152);
  if (v3)
    CFRelease(v3);
  _Unwind_Resume(exception_object);
}

BOOL RB::GlyphPathCache::prune(RB::GlyphPathCache *this, int a2)
{
  RB::GlyphPathCache *v3;
  char *v4;
  unsigned int v5;
  unint64_t v6;
  BOOL v7;
  int v8;
  int v10;
  _QWORD v11[2];

  v3 = this;
  v10 = 0;
  v4 = (char *)this + 8;
  v5 = 384;
  while (1)
  {
    if (v5 != 384)
    {
      v6 = *((_QWORD *)v3 + 11);
      if (!(v6 >> 17))
        break;
    }
    v10 = a2 - v5;
    if (*((_DWORD *)v3 + 24) <= a2 - v5)
    {
      *((_DWORD *)v3 + 24) = -1;
      v11[0] = v3;
      v11[1] = &v10;
      this = (RB::GlyphPathCache *)RB::UntypedTable::remove_if ((uint64_t)v4, (BOOL (*)(const void *, const void *, void *))RB::Table<RB::GlyphPathCacheDetails::GlyphKey const*,RB::GlyphPathCache::Path *>::remove_if<RB::GlyphPathCache::prune::$_0>(RB::GlyphPathCache::prune::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke, v11);
    }
    v7 = v5 > 1;
    v5 >>= 1;
    if (!v7)
    {
      v6 = *((_QWORD *)v3 + 11);
      break;
    }
  }
  if (v6)
  {
    v8 = RB::verbose_mode(this);
    v6 = *((_QWORD *)v3 + 11);
    if (v8 >= 1)
    {
      printf("\n== glyph path cache ==\n  %d bytes; %d paths; %d/%d misses/hits (%g ratio)\n\n",
        v6,
        *((_QWORD *)v3 + 8),
        *((_QWORD *)v3 + 14),
        *((_QWORD *)v3 + 13),
        (double)*((unint64_t *)v3 + 14) / (double)*((unint64_t *)v3 + 13));
      v6 = *((_QWORD *)v3 + 11);
    }
  }
  return v6 != 0;
}

uint64_t RB::`anonymous namespace'::GlyphSegments::begin_subpath(uint64_t this)
{
  *(_QWORD *)(this + 16) = *(_QWORD *)(*(_QWORD *)(this + 8) + 8);
  *(_DWORD *)(this + 28) = *(_DWORD *)(this + 24);
  return this;
}

uint64_t RB::`anonymous namespace'::GlyphSegments::cull_subpath(RB::_anonymous_namespace_::GlyphSegments *this)
{
  uint64_t v2;
  unint64_t v3;

  v2 = *((_QWORD *)this + 1);
  v3 = *((_QWORD *)this + 2);
  if (*(_QWORD *)(v2 + 8) < v3 && *(_QWORD *)(v2 + 16) < v3)
    RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(*((_QWORD *)this + 1), v3);
  *(_QWORD *)(v2 + 8) = v3;
  *((_DWORD *)this + 6) = *((_DWORD *)this + 7);
  return 1;
}

BOOL RB::`anonymous namespace'::GlyphSegments::pop_back(RB::_anonymous_namespace_::GlyphSegments *this)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *((_QWORD *)this + 1);
  v2 = *(_QWORD *)(v1 + 8);
  if (v2)
    *(_QWORD *)(v1 + 8) = v2 - 1;
  return v2 != 0;
}

float RB::`anonymous namespace'::GlyphSegments::push_back(uint64_t a1, unsigned int a2, float32x2_t a3, double a4, double a5, double a6)
{
  _QWORD *v12;
  uint64_t v13;
  uint32x2_t v14;
  int v15;
  uint64_t v16;
  int32x2_t v17;
  int v18;
  float result;
  uint64_t v20;

  v12 = *(_QWORD **)(a1 + 8);
  v13 = v12[1];
  if (!v13
    || (v14 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)(*v12 + 32 * v13 - 8), a3)),
        (vpmax_u32(v14, v14).u32[0] & 0x80000000) != 0))
  {
    v15 = *(_DWORD *)(a1 + 24);
    if (v12[2] < (unint64_t)(v13 + 1))
    {
      RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(*(_QWORD *)(a1 + 8), v13 + 1);
      v13 = v12[1];
    }
    v16 = *v12 + 32 * v13;
    *(_DWORD *)v16 = v15;
    *(_DWORD *)(v16 + 4) = 0;
    v17 = vdup_n_s32(0x7F800000u);
    *(int32x2_t *)(v16 + 8) = v17;
    *(int32x2_t *)(v16 + 16) = v17;
    *(double *)(v16 + 24) = *(double *)&a3;
    ++v12[1];
    v12 = *(_QWORD **)(a1 + 8);
    v13 = v12[1];
  }
  v18 = *(_DWORD *)(a1 + 24);
  if (v12[2] < (unint64_t)(v13 + 1))
  {
    RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow((uint64_t)v12, v13 + 1);
    v13 = v12[1];
  }
  result = 1.0 / (float)a2;
  v20 = *v12 + 32 * v13;
  *(_DWORD *)v20 = v18;
  *(float *)(v20 + 4) = result;
  *(double *)(v20 + 8) = a4;
  *(double *)(v20 + 16) = a5;
  *(double *)(v20 + 24) = a6;
  ++v12[1];
  *(_DWORD *)(a1 + 24) += a2;
  return result;
}

void *RB::vector<RB::Shader::Path::CubicSegment,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,32ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,32ul>(void *a1, size_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(32 * a3);
    v6 = v5 >> 5;
    if (v5 >> 5 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

BOOL RB::Table<RB::GlyphPathCacheDetails::GlyphKey const*,RB::GlyphPathCache::Path *>::remove_if<RB::GlyphPathCache::prune(unsigned int)::$_0>(RB::GlyphPathCache::prune(unsigned int)::$_0)::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  unsigned int v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  v3 = *(_DWORD *)(a2 + 80);
  v4 = *a3;
  v5 = *(_DWORD *)a3[1];
  if (v3 > v5)
  {
    v6 = *(_DWORD *)(v4 + 96);
    if (v3 < v6)
      v6 = *(_DWORD *)(a2 + 80);
    *(_DWORD *)(v4 + 96) = v6;
  }
  else
  {
    *(_QWORD *)(v4 + 88) -= 32 * *(_QWORD *)(a2 + 56);
  }
  return v3 <= v5;
}

void RB::ObjcEncoderDelegate::encode_metadata(id *this@<X0>, CFTypeRef *a2@<X8>)
{
  void *v4;
  const void *v5;

  *a2 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v4 = (void *)MEMORY[0x20BD168EC]();
    v5 = (const void *)objc_msgSend(this[1], "encodedMetadata");
    if (v5)
      *a2 = CFRetain(v5);
    objc_autoreleasePoolPop(v4);
  }
}

void sub_209B07F44(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::ObjcEncoderDelegate::should_encode_subset_font(id *this, CGFont *a2)
{
  if ((objc_opt_respondsToSelector() & 1) != 0)
    return objc_msgSend(this[1], "shouldEncodeFontSubset:", a2);
  else
    return 0;
}

void RB::ObjcEncoderDelegate::encode_font(id *this@<X0>, CGFont *a2@<X1>, CFTypeRef *a3@<X8>)
{
  void *v6;
  const void *v7;
  uint64_t v8;

  *a3 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v6 = (void *)MEMORY[0x20BD168EC]();
    v8 = 0;
    v7 = (const void *)objc_msgSend(this[1], "encodedCGFontData:error:", a2, &v8);
    if (v7)
      *a3 = CFRetain(v7);
    objc_autoreleasePoolPop(v6);
  }
}

void sub_209B08030(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void RB::ObjcEncoderDelegate::encode_font_subset(uint64_t a1@<X0>, uint64_t a2@<X1>, const __CFData *a3@<X2>, uint64_t a4@<X4>, CFTypeRef *a5@<X8>)
{
  void *v10;
  const void *v11;
  void *v12;
  const void *v13;
  uint64_t v14;
  CFTypeRef cf;

  *a5 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v10 = (void *)MEMORY[0x20BD168EC]();
    RBEncoderCreateFontData(a3, a4, (CFDataRef *)&cf);
    if (cf)
    {
      v14 = 0;
      v11 = (const void *)objc_msgSend(*(id *)(a1 + 8), "encodedFontData:cgFont:error:", cf, a2, &v14);
      if (v11)
        *a5 = CFRetain(v11);
      if (cf)
        CFRelease(cf);
    }
    objc_autoreleasePoolPop(v10);
  }
  else if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v12 = (void *)MEMORY[0x20BD168EC]();
    cf = 0;
    v13 = (const void *)objc_msgSend(*(id *)(a1 + 8), "encodedFontSubsetData:cgFont:error:", a3, a2, &cf);
    if (v13)
      *a5 = CFRetain(v13);
    objc_autoreleasePoolPop(v12);
  }
}

void sub_209B08178(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void RBEncoderCreateFontData(CFDataRef theData@<X1>, uint64_t a2@<X3>, CFDataRef *a3@<X8>)
{
  const UInt8 *BytePtr;
  CFIndex Length;
  void *v8;
  void *v9;
  const char *v10;
  size_t v11;
  unint64_t v12;
  uint64_t Count;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned __int16 *v20;
  int v21;
  unsigned __int16 *v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  char v29;
  uint64_t v30;

  v30 = *MEMORY[0x24BDAC8D0];
  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v26 = 0u;
  BytePtr = CFDataGetBytePtr(theData);
  Length = CFDataGetLength(theData);
  if (Length)
  {
    RB::ProtobufEncoder::encode_varint(&v26, 0xAuLL);
    RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)&v26, BytePtr, Length);
  }
  v8 = (void *)CGFontCopyName();
  if (v8)
  {
    v9 = (void *)MEMORY[0x20BD168EC]();
    v10 = (const char *)objc_msgSend(v8, "UTF8String");
    v11 = strlen(v10);
    if (v11)
    {
      v12 = v11;
      RB::ProtobufEncoder::encode_varint(&v26, 0x12uLL);
      RB::ProtobufEncoder::encode_data((RB::ProtobufEncoder *)&v26, v10, v12);
    }
    objc_autoreleasePoolPop(v9);
  }
  if (a2)
  {
    Count = CGFontIndexSetGetCount();
    v15 = Count;
    if (Count)
    {
      if ((Count & 0x8000000000000000) == 0)
      {
        v16 = 2 * Count;
        if ((unint64_t)(2 * Count) > 0x1000)
        {
          v17 = (char *)malloc_type_malloc(2 * Count, 0xB7967A8DuLL);
          v22 = (unsigned __int16 *)malloc_type_malloc(2 * v15, 0x95EF6F9uLL);
          v20 = v22;
          v21 = 1;
          if (!v17 || !v22)
          {
LABEL_23:
            free(v20);
LABEL_24:
            if (v21)
              free(v17);
            goto LABEL_26;
          }
        }
        else
        {
          MEMORY[0x24BDAC7A8](Count, v14);
          v17 = (char *)&v26 - ((v16 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v17, 2 * v15);
          MEMORY[0x24BDAC7A8](v18, v19);
          v20 = (unsigned __int16 *)v17;
          bzero(v17, 2 * v15);
          v21 = 0;
        }
        CGFontIndexSetGetIndexes();
        CGFontIndexMapGetValues();
        v23 = 0;
        do
        {
          if (v20[v23] != *(unsigned __int16 *)&v17[2 * v23])
          {
            RB::ProtobufEncoder::encode_varint(&v26, 0x1AuLL);
            RB::ProtobufEncoder::begin_length_delimited(&v26);
            v24 = *(unsigned __int16 *)&v17[2 * v23];
            if (*(_WORD *)&v17[2 * v23])
            {
              RB::ProtobufEncoder::encode_varint(&v26, 8uLL);
              RB::ProtobufEncoder::encode_varint(&v26, v24);
            }
            v25 = v20[v23];
            if (v20[v23])
            {
              RB::ProtobufEncoder::encode_varint(&v26, 0x10uLL);
              RB::ProtobufEncoder::encode_varint(&v26, v25);
            }
            RB::ProtobufEncoder::end_length_delimited(&v26);
          }
          ++v23;
        }
        while (v15 != v23);
        if (v16 <= 0x1000)
          goto LABEL_24;
        goto LABEL_23;
      }
    }
  }
LABEL_26:
  RB::ProtobufEncoder::take_data((RB::ProtobufEncoder *)&v26, a3);
  if (v8)
    CFRelease(v8);
  if (*((_QWORD *)&v27 + 1))
    free(*((void **)&v27 + 1));
  if ((_QWORD)v26)
    free((void *)v26);
}

void sub_209B08470(_Unwind_Exception *a1)
{
  const void *v1;
  void *v2;
  uint64_t v3;

  free(v2);
  if (v1)
    CFRelease(v1);
  RB::ProtobufEncoder::~ProtobufEncoder((RB::ProtobufEncoder *)(v3 - 144));
  _Unwind_Resume(a1);
}

void RB::ObjcEncoderDelegate::encode_image(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  void *v8;
  const void *v9;
  uint64_t v10;

  *a4 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v8 = (void *)MEMORY[0x20BD168EC]();
    v10 = 0;
    v9 = (const void *)objc_msgSend(*(id *)(a1 + 8), "encodedImageData:error:", a2, a3, &v10);
    if (v9)
      *a4 = CFRetain(v9);
    objc_autoreleasePoolPop(v8);
  }
}

void sub_209B08578(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void RB::ObjcEncoderDelegate::encode_shader_library(id *this@<X0>, const void *a2@<X1>, CFTypeRef *a3@<X8>)
{
  void *v6;
  const void *v7;
  uint64_t v8;

  *a3 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v6 = (void *)MEMORY[0x20BD168EC]();
    v8 = 0;
    v7 = (const void *)objc_msgSend(this[1], "encodedShaderLibraryData:error:", a2, &v8);
    if (v7)
      *a3 = CFRetain(v7);
    objc_autoreleasePoolPop(v6);
  }
}

void sub_209B08618(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::ObjcEncoderDelegate::font_set(id *this)
{
  _QWORD *result;
  _QWORD *v3;

  if ((objc_opt_respondsToSelector() & 1) == 0)
    return 0;
  result = (_QWORD *)objc_msgSend(this[1], "encoderSet");
  if (result)
  {
    v3 = result;
    objc_msgSend(result, "commit");
    return (_QWORD *)v3[1];
  }
  return result;
}

void RB::ObjcDecoderDelegate::decode_metadata(id *this, const void *a2, uint64_t a3)
{
  void *v6;

  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v6 = (void *)MEMORY[0x20BD168EC]();
    objc_msgSend(this[1], "decodedMetadata:", objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", a2, a3));
    objc_autoreleasePoolPop(v6);
  }
}

void RB::ObjcDecoderDelegate::decode_cgfont(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  void *v8;
  const void *v9;
  uint64_t v10;

  *a4 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v8 = (void *)MEMORY[0x20BD168EC]();
    v10 = 0;
    v9 = (const void *)objc_msgSend(this[1], "decodedCGFontWithData:error:", objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", a2, a3), &v10);
    if (v9)
      *a4 = CFRetain(v9);
    objc_autoreleasePoolPop(v8);
  }
}

void sub_209B087A4(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void RB::ObjcDecoderDelegate::decode_image(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  void *v8;
  const void *v9;
  int v10;
  uint64_t v11;

  *(_DWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v8 = (void *)MEMORY[0x20BD168EC]();
    v11 = 0;
    v10 = 0;
    v9 = (const void *)objc_msgSend(this[1], "decodedImageContentsWithData:type:error:", objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", a2, a3), &v10, &v11);
    *(_DWORD *)a4 = v10;
    if (v9)
      *(_QWORD *)(a4 + 8) = CFRetain(v9);
    objc_autoreleasePoolPop(v8);
  }
}

void sub_209B08878(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void RB::ObjcDecoderDelegate::decode_shader_library(id *this@<X0>, const void *a2@<X1>, uint64_t a3@<X2>, CFTypeRef *a4@<X8>)
{
  void *v8;
  const void *v9;
  uint64_t v10;

  *a4 = 0;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v8 = (void *)MEMORY[0x20BD168EC]();
    v10 = 0;
    v9 = (const void *)objc_msgSend(this[1], "decodedShaderLibraryWithData:error:", objc_msgSend(MEMORY[0x24BDBCE50], "dataWithBytes:length:", a2, a3), &v10);
    if (v9)
      *a4 = CFRetain(v9);
    objc_autoreleasePoolPop(v8);
  }
}

void sub_209B08938(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B08B30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17)
{
  RB::Encoder::~Encoder((RB::Encoder *)&a9);
  _Unwind_Resume(a1);
}

void RB::Encoder::~Encoder(RB::Encoder *this)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;
  void *v6;

  RB::UntypedTable::~UntypedTable((RB::Encoder *)((char *)this + 80));
  v2 = (unsigned int *)*((_QWORD *)this + 8);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  v6 = (void *)*((_QWORD *)this + 3);
  if (v6)
    free(v6);
  if (*(_QWORD *)this)
    free(*(void **)this);
}

void sub_209B08EC0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B091A8(_Unwind_Exception *exception_object)
{
  const void *v1;

  if (v1)
    CFRelease(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B0926C(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_209B093B0(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void sub_209B0951C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void RB::ProtobufEncoder::~ProtobufEncoder(RB::ProtobufEncoder *this)
{
  void *v2;

  v2 = (void *)*((_QWORD *)this + 3);
  if (v2)
    free(v2);
  if (*(_QWORD *)this)
    free(*(void **)this);
}

CGFontRef RBDecoderCreateCGFontWithData(void *a1)
{
  __CFDictionary *Mutable;
  const UInt8 *v3;
  CFIndex v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t field;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t i;
  CFIndex v12;
  uint64_t v13;
  void *v14;
  CGDataProvider *v15;
  CGFontRef v16;
  CFStringRef v17;
  _QWORD *v18;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  void *v23;
  uint64_t v24;
  uint64_t v25;
  char v26;

  Mutable = 0;
  v3 = 0;
  v4 = 0;
  v5 = 0;
  v6 = 0;
  v20 = objc_msgSend(a1, "bytes");
  v21 = v20 + objc_msgSend(a1, "length");
  v22 = 0;
  v23 = 0;
  v24 = 0;
  v25 = 0;
  v26 = 0;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20);
    if (!field)
      break;
    v8 = field >> 3;
    if ((field >> 3) == 3)
    {
      if ((field & 7) == 2)
      {
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)&v20);
        v9 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20);
        v10 = -1;
        for (i = -1; v9; v9 = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)&v20))
        {
          if ((v9 >> 3) == 2)
          {
            i = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)&v20, v9);
          }
          else if ((v9 >> 3) == 1)
          {
            v10 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)&v20, v9);
          }
          else
          {
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)&v20, v9);
          }
        }
        RB::ProtobufDecoder::end_message((uint64_t)&v20);
        if ((v10 & 0x8000000000000000) == 0 && (i & 0x8000000000000000) == 0)
        {
          if (!Mutable)
            Mutable = CFDictionaryCreateMutable(0, 0, 0, 0);
          CFDictionarySetValue(Mutable, (const void *)i, (const void *)v10);
        }
      }
      else
      {
        v26 = 1;
        v20 = v21;
      }
    }
    else if ((_DWORD)v8 == 2)
    {
      v3 = (const UInt8 *)RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)&v20, field);
      v4 = v12;
    }
    else if ((_DWORD)v8 == 1)
    {
      v5 = RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)&v20, field);
      v6 = v13;
    }
    else
    {
      RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)&v20, field);
    }
  }
  if (v6)
  {
    v14 = (void *)MEMORY[0x20BD168EC](0);
    v15 = CGDataProviderCreateWithCFData((CFDataRef)objc_msgSend(a1, "subdataWithRange:", v5 - objc_msgSend(a1, "bytes", v20), v6));
    v16 = CGFontCreateWithDataProvider(v15);
    if (v15)
      CFRelease(v15);
    objc_autoreleasePoolPop(v14);
    if (v16)
    {
      if (v4)
      {
        v17 = CFStringCreateWithBytes(0, v3, v4, 0x8000100u, 1u);
      }
      else
      {
        if (!Mutable)
          goto LABEL_36;
        v17 = 0;
      }
      v18 = -[RBDecodedFontMetadata initWithFontUID:glyphMap:]([RBDecodedFontMetadata alloc], v17, Mutable);
      objc_setAssociatedObject(v16, "RBDecodedFontMetadata", v18, (void *)0x301);

      if (v17)
        CFRelease(v17);
    }
  }
  else
  {
    v16 = 0;
  }
  if (Mutable)
    CFRelease(Mutable);
LABEL_36:
  if (v23)
    free(v23);
  return v16;
}

void sub_209B09974(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  const void *v13;
  const void *v14;

  CFRelease(v14);
  if (v13)
    CFRelease(v13);
  if (a13)
    free(a13);
  _Unwind_Resume(a1);
}

RBArchiveDelegateImpl *RBArchiveDelegate(uint64_t a1)
{
  unsigned __int8 v2;

  if ((_DWORD)a1)
    return -[RBArchiveDelegateImpl initWithFlags:]([RBArchiveDelegateImpl alloc], "initWithFlags:", a1);
  if ((v2 & 1) == 0)
  {
    {
      RBArchiveDelegate::shared = -[RBArchiveDelegateImpl initWithFlags:]([RBArchiveDelegateImpl alloc], "initWithFlags:", 0);
    }
  }
  return (RBArchiveDelegateImpl *)RBArchiveDelegate::shared;
}

void sub_209B09A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void RBArchiveToFile(void *a1, _BYTE *a2, uint64_t a3)
{
  void *v6;
  RBArchiveDelegateImpl *v7;

  v6 = (void *)MEMORY[0x20BD168EC]();
  v7 = RBArchiveDelegate(a3);
  archive_to_file(a1, a2, (uint64_t)v7);
  objc_autoreleasePoolPop(v6);
}

void archive_to_file(void *a1, _BYTE *a2, uint64_t a3)
{
  NSString *v6;
  void *v7;
  RB *v8;
  NSObject *v9;
  objc_class *v10;
  int v11;
  NSString *v12;
  __int16 v13;
  void *v14;
  __int16 v15;
  NSString *v16;
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  v6 = (NSString *)objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", a2);
  if (*a2 != 47)
    v6 = -[NSString stringByAppendingPathComponent:](NSTemporaryDirectory(), "stringByAppendingPathComponent:", v6);
  v7 = (void *)objc_msgSend(a1, "encodedDataForDelegate:error:", a3, 0);
  if (v7)
  {
    v8 = (RB *)objc_msgSend(v7, "writeToFile:atomically:", v6, 0);
    if ((_DWORD)v8)
    {
      v9 = RB::misc_log(v8);
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        v10 = (objc_class *)objc_opt_class();
        v11 = 138412802;
        v12 = NSStringFromClass(v10);
        v13 = 2048;
        v14 = a1;
        v15 = 2112;
        v16 = v6;
        _os_log_impl(&dword_209ACA000, v9, OS_LOG_TYPE_DEFAULT, "serialized %@:%p to %@", (uint8_t *)&v11, 0x20u);
      }
    }
  }
}

void RBArchiveToFileWithMetadata(void *a1, uint64_t a2, _BYTE *a3, uint64_t a4)
{
  void *v8;
  RBArchiveDelegateImpl *v9;
  RBArchiveDelegateImpl *v10;

  v8 = (void *)MEMORY[0x20BD168EC]();
  v9 = -[RBArchiveDelegateImpl initWithFlags:]([RBArchiveDelegateImpl alloc], "initWithFlags:", a4);
  v10 = v9;
  if (a2)
    -[RBArchiveDelegateImpl decodedMetadata:](v9, "decodedMetadata:", a2);
  archive_to_file(a1, a3, (uint64_t)v10);

  objc_autoreleasePoolPop(v8);
}

void sub_209B09CA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RB::ObjcDecoderDelegate::display_list_contents(RB::ObjcDecoderDelegate *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t RB::Coverage::`anonymous namespace'::visit_rect(uint64_t (***a1)(_QWORD, uint64_t *), float64x2_t *a2, float64x2_t *a3, char a4, float a5, float a6)
{
  int32x4_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  uint64_t v16;
  uint64_t v18;
  int32x2_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  float v23;
  __int16 v24;
  char v25;

  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    v18 = 0x100000001000000;
    v19 = vdup_n_s32(0x7F7FFFFFu);
    v20 = 0;
    v21 = 0;
    v22 = 1065353216;
    v23 = 0.0;
    v24 = 257;
  }
  else
  {
    v13 = vcvt_f32_f64(*a2);
    v14 = vcvt_f32_f64(a2[1]);
    *(int32x2_t *)v12.i8 = vcltz_f32(v14);
    v15 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v12), (int8x8_t)vadd_f32(v14, v13), (int8x8_t)v13);
    v16 = *(_QWORD *)&v14 & 0x7FFFFFFF7FFFFFFFLL;
    if (a3)
      v15 = RB::operator*(a3, v15, (float32x2_t)v16);
    v18 = (uint64_t)v15;
    v19 = (int32x2_t)v16;
    v20 = 0;
    v21 = 0;
    LODWORD(v22) = 1065353216;
    *((float *)&v22 + 1) = a5;
    v23 = a6;
    LOBYTE(v24) = 2;
    HIBYTE(v24) = a4;
  }
  v25 = 0;
  return (**a1)(a1, &v18);
}

uint64_t RB::Coverage::`anonymous namespace'::visit_ellipse(uint64_t (***a1)(_QWORD, uint64_t *), float64x2_t *a2, float64x2_t *a3, char a4, float a5, float a6)
{
  int32x4_t v12;
  float32x2_t v13;
  float32x2_t v14;
  float32x2_t v15;
  uint64_t v16;
  unsigned int v17;
  float v18;
  int32x2_t v19;
  uint64_t v21;
  int32x2_t v22;
  int32x4_t v23;
  unint64_t v24;
  float v25;
  __int16 v26;
  char v27;

  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    v21 = 0x100000001000000;
    v22 = vdup_n_s32(0x7F7FFFFFu);
    v23 = 0uLL;
    v24 = 1065353216;
    v25 = 0.0;
    v26 = 257;
  }
  else
  {
    v13 = vcvt_f32_f64(*a2);
    v14 = vcvt_f32_f64(a2[1]);
    *(int32x2_t *)v12.i8 = vcltz_f32(v14);
    v15 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v12), (int8x8_t)vadd_f32(v14, v13), (int8x8_t)v13);
    v16 = *(_QWORD *)&v14 & 0x7FFFFFFF7FFFFFFFLL;
    if (a3)
      v15 = RB::operator*(a3, v15, (float32x2_t)v16);
    *(float *)&v17 = *(float *)&v16 / *((float *)&v16 + 1);
    v18 = 1.0 / (float)(*(float *)&v16 / *((float *)&v16 + 1));
    v15.f32[0] = v18 * v15.f32[0];
    v19.i32[1] = HIDWORD(v16);
    *(float *)v19.i32 = v18 * *(float *)&v16;
    *(float *)&v16 = vmuls_lane_f32(0.5, (float32x2_t)v16, 1);
    v21 = (uint64_t)v15;
    v22 = v19;
    v23 = vdupq_lane_s32((int32x2_t)v16, 0);
    v24 = __PAIR64__(LODWORD(a5), v17);
    v25 = a6;
    LOBYTE(v26) = 5;
    HIBYTE(v26) = a4;
  }
  v27 = 0;
  return (**a1)(a1, &v21);
}

uint64_t RB::Coverage::`anonymous namespace'::visit_rounded_rect(uint64_t (***a1)(_QWORD, uint64_t *), float64x2_t *a2, int a3, float64x2_t *a4, char a5, float64_t a6, float64_t a7, float a8, float a9)
{
  int32x4_t v16;
  int32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float64x2_t v21;
  float32x2_t v22;
  double v23;
  uint64_t v24;
  float32x2_t v25;
  char v26;
  float v27;
  double v28;
  int32x2_t v29;
  char v30;
  float32x2_t v34;
  uint64_t v35;
  int32x2_t v36;
  int32x4_t v37;
  unint64_t v38;
  float v39;
  __int16 v40;
  char v41;

  if (CGRectIsInfinite(*(CGRect *)a2->f64))
  {
    v35 = 0x100000001000000;
    v36 = vdup_n_s32(0x7F7FFFFFu);
    v37 = 0uLL;
    v38 = 1065353216;
    v39 = 0.0;
    v40 = 257;
  }
  else
  {
    v18 = vcvt_f32_f64(*a2);
    v19 = vcvt_f32_f64(a2[1]);
    *(int32x2_t *)v16.i8 = vcltz_f32(v19);
    v20 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v16), (int8x8_t)vadd_f32(v19, v18), (int8x8_t)v18);
    v21.f64[0] = a6;
    v21.f64[1] = a7;
    v22 = vabs_f32(v19);
    *(float *)v17.i32 = fminf(v22.f32[0], v22.f32[1]) * 0.5;
    v23 = COERCE_DOUBLE(vminnm_f32(vmaxnm_f32(vcvt_f32_f64(v21), 0), (float32x2_t)vdup_lane_s32(v17, 0)));
    if (a4)
    {
      v34 = *(float32x2_t *)&v23;
      v20 = RB::operator*(a4, v20, v22);
      v25 = vmaxnm_f32(v34, 0);
      v23 = COERCE_DOUBLE(vabs_f32(vcvt_f32_f64(vmlaq_n_f64(vmulq_n_f64(*a4, v25.f32[0]), a4[1], v25.f32[1]))));
    }
    else
    {
      v24 = *(_QWORD *)&v19 & 0x7FFFFFFF7FFFFFFFLL;
    }
    v26 = 2;
    v27 = 1.0;
    if (*(float *)&v23 > 0.0 && *((float *)&v23 + 1) > 0.0)
    {
      v28 = COERCE_DOUBLE(vmul_f32(*(float32x2_t *)&v23, (float32x2_t)vdup_n_s32(0x3FA33333u)));
      v29 = vceq_f32((float32x2_t)vzip1_s32(*(int32x2_t *)&v23, (int32x2_t)v24), (float32x2_t)vzip2_s32(*(int32x2_t *)&v23, (int32x2_t)v24));
      if ((((float)(0.5 * *(float *)&v24) == *(float *)&v23) & v29.i32[1] & v29.i32[0]) != 0)
        v30 = 5;
      else
        v30 = 3;
      if (a3)
        v26 = 2;
      else
        v26 = v30;
      if (a3 == 1)
      {
        v26 = 4;
        v23 = v28;
      }
      v27 = vdiv_f32(*(float32x2_t *)&v23, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&v23, 1)).f32[0];
      v20.f32[0] = (float)(1.0 / v27) * v20.f32[0];
      *(float *)&v24 = (float)(1.0 / v27) * *(float *)&v24;
    }
    v35 = (uint64_t)v20;
    v36 = (int32x2_t)v24;
    v37 = vdupq_lane_s32(*(int32x2_t *)&v23, 1);
    v38 = __PAIR64__(LODWORD(a8), LODWORD(v27));
    v39 = a9;
    LOBYTE(v40) = v26;
    HIBYTE(v40) = a5;
  }
  v41 = 0;
  return (**a1)(a1, &v35);
}

uint64_t RB::Coverage::`anonymous namespace'::visit_rounded_rect(void (***a1)(uint64_t (***)(_QWORD, uint64_t *), uint64_t *), float64x2_t *a2, int a3, uint64_t a4, char a5, float64_t a6, float64_t a7, float64_t a8, float64_t a9, float a10, float a11)
{
  __int128 v21;
  double v22;
  double v23;
  uint64_t result;
  BOOL v25;
  int32x4_t v26;
  float32x4_t v27;
  float32x2_t v28;
  float32x2_t v29;
  float32x2_t v30;
  uint64_t v31;
  double v32;
  double v33;
  double v34;
  float v35;
  char v36;
  float32x4_t v37;
  _QWORD v38[2];
  float32x4_t v39;
  int v40;
  float v41;
  float v42;
  char v43;
  char v44;
  char v45;
  float64x2_t v46;
  float64x2_t v47;

  v46.f64[0] = a6;
  v46.f64[1] = a7;
  v47.f64[0] = a8;
  v47.f64[1] = a9;
  if (a6 == a7 && a7 == a8 && a8 == a9 && a9 == a6)
  {
    return 1;
  }
  if (!a4
    || (v21 = *(_OWORD *)(a4 + 16), v22 = *(double *)(a4 + 24), v23 = *(double *)(a4 + 8), *(double *)a4 == v22)
    && v23 == 0.0
    && *(double *)&v21 == 0.0
    || (result = 0, v22 == 0.0) && (*(double *)a4 == 0.0 ? (v25 = v23 == *(double *)&v21) : (v25 = 0), v25))
  {
    RB::clamp_corner_radii((uint64_t)&v46, a2[1].f64);
    if (RB::corners_are_uneven_pill(v46.f64, a2[1].f64))
      return 0;
    v27 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v46), v47);
    v28 = vcvt_f32_f64(*a2);
    v29 = vcvt_f32_f64(a2[1]);
    *(int32x2_t *)v26.i8 = vcltz_f32(v29);
    v30 = (float32x2_t)vbsl_s8((int8x8_t)*(_OWORD *)&vcltzq_s32(v26), (int8x8_t)vadd_f32(v29, v28), (int8x8_t)v28);
    v31 = *(_QWORD *)&v29 & 0x7FFFFFFF7FFFFFFFLL;
    if (a4)
    {
      v37 = v27;
      v30 = RB::operator*((float64x2_t *)a4, v30, (float32x2_t)v31);
      v32 = *(double *)(a4 + 8);
      v33 = fabs(*(double *)a4);
      v34 = fabs(v32);
      if (v32 != 0.0)
        v33 = v34;
      v35 = v33;
      v27 = vmulq_n_f32(v37, v35);
    }
    if (a3 == 1)
    {
      v27 = vmulq_f32(v27, (float32x4_t)vdupq_n_s32(0x3FA33333u));
      v36 = 4;
    }
    else if (a3)
    {
      v36 = 2;
    }
    else
    {
      v36 = 3;
    }
    v38[0] = v30;
    v38[1] = v31;
    v39 = v27;
    v40 = 1065353216;
    v41 = a10;
    v42 = a11;
    v43 = v36;
    v44 = a5;
    v45 = 0;
    (**a1)((uint64_t (***)(_QWORD, uint64_t *))a1, v38);
    return 1;
  }
  return result;
}

uint64_t RB::Coverage::`anonymous namespace'::visit_stroked_path()
{
  uint64_t v0;
  uint64_t *v1;
  float64x2_t *v2;
  unsigned int v3;
  int v4;
  float64x2_t *v5;
  uint64_t *v6;
  uint64_t v7;
  float32x2_t v8;
  uint64_t v9;
  float v10;
  unint64_t v11;
  unint64_t v13;
  char *v14;
  float *v15;
  uint64_t v16;
  double *v17;
  uint64_t v18;
  uint64_t v19;
  float *v20;
  double *v21;
  double v22;
  float v23;
  float *v24;
  double v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char v30;
  int v31;
  char v32;
  float v33;
  float v34;
  BOOL v35;
  double v36;
  float v37;
  uint64_t v38;
  uint64_t v39;
  __int128 v40;
  float64x2_t *v41;
  float v42;
  float v43;
  unint64_t v44;
  char *v45;
  uint64_t (**v46)();
  __int128 v47;
  uint64_t v48;
  int32x2_t v49;
  char v50;
  char v51;
  char v52;
  char v53;
  BOOL v54;
  float v55;
  _BYTE v56[40];
  char v57[4096];
  uint64_t v58;

  v0 = MEMORY[0x24BDAC7A8]();
  v58 = *MEMORY[0x24BDAC8D0];
  if (v3 > 1)
    return 0;
  v4 = v3;
  v5 = v2;
  v6 = v1;
  v7 = v0;
  if (v2)
  {
    v8 = (float32x2_t)RB::AffineTransform::scale2(v2);
    v9 = 0;
    if (vabds_f32(v8.f32[0], v8.f32[1]) >= 0.0001)
      return v9;
    v10 = vaddv_f32(v8) * 0.5;
    if (v10 == 0.0)
      return v9;
  }
  else
  {
    v10 = 1.0;
  }
  v11 = v6[6] << (v6[6] & 1);
  if (v11 >> 62)
    return 0;
  v13 = 4 * v11;
  if (4 * v11 <= 0x1000)
  {
    MEMORY[0x24BDAC7A8]();
    v14 = (char *)&v40 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
    bzero(v14, 4 * v11);
    if (v11)
      goto LABEL_12;
LABEL_27:
    v29 = 0;
LABEL_28:
    v30 = rb_line_cap(*((_DWORD *)v6 + 6));
    v31 = rb_line_join((CGLineJoin)*((_DWORD *)v6 + 7));
    v32 = v31;
    if (!v31)
    {
      if (*((double *)v6 + 4) <= 0.0)
        v32 = 2;
      else
        v32 = 0;
    }
    RB::Heap::Heap((RB::Heap *)v56, v57, 4096, 0);
    v33 = *((double *)v6 + 2) * v10;
    v34 = *((double *)v6 + 5);
    v40 = RBPathNull;
    v41 = v5;
    v42 = v33;
    v43 = v34;
    v44 = v29;
    v45 = v14;
    v35 = rb_clip_mode(v4);
    v36 = *((double *)v6 + 4);
    v46 = off_24C229920;
    RB::Coverage::StrokeablePath::StrokeablePath(&v47, &v40, v56);
    v37 = v36;
    v48 = 0x100000001000000;
    v49 = vdup_n_s32(0x7F7FFFFFu);
    v50 = 0;
    v51 = v30;
    v52 = v32;
    v53 = 15;
    v54 = v35;
    v55 = v37;
    RBPathRelease(v40, *((uint64_t *)&v40 + 1));
    v39 = *v6;
    v38 = v6[1];
    RBPathRelease(v47, *((uint64_t *)&v47 + 1));
    *(_QWORD *)&v47 = v39;
    *((_QWORD *)&v47 + 1) = v38;
    (*(void (**)(uint64_t, uint64_t (***)()))(*(_QWORD *)v7 + 8))(v7, &v46);
    v47 = RBPathEmpty;
    v46 = off_24C229920;
    RBPathRelease(RBPathEmpty, *((uint64_t *)&RBPathEmpty + 1));
    RB::Heap::~Heap((RB::Heap *)v56);
    v9 = 1;
    goto LABEL_34;
  }
  v14 = (char *)malloc_type_malloc(4 * v11, 0xCDFB4EFFuLL);
  if (!v11)
    goto LABEL_27;
LABEL_12:
  if (v14)
  {
    v16 = v6[6];
    if (v16)
    {
      v17 = (double *)v6[7];
      v18 = 8 * v16;
      v19 = 8 * v16;
      v20 = (float *)v14;
      v21 = v17;
      do
      {
        v22 = *v21++;
        v23 = v22;
        *v20++ = v23;
        v19 -= 8;
      }
      while (v19);
      if (v11 != v16)
      {
        v24 = (float *)&v14[4 * v16];
        do
        {
          v25 = *v17++;
          v26 = v25;
          *v24++ = v26;
          v18 -= 8;
        }
        while (v18);
      }
    }
    v27 = 0;
    if (v11 <= 1)
      v28 = 1;
    else
      v28 = v11;
    do
    {
      *(float *)&v14[4 * v27] = *(float *)&v14[4 * v27] * v10;
      ++v27;
    }
    while (v28 != v27);
    if (RB::Stroke::Dasher::prepare_pattern(v11, v14, v15))
      v29 = v11;
    else
      v29 = 0;
    goto LABEL_28;
  }
  v9 = 0;
LABEL_34:
  if (v13 > 0x1000)
    free(v14);
  return v9;
}

void sub_209B0A5CC(_Unwind_Exception *exception_object)
{
  unint64_t v1;
  void *v2;

  if (v1 > 0x1000)
    free(v2);
  _Unwind_Resume(exception_object);
}

float64x2_t CG::Quadratic::Quadratic(CG::Quadratic *this, const Point *a2, const Point *a3, const Point *a4)
{
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t result;

  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  v4 = *((float64x2_t *)this + 1);
  v5 = vsubq_f64(v4, *(float64x2_t *)this);
  *((double *)this + 6) = v5.f64[0] + v5.f64[0];
  *((double *)this + 7) = v5.f64[1] + v5.f64[1];
  result = vsubq_f64(*((float64x2_t *)this + 2), vaddq_f64(v4, v5));
  *((float64x2_t *)this + 4) = result;
  return result;
}

double CG::Quadratic::start_point(CG::Quadratic *this)
{
  return *(double *)this;
}

double CG::Quadratic::end_point(CG::Quadratic *this)
{
  return *((double *)this + 4);
}

double CG::Quadratic::derivative(float64x2_t *this, double a2)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(this[3], this[4], a2 + a2);
  return result;
}

BOOL CG::Quadratic::is_flat(CG::Quadratic *this, double a2)
{
  double v2;
  double v3;
  double v4;
  double v5;

  v2 = *((double *)this + 2);
  if (*(double *)this != v2 || *((double *)this + 1) != *((double *)this + 3))
  {
    v3 = *((double *)this + 4);
    if (v2 != v3)
    {
      v4 = *((double *)this + 5);
      v5 = *((double *)this + 3);
      return (v3 - v2 + *(double *)this - v2) * (v3 - v2 + *(double *)this - v2)
           + (*((double *)this + 1) - v5 + v4 - v5) * (*((double *)this + 1) - v5 + v4 - v5) < a2 * a2 * 16.0;
    }
    v5 = *((double *)this + 3);
    v4 = *((double *)this + 5);
    if (v5 != v4)
      return (v3 - v2 + *(double *)this - v2) * (v3 - v2 + *(double *)this - v2)
           + (*((double *)this + 1) - v5 + v4 - v5) * (*((double *)this + 1) - v5 + v4 - v5) < a2 * a2 * 16.0;
  }
  return 1;
}

uint64_t CG::Quadratic::length(CG::Quadratic *this, int a2)
{
  uint64_t result;
  int v5;
  _BYTE v6[80];
  uint64_t v7;

  result = CG::Quadratic::is_flat(this, 0.5);
  if (a2 <= 32 && !(_DWORD)result)
  {
    CG::Quadratic::split(this, 0.5, (uint64_t)v6);
    v5 = a2 + 1;
    CG::Quadratic::length((CG::Quadratic *)v6, v5);
    return CG::Quadratic::length((CG::Quadratic *)&v7, v5);
  }
  return result;
}

double CG::Quadratic::split@<D0>(CG::Quadratic *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  double v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double result;

  v3 = *((double *)this + 2);
  v4 = *((double *)this + 3);
  v5 = *((double *)this + 1);
  v6 = (v3 - *(double *)this) * a2;
  v7 = (v4 - v5) * a2;
  v8 = v6 + *(double *)this;
  v9 = v7 + v5;
  v10 = *((double *)this + 4);
  v11 = *((double *)this + 5);
  v12 = v3 + (v10 - v3) * a2;
  v13 = v4 + (v11 - v4) * a2;
  v14 = (v12 - v8) * a2;
  v15 = (v13 - (v7 + v5)) * a2;
  v16 = v15 + v7 + v5;
  v17 = v7 + v7;
  v18 = v15 - v7;
  v19 = v12 - (v14 + v8);
  *(_QWORD *)a3 = *(_QWORD *)this;
  *(double *)(a3 + 8) = v5;
  *(double *)(a3 + 16) = v8;
  *(double *)(a3 + 24) = v9;
  *(double *)(a3 + 32) = v14 + v8;
  *(double *)(a3 + 40) = v16;
  *(double *)(a3 + 48) = v6 + v6;
  *(double *)(a3 + 56) = v17;
  *(double *)(a3 + 64) = v14 - v6;
  *(double *)(a3 + 72) = v18;
  *(double *)(a3 + 80) = v14 + v8;
  *(double *)(a3 + 88) = v16;
  result = v11 - (v13 + v13 - v16);
  *(double *)(a3 + 96) = v12;
  *(double *)(a3 + 104) = v13;
  *(double *)(a3 + 112) = v10;
  *(double *)(a3 + 120) = v11;
  *(double *)(a3 + 128) = v19 + v19;
  *(double *)(a3 + 136) = v13 - v16 + v13 - v16;
  *(double *)(a3 + 144) = v10 - (v12 + v19);
  *(double *)(a3 + 152) = result;
  return result;
}

CG::Quadratic *CG::Quadratic::index(CG::Quadratic *this, double a2)
{
  CG::Quadratic *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  _BYTE v8[160];

  if (a2 > 0.0)
  {
    v3 = this;
    this = (CG::Quadratic *)CG::Quadratic::length(this, 0);
    if (v4 > a2)
    {
      v5 = 1.0;
      v6 = 0.0;
      do
      {
        CG::Quadratic::split(v3, (v6 + v5) * 0.5, (uint64_t)v8);
        this = (CG::Quadratic *)CG::Quadratic::length((CG::Quadratic *)v8, 0);
        if (v7 <= a2)
          v6 = (v6 + v5) * 0.5;
        else
          v5 = (v6 + v5) * 0.5;
      }
      while (v5 - v6 > 0.0001);
    }
  }
  return this;
}

uint64_t RB::BinPacker::add(uint64_t this, unsigned int a2, unsigned int a3, void *a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  int v13;
  BOOL v14;
  int v15;

  v5 = (int)a2 * (uint64_t)(int)a3;
  if (v5 == (int)v5)
  {
    v10 = this;
    if (*(_BYTE *)(this + 1104))
    {
      LOBYTE(v11) = 1;
    }
    else
    {
      v11 = *(_QWORD *)(this + 1088);
      if (v11)
        LOBYTE(v11) = *(_QWORD *)(v11 + 8) != a5;
    }
    *(_BYTE *)(this + 1104) = v11;
    v12 = *(_QWORD *)(this + 24);
    this = (*(_QWORD *)(this + 16) + 7) & 0xFFFFFFFFFFFFFFF8;
    if (this + 32 > v12)
      this = RB::Heap::alloc_slow((size_t *)v10, 0x20uLL, 7);
    else
      *(_QWORD *)(v10 + 16) = this + 32;
    *(_DWORD *)this = a2;
    *(_DWORD *)(this + 4) = a3;
    *(_QWORD *)(this + 8) = a5;
    *(_QWORD *)(this + 16) = a4;
    *(_QWORD *)(this + 24) = *(_QWORD *)(v10 + 1088);
    *(_QWORD *)(v10 + 1088) = this;
    *(int32x2_t *)(v10 + 1072) = vmax_s32(*(int32x2_t *)(v10 + 1072), (int32x2_t)__PAIR64__(a3, a2));
    v13 = *(_DWORD *)(v10 + 1080);
    v14 = __OFADD__(v13, (_DWORD)v5);
    v15 = v13 + v5;
    if (v14)
      v15 = 0x7FFFFFFF;
    *(_DWORD *)(v10 + 1080) = v15;
  }
  return this;
}

uint64_t RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(RB::Heap *this, _DWORD *a2, int *a3, uint64_t *a4)
{
  unint64_t v8;
  uint64_t result;
  int v10;
  uint64_t v11;

  v8 = *((_QWORD *)this + 3);
  result = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (result + 32 > v8)
    result = RB::Heap::alloc_slow((size_t *)this, 0x20uLL, 7);
  else
    *((_QWORD *)this + 2) = result + 32;
  v10 = *a3;
  v11 = *a4;
  *(_DWORD *)result = *a2;
  *(_DWORD *)(result + 4) = v10;
  *(_QWORD *)(result + 8) = v11;
  *(_QWORD *)(result + 16) = 0;
  return result;
}

__n128 RB::BinPacker::append_packed(RB::Heap *this, uint64_t a2, int a3, int a4)
{
  unint64_t v8;
  unint64_t v9;
  __n128 result;
  __int128 v11;
  uint64_t v12;

  v8 = *((_QWORD *)this + 3);
  v9 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 48 > v8)
    v9 = RB::Heap::alloc_slow((size_t *)this, 0x30uLL, 7);
  else
    *((_QWORD *)this + 2) = v9 + 48;
  result = *(__n128 *)a2;
  v11 = *(_OWORD *)(a2 + 16);
  *(_OWORD *)v9 = *(_OWORD *)a2;
  *(_OWORD *)(v9 + 16) = v11;
  *(_DWORD *)(v9 + 32) = a3;
  *(_DWORD *)(v9 + 36) = a4;
  v12 = *((_QWORD *)this + 137);
  *(_QWORD *)(v9 + 40) = *(_QWORD *)(v12 + 16);
  *(_QWORD *)(v12 + 16) = v9;
  return result;
}

void RB::BinPacker::pack(RB::Heap *this, uint64_t a2)
{
  uint64_t v2;
  int v4;
  int v5;
  uint64_t *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  int v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;

  v30 = a2;
  if (a2)
  {
    v2 = a2;
    v4 = *((int *)this + 266) >> 1;
    v5 = *((_DWORD *)this + 267);
    v6 = &v30;
    do
    {
      while (*(_DWORD *)v2 <= v4)
      {
        v6 = (uint64_t *)(v2 + 24);
        v2 = *(_QWORD *)(v2 + 24);
        if (!v2)
          goto LABEL_9;
      }
      if (*(_DWORD *)(v2 + 4) + v5 > *((_DWORD *)this + 267))
      {
        v7 = *((_DWORD *)this + 266);
        v8 = *(_QWORD *)(v2 + 8);
        v32 = *((_DWORD *)this + 267);
        v33 = v7;
        v31 = v8;
        v9 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
        v5 = 0;
        *(_QWORD *)(v9 + 24) = *((_QWORD *)this + 137);
        *((_QWORD *)this + 137) = v9;
      }
      RB::BinPacker::append_packed(this, v2, 0, v5);
      v5 += *(_DWORD *)(v2 + 4);
      v2 = *(_QWORD *)(v2 + 24);
      *v6 = v2;
    }
    while (v2);
LABEL_9:
    if (v30)
    {
      v10 = 0;
      v11 = v30;
      do
      {
        ++v10;
        v11 = *(_QWORD *)(v11 + 24);
      }
      while (v11);
      v13 = v12;
      v30 = v12;
      v14 = *(_DWORD *)(v12 + 4);
      if (v14 + v5 > *((_DWORD *)this + 267))
      {
        v15 = *((_DWORD *)this + 266);
        v16 = *(_QWORD *)(v12 + 8);
        v32 = *((_DWORD *)this + 267);
        v33 = v15;
        v31 = v16;
        v17 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
        v5 = 0;
        *(_QWORD *)(v17 + 24) = *((_QWORD *)this + 137);
        *((_QWORD *)this + 137) = v17;
        v14 = *(_DWORD *)(v13 + 4);
      }
      v18 = 0;
      v19 = 0;
      v20 = v14 + v5;
      while (1)
      {
        v21 = *(_DWORD *)v13 + v18;
        if (v21 > *((_DWORD *)this + 266))
          break;
        if (!(_DWORD)v19 && v21 > v4)
          v19 = (*(_DWORD *)(v13 + 4) + v5);
        RB::BinPacker::append_packed(this, v13, v18, v5);
        v18 += *(_DWORD *)v13;
        v13 = *(_QWORD *)(v13 + 24);
        if (!v13)
          return;
      }
      while (1)
      {
        v22 = (int)v19 >= v20 ? v20 : v19;
        v23 = *(_DWORD *)(v13 + 4);
        if (v23 + v22 > *((_DWORD *)this + 267))
          break;
        if (v20 <= (int)v19)
          goto LABEL_28;
        v27 = (v23 + v19);
        v28 = v4;
LABEL_29:
        v29 = 0;
        while (*(_DWORD *)v13 + v29 <= v4)
        {
          RB::BinPacker::append_packed(this, v13, v29 + v28, v19);
          v29 += *(_DWORD *)v13;
          v13 = *(_QWORD *)(v13 + 24);
          if (!v13)
            return;
        }
        v19 = v27;
      }
      v24 = *((_DWORD *)this + 266);
      v25 = *(_QWORD *)(v13 + 8);
      v32 = *((_DWORD *)this + 267);
      v33 = v24;
      v31 = v25;
      v26 = RB::Heap::emplace<RB::BinPacker::bin,int &,int &,unsigned long &>(this, &v33, &v32, &v31);
      v19 = 0;
      v20 = 0;
      *(_QWORD *)(v26 + 24) = *((_QWORD *)this + 137);
      *((_QWORD *)this + 137) = v26;
      v23 = *(_DWORD *)(v13 + 4);
LABEL_28:
      v28 = 0;
      v27 = v19;
      LODWORD(v19) = v20;
      v20 += v23;
      goto LABEL_29;
    }
  }
}

BOOL RB::BinPacker::pack(RB::BinPacker::item *)::$_0::__invoke(uint64_t a1, uint64_t a2)
{
  return *(_DWORD *)(a1 + 4) > *(_DWORD *)(a2 + 4);
}

void RB::Table<unsigned long,RB::BinPacker::item *>::for_each<RB::BinPacker::pack(void)::$_0>(RB::BinPacker::pack(void)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t a1, uint64_t a2, RB::Heap **a3)
{
  RB::BinPacker::pack(*a3, a2);
}

uint64_t RB::`anonymous namespace'::list_sort_1<RB::BinPacker::item,&RB::BinPacker::item::_next>(uint64_t a1, unint64_t a2, unsigned int (*a3)(uint64_t, uint64_t))
{
  uint64_t v3;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BOOL4 v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  BOOL v17;

  v3 = a1;
  if (a2 >= 2)
  {
    v6 = a2 >> 1;
    v7 = a1;
    v8 = (a2 >> 1) - 1;
    if (a2 >> 1 != 1)
    {
      v7 = a1;
      do
      {
        v7 = *(_QWORD *)(v7 + 24);
        --v8;
      }
      while (v8);
    }
    v9 = *(_QWORD *)(v7 + 24);
    *(_QWORD *)(v7 + 24) = 0;
    if (a3(v3, v10))
    {
      v11 = *(_QWORD *)(v3 + 24);
      v12 = v10;
    }
    else
    {
      v12 = *(_QWORD *)(v10 + 24);
      v11 = v3;
      v3 = v10;
    }
    v13 = v12 != 0;
    if (v12 && v11)
    {
      v14 = v3;
      do
      {
        if (a3(v11, v12))
        {
          *(_QWORD *)(v14 + 24) = v11;
          v15 = *(_QWORD *)(v11 + 24);
          v16 = v12;
          v14 = v11;
          v11 = v15;
        }
        else
        {
          *(_QWORD *)(v14 + 24) = v12;
          v16 = *(_QWORD *)(v12 + 24);
          v15 = v11;
          v14 = v12;
          v12 = v16;
        }
        v13 = v16 != 0;
        if (v16)
          v17 = v15 == 0;
        else
          v17 = 1;
      }
      while (!v17);
    }
    else
    {
      v16 = v12;
      v15 = v11;
      v14 = v3;
    }
    if (!v13)
      v16 = v15;
    *(_QWORD *)(v14 + 24) = v16;
  }
  return v3;
}

uint64_t RB::Coverage::StrokeablePath::can_mix(uint64_t a1, uint64_t a2, const RB::AffineTransform *a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  unsigned int CanMix;
  uint64_t v9;
  float *v10;
  float *v11;
  uint64_t v12;

  if (*(_QWORD *)(a1 + 32) != *(_QWORD *)(a2 + 32))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 16), *(float64x2_t **)(a2 + 16), a3);
  v6 = can_mix;
  if (*(float *)(a1 + 24) == *(float *)(a2 + 24) && *(float *)(a1 + 28) == *(float *)(a2 + 28))
  {
    v9 = *(_QWORD *)(a1 + 32);
    if (!v9)
      goto LABEL_7;
    v10 = *(float **)(a1 + 40);
    v11 = *(float **)(a2 + 40);
    v12 = 4 * v9;
    while (*v10 == *v11)
    {
      ++v10;
      ++v11;
      v12 -= 4;
      if (!v12)
        goto LABEL_7;
    }
  }
  if ((can_mix & 0xFE) != 0)
    v6 = 2;
  else
    v6 = can_mix;
LABEL_7:
  if (!v6)
    return 0;
  CanMix = RBPathCanMix(*(RBPath *)a1, *(RBPath *)a2);
  if (CanMix >= v6)
    return v6;
  else
    return CanMix;
}

float32_t RB::Coverage::StrokeablePath::mix(uint64_t a1, RB *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, CGFloat a7)
{
  float64x2_t *v12;
  const RB::AffineTransform ***v13;
  float64x2_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  float64x2_t *v18;
  float64x2_t v19;
  __int128 v20;
  __int128 v21;
  const RB::AffineTransform **v22;
  __int128 v23;
  float64x2_t v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  uint64_t v29;
  float32x2_t v30;
  uint64_t v31;
  float *v32;
  float *v33;
  float v34;
  __int128 v37;
  float64x2_t v38;
  __int128 v39;
  __int128 v40;
  float64x2_t v41;
  __int128 v42;
  __int128 v43;
  float64x2_t v44;
  __int128 v45;
  __int128 v46;

  v13 = (const RB::AffineTransform ***)(a1 + 16);
  v12 = *(float64x2_t **)(a1 + 16);
  if (v12)
  {
    v14.f64[0] = RB::operator*((float64x2_t *)a4, v12);
    v44 = v14;
    v45 = v15;
    v46 = v16;
  }
  else
  {
    v17 = *(_OWORD *)(a4 + 16);
    v44 = *(float64x2_t *)a4;
    v45 = v17;
    v46 = *(_OWORD *)(a4 + 32);
  }
  v18 = *(float64x2_t **)(a3 + 16);
  if (v18)
  {
    v19.f64[0] = RB::operator*((float64x2_t *)a5, v18);
    v41 = v19;
    v42 = v20;
    v43 = v21;
    v22 = *(const RB::AffineTransform ***)(a3 + 16);
  }
  else
  {
    v22 = 0;
    v23 = *(_OWORD *)(a5 + 16);
    v41 = *(float64x2_t *)a5;
    v42 = v23;
    v43 = *(_OWORD *)(a5 + 32);
  }
  RB::mix(a2, v13, v22, (const RB::AffineTransform *)a4, a7);
  if (*v13)
  {
    v24.f64[0] = RB::operator*((float64x2_t *)a6, (float64x2_t *)*v13);
    v38 = v24;
    v39 = v25;
    v40 = v26;
  }
  else
  {
    v27 = *(_OWORD *)(a6 + 16);
    v38 = *(float64x2_t *)a6;
    v39 = v27;
    v40 = *(_OWORD *)(a6 + 32);
  }
  RBPathMix(*(RBPath *)a1, *(RBPath *)a3, *(float *)&a7, &v44, &v41, &v38, (uint64_t *)&v37);
  v28 = *(_QWORD *)a1;
  v29 = *(_QWORD *)(a1 + 8);
  *(_OWORD *)a1 = v37;
  *(_QWORD *)&v37 = v28;
  *((_QWORD *)&v37 + 1) = v29;
  RBPathRelease(v28, v29);
  v30 = vmla_n_f32(*(float32x2_t *)(a1 + 24), vsub_f32(*(float32x2_t *)(a3 + 24), *(float32x2_t *)(a1 + 24)), *(float *)&a7);
  *(float32x2_t *)(a1 + 24) = v30;
  v31 = *(_QWORD *)(a1 + 32);
  if (v31)
  {
    v32 = *(float **)(a1 + 40);
    v33 = *(float **)(a3 + 40);
    do
    {
      v34 = *v33++;
      v30.f32[0] = *v32 + (float)((float)(v34 - *v32) * *(float *)&a7);
      *v32++ = v30.f32[0];
      --v31;
    }
    while (v31);
  }
  return v30.f32[0];
}

void RB::Coverage::StrokeablePath::add_path(size_t size@<X1>, uint64_t a2@<X0>, CGContextRef *a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v8;
  char *v9;
  float *v10;
  float *v11;
  BOOL v12;
  size_t v13;
  double *v14;
  float v15;
  unsigned int v16;
  CGContext *v17;
  CGLineJoin v18;
  CGContext *v19;
  CGLineCap v20;
  CGPathRef v21;
  CGPathRef v22;
  _OWORD *v23;
  __int128 v24;
  uint64_t v25;
  int v26;
  const CGPath *v27;
  uint64_t v28;
  float v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  uint64_t v33;
  const CGPath *v34;
  uint64_t v35;
  __int128 *v36;
  __int128 v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41[3];
  _OWORD v42[3];
  uint64_t v43;

  v43 = *MEMORY[0x24BDAC8D0];
  if (*(_QWORD *)(a2 + 8) == 0x209BD98A8)
  {
    CGContextBeginPath(*a3);
    *(_QWORD *)a4 = 0;
    *(_DWORD *)(a4 + 8) = 2;
    return;
  }
  v8 = *(_QWORD *)(a2 + 32);
  if (v8 >> 61)
  {
    v9 = 0;
    v10 = *(float **)(a2 + 40);
    v11 = &v10[v8];
    v12 = 1;
  }
  else
  {
    v12 = 8 * v8 <= 0x1000;
    if (8 * v8 > 0x1000)
    {
      v9 = (char *)malloc_type_malloc(8 * v8, 0xD1F95696uLL);
      v8 = *(_QWORD *)(a2 + 32);
      if (!v8)
        goto LABEL_12;
    }
    else
    {
      MEMORY[0x24BDAC7A8](a2, 8 * v8);
      v9 = (char *)v41 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
      bzero(v9, v13);
      if (!v8)
        goto LABEL_12;
    }
    v10 = *(float **)(a2 + 40);
    v11 = &v10[v8];
  }
  v14 = (double *)v9;
  do
  {
    v15 = *v10++;
    *v14++ = v15;
  }
  while (v10 != v11);
LABEL_12:
  v16 = *(unsigned __int8 *)(size + 73);
  if (v16 < 3)
  {
    CGContextSetLineWidth(*a3, *(float *)(a2 + 24));
    v17 = *a3;
    v18 = RBStrokeRef::clip(*(unsigned __int8 *)(size + 74));
    CGContextSetLineJoin(v17, v18);
    v19 = *a3;
    v20 = cg_line_cap(*(unsigned __int8 *)(size + 73));
    CGContextSetLineCap(v19, v20);
    CGContextSetLineDash(*a3, *(float *)(a2 + 28), (const CGFloat *)v9, *(_QWORD *)(a2 + 32));
    CGContextSetMiterLimit(*a3, *(float *)(size + 80));
    v21 = RBPathCopyCGPath(*(const CGPath **)a2, *(_QWORD *)(a2 + 8));
    v22 = v21;
    v23 = *(_OWORD **)(a2 + 16);
    if (v23)
    {
      v24 = v23[1];
      v42[0] = *v23;
      v42[1] = v24;
      v42[2] = v23[2];
      v25 = MEMORY[0x20BD16010](v21, v42);
      if (v22)
        CFRelease(v22);
      v26 = 2;
      v22 = (CGPathRef)v25;
      if (!v25)
        goto LABEL_17;
    }
    else
    {
      v26 = 2;
      if (!v21)
        goto LABEL_17;
    }
LABEL_22:
    *(_QWORD *)a4 = CFRetain(v22);
    *(_DWORD *)(a4 + 8) = v26;
    CFRelease(v22);
    if (v12)
      return;
    goto LABEL_23;
  }
  v27 = *(const CGPath **)a2;
  v28 = *(_QWORD *)(a2 + 8);
  v29 = *(float *)(a2 + 24);
  v30 = rb_line_cap(v16);
  v31 = RBStrokeRef::clip(*(unsigned __int8 *)(size + 74));
  v32 = RBPathCopyStrokedPath((uint64_t)v27, v28, v30, v31, (uint64_t *)v9, *(_QWORD *)(a2 + 32), v29, *(float *)(size + 80), *(float *)(a2 + 28));
  v34 = (const CGPath *)v32;
  v35 = v33;
  v36 = *(__int128 **)(a2 + 16);
  if (v36)
  {
    v37 = v36[1];
    v41[0] = *v36;
    v41[1] = v37;
    v41[2] = v36[2];
    v38 = RBPathCopyTransformedPath(v32, v33, v41);
    v40 = v39;
    RBPathRelease(0, 0x209BD98A8);
    RBPathRelease((uint64_t)v34, v35);
    v34 = (const CGPath *)v38;
    v35 = v40;
  }
  v22 = RBPathCopyCGPath(v34, v35);
  RBPathRelease((uint64_t)v34, v35);
  v26 = 0;
  if (v22)
    goto LABEL_22;
LABEL_17:
  *(_QWORD *)a4 = 0;
  *(_DWORD *)(a4 + 8) = v26;
  if (v12)
    return;
LABEL_23:
  free(v9);
}

void sub_209B0B454(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;
  uint64_t v3;
  char v4;

  RBPathRelease(v3, v2);
  if ((v4 & 1) == 0)
    free(v1);
  _Unwind_Resume(a1);
}

void RB::Coverage::StrokeablePath::clip(uint64_t a1, size_t size, uint64_t a3)
{
  int v6;
  const CGPath *v7;
  const CGPath *v8;
  int v9;

  v6 = *(unsigned __int8 *)(size + 76);
  if (*(unsigned __int8 *)(a3 + 140) != v6)
    RB::CGContext::set_aliasing_mode_slow(a3, v6);
  RB::Coverage::StrokeablePath::add_path(size, a1, (CGContextRef *)a3, (uint64_t)&v8);
  v7 = v8;
  if (v8)
  {
    CGContextBeginPath(*(CGContextRef *)a3);
    CGContextAddPath(*(CGContextRef *)a3, v7);
  }
  if (v9 == 2)
    CGContextReplacePathWithStrokedPath(*(CGContextRef *)a3);
  CGContextClip(*(CGContextRef *)a3);
  if (v7)
    CFRelease(v7);
}

void sub_209B0B554(_Unwind_Exception *a1)
{
  const void *v1;

  CFRelease(v1);
  _Unwind_Resume(a1);
}

void RB::Coverage::StrokeablePath::fill(uint64_t a1, size_t size, uint64_t a3, __int16 *a4)
{
  int v8;
  CGPathDrawingMode v10;
  const void *v39;
  const void *v40;
  CGPathDrawingMode mode;

  v8 = *(unsigned __int8 *)(size + 76);
  if (*(unsigned __int8 *)(a3 + 140) != v8)
    RB::CGContext::set_aliasing_mode_slow(a3, v8);
  RB::Coverage::StrokeablePath::add_path(size, a1, (CGContextRef *)a3, (uint64_t)&v40);
  v10 = mode;
  if (mode == kCGPathStroke)
  {
    if (*(_BYTE *)(a3 + 131) && *((_BYTE *)a4 + 9) && *(unsigned __int8 *)(a3 + 130) != *((unsigned __int8 *)a4 + 8))
      goto LABEL_11;
    _H0 = *(_WORD *)(a3 + 122);
    _H1 = *a4;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_11;
    _H0 = *(_WORD *)(a3 + 124);
    _H1 = a4[1];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_11;
    _H0 = *(_WORD *)(a3 + 126);
    _H1 = a4[2];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_11;
    _H0 = *(_WORD *)(a3 + 128);
    _H1 = a4[3];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
LABEL_11:
      RB::CGContext::set_stroke_color_slow((RB::CGContext *)a3, (const RB::Fill::Color *)a4, _D0);
  }
  else
  {
    if (*(_BYTE *)(a3 + 121) && *((_BYTE *)a4 + 9) && *(unsigned __int8 *)(a3 + 120) != *((unsigned __int8 *)a4 + 8))
      goto LABEL_19;
    _H0 = *(_WORD *)(a3 + 112);
    _H1 = *a4;
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_19;
    _H0 = *(_WORD *)(a3 + 114);
    _H1 = a4[1];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_19;
    _H0 = *(_WORD *)(a3 + 116);
    _H1 = a4[2];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
      goto LABEL_19;
    _H0 = *(_WORD *)(a3 + 118);
    _H1 = a4[3];
    __asm
    {
      FCVT            S1, H1
      FCVT            S0, H0
    }
    if (*(float *)_D0.i32 != _S1)
LABEL_19:
      RB::CGContext::set_fill_color_slow((RB::CGContext *)a3, (const RB::Fill::Color *)a4, _D0);
  }
  v39 = v40;
  if (v40)
  {
    CGContextDrawPathDirect();
    CFRelease(v39);
  }
  else
  {
    CGContextDrawPath(*(CGContextRef *)a3, v10);
  }
}

void sub_209B0B738(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::Coverage::StrokeablePath::encode(uint64_t a1, uint64_t a2, RB::ProtobufEncoder *this)
{
  float64x2_t *v6;
  int64x2_t v7;
  int v8;
  int v9;
  int v10;
  int v11;
  int v12;
  int v13;
  _QWORD *result;
  int v15;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RBPathEncode(*(RBPath *)a1, this);
  RB::ProtobufEncoder::end_length_delimited(this);
  v6 = *(float64x2_t **)(a1 + 16);
  if (v6)
  {
    v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v6[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v6->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v8 = *(int *)(a1 + 24);
  if (*(float *)&v8 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v8);
  }
  v9 = rb_line_cap(*(unsigned __int8 *)(a2 + 73));
  if (v9)
  {
    v10 = v9;
    RB::ProtobufEncoder::encode_varint(this, 0x20uLL);
    RB::ProtobufEncoder::encode_varint(this, v10);
  }
  v11 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 74));
  if (v11)
  {
    v12 = v11;
    RB::ProtobufEncoder::encode_varint(this, 0x28uLL);
    RB::ProtobufEncoder::encode_varint(this, v12);
  }
  if (*(_BYTE *)(a2 + 76) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x30uLL);
    RB::ProtobufEncoder::encode_varint(this, 1uLL);
  }
  v13 = *(int *)(a2 + 80);
  if (*(float *)&v13 != 10.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x3DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v13);
  }
  result = RB::ProtobufEncoder::packed_fixed32_field(this, 8, *(const unsigned int **)(a1 + 40), *(_QWORD *)(a1 + 32));
  v15 = *(int *)(a1 + 28);
  if (*(float *)&v15 != 0.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x4DuLL);
    return RB::ProtobufEncoder::encode_fixed32(this, v15);
  }
  return result;
}

void RB::Coverage::StrokeablePath::decode(uint64_t a1, uint64_t a2, size_t **this)
{
  unint64_t field;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  CGLineJoin v10;
  unsigned int v11;
  float v12;
  RB::Stroke::Dasher *v13;
  RB::Stroke::Dasher *v14;
  _BYTE *v15;
  uint64_t v16;
  float *v17;
  RB::Stroke::Dasher *v18;
  size_t *v19;
  char *v20;
  char *v21;
  _BYTE *v22;
  __int128 v23;
  _BYTE __dst[64];
  void *v25;
  RB::Stroke::Dasher *v26;
  unint64_t v27;
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v25 = 0;
  v26 = 0;
  v27 = 16;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)this);
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        if ((field & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)this);
          RBPathDecode((RB::Decoder *)this, (uint64_t *)&v23);
          v8 = *(_QWORD *)a1;
          v9 = *(_QWORD *)(a1 + 8);
          *(_OWORD *)a1 = v23;
          *(_QWORD *)&v23 = v8;
          *((_QWORD *)&v23 + 1) = v9;
          RBPathRelease(v8, v9);
          RB::ProtobufDecoder::end_message((uint64_t)this);
        }
        else
        {
          *((_BYTE *)this + 56) = 1;
          *this = this[1];
        }
        break;
      case 2u:
        RB::Decoder::affine_transform_field(this, field);
        *(_QWORD *)(a1 + 16) = v16;
        break;
      case 3u:
        *(float *)(a1 + 24) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      case 4u:
        v11 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
        *(_BYTE *)(a2 + 73) = rb_line_cap(v11);
        break;
      case 5u:
        v10 = RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)this, field);
        *(_BYTE *)(a2 + 74) = rb_line_join(v10);
        break;
      case 6u:
        *(_BYTE *)(a2 + 76) = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)this, field);
        break;
      case 7u:
        *(float *)(a2 + 80) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      case 8u:
        v12 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        v13 = v26;
        v14 = (RB::Stroke::Dasher *)((char *)v26 + 1);
        if (v27 < (unint64_t)v26 + 1)
        {
          RB::vector<float,16ul,unsigned long>::reserve_slow(__dst, (size_t)v14);
          v13 = v26;
          v14 = (RB::Stroke::Dasher *)((char *)v26 + 1);
        }
        v15 = v25;
        if (!v25)
          v15 = __dst;
        *(float *)&v15[4 * (_QWORD)v13] = v12;
        v26 = v14;
        break;
      case 9u:
        *(float *)(a1 + 28) = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)this, field);
        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)this, field);
        break;
    }
  }
  if (v26)
  {
    if (v25)
      v17 = (float *)v25;
    else
      v17 = (float *)__dst;
    if (RB::Stroke::Dasher::validate_pattern(v26, v17, v7))
    {
      v18 = v26;
      *(_QWORD *)(a1 + 32) = v26;
      v19 = this[8];
      v20 = (char *)((v19[2] + 3) & 0xFFFFFFFFFFFFFFFCLL);
      v21 = &v20[4 * (_QWORD)v18];
      if ((unint64_t)v21 > v19[3])
      {
        v20 = (char *)RB::Heap::alloc_slow(v19, 4 * (_QWORD)v18, 3);
        v18 = *(RB::Stroke::Dasher **)(a1 + 32);
        if (v18)
          goto LABEL_27;
      }
      else
      {
        v19[2] = (size_t)v21;
        if (v18)
        {
LABEL_27:
          if (v25)
            v22 = v25;
          else
            v22 = __dst;
          memmove(v20, v22, 4 * (_QWORD)v18);
        }
      }
      *(_QWORD *)(a1 + 40) = v20;
      goto LABEL_33;
    }
    *((_BYTE *)this + 56) = 1;
    *this = this[1];
  }
LABEL_33:
  if (v25)
    free(v25);
}

void sub_209B0BB9C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19)
    free(a19);
  _Unwind_Resume(exception_object);
}

void RB::Coverage::StrokeablePath::attributes(uint64_t a1, uint64_t a2, _QWORD *a3)
{
  uint64_t v6;
  uint64_t v7;
  void *v8;
  __int128 *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  double v13;
  int v14;
  char v15;
  float v16;
  unint64_t v17;
  float v18;
  void (**v19)(RB::XML::Value::Path *__hidden);
  void *v20[2];
  __int128 v21;
  __int128 v22;

  v6 = *(_QWORD *)a1;
  v7 = *(_QWORD *)(a1 + 8);
  v19 = &off_24C229060;
  v20[0] = (void *)RBPathRetain(v6, v7);
  v20[1] = v8;
  RB::XML::Element::set<RB::XML::Value::Path>(a3, (uint64_t)"stroked-path", (uint64_t)&v19);
  v19 = &off_24C229060;
  RBPathRelease((uint64_t)v20[0], (uint64_t)v20[1]);
  v9 = *(__int128 **)(a1 + 16);
  if (v9)
  {
    v10 = *v9;
    v11 = v9[1];
    v12 = v9[2];
    v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229330;
    *(_OWORD *)v20 = v10;
    v21 = v11;
    v22 = v12;
    RB::XML::Element::set<RB::XML::Value::Transform>(a3, (uint64_t)"transform", (uint64_t)&v19);
  }
  v13 = *(float *)(a1 + 24);
  v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229178;
  v20[0] = *(void **)&v13;
  RB::XML::Element::set<RB::XML::Value::Float>(a3, (uint64_t)"line-width", (uint64_t)&v19);
  v14 = *(unsigned __int8 *)(a2 + 73);
  if (v14 != 2)
  {
    v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229218;
    LOBYTE(v20[0]) = v14;
    RB::XML::Element::set<RB::XML::Value::LineCap>(a3, (uint64_t)"line-cap", (uint64_t)&v19);
  }
  v15 = *(_BYTE *)(a2 + 74);
  if (v15)
  {
    v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C2292E0;
    LOBYTE(v20[0]) = v15;
    RB::XML::Element::set<RB::XML::Value::LineJoin>(a3, (uint64_t)"line-join", (uint64_t)&v19);
  }
  v16 = *(float *)(a2 + 80);
  if (v16 != 10.0)
  {
    v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229178;
    *(double *)v20 = v16;
    RB::XML::Element::set<RB::XML::Value::Float>(a3, (uint64_t)"miter-limit", (uint64_t)&v19);
  }
  v17 = *(_QWORD *)(a1 + 32);
  if (v17)
  {
    RB::XML::Value::FloatArray::FloatArray<float>(&v19, *(float **)(a1 + 40), v17);
    RB::XML::Element::set<RB::XML::Value::FloatArray>(a3, (uint64_t)"dash", (uint64_t)&v19);
    v19 = &off_24C228E58;
    if (v20[0])
      free(v20[0]);
    v18 = *(float *)(a1 + 28);
    if (v18 != 0.0)
    {
      v19 = (void (**)(RB::XML::Value::Path *__hidden))&unk_24C229178;
      *(double *)v20 = v18;
      RB::XML::Element::set<RB::XML::Value::Float>(a3, (uint64_t)"dash-phase", (uint64_t)&v19);
    }
  }
}

void sub_209B0BDB0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12)
{
  if (a11)
    free(a11);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Path>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &off_24C229060;
  v6[1] = RBPathRetain(*(_QWORD *)(a3 + 8), *(_QWORD *)(a3 + 16));
  v6[2] = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Path,void>(v9 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

void sub_209B0BE94(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0xE1C40672A944CLL);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Transform>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229330;
  *(_OWORD *)(v6 + 8) = *(_OWORD *)(a3 + 8);
  *(_OWORD *)(v6 + 24) = *(_OWORD *)(a3 + 24);
  *(_OWORD *)(v6 + 40) = *(_OWORD *)(a3 + 40);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Transform,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Float>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &unk_24C229178;
  v6[1] = *(_QWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Float,void>(v8 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::LineCap>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C229218;
  *(_BYTE *)(v6 + 8) = *(_BYTE *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineCap,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::LineJoin>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C2292E0;
  *(_BYTE *)(v6 + 8) = *(_BYTE *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineJoin,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

void RB::Stroke::FixedWidthLineBounds::quadto(float32x2_t *a1, float64x2_t a2, float64x2_t a3, double a4, double a5, int32x4_t a6, int32x4_t a7, int32x4_t a8, int32x4_t a9)
{
  RB::Stroke::LineBounds::quadto(a1 + 2, vcvt_f32_f64(a2), vcvt_f32_f64(a3), a1[1].f32[0], a5, a6, a7, a8, a9);
}

void *RB::vector<float,16ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1);
  result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 8), __dst, 0x10uLL, (size_t *)__dst + 10, v3);
  *((_QWORD *)__dst + 8) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,4ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 4 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(4 * a5);
    v9 = v8 >> 2;
    if (v8 >> 2 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 4 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Path,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229C78;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B0C2D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Path *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Path>,std::allocator<RB::XML::Value::Path>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Path *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Path>,std::allocator<RB::XML::Value::Path>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Transform,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C22A030;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B0C388(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Transform *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Transform>,std::allocator<RB::XML::Value::Transform>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Transform *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Transform>,std::allocator<RB::XML::Value::Transform>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Float,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229E00;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B0C440(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Float *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Float>,std::allocator<RB::XML::Value::Float>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Float *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Float>,std::allocator<RB::XML::Value::Float>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineCap,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229EE0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B0C4F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::LineCap *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineCap>,std::allocator<RB::XML::Value::LineCap>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::LineCap *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineCap>,std::allocator<RB::XML::Value::LineCap>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::LineJoin,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229FC0;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B0C5B0(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::LineJoin *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineJoin>,std::allocator<RB::XML::Value::LineJoin>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::LineJoin *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::LineJoin>,std::allocator<RB::XML::Value::LineJoin>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

void RB::DisplayList::interpolated_bounds(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *a2, float a3, uint64_t a4, const RB::DisplayList::Contents *a5, const RB::DisplayList::Contents *a6)
{
  const RB::DisplayList::Item *v11;
  double v12;
  double v13;
  double v14;
  int32x4_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float32x2_t v20;
  float32x2_t v21;
  uint64_t v22;
  float32x2_t **v23;
  float32x2_t v24[2];

  if (!RB::DisplayList::Interpolator::Layer::is_fade(this))
  {
    if (a4)
    {
      v22 = *(_QWORD *)(a4 + 320);
      if (a5)
      {
LABEL_9:
        v23 = (float32x2_t **)*((_QWORD *)a5 + 40);
LABEL_12:
        RB::DisplayList::interpolated_bounds(this, a2, a3, v22, v23, v11);
        return;
      }
    }
    else
    {
      v22 = 0;
      if (a5)
        goto LABEL_9;
    }
    v23 = 0;
    goto LABEL_12;
  }
  v16 = 0;
  v17 = 0;
  v18 = 0;
  if (a4)
  {
    v18 = RB::DisplayList::Layer::bounds((RB::DisplayList::Layer *)(a4 + 320));
    v17 = v19;
  }
  v20 = 0;
  if (a5)
  {
    v20 = RB::DisplayList::Layer::bounds((const RB::DisplayList::Contents *)((char *)a5 + 320));
    v16 = v21;
  }
  v24[0] = v20;
  v24[1] = v16;
  RB::Rect::Union(v24, v18, v17, v12, v13, v14, v15);
}

void RB::DisplayList::interpolated_bounds(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *a2, float a3, uint64_t a4, float32x2_t **a5, const RB::DisplayList::Item *a6)
{
  int v8;
  double v11;
  double v12;
  double v13;
  float32x2_t v14;
  double v15;
  double v16;
  double v17;
  int32x4_t v18;
  double v19;
  float32x2_t v20;
  double v21;
  double v22;
  double v23;
  int32x4_t v24;
  double v25;
  size_t v26;
  uint64_t v27;
  size_t v28;
  _QWORD *v29;
  size_t v30;
  float32x2_t **v31;
  size_t v32;
  _QWORD *v33;
  int v34;
  RB::DisplayList::Interpolator::Contents *v35;
  float v36;
  int v37;
  int v38;
  int v39;
  int v40;
  char *v41;
  int v42;
  char *v43;
  double v44;
  uint64_t v45;
  uint64_t v47;
  size_t v48;
  _QWORD *v49;
  int v50;
  size_t v51;
  _QWORD *v52;
  int v53;
  double v54;
  double v55;
  double v56;
  int32x4_t v57;
  float v58;
  char *v59;
  float32x2_t v60;
  float32x2_t v61;
  double v62;
  double v63;
  double v64;
  int32x4_t v65;
  float32x2_t *v66;
  double v67;
  double v68;
  double v69;
  int32x4_t v70;
  float32x2_t *v71;
  float32x2_t v72;
  float32x2_t v73;
  uint64_t v74;
  uint64_t v75;
  double v76;
  double v77;
  double v78;
  int32x4_t v79;
  double v80;
  double v81;
  double v82;
  int32x4_t v83;
  uint64_t v84;
  const RB::DisplayList::ClipNode *v85;
  uint64_t v86;
  double v87;
  float32x2_t v88;
  double v89;
  double v90;
  double v91;
  int32x4_t v92;
  unsigned int v93;
  unsigned int v94;
  _QWORD *v95;
  double v96;
  float32x2_t v97;
  double v98;
  double v99;
  double v100;
  int32x4_t v101;
  unsigned int v102;
  unsigned int v103;
  _QWORD *v104;
  double v105;
  float32x2_t v106;
  double v107;
  double v108;
  double v109;
  int32x4_t v110;
  int v111;
  RB::Transition *v112;
  float32x2_t v113;
  float32x2_t v114;
  double v115;
  double v116;
  double v117;
  int32x4_t v118;
  int v119;
  int v120;
  RB::Transition *v121;
  float32x2_t v122;
  float32x2_t v123;
  double v124;
  double v125;
  double v126;
  int32x4_t v127;
  float32x2_t v128[2];
  RB::DisplayList::Interpolator::Contents *v129;
  char *v130;
  float v131;
  float v132;
  int v133;
  char v134;
  char v135;
  uint64_t v136;
  float32x2_t *v137[2];
  int v138;
  BOOL v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  char v148;
  uint64_t v149;
  uint64_t v150;
  __int16 v151;
  float32x2_t v152[2];
  int v153;
  BOOL v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  char v163;
  uint64_t v164;
  uint64_t v165;
  __int16 v166;
  __int128 v167[2];
  uint64_t v168;
  uint64_t v169;
  float32x2_t v170;
  float32x2_t v171;
  float32x2_t **v172;
  uint64_t v173;
  unsigned int v174;
  BOOL v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  char v184;
  uint64_t v185;
  uint64_t v186;
  __int16 v187;
  _QWORD v188[2];
  float v189;
  float v190;
  int v191;
  char v192;
  char v193;
  uint64_t v194;
  void *v195;
  size_t v196;
  unint64_t v197;
  _QWORD __dst[4];
  int v199;
  int v200;
  void *v201;
  size_t v202;
  unint64_t v203;
  uint64_t v204;
  float32x2_t v205;
  unsigned __int32 v206;
  BOOL v207;
  uint64_t v208;
  uint64_t v209;
  uint64_t v210;
  uint64_t v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  uint64_t v215;
  char v216;
  uint64_t v217;
  uint64_t v218;
  __int16 v219;
  uint64_t v220;
  _QWORD v221[17];

  v8 = (int)a2;
  v221[14] = *MEMORY[0x24BDAC8D0];
  v128[0] = 0;
  v128[1] = 0;
  if (RB::DisplayList::Interpolator::Layer::is_fade(this))
  {
    for (; a4; a4 = *(_QWORD *)(a4 + 8))
    {
      v13 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)a4);
      RB::Rect::Union(v128, *(float32x2_t *)&v13, v14, v15, v16, v17, v18);
    }
    while (a5)
    {
      v19 = RB::DisplayList::Item::clipped_bounds(a5);
      RB::Rect::Union(v128, *(float32x2_t *)&v19, v20, v21, v22, v23, v24);
      a5 = (float32x2_t **)a5[1];
    }
  }
  else if (*((_BYTE *)this + 248))
  {
    RB::DisplayList::Builder::Builder((RB::DisplayList::Builder *)&v172);
    if (*((_BYTE *)this + 248))
    {
      v202 = 0;
      v201 = 0;
      v203 = 32;
      v196 = 0;
      v195 = 0;
      v197 = 32;
      if (a4)
      {
        v26 = 0;
        v27 = a4;
        do
        {
          v28 = v26 + 1;
          if (v203 < v26 + 1)
          {
            RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(__dst, v28);
            v26 = v202;
            v28 = v202 + 1;
          }
          v29 = v201;
          if (!v201)
            v29 = __dst;
          v29[v26] = v27;
          v202 = v28;
          v27 = *(_QWORD *)(v27 + 8);
          v26 = v28;
        }
        while (v27);
      }
      if (a5)
      {
        v30 = v196;
        v31 = a5;
        do
        {
          v32 = v30 + 1;
          if (v197 < v30 + 1)
          {
            RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(v188, v32);
            v30 = v196;
            v32 = v196 + 1;
          }
          v33 = v195;
          if (!v195)
            v33 = v188;
          v33[v30] = v31;
          v196 = v32;
          v31 = (float32x2_t **)v31[1];
          v30 = v32;
        }
        while (v31);
      }
      v152[0] = (float32x2_t)a4;
      v152[1] = 0;
      v155 = 1;
      v156 = 1;
      v157 = 0;
      v158 = 1;
      v159 = 1;
      v160 = 0;
      v161 = 0;
      v162 = 0;
      v163 = 0;
      v164 = 0;
      v165 = 0;
      v166 = 256;
      if (a4)
        v34 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 40))(a4);
      else
        v34 = 0;
      v154 = v34 != -1;
      if (v34 == -1)
        v38 = 1;
      else
        v38 = v34;
      v153 = v38;
      v137[0] = (float32x2_t *)a5;
      v137[1] = 0;
      v140 = 1;
      v141 = 1;
      v142 = 0;
      v143 = 1;
      v144 = 1;
      v145 = 0;
      v146 = 0;
      v147 = 0;
      v148 = 0;
      v149 = 0;
      v150 = 0;
      v151 = 256;
      if (a5)
        v39 = ((uint64_t (*)(float32x2_t **))(*a5)[5])(a5);
      else
        v39 = 0;
      v139 = v39 != -1;
      if (v39 == -1)
        v40 = 1;
      else
        v40 = v39;
      v138 = v40;
      if (*((_QWORD *)this + 22))
        v41 = (char *)*((_QWORD *)this + 22);
      else
        v41 = (char *)this + 16;
      v42 = *((_DWORD *)this + 46);
      if (v42)
      {
        v43 = &v41[40 * v42];
        HIDWORD(v44) = 0;
        do
        {
          v45 = *(_QWORD *)v41 & 0xFLL;
          if ((_DWORD)v45 == 1 || (_DWORD)v45 == 8)
          {
            v47 = *(_QWORD *)v41 & 0xFLL;
          }
          else
          {
            v51 = *((unsigned int *)v41 + 2);
            v47 = *(_QWORD *)v41 & 0xFLL;
            if (v202 > v51)
            {
              v52 = v201;
              if (!v201)
                v52 = __dst;
              if (v45 == 9)
              {
                v53 = 0;
              }
              else if (*((_DWORD *)v41 + 3) == -1)
              {
                v53 = 0;
              }
              else
              {
                v53 = *((_DWORD *)v41 + 3);
              }
              RB::DisplayList::AtomizedItems::reset((uint64_t)v152, (const RB::DisplayList::Item *)v52[v51], v51, v53);
              v47 = *(_QWORD *)v41 & 0xFLL;
            }
          }
          if (v47)
          {
            v48 = *((unsigned int *)v41 + 4);
            if (v196 > v48)
            {
              v49 = v195;
              if (!v195)
                v49 = v188;
              if (v45 == 9)
              {
                v50 = 0;
              }
              else if (*((_DWORD *)v41 + 5) == -1)
              {
                v50 = 0;
              }
              else
              {
                v50 = *((_DWORD *)v41 + 5);
              }
              RB::DisplayList::AtomizedItems::reset((uint64_t)v137, (const RB::DisplayList::Item *)v49[v48], v48, v50);
            }
          }
          v129 = *(RB::DisplayList::Interpolator::Contents **)this;
          v130 = v41;
          v131 = a3;
          v132 = a3;
          v133 = 2139095040;
          v134 = v8;
          v135 = 0;
          v136 = 0;
          *(float *)&v44 = a3 - *((float *)v41 + 9);
          RB::DisplayList::Interpolator::Contents::animation_time(v129, *((_DWORD *)v41 + 8), 0, v44, v25);
          *(float *)&v25 = 1.0 - *(float *)&v44;
          if (v8)
            *(float *)&v44 = 1.0 - *(float *)&v44;
          v58 = fmaxf(*(float *)&v44, 0.0);
          v131 = v58;
          v59 = v130;
          switch(*(_DWORD *)v130 & 0xF)
          {
            case 0:
              RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)v152, this, (const RB::DisplayList::Interpolator::State *)&v129, 2u);
              goto LABEL_81;
            case 1:
            case 8:
              RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)v137, this, (const RB::DisplayList::Interpolator::State *)&v129, 1u);
              goto LABEL_81;
            case 2:
            case 6:
              if (v58 > 1.0)
                goto LABEL_77;
              RB::DisplayList::AtomizedItems::atom_bounds((RB::DisplayList::AtomizedItems *)v152, *(_QWORD *)v130 >> 36);
              v204 = (uint64_t)v72;
              v205 = v73;
              RB::DisplayList::AtomizedItems::atom_bounds((RB::DisplayList::AtomizedItems *)v137, *(_QWORD *)v130 >> 36);
              *(_QWORD *)&v167[0] = v74;
              *((_QWORD *)&v167[0] + 1) = v75;
              v170 = 0;
              v171 = 0;
              if (!(*(unsigned int (**)(_QWORD, RB::DisplayList::Interpolator::Contents **, uint64_t *, __int128 *, float32x2_t *))(**(_QWORD **)v152 + 224))(*(_QWORD *)v152, &v129, &v204, v167, v137[0]))goto LABEL_77;
              if ((RB::DisplayList::AtomizedItems::mix_clip_bounds(v152, (const RB::DisplayList::Interpolator::State *)&v129, (RB::Rect *)&v170, v137) & 1) != 0)
              {
                RB::Rect::intersect((float32x2_t *)&v204, v170, v171, v76, v77, v78, v79);
                RB::Rect::Union(v128, (float32x2_t)v204, v205, v80, v81, v82, v83);
              }
              else
              {
LABEL_77:
                if (!v173)
                  RB::DisplayList::Builder::reset_contents((RB::DisplayList::Builder *)&v172);
                v167[0] = xmmword_209BD5290;
                v167[1] = xmmword_209BD52A0;
                v168 = 0;
                v169 = 0;
                RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v204, (uint64_t)&v172, v167, 0, 0, 0);
                v84 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)v152, (const RB::DisplayList::Interpolator::State *)&v129, (const RB::DisplayList::AtomizedItems *)v137, (RB::DisplayList::CachedTransform *)&v204);
                v85 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)v152, (const RB::DisplayList::Interpolator::State *)&v129, (const RB::DisplayList::AtomizedItems *)v137, (RB::DisplayList::CachedTransform *)&v204);
                *(_QWORD *)(v84 + 16) = v86;
                *(_QWORD *)(v84 + 24) = v85;
                v87 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v84);
                RB::Rect::Union(v128, *(float32x2_t *)&v87, v88, v89, v90, v91, v92);
                (**(void (***)(uint64_t))v84)(v84);
                RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v221);
                RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v220);
                RB::Heap::~Heap((RB::Heap *)&v205);
              }
              break;
            case 3:
            case 7:
              v66 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds((RB::DisplayList::AtomizedItems *)v152);
              RB::Rect::Union(v128, *v66, v66[1], v67, v68, v69, v70);
              v71 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds((RB::DisplayList::AtomizedItems *)v137);
              goto LABEL_76;
            case 4:
            case 5:
              v71 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds((RB::DisplayList::AtomizedItems *)v137);
LABEL_76:
              v60 = *v71;
              v61 = v71[1];
LABEL_81:
              RB::Rect::Union(v128, v60, v61, v62, v63, v64, v65);
              break;
            case 9:
              v205 = 0;
              v204 = 0;
              if (*((_DWORD *)v130 + 3))
              {
                v93 = 0;
                do
                {
                  v94 = v93 + *((_DWORD *)v59 + 2);
                  v95 = v201;
                  if (!v201)
                    v95 = __dst;
                  v96 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v95[v94]);
                  RB::Rect::Union((float32x2_t *)&v204, *(float32x2_t *)&v96, v97, v98, v99, v100, v101);
                  ++v93;
                  v59 = v130;
                }
                while (v93 < *((_DWORD *)v130 + 3));
              }
              if (*((_DWORD *)v59 + 5))
              {
                v102 = 0;
                do
                {
                  v103 = v102 + *((_DWORD *)v59 + 4);
                  v104 = v195;
                  if (!v195)
                    v104 = v188;
                  v105 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v104[v103]);
                  RB::Rect::Union((float32x2_t *)&v204, *(float32x2_t *)&v105, v106, v107, v108, v109, v110);
                  ++v102;
                  v59 = v130;
                }
                while (v102 < *((_DWORD *)v130 + 5));
              }
              RB::Rect::Union(v128, (float32x2_t)v204, v205, v54, v55, v56, v57);
              break;
            default:
              break;
          }
          v41 += 40;
        }
        while (v41 != v43);
      }
      if (v195)
        free(v195);
      if (v201)
        free(v201);
    }
    RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)&v172);
  }
  else
  {
    __dst[3] = 0x100000000;
    __dst[2] = 0;
    v200 = 0;
    v35 = *(RB::DisplayList::Interpolator::Contents **)this;
    v199 = *(_DWORD *)(*(_QWORD *)this + 16);
    __dst[1] = 0;
    __dst[0] = 0xFFFFFFF100000000;
    *(float *)&v11 = a3;
    RB::DisplayList::Interpolator::Contents::animation_time(v35, v199, 0, v11, v12);
    v188[0] = *(_QWORD *)this;
    v188[1] = __dst;
    if (v8)
      v36 = 1.0 - v36;
    v189 = v36;
    v190 = a3;
    v191 = 2139095040;
    v192 = v8;
    v193 = 0;
    v194 = 0;
    v204 = a4;
    v205 = 0;
    v208 = 1;
    v209 = 1;
    v210 = 0;
    v211 = 1;
    v212 = 1;
    v213 = 0;
    v215 = 0;
    v214 = 0;
    v216 = 0;
    v218 = 0;
    v217 = 0;
    v219 = 256;
    if (a4)
      v37 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 40))(a4);
    else
      v37 = 0;
    v207 = v37 != -1;
    if (v37 == -1)
      v111 = 1;
    else
      v111 = v37;
    v206 = v111;
    if (v111)
    {
      do
      {
        v112 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v204, this);
        if (!RB::Transition::empty_transition(v112, 2))
        {
          RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)&v204, this, (const RB::DisplayList::Interpolator::State *)v188, 2u);
          RB::Rect::Union(v128, v113, v114, v115, v116, v117, v118);
        }
        RB::DisplayList::AtomizedItems::advance(&v204, 1);
      }
      while (v205.i32[1] < v206);
    }
    v172 = a5;
    v173 = 0;
    v176 = 1;
    v177 = 1;
    v178 = 0;
    v179 = 1;
    v180 = 1;
    v181 = 0;
    v182 = 0;
    v183 = 0;
    v184 = 0;
    v186 = 0;
    v185 = 0;
    v187 = 256;
    if (a5)
      v119 = ((uint64_t (*)(float32x2_t **))(*a5)[5])(a5);
    else
      v119 = 0;
    v175 = v119 != -1;
    if (v119 == -1)
      v120 = 1;
    else
      v120 = v119;
    v174 = v120;
    if (v120)
    {
      do
      {
        __dst[0] = __dst[0] & 0xFFFFFFFFFFFFFFF0 | 1;
        v121 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v172, this);
        if (RB::Transition::empty_transition(v121, 1))
          __dst[0] = __dst[0] & 0xFFFFFFFFFFFFFFF0 | 8;
        RB::DisplayList::AtomizedItems::effect_bounds((RB::DisplayList::AtomizedItems *)&v172, this, (const RB::DisplayList::Interpolator::State *)v188, 1u);
        RB::Rect::Union(v128, v122, v123, v124, v125, v126, v127);
        RB::DisplayList::AtomizedItems::advance(&v172, 1);
      }
      while (HIDWORD(v173) < v174);
    }
  }
}

void sub_209B0CF8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,char a61)
{
  if (STACK[0x3C0])
    free((void *)STACK[0x3C0]);
  if (STACK[0x4D8])
    free((void *)STACK[0x4D8]);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)&a61);
  _Unwind_Resume(a1);
}

void RB::DisplayList::apply_interpolator(RB::DisplayList *this, const RB::DisplayList::Interpolator::Layer *a2, double a3, unsigned int a4, RB::DisplayList::Layer *a5, float64x2_t *a6, double a7, float32x2_t *a8, const RB::Rect *a9, const RB::DisplayList::Item *a10, const RB::DisplayList::Item *a11, const RB::AffineTransform *a12)
{
  int v14;
  float v15;
  RB::DisplayList::Builder *v17;
  float32x2_t *v20;
  float v21;
  int v22;
  int v23;
  RB::Transition *v24;
  int v25;
  int v26;
  RB::Transition *v27;
  size_t v28;
  const RB::Rect *v29;
  size_t v30;
  const RB::Rect **v31;
  size_t v32;
  const RB::DisplayList::Item *v33;
  size_t v34;
  const RB::DisplayList::Item **v35;
  int v36;
  int v37;
  int v38;
  int v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v45;
  size_t v46;
  const RB::DisplayList::Item **v47;
  int v48;
  size_t v49;
  const RB::Rect **v50;
  int v51;
  char v52;
  unsigned int v53;
  RB::DisplayList::AtomizedItems *v54;
  const RB::DisplayList::ClipNode *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  double v60;
  float32x2_t v61;
  double v62;
  double v63;
  double v64;
  int32x4_t v65;
  RB::DisplayList::Builder **v66;
  uint64_t v67;
  int v68;
  double v69;
  float32x2_t v70;
  double v71;
  double v72;
  double v73;
  int32x4_t v74;
  uint64_t v75;
  uint64_t v76;
  const RB::DisplayList::ClipNode *v88;
  uint64_t v89;
  int v90;
  double v91;
  float32x2_t v92;
  double v93;
  double v94;
  double v95;
  int32x4_t v96;
  unsigned int v97;
  float32x2_t *v98;
  double v99;
  double v100;
  double v101;
  int32x4_t v102;
  RB::DisplayList::Item *v103;
  RB::DisplayList::Item *v104;
  RB::DisplayList::Item *v105;
  RB::DisplayList::Item *v106;
  float32x2_t *v107;
  double v108;
  double v109;
  double v110;
  int32x4_t v111;
  _QWORD v112[2];
  float32x2_t *v113;
  float32x2_t *v114;
  const RB::DisplayList::Item *v115;
  RB::DisplayList::Layer **v116;
  _QWORD v117[4];
  RB::DisplayList::Layer *v118;
  RB::DisplayList::Builder *v119;
  float v120;
  RB::DisplayList::Interpolator::Contents *v121;
  char *v122;
  float v123;
  float v124;
  int v125;
  char v126;
  char v127;
  const RB::DisplayList::Item *v128;
  const RB::DisplayList::Item *v129;
  unint64_t *v130;
  float v131;
  float v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  char v141;
  uint64_t v142;
  uint64_t v143;
  __int16 v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  uint64_t v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  char v156;
  uint64_t v157;
  uint64_t v158;
  __int16 v159;
  _QWORD v160[2];
  float v161;
  float v162;
  int v163;
  char v164;
  char v165;
  const RB::DisplayList::Item *v166;
  RB::DisplayList::Builder **v167;
  int8x16_t v168;
  uint64_t v169;
  uint64_t v170;
  const RB::DisplayList::Item *v171;
  uint64_t v172;
  unsigned int v173;
  BOOL v174;
  uint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  uint64_t v182;
  char v183;
  uint64_t v184;
  uint64_t v185;
  __int16 v186;
  const RB::DisplayList::Item **v187;
  size_t v188;
  unint64_t v189;
  const RB::Rect *v190;
  uint64_t v191;
  unsigned int v192;
  BOOL v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  char v202;
  uint64_t v203;
  uint64_t v204;
  __int16 v205;
  const RB::Rect **v206;
  size_t v207;
  unint64_t v208;
  uint64_t v209;

  v14 = (int)a2;
  v15 = *(float *)&a3;
  v115 = a11;
  v209 = *MEMORY[0x24BDAC8D0];
  v17 = *(RB::DisplayList::Builder **)&a6->f64[0];
  v118 = a5;
  v119 = v17;
  v120 = *(float *)&a7;
  v117[0] = this;
  v117[1] = a8;
  v117[2] = &v118;
  v117[3] = a6;
  v116 = &v118;
  if (*((_BYTE *)this + 248) && *((_DWORD *)this + 46))
  {
    if (a8)
    {
      MEMORY[0x24BDAC7A8](this, a2);
      v20 = (float32x2_t *)v112;
      *(float32x2_t *)&a3 = RB::operator*(a6 + 68, *a8, a8[1]);
      *(double *)v112 = a3;
      *(double *)&v112[1] = a7;
      if (!*((_BYTE *)this + 248))
        return;
    }
    else
    {
      v20 = 0;
    }
    v113 = a8;
    v114 = v20;
    v207 = 0;
    v206 = 0;
    v208 = 32;
    v188 = 0;
    v187 = 0;
    v189 = 32;
    if (a9)
    {
      v28 = 0;
      v29 = a9;
      do
      {
        v30 = v28 + 1;
        if (v208 < v28 + 1)
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&v190, v30);
          v28 = v207;
          v30 = v207 + 1;
        }
        v31 = v206;
        if (!v206)
          v31 = &v190;
        v31[v28] = v29;
        v207 = v30;
        v29 = (const RB::Rect *)*((_QWORD *)v29 + 1);
        v28 = v30;
      }
      while (v29);
    }
    if (a10)
    {
      v32 = v188;
      v33 = a10;
      do
      {
        v34 = v32 + 1;
        if (v189 < v32 + 1)
        {
          RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(&v171, v34);
          v32 = v188;
          v34 = v188 + 1;
        }
        v35 = v187;
        if (!v187)
          v35 = &v171;
        v35[v32] = v33;
        v188 = v34;
        v33 = (const RB::DisplayList::Item *)*((_QWORD *)v33 + 1);
        v32 = v34;
      }
      while (v33);
    }
    v145 = (unint64_t)a9;
    v146 = 0;
    v148 = 1;
    v149 = 1;
    v150 = 0;
    v151 = 1;
    v152 = 1;
    v153 = 0;
    v154 = 0;
    v155 = 0;
    v156 = 0;
    v157 = 0;
    v158 = 0;
    v159 = 256;
    if (a9)
      v36 = (*(uint64_t (**)(const RB::Rect *))(*(_QWORD *)a9 + 40))(a9);
    else
      v36 = 0;
    BYTE4(v147) = v36 != -1;
    if (v36 == -1)
      v37 = 1;
    else
      v37 = v36;
    LODWORD(v147) = v37;
    v129 = a10;
    v130 = 0;
    v133 = 1;
    v134 = 1;
    v135 = 0;
    v136 = 1;
    v137 = 1;
    v138 = 0;
    v139 = 0;
    v140 = 0;
    v141 = 0;
    v142 = 0;
    v143 = 0;
    v144 = 256;
    if (a10)
      v38 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(_QWORD *)a10 + 40))(a10);
    else
      v38 = 0;
    LOBYTE(v132) = v38 != -1;
    if (v38 == -1)
      v39 = 1;
    else
      v39 = v38;
    v131 = *(float *)&v39;
    if (*((_QWORD *)this + 22))
      v40 = (char *)*((_QWORD *)this + 22);
    else
      v40 = (char *)this + 16;
    v41 = *((unsigned int *)this + 46);
    if ((_DWORD)v41)
    {
      v42 = 40 * v41;
      while (2)
      {
        v43 = *(_QWORD *)v40 & 0xFLL;
        if ((_DWORD)v43 == 1 || (_DWORD)v43 == 8)
        {
          v45 = *(_QWORD *)v40 & 0xFLL;
        }
        else
        {
          v49 = *((unsigned int *)v40 + 2);
          v45 = *(_QWORD *)v40 & 0xFLL;
          if (v207 > v49)
          {
            v50 = v206;
            if (!v206)
              v50 = &v190;
            if (v43 == 9)
            {
              v51 = 0;
            }
            else if (*((_DWORD *)v40 + 3) == -1)
            {
              v51 = 0;
            }
            else
            {
              v51 = *((_DWORD *)v40 + 3);
            }
            RB::DisplayList::AtomizedItems::reset((uint64_t)&v145, v50[v49], v49, v51);
            v45 = *(_QWORD *)v40 & 0xFLL;
          }
        }
        if (v45)
        {
          v46 = *((unsigned int *)v40 + 4);
          if (v188 > v46)
          {
            v47 = v187;
            if (!v187)
              v47 = &v171;
            if (v43 == 9)
            {
              v48 = 0;
            }
            else if (*((_DWORD *)v40 + 5) == -1)
            {
              v48 = 0;
            }
            else
            {
              v48 = *((_DWORD *)v40 + 5);
            }
            RB::DisplayList::AtomizedItems::reset((uint64_t)&v129, v47[v46], v46, v48);
          }
        }
        v121 = *(RB::DisplayList::Interpolator::Contents **)this;
        v122 = v40;
        v123 = v15;
        v124 = v15;
        v125 = 2139095040;
        v126 = v14;
        v127 = 0;
        v128 = 0;
        *(float *)&a3 = v15 - *((float *)v40 + 9);
        RB::DisplayList::Interpolator::Contents::animation_time(v121, *((_DWORD *)v40 + 8), 0, a3, a7);
        *(float *)&a7 = 1.0 - *(float *)&a3;
        if (v14)
          *(float *)&a3 = 1.0 - *(float *)&a3;
        v123 = fmaxf(*(float *)&a3, 0.0);
        v128 = v115;
        v52 = 0;
        v53 = 2;
        v54 = (RB::DisplayList::AtomizedItems *)&v145;
        switch(*(_DWORD *)v122 & 0xF)
        {
          case 0:
            goto LABEL_87;
          case 1:
          case 4:
          case 5:
          case 8:
            v52 = (*(_QWORD *)v122 & 0xFLL) != 1;
            v53 = 1;
            v54 = (RB::DisplayList::AtomizedItems *)&v129;
LABEL_87:
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v117, v54, (uint64_t)&v121, v53, v52);
            goto LABEL_115;
          case 2:
          case 3:
            v75 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v145, (const RB::DisplayList::Interpolator::State *)&v121, (const RB::DisplayList::AtomizedItems *)&v129, (RB::DisplayList::CachedTransform *)a6);
            v76 = v75;
            _S0 = v123;
            if (v123 < 0.0)
              _S0 = 0.0;
            if (_S0 > 1.0)
              _S0 = 1.0;
            _H1 = *(_WORD *)(v145 + 44);
            _H2 = *((_WORD *)v129 + 22);
            __asm
            {
              FCVT            H0, S0
              FCVT            S1, H1
              FCVT            S2, H2
              FCVT            S0, H0
            }
            _S0 = _S1 + (float)((float)(_S2 - _S1) * _S0);
            __asm { FCVT            H0, S0 }
            *(_WORD *)(v75 + 44) = LOWORD(_S0);
            v88 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)&v145, (const RB::DisplayList::Interpolator::State *)&v121, (const RB::DisplayList::AtomizedItems *)&v129, (RB::DisplayList::CachedTransform *)a6);
            *(_QWORD *)(v76 + 16) = v89;
            *(_QWORD *)(v76 + 24) = v88;
            *(_QWORD *)(v76 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *((const RB::DisplayList::Metadata **)v129 + 4), *((_DWORD *)v129 + 10));
            *(_DWORD *)(v76 + 40) = v90;
            if (v114
              && (v91 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v76),
                  !RB::Rect::intersects(v114, *(float32x2_t *)&v91, v92, v93, v94, v95, v96)))
            {
              (**(void (***)(uint64_t))v76)(v76);
            }
            else
            {
              RB::DisplayList::Item::apply_alpha(v76, v120);
              RB::DisplayList::Builder::draw(v119, (RB::DisplayList::Item *)v76, v118, 0);
            }
            goto LABEL_115;
          case 6:
          case 7:
            v55 = RB::DisplayList::AtomizedItems::mix_clip_style((RB::DisplayList::AtomizedItems *)&v145, (const RB::DisplayList::Interpolator::State *)&v121, (const RB::DisplayList::AtomizedItems *)&v129, (RB::DisplayList::CachedTransform *)a6);
            v57 = v56;
            v58 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v145, (const RB::DisplayList::Interpolator::State *)&v121, (const RB::DisplayList::AtomizedItems *)&v129, (RB::DisplayList::CachedTransform *)a6);
            *(_QWORD *)(v58 + 16) = v57;
            *(_QWORD *)(v58 + 24) = v55;
            *(_QWORD *)(v58 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *(const RB::DisplayList::Metadata **)(v58 + 32), *(_DWORD *)(v58 + 40));
            *(_DWORD *)(v58 + 40) = v59;
            if (v114)
            {
              v60 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v58);
              if ((RB::Rect::intersects(v114, *(float32x2_t *)&v60, v61, v62, v63, v64, v65) & 1) == 0)
              {
                (**(void (***)(uint64_t))v58)(v58);
                v58 = 0;
              }
            }
            v66 = (RB::DisplayList::Builder **)(*(_QWORD *)v122 & 0xFFFFFFF00000000FLL);
            v168 = vextq_s8(*(int8x16_t *)(v122 + 8), *(int8x16_t *)(v122 + 8), 8uLL);
            v169 = 0x100000000;
            v170 = 0;
            v160[0] = v121;
            v160[1] = &v167;
            v163 = 2139095040;
            v165 = 0;
            v166 = v128;
            v167 = v66;
            v162 = v124;
            v161 = 1.0 - v123;
            v164 = v126 ^ 1;
            v67 = RB::DisplayList::AtomizedItems::mix((RB::DisplayList::AtomizedItems *)&v129, (const RB::DisplayList::Interpolator::State *)v160, (const RB::DisplayList::AtomizedItems *)&v145, (RB::DisplayList::CachedTransform *)a6);
            *(_QWORD *)(v67 + 16) = v57;
            *(_QWORD *)(v67 + 24) = v55;
            *(_QWORD *)(v67 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a6, *(const RB::DisplayList::Metadata **)(v67 + 32), *(_DWORD *)(v67 + 40));
            *(_DWORD *)(v67 + 40) = v68;
            if (v114)
            {
              v69 = RB::DisplayList::Item::clipped_bounds((float32x2_t **)v67);
              if ((RB::Rect::intersects(v114, *(float32x2_t *)&v69, v70, v71, v72, v73, v74) & 1) == 0)
              {
                (**(void (***)(uint64_t))v67)(v67);
                v67 = 0;
              }
            }
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()((RB::DisplayList::Builder *)&v116, (uint64_t)&v121, (RB::DisplayList::Item *)v58, (RB::DisplayList::Item *)v67, *(_QWORD *)&a6->f64[0]);
            goto LABEL_115;
          case 9:
            v97 = *((_DWORD *)v122 + 3);
            if (v97 != 1 || *((_DWORD *)v122 + 5) != 1)
            {
              v167 = (RB::DisplayList::Builder **)a6;
              v168.i64[0] = (uint64_t)v113;
              _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(&v167, *((_DWORD *)v122 + 2), v97, (uint64_t)&v190);
              v103 = v104;
              _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(&v167, *((_DWORD *)v122 + 4), *((_DWORD *)v122 + 5), (uint64_t)&v171);
              v106 = v105;
              goto LABEL_113;
            }
            if (v113
              && (v98 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds((RB::DisplayList::AtomizedItems *)&v145),
                  !RB::Rect::intersects(v113, *v98, v98[1], v99, v100, v101, v102)))
            {
              v103 = 0;
            }
            else
            {
              v103 = (RB::DisplayList::Item *)RB::DisplayList::AtomizedItems::copy((RB::DisplayList::AtomizedItems *)&v145, *(RB::DisplayList::Builder **)&a6->f64[0], (v147 - HIDWORD(v146)), 4);
              (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(_QWORD *)v103 + 32))(v103, a6, 1);
              if (!v113)
                goto LABEL_119;
            }
            v107 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds((RB::DisplayList::AtomizedItems *)&v129);
            if (RB::Rect::intersects(v113, *v107, v107[1], v108, v109, v110, v111))
            {
LABEL_119:
              v106 = (RB::DisplayList::Item *)RB::DisplayList::AtomizedItems::copy((RB::DisplayList::AtomizedItems *)&v129, *(RB::DisplayList::Builder **)&a6->f64[0], (LODWORD(v131) - HIDWORD(v130)), 4);
              (*(void (**)(RB::DisplayList::Item *, float64x2_t *, uint64_t))(*(_QWORD *)v106 + 32))(v106, a6, 1);
              goto LABEL_113;
            }
            v106 = 0;
LABEL_113:
            RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()((RB::DisplayList::Builder *)&v116, (uint64_t)&v121, v103, v106, *(_QWORD *)&a6->f64[0]);
LABEL_115:
            v40 += 40;
            v42 -= 40;
            if (!v42)
              break;
            continue;
          default:
            goto LABEL_115;
        }
        break;
      }
    }
    if (v187)
      free(v187);
    if (v206)
      free(v206);
  }
  else
  {
    v147 = 0;
    v148 = 0x100000000;
    v149 = a4;
    v145 = 0xFFFFFFF100000000;
    v146 = 0;
    RB::DisplayList::Interpolator::Contents::animation_time(*(RB::DisplayList::Interpolator::Contents **)this, a4, 0, a3, a7);
    v129 = *(const RB::DisplayList::Item **)this;
    v130 = &v145;
    if (v14)
      v21 = 1.0 - v21;
    v131 = v21;
    v132 = v15;
    LODWORD(v133) = 2139095040;
    WORD2(v133) = v14;
    v134 = (uint64_t)v115;
    v190 = a9;
    v191 = 0;
    v194 = 1;
    v195 = 1;
    v196 = 0;
    v197 = 1;
    v198 = 1;
    v199 = 0;
    v201 = 0;
    v200 = 0;
    v202 = 0;
    v204 = 0;
    v203 = 0;
    v205 = 256;
    if (a9)
      v22 = (*(uint64_t (**)(const RB::Rect *))(*(_QWORD *)a9 + 40))(a9);
    else
      v22 = 0;
    v193 = v22 != -1;
    if (v22 == -1)
      v23 = 1;
    else
      v23 = v22;
    v192 = v23;
    if (v23)
    {
      do
      {
        v24 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v190, this);
        if (RB::Transition::empty_transition(v24, 2))
          RB::DisplayList::AtomizedItems::advance(&v190, 1);
        else
          RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v117, (RB::DisplayList::AtomizedItems *)&v190, (uint64_t)&v129, 2u, 0);
      }
      while (HIDWORD(v191) < v192);
    }
    v171 = a10;
    v172 = 0;
    v175 = 1;
    v176 = 1;
    v177 = 0;
    v178 = 1;
    v179 = 1;
    v180 = 0;
    v182 = 0;
    v181 = 0;
    v183 = 0;
    v185 = 0;
    v184 = 0;
    v186 = 256;
    if (a10)
      v25 = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(_QWORD *)a10 + 40))(a10);
    else
      v25 = 0;
    v174 = v25 != -1;
    if (v25 == -1)
      v26 = 1;
    else
      v26 = v25;
    v173 = v26;
    if (v26)
    {
      do
      {
        v145 = v145 & 0xFFFFFFFFFFFFFFF0 | 1;
        v27 = RB::DisplayList::AtomizedItems::transition((RB::DisplayList::AtomizedItems *)&v171, this);
        if (RB::Transition::empty_transition(v27, 1))
          v145 = v145 & 0xFFFFFFFFFFFFFFF0 | 8;
        RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()((uint64_t)v117, (RB::DisplayList::AtomizedItems *)&v171, (uint64_t)&v129, 1u, 0);
      }
      while (HIDWORD(v172) < v173);
    }
  }
}

void sub_209B0D994(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 704);
  if (v3)
    free(v3);
  v4 = *(void **)(v1 + 984);
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

_DWORD *RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_1::operator()(uint64_t a1, RB::DisplayList::AtomizedItems *this, uint64_t a3, unsigned int a4, char a5)
{
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  float32x2_t *v13;
  float32x2_t *v14;
  double v15;
  double v16;
  double v17;
  int32x4_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  float64x2_t *v23;
  float64x2_t v24;
  __int128 v25;
  __int128 v26;
  int64x2_t v27;
  float v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float v36;
  char v37;
  float v38;
  float64x2_t v39;
  __int128 v40;
  __int128 v41;
  uint64_t v42;
  _QWORD v43[15];

  v43[14] = *MEMORY[0x24BDAC8D0];
  v10 = **(_QWORD **)(a3 + 8) >> 36;
  v11 = *((_DWORD *)this + 4) - *((_DWORD *)this + 3);
  if (v11 >= v10)
    v12 = v10;
  else
    v12 = v11;
  v13 = *(float32x2_t **)(a1 + 8);
  if (v13)
  {
    v14 = (float32x2_t *)RB::DisplayList::AtomizedItems::clipped_bounds(this);
    v19 = RB::Rect::intersects(v13, *v14, v14[1], v15, v16, v17, v18);
    if ((v19 & 1) != 0 || (a5 & 1) != 0)
    {
      if (!v19)
        return RB::DisplayList::AtomizedItems::advance(this, v12);
    }
    else if ((RB::DisplayList::AtomizedItems::effects_change_geometry(this, *(const RB::DisplayList::Interpolator::Layer **)a1, (const RB::DisplayList::Interpolator::State *)a3, a4) & 1) == 0)
    {
      return RB::DisplayList::AtomizedItems::advance(this, v12);
    }
  }
  v20 = RB::DisplayList::AtomizedItems::copy(this, **(RB::DisplayList::Builder ***)(a1 + 24), v12, 4);
  if ((a5 & 1) == 0 && (*(_WORD *)(*(_QWORD *)this + 46) & 0x800) == 0)
  {
    if (RB::DisplayList::AtomizedItems::effects_change_geometry(this, *(const RB::DisplayList::Interpolator::Layer **)a1, (const RB::DisplayList::Interpolator::State *)a3, a4))
    {
      v21 = *(_QWORD *)(a1 + 24);
      v22 = *(_OWORD *)(v21 + 1104);
      v39 = *(float64x2_t *)(v21 + 1088);
      v40 = v22;
      v41 = *(_OWORD *)(v21 + 1120);
      v23 = *(float64x2_t **)(a3 + 32);
      if (v23)
      {
        v24.f64[0] = RB::operator*(&v39, v23);
        v39 = v24;
        v40 = v25;
        v41 = v26;
      }
      (*(void (**)(uint64_t, float64x2_t *))(*(_QWORD *)v20 + 128))(v20, &v39);
    }
    v33 = (float64x2_t)xmmword_209BD5290;
    v34 = (float64x2_t)xmmword_209BD52A0;
    v37 = 0;
    v35 = 0uLL;
    LOBYTE(v36) = 0;
    v38 = 1.0;
    RB::DisplayList::AtomizedItems::apply_effects((uint64_t)this, *(const RB::DisplayList::Interpolator::Layer **)a1, a3, a4, (float32x2_t **)v20, (uint64_t)&v33);
    RB::DisplayList::Item::apply_alpha(v20, v38);
    v27 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v34, (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(v33, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v35));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) == 0)
    {
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)&v39, **(_QWORD **)(a1 + 24), (__int128 *)&v33, 0, 0, 0);
      (*(void (**)(uint64_t, float64x2_t *, _QWORD))(*(_QWORD *)v20 + 32))(v20, &v39, 0);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v43);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)&v42);
      RB::Heap::~Heap((RB::Heap *)&v39.f64[1]);
    }
    if (v37)
    {
      v28 = v36;
      if (v36 > 512.0)
        v28 = 512.0;
      *(float *)v39.f64 = v28;
      v29 = RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,float &>((size_t *)(*(_QWORD *)(**(_QWORD **)(a1 + 24) + 8) + 16), (float *)&v39);
      *(_QWORD *)(v29 + 16) = RB::AffineTransform::identity((RB::AffineTransform *)v29);
      v30 = *(_QWORD *)(**(_QWORD **)(a1 + 24) + 8);
      *(_QWORD *)(v29 + 8) = *(_QWORD *)(v30 + 312);
      *(_QWORD *)(v30 + 312) = v29;
      *(_QWORD *)(v29 + 32) = *(_QWORD *)(v20 + 16);
      *(_DWORD *)(v29 + 52) |= 1u;
      *(_QWORD *)(v20 + 16) = v29;
    }
  }
  if (v20)
  {
    (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)v20 + 32))(v20, *(_QWORD *)(a1 + 24), 1);
    if ((a4 & 2) != 0)
      *(_WORD *)(v20 + 46) |= 0x800u;
    v31 = *(_QWORD *)(a1 + 16);
    RB::DisplayList::Item::apply_alpha(v20, *(float *)(v31 + 16));
    RB::DisplayList::Builder::draw(*(RB::DisplayList::Builder **)(v31 + 8), (RB::DisplayList::Item *)v20, *(RB::DisplayList::Layer **)v31, 0);
  }
  return RB::DisplayList::AtomizedItems::advance(this, v12);
}

void sub_209B0DCF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_list va;

  va_start(va, a13);
  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)va);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::Item::mix_bounds(RB::DisplayList::Item *this, const State *a2, float32x2_t *a3, float32x2_t *a4, const RB::DisplayList::Item *a5)
{
  uint64_t v5;
  float32x2_t v6;
  float32x2_t v7;
  float32x2_t v8;

  v5 = *(_QWORD *)&a2->var0;
  v6 = vadd_f32(a3[1], *a3);
  v7 = vmla_n_f32(*a3, vsub_f32(*a4, *a3), *(float *)&v5);
  v8 = vsub_f32(vmla_n_f32(v6, vadd_f32(vsub_f32(*a4, v6), a4[1]), *(float *)&v5), v7);
  *a3 = v7;
  a3[1] = v8;
  return 1;
}

uint64_t RB::DisplayList::Clip::mix_bounds(uint64_t a1, uint64_t a2, float32x2_t *a3, float32x2_t *a4)
{
  uint64_t v4;
  float32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = vadd_f32(a3[1], *a3);
  v6 = vmla_n_f32(*a3, vsub_f32(*a4, *a3), *(float *)&v4);
  v7 = vsub_f32(vmla_n_f32(v5, vadd_f32(vsub_f32(*a4, v5), a4[1]), *(float *)&v4), v6);
  *a3 = v6;
  a3[1] = v7;
  return 1;
}

uint64_t RB::DisplayList::Layer::can_mix(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  BOOL v5;
  BOOL v6;
  uint64_t v7;
  const RB::DisplayList::Item *v8;
  uint64_t i;
  uint64_t v12;
  float v13;
  int v14;
  unsigned int v15;

  if (*(_QWORD *)(a1 + 16))
    return 0;
  v5 = !*(_BYTE *)(a1 + 64) && *(_QWORD *)(a3 + 16) == 0;
  v6 = v5 && *(_BYTE *)(a3 + 64) == 0;
  if (!v6
    || ((*(_DWORD *)(a3 + 60) ^ *(_DWORD *)(a1 + 60)) & 0x224F) != 0
    || *(unsigned __int8 *)(a1 + 67) != *(unsigned __int8 *)(a3 + 67))
  {
    return 0;
  }
  v7 = *(_QWORD *)a1;
  v8 = *(const RB::DisplayList::Item **)a3;
  if (!(*(_QWORD *)a1 | *(_QWORD *)a3))
    return a4;
  for (i = 0; v7; v7 = *(_QWORD *)(v7 + 8))
    i |= 1 << *(_WORD *)(v7 + 46);
  for (; v8; v8 = (const RB::DisplayList::Item *)*((_QWORD *)v8 + 1))
    i |= 1 << *((_WORD *)v8 + 23);
  if ((i & 3) != 0)
    return 0;
  v12 = RB::DisplayList::Interpolator::Contents::make_layer<RB::DisplayList::Layer::can_mix(RB::DisplayList::Interpolator::Contents&,RB::DisplayList::Layer const&,RB::Mixable)::$_2>(a2, *(_DWORD *)(a1 + 56), *(unsigned int *)(a3 + 56), a1, (const RB::DisplayList::Item **)a3);
  if (!v12)
    return 0;
  v13 = *(float *)(v12 + 8);
  if (*(float *)(a2 + 72) > v13)
    v13 = *(float *)(a2 + 72);
  *(float *)(a2 + 72) = v13;
  if (a4 < 4u)
  {
    if (a4 != 3)
    {
      if (a4 < 2u)
        return a4;
      v14 = *(_DWORD *)(v12 + 192);
      a4 = 2;
      goto LABEL_32;
    }
    v14 = *(_DWORD *)(v12 + 192);
    v15 = 3;
  }
  else
  {
    v14 = *(_DWORD *)(v12 + 192);
    if (v14 == 32)
      v15 = a4;
    else
      v15 = 3;
  }
  if ((v14 & 0xFFFFFECF) != 0)
    a4 = 2;
  else
    a4 = v15;
LABEL_32:
  if ((v14 & 0x44) != 0)
    return 1;
  if (*(_BYTE *)(v12 + 250))
  {
    if ((v14 & 3) != 0 || *(_BYTE *)(v12 + 248) == 0)
      return 1;
  }
  return a4;
}

uint64_t RB::DisplayList::Interpolator::Contents::make_layer<RB::DisplayList::Layer::can_mix(RB::DisplayList::Interpolator::Contents&,RB::DisplayList::Layer const&,RB::Mixable)::$_2>(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, const RB::DisplayList::Item **a5)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t *v10;
  const RB::DisplayList::Item *v11;
  uint64_t v12;
  BOOL is_fade;
  BOOL v14;
  _QWORD v16[2];
  uint64_t v17;
  int v18;
  void *v19;
  uint64_t v20;
  int v21;
  void *v22;
  uint64_t v23;
  int v24;
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  v8 = a1 + 32;
  v9 = a2 | (unint64_t)(a3 << 32);
  v17 = v9;
  v10 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>((_QWORD *)(a1 + 32), (unsigned int *)&v17);
  if (v10)
    return v10[3];
  v18 = 0;
  v19 = 0;
  v20 = 0x400000000;
  v21 = 0;
  v22 = 0;
  v23 = 0x200000000;
  v24 = 1;
  v17 = a1;
  RB::DisplayList::make_interpolator((RB::DisplayList *)&v17, *(RB::DisplayList::Interpolator::Layer **)a4, *a5, v11);
  if ((_BYTE)v24)
  {
    is_fade = RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)&v17);
    if (BYTE1(v24))
      v14 = 0;
    else
      v14 = is_fade;
    if (!v14)
      goto LABEL_13;
  }
  else if (BYTE1(v24))
  {
LABEL_13:
    v12 = operator new();
    RB::DisplayList::Interpolator::Layer::Layer(v12, &v17);
    goto LABEL_14;
  }
  if (HIBYTE(v24) || (*(_BYTE *)(a4 + 61) & 4) != 0)
    goto LABEL_13;
  v12 = 0;
LABEL_14:
  v16[0] = v9;
  v16[1] = v12;
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int>,RB::DisplayList::Interpolator::Layer*>>(v8, (unsigned int *)v16, v16);
  if (v22)
    free(v22);
  if (v19)
    free(v19);
  return v12;
}

void sub_209B0E064(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  va_list va;

  va_start(va, a4);
  RB::DisplayList::Interpolator::Layer::~Layer((RB::DisplayList::Interpolator::Layer *)va);
  _Unwind_Resume(a1);
}

RB::DisplayList::Layer *RB::DisplayList::Layer::mix(RB::DisplayList::Layer *this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer *a3, RB::DisplayList::Builder **a4)
{
  uint64_t v8;
  uint64_t v9;
  RB::DisplayList::Layer *v10;
  const RB::DisplayList::Item *v11;
  float v12;
  float v13;
  RB::DisplayList::Layer *v14;
  float v15;
  const RB::DisplayList::Item **v16;
  float v17;
  uint64_t v18;
  float64x2_t v19;
  __int128 v20;
  _QWORD *v21;
  uint64_t *v22;
  double v23;
  double v24;
  RB::DisplayList *v25;
  __int128 v27;
  const RB::AffineTransform *v28;
  _OWORD v29[3];
  __int128 v30[2];
  uint64_t v31;
  uint64_t v32;
  float64x2_t v33[80];
  _BYTE v34[80];
  _QWORD v35[15];

  v35[14] = *MEMORY[0x24BDAC8D0];
  v8 = RB::DisplayList::Layer::copy(this, *a4, 1u);
  v10 = (RB::DisplayList::Layer *)v8;
  v11 = (const RB::DisplayList::Item *)*((_QWORD *)a2 + 4);
  v12 = *(float *)(v8 + 48);
  v13 = *((float *)a3 + 12);
  if (v12 != 0.0 || v13 != 0.0)
  {
    if (v12 == 0.0)
      v15 = 1.0;
    else
      v15 = *(float *)(v8 + 48);
    if (v13 == 0.0)
      v17 = 1.0;
    else
      v17 = *((float *)a3 + 12);
    if (v15 == v17)
    {
      v14 = 0;
      v16 = (const RB::DisplayList::Item **)a3;
      if (!v11)
        goto LABEL_13;
    }
    else
    {
      v14 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(a3, *a4, 4u);
      *(_QWORD *)&v27 = 0;
      *((double *)&v27 + 1) = (float)(v15 / v17);
      v30[0] = *((unint64_t *)&v27 + 1);
      v30[1] = v27;
      v31 = 0;
      v32 = 0;
      RB::DisplayList::CachedTransform::CachedTransform((uint64_t)v33, (uint64_t)*a4, v30, 0, 0, 0);
      RB::DisplayList::Layer::apply_transform_(v14, (const RB::DisplayList::CachedTransform *)v33);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v35);
      RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v34);
      RB::Heap::~Heap((RB::Heap *)&v33[0].f64[1]);
      *((_DWORD *)v14 + 12) = 1065353216;
      v16 = (const RB::DisplayList::Item **)v14;
      if (!*((_QWORD *)a2 + 4))
        goto LABEL_13;
    }
    MEMORY[0x24BDAC7A8](v8, v9);
    v11 = (const RB::DisplayList::Item *)v29;
    v19 = vmulq_n_f64(*(float64x2_t *)(v18 + 16), v15);
    v20 = *(_OWORD *)(v18 + 32);
    v29[0] = vmulq_n_f64(*(float64x2_t *)v18, v15);
    v29[1] = v19;
    v29[2] = v20;
    goto LABEL_13;
  }
  v14 = 0;
  v15 = 1.0;
  v16 = (const RB::DisplayList::Item **)a3;
LABEL_13:
  RB::DisplayList::CachedTransform::CachedTransform((RB::DisplayList::CachedTransform *)v33, (float64x2_t *)a4, 1.0, v15, 0);
  v21 = (_QWORD *)(*(_QWORD *)a2 + 32);
  *(_QWORD *)&v30[0] = *((unsigned int *)this + 14) | ((unint64_t)*((unsigned int *)a3 + 14) << 32);
  v22 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v21, (unsigned int *)v30);
  if (v22)
  {
    v25 = (RB::DisplayList *)v22[3];
    if (v25)
    {
      LODWORD(v23) = *((_DWORD *)a2 + 5);
      LODWORD(v24) = 1.0;
      RB::DisplayList::apply_interpolator(v25, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), v23, *(_DWORD *)(*((_QWORD *)a2 + 1) + 32), v10, v33, v24, 0, *(const RB::Rect **)this, *v16, v11, v28);
    }
  }
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v35);
  RB::UntypedTable::~UntypedTable((RB::UntypedTable *)v34);
  RB::Heap::~Heap((RB::Heap *)&v33[0].f64[1]);
  if (v14)
    RB::DisplayList::Layer::~Layer(v14);
  return v10;
}

void sub_209B0E300(_Unwind_Exception *a1)
{
  uint64_t v1;
  RB::DisplayList::Layer *v2;

  RB::DisplayList::CachedTransform::~CachedTransform((RB::DisplayList::CachedTransform *)(v1 + 48));
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  _Unwind_Resume(a1);
}

void RB::DisplayList::CachedTransform::~CachedTransform(RB::DisplayList::CachedTransform *this)
{
  RB::UntypedTable::~UntypedTable((RB::DisplayList::CachedTransform *)((char *)this + 1368));
  RB::UntypedTable::~UntypedTable((RB::DisplayList::CachedTransform *)((char *)this + 1288));
  RB::Heap::~Heap((RB::DisplayList::CachedTransform *)((char *)this + 8));
}

uint64_t RB::DisplayList::LayerItem::prepare_mix(RB::DisplayList::LayerItem *this, RB::DisplayList::Interpolator::Contents *a2, RB::DisplayList::Interpolator::Op *a3, const RB::DisplayList::Item *a4)
{
  uint64_t result;
  const RB::DisplayList::Style *v9;
  const RB::DisplayList::Item *v10;
  unsigned __int8 v11;
  int v12;
  uint64_t v13;
  const RB::Animation *animation;
  const RB::Animation *v15;

  result = (*(uint64_t (**)(const RB::DisplayList::Item *))(*(_QWORD *)a4 + 16))(a4);
  if (!(_DWORD)result)
  {
    result = RB::DisplayList::Item::may_mix(this, a2, a4, v9);
    if ((_BYTE)result)
    {
      v11 = result;
      v12 = *((_DWORD *)a2 + 4);
      v13 = *((_QWORD *)a2 + 1);
      animation = (const RB::Animation *)RB::DisplayList::find_animation(this, a4, v10);
      if (animation)
      {
        v15 = animation;
        *((_DWORD *)a2 + 4) = RB::DisplayList::Interpolator::Contents::intern_animation(a2, animation);
        *((_QWORD *)a2 + 1) = v15;
      }
      result = RB::DisplayList::Layer::can_mix(*((_QWORD *)this + 6), (uint64_t)a2, *((_QWORD *)a4 + 6), v11);
      if ((_BYTE)result)
        result = (uint64_t)RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, result);
      *((_DWORD *)a2 + 4) = v12;
      *((_QWORD *)a2 + 1) = v13;
    }
  }
  return result;
}

double RB::DisplayList::LayerItem::mix(RB::DisplayList::Layer **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer **a3, RB::DisplayList::Builder **a4)
{
  size_t *v8;
  int v21;
  __int16 v22;
  RB::DisplayList::Layer *v23;

  v23 = RB::DisplayList::Layer::mix(this[6], a2, a3[6], a4);
  v8 = (size_t *)(*((_QWORD *)*a4 + 1) + 16);
  _H0 = *((_WORD *)this + 22);
  _H1 = *((_WORD *)a3 + 22);
  _S2 = *((_DWORD *)a2 + 4);
  __asm
  {
    FCVT            H2, S2
    FCVT            S0, H0
    FCVT            S1, H1
    FCVT            S2, H2
  }
  _S0 = _S0 + (float)((float)(_S1 - _S0) * _S2);
  __asm { FCVT            H0, S0 }
  v22 = LOWORD(_S0);
  v21 = *((_WORD *)this + 23) & 0x3F;
  return _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(v8, &v22, &v21, (uint64_t *)&v23);
}

double _ZN2RB4Heap7emplaceINS_11DisplayList9LayerItemEJRDF16_RKNS_9BlendModeERPNS2_5LayerEEEEPT_DpOT0_(size_t *a1, __int16 *a2, _DWORD *a3, uint64_t *a4)
{
  uint64_t v7;
  double result;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v7 + 56;
  _H0 = *a2;
  __asm { FCVT            S0, H0 }
  *(_QWORD *)&result = RB::DisplayList::LayerItem::LayerItem(v7, *a3, *a4, _S0);
  return result;
}

uint64_t RB::DisplayList::LayerItem::mix_bounds(RB::DisplayList::LayerItem *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, float32x2_t *a4, const RB::DisplayList::Item *a5)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  double v13;
  double v14;
  double v15;
  int32x4_t v16;
  RB::DisplayList *v17;
  const RB::DisplayList::Item *v18;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  float32x2_t v24;
  float32x2_t v25;
  unint64_t v26;

  v10 = *(unsigned int *)(*((_QWORD *)this + 6) + 56);
  v11 = (_QWORD *)(*(_QWORD *)a2 + 32);
  v26 = v10 | ((unint64_t)*(unsigned int *)(*((_QWORD *)a5 + 6) + 56) << 32);
  v12 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v11, (unsigned int *)&v26);
  if (v12
    && (v17 = (RB::DisplayList *)v12[3]) != 0
    && !RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)v12[3]))
  {
    v20 = *((_QWORD *)this + 6);
    v21 = *(float *)(v20 + 48);
    v22 = 1.0;
    if (v21 == 0.0)
      v21 = 1.0;
    v23 = *((_QWORD *)a5 + 6);
    if (*(float *)(v23 + 48) != 0.0)
      v22 = *(float *)(v23 + 48);
    if (v21 != v22)
      return 0;
    RB::DisplayList::interpolated_bounds(v17, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), *((float *)a2 + 5), *(_QWORD *)v20, *(float32x2_t ***)v23, v18);
    *a3 = v24;
    a3[1] = v25;
  }
  else
  {
    RB::Rect::Union(a3, *a4, a4[1], v13, v14, v15, v16);
  }
  return 1;
}

uint64_t RB::DisplayList::LayerItem::atom_position(RB::DisplayList::LayerItem *this, int a2)
{
  uint64_t v2;
  _QWORD *v4;
  float32x2_t v5;
  float32x2_t v6;
  char v7;
  uint32x2_t v8;
  int32x2_t v9;

  v2 = 0;
  if (!a2)
  {
    v4 = (_QWORD *)**((_QWORD **)this + 6);
    if (v4)
    {
      v5 = (float32x2_t)vdup_n_s32(0x7F800000u);
      do
      {
        v6 = (float32x2_t)(*(uint64_t (**)(_QWORD *, _QWORD))(*v4 + 56))(v4, 0);
        if (v7)
          v5 = vminnm_f32(v5, v6);
        v4 = (_QWORD *)v4[1];
      }
      while (v4);
      v8 = (uint32x2_t)vbic_s8(vorr_s8((int8x8_t)vcltz_f32(v5), (int8x8_t)vcgez_f32(v5)), (int8x8_t)vceq_f32(vabs_f32(v5), (float32x2_t)vdup_n_s32(0x7F800000u)));
      v9 = (int32x2_t)vpmin_u32(v8, v8);
      if (v9.i32[0] < 0)
      {
        v9.i32[0] = *(_DWORD *)(*((_QWORD *)this + 6) + 48);
        if (*(float *)v9.i32 == 0.0)
          return (uint64_t)v5;
        else
          return (uint64_t)vdiv_f32(v5, (float32x2_t)vdup_lane_s32(v9, 0));
      }
    }
  }
  return v2;
}

uint64_t RB::DisplayList::LayerClip::can_mix(RB::DisplayList::LayerClip *this, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Clip *a3)
{
  float v3;
  float v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*((unsigned __int8 *)this + 44) != *((unsigned __int8 *)a3 + 44))
    return 0;
  v3 = *((float *)this + 14);
  v4 = *((float *)a3 + 14);
  v5 = *((_QWORD *)this + 6);
  v6 = *((_QWORD *)a3 + 6);
  if (v3 == v4)
    v7 = 4;
  else
    v7 = 2;
  return RB::DisplayList::Layer::can_mix(v5, (uint64_t)a2, v6, v7);
}

uint64_t RB::DisplayList::LayerClip::mix(RB::DisplayList::Layer **this, const RB::DisplayList::Interpolator::State *a2, const RB::DisplayList::Layer **a3, RB::DisplayList::Builder **a4)
{
  size_t *v8;
  unsigned int v10;
  float v11;
  RB::DisplayList::Layer *v12;

  v12 = RB::DisplayList::Layer::mix(this[6], a2, a3[6], a4);
  v11 = *((float *)this + 14) + (float)((float)(*((float *)a3 + 14) - *((float *)this + 14)) * *((float *)a2 + 4));
  v8 = (size_t *)(*((_QWORD *)*a4 + 1) + 16);
  v10 = *((char *)this + 44);
  return RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(v8, &v12, &v11, &v10);
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float &,RB::ClipMode const&>(size_t *a1, _QWORD *a2, float *a3, unsigned int *a4)
{
  unint64_t v7;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 64 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x40uLL, 7);
  else
    a1[2] = v7 + 64;
  return RB::DisplayList::LayerClip::LayerClip(v7, *a2, *a4, *a3);
}

uint64_t RB::DisplayList::LayerClip::mix_bounds(RB::DisplayList::LayerClip *this, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, float32x2_t *a4, const RB::DisplayList::Clip *a5)
{
  uint64_t v10;
  _QWORD *v11;
  uint64_t *v12;
  double v13;
  double v14;
  double v15;
  int32x4_t v16;
  RB::DisplayList *v17;
  const RB::DisplayList::Item *v18;
  uint64_t v20;
  float v21;
  float v22;
  uint64_t v23;
  float32x2_t v24;
  float32x2_t v25;
  unint64_t v26;

  v10 = *(unsigned int *)(*((_QWORD *)this + 6) + 56);
  v11 = (_QWORD *)(*(_QWORD *)a2 + 32);
  v26 = v10 | ((unint64_t)*(unsigned int *)(*((_QWORD *)a5 + 6) + 56) << 32);
  v12 = std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(v11, (unsigned int *)&v26);
  if (v12
    && (v17 = (RB::DisplayList *)v12[3]) != 0
    && !RB::DisplayList::Interpolator::Layer::is_fade((RB::DisplayList::Interpolator::Layer *)v12[3]))
  {
    v20 = *((_QWORD *)this + 6);
    v21 = *(float *)(v20 + 48);
    v22 = 1.0;
    if (v21 == 0.0)
      v21 = 1.0;
    v23 = *((_QWORD *)a5 + 6);
    if (*(float *)(v23 + 48) != 0.0)
      v22 = *(float *)(v23 + 48);
    if (v21 != v22)
      return 0;
    RB::DisplayList::interpolated_bounds(v17, (const RB::DisplayList::Interpolator::Layer *)*((unsigned __int8 *)a2 + 28), *((float *)a2 + 5), *(_QWORD *)v20, *(float32x2_t ***)v23, v18);
    *a3 = v24;
    a3[1] = v25;
  }
  else
  {
    RB::Rect::Union(a3, *a4, a4[1], v13, v14, v15, v16);
  }
  return 1;
}

uint64_t RB::DisplayList::Clip::can_mix()
{
  return 0;
}

float RB::DisplayList::Clip::cg_alpha(RB::DisplayList::Clip *this)
{
  return 1.0;
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,float &>(size_t *a1, float *a2)
{
  unint64_t v3;

  v3 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v3 + 96 > a1[3])
    v3 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v3 + 96;
  *(_QWORD *)(v3 + 48) = 0;
  *(_OWORD *)(v3 + 16) = 0u;
  *(_OWORD *)(v3 + 32) = 0u;
  *(_QWORD *)v3 = &off_24C224628;
  RB::Filter::GaussianBlur::GaussianBlur(v3 + 56, *a2, 0, 0, 0);
  return v3;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::~FilterStyle(uint64_t a1)
{
  void (***v2)(_QWORD);

  v2 = *(void (****)(_QWORD))(a1 + 88);
  *(_QWORD *)(a1 + 88) = 0;
  if (v2)
    (**v2)(v2);
  return a1;
}

void RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::~FilterStyle(uint64_t a1)
{
  void (***v2)(_QWORD);

  v2 = *(void (****)(_QWORD))(a1 + 88);
  *(_QWORD *)(a1 + 88) = 0;
  if (v2)
    (**v2)(v2);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::type_id()
{
  return 20482;
}

unint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::copy(uint64_t a1, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 56), a2);
}

RB::DisplayList::Builder *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::draw(float *a1, RB::DisplayList::Builder *this, RB::DisplayList::Layer *a3, RB::DisplayList::Item *a4, char a5)
{
  float64x2_t *v10;
  const RB::DisplayList::ClipNode *v11;
  RB::DisplayList::LayerFilter *v12;
  RB::DisplayList::Builder *result;

  if (a1[14] <= 0.0
    || (v10 = (float64x2_t *)*((_QWORD *)a1 + 2),
        v11 = (const RB::DisplayList::ClipNode *)*((_QWORD *)a1 + 3),
        v12 = (RB::DisplayList::LayerFilter *)RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)this + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 14), this), result = RB::DisplayList::Builder::apply_filter_(this, a4, v12, v10, v11), (a4 = result) != 0))
  {
    *((_QWORD *)a4 + 2) = *((_QWORD *)a1 + 4);
    return RB::DisplayList::Builder::draw(this, a4, a3, a5);
  }
  return result;
}

double RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::map_roi(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  RB::Filter::GaussianBlur *v4;
  int32x4_t v5;

  v4 = (RB::Filter::GaussianBlur *)(a1 + 56);
  RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
  return RB::Filter::GaussianBlur::dod(v4, this, v5);
}

double RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::map_dod(uint64_t a1, float32x2_t *this, float64x2_t *a3)
{
  RB::Filter::GaussianBlur *v4;
  int32x4_t v5;

  v4 = (RB::Filter::GaussianBlur *)(a1 + 56);
  RB::Rect::move(this, a3, *(float64x2_t **)(a1 + 16));
  return RB::Filter::GaussianBlur::dod(v4, this, v5);
}

uint64_t RB::DisplayList::Style::matches(RB::DisplayList::Style *this, const Predicate *a2)
{
  return 0;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::can_mix(float32x2_t *a1, RB::DisplayList::Interpolator::Contents *a2, float32x2_t *a3)
{
  float32x2_t *v3;
  float32x2_t *v4;

  v3 = a1 + 7;
  if (a3)
    v4 = a3 + 7;
  else
    v4 = 0;
  return RB::Filter::GaussianBlur::can_mix(v3, a2, v4);
}

float32x2_t *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::mix(uint64_t a1, const RB::DisplayList::Interpolator::State *a2, float32x2_t *a3, RB::DisplayList::Builder **a4)
{
  float32x2_t *v7;
  float32x2_t *v8;

  v7 = (float32x2_t *)RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)*a4 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 56), *a4);
  if (a3)
    v8 = a3 + 7;
  else
    v8 = 0;
  RB::Filter::GaussianBlur::mix(v7 + 7, a2, v8, (const RB::DisplayList::CachedTransform *)a4);
  return v7;
}

uint64_t RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::prepare_encode(RB::DisplayList::Style *a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::prepare_encode(a1, a2);
  return RB::Filter::GaussianBlur::prepare_encode((uint64_t)a1 + 56);
}

_QWORD *RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Style::encode((_QWORD *)a1, a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x32uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ProtobufEncoder::encode_varint(a2, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Filter::GaussianBlur::encode((int *)(a1 + 56), a2);
  RB::ProtobufEncoder::end_length_delimited(a2);
  return RB::ProtobufEncoder::end_length_delimited(a2);
}

void RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "filter");
  RB::Filter::GaussianBlur::print((RB::Filter::GaussianBlur *)(a1 + 7), this);
  RB::DisplayList::Style::print(a1, this);
  RB::SexpString::pop(this);
}

unint64_t RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>(size_t *a1, RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  unint64_t v5;

  v5 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v5 + 96 > a1[3])
    v5 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v5 + 96;
  *(_QWORD *)(v5 + 48) = 0;
  *(_OWORD *)(v5 + 16) = 0u;
  *(_OWORD *)(v5 + 32) = 0u;
  *(_QWORD *)v5 = &off_24C224628;
  RB::Filter::GaussianBlur::GaussianBlur((RB::Filter::GaussianBlur *)(v5 + 56), a2, a3);
  return v5;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>(size_t *a1, RB::Filter::GaussianBlur *a2, RB::DisplayList::Builder *a3)
{
  _QWORD *v5;

  v5 = (_QWORD *)((a1[2] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(v5 + 9) > a1[3])
    v5 = (_QWORD *)RB::Heap::alloc_slow(a1, 0x48uLL, 7);
  else
    a1[2] = (size_t)(v5 + 9);
  v5[2] = 0;
  v5[3] = 0;
  *v5 = &off_24C227B08;
  RB::Filter::GaussianBlur::GaussianBlur((RB::Filter::GaussianBlur *)(v5 + 4), a2, a3);
  return v5;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::~GenericFilter(uint64_t a1)
{
  void (***v2)(_QWORD);

  v2 = *(void (****)(_QWORD))(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v2)
    (**v2)(v2);
  return a1;
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::~GenericFilter(uint64_t a1)
{
  void (***v2)(_QWORD);

  v2 = *(void (****)(_QWORD))(a1 + 64);
  *(_QWORD *)(a1 + 64) = 0;
  if (v2)
    (**v2)(v2);
  JUMPOUT(0x20BD16544);
}

_QWORD *RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::copy(uint64_t a1, RB::DisplayList::Builder *a2)
{
  return RB::Heap::emplace<RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur const&,RB::DisplayList::Builder &>((size_t *)(*((_QWORD *)a2 + 1) + 16), (RB::Filter::GaussianBlur *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::apply_transform(float32x2_t *a1, float64x2_t *a2)
{
  return RB::Filter::GaussianBlur::apply_transform(a1 + 4, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::append(uint64_t a1, int a2, uint64_t a3)
{
  return RB::Filter::GaussianBlur::append(a1 + 32, a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::filter_data()
{
  return 5;
}

double RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::roi(uint64_t a1, float32x2_t *a2, int32x4_t a3)
{
  return RB::Filter::GaussianBlur::dod((RB::Filter::GaussianBlur *)(a1 + 32), a2, a3);
}

double RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::dod(uint64_t a1, float32x2_t *a2, int32x4_t a3)
{
  return RB::Filter::GaussianBlur::dod((RB::Filter::GaussianBlur *)(a1 + 32), a2, a3);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::commutes_with_clip(uint64_t a1)
{
  return RB::Filter::GaussianBlur::commutes_with_clip((RB::Filter::GaussianBlur *)(a1 + 32));
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::required_depth(uint64_t a1, unsigned int a2)
{
  return RB::Filter::GaussianBlur::required_depth(a1 + 32, a2);
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::can_discard_color()
{
  return 1;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::can_render_inline()
{
  return 0;
}

uint64_t RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::prepare(uint64_t a1)
{
  return RB::Filter::GaussianBlur::prepare(a1 + 32);
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::render(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4, int32x2_t a5)
{
  RB::Filter::GaussianBlur::render(a1 + 32, a2, a3, a4, a5);
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::render(uint64_t a1, float64x2_t *a2, CFTypeRef *a3)
{
  RB::Filter::GaussianBlur::render(a1 + 32, a2, a3);
}

void RB::DisplayList::GenericFilter<RB::Filter::GaussianBlur>::print(uint64_t a1, std::string *a2)
{
  RB::Filter::GaussianBlur::print((RB::Filter::GaussianBlur *)(a1 + 32), a2);
}

uint64_t RB::DisplayList::CachedTransform::CachedTransform(uint64_t a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t a5, int a6)
{
  RB::Heap *v11;
  __int128 v12;
  __int128 v13;

  *(_QWORD *)a1 = a2;
  v11 = (RB::Heap *)(a1 + 8);
  RB::Heap::Heap((RB::Heap *)(a1 + 8), (char *)(a1 + 48), 1024, 0);
  *(_QWORD *)(a1 + 1072) = a4;
  *(_QWORD *)(a1 + 1080) = a5;
  v12 = *a3;
  v13 = a3[1];
  *(_OWORD *)(a1 + 1120) = a3[2];
  *(_OWORD *)(a1 + 1104) = v13;
  *(_OWORD *)(a1 + 1088) = v12;
  *(_QWORD *)(a1 + 1136) = 0;
  *(_DWORD *)(a1 + 1144) = a6;
  *(_QWORD *)(a1 + 1148) = 0;
  *(_OWORD *)(a1 + 1168) = 0u;
  *(_OWORD *)(a1 + 1184) = 0u;
  *(int64x2_t *)(a1 + 1200) = vdupq_n_s64(0x7FF8000000000000uLL);
  *(_QWORD *)(a1 + 1216) = 0;
  *(_OWORD *)(a1 + 1232) = 0u;
  *(_QWORD *)(a1 + 1248) = 1;
  *(_OWORD *)(a1 + 1256) = 0u;
  *(_OWORD *)(a1 + 1272) = 0u;
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 1288), 0, 0, 0, 0, v11);
  RB::UntypedTable::UntypedTable((RB::UntypedTable *)(a1 + 1368), 0, 0, 0, 0, v11);
  *(_QWORD *)(a1 + 1448) = 0;
  *(_BYTE *)(a1 + 1456) = 0;
  return a1;
}

void sub_209B0EFE4(_Unwind_Exception *a1)
{
  RB::Heap *v1;
  RB::UntypedTable *v2;

  RB::UntypedTable::~UntypedTable(v2);
  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::find<std::pair<unsigned int,unsigned int>>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = a2[1];
  v5 = 33 * v3 + v4;
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 33 * v3 + v4;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v5;
  }
  v8 = *(uint64_t ***)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (result = *v8; result; result = (uint64_t *)*result)
  {
    v10 = result[1];
    if (v5 == v10)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3 && *((_DWORD *)result + 5) == (_DWORD)v4)
        return result;
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return result;
}

{
  int8x8_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  uint64_t **v8;
  uint64_t *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = a2[1];
  v5 = 33 * v3 + v4;
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = 33 * v3 + v4;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = (*(_QWORD *)&v2 - 1) & v5;
  }
  v8 = *(uint64_t ***)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  for (result = *v8; result; result = (uint64_t *)*result)
  {
    v10 = result[1];
    if (v10 == v5)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3 && *((_DWORD *)result + 5) == (_DWORD)v4)
        return result;
    }
    else
    {
      if (v6.u32[0] > 1uLL)
      {
        if (v10 >= *(_QWORD *)&v2)
          v10 %= *(_QWORD *)&v2;
      }
      else
      {
        v10 &= *(_QWORD *)&v2 - 1;
      }
      if (v10 != v7)
        return 0;
    }
  }
  return result;
}

void *RB::vector<RB::DisplayList::Item const*,32ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 34) + (*((_QWORD *)__dst + 34) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 32), __dst, 0x20uLL, (size_t *)__dst + 34, v3);
  *((_QWORD *)__dst + 32) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,8ul>(void *__src, void *__dst, size_t a3, size_t *a4, size_t a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 8 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(8 * a5);
    v9 = v8 >> 3;
    if (v8 >> 3 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 8 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

RB::DisplayList::Builder *RB::DisplayList::apply_interpolator(RB::DisplayList::Interpolator::Layer const&,float,BOOL,unsigned int,RB::DisplayList::Layer &,float,RB::DisplayList::CachedTransform &,RB::Rect const*,RB::DisplayList::Item const*,RB::DisplayList::Item const*,RB::AffineTransform const*)::$_2::operator()(RB::DisplayList::Builder *result, uint64_t a2, RB::DisplayList::Item *a3, RB::DisplayList::Item *this, uint64_t a5)
{
  uint64_t v8;
  RB::AffineTransform *v10;
  RB::AffineTransform *v11;
  __int128 *v12;
  uint64_t v13;
  RB::DisplayList::Layer **v14;
  float v15;
  RB::DisplayList::Layer **v16;
  float v17;
  RB::DisplayList::Layer **v18;
  RB::DisplayList::Item *v19;

  v8 = (uint64_t)result;
  v19 = a3;
  if (a3 && this)
  {
    if (RB::may_discard_alpha(*((_WORD *)a3 + 23) & 0x3F))
    {
      _ZN2RB4Heap7emplaceINS_11DisplayList14CrossFadeStyleEJRPNS2_4ItemERfRDF16_EEEPT_DpOT0_((RB::Heap *)(*(_QWORD *)(a5 + 8) + 16), (uint64_t *)&v19, (float *)(a2 + 16), (__int16 *)this + 22);
      v11 = v10;
      v12 = RB::AffineTransform::identity(v10);
      v13 = *(_QWORD *)(a5 + 8);
      *((_QWORD *)v11 + 1) = *(_QWORD *)(v13 + 312);
      *((_QWORD *)v11 + 2) = v12;
      *(_QWORD *)(v13 + 312) = v11;
      *((_DWORD *)v11 + 13) |= 1u;
      *((_QWORD *)v11 + 4) = *((_QWORD *)this + 2);
      *((_QWORD *)this + 2) = v11;
      v14 = *(RB::DisplayList::Layer ***)v8;
      RB::DisplayList::Item::apply_alpha((uint64_t)this, *((float *)v14 + 4));
      return RB::DisplayList::Builder::draw(v14[1], this, *v14, 0);
    }
    goto LABEL_6;
  }
  if (a3)
  {
LABEL_6:
    v15 = 1.0 - *(float *)(a2 + 16);
    if (v15 < 0.0)
      v15 = 0.0;
    if (v15 > 1.0)
      v15 = 1.0;
    RB::DisplayList::Item::apply_alpha((uint64_t)a3, v15);
    v16 = *(RB::DisplayList::Layer ***)v8;
    RB::DisplayList::Item::apply_alpha((uint64_t)a3, *(float *)(*(_QWORD *)v8 + 16));
    result = RB::DisplayList::Builder::draw(v16[1], a3, *v16, 0);
  }
  if (this)
  {
    v17 = *(float *)(a2 + 16);
    if (v17 < 0.0)
      v17 = 0.0;
    if (v17 > 1.0)
      v17 = 1.0;
    RB::DisplayList::Item::apply_alpha((uint64_t)this, v17);
    v18 = *(RB::DisplayList::Layer ***)v8;
    RB::DisplayList::Item::apply_alpha((uint64_t)this, *((float *)v18 + 4));
    return RB::DisplayList::Builder::draw(v18[1], this, *v18, 0);
  }
  return result;
}

void _ZZZN2RB11DisplayList18apply_interpolatorERKNS0_12Interpolator5LayerEfbjRNS0_5LayerEfRNS0_15CachedTransformEPKNS_4RectEPKNS0_4ItemESE_PKNS_15AffineTransformEENK3__3clINS_6vectorISE_Lm32EmEESL_EEDaRNS1_5StateERNS0_13AtomizedItemsESQ_RKT_RKT0_ENKUljjST_E_clISL_EESM_jjST_(RB::DisplayList::Builder ***a1, unsigned int a2, unsigned int a3, uint64_t a4)
{
  int v7;
  uint64_t v8;
  RB::DisplayList::Layer *layer;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  float32x2_t *v13;
  double v14;
  float32x2_t v15;
  double v16;
  double v17;
  double v18;
  int32x4_t v19;
  RB::DisplayList::Item *v20;
  size_t *v21;
  uint64_t v22;
  int v23;
  int v24;
  RB::DisplayList::Layer *v25;

  v25 = 0;
  if (a3)
  {
    v7 = 0;
    v8 = 0;
    layer = 0;
    v10 = a3;
    do
    {
      v11 = *(_QWORD *)(a4 + 256);
      if (!v11)
        v11 = a4;
      v12 = *(_QWORD *)(v11 + 8 * a2);
      v13 = (float32x2_t *)a1[1];
      if (!v13
        || (v14 = RB::DisplayList::Item::clipped_bounds(*(float32x2_t ***)(v11 + 8 * a2)),
            RB::Rect::intersects(v13, *(float32x2_t *)&v14, v15, v16, v17, v18, v19)))
      {
        v20 = (RB::DisplayList::Item *)(*(uint64_t (**)(uint64_t, RB::DisplayList::Builder *, _QWORD))(*(_QWORD *)v12 + 24))(v12, **a1, 0);
        (*(void (**)(RB::DisplayList::Item *, RB::DisplayList::Builder **, uint64_t))(*(_QWORD *)v20 + 32))(v20, *a1, 1);
        if (!layer)
        {
          layer = (RB::DisplayList::Layer *)RB::DisplayList::Builder::make_layer(**a1, 0);
          v25 = layer;
          v7 = *((_DWORD *)v20 + 10);
          v8 = *((_QWORD *)v20 + 4);
        }
        *((_QWORD *)v20 + 4) = 0;
        *((_DWORD *)v20 + 10) = 0;
        RB::DisplayList::Builder::draw(**a1, v20, layer, 0);
      }
      ++a2;
      --v10;
    }
    while (v10);
    if (layer)
    {
      v21 = (size_t *)(*((_QWORD *)**a1 + 1) + 16);
      v23 = 2;
      v24 = 1;
      RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(v21, &v24, &v23, (uint64_t *)&v25);
      if (v22)
      {
        *(_DWORD *)(v22 + 40) = v7;
        *(_QWORD *)(v22 + 32) = v8;
      }
    }
  }
}

float _ZN2RB4Heap7emplaceINS_11DisplayList14CrossFadeStyleEJRPNS2_4ItemERfRDF16_EEEPT_DpOT0_(RB::Heap *this, uint64_t *a2, float *a3, __int16 *a4)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  float result;

  v8 = *((_QWORD *)this + 3);
  v9 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v9 + 72 > v8)
    v9 = RB::Heap::alloc_slow((size_t *)this, 0x48uLL, 7);
  else
    *((_QWORD *)this + 2) = v9 + 72;
  v10 = *a2;
  result = *a3;
  _H1 = *a4;
  __asm { FCVT            S1, H1 }
  *(_OWORD *)(v9 + 16) = 0u;
  *(_OWORD *)(v9 + 32) = 0u;
  *(_QWORD *)v9 = &off_24C227D78;
  *(_QWORD *)(v9 + 48) = 0;
  *(_QWORD *)(v9 + 56) = v10;
  *(float *)(v9 + 64) = result;
  *(_DWORD *)(v9 + 68) = _S1;
  return result;
}

double RB::Heap::emplace<RB::DisplayList::LayerItem,int,RB::BlendMode,RB::DisplayList::Layer *&>(size_t *a1, int *a2, _DWORD *a3, uint64_t *a4)
{
  uint64_t v7;
  double result;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v7 + 56;
  *(_QWORD *)&result = RB::DisplayList::LayerItem::LayerItem(v7, *a3, *a4, (float)*a2);
  return result;
}

void RB::DisplayList::Interpolator::Layer::~Layer(RB::DisplayList::Interpolator::Layer *this)
{
  void *v2;
  void *v3;

  v2 = (void *)*((_QWORD *)this + 29);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 22);
  if (v3)
    free(v3);
}

uint64_t RB::DisplayList::Interpolator::Layer::Layer(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  int v5;

  v4 = *a2;
  *(_DWORD *)(a1 + 8) = *((_DWORD *)a2 + 2);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + 176) = 0;
  *(_QWORD *)(a1 + 184) = 0x400000000;
  *(_QWORD *)(a1 + 176) = a2[22];
  a2[22] = 0;
  *(_DWORD *)(a1 + 184) = *((_DWORD *)a2 + 46);
  *((_DWORD *)a2 + 46) = 0;
  LODWORD(v4) = *(_DWORD *)(a1 + 188);
  *(_DWORD *)(a1 + 188) = *((_DWORD *)a2 + 47);
  *((_DWORD *)a2 + 47) = v4;
  RB::vector<RB::DisplayList::Interpolator::Op,4ul,unsigned int>::swap_inline((__int128 *)(a1 + 16), (__int128 *)a2 + 1);
  *(_DWORD *)(a1 + 192) = *((_DWORD *)a2 + 48);
  *(_QWORD *)(a1 + 232) = 0;
  *(_QWORD *)(a1 + 240) = 0x200000000;
  *(_QWORD *)(a1 + 232) = a2[29];
  a2[29] = 0;
  *(_DWORD *)(a1 + 240) = *((_DWORD *)a2 + 60);
  *((_DWORD *)a2 + 60) = 0;
  v5 = *(_DWORD *)(a1 + 244);
  *(_DWORD *)(a1 + 244) = *((_DWORD *)a2 + 61);
  *((_DWORD *)a2 + 61) = v5;
  RB::vector<RB::Rect,2ul,unsigned int>::swap_inline((__int128 *)(a1 + 200), (__int128 *)(a2 + 25));
  *(_DWORD *)(a1 + 248) = *((_DWORD *)a2 + 62);
  return a1;
}

void sub_209B0F764(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;
  void *v4;

  v3 = *(void **)(v1 + 232);
  if (v3)
    free(v3);
  v4 = *(void **)(v1 + 176);
  if (v4)
    free(v4);
  _Unwind_Resume(exception_object);
}

__int128 *RB::vector<RB::DisplayList::Interpolator::Op,4ul,unsigned int>::swap_inline(__int128 *result, __int128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v2 = *((_QWORD *)a2 + 20);
  v3 = *((_QWORD *)result + 20);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
  {
    v18 = a2[6];
    v19 = a2[7];
    v20 = a2[8];
    v21 = a2[9];
    v14 = a2[2];
    v15 = a2[3];
    v16 = a2[4];
    v17 = a2[5];
    v12 = *a2;
    v13 = a2[1];
    v5 = result[1];
    *a2 = *result;
    a2[1] = v5;
    v6 = result[2];
    v7 = result[3];
    v8 = result[5];
    a2[4] = result[4];
    a2[5] = v8;
    a2[2] = v6;
    a2[3] = v7;
    v9 = result[6];
    v10 = result[7];
    v11 = result[9];
    a2[8] = result[8];
    a2[9] = v11;
    a2[6] = v9;
    a2[7] = v10;
    result[6] = v18;
    result[7] = v19;
    result[8] = v20;
    result[9] = v21;
    result[2] = v14;
    result[3] = v15;
    result[4] = v16;
    result[5] = v17;
    *result = v12;
    result[1] = v13;
    if (v3)
    {
      if (v2)
        return result;
    }
    else
    {
      *((_QWORD *)result + 20) = 0;
      if (v2)
        return result;
    }
    *((_QWORD *)a2 + 20) = 0;
  }
  return result;
}

__int128 *RB::vector<RB::Rect,2ul,unsigned int>::swap_inline(__int128 *result, __int128 *a2)
{
  uint64_t v2;
  uint64_t v3;
  BOOL v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;

  v2 = *((_QWORD *)a2 + 4);
  v3 = *((_QWORD *)result + 4);
  if (v2)
    v4 = v3 == 0;
  else
    v4 = 1;
  if (v4)
  {
    v6 = *a2;
    v5 = a2[1];
    v7 = result[1];
    *a2 = *result;
    a2[1] = v7;
    *result = v6;
    result[1] = v5;
    if (v3)
    {
      if (v2)
        return result;
    }
    else
    {
      *((_QWORD *)result + 4) = 0;
      if (v2)
        return result;
    }
    *((_QWORD *)a2 + 4) = 0;
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__emplace_unique_key_args<std::pair<unsigned int,unsigned int>,std::pair<std::pair<unsigned int,unsigned int>,RB::DisplayList::Interpolator::Layer*>>(uint64_t a1, unsigned int *a2, _QWORD *a3)
{
  unint64_t v3;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  void **v11;
  _QWORD *v12;
  unint64_t v13;
  _QWORD *v15;
  uint64_t v16;
  float v17;
  float v18;
  _BOOL8 v19;
  unint64_t v20;
  unint64_t v21;
  size_t v22;
  uint64_t v23;
  _QWORD *v24;
  unint64_t v25;

  v6 = *a2;
  v7 = a2[1];
  v8 = 33 * v6 + v7;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = 33 * v6 + v7;
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
    v11 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == v8)
          {
            if (*((_DWORD *)v12 + 4) == (_DWORD)v6 && *((_DWORD *)v12 + 5) == (_DWORD)v7)
              return v12;
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9)
                v13 %= v9;
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v8;
  v16 = a3[1];
  v12[2] = *a3;
  v12[3] = v16;
  v17 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v18 = *(float *)(a1 + 32);
  if (!v9 || (float)(v18 * (float)v9) < v17)
  {
    v19 = 1;
    if (v9 >= 3)
      v19 = (v9 & (v9 - 1)) != 0;
    v20 = v19 | (2 * v9);
    v21 = vcvtps_u32_f32(v17 / v18);
    if (v20 <= v21)
      v22 = v21;
    else
      v22 = v20;
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v22);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = (v9 - 1) & v8;
    }
  }
  v23 = *(_QWORD *)a1;
  v24 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v24)
  {
    *v12 = *v24;
LABEL_42:
    *v24 = v12;
    goto LABEL_43;
  }
  *v12 = *v15;
  *v15 = v12;
  *(_QWORD *)(v23 + 8 * v3) = v15;
  if (*v12)
  {
    v25 = *(_QWORD *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v25 >= v9)
        v25 %= v9;
    }
    else
    {
      v25 &= v9 - 1;
    }
    v24 = (_QWORD *)(*(_QWORD *)a1 + 8 * v25);
    goto LABEL_42;
  }
LABEL_43:
  ++*(_QWORD *)(a1 + 24);
  return v12;
}

void sub_209B0FB2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  char *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,void *>>>::operator()[abi:nn180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,void *>>>::operator()[abi:nn180100](uint64_t a1, char *__p)
{
  char *v3;
  uint64_t v4;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = __p + 24;
    v4 = *((_QWORD *)__p + 3);
    *((_QWORD *)__p + 3) = 0;
    if (v4)
      std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100]((uint64_t)v3, v4);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

void std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  if (a2)
  {
    v3 = *(void **)(a2 + 232);
    if (v3)
      free(v3);
    v4 = *(void **)(a2 + 176);
    if (v4)
      free(v4);
    JUMPOUT(0x20BD16544);
  }
}

uint64_t RB::JSONPipeline::make_pipeline_set(RB::Device *a1, unint64_t a2)
{
  unint64_t v2;
  uint64_t **i;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  id v12[3];
  id v13[4];

  RB::JSONPipeline::JSONPipeline((RB::JSONPipeline *)v13);
  for (i = *(uint64_t ***)(a2 + 16); i; i = (uint64_t **)*i)
  {
    v6 = (uint64_t)i[2];
    v7 = *((unsigned int *)i + 6);
    v8 = (void *)objc_opt_new();
    RB::JSONPipelineData::JSONPipelineData((RB::JSONPipelineData *)v12);
    v9 = (uint64_t *)RB::Device::library(a1);
    v2 = v2 & 0xFFFFFFFF00000000 | v7;
    RB::Device::make_render_pipeline_descriptor(v6, v2, v9, 0, v8, (uint64_t)v12, 0);
    a2 = a2 & 0xFFFFFFFF00000000 | v7;
    RB::JSONPipeline::add_pipeline_state(v13, v6, a2, v8, (uint64_t)v12);

  }
  v10 = RB::JSONPipeline::finalize((RB::JSONPipeline *)v13);

  return v10;
}

void sub_209B0FD00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, ...)
{
  va_list va;

  va_start(va, a5);
  RB::JSONPipeline::~JSONPipeline((id *)va);
  _Unwind_Resume(a1);
}

void RB::JSONPipeline::add_pipeline_state(void **a1, char a2, __int16 a3, void *a4, uint64_t a5)
{
  id v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  MTLPixelFormat v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t v22;
  int v23;
  const __CFString *v24;
  uint64_t v25;
  void *v26;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  void *v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  RB::JSONPipeline *v37;
  id v39;
  id v40;
  id v41;
  _QWORD v42[4];
  _QWORD v43[4];
  _QWORD v44[4];
  _QWORD v45[4];
  char v46[256];
  uint64_t v47;

  v47 = *MEMORY[0x24BDAC8D0];
  v9 = *(id *)a5;
  if (!*(_QWORD *)a5)
  {
LABEL_7:
    v39 = 0;
    goto LABEL_8;
  }
  v10 = (void *)objc_msgSend(*(id *)a5, "specializedName");
  v11 = v10;
  if (!v10)
  {
    v13 = (void *)objc_msgSend(v9, "name");
    if (v13)
    {

      v39 = v13;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
  snprintf_l(v46, 0x100uLL, 0, "alias:%s#%s", (const char *)objc_msgSend(v10, "UTF8String"), (const char *)objc_msgSend(v10, "UTF8String"));
  v39 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithUTF8String:", v46);

  if ((objc_msgSend(a1[2], "containsObject:") & 1) == 0)
  {
    objc_msgSend(a1[2], "addObject:");
    v12 = *a1;
    v45[0] = v11;
    v44[0] = CFSTR("label");
    v44[1] = CFSTR("function");
    v45[1] = objc_msgSend(v9, "name");
    v45[2] = v11;
    v44[2] = CFSTR("specialized_name");
    v44[3] = CFSTR("constant_values");
    v45[3] = *(_QWORD *)(a5 + 16);
    objc_msgSend(v12, "addObject:", objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v45, v44, 4));
  }
LABEL_8:
  v14 = *(void **)(a5 + 8);
  if (!v14)
  {
LABEL_14:
    v40 = 0;
    goto LABEL_15;
  }
  v15 = (void *)objc_msgSend(*(id *)(a5 + 8), "specializedName");
  v16 = v15;
  if (!v15)
  {
    v18 = (void *)objc_msgSend(v14, "name");
    if (v18)
    {

      v40 = v18;
      goto LABEL_15;
    }
    goto LABEL_14;
  }
  snprintf_l(v46, 0x100uLL, 0, "alias:%s#%s", (const char *)objc_msgSend(v15, "UTF8String"), (const char *)objc_msgSend(v15, "UTF8String"));
  v40 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithUTF8String:", v46);

  if ((objc_msgSend(a1[3], "containsObject:") & 1) == 0)
  {
    objc_msgSend(a1[3], "addObject:");
    v17 = *a1;
    v43[0] = v16;
    v42[0] = CFSTR("label");
    v42[1] = CFSTR("function");
    v43[1] = objc_msgSend(v14, "name");
    v43[2] = v16;
    v42[2] = CFSTR("specialized_name");
    v42[3] = CFSTR("constant_values");
    v43[3] = *(_QWORD *)(a5 + 16);
    objc_msgSend(v17, "addObject:", objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v43, v42, 4));
  }
LABEL_15:
  v41 = (id)objc_opt_new();
  v20 = *((unsigned __int8 *)RB::pixel_format_traits(a3 & 0x3FF, v19) + 7);
  v21 = a2 & 0x3F;
  if (v21 > 0x1F)
  {
    if (v21 == 32)
    {
LABEL_22:
      if (v20 <= 4)
        v20 = 4;
      else
        v20 = v20;
      goto LABEL_31;
    }
    if (v21 != 33)
      goto LABEL_25;
    v22 = 4;
LABEL_33:
    if ((_DWORD)v20)
    {
      v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", CFSTR("supportsFamily(apple%d) && !supportsFamily(apple%d)"), v20, v22);
      goto LABEL_35;
    }
    v24 = CFSTR("!supportsFamily(apple%d)");
LABEL_32:
    v25 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithFormat:", v24, v22);
LABEL_35:
    objc_msgSend(v41, "setObject:forKeyedSubscript:", v25, CFSTR("enable"));
    goto LABEL_36;
  }
  if ((a2 & 0x3F) == 0)
  {
    v23 = objc_msgSend(a4, "supportAddingFragmentBinaryFunctions");
    v22 = 6;
    if (v23)
    {
      if (v20 <= 6)
        v20 = 6;
      else
        v20 = v20;
      goto LABEL_31;
    }
    goto LABEL_33;
  }
  if (v21 == 1)
    goto LABEL_22;
LABEL_25:
  if ((_DWORD)v20)
  {
LABEL_31:
    v24 = CFSTR("supportsFamily(apple%d)");
    v22 = v20;
    goto LABEL_32;
  }
LABEL_36:
  objc_msgSend(v41, "setObject:forKeyedSubscript:", v39, CFSTR("vertex_function"));
  if (v40)
    objc_msgSend(v41, "setObject:forKeyedSubscript:", v40, CFSTR("fragment_function"));
  v26 = (void *)objc_opt_new();
  v27 = 0;
  v28 = MEMORY[0x24BDBD1B8];
  do
  {
    v29 = (void *)objc_msgSend((id)objc_msgSend(a4, "colorAttachments"), "objectAtIndexedSubscript:", v27);
    if (objc_msgSend(v29, "pixelFormat"))
    {
      v30 = (void *)objc_opt_new();
      while (objc_msgSend(v26, "count") < v27)
        objc_msgSend(v26, "addObject:", v28);
      objc_msgSend(v29, "pixelFormat");
      objc_msgSend(v30, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", MTLPixelFormatGetName() + 14), CFSTR("pixel_format"));
      if (objc_msgSend(v29, "isBlendingEnabled"))
      {
        objc_msgSend(v30, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", objc_msgSend(v29, "isBlendingEnabled")), CFSTR("blending_enabled"));
        v31 = objc_msgSend(v29, "sourceRGBBlendFactor");
        if (v31 > 8)
          goto LABEL_65;
        objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v31), CFSTR("source_rgb_blend_factor"));
        v32 = objc_msgSend(v29, "destinationRGBBlendFactor");
        if (v32 > 8)
          goto LABEL_65;
        objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v32), CFSTR("destination_rgb_blend_factor"));
        v33 = objc_msgSend(v29, "rgbBlendOperation");
        if (v33 > 4
          || (objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_operation_name(MTLBlendOperation)const::names + v33), CFSTR("rgb_blend_operation")), v34 = objc_msgSend(v29, "sourceAlphaBlendFactor"), v34 > 8)|| (objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v34), CFSTR("source_alpha_blend_factor")), v35 = objc_msgSend(v29, "destinationAlphaBlendFactor"), v35 > 8)|| (objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_factor_name(MTLBlendFactor)const::names + v35), CFSTR("destination_alpha_blend_factor")), v36 = objc_msgSend(v29, "alphaBlendOperation"),
              v36 >= 5))
        {
LABEL_65:
          abort();
        }
        objc_msgSend(v30, "setObject:forKeyedSubscript:", *((_QWORD *)&RB::JSONPipeline::blend_operation_name(MTLBlendOperation)const::names + v36), CFSTR("alpha_blend_operation"));
      }
      if (objc_msgSend(v29, "writeMask") != 15)
      {
        v37 = (RB::JSONPipeline *)objc_msgSend(v29, "writeMask");
        objc_msgSend(v30, "setObject:forKeyedSubscript:", RB::JSONPipeline::color_write_mask_name(v37, (uint64_t)v37), CFSTR("write_mask"));
      }
      objc_msgSend(v26, "addObject:", v30);

    }
    ++v27;
  }
  while (v27 != 8);
  objc_msgSend(v41, "setObject:forKeyedSubscript:", v26, CFSTR("color_attachments"));
  if (objc_msgSend(a4, "stencilAttachmentPixelFormat"))
  {
    objc_msgSend(a4, "stencilAttachmentPixelFormat");
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", MTLPixelFormatGetName() + 14), CFSTR("stencil_attachment_pixel_format"));
  }
  if (objc_msgSend(a4, "depthAttachmentPixelFormat"))
  {
    objc_msgSend(a4, "depthAttachmentPixelFormat");
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", MTLPixelFormatGetName() + 14), CFSTR("depth_attachment_pixel_format"));
  }
  if (objc_msgSend(a4, "supportAddingFragmentBinaryFunctions"))
    objc_msgSend(v41, "setObject:forKeyedSubscript:", MEMORY[0x24BDBD1C8], CFSTR("support_adding_fragment_binary_functions"));
  if (objc_msgSend(a4, "maxFragmentCallStackDepth") != 1)
    objc_msgSend(v41, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInteger:", objc_msgSend(a4, "maxFragmentCallStackDepth")), CFSTR("max_fragment_call_stack_depth"));
  objc_msgSend(a1[1], "addObject:", v41);

}

void sub_209B104A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, id a13, id a14)
{

  _Unwind_Resume(a1);
}

void RB::JSONPipelineData::~JSONPipelineData(id *this)
{

}

uint64_t RB::JSONPipeline::finalize(RB::JSONPipeline *this)
{
  uint64_t v2;
  const __CFString *v4;
  uint64_t v5;
  const __CFString *v6;
  uint64_t v7;
  _QWORD v8[2];
  _QWORD v9[3];

  v9[2] = *MEMORY[0x24BDAC8D0];
  v6 = CFSTR("specialized_functions");
  v7 = *(_QWORD *)this;
  v8[0] = CFSTR("libraries");
  v9[0] = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v7, &v6, 1);
  v8[1] = CFSTR("pipelines");
  v2 = *((_QWORD *)this + 1);
  v4 = CFSTR("render_pipelines");
  v5 = v2;
  v9[1] = objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v5, &v4, 1);
  return objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v9, v8, 2);
}

void RB::JSONPipeline::~JSONPipeline(id *this)
{

}

RB::JSONPipeline *RB::JSONPipeline::JSONPipeline(RB::JSONPipeline *this)
{
  *(_QWORD *)this = objc_opt_new();
  *((_QWORD *)this + 1) = objc_opt_new();
  *((_QWORD *)this + 2) = objc_opt_new();
  *((_QWORD *)this + 3) = objc_opt_new();
  return this;
}

void sub_209B106D8(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

const __CFString *RB::JSONPipeline::color_write_mask_name(RB::JSONPipeline *this, uint64_t a2)
{
  char v2;
  void *v3;
  void *v4;

  if (!a2)
    return CFSTR("None");
  v2 = a2;
  if (a2 == 15)
    return CFSTR("All");
  v4 = (void *)objc_msgSend(MEMORY[0x24BDD16A8], "string");
  v3 = v4;
  if ((v2 & 8) != 0)
  {
    if (objc_msgSend(v4, "length"))
      objc_msgSend(v3, "appendString:", CFSTR(" "));
    objc_msgSend(v3, "appendString:", CFSTR("Red"));
    if ((v2 & 4) == 0)
    {
LABEL_7:
      if ((v2 & 2) == 0)
        goto LABEL_8;
      goto LABEL_16;
    }
  }
  else if ((v2 & 4) == 0)
  {
    goto LABEL_7;
  }
  if (objc_msgSend(v3, "length"))
    objc_msgSend(v3, "appendString:", CFSTR(" "));
  objc_msgSend(v3, "appendString:", CFSTR("Green"));
  if ((v2 & 2) == 0)
  {
LABEL_8:
    if ((v2 & 1) == 0)
      return (const __CFString *)v3;
    goto LABEL_19;
  }
LABEL_16:
  if (objc_msgSend(v3, "length"))
    objc_msgSend(v3, "appendString:", CFSTR(" "));
  objc_msgSend(v3, "appendString:", CFSTR("Blue"));
  if ((v2 & 1) != 0)
  {
LABEL_19:
    if (objc_msgSend(v3, "length"))
      objc_msgSend(v3, "appendString:", CFSTR(" "));
    objc_msgSend(v3, "appendString:", CFSTR("Alpha"));
  }
  return (const __CFString *)v3;
}

RB::JSONPipelineData *RB::JSONPipelineData::JSONPipelineData(RB::JSONPipelineData *this)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_QWORD *)this + 2) = objc_opt_new();
  return this;
}

void sub_209B10864(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void RB::JSONPipelineData::set_const(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  void *v8;
  void *v9;
  const __CFString *v10;
  uint64_t v11;
  const __CFString *v12;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  v8 = (void *)objc_opt_new();
  v9 = v8;
  if (a3 != 36)
    abort();
  objc_msgSend(v8, "setObject:forKeyedSubscript:", CFSTR("FunctionConstantIndex"), CFSTR("id_type"));
  v12 = CFSTR("data");
  v13[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithInt:", a2);
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v13, &v12, 1), CFSTR("id"));
  objc_msgSend(v9, "setObject:forKeyedSubscript:", CFSTR("ConstantUInt4"), CFSTR("value_type"));
  v10 = CFSTR("data");
  v11 = a4;
  objc_msgSend(v9, "setObject:forKeyedSubscript:", objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", &v11, &v10, 1), CFSTR("value"));
  objc_msgSend(*(id *)(a1 + 16), "addObject:", v9);

}

void sub_209B109C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

float64x2_t CG::Cubic::Cubic(CG::Cubic *this, const Point *a2, const Point *a3, const Point *a4, const Point *a5)
{
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t result;

  *(_OWORD *)this = *(_OWORD *)&a2->v;
  *((_OWORD *)this + 1) = *(_OWORD *)&a3->v;
  *((_OWORD *)this + 2) = *(_OWORD *)&a4->v;
  *((_OWORD *)this + 3) = *(_OWORD *)&a5->v;
  v5 = *((float64x2_t *)this + 1);
  v6 = vsubq_f64(v5, *(float64x2_t *)this);
  *((double *)this + 8) = 3.0 * v6.f64[0];
  *((double *)this + 9) = vmuld_lane_f64(3.0, v6, 1);
  v7 = *((float64x2_t *)this + 2);
  v8 = *((float64x2_t *)this + 3);
  v9 = vsubq_f64(v7, v5);
  v10 = vsubq_f64(v9, v6);
  *((double *)this + 10) = 3.0 * v10.f64[0];
  *((double *)this + 11) = vmuld_lane_f64(3.0, v10, 1);
  result = vaddq_f64(vsubq_f64(vsubq_f64(v6, v7), vaddq_f64(v9, v9)), v8);
  *((float64x2_t *)this + 6) = result;
  return result;
}

double CG::Cubic::evaluate(float64x2_t *this, double a2)
{
  double result;

  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(*this, vmlaq_n_f64(this[4], vmlaq_n_f64(this[5], this[6], a2), a2), a2);
  return result;
}

double CG::Cubic::derivative(CG::Cubic *this, double a2)
{
  double result;

  if (a2 == 0.0)
    return CG::Cubic::tangent_at_0(this);
  if (a2 == 1.0)
    return CG::Cubic::tangent_at_1(this);
  __asm { FMOV            V3.2D, #2.0 }
  *(_QWORD *)&result = *(_OWORD *)&vmlaq_n_f64(*((float64x2_t *)this + 4), vmlaq_f64(vmulq_n_f64(*((float64x2_t *)this + 6), a2 * 3.0), _Q3, *((float64x2_t *)this + 5)), a2);
  return result;
}

double CG::Cubic::tangent_at_0(CG::Cubic *this)
{
  double v1;
  double v2;
  double result;

  v1 = *(double *)this;
  v2 = *((double *)this + 1);
  result = *((double *)this + 2) - *(double *)this;
  if (result * result + (*((double *)this + 3) - v2) * (*((double *)this + 3) - v2) <= 0.00000001)
  {
    result = *((double *)this + 4) - v1;
    if (result * result + (*((double *)this + 5) - v2) * (*((double *)this + 5) - v2) <= 0.00000001)
      return *((double *)this + 6) - v1;
  }
  return result;
}

double CG::Cubic::tangent_at_1(CG::Cubic *this)
{
  double v1;
  double v2;
  double result;

  v1 = *((double *)this + 6);
  v2 = *((double *)this + 7);
  result = v1 - *((double *)this + 4);
  if (result * result + (v2 - *((double *)this + 5)) * (v2 - *((double *)this + 5)) <= 0.00000001)
  {
    result = v1 - *((double *)this + 2);
    if (result * result + (v2 - *((double *)this + 3)) * (v2 - *((double *)this + 3)) <= 0.00000001)
      return v1 - *(double *)this;
  }
  return result;
}

double cube::length(cube *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v27;
  double v28;
  _QWORD v30[320];

  v30[319] = *MEMORY[0x24BDAC8D0];
  v10 = (a4 - a2) * (a4 - a2) + (a5 - a3) * (a5 - a3);
  v11 = (a8 - a6) * (a8 - a6) + (a9 - a7) * (a9 - a7);
  v12 = 3.40282347e38;
  v13 = 3.40282347e38;
  if (v10 > 0.0)
    v13 = 1.0 / sqrt(v10);
  v14 = v13 * v10;
  if (v11 > 0.0)
    v12 = 1.0 / sqrt(v11);
  v15 = v12 * v11;
  v16 = fabs(v12 * v11 + v14);
  v17 = 0.0;
  if (v16 <= 0x7FEFFFFFFFFFFFFFLL)
  {
    LODWORD(v18) = 0;
    v19 = 1024;
    v20 = 1.0;
    do
    {
      v21 = (a7 - a5) * (a7 - a5) + (a6 - a4) * (a6 - a4);
      v22 = 3.40282347e38;
      if (v21 > 0.0)
        v22 = 1.0 / sqrt(v21);
      v23 = (a9 - a3) * (a9 - a3) + (a8 - a2) * (a8 - a2);
      v24 = 3.40282347e38;
      if (v23 > 0.0)
        v24 = 1.0 / sqrt(v23);
      v25 = v15 + v14 + v22 * v21;
      if (v25 - v24 * v23 > v20 * a10 && (int)v18 < 29)
      {
        v20 = v20 * 0.5;
        *(double *)&v30[(int)v18] = v20;
        *(double *)&v30[(int)v18 + 203] = a8;
        *(double *)&v30[(int)v18 + 29] = a9;
        *(double *)&v30[(int)v18 + 232] = (a8 + a6) * 0.5;
        *(double *)&v30[(int)v18 + 58] = (a9 + a7) * 0.5;
        *(double *)&v30[(int)v18 + 261] = (a8 + a6 * 2.0 + a4) * 0.25;
        *(double *)&v30[(int)v18 + 87] = (a9 + a7 * 2.0 + a5) * 0.25;
        a8 = (a8 + (a4 + a6) * 3.0 + a2) * 0.125;
        *(double *)&v30[(int)v18 + 290] = a8;
        a9 = (a9 + (a5 + a7) * 3.0 + a3) * 0.125;
        *(double *)&v30[(int)v18 + 116] = a9;
        a6 = (a6 + a4 * 2.0 + a2) * 0.25;
        *(double *)&v30[(int)v18 + 145] = v15 * 0.5;
        a7 = (a7 + a5 * 2.0 + a3) * 0.25;
        v27 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
        if (v27 <= 0.0)
          v28 = 3.40282347e38;
        else
          v28 = 1.0 / sqrt(v27);
        a4 = (a2 + a4) * 0.5;
        a5 = (a3 + a5) * 0.5;
        v14 = v14 * 0.5;
        v15 = v28 * v27;
        *(double *)&v30[(int)v18 + 174] = v15;
        LODWORD(v18) = v18 + 1;
      }
      else
      {
        v17 = v17 + (v24 * v23 + v25) * 0.5;
        if (!(_DWORD)v18)
          return v17;
        v18 = (int)v18 - 1;
        a2 = *(double *)&v30[v18 + 290];
        a3 = *(double *)&v30[v18 + 116];
        a4 = *(double *)&v30[v18 + 261];
        a5 = *(double *)&v30[v18 + 87];
        a6 = *(double *)&v30[v18 + 232];
        a7 = *(double *)&v30[v18 + 58];
        a8 = *(double *)&v30[v18 + 203];
        a9 = *(double *)&v30[v18 + 29];
        v14 = *(double *)&v30[v18 + 174];
        v15 = *(double *)&v30[v18 + 145];
        v20 = *(double *)&v30[v18];
      }
      --v19;
    }
    while (v19);
    return 1.0;
  }
  return v17;
}

double cube::index(cube *this, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10, double a11)
{
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  BOOL v30;
  double v31;
  double v32;
  double v33;
  double v34;
  _QWORD v36[320];

  v36[319] = *MEMORY[0x24BDAC8D0];
  v11 = 0.0;
  if (a10 != 0.0)
  {
    v12 = (a4 - a2) * (a4 - a2) + (a5 - a3) * (a5 - a3);
    v13 = (a8 - a6) * (a8 - a6) + (a9 - a7) * (a9 - a7);
    v14 = 3.40282347e38;
    v15 = 3.40282347e38;
    if (v12 > 0.0)
      v15 = 1.0 / sqrt(v12);
    v16 = v15 * v12;
    if (v13 > 0.0)
      v14 = 1.0 / sqrt(v13);
    v17 = v14 * v13;
    if (COERCE_UNSIGNED_INT64(fabs(v14 * v13 + v16)) <= 0x7FEFFFFFFFFFFFFFLL)
    {
      LODWORD(v18) = 0;
      v19 = 1024;
      v20 = 1.0;
      v21 = 0.0;
      while (1)
      {
        v22 = (a7 - a5) * (a7 - a5) + (a6 - a4) * (a6 - a4);
        v23 = 3.40282347e38;
        if (v22 > 0.0)
          v23 = 1.0 / sqrt(v22);
        v24 = (a9 - a3) * (a9 - a3) + (a8 - a2) * (a8 - a2);
        v25 = 3.40282347e38;
        if (v24 > 0.0)
          v25 = 1.0 / sqrt(v24);
        v26 = v23 * v22;
        v27 = v25 * v24;
        v28 = v17 + v16 + v26;
        if ((int)v18 > 28
          || ((v29 = vabdd_f64(v16, v26) + vabdd_f64(v26, v17), v28 - v27 <= v20 * a11) ? (v30 = v29 < a11) : (v30 = 0),
              v30))
        {
          v33 = (v27 + v28) * 0.5;
          v34 = v33 + v21;
          if (v33 + v21 >= a10)
            return fmin(v20 * (a10 - v21) / v33 + v11, 1.0);
          if (!(_DWORD)v18)
            return 1.0;
          v18 = (int)v18 - 1;
          a2 = *(double *)&v36[v18 + 290];
          v11 = v20 + v11;
          a3 = *(double *)&v36[v18 + 116];
          a4 = *(double *)&v36[v18 + 261];
          a5 = *(double *)&v36[v18 + 87];
          a6 = *(double *)&v36[v18 + 232];
          a7 = *(double *)&v36[v18 + 58];
          a8 = *(double *)&v36[v18 + 203];
          a9 = *(double *)&v36[v18 + 29];
          v16 = *(double *)&v36[v18 + 174];
          v21 = v34;
          v17 = *(double *)&v36[v18 + 145];
          v20 = *(double *)&v36[v18];
        }
        else
        {
          v20 = v20 * 0.5;
          *(double *)&v36[(int)v18] = v20;
          *(double *)&v36[(int)v18 + 203] = a8;
          *(double *)&v36[(int)v18 + 29] = a9;
          *(double *)&v36[(int)v18 + 232] = (a8 + a6) * 0.5;
          *(double *)&v36[(int)v18 + 58] = (a9 + a7) * 0.5;
          *(double *)&v36[(int)v18 + 261] = (a8 + a6 * 2.0 + a4) * 0.25;
          *(double *)&v36[(int)v18 + 87] = (a5 + a7 * 2.0 + a9) * 0.25;
          a8 = (a8 + (a4 + a6) * 3.0 + a2) * 0.125;
          *(double *)&v36[(int)v18 + 290] = a8;
          a9 = (a9 + (a7 + a5) * 3.0 + a3) * 0.125;
          *(double *)&v36[(int)v18 + 116] = a9;
          a6 = (a6 + a4 * 2.0 + a2) * 0.25;
          *(double *)&v36[(int)v18 + 145] = v17 * 0.5;
          a7 = (a7 + a5 * 2.0 + a3) * 0.25;
          v31 = (a9 - a7) * (a9 - a7) + (a8 - a6) * (a8 - a6);
          if (v31 <= 0.0)
            v32 = 3.40282347e38;
          else
            v32 = 1.0 / sqrt(v31);
          a4 = (a2 + a4) * 0.5;
          a5 = (a3 + a5) * 0.5;
          v16 = v16 * 0.5;
          v17 = v32 * v31;
          *(double *)&v36[(int)v18 + 174] = v17;
          LODWORD(v18) = v18 + 1;
        }
        if (!--v19)
          return 1.0;
      }
    }
  }
  return v11;
}

double CG::Cubic::length(CG::Cubic *this, double a2)
{
  return cube::length(this, *(double *)this, *((double *)this + 1), *((double *)this + 2), *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6), *((double *)this + 7), a2);
}

double CG::Cubic::index(CG::Cubic *this, double a2, double a3)
{
  return cube::index(this, *(double *)this, *((double *)this + 1), *((double *)this + 2), *((double *)this + 3), *((double *)this + 4), *((double *)this + 5), *((double *)this + 6), *((double *)this + 7), a2, a3);
}

float64x2_t CG::Cubic::split@<Q0>(float64x2_t *this@<X0>, double a2@<D0>, float64x2_t *a3@<X8>)
{
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t result;

  v4 = *this;
  v3 = this[1];
  v5 = vmulq_n_f64(vsubq_f64(v3, *this), a2);
  v6 = vaddq_f64(v5, *this);
  v7 = this[2];
  v8 = this[3];
  v9 = vmlaq_n_f64(v3, vsubq_f64(v7, v3), a2);
  v10 = vmlaq_n_f64(v7, vsubq_f64(v8, v7), a2);
  v11 = vmulq_n_f64(vsubq_f64(v9, v6), a2);
  v12 = vaddq_f64(v11, v6);
  v13 = vmlaq_n_f64(v9, vsubq_f64(v10, v9), a2);
  a3[1] = v6;
  a3[2] = v12;
  v14 = vsubq_f64(v5, v12);
  v15 = vmlaq_n_f64(v12, vsubq_f64(v13, v12), a2);
  *a3 = v4;
  __asm { FMOV            V0.2D, #3.0 }
  a3[3] = v15;
  a3[4] = vmulq_f64(v5, _Q0);
  a3[5] = vmulq_f64(vsubq_f64(v11, v5), _Q0);
  a3[6] = vaddq_f64(vsubq_f64(v14, vaddq_f64(v11, v11)), v15);
  a3[7] = v15;
  a3[8] = v13;
  a3[9] = v10;
  a3[10] = v8;
  v21 = vsubq_f64(v13, v15);
  v22 = vsubq_f64(v10, v13);
  a3[11] = vmulq_f64(v21, _Q0);
  a3[12] = vmulq_f64(vsubq_f64(v22, v21), _Q0);
  result = vaddq_f64(vsubq_f64(vsubq_f64(v8, v10), vaddq_f64(v22, v22)), v21);
  a3[13] = result;
  return result;
}

double CG::Cubic::inflection_points_classic(CG::Cubic *this)
{
  double v1;
  double v2;
  double v3;
  double v4;
  BOOL v5;
  BOOL v6;
  char v7;
  double result;
  double v9;
  double v10;
  double v11;
  double v12;
  BOOL v13;
  BOOL v14;
  double v15;

  v1 = *((double *)this + 12);
  if (v1 == 0.0
    || ((v2 = *((double *)this + 10), v3 = v1 * 3.0, v4 = -v2, v2 < 0.0) ? (v5 = v3 <= v4) : (v5 = 1),
        v5 && (v2 > 0.0 ? (v6 = v3 < v4) : (v6 = 0), !v6)))
  {
    v7 = 1;
    result = -1.0;
  }
  else
  {
    v7 = 0;
    result = v4 / v3;
  }
  v9 = *((double *)this + 13);
  if (v9 != 0.0)
  {
    v10 = *((double *)this + 11);
    v11 = v9 * 3.0;
    v12 = -v10;
    v13 = v10 >= 0.0 || v11 <= v12;
    if (!v13 || (v10 > 0.0 ? (v14 = v11 < v12) : (v14 = 0), v14))
    {
      v15 = v12 / v11;
      if ((v7 & 1) != 0)
      {
        return v15;
      }
      else if (vabdd_f64(result, v15) >= 0.000001 && result >= v15)
      {
        return v15;
      }
    }
  }
  return result;
}

uint64_t CG::Cubic::is_near(float64x2_t *this, const Point *a2, double a3, double a4)
{
  double v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  double v15;
  uint64_t result;
  float64x2_t v17;
  unsigned __int8 v18;
  unint64_t v19;
  double v20;
  double v21;
  double v22;
  float64x2_t v23;
  double v24;
  double v25;
  float64x2_t v26;
  float64x2_t v27;
  double v28;
  double v29;
  float64x2_t v30;
  float64x2_t v31;
  double v32;
  double v33;
  double v34;
  int v35;
  double v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  double v41;
  double v42;

  v4 = a4 * a4;
  v5 = this[4];
  v6 = this[5];
  v7 = this[6];
  v8 = vsubq_f64(*this, *(float64x2_t *)&a2->v);
  v9 = vmlaq_f64(v8, (float64x2_t)0, vmlaq_f64(v5, (float64x2_t)0, vmlaq_f64(v6, (float64x2_t)0, v7)));
  v10 = vmulq_f64(v9, v9);
  if (vaddvq_f64(v10) < a4 * a4)
    return 1;
  v11 = vaddq_f64(vaddq_f64(v5, v8), vaddq_f64(v6, v7));
  v12 = vmulq_f64(v11, v11);
  if (vaddvq_f64(v12) < v4)
    return 1;
  v13 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, a3), a3), a3);
  v14 = vmulq_f64(v13, v13);
  v15 = vaddvq_f64(v14);
  if (v15 < v4)
    return 1;
  v17 = vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v14, 1), v14);
  if ((vmovn_s64((int64x2_t)vbicq_s8(vmvnq_s8((int8x16_t)vcgeq_f64(v17, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1), v10))), (int8x16_t)vcgeq_f64(v17, vaddq_f64((float64x2_t)vdupq_laneq_s64((int64x2_t)v12, 1), v12)))).u8[0] & 1) == 0)return 0;
  v19 = 0x253EAE000uLL;
  if ((v18 & 1) == 0)
  {
    v41 = v15;
    v42 = v4;
    v40 = this[4];
    v38 = this[6];
    v39 = this[5];
    v36 = a3;
    v37 = v8;
    a3 = v36;
    v8 = v37;
    v7 = v38;
    v6 = v39;
    v5 = v40;
    v19 = 0x253EAE000uLL;
    v15 = v41;
    v4 = v42;
    if (v35)
    {
      CG::Cubic::is_near(CG::Point const&,double,double)const::G = 0x3FE3C6EF372FE950;
      a3 = v36;
      v8 = v37;
      v7 = v38;
      v6 = v39;
      v5 = v40;
      v19 = 0x253EAE000;
      v15 = v41;
      v4 = v42;
    }
  }
  v20 = *(double *)(v19 + 3720);
  v21 = 1.0 - v20;
  if (a3 <= 0.5)
  {
    v22 = a3;
    v25 = a3 + v21 * (1.0 - a3);
    v26 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v25), v25), v25);
    v27 = vmulq_f64(v26, v26);
    v24 = v15;
    v15 = vaddvq_f64(v27);
    a3 = v25;
    if (v15 >= v4)
      goto LABEL_12;
    return 1;
  }
  v22 = a3 - v21 * a3;
  v23 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v22), v22), v22);
  v24 = vaddvq_f64(vmulq_f64(v23, v23));
  if (v24 < v4)
    return 1;
LABEL_12:
  v28 = 1.0;
  if ((a3 + v22) * 0.00000003 >= 1.0)
    return 0;
  v29 = 0.0;
  result = 0;
  do
  {
    if (v15 >= v24)
    {
      v28 = a3;
      v31 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v29 + v20 * (v22 - v29)), v29 + v20 * (v22 - v29)), v29 + v20 * (v22 - v29));
      v15 = vaddvq_f64(vmulq_f64(v31, v31));
      a3 = v29 + v20 * (v22 - v29);
      if (v15 <= v4)
        return 1;
    }
    else
    {
      v29 = v22;
      v22 = v28 + v20 * (a3 - v28);
      v30 = vmlaq_n_f64(v8, vmlaq_n_f64(v5, vmlaq_n_f64(v6, v7, v22), v22), v22);
      v24 = vaddvq_f64(vmulq_f64(v30, v30));
      if (v24 <= v4)
        return 1;
    }
    v32 = v15;
    v33 = a3;
    v34 = (v22 + a3) * 0.00000003;
    v15 = v24;
    v24 = v32;
    a3 = v22;
    v22 = v33;
  }
  while (v28 - v29 > v34);
  return result;
}

void RBShapeData::~RBShapeData(RBShapeData *this)
{
  RBShapeData::apply<RB::DestroyAny>(&this->type);
  this->type = 0;
}

uint64_t RBShapeData::set_rendering_mode(uint64_t result, char a2)
{
  uint64_t v2;

  v2 = result;
  switch(*(_DWORD *)result)
  {
    case 1:
      result = RB::Coverage::Primitive::set_rendering_mode(result + 16, a2);
      break;
    case 2:
      *(_BYTE *)(result + 45) = a2;
      break;
    case 3:
      result = rb_clip_mode(a2);
      *(_BYTE *)(v2 + 92) = result;
      break;
    case 5:
      result = rb_clip_mode(a2);
      *(_BYTE *)(v2 + 52) = result;
      break;
    default:
      return result;
  }
  return result;
}

id *RBStrokeRef::map(id *result, uint64_t a2, uint64_t (**a3)(_QWORD), float64x2_t a4, float32x2_t a5, float32x2_t a6, uint64_t a7, float64x2_t *a8)
{
  id *v13;
  float64x2_t v14;
  float64x2_t *v15;
  float64x2_t v16;
  float64x2_t v17;
  float32x2_t v18;
  float v19;
  float32x2_t v20;
  uint64_t v21;
  float v22;
  float v23;
  id v24;
  double v25;
  float32x2_t v26;
  char v27;
  char v28;
  float v29;
  float v30;
  float v31;
  float32x2_t v32;
  float32x2_t v33;
  float64x2_t v34;
  double v35;
  float32x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;

  if (*result)
  {
    v13 = result;
    v34 = a4;
    v14 = a8[1];
    v37 = *a8;
    v38 = v14;
    v39 = a8[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v37))
      v15 = &v37;
    else
      v15 = a8;
    v16 = v15[1];
    v17 = v15[2];
    v37 = *v15;
    v38 = v16;
    v39 = v17;
    v35 = COERCE_DOUBLE(RB::operator*(&v37, a5, a6));
    v36 = v18;
    objc_msgSend(*v13, "borderWidth");
    v20.f32[0] = -v19;
    RB::Rect::inset((float32x2_t *)&v35, v20, v20.f32[0]);
    v21 = objc_opt_respondsToSelector();
    v22 = 1.0;
    if ((v21 & 1) != 0)
    {
      v21 = objc_msgSend(*v13, "maxLineWidth", *(_OWORD *)&v34);
      v22 = v23;
    }
    v24 = *v13;
    v25 = v35;
    v26 = v36;
    v27 = *(_BYTE *)(a2 + 33);
    v28 = *(_BYTE *)(a2 + 34);
    v29 = *(float *)(a2 + 40);
    v30 = RB::bezier_flatness((RB *)v21);
    v31 = RB::AffineTransform::scale(a8);
    v32 = vrecpe_f32((float32x2_t)LODWORD(v31));
    v33 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v31), v32), v32);
    return (id *)RB::Stroke::flatten_points(v24, a3, v27, v28, v34, v25, v26, v29, v30 * vmul_f32(v33, vrecps_f32((float32x2_t)LODWORD(v31), v33)).f32[0], v22);
  }
  return result;
}

void **RBStrokeRef::map(void **result, __n128 a2, float32x2_t a3, float32x2_t a4, uint64_t a5, uint64_t a6, uint64_t a7, float64x2_t *a8)
{
  void *v8;
  float64x2_t v13;
  float64x2_t *v14;
  float64x2_t v15;
  float64x2_t v16;
  float32x2_t v17;
  float v18;
  float32x2_t v19;
  uint64_t v20;
  int v21;
  int v22;
  RB *v28;
  float v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  float32x2_t v45;
  float32x2_t v46;

  v8 = *result;
  if (*result)
  {
    v13 = a8[1];
    v35 = *a8;
    v36 = v13;
    v37 = a8[2];
    if (RB::AffineTransform::invert((RB::AffineTransform *)&v35))
      v14 = &v35;
    else
      v14 = a8;
    v15 = v14[1];
    v16 = v14[2];
    v35 = *v14;
    v36 = v15;
    v37 = v16;
    v45 = RB::operator*(&v35, a3, a4);
    v46 = v17;
    objc_msgSend(v8, "borderWidth");
    v19.f32[0] = -v18;
    RB::Rect::inset(&v45, v19, v19.f32[0]);
    v20 = objc_msgSend(v8, "imageCount");
    v21 = objc_msgSend(v8, "seed");
    if (v21)
      v22 = v21;
    else
      v22 = 90911;
    __asm { FMOV            V0.2S, #1.0 }
    v38 = _D0;
    v39 = 1065353216;
    v40 = 0;
    v41 = 0;
    v42 = 1065353216;
    v43 = v22;
    v44 = 0;
    v28 = (RB *)objc_msgSend(v8, "rotatesImage", *(_OWORD *)&a2, &unk_24C229740, a6, v20, *(_QWORD *)&v45, vadd_f32(v46, v45));
    LOBYTE(v37.f64[1]) = (_BYTE)v28;
    v29 = RB::bezier_flatness(v28);
    v30 = RB::AffineTransform::scale(a8);
    v31 = vrecpe_f32((float32x2_t)LODWORD(v30));
    v32 = vmul_f32(vrecps_f32((float32x2_t)LODWORD(v30), v31), v31);
    return (void **)RB::Stroke::flatten_particles(v8, &v35, v34, -5.48612406e303, (float32x2_t)0x7F7FFFFF7F7FFFFFLL, v29 * vmul_f32(v32, vrecps_f32((float32x2_t)LODWORD(v30), v32)).f32[0], 1.0);
  }
  return result;
}

uint64_t RBStrokeRef::can_mix(_QWORD *a1, _QWORD *a2)
{
  return 4 * (*a1 == *a2);
}

void *RBStrokeRef::prepare(void **this, uint64_t **a2)
{
  void *result;
  _QWORD v9[4];
  __int128 v10;
  __int128 v11;
  int v12;
  uint64_t v13;
  int v14;

  result = *this;
  if (result)
  {
    result = (void *)objc_msgSend(result, "image");
    if (result)
    {
      v9[0] = 0;
      __asm { FMOV            V0.2S, #1.0 }
      v9[1] = _D0;
      v9[2] = 0;
      v9[3] = 0;
      v10 = xmmword_209BD5460;
      v11 = xmmword_209BD5460;
      v12 = 1065353216;
      v13 = 0x3C003C003C003C00;
      v14 = 50331648;
      return (void *)RBMakeCachedImageTexture(a2, (CGImage *)result, (const RB::Fill::ImageData *)v9, 0, 0);
    }
  }
  return result;
}

uint64_t *RBStrokeRef::texture(id *this, uint64_t **a2, unint64_t *a3, float *a4)
{
  id v4;
  int v7;
  uint64_t *result;
  _QWORD v14[4];
  __int128 v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  int v19;

  v4 = *this;
  if (!*this)
    return 0;
  *a3 = objc_msgSend(*this, "imageCount");
  objc_msgSend(v4, "imageScale");
  *(_DWORD *)a4 = v7;
  result = (uint64_t *)objc_msgSend(v4, "image");
  if (result)
  {
    v14[0] = 0;
    __asm { FMOV            V0.2S, #1.0 }
    v14[1] = _D0;
    v14[2] = 0;
    v14[3] = 0;
    v15 = xmmword_209BD5460;
    v16 = xmmword_209BD5460;
    v17 = 1065353216;
    v18 = 0x3C003C003C003C00;
    v19 = 0;
    return RBGetCachedImageTexture(a2, (CGImage *)result, (const RB::Fill::ImageData *)v14, 0, 0);
  }
  return result;
}

uint64_t *RBStrokeRef::prepare_encode(uint64_t *result, uint64_t a2, uint64_t *a3)
{
  if (*(_BYTE *)(a2 + 32) == 1)
  {
    result = (uint64_t *)*result;
    if (result)
      return RB::Encoder::prepare_image(a3, 0, (uint64_t *)objc_msgSend(result, "image"));
  }
  return result;
}

void RBStrokeRef::encode(id *a1, uint64_t a2, RB::ProtobufEncoder *this)
{
  id v6;
  unint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  const unsigned int *v10;
  int v11;
  int v12;
  int v13;
  int v14;
  id v15;
  unint64_t v16;
  float v17;
  int v18;
  uint64_t v19;
  _BYTE v20[64];
  void *v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  __int128 v25;
  uint64_t v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v6 = *a1;
  if (v6)
  {
    v21 = 0;
    v22 = 0;
    v25 = 0u;
    v23 = 64;
    v26 = 384;
    objc_msgSend(v6, "applyFunction:info:", RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::$_0::__invoke, v20);
    v7 = v22;
    if (v22)
    {
      v8 = v21;
      RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
      if (v8)
        v9 = v8;
      else
        v9 = v20;
      RB::ProtobufEncoder::encode_data(this, v9, v7);
    }
    if (*((_QWORD *)&v25 + 1))
    {
      if ((_QWORD)v25)
        v10 = (const unsigned int *)v25;
      else
        v10 = (const unsigned int *)&v24;
      RB::ProtobufEncoder::packed_fixed32_field(this, 2, v10, *((uint64_t *)&v25 + 1));
    }
    if ((_QWORD)v25)
      free((void *)v25);
    if (v21)
      free(v21);
  }
  if (*(_BYTE *)(a2 + 36) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x18uLL);
    RB::ProtobufEncoder::encode_varint(this, 1uLL);
  }
  if (*(_BYTE *)(a2 + 32) == 1)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x2AuLL);
    RB::ProtobufEncoder::begin_length_delimited(this);
    v14 = rb_alpha_blend_mode(*(unsigned __int8 *)(a2 + 35));
    if (v14)
    {
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v14);
    }
    v15 = *a1;
    if (*a1)
    {
      RB::Encoder::image_field(this, 2, 0, (uint64_t *)objc_msgSend(*a1, "image"));
      v16 = objc_msgSend(v15, "imageCount");
      if (v16 != 1)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x18uLL);
        RB::ProtobufEncoder::encode_varint(this, v16);
      }
      objc_msgSend(v15, "imageScale");
      v18 = LODWORD(v17);
      if (v17 != 1.0)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x25uLL);
        RB::ProtobufEncoder::encode_fixed32(this, v18);
      }
      if (objc_msgSend(v15, "rotatesImage"))
      {
        RB::ProtobufEncoder::encode_varint(this, 0x28uLL);
        RB::ProtobufEncoder::encode_varint(this, 1uLL);
      }
      v19 = objc_msgSend(v15, "seed");
      if (v19)
      {
        RB::ProtobufEncoder::encode_varint(this, 0x31uLL);
        RB::ProtobufEncoder::encode_fixed64(this, v19);
      }
    }
  }
  else
  {
    if (*(_BYTE *)(a2 + 32))
      return;
    RB::ProtobufEncoder::encode_varint(this, 0x22uLL);
    RB::ProtobufEncoder::begin_length_delimited(this);
    v11 = rb_line_cap(*(unsigned __int8 *)(a2 + 33));
    if (v11 != 1)
    {
      RB::ProtobufEncoder::encode_varint(this, 8uLL);
      RB::ProtobufEncoder::encode_varint(this, v11);
    }
    v12 = RBStrokeRef::clip(*(unsigned __int8 *)(a2 + 34));
    if (v12 != 1)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x10uLL);
      RB::ProtobufEncoder::encode_varint(this, v12);
    }
    v13 = *(int *)(a2 + 40);
    if (*(float *)&v13 != 10.0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
      RB::ProtobufEncoder::encode_fixed32(this, v13);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
}

void sub_209B11DA4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::StrokeData::~StrokeData((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::StrokeData::~StrokeData(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 1624);
  if (v2)
    free(v2);
  v3 = *(void **)(a1 + 64);
  if (v3)
    free(v3);
  return a1;
}

void RBStrokeRef::decode(id *a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  uint64_t v6;
  unsigned __int8 *v7;
  unint64_t field;
  char v9;
  float v10;
  uint64_t v11;
  size_t v12;
  _BYTE *v13;
  id v14;
  unint64_t i;
  unint64_t v16;
  double v17;
  unint64_t j;
  uint64_t v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  _BYTE *v23;
  unint64_t v24;
  unint64_t v25;
  unsigned int v26;
  unint64_t v27;
  id *v28;
  int v29;
  id v30;
  _BYTE __dst[1281];
  __int128 v33;
  unint64_t v34;
  uint64_t v35;

  v35 = *MEMORY[0x24BDAC8D0];
  v5 = (void *)objc_opt_new();
  v6 = 0;
  v7 = 0;
  v33 = 0u;
  v34 = 384;
  while (1)
  {
    field = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
    v9 = field;
    if (!field)
      break;
    switch((field >> 3))
    {
      case 1u:
        v21 = RB::ProtobufDecoder::data_field((RB::ProtobufDecoder *)a3, field);
        if (v21)
        {
          v6 = v22;
          v7 = (unsigned __int8 *)v21;
        }
        break;
      case 2u:
        v10 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, field);
        v11 = *((_QWORD *)&v33 + 1);
        v12 = *((_QWORD *)&v33 + 1) + 1;
        if (v34 < *((_QWORD *)&v33 + 1) + 1)
        {
          RB::vector<float,384ul,unsigned long>::reserve_slow(__dst, v12);
          v11 = *((_QWORD *)&v33 + 1);
          v12 = *((_QWORD *)&v33 + 1) + 1;
        }
        v13 = (_BYTE *)v33;
        if (!(_QWORD)v33)
          v13 = __dst;
        *(float *)&v13[4 * v11] = v10;
        *((_QWORD *)&v33 + 1) = v12;
        break;
      case 3u:
        *(_BYTE *)(a2 + 36) = RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a3, field);
        break;
      case 4u:
        *(_BYTE *)(a2 + 32) = 0;
        objc_msgSend(v5, "setStrokeType:", 0);
        v14 = v5;
        if ((v9 & 7) != 2)
          goto LABEL_38;
        RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a3);
        for (i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
              i;
              i = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3))
        {
          v16 = i >> 3;
          if ((i >> 3) == 3)
          {
            *(float *)&v17 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, i);
            objc_msgSend(v14, "setMiterLimit:", v17);
          }
          else if ((_DWORD)v16 == 2)
          {
            objc_msgSend(v14, "setLineJoin:", RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a3, i));
          }
          else if ((_DWORD)v16 == 1)
          {
            objc_msgSend(v14, "setLineCap:", RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a3, i));
          }
          else
          {
            RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, i);
          }
        }
        goto LABEL_34;
      case 5u:
        *(_BYTE *)(a2 + 32) = 1;
        objc_msgSend(v5, "setStrokeType:", 1);
        v14 = v5;
        if ((v9 & 7) == 2)
        {
          RB::ProtobufDecoder::begin_message((RB::ProtobufDecoder *)a3);
          for (j = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3);
                j;
                j = RB::ProtobufDecoder::next_field((RB::ProtobufDecoder *)a3))
          {
            switch((j >> 3))
            {
              case 1u:
                objc_msgSend(v14, "setBlendMode:", RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a3, j));
                break;
              case 2u:
                if (!RB::Decoder::image_field((RB::ProtobufDecoder *)a3, j))
                  objc_msgSend(v14, "setImage:", v19);
                break;
              case 3u:
                objc_msgSend(v14, "setImageCount:", RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a3, j));
                break;
              case 4u:
                *(float *)&v20 = RB::ProtobufDecoder::float_field((RB::ProtobufDecoder *)a3, j);
                objc_msgSend(v14, "setImageScale:", v20);
                break;
              case 5u:
                objc_msgSend(v14, "setRotatesImage:", RB::ProtobufDecoder::BOOL_field((RB::ProtobufDecoder *)a3, j));
                break;
              case 6u:
                objc_msgSend(v14, "setSeed:", RB::ProtobufDecoder::uint_field((RB::ProtobufDecoder *)a3, j));
                break;
              default:
                RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, j);
                break;
            }
          }
LABEL_34:
          RB::ProtobufDecoder::end_message(a3);
        }
        else
        {
LABEL_38:
          *(_BYTE *)(a3 + 56) = 1;
          *(_QWORD *)a3 = *(_QWORD *)(a3 + 8);
        }

        break;
      default:
        RB::ProtobufDecoder::skip_field((RB::ProtobufDecoder *)a3, field);
        break;
    }
  }
  if (v6)
  {
    v23 = (_QWORD)v33 ? (_BYTE *)v33 : __dst;
    v24 = *((_QWORD *)&v33 + 1);
    while (1)
    {
      v26 = *v7++;
      v25 = v26;
      if (v24 < (unint64_t)v26 >> 5)
        break;
      v27 = v25 >> 5;
      if ((v25 & 0x1F) <= 0xF && RB::Stroke::element_args(RBStrokeElement)::elts[v25 & 0x1F] <= v27)
        objc_msgSend(v5, "addElement:args:");
      v24 -= v27;
      v23 += 4 * v27;
      if (!--v6)
      {
        if (!v24)
          goto LABEL_51;
        goto LABEL_50;
      }
    }
    *(_BYTE *)(a3 + 56) = 1;
    *(_QWORD *)a3 = *(_QWORD *)(a3 + 8);
    if (v24)
    {
LABEL_50:
      *(_BYTE *)(a3 + 56) = 1;
      *(_QWORD *)a3 = *(_QWORD *)(a3 + 8);
    }
  }
LABEL_51:
  if (*(_BYTE *)(a2 + 32))
  {
    v28 = a1;
    if (*(_BYTE *)(a2 + 32) == 1)
    {
      *(_BYTE *)(a2 + 35) = rb_alpha_blend_mode(objc_msgSend(v5, "blendMode"));
      if (!objc_msgSend(v5, "image"))
      {
        *(_BYTE *)(a3 + 56) = 1;
        *(_QWORD *)a3 = *(_QWORD *)(a3 + 8);
      }
    }
  }
  else
  {
    v28 = a1;
    *(_BYTE *)(a2 + 33) = rb_line_cap(objc_msgSend(v5, "lineCap"));
    *(_BYTE *)(a2 + 34) = rb_line_join((CGLineJoin)objc_msgSend(v5, "lineJoin"));
    objc_msgSend(v5, "miterLimit");
    *(_DWORD *)(a2 + 40) = v29;
  }
  v30 = (id)objc_msgSend(v5, "commit", a1);
  if (*v28 != v30)
  {

    *v28 = v30;
  }
  if ((_QWORD)v33)
    free((void *)v33);

}

void sub_209B122B0(_Unwind_Exception *a1)
{
  void *v1;

  if (STACK[0x608])
    free((void *)STACK[0x608]);

  _Unwind_Resume(a1);
}

void **RBStrokeRef::attributes(void **result, uint64_t a2, _QWORD *a3)
{
  void *v3;
  id *v5;
  id v6;
  unsigned int v7;
  char v8;
  int v9;
  char v10;
  float v11;
  id v12;
  const void *v13;
  const void *v14;
  float v15;
  void *v16;
  int v17;
  void (**v18)(RB::XML::Value::Image *__hidden);
  id v19;
  CFTypeRef cf;

  v3 = *result;
  if (*result)
  {
    v5 = result;
    v18 = &off_24C2291F0;
    *(double *)&v19 = COERCE_DOUBLE(v3);
    RB::XML::Element::set<RB::XML::Value::Stroke>(a3, (uint64_t)"stroke", (uint64_t)&v18);
    v18 = &off_24C2291F0;

    result = (void **)objc_msgSend(*v5, "strokeType");
    if ((_DWORD)result == 1)
    {
      v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C228EA8;
      LODWORD(v19) = 1;
      RB::XML::Element::set<RB::XML::Value::StrokeType>(a3, (uint64_t)"stroke-type", (uint64_t)&v18);
      v12 = *v5;
      v13 = (const void *)objc_msgSend(v12, "image");
      if (v13)
      {
        v14 = v13;
        v18 = &off_24C2291A0;
        LODWORD(v19) = 0;
        CFRetain(v13);
        cf = v14;
        RB::XML::Element::set<RB::XML::Value::Image>(a3, (uint64_t)"stroke-image", (uint64_t)&v18);
        v18 = &off_24C2291A0;
        if (cf)
          CFRelease(cf);
      }
      objc_msgSend(v12, "imageScale");
      if (v15 != 1.0)
      {
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C229178;
        *(double *)&v19 = v15;
        RB::XML::Element::set<RB::XML::Value::Float>(a3, (uint64_t)"stroke-image-scale", (uint64_t)&v18);
      }
      v16 = (void *)objc_msgSend(v12, "imageCount");
      if (v16 != (void *)1)
      {
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C228FE8;
        v19 = v16;
        RB::XML::Element::set<RB::XML::Value::Int>(a3, (uint64_t)"stroke-image-count", (uint64_t)&v18);
      }
      if (objc_msgSend(v12, "rotatesImage"))
      {
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C229010;
        LOBYTE(v19) = 1;
        RB::XML::Element::set<RB::XML::Value::Bool>(a3, (uint64_t)"stroke-rotates-image", (uint64_t)&v18);
      }
      v17 = objc_msgSend(v12, "blendMode");
      if (v17)
      {
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C228F20;
        LODWORD(v19) = v17;
        RB::XML::Element::set<RB::XML::Value::AlphaBlendMode>(a3, (uint64_t)"stroke-blend", (uint64_t)&v18);
      }
      result = (void **)objc_msgSend(v12, "seed");
      if (result)
      {
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C228FE8;
        v19 = result;
        return (void **)RB::XML::Element::set<RB::XML::Value::Int>(a3, (uint64_t)"stroke-seed", (uint64_t)&v18);
      }
    }
    else if (!(_DWORD)result)
    {
      v6 = *v5;
      v7 = objc_msgSend(v6, "lineCap");
      if (v7 != 1)
      {
        v8 = rb_line_cap(v7);
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C229218;
        LOBYTE(v19) = v8;
        RB::XML::Element::set<RB::XML::Value::LineCap>(a3, (uint64_t)"line-cap", (uint64_t)&v18);
      }
      result = (void **)objc_msgSend(v6, "lineJoin");
      if ((_DWORD)result != 1)
      {
        v9 = (int)result;
        v10 = rb_line_join((CGLineJoin)result);
        v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C2292E0;
        LOBYTE(v19) = v10;
        result = (void **)RB::XML::Element::set<RB::XML::Value::LineJoin>(a3, (uint64_t)"line-join", (uint64_t)&v18);
        if (!v9)
        {
          result = (void **)objc_msgSend(v6, "miterLimit");
          if (v11 != 10.0)
          {
            v18 = (void (**)(RB::XML::Value::Image *__hidden))&unk_24C229178;
            *(double *)&v19 = v11;
            return (void **)RB::XML::Element::set<RB::XML::Value::Float>(a3, (uint64_t)"miter-limit", (uint64_t)&v18);
          }
        }
      }
    }
  }
  return result;
}

void sub_209B125D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Stroke>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = (_QWORD *)operator new();
  *v6 = &off_24C2291F0;
  v6[1] = *(id *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Stroke,void>(v8 + 1, (uint64_t)v6);
  ++a1[7];
  return result;
}

void sub_209B126B0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x81C40803F642BLL);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::StrokeType>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228EA8;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StrokeType,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

_QWORD *RB::XML::Element::set<RB::XML::Value::Image>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  CFTypeRef v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &off_24C2291A0;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = *(CFTypeRef *)(a3 + 16);
  if (v7)
    v7 = CFRetain(v7);
  *(_QWORD *)(v6 + 16) = v7;
  v8 = a1[7];
  if (a1[8] < (unint64_t)(v8 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v8 + 1);
    v8 = a1[7];
  }
  v9 = (_QWORD *)(a1[6] + 24 * v8);
  *v9 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Image,void>(v9 + 1, v6);
  ++a1[7];
  return result;
}

void sub_209B1282C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10C1C404DF0DBB8);
  _Unwind_Resume(a1);
}

_QWORD *RB::XML::Element::set<RB::XML::Value::AlphaBlendMode>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *result;

  v6 = operator new();
  *(_QWORD *)v6 = &unk_24C228F20;
  *(_DWORD *)(v6 + 8) = *(_DWORD *)(a3 + 8);
  v7 = a1[7];
  if (a1[8] < (unint64_t)(v7 + 1))
  {
    RB::vector<std::pair<char const*,std::shared_ptr<RB::XML::Value::Base>>,0ul,unsigned long>::reserve_slow((uint64_t)(a1 + 6), v7 + 1);
    v7 = a1[7];
  }
  v8 = (_QWORD *)(a1[6] + 24 * v7);
  *v8 = a2;
  result = std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AlphaBlendMode,void>(v8 + 1, v6);
  ++a1[7];
  return result;
}

void set_rounded_rect(uint64_t a1, int a2, float64_t a3, float64_t a4, float64_t a5, float64_t a6, float64_t a7, float64_t a8, float64_t a9, float64_t a10, double a11)
{
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  int64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  char v25;
  float32x2_t v26;
  float32x2_t v27;
  int v28;
  float v29;
  float v30;
  float32x4_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;

  v34.f64[0] = a3;
  v34.f64[1] = a4;
  v35.f64[0] = a5;
  v35.f64[1] = a6;
  v32.f64[0] = a7;
  v32.f64[1] = a8;
  v33.f64[0] = a9;
  v33.f64[1] = a10;
  RB::clamp_corner_radii((uint64_t)&v32, v35.f64);
  v19 = v33;
  v20 = v32;
  v21 = (float64x2_t)vdupq_lane_s64(*(uint64_t *)&v32.f64[0], 0);
  v22 = (int64x2_t)vandq_s8((int8x16_t)vceqq_f64(v32, v21), (int8x16_t)vceqq_f64(v33, v21));
  v23 = (float64x2_t)vandq_s8((int8x16_t)v22, (int8x16_t)vdupq_laneq_s64(v22, 1));
  if ((*(_QWORD *)&v23.f64[0] & 0x8000000000000000) != 0)
  {
    v19.f64[0] = v34.f64[0];
    v23.f64[0] = v35.f64[0];
    set_rounded_rect(a1, a2, v19, v34.f64[1], v23, v35.f64[1], v32.f64[0], v32.f64[0], a11);
  }
  else
  {
    if (a2)
    {
      if (a2 != 1)
        abort();
      v24 = (float64x2_t)vdupq_n_s64(0x3FF4666660000000uLL);
      v19 = vmulq_f64(v33, v24);
      v20 = vmulq_f64(v32, v24);
      v25 = 4;
    }
    else
    {
      v25 = 3;
    }
    v26 = vcvt_f32_f64(v34);
    v27 = vcvt_f32_f64(v35);
    v31 = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(v20), v19);
    v28 = *(_DWORD *)(a1 + 428);
    RBShapeData::apply<RB::DestroyAny>((int *)(a1 + 16));
    v29 = a11;
    v30 = *(double *)(a1 + 432);
    *(float32x2_t *)(a1 + 32) = v26;
    *(float32x2_t *)(a1 + 40) = v27;
    *(float32x4_t *)(a1 + 48) = v31;
    *(_DWORD *)(a1 + 64) = 1065353216;
    *(float *)(a1 + 68) = v29;
    *(float *)(a1 + 72) = v30;
    *(_BYTE *)(a1 + 76) = v25;
    *(_BYTE *)(a1 + 77) = v28;
    *(_BYTE *)(a1 + 78) &= 0xF8u;
    *(_DWORD *)(a1 + 16) = 1;
  }
}

void sub_209B135E8(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 32), *(_QWORD *)(v1 + 40));
  _Unwind_Resume(a1);
}

void sub_209B13868(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

unint64_t RBShapeData::decode(RBShapeData *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  unsigned __int8 *v6;
  int32x2_t v7;
  uint64_t v8;
  uint64_t v9[7];

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    v6 = &this->data[12];
    v7 = vdup_n_s32(0x7F7FFFFFu);
    while (2)
    {
      switch((v5 >> 3))
      {
        case 1u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          *(_OWORD *)v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(_QWORD *)&this->data[44] = 1065353216;
          *(_DWORD *)&this->data[52] = 0;
          *(_WORD *)&this->data[56] = 2;
          this->data[58] &= 0xF8u;
          this->type = 1;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message(a2);
          RB::Coverage::Primitive::decode((uint64_t)&this->data[12], a2);
          goto LABEL_15;
        case 2u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(_OWORD *)v6 = RBPathEmpty;
          *(_QWORD *)&this->data[28] = 0;
          *(_QWORD *)&this->data[34] = 0;
          this->type = 2;
          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message(a2);
          RB::Coverage::Path::decode((RB::Coverage::Path *)&this->data[12], a2);
          goto LABEL_15;
        case 3u:
          *(_OWORD *)v9 = RBPathEmpty;
          memset(&v9[2], 0, 32);
          v8 = *((_QWORD *)a2 + 8);
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(_QWORD *)&this->data[12] = off_24C229920;
          RB::Coverage::StrokeablePath::StrokeablePath(&this->data[20], v9, v8);
          *(_QWORD *)&this->data[68] = 0x100000001000000;
          *(int32x2_t *)&this->data[76] = v7;
          *(_DWORD *)&this->data[84] = 251658752;
          LOBYTE(this[1].type) = 0;
          *(_DWORD *)this[1].data = 1092616192;
          this->type = 3;
          RBPathRelease(v9[0], v9[1]);
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Coverage::StrokeablePath::decode((uint64_t)&this->data[20], (uint64_t)&this->data[12], (size_t **)a2);
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          goto LABEL_16;
        case 4u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          this->type = 0;
          *(_QWORD *)&this->data[12] = off_24C229900;
          *(_QWORD *)&this->data[20] = 0;
          *(_QWORD *)&this->data[28] = 0x100000001000000;
          *(int32x2_t *)&this->data[36] = v7;
          *(_DWORD *)&this->data[44] = 251658752;
          this->data[48] = 0;
          *(_DWORD *)&this->data[52] = 1092616192;
          this->type = 5;

          if ((v5 & 7) != 2)
            goto LABEL_18;
          RB::ProtobufDecoder::begin_message(a2);
          RBStrokeRef::decode((id *)&this->data[20], (uint64_t)&this->data[12], (uint64_t)a2);
          goto LABEL_15;
        case 5u:
          RBShapeData::apply<RB::DestroyAny>(&this->type);
          *(_OWORD *)v6 = 0u;
          *(_OWORD *)&this->data[28] = 0u;
          *(_QWORD *)&this->data[44] = 0x100000001000000;
          *(int32x2_t *)&this->data[52] = v7;
          *(_DWORD *)&this->data[60] = 0;
          *(_WORD *)&this->data[64] = 0;
          this->type = 4;
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::Coverage::Glyphs::decode((RB::Coverage::Glyphs *)&this->data[12], (size_t **)a2);
LABEL_15:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_18:
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
LABEL_16:
          result = RB::ProtobufDecoder::next_field(a2);
          v5 = result;
          if (!result)
            return result;
          continue;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          goto LABEL_16;
      }
    }
  }
  return result;
}

void sub_209B13BB8(_Unwind_Exception *a1)
{

  _Unwind_Resume(a1);
}

char *RBStrokeRef::encode(RB::Coverage::Stroke<RBStrokeRef> const&,RB::Encoder &)const::$_0::__invoke(char *result, unsigned __int8 *a2, int *a3, _QWORD *__dst)
{
  char *v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  int v18;

  if (result)
  {
    v7 = result;
    v8 = 0;
    do
    {
      v10 = *a2++;
      v9 = v10;
      if (v10 > 0xFuLL)
        v11 = 0;
      else
        v11 = RB::Stroke::element_args(RBStrokeElement)::elts[v9];
      v12 = __dst[9];
      if (__dst[10] < (unint64_t)(v12 + 1))
      {
        result = (char *)RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(__dst, v12 + 1);
        v12 = __dst[9];
      }
      v13 = (_QWORD *)__dst[8];
      if (!v13)
        v13 = __dst;
      *((_BYTE *)v13 + v12) = v9 | (32 * v11);
      ++__dst[9];
      v8 += v11;
      --v7;
    }
    while (v7);
    if (v8)
    {
      v14 = __dst[204];
      if (__dst[205] < (unint64_t)(v14 + v8))
      {
        result = (char *)RB::vector<float,384ul,unsigned long>::reserve_slow(__dst + 11, v14 + v8);
        v14 = __dst[204];
      }
      v15 = (char *)__dst[203];
      if (!v15)
        v15 = (char *)(__dst + 11);
      v16 = &v15[4 * v14];
      v17 = v8;
      do
      {
        v18 = *a3++;
        *(_DWORD *)v16 = v18;
        v16 += 4;
        --v17;
      }
      while (v17);
      __dst[204] = v14 + v8;
    }
  }
  return result;
}

void *RB::vector<unsigned char,64ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1);
  result = RB::details::realloc_vector<unsigned long,1ul>(*((void **)__dst + 8), __dst, 0x40uLL, (size_t *)__dst + 10, v3);
  *((_QWORD *)__dst + 8) = result;
  return result;
}

void *RB::vector<float,384ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 194) + (*((_QWORD *)__dst + 194) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 194) + (*((_QWORD *)__dst + 194) >> 1);
  result = RB::details::realloc_vector<unsigned long,4ul>(*((void **)__dst + 192), __dst, 0x180uLL, (size_t *)__dst + 194, v3);
  *((_QWORD *)__dst + 192) = result;
  return result;
}

id *RB::Coverage::Stroke<RBStrokeRef>::generate(uint64_t a1, uint64_t (**a2)(_QWORD), float64x2_t a3, float32x2_t a4, float32x2_t a5, uint64_t a6, float64x2_t *a7)
{
  return RBStrokeRef::map((id *)(a1 + 8), a1, a2, a3, a4, a5, (uint64_t)a7, a7);
}

void **RB::Coverage::Stroke<RBStrokeRef>::generate(uint64_t a1, uint64_t a2, __n128 a3, float32x2_t a4, float32x2_t a5, uint64_t a6, float64x2_t *a7)
{
  return RBStrokeRef::map((void **)(a1 + 8), a3, a4, a5, a2, a2, (uint64_t)a7, a7);
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Stroke,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229EA8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B13DEC(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Stroke *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Stroke>,std::allocator<RB::XML::Value::Stroke>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Stroke *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Stroke>,std::allocator<RB::XML::Value::Stroke>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::StrokeType,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229A10;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B13EA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::StrokeType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StrokeType>,std::allocator<RB::XML::Value::StrokeType>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::StrokeType *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::StrokeType>,std::allocator<RB::XML::Value::StrokeType>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::Image,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229E38;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B13F5C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::Image *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Image>,std::allocator<RB::XML::Value::Image>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::Image *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::Image>,std::allocator<RB::XML::Value::Image>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

_QWORD *std::shared_ptr<RB::XML::Value::Base>::shared_ptr[abi:nn180100]<RB::XML::Value::AlphaBlendMode,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &off_24C229AB8;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_209B14014(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (v1)
    (*(void (**)(uint64_t))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<RB::XML::Value::AlphaBlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AlphaBlendMode>,std::allocator<RB::XML::Value::AlphaBlendMode>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__shared_ptr_pointer<RB::XML::Value::AlphaBlendMode *,std::shared_ptr<RB::XML::Value::Base>::__shared_ptr_default_delete<RB::XML::Value::Base,RB::XML::Value::AlphaBlendMode>,std::allocator<RB::XML::Value::AlphaBlendMode>>::__on_zero_shared(uint64_t a1)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 24);
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  return result;
}

float32x2_t RB::Coverage::Stroke<RBStrokeRef>::bounds(_QWORD *a1, float64x2_t *a2)
{
  float32x2_t v4;
  uint32x2_t v5;
  float32x2_t v6;
  void *v7;
  float64_t v8;
  float64x2_t v9;
  float64_t v10;
  float64x2_t v11;

  v4 = (float32x2_t)a1[3];
  v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&v4 & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
  if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) != 0)
  {
    v7 = (void *)a1[1];
    if (v7)
    {
      objc_msgSend(v7, "boundingRect");
      v9.f64[1] = v8;
      v6 = vcvt_f32_f64(v9);
      v11.f64[1] = v10;
      v4 = vcvt_f32_f64(v11);
    }
    else
    {
      v4 = 0;
      v6 = 0;
    }
    a1[2] = v6;
    a1[3] = v4;
  }
  else
  {
    v6 = (float32x2_t)a1[2];
  }
  return RB::operator*(a2, v6, v4);
}

BOOL RB::pixel_formats_support_view_copy(RB *this, RB *a2, MTLPixelFormat a3)
{
  _BOOL8 result;
  unsigned int *v6;
  MTLPixelFormat v7;
  unsigned int *v8;

  if (this == a2)
    return 1;
  v6 = RB::pixel_format_traits((unint64_t)this, (MTLPixelFormat)a2);
  result = 1;
  if ((~((unint64_t)*((unsigned __int16 *)v6 + 2) << 32) & 0x3000000000) != 0 || (RB *)v6[6] != a2)
  {
    v8 = RB::pixel_format_traits((unint64_t)a2, v7);
    if ((~((unint64_t)*((unsigned __int16 *)v8 + 2) << 32) & 0x3000000000) != 0 || (RB *)v8[6] != this)
      return 0;
  }
  return result;
}

uint64_t RB::pixel_format_from_four_cc(int a1, MTLPixelFormat a2, _BYTE *a3, _BYTE *a4, char *a5)
{
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  int v9;
  BOOL v10;
  uint64_t v11;
  int v12;
  int v13;
  char v14;
  BOOL v15;
  uint64_t v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;

  v6 = 0;
  *a3 = 1;
  *a4 = 1;
  *a5 = 0;
  v7 = (a2 >> 1) & 1;
  v8 = (a2 >> 2) & 1;
  if (a1 > 1882468911)
  {
    if (a1 > 2016686641)
    {
      if (a1 > 2019964015)
      {
        if (a1 > 2021078067)
        {
          if (a1 > 2037741157)
          {
            if (a1 != 2037741158 && a1 != 2037741171)
              return v6;
            v15 = (a2 & 2) == 0;
            v16 = 501;
            goto LABEL_100;
          }
          if (a1 != 2021078068)
          {
            v12 = 2021078128;
            goto LABEL_40;
          }
          goto LABEL_79;
        }
        if (a1 == 2019964016)
        {
LABEL_60:
          v15 = (a2 & 2) == 0;
          v16 = 504;
          goto LABEL_100;
        }
        if (a1 != 2021077552)
        {
          if (a1 != 2021077554)
            return v6;
          goto LABEL_89;
        }
LABEL_87:
        v15 = (a2 & 2) == 0;
        v16 = 505;
        goto LABEL_100;
      }
      if (a1 > 2019963439)
      {
        if (a1 == 2019963440)
          goto LABEL_87;
        if (a1 != 2019963442)
        {
          if (a1 != 2019963956)
            return v6;
          goto LABEL_79;
        }
      }
      else if (a1 != 2016686642)
      {
        if (a1 != 2016687156)
        {
          v12 = 2016687216;
LABEL_40:
          if (a1 != v12)
            return v6;
          goto LABEL_60;
        }
LABEL_79:
        v15 = (a2 & 2) == 0;
        v16 = 507;
        goto LABEL_100;
      }
LABEL_89:
      v15 = (a2 & 2) == 0;
      v16 = 506;
      goto LABEL_100;
    }
    if (a1 > 1886859823)
    {
      if (a1 > 1999843441)
      {
        if (a1 == 1999843442)
        {
          if ((a2 & 4) != 0)
            v6 = 554;
          else
            v6 = 0;
          goto LABEL_136;
        }
        if (a1 == 1999908961)
        {
          *a3 = 0;
          v18 = (a2 & 4) == 0;
          v19 = 552;
LABEL_127:
          if (v18)
            v6 = 0;
          else
            v6 = v19;
LABEL_132:
          v14 = 1;
          if ((a2 & 0x20) == 0)
            goto LABEL_136;
          goto LABEL_133;
        }
        if (a1 != 2016686640)
          return v6;
        goto LABEL_87;
      }
      if (a1 != 1886859824)
      {
        if (a1 != 1886859826)
        {
          v13 = 1886860340;
          goto LABEL_68;
        }
LABEL_88:
        v15 = (a2 & 2) == 0;
        v16 = 509;
        goto LABEL_100;
      }
    }
    else if (a1 > 1885745711)
    {
      if (a1 != 1885745712)
      {
        if (a1 != 1885745714)
        {
          v13 = 1885746228;
          goto LABEL_68;
        }
        goto LABEL_88;
      }
    }
    else if (a1 != 1882468912)
    {
      if (a1 != 1882468914)
      {
        v13 = 1882469428;
LABEL_68:
        if (a1 != v13)
          return v6;
        v15 = (a2 & 2) == 0;
        v16 = 510;
        goto LABEL_100;
      }
      goto LABEL_88;
    }
    v15 = (a2 & 2) == 0;
    v16 = 508;
    goto LABEL_100;
  }
  if (a1 <= 1278226487)
  {
    if (a1 > 875704949)
    {
      if (a1 > 875836533)
      {
        if (a1 != 875836534)
        {
          if (a1 == 1093677112)
          {
            v8 = 0;
            *a3 = 0;
            v14 = 1;
            v6 = 1;
            if ((a2 & 0x20) == 0)
              goto LABEL_136;
            goto LABEL_133;
          }
          if (a1 != 1111970369)
            return v6;
          *a3 = 0;
          v14 = 1;
          v6 = 80;
          goto LABEL_120;
        }
      }
      else
      {
        if (a1 == 875704950)
        {
LABEL_64:
          v15 = (a2 & 2) == 0;
          v16 = 502;
          goto LABEL_100;
        }
        if (a1 == 875836468)
        {
          v8 = 0;
          *a3 = 0;
          v14 = 1;
          v6 = 42;
          if ((a2 & 0x20) == 0)
            goto LABEL_136;
          goto LABEL_133;
        }
        if (a1 != 875836518)
          return v6;
      }
      v15 = (a2 & 2) == 0;
      v16 = 503;
    }
    else
    {
      if (a1 <= 875704421)
      {
        if (a1 == 843264104)
        {
          *a3 = 0;
          if ((a2 & 8) != 0)
          {
            v8 = 0;
            *a5 = 4;
            v14 = 3;
            v6 = 65;
            if ((a2 & 0x20) == 0)
              goto LABEL_136;
            goto LABEL_133;
          }
        }
        else
        {
          if (a1 != 843264310)
          {
            v9 = 846624121;
            v10 = (a2 & 2) == 0;
            v11 = 562;
            goto LABEL_19;
          }
          *a3 = 0;
          if ((a2 & 8) != 0)
          {
            v8 = 0;
            *a5 = 4;
            v14 = 3;
            v6 = 60;
            if ((a2 & 0x20) == 0)
              goto LABEL_136;
            goto LABEL_133;
          }
        }
        goto LABEL_131;
      }
      if (a1 != 875704422 && a1 != 875704438)
      {
        if (a1 != 875704934)
          return v6;
        goto LABEL_64;
      }
      v15 = (a2 & 2) == 0;
      v16 = 500;
    }
LABEL_100:
    if (v15)
      v6 = 0;
    else
      v6 = v16;
LABEL_137:
    if ((a2 & 1) != 0)
    {
      if (v7)
      {
        v20 = *(unsigned int *)((char *)RB::pixel_format_traits(v6, a2) + 18);
        if ((_DWORD)v20)
        {
          *a4 = 0;
          return v20;
        }
      }
    }
    return v6;
  }
  if (a1 > 1378955370)
  {
    if (a1 > 1380411456)
    {
      if (a1 <= 1647534391)
      {
        if (a1 != 1380411457)
        {
          v9 = 1599226420;
          v10 = (a2 & 2) == 0;
          v11 = 542;
LABEL_19:
          if (v10)
            v11 = 0;
          if (a1 == v9)
            return v11;
          else
            return 0;
        }
        v8 = 0;
        *a3 = 0;
        v14 = 1;
        v6 = 115;
        if ((a2 & 0x20) == 0)
          goto LABEL_136;
        goto LABEL_133;
      }
      if (a1 != 1647534392)
      {
        if (a1 != 1815162994)
          return v6;
        v8 = 0;
        *a3 = 0;
        v14 = 1;
        v6 = 94;
        if ((a2 & 0x20) == 0)
          goto LABEL_136;
        goto LABEL_133;
      }
      *a3 = 0;
      v18 = (a2 & 4) == 0;
      v19 = 550;
      goto LABEL_127;
    }
    if (a1 == 1378955371)
    {
      v8 = 0;
      *a3 = 0;
      v14 = 1;
      v6 = 90;
      if ((a2 & 0x20) == 0)
        goto LABEL_136;
      goto LABEL_133;
    }
    if (a1 != 1380401729)
    {
      if (a1 != 1380410945)
        return v6;
      v8 = 0;
      *a3 = 0;
      v14 = 1;
      v6 = 125;
      if ((a2 & 0x20) == 0)
        goto LABEL_136;
      goto LABEL_133;
    }
    *a3 = 0;
    v14 = 1;
    v6 = 70;
LABEL_120:
    v8 = 1;
    if ((a2 & 0x20) == 0)
      goto LABEL_136;
    goto LABEL_133;
  }
  if (a1 <= 1278555700)
  {
    if (a1 == 1278226488)
    {
      if ((a2 & 0x18) != 8)
        return (a2 & 0x10) >> 4;
      *a5 = 3;
      v7 = 1;
      v6 = 10;
      goto LABEL_137;
    }
    if (a1 == 1278226742)
    {
      if ((a2 & 8) != 0)
      {
        if ((a2 & 0x10) != 0)
          v17 = 2;
        else
          v17 = 3;
        *a5 = v17;
        return 20;
      }
      return 0;
    }
    if (a1 != 1278555445)
      return v6;
    v8 = 0;
    *a3 = 0;
    v14 = 1;
    v6 = 43;
    if ((a2 & 0x20) == 0)
    {
LABEL_136:
      v7 = v8;
      goto LABEL_137;
    }
LABEL_133:
    if ((a2 & 8) == 0)
      return 0;
    *a5 = v14;
    *a3 = 1;
    goto LABEL_136;
  }
  if (a1 == 1278555701)
    return 40;
  if (a1 == 1279340600 || a1 == 1279342648)
  {
    *a3 = 0;
    if ((a2 & 8) != 0)
    {
      *a5 = 4;
      v8 = 1;
      v14 = 3;
      v6 = 30;
      if ((a2 & 0x20) == 0)
        goto LABEL_136;
      goto LABEL_133;
    }
LABEL_131:
    v6 = 0;
    v8 = 0;
    goto LABEL_132;
  }
  return v6;
}

uint64_t RB::pixel_format_required_depth(RB *this, MTLPixelFormat a2)
{
  unsigned int *v2;
  uint64_t v3;
  unint64_t v4;
  unsigned int v5;

  v2 = RB::pixel_format_traits((unint64_t)this, a2);
  v3 = *((unsigned __int16 *)v2 + 2);
  v4 = *v2 | (unint64_t)(v3 << 32);
  v5 = (v3 >> 2) & 3;
  if ((v4 & 0x200000000) != 0)
    return 4;
  else
    return v5;
}

char *RB::pixel_format_name(RB *this, MTLPixelFormat a2)
{
  if ((unint64_t)this - 0x80000001 >= 0xA)
    return (char *)(MTLPixelFormatGetName() + 14);
  else
    return off_24C22AAD8[(_QWORD)this - 0x80000001];
}

uint64_t RB::`anonymous namespace'::create_plane_dict(RB::_anonymous_namespace_ *this, uint64_t a2, uint64_t a3, uint64_t a4, _QWORD *a5, uint64_t a6, unint64_t *a7)
{
  uint64_t v12;
  unint64_t v13;
  uint64_t result;
  uint64_t v15;
  _QWORD v16[7];
  _QWORD v17[8];

  v17[7] = *MEMORY[0x24BDAC8D0];
  v12 = *MEMORY[0x24BDD8F18];
  v13 = MEMORY[0x20BD162BC](*MEMORY[0x24BDD8F18], a3 * (unint64_t)this, a3, a4, a5, a6, a7);
  result = 0;
  *a5 = a2 * v13;
  if (is_mul_ok(a2, v13))
  {
    v15 = *MEMORY[0x24BDD8F98];
    *a5 = MEMORY[0x20BD162BC](*MEMORY[0x24BDD8F98]);
    v16[0] = *MEMORY[0x24BDD8FA8];
    v17[0] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", this);
    v16[1] = *MEMORY[0x24BDD8F70];
    v17[1] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a2);
    v16[2] = v12;
    v17[2] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", v13);
    v16[3] = *MEMORY[0x24BDD8F90];
    v17[3] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", a4);
    v16[4] = v15;
    v17[4] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedLong:", *a5);
    v16[5] = *MEMORY[0x24BDD8F58];
    v17[5] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", 1);
    v16[6] = *MEMORY[0x24BDD8F10];
    v17[6] = objc_msgSend(MEMORY[0x24BDD16E0], "numberWithUnsignedInt:", a3);
    return objc_msgSend(MEMORY[0x24BDBCE70], "dictionaryWithObjects:forKeys:count:", v17, v16, 7);
  }
  return result;
}

unint64_t RB::ColorMode::ColorMode(RBColorMode)::$_0::operator()(uint64_t a1, const char *a2)
{
  char *v2;
  const char *v3;
  unsigned int v4;
  uint64_t v5;
  const char *v6;
  size_t v7;
  uint64_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x24BDAC8D0];
  v2 = RB::debug_string((RB *)"RB_COLOR_MODE", a2);
  if (v2)
  {
    v3 = v2;
    if (*v2)
    {
      v4 = 0;
      v5 = 0;
      while (1)
      {
        v6 = &v3[strspn(v3, "-,; ")];
        v7 = strcspn(v6, "-,; ");
        if (!v7)
          return v4 | (unint64_t)(v5 << 32);
        v9 = v7;
        v10 = v7 + 1;
        if (v7 + 1 > 0x1000)
        {
          v11 = (char *)malloc_type_malloc(v7 + 1, 0xB31493A2uLL);
        }
        else
        {
          MEMORY[0x24BDAC7A8](v7, v8);
          v11 = (char *)v13 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
          bzero(v11, v10);
        }
        memcpy(v11, v6, v9);
        v11[v9] = 0;
        if (strcasecmp(v11, "deep")
          && strcasecmp(v11, "wide")
          && strcasecmp(v11, "extended")
          && strcasecmp(v11, "fixed"))
        {
          if (!strcasecmp(v11, "linear"))
          {
            v5 = v5 | 1;
LABEL_23:
            v4 |= 1u;
            goto LABEL_29;
          }
          if (!strcasecmp(v11, "nonlinear"))
            goto LABEL_23;
          if (!strcasecmp(v11, "5bpc"))
          {
            v5 = v5 | 2;
          }
          else if (!strcasecmp(v11, "422"))
          {
            v5 = v5 | 4;
          }
          else
          {
            if (strcasecmp(v11, "420"))
            {
              if (!strcasecmp(v11, "pq"))
              {
                v5 = v5 | 0x20;
                v4 |= 0x20u;
              }
              else
              {
                fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Unknown RB_COLOR_MODE option: %s\n", v11);
              }
              goto LABEL_29;
            }
            v5 = v5 | 8;
          }
          v4 |= 0xEu;
        }
LABEL_29:
        if (v10 > 0x1000)
          free(v11);
        v3 = &v6[v9];
        if (!v6[v9])
          return v4 | (unint64_t)(v5 << 32);
      }
    }
  }
  v5 = 0;
  v4 = 0;
  return v4 | (unint64_t)(v5 << 32);
}

uint64_t RB::ColorMode::output_space(RB::ColorMode *this)
{
  if ((*((_DWORD *)this + 1) & 0x20) != 0)
    return 5;
  else
    return (*((_DWORD *)this + 1) & 1) == 0;
}

uint64_t RB::ColorMode::pixel_format(unsigned __int8 *a1, uint64_t a2, char a3, _BYTE *a4, BOOL *a5, _DWORD *a6)
{
  int v6;
  int v7;
  int v8;
  uint64_t result;
  BOOL v10;
  char v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;

  if ((a3 & 0x20) != 0)
    v6 = 0;
  else
    v6 = *a1;
  v7 = *((_DWORD *)a1 + 1);
  v8 = v7 & 1;
  if (a4)
    *a4 = v8 == 0;
  if (a5)
    *a5 = v8 == 0;
  if (a6)
  {
    *a6 = 0;
    v7 = *((_DWORD *)a1 + 1);
    if ((v7 & 0x10) != 0)
    {
      *a6 = 4;
      return 10;
    }
  }
  else if ((v7 & 0x10) != 0)
  {
    return 10;
  }
  if ((v6 - 1) < 3)
  {
    if (a2 && (a3 & 8) == 0 && *(unsigned __int8 *)(a2 + 283) >= 3u)
      return RB::ColorMode::pixel_format(RB::Device const*,unsigned int,RB::ColorSpace *,RB::ColorSpace *,unsigned int *)const::formats[v8 | (2 * (a3 & 1u))];
    if (a4 && v6 == 2)
    {
      v10 = v8 == 0;
      if (v8)
        v11 = 2;
      else
        v11 = 3;
      *a4 = v11;
      v12 = 2147483655;
      v13 = 2147483656;
      goto LABEL_40;
    }
    if ((a3 & 8) == 0 && v6 == 1 && (a3 & 1) == 0 && !v8)
      return 94;
    goto LABEL_38;
  }
  if (v6)
  {
LABEL_38:
    if ((v7 & 0x20) == 0)
    {
      v12 = 2147483651;
      v10 = (a3 & 0x1B) == 8;
      v13 = 115;
      goto LABEL_40;
    }
    if (a4)
      *a4 = 5;
    if (v8)
      return 2147483660;
    else
      return 2147483659;
  }
  if ((a3 & 0x1A) == 8)
  {
    if ((a3 & 1) == 0)
    {
      v14 = v8 == 0;
      if (v8)
        v15 = 2147483650;
      else
        v15 = 2147483649;
      v16 = 2147483653;
      if (v14)
        v16 = 43;
      if ((v7 & 2) != 0)
        return v16;
      else
        return v15;
    }
LABEL_66:
    if (v8)
      return 81;
    else
      return 80;
  }
  if ((a3 & 0x1A) != 2 || !a2 || (a3 & 1) != 0 || *(unsigned __int8 *)(a2 + 283) < 3u)
    goto LABEL_66;
  if ((a3 & 4) == 0 && (v7 & 8) != 0)
  {
    v10 = v8 == 0;
    v13 = 520;
    v12 = 500;
    goto LABEL_40;
  }
  if ((a3 & 4) == 0 && (v7 & 4) != 0)
  {
    v10 = v8 == 0;
    v13 = 522;
    v12 = 502;
LABEL_40:
    if (v10)
      return v12;
    else
      return v13;
  }
  if ((v7 & 2) != 0)
  {
    if (v8)
      return 2147483652;
    else
      return 40;
  }
  result = v8 ? 523 : 542;
  if ((a3 & 4) != 0)
    goto LABEL_66;
  return result;
}

uint64_t RB::color_depth_layer_format(int a1, int a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;

  if ((a1 - 1) >= 3)
  {
    v5 = 80;
    if (a2)
      v5 = 81;
    if (a1)
      return 115;
    else
      return v5;
  }
  else if (a3)
  {
    v3 = 552;
    if (a2)
      v3 = 553;
    if (*(unsigned __int8 *)(a3 + 283) <= 2u)
      return 115;
    else
      return v3;
  }
  else
  {
    return 115;
  }
}

unsigned int *_ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(unsigned int *result, unsigned int *a2, unsigned int *a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  unsigned int v8;
  __int128 v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  unsigned int v13;
  __int128 v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  unsigned int v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  unsigned int v23;
  __int128 v24;
  unsigned int v25;
  __int128 v26;

  v3 = *a2;
  v4 = *a3;
  if (v3 >= *result)
  {
    if (v4 < v3)
    {
      v10 = *((_QWORD *)a2 + 4);
      v11 = *(_OWORD *)a2;
      v12 = *((_OWORD *)a2 + 1);
      v13 = a3[8];
      v14 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v14;
      a2[8] = v13;
      *(_OWORD *)a3 = v11;
      *((_OWORD *)a3 + 1) = v12;
      a3[8] = v10;
      if (*a2 < (unint64_t)*result)
      {
        v15 = *((_QWORD *)result + 4);
        v16 = *(_OWORD *)result;
        v17 = *((_OWORD *)result + 1);
        v18 = a2[8];
        v19 = *((_OWORD *)a2 + 1);
        *(_OWORD *)result = *(_OWORD *)a2;
        *((_OWORD *)result + 1) = v19;
        result[8] = v18;
        *(_OWORD *)a2 = v16;
        *((_OWORD *)a2 + 1) = v17;
        a2[8] = v15;
      }
    }
  }
  else
  {
    if (v4 >= v3)
    {
      v20 = *((_QWORD *)result + 4);
      v21 = *(_OWORD *)result;
      v22 = *((_OWORD *)result + 1);
      v23 = a2[8];
      v24 = *((_OWORD *)a2 + 1);
      *(_OWORD *)result = *(_OWORD *)a2;
      *((_OWORD *)result + 1) = v24;
      result[8] = v23;
      *(_OWORD *)a2 = v21;
      *((_OWORD *)a2 + 1) = v22;
      a2[8] = v20;
      if (*a3 >= (unint64_t)*a2)
        return result;
      v5 = *((_QWORD *)a2 + 4);
      v6 = *(_OWORD *)a2;
      v7 = *((_OWORD *)a2 + 1);
      v25 = a3[8];
      v26 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v26;
      a2[8] = v25;
    }
    else
    {
      v5 = *((_QWORD *)result + 4);
      v6 = *(_OWORD *)result;
      v7 = *((_OWORD *)result + 1);
      v8 = a3[8];
      v9 = *((_OWORD *)a3 + 1);
      *(_OWORD *)result = *(_OWORD *)a3;
      *((_OWORD *)result + 1) = v9;
      result[8] = v8;
    }
    *(_OWORD *)a3 = v6;
    *((_OWORD *)a3 + 1) = v7;
    a3[8] = v5;
  }
  return result;
}

BOOL _ZNSt3__127__insertion_sort_incompleteB8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEbT1_SG_S9_(unsigned int *a1, unsigned int *a2)
{
  unint64_t v4;
  _BOOL8 result;
  unsigned int *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  unsigned int v10;
  __int128 v11;
  unsigned int *v12;
  unsigned int *v13;
  uint64_t v14;
  int v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  char *v19;
  __int128 v20;
  uint64_t v21;
  unsigned int *v22;
  unsigned int *v23;
  unsigned int *v24;
  unsigned int *v25;
  unsigned int v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  unsigned int v30;
  __int128 v31;
  uint64_t v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  uint64_t v36;
  __int128 v37;
  __int128 v38;
  __int128 v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  _BYTE v44[32];

  v4 = 0xCCCCCCCCCCCCCCCDLL * (((char *)a2 - (char *)a1) >> 3);
  result = 1;
  switch(v4)
  {
    case 0uLL:
    case 1uLL:
      return result;
    case 2uLL:
      v6 = a2 - 10;
      if (*(a2 - 10) < (unint64_t)*a1)
      {
        v7 = *((_QWORD *)a1 + 4);
        v8 = *(_OWORD *)a1;
        v9 = *((_OWORD *)a1 + 1);
        v10 = *(a2 - 2);
        v11 = *(_OWORD *)(a2 - 6);
        *(_OWORD *)a1 = *(_OWORD *)v6;
        *((_OWORD *)a1 + 1) = v11;
        a1[8] = v10;
        *(_OWORD *)v6 = v8;
        *(_OWORD *)(a2 - 6) = v9;
        *(a2 - 2) = v7;
      }
      return result;
    case 3uLL:
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a1 + 10, a2 - 10);
      return 1;
    case 4uLL:
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(a1, a1 + 10, a1 + 20, a2 - 10);
      return 1;
    case 5uLL:
      v22 = a1 + 10;
      v23 = a1 + 20;
      v24 = a1 + 30;
      _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(a1, a1 + 10, a1 + 20, a1 + 30);
      v26 = *(a2 - 10);
      v25 = a2 - 10;
      if (v26 >= (unint64_t)a1[30])
        return 1;
      v27 = *((_QWORD *)a1 + 19);
      v28 = *(_OWORD *)v24;
      v29 = *(_OWORD *)(a1 + 34);
      v30 = v25[8];
      v31 = *((_OWORD *)v25 + 1);
      *(_OWORD *)v24 = *(_OWORD *)v25;
      *(_OWORD *)(a1 + 34) = v31;
      a1[38] = v30;
      *(_OWORD *)v25 = v28;
      *((_OWORD *)v25 + 1) = v29;
      v25[8] = v27;
      if (*v24 >= (unint64_t)*v23)
        return 1;
      v32 = *((_QWORD *)a1 + 14);
      v34 = *(_OWORD *)v23;
      v33 = *((_OWORD *)a1 + 6);
      v35 = *(_OWORD *)(a1 + 34);
      *(_OWORD *)v23 = *(_OWORD *)v24;
      *((_OWORD *)a1 + 6) = v35;
      a1[28] = a1[38];
      *(_OWORD *)v24 = v34;
      *(_OWORD *)(a1 + 34) = v33;
      a1[38] = v32;
      if (*v23 >= (unint64_t)*v22)
        return 1;
      v36 = *((_QWORD *)a1 + 9);
      v38 = *(_OWORD *)v22;
      v37 = *(_OWORD *)(a1 + 14);
      v39 = *((_OWORD *)a1 + 6);
      *(_OWORD *)v22 = *(_OWORD *)v23;
      *(_OWORD *)(a1 + 14) = v39;
      a1[18] = a1[28];
      *(_OWORD *)v23 = v38;
      *((_OWORD *)a1 + 6) = v37;
      a1[28] = v36;
      if (a1[10] >= (unint64_t)*a1)
        return 1;
      v40 = *((_QWORD *)a1 + 4);
      v42 = *(_OWORD *)a1;
      v41 = *((_OWORD *)a1 + 1);
      v43 = *(_OWORD *)(a1 + 14);
      *(_OWORD *)a1 = *(_OWORD *)v22;
      *((_OWORD *)a1 + 1) = v43;
      a1[8] = a1[18];
      *(_OWORD *)v22 = v42;
      *(_OWORD *)(a1 + 14) = v41;
      result = 1;
      a1[18] = v40;
      return result;
    default:
      v12 = a1 + 20;
      _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a1 + 10, a1 + 20);
      v13 = a1 + 30;
      if (a1 + 30 == a2)
        return 1;
      v14 = 0;
      v15 = 0;
      break;
  }
  while (1)
  {
    v16 = *v13 | ((unint64_t)*((unsigned __int16 *)v13 + 2) << 32);
    v17 = *v13;
    if (v17 < *v12)
    {
      *(_OWORD *)v44 = *(_OWORD *)((char *)v13 + 6);
      *(_OWORD *)&v44[16] = *(_OWORD *)((char *)v13 + 22);
      v18 = v14;
      while (1)
      {
        v19 = (char *)a1 + v18;
        v20 = *(_OWORD *)((char *)a1 + v18 + 96);
        *(_OWORD *)(v19 + 120) = *(_OWORD *)((char *)a1 + v18 + 80);
        *(_OWORD *)(v19 + 136) = v20;
        *((_DWORD *)v19 + 38) = *(unsigned int *)((char *)a1 + v18 + 112);
        if (v18 == -80)
          break;
        v18 -= 40;
        if (v17 >= *((unsigned int *)v19 + 10))
        {
          v21 = (uint64_t)a1 + v18 + 120;
          goto LABEL_12;
        }
      }
      v21 = (uint64_t)a1;
LABEL_12:
      *(_DWORD *)v21 = v16;
      *(_WORD *)(v21 + 4) = WORD2(v16);
      *(_OWORD *)(v21 + 6) = *(_OWORD *)v44;
      *(_OWORD *)(v21 + 20) = *(_OWORD *)&v44[14];
      if (++v15 == 8)
        return v13 + 10 == a2;
    }
    v12 = v13;
    v14 += 40;
    v13 += 10;
    if (v13 == a2)
      return 1;
  }
}

__n128 _ZNSt3__17__sort4B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEvT1_SG_SG_SG_S9_(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  __n128 result;
  uint64_t v9;
  __int128 v10;
  unsigned int v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  unsigned int v15;
  __int128 v16;
  uint64_t v17;
  __int128 v18;
  unsigned int v19;
  __int128 v20;

  _ZNSt3__17__sort3B8nn180100INS_17_ClassicAlgPolicyERZZN2RB19pixel_format_traitsE14MTLPixelFormatENK3__0clEPvEUlRKT_RKT0_E_PNS2_17PixelFormatTraitsEEEjT1_SG_SG_S9_(a1, a2, a3);
  if (*a4 < (unint64_t)*a3)
  {
    v9 = *((_QWORD *)a3 + 4);
    result = *(__n128 *)a3;
    v10 = *((_OWORD *)a3 + 1);
    v11 = a4[8];
    v12 = *((_OWORD *)a4 + 1);
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *((_OWORD *)a3 + 1) = v12;
    a3[8] = v11;
    *(__n128 *)a4 = result;
    *((_OWORD *)a4 + 1) = v10;
    a4[8] = v9;
    if (*a3 < (unint64_t)*a2)
    {
      v13 = *((_QWORD *)a2 + 4);
      result = *(__n128 *)a2;
      v14 = *((_OWORD *)a2 + 1);
      v15 = a3[8];
      v16 = *((_OWORD *)a3 + 1);
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *((_OWORD *)a2 + 1) = v16;
      a2[8] = v15;
      *(__n128 *)a3 = result;
      *((_OWORD *)a3 + 1) = v14;
      a3[8] = v13;
      if (*a2 < (unint64_t)*a1)
      {
        v17 = *((_QWORD *)a1 + 4);
        result = *(__n128 *)a1;
        v18 = *((_OWORD *)a1 + 1);
        v19 = a2[8];
        v20 = *((_OWORD *)a2 + 1);
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *((_OWORD *)a1 + 1) = v20;
        a1[8] = v19;
        *(__n128 *)a2 = result;
        *((_OWORD *)a2 + 1) = v18;
        a2[8] = v17;
      }
    }
  }
  return result;
}

void sub_209B15538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_209B155C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_209B156D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10B1C404EFE7174);
  _Unwind_Resume(a1);
}

void sub_209B157A8(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x20BD16544](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

void sub_209B15890(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x20BD16544](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

void sub_209B1595C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10B1C404EFE7174);
  _Unwind_Resume(a1);
}

void sub_209B15A34(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x20BD16544](v2, 0x10B1C404EFE7174);

  _Unwind_Resume(a1);
}

void sub_209B163CC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  if (a27)
    -[RBEncoderSet addDisplayList:].cold.1(a27);
  if (a22)
    free(a22);
  if (a19)
    free(a19);
  _Unwind_Resume(exception_object);
}

void sub_209B166D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  void *v4;
  va_list va;

  va_start(va, a4);
  RB::Heap::~Heap((RB::Heap *)va);

  _Unwind_Resume(a1);
}

void sub_209B16AD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_209B16B34()
{
  JUMPOUT(0x209B16B14);
}

void sub_209B16B3C()
{
  JUMPOUT(0x209B16B1CLL);
}

void sub_209B16B44()
{
  JUMPOUT(0x209B16B24);
}

id __copy_helper_block_e8_40c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE(uint64_t a1, uint64_t a2)
{
  id result;

  result = *(id *)(a2 + 40);
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void __destroy_helper_block_e8_40c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE(uint64_t a1)
{

}

id __copy_helper_block_e8_32c30_ZTSN2RB8objc_ptrIP8RBDeviceEE40c30_ZTSN2RB8objc_ptrIP8RBShaderEE48c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE56c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE(_QWORD *a1, id *a2)
{
  id result;

  a1[4] = a2[4];
  a1[5] = a2[5];
  a1[6] = a2[6];
  result = a2[7];
  a1[7] = result;
  return result;
}

void sub_209B16C7C(_Unwind_Exception *a1)
{
  id *v1;

  _Unwind_Resume(a1);
}

void __destroy_helper_block_e8_32c30_ZTSN2RB8objc_ptrIP8RBDeviceEE40c30_ZTSN2RB8objc_ptrIP8RBShaderEE48c48_ZTSN2RB8objc_ptrIU13block_pointerFvP7NSErrorEEE56c61_ZTSN2RB8objc_ptrIPU28objcproto17OS_dispatch_queue8NSObjectEE(id *a1)
{

}

void *RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow(void *__dst, unint64_t a2)
{
  unint64_t v3;
  void *result;

  if (*((_QWORD *)__dst + 14) + (*((_QWORD *)__dst + 14) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 14) + (*((_QWORD *)__dst + 14) >> 1);
  result = RB::details::realloc_vector<unsigned long,24ul>(*((void **)__dst + 12), __dst, 4uLL, (unint64_t *)__dst + 14, v3);
  *((_QWORD *)__dst + 12) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,24ul>(void *__src, void *__dst, unint64_t a3, unint64_t *a4, unint64_t a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      v9 = a3;
      memcpy(__dst, __src, 24 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(24 * a5);
    v9 = v8 / 0x18;
    if (v8 / 0x18 != *a4)
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 24 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t ___ZN2RB19ObjcEncoderDelegate16encode_message_fIZ41__RBShader_encodedDataForDelegate_error__E3__2Z41__RBShader_encodedDataForDelegate_error__E3__3EEP6NSDataRKT_RKT0__block_invoke(uint64_t result)
{
  void **v1;

  v1 = *(void ***)(result + 32);
  if (v1)
  {
    if (*v1)
      free(*v1);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void RB::Decoder::~Decoder(RB::Decoder *this)
{
  void *v2;
  void *v3;

  RB::ObjectTable::~ObjectTable((RB::Decoder *)((char *)this + 184));
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
    free(v2);
  RB::UntypedTable::~UntypedTable((RB::Decoder *)((char *)this + 80));
  v3 = (void *)*((_QWORD *)this + 4);
  if (v3)
    free(v3);
}

uint64_t RB::`anonymous namespace'::render_coverage(uint64_t a1, float64x2_t *a2, uint64_t a3, char a4, unsigned int a5, _OWORD *a6, float a7)
{
  uint64_t v12;
  RB::Buffer *v18;
  uint64_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  uint64_t v24;
  __int128 v26;
  _OWORD v27[3];
  int v28;
  _OWORD v29[5];
  int v30;
  RB::Buffer *v31;
  int64x2_t v32;

  _S8 = a7;
  v28 = 0;
  memset(v27, 0, sizeof(v27));
  v26 = 0uLL;
  v12 = RB::Coverage::Primitive::set_globals(a3, (uint64_t)v29, (float32x2_t *)a1, a2, a5, &v28, (uint64_t)v27, (uint64_t)&v26);
  if ((_DWORD)v12)
  {
    __asm { FCVT            H0, S8 }
    LOWORD(v30) = _H0;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)0x54, 4uLL, 0, &v31);
    v18 = v31;
    if (v31)
    {
      v19 = *((_QWORD *)v31 + 7) + v32.i64[0];
      v20 = v29[0];
      *(_OWORD *)(v19 + 16) = v29[1];
      v21 = v29[4];
      v22 = v29[3];
      v23 = v29[2];
      *(_DWORD *)(v19 + 80) = v30;
      *(_OWORD *)(v19 + 48) = v22;
      *(_OWORD *)(v19 + 64) = v21;
      *(_OWORD *)(v19 + 32) = v23;
      *(_OWORD *)v19 = v20;
    }
    else
    {
      v31 = 0;
      v32 = 0uLL;
    }
    *(_DWORD *)(a1 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v18);
    *(int32x2_t *)(a1 + 188) = vmovn_s64(v32);
    LODWORD(v31) = v28 & 0xF;
    RB::Coverage::Primitive::set_coverage_state(a3, &v31);
    v24 = *(_DWORD *)(a1 + 136) == 2;
    RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((((unsigned __int16)v31 & 0x3FF) << 12) | ((a4 & 0x3F) << 6) | 4u | (unint64_t)(v24 << 33)), 4, (uint64_t)v27, 0, 1uLL, *(int32x2_t *)&v26, *(int32x2_t *)((char *)&v26 + 8));
    if (*((_QWORD *)&v27[1] + 1))
    {
      LODWORD(v31) = v31 & 0xFFFFFFF0 | 1;
      RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, (const char *)((v24 << 33) | ((a4 & 0x3F) << 6) | ((_DWORD)v31 << 12) & 0x3FF000 | 4u), 4, (uint64_t)&v27[1] + 8, 0, 1uLL, *(int32x2_t *)&v26, *(int32x2_t *)((char *)&v26 + 8));
    }
    *(_QWORD *)(a1 + 200) = 0;
    *(_DWORD *)(a1 + 196) = 0;
    if (a6)
      *a6 = v26;
  }
  return v12;
}

void RB::render_primitive(uint64_t a1, float64x2_t *a2, uint64_t a3, int32x2_t *a4, __int32 a5, unsigned int a6, float a7)
{
  unsigned int *v14;
  __int128 v15;

  v14 = RB::pixel_format_traits(*(_QWORD *)(a1 + 88), (MTLPixelFormat)a2);
  if (((*v14 | ((unint64_t)*((unsigned __int16 *)v14 + 2) << 32)) & 0x4000000000) != 0)
  {
    *(_BYTE *)(a1 + 176) = 1;
    *(_DWORD *)(a1 + 180) = 1;
    v15 = 0uLL;
    {
      *(_BYTE *)(a1 + 176) = 6;
      *(_DWORD *)(a1 + 180) = 0;
      RB::render_mesh_gradient((RB::RenderPass *)a1, a2, a4, 0, a5, a6, (int32x2_t *)&v15, a7);
    }
    *(_BYTE *)(a1 + 176) = 0;
    *(_DWORD *)(a1 + 180) = 0;
  }
  else
  {
    v15 = 0uLL;
      RB::render_mesh_gradient((RB::RenderPass *)a1, a2, a4, 0, a5, a6, (int32x2_t *)&v15, a7);
  }
}

void RB::render_primitive(RB::RenderPass *a1, float32x4_t *a2, uint64_t a3, RB::Fill::Custom *this, int a5, unsigned int a6, float a7)
{
  uint64_t *v14;
  Function *v15;
  float32x2_t *v16;
  _BOOL4 v17;
  const char *v18;
  unsigned int v19;
  int32x2_t v20;
  int32x2_t v21;
  _OWORD v22[3];
  int v23;
  RB::Buffer *v24;
  int64x2_t v25;

  v14 = RB::Fill::Custom::function(this, (uint64_t **)a1);
  if (v14)
  {
    v15 = (Function *)v14;
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a1, (RB::Device *)(*((unsigned int *)v14 + 20) + 108), 4uLL, 0, &v24);
    if (v24)
    {
      v16 = (float32x2_t *)(*((_QWORD *)v24 + 7) + v25.i64[0]);
      v23 = 0;
      memset(v22, 0, sizeof(v22));
      v20 = 0;
      v21 = 0;
      if (RB::Coverage::Primitive::set_globals(a3, (uint64_t)v16, (float32x2_t *)a1, (float64x2_t *)a2, a6, &v23, (uint64_t)v22, (uint64_t)&v20))
      {
        if (RB::Fill::Custom::set_custom((uint64_t)this, v16 + 10, (uint64_t)v15, (uint64_t)&v16[13] + 4, (uint64_t)a1, a2, a7))
        {
          *((_DWORD *)a1 + 46) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a1, v24);
          *(int32x2_t *)((char *)a1 + 188) = vmovn_s64(v25);
          v19 = v23 & 0xF;
          RB::Coverage::Primitive::set_coverage_state(a3, &v19);
          v17 = *((_DWORD *)a1 + 34) == 2;
          LODWORD(v18) = ((v19 & 0x3FF) << 12) | ((a6 & 0x3F) << 6) | 8;
          HIDWORD(v18) = a5 | (2 * v17);
          RB::Fill::Custom::set_fill_state(this, (RB::RenderState *)&v18, v15, (unint64_t **)a1);
          RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v18, 4, (uint64_t)v22, 0, 1uLL, v20, v21);
          if (*((_QWORD *)&v22[1] + 1))
          {
            v19 = v19 & 0xFFFFFFF0 | 1;
            LODWORD(v18) = (v19 << 12) & 0x3FF000 | v18 & 0xFFC00FFF;
            RB::RenderPass::draw_indexed_primitives((int32x2_t *)a1, v18, 4, (uint64_t)&v22[1] + 8, 0, 1uLL, v20, v21);
          }
          *((_QWORD *)a1 + 25) = 0;
          *((_DWORD *)a1 + 49) = 0;
          RB::Fill::Custom::reset_custom(this, a1);
        }
      }
    }
  }
}

double CG::LineSegment::index(float64x2_t *this, double a2)
{
  double v2;
  float64x2_t v3;
  double v4;

  v2 = 0.0;
  if (a2 > 0.0)
  {
    v3 = vsubq_f64(this[1], *this);
    v4 = sqrt(vaddvq_f64(vmulq_f64(v3, v3)));
    if (v4 <= a2)
      return 1.0;
    else
      return a2 / v4;
  }
  return v2;
}

__n128 CG::LineSegment::split@<Q0>(float64x2_t *this@<X0>, double a2@<D0>, uint64_t a3@<X8>)
{
  float64x2_t v3;
  __n128 result;

  v3 = vmlaq_n_f64(*this, vsubq_f64(this[1], *this), a2);
  result = (__n128)this[1];
  *(float64x2_t *)a3 = *this;
  *(float64x2_t *)(a3 + 16) = v3;
  *(float64x2_t *)(a3 + 32) = v3;
  *(__n128 *)(a3 + 48) = result;
  return result;
}

BOOL RB::Filter::ColorMatrix::append(uint64_t a1, int a2, float16x4_t *a3)
{
  __int128 v5;
  _OWORD v7[2];
  uint64_t v8;

  if (a2 == 1)
  {
    RB::operator*(a3 + 1, (int16x4_t *)(a1 + 8), (float16x4_t *)v7);
    v5 = v7[1];
    *(_OWORD *)(a1 + 8) = v7[0];
    *(_OWORD *)(a1 + 24) = v5;
    *(_QWORD *)(a1 + 40) = v8;
  }
  return a2 == 1;
}

BOOL RB::Filter::ColorMatrix::can_discard_color(RB::Filter::ColorMatrix *this, BOOL *a2)
{
  RB::ColorMatrix *v3;
  BOOL is_alpha_identity;

  v3 = (RB::Filter::ColorMatrix *)((char *)this + 8);
  is_alpha_identity = RB::ColorMatrix::is_alpha_identity((RB::Filter::ColorMatrix *)((char *)this + 8));
  *a2 = is_alpha_identity;
  return is_alpha_identity || !RB::ColorMatrix::is_alpha_color_dependent(v3);
}

uint64_t RB::Filter::ColorMatrix::can_mix(float16x4_t *this, RB::DisplayList::Interpolator::Contents *a2, float16x4_t *a3)
{
  if (!a3)
    return 2;
  if (this->i32[0] != a3->i32[0])
    return 0;
  if (RB::ColorMatrix::operator==(this + 1, a3 + 1))
    return 4;
  return 2;
}

float16x4_t RB::Filter::ColorMatrix::mix(float16x4_t *this, const RB::DisplayList::Interpolator::State *a2, const RB::Filter::ColorMatrix *a3, const RB::DisplayList::CachedTransform *a4)
{
  __int128 v7;
  float16x4_t v12;
  float16x4_t v13;
  float32x4_t v14;
  float32x4_t v16;
  float32x4_t v17;
  float16x4_t v19;
  float32x4_t v20;
  float32x4_t v22;
  float32x4_t v24;
  float16x4_t result;
  __int128 v26;
  __int128 v27;
  float16x4_t v28;

  if (a3)
  {
    _Q0 = *(_OWORD *)((char *)a3 + 8);
    v7 = *(_OWORD *)((char *)a3 + 24);
    v26 = _Q0;
    v27 = v7;
    v28 = *(float16x4_t *)((char *)a3 + 40);
  }
  else
  {
    *(double *)&_Q0 = RB::ColorMatrix::set_identity((RB::ColorMatrix *)&v26);
  }
  LODWORD(_Q0) = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  v12 = *(float16x4_t *)((char *)&v26 + 8);
  v13 = this[2];
  v14 = vcvtq_f32_f16(this[1]);
  _D0 = (int16x4_t)vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)&_Q0, 0)), vcvtq_f32_f16(vcvt_f16_f32(vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)&v26), v14)))))), v14));
  this[1] = (float16x4_t)_D0;
  _D0.i32[0] = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  v16 = vcvtq_f32_f16(v12);
  v17 = vcvtq_f32_f16(v13);
  _D0 = (int16x4_t)vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D0, 0)), vcvtq_f32_f16(vcvt_f16_f32(vsubq_f32(v16, v17)))))), v17));
  this[2] = (float16x4_t)_D0;
  _D0.i32[0] = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  v17.i64[0] = *((_QWORD *)&v27 + 1);
  v19 = this[4];
  v20 = vcvtq_f32_f16(this[3]);
  _D0 = (int16x4_t)vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D0, 0)), vcvtq_f32_f16(vcvt_f16_f32(vsubq_f32(vcvtq_f32_f16(*(float16x4_t *)&v27), v20)))))), v20));
  this[3] = (float16x4_t)_D0;
  _D0.i32[0] = *((_DWORD *)a2 + 4);
  __asm { FCVT            H0, S0 }
  v22 = vcvtq_f32_f16(*(float16x4_t *)v17.f32);
  _Q2 = vcvtq_f32_f16(v19);
  this[4] = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(_D0, 0)), vcvtq_f32_f16(vcvt_f16_f32(vsubq_f32(v22, _Q2)))))), _Q2));
  _Q2.i32[0] = *((_DWORD *)a2 + 4);
  __asm { FCVT            H2, S2 }
  v24 = vcvtq_f32_f16(this[5]);
  result = vcvt_f16_f32(vaddq_f32(vcvtq_f32_f16(vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(*(int16x4_t *)_Q2.f32, 0)), vcvtq_f32_f16(vcvt_f16_f32(vsubq_f32(vcvtq_f32_f16(v28), v24)))))), v24));
  this[5] = result;
  return result;
}

int32x2_t RB::Filter::ColorMatrix::dod(RB::Filter::ColorMatrix *this, int32x2_t *a2)
{
  int32x2_t result;

  _H0 = *((_WORD *)this + 23);
  __asm { FCVT            S0, H0 }
  if (*(float *)result.i32 != 0.0)
  {
    result = vdup_n_s32(0x7F7FFFFFu);
    *a2 = (int32x2_t)0x100000001000000;
    a2[1] = result;
  }
  return result;
}

uint64_t RB::Filter::ColorMatrix::set_globals(uint64_t a1, uint64_t a2, uint64_t a3, _DWORD *a4, int32x2_t a5)
{
  float16x4_t v8;
  float16x4_t v9;
  __n64 v10;
  float16x4_t v11;
  unsigned __int8 v12;
  uint64_t i;
  unsigned int v14;
  int v15;

  RB::Coverage::set_plane((float32x2_t *)a3, a2, a5);
  if (RB::ColorMatrix::is_diagonal((float16x4_t *)(a1 + 8)))
  {
    v8 = *(float16x4_t *)(a1 + 8);
    v8.i16[1] = WORD1(*(_QWORD *)(a1 + 16));
    v8.i16[2] = WORD2(*(_QWORD *)(a1 + 24));
    v8.i16[3] = HIWORD(*(_QWORD *)(a1 + 32));
    if ((*(_BYTE *)a1 & 4) != 0)
    {
      *a4 = *a4 & 0xFFFFFFF3 | (4 * (*a4 & 1));
    }
    else if ((*a4 & 8) == 0 && (*a4 & 5) != 1)
    {
      v9 = (float16x4_t)vdup_lane_s16(*(int16x4_t *)(a1 + 32), 3);
      v9.i16[3] = unk_209BD6A90;
      v8 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v8), vcvtq_f32_f16(v9)));
    }
    v12 = 0;
    *(float16x4_t *)(a3 + 28) = v8;
  }
  else if (RB::ColorMatrix::is_alpha_multiply((float16x4_t *)(a1 + 8), (*(_DWORD *)a1 & 4) != 0))
  {
    v10.n64_u64[0] = RB::ColorMatrix::alpha_multiply_color((RB::ColorMatrix *)(a1 + 8), (*(_DWORD *)a1 & 4) != 0).n64_u64[0];
    if ((*(_BYTE *)a1 & 4) != 0)
    {
      *a4 = *a4 & 0xFFFFFFF3 | (4 * (*a4 & 1));
    }
    else if ((*a4 & 8) == 0 && (*a4 & 5) != 1)
    {
      v11 = (float16x4_t)vdup_lane_s16((int16x4_t)v10.n64_u64[0], 3);
      v11.i16[3] = unk_209BD6A90;
      v10.n64_u64[0] = (unint64_t)vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16(v11), vcvtq_f32_f16((float16x4_t)v10.n64_u64[0])));
    }
    *(__n64 *)(a3 + 28) = v10;
    return 1;
  }
  else
  {
    for (i = 0; i != 40; i += 8)
      *(_QWORD *)(a3 + 28 + i) = *(_QWORD *)(a1 + i + 8);
    if (RB::ColorMatrix::has_alpha((float16x4_t *)(a1 + 8)))
    {
      v14 = *a4 & 0xFFFFFFF3;
      v15 = ((8 * (*a4 & 1)) | v14) ^ 8;
      if ((*(_BYTE *)a1 & 4) != 0)
        v15 = (4 * (*a4 & 1)) | v14;
      *a4 = v15;
      return 4;
    }
    else if ((vmaxv_u16((uint16x4_t)vmovn_s32((int32x4_t)vmvnq_s8((int8x16_t)vceqzq_f32(vcvtq_f32_f16(*(float16x4_t *)(a1 + 40)))))) & 0x8000) != 0)
    {
      return 3;
    }
    else
    {
      return 2;
    }
  }
  return v12;
}

int32x2_t *RB::Filter::ColorMatrix::render(_DWORD *a1, MTLPixelFormat a2, uint64_t a3, uint64_t a4)
{
  int32x2_t v7;
  char v8;
  __int16 v9;
  RB::Buffer *v10;
  uint64_t v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _OWORD v16[4];
  int v17;
  int v18;
  RB::Buffer *v19;
  int64x2_t v20;

  v18 = 0;
  v8 = RB::Filter::ColorMatrix::set_globals((uint64_t)a1, a2, (uint64_t)v16, &v18, v7);
  v9 = v18;
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a2, (RB::Device *)0x44, 4uLL, 0, &v19);
  v10 = v19;
  if (v19)
  {
    v11 = *((_QWORD *)v19 + 7) + v20.i64[0];
    v13 = v16[2];
    v12 = v16[3];
    v14 = v16[1];
    *(_DWORD *)(v11 + 64) = v17;
    *(_OWORD *)(v11 + 32) = v13;
    *(_OWORD *)(v11 + 48) = v12;
    *(_OWORD *)(v11 + 16) = v14;
    *(_OWORD *)v11 = v16[0];
  }
  else
  {
    v19 = 0;
    v20 = 0uLL;
  }
  *(_DWORD *)(a2 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a2, v10);
  *(int32x2_t *)(a2 + 188) = vmovn_s64(v20);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)(a4 & 0xFFFFFFFF00000000 | a4 & 0x3FFFFF | ((unsigned __int16)(v9 & 0xFF8F | (16 * (v8 & 0xF))) << 22)), 4, ***(_QWORD ***)a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
}

uint64_t RB::Filter::`anonymous namespace'::set_color_fill_state(_DWORD *a1, MTLPixelFormat a2, char a3)
{
  uint64_t v4;
  int v5;

  v4 = *(unsigned __int8 *)(a2 + 124);
  if ((a3 & 1) != 0 && (v4 & 1) != 0)
  {
    *a1 |= 3u;
    return v4 & 0xFE;
  }
  else if ((a3 & 2) != 0 && (v4 & 1) == 0)
  {
    if (RB::RenderParams::srgb_alpha(*(RB::RenderParams **)a2, a2))
      v5 = 2;
    else
      v5 = 3;
    *a1 |= v5;
    return v4 | 1;
  }
  return v4;
}

uint64_t RB::Filter::ColorMatrix::render(float16x4_t *a1, uint64_t a2, MTLPixelFormat a3)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;

  result = RB::ColorMatrix::is_identity(a1 + 1);
  if ((result & 1) == 0)
  {
    if (*(_DWORD *)(a3 + 136) == 2)
      v7 = 0x20000001DLL;
    else
      v7 = 29;
    return (uint64_t)RB::Filter::ColorMatrix::render(a1, a3, v6, v7);
  }
  return result;
}

uint64_t RB::Filter::ColorMatrix::render(uint64_t result, MTLPixelFormat a2, uint64_t a3, int a4, unsigned int a5, float32_t a6)
{
  char v7;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];
  uint64_t v14;
  uint64_t v15;

  v7 = a4;
  v10 = (uint64_t *)result;
  v15 = *MEMORY[0x24BDAC8D0];
  if (a4 != 24 && a4 != 2 || (result = RB::ColorMatrix::is_identity((float16x4_t *)(result + 8)), (result & 1) == 0))
  {
    v11 = a5 | (2 * (*(_DWORD *)(a2 + 136) == 2));
    if (a6 != 1.0)
    {
      MEMORY[0x24BDAC7A8](result, a2);
      v12 = 0;
      LODWORD(v12) = *(_DWORD *)v10;
      v13[0] = *(_OWORD *)(v10 + 1);
      v13[1] = *(_OWORD *)(v10 + 3);
      v14 = v10[5];
      RB::ColorMatrix::multiply_color((float16x4_t *)v13, 1.0, 1.0, 1.0, a6, (v12 >> 2) & 1);
      v10 = &v12;
    }
    return (uint64_t)RB::Filter::ColorMatrix::render(v10, a2, a3, ((v7 & 0x3F) << 6) | 0x1Du | (unint64_t)(v11 << 32));
  }
  return result;
}

_QWORD *RB::Filter::ColorMatrix::encode(RB::Filter::ColorMatrix *this, RB::Encoder *a2)
{
  _QWORD *v4;
  _QWORD *result;
  int v6;

  v4 = (_QWORD *)((char *)this + 8);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::ColorMatrix::encode(v4, a2);
  result = RB::ProtobufEncoder::end_length_delimited(a2);
  v6 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x10uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v6 = *(_DWORD *)this;
    if ((*(_DWORD *)this & 2) == 0)
    {
LABEL_3:
      if ((v6 & 4) == 0)
        return result;
LABEL_7:
      RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
      return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
  }
  else if ((v6 & 2) == 0)
  {
    goto LABEL_3;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
  result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((*(_DWORD *)this & 4) != 0)
    goto LABEL_7;
  return result;
}

unint64_t RB::Filter::ColorMatrix::decode(_DWORD *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  int v6;
  int v7;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(this);
            RB::ColorMatrix::decode((RB::ColorMatrix *)(a1 + 2), this);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *(_QWORD *)this = *((_QWORD *)this + 1);
          }
          break;
        case 2u:
          v6 = *a1 | RB::ProtobufDecoder::BOOL_field(this, v5);
          goto LABEL_15;
        case 3u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 2;
          else
            v7 = 0;
          goto LABEL_14;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 4;
          else
            v7 = 0;
LABEL_14:
          v6 = *a1 | v7;
LABEL_15:
          *a1 = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::ColorMatrix::print(float16x4_t *this, std::string *a2)
{
  const char *v4;

  if (!this->i32[0])
    goto LABEL_7;
  RB::SexpString::push(a2, "color-matrix");
  if ((this->i32[0] & 1) != 0)
  {
    v4 = "linear";
  }
  else
  {
    if ((this->i32[0] & 2) == 0)
      goto LABEL_7;
    v4 = "non-linear";
  }
  RB::SexpString::print(a2, 0, v4);
LABEL_7:
  RB::ColorMatrix::print(this + 1, a2);
  if (this->i32[0])
    RB::SexpString::pop(a2);
}

uint64_t RB::Filter::LuminanceCurve::can_discard_color(RB::Filter::LuminanceCurve *this, BOOL *a2)
{
  *a2 = 1;
  return 1;
}

uint64_t RB::Filter::LuminanceCurve::can_mix(float32x4_t *this, RB::DisplayList::Interpolator::Contents *a2, float32x4_t *a3)
{
  unsigned int v3;
  unsigned int can_mix;

  if (a3)
  {
    if (this->i32[0] == a3->i32[0])
    {
      if ((vminvq_u32((uint32x4_t)vceqq_f32(this[1], a3[1])) & 0x80000000) == 0)
        v3 = 2;
      else
        v3 = 4;
      can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)&this[2], (const RB::Fill::Color *)&a3[2]);
      if (can_mix >= v3)
        return v3;
      else
        return can_mix;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    _H0 = this[2].i16[3];
    __asm { FCVT            S0, H0 }
    if (_S0 == 0.0)
      return 4;
    else
      return 2;
  }
}

__int16 RB::Filter::LuminanceCurve::mix@<H0>(RB::Filter::LuminanceCurve *this@<X0>, const RB::DisplayList::Interpolator::State *a2@<X1>, const RB::Filter::LuminanceCurve *a3@<X2>, const RB::DisplayList::CachedTransform *a4@<X3>, double a5@<D0>, double a6@<D1>, double a7@<D2>, double a8@<D3>, double a9@<D4>, int8x16_t a10@<Q5>)
{
  float32x4_t v10;
  __int128 v11;
  int8x16_t v12;
  int8x16_t v13;
  __int16 result;

  if (a3)
  {
    v10 = *((float32x4_t *)this + 1);
    v11 = *((_OWORD *)a2 + 1);
    v12 = (int8x16_t)vsubq_f32(*((float32x4_t *)a3 + 1), v10);
    v13 = (int8x16_t)vmlaq_n_f32(v10, (float32x4_t)v12, *(float *)&v11);
    *((int8x16_t *)this + 1) = v13;
    v13.i32[0] = *((_DWORD *)a2 + 4);
    RB::Fill::Color::mix((float16x4_t *)this + 4, (float16x4_t *)a3 + 4, 0, v13, v12, *(double *)&v11, a8, a9, a10);
  }
  else
  {
    _H0 = *((_WORD *)this + 19);
    _S1 = *((_DWORD *)a2 + 4);
    __asm
    {
      FCVT            H1, S1
      FCVT            S0, H0
      FCVT            S1, H1
    }
    _S0 = _S0 - (float)(_S1 * _S0);
    __asm { FCVT            H0, S0 }
    *((_WORD *)this + 19) = result;
  }
  return result;
}

int32x2_t *RB::Filter::LuminanceCurve::render(int32x2_t *result, uint64_t a2, MTLPixelFormat a3)
{
  float32x4_t *v10;
  int v11;
  int32x2_t v12;
  unsigned int v13;
  uint64_t v14;
  float32x4_t v15;
  float v16;
  float v17;
  float32x4_t v18;
  int16x4_t v19;
  uint16x4_t v20;
  float16x4_t v21;
  float16x4_t v22;
  RB::Buffer *v26;
  uint64_t v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;
  float v31;
  __int32 v32;
  unsigned int v33;
  uint64_t v34;
  __int128 v35;
  _BYTE v36[32];
  __int128 v37;
  int v38;
  int v39;
  unint64_t v40;
  int64x2_t v41;

  _H0 = result[4].i16[3];
  __asm { FCVT            S0, H0 }
  if (_S0 != 0.0)
  {
    v10 = (float32x4_t *)result;
    v39 = 80;
    if ((v10->i8[0] & 4) != 0)
      v13 = (4 * (v39 & 1)) | v39 & 0xFFFFFFF3;
    else
      v13 = ((8 * (v39 & 1)) | v39 & 0xFFFFFFF3) ^ 8;
    v14 = *(_DWORD *)(a3 + 136) == 2;
    v15 = v10[1];
    v12.i32[0] = HIDWORD(v10[1].i64[0]);
    v16 = COERCE_FLOAT(v10[1].i64[1]);
    *(float *)&v33 = vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v15, 3), v15).f32[0]
                   + (float)((float)(*(float *)v12.i32 - v16) * 3.0);
    v34 = v15.i64[0];
    v17 = (float)((float)(v16 + v15.f32[0]) - (float)(*(float *)v12.i32 + *(float *)v12.i32)) * 3.0;
    *(float *)v12.i32 = (float)(*(float *)v12.i32 - v15.f32[0]) * 3.0;
    v31 = v17;
    v32 = v12.i32[0];
    RB::Coverage::set_plane((float32x2_t *)&v35, a3, v12);
    v18.i64[0] = __PAIR64__(LODWORD(v31), v33);
    v18.i64[1] = __PAIR64__(v34, v32);
    v19 = (int16x4_t)v34;
    v20 = (uint16x4_t)vcvt_f16_f32(v18);
    *(uint16x4_t *)&v36[12] = v20;
    if (v10[2].i8[9] && v10[2].u8[8] != v11)
    {
      v40 = v10[2].u64[0];
      v41.i16[0] = v10[2].i16[4];
      RB::Fill::Color::convert((uint64_t)&v40, v11, v20);
      v21.i16[3] = 15360;
      v21.i32[0] = v40;
      v21.i16[2] = WORD2(v40);
      v19.i32[0] = HIWORD(v40);
    }
    else
    {
      v21.i32[0] = v10[2].i32[0];
      v21.i16[2] = v10[2].i16[2];
      v21.i16[3] = unk_209BD6A96;
      v19.i16[0] = v10[2].i16[3];
    }
    v22 = vcvt_f16_f32(vmulq_f32(vcvtq_f32_f16((float16x4_t)vdup_lane_s16(v19, 0)), vcvtq_f32_f16(v21)));
    _H1 = v22.i16[3];
    __asm { FCVT            S1, H1 }
    _S1 = 1.0 - _S1;
    __asm { FCVT            H1, S1 }
    *(_DWORD *)&v36[20] = v22.i32[0];
    *(_WORD *)&v36[24] = v22.i16[2];
    *(_WORD *)&v36[26] = LOWORD(_S1);
    RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a3, (RB::Device *)0x44, 4uLL, 0, &v40);
    v26 = (RB::Buffer *)v40;
    if (v40)
    {
      v27 = *(_QWORD *)(v40 + 56) + v41.i64[0];
      v29 = *(_OWORD *)&v36[16];
      v28 = v37;
      v30 = *(_OWORD *)v36;
      *(_DWORD *)(v27 + 64) = v38;
      *(_OWORD *)(v27 + 32) = v29;
      *(_OWORD *)(v27 + 48) = v28;
      *(_OWORD *)(v27 + 16) = v30;
      *(_OWORD *)v27 = v35;
    }
    else
    {
      v40 = 0;
      v41 = 0uLL;
    }
    *(_DWORD *)(a3 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a3, v26);
    *(int32x2_t *)(a3 + 188) = vmovn_s64(v41);
    return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a3, (const char *)((v14 << 33) | (v13 << 22) | 0x1D), 4, ***(_QWORD ***)a3 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
  }
  return result;
}

_QWORD *RB::Filter::LuminanceCurve::encode(float32x4_t *this, RB::Encoder *a2)
{
  _QWORD *result;
  __int32 v5;

  RB::ProtobufEncoder::float4_field(a2, 1, this[1]);
  RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::Fill::Color::encode((RB::Fill::Color *)&this[2], a2);
  result = RB::ProtobufEncoder::end_length_delimited(a2);
  v5 = this->i32[0];
  if ((this->i32[0] & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v5 = this->i32[0];
    if ((this->i32[0] & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        return result;
LABEL_7:
      RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
      return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
  result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((this->i32[0] & 4) != 0)
    goto LABEL_7;
  return result;
}

unint64_t RB::Filter::LuminanceCurve::decode(__n128 *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unsigned __int32 v6;
  int v7;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          a1[1] = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 2u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(this);
            RB::Fill::Color::decode((uint64_t)&a1[2], this);
            RB::ProtobufDecoder::end_message((uint64_t)this);
          }
          else
          {
            *((_BYTE *)this + 56) = 1;
            *(_QWORD *)this = *((_QWORD *)this + 1);
          }
          break;
        case 3u:
          v6 = a1->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(this, v5);
          goto LABEL_16;
        case 4u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 2;
          else
            v7 = 0;
          goto LABEL_15;
        case 5u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 4;
          else
            v7 = 0;
LABEL_15:
          v6 = a1->n128_u32[0] | v7;
LABEL_16:
          a1->n128_u32[0] = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::LuminanceCurve::print(RB::Filter::LuminanceCurve *this, std::string *a2)
{
  const char *v4;

  RB::SexpString::push(a2, "luminance-curve");
  if ((*(_DWORD *)this & 1) != 0)
  {
    v4 = "linear";
    goto LABEL_5;
  }
  if ((*(_DWORD *)this & 2) != 0)
  {
    v4 = "non-linear";
LABEL_5:
    RB::SexpString::print(a2, 0, v4);
  }
  RB::SexpString::printf(a2, 1, "(curve %g %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6), *((float *)this + 7));
  _H0 = *((_WORD *)this + 16);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_10;
  _H1 = *((_WORD *)this + 17);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
    goto LABEL_10;
  _H0 = *((_WORD *)this + 18);
  __asm { FCVT            S1, H0 }
  if (_S1 != 1.0)
    goto LABEL_10;
  _H1 = *((_WORD *)this + 19);
  __asm { FCVT            S1, H1 }
  if (_S1 != 1.0)
LABEL_10:
    RB::Fill::Color::print((RB::Filter::LuminanceCurve *)((char *)this + 32), a2);
  RB::SexpString::pop(a2);
}

uint64_t RB::Filter::RGBACurves::can_mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  if (!a3)
    return 2;
  if (a1->i32[0] != a3->i32[0])
    return 0;
  if ((vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f32(a1[2], a3[2]), (int8x16_t)vceqq_f32(a1[1], a3[1])), vandq_s8((int8x16_t)vceqq_f32(a1[3], a3[3]), (int8x16_t)vceqq_f32(a1[4], a3[4])))) & 0x80000000) == 0)return 2;
  return 4;
}

__n128 RB::Filter::RGBACurves::mix(float32x4_t *a1, uint64_t a2, float32x4_t *a3)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  __n128 result;

  if (a3)
  {
    v3 = a3[1];
    v4 = a3[2];
    v5 = a3[3];
    v6 = a3[4];
  }
  else
  {
    v3 = (float32x4_t)xmmword_209BD6AC0;
    v4 = (float32x4_t)xmmword_209BD6AC0;
    v5 = (float32x4_t)xmmword_209BD6AC0;
    v6 = (float32x4_t)xmmword_209BD6AC0;
  }
  v7 = a1[2];
  a1[1] = vmlaq_n_f32(a1[1], vsubq_f32(v3, a1[1]), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  a1[2] = vmlaq_n_f32(v7, vsubq_f32(v4, v7), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  v8 = a1[4];
  a1[3] = vmlaq_n_f32(a1[3], vsubq_f32(v5, a1[3]), COERCE_FLOAT(*(_OWORD *)(a2 + 16)));
  result = *(__n128 *)(a2 + 16);
  a1[4] = vmlaq_n_f32(v8, vsubq_f32(v6, v8), result.n128_f32[0]);
  return result;
}

int32x2_t *RB::Filter::RGBACurves::render(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  const float *v4;
  char v5;
  int v6;
  int v7;
  RB::Buffer *v13;
  uint64_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  __int128 v24;
  _BYTE v25[48];
  int v26;
  RB::Buffer *v27;
  int64x2_t v28;
  float32x4x4_t v29;

  v6 = *a1;
  v4 = (const float *)(a1 + 4);
  v5 = v6;
  v29 = vld4q_f32(v4);
  v23 = v29.val[0];
  v7 = *(_DWORD *)(a3 + 136);
  __asm { FMOV            V1.4S, #3.0 }
  v22 = vmlaq_f32(vsubq_f32(v29.val[3], v29.val[0]), _Q1, vsubq_f32(v29.val[1], v29.val[2]));
  v20 = vmulq_f32(vsubq_f32(v29.val[1], v29.val[0]), _Q1);
  v21 = vmulq_f32(vsubq_f32(vaddq_f32(v29.val[2], v29.val[0]), vaddq_f32(v29.val[1], v29.val[1])), _Q1);
  RB::Coverage::set_plane((float32x2_t *)&v24, a3, *(int32x2_t *)v20.f32);
  *(float16x8_t *)&v25[12] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v22), v21);
  *(float16x8_t *)&v25[28] = vcvt_hight_f16_f32((int16x4_t)vcvt_f16_f32(v20), v23);
  RB::RenderFrame::alloc_buffer_region(**(RB::RenderFrame ***)a3, (RB::Device *)0x44, 4uLL, 0, &v27);
  v13 = v27;
  if (v27)
  {
    v14 = *((_QWORD *)v27 + 7) + v28.i64[0];
    v15 = *(_OWORD *)&v25[32];
    v16 = *(_OWORD *)&v25[16];
    v17 = *(_OWORD *)v25;
    *(_DWORD *)(v14 + 64) = v26;
    *(_OWORD *)(v14 + 32) = v16;
    *(_OWORD *)(v14 + 48) = v15;
    *(_OWORD *)(v14 + 16) = v17;
    *(_OWORD *)v14 = v24;
  }
  else
  {
    v27 = 0;
    v28 = 0uLL;
  }
  if ((v5 & 4) != 0)
    v18 = 402653213;
  else
    v18 = 436207645;
  *(_DWORD *)(a3 + 184) = RB::RenderFrame::buffer_id(**(RB::RenderFrame ***)a3, v13);
  *(int32x2_t *)(a3 + 188) = vmovn_s64(v28);
  return RB::RenderPass::draw_indexed_primitives((int32x2_t *)a3, (const char *)(v18 | ((unint64_t)(v7 == 2) << 33)), 4, ***(_QWORD ***)a3 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
}

_QWORD *RB::Filter::RGBACurves::encode(float32x4_t *this, RB::Encoder *a2)
{
  _QWORD *result;
  __int32 v5;

  RB::ProtobufEncoder::float4_field(a2, 1, this[1]);
  RB::ProtobufEncoder::float4_field(a2, 2, this[2]);
  RB::ProtobufEncoder::float4_field(a2, 3, this[3]);
  result = RB::ProtobufEncoder::float4_field(a2, 4, this[4]);
  v5 = this->i32[0];
  if ((this->i32[0] & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x28uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v5 = this->i32[0];
    if ((this->i32[0] & 2) == 0)
    {
LABEL_3:
      if ((v5 & 4) == 0)
        return result;
LABEL_7:
      RB::ProtobufEncoder::encode_varint(a2, 0x38uLL);
      return RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    }
  }
  else if ((v5 & 2) == 0)
  {
    goto LABEL_3;
  }
  RB::ProtobufEncoder::encode_varint(a2, 0x30uLL);
  result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  if ((this->i32[0] & 4) != 0)
    goto LABEL_7;
  return result;
}

unint64_t RB::Filter::RGBACurves::decode(__n128 *a1, RB::ProtobufDecoder *this)
{
  unint64_t result;
  unint64_t v5;
  unsigned __int32 v6;
  int v7;

  result = RB::ProtobufDecoder::next_field(this);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          a1[1] = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 2u:
          a1[2] = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 3u:
          a1[3] = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 4u:
          a1[4] = RB::ProtobufDecoder::float4_field(this, v5);
          break;
        case 5u:
          v6 = a1->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(this, v5);
          goto LABEL_17;
        case 6u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 2;
          else
            v7 = 0;
          goto LABEL_16;
        case 7u:
          if (RB::ProtobufDecoder::BOOL_field(this, v5))
            v7 = 4;
          else
            v7 = 0;
LABEL_16:
          v6 = a1->n128_u32[0] | v7;
LABEL_17:
          a1->n128_u32[0] = v6;
          break;
        default:
          RB::ProtobufDecoder::skip_field(this, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(this);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::RGBACurves::print(RB::Filter::RGBACurves *this, std::string *a2)
{
  const char *v4;

  RB::SexpString::push(a2, "rgba-curves");
  if ((*(_DWORD *)this & 1) != 0)
  {
    v4 = "linear";
    goto LABEL_5;
  }
  if ((*(_DWORD *)this & 2) != 0)
  {
    v4 = "non-linear";
LABEL_5:
    RB::SexpString::print(a2, 0, v4);
  }
  RB::SexpString::printf(a2, 1, "(red-curve %g %g %g %g)", *((float *)this + 4), *((float *)this + 5), *((float *)this + 6), *((float *)this + 7));
  RB::SexpString::printf(a2, 1, "(green-curve %g %g %g %g)", *((float *)this + 8), *((float *)this + 9), *((float *)this + 10), *((float *)this + 11));
  RB::SexpString::printf(a2, 1, "(blue-curve %g %g %g %g)", *((float *)this + 12), *((float *)this + 13), *((float *)this + 14), *((float *)this + 15));
  RB::SexpString::printf(a2, 1, "(alpha-curve %g %g %g %g)", *((float *)this + 16), *((float *)this + 17), *((float *)this + 18), *((float *)this + 19));
  RB::SexpString::pop(a2);
}

void RB::Filter::Custom::apply_transform(uint64_t a1, float64x2_t *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;

  *(double *)&v3 = RB::operator*((float64x2_t *)(a1 + 144), a2 + 68);
  *(_OWORD *)(a1 + 144) = v3;
  *(_OWORD *)(a1 + 160) = v4;
  *(_OWORD *)(a1 + 176) = v5;
}

BOOL RB::Filter::Custom::can_mix(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  return a3
      && *a1 == *(_DWORD *)a3
      && RB::CustomShader::Closure::can_mix((RB::CustomShader::Closure *)(a1 + 2), (const Closure *)(a3 + 8));
}

float32x2_t RB::Filter::Custom::mix(RB::Filter::Custom *this, float32_t *a2, const RB::Filter::Custom *a3, const RB::DisplayList::CachedTransform *a4, double a5, int8x16_t a6, double a7, double a8, double a9, int8x16_t a10)
{
  const RB::AffineTransform *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  float32x2_t result;

  if (a3)
  {
    RB::CustomShader::Closure::mix((RB::Filter::Custom *)((char *)this + 8), (const RB::Filter::Custom *)((char *)a3 + 8), a2[4], a6, a7, a8, a9, a10);
    RB::mix((CGAffineTransform *)this + 3, (float64x2_t *)a3 + 9, v13, a2[4]);
    *((_OWORD *)this + 9) = v14;
    *((_OWORD *)this + 10) = v15;
    *((_OWORD *)this + 11) = v16;
    *(_QWORD *)&v14 = *((_QWORD *)this + 24);
    *(_QWORD *)&v16 = *((_QWORD *)a3 + 24);
    v17 = *((_QWORD *)a2 + 2);
    *(float32x2_t *)&v15 = vadd_f32(*(float32x2_t *)((char *)this + 200), *(float32x2_t *)&v14);
    result = vmla_n_f32(*(float32x2_t *)&v14, vsub_f32(*(float32x2_t *)&v16, *(float32x2_t *)&v14), *(float *)&v17);
    *(float32x2_t *)&v15 = vsub_f32(vmla_n_f32(*(float32x2_t *)&v15, vadd_f32(vsub_f32(*(float32x2_t *)&v16, *(float32x2_t *)&v15), *(float32x2_t *)((char *)a3 + 200)), *(float *)&v17), result);
    *((float32x2_t *)this + 24) = result;
    *((_QWORD *)this + 25) = v15;
  }
  return result;
}

uint64_t RB::Filter::Custom::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::CustomShader::Closure::prepare(a1 + 8, a2);
}

Function *RB::Filter::Custom::render(uint64_t a1, uint64_t **a2, double a3, float a4, uint64_t a5, uint64_t a6)
{
  uint64_t v10;
  _QWORD *v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  Function *result;
  Function *v16;
  int32x2_t v17;
  uint64_t v18;
  __int128 v19;
  _BOOL4 v20;
  float64x2_t *v21;
  float64x2_t v22;
  float64x2_t *v23;
  float64x2_t v24;
  float64x2_t *v25;
  uint64_t *v26;
  int64x2_t v27;
  int64x2_t v33;
  float64x2_t v34;
  int v37;
  RB::Texture *v38;
  RB::Buffer *v39;
  int64x2_t v40;
  _BYTE v41[32];
  __int128 v42;

  _S8 = a4;
  v11 = (_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 8);
  v12 = v11 + 1;
  v13 = v11[14];
  if (v11[13])
    v12 = (_QWORD *)v11[13];
  v14 = **a2;
  *(_QWORD *)v41 = v12;
  *(_QWORD *)&v41[8] = v13;
  result = (Function *)RB::CustomShader::Function::function(v10, v14, 1u, v41);
  if (result)
  {
    v16 = result;
    RB::RenderFrame::add_function(**a2, result);
    result = (Function *)RB::RenderFrame::alloc_buffer_region((RB::RenderFrame *)**a2, (RB::Device *)(*((unsigned int *)v16 + 20) + 56), 4uLL, 0, &v39);
    if (v39)
    {
      v18 = *((_QWORD *)v39 + 7) + v40.i64[0];
      RB::Coverage::set_plane((float32x2_t *)v18, (uint64_t)a2, v17);
      v19 = *(_OWORD *)(a1 + 160);
      *(_OWORD *)v41 = *(_OWORD *)(a1 + 144);
      *(_OWORD *)&v41[16] = v19;
      v42 = *(_OWORD *)(a1 + 176);
      v20 = RB::AffineTransform::invert((RB::AffineTransform *)v41);
      if (v20)
        v21 = (float64x2_t *)v41;
      else
        v21 = (float64x2_t *)(a1 + 144);
      v22 = *v21;
      if (v20)
        v23 = (float64x2_t *)&v41[16];
      else
        v23 = (float64x2_t *)(a1 + 160);
      v24 = *v23;
      v25 = (float64x2_t *)(a1 + 176);
      if (v20)
        v25 = (float64x2_t *)&v42;
      v26 = a2[13];
      v27.i64[0] = (int)v26;
      v27.i64[1] = SHIDWORD(v26);
      __asm { FMOV            V6.2D, #0.5 }
      v33 = (int64x2_t)vmulq_f64(vcvtq_f64_s64(v27), _Q6);
      v34 = vmulq_n_f64(v22, *(double *)v33.i64);
      _Q0 = vmlaq_f64(vaddq_f64(vmlaq_n_f64(*v25, v22, (double)-LODWORD(a3)), v34), v24, vaddq_f64((float64x2_t)vdupq_laneq_s64(v33, 1), (float64x2_t)vdupq_lane_s64(COERCE__INT64((double)-HIDWORD(a3)), 0)));
      *(float32x2_t *)(v18 + 28) = vcvt_f32_f64(v34);
      *(float32x2_t *)&v24.f64[0] = vcvt_f32_f64(vmulq_n_f64(v24, -*(double *)&v33.i64[1]));
      *(float64_t *)(v18 + 36) = v24.f64[0];
      *(float32x2_t *)&_Q0.f64[0] = vcvt_f32_f64(_Q0);
      *(float64_t *)(v18 + 44) = _Q0.f64[0];
      __asm { FCVT            H0, S8 }
      *(_WORD *)(v18 + 52) = LOWORD(_Q0.f64[0]);
      memset(v41, 0, 24);
      v38 = 0;
      result = (Function *)RB::CustomShader::Closure::marshal_args(v11, (uint64_t)a2, (uint64_t)v16, (_OWORD *)(a1 + 192), v18 + 56, (uint64_t)v41, (uint64_t *)&v38, _Q0.f64[0], (float32x4_t)v24);
      if ((_DWORD)result)
      {
        *((_DWORD *)a2 + 55) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**a2, *(RB::Buffer **)v41);
        a2[28] = (uint64_t *)vmovn_s64(*(int64x2_t *)&v41[8]);
        *((_DWORD *)a2 + 46) = RB::RenderFrame::buffer_id((RB::RenderFrame *)**a2, v39);
        *(uint64_t **)((char *)a2 + 188) = (uint64_t *)vmovn_s64(v40);
        if (v38)
          *((_DWORD *)a2 + 58) = RB::RenderFrame::texture_id((RB::RenderFrame *)**a2, (uint64_t)v38);
        v37 = 0;
        result = (Function *)RB::RenderPass::draw_indexed_primitives((int32x2_t *)a2, (const char *)((a6 & 0x3FFFFF | (((16 * *(_DWORD *)a1) & 0x80 | v37 & 0x2F3 | (4 * (v37 & 1u)) | (*((_DWORD *)v16 + 25) >> 31 << 8)) << 22)) ^ 0x40000000 | ((unint64_t)(BYTE4(a6) & 7 | (*(_DWORD *)v16 << 6) | (8 * *((_DWORD *)v16 + 1))) << 32)), 4, *(_QWORD *)**a2 + 80, 0, 1uLL, (int32x2_t)0xC0000001C0000001, (int32x2_t)0x7FFFFFFF7FFFFFFFLL);
        *(uint64_t **)((char *)a2 + 220) = 0;
        *(uint64_t **)((char *)a2 + 228) = 0;
        *((_BYTE *)a2 + 236) = 0;
      }
    }
  }
  return result;
}

Function *RB::Filter::Custom::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;

  if (*(_DWORD *)(a4 + 136) == 2)
    v4 = 0x20000001ELL;
  else
    v4 = 30;
  return RB::Filter::Custom::render(a1, (uint64_t **)a4, a2, 1.0, a4, v4);
}

uint64_t *RB::Filter::Custom::prepare_encode(RB::Filter::Custom *this, RB::Encoder *a2)
{
  return RB::CustomShader::Closure::prepare_encode((RB::Filter::Custom *)((char *)this + 8), a2);
}

_QWORD *RB::Filter::Custom::encode(RB::Filter::Custom *this, RB::Encoder *a2)
{
  RB::CustomShader::Function **v4;
  _QWORD *result;
  int64x2_t v6;
  int v7;
  uint32x2_t v8;

  v4 = (RB::CustomShader::Function **)((char *)this + 8);
  RB::ProtobufEncoder::encode_varint(a2, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a2);
  RB::CustomShader::Closure::encode(v4, a2);
  result = RB::ProtobufEncoder::end_length_delimited(a2);
  v6 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(*((float64x2_t *)this + 10), (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*((float64x2_t *)this + 9), (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(*((float64x2_t *)this + 11)));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v6, 1), (int8x16_t)v6).u64[0] & 0x8000000000000000) == 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x12uLL);
    RB::ProtobufEncoder::begin_length_delimited(a2);
    RB::AffineTransform::encode((double *)this + 18, a2);
    result = RB::ProtobufEncoder::end_length_delimited(a2);
  }
  v7 = *(_DWORD *)this;
  if ((*(_DWORD *)this & 1) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x18uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
    v7 = *(_DWORD *)this;
  }
  if ((v7 & 8) != 0)
  {
    RB::ProtobufEncoder::encode_varint(a2, 0x20uLL);
    result = RB::ProtobufEncoder::encode_varint(a2, 1uLL);
  }
  v8 = (uint32x2_t)vcgtz_f32(*(float32x2_t *)((char *)this + 200));
  if ((vpmin_u32(v8, v8).u32[0] & 0x80000000) != 0)
    return RB::ProtobufEncoder::float4_field(a2, 5, *((float32x4_t *)this + 12));
  return result;
}

unint64_t RB::Filter::Custom::decode(__n128 *this, RB::Decoder *a2)
{
  unint64_t result;
  unint64_t v5;
  unsigned __int32 v6;
  int v7;

  result = RB::ProtobufDecoder::next_field(a2);
  if (result)
  {
    v5 = result;
    do
    {
      switch((v5 >> 3))
      {
        case 1u:
          if ((v5 & 7) != 2)
            goto LABEL_19;
          RB::ProtobufDecoder::begin_message(a2);
          RB::CustomShader::Closure::decode((RB::CustomShader::Closure *)&this->n128_i8[8], a2);
          goto LABEL_9;
        case 2u:
          if ((v5 & 7) == 2)
          {
            RB::ProtobufDecoder::begin_message(a2);
            RB::AffineTransform::decode((RB::AffineTransform *)&this[9], a2);
LABEL_9:
            RB::ProtobufDecoder::end_message((uint64_t)a2);
          }
          else
          {
LABEL_19:
            *((_BYTE *)a2 + 56) = 1;
            *(_QWORD *)a2 = *((_QWORD *)a2 + 1);
          }
          break;
        case 3u:
          v6 = this->n128_u32[0] | RB::ProtobufDecoder::BOOL_field(a2, v5);
          goto LABEL_15;
        case 4u:
          this->n128_u32[0] &= ~8u;
          if (RB::ProtobufDecoder::BOOL_field(a2, v5))
            v7 = 8;
          else
            v7 = 0;
          v6 = this->n128_u32[0] | v7;
LABEL_15:
          this->n128_u32[0] = v6;
          break;
        case 5u:
          this[12] = RB::ProtobufDecoder::float4_field(a2, v5);
          break;
        default:
          RB::ProtobufDecoder::skip_field(a2, v5);
          break;
      }
      result = RB::ProtobufDecoder::next_field(a2);
      v5 = result;
    }
    while (result);
  }
  return result;
}

void RB::Filter::Custom::print(float32x2_t *this, std::string *a2)
{
  float32x2_t v4;
  float32x2_t v5;
  uint32x2_t v6;
  __int32 v7;
  float32x2_t v8;
  uint32x2_t v9;

  RB::SexpString::push(a2, "custom-filter");
  RB::SexpString::print(a2, 0, "#:type color");
  v4 = this[1];
  if (v4)
    RB::SexpString::printf(a2, 0, "#:shader %s", (const char *)objc_msgSend(*(id *)(*(_QWORD *)&v4 + 24), "UTF8String"));
  v5 = this[25];
  v6 = (uint32x2_t)vcgtz_f32(v5);
  if ((vpmin_u32(v6, v6).u32[0] & 0x80000000) != 0)
    RB::SexpString::printf(a2, 0, "#: bounds (%g %g; %g %g)",
      COERCE_FLOAT(*(_QWORD *)&this[24]),
      COERCE_FLOAT(HIDWORD(*(_QWORD *)&this[24])),
      v5.f32[0],
      v5.f32[1]);
  v7 = this->i32[0];
  if ((this->i32[0] & 1) != 0)
  {
    RB::SexpString::print(a2, 0, "linear");
    v7 = this->i32[0];
  }
  if ((v7 & 8) != 0)
    RB::SexpString::print(a2, 0, "dither");
  v8 = this[25];
  v9 = (uint32x2_t)vcgtz_f32(v8);
  if ((vpmin_u32(v9, v9).u32[0] & 0x80000000) != 0)
    RB::SexpString::printf(a2, 0, "(bounds %g %g %g %g)", COERCE_FLOAT(*(_QWORD *)&this[24]), COERCE_FLOAT(HIDWORD(*(_QWORD *)&this[24])), v8.f32[0], v8.f32[1]);
  RB::SexpString::pop(a2);
}

void sub_209B19270(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  if (a19)
    free(a19);
  os_unfair_lock_unlock((os_unfair_lock_t)&devices_lock);
  _Unwind_Resume(a1);
}

uint64_t render_image(uint64_t a1, void *a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  RB::ImageProvider *v8;
  uint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v14;
  RB::ImageProvider *v15;

  make_image_provider(a1, a2, a3, (uint64_t *)&v15, a4, a5, a6, a7);
  v8 = v15;
  if (!v15)
    return 0;
  if ((objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererDeferRendering), "BOOLValue") & 1) == 0)
    RB::ImageProvider::start_rendering(v8);
  RB::ImageProvider::make_cgimage(v8, &v14);
  v9 = v14;
  v10 = (unsigned int *)((char *)v8 + 8);
  do
  {
    v11 = __ldxr(v10);
    v12 = v11 - 1;
  }
  while (__stlxr(v12, v10));
  if (!v12)
  {
    __dmb(9u);
    (*(void (**)(RB::ImageProvider *))(*(_QWORD *)v8 + 8))(v8);
  }
  return v9;
}

void sub_209B19468(_Unwind_Exception *exception_object)
{
  unsigned int *v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v3 = v1 + 2;
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
  {
    __dmb(9u);
    (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
  }
  _Unwind_Resume(exception_object);
}

void render_image_async(uint64_t a1, void *a2, uint64_t a3, NSObject *a4, uint64_t a5, double a6, double a7, double a8, double a9)
{
  uint64_t v11;
  uint64_t v12;
  NSObject *v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _QWORD v17[5];
  _QWORD block[5];
  uint64_t v19;

  make_image_provider(a1, a2, a3, &v19, a6, a7, a8, a9);
  v11 = v19;
  if (v19)
  {
    v17[0] = MEMORY[0x24BDAC760];
    v17[1] = 3221225472;
    v17[2] = ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke_2;
    v17[3] = &unk_24C22ABA8;
    v17[4] = a5;
    v12 = objc_msgSend(v17, "copy");

    *(_QWORD *)(v11 + 32) = v12;
    v13 = *(NSObject **)(v11 + 40);
    if (v13 != a4)
    {

      *(_QWORD *)(v11 + 40) = a4;
    }
    RB::ImageProvider::start_rendering((RB::ImageProvider *)v11);
    v14 = (unsigned int *)(v11 + 8);
    do
    {
      v15 = __ldxr(v14);
      v16 = v15 - 1;
    }
    while (__stlxr(v16, v14));
    if (!v16)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(_QWORD *)v11 + 8))(v11);
    }
  }
  else
  {
    block[0] = MEMORY[0x24BDAC760];
    block[1] = 3221225472;
    block[2] = ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke;
    block[3] = &unk_24C22AB80;
    block[4] = a5;
    dispatch_async(a4, block);
  }
}

void sub_209B195D4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  v3 = (unsigned int *)(v1 + 8);
  do
  {
    v4 = __ldxr(v3);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v3));
  if (!v5)
    render_image_async(v1);
  _Unwind_Resume(exception_object);
}

void sub_209B19CBC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table((uint64_t)&a33);
  _Unwind_Resume(a1);
}

void sub_209B19DAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void make_image_provider(uint64_t a1@<X0>, void *a2@<X1>, uint64_t a3@<X2>, uint64_t *a4@<X8>, double a5@<D0>, double a6@<D1>, double a7@<D2>, double a8@<D3>)
{
  uint64_t v14;
  int v16;
  void *v17;
  double v18;
  double v19;
  double v20;
  double v21;
  void *v22;
  uint64_t v23;
  void *v24;
  uint64_t v25;
  int v26;
  void *v27;
  uint64_t v28;
  char v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  uint64_t v35;
  void *v36;
  uint64_t v37;
  __n128 v38;
  float v39;
  __int16 v40;
  __int128 v41;
  _QWORD v42[6];
  unsigned __int8 v43[8];

  v14 = a1;
  if (a1 && +[RBDevice isRunningInBackground](RBDevice, "isRunningInBackground"))
  {
    v16 = objc_msgSend((id)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererBackgroundGPUMode), "intValue");
    if (!v16)
    {
LABEL_14:
      *a4 = 0;
      return;
    }
    if (v16 == 1)
      v14 = 0;
  }
  v17 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererScale);
  if (v17)
  {
    objc_msgSend(v17, "doubleValue");
    v19 = v18;
    if (v18 <= 0.0)
      goto LABEL_14;
  }
  else
  {
    v19 = 1.0;
  }
  v20 = ceil(v19 * a7);
  if (v20 <= 0.0)
    goto LABEL_14;
  v21 = ceil(v19 * a8);
  if (v21 <= 0.0)
    goto LABEL_14;
  v22 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererColorMode);
  if (v22)
    v23 = objc_msgSend(v22, "intValue");
  else
    v23 = 0;
  RB::ColorMode::ColorMode(v43, v23);
  v24 = (void *)objc_opt_new();
  objc_msgSend(v24, "setProfile:", 1);
  objc_msgSend(v24, "setDefaultColorSpace:", rb_color_space(((v43[4] & 1) == 0) | 0x100u));
  objc_msgSend(v24, "setContentRect:", *MEMORY[0x24BDBEFB0], *(double *)(MEMORY[0x24BDBEFB0] + 8), v20, v21);
  *(double *)v42 = v19;
  v42[1] = 0;
  v42[2] = 0;
  *(double *)&v42[3] = v19;
  *(double *)&v42[4] = -(a5 * v19);
  *(double *)&v42[5] = -(a6 * v19);
  objc_msgSend(v24, "concat:", v42);
  (*(void (**)(uint64_t, void *))(a3 + 16))(a3, v24);
  v25 = objc_msgSend(v24, "_rb_contents");
  if (v25)
  {
    v26 = RB::DisplayList::Layer::output_depth((RB::DisplayList::Layer *)(v25 + 320));
    v43[0] = RB::max_color_depth(v43[0], v26);
  }
  v41 = RBColorClear;
  v27 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererBackgroundColor);
  if (v27)
  {
    objc_msgSend(v27, "getValue:size:", &v41, 16);
  }
  else
  {
    v31 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererOpaque);
    if (v31)
    {
      v32 = objc_msgSend(v31, "BOOLValue");
      v28 = v32;
      if ((_DWORD)v32)
        v30 = 0;
      else
        v30 = 2;
      if ((_DWORD)v32)
        v29 = 24;
      else
        v29 = 25;
      goto LABEL_28;
    }
  }
  v28 = 0;
  v29 = 25;
  v30 = 2;
LABEL_28:
  v33 = (void *)objc_msgSend(a2, "objectForKeyedSubscript:", RBImageRendererPromotesFramebuffer);
  if (v33 && !objc_msgSend(v33, "BOOLValue"))
    v29 |= 0x20u;
  v40 = 0;
  if (v14)
    v34 = *(_QWORD *)(v14 + 8);
  else
    v34 = 0;
  v35 = RB::ColorMode::pixel_format(v43, v34, v29, (_BYTE *)&v40 + 1, (BOOL *)&v40, 0);
  v36 = (void *)objc_msgSend(v24, "moveContents");
  v37 = operator new();
  v38.n128_u32[0] = (int)v20;
  v38.n128_u32[1] = (int)v21;
  v39 = v19;
  RB::ImageProvider::ImageProvider(v37, v14, v36, v35, HIBYTE(v40), v40, v30, v28, v38, v39, *(float *)&v41, *((float *)&v41 + 1), *((float *)&v41 + 2), *((float *)&v41 + 3));
  *a4 = v37;

}

void sub_209B1A104(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___ZL18render_image_asyncP8RBDevice6CGRectP12NSDictionaryU13block_pointerFvP13RBDisplayListEPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvP7CGImageE_block_invoke_2(uint64_t a1, RB::ImageProvider *this)
{
  uint64_t v2;
  CFTypeRef cf;

  v2 = *(_QWORD *)(a1 + 32);
  RB::ImageProvider::make_cgimage(this, &cf);
  (*(void (**)(uint64_t, CFTypeRef))(v2 + 16))(v2, cf);
  if (cf)
    CFRelease(cf);
}

void sub_209B1A1C0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, CFTypeRef cf)
{
  if (cf)
    CFRelease(cf);
  _Unwind_Resume(exception_object);
}

void *RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 10) + (*((_QWORD *)__dst + 10) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 8), __dst, 8uLL, (size_t *)__dst + 10, v3);
  *((_QWORD *)__dst + 8) = result;
  return result;
}

uint64_t std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_impl<RB::FormattedRenderState::ID>(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  uint64_t v5;
  int v6;
  uint64_t *inserted;
  char v8;

  v4 = operator new(0x20uLL);
  v5 = *a2;
  v4[2] = *a2;
  v6 = *((_DWORD *)a2 + 2);
  *((_DWORD *)v4 + 6) = v6;
  *v4 = 0;
  v4[1] = (33 * v6) ^ v5;
  inserted = std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique(a1, (uint64_t)v4);
  if ((v8 & 1) == 0)
    operator delete(v4);
  return inserted;
}

void sub_209B1A33C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique(_QWORD *a1, uint64_t a2)
{
  _QWORD *v2;
  _DWORD *v4;
  unint64_t v5;
  uint64_t *v6;

  v2 = (_QWORD *)a2;
  v4 = (_DWORD *)(a2 + 16);
  v5 = (33 * *(_DWORD *)(a2 + 24)) ^ *(_DWORD *)(a2 + 16);
  *((_QWORD *)v4 - 1) = v5;
  v6 = std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_prepare[abi:nn180100]((uint64_t)a1, v5, v4);
  if (v6)
    return v6;
  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_perform[abi:nn180100](a1, v2);
  return v2;
}

uint64_t *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_prepare[abi:nn180100](uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3;
  uint8x8_t v4;
  uint64_t v5;
  uint64_t **v6;
  uint64_t *i;
  unint64_t v8;
  float v9;
  float v10;
  uint64_t v11;
  _BOOL8 v12;
  size_t v13;
  unint64_t v14;
  size_t v15;

  v3 = *(_QWORD *)(a1 + 8);
  if (v3)
  {
    v4 = (uint8x8_t)vcnt_s8((int8x8_t)v3);
    v4.i16[0] = vaddlv_u8(v4);
    if (v4.u32[0] > 1uLL)
      v5 = v3 <= a2 ? a2 % v3 : a2;
    else
      v5 = (v3 - 1) & a2;
    v6 = *(uint64_t ***)(*(_QWORD *)a1 + 8 * v5);
    if (v6)
    {
      for (i = *v6; i; i = (uint64_t *)*i)
      {
        v8 = i[1];
        if (v8 == a2)
        {
          if (*a3 == *((_DWORD *)i + 4)
            && *((_DWORD *)i + 5) == a3[1]
            && ((a3[2] ^ *((_DWORD *)i + 6)) & 0xFBFFFFFF) == 0)
          {
            return i;
          }
        }
        else
        {
          if (v4.u32[0] > 1uLL)
          {
            if (v8 >= v3)
              v8 %= v3;
          }
          else
          {
            v8 &= v3 - 1;
          }
          if (v8 != v5)
            break;
        }
      }
    }
  }
  v9 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v10 = *(float *)(a1 + 32);
  if (!v3 || (float)(v10 * (float)v3) < v9)
  {
    v11 = 2 * v3;
    v12 = v3 < 3 || (v3 & (v3 - 1)) != 0;
    v13 = v12 | v11;
    v14 = vcvtps_u32_f32(v9 / v10);
    if (v13 <= v14)
      v15 = v14;
    else
      v15 = v13;
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v15);
  }
  return 0;
}

_QWORD *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__node_insert_unique_perform[abi:nn180100](_QWORD *result, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  _QWORD *v5;
  unint64_t v6;

  v2 = (int8x8_t)result[1];
  v3 = a2[1];
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    if (v3 >= *(_QWORD *)&v2)
      v3 %= *(_QWORD *)&v2;
  }
  else
  {
    v3 &= *(_QWORD *)&v2 - 1;
  }
  v5 = *(_QWORD **)(*result + 8 * v3);
  if (v5)
  {
    *a2 = *v5;
LABEL_13:
    *v5 = a2;
    goto LABEL_14;
  }
  *a2 = result[2];
  result[2] = a2;
  *(_QWORD *)(*result + 8 * v3) = result + 2;
  if (*a2)
  {
    v6 = *(_QWORD *)(*a2 + 8);
    if (v4.u32[0] > 1uLL)
    {
      if (v6 >= *(_QWORD *)&v2)
        v6 %= *(_QWORD *)&v2;
    }
    else
    {
      v6 &= *(_QWORD *)&v2 - 1;
    }
    v5 = (_QWORD *)(*result + 8 * v6);
    goto LABEL_13;
  }
LABEL_14:
  ++result[3];
  return result;
}

uint64_t std::unordered_set<RB::FormattedRenderState>::unordered_set(uint64_t a1, uint64_t a2)
{
  unsigned int *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(unsigned int **)(a2 + 16); i; i = *(unsigned int **)i)
    std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(a1, i + 4, (uint64_t)(i + 4));
  return a1;
}

void sub_209B1A5F8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<RB::FormattedRenderState,std::hash<RB::FormattedRenderState>,std::equal_to<RB::FormattedRenderState>,std::allocator<RB::FormattedRenderState>>::__emplace_unique_key_args<RB::FormattedRenderState,RB::FormattedRenderState const&>(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v3;
  unsigned int v6;
  unsigned int v7;
  unint64_t v8;
  unint64_t v9;
  uint8x8_t v10;
  void **v11;
  _QWORD *v12;
  unint64_t v13;
  float v14;
  float v15;
  _BOOL8 v16;
  unint64_t v17;
  unint64_t v18;
  size_t v19;
  uint64_t v20;
  _QWORD *v21;
  unint64_t v22;

  v6 = *a2;
  v7 = a2[2];
  v8 = (33 * v7) ^ *a2;
  v9 = *(_QWORD *)(a1 + 8);
  if (v9)
  {
    v10 = (uint8x8_t)vcnt_s8((int8x8_t)v9);
    v10.i16[0] = vaddlv_u8(v10);
    if (v10.u32[0] > 1uLL)
    {
      v3 = (33 * v7) ^ v6;
      if (v8 >= v9)
        v3 = v8 % v9;
    }
    else
    {
      v3 = v8 & (v9 + 0xFFFFFFFF);
    }
    v11 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v11)
    {
      v12 = *v11;
      if (*v11)
      {
        do
        {
          v13 = v12[1];
          if (v13 == v8)
          {
            if (*((_DWORD *)v12 + 4) == v6
              && *((_DWORD *)v12 + 5) == a2[1]
              && ((*((_DWORD *)v12 + 6) ^ v7) & 0xFBFFFFFF) == 0)
            {
              return v12;
            }
          }
          else
          {
            if (v10.u32[0] > 1uLL)
            {
              if (v13 >= v9)
                v13 %= v9;
            }
            else
            {
              v13 &= v9 - 1;
            }
            if (v13 != v3)
              break;
          }
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
    }
  }
  v12 = operator new(0x20uLL);
  *v12 = 0;
  v12[1] = v8;
  v12[2] = *(_QWORD *)a3;
  *((_DWORD *)v12 + 6) = *(_DWORD *)(a3 + 8);
  v14 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v15 = *(float *)(a1 + 32);
  if (!v9 || (float)(v15 * (float)v9) < v14)
  {
    v16 = 1;
    if (v9 >= 3)
      v16 = (v9 & (v9 - 1)) != 0;
    v17 = v16 | (2 * v9);
    v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18)
      v19 = v18;
    else
      v19 = v17;
    std::__hash_table<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::__unordered_map_hasher<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::hash<unsigned int>,std::equal_to<unsigned int>,true>,std::__unordered_map_equal<unsigned int,std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>,std::equal_to<unsigned int>,std::hash<unsigned int>,true>,std::allocator<std::__hash_value_type<unsigned int,RB::Encoder::FontSet::Font>>>::__rehash<true>(a1, v19);
    v9 = *(_QWORD *)(a1 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v8 >= v9)
        v3 = v8 % v9;
      else
        v3 = v8;
    }
    else
    {
      v3 = ((_DWORD)v9 - 1) & v8;
    }
  }
  v20 = *(_QWORD *)a1;
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v21)
  {
    *v12 = *v21;
LABEL_40:
    *v21 = v12;
    goto LABEL_41;
  }
  *v12 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v12;
  *(_QWORD *)(v20 + 8 * v3) = a1 + 16;
  if (*v12)
  {
    v22 = *(_QWORD *)(*v12 + 8);
    if ((v9 & (v9 - 1)) != 0)
    {
      if (v22 >= v9)
        v22 %= v9;
    }
    else
    {
      v22 &= v9 - 1;
    }
    v21 = (_QWORD *)(*(_QWORD *)a1 + 8 * v22);
    goto LABEL_40;
  }
LABEL_41:
  ++*(_QWORD *)(a1 + 24);
  return v12;
}

void sub_209B1A850(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t RBStrokeBoundingRect(void *a1, float *a2)
{
  uint64_t result;
  char v5;
  int v6;
  float v7;
  float v8;
  CGImage *v9;
  CGImage *v10;
  float Width;
  float v12;
  size_t Height;
  float v14;
  float v15;
  uint64_t (**v21)();
  __int16 v22;
  float v23;
  int32x2_t v24;
  uint64_t v25;
  __int128 v26;
  __int128 v27;
  uint64_t v28;
  char v29;
  float v30;
  float v31;
  _DWORD v32[5];
  __int128 v33;
  uint64_t v34;

  result = objc_msgSend(a1, "strokeType");
  if ((_DWORD)result == 1)
  {
    v9 = (CGImage *)objc_msgSend(a1, "image");
    if (v9)
    {
      v10 = v9;
      Width = (float)CGImageGetWidth(v9);
      v12 = Width / (float)(unint64_t)objc_msgSend(a1, "imageCount");
      Height = CGImageGetHeight(v10);
      if (v12 < (float)Height)
        v12 = (float)Height;
      objc_msgSend(a1, "imageScale");
      v15 = (float)(v14 * 0.5) * v12;
    }
    else
    {
      v15 = 0.0;
    }
    v21 = off_24C223E60;
    v22 = 256;
    v23 = 0.0;
    v24 = vdup_n_s32(0x7F800000u);
    v25 = 0x7F0000007FLL;
    v26 = 0u;
    v27 = 0u;
    v28 = 0;
    v29 = 1;
    v30 = 0.0;
    v31 = v15;
    __asm { FMOV            V0.2S, #1.0 }
    *(_QWORD *)&v32[1] = _D0;
    *(_QWORD *)&v32[3] = 1065353216;
    v33 = 0u;
    v34 = 1065353216;
    result = RB::Stroke::stroke_particles(a1, (uint64_t (***)(_QWORD))&v21, (float64x2_t)0);
    if (a2)
    {
      v8 = v30;
LABEL_15:
      *a2 = v8;
    }
  }
  else if (!(_DWORD)result)
  {
    v5 = rb_line_cap(objc_msgSend(a1, "lineCap"));
    v6 = rb_line_join((CGLineJoin)objc_msgSend(a1, "lineJoin"));
    objc_msgSend(a1, "miterLimit");
    v21 = off_24C223E20;
    LOBYTE(v22) = v5;
    HIBYTE(v22) = v6;
    v23 = v7 * v7;
    v24 = vdup_n_s32(0x7F800000u);
    v25 = 0x7F0000007FLL;
    v26 = 0u;
    v27 = 0u;
    v28 = 0;
    v29 = 1;
    v30 = 0.0;
    *(_QWORD *)v32 = 0x3F80000000000000;
    result = RB::Stroke::stroke_points(a1, (uint64_t (***)(_QWORD))&v21, (float64x2_t)0);
    if (a2)
    {
      v8 = v30;
      if (!v6)
        v8 = v30 * 1.4142;
      goto LABEL_15;
    }
  }
  return result;
}

void *RB::vector<float,0ul,unsigned long>::reserve_slow(uint64_t a1, unint64_t a2)
{
  uint64_t v3;
  void *result;

  if (*(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *(_QWORD *)(a1 + 16) + (*(_QWORD *)(a1 + 16) >> 1);
  result = RB::details::realloc_vector<unsigned long,4ul>(*(void **)a1, (size_t *)(a1 + 16), v3);
  *(_QWORD *)a1 = result;
  return result;
}

void *RB::details::realloc_vector<unsigned long,4ul>(void *a1, size_t *a2, uint64_t a3)
{
  void *v4;
  size_t v5;
  size_t v6;
  void *v7;
  const char *v8;

  v4 = a1;
  if (a3)
  {
    v5 = malloc_good_size(4 * a3);
    v6 = v5 >> 2;
    if (v5 >> 2 != *a2)
    {
      v7 = malloc_type_realloc(v4, v5, 0x2F8905C9uLL);
      if (!v7)
        RB::precondition_failure((RB *)"allocation failure", v8);
      v4 = v7;
      *a2 = v6;
    }
  }
  else
  {
    *a2 = 0;
    free(a1);
    return 0;
  }
  return v4;
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::endpath(float32x2_t *a1, double a2, double a3)
{
  return RB::Stroke::LineBounds::endpath(a1 + 1, a2, a3);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::closepath(float32x2_t *a1, double a2, double a3)
{
  return RB::Stroke::LineBounds::closepath(a1 + 1, a2, a3);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::moveto(float32x2_t *a1, _DWORD *a2, double a3, double a4)
{
  LODWORD(a4) = *a2;
  return RB::Stroke::LineBounds::moveto(a1 + 1, a3, a4);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::lineto(float32x2_t *a1, _DWORD *a2, float32x2_t a3, double a4)
{
  LODWORD(a4) = *a2;
  return RB::Stroke::LineBounds::lineto(a1 + 1, a3, a4);
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::quadto(float32x2_t *a1, float *a2, float32x2_t a3, float32x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  RB::Stroke::LineBounds::quadto(a1 + 1, a3, a4, *a2, a6, a7, a8, a9, a10);
}

void RB::Stroke::Bounds<RB::Stroke::Point,RBStrokeBoundingRect::$_0>::cubeto(uint64_t a1, float *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  RB::Stroke::LineBounds::cubeto(a1 + 8, a3, a4, a5, *a2, a7, a8, a9, a10);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::endpath(float32x2_t *a1, double a2, double a3)
{
  return RB::Stroke::LineBounds::endpath(a1 + 1, a2, a3);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::closepath(float32x2_t *a1, double a2, double a3)
{
  return RB::Stroke::LineBounds::closepath(a1 + 1, a2, a3);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::moveto(float32x2_t *a1, uint64_t a2, double a3)
{
  double v3;
  float v4;

  v3 = *(double *)(a2 + 8);
  *(float *)&v3 = vaddv_f32(*(float32x2_t *)&v3) * 1.4142;
  v4 = *(float *)(a2 + 4);
  if (v4 < 1.0)
    v4 = 1.0;
  *(float *)&v3 = (float)(*(float *)&v3 * v4)
                * (float)(COERCE_FLOAT(HIDWORD(*(_QWORD *)(a2 + 24)))
                        + (float)(a1[10].f32[0] + COERCE_FLOAT(*(_QWORD *)(a2 + 24))));
  return RB::Stroke::LineBounds::moveto(a1 + 1, a3, v3);
}

float32x2_t *RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::lineto(float32x2_t *a1, uint64_t a2, float32x2_t a3)
{
  double v3;
  float v4;

  v3 = *(double *)(a2 + 8);
  *(float *)&v3 = vaddv_f32(*(float32x2_t *)&v3) * 1.4142;
  v4 = *(float *)(a2 + 4);
  if (v4 < 1.0)
    v4 = 1.0;
  *(float *)&v3 = (float)(*(float *)&v3 * v4)
                * (float)(COERCE_FLOAT(HIDWORD(*(_QWORD *)(a2 + 24)))
                        + (float)(a1[10].f32[0] + COERCE_FLOAT(*(_QWORD *)(a2 + 24))));
  return RB::Stroke::LineBounds::lineto(a1 + 1, a3, v3);
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::quadto(float32x2_t *a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, double a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  float v10;
  float v11;
  float result;

  v10 = vaddv_f32(a2[1]) * 1.4142;
  LODWORD(a6) = a2->i32[1];
  if (*(float *)&a6 < 1.0)
    *(float *)&a6 = 1.0;
  v11 = v10 * *(float *)&a6;
  *(float32x2_t *)a7.i8 = a2[3];
  a8.i32[0] = a7.i32[1];
  *(float *)&a6 = *(float *)&a7.i32[1] + (float)(a1[10].f32[0] + *(float *)a7.i32);
  RB::Stroke::LineBounds::quadto(a1 + 1, a3, a4, v11 * *(float *)&a6, a6, a7, a8, a9, a10);
  return result;
}

float RB::Stroke::Bounds<RB::Stroke::Particle,RBStrokeBoundingRect::$_1>::cubeto(uint64_t a1, float32x2_t *a2, float32x2_t a3, float32x2_t a4, float32x2_t a5, double a6, int32x4_t a7, int32x4_t a8, int32x4_t a9, int32x4_t a10)
{
  float v10;
  float v11;
  float result;

  v10 = vaddv_f32(a2[1]) * 1.4142;
  a7.i32[0] = a2->i32[1];
  if (*(float *)a7.i32 < 1.0)
    *(float *)a7.i32 = 1.0;
  v11 = v10 * *(float *)a7.i32;
  *(float32x2_t *)a8.i8 = a2[3];
  a9.i32[0] = a8.i32[1];
  *(float *)a7.i32 = *(float *)&a8.i32[1] + (float)(*(float *)(a1 + 80) + *(float *)a8.i32);
  RB::Stroke::LineBounds::cubeto(a1 + 8, a3, a4, a5, v11 * *(float *)a7.i32, a7, a8, a9, a10);
  return result;
}

RB::Symbol::GlyphCache *RB::Symbol::GlyphCache::GlyphCache(RB::Symbol::GlyphCache *this)
{
  RB::UntypedTable *v2;
  RB::Heap *v3;

  *(_DWORD *)this = 0;
  v2 = (RB::Symbol::GlyphCache *)((char *)this + 48);
  v3 = (RB::Symbol::GlyphCache *)((char *)this + 8);
  RB::Heap::Heap((RB::Symbol::GlyphCache *)((char *)this + 8), 0, 0, 0);
  RB::UntypedTable::UntypedTable(v2, (unint64_t (*)(RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_0::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_1::__invoke, 0, 0, v3);
  RB::UntypedTable::UntypedTable((RB::Symbol::GlyphCache *)((char *)this + 128), (unint64_t (*)(RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_2::__invoke, (BOOL (*)(RB *, RB *, const void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_3::__invoke, (void (*)(void *))RB::Symbol::GlyphCache::GlyphCache(void)::$_4::__invoke, 0, v3);
  *((_DWORD *)this + 52) = 32;
  RB::UntypedTable::insert((size_t **)this + 16, (size_t *)CFSTR("_slash"), (size_t *)1);
  RB::UntypedTable::insert((size_t **)this + 16, (size_t *)CFSTR("_badge"), (size_t *)2);
  return this;
}

void sub_209B1B5C4(_Unwind_Exception *a1)
{
  RB::Heap *v1;
  RB::UntypedTable *v2;
  RB::UntypedTable *v3;

  RB::UntypedTable::~UntypedTable(v3);
  RB::UntypedTable::~UntypedTable(v2);
  RB::Heap::~Heap(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::GlyphCache::ref(os_unfair_lock_s *a1, void *a2, unsigned int a3, unsigned __int8 a4)
{
  uint64_t v7;
  __int128 v9;
  unsigned int v10;
  int v11;

  *(_QWORD *)&v9 = a2;
  *((_QWORD *)&v9 + 1) = (33 * objc_msgSend(a2, "hash")) ^ a3;
  v10 = a3;
  v11 = a4;
  os_unfair_lock_lock(a1);
  v7 = (uint64_t)RB::UntypedTable::lookup((RB::UntypedTable *)&a1[12], (uint64_t *)&v9, 0);
  if (!v7)
  {
    v7 = operator new();
    RB::Symbol::Glyph::Glyph(v7, &v9);
    RB::UntypedTable::insert((size_t **)&a1[12], (size_t *)v7, (size_t *)v7);
  }
  ++*(_DWORD *)(v7 + 28);
  os_unfair_lock_unlock(a1);
  return v7;
}

void sub_209B1B6CC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  uint64_t v2;

  MEMORY[0x20BD16544](v2, 0x10A0C40C1C8AB79);
  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t *RB::Symbol::GlyphCache::intern_locked(RB::Symbol::GlyphCache *this, NSString *a2)
{
  size_t **v4;
  uint64_t *result;
  size_t *v6;

  v4 = (size_t **)((char *)this + 128);
  result = RB::UntypedTable::lookup((RB::Symbol::GlyphCache *)((char *)this + 128), (uint64_t *)a2, 0);
  if (!(_DWORD)result)
  {
    v6 = (size_t *)*((unsigned int *)this + 52);
    *((_DWORD *)this + 52) = (_DWORD)v6 + 1;
    RB::UntypedTable::insert(v4, (size_t *)-[NSString copy](a2, "copy"), v6);
    return (uint64_t *)v6;
  }
  return result;
}

uint64_t RB::Symbol::GlyphCache::tag(os_unfair_lock_s *a1, unsigned int a2)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v7[2];

  os_unfair_lock_lock(a1);
  v6 = 0;
  v7[0] = &v6;
  v7[1] = a2;
  RB::UntypedTable::for_each((uint64_t)&a1[32], (void (*)(const void *, const void *, void *))RB::Table<NSString *,unsigned int>::for_each<RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0>(RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke, v7);
  v4 = v6;
  os_unfair_lock_unlock(a1);
  return v4;
}

void sub_209B1B7C4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

uint64_t RB::Symbol::`anonymous namespace'::contains_slash_or_badge_layer(RB::Symbol::_anonymous_namespace_ *this, NSArray *a2)
{
  RB::Symbol::_anonymous_namespace_ *v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t i;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t j;
  void *v14;
  uint64_t v15;
  RB::Symbol::_anonymous_namespace_ *v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  _BYTE v25[128];
  _BYTE v26[128];
  uint64_t v27;

  v2 = this;
  v27 = *MEMORY[0x24BDAC8D0];
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  v24 = 0u;
  result = -[RB::Symbol::_anonymous_namespace_ countByEnumeratingWithState:objects:count:](this, "countByEnumeratingWithState:objects:count:", &v21, v26, 16);
  if (result)
  {
    v4 = result;
    v5 = *(_QWORD *)v22;
    v15 = *(_QWORD *)v22;
    v16 = v2;
    do
    {
      for (i = 0; i != v4; ++i)
      {
        if (*(_QWORD *)v22 != v5)
          objc_enumerationMutation(v2);
        v7 = *(void **)(*((_QWORD *)&v21 + 1) + 8 * i);
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v8 = (void *)objc_msgSend(v7, "tags");
          if (v8)
          {
            v9 = v8;
            v19 = 0u;
            v20 = 0u;
            v17 = 0u;
            v18 = 0u;
            v10 = objc_msgSend(v8, "countByEnumeratingWithState:objects:count:", &v17, v25, 16);
            if (v10)
            {
              v11 = v10;
              v12 = *(_QWORD *)v18;
              while (2)
              {
                for (j = 0; j != v11; ++j)
                {
                  if (*(_QWORD *)v18 != v12)
                    objc_enumerationMutation(v9);
                  v14 = *(void **)(*((_QWORD *)&v17 + 1) + 8 * j);
                  if ((objc_msgSend(v14, "isEqualToString:", CFSTR("_slash"), v15, v16) & 1) != 0
                    || (objc_msgSend(v14, "isEqualToString:", CFSTR("_badge")) & 1) != 0)
                  {
                    return 1;
                  }
                }
                v11 = objc_msgSend(v9, "countByEnumeratingWithState:objects:count:", &v17, v25, 16);
                v5 = v15;
                v2 = v16;
                if (v11)
                  continue;
                break;
              }
            }
          }
        }
      }
      v4 = -[RB::Symbol::_anonymous_namespace_ countByEnumeratingWithState:objects:count:](v2, "countByEnumeratingWithState:objects:count:", &v21, v26, 16);
      result = 0;
    }
    while (v4);
  }
  return result;
}

void RB::Symbol::Glyph::make_legacy_layers(RB::Symbol::Glyph *this, float a2)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  id v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  void *v12;
  double v13;
  char *v14;
  int v15;
  char *v16;
  char *v17;
  unsigned int v18;
  int v19;
  char *v20;
  uint64_t v21;
  char *v22;
  char *v23;
  int v24;
  uint64_t v25;
  float32x2_t v26;
  float32x2_t v27;
  float32x2_t v28;
  void *v29;
  double v30;
  uint64_t v31;
  int v32;
  int v33;
  char *v34;
  char *v35;
  unsigned int v36;
  int v37;
  char *v38;
  uint64_t v39;
  char *v40;
  char *v41;
  int v42;
  uint64_t *v43;
  uint64_t v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t j;
  float32x2_t v48;
  float32x2_t v49;
  float32x2_t v50;
  void *v51;
  double v52;
  uint64_t v53;
  int v54;
  int v55;
  char *v56;
  char *v57;
  unsigned int v58;
  int v59;
  char *v60;
  uint64_t v61;
  char *v62;
  char *v63;
  int v64;
  uint64_t i;
  float32x2_t v66;
  float32x2_t v67;
  float32x2_t v68;
  void *v69;
  double v70;
  uint64_t v71;
  int v72;
  int v73;
  char *v74;
  char *v75;
  unsigned int v76;
  int v77;
  char *v78;
  uint64_t v79;
  int v80;
  char *v81;
  char *v82;
  int v83;
  unsigned int v84;
  int *v85;
  id v86;
  id v87;
  _QWORD v88[5];
  uint64_t v89;
  uint64_t *v90;
  uint64_t v91;
  __n128 (*v92)(uint64_t, uint64_t);
  void (*v93)(uint64_t);
  const char *v94;
  int v95;
  id v96;
  CFTypeRef cf;
  _QWORD v98[5];
  _QWORD v99[6];

  v4 = *((_DWORD *)this + 6);
  switch(v4)
  {
    case 0:
    case 1:
      v5 = 1;
      goto LABEL_13;
    case 2:
      v5 = objc_msgSend(*(id *)this, "numberOfMulticolorLayers");
      goto LABEL_13;
    case 3:
      goto LABEL_5;
    case 4:
      goto LABEL_8;
    default:
      if ((v4 - 128) >= 2)
      {
        if (v4 != 130)
        {
          v5 = 0;
          goto LABEL_13;
        }
        *((_DWORD *)this + 6) = 4;
LABEL_8:
        v6 = objc_msgSend(*(id *)this, "numberOfPaletteLayers");
      }
      else
      {
        *((_DWORD *)this + 6) = 3;
LABEL_5:
        v6 = objc_msgSend(*(id *)this, "numberOfHierarchyLayers");
      }
      v5 = v6;
      if (!v6)
      {
        v5 = 1;
        *((_DWORD *)this + 6) = 1;
      }
LABEL_13:
      v7 = (void *)objc_opt_new();
      v8 = v7;
      v86 = v8;
      v87 = v7;
      switch(*((_DWORD *)this + 6))
      {
        case 0:
        case 1:
          objc_msgSend(v8, "translateByX:Y:", 0.0, *((float *)this + 17));
          v9.i32[0] = *((_DWORD *)this + 11);
          v10 = vrecpe_f32(v9);
          v11 = vmul_f32(vrecps_f32(v9, v10), v10);
          v11.f32[0] = vmul_f32(v11, vrecps_f32(v9, v11)).f32[0];
          objc_msgSend(v8, "scaleByX:Y:", v11.f32[0], (float)-v11.f32[0]);
          v12 = (void *)RB::Symbol::Glyph::copied_glyph(this);
          LODWORD(v13) = 1.0;
          objc_msgSend(v12, "drawInContext:", objc_msgSend(v7, "beginCGContextWithAlpha:", v13));
          objc_msgSend(v7, "endCGContext");
          v14 = (char *)this + 112;
          v15 = *((_DWORD *)this + 96);
          if (*((_DWORD *)this + 97) < (v15 + 1))
          {
            RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v15 + 1);
            v15 = *((_DWORD *)this + 96);
          }
          v16 = (char *)*((_QWORD *)this + 47);
          if (!v16)
            v16 = (char *)this + 112;
          v17 = &v16[88 * v15];
          *((_QWORD *)v17 + 5) = 0;
          *((_QWORD *)v17 + 1) = 0;
          *((_QWORD *)v17 + 2) = 0;
          *((_QWORD *)v17 + 6) = 0x400000000;
          *((_QWORD *)v17 + 7) = 1065353216;
          *((_QWORD *)v17 + 8) = 2139095040;
          *((_QWORD *)v17 + 9) = 1065353216;
          v18 = *((_DWORD *)v17 + 21) & 0xFE000000 | 0x311A00;
          *((_DWORD *)v17 + 20) = -1;
          *((_DWORD *)v17 + 21) = v18;
          v19 = *((_DWORD *)this + 96);
          *((_DWORD *)this + 96) = v19 + 1;
          v20 = (char *)*((_QWORD *)this + 47);
          v21 = objc_msgSend(v87, "moveContents");
          if (v20)
            v22 = v20;
          else
            v22 = v14;
          v23 = &v22[88 * v19];
          *(_QWORD *)v23 = v21;
          v24 = *((_DWORD *)v23 + 21);
          *((float *)v23 + 15) = a2;
          *((_DWORD *)v23 + 21) = v24 & 0xFFF3F000 | 0xC0000;
          break;
        case 2:
          if (v5)
          {
            v25 = 0;
            v85 = &v95;
            do
            {
              objc_msgSend(v8, "translateByX:Y:", 0.0, *((float *)this + 17), v85);
              v26.i32[0] = *((_DWORD *)this + 11);
              v27 = vrecpe_f32(v26);
              v28 = vmul_f32(vrecps_f32(v26, v27), v27);
              v28.f32[0] = vmul_f32(v28, vrecps_f32(v26, v28)).f32[0];
              objc_msgSend(v8, "scaleByX:Y:", v28.f32[0], (float)-v28.f32[0]);
              v89 = 0;
              v90 = &v89;
              v91 = 0x4812000000;
              v92 = __Block_byref_object_copy_;
              v93 = __Block_byref_object_dispose_;
              v94 = " 0";
              v95 = 10;
              v96 = 0;
              cf = 0;
              v29 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v30) = 1.0;
              v31 = objc_msgSend(v7, "beginCGContextWithAlpha:", v30);
              v88[0] = MEMORY[0x24BDAC760];
              v88[1] = 3221225472;
              v88[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_10;
              v88[3] = &unk_24C22ABF8;
              v88[4] = &v89;
              objc_msgSend(v29, "drawMulticolorLayerAtIndex:inContext:withColorResolver:", v25, v31, v88);
              objc_msgSend(v7, "endCGContext");
              v32 = *((_DWORD *)v90 + 12);
              v33 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v33 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v33 + 1);
                v33 = *((_DWORD *)this + 96);
              }
              v34 = (char *)*((_QWORD *)this + 47);
              if (!v34)
                v34 = (char *)this + 112;
              v35 = &v34[88 * v33];
              *((_QWORD *)v35 + 5) = 0;
              *((_QWORD *)v35 + 1) = 0;
              *((_QWORD *)v35 + 2) = 0;
              *((_QWORD *)v35 + 6) = 0x400000000;
              *((_QWORD *)v35 + 7) = 1065353216;
              *((_QWORD *)v35 + 8) = 2139095040;
              *((_QWORD *)v35 + 9) = 1065353216;
              v36 = *((_DWORD *)v35 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v35 + 20) = -1;
              *((_DWORD *)v35 + 21) = v36;
              v37 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v37 + 1;
              v38 = (char *)*((_QWORD *)this + 47);
              v39 = objc_msgSend(v87, "moveContents");
              if (v38)
                v40 = v38;
              else
                v40 = (char *)this + 112;
              v41 = &v40[88 * v37];
              *(_QWORD *)v41 = v39;
              v42 = *((_DWORD *)v41 + 21);
              *((float *)v41 + 15) = a2;
              *((_DWORD *)v41 + 21) = v42 & 0xFFF3F000 | ((v32 & 0xF) << 8) | 0xC0000;
              v43 = v90;
              v44 = *((_QWORD *)v41 + 1);
              *((_QWORD *)v41 + 1) = v90[7];
              v43[7] = v44;
              v45 = v90;
              v46 = *((_QWORD *)v41 + 2);
              *((_QWORD *)v41 + 2) = v90[8];
              v45[8] = v46;
              _Block_object_dispose(&v89, 8);
              if (cf)
                CFRelease(cf);

              ++v25;
              v8 = v86;
            }
            while (v5 != v25);
          }
          break;
        case 3:
          if (v5)
          {
            for (i = 0; i != v5; ++i)
            {
              objc_msgSend(v8, "translateByX:Y:", 0.0, *((float *)this + 17));
              v66.i32[0] = *((_DWORD *)this + 11);
              v67 = vrecpe_f32(v66);
              v68 = vmul_f32(vrecps_f32(v66, v67), v67);
              v68.f32[0] = vmul_f32(v68, vrecps_f32(v66, v68)).f32[0];
              objc_msgSend(v8, "scaleByX:Y:", v68.f32[0], (float)-v68.f32[0]);
              v89 = 0;
              v90 = &v89;
              v91 = 0x2020000000;
              LODWORD(v92) = -1;
              v69 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v70) = 1.0;
              v71 = objc_msgSend(v7, "beginCGContextWithAlpha:", v70);
              v99[0] = MEMORY[0x24BDAC760];
              v99[1] = 3221225472;
              v99[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke;
              v99[3] = &unk_24C22ABD0;
              v99[4] = &v89;
              objc_msgSend(v69, "drawHierarchyLayerAtIndex:inContext:withColorResolver:", i, v71, v99);
              objc_msgSend(v7, "endCGContext");
              v72 = *((_DWORD *)v90 + 6);
              v73 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v73 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v73 + 1);
                v73 = *((_DWORD *)this + 96);
              }
              v74 = (char *)*((_QWORD *)this + 47);
              if (!v74)
                v74 = (char *)this + 112;
              v75 = &v74[88 * v73];
              *((_QWORD *)v75 + 5) = 0;
              *((_QWORD *)v75 + 1) = 0;
              *((_QWORD *)v75 + 2) = 0;
              *((_QWORD *)v75 + 6) = 0x400000000;
              *((_QWORD *)v75 + 7) = 1065353216;
              *((_QWORD *)v75 + 8) = 2139095040;
              *((_QWORD *)v75 + 9) = 1065353216;
              v76 = *((_DWORD *)v75 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v75 + 20) = -1;
              *((_DWORD *)v75 + 21) = v76;
              v77 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v77 + 1;
              v78 = (char *)*((_QWORD *)this + 47);
              v79 = objc_msgSend(v87, "moveContents");
              v80 = v72;
              if (v78)
                v81 = v78;
              else
                v81 = (char *)this + 112;
              v82 = &v81[88 * v77];
              *(_QWORD *)v82 = v79;
              v83 = *((_DWORD *)v82 + 21);
              *((float *)v82 + 15) = a2;
              v84 = v83 & 0xFFF3F000;
              if (v72 < 0)
                v80 = 2560;
              *((_DWORD *)v82 + 21) = v84 | v80 | 0xC0000;
              _Block_object_dispose(&v89, 8);
            }
          }
          break;
        case 4:
          if (v5)
          {
            for (j = 0; j != v5; ++j)
            {
              objc_msgSend(v8, "translateByX:Y:", 0.0, *((float *)this + 17));
              v48.i32[0] = *((_DWORD *)this + 11);
              v49 = vrecpe_f32(v48);
              v50 = vmul_f32(vrecps_f32(v48, v49), v49);
              v50.f32[0] = vmul_f32(v50, vrecps_f32(v48, v50)).f32[0];
              objc_msgSend(v8, "scaleByX:Y:", v50.f32[0], (float)-v50.f32[0]);
              v89 = 0;
              v90 = &v89;
              v91 = 0x2020000000;
              LODWORD(v92) = 10;
              v51 = (void *)RB::Symbol::Glyph::copied_glyph(this);
              LODWORD(v52) = 1.0;
              v53 = objc_msgSend(v7, "beginCGContextWithAlpha:", v52);
              v98[0] = MEMORY[0x24BDAC760];
              v98[1] = 3221225472;
              v98[2] = ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_2;
              v98[3] = &unk_24C22ABD0;
              v98[4] = &v89;
              objc_msgSend(v51, "drawPaletteLayerAtIndex:inContext:withColorResolver:", j, v53, v98);
              objc_msgSend(v7, "endCGContext");
              v54 = *((_DWORD *)v90 + 6);
              v55 = *((_DWORD *)this + 96);
              if (*((_DWORD *)this + 97) < (v55 + 1))
              {
                RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow((char *)this + 112, v55 + 1);
                v55 = *((_DWORD *)this + 96);
              }
              v56 = (char *)*((_QWORD *)this + 47);
              if (!v56)
                v56 = (char *)this + 112;
              v57 = &v56[88 * v55];
              *((_QWORD *)v57 + 5) = 0;
              *((_QWORD *)v57 + 1) = 0;
              *((_QWORD *)v57 + 2) = 0;
              *((_QWORD *)v57 + 6) = 0x400000000;
              *((_QWORD *)v57 + 7) = 1065353216;
              *((_QWORD *)v57 + 8) = 2139095040;
              *((_QWORD *)v57 + 9) = 1065353216;
              v58 = *((_DWORD *)v57 + 21) & 0xFE000000 | 0x311A00;
              *((_DWORD *)v57 + 20) = -1;
              *((_DWORD *)v57 + 21) = v58;
              v59 = *((_DWORD *)this + 96);
              *((_DWORD *)this + 96) = v59 + 1;
              v60 = (char *)*((_QWORD *)this + 47);
              v61 = objc_msgSend(v87, "moveContents");
              if (v60)
                v62 = v60;
              else
                v62 = (char *)this + 112;
              v63 = &v62[88 * v59];
              *(_QWORD *)v63 = v61;
              v64 = *((_DWORD *)v63 + 21);
              *((float *)v63 + 15) = a2;
              *((_DWORD *)v63 + 21) = v64 & 0xFFF3F000 | ((v54 & 0xF) << 8) | 0xC0000;
              _Block_object_dispose(&v89, 8);
            }
          }
          break;
        default:
          break;
      }

      return;
  }
}

void sub_209B1C1E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10, id a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17)
{
  void *v17;

  _Unwind_Resume(a1);
}

BOOL RB::Symbol::Glyph::Layer::contains(uint64_t a1, unsigned int a2)
{
  int *v2;

  v2 = (int *)(a1 + 24);
  if (*(_QWORD *)(a1 + 40))
    v2 = *(int **)(a1 + 40);
  return RB::Symbol::tags_contains(v2, *(unsigned int *)(a1 + 48), a2);
}

int8x8_t RB::Symbol::Glyph::Layer::content_bounds(float32x2_t **this, double a2, double a3, float64x2_t a4, int32x4_t a5)
{
  int v6;
  float32x2_t v7;
  float64x2_t v8;
  float64_t v9;
  float32x2_t v10;
  float v11;
  float64_t v13;
  float64x2_t v14;
  int8x8_t v15;
  int8x8_t v16;
  RBPath v18;

  v6 = (*((_DWORD *)this + 21) >> 18) & 3;
  if (v6 == 3)
  {
    -[float32x2_t boundingRect](*this, "boundingRect");
    v14.f64[1] = v13;
    v7 = vcvt_f32_f64(v14);
  }
  else if (v6 == 2)
  {
    v7 = (*this)[35];
  }
  else
  {
    v7 = 0;
    if (v6 == 1)
    {
      v18.info = (void *)**this;
      v18.callbacks = (RBPathCallbacks *)(*this)[1];
      v8.f64[0] = RBPathGetBoundingRect(v18);
      v8.f64[1] = v9;
      v7 = vcvt_f32_f64(v8);
      *(_QWORD *)&a4.f64[1] = a5.i64[0];
      v10 = vcvt_f32_f64(a4);
      LODWORD(a4.f64[0]) = *((_DWORD *)this + 19);
      if (*(float *)a4.f64 > 0.0)
      {
        v11 = *(float *)a4.f64 * 0.70711;
        *(float *)a4.f64 = *(float *)a4.f64 * 5.0;
        if ((*((_BYTE *)this + 86) & 3) != 0 || v11 >= *(float *)a4.f64)
          *(float *)a4.f64 = v11;
        *(float *)a4.f64 = *(float *)a4.f64 / *((float *)this + 14);
        *(int32x2_t *)a5.i8 = vcgt_f32((float32x2_t)vdup_n_s32(0x7F7FFFFFu), v10);
        a5.i64[0] = vcltzq_s32(a5).u64[0];
        v7 = (float32x2_t)vbsl_s8(*(int8x8_t *)a5.i8, (int8x8_t)vsub_f32(v7, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4.f64[0], 0)), (int8x8_t)v7);
      }
    }
  }
  a5.i32[0] = *((_DWORD *)this + 15);
  v15 = (int8x8_t)vmul_n_f32(v7, *((float *)this + 14));
  LODWORD(a4.f64[0]) = 0;
  v16.i32[1] = v15.i32[1];
  *(float *)v16.i32 = *(float *)a5.i32 - *(float *)v15.i32;
  return vbsl_s8((int8x8_t)vdup_lane_s32((int32x2_t)vmvn_s8((int8x8_t)vceq_f32(*(float32x2_t *)a5.i8, *(float32x2_t *)&a4.f64[0])), 0), v16, v15);
}

RB::Symbol::Glyph::Layer *RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::~vector(RB::Symbol::Glyph::Layer *a1)
{
  RB::Symbol::Glyph::Layer *v1;
  void *v2;
  unint64_t v3;
  uint64_t v4;

  v1 = a1;
  v2 = (void *)*((_QWORD *)a1 + 33);
  if (v2)
    a1 = (RB::Symbol::Glyph::Layer *)*((_QWORD *)a1 + 33);
  if (*((_DWORD *)v1 + 68))
  {
    v3 = 0;
    do
    {
      RB::Symbol::Glyph::Layer::~Layer(a1);
      ++v3;
      a1 = (RB::Symbol::Glyph::Layer *)(v4 + 88);
    }
    while (v3 < *((unsigned int *)v1 + 68));
    v2 = (void *)*((_QWORD *)v1 + 33);
  }
  if (v2)
    free(v2);
  return v1;
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if ((*(_DWORD *)(v3 + 24) & 0x80000000) != 0)
    *(_DWORD *)(v3 + 24) = a3;
  return CGColorGetConstantColor((CFStringRef)*MEMORY[0x24BDBF330]);
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_2(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v3;
  int v4;
  int v5;

  v3 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
  if (*(_DWORD *)(v3 + 24) == 10)
  {
    v4 = 4;
    if (a3 < 4)
      v4 = a3;
    v5 = v4 + 4;
    if (!a3)
      v5 = 0;
    *(_DWORD *)(v3 + 24) = v5;
  }
  return CGColorGetConstantColor((CFStringRef)*MEMORY[0x24BDBF330]);
}

__n128 __Block_byref_object_copy_(uint64_t a1, uint64_t a2)
{
  __n128 result;

  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a2 + 48);
  result = *(__n128 *)(a2 + 56);
  *(__n128 *)(a1 + 56) = result;
  *(_QWORD *)(a2 + 56) = 0;
  *(_QWORD *)(a2 + 64) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 64);
  if (v2)
    CFRelease(v2);

}

uint64_t RB::Symbol::Glyph::make_legacy_layers(float)::Info::~Info(uint64_t a1)
{
  const void *v2;

  v2 = *(const void **)(a1 + 16);
  if (v2)
    CFRelease(v2);

  return a1;
}

CGColorRef ___ZN2RB6Symbol5Glyph18make_legacy_layersEf_block_invoke_10(uint64_t a1, void *a2, CFTypeRef cf)
{
  uint64_t v6;
  void *v7;
  CFTypeRef v8;
  CFTypeRef v9;

  if (a2)
  {
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 48) = 9;
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(void **)(v6 + 56);
    if (v7 != a2)
    {

      *(_QWORD *)(v6 + 56) = a2;
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    }
    v8 = *(CFTypeRef *)(v6 + 64);
    if (v8 != cf)
    {
      if (v8)
        CFRelease(v8);
      if (cf)
        v9 = CFRetain(cf);
      else
        v9 = 0;
      *(_QWORD *)(v6 + 64) = v9;
    }
  }
  return CGColorGetConstantColor((CFStringRef)*MEMORY[0x24BDBF330]);
}

const void **RB::cf_ptr<void const*>::operator=(const void **a1, CFTypeRef cf)
{
  CFTypeRef v3;
  CFTypeRef v5;

  v3 = *a1;
  if (v3 != cf)
  {
    if (v3)
      CFRelease(v3);
    if (cf)
      v5 = CFRetain(cf);
    else
      v5 = 0;
    *a1 = v5;
  }
  return a1;
}

uint64_t *RB::Symbol::Glyph::Layer::Layer(uint64_t *a1, uint64_t a2, void *a3, int a4, float a5, float a6)
{
  id *v11;
  unsigned int v12;
  RB::Symbol::GlyphCache *v13;
  RB::Symbol::GlyphCache *v14;
  RB::Symbol::GlyphCache *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  unsigned int v19;
  unsigned int v20;
  id *v21;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  int *v26;
  unint64_t v27;
  int v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  double v34;
  int *v35;
  void *v36;
  void *v37;
  void *v38;
  unint64_t v39;
  unint64_t v40;
  unint64_t v41;
  uint64_t v42;
  void *v43;
  _QWORD *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _DWORD *v49;
  int v50;
  _DWORD *v51;
  double v52;
  double v53;
  float64x2_t v54;
  int32x4_t v55;
  float32x2_t *v56;
  _BYTE *v57;
  unsigned int v58;
  float32x2_t v59;
  float32x2_t v60;
  double v61;
  double v62;
  double v63;
  int32x4_t v64;
  void *v65;
  double v66;
  double v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  unint64_t v72;
  id v73;
  const void *v74;
  const void *v75;
  CFTypeRef v76;
  int v77;
  const void *v78;
  id v79;
  const void *v80;
  int v82;
  int v83;
  const void **v84;
  __int128 v86;
  __int128 v87;
  __int128 v88;
  __int128 v89;
  __int128 v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  void *__dst[8];
  _BYTE v95[128];
  _BYTE v96[128];
  uint64_t v97;
  RBPath v98;

  v97 = *MEMORY[0x24BDAC8D0];
  a1[1] = 0;
  v11 = (id *)(a1 + 1);
  a1[2] = 0;
  v84 = (const void **)(a1 + 2);
  a1[5] = 0;
  a1[6] = 0x400000000;
  a1[7] = 1065353216;
  a1[8] = 2139095040;
  a1[9] = 1065353216;
  v12 = *((_DWORD *)a1 + 21) & 0xFE000000 | 0x311A00;
  *((_DWORD *)a1 + 20) = -1;
  *((_DWORD *)a1 + 21) = v12;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v13 = (RB::Symbol::GlyphCache *)objc_msgSend(a3, "tags");
    v14 = v13;
    if (v13)
    {
      v15 = (RB::Symbol::GlyphCache *)RB::Symbol::GlyphCache::shared(v13);
      v82 = a4;
      v92 = 0u;
      v93 = 0u;
      v90 = 0u;
      v91 = 0u;
      v16 = -[RB::Symbol::GlyphCache countByEnumeratingWithState:objects:count:](v14, "countByEnumeratingWithState:objects:count:", &v90, v96, 16);
      if (v16)
      {
        v17 = *(_QWORD *)v91;
        do
        {
          for (i = 0; i != v16; ++i)
          {
            if (*(_QWORD *)v91 != v17)
              objc_enumerationMutation(v14);
            v19 = RB::Symbol::GlyphCache::intern_locked(v15, *(NSString **)(*((_QWORD *)&v90 + 1) + 8 * i));
            v20 = *((_DWORD *)a1 + 12);
            if (*((_DWORD *)a1 + 13) < v20 + 1)
            {
              RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow(v11 + 2, v20 + 1);
              v20 = *((_DWORD *)a1 + 12);
            }
            v21 = (id *)a1[5];
            if (!v21)
              v21 = v11 + 2;
            *((_DWORD *)v21 + v20) = v19;
            ++*((_DWORD *)a1 + 12);
          }
          v16 = -[RB::Symbol::GlyphCache countByEnumeratingWithState:objects:count:](v14, "countByEnumeratingWithState:objects:count:", &v90, v96, 16);
        }
        while (v16);
      }
      if (a1[5])
        v22 = a1[5];
      else
        v22 = (uint64_t)(v11 + 2);
      v23 = *((unsigned int *)a1 + 12);
      v24 = 126 - 2 * __clz(v23);
      if ((_DWORD)v23)
        v25 = v24;
      else
        v25 = 0;
      std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(v22, (unsigned int *)(v22 + 4 * v23), (uint64_t)__dst, v25, 1);
      a4 = v82;
      if (a1[5])
        v26 = (int *)a1[5];
      else
        v26 = (int *)(v11 + 2);
      v27 = *((unsigned int *)a1 + 12);
      if (RB::Symbol::tags_contains(v26, v27, 1u))
      {
        v28 = 0x100000;
      }
      else
      {
        if (!RB::Symbol::tags_contains(v26, v27, 2u))
          goto LABEL_28;
        v28 = 0x200000;
      }
      *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFCFFFFF | v28;
    }
  }
LABEL_28:
  v29 = (void *)objc_msgSend(a3, "referenceShape");
  if (v29)
  {
    v30 = operator new();
    *(_DWORD *)(v30 + 8) = 1;
    *(_QWORD *)v30 = off_24C229608;
    RB::Path::Storage::Storage((uint64_t)__dst, (const char *)0x90);
    RB::Path::Storage::Storage((RB::Path::Storage *)(v30 + 16), (const char *)0x90, (const RB::Path::Storage *)__dst);
    RB::Path::Storage::~Storage((RB::Path::Storage *)__dst);
    v98.callbacks = (RBPathCallbacks *)&RBPathCGPathCallbacks;
    v98.info = v29;
    RB::Path::Storage::append_path((RB::Path::Storage *)(v30 + 16), v98);
    v31 = operator new();
    *(_OWORD *)v31 = RBPathEmpty;
    *(_QWORD *)(v31 + 16) = 0;
    *(_QWORD *)(v31 + 24) = 0;
    *a1 = v31;
    v33 = *(_QWORD *)v31;
    v32 = *(_QWORD *)(v31 + 8);
    *(_QWORD *)v31 = v30;
    *(_QWORD *)(v31 + 8) = &RB::Path::Object::callbacks;
    RBPathRelease(v33, v32);
    *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFF3FFFF | 0x40000;
    *((float *)a1 + 14) = a5;
    *((float *)a1 + 15) = a6;
    objc_msgSend(a3, "strokeWidth");
    *(float *)&v34 = v34;
    *((_DWORD *)a1 + 19) = LODWORD(v34);
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFFF0FFF | ((objc_msgSend(a3, "lineCap") & 0xF) << 12);
      *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFFCFFFF | ((objc_msgSend(a3, "lineJoin") & 3) << 16);
    }
    if (a1[5])
      v35 = (int *)a1[5];
    else
      v35 = (int *)(v11 + 2);
    if (RB::Symbol::tags_contains(v35, *((unsigned int *)a1 + 12), 1u) && (objc_opt_respondsToSelector() & 1) != 0)
    {
      v36 = (void *)objc_msgSend(a3, "referencePath");
      if (v36)
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v37 = (void *)objc_msgSend(v36, "clipStrokeKeyframes");
          v38 = v37;
          if (v37)
          {
            v39 = objc_msgSend(v37, "length");
            v40 = v39;
            if (v39 >= 0x10)
            {
              v41 = v39 >> 4;
              v42 = *a1;
              if (*(_DWORD *)(*a1 + 24) < (v39 >> 4) && *(_DWORD *)(v42 + 28) < v41)
                RB::vector<RBColor,0ul,unsigned int>::reserve_slow(v42 + 16, v39 >> 4);
              *(_DWORD *)(v42 + 24) = v41;
              memmove(*(void **)(*a1 + 16), (const void *)objc_msgSend(v38, "bytes"), v40 & 0xFFFFFFFFFFFFFFF0);
            }
          }
        }
      }
      if (!*(_DWORD *)(*a1 + 24))
        RB::Symbol::Glyph::Layer::remove(a1, 1u);
    }
  }
  if ((*((_BYTE *)a1 + 86) & 0xC) == 0)
  {
    v43 = (void *)objc_msgSend(a3, "sublayers");
    if (v43)
    {
      v44 = (_QWORD *)operator new();
      v44[33] = 0;
      v44[34] = 0x300000000;
      v44[35] = 0;
      v44[36] = 0;
      __dst[0] = v44;
      v86 = 0u;
      v87 = 0u;
      v88 = 0u;
      v89 = 0u;
      v45 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v86, v95, 16);
      v83 = a4;
      if (v45)
      {
        v46 = *(_QWORD *)v87;
LABEL_50:
        v47 = 0;
        while (1)
        {
          if (*(_QWORD *)v87 != v46)
            objc_enumerationMutation(v43);
          v48 = *(_QWORD *)(*((_QWORD *)&v86 + 1) + 8 * v47);
          v49 = __dst[0];
          v50 = *((_DWORD *)__dst[0] + 68);
          if (*((_DWORD *)__dst[0] + 69) < (v50 + 1))
          {
            RB::vector<RB::Symbol::Glyph::Layer,3ul,unsigned int>::reserve_slow(__dst[0], v50 + 1);
            v50 = v49[68];
          }
          v51 = (_DWORD *)*((_QWORD *)v49 + 33);
          if (!v51)
            v51 = v49;
          RB::Symbol::Glyph::Layer::Layer(&v51[22 * v50], a2, v48, 1, a5, a6);
          ++v49[68];
          v56 = (float32x2_t *)__dst[0];
          v57 = (_BYTE *)*((_QWORD *)__dst[0] + 33);
          if (!v57)
            v57 = __dst[0];
          v58 = *((_DWORD *)__dst[0] + 68) - 1;
          if ((v57[88 * v58 + 86] & 0xC) == 0)
            break;
          v59 = (float32x2_t)RB::Symbol::Glyph::Layer::content_bounds((float32x2_t **)&v57[88 * v58], v52, v53, v54, v55);
          RB::Rect::Union(v56 + 35, v59, v60, v61, v62, v63, v64);
          if (v45 == ++v47)
          {
            v45 = objc_msgSend(v43, "countByEnumeratingWithState:objects:count:", &v86, v95, 16);
            if (v45)
              goto LABEL_50;
            goto LABEL_62;
          }
        }
      }
      else
      {
LABEL_62:
        v65 = __dst[0];
        __dst[0] = 0;
        *a1 = (uint64_t)v65;
        *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFF3FFFF | 0x80000;
        *((float *)a1 + 15) = a6;
      }
      std::unique_ptr<RB::Symbol::Glyph::Sublayers>::reset[abi:nn180100]((uint64_t *)__dst, 0);
      a4 = v83;
    }
  }
  if ((*((_BYTE *)a1 + 86) & 0xC) != 0)
  {
    objc_msgSend(a3, "valueThreshold");
    *(float *)&v66 = v66;
    *((_DWORD *)a1 + 16) = LODWORD(v66);
    *((_DWORD *)a1 + 17) = objc_msgSend(a3, "motionGroup");
    objc_msgSend(a3, "opacity");
    *(float *)&v67 = v67;
    *((_DWORD *)a1 + 18) = LODWORD(v67);
    if (objc_msgSend(a3, "isEraserLayer"))
      v68 = 0x400000;
    else
      v68 = 0;
    *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFBFFFFF | v68;
    if (objc_msgSend(a3, "alwaysPulses"))
      v69 = 0x800000;
    else
      v69 = 0;
    *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFF7FFFFF | v69;
    if ((objc_opt_respondsToSelector() & 1) != 0)
    {
      if (objc_msgSend(a3, "alwaysRotates"))
        v70 = 0x1000000;
      else
        v70 = 0;
      *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFEFFFFFF | v70;
    }
    if (*((float *)a1 + 18) > 0.0)
    {
      v71 = *((_DWORD *)a1 + 21) & 0xFFFFF0FF;
      *((_DWORD *)a1 + 21) = v71;
      if ((a4 - 3) < 2)
      {
        v72 = objc_msgSend(a3, "hierarchyLevel");
        if (v72)
        {
          if (a4 == 3)
          {
            *((_BYTE *)a1 + 84) = v72;
          }
          else
          {
            v77 = 4;
            if (v72 < 4)
              v77 = v72;
            *((_DWORD *)a1 + 21) = (*((_DWORD *)a1 + 21) & 0xFFFFF0FF | (v77 << 8)) + 1024;
          }
        }
        return a1;
      }
      if (a4 != 2)
        return a1;
      *((_DWORD *)a1 + 21) = v71 | 0x900;
      if (*((float *)a1 + 19) <= 0.0)
      {
        if ((objc_opt_respondsToSelector() & 1) != 0)
        {
          v78 = (const void *)objc_msgSend(a3, "fillImage");
          if (v78)
          {
            *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFFFF0FF | 0xC00;
            RB::cf_ptr<void const*>::operator=(v84, v78);
            return a1;
          }
        }
        v79 = (id)objc_msgSend(a3, "fillColorName");
        if (*v11 != v79)
        {

          *v11 = v79;
        }
        v74 = (const void *)objc_msgSend(a3, "fillColor");
        v80 = *v84;
        if (*v84 != v74)
        {
          if (v80)
            CFRelease(v80);
          if (v74)
            goto LABEL_89;
          goto LABEL_102;
        }
      }
      else
      {
        v73 = (id)objc_msgSend(a3, "strokeColorName");
        if (*v11 != v73)
        {

          *v11 = v73;
        }
        v74 = (const void *)objc_msgSend(a3, "strokeColor");
        v75 = *v84;
        if (*v84 != v74)
        {
          if (v75)
            CFRelease(v75);
          if (v74)
          {
LABEL_89:
            v76 = CFRetain(v74);
LABEL_103:
            *v84 = v76;
            return a1;
          }
LABEL_102:
          v76 = 0;
          goto LABEL_103;
        }
      }
    }
  }
  return a1;
}

void sub_209B1CE0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, CFTypeRef *a11)
{
  uint64_t v11;
  id *v12;
  void *v14;

  v14 = *(void **)(v11 + 40);
  if (v14)
    free(v14);
  if (*a11)
    CFRelease(*a11);

  _Unwind_Resume(a1);
}

_QWORD *RB::Symbol::Glyph::Layer::remove(_QWORD *result, unsigned int a2)
{
  char *v2;
  uint64_t v3;
  char *v4;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  char *v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;

  v2 = (char *)(result + 3);
  if (result[5])
    v2 = (char *)result[5];
  v3 = *((unsigned int *)result + 12);
  if ((_DWORD)v3)
  {
    v4 = v2;
    v5 = *((unsigned int *)result + 12);
    do
    {
      v6 = v5 >> 1;
      v7 = &v4[4 * (v5 >> 1)];
      v9 = *(_DWORD *)v7;
      v8 = v7 + 4;
      v5 += ~(v5 >> 1);
      if (v9 < a2)
        v4 = v8;
      else
        v5 = v6;
    }
    while (v5);
    if (v4 != &v2[4 * v3] && *(_DWORD *)v4 == a2)
    {
      v10 = v4 - v2;
      v11 = (v3 - 1);
      *((_DWORD *)result + 12) = v11;
      if (v11 != v10 >> 2)
        return memmove(&v2[4 * (v10 >> 2)], &v2[4 * (v10 >> 2) + 4], 4 * (v11 - (v10 >> 2)));
    }
  }
  return result;
}

void *RB::Symbol::Glyph::Layer::mix_layers(_DWORD **a1, uint64_t a2, uint64_t a3, float64x2_t *a4, float64x2_t *a5, RB::Symbol::Presentation *a6, char a7, id *a8, float a9, _BYTE *a10)
{
  int v18;
  id v19;
  RB::DisplayList::State *State;
  void *v21;
  RB::DisplayList::State *v22;
  void *v23;
  RBDisplayListInterpolator *v24;
  uint64_t v25;
  double v26;
  int64x2_t v27;
  uint64_t *v28;
  uint64_t v29;
  RB::DisplayList::State *v30;
  RB::DisplayList::State *v31;
  float v32;
  float v33;
  _DWORD *v34;
  _DWORD *v35;
  _DWORD *v36;
  _DWORD *v37;
  _DWORD *v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  uint64_t v42;
  float v44;
  float64x2_t v45;
  float v46;
  float64x2_t v47;
  float v48;
  float64x2_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  uint64_t v53;
  __n128 v54;
  uint64_t v55;
  uint64_t v56;
  float64x2_t v57[3];
  float64x2_t v58[3];
  float64x2_t v59[4];
  RBPath v60;

  v18 = *(_DWORD *)(a2 + 84) & 0xC0000;
  if ((a7 & 1) != 0)
  {
    if (v18 != 0x40000
      || (*(_DWORD *)(a3 + 84) & 0xC0000) != 0x40000
      || *(float *)(a2 + 76) > 0.0 != *(float *)(a3 + 76) > 0.0)
    {
      v19 = *a8;
      if (!*a8)
      {
        v19 = (id)objc_opt_new();

        *a8 = v19;
      }
      State = (RB::DisplayList::State *)RBDisplayListGetState((uint64_t)v19);
      RB::Symbol::Glyph::Layer::draw(a2, State, 0, a4, a6, 1.0, 1.0, 1.0, 1.0, 1.0, (float32x2_t)0x3F80000000000000);
      v21 = (void *)objc_msgSend(*a8, "moveContents");
      v22 = (RB::DisplayList::State *)RBDisplayListGetState((uint64_t)*a8);
      RB::Symbol::Glyph::Layer::draw(a3, v22, 0, a5, a6, 1.0, 1.0, 1.0, 1.0, 1.0, (float32x2_t)0x3F80000000000000);
      v23 = (void *)objc_msgSend(*a8, "moveContents");
      v24 = -[RBDisplayListInterpolator initWithFrom:to:options:]([RBDisplayListInterpolator alloc], "initWithFrom:to:options:", v21, v23, 0);
      v25 = RBDisplayListGetState((uint64_t)*a8);
      *(float *)&v26 = a9;
      -[RBDisplayListInterpolator drawInState:by:](v24, "drawInState:by:", v25, v26);
      *a1 = (_DWORD *)objc_msgSend(*a8, "moveContents");
      *((_DWORD *)a1 + 21) |= 0xC0000u;
      *a10 = 1;

      goto LABEL_25;
    }
    if (*(float *)(a2 + 60) == *(float *)(a3 + 60))
    {
      v60.info = **(void ***)a3;
      v60.callbacks = *(RBPathCallbacks **)(*(_QWORD *)a3 + 8);
      if (RBPathCanMix(*(RBPath *)*(_QWORD *)a2, v60))
      {
        v44 = *(float *)(a2 + 56);
        v45.f64[0] = 0.0;
        v45.f64[1] = v44;
        v59[0] = (float64x2_t)COERCE_UNSIGNED_INT64(v44);
        v59[1] = v45;
        v59[2] = 0u;
        v46 = *(float *)(a3 + 56);
        v47.f64[0] = 0.0;
        v47.f64[1] = v46;
        v58[0] = (float64x2_t)COERCE_UNSIGNED_INT64(v46);
        v58[1] = v47;
        v58[2] = 0u;
        v48 = v44 + (float)((float)(v46 - v44) * a9);
        v49.f64[0] = 0.0;
        v49.f64[1] = v48;
        v57[0] = (float64x2_t)COERCE_UNSIGNED_INT64(v48);
        v57[1] = v49;
        v57[2] = 0u;
        v50 = operator new();
        *(_OWORD *)v50 = RBPathEmpty;
        *(_QWORD *)(v50 + 16) = 0;
        *(_QWORD *)(v50 + 24) = 0;
        *a1 = (_DWORD *)v50;
        RBPathMix(*(RBPath *)*(_QWORD *)a2, *(RBPath *)*(_QWORD *)a3, a9, v59, v58, v57, &v55);
        v51 = *a1;
        v52 = *(_QWORD *)*a1;
        v53 = *((_QWORD *)*a1 + 1);
        *v51 = v55;
        v51[1] = v56;
        v55 = v52;
        v56 = v53;
        RBPathRelease(v52, v53);
        v54.n128_f32[0] = a9;
        *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFF3FFFF | 0x40000;
        *((float *)a1 + 14) = v48;
        *((_DWORD *)a1 + 15) = *(_DWORD *)(a2 + 60);
        goto LABEL_43;
      }
    }
  }
  else if (v18 == 0x40000
         && (*(_DWORD *)(a3 + 84) & 0xC0000) == 0x40000
         && *(float *)(a2 + 56) == *(float *)(a3 + 56)
         && *(float *)(a2 + 60) == *(float *)(a3 + 60)
         && *(float *)(a2 + 76) > 0.0 == *(float *)(a3 + 76) > 0.0)
  {
    v27 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a4[1], a5[1]), (int8x16_t)vceqq_f64(*a4, *a5)), (int8x16_t)vceqq_f64(a4[2], a5[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v27, 1), (int8x16_t)v27).u64[0] & 0x8000000000000000) != 0)
    {
      if (RBPathEqualToPath(**(void ***)a2, *(_QWORD *)(*(_QWORD *)a2 + 8), **(_QWORD **)a3, *(void **)(*(_QWORD *)a3 + 8)))
      {
        v28 = (uint64_t *)operator new();
        RB::Symbol::Glyph::Shape::Shape(v28, *(_QWORD *)a2);
        *a1 = v28;
        *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFF3FFFF | 0x40000;
        a1[7] = *(_DWORD **)(a2 + 56);
LABEL_43:
        *((float *)a1 + 19) = *(float *)(a2 + 76) + (float)((float)(*(float *)(a3 + 76) - *(float *)(a2 + 76)) * a9);
        *a10 = 0;
        goto LABEL_25;
      }
    }
  }
  v29 = (uint64_t)*a8;
  if (!*a8)
  {
    v29 = objc_opt_new();

    *a8 = (id)v29;
  }
  v30 = (RB::DisplayList::State *)RBDisplayListGetState(v29);
  v31 = RBDrawingStateBeginLayer(v30, 0);
  v32 = 0.0;
  if (a9 >= 0.0)
    v32 = a9;
  if (v32 <= 1.0)
    v33 = v32;
  else
    v33 = 1.0;
  RB::Symbol::Glyph::Layer::draw(a2, v31, 0, a4, a6, 1.0, 1.0, 1.0, 1.0, 1.0 - v33, (float32x2_t)0x3F80000000000000);
  RB::Symbol::Glyph::Layer::draw(a3, v31, 0x3EFu, a5, a6, 1.0, 1.0, 1.0, 1.0, v33, (float32x2_t)0x3F80000000000000);
  RBDrawingStateDrawLayer((uint64_t)v30, v31, 0, 1.0);
  *a1 = (_DWORD *)objc_msgSend(*a8, "moveContents");
  *((_DWORD *)a1 + 21) |= 0xC0000u;
  *a10 = 1;
LABEL_25:
  *((_DWORD *)a1 + 21) = *((_DWORD *)a1 + 21) & 0xFFFFF0FF | (((*(_DWORD *)(a2 + 84) >> 8) & 0xF) << 8);
  v34 = *(_DWORD **)(a2 + 8);
  v35 = a1[1];
  if (v35 != v34)
  {

    a1[1] = v34;
  }
  v36 = *(_DWORD **)(a2 + 16);
  v37 = a1[2];
  if (v37 != v36)
  {
    if (v37)
      CFRelease(v37);
    if (v36)
      v38 = CFRetain(v36);
    else
      v38 = 0;
    a1[2] = v38;
  }
  *((float *)a1 + 18) = *(float *)(a2 + 72) + (float)((float)(*(float *)(a3 + 72) - *(float *)(a2 + 72)) * a9);
  v39 = *((_DWORD *)a1 + 21) & 0xFF7FFFFF | (((*(_DWORD *)(a2 + 84) >> 23) & 1) << 23);
  *((_DWORD *)a1 + 21) = v39;
  v40 = v39 & 0xFEFFFFFF | ((HIBYTE(*(_DWORD *)(a2 + 84)) & 1) << 24);
  *((_DWORD *)a1 + 21) = v40;
  *((_DWORD *)a1 + 21) = v40 & 0xFFBFFFFF | (((*(_DWORD *)(a2 + 84) >> 22) & 1) << 22);
  if (*(_QWORD *)(a2 + 40))
    v41 = *(_QWORD *)(a2 + 40);
  else
    v41 = a2 + 24;
  if (*(_QWORD *)(a3 + 40))
    v42 = *(_QWORD *)(a3 + 40);
  else
    v42 = a3 + 24;
  return RB::Symbol::tags_intersect(a1 + 3, v41, *(unsigned int *)(a2 + 48), v42, *(unsigned int *)(a3 + 48));
}

void sub_209B1D548(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10E0C403B0E517ALL);
  _Unwind_Resume(a1);
}

uint64_t *RB::Symbol::Glyph::Shape::Shape(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  unsigned int v5;
  int v6;
  __int128 *v8;
  _OWORD *v9;
  unsigned int v10;
  __int128 v11;

  *a1 = RBPathRetain(*(_QWORD *)a2, *(_QWORD *)(a2 + 8));
  a1[1] = v4;
  a1[2] = 0;
  a1[3] = 0;
  v5 = *(_DWORD *)(a2 + 24);
  if (v5)
  {
    v8 = *(__int128 **)(a2 + 16);
    RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(a1 + 2), v5);
    v9 = (_OWORD *)(a1[2] + 16 * *((unsigned int *)a1 + 6));
    v10 = v5;
    do
    {
      v11 = *v8++;
      *v9++ = v11;
      --v10;
    }
    while (v10);
    v6 = *((_DWORD *)a1 + 6);
  }
  else
  {
    v6 = 0;
  }
  *((_DWORD *)a1 + 6) = v6 + v5;
  return a1;
}

void sub_209B1D630(_Unwind_Exception *a1)
{
  uint64_t *v1;
  void **v2;

  if (*v2)
    free(*v2);
  RBPathRelease(*v1, v1[1]);
  _Unwind_Resume(a1);
}

unsigned int *RB::Symbol::Glyph::Layer::draw(uint64_t a1, RB::DisplayList::State *a2, unsigned int a3, float64x2_t *a4, RB::Symbol::Presentation *this, float a6, float a7, float a8, float a9, float a10, float32x2_t a11)
{
  void *v22;
  float16x4_t *v23;
  double v24;
  double v25;
  double v26;
  double v27;
  _QWORD v29[4];
  float v30;
  float v31;
  float v32;
  float v33;

  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    v22 = (void *)RB::Symbol::Presentation::shape(this);
    v23 = (float16x4_t *)RB::Symbol::Presentation::fill(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v22, a4, a11);
    *(float *)&v24 = a6;
    *(float *)&v25 = a7;
    *(float *)&v26 = a8;
    *(float *)&v27 = a9;
    -[float16x4_t setColor:colorSpace:](v23, "setColor:colorSpace:", 1, v24, v25, v26, v27);
    return (unsigned int *)RBDrawingStateDrawShape((uint64_t)a2, (uint64_t)v22, v23, a3, a10);
  }
  else
  {
    v29[0] = MEMORY[0x24BDAC760];
    v29[1] = 3221225472;
    v29[2] = ___ZNK2RB6Symbol5Glyph5Layer4drawEP15_RBDrawingState7RBColorf11RBBlendModeRKNS_15AffineTransformEDv2_fRKNS0_12PresentationE_block_invoke;
    v29[3] = &__block_descriptor_48_e16_v16__0__RBFill_8l;
    v30 = a6;
    v31 = a7;
    v32 = a8;
    v33 = a9;
    return RB::Symbol::Glyph::Layer::draw(a1, a2, a3, a4, this, (uint64_t)v29, a10, a11);
  }
}

_DWORD *RB::Symbol::`anonymous namespace'::mix_path_keyframes(_DWORD *result, uint64_t a2, uint64_t a3, __n128 a4)
{
  uint64_t v5;
  _DWORD *v7;
  int *v8;
  int *v9;
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  uint64_t v14;
  unint64_t v15;
  float32x2_t v16;
  uint64_t v17;
  uint64_t v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  float32x2_t v22;
  float32x2_t v23;
  float v24;
  float v25;
  unsigned int v26;
  uint64_t v27;
  __n128 v28;
  __n128 v29;

  v5 = *(unsigned int *)(a2 + 24);
  if ((_DWORD)v5 == *(_DWORD *)(a3 + 24))
  {
    v7 = result;
    if ((_DWORD)v5)
    {
      v8 = *(int **)(a2 + 16);
      v9 = *(int **)(a3 + 16);
      v10 = v5;
      while (1)
      {
        v12 = *v8;
        v8 += 4;
        v11 = v12;
        v13 = *v9;
        v9 += 4;
        if (v11 != v13)
          break;
        if (!--v10)
          goto LABEL_6;
      }
    }
    else
    {
LABEL_6:
      if (result[7] < v5)
      {
        v29 = a4;
        result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(result + 4), v5);
        a4 = v29;
        LODWORD(v5) = *(_DWORD *)(a2 + 24);
        if (!(_DWORD)v5)
          return result;
      }
      else if (!(_DWORD)v5)
      {
        return result;
      }
      v14 = 0;
      v15 = 0;
      v16 = (float32x2_t)vdup_lane_s32((int32x2_t)a4.n128_u64[0], 0);
      do
      {
        v17 = *(_QWORD *)(a2 + 16);
        v18 = *(_QWORD *)(a3 + 16);
        v19 = *(_DWORD *)(v18 + v14);
        if (*(_DWORD *)(v17 + v14) != v19)
        {
          v20 = v17 + v14;
          v21 = v18 + v14;
          v22 = *(float32x2_t *)(v20 + 4);
          v23 = *(float32x2_t *)(v21 + 4);
          v24 = *(float *)(v20 + 12);
          v25 = *(float *)(v21 + 12);
          v26 = v7[6];
          if (v7[7] < v26 + 1)
          {
            v28 = a4;
            result = RB::vector<RBColor,0ul,unsigned int>::reserve_slow((uint64_t)(v7 + 4), v26 + 1);
            a4 = v28;
            v26 = v7[6];
          }
          v27 = *((_QWORD *)v7 + 2) + 16 * v26;
          *(_DWORD *)v27 = v19;
          *(float32x2_t *)(v27 + 4) = vmla_f32(v22, v16, vsub_f32(v23, v22));
          *(float *)(v27 + 12) = v24 + (float)((float)(v25 - v24) * a4.n128_f32[0]);
          ++v7[6];
          LODWORD(v5) = *(_DWORD *)(a2 + 24);
        }
        ++v15;
        v14 += 16;
      }
      while (v15 < v5);
    }
  }
  return result;
}

void *RB::Symbol::tags_intersect(void *__dst, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unint64_t v12;
  unsigned int v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;

  if (a3 && a5)
  {
    v9 = (uint64_t)__dst;
    v10 = 0;
    v11 = 0;
    v12 = 0;
    do
    {
      v13 = *(_DWORD *)(a2 + 4 * v10);
      v14 = *(_DWORD *)(a4 + 4 * v12);
      if (v13 == v14)
      {
        v15 = *(_DWORD *)(v9 + 24);
        if (*(_DWORD *)(v9 + 28) < v15 + 1)
        {
          __dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v9, v15 + 1);
          v15 = *(_DWORD *)(v9 + 24);
        }
        v16 = *(_QWORD *)(v9 + 16);
        if (!v16)
          v16 = v9;
        *(_DWORD *)(v16 + 4 * v15) = v13;
        ++*(_DWORD *)(v9 + 24);
        ++v11;
        ++v12;
      }
      else if (v13 < v14)
      {
        ++v11;
      }
      else
      {
        ++v12;
      }
      if (a3 <= v11)
        break;
      v10 = v11;
    }
    while (v12 < a5);
  }
  return __dst;
}

BOOL RB::Symbol::tags_contains(int *a1, unint64_t a2, unsigned int a3)
{
  uint64_t v3;
  int v4;
  _BOOL8 v5;
  BOOL v6;
  int *v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int *v10;
  int *v11;
  unsigned int v12;

  if (a2 > 8)
  {
    v7 = &a1[a2];
    if (a1 != v7)
    {
      v8 = (uint64_t)(4 * a2) >> 2;
      do
      {
        v9 = v8 >> 1;
        v10 = (unsigned int *)&a1[v8 >> 1];
        v12 = *v10;
        v11 = (int *)(v10 + 1);
        v8 += ~(v8 >> 1);
        if (v12 < a3)
          a1 = v11;
        else
          v8 = v9;
      }
      while (v8);
      if (a1 != v7)
        return *a1 <= a3;
    }
    return 0;
  }
  if (!a2)
    return 0;
  v3 = 4 * a2 - 4;
  do
  {
    v4 = *a1++;
    v5 = v4 == a3;
    v6 = v4 == a3 || v3 == 0;
    v3 -= 4;
  }
  while (!v6);
  return v5;
}

_DWORD *RB::Symbol::tags_merge(_DWORD *__dst, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v7;
  unsigned int v8;
  BOOL v9;
  unint64_t v10;
  unsigned int v11;
  int *v12;
  int v13;
  int v14;
  unsigned int v15;
  uint64_t v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;

  v7 = (uint64_t)__dst;
  v8 = __dst[6];
  if (v8)
    v9 = a3 == 0;
  else
    v9 = 1;
  if (!v9)
  {
    v17 = 0;
    v18 = 0;
    while (1)
    {
      v19 = *(_QWORD *)(v7 + 16);
      if (v19)
        v20 = *(_QWORD *)(v7 + 16);
      else
        v20 = v7;
      v21 = *(_DWORD *)(v20 + 4 * v17);
      v22 = *(_DWORD *)(a2 + 4 * v18);
      if (v21 == v22)
      {
        ++v17;
      }
      else
      {
        if (v21 < v22)
        {
          ++v17;
          goto LABEL_36;
        }
        if (v22 != a4)
        {
          if (*(_DWORD *)(v7 + 28) < v8 + 1)
          {
            __dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v8 + 1);
            v19 = *(_QWORD *)(v7 + 16);
            v8 = *(_DWORD *)(v7 + 24);
          }
          if (v19)
            v23 = v19;
          else
            v23 = v7;
          if (v17 < v8)
            __dst = memmove((void *)(v23 + 4 * v17 + 4), (const void *)(v23 + 4 * v17), 4 * (v8 - (unint64_t)v17));
          *(_DWORD *)(v23 + 4 * v17) = v22;
          v8 = *(_DWORD *)(v7 + 24) + 1;
          *(_DWORD *)(v7 + 24) = v8;
        }
      }
      ++v18;
LABEL_36:
      if (v17 >= v8 || v18 >= a3)
        goto LABEL_7;
    }
  }
  v18 = 0;
LABEL_7:
  v10 = a3 - v18;
  if (a3 > v18)
  {
    v11 = v8 + a3 - v18;
    if (*(_DWORD *)(v7 + 28) < v11)
      __dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v11);
    v12 = (int *)(a2 + 4 * v18);
    do
    {
      v14 = *v12++;
      v13 = v14;
      if (v14 != a4)
      {
        v15 = *(_DWORD *)(v7 + 24);
        if (*(_DWORD *)(v7 + 28) < v15 + 1)
        {
          __dst = RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow((void *)v7, v15 + 1);
          v15 = *(_DWORD *)(v7 + 24);
        }
        v16 = *(_QWORD *)(v7 + 16);
        if (!v16)
          v16 = v7;
        *(_DWORD *)(v16 + 4 * v15) = v13;
        ++*(_DWORD *)(v7 + 24);
      }
      --v10;
    }
    while (v10);
  }
  return __dst;
}

unsigned int *RB::Symbol::tags_subtract(unsigned int *result, uint64_t a2, unint64_t a3)
{
  unsigned int v3;
  BOOL v4;
  unsigned int *v7;
  unsigned int v8;
  unint64_t v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;

  v3 = result[6];
  if (v3)
    v4 = a3 == 0;
  else
    v4 = 1;
  if (!v4)
  {
    v7 = result;
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = (unsigned int *)*((_QWORD *)v7 + 2);
      if (!v10)
        v10 = v7;
      result = &v10[v8];
      v11 = *(_DWORD *)(a2 + 4 * v9);
      if (*result == v11)
      {
        v12 = v3 - 1;
        v7[6] = v12;
        v3 = v8;
        if (v8 != (_DWORD)v12)
        {
          result = (unsigned int *)memmove(result, result + 1, 4 * (v12 - v8));
          v3 = v7[6];
        }
      }
      else if (*result < v11)
      {
        ++v8;
        continue;
      }
      ++v9;
    }
    while (v8 < v3 && v9 < a3);
  }
  return result;
}

double RB::Symbol::Glyph::Layer::content_transform(RB::Symbol::Glyph::Layer *this, float64x2_t *a2)
{
  double result;

  if (*((float *)this + 15) == 0.0)
    *(_QWORD *)&result = *(_OWORD *)&vmulq_n_f64(*a2, *((float *)this + 14));
  else
    *(_QWORD *)&result = *(_OWORD *)&vmulq_n_f64(*a2, (float)-*((float *)this + 14));
  return result;
}

RB::XML::Document *RB::Symbol::Glyph::Layer::clip(uint64_t a1, RB::DisplayList::State *a2, int a3, float64x2_t *a4, RB::Symbol::Presentation *this, float a6, float32x2_t a7)
{
  void *v14;
  RB::DisplayList::State *v16;
  _RBDrawingState *v17;
  unsigned int v18;
  float v19;
  double v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  RB::Symbol::Glyph::Sublayers *v24;
  float v25;
  double v26;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float v31;
  double v32;
  double v33;
  float64x2_t v34;
  float v35;
  double v36;
  _OWORD v37[3];
  _OWORD v38[3];

  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    v14 = (void *)RB::Symbol::Presentation::shape(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v14, a4, a7);
    return RBDrawingStateClipShape2(a2, (uint64_t)v14, a3, a6);
  }
  else
  {
    v16 = RBDrawingStateBeginLayer(a2, 0);
    v17 = (_RBDrawingState *)v16;
    v18 = (*(_DWORD *)(a1 + 84) >> 18) & 3;
    if (v18 >= 2)
    {
      if (v18 == 3)
      {
        v19 = *(float *)(a1 + 60);
        if (v19 == 0.0)
        {
          v20 = *(float *)(a1 + 56);
          v21 = vmulq_n_f64(*a4, v20);
          v22 = vmulq_n_f64(a4[1], v20);
          v23 = a4[2];
        }
        else
        {
          v30 = a4[1];
          v23 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v19), (float64x2_t)0, v30);
          v31 = *(float *)(a1 + 56);
          v32 = v31;
          v21 = vmulq_n_f64(*a4, (float)-v31);
          v22 = vmulq_n_f64(v30, v32);
        }
        v37[0] = v21;
        v37[1] = v22;
        v37[2] = v23;
        RBDrawingStateConcatCTM((uint64_t)v16, (uint64_t)v37);
        RBDrawingStateDrawDisplayList((uint64_t)v17, *(void **)a1, v33);
      }
      else
      {
        v24 = *(RB::Symbol::Glyph::Sublayers **)a1;
        v25 = *(float *)(a1 + 60);
        if (v25 == 0.0)
        {
          v26 = *(float *)(a1 + 56);
          v27 = vmulq_n_f64(*a4, v26);
          v28 = vmulq_n_f64(a4[1], v26);
          v29 = a4[2];
        }
        else
        {
          v34 = a4[1];
          v29 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v25), (float64x2_t)0, v34);
          v35 = *(float *)(a1 + 56);
          v36 = v35;
          v27 = vmulq_n_f64(*a4, (float)-v35);
          v28 = vmulq_n_f64(v34, v36);
        }
        v38[0] = v27;
        v38[1] = v28;
        v38[2] = v29;
        RB::Symbol::Glyph::Sublayers::draw_layers(v24, v17, (const RB::AffineTransform *)v38, this);
      }
    }
    return (RB::XML::Document *)RBDrawingStateClipLayer((uint64_t)a2, (RB::DisplayList::State *)v17, a3, a6);
  }
}

uint64_t RB::Symbol::Glyph::Layer::set_shape(uint64_t a1, void *a2, float64x2_t *a3, float32x2_t a4)
{
  uint64_t *v7;
  uint32x2_t v8;
  unsigned __int32 v9;
  float v10;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;
  float v14;
  double v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  double v21;
  double v22;
  double v24;
  double v25;
  double v26;
  float v27;
  uint64_t v28;
  uint64_t v29;
  float v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  uint64_t v34;
  uint64_t v35;
  float v36;
  double v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  float v42;
  double v43;
  float64x2_t v45;
  float v46;
  double v47;
  float v48;
  uint64_t v49;
  _OWORD v50[3];
  uint64_t v51;
  uint64_t v52;
  _OWORD v53[3];
  _OWORD v54[3];

  v7 = *(uint64_t **)a1;
  v8 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(a4, (float32x2_t)0x3F80000000000000));
  v9 = vpmax_u32(v8, v8).u32[0];
  v10 = *(float *)(a1 + 76);
  if ((v9 & 0x80000000) == 0)
  {
    v11 = 0;
LABEL_5:
    if (v10 <= 0.0)
    {
      v12 = *v7;
      v13 = v7[1];
      v14 = *(float *)(a1 + 60);
      if (v14 == 0.0)
      {
        v15 = *(float *)(a1 + 56);
        v16 = vmulq_n_f64(*a3, v15);
        v17 = vmulq_n_f64(a3[1], v15);
        v18 = a3[2];
      }
      else
      {
        v45 = a3[1];
        v18 = vmlaq_f64(vmlaq_n_f64(a3[2], *a3, v14), (float64x2_t)0, v45);
        v46 = *(float *)(a1 + 56);
        v47 = v46;
        v16 = vmulq_n_f64(*a3, (float)-v46);
        v17 = vmulq_n_f64(v45, v47);
      }
      v54[0] = v16;
      v54[1] = v17;
      v54[2] = v18;
      return objc_msgSend(a2, "setRBPath:transform:", v12, v13, v54);
    }
    goto LABEL_8;
  }
  if (v10 > 0.0)
  {
LABEL_26:
    RB::Symbol::Glyph::Layer::copy_path(a1, 0, &v51, a4);
    v35 = v51;
    v34 = v52;
    v36 = *(float *)(a1 + 60);
    if (v36 == 0.0)
    {
      v37 = *(float *)(a1 + 56);
      v38 = vmulq_n_f64(*a3, v37);
      v39 = vmulq_n_f64(a3[1], v37);
      v40 = a3[2];
    }
    else
    {
      v41 = a3[1];
      v40 = vmlaq_f64(vmlaq_n_f64(a3[2], *a3, v36), (float64x2_t)0, v41);
      v42 = *(float *)(a1 + 56);
      v43 = v42;
      v38 = vmulq_n_f64(*a3, (float)-v42);
      v39 = vmulq_n_f64(v41, v43);
    }
    v50[0] = v38;
    v50[1] = v39;
    v50[2] = v40;
    objc_msgSend(a2, "setRBPath:transform:", v51, v52, v50);
    return RBPathRelease(v35, v34);
  }
  v11 = *((_DWORD *)v7 + 6) != 0;
  if (!*((_DWORD *)v7 + 6))
    goto LABEL_5;
LABEL_8:
  if (v10 <= 0.0)
    v11 = 1;
  if (v11)
    goto LABEL_26;
  v19 = *a3;
  v20 = a3[1];
  v21 = a3[1].f64[1];
  v22 = a3->f64[1];
  if (a3->f64[0] != v21 || v22 != 0.0 || v20.f64[0] != 0.0)
  {
    if (v21 != 0.0)
      goto LABEL_26;
    if (v19.f64[0] != 0.0 || v22 != v20.f64[0])
      goto LABEL_26;
  }
  v24 = fabs(v19.f64[0]);
  v25 = fabs(v22);
  v26 = v22 == 0.0 ? v24 : v25;
  v27 = v26;
  if (v27 != 1.0)
    goto LABEL_26;
  v28 = *v7;
  v29 = v7[1];
  v30 = *(float *)(a1 + 60);
  if (v30 == 0.0)
  {
    v31 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(*(float *)(a1 + 56)), 0);
    v32 = a3[2];
    v33 = v31;
  }
  else
  {
    v32 = vmlaq_n_f64(vmlaq_f64(a3[2], (float64x2_t)0, v20), v19, v30);
    v48 = *(float *)(a1 + 56);
    *(double *)&v49 = v48;
    v31 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v48), 0);
    v33 = (float64x2_t)vdupq_lane_s64(v49, 0);
  }
  v53[0] = vmulq_f64(v31, v19);
  v53[1] = vmulq_f64(v33, v20);
  v53[2] = v32;
  return objc_msgSend(a2, "setStrokedRBPath:transform:lineWidth:lineCap:lineJoin:miterLimit:dashPhase:dashPattern:dashCount:", v28, v29, v53, ((__int16)*(_DWORD *)(a1 + 84) >> 12), ((int)(*(_DWORD *)(a1 + 84) << 14) >> 30), 0, v10, 10.0, 0.0, 0);
}

void sub_209B1E190(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  RBPathRelease(v2, v1);
  _Unwind_Resume(a1);
}

void RB::Symbol::Glyph::Sublayers::draw_layers(RB::Symbol::Glyph::Sublayers *this, _RBDrawingState *a2, const RB::AffineTransform *a3, const RB::Symbol::Presentation *a4)
{
  int v5;
  unsigned int v8;
  size_t v9;
  _RBDrawingState *v10;
  BOOL v11;
  RB::DisplayList::State *v12;
  int v13;
  unsigned int v14;
  RB::Symbol::Glyph::Sublayers *v15;
  uint64_t v16;
  char *v17;
  RB::DisplayList::State *v18;
  _BYTE *v19;
  _RBDrawingState *v20;
  size_t v21;
  _BYTE *v22;
  RB::Symbol::Glyph::Sublayers *v23;
  unsigned int v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  _BYTE v29[64];
  void *v30;
  size_t v31;
  unint64_t v32;
  uint64_t v33;

  v5 = (int)a3;
  v33 = *MEMORY[0x24BDAC8D0];
  v8 = objc_msgSend((id)RBDrawingStateGetDisplayList((uint64_t)a2), "profile");
  v11 = rb_profile_supports_porter_duff_blending(v8);
  v30 = 0;
  v31 = 0;
  v32 = 8;
  if (v11)
  {
    v12 = RBDrawingStateBeginLayer((RB::DisplayList::State *)a2, 0);
  }
  else
  {
    v13 = *((_DWORD *)this + 68);
    v12 = (RB::DisplayList::State *)a2;
    if (v13)
    {
      v9 = 0;
      v14 = v13 - 1;
      do
      {
        v15 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)this + 33);
        if (!v15)
          v15 = this;
        v16 = v14;
        v17 = (char *)v15 + 88 * v14;
        if ((v17[86] & 0x40) != 0)
        {
          v18 = (RB::DisplayList::State *)a2;
          if (v9)
          {
            v19 = v30;
            if (!v30)
              v19 = v29;
            v18 = *(RB::DisplayList::State **)&v19[8 * v9 - 8];
          }
          v20 = RBDrawingStateInit(v18);
          RB::Symbol::Glyph::Layer::clip((int)v17, (RB::DisplayList::State *)v20, 1, v5, a4);
          v21 = v31;
          v9 = v31 + 1;
          if (v32 < v31 + 1)
          {
            RB::vector<RBDevice *,8ul,unsigned long>::reserve_slow(v29, v9);
            v21 = v31;
            v9 = v31 + 1;
          }
          v22 = v30;
          if (!v30)
            v22 = v29;
          *(_QWORD *)&v22[8 * v21] = v20;
          v31 = v9;
        }
        --v14;
      }
      while (v16);
      v12 = (RB::DisplayList::State *)a2;
    }
  }
  if (*((_QWORD *)this + 33))
    v23 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)this + 33);
  else
    v23 = this;
  v24 = *((_DWORD *)this + 68);
  if (v24)
  {
    v25 = 88 * v24;
    do
    {
      if ((*((_BYTE *)v23 + 86) & 0x40) != 0)
      {
        if (v11)
        {
          RB::Symbol::Glyph::Layer::draw((int)v23, (int)v12, 23, v5, a4);
        }
        else
        {
          v26 = v30;
          if (!v30)
            v26 = v29;
          RBDrawingStateDestroy(*(RB::XML::Document **)&v26[8 * v31-- - 8], (const char *)v9, v10);
        }
      }
      if (*((float *)v23 + 18) > 0.0)
      {
        LODWORD(v27) = (_DWORD)v12;
        if (v31)
        {
          v28 = v30;
          if (!v30)
            v28 = v29;
          v27 = *(_QWORD *)&v28[8 * v31 - 8];
        }
        RB::Symbol::Glyph::Layer::draw((int)v23, v27, 0, v5, a4);
      }
      v23 = (RB::Symbol::Glyph::Sublayers *)((char *)v23 + 88);
      v25 -= 88;
    }
    while (v25);
  }
  if (v11)
    RBDrawingStateDrawLayer((uint64_t)a2, v12, 0, 1.0);
  if (v30)
    free(v30);
}

void sub_209B1E43C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17)
    free(a17);
  _Unwind_Resume(exception_object);
}

unsigned int *RB::Symbol::Glyph::Layer::draw(uint64_t a1, RB::DisplayList::State *a2, unsigned int a3, float64x2_t *a4, RB::Symbol::Presentation *this, uint64_t a6, float a7, float32x2_t a8)
{
  void *v16;
  float16x4_t *v17;
  RB::DisplayList::State *v19;
  _RBDrawingState *v20;
  unsigned int v21;
  float v22;
  double v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  _RBDrawingState *v27;
  void *v28;
  float16x4_t *v29;
  const char *v30;
  _RBDrawingState *v31;
  RB::Symbol::Glyph::Sublayers *v32;
  float v33;
  double v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float v39;
  double v40;
  double v41;
  float64x2_t v42;
  float v43;
  double v44;
  _OWORD v45[3];
  _OWORD v46[3];

  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000)
  {
    v16 = (void *)RB::Symbol::Presentation::shape(this);
    v17 = (float16x4_t *)RB::Symbol::Presentation::fill(this);
    RB::Symbol::Glyph::Layer::set_shape(a1, v16, a4, a8);
    (*(void (**)(uint64_t, float16x4_t *))(a6 + 16))(a6, v17);
    return (unsigned int *)RBDrawingStateDrawShape((uint64_t)a2, (uint64_t)v16, v17, a3, a7);
  }
  else if ((*(_DWORD *)(a1 + 84) & 0xF00) == 0xA00)
  {
    v19 = RBDrawingStateBeginLayer(a2, 0);
    v20 = (_RBDrawingState *)v19;
    v21 = (*(_DWORD *)(a1 + 84) >> 18) & 3;
    if (v21 >= 2)
    {
      if (v21 == 3)
      {
        v22 = *(float *)(a1 + 60);
        if (v22 == 0.0)
        {
          v23 = *(float *)(a1 + 56);
          v24 = vmulq_n_f64(*a4, v23);
          v25 = vmulq_n_f64(a4[1], v23);
          v26 = a4[2];
        }
        else
        {
          v38 = a4[1];
          v26 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v22), (float64x2_t)0, v38);
          v39 = *(float *)(a1 + 56);
          v40 = v39;
          v24 = vmulq_n_f64(*a4, (float)-v39);
          v25 = vmulq_n_f64(v38, v40);
        }
        v45[0] = v24;
        v45[1] = v25;
        v45[2] = v26;
        RBDrawingStateConcatCTM((uint64_t)v19, (uint64_t)v45);
        RBDrawingStateDrawDisplayList((uint64_t)v20, *(void **)a1, v41);
      }
      else
      {
        v32 = *(RB::Symbol::Glyph::Sublayers **)a1;
        v33 = *(float *)(a1 + 60);
        if (v33 == 0.0)
        {
          v34 = *(float *)(a1 + 56);
          v35 = vmulq_n_f64(*a4, v34);
          v36 = vmulq_n_f64(a4[1], v34);
          v37 = a4[2];
        }
        else
        {
          v42 = a4[1];
          v37 = vmlaq_f64(vmlaq_n_f64(a4[2], *a4, v33), (float64x2_t)0, v42);
          v43 = *(float *)(a1 + 56);
          v44 = v43;
          v35 = vmulq_n_f64(*a4, (float)-v43);
          v36 = vmulq_n_f64(v42, v44);
        }
        v46[0] = v35;
        v46[1] = v36;
        v46[2] = v37;
        RB::Symbol::Glyph::Sublayers::draw_layers(v32, v20, (const RB::AffineTransform *)v46, this);
      }
    }
    return (unsigned int *)RBDrawingStateDrawLayer((uint64_t)a2, (RB::DisplayList::State *)v20, a3, a7);
  }
  else
  {
    v27 = RBDrawingStateInit(a2);
    RB::Symbol::Glyph::Layer::clip(a1, (RB::DisplayList::State *)v27, 0, a4, this, 1.0, a8);
    v28 = (void *)RB::Symbol::Presentation::shape(this);
    v29 = (float16x4_t *)RB::Symbol::Presentation::fill(this);
    objc_msgSend(v28, "setInfinite");
    (*(void (**)(uint64_t, float16x4_t *))(a6 + 16))(a6, v29);
    RBDrawingStateDrawShape((uint64_t)v27, (uint64_t)v28, v29, a3, a7);
    return RBDrawingStateDestroy((RB::XML::Document *)v27, v30, v31);
  }
}

uint64_t ___ZNK2RB6Symbol5Glyph5Layer4drawEP15_RBDrawingState7RBColorf11RBBlendModeRKNS_15AffineTransformEDv2_fRKNS0_12PresentationE_block_invoke(_DWORD *a1, void *a2, double a3, double a4, double a5, double a6)
{
  LODWORD(a3) = a1[8];
  LODWORD(a4) = a1[9];
  LODWORD(a5) = a1[10];
  LODWORD(a6) = a1[11];
  return objc_msgSend(a2, "setColor:colorSpace:", 1, a3, a4, a5, a6);
}

void RB::Symbol::Glyph::Layer::copy_path(uint64_t a1@<X0>, _BYTE *a2@<X1>, uint64_t *a3@<X8>, float32x2_t a4@<D0>)
{
  uint32x2_t v7;
  unsigned int *v8;
  unsigned int *v9;
  char v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  _BYTE v14[64];

  if ((*(_DWORD *)(a1 + 84) & 0xC0000) == 0x40000
    && *(float *)(a1 + 76) <= 0.0
    && (v7 = (uint32x2_t)vceq_f32(a4, (float32x2_t)0x3F80000000000000), (vpmin_u32(v7, v7).u32[0] & 0x80000000) != 0))
  {
    if (a2)
      *a2 = 0;
    *a3 = RBPathRetain(**(_QWORD **)a1, *(_QWORD *)(*(_QWORD *)a1 + 8));
    a3[1] = v13;
  }
  else
  {
    v8 = (unsigned int *)operator new();
    v8[2] = 1;
    v9 = v8 + 2;
    *(_QWORD *)v8 = off_24C229608;
    RB::Path::Storage::Storage((uint64_t)v14, (const char *)0x90);
    RB::Path::Storage::Storage((RB::Path::Storage *)(v8 + 4), (const char *)0x90, (const RB::Path::Storage *)v14);
    RB::Path::Storage::~Storage((RB::Path::Storage *)v14);
    RB::Symbol::Glyph::Layer::append_path(a1);
    if ((v10 & 1) != 0)
    {
      if (a2)
        *a2 = 1;
      *a3 = (uint64_t)v8;
      a3[1] = (uint64_t)&RB::Path::Object::callbacks;
    }
    else
    {
      if (a2)
        *a2 = 0;
      *(_OWORD *)a3 = RBPathEmpty;
      do
      {
        v11 = __ldxr(v9);
        v12 = v11 - 1;
      }
      while (__stlxr(v12, v9));
      if (!v12)
      {
        __dmb(9u);
        (*(void (**)(unsigned int *))(*(_QWORD *)v8 + 8))(v8);
      }
    }
  }
}

void sub_209B1E88C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  unsigned int *v2;
  unsigned int v4;
  unsigned int v5;

  do
  {
    v4 = __ldxr(v2);
    v5 = v4 - 1;
  }
  while (__stlxr(v5, v2));
  if (!v5)
    render_image_async(v1);
  _Unwind_Resume(exception_object);
}

void RB::Symbol::Glyph::Layer::append_path(uint64_t a1)
{
  __asm { BR              X11 }
}

uint64_t sub_209B1E934@<X0>(float32x2_t a1@<D0>, unsigned int a2@<W8>, __int128 a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16)
{
  RB::Path::Storage *v17;
  float *v18;
  uint32x2_t v19;
  unsigned __int32 v20;
  float v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  float32x2_t v26;
  int32x2_t v27;
  uint64_t v28;
  uint64_t v29;
  float64x2_t v30;
  double v31;
  __int128 v32;

  v19 = (uint32x2_t)vmvn_s8((int8x8_t)vceq_f32(a1, (float32x2_t)0x3F80000000000000));
  v20 = vpmax_u32(v19, v19).u32[0];
  v21 = v18[19];
  if (v21 <= 0.0)
  {
    if ((v20 & 0x80000000) != 0 && (v23 = *(_QWORD *)v18, v24 = *(unsigned int *)(*(_QWORD *)v18 + 24), (_DWORD)v24))
    {
      v27 = (int32x2_t)0x100000000;
      v28 = v24;
      v29 = *(_QWORD *)(v23 + 16);
      if (a1.f32[0] == 0.0)
        a1.i32[0] = a1.i32[1];
      else
        v27.i32[0] = 1;
      v31 = a1.f32[0];
      RB::Path::Storage::append_element(v17, (const char *)0x18, &v31, (int *)&v27);
      v22 = 1;
    }
    else
    {
      v22 = 0;
    }
  }
  else
  {
    v26 = a1;
    v22 = v20 >> 31;
    v27 = vshl_s32((int32x2_t)vshl_u32((uint32x2_t)vdup_n_s32(a2), (uint32x2_t)0xE00000010), (int32x2_t)0xFFFFFFE2FFFFFFE4);
    v28 = 0;
    v29 = 0;
    v31 = (float)(v21 / v18[14]);
    v32 = xmmword_209BD6B30;
    RB::Path::Storage::append_element(v17, (const char *)0x13, &v31, (int *)&v27);
    if ((v20 & 0x80000000) != 0)
    {
      v30 = vcvtq_f64_f32(v26);
      RB::Path::Storage::append_element(v17, (const char *)0x12, v30.f64, 0);
    }
  }
  RB::Path::Storage::append_path(v17, *(RBPath *)*(_QWORD *)v18);
  if (v18[19] > 0.0)
  {
    if (v22)
      RB::Path::Storage::append_element(v17, (const char *)0x10, 0, 0);
    goto LABEL_15;
  }
  if (v22)
LABEL_15:
    RB::Path::Storage::append_element(v17, (const char *)0x10, 0, 0);
  return 1;
}

uint64_t RB::Symbol::Glyph::Sublayers::append_path(RB::Symbol::Glyph::Sublayers **this, RB::Path::Storage *a2, unsigned int a3)
{
  RB::Symbol::Glyph::Sublayers *v5;
  float v6;
  float v7;
  float v8;
  unsigned int v10;
  RB::Symbol::Glyph::Sublayers *v11;
  float v12;
  uint64_t v14;
  signed int v15;
  int v16;
  int v17;
  BOOL v18;
  float v19;
  int v20;
  signed int v22;
  uint64_t v23;
  uint64_t v24;
  RB::Symbol::Glyph::Sublayers *v25;
  char *v26;
  float v27;
  float v28;
  uint64_t v29;
  float64x2_t v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  int v34;
  uint64_t v35;
  unsigned int v36;
  float64x2_t v37;
  RB::Symbol::Glyph::Sublayers *v38;
  float *v39;
  float v40;
  float v41;
  char appended;
  uint64_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  uint64_t v47;
  float64x2_t v48;
  float64x2_t v49;
  float64x2_t v50;
  uint64_t v51;
  int v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;

  if (!a3)
    return 1;
  v5 = (RB::Symbol::Glyph::Sublayers *)this;
  if (a3 != 1)
  {
    HIWORD(v52) = 2;
    RB::Path::Storage::append_element(a2, (const char *)0x14, 0, (int *)((char *)&v52 + 2));
    v10 = a3;
    do
    {
      if ((--v10 & 0x80000000) != 0)
      {
        v15 = 0;
LABEL_45:
        if (v15 < a3)
        {
          if ((v10 & 0x80000000) != 0)
            v34 = -1;
          else
            v34 = v10;
          v35 = 88 * (v34 + 1);
          v36 = ~v34 + a3;
          v37 = (float64x2_t)xmmword_209BD5290;
          do
          {
            v38 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)v5 + 33);
            if (!v38)
              v38 = v5;
            v39 = (float *)((char *)v38 + v35);
            if (*(float *)((char *)v38 + v35 + 72) > 0.0)
            {
              v41 = v39[14];
              v40 = v39[15];
              if (v41 == 1.0 && v40 == 0.0)
              {
                appended = RB::Symbol::Glyph::Layer::append_path((char *)v38 + v35, a2, 0.0078125);
                v37 = (float64x2_t)xmmword_209BD5290;
                if ((appended & 1) == 0)
                  return 0;
              }
              else
              {
                *(double *)&v43 = v41;
                if (v40 == 0.0)
                {
                  v44 = (float64x2_t)vdupq_lane_s64(v43, 0);
                  v45 = 0uLL;
                  v46 = v44;
                }
                else
                {
                  v45 = vmulq_n_f64(v37, v40);
                  v44 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v41), 0);
                  v46 = (float64x2_t)vdupq_lane_s64(v43, 0);
                }
                v53 = vmulq_f64(v44, v37);
                v54 = vmulq_f64(v46, (float64x2_t)xmmword_209BD52A0);
                v55 = v45;
                RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
                if (!RB::Symbol::Glyph::Layer::append_path(v39, a2, 0.0078125))
                  return 0;
                RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
                v37 = (float64x2_t)xmmword_209BD5290;
              }
            }
            v35 += 88;
            --v36;
          }
          while (v36);
        }
        RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
        return 1;
      }
      v11 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)v5 + 33);
      if (!v11)
        v11 = v5;
      v12 = *((float *)v11 + 22 * v10 + 18);
      if (v12 > 0.0 && v12 != 1.0)
        return 0;
    }
    while ((*((_BYTE *)v11 + 88 * v10 + 86) & 0x40) == 0);
    v14 = (uint64_t)v11 + 88 * v10 - 16;
    v15 = v10 + 1;
    v16 = v10;
    while (1)
    {
      v17 = v16;
      v18 = __OFSUB__(v16--, 1);
      if (v16 < 0 != v18)
        break;
      v19 = *(float *)v14;
      v20 = *(_DWORD *)(v14 + 12) & 0x400000;
      v14 -= 88;
      if (v19 > 0.0 || v20 == 0)
      {
        v22 = v16 + 1;
        goto LABEL_30;
      }
    }
    v22 = 0;
LABEL_30:
    LOWORD(v52) = 3;
    RB::Path::Storage::append_element(a2, (const char *)0x14, 0, &v52);
    if (RB::Symbol::Glyph::Sublayers::append_path(v5, a2, v22))
    {
      if (v22 < v15)
      {
        v23 = v17 & ~(v17 >> 31);
        v24 = 88 * v23;
        do
        {
          RB::Path::Storage::append_element(a2, (const char *)0x15, 0, 0);
          v25 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)v5 + 33);
          if (!v25)
            v25 = v5;
          v26 = (char *)v25 + v24;
          v28 = *(float *)((char *)v25 + v24 + 56);
          v27 = *(float *)((char *)v25 + v24 + 60);
          if (v28 == 1.0 && v27 == 0.0)
          {
            RB::Symbol::Glyph::Layer::append_path((char *)v25 + v24, a2, 0.0078125);
          }
          else
          {
            *(double *)&v29 = v28;
            if (v27 == 0.0)
            {
              v30 = (float64x2_t)vdupq_lane_s64(v29, 0);
              v31 = 0uLL;
              v32 = v30;
              v33 = (float64x2_t)xmmword_209BD5290;
            }
            else
            {
              v33 = (float64x2_t)xmmword_209BD5290;
              v31 = vmulq_n_f64((float64x2_t)xmmword_209BD5290, v27);
              v30 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v28), 0);
              v32 = (float64x2_t)vdupq_lane_s64(v29, 0);
            }
            v53 = vmulq_f64(v30, v33);
            v54 = vmulq_f64(v32, (float64x2_t)xmmword_209BD52A0);
            v55 = v31;
            RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
            if (RB::Symbol::Glyph::Layer::append_path(v26, a2, 0.0078125))
              RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
          }
          ++v23;
          v24 += 88;
        }
        while (v23 < v15);
      }
      RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
      goto LABEL_45;
    }
    return 0;
  }
  if (this[33])
    v5 = this[33];
  v6 = *((float *)v5 + 18);
  if (v6 <= 0.0)
    return 1;
  if (v6 != 1.0)
    return 0;
  v8 = *((float *)v5 + 14);
  v7 = *((float *)v5 + 15);
  if (v8 == 1.0 && v7 == 0.0)
    return RB::Symbol::Glyph::Layer::append_path(v5, a2, 0.0078125);
  if (v7 == 0.0)
  {
    v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64(v8), 0);
    v49 = 0uLL;
    v50 = v48;
  }
  else
  {
    v49 = vmulq_n_f64((float64x2_t)xmmword_209BD5290, v7);
    *(double *)&v51 = v8;
    v48 = (float64x2_t)vdupq_lane_s64(COERCE__INT64((float)-v8), 0);
    v50 = (float64x2_t)vdupq_lane_s64(v51, 0);
  }
  v53 = vmulq_f64(v48, (float64x2_t)xmmword_209BD5290);
  v54 = vmulq_f64(v50, (float64x2_t)xmmword_209BD52A0);
  v55 = v49;
  RB::Path::Storage::append_element(a2, (const char *)0x11, 0, (int *)&v53);
  v47 = RB::Symbol::Glyph::Layer::append_path(v5, a2, 0.0078125);
  if ((_DWORD)v47)
    RB::Path::Storage::append_element(a2, (const char *)0x10, 0, 0);
  return v47;
}

void RB::Symbol::Glyph::Sublayers::print(RB::Symbol::Glyph::Sublayers *this, std::string *a2)
{
  RB::Symbol::Glyph::Sublayers *v4;
  unsigned int v5;
  uint64_t v6;
  float *v7;
  const char *v8;
  float v9;

  RB::SexpString::push(a2, "sublayers");
  v4 = (RB::Symbol::Glyph::Sublayers *)*((_QWORD *)this + 33);
  if (!v4)
    v4 = this;
  v5 = *((_DWORD *)this + 68);
  if (v5)
  {
    v6 = 88 * v5;
    v7 = (float *)((char *)v4 + 84);
    do
    {
      if ((*(_DWORD *)v7 & 0x400000) != 0)
        v8 = "eraser-layer";
      else
        v8 = "layer";
      RB::SexpString::push(a2, v8);
      v9 = *(v7 - 3);
      if (v9 != 1.0)
        RB::SexpString::printf(a2, 0, "(alpha %.2g)", v9);
      if ((*(_DWORD *)v7 & 0xC0000) == 0x80000)
        RB::Symbol::Glyph::Sublayers::print(*(RB::Symbol::Glyph::Sublayers **)(v7 - 21), (RB::SexpString *)a2);
      RB::SexpString::pop(a2);
      v7 += 22;
      v6 -= 88;
    }
    while (v6);
  }
  RB::SexpString::pop(a2);
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_0::__invoke(uint64_t a1)
{
  return *(_QWORD *)(a1 + 8);
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_1::__invoke(uint64_t a1, uint64_t a2)
{
  void *v2;

  if (*(_DWORD *)(a1 + 16) != *(_DWORD *)(a2 + 16) || *(unsigned __int8 *)(a1 + 20) != *(unsigned __int8 *)(a2 + 20))
    return 0;
  v2 = *(void **)a1;
  if (v2 == *(void **)a2)
    return 1;
  else
    return objc_msgSend(v2, "isEqual:");
}

uint64_t RB::Symbol::GlyphCache::GlyphCache(void)::$_3::__invoke(void *a1, const char *a2)
{
  return objc_msgSend(a1, "isEqualToString:", a2);
}

BOOL std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v3;
  unsigned int v4;
  unsigned int v5;
  BOOL v6;

  if (*(float *)a2 == *(float *)a3)
    v3 = 0;
  else
    v3 = -127;
  if (*(float *)a2 > *(float *)a3)
    v3 = 1;
  if (*(float *)a2 < *(float *)a3)
    v3 = -1;
  if (!v3)
  {
    v4 = *(_DWORD *)(a2 + 4);
    v5 = *(_DWORD *)(a3 + 4);
    v6 = v4 == v5;
    LOBYTE(v3) = v4 < v5 ? -1 : 1;
    if (v6)
      LOBYTE(v3) = 0;
  }
  return v3 != 129 && (v3 & 0x80u) != 0;
}

uint64_t std::__insertion_sort[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(uint64_t result, float *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v7;
  uint64_t v8;
  float *v9;
  float v10;
  unsigned int v11;
  uint64_t v12;
  float v13;
  uint64_t v14;
  int v15;
  unsigned int v16;
  BOOL v17;
  uint64_t v18;

  if ((float *)result != a2)
  {
    v4 = result;
    v5 = result + 8;
    if ((float *)(result + 8) != a2)
    {
      v7 = 0;
      v8 = result;
      do
      {
        v9 = (float *)v5;
        result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v5, v8);
        if ((_DWORD)result)
        {
          v10 = *v9;
          v11 = *(_DWORD *)(v8 + 12);
          v12 = v7;
          v13 = *(float *)v8;
          while (1)
          {
            v14 = v4 + v12;
            *(float *)(v14 + 8) = v13;
            *(_DWORD *)(v14 + 12) = *(_DWORD *)(v4 + v12 + 4);
            if (!v12)
              break;
            v13 = *(float *)(v14 - 8);
            if (v10 == v13)
              v15 = 0;
            else
              v15 = -127;
            if (v10 > v13)
              v15 = 1;
            if (v10 < v13)
              v15 = -1;
            if (!v15)
            {
              v16 = *(_DWORD *)(v4 + v12 - 4);
              v17 = v11 == v16;
              if (v11 < v16)
                LOBYTE(v15) = -1;
              else
                LOBYTE(v15) = 1;
              if (v17)
                LOBYTE(v15) = 0;
            }
            v12 -= 8;
            if (v15 == 129 || (v15 & 0x80) == 0)
            {
              v18 = v4 + v12 + 8;
              goto LABEL_24;
            }
          }
          v18 = v4;
LABEL_24:
          *(float *)v18 = v10;
          *(_DWORD *)(v18 + 4) = v11;
        }
        v5 = (uint64_t)(v9 + 2);
        v7 += 8;
        v8 = (uint64_t)v9;
      }
      while (v9 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(uint64_t result, float *a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  float *v7;
  float *v8;
  float v9;
  unsigned int v10;
  float *v11;
  float v12;
  int v13;
  unsigned int v14;
  BOOL v15;

  if ((float *)result != a2)
  {
    v4 = result;
    v5 = result + 8;
    if ((float *)(result + 8) != a2)
    {
      v7 = (float *)(result + 12);
      do
      {
        v8 = (float *)v5;
        result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v5, v4);
        if ((_DWORD)result)
        {
          v9 = *v8;
          v10 = *(_DWORD *)(v4 + 12);
          v11 = v7;
          v12 = *(float *)v4;
          do
          {
            *(v11 - 1) = v12;
            *v11 = *(v11 - 2);
            v12 = *(v11 - 5);
            if (v9 == v12)
              v13 = 0;
            else
              v13 = -127;
            if (v9 > v12)
              v13 = 1;
            if (v9 < v12)
              v13 = -1;
            if (!v13)
            {
              v14 = *((_DWORD *)v11 - 4);
              v15 = v10 == v14;
              if (v10 < v14)
                LOBYTE(v13) = -1;
              else
                LOBYTE(v13) = 1;
              if (v15)
                LOBYTE(v13) = 0;
            }
            v11 -= 2;
          }
          while (v13 != 129 && (v13 & 0x80) != 0);
          *(v11 - 1) = v9;
          *(_DWORD *)v11 = v10;
        }
        v5 = (uint64_t)(v8 + 2);
        v7 += 2;
        v4 = (uint64_t)v8;
      }
      while (v8 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, uint64_t a4)
{
  BOOL v8;
  uint64_t result;
  int v10;
  int *v11;
  int *v12;
  int v13;
  int v14;
  int *v15;
  int v16;
  int v17;
  int v18;
  int v19;

  v8 = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a2, (uint64_t)a1);
  result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a3, (uint64_t)a2);
  if (v8)
  {
    v10 = *a1;
    if ((_DWORD)result)
    {
      *a1 = *a3;
      *a3 = v10;
      v11 = a3 + 1;
      result = 1;
      v12 = a1 + 1;
LABEL_9:
      v15 = v11;
      goto LABEL_10;
    }
    *a1 = *a2;
    *a2 = v10;
    v17 = a1[1];
    a1[1] = a2[1];
    a2[1] = v17;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a3, (uint64_t)a2))
    {
      v18 = *a2;
      *a2 = *a3;
      *a3 = v18;
      v11 = a3 + 1;
      result = 2;
      v12 = a2 + 1;
      goto LABEL_9;
    }
  }
  else
  {
    if (!(_DWORD)result)
      return result;
    v13 = *a2;
    *a2 = *a3;
    *a3 = v13;
    v15 = a2 + 1;
    v14 = a2[1];
    a2[1] = a3[1];
    a3[1] = v14;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)a2, (uint64_t)a1))
    {
      v16 = *a1;
      *a1 = *a2;
      v12 = a1 + 1;
      *a2 = v16;
      result = 2;
LABEL_10:
      v19 = *v12;
      *v12 = *v15;
      *v15 = v19;
      return result;
    }
  }
  return 1;
}

unint64_t std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>(unint64_t a1, float *a2)
{
  float v2;
  unsigned int v3;
  float v4;
  int v5;
  unsigned int v6;
  BOOL v7;
  unint64_t v8;
  unint64_t v9;
  float v10;
  int v11;
  unsigned int v12;
  BOOL v13;
  char v14;
  unint64_t v15;
  int v16;
  unsigned int v17;
  BOOL v18;
  float *v19;
  float v20;
  BOOL v21;
  BOOL v22;
  int v23;
  unsigned int v24;
  BOOL v25;
  float v26;
  float v27;
  int v28;
  unint64_t v29;
  int v30;
  unsigned int v31;
  BOOL v32;
  char v33;
  float *v34;
  float v35;
  BOOL v36;
  BOOL v37;
  int v38;
  unsigned int v39;
  BOOL v40;
  char v41;

  v2 = *(float *)a1;
  v3 = *(_DWORD *)(a1 + 4);
  v4 = *(a2 - 2);
  if (*(float *)a1 == v4)
    v5 = 0;
  else
    v5 = -127;
  if (*(float *)a1 > v4)
    v5 = 1;
  if (*(float *)a1 < v4)
    v5 = -1;
  if (!v5)
  {
    v6 = *((_DWORD *)a2 - 1);
    v7 = v3 == v6;
    LOBYTE(v5) = v3 < v6 ? -1 : 1;
    if (v7)
      LOBYTE(v5) = 0;
  }
  if (v5 == 129 || (v5 & 0x80) == 0)
  {
    v15 = a1 + 8;
    do
    {
      v9 = v15;
      if (v15 >= (unint64_t)a2)
        break;
      if (v2 == *(float *)v15)
        v16 = 0;
      else
        v16 = -127;
      if (v2 > *(float *)v15)
        v16 = 1;
      if (v2 < *(float *)v15)
        v16 = -1;
      if (!v16)
      {
        v17 = *(_DWORD *)(v15 + 4);
        v18 = v3 == v17;
        LOBYTE(v16) = v3 < v17 ? -1 : 1;
        if (v18)
          LOBYTE(v16) = 0;
      }
      v15 += 8;
    }
    while (v16 == 129 || (v16 & 0x80) == 0);
  }
  else
  {
    v8 = a1;
    while (1)
    {
      v9 = v8 + 8;
      v10 = *(float *)(v8 + 8);
      if (v2 == v10)
        v11 = 0;
      else
        v11 = -127;
      if (v2 > v10)
        v11 = 1;
      if (v2 < v10)
        v11 = -1;
      if (!v11)
      {
        v12 = *(_DWORD *)(v8 + 12);
        v13 = v3 == v12;
        if (v3 < v12)
          v14 = -1;
        else
          v14 = 1;
        if (v13)
          LOBYTE(v11) = 0;
        else
          LOBYTE(v11) = v14;
      }
      v8 = v9;
      if (v11 != 129)
      {
        v8 = v9;
        if ((v11 & 0x80) != 0)
          break;
      }
    }
  }
  if (v9 >= (unint64_t)a2)
  {
    v19 = a2;
  }
  else
  {
    v19 = a2;
    do
    {
      v20 = *(v19 - 2);
      v19 -= 2;
      v21 = v2 < v20;
      v22 = v2 <= v20;
      if (v2 == v20)
        v23 = 0;
      else
        v23 = -127;
      if (!v22)
        v23 = 1;
      if (v21)
        v23 = -1;
      if (!v23)
      {
        v24 = *((_DWORD *)a2 - 1);
        v25 = v3 == v24;
        LOBYTE(v23) = v3 < v24 ? -1 : 1;
        if (v25)
          LOBYTE(v23) = 0;
      }
      if (v23 == 129)
        break;
      a2 = v19;
    }
    while ((v23 & 0x80) != 0);
  }
  if (v9 < (unint64_t)v19)
  {
    v26 = *(float *)v9;
    v27 = *v19;
    do
    {
      *(float *)v9 = v27;
      *v19 = v26;
      v28 = *(_DWORD *)(v9 + 4);
      *(float *)(v9 + 4) = v19[1];
      *((_DWORD *)v19 + 1) = v28;
      v29 = v9;
      while (1)
      {
        v9 = v29 + 8;
        v26 = *(float *)(v29 + 8);
        if (v2 == v26)
          v30 = 0;
        else
          v30 = -127;
        if (v2 > v26)
          v30 = 1;
        if (v2 < v26)
          v30 = -1;
        if (!v30)
        {
          v31 = *(_DWORD *)(v29 + 12);
          v32 = v3 == v31;
          if (v3 < v31)
            v33 = -1;
          else
            v33 = 1;
          if (v32)
            LOBYTE(v30) = 0;
          else
            LOBYTE(v30) = v33;
        }
        v29 = v9;
        if (v30 != 129)
        {
          v29 = v9;
          if ((v30 & 0x80) != 0)
            break;
        }
      }
      v34 = v19;
      do
      {
        v35 = *(v19 - 2);
        v19 -= 2;
        v27 = v35;
        v36 = v2 < v35;
        v37 = v2 <= v35;
        if (v2 == v35)
          v38 = 0;
        else
          v38 = -127;
        if (!v37)
          v38 = 1;
        if (v36)
          v38 = -1;
        if (!v38)
        {
          v39 = *((_DWORD *)v34 - 1);
          v40 = v3 == v39;
          if (v3 < v39)
            v41 = -1;
          else
            v41 = 1;
          if (v40)
            LOBYTE(v38) = 0;
          else
            LOBYTE(v38) = v41;
        }
        if (v38 == 129)
          break;
        v34 = v19;
      }
      while ((v38 & 0x80) != 0);
    }
    while (v9 < (unint64_t)v19);
  }
  if (v9 - 8 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v9 - 8);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v9 - 4);
  }
  *(float *)(v9 - 8) = v2;
  *(_DWORD *)(v9 - 4) = v3;
  return v9;
}

unint64_t std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,std::pair<float,unsigned int> *,std::__less<void,void> &>(uint64_t a1, float *a2)
{
  uint64_t v2;
  float v3;
  unsigned int v4;
  float v5;
  int v6;
  unsigned int v7;
  BOOL v8;
  unint64_t v9;
  float *v10;
  float v11;
  int v12;
  unsigned int v13;
  BOOL v14;
  float v15;
  int v16;
  unsigned int v17;
  BOOL v18;
  float v19;
  unint64_t v20;
  float *v21;
  int v22;
  unint64_t v23;
  float v24;
  BOOL v25;
  BOOL v26;
  int v27;
  unsigned int v28;
  BOOL v29;
  char v30;
  float *v31;
  int v32;
  unsigned int v33;
  BOOL v34;
  char v35;

  v2 = 0;
  v3 = *(float *)a1;
  v4 = *(_DWORD *)(a1 + 4);
  do
  {
    v5 = *(float *)(a1 + v2 + 8);
    if (v5 == v3)
      v6 = 0;
    else
      v6 = -127;
    if (v5 > v3)
      v6 = 1;
    if (v5 < v3)
      v6 = -1;
    if (!v6)
    {
      v7 = *(_DWORD *)(a1 + v2 + 12);
      v8 = v7 == v4;
      LOBYTE(v6) = v7 < v4 ? -1 : 1;
      if (v8)
        LOBYTE(v6) = 0;
    }
    v2 += 8;
  }
  while (v6 != 129 && (v6 & 0x80) != 0);
  v9 = a1 + v2;
  if (v2 == 8)
  {
    while (v9 < (unint64_t)a2)
    {
      v10 = a2 - 2;
      v15 = *(a2 - 2);
      if (v15 == v3)
        v16 = 0;
      else
        v16 = -127;
      if (v15 > v3)
        v16 = 1;
      if (v15 < v3)
        v16 = -1;
      if (!v16)
      {
        v17 = *((_DWORD *)a2 - 1);
        v18 = v17 == v4;
        LOBYTE(v16) = v17 < v4 ? -1 : 1;
        if (v18)
          LOBYTE(v16) = 0;
      }
      a2 -= 2;
      if (v16 != 129)
      {
        a2 = v10;
        if ((v16 & 0x80) != 0)
          goto LABEL_52;
      }
    }
    v10 = a2;
  }
  else
  {
    while (1)
    {
      v10 = a2 - 2;
      v11 = *(a2 - 2);
      if (v11 == v3)
        v12 = 0;
      else
        v12 = -127;
      if (v11 > v3)
        v12 = 1;
      if (v11 < v3)
        v12 = -1;
      if (!v12)
      {
        v13 = *((_DWORD *)a2 - 1);
        v14 = v13 == v4;
        LOBYTE(v12) = v13 < v4 ? -1 : 1;
        if (v14)
          LOBYTE(v12) = 0;
      }
      a2 -= 2;
      if (v12 != 129)
      {
        a2 = v10;
        if ((v12 & 0x80) != 0)
          break;
      }
    }
  }
LABEL_52:
  if (v9 >= (unint64_t)v10)
  {
    v20 = a1 + v2;
  }
  else
  {
    v19 = *v10;
    v20 = a1 + v2;
    v21 = v10;
    do
    {
      *(float *)v20 = v19;
      *v21 = v5;
      v22 = *(_DWORD *)(v20 + 4);
      *(float *)(v20 + 4) = v21[1];
      *((_DWORD *)v21 + 1) = v22;
      v23 = v20;
      do
      {
        v24 = *(float *)(v20 + 8);
        v20 += 8;
        v5 = v24;
        v25 = v24 < v3;
        v26 = v24 <= v3;
        if (v24 == v3)
          v27 = 0;
        else
          v27 = -127;
        if (!v26)
          v27 = 1;
        if (v25)
          v27 = -1;
        if (!v27)
        {
          v28 = *(_DWORD *)(v23 + 12);
          v29 = v28 == v4;
          if (v28 < v4)
            v30 = -1;
          else
            v30 = 1;
          if (v29)
            LOBYTE(v27) = 0;
          else
            LOBYTE(v27) = v30;
        }
        if (v27 == 129)
          break;
        v23 = v20;
      }
      while ((v27 & 0x80) != 0);
      while (1)
      {
        v31 = v21 - 2;
        v19 = *(v21 - 2);
        if (v19 == v3)
          v32 = 0;
        else
          v32 = -127;
        if (v19 > v3)
          v32 = 1;
        if (v19 < v3)
          v32 = -1;
        if (!v32)
        {
          v33 = *((_DWORD *)v21 - 1);
          v34 = v33 == v4;
          if (v33 < v4)
            v35 = -1;
          else
            v35 = 1;
          if (v34)
            LOBYTE(v32) = 0;
          else
            LOBYTE(v32) = v35;
        }
        v21 = v31;
        if (v32 != 129)
        {
          v21 = v31;
          if ((v32 & 0x80) != 0)
            break;
        }
      }
      v21 = v31;
    }
    while (v20 < (unint64_t)v31);
  }
  if (v20 - 8 != a1)
  {
    *(_DWORD *)a1 = *(_DWORD *)(v20 - 8);
    *(_DWORD *)(a1 + 4) = *(_DWORD *)(v20 - 4);
  }
  *(float *)(v20 - 8) = v3;
  *(_DWORD *)(v20 - 4) = v4;
  return v20 - 8;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, uint64_t a3)
{
  uint64_t v6;
  _BOOL8 result;
  int v8;
  int v9;
  float *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  float v14;
  unsigned int v15;
  uint64_t v16;
  float v17;
  float *v18;
  int v19;
  unsigned int v20;
  BOOL v21;
  uint64_t v22;

  v6 = ((char *)a2 - (char *)a1) >> 3;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)(a2 - 2), (uint64_t)a1))
      {
        v8 = *a1;
        *a1 = *(a2 - 2);
        *(a2 - 2) = v8;
        v9 = a1[1];
        a1[1] = *(a2 - 1);
        *(a2 - 1) = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a1 + 6, a2 - 2, a3);
      return 1;
    default:
      v10 = (float *)(a1 + 4);
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a1 + 2, a1 + 4, a3);
      v11 = (uint64_t)(a1 + 6);
      if (a1 + 6 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, v11, (uint64_t)v10))
    {
      v14 = *(float *)v11;
      v15 = *(_DWORD *)(v11 + 4);
      v16 = v12;
      v17 = *v10;
      while (1)
      {
        v18 = (float *)((char *)a1 + v16);
        v18[6] = v17;
        *((_DWORD *)v18 + 7) = *(int *)((char *)a1 + v16 + 20);
        if (v16 == -16)
          break;
        v17 = v18[2];
        if (v14 == v17)
          v19 = 0;
        else
          v19 = -127;
        if (v14 > v17)
          v19 = 1;
        if (v14 < v17)
          v19 = -1;
        if (!v19)
        {
          v20 = *(int *)((char *)a1 + v16 + 12);
          v21 = v15 == v20;
          if (v15 < v20)
            LOBYTE(v19) = -1;
          else
            LOBYTE(v19) = 1;
          if (v21)
            LOBYTE(v19) = 0;
        }
        v16 -= 8;
        if (v19 == 129 || (v19 & 0x80) == 0)
        {
          v22 = (uint64_t)a1 + v16 + 24;
          goto LABEL_26;
        }
      }
      v22 = (uint64_t)a1;
LABEL_26:
      *(float *)v22 = v14;
      *(_DWORD *)(v22 + 4) = v15;
      if (++v13 == 8)
        return v11 + 8 == (_QWORD)a2;
    }
    v10 = (float *)v11;
    v12 += 8;
    v11 += 8;
    if ((int *)v11 == a2)
      return 1;
  }
}

float std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, int *a4, uint64_t a5)
{
  float result;
  int v11;
  int v12;
  int v13;
  int v14;
  int v15;

  std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a2, a3, a5);
  if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a4, (uint64_t)a3))
  {
    v11 = *a3;
    *a3 = *a4;
    *a4 = v11;
    v12 = a3[1];
    a3[1] = a4[1];
    a4[1] = v12;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a3, (uint64_t)a2))
    {
      v13 = *a2;
      *a2 = *a3;
      *a3 = v13;
      v14 = a2[1];
      a2[1] = a3[1];
      a3[1] = v14;
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a5, (uint64_t)a2, (uint64_t)a1))
      {
        result = *(float *)a1;
        *a1 = *a2;
        *(float *)a2 = result;
        v15 = a1[1];
        a1[1] = a2[1];
        a2[1] = v15;
      }
    }
  }
  return result;
}

float std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(int *a1, int *a2, int *a3, int *a4, int *a5, uint64_t a6)
{
  float result;
  int v13;
  int v14;
  int v15;
  int v16;
  int v17;
  int v18;
  int v19;

  std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a2, a3, a4, a6);
  if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a5, (uint64_t)a4))
  {
    v13 = *a4;
    *a4 = *a5;
    *a5 = v13;
    v14 = a4[1];
    a4[1] = a5[1];
    a5[1] = v14;
    if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a4, (uint64_t)a3))
    {
      v15 = *a3;
      *a3 = *a4;
      *a4 = v15;
      v16 = a3[1];
      a3[1] = a4[1];
      a4[1] = v16;
      if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a3, (uint64_t)a2))
      {
        v17 = *a2;
        *a2 = *a3;
        *a3 = v17;
        v18 = a2[1];
        a2[1] = a3[1];
        a3[1] = v18;
        if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a6, (uint64_t)a2, (uint64_t)a1))
        {
          result = *(float *)a1;
          *a1 = *a2;
          *(float *)a2 = result;
          v19 = a1[1];
          a1[1] = a2[1];
          a2[1] = v19;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *,std::pair<float,unsigned int> *>(char *a1, char *a2, char *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int v15;
  int v16;
  uint64_t v17;
  char *v18;
  int v19;
  int v20;
  char *v21;

  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = (a2 - a1) >> 3;
    if (a2 - a1 >= 9)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = (uint64_t)&a1[8 * v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((_BOOL8)a1, a4, v9, v12);
        v12 -= 8;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if (std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a4, (uint64_t)v14, (uint64_t)a1))
        {
          v15 = *(_DWORD *)v14;
          *(_DWORD *)v14 = *(_DWORD *)a1;
          *(_DWORD *)a1 = v15;
          v16 = *((_DWORD *)v14 + 1);
          *((_DWORD *)v14 + 1) = *((_DWORD *)a1 + 1);
          *((_DWORD *)a1 + 1) = v16;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((_BOOL8)a1, a4, v9, (uint64_t)a1);
        }
        v14 += 8;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 9)
    {
      v17 = (unint64_t)v8 >> 3;
      v18 = a2 - 8;
      do
      {
        v19 = *(_DWORD *)a1;
        v20 = *((_DWORD *)a1 + 1);
        v21 = (char *)std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(a1, a4, v17);
        if (v18 == v21)
        {
          *(_DWORD *)v21 = v19;
          *((_DWORD *)v21 + 1) = v20;
        }
        else
        {
          *(_DWORD *)v21 = *(_DWORD *)v18;
          *((_DWORD *)v21 + 1) = *((_DWORD *)v18 + 1);
          *(_DWORD *)v18 = v19;
          *((_DWORD *)v18 + 1) = v20;
          std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>((_BOOL8)a1, (uint64_t)(v21 + 8), a4, (v21 + 8 - a1) >> 3);
        }
        v18 -= 8;
      }
      while (v17-- > 2);
    }
    return v13;
  }
  return a3;
}

BOOL std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(_BOOL8 result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  _BOOL8 v6;
  uint64_t v7;
  uint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  float v14;
  float v15;
  float *v16;
  uint64_t v17;
  int v18;
  unsigned int v19;
  BOOL v20;
  unsigned int v21;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v7 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= (a4 - result) >> 3)
    {
      v10 = (a4 - result) >> 2;
      v11 = v10 + 1;
      v12 = (float *)(result + 8 * (v10 + 1));
      v13 = v10 + 2;
      if (v10 + 2 < a3
        && std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, result + 8 * (v10 + 1), (uint64_t)(v12 + 2)))
      {
        v12 += 2;
        v11 = v13;
      }
      result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, (uint64_t)v12, v5);
      if (!result)
      {
        v14 = *(float *)v5;
        v21 = *(_DWORD *)(v5 + 4);
        v15 = *v12;
        do
        {
          v16 = (float *)v5;
          v5 = (uint64_t)v12;
          *v16 = v15;
          v16[1] = v12[1];
          if (v7 < v11)
            break;
          v17 = (2 * v11) | 1;
          v12 = (float *)(v6 + 8 * v17);
          v11 = 2 * v11 + 2;
          if (v11 >= a3)
          {
            v11 = v17;
          }
          else
          {
            result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, v6 + 8 * v17, (uint64_t)(v12 + 2));
            if (result)
              v12 += 2;
            else
              v11 = v17;
          }
          v15 = *v12;
          if (*v12 == v14)
            v18 = 0;
          else
            v18 = -127;
          if (*v12 > v14)
            v18 = 1;
          if (*v12 < v14)
            v18 = -1;
          if (!v18)
          {
            v19 = *((_DWORD *)v12 + 1);
            v20 = v19 == v21;
            if (v19 < v21)
              LOBYTE(v18) = -1;
            else
              LOBYTE(v18) = 1;
            if (v20)
              LOBYTE(v18) = 0;
          }
        }
        while (v18 == 129 || (v18 & 0x80) == 0);
        *(float *)v5 = v14;
        *(_DWORD *)(v5 + 4) = v21;
      }
    }
  }
  return result;
}

_DWORD *std::__floyd_sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[2 * v6 + 2];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3
      && std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a2, (uint64_t)&a1[2 * v6 + 2], (uint64_t)&a1[2 * v6 + 4]))
    {
      v9 += 2;
      v10 = v11;
    }
    *a1 = *v9;
    a1[1] = v9[1];
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

BOOL std::__sift_up[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,std::pair<float,unsigned int> *>(_BOOL8 result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  _BOOL8 v6;
  unint64_t v7;
  float *v8;
  float *v9;
  float v10;
  unsigned int v11;
  float v12;
  float *v13;
  int v14;
  unsigned int v15;
  BOOL v16;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v6 = result;
    v7 = v4 >> 1;
    v8 = (float *)(result + 8 * (v4 >> 1));
    v9 = (float *)(a2 - 8);
    result = std::__less<void,void>::operator()[abi:nn180100]<std::pair<float,unsigned int>,std::pair<float,unsigned int>>(a3, (uint64_t)v8, a2 - 8);
    if (result)
    {
      v10 = *(float *)(a2 - 8);
      v11 = *(_DWORD *)(a2 - 4);
      v12 = *v8;
      do
      {
        v13 = v9;
        v9 = v8;
        *v13 = v12;
        v13[1] = v8[1];
        if (!v7)
          break;
        v7 = (v7 - 1) >> 1;
        v8 = (float *)(v6 + 8 * v7);
        v12 = *v8;
        if (*v8 == v10)
          v14 = 0;
        else
          v14 = -127;
        if (*v8 > v10)
          v14 = 1;
        if (*v8 < v10)
          v14 = -1;
        if (!v14)
        {
          v15 = *((_DWORD *)v8 + 1);
          v16 = v15 == v11;
          if (v15 < v11)
            LOBYTE(v14) = -1;
          else
            LOBYTE(v14) = 1;
          if (v16)
            LOBYTE(v14) = 0;
        }
      }
      while (v14 != 129 && (v14 & 0x80) != 0);
      *v9 = v10;
      *((_DWORD *)v9 + 1) = v11;
    }
  }
  return result;
}

void *RB::details::realloc_vector<unsigned int,88ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  unint64_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 88 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(88 * a5);
    v9 = v8 / 0x58;
    if (*a4 != (v8 / 0x58))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 88 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(uint64_t result, unsigned int *a2, uint64_t a3, uint64_t a4, char a5)
{
  unsigned int *v8;
  unsigned int *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  char v18;
  BOOL v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v22;
  BOOL v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;
  uint64_t v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;

  v8 = (unsigned int *)result;
LABEL_2:
  v9 = v8;
LABEL_3:
  v10 = 1 - a4;
  while (2)
  {
    v8 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = a2 - v9;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return result;
      case 2uLL:
        v20 = *(a2 - 1);
        v21 = *v9;
        if (v20 < *v9)
        {
          *v9 = v20;
          *(a2 - 1) = v21;
        }
        return result;
      case 3uLL:
        return std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9, v9 + 1, a2 - 1);
      case 4uLL:
        return std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9, v9 + 1, v9 + 2, a2 - 1);
      case 5uLL:
        return std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9, v9 + 1, v9 + 2, v9 + 3, a2 - 1);
      default:
        if (v12 > 95)
        {
          if (v11 == 1)
          {
            if (v9 != a2)
              return (uint64_t)std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,RB::Symbol::Tag *>(v9, a2, a2, a3);
            return result;
          }
          v14 = v13 >> 1;
          v15 = &v9[v13 >> 1];
          if ((unint64_t)v12 < 0x201)
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(&v9[v13 >> 1], v9, a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          else
          {
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9, &v9[v13 >> 1], a2 - 1);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9 + 1, v15 - 1, a2 - 2);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9 + 2, &v9[v14 + 1], a2 - 3);
            std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v15 - 1, v15, &v9[v14 + 1]);
            v16 = *v9;
            *v9 = *v15;
            *v15 = v16;
            if ((a5 & 1) != 0)
              goto LABEL_12;
          }
          if (*(v9 - 1) >= *v9)
          {
            result = (uint64_t)std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(v9, (int *)a2);
            v9 = (unsigned int *)result;
            goto LABEL_17;
          }
LABEL_12:
          v17 = std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(v9, a2);
          if ((v18 & 1) == 0)
            goto LABEL_15;
          v19 = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v9, v17);
          v9 = v17 + 1;
          result = std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(v17 + 1, a2);
          if (!(_DWORD)result)
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_15:
            result = std::__introsort<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,false>(v8, v17, a3, -v11, a5 & 1);
            v9 = v17 + 1;
LABEL_17:
            a5 = 0;
            a4 = -v11;
            goto LABEL_3;
          }
          a4 = -v11;
          a2 = v17;
          if (v19)
            return result;
          goto LABEL_2;
        }
        v22 = v9 + 1;
        v24 = v9 == a2 || v22 == a2;
        if ((a5 & 1) != 0)
        {
          if (!v24)
          {
            v25 = 0;
            v26 = v9;
            do
            {
              v28 = *v26;
              v27 = v26[1];
              v26 = v22;
              if (v27 < v28)
              {
                v29 = v25;
                while (1)
                {
                  *(unsigned int *)((char *)v9 + v29 + 4) = v28;
                  if (!v29)
                    break;
                  v28 = *(unsigned int *)((char *)v9 + v29 - 4);
                  v29 -= 4;
                  if (v27 >= v28)
                  {
                    v30 = (unsigned int *)((char *)v9 + v29 + 4);
                    goto LABEL_42;
                  }
                }
                v30 = v9;
LABEL_42:
                *v30 = v27;
              }
              v22 = v26 + 1;
              v25 += 4;
            }
            while (v26 + 1 != a2);
          }
        }
        else if (!v24)
        {
          do
          {
            v32 = *v8;
            v31 = v8[1];
            v8 = v22;
            if (v31 < v32)
            {
              do
              {
                *v22 = v32;
                v32 = *(v22 - 2);
                --v22;
              }
              while (v31 < v32);
              *v22 = v31;
            }
            v22 = v8 + 1;
          }
          while (v8 + 1 != a2);
        }
        return result;
    }
  }
}

uint64_t std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;

  v3 = *a2;
  v4 = *a1;
  v5 = *a3;
  if (*a2 < *a1)
  {
    if (v5 < v3)
    {
      *a1 = v5;
      *a3 = v4;
      return 1;
    }
    *a1 = v3;
    *a2 = v4;
    if (*a3 >= v4)
      return 1;
    *a2 = *a3;
    *a3 = v4;
    return 2;
  }
  if (v5 < v3)
  {
    *a2 = v5;
    *a3 = v3;
    v6 = *a1;
    if (*a2 >= *a1)
      return 1;
    *a1 = *a2;
    *a2 = v6;
    return 2;
  }
  return 0;
}

unsigned int *std::__partition_with_equals_on_left[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(unsigned int *a1, int *a2)
{
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int *v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v2 = *a1;
  if (*a1 >= *(a2 - 1))
  {
    v5 = (int *)(a1 + 1);
    do
    {
      v3 = (unsigned int *)v5;
      if (v5 >= a2)
        break;
      ++v5;
    }
    while (v2 >= *v3);
  }
  else
  {
    v3 = a1;
    do
    {
      v4 = v3[1];
      ++v3;
    }
    while (v2 >= v4);
  }
  if (v3 < (unsigned int *)a2)
  {
    do
      v6 = *--a2;
    while (v2 < v6);
  }
  if (v3 < (unsigned int *)a2)
  {
    v7 = *v3;
    v8 = *a2;
    do
    {
      *v3 = v8;
      *a2 = v7;
      do
      {
        v9 = v3[1];
        ++v3;
        v7 = v9;
      }
      while (v2 >= v9);
      do
      {
        v10 = *--a2;
        v8 = v10;
      }
      while (v2 < v10);
    }
    while (v3 < (unsigned int *)a2);
  }
  if (v3 - 1 != a1)
    *a1 = *(v3 - 1);
  *(v3 - 1) = v2;
  return v3;
}

unsigned int *std::__partition_with_equals_on_right[abi:nn180100]<std::_ClassicAlgPolicy,RB::Symbol::Tag *,std::__less<void,void> &>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int *v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;

  v2 = 0;
  v3 = *a1;
  do
    v4 = a1[++v2];
  while (v4 < v3);
  v5 = &a1[v2];
  v6 = &a1[v2 - 1];
  if (v2 == 1)
  {
    do
    {
      if (v5 >= a2)
        break;
      v8 = *--a2;
    }
    while (v8 >= v3);
  }
  else
  {
    do
      v7 = *--a2;
    while (v7 >= v3);
  }
  if (v5 < a2)
  {
    v9 = *a2;
    v10 = &a1[v2];
    v11 = a2;
    do
    {
      *v10 = v9;
      *v11 = v4;
      do
      {
        v12 = v10[1];
        ++v10;
        v4 = v12;
      }
      while (v12 < v3);
      do
      {
        v13 = *--v11;
        v9 = v13;
      }
      while (v13 >= v3);
    }
    while (v10 < v11);
    v6 = v10 - 1;
  }
  if (v6 != a1)
    *a1 = *v6;
  *v6 = v3;
  return v6;
}

BOOL std::__insertion_sort_incomplete[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2)
{
  uint64_t v4;
  _BOOL8 result;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int *v9;
  int v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;

  v4 = a2 - a1;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = *(a2 - 1);
      v7 = *a1;
      if (v6 < *a1)
      {
        *a1 = v6;
        *(a2 - 1) = v7;
      }
      return result;
    case 3:
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a2 - 1);
      return 1;
    case 4:
      std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2, a2 - 1);
      return 1;
    case 5:
      std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2, a1 + 3, a2 - 1);
      return 1;
    default:
      v8 = a1 + 2;
      std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a1 + 1, a1 + 2);
      v9 = a1 + 3;
      if (a1 + 3 == a2)
        return 1;
      v10 = 0;
      v11 = 12;
      break;
  }
  while (1)
  {
    v12 = *v9;
    v13 = *v8;
    if (*v9 < *v8)
    {
      v14 = v11;
      while (1)
      {
        *(unsigned int *)((char *)a1 + v14) = v13;
        v15 = v14 - 4;
        if (v14 == 4)
          break;
        v13 = *(unsigned int *)((char *)a1 + v14 - 8);
        v14 -= 4;
        if (v12 >= v13)
        {
          v16 = (unsigned int *)((char *)a1 + v15);
          goto LABEL_12;
        }
      }
      v16 = a1;
LABEL_12:
      *v16 = v12;
      if (++v10 == 8)
        return v9 + 1 == a2;
    }
    v8 = v9;
    v11 += 4;
    if (++v9 == a2)
      return 1;
  }
}

uint64_t std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4)
{
  uint64_t result;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;

  result = std::__sort3[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a2, a3);
  v9 = *a3;
  if (*a4 < *a3)
  {
    *a3 = *a4;
    *a4 = v9;
    v10 = *a2;
    if (*a3 < *a2)
    {
      *a2 = *a3;
      *a3 = v10;
      v11 = *a1;
      if (*a2 < *a1)
      {
        *a1 = *a2;
        *a2 = v11;
      }
    }
  }
  return result;
}

uint64_t std::__sort5[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, unsigned int *a4, unsigned int *a5)
{
  uint64_t result;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  result = std::__sort4[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(a1, a2, a3, a4);
  v11 = *a4;
  if (*a5 < *a4)
  {
    *a4 = *a5;
    *a5 = v11;
    v12 = *a3;
    if (*a4 < *a3)
    {
      *a3 = *a4;
      *a4 = v12;
      v13 = *a2;
      if (*a3 < *a2)
      {
        *a2 = *a3;
        *a3 = v13;
        v14 = *a1;
        if (*a2 < *a1)
        {
          *a1 = *a2;
          *a2 = v14;
        }
      }
    }
  }
  return result;
}

unsigned int *std::__partial_sort_impl[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *,RB::Symbol::Tag *>(unsigned int *a1, unsigned int *a2, unsigned int *a3, uint64_t a4)
{
  unsigned int *v6;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unsigned int *v12;
  unsigned int *v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int *v19;
  unsigned int *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  unint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  unsigned int v28;

  if (a1 != a2)
  {
    v6 = a2;
    v8 = (char *)a2 - (char *)a1;
    v9 = a2 - a1;
    if ((char *)a2 - (char *)a1 >= 5)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[v10];
      do
      {
        std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>((uint64_t)a1, a4, v9, v12--);
        --v11;
      }
      while (v11);
    }
    v13 = v6;
    if (v6 != a3)
    {
      v14 = v6;
      do
      {
        v15 = *v14;
        if (*v14 < *a1)
        {
          *v14 = *a1;
          *a1 = v15;
          std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>((uint64_t)a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 5)
    {
      v16 = (unint64_t)v8 >> 2;
      do
      {
        v17 = 0;
        v18 = *a1;
        v19 = a1;
        do
        {
          v20 = &v19[v17 + 1];
          v21 = (2 * v17) | 1;
          v17 = 2 * v17 + 2;
          if (v17 >= v16)
          {
            v22 = *v20;
            v17 = v21;
          }
          else
          {
            v22 = *v20;
            v23 = v20[1];
            if (*v20 <= v23)
              v22 = v20[1];
            if (*v20 >= v23)
              v17 = v21;
            else
              ++v20;
          }
          *v19 = v22;
          v19 = v20;
        }
        while (v17 <= (uint64_t)((unint64_t)(v16 - 2) >> 1));
        if (v20 == --v6)
        {
          *v20 = v18;
        }
        else
        {
          *v20 = *v6;
          *v6 = v18;
          v24 = (char *)v20 - (char *)a1 + 4;
          if (v24 >= 5)
          {
            v25 = (((unint64_t)v24 >> 2) - 2) >> 1;
            v26 = &a1[v25];
            v27 = *v26;
            v28 = *v20;
            if (*v26 < *v20)
            {
              do
              {
                *v20 = v27;
                v20 = v26;
                if (!v25)
                  break;
                v25 = (v25 - 1) >> 1;
                v26 = &a1[v25];
                v27 = *v26;
              }
              while (*v26 < v28);
              *v20 = v28;
            }
          }
        }
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:nn180100]<std::_ClassicAlgPolicy,std::__less<void,void> &,RB::Symbol::Tag *>(uint64_t result, uint64_t a2, uint64_t a3, unsigned int *a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;

  if (a3 >= 2)
  {
    v4 = (uint64_t)a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= ((uint64_t)a4 - result) >> 2)
    {
      v6 = v4 >> 1;
      v7 = (v4 >> 1) + 1;
      v8 = (unsigned int *)(result + 4 * v7);
      v9 = v6 + 2;
      if (v9 >= a3)
      {
        v10 = *v8;
      }
      else
      {
        v10 = *v8;
        v11 = v8[1];
        if (*v8 <= v11)
          v10 = v8[1];
        if (*v8 < v11)
        {
          ++v8;
          v7 = v9;
        }
      }
      v12 = *a4;
      if (v10 >= *a4)
      {
        do
        {
          *a4 = v10;
          a4 = v8;
          if (v5 < v7)
            break;
          v13 = (2 * v7) | 1;
          v8 = (unsigned int *)(result + 4 * v13);
          v7 = 2 * v7 + 2;
          if (v7 >= a3)
          {
            v10 = *v8;
            v7 = v13;
          }
          else
          {
            v10 = *v8;
            v14 = v8[1];
            if (*v8 <= v14)
              v10 = v8[1];
            if (*v8 >= v14)
              v7 = v13;
            else
              ++v8;
          }
        }
        while (v10 >= v12);
        *a4 = v12;
      }
    }
  }
  return result;
}

uint64_t RB::Refcount<RB::Path::Object,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Table<NSString *,unsigned int>::for_each<RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0>(RB::Symbol::GlyphCache::tag(RB::Symbol::Tag)::$_0)const::{lambda(void const*,void const*,void *)#1}::__invoke(uint64_t result, int a2, uint64_t a3)
{
  if (*(_DWORD *)(a3 + 8) == a2)
    **(_QWORD **)a3 = result;
  return result;
}

uint64_t *std::unique_ptr<RB::Symbol::Glyph::Sublayers>::reset[abi:nn180100](uint64_t *result, uint64_t a2)
{
  uint64_t v2;
  void *v3;
  RB::Symbol::Glyph::Layer *v4;
  unint64_t v5;
  uint64_t v6;

  v2 = *result;
  *result = a2;
  if (v2)
  {
    v3 = *(void **)(v2 + 264);
    if (v3)
      v4 = *(RB::Symbol::Glyph::Layer **)(v2 + 264);
    else
      v4 = (RB::Symbol::Glyph::Layer *)v2;
    if (*(_DWORD *)(v2 + 272))
    {
      v5 = 0;
      do
      {
        RB::Symbol::Glyph::Layer::~Layer(v4);
        ++v5;
        v4 = (RB::Symbol::Glyph::Layer *)(v6 + 88);
      }
      while (v5 < *(unsigned int *)(v2 + 272));
      v3 = *(void **)(v2 + 264);
    }
    if (v3)
      free(v3);
    JUMPOUT(0x20BD16544);
  }
  return result;
}

void std::default_delete<RB::Symbol::Glyph::Shape>::operator()[abi:nn180100](uint64_t a1, uint64_t *a2)
{
  void *v3;

  if (a2)
  {
    v3 = (void *)a2[2];
    if (v3)
      free(v3);
    RBPathRelease(*a2, a2[1]);
    JUMPOUT(0x20BD16544);
  }
}

void *RB::vector<RB::Symbol::Tag,4ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  result = RB::details::realloc_vector<unsigned int,4ul>(*((void **)__dst + 2), __dst, 4u, (_DWORD *)__dst + 7, v3);
  *((_QWORD *)__dst + 2) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,4ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 4 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(4 * a5);
    v9 = v8 >> 2;
    if (*a4 != (v8 >> 2))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 4 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::DisplayList::ClipNode::contains(_QWORD *a1, double a2, double a3)
{
  _QWORD *v5;
  uint64_t result;

  if (!a1)
    return 1;
  v5 = a1;
  do
  {
    result = (*(uint64_t (**)(unint64_t, double, double))(*(_QWORD *)(v5[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                         + 32))(v5[1] & 0xFFFFFFFFFFFFFFFELL, a2, a3);
    if (!(_DWORD)result)
      break;
    v5 = (_QWORD *)*v5;
  }
  while (v5);
  return result;
}

uint64_t RB::DisplayList::ClipNode::elide_append(uint64_t *a1, float32x2_t *a2)
{
  uint64_t v2;
  uint32x2_t v3;
  uint32x2_t v4;

  v2 = *a1;
  if (*a1)
  {
    v3 = (uint32x2_t)vclez_f32(*(float32x2_t *)((*(_QWORD *)(v2 + 8) & 0xFFFFFFFFFFFFFFFELL) + 24));
    if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) != 0)
    {
      return 1;
    }
    else
    {
      v4 = (uint32x2_t)vclez_f32(a2[3]);
      v2 = 0;
      if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) != 0)
        *a1 = 0;
    }
  }
  return v2;
}

void RB::DisplayList::Clip::print(RB::DisplayList::Clip *this, std::string *a2)
{
  if (*((_DWORD *)this + 10))
    RB::SexpString::printf(a2, 0, "(identifier %u)", *((_DWORD *)this + 10));
  if (*((_BYTE *)this + 44) == 1)
    RB::SexpString::print(a2, 0, "inverse");
}

uint64_t RB::DisplayList::LayerClip::LayerClip(uint64_t a1, RB::DisplayList::Layer *this, int a3, float a4)
{
  float32x2_t v5;
  float32x2_t v6;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 44) = a3;
  *(_QWORD *)a1 = &off_24C228A38;
  *(_QWORD *)(a1 + 48) = this;
  *(float *)(a1 + 56) = a4;
  *(_BYTE *)(a1 + 45) = 2;
  if (a3 == 1)
  {
    v6 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    v5 = (float32x2_t)0x100000001000000;
LABEL_7:
    *(float32x2_t *)(a1 + 16) = v5;
    *(float32x2_t *)(a1 + 24) = v6;
    return a1;
  }
  if (!a3)
  {
    if (this)
    {
      v5 = RB::DisplayList::Layer::bounds(this);
    }
    else
    {
      v5 = 0;
      v6 = 0;
    }
    goto LABEL_7;
  }
  return a1;
}

void sub_209B210F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  RB::DisplayList::Layer *v3;

  v3 = *(RB::DisplayList::Layer **)(v1 + 48);
  *(_QWORD *)(v1 + 48) = 0;
  if (v3)
    RB::DisplayList::Layer::~Layer(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::DisplayList::LayerClip::copy(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4)
{
  size_t v8;
  int v9;
  RB::DisplayList::Layer *v10;
  RB::DisplayList::Layer *v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD *v14;
  _QWORD *i;
  float v16;
  uint64_t *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  size_t *v23;
  uint64_t v24;
  int v25;
  RB::DisplayList::Layer *v26;
  float32x2_t v27;
  float32x2_t v28;
  int8x16_t v29;
  uint64_t v30;
  _QWORD *v31;
  __int128 *v33;
  int v34;
  int v35;
  RB::DisplayList::Layer *v36;
  _OWORD v37[2];
  __int128 v38;
  uint64_t v39;
  uint64_t v40;

  v40 = *MEMORY[0x24BDAC8D0];
  v8 = *a2;
  v9 = *(unsigned __int8 *)(*a2 + 272);
  if (*(_BYTE *)(*a2 + 272) && *(float *)(a1 + 56) == 0.0)
    return (_QWORD *)a3;
  v10 = *(RB::DisplayList::Layer **)(a1 + 48);
  if (v10)
  {
    v10 = (RB::DisplayList::Layer *)RB::DisplayList::Layer::copy(v10, (RB::DisplayList::Builder *)*a2, 0);
    v11 = v10;
    v9 = *(unsigned __int8 *)(v8 + 272);
  }
  else
  {
    v11 = 0;
  }
  v36 = v11;
  if ((_DWORD)a4)
    v12 = *(_BYTE *)(a1 + 44) == 0;
  else
    v12 = *(char *)(a1 + 44);
  v35 = v12;
  if (!v9)
  {
LABEL_25:
    v22 = *(_QWORD *)(v8 + 8);
    v23 = (size_t *)(v22 + 16);
    if (!v11)
    {
      if ((_DWORD)v12)
        return (_QWORD *)a3;
      memset(v37, 0, sizeof(v37));
      LODWORD(v38) = 1065353216;
      *(_QWORD *)((char *)&v38 + 4) = 0;
      *(_DWORD *)((char *)&v38 + 11) = 0;
      v34 = 1;
      v33 = RB::AffineTransform::identity(v10);
      v30 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,int,RB::ClipMode &,RB::AffineTransform const*>(v23, v29, (uint64_t)v23, v37, &v34, &v35, (uint64_t *)&v33);
      v31 = (_QWORD *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v31 + 2) > a2[4])
        v31 = (_QWORD *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
      else
        a2[3] = (size_t)(v31 + 2);
      *v31 = a3;
      v31[1] = v30;
      return v31;
    }
    v24 = RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float const&,RB::ClipMode &>((size_t *)(v22 + 16), &v36, (float *)(a1 + 56), &v35);
    *(_QWORD *)(v24 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a2, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
    *(_DWORD *)(v24 + 40) = v25;
    RB::DisplayList::Layer::apply_transform(*(RB::DisplayList::Layer **)(v24 + 48), (const RB::DisplayList::CachedTransform *)a2);
    if (*(_BYTE *)(v8 + 272))
      RB::DisplayList::Layer::discard_color(*(_QWORD *)(v24 + 48));
    if (v35 == 1)
    {
      v28 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
      v27 = (float32x2_t)0x100000001000000;
    }
    else
    {
      if (v35)
      {
LABEL_39:
        v31 = (_QWORD *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
        if ((unint64_t)(v31 + 2) > a2[4])
          v31 = (_QWORD *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
        else
          a2[3] = (size_t)(v31 + 2);
        *v31 = a3;
        v31[1] = v24;
        return v31;
      }
      v26 = *(RB::DisplayList::Layer **)(v24 + 48);
      if (v26)
      {
        v27 = RB::DisplayList::Layer::bounds(v26);
      }
      else
      {
        v27 = 0;
        v28 = 0;
      }
    }
    *(float32x2_t *)(v24 + 16) = v27;
    *(float32x2_t *)(v24 + 24) = v28;
    goto LABEL_39;
  }
  v10 = RB::DisplayList::Builder::simplify_clip_layer((RB::DisplayList::Builder *)v8, v11, v12);
  v36 = v10;
  if (!v13)
  {
    v11 = v10;
    goto LABEL_25;
  }
  v14 = v13;
  for (i = (_QWORD *)v13[3]; i; i = (_QWORD *)*i)
    a3 = (*(uint64_t (**)(unint64_t, size_t *, uint64_t, uint64_t))(*(_QWORD *)(i[1] & 0xFFFFFFFFFFFFFFFELL)
                                                                                 + 24))(i[1] & 0xFFFFFFFFFFFFFFFELL, a2, a3, a4);
  v14[3] = 0;
  (*(void (**)(_QWORD *, size_t *, _QWORD))(*v14 + 32))(v14, a2, 0);
  v38 = 0uLL;
  v39 = 4;
  v16 = *(float *)(a1 + 56);
  v17 = (uint64_t *)v37;
  (*(void (**)(_QWORD *, size_t, uint64_t, _OWORD *, float))(*v14 + 88))(v14, v8, v12, v37, v16);
  v18 = (void *)v38;
  if ((_QWORD)v38)
    v17 = (uint64_t *)v38;
  if (*((_QWORD *)&v38 + 1))
  {
    v19 = 8 * *((_QWORD *)&v38 + 1);
    do
    {
      v20 = *v17;
      v21 = (_QWORD *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
      if ((unint64_t)(v21 + 2) > a2[4])
        v21 = (_QWORD *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
      else
        a2[3] = (size_t)(v21 + 2);
      *v21 = a3;
      v21[1] = v20;
      ++v17;
      a3 = (uint64_t)v21;
      v19 -= 8;
    }
    while (v19);
    v18 = (void *)v38;
    a3 = (uint64_t)v21;
  }
  if (v18)
    free(v18);
  return (_QWORD *)a3;
}

void sub_209B21458(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  if (a17)
    free(a17);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::DisplayList::LayerClip,RB::DisplayList::Layer *&,float const&,RB::ClipMode &>(size_t *a1, RB::DisplayList::Layer **a2, float *a3, int *a4)
{
  uint64_t v7;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 64 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x40uLL, 7);
  else
    a1[2] = v7 + 64;
  return RB::DisplayList::LayerClip::LayerClip(v7, *a2, *a4, *a3);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive&,int,RB::ClipMode &,RB::AffineTransform const*>(size_t *a1, int8x16_t a2, uint64_t a3, _OWORD *a4, int *a5, _DWORD *a6, uint64_t *a7)
{
  uint64_t v11;
  char v12;
  uint64_t v13;
  int8x16_t v14;
  int8x16_t v15;
  int32x4_t v16;

  v11 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v11 + 128 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x80uLL, 15);
  else
    a1[2] = v11 + 128;
  *(float *)a2.i32 = (float)*a5;
  v12 = *a6;
  v13 = *a7;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v12;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224A20;
  *(_QWORD *)(v11 + 48) = v13;
  v14 = *(int8x16_t *)a4;
  v15 = *((int8x16_t *)a4 + 1);
  v16 = *(int32x4_t *)((char *)a4 + 31);
  *(int32x4_t *)(v11 + 95) = v16;
  *(int8x16_t *)(v11 + 64) = v14;
  *(int8x16_t *)(v11 + 80) = v15;
  *(_DWORD *)(v11 + 112) = a2.i32[0];
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v11, a2, *(double *)v14.i64, v15, v16);
  return v11;
}

RB::DisplayList::Layer *RB::DisplayList::LayerClip::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  RB::DisplayList::Layer *result;
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float32x2_t v11[2];

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  if (*(float *)(a1 + 56) == 0.0)
    return (RB::DisplayList::Layer *)1;
  result = *(RB::DisplayList::Layer **)(a1 + 48);
  if (result)
  {
    v11[0] = RB::DisplayList::Layer::bounds(result);
    v11[1] = v6;
    return (RB::DisplayList::Layer *)(RB::Rect::intersects(v11, a2, a3, v7, v8, v9, v10) ^ 1);
  }
  return result;
}

float RB::DisplayList::LayerClip::min_scale(RB::DisplayList::LayerClip *this)
{
  RB::DisplayList::Layer *v1;
  float result;

  v1 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  if (!v1)
    return 0.0;
  RB::DisplayList::Layer::min_scale(v1);
  return result;
}

void RB::DisplayList::LayerClip::print(RB::DisplayList::Layer **this, std::string *a2)
{
  float v4;

  RB::SexpString::push(a2, "clip-layer");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)this, a2);
  v4 = *((float *)this + 14);
  if (v4 != 1.0)
    RB::SexpString::printf(a2, 1, "(alpha %g)", v4);
  RB::DisplayList::Layer::print(this[6], a2);
  RB::SexpString::pop(a2);
}

uint64_t RB::DisplayList::ItemClip::ItemClip(uint64_t a1, RB::DisplayList::Item *this, int a3, float a4)
{
  char v7;
  uint64_t v8;
  int32x2_t v9;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_BYTE *)(a1 + 44) = a3;
  *(_BYTE *)(a1 + 45) = 0;
  *(_QWORD *)a1 = &off_24C2289A0;
  *(_QWORD *)(a1 + 48) = this;
  if (this)
  {
    RB::DisplayList::Item::apply_alpha((uint64_t)this, a4);
    v7 = *(_BYTE *)(a1 + 45) & 0xFE;
  }
  else
  {
    v7 = 0;
  }
  *(_BYTE *)(a1 + 45) = v7;
  if (a3 == 1)
  {
    v9 = vdup_n_s32(0x7F7FFFFFu);
    v8 = 0x100000001000000;
LABEL_10:
    *(_QWORD *)(a1 + 16) = v8;
    *(int32x2_t *)(a1 + 24) = v9;
    return a1;
  }
  if (!a3)
  {
    if (this)
    {
      (*(void (**)(RB::DisplayList::Item *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
    }
    else
    {
      v8 = 0;
      v9 = 0;
    }
    goto LABEL_10;
  }
  return a1;
}

void sub_209B21764(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void (***v3)(_QWORD);

  v3 = *(void (****)(_QWORD))(v1 + 48);
  *(_QWORD *)(v1 + 48) = 0;
  if (v3)
    (**v3)(v3);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::DisplayList::ItemClip::copy(uint64_t a1, size_t *a2, uint64_t a3, int a4)
{
  size_t *v8;
  int v9;
  uint64_t v10;
  int v11;
  _QWORD *result;
  int v13;
  int v14;
  RB::DisplayList::Item *v15;

  v15 = (RB::DisplayList::Item *)(*(uint64_t (**)(_QWORD, size_t, _QWORD))(**(_QWORD **)(a1 + 48) + 24))(*(_QWORD *)(a1 + 48), *a2, 0);
  (*(void (**)(RB::DisplayList::Item *, size_t *, _QWORD))(*(_QWORD *)v15 + 32))(v15, a2, 0);
  v8 = (size_t *)(*(_QWORD *)(*a2 + 8) + 16);
  v9 = *(char *)(a1 + 44);
  if (a4)
    v9 = *(_BYTE *)(a1 + 44) == 0;
  v13 = v9;
  v14 = 1;
  v10 = RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *&,int,RB::ClipMode>(v8, &v15, &v14, &v13);
  *(_QWORD *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata((RB::DisplayList::CachedTransform *)a2, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  result = (_QWORD *)((a2[3] + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > a2[4])
    result = (_QWORD *)RB::Heap::alloc_slow(a2 + 1, 0x10uLL, 7);
  else
    a2[3] = (size_t)(result + 2);
  *result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::ItemClip,RB::DisplayList::Item *&,int,RB::ClipMode>(size_t *a1, RB::DisplayList::Item **a2, int *a3, int *a4)
{
  uint64_t v7;

  v7 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v7 + 56 > a1[3])
    v7 = RB::Heap::alloc_slow(a1, 0x38uLL, 7);
  else
    a1[2] = v7 + 56;
  return RB::DisplayList::ItemClip::ItemClip(v7, *a2, *a4, (float)*a3);
}

uint64_t RB::DisplayList::ItemClip::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v5;
  double v6;
  double v7;
  double v8;
  int32x4_t v9;
  float32x2_t v11[2];

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  v11[0] = COERCE_FLOAT32X2_T((*(double (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 48) + 144))(*(_QWORD *)(a1 + 48), 0));
  v11[1] = v5;
  return RB::Rect::intersects(v11, a2, a3, v6, v7, v8, v9) ^ 1;
}

void RB::DisplayList::ItemClip::print(RB::DisplayList::ItemClip *this, std::string *a2)
{
  RB::SexpString::push(a2, "clip-item");
  RB::DisplayList::Clip::print(this, a2);
  (*(void (**)(_QWORD, std::string *))(**((_QWORD **)this + 6) + 256))(*((_QWORD *)this + 6), a2);
  RB::SexpString::pop(a2);
}

void RB::DisplayList::LayerClip::~LayerClip(RB::DisplayList::LayerClip *this)
{
  RB::DisplayList::Layer *v2;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
}

{
  RB::DisplayList::Layer *v2;

  v2 = (RB::DisplayList::Layer *)*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    RB::DisplayList::Layer::~Layer(v2);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::LayerClip::type_id(RB::DisplayList::LayerClip *this)
{
  return 0;
}

void RB::DisplayList::ItemClip::~ItemClip(RB::DisplayList::ItemClip *this)
{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (**v2)(v2);
}

{
  void (***v2)(_QWORD);

  v2 = (void (***)(_QWORD))*((_QWORD *)this + 6);
  *((_QWORD *)this + 6) = 0;
  if (v2)
    (**v2)(v2);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::ItemClip::type_id(RB::DisplayList::ItemClip *this)
{
  return 1;
}

uint64_t RB::DisplayList::ItemClip::min_scale(RB::DisplayList::ItemClip *this)
{
  return (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 6) + 152))(*((_QWORD *)this + 6));
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::~GenericClip()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::type_id()
{
  return 4098;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::contains@<X0>(uint64_t a1@<X0>, char a2@<W8>, int8x16_t a3@<Q0>, double a4@<D1>, int8x16_t a5@<Q2>, int32x4_t a6@<Q3>)
{
  float32x2_t v7;
  float32x2_t v9;
  double v10;
  double v11;
  double v12;
  int32x4_t v13;
  float32x2_t v14[2];

  v7 = *(float32x2_t *)a3.i8;
  if (*(_BYTE *)(a1 + 44) == 1)
  {
    a3.i32[0] = *(_DWORD *)(a1 + 112);
    if (*(float *)a3.i32 == 0.0)
    {
      a2 = 1;
    }
    else
    {
      v14[0] = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a3, a4, a5, a6);
      v14[1] = v9;
      a2 = RB::Rect::intersects(v14, v7, *(float32x2_t *)&a4, v10, v11, v12, v13) ^ 1;
    }
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    if (*(float *)(a1 + 112) == 1.0)
      return RB::Coverage::Primitive::contains((float32x2_t *)(a1 + 64), *(_QWORD *)(a1 + 48), *(float32x2_t *)a3.i8, *(float32x2_t *)&a4);
    a2 = 0;
  }
  return a2 & 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Primitive>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(_BYTE *)(a1 + 109) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  unsigned int v7;
  _QWORD v9[3];
  int v10;
  uint64_t v11;
  int v12;

  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix)
    return 0;
  v6 = can_mix;
  v9[1] = 0;
  v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  v10 = 0;
  v11 = 1;
  v12 = 0;
  v7 = RB::Coverage::Primitive::can_mix(a1 + 64, (uint64_t)v9, a3 + 64);
  if (v7 >= v6)
    return v6;
  else
    return v7;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Primitive>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  size_t *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  int8x16_t v12;
  uint64_t v13;
  int8x16_t v14;
  double v15;
  int8x16_t v16;
  int32x4_t v17;
  _OWORD *v19;
  int v20;
  float v21;
  _OWORD v22[3];

  v8 = (size_t *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v22[0] = v9;
  v22[1] = v10;
  v22[2] = v11;
  v21 = *(float *)(a1 + 112) + (float)((float)(*(float *)(a3 + 112) - *(float *)(a1 + 112)) * *(float *)(a2 + 16));
  v20 = *(char *)(a1 + 44);
  v19 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v22);
  v13 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v8, v12, (uint64_t)v8, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v21, &v20, (uint64_t *)&v19);
  RB::Coverage::Primitive::mix(v13 + 64, a2, a3 + 64);
  RB::DisplayList::GenericClip<RB::Coverage::Primitive>::update_bounds(v13, v14, v15, v16, v17);
  return v13;
}

float RB::DisplayList::GenericClip<RB::Coverage::Primitive>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 112);
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Primitive>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;
  int v6;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v6 = a1[7].i32[0];
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode(a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::print(uint64_t a1, std::string *this)
{
  float v4;

  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  v4 = *(float *)(a1 + 112);
  if (v4 != 1.0)
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 64));
  RB::SexpString::pop(this);
}

_DWORD *RB::Refcount<RB::XML::Element,unsigned int>::release(_DWORD *result)
{
  int v1;

  v1 = result[2] - 1;
  result[2] = v1;
  if (!v1)
    return (_DWORD *)(*(uint64_t (**)(_DWORD *))(*(_QWORD *)result + 8))(result);
  return result;
}

uint64_t RB::Refcount<RB::XML::Element,unsigned int>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::XML::Element::~Element(RB::XML::Element *this)
{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t i;
  _DWORD *v8;
  int v9;

  *(_QWORD *)this = off_24C229358;
  v2 = (void *)*((_QWORD *)this + 6);
  if (*((_QWORD *)this + 7))
  {
    v3 = 0;
    v4 = (uint64_t)v2 + 8;
    do
    {
      ++v3;
      v4 = std::shared_ptr<RB::XML::Value::Base>::~shared_ptr[abi:nn180100](v4) + 24;
    }
    while (v3 < *((_QWORD *)this + 7));
    v2 = (void *)*((_QWORD *)this + 6);
  }
  if (v2)
    free(v2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    for (i = 0; i < v5; ++i)
    {
      v8 = (_DWORD *)v6[i];
      if (v8)
      {
        v9 = v8[2] - 1;
        v8[2] = v9;
        if (!v9)
        {
          (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
          v5 = *((_QWORD *)this + 4);
        }
      }
    }
    v6 = (_QWORD *)*((_QWORD *)this + 3);
  }
  if (v6)
    free(v6);
}

{
  void *v2;
  unint64_t v3;
  uint64_t v4;
  unint64_t v5;
  _QWORD *v6;
  unint64_t i;
  _DWORD *v8;
  int v9;

  *(_QWORD *)this = off_24C229358;
  v2 = (void *)*((_QWORD *)this + 6);
  if (*((_QWORD *)this + 7))
  {
    v3 = 0;
    v4 = (uint64_t)v2 + 8;
    do
    {
      ++v3;
      v4 = std::shared_ptr<RB::XML::Value::Base>::~shared_ptr[abi:nn180100](v4) + 24;
    }
    while (v3 < *((_QWORD *)this + 7));
    v2 = (void *)*((_QWORD *)this + 6);
  }
  if (v2)
    free(v2);
  v6 = (_QWORD *)*((_QWORD *)this + 3);
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    for (i = 0; i < v5; ++i)
    {
      v8 = (_DWORD *)v6[i];
      if (v8)
      {
        v9 = v8[2] - 1;
        v8[2] = v9;
        if (!v9)
        {
          (*(void (**)(_DWORD *))(*(_QWORD *)v8 + 8))(v8);
          v5 = *((_QWORD *)this + 4);
        }
      }
    }
    v6 = (_QWORD *)*((_QWORD *)this + 3);
  }
  if (v6)
    free(v6);
  JUMPOUT(0x20BD16544);
}

uint64_t std::shared_ptr<RB::XML::Value::Base>::~shared_ptr[abi:nn180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

_QWORD *RB::Encoder::typed_message_field<RB::Coverage::Primitive>(RB::Encoder *a1, uint64_t a2, float32x4_t *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Primitive::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Primitive>(std::string *a1, RB::Coverage::Primitive *a2)
{
  uint64_t v4;
  double v5;
  int8x16_t v6;
  int v7;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Coverage::Primitive::attributes(a2, (RB::XML::Element *)v4, 0.0, v5, v6);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v7 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v7;
  if (!v7)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B221EC(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

const __CFString *contents_debug_description(void *a1)
{
  RB::DisplayList::Contents *v1;
  std::string *v2;
  uint64_t v3;
  std::string __p[2];

  v1 = (RB::DisplayList::Contents *)objc_msgSend(a1, "_rb_contents");
  if (!v1)
    return CFSTR("(display-list)");
  memset(__p, 0, 41);
  RB::DisplayList::Contents::print(v1, __p);
  if ((__p[0].__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v2 = __p;
  else
    v2 = (std::string *)__p[0].__r_.__value_.__r.__words[0];
  v3 = objc_msgSend(MEMORY[0x24BDD17C8], "stringWithUTF8String:", v2);
  if (SHIBYTE(__p[0].__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p[0].__r_.__value_.__l.__data_);
  return (const __CFString *)v3;
}

void sub_209B22320(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  if (a14 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

unint64_t RBDrawingStateSetDefaultColorSpace(uint64_t a1, unsigned int a2)
{
  uint64_t v4;
  unint64_t result;
  uint64_t v6;

  v4 = *(_QWORD *)(a1 + 8);
  result = rb_color_space(a2);
  *(_WORD *)(a1 + 156) = result;
  v6 = *(_QWORD *)(v4 + 304);
  if (v6)
    *(_DWORD *)(v6 + 120) = a2;
  return result;
}

BOOL RBDrawingStateHasLinearColors(uint64_t a1)
{
  unsigned int v1;

  v1 = *(unsigned __int16 *)(a1 + 156);
  return (v1 & 1) == 0 && v1 > 0xFF;
}

void sub_209B224CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

size_t *RBDrawingStateAssign(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _RBDrawingState *v5;
  size_t *result;

  v2 = *(_QWORD *)(a1 + 8);
  if (v2 != *(_QWORD *)(a2 + 8))
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  RB::DisplayList::State::operator=(a1, a2);
  result = *(size_t **)(v2 + 304);
  if (result)
    return RB::XML::DisplayList::copy_state((RB::XML::DisplayList *)result, (RB::XML::Document *)a2, (_RBDrawingState *)a1, v5);
  return result;
}

uint64_t RBDrawingStateClipLayer(uint64_t a1, RB::DisplayList::State *a2, int a3, float a4)
{
  unsigned int *v8;
  RB::DisplayList::Layer *v9;
  _BOOL8 v10;
  uint64_t result;

  v8 = *(unsigned int **)(a1 + 8);
  if (!*((_QWORD *)v8 + 3))
    make_contents(*(unsigned int **)(a1 + 8));
  if (v8 != *((unsigned int **)a2 + 1))
    RB::precondition_failure((RB *)"display list mismatch", (const char *)a2);
  v9 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer((RB::DisplayList::Builder *)(v8 + 4), a2);
  RB::DisplayList::Builder::delete_state(v8 + 4, a2);
  v10 = rb_clip_mode(a3);
  RB::DisplayList::Builder::clip_layer((RB::DisplayList::Builder *)(v8 + 4), v9, (__n128 *)a1, v10, a4);
  result = *((_QWORD *)v8 + 38);
  if (result)
    return RB::XML::DisplayList::clip_layer(result, a3, a4);
  return result;
}

__n128 RB::AffineTransform::inverse(RB::AffineTransform *this)
{
  __int128 v2;
  RB::AffineTransform *v3;
  _OWORD v5[3];

  v2 = *((_OWORD *)this + 1);
  v5[0] = *(_OWORD *)this;
  v5[1] = v2;
  v5[2] = *((_OWORD *)this + 2);
  if (RB::AffineTransform::invert((RB::AffineTransform *)v5))
    v3 = (RB::AffineTransform *)v5;
  else
    v3 = this;
  return *(__n128 *)v3;
}

void RBDrawingStateGetClipBoundingBox(uint64_t a1)
{
  float32x2_t v2;
  float32x2_t v3;
  uint32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  uint32x2_t v7;
  __int128 v8;
  _BOOL4 v9;
  float64x2_t *v10;
  float64x2_t v11;
  __int128 *v12;
  __int128 v13;
  __int128 *v14;
  __int128 v15;
  float32x2_t v16;
  float32x2_t *v17;
  double v18;
  double v19;
  double v20;
  int32x4_t v21;
  uint32x2_t v22;
  float32x2_t v23;
  float32x2_t v24;
  float64x2_t v25;
  __int128 v26;
  __int128 v27;

  v3 = COERCE_FLOAT32X2_T(RB::DisplayList::State::clip_bounds((RB::DisplayList::State *)a1));
  v23 = v3;
  v24 = v2;
  v4 = (uint32x2_t)vclez_f32(v2);
  if ((vpmax_u32(v4, v4).u32[0] & 0x80000000) == 0)
  {
    v5 = v2;
    v6 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    v7 = (uint32x2_t)vcge_f32(vabs_f32(v2), v6);
    if ((vpmax_u32(v7, v7).u32[0] & 0x80000000) == 0)
    {
      v8 = *(_OWORD *)(a1 + 32);
      v25 = *(float64x2_t *)(a1 + 16);
      v26 = v8;
      v27 = *(_OWORD *)(a1 + 48);
      v9 = RB::AffineTransform::invert((RB::AffineTransform *)&v25);
      if (v9)
        v10 = &v25;
      else
        v10 = (float64x2_t *)(a1 + 16);
      v11 = *v10;
      if (v9)
        v12 = &v26;
      else
        v12 = (__int128 *)(a1 + 32);
      v13 = *v12;
      if (v9)
        v14 = &v27;
      else
        v14 = (__int128 *)(a1 + 48);
      v15 = *v14;
      v25 = v11;
      v26 = v13;
      v27 = v15;
      v23 = RB::operator*(&v25, v3, v5);
      v24 = v16;
    }
    v17 = (float32x2_t *)RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)(*(_QWORD *)(a1 + 8) + 16), (RB::DisplayList::State *)a1);
    v22 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&v17[1] & 0x7FFFFFFF7FFFFFFFLL), v6);
    if ((vpmax_u32(v22, v22).u32[0] & 0x80000000) == 0)
      RB::Rect::intersect(&v23, *v17, v17[1], v18, v19, v20, v21);
  }
}

void RBDrawingStateGetDeviceClipBoundingBox(uint64_t a1)
{
  float32x2_t v2;
  uint32x2_t v3;
  float32x2_t *v4;
  uint32x2_t v5;
  float32x2_t v6;
  float32x2_t v7;
  double v8;
  double v9;
  double v10;
  int32x4_t v11;
  float32x2_t v12[2];

  v12[0] = COERCE_FLOAT32X2_T(RB::DisplayList::State::clip_bounds((RB::DisplayList::State *)a1));
  v12[1] = v2;
  v3 = (uint32x2_t)vclez_f32(v2);
  if ((vpmax_u32(v3, v3).u32[0] & 0x80000000) == 0)
  {
    v4 = (float32x2_t *)RB::DisplayList::Builder::crop_bounds((RB::DisplayList::Builder *)(*(_QWORD *)(a1 + 8) + 16), (RB::DisplayList::State *)a1);
    v5 = (uint32x2_t)vcge_f32((float32x2_t)(*(_QWORD *)&v4[1] & 0x7FFFFFFF7FFFFFFFLL), (float32x2_t)vdup_n_s32(0x7F7FFFFFu));
    if ((vpmax_u32(v5, v5).u32[0] & 0x80000000) == 0)
    {
      v6 = RB::operator*((float64x2_t *)(a1 + 16), *v4, v4[1]);
      RB::Rect::intersect(v12, v6, v7, v8, v9, v10, v11);
    }
  }
}

RB::XML::Document *RBDrawingStateScaleCTM(uint64_t a1, float64x2_t a2, double a3)
{
  double v4;
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::Document *result;

  v4 = a2.f64[0];
  v6 = *(_QWORD *)(a1 + 8);
  RB::DisplayList::State::scale((float64x2_t *)a1, a2, a3);
  result = *(RB::XML::Document **)(v6 + 304);
  if (result)
    return RB::XML::DisplayList::scale_ctm(result, (_RBDrawingState *)a1, v7, v4, a3);
  return result;
}

RB::XML::Document *RBDrawingStateRotateCTM(uint64_t a1, double a2)
{
  uint64_t v4;
  float64x2_t v5;
  __double2 v6;
  float64x2_t v7;
  _RBDrawingState *v8;
  RB::XML::Document *result;
  float64x2_t v10[2];
  uint64_t v11;
  uint64_t v12;

  v4 = *(_QWORD *)(a1 + 8);
  v6 = __sincos_stret(a2);
  v5.f64[0] = v6.__cosval;
  v7.f64[0] = -v6.__sinval;
  v7.f64[1] = v6.__cosval;
  v5.f64[1] = v6.__sinval;
  v10[0] = v5;
  v10[1] = v7;
  v11 = 0;
  v12 = 0;
  RB::DisplayList::State::concat((float64x2_t *)a1, v10);
  result = *(RB::XML::Document **)(v4 + 304);
  if (result)
    return RB::XML::DisplayList::rotate_ctm(result, (_RBDrawingState *)a1, v8, a2);
  return result;
}

id RBDrawingStateGetIdentifierNamespace(uint64_t a1)
{
  __int128 v2;
  uint64_t v3;

  v3 = *MEMORY[0x24BDAC8D0];
  v2 = *(_OWORD *)(a1 + 68);
  return (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD1880]), "initWithUUIDBytes:", &v2);
}

RBTransition *RBDrawingStateGetTransition(uint64_t a1)
{
  return RBDrawingStateCopyTransition(a1);
}

RBTransition *RBDrawingStateCopyTransition(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;

  v1 = *(_QWORD *)(a1 + 88);
  if (!v1 || !*(_BYTE *)(v1 + 12))
    return +[RBTransition defaultTransition](RBTransition, "defaultTransition");
  v2 = objc_opt_new();
  -[RBTransition setTransition:](v2, (const char *)v1);
  return (RBTransition *)v2;
}

uint64_t RBDrawingStateSetAttribute(RB::DisplayList::State *this, void *cf, int a3)
{
  _QWORD *v6;
  uint64_t result;
  float v8;

  v6 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v6[3])
  {
    make_contents(*((unsigned int **)this + 1));
    if (a3)
      goto LABEL_3;
LABEL_7:
    objc_msgSend(cf, "floatValue");
    result = RB::DisplayList::State::set_numeric_value((uint64_t)this, v8);
    if (!(_DWORD)result)
      return result;
    goto LABEL_8;
  }
  if (!a3)
    goto LABEL_7;
LABEL_3:
  if (a3 != 1
    || (result = RB::DisplayList::State::set_text_run(this, cf, (RB::DisplayList::Builder *)(v6 + 2)), (result & 1) != 0))
  {
LABEL_8:
    result = v6[38];
    if (result)
      return RB::XML::DisplayList::attribute_value((RB::XML::Document *)result, (_RBDrawingState *)this, a3, cf);
  }
  return result;
}

uint64_t RBDrawingStateGetAttribute(uint64_t result, int a2, double a3)
{
  if (a2 == 1)
    return objc_msgSend(MEMORY[0x24BDD16E0], "numberWithBool:", *(_QWORD *)(result + 160) != 0);
  if (!a2)
  {
    LODWORD(a3) = *(_DWORD *)(result + 152);
    return objc_msgSend(MEMORY[0x24BDD16E0], "numberWithFloat:", a3);
  }
  return result;
}

uint64_t RBDrawingStateDrawDisplayList(uint64_t a1, void *a2, double a3)
{
  LODWORD(a3) = 1.0;
  return objc_msgSend(a2, "_drawInState:alpha:", a1, a3);
}

uint64_t RBDrawingStateDrawDisplayList2(uint64_t a1, void *a2)
{
  return objc_msgSend(a2, "_drawInState:alpha:", a1);
}

RB::DisplayList::Builder *RBDrawingStateDrawMetal(unsigned int **a1, unsigned int a2, int a3, void *a4, float64_t a5, float64_t a6, double a7, float64_t a8, float a9)
{
  unsigned int *v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  RB::DisplayList::Builder *result;
  RB::DisplayList::Builder *v19;
  float32x2_t *v20;
  double v21;
  double v22;
  int32x4_t v23;
  float64x2_t v24;
  float32x2_t v25;
  float64x2_t v26;
  float32x2_t v27;
  __int128 v32;

  v14 = a1[1];
  if (!*((_QWORD *)v14 + 3))
    make_contents(a1[1]);
  v15 = rb_blend_mode(a2);
  v16 = v15;
  v17 = a9 != 0.0 || *((_BYTE *)v14 + 288) == 0;
  if (v17 || (result = (RB::DisplayList::Builder *)RB::may_discard_alpha(v15), (result & 1) == 0))
  {
    v19 = (RB::DisplayList::Builder *)(v14 + 4);
    v20 = (float32x2_t *)RB::DisplayList::Builder::culling_bounds(v19, (RB::DisplayList::State *)a1);
    v24.f64[0] = a5;
    v24.f64[1] = a6;
    v25 = vcvt_f32_f64(v24);
    v26.f64[0] = a7;
    v26.f64[1] = a8;
    v27 = vcvt_f32_f64(v26);
    *(float32x2_t *)&v32 = v25;
    *((float32x2_t *)&v32 + 1) = v27;
    if (!v20)
      return RB::DisplayList::Builder::draw_custom((uint64_t)v19, a4, a3, &v32, (__n128 *)a1, v16, a9);
    result = (RB::DisplayList::Builder *)RB::Rect::intersects(v20, v25, v27, a7, v21, v22, v23);
    if ((_DWORD)result)
      return RB::DisplayList::Builder::draw_custom((uint64_t)v19, a4, a3, &v32, (__n128 *)a1, v16, a9);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddPredicateStyle(RB::DisplayList::State *this, uint64_t a2)
{
  _QWORD *v4;
  char *v5;
  const RB::DisplayList::InvertiblePredicate *v6;
  RB::XML::DisplayList *result;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v4[3])
    make_contents(*((unsigned int **)this + 1));
  if (a2)
    v5 = (char *)(a2 + 8);
  else
    v5 = 0;
  RB::DisplayList::State::add_predicate((__n128 *)this, (RB::DisplayList::Builder *)(v4 + 2), (const RB::DisplayList::Predicate *)v5, v5[40]);
  result = (RB::XML::DisplayList *)v4[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_predicate_style(result, (_RBDrawingState *)this, (_RBDrawingState *)v5, v6);
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAnimationStyle2(uint64_t a1, const RB::Animation *a2, uint64_t a3, uint64_t a4, const UUID *a5)
{
  _QWORD *v8;
  RB::XML::DisplayList *result;
  uuid_t dst;
  unsigned __int8 src[8];
  uint64_t v12;
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  *(_QWORD *)src = a3;
  v12 = a4;
  v8 = *(_QWORD **)(a1 + 8);
  if (!v8[3])
    make_contents(*(unsigned int **)(a1 + 8));
  uuid_copy(dst, src);
  if (a2)
    a2 = (const RB::Animation *)-[RBAnimation rb_animation]((uint64_t)a2);
  RB::DisplayList::State::add_animation((__n128 *)a1, (RB::DisplayList::Builder *)(v8 + 2), a2, (UUID *)dst, (int)a5);
  result = (RB::XML::DisplayList *)v8[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_animation_style(result, (_RBDrawingState *)a1, (_RBDrawingState *)a2, (const RB::Animation *)dst, a5);
  return result;
}

RB::XML::Document *RBDrawingStateAddShadowStyle3(uint64_t a1, unsigned int a2, unsigned int a3, char a4, double a5, float a6, double a7, double a8, float a9, float a10, float a11, float a12)
{
  _QWORD *v22;
  unsigned int v23;
  unsigned int v24;
  float v33;
  float64x2_t v34;
  double v35;
  int v36;
  RB::XML::Document *result;
  uint64_t v40;
  __int16 v41;
  __int128 v42;
  double v43[2];

  _S10 = a12;
  _S11 = a11;
  _S12 = a10;
  _S13 = a9;
  v43[0] = a7;
  v43[1] = a8;
  *(_QWORD *)&v42 = __PAIR64__(LODWORD(a10), LODWORD(a9));
  *((_QWORD *)&v42 + 1) = __PAIR64__(LODWORD(a12), LODWORD(a11));
  v22 = *(_QWORD **)(a1 + 8);
  if (!v22[3])
    make_contents(*(unsigned int **)(a1 + 8));
  LOWORD(v23) = rb_color_space(a2);
  LOBYTE(v24) = BYTE1(v23);
  if (!BYTE1(v23))
  {
    v23 = *(unsigned __int16 *)(a1 + 156);
    v24 = v23 >> 8;
  }
  __asm
  {
    FCVT            H0, S13
    FCVT            H1, S12
    FCVT            H2, S11
    FCVT            H3, S10
  }
  LOWORD(v40) = _H0;
  WORD1(v40) = _H1;
  WORD2(v40) = _H2;
  HIWORD(v40) = _H3;
  v41 = v23 | (v24 << 8);
  v34.f64[0] = a7;
  v34.f64[1] = a8;
  v35 = COERCE_DOUBLE(vcvt_f32_f64(v34));
  v36 = rb_blend_mode(a3);
  v33 = a5;
  RB::DisplayList::State::add_shadow((__n128 *)a1, (RB::DisplayList::Builder *)(v22 + 2), &v40, v36, a4 & 0x1F, v33, a6, v35);
  result = (RB::XML::Document *)v22[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_shadow_style(result, (_RBDrawingState *)a1, v43, &v42, a2, a3, a4, a5, a6);
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddProjectionStyle(RB::DisplayList::State *this, RB::ProjectionMatrix *a2)
{
  _QWORD *v4;
  const float *v5;
  RB::XML::DisplayList *result;

  v4 = (_QWORD *)*((_QWORD *)this + 1);
  if (!v4[3])
    make_contents(*((unsigned int **)this + 1));
  RB::DisplayList::State::add_projection_matrix((__n128 *)this, (RB::DisplayList::Builder *)(v4 + 2), a2);
  result = (RB::XML::DisplayList *)v4[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_projection_style(result, (_RBDrawingState *)this, (_RBDrawingState *)a2, v5);
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation>(__n128 *a1, uint64_t a2, __n128 *a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (result = a3->n128_f64[0], a3->n128_f64[0] != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation>,RB::GeometryStyle::Rotation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddScaleStyle(__n128 *a1, float64x2_t a2, float64_t a3, float64_t a4, float64_t a5)
{
  unint64_t v6;
  float64x2_t v7;
  _RBDrawingState *v8;
  RB::XML::DisplayList *result;
  unint64_t v10;
  double v11;
  double v12;
  double v13;
  float32x2_t v14[2];
  CGSize v15;
  CGPoint v16;

  v6 = a1->n128_u64[1];
  v12 = a4;
  v13 = a5;
  v10 = *(_QWORD *)&a2.f64[0];
  v11 = a3;
  if (!*(_QWORD *)(v6 + 24))
  {
    make_contents((unsigned int *)v6);
    *(_QWORD *)&a2.f64[0] = v10;
    a3 = v11;
    a4 = v12;
    a5 = v13;
  }
  a2.f64[1] = a3;
  v7.f64[0] = a4;
  v7.f64[1] = a5;
  v14[0] = vcvt_f32_f64(a2);
  v14[1] = vcvt_f32_f64(v7);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Scale>(a1, v6 + 16, v14);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
  {
    *(_QWORD *)&v15.width = v10;
    v15.height = v11;
    v16.x = v12;
    v16.y = v13;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_scale_style(result, (_RBDrawingState *)a1, v8, v15, v16);
  }
  return result;
}

uint32x2_t RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Scale>(__n128 *a1, uint64_t a2, float32x2_t *a3)
{
  uint32x2_t v10;
  uint32x2_t result;
  RB::DisplayList::Style *v12;

  if (!*(_BYTE *)(a2 + 272))
    goto LABEL_3;
  __asm { FMOV            V1.2S, #1.0 }
  v10 = (uint32x2_t)vceq_f32(*a3, _D1);
  result = vpmin_u32(v10, v10);
  if ((result.i32[0] & 0x80000000) == 0)
  {
LABEL_3:
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Scale>,RB::GeometryStyle::Scale>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (__n128 *)a3);
    return (uint32x2_t)RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v12).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddTranslationStyle(__n128 *a1, float64x2_t a2, float64_t a3)
{
  unint64_t v4;
  _RBDrawingState *v5;
  RB::XML::DisplayList *result;
  unint64_t v7;
  double v8;
  float32x2_t v9;
  CGSize v10;

  v4 = a1->n128_u64[1];
  v7 = *(_QWORD *)&a2.f64[0];
  v8 = a3;
  if (!*(_QWORD *)(v4 + 24))
  {
    make_contents((unsigned int *)v4);
    *(_QWORD *)&a2.f64[0] = v7;
    a3 = v8;
  }
  a2.f64[1] = a3;
  v9 = vcvt_f32_f64(a2);
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Translation>(a1, v4 + 16, &v9);
  result = *(RB::XML::DisplayList **)(v4 + 304);
  if (result)
  {
    *(_QWORD *)&v10.width = v7;
    v10.height = v8;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_translation_style(result, (_RBDrawingState *)a1, v5, v10);
  }
  return result;
}

uint32x2_t RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Translation>(__n128 *a1, uint64_t a2, float32x2_t *a3)
{
  uint32x2_t v5;
  uint32x2_t result;
  RB::DisplayList::Style *v7;

  if (!*(_BYTE *)(a2 + 272)
    || (v5 = (uint32x2_t)vceqz_f32(*a3), result = vpmin_u32(v5, v5), (result.i32[0] & 0x80000000) == 0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Translation>,RB::GeometryStyle::Translation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), a3);
    return (uint32x2_t)RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddRotation3DStyle(__n128 *a1, double a2, __n128 a3, float a4, float a5, __n128 a6, float a7, float a8, double a9, double a10)
{
  unint64_t v20;
  __n128 v21;
  __n128 v22;
  float v23;
  float v24;
  RB::XML::Document *result;
  __n128 v26;
  float v27;
  float v28;
  __n128 v29;
  float v30;
  float v31;
  double v32[2];
  __n128 v33;
  __n128 v34;
  float v35;
  float v36;
  uint64_t v37;

  v37 = *MEMORY[0x24BDAC8D0];
  v20 = a1->n128_u64[1];
  v30 = a7;
  v31 = a8;
  v28 = a5;
  v29 = a6;
  v26 = a3;
  v27 = a4;
  if (!*(_QWORD *)(v20 + 24))
  {
    make_contents((unsigned int *)v20);
    a3 = v26;
    a4 = v27;
    a5 = v28;
    a6 = v29;
    a7 = v30;
    a8 = v31;
  }
  v21 = a3;
  v21.n128_f32[1] = a4;
  v21.n128_f32[2] = a5;
  v22 = a6;
  v22.n128_f32[1] = a7;
  v22.n128_f32[2] = a8;
  v23 = a9;
  v24 = a10;
  v32[0] = a2;
  v33 = v21;
  v34 = v22;
  v35 = v23;
  v36 = v24;
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation3D>(a1, v20 + 16, v32);
  result = *(RB::XML::Document **)(v20 + 304);
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_rotation3d_style(result, (_RBDrawingState *)a1, a2, v26.n128_f32[0], v27, v28, v29.n128_f32[0], v30, v31, v23, v24);
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Rotation3D>(__n128 *a1, uint64_t a2, double *a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (result = *a3, *a3 != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Rotation3D>,RB::GeometryStyle::Rotation3D>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (uint64_t)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddAffineTransformStyle(uint64_t a1, float64x2_t *a2)
{
  uint64_t v4;
  float64x2_t v5;
  float64x2_t v6;
  const RB::AffineTransform *v7;
  RB::XML::DisplayList *result;
  float64x2_t v9[3];
  _OWORD v10[3];

  v4 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v4 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v5 = a2[1];
  v6 = a2[2];
  v10[0] = *a2;
  v10[1] = v5;
  v10[2] = v6;
  v9[0] = (float64x2_t)v10[0];
  v9[1] = v5;
  v9[2] = v6;
  RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Affine>((__n128 *)a1, v4 + 16, v9);
  result = *(RB::XML::DisplayList **)(v4 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_affine_transform_style(result, (_RBDrawingState *)a1, (_RBDrawingState *)v10, v7);
  return result;
}

double RB::DisplayList::State::add_geometry_style<RB::GeometryStyle::Affine>(__n128 *a1, uint64_t a2, float64x2_t *a3)
{
  int64x2_t v5;
  double result;
  RB::DisplayList::Style *v7;

  if (!*(_BYTE *)(a2 + 272)
    || (v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(a3[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*a3, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(a3[2])), *(_QWORD *)&result = vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0], (*(_QWORD *)&result & 0x8000000000000000) == 0))
  {
    RB::Heap::emplace<RB::DisplayList::GeometryMatrixStyle<RB::GeometryStyle::Affine>,RB::GeometryStyle::Affine>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (uint64_t)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddPathProjectionStyle(uint64_t a1, char *a2, void *a3, uint64_t a4, const RB::AffineTransform *a5, __n128 a6, double a7, double a8, double a9)
{
  uint64_t v15;
  __n128 v16;
  __int128 v17;
  CGPoint v18;
  RB::XML::DisplayList *result;
  __int128 v20;
  CGPoint v21;
  unint64_t v22;
  double v23;
  unint64_t v24;
  double v25;
  double v26;
  double v27;
  float64x2_t v28;
  __int128 v29;
  CGPoint v30;
  RBPath v31;

  if (a6.n128_f64[0] == a8 && a7 == a9)
    RB::precondition_failure((RB *)"invalid zero-length vector: (%f, %f), (%f, %f)", a2, a6.n128_u64[0], *(_QWORD *)&a7, *(_QWORD *)&a8, *(_QWORD *)&a9);
  v15 = *(_QWORD *)(a1 + 8);
  v26 = a8;
  v27 = a9;
  v24 = a6.n128_u64[0];
  v25 = a7;
  if (!*(_QWORD *)(v15 + 24))
  {
    make_contents((unsigned int *)v15);
    a6.n128_u64[0] = v24;
    a7 = v25;
    a8 = v26;
    a9 = v27;
  }
  a6.n128_f64[1] = a7;
  v16.n128_f64[0] = a8;
  v16.n128_f64[1] = a9;
  v17 = *(_OWORD *)(a4 + 16);
  v18 = *(CGPoint *)(a4 + 32);
  v28 = *(float64x2_t *)a4;
  v29 = v17;
  v30 = v18;
  RB::DisplayList::State::add_path_projection(a1, (RB::DisplayList::Builder *)(v15 + 16), (uint64_t)a2, (uint64_t)a3, &v28, (int)a5, a6, v16);
  result = *(RB::XML::DisplayList **)(v15 + 304);
  if (result)
  {
    v20 = *(_OWORD *)(a4 + 16);
    v21 = *(CGPoint *)(a4 + 32);
    v28 = *(float64x2_t *)a4;
    v29 = v20;
    v30 = v21;
    v31.callbacks = (RBPathCallbacks *)&v28;
    v22 = v24;
    *(double *)&v20 = v25;
    v21.x = v26;
    v23 = v27;
    v31.info = a3;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_path_projection_style(result, (_RBDrawingState *)a1, (_RBDrawingState *)a2, *(CGPoint *)((char *)&v20 - 8), v21, v31, a5);
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddBlurFilter(__n128 *a1, _RBDrawingState *a2, double a3, CGFloat a4, CGFloat a5, CGFloat a6, CGFloat a7)
{
  unint64_t v10;
  BOOL IsInfinite;
  const RB::Rect *v12;
  float64x2_t v13;
  float64x2_t v14;
  float v15;
  double v16;
  void (***v17)(_QWORD, double);
  RB::XML::DisplayList *result;
  double v19;
  double v20;
  double v21;
  double v22;
  _DWORD v23[8];
  void (***v24)(_QWORD, double);
  float32x2_t v25;
  float32x2_t v26;
  CGRect v27;
  CGRect v28;
  CGRect v29;

  v10 = a1->n128_u64[1];
  v21 = a6;
  v22 = a7;
  v19 = a4;
  v20 = a5;
  if (!*(_QWORD *)(v10 + 24))
  {
    make_contents((unsigned int *)v10);
    a4 = v19;
    a5 = v20;
    a6 = v21;
    a7 = v22;
  }
  v25 = 0;
  v26 = 0;
  v27.origin.x = a4;
  v27.origin.y = a5;
  v27.size.width = a6;
  v27.size.height = a7;
  IsInfinite = CGRectIsInfinite(v27);
  v12 = 0;
  if (!IsInfinite)
  {
    v28.origin.x = v19;
    v28.origin.y = v20;
    v28.size.width = v21;
    v28.size.height = v22;
    if (CGRectIsNull(v28))
    {
      v12 = 0;
    }
    else
    {
      v13.f64[0] = v19;
      v13.f64[1] = v20;
      v14.f64[0] = v21;
      v14.f64[1] = v22;
      v25 = vcvt_f32_f64(v13);
      v26 = vcvt_f32_f64(v14);
      v12 = (const RB::Rect *)&v25;
    }
  }
  v15 = a3;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v23, v15, 0, v12, (int)a2);
  v16 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(a1, v10 + 16, v23);
  v17 = v24;
  v24 = 0;
  if (v17)
    (**v17)(v17, v16);
  result = *(RB::XML::DisplayList **)(v10 + 304);
  if (result)
  {
    v29.origin.x = v19;
    v29.origin.y = v20;
    v29.size.width = v21;
    v29.size.height = v22;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_blur_filter(result, (_RBDrawingState *)a1, a2, a3, v29);
  }
  return result;
}

void sub_209B23C4C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void (***a22)(_QWORD))
{
  if (a22)
    (**a22)(a22);
  _Unwind_Resume(exception_object);
}

double RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(__n128 *a1, uint64_t a2, _DWORD *a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (LODWORD(result) = *a3, *(float *)a3 > 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::GaussianBlur>,RB::Filter::GaussianBlur>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (uint64_t)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddVariableBlurFilter(uint64_t a1, float16x4_t *a2, RBFill *a3, double a4, CGFloat a5, CGFloat a6, CGFloat a7, CGFloat a8)
{
  uint64_t v12;
  _BOOL8 IsInfinite;
  const RB::Rect *v14;
  float64x2_t v15;
  float64x2_t v16;
  uint64_t v17;
  __int128 *v18;
  __int16 v19;
  double v20;
  int8x16_t v21;
  int32x4_t v22;
  float v23;
  double v24;
  void (***v25)(_QWORD, double);
  RB::XML::DisplayList *result;
  double v27;
  double v28;
  double v29;
  double v30;
  _OWORD v31[2];
  uint64_t v32;
  int v33;
  __int16 v34;
  char v35;
  _QWORD v36[3];
  __int16 v37;
  uint64_t v38;
  uint64_t v39;
  char v40;
  RB::DisplayList::Item *v41;
  float32x2_t v42;
  float32x2_t v43;
  CGRect v44;
  CGRect v45;
  CGRect v46;

  v12 = *(_QWORD *)(a1 + 8);
  v29 = a7;
  v30 = a8;
  v27 = a5;
  v28 = a6;
  if (!*(_QWORD *)(v12 + 24))
  {
    make_contents((unsigned int *)v12);
    a5 = v27;
    a6 = v28;
    a7 = v29;
    a8 = v30;
  }
  v42 = 0;
  v43 = 0;
  v44.origin.x = a5;
  v44.origin.y = a6;
  v44.size.width = a7;
  v44.size.height = a8;
  IsInfinite = CGRectIsInfinite(v44);
  v14 = 0;
  if (!IsInfinite)
  {
    v45.origin.x = v27;
    v45.origin.y = v28;
    v45.size.width = v29;
    v45.size.height = v30;
    IsInfinite = CGRectIsNull(v45);
    if (IsInfinite)
    {
      v14 = 0;
    }
    else
    {
      v15.f64[0] = v27;
      v15.f64[1] = v28;
      v16.f64[0] = v29;
      v16.f64[1] = v30;
      v42 = vcvt_f32_f64(v15);
      v43 = vcvt_f32_f64(v16);
      v14 = (const RB::Rect *)&v42;
    }
  }
  v17 = *(_QWORD *)(v12 + 24) + 16;
  v18 = RB::AffineTransform::identity((RB::AffineTransform *)IsInfinite);
  v19 = *(_WORD *)(a1 + 156);
  v36[0] = v17;
  v36[1] = v18;
  v36[2] = 0x23F800000;
  v37 = v19;
  v38 = -[RBShape shapeData]((uint64_t)a2);
  v39 = RB::DisplayList::Builder::culling_bounds((RB::DisplayList::Builder *)(v12 + 16), (RB::DisplayList::State *)a1);
  v40 = 0;
  v41 = 0;
  memset(v31, 0, sizeof(v31));
  v32 = 1065353216;
  v33 = 0;
  v34 = 1;
  v35 = 0;
  RB::DisplayList::ItemFactory::operator()<RB::Coverage::Primitive>((uint64_t)v36, (float32x2_t *)v31, COERCE_DOUBLE(1065353216), v20, v21, v22);
  v23 = a4;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v31, v23, v41, v14, (int)a3);
  v24 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>((__n128 *)a1, v12 + 16, v31);
  v25 = (void (***)(_QWORD, double))v32;
  v32 = 0;
  if (v25)
    (**v25)(v25, v24);
  result = *(RB::XML::DisplayList **)(v12 + 304);
  if (result)
  {
    v46.origin.x = v27;
    v46.origin.y = v28;
    v46.size.width = v29;
    v46.size.height = v30;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_variable_blur_filter(result, (_RBDrawingState *)a1, a2, a4, a3, v46);
  }
  return result;
}

void sub_209B23EEC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void (***a21)(_QWORD))
{
  if (a21)
    (**a21)(a21);
  _Unwind_Resume(exception_object);
}

RB::XML::DisplayList *RBDrawingStateAddVariableBlurLayer(uint64_t a1, RB::DisplayList::State *a2, _RBDrawingState *a3, float a4, double a5, double a6, CGFloat a7, CGFloat a8, CGFloat a9, CGFloat a10)
{
  uint64_t v20;
  RB::DisplayList::Builder *v21;
  RB::DisplayList::Layer *v22;
  CGRect v24;

  v20 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v20 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v21 = (RB::DisplayList::Builder *)(v20 + 16);
  v22 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer(v21, a2);
  RB::DisplayList::Builder::delete_state((unsigned int *)v21, a2);
  v24.origin.x = a7;
  v24.origin.y = a8;
  v24.size.width = a9;
  v24.size.height = a10;
  return add_variable_blur_layer((__n128 *)a1, v22, a5, a4, a6, v24, a3);
}

RB::XML::DisplayList *add_variable_blur_layer(__n128 *a1, RB::DisplayList::Layer *a2, double a3, float a4, double a5, CGRect a6, _RBDrawingState *a7)
{
  unint64_t v13;
  const RB::Rect *v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  float v19;
  float *layer_item;
  float v21;
  double v22;
  void (***v23)(_QWORD, double);
  RB::XML::DisplayList *result;
  float64_t x;
  float64_t y;
  float64_t width;
  float64_t height;
  _DWORD v29[8];
  void (***v30)(_QWORD, double);
  float64x2_t v31[3];
  float32x2_t v32;
  float32x2_t v33;
  CGRect v34;
  CGRect v35;

  v13 = a1->n128_u64[1];
  width = a6.size.width;
  height = a6.size.height;
  x = a6.origin.x;
  y = a6.origin.y;
  if (!*(_QWORD *)(v13 + 24))
  {
    make_contents((unsigned int *)v13);
    a6.origin.x = x;
    a6.origin.y = y;
    a6.size.width = width;
    a6.size.height = height;
  }
  v32 = 0;
  v33 = 0;
  v14 = 0;
  if (!CGRectIsInfinite(a6))
  {
    v34.origin.x = x;
    v34.origin.y = y;
    v34.size.width = width;
    v34.size.height = height;
    if (CGRectIsNull(v34))
    {
      v14 = 0;
    }
    else
    {
      v15.f64[0] = x;
      v15.f64[1] = y;
      v16.f64[0] = width;
      v16.f64[1] = height;
      v32 = vcvt_f32_f64(v15);
      v33 = vcvt_f32_f64(v16);
      v14 = (const RB::Rect *)&v32;
    }
  }
  v17 = (float64x2_t)a1[2];
  v31[0] = (float64x2_t)a1[1];
  v31[1] = v17;
  v31[2] = (float64x2_t)a1[3];
  RB::AffineTransform::invert((RB::AffineTransform *)v31);
  v18 = 0.125;
  if (a3 != 0.0)
    v18 = a3;
  v19 = v18;
  layer_item = RB::DisplayList::Builder::make_layer_item((RB::DisplayList::Builder *)(v13 + 16), a2, 2, v31, a4, v19);
  v21 = a5;
  RB::Filter::GaussianBlur::GaussianBlur((uint64_t)v29, v21, (RB::DisplayList::Item *)layer_item, v14, (int)a7);
  v22 = RB::DisplayList::State::add_filter_style<RB::Filter::GaussianBlur>(a1, v13 + 16, v29);
  v23 = v30;
  v30 = 0;
  if (v23)
    (**v23)(v23, v22);
  result = *(RB::XML::DisplayList **)(v13 + 304);
  if (result)
  {
    v35.origin.x = x;
    v35.origin.y = y;
    v35.size.width = width;
    v35.size.height = height;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_variable_blur_layer(result, (_RBDrawingState *)a1, a7, a3, a4, a5, v35);
  }
  return result;
}

void sub_209B24180(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void (***a22)(_QWORD))
{
  if (a22)
    (**a22)(a22);
  _Unwind_Resume(exception_object);
}

RB::XML::Document *RBDrawingStateAddAlphaThresholdFilter2(uint64_t a1, unsigned int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  _QWORD *v14;
  unsigned int v15;
  unsigned int v17;
  RB::XML::Document *result;

  _S8 = a8;
  _S9 = a7;
  _S10 = a6;
  _S11 = a5;
  v14 = *(_QWORD **)(a1 + 8);
  if (!v14[3])
    make_contents(*(unsigned int **)(a1 + 8));
  LOWORD(v15) = rb_color_space(a2);
  LOWORD(v17) = BYTE1(v15);
  if (!BYTE1(v15))
  {
    v15 = *(unsigned __int16 *)(a1 + 156);
    v17 = v15 >> 8;
  }
  __asm
  {
    FCVT            H1, S11
    FCVT            H2, S10
    FCVT            H3, S9
    FCVT            H4, S8
  }
  RB::DisplayList::State::add_alpha_threshold((__n128 *)a1, (RB::DisplayList::Builder *)(v14 + 2), ((unint64_t)_H3 << 32) | ((unint64_t)_S4 << 48) | ((unint64_t)_H2 << 16) | _H1, v15 | (unsigned __int16)((_WORD)v17 << 8), COERCE_DOUBLE(__PAIR64__(LODWORD(a4), LODWORD(a3))));
  result = (RB::XML::Document *)v14[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_alpha_threshold_filter(result, (_RBDrawingState *)a1, a2, a3, a4, _S11, _S10, _S9, _S8);
  return result;
}

RB::XML::Document *RBDrawingStateAddAlphaThresholdFilter(uint64_t a1, float a2, float a3, float a4, float a5, float a6, float a7)
{
  return RBDrawingStateAddAlphaThresholdFilter2(a1, 0, a2, a3, a4, a5, a6, a7);
}

void RBDrawingStateAddAlphaGradientFilter2(uint64_t a1, unint64_t a2, uint64_t a3, unsigned int a4, uint64_t a5, int a6)
{
  _QWORD *v12;
  unsigned __int16 v13;
  uint64_t v14;

  v12 = *(_QWORD **)(a1 + 8);
  if (!v12[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v13 = rb_color_space(a4);
  RB::DisplayList::State::add_alpha_gradient((__n128 *)a1, (RB::DisplayList::Builder *)(v12 + 2), a2, a3, v13, a5, a6);
  v14 = v12[38];
  if (v14)
    RB::XML::DisplayList::add_alpha_gradient_filter(v14, a1);
}

void RBDrawingStateAddAlphaGradientFilter(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, int a5)
{
  RBDrawingStateAddAlphaGradientFilter2(a1, a2, a3, 0, a4, a5);
}

RB::XML::DisplayList *RBDrawingStateAddColorMatrixFilter(uint64_t a1, float *a2, RB::XML::Document *a3)
{
  uint64_t v6;
  RB::XML::DisplayList *result;
  float16x4_t v8;
  __int128 v9;
  __int128 v10;
  uint64_t v11;
  _OWORD v12[2];
  uint64_t v13;

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  RB::ColorMatrix::set_color_matrix((float16x4_t *)v12, a2);
  v8.i32[0] = (int)a3;
  v9 = v12[0];
  v10 = v12[1];
  v11 = v13;
  RB::DisplayList::State::add_filter_style<RB::Filter::ColorMatrix>((__n128 *)a1, v6 + 16, &v8);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_color_matrix_filter(result, (_RBDrawingState *)a1, (_RBDrawingState *)a2, a3);
  return result;
}

double RB::DisplayList::State::add_filter_style<RB::Filter::ColorMatrix>(__n128 *a1, uint64_t a2, float16x4_t *a3)
{
  double result;
  RB::DisplayList::Style *v7;

  if (!*(_BYTE *)(a2 + 272) || (RB::ColorMatrix::is_identity(a3 + 1) & 1) == 0)
  {
    RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::ColorMatrix>,RB::Filter::ColorMatrix>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (uint64_t)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMultiplyFilter2(uint64_t a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7)
{
  _QWORD *v14;
  RB::XML::Document *v15;
  unsigned __int16 v16;
  RB::DisplayList::Style *v17;
  RB::XML::Document *result;
  __n128 v19;

  v14 = *(_QWORD **)(a1 + 8);
  if (!v14[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v15 = (RB::XML::Document *)(a3 & 0xFFFFFFFB);
  v19.n128_u32[0] = v15;
  *(unint64_t *)((char *)v19.n128_u64 + 4) = color_filter_color(a2, v15, a1, a4, a5, a6, a7);
  v19.n128_u16[6] = v16;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMultiply>,RB::ColorStyle::ColorMultiply>((RB::Heap *)(v14[3] + 16), &v19);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v14 + 2), v17);
  result = (RB::XML::Document *)v14[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_color_multiply_filter(result, (_RBDrawingState *)a1, a2, v15, a4, a5, a6, a7);
  return result;
}

uint64_t color_filter_color(unsigned int a1, unsigned int a2, uint64_t a3, float a4, float a5, float a6, float a7)
{
  int v13;
  int v15;
  int v16;
  unsigned __int8 v24;
  int v25;
  uint64_t v27;
  __int16 v28;

  _S8 = a7;
  _S9 = a6;
  _S10 = a5;
  _S11 = a4;
  v13 = rb_color_space(a1);
  v15 = BYTE1(v13);
  if (BYTE1(v13))
  {
    v16 = v13;
  }
  else
  {
    v15 = HIBYTE(*(unsigned __int16 *)(a3 + 156));
    v16 = *(unsigned __int16 *)(a3 + 156);
  }
  __asm
  {
    FCVT            H0, S11
    FCVT            H1, S10
    FCVT            H2, S9
    FCVT            H3, S8
  }
  LOWORD(v27) = _D0.i16[0];
  WORD1(v27) = _H1;
  WORD2(v27) = _H2;
  HIWORD(v27) = _H3;
  v28 = v16 | (unsigned __int16)((_WORD)v15 << 8);
  if (v15)
  {
    v24 = v16 & 0xFE;
    v25 = (a2 >> 1) & 1 | v16;
    if ((a2 & 1) == 0)
      v24 = v25;
    RB::Fill::Color::convert((uint64_t)&v27, v24, _D0);
  }
  return v27;
}

RB::XML::Document *RBDrawingStateAddColorMultiplyFilter(uint64_t a1, int a2, float a3, float a4, float a5, float a6)
{
  return RBDrawingStateAddColorMultiplyFilter2(a1, 0, a2, a3, a4, a5, a6);
}

RB::XML::Document *RBDrawingStateAddAlphaMultiplyFilter2(uint64_t a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7)
{
  _QWORD *v14;
  RB::XML::Document *v15;
  unsigned __int16 v16;
  RB::DisplayList::Style *v17;
  RB::XML::Document *result;
  __n128 v19;

  v14 = *(_QWORD **)(a1 + 8);
  if (!v14[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v15 = (RB::XML::Document *)(a3 & 0xFFFFFFFB);
  v19.n128_u32[0] = v15;
  *(unint64_t *)((char *)v19.n128_u64 + 4) = color_filter_color(a2, v15, a1, a4, a5, a6, a7);
  v19.n128_u16[6] = v16;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::AlphaMultiply>,RB::ColorStyle::AlphaMultiply>((RB::Heap *)(v14[3] + 16), &v19);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v14 + 2), v17);
  result = (RB::XML::Document *)v14[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_alpha_multiply_filter(result, (_RBDrawingState *)a1, a2, v15, a4, a5, a6, a7);
  return result;
}

RB::XML::Document *RBDrawingStateAddAlphaMultiplyFilter(uint64_t a1, int a2, float a3, float a4, float a5, float a6)
{
  return RBDrawingStateAddAlphaMultiplyFilter2(a1, 0, a2, a3, a4, a5, a6);
}

RB::XML::DisplayList *RBDrawingStateAddHueRotationFilter(uint64_t a1, int a2, double a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  float v8;
  RB::XML::DisplayList *result;
  _DWORD v10[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v8 = a3;
  v10[0] = (_DWORD)v7;
  *(float *)&v10[1] = v8;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::HueRotation>((__n128 *)a1, v6 + 16, (uint64_t)v10);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_hue_rotation_filter(result, (_RBDrawingState *)a1, v7, a3);
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::HueRotation>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::HueRotation>,RB::ColorStyle::HueRotation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddSaturationFilter(uint64_t a1, int a2, float a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::DisplayList *result;
  _DWORD v9[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = (_DWORD)v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Saturation>((__n128 *)a1, v6 + 16, (uint64_t)v9);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_saturation_filter(result, (_RBDrawingState *)a1, v7, a3);
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Saturation>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  BOOL v4;
  RB::DisplayList::Style *v7;

  LODWORD(result) = *(_DWORD *)(a3 + 4);
  if (*(_BYTE *)(a2 + 272))
    v4 = *(float *)&result == 1.0;
  else
    v4 = 0;
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Saturation>,RB::ColorStyle::Saturation>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddBrightnessFilter(uint64_t a1, int a2, float a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::DisplayList *result;
  _DWORD v9[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = (_DWORD)v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Brightness>((__n128 *)a1, v6 + 16, (uint64_t)v9);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_brightness_filter(result, (_RBDrawingState *)a1, v7, a3);
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Brightness>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Brightness>,RB::ColorStyle::Brightness>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddContrastFilter(uint64_t a1, int a2, float a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::DisplayList *result;
  _DWORD v9[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = (_DWORD)v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::Contrast>((__n128 *)a1, v6 + 16, (uint64_t)v9);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_contrast_filter(result, (_RBDrawingState *)a1, v7, a3);
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::Contrast>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  BOOL v4;
  RB::DisplayList::Style *v7;

  LODWORD(result) = *(_DWORD *)(a3 + 4);
  if (*(_BYTE *)(a2 + 272))
    v4 = *(float *)&result == 1.0;
  else
    v4 = 0;
  if (!v4)
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::Contrast>,RB::ColorStyle::Contrast>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v7).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddLuminanceToAlphaFilter(uint64_t a1, int a2)
{
  _QWORD *v4;
  uint64_t v5;
  _RBDrawingState *v6;
  RB::DisplayList::Style *v7;
  RB::XML::DisplayList *result;
  int v9;

  v4 = *(_QWORD **)(a1 + 8);
  v5 = v4[3];
  if (!v5)
  {
    make_contents(*(unsigned int **)(a1 + 8));
    v5 = v4[3];
  }
  v6 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9 = (int)v6;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::LuminanceToAlpha>,RB::ColorStyle::LuminanceToAlpha>((RB::Heap *)(v5 + 16), &v9);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v4 + 2), v7);
  result = (RB::XML::DisplayList *)v4[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_luminance_to_alpha_filter(result, (_RBDrawingState *)a1, v6);
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddColorInvertFilter(uint64_t a1, int a2, float a3)
{
  uint64_t v6;
  _RBDrawingState *v7;
  RB::XML::DisplayList *result;
  _DWORD v9[2];

  v6 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v6 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v7 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v9[0] = (_DWORD)v7;
  *(float *)&v9[1] = a3;
  RB::DisplayList::State::add_color_style<RB::ColorStyle::ColorInvert>((__n128 *)a1, v6 + 16, (uint64_t)v9);
  result = *(RB::XML::DisplayList **)(v6 + 304);
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_color_invert_filter(result, (_RBDrawingState *)a1, v7, a3);
  return result;
}

double RB::DisplayList::State::add_color_style<RB::ColorStyle::ColorInvert>(__n128 *a1, uint64_t a2, uint64_t a3)
{
  double result;
  RB::DisplayList::Style *v6;

  if (!*(_BYTE *)(a2 + 272) || (LODWORD(result) = *(_DWORD *)(a3 + 4), *(float *)&result != 0.0))
  {
    RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorInvert>,RB::ColorStyle::ColorInvert>((RB::Heap *)(*(_QWORD *)(a2 + 8) + 16), (_QWORD *)a3);
    *(_QWORD *)&result = RB::DisplayList::State::add_style(a1, (RB::DisplayList::Builder *)a2, v6).n128_u64[0];
  }
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddGrayscaleFilter(uint64_t a1, int a2, float a3)
{
  _QWORD *v6;
  uint64_t v7;
  _RBDrawingState *v8;
  RB::DisplayList::Style *v9;
  RB::XML::DisplayList *result;
  __n128 v11;
  float v12;
  int v13;

  v6 = *(_QWORD **)(a1 + 8);
  v7 = v6[3];
  if (!v7)
  {
    make_contents(*(unsigned int **)(a1 + 8));
    v7 = v6[3];
  }
  v8 = (_RBDrawingState *)(a2 & 0xFFFFFFFB);
  v11.n128_u32[0] = v8;
  *(unint64_t *)((char *)v11.n128_u64 + 4) = 0x3C003C003C003C00;
  v11.n128_u16[6] = 0;
  v12 = a3;
  v13 = 0;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(v7 + 16), &v11);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v6 + 2), v9);
  result = (RB::XML::DisplayList *)v6[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_grayscale_filter(result, (_RBDrawingState *)a1, v8, a3);
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMonochromeFilter2(uint64_t a1, unsigned int a2, int a3, float a4, float a5, float a6, float a7, float a8, float a9)
{
  _QWORD *v18;
  RB::XML::Document *v19;
  unsigned __int16 v20;
  RB::DisplayList::Style *v21;
  RB::XML::Document *result;
  __n128 v23;
  float v24;
  float v25;

  v18 = *(_QWORD **)(a1 + 8);
  if (!v18[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v19 = (RB::XML::Document *)(a3 & 0xFFFFFFFB);
  v23.n128_u32[0] = v19;
  *(unint64_t *)((char *)v23.n128_u64 + 4) = color_filter_color(a2, v19, a1, a5, a6, a7, a8);
  v23.n128_u16[6] = v20;
  v24 = a4;
  v25 = a9;
  RB::Heap::emplace<RB::DisplayList::ColorFilterStyle<RB::ColorStyle::ColorMonochrome>,RB::ColorStyle::ColorMonochrome>((RB::Heap *)(v18[3] + 16), &v23);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v18 + 2), v21);
  result = (RB::XML::Document *)v18[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_color_monochrome_filter(result, (_RBDrawingState *)a1, a2, v19, a4, a5, a6, a7, a8, a9);
  return result;
}

RB::XML::Document *RBDrawingStateAddColorMonochromeFilter(uint64_t a1, int a2, float a3, float a4, float a5, float a6, float a7, float a8)
{
  return RBDrawingStateAddColorMonochromeFilter2(a1, 0, a2, a3, a4, a5, a6, a7, a8);
}

RB::XML::Document *RBDrawingStateAddLuminanceCurveFilter2(uint64_t a1, float32x2_t *a2, unsigned int a3, int a4, float a5, float a6, float a7, float a8)
{
  _QWORD *v16;
  RB::XML::Document *v17;
  uint64_t v18;
  __int128 v19;
  __int16 v20;
  RB::DisplayList::Style *v21;
  RB::XML::Document *result;
  _DWORD v23[4];
  __int128 v24;
  uint64_t v25;
  __int16 v26;
  uint64_t v27;

  v27 = *MEMORY[0x24BDAC8D0];
  v16 = *(_QWORD **)(a1 + 8);
  if (!v16[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v17 = (RB::XML::Document *)(a4 & 0xFFFFFFFB);
  v18 = color_filter_color(a3, v17, a1, a5, a6, a7, a8);
  v19 = *(_OWORD *)a2->f32;
  v23[0] = (_DWORD)v17;
  v24 = v19;
  v25 = v18;
  v26 = v20;
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::LuminanceCurve>,RB::Filter::LuminanceCurve>((RB::Heap *)(v16[3] + 16), (uint64_t)v23);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v16 + 2), v21);
  result = (RB::XML::Document *)v16[38];
  if (result)
    return (RB::XML::Document *)RB::XML::DisplayList::add_luminance_curve_filter(result, (_RBDrawingState *)a1, a2, a3, v17, a5, a6, a7, a8);
  return result;
}

RB::XML::Document *RBDrawingStateAddLuminanceCurveFilter(uint64_t a1, float32x2_t *a2, int a3, float a4, float a5, float a6, float a7)
{
  return RBDrawingStateAddLuminanceCurveFilter2(a1, a2, 0, a3, a4, a5, a6, a7);
}

RB::XML::DisplayList *RBDrawingStateAddRGBACurvesFilter(uint64_t a1, _RBDrawingState *a2, RB::XML::Document *a3)
{
  _QWORD *v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  RB::DisplayList::Style *v12;
  RB::XML::DisplayList *result;
  _DWORD v14[4];
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v6 = *(_QWORD **)(a1 + 8);
  v7 = v6[3];
  if (!v7)
  {
    make_contents(*(unsigned int **)(a1 + 8));
    v7 = v6[3];
  }
  v8 = *(_OWORD *)a2;
  v9 = *((_OWORD *)a2 + 1);
  v10 = *((_OWORD *)a2 + 2);
  v11 = *((_OWORD *)a2 + 3);
  v14[0] = (_DWORD)a3;
  v15 = v8;
  v16 = v9;
  v17 = v10;
  v18 = v11;
  RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::RGBACurves>,RB::Filter::RGBACurves>((RB::Heap *)(v7 + 16), (uint64_t)v14);
  RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v6 + 2), v12);
  result = (RB::XML::DisplayList *)v6[38];
  if (result)
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_rgba_curves_filter(result, (_RBDrawingState *)a1, a2, a3);
  return result;
}

RB::XML::DisplayList *RBDrawingStateAddShaderFilter(uint64_t a1, char *a2, float64x2_t *a3, const CGRect *a4, CGFloat a5, CGFloat a6)
{
  _QWORD *v10;
  float32x2_t v11;
  int v12;
  const RB::CustomShader::Closure *v13;
  RB::DisplayList::Style *v14;
  __n128 v15;
  void *v16;
  const void **v17;
  unint64_t i;
  uint64_t v19;
  unsigned int *v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  RB::CustomShader::Closure *v24;
  float64x2_t v25;
  RB::XML::DisplayList *result;
  __int128 v29;
  unsigned int v30;
  uint64_t v31;
  uint64_t v32;
  void *v33;
  unint64_t v34;
  __int128 v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  __int128 v39;
  uint64_t v40;
  CGSize v41;

  v40 = *MEMORY[0x24BDAC8D0];
  v10 = *(_QWORD **)(a1 + 8);
  if (!v10[3])
    make_contents(*(unsigned int **)(a1 + 8));
  v29 = 0uLL;
  if (a3)
  {
    v11 = vcvt_f32_f64(a3[1]);
    *(float32x2_t *)&v29 = vcvt_f32_f64(*a3);
    *((float32x2_t *)&v29 + 1) = v11;
  }
  v12 = a4 & 0xF;
  if ((a4 & 0xF) == 0 || v12 == 2)
  {
    v23 = (a4 >> 2) & 4 | (a4 >> 3) & 0x18 | v12;
    v24 = (RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    v25.f64[0] = a5;
    v25.f64[1] = a6;
    RB::DisplayList::State::add_custom_effect((__n128 *)a1, (RB::DisplayList::Builder *)(v10 + 2), v24, 0, &v29, v23, COERCE_DOUBLE(vcvt_f32_f64(v25)), 0.0);
  }
  else
  {
    if (v12 != 1)
      RB::precondition_failure((RB *)"invalid shader filter type", a2);
    v13 = (const RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    v30 = (a4 >> 1) & 8 | (a4 >> 5) & 1;
    RB::CustomShader::Closure::Closure((RB::CustomShader::Closure *)&v31, v13);
    v35 = xmmword_209BD5290;
    v36 = xmmword_209BD52A0;
    v37 = 0;
    v38 = 0;
    v39 = v29;
    v14 = (RB::DisplayList::Style *)RB::Heap::emplace<RB::DisplayList::FilterStyle<RB::Filter::Custom>,RB::Filter::Custom>((size_t *)(v10[3] + 16), (uint64_t)&v30);
    v15 = RB::DisplayList::State::add_style((__n128 *)a1, (RB::DisplayList::Builder *)(v10 + 2), v14);
    v16 = v33;
    if (v33)
      v17 = (const void **)v33;
    else
      v17 = (const void **)&v32;
    if (v34)
    {
      for (i = 0; i < v34; ++i)
      {
        RB::CustomShader::Value::reset_data(v17);
        v17 += 3;
      }
      v16 = v33;
    }
    if (v16)
      free(v16);
    v19 = v31;
    if (v31)
    {
      v20 = (unsigned int *)(v31 + 8);
      do
      {
        v21 = __ldxr(v20);
        v22 = v21 - 1;
      }
      while (__stlxr(v22, v20));
      if (!v22)
      {
        __dmb(9u);
        (*(void (**)(uint64_t, __n128))(*(_QWORD *)v19 + 8))(v19, v15);
      }
    }
  }
  result = (RB::XML::DisplayList *)v10[38];
  if (result)
  {
    v41.width = a5;
    v41.height = a6;
    return (RB::XML::DisplayList *)RB::XML::DisplayList::add_shader_filter(result, (_RBDrawingState *)a1, (_RBDrawingState *)a2, 0, v41, (const CGSize *)a3, a4);
  }
  return result;
}

void sub_209B2549C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  RB::Filter::Custom::~Custom((RB::Filter::Custom *)va);
  _Unwind_Resume(a1);
}

void RB::Filter::Custom::~Custom(RB::Filter::Custom *this)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  v2 = (const void **)((char *)this + 16);
  v3 = (const void **)*((_QWORD *)this + 14);
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (*((_QWORD *)this + 15))
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < *((_QWORD *)this + 15));
    v3 = (const void **)*((_QWORD *)this + 14);
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)*((_QWORD *)this + 1);
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
}

void RBDrawingStateAddShaderFilterLayer(uint64_t a1, RB::DisplayList::State *a2, _RBDrawingState *a3, const CGSize *a4, const CGRect *a5, CGFloat a6, CGFloat a7, CGFloat a8, CGFloat a9)
{
  uint64_t v18;
  RB::DisplayList::Builder *v19;
  RB::DisplayList::Layer *v20;
  CGSize v21;
  CGSize v22;

  v18 = *(_QWORD *)(a1 + 8);
  if (!*(_QWORD *)(v18 + 24))
    make_contents(*(unsigned int **)(a1 + 8));
  v19 = (RB::DisplayList::Builder *)(v18 + 16);
  v20 = (RB::DisplayList::Layer *)RB::DisplayList::Builder::end_layer(v19, a2);
  RB::DisplayList::Builder::delete_state((unsigned int *)v19, a2);
  v21.width = a6;
  v21.height = a7;
  v22.width = a8;
  v22.height = a9;
  add_shader_filter_layer((_RBDrawingState *)a1, a3, v20, v21, v22, a4, a5);
}

void add_shader_filter_layer(_RBDrawingState *a1, _RBDrawingState *a2, RB::DisplayList::Layer *a3, CGSize a4, CGSize a5, const CGSize *a6, const CGRect *a7)
{
  _QWORD *v12;
  float32x2_t v13;
  RB::CustomShader::Closure *v14;
  float64x2_t v15;
  float64x2_t v16;
  RB::XML::DisplayList *v17;
  CGFloat v18;
  CGFloat v19;
  CGFloat v20;
  CGFloat v21;
  float64_t v22;
  CGFloat width;
  float64_t v24;
  CGFloat height;
  __int128 v26;
  CGSize v27;
  CGSize v28;

  v27 = a5;
  v12 = (_QWORD *)*((_QWORD *)a1 + 1);
  if (!v12[3])
  {
    width = a4.width;
    height = a4.height;
    v19 = a5.width;
    v21 = a5.height;
    make_contents(*((unsigned int **)a1 + 1));
    a5.width = v19;
    a5.height = v21;
    a4.width = width;
    a4.height = height;
  }
  v26 = 0uLL;
  if (a6)
  {
    v13 = vcvt_f32_f64((float64x2_t)a6[1]);
    *(float32x2_t *)&v26 = vcvt_f32_f64(*(float64x2_t *)a6);
    *((float32x2_t *)&v26 + 1) = v13;
  }
  if ((a7 & 0xF) != 0)
  {
    RB::DisplayList::Layer::~Layer(a3);
  }
  else
  {
    v22 = a4.width;
    v24 = a4.height;
    v18 = a5.width;
    v20 = a5.height;
    v14 = (RB::CustomShader::Closure *)-[RBShape shapeData]((uint64_t)a2);
    v15.f64[0] = v22;
    v15.f64[1] = v24;
    v16.f64[0] = v18;
    v16.f64[1] = v20;
    RB::DisplayList::State::add_custom_effect((__n128 *)a1, (RB::DisplayList::Builder *)(v12 + 2), v14, (uint64_t)a3, &v26, (a7 >> 3) & 0x18 | (a7 >> 2) & 4, COERCE_DOUBLE(vcvt_f32_f64(v15)), COERCE_DOUBLE(vcvt_f32_f64(v16)));
    v17 = (RB::XML::DisplayList *)v12[38];
    if (v17)
    {
      v28.width = v22;
      v28.height = v24;
      RB::XML::DisplayList::add_shader_filter(v17, a1, a2, (RBShader *)&v27, v28, a6, a7);
    }
  }
}

id encode_contents(RB::DisplayList::Contents *a1, void *a2, _QWORD *a3)
{
  id v4;
  id v6[2];
  RB::DisplayList::Contents *v7;
  RB::DisplayList::Contents *v8;

  if (a1)
  {
    v6[0] = &unk_24C228DC8;
    v6[1] = a2;
    v7 = a1;
    v8 = a1;
    v4 = RB::ObjcEncoderDelegate::encode_message_f<NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#1},NSData * RB::ObjcEncoderDelegate::encode_message<RB::DisplayList::Contents>(RB::DisplayList::Contents const&)::{lambda(RB::DisplayList::Contents&)#2}>(v6, &v8, &v7);
    if (!a3)
      return v4;
  }
  else
  {
    v4 = 0;
    if (!a3)
      return v4;
  }
  if (!v4 && !*a3)
    *a3 = objc_msgSend(MEMORY[0x24BDD1540], "errorWithDomain:code:userInfo:", CFSTR("RBCodableError"), -1, 0);
  return v4;
}

void sub_209B25914(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

void sub_209B25BB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, ...)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  va_list va;
  va_list va1;

  va_start(va1, a4);
  va_start(va, a4);
  v7 = va_arg(va1, _QWORD);
  MEMORY[0x20BD16544](v4, 0x10A0C4070508A9ALL);
  v6 = v7;
  v7 = 0;
  if (v6)
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)va, v6);
  RB::DisplayList::Builder::~Builder((RB::DisplayList::Builder *)va1);
  _Unwind_Resume(a1);
}

void sub_209B25FD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12)
{
  uint64_t v12;
  uint64_t v14;
  uint64_t v15;
  unsigned int *v16;
  unsigned int v17;
  unsigned int v18;

  MEMORY[0x20BD16544](v12, 0x10A0C4070508A9ALL);
  v14 = a11;
  a11 = 0;
  if (v14)
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a11, v14);
  v15 = a12;
  if (a12)
  {
    v16 = (unsigned int *)(a12 + 8);
    do
    {
      v17 = __ldxr(v16);
      v18 = v17 - 1;
    }
    while (__stlxr(v18, v16));
    if (!v18)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(_QWORD *)v15 + 8))(v15);
    }
  }
  _Unwind_Resume(a1);
}

void sub_209B26318(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_209B269D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10A0C4070508A9ALL);
  _Unwind_Resume(a1);
}

void sub_209B26A9C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD16544](v1, 0x10F1C4040C62C24);
  _Unwind_Resume(a1);
}

void sub_209B26D18(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35)
{
  uint64_t v36;
  uint64_t v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int v40;

  v36 = a10;
  a10 = 0;
  if (v36)
    std::default_delete<RB::XML::Document>::operator()[abi:nn180100]((uint64_t)&a10, v36);
  v37 = a14;
  RB::Decoder::~Decoder((RB::Decoder *)&a15);
  if (v37)
  {
    v38 = (unsigned int *)(v37 + 8);
    do
    {
      v39 = __ldxr(v38);
      v40 = v39 - 1;
    }
    while (__stlxr(v40, v38));
    if (!v40)
    {
      __dmb(9u);
      (*(void (**)(uint64_t))(*(_QWORD *)v37 + 8))(v37);
    }
  }
  _Unwind_Resume(a1);
}

void sub_209B26EF0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_209B2701C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B27078(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B270EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B27154(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209B271B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void *RB::vector<std::pair<RB::cf_ptr<CGContext *>,RB::ContextDelegate *>,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 7) + (*((_DWORD *)__dst + 7) >> 1);
  result = RB::details::realloc_vector<unsigned int,16ul>(*((void **)__dst + 2), __dst, 1u, (_DWORD *)__dst + 7, v3);
  *((_QWORD *)__dst + 2) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,16ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 16 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(16 * a5);
    v9 = v8 >> 4;
    if (*a4 != (v8 >> 4))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 16 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

RB::CustomShader::Closure *RB::CustomShader::Closure::Closure(RB::CustomShader::Closure *this, const RB::CustomShader::Closure *a2)
{
  uint64_t v3;
  unsigned int *v4;
  unsigned int v5;
  unint64_t v6;
  const RB::CustomShader::Value *v7;
  char *v8;
  uint64_t v9;
  uint64_t v10;
  RB::CustomShader::Value *v11;
  unint64_t v12;
  uint64_t v13;

  v3 = *(_QWORD *)a2;
  if (*(_QWORD *)a2)
  {
    v4 = (unsigned int *)(v3 + 8);
    do
      v5 = __ldxr(v4);
    while (__stxr(v5 + 1, v4));
  }
  *(_QWORD *)this = v3;
  *((_QWORD *)this + 13) = 0;
  *((_QWORD *)this + 14) = 0;
  *((_QWORD *)this + 15) = 4;
  v6 = *((_QWORD *)a2 + 14);
  if (*((_QWORD *)a2 + 13))
    v7 = (const RB::CustomShader::Value *)*((_QWORD *)a2 + 13);
  else
    v7 = (const RB::CustomShader::Closure *)((char *)a2 + 8);
  if (v6 >= 5)
  {
    RB::vector<RB::CustomShader::Value,4ul,unsigned long>::reserve_slow((char *)this + 8, *((_QWORD *)a2 + 14));
    v8 = (char *)*((_QWORD *)this + 13);
    v9 = *((_QWORD *)this + 14);
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    if (!v6)
      goto LABEL_14;
  }
  if (!v8)
    v8 = (char *)this + 8;
  v11 = (RB::CustomShader::Value *)&v8[24 * v9];
  v12 = v6;
  do
  {
    v13 = RB::CustomShader::Value::Value(v11, v7);
    v7 = (const RB::CustomShader::Value *)((char *)v7 + 24);
    v11 = (RB::CustomShader::Value *)(v13 + 24);
    --v12;
  }
  while (v12);
  v10 = *((_QWORD *)this + 14);
LABEL_14:
  *((_QWORD *)this + 14) = v10 + v6;
  return this;
}

void sub_209B273E0(_Unwind_Exception *exception_object)
{
  unsigned int **v1;
  const void **v2;
  void **v3;
  unsigned int *v5;
  unint64_t v6;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;

  v5 = v1[13];
  if (v5)
    v2 = (const void **)v1[13];
  if (v1[14])
  {
    v6 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v2);
      ++v6;
      v2 += 3;
    }
    while (v6 < (unint64_t)v1[14]);
    v5 = (unsigned int *)*v3;
  }
  if (v5)
    free(v5);
  v7 = *v1;
  if (*v1)
  {
    v8 = v7 + 2;
    do
    {
      v9 = __ldxr(v8);
      v10 = v9 - 1;
    }
    while (__stlxr(v10, v8));
    if (!v10)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v7 + 8))(v7);
    }
  }
  _Unwind_Resume(exception_object);
}

void *RB::vector<RB::DisplayList::Transform::Term,1ul,unsigned int>::reserve_slow(void *__dst, unsigned int a2)
{
  unsigned int v3;
  void *result;

  if (*((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_DWORD *)__dst + 11) + (*((_DWORD *)__dst + 11) >> 1);
  result = RB::details::realloc_vector<unsigned int,32ul>(*((void **)__dst + 4), __dst, 1u, (_DWORD *)__dst + 11, v3);
  *((_QWORD *)__dst + 4) = result;
  return result;
}

void *RB::details::realloc_vector<unsigned int,32ul>(void *__src, void *__dst, unsigned int a3, _DWORD *a4, unsigned int a5)
{
  void *v7;
  size_t v8;
  size_t v9;
  void *v10;
  const char *v11;
  void *v12;

  v7 = __src;
  if (a5 <= a3)
  {
    if (__src)
    {
      LODWORD(v9) = a3;
      memcpy(__dst, __src, 32 * a5);
      free(v7);
      v12 = 0;
LABEL_8:
      *a4 = v9;
      return v12;
    }
  }
  else
  {
    v8 = malloc_good_size(32 * a5);
    v9 = v8 >> 5;
    if (*a4 != (v8 >> 5))
    {
      v10 = malloc_type_realloc(v7, v8, 0x66ED1BA4uLL);
      if (!v10)
        RB::precondition_failure((RB *)"allocation failure", v11);
      v12 = v10;
      if (!v7)
        memcpy(v10, __dst, 32 * *a4);
      goto LABEL_8;
    }
  }
  return v7;
}

uint64_t RB::Refcount<RB::Transition,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::Transition,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::Transition::~Transition(RB::Transition *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = off_24C224008;
  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
    free(v3);
}

{
  void *v2;
  void *v3;

  *(_QWORD *)this = off_24C224008;
  v2 = (void *)*((_QWORD *)this + 10);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 5);
  if (v3)
    free(v3);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::Refcount<RB::DisplayList::Interpolator::Object,std::atomic<unsigned int>>::release(uint64_t result)
{
  unsigned int *v1;
  unsigned int v2;
  unsigned int v3;

  v1 = (unsigned int *)(result + 8);
  do
  {
    v2 = __ldxr(v1);
    v3 = v2 - 1;
  }
  while (__stlxr(v3, v1));
  if (!v3)
  {
    __dmb(9u);
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 8))(result);
  }
  return result;
}

uint64_t RB::Refcount<RB::DisplayList::Interpolator::Object,std::atomic<unsigned int>>::finalize(uint64_t result)
{
  if (result)
    return (*(uint64_t (**)(uint64_t))(*(_QWORD *)result + 24))(result);
  return result;
}

void RB::DisplayList::Interpolator::Object::~Object(RB::DisplayList::Interpolator::Object *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = off_24C223AF8;
  v2 = (void *)*((_QWORD *)this + 47);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 40);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 16);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 14);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 12);
  if (v6)
    free(v6);
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table((uint64_t)this + 48);
}

{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = off_24C223AF8;
  v2 = (void *)*((_QWORD *)this + 47);
  if (v2)
    free(v2);
  v3 = (void *)*((_QWORD *)this + 40);
  if (v3)
    free(v3);
  v4 = (void *)*((_QWORD *)this + 16);
  if (v4)
    free(v4);
  v5 = (void *)*((_QWORD *)this + 14);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 12);
  if (v6)
    free(v6);
  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table((uint64_t)this + 48);
  JUMPOUT(0x20BD16544);
}

uint64_t std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::__unordered_map_hasher<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,RB::pair_hash<unsigned int,unsigned int>,std::equal_to<std::pair<unsigned int,unsigned int>>,true>,std::__unordered_map_equal<std::pair<unsigned int,unsigned int>,std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>,std::equal_to<std::pair<unsigned int,unsigned int>>,RB::pair_hash<unsigned int,unsigned int>,true>,std::allocator<std::__hash_value_type<std::pair<unsigned int,unsigned int>,std::unique_ptr<RB::DisplayList::Interpolator::Layer>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  uint64_t v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = v2[3];
      v2[3] = 0;
      if (v4)
        std::default_delete<RB::DisplayList::Interpolator::Layer>::operator()[abi:nn180100]((uint64_t)(v2 + 3), v4);
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

void std::default_delete<RB::XML::Document>::operator()[abi:nn180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  _DWORD *v4;
  int v5;

  if (a2)
  {
    RB::UntypedTable::~UntypedTable((RB::UntypedTable *)(a2 + 32));
    v3 = *(void **)(a2 + 8);
    if (v3)
      free(v3);
    v4 = *(_DWORD **)a2;
    if (*(_QWORD *)a2)
    {
      v5 = v4[2] - 1;
      v4[2] = v5;
      if (!v5)
        (*(void (**)(_DWORD *))(*(_QWORD *)v4 + 8))(v4);
    }
    JUMPOUT(0x20BD16544);
  }
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t (**v5[2])(_QWORD, __int128 *);

  if (*(_BYTE *)(a1 + 24))
  {
    v5[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C224580;
    v5[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    RB::Coverage::StrokeablePath::simplify(a2 + 8, a2, v5);
  }
  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(_QWORD *)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_BYTE *)(a1 + 24))
    *(_BYTE *)(result + 45) |= 4u;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Glyphs>(uint64_t a1, RB::Coverage::Glyphs *a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(RB::Heap **)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_BYTE *)(a1 + 24))
    *(_BYTE *)(result + 45) |= 4u;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = *(_QWORD *)(a1 + 32);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(*(size_t **)a1, *(_QWORD *)a1, a2, (int *)(a1 + 8), (_DWORD *)(a1 + 12), (uint64_t *)(a1 + 16));
    *(_QWORD *)(a1 + 32) = result;
  }
  if (*(_BYTE *)(a1 + 24))
    *(_BYTE *)(result + 45) |= 4u;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  else
    a1[2] = v11 + 152;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224988;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  *(_OWORD *)(v11 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(v11 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(v11 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(v11 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(v11 + 136) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11);
  return v11;
}

void sub_209B27A98(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 44) == 1)
  {
    *(_QWORD *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    if (*(float *)(a1 + 144) == 0.0)
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
      *(_QWORD *)(a1 + 24) = v2;
    }
  }
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::~GenericClip(_QWORD *a1)
{
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::~GenericClip(_QWORD *a1)
{
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::type_id()
{
  return 12290;
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  uint64_t (**v7)(_QWORD, __int128 *);
  int v8;
  _OWORD *v9;
  uint64_t v10;
  char v11;
  int v12;
  _QWORD *result;
  uint64_t (**v14[3])(_QWORD, __int128 *);
  int v15;
  _OWORD *v16;
  uint64_t v17;
  _OWORD *v18;
  int v19;

  v7 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(*(_QWORD *)this + 8) + 16);
  if (a4)
    v8 = *(_BYTE *)(a1 + 44) == 0;
  else
    v8 = *(char *)(a1 + 44);
  v19 = v8;
  v9 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  v18 = v9;
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
  {
    v11 = *(_BYTE *)(a1 + 45) & 4;
  }
  else if (*(_BYTE *)(*(_QWORD *)this + 272))
  {
    v14[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C228838;
    v14[1] = v7;
    v14[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v15 = v8;
    v16 = v9;
    v17 = 0;
    RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v14);
    v10 = v17;
    v11 = 4;
    if (v17)
      goto LABEL_11;
  }
  else
  {
    v11 = 0;
  }
  v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>((size_t *)v7, (uint64_t)v7, a1 + 56, (int *)(a1 + 144), &v19, (uint64_t *)&v18);
LABEL_11:
  *(_QWORD *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v12;
  *(_BYTE *)(v10 + 45) |= v11;
  result = (_QWORD *)((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((_QWORD *)this + 4))
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  else
    *((_QWORD *)this + 3) = result + 2;
  *result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float32x2_t v11[2];

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  if (*(float *)(a1 + 144) == 0.0)
    return 1;
  v11[0] = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  v11[1] = v6;
  return RB::Rect::intersects(v11, a2, a3, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 132) == 1)
    return 1.0;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, int a5)
{
  float64x2_t *v5;
  int64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float v9;
  float64x2_t v10[3];
  int v11;
  __int16 v12;
  int v13;
  char v14;
  int v15;
  int v16;
  uint64_t v17;
  uint64_t v18;

  v5 = *(float64x2_t **)(a1 + 48);
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  v7 = v5[1];
  v8 = vaddq_f64(v5[2], vcvtq_f64_s64(v6));
  v10[0] = *v5;
  v10[1] = v7;
  v10[2] = v8;
  v9 = *(float *)(a1 + 144);
  v11 = *(unsigned __int8 *)(a1 + 128);
  v12 = *(_WORD *)(a1 + 129);
  v13 = *(unsigned __int8 *)(a1 + 131);
  v14 = *(_BYTE *)(a1 + 132);
  v15 = *(_DWORD *)(a1 + 136);
  v16 = 1065353216;
  v17 = 1;
  v18 = 0;
  if (v11 == 1)
    abort();
  RB::render_stroke_coverage(a4, v10, (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56), (uint64_t)&v11, a5, v9);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 can_mix;
  const RB::AffineTransform *v6;
  unsigned __int8 v7;
  uint64_t result;

  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix)
    return 0;
  v7 = can_mix;
  if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a3 + 128)
    && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a3 + 129)
    && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a3 + 130)
    && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a3 + 131)
    && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a3 + 132)
    && *(float *)(a1 + 136) == *(float *)(a3 + 136))
  {
    LOBYTE(result) = RB::Coverage::StrokeablePath::can_mix(a1 + 64, a3 + 64, v6);
  }
  else
  {
    LOBYTE(result) = 0;
  }
  if (result >= v7)
    return v7;
  else
    return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  size_t *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  CGFloat v13;
  _OWORD *v15;
  int v16;
  float v17;
  _OWORD v18[3];

  v8 = (size_t *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v18[0] = v9;
  v18[1] = v10;
  v18[2] = v11;
  v17 = *(float *)(a1 + 144) + (float)((float)(*(float *)(a3 + 144) - *(float *)(a1 + 144)) * *(float *)(a2 + 16));
  v16 = *(char *)(a1 + 44);
  v15 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v18);
  v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, (uint64_t)v8, a1 + 56, (int *)&v17, &v16, (uint64_t *)&v15);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v12 + 64, (RB *)v8, a3 + 64, *(_QWORD *)(a1 + 48), *(_QWORD *)(a3 + 48), (uint64_t)v18, v13);
  *(float *)(v12 + 136) = *(float *)(v12 + 136)
                        + (float)((float)(*(float *)(a3 + 136) - *(float *)(v12 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v12 + 112) = 0x100000001000000;
  *(int32x2_t *)(v12 + 120) = vdup_n_s32(0x7F7FFFFFu);
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v12);
  return v12;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::clip(uint64_t a1, CGContextRef *a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v8;
  CGAffineTransform transform;

  memset(&v8, 0, sizeof(v8));
  v4 = *(float64x2_t **)(a1 + 48);
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, (uint64_t)a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    v6 = *a2;
    v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tx = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, (uint64_t)a2);
    transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::fill(uint64_t a1, CGContextRef *a2, __int16 *a3)
{
  float64x2_t *v6;
  int64x2_t v7;
  CGContext *v8;
  float64x2_t v9;
  CGAffineTransform v10;
  CGAffineTransform transform;

  memset(&v10, 0, sizeof(v10));
  v6 = *(float64x2_t **)(a1 + 48);
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v6[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, (uint64_t)a2, a3);
  }
  else
  {
    CGContextGetCTM(&v10, *a2);
    v8 = *a2;
    v9 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v9;
    *(float64x2_t *)&transform.tx = v6[2];
    CGContextConcatCTM(v8, &transform);
    RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, (uint64_t)a2, a3);
    transform = v10;
    CGContextSetCTM();
  }
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 144);
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;
  int v6;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, a1 + 56);
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v6 = *(int *)(a1 + 144);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((_QWORD *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::print(uint64_t a1, std::string *this)
{
  float v4;

  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  v4 = *(float *)(a1 + 144);
  if (v4 != 1.0)
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, a1 + 56);
  RB::SexpString::pop(this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  else
    a1[2] = v11 + 152;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224988;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  *(_OWORD *)(v11 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(v11 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(v11 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(v11 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(v11 + 136) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11);
  return v11;
}

void sub_209B28464(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), a3, *(_QWORD *)(a1 + 8), a2, (unsigned __int32 *)(*(_QWORD *)(a1 + 16) + 144), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), *(_QWORD *)(a1 + 8), a2, (int *)(*(_QWORD *)(a1 + 16) + 144), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::clip(float32x2_t *a1, CGContext **a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v8;
  CGAffineTransform transform;

  memset(&v8, 0, sizeof(v8));
  v4 = (float64x2_t *)a1[6];
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Primitive::clip(a1 + 8, a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    v6 = *a2;
    v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tx = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Primitive::clip(a1 + 8, a2);
    transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Primitive>::fill(float32x2_t *a1, RB::CGContext *a2, RB::Fill::Color *a3)
{
  float64x2_t *v6;
  int64x2_t v7;
  double v8;
  CGContext *v9;
  float64x2_t v10;
  double v11;
  CGAffineTransform v12;
  CGAffineTransform transform;

  memset(&v12, 0, sizeof(v12));
  v6 = (float64x2_t *)a1[6];
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v6[2]));
  *(_QWORD *)&v8 = vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0];
  if ((*(_QWORD *)&v8 & 0x8000000000000000) != 0)
  {
    RB::Coverage::Primitive::fill(a1 + 8, a2, a3, v8);
  }
  else
  {
    CGContextGetCTM(&v12, *(CGContextRef *)a2);
    v9 = *(CGContext **)a2;
    v10 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v10;
    *(float64x2_t *)&transform.tx = v6[2];
    CGContextConcatCTM(v9, &transform);
    RB::Coverage::Primitive::fill(a1 + 8, a2, a3, v11);
    transform = v12;
    CGContextSetCTM();
  }
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  else
    a1[2] = v11 + 152;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224988;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  *(_OWORD *)(v11 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(v11 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(v11 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(v11 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(v11 + 136) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11);
  return v11;
}

void sub_209B287BC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(RB::ProtobufEncoder *a1, uint64_t a2, uint64_t a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::StrokeablePath::encode(a3 + 8, a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(std::string *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Coverage::StrokeablePath::attributes(a2 + 8, a2, (_QWORD *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B288EC(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Path>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(**(size_t ***)(a1 + 8), a3, **(_QWORD **)(a1 + 8), a2, (unsigned __int32 *)(*(_QWORD *)(a1 + 8) + 8), (_DWORD *)(*(_QWORD *)(a1 + 8) + 12), (uint64_t *)(*(_QWORD *)(a1 + 8) + 16));
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Path>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(**(size_t ***)(a1 + 8), **(_QWORD **)(a1 + 8), a2, (int *)(*(_QWORD *)(a1 + 8) + 8), (_DWORD *)(*(_QWORD *)(a1 + 8) + 12), (uint64_t *)(*(_QWORD *)(a1 + 8) + 16));
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) = result;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::~GenericClip(uint64_t a1)
{
  RBPathRelease(*(_QWORD *)(a1 + 56), *(_QWORD *)(a1 + 64));
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::type_id()
{
  return 8194;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float32x2_t v11[2];
  RBPath v12;

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  if (*(float *)(a1 + 88) == 0.0)
    return 1;
  v12.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v12.info = (void *)(a1 + 56);
  v11[0] = COERCE_FLOAT32X2_T(RB::Coverage::Path::bounds(v12));
  v11[1] = v6;
  return RB::Rect::intersects(v11, a2, a3, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Path>::min_scale(uint64_t a1)
{
  return RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  unsigned int v7;
  _QWORD v9[3];
  int v10;
  uint64_t v11;
  int v12;

  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix)
    return 0;
  v6 = can_mix;
  v9[1] = 0;
  v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  v10 = 0;
  v11 = 1;
  v12 = 0;
  v7 = RB::Coverage::Path::can_mix((float64x2_t **)(a1 + 56), (const RB::DisplayList::Interpolator::Op *)v9, (float64x2_t **)(a3 + 56));
  if (v7 >= v6)
    return v6;
  else
    return v7;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Path>::mix(uint64_t a1, float *a2, uint64_t a3, float64x2_t *a4)
{
  size_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  uint64_t v12;
  _OWORD *v14;
  int v15;
  float v16;
  float64x2_t v17[3];

  v8 = (size_t *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, a2[4]);
  v17[0] = v9;
  v17[1] = v10;
  v17[2] = v11;
  v16 = *(float *)(a1 + 88) + (float)((float)(*(float *)(a3 + 88) - *(float *)(a1 + 88)) * a2[4]);
  v15 = *(char *)(a1 + 44);
  v14 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, v8, a1 + 56, (int *)&v16, &v15, (uint64_t *)&v14);
  RB::Coverage::Path::mix((RBPath *)(v12 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), *(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), v17, (RB::Heap *)v8);
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v12);
  return v12;
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::clip(uint64_t a1, CGContextRef *a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v8;
  CGAffineTransform transform;

  memset(&v8, 0, sizeof(v8));
  v4 = *(float64x2_t **)(a1 + 48);
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), a2);
  }
  else
  {
    CGContextGetCTM(&v8, *a2);
    v6 = *a2;
    v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tx = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), a2);
    transform = v8;
    CGContextSetCTM();
  }
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Path>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;
  int v6;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v6 = *(int *)(a1 + 88);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((_QWORD *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Path>::print(uint64_t a1, std::string *this)
{
  float v4;

  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  v4 = *(float *)(a1 + 88);
  if (v4 != 1.0)
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 56));
  RB::SexpString::pop(this);
}

uint64_t RB::DisplayList::GenericClipCopyVisitor<RB::Coverage::Path>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(*(size_t **)(a1 + 8), *(_QWORD *)(a1 + 8), a2, (int *)(*(_QWORD *)(a1 + 16) + 88), (_DWORD *)(a1 + 24), (uint64_t *)(a1 + 32));
  *(_QWORD *)(a1 + 40) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, size_t *a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v11 + 96;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C2247C0;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(v11 + 64) = v15;
  v16 = *(__int128 **)(a3 + 16);
  if (v16)
  {
    v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3])
      v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v17 + 3);
    v18 = *v16;
    v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *v17 = v18;
  }
  else
  {
    v17 = 0;
  }
  *(_QWORD *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_209B28FB4(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

_QWORD *RB::Encoder::typed_message_field<RB::Coverage::Path>(RB::Encoder *a1, uint64_t a2, RBPath *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Path::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Path>(std::string *a1, RB::Coverage::Path *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Coverage::Path::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B290DC(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, _OWORD *a2, int8x16_t a3)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(**(size_t ***)(a1 + 8), a3, **(_QWORD **)(a1 + 8), a2, (unsigned __int32 *)(*(_QWORD *)(a1 + 8) + 8), (_DWORD *)(*(_QWORD *)(a1 + 8) + 12), (uint64_t *)(*(_QWORD *)(a1 + 8) + 16));
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::DisplayList::ClipFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::visit(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(**(size_t ***)(a1 + 8), **(_QWORD **)(a1 + 8), a2, (int *)(*(_QWORD *)(a1 + 8) + 8), (_DWORD *)(*(_QWORD *)(a1 + 8) + 12), (uint64_t *)(*(_QWORD *)(a1 + 8) + 16));
  *(_QWORD *)(*(_QWORD *)(a1 + 8) + 32) = result;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 120 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x78uLL, 7);
  else
    a1[2] = v11 + 120;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224858;
  *(_QWORD *)(v11 + 48) = v14;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v11 + 56), a3, a2);
  *(_DWORD *)(v11 + 112) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds(v11);
  return v11;
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 44) == 1)
  {
    *(_QWORD *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    if (*(float *)(a1 + 112) == 0.0)
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
    else
    {
      *(double *)(a1 + 16) = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
      *(_QWORD *)(a1 + 24) = v2;
    }
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::~GenericClip()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::type_id()
{
  return 20482;
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  size_t *v7;
  int v8;
  char v9;
  uint64_t v10;
  int v11;
  _QWORD *result;
  _OWORD *v13;
  int v14;

  v7 = (size_t *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16);
  v8 = *(char *)(a1 + 44);
  if (a4)
    v8 = *(_BYTE *)(a1 + 44) == 0;
  v14 = v8;
  v13 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
    v9 = *(_BYTE *)(a1 + 45) & 4;
  else
    v9 = 4 * *(_BYTE *)(*(_QWORD *)this + 272);
  v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v7, (RB::Heap *)v7, (RB::Coverage::Glyphs *)(a1 + 56), (int *)(a1 + 112), &v14, (uint64_t *)&v13);
  *(_QWORD *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  *(_BYTE *)(v10 + 45) |= v9;
  result = (_QWORD *)((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((_QWORD *)this + 4))
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  else
    *((_QWORD *)this + 3) = result + 2;
  *result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float32x2_t v11[2];

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  if (*(float *)(a1 + 112) == 0.0)
    return 1;
  v11[0] = COERCE_FLOAT32X2_T(RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0));
  v11[1] = v6;
  return RB::Rect::intersects(v11, a2, a3, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::min_scale()
{
  return 0.0;
}

__n128 RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, int a5)
{
  float64x2_t *v5;
  int64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  __n128 result;
  float64x2_t v10[3];

  v5 = (float64x2_t *)a1[6];
  v6.i64[0] = SLODWORD(a2);
  v6.i64[1] = SHIDWORD(a2);
  v7 = v5[1];
  v8 = vaddq_f64(v5[2], vcvtq_f64_s64(v6));
  v10[0] = *v5;
  v10[1] = v7;
  v10[2] = v8;
  RB::render_glyphs_coverage(a4, v10, a1 + 7, a5, a1[14].f32[0]);
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  unsigned int v7;
  _QWORD v9[3];
  int v10;
  uint64_t v11;
  int v12;

  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix)
    return 0;
  v6 = can_mix;
  v9[1] = 0;
  v9[2] = 0;
  v9[0] = 0xFFFFFFF000000000;
  v10 = 0;
  v11 = 1;
  v12 = 0;
  v7 = RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 56), (const RB::DisplayList::Interpolator::Op *)v9, (const RB::Coverage::Glyphs *)(a3 + 56));
  if (v7 >= v6)
    return v6;
  else
    return v7;
}

float32x2_t *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::mix(uint64_t a1, float *a2, uint64_t a3, float64x2_t *a4)
{
  size_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float32x2_t *v12;
  _OWORD *v14;
  int v15;
  float v16;
  float64x2_t v17[3];

  v8 = (size_t *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, a2[4]);
  v17[0] = v9;
  v17[1] = v10;
  v17[2] = v11;
  v16 = *(float *)(a1 + 112) + (float)((float)(*(float *)(a3 + 112) - *(float *)(a1 + 112)) * a2[4]);
  v15 = *(char *)(a1 + 44);
  v14 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  v12 = (float32x2_t *)RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v8, (RB::Heap *)v8, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v16, &v15, (uint64_t *)&v14);
  RB::Coverage::Glyphs::mix(v12 + 7, (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 56), *(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), v17, (RB::Heap *)v8);
  RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::update_bounds((uint64_t)v12);
  return v12;
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::clip(uint64_t a1, RB::CGContext *a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v8;
  CGAffineTransform transform;

  memset(&v8, 0, sizeof(v8));
  v4 = *(float64x2_t **)(a1 + 48);
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
  {
    RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), a2);
  }
  else
  {
    CGContextGetCTM(&v8, *(CGContextRef *)a2);
    v6 = *(CGContext **)a2;
    v7 = v4[1];
    *(float64x2_t *)&transform.a = *v4;
    *(float64x2_t *)&transform.c = v7;
    *(float64x2_t *)&transform.tx = v4[2];
    CGContextConcatCTM(v6, &transform);
    RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), a2);
    transform = v8;
    CGContextSetCTM();
  }
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::fill(float32x2_t *a1, RB::CGContext *a2, RB::Fill::Color *a3)
{
  float64x2_t *v6;
  int64x2_t v7;
  double v8;
  CGContext *v9;
  float64x2_t v10;
  double v11;
  CGAffineTransform v12;
  CGAffineTransform transform;

  memset(&v12, 0, sizeof(v12));
  v6 = (float64x2_t *)a1[6];
  v7 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v6[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v6, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v6[2]));
  *(_QWORD *)&v8 = vandq_s8((int8x16_t)vdupq_laneq_s64(v7, 1), (int8x16_t)v7).u64[0];
  if ((*(_QWORD *)&v8 & 0x8000000000000000) != 0)
  {
    RB::Coverage::Glyphs::fill(a1 + 7, a2, a3, v8);
  }
  else
  {
    CGContextGetCTM(&v12, *(CGContextRef *)a2);
    v9 = *(CGContext **)a2;
    v10 = v6[1];
    *(float64x2_t *)&transform.a = *v6;
    *(float64x2_t *)&transform.c = v10;
    *(float64x2_t *)&transform.tx = v6[2];
    CGContextConcatCTM(v9, &transform);
    RB::Coverage::Glyphs::fill(a1 + 7, a2, a3, v11);
    transform = v12;
    CGContextSetCTM();
  }
}

float RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 112);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  return RB::Coverage::Glyphs::prepare_encode(a1 + 56, a2);
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;
  int v6;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 56));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v6 = *(int *)(a1 + 112);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((_QWORD *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Glyphs>::print(uint64_t a1, std::string *this)
{
  float v4;

  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  v4 = *(float *)(a1 + 112);
  if (v4 != 1.0)
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 56));
  RB::SexpString::pop(this);
}

_QWORD *RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(RB::Encoder *a1, uint64_t a2, RB::Coverage::Glyphs *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Coverage::Glyphs::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Glyphs>(std::string *a1, RB::Coverage::Glyphs *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Coverage::Glyphs::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B29A98(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10;
  int v11;
  char v12;
  uint64_t v13;

  v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3])
    v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  else
    a1[2] = v10 + 112;
  v11 = *a4;
  v12 = *a5;
  v13 = *a6;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_BYTE *)(v10 + 44) = v12;
  *(_BYTE *)(v10 + 45) = 0;
  *(_QWORD *)v10 = &off_24C2248F0;
  *(_QWORD *)(v10 + 48) = v13;
  *(_QWORD *)(v10 + 56) = off_24C229900;
  *(_QWORD *)(v10 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(v10 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(v10 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(v10 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(v10 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(v10 + 96) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10);
  return v10;
}

void sub_209B29BB8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(uint64_t a1)
{
  uint64_t v2;

  if (*(_BYTE *)(a1 + 44) == 1)
  {
    *(_QWORD *)(a1 + 16) = 0x100000001000000;
    *(int32x2_t *)(a1 + 24) = vdup_n_s32(0x7F7FFFFFu);
  }
  else if (!*(_BYTE *)(a1 + 44))
  {
    if (*(float *)(a1 + 104) == 0.0)
    {
      *(_QWORD *)(a1 + 16) = 0;
      *(_QWORD *)(a1 + 24) = 0;
    }
    else
    {
      *(float32x2_t *)(a1 + 16) = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
      *(_QWORD *)(a1 + 24) = v2;
    }
  }
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::~GenericClip(uint64_t a1)
{
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::~GenericClip(uint64_t a1)
{
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::type_id()
{
  return 16386;
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::copy(uint64_t a1, RB::DisplayList::CachedTransform *this, uint64_t a3, int a4)
{
  size_t *v7;
  int v8;
  char v9;
  uint64_t v10;
  int v11;
  _QWORD *result;
  _OWORD *v13;
  int v14;

  v7 = (size_t *)(*(_QWORD *)(*(_QWORD *)this + 8) + 16);
  v8 = *(char *)(a1 + 44);
  if (a4)
    v8 = *(_BYTE *)(a1 + 44) == 0;
  v14 = v8;
  v13 = RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)this, *(const RB::AffineTransform **)(a1 + 48));
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
    v9 = *(_BYTE *)(a1 + 45) & 4;
  else
    v9 = 4 * *(_BYTE *)(*(_QWORD *)this + 272);
  v10 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)(a1 + 104), &v14, (uint64_t *)&v13);
  *(_QWORD *)(v10 + 32) = RB::DisplayList::CachedTransform::transform_metadata(this, *(const RB::DisplayList::Metadata **)(a1 + 32), *(_DWORD *)(a1 + 40));
  *(_DWORD *)(v10 + 40) = v11;
  *(_BYTE *)(v10 + 45) |= v9;
  result = (_QWORD *)((*((_QWORD *)this + 3) + 7) & 0xFFFFFFFFFFFFFFF8);
  if ((unint64_t)(result + 2) > *((_QWORD *)this + 4))
    result = (_QWORD *)RB::Heap::alloc_slow((size_t *)this + 1, 0x10uLL, 7);
  else
    *((_QWORD *)this + 3) = result + 2;
  *result = a3;
  result[1] = v10;
  return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::contains(uint64_t a1, float32x2_t a2, float32x2_t a3)
{
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  float32x2_t v11[2];

  if (*(_BYTE *)(a1 + 44) != 1)
    return 0;
  if (*(float *)(a1 + 104) == 0.0)
    return 1;
  v11[0] = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  v11[1] = v6;
  return RB::Rect::intersects(v11, a2, a3, v7, v8, v9, v10) ^ 1;
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 92) == 1)
    return 1.0;
  return result;
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5)
{
  float64x2_t *v7;
  int64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  __n128 (***v11)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  float v12;
  float64x2_t v13[3];
  _BYTE v14[40];

  v7 = *(float64x2_t **)(a1 + 48);
  v8.i64[0] = SLODWORD(a2);
  v8.i64[1] = SHIDWORD(a2);
  v9 = v7[1];
  v10 = vaddq_f64(v7[2], vcvtq_f64_s64(v8));
  v13[0] = *v7;
  v13[1] = v9;
  v13[2] = v10;
  v11 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  v12 = *(float *)(a1 + 104);
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v14);
  RB::render_stroke_coverage((uint64_t)a4, v13, v11, (uint64_t)v14, a5, v12);
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::can_mix(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned __int8 can_mix;
  unsigned __int8 v6;
  uint64_t result;

  if (*(unsigned __int8 *)(a1 + 44) != *(unsigned __int8 *)(a3 + 44))
    return 0;
  can_mix = RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3);
  if (!can_mix)
    return 0;
  v6 = can_mix;
  if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a3 + 88)
    && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a3 + 89)
    && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a3 + 90)
    && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a3 + 91)
    && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a3 + 92)
    && *(float *)(a1 + 96) == *(float *)(a3 + 96))
  {
    LOBYTE(result) = RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a3 + 64));
  }
  else
  {
    LOBYTE(result) = 0;
  }
  if (result >= v6)
    return v6;
  else
    return result;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::mix(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  size_t *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  uint64_t v12;
  _OWORD *v14;
  int v15;
  float v16;
  _OWORD v17[3];

  v8 = (size_t *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::mix(*(CGAffineTransform **)(a1 + 48), *(float64x2_t **)(a3 + 48), (const RB::AffineTransform *)a3, *(float *)(a2 + 16));
  v17[0] = v9;
  v17[1] = v10;
  v17[2] = v11;
  v16 = *(float *)(a1 + 104) + (float)((float)(*(float *)(a3 + 104) - *(float *)(a1 + 104)) * *(float *)(a2 + 16));
  v15 = *(char *)(a1 + 44);
  v14 = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v17);
  v12 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(v8, (uint64_t)v8, a1 + 56, (int *)&v16, &v15, (uint64_t *)&v14);
  *(float *)(v12 + 96) = *(float *)(v12 + 96)
                       + (float)((float)(*(float *)(a3 + 96) - *(float *)(v12 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v12 + 72) = 0x100000001000000;
  *(int32x2_t *)(v12 + 80) = vdup_n_s32(0x7F7FFFFFu);
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v12);
  return v12;
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::clip(uint64_t a1, CGContextRef *a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v9;
  CGAffineTransform transform;

  memset(&v9, 0, sizeof(v9));
  v4 = *(float64x2_t **)(a1 + 48);
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
    return RBStrokeRef::clip(a1 + 64);
  CGContextGetCTM(&v9, *a2);
  v6 = *a2;
  v7 = v4[1];
  *(float64x2_t *)&transform.a = *v4;
  *(float64x2_t *)&transform.c = v7;
  *(float64x2_t *)&transform.tx = v4[2];
  CGContextConcatCTM(v6, &transform);
  RBStrokeRef::clip(a1 + 64);
  transform = v9;
  return CGContextSetCTM();
}

uint64_t RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::fill(uint64_t a1, CGContextRef *a2)
{
  float64x2_t *v4;
  int64x2_t v5;
  CGContext *v6;
  float64x2_t v7;
  CGAffineTransform v9;
  CGAffineTransform transform;

  memset(&v9, 0, sizeof(v9));
  v4 = *(float64x2_t **)(a1 + 48);
  v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
  if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) != 0)
    return RBStrokeRef::clip(a1 + 64);
  CGContextGetCTM(&v9, *a2);
  v6 = *a2;
  v7 = v4[1];
  *(float64x2_t *)&transform.a = *v4;
  *(float64x2_t *)&transform.c = v7;
  *(float64x2_t *)&transform.tx = v4[2];
  CGContextConcatCTM(v6, &transform);
  RBStrokeRef::clip(a1 + 64);
  transform = v9;
  return CGContextSetCTM();
}

float RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::cg_alpha(uint64_t a1)
{
  return *(float *)(a1 + 104);
}

uint64_t *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::prepare_encode(uint64_t a1, uint64_t *a2)
{
  return RBStrokeRef::prepare_encode((uint64_t *)(a1 + 64), a1 + 56, a2);
}

_QWORD *RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;
  int v6;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, a1 + 56);
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x12uLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  v6 = *(int *)(a1 + 104);
  if (*(float *)&v6 != 1.0)
  {
    RB::ProtobufEncoder::encode_varint(this, 0x1DuLL);
    RB::ProtobufEncoder::encode_fixed32(this, v6);
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Clip::encode((_QWORD *)a1, this);
}

void RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::print(uint64_t a1, std::string *this)
{
  float v4;

  RB::SexpString::push(this, "clip");
  RB::DisplayList::Clip::print((RB::DisplayList::Clip *)a1, this);
  v4 = *(float *)(a1 + 104);
  if (v4 != 1.0)
    RB::SexpString::printf(this, 0, "(alpha %g)", v4);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, a1 + 56);
  RB::SexpString::pop(this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10;
  int v11;
  char v12;
  uint64_t v13;

  v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3])
    v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  else
    a1[2] = v10 + 112;
  v11 = *a4;
  v12 = *a5;
  v13 = *a6;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_BYTE *)(v10 + 44) = v12;
  *(_BYTE *)(v10 + 45) = 0;
  *(_QWORD *)v10 = &off_24C2248F0;
  *(_QWORD *)(v10 + 48) = v13;
  *(_QWORD *)(v10 + 56) = off_24C229900;
  *(_QWORD *)(v10 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(v10 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(v10 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(v10 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(v10 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(v10 + 96) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10);
  return v10;
}

void sub_209B2A510(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t *RB::Coverage::Stroke<RBStrokeRef>::get_info(uint64_t *result, uint64_t ***a2, uint64_t a3)
{
  int v4;
  uint64_t v5;
  unint64_t *v6;

  *(_DWORD *)a3 = *((unsigned __int8 *)result + 32);
  *(_WORD *)(a3 + 4) = *(_WORD *)((char *)result + 33);
  v4 = *((unsigned __int8 *)result + 35);
  *(_DWORD *)(a3 + 20) = 1065353216;
  *(_DWORD *)(a3 + 8) = v4;
  *(_BYTE *)(a3 + 12) = *((_BYTE *)result + 36);
  *(_DWORD *)(a3 + 16) = *((_DWORD *)result + 10);
  v5 = a3 + 20;
  *(_QWORD *)(a3 + 24) = 1;
  v6 = (unint64_t *)(a3 + 24);
  *(_QWORD *)(v5 + 12) = 0;
  if (*((_BYTE *)result + 32) == 1)
  {
    result = RBStrokeRef::texture((id *)result + 1, *a2, v6, (float *)v5);
    *(_QWORD *)(a3 + 32) = result;
  }
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,float,RB::ClipMode const&,RB::AffineTransform const*>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10;
  int v11;
  char v12;
  uint64_t v13;

  v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3])
    v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  else
    a1[2] = v10 + 112;
  v11 = *a4;
  v12 = *a5;
  v13 = *a6;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_BYTE *)(v10 + 44) = v12;
  *(_BYTE *)(v10 + 45) = 0;
  *(_QWORD *)v10 = &off_24C2248F0;
  *(_QWORD *)(v10 + 48) = v13;
  *(_QWORD *)(v10 + 56) = off_24C229900;
  *(_QWORD *)(v10 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(v10 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(v10 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(v10 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(v10 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(v10 + 96) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10);
  return v10;
}

void sub_209B2A698(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

_QWORD *RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(RB::ProtobufEncoder *a1, uint64_t a2, uint64_t a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RBStrokeRef::encode((id *)(a3 + 8), a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(std::string *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RBStrokeRef::attributes((void **)(a2 + 8), a2, (_QWORD *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B2A7C8(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::ItemFactory::operator()<RB::Coverage::Stroke<RBStrokeRef>>(uint64_t a1, _QWORD *a2)
{
  float32x2_t *v4;
  float32x2_t v5;
  float32x2_t v6;
  double v7;
  double v8;
  double v9;
  int32x4_t v10;
  uint64_t result;
  float64x2_t v12[2];
  uint64_t v13;
  uint64_t v14;

  v4 = *(float32x2_t **)(a1 + 40);
  if (!v4
    || (v12[0] = (float64x2_t)xmmword_209BD5290,
        v12[1] = (float64x2_t)xmmword_209BD52A0,
        v13 = 0,
        v14 = 0,
        v5 = RB::Coverage::Stroke<RBStrokeRef>::bounds(a2, v12),
        result = RB::Rect::intersects(v4, v5, v6, v7, v8, v9, v10),
        (result & 1) != 0))
  {
    *(_QWORD *)&v12[0].f64[0] = a1;
    *(_QWORD *)&v12[0].f64[1] = a2;
    return (uint64_t)RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>>(*(_QWORD **)(a1 + 32), (uint64_t *)v12);
  }
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::MeshGradient>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[3];

  v4 = *a1;
  if (*(_BYTE *)(*a1 + 48))
  {
    v6[0] = off_24C223540;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    v4 = *a1;
  }
  result = *(_QWORD **)(v4 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    v4 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t *a1, const RB::ImageTexture *a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[3];

  v4 = *a1;
  if (*(_BYTE *)(*a1 + 48))
  {
    v6[0] = &off_24C2260B8;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    v4 = *a1;
  }
  result = *(_QWORD **)(v4 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20), (__int16 *)(v4 + 24));
    v4 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Path>::operator()<RB::Fill::Custom>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  _QWORD *result;
  _QWORD v6[3];

  v4 = *a1;
  if (*(_BYTE *)(*a1 + 48))
  {
    v6[0] = off_24C2260D8;
    v6[1] = a1;
    v6[2] = a2;
    RB::Coverage::Path::simplify(a1[1], (uint64_t)v6);
    v4 = *a1;
  }
  result = *(_QWORD **)(v4 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(size_t **)v4, a1[1], a2, (uint64_t *)(v4 + 8), (float *)(v4 + 16), (_DWORD *)(v4 + 20));
    v4 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Color>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::type_id()
{
  return 4198401;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2)
{
  RB::Heap *v3;
  __n128 result;
  __n128 *v5;
  int v6;

  v3 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46) & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (uint64_t)v3, (__int128 *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  result = *(__n128 *)(a1 + 16);
  v5[1] = result;
  v5[2].n128_u64[0] = *(_QWORD *)(a1 + 32);
  v5[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v5[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

uint64_t RB::DisplayList::Item::atom_count(RB::DisplayList::Item *this)
{
  return 0xFFFFFFFFLL;
}

uint64_t RB::DisplayList::Item::copy_atoms(RB::DisplayList::Item *this, Builder *a2, unsigned int a3, unsigned int a4, uint64_t a5)
{
  return (*(uint64_t (**)(RB::DisplayList::Item *, Builder *, uint64_t))(*(_QWORD *)this + 24))(this, a2, a5);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::atom_position(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

uint64_t RB::DisplayList::Item::atom_bounds(RB::DisplayList::Item *this)
{
  return (*(uint64_t (**)(RB::DisplayList::Item *, _QWORD))(*(_QWORD *)this + 144))(this, 0);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float64x2_t *v13;
  float64x2_t *v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t *v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  __n128 *v25;
  float64x2_t v26[3];
  __int128 v27[2];
  int v28;
  _QWORD v29[3];
  float v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;

  if ((*(_BYTE *)(a3 + 88) & 0x10) == 0)
  {
    _H0 = a1[7].n128_u16[3];
    __asm { FCVT            S0, H0 }
    v30 = _S0;
    if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
    {
      memset(v27, 0, sizeof(v27));
      v28 = 1065353216;
      v29[0] = 0;
      *(_DWORD *)((char *)v29 + 7) = 0;
      v13 = *(float64x2_t **)(a3 + 16);
      v14 = (float64x2_t *)a1[3].n128_u64[0];
      v15 = *v14;
      v16 = v14[2];
      v32 = v14[1];
      v33 = v16;
      v31 = v15;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v31))
        v17 = &v31;
      else
        v17 = v14;
      v18 = v17[1];
      v19 = v17[2];
      v26[0] = *v17;
      v26[1] = v18;
      v26[2] = v19;
      v20.f64[0] = RB::operator*(v13, v26);
      v31 = v20;
      v32 = v21;
      v33 = v22;
      if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v31, *(float *)(a3 + 64), &v30, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v27))
      {
        _H1 = a1[2].n128_u16[6];
        __asm { FCVT            S1, H1 }
        RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v27, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v30, _S1);
        result = a1[1];
        v25[1] = result;
        v25[2].n128_u64[0] = a1[2].n128_u64[0];
        v25[2].n128_u32[2] = a1[2].n128_u32[2];
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, int8x16_t a5)
{
  size_t *v13;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  __int32 v21;
  int v22;

  v22 = a3;
  _H1 = *(_WORD *)(a1 + 118);
  __asm { FCVT            S1, H1 }
  v13 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  *(float *)a5.i32 = (float)(_S1 * *(float *)a5.i32) * _S2;
  v21 = a5.i32[0];
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v13, a5, (uint64_t)v13, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v21, &v22, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

unsigned __int16 RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, int a3@<W2>, __int16 a4@<W3>, uint16x4_t a5@<D0>)
{
  return RB::Fill::Color::append_color_matrix((__int16 *)(a1 + 112), a2, a3, a4, a5);
}

BOOL RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Color>::append_blur(uint64_t a1, float64x2_t *a2, int8x16_t a3, double a4, int8x16_t a5, int32x4_t a6)
{
  float v7;
  _QWORD *v9;
  float32x2_t v10;
  double v11;
  int v12;
  _BOOL8 result;
  double v14;
  double v15;

  v7 = *(float *)a3.i32;
  v9 = *(_QWORD **)(a1 + 24);
  if (!v9)
    return RB::Coverage::Primitive::append_blur((RB::Coverage::Primitive *)(a1 + 64), v7, *(float64x2_t **)(a1 + 48), a2);
  v10 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a3, a4, a5, a6);
  v14 = *(double *)&v10;
  v15 = v11;
  v10.f32[0] = -ceilf(v7 * 2.8);
  RB::Rect::inset((float32x2_t *)&v14, v10, v10.f32[0]);
  v12 = RB::DisplayList::ClipNode::contains(v9, v14, v15);
  result = 0;
  if (v12)
    return RB::Coverage::Primitive::append_blur((RB::Coverage::Primitive *)(a1 + 64), v7, *(float64x2_t **)(a1 + 48), a2);
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  RB::Heap *v4;
  uint64_t v14;
  uint64_t v15;
  __int16 v17;
  int v18;

  v18 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  _H1 = *(_WORD *)(a1 + 118);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v17 = LOWORD(_S0);
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (__int128 *)(a1 + 64), a3, (uint64_t *)(a1 + 48), &v17, &v18);
  v15 = v14;
  *(_OWORD *)(v14 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v14 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v14 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v15;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(_BYTE *)(a1 + 109) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::has_no_effect(_WORD *a1)
{
  _H0 = a1[22];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  _H0 = a1[59];
  __asm { FCVT            S0, H0 }
  if (_S0 <= 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 112), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::apply_transform(float16x4_t *a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::Color::apply_transform(a1 + 14, a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 4198401)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 14), (const RB::Fill::Color *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

float16x4_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  float16x4_t *v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  _OWORD v20[3];

  v8 = (float16x4_t *)(*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v20[0] = v10;
  v20[1] = v11;
  v20[2] = v12;
  v8[6] = (float16x4_t)RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v20);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Color::mix(v8 + 14, (float16x4_t *)(a3 + 112), 3, v13, v14, v15, v16, v17, v18);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix((uint64_t)&v8[8], a2, a3 + 64);
  if ((v8[5].i16[3] & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    v8[5].i16[3] |= 0x1000u;
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)&a1[7]);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Color>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 64));
  RB::XML::print_attributes<RB::Fill::Color>(this, (float16x4_t *)(a1 + 112));
  RB::SexpString::pop(this);
}

uint64_t RB::DisplayList::Item::copy_shadow(RB::DisplayList::Item *this, Builder *a2, const RB::DisplayList::ShadowStyle *a3)
{
  return 0;
}

uint64_t RB::DisplayList::Item::append_blur(RB::DisplayList::Item *this, float a2, const RB::AffineTransform *a3)
{
  return 0;
}

void *RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(void *__dst, size_t a2)
{
  size_t v3;
  void *result;

  if (*((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1) <= a2)
    v3 = a2;
  else
    v3 = *((_QWORD *)__dst + 6) + (*((_QWORD *)__dst + 6) >> 1);
  result = RB::details::realloc_vector<unsigned long,8ul>(*((void **)__dst + 4), __dst, 4uLL, (size_t *)__dst + 6, v3);
  *((_QWORD *)__dst + 4) = result;
  return result;
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(RB::Heap *this, __int128 *a2, uint64_t a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  __int128 v17;
  __int128 v18;
  __n128 result;
  __int128 v20;
  __int128 v21;

  v12 = *((_QWORD *)this + 3);
  v13 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 176 > v12)
    v13 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 15);
  else
    *((_QWORD *)this + 2) = v13 + 176;
  v14 = *a4;
  v15 = *a5;
  v16 = *a6;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C227720;
  *(_QWORD *)(v13 + 48) = v14;
  v17 = *a2;
  v18 = a2[2];
  *(_OWORD *)(v13 + 80) = a2[1];
  *(_OWORD *)(v13 + 96) = v18;
  *(_OWORD *)(v13 + 64) = v17;
  result = *(__n128 *)a3;
  v20 = *(_OWORD *)(a3 + 16);
  v21 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v13 + 144) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v13 + 160) = v21;
  *(__n128 *)(v13 + 112) = result;
  *(_OWORD *)(v13 + 128) = v20;
  *(_QWORD *)v13 = &off_24C225F80;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::type_id()
{
  return 8392705;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (__int128 *)(a1 + 64), (uint64_t *)(a1 + 112), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(_QWORD *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::atom_position(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float64x2_t *v7;
  float64x2_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t *v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  __n128 *v23;
  float64x2_t v24[3];
  __int128 v25[2];
  int v26;
  _QWORD v27[3];
  float v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;

  if ((*(_BYTE *)(a3 + 88) & 0x10) == 0)
  {
    v28 = 0.0;
    if (RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)&a1[7], &v28)
      && (RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
    {
      memset(v25, 0, sizeof(v25));
      v26 = 1065353216;
      v27[0] = 0;
      *(_DWORD *)((char *)v27 + 7) = 0;
      v7 = *(float64x2_t **)(a3 + 16);
      v8 = (float64x2_t *)a1[3].n128_u64[0];
      v9 = *v8;
      v10 = v8[2];
      v30 = v8[1];
      v31 = v10;
      v29 = v9;
      if (RB::AffineTransform::invert((RB::AffineTransform *)&v29))
        v11 = &v29;
      else
        v11 = v8;
      v12 = v11[1];
      v13 = v11[2];
      v24[0] = *v11;
      v24[1] = v12;
      v24[2] = v13;
      v14.f64[0] = RB::operator*(v7, v24);
      v29 = v14;
      v30 = v15;
      v31 = v16;
      if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
      {
        _H1 = a1[2].n128_u16[6];
        __asm { FCVT            S1, H1 }
        RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v28, _S1);
        result = a1[1];
        v23[1] = result;
        v23[2].n128_u64[0] = a1[2].n128_u64[0];
        v23[2].n128_u32[2] = a1[2].n128_u32[2];
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v11;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  __int32 v21;
  float v22;
  int v23;

  v22 = 0.0;
  v23 = a3;
  if (!RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 112), &v22))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v11 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _Q0.i16[0] = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  *(float *)_Q0.i32 = *(float *)_Q0.i32 * (float)(a5 * v22);
  v21 = _Q0.i32[0];
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v11, _Q0, (uint64_t)v11, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v21, &v23, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::Gradient::append_color_matrix(a1 + 112, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(_BYTE *)(a1 + 109) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 8392705)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Gradient::can_mix((RB::Fill::Gradient *)(a1 + 14), (const RB::Fill::Gradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  _OWORD v20[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v20[0] = v10;
  v20[1] = v11;
  v20[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v20);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 112), v13, (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16), v14, v15, v16, v17, v18);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)&a1[7]);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Gradient>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 64));
  RB::XML::print_attributes<RB::Fill::Gradient>(this, (float32x2_t *)(a1 + 112));
  RB::SexpString::pop(this);
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Gradient>::visit_<RB::Coverage::Primitive>(_QWORD *a1, __int128 *a2)
{
  uint64_t *v3;
  uint64_t *v4;
  size_t *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = (uint64_t *)a1[3];
  v4 = a1 + 4;
  v5 = (size_t *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (RB::Heap *)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Gradient>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(_QWORD *a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = (uint64_t *)a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 208 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 208;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C225B20;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C2272C0;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(a1 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(a1 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 144), a4, a7, a2);
  return a1;
}

void sub_209B2BD3C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C2272C0;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C2272C0;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::type_id()
{
  return 8400897;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  uint64_t (**v5)(_QWORD, __int128 *);
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  uint64_t (**v10[5])(_QWORD, __int128 *);
  uint64_t v11;

  v4 = 0;
  v5 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223BA8;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
  v10[3] = (uint64_t (**)(_QWORD, __int128 *))(a1 + 144);
  v10[4] = *(uint64_t (***)(_QWORD, __int128 *))(a1 + 48);
  v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, (uint64_t *)(a1 + 144), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 144), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, (uint64_t)v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::Gradient::append_color_matrix(a1 + 144, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 200);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 132) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, __int32 a5, int a6)
{
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  float64x2_t v9;
  _OWORD v16[3];
  int v17;
  __int16 v18;
  int v19;
  char v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v6 = *(_QWORD *)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = *(_OWORD *)(v6 + 16);
  v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  v17 = *(unsigned __int8 *)(a1 + 128);
  v18 = *(_WORD *)(a1 + 129);
  v19 = *(unsigned __int8 *)(a1 + 131);
  v20 = *(_BYTE *)(a1 + 132);
  v21 = *(_DWORD *)(a1 + 136);
  v22 = 1065353216;
  v23 = 1;
  v24 = 0;
  if (v17 == 1)
    abort();
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a4, (uint64_t (**)(_QWORD, _QWORD *))v16, (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56), (uint64_t)&v17, (float32x2_t *)(a1 + 144), a5, a6, _S0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  double v18;
  float64x2_t v19;
  float64x2_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float64x2_t v23[2];
  uint64_t v24;
  uint64_t v25;
  int32x2_t v26[2];

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v23[0] = (float64x2_t)xmmword_209BD5290;
  v23[1] = (float64x2_t)xmmword_209BD52A0;
  v24 = 0;
  v25 = 0;
  v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v23);
  RB::Bounds::Bounds(v26, v16, v17);
  RB::Fill::Gradient::fill(a1 + 144, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  const RB::AffineTransform *v13;
  unsigned __int8 v14;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 8400897)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
        && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
        && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
        && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
        && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
        && *(float *)(a1 + 136) == *(float *)(a4 + 136))
      {
        result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
        if ((_BYTE)result)
        {
          v14 = result;
          can_mix = RB::Fill::Gradient::can_mix((RB::Fill::Gradient *)(a1 + 144), (const RB::Fill::Gradient *)(a4 + 144), v13);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v14, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v27[3];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v31[0] = v10;
  v31[1] = v11;
  v31[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v31);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 144), v14, v13, v15, v16, v17, v18, v19);
  *(double *)&v20 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28 = v20;
  v29 = v21;
  v30 = v22;
  *(double *)&v23 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  LODWORD(v23) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v28, (uint64_t)v27, *(_QWORD *)(v8 + 48), *(CGFloat *)&v23);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v28 = off_24C223BA8;
    *((_QWORD *)&v28 + 1) = v13;
    *(_QWORD *)&v29 = v8;
    *((_QWORD *)&v29 + 1) = v8 + 144;
    v30 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(_QWORD, __int128 *))&v28);
    if (*((_QWORD *)&v30 + 1))
    {
      *(_QWORD *)v8 = off_24C2272C0;
      *(_QWORD *)(v8 + 56) = off_24C229920;
      RBPathRelease(*(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72));
      v8 = *((_QWORD *)&v30 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 18));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, a1 + 56);
  RB::XML::print_attributes<RB::Fill::Gradient>(this, (float32x2_t *)(a1 + 144));
  RB::SexpString::pop(this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  else
    a1[2] = v11 + 152;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C224988;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(v11 + 64, a3 + 8, a2);
  *(_OWORD *)(v11 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(v11 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(v11 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(v11 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(v11 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(v11 + 136) = *(_DWORD *)(a3 + 80);
  *(_DWORD *)(v11 + 144) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::update_bounds(v11);
  return v11;
}

void sub_209B2C800(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::Encoder::typed_message_field<RB::Fill::Gradient>(RB::Encoder *a1, uint64_t a2, RB::Fill::Gradient *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x12uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Gradient::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Gradient>(std::string *a1, float32x2_t *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Fill::Gradient::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B2C928(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Color>::visit_<RB::Coverage::Primitive>(_QWORD *a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Color>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226F78;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::type_id()
{
  return 4206593;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  uint64_t (**v5)(_QWORD, __int128 *);
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  uint64_t (**v10[5])(_QWORD, __int128 *);
  uint64_t v11;

  v4 = 0;
  v5 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223B48;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
  v10[3] = (uint64_t (**)(_QWORD, __int128 *))(a1 + 144);
  v10[4] = *(uint64_t (***)(_QWORD, __int128 *))(a1 + 48);
  v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (uint64_t)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v13;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  float v21;
  int v22;

  v22 = a3;
  _H1 = *(_WORD *)(a1 + 150);
  __asm { FCVT            S1, H1 }
  v13 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  v21 = (float)(_S1 * a5) * _S2;
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, (uint64_t)v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

unsigned __int16 RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, int a3@<W2>, __int16 a4@<W3>, uint16x4_t a5@<D0>)
{
  return RB::Fill::Color::append_color_matrix((__int16 *)(a1 + 144), a2, a3, a4, a5);
}

unint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  size_t *v4;
  unint64_t v14;
  __int16 v16;
  int v17;

  v17 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  _H1 = *(_WORD *)(a1 + 150);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v16 = LOWORD(_S0);
  v14 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, a1 + 56, a3, (uint64_t *)(a1 + 48), &v16, &v17);
  *(_OWORD *)(v14 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v14 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v14 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v14;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 132) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::has_no_effect(_WORD *a1)
{
  _H0 = a1[22];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  _H0 = a1[75];
  __asm { FCVT            S0, H0 }
  if (_S0 <= 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  __int128 v16;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v16, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v16, *(int32x2_t *)((char *)&v16 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v16, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::Coverage::StrokeablePath::fill(a1 + 64, a1 + 56, a2, (__int16 *)(a1 + 144));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 144), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::apply_transform(float16x4_t *a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::Color::apply_transform(a1 + 18, a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 4206593)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
        && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
        && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
        && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
        && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
        && *(float *)(a1 + 136) == *(float *)(a4 + 136))
      {
        result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 144), (const RB::Fill::Color *)(a4 + 144));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v27[3];
  __int128 v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v31[0] = v10;
  v31[1] = v11;
  v31[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v31);
  v13 = (RB *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Color::mix((float16x4_t *)(v8 + 144), (float16x4_t *)(a3 + 144), 3, v14, v15, v16, v17, v18, v19);
  *(double *)&v20 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28 = v20;
  v29 = v21;
  v30 = v22;
  *(double *)&v23 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  LODWORD(v23) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v28, (uint64_t)v27, *(_QWORD *)(v8 + 48), *(CGFloat *)&v23);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v28 = off_24C223B48;
    *((_QWORD *)&v28 + 1) = v13;
    *(_QWORD *)&v29 = v8;
    *((_QWORD *)&v29 + 1) = v8 + 144;
    v30 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(_QWORD, __int128 *))&v28);
    if (*((_QWORD *)&v30 + 1))
    {
      *(_QWORD *)v8 = off_24C226F78;
      *(_QWORD *)(v8 + 56) = off_24C229920;
      RBPathRelease(*(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72));
      v8 = *((_QWORD *)&v30 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 18));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, a1 + 56);
  RB::XML::print_attributes<RB::Fill::Color>(this, (float16x4_t *)(a1 + 144));
  RB::SexpString::pop(this);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t a2, _OWORD *a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11;
  uint64_t v12;
  __int16 v13;
  char v14;
  uint64_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 208 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0xD0uLL, 7);
  else
    a1[2] = v11 + 208;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(_QWORD *)v11 = off_24C2272C0;
  *(_QWORD *)(v11 + 48) = v12;
  *(_QWORD *)(v11 + 56) = off_24C229920;
  *(_QWORD *)(v11 + 64) = RBPathRetain(*(_QWORD *)(a2 + 8), *(_QWORD *)(a2 + 16));
  *(_QWORD *)(v11 + 72) = v15;
  v16 = *(_OWORD *)(a2 + 40);
  *(_OWORD *)(v11 + 80) = *(_OWORD *)(a2 + 24);
  *(_OWORD *)(v11 + 96) = v16;
  v17 = *(_OWORD *)(a2 + 68);
  *(_OWORD *)(v11 + 112) = *(_OWORD *)(a2 + 56);
  *(_OWORD *)(v11 + 124) = v17;
  v19 = a3[2];
  v18 = a3[3];
  v20 = a3[1];
  *(_OWORD *)(v11 + 144) = *a3;
  *(_OWORD *)(v11 + 160) = v20;
  *(_OWORD *)(v11 + 176) = v19;
  *(_OWORD *)(v11 + 192) = v18;
  *(_QWORD *)v11 = &off_24C225B20;
  return v11;
}

_QWORD *RB::Encoder::typed_message_field<RB::Fill::Color>(RB::Encoder *a1, uint64_t a2, RB::Fill::Color *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Color::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Color>(std::string *a1, float16x4_t *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Fill::Color::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B2D508(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226258;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::type_id()
{
  return 4202497;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Color>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  RB::Heap *v5;
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  _QWORD v10[5];
  uint64_t v11;

  v4 = 0;
  v5 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = off_24C223B48;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 88;
  v10[4] = *(_QWORD *)(a1 + 48);
  v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 88, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;
  RBPath v4;

  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.info = (void *)(a1 + 56);
  v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v13;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  float v21;
  int v22;

  v22 = a3;
  _H1 = *(_WORD *)(a1 + 94);
  __asm { FCVT            S1, H1 }
  v13 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  v21 = (float)(_S1 * a5) * _S2;
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

unsigned __int16 RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, int a3@<W2>, __int16 a4@<W3>, uint16x4_t a5@<D0>)
{
  return RB::Fill::Color::append_color_matrix((__int16 *)(a1 + 88), a2, a3, a4, a5);
}

unint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, _OWORD *a3)
{
  size_t *v4;
  unint64_t v14;
  __int16 v16;
  int v17;

  v17 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  _H1 = *(_WORD *)(a1 + 94);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v16 = LOWORD(_S0);
  v14 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (uint64_t *)(a1 + 56), a3, (uint64_t *)(a1 + 48), &v16, &v17);
  *(_OWORD *)(v14 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v14 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v14 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v14;
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result;

  result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::has_no_effect(_WORD *a1)
{
  _H0 = a1[22];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  _H0 = a1[47];
  __asm { FCVT            S0, H0 }
  if (_S0 <= 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  float64x2_t v12;
  _OWORD v22[3];
  __int16 v23;
  int v24;
  __int16 v25;
  __int16 v26;
  _BYTE v27[8];
  uint64_t v28;
  void *v29;
  char v30;
  int32x2_t *v31[6];

  v31[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  v11 = *(_OWORD *)(v9 + 16);
  v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v22[0] = *(_OWORD *)v9;
  v22[1] = v11;
  v22[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v27, a3, (const RB::AffineTransform *)v22, (const RB::Coverage::Path *)(a1 + 56));
  v23 = *(_WORD *)(a1 + 88);
  v24 = *(_DWORD *)(a1 + 90);
  _H0 = *(_WORD *)(a1 + 94);
  __asm
  {
    FCVT            S1, H8
    FCVT            S0, H0
  }
  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }
  v25 = LOWORD(_S0);
  v26 = *(_WORD *)(a1 + 96);
  RB::Path::Renderer::render(v31, (uint64_t)&v23, a5, a6);
  if (v30)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v28);
  if (v29)
    free(v29);
}

void sub_209B2D9A4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,uint64_t a50,uint64_t a51,uint64_t a52,char a53)
{
  if (a49)
    free(a49);
  _Unwind_Resume(exception_object);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 88), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::apply_transform(float16x4_t *a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::Color::apply_transform(a1 + 11, a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 4202497)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 11), (const RB::Fill::Color *)(a4 + 11));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  __int128 v21;
  __int128 v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v27[3];
  float64x2_t v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v31[0] = v10;
  v31[1] = v11;
  v31[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v31);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Color::mix((float16x4_t *)(v8 + 88), (float16x4_t *)(a3 + 88), 3, v14, v15, v16, v17, v18, v19);
  v20.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28 = v20;
  v29 = v21;
  v30 = v22;
  v23.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v28, v27, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v28.f64[0] = off_24C223B48;
    *(_QWORD *)&v28.f64[1] = v13;
    *(_QWORD *)&v29 = v8;
    *((_QWORD *)&v29 + 1) = v8 + 88;
    v30 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v28);
    if (*((_QWORD *)&v30 + 1))
    {
      *(_QWORD *)v8 = off_24C226258;
      RBPathRelease(*(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64));
      v8 = *((_QWORD *)&v30 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 88));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Color>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 56));
  RB::XML::print_attributes<RB::Fill::Color>(this, (float16x4_t *)(a1 + 88));
  RB::SexpString::pop(this);
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, size_t *a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v11;
  int v12;
  char v13;
  uint64_t v14;
  uint64_t v15;
  __int128 *v16;
  _OWORD *v17;
  __int128 v18;
  __int128 v19;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 96 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x60uLL, 7);
  else
    a1[2] = v11 + 96;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_BYTE *)(v11 + 44) = v13;
  *(_BYTE *)(v11 + 45) = 0;
  *(_QWORD *)v11 = &off_24C2247C0;
  *(_QWORD *)(v11 + 48) = v14;
  *(_QWORD *)(v11 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(v11 + 64) = v15;
  v16 = *(__int128 **)(a3 + 16);
  if (v16)
  {
    v17 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v17 + 3) > a2[3])
      v17 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v17 + 3);
    v18 = *v16;
    v19 = v16[2];
    v17[1] = v16[1];
    v17[2] = v19;
    *v17 = v18;
  }
  else
  {
    v17 = 0;
  }
  *(_QWORD *)(v11 + 72) = v17;
  *(_DWORD *)(v11 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(v11 + 84) = *(_WORD *)(a3 + 28);
  *(_DWORD *)(v11 + 88) = v12;
  RB::DisplayList::GenericClip<RB::Coverage::Path>::update_bounds(v11);
  return v11;
}

void sub_209B2DEB8(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t *a2, _OWORD *a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11;
  uint64_t v12;
  __int16 v13;
  char v14;
  uint64_t v15;
  uint64_t v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 152 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0x98uLL, 7);
  else
    a1[2] = v11 + 152;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(_QWORD *)v11 = off_24C2265A0;
  *(_QWORD *)(v11 + 48) = v12;
  *(_QWORD *)(v11 + 56) = RBPathRetain(*a2, a2[1]);
  *(_QWORD *)(v11 + 64) = v15;
  v16 = *(uint64_t *)((char *)a2 + 22);
  *(_QWORD *)(v11 + 72) = a2[2];
  *(_QWORD *)(v11 + 78) = v16;
  v17 = a3[2];
  v18 = a3[3];
  v19 = a3[1];
  *(_OWORD *)(v11 + 88) = *a3;
  *(_OWORD *)(v11 + 136) = v18;
  *(_OWORD *)(v11 + 120) = v17;
  *(_OWORD *)(v11 + 104) = v19;
  *(_QWORD *)v11 = &off_24C224E00;
  return v11;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C2265A0;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C2265A0;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::type_id()
{
  return 8396801;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  RB::Heap *v5;
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  _QWORD v10[5];
  uint64_t v11;

  v4 = 0;
  v5 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = off_24C223BA8;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 88;
  v10[4] = *(_QWORD *)(a1 + 48);
  v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, (uint64_t *)(a1 + 88), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;
  RBPath v4;

  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.info = (void *)(a1 + 56);
  v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 88), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::Gradient::append_color_matrix(a1 + 88, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::bounds(uint64_t a1)
{
  RBPath v2;

  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result;

  result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  float64x2_t v12;
  _OWORD v19[3];
  _BYTE v20[8];
  uint64_t v21;
  void *v22;
  char v23;
  int32x2_t *v24[6];

  v24[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  v11 = *(_OWORD *)(v9 + 16);
  v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 88, (uint64_t)v19, a5, a6, _S0);
  if (v23)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  if (v22)
    free(v22);
}

void sub_209B2E41C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47)
    free(a47);
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  double v18;
  float64x2_t v19;
  float64x2_t v20;
  int8x16_t v21;
  int8x16_t v22;
  _OWORD v23[2];
  uint64_t v24;
  uint64_t v25;
  int32x2_t v26[2];
  RBPath v27;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0], *(int32x2_t *)((char *)v23 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v23[0] = xmmword_209BD5290;
  v23[1] = xmmword_209BD52A0;
  v24 = 0;
  v25 = 0;
  v27.callbacks = (RBPathCallbacks *)v23;
  v27.info = (void *)(a1 + 56);
  v16 = RB::Coverage::Path::bounds(v27);
  RB::Bounds::Bounds(v26, *(float32x2_t *)&v16, v17);
  RB::Fill::Gradient::fill(a1 + 88, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 88), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 8396801)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Gradient::can_mix((RB::Fill::Gradient *)(a1 + 11), (const RB::Fill::Gradient *)(a4 + 11), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  __int128 v21;
  __int128 v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v27[3];
  float64x2_t v28;
  __int128 v29;
  __int128 v30;
  _OWORD v31[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v31[0] = v10;
  v31[1] = v11;
  v31[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v31);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 88), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 88), v14, v13, v15, v16, v17, v18, v19);
  v20.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28 = v20;
  v29 = v21;
  v30 = v22;
  v23.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v28, v27, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v28.f64[0] = off_24C223BA8;
    *(_QWORD *)&v28.f64[1] = v13;
    *(_QWORD *)&v29 = v8;
    *((_QWORD *)&v29 + 1) = v8 + 88;
    v30 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v28);
    if (*((_QWORD *)&v30 + 1))
    {
      *(_QWORD *)v8 = off_24C2265A0;
      RBPathRelease(*(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64));
      v8 = *((_QWORD *)&v30 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 88));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 56));
  RB::XML::print_attributes<RB::Fill::Gradient>(this, (float32x2_t *)(a1 + 88));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 152 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 152;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C224E00;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  uint64_t v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C2265A0;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(a1 + 64) = v18;
  v19 = *(__int128 **)(a3 + 16);
  if (v19)
  {
    v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3])
      v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v20 + 3);
    v21 = *v19;
    v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *v20 = v21;
  }
  else
  {
    v20 = 0;
  }
  *(_QWORD *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 88), a4, a7, (RB::Heap *)a2);
  return a1;
}

void sub_209B2EAD8(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 152 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 152;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C224E00;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Gradient>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 208 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 208;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C225B20;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 136 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x88uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 136;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C222FC8;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::MeshGradient>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::MeshGradient>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, __int128 *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15;
  uint64_t v16;
  char v18;
  __int16 v19;
  __int128 v24;
  __int128 v25;

  v15 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 160 > a1[3])
    v15 = RB::Heap::alloc_slow(a1, 0xA0uLL, 15);
  else
    a1[2] = v15 + 160;
  v16 = *a5;
  _S0 = *a6;
  v18 = *a7;
  v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F | 0x4000;
  *(_QWORD *)v15 = off_24C2239E0;
  *(_QWORD *)(v15 + 48) = v16;
  v24 = *a3;
  v25 = a3[1];
  *(_OWORD *)(v15 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v15 + 64) = v24;
  *(_OWORD *)(v15 + 80) = v25;
  RB::Fill::MeshGradient::MeshGradient(v15 + 112, a4, v19, a2);
  *(_QWORD *)v15 = &off_24C223428;
  return v15;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C2239E0;
  v2 = (unsigned int *)a1[15];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *a1 = off_24C2239E0;
  v1 = (unsigned int *)a1[15];
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::type_id()
{
  return 20975617;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (__int128 *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(_QWORD *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::atom_position(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::copy_shadow(__n128 *a1, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float64x2_t *v7;
  float64x2_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t *v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  __n128 *v23;
  float64x2_t v24[3];
  __int128 v25[2];
  int v26;
  _QWORD v27[3];
  float v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;

  if ((*(_BYTE *)(a3 + 88) & 0x10) == 0)
  {
    v28 = 0.0;
    if (RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)&a1[7], &v28))
    {
      if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)a1, *(float *)(a3 + 64)) & 1) == 0)
      {
        memset(v25, 0, sizeof(v25));
        v26 = 1065353216;
        v27[0] = 0;
        *(_DWORD *)((char *)v27 + 7) = 0;
        v7 = *(float64x2_t **)(a3 + 16);
        v8 = (float64x2_t *)a1[3].n128_u64[0];
        v9 = *v8;
        v10 = v8[2];
        v30 = v8[1];
        v31 = v10;
        v29 = v9;
        if (RB::AffineTransform::invert((RB::AffineTransform *)&v29))
          v11 = &v29;
        else
          v11 = v8;
        v12 = v11[1];
        v13 = v11[2];
        v24[0] = *v11;
        v24[1] = v12;
        v24[2] = v13;
        v14.f64[0] = RB::operator*(v7, v24);
        v29 = v14;
        v30 = v15;
        v31 = v16;
        if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&a1[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
        {
          _H1 = a1[2].n128_u16[6];
          __asm { FCVT            S1, H1 }
          RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, a1[3].n128_i64[0], a1[2].n128_u16[7] & 0x3F, v28, _S1);
          result = a1[1];
          v23[1] = result;
          v23[2].n128_u64[0] = a1[2].n128_u64[0];
          v23[2].n128_u32[2] = a1[2].n128_u32[2];
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v11;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  __int32 v21;
  float v22;
  int v23;

  v22 = 0.0;
  v23 = a3;
  if (!RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 112), &v22))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v11 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _Q0.i16[0] = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  *(float *)_Q0.i32 = *(float *)_Q0.i32 * (float)(a5 * v22);
  v21 = _Q0.i32[0];
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v11, _Q0, (uint64_t)v11, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v21, &v23, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::MeshGradient::append_color_matrix(a1 + 112, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(_BYTE *)(a1 + 109) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::render(int32x2_t *a1, double a2, uint64_t a3, uint64_t a4, __int32 a5, unsigned int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v14[3];

  v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_primitive(a4, v14, (uint64_t)&a1[8], a1 + 14, a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  int8x16_t v16;
  int32x4_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float64x2_t v20[2];
  uint64_t v21;
  uint64_t v22;
  int32x2_t v23[2];

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip((float32x2_t *)(a1 + 64), (CGContext **)a2);
  v20[0] = (float64x2_t)xmmword_209BD5290;
  v20[1] = (float64x2_t)xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v18 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), v20, (int8x16_t)xmmword_209BD5290, 0.0, v16, v17);
  RB::Bounds::Bounds(v23, v18, v19);
  RB::Fill::MeshGradient::fill((int32x2_t *)(a1 + 112), (int8x8_t *)a2, v23[0], v23[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 20975617)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 14), (const RB::Fill::MeshGradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  double v13;
  _OWORD v15[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 112), v13, (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)&a1[7]);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 8));
  RB::XML::print_attributes<RB::Fill::MeshGradient>(this, (RB::Fill::MeshGradient *)(a1 + 14));
  RB::SexpString::pop(this);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, __int128 *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  __int128 v17;
  __int128 v18;

  v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 160 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0xA0uLL, 15);
  else
    a1[2] = v13 + 160;
  v14 = *a5;
  v15 = *a6;
  v16 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F | 0x4000;
  *(_QWORD *)v13 = off_24C2239E0;
  *(_QWORD *)(v13 + 48) = v14;
  v17 = *a3;
  v18 = a3[1];
  *(_OWORD *)(v13 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v13 + 64) = v17;
  *(_OWORD *)(v13 + 80) = v18;
  RB::Fill::MeshGradient::MeshGradient(v13 + 112, a4, 0, a2);
  *(_QWORD *)v13 = &off_24C223428;
  return v13;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::MeshGradient>::visit_<RB::Coverage::Primitive>(_QWORD *a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t *v4;
  size_t *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (size_t *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (RB::Heap *)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::MeshGradient>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 192 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xC0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 192;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C223310;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C2238C8;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(a1 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(a1 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::MeshGradient::MeshGradient(a1 + 144, a4, a7, a2);
  return a1;
}

void sub_209B2FBC8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C2238C8;
  v2 = (unsigned int *)a1[19];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C2238C8;
  v2 = (unsigned int *)a1[19];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::type_id()
{
  return 20983809;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  uint64_t (**v5)(_QWORD, __int128 *);
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  uint64_t (**v10[5])(_QWORD, __int128 *);
  uint64_t v11;

  v4 = 0;
  v5 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223B28;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
  v10[3] = (uint64_t (**)(_QWORD, __int128 *))(a1 + 144);
  v10[4] = *(uint64_t (***)(_QWORD, __int128 *))(a1 + 48);
  v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 144), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, (uint64_t)v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::MeshGradient::append_color_matrix(a1 + 144, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 184);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 132) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::render(uint64_t a1, double a2, uint64_t a3, _QWORD *a4, char a5, int a6)
{
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  float64x2_t v9;
  _OWORD v16[3];
  int v17;
  __int16 v18;
  int v19;
  char v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v6 = *(_QWORD *)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = *(_OWORD *)(v6 + 16);
  v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  v17 = *(unsigned __int8 *)(a1 + 128);
  v18 = *(_WORD *)(a1 + 129);
  v19 = *(unsigned __int8 *)(a1 + 131);
  v20 = *(_BYTE *)(a1 + 132);
  v21 = *(_DWORD *)(a1 + 136);
  v22 = 1065353216;
  v23 = 1;
  v24 = 0;
  if (v17 == 1)
    abort();
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a4, (uint64_t (**)(_QWORD, _QWORD *))v16, (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56), (uint64_t)&v17, (uint64_t (**)(_QWORD, _QWORD *))(a1 + 144), a5, a6, _S0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21[2];

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(int32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip((uint64_t)&a1[8], (size_t)&a1[7], a2);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds((uint64_t)&a1[7], v18);
  RB::Bounds::Bounds(v21, v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 18, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  const RB::AffineTransform *v13;
  unsigned __int8 v14;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 20983809)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
        && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
        && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
        && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
        && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
        && *(float *)(a1 + 136) == *(float *)(a4 + 136))
      {
        result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
        if ((_BYTE)result)
        {
          v14 = result;
          can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 144), (const RB::Fill::MeshGradient *)(a4 + 144), v13);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v14, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  double v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  _OWORD v26[3];
  __int128 v27;
  __int128 v28;
  __int128 v29;
  _OWORD v30[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v30[0] = v10;
  v30[1] = v11;
  v30[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v30);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 144), v14, v13);
  *(double *)&v15 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v27 = v15;
  v28 = v16;
  v29 = v17;
  *(double *)&v18 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v26[0] = v18;
  v26[1] = v19;
  v26[2] = v20;
  LODWORD(v18) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v27, (uint64_t)v26, *(_QWORD *)(v8 + 48), *(CGFloat *)&v18);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v27 = off_24C223B28;
    *((_QWORD *)&v27 + 1) = v13;
    *(_QWORD *)&v28 = v8;
    *((_QWORD *)&v28 + 1) = v8 + 144;
    v29 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(_QWORD, __int128 *))&v27);
    if (*((_QWORD *)&v29 + 1))
    {
      *(_QWORD *)v8 = off_24C2238C8;
      v21 = *(unsigned int **)(v8 + 152);
      if (v21)
      {
        v22 = v21 + 2;
        do
        {
          v23 = __ldxr(v22);
          v24 = v23 - 1;
        }
        while (__stlxr(v24, v22));
        if (!v24)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v21 + 8))(v21);
        }
      }
      *(_QWORD *)(v8 + 56) = off_24C229920;
      RBPathRelease(*(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72));
      v8 = *((_QWORD *)&v29 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 18));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::MeshGradient>(this, (RB::Fill::MeshGradient *)(a1 + 18));
  RB::SexpString::pop(this);
}

_QWORD *RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(RB::Encoder *a1, uint64_t a2, RB::Fill::MeshGradient *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x2AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::MeshGradient::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::MeshGradient>(std::string *a1, RB::Fill::MeshGradient *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Fill::MeshGradient::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B30738(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 192 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xC0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 192;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C223310;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  uint64_t v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C223580;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(a1 + 64) = v18;
  v19 = *(__int128 **)(a3 + 16);
  if (v19)
  {
    v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3])
      v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v20 + 3);
    v21 = *v19;
    v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *v20 = v21;
  }
  else
  {
    v20 = 0;
  }
  *(_QWORD *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::MeshGradient::MeshGradient(a1 + 88, a4, a7, (RB::Heap *)a2);
  return a1;
}

void sub_209B30904(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C223580;
  v2 = (unsigned int *)a1[12];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C223580;
  v2 = (unsigned int *)a1[12];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::type_id()
{
  return 20979713;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::MeshGradient>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  RB::Heap *v5;
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  _QWORD v10[5];
  uint64_t v11;

  v4 = 0;
  v5 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = off_24C223B28;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 88;
  v10[4] = *(_QWORD *)(a1 + 48);
  v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 88, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;
  RBPath v4;

  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.info = (void *)(a1 + 56);
  v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 88), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::MeshGradient::append_color_matrix(a1 + 88, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 128);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::bounds(uint64_t a1)
{
  RBPath v2;

  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result;

  result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  float64x2_t v12;
  _OWORD v19[3];
  _BYTE v20[8];
  uint64_t v21;
  void *v22;
  char v23;
  int32x2_t *v24[6];

  v24[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  v11 = *(_OWORD *)(v9 + 16);
  v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 88, (uint64_t)v19, a5, a6, _S0);
  if (v23)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  if (v22)
    free(v22);
}

void sub_209B30DE4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47)
    free(a47);
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  _OWORD v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21[2];
  RBPath v22;

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(int32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0], *(int32x2_t *)((char *)v18 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)&a1[7], (CGContextRef *)a2);
  v18[0] = xmmword_209BD5290;
  v18[1] = xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v22.callbacks = (RBPathCallbacks *)v18;
  v22.info = &a1[7];
  v16 = RB::Coverage::Path::bounds(v22);
  RB::Bounds::Bounds(v21, *(float32x2_t *)&v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 11, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 88), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 20979713)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 11), (const RB::Fill::MeshGradient *)(a4 + 11), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  double v14;
  float64x2_t v15;
  __int128 v16;
  __int128 v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  unsigned int *v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  float64x2_t v26[3];
  float64x2_t v27;
  __int128 v28;
  __int128 v29;
  _OWORD v30[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v30[0] = v10;
  v30[1] = v11;
  v30[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v30);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 88), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 88), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v27 = v15;
  v28 = v16;
  v29 = v17;
  v18.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v26[0] = v18;
  v26[1] = v19;
  v26[2] = v20;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v27, v26, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v27.f64[0] = off_24C223B28;
    *(_QWORD *)&v27.f64[1] = v13;
    *(_QWORD *)&v28 = v8;
    *((_QWORD *)&v28 + 1) = v8 + 88;
    v29 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v27);
    if (*((_QWORD *)&v29 + 1))
    {
      *(_QWORD *)v8 = off_24C223580;
      v21 = *(unsigned int **)(v8 + 96);
      if (v21)
      {
        v22 = v21 + 2;
        do
        {
          v23 = __ldxr(v22);
          v24 = v23 - 1;
        }
        while (__stlxr(v24, v22));
        if (!v24)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v21 + 8))(v21);
        }
      }
      RBPathRelease(*(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64));
      v8 = *((_QWORD *)&v29 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 88));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::MeshGradient>(this, (RB::Fill::MeshGradient *)(a1 + 11));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 136 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x88uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 136;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C222FC8;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 184 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xB8uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 184;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C224BD0;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(const RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12587009;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (__int128 *)(a1 + 64), (RB::ImageTexture *)(a1 + 112), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(_QWORD *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::copy_shadow(__n128 *this, uint64_t a2, uint64_t a3)
{
  __n128 result;
  float64x2_t *v7;
  float64x2_t *v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t *v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  __n128 *v23;
  float64x2_t v24[3];
  __int128 v25[2];
  int v26;
  _QWORD v27[3];
  float v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;

  if ((*(_BYTE *)(a3 + 88) & 0x10) == 0)
  {
    if (this[7].n128_u8[12])
    {
      v28 = 1.0;
      if ((RB::DisplayList::Item::clip_affects_blurred_bounds((RB::DisplayList::Item *)this, *(float *)(a3 + 64)) & 1) == 0)
      {
        memset(v25, 0, sizeof(v25));
        v26 = 1065353216;
        v27[0] = 0;
        *(_DWORD *)((char *)v27 + 7) = 0;
        v7 = *(float64x2_t **)(a3 + 16);
        v8 = (float64x2_t *)this[3].n128_u64[0];
        v9 = *v8;
        v10 = v8[2];
        v30 = v8[1];
        v31 = v10;
        v29 = v9;
        if (RB::AffineTransform::invert((RB::AffineTransform *)&v29))
          v11 = &v29;
        else
          v11 = v8;
        v12 = v11[1];
        v13 = v11[2];
        v24[0] = *v11;
        v24[1] = v12;
        v24[2] = v13;
        v14.f64[0] = RB::operator*(v7, v24);
        v29 = v14;
        v30 = v15;
        v31 = v16;
        if (RB::Coverage::Primitive::make_shadow((RB::Coverage::Primitive *)&this[4], &v29, *(float *)(a3 + 64), &v28, (*(_DWORD *)(a3 + 88) >> 2) & 1, (RB::Coverage::Primitive *)v25))
        {
          _H1 = this[2].n128_u16[6];
          __asm { FCVT            S1, H1 }
          RB::DisplayList::ShadowStyle::make_primitive(a3, a2, v25, this[3].n128_i64[0], this[2].n128_u16[7] & 0x3F, v28, _S1);
          result = this[1];
          v23[1] = result;
          v23[2].n128_u64[0] = this[2].n128_u64[0];
          v23[2].n128_u32[2] = this[2].n128_u32[2];
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, int8x16_t a5)
{
  size_t *v7;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  __int32 v19;
  int v20;

  v20 = a3;
  if (!*(_BYTE *)(a1 + 124))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, *(float *)a5.i32);
  v7 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H1 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S1, H1 }
  *(float *)a5.i32 = _S1 * *(float *)a5.i32;
  v19 = a5.i32[0];
  v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Primitive>,RB::Heap&,RB::Coverage::Primitive const&,float const&,RB::ClipMode &,RB::AffineTransform const*&>(v7, a5, (uint64_t)v7, (_OWORD *)(a1 + 64), (unsigned __int32 *)&v19, &v20, (uint64_t *)(a1 + 48));
  v15 = a4[5];
  v16 = v15 + 1;
  if (a4[6] < (unint64_t)(v15 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
    v15 = a4[5];
    v16 = v15 + 1;
  }
  v17 = (_QWORD *)a4[4];
  if (!v17)
    v17 = a4;
  v17[v15] = v14;
  a4[5] = v16;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 128, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 128, a2, a3);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
  RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 128), *(const RB::AffineTransform **)(a1 + 48));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::render(float32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  int8x16_t v16;
  int32x4_t v17;
  float32x2_t v18;
  float32x2_t v19;
  uint16x4_t v20;
  RB *v21;
  float64x2_t v22[2];
  uint64_t v23;
  uint64_t v24;
  uint16x4_t v25;

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(float32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v22, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v22[0].f64[0], *(int32x2_t *)&v22[0].f64[1]))
    {
      v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11)
        goto LABEL_11;
    }
    else
    {
      v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v22, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v22[0] = (float64x2_t)xmmword_209BD5290;
  v22[1] = (float64x2_t)xmmword_209BD52A0;
  v23 = 0;
  v24 = 0;
  v18 = RB::Coverage::Primitive::bounds(a1 + 8, v22, (int8x16_t)xmmword_209BD5290, 0.0, v16, v17);
  RB::Bounds::Bounds((int32x2_t *)&v25, v18, v19);
  v20 = v25;
  v21 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)&a1[14]);
  if (v21)
    RB::Fill::ImageData::fill(&a1[16], a2, v21, v20);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 128), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 128), a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;
  unsigned __int8 v14;
  unsigned int v15;
  unsigned __int8 v16;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 12587009)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Primitive::can_mix(a1 + 64, (uint64_t)a3, a4 + 64);
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 112), (const RB::ImageTexture *)(a4 + 112));
          if (can_mix)
          {
            v14 = can_mix;
            v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 128), (float32x2_t *)(a4 + 128));
            if (v15 >= v14)
              v16 = v14;
            else
              v16 = v15;
          }
          else
          {
            v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  _OWORD v15[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::ImageData::mix((RB::Fill::ImageData *)(v8 + 128), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::ImageData *)(a3 + 128), v13);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 112), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)&a1[7]);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 8));
  RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(this, (uint64_t)(a1 + 14));
  RB::SexpString::pop(this);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, __int128 *a3, RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;

  v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 208 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0xD0uLL, 15);
  else
    a1[2] = v13 + 208;
  v14 = *a5;
  v15 = *a6;
  v16 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C2274F0;
  *(_QWORD *)(v13 + 48) = v14;
  v17 = *a3;
  v18 = a3[1];
  *(_OWORD *)(v13 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v13 + 64) = v17;
  *(_OWORD *)(v13 + 80) = v18;
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(v13 + 112), a4, a2);
  v19 = *((_OWORD *)a4 + 2);
  v20 = *((_OWORD *)a4 + 3);
  v21 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(v13 + 192) = *((_OWORD *)a4 + 5);
  v22 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(v13 + 160) = v20;
  *(_OWORD *)(v13 + 176) = v21;
  *(_OWORD *)(v13 + 128) = v22;
  *(_OWORD *)(v13 + 144) = v19;
  if (!*(_BYTE *)(v13 + 205))
    *(_WORD *)(v13 + 204) = 0;
  *(_QWORD *)v13 = &off_24C225D50;
  return v13;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Image<RB::ImageTexture>>::visit_<RB::Coverage::Primitive>(_QWORD *a1, __int128 *a2)
{
  RB::ImageTexture *v3;
  uint64_t *v4;
  size_t *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = (RB::ImageTexture *)a1[3];
  v4 = a1 + 4;
  v5 = (size_t *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (RB::Heap *)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Image<RB::ImageTexture>>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(_QWORD *a1, uint64_t a2)
{
  const RB::ImageTexture *v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = (const RB::ImageTexture *)a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 240 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xF0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 240;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C2258F0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C227090;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(a1 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(a1 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 144), a4, a2);
  v18 = *((_OWORD *)a4 + 2);
  v19 = *((_OWORD *)a4 + 3);
  v20 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 224) = *((_OWORD *)a4 + 5);
  v21 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 192) = v19;
  *(_OWORD *)(a1 + 208) = v20;
  *(_OWORD *)(a1 + 160) = v21;
  *(_OWORD *)(a1 + 176) = v18;
  if (!*(_BYTE *)(a1 + 237))
    *(_WORD *)(a1 + 236) = a7;
  return a1;
}

void sub_209B321A4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C227090;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C227090;
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12595201;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  uint64_t (**v5)(_QWORD, __int128 *);
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  uint64_t (**v10[5])(_QWORD, __int128 *);
  uint64_t v11;

  v4 = 0;
  v5 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223B68;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
  v10[3] = (uint64_t (**)(_QWORD, __int128 *))(a1 + 144);
  v10[4] = *(uint64_t (***)(_QWORD, __int128 *))(a1 + 48);
  v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (RB::Heap *)v5, a1 + 56, (const RB::ImageTexture *)(a1 + 144), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v7;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  float v19;
  int v20;

  v20 = a3;
  if (!*(_BYTE *)(a1 + 156))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v7 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H1 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S1, H1 }
  v19 = _S1 * a5;
  v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)&v19, &v20, (uint64_t *)(a1 + 48));
  v15 = a4[5];
  v16 = v15 + 1;
  if (a4[6] < (unint64_t)(v15 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
    v15 = a4[5];
    v16 = v15 + 1;
  }
  v17 = (_QWORD *)a4[4];
  if (!v17)
    v17 = a4;
  v17[v15] = v14;
  a4[5] = v16;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 160, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 160, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 157);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
  RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 160), *(const RB::AffineTransform **)(a1 + 48));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 144, a2, (const RB::Fill::ImageData *)(a1 + 160), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, __int32 a5, int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  __n128 (***v15)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  float64x2_t v21[3];
  uint64_t (*v22)(_QWORD, _QWORD *);
  float32x2_t v23[10];
  int v24;
  __int16 v25;
  int v26;
  char v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;

  v6 = *(float64x2_t **)(a1 + 48);
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  v9 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v21[0] = *v6;
  v21[1] = v8;
  v21[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  v24 = *(unsigned __int8 *)(a1 + 128);
  v25 = *(_WORD *)(a1 + 129);
  v26 = *(unsigned __int8 *)(a1 + 131);
  v27 = *(_BYTE *)(a1 + 132);
  v28 = *(_DWORD *)(a1 + 136);
  v29 = 1065353216;
  v30 = 1;
  v31 = 0;
  if (v24 == 1)
    abort();
  v15 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 144, v23, (uint64_t ***)a4, v21, _S0);
  RB::render_stroke(a4, v21, v15, (uint64_t)&v24, &v22, a1 + 160, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(_BYTE *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  uint16x4_t v18;
  RB *v19;
  float64x2_t v20[2];
  uint64_t v21;
  uint64_t v22;
  uint16x4_t v23;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11)
        goto LABEL_11;
    }
    else
    {
      v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v20[0] = (float64x2_t)xmmword_209BD5290;
  v20[1] = (float64x2_t)xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v20);
  RB::Bounds::Bounds((int32x2_t *)&v23, v16, v17);
  v18 = v23;
  v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 144));
  if (v19)
    RB::Fill::ImageData::fill((_QWORD *)(a1 + 160), a2, v19, v18);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 160), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 160), a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;
  unsigned __int8 v15;
  unsigned int v16;
  unsigned __int8 v17;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 12595201)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
          && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
          && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
          && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
          && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
          && *(float *)(a1 + 136) == *(float *)(a4 + 136))
        {
          result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
          if ((_BYTE)result)
          {
            v13 = result;
            can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 144), (const RB::ImageTexture *)(a4 + 144));
            if (can_mix)
            {
              v15 = can_mix;
              v16 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 160), (float32x2_t *)(a4 + 160));
              if (v16 >= v15)
                v17 = v15;
              else
                v17 = v16;
            }
            else
            {
              v17 = 0;
            }
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, v17);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB *v13;
  int8x16_t v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  _OWORD v22[3];
  __int128 v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v26[0] = v10;
  v26[1] = v11;
  v26[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v26);
  v13 = (RB *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::ImageData::mix((RB::Fill::ImageData *)(v8 + 160), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::ImageData *)(a3 + 160), v14);
  *(double *)&v15 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23 = v15;
  v24 = v16;
  v25 = v17;
  *(double *)&v18 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  v22[2] = v20;
  LODWORD(v18) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v23, (uint64_t)v22, *(_QWORD *)(v8 + 48), *(CGFloat *)&v18);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v23 = off_24C223B68;
    *((_QWORD *)&v23 + 1) = v13;
    *(_QWORD *)&v24 = v8;
    *((_QWORD *)&v24 + 1) = v8 + 144;
    v25 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(_QWORD, __int128 *))&v23);
    if (*((_QWORD *)&v25 + 1))
    {
      *(_QWORD *)v8 = off_24C227090;
      *(_QWORD *)(v8 + 56) = off_24C229920;
      RBPathRelease(*(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72));
      v8 = *((_QWORD *)&v25 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 144), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::encode(RB::DisplayList::Item *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)a1 + 56);
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)a1 + 144);
  v4 = (float64x2_t *)*((_QWORD *)a1 + 6);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode(a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(this, (uint64_t)(a1 + 18));
  RB::SexpString::pop(this);
}

_QWORD *RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(RB::Encoder *a1, uint64_t a2, uint64_t a3)
{
  int32x4_t v5;
  int32x4_t v6;

  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x1AuLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ImageTexture::encode((RB::ImageTexture *)a3, a1);
  RB::Fill::ImageData::encode((RB::Fill::ImageData *)(a3 + 16), a1, v5, v6);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(std::string *a1, uint64_t a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::ImageTexture::attributes((RB::ImageTexture *)a2, (RB::XML::Element *)v4);
  RB::Fill::ImageData::attributes((RB::Fill::ImageData *)(a2 + 16), (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B32D60(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 240 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xF0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 240;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C2258F0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  uint64_t v18;
  __int128 *v19;
  _OWORD *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C226370;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(a1 + 64) = v18;
  v19 = *(__int128 **)(a3 + 16);
  if (v19)
  {
    v20 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v20 + 3) > a2[3])
      v20 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v20 + 3);
    v21 = *v19;
    v22 = v19[2];
    v20[1] = v19[1];
    v20[2] = v22;
    *v20 = v21;
  }
  else
  {
    v20 = 0;
  }
  *(_QWORD *)(a1 + 72) = v20;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 88), a4, (RB::Heap *)a2);
  v23 = *((_OWORD *)a4 + 2);
  v24 = *((_OWORD *)a4 + 3);
  v25 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 168) = *((_OWORD *)a4 + 5);
  *(_OWORD *)(a1 + 104) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 152) = v25;
  *(_OWORD *)(a1 + 136) = v24;
  *(_OWORD *)(a1 + 120) = v23;
  if (!*(_BYTE *)(a1 + 181))
    *(_WORD *)(a1 + 180) = a7;
  return a1;
}

void sub_209B32F50(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226370;
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(_QWORD *a1)
{
  *a1 = off_24C226370;
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12591105;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  RB::Heap *v5;
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  _QWORD v10[5];
  uint64_t v11;

  v4 = 0;
  v5 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = off_24C223B68;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 88;
  v10[4] = *(_QWORD *)(a1 + 48);
  v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, (const RB::ImageTexture *)(a1 + 88), (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;
  RBPath v4;

  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.info = (void *)(a1 + 56);
  v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v7;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  float v19;
  int v20;

  v20 = a3;
  if (!*(_BYTE *)(a1 + 100))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v7 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H1 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S1, H1 }
  v19 = _S1 * a5;
  v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Path>,RB::Heap&,RB::Coverage::Path&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, v7, a1 + 56, (int *)&v19, &v20, (uint64_t *)(a1 + 48));
  v15 = a4[5];
  v16 = v15 + 1;
  if (a4[6] < (unint64_t)(v15 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
    v15 = a4[5];
    v16 = v15 + 1;
  }
  v17 = (_QWORD *)a4[4];
  if (!v17)
    v17 = a4;
  v17[v15] = v14;
  a4[5] = v16;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 104, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 104, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 101);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1)
{
  RBPath v2;

  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::min_scale(const RB::AffineTransform **a1)
{
  RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 7), a1[6]);
  RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 13), a1[6]);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 88, a2, (const RB::Fill::ImageData *)(a1 + 104), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v20[3];
  _BYTE v21[28];
  float32x2_t v22[10];
  _BYTE v23[8];
  uint64_t v24;
  void *v25;
  char v26;
  int32x2_t *v27[6];

  v27[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a4);
  v11.i64[1] = SHIDWORD(a4);
  v12 = v10[1];
  v13 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v20[0] = *v10;
  v20[1] = v12;
  v20[2] = v13;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v23, a3, (const RB::AffineTransform *)v20, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Fill::Image<RB::ImageTexture>::set_image(a1 + 88, v22, (uint64_t ***)a3, v20, _S0);
  RB::Path::Renderer::render(v27, (uint64_t)v21, a5, a6);
  *((_DWORD *)a3 + 58) = 0;
  *((_BYTE *)a3 + 236) = 0;
  if (v26)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v24);
  if (v25)
    free(v25);
}

void sub_209B33400(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,void *a61)
{
  if (a61)
    free(a61);
  _Unwind_Resume(a1);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  uint16x4_t v18;
  RB *v19;
  _OWORD v20[2];
  uint64_t v21;
  uint64_t v22;
  uint16x4_t v23;
  RBPath v24;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0], *(int32x2_t *)((char *)v20 + 8)))
    {
      v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11)
        goto LABEL_11;
    }
    else
    {
      v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v20[0] = xmmword_209BD5290;
  v20[1] = xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v24.callbacks = (RBPathCallbacks *)v20;
  v24.info = (void *)(a1 + 56);
  v16 = RB::Coverage::Path::bounds(v24);
  RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v16, v17);
  v18 = v23;
  v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 88));
  if (v19)
    RB::Fill::ImageData::fill((_QWORD *)(a1 + 104), a2, v19, v18);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 104), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 104), a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;
  unsigned __int8 v14;
  unsigned int v15;
  unsigned __int8 v16;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 12591105)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Path::can_mix((float64x2_t **)(a1 + 56), a3, (float64x2_t **)(a4 + 56));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 88), (const RB::ImageTexture *)(a4 + 88));
          if (can_mix)
          {
            v14 = can_mix;
            v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 104), (float32x2_t *)(a4 + 104));
            if (v15 >= v14)
              v16 = v14;
            else
              v16 = v15;
          }
          else
          {
            v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  float64x2_t v15;
  __int128 v16;
  __int128 v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v22[3];
  float64x2_t v23;
  __int128 v24;
  __int128 v25;
  _OWORD v26[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v26[0] = v10;
  v26[1] = v11;
  v26[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v26);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::ImageData::mix((RB::Fill::ImageData *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::ImageData *)(a3 + 104), v14);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23 = v15;
  v24 = v16;
  v25 = v17;
  v18.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  v22[2] = v20;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v23.f64[0] = off_24C223B68;
    *(_QWORD *)&v23.f64[1] = v13;
    *(_QWORD *)&v24 = v8;
    *((_QWORD *)&v24 + 1) = v8 + 88;
    v25 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v23);
    if (*((_QWORD *)&v25 + 1))
    {
      *(_QWORD *)v8 = off_24C226370;
      RBPathRelease(*(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64));
      v8 = *((_QWORD *)&v25 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 88), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, a1 + 88);
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(this, (uint64_t)(a1 + 11));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 184 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xB8uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 184;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C224BD0;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Path const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 304 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x130uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 304;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, *a6);
  *result = &off_24C224CE8;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Custom>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Path,RB::Fill::Custom>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5);
  v3[7] = result;
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7)
{
  unint64_t v12;
  uint64_t v13;
  char v15;
  __int128 v20;
  __int128 v21;

  v12 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v12 + 320 > a1[3])
    v12 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  else
    a1[2] = v12 + 320;
  v13 = *a5;
  _S0 = *a6;
  v15 = *a7;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v12 + 16) = 0;
  *(_QWORD *)(v12 + 24) = 0;
  *(_DWORD *)(v12 + 40) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  *(_WORD *)(v12 + 44) = _S0;
  *(_WORD *)(v12 + 46) = v15 & 0x3F;
  *(_QWORD *)v12 = off_24C227608;
  *(_QWORD *)(v12 + 48) = v13;
  v20 = *a3;
  v21 = a3[1];
  *(_OWORD *)(v12 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v12 + 64) = v20;
  *(_OWORD *)(v12 + 80) = v21;
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v12 + 112), a4);
  *(_QWORD *)v12 = &off_24C225E68;
  return v12;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C227608;
  v2 = (const void **)(a1 + 15);
  v3 = (const void **)a1[27];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[28])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    v3 = (const void **)a1[27];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[14];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C227608;
  v2 = (const void **)(a1 + 15);
  v3 = (const void **)a1[27];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[28])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    v3 = (const void **)a1[27];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[14];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::type_id()
{
  return 16781313;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (uint64_t)v3, (__int128 *)(a1 + 64), a1 + 112, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), &v6);
  result = *(__n128 *)(a1 + 16);
  v4[1] = result;
  v4[2].n128_u64[0] = *(_QWORD *)(a1 + 32);
  v4[2].n128_u32[2] = *(_DWORD *)(a1 + 40);
  v4[2].n128_u16[7] |= *(_WORD *)(a1 + 46) & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::atom_position(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  float32x2_t v5;
  float32x2_t v6;

  v5 = RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
  return vmla_f32(v5, (float32x2_t)0x3F0000003F000000, v6);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::copy_shadow()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>::append_blur()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::bounds(uint64_t a1, int8x16_t a2, double a3, int8x16_t a4, int32x4_t a5)
{
  return RB::Coverage::Primitive::bounds((float32x2_t *)(a1 + 64), *(float64x2_t **)(a1 + 48), a2, a3, a4, a5);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (*(unsigned __int8 *)(a1 + 108) >= 2u && *(_BYTE *)(a1 + 109) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, int a5, unsigned int a6)
{
  uint64_t v6;
  int64x2_t v7;
  float32x4_t v8;
  float32x4_t v14[3];

  v6 = *(_QWORD *)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  v8 = *(float32x4_t *)(v6 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v14[0] = *(float32x4_t *)v6;
  v14[1] = v8;
  v14[2] = (float32x4_t)_Q0;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  RB::render_primitive(a3, v14, a1 + 64, (RB::Fill::Custom *)(a1 + 112), a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::render(float32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  int8x16_t v16;
  int32x4_t v17;
  float32x2_t v18;
  float32x2_t v19;
  float64x2_t v20[2];
  uint64_t v21;
  uint64_t v22;
  int32x2_t v23;

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(float32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Primitive::clip(a1 + 8, (CGContext **)a2);
  v20[0] = (float64x2_t)xmmword_209BD5290;
  v20[1] = (float64x2_t)xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v18 = RB::Coverage::Primitive::bounds(a1 + 8, v20, (int8x16_t)xmmword_209BD5290, 0.0, v16, v17);
  RB::Bounds::Bounds(&v23, v18, v19);
  RBStrokeRef::clip(&a1[14]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 16781313)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Primitive::can_mix((uint64_t)(a1 + 8), (uint64_t)a3, (uint64_t)(a4 + 8));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 14), (const RB::Fill::Custom *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  double v14;
  double v15;
  double v16;
  int8x16_t v17;
  _OWORD v19[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v19[0] = v10;
  v19[1] = v11;
  v19[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v19);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 112), *(float32_t *)(a2 + 16), (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16), v13, v14, v15, v16, v17);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  RB::Coverage::Primitive::mix(v8 + 64, a2, a3 + 64);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::encode(float32x4_t *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Primitive>(this, 1, a1 + 4);
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)&a1[7]);
  v4 = (float64x2_t *)a1[3].i64[0];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Primitive,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Primitive>(this, (RB::Coverage::Primitive *)(a1 + 8));
  RB::XML::print_attributes<RB::Fill::Custom>(this, (RB::Fill::Custom *)(a1 + 14));
  RB::SexpString::pop(this);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, uint64_t a2, __int128 *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v12;
  uint64_t v13;
  __int16 v14;
  char v15;
  __int128 v16;
  __int128 v17;

  v12 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v12 + 320 > a1[3])
    v12 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  else
    a1[2] = v12 + 320;
  v13 = *a5;
  v14 = *a6;
  v15 = *a7;
  *(_QWORD *)(v12 + 16) = 0;
  *(_QWORD *)(v12 + 24) = 0;
  *(_DWORD *)(v12 + 40) = 0;
  *(_QWORD *)(v12 + 32) = 0;
  *(_WORD *)(v12 + 44) = v14;
  *(_WORD *)(v12 + 46) = v15 & 0x3F;
  *(_QWORD *)v12 = off_24C227608;
  *(_QWORD *)(v12 + 48) = v13;
  v16 = *a3;
  v17 = a3[1];
  *(_OWORD *)(v12 + 95) = *(__int128 *)((char *)a3 + 31);
  *(_OWORD *)(v12 + 64) = v16;
  *(_OWORD *)(v12 + 80) = v17;
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v12 + 112), a4);
  *(_QWORD *)v12 = &off_24C225E68;
  return v12;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Custom>::visit_<RB::Coverage::Primitive>(_QWORD *a1, __int128 *a2)
{
  uint64_t v3;
  uint64_t *v4;
  size_t *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (size_t *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage9PrimitiveENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

__n128 RB::DisplayList::GenericItemCopyVisitor<RB::Fill::Custom>::visit_<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(_QWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t *v4;
  RB::Heap *v5;
  uint64_t v6;
  __n128 *v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v3 = a1[3];
  v4 = a1 + 4;
  v5 = (RB::Heap *)a1[1];
  v6 = a1[2];
  v10 = *(_WORD *)(v6 + 46) & 0x3F;
  v7 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (uint64_t)v5, a2, v3, v4, (__int16 *)(v6 + 44), &v10);
  a1[5] = v7;
  v8 = (__n128 *)a1[2];
  result = v8[1];
  v7[1] = result;
  v7[2].n128_u64[0] = v8[2].n128_u64[0];
  v7[2].n128_u32[2] = v8[2].n128_u32[2];
  v7[2].n128_u16[7] |= v8[2].n128_u16[7] & 0x5800;
  return result;
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 352 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x160uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 352;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, _S0);
  *result = &off_24C225A08;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, float _S0)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C2271A8;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229920;
  RB::Coverage::StrokeablePath::StrokeablePath(a1 + 64, a3 + 8, a2);
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a3 + 56);
  *(_BYTE *)(a1 + 128) = *(_BYTE *)(a3 + 72);
  *(_WORD *)(a1 + 129) = *(_WORD *)(a3 + 73);
  *(_BYTE *)(a1 + 131) = *(_BYTE *)(a3 + 75);
  *(_BYTE *)(a1 + 132) = *(_BYTE *)(a3 + 76);
  *(_DWORD *)(a1 + 136) = *(_DWORD *)(a3 + 80);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 144), a4);
  return a1;
}

void sub_209B347F4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;

  v1[7] = v2;
  RBPathRelease(v1[8], v1[9]);
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C2271A8;
  v2 = (const void **)(a1 + 19);
  v3 = (const void **)a1[31];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[32])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[32]);
    v3 = (const void **)a1[31];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[18];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C2271A8;
  v2 = (const void **)(a1 + 19);
  v3 = (const void **)a1[31];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[32])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[32]);
    v3 = (const void **)a1[31];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[18];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  a1[7] = off_24C229920;
  RBPathRelease(a1[8], a1[9]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::type_id()
{
  return 16789505;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  uint64_t (**v5)(_QWORD, __int128 *);
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  uint64_t (**v10[5])(_QWORD, __int128 *);
  uint64_t v11;

  v4 = 0;
  v5 = (uint64_t (**)(_QWORD, __int128 *))(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223B88;
  v10[1] = v5;
  v10[2] = (uint64_t (**)(_QWORD, __int128 *))a1;
  v10[3] = (uint64_t (**)(_QWORD, __int128 *))(a1 + 144);
  v10[4] = *(uint64_t (***)(_QWORD, __int128 *))(a1 + 48);
  v11 = 0;
  RB::Coverage::StrokeablePath::simplify(a1 + 64, a1 + 56, v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeINS4_14StrokeablePathEEENS_4Fill6CustomEEEJRS0_RKS7_RKS9_RPKNS_15AffineTransformERKDF16_NS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_((RB::Heap *)v5, (uint64_t)v5, a1 + 56, a1 + 144, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::required_depth()
{
  return 0;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 128) && *(_BYTE *)(a1 + 132) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 144), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::render(uint64_t a1, int a2, uint64_t **a3, double a4, __int32 a5, int a6)
{
  uint64_t v6;
  int64x2_t v7;
  __int128 v8;
  float64x2_t v9;
  _OWORD v16[3];
  int v17;
  __int16 v18;
  int v19;
  char v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;

  v6 = *(_QWORD *)(a1 + 48);
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  v8 = *(_OWORD *)(v6 + 16);
  v9 = vaddq_f64(*(float64x2_t *)(v6 + 32), vcvtq_f64_s64(v7));
  v16[0] = *(_OWORD *)v6;
  v16[1] = v8;
  v16[2] = v9;
  _H0 = *(_WORD *)(a1 + 44);
  v17 = *(unsigned __int8 *)(a1 + 128);
  v18 = *(_WORD *)(a1 + 129);
  v19 = *(unsigned __int8 *)(a1 + 131);
  v20 = *(_BYTE *)(a1 + 132);
  v21 = *(_DWORD *)(a1 + 136);
  v22 = 1065353216;
  v23 = 1;
  v24 = 0;
  if (v17 == 1)
    abort();
  __asm { FCVT            S0, H0 }
  RB::render_stroke(a3, (uint64_t (**)(_QWORD, _QWORD *))v16, (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56), (uint64_t)&v17, (RB::Fill::Custom *)(a1 + 144), a5, a6, _S0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::StrokeablePath::clip(a1 + 64, a1 + 56, a2);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Stroke<RB::Coverage::StrokeablePath>::bounds(a1 + 56, v18);
  RB::Bounds::Bounds(&v21, v16, v17);
  RBStrokeRef::clip(a1 + 144);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 144), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 16789505)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 128) == *(unsigned __int8 *)(a4 + 128)
        && *(unsigned __int8 *)(a1 + 129) == *(unsigned __int8 *)(a4 + 129)
        && *(unsigned __int8 *)(a1 + 130) == *(unsigned __int8 *)(a4 + 130)
        && *(unsigned __int8 *)(a1 + 131) == *(unsigned __int8 *)(a4 + 131)
        && *(unsigned __int8 *)(a1 + 132) == *(unsigned __int8 *)(a4 + 132)
        && *(float *)(a1 + 136) == *(float *)(a4 + 136))
      {
        result = (unint64_t *)RB::Coverage::StrokeablePath::can_mix(a1 + 64, a4 + 64, v12);
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 144), (const RB::Fill::Custom *)(a4 + 144));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  unsigned int **v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  void *v26;
  const void **v27;
  unint64_t v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  _OWORD v34[3];
  __int128 v35;
  __int128 v36;
  __int128 v37;
  _OWORD v38[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v38[0] = v10;
  v38[1] = v11;
  v38[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v38);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14 = (unsigned int **)(v8 + 144);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 144), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 144), *(float32_t *)(a2 + 16), v13, v15, v16, v17, v18, v19);
  *(double *)&v20 = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v35 = v20;
  v36 = v21;
  v37 = v22;
  *(double *)&v23 = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v34[0] = v23;
  v34[1] = v24;
  v34[2] = v25;
  LODWORD(v23) = *(_DWORD *)(a2 + 16);
  RB::Coverage::StrokeablePath::mix(v8 + 64, v13, a3 + 64, (uint64_t)&v35, (uint64_t)v34, *(_QWORD *)(v8 + 48), *(CGFloat *)&v23);
  *(float *)(v8 + 136) = *(float *)(v8 + 136)
                       + (float)((float)(*(float *)(a3 + 136) - *(float *)(v8 + 136)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 112) = 0x100000001000000;
  *(int32x2_t *)(v8 + 120) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v35 = off_24C223B88;
    *((_QWORD *)&v35 + 1) = v13;
    *(_QWORD *)&v36 = v8;
    *((_QWORD *)&v36 + 1) = v8 + 144;
    v37 = *(unint64_t *)(v8 + 48);
    RB::Coverage::StrokeablePath::simplify(v8 + 64, v8 + 56, (uint64_t (***)(_QWORD, __int128 *))&v35);
    if (*((_QWORD *)&v37 + 1))
    {
      *(_QWORD *)v8 = off_24C2271A8;
      v26 = *(void **)(v8 + 248);
      if (v26)
        v27 = *(const void ***)(v8 + 248);
      else
        v27 = (const void **)(v8 + 152);
      if (*(_QWORD *)(v8 + 256))
      {
        v28 = 0;
        do
        {
          RB::CustomShader::Value::reset_data(v27);
          ++v28;
          v27 += 3;
        }
        while (v28 < *(_QWORD *)(v8 + 256));
        v26 = *(void **)(v8 + 248);
      }
      if (v26)
        free(v26);
      v29 = *v14;
      if (*v14)
      {
        v30 = v29 + 2;
        do
        {
          v31 = __ldxr(v30);
          v32 = v31 - 1;
        }
        while (__stlxr(v32, v30));
        if (!v32)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v29 + 8))(v29);
        }
      }
      *(_QWORD *)(v8 + 56) = off_24C229920;
      RBPathRelease(*(_QWORD *)(v8 + 64), *(_QWORD *)(v8 + 72));
      v8 = *((_QWORD *)&v37 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 18), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 18));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Custom>(this, (RB::Fill::Custom *)(a1 + 18));
  RB::SexpString::pop(this);
}

_QWORD *RB::Encoder::typed_message_field<RB::Fill::Custom>(RB::Encoder *a1, uint64_t a2, RB::Fill::Custom *a3)
{
  RB::ProtobufEncoder::encode_varint(a1, (8 * a2) | 2);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::ProtobufEncoder::encode_varint(a1, 0x22uLL);
  RB::ProtobufEncoder::begin_length_delimited(a1);
  RB::Fill::Custom::encode(a3, a1);
  RB::ProtobufEncoder::end_length_delimited(a1);
  return RB::ProtobufEncoder::end_length_delimited(a1);
}

void RB::XML::print_attributes<RB::Fill::Custom>(std::string *a1, RB::Fill::Custom *a2)
{
  uint64_t v4;
  int v5;

  v4 = operator new();
  *(_DWORD *)(v4 + 8) = 1;
  *(_QWORD *)v4 = off_24C229358;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 60) = 0u;
  RB::Fill::Custom::attributes(a2, (RB::XML::Element *)v4);
  RB::XML::Element::print((RB::XML::Element *)v4, a1, 0);
  v5 = *(_DWORD *)(v4 + 8) - 1;
  *(_DWORD *)(v4 + 8) = v5;
  if (!v5)
    (*(void (**)(uint64_t))(*(_QWORD *)v4 + 8))(v4);
}

void sub_209B35370(_Unwind_Exception *exception_object)
{
  _DWORD *v1;
  int v3;

  v3 = v1[2] - 1;
  v1[2] = v3;
  if (!v3)
    (*(void (**)(_DWORD *))(*(_QWORD *)v1 + 8))(v1);
  _Unwind_Resume(exception_object);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 352 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x160uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 352;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, *a6);
  *result = &off_24C225A08;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(uint64_t a1, size_t *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, float _S0)
{
  uint64_t v16;
  __int128 *v17;
  _OWORD *v18;
  __int128 v19;
  __int128 v20;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C226488;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = RBPathRetain(*(_QWORD *)a3, *(_QWORD *)(a3 + 8));
  *(_QWORD *)(a1 + 64) = v16;
  v17 = *(__int128 **)(a3 + 16);
  if (v17)
  {
    v18 = (_OWORD *)((a2[2] + 15) & 0xFFFFFFFFFFFFFFF0);
    if ((unint64_t)(v18 + 3) > a2[3])
      v18 = (_OWORD *)RB::Heap::alloc_slow(a2, 0x30uLL, 15);
    else
      a2[2] = (size_t)(v18 + 3);
    v19 = *v17;
    v20 = v17[2];
    v18[1] = v17[1];
    v18[2] = v20;
    *v18 = v19;
  }
  else
  {
    v18 = 0;
  }
  *(_QWORD *)(a1 + 72) = v18;
  *(_DWORD *)(a1 + 80) = *(_DWORD *)(a3 + 24);
  *(_WORD *)(a1 + 84) = *(_WORD *)(a3 + 28);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(a1 + 96), a4);
  return a1;
}

void sub_209B35538(_Unwind_Exception *a1)
{
  uint64_t v1;

  RBPathRelease(*(_QWORD *)(v1 + 56), *(_QWORD *)(v1 + 64));
  _Unwind_Resume(a1);
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C226488;
  v2 = (const void **)(a1 + 13);
  v3 = (const void **)a1[25];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[26])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[26]);
    v3 = (const void **)a1[25];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[12];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  RBPathRelease(a1[7], a1[8]);
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C226488;
  v2 = (const void **)(a1 + 13);
  v3 = (const void **)a1[25];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[26])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[26]);
    v3 = (const void **)a1[25];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[12];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  RBPathRelease(a1[7], a1[8]);
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::type_id()
{
  return 16785409;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Path,RB::Fill::Custom>::copy(uint64_t a1, uint64_t a2, char a3)
{
  __int16 v4;
  RB::Heap *v5;
  __int16 v6;
  _QWORD *result;
  __int16 v9;
  _QWORD v10[5];
  uint64_t v11;

  v4 = 0;
  v5 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = *(_WORD *)(a1 + 46);
  if ((a3 & 2) != 0)
    goto LABEL_9;
  if ((*(_WORD *)(a1 + 46) & 0x1000) != 0 || *(_BYTE *)(a2 + 272) == 0)
    goto LABEL_9;
  v10[0] = off_24C223B88;
  v10[1] = v5;
  v10[2] = a1;
  v10[3] = a1 + 96;
  v10[4] = *(_QWORD *)(a1 + 48);
  v11 = 0;
  RB::Coverage::Path::simplify(a1 + 56, (uint64_t)v10);
  result = (_QWORD *)v11;
  if (!v11)
  {
    v6 = *(_WORD *)(a1 + 46);
    v4 = 4096;
LABEL_9:
    LODWORD(v10[0]) = v6 & 0x3F;
    result = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v5, (size_t *)v5, a1 + 56, a1 + 96, (uint64_t *)(a1 + 48), (__int16 *)(a1 + 44), v10);
    *((_OWORD *)result + 1) = *(_OWORD *)(a1 + 16);
    result[4] = *(_QWORD *)(a1 + 32);
    *((_DWORD *)result + 10) = *(_DWORD *)(a1 + 40);
    v9 = *((_WORD *)result + 23) | *(_WORD *)(a1 + 46) & 0x5800;
    *((_WORD *)result + 23) = v9;
    goto LABEL_10;
  }
  v9 = *(_WORD *)(v11 + 46);
  v4 = 4096;
LABEL_10:
  *((_WORD *)result + 23) = v9 | v4;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;
  RBPath v4;

  v4.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v4.info = (void *)(a1 + 56);
  v1 = RB::Coverage::Path::bounds(v4);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::required_depth()
{
  return 0;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::bounds(uint64_t a1)
{
  RBPath v2;

  v2.callbacks = *(RBPathCallbacks **)(a1 + 48);
  v2.info = (void *)(a1 + 56);
  return RB::Coverage::Path::bounds(v2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::min_scale(uint64_t a1)
{
  float result;

  result = RB::Coverage::Path::min_scale((RB::Coverage::Path *)(a1 + 56), *(const RB::AffineTransform **)(a1 + 48));
  if (result < 0.0)
    return 0.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 96), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::render(uint64_t a1, int a2, RB::RenderPass *a3, double a4, char a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  float64x2_t v12;
  _OWORD v19[3];
  _BYTE v20[8];
  uint64_t v21;
  void *v22;
  char v23;
  int32x2_t *v24[6];

  v24[5] = *(int32x2_t **)MEMORY[0x24BDAC8D0];
  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a4);
  v10.i64[1] = SHIDWORD(a4);
  v11 = *(_OWORD *)(v9 + 16);
  v12 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v19[0] = *(_OWORD *)v9;
  v19[1] = v11;
  v19[2] = v12;
  _H8 = *(_WORD *)(a1 + 44);
  RB::Path::ImmediateRenderer::ImmediateRenderer((RB::Path::ImmediateRenderer *)v20, a3, (const RB::AffineTransform *)v19, (const RB::Coverage::Path *)(a1 + 56));
  __asm { FCVT            S0, H8 }
  RB::Path::Renderer::render(v24, a1 + 96, (uint64_t)v19, a5, a6, _S0);
  if (v23)
    RB::Path::Accumulator::commit_buffer((RB::Path::Accumulator *)&v21);
  if (v22)
    free(v22);
}

void sub_209B359BC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51)
{
  if (a47)
    free(a47);
  _Unwind_Resume(exception_object);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  _OWORD v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;
  RBPath v22;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0], *(int32x2_t *)((char *)v18 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Path::clip((RB::Coverage::Path *)(a1 + 56), (CGContextRef *)a2);
  v18[0] = xmmword_209BD5290;
  v18[1] = xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v22.callbacks = (RBPathCallbacks *)v18;
  v22.info = (void *)(a1 + 56);
  v16 = RB::Coverage::Path::bounds(v22);
  RB::Bounds::Bounds(&v21, *(float32x2_t *)&v16, v17);
  RBStrokeRef::clip(a1 + 96);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 96), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 16785409)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Path::can_mix(a1 + 7, a3, a4 + 7);
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 12), (const RB::Fill::Custom *)(a4 + 12));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  unsigned int **v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  __int128 v21;
  __int128 v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  void *v26;
  const void **v27;
  unint64_t v28;
  unsigned int *v29;
  unsigned int *v30;
  unsigned int v31;
  unsigned int v32;
  float64x2_t v34[3];
  float64x2_t v35;
  __int128 v36;
  __int128 v37;
  _OWORD v38[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v38[0] = v10;
  v38[1] = v11;
  v38[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v38);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14 = (unsigned int **)(v8 + 96);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 96), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 96), *(float32_t *)(a2 + 16), v13, v15, v16, v17, v18, v19);
  v20.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v35 = v20;
  v36 = v21;
  v37 = v22;
  v23.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v34[0] = v23;
  v34[1] = v24;
  v34[2] = v25;
  RB::Coverage::Path::mix((RBPath *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (RBPath *)(a3 + 56), &v35, v34, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
  {
    *(_QWORD *)&v35.f64[0] = off_24C223B88;
    *(_QWORD *)&v35.f64[1] = v13;
    *(_QWORD *)&v36 = v8;
    *((_QWORD *)&v36 + 1) = v8 + 96;
    v37 = *(unint64_t *)(v8 + 48);
    RB::Coverage::Path::simplify(v8 + 56, (uint64_t)&v35);
    if (*((_QWORD *)&v37 + 1))
    {
      *(_QWORD *)v8 = off_24C226488;
      v26 = *(void **)(v8 + 200);
      if (v26)
        v27 = *(const void ***)(v8 + 200);
      else
        v27 = (const void **)(v8 + 104);
      if (*(_QWORD *)(v8 + 208))
      {
        v28 = 0;
        do
        {
          RB::CustomShader::Value::reset_data(v27);
          ++v28;
          v27 += 3;
        }
        while (v28 < *(_QWORD *)(v8 + 208));
        v26 = *(void **)(v8 + 200);
      }
      if (v26)
        free(v26);
      v29 = *v14;
      if (*v14)
      {
        v30 = v29 + 2;
        do
        {
          v31 = __ldxr(v30);
          v32 = v31 - 1;
        }
        while (__stlxr(v32, v30));
        if (!v32)
        {
          __dmb(9u);
          (*(void (**)(unsigned int *))(*(_QWORD *)v29 + 8))(v29);
        }
      }
      RBPathRelease(*(_QWORD *)(v8 + 56), *(_QWORD *)(v8 + 64));
      v8 = *((_QWORD *)&v37 + 1);
    }
    *(_WORD *)(v8 + 46) |= 0x1000u;
  }
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 12), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::encode(uint64_t a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Path>(this, 1, (RBPath *)(a1 + 56));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 96));
  v4 = *(float64x2_t **)(a1 + 48);
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Path>(this, (RB::Coverage::Path *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Custom>(this, (RB::Fill::Custom *)(a1 + 12));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage4PathENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, size_t *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v15 + 304 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x130uLL, 15);
  else
    *((_QWORD *)this + 2) = v15 + 304;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Path,RB::Fill::Custom>::GenericItem1(v15, a2, a3, a4, *a5, *a7, _S0);
  *result = &off_24C224CE8;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Gradient>(uint64_t a1, uint64_t (**a2)(_QWORD, __int128 *))
{
  uint64_t (*v4)(_QWORD, __int128 *);
  _QWORD *result;
  uint64_t (**v6[3])(_QWORD, __int128 *);

  v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C226178;
    v6[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(_QWORD *)(a1 + 8) + 8, *(_QWORD *)(a1 + 8), v6);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  }
  result = (_QWORD *)*((_QWORD *)v4 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(_QWORD *)(a1 + 8), (uint64_t *)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
    *(_QWORD *)(*(_QWORD *)a1 + 56) = result;
  }
  if (*((_BYTE *)v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::MeshGradient>(uint64_t a1, uint64_t (**a2)(_QWORD, __int128 *))
{
  uint64_t (*v4)(_QWORD, __int128 *);
  _QWORD *result;
  uint64_t (**v6[3])(_QWORD, __int128 *);

  v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C223560;
    v6[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(_QWORD *)(a1 + 8) + 8, *(_QWORD *)(a1 + 8), v6);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  }
  result = (_QWORD *)*((_QWORD *)v4 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(_QWORD *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
    *(_QWORD *)(*(_QWORD *)a1 + 56) = result;
  }
  if (*((_BYTE *)v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t a1, uint64_t (**a2)(_QWORD, __int128 *))
{
  uint64_t (*v4)(_QWORD, __int128 *);
  _QWORD *result;
  uint64_t (**v6[3])(_QWORD, __int128 *);

  v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(_QWORD, __int128 *))&off_24C226138;
    v6[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(_QWORD *)(a1 + 8) + 8, *(_QWORD *)(a1 + 8), v6);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  }
  result = (_QWORD *)*((_QWORD *)v4 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(RB::Heap **)v4, *(_QWORD *)(a1 + 8), (const RB::ImageTexture *)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5, (__int16 *)v4 + 12);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
    *(_QWORD *)(*(_QWORD *)a1 + 56) = result;
  }
  if (*((_BYTE *)v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>>::operator()<RB::Fill::Custom>(uint64_t a1, uint64_t (**a2)(_QWORD, __int128 *))
{
  uint64_t (*v4)(_QWORD, __int128 *);
  _QWORD *result;
  uint64_t (**v6[3])(_QWORD, __int128 *);

  v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  if (*(_BYTE *)(*(_QWORD *)a1 + 48))
  {
    v6[0] = (uint64_t (**)(_QWORD, __int128 *))off_24C226158;
    v6[1] = (uint64_t (**)(_QWORD, __int128 *))a1;
    v6[2] = a2;
    RB::Coverage::StrokeablePath::simplify(*(_QWORD *)(a1 + 8) + 8, *(_QWORD *)(a1 + 8), v6);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
  }
  result = (_QWORD *)*((_QWORD *)v4 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v4, *(_QWORD *)v4, *(_QWORD *)(a1 + 8), (uint64_t)a2, (uint64_t *)v4 + 1, (float *)v4 + 4, (_DWORD *)v4 + 5);
    v4 = *(uint64_t (**)(_QWORD, __int128 *))a1;
    *(_QWORD *)(*(_QWORD *)a1 + 56) = result;
  }
  if (*((_BYTE *)v4 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(uint64_t **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (RB::Heap *)**v2, a2, *(RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10, (__int16 *)*v2 + 12);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, **v2, a2, *(const RB::ImageTexture **)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5, (__int16 *)*v2 + 12);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::visit(uint64_t a1, __int128 *a2)
{
  size_t ***v2;
  size_t **v3;
  unint64_t result;

  v2 = *(size_t ****)(a1 + 8);
  v3 = *v2;
  result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Primitive,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Primitive const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (int *)*v2 + 4, (_WORD *)*v2 + 10);
  v3[7] = (size_t *)result;
  return result;
}

RB::Heap *RB::DisplayList::ItemFactory::Visitor<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>::visit(uint64_t a1, uint64_t a2)
{
  RB::Heap ***v2;
  RB::Heap **v3;
  RB::Heap *result;

  v2 = *(RB::Heap ****)(a1 + 8);
  v3 = *v2;
  result = (RB::Heap *)RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RB::Coverage::StrokeablePath>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RB::Coverage::StrokeablePath> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(**v2, (uint64_t)**v2, a2, *(_QWORD *)(a1 + 16), (uint64_t *)*v2 + 1, (float *)*v2 + 4, (_DWORD *)*v2 + 5);
  v3[7] = result;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Gradient>(RB::Coverage::Glyphs **a1, uint64_t *a2)
{
  RB::Coverage::Glyphs *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

uint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::MeshGradient>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  RB::Coverage::Glyphs *v3;
  uint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Image<RB::ImageTexture>>(RB::Coverage::Glyphs **a1, const RB::ImageTexture *a2)
{
  RB::Coverage::Glyphs *v3;
  _QWORD *result;

  v3 = *a1;
  result = (_QWORD *)*((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (float *)v3 + 4, (_DWORD *)v3 + 5, (__int16 *)v3 + 12);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

unint64_t RB::DisplayList::ItemFactory::Inner<RB::Coverage::Glyphs>::operator()<RB::Fill::Custom>(RB::Coverage::Glyphs **a1, uint64_t a2)
{
  RB::Coverage::Glyphs *v3;
  unint64_t result;

  v3 = *a1;
  result = *((_QWORD *)*a1 + 7);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(size_t **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)v3 + 1, (int *)v3 + 4, (_WORD *)v3 + 10);
    v3 = *a1;
    *((_QWORD *)*a1 + 7) = result;
  }
  if (*((_BYTE *)v3 + 48))
    *(_WORD *)(result + 46) |= 0x1000u;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::type_id()
{
  return 4214785;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy(__n128 *a1, uint64_t a2)
{
  RB::Heap *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = a1[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy_atoms(uint64_t a1, uint64_t a2)
{
  __n128 *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  __n128 *v9;
  RB::Heap *v10;
  _QWORD *v11;
  int v12;
  _BYTE v13[56];
  _BYTE v14[40];
  char v15[4096];
  uint64_t v16;

  MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v16 = *MEMORY[0x24BDAC8D0];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    v10 = (RB::Heap *)(*(_QWORD *)(v8 + 8) + 16);
    v12 = v9[2].n128_u16[7] & 0x3F;
    v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ColorEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(_BYTE *)(v8 + 272))
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::copy(v2, v3);
  }
}

void sub_209B368E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2;

  v2 = vcvtq_f64_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(_QWORD *)(a1 + 48) + 32), *(float64x2_t *)*(_QWORD *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(_QWORD *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  float32x2_t v5;

  v4 = RB::Coverage::Glyphs::glyph_bounds((float32x2_t *)(a1 + 56), a2, a3);
  return RB::operator*(*(float64x2_t **)(a1 + 48), *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v13;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  float v21;
  int v22;

  v22 = a3;
  _H1 = *(_WORD *)(a1 + 118);
  __asm { FCVT            S1, H1 }
  v13 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  v21 = (float)(_S1 * a5) * _S2;
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v13, (RB::Heap *)v13, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

unsigned __int16 RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, int a3@<W2>, __int16 a4@<W3>, uint16x4_t a5@<D0>)
{
  return RB::Fill::Color::append_color_matrix((__int16 *)(a1 + 112), a2, a3, a4, a5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, uint64_t a3)
{
  RB::Heap *v4;
  uint64_t v14;
  uint64_t v15;
  __int16 v17;
  int v18;

  v18 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  _H1 = *(_WORD *)(a1 + 118);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v17 = LOWORD(_S0);
  _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, (__int128 *)(a1 + 56), a3, (uint64_t *)(a1 + 48), &v17, &v18);
  v15 = v14;
  *(_OWORD *)(v14 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v14 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v14 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v15;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Color>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  RB::Coverage::Glyphs *v2;
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  float64x2_t v6[3];

  v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::has_no_effect(_WORD *a1)
{
  _H0 = a1[22];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  _H0 = a1[59];
  __asm { FCVT            S0, H0 }
  if (_S0 <= 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 112), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::apply_transform(float16x4_t *a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  RB::Heap *v5;
  uint32x4_t v6;

  v5 = (RB::Heap *)(a3 + 16);
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)&a1[7], a2, (RB::Heap *)(a3 + 16));
  RB::Fill::Color::apply_transform(a1 + 14, a2, v5, v6);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 4214785)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 14), (const RB::Fill::Color *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v27[3];
  float64x2_t v28[3];
  _OWORD v29[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v29[0] = v10;
  v29[1] = v11;
  v29[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v29);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Color::mix((float16x4_t *)(v8 + 112), (float16x4_t *)(a3 + 112), 3, v14, v15, v16, v17, v18, v19);
  v20.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28[0] = v20;
  v28[1] = v21;
  v28[2] = v22;
  v23.f64[0] = RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 56), v28, v27, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 56));
  RB::XML::print_attributes<RB::Fill::Color>(this, (float16x4_t *)(a1 + 112));
  RB::SexpString::pop(this);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Color>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;

  v1 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

__n128 _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS5_RKS7_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(RB::Heap *this, __int128 *a2, uint64_t a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __n128 result;
  __int128 v21;
  __int128 v22;

  v12 = *((_QWORD *)this + 3);
  v13 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 176 > v12)
    v13 = RB::Heap::alloc_slow((size_t *)this, 0xB0uLL, 7);
  else
    *((_QWORD *)this + 2) = v13 + 176;
  v14 = *a4;
  v15 = *a5;
  v16 = *a6;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C226A00;
  *(_QWORD *)(v13 + 48) = v14;
  v17 = *a2;
  v18 = a2[1];
  v19 = a2[2];
  *(_QWORD *)(v13 + 104) = *((_QWORD *)a2 + 6);
  *(_OWORD *)(v13 + 88) = v19;
  *(_OWORD *)(v13 + 72) = v18;
  *(_OWORD *)(v13 + 56) = v17;
  result = *(__n128 *)a3;
  v21 = *(_OWORD *)(a3 + 16);
  v22 = *(_OWORD *)(a3 + 48);
  *(_OWORD *)(v13 + 144) = *(_OWORD *)(a3 + 32);
  *(_OWORD *)(v13 + 160) = v22;
  *(__n128 *)(v13 + 112) = result;
  *(_OWORD *)(v13 + 128) = v21;
  *(_QWORD *)v13 = &off_24C225260;
  return result;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::type_id()
{
  return 8409089;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy(__n128 *a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = a1[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t *)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy_atoms(uint64_t a1, uint64_t a2)
{
  __n128 *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  __n128 *v9;
  size_t *v10;
  unint64_t v11;
  int v12;
  _BYTE v13[56];
  _BYTE v14[40];
  char v15[4096];
  uint64_t v16;

  MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v16 = *MEMORY[0x24BDAC8D0];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    v10 = (size_t *)(*(_QWORD *)(v8 + 8) + 16);
    v12 = v9[2].n128_u16[7] & 0x3F;
    v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, (RB::Heap *)v10, (RB::Coverage::Glyphs *)v13, (uint64_t *)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *(__n128 *)(v11 + 16) = v9[1];
    *(_QWORD *)(v11 + 32) = v9[2].n128_u64[0];
    if (!*(_BYTE *)(v8 + 272))
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)(v11 + 32), v7, v5);
    *(_DWORD *)(v11 + 40) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::copy(v2, v3);
  }
}

void sub_209B37280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2;

  v2 = vcvtq_f64_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(_QWORD *)(a1 + 48) + 32), *(float64x2_t *)*(_QWORD *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(_QWORD *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  float32x2_t v5;

  v4 = RB::Coverage::Glyphs::glyph_bounds((float32x2_t *)(a1 + 56), a2, a3);
  return RB::operator*(*(float64x2_t **)(a1 + 48), *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 112), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v10, (RB::Heap *)v10, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::Gradient::append_color_matrix(a1 + 112, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  RB::Coverage::Glyphs *v2;
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  float64x2_t v6[3];

  v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 168);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::render(float32x2_t *a1, int a2, uint64_t a3, double a4, char a5, int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v14[3];

  v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a3, v14, a1 + 7, a1 + 14, a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  double v18;
  float64x2_t v19;
  float64x2_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float64x2_t v23[2];
  uint64_t v24;
  uint64_t v25;
  int32x2_t v26[2];

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v23[0] = (float64x2_t)xmmword_209BD5290;
  v23[1] = (float64x2_t)xmmword_209BD52A0;
  v24 = 0;
  v25 = 0;
  v16 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), v23, 0);
  RB::Bounds::Bounds(v26, *(float32x2_t *)&v16, v17);
  RB::Fill::Gradient::fill(a1 + 112, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 8409089)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Gradient::can_mix((RB::Fill::Gradient *)(a1 + 14), (const RB::Fill::Gradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  int8x16_t v15;
  double v16;
  double v17;
  double v18;
  int8x16_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v27[3];
  float64x2_t v28[3];
  _OWORD v29[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v29[0] = v10;
  v29[1] = v11;
  v29[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v29);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 14), v14, v13, v15, v16, v17, v18, v19);
  v20.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v28[0] = v20;
  v28[1] = v21;
  v28[2] = v22;
  v23.f64[0] = RB::operator*(a3[6], a4 + 68);
  v27[0] = v23;
  v27[1] = v24;
  v27[2] = v25;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v28, v27, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 56));
  RB::XML::print_attributes<RB::Fill::Gradient>(this, (float32x2_t *)(a1 + 112));
  RB::SexpString::pop(this);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;

  v1 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill8GradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;

  v13 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v13 + 176 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0xB0uLL, 7);
  else
    a1[2] = v13 + 176;
  v14 = *a5;
  v15 = *a6;
  v16 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C226A00;
  *(_QWORD *)(v13 + 48) = v14;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v13 + 56), a3, a2);
  RB::Fill::Gradient::Gradient((uint64_t *)(v13 + 112), a4, 0, a2);
  *(_QWORD *)v13 = &off_24C225260;
  return v13;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t *a4, uint64_t *a5, int *a6, _WORD *a7, __int16 *a8)
{
  unint64_t v15;
  uint64_t v16;
  char v18;
  __int16 v19;

  v15 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 176 > a1[3])
    v15 = RB::Heap::alloc_slow(a1, 0xB0uLL, 7);
  else
    a1[2] = v15 + 176;
  v16 = *a5;
  _S0 = *a6;
  v18 = *a7;
  v19 = *a8;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v15 + 16) = 0;
  *(_QWORD *)(v15 + 24) = 0;
  *(_DWORD *)(v15 + 40) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_WORD *)(v15 + 44) = _S0;
  *(_WORD *)(v15 + 46) = v18 & 0x3F;
  *(_QWORD *)v15 = off_24C226A00;
  *(_QWORD *)(v15 + 48) = v16;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v15 + 56), a3, a2);
  RB::Fill::Gradient::Gradient((uint64_t *)(v15 + 112), a4, v19, a2);
  *(_QWORD *)v15 = &off_24C225260;
  return v15;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 160 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 160;
  return RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  __asm { FCVT            H0, S0 }
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C223698;
  *(_QWORD *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::Fill::MeshGradient::MeshGradient(a1 + 112, a4, a7, a2);
  *(_QWORD *)a1 = &off_24C2230E0;
  return a1;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *a1 = off_24C223698;
  v2 = (unsigned int *)a1[15];
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::~GenericItem(_QWORD *a1)
{
  unsigned int *v1;
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;

  *a1 = off_24C223698;
  v1 = (unsigned int *)a1[15];
  if (v1)
  {
    v2 = v1 + 2;
    do
    {
      v3 = __ldxr(v2);
      v4 = v3 - 1;
    }
    while (__stlxr(v4, v2));
    if (!v4)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v1 + 8))(v1);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::type_id()
{
  return 20992001;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy(__n128 *a1, uint64_t a2)
{
  RB::Heap *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = a1[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy_atoms(uint64_t a1, uint64_t a2)
{
  __n128 *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  __n128 *v9;
  RB::Heap *v10;
  uint64_t v11;
  int v12;
  _BYTE v13[56];
  _BYTE v14[40];
  char v15[4096];
  uint64_t v16;

  MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v16 = *MEMORY[0x24BDAC8D0];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    v10 = (RB::Heap *)(*(_QWORD *)(v8 + 8) + 16);
    v12 = v9[2].n128_u16[7] & 0x3F;
    v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *(__n128 *)(v11 + 16) = v9[1];
    *(_QWORD *)(v11 + 32) = v9[2].n128_u64[0];
    if (!*(_BYTE *)(v8 + 272))
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)(v11 + 32), v7, v5);
    *(_DWORD *)(v11 + 40) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::copy(v2, v3);
  }
}

void sub_209B3801C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2;

  v2 = vcvtq_f64_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(_QWORD *)(a1 + 48) + 32), *(float64x2_t *)*(_QWORD *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(_QWORD *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  float32x2_t v5;

  v4 = RB::Coverage::Glyphs::glyph_bounds((float32x2_t *)(a1 + 56), a2, a3);
  return RB::operator*(*(float64x2_t **)(a1 + 48), *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 112), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v10, (RB::Heap *)v10, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::MeshGradient::append_color_matrix(a1 + 112, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  RB::Coverage::Glyphs *v2;
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  float64x2_t v6[3];

  v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 152);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::render(float32x2_t *a1, int a2, uint64_t a3, double a4, char a5, int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v14[3];

  v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a4);
  v7.i64[1] = SHIDWORD(a4);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a3, v14, a1 + 7, (uint64_t)&a1[14], a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21[2];

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), v18, 0);
  RB::Bounds::Bounds(v21, *(float32x2_t *)&v16, v17);
  RB::Fill::MeshGradient::fill((int32x2_t *)(a1 + 112), (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 20992001)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 14), (const RB::Fill::MeshGradient *)(a4 + 14), v12);
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  double v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v22[3];
  float64x2_t v23[3];
  _OWORD v24[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v24[0] = v10;
  v24[1] = v11;
  v24[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v24);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  LODWORD(v14) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 14), v14, v13);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23[0] = v15;
  v23[1] = v16;
  v23[2] = v17;
  v18.f64[0] = RB::operator*(a3[6], a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  v22[2] = v20;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::MeshGradient>(this, (RB::Fill::MeshGradient *)(a1 + 14));
  RB::SexpString::pop(this);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;

  v1 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill12MeshGradientEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 160 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xA0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 160;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  return RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::MeshGradient>::GenericItem(v15, a2, a3, a4, *a5, *a7, 0, _S0);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 208 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 208;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C225030;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;

  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  __asm { FCVT            H0, S0 }
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C2267D0;
  *(_QWORD *)(a1 + 48) = a5;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(a1 + 56), a3, a2);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 112), a4, a2);
  v17 = *((_OWORD *)a4 + 2);
  v18 = *((_OWORD *)a4 + 3);
  v19 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 192) = *((_OWORD *)a4 + 5);
  v20 = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 160) = v18;
  *(_OWORD *)(a1 + 176) = v19;
  *(_OWORD *)(a1 + 128) = v20;
  *(_OWORD *)(a1 + 144) = v17;
  if (!*(_BYTE *)(a1 + 205))
    *(_WORD *)(a1 + 204) = a7;
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::~GenericItem()
{
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12603393;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy(__n128 *a1, uint64_t a2)
{
  RB::Heap *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = a1[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (const RB::ImageTexture *)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy_atoms(uint64_t a1, uint64_t a2)
{
  __n128 *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  __n128 *v9;
  RB::Heap *v10;
  _QWORD *v11;
  int v12;
  _BYTE v13[56];
  _BYTE v14[40];
  char v15[4096];
  uint64_t v16;

  MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v16 = *MEMORY[0x24BDAC8D0];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    v10 = (RB::Heap *)(*(_QWORD *)(v8 + 8) + 16);
    v12 = v9[2].n128_u16[7] & 0x3F;
    v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, v10, (RB::Coverage::Glyphs *)v13, (const RB::ImageTexture *)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *((__n128 *)v11 + 1) = v9[1];
    v11[4] = v9[2].n128_u64[0];
    if (!*(_BYTE *)(v8 + 272))
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)v11 + 4, v7, v5);
    *((_DWORD *)v11 + 10) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::copy(v2, v3);
  }
}

void sub_209B38BEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2;

  v2 = vcvtq_f64_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(_QWORD *)(a1 + 48) + 32), *(float64x2_t *)*(_QWORD *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(_QWORD *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  float32x2_t v5;

  v4 = RB::Coverage::Glyphs::glyph_bounds((float32x2_t *)(a1 + 56), a2, a3);
  return RB::operator*(*(float64x2_t **)(a1 + 48), *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v7;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  float v19;
  int v20;

  v20 = a3;
  if (!*(_BYTE *)(a1 + 124))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v7 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H1 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S1, H1 }
  v19 = _S1 * a5;
  v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Glyphs>,RB::Heap&,RB::Coverage::Glyphs const&,float const&,RB::ClipMode const&,RB::AffineTransform const* const&>(v7, (RB::Heap *)v7, (RB::Coverage::Glyphs *)(a1 + 56), (int *)&v19, &v20, (uint64_t *)(a1 + 48));
  v15 = a4[5];
  v16 = v15 + 1;
  if (a4[6] < (unint64_t)(v15 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
    v15 = a4[5];
    v16 = v15 + 1;
  }
  v17 = (_QWORD *)a4[4];
  if (!v17)
    v17 = a4;
  v17[v15] = v14;
  a4[5] = v16;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 128, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 128, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  RB::Coverage::Glyphs *v2;
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  float64x2_t v6[3];

  v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 125);
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
  return fmaxf(RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 128), *(const RB::AffineTransform **)(a1 + 48)), 0.0);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  return RB::ImageTexture::prepare(a1 + 112, a2, (const RB::Fill::ImageData *)(a1 + 128), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  float32x2_t *v14;
  float64x2_t v19[3];
  float32x2_t v20[10];

  v10 = (float64x2_t *)a1[6];
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v19[0] = *v10;
  v19[1] = v12;
  v19[2] = _Q0;
  v14 = a1 + 7;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::Fill::Image<RB::ImageTexture>::set_image((uint64_t)&a1[14], v20, (uint64_t ***)a4, v19, *(float *)_Q0.f64);
  RB::render_glyphs(a4, v19, v14, (uint64_t)v20, (uint64_t)&a1[16], a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(_BYTE *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  uint16x4_t v18;
  RB *v19;
  float64x2_t v20[2];
  uint64_t v21;
  uint64_t v22;
  uint16x4_t v23;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11)
        goto LABEL_11;
    }
    else
    {
      v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v20[0] = (float64x2_t)xmmword_209BD5290;
  v20[1] = (float64x2_t)xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v16 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), v20, 0);
  RB::Bounds::Bounds((int32x2_t *)&v23, *(float32x2_t *)&v16, v17);
  v18 = v23;
  v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 112));
  if (v19)
    RB::Fill::ImageData::fill((_QWORD *)(a1 + 128), a2, v19, v18);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 128), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  RB::Heap *v5;
  uint32x4_t v6;

  v5 = (RB::Heap *)(a3 + 16);
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 128), a2, v5, v6);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;
  unsigned __int8 v14;
  unsigned int v15;
  unsigned __int8 v16;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 12603393)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 56), a3, (const RB::Coverage::Glyphs *)(a4 + 56));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 112), (const RB::ImageTexture *)(a4 + 112));
          if (can_mix)
          {
            v14 = can_mix;
            v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 128), (float32x2_t *)(a4 + 128));
            if (v15 >= v14)
              v16 = v14;
            else
              v16 = v15;
          }
          else
          {
            v16 = 0;
          }
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, v16);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v22[3];
  float64x2_t v23[3];
  _OWORD v24[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v24[0] = v10;
  v24[1] = v11;
  v24[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v24);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  v14.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::ImageData::mix((RB::Fill::ImageData *)(v8 + 128), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::ImageData *)(a3 + 16), v14);
  v15.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v23[0] = v15;
  v23[1] = v16;
  v23[2] = v17;
  v18.f64[0] = RB::operator*(a3[6], a4 + 68);
  v22[0] = v18;
  v22[1] = v19;
  v22[2] = v20;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v23, v22, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  RB::Coverage::Glyphs::prepare_encode(a1 + 56, a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 112), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Image<RB::ImageTexture>>(this, 2, (uint64_t)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Image<RB::ImageTexture>>(this, (uint64_t)(a1 + 14));
  RB::SexpString::pop(this);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;

  v1 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS5_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, RB::Coverage::Glyphs *a3, const RB::ImageTexture *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 208 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xD0uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 208;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C225030;
  return result;
}

unint64_t RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Glyphs const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, int *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  char v16;

  v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 320 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  else
    a1[2] = v13 + 320;
  v14 = *a5;
  _S0 = *a6;
  v16 = *a7;
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = _S0;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C2268E8;
  *(_QWORD *)(v13 + 48) = v14;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v13 + 56), a3, a2);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v13 + 112), a4);
  *(_QWORD *)v13 = &off_24C225148;
  return v13;
}

_QWORD *RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C2268E8;
  v2 = (const void **)(a1 + 15);
  v3 = (const void **)a1[27];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[28])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    v3 = (const void **)a1[27];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[14];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::~GenericItem(_QWORD *a1)
{
  const void **v2;
  const void **v3;
  const void **v4;
  unint64_t v5;
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  unsigned int v9;

  *a1 = off_24C2268E8;
  v2 = (const void **)(a1 + 15);
  v3 = (const void **)a1[27];
  if (v3)
    v4 = v3;
  else
    v4 = v2;
  if (a1[28])
  {
    v5 = 0;
    do
    {
      RB::CustomShader::Value::reset_data(v4);
      ++v5;
      v4 += 3;
    }
    while (v5 < a1[28]);
    v3 = (const void **)a1[27];
  }
  if (v3)
    free(v3);
  v6 = (unsigned int *)a1[14];
  if (v6)
  {
    v7 = v6 + 2;
    do
    {
      v8 = __ldxr(v7);
      v9 = v8 - 1;
    }
    while (__stlxr(v9, v7));
    if (!v9)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v6 + 8))(v6);
    }
  }
  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::type_id()
{
  return 16797697;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy(__n128 *a1, uint64_t a2)
{
  size_t *v3;
  __n128 *v4;
  __n128 result;
  int v6;

  v3 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  v6 = a1[2].n128_u16[7] & 0x3F;
  v4 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v3, (RB::Heap *)v3, (RB::Coverage::Glyphs *)&a1[3].n128_i8[8], (uint64_t)&a1[7], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v6);
  result = a1[1];
  v4[1] = result;
  v4[2].n128_u64[0] = a1[2].n128_u64[0];
  v4[2].n128_u32[2] = a1[2].n128_u32[2];
  v4[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_count(uint64_t a1)
{
  return *(unsigned int *)(a1 + 72);
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy_atoms(uint64_t a1, uint64_t a2)
{
  __n128 *v2;
  uint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t v8;
  __n128 *v9;
  size_t *v10;
  unint64_t v11;
  int v12;
  _BYTE v13[56];
  _BYTE v14[40];
  char v15[4096];
  uint64_t v16;

  MEMORY[0x24BDAC7A8](a1, a2);
  v5 = v4;
  v7 = v6;
  v8 = v3;
  v9 = v2;
  v16 = *MEMORY[0x24BDAC8D0];
  if (v6 || v2[4].n128_u32[2] != v4)
  {
    RB::Heap::Heap((RB::Heap *)v14, v15, 4096, 0);
    RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)v13, (const RB::Coverage::Glyphs *)&v9[3].n128_i8[8], (RB::Heap *)v14, v7, v5);
    v10 = (size_t *)(*(_QWORD *)(v8 + 8) + 16);
    v12 = v9[2].n128_u16[7] & 0x3F;
    v11 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v10, (RB::Heap *)v10, (RB::Coverage::Glyphs *)v13, (uint64_t)&v9[7], (uint64_t *)&v9[3], &v9[2].n128_i16[6], &v12);
    *(__n128 *)(v11 + 16) = v9[1];
    *(_QWORD *)(v11 + 32) = v9[2].n128_u64[0];
    if (!*(_BYTE *)(v8 + 272))
      RB::DisplayList::Contents::copy_atoms(*(RB::DisplayList::Contents **)(v8 + 8), (const RB::DisplayList::Metadata **)(v11 + 32), v7, v5);
    *(_DWORD *)(v11 + 40) = v9[2].n128_u32[2];
    RB::Heap::~Heap((RB::Heap *)v14);
  }
  else
  {
    RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::copy(v2, v3);
  }
}

void sub_209B3998C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_list va;

  va_start(va, a9);
  RB::Heap::~Heap((RB::Heap *)va);
  _Unwind_Resume(a1);
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_position(uint64_t a1, unsigned int a2)
{
  float64x2_t v2;

  v2 = vcvtq_f64_f32(*(float32x2_t *)(*(_QWORD *)(a1 + 64) + 8 * a2));
  return vcvt_f32_f64(vmlaq_laneq_f64(vmlaq_n_f64(*(float64x2_t *)(*(_QWORD *)(a1 + 48) + 32), *(float64x2_t *)*(_QWORD *)(a1 + 48), v2.f64[0]), *(float64x2_t *)(*(_QWORD *)(a1 + 48) + 16), v2, 1));
}

float32x2_t RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_bounds(uint64_t a1, unsigned int a2, int a3)
{
  double v4;
  float32x2_t v5;

  v4 = RB::Coverage::Glyphs::glyph_bounds((float32x2_t *)(a1 + 56), a2, a3);
  return RB::operator*(*(float64x2_t **)(a1 + 48), *(float32x2_t *)&v4, v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::can_append_color_matrix()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::append_alpha_gradient()
{
  return 0;
}

void RB::DisplayList::GenericItem<RB::Coverage::Glyphs,RB::Fill::Custom>::disable_subpixel_quantization(uint64_t a1, float64x2_t *a2)
{
  RB::Coverage::Glyphs *v2;
  float64x2_t v3;
  float64x2_t v4;
  int64x2_t v5;
  float64x2_t v6[3];

  v2 = (RB::Coverage::Glyphs *)(a1 + 56);
  v3.f64[0] = RB::operator*(*(float64x2_t **)(a1 + 48), a2);
  v6[0] = v3;
  v6[1] = v4;
  v6[2] = (float64x2_t)v5;
  RB::Coverage::Glyphs::disable_subpixel_quantization(v2, v6, v3.f64[0], v4.f64[0], v5);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::required_depth()
{
  return 0;
}

double RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::bounds(uint64_t a1, char a2)
{
  return RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), a2);
}

float RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::min_scale()
{
  return 0.0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare(uint64_t a1, const RB::RenderParams *a2)
{
  return RB::Fill::Custom::prepare((RB::Fill::Custom *)(a1 + 112), a2, *(const RB::AffineTransform **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::render(float32x2_t *a1, double a2, uint64_t a3, uint64_t a4, char a5, int a6)
{
  float64x2_t *v6;
  int64x2_t v7;
  float64x2_t v8;
  float64x2_t v14[3];

  v6 = (float64x2_t *)a1[6];
  v7.i64[0] = SLODWORD(a2);
  v7.i64[1] = SHIDWORD(a2);
  v8 = v6[1];
  _Q0 = vaddq_f64(v6[2], vcvtq_f64_s64(v7));
  v14[0] = *v6;
  v14[1] = v8;
  v14[2] = _Q0;
  LOWORD(_Q0.f64[0]) = a1[5].i16[2];
  __asm { FCVT            S0, H0 }
  RB::render_glyphs(a4, v14, a1 + 7, (uint64_t)&a1[14], a5, a6, *(float *)_Q0.f64);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  double v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RB::Coverage::Glyphs::clip((float32x2_t **)(a1 + 56), (RB::CGContext *)a2);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), v18, 0);
  RB::Bounds::Bounds(&v21, *(float32x2_t *)&v16, v17);
  RBStrokeRef::clip(a1 + 112);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 112), a2);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3)
{
  RB::Coverage::Glyphs::apply_transform((RB::Coverage::Glyphs *)(a1 + 56), a2, (RB::Heap *)(a3 + 16));
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare_mix(float64x2_t **a1, RB::DisplayList::Interpolator::Contents *a2, const RB::DisplayList::Interpolator::Op *a3, float64x2_t **a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(float64x2_t **))&(*a4)[1].f64[0])(a4);
  if ((_DWORD)result == 16797697)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(a1[6], a4[6], v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11)
      {
        result = (unint64_t *)RB::Coverage::Glyphs::can_mix((RB::Coverage::Glyphs *)(a1 + 7), a3, (const RB::Coverage::Glyphs *)(a4 + 7));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Custom::can_mix((RB::Fill::Custom *)(a1 + 14), (const RB::Fill::Custom *)(a4 + 14));
          return RB::DisplayList::Interpolator::Op::set_type((unint64_t *)a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::mix(CGAffineTransform **a1, uint64_t a2, float64x2_t **a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  RB::Heap *v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  float64x2_t v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v26[3];
  float64x2_t v27[3];
  _OWORD v28[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], a3[6], v9, *(float *)(a2 + 16));
  v28[0] = v10;
  v28[1] = v11;
  v28[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v28);
  v13 = (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16);
  RB::Fill::Custom::mix((RB::Fill::Custom *)(v8 + 112), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Custom *)(a3 + 14), *(float32_t *)(a2 + 16), v13, v14, v15, v16, v17, v18);
  v19.f64[0] = RB::operator*((float64x2_t *)a1[6], a4 + 68);
  v27[0] = v19;
  v27[1] = v20;
  v27[2] = v21;
  v22.f64[0] = RB::operator*(a3[6], a4 + 68);
  v26[0] = v22;
  v26[1] = v23;
  v26[2] = v24;
  RB::Coverage::Glyphs::mix((float32x2_t *)(v8 + 56), (const RB::DisplayList::Interpolator::State *)a2, (const RB::Coverage::Glyphs *)(a3 + 7), v27, v26, *(float64x2_t **)(v8 + 48), v13);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  RB::Coverage::Glyphs::prepare_encode((uint64_t)(a1 + 7), a2);
  return RB::Fill::Custom::prepare_encode((RB::Fill::Custom *)(a1 + 14), a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Glyphs>(this, 1, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Custom>(this, 2, (RB::Fill::Custom *)(a1 + 14));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Glyphs>(this, (RB::Coverage::Glyphs *)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::Custom>(this, (RB::Fill::Custom *)(a1 + 14));
  RB::SexpString::pop(this);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Glyphs,RB::Fill::Custom>::atom_position(uint64_t a1)
{
  double v1;
  float32x2_t v2;

  v1 = RB::Coverage::Glyphs::bounds((float32x2_t *)(a1 + 56), *(float64x2_t **)(a1 + 48), 0);
  return vmla_f32(*(float32x2_t *)&v1, (float32x2_t)0x3F0000003F000000, v2);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6GlyphsENS_4Fill6CustomEEEJRS0_RKS5_RKS7_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(size_t *a1, RB::Heap *a2, RB::Coverage::Glyphs *a3, uint64_t a4, uint64_t *a5, __int16 *a6, _WORD *a7)
{
  unint64_t v13;
  uint64_t v14;
  __int16 v15;
  char v16;

  v13 = (a1[2] + 15) & 0xFFFFFFFFFFFFFFF0;
  if (v13 + 320 > a1[3])
    v13 = RB::Heap::alloc_slow(a1, 0x140uLL, 15);
  else
    a1[2] = v13 + 320;
  v14 = *a5;
  v15 = *a6;
  v16 = *a7;
  *(_QWORD *)(v13 + 16) = 0;
  *(_QWORD *)(v13 + 24) = 0;
  *(_DWORD *)(v13 + 40) = 0;
  *(_QWORD *)(v13 + 32) = 0;
  *(_WORD *)(v13 + 44) = v15;
  *(_WORD *)(v13 + 46) = v16 & 0x3F;
  *(_QWORD *)v13 = off_24C2268E8;
  *(_QWORD *)(v13 + 48) = v14;
  RB::Coverage::Glyphs::Glyphs((RB::Coverage::Glyphs *)(v13 + 56), a3, a2);
  RB::Fill::Custom::Custom((RB::CustomShader::Closure *)(v13 + 112), a4);
  *(_QWORD *)v13 = &off_24C225148;
  return v13;
}

_QWORD *RBFillData::apply<RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>>(_QWORD *result, uint64_t *a2)
{
  switch(*(_DWORD *)result)
  {
    case 1:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Color>(a2, (uint64_t)(result + 2));
      break;
    case 2:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Gradient>(a2, result + 2);
      break;
    case 3:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::MeshGradient>(a2, (uint64_t)(result + 2));
      break;
    case 4:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Image<RB::ImageTexture>>(a2, (const RB::ImageTexture *)(result + 2));
      break;
    case 5:
      result = RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Custom>(a2, (uint64_t)(result + 2));
      break;
    default:
      return result;
  }
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Color>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a1;
  result = *(_QWORD **)(*a1 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(_QWORD *)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    v3 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Gradient>(uint64_t *a1, uint64_t *a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a1;
  result = *(_QWORD **)(*a1 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    v3 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::MeshGradient>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a1;
  result = *(_QWORD **)(*a1 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    v3 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Image<RB::ImageTexture>>(uint64_t *a1, const RB::ImageTexture *a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a1;
  result = *(_QWORD **)(*a1 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(RB::Heap **)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20), (__int16 *)(v3 + 24));
    v3 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::DisplayList::ItemFactory::Inner<RB::Coverage::Stroke<RBStrokeRef>>::operator()<RB::Fill::Custom>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *a1;
  result = *(_QWORD **)(*a1 + 56);
  if (!result)
  {
    result = RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Custom>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Custom const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(*(RB::Heap **)v3, *(_QWORD *)v3, a1[1], a2, (uint64_t *)(v3 + 8), (float *)(v3 + 16), (_DWORD *)(v3 + 20));
    v3 = *a1;
    *(_QWORD *)(*a1 + 56) = result;
  }
  if (*(_BYTE *)(v3 + 48))
    *((_WORD *)result + 23) |= 0x1000u;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Color const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 120 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x78uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 120;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(v17, *a6, a2, a3, a4, *a5, *a7, *a8);
  *result = &off_24C225378;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(uint64_t a1, float _S0, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, char a7, __int16 a8)
{
  __int16 v17;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a7 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C226B18;
  *(_QWORD *)(a1 + 48) = a6;
  *(_QWORD *)(a1 + 56) = off_24C229900;
  *(_QWORD *)(a1 + 64) = *(id *)(a4 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a4 + 16);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a4 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a4 + 33);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a4 + 35);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a4 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a4 + 40);
  if (*(_BYTE *)(a5 + 9))
    v17 = *(_WORD *)(a5 + 8);
  else
    v17 = a8;
  *(_QWORD *)(a1 + 104) = *(_QWORD *)a5;
  *(_WORD *)(a1 + 112) = v17;
  return a1;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226B18;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226B18;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::type_id()
{
  return 4210689;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::copy(__n128 *a1, uint64_t a2, char a3)
{
  RB::Heap *v4;
  unsigned __int16 v5;
  BOOL v6;
  __int16 v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v5 = a1[2].n128_u16[7];
  if (*(_BYTE *)(a2 + 272))
    v6 = (a3 & 2 | v5 & 0x1000) == 0;
  else
    v6 = 0;
  if (v6)
    v7 = 4096;
  else
    v7 = 0;
  v10 = v5 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v4, (uint64_t)v4, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v7;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v13;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  _QWORD *v19;
  float v21;
  int v22;

  v22 = a3;
  _H1 = *(_WORD *)(a1 + 110);
  __asm { FCVT            S1, H1 }
  v13 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H2 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S2, H2 }
  v21 = (float)(_S1 * a5) * _S2;
  v16 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v13, (uint64_t)v13, a1 + 56, (int *)&v21, &v22, (uint64_t *)(a1 + 48));
  v17 = a4[5];
  v18 = v17 + 1;
  if (a4[6] < (unint64_t)(v17 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v18);
    v17 = a4[5];
    v18 = v17 + 1;
  }
  v19 = (_QWORD *)a4[4];
  if (!v19)
    v19 = a4;
  v19[v17] = v16;
  a4[5] = v18;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::can_append_color_matrix()
{
  return 1;
}

unsigned __int16 RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::append_color_matrix@<H0>(uint64_t a1@<X0>, float16x4_t *a2@<X1>, int a3@<W2>, __int16 a4@<W3>, uint16x4_t a5@<D0>)
{
  return RB::Fill::Color::append_color_matrix((__int16 *)(a1 + 104), a2, a3, a4, a5);
}

unint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::append_alpha_gradient(uint64_t a1, uint64_t a2, __int128 *a3)
{
  size_t *v4;
  unint64_t v14;
  __int16 v16;
  int v17;

  v17 = *(_WORD *)(a1 + 46) & 0x3F;
  v4 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  _H1 = *(_WORD *)(a1 + 110);
  __asm
  {
    FCVT            S0, H0
    FCVT            S1, H1
  }
  _S0 = _S1 * _S0;
  __asm { FCVT            H0, S0 }
  v16 = LOWORD(_S0);
  v14 = _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(v4, a1 + 56, a3, (uint64_t *)(a1 + 48), &v16, &v17);
  *(_OWORD *)(v14 + 16) = *(_OWORD *)(a1 + 16);
  *(_QWORD *)(v14 + 32) = *(_QWORD *)(a1 + 32);
  *(_DWORD *)(v14 + 40) = *(_DWORD *)(a1 + 40);
  (**(void (***)(uint64_t))a1)(a1);
  return v14;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::required_depth(float16x4_t *a1)
{
  return RB::Fill::Color::required_depth(a1 + 13);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 92) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::has_no_effect(_WORD *a1)
{
  _H0 = a1[22];
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  _H0 = a1[55];
  __asm { FCVT            S0, H0 }
  if (_S0 <= 0.0)
    return RB::may_discard_alpha(a1[23] & 0x3F);
  else
    return 0;
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare(void **result, uint64_t **a2)
{
  if (*((_BYTE *)result + 88) == 1)
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, int a5, int a6)
{
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  __n128 (***v14)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  float64x2_t v24[3];
  uint64_t (*v25)(_QWORD, _QWORD *);
  __int16 v26;
  _BYTE v27[40];

  v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  v12 = v10[1];
  v13 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v24[0] = *v10;
  v24[1] = v12;
  v24[2] = v13;
  v14 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  _H8 = *(_WORD *)(a1 + 44);
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v27);
  LOWORD(v25) = *(_WORD *)(a1 + 104);
  *(_DWORD *)((char *)&v25 + 2) = *(_DWORD *)(a1 + 106);
  _H0 = *(_WORD *)(a1 + 110);
  __asm
  {
    FCVT            S1, H8
    FCVT            S0, H0
  }
  _S0 = _S0 * _S1;
  __asm { FCVT            H0, S0 }
  HIWORD(v25) = LOWORD(_S0);
  v26 = *(_WORD *)(a1 + 112);
  RB::render_stroke((uint64_t)a4, v24, v14, (uint64_t)v27, &v25, a5, a6);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  __int128 v17;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)&v17, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v17, *(int32x2_t *)((char *)&v17 + 8)))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, &v17, v14, _S8);
    return RBStrokeRef::clip(a1 + 64);
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
  return RBStrokeRef::clip(a1 + 64);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::Color::matches((RB::Fill::Color *)(a1 + 104), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::apply_transform(float16x4_t *a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::Color::apply_transform(a1 + 13, a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 4210689)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
        && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
        && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
        && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
        && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
        && *(float *)(a1 + 96) == *(float *)(a4 + 96))
      {
        result = (unint64_t *)RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a4 + 64));
        if ((_BYTE)result)
        {
          v12 = result;
          can_mix = RB::Fill::Color::can_mix((RB::Fill::Color *)(a1 + 104), (const RB::Fill::Color *)(a4 + 104));
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  _OWORD v20[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v20[0] = v10;
  v20[1] = v11;
  v20[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v20);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Color::mix((float16x4_t *)(v8 + 104), (float16x4_t *)(a3 + 104), 3, v13, v14, v15, v16, v17, v18);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Color>(this, 2, (RB::Fill::Color *)(a1 + 13));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, a1 + 56);
  RB::XML::print_attributes<RB::Fill::Color>(this, (float16x4_t *)(a1 + 104));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ColorEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 120 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x78uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 120;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Color>::GenericItem1(v15, _S0, a2, a3, a4, *a5, *a7, 0);
  *result = &off_24C225378;
  return result;
}

uint64_t RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(size_t *a1, uint64_t a2, uint64_t a3, int *a4, _DWORD *a5, uint64_t *a6)
{
  uint64_t v10;
  int v11;
  char v12;
  uint64_t v13;

  v10 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v10 + 112 > a1[3])
    v10 = RB::Heap::alloc_slow(a1, 0x70uLL, 7);
  else
    a1[2] = v10 + 112;
  v11 = *a4;
  v12 = *a5;
  v13 = *a6;
  *(_QWORD *)(v10 + 16) = 0;
  *(_QWORD *)(v10 + 24) = 0;
  *(_DWORD *)(v10 + 40) = 0;
  *(_QWORD *)(v10 + 32) = 0;
  *(_BYTE *)(v10 + 44) = v12;
  *(_BYTE *)(v10 + 45) = 0;
  *(_QWORD *)v10 = &off_24C2248F0;
  *(_QWORD *)(v10 + 48) = v13;
  *(_QWORD *)(v10 + 56) = off_24C229900;
  *(_QWORD *)(v10 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(v10 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(v10 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(v10 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(v10 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(v10 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(v10 + 96) = *(_DWORD *)(a3 + 40);
  *(_DWORD *)(v10 + 104) = v11;
  RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>::update_bounds(v10);
  return v10;
}

void sub_209B3AFBC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

unint64_t _ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS7_RKS9_RPKNS_15AffineTransformEDF16_RNS_9BlendModeEEEEPT_DpOT0_(size_t *a1, uint64_t a2, __int128 *a3, uint64_t *a4, __int16 *a5, _WORD *a6)
{
  unint64_t v11;
  uint64_t v12;
  __int16 v13;
  char v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;

  v11 = (a1[2] + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v11 + 168 > a1[3])
    v11 = RB::Heap::alloc_slow(a1, 0xA8uLL, 7);
  else
    a1[2] = v11 + 168;
  v12 = *a4;
  v13 = *a5;
  v14 = *a6;
  *(_QWORD *)(v11 + 16) = 0;
  *(_QWORD *)(v11 + 24) = 0;
  *(_DWORD *)(v11 + 40) = 0;
  *(_QWORD *)(v11 + 32) = 0;
  *(_WORD *)(v11 + 44) = v13;
  *(_WORD *)(v11 + 46) = v14 & 0x3F;
  *(_QWORD *)v11 = off_24C226E60;
  *(_QWORD *)(v11 + 48) = v12;
  *(_QWORD *)(v11 + 56) = off_24C229900;
  *(_QWORD *)(v11 + 64) = *(id *)(a2 + 8);
  v15 = *(_OWORD *)(a2 + 28);
  *(_OWORD *)(v11 + 72) = *(_OWORD *)(a2 + 16);
  *(_OWORD *)(v11 + 84) = v15;
  v16 = *a3;
  v17 = a3[1];
  v18 = a3[2];
  *(_OWORD *)(v11 + 152) = a3[3];
  *(_OWORD *)(v11 + 136) = v18;
  *(_OWORD *)(v11 + 120) = v17;
  *(_OWORD *)(v11 + 104) = v16;
  *(_QWORD *)v11 = &off_24C2256C0;
  return v11;
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226E60;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226E60;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::type_id()
{
  return 8404993;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::copy(__n128 *a1, uint64_t a2, char a3)
{
  RB::Heap *v4;
  unsigned __int16 v5;
  BOOL v6;
  __int16 v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v5 = a1[2].n128_u16[7];
  if (*(_BYTE *)(a2 + 272))
    v6 = (a3 & 2 | v5 & 0x1000) == 0;
  else
    v6 = 0;
  if (v6)
    v7 = 4096;
  else
    v7 = 0;
  v10 = v5 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v4, v4, (uint64_t)&a1[3].n128_i64[1], &a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v7;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::Gradient::get_alpha((RB::Fill::Gradient *)(a1 + 104), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, (uint64_t)v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::Gradient::append_color_matrix(a1 + 104, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 160);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 92) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare(void **result, uint64_t **a2)
{
  if (*((_BYTE *)result + 88) == 1)
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, __int32 a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  __n128 (***v13)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  float32x2_t *v14;
  _OWORD v20[3];
  _BYTE v21[40];

  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  v20[2] = _Q0;
  v13 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  v14 = (float32x2_t *)(a1 + 104);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke((uint64_t)a4, (uint64_t (**)(_QWORD, _QWORD *))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  double v18;
  float64x2_t v19;
  float64x2_t v20;
  int8x16_t v21;
  int8x16_t v22;
  float64x2_t v23[2];
  uint64_t v24;
  uint64_t v25;
  int32x2_t v26[2];

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v23, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v23[0].f64[0], *(int32x2_t *)&v23[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v23, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v23[0] = (float64x2_t)xmmword_209BD5290;
  v23[1] = (float64x2_t)xmmword_209BD52A0;
  v24 = 0;
  v25 = 0;
  v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), v23);
  RB::Bounds::Bounds(v26, v16, v17);
  RB::Fill::Gradient::fill(a1 + 104, (RB::CGContext *)a2, *(double *)v26, *(double *)&v26[1], v18, v19, v20, v21, v22);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 104), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 8404993)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
        && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
        && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
        && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
        && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
        && *(float *)(a1 + 96) == *(float *)(a4 + 96))
      {
        result = (unint64_t *)RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a4 + 64));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::Gradient::can_mix((RB::Fill::Gradient *)(a1 + 104), (const RB::Fill::Gradient *)(a4 + 104), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  int8x16_t v14;
  double v15;
  double v16;
  double v17;
  int8x16_t v18;
  _OWORD v20[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v20[0] = v10;
  v20[1] = v11;
  v20[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v20);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::Gradient::mix((RB::Fill::Gradient *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::Gradient *)(a3 + 104), v13, (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16), v14, v15, v16, v17, v18);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::Gradient>(this, 2, (RB::Fill::Gradient *)(a1 + 13));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::print(uint64_t a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, *(const RB::AffineTransform **)(a1 + 48));
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, a1 + 56);
  RB::XML::print_attributes<RB::Fill::Gradient>(this, (float32x2_t *)(a1 + 104));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill8GradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 168 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0xA8uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 168;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C2256C0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C226E60;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229900;
  *(_QWORD *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::Fill::Gradient::Gradient((uint64_t *)(a1 + 104), a4, a7, a2);
  return a1;
}

void sub_209B3BB20(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Gradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 168 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xA8uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 168;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Gradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C2256C0;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::MeshGradient const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 152 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 152;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C2231F8;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F | 0x4000;
  *(_QWORD *)a1 = off_24C2237B0;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229900;
  *(_QWORD *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::Fill::MeshGradient::MeshGradient(a1 + 104, a4, a7, a2);
  return a1;
}

void sub_209B3BD58(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::~GenericItem(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)a1 = off_24C2237B0;
  v2 = *(unsigned int **)(a1 + 112);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::~GenericItem(uint64_t a1)
{
  unsigned int *v2;
  unsigned int *v3;
  unsigned int v4;
  unsigned int v5;

  *(_QWORD *)a1 = off_24C2237B0;
  v2 = *(unsigned int **)(a1 + 112);
  if (v2)
  {
    v3 = v2 + 2;
    do
    {
      v4 = __ldxr(v3);
      v5 = v4 - 1;
    }
    while (__stlxr(v5, v3));
    if (!v5)
    {
      __dmb(9u);
      (*(void (**)(unsigned int *))(*(_QWORD *)v2 + 8))(v2);
    }
  }
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::type_id()
{
  return 20987905;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::copy(__n128 *a1, uint64_t a2, char a3)
{
  RB::Heap *v4;
  unsigned __int16 v5;
  BOOL v6;
  __int16 v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v5 = a1[2].n128_u16[7];
  if (*(_BYTE *)(a2 + 272))
    v6 = (a3 & 2 | v5 & 0x1000) == 0;
  else
    v6 = 0;
  if (v6)
    v7 = 4096;
  else
    v7 = 0;
  v10 = v5 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v4, v4, (uint64_t)&a1[3].n128_i64[1], (uint64_t)&a1[6].n128_i64[1], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v7;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::can_make_clip()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v10;
  uint64_t v17;
  uint64_t v18;
  size_t v19;
  _QWORD *v20;
  float v22;
  float v23;
  int v24;

  v23 = 0.0;
  v24 = a3;
  if (!RB::Fill::MeshGradient::get_alpha((RB::Fill::MeshGradient *)(a1 + 104), &v23))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v10 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  v22 = _S0 * (float)(a5 * v23);
  v17 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v10, (uint64_t)v10, a1 + 56, (int *)&v22, &v24, (uint64_t *)(a1 + 48));
  v18 = a4[5];
  v19 = v18 + 1;
  if (a4[6] < (unint64_t)(v18 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v19);
    v18 = a4[5];
    v19 = v18 + 1;
  }
  v20 = (_QWORD *)a4[4];
  if (!v20)
    v20 = a4;
  v20[v18] = v17;
  a4[5] = v19;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::can_append_color_matrix()
{
  return 1;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::append_color_matrix(uint64_t a1, float16x4_t *a2, uint64_t a3, __int16 a4)
{
  RB::Fill::MeshGradient::append_color_matrix(a1 + 104, a2, a3, a4);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 144);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
}

float RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::min_scale(uint64_t a1)
{
  float result;

  result = 0.0;
  if (!*(_BYTE *)(a1 + 88) && *(_BYTE *)(a1 + 92) == 1)
    return 1.0;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

void **RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare(void **result, uint64_t **a2)
{
  if (*((_BYTE *)result + 88) == 1)
    return (void **)RBStrokeRef::prepare(result + 8, a2);
  return result;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::render(uint64_t a1, double a2, uint64_t a3, uint64_t ***a4, char a5, int a6)
{
  uint64_t v9;
  int64x2_t v10;
  __int128 v11;
  __n128 (***v13)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  uint64_t (**v14)(_QWORD, _QWORD *);
  _OWORD v20[3];
  _BYTE v21[40];

  v9 = *(_QWORD *)(a1 + 48);
  v10.i64[0] = SLODWORD(a2);
  v10.i64[1] = SHIDWORD(a2);
  v11 = *(_OWORD *)(v9 + 16);
  _Q0 = vaddq_f64(*(float64x2_t *)(v9 + 32), vcvtq_f64_s64(v10));
  v20[0] = *(_OWORD *)v9;
  v20[1] = v11;
  v20[2] = _Q0;
  v13 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  v14 = (uint64_t (**)(_QWORD, _QWORD *))(a1 + 104);
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), a4, (uint64_t)v21);
  RB::render_stroke(a4, (uint64_t (**)(_QWORD, _QWORD *))v20, v13, (uint64_t)v21, v14, a5, a6, _S8);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::render(int32x2_t *a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  float64x2_t v18[2];
  uint64_t v19;
  uint64_t v20;
  int32x2_t v21[2];

  v4 = (float64x2_t *)a1[6];
  v5 = (float32x2_t *)a1[3];
  _H0 = a1[5].i16[2];
  __asm { FCVT            S8, H0 }
  v11 = a1[5].i16[3] & 0x3F;
  *(double *)&v12 = (*(double (**)(int32x2_t *, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v18, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) != v5)
    goto LABEL_10;
  if (!RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v18[0].f64[0], *(int32x2_t *)&v18[0].f64[1]))
  {
    v14 = 0;
LABEL_10:
    RB::CGContext::update_state_slow(a2, v4, v5, v11, v18, v14, _S8);
    goto LABEL_11;
  }
  v14 = 1;
  if (*(float64x2_t **)(a2 + 80) != v4)
    goto LABEL_10;
  if (*(float *)(a2 + 132) != _S8 || *(_DWORD *)(a2 + 136) != v11)
    goto LABEL_10;
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(&a1[8]);
  v18[0] = (float64x2_t)xmmword_209BD5290;
  v18[1] = (float64x2_t)xmmword_209BD52A0;
  v19 = 0;
  v20 = 0;
  v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds(&a1[7], v18);
  RB::Bounds::Bounds(v21, v16, v17);
  RB::Fill::MeshGradient::fill(a1 + 13, (int8x8_t *)a2, v21[0], v21[1]);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2)
{
  return RB::AlphaGradientEffect::matches((RB::AlphaGradientEffect *)(a1 + 104), a2);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  const RB::AffineTransform *v12;
  unsigned __int8 v13;
  unsigned __int8 can_mix;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 20987905)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      if (result >= v11)
        v11 = v11;
      else
        v11 = result;
      if (v11
        && *(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
        && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
        && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
        && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
        && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
        && *(float *)(a1 + 96) == *(float *)(a4 + 96))
      {
        result = (unint64_t *)RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a4 + 64));
        if ((_BYTE)result)
        {
          v13 = result;
          can_mix = RB::Fill::MeshGradient::can_mix((RB::Fill::MeshGradient *)(a1 + 104), (const RB::Fill::MeshGradient *)(a4 + 104), v12);
          return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v13, can_mix);
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  double v13;
  _OWORD v15[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  LODWORD(v13) = *(_DWORD *)(a2 + 16);
  RB::Fill::MeshGradient::mix((RB::Fill::MeshGradient *)(v8 + 104), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::MeshGradient *)(a3 + 104), v13, (RB::Heap *)(*(_QWORD *)(*(_QWORD *)&a4->f64[0] + 8) + 16));
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::prepare_encode(uint64_t *a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode(a1, a2);
  return RBStrokeRef::prepare_encode(a1 + 8, (uint64_t)(a1 + 7), (uint64_t *)a2);
}

_QWORD *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::encode(_QWORD *a1, RB::ProtobufEncoder *this)
{
  float64x2_t *v4;
  int64x2_t v5;

  RB::ProtobufEncoder::encode_varint(this, 0xAuLL);
  RB::ProtobufEncoder::begin_length_delimited(this);
  RB::Encoder::typed_message_field<RB::Coverage::Stroke<RBStrokeRef>>(this, 1, (uint64_t)(a1 + 7));
  RB::Encoder::typed_message_field<RB::Fill::MeshGradient>(this, 2, (RB::Fill::MeshGradient *)(a1 + 13));
  v4 = (float64x2_t *)a1[6];
  if (v4)
  {
    v5 = (int64x2_t)vandq_s8(vandq_s8((int8x16_t)vceqq_f64(v4[1], (float64x2_t)xmmword_209BD52A0), (int8x16_t)vceqq_f64(*v4, (float64x2_t)xmmword_209BD5290)), (int8x16_t)vceqzq_f64(v4[2]));
    if ((vandq_s8((int8x16_t)vdupq_laneq_s64(v5, 1), (int8x16_t)v5).u64[0] & 0x8000000000000000) == 0)
    {
      RB::ProtobufEncoder::encode_varint(this, 0x1AuLL);
      RB::ProtobufEncoder::begin_length_delimited(this);
      RB::AffineTransform::encode(v4->f64, this);
      RB::ProtobufEncoder::end_length_delimited(this);
    }
  }
  RB::ProtobufEncoder::end_length_delimited(this);
  return RB::DisplayList::Item::encode((RB::DisplayList::Item *)a1, this);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::print(const RB::AffineTransform **a1, std::string *this)
{
  RB::SexpString::push(this, "draw");
  RB::DisplayList::Item::print((RB::DisplayList::Item *)a1, this);
  RB::SexpString::print_ctm(this, a1[6]);
  RB::XML::print_attributes<RB::Coverage::Stroke<RBStrokeRef>>(this, (uint64_t)(a1 + 7));
  RB::XML::print_attributes<RB::Fill::MeshGradient>(this, (RB::Fill::MeshGradient *)(a1 + 13));
  RB::SexpString::pop(this);
}

_QWORD *_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill12MeshGradientEEEJRS0_RKS7_RKS9_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(RB::Heap *this, RB::Heap *a2, uint64_t a3, uint64_t a4, uint64_t *a5, __int16 *a6, _DWORD *a7)
{
  unint64_t v14;
  uint64_t v15;
  _QWORD *result;

  v14 = *((_QWORD *)this + 3);
  v15 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v15 + 152 > v14)
    v15 = RB::Heap::alloc_slow((size_t *)this, 0x98uLL, 7);
  else
    *((_QWORD *)this + 2) = v15 + 152;
  _H0 = *a6;
  __asm { FCVT            S0, H0 }
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::MeshGradient>::GenericItem1(v15, a2, a3, a4, *a5, *a7, 0, _S0);
  *result = &off_24C2231F8;
  return result;
}

_QWORD *RB::Heap::emplace<RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef> const&,RB::Fill::Image<RB::ImageTexture> const&,RB::AffineTransform const* const&,float const&,RB::BlendMode const&,std::optional<RB::ColorSpace> const&>(RB::Heap *this, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t *a5, float *a6, _DWORD *a7, __int16 *a8)
{
  unint64_t v16;
  uint64_t v17;
  _QWORD *result;

  v16 = *((_QWORD *)this + 3);
  v17 = (*((_QWORD *)this + 2) + 7) & 0xFFFFFFFFFFFFFFF8;
  if (v17 + 200 > v16)
    v17 = RB::Heap::alloc_slow((size_t *)this, 0xC8uLL, 7);
  else
    *((_QWORD *)this + 2) = v17 + 200;
  result = (_QWORD *)RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(v17, a2, a3, a4, *a5, *a7, *a8, *a6);
  *result = &off_24C225490;
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::GenericItem1(uint64_t a1, RB::Heap *a2, uint64_t a3, const RB::ImageTexture *a4, uint64_t a5, char a6, __int16 a7, float _S0)
{
  __int128 v18;
  __int128 v19;
  __int128 v20;

  __asm { FCVT            H0, S0 }
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = 0;
  *(_DWORD *)(a1 + 40) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_WORD *)(a1 + 44) = _H0;
  *(_WORD *)(a1 + 46) = a6 & 0x3F;
  *(_QWORD *)a1 = off_24C226C30;
  *(_QWORD *)(a1 + 48) = a5;
  *(_QWORD *)(a1 + 56) = off_24C229900;
  *(_QWORD *)(a1 + 64) = *(id *)(a3 + 8);
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a3 + 16);
  *(_BYTE *)(a1 + 88) = *(_BYTE *)(a3 + 32);
  *(_WORD *)(a1 + 89) = *(_WORD *)(a3 + 33);
  *(_BYTE *)(a1 + 91) = *(_BYTE *)(a3 + 35);
  *(_BYTE *)(a1 + 92) = *(_BYTE *)(a3 + 36);
  *(_DWORD *)(a1 + 96) = *(_DWORD *)(a3 + 40);
  RB::ImageTexture::ImageTexture((RB::ImageTexture *)(a1 + 104), a4, a2);
  v18 = *((_OWORD *)a4 + 2);
  v19 = *((_OWORD *)a4 + 3);
  v20 = *((_OWORD *)a4 + 4);
  *(_OWORD *)(a1 + 184) = *((_OWORD *)a4 + 5);
  *(_OWORD *)(a1 + 120) = *((_OWORD *)a4 + 1);
  *(_OWORD *)(a1 + 168) = v20;
  *(_OWORD *)(a1 + 152) = v19;
  *(_OWORD *)(a1 + 136) = v18;
  if (!*(_BYTE *)(a1 + 197))
    *(_WORD *)(a1 + 196) = a7;
  return a1;
}

void sub_209B3C910(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 56) = v2;

  _Unwind_Resume(a1);
}

uint64_t RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226C30;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  return a1;
}

void RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::~GenericItem(uint64_t a1)
{
  *(_QWORD *)a1 = off_24C226C30;
  *(_QWORD *)(a1 + 56) = off_24C229900;

  JUMPOUT(0x20BD16544);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::type_id()
{
  return 12599297;
}

__n128 RB::DisplayList::GenericItem<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::copy(__n128 *a1, uint64_t a2, char a3)
{
  RB::Heap *v4;
  unsigned __int16 v5;
  BOOL v6;
  __int16 v7;
  __n128 *v8;
  __n128 result;
  int v10;

  v4 = (RB::Heap *)(*(_QWORD *)(a2 + 8) + 16);
  v5 = a1[2].n128_u16[7];
  if (*(_BYTE *)(a2 + 272))
    v6 = (a3 & 2 | v5 & 0x1000) == 0;
  else
    v6 = 0;
  if (v6)
    v7 = 4096;
  else
    v7 = 0;
  v10 = v5 & 0x3F;
  v8 = (__n128 *)_ZN2RB4Heap7emplaceINS_11DisplayList11GenericItemINS_8Coverage6StrokeI11RBStrokeRefEENS_4Fill5ImageINS_12ImageTextureEEEEEJRS0_RKS7_RKSB_RKPKNS_15AffineTransformERKDF16_RKNS_9BlendModeERKNSt3__19nullopt_tEEEEPT_DpOT0_(v4, v4, (uint64_t)&a1[3].n128_i64[1], (const RB::ImageTexture *)&a1[6].n128_i8[8], (uint64_t *)&a1[3], &a1[2].n128_i16[6], &v10);
  result = a1[1];
  v8[1] = result;
  v8[2].n128_u64[0] = a1[2].n128_u64[0];
  v8[2].n128_u32[2] = a1[2].n128_u32[2];
  v8[2].n128_u16[7] |= a1[2].n128_u16[7] & 0x5800 | v7;
  return result;
}

const RB::AffineTransform *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(const RB::AffineTransform **a1, const RB::DisplayList::CachedTransform *a2, uint64_t a3)
{
  const RB::AffineTransform *result;

  RB::DisplayList::Item::apply_transform((RB::DisplayList::Item *)a1, a2, a3);
  result = (const RB::AffineTransform *)RB::DisplayList::CachedTransform::transform_ctm((float64x2_t *)a2, a1[6]);
  a1[6] = result;
  return result;
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::atom_position(uint64_t a1)
{
  float32x2_t v1;
  float32x2_t v2;

  v1 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
  return vmla_f32(v1, (float32x2_t)0x3F0000003F000000, v2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::can_make_clip()
{
  return 1;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::make_clip(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, float a5)
{
  size_t *v7;
  uint64_t v14;
  uint64_t v15;
  size_t v16;
  _QWORD *v17;
  float v19;
  int v20;

  v20 = a3;
  if (!*(_BYTE *)(a1 + 116))
    return RB::DisplayList::Item::make_clip(a1, a2, a3, a4, a5);
  v7 = (size_t *)(*(_QWORD *)(a2 + 8) + 16);
  _H1 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S1, H1 }
  v19 = _S1 * a5;
  v14 = RB::Heap::emplace<RB::DisplayList::GenericClip<RB::Coverage::Stroke<RBStrokeRef>>,RB::Heap&,RB::Coverage::Stroke<RBStrokeRef>&,float &,RB::ClipMode &,RB::AffineTransform const*&>(v7, (uint64_t)v7, a1 + 56, (int *)&v19, &v20, (uint64_t *)(a1 + 48));
  v15 = a4[5];
  v16 = v15 + 1;
  if (a4[6] < (unint64_t)(v15 + 1))
  {
    RB::vector<RB::DisplayList::Clip *,4ul,unsigned long>::reserve_slow(a4, v16);
    v15 = a4[5];
    v16 = v15 + 1;
  }
  v17 = (_QWORD *)a4[4];
  if (!v17)
    v17 = a4;
  v17[v15] = v14;
  a4[5] = v16;
  return (**(uint64_t (***)(uint64_t))a1)(a1);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::can_append_color_matrix(int a1, float16x4_t *a2, char a3, __int16 a4)
{
  return RB::Fill::ImageData::can_append_color_matrix(a1 + 120, a2, a3, a4);
}

float16x4_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::append_color_matrix(uint64_t a1, RB::ColorMatrix *a2, int a3)
{
  return RB::Fill::ImageData::append_color_matrix(a1 + 120, a2, a3);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::append_alpha_gradient()
{
  return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::required_depth(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 117);
}

float32x2_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::bounds(uint64_t a1)
{
  return RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), *(float64x2_t **)(a1 + 48));
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::min_scale(uint64_t a1)
{
  RB::Fill::ImageData::min_scale((RB::Fill::ImageData *)(a1 + 120), *(const RB::AffineTransform **)(a1 + 48));
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::has_no_effect(uint64_t a1)
{
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S0, H0 }
  if (_S0 == 0.0)
    return RB::may_discard_alpha(*(_WORD *)(a1 + 46) & 0x3F);
  else
    return 0;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare(uint64_t a1, uint64_t **a2)
{
  if (*(_BYTE *)(a1 + 88) == 1)
    RBStrokeRef::prepare((void **)(a1 + 64), a2);
  return RB::ImageTexture::prepare(a1 + 104, a2, (const RB::Fill::ImageData *)(a1 + 120), *(float64x2_t **)(a1 + 48), 0);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, double a2, uint64_t a3, uint64_t a4, __int32 a5, int a6)
{
  float64x2_t *v10;
  int64x2_t v11;
  float64x2_t v12;
  __n128 (***v14)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double);
  uint64_t v15;
  float64x2_t v21[3];
  uint64_t (*v22)(_QWORD, _QWORD *);
  float32x2_t v23[10];
  _BYTE v24[40];

  v10 = *(float64x2_t **)(a1 + 48);
  v11.i64[0] = SLODWORD(a2);
  v11.i64[1] = SHIDWORD(a2);
  v12 = v10[1];
  _Q0 = vaddq_f64(v10[2], vcvtq_f64_s64(v11));
  v21[0] = *v10;
  v21[1] = v12;
  v21[2] = _Q0;
  v14 = (__n128 (***)(_QWORD, _BYTE *, _QWORD, float64x2_t *, __n128, double, double))(a1 + 56);
  v15 = a1 + 104;
  LOWORD(_Q0.f64[0]) = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  RB::Coverage::Stroke<RBStrokeRef>::get_info((uint64_t *)(a1 + 56), (uint64_t ***)a4, (uint64_t)v24);
  RB::Fill::Image<RB::ImageTexture>::set_image(v15, v23, (uint64_t ***)a4, v21, _S8);
  RB::render_stroke(a4, v21, v14, (uint64_t)v24, &v22, a1 + 120, a5, a6);
  *(_DWORD *)(a4 + 232) = 0;
  *(_BYTE *)(a4 + 236) = 0;
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::render(uint64_t a1, uint64_t a2)
{
  float64x2_t *v4;
  float32x2_t *v5;
  unsigned int v11;
  float32x2_t v12;
  float32x2_t v13;
  int v14;
  float32x2_t v16;
  float32x2_t v17;
  uint16x4_t v18;
  RB *v19;
  float64x2_t v20[2];
  uint64_t v21;
  uint64_t v22;
  uint16x4_t v23;

  v4 = *(float64x2_t **)(a1 + 48);
  v5 = *(float32x2_t **)(a1 + 24);
  _H0 = *(_WORD *)(a1 + 44);
  __asm { FCVT            S8, H0 }
  v11 = *(_WORD *)(a1 + 46) & 0x3F;
  *(double *)&v12 = (*(double (**)(uint64_t, _QWORD))(*(_QWORD *)a1 + 144))(a1, 0);
  RB::Bounds::Bounds((int32x2_t *)v20, v12, v13);
  v14 = 0;
  if (*(float32x2_t **)(a2 + 88) == v5)
  {
    if (RB::Bounds::contains((int32x2_t *)(a2 + 96), *(int32x2_t *)&v20[0].f64[0], *(int32x2_t *)&v20[0].f64[1]))
    {
      v14 = 1;
      if (*(float64x2_t **)(a2 + 80) == v4 && *(float *)(a2 + 132) == _S8 && *(_DWORD *)(a2 + 136) == v11)
        goto LABEL_11;
    }
    else
    {
      v14 = 0;
    }
  }
  RB::CGContext::update_state_slow(a2, v4, v5, v11, v20, v14, _S8);
LABEL_11:
  RB::CGContext::save((RB::CGContext *)a2);
  RBStrokeRef::clip(a1 + 64);
  v20[0] = (float64x2_t)xmmword_209BD5290;
  v20[1] = (float64x2_t)xmmword_209BD52A0;
  v21 = 0;
  v22 = 0;
  v16 = RB::Coverage::Stroke<RBStrokeRef>::bounds((_QWORD *)(a1 + 56), v20);
  RB::Bounds::Bounds((int32x2_t *)&v23, v16, v17);
  v18 = v23;
  v19 = (RB *)RB::ImageTexture::cg_image((RB::ImageTexture *)(a1 + 104));
  if (v19)
    RB::Fill::ImageData::fill((_QWORD *)(a1 + 120), a2, v19, v18);
  RB::CGContext::restore((RB::CGContext *)a2);
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::matches(uint64_t a1, const RB::DisplayList::Predicate *a2, uint16x4_t a3)
{
  return RB::Fill::ImageData::matches((RB::Fill::ImageData *)(a1 + 120), a2, a3);
}

void RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::apply_transform(uint64_t a1, const RB::DisplayList::Transform *a2, uint64_t a3, uint32x4_t a4)
{
  RB::Fill::ImageData::apply_transform((RB::Fill::ImageData *)(a1 + 120), a2, (RB::Heap *)(a3 + 16), a4);
}

unint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare_mix(uint64_t a1, RB::DisplayList::Interpolator::Contents *a2, unint64_t *a3, uint64_t a4)
{
  unint64_t *result;
  const RB::DisplayList::Style *v9;
  const RB::AffineTransform *v10;
  int v11;
  unsigned __int8 v12;
  unsigned __int8 can_mix;
  unsigned __int8 v14;
  unsigned int v15;
  unsigned __int8 v16;

  result = (unint64_t *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)a4 + 16))(a4);
  if ((_DWORD)result == 12599297)
  {
    result = (unint64_t *)RB::DisplayList::Item::may_mix((RB::DisplayList::Item *)a1, a2, (const RB::DisplayList::Item *)a4, v9);
    if ((_BYTE)result)
    {
      LOBYTE(v11) = (_BYTE)result;
      result = (unint64_t *)RB::can_mix(*(float64x2_t **)(a1 + 48), *(float64x2_t **)(a4 + 48), v10);
      v11 = result >= v11
          ? v11
          : result;
      if (v11)
      {
        if (*(unsigned __int8 *)(a1 + 88) == *(unsigned __int8 *)(a4 + 88)
          && *(unsigned __int8 *)(a1 + 89) == *(unsigned __int8 *)(a4 + 89)
          && *(unsigned __int8 *)(a1 + 90) == *(unsigned __int8 *)(a4 + 90)
          && *(unsigned __int8 *)(a1 + 91) == *(unsigned __int8 *)(a4 + 91)
          && *(unsigned __int8 *)(a1 + 92) == *(unsigned __int8 *)(a4 + 92)
          && *(float *)(a1 + 96) == *(float *)(a4 + 96))
        {
          result = (unint64_t *)RBStrokeRef::can_mix((_QWORD *)(a1 + 64), (_QWORD *)(a4 + 64));
          if ((_BYTE)result)
          {
            v12 = result;
            can_mix = RB::ImageTexture::can_mix((RB::ImageTexture *)(a1 + 104), (const RB::ImageTexture *)(a4 + 104));
            if (can_mix)
            {
              v14 = can_mix;
              v15 = RB::Fill::ImageData::can_mix((float32x2_t *)(a1 + 120), (float32x2_t *)(a4 + 120));
              if (v15 >= v14)
                v16 = v14;
              else
                v16 = v15;
            }
            else
            {
              v16 = 0;
            }
            return RB::DisplayList::Interpolator::Op::set_type(a3, v11, v12, v16);
          }
        }
      }
    }
  }
  return result;
}

uint64_t RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::mix(CGAffineTransform **a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  uint64_t v8;
  const RB::AffineTransform *v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  int8x16_t v13;
  _OWORD v15[3];

  v8 = (*(uint64_t (**)(CGAffineTransform **, _QWORD, _QWORD, _QWORD, uint64_t))&(*a1)[1].a)(a1, *(_QWORD *)&a4->f64[0], *(unsigned int *)(*(_QWORD *)(a2 + 8) + 12), **(_QWORD **)(a2 + 8) >> 36, 2);
  RB::mix(a1[6], *(float64x2_t **)(a3 + 48), v9, *(float *)(a2 + 16));
  v15[0] = v10;
  v15[1] = v11;
  v15[2] = v12;
  *(_QWORD *)(v8 + 48) = RB::DisplayList::CachedTransform::transform_ctm(a4, (const RB::AffineTransform *)v15);
  v13.i32[0] = *(_DWORD *)(a2 + 16);
  RB::Fill::ImageData::mix((RB::Fill::ImageData *)(v8 + 120), *(const RB::DisplayList::Interpolator::Op **)(a2 + 8), (const RB::Fill::ImageData *)(a3 + 120), v13);
  RB::operator*((float64x2_t *)a1[6], a4 + 68);
  RB::operator*(*(float64x2_t **)(a3 + 48), a4 + 68);
  *(float *)(v8 + 96) = *(float *)(v8 + 96)
                      + (float)((float)(*(float *)(a3 + 96) - *(float *)(v8 + 96)) * *(float *)(a2 + 16));
  *(_QWORD *)(v8 + 72) = 0x100000001000000;
  *(int32x2_t *)(v8 + 80) = vdup_n_s32(0x7F7FFFFFu);
  if ((*(_WORD *)(v8 + 46) & 0x1000) == 0 && *(_BYTE *)(*(_QWORD *)&a4->f64[0] + 272))
    *(_WORD *)(v8 + 46) |= 0x1000u;
  return v8;
}

uint64_t *RB::DisplayList::GenericItem1<RB::Coverage::Stroke<RBStrokeRef>,RB::Fill::Image<RB::ImageTexture>>::prepare_encode(uint64_t a1, RB::Encoder *a2)
{
  RB::DisplayList::Item::prepare_encode((uint64_t *)a1, a2);
  RBStrokeRef::prepare_encode((uint64_t *)(a1 + 64), a1 + 56, (uint64_t *)a2);
  return RB::ImageTexture::prepare_encode((uint64_t **)(a1 + 104), a2);
}

