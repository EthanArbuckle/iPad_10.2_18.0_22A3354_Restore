uint64_t ARDeviceSupported()
{
  if (ARDeviceSupported_onceToken != -1)
    dispatch_once(&ARDeviceSupported_onceToken, &__block_literal_global_20);
  return ARDeviceSupported_supported;
}

ARRaycastResult *raycastResultFromNewAPI(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  unint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  unint64_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  unint64_t v18;
  int v19;
  _BOOL8 v20;
  uint64_t v21;
  int ResultOrientation;
  uint64_t v23;
  uint64_t v24;
  ARRaycastResult *v25;
  const void *v26;
  void *v27;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  double v38;
  double v40;
  double v42;
  double v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  float32x4_t v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;

  *(double *)v4.i64 = ARVisionToRenderingCoordinateTransform();
  v33 = v4;
  v35 = v5;
  v29 = v7;
  v31 = v6;
  CV3DRaycastResultTransformationToWorld();
  v8 = 0;
  v45 = v9;
  v46 = v10;
  v47 = v11;
  v48 = v12;
  do
  {
    *(float32x4_t *)((char *)&v49 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v33, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v8))), v35, *(float32x2_t *)&v45.f32[v8 / 4], 1), v31, *(float32x4_t *)((char *)&v45 + v8), 2), v29, *(float32x4_t *)((char *)&v45 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  v34 = v49;
  v36 = v50;
  v30 = v52;
  v32 = v51;
  *(double *)v13.i64 = ARRenderingToVisionCoordinateTransform();
  v14 = 0;
  v45 = v13;
  v46 = v15;
  v47 = v16;
  v48 = v17;
  do
  {
    *(float32x4_t *)((char *)&v49 + v14) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v34, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v14))), v36, *(float32x2_t *)&v45.f32[v14 / 4], 1), v32, *(float32x4_t *)((char *)&v45 + v14), 2), v30, *(float32x4_t *)((char *)&v45 + v14), 3);
    v14 += 16;
  }
  while (v14 != 64);
  v18 = 0;
  v45 = v49;
  v46 = v50;
  v47 = v51;
  v48 = v52;
  do
  {
    *(float32x4_t *)((char *)&v49 + v18) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)((char *)&v45 + v18))), a2, *(float32x2_t *)&v45.f32[v18 / 4], 1), a3, *(float32x4_t *)((char *)&v45 + v18), 2), a4, *(float32x4_t *)((char *)&v45 + v18), 3);
    v18 += 16;
  }
  while (v18 != 64);
  v42 = *(double *)v51.i64;
  v44 = *(double *)v52.i64;
  v38 = *(double *)v49.i64;
  v40 = *(double *)v50.i64;
  v19 = CV3DRaycastResultOriginatedFrom();
  v20 = CV3DRaycastResultExtentChecked() == *MEMORY[0x1E0CFC900];
  if (v19 == *MEMORY[0x1E0CFC918])
    v21 = v20;
  else
    v21 = 2;
  ResultOrientation = CV3DRaycastGetResultOrientation();
  v23 = 1;
  if (ResultOrientation != *MEMORY[0x1E0CFC910])
    v23 = 2;
  if (ResultOrientation == *MEMORY[0x1E0CFC908])
    v24 = 0;
  else
    v24 = v23;
  v25 = -[ARRaycastResult initWithWorldTransform:target:targetAlignment:]([ARRaycastResult alloc], "initWithWorldTransform:target:targetAlignment:", v21, v24, v38, v40, v42, v44);
  v26 = (const void *)CV3DRaycastResultPlaneIdentifier();
  if (v26)
  {
    objc_msgSend(MEMORY[0x1E0CB3A28], "ar_UUIDWithCFUUIDRef:", v26);
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    -[ARRaycastResult setAnchorIdentifier:](v25, "setAnchorIdentifier:", v27);
    CFRelease(v26);

  }
  return v25;
}

void sub_1B3A6A6AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id raycastResultsFromNewAPI(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, void *a6)
{
  id v6;
  void *v7;
  unint64_t i;
  void *v9;
  void *v10;
  id v11;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v6 = a6;
  v7 = (void *)objc_opt_new();
  for (i = 0; i < CV3DRayCastResultsLength(); ++i)
  {
    CV3DRayCastResultAtIndex();
    raycastResultFromNewAPI(a1, a2, a3, a4);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v7, "addObject:", v9);

  }
  if (objc_msgSend(v6, "target") == 2)
  {
    objc_msgSend(v7, "firstObject");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "setTarget:", 2);
    v17[0] = v10;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v17, 1);
    v11 = (id)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v11 = v7;
  }

  return v11;
}

void sub_1B3A6A7FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id ARRaycastResultsDictionaryFrom(const CV3DRaycastResultMap *a1, simd_float4x4 a2)
{
  void *v3;
  CFIndex i;
  const void *ValueAtIndex;
  const CV3DRaycastResultMap *v6;
  void *v7;
  uint64_t v8;
  uint64_t j;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  uint64_t v15;
  const __CFArray *theArray;

  v15 = CV3DRayCastResultMapLength();
  if (v15)
  {
    v3 = (void *)objc_opt_new();
    theArray = (const __CFArray *)MEMORY[0x1B5E2C208](a1);
    for (i = 0; i != v15; ++i)
    {
      ValueAtIndex = CFArrayGetValueAtIndex(theArray, i);
      v6 = a1;
      CV3DRayCastResultListFromId();
      objc_msgSend(MEMORY[0x1E0CB3A28], "ar_UUIDWithCFUUIDRef:", ValueAtIndex);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = CV3DRayCastResultsLength();
      if (v8)
      {
        for (j = 0; j != v8; ++j)
        {
          CV3DRayCastResultAtIndex();
          raycastResultFromNewAPI((float32x4_t)a2.columns[0], (float32x4_t)a2.columns[1], (float32x4_t)a2.columns[2], (float32x4_t)a2.columns[3]);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v3, "objectForKeyedSubscript:", v7);
          v11 = (void *)objc_claimAutoreleasedReturnValue();

          if (!v11)
          {
            v12 = (void *)objc_opt_new();
            objc_msgSend(v3, "setObject:forKeyedSubscript:", v12, v7);

          }
          objc_msgSend(v3, "objectForKeyedSubscript:", v7, v15);
          v13 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v13, "addObject:", v10);

        }
      }

      a1 = v6;
    }
    CFRelease(theArray);
  }
  else
  {
    v3 = 0;
  }
  return v3;
}

void sub_1B3A6A9CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

ARRaycastResult *ARRaycastResultFrom(CV3DHitTestResult *a1, simd_float4x4 a2)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  unint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  unint64_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  unint64_t v17;
  int v18;
  uint64_t v19;
  int var4;
  uint64_t v21;
  ARRaycastResult *v22;
  void *v23;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;

  *(double *)v3.i64 = ARVisionToRenderingCoordinateTransform();
  v29 = v3;
  v31 = v4;
  v25 = v6;
  v27 = v5;
  *(double *)v7.i64 = ARMatrix4x4MakeColumnMajorTransformFromArray((float64x2_t *)a1->var1);
  v8 = 0;
  v34 = v7;
  v35 = v9;
  v36 = v10;
  v37 = v11;
  do
  {
    *(float32x4_t *)((char *)&v38 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v29, COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v8))), v31, *(float32x2_t *)&v34.f32[v8 / 4], 1), v27, *(float32x4_t *)((char *)&v34 + v8), 2), v25, *(float32x4_t *)((char *)&v34 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  v30 = v38;
  v32 = v39;
  v26 = v41;
  v28 = v40;
  *(double *)v12.i64 = ARRenderingToVisionCoordinateTransform();
  v13 = 0;
  v34 = v12;
  v35 = v14;
  v36 = v15;
  v37 = v16;
  do
  {
    *(float32x4_t *)((char *)&v38 + v13) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v30, COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v13))), v32, *(float32x2_t *)&v34.f32[v13 / 4], 1), v28, *(float32x4_t *)((char *)&v34 + v13), 2), v26, *(float32x4_t *)((char *)&v34 + v13), 3);
    v13 += 16;
  }
  while (v13 != 64);
  v17 = 0;
  v34 = v38;
  v35 = v39;
  v36 = v40;
  v37 = v41;
  do
  {
    *(float32x4_t *)((char *)&v38 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a2.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v34 + v17))), (float32x4_t)a2.columns[1], *(float32x2_t *)&v34.f32[v17 / 4], 1), (float32x4_t)a2.columns[2], *(float32x4_t *)((char *)&v34 + v17), 2), (float32x4_t)a2.columns[3], *(float32x4_t *)((char *)&v34 + v17), 3);
    v17 += 16;
  }
  while (v17 != 64);
  if (a1->var2 == 1 && (v18 = a1->var3 - 1, v18 <= 3))
    v19 = qword_1B3BDFCF8[v18];
  else
    v19 = 2;
  var4 = a1->var4;
  if (var4 == 4)
    v21 = 2;
  else
    v21 = var4 == 2;
  v22 = -[ARRaycastResult initWithWorldTransform:target:targetAlignment:]([ARRaycastResult alloc], "initWithWorldTransform:target:targetAlignment:", v19, v21, *(double *)v38.i64, *(double *)v39.i64, *(double *)v40.i64, *(double *)v41.i64);
  if (a1->var5)
  {
    objc_msgSend(MEMORY[0x1E0CB3A28], "ar_UUIDWithCFUUIDRef:");
    v23 = (void *)objc_claimAutoreleasedReturnValue();
    -[ARRaycastResult setAnchorIdentifier:](v22, "setAnchorIdentifier:", v23);

  }
  return v22;
}

void sub_1B3A6ABEC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id raycastResultsFrom(CV3DHitTestResults *a1, ARRaycastQuery *a2, simd_float4x4 a3)
{
  ARRaycastQuery *v4;
  void *v5;
  uint64_t v6;
  unint64_t v7;
  void *v8;
  void *v9;
  id v10;
  _QWORD v13[2];

  v13[1] = *MEMORY[0x1E0C80C00];
  v4 = a2;
  v5 = (void *)objc_opt_new();
  if (a1->var1)
  {
    v6 = 0;
    v7 = 0;
    do
    {
      ARRaycastResultFrom(&a1->var0[v6], a3);
      v8 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "addObject:", v8);

      ++v7;
      ++v6;
    }
    while (v7 < a1->var1);
  }
  if (-[ARRaycastQuery target](v4, "target", *(_OWORD *)a3.columns, *(_OWORD *)&a3.columns[1], *(_OWORD *)&a3.columns[2], *(_OWORD *)&a3.columns[3]) == ARRaycastTargetEstimatedPlane)
  {
    objc_msgSend(v5, "firstObject");
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "setTarget:", 2);
    v13[0] = v9;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v13, 1);
    v10 = (id)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v10 = v5;
  }

  return v10;
}

void sub_1B3A6AD3C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t intentFrom(uint64_t a1)
{
  uint64_t v2;
  int v3;

  v2 = CV3DRaycastIntentCreate();
  if (*(_DWORD *)(a1 + 72))
    CV3DRaycastIntentEnableTracking();
  v3 = *(_DWORD *)(a1 + 76);
  if (v3 == 1 || v3 == 3)
    CV3DRaycastIntentSetConsideredGeometry();
  CV3DRaycastIntentSetConsideredOrientations();
  CV3DRaycastIntentSetExtentCheckForTrackedPlanes();
  return v2;
}

uint64_t *RaycastSession::RaycastSession(uint64_t *a1, uint64_t a2, void *a3, int a4)
{
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  _QWORD *v12;
  uint64_t v13;
  _QWORD *exception;
  uint64_t v15;
  _QWORD v16[5];
  _QWORD v17[5];
  uint64_t v18;

  v7 = a3;
  CV3DRaycastSessionConfigurationCreate();
  if (a4)
    CV3DRaycastSessionConfigurationEnableDeterministicMode();
  v18 = 0;
  *a1 = CV3DRaycastSessionCreateWithConfig();
  CV3DRaycastSessionConfigurationRelease();
  if (v18)
  {
    exception = __cxa_allocate_exception(0x10uLL);
    v15 = v18;
    *exception = &unk_1E6670440;
    exception[1] = v15;
  }
  v8 = MEMORY[0x1E0C809B0];
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v17[2] = ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke;
  v17[3] = &__block_descriptor_40_e28_v80__0____CFUUID__8____4__16l;
  v17[4] = a2;
  v9 = (void *)MEMORY[0x1B5E2DF90](v17);
  v16[0] = v8;
  v16[1] = 3221225472;
  v16[2] = ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke_5;
  v16[3] = &__block_descriptor_40_e19_v16__0____CFUUID__8l;
  v16[4] = a2;
  v10 = (void *)MEMORY[0x1B5E2DF90](v16);
  CV3DRaycastSessionSetAnchoringFunctors();
  if (v18 || (CV3DRaycastSessionRegisterOnTrackableUpdateCallback(), v18))
  {
    v12 = __cxa_allocate_exception(0x10uLL);
    v13 = v18;
    *v12 = &unk_1E6670440;
    v12[1] = v13;
  }

  return a1;
}

void sub_1B3A6B018(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke()
{
  NSObject *v0;
  uint8_t buf[4];
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if ((CV3DSLAMSessionAddAnchor() & 1) == 0)
  {
    _ARLogGeneral();
    v0 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v2 = 0;
      _os_log_impl(&dword_1B3A68000, v0, OS_LOG_TYPE_ERROR, "Error adding anchor: %@", buf, 0xCu);

    }
  }
}

id _ARLogGeneral(void)
{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_0);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_82);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_36);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_48);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_121);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_507);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_49);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_454);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_51_0);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_56);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_47_1);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_184_0);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_87);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_109);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_46_0);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_97);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_161);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_58_1);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_191_0);
  return (id)_ARLogGeneral(void)::logObj;
}

{
  if (_ARLogGeneral(void)::onceToken != -1)
    dispatch_once(&_ARLogGeneral(void)::onceToken, &__block_literal_global_8_3);
  return (id)_ARLogGeneral(void)::logObj;
}

void ___ZN14RaycastSessionC2EP15CV3DSLAMSessionU13block_pointerFvPK20CV3DRaycastResultMapEb_block_invoke_5()
{
  NSObject *v0;
  uint8_t buf[4];
  uint64_t v2;
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  if ((CV3DSLAMSessionRemoveAnchor() & 1) == 0)
  {
    _ARLogGeneral();
    v0 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v0, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v2 = 0;
      _os_log_impl(&dword_1B3A68000, v0, OS_LOG_TYPE_ERROR, "Error removing anchor: %@", buf, 0xCu);

    }
  }
}

uint64_t RaycastSession::PushDenseFrame(RaycastSession *this, __CVBuffer *a2, __CVBuffer *a3, simd_float3x3 a4, simd_float4x4 a5)
{
  CV3DRaycastDenseFrameCreate();
  CV3DRaycastPushDenseFrame();
  return CV3DRaycastDenseFrameRelease();
}

uint64_t RaycastSession::InvalidateDenseFrame(RaycastSession *this)
{
  return CV3DRaycastInvalidateDenseFrame();
}

id RaycastSession::PerformHitTest(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, uint64_t a5, uint64_t a6, void *a7)
{
  id v8;
  void *v9;
  uint64_t v10;

  v8 = a7;
  intentFrom(a6);
  v9 = (void *)MEMORY[0x1E0C9AA60];
  v10 = CV3DRaycastSessionAttemptWithIntent();
  CV3DRaycastIntentRelease();
  if (v10 && CV3DRayCastResultsLength())
  {
    raycastResultsFromNewAPI(a1, a2, a3, a4, v10, v8);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
  }
  CV3DRaycastResultListRelease();

  return v9;
}

void sub_1B3A6B39C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t RaycastSession::StopRaycast(RaycastSession *this, const __CFUUID *a2)
{
  return CV3DRaycastRemoveTrackableRay();
}

uint64_t RaycastSession::PushChunks(RaycastSession *this, const CV3DReconMeshList *a2, simd_float4x4 a3)
{
  return CV3DRaycastPushChunks();
}

void CFErrorRefException::~CFErrorRefException(std::exception *this)
{
  CFErrorRefException::~CFErrorRefException(this);
  JUMPOUT(0x1B5E2D5B8);
}

{
  std::exception_vtbl *v2;

  this->__vftable = (std::exception_vtbl *)&unk_1E6670440;
  v2 = this[1].__vftable;
  if (v2)
    CFRelease(v2);
  std::exception::~exception(this);
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void ___ZL13_ARLogGeneralv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

uint64_t ARCreatePlaneDetectionExtentTypeForPlaneDetectionType(__int16 a1)
{
  uint64_t v2;
  NSObject *v3;
  uint8_t v5[16];

  v2 = CV3DPlaneDetectionExtentTypesCreate();
  if (!v2)
  {
    _ARLogGeneral();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_1B3A68000, v3, OS_LOG_TYPE_ERROR, "Could not instantiate desired extent for plane detection", v5, 2u);
    }

  }
  if ((a1 & 0x200) != 0)
  {
    CV3DPlaneDetectionExtentTypesSetAll();
  }
  else
  {
    CV3DPlaneDetectionExtentTypesSetAxisAlignedBox();
    CV3DPlaneDetectionExtentTypesSetOrientedBox();
    CV3DPlaneDetectionExtentTypesSetConvexHull();
  }
  return v2;
}

uint64_t ARPlaneDetectionOrientationForPlaneDetectionType(char a1)
{
  unsigned __int8 *v1;
  unsigned __int8 *v2;

  v1 = (unsigned __int8 *)MEMORY[0x1E0D841F8];
  if ((~a1 & 3) != 0)
  {
    if ((a1 & 0x80) == 0)
      v1 = (unsigned __int8 *)MEMORY[0x1E0D841F0];
    v2 = (unsigned __int8 *)MEMORY[0x1E0D84208];
    if ((a1 & 2) == 0)
      v2 = (unsigned __int8 *)MEMORY[0x1E0D84200];
    if ((a1 & 0x81) == 0)
      v1 = v2;
  }
  return *v1;
}

uint64_t ExtractConfig(const PlaneDetectionConfiguration *a1)
{
  uint64_t v2;
  NSNumber *minVergenceAngleDegreesUserDefaultValue;
  NSString *detectionPolicyString;

  v2 = CV3DPlaneDetectionConfigurationCreate();
  minVergenceAngleDegreesUserDefaultValue = a1->minVergenceAngleDegreesUserDefaultValue;
  if (minVergenceAngleDegreesUserDefaultValue)
    -[NSNumber doubleValue](minVergenceAngleDegreesUserDefaultValue, "doubleValue");
  else
    -[ARWorldTrackingOptions minVergenceAngle](a1->options, "minVergenceAngle");
  CV3DPlaneDetectionConfigurationSetMinVergenceAngle();
  -[ARWorldTrackingOptions planeDetection](a1->options, "planeDetection");
  CV3DPlaneDetectionConfigurationSetDesiredOrientations();
  ARCreatePlaneDetectionExtentTypeForPlaneDetectionType(-[ARWorldTrackingOptions planeDetection](a1->options, "planeDetection"));
  CV3DPlaneDetectionConfigurationSetDesiredExtent();
  CV3DPlaneDetectionExtentTypesRelease();
  if (-[ARWorldTrackingOptions planeEstimationShouldUseJasperData](a1->options, "planeEstimationShouldUseJasperData"))
  {
    detectionPolicyString = a1->detectionPolicyString;
    if (detectionPolicyString)
      -[NSString isEqualToString:](detectionPolicyString, "isEqualToString:", CFSTR("jasper"));
    CV3DPlaneDetectionConfigurationSetDetectionPolicy();
  }
  else
  {
    CV3DPlaneDetectionConfigurationSetDetectionPolicy();
    CV3DPlaneDetectionConfigurationEnableMLSegmentDetector();
  }
  if (a1->var0)
    CV3DPlaneDetectionConfigurationEnableDeterministicMode();
  if (-[ARWorldTrackingOptions lowQosSchedulingEnabled](a1->options, "lowQosSchedulingEnabled"))
    CV3DPlaneDetectionConfigurationEnableLowQosScheduling();
  return v2;
}

uint64_t ExtractParams(const PlaneDetectionConfiguration *a1)
{
  uint64_t v2;
  NSNumber *detectionCountUserDefaultValue;

  v2 = CV3DPlaneDetectionParametersCreate();
  detectionCountUserDefaultValue = a1->detectionCountUserDefaultValue;
  if (detectionCountUserDefaultValue)
  {
    -[NSNumber intValue](detectionCountUserDefaultValue, "intValue");
    CV3DPlaneDetectionParametersSetMinDetections();
  }
  if (-[ARWorldTrackingOptions planeBundleAdjustmentEnabled](a1->options, "planeBundleAdjustmentEnabled"))
    CV3DPlaneDetectionParametersSetMinDetections();
  if (+[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.planeEstimation.enableInverseDepthDetector")))
  {
    CV3DPlaneDetectionParametersSetInverseDepthDetector();
    CV3DPlaneDetectionParametersSetMinimumCellSize();
    CV3DPlaneDetectionParametersSetPlaneFitThreshold();
    CV3DPlaneDetectionParametersSetMinDepthConfidence();
    CV3DPlaneDetectionParametersSetMinNormalDotProduct();
    CV3DPlaneDetectionParametersSetMinClusterSize();
  }
  return v2;
}

_QWORD *PlaneDetectionSession::PlaneDetectionSession(_QWORD *a1, uint64_t a2, const PlaneDetectionConfiguration *a3, void *a4, void *a5)
{
  id v9;
  id v10;
  uint64_t v11;
  uint64_t v12;
  void *v13;
  void *v14;
  NSObject *v15;
  CFStringRef v16;
  NSObject *v17;
  CFStringRef v18;
  NSObject *v19;
  _QWORD v21[5];
  _QWORD v22[5];
  CFErrorRef err;
  uint8_t buf[4];
  CFStringRef v25;
  uint64_t v26;

  v26 = *MEMORY[0x1E0C80C00];
  v9 = a4;
  v10 = a5;
  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0;
  a1[1] = ExtractParams(a3);
  *a1 = ExtractConfig(a3);
  err = 0;
  v11 = CV3DPlaneDetectionSessionCreateWithConfig();
  a1[2] = v11;
  if (v11)
  {
    v12 = MEMORY[0x1E0C809B0];
    v22[0] = MEMORY[0x1E0C809B0];
    v22[1] = 3221225472;
    v22[2] = ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke;
    v22[3] = &__block_descriptor_40_e28_v80__0____CFUUID__8____4__16l;
    v22[4] = a2;
    v13 = (void *)MEMORY[0x1B5E2DF90](v22);
    v21[0] = v12;
    v21[1] = 3221225472;
    v21[2] = ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke_2;
    v21[3] = &__block_descriptor_40_e19_v16__0____CFUUID__8l;
    v21[4] = a2;
    v14 = (void *)MEMORY[0x1B5E2DF90](v21);
    if ((CV3DPlaneDetectionSessionSetAnchoringFunctors() & 1) == 0)
    {
      _ARLogGeneral();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        v16 = CFErrorCopyDescription(err);
        *(_DWORD *)buf = 138412290;
        v25 = v16;
        _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "Error setting anchoring functors: %@", buf, 0xCu);
      }

      CFRelease(err);
    }
    if ((CV3DPlaneDetectionSessionRegisterUpdateCallback() & 1) == 0)
    {
      _ARLogGeneral();
      v17 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        v18 = CFErrorCopyDescription(err);
        *(_DWORD *)buf = 138412290;
        v25 = v18;
        _os_log_impl(&dword_1B3A68000, v17, OS_LOG_TYPE_ERROR, "Error registering update callback: %@", buf, 0xCu);
      }

      CFRelease(err);
    }
    if (v10)
      CV3DPlaneDetectionSessionSetSingleShotPlanesCallback();

  }
  else
  {
    _ARLogGeneral();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v25 = CFErrorCopyDescription(err);
      _os_log_impl(&dword_1B3A68000, v19, OS_LOG_TYPE_ERROR, "Error initializing surface detection: %@", buf, 0xCu);
    }

    CFRelease(err);
  }

  return a1;
}

void sub_1B3A6BAE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke()
{
  return CV3DSLAMSessionAddAnchor();
}

uint64_t ___ZN21PlaneDetectionSessionC2EP15CV3DSLAMSessionRK27PlaneDetectionConfigurationU13block_pointerFvPK27CV3DPlaneDetectionPlaneListEU13block_pointerFvPK37CV3DPlaneDetectionSingleShotPlaneListE_block_invoke_2()
{
  return CV3DSLAMSessionRemoveAnchor();
}

void PlaneDetectionSession::~PlaneDetectionSession(PlaneDetectionSession *this)
{
  CV3DPlaneDetectionConfigurationRelease();
  CV3DPlaneDetectionParametersRelease();
  CV3DPlaneDetectionSessionRelease();
}

void PlaneDetectionSession::PushSlamState(PlaneDetectionSession *this, const CV3DSLAMStateContext *a2)
{
  CV3DPlaneDetectionSlamMetadataCreateFromSlamState();
  CV3DPlaneDetectionPushSlamMetadata();
  CV3DPlaneDetectionSlamMetadataRelease();
}

void sub_1B3A6BCE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushSemanticsAndNormals(PlaneDetectionSession *this, ARSegmentationData *a2, simd_float4x4 a3, simd_float3x3 a4, double a5)
{
  ARSegmentationData *v5;

  v5 = a2;
  -[ARSegmentationData timestamp](v5, "timestamp");
  -[ARSegmentationData segmentationBuffer](v5, "segmentationBuffer");
  -[ARSegmentationData confidenceBuffer](v5, "confidenceBuffer");
  -[ARSegmentationData normalsBuffer](v5, "normalsBuffer");
  CV3DPlaneDetectionSemanticFrameCreate();
  CV3DPlaneDetectionPushSemanticFrame();
  CV3DPlaneDetectionSemanticFrameRelease();

  return 1;
}

void sub_1B3A6BE64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushDepthWithSemantics(PlaneDetectionSession *this, ARMLDepthData *a2, ARSegmentationData *a3, simd_float4x4 a4, simd_float3x3 a5, double a6)
{
  ARMLDepthData *v7;
  ARSegmentationData *v8;

  v7 = a2;
  v8 = a3;
  -[ARSegmentationData timestamp](v8, "timestamp");
  -[ARMLDepthData singleFrameDepthBuffer](v7, "singleFrameDepthBuffer");
  -[ARMLDepthData confidenceBuffer](v7, "confidenceBuffer");
  -[ARMLDepthData normalsBuffer](v7, "normalsBuffer");
  -[ARSegmentationData maskedSemanticsSampledForDepth](v8, "maskedSemanticsSampledForDepth");
  -[ARSegmentationData confidenceSampledForDepth](v8, "confidenceSampledForDepth");
  CV3DPlaneDetectionDepthAndSemanticFrameCreate();
  CV3DPlaneDetectionPushDepthAndSemanticFrame();
  CV3DPlaneDetectionDepthAndSemanticFrameRelease();

  return 1;
}

void sub_1B3A6C02C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::PushJasperPointCloud(uint64_t a1, void *a2)
{
  id v2;

  v2 = a2;
  CV3DPlaneDetectionDepthCameraFrameCreateFromAD();
  CV3DPlaneDetectionPushSparseDepthFrame();
  CV3DPlaneDetectionDepthCameraFrameRelease();

  return 1;
}

void sub_1B3A6C1B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id PlaneDetectionSession::SerializePlanes(PlaneDetectionSession *this)
{
  void *v1;
  id v2;
  NSObject *v3;
  uint8_t buf[4];
  CFStringRef v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v1 = (void *)objc_opt_new();
  if (CV3DPlaneDetectionSerialize())
  {
    v2 = v1;
  }
  else
  {
    _ARLogGeneral();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v6 = CFErrorCopyDescription(0);
      _os_log_impl(&dword_1B3A68000, v3, OS_LOG_TYPE_ERROR, "Failed to serialize surface data: %@", buf, 0xCu);
    }

    CFRelease(0);
    v2 = 0;
  }

  return v2;
}

void sub_1B3A6C2D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void PlaneDetectionSession::LoadPlanes(PlaneDetectionSession *this, const __CFData *a2)
{
  NSObject *v2;
  uint8_t buf[4];
  CFStringRef v4;
  uint64_t v5;

  v5 = *MEMORY[0x1E0C80C00];
  if ((CV3DPlaneDetectionLoadMap() & 1) == 0)
  {
    _ARLogGeneral();
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138412290;
      v4 = CFErrorCopyDescription(0);
      _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_ERROR, "Failed to load surface data: %@", buf, 0xCu);
    }

    CFRelease(0);
  }
}

void sub_1B3A6C3B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void PlaneDetectionSession::ErasePlanes(uint64_t a1, void *a2)
{
  id v2;
  __CFArray *Mutable;
  id v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v8;
  void *v9;
  const void *v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v2 = a2;
  Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, 0);
  v13 = 0u;
  v14 = 0u;
  v11 = 0u;
  v12 = 0u;
  v4 = v2;
  v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v5)
  {
    v6 = *(_QWORD *)v12;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v4);
        v8 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * v7);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          objc_msgSend(v8, "identifier", (_QWORD)v11);
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          v10 = (const void *)objc_msgSend(v9, "ar_createCFUUIDRef");

          CFArrayAppendValue(Mutable, v10);
          CFRelease(v10);
        }
        ++v7;
      }
      while (v5 != v7);
      v5 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v5);
  }

  CV3DPlaneDetectionErasePlaneDetections();
  CFRelease(Mutable);

}

void sub_1B3A6C54C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t PlaneDetectionSession::UpdateConfiguration(PlaneDetectionSession *this, const PlaneDetectionConfiguration *a2)
{
  CV3DPlaneDetectionConfigurationRelease();
  *(_QWORD *)this = ExtractConfig(a2);
  return CV3DPlaneDetectionSetConfiguration();
}

uint64_t PlaneDetectionSession::DidParametersOrConfigurationChanged(PlaneDetectionSession *this, const PlaneDetectionConfiguration *a2)
{
  unsigned int v3;
  int v4;
  int v5;

  ExtractParams(a2);
  ExtractConfig(a2);
  v3 = CV3DPlaneDetectionParametersEqualParameters() ^ 1;
  v4 = CV3DPlaneDetectionConfigurationEqualConfigurations();
  CV3DPlaneDetectionConfigurationRelease();
  CV3DPlaneDetectionParametersRelease();
  if (v4)
    v5 = 0;
  else
    v5 = 256;
  return v5 | v3;
}

void ___ZL13_ARLogGeneralv_block_invoke_0()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

id _ARLogGeneral()
{
  if (_ARLogGeneral_onceToken != -1)
    dispatch_once(&_ARLogGeneral_onceToken, &__block_literal_global_1);
  return (id)_ARLogGeneral_logObj;
}

void sub_1B3A6E6EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

double simd_quaternion(simd_float3x3 a1)
{
  float v1;
  float v3;
  float32x2_t v4;
  float32x2_t v5;
  float32x2_t v6;
  float v8;
  float32x2_t v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x2_t v12;
  float32x2_t v13;
  float32x2_t v14;
  unsigned __int32 v15;
  float32x2_t v20;
  float v21;
  unsigned int v22;
  float32x2_t v23;
  float32x2_t v24;
  float32x2_t v25;

  v1 = a1.columns[2].f32[2] + (float)(a1.columns[0].f32[0] + a1.columns[1].f32[1]);
  if (v1 >= 0.0)
  {
    v8 = sqrtf(v1 + 1.0);
    v9 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8));
    v10 = vmul_f32(v9, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v9));
    v20 = vmul_n_f32(vsub_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL), *(int32x2_t *)a1.columns[2].f32), (float32x2_t)vext_s8(*(int8x8_t *)a1.columns[2].f32, (int8x8_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), 4uLL)), vmul_f32(v10, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v8 + v8), v10)).f32[0]);
  }
  else if (a1.columns[0].f32[0] < a1.columns[1].f32[1] || a1.columns[0].f32[0] < a1.columns[2].f32[2])
  {
    v3 = 1.0 - a1.columns[0].f32[0];
    if (a1.columns[1].f32[1] >= a1.columns[2].f32[2])
    {
      v21 = sqrtf(a1.columns[1].f32[1] + (float)(v3 - a1.columns[2].f32[2]));
      *(float *)&v22 = v21 + v21;
      v23 = vrecpe_f32((float32x2_t)v22);
      v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v22, v23));
      v25.i32[0] = vmul_f32(v24, vrecps_f32((float32x2_t)v22, v24)).u32[0];
      v24.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_lane_s32(*(int32x2_t *)a1.columns[0].f32, 1), *(float32x2_t *)a1.columns[1].f32).u32[0];
      v24.i32[1] = v22;
      v25.i32[1] = 0.25;
      v20 = vmul_f32(v24, v25);
    }
    else
    {
      v4 = (float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[2].f32[2] + (float)(v3 - a1.columns[1].f32[1]))));
      *(float32x2_t *)a1.columns[2].f32 = vadd_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[0], (int8x16_t)a1.columns[0], 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 8uLL)), *(float32x2_t *)a1.columns[2].f32);
      *(int32x2_t *)a1.columns[1].f32 = vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
      a1.columns[1].i32[0] = 2.0;
      a1.columns[1].i32[0] = vmul_f32(v4, *(float32x2_t *)a1.columns[1].f32).u32[0];
      v5 = vrecpe_f32((float32x2_t)a1.columns[1].u32[0]);
      v6 = vmul_f32(v5, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v5));
      v20 = vmul_n_f32(*(float32x2_t *)a1.columns[2].f32, vmul_f32(v6, vrecps_f32((float32x2_t)a1.columns[1].u32[0], v6)).f32[0]);
      __asm { FMOV            V2.2S, #0.25 }
    }
  }
  else
  {
    v11 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)a1.columns[1].f32, 0);
    v12 = vadd_f32(*(float32x2_t *)a1.columns[0].f32, v11);
    v11.i32[0] = 2.0;
    v11.i32[0] = vmul_f32((float32x2_t)__PAIR64__(a1.columns[0].u32[1], COERCE_UNSIGNED_INT(sqrtf(a1.columns[0].f32[0]+ (float)((float)(1.0 - a1.columns[1].f32[1]) - a1.columns[2].f32[2])))), v11).u32[0];
    v11.i32[1] = v12.i32[1];
    v13 = vrecpe_f32((float32x2_t)v11.u32[0]);
    v14 = vmul_f32(v13, vrecps_f32((float32x2_t)v11.u32[0], v13));
    v15 = vmul_f32(v14, vrecps_f32((float32x2_t)v11.u32[0], v14)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.i32[1] = v15;
    v20 = vmul_f32(v11, _D5);
  }
  return *(double *)&v20;
}

void sub_1B3A70EF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A70FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3A7118C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id a26)
{

  _Unwind_Resume(a1);
}

void sub_1B3A71648(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;

  _Unwind_Resume(a1);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::operator=(uint64_t a1, uint64_t a2)
{
  if (a1 != a2)
  {
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((_QWORD *)a1, *(_DWORD **)a2, *(_DWORD **)(a2 + 8), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((_QWORD *)(a1 + 24), *(_DWORD **)(a2 + 24), *(_DWORD **)(a2 + 32), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 32) - *(_QWORD *)(a2 + 24)) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((_QWORD *)(a1 + 48), *(_DWORD **)(a2 + 48), *(_DWORD **)(a2 + 56), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 56) - *(_QWORD *)(a2 + 48)) >> 2));
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((_QWORD *)(a1 + 72), *(_DWORD **)(a2 + 72), *(_DWORD **)(a2 + 80), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 80) - *(_QWORD *)(a2 + 72)) >> 2));
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((uint64_t **)(a1 + 96), *(uint64_t **)(a2 + 96), *(uint64_t **)(a2 + 104), (uint64_t)(*(_QWORD *)(a2 + 104) - *(_QWORD *)(a2 + 96)) >> 3);
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((uint64_t **)(a1 + 120), *(uint64_t **)(a2 + 120), *(uint64_t **)(a2 + 128), (uint64_t)(*(_QWORD *)(a2 + 128) - *(_QWORD *)(a2 + 120)) >> 3);
    std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((_QWORD *)(a1 + 144), *(_DWORD **)(a2 + 144), *(_DWORD **)(a2 + 152), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a2 + 152) - *(_QWORD *)(a2 + 144)) >> 2));
  }
  return a1;
}

_DWORD *std::vector<cva::Matrix<float,3u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>(_QWORD *a1, _DWORD *a2, _DWORD *a3, unint64_t a4)
{
  _DWORD *v6;
  uint64_t v8;
  _DWORD *result;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _DWORD **v13;
  _DWORD *v14;
  char *v15;
  uint64_t v16;
  _DWORD *v17;
  _DWORD *v18;
  unint64_t v19;
  _DWORD *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  _DWORD *v24;
  uint64_t v25;
  int64_t v26;
  _DWORD *v27;
  uint64_t v28;

  v6 = a2;
  v8 = a1[2];
  result = (_DWORD *)*a1;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - (uint64_t)result) >> 2) < a4)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 > 0x1555555555555555)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 2);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0xAAAAAAAAAAAAAAALL)
      v12 = 0x1555555555555555;
    else
      v12 = v11;
    std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](a1, v12);
    v14 = (_DWORD *)a1[1];
    v13 = (_DWORD **)(a1 + 1);
    result = v14;
    v15 = (char *)v14;
    if (v6 != a3)
    {
      v15 = (char *)result;
      do
      {
        v16 = *(_QWORD *)v6;
        *((_DWORD *)v15 + 2) = v6[2];
        *(_QWORD *)v15 = v16;
        v15 += 12;
        v6 += 3;
      }
      while (v6 != a3);
    }
LABEL_30:
    v26 = v15 - (char *)result;
    goto LABEL_31;
  }
  v18 = (_DWORD *)a1[1];
  v13 = (_DWORD **)(a1 + 1);
  v17 = v18;
  v19 = 0xAAAAAAAAAAAAAAABLL * (v18 - result);
  if (v19 >= a4)
  {
    v15 = (char *)result;
    if (a2 != a3)
    {
      v27 = result;
      do
      {
        if (v6 != v27)
        {
          v28 = *(_QWORD *)v6;
          v27[2] = v6[2];
          *(_QWORD *)v27 = v28;
        }
        v6 += 3;
        v27 += 3;
        v15 += 12;
      }
      while (v6 != a3);
    }
    goto LABEL_30;
  }
  v20 = &a2[3 * v19];
  if (v17 != result)
  {
    v21 = 12 * v19;
    do
    {
      if (v6 != result)
      {
        v22 = *(_QWORD *)v6;
        result[2] = v6[2];
        *(_QWORD *)result = v22;
      }
      v6 += 3;
      result += 3;
      v21 -= 12;
    }
    while (v21);
    result = *v13;
  }
  v23 = (char *)result;
  if (v20 != a3)
  {
    v23 = (char *)result;
    v24 = result;
    do
    {
      v25 = *(_QWORD *)v20;
      v24[2] = v20[2];
      *(_QWORD *)v24 = v25;
      v24 += 3;
      v20 += 3;
      v23 += 12;
    }
    while (v20 != a3);
  }
  v26 = v23 - (char *)result;
LABEL_31:
  *v13 = (_DWORD *)((char *)result + v26);
  return result;
}

char *std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x1555555555555556)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[12 * v4];
  return result;
}

void std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x1555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(12 * a2);
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E666E9D8, MEMORY[0x1E0DE42D0]);
}

void sub_1B3A71C94(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5020] + 16);
  return result;
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x1E0DE4E98], MEMORY[0x1E0DE4390]);
}

uint64_t *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__assign_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>(uint64_t **a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t *v6;
  uint64_t v8;
  uint64_t *result;
  uint64_t v10;
  unint64_t v11;
  uint64_t **v12;
  uint64_t *v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t *v17;
  unint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  int64_t v24;
  uint64_t *v25;

  v6 = a2;
  v8 = (uint64_t)a1[2];
  result = *a1;
  if (a4 > (v8 - (uint64_t)result) >> 3)
  {
    if (result)
    {
      a1[1] = result;
      operator delete(result);
      v8 = 0;
      *a1 = 0;
      a1[1] = 0;
      a1[2] = 0;
    }
    if (a4 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, v11);
    v13 = a1[1];
    v12 = a1 + 1;
    result = v13;
    v14 = (char *)v13;
    if (v6 != a3)
    {
      v14 = (char *)result;
      do
      {
        v15 = *v6++;
        *(_QWORD *)v14 = v15;
        v14 += 8;
      }
      while (v6 != a3);
    }
LABEL_30:
    v24 = v14 - (char *)result;
    goto LABEL_31;
  }
  v17 = a1[1];
  v12 = a1 + 1;
  v16 = v17;
  v18 = v17 - result;
  if (v18 >= a4)
  {
    v14 = (char *)result;
    if (a2 != a3)
    {
      v25 = result;
      do
      {
        if (v6 != v25)
          *v25 = *v6;
        ++v6;
        ++v25;
        v14 += 8;
      }
      while (v6 != a3);
    }
    goto LABEL_30;
  }
  v19 = &a2[v18];
  if (v16 != result)
  {
    v20 = 8 * v18;
    do
    {
      if (v6 != result)
        *result = *v6;
      ++v6;
      ++result;
      v20 -= 8;
    }
    while (v20);
    result = *v12;
  }
  v21 = (char *)result;
  if (v19 != a3)
  {
    v21 = (char *)result;
    v22 = result;
    do
    {
      v23 = *v19++;
      *v22++ = v23;
      v21 += 8;
    }
    while (v19 != a3);
  }
  v24 = v21 - (char *)result;
LABEL_31:
  *v12 = (uint64_t *)((char *)result + v24);
  return result;
}

char *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::TriMesh(uint64_t a1, uint64_t **a2)
{
  *(_QWORD *)a1 = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)a1, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[1] - (char *)*a2) >> 2));
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 32) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)(a1 + 24), a2[3], a2[4], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[4] - (char *)a2[3]) >> 2));
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>((char *)(a1 + 48), a2[6], a2[7], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[7] - (char *)a2[6]) >> 2));
  *(_QWORD *)(a1 + 72) = 0;
  *(_QWORD *)(a1 + 80) = 0;
  *(_QWORD *)(a1 + 88) = 0;
  std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>((char *)(a1 + 72), a2[9], a2[10], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[10] - (char *)a2[9]) >> 2));
  *(_QWORD *)(a1 + 96) = 0;
  *(_QWORD *)(a1 + 104) = 0;
  *(_QWORD *)(a1 + 112) = 0;
  std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>((char *)(a1 + 96), a2[12], a2[13], a2[13] - a2[12]);
  *(_QWORD *)(a1 + 120) = 0;
  *(_QWORD *)(a1 + 128) = 0;
  *(_QWORD *)(a1 + 136) = 0;
  std::vector<cva::Matrix<float,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,2u,1u,false>*,cva::Matrix<float,2u,1u,false>*>((char *)(a1 + 120), a2[15], a2[16], a2[16] - a2[15]);
  *(_QWORD *)(a1 + 144) = 0;
  *(_QWORD *)(a1 + 152) = 0;
  *(_QWORD *)(a1 + 160) = 0;
  std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>((char *)(a1 + 144), a2[18], a2[19], 0xAAAAAAAAAAAAAAABLL * (((char *)a2[19] - (char *)a2[18]) >> 2));
  return a1;
}

void sub_1B3A72018(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void **v3;
  void **v4;
  void **v5;
  void **v6;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v8 = *v6;
  if (*v6)
  {
    *(_QWORD *)(v1 + 128) = v8;
    operator delete(v8);
  }
  v9 = *v5;
  if (*v5)
  {
    *(_QWORD *)(v1 + 104) = v9;
    operator delete(v9);
  }
  v10 = *v4;
  if (*v4)
  {
    *(_QWORD *)(v1 + 80) = v10;
    operator delete(v10);
  }
  v11 = *v3;
  if (*v3)
  {
    *(_QWORD *)(v1 + 56) = v11;
    operator delete(v11);
  }
  v12 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 32) = v12;
    operator delete(v12);
  }
  v13 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<float,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,3u,1u,false>*,cva::Matrix<float,3u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2;
      *(_DWORD *)(v7 + 8) = *((_DWORD *)a2 + 2);
      *(_QWORD *)v7 = v8;
      v7 += 12;
      a2 = (uint64_t *)((char *)a2 + 12);
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B3A7210C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<unsigned int,3u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,3u,1u,false>*,cva::Matrix<unsigned int,3u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2;
      *(_DWORD *)(v7 + 8) = *((_DWORD *)a2 + 2);
      *(_QWORD *)v7 = v8;
      v7 += 12;
      a2 = (uint64_t *)((char *)a2 + 12);
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B3A72188(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<unsigned int,2u,1u,false>*,cva::Matrix<unsigned int,2u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B3A721F8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<cva::Matrix<float,2u,1u,false>>::__init_with_size[abi:ne180100]<cva::Matrix<float,2u,1u,false>*,cva::Matrix<float,2u,1u,false>*>(char *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  char *v6;
  _QWORD *v7;
  uint64_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = (_QWORD *)*((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      v8 = *a2++;
      *v7++ = v8;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B3A72268(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t cv3d::recon::mesh_util::TriMesh<float,unsigned int>::~TriMesh(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  v2 = *(void **)(a1 + 144);
  if (v2)
  {
    *(_QWORD *)(a1 + 152) = v2;
    operator delete(v2);
  }
  v3 = *(void **)(a1 + 120);
  if (v3)
  {
    *(_QWORD *)(a1 + 128) = v3;
    operator delete(v3);
  }
  v4 = *(void **)(a1 + 96);
  if (v4)
  {
    *(_QWORD *)(a1 + 104) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(a1 + 72);
  if (v5)
  {
    *(_QWORD *)(a1 + 80) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(a1 + 48);
  if (v6)
  {
    *(_QWORD *)(a1 + 56) = v6;
    operator delete(v6);
  }
  v7 = *(void **)(a1 + 24);
  if (v7)
  {
    *(_QWORD *)(a1 + 32) = v7;
    operator delete(v7);
  }
  v8 = *(void **)a1;
  if (*(_QWORD *)a1)
  {
    *(_QWORD *)(a1 + 8) = v8;
    operator delete(v8);
  }
  return a1;
}

_QWORD *std::vector<unsigned char>::__init_with_size[abi:ne180100]<unsigned char *,unsigned char *>(_QWORD *result, const void *a2, uint64_t a3, size_t __sz)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (__sz)
  {
    v6 = result;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](result, __sz);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3A72370(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned char>::__vallocate[abi:ne180100](_QWORD *a1, size_t __sz)
{
  char *result;

  if ((__sz & 0x8000000000000000) != 0)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)operator new(__sz);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[__sz];
  return result;
}

_QWORD *std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(_QWORD *result, char *__src, char *a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  uint64_t v10;
  size_t v11;
  _BYTE *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;

  v7 = result;
  v8 = result[2];
  v9 = (char *)*result;
  if (v8 - *result < a4)
  {
    if (v9)
    {
      result[1] = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 2 * v8;
    if (2 * v8 <= a4)
      v10 = a4;
    if (v8 >= 0x3FFFFFFFFFFFFFFFLL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<unsigned char>::__vallocate[abi:ne180100](v7, v11);
    v9 = (char *)v7[1];
    goto LABEL_17;
  }
  v12 = (_BYTE *)result[1];
  v13 = v12 - v9;
  if (v12 - v9 >= a4)
  {
LABEL_17:
    v16 = a3 - __src;
    if (v16)
      result = memmove(v9, __src, v16);
    v15 = &v9[v16];
    goto LABEL_20;
  }
  v14 = &__src[v13];
  if (v12 != v9)
  {
    result = memmove((void *)*result, __src, v13);
    v9 = (char *)v7[1];
  }
  if (a3 != v14)
    result = memmove(v9, v14, a3 - v14);
  v15 = &v9[a3 - v14];
LABEL_20:
  v7[1] = v15;
  return result;
}

void sub_1B3A73904(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A73AA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A73C7C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A73F6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A74178(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_1()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke()
{
  _BOOL8 result;

  result = +[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.skipCrashOnARCrash"));
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

id _ARLogGeneral_0()
{
  if (_ARLogGeneral_onceToken_0 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_0, &__block_literal_global_4);
  return (id)_ARLogGeneral_logObj_0;
}

id _ARLogSensor()
{
  if (_ARLogSensor_onceToken != -1)
    dispatch_once(&_ARLogSensor_onceToken, &__block_literal_global_123);
  return (id)_ARLogSensor_logObj;
}

void sub_1B3A75BF8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, int a10, __int16 a11, __int16 a12, uint64_t a13, __int16 a14, __int128 a15)
{
  void *v15;
  void *v16;
  id v17;
  NSObject *v18;
  objc_class *v19;
  id v20;
  id v21;
  uint64_t v22;
  void *v23;

  if (a2 == 1)
  {
    v17 = objc_begin_catch(exception_object);
    _ARLogSensor();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      v19 = (objc_class *)objc_opt_class();
      NSStringFromClass(v19);
      v20 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "logPrefix");
      v21 = (id)objc_claimAutoreleasedReturnValue();
      v22 = objc_msgSend(v15, "timeOfFlightProjectorMode");
      objc_msgSend(v17, "reason");
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(a9) = 138544642;
      *(_QWORD *)((char *)&a9 + 4) = v20;
      WORD6(a9) = 2048;
      *(_QWORD *)((char *)&a9 + 14) = v16;
      a12 = 2112;
      a13 = (uint64_t)v21;
      a14 = 2112;
      WORD1(a15) = 2048;
      *(_QWORD *)((char *)&a15 + 4) = v22;
      WORD6(a15) = 2112;
      *(_QWORD *)((char *)&a15 + 14) = v23;
      _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set projector mode to %@. Current projector mode of the device: %ld. Exception: %@", (uint8_t *)&a9, 0x3Eu);

    }
    objc_end_catch();
    JUMPOUT(0x1B3A75BB4);
  }
  _Unwind_Resume(exception_object);
}

uint64_t ARAVTimeOfFlightProjectorModeFromARTimeOfFlightProjectMode(void *a1)
{
  id v1;
  uint64_t v2;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("ARTimeOfFlightProjectorModeNormal")) & 1) != 0)
  {
    v2 = 1;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("ARTimeOfFlightProjectorModeShortRange")) & 1) != 0)
  {
    v2 = 2;
  }
  else if ((objc_msgSend(v1, "isEqualToString:", CFSTR("ARTimeOfFlightProjectorModeNormalShortHybrid")) & 1) != 0)
  {
    v2 = 3;
  }
  else if (objc_msgSend(v1, "isEqualToString:", CFSTR("ARTimeOfFlightProjectorModeHighQualityMacro")))
  {
    v2 = 6;
  }
  else
  {
    v2 = 0;
  }

  return v2;
}

void sub_1B3A76778(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A7696C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A76E44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_2()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke_0()
{
  _BOOL8 result;

  result = +[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.skipCrashOnARCrash"));
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

void sub_1B3A777A8(void *a1)
{
  void *v1;

  objc_begin_catch(a1);

  objc_exception_rethrow();
}

void sub_1B3A777B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  objc_end_catch();

  _Unwind_Resume(a1);
}

void sub_1B3A7785C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A77920(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id _ARLogGeneral_1()
{
  if (_ARLogGeneral_onceToken_2 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_2, &__block_literal_global_7);
  return (id)_ARLogGeneral_logObj_2;
}

void sub_1B3A7932C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A795F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27)
{
  void *v27;

  std::deque<std::pair<int,int>>::~deque[abi:ne180100](&a27);
  _Unwind_Resume(a1);
}

void std::deque<std::pair<int,int>>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;

  v4 = a1[2];
  v5 = a1[1];
  v6 = ((v4 - v5) << 6) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::pair<int,int>>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  *(_QWORD *)(*(_QWORD *)(v5 + ((v7 >> 6) & 0x3FFFFFFFFFFFFF8)) + 8 * (v7 & 0x1FF)) = *a2;
  ++a1[5];
}

void sub_1B3A79840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  void *v13;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1B3A7994C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A799C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A79A58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3A79B9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A79C64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A79D58(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPS1_S6_EEvT_T0_m(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3A79DF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void *_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE18__assign_with_sizeB8ne180100IPS1_S6_EEvT_T0_l(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t std::deque<std::pair<int,int>>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  void *v7;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  a1[5] = 0;
  v4 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v4 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v5 = v4 >> 3;
  if (v5 == 1)
  {
    v6 = 256;
  }
  else
  {
    if (v5 != 2)
      goto LABEL_9;
    v6 = 512;
  }
  a1[4] = v6;
LABEL_9:
  while (v2 != v3)
  {
    v7 = *v2++;
    operator delete(v7);
  }
  return std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer((uint64_t)a1);
}

uint64_t std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  v2 = *(_QWORD *)(a1 + 16);
  if (v2 != v3)
    *(_QWORD *)(a1 + 16) = v2 + ((v3 - v2 + 7) & 0xFFFFFFFFFFFFFFF8);
  v4 = *(void **)a1;
  if (*(_QWORD *)a1)
    operator delete(v4);
  return a1;
}

void std::deque<std::pair<int,int>>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x200;
  v4 = v2 - 512;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0x1000uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0x1000uLL);
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0x1000uLL);
  std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1B3A7A330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(_QWORD *a1, _QWORD *a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  uint64_t *v22;
  uint64_t v23;
  uint64_t v24;
  char *v25;
  uint64_t v26;
  char *v27;

  v5 = (char *)a1[3];
  v4 = (uint64_t)(a1 + 3);
  v6 = *(char **)(v4 - 8);
  if (v6 == v5)
  {
    v7 = (char *)a1[1];
    v8 = (uint64_t)&v7[-*a1];
    if ((unint64_t)v7 <= *a1)
    {
      if (v6 == (char *)*a1)
        v18 = 1;
      else
        v18 = (uint64_t)&v6[-*a1] >> 2;
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v18);
      v21 = &v19[8 * (v18 >> 2)];
      v22 = (uint64_t *)a1[1];
      v6 = v21;
      v23 = a1[2] - (_QWORD)v22;
      if (v23)
      {
        v6 = &v21[v23 & 0xFFFFFFFFFFFFFFF8];
        v24 = 8 * (v23 >> 3);
        v25 = &v19[8 * (v18 >> 2)];
        do
        {
          v26 = *v22++;
          *(_QWORD *)v25 = v26;
          v25 += 8;
          v24 -= 8;
        }
        while (v24);
      }
      v27 = (char *)*a1;
      *a1 = v19;
      a1[1] = v21;
      a1[2] = v6;
      a1[3] = &v19[8 * v20];
      if (v27)
      {
        operator delete(v27);
        v6 = (char *)a1[2];
      }
    }
    else
    {
      v9 = v8 >> 3;
      v10 = v8 >> 3 < -1;
      v11 = (v8 >> 3) + 2;
      if (v10)
        v12 = v11;
      else
        v12 = v9 + 1;
      v13 = -(v12 >> 1);
      v14 = v12 >> 1;
      v15 = &v7[-8 * v14];
      v16 = v6 - v7;
      if (v6 != v7)
      {
        memmove(&v7[-8 * v14], v7, v6 - v7);
        v6 = (char *)a1[1];
      }
      v17 = &v6[8 * v13];
      v6 = &v15[v16];
      a1[1] = v17;
      a1[2] = &v15[v16];
    }
  }
  *(_QWORD *)v6 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  uint64_t v15;
  uint64_t *v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  char *v22;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = a1 + 24;
    v7 = *(_BYTE **)(a1 + 24);
    v8 = *(_BYTE **)(a1 + 16);
    if (v8 >= v7)
    {
      if (v7 == v4)
        v12 = 1;
      else
        v12 = (v7 - v4) >> 2;
      v13 = 2 * v12;
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v6, v12);
      v5 = &v14[(v13 + 6) & 0xFFFFFFFFFFFFFFF8];
      v16 = *(uint64_t **)(a1 + 8);
      v17 = v5;
      v18 = *(_QWORD *)(a1 + 16) - (_QWORD)v16;
      if (v18)
      {
        v17 = &v5[v18 & 0xFFFFFFFFFFFFFFF8];
        v19 = 8 * (v18 >> 3);
        v20 = v5;
        do
        {
          v21 = *v16++;
          *(_QWORD *)v20 = v21;
          v20 += 8;
          v19 -= 8;
        }
        while (v19);
      }
      v22 = *(char **)a1;
      *(_QWORD *)a1 = v14;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v17;
      *(_QWORD *)(a1 + 24) = &v14[8 * v15];
      if (v22)
      {
        operator delete(v22);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v9 = (v7 - v8) >> 3;
      if (v9 >= -1)
        v10 = v9 + 1;
      else
        v10 = v9 + 2;
      v11 = v10 >> 1;
      v5 = &v4[8 * (v10 >> 1)];
      if (v8 != v4)
      {
        memmove(&v4[8 * (v10 >> 1)], v4, v8 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v11];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(_QWORD *a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  uint64_t v24;
  char *v25;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 2;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(a1[4], v16);
      v19 = &v17[8 * (v16 >> 2)];
      v20 = (uint64_t *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFF8];
        v22 = 8 * (v21 >> 3);
        v23 = &v17[8 * (v16 >> 2)];
        do
        {
          v24 = *v20++;
          *(_QWORD *)v23 = v24;
          v23 += 8;
          v22 -= 8;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[8 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 3;
      v8 = v6 >> 3 < -1;
      v9 = (v6 >> 3) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-8 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-8 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[8 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
      a1[2] = &v13[v14];
    }
  }
  *(_QWORD *)v4 = *a2;
  a1[2] += 8;
}

void std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front(uint64_t a1, _QWORD *a2)
{
  char *v4;
  char *v5;
  _BYTE *v6;
  _BYTE *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  uint64_t *v15;
  char *v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;

  v4 = *(char **)(a1 + 8);
  if (v4 == *(char **)a1)
  {
    v6 = *(_BYTE **)(a1 + 16);
    v7 = *(_BYTE **)(a1 + 24);
    if (v6 >= v7)
    {
      if (v7 == v4)
        v11 = 1;
      else
        v11 = (v7 - v4) >> 2;
      v12 = 2 * v11;
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(*(_QWORD *)(a1 + 32), v11);
      v5 = &v13[(v12 + 6) & 0xFFFFFFFFFFFFFFF8];
      v15 = *(uint64_t **)(a1 + 8);
      v16 = v5;
      v17 = *(_QWORD *)(a1 + 16) - (_QWORD)v15;
      if (v17)
      {
        v16 = &v5[v17 & 0xFFFFFFFFFFFFFFF8];
        v18 = 8 * (v17 >> 3);
        v19 = v5;
        do
        {
          v20 = *v15++;
          *(_QWORD *)v19 = v20;
          v19 += 8;
          v18 -= 8;
        }
        while (v18);
      }
      v21 = *(char **)a1;
      *(_QWORD *)a1 = v13;
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = v16;
      *(_QWORD *)(a1 + 24) = &v13[8 * v14];
      if (v21)
      {
        operator delete(v21);
        v5 = *(char **)(a1 + 8);
      }
    }
    else
    {
      v8 = (v7 - v6) >> 3;
      if (v8 >= -1)
        v9 = v8 + 1;
      else
        v9 = v8 + 2;
      v10 = v9 >> 1;
      v5 = &v4[8 * (v9 >> 1)];
      if (v6 != v4)
      {
        memmove(&v4[8 * (v9 >> 1)], v4, v6 - v4);
        v4 = *(char **)(a1 + 16);
      }
      *(_QWORD *)(a1 + 8) = v5;
      *(_QWORD *)(a1 + 16) = &v4[8 * v10];
    }
  }
  else
  {
    v5 = *(char **)(a1 + 8);
  }
  *((_QWORD *)v5 - 1) = *a2;
  *(_QWORD *)(a1 + 8) -= 8;
}

_QWORD *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEEC2Em(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 16 * a2);
    a1[1] = &v4[16 * a2];
  }
  return a1;
}

void sub_1B3A7A830(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPKS1_S7_EEvT_T0_m(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3A7A8A8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3A7AAD8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_2()
{
  if (_ARLogGeneral_onceToken_3 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_3, &__block_literal_global_100);
  return (id)_ARLogGeneral_logObj_3;
}

uint64_t ARCorrectCVPixelBufferOrientation(__CVBuffer *a1, unsigned int a2, __CVBuffer **a3)
{
  uint64_t result;
  NSObject *v7;
  NSObject *v8;
  size_t Width;
  size_t Height;
  uint8_t v11;
  const __CFDictionary *Attributes;
  const __CFAllocator *v13;
  NSObject *v14;
  const char *v15;
  vImage_Buffer *p_buf;
  vImage_Error v17;
  vImage_Error v18;
  __CVBuffer *v19;
  __int16 v20;
  vImage_Buffer v21;
  vImage_Buffer dest;
  vImage_Buffer buf;
  CVPixelBufferRef v24;
  CVPixelBufferRef pixelBufferOut;

  if (a1)
  {
    if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
    {
      if (a2 == 1)
      {
        CVPixelBufferRetain(a1);
        result = 0;
        *a3 = a1;
        return result;
      }
      v24 = 0;
      pixelBufferOut = 0;
      switch(a2)
      {
        case 2u:
          Width = CVPixelBufferGetWidth(a1);
          Height = CVPixelBufferGetHeight(a1);
          v11 = 0;
          break;
        case 3u:
        case 4u:
          Width = CVPixelBufferGetWidth(a1);
          Height = CVPixelBufferGetHeight(a1);
          v11 = 2;
          break;
        case 5u:
        case 8u:
          Height = CVPixelBufferGetWidth(a1);
          Width = CVPixelBufferGetHeight(a1);
          v11 = 3;
          break;
        case 6u:
        case 7u:
          Height = CVPixelBufferGetWidth(a1);
          Width = CVPixelBufferGetHeight(a1);
          v11 = 1;
          break;
        default:
          v11 = 0;
          Height = 0;
          Width = 0;
          break;
      }
      Attributes = (const __CFDictionary *)_getAttributes();
      v13 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Width, Height, 0x4C303038u, Attributes, &pixelBufferOut))
      {
        _ARLogGeneral();
        v14 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.data) = 0;
          v15 = "Could not create pixelbuffer";
          p_buf = &buf;
LABEL_29:
          _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_ERROR, v15, (uint8_t *)p_buf, 2u);
        }
LABEL_30:

        CVPixelBufferRelease(pixelBufferOut);
        CVPixelBufferRelease(v24);
        return 4294960636;
      }
      CVPixelBufferLockBaseAddress(a1, 0);
      CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
      buf.data = CVPixelBufferGetBaseAddress(a1);
      buf.height = CVPixelBufferGetHeight(a1);
      buf.width = CVPixelBufferGetWidth(a1);
      buf.rowBytes = CVPixelBufferGetBytesPerRow(a1);
      dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
      dest.height = CVPixelBufferGetHeight(pixelBufferOut);
      dest.width = CVPixelBufferGetWidth(pixelBufferOut);
      dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
      v17 = vImageRotate90_Planar8(&buf, &dest, v11, 0, 0);
      CVPixelBufferUnlockBaseAddress(a1, 0);
      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      if (v17)
      {
        _ARLogGeneral();
        v14 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          goto LABEL_30;
        LOWORD(v21.data) = 0;
        v15 = "Could not rotate pixelbuffer";
LABEL_28:
        p_buf = &v21;
        goto LABEL_29;
      }
      if (a2 <= 7 && ((1 << a2) & 0xB4) != 0)
      {
        if (CVPixelBufferCreate(v13, Width, Height, 0x4C303038u, Attributes, &v24))
        {
          _ARLogGeneral();
          v14 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_30;
          LOWORD(v21.data) = 0;
          v15 = "Could not create pixelbuffer";
          goto LABEL_28;
        }
        CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferLockBaseAddress(v24, 0);
        v21.data = CVPixelBufferGetBaseAddress(v24);
        v21.height = CVPixelBufferGetHeight(v24);
        v21.width = CVPixelBufferGetWidth(v24);
        v21.rowBytes = CVPixelBufferGetBytesPerRow(v24);
        v18 = vImageHorizontalReflect_Planar8(&dest, &v21, 0);
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferUnlockBaseAddress(v24, 0);
        if (v18)
        {
          _ARLogGeneral();
          v14 = objc_claimAutoreleasedReturnValue();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            goto LABEL_30;
          v20 = 0;
          v15 = "Could not mirror pixelbuffer";
          p_buf = (vImage_Buffer *)&v20;
          goto LABEL_29;
        }
        v19 = pixelBufferOut;
        *a3 = v24;
        CVPixelBufferRelease(v19);
      }
      else
      {
        *a3 = pixelBufferOut;
      }
      return 0;
    }
    _ARLogGeneral();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "Input pixel buffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
    }

    return 4294960616;
  }
  else
  {
    _ARLogGeneral();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B3A68000, v7, OS_LOG_TYPE_ERROR, "Input pixel buffer cannot be NULL", (uint8_t *)&buf, 2u);
    }

    return 4294960635;
  }
}

id _getAttributes(void)
{
  uint64_t v0;
  _QWORD v2[2];
  _QWORD v3[3];

  v3[2] = *MEMORY[0x1E0C80C00];
  v0 = *MEMORY[0x1E0CA8FF0];
  v2[0] = *MEMORY[0x1E0CA8FF8];
  v2[1] = v0;
  v3[0] = MEMORY[0x1E0C9AAB0];
  v3[1] = MEMORY[0x1E0C9AA70];
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v3, v2, 2);
  return (id)objc_claimAutoreleasedReturnValue();
}

uint64_t ARCreateDownScaledGrayscaleImageAndMask(void *a1, size_t a2, void *a3, CVPixelBufferRef *a4, CVPixelBufferRef *a5)
{
  id v8;
  id v9;
  id v10;
  double v11;
  double v12;
  double v13;
  double v14;
  void *v15;
  const __CFDictionary *Attributes;
  const __CFAllocator *v17;
  NSObject *v18;
  const char *v19;
  uint8_t *p_buf;
  uint64_t v21;
  id v23;
  void *v24;
  CVPixelBufferRef *v25;
  CVPixelBufferRef *v26;
  NSObject *v27;
  __CVBuffer *v28;
  __IOSurface *v29;
  vImage_Error v30;
  NSObject *v31;
  CVPixelBufferRef v32;
  __IOSurface *IOSurface;
  const __CFString *v34;
  __IOSurface *v35;
  id v36;
  uint8_t v38[16];
  __CVBuffer *v39[2];
  vImage_Buffer v40;
  vImage_Buffer buf;
  CVPixelBufferRef texture;
  CVPixelBufferRef pixelBufferOut;
  CVPixelBufferRef v44;

  v8 = a1;
  v9 = a3;
  v10 = objc_alloc_init(MEMORY[0x1E0C9DD90]);
  pixelBufferOut = 0;
  v44 = 0;
  texture = 0;
  objc_msgSend(v8, "extent");
  v12 = v11;
  objc_msgSend(v8, "extent");
  v14 = v13;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("arkit/%s; %@; 1/1"),
    "ARCreateDownScaledGrayscaleImageAndMask",
    v9);
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  Attributes = (const __CFDictionary *)_getAttributes();
  v17 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  if (!CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (unint64_t)v12, (unint64_t)v14, 0x4C303038u, Attributes, &pixelBufferOut))
  {
    objc_msgSend(v10, "render:toCVPixelBuffer:", v8, pixelBufferOut);
    if (pixelBufferOut)
    {
      buf.data = 0;
      if (!ARScalePixelBufferMaxDimensionToNewDimension(pixelBufferOut, a2, (__CVBuffer **)&buf))
      {
        CVPixelBufferRelease(pixelBufferOut);
        pixelBufferOut = (CVPixelBufferRef)buf.data;
        if (a5)
          goto LABEL_14;
        goto LABEL_18;
      }
      v36 = v9;
      v23 = v10;
      v24 = v15;
      v25 = a5;
      v26 = a4;
      _ARLogGeneral();
      v27 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
      {
        LOWORD(v40.data) = 0;
        _os_log_impl(&dword_1B3A68000, v27, OS_LOG_TYPE_ERROR, "Error: Could not downscale pixelbuffer", (uint8_t *)&v40, 2u);
      }

      a4 = v26;
      a5 = v25;
      v15 = v24;
      v10 = v23;
      v9 = v36;
    }
    if (a5)
    {
LABEL_14:
      if (CVPixelBufferCreate(v17, (unint64_t)v12, (unint64_t)v14, 0x20u, Attributes, &v44))
      {
        _ARLogGeneral();
        v18 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_6;
        LOWORD(buf.data) = 0;
        v19 = "Could not create pixelbuffer";
        goto LABEL_4;
      }
      objc_msgSend(v10, "render:toCVPixelBuffer:", v8, v44);
      if (CVPixelBufferCreate(v17, (unint64_t)v12, (unint64_t)v14, 0x4C303038u, Attributes, &texture))
      {
        _ARLogGeneral();
        v18 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_6;
        LOWORD(buf.data) = 0;
        v19 = "Could not create pixelbuffer";
        goto LABEL_4;
      }
      CVPixelBufferLockBaseAddress(v44, 0);
      CVPixelBufferLockBaseAddress(texture, 0);
      memset(&buf, 0, sizeof(buf));
      buf.data = CVPixelBufferGetBaseAddress(v44);
      buf.height = CVPixelBufferGetHeight(v44);
      buf.width = CVPixelBufferGetWidth(v44);
      buf.rowBytes = CVPixelBufferGetBytesPerRow(v44);
      memset(&v40, 0, sizeof(v40));
      v40.data = CVPixelBufferGetBaseAddress(texture);
      v40.height = CVPixelBufferGetHeight(texture);
      v40.width = CVPixelBufferGetWidth(texture);
      v40.rowBytes = CVPixelBufferGetBytesPerRow(texture);
      v30 = vImageExtractChannel_ARGB8888(&buf, &v40, 0, 0);
      CVPixelBufferUnlockBaseAddress(v44, 0);
      CVPixelBufferUnlockBaseAddress(texture, 0);
      if (v30)
      {
        _ARLogGeneral();
        v18 = objc_claimAutoreleasedReturnValue();
        if (!os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          goto LABEL_6;
        LOWORD(v39[0]) = 0;
        v19 = "Could not extract alpha channel from image";
        p_buf = (uint8_t *)v39;
        goto LABEL_5;
      }
      CVPixelBufferRelease(v44);
      if (texture)
      {
        v39[0] = 0;
        if (ARScalePixelBufferMaxDimensionToNewDimension(texture, a2, v39))
        {
          _ARLogGeneral();
          v31 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v38 = 0;
            _os_log_impl(&dword_1B3A68000, v31, OS_LOG_TYPE_ERROR, "Error: Could not downscale alpha mask", v38, 2u);
          }

          v32 = texture;
        }
        else
        {
          CVPixelBufferRelease(texture);
          v32 = v39[0];
          texture = v39[0];
        }
      }
      else
      {
        v32 = 0;
      }
      *a5 = v32;
      *a4 = pixelBufferOut;
      IOSurface = CVPixelBufferGetIOSurface(*a5);
      v34 = (const __CFString *)*MEMORY[0x1E0CBC048];
      IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E0CBC048], v15);
      v35 = CVPixelBufferGetIOSurface(*a4);
      IOSurfaceSetValue(v35, v34, v15);
LABEL_19:
      v21 = 0;
      goto LABEL_7;
    }
LABEL_18:
    v28 = pixelBufferOut;
    *a4 = pixelBufferOut;
    v29 = CVPixelBufferGetIOSurface(v28);
    IOSurfaceSetValue(v29, (CFStringRef)*MEMORY[0x1E0CBC048], v15);
    goto LABEL_19;
  }
  _ARLogGeneral();
  v18 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    v19 = "Could not create pixelbuffer";
LABEL_4:
    p_buf = (uint8_t *)&buf;
LABEL_5:
    _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_ERROR, v19, p_buf, 2u);
  }
LABEL_6:

  CVPixelBufferRelease(v44);
  CVPixelBufferRelease(pixelBufferOut);
  CVPixelBufferRelease(texture);
  v21 = 4294960636;
LABEL_7:

  return v21;
}

void sub_1B3A7BA20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t ARScalePixelBufferMaxDimensionToNewDimension(__CVBuffer *a1, size_t a2, __CVBuffer **a3)
{
  size_t Width;
  size_t Height;
  size_t v8;
  float v9;
  size_t v10;
  NSObject *v11;
  uint64_t result;
  const __CFDictionary *Attributes;
  NSObject *v14;
  NSObject *v15;
  uint8_t v16[16];
  vImage_Buffer dest;
  vImage_Buffer buf;
  CVPixelBufferRef pixelBufferOut;

  if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
  {
    Width = CVPixelBufferGetWidth(a1);
    Height = CVPixelBufferGetHeight(a1);
    if (Width <= Height)
      v8 = Height;
    else
      v8 = Width;
    if (v8 <= a2)
    {
      v10 = Height;
      a2 = Width;
    }
    else
    {
      v9 = (float)a2;
      if (Width <= Height)
      {
        v10 = a2;
        a2 = (unint64_t)(float)((float)(v9 / (float)Height) * (float)Width);
      }
      else
      {
        v10 = (unint64_t)(float)((float)(v9 / (float)Width) * (float)Height);
      }
    }
    if (a2 == Width && v10 == Height)
    {
      *a3 = a1;
      CVPixelBufferRetain(a1);
      return 0;
    }
    else
    {
      Attributes = (const __CFDictionary *)_getAttributes();
      pixelBufferOut = 0;
      if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], a2, v10, 0x4C303038u, Attributes, &pixelBufferOut))
      {
        _ARLogGeneral();
        v14 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          LOWORD(buf.data) = 0;
          _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", (uint8_t *)&buf, 2u);
        }

        return 4294960634;
      }
      else
      {
        CVPixelBufferLockBaseAddress(a1, 0);
        CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
        buf.data = CVPixelBufferGetBaseAddress(a1);
        buf.height = CVPixelBufferGetHeight(a1);
        buf.width = CVPixelBufferGetWidth(a1);
        buf.rowBytes = CVPixelBufferGetBytesPerRow(a1);
        dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
        dest.height = CVPixelBufferGetHeight(pixelBufferOut);
        dest.width = CVPixelBufferGetWidth(pixelBufferOut);
        dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
        if (vImageScale_Planar8(&buf, &dest, 0, 0x20u))
        {
          _ARLogGeneral();
          v15 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v16 = 0;
            _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "Could not scale pixelbuffer", v16, 2u);
          }

          CVPixelBufferUnlockBaseAddress(a1, 0);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          CVPixelBufferRelease(pixelBufferOut);
          return 4294960636;
        }
        else
        {
          CVPixelBufferUnlockBaseAddress(a1, 0);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          result = 0;
          *a3 = pixelBufferOut;
        }
      }
    }
  }
  else
  {
    _ARLogGeneral();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      LOWORD(buf.data) = 0;
      _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "Pixelbuffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
    }

    return 4294960616;
  }
  return result;
}

CVPixelBufferRef ARPixelBufferWithCIImage(void *a1)
{
  id v1;
  void *v2;
  double v3;
  double v4;
  double v5;
  double v6;
  const __CFDictionary *v7;
  CVPixelBufferRef v8;
  CVPixelBufferRef v10;
  uint64_t v11;
  _QWORD v12[2];

  v12[1] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C9DD90], "context");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = 0;
  objc_msgSend(v1, "extent");
  v4 = v3;
  objc_msgSend(v1, "extent");
  v6 = v5;
  v11 = *MEMORY[0x1E0CA8FF0];
  v12[0] = MEMORY[0x1E0C9AA70];
  v7 = (const __CFDictionary *)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v12, &v11, 1);
  CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], (unint64_t)v4, (unint64_t)v6, 0x34323066u, v7, &v10);
  objc_msgSend(v2, "render:toCVPixelBuffer:", v1, v10);
  v8 = v10;

  return v8;
}

void sub_1B3A7BE44(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ARCreatePixelBufferWithPaddingToFillMinimumDimension(__CVBuffer *a1, size_t a2, Pixel_8 a3, __CVBuffer **a4)
{
  size_t Width;
  size_t Height;
  uint64_t result;
  NSObject *v11;
  const __CFDictionary *Attributes;
  NSObject *v13;
  const char *v14;
  uint8_t *p_buf;
  __int16 v16;
  vImage_Buffer dest;
  vImage_Buffer src;
  vImage_Buffer buf;
  CVPixelBufferRef pixelBufferOut;

  if (CVPixelBufferGetPixelFormatType(a1) == 1278226488)
  {
    Width = CVPixelBufferGetWidth(a1);
    Height = CVPixelBufferGetHeight(a1);
    if (Width >= a2 && Height >= a2)
    {
      *a4 = a1;
      CVPixelBufferRetain(a1);
      return 0;
    }
    if (Width <= a2)
      Width = a2;
    if (Height > a2)
      a2 = Height;
    pixelBufferOut = 0;
    Attributes = (const __CFDictionary *)_getAttributes();
    if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Width, a2, 0x4C303038u, Attributes, &pixelBufferOut))
    {
      _ARLogGeneral();
      v13 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        LOWORD(buf.data) = 0;
        v14 = "Error: Could not create mask";
        p_buf = (uint8_t *)&buf;
LABEL_22:
        _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, v14, p_buf, 2u);
      }
LABEL_23:

      CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
      CVPixelBufferUnlockBaseAddress(a1, 0);
      CVPixelBufferRelease(pixelBufferOut);
      return 4294960636;
    }
    CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
    CVPixelBufferLockBaseAddress(a1, 0);
    buf.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
    buf.height = CVPixelBufferGetHeight(pixelBufferOut);
    buf.width = CVPixelBufferGetWidth(pixelBufferOut);
    buf.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    src.data = CVPixelBufferGetBaseAddress(a1);
    src.height = CVPixelBufferGetHeight(a1);
    src.width = CVPixelBufferGetWidth(a1);
    src.rowBytes = CVPixelBufferGetBytesPerRow(a1);
    dest.data = buf.data;
    dest.height = src.height;
    dest.width = src.width;
    dest.rowBytes = buf.rowBytes;
    if (vImageOverwriteChannelsWithScalar_Planar8(a3, &buf, 0))
    {
      _ARLogGeneral();
      v13 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v16 = 0;
      v14 = "Error: Could not fill buffer";
    }
    else
    {
      if (!vImageCopyBuffer(&src, &dest, 1uLL, 0))
      {
        CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
        CVPixelBufferUnlockBaseAddress(a1, 0);
        result = 0;
        *a4 = pixelBufferOut;
        return result;
      }
      _ARLogGeneral();
      v13 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
        goto LABEL_23;
      v16 = 0;
      v14 = "Error: Could not copy buffer";
    }
    p_buf = (uint8_t *)&v16;
    goto LABEL_22;
  }
  _ARLogGeneral();
  v11 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(buf.data) = 0;
    _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "Pixelbuffer must have format kCVPixelFormatType_OneComponent8", (uint8_t *)&buf, 2u);
  }

  return 4294960616;
}

uint64_t ARCreateSynchronizationMarker(size_t width, size_t height, CVPixelBufferRef *a3)
{
  vImagePixelCount v4;
  int v5;
  uint64_t result;
  vImagePixelCount v7;
  vImagePixelCount v8;
  int v9;
  int v10;
  int v11;
  vImagePixelCount v12;
  void *data;
  int v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  int v18;
  vImagePixelCount v19;
  size_t v20;
  unsigned int v21;
  vImage_Buffer v22;
  vImage_Buffer dest;
  CVPixelBufferRef pixelBufferOut;

  pixelBufferOut = 0;
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], width, height, 0x4C303038u, 0, &pixelBufferOut))
    return 4294960636;
  CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
  dest.data = CVPixelBufferGetBaseAddress(pixelBufferOut);
  dest.height = CVPixelBufferGetHeight(pixelBufferOut);
  dest.width = CVPixelBufferGetWidth(pixelBufferOut);
  dest.rowBytes = CVPixelBufferGetBytesPerRow(pixelBufferOut);
  if (vImageOverwriteChannelsWithScalar_Planar8(0, &dest, 0x200u)
    || ((v4 = dest.height >> 1, ((dest.height >> 1) & 0x80000000) == 0) ? (v5 = dest.height >> 1) : (v5 = v4 + 1),
        v22.data = (char *)dest.data + (v4 - (v5 >> 1)) * dest.rowBytes - (v5 >> 1) + (dest.width >> 1),
        v22.height = (int)((uint64_t)dest.height >> 1),
        v22.width = v22.height,
        v22.rowBytes = dest.rowBytes,
        vImageOverwriteChannelsWithScalar_Planar8(0xFFu, &v22, 0x200u)))
  {
    CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    CVPixelBufferRelease(pixelBufferOut);
    return 4294960636;
  }
  v8 = v22.height;
  v7 = v22.width;
  if (SLODWORD(v22.width) >= 0)
    v9 = v22.width;
  else
    v9 = LODWORD(v22.width) + 1;
  if (SLODWORD(v22.height) >= 0)
    v10 = v22.height;
  else
    v10 = LODWORD(v22.height) + 1;
  if ((v4 & 0x80000000) == 0)
    v11 = v4;
  else
    v11 = v4 + 3;
  if (v22.height)
  {
    v12 = 0;
    data = v22.data;
    v14 = v9 >> 1;
    v15 = v14 * v14;
    v16 = (v11 >> 2) * (v11 >> 2);
    v17 = -v14;
    v18 = -(v10 >> 1);
    do
    {
      if (v7)
      {
        v19 = 0;
        v20 = (size_t)data + v22.rowBytes * v12;
        do
        {
          v21 = (v18 + v12) * (v18 + v12) + (v17 + v19) * (v17 + v19);
          if (v21 < v15)
            *(_BYTE *)(v20 + v19) = 85;
          if (v21 < v16)
            *(_BYTE *)(v20 + v19) = -86;
          ++v19;
          v7 = v22.width;
        }
        while (v22.width > v19);
        v8 = v22.height;
      }
      ++v12;
    }
    while (v8 > v12);
  }
  CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
  result = 0;
  *a3 = pixelBufferOut;
  return result;
}

size_t ARWrapCVPixelBufferVImage@<X0>(__CVBuffer *a1@<X0>, void **a2@<X8>)
{
  size_t result;

  *a2 = CVPixelBufferGetBaseAddress(a1);
  a2[1] = (void *)CVPixelBufferGetHeight(a1);
  a2[2] = (void *)CVPixelBufferGetWidth(a1);
  result = CVPixelBufferGetBytesPerRow(a1);
  a2[3] = (void *)result;
  return result;
}

size_t ARWrapCVPixelBufferPlaneVImage@<X0>(__CVBuffer *a1@<X0>, size_t a2@<X1>, void **a3@<X8>)
{
  size_t result;

  *a3 = CVPixelBufferGetBaseAddressOfPlane(a1, a2);
  a3[1] = (void *)CVPixelBufferGetHeightOfPlane(a1, a2);
  a3[2] = (void *)CVPixelBufferGetWidthOfPlane(a1, a2);
  result = CVPixelBufferGetBytesPerRowOfPlane(a1, a2);
  a3[3] = (void *)result;
  return result;
}

CVPixelBufferRef ARCreateCVPixelBufferFromPoolWithZeroCopyOption(CVPixelBufferPoolRef *a1, int a2, void *a3, void *a4, int a5, double a6, double a7)
{
  id v13;
  id v14;
  CVReturn v15;
  NSObject *v16;
  objc_class *v17;
  void *v18;
  CVPixelBufferRef v19;
  CVReturn v20;
  NSObject *v21;
  objc_class *v22;
  void *v23;
  __IOSurface *IOSurface;
  CVPixelBufferRef pixelBufferOut;
  uint8_t buf[4];
  void *v28;
  __int16 v29;
  id v30;
  __int16 v31;
  id v32;
  __int16 v33;
  CVReturn v34;
  uint64_t v35;

  v35 = *MEMORY[0x1E0C80C00];
  v13 = a3;
  v14 = a4;
  pixelBufferOut = 0;
  v15 = ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(a1, a2, a5, a6, a7);
  if (v15)
  {
    _ARLogTechnique();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = (objc_class *)objc_opt_class();
      NSStringFromClass(v17);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)buf = 138413058;
      v28 = v18;
      v29 = 2048;
      v30 = v13;
      v31 = 2112;
      v32 = v14;
      v33 = 1024;
      v34 = v15;
      _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, "%@(%p): Unable to configure pixelbuffer pool for %@: %i", buf, 0x26u);

    }
    v19 = 0;
  }
  else
  {
    v20 = CVPixelBufferPoolCreatePixelBuffer((CFAllocatorRef)*MEMORY[0x1E0C9AE00], *a1, &pixelBufferOut);
    if (v20)
    {
      _ARLogTechnique();
      v21 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      {
        v22 = (objc_class *)objc_opt_class();
        NSStringFromClass(v22);
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138413058;
        v28 = v23;
        v29 = 2048;
        v30 = v13;
        v31 = 2112;
        v32 = v14;
        v33 = 1024;
        v34 = v20;
        _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, "%@(%p): Unable to create pixel buffer for %@: %i", buf, 0x26u);

      }
    }
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("arkit/%s; %@; X/X"),
      "ARCreateCVPixelBufferFromPoolWithZeroCopyOption",
      v14);
    v16 = objc_claimAutoreleasedReturnValue();
    IOSurface = CVPixelBufferGetIOSurface(pixelBufferOut);
    IOSurfaceSetValue(IOSurface, (CFStringRef)*MEMORY[0x1E0CBC048], v16);
    v19 = pixelBufferOut;
  }

  return v19;
}

void sub_1B3A7C5FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(CVPixelBufferPoolRef *a1, int a2, int a3, double a4, double a5)
{
  __CVPixelBufferPool *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t NewWithZeroCopyOption;
  NSObject *v19;
  CVPixelBufferPoolRef v20;
  NSObject *v21;
  int v23;
  CVPixelBufferPoolRef v24;
  __int16 v25;
  uint64_t v26;
  __int16 v27;
  uint64_t v28;
  __int16 v29;
  uint64_t v30;
  __int16 v31;
  int v32;
  __int16 v33;
  int v34;
  __int16 v35;
  int v36;
  uint64_t v37;

  v37 = *MEMORY[0x1E0C80C00];
  v10 = *a1;
  if (v10)
  {
    CVPixelBufferPoolGetPixelBufferAttributes(v10);
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "objectForKeyedSubscript:", *MEMORY[0x1E0CA90E0]);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "integerValue");

    objc_msgSend(v11, "objectForKeyedSubscript:", *MEMORY[0x1E0CA8FD8]);
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = objc_msgSend(v14, "integerValue");

    objc_msgSend(v11, "objectForKeyedSubscript:", *MEMORY[0x1E0CA9040]);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "integerValue");

    if (v13 == (int)a4 && v15 == (int)a5)
    {

      if (v17 == a2)
        return 0;
    }
    else
    {

    }
  }
  else
  {
    v13 = 0;
    v15 = 0;
    v17 = 0;
  }
  _ARLogGeneral();
  v19 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
  {
    v20 = *a1;
    v23 = 134219520;
    v24 = v20;
    v25 = 2048;
    v26 = v13;
    v27 = 2048;
    v28 = v15;
    v29 = 2048;
    v30 = v17;
    v31 = 1024;
    v32 = (int)a4;
    v33 = 1024;
    v34 = (int)a5;
    v35 = 1024;
    v36 = a2;
    _os_log_impl(&dword_1B3A68000, v19, OS_LOG_TYPE_INFO, "ARSystemTools: Recreating pixel buffer pool (%p) due to configuration changes: %li,%li/%li => %i,%i/%i", (uint8_t *)&v23, 0x3Cu);
  }

  if (*a1)
  {
    CVPixelBufferPoolRelease(*a1);
    *a1 = 0;
  }
  kdebug_trace();
  NewWithZeroCopyOption = ar_pixelBufferPoolCreateNewWithZeroCopyOption((int)a4, (int)a5, a2, a1, a3);
  kdebug_trace();
  if ((_DWORD)NewWithZeroCopyOption)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      LOWORD(v23) = 0;
      _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, "ARSystemTools: Could not create pixel buffer pool.", (uint8_t *)&v23, 2u);
    }

  }
  return NewWithZeroCopyOption;
}

void sub_1B3A7C8CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id _ARLogTechnique(void)
{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_51);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_118);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_33);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_504);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_51);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_123_0);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_79);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_106);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_90);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_61_0);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_109);
  return (id)_ARLogTechnique(void)::logObj;
}

{
  if (_ARLogTechnique(void)::onceToken != -1)
    dispatch_once(&_ARLogTechnique(void)::onceToken, &__block_literal_global_278);
  return (id)_ARLogTechnique(void)::logObj;
}

CVPixelBufferRef ARCreateCVPixelBufferFromPool(CVPixelBufferPoolRef *a1, int a2, void *a3, void *a4, double a5, double a6)
{
  return ARCreateCVPixelBufferFromPoolWithZeroCopyOption(a1, a2, a3, a4, 0, a5, a6);
}

double ARPixelBufferGetSensorCropRect(__CVBuffer *a1)
{
  void *v1;
  __int128 v3;

  v3 = *MEMORY[0x1E0C9D648];
  if (a1)
  {
    ARPixelBufferGetMetadata(a1);
    v1 = (void *)objc_claimAutoreleasedReturnValue();
    FigCFDictionaryGetCGRectIfPresent();

  }
  return *(double *)&v3;
}

void sub_1B3A7C9B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ARPixelBufferGetMetadata(__CVBuffer *a1)
{
  CFDictionaryRef v1;
  void *v2;

  v1 = CVBufferCopyAttachments(a1, kCVAttachmentMode_ShouldPropagate);
  -[__CFDictionary valueForKey:](v1, "valueForKey:", *MEMORY[0x1E0D04138]);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

void sub_1B3A7CA04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferConvertYCbCrToARGB(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  OSType PixelFormatType;
  int Width;
  int Height;
  OSType v7;
  int v8;
  int v9;
  int32x2_t v10;
  int32x2_t v11;
  const vImage_YpCbCrToARGBMatrix *v12;
  int8x8_t v13;
  int32_t v14;
  NSObject *v15;
  NSObject *v16;
  NSObject *v17;
  uint64_t v18;
  NSObject *v20;
  uint8_t v21[16];
  vImage_Buffer dest;
  vImage_Buffer srcCbCr;
  vImage_Buffer buf;
  vImage_YpCbCrPixelRange pixelRange;
  uint8_t permuteMap[4];
  vImage_YpCbCrToARGB outInfo;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    Width = CVPixelBufferGetWidth(a1);
    Height = CVPixelBufferGetHeight(a1);
    v7 = CVPixelBufferGetPixelFormatType(*a2);
    v8 = CVPixelBufferGetWidth(*a2);
    v9 = CVPixelBufferGetHeight(*a2);
    if (v7 == 32)
    {
      if (v9 == Height && v8 == Width)
      {
        CVPixelBufferLockBaseAddress(*a2, 0);
        CVPixelBufferLockBaseAddress(a1, 0);
        v12 = (const vImage_YpCbCrToARGBMatrix *)*MEMORY[0x1E0C8BDB0];
        *(_DWORD *)permuteMap = 50462976;
        if ((PixelFormatType | 0x10) == 0x34323076)
        {
          v10.i32[0] = 875704422;
          v11.i32[0] = PixelFormatType;
          v13 = vbsl_s8((int8x8_t)vdup_lane_s32(vceq_s32(v11, v10), 0), (int8x8_t)0x1000000FFLL, (int8x8_t)0x10000000EBLL);
          pixelRange.Yp_bias = 16 * (PixelFormatType != 875704422);
          pixelRange.CbCr_bias = 128;
          pixelRange.YpRangeMax = v13.i32[0];
          if (PixelFormatType == 875704422)
            v14 = 255;
          else
            v14 = 240;
          pixelRange.CbCrRangeMax = v14;
          *(int8x8_t *)&pixelRange.YpMax = v13;
          pixelRange.CbCrMax = v14;
          pixelRange.CbCrMin = 16 * (PixelFormatType != 875704422);
          if (vImageConvert_YpCbCrToARGB_GenerateConversion(v12, &pixelRange, &outInfo, kvImage420Yp8_CbCr8, kvImageARGB8888, 0))
          {
            _ARLogGeneral();
            v15 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
            {
              LOWORD(buf.data) = 0;
              _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "Could not generate the conversion format", (uint8_t *)&buf, 2u);
            }

          }
          memset(&buf, 0, sizeof(buf));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(a1, 0, (uint64_t)&buf);
          memset(&srcCbCr, 0, sizeof(srcCbCr));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(a1, 1uLL, (uint64_t)&srcCbCr);
          memset(&dest, 0, sizeof(dest));
          __ARPixelBufferConvertYCbCrToARGB_block_invoke(*a2, 0, (uint64_t)&dest);
          if (!vImageConvert_420Yp8_CbCr8ToARGB8888(&buf, &srcCbCr, &dest, &outInfo, permuteMap, 0xFFu, 0))
          {
            v18 = 0;
            goto LABEL_32;
          }
          _ARLogGeneral();
          v16 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)v21 = 0;
            _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, "Could not convert color formats", v21, 2u);
          }

        }
        else
        {
          _ARLogGeneral();
          v20 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)outInfo.opaque = 0;
            _os_log_impl(&dword_1B3A68000, v20, OS_LOG_TYPE_ERROR, "Pixel format not supported", outInfo.opaque, 2u);
          }

        }
        v18 = 4294960636;
LABEL_32:
        CVPixelBufferUnlockBaseAddress(*a2, 0);
        CVPixelBufferUnlockBaseAddress(a1, 0);
        return v18;
      }
      _ARLogGeneral();
      v17 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)outInfo.opaque = 0;
        _os_log_impl(&dword_1B3A68000, v17, OS_LOG_TYPE_ERROR, "Output pixel buffer must have same dimensions as input pixel buffer", outInfo.opaque, 2u);
      }
    }
    else
    {
      _ARLogGeneral();
      v17 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)outInfo.opaque = 0;
        _os_log_impl(&dword_1B3A68000, v17, OS_LOG_TYPE_ERROR, "Output pixel buffer must have format kCVPixelFormatType_32ARGB", outInfo.opaque, 2u);
      }
    }
  }
  else
  {
    _ARLogGeneral();
    v17 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)outInfo.opaque = 0;
      _os_log_impl(&dword_1B3A68000, v17, OS_LOG_TYPE_ERROR, "Input buffer cannot be null", outInfo.opaque, 2u);
    }
  }

  return 4294960635;
}

CVPixelBufferRef ARCreatePixelBufferWithConversion(__CVBuffer *a1, OSType a2)
{
  OSStatus v4;
  NSObject *v5;
  size_t Width;
  size_t Height;
  CVReturn v8;
  OSStatus v9;
  NSObject *v10;
  CVPixelBufferRef v11;
  _QWORD v13[2];
  void (*v14)(uint64_t);
  void *v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;
  uint64_t v19;
  VTPixelTransferSessionRef v20;
  uint8_t v21[4];
  CVReturn v22;
  uint8_t buf[8];
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  v17 = 0;
  v18 = &v17;
  v19 = 0x2020000000;
  v20 = 0;
  v13[0] = MEMORY[0x1E0C809B0];
  v13[1] = 3221225472;
  v14 = __ARCreatePixelBufferWithConversion_block_invoke;
  v15 = &unk_1E6672308;
  v16 = &v17;
  v4 = VTPixelTransferSessionCreate(0, &v20);
  if (v4)
  {
    _ARLogGeneral();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&buf[4] = v4;
      _os_log_impl(&dword_1B3A68000, v5, OS_LOG_TYPE_ERROR, "Could not create pixel transfer session. Error code: %d", buf, 8u);
    }
LABEL_4:

    goto LABEL_13;
  }
  *(_QWORD *)buf = 0;
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Width, Height, a2, 0, (CVPixelBufferRef *)buf);
  if (v8)
  {
    _ARLogGeneral();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)v21 = 67109120;
      v22 = v8;
      _os_log_impl(&dword_1B3A68000, v5, OS_LOG_TYPE_ERROR, "Could not create RGB24 pixel buffer. Error code: %d", v21, 8u);
    }
    goto LABEL_4;
  }
  v9 = VTPixelTransferSessionTransferImage((VTPixelTransferSessionRef)v18[3], a1, *(CVPixelBufferRef *)buf);
  if (!v9)
  {
    v11 = *(CVPixelBufferRef *)buf;
    goto LABEL_14;
  }
  _ARLogGeneral();
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v21 = 67109120;
    v22 = v9;
    _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "Could not transfer pixel buffer. Error code: %d", v21, 8u);
  }

  CVPixelBufferRelease(*(CVPixelBufferRef *)buf);
LABEL_13:
  v11 = 0;
LABEL_14:
  v14((uint64_t)v13);
  _Block_object_dispose(&v17, 8);
  return v11;
}

void sub_1B3A7D090(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  void (*v6)(uint64_t *);
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, void (*)(uint64_t *));
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferConvertRGBAHalfTo128RGBAFloat(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  OSType PixelFormatType;
  int Width;
  int Height;
  OSType v7;
  int v8;
  int v9;
  vImage_Error v10;
  NSObject *v11;
  uint64_t v12;
  NSObject *v13;
  vImage_Buffer v15;
  vImage_Buffer src;
  _QWORD v17[2];
  uint64_t (*v18)(uint64_t);
  void *v19;
  CVPixelBufferRef *v20;
  __CVBuffer *v21;
  uint8_t buf[4];
  vImage_Error v23;
  uint64_t v24;

  v24 = *MEMORY[0x1E0C80C00];
  if (!a1)
  {
    _ARLogGeneral();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Input buffer cannot be null", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  v7 = CVPixelBufferGetPixelFormatType(*a2);
  v8 = CVPixelBufferGetWidth(*a2);
  v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 1380411457)
  {
    _ARLogGeneral();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Input pixel buffer must have format kCVPixelFormatType_64RGBAHalf", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  if (v7 != 1380410945)
  {
    _ARLogGeneral();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Output pixel buffer must have format kCVPixelFormatType_128RGBAFloat", (uint8_t *)&src, 2u);
    }
    goto LABEL_21;
  }
  if (v9 != Height || v8 != Width)
  {
    _ARLogGeneral();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      LOWORD(src.data) = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Output pixel buffer must have same dimensions as input pixel buffer", (uint8_t *)&src, 2u);
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  v17[0] = MEMORY[0x1E0C809B0];
  v17[1] = 3221225472;
  v18 = __ARPixelBufferConvertRGBAHalfTo128RGBAFloat_block_invoke;
  v19 = &__block_descriptor_48_e5_v8__0l;
  v20 = a2;
  v21 = a1;
  memset(&src, 0, sizeof(src));
  ARWrapCVPixelBufferVImage(a1, &src.data);
  memset(&v15, 0, sizeof(v15));
  ARWrapCVPixelBufferVImage(*a2, &v15.data);
  src.width *= 4;
  v15.width *= 4;
  v10 = vImageConvert_Planar16FtoPlanarF(&src, &v15, 0);
  if (v10)
  {
    _ARLogGeneral();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 134217984;
      v23 = v10;
      _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "vImageConvert_Planar16FtoPlanarF error: %zd", buf, 0xCu);
    }

    v12 = 4294960636;
  }
  else
  {
    v12 = 0;
  }
  v18((uint64_t)v17);
  return v12;
}

void sub_1B3A7D404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *))
{
  a19(&a17);
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferConvertTwoComponent16HalfToRGBAHalf(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  OSType PixelFormatType;
  unsigned int Width;
  int Height;
  OSType v7;
  int v8;
  int v9;
  char *BaseAddress;
  size_t BytesPerRow;
  size_t v12;
  char *v13;
  size_t DataSize;
  uint64_t v15;
  _DWORD *v16;
  int *v17;
  uint64_t v18;
  int v19;
  NSObject *v21;
  const char *v22;
  _QWORD v23[2];
  uint64_t (*v24)(uint64_t);
  void *v25;
  __CVBuffer *v26;
  CVPixelBufferRef *v27;
  uint8_t buf[16];

  if (!a1)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_WORD *)buf = 0;
    v22 = "Input buffer cannot be null";
LABEL_20:
    _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, v22, buf, 2u);
    goto LABEL_21;
  }
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  v7 = CVPixelBufferGetPixelFormatType(*a2);
  v8 = CVPixelBufferGetWidth(*a2);
  v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 843264104)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_WORD *)buf = 0;
    v22 = "Input pixel buffer must have format kCVPixelFormatType_TwoComponent16Half";
    goto LABEL_20;
  }
  if (v7 != 1380411457)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    *(_WORD *)buf = 0;
    v22 = "Output pixel buffer must have format kCVPixelFormatType_64RGBAHalf";
    goto LABEL_20;
  }
  if (v9 != Height || v8 != Width)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v22 = "Output pixel buffer must have same dimensions as input pixel buffer";
      goto LABEL_20;
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(*a2, 0);
  v23[0] = MEMORY[0x1E0C809B0];
  v23[1] = 3221225472;
  v24 = __ARPixelBufferConvertTwoComponent16HalfToRGBAHalf_block_invoke;
  v25 = &__block_descriptor_48_e5_v8__0l;
  v26 = a1;
  v27 = a2;
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  v12 = CVPixelBufferGetBytesPerRow(*a2);
  v13 = (char *)CVPixelBufferGetBaseAddress(*a2);
  DataSize = CVPixelBufferGetDataSize(*a2);
  bzero(v13, DataSize);
  if (Height)
  {
    v15 = 0;
    do
    {
      v16 = v13;
      v17 = (int *)BaseAddress;
      v18 = Width;
      if (Width)
      {
        do
        {
          v19 = *v17++;
          *v16 = v19;
          v16 += 2;
          --v18;
        }
        while (v18);
      }
      ++v15;
      BaseAddress += BytesPerRow;
      v13 += v12;
    }
    while (v15 != Height);
  }
  v24((uint64_t)v23);
  return 0;
}

void sub_1B3A7D6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void (*a11)(uint64_t *))
{
  a11(&a9);
  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferConvertBGRAToARGB(__CVBuffer *a1, CVPixelBufferRef *a2)
{
  OSType PixelFormatType;
  unsigned int Width;
  int Height;
  OSType v7;
  int v8;
  int v9;
  size_t BytesPerRow;
  size_t v11;
  char *BaseAddress;
  char *v13;
  uint8x8_t v14;
  uint64_t v15;
  _DWORD *v16;
  __int32 *v17;
  uint64_t v18;
  __int32 v19;
  int16x8_t v20;
  NSObject *v22;
  const char *v23;
  uint8_t *v24;
  __int16 v25;
  __int16 v26;
  __int16 v27;
  __int16 v28;

  if (!a1)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    v28 = 0;
    v23 = "Input buffer cannot be null";
    v24 = (uint8_t *)&v28;
LABEL_20:
    _os_log_impl(&dword_1B3A68000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_21;
  }
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  v7 = CVPixelBufferGetPixelFormatType(*a2);
  v8 = CVPixelBufferGetWidth(*a2);
  v9 = CVPixelBufferGetHeight(*a2);
  if (PixelFormatType != 1111970369)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    v27 = 0;
    v23 = "Input pixel buffer must have format kCVPixelFormatType_32BGRA";
    v24 = (uint8_t *)&v27;
    goto LABEL_20;
  }
  if (v7 != 32)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    v26 = 0;
    v23 = "Output pixel buffer must have format kCVPixelFormatType_32ARGB";
    v24 = (uint8_t *)&v26;
    goto LABEL_20;
  }
  if (v9 != Height || v8 != Width)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v25 = 0;
      v23 = "Output pixel buffer must have same dimensions as input pixel buffer";
      v24 = (uint8_t *)&v25;
      goto LABEL_20;
    }
LABEL_21:

    return 4294960635;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  v11 = CVPixelBufferGetBytesPerRow(*a2);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  v13 = (char *)CVPixelBufferGetBaseAddress(*a2);
  if (Height)
  {
    v15 = 0;
    do
    {
      v16 = v13;
      v17 = (__int32 *)BaseAddress;
      v18 = Width;
      if (Width)
      {
        do
        {
          v19 = *v17++;
          v14.i32[0] = v19;
          v20 = (int16x8_t)vmovl_u8(v14);
          *(int16x4_t *)v20.i8 = vrev64_s16(*(int16x4_t *)v20.i8);
          v14 = (uint8x8_t)vmovn_s16(v20);
          *v16++ = v14.i32[0];
          --v18;
        }
        while (v18);
      }
      ++v15;
      BaseAddress += BytesPerRow;
      v13 += v11;
    }
    while (v15 != Height);
  }
  CVPixelBufferUnlockBaseAddress(*a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 0;
}

uint64_t AROSTypeFromMTLPixelFormat(uint64_t a1)
{
  uint64_t v1;
  uint64_t i;
  uint64_t v4;
  uint64_t v5;
  NSObject *v6;
  int v8;
  uint64_t v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (a1 == 10)
    return 1278226488;
  for (i = 0; ; i += 24)
  {
    v4 = i + 24;
    if (i == 216)
      break;
    v5 = *(_QWORD *)&FormatList[i + 32];
    if (v5 == a1)
      return *(unsigned int *)&FormatList[v4];
  }
  v1 = 0;
  _ARLogGeneral();
  v6 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
  {
    v8 = 134217984;
    v9 = a1;
    _os_log_impl(&dword_1B3A68000, v6, OS_LOG_TYPE_ERROR, "MTLPixelFormat not supported %lu", (uint8_t *)&v8, 0xCu);
  }

  return v1;
}

uint64_t ARMTLPixelFormatFromOSType(unsigned int a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  void *v5;
  int v7;
  void *v8;
  uint64_t v9;

  v2 = 0;
  v9 = *MEMORY[0x1E0C80C00];
  v3 = 1278226488;
  do
  {
    if (v3 == a1)
      return *(_QWORD *)&FormatList[v2 + 8];
    v3 = *(_DWORD *)&FormatList[v2 + 24];
    v2 += 24;
  }
  while (v2 != 240);
  _ARLogGeneral();
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    AROSTypeToString(a1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = 138543362;
    v8 = v5;
    _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "OSType not supported %{public}@", (uint8_t *)&v7, 0xCu);

  }
  return 0;
}

void sub_1B3A7DB74(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id AROSTypeToString(unsigned int a1)
{
  char *v1;
  int i;
  unsigned int v3;
  unsigned int v4;
  char v5;
  char v6;
  char v7;
  char *v8;
  char v10;
  _BYTE v11[39];

  *(_QWORD *)&v11[31] = *MEMORY[0x1E0C80C00];
  if (a1)
  {
    v1 = &v10;
    for (i = 24; i != -8; i -= 8)
    {
      v3 = a1 >> i;
      v4 = (a1 >> i);
      if (v4 - 127 > 0xFFFFFFA0)
      {
        v8 = v1 + 1;
      }
      else
      {
        v3 = (a1 >> i) & 0xF;
        if (v4 >= 0xA0)
          v5 = 55;
        else
          v5 = 48;
        v1[1] = v5 + ((a1 >> i) >> 4);
        if (v3 >= 0xA)
          v6 = 55;
        else
          v6 = 48;
        v7 = v6 + v3;
        v8 = v1 + 3;
        v1[2] = v7;
        LOBYTE(v3) = 36;
      }
      *v1 = v3;
      v1 = v8;
    }
  }
  else
  {
    v8 = v11;
    v10 = 48;
  }
  *v8 = 0;
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", &v10);
  return (id)objc_claimAutoreleasedReturnValue();
}

uint64_t ARBytesPerElement(unsigned int a1)
{
  uint64_t v2;
  int v3;
  NSObject *v4;
  void *v5;
  int v7;
  void *v8;
  uint64_t v9;

  v2 = 0;
  v9 = *MEMORY[0x1E0C80C00];
  v3 = 1278226488;
  do
  {
    if (v3 == a1)
      return *(int *)&FormatList[v2 + 16];
    v3 = *(_DWORD *)&FormatList[v2 + 24];
    v2 += 24;
  }
  while (v2 != 240);
  _ARLogGeneral();
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    AROSTypeToString(a1);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = 138543362;
    v8 = v5;
    _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "OSType not supported %{public}@", (uint8_t *)&v7, 0xCu);

  }
  return 0;
}

void sub_1B3A7DD60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

__CFDictionary *ar_createAttributeDictionaryNewWithZeroCopyOption(unsigned int a1, unsigned int a2, int a3, int a4)
{
  const __CFAllocator *v5;
  __CFDictionary *Mutable;
  CFNumberRef v7;
  CFNumberRef v8;
  CFMutableDictionaryRef v9;
  CFMutableDictionaryRef v10;
  CFNumberRef v11;
  CFNumberRef v12;
  CFNumberRef v13;
  CFNumberRef v14;
  CFNumberRef v15;
  CFNumberRef v16;
  uint64_t v18;
  unint64_t v19;

  v19 = __PAIR64__(a1, a2);
  LODWORD(v18) = 16;
  HIDWORD(v18) = a3;
  v5 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  Mutable = CFDictionaryCreateMutable((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  if (Mutable)
  {
    v7 = CFNumberCreate(v5, kCFNumberIntType, (char *)&v18 + 4);
    if (!v7)
      goto LABEL_9;
    v8 = v7;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA9040], v7);
    CFRelease(v8);
    v9 = CFDictionaryCreateMutable(v5, 0, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
    if (!v9)
      goto LABEL_9;
    v10 = v9;
    CFDictionaryAddValue(Mutable, (const void *)*MEMORY[0x1E0CA8FF0], v9);
    CFRelease(v10);
    v11 = CFNumberCreate(v5, kCFNumberIntType, (char *)&v19 + 4);
    if (!v11)
      goto LABEL_9;
    v12 = v11;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA90E0], v11);
    CFRelease(v12);
    v13 = CFNumberCreate(v5, kCFNumberIntType, &v19);
    if (!v13)
      goto LABEL_9;
    v14 = v13;
    CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8FD8], v13);
    CFRelease(v14);
    v15 = CFNumberCreate(v5, kCFNumberIntType, &v18);
    if (v15)
    {
      v16 = v15;
      CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA9048], v15);
      CFRelease(v16);
      if (a4)
        CFDictionarySetValue(Mutable, (const void *)*MEMORY[0x1E0CA8F68], (const void *)objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", 64, v18, v19));
    }
    else
    {
LABEL_9:
      CFRelease(Mutable);
      return 0;
    }
  }
  return Mutable;
}

__CFDictionary *ar_createAttributeDictionaryNew(unsigned int a1, unsigned int a2, int a3)
{
  return ar_createAttributeDictionaryNewWithZeroCopyOption(a1, a2, a3, 0);
}

uint64_t ar_pixelBufferPoolCreateNewWithZeroCopyOption(unsigned int a1, unsigned int a2, int a3, __CVPixelBufferPool **a4, int a5)
{
  __CFDictionary *AttributeDictionaryNewWithZeroCopyOption;
  __CFDictionary *v7;
  uint64_t v8;

  AttributeDictionaryNewWithZeroCopyOption = ar_createAttributeDictionaryNewWithZeroCopyOption(a1, a2, a3, a5);
  if (AttributeDictionaryNewWithZeroCopyOption)
  {
    v7 = AttributeDictionaryNewWithZeroCopyOption;
    v8 = CVPixelBufferPoolCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], 0, AttributeDictionaryNewWithZeroCopyOption, a4);
    CFRelease(v7);
    if (!(_DWORD)v8)
      return v8;
  }
  else
  {
    v8 = 4294960636;
  }
  *a4 = 0;
  return v8;
}

uint64_t ar_pixelBufferPoolCreateNew(unsigned int a1, unsigned int a2, int a3, __CVPixelBufferPool **a4)
{
  return ar_pixelBufferPoolCreateNewWithZeroCopyOption(a1, a2, a3, a4, 0);
}

uint64_t ARRecreatePixelBufferPoolOnConfigurationChanges(CVPixelBufferPoolRef *a1, int a2, double a3, double a4)
{
  return ARRecreatePixelBufferPoolOnConfigurationChangesWithZeroCopyOption(a1, a2, 0, a3, a4);
}

id ARPixelBufferToDictionaryRepresentation(__CVBuffer *a1)
{
  size_t Width;
  size_t Height;
  uint64_t PixelFormatType;
  size_t BytesPerRow;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  _QWORD v13[5];
  _QWORD v14[6];

  v14[5] = *MEMORY[0x1E0C80C00];
  if (!a1)
    return 0;
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  CVPixelBufferLockBaseAddress(a1, 0);
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", CVPixelBufferGetBaseAddress(a1), BytesPerRow * Height);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  CVPixelBufferUnlockBaseAddress(a1, 0);
  v14[0] = v6;
  v13[0] = CFSTR("ARPixelBufferData");
  v13[1] = CFSTR("ARPixelBufferWidth");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", Width);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v14[1] = v7;
  v13[2] = CFSTR("ARPixelBufferHeight");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", Height);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v14[2] = v8;
  v13[3] = CFSTR("ARPixelBufferBytesPerRow");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", BytesPerRow);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v14[3] = v9;
  v13[4] = CFSTR("ARPixelBufferFormat");
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInt:", PixelFormatType);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v14[4] = v10;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v14, v13, 5);
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  return v11;
}

void sub_1B3A7E17C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferFromDictionaryRepresentation(void *a1, CVPixelBufferRef *a2)
{
  id v3;
  void *v4;
  uint64_t v5;
  void *v6;
  size_t v7;
  void *v8;
  size_t v9;
  void *v10;
  OSType v11;
  void *v12;
  size_t v13;
  void *v14;
  void *v15;

  v3 = a1;
  v4 = v3;
  v5 = 4294960635;
  if (v3 && a2)
  {
    objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("ARPixelBufferWidth"));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = objc_msgSend(v6, "unsignedIntegerValue");

    objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("ARPixelBufferHeight"));
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = objc_msgSend(v8, "unsignedIntegerValue");

    objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("ARPixelBufferFormat"));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    v11 = objc_msgSend(v10, "unsignedIntValue");

    objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("ARPixelBufferBytesPerRow"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    v13 = objc_msgSend(v12, "unsignedIntegerValue");

    objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("ARPixelBufferData"));
    v14 = (void *)objc_claimAutoreleasedReturnValue();
    v15 = v14;
    if (v7 && v9 && v11 && v13 && v14)
      v5 = CVPixelBufferCreateWithBytes(0, v7, v9, v11, (void *)objc_msgSend(objc_retainAutorelease(v14), "bytes"), v13, 0, 0, 0, a2);

  }
  return v5;
}

void sub_1B3A7E324(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ARUnWrapOneComponent16BufferDepth32BitsBuffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType;
  OSType v5;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  char *BaseAddress;
  char *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint8_t *v18;
  uint64_t i;
  uint64_t v21;
  size_t v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1278226742 || v5 != 1717855600)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_17;
    v25 = 0;
    v17 = "Source buffer must have pixel format kCVPixelFormatType_OneComponent16 and destination buffer kCVPixelFormatTy"
          "pe_DepthFloat32.";
    v18 = (uint8_t *)&v25;
LABEL_16:
    _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, v17, v18, 2u);
    goto LABEL_17;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v9 = CVPixelBufferGetBytesPerRow(a2);
  v10 = CVPixelBufferGetHeight(a2);
  v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_17;
    v24 = 0;
    v17 = "Source buffer and destination buffer must have the same height";
    v18 = (uint8_t *)&v24;
    goto LABEL_16;
  }
  v12 = v11;
  if (Width != 2 * v11)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v23 = 0;
      v17 = "Source buffer must have double the width of the source buffer";
      v18 = (uint8_t *)&v23;
      goto LABEL_16;
    }
LABEL_17:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  v14 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (BytesPerRow == v9)
  {
    if (Height)
    {
      v15 = 0;
      do
      {
        memcpy(&v14[v15], &BaseAddress[v15], BytesPerRow);
        v15 += BytesPerRow;
        --Height;
      }
      while (Height);
    }
  }
  else if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      if (v12)
      {
        v21 = 0;
        v22 = v12;
        do
        {
          *(_WORD *)&v14[v21] = *(_WORD *)&BaseAddress[i * BytesPerRow + (v21 & 0xFFFFFFFC)];
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      v14 += v9;
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent16Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType;
  OSType v5;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v9;
  size_t v10;
  size_t v11;
  char *BaseAddress;
  char *v13;
  char *v14;
  uint64_t v15;
  NSObject *v16;
  const char *v17;
  uint8_t *v18;
  uint64_t i;
  uint64_t v21;
  size_t v22;
  __int16 v23;
  __int16 v24;
  __int16 v25;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v5 != 1278226742)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_17;
    v25 = 0;
    v17 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent16";
    v18 = (uint8_t *)&v25;
LABEL_16:
    _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, v17, v18, 2u);
    goto LABEL_17;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v9 = CVPixelBufferGetBytesPerRow(a2);
  v10 = CVPixelBufferGetHeight(a2);
  v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
      goto LABEL_17;
    v24 = 0;
    v17 = "Source buffer and destination buffer must have the same height";
    v18 = (uint8_t *)&v24;
    goto LABEL_16;
  }
  if (v11 != 2 * Width)
  {
    _ARLogGeneral();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v23 = 0;
      v17 = "Destination buffer must have double the width of the source buffer";
      v18 = (uint8_t *)&v23;
      goto LABEL_16;
    }
LABEL_17:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  v13 = (char *)CVPixelBufferGetBaseAddress(a2);
  v14 = v13;
  if (v9 == BytesPerRow)
  {
    if (Height)
    {
      v15 = 0;
      do
      {
        memcpy(&v14[v15], &BaseAddress[v15], BytesPerRow);
        v15 += BytesPerRow;
        --Height;
      }
      while (Height);
    }
  }
  else if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      if (Width)
      {
        v21 = 0;
        v22 = Width;
        do
        {
          *(_DWORD *)&v13[i * v9 + (v21 & 0xFFFFFFFC)] = *(_DWORD *)&BaseAddress[v21];
          v21 += 4;
          --v22;
        }
        while (v22);
      }
      BaseAddress += BytesPerRow;
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent8BufferWithScale(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType;
  OSType v7;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v11;
  size_t v12;
  size_t v13;
  float *BaseAddress;
  _BYTE *v15;
  uint64_t i;
  size_t v17;
  _BYTE *v18;
  float *j;
  float v20;
  NSObject *v22;
  const char *v23;
  uint8_t *v24;
  __int16 v25;
  __int16 v26;
  __int16 v27;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1278226488)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v27 = 0;
    v23 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent8";
    v24 = (uint8_t *)&v27;
LABEL_17:
    _os_log_impl(&dword_1B3A68000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_18;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v11 = CVPixelBufferGetBytesPerRow(a2);
  v12 = CVPixelBufferGetHeight(a2);
  v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v26 = 0;
    v23 = "Source buffer and destination buffer must have the same height";
    v24 = (uint8_t *)&v26;
    goto LABEL_17;
  }
  if (Width != v13)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v25 = 0;
      v23 = "Destination buffer must have the same width as the source buffer";
      v24 = (uint8_t *)&v25;
      goto LABEL_17;
    }
LABEL_18:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  v15 = CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      v17 = Width;
      v18 = v15;
      for (j = BaseAddress; v17; --v17)
      {
        v20 = *j++;
        *v18++ = (int)(float)(v20 * a3);
      }
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      v15 += v11;
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBufferOneComponent16BufferWithScale(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType;
  OSType v7;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v11;
  size_t v12;
  size_t v13;
  float *BaseAddress;
  char *v15;
  uint64_t i;
  size_t v17;
  float *v18;
  _WORD *j;
  float v20;
  NSObject *v22;
  const char *v23;
  uint8_t *v24;
  __int16 v25;
  __int16 v26;
  uint8_t buf[2];

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1278226742 && v7 != 1647392359)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
LABEL_15:

      return 0;
    }
    *(_WORD *)buf = 0;
    v23 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_OneComponent16";
    v24 = buf;
LABEL_14:
    _os_log_impl(&dword_1B3A68000, v22, OS_LOG_TYPE_ERROR, v23, v24, 2u);
    goto LABEL_15;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v11 = CVPixelBufferGetBytesPerRow(a2);
  v12 = CVPixelBufferGetHeight(a2);
  v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    v26 = 0;
    v23 = "Source buffer and destination buffer must have the same height";
    v24 = (uint8_t *)&v26;
    goto LABEL_14;
  }
  if (Width != v13)
  {
    _ARLogGeneral();
    v22 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      goto LABEL_15;
    v25 = 0;
    v23 = "Destination buffer must have the same width as the source buffer";
    v24 = (uint8_t *)&v25;
    goto LABEL_14;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  v15 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      v17 = Width;
      v18 = BaseAddress;
      for (j = v15; v17; --v17)
      {
        v20 = *v18++;
        *j++ = (int)(float)(v20 * a3);
      }
      v15 += v11;
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARWrapDepth32BitsBuffer_FixedPointUnsigned13_3_OneComponent16Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  return ARWrapDepth32BitsBufferOneComponent16BufferWithScale(a1, a2, 8000.0);
}

uint64_t ARConvertDepthFloatingPointBufferToFixedPointUnsigned13_3Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType;
  OSType v5;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v9;
  size_t v10;
  size_t v11;
  float *v12;
  char *v13;
  uint64_t k;
  float *v15;
  _WORD *v16;
  size_t m;
  float v18;
  NSObject *v19;
  const char *v20;
  uint8_t *v21;
  char *BaseAddress;
  char *v24;
  uint64_t i;
  __int16 *v26;
  _WORD *v27;
  size_t j;
  __int16 v29;
  __int16 v36;
  __int16 v37;
  __int16 v38;
  __int16 v39;
  __int16 v40;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1751410032 && PixelFormatType != 1717855600 || v5 != 825437747)
  {
    _ARLogGeneral();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v36 = 0;
      v20 = "Source buffer must have either kCVPixelFormatType_DepthFloat16 or kCVPixelFormatType_DepthFloat32 pixel form"
            "at, destination buffer should have kCVPixelFormatType_FixedPointUnsigned13_3 pixel format";
      v21 = (uint8_t *)&v36;
LABEL_15:
      _os_log_impl(&dword_1B3A68000, v19, OS_LOG_TYPE_ERROR, v20, v21, 2u);
    }
LABEL_16:

    return 0;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v9 = CVPixelBufferGetBytesPerRow(a2);
  v10 = CVPixelBufferGetHeight(a2);
  v11 = CVPixelBufferGetWidth(a2);
  if (PixelFormatType != 1717855600)
  {
    if (Height != v10)
    {
      _ARLogGeneral();
      v19 = objc_claimAutoreleasedReturnValue();
      if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        goto LABEL_16;
      v40 = 0;
      v20 = "Source buffer and destination buffer must have the same height";
      v21 = (uint8_t *)&v40;
      goto LABEL_15;
    }
    if (Width == v11)
    {
      CVPixelBufferLockBaseAddress(a1, 0);
      CVPixelBufferLockBaseAddress(a2, 0);
      BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
      v24 = (char *)CVPixelBufferGetBaseAddress(a2);
      if (Height)
      {
        for (i = 0; i != Height; ++i)
        {
          v26 = (__int16 *)BaseAddress;
          v27 = v24;
          for (j = Width; j; --j)
          {
            v29 = *v26++;
            _H0 = v29;
            __asm { FCVT            S0, H0 }
            *v27++ = (int)(float)(_S0 * 8000.0);
          }
          v24 += v9;
          BaseAddress += BytesPerRow;
        }
      }
      goto LABEL_24;
    }
    _ARLogGeneral();
    v19 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      v39 = 0;
      v20 = "Destination buffer must have the same width as the source buffer";
      v21 = (uint8_t *)&v39;
      goto LABEL_15;
    }
    goto LABEL_16;
  }
  if (Height != v10)
  {
    _ARLogGeneral();
    v19 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    v38 = 0;
    v20 = "Source buffer and destination buffer must have the same height";
    v21 = (uint8_t *)&v38;
    goto LABEL_15;
  }
  if (Width != v11)
  {
    _ARLogGeneral();
    v19 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      goto LABEL_16;
    v37 = 0;
    v20 = "Destination buffer must have the same width as the source buffer";
    v21 = (uint8_t *)&v37;
    goto LABEL_15;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  v12 = (float *)CVPixelBufferGetBaseAddress(a1);
  v13 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (k = 0; k != Height; ++k)
    {
      v15 = v12;
      v16 = v13;
      for (m = Width; m; --m)
      {
        v18 = *v15++;
        *v16++ = (int)(float)(v18 * 8000.0);
      }
      v13 += v9;
      v12 = (float *)((char *)v12 + BytesPerRow);
    }
  }
LABEL_24:
  CVPixelBufferUnlockBaseAddress(a2, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  return 1;
}

uint64_t ARUnWrapFixedPointUnsigned13_3_OneComponent16Buffer_Depth32BitsBuffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType;
  OSType v5;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v9;
  size_t v10;
  size_t v11;
  unsigned __int16 *BaseAddress;
  float *v13;
  uint64_t i;
  size_t v15;
  unsigned __int16 *v16;
  float *j;
  unsigned int v18;
  float v19;
  NSObject *v21;
  const char *v22;
  uint8_t *v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 825437747 && PixelFormatType != 1647392359 && PixelFormatType != 1278226742
    || v5 != 1717855600)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
    v26 = 0;
    v22 = "Source buffer must have pixel format kCVPixelFormatType_OneComponent16, kCVPixelFormatType_FixedPointUnsigned1"
          "3_3, or kCVPixelFormatType_16Gray and destination buffer kCVPixelFormatType_DepthFloat32.";
    v23 = (uint8_t *)&v26;
LABEL_19:
    _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, v22, v23, 2u);
    goto LABEL_20;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v9 = CVPixelBufferGetBytesPerRow(a2);
  v10 = CVPixelBufferGetHeight(a2);
  v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_20;
    v25 = 0;
    v22 = "Source buffer and destination buffer must have the same height";
    v23 = (uint8_t *)&v25;
    goto LABEL_19;
  }
  if (Width != v11)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v24 = 0;
      v22 = "Source buffer must have the same width of the source buffer";
      v23 = (uint8_t *)&v24;
      goto LABEL_19;
    }
LABEL_20:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (unsigned __int16 *)CVPixelBufferGetBaseAddress(a1);
  v13 = (float *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      v15 = Width;
      v16 = BaseAddress;
      for (j = v13; v15; --v15)
      {
        v18 = *v16++;
        v19 = (double)v18 * 0.000125;
        *j++ = v19;
      }
      v13 = (float *)((char *)v13 + v9);
      BaseAddress = (unsigned __int16 *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARConvertFixedPointUnsigned13_3ToDepthFloat32Buffer(__CVBuffer *a1, __CVBuffer *a2)
{
  OSType PixelFormatType;
  OSType v5;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v9;
  size_t v10;
  size_t v11;
  unsigned __int16 *BaseAddress;
  float *v13;
  uint64_t i;
  size_t v15;
  unsigned __int16 *v16;
  float *j;
  unsigned int v18;
  float v19;
  NSObject *v21;
  const char *v22;
  uint8_t *v23;
  __int16 v24;
  __int16 v25;
  __int16 v26;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 825437747 || v5 != 1717855600)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v26 = 0;
    v22 = "Source buffer must have pixel format kCVPixelFormatType_FixedPointUnsigned13_3 and destination buffer kCVPixel"
          "FormatType_DepthFloat32.";
    v23 = (uint8_t *)&v26;
LABEL_17:
    _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, v22, v23, 2u);
    goto LABEL_18;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v9 = CVPixelBufferGetBytesPerRow(a2);
  v10 = CVPixelBufferGetHeight(a2);
  v11 = CVPixelBufferGetWidth(a2);
  if (Height != v10)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
      goto LABEL_18;
    v25 = 0;
    v22 = "Source buffer and destination buffer must have the same height";
    v23 = (uint8_t *)&v25;
    goto LABEL_17;
  }
  if (Width != v11)
  {
    _ARLogGeneral();
    v21 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      v24 = 0;
      v22 = "Source buffer must have the same width of the source buffer";
      v23 = (uint8_t *)&v24;
      goto LABEL_17;
    }
LABEL_18:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (unsigned __int16 *)CVPixelBufferGetBaseAddress(a1);
  v13 = (float *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    for (i = 0; i != Height; ++i)
    {
      v15 = Width;
      v16 = BaseAddress;
      for (j = v13; v15; --v15)
      {
        v18 = *v16++;
        v19 = (double)v18 * 0.000125;
        *j++ = v19;
      }
      v13 = (float *)((char *)v13 + v9);
      BaseAddress = (unsigned __int16 *)((char *)BaseAddress + BytesPerRow);
    }
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

uint64_t ARDepth32BitsBufferToBGRAWithScaling(__CVBuffer *a1, __CVBuffer *a2, float a3)
{
  OSType PixelFormatType;
  OSType v7;
  size_t BytesPerRow;
  size_t Height;
  size_t Width;
  size_t v11;
  size_t v12;
  size_t v13;
  float *BaseAddress;
  char *v15;
  uint64_t v16;
  _BYTE *v17;
  _BYTE *v18;
  size_t v19;
  float *i;
  double v21;
  float v22;
  int v23;
  float v24;
  int v25;
  float v26;
  int v27;
  NSObject *v29;
  const char *v30;
  uint8_t *v31;
  __int16 v32;
  __int16 v33;
  __int16 v34;

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v7 = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1717855600 || v7 != 1111970369)
  {
    _ARLogGeneral();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_31;
    v34 = 0;
    v30 = "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32 and destination buffer kCVPixelFormatType_32BGRA.";
    v31 = (uint8_t *)&v34;
LABEL_30:
    _os_log_impl(&dword_1B3A68000, v29, OS_LOG_TYPE_ERROR, v30, v31, 2u);
    goto LABEL_31;
  }
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v11 = CVPixelBufferGetBytesPerRow(a2);
  v12 = CVPixelBufferGetHeight(a2);
  v13 = CVPixelBufferGetWidth(a2);
  if (Height != v12)
  {
    _ARLogGeneral();
    v29 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
      goto LABEL_31;
    v33 = 0;
    v30 = "Source buffer and destination buffer must have the same height";
    v31 = (uint8_t *)&v33;
    goto LABEL_30;
  }
  if (Width != v13)
  {
    _ARLogGeneral();
    v29 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_ERROR))
    {
      v32 = 0;
      v30 = "Source buffer must have the same width of the source buffer";
      v31 = (uint8_t *)&v32;
      goto LABEL_30;
    }
LABEL_31:

    return 0;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
  v15 = (char *)CVPixelBufferGetBaseAddress(a2);
  if (Height)
  {
    v16 = 0;
    v17 = v15 + 1;
    do
    {
      v18 = v17;
      v19 = Width;
      for (i = BaseAddress; v19; --v19)
      {
        v21 = (float)((float)(*i * a3) * 0.25);
        v22 = (fabs(v21 + -0.25) * -4.0 + 1.5) * 255.0;
        v23 = (int)v22;
        if (v22 > 255.0)
          LOBYTE(v23) = -1;
        if (v22 < 0.0)
          LOBYTE(v23) = 0;
        *(v18 - 1) = v23;
        v24 = (fabs(v21 + -0.5) * -4.0 + 1.5) * 255.0;
        v25 = (int)v24;
        if (v24 > 255.0)
          LOBYTE(v25) = -1;
        if (v24 < 0.0)
          LOBYTE(v25) = 0;
        *v18 = v25;
        v26 = (fabs(v21 + -0.75) * -4.0 + 1.5) * 255.0;
        if (v26 >= 0.0)
        {
          if (v26 <= 255.0)
            v27 = (int)v26;
          else
            LOBYTE(v27) = -1;
        }
        else
        {
          LOBYTE(v27) = 0;
        }
        v18[1] = v27;
        v18[2] = -1;
        ++i;
        v18 += 4;
      }
      ++v16;
      BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      v17 += v11;
    }
    while (v16 != Height);
  }
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  return 1;
}

void ARDepth32ImageAverageDepth(__CVBuffer *a1)
{
  size_t BytesPerRow;
  size_t Width;
  size_t Height;
  float *BaseAddress;
  uint64_t v6;
  int v7;
  float v8;
  size_t v9;
  float *v10;
  float v11;
  NSObject *v12;
  uint8_t v13[16];

  if (CVPixelBufferGetPixelFormatType(a1) == 1717855600)
  {
    BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    Width = CVPixelBufferGetWidth(a1);
    Height = CVPixelBufferGetHeight(a1);
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    BaseAddress = (float *)CVPixelBufferGetBaseAddress(a1);
    if (Height)
    {
      v6 = 0;
      v7 = 0;
      v8 = 0.0;
      do
      {
        if (Width)
        {
          v9 = Width;
          v10 = BaseAddress;
          do
          {
            v11 = *v10++;
            v8 = v8 + v11;
            --v9;
          }
          while (v9);
          v7 += Width;
        }
        ++v6;
        BaseAddress = (float *)((char *)BaseAddress + BytesPerRow);
      }
      while (v6 != Height);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  else
  {
    _ARLogGeneral();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v13 = 0;
      _os_log_impl(&dword_1B3A68000, v12, OS_LOG_TYPE_ERROR, "Source buffer must have pixel format kCVPixelFormatType_DepthFloat32.", v13, 2u);
    }

  }
}

void ARDepth16ImageAverageDepth(__CVBuffer *a1)
{
  OSType PixelFormatType;
  OSType v3;
  size_t BytesPerRow;
  size_t Width;
  size_t Height;
  char *BaseAddress;
  uint64_t v8;
  int v9;
  float v10;
  size_t v11;
  __int16 *v12;
  __int16 v13;
  NSObject *v20;
  uint8_t v21[16];

  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v3 = PixelFormatType;
  if (PixelFormatType == 1278226536 || PixelFormatType == 1751410032 || PixelFormatType == 1751411059)
  {
    BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    Width = CVPixelBufferGetWidth(a1);
    Height = CVPixelBufferGetHeight(a1);
    CVPixelBufferLockBaseAddress(a1, 1uLL);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    if (Height)
    {
      v8 = 0;
      v9 = 0;
      v10 = 0.0;
      do
      {
        if (Width)
        {
          v11 = Width;
          v12 = (__int16 *)BaseAddress;
          do
          {
            v13 = *v12++;
            _H1 = v13;
            __asm { FCVT            S1, H1 }
            if (_S1 != 0.0 && v3 == 1751411059)
              _S1 = 1.0 / _S1;
            v10 = v10 + _S1;
            --v11;
          }
          while (v11);
          v9 += Width;
        }
        ++v8;
        BaseAddress += BytesPerRow;
      }
      while (v8 != Height);
    }
    CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  }
  else
  {
    _ARLogGeneral();
    v20 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v21 = 0;
      _os_log_impl(&dword_1B3A68000, v20, OS_LOG_TYPE_ERROR, "Source buffer must have pixel format kCVPixelFormatType_OneComponent16Half, kCVPixelFormatType_DepthFloat16 or kCVPixelFormatType_DisparityFloat16.", v21, 2u);
    }

  }
}

uint64_t ARDepth32BitsBufferToBGRA(__CVBuffer *a1, __CVBuffer *a2)
{
  return ARDepth32BitsBufferToBGRAWithScaling(a1, a2, 1.0);
}

id ARDepthRepresentationDictionaryClassList()
{
  if (ARDepthRepresentationDictionaryClassList::onceToken != -1)
    dispatch_once(&ARDepthRepresentationDictionaryClassList::onceToken, &__block_literal_global_41);
  return (id)ARDepthRepresentationDictionaryClassList::depthMetadataClasses;
}

id ARDepthRepresentationDictionary(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  v1 = a1;
  if (v1)
  {
    v2 = (void *)objc_opt_new();
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithShort:", objc_msgSend(v1, "depthDataVersionMajor"));
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKey:", v3, *MEMORY[0x1E0D052F8]);

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v1, "depthDataQuality"));
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKey:", v4, *MEMORY[0x1E0D052F0]);

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithBool:", objc_msgSend(v1, "isDepthDataFiltered"));
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKey:", v5, *MEMORY[0x1E0D052B8]);

    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", objc_msgSend(v1, "depthDataAccuracy"));
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKey:", v6, *MEMORY[0x1E0D052A8]);

    v7 = (void *)MEMORY[0x1E0CB37E8];
    objc_msgSend(v1, "depthBlurEffectSimulatedAperture");
    objc_msgSend(v7, "numberWithFloat:");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKey:", v8, *MEMORY[0x1E0D051E0]);

    objc_msgSend(v1, "depthBlurEffectRenderingParameters");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    if (v9)
    {
      objc_msgSend(v1, "depthBlurEffectRenderingParameters");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "setObject:forKey:", v10, *MEMORY[0x1E0D051D8]);

    }
    objc_msgSend(v1, "cameraCalibrationData");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "cameraCalibrationDataDictionary");
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "addEntriesFromDictionary:", v12);

  }
  else
  {
    v2 = 0;
  }

  return v2;
}

void sub_1B3A7FC28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreatePixelBufferFromCGImage(CGImage *a1)
{
  uint64_t v2;
  const __CFDictionary *v3;
  size_t Width;
  size_t Height;
  BOOL v6;
  NSObject *v7;
  void *BaseAddress;
  size_t BitsPerComponent;
  size_t BytesPerRow;
  CGColorSpace *DeviceRGB;
  size_t v12;
  size_t v13;
  CGContext *v14;
  size_t v15;
  size_t v16;
  CVPixelBufferRef v17;
  CGAffineTransform v19;
  uint8_t buf[16];
  CVPixelBufferRef pixelBufferOut;
  _QWORD v22[2];
  _QWORD v23[3];
  CGRect v24;

  v23[2] = *MEMORY[0x1E0C80C00];
  v2 = *MEMORY[0x1E0CA8F70];
  v22[0] = *MEMORY[0x1E0CA8F78];
  v22[1] = v2;
  v23[0] = MEMORY[0x1E0C9AAB0];
  v23[1] = MEMORY[0x1E0C9AAB0];
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v23, v22, 2);
  v3 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  pixelBufferOut = 0;
  Width = CGImageGetWidth(a1);
  Height = CGImageGetHeight(a1);
  if (CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Width, Height, 0x20u, v3, &pixelBufferOut))
    v6 = 1;
  else
    v6 = pixelBufferOut == 0;
  if (v6)
  {
    _ARLogGeneral();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v7, OS_LOG_TYPE_ERROR, "Operation failed: Could not create a pixel buffer", buf, 2u);
    }

    v17 = 0;
  }
  else
  {
    CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
    BaseAddress = CVPixelBufferGetBaseAddress(pixelBufferOut);
    BitsPerComponent = CGImageGetBitsPerComponent(a1);
    BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
    DeviceRGB = CGColorSpaceCreateDeviceRGB();
    v12 = CGImageGetWidth(a1);
    v13 = CGImageGetHeight(a1);
    v14 = CGBitmapContextCreate(BaseAddress, v12, v13, BitsPerComponent, BytesPerRow, DeviceRGB, 6u);
    CGAffineTransformMakeRotation(&v19, 0.0);
    CGContextConcatCTM(v14, &v19);
    v15 = CGImageGetWidth(a1);
    v16 = CGImageGetHeight(a1);
    v24.size.width = (double)v15;
    v24.size.height = (double)v16;
    v24.origin.x = 0.0;
    v24.origin.y = 0.0;
    CGContextDrawImage(v14, v24, a1);
    CGColorSpaceRelease(DeviceRGB);
    CGContextRelease(v14);
    CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
    v17 = pixelBufferOut;
  }

  return v17;
}

void sub_1B3A7FEA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARReadDepthBufferFromFile(void *a1, CVPixelBufferRef *a2, float a3)
{
  id v5;
  const char *v6;
  const __CFAllocator *v7;
  const __CFString *v8;
  const __CFURL *v9;
  CGImageSource *v10;
  CGImage *ImageAtIndex;
  CGColorSpace *ColorSpace;
  CGColorSpaceModel Model;
  NSObject *v14;
  NSObject *v15;
  const char *v16;
  uint8_t *v17;
  unint64_t Width;
  size_t Height;
  size_t BitsPerPixel;
  size_t BytesPerRow;
  size_t v22;
  CGDataProvider *DataProvider;
  const __CFData *v24;
  const __CFData *v25;
  const UInt8 *BytePtr;
  uint64_t v27;
  float *BaseAddress;
  size_t v30;
  float v31;
  size_t v32;
  uint64_t v33;
  __int16 v34;
  uint8_t v35[2];
  __int16 v36;
  uint8_t buf[16];
  __int16 v38;
  __int16 v39;

  v5 = objc_retainAutorelease(a1);
  v6 = (const char *)objc_msgSend(v5, "UTF8String");
  v7 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v8 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], v6, 0x8000100u);
  v9 = CFURLCreateWithFileSystemPath(v7, v8, kCFURLPOSIXPathStyle, 0);
  CFRelease(v8);
  v10 = CGImageSourceCreateWithURL(v9, 0);
  CFRelease(v9);
  if (!v10)
  {
    _ARLogGeneral();
    v15 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    v39 = 0;
    v16 = "CGImageSourceCreateWithURL() failed!";
    v17 = (uint8_t *)&v39;
LABEL_20:
    _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, v16, v17, 2u);
    goto LABEL_21;
  }
  ImageAtIndex = CGImageSourceCreateImageAtIndex(v10, 0, 0);
  CFRelease(v10);
  if (!ImageAtIndex)
  {
    _ARLogGeneral();
    v15 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      goto LABEL_21;
    v38 = 0;
    v16 = "CGImageSourceCreateImageAtIndex() failed!";
    v17 = (uint8_t *)&v38;
    goto LABEL_20;
  }
  ColorSpace = CGImageGetColorSpace(ImageAtIndex);
  Model = CGColorSpaceGetModel(ColorSpace);
  if (Model | CGImageGetAlphaInfo(ImageAtIndex))
  {
    _ARLogGeneral();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_ERROR, "unexpected image format!", buf, 2u);
    }

    CGImageRelease(ImageAtIndex);
    goto LABEL_22;
  }
  Width = CGImageGetWidth(ImageAtIndex);
  Height = CGImageGetHeight(ImageAtIndex);
  BitsPerPixel = CGImageGetBitsPerPixel(ImageAtIndex);
  BytesPerRow = CGImageGetBytesPerRow(ImageAtIndex);
  if (BitsPerPixel != 16)
  {
    CGImageRelease(ImageAtIndex);
    _ARLogGeneral();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v36 = 0;
      v16 = "expected 16bit format!";
      v17 = (uint8_t *)&v36;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  v22 = BytesPerRow;
  DataProvider = CGImageGetDataProvider(ImageAtIndex);
  v24 = CGDataProviderCopyData(DataProvider);
  v25 = v24;
  if (!v24)
  {
    CGImageRelease(ImageAtIndex);
    _ARLogGeneral();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v35 = 0;
      v16 = "CGDataProviderCopyData() failed!";
      v17 = v35;
      goto LABEL_20;
    }
    goto LABEL_21;
  }
  BytePtr = CFDataGetBytePtr(v24);
  if (CVPixelBufferCreate(v7, Width, Height, 0x66646570u, 0, a2))
  {
    CFRelease(v25);
    CGImageRelease(ImageAtIndex);
    _ARLogGeneral();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      v34 = 0;
      v16 = "CVPixelBufferCreate() failed!";
      v17 = (uint8_t *)&v34;
      goto LABEL_20;
    }
LABEL_21:

LABEL_22:
    v27 = 0;
    goto LABEL_23;
  }
  CVPixelBufferLockBaseAddress(*a2, 0);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(*a2);
  v30 = CVPixelBufferGetBytesPerRow(*a2);
  if (Height)
  {
    LODWORD(v32) = 0;
    do
    {
      if (Width)
      {
        v33 = 0;
        do
        {
          LOWORD(v31) = *(_WORD *)&BytePtr[2 * v33];
          v31 = (float)LODWORD(v31) * a3;
          BaseAddress[v33++] = v31;
        }
        while (Width > v33);
      }
      BytePtr += v22;
      BaseAddress = (float *)((char *)BaseAddress + v30);
      v32 = (v32 + 1);
    }
    while (Height > v32);
  }
  CVPixelBufferUnlockBaseAddress(*a2, 0);
  CFRelease(v25);
  CGImageRelease(ImageAtIndex);
  v27 = 1;
LABEL_23:

  return v27;
}

void sub_1B3A8025C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARPixelBufferCopy(__CVBuffer *a1, __CVBuffer *a2)
{
  size_t Width;
  size_t v5;
  size_t Height;
  size_t v7;
  CVReturn v8;
  CVReturn v9;
  NSObject *v10;
  uint64_t v11;
  uint64_t v13;
  CVReturn v14;
  NSObject *v15;
  size_t PlaneCount;
  size_t v17;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  size_t v20;
  size_t v21;
  size_t BytesPerRowOfPlane;
  void *BaseAddressOfPlane;
  void *v24;
  vImage_Error v25;
  NSObject *v26;
  __IOSurface *IOSurface;
  size_t BytesPerElement;
  __IOSurface *v29;
  size_t v30;
  vImage_Error v31;
  NSObject *v32;
  OSType v33;
  id v34;
  OSType v35;
  void *v36;
  NSObject *v37;
  OSType PixelFormatType;
  id v39;
  OSType v40;
  void *v41;
  vImage_Buffer v42;
  vImage_Buffer src;
  _QWORD v44[2];
  void (*v45)(uint64_t);
  void *v46;
  __CVBuffer *v47;
  _QWORD v48[2];
  void (*v49)(uint64_t);
  void *v50;
  __CVBuffer *v51;
  uint8_t buf[4];
  size_t v53;
  __int16 v54;
  size_t v55;
  __int16 v56;
  size_t v57;
  __int16 v58;
  size_t v59;
  __int16 v60;
  size_t v61;
  __int16 v62;
  size_t v63;
  __int16 v64;
  size_t v65;
  __int16 v66;
  size_t v67;
  uint64_t v68;

  v68 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(a1);
  v5 = CVPixelBufferGetWidth(a2);
  Height = CVPixelBufferGetHeight(a1);
  v7 = CVPixelBufferGetHeight(a2);
  if (Width != v5 || Height != v7)
  {
    _ARLogGeneral();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers must have matching dimensions", buf, 2u);
    }
    goto LABEL_9;
  }
  v8 = CVPixelBufferLockBaseAddress(a1, 0);
  if (!v8)
  {
    v13 = MEMORY[0x1E0C809B0];
    v48[0] = MEMORY[0x1E0C809B0];
    v48[1] = 3221225472;
    v49 = __ARPixelBufferCopy_block_invoke;
    v50 = &__block_descriptor_40_e5_v8__0l;
    v51 = a1;
    v14 = CVPixelBufferLockBaseAddress(a2, 0);
    if (v14)
    {
      _ARLogGeneral();
      v15 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 67109120;
        LODWORD(v53) = v14;
        _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error locking destination buffer: %d", buf, 8u);
      }

      v11 = 0;
      goto LABEL_58;
    }
    v44[0] = v13;
    v44[1] = 3221225472;
    v45 = __ARPixelBufferCopy_block_invoke_46;
    v46 = &__block_descriptor_40_e5_v8__0l;
    v47 = a2;
    if (CVPixelBufferIsPlanar(a1))
    {
      if (CVPixelBufferIsPlanar(a2))
      {
        PlaneCount = CVPixelBufferGetPlaneCount(a1);
        if (PlaneCount == CVPixelBufferGetPlaneCount(a2))
        {
          if (PlaneCount)
          {
            v17 = 0;
            while (1)
            {
              WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, v17);
              HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, v17);
              v20 = CVPixelBufferGetWidthOfPlane(a2, v17);
              v21 = CVPixelBufferGetHeightOfPlane(a2, v17);
              if (WidthOfPlane != v20 || HeightOfPlane != v21)
                break;
              BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, v17);
              if (BytesPerRowOfPlane * HeightOfPlane != CVPixelBufferGetBytesPerRowOfPlane(a2, v17) * HeightOfPlane)
              {
                _ARLogGeneral();
                v37 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 134217984;
                  v53 = v17;
                  _os_log_impl(&dword_1B3A68000, v37, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers match resolution and number of planes but plane %lu within each pixel buffer has a different number of bytes per row", buf, 0xCu);
                }
LABEL_49:

                goto LABEL_56;
              }
              if (BytesPerRowOfPlane % WidthOfPlane)
              {
                BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(a2, v17);
                v24 = CVPixelBufferGetBaseAddressOfPlane(a1, v17);
                memcpy(BaseAddressOfPlane, v24, BytesPerRowOfPlane * HeightOfPlane);
              }
              else
              {
                memset(&src, 0, sizeof(src));
                ARWrapCVPixelBufferPlaneVImage(a1, v17, &src.data);
                memset(&v42, 0, sizeof(v42));
                ARWrapCVPixelBufferPlaneVImage(a2, v17, &v42.data);
                v25 = vImageCopyBuffer(&src, &v42, BytesPerRowOfPlane / WidthOfPlane, 0x10u);
                if (v25)
                {
                  _ARLogGeneral();
                  v32 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
                  {
                    PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
                    AROSTypeToString(PixelFormatType);
                    v39 = (id)objc_claimAutoreleasedReturnValue();
                    v40 = CVPixelBufferGetPixelFormatType(a2);
                    AROSTypeToString(v40);
                    v41 = (void *)objc_claimAutoreleasedReturnValue();
                    *(_DWORD *)buf = 134219778;
                    v53 = v25;
                    v54 = 2048;
                    v55 = v17;
                    v56 = 2114;
                    v57 = (size_t)v39;
                    v58 = 2048;
                    v59 = WidthOfPlane;
                    v60 = 2048;
                    v61 = HeightOfPlane;
                    v62 = 2114;
                    v63 = (size_t)v41;
                    v64 = 2048;
                    v65 = WidthOfPlane;
                    v66 = 2048;
                    v67 = HeightOfPlane;
                    _os_log_impl(&dword_1B3A68000, v32, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: vImageCopyBuffer error (%zu) for plane %zu copying pixel buffer (format:%{public}@, plane size:%zux%zu) to pixel buffer (format:%{public}@, plane size:%zux%zu)", buf, 0x52u);

                  }
                  goto LABEL_55;
                }
              }
              if (PlaneCount == ++v17)
                goto LABEL_43;
            }
            _ARLogGeneral();
            v37 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 134217984;
              v53 = v17;
              _os_log_impl(&dword_1B3A68000, v37, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers match resolution and number of planes but plane %lu within each pixel buffer are different resolutions", buf, 0xCu);
            }
            goto LABEL_49;
          }
          goto LABEL_43;
        }
        _ARLogGeneral();
        v26 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B3A68000, v26, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Source and destination buffers must have the same number of planes", buf, 2u);
        }
      }
      else
      {
        _ARLogGeneral();
        v26 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B3A68000, v26, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have planar mismatch between source (planar) and destination (non-planar)", buf, 2u);
        }
      }
    }
    else if (CVPixelBufferIsPlanar(a2))
    {
      _ARLogGeneral();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_WORD *)buf = 0;
        _os_log_impl(&dword_1B3A68000, v26, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have planar mismatch between source (non-planar) and destination (planar)", buf, 2u);
      }
    }
    else
    {
      IOSurface = CVPixelBufferGetIOSurface(a1);
      BytesPerElement = IOSurfaceGetBytesPerElement(IOSurface);
      v29 = CVPixelBufferGetIOSurface(a2);
      v30 = IOSurfaceGetBytesPerElement(v29);
      if (BytesPerElement == v30)
      {
        memset(&src, 0, sizeof(src));
        ARWrapCVPixelBufferVImage(a1, &src.data);
        memset(&v42, 0, sizeof(v42));
        ARWrapCVPixelBufferVImage(a2, &v42.data);
        v31 = vImageCopyBuffer(&src, &v42, BytesPerElement, 0x10u);
        if (!v31)
        {
LABEL_43:
          CVBufferPropagateAttachments(a1, a2);
          v11 = 1;
LABEL_57:
          v45((uint64_t)v44);
LABEL_58:
          v49((uint64_t)v48);
          return v11;
        }
        _ARLogGeneral();
        v32 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
        {
          v33 = CVPixelBufferGetPixelFormatType(a1);
          AROSTypeToString(v33);
          v34 = (id)objc_claimAutoreleasedReturnValue();
          v35 = CVPixelBufferGetPixelFormatType(a2);
          AROSTypeToString(v35);
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 134219522;
          v53 = v31;
          v54 = 2114;
          v55 = (size_t)v34;
          v56 = 2048;
          v57 = Width;
          v58 = 2048;
          v59 = Height;
          v60 = 2114;
          v61 = (size_t)v36;
          v62 = 2048;
          v63 = Width;
          v64 = 2048;
          v65 = Height;
          _os_log_impl(&dword_1B3A68000, v32, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: vImageCopyBuffer error (%zu) copying pixel buffer (format:%{public}@, size:%zux%zu) to pixel buffer (format:%{public}@, size:%zux%zu)", buf, 0x48u);

        }
LABEL_55:

LABEL_56:
        v11 = 0;
        goto LABEL_57;
      }
      _ARLogGeneral();
      v26 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 134218240;
        v53 = BytesPerElement;
        v54 = 2048;
        v55 = v30;
        _os_log_impl(&dword_1B3A68000, v26, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Cannot have byte-per-element mismatch between source and destination. src: %zu - dst: %zu", buf, 0x16u);
      }
    }

    goto LABEL_56;
  }
  v9 = v8;
  _ARLogGeneral();
  v10 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 67109120;
    LODWORD(v53) = v9;
    _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "ARPixelBufferCopy: Error locking source buffer: %d", buf, 8u);
  }
LABEL_9:

  return 0;
}

void sub_1B3A80A28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, void (*a19)(char *), uint64_t a20,uint64_t a21,char a22,uint64_t a23,void (*a24)(char *))
{
  void *v24;
  void *v25;

  a19(&a17);
  a24(&a22);
  _Unwind_Resume(a1);
}

double ARGetCroppedRegionCenterCrop(double a1, double a2, double a3)
{
  return (a1 - a3) * 0.5 + 0.0;
}

uint64_t ARCGImagePropertyOrientationFromUIDeviceOrientation(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 3)
    return 1;
  else
    return dword_1B3BDFF60[a1 - 1];
}

uint64_t _ARConvertBufferPixelsToBufferPixels(__CVBuffer *a1, __CVBuffer *a2, void *a3)
{
  void (**v5)(id, char *, size_t, size_t, size_t);
  size_t Width;
  size_t v7;
  size_t v8;
  BOOL v9;
  uint64_t v10;
  void *v11;
  void *v12;
  uint64_t i;
  uint64_t v14;
  size_t v15;
  __CVBuffer *pixelBuffer;
  __CVBuffer *v18;
  char *BaseAddress;
  size_t v20;
  size_t BytesPerRow;
  size_t Height;

  v5 = a3;
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v20 = CVPixelBufferGetBytesPerRow(a2);
  v7 = CVPixelBufferGetHeight(a2);
  v8 = CVPixelBufferGetWidth(a2);
  v9 = Height == v7 && Width == v8;
  v10 = v9;
  if (v9)
  {
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferLockBaseAddress(a2, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    pixelBuffer = a1;
    v18 = a2;
    v11 = CVPixelBufferGetBaseAddress(a2);
    if (Height)
    {
      v12 = v11;
      for (i = 0; i != Height; ++i)
      {
        v14 = 0;
        v15 = Width;
        do
        {
          v5[2](v5, &BaseAddress[i * BytesPerRow + v14 * (BytesPerRow / Width)], BytesPerRow / Width, (size_t)v12 + i * v20 + v14 * (v20 / Width), v20 / Width);
          ++v14;
          --v15;
        }
        while (v15);
      }
    }
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    v10 = v10;
    CVPixelBufferUnlockBaseAddress(v18, 0);
  }

  return v10;
}

void sub_1B3A80E1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARCreatePixelBufferFromSourceWithPixelConverter(__CVBuffer *a1, OSType a2, CVPixelBufferRef *a3, void *a4)
{
  id v7;
  size_t Width;
  size_t Height;
  IOSurfaceRef IOSurface;
  __CVBuffer *v11;
  uint64_t v12;
  CVPixelBufferRef pixelBufferOut;

  v7 = a4;
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  if (CVPixelBufferGetWidth(*a3) == Width && CVPixelBufferGetHeight(*a3) == Height)
  {
    IOSurface = CVPixelBufferGetIOSurface(*a3);
    pixelBufferOut = 0;
    if (IOSurface)
    {
      v11 = *a3;
      pixelBufferOut = *a3;
      LOBYTE(v12) = 1;
      goto LABEL_9;
    }
  }
  else
  {
    pixelBufferOut = 0;
  }
  if (*a3)
  {
LABEL_13:
    v12 = 4294960636;
    goto LABEL_14;
  }
  v12 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], Width, Height, a2, 0, &pixelBufferOut);
  if ((_DWORD)v12)
    goto LABEL_14;
  v11 = pixelBufferOut;
LABEL_9:
  if ((_ARConvertBufferPixelsToBufferPixels(a1, v11, v7) & 1) == 0)
  {
    CVPixelBufferRelease(pixelBufferOut);
    goto LABEL_13;
  }
  if ((v12 & 1) != 0)
  {
    v12 = 0;
  }
  else
  {
    v12 = 0;
    *a3 = pixelBufferOut;
  }
LABEL_14:

  return v12;
}

void sub_1B3A80F68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreateColorizedOneComponentTo24RGBPixelBuffer(__CVBuffer *a1, void *a2)
{
  id v3;
  OSType PixelFormatType;
  OSType v5;
  void *v6;
  NSObject *v7;
  CVPixelBufferRef v8;
  size_t Width;
  size_t Height;
  NSObject *v11;
  char *BaseAddress;
  char *v13;
  uint64_t v14;
  uint64_t v15;
  _BYTE *v16;
  unint64_t v17;
  void *v18;
  double v19;
  void *v20;
  double v21;
  void *v22;
  double v23;
  int v30;
  NSObject *v31;
  size_t v33;
  size_t v34;
  size_t BytesPerRow;
  BOOL v36;
  const __CFDictionary *v37;
  _BYTE *v38;
  _QWORD v39[2];
  uint64_t (*v40)(uint64_t);
  void *v41;
  __CVBuffer *v42;
  CVPixelBufferRef v43;
  uint8_t buf[8];
  uint8_t v45[4];
  int v46;
  uint64_t v47;
  _QWORD v48[3];

  v48[1] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = PixelFormatType;
  if (!v3 && PixelFormatType == 1278226488)
  {
    v6 = 0;
    _ARLogGeneral();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v7, OS_LOG_TYPE_ERROR, "Missing color table for kCVPixelFormatType_OneComponent8 input", buf, 2u);
    }
LABEL_5:

    v8 = 0;
    goto LABEL_37;
  }
  if (PixelFormatType - 1278226488 > 0x30
    || ((1 << (PixelFormatType - 56)) & 0x1400000000001) == 0)
  {
    v6 = v3;
    _ARLogGeneral();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v7, OS_LOG_TYPE_ERROR, "Failed to create the colorized buffer: Unexpected format.", buf, 2u);
    }
    goto LABEL_5;
  }
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(a1);
  *(_QWORD *)buf = 0;
  v47 = *MEMORY[0x1E0CA8FF0];
  v48[0] = MEMORY[0x1E0C9AA70];
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v48, &v47, 1);
  v37 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  if (CVPixelBufferCreate(0, Width, Height, 0x18u, v37, (CVPixelBufferRef *)buf))
  {
    v6 = v3;
    _ARLogGeneral();
    v11 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v45 = 0;
      _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", v45, 2u);
    }

    v8 = 0;
    goto LABEL_36;
  }
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)buf, 0);
  v39[0] = MEMORY[0x1E0C809B0];
  v39[1] = 3221225472;
  v40 = __ARCreateColorizedOneComponentTo24RGBPixelBuffer_block_invoke;
  v41 = &__block_descriptor_48_e5_v8__0l;
  v42 = a1;
  v43 = *(CVPixelBufferRef *)buf;
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
  v13 = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)buf);
  BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
  v6 = v3;
  v34 = CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)buf);
  if (!Height)
  {
LABEL_26:
    v8 = *(CVPixelBufferRef *)buf;
    goto LABEL_35;
  }
  v14 = 0;
  v38 = v13 + 2;
  v36 = 1;
  v33 = Height;
  while (!Width)
  {
LABEL_25:
    v36 = v33 > ++v14;
    BaseAddress += BytesPerRow;
    v38 += v34;
    if (v14 == v33)
      goto LABEL_26;
  }
  v15 = 0;
  v16 = v38;
  while (1)
  {
    if (v5 == 1278226536)
    {
      _H0 = *(_WORD *)&BaseAddress[2 * v15];
      __asm { FCVT            S0, H0 }
LABEL_23:
      v30 = (int)fminf(_S0 * 255.0, 255.0);
      *(v16 - 2) = v30;
      *(v16 - 1) = v30;
      *v16 = v30;
      goto LABEL_24;
    }
    if (v5 == 1278226534)
    {
      _S0 = *(float *)&BaseAddress[4 * v15];
      goto LABEL_23;
    }
    if (v5 == 1278226488)
      break;
LABEL_24:
    ++v15;
    v16 += 3;
    if (Width == v15)
      goto LABEL_25;
  }
  v17 = BaseAddress[v15];
  if (objc_msgSend(v6, "count") > v17)
  {
    objc_msgSend(v6, "objectAtIndexedSubscript:", v17);
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v18, "red");
    *(v16 - 2) = (int)(v19 * 255.0);

    objc_msgSend(v6, "objectAtIndexedSubscript:", v17);
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v20, "green");
    *(v16 - 1) = (int)(v21 * 255.0);

    objc_msgSend(v6, "objectAtIndexedSubscript:", v17);
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v22, "blue");
    *v16 = (int)(v23 * 255.0);

    goto LABEL_24;
  }
  _ARLogGeneral();
  v31 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)v45 = 67109120;
    v46 = v17;
    _os_log_impl(&dword_1B3A68000, v31, OS_LOG_TYPE_ERROR, "Failed to create the colorized buffer: Color is not defined for label=%d", v45, 8u);
  }

  if (v36)
    v8 = 0;
  else
    v8 = *(CVPixelBufferRef *)buf;
LABEL_35:
  v40((uint64_t)v39);
LABEL_36:

LABEL_37:
  return v8;
}

void sub_1B3A81424(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

uint64_t ARCreateConcatenatedCVPixelBuffer(__CVBuffer *a1, __CVBuffer *a2, uint64_t a3)
{
  size_t Width;
  size_t v7;
  size_t Height;
  size_t v9;
  OSType PixelFormatType;
  OSType v11;
  NSObject *v12;
  NSObject *v13;
  const char *v14;
  NSObject *v15;
  uint32_t v16;
  uint64_t v17;
  size_t BytesPerRow;
  char *BaseAddress;
  char *v21;
  char *v22;
  __IOSurface *IOSurface;
  size_t BytesPerElement;
  __IOSurface *v25;
  size_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  size_t v33;
  size_t v34;
  size_t v35;
  size_t __n;
  size_t __na;
  uint8_t buf[16];
  uint64_t v39;
  uint64_t v40;
  _BYTE pixelBufferOut[12];
  __int16 v42;
  size_t v43;
  uint64_t v44;

  v44 = *MEMORY[0x1E0C80C00];
  Width = CVPixelBufferGetWidth(a1);
  v7 = CVPixelBufferGetWidth(a2);
  Height = CVPixelBufferGetHeight(a1);
  v9 = CVPixelBufferGetHeight(a2);
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v11 = CVPixelBufferGetPixelFormatType(a2);
  if (Height != v9)
  {
    _ARLogGeneral();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)pixelBufferOut = 134218240;
      *(_QWORD *)&pixelBufferOut[4] = Height;
      v42 = 2048;
      v43 = v9;
      v14 = "Failed to concatenate buffers: Height does not match (%zu <-> %zu)";
      v15 = v12;
      v16 = 22;
LABEL_16:
      _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, v14, pixelBufferOut, v16);
      goto LABEL_17;
    }
    goto LABEL_17;
  }
  if (PixelFormatType != v11)
  {
    _ARLogGeneral();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)pixelBufferOut = 0;
      v14 = "Failed to concatenate buffers: format does not match";
LABEL_15:
      v15 = v12;
      v16 = 2;
      goto LABEL_16;
    }
LABEL_17:
    v17 = 0;
    goto LABEL_18;
  }
  if (!CVPixelBufferGetIOSurface(a1) || !CVPixelBufferGetIOSurface(a2))
  {
    _ARLogGeneral();
    v12 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)pixelBufferOut = 0;
      v14 = "Failed to concatenate buffers: Buffers need to be IOSurface back";
      goto LABEL_15;
    }
    goto LABEL_17;
  }
  __n = v7;
  v39 = *MEMORY[0x1E0CA8FF0];
  v40 = MEMORY[0x1E0C9AA70];
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v40, &v39, 1);
  v12 = objc_claimAutoreleasedReturnValue();
  *(_QWORD *)pixelBufferOut = 0;
  if (CVPixelBufferCreate(0, Width + a3 + __n, Height, PixelFormatType, (CFDictionaryRef)v12, (CVPixelBufferRef *)pixelBufferOut))
  {
    _ARLogGeneral();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", buf, 2u);
    }

    goto LABEL_17;
  }
  CVPixelBufferLockBaseAddress(*(CVPixelBufferRef *)pixelBufferOut, 0);
  CVPixelBufferLockBaseAddress(a1, 0);
  CVPixelBufferLockBaseAddress(a2, 0);
  BytesPerRow = CVPixelBufferGetBytesPerRow(*(CVPixelBufferRef *)pixelBufferOut);
  v34 = CVPixelBufferGetBytesPerRow(a1);
  v33 = BytesPerRow;
  v32 = CVPixelBufferGetBytesPerRow(a2);
  BaseAddress = (char *)CVPixelBufferGetBaseAddress(*(CVPixelBufferRef *)pixelBufferOut);
  v21 = (char *)CVPixelBufferGetBaseAddress(a1);
  v22 = (char *)CVPixelBufferGetBaseAddress(a2);
  IOSurface = CVPixelBufferGetIOSurface(a1);
  BytesPerElement = IOSurfaceGetBytesPerElement(IOSurface);
  v25 = CVPixelBufferGetIOSurface(a2);
  v26 = IOSurfaceGetBytesPerElement(v25);
  v27 = v34;
  v28 = v32;
  if (Height)
  {
    v35 = v26 * __n;
    __na = BytesPerElement * Width;
    v29 = a3 + BytesPerElement * Width;
    do
    {
      v30 = v27;
      v31 = v28;
      memcpy(BaseAddress, v21, __na);
      memcpy(&BaseAddress[v29], v22, v35);
      v28 = v31;
      v27 = v30;
      BaseAddress += v33;
      v21 += v30;
      v22 += v31;
      --Height;
    }
    while (Height);
  }
  CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)pixelBufferOut, 0);
  CVPixelBufferUnlockBaseAddress(a1, 0);
  CVPixelBufferUnlockBaseAddress(a2, 0);
  v17 = *(_QWORD *)pixelBufferOut;
LABEL_18:

  return v17;
}

void sub_1B3A8187C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{

  _Unwind_Resume(a1);
}

id ARIOSurfaceToPNGData(IOSurfaceRef surface)
{
  NSObject *v1;
  void *v3;
  uint8_t v4[8];
  CVPixelBufferRef pixelBufferOut;

  pixelBufferOut = 0;
  if (CVPixelBufferCreateWithIOSurface(0, surface, 0, &pixelBufferOut))
  {
    _ARLogGeneral();
    v1 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v1, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v4 = 0;
      _os_log_impl(&dword_1B3A68000, v1, OS_LOG_TYPE_ERROR, "Could not create pixelbuffer", v4, 2u);
    }

    return 0;
  }
  else
  {
    ARPixelBufferToPNGData((uint64_t)pixelBufferOut);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    CVPixelBufferRelease(pixelBufferOut);
    return v3;
  }
}

void sub_1B3A81960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ARPixelBufferToPNGData(uint64_t a1)
{
  CGColorSpace *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  NSObject *v8;
  uint64_t v9;
  void *v10;
  uint8_t v12[8];
  uint64_t v13;
  CGColorSpace *v14;
  uint64_t v15;
  _QWORD v16[2];

  v16[1] = *MEMORY[0x1E0C80C00];
  v2 = CGColorSpaceCreateWithName((CFStringRef)*MEMORY[0x1E0C9D990]);
  v3 = (void *)MEMORY[0x1E0C9DDC8];
  v15 = *MEMORY[0x1E0C9E110];
  v16[0] = v2;
  objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v16, &v15, 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "imageWithCVPixelBuffer:options:", a1, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  if (v5)
  {
    v6 = (void *)MEMORY[0x1E0C9DD90];
    v13 = *MEMORY[0x1E0C9DFC0];
    v14 = v2;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v14, &v13, 1);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "contextWithOptions:", v7);
    v8 = objc_claimAutoreleasedReturnValue();

    v9 = -[NSObject workingColorSpace](v8, "workingColorSpace");
    -[NSObject PNGRepresentationOfImage:format:colorSpace:options:](v8, "PNGRepresentationOfImage:format:colorSpace:options:", v5, *MEMORY[0x1E0C9E000], v9, MEMORY[0x1E0C9AA70]);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    CGColorSpaceRelease(v2);
  }
  else
  {
    _ARLogGeneral();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v12 = 0;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "Failed to create CIImage", v12, 2u);
    }
    v10 = 0;
  }

  return v10;
}

void sub_1B3A81B18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

CVPixelBufferRef ARCreateEmptyBufferWithSameFormatFromSource(__CVBuffer *a1)
{
  __CVBuffer *v1;
  size_t Width;
  size_t Height;
  CVPixelBufferRef result;
  NSObject *v5;
  uint8_t v6[16];
  CVPixelBufferRef pixelBufferOut;
  uint64_t v8;
  _QWORD v9[2];

  v1 = a1;
  v9[1] = *MEMORY[0x1E0C80C00];
  pixelBufferOut = 0;
  Width = CVPixelBufferGetWidth(a1);
  Height = CVPixelBufferGetHeight(v1);
  LODWORD(v1) = CVPixelBufferGetPixelFormatType(v1);
  v8 = *MEMORY[0x1E0CA8FF0];
  v9[0] = MEMORY[0x1E0C9AA70];
  CVPixelBufferCreate(0, Width, Height, (OSType)v1, (CFDictionaryRef)objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v9, &v8, 1), &pixelBufferOut);
  result = pixelBufferOut;
  if (!pixelBufferOut)
  {
    _ARLogGeneral();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v6 = 0;
      _os_log_impl(&dword_1B3A68000, v5, OS_LOG_TYPE_ERROR, "Failed to create an empty pixelbuffer", v6, 2u);
    }

    return pixelBufferOut;
  }
  return result;
}

void ___ZL13_ARLogGeneralv_block_invoke_3()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

double ARUltrawideToWideExtrinsics()
{
  __int128 v0;
  __int128 v1;
  __int128 v2;
  __int128 v3;
  uint64_t v4;
  uint64_t v5;
  double result;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  _OWORD v11[5];
  simd_float4x4 v12;
  simd_float4x4 v13;

  ARCameraToJasperExtrinsics((void *)*MEMORY[0x1E0C89F98]);
  ARMatrix4x4FromMatrix4x3();
  v7 = v1;
  v8 = v0;
  v9 = v3;
  v10 = v2;
  ARCameraToJasperExtrinsics((void *)*MEMORY[0x1E0C89FA0]);
  ARMatrix4x4FromMatrix4x3();
  v13 = __invert_f4(v12);
  v5 = 0;
  v11[0] = v8;
  v11[1] = v7;
  v11[2] = v10;
  v11[3] = v9;
  do
  {
    v11[v5 + 4] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v13.columns[0], COERCE_FLOAT(v11[v5])), (float32x4_t)v13.columns[1], *(float32x2_t *)&v11[v5], 1), (float32x4_t)v13.columns[2], (float32x4_t)v11[v5], 2), (float32x4_t)v13.columns[3], (float32x4_t)v11[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  *(_QWORD *)&result = ARMatrix4x3FromMatrix4x4(v4).n128_u64[0];
  return result;
}

__n128 ARCameraToJasperExtrinsics(void *a1)
{
  id v1;
  void *v2;
  __n128 v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0C89FA0]) & 1) != 0)
  {
    v2 = &unk_1E66CEA00;
  }
  else
  {
    if (!objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0C89F98]))
    {
      v4 = (__n128)xmmword_1B3BDFDC0;
      goto LABEL_7;
    }
    v2 = &unk_1E66CEA18;
  }
  v4 = ARMatrix4x3FromRowMajorFlatArray(v2);
LABEL_7:

  return v4;
}

void sub_1B3A81E2C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double ARST2UltrawideToWideExtrinsics()
{
  return *(double *)&_PromotedConst;
}

__n128 ARST2CameraToJasperExtrinsics(void *a1)
{
  id v1;
  void *v2;
  __n128 v4;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0C89FA0]) & 1) != 0)
  {
    v2 = &unk_1E66CEA30;
  }
  else
  {
    if (!objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0C89F98]))
    {
      v4 = (__n128)xmmword_1B3BDFDC0;
      goto LABEL_7;
    }
    v2 = &unk_1E66CEA18;
  }
  v4 = ARMatrix4x3FromRowMajorFlatArray(v2);
LABEL_7:

  return v4;
}

void sub_1B3A81F08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ARJasperWideCameraCalibration()
{
  if (ARJasperWideCameraCalibration::onceToken != -1)
    dispatch_once(&ARJasperWideCameraCalibration::onceToken, &__block_literal_global_9);
  return (id)ARJasperWideCameraCalibration::cameraCalibration;
}

void sub_1B3A820D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  _Unwind_Resume(a1);
}

id ARST2JasperWideCameraCalibration()
{
  if (ARST2JasperWideCameraCalibration::onceToken != -1)
    dispatch_once(&ARST2JasperWideCameraCalibration::onceToken, &__block_literal_global_8_0);
  return (id)ARST2JasperWideCameraCalibration::cameraCalibration;
}

void sub_1B3A822F4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  _Unwind_Resume(a1);
}

void sub_1B3A82498(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A824F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A82584(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3A82680(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A82720(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3A82BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B3A82D4C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3A82E9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A82FD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A830DC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void std::vector<ARTexturedPlane>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, (uint64_t)*v2);
    operator delete(**a1);
  }
}

void std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 8); i != a2; i -= 224)
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(i - 32, *(_QWORD **)(i - 24));
  }
  *(_QWORD *)(a1 + 8) = a2;
}

void std::__tree<std::array<unsigned char,16ul>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::array<unsigned char,16ul>>::destroy(a1, *a2);
    std::__tree<std::array<unsigned char,16ul>>::destroy(a1, a2[1]);
    operator delete(a2);
  }
}

void std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(a1, a2[1]);

    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(a2 + 30), (_QWORD *)a2[31]);
    operator delete(a2);
  }
}

id _ARLogGeneral_3()
{
  if (_ARLogGeneral_onceToken_4 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_4, &__block_literal_global_10);
  return (id)_ARLogGeneral_logObj_4;
}

void sub_1B3A83C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16, uint64_t a17, void (*a18)(char *))
{
  a18(&a16);
  _Unwind_Resume(a1);
}

uint64_t ARKitDaemonLibraryCore()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  __int128 v7;
  __int128 v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  v3 = 0;
  v4 = &v3;
  v5 = 0x2020000000;
  v0 = ARKitDaemonLibraryCore_frameworkLibrary;
  v6 = ARKitDaemonLibraryCore_frameworkLibrary;
  if (!ARKitDaemonLibraryCore_frameworkLibrary)
  {
    v7 = xmmword_1E6672468;
    v8 = *(_OWORD *)&off_1E6672478;
    v1 = _sl_dlopen();
    v4[3] = v1;
    ARKitDaemonLibraryCore_frameworkLibrary = v1;
    v0 = v1;
  }
  _Block_object_dispose(&v3, 8);
  return v0;
}

void sub_1B3A85B74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _Block_object_dispose(&a9, 8);
  _Unwind_Resume(a1);
}

uint64_t ARKitDaemonLibrary()
{
  uint64_t v0;
  void *v2;

  v0 = ARKitDaemonLibraryCore();
  if (!v0)
  {
    v2 = (void *)abort_report_np();
    free(v2);
  }
  return v0;
}

id getARDaemonClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getARDaemonClass_softClass;
  v7 = getARDaemonClass_softClass;
  if (!getARDaemonClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getARDaemonClass_block_invoke;
    v3[3] = &unk_1E6672490;
    v3[4] = &v4;
    __getARDaemonClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B3A85C84(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getARDaemonClass_block_invoke(uint64_t a1)
{
  Class result;

  ARKitDaemonLibrary();
  result = objc_getClass("ARDaemon");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    __getARDaemonClass_block_invoke_cold_1();
  getARDaemonClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id getARDaemonReplayBlockDelegateClass()
{
  void *v0;
  id v1;
  _QWORD v3[5];
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = 0;
  v5 = &v4;
  v6 = 0x2050000000;
  v0 = (void *)getARDaemonReplayBlockDelegateClass_softClass;
  v7 = getARDaemonReplayBlockDelegateClass_softClass;
  if (!getARDaemonReplayBlockDelegateClass_softClass)
  {
    v3[0] = MEMORY[0x1E0C809B0];
    v3[1] = 3221225472;
    v3[2] = __getARDaemonReplayBlockDelegateClass_block_invoke;
    v3[3] = &unk_1E6672490;
    v3[4] = &v4;
    __getARDaemonReplayBlockDelegateClass_block_invoke((uint64_t)v3);
    v0 = (void *)v5[3];
  }
  v1 = v0;
  _Block_object_dispose(&v4, 8);
  return v1;
}

void sub_1B3A85D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

Class __getARDaemonReplayBlockDelegateClass_block_invoke(uint64_t a1)
{
  Class result;

  ARKitDaemonLibrary();
  result = objc_getClass("ARDaemonReplayBlockDelegate");
  *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = result;
  if (!*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24))
    __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1();
  getARDaemonReplayBlockDelegateClass_softClass = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  return result;
}

id ARDaemonLocalAnonymousListenerDaemon()
{
  return objc_loadWeakRetained(&sLocalAnonymousListenerDaemon);
}

id AROverrideARDaemonLocalAnonymousListenerDaemon(id obj)
{
  return objc_storeWeak(&sLocalAnonymousListenerDaemon, obj);
}

id AROSVersionString()
{
  if (AROSVersionString_onceToken != -1)
    dispatch_once(&AROSVersionString_onceToken, &__block_literal_global_11);
  return (id)AROSVersionString_buildVersion;
}

uint64_t ARInternalOSBuild()
{
  if (ARInternalOSBuild_onceToken != -1)
    dispatch_once(&ARInternalOSBuild_onceToken, &__block_literal_global_11);
  return ARInternalOSBuild_internalVersion;
}

id ARDeviceString()
{
  if (ARDeviceString_onceToken != -1)
    dispatch_once(&ARDeviceString_onceToken, &__block_literal_global_13);
  return (id)ARDeviceString_deviceString;
}

id ARVersionStringForIdentifier(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  NSObject *v6;
  int v8;
  id v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (ARVersionStringForIdentifier_onceToken != -1)
    dispatch_once(&ARVersionStringForIdentifier_onceToken, &__block_literal_global_16);
  objc_msgSend((id)ARVersionStringForIdentifier_versionDictionary, "objectForKeyedSubscript:", v1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v2)
  {
    objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", v1);
    v3 = (void *)objc_claimAutoreleasedReturnValue();
    v4 = v3;
    if (v3)
    {
      objc_msgSend(v3, "infoDictionary");
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("CFBundleVersion"));
      v2 = (void *)objc_claimAutoreleasedReturnValue();

      if (v2)
        objc_msgSend((id)ARVersionStringForIdentifier_versionDictionary, "setObject:forKeyedSubscript:", v2, v1);
    }
    else
    {
      _ARLogGeneral_4();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        v8 = 138412290;
        v9 = v1;
        _os_log_impl(&dword_1B3A68000, v6, OS_LOG_TYPE_ERROR, "Couldn't find bundle for name %@", (uint8_t *)&v8, 0xCu);
      }

      v2 = 0;
    }

  }
  return v2;
}

id _ARLogGeneral_4()
{
  if (_ARLogGeneral_onceToken_5 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_5, &__block_literal_global_200);
  return (id)_ARLogGeneral_logObj_5;
}

uint64_t ARDeviceIsiPad()
{
  if (ARDeviceIsiPad_onceToken != -1)
    dispatch_once(&ARDeviceIsiPad_onceToken, &__block_literal_global_23);
  return s_deviceIsiPad;
}

uint64_t AROverrideARDeviceIsiPad(uint64_t result)
{
  s_deviceIsiPad = result;
  return result;
}

uint64_t ARDeviceHasBackCamera()
{
  if (ARDeviceHasBackCamera_onceToken != -1)
    dispatch_once(&ARDeviceHasBackCamera_onceToken, &__block_literal_global_26);
  return ARDeviceHasBackCamera_s_deviceHasBackCamera;
}

uint64_t ARDeviceHasFrontCamera()
{
  if (ARDeviceHasFrontCamera_onceToken != -1)
    dispatch_once(&ARDeviceHasFrontCamera_onceToken, &__block_literal_global_29);
  return ARDeviceHasFrontCamera_s_deviceHasFrontCamera;
}

uint64_t ARDeviceHasHomeButton()
{
  if (ARDeviceHasHomeButton_onceToken != -1)
    dispatch_once(&ARDeviceHasHomeButton_onceToken, &__block_literal_global_32);
  return s_deviceHasHomeButton;
}

uint64_t AROverrideARDeviceHasHomeButton(uint64_t result)
{
  s_deviceHasHomeButton = result;
  return result;
}

uint64_t ARDeviceHasIsland()
{
  if (ARDeviceHasIsland_onceToken != -1)
    dispatch_once(&ARDeviceHasIsland_onceToken, &__block_literal_global_35);
  return s_deviceHasIsland;
}

uint64_t AROverrideARDeviceHasIsland(uint64_t result)
{
  s_deviceHasIsland = result;
  return result;
}

id ARDeviceName()
{
  if (ARDeviceName_onceToken != -1)
    dispatch_once(&ARDeviceName_onceToken, &__block_literal_global_38);
  return (id)ARDeviceName_deviceName;
}

id ARMarketingDeviceName()
{
  if (ARMarketingDeviceName_onceToken != -1)
    dispatch_once(&ARMarketingDeviceName_onceToken, &__block_literal_global_41_0);
  return (id)ARMarketingDeviceName_localizedDeviceName;
}

id ARDeviceClass()
{
  if (ARDeviceClass_onceToken != -1)
    dispatch_once(&ARDeviceClass_onceToken, &__block_literal_global_44);
  return (id)ARDeviceClass_deviceClass;
}

uint64_t ARPearlCameraSupported()
{
  if (ARPearlCameraSupported_onceToken != -1)
    dispatch_once(&ARPearlCameraSupported_onceToken, &__block_literal_global_47);
  return ARPearlCameraSupported_supported;
}

__n128 ARDisplayCenterTransformForCaptureDevicePosition(uint64_t a1)
{
  __int128 *v2;

  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1)
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_50);
  if (a1 == 2)
    v2 = &ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  else
    v2 = &ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  return (__n128)*v2;
}

double ARFrontWideCameraTransformFromBackWideAngleCameraTransform(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float32x4_t v9;
  simd_float4 v10;
  float32x4_t v11;
  simd_float4 v12;
  float32x4_t v13;
  simd_float4 v14;
  float32x4_t v15;
  simd_float4 v16;
  float32x4_t v18;
  float32x4_t v20;
  float32x4_t v22;
  float32x4_t v24;
  simd_float4x4 v25;
  simd_float4x4 v26;
  simd_float4x4 v27;
  simd_float4x4 v28;
  simd_float4x4 v29;
  simd_float4x4 v30;

  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1)
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_50);
  v13 = (float32x4_t)xmmword_1EF081B00;
  v15 = (float32x4_t)ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  v9 = (float32x4_t)xmmword_1EF081B10;
  v11 = (float32x4_t)xmmword_1EF081B20;
  v27.columns[2] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_2;
  v27.columns[1] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_1;
  v27.columns[0] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  v27.columns[3] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_3;
  v28 = __invert_f4(v27);
  v4 = 0;
  v25 = v28;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v15, COERCE_FLOAT(*(_OWORD *)&v25.columns[v4])), v13, *(float32x2_t *)v25.columns[v4].f32, 1), v9, (float32x4_t)v25.columns[v4], 2), v11, (float32x4_t)v25.columns[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  v5 = 0;
  v25 = v26;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)&v25.columns[v5])), a2, *(float32x2_t *)v25.columns[v5].f32, 1), a3, (float32x4_t)v25.columns[v5], 2), a4, (float32x4_t)v25.columns[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  v22 = (float32x4_t)v26.columns[1];
  v24 = (float32x4_t)v26.columns[0];
  v18 = (float32x4_t)v26.columns[3];
  v20 = (float32x4_t)v26.columns[2];
  v29 = *(simd_float4x4 *)*(_QWORD *)&MEMORY[0x1E0C83FF0];
  v14 = v29.columns[1];
  v16 = *(simd_float4 *)MEMORY[0x1E0C83FF0];
  v29.columns[2].i32[2] = -1.0;
  v10 = v29.columns[2];
  v12 = v29.columns[3];
  v30 = __invert_f4(*MEMORY[0x1E0C83FF0]);
  v6 = 0;
  v25.columns[0] = v16;
  v25.columns[1] = v14;
  v25.columns[2] = v10;
  v25.columns[3] = v12;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v24, COERCE_FLOAT(*(_OWORD *)&v25.columns[v6])), v22, *(float32x2_t *)v25.columns[v6].f32, 1), v20, (float32x4_t)v25.columns[v6], 2), v18, (float32x4_t)v25.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  v7 = 0;
  v25 = v26;
  memset(&v26, 0, sizeof(v26));
  do
  {
    v26.columns[v7] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v30.columns[0], COERCE_FLOAT(*(_OWORD *)&v25.columns[v7])), (float32x4_t)v30.columns[1], *(float32x2_t *)v25.columns[v7].f32, 1), (float32x4_t)v30.columns[2], (float32x4_t)v25.columns[v7], 2), (float32x4_t)v30.columns[3], (float32x4_t)v25.columns[v7], 3);
    ++v7;
  }
  while (v7 != 4);
  return *(double *)v26.columns[0].i64;
}

double ARFrontWideCameraTransformFromBackWideAngleCameraTransformWithZFlip(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  simd_float4 v11;
  simd_float4 v12;
  simd_float4 v13;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  simd_float4x4 v23;
  simd_float4x4 v24;
  simd_float4x4 v25;
  simd_float4x4 v26;

  if (ARDisplayCenterTransformForCaptureDevicePosition_onceToken[0] != -1)
    dispatch_once(ARDisplayCenterTransformForCaptureDevicePosition_onceToken, &__block_literal_global_50);
  v17 = (float32x4_t)xmmword_1EF081B00;
  v18 = (float32x4_t)ARDisplayCenterTransformForCaptureDevicePosition_rearCameraFromDisplayCenter;
  v15 = (float32x4_t)xmmword_1EF081B10;
  v16 = (float32x4_t)xmmword_1EF081B20;
  v25.columns[2] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_2;
  v25.columns[1] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_1;
  v25.columns[0] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_0;
  v25.columns[3] = (simd_float4)ARDisplayCenterTransformForCaptureDevicePosition_frontCameraFromDisplayCenter_3;
  v26 = __invert_f4(v25);
  v4 = 0;
  v23 = v26;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v4] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v18, COERCE_FLOAT(*(_OWORD *)&v23.columns[v4])), v17, *(float32x2_t *)v23.columns[v4].f32, 1), v15, (float32x4_t)v23.columns[v4], 2), v16, (float32x4_t)v23.columns[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  v5 = 0;
  v23 = v24;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v5] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, COERCE_FLOAT(*(_OWORD *)&v23.columns[v5])), a2, *(float32x2_t *)v23.columns[v5].f32, 1), a3, (float32x4_t)v23.columns[v5], 2), a4, (float32x4_t)v23.columns[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  v6 = 0;
  v7 = (float32x4_t)v24.columns[0];
  v8 = (float32x4_t)v24.columns[1];
  v9 = (float32x4_t)v24.columns[2];
  v10 = (float32x4_t)v24.columns[3];
  v11 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 32);
  v12 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v11.i32[2] = -1.0;
  v13 = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 16);
  v23.columns[0] = (simd_float4)*MEMORY[0x1E0C83FF0];
  v23.columns[1] = v13;
  v23.columns[2] = v11;
  v23.columns[3] = v12;
  memset(&v24, 0, sizeof(v24));
  do
  {
    v24.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v7, COERCE_FLOAT(*(_OWORD *)&v23.columns[v6])), v8, *(float32x2_t *)v23.columns[v6].f32, 1), v9, (float32x4_t)v23.columns[v6], 2), v10, (float32x4_t)v23.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  return *(double *)v24.columns[0].i64;
}

uint64_t ARAppleNeuralEngine()
{
  if (ARAppleNeuralEngine_onceToken[0] != -1)
    dispatch_once(ARAppleNeuralEngine_onceToken, &__block_literal_global_57);
  return s_deviceSupportsANE;
}

uint64_t ARDeviceHasANE()
{
  if (ARAppleNeuralEngine_onceToken[0] != -1)
    dispatch_once(ARAppleNeuralEngine_onceToken, &__block_literal_global_57);
  return s_deviceSupportsANE;
}

uint64_t AROverrideARAppleNeuralEngine(uint64_t result)
{
  s_deviceSupportsANE = result;
  return result;
}

id ARDeviceANEVersion()
{
  void *v0;

  if (objc_msgSend(MEMORY[0x1E0CFDF40], "hasANE"))
  {
    objc_msgSend(MEMORY[0x1E0CFDF40], "aneSubType");
    v0 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v0 = 0;
  }
  return v0;
}

uint64_t ARIsANEVersionEqualOrPriorToH12()
{
  if (ARIsANEVersionEqualOrPriorToH12_onceToken[0] != -1)
    dispatch_once(ARIsANEVersionEqualOrPriorToH12_onceToken, &__block_literal_global_61);
  return ARIsANEVersionEqualOrPriorToH12_s_isANEVersionEqualOrPriorToH12;
}

uint64_t ARIsANEE5RTAvailable()
{
  return 1;
}

id ARMLModelPath(void *a1, int a2)
{
  id v3;
  void *v4;
  id v5;
  void *v6;
  void *v7;
  __CFString *v8;
  void *v9;
  void *v10;
  id v11;
  void *v12;
  void *v13;
  void *v14;

  v3 = a1;
  if ((a2 & 1) == 0)
    goto LABEL_5;
  objc_msgSend(MEMORY[0x1E0CFDF40], "aneSubType");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  if (!objc_msgSend(MEMORY[0x1E0CFDF40], "hasANE")
    || (objc_msgSend(v4, "isEqualToString:", CFSTR("m9")) & 1) != 0)
  {

LABEL_5:
    v5 = v3;
    goto LABEL_6;
  }
  objc_msgSend(v4, "uppercaseString");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(CFSTR("_"), "stringByAppendingString:", v9);
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "stringByAppendingString:", v10);
  v5 = (id)objc_claimAutoreleasedReturnValue();

LABEL_6:
  ARKitCoreBundle();
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CFDF40], "aneSubType");
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (a2)
  {
    if (objc_msgSend(MEMORY[0x1E0CFDF40], "hasANE")
      && (objc_msgSend(v7, "isEqualToString:", CFSTR("m9")) & 1) == 0)
    {
      v11 = objc_alloc(MEMORY[0x1E0CB3940]);
      objc_msgSend(v7, "uppercaseString");
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      v8 = (__CFString *)objc_msgSend(v11, "initWithFormat:", CFSTR("MLModels/%@"), v12);

    }
    else
    {
      v8 = CFSTR("MLModels/Debug");
    }
  }
  else
  {
    v8 = CFSTR("MLModels/NonPrecompiled");
  }

  objc_msgSend(v6, "pathForResource:ofType:inDirectory:", v5, CFSTR("mlmodelc"), v8);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v13, "stringByAppendingPathComponent:", CFSTR("model.espresso.net"));
  v14 = (void *)objc_claimAutoreleasedReturnValue();

  return v14;
}

id ARKitCoreBundle()
{
  if (ARKitCoreBundle_onceToken != -1)
    dispatch_once(&ARKitCoreBundle_onceToken, &__block_literal_global_186);
  return (id)ARKitCoreBundle_arkitCoreBundle;
}

uint64_t ARIsAirPlaneModeEnabled()
{
  return MGGetBoolAnswer();
}

uint64_t ARDeviceSupportsJasper()
{
  if (ARDeviceSupportsJasper_onceToken != -1)
    dispatch_once(&ARDeviceSupportsJasper_onceToken, &__block_literal_global_76);
  return s_deviceSupportsJasper;
}

uint64_t AROverrideARDeviceSupportsJasper(uint64_t result)
{
  s_deviceSupportsJasper = result;
  return result;
}

uint64_t ARShouldSupport1440pAndAutofocus()
{
  if (ARShouldSupport1440pAndAutofocus_onceToken != -1)
    dispatch_once(&ARShouldSupport1440pAndAutofocus_onceToken, &__block_literal_global_78);
  return ARShouldSupport1440pAndAutofocus_cachedReturn;
}

uint64_t ARLinkedOnOrAfterPeace()
{
  if (ARLinkedOnOrAfterPeace_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterPeace_onceToken, &__block_literal_global_79);
  return ARLinkedOnOrAfterPeace_cachedReturn;
}

uint64_t ARLinkedOnOrAfterPeaceE()
{
  if (ARLinkedOnOrAfterPeaceE_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterPeaceE_onceToken, &__block_literal_global_80);
  return ARLinkedOnOrAfterPeaceE_cachedReturn;
}

uint64_t ARLinkedOnOrAfterYukon()
{
  if (ARLinkedOnOrAfterYukon_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterYukon_onceToken, &__block_literal_global_81);
  return ARLinkedOnOrAfterYukon_cachedReturn;
}

uint64_t ARLinkedOnOrAfterAzul()
{
  if (ARLinkedOnOrAfterAzul_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterAzul_onceToken, &__block_literal_global_82_0);
  if (ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul)
    return objc_msgSend((id)ARLinkedOnOrAfterAzul_forceAssumeLinkedOnOrAfterAzul, "BOOLValue");
  else
    return ARLinkedOnOrAfterAzul_cachedReturn;
}

uint64_t ARLinkedOnOrAfterAzulC()
{
  if (ARLinkedOnOrAfterAzulC_onceToken[0] != -1)
    dispatch_once(ARLinkedOnOrAfterAzulC_onceToken, &__block_literal_global_83);
  return ARLinkedOnOrAfterAzulC_cachedReturn;
}

uint64_t ARLinkedOnOrAfterAzulE()
{
  if (ARLinkedOnOrAfterAzulE_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterAzulE_onceToken, &__block_literal_global_84);
  return ARLinkedOnOrAfterAzulE_cachedReturn;
}

uint64_t ARLinkedOnOrAfterSydney()
{
  if (ARLinkedOnOrAfterSydney_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterSydney_onceToken, &__block_literal_global_85_0);
  return ARLinkedOnOrAfterSydney_cachedReturn;
}

uint64_t ARLinkedOnOrAfterCrystal()
{
  if (ARLinkedOnOrAfterCrystal_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterCrystal_onceToken, &__block_literal_global_86);
  return ARLinkedOnOrAfterCrystal_cachedReturn;
}

uint64_t ARLinkedOnOrAfterConstellation()
{
  if (ARLinkedOnOrAfterConstellation_onceToken != -1)
    dispatch_once(&ARLinkedOnOrAfterConstellation_onceToken, &__block_literal_global_87);
  return ARLinkedOnOrAfterConstellation_cachedReturn;
}

double ARDispatchAfterLeewayForTimeInterval(double a1)
{
  double v1;
  BOOL v2;
  double result;

  v1 = fmax(a1 * 0.1, 0.001);
  v2 = a1 > 0.0;
  result = 0.0;
  if (v2)
    return v1;
  return result;
}

double ARConvertTicksToSeconds(unint64_t a1)
{
  if (ARConvertTicksToSeconds_onceToken != -1)
    dispatch_once(&ARConvertTicksToSeconds_onceToken, &__block_literal_global_88);
  return *(double *)&ARConvertTicksToSeconds_ticksToSecond * (double)a1;
}

unint64_t ARConvertSecondsToTicks(double a1)
{
  if (ARConvertSecondsToTicks_onceToken != -1)
    dispatch_once(&ARConvertSecondsToTicks_onceToken, &__block_literal_global_89);
  return (unint64_t)(*(double *)&ARConvertSecondsToTicks_secondsToTick * a1);
}

uint64_t ARConvertMCTToMAT(uint64_t a1)
{
  NSObject *v2;
  uint8_t v4[16];
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  if (!mach_get_times())
    return a1 - v5 + v6;
  _ARLogGeneral_4();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_ERROR, "mach_get_times is failing for ARConvertMCTToMAT", v4, 2u);
  }

  return a1;
}

uint64_t ARConvertMATToMCT(uint64_t a1)
{
  NSObject *v2;
  uint8_t v4[16];
  uint64_t v5;
  uint64_t v6;

  v5 = 0;
  v6 = 0;
  if (!mach_get_times())
    return v5 + a1 - v6;
  _ARLogGeneral_4();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v4 = 0;
    _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_ERROR, "mach_get_times is failing for ARConvertMATToMCT", v4, 2u);
  }

  return a1;
}

dispatch_queue_t ARCreateFixedPriorityDispatchQueue(const char *a1)
{
  return ARCreateFixedPriorityDispatchQueueWithQOS(a1);
}

dispatch_queue_t ARCreateFixedPriorityDispatchQueueWithQOS(const char *a1)
{
  NSObject *inactive;
  NSObject *v3;
  dispatch_queue_t v4;

  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

dispatch_queue_t ARCreateNonFixedPriorityDispatchQueue(const char *a1)
{
  NSObject *inactive;
  NSObject *v3;
  dispatch_queue_t v4;

  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

dispatch_queue_t ARCreateNonFixedPriorityConcurrentDispatchQueue(const char *a1)
{
  NSObject *inactive;
  NSObject *v3;
  dispatch_queue_t v4;

  inactive = dispatch_workloop_create_inactive(a1);
  dispatch_workloop_set_qos_class_floor();
  dispatch_activate(inactive);
  dispatch_queue_attr_make_with_autorelease_frequency(MEMORY[0x1E0C80D50], DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v3 = objc_claimAutoreleasedReturnValue();
  v4 = dispatch_queue_create_with_target_V2(a1, v3, inactive);

  return v4;
}

BOOL ARDispatchQueueIsCurrentDispatchQueue(NSObject *a1)
{
  const char *label;
  const char *v2;

  label = dispatch_queue_get_label(a1);
  v2 = dispatch_queue_get_label(0);
  return ARStringIsEqualToString(label, v2);
}

BOOL ARStringIsEqualToString(const char *a1, const char *a2)
{
  size_t v4;

  v4 = strlen(a1);
  return strlen(a2) == v4 && strncmp(a1, a2, v4) == 0;
}

BOOL ARDispatchQueueIsEqualToDispatchQueue(NSObject *a1, NSObject *a2)
{
  const char *label;
  const char *v4;

  label = dispatch_queue_get_label(a1);
  v4 = dispatch_queue_get_label(a2);
  return ARStringIsEqualToString(label, v4);
}

uint64_t ARGetMemoryFootprint(_QWORD *a1, _QWORD *a2)
{
  uint64_t result;
  mach_msg_type_number_t task_info_outCnt;
  integer_t task_info_out[4];
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  int v29;

  v29 = 0;
  v27 = 0u;
  v28 = 0u;
  v25 = 0u;
  v26 = 0u;
  v23 = 0u;
  v24 = 0u;
  v21 = 0u;
  v22 = 0u;
  v19 = 0u;
  v20 = 0u;
  v17 = 0u;
  v18 = 0u;
  v15 = 0u;
  v16 = 0u;
  v14 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  v8 = 0u;
  v9 = 0u;
  *(_OWORD *)task_info_out = 0u;
  v7 = 0u;
  task_info_outCnt = 93;
  result = task_info(*MEMORY[0x1E0C83DA0], 0x16u, task_info_out, &task_info_outCnt);
  if (!(_DWORD)result)
  {
    *a1 = v15;
    *a2 = *((_QWORD *)&v16 + 1);
  }
  return result;
}

uint64_t ARRGBFaceTrackingEnabled()
{
  if (ARRGBFaceTrackingEnabled_onceToken[0] != -1)
    dispatch_once(ARRGBFaceTrackingEnabled_onceToken, &__block_literal_global_90);
  return ARRGBFaceTrackingEnabled_faceTrackingEnabled;
}

id ARFaceTrackingDevice()
{
  if (ARFaceTrackingDevice_onceToken[0] != -1)
    dispatch_once(ARFaceTrackingDevice_onceToken, &__block_literal_global_91);
  return (id)ARFaceTrackingDevice_deviceType;
}

BOOL ARHasH10()
{
  void *v0;
  _BOOL8 v1;

  v0 = (void *)MGCopyAnswer();
  v1 = objc_msgSend(v0, "integerValue") == 32789;

  return v1;
}

uint64_t ARDeviceRequiresFrameTrendControllerWorkaround()
{
  void *v0;
  uint64_t v1;

  if (!dyld_program_sdk_at_least())
    return 1;
  v0 = (void *)MGCopyAnswer();
  if (v0)
    v1 = objc_msgSend(&unk_1E66CEA48, "containsObject:", v0);
  else
    v1 = 1;

  return v1;
}

uint64_t ARDeviceSupportsMulticamMode()
{
  uint64_t result;

  result = objc_msgSend(MEMORY[0x1E0C8B0D8], "isMultiCamSupported");
  if ((_DWORD)result)
  {
    if (ARLinkedOnOrAfterYukon_onceToken != -1)
      dispatch_once(&ARLinkedOnOrAfterYukon_onceToken, &__block_literal_global_81);
    return ARLinkedOnOrAfterYukon_cachedReturn != 0;
  }
  return result;
}

uint64_t ARDeviceSupportsMulticamSessionWithVideoFormats(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  unint64_t v11;
  uint64_t i;
  void *v13;
  id v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t j;
  void *v19;
  uint64_t v20;
  void *v21;
  void *v22;
  int v23;
  uint64_t v24;
  uint64_t v25;
  BOOL v26;
  uint64_t v27;
  void *v29;
  void *v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  id obj;
  uint64_t v35;
  id v36;
  void *v37;
  id v38;
  uint64_t v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  _BYTE v53[128];
  _BYTE v54[128];
  _BYTE v55[128];
  uint64_t v56;

  v56 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (ARDeviceSupportsMulticamMode())
  {
    objc_msgSend(v1, "ar_map:", &__block_literal_global_100_0);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x1E0C99E60], "setWithArray:");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = (void *)MEMORY[0x1E0C8B0A8];
    v30 = v2;
    objc_msgSend(v2, "allObjects");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "discoverySessionWithDeviceTypes:mediaType:position:", v4, *MEMORY[0x1E0C8A808], 0);
    v5 = (void *)objc_claimAutoreleasedReturnValue();

    v29 = v5;
    objc_msgSend(v5, "supportedMultiCamDeviceSets");
    v49 = 0u;
    v50 = 0u;
    v51 = 0u;
    v52 = 0u;
    obj = (id)objc_claimAutoreleasedReturnValue();
    v6 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v55, 16);
    if (v6)
    {
      v7 = v6;
      v8 = *(_QWORD *)v50;
      v38 = v1;
      v32 = *(_QWORD *)v50;
      while (2)
      {
        v9 = 0;
        v33 = v7;
        do
        {
          if (*(_QWORD *)v50 != v8)
            objc_enumerationMutation(obj);
          v10 = *(void **)(*((_QWORD *)&v49 + 1) + 8 * v9);
          v11 = objc_msgSend(v10, "count");
          if (v11 >= objc_msgSend(v1, "count"))
          {
            v35 = v9;
            v37 = (void *)objc_opt_new();
            v45 = 0u;
            v46 = 0u;
            v47 = 0u;
            v48 = 0u;
            v36 = v10;
            v40 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
            if (v40)
            {
              v39 = *(_QWORD *)v46;
              do
              {
                for (i = 0; i != v40; ++i)
                {
                  if (*(_QWORD *)v46 != v39)
                    objc_enumerationMutation(v36);
                  v13 = *(void **)(*((_QWORD *)&v45 + 1) + 8 * i);
                  v41 = 0u;
                  v42 = 0u;
                  v43 = 0u;
                  v44 = 0u;
                  v14 = v1;
                  v15 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v41, v53, 16);
                  if (v15)
                  {
                    v16 = v15;
                    v17 = *(_QWORD *)v42;
                    while (2)
                    {
                      for (j = 0; j != v16; ++j)
                      {
                        if (*(_QWORD *)v42 != v17)
                          objc_enumerationMutation(v14);
                        v19 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * j);
                        v20 = objc_msgSend(v13, "position");
                        if (v20 == objc_msgSend(v19, "captureDevicePosition"))
                        {
                          objc_msgSend(v13, "deviceType");
                          v21 = (void *)objc_claimAutoreleasedReturnValue();
                          objc_msgSend(v19, "captureDeviceType");
                          v22 = (void *)objc_claimAutoreleasedReturnValue();
                          v23 = objc_msgSend(v21, "isEqualToString:", v22);

                          if (v23)
                          {
                            objc_msgSend(v37, "addObject:", v19);
                            goto LABEL_24;
                          }
                        }
                      }
                      v16 = objc_msgSend(v14, "countByEnumeratingWithState:objects:count:", &v41, v53, 16);
                      if (v16)
                        continue;
                      break;
                    }
                  }
LABEL_24:

                  v1 = v38;
                }
                v40 = objc_msgSend(v36, "countByEnumeratingWithState:objects:count:", &v45, v54, 16);
              }
              while (v40);
            }

            v24 = objc_msgSend(v37, "count");
            v25 = objc_msgSend(v1, "count");

            v26 = v24 == v25;
            v8 = v32;
            v7 = v33;
            v9 = v35;
            if (v26)
            {
              v27 = 1;
              goto LABEL_32;
            }
          }
          ++v9;
        }
        while (v9 != v7);
        v7 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v49, v55, 16);
        if (v7)
          continue;
        break;
      }
    }
    v27 = 0;
LABEL_32:

  }
  else
  {
    v27 = 0;
  }

  return v27;
}

uint64_t ARDeviceSupportsMulticamWithTripleRGBStreaming()
{
  if (ARDeviceSupportsMulticamWithTripleRGBStreaming_onceToken != -1)
    dispatch_once(&ARDeviceSupportsMulticamWithTripleRGBStreaming_onceToken, &__block_literal_global_104);
  return ARDeviceSupportsMulticamWithTripleRGBStreaming_supportsMulticamWithTripleRGBStreaming;
}

uint64_t ARDeviceSupportsUltraWideCamera()
{
  if (ARDeviceSupportsUltraWideCamera_onceToken != -1)
    dispatch_once(&ARDeviceSupportsUltraWideCamera_onceToken, &__block_literal_global_107);
  return ARDeviceSupportsUltraWideCamera_ultraWideAvailable;
}

uint64_t ARUserDefaultsMulticamModeEnabled()
{
  if (ARUserDefaultsMulticamModeEnabled_onceToken != -1)
    dispatch_once(&ARUserDefaultsMulticamModeEnabled_onceToken, &__block_literal_global_110);
  return s_multicamModeEnabled;
}

uint64_t AROverrideARUserDefaultsMulticamModeEnabled(uint64_t result)
{
  s_multicamModeEnabled = result;
  return result;
}

double ARReflectedLightMeterCalibrationConstantForDevice(uint64_t a1, void *a2)
{
  id v3;
  uint64_t v4;
  double v5;

  v3 = a2;
  v4 = MGGetProductType();
  if (a1 != 1)
    goto LABEL_12;
  if (v4 <= 2032616840)
  {
    if (v4 != 910181310)
      goto LABEL_9;
    goto LABEL_8;
  }
  if (v4 == 3743999268)
  {
LABEL_8:
    if ((id)*MEMORY[0x1E0C89FA0] == v3)
    {
      v5 = 45.3950005;
      goto LABEL_13;
    }
LABEL_9:
    if (v4 != 1371389549)
      goto LABEL_12;
    goto LABEL_10;
  }
  if (v4 != 2722529672)
  {
    if (v4 != 2032616841)
      goto LABEL_12;
    goto LABEL_8;
  }
LABEL_10:
  if ((id)*MEMORY[0x1E0C89F98] == v3)
  {
    v5 = 210.628006;
    goto LABEL_13;
  }
  if ((id)*MEMORY[0x1E0C89FA0] == v3)
  {
    v5 = 58.7200012;
    goto LABEL_13;
  }
LABEL_12:
  v5 = 0.0;
LABEL_13:

  return v5;
}

BOOL ARDeviceSupportsSceneLuminanceEstimation(uint64_t a1, void *a2)
{
  return ARReflectedLightMeterCalibrationConstantForDevice(a1, a2) != 0.0;
}

long double AREstimatedSceneLuminanceForCamera(uint64_t a1, void *a2, double a3, double a4, long double a5)
{
  double v8;

  v8 = ARReflectedLightMeterCalibrationConstantForDevice(a1, a2);
  return exp2(a5) * v8 / (a3 * a4);
}

__CFString *ARCreateOBJStringForMeshAnchors(void *a1, _QWORD *a2, float a3)
{
  id v5;
  void *v6;
  void *v7;
  void *v8;
  __CFString *v9;
  NSObject *v10;
  void *v11;
  uint64_t v12;
  void *v13;
  uint8_t v15[8];
  uint64_t v16;
  _QWORD v17[2];

  v17[1] = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E48]), "initToMemory");
  v7 = v6;
  if (!v6)
  {
    _ARLogGeneral_4();
    v10 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v15 = 0;
      _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "Creating the OBJ failed.", v15, 2u);
    }

    if (a2)
    {
      v11 = (void *)MEMORY[0x1E0CB35C8];
      v12 = *MEMORY[0x1E0CB28A8];
      v16 = *MEMORY[0x1E0CB2D50];
      v17[0] = CFSTR("Failed to create an in-memory output stream.");
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v17, &v16, 1);
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "errorWithDomain:code:userInfo:", v12, -1, v13);
      *a2 = (id)objc_claimAutoreleasedReturnValue();

    }
    goto LABEL_8;
  }
  objc_msgSend(v6, "open");
  ARWriteOBJForMeshAnchorsToStream(v5, v7, a2, a3);
  if (*a2)
  {
LABEL_8:
    v9 = &stru_1E6676798;
    goto LABEL_9;
  }
  objc_msgSend(v7, "close");
  objc_msgSend(v7, "propertyForKey:", *MEMORY[0x1E0C99868]);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = (__CFString *)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3940]), "initWithData:encoding:", v8, 4);

LABEL_9:
  return v9;
}

void ARWriteOBJForMeshAnchorsToStream(void *a1, void *a2, _QWORD *a3, float a4)
{
  id v7;
  id v8;
  NSObject *v9;
  void *v10;
  id v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  void *v16;
  uint64_t v17;
  void *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;
  void *v24;
  id v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  int v44;
  double v45;
  uint64_t v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  void *v51;
  void *v52;
  void *v53;
  void *v54;
  uint64_t v55;
  void *v56;
  float *v57;
  void *v58;
  id v59;
  uint64_t v60;
  float *v61;
  void *v62;
  id v63;
  BOOL v64;
  char v65;
  void *v66;
  void *v67;
  id v68;
  uint64_t v69;
  float *v70;
  uint64_t v71;
  uint64_t i;
  int v73;
  __n128 v74;
  float *v75;
  void *v76;
  id v77;
  uint64_t v78;
  void *v79;
  uint64_t v80;
  uint64_t v81;
  float *v82;
  float *v83;
  float32x4_t v84;
  float32x4_t v85;
  float32x4_t v86;
  float32x4_t v87;
  uint64_t v88;
  float v89;
  float32x4_t v90;
  void *v91;
  void *v92;
  uint64_t v93;
  void *v94;
  id v95;
  uint64_t v96;
  void *v97;
  uint64_t v98;
  uint64_t v99;
  float *v100;
  float v101;
  float32x4_t v102;
  float32x4_t v103;
  float32x4_t v104;
  float32x4_t v105;
  float32x4_t v106;
  void *v107;
  void *v108;
  uint64_t v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  int *v113;
  uint64_t v114;
  uint64_t v115;
  int v116;
  void *v117;
  void *v118;
  uint64_t v119;
  void *v120;
  int v121;
  uint64_t v122;
  NSObject *v123;
  int v124;
  void *v125;
  uint64_t v126;
  _QWORD *v127;
  void *v128;
  uint64_t v129;
  void *v130;
  const __CFString **v131;
  uint64_t *v132;
  void *v133;
  NSObject *v134;
  void *v135;
  uint64_t v136;
  void *v137;
  NSObject *v138;
  void *v139;
  uint64_t v140;
  void *v141;
  uint64_t v142;
  id obj;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  void *v147;
  uint64_t v148;
  void *v149;
  int v150;
  void *v151;
  void *v152;
  void *v153;
  _QWORD *v154;
  uint64_t v155;
  void *v156;
  float v157;
  float v158;
  void *v159;
  uint64_t v160;
  void *v161;
  float v162;
  float v163;
  unsigned int v164;
  uint64_t v165;
  float v166;
  __int128 v167;
  __int128 v168;
  __int128 v169;
  __int128 v170;
  __int128 v171;
  __int128 v172;
  __int128 v173;
  __int128 v174;
  _BYTE v175[128];
  uint64_t v176;
  const __CFString *v177;
  uint64_t v178;
  const __CFString *v179;
  uint64_t v180;
  const __CFString *v181;
  uint8_t buf[4];
  _BYTE v183[18];
  _BYTE v184[128];
  uint64_t v185;

  v185 = *MEMORY[0x1E0C80C00];
  v7 = a1;
  v8 = a2;
  _ARLogGeneral_4();
  v9 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)buf = 134217984;
    *(_QWORD *)v183 = objc_msgSend(v7, "count");
    _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_INFO, "Writing an OBJ file for %lu mesh anchors to a stream.", buf, 0xCu);
  }

  objc_msgSend(MEMORY[0x1E0CB37A0], "string");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v171 = 0u;
  v172 = 0u;
  v173 = 0u;
  v174 = 0u;
  v11 = v7;
  v155 = objc_msgSend(v11, "countByEnumeratingWithState:objects:count:", &v171, v184, 16);
  if (!v155)
  {

    goto LABEL_60;
  }
  v151 = v10;
  v153 = v8;
  v154 = a3;
  LODWORD(v12) = 0;
  LODWORD(v13) = 0;
  v159 = v11;
  v160 = *(_QWORD *)v172;
LABEL_5:
  v14 = 0;
  while (1)
  {
    v164 = v12;
    if (*(_QWORD *)v172 != v160)
      objc_enumerationMutation(v11);
    objc_msgSend(*(id *)(*((_QWORD *)&v171 + 1) + 8 * v14), "geometry");
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v15, "vertices");
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    v17 = objc_msgSend(v16, "count");

    objc_msgSend(v15, "normals");
    v18 = (void *)objc_claimAutoreleasedReturnValue();
    v19 = objc_msgSend(v18, "count");

    objc_msgSend(v15, "vertices");
    v20 = (void *)objc_claimAutoreleasedReturnValue();
    v21 = objc_msgSend(v20, "count");
    objc_msgSend(v15, "normals");
    v22 = (void *)objc_claimAutoreleasedReturnValue();
    v23 = objc_msgSend(v22, "count");

    if (v21 != v23)
      break;
    objc_msgSend(v15, "faces");
    v24 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v24, "buffer");
    v25 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v26 = objc_msgSend(v25, "contents");

    objc_msgSend(v15, "faces");
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = objc_msgSend(v27, "count");

    if (v28 >= 1)
    {
      v29 = 0;
      while (1)
      {
        v30 = *(unsigned int *)(v26 + 4 * v29);
        objc_msgSend(v15, "vertices");
        v31 = (void *)objc_claimAutoreleasedReturnValue();
        v32 = objc_msgSend(v31, "count");

        if (v32 <= v30)
          break;
        ++v29;
        objc_msgSend(v15, "faces");
        v33 = (void *)objc_claimAutoreleasedReturnValue();
        v34 = 3 * objc_msgSend(v33, "count");

        if (v34 <= v29)
          goto LABEL_13;
      }
      _ARLogGeneral_4();
      v123 = objc_claimAutoreleasedReturnValue();
      v11 = v159;
      if (os_log_type_enabled(v123, OS_LOG_TYPE_ERROR))
      {
        v124 = *(_DWORD *)(v26 + 4 * v29);
        objc_msgSend(v15, "vertices");
        v125 = (void *)objc_claimAutoreleasedReturnValue();
        v126 = objc_msgSend(v125, "count");
        *(_DWORD *)buf = 67109376;
        *(_DWORD *)v183 = v124;
        *(_WORD *)&v183[4] = 2048;
        *(_QWORD *)&v183[6] = v126;
        _os_log_impl(&dword_1B3A68000, v123, OS_LOG_TYPE_ERROR, "Face index %d is out of range [0, %ld].", buf, 0x12u);

      }
      v8 = v153;
      v127 = v154;
      v10 = v151;
      if (v154)
      {
        v128 = (void *)MEMORY[0x1E0CB35C8];
        v129 = *MEMORY[0x1E0CB28A8];
        v178 = *MEMORY[0x1E0CB2D50];
        v179 = CFSTR("A face index is out of range.");
        v130 = (void *)MEMORY[0x1E0C99D80];
        v131 = &v179;
        v132 = &v178;
        goto LABEL_57;
      }
      goto LABEL_58;
    }
LABEL_13:
    v13 = v17 + v13;
    v12 = v19 + v164;

    ++v14;
    v11 = v159;
    if (v14 == v155)
    {
      v155 = objc_msgSend(v159, "countByEnumeratingWithState:objects:count:", &v171, v184, 16);
      if (!v155)
      {

        v8 = v153;
        a3 = v154;
        v10 = v151;
        if ((_DWORD)v13)
        {
          objc_msgSend(v151, "appendString:", CFSTR("#\n"));
          v149 = (void *)MEMORY[0x1E0CB3940];
          objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle");
          v161 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v161, "infoDictionary");
          v156 = (void *)objc_claimAutoreleasedReturnValue();
          v165 = v12;
          objc_msgSend(v156, "objectForKeyedSubscript:", CFSTR("CFBundleVersion"));
          v147 = (void *)objc_claimAutoreleasedReturnValue();
          ARKitBundle();
          v35 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v35, "infoDictionary");
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v36, "objectForKeyedSubscript:", CFSTR("CFBundleVersion"));
          v37 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(MEMORY[0x1E0CB34D0], "bundleWithIdentifier:", CFSTR("com.apple.AppleCV3D"));
          v38 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v38, "infoDictionary");
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v39, "objectForKeyedSubscript:", CFSTR("CFBundleVersion"));
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v149, "stringWithFormat:", CFSTR("# ARKit mesh exported from ARExamples %@, ARKit %@, AppleCV3D %@\n"), v147, v37, v40);
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v151, "appendString:", v41);

          objc_msgSend(v151, "appendString:", CFSTR("#\n"));
          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("# Vertex count: %d\n"), v13);
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v151, "appendString:", v42);

          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("# Face count: %d\n"), v165);
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v151, "appendString:", v43);

          objc_msgSend(v151, "appendString:", CFSTR("#\n"));
          objc_msgSend(v151, "appendString:", CFSTR("# Real world scale is 1 unit = 1 m\n"));
          objc_msgSend(v151, "appendString:", CFSTR("# Each vertex is followed by four RGBA color values in range [0.0 - 1.0] (not in spec)\n"));
          v169 = 0u;
          v170 = 0u;
          v167 = 0u;
          v168 = 0u;
          obj = v159;
          v145 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v167, v175, 16);
          if (!v145)
          {
            v8 = v153;
LABEL_71:

            v10 = v151;
            objc_msgSend(v151, "appendString:", CFSTR("\n"));
            objc_msgSend(v151, "appendString:", CFSTR("# EOF\n"));
            ARAppendStringToStream(v151, v8, v154);
LABEL_72:
            v11 = v159;
            goto LABEL_64;
          }
          v44 = 1;
          v144 = *(_QWORD *)v168;
          v45 = a4;
          while (2)
          {
            v46 = 0;
            v47 = v151;
LABEL_19:
            v150 = v44;
            if (*(_QWORD *)v168 != v144)
              objc_enumerationMutation(obj);
            v48 = *(void **)(*((_QWORD *)&v167 + 1) + 8 * v46);
            objc_msgSend(v48, "geometry");
            v49 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v47, "appendString:", CFSTR("\n"));
            v50 = (void *)MEMORY[0x1E0CB3940];
            v152 = v48;
            objc_msgSend(v48, "identifier");
            v51 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v51, "UUIDString");
            v52 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v50, "stringWithFormat:", CFSTR("o mesh_anchor_%@\n"), v52);
            v53 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v47, "appendString:", v53);

            objc_msgSend(v47, "appendString:", CFSTR("\n"));
            objc_msgSend(v49, "colors");
            v54 = (void *)objc_claimAutoreleasedReturnValue();
            v55 = objc_msgSend(v54, "count");

            objc_msgSend(v49, "classification");
            v56 = (void *)objc_claimAutoreleasedReturnValue();
            v57 = (float *)objc_msgSend(v56, "count");

            objc_msgSend(v49, "faces");
            v58 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v58, "buffer");
            v59 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v60 = objc_msgSend(v59, "contents");

            v146 = v60;
            v148 = v46;
            if (v55)
            {
              v61 = v57;
              objc_msgSend(v49, "colors");
              v62 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v62, "buffer");
              v63 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              v57 = (float *)objc_msgSend(v63, "contents");

              goto LABEL_23;
            }
            v61 = v57;
            if (v57)
            {
              objc_msgSend(v49, "vertices");
              v66 = (void *)objc_claimAutoreleasedReturnValue();
              v57 = (float *)malloc_type_malloc(12 * objc_msgSend(v66, "count"), 0x100004052888210uLL);

              objc_msgSend(v49, "classification");
              v67 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v67, "buffer");
              v68 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
              v69 = objc_msgSend(v68, "contents");

              v70 = 0;
              v71 = v60;
              do
              {
                for (i = 0; i != 12; i += 4)
                {
                  v73 = *(_DWORD *)(v71 + i);
                  v74 = ARCV3DColorComponentsForARKitSemantics(*((unsigned __int8 *)v70 + v69));
                  v75 = &v57[3 * v73];
                  *(_QWORD *)v75 = v74.n128_u64[0];
                  v75[2] = v74.n128_f32[2];
                }
                v70 = (float *)((char *)v70 + 1);
                v71 += 12;
              }
              while (v70 != v61);
              v65 = 1;
            }
            else
            {
LABEL_23:
              if (v61)
                v64 = v55 == 0;
              else
                v64 = 0;
              v65 = v64;
            }
            objc_msgSend(v49, "vertices");
            v76 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v76, "buffer");
            v77 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v78 = objc_msgSend(v77, "contents");

            objc_msgSend(v49, "vertices");
            v79 = (void *)objc_claimAutoreleasedReturnValue();
            v80 = objc_msgSend(v79, "count");

            if (v80 >= 1)
            {
              v81 = 0;
              v82 = v57 + 2;
              v83 = (float *)(v78 + 8);
              do
              {
                v157 = *(v83 - 2);
                v162 = *(v83 - 1);
                v166 = *v83;
                objc_msgSend(v152, "transform");
                if (v57)
                {
                  v88 = *((_QWORD *)v82 - 1);
                  v89 = *v82;
                }
                else
                {
                  v88 = 0x3F0000003F000000;
                  v89 = 0.5;
                }
                v90 = vaddq_f32(v87, vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v84, v157), v85, v162), v86, v166));
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("v %.06f %.06f %.06f %.03f %.03f %.03f %.03f\n"), v90.f32[0], v90.f32[1], v90.f32[2], *(float *)&v88, *((float *)&v88 + 1), v89, *(_QWORD *)&v45);
                v91 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v47, "appendString:", v91);

                ++v81;
                objc_msgSend(v49, "vertices");
                v92 = (void *)objc_claimAutoreleasedReturnValue();
                v93 = objc_msgSend(v92, "count");

                v82 += 3;
                v83 += 3;
              }
              while (v93 > v81);
            }
            if ((v65 & 1) != 0)
              free(v57);
            objc_msgSend(v47, "appendString:", CFSTR("\n"));
            objc_msgSend(v49, "normals");
            v94 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v94, "buffer");
            v95 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
            v96 = objc_msgSend(v95, "contents");

            objc_msgSend(v49, "normals");
            v97 = (void *)objc_claimAutoreleasedReturnValue();
            v98 = objc_msgSend(v97, "count");

            if (v98 >= 1)
            {
              v99 = 0;
              v100 = (float *)(v96 + 8);
              do
              {
                v158 = *(v100 - 2);
                v163 = *(v100 - 1);
                v101 = *v100;
                v100 += 3;
                objc_msgSend(v152, "transform");
                v106 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v102, v158), v103, v163), v104, v101), (float32x4_t)0, v105);
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("vn %f %f %f\n"), v106.f32[0], v106.f32[1], v106.f32[2]);
                v107 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v47, "appendString:", v107);

                ++v99;
                objc_msgSend(v49, "normals");
                v108 = (void *)objc_claimAutoreleasedReturnValue();
                v109 = objc_msgSend(v108, "count");

              }
              while (v109 > v99);
            }
            objc_msgSend(v47, "appendString:", CFSTR("\n"));
            objc_msgSend(v49, "faces");
            v110 = (void *)objc_claimAutoreleasedReturnValue();
            v111 = objc_msgSend(v110, "count");

            if (v111 >= 1)
            {
              v112 = 0;
              v113 = (int *)(v146 + 8);
              do
              {
                v114 = (*(v113 - 2) + v150);
                v115 = (*(v113 - 1) + v150);
                v116 = *v113;
                v113 += 3;
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("f %d//%d %d//%d %d//%d\n"), v114, v114, v115, v115, (v116 + v150), (v116 + v150));
                v117 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v47, "appendString:", v117);

                ++v112;
                objc_msgSend(v49, "faces");
                v118 = (void *)objc_claimAutoreleasedReturnValue();
                v119 = objc_msgSend(v118, "count");

              }
              while (v119 > v112);
            }
            objc_msgSend(v49, "vertices");
            v120 = (void *)objc_claimAutoreleasedReturnValue();
            v121 = objc_msgSend(v120, "count");

            v8 = v153;
            ARAppendStringToStream(v47, v153, v154);
            if (*v154)
            {

              v10 = v47;
              goto LABEL_72;
            }
            v44 = v150 + v121;
            objc_msgSend(MEMORY[0x1E0CB37A0], "string");
            v122 = objc_claimAutoreleasedReturnValue();

            v46 = v148 + 1;
            v47 = (void *)v122;
            if (v148 + 1 == v145)
            {
              v151 = (void *)v122;
              v145 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v167, v175, 16);
              if (v145)
                continue;
              goto LABEL_71;
            }
            goto LABEL_19;
          }
        }
LABEL_60:
        _ARLogGeneral_4();
        v134 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v134, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B3A68000, v134, OS_LOG_TYPE_ERROR, "No mesh to save.", buf, 2u);
        }

        if (a3)
        {
          v135 = (void *)MEMORY[0x1E0CB35C8];
          v136 = *MEMORY[0x1E0CB28A8];
          v176 = *MEMORY[0x1E0CB2D50];
          v177 = CFSTR("There is no mesh to save.");
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v177, &v176, 1);
          v137 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v135, "errorWithDomain:code:userInfo:", v136, -1, v137);
          *a3 = (id)objc_claimAutoreleasedReturnValue();

        }
        goto LABEL_64;
      }
      goto LABEL_5;
    }
  }
  _ARLogGeneral_4();
  v138 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v138, OS_LOG_TYPE_ERROR))
  {
    objc_msgSend(v15, "vertices");
    v139 = (void *)objc_claimAutoreleasedReturnValue();
    v140 = objc_msgSend(v139, "count");
    objc_msgSend(v15, "normals");
    v141 = (void *)objc_claimAutoreleasedReturnValue();
    v142 = objc_msgSend(v141, "count");
    *(_DWORD *)buf = 134218240;
    *(_QWORD *)v183 = v140;
    *(_WORD *)&v183[8] = 2048;
    *(_QWORD *)&v183[10] = v142;
    _os_log_impl(&dword_1B3A68000, v138, OS_LOG_TYPE_ERROR, "Vertex count %ld does not match normal count %ld.", buf, 0x16u);

  }
  v8 = v153;
  v127 = v154;
  v10 = v151;
  if (v154)
  {
    v128 = (void *)MEMORY[0x1E0CB35C8];
    v129 = *MEMORY[0x1E0CB28A8];
    v180 = *MEMORY[0x1E0CB2D50];
    v181 = CFSTR("An anchor geometrie's vertex count does not match normal count.");
    v130 = (void *)MEMORY[0x1E0C99D80];
    v131 = &v181;
    v132 = &v180;
LABEL_57:
    objc_msgSend(v130, "dictionaryWithObjects:forKeys:count:", v131, v132, 1);
    v133 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v128, "errorWithDomain:code:userInfo:", v129, -1, v133);
    *v127 = (id)objc_claimAutoreleasedReturnValue();

  }
LABEL_58:

LABEL_64:
}

void ARAppendStringToStream(void *a1, void *a2, _QWORD *a3)
{
  id v5;
  void *v6;
  uint64_t v7;
  id v8;
  void *v9;
  NSObject *v10;
  void *v11;
  void *v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  const __CFString *v16;
  uint8_t buf[4];
  void *v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  objc_msgSend(a1, "dataUsingEncoding:", 4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = objc_msgSend(v6, "length");
  v8 = objc_retainAutorelease(v6);
  if (objc_msgSend(v5, "write:maxLength:", objc_msgSend(v8, "bytes"), v7) != v7)
  {
    objc_msgSend(v5, "streamError");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    if (v9)
    {
      _ARLogGeneral_4();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        objc_msgSend(v5, "streamError");
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        *(_DWORD *)buf = 138412290;
        v18 = v11;
        _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "Writing a string to the output stream failed with error: %@", buf, 0xCu);

      }
      if (a3)
      {
        objc_msgSend(v5, "streamError");
        *a3 = (id)objc_claimAutoreleasedReturnValue();
      }
    }
    else if (a3)
    {
      v12 = (void *)MEMORY[0x1E0CB35C8];
      v13 = *MEMORY[0x1E0CB28A8];
      v15 = *MEMORY[0x1E0CB2D50];
      v16 = CFSTR("Writing a string to an output stream failed with an unknown error.");
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v16, &v15, 1);
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v12, "errorWithDomain:code:userInfo:", v13, -1, v14);
      *a3 = (id)objc_claimAutoreleasedReturnValue();

    }
  }

}

id ARKitBundle()
{
  if (ARKitBundle_onceToken != -1)
    dispatch_once(&ARKitBundle_onceToken, &__block_literal_global_176);
  return (id)ARKitBundle_arkitBundle;
}

double ARFixedIntrinsicsForBackUltraWideCamera640x480()
{
  uint64_t v0;
  double result;

  v0 = MGGetProductType();
  result = *(double *)&_PromotedConst_213;
  if (v0 <= 2722529671)
  {
    if (v0 != 1371389549 && v0 != 2080700391)
      return result;
    return *(double *)"KFyC";
  }
  if (v0 == 2722529672)
    return *(double *)"KFyC";
  if (v0 == 3863625342 || v0 == 3599094683)
    return *(double *)&_PromotedConst_212;
  return result;
}

double ARRadialDistortionForUltraWideCamera()
{
  uint64_t v0;
  double result;

  v0 = MGGetProductType();
  if (v0 <= 2722529671)
  {
    if (v0 != 1371389549)
    {
      result = -0.00199588993;
      if (v0 != 2080700391)
        return result;
    }
    return -0.000000502777423;
  }
  if (v0 == 2722529672)
    return -0.000000502777423;
  result = -0.00199588993;
  if (v0 == 3863625342 || v0 == 3599094683)
    return -0.00382197322;
  return result;
}

double ARWideToUltrawideExtrinsicsForOldRecordings()
{
  if (ARWideToUltrawideExtrinsicsForOldRecordings_onceToken != -1)
    dispatch_once(&ARWideToUltrawideExtrinsicsForOldRecordings_onceToken, &__block_literal_global_152);
  return *(double *)&ARWideToUltrawideExtrinsicsForOldRecordings_wideToUltrawideExtrinsics_0;
}

uint64_t ARDeviceHasGPSCapability()
{
  if (ARDeviceHasGPSCapability_onceToken != -1)
    dispatch_once(&ARDeviceHasGPSCapability_onceToken, &__block_literal_global_153);
  return s_deviceHasGPSCapability;
}

uint64_t AROverrideARDeviceHasGPSCapability(uint64_t result)
{
  s_deviceHasGPSCapability = result;
  return result;
}

const __SCNetworkReachability *ARDeviceHasInternetConnectivity()
{
  const __SCNetworkReachability *result;
  const __SCNetworkReachability *v1;
  SCNetworkReachabilityFlags flags;
  sockaddr address;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  address = (sockaddr)xmmword_1B3BE0150;
  result = SCNetworkReachabilityCreateWithAddress((CFAllocatorRef)*MEMORY[0x1E0C9AE00], &address);
  if (result)
  {
    v1 = result;
    flags = 0;
    SCNetworkReachabilityGetFlags(result, &flags);
    CFRelease(v1);
    return (const __SCNetworkReachability *)((flags >> 1) & 1);
  }
  return result;
}

uint64_t ARGetProcessNameForPID(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("pid=%d <Unknown>"), a1);
}

BOOL ARIsProcessRunning()
{
  void *v0;
  id v1;
  int v2;
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  id v6;
  char __s1[1024];
  _DWORD buffer[2048];
  uint64_t v10;

  v0 = (void *)MEMORY[0x1E0C80A78]();
  v10 = *MEMORY[0x1E0C80C00];
  v1 = v0;
  bzero(buffer, 0x2000uLL);
  v2 = proc_listallpids(buffer, 0x2000);
  if (v2 < 1)
  {
    v5 = 0;
  }
  else
  {
    v3 = 0;
    v4 = v2;
    v5 = 1;
    do
    {
      bzero(__s1, 0x400uLL);
      proc_name(buffer[v3], __s1, 0x400u);
      v6 = objc_retainAutorelease(v1);
      if (!strncmp(__s1, (const char *)objc_msgSend(v6, "UTF8String"), objc_msgSend(v6, "length")))
        break;
      v5 = ++v3 < v4;
    }
    while (v4 != v3);
  }

  return v5;
}

double ARGetSystemBootTime()
{
  int v0;
  int v1;
  NSObject *v2;
  char *v3;
  size_t v5;
  uint64_t v6;
  uint64_t v7;
  uint8_t buf[4];
  char *v9;
  uint64_t v10;

  v10 = *MEMORY[0x1E0C80C00];
  if (ARGetSystemBootTime_onceToken != -1)
    dispatch_once(&ARGetSystemBootTime_onceToken, &__block_literal_global_158);
  if (!ARGetSystemBootTime_bootTimeMIBSize)
    return 0.0;
  v6 = 0;
  v7 = 0;
  v5 = 16;
  v0 = sysctl(ARGetSystemBootTime_bootTimeMIB, ARGetSystemBootTime_bootTimeMIBSize, &v6, &v5, 0, 0);
  if (v0)
  {
    v1 = v0;
    _ARLogGeneral_4();
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = strerror(v1);
      *(_DWORD *)buf = 136380675;
      v9 = v3;
      _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_ERROR, "Failed to lookup kern.boottime with error: %{private}s", buf, 0xCu);
    }

    return 0.0;
  }
  return (double)(int)v7 / 1000000.0 + (double)v6;
}

double ARGetSystemUpTime()
{
  return (double)clock_gettime_nsec_np(_CLOCK_UPTIME_RAW) / 1000000000.0;
}

double ARGetSystemUpTimeIncludingSleep()
{
  return (double)clock_gettime_nsec_np(_CLOCK_MONOTONIC_RAW) / 1000000000.0;
}

double ARGetSystemUpTimeIncludingSleepAndDriftCorrection()
{
  return (double)clock_gettime_nsec_np(_CLOCK_MONOTONIC) / 1000000000.0;
}

NSObject *ARCreateDispatchSourceForSignalWithHandler(int a1, NSObject *a2, void *a3)
{
  id v5;
  NSObject *v6;
  id v7;
  _QWORD v9[4];
  id v10;
  int v11;

  v5 = a3;
  v6 = dispatch_source_create(MEMORY[0x1E0C80DC0], a1, 0, a2);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v9[2] = __ARCreateDispatchSourceForSignalWithHandler_block_invoke;
  v9[3] = &unk_1E6672618;
  v10 = v5;
  v11 = a1;
  v7 = v5;
  dispatch_source_set_event_handler(v6, v9);

  return v6;
}

__CFString *ARAVCaptureDevicePositionToString(unint64_t a1)
{
  if (a1 > 2)
    return 0;
  else
    return off_1E66726E0[a1];
}

__CFString *NSStringFromAVCaptureDevicePosition(unint64_t a1)
{
  if (a1 > 2)
    return 0;
  else
    return off_1E66726E0[a1];
}

id ARCreateTransactionForService(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;
  void *v5;
  id v6;
  void *v7;

  v1 = (void *)MEMORY[0x1E0CB3940];
  v2 = a1;
  objc_msgSend((id)objc_opt_class(), "serviceName");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "clientBundleIdentifier");
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v1, "stringWithFormat:", CFSTR("%@:%@"), v3, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = objc_retainAutorelease(v5);
  objc_msgSend(v6, "UTF8String");
  v7 = (void *)os_transaction_create();

  return v7;
}

id ARGetSubclassesForClassAndImage(objc_class *a1, const void *a2)
{
  return AREnumerateClasses(a2, 0, a1);
}

id AREnumerateClasses(const void *a1, void *a2, objc_class *a3)
{
  Protocol *v5;
  void *v6;
  void *v7;
  uint32_t v8;
  uint32_t v9;
  uint32_t v10;
  uint64_t v11;
  const mach_header *image_header;
  _QWORD v14[4];
  id v15;
  _QWORD block[4];
  id v17;

  v5 = a2;
  v6 = (void *)objc_opt_new();
  v7 = v6;
  if (a1)
  {
    block[0] = MEMORY[0x1E0C809B0];
    block[1] = 3221225472;
    block[2] = __AREnumerateClasses_block_invoke;
    block[3] = &unk_1E66726C0;
    v17 = v6;
    objc_enumerateClasses(a1, 0, v5, a3, block);

  }
  else
  {
    v8 = _dyld_image_count();
    if (v8)
    {
      v9 = v8;
      v10 = 0;
      v11 = MEMORY[0x1E0C809B0];
      do
      {
        image_header = _dyld_get_image_header(v10);
        v14[0] = v11;
        v14[1] = 3221225472;
        v14[2] = __AREnumerateClasses_block_invoke_2;
        v14[3] = &unk_1E66726C0;
        v15 = v7;
        objc_enumerateClasses(image_header, 0, v5, a3, v14);

        ++v10;
      }
      while (v9 != v10);
    }
  }

  return v7;
}

id ARGetSubclassesForClass(objc_class *a1)
{
  return AREnumerateClasses(0, 0, a1);
}

id ARGetClassesImplementingProtocol(void *a1)
{
  return AREnumerateClasses(0, a1, 0);
}

id ARLibraryDirectory()
{
  if (ARLibraryDirectory_onceToken != -1)
    dispatch_once(&ARLibraryDirectory_onceToken, &__block_literal_global_168);
  return (id)ARLibraryDirectory_arkitLibraryDirectory;
}

id ARCacheDirectory()
{
  if (ARCacheDirectory_onceToken != -1)
    dispatch_once(&ARCacheDirectory_onceToken, &__block_literal_global_173);
  return (id)ARCacheDirectory_arkitCacheDirectory;
}

id ARCreateTemporaryDirectory(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  id v7;

  NSTemporaryDirectory();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = (void *)objc_opt_new();
  objc_msgSend(v3, "UUIDString");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "stringByAppendingPathComponent:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  LODWORD(v3) = objc_msgSend(v6, "createDirectoryAtPath:withIntermediateDirectories:attributes:error:", v5, 0, 0, a1);

  v7 = 0;
  if ((_DWORD)v3)
    v7 = v5;

  return v7;
}

id ARSandboxDirectories()
{
  void *v0;
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  _QWORD v6[3];

  v6[2] = *MEMORY[0x1E0C80C00];
  NSTemporaryDirectory();
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "stringByStandardizingPath");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v6[0] = v1;
  ARLibraryDirectory();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "stringByStandardizingPath");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v6[1] = v3;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v6, 2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

uint64_t ARSandboxContains(void *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;
  void *v4;
  uint64_t v5;
  uint64_t i;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  _BYTE v12[128];
  uint64_t v13;

  v13 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "stringByStandardizingPath");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0CB3620], "defaultManager");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "fileExistsAtPath:isDirectory:", v1, 0);

  if ((_DWORD)v3)
  {
    v10 = 0u;
    v11 = 0u;
    v8 = 0u;
    v9 = 0u;
    ARSandboxDirectories();
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
    if (v3)
    {
      v5 = *(_QWORD *)v9;
      while (2)
      {
        for (i = 0; i != v3; ++i)
        {
          if (*(_QWORD *)v9 != v5)
            objc_enumerationMutation(v4);
          if ((objc_msgSend(v1, "hasPrefix:", *(_QWORD *)(*((_QWORD *)&v8 + 1) + 8 * i), (_QWORD)v8) & 1) != 0)
          {
            v3 = 1;
            goto LABEL_12;
          }
        }
        v3 = objc_msgSend(v4, "countByEnumeratingWithState:objects:count:", &v8, v12, 16);
        if (v3)
          continue;
        break;
      }
    }
LABEL_12:

  }
  return v3;
}

id ARCreateFixedPriorityPthreadQueue(uint64_t a1, int a2)
{
  void *v3;
  sched_param v5;
  pthread_attr_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  memset(&v6, 0, sizeof(v6));
  pthread_attr_init(&v6);
  v5 = 0;
  pthread_attr_getschedparam(&v6, &v5);
  v5.sched_priority = a2;
  pthread_attr_setschedpolicy(&v6, 2);
  pthread_attr_setschedparam(&v6, &v5);
  pthread_attr_setinheritsched(&v6, 2);
  v3 = (void *)dispatch_pthread_root_queue_create();
  pthread_attr_destroy(&v6);
  return v3;
}

id _ARSystemLibraryPath()
{
  void *v0;
  void *v1;

  NSSearchPathForDirectoriesInDomains(NSLibraryDirectory, 8uLL, 1);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  if (objc_msgSend(v0, "count"))
  {
    objc_msgSend(v0, "objectAtIndex:", 0);
    v1 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v1 = 0;
  }

  return v1;
}

id ARKitUIBundle()
{
  if (ARKitUIBundle_onceToken != -1)
    dispatch_once(&ARKitUIBundle_onceToken, &__block_literal_global_181);
  return (id)ARKitUIBundle_arkitUIBundle;
}

uint64_t ARLoadExternalBundleByName()
{
  return 0;
}

BOOL ARSubclassOverridesSelector(objc_class *a1, objc_class *a2, SEL name)
{
  IMP MethodImplementation;
  IMP v6;
  BOOL v7;

  if (a1 == a2)
    return 0;
  MethodImplementation = class_getMethodImplementation(a1, name);
  v6 = class_getMethodImplementation(a2, name);
  if (MethodImplementation)
    v7 = v6 == 0;
  else
    v7 = 1;
  return !v7 && MethodImplementation != v6;
}

BOOL ARSubclassOverridesClassSelector(void *a1, void *a2, uint64_t a3)
{
  uint64_t v5;
  uint64_t v6;
  BOOL v7;

  if (a1 == a2)
    return 0;
  v5 = objc_msgSend(a1, "methodForSelector:");
  v6 = objc_msgSend(a2, "methodForSelector:", a3);
  if (v5)
    v7 = v6 == 0;
  else
    v7 = 1;
  return !v7 && v5 != v6;
}

id ARApprovedDecoderClasses()
{
  if (ARApprovedDecoderClasses_onceToken != -1)
    dispatch_once(&ARApprovedDecoderClasses_onceToken, &__block_literal_global_191);
  return (id)ARApprovedDecoderClasses_set;
}

id ARCrashReporterKey()
{
  if (ARCrashReporterKey_onceToken != -1)
    dispatch_once(&ARCrashReporterKey_onceToken, &__block_literal_global_197);
  return (id)ARCrashReporterKey_crashReporterKey;
}

id _ARLogTechnique()
{
  if (_ARLogTechnique_onceToken != -1)
    dispatch_once(&_ARLogTechnique_onceToken, &__block_literal_global_168_0);
  return (id)_ARLogTechnique_logObj;
}

void sub_1B3A8F38C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A8F5B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::operator=[abi:ne180100](uint64_t a1, __int128 *a2)
{
  __int128 v3;
  std::__shared_weak_count *v4;
  unint64_t *p_shared_owners;
  unint64_t v6;

  v3 = *a2;
  *(_QWORD *)a2 = 0;
  *((_QWORD *)a2 + 1) = 0;
  v4 = *(std::__shared_weak_count **)(a1 + 8);
  *(_OWORD *)a1 = v3;
  if (v4)
  {
    p_shared_owners = (unint64_t *)&v4->__shared_owners_;
    do
      v6 = __ldaxr(p_shared_owners);
    while (__stlxr(v6 - 1, p_shared_owners));
    if (!v6)
    {
      ((void (*)(std::__shared_weak_count *))v4->__on_zero_shared)(v4);
      std::__shared_weak_count::__release_weak(v4);
    }
  }
  return a1;
}

void sub_1B3A8F81C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A8FC58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28)
{
  void *v28;
  void *v29;
  uint64_t v30;
  void *v32;

  v32 = *(void **)(v30 - 128);
  if (v32)
  {
    *(_QWORD *)(v30 - 120) = v32;
    operator delete(v32);
  }

  _Unwind_Resume(a1);
}

void sub_1B3A8FDB0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A9002C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A90390(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3A90520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3A906A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A908B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A909FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A90B1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A90D14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A91290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3A9142C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A91924(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3A91B60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_0()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_4()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

_QWORD *std::allocate_shared[abi:ne180100]<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,int,void>@<X0>(int *a1@<X1>, _QWORD *a2@<X8>)
{
  _QWORD *v4;
  _QWORD *result;

  v4 = operator new(0x78uLL);
  result = std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,0>(v4, a1);
  *a2 = v4 + 3;
  a2[1] = v4;
  return result;
}

void sub_1B3A91D6C(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__shared_ptr_emplace[abi:ne180100]<int,std::allocator<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>,0>(_QWORD *a1, int *a2)
{
  a1[1] = 0;
  a1[2] = 0;
  *a1 = &unk_1E6670538;
  arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::KeyMapBuffer((uint64_t)(a1 + 3), *a2);
  return a1;
}

void sub_1B3A91DBC(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670538;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670538;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

uint64_t std::__shared_ptr_emplace<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::__on_zero_shared(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 24;
  std::deque<std::pair<int,int>>::~deque[abi:ne180100]((_QWORD *)(a1 + 64));
  return std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::~__hash_table(v1);
}

uint64_t std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__deallocate_node(int a1, _QWORD *__p)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  if (__p)
  {
    v2 = __p;
    do
    {
      v3 = (_QWORD *)*v2;
      v4 = (void *)v2[3];
      if (v4)
      {
        v2[4] = v4;
        operator delete(v4);
      }
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

uint64_t std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100](uint64_t a1)
{
  std::__shared_weak_count *v2;
  unint64_t *p_shared_owners;
  unint64_t v4;

  v2 = *(std::__shared_weak_count **)(a1 + 8);
  if (v2)
  {
    p_shared_owners = (unint64_t *)&v2->__shared_owners_;
    do
      v4 = __ldaxr(p_shared_owners);
    while (__stlxr(v4 - 1, p_shared_owners));
    if (!v4)
    {
      ((void (*)(std::__shared_weak_count *))v2->__on_zero_shared)(v2);
      std::__shared_weak_count::__release_weak(v2);
    }
  }
  return a1;
}

id _ARLogTechnique_0()
{
  if (_ARLogTechnique_onceToken_0 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_0, &__block_literal_global_173_0);
  return (id)_ARLogTechnique_logObj_0;
}

void sub_1B3A93160(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  void (*v6)(uint64_t *);
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  va_list va1;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  va_list va2;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  va_list va3;

  va_start(va3, a2);
  va_start(va2, a2);
  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, void (*)(uint64_t *));
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v9 = va_arg(va1, _QWORD);
  v10 = va_arg(va1, _QWORD);
  va_copy(va2, va1);
  v11 = va_arg(va2, _QWORD);
  v13 = va_arg(va2, _QWORD);
  v14 = va_arg(va2, _QWORD);
  v15 = va_arg(va2, _QWORD);
  va_copy(va3, va2);
  v16 = va_arg(va3, _QWORD);
  v18 = va_arg(va3, _QWORD);
  v19 = va_arg(va3, _QWORD);
  v20 = va_arg(va3, _QWORD);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Block_object_dispose(va2, 8);
  _Block_object_dispose(va3, 8);
  _Unwind_Resume(a1);
}

void sub_1B3A9522C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,id location,os_activity_scope_state_s state)
{
  id *v27;
  id *v28;

  objc_destroyWeak(v28);
  objc_destroyWeak(v27);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_5()
{
  if (_ARLogGeneral_onceToken_6 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_6, &__block_literal_global_209_0);
  return (id)_ARLogGeneral_logObj_6;
}

void sub_1B3A9545C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3A956A0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3A95A54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3A95B60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3A95C00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3A95ED0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3A96124(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3A9645C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3A9658C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3A96794(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3A969EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location, os_activity_scope_state_s state)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3A97058(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A97144(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A97458(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A981F0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

__n64 simd_matrix3x3(float32x4_t a1)
{
  float v9;
  __n64 result;

  _Q2 = a1;
  _S3 = a1.i32[1];
  _S4 = a1.i32[2];
  __asm { FMLS            S0, S4, V2.S[2] }
  _S6 = _Q2.i32[3];
  __asm { FMLA            S0, S6, V2.S[3] }
  v9 = vmlas_n_f32(vmuls_lane_f32(a1.f32[2], _Q2, 3), a1.f32[1], _Q2.f32[0]);
  __asm
  {
    FMLA            S5, S3, V2.S[1]
    FMLA            S5, S6, V2.S[3]
    FMLS            S5, S2, V2.S[0]
    FMLA            S18, S4, V2.S[1]
    FMLA            S6, S4, V2.S[2]
    FMLS            S6, S2, V2.S[0]
    FMLS            S6, S3, V2.S[1]
  }
  result.n64_f32[1] = v9 + v9;
  return result;
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void sub_1B3A9871C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A98C28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A98D9C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3A99204(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3A99474(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A999EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23,void *a24)
{
  void *v24;

  _Unwind_Resume(a1);
}

void sub_1B3A99B38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3A99C1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id ARFilterFaceTrackingPayload(void *a1)
{
  id v1;
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  void *v7;
  void *v8;
  char isKindOfClass;
  NSArray *v10;
  void *v11;
  void *v12;
  char v13;
  id v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _BYTE v20[128];
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if (v1)
  {
    if (ARFilterFaceTrackingPayload::onceToken != -1)
      dispatch_once(&ARFilterFaceTrackingPayload::onceToken, &__block_literal_global_233);
    v15 = (id)objc_opt_new();
    v18 = 0u;
    v19 = 0u;
    v16 = 0u;
    v17 = 0u;
    objc_msgSend(v1, "allKeys");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
    if (v3)
    {
      v4 = *(_QWORD *)v17;
      do
      {
        for (i = 0; i != v3; ++i)
        {
          if (*(_QWORD *)v17 != v4)
            objc_enumerationMutation(v2);
          v6 = *(_QWORD *)(*((_QWORD *)&v16 + 1) + 8 * i);
          v7 = (void *)MEMORY[0x1B5E2DDB0]();
          objc_opt_class();
          if ((objc_opt_isKindOfClass() & 1) != 0)
          {
            if (objc_msgSend((id)ARFilterFaceTrackingPayload::approvedListNoFurtherFiltering, "containsObject:", v6))goto LABEL_17;
            if (!objc_msgSend((id)ARFilterFaceTrackingPayload::approvedList, "containsObject:", v6))
              goto LABEL_19;
            objc_msgSend(v1, "objectForKeyedSubscript:", v6);
            v8 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            isKindOfClass = objc_opt_isKindOfClass();

            if ((isKindOfClass & 1) != 0)
            {
              objc_msgSend(v1, "objectForKeyedSubscript:", v6);
              v10 = (NSArray *)objc_claimAutoreleasedReturnValue();
              ARFilterFaceTrackingPayload(v10);
              v11 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v15, "setObject:forKeyedSubscript:", v11, v6);
              goto LABEL_16;
            }
            objc_msgSend(v1, "objectForKeyedSubscript:", v6);
            v12 = (void *)objc_claimAutoreleasedReturnValue();
            objc_opt_class();
            v13 = objc_opt_isKindOfClass();

            if ((v13 & 1) == 0)
            {
LABEL_17:
              objc_msgSend(v1, "objectForKeyedSubscript:", v6);
              v10 = (NSArray *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v15, "setObject:forKeyedSubscript:", v10, v6);
            }
            else
            {
              objc_msgSend(v1, "objectForKeyedSubscript:", v6);
              v10 = (NSArray *)objc_claimAutoreleasedReturnValue();
              _ARFilterFaceTrackingPayloadArray(v10);
              v11 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v15, "setObject:forKeyedSubscript:", v11, v6);
LABEL_16:

            }
          }
LABEL_19:
          objc_autoreleasePoolPop(v7);
        }
        v3 = objc_msgSend(v2, "countByEnumeratingWithState:objects:count:", &v16, v20, 16);
      }
      while (v3);
    }

  }
  else
  {
    v15 = 0;
  }

  return v15;
}

void sub_1B3A99F2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

id _ARFilterFaceTrackingPayloadArray(NSArray *a1)
{
  NSArray *v1;
  void *v2;
  NSArray *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  NSArray *v8;
  void *v9;
  void *v10;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _BYTE v16[128];
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v2 = (void *)objc_opt_new();
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v3 = v1;
  v4 = -[NSArray countByEnumeratingWithState:objects:count:](v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
  v5 = v4;
  if (v4)
  {
    v6 = *(_QWORD *)v13;
    do
    {
      v7 = 0;
      do
      {
        if (*(_QWORD *)v13 != v6)
          objc_enumerationMutation(v3);
        v8 = *(NSArray **)(*((_QWORD *)&v12 + 1) + 8 * v7);
        v9 = (void *)MEMORY[0x1B5E2DDB0](v4);
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          ARFilterFaceTrackingPayload(v8);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObject:", v10);
LABEL_10:

          goto LABEL_12;
        }
        objc_opt_class();
        if ((objc_opt_isKindOfClass() & 1) != 0)
        {
          _ARFilterFaceTrackingPayloadArray(v8);
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObject:", v10);
          goto LABEL_10;
        }
        objc_msgSend(v2, "addObject:", v8, (_QWORD)v12);
LABEL_12:
        objc_autoreleasePoolPop(v9);
        ++v7;
      }
      while (v5 != v7);
      v4 = -[NSArray countByEnumeratingWithState:objects:count:](v3, "countByEnumeratingWithState:objects:count:", &v12, v16, 16);
      v5 = v4;
    }
    while (v4);
  }

  return v2;
}

void sub_1B3A9A32C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_5()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

char *std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<float>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<float>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 1);
        v17 -= 16;
        *((_OWORD *)v14 - 1) = v19;
        v14 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

_QWORD *std::vector<float>::__init_with_size[abi:ne180100]<float const*,float const*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3A9A67C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEEC2Em(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B3A9A6F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *_ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE16__init_with_sizeB8ne180100IPKS1_S7_EEvT_T0_m(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3A9A768(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3A9A8F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;
  void *v11;

  v11 = v10;

  a9.super_class = (Class)ARFaceTrackingImageSensor;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

id _ARLogSensor(void)
{
  if (_ARLogSensor(void)::onceToken != -1)
    dispatch_once(&_ARLogSensor(void)::onceToken, &__block_literal_global_135);
  return (id)_ARLogSensor(void)::logObj;
}

void sub_1B3A9AA84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A9AC94(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A9AD78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A9B554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3A9B740(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A9B840(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A9BAA8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A9BCE4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3A9C7C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3A9CAD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3A9D0BC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17)
{
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1B3A9D240(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3A9D7FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3A9D994(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void ___ZL12_ARLogSensorv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Sensor");
  v1 = (void *)_ARLogSensor(void)::logObj;
  _ARLogSensor(void)::logObj = (uint64_t)v0;

}

uint64_t rawGyroscopeCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  objc_msgSend(a2, "gyroscopeOutput:", a1);
  return kdebug_trace();
}

uint64_t rawAccelerometerCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  objc_msgSend(a2, "accelerometerOutput:", a1);
  return kdebug_trace();
}

uint64_t rawMagnetometerCallback(uint64_t a1, void *a2)
{
  kdebug_trace();
  objc_msgSend(a2, "magnetometerOutput:", a1);
  return kdebug_trace();
}

id _ARLogSensor_0()
{
  if (_ARLogSensor_onceToken_0 != -1)
    dispatch_once(&_ARLogSensor_onceToken_0, &__block_literal_global_19);
  return (id)_ARLogSensor_logObj_0;
}

id ARDictionaryFromAnchors(void *a1)
{
  id v1;
  void *v2;
  id v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  void *v8;
  void *v9;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  _BYTE v15[128];
  uint64_t v16;

  v16 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionaryWithCapacity:", objc_msgSend(v1, "count"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  v14 = 0u;
  v3 = v1;
  v4 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
  if (v4)
  {
    v5 = v4;
    v6 = *(_QWORD *)v12;
    do
    {
      for (i = 0; i != v5; ++i)
      {
        if (*(_QWORD *)v12 != v6)
          objc_enumerationMutation(v3);
        v8 = *(void **)(*((_QWORD *)&v11 + 1) + 8 * i);
        objc_msgSend(v8, "identifier", (_QWORD)v11);
        v9 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v2, "setObject:forKey:", v8, v9);

      }
      v5 = objc_msgSend(v3, "countByEnumeratingWithState:objects:count:", &v11, v15, 16);
    }
    while (v5);
  }

  return v2;
}

id ARAnchorsForPoseGraphUpdates(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0CB3880];
  v2 = a1;
  objc_msgSend(v1, "predicateWithBlock:", &__block_literal_global_20);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "filteredArrayUsingPredicate:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id ARAnchorsForPublicDelegate(void *a1)
{
  void *v1;
  id v2;
  void *v3;
  void *v4;

  v1 = (void *)MEMORY[0x1E0CB3880];
  v2 = a1;
  objc_msgSend(v1, "predicateWithBlock:", &__block_literal_global_40);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "filteredArrayUsingPredicate:", v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

__IOHIDServiceClient *copyHIDServicePlugin(__IOHIDEventSystemClient *a1, int a2, int a3, const char *a4)
{
  const __CFAllocator *v6;
  CFNumberRef v7;
  CFNumberRef v8;
  CFDictionaryRef v9;
  const __CFArray *v10;
  const __CFArray *v11;
  CFIndex Count;
  CFIndex v13;
  CFIndex v14;
  __IOHIDServiceClient *ValueAtIndex;
  void *v16;
  const void *v17;
  int v18;
  int v19;
  const __CFString *v20;
  const __CFString *v21;
  CFTypeID v22;
  const char *CStringPtr;
  size_t v24;
  const char *v25;
  char *v26;
  size_t v27;
  CFTypeID v28;
  size_t v29;
  int v30;
  const __CFNumber *v32;
  const __CFNumber *v33;
  uint64_t v34;
  int v35;
  int valuePtr;
  char __str[32];
  void *values[2];
  void *keys[2];
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v35 = a3;
  valuePtr = a2;
  if (!a1)
    return 0;
  v6 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
  v7 = CFNumberCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], kCFNumberSInt32Type, &valuePtr);
  v8 = CFNumberCreate(v6, kCFNumberSInt32Type, &v35);
  *(_OWORD *)keys = xmmword_1E6672F38;
  values[0] = v7;
  values[1] = v8;
  v9 = CFDictionaryCreate(v6, (const void **)keys, (const void **)values, 2, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
  IOHIDEventSystemClientSetMatching();
  v10 = IOHIDEventSystemClientCopyServices(a1);
  v11 = v10;
  if (!v10 || CFArrayGetCount(v10) < 1 || (Count = CFArrayGetCount(v11), Count < 1))
  {
    ValueAtIndex = 0;
    goto LABEL_27;
  }
  v13 = Count;
  v32 = v8;
  v33 = v7;
  v14 = 0;
  while (1)
  {
    ValueAtIndex = (__IOHIDServiceClient *)CFArrayGetValueAtIndex(v11, v14);
    v16 = (void *)IOHIDServiceClientCopyProperty(ValueAtIndex, CFSTR("PrimaryUsage"));
    if (!v16)
      goto LABEL_21;
    v17 = v16;
    v18 = objc_msgSend(v16, "intValue");
    v19 = v35;
    CFRelease(v17);
    if (v18 != v19)
      goto LABEL_21;
    if (!a4 || !*a4)
      break;
    v20 = (const __CFString *)IOHIDServiceClientCopyProperty(ValueAtIndex, CFSTR("LocationID"));
    if (v20)
    {
      v21 = v20;
      v22 = CFGetTypeID(v20);
      if (v22 == CFStringGetTypeID())
      {
        CStringPtr = CFStringGetCStringPtr(v21, 0x8000100u);
        v24 = strlen(a4);
        if (v24 != strlen(CStringPtr))
          goto LABEL_20;
        v25 = a4;
        v26 = (char *)CStringPtr;
        v27 = v24;
      }
      else
      {
        v28 = CFGetTypeID(v21);
        if (v28 != CFNumberGetTypeID()
          || (v34 = 0, !CFNumberGetValue((CFNumberRef)v21, kCFNumberLongType, &v34))
          || (snprintf(__str, 0x20uLL, "%lu", v34), v29 = strlen(a4), v29 != strlen(__str)))
        {
LABEL_20:
          CFRelease(v21);
          goto LABEL_21;
        }
        v26 = __str;
        v25 = a4;
        v27 = v29;
      }
      v30 = strncmp(v25, v26, v27);
      CFRelease(v21);
      if (!v30)
        break;
    }
LABEL_21:
    if (v13 == ++v14)
    {
      ValueAtIndex = 0;
      goto LABEL_26;
    }
  }
  CFRetain(ValueAtIndex);
LABEL_26:
  v8 = v32;
  v7 = v33;
LABEL_27:
  CFRelease(v9);
  CFRelease(v7);
  CFRelease(v8);
  if (v11)
    CFRelease(v11);
  return ValueAtIndex;
}

void rawIOHIDEventCallback(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  id v5;
  unint64_t v6;
  unint64_t v7;
  double v8;
  mach_timebase_info info;

  v5 = a1;
  info = 0;
  mach_timebase_info(&info);
  LODWORD(v7) = info.denom;
  LODWORD(v6) = info.numer;
  v8 = (double)v6 / (double)v7 * 0.000000001 * (double)(unint64_t)IOHIDEventGetTimeStamp();
  if (IOHIDEventGetType() == 13)
  {
    kdebug_trace();
    objc_msgSend(v5, "accelerometerDidOutputEvent:timestamp:", a4, v8);
LABEL_5:
    kdebug_trace();
    goto LABEL_6;
  }
  if (IOHIDEventGetType() == 20)
  {
    kdebug_trace();
    objc_msgSend(v5, "gyroscopeDidOutputEvent:timestamp:", a4, v8);
    goto LABEL_5;
  }
LABEL_6:

}

void sub_1B3AA0B4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA0C74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA0DD0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AA0EAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA0FC0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA1334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23)
{
  uint64_t v23;
  void *v25;

  if (__p)
    operator delete(__p);
  if (a19)
    operator delete(a19);
  if (a22)
    operator delete(a22);
  v25 = *(void **)(v23 - 112);
  if (v25)
  {
    *(_QWORD *)(v23 - 104) = v25;
    operator delete(v25);
  }

  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        v10 -= 16;
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<unsigned long long>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void sub_1B3AA1934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  uint64_t v28;
  void *v30;
  void *v31;

  if (__p)
    operator delete(__p);
  if (a19)
    operator delete(a19);
  if (a23)
    operator delete(a23);
  if (a27)
    operator delete(a27);
  v30 = *(void **)(v28 - 160);
  if (v30)
  {
    *(_QWORD *)(v28 - 152) = v30;
    operator delete(v30);
  }
  v31 = *(void **)(v28 - 128);
  if (v31)
  {
    *(_QWORD *)(v28 - 120) = v31;
    operator delete(v31);
  }

  _Unwind_Resume(a1);
}

void std::vector<float>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 2)
  {
    if (a2 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = &v6[4 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_DWORD *)v11 - 1);
        v11 -= 4;
        *((_DWORD *)v12 - 1) = v13;
        v12 -= 4;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void std::vector<unsigned long long>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<unsigned long long>::__append((char **)a1, a2 - v2);
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((char **)a1, a2 - v2);
  }
}

void sub_1B3AA1B7C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  uint64_t v14;
  void *v16;

  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  v16 = *(void **)(v14 - 48);
  if (v16)
  {
    *(_QWORD *)(v14 - 40) = v16;
    operator delete(v16);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3AA1D68(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA2318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24)
{
  uint64_t v24;
  void *v26;

  if (__p)
    operator delete(__p);
  if (a19)
    operator delete(a19);
  if (a23)
    operator delete(a23);
  v26 = *(void **)(v24 - 112);
  if (v26)
  {
    *(_QWORD *)(v24 - 104) = v26;
    operator delete(v26);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3AA2654(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a17)
    operator delete(a17);
  if (a21)
    operator delete(a21);
  _Unwind_Resume(exception_object);
}

void sub_1B3AA2C14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,_QWORD *a47)
{
  if (__p)
    operator delete(__p);
  if (a29)
    operator delete(a29);
  if (a33)
    operator delete(a33);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a46, a47);

  _Unwind_Resume(a1);
}

void sub_1B3AA2D58(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, char a12)
{
  if (__p)
    operator delete(__p);
  +[ARPointCloud emptyPointCloud].cold.1((uint64_t)&a12);
  _Unwind_Resume(a1);
}

void sub_1B3AA2FAC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AA31E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *__p, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  uint64_t v26;
  void *v28;

  if (__p)
    operator delete(__p);
  if (a22)
    operator delete(a22);
  if (a25)
    operator delete(a25);
  v28 = *(void **)(v26 - 96);
  if (v28)
  {
    *(_QWORD *)(v26 - 88) = v28;
    operator delete(v28);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3AA32CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AA34A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AA355C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AA3718(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<unsigned long long>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

void std::vector<float>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 2);
    if (v10 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = v5 - v8;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = &v14[4 * v13];
    bzero(v15, 4 * a2);
    v17 = &v15[4 * a2];
    while (v7 != v8)
    {
      v18 = *((_DWORD *)v7 - 1);
      v7 -= 4;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

__n128 _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE13__move_assignERS4_NS_17integral_constantIbLb1EEE(uint64_t a1, __n128 *a2)
{
  void *v4;
  __n128 result;

  v4 = *(void **)a1;
  if (v4)
  {
    *(_QWORD *)(a1 + 8) = v4;
    operator delete(v4);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
  }
  result = *a2;
  *(__n128 *)a1 = *a2;
  *(_QWORD *)(a1 + 16) = a2[1].n128_u64[0];
  a2->n128_u64[0] = 0;
  a2->n128_u64[1] = 0;
  a2[1].n128_u64[0] = 0;
  return result;
}

_QWORD *std::vector<unsigned long long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B3AA3A68(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t **_ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE25__emplace_unique_key_argsIyJNS_4pairIyS2_EEEEENSC_INS_15__tree_iteratorIS3_PNS_11__tree_nodeIS3_PvEElEEbEERKT_DpOT0_(uint64_t **a1, unint64_t *a2, uint64_t a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  _QWORD *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = operator new(0x40uLL);
    v10[4] = *(_QWORD *)a3;
    *((_OWORD *)v10 + 3) = *(_OWORD *)(a3 + 16);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

uint64_t *_ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

_QWORD *std::vector<unsigned long long>::__init_with_size[abi:ne180100]<unsigned long long *,unsigned long long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3AA3D8C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3AA3E04(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double ARRotateCovariance(double a1, double a2, __n128 a3, int32x4_t a4, int32x4_t a5, int32x4_t a6)
{
  uint64_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  int32x4_t v10;
  uint64_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  _OWORD v16[2];
  __n128 v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;

  v6 = 0;
  v7 = vzip1q_s32(a4, a6);
  v8 = vzip1q_s32(v7, a5);
  v9 = vzip1q_s32(vzip2q_s32(a4, a6), vdupq_laneq_s32(a5, 2));
  v10 = vzip2q_s32(v7, vdupq_lane_s32(*(int32x2_t *)a5.i8, 1));
  v17 = a3;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v6 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a4, COERCE_FLOAT(v16[v6])), (float32x4_t)a5, *(float32x2_t *)&v16[v6], 1), (float32x4_t)a6, (float32x4_t)v16[v6], 2);
    ++v6;
  }
  while (v6 != 3);
  v11 = 0;
  v8.i32[3] = 0;
  v10.i32[3] = 0;
  v9.i32[3] = 0;
  v12 = v18;
  v13 = v19;
  v14 = v20;
  v16[0] = v8;
  v16[1] = v10;
  v17 = (__n128)v9;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v11 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, COERCE_FLOAT(v16[v11])), v13, *(float32x2_t *)&v16[v11], 1), v14, (float32x4_t)v16[v11], 2);
    ++v11;
  }
  while (v11 != 3);
  return *(double *)v18.i64;
}

float tanFromCos(float a1)
{
  return sqrtf(1.0 - (float)(a1 * a1)) / a1;
}

float computeVarianceInCamZ(__n128 a1, float a2)
{
  float v2;

  v2 = a1.n128_f32[2] / (float)(sqrtf(1.0 - (float)(a2 * a2)) / a2);
  return (float)(v2 * *(float *)&k_viofeature_normalized_disparity_error)
       * (float)(v2 * *(float *)&k_viofeature_normalized_disparity_error);
}

__n64 ARPointVarianceVIOFeature()
{
  __n64 result;

  result.n64_u32[0] = k_viofeature_variance_xy;
  result.n64_u32[1] = k_viofeature_variance_xy;
  return result;
}

double ARPointCovarianceVIOFeature(__n128 a1, int32x4_t a2, int32x4_t a3, int32x4_t a4, float a5)
{
  float v8;
  unsigned int v9;
  __n128 v10;
  double v11;

  v8 = sqrtf(1.0 - (float)(a5 * a5));
  *(float *)&v9 = (float)((float)(a1.n128_f32[2] / (float)(v8 / a5)) * *(float *)&k_viofeature_normalized_disparity_error)
                * (float)((float)(a1.n128_f32[2] / (float)(v8 / a5)) * *(float *)&k_viofeature_normalized_disparity_error);
  v10.n128_u64[0] = 0;
  LODWORD(v11) = 0;
  HIDWORD(v11) = k_viofeature_variance_xy;
  v10.n128_u64[1] = v9;
  return ARRotateCovariance(COERCE_DOUBLE((unint64_t)k_viofeature_variance_xy), v11, v10, a2, a3, a4);
}

__n64 ARPointVarianceJasper()
{
  __n64 result;

  result.n64_u32[0] = k_jasper_variance_uv;
  result.n64_u32[1] = k_jasper_variance_uv;
  return result;
}

double ARPointCovarianceJasper(__n128 a1, int32x4_t a2, int32x4_t a3, int32x4_t a4)
{
  __n128 v7;
  double v8;

  a1.n128_f32[0] = *(float *)&k_jasper_max_z - a1.n128_f32[2];
  if ((float)(*(float *)&k_jasper_max_z - a1.n128_f32[2]) < 0.0)
    a1.n128_f32[0] = 0.0;
  v7.n128_u64[0] = 0;
  v7.n128_u32[3] = 0;
  LODWORD(v8) = 0;
  HIDWORD(v8) = k_jasper_variance_uv;
  v7.n128_f32[2] = *(float *)&k_jasper_variance_z * (float)(1.0 - (float)(a1.n128_f32[0] / *(float *)&k_jasper_max_z));
  return ARRotateCovariance(COERCE_DOUBLE((unint64_t)k_jasper_variance_uv), v8, v7, a2, a3, a4);
}

void *ar_rt_frame_time_estimator_init(uint64_t a1, int a2)
{
  void *result;

  ar_rt_ring_buffer_init(a1, a2);
  result = malloc_type_calloc(a2, 8uLL, 0x100004000313F17uLL);
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

void ar_rt_frame_time_estimator_reset(uint64_t a1)
{
  ar_rt_ring_buffer_reset(a1);
  free(*(void **)(a1 + 16));
}

uint64_t ar_rt_frame_time_estimator_add_frame_time(uint64_t a1, double a2)
{
  uint64_t v3;
  uint64_t result;

  v3 = *(_QWORD *)(a1 + 16);
  result = ar_rt_ring_buffer_add_element((int *)a1);
  *(double *)(v3 + 8 * (int)result) = a2;
  return result;
}

BOOL ar_rt_frame_time_estimator_estimate_frame_time(uint64_t a1, double *a2)
{
  _BOOL8 v4;
  int v5;
  double v6;
  int v7;
  unint64_t v8;
  double v9;
  int v10;

  v4 = ar_rt_ring_buffer_filled((_DWORD *)a1);
  if (v4)
  {
    v5 = ar_rt_ring_buffer_increment_index((_DWORD *)a1, *(_DWORD *)(a1 + 4));
    if (v5 == *(_DWORD *)(a1 + 4))
    {
      v6 = NAN;
    }
    else
    {
      v7 = v5;
      v8 = 0;
      v9 = 0.0;
      do
      {
        v10 = ar_rt_ring_buffer_increment_index((_DWORD *)a1, v7);
        v9 = v9 + *(double *)(*(_QWORD *)(a1 + 16) + 8 * v10) - *(double *)(*(_QWORD *)(a1 + 16) + 8 * v7);
        ++v8;
        v7 = v10;
      }
      while (v10 != *(_DWORD *)(a1 + 4));
      v6 = v9 / (double)v8;
    }
    *a2 = v6;
  }
  return v4;
}

id _ARLogTechnique_1()
{
  if (_ARLogTechnique_onceToken_1 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_1, &__block_literal_global_23);
  return (id)_ARLogTechnique_logObj_1;
}

id reportingQueue()
{
  if (reportingQueue_onceToken != -1)
    dispatch_once(&reportingQueue_onceToken, &__block_literal_global_492);
  return (id)reportingQueue_s_reportingQueue;
}

id hitTestReportingMap()
{
  if (hitTestReportingMap_onceToken != -1)
    dispatch_once(&hitTestReportingMap_onceToken, &__block_literal_global_493);
  return (id)hitTestReportingMap_s_hitTestReporting;
}

id bundleID()
{
  if (bundleID_onceToken != -1)
    dispatch_once(&bundleID_onceToken, &__block_literal_global_495);
  return (id)bundleID_bundleID;
}

id _ARLogSession()
{
  if (_ARLogSession_onceToken != -1)
    dispatch_once(&_ARLogSession_onceToken, &__block_literal_global_497);
  return (id)_ARLogSession_logObj;
}

void __reportingQueue_block_invoke()
{
  dispatch_queue_t v0;
  void *v1;
  NSObject *v2;

  dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
  v2 = objc_claimAutoreleasedReturnValue();
  v0 = dispatch_queue_create(0, v2);
  v1 = (void *)reportingQueue_s_reportingQueue;
  reportingQueue_s_reportingQueue = (uint64_t)v0;

}

void __hitTestReportingMap_block_invoke()
{
  uint64_t v0;
  void *v1;

  v0 = objc_opt_new();
  v1 = (void *)hitTestReportingMap_s_hitTestReporting;
  hitTestReportingMap_s_hitTestReporting = v0;

}

void __bundleID_block_invoke()
{
  void *v0;
  uint64_t v1;
  void *v2;
  uint64_t v3;
  void *v4;
  id v5;

  objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle");
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "bundleIdentifier");
  v1 = objc_claimAutoreleasedReturnValue();
  v2 = (void *)bundleID_bundleID;
  bundleID_bundleID = v1;

  if (!bundleID_bundleID)
  {
    objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
    v5 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "processName");
    v3 = objc_claimAutoreleasedReturnValue();
    v4 = (void *)bundleID_bundleID;
    bundleID_bundleID = v3;

  }
}

id _ARLogGeneral_6()
{
  if (_ARLogGeneral_onceToken_7 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_7, &__block_literal_global_26);
  return (id)_ARLogGeneral_logObj_7;
}

void sub_1B3AAD3D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARLLAToECEF@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result;
  __int128 v3;
  __int128 v4;

  result = cnnavigation::LLAToECEF();
  v3 = 0uLL;
  v4 = 0uLL;
  if (!(_DWORD)result)
  {
    *(_QWORD *)&v4 = 0;
    v3 = 0uLL;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

int8x16_t ARECEFToLLA@<Q0>(int8x16_t *a1@<X8>)
{
  __int32 v2;
  int32x4_t v3;
  int32x4_t v4;
  int8x16_t v5;
  float64x2_t v6;
  int8x16_t v7;
  int8x16_t result;

  v2 = cnnavigation::ECEFToLLA();
  v3.i32[0] = 0;
  v4.i32[0] = v2;
  v5 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_s32(v4, v3), 0);
  v6 = (float64x2_t)vdupq_n_s64(0x404CA5DC1A63C1F8uLL);
  v7 = vandq_s8((int8x16_t)vmulq_f64((float64x2_t)0, v6), v5);
  v6.f64[0] = 0.0;
  result = vbslq_s8(v5, (int8x16_t)v6, (int8x16_t)0);
  *a1 = v7;
  a1[1] = result;
  return result;
}

uint64_t ARECEFToENU@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  result = cnnavigation::ECEFToENU();
  v3 = 0uLL;
  v4 = 0uLL;
  if (!(_DWORD)result)
  {
    v3 = v5;
    *(_QWORD *)&v4 = v6;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

uint64_t ARENUToECEF@<X0>(_OWORD *a1@<X8>)
{
  uint64_t result;
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  result = cnnavigation::ENUToECEF();
  v3 = 0uLL;
  v4 = 0uLL;
  if (!(_DWORD)result)
  {
    v3 = v5;
    *(_QWORD *)&v4 = v6;
  }
  *a1 = v3;
  a1[1] = v4;
  return result;
}

void ARENUToECEFTransform(uint64_t a1@<X0>, _OWORD *a2@<X8>)
{
  float64x2_t v3;
  _OWORD *v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  void *v9;
  int v10;
  __int128 v11;
  uint64_t i;
  unsigned int j;
  __int128 v14;
  __int128 v15;
  float64x2_t v16;
  uint64_t v17;
  _BYTE v18[24];
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  float64x2_t v22;
  void *v23;
  __int128 v24;
  uint64_t v25;
  _BYTE *v26;
  _BYTE v27[120];
  void *v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;

  v31 = *MEMORY[0x1E0C80C00];
  v3 = *(float64x2_t *)a1;
  v4 = (_OWORD *)MEMORY[0x1E0C83FD8];
  v5 = *(_OWORD *)(MEMORY[0x1E0C83FD8] + 80);
  a2[4] = *(_OWORD *)(MEMORY[0x1E0C83FD8] + 64);
  a2[5] = v5;
  v6 = v4[7];
  a2[6] = v4[6];
  a2[7] = v6;
  v7 = v4[1];
  *a2 = *v4;
  a2[1] = v7;
  v8 = v4[3];
  a2[2] = v4[2];
  a2[3] = v8;
  v9 = *(void **)(a1 + 16);
  v16 = vmulq_f64(v3, (float64x2_t)vdupq_n_s64(0x3F91DF46A2529D39uLL));
  v22 = v16;
  v23 = v9;
  memset(v18, 0, sizeof(v18));
  v10 = cnnavigation::LLAToECEF();
  v11 = 0uLL;
  v17 = 0;
  if (!v10)
  {
    v11 = *(_OWORD *)v18;
    v17 = *(_QWORD *)&v18[16];
  }
  v15 = v11;
  v29 = xmmword_1B3BE0310;
  v30 = 0x3FF0000000000000;
  *(float64x2_t *)&v27[104] = v16;
  v28 = v9;
  LOBYTE(v22.f64[1]) = 0;
  v25 = 0x300000003;
  v23 = &unk_1E6670498;
  v24 = xmmword_1B3BE0300;
  v26 = v27;
  *(_QWORD *)&v22.f64[0] = MEMORY[0x1E0D17570] + 16;
  if (!cnnavigation::ENUToECEF())
  {
    v19 = 0x300000003;
    *(_QWORD *)v18 = &unk_1E6670498;
    *(_OWORD *)&v18[8] = xmmword_1B3BE0300;
    v20 = &v21;
    for (i = 0; i != 3; ++i)
    {
      for (j = 0; j != 3; ++j)
        *((_QWORD *)&a2[2 * i] + j) = *(_QWORD *)cnmatrix::CNMatrixBase<double>::operator()((uint64_t)v18, j, i);
    }
  }
  *(_QWORD *)&v14 = v17;
  *((_QWORD *)&v14 + 1) = 1.0;
  a2[6] = v15;
  a2[7] = v14;
  cnnavigation::ENUToECEFJacobian::~ENUToECEFJacobian((cnnavigation::ENUToECEFJacobian *)&v22);
}

void sub_1B3AAD93C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29)
{
  cnnavigation::ENUToECEFJacobian::~ENUToECEFJacobian((cnnavigation::ENUToECEFJacobian *)&a29);
  _Unwind_Resume(a1);
}

_QWORD *cnmatrix::CNMatrix<3u,3u,double>::~CNMatrix(_QWORD *result)
{
  *result = &unk_1E6670468;
  return result;
}

void ARAnchorToECEFTransform(_OWORD *a1@<X0>, _OWORD *a2@<X8>)
{
  __int128 v2;
  _OWORD v3[2];

  v2 = a1[1];
  v3[0] = *a1;
  v3[1] = v2;
  ARENUToECEFTransform((uint64_t)v3, a2);
}

uint64_t find_index(const __int16 *a1, __int16 a2, __int16 a3, unint64_t a4, unint64_t a5, unint64_t *a6)
{
  unint64_t v6;
  int v7;
  int v8;

  while (1)
  {
    v6 = (a5 + a4) >> 1;
    v7 = (unsigned __int16)a1[3 * v6];
    if (v7 == (unsigned __int16)a2)
      break;
    if ((__int16)v7 <= a2)
      goto LABEL_6;
LABEL_7:
    a5 = v6;
    if (v6 <= a4)
      return 0;
  }
  v8 = (unsigned __int16)a1[3 * ((a5 + a4) >> 1) + 1];
  if (v8 != (unsigned __int16)a3)
  {
    if ((__int16)v8 > a3)
      goto LABEL_7;
LABEL_6:
    a4 = v6 + 1;
    v6 = a5;
    goto LABEL_7;
  }
  *a6 = v6;
  return 1;
}

double ARGetFallbackUndulationValue(double a1, double a2)
{
  unint64_t v2;
  int v3;
  int v4;
  uint64_t v5;
  unint64_t v6;
  int v7;
  char *v8;
  int v9;

  v2 = 0;
  v3 = (unsigned __int16)(int)((a1 + 90.0) * 10.0);
  v4 = (unsigned __int16)(int)((a2 + 180.0) * 10.0);
  v5 = 2173;
  while (1)
  {
    v6 = (v5 + v2) >> 1;
    v7 = undulation_constants[3 * v6];
    if (v7 == v3)
      break;
    if ((__int16)v7 <= (__int16)v3)
      goto LABEL_7;
LABEL_8:
    v5 = v6;
    if (v6 <= v2)
      return NAN;
  }
  v8 = (char *)&undulation_constants[3 * ((v5 + v2) >> 1)];
  v9 = *((unsigned __int16 *)v8 + 1);
  if (v9 != v4)
  {
    if ((__int16)v9 > (__int16)v4)
      goto LABEL_8;
LABEL_7:
    v2 = v6 + 1;
    v6 = v5;
    goto LABEL_8;
  }
  return (double)*((__int16 *)v8 + 2) * 0.01;
}

double ARMSLToWGS84Altitude(double a1, double a2)
{
  return a1 + a2;
}

double ARWGS84ToMSLAltitude(double a1, double a2)
{
  return a1 - a2;
}

double ARLInfinityDistance(double a1, double a2, double a3, double a4)
{
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;

  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C9E3B8]), "initWithLatitude:longitude:", a1, a2);
  v9 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C9E3B8]), "initWithLatitude:longitude:", a3, a4);
  v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C9E3B8]), "initWithLatitude:longitude:", a1, a4);
  v11 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C9E3B8]), "initWithLatitude:longitude:", a3, a2);
  objc_msgSend(v8, "distanceFromLocation:", v10);
  v13 = v12;
  objc_msgSend(v9, "distanceFromLocation:", v10);
  v15 = v14;
  objc_msgSend(v8, "distanceFromLocation:", v11);
  v17 = v16;
  objc_msgSend(v9, "distanceFromLocation:", v11);
  if (v13 >= v15)
    v19 = v13;
  else
    v19 = v15;
  if (v17 >= v18)
    v18 = v17;
  if (v19 >= v18)
    v20 = v19;
  else
    v20 = v18;

  return v20;
}

void sub_1B3AADBFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

double ARLInfinityAngularDistance(double a1, double a2, double a3, double a4)
{
  double v4;
  double result;

  v4 = vabdd_f64(a4, a2);
  if (v4 > 180.0)
    v4 = 360.0 - v4;
  result = vabdd_f64(a3, a1);
  if (v4 >= result)
    return v4;
  return result;
}

__n128 cnmatrix::CNMatrixBase<double>::operator=(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  int v5;
  unint64_t *v6;
  unint64_t *v7;
  unint64_t v8;
  __n128 result;
  _OWORD *v10;
  __int128 *v11;
  __n128 *v12;
  __n128 *v13;
  uint64_t v14;
  __int128 v15;

  if (a1 != a2)
  {
    v2 = *(_DWORD *)(a2 + 8);
    if (*(_DWORD *)(a1 + 24) < v2)
      cnmatrix::CNMatrixBase<double>::operator=();
    v3 = *(_DWORD *)(a2 + 12);
    if (*(_DWORD *)(a1 + 28) < v3)
      cnmatrix::CNMatrixBase<double>::operator=();
    *(_DWORD *)(a1 + 8) = v2;
    *(_DWORD *)(a1 + 12) = v3;
    v4 = v3 * v2;
    *(_DWORD *)(a1 + 16) = v4;
    *(_DWORD *)(a1 + 20) = v2;
    v5 = *(_DWORD *)(a2 + 16);
    if (v5 > 3)
    {
      v10 = *(_OWORD **)(a1 + 32);
      v11 = *(__int128 **)(a2 + 32);
      v12 = (__n128 *)((char *)v10 + 8 * (v5 - 2));
      v13 = (__n128 *)((char *)v11 + 8 * (v5 - 2));
      v14 = (v5 - 1) >> 1;
      do
      {
        v15 = *v11++;
        *v10++ = v15;
        --v14;
      }
      while (v14);
      result = *v13;
      *v12 = *v13;
    }
    else if ((int)v4 >= 1)
    {
      v6 = *(unint64_t **)(a2 + 32);
      v7 = *(unint64_t **)(a1 + 32);
      do
      {
        v8 = *v6++;
        result.n128_u64[0] = v8;
        *v7++ = v8;
        --v4;
      }
      while (v4);
    }
  }
  return result;
}

void cnmatrix::CNMatrix<3u,3u,double>::~CNMatrix(_QWORD *a1)
{
  *a1 = &unk_1E6670468;
  JUMPOUT(0x1B5E2D5B8);
}

uint64_t cnmatrix::CNMatrix<3u,3u,double>::AllocateAndBindMemoryBacking(uint64_t result)
{
  *(_QWORD *)(result + 32) = result + 40;
  return result;
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(uint64_t a1)
{
  char v1[9];
  uint64_t v2;

  v2 = *MEMORY[0x1E0C80C00];
  cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(a1, v1);
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint(uint64_t a1, char *a2)
{
  unsigned int v2;
  unsigned int v4;
  int v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;

  v2 = *(_DWORD *)(a1 + 8);
  if (v2 >= 2)
  {
    v4 = *(_DWORD *)(a1 + 12);
    if (v4 >= 2)
    {
      if (!a2)
        cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint();
      v6 = v4 + v2 - *(_DWORD *)(a1 + 20);
      if (v6 <= 0)
        cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint();
      bzero(a2, *(unsigned int *)(a1 + 16));
      v7 = *(_DWORD *)(a1 + 16);
      if (v7 >= 3)
      {
        v8 = (v7 - 1);
        v9 = *(_QWORD *)(a1 + 32);
        v10 = 1;
        do
        {
          v11 = &a2[v10];
          if (!a2[v10])
          {
            v12 = *(_QWORD *)(v9 + 8 * v10);
            v13 = v10;
            do
            {
              v13 = v13 * v6 % (int)v8;
              v14 = *(_QWORD *)(v9 + 8 * v13);
              *(_QWORD *)(v9 + 8 * v13) = v12;
              *v11 = 1;
              v11 = &a2[v13];
              v12 = v14;
            }
            while (!*v11);
          }
          ++v10;
        }
        while (v10 != v8);
      }
    }
  }
}

uint64_t cnmatrix::CNMatrixBase<double>::operator()(uint64_t a1, int a2, int a3)
{
  uint64_t v3;
  unsigned int v4;

  v3 = *(_QWORD *)(a1 + 32);
  if (!v3)
    cnmatrix::CNMatrixBase<double>::operator()();
  v4 = a2 + *(_DWORD *)(a1 + 20) * a3;
  if ((v4 & 0x80000000) != 0)
    cnmatrix::CNMatrixBase<double>::operator()();
  if ((signed int)v4 >= *(_DWORD *)(a1 + 16))
    cnmatrix::CNMatrixBase<double>::operator()();
  return v3 + 8 * v4;
}

id _ARLogSensor_1()
{
  if (_ARLogSensor_onceToken_3 != -1)
    dispatch_once(&_ARLogSensor_onceToken_3, &__block_literal_global_216);
  return (id)_ARLogSensor_logObj_3;
}

void sub_1B3AAE8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  os_unfair_lock_s *v7;
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  os_unfair_lock_unlock(v7);
  _Unwind_Resume(a1);
}

void sub_1B3AAF8DC(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

void sub_1B3AB0450(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3AB0684(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3AB0AB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void *ARC3DShapeTriangulationListCreate@<X0>(_QWORD *a1@<X8>)
{
  void *result;

  a1[1] = 0;
  a1[2] = 0;
  *a1 = 0x400000000;
  a1[1] = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  result = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
  a1[2] = result;
  return result;
}

void ARC3DShapeTriangulationListDestroy(uint64_t a1)
{
  free(*(void **)(a1 + 8));
  free(*(void **)(a1 + 16));
}

void **ARC3DShapeTriangulationListInsert(void **result, uint64_t a2, uint64_t a3)
{
  void **v5;
  unsigned int v6;
  unsigned int v7;

  v5 = result;
  v6 = *(_DWORD *)result;
  if (*(_DWORD *)result == *((_DWORD *)result + 1))
  {
    v7 = 2 * v6;
    *((_DWORD *)result + 1) = v7;
    result[1] = malloc_type_realloc(result[1], 8 * v7, 0x2004093837F09uLL);
    result = (void **)malloc_type_realloc(v5[2], 8 * *((unsigned int *)v5 + 1), 0x2004093837F09uLL);
    v5[2] = result;
    v6 = *(_DWORD *)v5;
  }
  *((_QWORD *)v5[1] + v6) = a2;
  *((_QWORD *)v5[2] + v6) = a3;
  *(_DWORD *)v5 = v6 + 1;
  return result;
}

uint64_t ARC3DShapeTriangulationStackCreate()
{
  malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  return 0x1000000000;
}

void ARC3DShapeTriangulationStackDestroy(int a1, void *a2)
{
  free(a2);
}

_QWORD *ARC3DShapeTriangulationStackPush(int *a1, uint64_t a2)
{
  int v4;
  int v5;
  _QWORD *result;

  v4 = *a1;
  v5 = a1[1];
  if (v5 == *a1)
  {
    a1[1] = 2 * v5;
    result = malloc_type_realloc(*((void **)a1 + 1), 8 * (2 * v5), 0x2004093837F09uLL);
    *((_QWORD *)a1 + 1) = result;
    v4 = *a1;
  }
  else
  {
    result = (_QWORD *)*((_QWORD *)a1 + 1);
  }
  *a1 = v4 + 1;
  result[v4] = a2;
  return result;
}

uint64_t ARC3DShapeTriangulationStackPop(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;

  v1 = *(_QWORD *)(a1 + 8);
  v2 = *(_DWORD *)a1 - 1;
  *(_DWORD *)a1 = v2;
  return *(_QWORD *)(v1 + 8 * v2);
}

_QWORD *ARC3DNeighborSharingVertex(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;

  if (*result == a2)
  {
    v2 = result + 3;
    return (_QWORD *)*v2;
  }
  if (result[1] == a2)
  {
    v2 = result + 4;
    return (_QWORD *)*v2;
  }
  if (result[2] == a2)
  {
    v2 = result + 5;
    return (_QWORD *)*v2;
  }
  return result;
}

uint64_t ARC3DNeighborSharingVertices(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  BOOL v5;
  _QWORD *v6;

  if (*a1 == a2 || *a1 == a3)
  {
    v4 = a1[1];
    v5 = v4 == a2 || v4 == a3;
    v6 = a1 + 3;
    if (!v5)
      v6 = a1 + 5;
  }
  else
  {
    v6 = a1 + 4;
  }
  return *v6;
}

uint64_t ARC3DShapeTriangulationTriangleCrossesSegment(double **a1, double a2, double a3, double a4, double a5)
{
  int v10;
  int v11;

  v10 = ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, **a1, (*a1)[1], *a1[1], a1[1][1]);
  v11 = ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, *a1[1], a1[1][1], *a1[2], a1[2][1]);
  return v10 | v11 | ARC3DSegmentIntersectsSegment(a2, a3, a4, a5, *a1[2], a1[2][1], **a1, (*a1)[1]);
}

uint64_t ARC3DShapeTriangulationCheckConsistency(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;

  v1 = *(unsigned int *)(result + 32);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(result + 16);
    do
    {
      v4 = 0;
      v5 = v3 + 56 * v2;
      do
      {
        v6 = v4 + 1;
        if (v4 == 2)
          v7 = 0;
        else
          v7 = (v4 + 1);
        v8 = *(_QWORD *)(v3 + 56 * v2 + 8 * v4 + 24);
        if (v8 == v5)
          ARC3DShapeTriangulationCheckConsistency_cold_1();
        if (v8 == 1)
          ARC3DShapeTriangulationCheckConsistency_cold_2();
        v9 = 0;
        result = 0;
        v10 = 0;
        v11 = *(_QWORD *)(v5 + 8 * v7);
        v12 = v3;
        v13 = 0xFFFFFFFFLL;
        do
        {
          for (i = 0; i != 3; ++i)
          {
            if (i == 2)
              v15 = 0;
            else
              v15 = i + 1;
            if (*(_QWORD *)(v5 + 8 * v4) == *(_QWORD *)(v3 + 56 * v9 + 8 * v15) && v11 == *(_QWORD *)(v12 + 8 * i))
            {
              v13 = i;
              ++v10;
              result = v3 + 56 * v9;
            }
          }
          ++v9;
          v12 += 56;
        }
        while (v9 != v1);
        if (result != v8)
          ARC3DShapeTriangulationCheckConsistency_cold_8();
        if (v8)
        {
          if (v10 != 1)
            ARC3DShapeTriangulationCheckConsistency_cold_7();
          if (*(_QWORD *)(v8 + 8 * v13 + 24) != v5)
            ARC3DShapeTriangulationCheckConsistency_cold_6();
          if (*(unsigned __int8 *)(v8 + v13 + 48) != *(unsigned __int8 *)(v3 + 56 * v2 + v4 + 48))
            ARC3DShapeTriangulationCheckConsistency_cold_5();
        }
        else
        {
          if (v10)
            ARC3DShapeTriangulationCheckConsistency_cold_4();
          if (*(_BYTE *)(v3 + 56 * v2 + v4 + 48))
            ARC3DShapeTriangulationCheckConsistency_cold_3();
        }
        ++v4;
      }
      while (v6 != 3);
      ++v2;
    }
    while (v2 != v1);
  }
  return result;
}

double ARC3DShapeTriangulationTriangleArea(double a1, double a2, double a3, double a4, double a5, double a6)
{
  return fabs(a3 * a6 + a1 * a4 + a5 * a2 - a1 * a6 - a5 * a4 - a3 * a2) * 0.5;
}

uint64_t ARC3DShapeTriangulationGetNewTriangle(uint64_t a1)
{
  uint64_t v1;
  unsigned int v2;
  uint64_t result;

  v1 = *(_QWORD *)(a1 + 16);
  v2 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v2 + 1;
  result = v1 + 56 * v2;
  *(_BYTE *)(result + 51) = 0;
  return result;
}

uint64_t ARC3DShapeTriangulationTriangleContainingVertex(uint64_t a1, uint64_t a2)
{
  int v2;
  unsigned int v3;
  uint64_t v4;
  _QWORD *i;
  uint64_t v6;

  v2 = *(_DWORD *)(a2 + 32);
  v3 = v2 - 1;
  if (v2 - 1 < 0)
    return 2;
  v4 = *(_QWORD *)(a2 + 16);
  for (i = (_QWORD *)(v4 + 56 * v3); ; i -= 7)
  {
    if (v4)
    {
      v6 = v4 + 56 * v3;
      if (*i == a1 || i[1] == a1)
        return v6;
      if (i[2] == a1)
        break;
    }
    --v3;
    if (--v2 <= 0)
      return 2;
  }
  return (uint64_t)i;
}

uint64_t ARC3DShapeTriangulationTriangleContainingPoint(float64x2_t *a1, unint64_t a2, uint64_t a3)
{
  uint64_t v3;
  int v4;
  uint64_t v5;
  char v6;
  float64x2_t v7;
  uint64_t v8;
  int8x16_t v9;
  float64x2_t v10;
  double **v11;
  double v12;
  double v13;
  float64_t v14;
  double *v15;
  double *v16;
  double v17;
  double v18;
  double v19;
  double v20;

  v3 = *(unsigned int *)(a3 + 32);
  v4 = *(_DWORD *)(a3 + 32);
  while (v4)
  {
    v5 = 0;
    v6 = 0;
    --v4;
    v7 = *a1;
    do
    {
      if (v5 == 2)
        v8 = 0;
      else
        v8 = v5 + 1;
      v9 = (int8x16_t)vsubq_f64(*(float64x2_t *)*(_QWORD *)(a2 + 8 * v5), v7);
      v10 = vmulq_f64(vsubq_f64(*(float64x2_t *)*(_QWORD *)(a2 + 8 * v8), v7), (float64x2_t)vextq_s8(v9, v9, 8uLL));
      if ((vmovn_s64(vcgtq_f64(v10, (float64x2_t)vdupq_laneq_s64((int64x2_t)v10, 1))).u8[0] & 1) != 0)
      {
        a2 = *(_QWORD *)(a2 + 8 * v5 + 24);
        if (a2 < 3)
          return 2;
        v6 = 1;
      }
      ++v5;
    }
    while (v5 != 3);
    if ((v6 & 1) == 0)
      return a2;
  }
  if (!(_DWORD)v3)
    return 2;
  v11 = *(double ***)(a3 + 16);
  a2 = 2;
  while (1)
  {
    v15 = v11[1];
    v16 = v11[2];
    v17 = **v11;
    v18 = (*v11)[1];
    v19 = v15[1];
    v20 = v16[1];
    v12 = a1->f64[0];
    v13 = a1->f64[1];
    v14 = -a1->f64[0];
    if (vabdd_f64(fabs(*v15 * v20 + v17 * v19 + *v16 * v18 - v17 * v20 - *v16 * v19 - *v15 * v18) * 0.5- fabs(v18 * *v16 + v12 * v20 + v17 * v13 + v14 * v18 - v17 * v20 - *v16 * v13) * 0.5- fabs(*v15 * v20 + v12 * v19 + *v16 * v13 + v14 * v20 - *v16 * v19 - *v15 * v13) * 0.5, fabs(v17 * v19 + v12 * v18 + *v15 * v13 + v14 * v19 - *v15 * v18 - v17 * v13) * 0.5) < 0.001)break;
    v11 += 7;
    if (!--v3)
      return a2;
  }
  return (uint64_t)v11;
}

uint64_t ARC3DEdgeCrossingSegment(uint64_t a1, double *a2, double *a3, double ***a4)
{
  double *v8;
  double *v9;
  BOOL v10;
  double ***v11;
  double **v12;
  double *v13;
  double *v14;
  double *v15;
  uint64_t result;

  v8 = *(double **)a1;
  if (*(double **)a1 == a3 || (v9 = *(double **)(a1 + 8), v9 == a3) || *(double **)(a1 + 16) == a3)
  {
    v12 = *(double ***)(a1 + 24);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3))
      goto LABEL_41;
    v12 = *(double ***)(a1 + 32);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3))
      goto LABEL_41;
    v12 = *(double ***)(a1 + 40);
    if (v12 && (*v12 == a2 || v12[1] == a2 || v12[2] == a2) && (*v12 == a3 || v12[1] == a3 || v12[2] == a3))
      goto LABEL_41;
  }
  else
  {
    v10 = v8 == a2 || v9 == a2;
    if (!v10 && ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v8, v8[1], *v9, v9[1]))
    {
      v11 = (double ***)(a1 + 24);
LABEL_40:
      v12 = *v11;
LABEL_41:
      *a4 = v12;
      return 1;
    }
    v13 = *(double **)(a1 + 8);
    if (v13 != a2)
    {
      v14 = *(double **)(a1 + 16);
      if (v14 != a2)
      {
        if (ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v13, v13[1], *v14, v14[1]))
        {
          v11 = (double ***)(a1 + 32);
          goto LABEL_40;
        }
      }
    }
    v15 = *(double **)(a1 + 16);
    if (v15 != a2 && *(double **)a1 != a2)
    {
      result = ARC3DSegmentIntersectsSegment(*a2, a2[1], *a3, a3[1], *v15, v15[1], **(double **)a1, *(double *)(*(_QWORD *)a1 + 8));
      if (!(_DWORD)result)
        return result;
      v11 = (double ***)(a1 + 40);
      goto LABEL_40;
    }
  }
  return 0;
}

uint64_t ARC3DLinkFromTriangleToTriangle(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t result;

  v3 = 0;
  v4 = a1 + 24;
  result = 3;
  while (*(_QWORD *)(v4 + v3) != a2)
  {
    v3 += 8;
    if (v3 == 24)
      return result;
  }
  return a1 + v3 + 24;
}

uint64_t ARC3DLinkIndexFromTriangleToTriangle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t result;
  uint64_t v5;

  result = 0;
  v5 = a1 + 24;
  while (*(_QWORD *)(v5 + 8 * result) != a2)
  {
    if (++result == 3)
      ARC3DLinkIndexFromTriangleToTriangle_cold_1(3, a2, a3);
  }
  return result;
}

uint64_t ARC3DLinkIndicesFromTriangleToTriangle(uint64_t result, uint64_t a2, _DWORD *a3, _DWORD *a4, int *a5)
{
  uint64_t v5;
  int v6;
  int v7;

  v5 = 0;
  while (*(_QWORD *)(result + 24 + 8 * v5) != a2)
  {
    if ((_DWORD)++v5 == 3)
    {
      *a5 = -1;
      *a4 = -1;
      *a3 = -1;
      return result;
    }
  }
  *a3 = v5;
  if (v5 > 1)
    v6 = -2;
  else
    v6 = 1;
  *a4 = v6 + v5;
  if ((_DWORD)v5)
    v7 = v5 - 1;
  else
    v7 = 2;
  *a5 = v7;
  return result;
}

uint64_t ARC3DLinkFromTriangleWithEdge(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v5;
  unsigned int v7;

  if (!a1)
    return 0xFFFFFFFFLL;
  v3 = a1[1];
  if (*a1 == a2 && v3 == a3)
    return 0;
  v5 = a1[2];
  if (v5 == a2 && *a1 == a3)
    v7 = 2;
  else
    v7 = -1;
  if (v3 == a2 && v5 == a3)
    return 1;
  else
    return v7;
}

BOOL ARC3DCircumcircleContainsPoint_BROKEN(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v8 = a1 - a5;
  v9 = a2 - a6;
  v10 = a3 - a5;
  v11 = a4 - a6;
  v12 = a1 - a7;
  v13 = a2 - a8;
  v14 = a3 - a7;
  v15 = a4 - a8;
  v16 = v9 * v11 + v8 * v10;
  v17 = v15 * v13 + v14 * v12;
  if (v16 >= 0.0 && v17 >= 0.0)
    return 0;
  if (v16 >= 0.0 || v17 >= 0.0)
    return v16 * (v14 * v13 - v12 * v15) + (v8 * v11 - v10 * v9) * v17 < 0.0;
  return 1;
}

BOOL ARC3DCircumcircleContainsPoint(double *a1, double *a2, double *a3, double *a4)
{
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;

  v4 = a1[1];
  v5 = a2[1];
  v6 = a3[1];
  v7 = v4 * v4 + *a1 * *a1;
  v8 = v5 * v5 + *a2 * *a2;
  v9 = v6 * v6 + *a3 * *a3;
  v10 = v5 - v6;
  v11 = *a2 * (v6 - v4) + *a1 * (v5 - v6);
  v12 = v4 - v5;
  v13 = v11 + *a3 * v12 + v11 + *a3 * v12;
  v14 = (v8 * (v6 - v4) + v7 * v10 + v9 * v12) / v13;
  v15 = *a2 - *a3;
  v16 = *a1 - *a2;
  v17 = -(v8 * (*a3 - *a1) + v7 * v15 + v9 * v16) / v13;
  v18 = sqrt(((v4 - v6) * (v4 - v6) + (*a1 - *a3) * (*a1 - *a3)) * ((v12 * v12 + v16 * v16) * (v10 * v10 + v15 * v15)));
  v19 = fabs(v13);
  return (v17 - a4[1]) * (v17 - a4[1]) + (v14 - *a4) * (v14 - *a4) < v18 / v19 * (v18 / v19);
}

BOOL ARC3DPointFallsOnTriangleEdge(_QWORD *a1, double *a2)
{
  double *v3;
  double v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  long double v12;
  double *v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  long double v20;
  double v22;
  double v23;
  double v24;
  double v25;
  long double v26;

  v3 = (double *)a1[1];
  v4 = *a2;
  v5 = a2[1];
  v6 = *v3;
  v7 = v3[1];
  v8 = *(double *)*a1 - *a2;
  v9 = *(double *)(*a1 + 8) - v5;
  v10 = v9 * v9 + v8 * v8;
  if (v10 <= 0.0)
  {
    v11 = -v10;
    v12 = hypot(v8, v9);
    if (v12 * v12 == v11)
      return 1;
  }
  v13 = (double *)a1[2];
  v14 = *v13;
  v15 = v13[1];
  v16 = v6 - v4;
  v17 = v7 - v5;
  v18 = v17 * v17 + v16 * v16;
  if (v18 <= 0.0)
  {
    v19 = -v18;
    v20 = hypot(v16, v17);
    if (v20 * v20 == v19)
      return 1;
  }
  v22 = v14 - v4;
  v23 = v15 - v5;
  v24 = v23 * v23 + v22 * v22;
  if (v24 > 0.0)
    return 0;
  v25 = -v24;
  v26 = hypot(v22, v23);
  return v26 * v26 == v25;
}

uint64_t ARC3DPointFallsOnTriangleEdgeAndLinks(uint64_t a1, double *a2, _DWORD *a3, _DWORD *a4)
{
  double *v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  uint64_t v10;
  double *v11;
  double v12;

  v4 = *(double **)(a1 + 8);
  v5 = **(double **)a1;
  v6 = *(double *)(*(_QWORD *)a1 + 8);
  v7 = v4[1];
  v8 = *a2;
  v9 = a2[1];
  if ((*v4 - v5) * (v9 - v6) - (v7 - v6) * (*a2 - v5) == 0.0)
  {
    v10 = 0;
    *a3 = 0;
    while (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 24 + 8 * v10) != a1)
    {
      if (++v10 == 3)
        ARC3DLinkIndexFromTriangleToTriangle_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
    }
  }
  else
  {
    v11 = *(double **)(a1 + 16);
    v12 = v11[1];
    if ((*v11 - *v4) * (v9 - v7) - (v12 - v7) * (v8 - *v4) == 0.0)
    {
      v10 = 0;
      *a3 = 1;
      while (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 24 + 8 * v10) != a1)
      {
        if (++v10 == 3)
          ARC3DLinkIndexFromTriangleToTriangle_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
      }
    }
    else
    {
      if ((v5 - *v11) * (v9 - v12) - (v6 - v12) * (v8 - *v11) != 0.0)
        return 0;
      v10 = 0;
      *a3 = 2;
      while (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 24 + 8 * v10) != a1)
      {
        if (++v10 == 3)
          ARC3DLinkIndexFromTriangleToTriangle_cold_1(a1, (uint64_t)a2, (uint64_t)a3);
      }
    }
  }
  *a4 = v10;
  return 1;
}

uint64_t ARC3DVertexNotSharedByTriangles(uint64_t a1, uint64_t a2)
{
  _QWORD *v2;
  int v3;
  unsigned int v5;

  if (!a1)
    ARC3DVertexNotSharedByTriangles_cold_1();
  if (!a2)
    ARC3DVertexNotSharedByTriangles_cold_2();
  v2 = (_QWORD *)(a1 + 24);
  v3 = 1;
  while (*v2 != a2)
  {
    --v3;
    ++v2;
    if (v3 == -2)
      return 0;
  }
  if (v3 == 1)
    v5 = 2;
  else
    v5 = -v3;
  return *(_QWORD *)(a1 + 8 * v5);
}

uint64_t ARC3DShapeConnectedComponentTriangulatePseudopolygon(int *a1, double *a2, double *a3, unsigned int *a4, int a5)
{
  unsigned int v5;
  uint64_t v6;
  double **v10;
  double *v11;
  int v12;
  uint64_t v13;
  double *v14;
  double *v15;
  unint64_t **v16;
  unint64_t *v17;
  unint64_t v18;
  unsigned int v19;
  uint64_t v20;
  unint64_t v21;
  double *v22;
  unint64_t v23;
  double **v24;
  double *v25;
  double *v26;
  unsigned int v27;
  double *v28;
  unsigned int v29;
  double *v30;
  double *v31;
  double *v33;
  double *v35;
  BOOL v36;
  int v37;
  BOOL v38;
  unsigned int v39;
  uint64_t v40;
  double *v42;
  BOOL v43;
  double *v44;
  BOOL v45;
  int v46;
  BOOL v47;
  unsigned int v48;
  uint64_t v49;
  unint64_t v50;
  double **v51;
  uint64_t v52;
  double *v53;
  double *v54;
  unint64_t v55;
  double **v56;
  double *v57;
  double *v58;
  double *v60;
  int v62;
  unsigned int v64;
  double *v65;
  unsigned int v66;
  double *v67;
  double *v69;
  int v71;
  unsigned int v73;
  uint64_t v74;
  double *v75;
  double *v77;
  double *v79;
  BOOL v80;
  int v81;
  BOOL v82;
  unsigned int v83;
  char v84;
  char v85;
  uint64_t v87;
  unsigned int v88;
  uint64_t v89;
  double *v90;
  double *v92;
  int v94;
  unsigned int v96;
  uint64_t result;
  double *v98;
  double *v100;
  int v102;
  unsigned int v104;
  double *v105;
  double *v107;
  unsigned int v110;
  double *v111;
  double *v113;
  unsigned int v116;
  char v117;
  char v118;
  unsigned int v119;
  unsigned int *v120;
  int v121;

  v5 = *a1;
  v6 = (*a1 - 1);
  if (*a1 <= 1)
    ARC3DShapeConnectedComponentTriangulatePseudopolygon_cold_1();
  v10 = (double **)*((_QWORD *)a1 + 1);
  v11 = *v10;
  if (v6 <= 1)
  {
    v12 = 0;
    v16 = (unint64_t **)(a1 + 4);
    v17 = (unint64_t *)*((_QWORD *)a1 + 2);
    v18 = *v17;
    v19 = *a4;
  }
  else
  {
    v119 = *a1;
    v120 = a4;
    v121 = a5;
    v12 = 0;
    v13 = 1;
    v14 = *v10;
    do
    {
      v15 = v10[v13];
      if (ARC3DCircumcircleContainsPoint(a2, a3, v14, v15))
      {
        v12 = v13;
        v14 = v15;
      }
      ++v13;
    }
    while (v6 != v13);
    v16 = (unint64_t **)(a1 + 4);
    v17 = (unint64_t *)*((_QWORD *)a1 + 2);
    v18 = *v17;
    a4 = v120;
    v19 = *v120;
    if (v12 >= 1)
    {
      v20 = 1;
      a5 = v121;
      while (1)
      {
        v21 = *(_QWORD *)(*((_QWORD *)v120 + 1) + 8 * --v19);
        if (v121)
        {
          v22 = v10[v20];
          *(_QWORD *)v21 = v22;
          v23 = 1;
        }
        else
        {
          *(_QWORD *)v21 = v11;
          v22 = v11;
          v11 = *(double **)(*((_QWORD *)a1 + 1) + v20 * 8);
          v23 = v18;
          v18 = 1;
        }
        *(_QWORD *)(v21 + 8) = v11;
        *(_QWORD *)(v21 + 16) = a2;
        v24 = (double **)(*v16)[v20];
        *(_QWORD *)(v21 + 24) = v24;
        *(_QWORD *)(v21 + 32) = v18;
        *(_QWORD *)(v21 + 40) = v23;
        if (v121)
        {
          if (v18)
          {
            v25 = *(double **)v18;
            v26 = *(double **)(v18 + 8);
            if (*(double **)v18 == a2 && v26 == v11)
            {
              v27 = 0;
            }
            else
            {
              v30 = *(double **)(v18 + 16);
              if (v26 == a2 && v30 == v11)
              {
                v27 = 1;
              }
              else if (v30 == a2 && v25 == v11)
              {
                v27 = 2;
              }
              else
              {
                v27 = -1;
              }
            }
          }
          else
          {
            v27 = -1;
          }
          if (!v24)
            goto LABEL_204;
          v33 = v24[1];
          if (*v24 == v11 && v33 == v22)
          {
            v39 = 0;
          }
          else
          {
            v35 = v24[2];
            v36 = v35 == v11 && *v24 == v22;
            v37 = v36 ? 2 : -1;
            v38 = v33 == v11 && v35 == v22;
            v39 = v38 ? 1 : v37;
          }
          if (v27 == -1 || v39 == -1)
            goto LABEL_204;
          v24[v39 + 3] = (double *)v21;
          *(_QWORD *)(*(_QWORD *)(v21 + 32) + 8 * v27 + 24) = v21;
          v40 = *(_QWORD *)(v21 + 24);
          *(_BYTE *)(v21 + 49) = *(_BYTE *)(*(_QWORD *)(v21 + 32) + v27 + 48);
          *(_BYTE *)(v21 + 48) = *(_BYTE *)(v40 + v39 + 48);
          *(_BYTE *)(v21 + 50) = 0;
        }
        else
        {
          if (v23)
          {
            v28 = *(double **)(v23 + 8);
            if (*(double **)v23 == v22 && v28 == a2)
            {
              v29 = 0;
            }
            else
            {
              v31 = *(double **)(v23 + 16);
              if (v28 == v22 && v31 == a2)
              {
                v29 = 1;
              }
              else if (v31 == v22 && *(_QWORD *)v23 == (_QWORD)a2)
              {
                v29 = 2;
              }
              else
              {
                v29 = -1;
              }
            }
          }
          else
          {
            v29 = -1;
          }
          if (!v24
            || ((v42 = v24[1], *v24 == v11) ? (v43 = v42 == v22) : (v43 = 0),
                v43
              ? (v48 = 0)
              : ((v44 = v24[2], v44 == v11) ? (v45 = *v24 == v22) : (v45 = 0),
                 !v45 ? (v46 = -1) : (v46 = 2),
                 v42 == v11 ? (v47 = v44 == v22) : (v47 = 0),
                 !v47 ? (v48 = v46) : (v48 = 1)),
                v29 == -1 || v48 == -1))
          {
LABEL_204:
            *a4 = v19;
            return 2;
          }
          if (v23 >= 2)
          {
            *(_QWORD *)(v23 + 8 * v29 + 24) = v21;
            *(_BYTE *)(v21 + 50) = *(_BYTE *)(*(_QWORD *)(v21 + 40) + v29 + 48);
            v24 = *(double ***)(v21 + 24);
          }
          if ((unint64_t)v24 >= 2)
          {
            v24[v48 + 3] = (double *)v21;
            *(_BYTE *)(v21 + 48) = *(_BYTE *)(*(_QWORD *)(v21 + 24) + v48 + 48);
          }
          *(_BYTE *)(v21 + 49) = 0;
        }
        v10 = (double **)*((_QWORD *)a1 + 1);
        v11 = v10[v20++];
        v18 = v21;
        if (v12 + 1 == v20)
        {
          *v120 = v19;
          v17 = *v16;
          v11 = v14;
          v18 = v21;
          goto LABEL_91;
        }
      }
    }
    v11 = v14;
    a5 = v121;
LABEL_91:
    v5 = v119;
  }
  v49 = v17[v6];
  if ((int)(v5 - 3) >= v12)
  {
    v51 = &v10[v5 - 2];
    v52 = (int)(v5 - 3);
    while (1)
    {
      v53 = *v51;
      v50 = *(_QWORD *)(*((_QWORD *)a4 + 1) + 8 * --v19);
      *(_QWORD *)v50 = a3;
      if ((a5 & 1) != 0)
      {
        *(_QWORD *)(v50 + 8) = v53;
        v54 = v53;
        v53 = *(double **)(*((_QWORD *)a1 + 1) + 8 * v52);
        v55 = 1;
      }
      else
      {
        v54 = *(double **)(*((_QWORD *)a1 + 1) + 8 * v52);
        *(_QWORD *)(v50 + 8) = v54;
        v55 = v49;
        v49 = 1;
      }
      *(_QWORD *)(v50 + 16) = v53;
      *(_QWORD *)(v50 + 24) = v49;
      v56 = (double **)(*v16)[v52 + 1];
      *(_QWORD *)(v50 + 32) = v56;
      *(_QWORD *)(v50 + 40) = v55;
      if (a5)
      {
        if (v49)
        {
          v58 = *(double **)v49;
          v57 = *(double **)(v49 + 8);
          if (*(double **)v49 == v54 && v57 == a3)
          {
            v64 = 0;
            if (!v56)
              goto LABEL_204;
          }
          else
          {
            v60 = *(double **)(v49 + 16);
            if (v60 == v54 && v58 == a3)
              v62 = 2;
            else
              v62 = -1;
            if (v57 == v54 && v60 == a3)
              v64 = 1;
            else
              v64 = v62;
            if (!v56)
              goto LABEL_204;
          }
        }
        else
        {
          v64 = -1;
          if (!v56)
            goto LABEL_204;
        }
        v67 = v56[1];
        if (*v56 == v53 && v67 == v54)
        {
          v73 = 0;
        }
        else
        {
          v69 = v56[2];
          if (v69 == v53 && *v56 == v54)
            v71 = 2;
          else
            v71 = -1;
          if (v67 == v53 && v69 == v54)
            v73 = 1;
          else
            v73 = v71;
        }
        if (v64 == -1 || v73 == -1)
          goto LABEL_204;
        v56[v73 + 3] = (double *)v50;
        *(_QWORD *)(*(_QWORD *)(v50 + 24) + 8 * v64 + 24) = v50;
        v74 = *(_QWORD *)(v50 + 32);
        *(_BYTE *)(v50 + 48) = *(_BYTE *)(*(_QWORD *)(v50 + 24) + v64 + 48);
        *(_WORD *)(v50 + 49) = *(unsigned __int8 *)(v74 + v73 + 48);
      }
      else
      {
        if (v55)
        {
          v65 = *(double **)(v55 + 8);
          if (*(double **)v55 == a3 && v65 == v53)
          {
            v66 = 0;
          }
          else
          {
            v75 = *(double **)(v55 + 16);
            if (v65 == a3 && v75 == v53)
            {
              v66 = 1;
            }
            else if (v75 == a3 && *(_QWORD *)v55 == (_QWORD)v53)
            {
              v66 = 2;
            }
            else
            {
              v66 = -1;
            }
          }
        }
        else
        {
          v66 = -1;
        }
        if (!v56)
          goto LABEL_204;
        v77 = v56[1];
        if (*v56 == v53 && v77 == v54)
        {
          v83 = 0;
        }
        else
        {
          v79 = v56[2];
          v80 = v79 == v53 && *v56 == v54;
          v81 = v80 ? 2 : -1;
          v82 = v77 == v53 && v79 == v54;
          v83 = v82 ? 1 : v81;
        }
        if (v66 == -1 || v83 == -1)
          goto LABEL_204;
        if (v55 < 2)
        {
          v84 = 0;
        }
        else
        {
          *(_QWORD *)(v55 + 8 * v66 + 24) = v50;
          v56 = *(double ***)(v50 + 32);
          v84 = *(_BYTE *)(*(_QWORD *)(v50 + 40) + v66 + 48);
        }
        *(_BYTE *)(v50 + 50) = v84;
        if ((unint64_t)v56 < 2)
        {
          v85 = 0;
        }
        else
        {
          v56[v83 + 3] = (double *)v50;
          v85 = *(_BYTE *)(*(_QWORD *)(v50 + 32) + v83 + 48);
        }
        *(_BYTE *)(v50 + 49) = v85;
        *(_BYTE *)(v50 + 48) = 0;
      }
      v51 = (double **)(*((_QWORD *)a1 + 1) + 8 * v52);
      v49 = v50;
      if (v52-- <= v12)
        goto LABEL_184;
    }
  }
  v50 = v17[v6];
LABEL_184:
  v87 = *((_QWORD *)a4 + 1);
  v88 = v19 - 1;
  *a4 = v88;
  v89 = *(_QWORD *)(v87 + 8 * v88);
  *(_QWORD *)v89 = a2;
  if (a5)
  {
    *(_QWORD *)(v89 + 8) = a3;
    *(_QWORD *)(v89 + 16) = v11;
    if (v18)
    {
      v90 = *(double **)(v18 + 8);
      if (*(double **)v18 != a2 || v90 != v11)
      {
        v92 = *(double **)(v18 + 16);
        if (v92 == a2 && *(_QWORD *)v18 == (_QWORD)v11)
          v94 = 2;
        else
          v94 = -1;
        if (v90 == a2 && v92 == v11)
          v96 = 1;
        else
          v96 = v94;
        if (!v50)
          return 2;
LABEL_231:
        v105 = *(double **)(v50 + 8);
        if (*(double **)v50 == v11 && v105 == a3)
        {
          v110 = 0;
        }
        else
        {
          v107 = *(double **)(v50 + 16);
          if (v105 == v11 && v107 == a3)
          {
            v110 = 1;
          }
          else if (v107 == v11 && *(_QWORD *)v50 == (_QWORD)a3)
          {
            v110 = 2;
          }
          else
          {
            v110 = -1;
          }
        }
        result = 2;
        if (v96 != -1 && v110 != -1)
        {
          *(_QWORD *)(v89 + 24) = 1;
          *(_QWORD *)(v89 + 32) = v50;
          *(_QWORD *)(v89 + 40) = v18;
          if (v18 < 2)
          {
            v117 = 0;
          }
          else
          {
            *(_QWORD *)(v18 + 8 * v96 + 24) = v89;
            v117 = *(_BYTE *)(v18 + v96 + 48);
          }
          *(_BYTE *)(v89 + 50) = v117;
          if (v50 < 2)
          {
            v118 = 0;
          }
          else
          {
            *(_QWORD *)(v50 + 8 * v110 + 24) = v89;
            v118 = *(_BYTE *)(v50 + v110 + 48);
          }
          *(_BYTE *)(v89 + 49) = v118;
          *(_BYTE *)(v89 + 48) = 1;
          return v89;
        }
        return result;
      }
      v96 = 0;
      if (v50)
        goto LABEL_231;
    }
    else
    {
      v96 = -1;
      if (v50)
        goto LABEL_231;
    }
    return 2;
  }
  *(_QWORD *)(v89 + 8) = v11;
  *(_QWORD *)(v89 + 16) = a3;
  if (v18)
  {
    v98 = *(double **)(v18 + 8);
    if (*(double **)v18 == v11 && v98 == a2)
    {
      v104 = 0;
      if (!v50)
        return 2;
    }
    else
    {
      v100 = *(double **)(v18 + 16);
      if (v100 == v11 && *(_QWORD *)v18 == (_QWORD)a2)
        v102 = 2;
      else
        v102 = -1;
      if (v98 == v11 && v100 == a2)
        v104 = 1;
      else
        v104 = v102;
      if (!v50)
        return 2;
    }
  }
  else
  {
    v104 = -1;
    if (!v50)
      return 2;
  }
  v111 = *(double **)(v50 + 8);
  if (*(double **)v50 == a3 && v111 == v11)
  {
    v116 = 0;
  }
  else
  {
    v113 = *(double **)(v50 + 16);
    if (v111 == a3 && v113 == v11)
    {
      v116 = 1;
    }
    else if (v113 == a3 && *(_QWORD *)v50 == (_QWORD)v11)
    {
      v116 = 2;
    }
    else
    {
      v116 = -1;
    }
  }
  result = 2;
  if (v18 && v104 != -1 && v116 != -1)
  {
    *(_QWORD *)(v18 + 8 * v104 + 24) = v89;
    *(_QWORD *)(v50 + 8 * v116 + 24) = v89;
    *(_QWORD *)(v89 + 24) = v18;
    *(_QWORD *)(v89 + 32) = v50;
    *(_QWORD *)(v89 + 40) = 1;
    *(_BYTE *)(v89 + 48) = *(_BYTE *)(v18 + v104 + 48);
    *(_BYTE *)(v89 + 49) = *(_BYTE *)(v50 + v116 + 48);
    *(_BYTE *)(v89 + 50) = 1;
    return v89;
  }
  return result;
}

void ARC3DShapeTriangulationAddEdge(uint64_t a1, double *a2, double *a3)
{
  double *v3;
  uint64_t v4;
  double *v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  void *v23;
  int v24;
  double *v25;
  double *v26;
  uint64_t **v27;
  double *v28;
  uint64_t *v29;
  BOOL v30;
  void *v31;
  double *v32;
  double *v33;
  double v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t *v38;
  uint64_t *v39;
  double *v40;
  unsigned int v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t *v46;
  uint64_t *v47;
  uint64_t *v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  void *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  unsigned int v58;
  double *v59;
  int v60;
  unsigned int v61;
  uint64_t v62;
  void *v63;
  void *v64;
  uint64_t v65;
  void *v66;
  void *v67;
  uint64_t v68;
  void *ptr;
  double **v70;

  v3 = a3;
  v4 = a1;
  if (*a2 > *a3 || *a2 == *a3 && a2[1] < a3[1])
  {
    v5 = a2;
  }
  else
  {
    v5 = a3;
    v3 = a2;
  }
  v6 = ARC3DShapeTriangulationTriangleContainingVertex((uint64_t)v3, a1);
  if (v6 == 2)
  {
    v16 = 6;
    goto LABEL_44;
  }
  v7 = v6;
  v8 = *(_DWORD *)(v4 + 32);
  v70 = 0;
  if ((ARC3DEdgeCrossingSegment(v6, v3, v5, &v70) & 1) == 0)
  {
    while (1)
    {
      if (!--v8)
      {
        v16 = 2;
        goto LABEL_44;
      }
      if (*(double **)v7 == v3)
        break;
      if (*(double **)(v7 + 8) == v3)
      {
        v9 = (uint64_t *)(v7 + 32);
        goto LABEL_15;
      }
      if (*(double **)(v7 + 16) == v3)
      {
        v9 = (uint64_t *)(v7 + 40);
LABEL_15:
        v7 = *v9;
      }
      if (ARC3DEdgeCrossingSegment(v7, v3, v5, &v70))
        goto LABEL_17;
    }
    v9 = (uint64_t *)(v7 + 24);
    goto LABEL_15;
  }
LABEL_17:
  if (!v7 || *(double **)v7 != v5 && *(double **)(v7 + 8) != v5 && *(double **)(v7 + 16) != v5)
  {
    v68 = 0x1000000000;
    ptr = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
    v65 = 0x400000000;
    v66 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    v67 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    v62 = 0x400000000;
    v63 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    v10 = malloc_type_malloc(0x20uLL, 0x2004093837F09uLL);
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v64 = v10;
    do
    {
      v14 = *(double **)(v7 + v11);
      if (v14 != v3)
      {
        if ((*v5 - *v3) * (v14[1] - v3[1]) - (v5[1] - v3[1]) * (*v14 - *v3) <= 0.0)
          v12 = *(_QWORD *)(v7 + v11);
        else
          v13 = *(_QWORD *)(v7 + v11);
      }
      v11 += 8;
    }
    while (v11 != 24);
    if (*(_QWORD *)v7 == v12)
    {
      v19 = (uint64_t *)(v7 + 32);
    }
    else if (*(_QWORD *)(v7 + 8) == v12)
    {
      v19 = (uint64_t *)(v7 + 40);
    }
    else
    {
      if (*(_QWORD *)(v7 + 16) != v12)
      {
        v15 = 0;
        goto LABEL_49;
      }
      v19 = (uint64_t *)(v7 + 24);
    }
    v15 = *v19;
LABEL_49:
    ARC3DShapeTriangulationListInsert((void **)&v65, v13, v15);
    if (*(_QWORD *)v7 == v13)
    {
      v21 = (uint64_t *)(v7 + 32);
    }
    else if (*(_QWORD *)(v7 + 8) == v13)
    {
      v21 = (uint64_t *)(v7 + 40);
    }
    else
    {
      if (*(_QWORD *)(v7 + 16) != v13)
      {
        v20 = 0;
LABEL_57:
        ARC3DShapeTriangulationListInsert((void **)&v62, v12, v20);
        v22 = 0;
        v61 = v68;
        if ((double *)v13 != v5 && (double *)v12 != v5)
        {
          v56 = 0;
          v57 = 0;
          v55 = v4;
          v58 = HIDWORD(v68);
          v23 = ptr;
          v24 = *(_DWORD *)(v4 + 32) - 1;
          v25 = v3;
          while (1)
          {
            if (!v24)
            {
              v45 = 3;
              goto LABEL_112;
            }
            v26 = *(double **)(v7 + 8);
            if (*(double **)v7 == v25)
            {
              v28 = *(double **)(v7 + 16);
              v27 = (uint64_t **)(v7 + 32);
            }
            else if (v26 == v25)
            {
              v27 = (uint64_t **)(v7 + 40);
              v28 = *(double **)v7;
              v26 = *(double **)(v7 + 16);
            }
            else
            {
              if (*(double **)(v7 + 16) != v25)
                goto LABEL_108;
              v27 = (uint64_t **)(v7 + 24);
              v28 = *(double **)(v7 + 8);
              v26 = *(double **)v7;
            }
            v29 = *v27;
            if (*v27)
              v30 = v26 == 0;
            else
              v30 = 1;
            if (v30)
            {
LABEL_108:
              v45 = 4;
              goto LABEL_112;
            }
            v60 = v24;
            v31 = v23;
            v32 = (double *)ARC3DVertexNotSharedByTriangles((uint64_t)v29, v7);
            if (!v32)
            {
              v45 = 1;
LABEL_112:
              v4 = v55;
LABEL_129:
              *(_DWORD *)(v4 + 40) = v45;
              goto LABEL_130;
            }
            v33 = v32;
            v34 = (*v5 - *v3) * (v32[1] - v3[1]) - (v5[1] - v3[1]) * (*v32 - *v3);
            v35 = *v29;
            v59 = v28;
            if (v34 <= 0.0)
            {
              if (v35 == v13)
              {
                v39 = v29 + 4;
              }
              else if (v29[1] == v13)
              {
                v39 = v29 + 5;
              }
              else
              {
                if (v29[2] != v13)
                {
                  v37 = 0;
LABEL_90:
                  ARC3DShapeTriangulationListInsert((void **)&v62, (uint64_t)v32, v37);
                  v40 = (double *)v13;
                  v56 = v12;
                  goto LABEL_91;
                }
                v39 = v29 + 3;
              }
              v37 = *v39;
              goto LABEL_90;
            }
            if (v35 == v12)
              break;
            if (v29[1] == v12)
            {
              v38 = v29 + 5;
              goto LABEL_86;
            }
            if (v29[2] == v12)
            {
              v38 = v29 + 3;
              goto LABEL_86;
            }
            v36 = 0;
LABEL_87:
            ARC3DShapeTriangulationListInsert((void **)&v65, (uint64_t)v32, v36);
            v40 = v33;
            v57 = v13;
            v33 = (double *)v12;
LABEL_91:
            v23 = v31;
            if (v61 == v58)
            {
              v58 *= 2;
              v23 = malloc_type_realloc(v31, 8 * v58, 0x2004093837F09uLL);
              ptr = v23;
            }
            v41 = v61 + 1;
            *((_QWORD *)v23 + v61) = v7;
            v25 = v59;
            if (v34 > 0.0 == (*v5 - *v3) * (v26[1] - v3[1]) - (v5[1] - v3[1]) * (*v26 - *v3) > 0.0)
              v25 = v26;
            if (v40 != v5)
            {
              v24 = v60 - 1;
              v12 = (uint64_t)v33;
              v13 = (uint64_t)v40;
              v7 = (uint64_t)v29;
              ++v61;
              if (v33 != v5)
                continue;
            }
            v22 = v57;
            HIDWORD(v68) = v58;
            v4 = v55;
            v42 = v56;
            goto LABEL_99;
          }
          v38 = v29 + 4;
LABEL_86:
          v36 = *v38;
          goto LABEL_87;
        }
        v41 = v68;
        v29 = (uint64_t *)v7;
        v40 = (double *)v13;
        v42 = 0;
LABEL_99:
        v43 = *v29;
        if (v40 != v5)
        {
          if (v43 == v42)
          {
            v46 = v29 + 4;
          }
          else if (v29[1] == v42)
          {
            v46 = v29 + 5;
          }
          else
          {
            if (v29[2] != v42)
            {
              v44 = 0;
LABEL_117:
              v48 = &v65;
              goto LABEL_122;
            }
            v46 = v29 + 3;
          }
          v44 = *v46;
          goto LABEL_117;
        }
        if (v43 == v22)
        {
          v47 = v29 + 4;
        }
        else if (v29[1] == v22)
        {
          v47 = v29 + 5;
        }
        else
        {
          if (v29[2] != v22)
          {
            v44 = 0;
LABEL_121:
            v48 = &v62;
LABEL_122:
            ARC3DShapeTriangulationListInsert((void **)v48, (uint64_t)v5, v44);
            if (HIDWORD(v68) == v41)
            {
              HIDWORD(v68) = 2 * v41;
              v49 = malloc_type_realloc(ptr, 16 * v41, 0x2004093837F09uLL);
              ptr = v49;
            }
            else
            {
              v49 = ptr;
            }
            LODWORD(v68) = v41 + 1;
            *((_QWORD *)v49 + v41) = v29;
            v45 = 1;
            v50 = ARC3DShapeConnectedComponentTriangulatePseudopolygon((int *)&v65, v3, v5, (unsigned int *)&v68, 1);
            if (v50 == 2)
              goto LABEL_129;
            v51 = v50;
            v52 = ARC3DShapeConnectedComponentTriangulatePseudopolygon((int *)&v62, v3, v5, (unsigned int *)&v68, 0);
            if (v52 == 2)
              goto LABEL_129;
            *(_QWORD *)(v51 + 24) = v52;
            *(_QWORD *)(v52 + 40) = v51;
            if ((_DWORD)v68)
              ARC3DShapeTriangulationAddEdge_cold_1();
LABEL_130:
            free(ptr);
            v53 = v67;
            free(v66);
            free(v53);
            v54 = v64;
            free(v63);
            free(v54);
            return;
          }
          v47 = v29 + 3;
        }
        v44 = *v47;
        goto LABEL_121;
      }
      v21 = (uint64_t *)(v7 + 24);
    }
    v20 = *v21;
    goto LABEL_57;
  }
  v17 = 0;
  while (*(double ***)(v7 + 8 * v17 + 24) != v70)
  {
    if (++v17 == 3)
    {
      LODWORD(v17) = -1;
      break;
    }
  }
  v18 = 0;
  while (v70[v18 + 3] != (double *)v7)
  {
    if (++v18 == 3)
      goto LABEL_43;
  }
  if ((_DWORD)v17 != -1)
  {
    *((_BYTE *)v70 + v18 + 48) = 1;
    *(_BYTE *)(v7 + v17 + 48) = 1;
    return;
  }
LABEL_43:
  v16 = 5;
LABEL_44:
  *(_DWORD *)(v4 + 40) = v16;
}

int *ARC3DShapeTriangulationResolveSwaps(int *result, double *a2)
{
  unsigned int v2;
  int *v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  unsigned int v15;
  double *v16;
  double *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  char v23;
  uint64_t v24;
  uint64_t *v25;
  uint64_t v26;
  uint64_t *v27;

  v2 = *result;
  if (*result)
  {
    v4 = result;
    v5 = 1000;
    while (2)
    {
      if (v5 >= 2)
      {
        if (v2 > v4[8])
        {
          v14 = 9;
        }
        else
        {
          v6 = *((_QWORD *)v4 + 1);
          v7 = v2 - 1;
          *v4 = v7;
          v8 = *(_QWORD *)(v6 + 8 * v7);
          v9 = *(_QWORD *)(v8 + 32);
          if (v9)
          {
            v10 = 0;
            --v5;
            v11 = 24;
            while (*(_QWORD *)(v9 + v11) != v8)
            {
              ++v10;
              v11 += 8;
              if (v10 == 3)
                goto LABEL_38;
            }
            if (v10 > 1)
              v12 = -2;
            else
              v12 = 1;
            if ((_DWORD)v10)
              v13 = (v10 - 1);
            else
              v13 = 2;
            v14 = 5;
            if (~v12 != (_DWORD)v10 && (_DWORD)v13 != -1)
            {
              if (!*(_BYTE *)(v8 + 49))
              {
                v15 = v12 + v10;
                v16 = *(double **)(v9 + v11 - 24);
                v17 = *(double **)(v9 + 8 * v13);
                result = (int *)ARC3DCircumcircleContainsPoint(v16, *(double **)(v9 + 8 * (v12 + v10)), v17, a2);
                if ((_DWORD)result)
                {
                  v18 = v15;
                  v19 = *(_QWORD *)(v9 + 24 + 8 * v15);
                  v20 = *(_QWORD *)(v9 + 24 + 8 * v13);
                  v21 = *(_QWORD *)(v8 + 40);
                  v22 = *(_BYTE *)(v9 + 48 + v13);
                  v23 = *(_BYTE *)(v8 + 50);
                  *(_WORD *)(v8 + 49) = *(unsigned __int8 *)(v9 + 48 + v18);
                  *(_BYTE *)(v9 + 48) = 0;
                  *(_BYTE *)(v9 + 49) = v22;
                  *(_BYTE *)(v9 + 50) = v23;
                  *(_QWORD *)(v8 + 16) = v17;
                  *(_QWORD *)(v8 + 32) = v19;
                  *(_QWORD *)(v8 + 40) = v9;
                  *(_QWORD *)v9 = a2;
                  *(_QWORD *)(v9 + 8) = v17;
                  *(_QWORD *)(v9 + 16) = v16;
                  *(_QWORD *)(v9 + 24) = v8;
                  *(_QWORD *)(v9 + 32) = v20;
                  *(_QWORD *)(v9 + 40) = v21;
                  if (v19)
                  {
                    v24 = 0;
                    while (*(_QWORD *)(v19 + 24 + v24) != v9)
                    {
                      v24 += 8;
                      if (v24 == 24)
                        goto LABEL_38;
                    }
                    v25 = (uint64_t *)(v19 + v24 + 24);
                    if (v25 == (uint64_t *)3)
                      goto LABEL_38;
                    *v25 = v8;
                    result = (int *)ARC3DShapeTriangulationStackPush(v4, v8);
                  }
                  if (v20)
                    result = (int *)ARC3DShapeTriangulationStackPush(v4, v9);
                  if (v21)
                  {
                    v26 = 0;
                    while (*(_QWORD *)(v21 + 24 + v26) != v8)
                    {
                      v26 += 8;
                      if (v26 == 24)
                        goto LABEL_38;
                    }
                    v27 = (uint64_t *)(v21 + v26 + 24);
                    if (v27 != (uint64_t *)3)
                    {
                      *v27 = v9;
                      goto LABEL_36;
                    }
LABEL_38:
                    v14 = 5;
                    goto LABEL_39;
                  }
                }
              }
LABEL_36:
              v2 = *v4;
              if (*v4)
                continue;
              return result;
            }
          }
          else
          {
            v14 = 10;
          }
        }
LABEL_39:
        v4[10] = v14;
      }
      break;
    }
  }
  return result;
}

int *ARC3DShapeTriangulationTriangleSplitInside(int *result, uint64_t a2, uint64_t a3)
{
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t *v18;

  v4 = result;
  v6 = *(_QWORD *)(a2 + 32);
  v5 = *(_QWORD *)(a2 + 40);
  v7 = *(_QWORD *)a2;
  v8 = *(_QWORD *)(a2 + 8);
  v10 = *(_QWORD *)(a2 + 16);
  v9 = *(_QWORD *)(a2 + 24);
  *(_QWORD *)a2 = a3;
  *(_QWORD *)(a2 + 8) = v7;
  *(_QWORD *)(a2 + 16) = v8;
  v11 = *((_QWORD *)result + 2);
  v12 = result[8];
  v13 = v11 + 56 * v12;
  *(_BYTE *)(v13 + 51) = 0;
  result[8] = v12 + 2;
  v14 = v11 + 56 * (v12 + 1);
  *(_BYTE *)(v14 + 51) = 0;
  *(_QWORD *)(a2 + 24) = v13;
  *(_QWORD *)(a2 + 32) = v9;
  *(_QWORD *)(a2 + 40) = v14;
  *(_QWORD *)v13 = a3;
  *(_QWORD *)(v13 + 8) = v10;
  *(_QWORD *)(v13 + 16) = v7;
  *(_QWORD *)(v13 + 24) = v14;
  *(_QWORD *)(v13 + 32) = v5;
  *(_QWORD *)(v13 + 40) = a2;
  *(_QWORD *)v14 = a3;
  *(_QWORD *)(v14 + 8) = v8;
  *(_QWORD *)(v14 + 16) = v10;
  *(_QWORD *)(v14 + 24) = a2;
  *(_QWORD *)(v14 + 32) = v6;
  *(_QWORD *)(v14 + 40) = v13;
  *(_BYTE *)(v13 + 48) = 0;
  *(_BYTE *)(v13 + 49) = *(_BYTE *)(a2 + 50);
  *(_BYTE *)(v13 + 50) = 0;
  *(_BYTE *)(v14 + 48) = 0;
  *(_BYTE *)(v14 + 49) = *(_BYTE *)(a2 + 49);
  *(_BYTE *)(v14 + 50) = 0;
  *(_BYTE *)(a2 + 49) = *(_BYTE *)(a2 + 48);
  *(_BYTE *)(a2 + 48) = 0;
  *(_BYTE *)(a2 + 50) = 0;
  if (v9)
    result = (int *)ARC3DShapeTriangulationStackPush(result, a2);
  if (v6)
  {
    v15 = 0;
    while (*(_QWORD *)(v6 + 24 + v15) != a2)
    {
      v15 += 8;
      if (v15 == 24)
        goto LABEL_17;
    }
    v16 = (uint64_t *)(v6 + v15 + 24);
    if (v16 == (uint64_t *)3)
      goto LABEL_17;
    *v16 = v14;
    result = (int *)ARC3DShapeTriangulationStackPush(v4, v14);
  }
  if (!v5)
    return result;
  v17 = 0;
  while (*(_QWORD *)(v5 + 24 + v17) != a2)
  {
    v17 += 8;
    if (v17 == 24)
      goto LABEL_17;
  }
  v18 = (uint64_t *)(v5 + v17 + 24);
  if (v18 != (uint64_t *)3)
  {
    *v18 = v13;
    return (int *)ARC3DShapeTriangulationStackPush(v4, v13);
  }
LABEL_17:
  v4[10] = 5;
  return result;
}

_QWORD *ARC3DShapeTriangulationTriangleSplitOnEdge(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, unsigned int a5)
{
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned __int8 v16;
  char v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD *result;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  uint64_t *v30;

  v7 = *(_QWORD *)(a2 + 24 + 8 * a4);
  v8 = (a5 + 1) % 3;
  v9 = *(_QWORD *)(v7 + 24 + 8 * v8);
  v10 = (a5 + 2) % 3;
  v11 = *(_QWORD *)(v7 + 24 + 8 * v10);
  v12 = (a4 + 1) % 3;
  v13 = *(_QWORD *)(a2 + 24 + 8 * v12);
  v14 = (a4 + 2) % 3;
  v15 = *(_QWORD *)(a2 + 24 + 8 * v14);
  v16 = *(_BYTE *)(v7 + 48 + v8);
  LOBYTE(v8) = *(_BYTE *)(v7 + 48 + v10);
  LOBYTE(v12) = *(_BYTE *)(a2 + 48 + v12);
  v17 = *(_BYTE *)(a2 + 48 + v14);
  v18 = *(_BYTE *)(v7 + 48 + a5);
  v19 = *(_QWORD *)(a2 + 8 * a4);
  v20 = *(_QWORD *)(v7 + 8 * a5);
  v21 = *(_QWORD *)(a2 + 8 * v14);
  v22 = *(_QWORD *)(v7 + 8 * v10);
  result = *(_QWORD **)(a1 + 16);
  v24 = *(_DWORD *)(a1 + 32);
  v25 = (uint64_t)&result[7 * v24];
  *(_BYTE *)(v25 + 51) = 0;
  *(_DWORD *)(a1 + 32) = v24 + 2;
  v26 = (uint64_t)&result[7 * v24 + 7];
  *(_BYTE *)(v26 + 51) = 0;
  *(_QWORD *)a2 = a3;
  *(_QWORD *)(a2 + 8) = v20;
  *(_QWORD *)(a2 + 16) = v21;
  *(_QWORD *)(a2 + 24) = v7;
  *(_QWORD *)(a2 + 32) = v13;
  *(_QWORD *)(a2 + 40) = v25;
  *(_BYTE *)(a2 + 48) = v18;
  *(_WORD *)(a2 + 49) = v12;
  *(_QWORD *)v7 = a3;
  *(_QWORD *)(v7 + 8) = v22;
  *(_QWORD *)(v7 + 16) = v20;
  *(_QWORD *)(v7 + 24) = v26;
  *(_QWORD *)(v7 + 32) = v11;
  *(_QWORD *)(v7 + 40) = a2;
  *(_BYTE *)(v7 + 48) = 0;
  *(_BYTE *)(v7 + 49) = v8;
  *(_BYTE *)(v7 + 50) = v18;
  *(_QWORD *)v25 = a3;
  *(_QWORD *)(v25 + 8) = v21;
  *(_QWORD *)(v25 + 16) = v19;
  *(_QWORD *)(v25 + 24) = a2;
  *(_QWORD *)(v25 + 32) = v15;
  *(_QWORD *)(v25 + 40) = v26;
  *(_BYTE *)(v25 + 48) = 0;
  *(_BYTE *)(v25 + 49) = v17;
  *(_BYTE *)(v25 + 50) = v18;
  *(_QWORD *)v26 = a3;
  *(_QWORD *)(v26 + 8) = v19;
  *(_QWORD *)(v26 + 16) = v22;
  *(_QWORD *)(v26 + 24) = v25;
  *(_QWORD *)(v26 + 32) = v9;
  *(_QWORD *)(v26 + 40) = v7;
  *(_BYTE *)(v26 + 48) = v18;
  *(_WORD *)(v26 + 49) = v16;
  if (v11)
    result = ARC3DShapeTriangulationStackPush((int *)a1, v7);
  if (v13)
    result = ARC3DShapeTriangulationStackPush((int *)a1, a2);
  if (v15)
  {
    v27 = 0;
    while (*(_QWORD *)(v15 + 24 + v27) != a2)
    {
      v27 += 8;
      if (v27 == 24)
        goto LABEL_19;
    }
    v28 = (uint64_t *)(v15 + v27 + 24);
    if (v28 == (uint64_t *)3)
      goto LABEL_19;
    *v28 = v25;
    result = ARC3DShapeTriangulationStackPush((int *)a1, v25);
  }
  if (!v9)
    return result;
  v29 = 0;
  while (*(_QWORD *)(v9 + 24 + v29) != v7)
  {
    v29 += 8;
    if (v29 == 24)
      goto LABEL_19;
  }
  v30 = (uint64_t *)(v9 + v29 + 24);
  if (v30 != (uint64_t *)3)
  {
    *v30 = v26;
    return ARC3DShapeTriangulationStackPush((int *)a1, v26);
  }
LABEL_19:
  *(_DWORD *)(a1 + 40) = 5;
  return result;
}

int *ARC3DShapeTriangulationAddPoint(uint64_t a1, float64x2_t *a2)
{
  int *result;
  uint64_t v5;
  uint64_t v6;

  result = (int *)ARC3DShapeTriangulationTriangleContainingPoint(a2, *(_QWORD *)(a1 + 16) + 56 * (*(_DWORD *)(a1 + 32) - 1), a1);
  if (result == (int *)2)
  {
    *(_DWORD *)(a1 + 40) = 8;
  }
  else
  {
    v5 = (uint64_t)result;
    v6 = 0;
    if (ARC3DPointFallsOnTriangleEdgeAndLinks((uint64_t)result, a2->f64, (_DWORD *)&v6 + 1, &v6))
      ARC3DShapeTriangulationTriangleSplitOnEdge(a1, v5, (uint64_t)a2, HIDWORD(v6), v6);
    else
      ARC3DShapeTriangulationTriangleSplitInside((int *)a1, v5, (uint64_t)a2);
    return ARC3DShapeTriangulationResolveSwaps((int *)a1, a2->f64);
  }
  return result;
}

__n128 ARC3DShapeTriangulationInit(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  uint64_t v15;
  __n128 result;

  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a1 + 32) = v6 + 1;
  v7 = v5 + 56 * v6;
  *(_BYTE *)(v7 + 51) = 0;
  *(_QWORD *)(a1 + 24) = v7;
  v8 = *(double *)(*(_QWORD *)a2 + 16);
  v9 = *(double *)(*(_QWORD *)a2 + 24);
  v10 = *(double *)(*(_QWORD *)a2 + 32);
  v11 = *(double *)(*(_QWORD *)a2 + 40);
  v12 = v9 - v8;
  v13 = v11 - v10;
  if (vabdd_f64(v9, v8) < 0.00001 || vabdd_f64(v11, v10) < 0.00001)
    *(_DWORD *)(a1 + 40) = 7;
  v14 = v10 + v13 * -100.0;
  v15 = v5 + 56 * v6;
  *(_QWORD *)(v15 + 24) = 0;
  *(_QWORD *)(v15 + 32) = 0;
  *(_DWORD *)(v15 + 47) = 0;
  *(_QWORD *)(v15 + 40) = 0;
  *(double *)a3 = v8 + v12 * -100.0;
  *(double *)(a3 + 8) = v14;
  *(_OWORD *)(a3 + 48) = *(_OWORD *)a3;
  *(double *)a4 = v8 + v12 * 100.0;
  *(double *)(a4 + 8) = v14;
  *(_OWORD *)(a4 + 48) = *(_OWORD *)a4;
  *(double *)a5 = v8 + v12 * 0.0;
  *(double *)(a5 + 8) = v10 + v13 * 100.0;
  result = *(__n128 *)a5;
  *(_OWORD *)(a5 + 48) = *(_OWORD *)a5;
  *(_QWORD *)v7 = a3;
  *(_QWORD *)(v7 + 8) = a4;
  *(_QWORD *)(v7 + 16) = a5;
  return result;
}

uint64_t ARC3DShapeTriangulationTriangleMark(uint64_t a1, int a2, BOOL *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t result;
  unsigned __int8 *v9;

  *(_BYTE *)(a1 + 51) = 1;
  *(_BYTE *)(a1 + 52) = a2;
  v6 = *(_QWORD *)(a1 + 24);
  if (v6 && !*(_BYTE *)(v6 + 51))
    ARC3DShapeTriangulationTriangleMark();
  v7 = *(_QWORD *)(a1 + 32);
  if (v7 && !*(_BYTE *)(v7 + 51))
    ARC3DShapeTriangulationTriangleMark();
  result = *(_QWORD *)(a1 + 40);
  if (result)
  {
    if (!*(_BYTE *)(result + 51))
      result = ARC3DShapeTriangulationTriangleMark();
  }
  if (*(_QWORD *)(a1 + 24))
  {
    if (*(_QWORD *)(a1 + 32))
    {
      if (*(_QWORD *)(a1 + 40))
        return result;
      v9 = (unsigned __int8 *)(a1 + 50);
    }
    else
    {
      v9 = (unsigned __int8 *)(a1 + 49);
    }
  }
  else
  {
    v9 = (unsigned __int8 *)(a1 + 48);
  }
  *a3 = *v9 != a2;
  return result;
}

void *ARC3DShapeTriangulationClean(uint64_t a1)
{
  unint64_t v2;
  unsigned int v3;
  int v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  void *result;
  BOOL v10;

  v10 = 0;
  ARC3DShapeTriangulationTriangleMark(*(_QWORD *)(a1 + 16), 1, &v10);
  LODWORD(v2) = *(_DWORD *)(a1 + 32);
  if (!(_DWORD)v2)
    goto LABEL_12;
  v3 = 0;
  v4 = v10;
  do
  {
    if (*(unsigned __int8 *)(*(_QWORD *)(a1 + 16) + 56 * v3 + 52) == v4)
    {
      LODWORD(v2) = v2 - 1;
      *(_DWORD *)(a1 + 32) = v2;
      if (v3 < v2)
      {
        v5 = v3;
        v6 = 56 * v3;
        do
        {
          v7 = *(_QWORD *)(a1 + 16) + v6;
          ++v5;
          v8 = *(_OWORD *)(v7 + 72);
          *(_OWORD *)v7 = *(_OWORD *)(v7 + 56);
          *(_OWORD *)(v7 + 16) = v8;
          *(_OWORD *)(v7 + 32) = *(_OWORD *)(v7 + 88);
          *(_QWORD *)(v7 + 48) = *(_QWORD *)(v7 + 104);
          v2 = *(unsigned int *)(a1 + 32);
          v6 += 56;
        }
        while (v5 < v2);
      }
    }
    else
    {
      ++v3;
    }
  }
  while (v3 < v2);
  if ((_DWORD)v2)
  {
    result = malloc_type_realloc(*(void **)(a1 + 16), 56 * v2, 0x1020040F7381AC9uLL);
  }
  else
  {
LABEL_12:
    free(*(void **)(a1 + 16));
    result = 0;
  }
  *(_QWORD *)(a1 + 16) = result;
  return result;
}

void *ARC3DShapeConnectedComponentTriangulate(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  uint64_t v6;
  int v7;
  int *v8;
  int v9;
  unsigned int v10;
  __int128 v11;
  int v12;
  unsigned int v13;
  uint64_t v14;
  float64x2_t *v15;
  uint64_t v16;
  uint64_t v17;
  float64x2_t *v18;
  double *f64;
  float64x2_t v20;
  float64x2_t v21;
  uint64_t v22;
  float64x2_t *v23;
  int32x2_t v24;
  _DWORD *v26;
  float64x2_t v27;
  _OWORD v28[2];
  _OWORD v29[5];
  _OWORD v30[5];
  _OWORD v31[5];
  uint64_t v32;
  void *v33;
  void *v34;
  uint64_t v35;
  int v36;
  unsigned int v37;
  uint64_t v38;

  v6 = *(unsigned int *)(a1 + 8);
  if ((_DWORD)v6)
  {
    v7 = 0;
    v8 = (int *)(*(_QWORD *)a1 + 8);
    do
    {
      v9 = *v8;
      v8 += 14;
      v7 += v9;
      --v6;
    }
    while (v6);
    v10 = 2 * v7 + 2;
  }
  else
  {
    v10 = 2;
  }
  v35 = 0;
  v32 = 0x1000000000;
  v33 = malloc_type_malloc(0x80uLL, 0x2004093837F09uLL);
  v34 = malloc_type_malloc(56 * v10, 0x1020040F7381AC9uLL);
  v36 = 0;
  v37 = v10;
  v38 = 0;
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  v11 = *(_OWORD *)(a1 + 16);
  v28[0] = *(_OWORD *)a1;
  v28[1] = v11;
  memset(v29, 0, sizeof(v29));
  ARC3DShapeTriangulationInit((uint64_t)&v32, (uint64_t)v28, (uint64_t)v31, (uint64_t)v30, (uint64_t)v29);
  v12 = v38;
  if ((_DWORD)v38)
  {
LABEL_20:
    free(v33);
    *a2 = 0;
    *a3 = v12;
    free(v34);
    return 0;
  }
  else
  {
    v26 = a3;
    v13 = *(_DWORD *)(a1 + 8);
    v27 = (float64x2_t)vdupq_n_s64(0x3EE4F8B588E368F1uLL);
    while ((--v13 & 0x80000000) == 0)
    {
      v14 = *(_QWORD *)a1 + 56 * v13;
      v15 = *(float64x2_t **)v14;
      v16 = *(unsigned int *)(v14 + 8);
      ARC3DShapeTriangulationAddPoint((uint64_t)&v32, *(float64x2_t **)v14);
      v12 = v38;
      if ((_DWORD)v38)
        goto LABEL_19;
      if (v16 >= 2)
      {
        v17 = 1;
        while (1)
        {
          v18 = &v15[5 * v17];
          v20 = *v18;
          f64 = v18[-5].f64;
          v21 = v20;
          v22 = v17;
          v23 = v15;
          while (1)
          {
            v24 = vmovn_s64(vcgeq_f64(v27, vabdq_f64(v21, *v23)));
            if ((v24.i32[0] & v24.i32[1] & 1) != 0)
              break;
            v23 += 5;
            if (!--v22)
            {
              ARC3DShapeTriangulationAddPoint((uint64_t)&v32, &v15[5 * v17]);
              v12 = v38;
              if ((_DWORD)v38)
                goto LABEL_19;
              break;
            }
          }
          ARC3DShapeTriangulationAddEdge((uint64_t)&v32, f64, v15[5 * v17].f64);
          v12 = v38;
          if ((_DWORD)v38)
            break;
          if (++v17 == v16)
            goto LABEL_18;
        }
LABEL_19:
        a3 = v26;
        goto LABEL_20;
      }
LABEL_18:
      ARC3DShapeTriangulationAddEdge((uint64_t)&v32, v15[5 * (v16 - 1)].f64, v15->f64);
      v12 = v38;
      if ((_DWORD)v38)
        goto LABEL_19;
    }
    ARC3DShapeTriangulationClean((uint64_t)&v32);
    free(v33);
    *a2 = v36;
    *v26 = 0;
    return v34;
  }
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 368, a4);
}

id _ARLogGeneral_7()
{
  if (_ARLogGeneral_onceToken_9 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_9, &__block_literal_global_28);
  return (id)_ARLogGeneral_logObj_9;
}

void sub_1B3AB60A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

float ARVoxelSizeForSceneReconstructionOptions(void *a1)
{
  float v1;
  void *v2;
  double v3;

  v1 = 0.05;
  switch(objc_msgSend(a1, "voxelSize"))
  {
    case 0:
      +[ARKitUserDefaults numberForKey:](ARKitUserDefaults, "numberForKey:", CFSTR("com.apple.arkit.sceneReconstruction.voxelSize"));
      v2 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "doubleValue");
      v1 = v3;

      break;
    case 2:
      v1 = 0.03;
      break;
    case 3:
      v1 = 0.01;
      break;
    case 4:
      v1 = 0.0;
      break;
    default:
      return v1;
  }
  return v1;
}

uint64_t ARBucketsOrderOfMagnitudeForSceneReconstructionOptions(void *a1)
{
  unint64_t v1;
  unsigned int v2;

  v1 = objc_msgSend(a1, "bucketsCount");
  v2 = 0x11100D11u >> (8 * v1);
  if (v1 >= 4)
    LOBYTE(v2) = 13;
  return v2;
}

unint64_t SemanticFromARMeshClassification(unsigned int a1)
{
  unint64_t v1;

  v1 = 0x6070F1303010200uLL >> (8 * a1);
  if (a1 >= 8)
    LOBYTE(v1) = 0;
  return v1 & 0x1F;
}

uint64_t ARMeshClassificationFromSemantic(int a1)
{
  int v1;
  uint64_t result;

  v1 = a1 - 1;
  result = 2;
  switch(v1)
  {
    case 0:
      return result;
    case 1:
      result = 1;
      break;
    case 2:
      result = 3;
      break;
    case 5:
      result = 7;
      break;
    case 6:
    case 7:
      result = 6;
      break;
    case 14:
    case 17:
      result = 5;
      break;
    case 15:
    case 18:
      result = 4;
      break;
    default:
      result = 0;
      break;
  }
  return result;
}

id ARMeshAnchorFromMesh(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, char a6, float32x4_t a7, float32x4_t a8, float32x4_t a9, float32x4_t a10, double a11)
{
  return ARMeshAnchorFromMeshNoCopy(a1, a2, a3, a4, a5, 0, 1, 1, a7, a8, a9, a10, a11, a6, 0);
}

id ARMeshAnchorFromMeshNoCopy(void *a1, uint64_t a2, void *a3, void *a4, uint64_t a5, int a6, int a7, int a8, float32x4_t a9, float32x4_t a10, float32x4_t a11, float32x4_t a12, double a13, char a14, char a15)
{
  id v23;
  id v24;
  uint64_t v25;
  id v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  uint64_t v31;
  __int128 v32;
  __int128 v33;
  __int128 v34;
  __int128 v35;
  void *v36;
  ARMeshAnchor *v37;
  ARMeshAnchor *v38;
  double v39;
  double v40;
  double v41;
  double v42;
  uint64_t v43;
  void *v44;
  double v46;
  double v47;
  double v48;
  double v49;
  _OWORD v54[4];
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;

  v23 = a1;
  v24 = a3;
  v26 = a4;
  v27 = a9.i64[0];
  v28 = a10.i64[0];
  v29 = a11.i64[0];
  v30 = a12.i64[0];
  if (a15)
  {
    CV3DReconMeshGetLocalToWorldTransform();
    v25 = 0;
    v31 = 0;
    v54[0] = v32;
    v54[1] = v33;
    v54[2] = v34;
    v54[3] = v35;
    v55 = 0u;
    v56 = 0u;
    v57 = 0u;
    v58 = 0u;
    do
    {
      *(__int128 *)((char *)&v55 + v31 * 16) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a9, COERCE_FLOAT(v54[v31])), a10, *(float32x2_t *)&v54[v31], 1), a11, (float32x4_t)v54[v31], 2), a12, (float32x4_t)v54[v31], 3);
      ++v31;
    }
    while (v31 != 4);
    v27 = v55;
    v28 = v56;
    v29 = v57;
    v30 = v58;
  }
  v46 = *(double *)&v30;
  v47 = *(double *)&v29;
  v48 = *(double *)&v28;
  v49 = *(double *)&v27;
  ARMeshGeometryFromMeshNoCopy(v23, a2, v25, a5, a6, a8);
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  if (v36)
  {
    v37 = [ARMeshAnchor alloc];
    v38 = v37;
    if (v26)
    {
      if (a7)
      {
        objc_msgSend(v26, "visionTransform");
        v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:visionTransform:referenceOriginTransform:](v38, "initWithGeometry:atTimestamp:identifier:visionTransform:referenceOriginTransform:", v36, v24, a13, v39, v40, v41, v42, *(_OWORD *)&a9, *(_OWORD *)&a10, *(_OWORD *)&a11, *(_OWORD *)&a12);
LABEL_13:
        v44 = (void *)v43;
        goto LABEL_14;
      }
    }
    else if (a7)
    {
      v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:referenceOriginTransform:](v37, "initWithGeometry:atTimestamp:identifier:referenceOriginTransform:", v36, v24, a13, *(double *)a9.i64, *(double *)a10.i64, *(double *)a11.i64, *(double *)a12.i64);
      goto LABEL_13;
    }
    v43 = -[ARMeshAnchor initWithGeometry:atTimestamp:identifier:transform:](v37, "initWithGeometry:atTimestamp:identifier:transform:", v36, v24, a13, v49, v48, v47, v46);
    goto LABEL_13;
  }
  v44 = 0;
LABEL_14:

  return v44;
}

ARMeshGeometry *ARMeshGeometryFromMeshNoCopy(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6)
{
  id v9;
  uint64_t VerticesCount;
  uint64_t v11;
  void *v12;
  uint64_t VerticesRawPtr;
  ARGeometrySource *v14;
  ARGeometrySource *v15;
  void *v16;
  ARMeshGeometry *v17;
  uint64_t VertexNormalsRawPtr;
  uint64_t FacesCount;
  uint64_t v20;
  ARGeometryElement *v22;
  ARGeometrySource *v23;
  id v24;
  uint64_t FaceSemanticLabelsRawPtr;
  _BYTE *v26;
  uint64_t v27;
  ARGeometrySource *v28;
  ARGeometryElement *v29;
  void *v30;
  void *v31;
  ARMeshGeometry *v32;

  v9 = a1;
  VerticesCount = CV3DReconMeshGetVerticesCount();
  if (VerticesCount)
  {
    v11 = VerticesCount;
    if (a5)
    {
      CV3DReconMeshGetVerticesAsMTLBufferForDevice();
      v12 = (void *)objc_claimAutoreleasedReturnValue();
      goto LABEL_6;
    }
    VerticesRawPtr = CV3DReconMeshGetVerticesRawPtr();
    if (VerticesRawPtr)
    {
      v12 = (void *)objc_msgSend(v9, "newBufferWithBytes:length:options:", VerticesRawPtr, 12 * v11, 0);
LABEL_6:
      v14 = -[ARGeometrySource initWithBuffer:count:format:componentsPerVector:offset:stride:]([ARGeometrySource alloc], "initWithBuffer:count:format:componentsPerVector:offset:stride:", v12, v11, 30, 3, 0, 12);
      v15 = 0;
      if (a6)
      {
        if (a5)
        {
          CV3DReconMeshGetVertexNormalsAsMTLBufferForDevice();
          v16 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          VertexNormalsRawPtr = CV3DReconMeshGetVertexNormalsRawPtr();
          if (!VertexNormalsRawPtr)
          {
            __ARMeshGeometryFromMeshNoCopy_block_invoke(0, CFSTR("Error getting normals raw pointer"), 0);
            v15 = 0;
            goto LABEL_17;
          }
          v16 = (void *)objc_msgSend(v9, "newBufferWithBytes:length:options:", VertexNormalsRawPtr, 12 * v11, 0);
        }
        v15 = -[ARGeometrySource initWithBuffer:count:format:componentsPerVector:offset:stride:]([ARGeometrySource alloc], "initWithBuffer:count:format:componentsPerVector:offset:stride:", v16, v11, 30, 3, 0, 12);

      }
      FacesCount = CV3DReconMeshGetFacesCount();
      if (FacesCount)
      {
        CV3DReconMeshGetFacesAsMTLBufferForDevice();
        v20 = objc_claimAutoreleasedReturnValue();
        v31 = (void *)v20;
        v22 = -[ARGeometryElement initWithBuffer:count:bytesPerIndex:primitiveType:]([ARGeometryElement alloc], "initWithBuffer:count:bytesPerIndex:primitiveType:", v20, FacesCount, 4, 1);
        v32 = -[ARMeshGeometry initWithVertices:normals:faces:]([ARMeshGeometry alloc], "initWithVertices:normals:faces:", v14, v15, v22);
        if ((~a4 & 0x11) == 0 || (a4 & 0x80) != 0)
        {
          CV3DReconMeshGetVertexColorsAsMTLBufferForDevice();
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          v23 = -[ARGeometrySource initWithBuffer:count:format:componentsPerVector:offset:stride:]([ARGeometrySource alloc], "initWithBuffer:count:format:componentsPerVector:offset:stride:", v30, v11, 30, 3, 0, 12);
          -[ARMeshGeometry setColors:](v32, "setColors:", v23);

        }
        if ((~(_BYTE)a4 & 3) == 0)
        {
          if (a5)
          {
            CV3DReconMeshGetFaceSemanticLabelsAsMTLBufferForDevice();
            v24 = (id)objc_claimAutoreleasedReturnValue();
          }
          else
          {
            FaceSemanticLabelsRawPtr = CV3DReconMeshGetFaceSemanticLabelsRawPtr();
            if (!FaceSemanticLabelsRawPtr)
            {
              v29 = v22;
              __ARMeshGeometryFromMeshNoCopy_block_invoke(0, CFSTR("Error getting semantic labels raw pointer"), 0);
              v17 = 0;
              goto LABEL_32;
            }
            v24 = objc_retainAutorelease((id)objc_msgSend(v9, "newBufferWithBytes:length:options:", FaceSemanticLabelsRawPtr, FacesCount, 0));
            v26 = (_BYTE *)objc_msgSend(v24, "contents");
            v27 = FacesCount;
            do
            {
              *v26 = ARMeshClassificationFromSemantic(*v26);
              ++v26;
              --v27;
            }
            while (v27);
          }
          v28 = -[ARGeometrySource initWithBuffer:count:format:componentsPerVector:offset:stride:]([ARGeometrySource alloc], "initWithBuffer:count:format:componentsPerVector:offset:stride:", v24, FacesCount, 45, 1, 0, 1);
          -[ARMeshGeometry setClassification:](v32, "setClassification:", v28);

        }
        v29 = v22;
        v17 = v32;
LABEL_32:

        goto LABEL_18;
      }
LABEL_17:
      v17 = 0;
LABEL_18:

      goto LABEL_19;
    }
    __ARMeshGeometryFromMeshNoCopy_block_invoke(0, CFSTR("Error getting vertices raw pointer"), 0);
  }
  v17 = 0;
LABEL_19:

  return v17;
}

id _ARLogGeneral_8()
{
  if (_ARLogGeneral_onceToken_10 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_10, &__block_literal_global_24);
  return (id)_ARLogGeneral_logObj_10;
}

const __CFString *NSStringFromAREnvironmentTexturing(unint64_t a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_1E66737C8[a1];
}

const __CFString *NSStringFromARPlaneDetection(char a1)
{
  const __CFString *v1;

  v1 = CFSTR("Vertical");
  if ((a1 & 2) == 0)
    v1 = CFSTR("None");
  if ((a1 & 1) != 0)
    v1 = CFSTR("Horizontal");
  if ((~a1 & 3) != 0)
    return v1;
  else
    return CFSTR("Horizontal|Vertical");
}

const __CFString *NSStringFromARWorldAlignment(unint64_t a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_1E66737E0[a1];
}

id NSStringFromARFrameSemantics(uint64_t a1)
{
  void *v2;
  void *v3;
  const __CFString *v4;
  const __CFString *v5;
  void *v6;

  v2 = (void *)objc_opt_new();
  v3 = v2;
  if (!a1)
  {
    v5 = CFSTR("None");
LABEL_15:
    objc_msgSend(v3, "addObject:", v5);
    goto LABEL_16;
  }
  if ((~(_DWORD)a1 & 3) != 0)
  {
    if ((a1 & 1) == 0)
    {
      if ((a1 & 4) != 0)
        goto LABEL_12;
LABEL_7:
      if ((a1 & 8) != 0)
        goto LABEL_13;
      goto LABEL_8;
    }
    v4 = CFSTR("Person Segmentation");
  }
  else
  {
    v4 = CFSTR("Person Segmentation with Depth");
  }
  objc_msgSend(v2, "addObject:", v4);
  if ((a1 & 4) == 0)
    goto LABEL_7;
LABEL_12:
  objc_msgSend(v3, "addObject:", CFSTR("Body Detection"));
  if ((a1 & 8) != 0)
  {
LABEL_13:
    objc_msgSend(v3, "addObject:", CFSTR("Scene Depth"));
    if ((a1 & 0x10) == 0)
      goto LABEL_16;
    goto LABEL_14;
  }
LABEL_8:
  if ((a1 & 0x10) != 0)
  {
LABEL_14:
    v5 = CFSTR("Smoothed Scene Depth");
    goto LABEL_15;
  }
LABEL_16:
  if (!objc_msgSend(v3, "count"))
    objc_msgSend(v3, "addObject:", CFSTR("Unknown"));
  objc_msgSend(v3, "componentsJoinedByString:", CFSTR("|"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

__CFString *NSStringFromARSceneReconstruction(uint64_t a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __CFString *v6;

  v2 = (void *)objc_opt_new();
  v3 = v2;
  if (a1)
  {
    if ((a1 & 1) != 0)
      objc_msgSend(v2, "addObject:", CFSTR("Mesh"));
    if ((~(_DWORD)a1 & 3) == 0)
      objc_msgSend(v3, "addObject:", CFSTR("with classification"));
    if ((~(_DWORD)a1 & 0x11) == 0)
      objc_msgSend(v3, "addObject:", CFSTR("with color"));
    if ((a1 & 8) != 0)
      objc_msgSend(v3, "addObject:", CFSTR("Keyframe"));
    if ((~(_DWORD)a1 & 0x18) == 0)
      objc_msgSend(v3, "addObject:", CFSTR("with color"));
    if ((a1 & 0x80) != 0)
      objc_msgSend(v3, "addObject:", CFSTR("ObjectCapture"));
    if (objc_msgSend(v3, "count"))
    {
      v4 = (void *)MEMORY[0x1E0CB3940];
      objc_msgSend(v3, "componentsJoinedByString:", CFSTR(" "));
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v4, "stringWithFormat:", CFSTR("(%@)"), v5);
      v6 = (__CFString *)objc_claimAutoreleasedReturnValue();

    }
    else
    {
      v6 = CFSTR("Unknown");
    }
  }
  else
  {
    v6 = CFSTR("None");
  }

  return v6;
}

void sub_1B3AB7700(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, __int128 buf, int a12, __int16 a13, __int16 a14, void *a15)
{
  id v15;
  NSObject *v16;
  objc_class *v17;
  id v18;
  void *v19;

  if (a2 == 1)
  {
    v15 = objc_begin_catch(a1);
    _ARLogGeneral_9();
    v16 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
    {
      v17 = (objc_class *)objc_opt_class();
      NSStringFromClass(v17);
      v18 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "reason");
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138543874;
      *(_QWORD *)((char *)&buf + 4) = v18;
      WORD6(buf) = 2048;
      a14 = 2112;
      a15 = v19;
      _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: Unable to decode jasper framerate values: %@", (uint8_t *)&buf, 0x20u);

    }
    objc_end_catch();
    JUMPOUT(0x1B3AB7614);
  }
  _Unwind_Resume(a1);
}

id _ARLogGeneral_9()
{
  if (_ARLogGeneral_onceToken_11 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_11, &__block_literal_global_434);
  return (id)_ARLogGeneral_logObj_11;
}

void sub_1B3AB7DAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void ARAddScalingTechniquesToTechniques(void *a1, uint64_t a2, uint64_t a3, double a4, double a5, double a6, double a7)
{
  id v13;
  ARMLImageDownScalingTechnique *v14;
  ARMLImageDownScalingTechnique *v15;
  ARParentTechnique *v16;
  void *v17;
  ARParentTechnique *v18;
  ARParentTechnique *v19;
  void *v20;
  ARParentTechnique *v21;
  ARMLImageDownScalingTechnique *v22;
  _QWORD v23[2];

  v23[1] = *MEMORY[0x1E0C80C00];
  v13 = a1;
  v14 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", a4, a5, a6);
  -[ARMLImageDownScalingTechnique setSaveIntermediateScaleResultData:](v14, "setSaveIntermediateScaleResultData:", a2);
  -[ARMLImageDownScalingTechnique setCenterCropImage:](v14, "setCenterCropImage:", a3);
  v15 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", a4, a5, a7);
  -[ARMLImageDownScalingTechnique setSaveIntermediateScaleResultData:](v15, "setSaveIntermediateScaleResultData:", a2);
  -[ARMLImageDownScalingTechnique setCenterCropImage:](v15, "setCenterCropImage:", a3);
  -[ARMLImageDownScalingTechnique setShouldOperateOnHighResolutionImages:](v15, "setShouldOperateOnHighResolutionImages:", 1);
  v16 = [ARParentTechnique alloc];
  v23[0] = v14;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v23, 1);
  v17 = (void *)objc_claimAutoreleasedReturnValue();
  v18 = -[ARParentTechnique initWithParallelTechniques:](v16, "initWithParallelTechniques:", v17);

  v19 = [ARParentTechnique alloc];
  v22 = v15;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v22, 1);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v21 = -[ARParentTechnique initWithParallelTechniques:](v19, "initWithParallelTechniques:", v20);

  objc_msgSend(v13, "addObject:", v18);
  objc_msgSend(v13, "addObject:", v21);

}

void ARAddNonJasperSemanticsToParent(void *a1, void *a2, uint64_t a3, uint64_t a4)
{
  void *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  void *v10;
  ARMLImageDownScalingTechnique *v11;
  ARParentTechnique *v12;
  void *v13;
  ARParentTechnique *v14;
  ARImageDistortionCorrectionTechnique *v15;
  ARParentTechnique *v16;
  id v17;
  void *v18;
  ARParentTechnique *v19;
  ARSplitTechniqueSynchronizerTechnique *v20;
  ARParentTechnique *v21;
  void *v22;
  ARSyncedUltraWideForwardingStrategy *v23;
  ARSyncedUltraWideForwardingStrategy *v24;
  id v26;
  id v27;
  void *v28;
  ARParentTechnique *v29;
  id v30;
  _QWORD v31[2];

  v31[1] = *MEMORY[0x1E0C80C00];
  v27 = a1;
  v6 = (void *)MEMORY[0x1E0C99E20];
  v26 = a2;
  v7 = objc_opt_class();
  v8 = objc_opt_class();
  v9 = objc_opt_class();
  objc_msgSend(v6, "setWithObjects:", v7, v8, v9, objc_opt_class(), 0);
  v28 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v11 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", 256.0, 192.0, 0.002);
  -[ARMLImageDownScalingTechnique setResizeUltraWideImage:](v11, "setResizeUltraWideImage:", ARDeviceSupportsUltraWideCamera());
  -[ARMLImageDownScalingTechnique setWideRotationStrategy:](v11, "setWideRotationStrategy:", &__block_literal_global_30);
  -[ARMLImageDownScalingTechnique setUltrawideRotationStrategy:](v11, "setUltrawideRotationStrategy:", &__block_literal_global_30);
  v12 = [ARParentTechnique alloc];
  v31[0] = v11;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v31, 1);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v14 = -[ARParentTechnique initWithParallelTechniques:](v12, "initWithParallelTechniques:", v13);

  objc_msgSend(v10, "addObject:", v14);
  if (ARDeviceSupportsUltraWideCamera())
  {
    v15 = -[ARImageDistortionCorrectionTechnique initWithImageSize:]([ARImageDistortionCorrectionTechnique alloc], "initWithImageSize:", 256.0, 192.0);
    objc_msgSend(v10, "addObject:", v15);

  }
  v16 = [ARParentTechnique alloc];
  v17 = -[ARSISemanticSegmentationTechnique initLegacyAlgorithmUsingSynchronizedUltrawideWhenAvailable:]([ARSISemanticSegmentationTechnique alloc], "initLegacyAlgorithmUsingSynchronizedUltrawideWhenAvailable:", a4);
  v30 = v17;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v30, 1);
  v18 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = -[ARParentTechnique initWithParallelTechniques:](v16, "initWithParallelTechniques:", v18);

  objc_msgSend(v10, "addObject:", v19);
  v20 = -[ARSplitTechniqueSynchronizerTechnique initWithSynchronizedResultDataClasses:]([ARSplitTechniqueSynchronizerTechnique alloc], "initWithSynchronizedResultDataClasses:", v28);
  v21 = -[ARParentTechnique initWithTechniques:delegate:]([ARParentTechnique alloc], "initWithTechniques:delegate:", v10, v20);
  v29 = v21;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v29, 1);
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v27, "setSplitTechniques:", v22);

  if (ARDeviceSupportsUltraWideCamera() && (_DWORD)a4)
    v23 = -[ARSyncedUltraWideForwardingStrategy initWithMaxFrameRate:]([ARSyncedUltraWideForwardingStrategy alloc], "initWithMaxFrameRate:", a3);
  else
    v23 = -[ARFrameRateLimitingStrategy initWithFrameRate:]([ARFrameRateLimitingStrategy alloc], "initWithFrameRate:", 10);
  v24 = v23;
  objc_msgSend(v27, "setSplitTechniqueFowardingStrategy:", v23);

  objc_msgSend(v26, "insertObject:atIndex:", v20, 0);
}

void ARAddJasperTechniquesToParent(void *a1, void *a2, int a3, unsigned int a4, uint64_t a5)
{
  id v6;
  id v7;
  void *v8;
  void *v9;
  void *v10;
  uint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  ARMLImageDownScalingTechnique *v19;
  ARParentTechnique *v20;
  void *v21;
  ARParentTechnique *v22;
  ARDepthTechnique *v23;
  ARParentTechnique *v24;
  void *v25;
  ARParentTechnique *v26;
  ARImageDistortionCorrectionTechnique *v27;
  ARParentTechnique *v28;
  void *v29;
  void *v30;
  ARParentTechnique *v31;
  void *v32;
  void *v33;
  id v34;
  ARParentTechnique *v35;
  ARParentTechnique *v36;
  id v37;
  void *v38;
  void *v39;
  ARSyncedUltraWideForwardingStrategy *v40;
  ARSyncedUltraWideForwardingStrategy *v41;
  ARSplitTechniqueSynchronizerTechnique *v42;
  id v43;
  int v44;
  void *v45;
  void *v46;
  ARSyncedUltraWideForwardingStrategy *v47;
  ARSyncedUltraWideForwardingStrategy *v48;
  void *v49;
  void *v50;
  ARSyncedUltraWideForwardingStrategy *v51;
  ARSyncedUltraWideForwardingStrategy *v52;
  id v53;
  void *v57;
  ARDepthTechnique *v58;
  _QWORD v59[2];

  v59[1] = *MEMORY[0x1E0C80C00];
  v6 = a1;
  v7 = a2;
  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  +[ARParentTechnique parentTechniqueOfClass:inArray:](ARParentTechnique, "parentTechniqueOfClass:inArray:", objc_opt_class(), v7);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  if (v9)
  {
    v10 = (void *)MEMORY[0x1E0C99E20];
    v11 = objc_opt_class();
    objc_msgSend(v10, "setWithObjects:", v11, objc_opt_class(), 0);
    v12 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v12 = 0;
  }
  if (a3)
  {
    v53 = v6;
    v13 = (void *)MEMORY[0x1E0C99E20];
    v14 = objc_opt_class();
    v15 = objc_opt_class();
    v16 = objc_opt_class();
    v17 = objc_opt_class();
    objc_msgSend(v13, "setWithObjects:", v14, v15, v16, v17, objc_opt_class(), 0);
    v18 = objc_claimAutoreleasedReturnValue();

    objc_msgSend(v8, "removeAllObjects");
    if (v9)
    {
      +[ARTechnique techniqueOfClass:inArray:](ARTechnique, "techniqueOfClass:inArray:", objc_opt_class(), v7);
      v19 = (ARMLImageDownScalingTechnique *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v19 = -[ARMLImageDownScalingTechnique initWithSize:requiredTimeInterval:]([ARMLImageDownScalingTechnique alloc], "initWithSize:requiredTimeInterval:", 256.0, 192.0, 0.002);
      v20 = [ARParentTechnique alloc];
      v59[0] = v19;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v59, 1);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      v22 = -[ARParentTechnique initWithParallelTechniques:](v20, "initWithParallelTechniques:", v21);

      objc_msgSend(v8, "addObject:", v22);
      v23 = -[ARDepthTechnique initWithPrioritization:temporalSmoothing:]([ARDepthTechnique alloc], "initWithPrioritization:temporalSmoothing:", 1, a4);
      v24 = [ARParentTechnique alloc];
      v58 = v23;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v58, 1);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      v26 = -[ARParentTechnique initWithParallelTechniques:](v24, "initWithParallelTechniques:", v25);

      objc_msgSend(v8, "addObject:", v26);
    }
    v6 = v53;
    if (ARDeviceSupportsUltraWideCamera())
    {
      v27 = -[ARImageDistortionCorrectionTechnique initWithImageSize:]([ARImageDistortionCorrectionTechnique alloc], "initWithImageSize:", 256.0, 192.0);
      objc_msgSend(v8, "addObject:", v27);
      -[ARMLImageDownScalingTechnique setResizeUltraWideImage:](v19, "setResizeUltraWideImage:", 1);
      -[ARMLImageDownScalingTechnique setUltrawideRotationStrategy:](v19, "setUltrawideRotationStrategy:", &__block_literal_global_428);

    }
    v28 = [ARParentTechnique alloc];
    v29 = (void *)objc_opt_new();
    v57 = v29;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v57, 1);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    v31 = -[ARParentTechnique initWithParallelTechniques:](v28, "initWithParallelTechniques:", v30);

    objc_msgSend(v8, "addObject:", v31);
    v32 = (void *)objc_opt_new();
    objc_msgSend(v8, "addObject:", v32);

    v12 = (void *)v18;
  }
  if (v12)
  {
    if (v9)
      v33 = v9;
    else
      v33 = v6;
    v34 = v33;
    if (objc_msgSend(v8, "count"))
      v35 = -[ARParentTechnique initWithTechniques:]([ARParentTechnique alloc], "initWithTechniques:", v8);
    else
      v35 = (ARParentTechnique *)objc_opt_new();
    v36 = v35;
    v37 = v6;
    objc_msgSend(v34, "splitTechniques");
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v38, "arrayByAddingObject:", v36);
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v34, "setSplitTechniques:", v39);

    if (ARDeviceSupportsUltraWideCamera())
      v40 = -[ARSyncedUltraWideForwardingStrategy initWithMaxFrameRate:]([ARSyncedUltraWideForwardingStrategy alloc], "initWithMaxFrameRate:", a5);
    else
      v40 = -[ARFrameRateLimitingStrategy initWithFrameRate:]([ARFrameRateLimitingStrategy alloc], "initWithFrameRate:", 10);
    v41 = v40;
    objc_msgSend(v34, "setSplitTechniqueFowardingStrategy:", v40);

    v42 = -[ARSplitTechniqueSynchronizerTechnique initWithSynchronizedResultDataClasses:]([ARSplitTechniqueSynchronizerTechnique alloc], "initWithSynchronizedResultDataClasses:", v12);
    -[ARTechnique setDelegate:](v36, "setDelegate:", v42);
    objc_msgSend(v7, "insertObject:atIndex:", v42, 0);

    v6 = v37;
  }
  if (a3)
  {
    objc_opt_class();
    if ((objc_opt_isKindOfClass() & 1) != 0)
    {
      v43 = v9;
      v44 = ARDeviceSupportsUltraWideCamera();
      objc_msgSend(v43, "splitTechniqueFowardingStrategy");
      v45 = (void *)objc_claimAutoreleasedReturnValue();
      v46 = v45;
      if (v44)
      {
        if (!v45)
        {
          v47 = -[ARSyncedUltraWideForwardingStrategy initWithMaxFrameRate:]([ARSyncedUltraWideForwardingStrategy alloc], "initWithMaxFrameRate:", a5);
LABEL_30:
          v48 = v47;

          objc_msgSend(v43, "setDepthTechniqueProcessingStrategy:", v48);
          objc_msgSend(v43, "splitTechniqueFowardingStrategy");
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          v50 = v49;
          if (v49)
            v51 = v49;
          else
            v51 = -[ARSyncedUltraWideForwardingStrategy initWithMaxFrameRate:]([ARSyncedUltraWideForwardingStrategy alloc], "initWithMaxFrameRate:", a5);
          v52 = v51;

          objc_msgSend(v43, "setDepthTechniqueProcessingStrategy:", v52);
          goto LABEL_34;
        }
      }
      else if (!v45)
      {
        v47 = -[ARFrameRateLimitingStrategy initWithFrameRate:]([ARFrameRateLimitingStrategy alloc], "initWithFrameRate:", 10);
        goto LABEL_30;
      }
      v47 = v45;
      goto LABEL_30;
    }
  }
LABEL_34:

}

id _ARLogGeneral_10()
{
  if (_ARLogGeneral_onceToken_12 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_12, &__block_literal_global_184);
  return (id)_ARLogGeneral_logObj_12;
}

id _ARLogSensor_2()
{
  if (_ARLogSensor_onceToken_5 != -1)
    dispatch_once(&_ARLogSensor_onceToken_5, &__block_literal_global_187_0);
  return (id)_ARLogSensor_logObj_5;
}

id _ARLogTechnique_2()
{
  if (_ARLogTechnique_onceToken_4 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_4, &__block_literal_global_258);
  return (id)_ARLogTechnique_logObj_4;
}

void sub_1B3ABF624(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 72));
  _Unwind_Resume(a1);
}

void arkit::computeBoundingBoxes(uint64_t a1, void *a2, char **a3, uint64_t *a4, uint64x2_t *a5)
{
  id v9;
  unint64_t v10;
  unint64_t v11;
  void *v12;
  void *v13;
  uint64_t v14;
  double v15;
  uint64_t v16;
  double v17;
  uint64_t i;
  double v19;
  double v20;
  int8x16_t v21;
  double v22;
  double v23;
  unint64_t v24;
  int8x16_t v25;
  unint64_t v26;
  int8x16_t *v27;
  int8x16_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t v34;
  int8x16_t *v35;
  char *v36;
  char *v37;
  int8x16_t *v38;
  int8x16_t v39;
  int8x16_t v40;
  int8x16_t v41;
  uint64x2_t *v42;
  char *v43;
  uint64_t v44;
  uint64_t v45;
  uint64x2_t *v46;
  uint64x2_t *v47;
  int64x2_t v48;
  int8x16_t v49;
  char *v50;
  uint64x2_t *v51;
  uint64x2_t v52;
  int64x2_t v53;
  uint64x2_t *v54;
  int64x2_t v55;
  uint64x2_t *v56;
  uint64x2_t v57;
  uint64x2_t v58;
  uint64x2_t *v59;
  int64x2_t v60;
  int8x16_t v61;
  uint64x2_t *j;
  int64x2_t v63;
  uint64x2_t v64;
  int8x16_t v65;
  uint64_t *v66;
  id v67;
  int8x16_t v68;
  int8x16_t v69;
  void *__p;
  void *v71;
  uint64_t v72;
  int8x16_t v73;
  int8x16_t v74;
  __int128 v75;
  __int128 v76;
  __int128 v77;
  __int128 v78;
  _BYTE v79[128];
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v9 = a2;
  v11 = *(_QWORD *)(a1 + 8);
  v10 = *(_QWORD *)(a1 + 16);
  v67 = v9;
  objc_msgSend(v9, "detectedObjects");
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  std::vector<arkit::IntRect>::reserve((void **)a3, objc_msgSend(v12, "count"));

  v77 = 0u;
  v78 = 0u;
  v75 = 0u;
  v76 = 0u;
  objc_msgSend(v67, "detectedObjects");
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v66 = a4;
  v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v75, v79, 16);
  if (v14)
  {
    v15 = (double)v10;
    v16 = *(_QWORD *)v76;
    v17 = (double)v11;
    do
    {
      for (i = 0; i != v14; ++i)
      {
        if (*(_QWORD *)v76 != v16)
          objc_enumerationMutation(v13);
        objc_msgSend(*(id *)(*((_QWORD *)&v75 + 1) + 8 * i), "boundingBox");
        v21.i64[0] = vcvtpd_u64_f64(v19 * v15);
        v21.i64[1] = vcvtpd_u64_f64(v20 * v17);
        v24 = vcvtpd_u64_f64((v20 + v23) * v17);
        v25.i64[0] = vcvtpd_u64_f64((v19 + v22) * v15);
        v25.i64[1] = v24;
        v27 = (int8x16_t *)a3[1];
        v26 = (unint64_t)a3[2];
        if ((unint64_t)v27 >= v26)
        {
          v29 = ((char *)v27 - *a3) >> 5;
          v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 59)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v68 = v25;
          v69 = v21;
          v31 = v26 - (_QWORD)*a3;
          if (v31 >> 4 > v30)
            v30 = v31 >> 4;
          if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFE0)
            v32 = 0x7FFFFFFFFFFFFFFLL;
          else
            v32 = v30;
          v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>((uint64_t)(a3 + 2), v32);
          v35 = (int8x16_t *)&v33[32 * v29];
          v25 = v68;
          v21 = v69;
          *v35 = v69;
          v35[1] = v68;
          v37 = *a3;
          v36 = a3[1];
          v38 = v35;
          if (v36 != *a3)
          {
            do
            {
              v39 = *((int8x16_t *)v36 - 1);
              v38[-2] = *((int8x16_t *)v36 - 2);
              v38[-1] = v39;
              v38 -= 2;
              v36 -= 32;
            }
            while (v36 != v37);
            v36 = *a3;
          }
          v28 = v35 + 2;
          *a3 = (char *)v38;
          a3[1] = v35[2].i8;
          a3[2] = &v33[32 * v34];
          if (v36)
          {
            operator delete(v36);
            v25 = v68;
            v21 = v69;
          }
        }
        else
        {
          *v27 = v21;
          v27[1] = v25;
          v28 = v27 + 2;
        }
        a3[1] = (char *)v28;
        v40 = vbslq_s8((int8x16_t)vcgtq_u64(a5[1], (uint64x2_t)v25), (int8x16_t)a5[1], v25);
        *(int8x16_t *)a5 = vbslq_s8((int8x16_t)vcgtq_u64(*a5, (uint64x2_t)v21), v21, *(int8x16_t *)a5);
        a5[1] = (uint64x2_t)v40;
      }
      v14 = objc_msgSend(v13, "countByEnumeratingWithState:objects:count:", &v75, v79, 16);
    }
    while (v14);
  }

  std::vector<arkit::BoundingBoxGroup>::reserve(v66, (unint64_t)((a3[1] - *a3) >> 5) >> 1);
  __p = 0;
  v71 = 0;
  v72 = 0;
  v41.i64[0] = -1;
  v41.i64[1] = -1;
  v73 = v41;
  v74 = 0uLL;
  std::vector<arkit::BoundingBoxGroup::Element>::reserve(&__p, (a3[1] - *a3) >> 5);
  v42 = (uint64x2_t *)*a3;
  v43 = a3[1];
  if (*a3 != v43)
  {
    do
    {
      v45 = *v66;
      v44 = v66[1];
      if (*v66 != v44)
      {
        while (1)
        {
          v46 = *(uint64x2_t **)v45;
          v47 = *(uint64x2_t **)(v45 + 8);
          if (*(uint64x2_t **)v45 != v47)
            break;
LABEL_26:
          v45 += 64;
          if (v45 == v44)
            goto LABEL_30;
        }
        while (1)
        {
          v48 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v42, v46[1]), (int8x16_t)vcgtq_u64(*v42, *v46)), vandq_s8((int8x16_t)vcgeq_u64(*v46, v42[1]), (int8x16_t)vcgtq_u64(*v46, *v42)));
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v48, 1), (int8x16_t)v48).u64[0] & 0x8000000000000000) == 0)
            break;
          v46 += 7;
          if (v46 == v47)
            goto LABEL_26;
        }
      }
      if (v45 == v44)
      {
LABEL_30:
        if (&v42[2] == (uint64x2_t *)v43)
          goto LABEL_50;
        v51 = v42 + 2;
        while (1)
        {
          v52 = v51[1];
          v53 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v42, v52), (int8x16_t)vcgtq_u64(*v42, *v51)), vandq_s8((int8x16_t)vcgeq_u64(*v51, v42[1]), (int8x16_t)vcgtq_u64(*v51, *v42)));
          if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v53, 1), (int8x16_t)v53).u64[0] & 0x8000000000000000) == 0)
            break;
          v54 = (uint64x2_t *)__p;
          if (__p != v71)
          {
            do
            {
              v55 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(*v51, v54[1]), (int8x16_t)vcgtq_u64(*v51, *v54)), vandq_s8((int8x16_t)vcgeq_u64(*v54, v52), (int8x16_t)vcgtq_u64(*v54, *v51)));
              if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v55, 1), (int8x16_t)v55).u64[0] & 0x8000000000000000) == 0)
                goto LABEL_38;
              v54 += 7;
            }
            while (v54 != v71);
          }
          v51 += 2;
          if (v51 == (uint64x2_t *)v43)
            goto LABEL_50;
        }
LABEL_38:
        std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v51);
        v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v51), *(int8x16_t *)v51, v73);
        v74 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v51[1]), v74, (int8x16_t)v51[1]);
        if (v51 == (uint64x2_t *)v43)
        {
LABEL_50:
          v50 = v43;
        }
        else
        {
          v56 = v51 + 2;
          if (&v51[2] == (uint64x2_t *)v43)
          {
            v50 = (char *)v51;
          }
          else
          {
            v50 = (char *)v51;
            do
            {
              v57 = v51[2];
              v58 = v51[3];
              v59 = v56;
              v60 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(v57, v42[1]), (int8x16_t)vcgtq_u64(v57, *v42)), vandq_s8((int8x16_t)vcgeq_u64(*v42, v58), (int8x16_t)vcgtq_u64(*v42, v57)));
              if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v60, 1), (int8x16_t)v60).u64[0] & 0x8000000000000000) != 0)
              {
                for (j = (uint64x2_t *)__p; j != v71; j += 7)
                {
                  v63 = (int64x2_t)vorrq_s8(vandq_s8((int8x16_t)vcgeq_u64(v57, j[1]), (int8x16_t)vcgtq_u64(v57, *j)), vandq_s8((int8x16_t)vcgeq_u64(*j, v58), (int8x16_t)vcgtq_u64(*j, v57)));
                  if ((vorrq_s8((int8x16_t)vdupq_laneq_s64(v63, 1), (int8x16_t)v63).u64[0] & 0x8000000000000000) == 0)
                    goto LABEL_42;
                }
                v64 = v59[1];
                *(uint64x2_t *)v50 = *v59;
                *((uint64x2_t *)v50 + 1) = v64;
                v50 += 32;
              }
              else
              {
LABEL_42:
                std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v59);
                v61 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v51[3]), v74, (int8x16_t)v51[3]);
                v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v59), *(int8x16_t *)v59, v73);
                v74 = v61;
              }
              v56 = v59 + 2;
              v51 = v59;
            }
            while (&v59[2] != (uint64x2_t *)v43);
          }
        }
        if (v71 == __p)
        {
          v42 += 2;
        }
        else
        {
          std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(&__p, v42);
          v73 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v73, *v42), *(int8x16_t *)v42, v73);
          v74 = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v74, v42[1]), v74, (int8x16_t)v42[1]);
          v50 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(v42->i8, v42[2].i8, v50);
          std::vector<arkit::BoundingBoxGroup>::push_back[abi:ne180100](v66, (uint64_t)&__p);
          v71 = __p;
          v65.i64[0] = -1;
          v65.i64[1] = -1;
          v73 = v65;
          v74 = 0uLL;
        }
      }
      else
      {
        std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>((void **)v45, v42);
        v49 = *(int8x16_t *)(v45 + 48);
        *(int8x16_t *)(v45 + 32) = vbslq_s8((int8x16_t)vcgtq_u64(*(uint64x2_t *)(v45 + 32), *v42), *(int8x16_t *)v42, *(int8x16_t *)(v45 + 32));
        *(int8x16_t *)(v45 + 48) = vbslq_s8((int8x16_t)vcgtq_u64((uint64x2_t)v49, v42[1]), v49, (int8x16_t)v42[1]);
        v50 = std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(v42->i8, v42[2].i8, v43);
      }
      v43 = v50;
    }
    while (v42 != (uint64x2_t *)v50);
    if (v42 != (uint64x2_t *)a3[1])
      a3[1] = (char *)v42;
  }
  if (__p)
  {
    v71 = __p;
    operator delete(__p);
  }

}

void sub_1B3AC3400(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16)
{
  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void std::vector<arkit::IntRect>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFE0];
    v9 = &v6[32 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v13;
        v12 -= 32;
        v10 -= 32;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t std::vector<arkit::BoundingBoxGroup>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 6)
  {
    if (a2 >> 58)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + (v6 << 6);
    std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1B3AC3590(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void std::vector<arkit::BoundingBoxGroup::Element>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0x6DB6DB6DB6DB6DB7 * ((v4 - (_BYTE *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x24924924924924ALL)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 112;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(v3, a2);
    v7 = &v6[112 * v5];
    v9 = &v6[112 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_OWORD *)v10 - 7);
        v14 = *((_OWORD *)v10 - 5);
        *((_OWORD *)v12 - 6) = *((_OWORD *)v10 - 6);
        *((_OWORD *)v12 - 5) = v14;
        *((_OWORD *)v12 - 7) = v13;
        v15 = *((_OWORD *)v10 - 4);
        v16 = *((_OWORD *)v10 - 3);
        v17 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v17;
        *((_OWORD *)v12 - 4) = v15;
        *((_OWORD *)v12 - 3) = v16;
        v12 -= 112;
        v10 -= 112;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t std::vector<arkit::BoundingBoxGroup>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  __int128 v16;
  _QWORD v17[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 6;
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) >> 58)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v12 = v5 - *a1;
    if (v12 >> 5 > v11)
      v11 = v12 >> 5;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFC0)
      v13 = 0x3FFFFFFFFFFFFFFLL;
    else
      v13 = v11;
    v17[4] = result;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(result, v13);
    else
      v14 = 0;
    v15 = &v14[64 * v10];
    v17[0] = v14;
    v17[1] = v15;
    v17[3] = &v14[64 * v13];
    *(_QWORD *)v15 = 0;
    *((_QWORD *)v15 + 1) = 0;
    *((_QWORD *)v15 + 2) = 0;
    *(_OWORD *)v15 = *(_OWORD *)a2;
    *((_QWORD *)v15 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16 = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v15 + 2) = *(_OWORD *)(a2 + 32);
    *((_OWORD *)v15 + 3) = v16;
    v17[2] = v15 + 64;
    std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(a1, v17);
    v9 = a1[1];
    result = std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)v17);
  }
  else
  {
    *(_QWORD *)v7 = 0;
    *(_QWORD *)(v7 + 8) = 0;
    *(_QWORD *)(v7 + 16) = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    *(_QWORD *)(v7 + 16) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = *(_OWORD *)(a2 + 48);
    *(_OWORD *)(v7 + 32) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)(v7 + 48) = v8;
    v9 = v7 + 64;
    a1[1] = v7 + 64;
  }
  a1[1] = v9;
  return result;
}

void sub_1B3AC37C4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void sub_1B3AC3958(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AC39D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARPersonOcclusionTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3AC4450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1B3AC5520(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,void *__p,uint64_t a33)
{
  void *v33;
  uint64_t v34;

  *(_QWORD *)(v34 - 176) = &a29;
  std::vector<arkit::BoundingBoxGroup>::__destroy_vector::operator()[abi:ne180100]((void ***)(v34 - 176));
  if (__p)
  {
    a33 = (uint64_t)__p;
    operator delete(__p);
  }

  _Unwind_Resume(a1);
}

float *arkit::RobustExpFilter<float>::filter(uint64_t a1, float *a2, size_t a3)
{
  float *result;
  float *v6;
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  float v11;
  float v12;
  unint64_t v14;
  int v15;

  result = *(float **)a1;
  v6 = *(float **)(a1 + 8);
  v8 = v6 - result;
  if (v8 == a3 >> 2)
  {
    if (v6 == result)
    {
      return v6;
    }
    else
    {
      v9 = 0;
      v10 = *(_QWORD *)(a1 + 24);
      do
      {
        v11 = result[v9];
        v12 = (float)((float)(v11 + (float)(*(float *)(a1 + 72) * *(float *)(v10 + 4 * v9))) * 0.7)
            + (float)(a2[v9] * 0.3);
        result[v9] = v12;
        *(float *)(v10 + 4 * v9) = (float)((float)(1.0 - *(float *)(a1 + 88)) * *(float *)(v10 + 4 * v9))
                                 + (float)(*(float *)(a1 + 88) * (float)(v12 - v11));
        ++v9;
      }
      while (v8 > v9);
    }
  }
  else
  {
    v14 = a3 >> 2;
    std::vector<float>::resize(a1, a3 >> 2);
    memcpy(*(void **)a1, a2, a3);
    v15 = 0;
    std::vector<float>::resize(a1 + 24, v14, &v15);
    return *(float **)a1;
  }
  return result;
}

_QWORD *arkit::fillInstanceDepthBufferOutsideAllDetections(_QWORD *result, unsigned __int8 **a2, _QWORD *a3, uint64_t *a4)
{
  unint64_t v4;
  unint64_t v5;
  unsigned __int8 *v6;
  _DWORD *v7;
  uint64_t v8;
  _DWORD *v9;
  uint64_t v10;
  unsigned __int8 *v11;
  unsigned __int8 *v12;
  unsigned __int8 *v13;
  _DWORD *v14;
  _DWORD *v15;
  unsigned __int8 *v16;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned __int8 *v21;
  unsigned __int8 *v22;
  _DWORD *v23;
  _DWORD *v24;
  unsigned __int8 *v25;
  uint64_t v26;
  unsigned __int8 *v27;
  _DWORD *v28;
  _DWORD *v29;
  unint64_t v31;
  unsigned __int8 *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned __int8 *v35;
  unsigned __int8 *v36;
  _DWORD *v37;
  _QWORD *v38;
  unsigned __int8 *v39;
  unsigned __int8 *v40;
  _DWORD *v41;
  unsigned __int8 *v42;

  v4 = a4[1];
  if (v4)
  {
    v5 = 0;
    v6 = *a2;
    v7 = (_DWORD *)*result;
    v8 = result[3];
    v9 = (_DWORD *)*a3;
    v10 = a3[3];
    v12 = a2[2];
    v11 = a2[3];
    do
    {
      if (v12)
      {
        v13 = v6;
        v14 = v7;
        v15 = v9;
        v16 = v12;
        do
        {
          if (*v13++)
            *v15 = *v14;
          ++v15;
          ++v14;
          --v16;
        }
        while (v16);
        v4 = a4[1];
      }
      ++v5;
      v9 = (_DWORD *)((char *)v9 + v10);
      v7 = (_DWORD *)((char *)v7 + v8);
      v6 = &v11[(_QWORD)v6];
    }
    while (v4 > v5);
  }
  v18 = a4[3];
  if (v4 < v18)
  {
    v19 = result[3];
    v20 = a3[3];
    v22 = a2[2];
    v21 = a2[3];
    v23 = (_DWORD *)(*a3 + v4 * v20);
    v24 = (_DWORD *)(*result + v4 * v19);
    v25 = &(*a2)[v4 * (_QWORD)v21];
    do
    {
      v26 = *a4;
      if (*a4)
      {
        v27 = v25;
        v28 = v24;
        v29 = v23;
        do
        {
          if (*v27++)
            *v29 = *v28;
          ++v29;
          ++v28;
          --v26;
        }
        while (v26);
      }
      v31 = a4[2];
      if (v31 >= (unint64_t)v22)
      {
        v18 = a4[3];
      }
      else
      {
        do
        {
          if (v25[v31])
            v23[v31] = v24[v31];
          ++v31;
        }
        while (v22 != (unsigned __int8 *)v31);
        v18 = a4[3];
      }
      ++v4;
      v23 = (_DWORD *)((char *)v23 + v20);
      v24 = (_DWORD *)((char *)v24 + v19);
      v25 = &v21[(_QWORD)v25];
    }
    while (v4 < v18);
  }
  v32 = a2[1];
  if (v18 < (unint64_t)v32)
  {
    v33 = result[3];
    v34 = a3[3];
    v36 = a2[2];
    v35 = a2[3];
    v37 = (_DWORD *)(*a3 + v18 * v34);
    v38 = (_QWORD *)(*result + v18 * v33);
    v39 = &(*a2)[v18 * (_QWORD)v35];
    do
    {
      if (v36)
      {
        v40 = v39;
        result = v38;
        v41 = v37;
        v42 = v36;
        do
        {
          if (*v40++)
            *v41 = *(_DWORD *)result;
          ++v41;
          result = (_QWORD *)((char *)result + 4);
          --v42;
        }
        while (v42);
      }
      ++v18;
      v37 = (_DWORD *)((char *)v37 + v34);
      v38 = (_QWORD *)((char *)v38 + v33);
      v39 = &v35[(_QWORD)v39];
    }
    while ((unsigned __int8 *)v18 != v32);
  }
  return result;
}

void sub_1B3AC5B3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AC5C48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

char *std::vector<arkit::BoundingBoxGroup::Element>::emplace_back<arkit::IntRect const&>(void **a1, _OWORD *a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  unint64_t v7;
  __int128 v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  __int128 v15;
  char *v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= (unint64_t)v6)
  {
    v10 = 0x6DB6DB6DB6DB6DB7 * ((uint64_t)(v7 - (_QWORD)*a1) >> 4);
    v11 = v10 + 1;
    if ((unint64_t)(v10 + 1) > 0x249249249249249)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v12 = 0x6DB6DB6DB6DB6DB7 * ((v5 - (_BYTE *)*a1) >> 4);
    if (2 * v12 > v11)
      v11 = 2 * v12;
    if (v12 >= 0x124924924924924)
      v13 = 0x249249249249249;
    else
      v13 = v11;
    v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(v4, v13);
    v15 = a2[1];
    v16 = &v14[112 * v10];
    *(_OWORD *)v16 = *a2;
    *((_OWORD *)v16 + 1) = v15;
    v18 = &v14[112 * v17];
    *((_DWORD *)v16 + 8) = 0;
    *((_QWORD *)v16 + 5) = 0;
    *((_DWORD *)v16 + 12) = 0;
    *((_QWORD *)v16 + 7) = 0;
    *((_DWORD *)v16 + 16) = 2139095039;
    *((_DWORD *)v16 + 18) = 0;
    *((_QWORD *)v16 + 10) = 0;
    *((_DWORD *)v16 + 22) = 0;
    *((_QWORD *)v16 + 12) = 0;
    *((_DWORD *)v16 + 26) = 2139095039;
    v9 = v16 + 112;
    v20 = (char *)*a1;
    v19 = (char *)a1[1];
    if (v19 != *a1)
    {
      do
      {
        v21 = *((_OWORD *)v19 - 7);
        v22 = *((_OWORD *)v19 - 5);
        *((_OWORD *)v16 - 6) = *((_OWORD *)v19 - 6);
        *((_OWORD *)v16 - 5) = v22;
        *((_OWORD *)v16 - 7) = v21;
        v23 = *((_OWORD *)v19 - 4);
        v24 = *((_OWORD *)v19 - 3);
        v25 = *((_OWORD *)v19 - 1);
        *((_OWORD *)v16 - 2) = *((_OWORD *)v19 - 2);
        *((_OWORD *)v16 - 1) = v25;
        *((_OWORD *)v16 - 4) = v23;
        *((_OWORD *)v16 - 3) = v24;
        v16 -= 112;
        v19 -= 112;
      }
      while (v19 != v20);
      v19 = (char *)*a1;
    }
    *a1 = v16;
    a1[1] = v9;
    a1[2] = v18;
    if (v19)
      operator delete(v19);
  }
  else
  {
    v8 = a2[1];
    *(_OWORD *)v7 = *a2;
    *(_OWORD *)(v7 + 16) = v8;
    *(_DWORD *)(v7 + 32) = 0;
    *(_QWORD *)(v7 + 40) = 0;
    *(_DWORD *)(v7 + 48) = 0;
    *(_QWORD *)(v7 + 56) = 0;
    *(_DWORD *)(v7 + 64) = 2139095039;
    *(_DWORD *)(v7 + 72) = 0;
    *(_QWORD *)(v7 + 80) = 0;
    *(_DWORD *)(v7 + 88) = 0;
    *(_DWORD *)(v7 + 104) = 2139095039;
    v9 = (char *)(v7 + 112);
    *(_QWORD *)(v7 + 96) = 0;
  }
  a1[1] = v9;
  return v9 - 112;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup::Element>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x24924924924924ALL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(112 * a2);
}

void ___ZL15_ARLogTechniquev_block_invoke_1()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t std::vector<arkit::BoundingBoxGroup>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 58)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(a2 << 6);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>,std::reverse_iterator<arkit::BoundingBoxGroup*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 64) = 0;
      *(_QWORD *)(v7 - 56) = 0;
      *(_QWORD *)(v7 - 48) = 0;
      v8 = *(_OWORD *)(a3 - 64);
      a3 -= 64;
      *(_OWORD *)(v7 - 64) = v8;
      *(_QWORD *)(v7 - 48) = *(_QWORD *)(a3 + 16);
      *(_QWORD *)a3 = 0;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      v9 = *(_OWORD *)(a3 + 48);
      *(_OWORD *)(v7 - 32) = *(_OWORD *)(a3 + 32);
      *(_OWORD *)(v7 - 16) = v9;
      v7 = *((_QWORD *)&v15 + 1) - 64;
      *((_QWORD *)&v15 + 1) -= 64;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<arkit::BoundingBoxGroup>,std::reverse_iterator<arkit::BoundingBoxGroup*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 64;
  }
}

uint64_t std::__split_buffer<arkit::BoundingBoxGroup>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<arkit::BoundingBoxGroup>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<arkit::BoundingBoxGroup>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 64);
    *(_QWORD *)(a1 + 16) = v2 - 64;
    if (v5)
    {
      *(_QWORD *)(v2 - 56) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 64;
    }
  }
}

char *std::__rotate[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>,std::__wrap_iter<arkit::IntRect *>>(char *__src, char *a2, char *a3)
{
  char *v4;
  int64_t v6;
  size_t v7;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;

  v4 = a3;
  if (__src != a2)
  {
    if (a2 == a3)
    {
      return __src;
    }
    else if (__src + 32 == a2)
    {
      v9 = *(_OWORD *)__src;
      v11 = *((_OWORD *)__src + 1);
      v6 = a3 - a2;
      memmove(__src, a2, a3 - a2);
      v4 = &__src[v6];
      *(_OWORD *)v4 = v9;
      *((_OWORD *)v4 + 1) = v11;
    }
    else if (a2 + 32 == a3)
    {
      v4 = __src + 32;
      v10 = *((_OWORD *)a3 - 2);
      v12 = *((_OWORD *)a3 - 1);
      v7 = a3 - 32 - __src;
      if (a3 - 32 != __src)
        memmove(__src + 32, __src, v7);
      *(_OWORD *)__src = v10;
      *((_OWORD *)__src + 1) = v12;
    }
    else
    {
      return std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>>(__src, a2, a3);
    }
  }
  return v4;
}

char *std::__rotate_gcd[abi:ne180100]<std::_ClassicAlgPolicy,std::__wrap_iter<arkit::IntRect *>>(char *a1, char *a2, char *a3)
{
  uint64_t v3;
  char *v4;
  char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  __int128 v14;
  __int128 v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  uint64_t v20;
  BOOL v21;
  char v22;
  uint64_t v23;
  char *v24;
  __int128 v26;

  v3 = (a2 - a1) >> 5;
  if (v3 == (a3 - a2) >> 5)
  {
    if (a1 != a2 && a2 != a3)
    {
      v4 = a1 + 32;
      v5 = a2 + 32;
      do
      {
        v7 = *((_OWORD *)v4 - 2);
        v6 = *((_OWORD *)v4 - 1);
        v8 = *((_OWORD *)v5 - 1);
        *((_OWORD *)v4 - 2) = *((_OWORD *)v5 - 2);
        *((_OWORD *)v4 - 1) = v8;
        *((_OWORD *)v5 - 2) = v7;
        *((_OWORD *)v5 - 1) = v6;
        if (v4 == a2)
          break;
        v4 += 32;
        v9 = v5 == a3;
        v5 += 32;
      }
      while (!v9);
    }
  }
  else
  {
    v10 = (a3 - a2) >> 5;
    v11 = (a2 - a1) >> 5;
    do
    {
      v12 = v11;
      v11 = v10;
      v10 = v12 % v10;
    }
    while (v10);
    if (v11)
    {
      v13 = &a1[32 * v11];
      do
      {
        v14 = *((_OWORD *)v13 - 2);
        v15 = *((_OWORD *)v13 - 1);
        v13 -= 32;
        v26 = v15;
        v16 = &v13[32 * v3];
        v17 = v13;
        do
        {
          v18 = v16;
          v19 = *((_OWORD *)v16 + 1);
          *(_OWORD *)v17 = *(_OWORD *)v16;
          *((_OWORD *)v17 + 1) = v19;
          v20 = a3 - v16;
          v16 += 32 * v3;
          v21 = __OFSUB__(v3, v20 >> 5);
          v23 = v3 - (v20 >> 5);
          v22 = (v23 < 0) ^ v21;
          v24 = &a1[32 * v23];
          if (!v22)
            v16 = v24;
          v17 = v18;
        }
        while (v16 != v13);
        *(_OWORD *)v18 = v14;
        *((_OWORD *)v18 + 1) = v26;
      }
      while (v13 != a1);
    }
    return &a1[32 * ((a3 - a2) >> 5)];
  }
  return a2;
}

_QWORD *std::allocate_shared[abi:ne180100]<arkit::RobustExpFilter<float>,std::allocator<arkit::RobustExpFilter<float>>,double,double,double,double,double,double,double,double,void>@<X0>(double *a1@<X1>, double *a2@<X2>, double *a3@<X3>, double *a4@<X4>, double *a5@<X5>, uint64_t a6@<X6>, double *a7@<X7>, _QWORD *a8@<X8>, double *a9)
{
  _QWORD *v17;
  _QWORD *result;

  v17 = operator new(0x78uLL);
  result = std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__shared_ptr_emplace[abi:ne180100]<double,double,double,double,double,double,double,double,std::allocator<arkit::RobustExpFilter<float>>,0>(v17, a1, a2, a3, a4, a5, a6, a7, a9);
  *a8 = v17 + 3;
  a8[1] = v17;
  return result;
}

void sub_1B3AC63A0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__shared_ptr_emplace[abi:ne180100]<double,double,double,double,double,double,double,double,std::allocator<arkit::RobustExpFilter<float>>,0>(_QWORD *a1, double *a2, double *a3, double *a4, double *a5, double *a6, uint64_t a7, double *a8, double *a9)
{
  char v11;

  a1[2] = 0;
  *a1 = &unk_1E6670570;
  a1[1] = 0;
  std::allocator<arkit::RobustExpFilter<float>>::construct[abi:ne180100]<arkit::RobustExpFilter<float>,double,double,double,double,double,double,double,double>((uint64_t)&v11, (uint64_t)(a1 + 3), a2, a3, a4, a5, a6, a7, a8, a9);
  return a1;
}

void sub_1B3AC6420(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670570;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670570;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

void std::__shared_ptr_emplace<arkit::RobustExpFilter<float>>::__on_zero_shared(uint64_t a1)
{
  char v1;

  std::allocator<arkit::RobustExpFilter<float>>::destroy[abi:ne180100]((uint64_t)&v1, a1 + 24);
}

float std::allocator<arkit::RobustExpFilter<float>>::construct[abi:ne180100]<arkit::RobustExpFilter<float>,double,double,double,double,double,double,double,double>(uint64_t a1, uint64_t a2, double *a3, double *a4, double *a5, double *a6, double *a7, uint64_t a8, double *a9, double *a10)
{
  float v10;
  float v11;
  float v12;
  float v13;
  float v14;
  float v15;
  float v16;
  float v17;
  float v18;
  BOOL v19;
  float v20;
  float v21;
  float result;

  v10 = *a3;
  v11 = *a4;
  v12 = *a5;
  v13 = *a6;
  v14 = *a7;
  v15 = *a9;
  v16 = *a10;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = 0u;
  *(_OWORD *)a2 = 0u;
  *(float *)(a2 + 48) = v10;
  *(float *)(a2 + 52) = v11;
  *(float *)(a2 + 56) = v12;
  *(float *)(a2 + 60) = v13;
  *(float *)(a2 + 64) = v14;
  *(float *)(a2 + 68) = v15;
  *(float *)(a2 + 72) = v15;
  *(float *)(a2 + 76) = v16;
  v17 = v12 - v11;
  v18 = 1.0 / (float)(v12 - v11);
  v19 = v17 < 0.000001;
  v20 = 1000000.0;
  if (v19)
    v18 = 1000000.0;
  v21 = v14 - v13;
  if (v21 >= 0.000001)
    v20 = 1.0 / v21;
  *(float *)(a2 + 80) = v18;
  *(float *)(a2 + 84) = v20;
  result = 1.0 / (float)(v15 + 1.0);
  *(float *)(a2 + 88) = result;
  return result;
}

void std::allocator<arkit::RobustExpFilter<float>>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;

  v3 = *(void **)(a2 + 24);
  if (v3)
  {
    *(_QWORD *)(a2 + 32) = v3;
    operator delete(v3);
  }
  v4 = *(void **)a2;
  if (*(_QWORD *)a2)
  {
    *(_QWORD *)(a2 + 8) = v4;
    operator delete(v4);
  }
}

void std::vector<float>::resize(uint64_t a1, unint64_t a2, _DWORD *a3)
{
  unint64_t v3;

  v3 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v3)
  {
    if (a2 < v3)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    std::vector<float>::__append((void **)a1, a2 - v3, a3);
  }
}

void std::vector<float>::__append(void **a1, unint64_t a2, _DWORD *a3)
{
  uint64_t v6;
  _BYTE *v7;
  _BYTE *v8;
  _DWORD *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  _DWORD *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *i;
  int v25;

  v8 = a1[2];
  v6 = (uint64_t)(a1 + 2);
  v7 = v8;
  v9 = *(_DWORD **)(v6 - 8);
  if (a2 <= (v8 - (_BYTE *)v9) >> 2)
  {
    if (a2)
    {
      v16 = 4 * a2;
      v17 = &v9[a2];
      do
      {
        *v9++ = *a3;
        v16 -= 4;
      }
      while (v16);
      v9 = v17;
    }
    a1[1] = v9;
  }
  else
  {
    v10 = (char *)v9 - (_BYTE *)*a1;
    v11 = a2 + (v10 >> 2);
    if (v11 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v12 = v10 >> 2;
    v13 = v7 - (_BYTE *)*a1;
    if (v13 >> 1 > v11)
      v11 = v13 >> 1;
    if ((unint64_t)v13 >= 0x7FFFFFFFFFFFFFFCLL)
      v14 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v14 = v11;
    if (v14)
      v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v6, v14);
    else
      v15 = 0;
    v18 = &v15[4 * v12];
    v19 = &v18[4 * a2];
    v20 = 4 * a2;
    v21 = v18;
    do
    {
      *(_DWORD *)v21 = *a3;
      v21 += 4;
      v20 -= 4;
    }
    while (v20);
    v22 = &v15[4 * v14];
    v23 = (char *)*a1;
    for (i = (char *)a1[1]; i != v23; i -= 4)
    {
      v25 = *((_DWORD *)i - 1);
      *((_DWORD *)v18 - 1) = v25;
      v18 -= 4;
    }
    *a1 = v18;
    a1[1] = v19;
    a1[2] = v22;
    if (v23)
      operator delete(v23);
  }
}

void std::vector<arkit::BoundingBoxGroup>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<arkit::BoundingBoxGroup>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<arkit::BoundingBoxGroup>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 64);
      v4 -= 64;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 56) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

void sub_1B3AC6C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id a9)
{
  id *v9;

  objc_destroyWeak(v9);
  objc_destroyWeak(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3AC7464(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

void sub_1B3AC7740(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AC7D98(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B3AC7E1C(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_1B3AC7F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  uint64_t v9;
  va_list va;

  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v9 - 64), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

id _ARLogGeneral_11()
{
  if (_ARLogGeneral_onceToken_13 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_13, &__block_literal_global_249);
  return (id)_ARLogGeneral_logObj_13;
}

void sub_1B3AC871C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  uint64_t v27;

  _Block_object_dispose(&a27, 8);
  _Block_object_dispose((const void *)(v27 - 112), 8);
  _Unwind_Resume(a1);
}

void sub_1B3ACAF74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v3 - 216, *(_QWORD **)(v3 - 208));

  _Unwind_Resume(a1);
}

void sub_1B3ACB074(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

uint64_t *std::__tree<unsigned long long>::__emplace_unique_key_args<unsigned long long,unsigned long long>(uint64_t **a1, unint64_t *a2, uint64_t *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unint64_t v7;
  uint64_t **v8;
  unint64_t v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = v5[4];
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x28uLL);
    v10[4] = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return v10;
  }
  return (uint64_t *)v8;
}

uint64_t *std::set<unsigned long long>::set[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1B3ACB1D4(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::set<unsigned long long>::insert[abi:ne180100]<std::__tree_const_iterator<unsigned long long,std::__tree_node<unsigned long long,void *> *,long>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(v5, v6, v4 + 4, v4 + 4);
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<unsigned long long>::__emplace_hint_unique_key_args<unsigned long long,unsigned long long const&>(uint64_t **a1, _QWORD *a2, unint64_t *a3, uint64_t *a4)
{
  uint64_t **v6;
  uint64_t *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (uint64_t **)std::__tree<unsigned long long>::__find_equal<unsigned long long>(a1, a2, &v11, &v10, a3);
  v7 = *v6;
  if (!*v6)
  {
    v8 = v6;
    v7 = (uint64_t *)operator new(0x28uLL);
    v7[4] = *a4;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, v7);
  }
  return v7;
}

_QWORD *std::__tree<unsigned long long>::__find_equal<unsigned long long>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, unint64_t *a5)
{
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  BOOL v14;
  unint64_t v15;
  _QWORD *v16;
  _QWORD *v17;
  unint64_t v18;
  _QWORD *v19;
  _QWORD *v20;
  _QWORD *v21;
  unint64_t v22;

  v5 = a1 + 1;
  if (a1 + 1 == a2 || (v6 = *a5, v7 = a2[4], *a5 < v7))
  {
    v8 = *a2;
    if ((_QWORD *)*a1 == a2)
    {
      v10 = a2;
LABEL_17:
      if (v8)
      {
        *a3 = v10;
        return v10 + 1;
      }
      else
      {
        *a3 = a2;
        return a2;
      }
    }
    if (v8)
    {
      v9 = (_QWORD *)*a2;
      do
      {
        v10 = v9;
        v9 = (_QWORD *)v9[1];
      }
      while (v9);
    }
    else
    {
      v13 = a2;
      do
      {
        v10 = (_QWORD *)v13[2];
        v14 = *v10 == (_QWORD)v13;
        v13 = v10;
      }
      while (v14);
    }
    v15 = *a5;
    if (v10[4] < *a5)
      goto LABEL_17;
    v16 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v17 = v16;
          v18 = v16[4];
          if (v15 >= v18)
            break;
          v16 = (_QWORD *)*v17;
          v5 = v17;
          if (!*v17)
            goto LABEL_29;
        }
        if (v18 >= v15)
          break;
        v5 = v17 + 1;
        v16 = (_QWORD *)v17[1];
      }
      while (v16);
    }
    else
    {
      v17 = a1 + 1;
    }
LABEL_29:
    *a3 = v17;
    return v5;
  }
  if (v7 >= v6)
  {
    *a3 = a2;
    *a4 = a2;
    return a4;
  }
  v11 = a2[1];
  if (v11)
  {
    v12 = (_QWORD *)a2[1];
    do
    {
      a4 = v12;
      v12 = (_QWORD *)*v12;
    }
    while (v12);
  }
  else
  {
    v19 = a2;
    do
    {
      a4 = (_QWORD *)v19[2];
      v14 = *a4 == (_QWORD)v19;
      v19 = a4;
    }
    while (!v14);
  }
  if (a4 != v5 && v6 >= a4[4])
  {
    v20 = (_QWORD *)*v5;
    if (*v5)
    {
      do
      {
        while (1)
        {
          v21 = v20;
          v22 = v20[4];
          if (v6 >= v22)
            break;
          v20 = (_QWORD *)*v21;
          v5 = v21;
          if (!*v21)
            goto LABEL_48;
        }
        if (v22 >= v6)
          break;
        v5 = v21 + 1;
        v20 = (_QWORD *)v21[1];
      }
      while (v20);
    }
    else
    {
      v21 = a1 + 1;
    }
LABEL_48:
    *a3 = v21;
    return v5;
  }
  if (v11)
  {
    *a3 = a4;
  }
  else
  {
    *a3 = a2;
    return a2 + 1;
  }
  return a4;
}

void sub_1B3ACCF1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACD0A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3ACD13C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACDB14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3ACDC9C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACE0B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;

  a9.super_class = (Class)ARWorldTrackingTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void std::shared_ptr<PlaneDetectionSession>::reset[abi:ne180100](_QWORD *a1)
{
  std::__shared_weak_count *v1;
  unint64_t *p_shared_owners;
  unint64_t v3;

  v1 = (std::__shared_weak_count *)a1[1];
  *a1 = 0;
  a1[1] = 0;
  if (v1)
  {
    p_shared_owners = (unint64_t *)&v1->__shared_owners_;
    do
      v3 = __ldaxr(p_shared_owners);
    while (__stlxr(v3 - 1, p_shared_owners));
    if (!v3)
    {
      ((void (*)(std::__shared_weak_count *))v1->__on_zero_shared)(v1);
      std::__shared_weak_count::__release_weak(v1);
    }
  }
}

void sub_1B3ACE248(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3ACE500(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACE5B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3ACE618(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACE7EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3ACEB34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3ACEF18(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3ACF110(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ACF3DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3AD0310(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3AD07D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD0D58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1B3AD0FB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, id a18)
{
  void *v18;
  void *v19;
  void *v20;

  v20 = v19;

  _Unwind_Resume(a1);
}

void sub_1B3AD1244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void sub_1B3AD1960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *), uint64_t a18, uint64_t a19, char a20,uint64_t a21,void (*a22)(char *),uint64_t a23,uint64_t a24,char a25,uint64_t a26,void (*a27)(char *))
{
  a17(&a15);
  a22(&a20);
  a27(&a25);
  _Unwind_Resume(a1);
}

void sub_1B3AD269C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,void *a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  void *v30;
  void *v31;
  void *v32;

  _Unwind_Resume(a1);
}

void sub_1B3AD2A48(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD2BC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id a16)
{
  void *v16;
  void *v17;
  void *v18;

  if (a2 == 1)
  {
    objc_msgSend(v17, "_handleCV3DError:withDescription:failTechnique:", *((_QWORD *)__cxa_begin_catch(a1) + 1), CFSTR("Raycasting error"), 0);
    __cxa_end_catch();
    JUMPOUT(0x1B3AD2B9CLL);
  }

  _Unwind_Resume(a1);
}

void sub_1B3AD2DAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  uint64_t v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD3484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,void (*a26)(char *),uint64_t a27,uint64_t a28,char a29,uint64_t a30,void (*a31)(char *))
{
  void *v31;
  void *v32;
  void *v33;

  a26(&a24);
  a31(&a29);

  _Unwind_Resume(a1);
}

void sub_1B3AD3714(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD3930(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD3A38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD3E44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD41B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD428C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD42FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD4D48(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  void *v32;
  void *v33;

  _Unwind_Resume(a1);
}

double simd_matrix4x4(float32x4_t a1)
{
  float v10;
  double v11;

  _S3 = a1.i32[1];
  _S5 = a1.i32[2];
  __asm { FMLS            S1, S5, V0.S[2] }
  _S7 = a1.i32[3];
  __asm { FMLA            S1, S7, V0.S[3] }
  v10 = vmlas_n_f32(vmuls_lane_f32(a1.f32[2], a1, 3), a1.f32[1], a1.f32[0]);
  LODWORD(v11) = _S1;
  *((float *)&v11 + 1) = v10 + v10;
  __asm
  {
    FMLA            S6, S3, V0.S[1]
    FMLA            S6, S7, V0.S[3]
    FMLS            S6, S0, V0.S[0]
    FMLA            S18, S5, V0.S[1]
    FMLA            S17, S0, V0.S[2]
    FMLA            S16, S5, V0.S[1]
    FMLA            S7, S5, V0.S[2]
    FMLS            S7, S0, V0.S[0]
    FMLS            S7, S3, V0.S[1]
  }
  return v11;
}

void sub_1B3AD52D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD53C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD5430(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD5554(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD5720(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v4;

  _Unwind_Resume(a1);
}

void sub_1B3AD5844(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1B3AD58E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD5A6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD5BCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD5C64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD5D28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD6F38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, id *location, id *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,id a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,id a46,uint64_t a47,uint64_t a48,char a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,char a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,char a62,uint64_t a63)
{
  uint64_t a64;
  void *v64;

  objc_destroyWeak(location);
  objc_destroyWeak(a10);
  objc_destroyWeak(&a46);
  ((void (*)(char *))a51)(&a49);
  ((void (*)(char *))a58)(&a56);
  ((void (*)(char *))a64)(&a62);

  _Unwind_Resume(a1);
}

void sub_1B3AD7354(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD73A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3AD73FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD74A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD75E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD76E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD787C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD7934(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3AD79C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD7B00(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD7BE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD7E64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD7F58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AD81EC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  os_unfair_lock_unlock(v1);
  objc_destroyWeak((id *)(v3 - 80));
  _Unwind_Resume(a1);
}

void sub_1B3AD8280(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD82D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD8320(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD8414(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AD8714(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v2;

  _Unwind_Resume(a1);
}

void sub_1B3AD8E58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33)
{

  _Unwind_Resume(a1);
}

void sub_1B3AD9108(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

double ARCascadeTransform(double *a1, double *a2, simd_float4x3 a3, const double *a4, const double *a5)
{
  double result;

  *a1 = a4[3] * a3.columns[1].f32[0] + *a4 * a3.columns[0].f32[0] + a4[6] * a3.columns[2].f32[0];
  a1[1] = a4[4] * a3.columns[1].f32[0] + a4[1] * a3.columns[0].f32[0] + a4[7] * a3.columns[2].f32[0];
  a1[2] = a4[5] * a3.columns[1].f32[0] + a4[2] * a3.columns[0].f32[0] + a4[8] * a3.columns[2].f32[0];
  a1[3] = a4[3] * a3.columns[1].f32[1] + *a4 * a3.columns[0].f32[1] + a4[6] * a3.columns[2].f32[1];
  a1[4] = a4[4] * a3.columns[1].f32[1] + a4[1] * a3.columns[0].f32[1] + a4[7] * a3.columns[2].f32[1];
  a1[5] = a4[5] * a3.columns[1].f32[1] + a4[2] * a3.columns[0].f32[1] + a4[8] * a3.columns[2].f32[1];
  a1[6] = a4[3] * a3.columns[1].f32[2] + *a4 * a3.columns[0].f32[2] + a4[6] * a3.columns[2].f32[2];
  a1[7] = a4[4] * a3.columns[1].f32[2] + a4[1] * a3.columns[0].f32[2] + a4[7] * a3.columns[2].f32[2];
  a1[8] = a4[5] * a3.columns[1].f32[2] + a4[2] * a3.columns[0].f32[2] + a4[8] * a3.columns[2].f32[2];
  *a2 = a3.columns[3].f32[0] / 1000.0
      + *a5 * a3.columns[0].f32[0]
      + a5[2] * a3.columns[2].f32[0]
      + a5[1] * a3.columns[1].f32[0];
  a2[1] = a3.columns[3].f32[1] / 1000.0
        + *a5 * a3.columns[0].f32[1]
        + a5[2] * a3.columns[2].f32[1]
        + a5[1] * a3.columns[1].f32[1];
  result = a3.columns[3].f32[2] / 1000.0
         + *a5 * a3.columns[0].f32[2]
         + a5[2] * a3.columns[2].f32[2]
         + a5[1] * a3.columns[1].f32[2];
  a2[2] = result;
  return result;
}

void sub_1B3AD984C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, void (*a20)(char *),uint64_t a21,uint64_t a22,char a23,uint64_t a24,void (*a25)(char *))
{
  void *v25;
  void *v26;
  void *v27;

  a20(&a18);
  a25(&a23);

  _Unwind_Resume(a1);
}

void sub_1B3AD9DA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3ADB450(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1B3ADBE14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3ADBF48(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<RaycastSession>::operator=[abi:ne180100](_QWORD *a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  std::__shared_weak_count *v7;
  unint64_t *p_shared_owners;
  unint64_t v9;

  v4 = *a2;
  v3 = a2[1];
  if (v3)
  {
    v5 = (unint64_t *)(v3 + 8);
    do
      v6 = __ldxr(v5);
    while (__stxr(v6 + 1, v5));
  }
  v7 = (std::__shared_weak_count *)a1[1];
  *a1 = v4;
  a1[1] = v3;
  if (v7)
  {
    p_shared_owners = (unint64_t *)&v7->__shared_owners_;
    do
      v9 = __ldaxr(p_shared_owners);
    while (__stlxr(v9 - 1, p_shared_owners));
    if (!v9)
    {
      ((void (*)(std::__shared_weak_count *))v7->__on_zero_shared)(v7);
      std::__shared_weak_count::__release_weak(v7);
    }
  }
  return a1;
}

void ___ZL15_ARLogTechniquev_block_invoke_2()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_6()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

uint64_t initAudioServicesPlaySystemSound(uint64_t a1)
{
  if (AudioToolboxLibrary(void)::sOnce != -1)
    dispatch_once(&AudioToolboxLibrary(void)::sOnce, &__block_literal_global_510);
  softLinkAudioServicesPlaySystemSound = (uint64_t (*))dlsym((void *)AudioToolboxLibrary(void)::sLib, "AudioServicesPlaySystemSound");
  return softLinkAudioServicesPlaySystemSound(a1);
}

_QWORD *std::allocate_shared[abi:ne180100]<RaycastSession,std::allocator<RaycastSession>,CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,void>@<X0>(_QWORD *a1@<X1>, _QWORD *a2@<X2>, unsigned __int8 *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x20uLL);
  result = std::__shared_ptr_emplace<RaycastSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,std::allocator<RaycastSession>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B3ADC668(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<RaycastSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,void({block_pointer} {__strong}&)(CV3DRaycastResultMap const*),BOOL,std::allocator<RaycastSession>,0>(_QWORD *a1, _QWORD *a2, _QWORD *a3, unsigned __int8 *a4)
{
  a1[2] = 0;
  *a1 = &unk_1E66704C8;
  a1[1] = 0;
  RaycastSession::RaycastSession(a1 + 3, *a2, *a3, *a4);
  return a1;
}

void sub_1B3ADC6C0(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<RaycastSession>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66704C8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<RaycastSession>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66704C8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

uint64_t std::__shared_ptr_emplace<RaycastSession>::__on_zero_shared()
{
  return CV3DRaycastSessionRelease();
}

_QWORD *std::allocate_shared[abi:ne180100]<PlaneDetectionSession,std::allocator<PlaneDetectionSession>,CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),void>@<X0>(_QWORD *a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X3>, _QWORD *a4@<X4>, _QWORD *a5@<X8>)
{
  _QWORD *v10;
  _QWORD *result;

  v10 = operator new(0x30uLL);
  result = std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),std::allocator<PlaneDetectionSession>,0>(v10, a1, a2, a3, a4);
  *a5 = v10 + 3;
  a5[1] = v10;
  return result;
}

void sub_1B3ADC7A0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void({block_pointer} {__strong}&)(CV3DPlaneDetectionSingleShotPlaneList const*),std::allocator<PlaneDetectionSession>,0>(_QWORD *a1, _QWORD *a2, uint64_t a3, _QWORD *a4, _QWORD *a5)
{
  a1[2] = 0;
  *a1 = &unk_1E6670500;
  a1[1] = 0;
  PlaneDetectionSession::PlaneDetectionSession(a1 + 3, *a2, a3, *a4, *a5);
  return a1;
}

void sub_1B3ADC7F8(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670500;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E6670500;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

void std::__shared_ptr_emplace<PlaneDetectionSession>::__on_zero_shared(uint64_t a1)
{
  PlaneDetectionSession::~PlaneDetectionSession((PlaneDetectionSession *)(a1 + 24));
}

_QWORD *std::allocate_shared[abi:ne180100]<PlaneDetectionSession,std::allocator<PlaneDetectionSession>,CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),void>@<X0>(_QWORD *a1@<X1>, uint64_t a2@<X2>, _QWORD *a3@<X3>, _QWORD *a4@<X8>)
{
  _QWORD *v8;
  _QWORD *result;

  v8 = operator new(0x30uLL);
  result = std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),std::allocator<PlaneDetectionSession>,0>(v8, a1, a2, a3);
  *a4 = v8 + 3;
  a4[1] = v8;
  return result;
}

void sub_1B3ADC8BC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__shared_ptr_emplace<PlaneDetectionSession>::__shared_ptr_emplace[abi:ne180100]<CV3DSLAMSession *&,PlaneDetectionConfiguration const&,void({block_pointer} {__strong}&)(CV3DPlaneDetectionPlaneList const*),std::allocator<PlaneDetectionSession>,0>(_QWORD *a1, _QWORD *a2, uint64_t a3, _QWORD *a4)
{
  a1[2] = 0;
  *a1 = &unk_1E6670500;
  a1[1] = 0;
  PlaneDetectionSession::PlaneDetectionSession(a1 + 3, *a2, a3, *a4, 0);
  return a1;
}

void sub_1B3ADC914(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<long,double>,std::__map_value_compare<long,std::__value_type<long,double>,std::less<long>,true>,std::allocator<std::__value_type<long,double>>>::__emplace_unique_key_args<long,std::piecewise_construct_t const&,std::tuple<long &&>,std::tuple<>>(uint64_t **a1, uint64_t *a2, uint64_t a3, uint64_t **a4)
{
  uint64_t *v6;
  uint64_t **v7;
  uint64_t v8;
  uint64_t **v9;
  uint64_t v10;
  uint64_t *v11;

  v7 = a1 + 1;
  v6 = a1[1];
  if (v6)
  {
    v8 = *a2;
    while (1)
    {
      while (1)
      {
        v9 = (uint64_t **)v6;
        v10 = v6[4];
        if (v8 >= v10)
          break;
        v6 = *v9;
        v7 = v9;
        if (!*v9)
          goto LABEL_10;
      }
      if (v10 >= v8)
        break;
      v6 = v9[1];
      if (!v6)
      {
        v7 = v9 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v9 = a1 + 1;
LABEL_10:
    v11 = (uint64_t *)operator new(0x30uLL);
    v11[4] = **a4;
    v11[5] = 0;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v9, v7, v11);
    return v11;
  }
  return (uint64_t *)v9;
}

void sub_1B3ADCB84(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

float arkit::ExponentialSmoother<float>::step(uint64_t a1, float *a2, float a3, float a4, float a5)
{
  float v8;
  float v9;
  float v10;

  if (a5 <= 0.0 || a5 > 1.0)
    arkit::ExponentialSmoother<float>::step();
  if (a3 <= 0.0)
    arkit::ExponentialSmoother<float>::step();
  if (a4 <= 0.0)
    arkit::ExponentialSmoother<float>::step();
  v8 = *a2;
  if (*(_BYTE *)(a1 + 4))
  {
    v9 = a4 / log(1.0 - a5);
    v10 = expf(a3 / v9);
    v8 = (float)((float)(1.0 - (float)(1.0 - v10)) * *(float *)a1) + (float)((float)(1.0 - v10) * v8);
  }
  *(float *)a1 = v8;
  *(_BYTE *)(a1 + 4) = 1;
  return v8;
}

void sub_1B3ADCE08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

double ar_rt_ring_buffer_init(uint64_t a1, int a2)
{
  double result;

  if (a2 < 0)
    ar_rt_ring_buffer_init_cold_1();
  *(_DWORD *)a1 = a2;
  *(_QWORD *)&result = 0xFFFFFFFFLL;
  *(_QWORD *)(a1 + 4) = 0xFFFFFFFFLL;
  return result;
}

uint64_t ar_rt_ring_buffer_reset(uint64_t result)
{
  if (!result)
    ar_rt_ring_buffer_reset_cold_1();
  *(_QWORD *)result = 0;
  *(_DWORD *)(result + 8) = 0;
  return result;
}

BOOL ar_rt_ring_buffer_empty(uint64_t a1)
{
  if (!a1)
    ar_rt_ring_buffer_empty_cold_1();
  return *(_DWORD *)(a1 + 8) < 1;
}

uint64_t ar_rt_ring_buffer_increment_index(_DWORD *a1, int a2)
{
  if (!a1)
    ar_rt_ring_buffer_increment_index_cold_1();
  return (*a1 & (((a2 + 1) % *a1) >> 31)) + (a2 + 1) % *a1;
}

uint64_t ar_rt_ring_buffer_decrement_index(_DWORD *a1, int a2)
{
  if (!a1)
    ar_rt_ring_buffer_decrement_index_cold_1();
  return (*a1 & (((a2 - 1) % *a1) >> 31)) + (a2 - 1) % *a1;
}

uint64_t ar_rt_ring_buffer_add_element(int *a1)
{
  int v1;
  int v2;
  uint64_t v3;

  if (!a1)
    ar_rt_ring_buffer_add_element_cold_1();
  v1 = a1[2];
  v2 = *a1;
  if (v1 < *a1)
    a1[2] = v1 + 1;
  v3 = (v2 & (((a1[1] + 1) % v2) >> 31)) + (a1[1] + 1) % v2;
  a1[1] = v3;
  return v3;
}

BOOL ar_rt_ring_buffer_filled(_DWORD *a1)
{
  if (!a1)
    ar_rt_ring_buffer_filled_cold_1();
  return a1[2] == *a1;
}

void MakeMatrix3x4f(float a1@<S0>, float a2@<S1>, float a3@<S2>, float a4@<S3>, float a5@<S4>, float a6@<S5>, float a7@<S6>, float a8@<S7>, float *a9@<X8>, float a10, float a11, float a12, float a13)
{
  *a9 = a1;
  a9[1] = a5;
  a9[2] = a10;
  a9[3] = a2;
  a9[4] = a6;
  a9[5] = a11;
  a9[6] = a3;
  a9[7] = a7;
  a9[8] = a12;
  a9[9] = a4;
  a9[10] = a8;
  a9[11] = a13;
}

int32x2_t round@<D0>(float32x2_t *a1@<X0>, int32x2_t *a2@<X8>)
{
  int32x2_t result;

  result = vcvt_s32_f32(vrnda_f32(*a1));
  *a2 = result;
  return result;
}

{
  unsigned int v2;
  int32x2_t result;

  v2 = llroundf(a1[1].f32[0]);
  result = vcvt_s32_f32(vrnda_f32(*a1));
  *a2 = result;
  a2[1].i32[0] = v2;
  return result;
}

double convert@<D0>(double *a1@<X0>, _QWORD *a2@<X8>)
{
  double result;

  result = *a1;
  *a2 = *(_QWORD *)a1;
  return result;
}

float convert@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float result;

  result = *(float *)(a1 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(float *)(a2 + 8) = result;
  return result;
}

double convert@<D0>(const simd_float3x3 *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v2;
  __int32 v3;
  __int32 v4;
  double result;

  v2 = *(__int128 *)((char *)a1->columns + 4);
  v3 = a1->columns[1].i32[2];
  v4 = a1->columns[2].i32[2];
  *((_QWORD *)&v2 + 1) = a1->columns[1].i64[0];
  *(_DWORD *)a2 = a1->columns[0].i32[0];
  *(_OWORD *)(a2 + 4) = v2;
  *(_DWORD *)(a2 + 20) = v3;
  result = *(double *)a1->columns[2].i64;
  *(double *)(a2 + 24) = result;
  *(_DWORD *)(a2 + 32) = v4;
  return result;
}

__n128 convert@<Q0>(const simd_float4x4 *a1@<X0>, uint64_t a2@<X8>)
{
  simd_float4 v2;
  __n128 result;
  simd_float4 v4;

  v2 = a1->columns[1];
  *(simd_float4 *)a2 = a1->columns[0];
  *(simd_float4 *)(a2 + 16) = v2;
  result = (__n128)a1->columns[2];
  v4 = a1->columns[3];
  *(__n128 *)(a2 + 32) = result;
  *(simd_float4 *)(a2 + 48) = v4;
  return result;
}

double convert(uint64_t a1)
{
  return *(double *)a1;
}

double homogenize@<D0>(double *a1@<X0>, uint64_t a2@<X8>)
{
  double result;

  result = *a1;
  *(double *)a2 = *a1;
  *(_DWORD *)(a2 + 8) = 1065353216;
  return result;
}

float homogenize@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  float result;

  result = *(float *)(a1 + 8);
  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(float *)(a2 + 8) = result;
  *(_DWORD *)(a2 + 12) = 1065353216;
  return result;
}

double homogenize(uint64_t a1)
{
  __asm { FMOV            V0.4S, #1.0 }
  return *(double *)a1;
}

__n128 homogenize(uint64_t a1)
{
  return *(__n128 *)a1;
}

float32x2_t dehomogenize@<D0>(float32x2_t *a1@<X0>, float32x2_t *a2@<X8>)
{
  const float *v2;
  float32x2_t v3;
  float32x2_t result;

  v2 = (const float *)&a1[1];
  v3 = vld1_dup_f32(v2);
  result = vdiv_f32(*a1, v3);
  *a2 = result;
  return result;
}

float32x2_t dehomogenize@<D0>(float32x2_t *a1@<X0>, float32x2_t *a2@<X8>, double a3@<D0>)
{
  float32_t v3;
  float32x2_t result;

  LODWORD(a3) = a1[1].i32[1];
  v3 = a1[1].f32[0] / *(float *)&a3;
  result = vdiv_f32(*a1, (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a3, 0));
  *a2 = result;
  a2[1].f32[0] = v3;
  return result;
}

float32x2_t dehomogenize(uint64_t a1)
{
  return vdiv_f32(*(float32x2_t *)a1, (float32x2_t)vdup_lane_s32(*(int32x2_t *)(a1 + 8), 0));
}

float32x2_t dehomogenize(float32x2_t *a1, double a2, int32x2_t a3)
{
  a3.i32[0] = a1[1].i32[1];
  return vdiv_f32(*a1, (float32x2_t)vdup_lane_s32(a3, 0));
}

id ARStreamIdentifierForDeviceTypeAndPosition(void *a1, uint64_t a2)
{
  id v3;
  id v4;
  void *v5;

  v3 = a1;
  if (objc_msgSend(v3, "isEqualToString:", *MEMORY[0x1E0C89F80]))
  {
    v4 = (id)*MEMORY[0x1E0D040C0];
  }
  else
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@.%ld"), v3, a2);
    v4 = (id)objc_claimAutoreleasedReturnValue();
  }
  v5 = v4;

  return v5;
}

id AVCaptureDeviceTypeFromST2StreamIdentifier(void *a1)
{
  id v1;
  id v2;
  id v3;
  id v4;

  v1 = a1;
  v2 = (id)*MEMORY[0x1E0C89FA0];
  if (objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0D040C8]))
  {
    v3 = (id)*MEMORY[0x1E0C89F98];

    v2 = v3;
  }
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("JasperCamera")) & 1) != 0
    || objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0D040C0]))
  {
    v4 = (id)*MEMORY[0x1E0C89F80];

    v2 = v4;
  }

  return v2;
}

id AVCaptureDeviceTypeFromStreamIdentifier(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  id v4;
  id v5;

  v1 = a1;
  objc_msgSend(v1, "componentsSeparatedByString:", CFSTR("."));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "firstObject");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  if ((objc_msgSend(v3, "containsString:", CFSTR("AVCaptureDeviceType")) & 1) != 0)
  {
    if (objc_msgSend(v3, "isEqualToString:", CFSTR("AVCaptureDeviceTypeBuiltInSuperWideAngleCamera")))
    {
      v4 = (id)*MEMORY[0x1E0C89F98];

      v3 = v4;
    }
    v5 = v3;
    v3 = v5;
  }
  else
  {
    AVCaptureDeviceTypeFromST2StreamIdentifier(v1);
    v5 = (id)objc_claimAutoreleasedReturnValue();
  }

  return v5;
}

uint64_t AVCaptureDevicePositionFromST2StreamIdentifier(void *a1)
{
  id v1;
  uint64_t v2;

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0D040B8]) & 1) != 0
    || (objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0D040C8]) & 1) != 0
    || (objc_msgSend(v1, "isEqualToString:", CFSTR("JasperCamera")) & 1) != 0)
  {
    v2 = 1;
  }
  else
  {
    v2 = objc_msgSend(v1, "isEqualToString:", *MEMORY[0x1E0D040C0]);
  }

  return v2;
}

uint64_t AVCaptureDevicePositionFromStreamIdentifier(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  uint64_t v4;

  v1 = a1;
  if ((objc_msgSend(v1, "containsString:", CFSTR("AVCaptureDeviceType")) & 1) != 0)
  {
    objc_msgSend(v1, "componentsSeparatedByString:", CFSTR("."));
    v2 = (void *)objc_claimAutoreleasedReturnValue();

    if ((unint64_t)objc_msgSend(v2, "count") < 2)
    {
      v4 = 0;
    }
    else
    {
      objc_msgSend(v2, "objectAtIndexedSubscript:", 1);
      v3 = (void *)objc_claimAutoreleasedReturnValue();
      v4 = objc_msgSend(v3, "integerValue");

    }
    v1 = v2;
  }
  else
  {
    v4 = AVCaptureDevicePositionFromST2StreamIdentifier(v1);
  }

  return v4;
}

uint64_t ARDeviceOrientationForCameraPositionAndVideoTransform(uint64_t a1, _OWORD *a2)
{
  __int128 v4;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  CGAffineTransform v9;
  CGAffineTransform t1;

  v4 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v4;
  *(_OWORD *)&t1.tx = a2[2];
  v9 = *(CGAffineTransform *)ARVideoTransformPortrait;
  if (CGAffineTransformEqualToTransform(&t1, &v9))
    return 1;
  v6 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v6;
  *(_OWORD *)&t1.tx = a2[2];
  v9 = *(CGAffineTransform *)ARVideoTransformPortraitUpsideDown;
  if (CGAffineTransformEqualToTransform(&t1, &v9))
    return 2;
  v7 = a2[1];
  *(_OWORD *)&t1.a = *a2;
  *(_OWORD *)&t1.c = v7;
  *(_OWORD *)&t1.tx = a2[2];
  v9 = *(CGAffineTransform *)ARVideoTransformLandscapeLeft;
  if (CGAffineTransformEqualToTransform(&t1, &v9))
  {
    if (a1 == 2)
      return 4;
    else
      return 3;
  }
  else
  {
    v8 = a2[1];
    *(_OWORD *)&t1.a = *a2;
    *(_OWORD *)&t1.c = v8;
    *(_OWORD *)&t1.tx = a2[2];
    v9 = *(CGAffineTransform *)ARVideoTransformLandscapeRight;
    if (CGAffineTransformEqualToTransform(&t1, &v9))
    {
      if (a1 == 2)
        return 3;
      else
        return 4;
    }
    else if (a1 == 2)
    {
      return 1;
    }
    else
    {
      return 3;
    }
  }
}

__n128 ARVideoTransformForDeviceOrientation@<Q0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  __int128 *v2;
  __int128 v3;
  __n128 result;

  switch(a1)
  {
    case 1:
      v2 = &ARVideoTransformPortrait;
      break;
    case 2:
      v2 = &ARVideoTransformPortraitUpsideDown;
      break;
    case 4:
      v2 = &ARVideoTransformLandscapeRight;
      break;
    default:
      v2 = &ARVideoTransformLandscapeLeft;
      break;
  }
  v3 = v2[1];
  *(_OWORD *)a2 = *v2;
  *(_OWORD *)(a2 + 16) = v3;
  result = (__n128)v2[2];
  *(__n128 *)(a2 + 32) = result;
  return result;
}

id ARMetadataIdentifierForARRecordableResultsClass(objc_class *a1)
{
  void *v1;
  void *v2;
  void *v3;

  v1 = (void *)MEMORY[0x1E0CB3940];
  NSStringFromClass(a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringWithFormat:", CFSTR("%@%@"), CFSTR("mdta/com.apple.arkit.result."), v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  return v3;
}

id ARMetadataIdentifierForARSensorDataClass(uint64_t a1, uint64_t a2)
{
  id v4;
  id *v5;
  id *v6;

  if (objc_opt_class() == a1)
  {
    v5 = (id *)MEMORY[0x1E0CFCBC8];
    v6 = (id *)MEMORY[0x1E0CFCBF0];
    goto LABEL_12;
  }
  if (objc_opt_class() == a1)
  {
    v5 = (id *)MEMORY[0x1E0CFCB68];
    v6 = (id *)MEMORY[0x1E0CFCBE0];
    goto LABEL_12;
  }
  if (objc_opt_class() == a1)
  {
    v5 = (id *)MEMORY[0x1E0CFCBD0];
LABEL_14:
    v4 = *v5;
    return v4;
  }
  if (objc_opt_class() == a1)
  {
    v5 = (id *)MEMORY[0x1E0CFCBA8];
    goto LABEL_14;
  }
  if (objc_opt_class() == a1)
  {
    v5 = (id *)MEMORY[0x1E0CFCBA0];
    v6 = (id *)MEMORY[0x1E0CFCBE8];
LABEL_12:
    if (!a2)
      v5 = v6;
    goto LABEL_14;
  }
  v4 = 0;
  return v4;
}

id _ARLogGeneral_12()
{
  if (_ARLogGeneral_onceToken_14 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_14, &__block_literal_global_37);
  return (id)_ARLogGeneral_logObj_14;
}

uint64_t aggregationSizeForPointCloud(void *a1)
{
  void *v1;
  int v2;

  objc_msgSend(a1, "pointCloud");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v2 = objc_msgSend(v1, "length");

  if (v2 == 168)
    return 2;
  else
    return 4;
}

void sub_1B3ADDD50(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3ADE3E4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, os_unfair_lock_t lock)
{
  os_unfair_lock_unlock(lock);
  _Unwind_Resume(a1);
}

void sub_1B3ADE6D4(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3ADE788(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3ADE998(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

const __CFString *NSStringFromCV3DVIOReturn(unsigned int a1)
{
  if (a1 > 0x21)
    return &stru_1E6676798;
  else
    return off_1E6673D50[a1];
}

const __CFString *NSStringFromCV3DSLAMConfigReturn(unsigned int a1)
{
  NSObject *v2;
  uint8_t v3[16];

  if (a1 < 5)
    return off_1E6673E60[a1];
  _ARLogGeneral_13();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_DEBUG, "Unknown CV3DSLAMConfigReturn value passed.", v3, 2u);
  }

  return &stru_1E6676798;
}

id _ARLogGeneral_13()
{
  if (_ARLogGeneral_onceToken_15 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_15, &__block_literal_global_245);
  return (id)_ARLogGeneral_logObj_15;
}

const __CFString *NSStringFromCV3DSLAMReturn(int a1)
{
  NSObject *v2;
  uint8_t v3[16];

  if (*MEMORY[0x1E0CFCA08] == a1)
    return CFSTR("NoError");
  if (*MEMORY[0x1E0CFC9E8] == a1)
    return CFSTR("Error");
  if (*MEMORY[0x1E0CFC9F0] == a1)
    return CFSTR("InsufficientMemory");
  if (*MEMORY[0x1E0CFC9F8] == a1)
    return CFSTR("InvalidContext");
  if (*MEMORY[0x1E0CFCA00] == a1)
    return CFSTR("InvalidParameter");
  if (*MEMORY[0x1E0CFC9E0] == a1)
    return CFSTR("CMMapNotAvailable");
  _ARLogGeneral_13();
  v2 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
  {
    *(_WORD *)v3 = 0;
    _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_DEBUG, "Unknown CV3DSLAMReturn value passed.", v3, 2u);
  }

  return &stru_1E6676798;
}

const __CFString *NSStringFromCV3DPosePredictionReturn(unsigned int a1)
{
  if (a1 > 6)
    return &stru_1E6676798;
  else
    return off_1E6673E88[a1];
}

const __CFString *NSStringFromCV3DSLAMAnchorAddedResult(int a1)
{
  if (*MEMORY[0x1E0CFC940] == a1)
    return CFSTR("NoError");
  if (*MEMORY[0x1E0CFC938] == a1)
    return CFSTR("NoActiveAnchorGroup");
  if (*MEMORY[0x1E0CFC930] == a1)
    return CFSTR("InactiveAnchorGroup");
  if (*MEMORY[0x1E0CFC948] == a1)
    return CFSTR("TooManyAnchors");
  if (*MEMORY[0x1E0CFC920] == a1)
    return CFSTR("DuplicateAnchor");
  if (*MEMORY[0x1E0CFC928] == a1)
    return CFSTR("Error");
  return CFSTR("Unknown");
}

const __CFString *NSStringFromSLAMCMDataType(int a1)
{
  if (*MEMORY[0x1E0CFC970] == a1)
    return CFSTR("PoseAnchor");
  if (*MEMORY[0x1E0CFC950] == a1)
    return CFSTR("KeyframeInfo");
  if (*MEMORY[0x1E0CFC968] == a1)
    return CFSTR("ObjectsAnchor");
  if (*MEMORY[0x1E0CFC980] == a1)
    return CFSTR("RelocalizationResult");
  if (*MEMORY[0x1E0CFC978] == a1)
    return CFSTR("RegistrationData");
  if (*MEMORY[0x1E0CFC960] == a1)
    return CFSTR("ObjectAnchorRemoval");
  if (*MEMORY[0x1E0CFC988] == a1)
    return CFSTR("VIOStateAndUTCTimestamp");
  if (*MEMORY[0x1E0CFC958] == a1)
    return CFSTR("MapRegistrationStats");
  return CFSTR("Unknown");
}

const __CFString *NSStringFromCV3DSLAMCalibrationReturn(unsigned int a1)
{
  if (a1 > 6)
    return &stru_1E6676798;
  else
    return off_1E6673EC0[a1];
}

const __CFString *NSStringFromCV3DSLAMJasperPointCloudReturn(unsigned int a1)
{
  if (a1 > 2)
    return CFSTR("Unknown");
  else
    return off_1E6673EF8[a1];
}

const __CFString *NSStringFromCV3DVIOTrackingState(unsigned int a1)
{
  if (a1 > 4)
    return &stru_1E6676798;
  else
    return off_1E6673F10[a1];
}

const __CFString *NSStringFromCV3DSLAMMode(int a1)
{
  const __CFString *v1;

  if (*MEMORY[0x1E0CFC9D8] == a1)
    v1 = CFSTR("Visual");
  else
    v1 = CFSTR("Unknown");
  if (*MEMORY[0x1E0CFC9D0] == a1)
    return CFSTR("Regular");
  else
    return v1;
}

id ARGetAnchorIdentifierFromAnchorRef()
{
  uint64_t v0;
  const void *v1;
  void *v2;
  NSObject *v4;
  uint8_t buf[4];
  uint64_t v6;
  uint64_t v7;

  v7 = *MEMORY[0x1E0C80C00];
  v0 = CV3DSLAMAnchorCopyAnchorID();
  if (v0)
  {
    v1 = (const void *)v0;
    objc_msgSend(MEMORY[0x1E0CB3A28], "ar_UUIDWithCFUUIDRef:", v0);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    CFRelease(v1);
    return v2;
  }
  else
  {
    _ARLogGeneral_13();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v6 = 0;
      _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "Failed to retrieve anchor identifier %{public}@", buf, 0xCu);

    }
    return 0;
  }
}

const __CFString *NSStringFromCV3DVisualSLAMState(int a1)
{
  if (*MEMORY[0x1E0CFCAE0] == a1)
    return CFSTR("VisionOnly");
  if (*MEMORY[0x1E0CFCAE8] == a1)
    return CFSTR("VisionOnlyAndInertialInitialization");
  if (*MEMORY[0x1E0CFCAF0] == a1)
    return CFSTR("VisualInertial");
  return CFSTR("Unknown");
}

uint64_t NSErrorFromCV3DVIOTrackingState()
{
  return 0;
}

uint64_t CV3DSLAMCameraVideoModeForResolutionAndDeviceType(void *a1, double a2, double a3)
{
  void *v5;
  id v6;
  void *v7;
  id v8;
  uint64_t v9;
  id v10;
  uint64_t v11;

  v5 = (void *)MEMORY[0x1E0CB3940];
  v6 = a1;
  objc_msgSend(v5, "stringWithFormat:", CFSTR("%.0fx%.0f"), *(_QWORD *)&a2, *(_QWORD *)&a3);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = (id)*MEMORY[0x1E0C89F98];

  if (v8 == v6)
  {
    objc_msgSend(v7, "stringByAppendingString:", CFSTR("xSW"));
    v9 = objc_claimAutoreleasedReturnValue();

    v7 = (void *)v9;
  }
  v10 = objc_retainAutorelease(v7);
  objc_msgSend(v10, "UTF8String");
  v11 = CV3DSLAMCameraVideoModeFromString();

  return v11;
}

id ARVisionDataParametersForWorldTrackingOptions(void *a1)
{
  id v1;
  unsigned int v2;
  NSObject *v3;
  const __CFString *v4;
  void *AVCaptureConfig;
  NSObject *v6;
  uint64_t v8;
  _QWORD v9[2];
  uint64_t (*v10)();
  void *v11;
  uint64_t v12;
  uint64_t v13;
  uint8_t buf[4];
  id v15;
  __int16 v16;
  const __CFString *v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  v13 = 0;
  v2 = objc_msgSend(v1, "createSLAMCalibration:", &v13);
  v9[0] = MEMORY[0x1E0C809B0];
  v9[1] = 3221225472;
  v10 = __ARVisionDataParametersForWorldTrackingOptions_block_invoke;
  v11 = &__block_descriptor_40_e5_v8__0l;
  v12 = v13;
  if (v2)
  {
    _ARLogGeneral_13();
    v3 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      if (v2 > 6)
        v4 = &stru_1E6676798;
      else
        v4 = off_1E6673F38[v2 - 1];
      *(_DWORD *)buf = 138543618;
      v15 = v1;
      v16 = 2114;
      v17 = v4;
      _os_log_impl(&dword_1B3A68000, v3, OS_LOG_TYPE_ERROR, "Error building slam calibration, unable to fetch vision data output parameters for %{public}@: %{public}@", buf, 0x16u);
    }

    AVCaptureConfig = 0;
  }
  else
  {
    v8 = 0;
    objc_msgSend(v1, "createSLAMConfig:calibration:", &v8);
    AVCaptureConfig = (void *)CV3DSLAMConfigCreateAVCaptureConfig();
    CV3DSLAMConfigRelease();
    if (!AVCaptureConfig)
    {
      _ARLogGeneral_13();
      v6 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 138543618;
        v15 = v1;
        v16 = 2112;
        v17 = 0;
        _os_log_impl(&dword_1B3A68000, v6, OS_LOG_TYPE_ERROR, "Error reading vision data output parameters for %{public}@: %@", buf, 0x16u);
      }

    }
  }
  ((void (*)(_QWORD *))v10)(v9);

  return AVCaptureConfig;
}

void sub_1B3ADF268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, void (*a13)(char *))
{
  a13(&a11);
  _Unwind_Resume(a1);
}

uint64_t ARParseAndAddCameraCalibrationParameters(void *a1)
{
  id v1;
  void *v2;
  int v3;
  void *v4;
  int v5;
  BOOL v6;
  NSObject *v7;
  uint64_t v8;
  uint64_t v9;
  NSObject *v10;
  void *v11;
  NSObject *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  NSObject *v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  void *v22;
  void *v23;
  NSObject *v24;
  void *v25;
  uint64_t v26;
  void *v27;
  uint64_t v28;
  void *v29;
  NSObject *v30;
  uint64_t v31;
  void *v32;
  uint64_t v33;
  void *v34;
  void *v35;
  uint64_t v36;
  void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  NSObject *v41;
  const __CFString *v42;
  void *v44;
  void *v45;
  void *v46;
  NSObject *v47;
  void *v48;
  void *v49;
  NSObject *v50;
  uint8_t v51[4];
  const char *v52;
  __int16 v53;
  const __CFString *v54;
  _QWORD buf[4];
  __int128 v56;
  __int128 v57;
  uint64_t v58;
  _QWORD v59[5];
  _OWORD v60[2];
  uint64_t v61;

  v61 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyImageWidth);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = objc_msgSend(v2, "intValue");

  objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyImageHeight);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = objc_msgSend(v4, "intValue");

  if (v3)
    v6 = v5 == 0;
  else
    v6 = 1;
  if (v6)
  {
    _ARLogGeneral_13();
    v7 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136446722;
      *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *__"
                                     "strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, const "
                                     "uint32_t, const uint32_t)";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = v3;
      WORD1(buf[2]) = 1024;
      HIDWORD(buf[2]) = v5;
      _os_log_impl(&dword_1B3A68000, v7, OS_LOG_TYPE_ERROR, "%{public}s: wrong width (%d) or height(%d)", (uint8_t *)buf, 0x18u);
    }
    v8 = 1;
  }
  else
  {
    objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyLensType);
    v9 = objc_claimAutoreleasedReturnValue();
    v7 = v9;
    if (v9)
    {
      objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyCameraMatrix);
      v10 = objc_claimAutoreleasedReturnValue();
      -[NSObject componentsSeparatedByString:](v10, "componentsSeparatedByString:", CFSTR(","));
      v11 = (void *)objc_claimAutoreleasedReturnValue();
      if ((unint64_t)objc_msgSend(v11, "count") > 8)
      {
        objc_msgSend(v11, "objectAtIndex:", 0);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "floatValue");

        objc_msgSend(v11, "objectAtIndex:", 4);
        v14 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "floatValue");

        objc_msgSend(v11, "objectAtIndex:", 2);
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "floatValue");

        objc_msgSend(v11, "objectAtIndex:", 5);
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v16, "floatValue");

        objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyRadialDistortion);
        v12 = objc_claimAutoreleasedReturnValue();
        -[NSObject componentsSeparatedByString:](v12, "componentsSeparatedByString:", CFSTR(","));
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        if ((unint64_t)objc_msgSend(v17, "count") > 2)
        {
          v50 = v12;
          v19 = 0;
          memset(v60, 0, sizeof(v60));
          do
          {
            objc_msgSend(v17, "objectAtIndex:", v19);
            v20 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v20, "doubleValue");
            *((_QWORD *)v60 + v19) = v21;

            ++v19;
          }
          while (v19 != 4);
          objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyTangentialDistortion);
          v22 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v22, "componentsSeparatedByString:", CFSTR(","));
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          if ((unint64_t)objc_msgSend(v23, "count") >= 2)
          {
            objc_msgSend(v23, "objectAtIndex:", 0);
            v25 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v25, "doubleValue");
            v59[3] = v26;
            v49 = v23;
            objc_msgSend(v23, "objectAtIndex:", 1);
            v27 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v27, "doubleValue");
            v59[4] = v28;

            objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuPosition);
            v48 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v48, "componentsSeparatedByString:", CFSTR(","));
            v29 = (void *)objc_claimAutoreleasedReturnValue();
            if ((unint64_t)objc_msgSend(v29, "count") > 2)
            {
              v45 = v11;
              v46 = v22;
              v47 = v10;
              v31 = 0;
              memset(v59, 0, 24);
              do
              {
                objc_msgSend(v29, "objectAtIndex:", v31);
                v32 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v32, "doubleValue");
                v59[v31] = v33;

                ++v31;
              }
              while (v31 != 3);
              objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuRotation);
              v34 = (void *)objc_claimAutoreleasedReturnValue();
              objc_msgSend(v34, "componentsSeparatedByString:", CFSTR(","));
              v35 = (void *)objc_claimAutoreleasedReturnValue();
              if ((unint64_t)objc_msgSend(v35, "count") >= 9)
              {
                v44 = v34;
                v36 = 0;
                v58 = 0;
                v56 = 0u;
                v57 = 0u;
                memset(buf, 0, sizeof(buf));
                do
                {
                  objc_msgSend(v35, "objectAtIndex:", v36);
                  v37 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v37, "doubleValue");
                  buf[v36] = v38;

                  ++v36;
                }
                while (v36 != 9);
                objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyTimestampCorrectionForCamera);
                v39 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v39, "doubleValue");

                objc_msgSend(v1, "objectForKeyedSubscript:", ARWorldTrackingBackWideCalibrationParametersKeyCameraReadoutTime);
                v40 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v40, "doubleValue");

                ARGetCV3DCameraLensDistortionModelFromLensType(v7);
                v8 = CV3DSLAMCalibrationAddCameraParameters2();
                v22 = v46;
                v23 = v49;
                if ((_DWORD)v8)
                {
                  _ARLogGeneral_13();
                  v41 = objc_claimAutoreleasedReturnValue();
                  if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
                  {
                    if (v8 > 6)
                      v42 = &stru_1E6676798;
                    else
                      v42 = off_1E6673F38[(int)v8 - 1];
                    *(_DWORD *)v51 = 136315394;
                    v52 = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *__strong _Non"
                          "null, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, const uint32_t, const uint32_t)";
                    v53 = 2112;
                    v54 = v42;
                    _os_log_impl(&dword_1B3A68000, v41, OS_LOG_TYPE_ERROR, "%s: CV3DSLAMCalibrationAddCameraParameters failed (result=%@)", v51, 0x16u);
                  }

                }
                v34 = v44;
              }
              else
              {
                v8 = 1;
                v22 = v46;
                v23 = v49;
              }

              v10 = v47;
              v11 = v45;
            }
            else
            {
              _ARLogGeneral_13();
              v30 = objc_claimAutoreleasedReturnValue();
              if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
              {
                LODWORD(buf[0]) = 136315394;
                *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDict"
                                               "ionary *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSL"
                                               "AMCameraMode, const uint32_t, const uint32_t)";
                WORD2(buf[1]) = 1024;
                *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v29, "count");
                _os_log_impl(&dword_1B3A68000, v30, OS_LOG_TYPE_ERROR, "%s: wrong cameraToImuPositionArray (cameraToImuPositionArray=%d)", (uint8_t *)buf, 0x12u);
              }

              v8 = 1;
              v23 = v49;
            }

          }
          else
          {
            _ARLogGeneral_13();
            v24 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              LODWORD(buf[0]) = 136315394;
              *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictio"
                                             "nary *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCa"
                                             "meraMode, const uint32_t, const uint32_t)";
              WORD2(buf[1]) = 1024;
              *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v23, "count");
              _os_log_impl(&dword_1B3A68000, v24, OS_LOG_TYPE_ERROR, "%s: wrong tangentialDistortionArray (tangentialDistortionArray.count=%d)", (uint8_t *)buf, 0x12u);
            }

            v8 = 1;
          }
          v12 = v50;

        }
        else
        {
          _ARLogGeneral_13();
          v18 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
          {
            LODWORD(buf[0]) = 136315394;
            *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictiona"
                                           "ry *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCamera"
                                           "Mode, const uint32_t, const uint32_t)";
            WORD2(buf[1]) = 1024;
            *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v17, "count");
            _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_ERROR, "%s: wrong radialDistortionArray array (radialDistortionArray.count=%d)", (uint8_t *)buf, 0x12u);
          }

          v8 = 1;
        }

      }
      else
      {
        _ARLogGeneral_13();
        v12 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
        {
          LODWORD(buf[0]) = 136446466;
          *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary"
                                         " *__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode"
                                         ", const uint32_t, const uint32_t)";
          WORD2(buf[1]) = 1024;
          *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v11, "count");
          _os_log_impl(&dword_1B3A68000, v12, OS_LOG_TYPE_ERROR, "%{public}s: wrong Intrinsics array (intrinsicsArray.count=%d)", (uint8_t *)buf, 0x12u);
        }
        v8 = 1;
      }

    }
    else
    {
      _ARLogGeneral_13();
      v10 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddCameraCalibrationParameters(NSDictionary *"
                                       "__strong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull, CV3DSLAMCameraMode, co"
                                       "nst uint32_t, const uint32_t)";
        WORD2(buf[1]) = 2114;
        *(_QWORD *)((char *)&buf[1] + 6) = 0;
        _os_log_impl(&dword_1B3A68000, v10, OS_LOG_TYPE_ERROR, "%{public}s: wrong lens type(%{public}@)", (uint8_t *)buf, 0x16u);
      }
      v8 = 1;
    }

  }
  return v8;
}

uint64_t ARGetCV3DCameraLensDistortionModelFromLensType(void *a1)
{
  id v1;
  uint64_t v2;
  NSObject *v4;
  uint8_t v5[16];

  v1 = a1;
  if ((objc_msgSend(v1, "isEqualToString:", CFSTR("Perspective")) & 1) == 0)
  {
    if ((objc_msgSend(v1, "isEqualToString:", CFSTR("Fisheye")) & 1) != 0)
    {
      v2 = 1;
      goto LABEL_9;
    }
    if ((objc_msgSend(v1, "isEqualToString:", CFSTR("FlyoverPerspective")) & 1) != 0)
    {
      v2 = 2;
      goto LABEL_9;
    }
    if ((objc_msgSend(v1, "isEqualToString:", CFSTR("NoDistortion")) & 1) != 0)
    {
      v2 = 3;
      goto LABEL_9;
    }
    _ARLogGeneral_13();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)v5 = 0;
      _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "LensType not configured in calibration directory, defaulting to Perspective", v5, 2u);
    }

  }
  v2 = 0;
LABEL_9:

  return v2;
}

id AppleCV3DValuesFromExternalCalibrationDictionary(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  uint64_t v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  id v51;
  _QWORD v52[10];

  v52[9] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("CameraDescription"));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = v3;
  if (!v3)
    goto LABEL_34;
  objc_msgSend(v3, "objectForKeyedSubscript:", CFSTR("CameraIntrinsics"));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = v5;
  if (v5)
  {
    objc_msgSend(v5, "objectForKeyedSubscript:", CFSTR("DistortionCoefficients"));
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = v7;
    if (v7)
    {
      objc_msgSend(v7, "componentsJoinedByString:", CFSTR(","));
      v9 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v9, ARWorldTrackingBackWideCalibrationParametersKeyRadialDistortion);

    }
    objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("LensType"));
    v10 = objc_claimAutoreleasedReturnValue();
    if (v10)
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v10, ARWorldTrackingBackWideCalibrationParametersKeyLensType);
    objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("Resolution"));
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    v12 = v11;
    if (v11)
    {
      objc_msgSend(v11, "objectForKeyedSubscript:", CFSTR("Height"));
      v13 = (void *)objc_claimAutoreleasedReturnValue();
      if (v13)
        objc_msgSend(v2, "setObject:forKeyedSubscript:", v13, ARWorldTrackingBackWideCalibrationParametersKeyImageHeight);
      objc_msgSend(v12, "objectForKeyedSubscript:", CFSTR("Width"));
      v14 = (void *)objc_claimAutoreleasedReturnValue();
      if (v14)
        objc_msgSend(v2, "setObject:forKeyedSubscript:", v14, ARWorldTrackingBackWideCalibrationParametersKeyImageWidth);

    }
    v48 = v12;
    v51 = v1;
    objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("EffectiveFocusLength"));
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    v16 = v15;
    if (v15)
    {
      objc_msgSend(v15, "objectForKeyedSubscript:", CFSTR("X"));
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v16, "objectForKeyedSubscript:", CFSTR("Y"));
      v18 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v18 = 0;
      v17 = 0;
    }
    v49 = (void *)v10;
    v50 = v8;
    objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("PrincipalPoint"));
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    v20 = v19;
    v47 = v16;
    if (v19)
    {
      objc_msgSend(v19, "objectForKeyedSubscript:", CFSTR("X"));
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v20, "objectForKeyedSubscript:", CFSTR("Y"));
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      if (!v17)
        goto LABEL_24;
    }
    else
    {
      v22 = 0;
      v21 = 0;
      if (!v17)
      {
LABEL_24:
        objc_msgSend(v6, "objectForKeyedSubscript:", CFSTR("TangentialDistortionCoefficients"));
        v26 = (void *)objc_claimAutoreleasedReturnValue();
        v27 = v26;
        if (v26)
        {
          objc_msgSend(v26, "componentsJoinedByString:", CFSTR(","));
          v28 = v17;
          v29 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "setObject:forKeyedSubscript:", v29, ARWorldTrackingBackWideCalibrationParametersKeyTangentialDistortion);

          v17 = v28;
        }
        objc_msgSend(v2, "setObject:forKeyedSubscript:", &unk_1E66CF180, ARWorldTrackingBackWideCalibrationParametersKeyCameraReadoutTime);

        v1 = v51;
        goto LABEL_27;
      }
    }
    if (v18 && v21 && v22)
    {
      v52[0] = v17;
      v52[1] = &unk_1E66CF160;
      v52[2] = v21;
      v52[3] = &unk_1E66CF160;
      v52[4] = v18;
      v52[5] = v22;
      v52[6] = &unk_1E66CF160;
      v52[7] = &unk_1E66CF160;
      v52[8] = &unk_1E66CF170;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v52, 9);
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "componentsJoinedByString:", CFSTR(","));
      v24 = v17;
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v25, ARWorldTrackingBackWideCalibrationParametersKeyCameraMatrix);

      v17 = v24;
    }
    goto LABEL_24;
  }
LABEL_27:
  objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("RotationIMUToCamera"));
  v30 = (void *)objc_claimAutoreleasedReturnValue();
  v31 = v30;
  if (v30)
  {
    objc_msgSend(v30, "componentsJoinedByString:", CFSTR(","));
    v32 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v32, ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuRotation);

  }
  objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("TranslationCameraToIMU"));
  v33 = (void *)objc_claimAutoreleasedReturnValue();
  v34 = v33;
  if (v33)
  {
    objc_msgSend(v33, "componentsJoinedByString:", CFSTR(","));
    v35 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v35, ARWorldTrackingBackWideCalibrationParametersKeyCameraToImuPosition);

  }
  objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("TimestampCorrectionForCamera"));
  v36 = (void *)objc_claimAutoreleasedReturnValue();
  if (v36)
    objc_msgSend(v2, "setObject:forKeyedSubscript:", v36, ARWorldTrackingBackWideCalibrationParametersKeyTimestampCorrectionForCamera);

LABEL_34:
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("IMUDescription"));
  v37 = (void *)objc_claimAutoreleasedReturnValue();
  if (v37)
  {
    objc_msgSend(v4, "objectForKeyedSubscript:", CFSTR("AccelerometerTimestampCorrection"));
    v38 = (void *)objc_claimAutoreleasedReturnValue();
    if (v38)
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v38, CFSTR("AccelerometerTimestampCorrection"));
    objc_msgSend(v37, "objectForKeyedSubscript:", CFSTR("Gravity"));
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    v40 = v39;
    if (v39)
    {
      objc_msgSend(v39, "componentsJoinedByString:", CFSTR(","));
      v41 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v41, CFSTR("Gravity"));

    }
    objc_msgSend(v37, "objectForKeyedSubscript:", CFSTR("NoiseCharacteristics"));
    v42 = (void *)objc_claimAutoreleasedReturnValue();
    v43 = v42;
    if (v42)
    {
      objc_msgSend(v42, "componentsJoinedByString:", CFSTR(","));
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "setObject:forKeyedSubscript:", v44, CFSTR("ImuNoiseCharacteristics"));

    }
  }
  v45 = (void *)objc_msgSend(v2, "copy");

  return v45;
}

uint64_t ARParseAndAddImuCalibrationParameters(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  NSObject *v4;
  uint64_t v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  NSObject *v11;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  void *v15;
  NSObject *v16;
  const __CFString *v17;
  int v19;
  const char *v20;
  __int16 v21;
  const __CFString *v22;
  _QWORD buf[4];
  _QWORD v24[4];

  v24[3] = *MEMORY[0x1E0C80C00];
  v1 = a1;
  objc_msgSend(v1, "valueForKey:", CFSTR("Gravity"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "componentsSeparatedByString:", CFSTR(","));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if ((unint64_t)objc_msgSend(v3, "count") > 2)
  {
    v6 = 0;
    memset(v24, 0, 24);
    do
    {
      objc_msgSend(v3, "objectAtIndex:", v6);
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v7, "doubleValue");
      v24[v6] = v8;

      ++v6;
    }
    while (v6 != 3);
    objc_msgSend(v1, "valueForKey:", CFSTR("ImuNoiseCharacteristics"));
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "componentsSeparatedByString:", CFSTR(","));
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    if ((unint64_t)objc_msgSend(v10, "count") >= 4)
    {
      v12 = 0;
      memset(buf, 0, sizeof(buf));
      do
      {
        objc_msgSend(v10, "objectAtIndex:", v12);
        v13 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v13, "doubleValue");
        buf[v12] = v14;

        ++v12;
      }
      while (v12 != 4);
      objc_msgSend(v1, "valueForKey:", CFSTR("AccelerometerTimestampCorrection"));
      v15 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v15, "doubleValue");

      v5 = CV3DSLAMCalibrationAddIMUParameters();
      if ((_DWORD)v5)
      {
        _ARLogGeneral_13();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          if (v5 > 6)
            v17 = &stru_1E6676798;
          else
            v17 = off_1E6673F38[(int)v5 - 1];
          v19 = 136315394;
          v20 = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__strong _Nonnull, CV3DSLA"
                "MMutableCalibrationRef _Nonnull)";
          v21 = 2112;
          v22 = v17;
          _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, "%s: CV3DSLAMCalibrationAddIMUParameters failed (result=%@)", (uint8_t *)&v19, 0x16u);
        }

      }
    }
    else
    {
      _ARLogGeneral_13();
      v11 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf[0]) = 136446466;
        *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__s"
                                       "trong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull)";
        WORD2(buf[1]) = 1024;
        *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v10, "count");
        _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "%{public}s: wrong imuNoiseCharacteristicsArray (imuNoiseCharacteristicsArray.count=%d)", (uint8_t *)buf, 0x12u);
      }

      v5 = 1;
    }

  }
  else
  {
    _ARLogGeneral_13();
    v4 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136446466;
      *(_QWORD *)((char *)buf + 4) = "CV3DSLAMCalibrationReturn ARParseAndAddImuCalibrationParameters(NSDictionary *__str"
                                     "ong _Nonnull, CV3DSLAMMutableCalibrationRef _Nonnull)";
      WORD2(buf[1]) = 1024;
      *(_DWORD *)((char *)&buf[1] + 6) = objc_msgSend(v3, "count");
      _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "%{public}s: wrong gravityArray (gravityArray.count=%d)", (uint8_t *)buf, 0x12u);
    }

    v5 = 1;
  }

  return v5;
}

uint64_t ARGetLensTypeFromCalibrationDictionary(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  uint64_t v4;
  NSObject *v5;
  int v7;
  const char *v8;
  uint64_t v9;

  v9 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "objectForKey:", *MEMORY[0x1E0CFCAA8]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", *MEMORY[0x1E0CFCAB8]);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "valueForKey:", *MEMORY[0x1E0CFCAC0]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if ((objc_msgSend(v3, "isEqualToString:", CFSTR("Perspective")) & 1) != 0)
  {
    v4 = 1;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", CFSTR("Fisheye")) & 1) != 0)
  {
    v4 = 2;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", CFSTR("FlyoverPerspective")) & 1) != 0)
  {
    v4 = 3;
  }
  else if ((objc_msgSend(v3, "isEqualToString:", CFSTR("NoDistortion")) & 1) != 0)
  {
    v4 = 4;
  }
  else
  {
    _ARLogGeneral_13();
    v5 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      v7 = 136446210;
      v8 = "ARLensType ARGetLensTypeFromCalibrationDictionary(NSDictionary *__strong _Nonnull)";
      _os_log_impl(&dword_1B3A68000, v5, OS_LOG_TYPE_ERROR, "%{public}s: ARLensType not configured in calibration directory", (uint8_t *)&v7, 0xCu);
    }

    v4 = 0;
  }

  return v4;
}

float ARGetIntrinsicsFromCalibrationDictionary(void *a1)
{
  void *v1;
  const __CFDictionary *v2;
  const __CFDictionary *Value;
  const __CFDictionary *v4;
  float x;
  float v12;
  CGPoint v13;
  CGPoint point;

  objc_msgSend(a1, "objectForKey:", *MEMORY[0x1E0CFCAA8]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", *MEMORY[0x1E0CFCAB8]);
  v2 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
  point.x = 0.0;
  point.y = 0.0;
  v13.x = 0.0;
  v13.y = 0.0;
  Value = (const __CFDictionary *)CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E0CFCAB0]);
  CGPointMakeWithDictionaryRepresentation(Value, &point);
  v4 = (const __CFDictionary *)CFDictionaryGetValue(v2, (const void *)*MEMORY[0x1E0CFCAC8]);
  CGPointMakeWithDictionaryRepresentation(v4, &v13);
  x = point.x;
  v12 = x;

  __asm { FMOV            V2.4S, #1.0 }
  return v12;
}

void ARGetRadialDistortionFromCalibrationDictionary(void *a1@<X0>, _OWORD *a2@<X8>)
{
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  uint64_t v7;
  void *v8;
  uint64_t v9;
  void *v10;
  __int128 v11;
  unint64_t v12;
  __int128 v13;
  __int128 v14;
  NSObject *v15;
  uint64_t v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  uint8_t buf[4];
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "objectForKey:", *MEMORY[0x1E0CFCAA8]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0CFCAB8]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "objectForKey:", *MEMORY[0x1E0CFCAD0]);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  if ((unint64_t)objc_msgSend(v5, "count") < 3)
  {
    _ARLogGeneral_13();
    v15 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v21 = objc_msgSend(v5, "count");
      _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "ARGetRadialDistortionFromCalibrationDictionary: wrong radialDistortion coeffs (coefficients.count = %d)", buf, 8u);
    }

    v13 = 0uLL;
    v14 = 0uLL;
  }
  else
  {
    objc_msgSend(v5, "objectAtIndexedSubscript:", 0);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "doubleValue");
    v18 = v7;

    objc_msgSend(v5, "objectAtIndexedSubscript:", 1);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "doubleValue");
    v16 = v9;

    objc_msgSend(v5, "objectAtIndexedSubscript:", 2);
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "doubleValue");
    *(_QWORD *)&v11 = v18;
    *((_QWORD *)&v11 + 1) = v16;
    v19 = v11;
    v17 = v12;

    v14 = v17;
    v13 = v19;
  }
  *a2 = v13;
  a2[1] = v14;

}

__n128 ARGetTangentialDistortionFromCalibrationDictionary(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  void *v6;
  __int128 v7;
  uint64_t v8;
  NSObject *v9;
  uint64_t v11;
  __int128 v12;
  uint8_t buf[4];
  int v14;
  uint64_t v15;

  v15 = *MEMORY[0x1E0C80C00];
  objc_msgSend(a1, "objectForKey:", *MEMORY[0x1E0CFCAA8]);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKey:", *MEMORY[0x1E0CFCAB8]);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "objectForKey:", *MEMORY[0x1E0CFCAD8]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  if ((unint64_t)objc_msgSend(v3, "count") < 2)
  {
    _ARLogGeneral_13();
    v9 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 67109120;
      v14 = objc_msgSend(v3, "count");
      _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_ERROR, "ARGetTangentialDistortionFromCalibrationDictionary: wrong tangentialDistortion coeffs (coefficients.count = %d)", buf, 8u);
    }

    v12 = 0u;
  }
  else
  {
    objc_msgSend(v3, "objectAtIndexedSubscript:", 0);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v4, "doubleValue");
    v11 = v5;

    objc_msgSend(v3, "objectAtIndexedSubscript:", 1);
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v6, "doubleValue");
    *(_QWORD *)&v7 = v11;
    *((_QWORD *)&v7 + 1) = v8;
    v12 = v7;

  }
  return (__n128)v12;
}

uint64_t ARSurfaceOrientationForPlaneDetectionType(char a1)
{
  uint64_t v1;

  v1 = 3;
  if ((~a1 & 3) != 0)
  {
    if (a1 < 0)
      LODWORD(v1) = 3;
    else
      LODWORD(v1) = 1;
    if ((a1 & 0x81) != 0)
      return v1;
    else
      return a1 & 2;
  }
  return v1;
}

uint64_t ARSurfaceExtentTypeForPlaneDetectionType(__int16 a1)
{
  if ((a1 & 0x200) != 0)
    return 15;
  else
    return 7;
}

uint64_t ARPlaneClassificationForSceneUnderstandingLabel(int a1)
{
  if ((a1 - 1) > 9)
    return 0;
  else
    return qword_1B3BE4030[a1 - 1];
}

const __CFString *NSStringFromSceneUnderstandingLabel(unsigned int a1)
{
  if (a1 > 0xC)
    return CFSTR("Empty");
  else
    return off_1E6673F68[a1];
}

void ARInitializeHitTestIntent(uint64_t a1, void *a2, int a3, simd_float4 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7)
{
  ARInitializeHitTestIntentWithExtentCheck(a1, a2, a3, 2, a4, a5, a6, a7);
}

void ARInitializeHitTestIntentWithExtentCheck(uint64_t a1, void *a2, int a3, int a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  uint64_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  double *v23;
  uint64_t v24;
  int v25;
  unint64_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  simd_float4x4 v30;
  id v31;
  float32x4_t v32;
  float32x4_t v33;
  simd_float4x4 v34;

  v30.columns[2] = a7;
  v30.columns[3] = a8;
  v30.columns[0] = a5;
  v30.columns[1] = a6;
  v31 = a2;
  objc_msgSend(v31, "direction");
  v27 = v11;
  v34 = __invert_f4(v30);
  v30.columns[1] = v34.columns[0];
  v30.columns[2] = v34.columns[1];
  v30.columns[3] = v34.columns[2];
  v28 = vmlaq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v34.columns[0], v27.f32[0]), (float32x4_t)v34.columns[1], *(float32x2_t *)v27.f32, 1), (float32x4_t)v34.columns[2], v27, 2), (float32x4_t)0, (float32x4_t)v34.columns[3]);
  v30.columns[0] = v34.columns[3];
  *(double *)v12.i64 = ARRenderingToVisionCoordinateTransform();
  v29 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v12, v28.f32[0]), v13, *(float32x2_t *)v28.f32, 1), v14, v28, 2), v15, v28, 3);
  objc_msgSend(v31, "origin");
  v30.columns[3] = (simd_float4)vaddq_f32((float32x4_t)v30.columns[0], vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v30.columns[1], v16.f32[0]), (float32x4_t)v30.columns[2], *(float32x2_t *)v16.f32, 1), (float32x4_t)v30.columns[3], v16, 2));
  *(double *)v17.i64 = ARRenderingToVisionCoordinateTransform();
  v18 = 0;
  v22 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, v30.columns[3].f32[0]), v19, *(float32x2_t *)v30.columns[3].f32, 1), v20, (float32x4_t)v30.columns[3], 2), v21, (float32x4_t)v30.columns[3], 3);
  do
  {
    v32 = v22;
    v23 = (double *)(a1 + 8 * v18);
    *v23 = *(float *)((unint64_t)&v32 & 0xFFFFFFFFFFFFFFF3 | (4 * (v18 & 3)));
    v33 = v29;
    v23[3] = *(float *)((unint64_t)&v33 & 0xFFFFFFFFFFFFFFF3 | (4 * (v18++ & 3)));
  }
  while (v18 != 3);
  *(_OWORD *)(a1 + 48) = xmmword_1B3BE3A10;
  *(CFAbsoluteTime *)(a1 + 88) = CFAbsoluteTimeGetCurrent();
  *(_DWORD *)(a1 + 72) = a3;
  *(_DWORD *)(a1 + 76) = 0;
  *(_DWORD *)(a1 + 84) = 0;
  v24 = objc_msgSend(v31, "target");
  if (v24)
  {
    if (v24 == 1)
    {
      v25 = 1;
      a4 = 1;
    }
    else
    {
      if (v24 != 2)
        goto LABEL_10;
      v25 = 3;
    }
  }
  else
  {
    v25 = 1;
  }
  *(_DWORD *)(a1 + 76) = v25;
  *(_DWORD *)(a1 + 84) = a4;
LABEL_10:
  v26 = objc_msgSend(v31, "targetAlignment");
  if (v26 <= 2)
    *(_DWORD *)(a1 + 80) = dword_1B3BE4080[v26];
  *(_QWORD *)(a1 + 64) = CFUUIDCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00]);

}

void ARReleaseHitTestIntent(uint64_t a1)
{
  const void *v1;

  if (a1)
  {
    v1 = *(const void **)(a1 + 64);
    if (v1)
      CFRelease(v1);
  }
}

uint64_t ARCreateCV3DLoggingHandle(uint64_t a1, uint64_t a2)
{
  uint64_t Handle;
  int v5;
  NSObject *v6;
  NSObject *v7;
  const char *v8;
  NSObject *v9;
  os_log_type_t v10;
  uint32_t v11;
  int v12;
  NSObject *v13;
  NSObject *v14;
  const char *v15;
  NSObject *v16;
  os_log_type_t v17;
  uint32_t v18;
  int v20;
  int v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  Handle = CV3DLoggingCreateHandle();
  if (a1 < 0)
  {
    _ARLogGeneral_13();
    v7 = objc_claimAutoreleasedReturnValue();
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      goto LABEL_11;
    LOWORD(v20) = 0;
    v8 = "AppleCV3D API logging disabled";
    v9 = v7;
    v10 = OS_LOG_TYPE_INFO;
    v11 = 2;
  }
  else
  {
    v5 = CV3DLoggingEnable();
    _ARLogGeneral_13();
    v6 = objc_claimAutoreleasedReturnValue();
    v7 = v6;
    if (v5)
    {
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
        goto LABEL_11;
      v20 = 67109120;
      v21 = v5;
      v8 = "Error enabling AppleCV3D API logging: %i";
      v9 = v7;
      v10 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
        goto LABEL_11;
      v20 = 67109120;
      v21 = a1;
      v8 = "AppleCV3D API logging level enabled: %i";
      v9 = v7;
      v10 = OS_LOG_TYPE_INFO;
    }
    v11 = 8;
  }
  _os_log_impl(&dword_1B3A68000, v9, v10, v8, (uint8_t *)&v20, v11);
LABEL_11:

  if (a2 < 0)
  {
    _ARLogGeneral_13();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      LOWORD(v20) = 0;
      v15 = "AppleCV3D internal logging disabled";
      v16 = v14;
      v17 = OS_LOG_TYPE_INFO;
      v18 = 2;
LABEL_20:
      _os_log_impl(&dword_1B3A68000, v16, v17, v15, (uint8_t *)&v20, v18);
    }
  }
  else
  {
    v12 = CV3DLoggingEnableInternal();
    _ARLogGeneral_13();
    v13 = objc_claimAutoreleasedReturnValue();
    v14 = v13;
    if (v12)
    {
      if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
      {
        v20 = 67109120;
        v21 = v12;
        v15 = "Error enabling AppleCV3D internal logging: %i";
        v16 = v14;
        v17 = OS_LOG_TYPE_ERROR;
LABEL_19:
        v18 = 8;
        goto LABEL_20;
      }
    }
    else if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
    {
      v20 = 67109120;
      v21 = a2;
      v15 = "AppleCV3D internal logging level enabled: %i";
      v16 = v14;
      v17 = OS_LOG_TYPE_INFO;
      goto LABEL_19;
    }
  }

  return Handle;
}

id ARAnchorsFromCV3DAnchorsArray(void *a1, void *a2, double a3)
{
  id v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  const void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  NSObject *v15;
  NSObject *v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  uint64_t v21;
  simd_float4 v22;
  uint64_t v23;
  simd_float4 v24;
  simd_float4 v25;
  simd_float4 v26;
  ARAnchor *v27;
  NSObject *v28;
  id v30;
  id v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  simd_float4x4 v36;
  simd_float4x4 v37;
  uint8_t buf[16];
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  uint64_t v42;
  simd_float4x4 v43;

  v42 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  v30 = a2;
  v6 = objc_msgSend(v5, "count");
  objc_msgSend(MEMORY[0x1E0C99E20], "setWithCapacity:", v6);
  v31 = (id)objc_claimAutoreleasedReturnValue();
  if (v6)
  {
    v7 = 0;
    v8 = 0x1E0CB3000uLL;
    do
    {
      objc_msgSend(v5, "objectAtIndex:", v7);
      v9 = CV3DSLAMAnchorCopyAnchorID();
      if (v9)
      {
        v10 = (const void *)v9;
        objc_msgSend(*(id *)(v8 + 2600), "ar_UUIDWithCFUUIDRef:", v9);
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        CFRelease(v10);
        v12 = (void *)CV3DSLAMAnchorCopySessionID();
        v13 = v12;
        if (v12)
        {
          objc_msgSend(*(id *)(v8 + 2600), "ar_UUIDWithIntegerValue:", objc_msgSend(v12, "integerValue"));
          v14 = (void *)objc_claimAutoreleasedReturnValue();
        }
        else
        {
          _ARLogGeneral_13();
          v16 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v16, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = 0;
            _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_INFO, "Unable to parse SLAM anchor session identifier: %@", buf, 0xCu);

            v8 = 0x1E0CB3000;
          }

          v14 = 0;
        }
        if ((CV3DSLAMAnchorCopyPose() & 1) != 0)
        {
          v43.columns[2] = 0u;
          v43.columns[3] = 0u;
          v43.columns[0] = 0u;
          v43.columns[1] = 0u;
          v36 = __invert_f4(v43);
          *(double *)v17.i64 = ARVisionToRenderingCoordinateTransform();
          v21 = 0;
          v37 = v36;
          *(_OWORD *)buf = 0u;
          v39 = 0u;
          v40 = 0u;
          v41 = 0u;
          do
          {
            *(float32x4_t *)&buf[v21 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(_OWORD *)&v37.columns[v21])), v18, *(float32x2_t *)v37.columns[v21].f32, 1), v19, (float32x4_t)v37.columns[v21], 2), v20, (float32x4_t)v37.columns[v21], 3);
            ++v21;
          }
          while (v21 != 4);
          v34 = v39;
          v35 = *(float32x4_t *)buf;
          v32 = v41;
          v33 = v40;
          *(double *)v22.i64 = ARRenderingToVisionCoordinateTransform();
          v23 = 0;
          v37.columns[0] = v22;
          v37.columns[1] = v24;
          v37.columns[2] = v25;
          v37.columns[3] = v26;
          *(_OWORD *)buf = 0u;
          v39 = 0u;
          v40 = 0u;
          v41 = 0u;
          do
          {
            *(float32x4_t *)&buf[v23 * 16] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(_OWORD *)&v37.columns[v23])), v34, *(float32x2_t *)v37.columns[v23].f32, 1), v33, (float32x4_t)v37.columns[v23], 2), v32, (float32x4_t)v37.columns[v23], 3);
            ++v23;
          }
          while (v23 != 4);
          v27 = -[ARAnchor initWithIdentifier:transform:]([ARAnchor alloc], "initWithIdentifier:transform:", v11, *(double *)buf, *(double *)v39.i64, *(double *)v40.i64, *(double *)v41.i64);
          -[ARAnchor setSessionIdentifier:](v27, "setSessionIdentifier:", v14);
          -[ARAnchor setLastUpdateTimestamp:](v27, "setLastUpdateTimestamp:", a3);
          objc_msgSend(v31, "addObject:", v27);

        }
        else
        {
          _ARLogGeneral_13();
          v28 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 138412290;
            *(_QWORD *)&buf[4] = 0;
            _os_log_impl(&dword_1B3A68000, v28, OS_LOG_TYPE_ERROR, "Unable to parse SLAM anchor transform: %@", buf, 0xCu);

            v8 = 0x1E0CB3000;
          }

        }
      }
      else
      {
        _ARLogGeneral_13();
        v15 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 138412290;
          *(_QWORD *)&buf[4] = 0;
          _os_log_impl(&dword_1B3A68000, v15, OS_LOG_TYPE_ERROR, "Unable to parse SLAM anchor identifier: %@", buf, 0xCu);

        }
      }
      ++v7;
    }
    while (v7 != v6);
  }

  return v31;
}

uint64_t ARRequestIDsFromSLAMAnchorUpdate()
{
  return MEMORY[0x1E0C9AA60];
}

id ARGetAnchorIdentifierFromCMData(uint64_t a1)
{
  NSObject *v2;
  void *v3;
  void *v4;
  __int128 v5;
  char v6;
  uint8_t buf[24];
  uint64_t v8;

  v8 = *MEMORY[0x1E0C80C00];
  v6 = 0;
  v5 = 0uLL;
  v4 = 0;
  if (MEMORY[0x1B5E2CA78](a1, &v6, &v5, &v4))
  {
    *(_OWORD *)buf = v5;
    return (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB3A28]), "initWithUUIDBytes:", buf);
  }
  else
  {
    _ARLogGeneral_13();
    v2 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      v3 = v4;
      *(_DWORD *)buf = 138412290;
      *(_QWORD *)&buf[4] = v4;
      _os_log_impl(&dword_1B3A68000, v2, OS_LOG_TYPE_ERROR, "Unable to parse anchor metadata: %@", buf, 0xCu);

    }
    return 0;
  }
}

__n128 ARCV3DColorComponentsForRawSemantics(unint64_t a1)
{
  __n128 result;
  __int128 *v3;

  if (ARDeviceSupportsJasper())
  {
    if (_CV3DColorMappingForRawSemantics_onceToken != -1)
      dispatch_once(&_CV3DColorMappingForRawSemantics_onceToken, &__block_literal_global_250);
    result.n128_u64[0] = 0;
    if (a1 <= 0x64)
    {
      v3 = &_CV3DColorMappingForRawSemantics_cv3DColors;
      return (__n128)v3[a1];
    }
  }
  else
  {
    if (_CV3DColorComponentsFor12ClassModelIndex_onceToken != -1)
      dispatch_once(&_CV3DColorComponentsFor12ClassModelIndex_onceToken, &__block_literal_global_251);
    result.n128_u64[0] = 0;
    if (a1 <= 0xB)
    {
      v3 = &_CV3DColorComponentsFor12ClassModelIndex_cv3DColors;
      return (__n128)v3[a1];
    }
  }
  return result;
}

uint64_t _CV3DRawSemanticsValueForARKitSemantics(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 6)
    return 0;
  else
    return qword_1B3BE4090[a1 - 1];
}

__int128 *ARCV3DColorComponentsForARKitSemanticsLUT8Elements()
{
  if (ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken != -1)
    dispatch_once(&ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken, &__block_literal_global_38);
  return &ARCV3DColorComponentsForARKitSemanticsLUT8Elements_cv3DColors;
}

__n128 ARCV3DColorComponentsForARKitSemantics(unint64_t a1)
{
  __n128 result;

  if (ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken != -1)
    dispatch_once(&ARCV3DColorComponentsForARKitSemanticsLUT8Elements_onceToken, &__block_literal_global_38);
  result.n128_u64[0] = 0;
  if (a1 <= 7)
    return (__n128)ARCV3DColorComponentsForARKitSemanticsLUT8Elements_cv3DColors[a1];
  return result;
}

void sub_1B3AE1B68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AE1C20(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AE1C90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AE1FF4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AE20B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AE2178(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AE232C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3AE24B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3AE2664(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AE2718(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AE27FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id _ARLogSensor_3()
{
  if (_ARLogSensor_onceToken_6 != -1)
    dispatch_once(&_ARLogSensor_onceToken_6, &__block_literal_global_216_0);
  return (id)_ARLogSensor_logObj_6;
}

id _ARLogGeneral_14()
{
  if (_ARLogGeneral_onceToken_16 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_16, &__block_literal_global_324);
  return (id)_ARLogGeneral_logObj_16;
}

id _ARLogSensor_4()
{
  if (_ARLogSensor_onceToken_7 != -1)
    dispatch_once(&_ARLogSensor_onceToken_7, &__block_literal_global_327);
  return (id)_ARLogSensor_logObj_7;
}

id _ARLogGeneral_15()
{
  if (_ARLogGeneral_onceToken_17 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_17, &__block_literal_global_41);
  return (id)_ARLogGeneral_logObj_17;
}

id _ARLogTechnique_3()
{
  if (_ARLogTechnique_onceToken_5 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_5, &__block_literal_global_355);
  return (id)_ARLogTechnique_logObj_5;
}

double HeadingFromRot(uint64_t a1)
{
  double v1;
  double v2;
  double result;

  v1 = *(double *)(a1 + 64);
  v2 = *(double *)(a1 + 72);
  if (v2 * v2 + v1 * v1 < 0.01)
    return NAN;
  result = atan2(-v1, -v2) * 0.318309886 * 180.0;
  if (fabs(result) < 0.001)
    result = 0.0;
  if (result < 0.0)
    result = result + 360.0;
  if (result >= 360.0)
    HeadingFromRot();
  return result;
}

__n128 MatrixFromTransform4Dof@<Q0>(__n128 *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v4;
  __double2 v5;
  __int128 v11;
  __n128 result;

  v5 = __sincos_stret(a1[1].n128_f64[1] * 3.14159265 / 180.0);
  *(double *)&v4 = v5.__cosval;
  __asm { FMOV            V2.2D, #1.0 }
  *(_QWORD *)&_Q2 = a1[1].n128_u64[0];
  *(double *)&v11 = -v5.__sinval;
  *((_QWORD *)&v11 + 1) = *(_QWORD *)&v5.__cosval;
  *((_QWORD *)&v4 + 1) = *(_QWORD *)&v5.__sinval;
  result = *a1;
  *(_OWORD *)a2 = v4;
  *(_OWORD *)(a2 + 16) = 0u;
  *(_OWORD *)(a2 + 32) = v11;
  *(_OWORD *)(a2 + 48) = 0u;
  *(_OWORD *)(a2 + 64) = 0u;
  *(_OWORD *)(a2 + 80) = xmmword_1B3BE4160;
  *(__n128 *)(a2 + 96) = result;
  *(_OWORD *)(a2 + 112) = _Q2;
  return result;
}

void Transform4DofFromMatrix(const simd_double4x4 *a1@<X0>, uint64_t a2@<X8>)
{
  double v4;

  v4 = atan2(a1->columns[0].f64[0], a1->columns[1].f64[0]) * 0.318309886 * 180.0 + -90.0;
  if (v4 < 0.0)
    v4 = v4 + 360.0;
  *(_OWORD *)a2 = *(_OWORD *)a1->columns[3].f64;
  *(double *)(a2 + 16) = a1->columns[3].f64[2];
  *(double *)(a2 + 24) = v4;
  *(_BYTE *)(a2 + 32) = 0;
}

float64x2_t *ConvertIMU@<X0>(float64x2_t *result@<X0>, uint64_t a2@<X8>)
{
  uint64_t v2;
  float64x2_t v3;
  float64x2_t v4;
  float64x2_t v5;
  float64x2_t v6;
  float64x2_t v7;
  float64x2_t v8;
  float64x2_t v9;
  float64x2_t v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t *v13;
  _OWORD v14[8];

  v2 = 0;
  v4 = *result;
  v3 = result[1];
  v6 = result[2];
  v5 = result[3];
  v8 = result[4];
  v7 = result[5];
  v10 = result[6];
  v9 = result[7];
  v14[2] = xmmword_1B3BE4180;
  memset(&v14[3], 0, 32);
  v14[5] = xmmword_1B3BE4180;
  v14[6] = 0u;
  v14[7] = xmmword_1B3BE4190;
  do
  {
    v12 = (float64x2_t)v14[v2];
    v11 = (float64x2_t)v14[v2 + 1];
    v13 = (float64x2_t *)(a2 + v2 * 16);
    *v13 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v4, v12.f64[0]), v6, v12, 1), v8, v11.f64[0]), v10, v11, 1);
    v13[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v3, v12.f64[0]), v5, v12, 1), v7, v11.f64[0]), v9, v11, 1);
    v2 += 2;
  }
  while (v2 != 8);
  return result;
}

id ARTechniqueProcessDataClassApprovedList()
{
  if (ARTechniqueProcessDataClassApprovedList_onceToken != -1)
    dispatch_once(&ARTechniqueProcessDataClassApprovedList_onceToken, &__block_literal_global_43);
  return (id)ARTechniqueProcessDataClassApprovedList_techniqueProcessDataClassApprovedList;
}

id ARTechniqueResultDataClassApprovedList()
{
  if (ARTechniqueResultDataClassApprovedList_onceToken != -1)
    dispatch_once(&ARTechniqueResultDataClassApprovedList_onceToken, &__block_literal_global_26_0);
  return (id)ARTechniqueResultDataClassApprovedList_techniqueResultDataClassApprovedList;
}

id ARRemoteTechniqueClientInterfaceWithProtocol(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;

  objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  ARTechniqueResultDataClassApprovedList();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_techniqueDidOutputResultData_timestamp_context_, 0, 0);

  ARTechniqueResultDataClassApprovedList();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v3, sel_techniqueDidOutputResultData_timestamp_context_, 2, 0);

  return v1;
}

id ARRemoteTechniqueServiceInterfaceWithProtocol(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  ARTechniqueProcessDataClassApprovedList();
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v2, sel_processData_reply_, 0, 0);

  ARTechniqueProcessDataClassApprovedList();
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v3, sel_processData_reply_, 0, 1);

  ARTechniqueResultDataClassApprovedList();
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setClasses:forSelector:argumentIndex:ofReply:", v4, sel_requestResultDataAtTimestamp_context_, 1, 0);

  return v1;
}

id _ARLogTechnique_4()
{
  if (_ARLogTechnique_onceToken_6 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_6, &__block_literal_global_189);
  return (id)_ARLogTechnique_logObj_6;
}

void sub_1B3AEEEE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AEEFE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AEF0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AEF2D0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__1(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__1(uint64_t a1)
{

}

void sub_1B3AEF448(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AEF510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3AEF5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_16()
{
  if (_ARLogGeneral_onceToken_18 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_18, &__block_literal_global_81_0);
  return (id)_ARLogGeneral_logObj_18;
}

id _ARLogTechnique_5()
{
  if (_ARLogTechnique_onceToken_7 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_7, &__block_literal_global_45);
  return (id)_ARLogTechnique_logObj_7;
}

void sub_1B3AF18E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, void (*a17)(char *))
{
  a17(&a15);
  _Unwind_Resume(a1);
}

float arkit::gaussian(arkit *this, float a2, float a3)
{
  float v3;

  v3 = a3 * 6.28318531;
  return expf((float)-(float)(a2 * a2) / (float)(a3 + a3)) * (float)(1.0 / sqrtf(v3));
}

float arkit::invgaussian(arkit *this, float a2, float a3)
{
  float v4;

  v4 = a3 * 6.28318531;
  return sqrtf(-(float)(logf(sqrtf(v4) * a2) * (float)(a3 + a3)));
}

void arkit::gaussianKernel(arkit *this@<X0>, float a2@<S0>, float **a3@<X8>)
{
  int v3;
  float *v5;
  float *v6;
  float *v7;
  uint64_t v8;
  float *v9;
  float *v10;
  int v11;
  float *v12;
  int v13;
  unsigned int v14;
  float v15;
  float v16;
  float v17;
  _QWORD *v18;
  float v19;
  float v20;
  float *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  float *v27;
  float *v28;
  int v29;
  float *i;

  if ((int)this <= 0)
    arkit::gaussianKernel();
  v3 = (int)this;
  if ((this & 0x80000001) != 1)
    arkit::gaussianKernel();
  *a3 = 0;
  a3[1] = 0;
  a3[2] = 0;
  if (a2 == 0.0)
  {
    v5 = (float *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), 1uLL);
    v6 = *a3;
    v7 = a3[1];
    v9 = &v5[v8];
    *v5 = 1.0;
    v10 = v5 + 1;
    while (v7 != v6)
    {
      v11 = *((_DWORD *)v7-- - 1);
      *((_DWORD *)v5-- - 1) = v11;
    }
    *a3 = v5;
    a3[1] = v10;
    a3[2] = v9;
    if (v6)
      operator delete(v6);
    a3[1] = v10;
  }
  else
  {
    v12 = 0;
    v13 = 0;
    v14 = ((_DWORD)this - 1) >> 1;
    v15 = a2 * 6.28318531;
    v16 = 1.0 / sqrtf(v15);
    v17 = a2 + a2;
    v18 = a3 + 2;
    v19 = 0.0;
    do
    {
      v20 = v16 * expf((float)-(float)((float)(int)(v13 - v14) * (float)(int)(v13 - v14)) / v17);
      if ((unint64_t)v12 >= *v18)
      {
        v21 = *a3;
        v22 = v12 - *a3;
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62)
          std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
        v24 = *v18 - (_QWORD)v21;
        if (v24 >> 1 > v23)
          v23 = v24 >> 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
          v25 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        if (v25)
        {
          v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v25);
          v21 = *a3;
          v12 = a3[1];
        }
        else
        {
          v26 = 0;
        }
        v27 = (float *)&v26[4 * v22];
        *v27 = v20;
        v28 = v27 + 1;
        while (v12 != v21)
        {
          v29 = *((_DWORD *)v12-- - 1);
          *((_DWORD *)v27-- - 1) = v29;
        }
        *a3 = v27;
        a3[1] = v28;
        a3[2] = (float *)&v26[4 * v25];
        if (v21)
          operator delete(v21);
        v12 = v28;
      }
      else
      {
        *v12++ = v20;
      }
      a3[1] = v12;
      v19 = v19 + *(v12 - 1);
      ++v13;
    }
    while (v13 != v3);
    for (i = *a3; i != v12; ++i)
      *i = *i / v19;
  }
}

void sub_1B3AF1EB4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::unflatten(uint64_t *a1@<X0>, uint64_t *a2@<X8>, double a3@<D0>)
{
  uint64_t *v3;
  uint64_t v4;
  uint64_t i;
  uint64_t *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _DWORD *v10;
  _DWORD **v11;
  unint64_t v12;
  _QWORD *v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v25;
  void *__p;
  void *v27;
  uint64_t v28;

  v3 = a2;
  v25 = LODWORD(a3);
  if (LODWORD(a3) * HIDWORD(a3) != (a1[1] - *a1) >> 2)
    arkit::unflatten();
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (HIDWORD(a3))
  {
    v4 = 0;
    v23 = HIDWORD(a3);
    do
    {
      __p = 0;
      v27 = 0;
      v28 = 0;
      std::vector<std::vector<float>>::push_back[abi:ne180100](v3, (uint64_t)&__p);
      if (__p)
      {
        v27 = __p;
        operator delete(__p);
      }
      if ((_DWORD)v25)
      {
        for (i = 0; i != v25; ++i)
        {
          v6 = v3;
          v7 = *v3 + 24 * v4;
          v8 = (v25 * v4 + i);
          v9 = *a1;
          v11 = (_DWORD **)(v7 + 8);
          v10 = *(_DWORD **)(v7 + 8);
          v13 = (_QWORD *)(v7 + 16);
          v12 = *(_QWORD *)(v7 + 16);
          if ((unint64_t)v10 >= v12)
          {
            v15 = *(_DWORD **)v7;
            v16 = ((uint64_t)v10 - *(_QWORD *)v7) >> 2;
            v17 = v16 + 1;
            if ((unint64_t)(v16 + 1) >> 62)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v18 = v12 - (_QWORD)v15;
            if (v18 >> 1 > v17)
              v17 = v18 >> 1;
            if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL)
              v19 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v19 = v17;
            if (v19)
            {
              v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v13, v19);
              v10 = *v11;
              v15 = *(_DWORD **)v7;
            }
            else
            {
              v20 = 0;
            }
            v21 = &v20[4 * v16];
            *(_DWORD *)v21 = *(_DWORD *)(v9 + 4 * v8);
            v14 = v21 + 4;
            v3 = v6;
            while (v10 != v15)
            {
              v22 = *--v10;
              *((_DWORD *)v21 - 1) = v22;
              v21 -= 4;
            }
            *(_QWORD *)v7 = v21;
            *v11 = v14;
            *v13 = &v20[4 * v19];
            if (v15)
              operator delete(v15);
          }
          else
          {
            *v10 = *(_DWORD *)(v9 + 4 * v8);
            v14 = v10 + 1;
          }
          *v11 = v14;
        }
      }
      ++v4;
    }
    while (v4 != v23);
  }
}

void sub_1B3AF209C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13)
{
  void *v13;
  void *v14;

  v14 = v13;
  if (__p)
  {
    a13 = (uint64_t)__p;
    operator delete(__p);
  }
  __p = v14;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::vector<float>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  _QWORD v16[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v16);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B3AF21FC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

void arkit::unflatten(_QWORD *a1@<X0>, uint64_t *a2@<X8>, __n128 a3@<Q0>)
{
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _DWORD *v14;
  _DWORD **v15;
  unint64_t v16;
  _QWORD *v17;
  _DWORD *v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;
  _DWORD *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  int v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  void *__p;
  void *v37;
  uint64_t v38;
  void **p_p;

  v3 = a3.n128_u32[0];
  v32 = a3.n128_u32[1];
  if (a3.n128_u32[0] * a3.n128_u32[1] * a3.n128_u32[2] != (uint64_t)(a1[1] - *a1) >> 2)
    arkit::unflatten();
  *a2 = 0;
  a2[1] = 0;
  a2[2] = 0;
  if (a3.n128_u32[2])
  {
    v4 = a1;
    v5 = 0;
    v30 = a3.n128_u32[2];
    do
    {
      __p = 0;
      v37 = 0;
      v38 = 0;
      std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](a2, (uint64_t)&__p);
      p_p = &__p;
      std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
      if ((_DWORD)v32)
      {
        v6 = 0;
        v31 = v32 * v5;
        do
        {
          v34 = v6;
          v7 = (uint64_t *)(*a2 + 24 * v5);
          __p = 0;
          v37 = 0;
          v38 = 0;
          std::vector<std::vector<float>>::push_back[abi:ne180100](v7, (uint64_t)&__p);
          if (__p)
          {
            v37 = __p;
            operator delete(__p);
          }
          v8 = v34;
          if ((_DWORD)v3)
          {
            v9 = 0;
            v10 = (v31 + v34) * v3;
            v33 = v10;
            do
            {
              v11 = *(_QWORD *)(*a2 + 24 * v5) + 24 * v8;
              v12 = (v10 + v9);
              v13 = *v4;
              v15 = (_DWORD **)(v11 + 8);
              v14 = *(_DWORD **)(v11 + 8);
              v17 = (_QWORD *)(v11 + 16);
              v16 = *(_QWORD *)(v11 + 16);
              if ((unint64_t)v14 >= v16)
              {
                v19 = v5;
                v20 = v3;
                v21 = v4;
                v22 = *(_DWORD **)v11;
                v23 = ((uint64_t)v14 - *(_QWORD *)v11) >> 2;
                v24 = v23 + 1;
                if ((unint64_t)(v23 + 1) >> 62)
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                v25 = v16 - (_QWORD)v22;
                if (v25 >> 1 > v24)
                  v24 = v25 >> 1;
                if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
                  v26 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v26 = v24;
                if (v26)
                {
                  v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v17, v26);
                  v14 = *v15;
                  v22 = *(_DWORD **)v11;
                }
                else
                {
                  v27 = 0;
                }
                v28 = &v27[4 * v23];
                *(_DWORD *)v28 = *(_DWORD *)(v13 + 4 * v12);
                v18 = v28 + 4;
                v4 = v21;
                while (v14 != v22)
                {
                  v29 = *--v14;
                  *((_DWORD *)v28 - 1) = v29;
                  v28 -= 4;
                }
                *(_QWORD *)v11 = v28;
                *v15 = v18;
                *v17 = &v27[4 * v26];
                v3 = v20;
                if (v22)
                  operator delete(v22);
                v5 = v19;
                v8 = v34;
                v10 = v33;
              }
              else
              {
                *v14 = *(_DWORD *)(v13 + 4 * v12);
                v18 = v14 + 1;
              }
              *v15 = v18;
              ++v9;
            }
            while (v9 != v3);
          }
          v6 = v8 + 1;
        }
        while (v6 != v32);
      }
      ++v5;
    }
    while (v5 != v30);
  }
}

void sub_1B3AF245C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *__p, uint64_t a16, uint64_t a17, void **p_p)
{
  p_p = &__p;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&p_p);
  __p = a14;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

void **std::vector<std::vector<std::vector<float>>>::push_back[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  void **result;
  unint64_t v5;
  unint64_t v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  uint64_t v15;
  void *v16[5];

  v6 = a1[2];
  result = (void **)(a1 + 2);
  v5 = v6;
  v7 = *(result - 1);
  if ((unint64_t)v7 >= v6)
  {
    v9 = 0xAAAAAAAAAAAAAAABLL * (((uint64_t)v7 - *a1) >> 3);
    v10 = v9 + 1;
    if (v9 + 1 > 0xAAAAAAAAAAAAAAALL)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v5 - *a1) >> 3);
    if (2 * v11 > v10)
      v10 = 2 * v11;
    if (v11 >= 0x555555555555555)
      v12 = 0xAAAAAAAAAAAAAAALL;
    else
      v12 = v10;
    v16[4] = result;
    v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)result, v12);
    v14 = &v13[24 * v9];
    v16[0] = v13;
    v16[1] = v14;
    v16[3] = &v13[24 * v15];
    *((_QWORD *)v14 + 1) = 0;
    *((_QWORD *)v14 + 2) = 0;
    *(_QWORD *)v14 = 0;
    *(_OWORD *)v14 = *(_OWORD *)a2;
    *((_QWORD *)v14 + 2) = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v16[2] = v14 + 24;
    std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(a1, v16);
    v8 = (_QWORD *)a1[1];
    result = std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(v16);
  }
  else
  {
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *(_OWORD *)v7 = *(_OWORD *)a2;
    v7[2] = *(_QWORD *)(a2 + 16);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
    *(_QWORD *)(a2 + 16) = 0;
    v8 = v7 + 3;
    a1[1] = (uint64_t)(v7 + 3);
  }
  a1[1] = (uint64_t)v8;
  return result;
}

void sub_1B3AF25D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void arkit::sum(float ***a1@<X0>, unsigned int a2@<W1>, char **a3@<X8>)
{
  unint64_t v5;
  char *v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  unint64_t v11;
  float *v12;
  float v13;
  unint64_t v14;
  char *v15;
  uint64_t v16;
  float **v17;
  float **v18;
  float *v19;
  _QWORD *v20;
  float *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  float *v28;
  int v29;
  float *v30;
  float *v31;
  float v32;
  float v33;
  int v34;

  if (a2 >= 2)
    arkit::sum();
  if (a2 == 1)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
    v17 = *a1;
    v18 = a1[1];
    if (*a1 != v18)
    {
      v19 = 0;
      v20 = a3 + 2;
      do
      {
        if ((unint64_t)v19 >= *v20)
        {
          v21 = (float *)*a3;
          v22 = ((char *)v19 - *a3) >> 2;
          v23 = v22 + 1;
          if ((unint64_t)(v22 + 1) >> 62)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v24 = *v20 - (_QWORD)v21;
          if (v24 >> 1 > v23)
            v23 = v24 >> 1;
          if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
            v25 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v25 = v23;
          if (v25)
          {
            v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a3 + 2), v25);
            v21 = (float *)*a3;
            v19 = (float *)a3[1];
          }
          else
          {
            v26 = 0;
          }
          v27 = &v26[4 * v22];
          *(_DWORD *)v27 = 0;
          v28 = (float *)(v27 + 4);
          while (v19 != v21)
          {
            v29 = *((_DWORD *)v19-- - 1);
            *((_DWORD *)v27 - 1) = v29;
            v27 -= 4;
          }
          *a3 = v27;
          a3[1] = (char *)v28;
          a3[2] = &v26[4 * v25];
          if (v21)
            operator delete(v21);
          v19 = v28;
        }
        else
        {
          *v19++ = 0.0;
        }
        a3[1] = (char *)v19;
        v30 = *v17;
        v31 = v17[1];
        if (*v17 != v31)
        {
          v32 = *(v19 - 1);
          do
          {
            v33 = *v30++;
            v32 = v33 + v32;
            *(v19 - 1) = v32;
          }
          while (v30 != v31);
        }
        v17 += 3;
      }
      while (v17 != v18);
    }
  }
  else
  {
    v5 = (*a1)[1] - **a1;
    v34 = 0;
    std::vector<float>::vector(a3, v5, &v34);
    v6 = (char *)*a1;
    v7 = (char *)(*a1)[1] - (char *)**a1;
    if (v7)
    {
      v8 = 0;
      v9 = v7 >> 2;
      v10 = (char *)a1[1];
      v11 = (v10 - v6) / 24;
      v12 = (float *)*a3;
      if (v11 <= 1)
        v11 = 1;
      if (v9 <= 1)
        v9 = 1;
      do
      {
        if (v10 != v6)
        {
          v13 = v12[v8];
          v14 = v11;
          v15 = v6;
          do
          {
            v16 = *(_QWORD *)v15;
            v15 += 24;
            v13 = *(float *)(v16 + 4 * v8) + v13;
            v12[v8] = v13;
            --v14;
          }
          while (v14);
        }
        ++v8;
      }
      while (v8 != v9);
    }
  }
}

void sub_1B3AF27F0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::normalizeL1(float **a1@<X0>, float **a2@<X8>)
{
  float *v3;
  float *v4;
  float v5;
  float *v6;
  float v7;
  float *v8;
  _QWORD *v9;
  float v10;
  float *v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  float *v18;
  int v19;

  v3 = *a1;
  v4 = a1[1];
  if (*a1 == v4)
  {
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
  }
  else
  {
    v5 = 0.0;
    v6 = *a1;
    do
    {
      v7 = *v6++;
      v5 = v5 + v7;
    }
    while (v6 != v4);
    *a2 = 0;
    a2[1] = 0;
    a2[2] = 0;
    if (v3 != v4)
    {
      v8 = 0;
      v9 = a2 + 2;
      do
      {
        v10 = *v3 / v5;
        if ((unint64_t)v8 >= *v9)
        {
          v12 = *a2;
          v13 = v8 - *a2;
          v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 62)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v15 = *v9 - (_QWORD)v12;
          if (v15 >> 1 > v14)
            v14 = v15 >> 1;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFFCLL)
            v16 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v16 = v14;
          if (v16)
          {
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(a2 + 2), v16);
            v12 = *a2;
            v8 = a2[1];
          }
          else
          {
            v17 = 0;
          }
          v18 = (float *)&v17[4 * v13];
          *v18 = v10;
          v11 = v18 + 1;
          while (v8 != v12)
          {
            v19 = *((_DWORD *)v8-- - 1);
            *((_DWORD *)v18-- - 1) = v19;
          }
          *a2 = v18;
          a2[1] = v11;
          a2[2] = (float *)&v17[4 * v16];
          if (v12)
            operator delete(v12);
        }
        else
        {
          *v8 = v10;
          v11 = v8 + 1;
        }
        a2[1] = v11;
        ++v3;
        v8 = v11;
      }
      while (v3 != v4);
    }
  }
}

void sub_1B3AF295C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void arkit::mixtureKernel(arkit *this@<X2>, uint64_t *a2@<X0>, _QWORD *a3@<X1>, float **a4@<X8>)
{
  unint64_t v8;
  unint64_t v9;
  _BYTE *v10;
  float *v11;
  uint64_t v12;
  float *v13;
  unint64_t v14;
  float **v15;
  uint64_t v16;
  float **v17;
  float **i;
  char *v19;
  float *v20;
  float *v21;
  float *v22;
  float *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  float *v29;
  int v30;
  void *__p;
  float *v32;
  float **v33;
  float **v34;
  unint64_t v35;

  v33 = 0;
  v34 = 0;
  v35 = 0;
  if (a2[1] != *a2)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      arkit::gaussianKernel(this, *(float *)(*a3 + 4 * v8), (float **)&__p);
      v10 = __p;
      v11 = v32;
      if (__p != v32)
      {
        v12 = *a2;
        v13 = (float *)__p;
        do
        {
          *v13 = *v13 * sqrtf(*(float *)(v12 + 4 * v8));
          ++v13;
        }
        while (v13 != v11);
      }
      v14 = ((char *)v11 - v10) >> 2;
      if (v14 > v9)
        v9 = v14;
      v15 = v34;
      if ((unint64_t)v34 >= v35)
      {
        v16 = std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>((uint64_t *)&v33, (uint64_t)&__p);
      }
      else
      {
        *v34 = 0;
        v15[1] = 0;
        v15[2] = 0;
        std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v15, __p, (uint64_t)v32, ((char *)v32 - (_BYTE *)__p) >> 2);
        v16 = (uint64_t)(v15 + 3);
      }
      v34 = (float **)v16;
      if (__p)
      {
        v32 = (float *)__p;
        operator delete(__p);
      }
      ++v8;
    }
    while (v8 < (a2[1] - *a2) >> 2);
    v17 = v33;
    for (i = v34; v17 != i; v17 += 3)
    {
      v19 = (char *)*v17;
      if (v9 > v17[1] - *v17)
      {
        do
        {
          LODWORD(__p) = 0;
          std::vector<float>::insert((uint64_t)v17, v19, (float *)&__p);
          v21 = v17[1];
          v20 = v17[2];
          if (v21 >= v20)
          {
            v23 = *v17;
            v24 = v21 - *v17;
            v25 = v24 + 1;
            if ((unint64_t)(v24 + 1) >> 62)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v26 = (char *)v20 - (char *)v23;
            if (v26 >> 1 > v25)
              v25 = v26 >> 1;
            if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
              v27 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v27 = v25;
            if (v27)
            {
              v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)(v17 + 2), v27);
              v23 = *v17;
              v21 = v17[1];
            }
            else
            {
              v28 = 0;
            }
            v29 = (float *)&v28[4 * v24];
            *v29 = 0.0;
            v22 = v29 + 1;
            while (v21 != v23)
            {
              v30 = *((_DWORD *)v21-- - 1);
              *((_DWORD *)v29-- - 1) = v30;
            }
            *v17 = v29;
            v17[1] = v22;
            v17[2] = (float *)&v28[4 * v27];
            if (v23)
              operator delete(v23);
          }
          else
          {
            *v21 = 0.0;
            v22 = v21 + 1;
          }
          v17[1] = v22;
          v19 = (char *)*v17;
        }
        while (v9 > v22 - *v17);
      }
    }
  }
  arkit::sum(&v33, 0, (char **)&__p);
  arkit::normalizeL1((float **)&__p, a4);
  if (__p)
  {
    v32 = (float *)__p;
    operator delete(__p);
  }
  __p = &v33;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_1B3AF2BD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, char *__p, char *a10, uint64_t a11, char a12, uint64_t a13)
{
  if (__p)
  {
    a10 = __p;
    operator delete(__p);
  }
  __p = &a12;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

char *std::vector<float>::insert(uint64_t a1, char *__src, float *a3)
{
  char *v4;
  char *v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  char *v12;
  int v13;
  _BYTE *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  void *__p;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;

  v4 = __src;
  v6 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  v7 = a1 + 16;
  v8 = v9;
  if ((unint64_t)v6 >= v9)
  {
    v14 = *(_BYTE **)a1;
    v15 = ((uint64_t)&v6[-*(_QWORD *)a1] >> 2) + 1;
    if (v15 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v16 = (__src - v14) >> 2;
    v17 = v8 - (_QWORD)v14;
    if (v17 >> 1 > v15)
      v15 = v17 >> 1;
    if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
      v18 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v18 = v15;
    v25 = v7;
    if (v18)
      v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v7, v18);
    else
      v19 = 0;
    __p = v19;
    v22 = &v19[4 * v16];
    v23 = v22;
    v24 = &v19[4 * v18];
    std::__split_buffer<float>::push_back(&__p, a3);
    v4 = std::vector<float>::__swap_out_circular_buffer((void **)a1, (uint64_t)&__p, v4);
    if (v23 != v22)
      v23 += (v22 - v23 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (__p)
      operator delete(__p);
  }
  else if (__src == v6)
  {
    *(float *)__src = *a3;
    *(_QWORD *)(a1 + 8) = __src + 4;
  }
  else
  {
    v10 = __src + 4;
    v11 = v6 - 4;
    v12 = v6;
    while (v11 < v6)
    {
      v13 = *(_DWORD *)v11;
      v11 += 4;
      *(_DWORD *)v12 = v13;
      v12 += 4;
    }
    *(_QWORD *)(a1 + 8) = v12;
    if (v6 != v10)
      memmove(&v6[-4 * ((v6 - v10) >> 2)], __src, v6 - v10);
    *(float *)v4 = *a3;
  }
  return v4;
}

void sub_1B3AF2D8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void arkit::mixtureKernels(uint64_t *a1@<X0>, _QWORD *a2@<X1>, arkit *a3@<X2>, uint64_t *a4@<X8>)
{
  uint64_t v5;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  void *__p[3];
  void *v13;
  void *v14;
  uint64_t v15;
  void *v16;
  void *v17;
  uint64_t v18;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  v5 = *a1;
  if (a1[1] != *a1)
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v16 = 0;
      v17 = 0;
      v18 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v16, *(const void **)(v5 + v9), *(_QWORD *)(v5 + v9 + 8), (uint64_t)(*(_QWORD *)(v5 + v9 + 8) - *(_QWORD *)(v5 + v9)) >> 2);
      v11 = *a2 + v9;
      v14 = 0;
      v15 = 0;
      v13 = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v13, *(const void **)v11, *(_QWORD *)(v11 + 8), (uint64_t)(*(_QWORD *)(v11 + 8) - *(_QWORD *)v11) >> 2);
      arkit::mixtureKernel(a3, (uint64_t *)&v16, &v13, (float **)__p);
      std::vector<std::vector<float>>::push_back[abi:ne180100](a4, (uint64_t)__p);
      if (__p[0])
      {
        __p[1] = __p[0];
        operator delete(__p[0]);
      }
      if (v13)
      {
        v14 = v13;
        operator delete(v13);
      }
      if (v16)
      {
        v17 = v16;
        operator delete(v16);
      }
      ++v10;
      v5 = *a1;
      v9 += 24;
    }
    while (0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3) > v10);
  }
}

void sub_1B3AF2EE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);
  if (a16)
  {
    a17 = (uint64_t)a16;
    operator delete(a16);
  }
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a16);
  _Unwind_Resume(a1);
}

void arkit::unflattenParams(uint64_t a1, uint64_t *a2, uint64_t a3, uint64_t a4, char *a5, uint64_t *a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v14;
  uint64_t v15;
  const void *v16;
  unint64_t v17;
  unsigned int v21;
  __n128 v22;
  __n128 v23;
  void *v24;
  void *v25;
  uint64_t v26;
  void *__p;
  void *v28;
  uint64_t v29;
  __int128 v30;
  uint64_t v31;
  void **v32;

  v8 = *(_QWORD *)(a1 + 8);
  v9 = (v8 - *(_QWORD *)a1) >> 2;
  v10 = (a2[1] - *a2) >> 2;
  if (v10 % v9)
    arkit::unflattenParams();
  v14 = v10 / v9;
  v15 = *(_QWORD *)(a3 + 8);
  v16 = *(const void **)a3;
  v17 = (v15 - *(_QWORD *)a3) >> 2;
  if (v17 / v9 % v14)
    arkit::unflattenParams();
  if (v17 / v14 % v9)
    arkit::unflattenParams();
  if (v17 != (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2)
    arkit::unflattenParams();
  v21 = v17 / v9 / v14;
  if (a5 != (char *)a1)
  {
    std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a5, *(char **)a1, v8, v9);
    v16 = *(const void **)a3;
    v15 = *(_QWORD *)(a3 + 8);
    v17 = (v15 - *(_QWORD *)a3) >> 2;
  }
  v28 = 0;
  v29 = 0;
  __p = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&__p, v16, v15, v17);
  v22.n128_u64[0] = __PAIR64__(v14, v21);
  v22.n128_u32[2] = v9;
  v23 = v22;
  arkit::unflatten(&__p, (uint64_t *)&v30, v22);
  std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a7);
  *(_OWORD *)a7 = v30;
  *(_QWORD *)(a7 + 16) = v31;
  v31 = 0;
  v30 = 0uLL;
  v32 = (void **)&v30;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v32);
  if (__p)
  {
    v28 = __p;
    operator delete(__p);
  }
  v25 = 0;
  v26 = 0;
  v24 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v24, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 2);
  arkit::unflatten(&v24, (uint64_t *)&v30, v23);
  std::vector<std::vector<std::vector<float>>>::__vdeallocate((void ***)a8);
  *(_OWORD *)a8 = v30;
  *(_QWORD *)(a8 + 16) = v31;
  v31 = 0;
  v30 = 0uLL;
  v32 = (void **)&v30;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](&v32);
  if (v24)
  {
    v25 = v24;
    operator delete(v24);
  }
  arkit::unflatten(a2, (uint64_t *)&v30, COERCE_DOUBLE(__PAIR64__(v9, v14)));
  std::vector<std::vector<float>>::__vdeallocate(a6);
  *(_OWORD *)a6 = v30;
  a6[2] = v31;
  v31 = 0;
  v30 = 0uLL;
  v32 = (void **)&v30;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v32);
}

void sub_1B3AF3164(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void arkit::loadParams(int a1, char *a2, uint64_t *a3, uint64_t a4, uint64_t a5, char *a6)
{
  _OWORD *v11;
  _OWORD *v12;
  char *v13;
  char *v14;
  _OWORD *v15;
  _OWORD *v16;
  _OWORD *v17;
  _OWORD *v18;
  _DWORD *v19;
  _OWORD *v20;
  _OWORD *v21;
  _OWORD *v22;
  _OWORD *v23;
  void *v24;
  void *__p;
  _BYTE *v26;
  void *v27[3];
  void *v28;
  void *v29;
  char *v30;
  void *v31;
  void *v32;
  char *v33;
  void *v34;
  void *v35;
  char *v36;
  _BYTE __dst[1320];
  uint64_t v38;

  v38 = *MEMORY[0x1E0C80C00];
  switch(a1)
  {
    case 0:
      *(_OWORD *)__dst = xmmword_1B3BE4244;
      *(_OWORD *)&__dst[16] = unk_1B3BE4254;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE4264;
      *(_OWORD *)&__dst[48] = unk_1B3BE4274;
      *(_DWORD *)&__dst[64] = 1107321277;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE4318;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE4328;
      *(_OWORD *)&__dst[176] = unk_1B3BE4338;
      *(_OWORD *)&__dst[188] = unk_1B3BE4344;
      *(_OWORD *)&__dst[80] = unk_1B3BE42D8;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE42E8;
      *(_OWORD *)&__dst[112] = unk_1B3BE42F8;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE4308;
      *(_OWORD *)&__dst[16] = unk_1B3BE4298;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE42A8;
      *(_OWORD *)&__dst[48] = unk_1B3BE42B8;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE42C8;
      *(_OWORD *)__dst = xmmword_1B3BE4288;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BE4354, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BE4750, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BE4B4C;
      *(_OWORD *)&__dst[16] = unk_1B3BE4B5C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE4B6C;
      *(_OWORD *)&__dst[48] = unk_1B3BE4B7C;
      *(_DWORD *)&__dst[64] = 1059106455;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 1:
      *(_OWORD *)__dst = xmmword_1B3BE4B90;
      *(_OWORD *)&__dst[16] = unk_1B3BE4BA0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE4BB0;
      *(_OWORD *)&__dst[48] = unk_1B3BE4BC0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE4C60;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE4C70;
      *(_OWORD *)&__dst[176] = unk_1B3BE4C80;
      *(_OWORD *)&__dst[80] = unk_1B3BE4C20;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE4C30;
      *(_OWORD *)&__dst[112] = unk_1B3BE4C40;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE4C50;
      *(_OWORD *)__dst = xmmword_1B3BE4BD0;
      *(_OWORD *)&__dst[16] = unk_1B3BE4BE0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE4BF0;
      *(_OWORD *)&__dst[48] = unk_1B3BE4C00;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE4C10;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BE4C90, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BE5050, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BE5410;
      *(_OWORD *)&__dst[16] = unk_1B3BE5420;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE5430;
      *(_OWORD *)&__dst[48] = unk_1B3BE5440;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 2:
      *(_OWORD *)__dst = xmmword_1B3BF2D6C;
      *(_OWORD *)&__dst[16] = unk_1B3BF2D7C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF2D8C;
      *(_OWORD *)&__dst[48] = unk_1B3BF2D9C;
      *(_DWORD *)&__dst[64] = 1106318384;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF2E40;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF2E50;
      *(_OWORD *)&__dst[176] = unk_1B3BF2E60;
      *(_OWORD *)&__dst[188] = unk_1B3BF2E6C;
      *(_OWORD *)&__dst[80] = unk_1B3BF2E00;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF2E10;
      *(_OWORD *)&__dst[112] = unk_1B3BF2E20;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF2E30;
      *(_OWORD *)&__dst[16] = unk_1B3BF2DC0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF2DD0;
      *(_OWORD *)&__dst[48] = unk_1B3BF2DE0;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF2DF0;
      *(_OWORD *)__dst = xmmword_1B3BF2DB0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BF2E7C, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BF3278, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BF3674;
      *(_OWORD *)&__dst[16] = unk_1B3BF3684;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF3694;
      *(_OWORD *)&__dst[48] = unk_1B3BF36A4;
      *(_DWORD *)&__dst[64] = 1058765256;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 3:
      *(_OWORD *)__dst = xmmword_1B3BF36B8;
      *(_OWORD *)&__dst[16] = unk_1B3BF36C8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF36D8;
      *(_OWORD *)&__dst[48] = unk_1B3BF36E8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF3788;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF3798;
      *(_OWORD *)&__dst[176] = unk_1B3BF37A8;
      *(_OWORD *)&__dst[80] = unk_1B3BF3748;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF3758;
      *(_OWORD *)&__dst[112] = unk_1B3BF3768;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF3778;
      *(_OWORD *)__dst = xmmword_1B3BF36F8;
      *(_OWORD *)&__dst[16] = unk_1B3BF3708;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF3718;
      *(_OWORD *)&__dst[48] = unk_1B3BF3728;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF3738;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BF37B8, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BF3B78, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BF3F38;
      *(_OWORD *)&__dst[16] = unk_1B3BF3F48;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF3F58;
      *(_OWORD *)&__dst[48] = unk_1B3BF3F68;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 4:
      *(_OWORD *)&__dst[16] = unk_1B3BEA80C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEA81C;
      *(_OWORD *)&__dst[48] = unk_1B3BEA82C;
      *(_QWORD *)&__dst[64] = 0x42048AD641D8840ALL;
      *(_OWORD *)__dst = xmmword_1B3BEA7FC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BEA8F4;
      *(_OWORD *)&__dst[192] = xmmword_1B3BEA904;
      *(_OWORD *)&__dst[112] = unk_1B3BEA8B4;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEA8C4;
      *(_OWORD *)&__dst[144] = unk_1B3BEA8D4;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEA8E4;
      *(_OWORD *)&__dst[48] = unk_1B3BEA874;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEA884;
      *(_OWORD *)&__dst[80] = unk_1B3BEA894;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEA8A4;
      *(_OWORD *)__dst = xmmword_1B3BEA844;
      *(_QWORD *)&__dst[208] = 0x382BF76A391C3CE2;
      *(_OWORD *)&__dst[16] = unk_1B3BEA854;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEA864;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BEA91C, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BEAD54, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BEB19C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEB1AC;
      *(_OWORD *)&__dst[48] = unk_1B3BEB1BC;
      *(_QWORD *)&__dst[64] = 0x3F27AA8B3F22E968;
      *(_OWORD *)__dst = xmmword_1B3BEB18C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 5:
      *(_OWORD *)&__dst[16] = unk_1B3BE9E34;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE9E44;
      *(_OWORD *)&__dst[48] = unk_1B3BE9E54;
      *(_QWORD *)&__dst[64] = 0x41EEE0B641DD5DB7;
      *(_OWORD *)__dst = xmmword_1B3BE9E24;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BE9F1C;
      *(_OWORD *)&__dst[192] = xmmword_1B3BE9F2C;
      *(_OWORD *)&__dst[112] = unk_1B3BE9EDC;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE9EEC;
      *(_OWORD *)&__dst[144] = unk_1B3BE9EFC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE9F0C;
      *(_OWORD *)&__dst[48] = unk_1B3BE9E9C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE9EAC;
      *(_OWORD *)&__dst[80] = unk_1B3BE9EBC;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE9ECC;
      *(_OWORD *)__dst = xmmword_1B3BE9E6C;
      *(_QWORD *)&__dst[208] = 0x39A7C5AC3A20B1BCLL;
      *(_OWORD *)&__dst[16] = unk_1B3BE9E7C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE9E8C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BE9F44, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BEA37C, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BEA7C4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEA7D4;
      *(_OWORD *)&__dst[48] = unk_1B3BEA7E4;
      *(_QWORD *)&__dst[64] = 0x3F2754B03F234DCFLL;
      *(_OWORD *)__dst = xmmword_1B3BEA7B4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 6:
      *(_OWORD *)&__dst[48] = unk_1B3BEBBDC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEBBEC;
      *(_QWORD *)&__dst[80] = 0x4203DBAA41E1A20FLL;
      *(_OWORD *)__dst = xmmword_1B3BEBBAC;
      *(_OWORD *)&__dst[16] = unk_1B3BEBBBC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEBBCC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x16uLL);
      memcpy(__dst, &unk_1B3BEBC04, 0x108uLL);
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x42uLL);
      memcpy(__dst, &unk_1B3BEBD0C, sizeof(__dst));
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x14AuLL);
      memcpy(__dst, &unk_1B3BEC234, sizeof(__dst));
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x14AuLL);
      *(_OWORD *)&__dst[48] = unk_1B3BEC78C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEC79C;
      *(_QWORD *)&__dst[80] = 0x3F2B11E83F2A2D73;
      *(_OWORD *)__dst = xmmword_1B3BEC75C;
      *(_OWORD *)&__dst[16] = unk_1B3BEC76C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEC77C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x16uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 7:
      *(_OWORD *)&__dst[16] = unk_1B3BEB1E4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEB1F4;
      *(_OWORD *)&__dst[48] = unk_1B3BEB204;
      *(_QWORD *)&__dst[64] = 0x41FDBD4641CDA493;
      *(_OWORD *)__dst = xmmword_1B3BEB1D4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BEB2CC;
      *(_OWORD *)&__dst[192] = xmmword_1B3BEB2DC;
      *(_OWORD *)&__dst[112] = unk_1B3BEB28C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEB29C;
      *(_OWORD *)&__dst[144] = unk_1B3BEB2AC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEB2BC;
      *(_OWORD *)&__dst[48] = unk_1B3BEB24C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEB25C;
      *(_OWORD *)&__dst[80] = unk_1B3BEB26C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEB27C;
      *(_OWORD *)__dst = xmmword_1B3BEB21C;
      *(_QWORD *)&__dst[208] = 0x36EAE18B38F776C5;
      *(_OWORD *)&__dst[16] = unk_1B3BEB22C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEB23C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BEB2F4, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BEB72C, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BEBB74;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEBB84;
      *(_OWORD *)&__dst[48] = unk_1B3BEBB94;
      *(_QWORD *)&__dst[64] = 0x3F2A95EA3F25CDC4;
      *(_OWORD *)__dst = xmmword_1B3BEBB64;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 8:
      *(_OWORD *)__dst = xmmword_1B3BED100;
      *(_OWORD *)&__dst[16] = unk_1B3BED110;
      *(_OWORD *)&__dst[32] = xmmword_1B3BED120;
      *(_OWORD *)&__dst[48] = unk_1B3BED130;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BED1D0;
      *(_OWORD *)&__dst[160] = xmmword_1B3BED1E0;
      *(_OWORD *)&__dst[176] = unk_1B3BED1F0;
      *(_OWORD *)&__dst[80] = unk_1B3BED190;
      *(_OWORD *)&__dst[96] = xmmword_1B3BED1A0;
      *(_OWORD *)&__dst[112] = unk_1B3BED1B0;
      *(_OWORD *)&__dst[128] = xmmword_1B3BED1C0;
      *(_OWORD *)__dst = xmmword_1B3BED140;
      *(_OWORD *)&__dst[16] = unk_1B3BED150;
      *(_OWORD *)&__dst[32] = xmmword_1B3BED160;
      *(_OWORD *)&__dst[48] = unk_1B3BED170;
      *(_OWORD *)&__dst[64] = xmmword_1B3BED180;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BED200, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BED5C0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BED980;
      *(_OWORD *)&__dst[16] = unk_1B3BED990;
      *(_OWORD *)&__dst[32] = xmmword_1B3BED9A0;
      *(_OWORD *)&__dst[48] = unk_1B3BED9B0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 9:
      *(_OWORD *)__dst = xmmword_1B3BEC7B4;
      *(_OWORD *)&__dst[16] = unk_1B3BEC7C4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEC7D4;
      *(_OWORD *)&__dst[48] = unk_1B3BEC7E4;
      *(_DWORD *)&__dst[64] = 1106231152;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BEC888;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEC898;
      *(_OWORD *)&__dst[176] = unk_1B3BEC8A8;
      *(_OWORD *)&__dst[188] = unk_1B3BEC8B4;
      *(_OWORD *)&__dst[80] = unk_1B3BEC848;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEC858;
      *(_OWORD *)&__dst[112] = unk_1B3BEC868;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEC878;
      *(_OWORD *)&__dst[16] = unk_1B3BEC808;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEC818;
      *(_OWORD *)&__dst[48] = unk_1B3BEC828;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEC838;
      *(_OWORD *)__dst = xmmword_1B3BEC7F8;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BEC8C4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BECCC0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BED0BC;
      *(_OWORD *)&__dst[16] = unk_1B3BED0CC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BED0DC;
      *(_OWORD *)&__dst[48] = unk_1B3BED0EC;
      *(_DWORD *)&__dst[64] = 1052182263;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 10:
      *(_OWORD *)__dst = xmmword_1B3BED9C0;
      *(_OWORD *)&__dst[16] = unk_1B3BED9D0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BED9E0;
      *(_OWORD *)&__dst[48] = unk_1B3BED9F0;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BEDA90;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEDAA0;
      *(_OWORD *)&__dst[176] = unk_1B3BEDAB0;
      *(_OWORD *)&__dst[80] = unk_1B3BEDA50;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEDA60;
      *(_OWORD *)&__dst[112] = unk_1B3BEDA70;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEDA80;
      *(_OWORD *)__dst = xmmword_1B3BEDA00;
      *(_OWORD *)&__dst[16] = unk_1B3BEDA10;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEDA20;
      *(_OWORD *)&__dst[48] = unk_1B3BEDA30;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEDA40;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BEDAC0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BEDE80, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BEE240;
      *(_OWORD *)&__dst[16] = unk_1B3BEE250;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEE260;
      *(_OWORD *)&__dst[48] = unk_1B3BEE270;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 11:
      *(_OWORD *)&__dst[16] = unk_1B3BEECF4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEED04;
      *(_OWORD *)&__dst[48] = unk_1B3BEED14;
      *(_QWORD *)&__dst[64] = 0x41F0537541E02DC3;
      *(_OWORD *)__dst = xmmword_1B3BEECE4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BEEDDC;
      *(_OWORD *)&__dst[192] = xmmword_1B3BEEDEC;
      *(_OWORD *)&__dst[112] = unk_1B3BEED9C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEEDAC;
      *(_OWORD *)&__dst[144] = unk_1B3BEEDBC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEEDCC;
      *(_OWORD *)&__dst[48] = unk_1B3BEED5C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEED6C;
      *(_OWORD *)&__dst[80] = unk_1B3BEED7C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEED8C;
      *(_OWORD *)__dst = xmmword_1B3BEED2C;
      *(_QWORD *)&__dst[208] = 0x389B3073388637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B3BEED3C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEED4C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BEEE04, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BEF23C, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BEF684;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEF694;
      *(_OWORD *)&__dst[48] = unk_1B3BEF6A4;
      *(_QWORD *)&__dst[64] = 0x3F2731C23F211740;
      *(_OWORD *)__dst = xmmword_1B3BEF674;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 12:
      *(_OWORD *)&__dst[16] = unk_1B3BEE290;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEE2A0;
      *(_OWORD *)&__dst[48] = unk_1B3BEE2B0;
      *(_OWORD *)&__dst[60] = unk_1B3BEE2BC;
      *(_OWORD *)__dst = xmmword_1B3BEE280;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BEE37C;
      *(_OWORD *)&__dst[192] = xmmword_1B3BEE38C;
      *(_OWORD *)&__dst[208] = unk_1B3BEE39C;
      *(_OWORD *)&__dst[112] = unk_1B3BEE33C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEE34C;
      *(_OWORD *)&__dst[144] = unk_1B3BEE35C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEE36C;
      *(_OWORD *)&__dst[48] = unk_1B3BEE2FC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEE30C;
      *(_OWORD *)&__dst[80] = unk_1B3BEE31C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEE32C;
      *(_OWORD *)__dst = xmmword_1B3BEE2CC;
      *(_OWORD *)&__dst[16] = unk_1B3BEE2DC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEE2EC;
      *(_DWORD *)&__dst[224] = 981548204;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B3BEE3B0, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B3BEE824, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BEECA8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEECB8;
      *(_OWORD *)&__dst[48] = unk_1B3BEECC8;
      *(_OWORD *)&__dst[60] = unk_1B3BEECD4;
      *(_OWORD *)__dst = xmmword_1B3BEEC98;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 13:
      *(_OWORD *)__dst = xmmword_1B3BF0094;
      *(_OWORD *)&__dst[16] = unk_1B3BF00A4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF00B4;
      *(_OWORD *)&__dst[48] = unk_1B3BF00C4;
      *(_DWORD *)&__dst[64] = 1106552048;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF0168;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF0178;
      *(_OWORD *)&__dst[176] = unk_1B3BF0188;
      *(_OWORD *)&__dst[188] = unk_1B3BF0194;
      *(_OWORD *)&__dst[80] = unk_1B3BF0128;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF0138;
      *(_OWORD *)&__dst[112] = unk_1B3BF0148;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF0158;
      *(_OWORD *)&__dst[16] = unk_1B3BF00E8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF00F8;
      *(_OWORD *)&__dst[48] = unk_1B3BF0108;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF0118;
      *(_OWORD *)__dst = xmmword_1B3BF00D8;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BF01A4, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BF05A0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BF099C;
      *(_OWORD *)&__dst[16] = unk_1B3BF09AC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF09BC;
      *(_OWORD *)&__dst[48] = unk_1B3BF09CC;
      *(_DWORD *)&__dst[64] = 1059864650;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 14:
      *(_OWORD *)&__dst[16] = unk_1B3BEF6CC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEF6DC;
      *(_OWORD *)&__dst[48] = unk_1B3BEF6EC;
      *(_QWORD *)&__dst[64] = 0x41F0C6B541DD6B4DLL;
      *(_OWORD *)__dst = xmmword_1B3BEF6BC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BEF7B4;
      *(_OWORD *)&__dst[192] = xmmword_1B3BEF7C4;
      *(_OWORD *)&__dst[112] = unk_1B3BEF774;
      *(_OWORD *)&__dst[128] = xmmword_1B3BEF784;
      *(_OWORD *)&__dst[144] = unk_1B3BEF794;
      *(_OWORD *)&__dst[160] = xmmword_1B3BEF7A4;
      *(_OWORD *)&__dst[48] = unk_1B3BEF734;
      *(_OWORD *)&__dst[64] = xmmword_1B3BEF744;
      *(_OWORD *)&__dst[80] = unk_1B3BEF754;
      *(_OWORD *)&__dst[96] = xmmword_1B3BEF764;
      *(_OWORD *)__dst = xmmword_1B3BEF704;
      *(_QWORD *)&__dst[208] = 0x360637BD3827C5ACLL;
      *(_OWORD *)&__dst[16] = unk_1B3BEF714;
      *(_OWORD *)&__dst[32] = xmmword_1B3BEF724;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BEF7DC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BEFC14, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF005C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF006C;
      *(_OWORD *)&__dst[48] = unk_1B3BF007C;
      *(_QWORD *)&__dst[64] = 0x3F2799703F26BD3CLL;
      *(_OWORD *)__dst = xmmword_1B3BF004C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 15:
      *(_OWORD *)&__dst[16] = unk_1B3BF47BC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF47CC;
      *(_OWORD *)&__dst[48] = unk_1B3BF47DC;
      *(_OWORD *)&__dst[60] = unk_1B3BF47E8;
      *(_OWORD *)__dst = xmmword_1B3BF47AC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF48A8;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF48B8;
      *(_OWORD *)&__dst[208] = unk_1B3BF48C8;
      *(_OWORD *)&__dst[112] = unk_1B3BF4868;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF4878;
      *(_OWORD *)&__dst[144] = unk_1B3BF4888;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF4898;
      *(_OWORD *)&__dst[48] = unk_1B3BF4828;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF4838;
      *(_OWORD *)&__dst[80] = unk_1B3BF4848;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF4858;
      *(_OWORD *)__dst = xmmword_1B3BF47F8;
      *(_OWORD *)&__dst[16] = unk_1B3BF4808;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF4818;
      *(_DWORD *)&__dst[224] = 966265636;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B3BF48DC, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B3BF4D50, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF51D4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF51E4;
      *(_OWORD *)&__dst[48] = unk_1B3BF51F4;
      *(_OWORD *)&__dst[60] = unk_1B3BF5200;
      *(_OWORD *)__dst = xmmword_1B3BF51C4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 16:
      *(_OWORD *)&__dst[16] = unk_1B3BF5220;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF5230;
      *(_OWORD *)&__dst[48] = unk_1B3BF5240;
      *(_OWORD *)&__dst[60] = unk_1B3BF524C;
      *(_OWORD *)__dst = xmmword_1B3BF5210;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF530C;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF531C;
      *(_OWORD *)&__dst[208] = unk_1B3BF532C;
      *(_OWORD *)&__dst[112] = unk_1B3BF52CC;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF52DC;
      *(_OWORD *)&__dst[144] = unk_1B3BF52EC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF52FC;
      *(_OWORD *)&__dst[48] = unk_1B3BF528C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF529C;
      *(_OWORD *)&__dst[80] = unk_1B3BF52AC;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF52BC;
      *(_OWORD *)__dst = xmmword_1B3BF525C;
      *(_OWORD *)&__dst[16] = unk_1B3BF526C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF527C;
      *(_DWORD *)&__dst[224] = 964336659;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B3BF5340, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B3BF57B4, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF5C38;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF5C48;
      *(_OWORD *)&__dst[48] = unk_1B3BF5C58;
      *(_OWORD *)&__dst[60] = unk_1B3BF5C64;
      *(_OWORD *)__dst = xmmword_1B3BF5C28;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 17:
      *(_OWORD *)__dst = xmmword_1B3BF09E0;
      *(_OWORD *)&__dst[16] = unk_1B3BF09F0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF0A00;
      *(_OWORD *)&__dst[48] = unk_1B3BF0A10;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF0AB0;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF0AC0;
      *(_OWORD *)&__dst[176] = unk_1B3BF0AD0;
      *(_OWORD *)&__dst[80] = unk_1B3BF0A70;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF0A80;
      *(_OWORD *)&__dst[112] = unk_1B3BF0A90;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF0AA0;
      *(_OWORD *)__dst = xmmword_1B3BF0A20;
      *(_OWORD *)&__dst[16] = unk_1B3BF0A30;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF0A40;
      *(_OWORD *)&__dst[48] = unk_1B3BF0A50;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF0A60;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BF0AE0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BF0EA0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BF1260;
      *(_OWORD *)&__dst[16] = unk_1B3BF1270;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF1280;
      *(_OWORD *)&__dst[48] = unk_1B3BF1290;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 18:
      *(_OWORD *)__dst = xmmword_1B3BF12A0;
      *(_OWORD *)&__dst[16] = unk_1B3BF12B0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF12C0;
      *(_OWORD *)&__dst[48] = unk_1B3BF12D0;
      *(_DWORD *)&__dst[64] = 1107695405;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF1374;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF1384;
      *(_OWORD *)&__dst[176] = unk_1B3BF1394;
      *(_OWORD *)&__dst[188] = unk_1B3BF13A0;
      *(_OWORD *)&__dst[80] = unk_1B3BF1334;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF1344;
      *(_OWORD *)&__dst[112] = unk_1B3BF1354;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF1364;
      *(_OWORD *)&__dst[16] = unk_1B3BF12F4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF1304;
      *(_OWORD *)&__dst[48] = unk_1B3BF1314;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF1324;
      *(_OWORD *)__dst = xmmword_1B3BF12E4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BF13B0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BF17AC, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BF1BA8;
      *(_OWORD *)&__dst[16] = unk_1B3BF1BB8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF1BC8;
      *(_OWORD *)&__dst[48] = unk_1B3BF1BD8;
      *(_DWORD *)&__dst[64] = 1050791868;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 19:
      *(_OWORD *)__dst = xmmword_1B3BF09E0;
      *(_OWORD *)&__dst[16] = unk_1B3BF09F0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF0A00;
      *(_OWORD *)&__dst[48] = unk_1B3BF0A10;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF0AB0;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF0AC0;
      *(_OWORD *)&__dst[176] = unk_1B3BF0AD0;
      *(_OWORD *)&__dst[80] = unk_1B3BF0A70;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF0A80;
      *(_OWORD *)&__dst[112] = unk_1B3BF0A90;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF0AA0;
      *(_OWORD *)__dst = xmmword_1B3BF0A20;
      *(_OWORD *)&__dst[16] = unk_1B3BF0A30;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF0A40;
      *(_OWORD *)&__dst[48] = unk_1B3BF0A50;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF0A60;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BF0AE0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BF0EA0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BF1260;
      *(_OWORD *)&__dst[16] = unk_1B3BF1270;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF1280;
      *(_OWORD *)&__dst[48] = unk_1B3BF1290;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 20:
    case 24:
      v11 = operator new(0x40uLL);
      *(_QWORD *)&__dst[8] = v11 + 4;
      *(_QWORD *)&__dst[16] = v11 + 4;
      *v11 = xmmword_1B3BF24AC;
      v11[1] = unk_1B3BF24BC;
      v11[2] = xmmword_1B3BF24CC;
      v11[3] = unk_1B3BF24DC;
      *(_QWORD *)__dst = v11;
      v12 = operator new(0xC0uLL);
      v36 = (char *)(v12 + 12);
      v12[8] = xmmword_1B3BF256C;
      v12[9] = unk_1B3BF257C;
      v12[10] = xmmword_1B3BF258C;
      v12[11] = unk_1B3BF259C;
      v12[4] = xmmword_1B3BF252C;
      v12[5] = unk_1B3BF253C;
      v12[6] = xmmword_1B3BF254C;
      v12[7] = unk_1B3BF255C;
      *v12 = xmmword_1B3BF24EC;
      v12[1] = unk_1B3BF24FC;
      v12[2] = xmmword_1B3BF250C;
      v12[3] = unk_1B3BF251C;
      v34 = v12;
      v35 = v12 + 12;
      v13 = (char *)operator new(0x3C0uLL);
      v31 = v13;
      v33 = v13 + 960;
      memcpy(v13, &unk_1B3BF25AC, 0x3C0uLL);
      v32 = v13 + 960;
      v14 = (char *)operator new(0x3C0uLL);
      v28 = v14;
      v30 = v14 + 960;
      memcpy(v14, &unk_1B3BF296C, 0x3C0uLL);
      v29 = v14 + 960;
      v15 = operator new(0x40uLL);
      *v15 = xmmword_1B3BF2D2C;
      v15[1] = unk_1B3BF2D3C;
      v15[2] = xmmword_1B3BF2D4C;
      v15[3] = unk_1B3BF2D5C;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)(v15 + 4), 0x10uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 21:
    case 25:
      v16 = operator new(0x40uLL);
      *(_QWORD *)&__dst[8] = v16 + 4;
      *(_QWORD *)&__dst[16] = v16 + 4;
      *v16 = xmmword_1B3BF1BEC;
      v16[1] = unk_1B3BF1BFC;
      v16[2] = xmmword_1B3BF1C0C;
      v16[3] = unk_1B3BF1C1C;
      *(_QWORD *)__dst = v16;
      v12 = operator new(0xC0uLL);
      v36 = (char *)(v12 + 12);
      v12[8] = xmmword_1B3BF1CAC;
      v12[9] = unk_1B3BF1CBC;
      v12[10] = xmmword_1B3BF1CCC;
      v12[11] = unk_1B3BF1CDC;
      v12[4] = xmmword_1B3BF1C6C;
      v12[5] = unk_1B3BF1C7C;
      v12[6] = xmmword_1B3BF1C8C;
      v12[7] = unk_1B3BF1C9C;
      *v12 = xmmword_1B3BF1C2C;
      v12[1] = unk_1B3BF1C3C;
      v12[2] = xmmword_1B3BF1C4C;
      v12[3] = unk_1B3BF1C5C;
      v34 = v12;
      v35 = v12 + 12;
      v13 = (char *)operator new(0x3C0uLL);
      v31 = v13;
      v33 = v13 + 960;
      memcpy(v13, &unk_1B3BF1CEC, 0x3C0uLL);
      v32 = v13 + 960;
      v14 = (char *)operator new(0x3C0uLL);
      v28 = v14;
      v30 = v14 + 960;
      memcpy(v14, &unk_1B3BF20AC, 0x3C0uLL);
      v29 = v14 + 960;
      v15 = operator new(0x40uLL);
      *v15 = xmmword_1B3BF246C;
      v15[1] = unk_1B3BF247C;
      v15[2] = xmmword_1B3BF248C;
      v15[3] = unk_1B3BF249C;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)(v15 + 4), 0x10uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 22:
    case 26:
      v18 = operator new(0x38uLL);
      *(_QWORD *)&__dst[8] = (char *)v18 + 56;
      *(_QWORD *)&__dst[16] = (char *)v18 + 56;
      *v18 = xmmword_1B3C039C0;
      v18[1] = unk_1B3C039D0;
      v18[2] = xmmword_1B3C039E0;
      *((_QWORD *)v18 + 6) = 0x41FF189341DFACC5;
      *(_QWORD *)__dst = v18;
      v12 = operator new(0xA8uLL);
      v36 = (char *)v12 + 168;
      v12[8] = xmmword_1B3C03A78;
      v12[9] = unk_1B3C03A88;
      *((_QWORD *)v12 + 20) = 0x39BBB1F238BAA583;
      v12[4] = xmmword_1B3C03A38;
      v12[5] = unk_1B3C03A48;
      v12[6] = xmmword_1B3C03A58;
      v12[7] = unk_1B3C03A68;
      *v12 = xmmword_1B3C039F8;
      v12[1] = unk_1B3C03A08;
      v12[2] = xmmword_1B3C03A18;
      v12[3] = unk_1B3C03A28;
      v34 = v12;
      v35 = (char *)v12 + 168;
      v13 = (char *)operator new(0x348uLL);
      v31 = v13;
      v33 = v13 + 840;
      memcpy(v13, &unk_1B3C03AA0, 0x348uLL);
      v32 = v13 + 840;
      v14 = (char *)operator new(0x348uLL);
      v28 = v14;
      v30 = v14 + 840;
      memcpy(v14, &unk_1B3C03DE8, 0x348uLL);
      v29 = v14 + 840;
      v15 = operator new(0x38uLL);
      *v15 = xmmword_1B3C04130;
      v15[1] = unk_1B3C04140;
      v15[2] = xmmword_1B3C04150;
      *((_QWORD *)v15 + 6) = 0x3EBE4B883EB90DBFLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 23:
    case 27:
      v20 = operator new(0x3CuLL);
      *(_QWORD *)&__dst[8] = (char *)v20 + 60;
      *(_QWORD *)&__dst[16] = (char *)v20 + 60;
      *v20 = xmmword_1B3C04168;
      v20[1] = unk_1B3C04178;
      v20[2] = xmmword_1B3C04188;
      *(_OWORD *)((char *)v20 + 44) = *(__int128 *)((char *)&xmmword_1B3C04188 + 12);
      *(_QWORD *)__dst = v20;
      v12 = operator new(0xB4uLL);
      v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 984649170;
      v12[8] = xmmword_1B3C04224;
      v12[9] = unk_1B3C04234;
      v12[10] = xmmword_1B3C04244;
      v12[4] = xmmword_1B3C041E4;
      v12[5] = unk_1B3C041F4;
      v12[6] = xmmword_1B3C04204;
      v12[7] = unk_1B3C04214;
      *v12 = xmmword_1B3C041A4;
      v12[1] = unk_1B3C041B4;
      v12[2] = xmmword_1B3C041C4;
      v12[3] = unk_1B3C041D4;
      v34 = v12;
      v35 = (char *)v12 + 180;
      v13 = (char *)operator new(0x384uLL);
      v31 = v13;
      v33 = v13 + 900;
      memcpy(v13, &unk_1B3C04258, 0x384uLL);
      v32 = v13 + 900;
      v14 = (char *)operator new(0x384uLL);
      v28 = v14;
      v30 = v14 + 900;
      memcpy(v14, &unk_1B3C045DC, 0x384uLL);
      v29 = v14 + 900;
      v15 = operator new(0x3CuLL);
      *v15 = xmmword_1B3C04960;
      v15[1] = unk_1B3C04970;
      v15[2] = xmmword_1B3C04980;
      *(_OWORD *)((char *)v15 + 44) = *(__int128 *)((char *)&xmmword_1B3C04980 + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 28:
      *(_OWORD *)__dst = xmmword_1B3C0499C;
      *(_OWORD *)&__dst[16] = unk_1B3C049AC;
      *(_OWORD *)&__dst[32] = xmmword_1B3C049BC;
      *(_OWORD *)&__dst[48] = unk_1B3C049CC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3C04A6C;
      *(_OWORD *)&__dst[160] = xmmword_1B3C04A7C;
      *(_OWORD *)&__dst[176] = unk_1B3C04A8C;
      *(_OWORD *)&__dst[80] = unk_1B3C04A2C;
      *(_OWORD *)&__dst[96] = xmmword_1B3C04A3C;
      *(_OWORD *)&__dst[112] = unk_1B3C04A4C;
      *(_OWORD *)&__dst[128] = xmmword_1B3C04A5C;
      *(_OWORD *)__dst = xmmword_1B3C049DC;
      *(_OWORD *)&__dst[16] = unk_1B3C049EC;
      *(_OWORD *)&__dst[32] = xmmword_1B3C049FC;
      *(_OWORD *)&__dst[48] = unk_1B3C04A0C;
      *(_OWORD *)&__dst[64] = xmmword_1B3C04A1C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3C04A9C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3C04E5C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3C0521C;
      *(_OWORD *)&__dst[16] = unk_1B3C0522C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0523C;
      *(_OWORD *)&__dst[48] = unk_1B3C0524C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 29:
      *(_OWORD *)__dst = xmmword_1B3BE82CC;
      *(_OWORD *)&__dst[16] = unk_1B3BE82DC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE82EC;
      *(_OWORD *)&__dst[48] = unk_1B3BE82FC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE839C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE83AC;
      *(_OWORD *)&__dst[176] = unk_1B3BE83BC;
      *(_OWORD *)&__dst[80] = unk_1B3BE835C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE836C;
      *(_OWORD *)&__dst[112] = unk_1B3BE837C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE838C;
      *(_OWORD *)__dst = xmmword_1B3BE830C;
      *(_OWORD *)&__dst[16] = unk_1B3BE831C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE832C;
      *(_OWORD *)&__dst[48] = unk_1B3BE833C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE834C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BE83CC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BE878C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BE8B4C;
      *(_OWORD *)&__dst[16] = unk_1B3BE8B5C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE8B6C;
      *(_OWORD *)&__dst[48] = unk_1B3BE8B7C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 30:
      *(_OWORD *)__dst = xmmword_1B3BE7A0C;
      *(_OWORD *)&__dst[16] = unk_1B3BE7A1C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE7A2C;
      *(_OWORD *)&__dst[48] = unk_1B3BE7A3C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE7ADC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE7AEC;
      *(_OWORD *)&__dst[176] = unk_1B3BE7AFC;
      *(_OWORD *)&__dst[80] = unk_1B3BE7A9C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE7AAC;
      *(_OWORD *)&__dst[112] = unk_1B3BE7ABC;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE7ACC;
      *(_OWORD *)__dst = xmmword_1B3BE7A4C;
      *(_OWORD *)&__dst[16] = unk_1B3BE7A5C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE7A6C;
      *(_OWORD *)&__dst[48] = unk_1B3BE7A7C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE7A8C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BE7B0C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BE7ECC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BE828C;
      *(_OWORD *)&__dst[16] = unk_1B3BE829C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE82AC;
      *(_OWORD *)&__dst[48] = unk_1B3BE82BC;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 31:
      *(_OWORD *)__dst = xmmword_1B3BE9564;
      *(_OWORD *)&__dst[16] = unk_1B3BE9574;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE9584;
      *(_OWORD *)&__dst[48] = unk_1B3BE9594;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE9634;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE9644;
      *(_OWORD *)&__dst[176] = unk_1B3BE9654;
      *(_OWORD *)&__dst[80] = unk_1B3BE95F4;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE9604;
      *(_OWORD *)&__dst[112] = unk_1B3BE9614;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE9624;
      *(_OWORD *)__dst = xmmword_1B3BE95A4;
      *(_OWORD *)&__dst[16] = unk_1B3BE95B4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE95C4;
      *(_OWORD *)&__dst[48] = unk_1B3BE95D4;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE95E4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BE9664, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BE9A24, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BE9DE4;
      *(_OWORD *)&__dst[16] = unk_1B3BE9DF4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE9E04;
      *(_OWORD *)&__dst[48] = unk_1B3BE9E14;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 32:
      *(_OWORD *)&__dst[16] = unk_1B3BE8B9C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE8BAC;
      *(_OWORD *)&__dst[48] = unk_1B3BE8BBC;
      *(_QWORD *)&__dst[64] = 0x41F0831241EF45A2;
      *(_OWORD *)__dst = xmmword_1B3BE8B8C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BE8C84;
      *(_OWORD *)&__dst[192] = xmmword_1B3BE8C94;
      *(_OWORD *)&__dst[112] = unk_1B3BE8C44;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE8C54;
      *(_OWORD *)&__dst[144] = unk_1B3BE8C64;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE8C74;
      *(_OWORD *)&__dst[48] = unk_1B3BE8C04;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE8C14;
      *(_OWORD *)&__dst[80] = unk_1B3BE8C24;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE8C34;
      *(_OWORD *)__dst = xmmword_1B3BE8BD4;
      *(_QWORD *)&__dst[208] = 0x3A288AF93705D7F6;
      *(_OWORD *)&__dst[16] = unk_1B3BE8BE4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE8BF4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BE8CAC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BE90E4, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BE952C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE953C;
      *(_OWORD *)&__dst[48] = unk_1B3BE954C;
      *(_QWORD *)&__dst[64] = 0x3F2C26573F297785;
      *(_OWORD *)__dst = xmmword_1B3BE951C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 33:
      *(_OWORD *)&__dst[16] = unk_1B3BE5DAC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE5DBC;
      *(_OWORD *)&__dst[48] = unk_1B3BE5DCC;
      *(_QWORD *)&__dst[64] = 0x420B90CD41F6113ELL;
      *(_OWORD *)__dst = xmmword_1B3BE5D9C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BE5E94;
      *(_OWORD *)&__dst[192] = xmmword_1B3BE5EA4;
      *(_OWORD *)&__dst[112] = unk_1B3BE5E54;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE5E64;
      *(_OWORD *)&__dst[144] = unk_1B3BE5E74;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE5E84;
      *(_OWORD *)&__dst[48] = unk_1B3BE5E14;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE5E24;
      *(_OWORD *)&__dst[80] = unk_1B3BE5E34;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE5E44;
      *(_OWORD *)__dst = xmmword_1B3BE5DE4;
      *(_QWORD *)&__dst[208] = 0x3928D21C394C78EALL;
      *(_OWORD *)&__dst[16] = unk_1B3BE5DF4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE5E04;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BE5EBC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BE62F4, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BE673C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE674C;
      *(_OWORD *)&__dst[48] = unk_1B3BE675C;
      *(_QWORD *)&__dst[64] = 0x3F2879D53F2547F1;
      *(_OWORD *)__dst = xmmword_1B3BE672C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 34:
      *(_OWORD *)__dst = xmmword_1B3BE5450;
      *(_OWORD *)&__dst[16] = unk_1B3BE5460;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE5470;
      *(_OWORD *)&__dst[48] = unk_1B3BE5480;
      *(_DWORD *)&__dst[64] = 1107628358;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE5524;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE5534;
      *(_OWORD *)&__dst[176] = unk_1B3BE5544;
      *(_OWORD *)&__dst[188] = unk_1B3BE5550;
      *(_OWORD *)&__dst[80] = unk_1B3BE54E4;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE54F4;
      *(_OWORD *)&__dst[112] = unk_1B3BE5504;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE5514;
      *(_OWORD *)&__dst[16] = unk_1B3BE54A4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE54B4;
      *(_OWORD *)&__dst[48] = unk_1B3BE54C4;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE54D4;
      *(_OWORD *)__dst = xmmword_1B3BE5494;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3BE5560, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3BE595C, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3BE5D58;
      *(_OWORD *)&__dst[16] = unk_1B3BE5D68;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE5D78;
      *(_OWORD *)&__dst[48] = unk_1B3BE5D88;
      *(_DWORD *)&__dst[64] = 1059764423;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 35:
      *(_OWORD *)__dst = xmmword_1B3BE714C;
      *(_OWORD *)&__dst[16] = unk_1B3BE715C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE716C;
      *(_OWORD *)&__dst[48] = unk_1B3BE717C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BE721C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE722C;
      *(_OWORD *)&__dst[176] = unk_1B3BE723C;
      *(_OWORD *)&__dst[80] = unk_1B3BE71DC;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE71EC;
      *(_OWORD *)&__dst[112] = unk_1B3BE71FC;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE720C;
      *(_OWORD *)__dst = xmmword_1B3BE718C;
      *(_OWORD *)&__dst[16] = unk_1B3BE719C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE71AC;
      *(_OWORD *)&__dst[48] = unk_1B3BE71BC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE71CC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BE724C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BE760C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BE79CC;
      *(_OWORD *)&__dst[16] = unk_1B3BE79DC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE79EC;
      *(_OWORD *)&__dst[48] = unk_1B3BE79FC;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 36:
      *(_OWORD *)&__dst[16] = unk_1B3BE6784;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE6794;
      *(_OWORD *)&__dst[48] = unk_1B3BE67A4;
      *(_QWORD *)&__dst[64] = 0x41FDA7F941E7D63FLL;
      *(_OWORD *)__dst = xmmword_1B3BE6774;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BE686C;
      *(_OWORD *)&__dst[192] = xmmword_1B3BE687C;
      *(_OWORD *)&__dst[112] = unk_1B3BE682C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BE683C;
      *(_OWORD *)&__dst[144] = unk_1B3BE684C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BE685C;
      *(_OWORD *)&__dst[48] = unk_1B3BE67EC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BE67FC;
      *(_OWORD *)&__dst[80] = unk_1B3BE680C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BE681C;
      *(_OWORD *)__dst = xmmword_1B3BE67BC;
      *(_QWORD *)&__dst[208] = 0x380A697B358637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B3BE67CC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE67DC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BE6894, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BE6CCC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BE7114;
      *(_OWORD *)&__dst[32] = xmmword_1B3BE7124;
      *(_OWORD *)&__dst[48] = unk_1B3BE7134;
      *(_QWORD *)&__dst[64] = 0x3F2936D63F26466BLL;
      *(_OWORD *)__dst = xmmword_1B3BE7104;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 37:
      *(_OWORD *)__dst = xmmword_1B3BF3F78;
      *(_OWORD *)&__dst[16] = unk_1B3BF3F88;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF3F98;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF3F98 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BF4024;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF4034;
      *(_OWORD *)&__dst[144] = unk_1B3BF4044;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF4054;
      *(_OWORD *)&__dst[48] = unk_1B3BF3FE4;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF3FF4;
      *(_OWORD *)&__dst[80] = unk_1B3BF4004;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF4014;
      *(_OWORD *)__dst = xmmword_1B3BF3FB4;
      *(_OWORD *)&__dst[16] = unk_1B3BF3FC4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF3FD4;
      *(_DWORD *)&__dst[176] = 974499625;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BF4068, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BF43EC, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BF4770;
      *(_OWORD *)&__dst[16] = unk_1B3BF4780;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF4790;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF4790 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 38:
      *(_OWORD *)&__dst[16] = unk_1B3BF5C84;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF5C94;
      *(_OWORD *)&__dst[48] = unk_1B3BF5CA4;
      *(_QWORD *)&__dst[64] = 0x420394AC41EFBA84;
      *(_OWORD *)__dst = xmmword_1B3BF5C74;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF5D6C;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF5D7C;
      *(_OWORD *)&__dst[112] = unk_1B3BF5D2C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF5D3C;
      *(_OWORD *)&__dst[144] = unk_1B3BF5D4C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF5D5C;
      *(_OWORD *)&__dst[48] = unk_1B3BF5CEC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF5CFC;
      *(_OWORD *)&__dst[80] = unk_1B3BF5D0C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF5D1C;
      *(_OWORD *)__dst = xmmword_1B3BF5CBC;
      *(_QWORD *)&__dst[208] = 0x3955E8D5390A697BLL;
      *(_OWORD *)&__dst[16] = unk_1B3BF5CCC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF5CDC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BF5D94, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BF61CC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF6614;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF6624;
      *(_OWORD *)&__dst[48] = unk_1B3BF6634;
      *(_QWORD *)&__dst[64] = 0x3F210E343F19E27ALL;
      *(_OWORD *)__dst = xmmword_1B3BF6604;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 39:
      *(_OWORD *)&__dst[16] = unk_1B3BF665C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF666C;
      *(_OWORD *)&__dst[48] = unk_1B3BF667C;
      *(_OWORD *)&__dst[60] = unk_1B3BF6688;
      *(_OWORD *)__dst = xmmword_1B3BF664C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x13uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF6748;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF6758;
      *(_OWORD *)&__dst[208] = unk_1B3BF6768;
      *(_OWORD *)&__dst[112] = unk_1B3BF6708;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF6718;
      *(_OWORD *)&__dst[144] = unk_1B3BF6728;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF6738;
      *(_OWORD *)&__dst[48] = unk_1B3BF66C8;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF66D8;
      *(_OWORD *)&__dst[80] = unk_1B3BF66E8;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF66F8;
      *(_OWORD *)__dst = xmmword_1B3BF6698;
      *(_OWORD *)&__dst[16] = unk_1B3BF66A8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF66B8;
      *(_DWORD *)&__dst[224] = 929751435;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x39uLL);
      memcpy(__dst, &unk_1B3BF677C, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x11DuLL);
      memcpy(__dst, &unk_1B3BF6BF0, 0x474uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x11DuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF7074;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF7084;
      *(_OWORD *)&__dst[48] = unk_1B3BF7094;
      *(_OWORD *)&__dst[60] = unk_1B3BF70A0;
      *(_OWORD *)__dst = xmmword_1B3BF7064;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x13uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 40:
      *(_OWORD *)__dst = xmmword_1B3BF70B0;
      *(_OWORD *)&__dst[16] = unk_1B3BF70C0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF70D0;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF70D0 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BF715C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF716C;
      *(_OWORD *)&__dst[144] = unk_1B3BF717C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF718C;
      *(_OWORD *)&__dst[48] = unk_1B3BF711C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF712C;
      *(_OWORD *)&__dst[80] = unk_1B3BF713C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF714C;
      *(_OWORD *)__dst = xmmword_1B3BF70EC;
      *(_OWORD *)&__dst[16] = unk_1B3BF70FC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF710C;
      *(_DWORD *)&__dst[176] = 0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BF71A0, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BF7524, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BF78A8;
      *(_OWORD *)&__dst[16] = unk_1B3BF78B8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF78C8;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF78C8 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 41:
      *(_OWORD *)&__dst[16] = unk_1B3BF78F4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF7904;
      *(_OWORD *)&__dst[48] = unk_1B3BF7914;
      *(_QWORD *)&__dst[64] = 0x42004EF741F0AF74;
      *(_OWORD *)__dst = xmmword_1B3BF78E4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF79DC;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF79EC;
      *(_OWORD *)&__dst[112] = unk_1B3BF799C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF79AC;
      *(_OWORD *)&__dst[144] = unk_1B3BF79BC;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF79CC;
      *(_OWORD *)&__dst[48] = unk_1B3BF795C;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF796C;
      *(_OWORD *)&__dst[80] = unk_1B3BF797C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF798C;
      *(_OWORD *)__dst = xmmword_1B3BF792C;
      *(_QWORD *)&__dst[208] = 0x37E27E0F3855E8D5;
      *(_OWORD *)&__dst[16] = unk_1B3BF793C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF794C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BF7A04, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BF7E3C, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF8284;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF8294;
      *(_OWORD *)&__dst[48] = unk_1B3BF82A4;
      *(_QWORD *)&__dst[64] = 0x3F2DAFE23F2C5B3ALL;
      *(_OWORD *)__dst = xmmword_1B3BF8274;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 42:
      *(_OWORD *)&__dst[16] = unk_1B3BF82CC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF82DC;
      *(_OWORD *)&__dst[48] = unk_1B3BF82EC;
      *(_QWORD *)&__dst[64] = 0x4200033741E8DB70;
      *(_OWORD *)__dst = xmmword_1B3BF82BC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x12uLL);
      *(_OWORD *)&__dst[176] = unk_1B3BF83B4;
      *(_OWORD *)&__dst[192] = xmmword_1B3BF83C4;
      *(_OWORD *)&__dst[112] = unk_1B3BF8374;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF8384;
      *(_OWORD *)&__dst[144] = unk_1B3BF8394;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF83A4;
      *(_OWORD *)&__dst[48] = unk_1B3BF8334;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF8344;
      *(_OWORD *)&__dst[80] = unk_1B3BF8354;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF8364;
      *(_OWORD *)__dst = xmmword_1B3BF8304;
      *(_QWORD *)&__dst[208] = 0x38BAA583390205FFLL;
      *(_OWORD *)&__dst[16] = unk_1B3BF8314;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF8324;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x36uLL);
      memcpy(__dst, &unk_1B3BF83DC, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0x10EuLL);
      memcpy(__dst, &unk_1B3BF8814, 0x438uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0x10EuLL);
      *(_OWORD *)&__dst[16] = unk_1B3BF8C5C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF8C6C;
      *(_OWORD *)&__dst[48] = unk_1B3BF8C7C;
      *(_QWORD *)&__dst[64] = 0x3F31BB283F2DFA01;
      *(_OWORD *)__dst = xmmword_1B3BF8C4C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x12uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 43:
      *(_OWORD *)__dst = xmmword_1B3BFAE7C;
      *(_OWORD *)&__dst[16] = unk_1B3BFAE8C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFAE9C;
      *(_OWORD *)&__dst[48] = unk_1B3BFAEAC;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFAF4C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFAF5C;
      *(_OWORD *)&__dst[176] = unk_1B3BFAF6C;
      *(_OWORD *)&__dst[80] = unk_1B3BFAF0C;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFAF1C;
      *(_OWORD *)&__dst[112] = unk_1B3BFAF2C;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFAF3C;
      *(_OWORD *)__dst = xmmword_1B3BFAEBC;
      *(_OWORD *)&__dst[16] = unk_1B3BFAECC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFAEDC;
      *(_OWORD *)&__dst[48] = unk_1B3BFAEEC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFAEFC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFAF7C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFB33C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFB6FC;
      *(_OWORD *)&__dst[16] = unk_1B3BFB70C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFB71C;
      *(_OWORD *)&__dst[48] = unk_1B3BFB72C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 44:
      *(_OWORD *)__dst = xmmword_1B3BFB73C;
      *(_OWORD *)&__dst[16] = unk_1B3BFB74C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFB75C;
      *(_OWORD *)&__dst[48] = unk_1B3BFB76C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFB80C;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFB81C;
      *(_OWORD *)&__dst[176] = unk_1B3BFB82C;
      *(_OWORD *)&__dst[80] = unk_1B3BFB7CC;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFB7DC;
      *(_OWORD *)&__dst[112] = unk_1B3BFB7EC;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFB7FC;
      *(_OWORD *)__dst = xmmword_1B3BFB77C;
      *(_OWORD *)&__dst[16] = unk_1B3BFB78C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFB79C;
      *(_OWORD *)&__dst[48] = unk_1B3BFB7AC;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFB7BC;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFB83C, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFBBFC, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFBFBC;
      *(_OWORD *)&__dst[16] = unk_1B3BFBFCC;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFBFDC;
      *(_OWORD *)&__dst[48] = unk_1B3BFBFEC;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 45:
      *(_OWORD *)__dst = xmmword_1B3BFBFFC;
      *(_OWORD *)&__dst[16] = unk_1B3BFC00C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFC01C;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFC01C + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BFC0A8;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFC0B8;
      *(_OWORD *)&__dst[144] = unk_1B3BFC0C8;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFC0D8;
      *(_OWORD *)&__dst[48] = unk_1B3BFC068;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFC078;
      *(_OWORD *)&__dst[80] = unk_1B3BFC088;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFC098;
      *(_OWORD *)__dst = xmmword_1B3BFC038;
      *(_OWORD *)&__dst[16] = unk_1B3BFC048;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFC058;
      *(_DWORD *)&__dst[176] = 1001742066;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BFC0EC, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BFC470, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BFC7F4;
      *(_OWORD *)&__dst[16] = unk_1B3BFC804;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFC814;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFC814 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 46:
      *(_OWORD *)__dst = xmmword_1B3BFC830;
      *(_OWORD *)&__dst[16] = unk_1B3BFC840;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFC850;
      *(_OWORD *)&__dst[48] = unk_1B3BFC860;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFC900;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFC910;
      *(_OWORD *)&__dst[176] = unk_1B3BFC920;
      *(_OWORD *)&__dst[80] = unk_1B3BFC8C0;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFC8D0;
      *(_OWORD *)&__dst[112] = unk_1B3BFC8E0;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFC8F0;
      *(_OWORD *)__dst = xmmword_1B3BFC870;
      *(_OWORD *)&__dst[16] = unk_1B3BFC880;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFC890;
      *(_OWORD *)&__dst[48] = unk_1B3BFC8A0;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFC8B0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFC930, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFCCF0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFD0B0;
      *(_OWORD *)&__dst[16] = unk_1B3BFD0C0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFD0D0;
      *(_OWORD *)&__dst[48] = unk_1B3BFD0E0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 47:
      *(_OWORD *)__dst = xmmword_1B3BFD0F0;
      *(_OWORD *)&__dst[16] = unk_1B3BFD100;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFD110;
      *(_OWORD *)&__dst[48] = unk_1B3BFD120;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFD1C0;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFD1D0;
      *(_OWORD *)&__dst[176] = unk_1B3BFD1E0;
      *(_OWORD *)&__dst[80] = unk_1B3BFD180;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFD190;
      *(_OWORD *)&__dst[112] = unk_1B3BFD1A0;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFD1B0;
      *(_OWORD *)__dst = xmmword_1B3BFD130;
      *(_OWORD *)&__dst[16] = unk_1B3BFD140;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFD150;
      *(_OWORD *)&__dst[48] = unk_1B3BFD160;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFD170;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFD1F0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFD5B0, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFD970;
      *(_OWORD *)&__dst[16] = unk_1B3BFD980;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFD990;
      *(_OWORD *)&__dst[48] = unk_1B3BFD9A0;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 48:
      *(_OWORD *)__dst = xmmword_1B3BFEC18;
      *(_OWORD *)&__dst[16] = unk_1B3BFEC28;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFEC38;
      *(_QWORD *)&__dst[48] = 0x4204750141F0E75ELL;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BFECC0;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFECD0;
      *(_OWORD *)&__dst[144] = unk_1B3BFECE0;
      *(_OWORD *)&__dst[48] = unk_1B3BFEC80;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFEC90;
      *(_OWORD *)&__dst[80] = unk_1B3BFECA0;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFECB0;
      *(_OWORD *)__dst = xmmword_1B3BFEC50;
      *(_QWORD *)&__dst[160] = 0x3C2A10E03AC7C0F4;
      *(_OWORD *)&__dst[16] = unk_1B3BFEC60;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFEC70;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B3BFECF8, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B3BFF040, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B3BFF388;
      *(_OWORD *)&__dst[16] = unk_1B3BFF398;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFF3A8;
      *(_QWORD *)&__dst[48] = 0x3E7AD7D83E6BD33DLL;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 49:
      *(_OWORD *)__dst = xmmword_1B3BFF3C0;
      *(_OWORD *)&__dst[16] = unk_1B3BFF3D0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFF3E0;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFF3E0 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BFDA20;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFDA30;
      *(_OWORD *)&__dst[144] = unk_1B3BFDA40;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFDA50;
      *(_OWORD *)&__dst[48] = unk_1B3BFD9E0;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFD9F0;
      *(_OWORD *)&__dst[80] = unk_1B3BFDA00;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFDA10;
      *(_OWORD *)__dst = xmmword_1B3BFD9B0;
      *(_OWORD *)&__dst[16] = unk_1B3BFD9C0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFD9D0;
      *(_DWORD *)&__dst[176] = 986478826;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BFF4B0, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BFF834, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BFFBB8;
      *(_OWORD *)&__dst[16] = unk_1B3BFFBC8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFFBD8;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFFBD8 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 50:
      *(_OWORD *)__dst = xmmword_1B3BFDA64;
      *(_OWORD *)&__dst[16] = unk_1B3BFDA74;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFDA84;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFDA84 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BFDB10;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFDB20;
      *(_OWORD *)&__dst[144] = unk_1B3BFDB30;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFDB40;
      *(_OWORD *)&__dst[48] = unk_1B3BFDAD0;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFDAE0;
      *(_OWORD *)&__dst[80] = unk_1B3BFDAF0;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFDB00;
      *(_OWORD *)__dst = xmmword_1B3BFDAA0;
      *(_OWORD *)&__dst[16] = unk_1B3BFDAB0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFDAC0;
      *(_DWORD *)&__dst[176] = 910775196;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BFDB54, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BFDED8, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BFE25C;
      *(_OWORD *)&__dst[16] = unk_1B3BFE26C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFE27C;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFE27C + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 51:
      *(_OWORD *)__dst = xmmword_1B3BFE358;
      *(_OWORD *)&__dst[16] = unk_1B3BFE368;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFE378;
      *(_OWORD *)&__dst[48] = unk_1B3BFE388;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFE328;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFE338;
      *(_OWORD *)&__dst[176] = unk_1B3BFE348;
      *(_OWORD *)&__dst[80] = unk_1B3BFE2E8;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFE2F8;
      *(_OWORD *)&__dst[112] = unk_1B3BFE308;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFE318;
      *(_OWORD *)__dst = xmmword_1B3BFE298;
      *(_OWORD *)&__dst[16] = unk_1B3BFE2A8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFE2B8;
      *(_OWORD *)&__dst[48] = unk_1B3BFE2C8;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFE2D8;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFE458, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFE818, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFEBD8;
      *(_OWORD *)&__dst[16] = unk_1B3BFEBE8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFEBF8;
      *(_OWORD *)&__dst[48] = unk_1B3BFEC08;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 52:
      *(_OWORD *)__dst = xmmword_1B3BFE358;
      *(_OWORD *)&__dst[16] = unk_1B3BFE368;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFE378;
      *(_OWORD *)&__dst[48] = unk_1B3BFE388;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BFE428;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFE438;
      *(_OWORD *)&__dst[176] = unk_1B3BFE448;
      *(_OWORD *)&__dst[80] = unk_1B3BFE3E8;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFE3F8;
      *(_OWORD *)&__dst[112] = unk_1B3BFE408;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFE418;
      *(_OWORD *)__dst = xmmword_1B3BFE398;
      *(_OWORD *)&__dst[16] = unk_1B3BFE3A8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFE3B8;
      *(_OWORD *)&__dst[48] = unk_1B3BFE3C8;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFE3D8;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BFE458, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFE818, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFEBD8;
      *(_OWORD *)&__dst[16] = unk_1B3BFEBE8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFEBF8;
      *(_OWORD *)&__dst[48] = unk_1B3BFEC08;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 53:
    case 62:
      v23 = operator new(0x38uLL);
      *(_QWORD *)&__dst[8] = (char *)v23 + 56;
      *(_QWORD *)&__dst[16] = (char *)v23 + 56;
      *v23 = xmmword_1B3BFEC18;
      v23[1] = unk_1B3BFEC28;
      v23[2] = xmmword_1B3BFEC38;
      *((_QWORD *)v23 + 6) = 0x4204750141F0E75ELL;
      *(_QWORD *)__dst = v23;
      v12 = operator new(0xA8uLL);
      v36 = (char *)v12 + 168;
      v12[8] = xmmword_1B3BFECD0;
      v12[9] = unk_1B3BFECE0;
      *((_QWORD *)v12 + 20) = 0x3C2A10E03AC7C0F4;
      v12[4] = xmmword_1B3BFEC90;
      v12[5] = unk_1B3BFECA0;
      v12[6] = xmmword_1B3BFECB0;
      v12[7] = unk_1B3BFECC0;
      *v12 = xmmword_1B3BFEC50;
      v12[1] = unk_1B3BFEC60;
      v12[2] = xmmword_1B3BFEC70;
      v12[3] = unk_1B3BFEC80;
      v34 = v12;
      v35 = (char *)v12 + 168;
      v13 = (char *)operator new(0x348uLL);
      v31 = v13;
      v33 = v13 + 840;
      memcpy(v13, &unk_1B3BFECF8, 0x348uLL);
      v32 = v13 + 840;
      v14 = (char *)operator new(0x348uLL);
      v28 = v14;
      v30 = v14 + 840;
      memcpy(v14, &unk_1B3BFF040, 0x348uLL);
      v29 = v14 + 840;
      v15 = operator new(0x38uLL);
      *v15 = xmmword_1B3BFF388;
      v15[1] = unk_1B3BFF398;
      v15[2] = xmmword_1B3BFF3A8;
      *((_QWORD *)v15 + 6) = 0x3E7AD7D83E6BD33DLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 54:
    case 63:
      v22 = operator new(0x3CuLL);
      *(_QWORD *)&__dst[8] = (char *)v22 + 60;
      *(_QWORD *)&__dst[16] = (char *)v22 + 60;
      *v22 = xmmword_1B3BFF3C0;
      v22[1] = unk_1B3BFF3D0;
      v22[2] = xmmword_1B3BFF3E0;
      *(_OWORD *)((char *)v22 + 44) = *(__int128 *)((char *)&xmmword_1B3BFF3E0 + 12);
      *(_QWORD *)__dst = v22;
      v12 = operator new(0xB4uLL);
      v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 991517359;
      v12[8] = xmmword_1B3BFF47C;
      v12[9] = unk_1B3BFF48C;
      v12[10] = xmmword_1B3BFF49C;
      v12[4] = xmmword_1B3BFF43C;
      v12[5] = unk_1B3BFF44C;
      v12[6] = xmmword_1B3BFF45C;
      v12[7] = unk_1B3BFF46C;
      *v12 = xmmword_1B3BFF3FC;
      v12[1] = unk_1B3BFF40C;
      v12[2] = xmmword_1B3BFF41C;
      v12[3] = unk_1B3BFF42C;
      v34 = v12;
      v35 = (char *)v12 + 180;
      v13 = (char *)operator new(0x384uLL);
      v31 = v13;
      v33 = v13 + 900;
      memcpy(v13, &unk_1B3BFF4B0, 0x384uLL);
      v32 = v13 + 900;
      v14 = (char *)operator new(0x384uLL);
      v28 = v14;
      v30 = v14 + 900;
      memcpy(v14, &unk_1B3BFF834, 0x384uLL);
      v29 = v14 + 900;
      v15 = operator new(0x3CuLL);
      *v15 = xmmword_1B3BFFBB8;
      v15[1] = unk_1B3BFFBC8;
      v15[2] = xmmword_1B3BFFBD8;
      *(_OWORD *)((char *)v15 + 44) = *(__int128 *)((char *)&xmmword_1B3BFFBD8 + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 55:
    case 64:
      v17 = operator new(0x38uLL);
      *(_QWORD *)&__dst[8] = (char *)v17 + 56;
      *(_QWORD *)&__dst[16] = (char *)v17 + 56;
      *v17 = xmmword_1B3BFFBF4;
      v17[1] = unk_1B3BFFC04;
      v17[2] = xmmword_1B3BFFC14;
      *((_QWORD *)v17 + 6) = 0x41FF12A441E0E33ALL;
      *(_QWORD *)__dst = v17;
      v12 = operator new(0xA8uLL);
      v36 = (char *)v12 + 168;
      v12[8] = xmmword_1B3BFFCAC;
      v12[9] = unk_1B3BFFCBC;
      *((_QWORD *)v12 + 20) = 0x36C9539C38C9539CLL;
      v12[4] = xmmword_1B3BFFC6C;
      v12[5] = unk_1B3BFFC7C;
      v12[6] = xmmword_1B3BFFC8C;
      v12[7] = unk_1B3BFFC9C;
      *v12 = xmmword_1B3BFFC2C;
      v12[1] = unk_1B3BFFC3C;
      v12[2] = xmmword_1B3BFFC4C;
      v12[3] = unk_1B3BFFC5C;
      v34 = v12;
      v35 = (char *)v12 + 168;
      v13 = (char *)operator new(0x348uLL);
      v31 = v13;
      v33 = v13 + 840;
      memcpy(v13, &unk_1B3BFFCD4, 0x348uLL);
      v32 = v13 + 840;
      v14 = (char *)operator new(0x348uLL);
      v28 = v14;
      v30 = v14 + 840;
      memcpy(v14, &unk_1B3C0001C, 0x348uLL);
      v29 = v14 + 840;
      v15 = operator new(0x38uLL);
      *v15 = xmmword_1B3C00364;
      v15[1] = unk_1B3C00374;
      v15[2] = xmmword_1B3C00384;
      *((_QWORD *)v15 + 6) = 0x3E92DA983E8708ABLL;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 56, 0xEuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 56:
    case 65:
      v19 = operator new(0x44uLL);
      *(_QWORD *)&__dst[8] = v19 + 17;
      *(_QWORD *)&__dst[16] = v19 + 17;
      v19[16] = 1107541042;
      *(_OWORD *)v19 = xmmword_1B3C0039C;
      *((_OWORD *)v19 + 1) = unk_1B3C003AC;
      *((_OWORD *)v19 + 2) = xmmword_1B3C003BC;
      *((_OWORD *)v19 + 3) = unk_1B3C003CC;
      *(_QWORD *)__dst = v19;
      v12 = operator new(0xCCuLL);
      v36 = (char *)v12 + 204;
      v12[10] = xmmword_1B3C00480;
      v12[11] = unk_1B3C00490;
      *(_OWORD *)((char *)v12 + 188) = unk_1B3C0049C;
      v12[6] = xmmword_1B3C00440;
      v12[7] = unk_1B3C00450;
      v12[8] = xmmword_1B3C00460;
      v12[9] = unk_1B3C00470;
      v12[2] = xmmword_1B3C00400;
      v12[3] = unk_1B3C00410;
      v12[4] = xmmword_1B3C00420;
      v12[5] = unk_1B3C00430;
      *v12 = xmmword_1B3C003E0;
      v12[1] = unk_1B3C003F0;
      v34 = v12;
      v35 = (char *)v12 + 204;
      v13 = (char *)operator new(0x3FCuLL);
      v31 = v13;
      v33 = v13 + 1020;
      memcpy(v13, &unk_1B3C004AC, 0x3FCuLL);
      v32 = v13 + 1020;
      v14 = (char *)operator new(0x3FCuLL);
      v28 = v14;
      v30 = v14 + 1020;
      memcpy(v14, &unk_1B3C008A8, 0x3FCuLL);
      v29 = v14 + 1020;
      v15 = operator new(0x44uLL);
      *((_DWORD *)v15 + 16) = 1051758571;
      *v15 = xmmword_1B3C00CA4;
      v15[1] = unk_1B3C00CB4;
      v15[2] = xmmword_1B3C00CC4;
      v15[3] = unk_1B3C00CD4;
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 68, 0x11uLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
      goto LABEL_11;
    case 57:
    case 66:
      v21 = operator new(0x3CuLL);
      *(_QWORD *)&__dst[8] = (char *)v21 + 60;
      *(_QWORD *)&__dst[16] = (char *)v21 + 60;
      *v21 = xmmword_1B3C00CE8;
      v21[1] = unk_1B3C00CF8;
      v21[2] = xmmword_1B3C00D08;
      *(_OWORD *)((char *)v21 + 44) = *(__int128 *)((char *)&xmmword_1B3C00D08 + 12);
      *(_QWORD *)__dst = v21;
      v12 = operator new(0xB4uLL);
      v36 = (char *)v12 + 180;
      *((_DWORD *)v12 + 44) = 1008605961;
      v12[8] = xmmword_1B3C00DA4;
      v12[9] = unk_1B3C00DB4;
      v12[10] = xmmword_1B3C00DC4;
      v12[4] = xmmword_1B3C00D64;
      v12[5] = unk_1B3C00D74;
      v12[6] = xmmword_1B3C00D84;
      v12[7] = unk_1B3C00D94;
      *v12 = xmmword_1B3C00D24;
      v12[1] = unk_1B3C00D34;
      v12[2] = xmmword_1B3C00D44;
      v12[3] = unk_1B3C00D54;
      v34 = v12;
      v35 = (char *)v12 + 180;
      v13 = (char *)operator new(0x384uLL);
      v31 = v13;
      v33 = v13 + 900;
      memcpy(v13, &unk_1B3C00DD8, 0x384uLL);
      v32 = v13 + 900;
      v14 = (char *)operator new(0x384uLL);
      v28 = v14;
      v30 = v14 + 900;
      memcpy(v14, &unk_1B3C0115C, 0x384uLL);
      v29 = v14 + 900;
      v15 = operator new(0x3CuLL);
      *v15 = xmmword_1B3C014E0;
      v15[1] = unk_1B3C014F0;
      v15[2] = xmmword_1B3C01500;
      *(_OWORD *)((char *)v15 + 44) = *(__int128 *)((char *)&xmmword_1B3C01500 + 12);
      std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)v15, (uint64_t)v15 + 60, 0xFuLL);
      arkit::unflattenParams((uint64_t)__dst, (uint64_t *)&v34, (uint64_t)&v31, (uint64_t)&v28, a2, a3, a4, a5);
LABEL_11:
      operator delete(v15);
      operator delete(v14);
      operator delete(v13);
      operator delete(v12);
      v24 = *(void **)__dst;
      if (!*(_QWORD *)__dst)
        return;
      *(_QWORD *)&__dst[8] = *(_QWORD *)__dst;
      goto LABEL_199;
    case 58:
      *(_OWORD *)__dst = xmmword_1B3BF9554;
      *(_OWORD *)&__dst[16] = unk_1B3BF9564;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF9574;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF9574 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BF9600;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF9610;
      *(_OWORD *)&__dst[144] = unk_1B3BF9620;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF9630;
      *(_OWORD *)&__dst[48] = unk_1B3BF95C0;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF95D0;
      *(_OWORD *)&__dst[80] = unk_1B3BF95E0;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF95F0;
      *(_OWORD *)__dst = xmmword_1B3BF9590;
      *(_OWORD *)&__dst[16] = unk_1B3BF95A0;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF95B0;
      *(_DWORD *)&__dst[176] = 949557140;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BF9644, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BF99C8, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BF9D4C;
      *(_OWORD *)&__dst[16] = unk_1B3BF9D5C;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF9D6C;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BF9D6C + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 59:
      *(_OWORD *)__dst = xmmword_1B3BF8C94;
      *(_OWORD *)&__dst[16] = unk_1B3BF8CA4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF8CB4;
      *(_OWORD *)&__dst[48] = unk_1B3BF8CC4;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF8D64;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF8D74;
      *(_OWORD *)&__dst[176] = unk_1B3BF8D84;
      *(_OWORD *)&__dst[80] = unk_1B3BF8D24;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF8D34;
      *(_OWORD *)&__dst[112] = unk_1B3BF8D44;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF8D54;
      *(_OWORD *)__dst = xmmword_1B3BF8CD4;
      *(_OWORD *)&__dst[16] = unk_1B3BF8CE4;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF8CF4;
      *(_OWORD *)&__dst[48] = unk_1B3BF8D04;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF8D14;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BF8D94, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BF9154, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BF9514;
      *(_OWORD *)&__dst[16] = unk_1B3BF9524;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF9534;
      *(_OWORD *)&__dst[48] = unk_1B3BF9544;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 60:
      *(_OWORD *)__dst = xmmword_1B3BF9D88;
      *(_OWORD *)&__dst[16] = unk_1B3BF9D98;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF9DA8;
      *(_OWORD *)&__dst[48] = unk_1B3BF9DB8;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x10uLL);
      *(_OWORD *)&__dst[144] = unk_1B3BF9E58;
      *(_OWORD *)&__dst[160] = xmmword_1B3BF9E68;
      *(_OWORD *)&__dst[176] = unk_1B3BF9E78;
      *(_OWORD *)&__dst[80] = unk_1B3BF9E18;
      *(_OWORD *)&__dst[96] = xmmword_1B3BF9E28;
      *(_OWORD *)&__dst[112] = unk_1B3BF9E38;
      *(_OWORD *)&__dst[128] = xmmword_1B3BF9E48;
      *(_OWORD *)__dst = xmmword_1B3BF9DC8;
      *(_OWORD *)&__dst[16] = unk_1B3BF9DD8;
      *(_OWORD *)&__dst[32] = xmmword_1B3BF9DE8;
      *(_OWORD *)&__dst[48] = unk_1B3BF9DF8;
      *(_OWORD *)&__dst[64] = xmmword_1B3BF9E08;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x30uLL);
      memcpy(__dst, &unk_1B3BF9E88, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xF0uLL);
      memcpy(__dst, &unk_1B3BFA248, 0x3C0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xF0uLL);
      *(_OWORD *)__dst = xmmword_1B3BFA608;
      *(_OWORD *)&__dst[16] = unk_1B3BFA618;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFA628;
      *(_OWORD *)&__dst[48] = unk_1B3BFA638;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x10uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 61:
      *(_OWORD *)__dst = xmmword_1B3BFA648;
      *(_OWORD *)&__dst[16] = unk_1B3BFA658;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFA668;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFA668 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3BFA6F4;
      *(_OWORD *)&__dst[128] = xmmword_1B3BFA704;
      *(_OWORD *)&__dst[144] = unk_1B3BFA714;
      *(_OWORD *)&__dst[160] = xmmword_1B3BFA724;
      *(_OWORD *)&__dst[48] = unk_1B3BFA6B4;
      *(_OWORD *)&__dst[64] = xmmword_1B3BFA6C4;
      *(_OWORD *)&__dst[80] = unk_1B3BFA6D4;
      *(_OWORD *)&__dst[96] = xmmword_1B3BFA6E4;
      *(_OWORD *)__dst = xmmword_1B3BFA684;
      *(_OWORD *)&__dst[16] = unk_1B3BFA694;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFA6A4;
      *(_DWORD *)&__dst[176] = 944604505;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3BFA738, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3BFAABC, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3BFAE40;
      *(_OWORD *)&__dst[16] = unk_1B3BFAE50;
      *(_OWORD *)&__dst[32] = xmmword_1B3BFAE60;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3BFAE60 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 67:
      *(_OWORD *)__dst = xmmword_1B3C0151C;
      *(_OWORD *)&__dst[16] = unk_1B3C0152C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0153C;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xCuLL);
      *(_OWORD *)&__dst[80] = unk_1B3C0159C;
      *(_OWORD *)&__dst[96] = xmmword_1B3C015AC;
      *(_OWORD *)&__dst[112] = unk_1B3C015BC;
      *(_OWORD *)&__dst[128] = xmmword_1B3C015CC;
      *(_OWORD *)&__dst[16] = unk_1B3C0155C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0156C;
      *(_OWORD *)&__dst[48] = unk_1B3C0157C;
      *(_OWORD *)&__dst[64] = xmmword_1B3C0158C;
      *(_OWORD *)__dst = xmmword_1B3C0154C;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x24uLL);
      memcpy(__dst, &unk_1B3C015DC, 0x2D0uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xB4uLL);
      memcpy(__dst, &unk_1B3C018AC, 0x2D0uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xB4uLL);
      *(_OWORD *)__dst = xmmword_1B3C01B7C;
      *(_OWORD *)&__dst[16] = unk_1B3C01B8C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C01B9C;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xCuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 68:
      *(_OWORD *)__dst = xmmword_1B3C01BAC;
      *(_OWORD *)&__dst[16] = unk_1B3C01BBC;
      *(_OWORD *)&__dst[32] = xmmword_1B3C01BCC;
      *(_DWORD *)&__dst[48] = 1106905750;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C01C50;
      *(_OWORD *)&__dst[128] = xmmword_1B3C01C60;
      *(_OWORD *)&__dst[140] = *(__int128 *)((char *)&xmmword_1B3C01C60 + 12);
      *(_OWORD *)&__dst[48] = unk_1B3C01C10;
      *(_OWORD *)&__dst[64] = xmmword_1B3C01C20;
      *(_OWORD *)&__dst[80] = unk_1B3C01C30;
      *(_OWORD *)&__dst[96] = xmmword_1B3C01C40;
      *(_OWORD *)__dst = xmmword_1B3C01BE0;
      *(_OWORD *)&__dst[16] = unk_1B3C01BF0;
      *(_OWORD *)&__dst[32] = xmmword_1B3C01C00;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B3C01C7C, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B3C01F88, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B3C02294;
      *(_OWORD *)&__dst[16] = unk_1B3C022A4;
      *(_OWORD *)&__dst[32] = xmmword_1B3C022B4;
      *(_DWORD *)&__dst[48] = 1049737453;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 69:
      *(_OWORD *)__dst = xmmword_1B3C022C8;
      *(_OWORD *)&__dst[16] = unk_1B3C022D8;
      *(_OWORD *)&__dst[32] = xmmword_1B3C022E8;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3C022E8 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C02374;
      *(_OWORD *)&__dst[128] = xmmword_1B3C02384;
      *(_OWORD *)&__dst[144] = unk_1B3C02394;
      *(_OWORD *)&__dst[160] = xmmword_1B3C023A4;
      *(_OWORD *)&__dst[48] = unk_1B3C02334;
      *(_OWORD *)&__dst[64] = xmmword_1B3C02344;
      *(_OWORD *)&__dst[80] = unk_1B3C02354;
      *(_OWORD *)&__dst[96] = xmmword_1B3C02364;
      *(_OWORD *)__dst = xmmword_1B3C02304;
      *(_OWORD *)&__dst[16] = unk_1B3C02314;
      *(_OWORD *)&__dst[32] = xmmword_1B3C02324;
      *(_DWORD *)&__dst[176] = 936490775;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3C023B8, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3C0273C, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3C02AC0;
      *(_OWORD *)&__dst[16] = unk_1B3C02AD0;
      *(_OWORD *)&__dst[32] = xmmword_1B3C02AE0;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3C02AE0 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 70:
      *(_OWORD *)__dst = xmmword_1B3C02AFC;
      *(_OWORD *)&__dst[16] = unk_1B3C02B0C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C02B1C;
      *(_DWORD *)&__dst[48] = 1103650039;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C02BA0;
      *(_OWORD *)&__dst[128] = xmmword_1B3C02BB0;
      *(_OWORD *)&__dst[140] = *(__int128 *)((char *)&xmmword_1B3C02BB0 + 12);
      *(_OWORD *)&__dst[48] = unk_1B3C02B60;
      *(_OWORD *)&__dst[64] = xmmword_1B3C02B70;
      *(_OWORD *)&__dst[80] = unk_1B3C02B80;
      *(_OWORD *)&__dst[96] = xmmword_1B3C02B90;
      *(_OWORD *)__dst = xmmword_1B3C02B30;
      *(_OWORD *)&__dst[16] = unk_1B3C02B40;
      *(_OWORD *)&__dst[32] = xmmword_1B3C02B50;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B3C02BCC, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B3C02ED8, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B3C031E4;
      *(_OWORD *)&__dst[16] = unk_1B3C031F4;
      *(_OWORD *)&__dst[32] = xmmword_1B3C03204;
      *(_DWORD *)&__dst[48] = 1051218311;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 71:
      *(_OWORD *)__dst = xmmword_1B3C03218;
      *(_OWORD *)&__dst[16] = unk_1B3C03228;
      *(_OWORD *)&__dst[32] = xmmword_1B3C03238;
      *(_QWORD *)&__dst[48] = 0x41C16A6841B9EA9BLL;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C032C0;
      *(_OWORD *)&__dst[128] = xmmword_1B3C032D0;
      *(_OWORD *)&__dst[144] = unk_1B3C032E0;
      *(_OWORD *)&__dst[48] = unk_1B3C03280;
      *(_OWORD *)&__dst[64] = xmmword_1B3C03290;
      *(_OWORD *)&__dst[80] = unk_1B3C032A0;
      *(_OWORD *)&__dst[96] = xmmword_1B3C032B0;
      *(_OWORD *)__dst = xmmword_1B3C03250;
      *(_OWORD *)&__dst[16] = unk_1B3C03260;
      *(_OWORD *)&__dst[32] = xmmword_1B3C03270;
      *(_QWORD *)&__dst[160] = 0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B3C032F8, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B3C03640, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B3C03988;
      *(_OWORD *)&__dst[16] = unk_1B3C03998;
      *(_OWORD *)&__dst[32] = xmmword_1B3C039A8;
      *(_QWORD *)&__dst[48] = 0x3EADDA8C3EA2B9D4;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 72:
      *(_OWORD *)__dst = xmmword_1B3C0525C;
      *(_OWORD *)&__dst[16] = unk_1B3C0526C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0527C;
      *(_DWORD *)&__dst[48] = 1108299798;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xDuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C05300;
      *(_OWORD *)&__dst[128] = xmmword_1B3C05310;
      *(_OWORD *)&__dst[140] = *(__int128 *)((char *)&xmmword_1B3C05310 + 12);
      *(_OWORD *)&__dst[48] = unk_1B3C052C0;
      *(_OWORD *)&__dst[64] = xmmword_1B3C052D0;
      *(_OWORD *)&__dst[80] = unk_1B3C052E0;
      *(_OWORD *)&__dst[96] = xmmword_1B3C052F0;
      *(_OWORD *)__dst = xmmword_1B3C05290;
      *(_OWORD *)&__dst[16] = unk_1B3C052A0;
      *(_OWORD *)&__dst[32] = xmmword_1B3C052B0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x27uLL);
      memcpy(__dst, &unk_1B3C0532C, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xC3uLL);
      memcpy(__dst, &unk_1B3C05638, 0x30CuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xC3uLL);
      *(_OWORD *)__dst = xmmword_1B3C05944;
      *(_OWORD *)&__dst[16] = unk_1B3C05954;
      *(_OWORD *)&__dst[32] = xmmword_1B3C05964;
      *(_DWORD *)&__dst[48] = 1050384047;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xDuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 73:
      *(_OWORD *)__dst = xmmword_1B3C05978;
      *(_OWORD *)&__dst[16] = unk_1B3C05988;
      *(_OWORD *)&__dst[32] = xmmword_1B3C05998;
      *(_QWORD *)&__dst[48] = 0x4204202B41F0C020;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xEuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C05A20;
      *(_OWORD *)&__dst[128] = xmmword_1B3C05A30;
      *(_OWORD *)&__dst[144] = unk_1B3C05A40;
      *(_OWORD *)&__dst[48] = unk_1B3C059E0;
      *(_OWORD *)&__dst[64] = xmmword_1B3C059F0;
      *(_OWORD *)&__dst[80] = unk_1B3C05A00;
      *(_OWORD *)&__dst[96] = xmmword_1B3C05A10;
      *(_OWORD *)__dst = xmmword_1B3C059B0;
      *(_QWORD *)&__dst[160] = 0x3716FEB5360637BDLL;
      *(_OWORD *)&__dst[16] = unk_1B3C059C0;
      *(_OWORD *)&__dst[32] = xmmword_1B3C059D0;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2AuLL);
      memcpy(__dst, &unk_1B3C05A58, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xD2uLL);
      memcpy(__dst, &unk_1B3C05DA0, 0x348uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xD2uLL);
      *(_OWORD *)__dst = xmmword_1B3C060E8;
      *(_OWORD *)&__dst[16] = unk_1B3C060F8;
      *(_OWORD *)&__dst[32] = xmmword_1B3C06108;
      *(_QWORD *)&__dst[48] = 0x3E87D71B3E77E308;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xEuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 74:
      *(_OWORD *)__dst = xmmword_1B3C06120;
      *(_OWORD *)&__dst[16] = unk_1B3C06130;
      *(_OWORD *)&__dst[32] = xmmword_1B3C06140;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3C06140 + 12);
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0xFuLL);
      *(_OWORD *)&__dst[112] = unk_1B3C061CC;
      *(_OWORD *)&__dst[128] = xmmword_1B3C061DC;
      *(_OWORD *)&__dst[144] = unk_1B3C061EC;
      *(_OWORD *)&__dst[160] = xmmword_1B3C061FC;
      *(_OWORD *)&__dst[48] = unk_1B3C0618C;
      *(_OWORD *)&__dst[64] = xmmword_1B3C0619C;
      *(_OWORD *)&__dst[80] = unk_1B3C061AC;
      *(_OWORD *)&__dst[96] = xmmword_1B3C061BC;
      *(_OWORD *)__dst = xmmword_1B3C0615C;
      *(_OWORD *)&__dst[16] = unk_1B3C0616C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0617C;
      *(_DWORD *)&__dst[176] = 964994326;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x2DuLL);
      memcpy(__dst, &unk_1B3C06210, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xE1uLL);
      memcpy(__dst, &unk_1B3C06594, 0x384uLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xE1uLL);
      *(_OWORD *)__dst = xmmword_1B3C06918;
      *(_OWORD *)&__dst[16] = unk_1B3C06928;
      *(_OWORD *)&__dst[32] = xmmword_1B3C06938;
      *(_OWORD *)&__dst[44] = *(__int128 *)((char *)&xmmword_1B3C06938 + 12);
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0xFuLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 75:
      *(_OWORD *)__dst = xmmword_1B3C06954;
      *(_OWORD *)&__dst[16] = unk_1B3C06964;
      *(_OWORD *)&__dst[32] = xmmword_1B3C06974;
      *(_OWORD *)&__dst[48] = unk_1B3C06984;
      *(_DWORD *)&__dst[64] = 1107585920;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3C06A28;
      *(_OWORD *)&__dst[160] = xmmword_1B3C06A38;
      *(_OWORD *)&__dst[176] = unk_1B3C06A48;
      *(_OWORD *)&__dst[188] = unk_1B3C06A54;
      *(_OWORD *)&__dst[80] = unk_1B3C069E8;
      *(_OWORD *)&__dst[96] = xmmword_1B3C069F8;
      *(_OWORD *)&__dst[112] = unk_1B3C06A08;
      *(_OWORD *)&__dst[128] = xmmword_1B3C06A18;
      *(_OWORD *)&__dst[16] = unk_1B3C069A8;
      *(_OWORD *)&__dst[32] = xmmword_1B3C069B8;
      *(_OWORD *)&__dst[48] = unk_1B3C069C8;
      *(_OWORD *)&__dst[64] = xmmword_1B3C069D8;
      *(_OWORD *)__dst = xmmword_1B3C06998;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3C06A64, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3C06E60, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3C0725C;
      *(_OWORD *)&__dst[16] = unk_1B3C0726C;
      *(_OWORD *)&__dst[32] = xmmword_1B3C0727C;
      *(_OWORD *)&__dst[48] = unk_1B3C0728C;
      *(_DWORD *)&__dst[64] = 1052594043;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
      goto LABEL_189;
    case 76:
      *(_OWORD *)__dst = xmmword_1B3C072A0;
      *(_OWORD *)&__dst[16] = unk_1B3C072B0;
      *(_OWORD *)&__dst[32] = xmmword_1B3C072C0;
      *(_OWORD *)&__dst[48] = unk_1B3C072D0;
      *(_DWORD *)&__dst[64] = 1107151090;
      std::vector<float>::vector[abi:ne180100](&v34, __dst, 0x11uLL);
      *(_OWORD *)&__dst[144] = unk_1B3C07374;
      *(_OWORD *)&__dst[160] = xmmword_1B3C07384;
      *(_OWORD *)&__dst[176] = unk_1B3C07394;
      *(_OWORD *)&__dst[188] = unk_1B3C073A0;
      *(_OWORD *)&__dst[80] = unk_1B3C07334;
      *(_OWORD *)&__dst[96] = xmmword_1B3C07344;
      *(_OWORD *)&__dst[112] = unk_1B3C07354;
      *(_OWORD *)&__dst[128] = xmmword_1B3C07364;
      *(_OWORD *)&__dst[16] = unk_1B3C072F4;
      *(_OWORD *)&__dst[32] = xmmword_1B3C07304;
      *(_OWORD *)&__dst[48] = unk_1B3C07314;
      *(_OWORD *)&__dst[64] = xmmword_1B3C07324;
      *(_OWORD *)__dst = xmmword_1B3C072E4;
      std::vector<float>::vector[abi:ne180100](&v31, __dst, 0x33uLL);
      memcpy(__dst, &unk_1B3C073B0, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](&v28, __dst, 0xFFuLL);
      memcpy(__dst, &unk_1B3C077AC, 0x3FCuLL);
      std::vector<float>::vector[abi:ne180100](v27, __dst, 0xFFuLL);
      *(_OWORD *)__dst = xmmword_1B3C07BA8;
      *(_OWORD *)&__dst[16] = unk_1B3C07BB8;
      *(_OWORD *)&__dst[32] = xmmword_1B3C07BC8;
      *(_OWORD *)&__dst[48] = unk_1B3C07BD8;
      *(_DWORD *)&__dst[64] = 1052644911;
      std::vector<float>::vector[abi:ne180100](&__p, __dst, 0x11uLL);
      if (&__p != (void **)a6)
        std::vector<float>::__assign_with_size[abi:ne180100]<float *,float *>(a6, (char *)__p, (uint64_t)v26, (v26 - (_BYTE *)__p) >> 2);
LABEL_189:
      arkit::unflattenParams((uint64_t)&v34, (uint64_t *)&v31, (uint64_t)&v28, (uint64_t)v27, a2, a3, a4, a5);
      if (__p)
      {
        v26 = __p;
        operator delete(__p);
      }
      if (v27[0])
      {
        v27[1] = v27[0];
        operator delete(v27[0]);
      }
      if (v28)
      {
        v29 = v28;
        operator delete(v28);
      }
      if (v31)
      {
        v32 = v31;
        operator delete(v31);
      }
      v24 = v34;
      if (!v34)
        return;
      v35 = v34;
LABEL_199:
      operator delete(v24);
      return;
    default:
      arkit::loadParams();
  }
}

void sub_1B3AF8890(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26)
{
  if (__p)
    operator delete(__p);
  if (a16)
    operator delete(a16);
  if (a19)
    operator delete(a19);
  if (a22)
    operator delete(a22);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<float>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a3);
    v6 = (char *)a1[1];
    memmove(v6, a2, 4 * a3);
    a1[1] = &v6[4 * a3];
  }
  return a1;
}

void sub_1B3AF9924(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float **arkit::sampleSignalToNoise(float **result, _DWORD *a2, _DWORD *a3, float *a4, float *a5, float a6)
{
  float *v6;
  float *v7;
  int v8;
  int v9;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  BOOL v15;
  _BOOL4 v16;
  BOOL v17;
  float v18;
  float v19;
  float v20;
  float v21;
  float v22;

  v6 = *result;
  v7 = result[1];
  if (*result == v7)
  {
    v10 = 0;
    v8 = 0;
    v12 = INFINITY;
    v11 = -INFINITY;
  }
  else
  {
    v8 = 0;
    v9 = 0;
    v10 = 0;
    v11 = -INFINITY;
    v12 = INFINITY;
    do
    {
      v13 = *v6++;
      v14 = v13 - a6;
      v15 = (float)(v13 - a6) <= 0.0;
      if ((float)(v13 - a6) >= 0.0 && (float)(v13 - a6) < v12)
      {
        v12 = v14;
        v8 = v9;
      }
      if (v15 && v14 > v11)
      {
        v10 = v9;
        v11 = v14;
      }
      ++v9;
    }
    while (v6 != v7);
  }
  if (v11 == -INFINITY)
    v10 = v8;
  v16 = v12 == INFINITY;
  if (v12 == INFINITY)
    v8 = v10;
  v17 = v11 == -INFINITY;
  v18 = -v11;
  v19 = v12 - v11;
  v20 = v18 / v19;
  v21 = v12 / v19;
  if (v17)
    v16 = 1;
  if (v16)
    v20 = 0.5;
  *a4 = v20;
  if (v16)
    v22 = 0.5;
  else
    v22 = v21;
  *a5 = v22;
  *a3 = v10;
  *a2 = v8;
  return result;
}

void arkit::gaussianMixtureKernels(int a1@<W0>, arkit *a2@<X1>, uint64_t a3@<X8>, float a4@<S0>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  float v12;
  float *v13;
  float **v14;
  unint64_t v15;
  _QWORD *v16;
  float *v17;
  float *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  float *v24;
  int v25;
  float v26;
  float *v27;
  uint64_t v28;
  float *v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  unint64_t v33;
  char *v34;
  float *v35;
  int v36;
  uint64_t v37;
  float v38;
  float v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  void *__p;
  void *v44;
  uint64_t v45;
  void *v46;
  float *v47;
  float *v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *v52;
  void *v53;
  uint64_t v54;
  void *v55;
  void *v56;
  uint64_t v57;
  void **v58[3];
  uint64_t v59[3];
  uint64_t v60;
  uint64_t v61;
  void *v62;
  void *v63;
  uint64_t v64;
  void **v65[3];
  void **v66[3];
  uint64_t v67[3];
  float *v68;
  float *v69;
  uint64_t v70;

  v68 = 0;
  v69 = 0;
  v70 = 0;
  memset(v67, 0, sizeof(v67));
  memset(v66, 0, sizeof(v66));
  memset(v65, 0, sizeof(v65));
  v62 = 0;
  v63 = 0;
  v64 = 0;
  arkit::loadParams(a1, (char *)&v68, v67, (uint64_t)v66, (uint64_t)v65, (char *)&v62);
  v60 = 0;
  v61 = 0;
  arkit::sampleSignalToNoise(&v68, (_DWORD *)&v61 + 1, &v61, (float *)&v60 + 1, (float *)&v60, a4);
  v7 = SHIDWORD(v61);
  arkit::mixtureKernels((uint64_t *)&v66[0][3 * SHIDWORD(v61)], &v65[0][3 * SHIDWORD(v61)], a2, v59);
  v8 = (int)v61;
  arkit::mixtureKernels((uint64_t *)&v66[0][3 * (int)v61], &v65[0][3 * (int)v61], a2, (uint64_t *)v58);
  v56 = 0;
  v57 = 0;
  v55 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v55, *(const void **)(v67[0] + 24 * (int)v7), *(_QWORD *)(v67[0] + 24 * (int)v7 + 8), (uint64_t)(*(_QWORD *)(v67[0] + 24 * (int)v7 + 8) - *(_QWORD *)(v67[0] + 24 * (int)v7)) >> 2);
  v41 = v7;
  v42 = a3;
  v40 = v8;
  v53 = 0;
  v54 = 0;
  v52 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(&v52, *(const void **)(v67[0] + 24 * (int)v8), *(_QWORD *)(v67[0] + 24 * (int)v8 + 8), (uint64_t)(*(_QWORD *)(v67[0] + 24 * (int)v8 + 8) - *(_QWORD *)(v67[0] + 24 * (int)v8)) >> 2);
  v9 = 0;
  v49 = 0;
  v50 = 0;
  v51 = 0;
  v46 = 0;
  v47 = 0;
  v48 = 0;
  do
  {
    __p = 0;
    v44 = 0;
    v45 = 0;
    std::vector<std::vector<float>>::push_back[abi:ne180100](&v49, (uint64_t)&__p);
    if (__p)
    {
      v44 = __p;
      operator delete(__p);
    }
    if ((_DWORD)a2)
    {
      v10 = 0;
      do
      {
        v11 = v49 + 24 * v9;
        v12 = (float)(*(float *)&v60 * *((float *)v58[0][3 * v9] + v10))
            + (float)(*((float *)&v60 + 1) * *(float *)(*(_QWORD *)(v59[0] + 24 * v9) + 4 * v10));
        v14 = (float **)(v11 + 8);
        v13 = *(float **)(v11 + 8);
        v16 = (_QWORD *)(v11 + 16);
        v15 = *(_QWORD *)(v11 + 16);
        if ((unint64_t)v13 >= v15)
        {
          v18 = *(float **)v11;
          v19 = ((uint64_t)v13 - *(_QWORD *)v11) >> 2;
          v20 = v19 + 1;
          if ((unint64_t)(v19 + 1) >> 62)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v21 = v15 - (_QWORD)v18;
          if (v21 >> 1 > v20)
            v20 = v21 >> 1;
          if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
            v22 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v22 = v20;
          if (v22)
          {
            v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)v16, v22);
            v13 = *v14;
            v18 = *(float **)v11;
          }
          else
          {
            v23 = 0;
          }
          v24 = (float *)&v23[4 * v19];
          *v24 = v12;
          v17 = v24 + 1;
          while (v13 != v18)
          {
            v25 = *((_DWORD *)v13-- - 1);
            *((_DWORD *)v24-- - 1) = v25;
          }
          *(_QWORD *)v11 = v24;
          *v14 = v17;
          *v16 = &v23[4 * v22];
          if (v18)
            operator delete(v18);
        }
        else
        {
          *v13 = v12;
          v17 = v13 + 1;
        }
        *v14 = v17;
        ++v10;
      }
      while (v10 != a2);
    }
    v26 = (float)(*(float *)&v60 * *((float *)v52 + v9)) + (float)(*((float *)&v60 + 1) * *((float *)v55 + v9));
    v27 = v47;
    if (v47 >= v48)
    {
      v29 = (float *)v46;
      v30 = ((char *)v47 - (_BYTE *)v46) >> 2;
      v31 = v30 + 1;
      if ((unint64_t)(v30 + 1) >> 62)
        std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
      v32 = (char *)v48 - (_BYTE *)v46;
      if (((char *)v48 - (_BYTE *)v46) >> 1 > v31)
        v31 = v32 >> 1;
      if ((unint64_t)v32 >= 0x7FFFFFFFFFFFFFFCLL)
        v33 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v33 = v31;
      if (v33)
      {
        v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v48, v33);
        v29 = (float *)v46;
        v27 = v47;
      }
      else
      {
        v34 = 0;
      }
      v35 = (float *)&v34[4 * v30];
      *v35 = v26;
      v28 = (uint64_t)(v35 + 1);
      while (v27 != v29)
      {
        v36 = *((_DWORD *)v27-- - 1);
        *((_DWORD *)v35-- - 1) = v36;
      }
      v46 = v35;
      v47 = (float *)v28;
      v48 = (float *)&v34[4 * v33];
      if (v29)
        operator delete(v29);
    }
    else
    {
      *v47 = v26;
      v28 = (uint64_t)(v27 + 1);
    }
    v47 = (float *)v28;
    ++v9;
  }
  while (v9 != 3);
  v37 = v60;
  v38 = *((float *)v62 + v41);
  v39 = *((float *)v62 + v40);
  *(_QWORD *)(v42 + 8) = 0;
  *(_QWORD *)(v42 + 16) = 0;
  *(_QWORD *)v42 = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>((_QWORD *)v42, v46, v28, (v28 - (uint64_t)v46) >> 2);
  *(_QWORD *)(v42 + 24) = 0;
  *(_QWORD *)(v42 + 32) = 0;
  *(_QWORD *)(v42 + 40) = 0;
  std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>((_QWORD *)(v42 + 24), v49, v50, 0xAAAAAAAAAAAAAAABLL * ((v50 - v49) >> 3));
  *(float *)(v42 + 48) = (float)(*(float *)&v37 * v39) + (float)(*((float *)&v37 + 1) * v38);
  if (v46)
  {
    v47 = (float *)v46;
    operator delete(v46);
  }
  v46 = &v49;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v46);
  if (v52)
  {
    v53 = v52;
    operator delete(v52);
  }
  if (v55)
  {
    v56 = v55;
    operator delete(v55);
  }
  v55 = v58;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v55);
  v58[0] = (void **)v59;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v58);
  if (v62)
  {
    v63 = v62;
    operator delete(v62);
  }
  v62 = v65;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v62);
  v65[0] = (void **)v66;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](v65);
  v66[0] = (void **)v67;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](v66);
  if (v68)
  {
    v69 = v68;
    operator delete(v68);
  }
}

void sub_1B3AF9EC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char *__p, char *a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,char **a26,char **a27,uint64_t a28,char *a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37,uint64_t a38)
{
  void **v38;
  uint64_t v39;
  void *v41;
  void *v42;

  v41 = *v38;
  if (*v38)
  {
    *(_QWORD *)(a12 + 8) = v41;
    operator delete(v41);
  }
  if (__p)
  {
    a18 = __p;
    operator delete(__p);
  }
  __p = &a20;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (a23)
  {
    a24 = (uint64_t)a23;
    operator delete(a23);
  }
  if (a26)
  {
    a27 = a26;
    operator delete(a26);
  }
  a26 = &a29;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a26);
  a29 = &a32;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a29);
  if (a37)
  {
    a38 = (uint64_t)a37;
    operator delete(a37);
  }
  a37 = (void *)(v39 - 216);
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a37);
  *(_QWORD *)(v39 - 216) = v39 - 192;
  std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 216));
  *(_QWORD *)(v39 - 192) = v39 - 168;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 192));
  v42 = *(void **)(v39 - 144);
  if (v42)
  {
    *(_QWORD *)(v39 - 136) = v42;
    operator delete(v42);
  }
  _Unwind_Resume(a1);
}

void std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::vector<float>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<std::vector<float>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>,std::reverse_iterator<std::vector<float>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::reverse_iterator<std::vector<float>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<float>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<float>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<float>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

void std::vector<std::vector<std::vector<float>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t std::vector<std::vector<std::vector<float>>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>,std::reverse_iterator<std::vector<std::vector<float>>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<std::vector<float>>>,std::reverse_iterator<std::vector<std::vector<float>>*>>::operator()[abi:ne180100](uint64_t a1)
{
  void **v1;
  void **v2;
  void **v3;

  v1 = *(void ***)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(void ***)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = v1;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
    v1 += 3;
  }
}

void **std::__split_buffer<std::vector<std::vector<float>>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::vector<std::vector<float>>>::clear[abi:ne180100]((uint64_t)a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<std::vector<std::vector<float>>>::clear[abi:ne180100](uint64_t a1)
{
  uint64_t i;
  uint64_t v2;
  void **v4;
  void **v5;

  v2 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v2; i = *(_QWORD *)(a1 + 16))
  {
    v4 = (void **)(i - 24);
    *(_QWORD *)(a1 + 16) = v4;
    v5 = v4;
    std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
  }
}

_QWORD *std::vector<float>::vector(_QWORD *a1, unint64_t a2, _DWORD *a3)
{
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_DWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 4 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 4;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B3AFA5B8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<float>>::__push_back_slow_path<std::vector<float> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[24 * v9];
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v11, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<float>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_1B3AFA6D4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<float>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

float std::__split_buffer<float>::push_back(_QWORD *a1, float *a2)
{
  char *v4;
  char *v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  int64_t v14;
  char *v15;
  unint64_t v16;
  char *v17;
  uint64_t v18;
  char *v19;
  int *v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  int v24;
  char *v25;
  float result;

  v4 = (char *)a1[2];
  if (v4 == (char *)a1[3])
  {
    v5 = (char *)a1[1];
    v6 = (uint64_t)&v5[-*a1];
    if ((unint64_t)v5 <= *a1)
    {
      if (v4 == (char *)*a1)
        v16 = 1;
      else
        v16 = (uint64_t)&v4[-*a1] >> 1;
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1[4], v16);
      v19 = &v17[v16 & 0xFFFFFFFFFFFFFFFCLL];
      v20 = (int *)a1[1];
      v4 = v19;
      v21 = a1[2] - (_QWORD)v20;
      if (v21)
      {
        v4 = &v19[v21 & 0xFFFFFFFFFFFFFFFCLL];
        v22 = 4 * (v21 >> 2);
        v23 = &v17[v16 & 0xFFFFFFFFFFFFFFFCLL];
        do
        {
          v24 = *v20++;
          *(_DWORD *)v23 = v24;
          v23 += 4;
          v22 -= 4;
        }
        while (v22);
      }
      v25 = (char *)*a1;
      *a1 = v17;
      a1[1] = v19;
      a1[2] = v4;
      a1[3] = &v17[4 * v18];
      if (v25)
      {
        operator delete(v25);
        v4 = (char *)a1[2];
      }
    }
    else
    {
      v7 = v6 >> 2;
      v8 = v6 >> 2 < -1;
      v9 = (v6 >> 2) + 2;
      if (v8)
        v10 = v9;
      else
        v10 = v7 + 1;
      v11 = -(v10 >> 1);
      v12 = v10 >> 1;
      v13 = &v5[-4 * v12];
      v14 = v4 - v5;
      if (v4 != v5)
      {
        memmove(&v5[-4 * v12], v5, v4 - v5);
        v4 = (char *)a1[1];
      }
      v15 = &v4[4 * v11];
      v4 = &v13[v14];
      a1[1] = v15;
    }
  }
  result = *a2;
  *(float *)v4 = *a2;
  a1[2] = v4 + 4;
  return result;
}

char *std::vector<float>::__swap_out_circular_buffer(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

void std::vector<std::vector<std::vector<float>>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

void std::vector<std::vector<float>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<float>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::vector<std::vector<float>>::__init_with_size[abi:ne180100]<std::vector<float>*,std::vector<float>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B3AFA9C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::vector<float>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<float>>,std::vector<float>*,std::vector<float>*,std::vector<float>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<float>::__init_with_size[abi:ne180100]<float *,float *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1B3AFAAD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  if (v1 != v2)
  {
    v3 = **(_QWORD **)(a1 + 16);
    do
    {
      v5 = *(void **)(v3 - 24);
      v3 -= 24;
      v4 = v5;
      if (v5)
      {
        *(_QWORD *)(v1 - 16) = v4;
        operator delete(v4);
      }
      v1 = v3;
    }
    while (v3 != v2);
  }
}

BOOL operator==(float32x2_t *a1, float32x2_t *a2)
{
  float32x2_t v2;
  float32x2_t v3;

  v2 = vsub_f32(*a1, *a2);
  if (fabsf(sqrtf(vaddv_f32(vmul_f32(v2, v2)))) >= 0.00000011921)
    return 0;
  v3 = vsub_f32(a1[1], a2[1]);
  return fabsf(sqrtf(vaddv_f32(vmul_f32(v3, v3)))) < 0.00000011921;
}

void sub_1B3AFB138(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AFB1D0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_1B3AFB24C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AFB34C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14)
{
  void *v14;

  if (__p)
    operator delete(__p);
  if (a13)
    operator delete(a13);

  _Unwind_Resume(a1);
}

_QWORD *std::vector<ARPatch>::__init_with_size[abi:ne180100]<ARPatch*,ARPatch*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3AFB414(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

float arkit::btr::EstimateScaleReprojectionLinear(uint64_t a1)
{
  const RegistrationData *v1;
  unint64_t v2;
  float result;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  _QWORD v16[3];
  __int128 v17;
  uint64_t v18;
  char v19;

  v1 = *(const RegistrationData **)a1;
  v2 = 0xEFBEFBEFBEFBEFBFLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  result = -1.0;
  if (v2 >= 2)
  {
    v16[0] = 10;
    v16[1] = 0x3CA3D70A3A83126FLL;
    v16[2] = 5;
    v18 = 0x3FF9999A3D4CCCCDLL;
    v19 = 1;
    v17 = xmmword_1B3C07C00;
    v7 = 0;
    v8 = xmmword_1B3C07C14;
    v9 = *(_OWORD *)algn_1B3C07C24;
    v10 = xmmword_1B3C07C34;
    v11 = unk_1B3C07C44;
    v12 = xmmword_1B3C07C14;
    v13 = *(_OWORD *)algn_1B3C07C24;
    v14 = xmmword_1B3C07C34;
    v15 = unk_1B3C07C44;
    v5 = v2 - 1;
    v6 = 504;
    do
    {
      v6 += 504;
      --v5;
    }
    while (v5);
    return *(float *)&v7 / *((float *)&v7 + 1);
  }
  return result;
}

__n128 arkit::btr::`anonymous namespace'::LinearScaleEstimatorOnline::Reset(arkit::btr::_anonymous_namespace_::LinearScaleEstimatorOnline *this, const RegistrationData *a2)
{
  SE3GroupStorage<float, cva::Matrix<float, 4, 4>> *p_cam_from_vio;
  __n128 result;
  uint64_t v6;
  float *v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  float *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  _OWORD *v15;
  uint64_t v16;
  float v17;
  float *v18;
  float v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  _QWORD v28[2];
  _QWORD v29[2];
  uint64_t *v30[2];
  __int128 *v31;
  uint64_t v32;
  _OWORD v33[2];
  int v34;

  *(_QWORD *)this = 0;
  p_cam_from_vio = &a2->cam_from_vio;
  v24 = xmmword_1B3C07C14;
  v25 = *(_OWORD *)algn_1B3C07C24;
  v26 = xmmword_1B3C07C34;
  v27 = unk_1B3C07C44;
  *(_QWORD *)&v33[0] = &a2->cam_from_vio;
  *((_QWORD *)&v33[0] + 1) = 4;
  v30[0] = (uint64_t *)v33;
  v31 = &v24;
  v32 = 4;
  cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v31, v30);
  v29[0] = &v24;
  v29[1] = 4;
  v30[0] = v29;
  v28[0] = &p_cam_from_vio->m_data[12];
  v28[1] = 0xC00000004;
  v31 = (__int128 *)v30;
  v32 = (uint64_t)v28;
  if (p_cam_from_vio == (SE3GroupStorage<float, cva::Matrix<float, 4, 4>> *)&v24)
  {
    DWORD2(v33[0]) = 0;
    *(_QWORD *)&v33[0] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)v33, (uint64_t)&v31);
    *(_QWORD *)&v27 = *(_QWORD *)&v33[0];
    DWORD2(v27) = DWORD2(v33[0]);
  }
  else
  {
    v6 = 0;
    v34 = 0;
    memset(v33, 0, sizeof(v33));
    v7 = (float *)&v24;
    v8 = 0x100000000;
    do
    {
      *(float *)((char *)v33 + v6) = -*v7;
      v9 = HIDWORD(v8);
      v10 = (int)v8 < 2;
      if ((int)v8 < 2)
        v9 = 0;
      v11 = &v7[v9];
      v12 = (v8 + 1);
      v13 = v8 & 0xFFFFFFFF00000000;
      v7 = v11 + 1;
      if (!v10)
        v12 = 0;
      v8 = v12 | v13;
      v6 += 4;
    }
    while (v6 != 36);
    v14 = 0;
    v15 = v33;
    do
    {
      v16 = 0;
      v17 = 0.0;
      v18 = &p_cam_from_vio->m_data[12];
      do
      {
        v19 = *v18++;
        v17 = v17 + (float)(*(float *)((char *)v15 + v16) * v19);
        v16 += 12;
      }
      while (v16 != 36);
      *((float *)&v28[-2] + v14++) = v17;
      v15 = (_OWORD *)((char *)v15 + 4);
    }
    while (v14 != 3);
  }
  v20 = v25;
  *(_OWORD *)((char *)this + 8) = v24;
  *(_OWORD *)((char *)this + 24) = v20;
  result.n128_u64[0] = v26;
  v21 = v27;
  *(_OWORD *)((char *)this + 40) = v26;
  *(_OWORD *)((char *)this + 56) = v21;
  if ((SE3GroupStorage<float, cva::Matrix<float, 4, 4>> *)((char *)this + 72) != &a2->cam_from_obj)
  {
    result = *(__n128 *)a2->cam_from_obj.m_data;
    v22 = *(_OWORD *)&a2->cam_from_obj.m_data[4];
    v23 = *(_OWORD *)&a2->cam_from_obj.m_data[12];
    *(_OWORD *)((char *)this + 104) = *(_OWORD *)&a2->cam_from_obj.m_data[8];
    *(_OWORD *)((char *)this + 120) = v23;
    *(__n128 *)((char *)this + 72) = result;
    *(_OWORD *)((char *)this + 88) = v22;
  }
  return result;
}

unint64_t arkit::btr::`anonymous namespace'::LinearScaleEstimatorOnline::Add(float *a1, uint64_t a2, uint64_t a3, float a4)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  const float *v13;
  float32x2_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  uint64_t v18;
  _OWORD *v19;
  uint64_t v20;
  float v21;
  uint64_t v22;
  const float *v23;
  float32x2_t v24;
  float32x2_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  float *v29;
  float *v30;
  float *v31;
  float v32;
  uint64_t v33;
  float *v34;
  float *v35;
  float v36;
  uint64_t v37;
  float v38;
  float v39;
  float *v40;
  float v41;
  uint64_t v42;
  float v43;
  float v44;
  float v45;
  float v46;
  uint64_t v47;
  float v48;
  float v49;
  float v50;
  _OWORD *v51;
  uint64_t v52;
  const float *v53;
  float32x2_t v54;
  float32x2_t v55;
  float v56;
  float v57;
  _OWORD *v61;
  _OWORD *v62;
  _QWORD *v63;
  _OWORD *v64;
  _OWORD *v65;
  _QWORD *v66;
  float32x2_t v67;
  float v68;
  _OWORD v69[4];
  _OWORD v70[4];
  _OWORD v71[4];
  _OWORD v72[4];
  _OWORD v73[12];
  float32x4_t v74[3];
  __int128 v75;
  _OWORD v76[12];
  float32x2_t v77;

  v6 = 0;
  v7 = a2 + 356;
  v8 = a2 + 128;
  v9 = a2 + 404;
  memset(&v77, 0, 128);
  do
  {
    v10 = a2 + 12 * v6;
    v11 = v6 + 1;
    *(_QWORD *)&v71[0] = *(_QWORD *)(v10 + 128);
    DWORD2(v71[0]) = *(_DWORD *)(v10 + 136);
    v74[0].i64[0] = v7;
    v74[0].i64[1] = 4;
    *(_QWORD *)&v73[0] = v74;
    *((_QWORD *)&v73[0] + 1) = v71;
    *(_QWORD *)((char *)v76 + 4) = 0;
    HIDWORD(v76[0]) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v76 + 4, (float **)v73);
    v12 = 0;
    DWORD2(v72[0]) = 0;
    *(_QWORD *)&v72[0] = 0;
    do
    {
      *(float *)((char *)v72 + v12) = *(float *)((char *)v76 + v12 + 4) + *(float *)(v9 + v12);
      v12 += 4;
    }
    while (v12 != 12);
    v13 = (const float *)v72 + 2;
    v14 = vld1_dup_f32(v13);
    *(&v77 + v6++) = vdiv_f32(*(float32x2_t *)&v72[0], v14);
  }
  while (v11 != 16);
  v15 = 0;
  memset(v76, 0, sizeof(v76));
  do
  {
    v16 = v8 + 12 * v15;
    *(_QWORD *)&v70[0] = *(_QWORD *)v16;
    DWORD2(v70[0]) = *(_DWORD *)(v16 + 8);
    *(_QWORD *)&v72[0] = a1 + 18;
    *((_QWORD *)&v72[0] + 1) = 4;
    v17 = (char *)v76 + 12 * v15++;
    v74[0].i64[0] = (uint64_t)v72;
    v74[0].i64[1] = (uint64_t)v70;
    *(_QWORD *)((char *)v73 + 4) = 0;
    HIDWORD(v73[0]) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v73 + 4, (float **)v74);
    v18 = 0;
    DWORD2(v71[0]) = 0;
    *(_QWORD *)&v71[0] = 0;
    do
    {
      *(float *)((char *)v71 + v18 * 4) = *(float *)((char *)v73 + v18 * 4 + 4) + a1[v18 + 30];
      ++v18;
    }
    while (v18 != 3);
    *(_QWORD *)v17 = *(_QWORD *)&v71[0];
    *((_DWORD *)v17 + 2) = DWORD2(v71[0]);
  }
  while (v15 != 16);
  *(_QWORD *)&v73[0] = a2 + 420;
  *((_QWORD *)&v73[0] + 1) = a1 + 2;
  memset(v74, 0, sizeof(v74));
  v75 = 0u;
  cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(v74, (float32x4_t **)v73);
  *(_QWORD *)&v71[0] = v74;
  *((_QWORD *)&v71[0] + 1) = 4;
  *(_QWORD *)&v72[0] = v71;
  *((_QWORD *)&v72[0] + 1) = v76;
  memset(v73, 0, sizeof(v73));
  v19 = v73;
  cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>((uint64_t *)v73, (uint64_t **)v72);
  v20 = 0;
  *(_QWORD *)&v71[0] = v75;
  DWORD2(v71[0]) = DWORD2(v75);
  v21 = 0.0;
  do
  {
    v22 = 0;
    DWORD2(v72[0]) = 0;
    *(_QWORD *)&v72[0] = 0;
    do
    {
      *(float *)((char *)v72 + v22) = (float)(*(float *)((char *)v19 + v22) * a4) + *(float *)((char *)v71 + v22);
      v22 += 4;
    }
    while (v22 != 12);
    v23 = (const float *)v72 + 2;
    v24 = vld1_dup_f32(v23);
    v25 = vsub_f32(vdiv_f32(*(float32x2_t *)&v72[0], v24), *(&v77 + v20));
    v21 = v21 + sqrtf(vaddv_f32(vmul_f32(v25, v25)));
    v19 = (_OWORD *)((char *)v19 + 12);
    ++v20;
  }
  while (v20 != 16);
  v26 = v21 * 0.0625;
  if ((float)(v21 * 0.0625) >= *(float *)(a3 + 36))
  {
    v28 = 0;
    v29 = (float *)v73 + 2;
    memset(v72, 0, sizeof(v72));
    v30 = (float *)&v77;
    v31 = (float *)v73 + 2;
    do
    {
      v32 = *v30;
      v30 += 2;
      *(float *)((char *)v72 + v28) = (float)(*v31 * v32) - *(v31 - 2);
      v31 += 3;
      v28 += 4;
    }
    while (v28 != 64);
    v33 = 0;
    v34 = (float *)&v77 + 1;
    memset(v71, 0, sizeof(v71));
    v35 = (float *)&v77 + 1;
    do
    {
      v36 = *v35;
      v35 += 2;
      *(float *)((char *)v71 + v33) = (float)(*v29 * v36) - *(v29 - 1);
      v29 += 3;
      v33 += 4;
    }
    while (v33 != 64);
    v37 = 0;
    v38 = *((float *)&v75 + 2);
    v39 = *(float *)&v75;
    memset(v70, 0, sizeof(v70));
    v40 = (float *)&v77;
    do
    {
      v41 = *v40;
      v40 += 2;
      *(float *)((char *)v70 + v37) = v39 - (float)(v41 * v38);
      v37 += 4;
    }
    while (v37 != 64);
    v42 = 0;
    v43 = *((float *)&v75 + 1);
    memset(v69, 0, sizeof(v69));
    do
    {
      v44 = *v34;
      v34 += 2;
      *(float *)((char *)v69 + v42) = v43 - (float)(v44 * v38);
      v42 += 4;
    }
    while (v42 != 64);
    v64 = v70;
    v65 = v72;
    v66 = &v64;
    v61 = v69;
    v62 = v71;
    v63 = &v61;
    v67.i32[1] = 0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>((float *)&v67 + 1, (uint64_t)&v65);
    v68 = 0.0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v68, (uint64_t)&v62);
    v45 = v67.f32[1];
    v46 = v68;
    v64 = v72;
    v65 = v72;
    v66 = &v64;
    v61 = v71;
    v62 = v71;
    v63 = &v61;
    v67.i32[1] = 0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>((float *)&v67 + 1, (uint64_t)&v65);
    v68 = 0.0;
    cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v68, (uint64_t)&v62);
    v47 = 0;
    v65 = (_OWORD *)v75;
    LODWORD(v66) = DWORD2(v75);
    v48 = v67.f32[1] + v68;
    v49 = (float)(v45 + v46) / (float)(v67.f32[1] + v68);
    v50 = 0.0;
    v51 = v73;
    do
    {
      v52 = 0;
      v68 = 0.0;
      v67 = 0;
      do
      {
        v67.f32[v52] = (float)(v49 * *(float *)((char *)v51 + v52 * 4)) + *(float *)((char *)&v65 + v52 * 4);
        ++v52;
      }
      while (v52 != 3);
      v53 = &v68;
      v54 = vld1_dup_f32(v53);
      v55 = vsub_f32(vdiv_f32(v67, v54), *(&v77 + v47));
      v50 = v50 + sqrtf(vaddv_f32(vmul_f32(v55, v55)));
      v51 = (_OWORD *)((char *)v51 + 12);
      ++v47;
    }
    while (v47 != 16);
    v56 = v50 * 0.0625;
    if (v56 <= (float)(v26 * 1.001))
    {
      v57 = v48 + a1[1];
      *a1 = (float)(v45 + v46) + *a1;
      a1[1] = v57;
      v27 = 13;
      v56 = v49;
    }
    else
    {
      v27 = 8;
    }
    v26 = v56;
  }
  else
  {
    v27 = 12;
  }
  return v27 | ((unint64_t)LODWORD(v26) << 32);
}

void arkit::btr::ComputeReprojectionErrorS(uint64_t **a1, float a2)
{
  uint64_t **v3;
  uint64_t v5;
  __int128 v6;
  __int128 v7;
  uint64_t i;
  float32x4_t *v9;
  uint64_t v10;
  float *v11;
  unint64_t v12;
  unint64_t v13;
  BOOL v14;
  float *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  float32x4_t *v19;
  uint64_t v20;
  float v21;
  float *f32;
  float v23;
  uint64_t v24;
  unint64_t v25;
  float v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t j;
  uint64_t v32;
  __int128 *v33;
  uint64_t v34;
  uint64_t v35;
  const float *v36;
  float32x2_t v37;
  float32x2_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  float32x2_t v44;
  uint64_t v45;
  const float *v46;
  float32x2_t v47;
  float32x2_t v48;
  unint64_t v49;
  uint64_t **v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  int v54;
  float32x2_t v55;
  int v56;
  __int128 v57;
  __int128 v58;
  __int128 v59;
  __int128 v60;
  float32x4_t v61;
  __int128 v62;
  __int128 v63;
  __int128 v64;
  _OWORD v65[4];
  float32x4_t *v66;
  uint64_t v67;
  __int128 *v68;
  uint64_t v69;
  __int128 **v70;
  uint64_t v71;
  _OWORD v72[2];

  if (a2 >= 0.0 && (unint64_t)((char *)a1[1] - (char *)*a1) >= 0x10)
  {
    v3 = a1;
    v5 = **a1;
    v6 = *(_OWORD *)(v5 + 372);
    v65[0] = *(_OWORD *)(v5 + 356);
    v65[1] = v6;
    v7 = *(_OWORD *)(v5 + 404);
    v65[2] = *(_OWORD *)(v5 + 388);
    v65[3] = v7;
    for (i = 48; i != 60; i += 4)
      *(float *)((char *)v65 + i) = *(float *)((char *)v65 + i) * a2;
    v9 = (float32x4_t *)(v5 + 420);
    v57 = xmmword_1B3C07C14;
    v58 = *(_OWORD *)algn_1B3C07C24;
    v59 = xmmword_1B3C07C34;
    v60 = unk_1B3C07C44;
    v61.i64[0] = v5 + 420;
    v61.i64[1] = 4;
    v70 = (__int128 **)&v61;
    *(_QWORD *)&v72[0] = &v57;
    *((_QWORD *)&v72[0] + 1) = 4;
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)v72, (uint64_t **)&v70);
    v68 = &v57;
    v69 = 4;
    v70 = &v68;
    v66 = v9 + 3;
    v67 = 0xC00000004;
    *(_QWORD *)&v72[0] = &v70;
    *((_QWORD *)&v72[0] + 1) = &v66;
    if (v9 == (float32x4_t *)&v57)
    {
      v61.i32[2] = 0;
      v61.i64[0] = 0;
      cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v61, (uint64_t)v72);
      *(_QWORD *)&v60 = v61.i64[0];
      DWORD2(v60) = v61.i32[2];
    }
    else
    {
      v10 = 0;
      LODWORD(v63) = 0;
      v61 = 0u;
      v62 = 0u;
      v11 = (float *)&v57;
      v12 = 0x100000000;
      do
      {
        v61.f32[v10] = -*v11;
        v13 = HIDWORD(v12);
        v14 = (int)v12 < 2;
        if ((int)v12 < 2)
          v13 = 0;
        v15 = &v11[v13];
        v16 = (v12 + 1);
        v17 = v12 & 0xFFFFFFFF00000000;
        v11 = v15 + 1;
        if (!v14)
          v16 = 0;
        v12 = v16 | v17;
        ++v10;
      }
      while (v10 != 9);
      v18 = 0;
      v19 = &v61;
      do
      {
        v20 = 0;
        v21 = 0.0;
        f32 = v9[3].f32;
        do
        {
          v23 = *f32++;
          v21 = v21 + (float)(v19->f32[v20] * v23);
          v20 += 3;
        }
        while (v20 != 9);
        *((float *)&v60 + v18++) = v21;
        v19 = (float32x4_t *)((char *)v19 + 4);
      }
      while (v18 != 3);
    }
    *(_QWORD *)&v72[0] = &v57;
    *((_QWORD *)&v72[0] + 1) = v65;
    v61 = 0u;
    v62 = 0u;
    v63 = 0u;
    v64 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v61, (float32x4_t **)v72);
    v24 = (char *)v3[1] - (char *)*v3;
    if ((unint64_t)v24 >= 9)
    {
      v25 = v24 >> 3;
      if (v25 <= 2)
        v25 = 2;
      v49 = v25;
      v26 = 0.0;
      v52 = 1;
      v50 = v3;
      do
      {
        v27 = 0;
        v28 = 128;
        do
        {
          v29 = (*v3)[v52];
          v30 = 3 * v27;
          LODWORD(v69) = 0;
          v68 = 0;
          if ((__int128 **)(v29 + 128) == &v68)
          {
            v32 = v29 + 128 + 12 * v27;
            v33 = *(__int128 **)v32;
            LODWORD(v69) = *(_DWORD *)(v32 + 8);
            v68 = v33;
          }
          else
          {
            for (j = 0; j != 12; j += 4)
              *(_DWORD *)((char *)&v68 + j) = *(_DWORD *)(v29 + v28 + j);
          }
          v51 = v27 + 1;
          v70 = (__int128 **)(v29 + 356);
          v71 = 4;
          *(_QWORD *)&v72[0] = &v70;
          *((_QWORD *)&v72[0] + 1) = &v68;
          v34 = v29 + 404;
          *(_QWORD *)((char *)&v57 + 4) = 0;
          HIDWORD(v57) = 0;
          cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v57 + 4, (float **)v72);
          v35 = 0;
          LODWORD(v67) = 0;
          v66 = 0;
          do
          {
            *(float *)((char *)&v66 + v35) = *(float *)((char *)&v57 + v35 + 4) + *(float *)(v34 + v35);
            v35 += 4;
          }
          while (v35 != 12);
          v36 = (const float *)&v67;
          v37 = vld1_dup_f32(v36);
          v38 = (float32x2_t)v66;
          *(_QWORD *)&v72[0] = (*v50)[v52] + 420;
          *((_QWORD *)&v72[0] + 1) = &v61;
          v57 = 0u;
          v58 = 0u;
          v59 = 0u;
          v60 = 0u;
          cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>((float32x4_t *)&v57, (float32x4_t **)v72);
          v39 = (*v50)[v52];
          v53 = 0;
          v54 = 0;
          if ((uint64_t *)(v39 + 4 * v30 - 4 * v30 + 128) == &v53)
          {
            v42 = 0;
            DWORD2(v72[0]) = 0;
            *(_QWORD *)&v72[0] = 0;
            v43 = v39 + v28;
            do
            {
              *(float *)((char *)v72 + v42) = *(float *)(v43 + v42) * a2;
              v42 += 4;
            }
            while (v42 != 12);
            v53 = *(_QWORD *)&v72[0];
            v54 = DWORD2(v72[0]);
            v3 = v50;
          }
          else
          {
            v40 = 0;
            v41 = v39 + v28;
            v3 = v50;
            do
            {
              *(float *)((char *)&v53 + v40) = *(float *)(v41 + v40) * a2;
              v40 += 4;
            }
            while (v40 != 12);
          }
          v44 = vdiv_f32(v38, v37);
          v68 = &v57;
          v69 = 4;
          v70 = &v68;
          v71 = (uint64_t)&v53;
          *(_QWORD *)((char *)v72 + 4) = 0;
          HIDWORD(v72[0]) = 0;
          cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v72 + 4, (float **)&v70);
          v45 = 0;
          v56 = 0;
          v55 = 0;
          do
          {
            v55.f32[v45] = *(float *)((char *)v72 + v45 * 4 + 4) + *(float *)((char *)&v60 + v45 * 4);
            ++v45;
          }
          while (v45 != 3);
          v46 = (const float *)&v56;
          v47 = vld1_dup_f32(v46);
          v48 = vsub_f32(vdiv_f32(v55, v47), v44);
          v26 = v26 + sqrtf(vaddv_f32(vmul_f32(v48, v48)));
          v28 += 12;
          v27 = v51;
        }
        while (v51 != 16);
        ++v52;
      }
      while (v52 != v49);
    }
  }
}

uint64_t arkit::btr::ScaleCorrection::ScaleCorrection(uint64_t a1, __int128 *a2)
{
  __int128 v3;
  __int128 v4;
  __int128 v5;

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v3;
  _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((_QWORD *)(a1 + 56));
  return a1;
}

{
  __int128 v3;
  __int128 v4;
  __int128 v5;

  v3 = *a2;
  v4 = a2[1];
  v5 = a2[2];
  *(_QWORD *)(a1 + 48) = *((_QWORD *)a2 + 6);
  *(_OWORD *)(a1 + 16) = v4;
  *(_OWORD *)(a1 + 32) = v5;
  *(_OWORD *)a1 = v3;
  _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_((_QWORD *)(a1 + 56));
  return a1;
}

float arkit::btr::ScaleCorrection::EstimateScale(uint64_t a1, uint64_t a2, float *a3)
{
  float *v3;
  uint64_t v5;
  uint64_t v6;
  __int128 *v7;
  uint64_t v8;
  float *v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  float *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  __int128 *v17;
  uint64_t v18;
  float v19;
  float *v20;
  float v21;
  uint64_t v22;
  float *v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  BOOL v27;
  float *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  __int128 *v32;
  uint64_t v33;
  float v34;
  float *v35;
  float v36;
  __int128 v37;
  __int128 v38;
  unint64_t v39;
  __int128 v40;
  __int128 v41;
  float v42;
  uint64_t v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  uint64_t v51;
  int32x2_t v52;
  float32x4_t v53;
  uint64_t v54;
  float *v55;
  float32x4_t v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  BOOL v60;
  float *v61;
  uint64_t v62;
  unint64_t v63;
  float v64;
  uint64_t i;
  uint64_t v66;
  float v67;
  float *v68;
  float v69;
  uint64_t j;
  float v71;
  uint64_t v72;
  char *v73;
  std::__shared_weak_count *v74;
  unint64_t *v75;
  unint64_t v76;
  uint64_t v77;
  float v78;
  unint64_t v79;
  float v80;
  float v81;
  unint64_t v82;
  uint64_t v83;
  char *v85;
  std::__shared_weak_count *v86;
  unint64_t *v87;
  unint64_t v88;
  float v89;
  uint64_t v90;
  unint64_t v91;
  unint64_t v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  __int128 v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  __int128 v102;
  int v103;
  __int128 v104;
  __int128 v105;
  __int128 v106;
  _OWORD v107[9];
  float32x4_t v108;
  __int128 v109;
  _QWORD v110[2];
  __int128 *v111;
  uint64_t v112;
  uint64_t *v113[2];
  __int128 *v114;
  uint64_t v115;

  v3 = a3;
  v5 = a1 + 56;
  v6 = *(_QWORD *)(a1 + 56);
  if (!*(_BYTE *)(a1 + 48) || !*(_BYTE *)(v6 + 5))
  {
    v7 = (__int128 *)(a2 + 420);
    if (*(_BYTE *)(v6 + 8))
    {
      *(_BYTE *)(v6 + 8) = 0;
      v104 = xmmword_1B3C07C14;
      v105 = *(_OWORD *)algn_1B3C07C24;
      v106 = xmmword_1B3C07C34;
      v107[0] = unk_1B3C07C44;
      *(_QWORD *)&v98 = a2 + 420;
      *((_QWORD *)&v98 + 1) = 4;
      v114 = &v98;
      v108.i64[0] = (uint64_t)&v104;
      v108.i64[1] = 4;
      cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v108, (uint64_t **)&v114);
      v113[0] = (uint64_t *)&v104;
      v113[1] = (uint64_t *)4;
      v114 = (__int128 *)v113;
      v111 = (__int128 *)(a2 + 468);
      v112 = 0xC00000004;
      v108.i64[0] = (uint64_t)&v114;
      v108.i64[1] = (uint64_t)&v111;
      if (v7 == &v104)
      {
        DWORD2(v98) = 0;
        *(_QWORD *)&v98 = 0;
        cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v98, (uint64_t)&v108);
        *(_QWORD *)&v107[0] = v98;
        DWORD2(v107[0]) = DWORD2(v98);
      }
      else
      {
        v8 = 0;
        LODWORD(v100) = 0;
        v98 = 0u;
        v99 = 0u;
        v9 = (float *)&v104;
        v10 = 0x100000000;
        do
        {
          *(float *)((char *)&v98 + v8) = -*v9;
          v11 = HIDWORD(v10);
          v12 = (int)v10 < 2;
          if ((int)v10 < 2)
            v11 = 0;
          v13 = &v9[v11];
          v14 = (v10 + 1);
          v15 = v10 & 0xFFFFFFFF00000000;
          v9 = v13 + 1;
          if (!v12)
            v14 = 0;
          v10 = v14 | v15;
          v8 += 4;
        }
        while (v8 != 36);
        v16 = 0;
        v17 = &v98;
        do
        {
          v18 = 0;
          v19 = 0.0;
          v20 = (float *)(a2 + 468);
          do
          {
            v21 = *v20++;
            v19 = v19 + (float)(*(float *)((char *)v17 + v18) * v21);
            v18 += 12;
          }
          while (v18 != 36);
          *((float *)v107 + v16++) = v19;
          v17 = (__int128 *)((char *)v17 + 4);
        }
        while (v16 != 3);
      }
      v37 = v105;
      *(_OWORD *)(v6 + 408) = v104;
      *(_OWORD *)(v6 + 424) = v37;
      v38 = v107[0];
      *(_OWORD *)(v6 + 440) = v106;
      *(_OWORD *)(v6 + 456) = v38;
      v39 = 1;
      goto LABEL_34;
    }
    *(_QWORD *)&v104 = a2 + 420;
    *((_QWORD *)&v104 + 1) = v6 + 408;
    memset(&v108, 0, 48);
    v109 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v108, (float32x4_t **)&v104);
    v104 = xmmword_1B3C07C14;
    v105 = *(_OWORD *)algn_1B3C07C24;
    v106 = xmmword_1B3C07C34;
    v107[0] = unk_1B3C07C44;
    *(_QWORD *)&v98 = a2 + 420;
    *((_QWORD *)&v98 + 1) = 4;
    v113[0] = (uint64_t *)&v98;
    v114 = &v104;
    v115 = 4;
    cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>((uint64_t)&v114, v113);
    v111 = &v104;
    v112 = 4;
    v113[0] = (uint64_t *)&v111;
    v110[0] = a2 + 468;
    v110[1] = 0xC00000004;
    v114 = (__int128 *)v113;
    v115 = (uint64_t)v110;
    if (v7 == &v104)
    {
      DWORD2(v98) = 0;
      *(_QWORD *)&v98 = 0;
      cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>((uint64_t)&v98, (uint64_t)&v114);
      v3 = a3;
      *(_QWORD *)&v107[0] = v98;
      DWORD2(v107[0]) = DWORD2(v98);
      v25 = a1;
    }
    else
    {
      v22 = 0;
      LODWORD(v100) = 0;
      v23 = (float *)&v104;
      v24 = 0x100000000;
      v98 = 0u;
      v99 = 0u;
      v25 = a1;
      do
      {
        *(float *)((char *)&v98 + v22) = -*v23;
        v26 = HIDWORD(v24);
        v27 = (int)v24 < 2;
        if ((int)v24 < 2)
          v26 = 0;
        v28 = &v23[v26];
        v29 = (v24 + 1);
        v30 = v24 & 0xFFFFFFFF00000000;
        v23 = v28 + 1;
        if (!v27)
          v29 = 0;
        v24 = v29 | v30;
        v22 += 4;
      }
      while (v22 != 36);
      v31 = 0;
      v32 = &v98;
      v3 = a3;
      do
      {
        v33 = 0;
        v34 = 0.0;
        v35 = (float *)(a2 + 468);
        do
        {
          v36 = *v35++;
          v34 = v34 + (float)(*(float *)((char *)v32 + v33) * v36);
          v33 += 12;
        }
        while (v33 != 36);
        *((float *)v107 + v31++) = v34;
        v32 = (__int128 *)((char *)v32 + 4);
      }
      while (v31 != 3);
    }
    v40 = v105;
    *(_OWORD *)(v6 + 408) = v104;
    *(_OWORD *)(v6 + 424) = v40;
    v41 = v107[0];
    *(_OWORD *)(v6 + 440) = v106;
    *(_OWORD *)(v6 + 456) = v41;
    v42 = sqrtf((float)((float)(*(float *)&v109 * *(float *)&v109) + (float)(*((float *)&v109 + 1) * *((float *)&v109 + 1)))+ (float)(*((float *)&v109 + 2) * *((float *)&v109 + 2)));
    if (v42 < *(float *)(v25 + 8))
    {
      v39 = ((unint64_t)LODWORD(v42) << 32) | 1;
      goto LABEL_34;
    }
    if (v42 <= *(float *)(v25 + 12))
    {
      v44 = 0;
      v45 = *(_OWORD *)(a2 + 272);
      v107[5] = *(_OWORD *)(a2 + 256);
      v107[6] = v45;
      v46 = *(_OWORD *)(a2 + 304);
      v107[7] = *(_OWORD *)(a2 + 288);
      v107[8] = v46;
      v47 = *(_OWORD *)(a2 + 208);
      v107[1] = *(_OWORD *)(a2 + 192);
      v107[2] = v47;
      v48 = *(_OWORD *)(a2 + 240);
      v107[3] = *(_OWORD *)(a2 + 224);
      v107[4] = v48;
      v49 = *(_OWORD *)(a2 + 144);
      v104 = *(_OWORD *)(a2 + 128);
      v105 = v49;
      v50 = *(_OWORD *)(a2 + 176);
      v106 = *(_OWORD *)(a2 + 160);
      v52.i32[1] = DWORD1(v106);
      v107[0] = v50;
      v51 = *(_QWORD *)(v6 + 16) + 1;
      *(_QWORD *)(v6 + 16) = v51;
      *(float *)v52.i32 = (float)(unint64_t)v51;
      v53 = (float32x4_t)vdupq_lane_s32(v52, 0);
      do
      {
        *(float32x4_t *)(v6 + 24 + v44) = vaddq_f32(*(float32x4_t *)(v6 + 24 + v44), vdivq_f32(vsubq_f32(*(float32x4_t *)((char *)&v104 + v44), *(float32x4_t *)(v6 + 24 + v44)), v53));
        v44 += 16;
      }
      while (v44 != 192);
      v54 = 0;
      v55 = (float *)(v6 + 216);
      do
      {
        v56 = vsubq_f32(*(float32x4_t *)((char *)&v104 + v54), *(float32x4_t *)(v6 + v54 + 24));
        *(float32x4_t *)(v6 + v54 + 216) = vaddq_f32(*(float32x4_t *)(v6 + v54 + 216), vmulq_f32(v56, v56));
        v54 += 16;
      }
      while (v54 != 192);
      v57 = 0;
      v58 = 0;
      v103 = 0;
      v101 = 0u;
      v102 = 0u;
      v99 = 0u;
      v100 = 0u;
      v98 = 0u;
      do
      {
        *(float *)((char *)&v98 + v57) = *v55 / *(float *)v52.i32;
        v59 = HIDWORD(v58);
        v60 = (int)v58 < 2;
        if ((int)v58 < 2)
          v59 = 0;
        v61 = &v55[v59];
        v62 = (v58 + 1);
        v63 = v58 & 0xFFFFFFFF00000000;
        v55 = v61 + 1;
        if (!v60)
          v62 = 0;
        v58 = v62 | v63;
        v57 += 4;
      }
      while (v57 != 84);
      v64 = *(float *)&v98;
      for (i = 12; i != 84; i += 12)
        v64 = v64 + *(float *)((char *)&v98 + i);
      v66 = 1;
      v67 = sqrtf(v64);
      do
      {
        v68 = (float *)&v98 + v66;
        v69 = *v68;
        for (j = 3; j != 21; j += 3)
          v69 = v69 + v68[j];
        v71 = sqrtf(v69);
        if (v67 < v71)
          v67 = v71;
        v66 = (v66 + 1);
      }
      while ((_DWORD)v66 != 3);
      v72 = 13;
      if (v67 > *(float *)(v25 + 32))
      {
        v72 = 5;
        v42 = v67;
      }
      *(_QWORD *)v3 = v72 | ((unint64_t)LODWORD(v42) << 32);
      if ((_DWORD)v72 != 5)
        goto LABEL_66;
    }
    else
    {
      *(_QWORD *)v3 = ((unint64_t)LODWORD(v42) << 32) | 2;
    }
    v73 = (char *)operator new(0x2A8uLL);
    *(_OWORD *)(v73 + 8) = 0u;
    *(_QWORD *)v73 = &unk_1E66705A8;
    *(_OWORD *)(v73 + 24) = 0u;
    *((_DWORD *)v73 + 6) = 1065353216;
    v73[32] = 1;
    *(_OWORD *)(v73 + 40) = 0u;
    *(_OWORD *)(v73 + 56) = 0u;
    *(_OWORD *)(v73 + 72) = 0u;
    *(_OWORD *)(v73 + 88) = 0u;
    *(_OWORD *)(v73 + 104) = 0u;
    *(_OWORD *)(v73 + 120) = 0u;
    *(_OWORD *)(v73 + 136) = 0u;
    *(_OWORD *)(v73 + 152) = 0u;
    *(_OWORD *)(v73 + 168) = 0u;
    *(_OWORD *)(v73 + 184) = 0u;
    *(_OWORD *)(v73 + 200) = 0u;
    *(_OWORD *)(v73 + 216) = 0u;
    *(_OWORD *)(v73 + 232) = 0u;
    *(_OWORD *)(v73 + 248) = 0u;
    *((_QWORD *)v73 + 53) = 0;
    *(_OWORD *)(v73 + 264) = 0u;
    *(_OWORD *)(v73 + 280) = 0u;
    *(_OWORD *)(v73 + 296) = 0u;
    *(_OWORD *)(v73 + 312) = 0u;
    *(_OWORD *)(v73 + 328) = 0u;
    *(_OWORD *)(v73 + 344) = 0u;
    *(_OWORD *)(v73 + 360) = 0u;
    *(_OWORD *)(v73 + 376) = 0u;
    *(_OWORD *)(v73 + 392) = 0u;
    *(_OWORD *)(v73 + 408) = 0u;
    *((_OWORD *)v73 + 27) = xmmword_1B3C07C14;
    *((_OWORD *)v73 + 28) = *(_OWORD *)algn_1B3C07C24;
    *((_OWORD *)v73 + 29) = xmmword_1B3C07C34;
    *((_OWORD *)v73 + 30) = unk_1B3C07C44;
    *((_QWORD *)v73 + 62) = 0;
    *(_OWORD *)(v73 + 504) = xmmword_1B3C07C14;
    *(_OWORD *)(v73 + 520) = *(_OWORD *)algn_1B3C07C24;
    *(_OWORD *)(v73 + 536) = xmmword_1B3C07C34;
    *(_OWORD *)(v73 + 552) = unk_1B3C07C44;
    *(_OWORD *)(v73 + 568) = xmmword_1B3C07C14;
    *(_OWORD *)(v73 + 584) = *(_OWORD *)algn_1B3C07C24;
    *(_OWORD *)(v73 + 600) = xmmword_1B3C07C34;
    *(_OWORD *)(v73 + 616) = unk_1B3C07C44;
    *(_OWORD *)(v73 + 632) = 0u;
    *((_DWORD *)v73 + 162) = 1065353216;
    *((_DWORD *)v73 + 169) = 0;
    *(_QWORD *)(v73 + 668) = 0;
    *(_OWORD *)(v73 + 652) = 0u;
    *(_QWORD *)&v104 = v73 + 24;
    *((_QWORD *)&v104 + 1) = v73;
    std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::operator=[abi:ne180100](v5, &v104);
    v74 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
    if (*((_QWORD *)&v104 + 1))
    {
      v75 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
      do
        v76 = __ldaxr(v75);
      while (__stlxr(v76 - 1, v75));
      if (!v76)
      {
        ((void (*)(std::__shared_weak_count *))v74->__on_zero_shared)(v74);
        std::__shared_weak_count::__release_weak(v74);
      }
    }
    *(float *)&v72 = *v3;
LABEL_66:
    if ((_DWORD)v72 != 13)
      goto LABEL_35;
    v77 = *(_QWORD *)v5;
    if (*(_BYTE *)(*(_QWORD *)v5 + 4))
    {
      v78 = v3[1];
      *(_QWORD *)v3 = v79;
      v6 = *(_QWORD *)(v25 + 56);
      if ((_DWORD)v79 != 13)
        return *(float *)v6;
      v80 = *(float *)(v6 + 472) / *(float *)(v6 + 476);
      v81 = v78 + *(float *)(v6 + 628);
      *(float *)(v6 + 628) = v81;
      v82 = *(_QWORD *)(v6 + 608) + 1;
      *(_QWORD *)(v6 + 608) = v82;
      if (v82 >= *(_QWORD *)v25)
      {
        if (v81 >= *(float *)(v25 + 28))
        {
          if (*(float *)(v25 + 40) > v80 || *(float *)(v25 + 44) < v80)
          {
            *(_QWORD *)v3 = ((unint64_t)LODWORD(v80) << 32) | 0xB;
            v3[1] = *((float *)&v79 + 1);
            v85 = (char *)operator new(0x2A8uLL);
            *(_OWORD *)(v85 + 8) = 0u;
            *(_QWORD *)v85 = &unk_1E66705A8;
            *(_OWORD *)(v85 + 24) = 0u;
            *((_DWORD *)v85 + 6) = 1065353216;
            v85[32] = 1;
            *(_OWORD *)(v85 + 40) = 0u;
            *(_OWORD *)(v85 + 56) = 0u;
            *(_OWORD *)(v85 + 72) = 0u;
            *(_OWORD *)(v85 + 88) = 0u;
            *(_OWORD *)(v85 + 104) = 0u;
            *(_OWORD *)(v85 + 120) = 0u;
            *(_OWORD *)(v85 + 136) = 0u;
            *(_OWORD *)(v85 + 152) = 0u;
            *(_OWORD *)(v85 + 168) = 0u;
            *(_OWORD *)(v85 + 184) = 0u;
            *(_OWORD *)(v85 + 200) = 0u;
            *(_OWORD *)(v85 + 216) = 0u;
            *(_OWORD *)(v85 + 232) = 0u;
            *(_OWORD *)(v85 + 248) = 0u;
            *((_QWORD *)v85 + 53) = 0;
            *(_OWORD *)(v85 + 264) = 0u;
            *(_OWORD *)(v85 + 280) = 0u;
            *(_OWORD *)(v85 + 296) = 0u;
            *(_OWORD *)(v85 + 312) = 0u;
            *(_OWORD *)(v85 + 328) = 0u;
            *(_OWORD *)(v85 + 344) = 0u;
            *(_OWORD *)(v85 + 360) = 0u;
            *(_OWORD *)(v85 + 376) = 0u;
            *(_OWORD *)(v85 + 392) = 0u;
            *(_OWORD *)(v85 + 408) = 0u;
            *((_OWORD *)v85 + 27) = xmmword_1B3C07C14;
            *((_OWORD *)v85 + 28) = *(_OWORD *)algn_1B3C07C24;
            *((_OWORD *)v85 + 29) = xmmword_1B3C07C34;
            *((_OWORD *)v85 + 30) = unk_1B3C07C44;
            *((_QWORD *)v85 + 62) = 0;
            *(_OWORD *)(v85 + 504) = xmmword_1B3C07C14;
            *(_OWORD *)(v85 + 520) = *(_OWORD *)algn_1B3C07C24;
            *(_OWORD *)(v85 + 536) = xmmword_1B3C07C34;
            *(_OWORD *)(v85 + 552) = unk_1B3C07C44;
            *(_OWORD *)(v85 + 568) = xmmword_1B3C07C14;
            *(_OWORD *)(v85 + 584) = *(_OWORD *)algn_1B3C07C24;
            *(_OWORD *)(v85 + 600) = xmmword_1B3C07C34;
            *(_OWORD *)(v85 + 616) = unk_1B3C07C44;
            *(_OWORD *)(v85 + 632) = 0u;
            *((_DWORD *)v85 + 162) = 1065353216;
            *((_DWORD *)v85 + 169) = 0;
            *(_QWORD *)(v85 + 668) = 0;
            *(_OWORD *)(v85 + 652) = 0u;
            *(_QWORD *)&v104 = v85 + 24;
            *((_QWORD *)&v104 + 1) = v85;
            std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::operator=[abi:ne180100](v5, &v104);
            v86 = (std::__shared_weak_count *)*((_QWORD *)&v104 + 1);
            if (*((_QWORD *)&v104 + 1))
            {
              v87 = (unint64_t *)(*((_QWORD *)&v104 + 1) + 8);
              do
                v88 = __ldaxr(v87);
              while (__stlxr(v88 - 1, v87));
              if (!v88)
              {
                ((void (*)(std::__shared_weak_count *))v86->__on_zero_shared)(v86);
                std::__shared_weak_count::__release_weak(v86);
              }
            }
            goto LABEL_35;
          }
          v89 = vabds_f32(v80, *(float *)(v6 + 624)) / fminf(v80, *(float *)(v6 + 624));
          *(float *)(v6 + 624) = v80;
          if (v89 >= *(float *)(v25 + 24))
          {
            *(_QWORD *)(v6 + 616) = 0;
          }
          else
          {
            v90 = *(_QWORD *)(v6 + 616);
            v93 = __CFADD__(v90, 1);
            v91 = v90 + 1;
            *(_QWORD *)(v6 + 616) = v91;
            if (!v93)
            {
              v92 = *(_QWORD *)(v25 + 16);
              v93 = v91 >= v92;
              if (v91 >= v92)
                v94 = 0;
              else
                v94 = 9;
              *(_QWORD *)v3 = v94 | ((unint64_t)LODWORD(v80) << 32);
              v3[1] = *((float *)&v79 + 1);
              if (v93)
              {
                v95 = *(_QWORD *)v5;
                *(float *)v95 = v80;
                *(_BYTE *)(v95 + 5) = 1;
              }
              goto LABEL_35;
            }
          }
          v83 = 10;
        }
        else
        {
          v83 = 3;
          v80 = v81;
        }
      }
      else
      {
        v83 = 7;
      }
      *(_QWORD *)v3 = v83 | ((unint64_t)LODWORD(v80) << 32);
      v3[1] = *((float *)&v79 + 1);
LABEL_35:
      v6 = *(_QWORD *)v5;
      return *(float *)v6;
    }
    *(_BYTE *)(v77 + 4) = 1;
    v39 = 7;
LABEL_34:
    *(_QWORD *)v3 = v39;
    goto LABEL_35;
  }
  *(_QWORD *)a3 = 6;
  return *(float *)v6;
}

uint64_t arkit::btr::ScaleCorrection::GetDbgData(arkit::btr::ScaleCorrection *this)
{
  return *((_QWORD *)this + 7) + 632;
}

double cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>(uint64_t *a1, uint64_t **a2)
{
  uint64_t v3;
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double result;
  float *v11;
  float v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;
  __int128 v29;
  __int128 v30;

  v3 = **a2;
  if ((uint64_t *)(v3 - 4 * *((unsigned int *)*a2 + 3)) == a1 || (v4 = a2[1], v4 == a1))
  {
    v29 = 0u;
    v30 = 0u;
    v27 = 0u;
    v28 = 0u;
    v25 = 0u;
    v26 = 0u;
    v23 = 0u;
    v24 = 0u;
    v21 = 0u;
    v22 = 0u;
    v19 = 0u;
    v20 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,16u,false>,cva::MatrixRef<float,3u,3u,false>,cva::Matrix<float,3u,16u,false>>(&v19);
    v13 = v28;
    *((_OWORD *)a1 + 8) = v27;
    *((_OWORD *)a1 + 9) = v13;
    v14 = v30;
    *((_OWORD *)a1 + 10) = v29;
    *((_OWORD *)a1 + 11) = v14;
    v15 = v24;
    *((_OWORD *)a1 + 4) = v23;
    *((_OWORD *)a1 + 5) = v15;
    v16 = v26;
    *((_OWORD *)a1 + 6) = v25;
    *((_OWORD *)a1 + 7) = v16;
    v17 = v20;
    *(_OWORD *)a1 = v19;
    *((_OWORD *)a1 + 1) = v17;
    result = *(double *)&v21;
    v18 = v22;
    *((_OWORD *)a1 + 2) = v21;
    *((_OWORD *)a1 + 3) = v18;
  }
  else
  {
    v5 = 0;
    v6 = *((unsigned int *)*a2 + 2);
    do
    {
      v7 = 0;
      v8 = v3;
      do
      {
        if ((_DWORD)v6)
        {
          v9 = 0;
          LODWORD(result) = 0;
          v11 = (float *)v4 + 3 * v5;
          do
          {
            v12 = *v11++;
            *(float *)&result = *(float *)&result + (float)(*(float *)(v8 + v9) * v12);
            v9 += 4 * v6;
          }
          while (4 * (3 * v6) != v9);
        }
        else
        {
          LODWORD(result) = 0;
        }
        *((_DWORD *)a1 + 3 * v5 + v7++) = LODWORD(result);
        v8 += 4;
      }
      while (v7 != 3);
      ++v5;
    }
    while (v5 != 16);
  }
  return result;
}

float *cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(float *result, uint64_t a2)
{
  float *v2;
  uint64_t v3;
  float v4;
  float32x4_t v5;
  int v6;

  v2 = result;
  if (*(float **)a2 == result)
  {
    v6 = 0;
    result = (float *)cva::assign<false,false,cva::Matrix<float,1u,1u,false>,cva::Matrix<float,1u,16u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,1u,16u,false>>>(&v6);
    *(_DWORD *)v2 = v6;
  }
  else
  {
    v3 = 0;
    v4 = 0.0;
    do
    {
      v5 = vmulq_f32(*(float32x4_t *)(*(_QWORD *)a2 + v3), *(float32x4_t *)(**(_QWORD **)(a2 + 8) + v3));
      v4 = (float)((float)((float)(v4 + v5.f32[0]) + v5.f32[1]) + v5.f32[2]) + v5.f32[3];
      v3 += 16;
    }
    while (v3 != 64);
    *result = v4;
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(uint64_t result, float **a2)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float v8;
  float *v9;
  float v10;
  uint64_t v11;
  int v12;

  v2 = result;
  v3 = *(_QWORD *)*a2;
  if (v3 - 4 * *((unsigned int *)*a2 + 3) == result || (v4 = a2[1], v4 == (float *)result))
  {
    v12 = 0;
    v11 = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixRef<float const,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(&v11);
    *(_QWORD *)v2 = v11;
    *(_DWORD *)(v2 + 8) = v12;
  }
  else
  {
    v5 = 0;
    v6 = *((unsigned int *)*a2 + 2);
    do
    {
      if ((_DWORD)v6)
      {
        v7 = 0;
        v8 = 0.0;
        v9 = v4;
        do
        {
          v10 = *v9++;
          v8 = v8 + (float)(*(float *)(v3 + v7) * v10);
          v7 += 4 * v6;
        }
        while (4 * (3 * v6) != v7);
      }
      else
      {
        v8 = 0.0;
      }
      *(float *)(result + 4 * v5++) = v8;
      v3 += 4;
    }
    while (v5 != 3);
  }
  return result;
}

uint64_t cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>(uint64_t result, uint64_t **a2)
{
  _DWORD *v2;
  uint64_t *v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  _DWORD *v7;
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  _DWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  int v16;
  _DWORD *v17;
  unint64_t v18;
  int *v19;
  int v20;
  unint64_t v21;
  BOOL v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  _OWORD v26[2];
  int v27;

  v2 = *(_DWORD **)result;
  v3 = *a2;
  v4 = **a2;
  if (v4 - 4 * *((unsigned int *)*a2 + 3) == *(_QWORD *)result - 4 * *(unsigned int *)(result + 12))
  {
    v14 = 0;
    v15 = 0;
    v27 = 0;
    memset(v26, 0, sizeof(v26));
    do
    {
      if (v15 > 2 || HIDWORD(v15) >= 3)
        cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
      *(_DWORD *)((char *)v26 + v14) = *(_DWORD *)(v4 + 4 * (HIDWORD(v15) + *((_DWORD *)v3 + 2) * v15));
      if (v15 >= 2)
        v15 = (v15 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v15 = (v15 + 1) | v15 & 0xFFFFFFFF00000000;
      v14 += 4;
    }
    while (v14 != 36);
    v16 = *(_DWORD *)(result + 8);
    if (v16)
    {
      v17 = &v2[3 * v16];
      v18 = (unint64_t)(v16 - 3) << 32;
      v19 = (int *)v26;
      do
      {
        v20 = *v19++;
        *v2 = v20;
        v21 = HIDWORD(v18);
        v22 = (int)v18 < 2;
        if ((int)v18 < 2)
          v21 = 0;
        v23 = &v2[v21];
        v24 = (v18 + 1);
        v25 = v18 & 0xFFFFFFFF00000000;
        if (!v22)
          v24 = 0;
        v18 = v24 | v25;
        v2 = v23 + 1;
      }
      while (v2 != v17);
    }
  }
  else
  {
    v5 = *(_DWORD *)(result + 8);
    if (v5)
    {
      v6 = 0;
      v7 = &v2[3 * v5];
      v8 = (unint64_t)(v5 - 3) << 32;
      do
      {
        if (v6 > 2 || HIDWORD(v6) >= 3)
          cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>();
        *v2 = *(_DWORD *)(v4 + 4 * (HIDWORD(v6) + *((_DWORD *)v3 + 2) * v6));
        if (v6 >= 2)
          v6 = (v6 & 0xFFFFFFFF00000000) + 0x100000000;
        else
          v6 = (v6 + 1) | v6 & 0xFFFFFFFF00000000;
        v9 = HIDWORD(v8);
        v10 = (int)v8 < 2;
        if ((int)v8 < 2)
          v9 = 0;
        v11 = &v2[v9];
        v12 = (v8 + 1);
        v13 = v8 & 0xFFFFFFFF00000000;
        if (!v10)
          v12 = 0;
        v8 = v12 | v13;
        v2 = v11 + 1;
      }
      while (v2 != v7);
    }
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t v5;
  float ***v6;
  float **v7;
  float *v8;
  unint64_t v9;
  unint64_t v10;
  BOOL v11;
  float *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  _OWORD *v16;
  uint64_t v17;
  float v18;
  float *v19;
  float v20;
  _OWORD v21[2];
  int v22;

  v2 = result;
  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(float **)v3;
  if (*(_QWORD *)v3 - 4 * *(unsigned int *)(v3 + 12) == result)
  {
    DWORD2(v21[0]) = 0;
    *(_QWORD *)&v21[0] = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixUnaryExpr<cva::MatrixRef<float,3u,3u,false>,cva::detail::NegOp>,cva::MatrixRef<float const,3u,1u,false>>(v21);
    *(_QWORD *)v2 = *(_QWORD *)&v21[0];
    *(_DWORD *)(v2 + 8) = DWORD2(v21[0]);
  }
  else
  {
    v5 = 0;
    v6 = *(float ****)a2;
    memset(v21, 0, sizeof(v21));
    v22 = 0;
    v7 = *v6;
    v8 = **v6;
    v9 = (unint64_t)(*((_DWORD *)v7 + 2) - 3) << 32;
    do
    {
      *(float *)((char *)v21 + v5) = -*v8;
      v10 = HIDWORD(v9);
      v11 = (int)v9 < 2;
      if ((int)v9 < 2)
        v10 = 0;
      v12 = &v8[v10];
      v13 = (v9 + 1);
      v14 = v9 & 0xFFFFFFFF00000000;
      v8 = v12 + 1;
      if (!v11)
        v13 = 0;
      v9 = v13 | v14;
      v5 += 4;
    }
    while (v5 != 36);
    v15 = 0;
    v16 = v21;
    do
    {
      v17 = 0;
      v18 = 0.0;
      v19 = v4;
      do
      {
        v20 = *v19++;
        v18 = v18 + (float)(*(float *)((char *)v16 + v17) * v20);
        v17 += 12;
      }
      while (v17 != 36);
      *(float *)(result + 4 * v15++) = v18;
      v16 = (_OWORD *)((char *)v16 + 4);
    }
    while (v15 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(float32x4_t *a1, float32x4_t **a2)
{
  float32x4_t *v3;
  float32x4_t *v4;
  uint64_t i;
  uint64_t v6;
  float32x4_t v7;
  float32x4_t *v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v13;
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;

  v3 = *a2;
  if (*a2 == a1 || (v4 = a2[1], v4 == a1))
  {
    v15 = 0u;
    v16 = 0u;
    v13 = 0u;
    v14 = 0u;
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v13);
    v10 = v14;
    *a1 = v13;
    a1[1] = v10;
    v7.i64[0] = v15.i64[0];
    v11 = v16;
    a1[2] = v15;
    a1[3] = v11;
  }
  else
  {
    for (i = 0; i != 4; ++i)
    {
      v6 = 0;
      v7 = 0uLL;
      v8 = v3;
      do
      {
        v9 = *v8++;
        v7 = vmlaq_n_f32(v7, v9, v4->f32[v6++]);
      }
      while (v6 != 4);
      a1[i] = v7;
      ++v4;
    }
  }
  return *(double *)v7.i64;
}

double _ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrection4ImplENS_9allocatorIS4_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<D0>(_QWORD *a1@<X8>)
{
  char *v2;
  double result;

  v2 = (char *)operator new(0x2A8uLL);
  result = 0.0;
  *(_OWORD *)(v2 + 8) = 0u;
  *(_QWORD *)v2 = &unk_1E66705A8;
  *(_OWORD *)(v2 + 24) = 0u;
  *((_DWORD *)v2 + 6) = 1065353216;
  v2[32] = 1;
  *(_OWORD *)(v2 + 40) = 0u;
  *(_OWORD *)(v2 + 56) = 0u;
  *(_OWORD *)(v2 + 72) = 0u;
  *(_OWORD *)(v2 + 88) = 0u;
  *(_OWORD *)(v2 + 104) = 0u;
  *(_OWORD *)(v2 + 120) = 0u;
  *(_OWORD *)(v2 + 136) = 0u;
  *(_OWORD *)(v2 + 152) = 0u;
  *(_OWORD *)(v2 + 168) = 0u;
  *(_OWORD *)(v2 + 184) = 0u;
  *(_OWORD *)(v2 + 200) = 0u;
  *(_OWORD *)(v2 + 216) = 0u;
  *(_OWORD *)(v2 + 232) = 0u;
  *(_OWORD *)(v2 + 248) = 0u;
  *((_QWORD *)v2 + 53) = 0;
  *(_OWORD *)(v2 + 264) = 0u;
  *(_OWORD *)(v2 + 280) = 0u;
  *(_OWORD *)(v2 + 296) = 0u;
  *(_OWORD *)(v2 + 312) = 0u;
  *(_OWORD *)(v2 + 328) = 0u;
  *(_OWORD *)(v2 + 344) = 0u;
  *(_OWORD *)(v2 + 360) = 0u;
  *(_OWORD *)(v2 + 376) = 0u;
  *(_OWORD *)(v2 + 392) = 0u;
  *(_OWORD *)(v2 + 408) = 0u;
  *((_OWORD *)v2 + 27) = xmmword_1B3C07C14;
  *((_OWORD *)v2 + 28) = *(_OWORD *)algn_1B3C07C24;
  *((_OWORD *)v2 + 29) = xmmword_1B3C07C34;
  *((_OWORD *)v2 + 30) = unk_1B3C07C44;
  *((_QWORD *)v2 + 62) = 0;
  *(_OWORD *)(v2 + 504) = xmmword_1B3C07C14;
  *(_OWORD *)(v2 + 520) = *(_OWORD *)algn_1B3C07C24;
  *(_OWORD *)(v2 + 536) = xmmword_1B3C07C34;
  *(_OWORD *)(v2 + 552) = unk_1B3C07C44;
  *(_OWORD *)(v2 + 568) = xmmword_1B3C07C14;
  *(_OWORD *)(v2 + 584) = *(_OWORD *)algn_1B3C07C24;
  *(_OWORD *)(v2 + 600) = xmmword_1B3C07C34;
  *(_OWORD *)(v2 + 616) = unk_1B3C07C44;
  *(_OWORD *)(v2 + 632) = 0u;
  *((_DWORD *)v2 + 162) = 1065353216;
  *((_DWORD *)v2 + 169) = 0;
  *(_QWORD *)(v2 + 668) = 0;
  *(_OWORD *)(v2 + 652) = 0u;
  *a1 = v2 + 24;
  a1[1] = v2;
  return result;
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66705A8;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66705A8;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection::Impl>::__on_zero_shared(uint64_t a1)
{
  void *v2;

  v2 = *(void **)(a1 + 656);
  if (v2)
  {
    *(_QWORD *)(a1 + 664) = v2;
    operator delete(v2);
  }
}

void sub_1B3AFD1CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AFD340(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

id _ARLogGeneral_17()
{
  if (_ARLogGeneral_onceToken_20 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_20, &__block_literal_global_47);
  return (id)_ARLogGeneral_logObj_20;
}

void sub_1B3AFD46C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AFD4E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AFD568(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AFD640(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3AFD6D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3AFD768(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3AFD8C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3AFD94C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3AFDA68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

double ARConsensusAndAverageFilterImpl::Update(ARConsensusAndAverageFilterImpl *this, const simd_double4x4 *a2, const simd_double4x4 *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, __int128 a9, __int128 a10, __int128 a11, __int128 a12, uint64_t a13, __n128 a14, uint64_t a15, uint64_t a16, char a17, __int128 __src, __int128 a19, __int128 a20,__int128 a21,__int128 a22,__int128 a23,__int128 a24,__int128 a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,simd_double4x4 a48)
{
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  char **v54;
  __int128 v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  unint64_t v59;
  unint64_t v60;
  char *v61;
  unint64_t v62;
  unint64_t v63;
  uint64_t v64;
  unint64_t v65;
  char *v66;
  char *v67;
  char *v68;
  char *v69;
  char *v70;
  double result;
  __int128 v72;
  __int128 v73;
  _OWORD v74[2];
  __int128 v75;
  __int128 vars0;

  v52 = *((_QWORD *)this + 34);
  v51 = *((_QWORD *)this + 35);
  if (0x8E38E38E38E38E39 * ((v51 - v52) >> 5) == *((_DWORD *)this + 76))
  {
    v53 = v51 - (v52 + 288);
    if (v51 != v52 + 288)
      memmove(*((void **)this + 34), (const void *)(v52 + 288), v51 - (v52 + 288));
    *((_QWORD *)this + 35) = v52 + v53;
  }
  v54 = (char **)((char *)this + 272);
  *(_OWORD *)&STACK[0x5C0] = 0u;
  *(_OWORD *)&STACK[0x5D0] = 0u;
  *(_OWORD *)&STACK[0x5A0] = 0u;
  *(_OWORD *)&STACK[0x5B0] = 0u;
  *(_OWORD *)&STACK[0x580] = 0u;
  *(_OWORD *)&STACK[0x590] = 0u;
  *(_OWORD *)&STACK[0x560] = 0u;
  *(_OWORD *)&STACK[0x570] = 0u;
  v55 = *(_OWORD *)&a2->columns[2].f64[2];
  a22 = *(_OWORD *)a2->columns[2].f64;
  a23 = v55;
  v56 = *(_OWORD *)&a2->columns[3].f64[2];
  a24 = *(_OWORD *)a2->columns[3].f64;
  a25 = v56;
  v57 = *(_OWORD *)&a2->columns[0].f64[2];
  __src = *(_OWORD *)a2->columns[0].f64;
  a19 = v57;
  v58 = *(_OWORD *)&a2->columns[1].f64[2];
  a20 = *(_OWORD *)a2->columns[1].f64;
  a21 = v58;
  __invert_d4();
  *(_OWORD *)&STACK[0x540] = 0u;
  *(_OWORD *)&STACK[0x550] = 0u;
  memset(&a48, 0, 96);
  ConvertIMU((float64x2_t *)&STACK[0x560], (uint64_t)&a48);
  ARConsensusAndAverageFilterImpl::ConvertToENU((float64x2_t *)this, &a48, a3, (uint64_t)&__src);
  v60 = *((_QWORD *)this + 35);
  v59 = *((_QWORD *)this + 36);
  if (v60 >= v59)
  {
    v62 = 0x8E38E38E38E38E39 * ((uint64_t)(v60 - (_QWORD)*v54) >> 5);
    if (v62 + 1 > 0xE38E38E38E38E3)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v63 = 0x8E38E38E38E38E39 * ((uint64_t)(v59 - (_QWORD)*v54) >> 5);
    v64 = 2 * v63;
    if (2 * v63 <= v62 + 1)
      v64 = v62 + 1;
    if (v63 >= 0x71C71C71C71C71)
      v65 = 0xE38E38E38E38E3;
    else
      v65 = v64;
    if (v65)
      v66 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>((uint64_t)this + 288, v65);
    else
      v66 = 0;
    v67 = &v66[288 * v62];
    v68 = &v66[288 * v65];
    memcpy(v67, &__src, 0x120uLL);
    v61 = v67 + 288;
    v70 = (char *)*((_QWORD *)this + 34);
    v69 = (char *)*((_QWORD *)this + 35);
    if (v69 != v70)
    {
      do
      {
        v69 -= 288;
        v67 -= 288;
        memcpy(v67, v69, 0x120uLL);
      }
      while (v69 != v70);
      v69 = *v54;
    }
    *((_QWORD *)this + 34) = v67;
    *((_QWORD *)this + 35) = v61;
    *((_QWORD *)this + 36) = v68;
    if (v69)
      operator delete(v69);
  }
  else
  {
    memcpy(*((void **)this + 35), &__src, 0x120uLL);
    v61 = (char *)(v60 + 288);
  }
  *((_QWORD *)this + 35) = v61;
  ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensusAndAverage((uint64_t)this, (uint64_t *)this + 34, 954437177 * ((unint64_t)&v61[-*((_QWORD *)this + 34)] >> 5) - 1, (uint64_t)this + 296, (uint64_t)&a14);
  if (a17)
  {
    MatrixFromTransform4Dof(&a14, (uint64_t)v74);
    *((_OWORD *)this + 4) = a9;
    *((_OWORD *)this + 5) = a10;
    *((_OWORD *)this + 6) = a11;
    *((_OWORD *)this + 7) = a12;
    v72 = v74[1];
    *(_OWORD *)this = v74[0];
    *((_OWORD *)this + 1) = v72;
    result = *(double *)&v75;
    v73 = vars0;
    *((_OWORD *)this + 2) = v75;
    *((_OWORD *)this + 3) = v73;
    *((_BYTE *)this + 128) = 1;
  }
  return result;
}

void ARConsensusAndAverageFilterImpl::ConvertToENU(float64x2_t *this@<X0>, const simd_double4x4 *a2@<X1>, const simd_double4x4 *a3@<X2>, uint64_t a4@<X8>)
{
  uint64_t v7;
  int64x2_t v8;
  int64x2_t *v9;
  _OWORD *v10;
  uint64_t v11;
  int64x2_t v12;
  int64x2_t *v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  uint64_t v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  float64x2_t v27;
  float64x2_t v28;
  __int128 v29;
  __int128 v30;
  float64x2_t v31;
  float64x2_t v32;
  float64x2_t v33;
  float64x2_t v34;
  float64x2_t v35;
  float64x2_t v36;
  float64x2_t v37;
  float64x2_t v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t *v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  _OWORD v46[8];
  __int128 v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  __int128 v52;
  __int128 v53;
  __int128 v54;

  v7 = 0;
  *(_QWORD *)(a4 + 128) = 0x7FF8000000000000;
  *(_BYTE *)(a4 + 136) = 0;
  v8 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    v9 = (int64x2_t *)(a4 + v7);
    *v9 = v8;
    v9[1] = v8;
    v7 += 32;
  }
  while (v7 != 128);
  v10 = (_OWORD *)(a4 + 144);
  *(_QWORD *)(a4 + 272) = 0x7FF8000000000000;
  *(_BYTE *)(a4 + 280) = 0;
  v11 = 144;
  v12 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    v13 = (int64x2_t *)(a4 + v11);
    *v13 = v12;
    v13[1] = v12;
    v11 += 32;
  }
  while (v11 != 272);
  v14 = *(_OWORD *)&a2->columns[2].f64[2];
  *(_OWORD *)(a4 + 64) = *(_OWORD *)a2->columns[2].f64;
  *(_OWORD *)(a4 + 80) = v14;
  v15 = *(_OWORD *)&a2->columns[3].f64[2];
  *(_OWORD *)(a4 + 96) = *(_OWORD *)a2->columns[3].f64;
  *(_OWORD *)(a4 + 112) = v15;
  v16 = *(_OWORD *)&a2->columns[0].f64[2];
  *(_OWORD *)a4 = *(_OWORD *)a2->columns[0].f64;
  *(_OWORD *)(a4 + 16) = v16;
  v17 = *(_OWORD *)&a2->columns[1].f64[2];
  *(_OWORD *)(a4 + 32) = *(_OWORD *)a2->columns[1].f64;
  *(_OWORD *)(a4 + 48) = v17;
  *(_QWORD *)(a4 + 128) = 0;
  *(_BYTE *)(a4 + 136) = 1;
  *(double *)(a4 + 128) = HeadingFromRot(a4);
  v18 = 0;
  v19 = *(_OWORD *)&a3->columns[3].f64[2];
  *(_OWORD *)(a4 + 240) = *(_OWORD *)a3->columns[3].f64;
  *(_OWORD *)(a4 + 256) = v19;
  v20 = *(_OWORD *)&a3->columns[2].f64[2];
  *(_OWORD *)(a4 + 208) = *(_OWORD *)a3->columns[2].f64;
  *(_OWORD *)(a4 + 224) = v20;
  v21 = *(_OWORD *)&a3->columns[1].f64[2];
  *(_OWORD *)(a4 + 176) = *(_OWORD *)a3->columns[1].f64;
  *(_OWORD *)(a4 + 192) = v21;
  v22 = *(_OWORD *)&a3->columns[0].f64[2];
  *v10 = *(_OWORD *)a3->columns[0].f64;
  *(_OWORD *)(a4 + 160) = v22;
  *(_QWORD *)(a4 + 272) = 0;
  v23 = vnegq_f64(*(float64x2_t *)(a4 + 224));
  v24 = vnegq_f64(*(float64x2_t *)(a4 + 208));
  v25 = vnegq_f64(*(float64x2_t *)(a4 + 192));
  v26 = vnegq_f64(*(float64x2_t *)(a4 + 176));
  v27 = vnegq_f64(*(float64x2_t *)(a4 + 160));
  v28 = vnegq_f64(*(float64x2_t *)(a4 + 144));
  v30 = *(_OWORD *)(a4 + 240);
  v29 = *(_OWORD *)(a4 + 256);
  v53 = 0u;
  v54 = 0u;
  v51 = 0u;
  v52 = 0u;
  v49 = 0u;
  v50 = 0u;
  v47 = 0u;
  v48 = 0u;
  v32 = this[9];
  v31 = this[10];
  v34 = this[11];
  v33 = this[12];
  v36 = this[13];
  v35 = this[14];
  v38 = this[15];
  v37 = this[16];
  v46[0] = v24;
  v46[1] = v23;
  v46[2] = v26;
  v46[3] = v25;
  v46[4] = v28;
  v46[5] = v27;
  v46[6] = v30;
  v46[7] = v29;
  do
  {
    v40 = (float64x2_t)v46[v18];
    v39 = (float64x2_t)v46[v18 + 1];
    v41 = (float64x2_t *)((char *)&v47 + v18 * 16);
    *v41 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v32, v40.f64[0]), v34, v40, 1), v36, v39.f64[0]), v38, v39, 1);
    v41[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v31, v40.f64[0]), v33, v40, 1), v35, v39.f64[0]), v37, v39, 1);
    v18 += 2;
  }
  while (v18 != 8);
  v42 = v52;
  *(_OWORD *)(a4 + 208) = v51;
  *(_OWORD *)(a4 + 224) = v42;
  v43 = v54;
  *(_OWORD *)(a4 + 240) = v53;
  *(_OWORD *)(a4 + 256) = v43;
  v44 = v48;
  *v10 = v47;
  *(_OWORD *)(a4 + 160) = v44;
  v45 = v50;
  *(_OWORD *)(a4 + 176) = v49;
  *(_OWORD *)(a4 + 192) = v45;
  *(_BYTE *)(a4 + 280) = 1;
  *(double *)(a4 + 272) = HeadingFromRot(a4 + 144);
}

void ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensusAndAverage(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int v9;
  unsigned int *v10;
  double *v11;
  double *v12;
  double v13;
  double v14;
  double v15;
  double *v16;
  double v17;
  double v18;
  __double2 v19;
  __int128 v20;
  double v21;
  float64x2_t v22;
  double v23;
  __int128 v24;
  __int128 v25;
  float64x2_t v26;
  __int128 v27;
  char v28[96];
  float64x2_t v29;
  double v30;
  float64x2_t __dst[18];
  __int128 v32;
  uint64_t v33;
  double v34;
  uint64_t v35;
  char *v36;
  double *v37;
  unsigned int *v38;
  unsigned int *v39;
  uint64_t v40;
  __int128 v41;
  __int128 v42;
  uint64_t v43;

  v9 = *(_DWORD *)(a4 + 8);
  ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensus(a1, a2, a3, a4, (uint64_t)&v41);
  if (!(_BYTE)v43)
  {
    v24 = v42;
    *(_OWORD *)a5 = v41;
    *(_OWORD *)(a5 + 16) = v24;
    *(_QWORD *)(a5 + 32) = v43;
    return;
  }
  v38 = 0;
  v39 = 0;
  v40 = 0;
  ARConsensusAndAverageFilterImpl::GetInliers(a1, a2, a3, (uint64_t)&v41, v9, (uint64_t)&v38);
  v10 = v39;
  if (v39 == v38)
  {
    v25 = v42;
    *(_OWORD *)a5 = v41;
    *(_OWORD *)(a5 + 16) = v25;
    *(_QWORD *)(a5 + 32) = v43;
    if (v10)
    {
LABEL_19:
      v39 = v10;
      operator delete(v10);
    }
  }
  else
  {
    ARConsensusAndAverageFilterImpl::RetrieveInliers(a2, &v38, &v36);
    v11 = (double *)v36;
    v12 = v37;
    v13 = 0.0;
    v14 = 0.0;
    v15 = 0.0;
    if (v36 != (char *)v37)
    {
      v16 = (double *)v36;
      do
      {
        v17 = v16[16] - v16[34];
        v18 = v17 + ceil(v17 / -360.0) * 360.0;
        if (v18 > 180.0)
          v18 = v18 + -360.0;
        v19 = __sincos_stret(v18 * 3.14159265 / 180.0);
        v13 = v13 + v19.__sinval;
        v14 = v14 + v19.__cosval;
        v15 = v15 + 1.0;
        v16 += 36;
      }
      while (v16 != v12);
    }
    v21 = atan2(v13 / v15, v14 / v15) * 0.318309886 * 180.0;
    v22 = 0uLL;
    v35 = 1;
    v32 = 0u;
    v33 = 0;
    v34 = v21;
    v23 = 0.0;
    if (v11 == v12)
    {
      *(_QWORD *)&v20 = 0;
    }
    else
    {
      *(_QWORD *)&v20 = 0;
      do
      {
        v26 = v22;
        v27 = v20;
        memcpy(__dst, v11, sizeof(__dst));
        ARConsensusAndAverageFilterImpl::ApplyTransform((uint64_t)__dst, (uint64_t)&v32, (uint64_t)v28);
        v22 = vaddq_f64(v26, vsubq_f64(__dst[15], v29));
        v23 = v23 + __dst[16].f64[0] - v30;
        *((_QWORD *)&v20 + 1) = *((_QWORD *)&v27 + 1);
        *(double *)&v20 = *(double *)&v27 + 1.0;
        v11 += 36;
      }
      while (v11 != v12);
      v11 = (double *)v36;
    }
    *(float64x2_t *)a5 = vdivq_f64(v22, (float64x2_t)vdupq_lane_s64(v20, 0));
    *(double *)(a5 + 16) = v23 / *(double *)&v20;
    *(double *)(a5 + 24) = v21;
    *(_BYTE *)(a5 + 32) = 1;
    if (v11)
    {
      v37 = v11;
      operator delete(v11);
    }
    v10 = v38;
    if (v38)
      goto LABEL_19;
  }
}

void sub_1B3AFE210(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 - 192);
  if (v3)
  {
    *(_QWORD *)(v1 - 184) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xE38E38E38E38E4)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(288 * a2);
}

void ARConsensusAndAverageFilterImpl::GetAlignmentAtFrameConsensus(uint64_t a1@<X0>, uint64_t *a2@<X1>, unsigned int a3@<W2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  int v7;
  double v8;
  int v11;
  uint64_t v12;
  uint64_t v13;
  double v14;
  double *v15;
  BOOL v16;
  double v17;
  float64x2_t v18;
  __double2 v19;
  float64x2_t v20;
  double Inliers;
  __int128 v23;
  float64x2_t v24;
  __int128 v25;
  char v26;
  float64x2_t v27;
  __int128 v28;
  uint64_t v29;

  v7 = *(_DWORD *)(a4 + 8);
  v8 = *(double *)a4;
  LOBYTE(v29) = 0;
  v27 = 0u;
  v28 = 0u;
  if ((a3 & 0x80000000) != 0)
  {
    v14 = 0.0;
  }
  else
  {
    v11 = 0;
    v12 = a3;
    v13 = 288 * a3 + 280;
    v14 = 0.0;
    do
    {
      v15 = (double *)(*a2 + v13);
      if (*((_BYTE *)v15 - 144))
        v16 = *(_BYTE *)v15 == 0;
      else
        v16 = 1;
      if (!v16)
      {
        v17 = *(v15 - 19) - *(v15 - 1);
        *((double *)&v25 + 1) = v17 + ceil(v17 / -360.0) * 360.0;
        v19 = __sincos_stret(*((double *)&v25 + 1) * 3.14159265 / 180.0);
        v18.f64[0] = v19.__cosval;
        v20.f64[0] = -v19.__sinval;
        v20.f64[1] = v19.__cosval;
        v18.f64[1] = v19.__sinval;
        v24 = vsubq_f64(*(float64x2_t *)(v15 - 5), vmlaq_n_f64(vmulq_laneq_f64(v20, *(float64x2_t *)(v15 - 23), 1), v18, *(v15 - 23)));
        *(double *)&v25 = *(v15 - 3) - *(v15 - 21);
        v26 = 1;
        Inliers = ARConsensusAndAverageFilterImpl::GetInliers(a1, a2, a3, (uint64_t)&v24, v7, 0);
        if (Inliers > v14)
        {
          v27 = v24;
          v28 = v25;
          LOBYTE(v29) = v26;
          v14 = Inliers;
        }
        ++v11;
      }
      if (v11 > v7)
        break;
      v13 -= 288;
    }
    while (v12-- > 0);
  }
  *(double *)(a1 + 312) = v14;
  if (v14 >= v8)
  {
    v23 = v28;
    *(float64x2_t *)a5 = v27;
    *(_OWORD *)(a5 + 16) = v23;
    *(_QWORD *)(a5 + 32) = v29;
  }
  else
  {
    *(_BYTE *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
}

double ARConsensusAndAverageFilterImpl::GetInliers(uint64_t a1, uint64_t *a2, unsigned int a3, uint64_t a4, int a5, uint64_t a6)
{
  int v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  double *v17;
  float v18;
  float v19;
  double v20;
  BOOL v21;
  unint64_t v22;
  _DWORD *v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  int v32;
  uint64_t v34;
  double v35;
  double v36;
  double v37;

  if (0x8E38E38E38E38E39 * ((a2[1] - *a2) >> 5) <= a3)
    ARConsensusAndAverageFilterImpl::GetInliers();
  if ((a3 & 0x80000000) == 0)
  {
    v10 = 0;
    v11 = a3;
    v12 = a6 + 16;
    v13 = 0.0;
    while (1)
    {
      v14 = *a2;
      v15 = *a2 + 288 * v11;
      if (*(_BYTE *)(v15 + 136))
        v16 = *(_BYTE *)(v15 + 280) == 0;
      else
        v16 = 1;
      if (!v16)
      {
        ARConsensusAndAverageFilterImpl::ApplyTransform(v15, a4, (uint64_t)&v34);
        v17 = (double *)(v14 + 288 * v11);
        v18 = (v17[31] - v36) * (v17[31] - v36) + (v17[30] - v35) * (v17[30] - v35);
        v19 = sqrtf(v18);
        v20 = v17[34] - v37 + ceil((v17[34] - v37) / -360.0) * 360.0;
        if (v20 > 180.0)
          v20 = v20 + -360.0;
        v21 = fabs(v20) <= 10.0 && v19 <= 10.0;
        if (v21)
        {
          if (a6)
          {
            v23 = *(_DWORD **)(a6 + 8);
            v22 = *(_QWORD *)(a6 + 16);
            if ((unint64_t)v23 >= v22)
            {
              v25 = *(_DWORD **)a6;
              v26 = ((uint64_t)v23 - *(_QWORD *)a6) >> 2;
              v27 = v26 + 1;
              if ((unint64_t)(v26 + 1) >> 62)
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              v28 = v22 - (_QWORD)v25;
              if (v28 >> 1 > v27)
                v27 = v28 >> 1;
              if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
                v29 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v29 = v27;
              if (v29)
              {
                v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v12, v29);
                v25 = *(_DWORD **)a6;
                v23 = *(_DWORD **)(a6 + 8);
              }
              else
              {
                v30 = 0;
              }
              v31 = &v30[4 * v26];
              *(_DWORD *)v31 = v11;
              v24 = v31 + 4;
              while (v23 != v25)
              {
                v32 = *--v23;
                *((_DWORD *)v31 - 1) = v32;
                v31 -= 4;
              }
              *(_QWORD *)a6 = v31;
              *(_QWORD *)(a6 + 8) = v24;
              *(_QWORD *)(a6 + 16) = &v30[4 * v29];
              if (v25)
                operator delete(v25);
            }
            else
            {
              *v23 = v11;
              v24 = v23 + 1;
            }
            *(_QWORD *)(a6 + 8) = v24;
          }
          v13 = v13 + 1.0;
          if (v10 >= a5)
            return v13;
        }
        ++v10;
      }
      v21 = v11-- <= 0;
      if (v21)
        return v13;
    }
  }
  return 0.0;
}

__n128 ARConsensusAndAverageFilterImpl::RetrieveInliers@<Q0>(_QWORD *a1@<X1>, unsigned int **a2@<X2>, _QWORD *a3@<X8>)
{
  uint64_t *v5;
  __n128 result;
  unsigned int *v7;
  unsigned int *v8;
  unsigned int v9;
  uint64_t v10;
  unsigned int v11;
  _OWORD *v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  uint64_t v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;

  v5 = std::vector<std::pair<Pos4Dof,Pos4Dof>>::vector(a3, a2[1] - *a2);
  v7 = *a2;
  v8 = a2[1];
  if (*a2 != v8)
  {
    v9 = 0;
    v10 = *v5;
    do
    {
      v11 = *v7++;
      v12 = (_OWORD *)(*a1 + 288 * v11);
      v13 = v10 + 288 * v9;
      v14 = v12[4];
      v16 = v12[1];
      v15 = v12[2];
      *(_OWORD *)(v13 + 48) = v12[3];
      *(_OWORD *)(v13 + 64) = v14;
      *(_OWORD *)(v13 + 16) = v16;
      *(_OWORD *)(v13 + 32) = v15;
      v18 = v12[6];
      v17 = v12[7];
      v19 = v12[5];
      *(_OWORD *)(v13 + 121) = *(_OWORD *)((char *)v12 + 121);
      *(_OWORD *)(v13 + 96) = v18;
      *(_OWORD *)(v13 + 112) = v17;
      *(_OWORD *)(v13 + 80) = v19;
      *(_OWORD *)v13 = *v12;
      v20 = *a1 + 288 * v11;
      *(_OWORD *)(v13 + 144) = *(_OWORD *)(v20 + 144);
      v21 = *(_OWORD *)(v20 + 160);
      v22 = *(_OWORD *)(v20 + 176);
      v23 = *(_OWORD *)(v20 + 208);
      *(_OWORD *)(v13 + 192) = *(_OWORD *)(v20 + 192);
      *(_OWORD *)(v13 + 208) = v23;
      *(_OWORD *)(v13 + 160) = v21;
      *(_OWORD *)(v13 + 176) = v22;
      result = *(__n128 *)(v20 + 224);
      v24 = *(_OWORD *)(v20 + 240);
      v25 = *(_OWORD *)(v20 + 256);
      *(_OWORD *)(v13 + 265) = *(_OWORD *)(v20 + 265);
      *(_OWORD *)(v13 + 240) = v24;
      *(_OWORD *)(v13 + 256) = v25;
      *(__n128 *)(v13 + 224) = result;
      ++v9;
    }
    while (v7 != v8);
  }
  return result;
}

void ARConsensusAndAverageFilterImpl::ApplyTransform(uint64_t a1@<X1>, uint64_t a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v6;
  int64x2_t v7;
  int64x2_t *v8;
  double v9;
  __double2 v10;
  uint64_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t *v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  float64x2_t v28;
  float64x2_t v29;
  float64x2_t v30;
  float64x2_t v31;
  _OWORD v32[8];
  _OWORD v33[8];

  v6 = 0;
  *(_QWORD *)(a3 + 128) = 0x7FF8000000000000;
  *(_BYTE *)(a3 + 136) = 0;
  v7 = vdupq_n_s64(0x7FF8000000000000uLL);
  do
  {
    v8 = (int64x2_t *)(a3 + v6);
    *v8 = v7;
    v8[1] = v7;
    v6 += 32;
  }
  while (v6 != 128);
  if (*(_BYTE *)(a2 + 32))
  {
    v9 = *(double *)(a2 + 24);
    v30 = *(float64x2_t *)(MEMORY[0x1E0C83FD8] + 80);
    v31 = *(float64x2_t *)(MEMORY[0x1E0C83FD8] + 16);
    v28 = *(float64x2_t *)(MEMORY[0x1E0C83FD8] + 64);
    v29 = *(float64x2_t *)(MEMORY[0x1E0C83FD8] + 48);
    v27 = *(_OWORD *)(MEMORY[0x1E0C83FD8] + 112);
    v10 = __sincos_stret(v9 * 3.14159265 / 180.0);
    v13.f64[0] = v10.__cosval;
    v15.f64[1] = *((float64_t *)&v27 + 1);
    v11 = 0;
    v12.f64[0] = -v10.__sinval;
    v12.f64[1] = v10.__cosval;
    v13.f64[1] = v10.__sinval;
    v14 = *(float64x2_t *)a2;
    v15.f64[0] = *(float64_t *)(a2 + 16);
    v16 = *(_OWORD *)(a1 + 80);
    v32[4] = *(_OWORD *)(a1 + 64);
    v32[5] = v16;
    v17 = *(_OWORD *)(a1 + 112);
    v32[6] = *(_OWORD *)(a1 + 96);
    v32[7] = v17;
    v18 = *(_OWORD *)(a1 + 16);
    v32[0] = *(_OWORD *)a1;
    v32[1] = v18;
    v19 = *(_OWORD *)(a1 + 48);
    v32[2] = *(_OWORD *)(a1 + 32);
    v32[3] = v19;
    do
    {
      v21 = (float64x2_t)v32[v11];
      v20 = (float64x2_t)v32[v11 + 1];
      v22 = (float64x2_t *)&v33[v11];
      *v22 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v13, v21.f64[0]), v12, v21, 1), v28, v20.f64[0]), v14, v20, 1);
      v22[1] = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(v31, v21.f64[0]), v29, v21, 1), v30, v20.f64[0]), v15, v20, 1);
      v11 += 2;
    }
    while (v11 != 8);
    v23 = v33[5];
    *(_OWORD *)(a3 + 64) = v33[4];
    *(_OWORD *)(a3 + 80) = v23;
    v24 = v33[7];
    *(_OWORD *)(a3 + 96) = v33[6];
    *(_OWORD *)(a3 + 112) = v24;
    v25 = v33[1];
    *(_OWORD *)a3 = v33[0];
    *(_OWORD *)(a3 + 16) = v25;
    v26 = v33[3];
    *(_OWORD *)(a3 + 32) = v33[2];
    *(_OWORD *)(a3 + 48) = v26;
    *(double *)(a3 + 128) = *(double *)(a1 + 128) - v9;
    *(_BYTE *)(a3 + 136) = 1;
  }
}

_QWORD *std::vector<std::pair<Pos4Dof,Pos4Dof>>::vector(_QWORD *a1, unint64_t a2)
{
  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::pair<Pos4Dof,Pos4Dof>>::__vallocate[abi:ne180100](a1, a2);
    std::vector<std::pair<Pos4Dof,Pos4Dof>>::__construct_at_end((uint64_t)a1, a2);
  }
  return a1;
}

void sub_1B3AFE924(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<std::pair<Pos4Dof,Pos4Dof>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xE38E38E38E38E4)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<AlignedPose>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[288 * v4];
  return result;
}

uint64_t std::vector<std::pair<Pos4Dof,Pos4Dof>>::__construct_at_end(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  int64x2_t v4;
  uint64_t v5;
  int64x2_t *v6;
  uint64_t i;
  int64x2_t *v8;

  v2 = *(_QWORD *)(result + 8);
  if (a2)
  {
    v3 = v2 + 288 * a2;
    v4 = vdupq_n_s64(0x7FF8000000000000uLL);
    do
    {
      v5 = 0;
      *(_QWORD *)(v2 + 128) = 0x7FF8000000000000;
      *(_BYTE *)(v2 + 136) = 0;
      do
      {
        v6 = (int64x2_t *)(v2 + v5);
        *v6 = v4;
        v6[1] = v4;
        v5 += 32;
      }
      while (v5 != 128);
      *(_QWORD *)(v2 + 272) = 0x7FF8000000000000;
      *(_BYTE *)(v2 + 280) = 0;
      for (i = 144; i != 272; i += 32)
      {
        v8 = (int64x2_t *)(v2 + i);
        *v8 = v4;
        v8[1] = v4;
      }
      v2 += 288;
    }
    while (v2 != v3);
    v2 = v3;
  }
  *(_QWORD *)(result + 8) = v2;
  return result;
}

id _ARLogGeneral_18()
{
  if (_ARLogGeneral_onceToken_21 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_21, &__block_literal_global_48);
  return (id)_ARLogGeneral_logObj_21;
}

void sub_1B3AFFE74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::resize(unint64_t *a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  size_t v4;

  v2 = a1[1] - *a1;
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<unsigned char>::__append(a1, v4);
  }
  else if (!v3)
  {
    a1[1] = *a1 + a2;
  }
}

void _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 4 * a2;
  }
  else
  {
    _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE6resizeEm(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE8__appendEm((void **)a1, a2 - v2);
  }
}

void sub_1B3B000C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B001DC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B00800(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, void *a17, void *a18, void *a19)
{
  void *v19;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_7()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void std::vector<unsigned char>::__append(unint64_t *a1, size_t a2)
{
  char *v4;
  char *v5;
  unint64_t v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  size_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  char v15;

  v5 = (char *)a1[1];
  v4 = (char *)a1[2];
  if (v4 - v5 >= a2)
  {
    if (a2)
    {
      bzero((void *)a1[1], a2);
      v5 += a2;
    }
    a1[1] = (unint64_t)v5;
  }
  else
  {
    v6 = *a1;
    v7 = &v5[-*a1];
    v8 = (unint64_t)&v7[a2];
    if ((uint64_t)&v7[a2] < 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v9 = (unint64_t)&v4[-v6];
    if (2 * v9 > v8)
      v8 = 2 * v9;
    if (v9 >= 0x3FFFFFFFFFFFFFFFLL)
      v10 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v10 = v8;
    if (v10)
      v11 = (unint64_t)operator new(v10);
    else
      v11 = 0;
    v12 = &v7[v11];
    v13 = (char *)(v11 + v10);
    bzero(v12, a2);
    if (v5 == (char *)v6)
    {
      v11 = (unint64_t)v12;
    }
    else
    {
      v14 = &v5[~v6];
      do
      {
        v15 = *--v5;
        (v14--)[v11] = v15;
      }
      while (v5 != (char *)v6);
      v5 = (char *)*a1;
    }
    *a1 = v11;
    a1[1] = (unint64_t)&v12[a2];
    a1[2] = (unint64_t)v13;
    if (v5)
      operator delete(v5);
  }
}

void _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  int v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 2)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 4 * a2);
      v7 += 4 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 2);
    if (v9 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 1 > v9)
      v9 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[4 * v10];
    v15 = &v13[4 * v12];
    bzero(v14, 4 * a2);
    v16 = &v14[4 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_DWORD *)v17 - 1);
        v17 -= 4;
        *((_DWORD *)v14 - 1) = v19;
        v14 -= 4;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE8__appendEm(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  __int128 v27;
  char *v28;
  uint64_t v29;
  char *v30;
  __int128 v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 4)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 4);
    if (v14 >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 4;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 3 > v14)
      v14 = v16 >> 3;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
      v17 = 0xFFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v9, v17);
    else
      v18 = 0;
    v28 = &v18[16 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[16 * v17];
    v29 = 16 * a5;
    v30 = &v28[16 * a5];
    do
    {
      v31 = *(_OWORD *)v7;
      v7 += 16;
      *(_OWORD *)v28 = v31;
      v28 += 16;
      v29 -= 16;
    }
    while (v29);
    v35 = v30;
    v5 = _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 15) & 0xFFFFFFFFFFFFFFF0;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 4;
  if (v20 >= a5)
  {
    v21 = &__src[16 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[16 * a5];
    v25 = &v23[-16 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_OWORD *)v25;
        v25 += 16;
        *(_OWORD *)v26 = v27;
        v26 += 16;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-16 * ((v23 - v24) >> 4)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[16 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[16 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_1B3B0102C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  __int128 v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_OWORD *)v8 - 1);
      v8 -= 16;
      *((_OWORD *)v7 - 1) = v9;
      v7 -= 16;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

char *std::vector<unsigned char>::__insert_with_size[abi:ne180100]<std::__wrap_iter<unsigned char *>,std::__wrap_iter<unsigned char *>>(uint64_t a1, char *__dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  uint64_t v6;
  char *v7;
  uint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  char *v13;
  unint64_t v14;
  size_t v15;
  void *v16;
  uint64_t v17;
  char *v18;
  int64_t v19;
  char *v20;
  char *v21;
  char *v22;
  char *v23;
  int64_t v24;
  char v25;
  char *v26;
  char *v27;
  char *v28;
  char v29;
  char *v30;
  char *v31;
  char *v32;
  char v33;
  char *v34;
  char *v35;

  v5 = __dst;
  if (a5 < 1)
    return v5;
  v6 = a5;
  v7 = __src;
  v10 = *(char **)(a1 + 8);
  v9 = *(_QWORD *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    v11 = *(char **)a1;
    v12 = (uint64_t)&v10[a5 - *(_QWORD *)a1];
    if (v12 < 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v13 = (char *)(__dst - v11);
    v14 = v9 - (_QWORD)v11;
    if (2 * v14 > v12)
      v12 = 2 * v14;
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL)
      v15 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v15 = v12;
    if (v15)
      v16 = operator new(v15);
    else
      v16 = 0;
    v26 = &v13[(_QWORD)v16];
    v27 = &v13[(_QWORD)v16 + v6];
    v28 = v26;
    do
    {
      v29 = *v7++;
      *v28++ = v29;
      --v6;
    }
    while (v6);
    v30 = *(char **)a1;
    if (*(char **)a1 == v5)
    {
      v32 = v26;
    }
    else
    {
      v31 = v5;
      v32 = v26;
      do
      {
        v33 = *--v31;
        *--v32 = v33;
      }
      while (v31 != v30);
      v10 = *(char **)(a1 + 8);
    }
    v34 = (char *)v16 + v15;
    if (v10 != v5)
      memmove(v27, v5, v10 - v5);
    v35 = *(char **)a1;
    *(_QWORD *)a1 = v32;
    *(_QWORD *)(a1 + 8) = &v27[v10 - v5];
    *(_QWORD *)(a1 + 16) = v34;
    if (v35)
      operator delete(v35);
    return v26;
  }
  v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    v18 = &__src[a5];
    v20 = *(char **)(a1 + 8);
LABEL_17:
    v21 = &v5[v6];
    v22 = &v20[-v6];
    v23 = v20;
    if (&v20[-v6] < v10)
    {
      v24 = &v10[v6] - v20;
      v23 = v20;
      do
      {
        v25 = *v22++;
        *v23++ = v25;
        --v24;
      }
      while (v24);
    }
    *(_QWORD *)(a1 + 8) = v23;
    if (v20 != v21)
      memmove(&v5[v6], v5, v20 - v21);
    if (v18 != v7)
      memmove(v5, v7, v18 - v7);
    return v5;
  }
  v18 = &__src[v17];
  v19 = a4 - &__src[v17];
  if (a4 != &__src[v17])
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  v20 = &v10[v19];
  *(_QWORD *)(a1 + 8) = &v10[v19];
  if (v17 >= 1)
    goto LABEL_17;
  return v5;
}

char *_ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  int v27;
  char *v28;
  uint64_t v29;
  char *v30;
  int v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 2)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 2);
    if (v14 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 2;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 1 > v14)
      v14 = v16 >> 1;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFFCLL)
      v17 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[4 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[4 * v17];
    v29 = 4 * a5;
    v30 = &v28[4 * a5];
    do
    {
      v31 = *(_DWORD *)v7;
      v7 += 4;
      *(_DWORD *)v28 = v31;
      v28 += 4;
      v29 -= 4;
    }
    while (v29);
    v35 = v30;
    v5 = _ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 3) & 0xFFFFFFFFFFFFFFFCLL;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 2;
  if (v20 >= a5)
  {
    v21 = &__src[4 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[4 * a5];
    v25 = &v23[-4 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_DWORD *)v25;
        v25 += 4;
        *(_DWORD *)v26 = v27;
        v26 += 4;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-4 * ((v23 - v24) >> 2)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[4 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[4 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_1B3B014D8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv4_hNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_DWORD *)v8 - 1);
      v8 -= 4;
      *((_DWORD *)v7 - 1) = v9;
      v7 -= 4;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

char *_ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE18__insert_with_sizeB8ne180100INS_11__wrap_iterIPS1_EES8_EES8_NS6_IPKS1_EET_T0_l(uint64_t a1, uint64_t __dst, char *__src, char *a4, uint64_t a5)
{
  char *v5;
  char *v7;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  int64_t v22;
  char *v23;
  char *v24;
  char *v25;
  char *v26;
  uint64_t v27;
  char *v28;
  uint64_t v29;
  char *v30;
  uint64_t v31;
  void *__p;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v5 = (char *)__dst;
  if (a5 < 1)
    return v5;
  v7 = __src;
  v11 = *(_QWORD *)(a1 + 16);
  v9 = a1 + 16;
  v10 = v11;
  v12 = *(_QWORD *)(v9 - 8);
  if (a5 > (uint64_t)(v11 - v12) >> 3)
  {
    v13 = *(void **)a1;
    v14 = a5 + ((uint64_t)(v12 - *(_QWORD *)a1) >> 3);
    if (v14 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v15 = (__dst - (uint64_t)v13) >> 3;
    v16 = v10 - (_QWORD)v13;
    if (v16 >> 2 > v14)
      v14 = v16 >> 2;
    if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF8)
      v17 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v17 = v14;
    v37 = v9;
    if (v17)
      v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v9, v17);
    else
      v18 = 0;
    v28 = &v18[8 * v15];
    __p = v18;
    v34 = v28;
    v36 = &v18[8 * v17];
    v29 = 8 * a5;
    v30 = &v28[8 * a5];
    do
    {
      v31 = *(_QWORD *)v7;
      v7 += 8;
      *(_QWORD *)v28 = v31;
      v28 += 8;
      v29 -= 8;
    }
    while (v29);
    v35 = v30;
    v5 = _ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_((void **)a1, (uint64_t)&__p, v5);
    if (v35 != v34)
      v35 += (v34 - v35 + 7) & 0xFFFFFFFFFFFFFFF8;
    if (__p)
      operator delete(__p);
    return v5;
  }
  v19 = v12 - __dst;
  v20 = (uint64_t)(v12 - __dst) >> 3;
  if (v20 >= a5)
  {
    v21 = &__src[8 * a5];
    v23 = *(char **)(v9 - 8);
LABEL_17:
    v24 = &v5[8 * a5];
    v25 = &v23[-8 * a5];
    v26 = v23;
    if ((unint64_t)v25 < v12)
    {
      v26 = v23;
      do
      {
        v27 = *(_QWORD *)v25;
        v25 += 8;
        *(_QWORD *)v26 = v27;
        v26 += 8;
      }
      while ((unint64_t)v25 < v12);
    }
    *(_QWORD *)(a1 + 8) = v26;
    if (v23 != v24)
      memmove(&v23[-8 * ((v23 - v24) >> 3)], v5, v23 - v24);
    if (v21 != v7)
      memmove(v5, v7, v21 - v7);
    return v5;
  }
  v21 = &__src[8 * v20];
  v22 = a4 - v21;
  if (a4 != v21)
    memmove(*(void **)(v9 - 8), &__src[8 * v20], a4 - v21);
  v23 = (char *)(v12 + v22);
  *(_QWORD *)(a1 + 8) = v12 + v22;
  if (v19 >= 1)
    goto LABEL_17;
  return v5;
}

void sub_1B3B017A8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

char *_ZNSt3__16vectorIDv4_tNS_9allocatorIS1_EEE26__swap_out_circular_bufferERNS_14__split_bufferIS1_RS3_EEPS1_(void **a1, uint64_t a2, char *__src)
{
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  _BYTE *v10;
  uint64_t v11;
  int64_t v12;
  char *v13;
  void *v14;
  void *v15;

  v5 = *(char **)(a2 + 8);
  v6 = (char *)*a1;
  v7 = v5;
  if (*a1 != __src)
  {
    v8 = __src;
    v7 = *(char **)(a2 + 8);
    do
    {
      v9 = *((_QWORD *)v8 - 1);
      v8 -= 8;
      *((_QWORD *)v7 - 1) = v9;
      v7 -= 8;
    }
    while (v8 != v6);
  }
  *(_QWORD *)(a2 + 8) = v7;
  v10 = a1[1];
  v11 = *(_QWORD *)(a2 + 16);
  v12 = v10 - __src;
  if (v10 != __src)
  {
    memmove(*(void **)(a2 + 16), __src, v10 - __src);
    v7 = *(char **)(a2 + 8);
  }
  *(_QWORD *)(a2 + 16) = v11 + v12;
  v13 = (char *)*a1;
  *a1 = v7;
  *(_QWORD *)(a2 + 8) = v13;
  v14 = a1[1];
  a1[1] = *(void **)(a2 + 16);
  *(_QWORD *)(a2 + 16) = v14;
  v15 = a1[2];
  a1[2] = *(void **)(a2 + 24);
  *(_QWORD *)(a2 + 24) = v15;
  *(_QWORD *)a2 = *(_QWORD *)(a2 + 8);
  return v5;
}

id ARQATraceableDefaultEntryForResultData(void *a1)
{
  id v1;
  void *v2;
  objc_class *v3;
  void *v4;
  void *v5;
  void *v6;

  v1 = a1;
  v2 = (void *)objc_opt_new();
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v4, CFSTR("type"));

  v5 = (void *)MEMORY[0x1E0CB37E8];
  objc_msgSend(v1, "timestamp");
  objc_msgSend(v5, "numberWithDouble:");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "setObject:forKeyedSubscript:", v6, CFSTR("timestamp"));

  return v2;
}

void sub_1B3B01948(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

id ARQATraceableDefaultFormatForResultData()
{
  void *v0;

  v0 = (void *)objc_opt_new();
  objc_msgSend(v0, "setObject:forKeyedSubscript:", CFSTR("Name of this data type"), CFSTR("type"));
  objc_msgSend(v0, "setObject:forKeyedSubscript:", CFSTR("Timestamp in seconds"), CFSTR("timestamp"));
  return v0;
}

void sub_1B3B019D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B01A88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

id ARFloat(float a1)
{
  uint64_t v1;
  uint64_t v2;

  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v1, v2);
  return (id)objc_claimAutoreleasedReturnValue();
}

void sub_1B3B01BA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B01CBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B01F60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  _Unwind_Resume(a1);
}

void sub_1B3B021C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1B3B022C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B02364(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B024B4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B02C80(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3B02E38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3B02F24(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3B03150(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B03300(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B03748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1B3B03868(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B03970(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B03A5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B03BB0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B03E10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3B04A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{

  _Unwind_Resume(a1);
}

void sub_1B3B04F14(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B051F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, uint64_t a12, void *a13, void *a14)
{

  _Unwind_Resume(a1);
}

void sub_1B3B05310(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B06FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,void *a27)
{
  void *v27;
  void *v28;

  _Unwind_Resume(a1);
}

void sub_1B3B076F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B07788(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B07920(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3B08144(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B0831C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B08574(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B08634(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B08784(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B08AC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B08C04(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_8()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

id ARKitCoreBuildVersionString()
{
  void *v0;
  void *v1;
  void *v2;

  objc_msgSend(MEMORY[0x1E0CB34D0], "bundleForClass:", objc_opt_class());
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "infoDictionary");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("CFBundleVersion"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  return v2;
}

const __CFString *ARTrackingStateToString(unint64_t a1)
{
  if (a1 > 2)
    return CFSTR("Undefined");
  else
    return off_1E6674448[a1];
}

const __CFString *ARTrackingStateReasonToString(unint64_t a1)
{
  if (a1 > 4)
    return CFSTR("Undefined");
  else
    return off_1E6674460[a1];
}

void sub_1B3B09D84(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B09E8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15)
{
  uint64_t v15;
  void *v17;

  if (__p)
    operator delete(__p);
  v17 = *(void **)(v15 - 48);
  if (v17)
  {
    *(_QWORD *)(v15 - 40) = v17;
    operator delete(v17);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3B09F0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARUndistortionMapping;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B0A13C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12)
{
  void *v12;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1B3B0A1C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARImageDistortionCorrectionTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B0AF54(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,void *a37)
{
  void *v37;
  void *v38;

  _Unwind_Resume(a1);
}

void sub_1B3B0B334(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B0B5B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B0B6C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B0B854(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B0BB60(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B0BCB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<float>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<float>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 4 * a2);
    a1[1] = &v4[4 * a2];
  }
  return a1;
}

void sub_1B3B0BDC0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void ___ZL15_ARLogTechniquev_block_invoke_3()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

id _ARLogTechnique_6()
{
  if (_ARLogTechnique_onceToken_8 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_8, &__block_literal_global_52);
  return (id)_ARLogTechnique_logObj_8;
}

double ARMatrixFromCVAMatrix(uint64_t a1)
{
  return *(double *)a1;
}

__n128 ARMatrixFromCVAMatrix(uint64_t a1)
{
  return *(__n128 *)a1;
}

void ARCVAMatrixFromMatrix(simd_float4x4 a1@<0:Q0, 16:Q1, 32:Q2, 48:Q3>, simd_float4x4 *a2@<X8>)
{
  *a2 = a1;
}

__n128 ARCVAMatrixFromMatrix@<Q0>(simd_float3x3 a1@<0:Q0, 16:Q1, 32:Q2>, uint64_t a2@<X8>)
{
  a1.columns[0].i32[3] = a1.columns[1].i32[0];
  *(simd_float3 *)a2 = a1.columns[0];
  *(int8x16_t *)(a2 + 16) = vextq_s8(vextq_s8((int8x16_t)a1.columns[1], (int8x16_t)a1.columns[1], 0xCuLL), (int8x16_t)a1.columns[2], 8uLL);
  *(_DWORD *)(a2 + 32) = a1.columns[2].i32[2];
  return (__n128)a1.columns[0];
}

void sub_1B3B0D9F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B0DAFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARFaceTrackingManager;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B0E048(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,void *a35,uint64_t a36,char a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,id a42)
{
  void *v42;
  void *v43;

  _Block_object_dispose(&a37, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__2(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__2(uint64_t a1)
{

}

void sub_1B3B0E47C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B0E91C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _Unwind_Exception *exception_object, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_1B3B0EBE4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, uint64_t a11, void *a12)
{

  _Unwind_Resume(a1);
}

void sub_1B3B0EEC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1B3B0F010(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_9()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke_4()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

id _ARLogGeneral_19()
{
  if (_ARLogGeneral_onceToken_22 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_22, &__block_literal_global_120);
  return (id)_ARLogGeneral_logObj_22;
}

ARPlaneAnchor *ARCreatePlaneAnchorFromCV3DPlane(const CV3DPlaneDetectionPlane *a1, NSUUID *a2, simd_float4x4 a3, simd_float4x4 a4, char a5, int a6, __int16 a7)
{
  uint64_t v12;
  simd_float4 v13;
  simd_float4 v14;
  simd_float4 v15;
  simd_float4 v16;
  int v17;
  int Orientation;
  int v19;
  float v20;
  unsigned __int8 v22;
  uint64_t v23;
  float v24;
  uint64_t v25;
  float32x2_t v26;
  int32x2_t v27;
  float32x2_t v28;
  float v29;
  __float2 v30;
  float32x4_t v31;
  simd_float4 v32;
  uint64_t v33;
  simd_float4 v34;
  simd_float4 v35;
  simd_float4 v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  _BOOL8 v40;
  uint64_t v41;
  ARPlaneAnchor *v42;
  double v43;
  void *v44;
  unsigned int v45;
  double v46;
  double v47;
  void *v48;
  void *v49;
  double v51;
  double v52;
  float v53;
  __float2 v54;
  float32x4_t v55;
  simd_float4 v56;
  uint64_t v57;
  simd_float4 v58;
  simd_float4 v59;
  simd_float4 v60;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float v77;
  simd_float4x4 v78;
  simd_float4x4 v79;
  simd_float4x4 v80;
  simd_float4x4 v81;

  v66 = (float32x4_t)a4.columns[2];
  v69 = (float32x4_t)a4.columns[3];
  v72 = (float32x4_t)a4.columns[1];
  v75 = (float32x4_t)a4.columns[0];
  CV3DPlaneDetectionPlaneTransformationToWorld();
  v12 = 0;
  v78.columns[0] = v13;
  v78.columns[1] = v14;
  v78.columns[2] = v15;
  v78.columns[3] = v16;
  do
  {
    v79.columns[v12] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v75, COERCE_FLOAT(*(_OWORD *)&v78.columns[v12])), v72, *(float32x2_t *)v78.columns[v12].f32, 1), v66, (float32x4_t)v78.columns[v12], 2), v69, (float32x4_t)v78.columns[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  v70 = (float32x4_t)v79.columns[1];
  v73 = (float32x4_t)v79.columns[0];
  v65 = (float32x4_t)v79.columns[3];
  v67 = (float32x4_t)v79.columns[2];
  v17 = CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
  Orientation = CV3DPlaneDetectionPlaneGetOrientation();
  v19 = *MEMORY[0x1E0D84210];
  v20 = 0.0;
  if (Orientation == v19 && v17 != 0)
  {
    v79.columns[0] = v78.columns[0];
    v79.columns[1] = v78.columns[1];
    {
      pivotForOrientedBox(simd_float4x2)::k_cos45 = 1060439283;
    }
    v23 = 0;
    v24 = *(float *)&pivotForOrientedBox(simd_float4x2)::k_cos45;
    do
    {
      v25 = v23 + 1;
      v26 = vsub_f32(*(float32x2_t *)&v79.columns[0].f32[2 * v23], *(float32x2_t *)&v79.columns[0].f32[2 * ((v23 + 1) & 3)]);
      v27 = (int32x2_t)vmul_f32(v26, v26);
      *(float *)v27.i32 = sqrtf(vmlas_n_f32(*(float *)&v27.i32[1], v26.f32[0], v26.f32[0]));
      v28 = vdiv_f32(v26, (float32x2_t)vdup_lane_s32(v27, 0));
      if (v28.f32[0] >= v24)
      {
        v77 = v28.f32[1];
        v29 = acosf(fminf(fmaxf(v28.f32[0], -1.0), 1.0));
        if (v77 >= 0.0)
          v20 = v29;
        else
          v20 = -v29;
      }
      v23 = v25;
    }
    while (v25 != 4);
  }
  if (a6)
  {
    v30 = __sincosf_stret(v20 * 0.5);
    v31 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFF70, v30.__sinval);
    v31.i32[3] = LODWORD(v30.__cosval);
    *(double *)v32.i64 = simd_matrix4x4(v31);
    v33 = 0;
    v78.columns[0] = v32;
    v78.columns[1] = v34;
    v78.columns[2] = v35;
    v78.columns[3] = v36;
    do
    {
      v79.columns[v33] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v73, COERCE_FLOAT(*(_OWORD *)&v78.columns[v33])), v70, *(float32x2_t *)v78.columns[v33].f32, 1), v67, (float32x4_t)v78.columns[v33], 2), v65, (float32x4_t)v78.columns[v33], 3);
      ++v33;
    }
    while (v33 != 4);
    v70 = (float32x4_t)v79.columns[1];
    v73 = (float32x4_t)v79.columns[0];
    v65 = (float32x4_t)v79.columns[3];
    v67 = (float32x4_t)v79.columns[2];
  }
  v80 = __invert_f4(*(simd_float4x4 *)_PromotedConst_2);
  v37 = 0;
  v78 = v80;
  do
  {
    v79.columns[v37] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v73, COERCE_FLOAT(*(_OWORD *)&v78.columns[v37])), v70, *(float32x2_t *)v78.columns[v37].f32, 1), v67, (float32x4_t)v78.columns[v37], 2), v65, (float32x4_t)v78.columns[v37], 3);
    ++v37;
  }
  while (v37 != 4);
  v38 = 0;
  v62 = (__n128)v79.columns[1];
  v63 = (__n128)v79.columns[0];
  v78 = v79;
  v61 = (__n128)v79.columns[2];
  do
  {
    v79.columns[v38] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a3.columns[0], COERCE_FLOAT(*(_OWORD *)&v78.columns[v38])), (float32x4_t)a3.columns[1], *(float32x2_t *)v78.columns[v38].f32, 1), (float32x4_t)a3.columns[2], (float32x4_t)v78.columns[v38], 2), (float32x4_t)a3.columns[3], (float32x4_t)v78.columns[v38], 3);
    ++v38;
  }
  while (v38 != 4);
  v74 = (float32x4_t)v79.columns[1];
  v76 = (float32x4_t)v79.columns[0];
  v68 = (float32x4_t)v79.columns[3];
  v71 = (float32x4_t)v79.columns[2];
  v39 = CV3DPlaneDetectionPlaneGetOrientation();
  v40 = v39 != v19;
  if (v39 != v19 || (a7 & 0x100) != 0)
    goto LABEL_24;
  v81 = __invert_f4(a3);
  v51 = AREulerAnglesFromMatrix((__n128)v81.columns[0], (__n128)v81.columns[1], (__n128)v81.columns[2]);
  v52 = *((float *)&v51 + 1);
  if (v52 > 2.35619449)
    goto LABEL_29;
  if (v52 <= 0.785398163)
  {
    if (v52 < -2.35619449)
    {
LABEL_29:
      v41 = 180;
      goto LABEL_32;
    }
    if (v52 >= -0.785398163)
    {
LABEL_24:
      v41 = 0;
      goto LABEL_25;
    }
    v41 = -90;
  }
  else
  {
    v41 = 90;
  }
LABEL_32:
  v53 = (double)v41 * 3.14159265 / 180.0;
  v54 = __sincosf_stret(v53 * 0.5);
  v55 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v54.__sinval);
  v55.i32[3] = LODWORD(v54.__cosval);
  *(double *)v56.i64 = simd_matrix4x4(v55);
  v57 = 0;
  v78.columns[0] = v56;
  v78.columns[1] = v58;
  v78.columns[2] = v59;
  v78.columns[3] = v60;
  do
  {
    v79.columns[v57] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v76, COERCE_FLOAT(*(_OWORD *)&v78.columns[v57])), v74, *(float32x2_t *)v78.columns[v57].f32, 1), v71, (float32x4_t)v78.columns[v57], 2), v68, (float32x4_t)v78.columns[v57], 3);
    ++v57;
  }
  while (v57 != 4);
  v74.i64[0] = v79.columns[1].i64[0];
  v76.i64[0] = v79.columns[0].i64[0];
  v68.i64[0] = v79.columns[3].i64[0];
  v71.i64[0] = v79.columns[2].i64[0];
LABEL_25:
  v42 = -[ARPlaneAnchor initWithIdentifier:transform:alignment:]([ARPlaneAnchor alloc], "initWithIdentifier:transform:alignment:", a2, v40, *(double *)v76.i64, *(double *)v74.i64, *(double *)v71.i64, *(double *)v68.i64);
  -[ARPlaneAnchor setWorldAlignmentRotation:](v42, "setWorldAlignmentRotation:", v41);
  CV3DPlaneDetectionPlaneUncertaintyAlongNormal();
  *(float *)&v43 = v43;
  -[ARPlaneAnchor setUncertaintyAlongNormal:](v42, "setUncertaintyAlongNormal:", v43);
  _updateExtentsForPlaneAnchor(v42, a1, v20, a6, (a7 & 0x200) != 0);
  v44 = (void *)objc_opt_new();
  v45 = semanticsLabelForPlane((uint64_t)a1, v44);
  setSemanticsFromCV3D(v45, v44, a5, v42);
  if (-[ARPlaneAnchor alignment](v42, "alignment") == ARPlaneAnchorAlignmentHorizontal)
  {
    v47 = AREulerAnglesFromMatrix(v63, v62, v61);
    *(float *)&v47 = *((float *)&v47 + 1) * 0.318309886 * 180.0;
    v46 = *(float *)&v47;
  }
  -[NSUUID ar_integerValue](a2, "ar_integerValue", v46, *(_OWORD *)&v61, *(_OWORD *)&v62, *(_OWORD *)&v63);
  -[ARPlaneAnchor planeExtent](v42, "planeExtent");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v48, "width");
  -[ARPlaneAnchor planeExtent](v42, "planeExtent");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v49, "height");
  kdebug_trace();

  return v42;
}

void sub_1B3B10AA0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void _updateExtentsForPlaneAnchor(ARPlaneAnchor *a1, const CV3DPlaneDetectionPlane *a2, float a3, int a4, int a5)
{
  uint64_t v7;
  __float2 v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x2_t v13;
  uint64_t v14;
  float32x2_t v15;
  float32x2_t v16;
  float32x2_t v17;
  float32x4_t v18;
  float v19;
  __float2 v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  uint64_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  int8x16_t v31;
  uint64_t v32;
  float *v33;
  float v34;
  int8x16_t v35;
  float v36;
  float32x4_t v37;
  float32x2_t v38;
  void *v39;
  double v40;
  __float2 v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  void *v48;
  void *v49;
  void *v50;
  uint64_t v51;
  __float2 v52;
  float32x4_t v53;
  __int128 v54;
  uint64_t v55;
  __int128 v56;
  __int128 v57;
  __int128 v58;
  float v59;
  __float2 v60;
  float32x4_t v61;
  float32x4_t v62;
  float32x4_t v63;
  float32x4_t v64;
  float32x4_t v65;
  uint64_t v66;
  unint64_t VerticesCount;
  uint64_t VerticesRawPtr;
  uint64_t v69;
  uint64_t v70;
  float32x4_t *v71;
  float32x4_t v72;
  float32x4_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  char *v77;
  float32x4_t *v78;
  float32x4_t *v79;
  char *v80;
  float32x4_t v81;
  uint64_t FacesCount;
  uint64_t FacesRawPtr;
  uint64_t v84;
  uint64_t v85;
  _WORD *v86;
  int *v87;
  int v88;
  char *v89;
  char *v90;
  _WORD *v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  char *v96;
  char *v97;
  __int16 v98;
  int v99;
  char *v100;
  char *v101;
  uint64_t v102;
  uint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  char *v107;
  char *v108;
  __int16 v109;
  int v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  char *v117;
  char *v118;
  __int16 v119;
  uint64_t v120;
  unint64_t v121;
  uint64_t v122;
  float32x4_t *v123;
  float32x4_t v124;
  float32x4_t v125;
  uint64_t v126;
  unint64_t v127;
  unint64_t v128;
  char *v129;
  float32x4_t *v130;
  float32x4_t *v131;
  char *v132;
  float32x4_t v133;
  uint64_t v134;
  uint64_t v135;
  unint64_t v136;
  uint64_t i;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  uint64_t v141;
  float32x4_t *v142;
  float32x4_t v143;
  float32x4_t v144;
  uint64_t v145;
  unint64_t v146;
  unint64_t v147;
  char *v148;
  float32x4_t *v149;
  float32x4_t *v150;
  char *v151;
  float32x4_t v152;
  uint64_t v153;
  ARPlaneGeometry *v154;
  ARPlaneGeometry *v155;
  void *v156;
  uint64_t v157;
  unint64_t v158;
  uint64_t v159;
  float v160;
  __float2 v161;
  float32x4_t v162;
  float32x4_t v163;
  float32x4_t v164;
  float32x4_t v165;
  float32x4_t v166;
  uint64_t v167;
  uint64_t v168;
  float v169;
  uint64_t v170;
  float32x2_t *v171;
  float32x2_t *v172;
  float32x2_t v173;
  float32x4_t v174;
  int8x16_t v175;
  double v176;
  double v177;
  double v178;
  int32x2_t v179;
  uint64_t v180;
  char *v181;
  uint64_t v182;
  unint64_t v183;
  uint64_t v184;
  unint64_t v185;
  char *v186;
  double *v187;
  char *v188;
  char *v189;
  double *v190;
  ARPatchGrid *v191;
  double v192;
  ARPatchGrid *v193;
  __int128 v194;
  __int128 v195;
  __int128 v196;
  __int128 v197;
  __int128 v198;
  __int128 v199;
  __int128 v200;
  __int128 v201;
  float32x4_t v203;
  int8x16_t v204;
  ARPlaneAnchor *v205;
  float32x4_t v206;
  float32x4_t v207;
  float32x4_t v208;
  float32x4_t v209;
  float32x4_t v210;
  float32x4_t v211;
  float32x4_t v212;
  float32x4_t v213;
  float32x4_t v214;
  float32x4_t v215;
  float32x4_t v216;
  float32x4_t v217;
  void *__p[2];
  uint64_t v219;
  void *v220[2];
  uint64_t v221;
  __int128 v222;
  __int128 v223;
  __int128 v224;
  __int128 v225;
  __int128 v226;
  float32x4_t v227;
  float32x4_t v228;
  float32x4_t v229;

  v205 = a1;
  v7 = -[ARPlaneAnchor worldAlignmentRotation](v205, "worldAlignmentRotation");
  if (CV3DPlaneDetectionPlaneExtentOrientedBoundingBox()
    && CV3DPlaneDetectionPlaneGetOrientation() == *MEMORY[0x1E0D84210])
  {
    CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
    v8 = __sincosf_stret(a3 * -0.5);
    v9 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFF70, v8.__sinval);
    v9.i32[3] = LODWORD(v8.__cosval);
    *(double *)v10.i64 = simd_matrix4x4(v9);
    v14 = 0;
    v15 = (float32x2_t)vdup_n_s32(0x7F7FFFFFu);
    v16 = (float32x2_t)0x80000000800000;
    do
    {
      v17 = vadd_f32(v13, (float32x2_t)*(_OWORD *)&vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(v220[v14])), v11, (float32x2_t)v220[v14], 1), (float32x4_t)0, v12));
      v15 = vminnm_f32(v15, v17);
      v16 = vmaxnm_f32(v16, v17);
      ++v14;
    }
    while (v14 != 4);
    *(float32x2_t *)v11.f32 = vsub_f32(v16, v15);
    v11.i32[2] = v11.i32[1];
    v18 = 0uLL;
    v204 = vextq_s8((int8x16_t)vzip1q_s32((int32x4_t)v11, (int32x4_t)0), (int8x16_t)v11, 8uLL);
    if (v7)
    {
      v215 = v11;
      v19 = (double)-v7 * 3.14159265 / 180.0;
      v20 = __sincosf_stret(v19 * 0.5);
      v21 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v20.__sinval);
      v21.i32[3] = LODWORD(v20.__cosval);
      *(double *)v22.i64 = simd_matrix4x4(v21);
      v26 = 0;
      v222 = xmmword_1B3BDFDE0;
      v223 = xmmword_1B3BE00D0;
      v224 = xmmword_1B3BDFDD0;
      v225 = xmmword_1B3BDFD50;
      do
      {
        *(__int128 *)((char *)&v226 + v26) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v22, COERCE_FLOAT(*(__int128 *)((char *)&v222 + v26))), v23, *(float32x2_t *)((char *)&v222 + v26), 1), v24, *(float32x4_t *)((char *)&v222 + v26), 2), v25, *(float32x4_t *)((char *)&v222 + v26), 3);
        v26 += 16;
      }
      while (v26 != 64);
      v28 = (float32x4_t)v226;
      v27 = v227;
      v30 = v228;
      v29 = v229;
      if (v7 == 90 || v7 == -90)
      {
        v31 = (int8x16_t)v215;
        v31.i32[1] = 0;
        v204 = v31;
      }
      v18 = 0uLL;
    }
    else
    {
      v29 = (float32x4_t)xmmword_1B3BDFD50;
      v30 = (float32x4_t)xmmword_1B3BDFDD0;
      v27 = (float32x4_t)xmmword_1B3BE00D0;
      v28 = (float32x4_t)xmmword_1B3BDFDE0;
    }
    v38 = vadd_f32(v15, v16);
    v37 = vaddq_f32(v29, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v28, 0.5 * v38.f32[0]), v27, vmuls_lane_f32(0.5, v38, 1)), v18, v30));
  }
  else
  {
    CV3DPlaneDetectionPlaneExtentAlignedBoundingBox();
    v32 = CV3DPlaneDetectionAlignedBoundingBoxMin();
    v33 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMax();
    v34 = v33[1];
    v35.i32[0] = *(_DWORD *)(v32 + 4);
    v36 = (float)(v34 + *(float *)v35.i32) * 0.5;
    v35.i64[0] = v35.u32[0];
    v35.i32[3] = 0;
    *(float *)v35.i32 = v34 - *(float *)v35.i32;
    *(float *)&v35.i32[2] = *v33 - *(float *)v32;
    v204 = v35;
    v37 = vaddq_f32(vaddq_f32(vmlaq_n_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDE0, (float)(*v33 + *(float *)v32) * 0.5), (float32x4_t)xmmword_1B3BE00D0, v36), (float32x4_t)0), (float32x4_t)xmmword_1B3BDFD50);
  }
  v203 = vdivq_f32(v37, (float32x4_t)vdupq_laneq_s32((int32x4_t)v37, 3));
  if (a4)
  {
    -[ARPlaneAnchor setCenter:](v205, "setCenter:", *(double *)v203.i64);
    -[ARPlaneAnchor planeExtent](v205, "planeExtent");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    LODWORD(v40) = 0;
  }
  else
  {
    v41 = __sincosf_stret(a3 * 0.5);
    v42 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v41.__sinval);
    v42.i32[3] = LODWORD(v41.__cosval);
    *(double *)v43.i64 = simd_matrix4x4(v42);
    v47 = vaddq_f32(v46, vmlaq_laneq_f32(vmlaq_f32(vmulq_n_f32(v43, v203.f32[0]), (float32x4_t)0, v44), v45, v203, 2));
    -[ARPlaneAnchor setCenter:](v205, "setCenter:", COERCE_DOUBLE((unint64_t)vdivq_f32(v47, (float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 3)).u32[0]));
    -[ARPlaneAnchor planeExtent](v205, "planeExtent");
    v39 = (void *)objc_claimAutoreleasedReturnValue();
    *(float *)&v40 = a3;
  }
  objc_msgSend(v39, "setRotationOnYAxis:", v40);

  -[ARPlaneAnchor setExtent:](v205, "setExtent:", *(double *)v204.i64);
  -[ARPlaneAnchor planeExtent](v205, "planeExtent");
  v48 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v48, "setWidth:", *(double *)v204.i64);

  -[ARPlaneAnchor planeExtent](v205, "planeExtent");
  v49 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v49, "setHeight:", COERCE_DOUBLE(__PAIR64__(v204.u32[1], v204.u32[2])));

  if (!a4)
    a3 = 0.0;
  -[ARAnchor identifier](v205, "identifier");
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v50, "ar_integerValue");
  kdebug_trace();

  v51 = -[ARPlaneAnchor worldAlignmentRotation](v205, "worldAlignmentRotation");
  v52 = __sincosf_stret(a3 * -0.5);
  v53 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFF70, v52.__sinval);
  v53.i32[3] = LODWORD(v52.__cosval);
  *(double *)&v54 = simd_matrix4x4(v53);
  v55 = 0;
  v194 = v56;
  v196 = v54;
  v222 = v54;
  v223 = v56;
  v198 = v58;
  v200 = v57;
  v224 = v57;
  v225 = v58;
  do
  {
    *(__int128 *)((char *)&v226 + v55) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDE0, COERCE_FLOAT(*(__int128 *)((char *)&v222 + v55))), (float32x4_t)xmmword_1B3BE00D0, *(float32x2_t *)((char *)&v222 + v55), 1), (float32x4_t)xmmword_1B3BDFDD0, *(float32x4_t *)((char *)&v222 + v55), 2), (float32x4_t)xmmword_1B3BDFD50, *(float32x4_t *)((char *)&v222 + v55), 3);
    v55 += 16;
  }
  while (v55 != 64);
  v213 = v229;
  v216 = v228;
  v209 = v227;
  v211 = (float32x4_t)v226;
  if (v51)
  {
    v59 = (double)-v51 * 3.14159265 / 180.0;
    v60 = __sincosf_stret(v59 * 0.5);
    v61 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v60.__sinval);
    v61.i32[3] = LODWORD(v60.__cosval);
    *(double *)v62.i64 = simd_matrix4x4(v61);
    v66 = 0;
    v222 = (__int128)v211;
    v223 = (__int128)v209;
    v224 = (__int128)v216;
    v225 = (__int128)v213;
    do
    {
      *(__int128 *)((char *)&v226 + v66) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v62, COERCE_FLOAT(*(__int128 *)((char *)&v222 + v66))), v63, *(float32x2_t *)((char *)&v222 + v66), 1), v64, *(float32x4_t *)((char *)&v222 + v66), 2), v65, *(float32x4_t *)((char *)&v222 + v66), 3);
      v66 += 16;
    }
    while (v66 != 64);
    v209 = v227;
    v211 = (float32x4_t)v226;
    v213 = v229;
    v216 = v228;
  }
  v226 = 0uLL;
  v227.i64[0] = 0;
  v222 = 0uLL;
  *(_QWORD *)&v223 = 0;
  if (CV3DPlaneDetectionPlaneExtentPolygons())
  {
    if (CV3DPlaneDetectionPlaneCreateTriangulatedPolygons())
    {
      v220[0] = 0;
      VerticesCount = CV3DReconMeshGetVerticesCount();
      VerticesRawPtr = CV3DReconMeshGetVerticesRawPtr();
      if (VerticesCount - 1 <= 0xFFFE)
      {
        v69 = VerticesRawPtr;
        if (VerticesRawPtr)
        {
          _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, VerticesCount);
          v70 = 0;
          v71 = (float32x4_t *)*((_QWORD *)&v226 + 1);
          do
          {
            v72 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v69 + 12 * v70)), v209, *(float *)(v69 + 12 * v70 + 4)), (float32x4_t)0, v216));
            v73 = vdivq_f32(v72, (float32x4_t)vdupq_laneq_s32((int32x4_t)v72, 3));
            if ((unint64_t)v71 >= v227.i64[0])
            {
              v206 = v73;
              v74 = (uint64_t)((uint64_t)v71 - v226) >> 4;
              if ((unint64_t)(v74 + 1) >> 60)
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              v75 = (uint64_t)(v227.i64[0] - v226) >> 3;
              if (v75 <= v74 + 1)
                v75 = v74 + 1;
              if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL)
                v76 = 0xFFFFFFFFFFFFFFFLL;
              else
                v76 = v75;
              if (v76)
                v77 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v76);
              else
                v77 = 0;
              v78 = (float32x4_t *)&v77[16 * v74];
              *v78 = v206;
              v71 = v78 + 1;
              v79 = (float32x4_t *)*((_QWORD *)&v226 + 1);
              v80 = (char *)v226;
              if (*((_QWORD *)&v226 + 1) != (_QWORD)v226)
              {
                do
                {
                  v81 = v79[-1];
                  --v79;
                  v78[-1] = v81;
                  --v78;
                }
                while (v79 != (float32x4_t *)v80);
                v79 = (float32x4_t *)v226;
              }
              *(_QWORD *)&v226 = v78;
              *((_QWORD *)&v226 + 1) = v71;
              v227.i64[0] = (uint64_t)&v77[16 * v76];
              if (v79)
                operator delete(v79);
            }
            else
            {
              *v71++ = v73;
            }
            *((_QWORD *)&v226 + 1) = v71;
            ++v70;
          }
          while (v70 != VerticesCount);
        }
      }
      FacesCount = CV3DReconMeshGetFacesCount();
      FacesRawPtr = CV3DReconMeshGetFacesRawPtr();
      if (*((_QWORD *)&v226 + 1) - (_QWORD)v226 >= 0x21uLL)
      {
        if (FacesCount)
        {
          v84 = FacesRawPtr;
          if (FacesRawPtr)
          {
            std::vector<short>::reserve((void **)&v222, 3 * FacesCount);
            v85 = 0;
            v86 = (_WORD *)*((_QWORD *)&v222 + 1);
            do
            {
              v87 = (int *)(v84 + 12 * v85);
              v88 = *v87;
              v89 = (char *)v223;
              if ((unint64_t)v86 >= (unint64_t)v223)
              {
                v91 = (_WORD *)v222;
                v92 = (uint64_t)v86 - v222;
                if ((uint64_t)((uint64_t)v86 - v222) < -2)
                  goto LABEL_206;
                v93 = v92 >> 1;
                if ((_QWORD)v223 - (_QWORD)v222 <= (unint64_t)((v92 >> 1) + 1))
                  v94 = v93 + 1;
                else
                  v94 = v223 - v222;
                if ((_QWORD)v223 - (_QWORD)v222 >= 0x7FFFFFFFFFFFFFFEuLL)
                  v95 = 0x7FFFFFFFFFFFFFFFLL;
                else
                  v95 = v94;
                if (v95)
                {
                  v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v95);
                  v86 = (_WORD *)*((_QWORD *)&v222 + 1);
                  v91 = (_WORD *)v222;
                }
                else
                {
                  v96 = 0;
                }
                v97 = &v96[2 * v93];
                *(_WORD *)v97 = v88;
                v90 = v97 + 2;
                while (v86 != v91)
                {
                  v98 = *--v86;
                  *((_WORD *)v97 - 1) = v98;
                  v97 -= 2;
                }
                v89 = &v96[2 * v95];
                *(_QWORD *)&v222 = v97;
                *((_QWORD *)&v222 + 1) = v90;
                *(_QWORD *)&v223 = v89;
                if (v91)
                {
                  operator delete(v91);
                  v89 = (char *)v223;
                }
              }
              else
              {
                *v86 = v88;
                v90 = (char *)(v86 + 1);
              }
              *((_QWORD *)&v222 + 1) = v90;
              v99 = v87[1];
              if (v90 >= v89)
              {
                v101 = (char *)v222;
                v102 = (uint64_t)&v90[-v222];
                if ((uint64_t)&v90[-v222] < -2)
                  goto LABEL_206;
                v103 = v102 >> 1;
                v104 = (unint64_t)&v89[-v222];
                if (v104 <= (v102 >> 1) + 1)
                  v105 = v103 + 1;
                else
                  v105 = v104;
                if (v104 >= 0x7FFFFFFFFFFFFFFELL)
                  v106 = 0x7FFFFFFFFFFFFFFFLL;
                else
                  v106 = v105;
                if (v106)
                {
                  v107 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v106);
                  v90 = (char *)*((_QWORD *)&v222 + 1);
                  v101 = (char *)v222;
                }
                else
                {
                  v107 = 0;
                }
                v108 = &v107[2 * v103];
                *(_WORD *)v108 = v99;
                v100 = v108 + 2;
                while (v90 != v101)
                {
                  v109 = *((_WORD *)v90 - 1);
                  v90 -= 2;
                  *((_WORD *)v108 - 1) = v109;
                  v108 -= 2;
                }
                v89 = &v107[2 * v106];
                *(_QWORD *)&v222 = v108;
                *((_QWORD *)&v222 + 1) = v100;
                *(_QWORD *)&v223 = v89;
                if (v101)
                {
                  operator delete(v101);
                  v89 = (char *)v223;
                }
              }
              else
              {
                *(_WORD *)v90 = v99;
                v100 = v90 + 2;
              }
              *((_QWORD *)&v222 + 1) = v100;
              v110 = v87[2];
              if (v100 >= v89)
              {
                v111 = (char *)v222;
                v112 = (uint64_t)&v100[-v222];
                if ((uint64_t)&v100[-v222] <= -3)
LABEL_206:
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                v113 = v112 >> 1;
                v114 = (unint64_t)&v89[-v222];
                if (v114 <= (v112 >> 1) + 1)
                  v115 = v113 + 1;
                else
                  v115 = v114;
                if (v114 >= 0x7FFFFFFFFFFFFFFELL)
                  v116 = 0x7FFFFFFFFFFFFFFFLL;
                else
                  v116 = v115;
                if (v116)
                {
                  v117 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)&v223, v116);
                  v100 = (char *)*((_QWORD *)&v222 + 1);
                  v111 = (char *)v222;
                }
                else
                {
                  v117 = 0;
                }
                v118 = &v117[2 * v113];
                *(_WORD *)v118 = v110;
                v86 = v118 + 2;
                while (v100 != v111)
                {
                  v119 = *((_WORD *)v100 - 1);
                  v100 -= 2;
                  *((_WORD *)v118 - 1) = v119;
                  v118 -= 2;
                }
                *(_QWORD *)&v222 = v118;
                *((_QWORD *)&v222 + 1) = v86;
                *(_QWORD *)&v223 = &v117[2 * v116];
                if (v111)
                  operator delete(v111);
              }
              else
              {
                *(_WORD *)v100 = v110;
                v86 = v100 + 2;
              }
              *((_QWORD *)&v222 + 1) = v86;
              ++v85;
            }
            while (v85 != FacesCount);
          }
        }
      }
      CV3DReconMeshRelease();
    }
    else
    {
      v134 = CV3DPlaneDetectionPolygonListLength();
      if (v134)
      {
        v135 = 0;
        v136 = 0;
        do
        {
          CV3DPlaneDetectionPolygonAtIndex();
          v136 += CV3DPlaneDetectionPolygonPointsNum();
          ++v135;
        }
        while (v134 != v135);
      }
      else
      {
        v136 = 0;
      }
      _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, v136);
      if (v134)
      {
        for (i = 0; i != v134; ++i)
        {
          CV3DPlaneDetectionPolygonAtIndex();
          v138 = CV3DPlaneDetectionPolygonPointsNum();
          v139 = CV3DPlaneDetectionPolygonPointsRawPtr();
          if (v138)
          {
            v140 = v139;
            v141 = 0;
            v142 = (float32x4_t *)*((_QWORD *)&v226 + 1);
            do
            {
              v143 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v140 + 8 * v141)), v209, *(float *)(v140 + 8 * v141 + 4)), (float32x4_t)0, v216));
              v144 = vdivq_f32(v143, (float32x4_t)vdupq_laneq_s32((int32x4_t)v143, 3));
              if ((unint64_t)v142 >= v227.i64[0])
              {
                v208 = v144;
                v145 = (uint64_t)((uint64_t)v142 - v226) >> 4;
                if ((unint64_t)(v145 + 1) >> 60)
                  std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
                v146 = (uint64_t)(v227.i64[0] - v226) >> 3;
                if (v146 <= v145 + 1)
                  v146 = v145 + 1;
                if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL)
                  v147 = 0xFFFFFFFFFFFFFFFLL;
                else
                  v147 = v146;
                if (v147)
                  v148 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v147);
                else
                  v148 = 0;
                v149 = (float32x4_t *)&v148[16 * v145];
                *v149 = v208;
                v142 = v149 + 1;
                v150 = (float32x4_t *)*((_QWORD *)&v226 + 1);
                v151 = (char *)v226;
                if (*((_QWORD *)&v226 + 1) != (_QWORD)v226)
                {
                  do
                  {
                    v152 = v150[-1];
                    --v150;
                    v149[-1] = v152;
                    --v149;
                  }
                  while (v150 != (float32x4_t *)v151);
                  v150 = (float32x4_t *)v226;
                }
                *(_QWORD *)&v226 = v149;
                *((_QWORD *)&v226 + 1) = v142;
                v227.i64[0] = (uint64_t)&v148[16 * v147];
                if (v150)
                  operator delete(v150);
              }
              else
              {
                *v142++ = v144;
              }
              *((_QWORD *)&v226 + 1) = v142;
              ++v141;
            }
            while (v141 != v138);
          }
        }
      }
    }
  }
  else
  {
    if (!CV3DPlaneDetectionPlaneConvexHull2D())
    {
LABEL_154:
      v154 = 0;
      goto LABEL_161;
    }
    v120 = CV3DPlaneDetectionConvexHullPointsRawPtr();
    v121 = CV3DPlaneDetectionConvexHullPointsNum();
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE7reserveEm((void **)&v226, v121);
    if (v121)
    {
      v122 = 0;
      v123 = (float32x4_t *)*((_QWORD *)&v226 + 1);
      do
      {
        v124 = vaddq_f32(v213, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v211, *(float *)(v120 + 8 * v122)), v209, *(float *)(v120 + 8 * v122 + 4)), (float32x4_t)0, v216));
        v125 = vdivq_f32(v124, (float32x4_t)vdupq_laneq_s32((int32x4_t)v124, 3));
        if ((unint64_t)v123 >= v227.i64[0])
        {
          v207 = v125;
          v126 = (uint64_t)((uint64_t)v123 - v226) >> 4;
          if ((unint64_t)(v126 + 1) >> 60)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v127 = (uint64_t)(v227.i64[0] - v226) >> 3;
          if (v127 <= v126 + 1)
            v127 = v126 + 1;
          if (v227.i64[0] - (uint64_t)v226 >= 0x7FFFFFFFFFFFFFF0uLL)
            v128 = 0xFFFFFFFFFFFFFFFLL;
          else
            v128 = v127;
          if (v128)
            v129 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v128);
          else
            v129 = 0;
          v130 = (float32x4_t *)&v129[16 * v126];
          *v130 = v207;
          v123 = v130 + 1;
          v131 = (float32x4_t *)*((_QWORD *)&v226 + 1);
          v132 = (char *)v226;
          if (*((_QWORD *)&v226 + 1) != (_QWORD)v226)
          {
            do
            {
              v133 = v131[-1];
              --v131;
              v130[-1] = v133;
              --v130;
            }
            while (v131 != (float32x4_t *)v132);
            v131 = (float32x4_t *)v226;
          }
          *(_QWORD *)&v226 = v130;
          *((_QWORD *)&v226 + 1) = v123;
          v227.i64[0] = (uint64_t)&v129[16 * v128];
          if (v131)
            operator delete(v131);
        }
        else
        {
          *v123++ = v125;
        }
        *((_QWORD *)&v226 + 1) = v123;
        ++v122;
      }
      while (v122 != v121);
    }
  }
  v153 = *((_QWORD *)&v226 + 1) - v226;
  if (*((_QWORD *)&v226 + 1) - (_QWORD)v226 < 0x30uLL)
    goto LABEL_154;
  if ((_QWORD)v222 == *((_QWORD *)&v222 + 1))
  {
    v154 = -[ARPlaneGeometry initWithBoundaryVertices:center:extent:]([ARPlaneGeometry alloc], "initWithBoundaryVertices:center:extent:", &v226, *(double *)v203.i64, *(double *)v204.i64);
  }
  else
  {
    v155 = [ARPlaneGeometry alloc];
    *(_OWORD *)v220 = v226;
    v221 = v227.i64[0];
    v227.i64[0] = 0;
    v226 = 0uLL;
    *(_OWORD *)__p = v222;
    v219 = v223;
    v222 = 0uLL;
    *(_QWORD *)&v223 = 0;
    v154 = -[ARPlaneGeometry initWithVertices:triangleIndices:boundaryVertexCount:center:extent:](v155, "initWithVertices:triangleIndices:boundaryVertexCount:center:extent:", v220, __p, v153 >> 4, *(double *)v203.i64, *(double *)v204.i64);
    if (__p[0])
    {
      __p[1] = __p[0];
      operator delete(__p[0]);
    }
    if (v220[0])
    {
      v220[1] = v220[0];
      operator delete(v220[0]);
    }
  }
LABEL_161:
  if ((_QWORD)v222)
  {
    *((_QWORD *)&v222 + 1) = v222;
    operator delete((void *)v222);
  }
  if ((_QWORD)v226)
  {
    *((_QWORD *)&v226 + 1) = v226;
    operator delete((void *)v226);
  }
  -[ARPlaneAnchor setGeometry:](v205, "setGeometry:", v154, v194, v196, v198, v200);
  -[ARAnchor identifier](v205, "identifier");
  v156 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v156, "ar_integerValue");
  -[ARPlaneGeometry vertexCount](v154, "vertexCount");
  -[ARPlaneGeometry triangleCount](v154, "triangleCount");
  kdebug_trace();

  if (a5)
  {
    v157 = -[ARPlaneAnchor worldAlignmentRotation](v205, "worldAlignmentRotation");
    v158 = CV3DPlaneDetectionExtentGridLength();
    if (v158)
    {
      v159 = 0;
      v222 = v197;
      v223 = v195;
      v224 = v201;
      v225 = v199;
      do
      {
        *(__int128 *)((char *)&v226 + v159) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDE0, COERCE_FLOAT(*(__int128 *)((char *)&v222 + v159))), (float32x4_t)xmmword_1B3BE00D0, *(float32x2_t *)((char *)&v222 + v159), 1), (float32x4_t)xmmword_1B3BDFDD0, *(float32x4_t *)((char *)&v222 + v159), 2), (float32x4_t)xmmword_1B3BDFD50, *(float32x4_t *)((char *)&v222 + v159), 3);
        v159 += 16;
      }
      while (v159 != 64);
      v214 = v229;
      v217 = v228;
      v210 = v227;
      v212 = (float32x4_t)v226;
      if (v157)
      {
        v160 = (double)-v157 * 3.14159265 / 180.0;
        v161 = __sincosf_stret(v160 * 0.5);
        v162 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v161.__sinval);
        v162.i32[3] = LODWORD(v161.__cosval);
        *(double *)v163.i64 = simd_matrix4x4(v162);
        v167 = 0;
        v222 = (__int128)v212;
        v223 = (__int128)v210;
        v224 = (__int128)v217;
        v225 = (__int128)v214;
        do
        {
          *(__int128 *)((char *)&v226 + v167) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v163, COERCE_FLOAT(*(__int128 *)((char *)&v222 + v167))), v164, *(float32x2_t *)((char *)&v222 + v167), 1), v165, *(float32x4_t *)((char *)&v222 + v167), 2), v166, *(float32x4_t *)((char *)&v222 + v167), 3);
          v167 += 16;
        }
        while (v167 != 64);
        v210 = v227;
        v212 = (float32x4_t)v226;
        v214 = v229;
        v217 = v228;
      }
      v226 = 0uLL;
      v227.i64[0] = 0;
      std::vector<ARPatch>::reserve((void **)&v226, v158);
      v168 = 0;
      v169 = -a3;
      if (v158 <= 1)
        v170 = 1;
      else
        v170 = v158;
      do
      {
        CV3DPlaneDetectionExtentGridAtIndex();
        v171 = (float32x2_t *)CV3DPlaneDetectionAlignedBoundingBoxMin();
        v172 = (float32x2_t *)CV3DPlaneDetectionAlignedBoundingBoxMax();
        v173 = vadd_f32(*v171, *v172);
        v174 = vaddq_f32(v214, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v212, 0.5 * v173.f32[0]), v210, vmuls_lane_f32(0.5, v173, 1)), (float32x4_t)0, v217));
        v175 = (int8x16_t)vdivq_f32(v174, (float32x4_t)vdupq_laneq_s32((int32x4_t)v174, 3));
        v176 = COERCE_DOUBLE(vsub_f32(*v172, *v171));
        v177 = COERCE_DOUBLE(vrev64_s32(*(int32x2_t *)&v176));
        if (v157 == -90)
          v177 = v176;
        if (v157 == 90)
          v178 = v176;
        else
          v178 = v177;
        v179 = vzip1_s32(*(int32x2_t *)v175.i8, (int32x2_t)*(_OWORD *)&vextq_s8(v175, v175, 8uLL));
        v180 = *((_QWORD *)&v226 + 1);
        if (*((_QWORD *)&v226 + 1) >= v227.i64[0])
        {
          v182 = (uint64_t)(*((_QWORD *)&v226 + 1) - v226) >> 4;
          v183 = v182 + 1;
          if ((unint64_t)(v182 + 1) >> 60)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v184 = v227.i64[0] - v226;
          if ((uint64_t)(v227.i64[0] - v226) >> 3 > v183)
            v183 = v184 >> 3;
          if ((unint64_t)v184 >= 0x7FFFFFFFFFFFFFF0)
            v185 = 0xFFFFFFFFFFFFFFFLL;
          else
            v185 = v183;
          if (v185)
            v186 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v227, v185);
          else
            v186 = 0;
          v187 = (double *)&v186[16 * v182];
          *v187 = *(double *)&v179;
          v187[1] = v178;
          v188 = (char *)*((_QWORD *)&v226 + 1);
          v189 = (char *)v226;
          v190 = v187;
          if (*((_QWORD *)&v226 + 1) != (_QWORD)v226)
          {
            do
            {
              *((_OWORD *)v190 - 1) = *((_OWORD *)v188 - 1);
              v190 -= 2;
              v188 -= 16;
            }
            while (v188 != v189);
            v188 = (char *)v226;
          }
          v181 = (char *)(v187 + 2);
          *(_QWORD *)&v226 = v190;
          *((_QWORD *)&v226 + 1) = v187 + 2;
          v227.i64[0] = (uint64_t)&v186[16 * v185];
          if (v188)
            operator delete(v188);
        }
        else
        {
          **((_QWORD **)&v226 + 1) = v179;
          *(double *)(v180 + 8) = v178;
          v181 = (char *)(v180 + 16);
        }
        *((_QWORD *)&v226 + 1) = v181;
        ++v168;
      }
      while (v168 != v170);
      v191 = [ARPatchGrid alloc];
      HIDWORD(v192) = DWORD1(v226);
      v222 = v226;
      *(_QWORD *)&v223 = v227.i64[0];
      v227.i64[0] = 0;
      v226 = 0uLL;
      *(float *)&v192 = v169;
      v193 = -[ARPatchGrid initWithPatchesVector:pivotAngle:](v191, "initWithPatchesVector:pivotAngle:", &v222, v192);
      if ((_QWORD)v222)
      {
        *((_QWORD *)&v222 + 1) = v222;
        operator delete((void *)v222);
      }
      if ((_QWORD)v226)
      {
        *((_QWORD *)&v226 + 1) = v226;
        operator delete((void *)v226);
      }
    }
    else
    {
      v193 = 0;
    }
    -[ARPlaneAnchor setGridExtent:](v205, "setGridExtent:", v193);

  }
}

void sub_1B3B11B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,void *a47,uint64_t a48)
{
  uint64_t v48;
  void *v50;
  void *v51;

  v50 = *(void **)(v48 - 256);
  if (v50)
  {
    *(_QWORD *)(v48 - 248) = v50;
    operator delete(v50);
  }
  v51 = *(void **)(v48 - 192);
  if (v51)
  {
    *(_QWORD *)(v48 - 184) = v51;
    operator delete(v51);
  }

  _Unwind_Resume(a1);
}

uint64_t semanticsLabelForPlane(uint64_t a1, void *a2)
{
  id v2;
  uint64_t NumSemanticLabels;
  uint64_t i;
  void *v5;

  v2 = a2;
  if (CV3DPlaneDetectionGetSemanticLabel())
  {
    if (v2)
    {
      NumSemanticLabels = CV3DPlaneDetectionGetNumSemanticLabels();
      if (NumSemanticLabels)
      {
        for (i = 0; i != NumSemanticLabels; ++i)
        {
          CV3DPlaneDetectionGetSemanticProbability();
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", 0.0);
          v5 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v2, "addObject:", v5);

        }
      }
    }
  }

  return 0;
}

void sub_1B3B11D08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void setSemanticsFromCV3D(unsigned int a1, void *a2, char a3, void *a4)
{
  id v7;
  void *v8;
  id v9;
  uint64_t v10;
  void *v11;
  unint64_t i;
  void *v13;
  double v14;
  double v15;
  uint64_t v16;
  void *v17;
  void *v18;
  void *v19;
  uint64_t v20;
  id v21;

  v21 = a2;
  v7 = a4;
  v8 = v21;
  v9 = v7;
  if ((a3 & 1) == 0)
  {
    v10 = objc_msgSend(v21, "count");
    v8 = v21;
    if (!v10)
    {
      v20 = 1;
      goto LABEL_15;
    }
  }
  if (!objc_msgSend(v8, "count"))
  {
    v20 = 0;
LABEL_15:
    objc_msgSend(v9, "setClassificationStatus:", v20);
    objc_msgSend(v9, "setClassification:", 0);
    objc_msgSend(v9, "setPossibleClassifications:", MEMORY[0x1E0C9AA70]);
    goto LABEL_16;
  }
  v11 = (void *)objc_opt_new();
  for (i = 0; objc_msgSend(v21, "count") > i; ++i)
  {
    objc_msgSend(v21, "objectAtIndex:", i);
    v13 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "doubleValue");
    v15 = v14;

    if (v15 > 2.22044605e-16)
    {
      v16 = ARPlaneClassificationForSceneUnderstandingLabel(i);
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v15);
      v17 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInteger:", v16);
      v18 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "setObject:forKeyedSubscript:", v17, v18);

    }
  }
  if (a1)
  {
    objc_msgSend(v9, "setClassification:", ARPlaneClassificationForSceneUnderstandingLabel(a1));
    objc_msgSend(v9, "setClassificationStatus:", 3);
    NSStringFromSceneUnderstandingLabel(a1);
    v19 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "setClassificationLabel:", v19);

  }
  else
  {
    objc_msgSend(v9, "setClassification:", 0);
    objc_msgSend(v9, "setClassificationStatus:", 2);
  }
  objc_msgSend(v9, "setPossibleClassifications:", v11);

LABEL_16:
}

void sub_1B3B11F04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

ARPlaneAnchor *ARUpdatePlaneAnchorFromCV3DPlane(ARPlaneAnchor *a1, const CV3DPlaneDetectionPlane *a2, simd_float4x4 a3, simd_float4x4 a4, char a5, int a6, __int16 a7)
{
  uint64_t v12;
  simd_float4 v13;
  simd_float4 v14;
  simd_float4 v15;
  simd_float4 v16;
  int v17;
  float v18;
  unsigned __int8 v20;
  uint64_t v21;
  float v22;
  uint64_t v23;
  float32x2_t v24;
  int32x2_t v25;
  float32x2_t v26;
  float v27;
  __float2 v28;
  float32x4_t v29;
  simd_float4 v30;
  uint64_t v31;
  simd_float4 v32;
  simd_float4 v33;
  simd_float4 v34;
  uint64_t v35;
  uint64_t v36;
  ARPlaneAnchor *v37;
  double v38;
  float v39;
  __float2 v40;
  float32x4_t v41;
  simd_float4 v42;
  uint64_t v43;
  simd_float4 v44;
  simd_float4 v45;
  simd_float4 v46;
  void *v47;
  unsigned int v48;
  double v49;
  double v50;
  __n128 v51;
  __n128 v52;
  __n128 v53;
  float v54;
  float v55;
  float v56;
  void *v57;
  void *v58;
  void *v59;
  __n128 v61;
  __n128 v62;
  __n128 v63;
  float32x4_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float32x4_t v69;
  float32x4_t v70;
  float32x4_t v71;
  float32x4_t v72;
  float32x4_t v73;
  float32x4_t v74;
  float32x4_t v75;
  float32x4_t v76;
  float v77;
  float v78;
  simd_float4x4 v79;
  simd_float4x4 v80;
  simd_float4x4 v81;

  v66 = (float32x4_t)a4.columns[2];
  v69 = (float32x4_t)a4.columns[3];
  v72 = (float32x4_t)a4.columns[1];
  v75 = (float32x4_t)a4.columns[0];
  CV3DPlaneDetectionPlaneTransformationToWorld();
  v12 = 0;
  v79.columns[0] = v13;
  v79.columns[1] = v14;
  v79.columns[2] = v15;
  v79.columns[3] = v16;
  do
  {
    v80.columns[v12] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v75, COERCE_FLOAT(*(_OWORD *)&v79.columns[v12])), v72, *(float32x2_t *)v79.columns[v12].f32, 1), v66, (float32x4_t)v79.columns[v12], 2), v69, (float32x4_t)v79.columns[v12], 3);
    ++v12;
  }
  while (v12 != 4);
  v70 = (float32x4_t)v80.columns[1];
  v73 = (float32x4_t)v80.columns[0];
  v65 = (float32x4_t)v80.columns[3];
  v67 = (float32x4_t)v80.columns[2];
  v17 = CV3DPlaneDetectionPlaneExtentOrientedBoundingBox();
  v18 = 0.0;
  if (CV3DPlaneDetectionPlaneGetOrientation() == *MEMORY[0x1E0D84210] && v17 != 0)
  {
    v80.columns[0] = v79.columns[0];
    v80.columns[1] = v79.columns[1];
    {
      pivotForOrientedBox(simd_float4x2)::k_cos45 = 1060439283;
    }
    v21 = 0;
    v22 = *(float *)&pivotForOrientedBox(simd_float4x2)::k_cos45;
    do
    {
      v23 = v21 + 1;
      v24 = vsub_f32(*(float32x2_t *)&v80.columns[0].f32[2 * v21], *(float32x2_t *)&v80.columns[0].f32[2 * ((v21 + 1) & 3)]);
      v25 = (int32x2_t)vmul_f32(v24, v24);
      *(float *)v25.i32 = sqrtf(vmlas_n_f32(*(float *)&v25.i32[1], v24.f32[0], v24.f32[0]));
      v26 = vdiv_f32(v24, (float32x2_t)vdup_lane_s32(v25, 0));
      if (v26.f32[0] >= v22)
      {
        v77 = v26.f32[1];
        v27 = acosf(fminf(fmaxf(v26.f32[0], -1.0), 1.0));
        if (v77 >= 0.0)
          v18 = v27;
        else
          v18 = -v27;
      }
      v21 = v23;
    }
    while (v23 != 4);
  }
  if (a6)
  {
    v28 = __sincosf_stret(v18 * 0.5);
    v29 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFF70, v28.__sinval);
    v29.i32[3] = LODWORD(v28.__cosval);
    *(double *)v30.i64 = simd_matrix4x4(v29);
    v31 = 0;
    v79.columns[0] = v30;
    v79.columns[1] = v32;
    v79.columns[2] = v33;
    v79.columns[3] = v34;
    do
    {
      v80.columns[v31] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v73, COERCE_FLOAT(*(_OWORD *)&v79.columns[v31])), v70, *(float32x2_t *)v79.columns[v31].f32, 1), v67, (float32x4_t)v79.columns[v31], 2), v65, (float32x4_t)v79.columns[v31], 3);
      ++v31;
    }
    while (v31 != 4);
    v70 = (float32x4_t)v80.columns[1];
    v73 = (float32x4_t)v80.columns[0];
    v65 = (float32x4_t)v80.columns[3];
    v67 = (float32x4_t)v80.columns[2];
  }
  v81 = __invert_f4(*(simd_float4x4 *)_PromotedConst_2);
  v35 = 0;
  v79 = v81;
  do
  {
    v80.columns[v35] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v73, COERCE_FLOAT(*(_OWORD *)&v79.columns[v35])), v70, *(float32x2_t *)v79.columns[v35].f32, 1), v67, (float32x4_t)v79.columns[v35], 2), v65, (float32x4_t)v79.columns[v35], 3);
    ++v35;
  }
  while (v35 != 4);
  v36 = 0;
  v62 = (__n128)v80.columns[1];
  v63 = (__n128)v80.columns[0];
  v79 = v80;
  v61 = (__n128)v80.columns[2];
  do
  {
    v80.columns[v36] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)a3.columns[0], COERCE_FLOAT(*(_OWORD *)&v79.columns[v36])), (float32x4_t)a3.columns[1], *(float32x2_t *)v79.columns[v36].f32, 1), (float32x4_t)a3.columns[2], (float32x4_t)v79.columns[v36], 2), (float32x4_t)a3.columns[3], (float32x4_t)v79.columns[v36], 3);
    ++v36;
  }
  while (v36 != 4);
  v74 = (float32x4_t)v80.columns[1];
  v76 = (float32x4_t)v80.columns[0];
  v68 = (float32x4_t)v80.columns[3];
  v71 = (float32x4_t)v80.columns[2];
  v37 = (ARPlaneAnchor *)-[ARPlaneAnchor copy](a1, "copy");
  -[ARAnchor setTransform:](v37, "setTransform:", *(double *)v76.i64, *(double *)v74.i64, *(double *)v71.i64, *(double *)v68.i64);
  CV3DPlaneDetectionPlaneUncertaintyAlongNormal();
  *(float *)&v38 = v38;
  -[ARPlaneAnchor setUncertaintyAlongNormal:](v37, "setUncertaintyAlongNormal:", v38);
  if (-[ARPlaneAnchor worldAlignmentRotation](v37, "worldAlignmentRotation"))
  {
    v39 = (double)-[ARPlaneAnchor worldAlignmentRotation](v37, "worldAlignmentRotation", *(_OWORD *)&v61, *(_OWORD *)&v62, *(_OWORD *)&v63)* 3.14159265/ 180.0;
    v40 = __sincosf_stret(v39 * 0.5);
    v41 = vmulq_n_f32((float32x4_t)xmmword_1B3BDFDD0, v40.__sinval);
    v41.i32[3] = LODWORD(v40.__cosval);
    *(double *)v42.i64 = simd_matrix4x4(v41);
    v43 = 0;
    v79.columns[0] = v42;
    v79.columns[1] = v44;
    v79.columns[2] = v45;
    v79.columns[3] = v46;
    do
    {
      v80.columns[v43] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v76, COERCE_FLOAT(*(_OWORD *)&v79.columns[v43])), v74, *(float32x2_t *)v79.columns[v43].f32, 1), v71, (float32x4_t)v79.columns[v43], 2), v68, (float32x4_t)v79.columns[v43], 3);
      ++v43;
    }
    while (v43 != 4);
    -[ARAnchor setTransform:](v37, "setTransform:", *(double *)v80.columns[0].i64, *(double *)v80.columns[1].i64, *(double *)v80.columns[2].i64, *(double *)v80.columns[3].i64);
  }
  _updateExtentsForPlaneAnchor(v37, a2, v18, a6, (a7 & 0x200) != 0);
  v47 = (void *)objc_opt_new();
  v48 = semanticsLabelForPlane((uint64_t)a2, v47);
  setSemanticsFromCV3D(v48, v47, a5, v37);
  if (-[ARPlaneAnchor alignment](v37, "alignment") == ARPlaneAnchorAlignmentHorizontal)
  {
    v50 = AREulerAnglesFromMatrix(v63, v62, v61);
    v78 = *((float *)&v50 + 1);
    -[ARAnchor referenceTransform](a1, "referenceTransform");
    AREulerAnglesFromMatrix(v51, v52, v53);
    v54 = v78 * 0.318309886 * 180.0;
    v56 = v54 + v55 * -0.318309886 * 180.0;
    v49 = v56;
  }
  -[ARAnchor identifier](v37, "identifier", v49, *(_OWORD *)&v61, *(_OWORD *)&v62, *(_OWORD *)&v63);
  v57 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v57, "ar_integerValue");
  -[ARPlaneAnchor planeExtent](v37, "planeExtent");
  v58 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v58, "width");
  -[ARPlaneAnchor planeExtent](v37, "planeExtent");
  v59 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v59, "height");
  kdebug_trace();

  return v37;
}

void sub_1B3B12498(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B12660(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B12BC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30)
{
  void *v30;

  _Unwind_Resume(a1);
}

void sub_1B3B12EF4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B132D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<short>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int16 v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 1)
  {
    if ((a2 & 0x8000000000000000) != 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFFELL];
    v9 = &v6[2 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_WORD *)v11 - 1);
        v11 -= 2;
        *((_WORD *)v12 - 1) = v13;
        v12 -= 2;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<short>>(uint64_t a1, uint64_t a2)
{
  if (a2 < 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(2 * a2);
}

void std::vector<ARPatch>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 4)
  {
    if (a2 >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF0];
    v9 = &v6[16 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 1) = *((_OWORD *)v10 - 1);
        v12 -= 16;
        v10 -= 16;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_10()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void sub_1B3B13E64(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B14404(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void sub_1B3B14E8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15, void *a16, uint64_t a17, uint64_t a18, void *a19)
{

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_11()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

id ARSensorDataTypesToString(uint64_t a1)
{
  void *v2;
  void *v3;
  const __CFString *v4;
  void *v5;

  v2 = (void *)objc_opt_new();
  v3 = v2;
  if (!a1)
  {
    v4 = CFSTR("None");
LABEL_20:
    objc_msgSend(v3, "addObject:", v4);
    goto LABEL_21;
  }
  if ((a1 & 1) != 0)
  {
    objc_msgSend(v2, "addObject:", CFSTR("ColorImage"));
    if ((a1 & 2) == 0)
    {
LABEL_4:
      if ((a1 & 4) == 0)
        goto LABEL_5;
      goto LABEL_14;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_4;
  }
  objc_msgSend(v3, "addObject:", CFSTR("Accelerometer"));
  if ((a1 & 4) == 0)
  {
LABEL_5:
    if ((a1 & 8) == 0)
      goto LABEL_6;
    goto LABEL_15;
  }
LABEL_14:
  objc_msgSend(v3, "addObject:", CFSTR("Gyroscope"));
  if ((a1 & 8) == 0)
  {
LABEL_6:
    if ((a1 & 0x10) == 0)
      goto LABEL_7;
    goto LABEL_16;
  }
LABEL_15:
  objc_msgSend(v3, "addObject:", CFSTR("DeviceOrientation"));
  if ((a1 & 0x10) == 0)
  {
LABEL_7:
    if ((a1 & 0x20) == 0)
      goto LABEL_8;
    goto LABEL_17;
  }
LABEL_16:
  objc_msgSend(v3, "addObject:", CFSTR("FaceMetaData"));
  if ((a1 & 0x20) == 0)
  {
LABEL_8:
    if ((a1 & 0x40) == 0)
      goto LABEL_9;
    goto LABEL_18;
  }
LABEL_17:
  objc_msgSend(v3, "addObject:", CFSTR("Depth"));
  if ((a1 & 0x40) == 0)
  {
LABEL_9:
    if ((a1 & 0x400) == 0)
      goto LABEL_21;
    goto LABEL_19;
  }
LABEL_18:
  objc_msgSend(v3, "addObject:", CFSTR("Location"));
  if ((a1 & 0x400) != 0)
  {
LABEL_19:
    v4 = CFSTR("Magnetometer");
    goto LABEL_20;
  }
LABEL_21:
  objc_msgSend(v3, "componentsJoinedByString:", CFSTR(" | "));
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

uint64_t ARC3DSegmentIntersectsSegment(double a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8)
{
  if ((a3 - a1) * (a6 - a2) - (a4 - a2) * (a5 - a1) <= 0.0 != (a3 - a1) * (a8 - a2) - (a4 - a2) * (a7 - a1) > 0.0)
    return 0;
  else
    return ((a7 - a5) * (a2 - a6) - (a8 - a6) * (a1 - a5) > 0.0) ^ ((a7 - a5) * (a4 - a6)
                                                                                - (a8 - a6) * (a3 - a5) > 0.0);
}

double ARC3DComputeLinesIntersection(double *a1, double *a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9, double a10)
{
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double result;

  v10 = a3 - a5;
  v11 = (a3 - a5) * (a8 - a10) - (a4 - a6) * (a7 - a9);
  if (v11 == 0.0)
    ARC3DComputeLinesIntersection_cold_1();
  v12 = -(a4 - a6);
  v13 = a3 * a6 - a4 * a5;
  v14 = a7 * a10 - a8 * a9;
  *a1 = (v13 * (a7 - a9) - v10 * v14) / v11;
  result = (v14 * v12 + v13 * (a8 - a10)) / v11;
  *a2 = result;
  return result;
}

double ARC3DComputeLinesIntersectionForPoints(double *a1, double a2, double a3, double a4, double a5, double a6, double a7, double a8, double a9)
{
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double result;

  v9 = a2 - a4;
  v10 = (a2 - a4) * (a7 - a9) - (a3 - a5) * (a6 - a8);
  if (v10 == 0.0)
    ARC3DComputeLinesIntersectionForPoints_cold_1();
  v11 = -(a3 - a5);
  v12 = a2 * a5 - a3 * a4;
  v13 = a6 * a9 - a7 * a8;
  v14 = (v12 * (a6 - a8) - v9 * v13) / v10;
  result = (v13 * v11 + v12 * (a7 - a9)) / v10;
  *a1 = v14;
  a1[1] = result;
  return result;
}

id _ARLogGeneral_20()
{
  if (_ARLogGeneral_onceToken_24 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_24, &__block_literal_global_58);
  return (id)_ARLogGeneral_logObj_24;
}

void sub_1B3B17B58(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

const __CFString *NSStringFromARWorldMappingStatus(unint64_t a1)
{
  if (a1 > 3)
    return &stru_1E6676798;
  else
    return off_1E6674588[a1];
}

void sub_1B3B18F2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_21()
{
  if (_ARLogGeneral_onceToken_25 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_25, &__block_literal_global_59);
  return (id)_ARLogGeneral_logObj_25;
}

void sub_1B3B1A4A8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3B1A6EC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_7()
{
  if (_ARLogTechnique_onceToken_10 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_10, &__block_literal_global_60);
  return (id)_ARLogTechnique_logObj_10;
}

id _ARLogGeneral_22()
{
  if (_ARLogGeneral_onceToken_26 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_26, &__block_literal_global_151);
  return (id)_ARLogGeneral_logObj_26;
}

void sub_1B3B1B990(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *), uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
  a12(&a10);
  _Block_object_dispose(&a18, 8);
  _Block_object_dispose(&a22, 8);
  _Block_object_dispose(&a26, 8);
  _Block_object_dispose(&a30, 8);
  _Unwind_Resume(a1);
}

void sub_1B3B1BD60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_0(uint64_t a1)
{
  void *v1;

  qword_1EF081328 = a1;

}

id ARCopyFromSharedTextureHandle(void *a1, char a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;

  v3 = a1;
  objc_msgSend(v3, "device");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = (void *)objc_msgSend(v4, "newCommandQueue");
  v6 = (void *)objc_msgSend(v4, "newSharedTextureWithHandle:", v3);

  objc_msgSend(MEMORY[0x1E0CC6BB0], "textureCubeDescriptorWithPixelFormat:size:mipmapped:", objc_msgSend(v6, "pixelFormat"), objc_msgSend(v6, "width"), (unint64_t)objc_msgSend(v6, "mipmapLevelCount") > 1);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if ((a2 & 1) != 0)
    v8 = objc_msgSend(v4, "newSharedTextureWithDescriptor:", v7);
  else
    v8 = objc_msgSend(v4, "newTextureWithDescriptor:", v7);
  v9 = (void *)v8;
  objc_msgSend(v5, "commandBuffer");
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v10, "setLabel:", CFSTR("com.apple.arkit.lightestimation.copytexturebuffer"));
  objc_msgSend(v10, "blitCommandEncoder");
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v11, "setLabel:", CFSTR("com.apple.arkit.lightestimation.copytexture"));
  objc_msgSend(v11, "copyFromTexture:toTexture:", v6, v9);
  objc_msgSend(v11, "endEncoding");
  objc_msgSend(v10, "commit");
  objc_msgSend(v10, "waitUntilCompleted");

  return v9;
}

id ARCopyMipmapsFromSharedTextureHandle(void *a1, id a2)
{
  id v2;
  id v3;
  void *v4;
  void *v5;
  void *v6;
  unint64_t v7;
  id v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = a2;
  if (a2)
  {
    v3 = a1;
    objc_msgSend(v3, "device");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    v5 = (void *)objc_msgSend(v4, "newCommandQueue");
    v6 = (void *)objc_msgSend(v4, "newSharedTextureWithHandle:", v3);

    v7 = objc_msgSend(v6, "mipmapLevelCount");
    if (v7 >= (unint64_t)v2)
      v8 = v2;
    else
      v8 = (id)v7;
    objc_msgSend(MEMORY[0x1E0CC6BB0], "textureCubeDescriptorWithPixelFormat:size:mipmapped:", objc_msgSend(v6, "pixelFormat"), (unint64_t)exp2((double)((unint64_t)v8 - 1)), (unint64_t)objc_msgSend(v6, "mipmapLevelCount") > 1);
    v9 = (void *)objc_claimAutoreleasedReturnValue();
    v2 = (id)objc_msgSend(v4, "newSharedTextureWithDescriptor:", v9);
    objc_msgSend(v5, "commandBuffer");
    v10 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "setLabel:", CFSTR("com.apple.arkit.lightestimation.lowrescopytexturebuffer"));
    objc_msgSend(v10, "blitCommandEncoder");
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "setLabel:", CFSTR("com.apple.arkit.lightestimation.lowrescopytexture"));
    objc_msgSend(v11, "copyFromTexture:sourceSlice:sourceLevel:toTexture:destinationSlice:destinationLevel:sliceCount:levelCount:", v6, 0, objc_msgSend(v6, "mipmapLevelCount") - (_QWORD)v8, v2, 0, 0, 6, v8);
    objc_msgSend(v11, "endEncoding");
    objc_msgSend(v10, "commit");
    objc_msgSend(v10, "waitUntilCompleted");

  }
  return v2;
}

float ARAverageCubemapIntensity(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  float v4;
  char v5;
  uint64_t v6;
  uint64_t v7;
  char v8;
  char v9;
  char v10;
  uint64_t v11;
  float v21;
  int64x2_t v24;
  _QWORD v25[3];
  int64x2_t v26;
  uint64_t v27;
  _WORD v28[16];
  uint64_t v29;

  v29 = *MEMORY[0x1E0C80C00];
  v1 = a1;
  if ((unint64_t)objc_msgSend(v1, "mipmapLevelCount") >= 2)
    v2 = objc_msgSend(v1, "mipmapLevelCount") - 2;
  else
    v2 = 0;
  v3 = 0;
  v4 = 0.0;
  v24 = vdupq_n_s64(2uLL);
  do
  {
    memset(v25, 0, sizeof(v25));
    v26 = v24;
    v5 = 1;
    v27 = 1;
    objc_msgSend(v1, "getBytes:bytesPerRow:bytesPerImage:fromRegion:mipmapLevel:slice:", v28, 16, 32, v25, v2, v3, *(_OWORD *)&v24);
    v6 = 0;
    do
    {
      v7 = 0;
      v8 = v5;
      v9 = 1;
      do
      {
        v10 = v9;
        v11 = v6 | v7;
        _H0 = v28[v11];
        _H1 = *(_WORD *)((char *)v28 + ((2 * v11) | 2));
        _H2 = *(_WORD *)((char *)v28 + ((2 * v11) | 4));
        __asm
        {
          FCVT            S0, H0
          FCVT            S1, H1
        }
        v21 = (float)(_S1 * 0.715) + (float)(_S0 * 0.213);
        __asm { FCVT            S1, H2 }
        v4 = v4 + (float)(v21 + (float)(_S1 * 0.072));
        v7 = 4;
        v9 = 0;
      }
      while ((v10 & 1) != 0);
      v5 = 0;
      v6 = 8;
    }
    while ((v8 & 1) != 0);
    ++v3;
  }
  while (v3 != 6);

  return v4 / 24.0;
}

id ARErrorWithCodeAndUserInfo(uint64_t a1, void *a2)
{
  id v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  const __CFString *v8;
  void *v9;
  void *v10;
  void *v11;
  const __CFString *v12;
  uint64_t v13;
  const __CFString *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  _QWORD *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  const __CFString *v35;
  void *v36;
  void *v37;
  void *v38;
  void *v39;
  void *v40;
  void *v41;
  void *v42;
  void *v43;
  void *v44;
  void *v45;
  void *v46;
  void *v47;
  void *v48;
  void *v49;
  void *v50;
  uint64_t v51;
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;
  void *v62;
  void *v63;

  v3 = a2;
  objc_msgSend(MEMORY[0x1E0C99E08], "dictionary");
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v5 = v4;
  if (a1 <= 299)
  {
    if (a1 <= 149)
    {
      switch(a1)
      {
        case 'd':
          ARKitCoreBundle();
          v9 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v9, "localizedStringForKey:value:table:", CFSTR("Unsupported configuration."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v10 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v10, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          v7 = v11;
          v12 = CFSTR("The provided configuration is not supported on this device.");
          goto LABEL_31;
        case 'e':
          ARKitCoreBundle();
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v25, "localizedStringForKey:value:table:", CFSTR("Required sensor unavailable."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v26 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v26, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v11 = (void *)objc_claimAutoreleasedReturnValue();
          v7 = v11;
          v12 = CFSTR("A required sensor is not available on this device.");
          goto LABEL_31;
        case 'f':
          ARKitCoreBundle();
          v29 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v29, "localizedStringForKey:value:table:", CFSTR("Required sensor failed."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v30 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v30, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v31 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v31, "localizedStringForKey:value:table:", CFSTR("A sensor failed to deliver the required input."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v32 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v32, *MEMORY[0x1E0CB2D68]);

          ARKitCoreBundle();
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          v34 = v33;
          v35 = CFSTR("Make sure that the application has the required privacy settings.");
          break;
        case 'g':
          ARKitCoreBundle();
          v36 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v36, "localizedStringForKey:value:table:", CFSTR("Camera access not authorized."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v37 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v37, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v38 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v38, "localizedStringForKey:value:table:", CFSTR("The app does not have permission to use the camera."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v39 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v39, *MEMORY[0x1E0CB2D68]);

          ARKitCoreBundle();
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          v34 = v33;
          v35 = CFSTR("Make sure that the application has the required camera privacy settings.");
          break;
        case 'h':
          ARKitCoreBundle();
          v40 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v40, "localizedStringForKey:value:table:", CFSTR("Microphone access not authorized."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v41 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v41, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v42 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v42, "localizedStringForKey:value:table:", CFSTR("The app does not have permission to use the microphone."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v43 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v43, *MEMORY[0x1E0CB2D68]);

          ARKitCoreBundle();
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          v34 = v33;
          v35 = CFSTR("Make sure that the application has the required microphone privacy settings.");
          break;
        case 'i':
          ARKitCoreBundle();
          v44 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v44, "localizedStringForKey:value:table:", CFSTR("Location access not authorized."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v45 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v45, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v46 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v46, "localizedStringForKey:value:table:", CFSTR("The app does not have permission to use the location of the device."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v47 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v47, *MEMORY[0x1E0CB2D68]);

          ARKitCoreBundle();
          v33 = (void *)objc_claimAutoreleasedReturnValue();
          v34 = v33;
          v35 = CFSTR("Location access and precise accuracy must be enabled in the app's privacy settings.");
          break;
        case 'j':
          ARKitCoreBundle();
          v49 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v49, "localizedStringForKey:value:table:", CFSTR("Another high-resolution frame is currently being captured."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v50 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v5, "setObject:forKeyedSubscript:", v50, *MEMORY[0x1E0CB2D50]);

          ARKitCoreBundle();
          v7 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v7, "localizedStringForKey:value:table:", CFSTR("Please wait for the completion handler call."), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          v28 = (_QWORD *)MEMORY[0x1E0CB2D80];
          goto LABEL_51;
        case 'k':
          ARKitCoreBundle();
          v6 = (void *)objc_claimAutoreleasedReturnValue();
          v7 = v6;
          v8 = CFSTR("Capturing a high resolution frame failed.");
          goto LABEL_50;
        default:
          goto LABEL_52;
      }
      objc_msgSend(v33, "localizedStringForKey:value:table:", v35, &stru_1E6676798, CFSTR("Localizable_iOS"));
      v48 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v48, *MEMORY[0x1E0CB2D80]);

      if (v3)
        goto LABEL_53;
      goto LABEL_54;
    }
    if (a1 <= 200)
    {
      if (a1 != 150)
      {
        if (a1 != 200)
          goto LABEL_52;
        ARKitCoreBundle();
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "localizedStringForKey:value:table:", CFSTR("World tracking failed."), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "setObject:forKeyedSubscript:", v16, *MEMORY[0x1E0CB2D50]);

        ARKitCoreBundle();
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v11;
        v12 = CFSTR("World tracking cannot determine the devices position.");
        goto LABEL_31;
      }
      objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("Unsupported capture session configuration."), *MEMORY[0x1E0CB2D50]);
      objc_msgSend(v5, "setObject:forKeyedSubscript:", CFSTR("Input device and/or format of the provided capture session are not supported for the given configuration."), *MEMORY[0x1E0CB2D68]);
      v13 = *MEMORY[0x1E0CB2D80];
      v14 = CFSTR("Make sure that the correct device and format are being used for capture.");
LABEL_56:
      objc_msgSend(v5, "setObject:forKeyedSubscript:", v14, v13);
      if (!v3)
        goto LABEL_54;
      goto LABEL_53;
    }
    if (a1 == 201)
    {
      ARKitCoreBundle();
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      v8 = CFSTR("Geo tracking is not available at this location.");
    }
    else
    {
      if (a1 != 202)
        goto LABEL_52;
      ARKitCoreBundle();
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      v7 = v6;
      v8 = CFSTR("Geo tracking failed because of a runtime error.");
    }
LABEL_50:
    objc_msgSend(v6, "localizedStringForKey:value:table:", v8, &stru_1E6676798, CFSTR("Localizable_iOS"));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = (_QWORD *)MEMORY[0x1E0CB2D50];
    goto LABEL_51;
  }
  if (a1 <= 499)
  {
    switch(a1)
    {
      case 300:
        ARKitCoreBundle();
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v6;
        v8 = CFSTR("Invalid reference image.");
        goto LABEL_50;
      case 301:
        ARKitCoreBundle();
        v19 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v19, "localizedStringForKey:value:table:", CFSTR("Invalid reference object."), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v20 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "setObject:forKeyedSubscript:", v20, *MEMORY[0x1E0CB2D50]);

        ARKitCoreBundle();
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v11;
        v12 = CFSTR("The reference object data is not in a format supported by this version of ARReferenceObject.");
        break;
      case 302:
        ARKitCoreBundle();
        v21 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v21, "localizedStringForKey:value:table:", CFSTR("Invalid world map."), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v22 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "setObject:forKeyedSubscript:", v22, *MEMORY[0x1E0CB2D50]);

        ARKitCoreBundle();
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v11;
        v12 = CFSTR("The world map data is not in a format supported by this version of ARWorldMap.");
        break;
      case 303:
        ARKitCoreBundle();
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v6;
        v8 = CFSTR("Invalid configuration.");
        goto LABEL_50;
      case 304:
        ARKitCoreBundle();
        v23 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v23, "localizedStringForKey:value:table:", CFSTR("Invalid collaboration data."), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v24 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "setObject:forKeyedSubscript:", v24, *MEMORY[0x1E0CB2D50]);

        ARKitCoreBundle();
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v11;
        v12 = CFSTR("The encoded data is not in a format supported by this version of ARCollaborationData.");
        break;
      default:
        if (a1 == 400)
        {
          ARKitCoreBundle();
          v6 = (void *)objc_claimAutoreleasedReturnValue();
          v7 = v6;
          v8 = CFSTR("Insufficient features.");
          goto LABEL_50;
        }
        if (a1 != 401)
          goto LABEL_52;
        ARKitCoreBundle();
        v17 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "localizedStringForKey:value:table:", CFSTR("Object merge failed."), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v5, "setObject:forKeyedSubscript:", v18, *MEMORY[0x1E0CB2D50]);

        ARKitCoreBundle();
        v11 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v11;
        v12 = CFSTR("Not enough matching features were found for the reference objects to be merged.");
        break;
    }
LABEL_31:
    objc_msgSend(v11, "localizedStringForKey:value:table:", v12, &stru_1E6676798, CFSTR("Localizable_iOS"));
    v27 = (void *)objc_claimAutoreleasedReturnValue();
    v28 = (_QWORD *)MEMORY[0x1E0CB2D68];
LABEL_51:
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v27, *v28);

    goto LABEL_52;
  }
  if (a1 > 999)
  {
    switch(a1)
    {
      case 1000:
        objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("Unauthorized to write to the photo library."), *MEMORY[0x1E0CB2D50]);
        objc_msgSend(v5, "setObject:forKeyedSubscript:", CFSTR("A permission is missing to access the photo library."), *MEMORY[0x1E0CB2D68]);
        v13 = *MEMORY[0x1E0CB2D80];
        v14 = CFSTR("Make sure that the application has the required privacy settings.");
        goto LABEL_56;
      case 1001:
        objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("Failed saving the recording."), *MEMORY[0x1E0CB2D50]);
        v13 = *MEMORY[0x1E0CB2D68];
        v14 = CFSTR("Failed saving the recording for an unknown reason.");
        goto LABEL_56;
      case 1002:
      case 1003:
        goto LABEL_52;
      case 1004:
        objc_msgSend(v4, "setObject:forKeyedSubscript:", CFSTR("Failed to load espresso model."), *MEMORY[0x1E0CB2D50]);
        if (v3)
        {
          v51 = *MEMORY[0x1E0CB2AA0];
          objc_msgSend(v3, "objectForKey:", *MEMORY[0x1E0CB2AA0]);
          v52 = (void *)objc_claimAutoreleasedReturnValue();

          if (v52)
          {
            v53 = (void *)MEMORY[0x1E0CB3940];
            objc_msgSend(v3, "objectForKey:", v51);
            v54 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v53, "stringWithFormat:", CFSTR("File path '%@' is invalid or does not exist"), v54);
            v55 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v5, "setObject:forKeyedSubscript:", v55, *MEMORY[0x1E0CB2D68]);

            goto LABEL_53;
          }
        }
        v13 = *MEMORY[0x1E0CB2D68];
        v14 = CFSTR("File path is invalid or does not exist");
        break;
      case 1005:
        ARKitCoreBundle();
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v6;
        v8 = CFSTR("Unsupported sensor data.");
        goto LABEL_50;
      default:
        if (a1 != 1028)
          goto LABEL_52;
        ARKitCoreBundle();
        v6 = (void *)objc_claimAutoreleasedReturnValue();
        v7 = v6;
        v8 = CFSTR("Unsupported feature.");
        goto LABEL_50;
    }
    goto LABEL_56;
  }
  if (a1 == 500)
  {
    ARKitCoreBundle();
    v56 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v56, "localizedStringForKey:value:table:", CFSTR("File IO failed."), &stru_1E6676798, CFSTR("Localizable_iOS"));
    v57 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v57, *MEMORY[0x1E0CB2D50]);

    v58 = (void *)MEMORY[0x1E0CB3940];
    ARKitCoreBundle();
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v59, "localizedStringForKey:value:table:", CFSTR("Unable to read from or write to URL: %@."), &stru_1E6676798, CFSTR("Localizable_iOS"));
    v60 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v3, "objectForKeyedSubscript:", *MEMORY[0x1E0CB3308]);
    v61 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v58, "stringWithFormat:", v60, v61);
    v62 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v5, "setObject:forKeyedSubscript:", v62, *MEMORY[0x1E0CB2D68]);

    if (!v3)
      goto LABEL_54;
    goto LABEL_53;
  }
  if (a1 == 501)
  {
    ARKitCoreBundle();
    v6 = (void *)objc_claimAutoreleasedReturnValue();
    v7 = v6;
    v8 = CFSTR("Request failed.");
    goto LABEL_50;
  }
LABEL_52:
  if (v3)
LABEL_53:
    objc_msgSend(v5, "addEntriesFromDictionary:", v3);
LABEL_54:
  objc_msgSend(MEMORY[0x1E0CB35C8], "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), a1, v5);
  v63 = (void *)objc_claimAutoreleasedReturnValue();

  return v63;
}

const __CFString *NSStringFromARPlaneClassification(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 6)
    return CFSTR("None");
  else
    return off_1E6674638[a1 - 1];
}

const __CFString *NSStringFromARPlaneClassificationStatus(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 2)
    return CFSTR("Unavailable");
  else
    return off_1E6674620[a1 - 1];
}

const __CFString *NSStringFromARPlaneAlignment(uint64_t a1)
{
  const __CFString *v1;

  v1 = CFSTR("vertical");
  if (a1 != 1)
    v1 = 0;
  if (a1)
    return v1;
  else
    return CFSTR("horizontal");
}

id ARCreateOBJStringForPlaneAnchors(void *a1, _QWORD *a2, float a3)
{
  id v5;
  void *v6;
  id v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t i;
  void *v14;
  void *v15;
  void *v16;
  BOOL v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  int v27;
  double v28;
  uint64_t v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  float32x4_t *v36;
  uint64_t v37;
  __n128 v38;
  double v39;
  double v40;
  double v41;
  uint64_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  void *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  __int16 *v53;
  void *v54;
  void *v55;
  NSObject *v56;
  void *v57;
  uint64_t v58;
  void *v59;
  void *v61;
  id obj;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  int v66;
  __int128 v67;
  __int128 v68;
  __int128 v69;
  __int128 v70;
  uint8_t buf[16];
  __int128 v72;
  __int128 v73;
  __int128 v74;
  __int128 v75;
  _BYTE v76[128];
  uint64_t v77;
  const __CFString *v78;
  _BYTE v79[128];
  uint64_t v80;

  v80 = *MEMORY[0x1E0C80C00];
  v5 = a1;
  objc_msgSend(MEMORY[0x1E0CB37A0], "string");
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v72 = 0u;
  v73 = 0u;
  v74 = 0u;
  v75 = 0u;
  v7 = v5;
  v8 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v72, v79, 16);
  if (v8)
  {
    v9 = v8;
    v10 = 0;
    LODWORD(v11) = 0;
    v12 = *(_QWORD *)v73;
    do
    {
      for (i = 0; i != v9; ++i)
      {
        if (*(_QWORD *)v73 != v12)
          objc_enumerationMutation(v7);
        v14 = *(void **)(*((_QWORD *)&v72 + 1) + 8 * i);
        objc_msgSend(v14, "geometry");
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        v11 = objc_msgSend(v15, "vertexCount") + v11;

        objc_msgSend(v14, "geometry");
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        v10 += objc_msgSend(v16, "triangleCount");

      }
      v9 = objc_msgSend(v7, "countByEnumeratingWithState:objects:count:", &v72, v79, 16);
    }
    while (v9);

    if ((_DWORD)v11)
      v17 = v10 == 0;
    else
      v17 = 1;
    if (!v17)
    {
      objc_msgSend(v6, "appendString:", CFSTR("#\n"));
      v18 = (void *)MEMORY[0x1E0CB3940];
      objc_msgSend(MEMORY[0x1E0CB34D0], "mainBundle");
      v19 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v19, "bundleIdentifier");
      v20 = (void *)objc_claimAutoreleasedReturnValue();
      ARVersionStringForIdentifier(v20);
      v21 = (void *)objc_claimAutoreleasedReturnValue();
      ARVersionStringForIdentifier(CFSTR("com.apple.ARKit"));
      v22 = (void *)objc_claimAutoreleasedReturnValue();
      ARVersionStringForIdentifier(CFSTR("com.apple.AppleCV3D"));
      v61 = v7;
      v23 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v18, "stringWithFormat:", CFSTR("# ARKit plane geometry mesh exported from ARExamples %@, ARKit %@, AppleCV3D %@\n"), v21, v22, v23);
      v24 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "appendString:", v24);

      objc_msgSend(v6, "appendString:", CFSTR("#\n"));
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("# Vertex count: %d\n"), v11);
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "appendString:", v25);

      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("# Face count: %d\n"), (2 * v10));
      v26 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "appendString:", v26);

      objc_msgSend(v6, "appendString:", CFSTR("#\n"));
      objc_msgSend(v6, "appendString:", CFSTR("# Real world scale is 1 unit = 1 m\n"));
      objc_msgSend(v6, "appendString:", CFSTR("# Each vertex is followed by four RGBA color values in range [0.0 - 1.0] (not in spec)\n"));
      v69 = 0u;
      v70 = 0u;
      v67 = 0u;
      v68 = 0u;
      obj = v61;
      v64 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v67, v76, 16);
      if (v64)
      {
        v27 = 1;
        v63 = *(_QWORD *)v68;
        v28 = a3;
        do
        {
          v29 = 0;
          do
          {
            if (*(_QWORD *)v68 != v63)
              objc_enumerationMutation(obj);
            v65 = v29;
            v30 = *(void **)(*((_QWORD *)&v67 + 1) + 8 * v29);
            objc_msgSend(v6, "appendString:", CFSTR("\n"));
            v31 = (void *)MEMORY[0x1E0CB3940];
            objc_msgSend(v30, "identifier");
            v32 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v32, "UUIDString");
            v33 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v31, "stringWithFormat:", CFSTR("o plane_anchor_%@\n"), v33);
            v34 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v6, "appendString:", v34);

            objc_msgSend(v6, "appendString:", CFSTR("\n"));
            objc_msgSend(v30, "geometry");
            v35 = (void *)objc_claimAutoreleasedReturnValue();
            v36 = (float32x4_t *)objc_msgSend(v35, "vertices");
            v37 = objc_msgSend(v35, "vertexCount");
            v38 = ARCV3DColorComponentsForARKitSemantics(objc_msgSend(v30, "classification"));
            v66 = v37;
            if (v37)
            {
              v39 = v38.n128_f32[0];
              v40 = v38.n128_f32[1];
              v41 = v38.n128_f32[2];
              v42 = v37;
              do
              {
                v43 = *v36++;
                objc_msgSend(v30, "transform");
                v48 = vaddq_f32(v47, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v44, v43.f32[0]), v45, *(float32x2_t *)v43.f32, 1), v46, v43, 2));
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("v %.03f %.03f %.03f %.03f %.03f %.03f %.03f\n"), v48.f32[0], v48.f32[1], v48.f32[2], *(_QWORD *)&v39, *(_QWORD *)&v40, *(_QWORD *)&v41, *(_QWORD *)&v28);
                v49 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v6, "appendString:", v49);

                --v42;
              }
              while (v42);
            }
            objc_msgSend(v6, "appendString:", CFSTR("\n"), v38.n128_f64[0]);
            v50 = objc_msgSend(v35, "triangleIndices");
            v51 = objc_msgSend(v35, "triangleCount");
            if (v51)
            {
              v52 = v51;
              v53 = (__int16 *)(v50 + 4);
              do
              {
                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("f %d %d %d\n"), (v27 + *(v53 - 2)), (v27 + *(v53 - 1)), (v27 + *v53));
                v54 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v6, "appendString:", v54);

                objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("f %d %d %d\n"), (v27 + *v53), (v27 + *(v53 - 1)), (v27 + *(v53 - 2)));
                v55 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v6, "appendString:", v55);

                v53 += 3;
                --v52;
              }
              while (v52);
            }
            v27 += v66;

            v29 = v65 + 1;
          }
          while (v65 + 1 != v64);
          v64 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v67, v76, 16);
        }
        while (v64);
      }

      objc_msgSend(v6, "appendString:", CFSTR("\n"));
      objc_msgSend(v6, "appendString:", CFSTR("# EOF\n"));
      v7 = v61;
      goto LABEL_33;
    }
  }
  else
  {

  }
  if (_ARLogGeneral_onceToken_27 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_27, &__block_literal_global_61);
  v56 = _ARLogGeneral_logObj_27;
  if (os_log_type_enabled((os_log_t)_ARLogGeneral_logObj_27, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B3A68000, v56, OS_LOG_TYPE_ERROR, "No mesh to save.", buf, 2u);
  }
  if (a2)
  {
    v57 = (void *)MEMORY[0x1E0CB35C8];
    v58 = *MEMORY[0x1E0CB28A8];
    v77 = *MEMORY[0x1E0CB2D50];
    v78 = CFSTR("There is no plane geometry mesh to save.");
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v78, &v77, 1);
    v59 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v57, "errorWithDomain:code:userInfo:", v58, -1, v59);
    *a2 = (id)objc_claimAutoreleasedReturnValue();

  }
LABEL_33:

  return v6;
}

void sub_1B3B1F3BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v19;

  _Unwind_Resume(a1);
}

void sub_1B3B1FBE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B20338(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B204B0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_12()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

double cva::assign<false,false,cva::Matrix<float,4u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(float32x4_t *a1, uint64_t a2)
{
  float32x4_t **v4;
  float32x4_t v5;
  uint64_t v6;
  float *v7;
  float32x4_t v8;
  float v9;
  float32x4_t v11[4];

  if (*(float32x4_t **)(a2 + 8) == a1)
  {
    v11[0] = 0uLL;
    cva::assign<false,false,cva::Matrix<float,4u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(v11, a2);
    v8.i64[0] = v11[0].i64[0];
    *a1 = v11[0];
  }
  else
  {
    v4 = *(float32x4_t ***)a2;
    memset(v11, 0, sizeof(v11));
    cva::assign<false,false,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>,cva::Matrix<float,4u,4u,false>>(v11, v4);
    v5 = 0uLL;
    v6 = 0;
    v7 = *(float **)(a2 + 8);
    do
    {
      v8 = v11[v6];
      v9 = *v7++;
      v5 = vmlaq_n_f32(v5, v8, v9);
      ++v6;
    }
    while (v6 != 4);
    *a1 = v5;
  }
  return *(double *)v8.i64;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t i;
  uint64_t v6;
  float v7;
  float *v8;
  float v9;
  uint64_t v10;
  int v11;

  v2 = result;
  v3 = *a2;
  if (*a2 == result || (v4 = (float *)a2[1], v4 == (float *)result))
  {
    v11 = 0;
    v10 = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>(&v10);
    *(_QWORD *)v2 = v10;
    *(_DWORD *)(v2 + 8) = v11;
  }
  else
  {
    for (i = 0; i != 3; ++i)
    {
      v6 = 0;
      v7 = 0.0;
      v8 = v4;
      do
      {
        v9 = *v8++;
        v7 = v7 + (float)(*(float *)(v3 + v6) * v9);
        v6 += 12;
      }
      while (v6 != 36);
      *(float *)(result + 4 * i) = v7;
      v3 += 4;
    }
  }
  return result;
}

void cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(uint64_t a1, uint64_t a2)
{
  _QWORD *v4;
  _OWORD *v5;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  float v9;
  float *v10;
  float v11;
  _OWORD v12[3];

  if (*(_QWORD *)(a2 + 8) == a1)
  {
    DWORD2(v12[0]) = 0;
    *(_QWORD *)&v12[0] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>,cva::Matrix<float,4u,1u,false>>(v12, a2);
    *(_QWORD *)a1 = *(_QWORD *)&v12[0];
    *(_DWORD *)(a1 + 8) = DWORD2(v12[0]);
  }
  else
  {
    v4 = *(_QWORD **)a2;
    memset(v12, 0, sizeof(v12));
    v5 = v12;
    cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(v12, v4);
    v6 = 0;
    v7 = *(float **)(a2 + 8);
    do
    {
      v8 = 0;
      v9 = 0.0;
      v10 = v7;
      do
      {
        v11 = *v10++;
        v9 = v9 + (float)(*(float *)((char *)v5 + v8) * v11);
        v8 += 12;
      }
      while (v8 != 48);
      *(float *)(a1 + 4 * v6++) = v9;
      v5 = (_OWORD *)((char *)v5 + 4);
    }
    while (v6 != 3);
  }
}

double cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(_OWORD *a1, _QWORD *a2)
{
  _OWORD *v3;
  _OWORD *v4;
  uint64_t i;
  uint64_t v6;
  _OWORD *v7;
  uint64_t v8;
  double result;
  float *v10;
  float v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v3 = (_OWORD *)*a2;
  if ((_OWORD *)*a2 == a1 || (v4 = (_OWORD *)a2[1], v4 == a1))
  {
    v14 = 0u;
    v15 = 0u;
    v13 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,4u,false>>(&v13);
    v12 = v14;
    *a1 = v13;
    a1[1] = v12;
    result = *(double *)&v15;
    a1[2] = v15;
  }
  else
  {
    for (i = 0; i != 4; ++i)
    {
      v6 = 0;
      v7 = v3;
      do
      {
        v8 = 0;
        LODWORD(result) = 0;
        v10 = (float *)&v4[i];
        do
        {
          v11 = *v10++;
          *(float *)&result = *(float *)&result + (float)(*(float *)((char *)v7 + v8) * v11);
          v8 += 12;
        }
        while (v8 != 48);
        *((_DWORD *)a1 + 3 * i + v6++) = LODWORD(result);
        v7 = (_OWORD *)((char *)v7 + 4);
      }
      while (v6 != 3);
    }
  }
  return result;
}

void sub_1B3B20A38(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1B3B20E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B3B216C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *__p,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,char a41)
{
  void *v41;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1B3B21A34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

id visitChildren(int a1, int a2, void *a3, void *a4, uint64_t a5, uint64_t a6, __n128 a7)
{
  void *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t i;
  void *v18;
  uint64_t v19;
  uint64_t j;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  uint64_t v28;
  void *v29;
  void *v30;
  void *v31;
  id v33;
  id v34;
  void *v35;
  uint64_t v36;
  id obj;
  int v38;
  id v40;
  __int128 v41;
  __int128 v42;
  __int128 v43;
  __int128 v44;
  __int128 v45;
  __int128 v46;
  __int128 v47;
  __int128 v48;
  _BYTE v49[128];
  _BYTE v50[128];
  uint64_t v51;

  v51 = *MEMORY[0x1E0C80C00];
  v40 = a3;
  v33 = a4;
  v12 = (void *)objc_opt_new();
  v38 = a1;
  objc_msgSend(&stru_1E6676798, "stringByPaddingToLength:withString:startingAtIndex:", a1, CFSTR("\t"), 0);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v35 = (void *)objc_opt_new();
  v47 = 0u;
  v48 = 0u;
  v45 = 0u;
  v46 = 0u;
  obj = v33;
  v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v45, v50, 16);
  if (v14)
  {
    v15 = 0;
    v16 = *(_QWORD *)v46;
    do
    {
      for (i = 0; i != v14; ++i)
      {
        if (*(_QWORD *)v46 != v16)
          objc_enumerationMutation(obj);
        if (objc_msgSend(*(id *)(*((_QWORD *)&v45 + 1) + 8 * i), "intValue") == a2)
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithInt:", v15 + i);
          v18 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v35, "addObject:", v18);

        }
      }
      v14 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v45, v50, 16);
      v15 = (v15 + i);
    }
    while (v14);
  }

  if (objc_msgSend(v35, "count"))
  {
    v43 = 0u;
    v44 = 0u;
    v41 = 0u;
    v42 = 0u;
    v34 = v35;
    v19 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
    if (v19)
    {
      v36 = *(_QWORD *)v42;
      do
      {
        for (j = 0; j != v19; ++j)
        {
          if (*(_QWORD *)v42 != v36)
            objc_enumerationMutation(v34);
          v21 = *(void **)(*((_QWORD *)&v41 + 1) + 8 * j);
          v22 = (void *)MEMORY[0x1E0CB3940];
          objc_msgSend(v40, "objectAtIndexedSubscript:", (int)objc_msgSend(v21, "intValue"));
          v23 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v22, "stringWithFormat:", CFSTR("%@JOINT %@\n"), v13, v23);
          v24 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v12, "appendString:", v24);

          objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@{\n"), v13);
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v12, "appendString:", v25);

          objc_msgSend(v12, "appendFormat:", CFSTR("\t%@OFFSET %f %f %f\n"), v13, (float)(*(float *)(a5 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48) * a7.n128_f32[0]), vmuls_lane_f32(a7.n128_f32[1], *(float32x2_t *)(a5 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48), 1), (float)(a7.n128_f32[2] * *(float *)(a5 + 8 + ((uint64_t)(int)objc_msgSend(v21, "intValue") << 6) + 48)));
          if (a6)
          {
            if (a6 != 1)
              goto LABEL_21;
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@CHANNELS 3 Xposition Yposition Zposition\n"), v13);
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "appendString:", v26);
          }
          else
          {
            objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@CHANNELS 3 Xrotation Yrotation Zrotation\n"), v13);
            v26 = (void *)objc_claimAutoreleasedReturnValue();
            objc_msgSend(v12, "appendString:", v26);
          }

LABEL_21:
          visitChildren((v38 + 1), objc_msgSend(v21, "intValue"), v40, obj, a5, a6, a7);
          v27 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v12, "appendString:", v27);
          objc_msgSend(v12, "appendFormat:", CFSTR("%@}\n"), v13);

        }
        v19 = objc_msgSend(v34, "countByEnumeratingWithState:objects:count:", &v41, v49, 16);
      }
      while (v19);
    }
  }
  else
  {
    objc_msgSend(&stru_1E6676798, "stringByPaddingToLength:withString:startingAtIndex:", v38 - 1, CFSTR("\t"), 0);
    v28 = objc_claimAutoreleasedReturnValue();

    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@End Site\n"), v28);
    v29 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "appendString:", v29);

    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@{\n"), v28);
    v30 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "appendString:", v30);

    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@\tOFFSET 0.0 0.0 0.0\n"), v28);
    v31 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "appendString:", v31);

    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("\t%@}\n"), v28);
    v34 = (id)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v12, "appendString:");
    v13 = (void *)v28;
  }

  return v12;
}

void sub_1B3B22004(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  void *v26;
  void *v27;

  _Unwind_Resume(a1);
}

void sub_1B3B223BC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B226E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_13()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

id _ARLogGeneral_23()
{
  if (_ARLogGeneral_onceToken_28 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_28, &__block_literal_global_64);
  return (id)_ARLogGeneral_logObj_28;
}

void sub_1B3B24748(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, ...)
{
  uint64_t v11;
  va_list va;
  uint64_t v13;
  void (*v14)(uint64_t *);
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  va_list va1;

  va_start(va1, a10);
  va_start(va, a10);
  v11 = va_arg(va1, _QWORD);
  v13 = va_arg(va1, _QWORD);
  v14 = va_arg(va1, void (*)(uint64_t *));
  v15 = va_arg(va1, _QWORD);
  v16 = va_arg(va1, _QWORD);
  v17 = va_arg(va1, _QWORD);
  v14((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

const __CFString *NSStringFromARAltitudeSource(unint64_t a1)
{
  if (a1 > 3)
    return CFSTR("???");
  else
    return off_1E6674708[a1];
}

id _ARLogTechnique_8()
{
  if (_ARLogTechnique_onceToken_12 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_12, &__block_literal_global_66);
  return (id)_ARLogTechnique_logObj_12;
}

id _ARLogSensor_5()
{
  if (_ARLogSensor_onceToken_9 != -1)
    dispatch_once(&_ARLogSensor_onceToken_9, &__block_literal_global_210);
  return (id)_ARLogSensor_logObj_9;
}

id _ARLogGeneral_24()
{
  if (_ARLogGeneral_onceToken_29 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_29, &__block_literal_global_254);
  return (id)_ARLogGeneral_logObj_29;
}

void sub_1B3B28544(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B28698(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B28FCC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ARTexturedPlane::~ARTexturedPlane(ARTexturedPlane *this)
{

  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&this[3].var4, (_QWORD *)this[3].var4.__tree_.__pair1_.__value_.__left_);
}

uint64_t std::set<std::array<unsigned char,16ul>>::set[abi:ne180100](uint64_t a1, uint64_t a2)
{
  *(_QWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 8) = 0;
  *(_QWORD *)a1 = a1 + 8;
  std::set<std::array<unsigned char,16ul>>::insert[abi:ne180100]<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>((char *)a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1B3B29140(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *std::set<std::array<unsigned char,16ul>>::insert[abi:ne180100]<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>(char *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 8;
    do
    {
      result = std::__tree<std::array<unsigned char,16ul>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul> const&>(v5, v6, (uint64_t)v4 + 25, (_QWORD *)((char *)v4 + 25));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul> const&>(uint64_t **a1, _QWORD *a2, uint64_t a3, _OWORD *a4)
{
  void **v6;
  char *v7;
  uint64_t **v8;
  uint64_t v10;
  uint64_t v11;

  v6 = (void **)std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(a1, a2, &v11, &v10, a3);
  v7 = (char *)*v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v7 + 25) = *a4;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;

  if (a1 + 1 != a2)
  {
    v5 = 0;
    while (1)
    {
      v6 = *(unsigned __int8 *)(a5 + v5);
      v7 = *((unsigned __int8 *)a2 + v5 + 25);
      if (v6 < v7)
        break;
      v8 = v7 < v6 || v5++ == 15;
      if (v8)
      {
        v9 = 0;
        while (1)
        {
          v10 = *((unsigned __int8 *)a2 + v9 + 25);
          v11 = *(unsigned __int8 *)(a5 + v9);
          if (v10 < v11)
            break;
          if (v11 < v10 || v9++ == 15)
          {
            *a3 = a2;
            *a4 = a2;
            return a4;
          }
        }
        v22 = a2[1];
        if (v22)
        {
          v23 = (_QWORD *)a2[1];
          do
          {
            a4 = v23;
            v23 = (_QWORD *)*v23;
          }
          while (v23);
        }
        else
        {
          v24 = a2;
          do
          {
            a4 = (_QWORD *)v24[2];
            v8 = *a4 == (_QWORD)v24;
            v24 = a4;
          }
          while (!v8);
        }
        if (a4 != a1 + 1)
        {
          v25 = 0;
          while (1)
          {
            v26 = *(unsigned __int8 *)(a5 + v25);
            v27 = *((unsigned __int8 *)a4 + v25 + 25);
            if (v26 < v27)
              break;
            if (v27 < v26 || v25++ == 15)
              return std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
          }
        }
        if (v22)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
    }
  }
  v13 = *a2;
  if ((_QWORD *)*a1 == a2)
  {
    v15 = a2;
  }
  else
  {
    if (v13)
    {
      v14 = (_QWORD *)*a2;
      do
      {
        v15 = v14;
        v14 = (_QWORD *)v14[1];
      }
      while (v14);
    }
    else
    {
      v16 = a2;
      do
      {
        v15 = (_QWORD *)v16[2];
        v8 = *v15 == (_QWORD)v16;
        v16 = v15;
      }
      while (v8);
    }
    v17 = 0;
    while (1)
    {
      v18 = *((unsigned __int8 *)v15 + v17 + 25);
      v19 = *(unsigned __int8 *)(a5 + v17);
      if (v18 < v19)
        break;
      if (v19 < v18 || v17++ == 15)
        return std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
    }
  }
  if (v13)
  {
    *a3 = v15;
    return v15 + 1;
  }
  else
  {
    *a3 = a2;
    return a2;
  }
}

_QWORD *std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
LABEL_2:
    while (2)
    {
      v6 = 0;
      v7 = v4;
      do
      {
        v8 = *(unsigned __int8 *)(a3 + v6);
        v9 = *((unsigned __int8 *)v7 + v6 + 25);
        if (v8 < v9)
        {
          v4 = (_QWORD *)*v7;
          result = v7;
          if (*v7)
            goto LABEL_2;
          goto LABEL_22;
        }
      }
      while (v9 >= v8 && v6++ != 15);
      v11 = 0;
      while (1)
      {
        v12 = *((unsigned __int8 *)v7 + v11 + 25);
        v13 = *(unsigned __int8 *)(a3 + v11);
        if (v12 < v13)
          break;
        if (v13 < v12 || v11++ == 15)
          goto LABEL_22;
      }
      result = v7 + 1;
      v4 = (_QWORD *)v7[1];
      if (v4)
        continue;
      break;
    }
  }
  else
  {
    v7 = result;
  }
LABEL_22:
  *a2 = v7;
  return result;
}

void sub_1B3B29798(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v3;
  va_list va;
  uint64_t v5;
  void (*v6)(uint64_t *);
  uint64_t v7;
  uint64_t v8;
  va_list va1;

  va_start(va1, a2);
  va_start(va, a2);
  v3 = va_arg(va1, _QWORD);
  v5 = va_arg(va1, _QWORD);
  v6 = va_arg(va1, void (*)(uint64_t *));
  v7 = va_arg(va1, _QWORD);
  v8 = va_arg(va1, _QWORD);
  v6((uint64_t *)va);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_25()
{
  if (_ARLogGeneral_onceToken_30 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_30, &__block_literal_global_68);
  return (id)_ARLogGeneral_logObj_30;
}

uint64_t ARPowerUsageForThermalState(uint64_t a1)
{
  if (a1 == 3)
    return 2;
  else
    return a1 == 2;
}

uint64_t ARPowerUsageForPowerPressureLevel(int a1)
{
  uint64_t v1;

  v1 = a1 == 20;
  if (a1 == 30)
    v1 = 2;
  if (a1 == 40)
    return 2;
  else
    return v1;
}

id _ARLogSession_0()
{
  if (_ARLogSession_onceToken_1 != -1)
    dispatch_once(&_ARLogSession_onceToken_1, &__block_literal_global_790);
  return (id)_ARLogSession_logObj_1;
}

void sub_1B3B2A314(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  id *v20;
  id *v21;

  objc_destroyWeak(v21);
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B2ABF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

id ARSessionRunOptionsToString(char a1)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  const __CFString *v8;

  v2 = (void *)objc_opt_new();
  v3 = v2;
  if ((a1 & 1) != 0)
  {
    v8 = CFSTR("ResetTracking");
  }
  else
  {
    if ((a1 & 2) == 0)
    {
      if ((a1 & 4) == 0)
        goto LABEL_4;
LABEL_10:
      objc_msgSend(v3, "addObject:", CFSTR("StopTrackedRaycasts"));
      if ((a1 & 8) == 0)
        goto LABEL_6;
      goto LABEL_5;
    }
    v8 = CFSTR("RemoveExistingAnchors");
  }
  objc_msgSend(v2, "addObject:", v8);
  if ((a1 & 4) != 0)
    goto LABEL_10;
LABEL_4:
  if ((a1 & 8) != 0)
LABEL_5:
    objc_msgSend(v3, "addObject:", CFSTR("ResetSceneReconstruction"));
LABEL_6:
  v4 = (void *)MEMORY[0x1E0CB3940];
  objc_msgSend(v3, "componentsJoinedByString:", CFSTR(" | "));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringWithFormat:", CFSTR("(%@)"), v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

void sub_1B3B2B368(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B2D1AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B2D344(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3B2D4A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, os_activity_scope_state_s a9)
{
  os_activity_scope_leave(&a9);
  _Unwind_Resume(a1);
}

void sub_1B3B2DB04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B33CFC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_26()
{
  if (_ARLogGeneral_onceToken_31 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_31, &__block_literal_global_793);
  return (id)_ARLogGeneral_logObj_31;
}

void sub_1B3B39430(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__3(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__3(uint64_t a1)
{

}

void sub_1B3B39BE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B3A240(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B3A648(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,os_activity_scope_state_s state)
{
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B3AF64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3B968(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3BE94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3C510(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 128));
  _Unwind_Resume(a1);
}

void sub_1B3B3CA30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,os_activity_scope_state_s state)
{
  uint64_t v25;

  objc_destroyWeak((id *)(v25 - 144));
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B3CDAC(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 128));
  _Unwind_Resume(a1);
}

void sub_1B3B3D0B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,os_activity_scope_state_s state)
{
  objc_destroyWeak(&location);
  os_activity_scope_leave(&state);
  _Unwind_Resume(a1);
}

void sub_1B3B3D3A8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3D674(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3DB54(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id location, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43)
{
  uint64_t v43;

  objc_destroyWeak(&location);
  objc_destroyWeak(a10);
  _Block_object_dispose(&a43, 8);
  objc_destroyWeak((id *)(v43 - 256));
  _Unwind_Resume(a1);
}

void sub_1B3B3E028(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B3E3D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  objc_destroyWeak((id *)(v1 - 144));
  _Unwind_Resume(a1);
}

void sub_1B3B3E6C0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

CFStringRef NSStringFromCFUUIDRef(CFUUIDRef uuid)
{
  return (id)CFUUIDCreateString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], uuid);
}

id _ARLogGeneral_27()
{
  if (_ARLogGeneral_onceToken_32 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_32, &__block_literal_global_194);
  return (id)_ARLogGeneral_logObj_32;
}

id _ARLogSensor_6()
{
  if (_ARLogSensor_onceToken_11 != -1)
    dispatch_once(&_ARLogSensor_onceToken_11, &__block_literal_global_197_0);
  return (id)_ARLogSensor_logObj_11;
}

id _ARLogGeneral_28()
{
  if (_ARLogGeneral_onceToken_33 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_33, &__block_literal_global_259);
  return (id)_ARLogGeneral_logObj_33;
}

void sub_1B3B43AA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B449D0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, id location)
{
  id *v16;

  objc_destroyWeak(v16);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B44F14(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogTechnique_9()
{
  if (_ARLogTechnique_onceToken_13 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_13, &__block_literal_global_73);
  return (id)_ARLogTechnique_logObj_13;
}

void sub_1B3B46D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,void (*a44)(char *))
{
  a44(&a42);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_29()
{
  if (_ARLogGeneral_onceToken_34 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_34, &__block_literal_global_74);
  return (id)_ARLogGeneral_logObj_34;
}

uint64_t _archive_open_callback(uint64_t a1, uint64_t a2)
{
  if (a2)
    return 0;
  archive_set_error();
  return 4294967266;
}

uint64_t _archive_write_callback(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  objc_msgSend(a2, "appendBytes:length:");
  return a4;
}

uint64_t _archive_close_callback()
{
  return 0;
}

id ARLocationSensorDidOutputSensorDataClassApprovedList()
{
  if (ARLocationSensorDidOutputSensorDataClassApprovedList_onceToken != -1)
    dispatch_once(&ARLocationSensorDidOutputSensorDataClassApprovedList_onceToken, &__block_literal_global_75);
  return (id)ARLocationSensorDidOutputSensorDataClassApprovedList_locationSensorDidOutputSensorDataClassApprovedList;
}

id ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList()
{
  if (ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_onceToken != -1)
    dispatch_once(&ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_onceToken, &__block_literal_global_4_0);
  return (id)ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList_locationSensorUpdateEstimationFromVIOPoseClassApprovedList;
}

id ARRemoteLocationSensorClientInterface()
{
  void *v0;
  void *v1;

  ARRemoteSensorClientInterfaceWithProtocol((uint64_t)&unk_1EF0AB488);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  ARLocationSensorDidOutputSensorDataClassApprovedList();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_sensorDidOutputSensorData_, 0, 0);

  return v0;
}

id ARRemoteLocationSensorServiceInterface()
{
  void *v0;
  void *v1;

  ARRemoteSensorServiceInterfaceWithProtocol((uint64_t)&unk_1EF0AB4E8);
  v0 = (void *)objc_claimAutoreleasedReturnValue();
  ARLocationSensorUpdateEstimationFromVIOPoseClassApprovedList();
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v0, "setClasses:forSelector:argumentIndex:ofReply:", v1, sel_updateEstimationFromVIOPose_imageData_, 1, 0);

  return v0;
}

id _ARLogSensor_7()
{
  if (_ARLogSensor_onceToken_12 != -1)
    dispatch_once(&_ARLogSensor_onceToken_12, &__block_literal_global_112);
  return (id)_ARLogSensor_logObj_12;
}

void sub_1B3B4E290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__4(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__4(uint64_t a1)
{

}

void sub_1B3B4E9A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4E9F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4EA4C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id _ARLogSession(void)
{
  if (_ARLogSession(void)::onceToken != -1)
    dispatch_once(&_ARLogSession(void)::onceToken, &__block_literal_global_76);
  return (id)_ARLogSession(void)::logObj;
}

void sub_1B3B4EDE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::_CV3DODTCreateWithOptionsConfigAndModel(_anonymous_namespace_ *this, CV3DODTContext **a2, const __CFDictionary *a3, CV3DMLModel *a4)
{
  uint64_t v4;

  CV3DODTConfigCreate();
  v4 = CV3DODTCreateWithOptionsConfigAndModel();
  CV3DODTConfigRelease();
  return v4;
}

void sub_1B3B4F0A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B4F210(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B4F598(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B4F6B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4F718(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4F778(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4F7D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B4FBF0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B50088(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B50244(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B50490(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B50780(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B50974(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)ARODTHandleManager;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B50BCC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B50C68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B50E5C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B50EE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B51044(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogSessionv_block_invoke()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Session");
  v1 = (void *)_ARLogSession(void)::logObj;
  _ARLogSession(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke_5()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

const __CFString *ARMLDepthDataSourceDescription(uint64_t a1)
{
  const __CFString *v1;

  v1 = CFSTR("Unknown");
  if (a1 == 1)
    v1 = CFSTR("Estimated Depth");
  if (a1 == 2)
    return CFSTR("Apple Depth");
  else
    return v1;
}

void sub_1B3B515FC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B51798(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B51C28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B51D50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B51FFC(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100](v2 - 96);

  _Unwind_Resume(a1);
}

void sub_1B3B52330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *__p,uint64_t a26)
{
  uint64_t v26;

  MEMORY[0x1B5E2D5B8](v26, 0x1020C405A8B1BAELL);
  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void std::vector<arkit::Landmark>::reserve(char **a1, unint64_t a2)
{
  uint64_t v3;
  char *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xAAAAAAAAAAAAAAABLL * ((v4 - *a1) >> 2) < a2)
  {
    if (a2 >= 0x1555555555555556)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(v3, a2);
    v7 = &v6[v5];
    v9 = &v6[12 * v8];
    v11 = *a1;
    v10 = a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *(_QWORD *)(v10 - 12);
        v10 -= 12;
        *(_QWORD *)(v12 - 12) = v13;
        v12 -= 12;
        v12[8] = v10[8];
      }
      while (v10 != v11);
      v10 = *a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

_QWORD *std::shared_ptr<arkit::FaceTrackingData>::shared_ptr[abi:ne180100]<arkit::FaceTrackingData,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E6670650;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B3B525B0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  uint64_t v10;

  a10 = 0;
  if (v10)
    std::default_delete<arkit::FaceTrackingData>::operator()[abi:ne180100]((uint64_t)&a10, v10);
  _Unwind_Resume(exception_object);
}

void std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

void std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::__on_zero_shared(uint64_t a1)
{
  std::default_delete<arkit::FaceTrackingData>::operator()[abi:ne180100](a1 + 24, *(_QWORD *)(a1 + 24));
}

uint64_t std::__shared_ptr_pointer<arkit::FaceTrackingData *,std::shared_ptr<arkit::FaceTrackingData>::__shared_ptr_default_delete<arkit::FaceTrackingData,arkit::FaceTrackingData>,std::allocator<arkit::FaceTrackingData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

void std::default_delete<arkit::FaceTrackingData>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  if (a2)
  {
    v2 = *(void **)(a2 + 40);
    if (v2)
    {
      *(_QWORD *)(a2 + 48) = v2;
      operator delete(v2);
    }
    JUMPOUT(0x1B5E2D5B8);
  }
}

BOOL std::type_info::operator==[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(a1 + 8);
  v3 = *(_QWORD *)(a2 + 8);
  if (v2 == v3)
    return 1;
  if ((v3 & v2) < 0 != __OFSUB__(v2, v3))
    return strcmp((const char *)(v2 & 0x7FFFFFFFFFFFFFFFLL), (const char *)(v3 & 0x7FFFFFFFFFFFFFFFLL)) == 0;
  return 0;
}

id _ARLogGeneral_30()
{
  if (_ARLogGeneral_onceToken_35 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_35, &__block_literal_global_183_0);
  return (id)_ARLogGeneral_logObj_35;
}

void sub_1B3B551B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B5530C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, objc_super a9)
{
  void *v9;

  a9.super_class = (Class)ARPlaneEstimationTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B55424(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B55514(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3B555E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3B5576C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3B55924(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B55A08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B55B34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B55FB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,char a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,uint64_t a60,uint64_t a61,uint64_t a62,uint64_t a63)
{
  void *__p;
  uint64_t a69;
  void *v69;
  void *v70;
  uint64_t v71;
  void *v73;

  ((void (*)(char *))a44)(&a42);
  if (__p)
  {
    a69 = (uint64_t)__p;
    operator delete(__p);
  }
  v73 = *(void **)(v71 - 208);
  if (v73)
  {
    *(_QWORD *)(v71 - 200) = v73;
    operator delete(v73);
  }

  _Unwind_Resume(a1);
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void ___ZL15_ARLogTechniquev_block_invoke_6()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

_QWORD *std::vector<CV3DSurfaceDetectionPoint3D>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B3B56228(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t *std::back_insert_iterator<std::vector<double>>::operator=[abi:ne180100](uint64_t *a1, _QWORD *a2)
{
  uint64_t v4;
  _QWORD *v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  uint64_t v16;

  v4 = *a1;
  v5 = *(_QWORD **)(*a1 + 8);
  v6 = (_QWORD *)(*a1 + 16);
  if ((unint64_t)v5 >= *v6)
  {
    v8 = *(_QWORD **)v4;
    v9 = ((uint64_t)v5 - *(_QWORD *)v4) >> 3;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = *v6 - (_QWORD)v8;
    if (v11 >> 2 > v10)
      v10 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)v6, v12);
      v8 = *(_QWORD **)v4;
      v5 = *(_QWORD **)(v4 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[8 * v9];
    v15 = &v13[8 * v12];
    *(_QWORD *)v14 = *a2;
    v7 = v14 + 8;
    while (v5 != v8)
    {
      v16 = *--v5;
      *((_QWORD *)v14 - 1) = v16;
      v14 -= 8;
    }
    *(_QWORD *)v4 = v14;
    *(_QWORD *)(v4 + 8) = v7;
    *(_QWORD *)(v4 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v5 = *a2;
    v7 = v5 + 1;
  }
  *(_QWORD *)(v4 + 8) = v7;
  return a1;
}

void sub_1B3B56404(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B5671C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B56A48(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  void *v8;
  void *v9;

  v8 = *(void **)(v6 - 216);
  if (v8)
  {
    *(_QWORD *)(v6 - 208) = v8;
    operator delete(v8);
  }
  v9 = *(void **)(v6 - 192);
  if (v9)
  {
    *(_QWORD *)(v6 - 184) = v9;
    operator delete(v9);
  }

  _Unwind_Resume(a1);
}

void std::vector<CV3DHitTestPoint3D>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<CV3DHitTestPoint3D>::__append((char **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 12 * a2;
  }
}

void std::vector<CV3DHitTestCovariance3D>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0x8E38E38E38E38E39 * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 2);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<CV3DHitTestCovariance3D>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 36 * a2;
  }
}

_QWORD *std::vector<CV3DHitTestPoint3D>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B3B56BF0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<CV3DHitTestCovariance3D>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<CV3DHitTestCovariance3D>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_1B3B56C90(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<CV3DHitTestCovariance3D>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x71C71C71C71C71DLL)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[36 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x71C71C71C71C71DLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(36 * a2);
}

void std::vector<CV3DHitTestPoint3D>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  int v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 12 * ((12 * a2 - 12) / 0xC) + 12;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x1555555555555555)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xAAAAAAAAAAAAAAALL)
      v11 = 0x1555555555555555;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[12 * v8];
    v15 = &v12[12 * v11];
    v16 = 12 * ((12 * a2 - 12) / 0xC) + 12;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = *a1;
    v18 = a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_QWORD *)(v18 - 12);
        v18 -= 12;
        v21 = *((_DWORD *)v18 + 2);
        *(_QWORD *)(v14 - 12) = v20;
        v14 -= 12;
        *((_DWORD *)v14 + 2) = v21;
      }
      while (v18 != v19);
      v18 = *a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void std::vector<CV3DHitTestCovariance3D>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0x8E38E38E38E38E39 * ((v6 - v7) >> 2) >= a2)
  {
    if (a2)
    {
      v13 = 36 * ((36 * a2 - 36) / 0x24) + 36;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0x8E38E38E38E38E39 * ((v7 - (_BYTE *)*a1) >> 2);
    v9 = v8 + a2;
    if (v8 + a2 > 0x71C71C71C71C71CLL)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0x8E38E38E38E38E39 * ((v5 - (_BYTE *)*a1) >> 2);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x38E38E38E38E38ELL)
      v11 = 0x71C71C71C71C71CLL;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<CV3DHitTestCovariance3D>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[36 * v8];
    v15 = &v12[36 * v11];
    v16 = 36 * ((36 * a2 - 36) / 0x24) + 36;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 36);
        v21 = *(_OWORD *)(v18 - 20);
        *((_DWORD *)v14 - 1) = *((_DWORD *)v18 - 1);
        *(_OWORD *)(v14 - 20) = v21;
        *(_OWORD *)(v14 - 36) = v20;
        v14 -= 36;
        v18 -= 36;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void sub_1B3B57114(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B57504(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_1B3B57998(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3B57B28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_14()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke_7()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

uint64_t ARRemoteSensorClientInterfaceWithProtocol(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", a1);
}

uint64_t ARRemoteSensorServiceInterfaceWithProtocol(uint64_t a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3B50], "interfaceWithProtocol:", a1);
}

id _ARLogSensor_8()
{
  if (_ARLogSensor_onceToken_13 != -1)
    dispatch_once(&_ARLogSensor_onceToken_13, &__block_literal_global_81);
  return (id)_ARLogSensor_logObj_13;
}

void sub_1B3B581B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

id _ARLogGeneral_31()
{
  if (_ARLogGeneral_onceToken_36 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_36, &__block_literal_global_82);
  return (id)_ARLogGeneral_logObj_36;
}

id _ARLogTechnique_10()
{
  if (_ARLogTechnique_onceToken_16 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_16, &__block_literal_global_74_0);
  return (id)_ARLogTechnique_logObj_16;
}

void sub_1B3B5BB7C(_Unwind_Exception *a1)
{
  kdebug_trace();
  _Unwind_Resume(a1);
}

void AppClipCodeUpdateCallbackHandler(void *a1, double a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8)
{
  id *v11;
  NSObject *v12;
  uint64_t NumberOfTrackingData;
  void *v14;
  double v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  NSObject *v21;
  uint64_t Id;
  uint64_t v23;
  void *v24;
  NSObject *v25;
  int v26;
  NSObject *v27;
  int v28;
  uint64_t v29;
  uint64_t IsScaleReliable;
  double v31;
  double v32;
  uint64_t v33;
  double v34;
  double v35;
  double v36;
  NSObject *v37;
  NSObject *v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int DataVersion;
  uint64_t v42;
  void *v43;
  void *v44;
  void *v45;
  _BOOL4 v46;
  void *v47;
  void *v48;
  id v49;
  void *v50;
  void *v51;
  id v52;
  unsigned int v53;
  uint64_t v54;
  double obj;
  id obja;
  void *objb;
  id objc;
  double v59;
  void *v60;
  double log;
  NSObject *loga;
  NSObject *logb;
  double theData;
  void *theDataa;
  _QWORD v66[4];
  id *v67;
  id v68;
  NSObject *v69;
  _BYTE *v70;
  double v71;
  double v72;
  NSObject *v73;
  void *v74;
  uint8_t v75[4];
  double v76;
  __int16 v77;
  double v78;
  __int16 v79;
  NSObject *v80;
  _BYTE buf[24];
  uint64_t v82;
  uint64_t v83;

  v83 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  v11 = a1;
  if (!a8)
  {
    *(double *)&v73 = 0.0;
    NumberOfTrackingData = AppC3DTrackingResultGetNumberOfTrackingData();
    kdebug_trace();
    *(_QWORD *)buf = 0;
    *(_QWORD *)&buf[8] = buf;
    *(_QWORD *)&buf[16] = 0x2020000000;
    v82 = 0;
    v14 = (void *)objc_msgSend(objc_alloc(MEMORY[0x1E0C99E08]), "initWithCapacity:", NumberOfTrackingData);
    if (!NumberOfTrackingData)
    {
LABEL_61:
      v50 = (void *)objc_opt_new();
      objc_msgSend(v50, "setTrackedAppClipCodes:", v14);
      v74 = v50;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", &v74, 1);
      v51 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v11, "pushResultData:forTimestamp:", v51, a2);

      objc_msgSend(v14, "count");
      kdebug_trace();

      _Block_object_dispose(buf, 8);
      goto LABEL_62;
    }
    v15 = 0.0;
    while (1)
    {
      *(double *)&v73 = 0.0;
      AppC3DTrackingResultCopyTransform();
      log = v17;
      theData = v16;
      obj = v19;
      v59 = v18;
      v20 = *(double *)&v73;
      if (*(double *)&v73 == 0.0)
      {
        Id = AppC3DTrackingResultGetId();
        v20 = *(double *)&v73;
        if (*(double *)&v73 == 0.0)
        {
          objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedLong:", Id);
          v20 = COERCE_DOUBLE(objc_claimAutoreleasedReturnValue());
          objc_msgSend(v14, "objectForKey:", *(_QWORD *)&v20);
          v24 = (void *)objc_claimAutoreleasedReturnValue();

          if (v24)
          {
            _ARLogTechnique_10();
            v25 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v75 = 138412546;
              v76 = v20;
              v77 = 2048;
              v78 = a2;
              _os_log_impl(&dword_1B3A68000, v25, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Duplicate instance ID %@ detected at time %F", v75, 0x16u);
            }
            goto LABEL_35;
          }
          AppC3DTrackingResultGetConfidence();
          v25 = v73;
          if (*(double *)&v73 != 0.0)
          {
            _ARLogTechnique_10();
            v27 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v75 = 134218498;
              v76 = a2;
              v77 = 2048;
              v78 = v15;
              v79 = 2112;
              v80 = v25;
              _os_log_impl(&dword_1B3A68000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not retrieve confidence at time %F index:%lu Error: %@", v75, 0x20u);
            }
            goto LABEL_34;
          }
          v28 = v26;
          if (+[ARAppClipCodeTechnique shouldRunCameraOrScannerPerformanceTestingMode](ARAppClipCodeTechnique, "shouldRunCameraOrScannerPerformanceTestingMode"))
          {
            v29 = 1;
            goto LABEL_31;
          }
          IsScaleReliable = AppC3DTrackingResultIsScaleReliable();
          v25 = v73;
          if (*(double *)&v73 != 0.0)
          {
            _ARLogTechnique_10();
            v27 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v75 = 134218498;
              v76 = a2;
              v77 = 2048;
              v78 = v15;
              v79 = 2112;
              v80 = v25;
              _os_log_impl(&dword_1B3A68000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not determine scale reliability at time %F index:%lu Error: %@", v75, 0x20u);
            }
LABEL_34:

            v33 = -[NSObject code](v25, "code");
            *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v33;
LABEL_35:

            goto LABEL_15;
          }
          v29 = IsScaleReliable;
LABEL_31:
          AppC3DTrackingResultGetSize();
          v25 = v73;
          if (*(double *)&v73 != 0.0)
          {
            _ARLogTechnique_10();
            v27 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)v75 = 134218498;
              v76 = a2;
              v77 = 2048;
              v78 = v15;
              v79 = 2112;
              v80 = v25;
              _os_log_impl(&dword_1B3A68000, v27, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not retrieve size at time %F index:%lu Error: %@", v75, 0x20u);
            }
            goto LABEL_34;
          }
          v34 = v31;
          v35 = v32;
          v25 = objc_opt_new();
          -[NSObject setCodeToWorldVisionTransform:](v25, "setCodeToWorldVisionTransform:", theData, log, v59, obj);
          -[NSObject setSize:](v25, "setSize:", v34, v35);
          LODWORD(v36) = v28;
          -[NSObject setConfidence:](v25, "setConfidence:", v36);
          -[NSObject setIsScaleReliable:](v25, "setIsScaleReliable:", v29);
          -[NSObject setUrlDecodingStateInternal:](v25, "setUrlDecodingStateInternal:", 0);
          objc_msgSend(v14, "setObject:forKey:", v25, *(_QWORD *)&v20);
          theDataa = (void *)AppC3DTrackingResultCreateData();
          v37 = v73;
          if (*(double *)&v73 == 0.0 && theDataa)
          {
            if (CFDataGetLength((CFDataRef)theDataa))
            {
              AppC3DTrackingResultGetMetadata();
              loga = v73;
              if (*(double *)&v73 != 0.0)
              {
                _ARLogTechnique_10();
                v38 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v75 = 134218498;
                  v76 = a2;
                  v77 = 2048;
                  v78 = v15;
                  v79 = 2112;
                  v80 = loga;
                  _os_log_impl(&dword_1B3A68000, v38, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not access result metadata at time %F index:%lu Error: %@", v75, 0x20u);
                }
                goto LABEL_42;
              }
              DataVersion = AppC3DTrackingResultGetDataVersion();
              loga = v73;
              if (*(double *)&v73 == 0.0)
              {
                v42 = DataVersion;
                -[NSObject setUrlEncodingVersion:](v25, "setUrlEncodingVersion:", DataVersion);
                v54 = v42;
                objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithLong:", v42);
                loga = objc_claimAutoreleasedReturnValue();
                obja = v11[13];
                objc_sync_enter(obja);
                objc_msgSend(v11[13], "objectForKeyedSubscript:", theDataa);
                v43 = (void *)objc_claimAutoreleasedReturnValue();
                objc_msgSend(v43, "objectForKeyedSubscript:", loga);
                v60 = (void *)objc_claimAutoreleasedReturnValue();

                objc_sync_exit(obja);
                if (v60)
                {
                  objc_msgSend(v60, "url");
                  v44 = (void *)objc_claimAutoreleasedReturnValue();
                  -[NSObject setUrl:](v25, "setUrl:", v44);

                  -[NSObject setUrlDecodingStateInternal:](v25, "setUrlDecodingStateInternal:", objc_msgSend(v60, "urlDecodingStateInternal"));
                }
                else
                {
                  v52 = v11[13];
                  objc_sync_enter(v52);
                  objc_msgSend(v11[13], "objectForKeyedSubscript:", theDataa);
                  v45 = (void *)objc_claimAutoreleasedReturnValue();
                  v46 = v45 == 0;

                  if (v46)
                  {
                    v47 = (void *)objc_opt_new();
                    objc_msgSend(v11[13], "setObject:forKeyedSubscript:", v47, theDataa);

                  }
                  objb = (void *)objc_opt_new();
                  objc_msgSend(objb, "setUrlDecodingStateInternal:", 2);
                  objc_msgSend(v11[13], "objectForKeyedSubscript:", theDataa);
                  v48 = (void *)objc_claimAutoreleasedReturnValue();
                  objc_msgSend(v48, "setObject:forKeyedSubscript:", objb, loga);

                  objc_sync_exit(v52);
                  objc = v11[14];
                  v53 = objc_msgSend(v11, "ignoreURLLimitation") ^ 1;
                  v66[0] = MEMORY[0x1E0C809B0];
                  v66[1] = 3221225472;
                  v66[2] = __AppClipCodeUpdateCallbackHandler_block_invoke;
                  v66[3] = &unk_1E6674F60;
                  v71 = a2;
                  v72 = v15;
                  v70 = buf;
                  v67 = v11;
                  v49 = theDataa;
                  v68 = v49;
                  v69 = loga;
                  objc_msgSend(objc, "decodeURLWithEncodedData:codingVersion:requiresAuthorization:completionHandler:", v49, v54, v53, v66);

                }
              }
              else
              {
                _ARLogTechnique_10();
                v38 = objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled(v38, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)v75 = 134218498;
                  v76 = a2;
                  v77 = 2048;
                  v78 = v15;
                  v79 = 2112;
                  v80 = loga;
                  _os_log_impl(&dword_1B3A68000, v38, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not get URL coding version from result metadata at time %F index:%lu Error: %@", v75, 0x20u);
                }
LABEL_42:

                v39 = -[NSObject code](loga, "code");
                *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v39;
                -[NSObject setUrlDecodingStateInternal:](v25, "setUrlDecodingStateInternal:", 1);
              }

              goto LABEL_35;
            }
            v37 = v73;
          }
          if (v37)
          {
            _ARLogTechnique_10();
            logb = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(logb, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)v75 = 134218498;
              v76 = a2;
              v77 = 2048;
              v78 = v15;
              v79 = 2112;
              v80 = v37;
              _os_log_impl(&dword_1B3A68000, logb, OS_LOG_TYPE_INFO, "ARAppClipCodeTechnique: Could not create decoded data at time %F index:%lu Error: %@", v75, 0x20u);
            }

            v40 = -[NSObject code](v37, "code");
            *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v40;

          }
          if (theDataa)
            CFRelease(theDataa);
          goto LABEL_35;
        }
        _ARLogTechnique_10();
        v21 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v75 = 134218498;
          v76 = a2;
          v77 = 2048;
          v78 = v15;
          v79 = 2112;
          v80 = *(NSObject **)&v20;
          _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not get id at time %F index:%lu Error: %@", v75, 0x20u);
        }
      }
      else
      {
        _ARLogTechnique_10();
        v21 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)v75 = 134218498;
          v76 = a2;
          v77 = 2048;
          v78 = v15;
          v79 = 2112;
          v80 = *(NSObject **)&v20;
          _os_log_impl(&dword_1B3A68000, v21, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Could not copy tranform at time %F index:%lu Error: %@", v75, 0x20u);
        }
      }

      v23 = objc_msgSend(*(id *)&v20, "code");
      *(_QWORD *)(*(_QWORD *)&buf[8] + 24) = v23;
LABEL_15:

      if (NumberOfTrackingData == ++*(_QWORD *)&v15)
        goto LABEL_61;
    }
  }
  _ARLogTechnique_10();
  v12 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 134218242;
    *(double *)&buf[4] = a2;
    *(_WORD *)&buf[12] = 2112;
    *(_QWORD *)&buf[14] = a8;
    _os_log_impl(&dword_1B3A68000, v12, OS_LOG_TYPE_ERROR, "ARAppClipCodeTechnique: Error during app clip code tracking at time %F, Error: %@", buf, 0x16u);
  }

  objc_msgSend(v11, "pushResultData:forTimestamp:", MEMORY[0x1E0C9AA60], a2);
  objc_msgSend(a8, "code");
  kdebug_trace();

LABEL_62:
}

void sub_1B3B5C730(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id obj, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15)
{
  uint64_t v15;

  objc_sync_exit(obj);
  _Block_object_dispose((const void *)(v15 - 192), 8);
  _Unwind_Resume(a1);
}

void sub_1B3B5CB04(_Unwind_Exception *a1)
{
  void *v1;

  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

Class initBCSAppClipCodeURLDecoder()
{
  Class result;

  if (BarcodeSupportLibrary_sOnce != -1)
    dispatch_once(&BarcodeSupportLibrary_sOnce, &__block_literal_global_72_0);
  result = objc_getClass("BCSAppClipCodeURLDecoder");
  classBCSAppClipCodeURLDecoder = (uint64_t)result;
  getBCSAppClipCodeURLDecoderClass = (uint64_t (*)())BCSAppClipCodeURLDecoderFunction;
  return result;
}

id BCSAppClipCodeURLDecoderFunction()
{
  return (id)classBCSAppClipCodeURLDecoder;
}

void sub_1B3B5E06C(_Unwind_Exception *a1)
{
  id *v1;
  id *v2;
  uint64_t v3;

  objc_destroyWeak(v2);
  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v3 - 72));
  _Unwind_Resume(a1);
}

id _ARLogTechnique_11()
{
  if (_ARLogTechnique_onceToken_17 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_17, &__block_literal_global_84);
  return (id)_ARLogTechnique_logObj_17;
}

void sub_1B3B5F6E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *a40)
{

  _Unwind_Resume(a1);
}

id textureForSizeWithPixelFormatAndMetalDevice(int a1, void *a2, double a3, double a4)
{
  void *v7;
  id v8;
  void *v9;
  void *v10;

  v7 = (void *)MEMORY[0x1E0CC6BB0];
  v8 = a2;
  objc_msgSend(v7, "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", getMTLPixelFormat(a1), (unint64_t)a3, (unint64_t)a4, 0);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v9, "setUsage:", 19);
  v10 = (void *)objc_msgSend(v8, "newTextureWithDescriptor:", v9);

  return v10;
}

__IOSurface *bindPixelBufferToMTL2DTextureWithMetalDevice(__CVBuffer *a1, void *a2)
{
  id v3;
  __IOSurface *IOSurface;
  OSType PixelFormatType;
  uint64_t MTLPixelFormat;
  size_t WidthOfPlane;
  void *v8;
  void *v9;

  v3 = a2;
  IOSurface = CVPixelBufferGetIOSurface(a1);
  if (IOSurface)
  {
    PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
    MTLPixelFormat = getMTLPixelFormat(PixelFormatType);
    WidthOfPlane = IOSurfaceGetWidthOfPlane(IOSurface, 0);
    objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", MTLPixelFormat, WidthOfPlane, IOSurfaceGetHeightOfPlane(IOSurface, 0), 0);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    v9 = v8;
    if (v8)
    {
      objc_msgSend(v8, "setUsage:", 23);
      IOSurface = (__IOSurface *)objc_msgSend(v3, "newTextureWithDescriptor:iosurface:plane:", v9, IOSurface, 0);
    }
    else
    {
      IOSurface = 0;
    }

  }
  return IOSurface;
}

id _ARLogGeneral_32()
{
  if (_ARLogGeneral_onceToken_38 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_38, &__block_literal_global_231);
  return (id)_ARLogGeneral_logObj_38;
}

void sub_1B3B625F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,char a52,uint64_t a53,void (*a54)(char *))
{
  a54(&a52);
  ((void (*)(unint64_t *))STACK[0x258])(&STACK[0x248]);
  _Block_object_dispose(&STACK[0x278], 8);
  _Block_object_dispose(&STACK[0x298], 8);
  ((void (*)(unint64_t *))STACK[0x2C8])(&STACK[0x2B8]);
  ((void (*)(unint64_t *))STACK[0x2F0])(&STACK[0x2E0]);
  ((void (*)(unint64_t *))STACK[0x328])(&STACK[0x318]);
  _Block_object_dispose(&STACK[0x340], 8);
  ((void (*)(unint64_t *))STACK[0x370])(&STACK[0x360]);
  _Block_object_dispose(&STACK[0x388], 8);
  ((void (*)(unint64_t *))STACK[0x3B8])(&STACK[0x3A8]);
  _Block_object_dispose(&STACK[0x3D0], 8);
  _Unwind_Resume(a1);
}

double matrixForImageRotation(uint64_t a1)
{
  float v1;
  __float2 v2;
  double v3;

  v1 = 0.0;
  if ((unint64_t)(a1 - 1) <= 2)
    v1 = flt_1B3C08438[a1 - 1];
  v2 = __sincosf_stret(v1);
  *(float *)&v3 = v2.__cosval;
  *((float *)&v3 + 1) = -v2.__sinval;
  return v3;
}

uint64_t getMTLPixelFormat(int a1)
{
  uint64_t v1;
  uint64_t v2;
  NSObject *v4;
  uint8_t v5[16];
  uint64_t v6;
  uint64_t v7;

  if (a1 > 1380401728)
  {
    if (a1 == 1380411457)
      return 115;
    if (a1 == 1380401729)
      return 70;
  }
  else
  {
    if (a1 == 843264104)
      return 65;
    if (a1 == 1111970369)
      return 80;
  }
  v6 = v1;
  v7 = v2;
  _ARLogGeneral_32();
  v4 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)v5 = 0;
    _os_log_impl(&dword_1B3A68000, v4, OS_LOG_TYPE_ERROR, "error unsupported pixelformat", v5, 2u);
  }

  return 0;
}

void sub_1B3B631D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B633B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B636D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *__p,uint64_t a23)
{
  void *v23;
  void *v24;
  void *v25;
  void *v26;
  void *v27;
  void *v28;
  void *v29;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1B3B6396C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B63B6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63C20(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63C78(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63CC4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63F1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63F68(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B63FB4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B64000(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B640C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B642A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B643C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B644B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t ARFaceLandmarkDataFromLabeledFacePosition(void *a1, __int16 *a2, __int16 *a3, __int16 *a4, float *a5, float *a6, float *a7)
{
  id v13;
  float v14;
  uint64_t v15;
  float v16;
  __int16 v17;
  __int16 v18;
  __int16 v19;
  float v20;
  int v21;
  char v22;
  int v23;
  int v24;
  char v25;
  char v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;

  v13 = a1;
  v14 = 1.0;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeOuterCorner")) & 1) != 0)
  {
    v15 = 1;
    v16 = 0.0;
    v17 = 1102;
    v18 = 1181;
    v19 = 1101;
LABEL_3:
    v20 = 0.0;
    goto LABEL_20;
  }
  v20 = 0.31;
  v16 = 0.19242;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeInnerCorner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1088;
    v18 = 1089;
    v19 = 1193;
LABEL_6:
    v14 = 0.49758;
    goto LABEL_20;
  }
  v21 = 1058051330;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeLowerOuter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1106;
    v14 = 0.0;
    v18 = 1107;
    v19 = 1199;
LABEL_9:
    v16 = 0.43523;
LABEL_10:
    v20 = *(float *)&v21;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeLowerInner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1085;
    v18 = 1198;
    v19 = 1108;
    v14 = 0.20381;
    v16 = 0.0;
LABEL_13:
    v20 = 0.79619;
    goto LABEL_20;
  }
  v22 = objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeUpperOuter"));
  v23 = 1059847335;
  v24 = 1051199154;
  if ((v22 & 1) != 0)
  {
    v15 = 1;
    v17 = 1096;
    v18 = 1187;
    v19 = 1095;
LABEL_18:
    v14 = *(float *)&v24;
    v16 = 0.0;
LABEL_19:
    v20 = *(float *)&v23;
    goto LABEL_20;
  }
  v25 = objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyeUpperInner"));
  v23 = 1058721800;
  v24 = 1053450224;
  if ((v25 & 1) != 0)
  {
    v15 = 1;
    v17 = 1094;
    v18 = 1189;
    v19 = 1093;
    goto LABEL_18;
  }
  v27 = objc_msgSend(v13, "isEqualToString:", CFSTR("RightEyePupil"));
  v23 = 1053609165;
  if ((v27 & 1) != 0)
  {
    v15 = 1;
    v17 = 1108;
    v18 = 1095;
    v19 = 1093;
    v14 = 0.3;
    v16 = 0.3;
    goto LABEL_19;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeOuterCorner")) & 1) != 0)
  {
    v15 = 1;
    v16 = 0.0;
    v17 = 1068;
    v18 = 1180;
    v19 = 1069;
    goto LABEL_3;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeInnerCorner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1082;
    v18 = 1081;
    v19 = 1168;
    goto LABEL_6;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeLowerOuter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1064;
    v14 = 0.0;
    v18 = 1063;
    v19 = 1162;
    goto LABEL_9;
  }
  v16 = 0.0;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeLowerInner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1061;
    v18 = 1163;
    v19 = 1062;
    v14 = 0.20381;
    goto LABEL_13;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeUpperOuter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1074;
    v18 = 1174;
    v19 = 1075;
    v14 = 0.32818;
    v20 = 0.67182;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyeUpperInner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1076;
    v18 = 1172;
    v19 = 1077;
    v14 = 0.39526;
    v20 = 0.60474;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftEyePupil")) & 1) != 0)
  {
    v15 = 1;
    v17 = 1062;
    v18 = 1077;
    v19 = 1075;
    v16 = 0.3;
    v20 = 0.4;
    v14 = 0.3;
    goto LABEL_20;
  }
  v20 = 0.48977;
  v16 = 0.18919;
  v14 = 0.32105;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightBrowOuter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 334;
    v18 = 327;
    v19 = 335;
    goto LABEL_20;
  }
  v21 = 1053597916;
  v28 = 1046921939;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightBrowMiddle")) & 1) != 0)
  {
    v15 = 1;
    v17 = 209;
    v18 = 329;
    v19 = 328;
LABEL_41:
    v14 = 0.37498;
LABEL_42:
    v16 = *(float *)&v28;
    goto LABEL_10;
  }
  v32 = 1030661949;
  v29 = 1053234397;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("RightBrowInner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 329;
    v18 = 349;
    v19 = 348;
LABEL_45:
    v14 = 0.5529;
LABEL_46:
    v16 = *(float *)&v29;
    v20 = *(float *)&v32;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftBrowOuter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 767;
    v18 = 762;
    v19 = 768;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftBrowMiddle")) & 1) != 0)
  {
    v15 = 1;
    v17 = 657;
    v18 = 764;
    v19 = 763;
    goto LABEL_41;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("LeftBrowInner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 764;
    v18 = 782;
    v19 = 781;
    goto LABEL_45;
  }
  v20 = 0.56212;
  v16 = 0.095512;
  v14 = 0.34236;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightCorner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 396;
    v18 = 190;
    v19 = 188;
    goto LABEL_20;
  }
  v21 = 1053235527;
  v28 = 1052383319;
  v30 = 1048419522;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightUp1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 108;
    v18 = 107;
    v19 = 100;
LABEL_57:
    v14 = *(float *)&v30;
    goto LABEL_42;
  }
  v32 = 1027608717;
  v29 = 1047327851;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightUp2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 108;
    v18 = 98;
    v19 = 96;
LABEL_60:
    v14 = 0.72171;
    goto LABEL_46;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightPhiltrum")) & 1) != 0)
  {
    v15 = 1;
    v17 = 90;
    v18 = 92;
    v19 = 94;
LABEL_63:
    v14 = 0.47181;
    v16 = 0.2723;
    v20 = 0.25589;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthCenterPhiltrum")) & 1) != 0)
  {
    v19 = 1;
    v17 = 541;
    v18 = 21;
    v16 = 0.7408;
    v14 = 0.2592;
    v20 = 0.0;
    v15 = 1;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftPhiltrum")) & 1) != 0)
  {
    v15 = 1;
    v17 = 539;
    v18 = 541;
    v19 = 543;
    goto LABEL_63;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftUp2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 557;
    v18 = 547;
    v19 = 545;
    goto LABEL_60;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftUp1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 557;
    v18 = 556;
    v19 = 549;
    goto LABEL_57;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftCorner")) & 1) != 0)
  {
    v15 = 1;
    v17 = 826;
    v18 = 639;
    v19 = 637;
    goto LABEL_20;
  }
  v20 = 0.094037;
  v16 = 0.13663;
  v14 = 0.76933;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftDown1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 714;
    v18 = 713;
    v19 = 571;
    goto LABEL_20;
  }
  v21 = 1056986958;
  v28 = 1034297112;
  v30 = 1054198174;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthLeftDown2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 706;
    v18 = 723;
    v19 = 722;
    goto LABEL_57;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthCenterLower")) & 1) != 0)
  {
    v15 = 1;
    v17 = 263;
    v18 = 27;
    v19 = 28;
    v16 = 0.093781;
    v14 = 0.90622;
    goto LABEL_3;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightDown2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 271;
    v18 = 288;
    v19 = 287;
    goto LABEL_57;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthRightDown1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 279;
    v18 = 278;
    v19 = 122;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerUp")) & 1) != 0)
  {
    v15 = 1;
    v16 = 1.0;
    v14 = 0.0;
    v17 = 542;
    v18 = 24;
    v19 = 23;
    goto LABEL_3;
  }
  v20 = 0.0;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerDown")) & 1) != 0)
  {
    v15 = 1;
    v14 = 1.0;
    v17 = 699;
    v18 = 26;
    v19 = 25;
LABEL_88:
    v16 = 0.0;
    goto LABEL_20;
  }
  v21 = 1030023345;
  v16 = 0.7827;
  v14 = 0.16141;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerUpRight")) & 1) != 0)
  {
    v15 = 1;
    v17 = 105;
    v18 = 254;
    v19 = 253;
    goto LABEL_10;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerUpLeft")) & 1) != 0)
  {
    v15 = 1;
    v17 = 554;
    v18 = 689;
    v19 = 688;
    goto LABEL_10;
  }
  v21 = 1050784710;
  v16 = 0.66943;
  v14 = 0.014741;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerDownRight")) & 1) != 0)
  {
    v15 = 1;
    v17 = 275;
    v18 = 290;
    v19 = 289;
    goto LABEL_10;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("MouthInnerDownLeft")) & 1) != 0)
  {
    v15 = 1;
    v17 = 710;
    v18 = 725;
    v19 = 724;
    goto LABEL_10;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseRidgeRoot")) & 1) != 0)
  {
    v15 = 1;
    v17 = 36;
    v18 = 360;
    v19 = 15;
    v20 = 0.33965;
    v14 = 0.66035;
    goto LABEL_88;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseRidge1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 606;
    v18 = 12;
    v19 = 13;
    v16 = 0.38536;
    v14 = 0.61464;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseRidge2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 156;
    v18 = 10;
    v19 = 9;
    v16 = 0.93626;
    v14 = 0.063743;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseRidgeTip")) & 1) != 0)
  {
    v15 = 1;
    v17 = 129;
    v18 = 8;
    v19 = 7;
    v16 = 0.68;
    v14 = 0.32;
    goto LABEL_20;
  }
  v21 = 1062999407;
  v16 = 0.088421;
  v14 = 0.051877;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseBaseLeft")) & 1) != 0)
  {
    v15 = 1;
    v17 = 743;
    v18 = 866;
    v19 = 867;
    goto LABEL_10;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseBaseCenterLeft")) & 1) != 0)
  {
    v15 = 1;
    v17 = 526;
    v18 = 869;
    v19 = 742;
LABEL_113:
    v14 = 0.65537;
    v16 = 0.16678;
    v20 = 0.17784;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseBaseCenter")) & 1) != 0)
  {
    v15 = 1;
    v17 = 759;
    v18 = 3;
    v19 = 4;
    v16 = 0.27602;
    v14 = 0.72398;
    goto LABEL_20;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseBaseCenterRight")) & 1) != 0)
  {
    v15 = 1;
    v17 = 77;
    v18 = 441;
    v19 = 307;
    goto LABEL_113;
  }
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseBaseRight")) & 1) != 0)
  {
    v15 = 1;
    v17 = 308;
    v18 = 438;
    v19 = 439;
    goto LABEL_10;
  }
  v20 = 0.80801;
  v16 = 0.12549;
  v14 = 0.0665;
  if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseAlaLeft1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 588;
    v18 = 738;
    v19 = 739;
  }
  else if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseAlaRight1")) & 1) != 0)
  {
    v15 = 1;
    v17 = 139;
    v18 = 303;
    v19 = 304;
  }
  else if ((objc_msgSend(v13, "isEqualToString:", CFSTR("NoseAlaLeft2")) & 1) != 0)
  {
    v15 = 1;
    v17 = 530;
    v18 = 805;
    v19 = 531;
    v20 = 0.051558;
    v16 = 0.21135;
    v14 = 0.73709;
  }
  else
  {
    v31 = objc_msgSend(v13, "isEqualToString:", CFSTR("NoseAlaRight2"));
    v15 = v31;
    if ((_DWORD)v31)
      v19 = 82;
    else
      v19 = -1;
    if ((_DWORD)v31)
      v18 = 374;
    else
      v18 = -1;
    if ((_DWORD)v31)
      v17 = 81;
    else
      v17 = -1;
    if ((_DWORD)v31)
      v14 = 0.73709;
    else
      v14 = -1.0;
    if ((_DWORD)v31)
      v16 = 0.21135;
    else
      v16 = -1.0;
    if ((_DWORD)v31)
      v20 = 0.051558;
    else
      v20 = -1.0;
  }
LABEL_20:
  *a2 = v19;
  *a3 = v18;
  *a4 = v17;
  *a5 = v14;
  *a6 = v16;
  *a7 = v20;

  return v15;
}

void sub_1B3B650D0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_15()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

_QWORD *std::vector<short>::vector(_QWORD *a1, uint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<short>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 2 * a2);
    a1[1] = &v4[2 * a2];
  }
  return a1;
}

void sub_1B3B65360(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<short>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<short>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[2 * v4];
  return result;
}

uint64_t createUUID(void)
{
  void *v0;
  _QWORD v2[3];

  v2[2] = *MEMORY[0x1E0C80C00];
  v0 = (void *)objc_opt_new();
  objc_msgSend(v0, "getUUIDBytes:", v2);

  return v2[0];
}

void sub_1B3B65424(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t toUUID(const __CFUUID *a1)
{
  void *v1;
  _QWORD v3[3];

  v3[2] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB3A28], "ar_UUIDWithCFUUIDRef:", a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "getUUIDBytes:", v3);

  return v3[0];
}

void sub_1B3B654B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

id ARCreateTexture(uint64_t a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0CC6BB0], "texture2DDescriptorWithPixelFormat:width:height:mipmapped:", 81, a1, a1, 0);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "setUsage:", 5);
  +[ARSharedGPUDevice sharedInstance](ARSharedGPUDevice, "sharedInstance");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "device");
  v3 = (void *)objc_claimAutoreleasedReturnValue();

  v4 = (void *)objc_msgSend(v3, "newTextureWithDescriptor:", v1);
  objc_msgSend(v4, "setLabel:", CFSTR("com.apple.arkit.planetexture"));

  return v4;
}

void sub_1B3B65560(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  v4 = v3;

  _Unwind_Resume(a1);
}

void convert(uint64_t a1@<X8>)
{
  float32x4_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  float *v17;
  float *v18;
  const __CFUUID *v19;
  uint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  const __CFArray *v26;
  const __CFArray *v27;
  CFIndex Count;
  CFIndex i;
  const __CFUUID *ValueAtIndex;
  uint64_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  float32x4_t v39;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  float32x4_t v44;
  float32x4_t v45;
  float32x4_t v46;
  float32x4_t v47;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  uint64_t v52;

  v52 = *MEMORY[0x1E0C80C00];
  *(double *)v3.i64 = ARVisionToRenderingCoordinateTransform();
  v40 = v3;
  v41 = v4;
  v42 = v5;
  v43 = v6;
  CV3DPlaneDetectionPlaneTransformationToWorld();
  v7 = 0;
  v48 = v8;
  v49 = v9;
  v50 = v10;
  v51 = v11;
  do
  {
    *(float32x4_t *)((char *)&v44 + v7) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, COERCE_FLOAT(*(__int128 *)((char *)&v48 + v7))), v41, *(float32x2_t *)((char *)&v48 + v7), 1), v42, *(float32x4_t *)((char *)&v48 + v7), 2), v43, *(float32x4_t *)((char *)&v48 + v7), 3);
    v7 += 16;
  }
  while (v7 != 64);
  v36 = v44;
  v38 = v45;
  v32 = v47;
  v34 = v46;
  *(double *)&v12 = ARRenderingToVisionCoordinateTransform();
  v13 = 0;
  v48 = v12;
  v49 = v14;
  v50 = v15;
  v51 = v16;
  do
  {
    *(float32x4_t *)((char *)&v44 + v13) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v36, COERCE_FLOAT(*(__int128 *)((char *)&v48 + v13))), v38, *(float32x2_t *)((char *)&v48 + v13), 1), v34, *(float32x4_t *)((char *)&v48 + v13), 2), v32, *(float32x4_t *)((char *)&v48 + v13), 3);
    v13 += 16;
  }
  while (v13 != 64);
  v37 = v45;
  v39 = v44;
  v33 = v47;
  v35 = v46;
  CV3DPlaneDetectionPlaneExtentAlignedBoundingBox();
  v17 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMin();
  v18 = (float *)CV3DPlaneDetectionAlignedBoundingBoxMax();
  *(_QWORD *)(a1 + 200) = 0;
  *(_QWORD *)(a1 + 192) = a1 + 200;
  *(_QWORD *)(a1 + 208) = 0;
  *(_QWORD *)(a1 + 216) = 0;
  v19 = (const __CFUUID *)CV3DPlaneDetectionPlaneCopyUUID();
  *(_QWORD *)a1 = toUUID(v19);
  *(_QWORD *)(a1 + 8) = v20;
  CFRelease(v19);
  *(_QWORD *)(a1 + 16) = CV3DPlaneDetectionPlaneAge();
  v21 = vaddq_f32(v43, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v40, *v18), v41, v18[1]), (float32x4_t)0, v42));
  v22 = vaddq_f32(v43, vmlaq_f32(vmlaq_n_f32(vmulq_n_f32(v40, *v17), v41, v17[1]), (float32x4_t)0, v42));
  *(float32x4_t *)(a1 + 96) = vmaxnmq_f32(v21, v22);
  *(float32x4_t *)(a1 + 112) = vminnmq_f32(v21, v22);
  *(float32x4_t *)(a1 + 32) = v39;
  *(float32x4_t *)(a1 + 48) = v37;
  *(float32x4_t *)(a1 + 64) = v35;
  *(float32x4_t *)(a1 + 80) = v33;
  if (CV3DPlaneDetectionPlaneExtentOrientedBoundingBox())
  {
    v23 = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v44.f32[2]), v41, *(float32x2_t *)&v44.u32[2], 1), (float32x4_t)0, v42));
    v24 = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v45.f32[0]), v41, *(float32x2_t *)v45.f32, 1), (float32x4_t)0, v42));
    v25 = vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v45.f32[2]), v41, *(float32x2_t *)&v45.u32[2], 1), (float32x4_t)0, v42);
    *(float32x4_t *)(a1 + 128) = vaddq_f32(v43, vmlaq_f32(vmlaq_lane_f32(vmulq_n_f32(v40, v44.f32[0]), v41, *(float32x2_t *)v44.f32, 1), (float32x4_t)0, v42));
    *(float32x4_t *)(a1 + 144) = v23;
    *(float32x4_t *)(a1 + 160) = v24;
    *(float32x4_t *)(a1 + 176) = vaddq_f32(v43, v25);
  }
  v26 = (const __CFArray *)CV3DPlaneDetectionPlaneMergedIds();
  v27 = v26;
  if (v26)
  {
    Count = CFArrayGetCount(v26);
    if (Count)
    {
      for (i = 0; i != Count; ++i)
      {
        ValueAtIndex = (const __CFUUID *)CFArrayGetValueAtIndex(v27, i);
        *(_QWORD *)&v48 = toUUID(ValueAtIndex);
        *((_QWORD *)&v48 + 1) = v31;
        std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)(a1 + 192), (uint64_t)&v48, &v48);
      }
    }
    CFRelease(v27);
  }
}

void sub_1B3B65850(_Unwind_Exception *a1)
{
  ARTexturedPlane *v1;

  ARTexturedPlane::~ARTexturedPlane(v1);
  _Unwind_Resume(a1);
}

void convert(const CV3DPlaneDetectionPlaneList *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3;
  uint64_t i;
  const __CFUUID *v5;
  uint64_t v6;
  _OWORD *v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  char *v16;
  _QWORD *v17;
  uint64_t v18;
  id v19;
  void *v20;
  __int128 *v21;
  _QWORD v22[2];
  _OWORD v23[12];
  _QWORD **v24;
  _QWORD *v25;
  uint64_t v26;
  id v27;
  uint64_t v28;

  v28 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = a2 + 8;
  if (a1)
  {
    v3 = CV3DPlaneDetectionPlaneListLength();
    if (v3)
    {
      for (i = 0; i != v3; ++i)
      {
        if (CV3DPlaneDetectionPlaneAtIndex())
        {
          v5 = (const __CFUUID *)CV3DPlaneDetectionPlaneCopyUUID();
          convert((uint64_t)v23);
          v22[0] = toUUID(v5);
          v22[1] = v6;
          v21 = (__int128 *)v22;
          v7 = std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul>&&>,std::tuple<>>((uint64_t **)a2, (uint64_t)v22, (uint64_t)&std::piecewise_construct, &v21);
          v9 = v23[10];
          v8 = v23[11];
          v10 = v23[9];
          v11 = v23[7];
          v7[11] = v23[8];
          v7[12] = v10;
          v7[13] = v9;
          v7[14] = v8;
          v12 = v23[5];
          v7[7] = v23[4];
          v7[8] = v12;
          v7[9] = v23[6];
          v7[10] = v11;
          v13 = v23[1];
          v15 = v23[2];
          v14 = v23[3];
          v7[3] = v23[0];
          v7[4] = v13;
          v7[5] = v15;
          v7[6] = v14;
          v16 = (char *)v7 + 248;
          std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(v7 + 15), *((_QWORD **)v7 + 31));
          v17 = v25;
          *((_QWORD *)v7 + 30) = v24;
          *((_QWORD *)v7 + 31) = v17;
          v18 = v26;
          *((_QWORD *)v7 + 32) = v26;
          if (v18)
          {
            v17[2] = v16;
            v24 = &v25;
            v25 = 0;
            v26 = 0;
          }
          else
          {
            *((_QWORD *)v7 + 30) = v16;
          }
          v19 = v27;
          v27 = 0;
          v20 = (void *)*((_QWORD *)v7 + 33);
          *((_QWORD *)v7 + 33) = v19;

          std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v24, v25);
          CFRelease(v5);
        }
      }
    }
  }
}

void sub_1B3B65A40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ARTexturedPlane *a7)
{
  uint64_t v7;

  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(v7, *(_QWORD **)(v7 + 8));
  _Unwind_Resume(a1);
}

id convertToMesh(const ARTexturedPlane *a1)
{
  return -[ARMeshPrimitive initAsPlaneWithTransform:min:max:texture:]([ARMeshPrimitive alloc], "initAsPlaneWithTransform:min:max:texture:", a1[3].var5, *(double *)&a1->var4.__tree_.__pair1_.__value_.__left_, *(double *)&a1->var5, *(double *)&a1[1].var0.var0[8], *(double *)&a1[1].var4.__tree_.__begin_node_, *(double *)a1[2].var0.var0, *(double *)&a1[1].var4.__tree_.__pair3_.__value_);
}

id convertToMeshes(const ARTexturedPlane **a1)
{
  void *v2;
  const ARTexturedPlane *v3;
  const ARTexturedPlane *v4;
  void *v5;

  v2 = (void *)objc_opt_new();
  v3 = *a1;
  v4 = a1[1];
  while (v3 != v4)
  {
    convertToMesh(v3);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v2, "addObject:", v5);

    v3 += 4;
  }
  return v2;
}

void sub_1B3B65B24(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

double randomPlanePointInWorldCoordinates(const ARTexturedPlane *a1)
{
  float v2;
  float v3;
  float v4;
  double result;

  v2 = *(float *)a1[2].var0.var0;
  v3 = *(float *)&a1[1].var4.__tree_.__pair3_.__value_;
  v4 = v2 + (float)((float)((float)rand() * 4.6566e-10) * (float)(v3 - v2));
  *(_QWORD *)&result = vaddq_f32(*(float32x4_t *)&a1[1].var4.__tree_.__begin_node_, vmlaq_n_f32(vmlaq_f32(vmulq_n_f32(*(float32x4_t *)&a1->var4.__tree_.__pair1_.__value_.__left_, v4), (float32x4_t)0, *(float32x4_t *)&a1->var5), *(float32x4_t *)((char *)&a1[1].var0 + 8), *(float *)&a1[2].var0.var0[8]+ (float)((float)((float)rand() * 4.6566e-10)* (float)(*(float *)&a1[1].var5 - *(float *)&a1[2].var0.var0[8])))).u64[0];
  return result;
}

__n128 convert@<Q0>(const ARTexturedPlane *a1@<X0>, _OWORD *a2@<X8>)
{
  int v2;
  unint64_t *p_var1;
  __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::array<unsigned char, 16>, void *>>> *p_pair1;
  uint64_t v5;
  __int128 v6;
  uint64_t v8;
  int v9;
  int v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  float v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float32x4_t v19;
  float v20;
  float v21;
  float32x4_t v22;
  float32x4_t v23;
  float v24;
  float32x4_t v25;
  float32x4_t v26;
  float32x4_t v27;
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v34;
  float32x4_t v35;
  float32x4_t v36;
  float32x4_t v37;
  float32x4_t v38;
  uint64_t v39;
  uint64_t v40;
  float32x4_t v41;
  float32x4_t v42;
  float32x4_t v43;
  __n128 result;
  __int128 v45;
  float32x4_t v46;
  float32x4_t v47;
  float32x4_t v48;
  __int128 v49;
  float32x4_t v50;
  float32x4_t v51;
  float32x4_t v52;

  v2 = 0;
  p_var1 = &a1[2].var1;
  p_pair1 = &a1[2].var4.__tree_.__pair1_;
  v5 = -3;
  do
  {
    v6 = *(_OWORD *)&p_pair1->__value_.__left_;
    p_pair1 += 2;
    if (*(float *)&v6 > *(float *)&p_var1[2 * v2])
      v2 = v5 + 4;
  }
  while (!__CFADD__(v5++, 1));
  v8 = 0;
  v9 = (v2 + 2) & 3;
  if (v2 + 2 <= 0)
    v9 = -(-(v2 + 2) & 3);
  v10 = (v2 + 3) & 3;
  if (v2 + 3 <= 0)
    v10 = -(-(v2 + 3) & 3);
  v11 = *(float32x4_t *)&p_var1[2 * v10];
  v12 = vsubq_f32(*(float32x4_t *)&p_var1[2 * v2], v11);
  v13 = vmulq_f32(v12, v12);
  v14 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2);
  v16 = vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1));
  LODWORD(v15) = vaddq_f32(v14, v16).u32[0];
  v16.f32[0] = sqrtf(v15);
  *(float32x2_t *)v14.f32 = vrsqrte_f32((float32x2_t)LODWORD(v15));
  *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v15), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32)));
  v17 = vmulq_n_f32(v12, vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v15), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32))).f32[0]);
  v18 = vsubq_f32(*(float32x4_t *)&p_var1[2 * v9], v11);
  v19 = vmulq_f32(v18, v18);
  LODWORD(v20) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 2), vaddq_f32(v19, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v19.f32, 1))).u32[0];
  v21 = sqrtf(v20);
  *(float32x2_t *)v14.f32 = vrsqrte_f32((float32x2_t)LODWORD(v20));
  *(float32x2_t *)v14.f32 = vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v20), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32)));
  v22 = vmulq_n_f32(v18, vmul_f32(*(float32x2_t *)v14.f32, vrsqrts_f32((float32x2_t)LODWORD(v20), vmul_f32(*(float32x2_t *)v14.f32, *(float32x2_t *)v14.f32))).f32[0]);
  v23 = vaddq_f32(vaddq_f32(*(float32x4_t *)&a1[2].var1, *(float32x4_t *)&a1[2].var4.__tree_.__pair1_.__value_.__left_), *(float32x4_t *)&a1[2].var5);
  if (v16.f32[0] >= v21)
    v24 = v21;
  else
    v24 = v16.f32[0];
  v25 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
  v26 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
  v27 = v26;
  v27.f32[1] = v24 * 0.5;
  v28 = *(float32x4_t *)MEMORY[0x1E0C83FF0];
  v29 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v17.i32[3] = HIDWORD(*MEMORY[0x1E0C83FF0]);
  v22.i32[3] = v25.i32[3];
  __asm { FMOV            V4.4S, #0.25 }
  v34 = vmulq_f32(vaddq_f32(v23, *(float32x4_t *)((char *)&a1[3].var0 + 8)), _Q4);
  v35 = *(float32x4_t *)&a1->var4.__tree_.__pair1_.__value_.__left_;
  v36 = *(float32x4_t *)&a1->var5;
  v37 = *(float32x4_t *)((char *)&a1[1].var0 + 8);
  v38 = *(float32x4_t *)&a1[1].var4.__tree_.__begin_node_;
  v45 = *MEMORY[0x1E0C83FF0];
  v46 = v29;
  v47 = v25;
  v48 = v27;
  do
  {
    *(__int128 *)((char *)&v49 + v8) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v17, COERCE_FLOAT(*(__int128 *)((char *)&v45 + v8))), v29, *(float32x2_t *)((char *)&v45 + v8), 1), v22, *(float32x4_t *)((char *)&v45 + v8), 2), v26, *(float32x4_t *)((char *)&v45 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  v39 = 0;
  v34.i32[3] = v26.i32[3];
  v45 = v49;
  v46 = v50;
  v47 = v51;
  v48 = v52;
  do
  {
    *(__int128 *)((char *)&v49 + v39) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v28, COERCE_FLOAT(*(__int128 *)((char *)&v45 + v39))), v29, *(float32x2_t *)((char *)&v45 + v39), 1), v25, *(float32x4_t *)((char *)&v45 + v39), 2), v34, *(float32x4_t *)((char *)&v45 + v39), 3);
    v39 += 16;
  }
  while (v39 != 64);
  v40 = 0;
  v45 = v49;
  v46 = v50;
  v47 = v51;
  v48 = v52;
  do
  {
    *(__int128 *)((char *)&v49 + v40) = (__int128)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v35, COERCE_FLOAT(*(__int128 *)((char *)&v45 + v40))), v36, *(float32x2_t *)((char *)&v45 + v40), 1), v37, *(float32x4_t *)((char *)&v45 + v40), 2), v38, *(float32x4_t *)((char *)&v45 + v40), 3);
    v40 += 16;
  }
  while (v40 != 64);
  v41 = v50;
  v42 = v51;
  v43 = v52;
  *a2 = v49;
  a2[1] = v41;
  a2[2] = v42;
  a2[3] = v43;
  v16.f32[1] = v24;
  v16.f32[2] = v21;
  a2[4] = v16;
  result.n128_u64[0] = v16.i64[0];
  result.n128_u32[2] = v16.u32[2];
  return result;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>(uint64_t **a1, uint64_t a2, _OWORD *a3)
{
  void **v5;
  char *v6;
  uint64_t **v7;
  uint64_t v9;

  v5 = (void **)std::__tree<std::array<unsigned char,16ul>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v9, a2);
  v6 = (char *)*v5;
  if (!*v5)
  {
    v7 = (uint64_t **)v5;
    v6 = (char *)operator new(0x30uLL);
    *(_OWORD *)(v6 + 25) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v9, v7, (uint64_t *)v6);
  }
  return v6;
}

_OWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul>&&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, __int128 **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  __int128 v9;
  uint64_t v11;

  v6 = (void **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v11, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x110uLL);
    v9 = **a4;
    v7[15] = 0u;
    v7[16] = 0u;
    v7[13] = 0u;
    v7[14] = 0u;
    v7[11] = 0u;
    v7[12] = 0u;
    v7[9] = 0u;
    v7[10] = 0u;
    v7[7] = 0u;
    v7[8] = 0u;
    v7[5] = 0u;
    v7[6] = 0u;
    v7[3] = 0u;
    v7[4] = 0u;
    v7[2] = v9;
    *((_QWORD *)v7 + 30) = (char *)v7 + 248;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v11, v8, (uint64_t *)v7);
  }
  return v7;
}

_QWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *result;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  _QWORD *v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;

  v5 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v4 = v5;
  if (v5)
  {
LABEL_2:
    while (2)
    {
      v6 = 0;
      v7 = v4;
      do
      {
        v8 = *(unsigned __int8 *)(a3 + v6);
        v9 = *((unsigned __int8 *)v7 + v6 + 32);
        if (v8 < v9)
        {
          v4 = (_QWORD *)*v7;
          result = v7;
          if (*v7)
            goto LABEL_2;
          goto LABEL_22;
        }
      }
      while (v9 >= v8 && v6++ != 15);
      v11 = 0;
      while (1)
      {
        v12 = *((unsigned __int8 *)v7 + v11 + 32);
        v13 = *(unsigned __int8 *)(a3 + v11);
        if (v12 < v13)
          break;
        if (v13 < v12 || v11++ == 15)
          goto LABEL_22;
      }
      result = v7 + 1;
      v4 = (_QWORD *)v7[1];
      if (v4)
        continue;
      break;
    }
  }
  else
  {
    v7 = result;
  }
LABEL_22:
  *a2 = v7;
  return result;
}

const __CFString *NSStringFromARGeoTrackingState(unint64_t a1)
{
  if (a1 > 3)
    return CFSTR("Unknown");
  else
    return *(&off_1E66751C0 + a1);
}

const __CFString *NSStringFromARGeoTrackingAccuracy(unint64_t a1)
{
  if (a1 > 3)
    return CFSTR("Unknown");
  else
    return *(&off_1E66751E0 + a1);
}

const __CFString *NSStringFromARGeoTrackingStateReason(unint64_t a1)
{
  if (a1 > 8)
    return CFSTR("Unknown");
  else
    return *(&off_1E6675200 + a1);
}

const __CFString *NSStringFromARGeoTrackingInternalFailureReason(uint64_t a1)
{
  const __CFString *result;

  if (a1 > 63)
  {
    if (a1 <= 511)
    {
      switch(a1)
      {
        case 64:
          return CFSTR("Invalid VIO Pose");
        case 128:
          return CFSTR("Phone Angle");
        case 256:
          return CFSTR("VL Bad Image");
      }
    }
    else if (a1 > 2047)
    {
      if (a1 == 2048)
        return CFSTR("VL Unrecognized Error");
      if (a1 == 4096)
        return CFSTR("Waiting For Availability Check");
    }
    else
    {
      if (a1 == 512)
        return CFSTR("VL Unavailable At Location");
      if (a1 == 1024)
        return CFSTR("Waiting For Location");
    }
    return CFSTR("Unknown");
  }
  result = CFSTR("None");
  switch(a1)
  {
    case 0:
      return result;
    case 1:
      return CFSTR("VL Unsupported");
    case 2:
      return CFSTR("VL Map Data Not Loaded");
    case 3:
    case 5:
    case 6:
    case 7:
      return CFSTR("Unknown");
    case 4:
      return CFSTR("VL Map Data Pending");
    case 8:
      return CFSTR("VL Pose Estimation Failed");
    default:
      if (a1 == 16)
      {
        result = CFSTR("VL Rejected Pose");
      }
      else
      {
        if (a1 != 32)
          return CFSTR("Unknown");
        result = CFSTR("VL Bad Input");
      }
      break;
  }
  return result;
}

void sub_1B3B66850(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;

  v9 = v6;

  _Unwind_Resume(a1);
}

void sub_1B3B669A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARDepthEstimationTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B66BBC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B66C1C()
{
  JUMPOUT(0x1B3B66C08);
}

void sub_1B3B66FD4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_8()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

id ARReplaySensorClassForMovieURL(void *a1, _QWORD *a2)
{
  id v3;
  void *v4;
  int v5;
  id v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  id v26;
  uint64_t v27;
  void *v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;
  _QWORD v32[2];

  v32[1] = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = v3;
  if (v3 && (objc_msgSend(v3, "isFileURL") & 1) != 0)
  {
    v26 = 0;
    v5 = objc_msgSend(v4, "getResourceValue:forKey:error:", &v26, *MEMORY[0x1E0C99A10], a2);
    v6 = v26;
    v7 = v6;
    if (v5)
    {
      if ((objc_msgSend(v6, "BOOLValue") & 1) != 0)
      {
        objc_msgSend(MEMORY[0x1E0C8B3C0], "assetWithURL:", v4);
        v8 = (void *)objc_claimAutoreleasedReturnValue();
        if (v8)
        {
          objc_opt_class();
          v9 = (void *)objc_claimAutoreleasedReturnValue();
LABEL_9:

LABEL_14:
          goto LABEL_15;
        }
        if (a2)
        {
          v20 = (void *)MEMORY[0x1E0CB3940];
          ARKitCoreBundle();
          v21 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v21, "localizedStringForKey:value:table:", CFSTR("Replay URL is not valid AVURLAsset: %@"), &stru_1E6676798, CFSTR("Localizable_iOS"));
          v22 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v20, "stringWithFormat:", v22, v4);
          v23 = (void *)objc_claimAutoreleasedReturnValue();

          v24 = (void *)MEMORY[0x1E0CB35C8];
          v27 = *MEMORY[0x1E0CB2D50];
          v28 = v23;
          objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v28, &v27, 1);
          v25 = (void *)objc_claimAutoreleasedReturnValue();
          objc_msgSend(v24, "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), 102, v25);
          *a2 = (id)objc_claimAutoreleasedReturnValue();

        }
LABEL_18:
        v9 = 0;
        goto LABEL_9;
      }
      if (a2)
      {
        v14 = (void *)MEMORY[0x1E0CB3940];
        ARKitCoreBundle();
        v15 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v15, "localizedStringForKey:value:table:", CFSTR("Replay URL is not readable: %@"), &stru_1E6676798, CFSTR("Localizable_iOS"));
        v16 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v14, "stringWithFormat:", v16, v4);
        v8 = (void *)objc_claimAutoreleasedReturnValue();

        v17 = (void *)MEMORY[0x1E0CB35C8];
        v29 = *MEMORY[0x1E0CB2D50];
        v30 = v8;
        objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &v30, &v29, 1);
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        objc_msgSend(v17, "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), 102, v18);
        *a2 = (id)objc_claimAutoreleasedReturnValue();

        goto LABEL_18;
      }
    }
    v9 = 0;
    goto LABEL_14;
  }
  if (a2)
  {
    v10 = (void *)MEMORY[0x1E0CB3940];
    ARKitCoreBundle();
    v11 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v11, "localizedStringForKey:value:table:", CFSTR("Replay URL is missing or not a fileURL: %@"), &stru_1E6676798, CFSTR("Localizable_iOS"));
    v12 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v10, "stringWithFormat:", v12, v4);
    v7 = (void *)objc_claimAutoreleasedReturnValue();

    v13 = (void *)MEMORY[0x1E0CB35C8];
    v31 = *MEMORY[0x1E0CB2D50];
    v32[0] = v7;
    objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", v32, &v31, 1);
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v13, "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), 102, v8);
    v9 = 0;
    *a2 = (id)objc_claimAutoreleasedReturnValue();
    goto LABEL_9;
  }
  v9 = 0;
LABEL_15:

  return v9;
}

uint64_t replayModeByApplyingUserDefaultOverrides(uint64_t a1)
{
  if (+[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.replaySensor.deterministicMode")))
  {
    if (+[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.replaySensor.deterministicMode.useMovieFPS")))
    {
      return 2;
    }
    else
    {
      return 1;
    }
  }
  else if (+[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.session.replay.filepath.manual")))
  {
    return 3;
  }
  else
  {
    return a1;
  }
}

const __CFString *NSStringFromARReplayMode(uint64_t a1)
{
  if ((unint64_t)(a1 - 1) > 2)
    return CFSTR("Realtime");
  else
    return *(&off_1E6675248 + a1 - 1);
}

uint64_t ARRigInputJoints()
{
  unsigned __int8 v0;
  _OWORD v2[8];
  const char *v3;
  uint64_t v4;

  v4 = *MEMORY[0x1E0C80C00];
  {
    v2[6] = xmmword_1E66752C0;
    v2[7] = *(_OWORD *)off_1E66752D0;
    v3 = "righthand";
    v2[2] = xmmword_1E6675280;
    v2[3] = *(_OWORD *)&off_1E6675290;
    v2[4] = xmmword_1E66752A0;
    v2[5] = *(_OWORD *)&off_1E66752B0;
    v2[0] = xmmword_1E6675260;
    v2[1] = *(_OWORD *)&off_1E6675270;
    std::vector<char const*>::vector[abi:ne180100](&ARRigInputJoints::dataVector, v2, 0x11uLL);
    __cxa_atexit((void (*)(void *))std::vector<char const*>::~vector[abi:ne180100], &ARRigInputJoints::dataVector, &dword_1B3A68000);
  }
  return ARRigInputJoints::dataVector;
}

void sub_1B3B67678(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *std::vector<char const*>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a3);
    v6 = (char *)a1[1];
    memmove(v6, a2, 8 * a3);
    a1[1] = &v6[8 * a3];
  }
  return a1;
}

void sub_1B3B676F4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<char const*>::~vector[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t ARRigOutputJoints()
{
  unsigned __int8 v0;
  _BYTE v2[728];
  uint64_t v3;

  v3 = *MEMORY[0x1E0C80C00];
  {
    memcpy(v2, off_1E66752E8, sizeof(v2));
    std::vector<char const*>::vector[abi:ne180100](&ARRigOutputJoints::dataVector, v2, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<char const*>::~vector[abi:ne180100], &ARRigOutputJoints::dataVector, &dword_1B3A68000);
  }
  return ARRigOutputJoints::dataVector;
}

void sub_1B3B67808(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ARNeutralBodySkeleton3DModelTransforms(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v8;
  uint64_t result;
  _OWORD v10[364];
  uint64_t v11;

  MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v11 = *MEMORY[0x1E0C80C00];
  {
    v10[0] = xmmword_1B3BDFDC0;
    v10[1] = xmmword_1B3BDFDD0;
    v10[2] = xmmword_1B3BDFF70;
    v10[3] = xmmword_1B3C08590;
    v10[4] = xmmword_1B3C085A0;
    v10[5] = xmmword_1B3C085B0;
    v10[6] = xmmword_1B3C085C0;
    v10[7] = xmmword_1B3C085D0;
    v10[8] = xmmword_1B3C085E0;
    v10[9] = xmmword_1B3C085F0;
    v10[10] = xmmword_1B3C08600;
    v10[11] = xmmword_1B3C08610;
    v10[12] = xmmword_1B3C08620;
    v10[13] = xmmword_1B3C08630;
    v10[14] = xmmword_1B3C08640;
    v10[15] = xmmword_1B3C08650;
    v10[16] = xmmword_1B3C08660;
    v10[17] = xmmword_1B3C08670;
    v10[18] = xmmword_1B3C08680;
    v10[19] = xmmword_1B3C08690;
    v10[20] = xmmword_1B3C086A0;
    v10[21] = xmmword_1B3C086B0;
    v10[22] = xmmword_1B3C08680;
    v10[23] = xmmword_1B3C086C0;
    v10[24] = xmmword_1B3C086A0;
    v10[25] = xmmword_1B3C086D0;
    v10[26] = xmmword_1B3C08680;
    v10[27] = xmmword_1B3C086E0;
    v10[28] = xmmword_1B3C086F0;
    v10[29] = xmmword_1B3C08700;
    v10[30] = xmmword_1B3C085A0;
    v10[31] = xmmword_1B3C08710;
    v10[32] = xmmword_1B3C08720;
    v10[33] = xmmword_1B3C08730;
    v10[34] = xmmword_1B3C085A0;
    v10[35] = xmmword_1B3C08740;
    v10[36] = xmmword_1B3C08750;
    v10[37] = xmmword_1B3C08760;
    v10[38] = xmmword_1B3C08770;
    v10[39] = xmmword_1B3C08780;
    v10[40] = xmmword_1B3C08790;
    v10[41] = xmmword_1B3C087A0;
    v10[42] = xmmword_1B3C087B0;
    v10[43] = xmmword_1B3C087C0;
    v10[44] = xmmword_1B3C08790;
    v10[45] = xmmword_1B3C087D0;
    v10[46] = xmmword_1B3C087E0;
    v10[47] = xmmword_1B3C087F0;
    v10[48] = xmmword_1B3C08800;
    v10[49] = xmmword_1B3C08810;
    v10[50] = xmmword_1B3C08820;
    v10[51] = xmmword_1B3C08830;
    v10[52] = xmmword_1B3C08800;
    v10[53] = xmmword_1B3C08810;
    v10[54] = xmmword_1B3C08820;
    v10[55] = xmmword_1B3C08840;
    v10[56] = xmmword_1B3C08800;
    v10[57] = xmmword_1B3C08810;
    v10[58] = xmmword_1B3C08820;
    v10[59] = xmmword_1B3C08850;
    v10[60] = xmmword_1B3C08800;
    v10[61] = xmmword_1B3C08810;
    v10[62] = xmmword_1B3C08820;
    v10[63] = xmmword_1B3C08860;
    v10[64] = xmmword_1B3C08870;
    v10[65] = xmmword_1B3C08880;
    v10[66] = xmmword_1B3C08890;
    v10[67] = xmmword_1B3C088A0;
    v10[68] = xmmword_1B3C088B0;
    v10[69] = xmmword_1B3C088C0;
    v10[70] = xmmword_1B3C088D0;
    v10[71] = xmmword_1B3C088E0;
    v10[72] = xmmword_1B3C088B0;
    v10[73] = xmmword_1B3C088C0;
    v10[74] = xmmword_1B3C088D0;
    v10[75] = xmmword_1B3C088F0;
    v10[76] = xmmword_1B3C08900;
    v10[77] = xmmword_1B3C08910;
    v10[78] = xmmword_1B3C08920;
    v10[79] = xmmword_1B3C08930;
    v10[80] = xmmword_1B3C08940;
    v10[81] = xmmword_1B3C08950;
    v10[82] = xmmword_1B3C08960;
    v10[83] = xmmword_1B3C08970;
    v10[84] = xmmword_1B3C08980;
    v10[85] = xmmword_1B3C08990;
    v10[86] = xmmword_1B3C089A0;
    v10[87] = xmmword_1B3C089B0;
    v10[88] = xmmword_1B3C08980;
    v10[89] = xmmword_1B3C089C0;
    v10[90] = xmmword_1B3C089D0;
    v10[91] = xmmword_1B3C089E0;
    v10[92] = xmmword_1B3C089F0;
    v10[93] = xmmword_1B3C08A00;
    v10[94] = xmmword_1B3C08A10;
    v10[95] = xmmword_1B3C08A20;
    v10[96] = xmmword_1B3C089F0;
    v10[97] = xmmword_1B3C08A00;
    v10[98] = xmmword_1B3C08A10;
    v10[99] = xmmword_1B3C08A30;
    v10[100] = xmmword_1B3C089F0;
    v10[101] = xmmword_1B3C08A00;
    v10[102] = xmmword_1B3C08A10;
    v10[103] = xmmword_1B3C08A40;
    v10[104] = xmmword_1B3C089F0;
    v10[105] = xmmword_1B3C08A00;
    v10[106] = xmmword_1B3C08A10;
    v10[107] = xmmword_1B3C08A50;
    v10[108] = xmmword_1B3C089F0;
    v10[109] = xmmword_1B3C08A00;
    v10[110] = xmmword_1B3C08A10;
    v10[111] = xmmword_1B3C08A60;
    v10[112] = xmmword_1B3C08A70;
    v10[113] = xmmword_1B3C08A80;
    v10[114] = xmmword_1B3C08A90;
    v10[115] = xmmword_1B3C08AA0;
    v10[116] = xmmword_1B3C08A70;
    v10[117] = xmmword_1B3C08A80;
    v10[118] = xmmword_1B3C08A90;
    v10[119] = xmmword_1B3C08AB0;
    v10[120] = xmmword_1B3C08A70;
    v10[121] = xmmword_1B3C08A80;
    v10[122] = xmmword_1B3C08A90;
    v10[123] = xmmword_1B3C08AC0;
    v10[124] = xmmword_1B3C08A70;
    v10[125] = xmmword_1B3C08A80;
    v10[126] = xmmword_1B3C08A90;
    v10[127] = xmmword_1B3C08AD0;
    v10[128] = xmmword_1B3C08A70;
    v10[129] = xmmword_1B3C08A80;
    v10[130] = xmmword_1B3C08A90;
    v10[131] = xmmword_1B3C08AE0;
    v10[132] = xmmword_1B3C08AF0;
    v10[133] = xmmword_1B3C08B00;
    v10[134] = xmmword_1B3C08B10;
    v10[135] = xmmword_1B3C08B20;
    v10[136] = xmmword_1B3C08AF0;
    v10[137] = xmmword_1B3C08B00;
    v10[138] = xmmword_1B3C08B10;
    v10[139] = xmmword_1B3C08B30;
    v10[140] = xmmword_1B3C08AF0;
    v10[141] = xmmword_1B3C08B00;
    v10[142] = xmmword_1B3C08B10;
    v10[143] = xmmword_1B3C08B40;
    v10[144] = xmmword_1B3C08AF0;
    v10[145] = xmmword_1B3C08B00;
    v10[146] = xmmword_1B3C08B10;
    v10[147] = xmmword_1B3C08B50;
    v10[148] = xmmword_1B3C08AF0;
    v10[149] = xmmword_1B3C08B00;
    v10[150] = xmmword_1B3C08B10;
    v10[151] = xmmword_1B3C08B60;
    v10[152] = xmmword_1B3C08B70;
    v10[153] = xmmword_1B3C08B80;
    v10[154] = xmmword_1B3C08B90;
    v10[155] = xmmword_1B3C08BA0;
    v10[156] = xmmword_1B3C08B70;
    v10[157] = xmmword_1B3C08B80;
    v10[158] = xmmword_1B3C08B90;
    v10[159] = xmmword_1B3C08BB0;
    v10[160] = xmmword_1B3C08B70;
    v10[161] = xmmword_1B3C08B80;
    v10[162] = xmmword_1B3C08B90;
    v10[163] = xmmword_1B3C08BC0;
    v10[164] = xmmword_1B3C08B70;
    v10[165] = xmmword_1B3C08B80;
    v10[166] = xmmword_1B3C08B90;
    v10[167] = xmmword_1B3C08BD0;
    v10[168] = xmmword_1B3C08B70;
    v10[169] = xmmword_1B3C08B80;
    v10[170] = xmmword_1B3C08B90;
    v10[171] = xmmword_1B3C08BE0;
    v10[172] = xmmword_1B3C08BF0;
    v10[173] = xmmword_1B3C08C00;
    v10[174] = xmmword_1B3C08C10;
    v10[175] = xmmword_1B3C08C20;
    v10[176] = xmmword_1B3C08BF0;
    v10[177] = xmmword_1B3C08C00;
    v10[178] = xmmword_1B3C08C10;
    v10[179] = xmmword_1B3C08C30;
    v10[180] = xmmword_1B3C08BF0;
    v10[181] = xmmword_1B3C08C00;
    v10[182] = xmmword_1B3C08C10;
    v10[183] = xmmword_1B3C08C40;
    v10[184] = xmmword_1B3C08BF0;
    v10[185] = xmmword_1B3C08C00;
    v10[186] = xmmword_1B3C08C10;
    v10[187] = xmmword_1B3C08C50;
    v10[188] = xmmword_1B3C08C60;
    v10[189] = xmmword_1B3C08C70;
    v10[190] = xmmword_1B3C088D0;
    v10[191] = xmmword_1B3C08C80;
    v10[192] = xmmword_1B3C08C90;
    v10[193] = xmmword_1B3C08CA0;
    v10[194] = xmmword_1B3C08CB0;
    v10[195] = xmmword_1B3C08CC0;
    v10[196] = xmmword_1B3C08C90;
    v10[197] = xmmword_1B3C08CA0;
    v10[198] = xmmword_1B3C08CB0;
    v10[199] = xmmword_1B3C08CD0;
    v10[200] = xmmword_1B3C08C90;
    v10[201] = xmmword_1B3C08CA0;
    v10[202] = xmmword_1B3C08CB0;
    v10[203] = xmmword_1B3C08CE0;
    v10[204] = xmmword_1B3C08CF0;
    v10[205] = xmmword_1B3C08D00;
    v10[206] = xmmword_1B3C08D10;
    v10[207] = xmmword_1B3C08D20;
    v10[208] = xmmword_1B3C08CF0;
    v10[209] = xmmword_1B3C08D00;
    v10[210] = xmmword_1B3C08D10;
    v10[211] = xmmword_1B3C08D30;
    v10[212] = xmmword_1B3C08CF0;
    v10[213] = xmmword_1B3C08D00;
    v10[214] = xmmword_1B3C08D10;
    v10[215] = xmmword_1B3C08D40;
    v10[216] = xmmword_1B3C08D50;
    v10[217] = xmmword_1B3C08D60;
    v10[218] = xmmword_1B3C08D10;
    v10[219] = xmmword_1B3C08D70;
    v10[220] = xmmword_1B3C08D50;
    v10[221] = xmmword_1B3C08D60;
    v10[222] = xmmword_1B3C08D10;
    v10[223] = xmmword_1B3C08D70;
    v10[224] = xmmword_1B3C08D50;
    v10[225] = xmmword_1B3C08D60;
    v10[226] = xmmword_1B3C08D10;
    v10[227] = xmmword_1B3C08D70;
    v10[228] = xmmword_1B3C08D50;
    v10[229] = xmmword_1B3C08D60;
    v10[230] = xmmword_1B3C08D10;
    v10[231] = xmmword_1B3C08D70;
    v10[232] = xmmword_1B3C08D80;
    v10[233] = xmmword_1B3C08D90;
    v10[234] = xmmword_1B3C08D10;
    v10[235] = xmmword_1B3C08DA0;
    v10[236] = xmmword_1B3C08D50;
    v10[237] = xmmword_1B3C08D60;
    v10[238] = xmmword_1B3C08D10;
    v10[239] = xmmword_1B3C08DB0;
    v10[240] = xmmword_1B3C08D50;
    v10[241] = xmmword_1B3C08D60;
    v10[242] = xmmword_1B3C08D10;
    v10[243] = xmmword_1B3C08DB0;
    v10[244] = xmmword_1B3C08D50;
    v10[245] = xmmword_1B3C08D60;
    v10[246] = xmmword_1B3C08D10;
    v10[247] = xmmword_1B3C08DB0;
    v10[248] = xmmword_1B3C08D50;
    v10[249] = xmmword_1B3C08D60;
    v10[250] = xmmword_1B3C08D10;
    v10[251] = xmmword_1B3C08DB0;
    v10[252] = xmmword_1B3C08DC0;
    v10[253] = xmmword_1B3C08DD0;
    v10[254] = xmmword_1B3C08DE0;
    v10[255] = xmmword_1B3C08DF0;
    v10[256] = xmmword_1B3C08E00;
    v10[257] = xmmword_1B3C08E10;
    v10[258] = xmmword_1B3C08E20;
    v10[259] = xmmword_1B3C08E30;
    v10[260] = xmmword_1B3C08E40;
    v10[261] = xmmword_1B3C08E50;
    v10[262] = xmmword_1B3C08E60;
    v10[263] = xmmword_1B3C08E70;
    v10[264] = xmmword_1B3C08E40;
    v10[265] = xmmword_1B3C08E80;
    v10[266] = xmmword_1B3C08E50;
    v10[267] = xmmword_1B3C08E90;
    v10[268] = xmmword_1B3C08EA0;
    v10[269] = xmmword_1B3C08EB0;
    v10[270] = xmmword_1B3C08EC0;
    v10[271] = xmmword_1B3C08ED0;
    v10[272] = xmmword_1B3C08EA0;
    v10[273] = xmmword_1B3C08EB0;
    v10[274] = xmmword_1B3C08EC0;
    v10[275] = xmmword_1B3C08EE0;
    v10[276] = xmmword_1B3C08EA0;
    v10[277] = xmmword_1B3C08EB0;
    v10[278] = xmmword_1B3C08EC0;
    v10[279] = xmmword_1B3C08EF0;
    v10[280] = xmmword_1B3C08EA0;
    v10[281] = xmmword_1B3C08EB0;
    v10[282] = xmmword_1B3C08EC0;
    v10[283] = xmmword_1B3C08F00;
    v10[284] = xmmword_1B3C08EA0;
    v10[285] = xmmword_1B3C08EB0;
    v10[286] = xmmword_1B3C08EC0;
    v10[287] = xmmword_1B3C08F10;
    v10[288] = xmmword_1B3C08F20;
    v10[289] = xmmword_1B3C08F30;
    v10[290] = xmmword_1B3C08F40;
    v10[291] = xmmword_1B3C08F50;
    v10[292] = xmmword_1B3C08F20;
    v10[293] = xmmword_1B3C08F30;
    v10[294] = xmmword_1B3C08F40;
    v10[295] = xmmword_1B3C08F60;
    v10[296] = xmmword_1B3C08F20;
    v10[297] = xmmword_1B3C08F30;
    v10[298] = xmmword_1B3C08F40;
    v10[299] = xmmword_1B3C08F70;
    v10[300] = xmmword_1B3C08F20;
    v10[301] = xmmword_1B3C08F30;
    v10[302] = xmmword_1B3C08F40;
    v10[303] = xmmword_1B3C08F80;
    v10[304] = xmmword_1B3C08F20;
    v10[305] = xmmword_1B3C08F30;
    v10[306] = xmmword_1B3C08F40;
    v10[307] = xmmword_1B3C08F90;
    v10[308] = xmmword_1B3C08FA0;
    v10[309] = xmmword_1B3C08FB0;
    v10[310] = xmmword_1B3C08FC0;
    v10[311] = xmmword_1B3C08FD0;
    v10[312] = xmmword_1B3C08FA0;
    v10[313] = xmmword_1B3C08FB0;
    v10[314] = xmmword_1B3C08FC0;
    v10[315] = xmmword_1B3C08FE0;
    v10[316] = xmmword_1B3C08FA0;
    v10[317] = xmmword_1B3C08FB0;
    v10[318] = xmmword_1B3C08FC0;
    v10[319] = xmmword_1B3C08FF0;
    v10[320] = xmmword_1B3C08FA0;
    v10[321] = xmmword_1B3C08FB0;
    v10[322] = xmmword_1B3C08FC0;
    v10[323] = xmmword_1B3C09000;
    v10[324] = xmmword_1B3C08FA0;
    v10[325] = xmmword_1B3C08FB0;
    v10[326] = xmmword_1B3C08FC0;
    v10[327] = xmmword_1B3C09010;
    v10[328] = xmmword_1B3C09020;
    v10[329] = xmmword_1B3C09030;
    v10[330] = xmmword_1B3C09040;
    v10[331] = xmmword_1B3C09050;
    v10[332] = xmmword_1B3C09020;
    v10[333] = xmmword_1B3C09030;
    v10[334] = xmmword_1B3C09040;
    v10[335] = xmmword_1B3C09060;
    v10[336] = xmmword_1B3C09020;
    v10[337] = xmmword_1B3C09030;
    v10[338] = xmmword_1B3C09040;
    v10[339] = xmmword_1B3C09070;
    v10[340] = xmmword_1B3C09020;
    v10[341] = xmmword_1B3C09030;
    v10[342] = xmmword_1B3C09040;
    v10[343] = xmmword_1B3C09080;
    v10[344] = xmmword_1B3C09020;
    v10[345] = xmmword_1B3C09030;
    v10[346] = xmmword_1B3C09040;
    v10[347] = xmmword_1B3C09090;
    v10[348] = xmmword_1B3C090A0;
    v10[349] = xmmword_1B3C090B0;
    v10[350] = xmmword_1B3C090C0;
    v10[351] = xmmword_1B3C090D0;
    v10[352] = xmmword_1B3C090A0;
    v10[353] = xmmword_1B3C090B0;
    v10[354] = xmmword_1B3C090C0;
    v10[355] = xmmword_1B3C090E0;
    v10[356] = xmmword_1B3C090A0;
    v10[357] = xmmword_1B3C090B0;
    v10[358] = xmmword_1B3C090C0;
    v10[359] = xmmword_1B3C090F0;
    v10[360] = xmmword_1B3C090A0;
    v10[361] = xmmword_1B3C090B0;
    v10[362] = xmmword_1B3C090C0;
    v10[363] = xmmword_1B3C09100;
    std::vector<simd_float4x4>::vector[abi:ne180100](&ARNeutralBodySkeleton3DModelTransforms::dataVector, v10, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<simd_float4x4>::~vector[abi:ne180100], &ARNeutralBodySkeleton3DModelTransforms::dataVector, &dword_1B3A68000);
  }
  result = ARNeutralBodySkeleton3DModelTransforms::dataVector;
  if (*(_QWORD *)algn_1EF082810 - ARNeutralBodySkeleton3DModelTransforms::dataVector != 5824)
    ARNeutralBodySkeleton3DModelTransforms_cold_1();
  return result;
}

void sub_1B3B68410(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *std::vector<simd_float4x4>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  char *v6;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<simd_float4x4>::__vallocate[abi:ne180100](a1, a3);
    v6 = (char *)a1[1];
    memmove(v6, a2, a3 << 6);
    a1[1] = &v6[64 * a3];
  }
  return a1;
}

void sub_1B3B68490(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<simd_float4x4>::~vector[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

uint64_t ARNeutralBodySkeleton3DLocalTransforms(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned __int8 v8;
  uint64_t result;
  __n128 v15;
  __int128 v16;
  int v17;
  uint64_t v18;
  __n128 v20;
  __int128 v21;
  int v22;
  uint64_t v23;
  __n128 v25;
  __int128 v26;
  int v27;
  uint64_t v28;
  __n128 v30;
  __int128 v31;
  int v32;
  uint64_t v33;
  __n128 v35;
  __int128 v36;
  int v37;
  uint64_t v38;
  __n128 v40;
  __int128 v41;
  int v42;
  uint64_t v43;
  __n128 v45;
  __int128 v46;
  int v47;
  uint64_t v48;
  __n128 v50;
  __int128 v51;
  int v52;
  uint64_t v53;
  __n128 v55;
  __int128 v56;
  int v57;
  uint64_t v58;
  __n128 v60;
  __int128 v61;
  int v62;
  uint64_t v63;
  __n128 v65;
  __int128 v66;
  int v67;
  uint64_t v68;
  __n128 v70;
  __int128 v71;
  int v72;
  uint64_t v73;
  __n128 v75;
  __int128 v76;
  int v77;
  uint64_t v78;
  __n128 v80;
  __int128 v81;
  int v82;
  uint64_t v83;
  __n128 v85;
  __int128 v86;
  int v87;
  uint64_t v88;
  __n128 v90;
  __int128 v91;
  int v92;
  uint64_t v93;
  __n128 v95;
  __int128 v96;
  int v97;
  uint64_t v98;
  __n128 v100;
  __int128 v101;
  int v102;
  uint64_t v103;
  __n128 v105;
  __int128 v106;
  int v107;
  uint64_t v108;
  __n128 v110;
  __int128 v111;
  int v112;
  uint64_t v113;
  __n128 v115;
  __int128 v116;
  int v117;
  uint64_t v118;
  __n128 v120;
  __int128 v121;
  int v122;
  uint64_t v123;
  __n128 v125;
  __int128 v126;
  int v127;
  uint64_t v128;
  __n128 v130;
  __int128 v131;
  int v132;
  uint64_t v133;
  __n128 v135;
  __int128 v136;
  int v137;
  uint64_t v138;
  __n128 v140;
  __int128 v141;
  int v142;
  uint64_t v143;
  __n128 v145;
  __int128 v146;
  int v147;
  uint64_t v148;
  __n128 v150;
  __int128 v151;
  int v152;
  uint64_t v153;
  __n128 v155;
  __int128 v156;
  int v157;
  uint64_t v158;
  __n128 v160;
  __int128 v161;
  int v162;
  uint64_t v163;
  __n128 v165;
  __int128 v166;
  int v167;
  uint64_t v168;
  __n128 v170;
  __int128 v171;
  int v172;
  uint64_t v173;
  __n128 v175;
  __int128 v176;
  int v177;
  uint64_t v178;
  __n128 v180;
  __int128 v181;
  int v182;
  uint64_t v183;
  __n128 v185;
  __int128 v186;
  int v187;
  uint64_t v188;
  __n128 v190;
  __int128 v191;
  int v192;
  uint64_t v193;
  __n128 v195;
  __int128 v196;
  int v197;
  uint64_t v198;
  __n128 v200;
  __int128 v201;
  int v202;
  uint64_t v203;
  __n128 v205;
  __int128 v206;
  int v207;
  uint64_t v208;
  __n128 v210;
  __int128 v211;
  int v212;
  uint64_t v213;
  __n128 v215;
  __int128 v216;
  int v217;
  uint64_t v218;
  __n128 v220;
  __int128 v221;
  int v222;
  uint64_t v223;
  __n128 v225;
  __int128 v226;
  int v227;
  uint64_t v228;
  __n128 v230;
  __int128 v231;
  int v232;
  uint64_t v233;
  __n128 v235;
  __int128 v236;
  int v237;
  uint64_t v238;
  __n128 v240;
  __int128 v241;
  int v242;
  uint64_t v243;
  __n128 v245;
  __int128 v246;
  int v247;
  uint64_t v248;
  __n128 v250;
  __int128 v251;
  int v252;
  uint64_t v253;
  __n128 v255;
  __int128 v256;
  int v257;
  uint64_t v258;
  __n128 v260;
  __int128 v261;
  int v262;
  uint64_t v263;
  __n128 v265;
  __int128 v266;
  int v267;
  uint64_t v268;
  __n128 v270;
  __int128 v271;
  int v272;
  uint64_t v273;
  __n128 v275;
  __int128 v276;
  int v277;
  uint64_t v278;
  __n128 v280;
  __int128 v281;
  int v282;
  uint64_t v283;
  __n128 v285;
  __int128 v286;
  int v287;
  uint64_t v288;
  __n128 v290;
  __int128 v291;
  int v292;
  uint64_t v293;
  __n128 v295;
  __int128 v296;
  int v297;
  uint64_t v298;
  __n128 v300;
  __int128 v301;
  int v302;
  uint64_t v303;
  __n128 v305;
  __int128 v306;
  int v307;
  uint64_t v308;
  __n128 v310;
  __int128 v311;
  int v312;
  uint64_t v313;
  __n128 v315;
  __int128 v316;
  int v317;
  uint64_t v318;
  __n128 v320;
  __int128 v321;
  int v322;
  uint64_t v323;
  __n128 v325;
  __int128 v326;
  int v327;
  uint64_t v328;
  __n128 v330;
  __int128 v331;
  int v332;
  uint64_t v333;
  __n128 v335;
  __int128 v336;
  int v337;
  uint64_t v338;
  __n128 v340;
  __int128 v341;
  int v342;
  uint64_t v343;
  __n128 v345;
  __int128 v346;
  int v347;
  uint64_t v348;
  __n128 v350;
  __int128 v351;
  int v352;
  uint64_t v353;
  __n128 v355;
  __int128 v356;
  int v357;
  uint64_t v358;
  __n128 v360;
  __int128 v361;
  int v362;
  uint64_t v363;
  __n128 v365;
  __int128 v366;
  int v367;
  uint64_t v368;
  __n128 v370;
  __int128 v371;
  int v372;
  uint64_t v373;
  __n128 v375;
  __int128 v376;
  int v377;
  uint64_t v378;
  __n128 v380;
  __int128 v381;
  int v382;
  uint64_t v383;
  __n128 v385;
  __int128 v386;
  int v387;
  uint64_t v388;
  __n128 v390;
  __int128 v391;
  int v392;
  uint64_t v393;
  __n128 v395;
  __int128 v396;
  int v397;
  uint64_t v398;
  __n128 v400;
  __int128 v401;
  int v402;
  uint64_t v403;
  __n128 v405;
  __int128 v406;
  int v407;
  uint64_t v408;
  __n128 v410;
  __int128 v411;
  int v412;
  uint64_t v413;
  __n128 v415;
  __int128 v416;
  int v417;
  uint64_t v418;
  __n128 v420;
  __int128 v421;
  int v422;
  uint64_t v423;
  __n128 v425;
  __int128 v426;
  int v427;
  uint64_t v428;
  __n128 v430;
  __int128 v431;
  int v432;
  uint64_t v433;
  __n128 v435;
  __int128 v436;
  int v437;
  uint64_t v438;
  __n128 v440;
  __int128 v441;
  int v442;
  uint64_t v443;
  __n128 v445;
  __int128 v446;
  int v447;
  uint64_t v448;
  __n128 v450;
  __int128 v451;
  int v452;
  uint64_t v453;
  __n128 v455;
  __int128 v456;
  int v457;
  uint64_t v458;
  __n128 v460;
  __int128 v461;
  int v462;
  uint64_t v463;
  __n128 v465;
  __int128 v466;
  int v467;
  uint64_t v468;
  unint64_t v469;
  unsigned __int32 v470;
  __int128 v471;
  uint64_t v472;
  int v473;
  unint64_t v474;
  unsigned __int32 v475;
  __int128 v476;
  uint64_t v477;
  int v478;
  unint64_t v479;
  unsigned __int32 v480;
  __int128 v481;
  uint64_t v482;
  int v483;
  unint64_t v484;
  unsigned __int32 v485;
  __int128 v486;
  uint64_t v487;
  int v488;
  unint64_t v489;
  unsigned __int32 v490;
  __int128 v491;
  uint64_t v492;
  int v493;
  unint64_t v494;
  unsigned __int32 v495;
  __int128 v496;
  uint64_t v497;
  int v498;
  unint64_t v499;
  unsigned __int32 v500;
  __int128 v501;
  uint64_t v502;
  int v503;
  unint64_t v504;
  unsigned __int32 v505;
  __int128 v506;
  uint64_t v507;
  int v508;
  unint64_t v509;
  unsigned __int32 v510;
  __int128 v511;
  uint64_t v512;
  int v513;
  unint64_t v514;
  unsigned __int32 v515;
  __int128 v516;
  uint64_t v517;
  int v518;
  unint64_t v519;
  unsigned __int32 v520;
  __int128 v521;
  uint64_t v522;
  int v523;
  unint64_t v524;
  unsigned __int32 v525;
  __int128 v526;
  uint64_t v527;
  int v528;
  unint64_t v529;
  unsigned __int32 v530;
  __int128 v531;
  uint64_t v532;
  int v533;
  unint64_t v534;
  unsigned __int32 v535;
  __int128 v536;
  uint64_t v537;
  int v538;
  unint64_t v539;
  unsigned __int32 v540;
  __int128 v541;
  uint64_t v542;
  int v543;
  unint64_t v544;
  unsigned __int32 v545;
  __int128 v546;
  uint64_t v547;
  int v548;
  unint64_t v549;
  unsigned __int32 v550;
  __int128 v551;
  uint64_t v552;
  int v553;
  unint64_t v554;
  unsigned __int32 v555;
  __int128 v556;
  uint64_t v557;
  int v558;
  unint64_t v559;
  unsigned __int32 v560;
  __int128 v561;
  uint64_t v562;
  int v563;
  unint64_t v564;
  unsigned __int32 v565;
  __int128 v566;
  uint64_t v567;
  int v568;
  unint64_t v569;
  unsigned __int32 v570;
  __int128 v571;
  uint64_t v572;
  int v573;
  unint64_t v574;
  unsigned __int32 v575;
  __int128 v576;
  uint64_t v577;
  int v578;
  unint64_t v579;
  unsigned __int32 v580;
  __int128 v581;
  uint64_t v582;
  int v583;
  unint64_t v584;
  unsigned __int32 v585;
  __int128 v586;
  uint64_t v587;
  int v588;
  unint64_t v589;
  unsigned __int32 v590;
  __int128 v591;
  uint64_t v592;
  int v593;
  unint64_t v594;
  unsigned __int32 v595;
  __int128 v596;
  uint64_t v597;
  int v598;
  unint64_t v599;
  unsigned __int32 v600;
  __int128 v601;
  uint64_t v602;
  int v603;
  unint64_t v604;
  unsigned __int32 v605;
  __int128 v606;
  uint64_t v607;
  int v608;
  unint64_t v609;
  unsigned __int32 v610;
  __int128 v611;
  uint64_t v612;
  int v613;
  unint64_t v614;
  unsigned __int32 v615;
  __int128 v616;
  uint64_t v617;
  int v618;
  unint64_t v619;
  unsigned __int32 v620;
  __int128 v621;
  uint64_t v622;
  int v623;
  unint64_t v624;
  unsigned __int32 v625;
  __int128 v626;
  uint64_t v627;
  int v628;
  unint64_t v629;
  unsigned __int32 v630;
  __int128 v631;
  uint64_t v632;
  int v633;
  unint64_t v634;
  unsigned __int32 v635;
  __int128 v636;
  uint64_t v637;
  int v638;
  unint64_t v639;
  unsigned __int32 v640;
  __int128 v641;
  uint64_t v642;
  int v643;
  unint64_t v644;
  unsigned __int32 v645;
  __int128 v646;
  uint64_t v647;
  int v648;
  unint64_t v649;
  unsigned __int32 v650;
  __int128 v651;
  uint64_t v652;
  int v653;
  unint64_t v654;
  unsigned __int32 v655;
  __int128 v656;
  uint64_t v657;
  int v658;
  unint64_t v659;
  unsigned __int32 v660;
  __int128 v661;
  uint64_t v662;
  int v663;
  unint64_t v664;
  unsigned __int32 v665;
  __int128 v666;
  uint64_t v667;
  int v668;
  unint64_t v669;
  unsigned __int32 v670;
  __int128 v671;
  uint64_t v672;
  int v673;
  unint64_t v674;
  unsigned __int32 v675;
  __int128 v676;
  uint64_t v677;
  int v678;
  unint64_t v679;
  unsigned __int32 v680;
  __int128 v681;
  uint64_t v682;
  int v683;
  unint64_t v684;
  unsigned __int32 v685;
  __int128 v686;
  uint64_t v687;
  int v688;
  unint64_t v689;
  unsigned __int32 v690;
  __int128 v691;
  uint64_t v692;
  int v693;
  unint64_t v694;
  unsigned __int32 v695;
  __int128 v696;
  uint64_t v697;
  int v698;
  unint64_t v699;
  unsigned __int32 v700;
  __int128 v701;
  uint64_t v702;
  int v703;
  unint64_t v704;
  unsigned __int32 v705;
  __int128 v706;
  uint64_t v707;
  int v708;
  unint64_t v709;
  unsigned __int32 v710;
  __int128 v711;
  uint64_t v712;
  int v713;
  unint64_t v714;
  unsigned __int32 v715;
  __int128 v716;
  uint64_t v717;
  int v718;
  unint64_t v719;
  unsigned __int32 v720;
  __int128 v721;
  uint64_t v722;
  int v723;
  unint64_t v724;
  unsigned __int32 v725;
  __int128 v726;
  uint64_t v727;
  int v728;
  unint64_t v729;
  unsigned __int32 v730;
  __int128 v731;
  uint64_t v732;
  int v733;
  unint64_t v734;
  unsigned __int32 v735;
  __int128 v736;
  uint64_t v737;
  int v738;
  unint64_t v739;
  unsigned __int32 v740;
  __int128 v741;
  uint64_t v742;
  int v743;
  unint64_t v744;
  unsigned __int32 v745;
  __int128 v746;
  uint64_t v747;
  int v748;
  unint64_t v749;
  unsigned __int32 v750;
  __int128 v751;
  uint64_t v752;
  int v753;
  unint64_t v754;
  unsigned __int32 v755;
  __int128 v756;
  uint64_t v757;
  int v758;
  unint64_t v759;
  unsigned __int32 v760;
  __int128 v761;
  uint64_t v762;
  int v763;
  unint64_t v764;
  unsigned __int32 v765;
  __int128 v766;
  uint64_t v767;
  int v768;
  unint64_t v769;
  unsigned __int32 v770;
  __int128 v771;
  uint64_t v772;
  int v773;
  unint64_t v774;
  unsigned __int32 v775;
  __int128 v776;
  uint64_t v777;
  int v778;
  unint64_t v779;
  unsigned __int32 v780;
  __int128 v781;
  uint64_t v782;
  int v783;
  unint64_t v784;
  unsigned __int32 v785;
  __int128 v786;
  uint64_t v787;
  int v788;
  unint64_t v789;
  unsigned __int32 v790;
  __int128 v791;
  uint64_t v792;
  int v793;
  unint64_t v794;
  unsigned __int32 v795;
  __int128 v796;
  uint64_t v797;
  int v798;
  unint64_t v799;
  unsigned __int32 v800;
  __int128 v801;
  uint64_t v802;
  int v803;
  unint64_t v804;
  unsigned __int32 v805;
  __int128 v806;
  uint64_t v807;
  int v808;
  unint64_t v809;
  unsigned __int32 v810;
  __int128 v811;
  uint64_t v812;
  int v813;
  unint64_t v814;
  unsigned __int32 v815;
  __int128 v816;
  uint64_t v817;
  int v818;
  unint64_t v819;
  unsigned __int32 v820;
  __int128 v821;
  uint64_t v822;
  int v823;
  unint64_t v824;
  unsigned __int32 v825;
  __int128 v826;
  uint64_t v827;
  int v828;
  unint64_t v829;
  unsigned __int32 v830;
  __int128 v831;
  uint64_t v832;
  int v833;
  unint64_t v834;
  unsigned __int32 v835;
  __int128 v836;
  uint64_t v837;
  int v838;
  unint64_t v839;
  unsigned __int32 v840;
  __int128 v841;
  uint64_t v842;
  int v843;
  unint64_t v844;
  unsigned __int32 v845;
  __int128 v846;
  uint64_t v847;
  int v848;
  unint64_t v849;
  unsigned __int32 v850;
  __int128 v851;
  uint64_t v852;
  int v853;
  unint64_t v854;
  unsigned __int32 v855;
  __int128 v856;
  uint64_t v857;
  int v858;
  unint64_t v859;
  unsigned __int32 v860;
  __int128 v861;
  uint64_t v862;
  int v863;
  unint64_t v864;
  unsigned __int32 v865;
  __int128 v866;
  uint64_t v867;
  int v868;
  unint64_t v869;
  unsigned __int32 v870;
  __int128 v871;
  uint64_t v872;
  int v873;
  unint64_t v874;
  unsigned __int32 v875;
  __int128 v876;
  uint64_t v877;
  int v878;
  unint64_t v879;
  unsigned __int32 v880;
  __int128 v881;
  uint64_t v882;
  int v883;
  unint64_t v884;
  unsigned __int32 v885;
  __int128 v886;
  uint64_t v887;
  int v888;
  unint64_t v889;
  unsigned __int32 v890;
  __int128 v891;
  uint64_t v892;
  int v893;
  unint64_t v894;
  unsigned __int32 v895;
  __int128 v896;
  uint64_t v897;
  int v898;
  unint64_t v899;
  unsigned __int32 v900;
  __int128 v901;
  uint64_t v902;
  int v903;
  unint64_t v904;
  unsigned __int32 v905;
  __int128 v906;
  uint64_t v907;
  int v908;
  unint64_t v909;
  unsigned __int32 v910;
  __int128 v911;
  uint64_t v912;
  int v913;
  unint64_t v914;
  unsigned __int32 v915;
  __int128 v916;
  uint64_t v917;
  int v918;
  unint64_t v919;
  unsigned __int32 v920;
  __int128 v921;
  uint64_t v922;
  int v923;
  uint64_t v924;

  MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v924 = *MEMORY[0x1E0C80C00];
  {
    __asm { FMOV            V0.4S, #1.0 }
    v15 = ARMakeSRT(_Q0);
    v470 = v15.n128_u32[2];
    v469 = v15.n128_u64[0];
    v471 = v16;
    v473 = v17;
    v472 = v18;
    __asm { FMOV            V0.4S, #1.0 }
    v20 = ARMakeSRT(_Q0);
    v475 = v20.n128_u32[2];
    v474 = v20.n128_u64[0];
    v476 = v21;
    v478 = v22;
    v477 = v23;
    __asm { FMOV            V0.4S, #1.0 }
    v25 = ARMakeSRT(_Q0);
    v480 = v25.n128_u32[2];
    v479 = v25.n128_u64[0];
    v481 = v26;
    v483 = v27;
    v482 = v28;
    __asm { FMOV            V0.4S, #1.0 }
    v30 = ARMakeSRT(_Q0);
    v485 = v30.n128_u32[2];
    v484 = v30.n128_u64[0];
    v486 = v31;
    v488 = v32;
    v487 = v33;
    __asm { FMOV            V0.4S, #1.0 }
    v35 = ARMakeSRT(_Q0);
    v490 = v35.n128_u32[2];
    v489 = v35.n128_u64[0];
    v491 = v36;
    v493 = v37;
    v492 = v38;
    __asm { FMOV            V0.4S, #1.0 }
    v40 = ARMakeSRT(_Q0);
    v495 = v40.n128_u32[2];
    v494 = v40.n128_u64[0];
    v496 = v41;
    v498 = v42;
    v497 = v43;
    __asm { FMOV            V0.4S, #1.0 }
    v45 = ARMakeSRT(_Q0);
    v500 = v45.n128_u32[2];
    v499 = v45.n128_u64[0];
    v501 = v46;
    v503 = v47;
    v502 = v48;
    __asm { FMOV            V0.4S, #1.0 }
    v50 = ARMakeSRT(_Q0);
    v505 = v50.n128_u32[2];
    v504 = v50.n128_u64[0];
    v506 = v51;
    v508 = v52;
    v507 = v53;
    __asm { FMOV            V0.4S, #1.0 }
    v55 = ARMakeSRT(_Q0);
    v510 = v55.n128_u32[2];
    v509 = v55.n128_u64[0];
    v511 = v56;
    v513 = v57;
    v512 = v58;
    __asm { FMOV            V0.4S, #1.0 }
    v60 = ARMakeSRT(_Q0);
    v515 = v60.n128_u32[2];
    v514 = v60.n128_u64[0];
    v516 = v61;
    v518 = v62;
    v517 = v63;
    __asm { FMOV            V0.4S, #1.0 }
    v65 = ARMakeSRT(_Q0);
    v520 = v65.n128_u32[2];
    v519 = v65.n128_u64[0];
    v521 = v66;
    v523 = v67;
    v522 = v68;
    __asm { FMOV            V0.4S, #1.0 }
    v70 = ARMakeSRT(_Q0);
    v525 = v70.n128_u32[2];
    v524 = v70.n128_u64[0];
    v526 = v71;
    v528 = v72;
    v527 = v73;
    __asm { FMOV            V0.4S, #1.0 }
    v75 = ARMakeSRT(_Q0);
    v530 = v75.n128_u32[2];
    v529 = v75.n128_u64[0];
    v531 = v76;
    v533 = v77;
    v532 = v78;
    __asm { FMOV            V0.4S, #1.0 }
    v80 = ARMakeSRT(_Q0);
    v535 = v80.n128_u32[2];
    v534 = v80.n128_u64[0];
    v536 = v81;
    v538 = v82;
    v537 = v83;
    __asm { FMOV            V0.4S, #1.0 }
    v85 = ARMakeSRT(_Q0);
    v540 = v85.n128_u32[2];
    v539 = v85.n128_u64[0];
    v541 = v86;
    v543 = v87;
    v542 = v88;
    __asm { FMOV            V0.4S, #1.0 }
    v90 = ARMakeSRT(_Q0);
    v545 = v90.n128_u32[2];
    v544 = v90.n128_u64[0];
    v546 = v91;
    v548 = v92;
    v547 = v93;
    __asm { FMOV            V0.4S, #1.0 }
    v95 = ARMakeSRT(_Q0);
    v550 = v95.n128_u32[2];
    v549 = v95.n128_u64[0];
    v551 = v96;
    v553 = v97;
    v552 = v98;
    __asm { FMOV            V0.4S, #1.0 }
    v100 = ARMakeSRT(_Q0);
    v555 = v100.n128_u32[2];
    v554 = v100.n128_u64[0];
    v556 = v101;
    v558 = v102;
    v557 = v103;
    __asm { FMOV            V0.4S, #1.0 }
    v105 = ARMakeSRT(_Q0);
    v560 = v105.n128_u32[2];
    v559 = v105.n128_u64[0];
    v561 = v106;
    v563 = v107;
    v562 = v108;
    __asm { FMOV            V0.4S, #1.0 }
    v110 = ARMakeSRT(_Q0);
    v565 = v110.n128_u32[2];
    v564 = v110.n128_u64[0];
    v566 = v111;
    v568 = v112;
    v567 = v113;
    __asm { FMOV            V0.4S, #1.0 }
    v115 = ARMakeSRT(_Q0);
    v570 = v115.n128_u32[2];
    v569 = v115.n128_u64[0];
    v571 = v116;
    v573 = v117;
    v572 = v118;
    __asm { FMOV            V0.4S, #1.0 }
    v120 = ARMakeSRT(_Q0);
    v575 = v120.n128_u32[2];
    v574 = v120.n128_u64[0];
    v576 = v121;
    v578 = v122;
    v577 = v123;
    __asm { FMOV            V0.4S, #1.0 }
    v125 = ARMakeSRT(_Q0);
    v580 = v125.n128_u32[2];
    v579 = v125.n128_u64[0];
    v581 = v126;
    v583 = v127;
    v582 = v128;
    __asm { FMOV            V0.4S, #1.0 }
    v130 = ARMakeSRT(_Q0);
    v585 = v130.n128_u32[2];
    v584 = v130.n128_u64[0];
    v586 = v131;
    v588 = v132;
    v587 = v133;
    __asm { FMOV            V0.4S, #1.0 }
    v135 = ARMakeSRT(_Q0);
    v590 = v135.n128_u32[2];
    v589 = v135.n128_u64[0];
    v591 = v136;
    v593 = v137;
    v592 = v138;
    __asm { FMOV            V0.4S, #1.0 }
    v140 = ARMakeSRT(_Q0);
    v595 = v140.n128_u32[2];
    v594 = v140.n128_u64[0];
    v596 = v141;
    v598 = v142;
    v597 = v143;
    __asm { FMOV            V0.4S, #1.0 }
    v145 = ARMakeSRT(_Q0);
    v600 = v145.n128_u32[2];
    v599 = v145.n128_u64[0];
    v601 = v146;
    v603 = v147;
    v602 = v148;
    __asm { FMOV            V0.4S, #1.0 }
    v150 = ARMakeSRT(_Q0);
    v605 = v150.n128_u32[2];
    v604 = v150.n128_u64[0];
    v606 = v151;
    v608 = v152;
    v607 = v153;
    __asm { FMOV            V0.4S, #1.0 }
    v155 = ARMakeSRT(_Q0);
    v610 = v155.n128_u32[2];
    v609 = v155.n128_u64[0];
    v611 = v156;
    v613 = v157;
    v612 = v158;
    __asm { FMOV            V0.4S, #1.0 }
    v160 = ARMakeSRT(_Q0);
    v615 = v160.n128_u32[2];
    v614 = v160.n128_u64[0];
    v616 = v161;
    v618 = v162;
    v617 = v163;
    __asm { FMOV            V0.4S, #1.0 }
    v165 = ARMakeSRT(_Q0);
    v620 = v165.n128_u32[2];
    v619 = v165.n128_u64[0];
    v621 = v166;
    v623 = v167;
    v622 = v168;
    __asm { FMOV            V0.4S, #1.0 }
    v170 = ARMakeSRT(_Q0);
    v625 = v170.n128_u32[2];
    v624 = v170.n128_u64[0];
    v626 = v171;
    v628 = v172;
    v627 = v173;
    __asm { FMOV            V0.4S, #1.0 }
    v175 = ARMakeSRT(_Q0);
    v630 = v175.n128_u32[2];
    v629 = v175.n128_u64[0];
    v631 = v176;
    v633 = v177;
    v632 = v178;
    __asm { FMOV            V0.4S, #1.0 }
    v180 = ARMakeSRT(_Q0);
    v635 = v180.n128_u32[2];
    v634 = v180.n128_u64[0];
    v636 = v181;
    v638 = v182;
    v637 = v183;
    __asm { FMOV            V0.4S, #1.0 }
    v185 = ARMakeSRT(_Q0);
    v640 = v185.n128_u32[2];
    v639 = v185.n128_u64[0];
    v641 = v186;
    v643 = v187;
    v642 = v188;
    __asm { FMOV            V0.4S, #1.0 }
    v190 = ARMakeSRT(_Q0);
    v645 = v190.n128_u32[2];
    v644 = v190.n128_u64[0];
    v646 = v191;
    v648 = v192;
    v647 = v193;
    __asm { FMOV            V0.4S, #1.0 }
    v195 = ARMakeSRT(_Q0);
    v650 = v195.n128_u32[2];
    v649 = v195.n128_u64[0];
    v651 = v196;
    v653 = v197;
    v652 = v198;
    __asm { FMOV            V0.4S, #1.0 }
    v200 = ARMakeSRT(_Q0);
    v655 = v200.n128_u32[2];
    v654 = v200.n128_u64[0];
    v656 = v201;
    v658 = v202;
    v657 = v203;
    __asm { FMOV            V0.4S, #1.0 }
    v205 = ARMakeSRT(_Q0);
    v660 = v205.n128_u32[2];
    v659 = v205.n128_u64[0];
    v661 = v206;
    v663 = v207;
    v662 = v208;
    __asm { FMOV            V0.4S, #1.0 }
    v210 = ARMakeSRT(_Q0);
    v665 = v210.n128_u32[2];
    v664 = v210.n128_u64[0];
    v666 = v211;
    v668 = v212;
    v667 = v213;
    __asm { FMOV            V0.4S, #1.0 }
    v215 = ARMakeSRT(_Q0);
    v670 = v215.n128_u32[2];
    v669 = v215.n128_u64[0];
    v671 = v216;
    v673 = v217;
    v672 = v218;
    __asm { FMOV            V0.4S, #1.0 }
    v220 = ARMakeSRT(_Q0);
    v675 = v220.n128_u32[2];
    v674 = v220.n128_u64[0];
    v676 = v221;
    v678 = v222;
    v677 = v223;
    __asm { FMOV            V0.4S, #1.0 }
    v225 = ARMakeSRT(_Q0);
    v680 = v225.n128_u32[2];
    v679 = v225.n128_u64[0];
    v681 = v226;
    v683 = v227;
    v682 = v228;
    __asm { FMOV            V0.4S, #1.0 }
    v230 = ARMakeSRT(_Q0);
    v685 = v230.n128_u32[2];
    v684 = v230.n128_u64[0];
    v686 = v231;
    v688 = v232;
    v687 = v233;
    __asm { FMOV            V0.4S, #1.0 }
    v235 = ARMakeSRT(_Q0);
    v690 = v235.n128_u32[2];
    v689 = v235.n128_u64[0];
    v691 = v236;
    v693 = v237;
    v692 = v238;
    __asm { FMOV            V0.4S, #1.0 }
    v240 = ARMakeSRT(_Q0);
    v695 = v240.n128_u32[2];
    v694 = v240.n128_u64[0];
    v696 = v241;
    v698 = v242;
    v697 = v243;
    __asm { FMOV            V0.4S, #1.0 }
    v245 = ARMakeSRT(_Q0);
    v700 = v245.n128_u32[2];
    v699 = v245.n128_u64[0];
    v701 = v246;
    v703 = v247;
    v702 = v248;
    __asm { FMOV            V0.4S, #1.0 }
    v250 = ARMakeSRT(_Q0);
    v705 = v250.n128_u32[2];
    v704 = v250.n128_u64[0];
    v706 = v251;
    v708 = v252;
    v707 = v253;
    __asm { FMOV            V0.4S, #1.0 }
    v255 = ARMakeSRT(_Q0);
    v710 = v255.n128_u32[2];
    v709 = v255.n128_u64[0];
    v711 = v256;
    v713 = v257;
    v712 = v258;
    __asm { FMOV            V0.4S, #1.0 }
    v260 = ARMakeSRT(_Q0);
    v715 = v260.n128_u32[2];
    v714 = v260.n128_u64[0];
    v716 = v261;
    v718 = v262;
    v717 = v263;
    __asm { FMOV            V0.4S, #1.0 }
    v265 = ARMakeSRT(_Q0);
    v720 = v265.n128_u32[2];
    v719 = v265.n128_u64[0];
    v721 = v266;
    v723 = v267;
    v722 = v268;
    __asm { FMOV            V0.4S, #1.0 }
    v270 = ARMakeSRT(_Q0);
    v725 = v270.n128_u32[2];
    v724 = v270.n128_u64[0];
    v726 = v271;
    v728 = v272;
    v727 = v273;
    __asm { FMOV            V0.4S, #1.0 }
    v275 = ARMakeSRT(_Q0);
    v730 = v275.n128_u32[2];
    v729 = v275.n128_u64[0];
    v731 = v276;
    v733 = v277;
    v732 = v278;
    __asm { FMOV            V0.4S, #1.0 }
    v280 = ARMakeSRT(_Q0);
    v735 = v280.n128_u32[2];
    v734 = v280.n128_u64[0];
    v736 = v281;
    v738 = v282;
    v737 = v283;
    __asm { FMOV            V0.4S, #1.0 }
    v285 = ARMakeSRT(_Q0);
    v740 = v285.n128_u32[2];
    v739 = v285.n128_u64[0];
    v741 = v286;
    v743 = v287;
    v742 = v288;
    __asm { FMOV            V0.4S, #1.0 }
    v290 = ARMakeSRT(_Q0);
    v745 = v290.n128_u32[2];
    v744 = v290.n128_u64[0];
    v746 = v291;
    v748 = v292;
    v747 = v293;
    __asm { FMOV            V0.4S, #1.0 }
    v295 = ARMakeSRT(_Q0);
    v750 = v295.n128_u32[2];
    v749 = v295.n128_u64[0];
    v751 = v296;
    v753 = v297;
    v752 = v298;
    __asm { FMOV            V0.4S, #1.0 }
    v300 = ARMakeSRT(_Q0);
    v755 = v300.n128_u32[2];
    v754 = v300.n128_u64[0];
    v756 = v301;
    v758 = v302;
    v757 = v303;
    __asm { FMOV            V0.4S, #1.0 }
    v305 = ARMakeSRT(_Q0);
    v760 = v305.n128_u32[2];
    v759 = v305.n128_u64[0];
    v761 = v306;
    v763 = v307;
    v762 = v308;
    __asm { FMOV            V0.4S, #1.0 }
    v310 = ARMakeSRT(_Q0);
    v765 = v310.n128_u32[2];
    v764 = v310.n128_u64[0];
    v766 = v311;
    v768 = v312;
    v767 = v313;
    __asm { FMOV            V0.4S, #1.0 }
    v315 = ARMakeSRT(_Q0);
    v770 = v315.n128_u32[2];
    v769 = v315.n128_u64[0];
    v771 = v316;
    v773 = v317;
    v772 = v318;
    __asm { FMOV            V0.4S, #1.0 }
    v320 = ARMakeSRT(_Q0);
    v775 = v320.n128_u32[2];
    v774 = v320.n128_u64[0];
    v776 = v321;
    v778 = v322;
    v777 = v323;
    __asm { FMOV            V0.4S, #1.0 }
    v325 = ARMakeSRT(_Q0);
    v780 = v325.n128_u32[2];
    v779 = v325.n128_u64[0];
    v781 = v326;
    v783 = v327;
    v782 = v328;
    __asm { FMOV            V0.4S, #1.0 }
    v330 = ARMakeSRT(_Q0);
    v785 = v330.n128_u32[2];
    v784 = v330.n128_u64[0];
    v786 = v331;
    v788 = v332;
    v787 = v333;
    __asm { FMOV            V0.4S, #1.0 }
    v335 = ARMakeSRT(_Q0);
    v790 = v335.n128_u32[2];
    v789 = v335.n128_u64[0];
    v791 = v336;
    v793 = v337;
    v792 = v338;
    __asm { FMOV            V0.4S, #1.0 }
    v340 = ARMakeSRT(_Q0);
    v795 = v340.n128_u32[2];
    v794 = v340.n128_u64[0];
    v796 = v341;
    v798 = v342;
    v797 = v343;
    __asm { FMOV            V0.4S, #1.0 }
    v345 = ARMakeSRT(_Q0);
    v800 = v345.n128_u32[2];
    v799 = v345.n128_u64[0];
    v801 = v346;
    v803 = v347;
    v802 = v348;
    __asm { FMOV            V0.4S, #1.0 }
    v350 = ARMakeSRT(_Q0);
    v805 = v350.n128_u32[2];
    v804 = v350.n128_u64[0];
    v806 = v351;
    v808 = v352;
    v807 = v353;
    __asm { FMOV            V0.4S, #1.0 }
    v355 = ARMakeSRT(_Q0);
    v810 = v355.n128_u32[2];
    v809 = v355.n128_u64[0];
    v811 = v356;
    v813 = v357;
    v812 = v358;
    __asm { FMOV            V0.4S, #1.0 }
    v360 = ARMakeSRT(_Q0);
    v815 = v360.n128_u32[2];
    v814 = v360.n128_u64[0];
    v816 = v361;
    v818 = v362;
    v817 = v363;
    __asm { FMOV            V0.4S, #1.0 }
    v365 = ARMakeSRT(_Q0);
    v820 = v365.n128_u32[2];
    v819 = v365.n128_u64[0];
    v821 = v366;
    v823 = v367;
    v822 = v368;
    __asm { FMOV            V0.4S, #1.0 }
    v370 = ARMakeSRT(_Q0);
    v825 = v370.n128_u32[2];
    v824 = v370.n128_u64[0];
    v826 = v371;
    v828 = v372;
    v827 = v373;
    __asm { FMOV            V0.4S, #1.0 }
    v375 = ARMakeSRT(_Q0);
    v830 = v375.n128_u32[2];
    v829 = v375.n128_u64[0];
    v831 = v376;
    v833 = v377;
    v832 = v378;
    __asm { FMOV            V0.4S, #1.0 }
    v380 = ARMakeSRT(_Q0);
    v835 = v380.n128_u32[2];
    v834 = v380.n128_u64[0];
    v836 = v381;
    v838 = v382;
    v837 = v383;
    __asm { FMOV            V0.4S, #1.0 }
    v385 = ARMakeSRT(_Q0);
    v840 = v385.n128_u32[2];
    v839 = v385.n128_u64[0];
    v841 = v386;
    v843 = v387;
    v842 = v388;
    __asm { FMOV            V0.4S, #1.0 }
    v390 = ARMakeSRT(_Q0);
    v845 = v390.n128_u32[2];
    v844 = v390.n128_u64[0];
    v846 = v391;
    v848 = v392;
    v847 = v393;
    __asm { FMOV            V0.4S, #1.0 }
    v395 = ARMakeSRT(_Q0);
    v850 = v395.n128_u32[2];
    v849 = v395.n128_u64[0];
    v851 = v396;
    v853 = v397;
    v852 = v398;
    __asm { FMOV            V0.4S, #1.0 }
    v400 = ARMakeSRT(_Q0);
    v855 = v400.n128_u32[2];
    v854 = v400.n128_u64[0];
    v856 = v401;
    v858 = v402;
    v857 = v403;
    __asm { FMOV            V0.4S, #1.0 }
    v405 = ARMakeSRT(_Q0);
    v860 = v405.n128_u32[2];
    v859 = v405.n128_u64[0];
    v861 = v406;
    v863 = v407;
    v862 = v408;
    __asm { FMOV            V0.4S, #1.0 }
    v410 = ARMakeSRT(_Q0);
    v865 = v410.n128_u32[2];
    v864 = v410.n128_u64[0];
    v866 = v411;
    v868 = v412;
    v867 = v413;
    __asm { FMOV            V0.4S, #1.0 }
    v415 = ARMakeSRT(_Q0);
    v870 = v415.n128_u32[2];
    v869 = v415.n128_u64[0];
    v871 = v416;
    v873 = v417;
    v872 = v418;
    __asm { FMOV            V0.4S, #1.0 }
    v420 = ARMakeSRT(_Q0);
    v875 = v420.n128_u32[2];
    v874 = v420.n128_u64[0];
    v876 = v421;
    v878 = v422;
    v877 = v423;
    __asm { FMOV            V0.4S, #1.0 }
    v425 = ARMakeSRT(_Q0);
    v880 = v425.n128_u32[2];
    v879 = v425.n128_u64[0];
    v881 = v426;
    v883 = v427;
    v882 = v428;
    __asm { FMOV            V0.4S, #1.0 }
    v430 = ARMakeSRT(_Q0);
    v885 = v430.n128_u32[2];
    v884 = v430.n128_u64[0];
    v886 = v431;
    v888 = v432;
    v887 = v433;
    __asm { FMOV            V0.4S, #1.0 }
    v435 = ARMakeSRT(_Q0);
    v890 = v435.n128_u32[2];
    v889 = v435.n128_u64[0];
    v891 = v436;
    v893 = v437;
    v892 = v438;
    __asm { FMOV            V0.4S, #1.0 }
    v440 = ARMakeSRT(_Q0);
    v895 = v440.n128_u32[2];
    v894 = v440.n128_u64[0];
    v896 = v441;
    v898 = v442;
    v897 = v443;
    __asm { FMOV            V0.4S, #1.0 }
    v445 = ARMakeSRT(_Q0);
    v900 = v445.n128_u32[2];
    v899 = v445.n128_u64[0];
    v901 = v446;
    v903 = v447;
    v902 = v448;
    __asm { FMOV            V0.4S, #1.0 }
    v450 = ARMakeSRT(_Q0);
    v905 = v450.n128_u32[2];
    v904 = v450.n128_u64[0];
    v906 = v451;
    v908 = v452;
    v907 = v453;
    __asm { FMOV            V0.4S, #1.0 }
    v455 = ARMakeSRT(_Q0);
    v910 = v455.n128_u32[2];
    v909 = v455.n128_u64[0];
    v911 = v456;
    v913 = v457;
    v912 = v458;
    __asm { FMOV            V0.4S, #1.0 }
    v460 = ARMakeSRT(_Q0);
    v915 = v460.n128_u32[2];
    v914 = v460.n128_u64[0];
    v916 = v461;
    v918 = v462;
    v917 = v463;
    __asm { FMOV            V0.4S, #1.0 }
    v465 = ARMakeSRT(_Q0);
    v920 = v465.n128_u32[2];
    v919 = v465.n128_u64[0];
    v921 = v466;
    v923 = v467;
    v922 = v468;
    std::vector<ARSRT>::vector[abi:ne180100](&ARNeutralBodySkeleton3DLocalTransforms::dataVector, &v469, 0x5BuLL);
    __cxa_atexit((void (*)(void *))std::vector<ARSRT>::~vector[abi:ne180100], &ARNeutralBodySkeleton3DLocalTransforms::dataVector, &dword_1B3A68000);
  }
  result = ARNeutralBodySkeleton3DLocalTransforms::dataVector;
  if (*(_QWORD *)algn_1EF082830 - ARNeutralBodySkeleton3DLocalTransforms::dataVector != 4368)
    ARNeutralBodySkeleton3DLocalTransforms_cold_1();
  return result;
}

void sub_1B3B697A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

_QWORD *std::vector<ARSRT>::vector[abi:ne180100](_QWORD *a1, const void *a2, unint64_t a3)
{
  uint64_t v6;
  size_t v7;
  char *v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a3)
  {
    std::vector<ARSRT>::__vallocate[abi:ne180100](a1, a3);
    v6 = 3 * a3;
    v7 = 48 * a3;
    v8 = (char *)a1[1];
    memmove(v8, a2, v7);
    a1[1] = &v8[16 * v6];
  }
  return a1;
}

void sub_1B3B69824(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<ARSRT>::~vector[abi:ne180100](uint64_t a1)
{
  void *v2;

  v2 = *(void **)a1;
  if (v2)
  {
    *(_QWORD *)(a1 + 8) = v2;
    operator delete(v2);
  }
  return a1;
}

char *std::vector<simd_float4x4>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 58)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[64 * v4];
  return result;
}

char *std::vector<ARSRT>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0x555555555555556)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<ARSRT>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[48 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ARSRT>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x555555555555556)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(48 * a2);
}

void ARSurfaceUseCountIsZeroCallback(void *a1, uint64_t a2)
{
  id v3;

  objc_msgSend(a1, "object");
  v3 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v3, "updateBufferPopulationRegistryWithReleasedSurfaceID:", a2);

}

uint64_t ARBufferPopulationMonitorSignpostTypeForCaptureDevice(void *a1)
{
  id v1;
  uint64_t v2;

  v1 = a1;
  if ((id)*MEMORY[0x1E0C89FA0] == v1)
  {
    v2 = 1;
  }
  else if ((id)*MEMORY[0x1E0C89F90] == v1)
  {
    v2 = 4;
  }
  else if ((id)*MEMORY[0x1E0C89F98] == v1)
  {
    v2 = 2;
  }
  else
  {
    v2 = 4 * (*MEMORY[0x1E0C89F80] == (_QWORD)v1);
  }

  return v2;
}

uint64_t __Block_byref_object_copy__5(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__5(uint64_t a1)
{

}

void sub_1B3B6A324(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3B6A390(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3B6A3E8(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3B6A924(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B6A9A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B6AA3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B6ABE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, void *a12, uint64_t a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

void sub_1B3B6AD6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  v5 = v4;

  _Unwind_Resume(a1);
}

void sub_1B3B6AFB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12)
{
  void *v12;
  void *v13;
  void *v14;
  void *v15;

  _Unwind_Resume(a1);
}

void sub_1B3B6B454(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21,void *a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

void sub_1B3B6B5C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)ARSpatialMappingResultData;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_16()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

_QWORD *std::vector<unsigned char>::vector(_QWORD *a1, size_t a2)
{
  char *v4;
  char *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<unsigned char>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = &v4[a2];
    bzero(v4, a2);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3B6B718(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 ARMinimumCornerForVertexSource(void *a1)
{
  id v1;
  uint64_t v2;
  uint64_t v3;
  id v4;
  uint64_t v5;
  __int128 v6;
  float *v7;
  float v8;
  float v9;
  float v10;
  float v11;
  __int128 v13;

  v1 = a1;
  v2 = objc_msgSend(v1, "count");
  if (v2)
  {
    v3 = v2;
    objc_msgSend(v1, "buffer");
    v4 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
    v5 = objc_msgSend(v4, "contents");

    *(_QWORD *)&v6 = *(_QWORD *)v5;
    v8 = *(float *)(v5 + 8);
    v7 = (float *)(v5 + 8);
    v9 = v8;
    do
    {
      *(int8x8_t *)&v6 = vbsl_s8((int8x8_t)vcgt_f32(*(float32x2_t *)(v7 - 2), *(float32x2_t *)&v6), *(int8x8_t *)&v6, *(int8x8_t *)(v7 - 2));
      v10 = *v7;
      v7 += 3;
      v11 = v10;
      if (v9 >= v10)
        v9 = v11;
      --v3;
    }
    while (v3);
    *((float *)&v6 + 2) = v9;
    v13 = v6;
  }
  else
  {
    v13 = 0u;
  }

  return (__n128)v13;
}

void ARConvertVisionSourceToWorldSource(void *a1, int a2, simd_float4 a3, simd_float4 a4, simd_float4 a5, simd_float4 a6)
{
  id v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  uint64_t v13;
  uint64_t v14;
  int32x2_t v15;
  float32x4_t v16;
  float *v17;
  uint64_t v18;
  float32x4_t v19;
  unint64_t v20;
  simd_float4x4 v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v25;
  id v26;
  _OWORD v27[4];
  float32x4_t v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  simd_float4x4 v32;

  v21.columns[2] = a5;
  v21.columns[3] = a6;
  v21.columns[0] = a3;
  v21.columns[1] = a4;
  v26 = a1;
  objc_msgSend(v26, "buffer");
  v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  v8 = objc_msgSend(v7, "contents");

  v32 = __invert_f4(v21);
  v21.columns[2] = v32.columns[1];
  v21.columns[3] = v32.columns[0];
  v21.columns[0] = v32.columns[3];
  v21.columns[1] = v32.columns[2];
  *(double *)v9.i64 = ARVisionToRenderingCoordinateTransform();
  v13 = 0;
  v27[0] = v21.columns[3];
  v27[1] = v21.columns[2];
  v27[2] = v21.columns[1];
  v27[3] = v21.columns[0];
  v28 = 0u;
  v29 = 0u;
  v30 = 0u;
  v31 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v28 + v13 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v9, COERCE_FLOAT(v27[v13])), v10, *(float32x2_t *)&v27[v13], 1), v11, (float32x4_t)v27[v13], 2), v12, (float32x4_t)v27[v13], 3);
    ++v13;
  }
  while (v13 != 4);
  v24 = v29;
  v25 = v28;
  v22 = v31;
  v23 = v30;
  v14 = objc_msgSend(v26, "count");
  if (v14)
  {
    v15.i32[0] = 1.0;
    if (a2)
      *(float *)v15.i32 = 0.0;
    v16 = (float32x4_t)vdupq_lane_s32(v15, 0);
    v17 = (float *)(v8 + 8);
    v18 = 1;
    do
    {
      v19 = vmlaq_f32(vmlaq_n_f32(vmlaq_n_f32(vmulq_n_f32(v25, *(v17 - 2)), v24, *(v17 - 1)), v23, *v17), v16, v22);
      if ((a2 & 1) == 0)
        v19 = vdivq_f32(v19, (float32x4_t)vdupq_laneq_s32((int32x4_t)v19, 3));
      *v17 = v19.f32[2];
      *((_QWORD *)v17 - 1) = v19.i64[0];
      v20 = v18 + 2;
      v18 += 3;
      v17 += 3;
    }
    while (v20 < 3 * v14);
  }

}

id _ARLogGeneral_33()
{
  if (_ARLogGeneral_onceToken_39 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_39, &__block_literal_global_88);
  return (id)_ARLogGeneral_logObj_39;
}

void sub_1B3B6D9E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, void *a11, void *a12, void *a13)
{
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void std::vector<unsigned char>::reserve(unint64_t *a1, size_t __sz)
{
  unint64_t v2;
  char *v5;
  _BYTE *v6;
  char *v7;
  _BYTE *v8;
  char *v9;
  char v10;

  v2 = *a1;
  if (a1[2] - *a1 < __sz)
  {
    if ((__sz & 0x8000000000000000) != 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (char *)a1[1];
    v6 = operator new(__sz);
    v7 = &v5[(_QWORD)v6 - v2];
    v8 = v7;
    if (v5 != (char *)v2)
    {
      v9 = &v5[~v2];
      do
      {
        v10 = *--v5;
        (v9--)[(_QWORD)v6] = v10;
      }
      while (v5 != (char *)v2);
      v8 = v6;
    }
    *a1 = (unint64_t)v8;
    a1[1] = (unint64_t)v7;
    a1[2] = (unint64_t)&v6[__sz];
    if (v2)
      operator delete((void *)v2);
  }
}

void sub_1B3B6DCC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARCubemapCompletion;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B6E024(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B6E4F4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B6EBD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;
  void *v18;
  void *v19;
  void *v20;
  void *v21;

  _Unwind_Resume(a1);
}

void sub_1B3B6ED98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  void *v17;

  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

void sub_1B3B6F034(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_9()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_17()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void sub_1B3B6F318(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B6F558(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B6F5E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARSIPersonDetectionTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3B6F7D8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B6FA5C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_10()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_18()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

BOOL ___ZL18ARSkipCrashOnCrashv_block_invoke_1()
{
  _BOOL8 result;

  result = +[ARKitUserDefaults BOOLForKey:](ARKitUserDefaults, "BOOLForKey:", CFSTR("com.apple.arkit.skipCrashOnARCrash"));
  ARSkipCrashOnCrash(void)::skipCrashOnCrash = result;
  return result;
}

id _ARLogTechnique_12()
{
  if (_ARLogTechnique_onceToken_18 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_18, &__block_literal_global_91);
  return (id)_ARLogTechnique_logObj_18;
}

uint64_t ARViewToCameraImageTransform@<X0>(uint64_t result@<X0>, int a2@<W1>, uint64_t a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>, double a7@<D3>)
{
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double v13;

  v7 = a5 / a4;
  v8 = a4 / a5;
  if ((unint64_t)(result - 3) <= 1)
    v7 = v8;
  v9 = *(double *)(MEMORY[0x1E0C9D538] + 8);
  v10 = a6 / a7;
  if (v7 >= v10)
  {
    v13 = *MEMORY[0x1E0C9D538];
    v11 = 1.0;
    if (v7 <= v10)
    {
      v12 = 1.0;
    }
    else
    {
      v12 = v10 / v7;
      v9 = (1.0 - v12) * 0.5;
    }
  }
  else
  {
    v11 = v7 / v10;
    v12 = 1.0;
    v13 = (1.0 - v11) * 0.5;
  }
  *(_OWORD *)(a3 + 16) = 0u;
  *(_OWORD *)(a3 + 32) = 0u;
  *(_OWORD *)a3 = 0u;
  if (!a2)
  {
    if (result == 2)
    {
      v13 = v13 + v11;
      *(double *)(a3 + 8) = v12;
      *(double *)(a3 + 16) = -v11;
      goto LABEL_25;
    }
    if (result == 4)
    {
      v13 = v13 + v11;
      *(double *)a3 = -v11;
      v9 = v9 + v12;
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(double *)(a3 + 24) = -v12;
      goto LABEL_25;
    }
    if (result != 3)
    {
      v9 = v9 + v12;
      *(double *)(a3 + 8) = -v12;
      goto LABEL_24;
    }
    *(double *)a3 = v11;
LABEL_19:
    *(_QWORD *)(a3 + 8) = 0;
    *(_QWORD *)(a3 + 16) = 0;
    *(double *)(a3 + 24) = v12;
    goto LABEL_25;
  }
  if (result == 2)
  {
    v13 = v13 + v11;
    v9 = v9 + v12;
    *(double *)(a3 + 8) = -v12;
    *(double *)(a3 + 16) = -v11;
    goto LABEL_25;
  }
  if (result == 4)
  {
    *(double *)a3 = -v11;
    v13 = v13 + v11;
    goto LABEL_19;
  }
  if (result != 3)
  {
    *(double *)(a3 + 8) = v12;
LABEL_24:
    *(double *)(a3 + 16) = v11;
    goto LABEL_25;
  }
  *(double *)a3 = v11;
  v9 = v9 + v12;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  *(double *)(a3 + 24) = -v12;
LABEL_25:
  *(double *)(a3 + 32) = v13;
  *(double *)(a3 + 40) = v9;
  return result;
}

CGAffineTransform *ARCameraImageToViewTransform@<X0>(uint64_t a1@<X0>, int a2@<W1>, CGAffineTransform *a3@<X8>, double a4@<D0>, double a5@<D1>, double a6@<D2>, double a7@<D3>)
{
  CGAffineTransform v9;

  ARViewToCameraImageTransform(a1, a2, (uint64_t)&v9, a6, a7, a4, a5);
  return CGAffineTransformInvert(a3, &v9);
}

uint64_t ARCameraToDisplayRotation(unint64_t a1)
{
  if (a1 > 4)
    return 90;
  else
    return qword_1B3C0B3A8[a1];
}

const __CFString *NSStringFromUIInterfaceOrientation(unint64_t a1)
{
  if (a1 > 4)
    return &stru_1E6676798;
  else
    return off_1E6675630[a1];
}

id ARFrameworkVersions()
{
  if (ARFrameworkVersions_onceToken != -1)
    dispatch_once(&ARFrameworkVersions_onceToken, &__block_literal_global_92);
  return (id)ARFrameworkVersions_frameworksVersionsDict;
}

uint64_t ARObjectTrackingInternalErrorCodeIsTransientError(unint64_t a1)
{
  return (a1 > 9) | (0xA1u >> a1) & 1;
}

uint64_t ARObjectTrackingInternalErrorCodeShouldStopProvider(unint64_t a1)
{
  return (a1 > 7) | (0x56u >> a1) & 1;
}

id NSErrorFromARObjectTrackingInternalErrorCode(uint64_t a1)
{
  return NSErrorFromARObjectTrackingInternalErrorCodeAndUserInfo(a1, 0);
}

id NSErrorFromARObjectTrackingInternalErrorCodeAndUserInfo(uint64_t a1, void *a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)MEMORY[0x1E0CB35C8];
  v4 = (void *)objc_msgSend(a2, "copy");
  objc_msgSend(v3, "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), a1, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

id NSErrorFromARObjectTrackingODTError(void *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  if (a1)
  {
    v1 = (void *)MEMORY[0x1E0CB35C8];
    objc_msgSend(a1, "userInfo");
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v3 = (void *)objc_msgSend(v2, "copy");
    objc_msgSend(v1, "errorWithDomain:code:userInfo:", CFSTR("com.apple.arkit.error"), 4, v3);
    v4 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v4 = 0;
  }
  return v4;
}

void sub_1B3B727E0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B729B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B729FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3B72DC8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1B3B73774(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *__p,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,uint64_t a52)
{
  void *v52;
  void *v53;
  void *v54;

  if (__p)
    operator delete(__p);
  if (a51)
    operator delete(a51);

  _Unwind_Resume(a1);
}

void _ZNSt3__16vectorIDv2_fNS_9allocatorIS1_EEE7reserveEm(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        v13 = *((_QWORD *)v10 - 1);
        v10 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_19()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

std::vector<unsigned int> *__cdecl std::vector<unsigned int>::vector(std::vector<unsigned int> *this, std::vector<unsigned int>::size_type __n)
{
  std::vector<unsigned int>::pointer end;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B3B73A94(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3B74E28(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7570C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,void *__p,uint64_t a41,uint64_t a42,void *a43,uint64_t a44)
{
  uint64_t v44;
  void *v46;

  if (__p)
    operator delete(__p);
  if (a43)
    operator delete(a43);
  v46 = *(void **)(v44 - 240);
  if (v46)
  {
    *(_QWORD *)(v44 - 232) = v46;
    operator delete(v46);
  }

  _Unwind_Resume(a1);
}

void std::vector<__ARC3DShapeVertex>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  uint64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (0xCCCCCCCCCCCCCCCDLL * ((v4 - (_BYTE *)*a1) >> 4) < a2)
  {
    if (a2 >= 0x333333333333334)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = ((_BYTE *)a1[1] - (_BYTE *)*a1) / 80;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<__ARC3DShapeVertex>>(v3, a2);
    v7 = &v6[80 * v5];
    v9 = &v6[80 * v8];
    v11 = (char *)*a1;
    v10 = (char *)a1[1];
    v12 = v7;
    if (v10 != *a1)
    {
      do
      {
        *((_OWORD *)v12 - 5) = *((_OWORD *)v10 - 5);
        v13 = *((_OWORD *)v10 - 4);
        v14 = *((_OWORD *)v10 - 3);
        v15 = *((_OWORD *)v10 - 1);
        *((_OWORD *)v12 - 2) = *((_OWORD *)v10 - 2);
        *((_OWORD *)v12 - 1) = v15;
        *((_OWORD *)v12 - 4) = v13;
        *((_OWORD *)v12 - 3) = v14;
        v12 -= 80;
        v10 -= 80;
      }
      while (v10 != v11);
      v10 = (char *)*a1;
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

void sub_1B3B75A00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B75D2C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26)
{
  void *v26;
  void *v27;
  void *v28;
  void *v29;
  void *v30;
  void *v31;
  void *v32;

  v32 = v30;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_11()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_20()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

char *std::vector<short>::__assign_with_size[abi:ne180100]<short const*,short const*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  unint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (uint64_t)(v8 - *(_QWORD *)result) >> 1)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if ((a4 & 0x8000000000000000) != 0)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    if (v8 <= a4)
      v10 = a4;
    else
      v10 = v8;
    if (v8 >= 0x7FFFFFFFFFFFFFFELL)
      v11 = 0x7FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<short>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_17:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 1;
  if (v15 >= a4)
    goto LABEL_17;
  v16 = &__src[2 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_19:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_20:
  *v12 = &v9[v17];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<__ARC3DShapeVertex>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x333333333333334)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(80 * a2);
}

_QWORD *std::vector<short>::__init_with_size[abi:ne180100]<short const*,short const*>(_QWORD *result, const void *a2, uint64_t a3, uint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<short>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3B76070(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3B76514(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7666C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, _QWORD *a11)
{
  uint64_t v11;

  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a10, a11);
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(v11, *(_QWORD **)(v11 + 8));
  _Unwind_Resume(a1);
}

_QWORD *intersect<std::array<unsigned char,16ul>>@<X0>(_QWORD *result@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)a3 = a3 + 8;
  v4 = result + 1;
  v5 = (_QWORD *)*result;
  if ((_QWORD *)*result != result + 1)
  {
    v7 = (_QWORD *)(a2 + 8);
    do
    {
      result = std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(a2, (uint64_t)v5 + 25);
      if (v7 != result)
        result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a3, (uint64_t)v5 + 25, (_QWORD *)((char *)v5 + 25));
      v8 = (_QWORD *)v5[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v5[2];
          v10 = *v9 == (_QWORD)v5;
          v5 = v9;
        }
        while (!v10);
      }
      v5 = v9;
    }
    while (v9 != v4);
  }
  return result;
}

void sub_1B3B76758(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

char *keys<std::array<unsigned char,16ul>,ARTexturedPlane>@<X0>(char *result@<X0>, uint64_t a2@<X8>)
{
  char *v3;
  char *v4;
  char *v5;
  char *v6;
  BOOL v7;

  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = a2 + 8;
  v3 = result + 8;
  v4 = *(char **)result;
  if (*(char **)result != result + 8)
  {
    do
    {
      result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a2, (uint64_t)(v4 + 32), (_OWORD *)v4 + 2);
      v5 = (char *)*((_QWORD *)v4 + 1);
      if (v5)
      {
        do
        {
          v6 = v5;
          v5 = *(char **)v5;
        }
        while (v5);
      }
      else
      {
        do
        {
          v6 = (char *)*((_QWORD *)v4 + 2);
          v7 = *(_QWORD *)v6 == (_QWORD)v4;
          v4 = v6;
        }
        while (!v7);
      }
      v4 = v6;
    }
    while (v6 != v3);
  }
  return result;
}

void sub_1B3B767FC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

void sub_1B3B77130(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,_QWORD *a25,uint64_t a26,char a27,_QWORD *a28,uint64_t a29,char a30,_QWORD *a31,uint64_t a32,char a33,_QWORD *a34,uint64_t a35,char a36,_QWORD *a37)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(a19, *(_QWORD **)(a19 + 8));
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy((uint64_t)&a24, a25);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a27, a28);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a30, a31);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a33, a34);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&a36, a37);
  _Unwind_Resume(a1);
}

char *notInLeftButRight<std::array<unsigned char,16ul>>@<X0>(char *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  char *v7;
  _QWORD *v8;
  _QWORD *v9;
  BOOL v10;

  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)a3 = a3 + 8;
  v4 = a2 + 1;
  v5 = (_QWORD *)*a2;
  if ((_QWORD *)*a2 != a2 + 1)
  {
    v6 = (uint64_t)result;
    v7 = result + 8;
    do
    {
      result = (char *)std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(v6, (uint64_t)v5 + 25);
      if (v7 == result)
        result = std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>((uint64_t **)a3, (uint64_t)v5 + 25, (_QWORD *)((char *)v5 + 25));
      v8 = (_QWORD *)v5[1];
      if (v8)
      {
        do
        {
          v9 = v8;
          v8 = (_QWORD *)*v8;
        }
        while (v8);
      }
      else
      {
        do
        {
          v9 = (_QWORD *)v5[2];
          v10 = *v9 == (_QWORD)v5;
          v5 = v9;
        }
        while (!v10);
      }
      v5 = v9;
    }
    while (v9 != v4);
  }
  return result;
}

void sub_1B3B772E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::at(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v2 = *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(a1, &v4, a2);
  if (!v2)
    std::__throw_out_of_range[abi:ne180100]("map::at:  key not found");
  return v2 + 48;
}

void sub_1B3B77A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,char a46,_QWORD *a47,uint64_t a48,char a49,_QWORD *a50)
{
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy((uint64_t)&a46, a47);
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy((uint64_t)&a49, a50);
  _Unwind_Resume(a1);
}

char *ARPlaneUpdateQueue::insert(_QWORD *a1, uint64_t a2, uint64_t a3, id *a4)
{
  uint64_t **v6;
  char *result;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  _OWORD v18[13];
  _QWORD *v19[3];
  id v20;
  __int128 v21;
  uint64_t v22;

  v22 = *MEMORY[0x1E0C80C00];
  *(_QWORD *)&v21 = a2;
  *((_QWORD *)&v21 + 1) = a3;
  v6 = (uint64_t **)(a1 + 6);
  result = (char *)std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>((uint64_t)(a1 + 6), (uint64_t)&v21);
  if (a1 + 7 == (_QWORD *)result)
  {
    v8 = *((_OWORD *)a4 + 8);
    v9 = *((_OWORD *)a4 + 10);
    v10 = *((_OWORD *)a4 + 11);
    v18[10] = *((_OWORD *)a4 + 9);
    v18[11] = v9;
    v18[12] = v10;
    v11 = *((_OWORD *)a4 + 4);
    v12 = *((_OWORD *)a4 + 6);
    v13 = *((_OWORD *)a4 + 7);
    v18[6] = *((_OWORD *)a4 + 5);
    v18[7] = v12;
    v18[8] = v13;
    v18[9] = v8;
    v14 = *(_OWORD *)a4;
    v15 = *((_OWORD *)a4 + 1);
    v18[0] = v21;
    v18[1] = v14;
    v16 = *((_OWORD *)a4 + 2);
    v17 = *((_OWORD *)a4 + 3);
    v18[2] = v15;
    v18[3] = v16;
    v18[4] = v17;
    v18[5] = v11;
    std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)v19, (uint64_t)(a4 + 24));
    v20 = a4[27];
    std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::push_back(a1, (uint64_t)v18);

    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)v19, v19[1]);
    return std::__tree<std::array<unsigned char,16ul>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::array<unsigned char,16ul>>(v6, (uint64_t)&v21, &v21);
  }
  return result;
}

void sub_1B3B77BFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>::~pair((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>::~pair(uint64_t a1)
{

  std::__tree<std::array<unsigned char,16ul>>::destroy(a1 + 208, *(_QWORD **)(a1 + 216));
  return a1;
}

void sub_1B3B77D18(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::vector<ARTexturedPlane>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  _Unwind_Resume(a1);
}

void sub_1B3B77DF8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t **std::__tree<std::array<unsigned char,16ul>>::__assign_multi<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>(uint64_t **result, _QWORD *a2, _QWORD *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t *v16;

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v14 = result;
    v15 = v8;
    v16 = v8;
    if (v8)
    {
      v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        v9 = a2;
        do
        {
          *(_OWORD *)((char *)v8 + 25) = *(_OWORD *)((char *)v9 + 25);
          std::__tree<std::array<unsigned char,16ul>>::__node_insert_multi(v5, v8);
          v8 = v15;
          v16 = v15;
          if (v15)
            v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v15);
          v10 = (_QWORD *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              v10 = (_QWORD *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (_QWORD *)v9[2];
              v11 = *a2 == (_QWORD)v9;
              v9 = a2;
            }
            while (!v11);
          }
          if (!v8)
            break;
          v9 = a2;
        }
        while (a2 != a3);
      }
    }
    result = (uint64_t **)std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      result = (uint64_t **)std::__tree<std::array<unsigned char,16ul>>::__emplace_multi<std::array<unsigned char,16ul> const&>(v5, (_QWORD *)((char *)a2 + 25));
      v12 = (_QWORD *)a2[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)a2[2];
          v11 = *v13 == (_QWORD)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1B3B77FE8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::array<unsigned char,16ul>>::__node_insert_multi(uint64_t **a1, uint64_t *a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t **v9;

  v3 = a1 + 1;
  v4 = a1[1];
  if (v4)
  {
LABEL_2:
    while (2)
    {
      v3 = (uint64_t **)v4;
      v5 = 25;
      while (1)
      {
        v6 = *((unsigned __int8 *)a2 + v5);
        v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7)
          break;
        if (v7 >= v6 && v5++ != 40)
          continue;
        v4 = v3[1];
        if (v4)
          goto LABEL_2;
        v9 = v3 + 1;
        goto LABEL_12;
      }
      v4 = *v3;
      v9 = v3;
      if (*v3)
        continue;
      break;
    }
  }
  else
  {
    v9 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v3, v9, a2);
  return a2;
}

_QWORD *std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next(uint64_t a1)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;

  result = *(_QWORD **)(a1 + 16);
  if (result)
  {
    v3 = (_QWORD *)*result;
    if (*result == a1)
    {
      *result = 0;
      while (1)
      {
        v4 = (_QWORD *)result[1];
        if (!v4)
          break;
        do
        {
          result = v4;
          v4 = (_QWORD *)*v4;
        }
        while (v4);
      }
    }
    else
    {
      for (result[1] = 0; v3; v3 = (_QWORD *)result[1])
      {
        do
        {
          result = v3;
          v3 = (_QWORD *)*v3;
        }
        while (v3);
      }
    }
  }
  return result;
}

uint64_t std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  std::__tree<std::array<unsigned char,16ul>>::destroy(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::array<unsigned char,16ul>>::destroy(*(_QWORD *)a1, v2);
  }
  return a1;
}

char *std::__tree<std::array<unsigned char,16ul>>::__emplace_multi<std::array<unsigned char,16ul> const&>(uint64_t **a1, _OWORD *a2)
{
  char *v4;
  char *v5;
  uint64_t **v6;
  uint64_t *v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t **v12;

  v4 = (char *)operator new(0x30uLL);
  v5 = v4;
  *(_OWORD *)(v4 + 25) = *a2;
  v6 = a1 + 1;
  v7 = a1[1];
  if (v7)
  {
LABEL_2:
    while (2)
    {
      v6 = (uint64_t **)v7;
      v8 = 25;
      while (1)
      {
        v9 = v4[v8];
        v10 = *((unsigned __int8 *)v6 + v8);
        if (v9 < v10)
          break;
        if (v10 >= v9 && v8++ != 40)
          continue;
        v7 = v6[1];
        if (v7)
          goto LABEL_2;
        v12 = v6 + 1;
        goto LABEL_12;
      }
      v7 = *v6;
      v12 = v6;
      if (*v6)
        continue;
      break;
    }
  }
  else
  {
    v12 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v6, v12, (uint64_t *)v4);
  return v5;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t **a1, uint64_t a2, uint64_t a3)
{
  uint64_t **v5;
  uint64_t *result;
  uint64_t *v7;
  uint64_t v8;

  v5 = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v8, a2);
  result = *v5;
  if (!*v5)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)a1, a3, (uint64_t)&v7);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v8, v5, v7);
    return v7;
  }
  return result;
}

id std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v5;
  _OWORD *v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  id result;

  v5 = a1 + 8;
  v6 = operator new(0x110uLL);
  *(_QWORD *)(a3 + 8) = v5;
  *(_QWORD *)a3 = v6;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = *(_OWORD *)(a2 + 176);
  v6[12] = *(_OWORD *)(a2 + 160);
  v6[13] = v7;
  v6[14] = *(_OWORD *)(a2 + 192);
  v8 = *(_OWORD *)(a2 + 112);
  v6[8] = *(_OWORD *)(a2 + 96);
  v6[9] = v8;
  v9 = *(_OWORD *)(a2 + 144);
  v6[10] = *(_OWORD *)(a2 + 128);
  v6[11] = v9;
  v10 = *(_OWORD *)(a2 + 16);
  v6[2] = *(_OWORD *)a2;
  v6[3] = v10;
  v11 = *(_OWORD *)(a2 + 48);
  v6[4] = *(_OWORD *)(a2 + 32);
  v6[5] = v11;
  v12 = *(_OWORD *)(a2 + 80);
  v6[6] = *(_OWORD *)(a2 + 64);
  v6[7] = v12;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)(v6 + 15), a2 + 208);
  result = *(id *)(a2 + 232);
  *((_QWORD *)v6 + 33) = result;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

void sub_1B3B78304(_Unwind_Exception *a1)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *>>>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  if (*(_BYTE *)(a1 + 8))
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(a2 + 240, *(_QWORD **)(a2 + 248));
  }
  else if (!a2)
  {
    return;
  }
  operator delete((void *)a2);
}

_QWORD *std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v4 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v3 = v4;
  if (v4)
  {
    v5 = result;
    do
    {
      v6 = 0;
      while (1)
      {
        v7 = *((unsigned __int8 *)v3 + v6 + 25);
        v8 = *(unsigned __int8 *)(a2 + v6);
        if (v7 < v8)
          break;
        if (v8 < v7 || v6++ == 15)
        {
          v5 = v3;
          break;
        }
      }
      if (v7 < v8)
        ++v3;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
    if (v5 != result)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(unsigned __int8 *)(a2 + v10);
        v12 = *((unsigned __int8 *)v5 + v10 + 25);
        if (v11 < v12)
          break;
        if (v12 < v11 || v10++ == 15)
          return v5;
      }
    }
  }
  return result;
}

void std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::push_back(_QWORD *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  _QWORD *v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v4 = a1[2];
  v5 = a1[1];
  v6 = 2 * (v4 - v5) + ((v4 - v5) >> 3) - 1;
  if (v4 == v5)
    v6 = 0;
  v7 = a1[5] + a1[4];
  if (v6 == v7)
  {
    std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__add_back_capacity(a1);
    v5 = a1[1];
    v7 = a1[5] + a1[4];
  }
  v8 = *(_QWORD *)(v5 + 8 * (v7 / 0x11));
  v9 = v7 % 0x11;
  v10 = v8 + 240 * v9;
  *(_OWORD *)v10 = *(_OWORD *)a2;
  v11 = *(_OWORD *)(a2 + 128);
  v13 = *(_OWORD *)(a2 + 80);
  v12 = *(_OWORD *)(a2 + 96);
  *(_OWORD *)(v10 + 112) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v10 + 128) = v11;
  *(_OWORD *)(v10 + 80) = v13;
  *(_OWORD *)(v10 + 96) = v12;
  v14 = *(_OWORD *)(a2 + 192);
  v16 = *(_OWORD *)(a2 + 144);
  v15 = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(v10 + 176) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v10 + 192) = v14;
  *(_OWORD *)(v10 + 144) = v16;
  *(_OWORD *)(v10 + 160) = v15;
  v17 = *(_OWORD *)(a2 + 16);
  v18 = *(_OWORD *)(a2 + 32);
  v19 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v10 + 48) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v10 + 64) = v19;
  *(_OWORD *)(v10 + 16) = v17;
  *(_OWORD *)(v10 + 32) = v18;
  *(_QWORD *)(v10 + 208) = *(_QWORD *)(a2 + 208);
  v20 = (_QWORD *)(v10 + 208);
  v21 = (_QWORD *)(a2 + 216);
  v22 = *(_QWORD *)(a2 + 216);
  *(_QWORD *)(v10 + 216) = v22;
  v23 = v10 + 216;
  v24 = *(_QWORD *)(a2 + 224);
  *(_QWORD *)(v23 + 8) = v24;
  if (v24)
  {
    *(_QWORD *)(v22 + 16) = v23;
    *(_QWORD *)(a2 + 208) = v21;
    *v21 = 0;
    *(_QWORD *)(a2 + 224) = 0;
  }
  else
  {
    *v20 = v23;
  }
  v25 = v8 + 240 * v9;
  v26 = *(_QWORD *)(a2 + 232);
  *(_QWORD *)(a2 + 232) = 0;
  *(_QWORD *)(v25 + 232) = v26;
  ++a1[5];
}

void std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__add_back_capacity(_QWORD *a1)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  _QWORD *v7;
  char *v8;
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  int64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  uint64_t v28;
  char *v29;
  __int128 v30;
  __int128 v31;
  __int128 v32;
  unint64_t v33;
  char *v34;
  char *v35;
  uint64_t v36;
  char *v37;
  uint64_t *v38;
  uint64_t v39;
  uint64_t v40;
  char *v41;
  uint64_t v42;
  char *v43;
  _QWORD *v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t v49;
  uint64_t v50;
  char *v51;
  uint64_t v52;
  void *v53;
  __int128 v54;
  __int128 v55;
  _QWORD *v56;

  v2 = a1[4];
  v3 = v2 >= 0x11;
  v4 = v2 - 17;
  if (v3)
  {
    v5 = (uint64_t)(a1 + 3);
    v6 = (char *)a1[3];
    a1[4] = v4;
    v7 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v11 = *v7;
    v9 = (char *)(v7 + 1);
    v10 = v11;
    a1[1] = v9;
    if (v8 != v6)
    {
LABEL_33:
      *(_QWORD *)v8 = v10;
      a1[2] += 8;
      return;
    }
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v33 = 1;
      else
        v33 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v5, v33);
      v35 = &v34[8 * (v33 >> 2)];
      v37 = &v34[8 * v36];
      v38 = (uint64_t *)a1[1];
      v8 = v35;
      v39 = a1[2] - (_QWORD)v38;
      if (v39)
      {
        v8 = &v35[v39 & 0xFFFFFFFFFFFFFFF8];
        v40 = 8 * (v39 >> 3);
        v41 = &v34[8 * (v33 >> 2)];
        do
        {
          v42 = *v38++;
          *(_QWORD *)v41 = v42;
          v41 += 8;
          v40 -= 8;
        }
        while (v40);
      }
      goto LABEL_30;
    }
LABEL_5:
    v13 = v12 >> 3;
    v14 = v12 >> 3 < -1;
    v15 = (v12 >> 3) + 2;
    if (v14)
      v16 = v15;
    else
      v16 = v13 + 1;
    v17 = -(v16 >> 1);
    v18 = v16 >> 1;
    v19 = &v9[-8 * v18];
    v20 = v8 - v9;
    if (v8 != v9)
    {
      memmove(&v9[-8 * v18], v9, v8 - v9);
      v9 = (char *)a1[1];
    }
    v8 = &v19[v20];
    a1[1] = &v9[8 * v17];
    a1[2] = &v19[v20];
    goto LABEL_33;
  }
  v21 = a1[2];
  v22 = (v21 - a1[1]) >> 3;
  v23 = a1[3];
  v24 = v23 - *a1;
  if (v22 < v24 >> 3)
  {
    if (v23 != v21)
    {
      *(_QWORD *)&v54 = operator new(0xFF0uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &v54);
      return;
    }
    *(_QWORD *)&v54 = operator new(0xFF0uLL);
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &v54);
    v44 = (_QWORD *)a1[1];
    v8 = (char *)a1[2];
    v45 = *v44;
    v9 = (char *)(v44 + 1);
    v10 = v45;
    a1[1] = v9;
    if (v8 != (char *)a1[3])
      goto LABEL_33;
    v12 = (uint64_t)&v9[-*a1];
    if ((unint64_t)v9 <= *a1)
    {
      if (v8 == (char *)*a1)
        v46 = 1;
      else
        v46 = (uint64_t)&v8[-*a1] >> 2;
      v34 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v46);
      v35 = &v34[8 * (v46 >> 2)];
      v37 = &v34[8 * v47];
      v48 = (uint64_t *)a1[1];
      v8 = v35;
      v49 = a1[2] - (_QWORD)v48;
      if (v49)
      {
        v8 = &v35[v49 & 0xFFFFFFFFFFFFFFF8];
        v50 = 8 * (v49 >> 3);
        v51 = &v34[8 * (v46 >> 2)];
        do
        {
          v52 = *v48++;
          *(_QWORD *)v51 = v52;
          v51 += 8;
          v50 -= 8;
        }
        while (v50);
      }
LABEL_30:
      v43 = (char *)*a1;
      *a1 = v34;
      a1[1] = v35;
      a1[2] = v8;
      a1[3] = v37;
      if (v43)
      {
        operator delete(v43);
        v8 = (char *)a1[2];
      }
      goto LABEL_33;
    }
    goto LABEL_5;
  }
  if (v23 == *a1)
    v25 = 1;
  else
    v25 = v24 >> 2;
  v56 = a1 + 3;
  *(_QWORD *)&v54 = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 3), v25);
  *((_QWORD *)&v54 + 1) = v54 + 8 * v22;
  *(_QWORD *)&v55 = *((_QWORD *)&v54 + 1);
  *((_QWORD *)&v55 + 1) = v54 + 8 * v26;
  v53 = operator new(0xFF0uLL);
  std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&v54, &v53);
  v27 = (_QWORD *)a1[2];
  v28 = -7 - (_QWORD)v27;
  while (v27 != (_QWORD *)a1[1])
  {
    --v27;
    v28 += 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_front((uint64_t)&v54, v27);
  }
  v29 = (char *)*a1;
  v30 = v54;
  v31 = v55;
  *(_QWORD *)&v54 = *a1;
  *((_QWORD *)&v54 + 1) = v27;
  v32 = *((_OWORD *)a1 + 1);
  *(_OWORD *)a1 = v30;
  *((_OWORD *)a1 + 1) = v31;
  v55 = v32;
  if (v27 != (_QWORD *)v32)
    *(_QWORD *)&v55 = v32 + (-(v32 + v28) & 0xFFFFFFFFFFFFFFF8);
  if (v29)
    operator delete(v29);
}

void sub_1B3B787DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13)
{
  void *v13;

  operator delete(v13);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

uint64_t std::__tree<std::array<unsigned char,16ul>>::__erase_unique<std::array<unsigned char,16ul>>(uint64_t **a1, uint64_t a2)
{
  uint64_t *v3;
  uint64_t *v4;

  v3 = std::__tree<std::array<unsigned char,16ul>>::find<std::array<unsigned char,16ul>>((uint64_t)a1, a2);
  if (a1 + 1 == (uint64_t **)v3)
    return 0;
  v4 = v3;
  std::__tree<std::array<unsigned char,16ul>>::__remove_node_pointer(a1, v3);
  operator delete(v4);
  return 1;
}

uint64_t *std::__tree<std::array<unsigned char,16ul>>::__remove_node_pointer(uint64_t **a1, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  BOOL v5;
  uint64_t *v6;

  v2 = (uint64_t *)a2[1];
  if (v2)
  {
    do
    {
      v3 = v2;
      v2 = (uint64_t *)*v2;
    }
    while (v2);
  }
  else
  {
    v4 = a2;
    do
    {
      v3 = (uint64_t *)v4[2];
      v5 = *v3 == (_QWORD)v4;
      v4 = v3;
    }
    while (!v5);
  }
  if (*a1 == a2)
    *a1 = v3;
  v6 = a1[1];
  a1[2] = (uint64_t *)((char *)a1[2] - 1);
  std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(v6, a2);
  return v3;
}

uint64_t *std::__tree_remove[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t *v3;
  uint64_t *v4;
  int v5;
  uint64_t **v6;
  uint64_t *v7;
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t *v16;
  uint64_t *v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  BOOL v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  v2 = *a2;
  v3 = a2;
  if (*a2)
  {
    v4 = (uint64_t *)a2[1];
    if (!v4)
    {
      v3 = a2;
      goto LABEL_7;
    }
    do
    {
      v3 = v4;
      v4 = (uint64_t *)*v4;
    }
    while (v4);
  }
  v2 = v3[1];
  if (v2)
  {
LABEL_7:
    v5 = 0;
    *(_QWORD *)(v2 + 16) = v3[2];
    goto LABEL_8;
  }
  v5 = 1;
LABEL_8:
  v6 = (uint64_t **)v3[2];
  v7 = *v6;
  if (*v6 == v3)
  {
    *v6 = (uint64_t *)v2;
    if (v3 == result)
    {
      v7 = 0;
      result = (uint64_t *)v2;
    }
    else
    {
      v7 = v6[1];
    }
  }
  else
  {
    v6[1] = (uint64_t *)v2;
  }
  v8 = *((unsigned __int8 *)v3 + 24);
  if (v3 != a2)
  {
    v9 = a2[2];
    v3[2] = v9;
    *(_QWORD *)(v9 + 8 * (*(_QWORD *)a2[2] != (_QWORD)a2)) = v3;
    v11 = *a2;
    v10 = a2[1];
    *(_QWORD *)(v11 + 16) = v3;
    *v3 = v11;
    v3[1] = v10;
    if (v10)
      *(_QWORD *)(v10 + 16) = v3;
    *((_BYTE *)v3 + 24) = *((_BYTE *)a2 + 24);
    if (result == a2)
      result = v3;
  }
  if (!v8 || !result)
    return result;
  if (!v5)
  {
    *(_BYTE *)(v2 + 24) = 1;
    return result;
  }
  while (1)
  {
    v12 = v7[2];
    if (*(uint64_t **)v12 == v7)
      break;
    if (!*((_BYTE *)v7 + 24))
    {
      *((_BYTE *)v7 + 24) = 1;
      *(_BYTE *)(v12 + 24) = 0;
      v13 = *(uint64_t **)(v12 + 8);
      v14 = *v13;
      *(_QWORD *)(v12 + 8) = *v13;
      if (v14)
        *(_QWORD *)(v14 + 16) = v12;
      v13[2] = *(_QWORD *)(v12 + 16);
      *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v13;
      *v13 = v12;
      *(_QWORD *)(v12 + 16) = v13;
      if (result == (uint64_t *)*v7)
        result = v7;
      v7 = *(uint64_t **)(*v7 + 8);
    }
    v15 = (_QWORD *)*v7;
    if (*v7 && !*((_BYTE *)v15 + 24))
    {
      v16 = (uint64_t *)v7[1];
      if (!v16)
        goto LABEL_56;
LABEL_55:
      if (*((_BYTE *)v16 + 24))
      {
LABEL_56:
        *((_BYTE *)v15 + 24) = 1;
        *((_BYTE *)v7 + 24) = 0;
        v22 = v15[1];
        *v7 = v22;
        if (v22)
          *(_QWORD *)(v22 + 16) = v7;
        v15[2] = v7[2];
        *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v15;
        v15[1] = v7;
        v7[2] = (uint64_t)v15;
        v16 = v7;
      }
      else
      {
        v15 = v7;
      }
      v23 = v15[2];
      *((_BYTE *)v15 + 24) = *(_BYTE *)(v23 + 24);
      *(_BYTE *)(v23 + 24) = 1;
      *((_BYTE *)v16 + 24) = 1;
      v24 = *(uint64_t **)(v23 + 8);
      v25 = *v24;
      *(_QWORD *)(v23 + 8) = *v24;
      if (v25)
        *(_QWORD *)(v25 + 16) = v23;
      v24[2] = *(_QWORD *)(v23 + 16);
      *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
      *v24 = v23;
      goto LABEL_72;
    }
    v16 = (uint64_t *)v7[1];
    if (v16 && !*((_BYTE *)v16 + 24))
      goto LABEL_55;
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (v17 == result)
    {
      v17 = result;
LABEL_53:
      *((_BYTE *)v17 + 24) = 1;
      return result;
    }
    if (!*((_BYTE *)v17 + 24))
      goto LABEL_53;
LABEL_49:
    v7 = *(uint64_t **)(v17[2] + 8 * (*(_QWORD *)v17[2] == (_QWORD)v17));
  }
  if (!*((_BYTE *)v7 + 24))
  {
    *((_BYTE *)v7 + 24) = 1;
    *(_BYTE *)(v12 + 24) = 0;
    v18 = v7[1];
    *(_QWORD *)v12 = v18;
    if (v18)
      *(_QWORD *)(v18 + 16) = v12;
    v7[2] = *(_QWORD *)(v12 + 16);
    *(_QWORD *)(*(_QWORD *)(v12 + 16) + 8 * (**(_QWORD **)(v12 + 16) != v12)) = v7;
    v7[1] = v12;
    *(_QWORD *)(v12 + 16) = v7;
    if (result == (uint64_t *)v12)
      result = v7;
    v7 = *(uint64_t **)v12;
  }
  v19 = (_QWORD *)*v7;
  if (*v7 && !*((_BYTE *)v19 + 24))
    goto LABEL_68;
  v20 = (uint64_t *)v7[1];
  if (!v20 || *((_BYTE *)v20 + 24))
  {
    *((_BYTE *)v7 + 24) = 0;
    v17 = (uint64_t *)v7[2];
    if (*((_BYTE *)v17 + 24))
      v21 = v17 == result;
    else
      v21 = 1;
    if (v21)
      goto LABEL_53;
    goto LABEL_49;
  }
  if (v19 && !*((_BYTE *)v19 + 24))
  {
LABEL_68:
    v20 = v7;
  }
  else
  {
    *((_BYTE *)v20 + 24) = 1;
    *((_BYTE *)v7 + 24) = 0;
    v26 = *v20;
    v7[1] = *v20;
    if (v26)
      *(_QWORD *)(v26 + 16) = v7;
    v20[2] = v7[2];
    *(_QWORD *)(v7[2] + 8 * (*(_QWORD *)v7[2] != (_QWORD)v7)) = v20;
    *v20 = (uint64_t)v7;
    v7[2] = (uint64_t)v20;
    v19 = v7;
  }
  v23 = v20[2];
  *((_BYTE *)v20 + 24) = *(_BYTE *)(v23 + 24);
  *(_BYTE *)(v23 + 24) = 1;
  *((_BYTE *)v19 + 24) = 1;
  v24 = *(uint64_t **)v23;
  v27 = *(_QWORD *)(*(_QWORD *)v23 + 8);
  *(_QWORD *)v23 = v27;
  if (v27)
    *(_QWORD *)(v27 + 16) = v23;
  v24[2] = *(_QWORD *)(v23 + 16);
  *(_QWORD *)(*(_QWORD *)(v23 + 16) + 8 * (**(_QWORD **)(v23 + 16) != v23)) = v24;
  v24[1] = v23;
LABEL_72:
  *(_QWORD *)(v23 + 16) = v24;
  return result;
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::pop_front(int64x2_t *a1)
{
  unint64_t v2;

  v2 = *(_QWORD *)(a1->i64[1] + 8 * (a1[2].i64[0] / 0x11uLL)) + 240 * (a1[2].i64[0] % 0x11uLL);

  std::__tree<std::array<unsigned char,16ul>>::destroy(v2 + 208, *(_QWORD **)(v2 + 216));
  a1[2] = vaddq_s64(a1[2], (int64x2_t)xmmword_1B3C0B480);
  return std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__maybe_remove_front_spare[abi:ne180100]((uint64_t)a1, 1);
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::__maybe_remove_front_spare[abi:ne180100](uint64_t a1, int a2)
{
  unint64_t v2;
  int v4;

  v2 = *(_QWORD *)(a1 + 32);
  if (v2 < 0x11)
    a2 = 1;
  if (v2 < 0x22)
    v4 = a2;
  else
    v4 = 0;
  if ((v4 & 1) == 0)
  {
    operator delete(**(void ***)(a1 + 8));
    *(_QWORD *)(a1 + 8) += 8;
    *(_QWORD *)(a1 + 32) -= 17;
  }
  return v4 ^ 1u;
}

uint64_t std::deque<std::pair<std::array<unsigned char,16ul>,ARTexturedPlane>>::~deque[abi:ne180100](_QWORD *a1)
{
  void **v2;
  void **v3;
  _QWORD *v4;
  unint64_t v5;
  void **v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  void *v13;

  v2 = (void **)a1[1];
  v3 = (void **)a1[2];
  if (v3 == v2)
  {
    v4 = a1 + 5;
    v3 = (void **)a1[1];
  }
  else
  {
    v4 = a1 + 5;
    v5 = a1[4];
    v6 = &v2[v5 / 0x11];
    v7 = (unint64_t)*v6 + 240 * (v5 % 0x11);
    v8 = (unint64_t)v2[(a1[5] + v5) / 0x11] + 240 * ((a1[5] + v5) % 0x11);
    if (v7 != v8)
    {
      do
      {

        std::__tree<std::array<unsigned char,16ul>>::destroy(v7 + 208, *(_QWORD **)(v7 + 216));
        v7 += 240;
        if (v7 - (_QWORD)*v6 == 4080)
        {
          v9 = (unint64_t)v6[1];
          ++v6;
          v7 = v9;
        }
      }
      while (v7 != v8);
      v2 = (void **)a1[1];
      v3 = (void **)a1[2];
    }
  }
  *v4 = 0;
  v10 = (char *)v3 - (char *)v2;
  if ((unint64_t)((char *)v3 - (char *)v2) >= 0x11)
  {
    do
    {
      operator delete(*v2);
      v3 = (void **)a1[2];
      v2 = (void **)(a1[1] + 8);
      a1[1] = v2;
      v10 = (char *)v3 - (char *)v2;
    }
    while ((unint64_t)((char *)v3 - (char *)v2) > 0x10);
  }
  v11 = v10 >> 3;
  if (v11 == 1)
  {
    v12 = 8;
  }
  else
  {
    if (v11 != 2)
      goto LABEL_16;
    v12 = 17;
  }
  a1[4] = v12;
LABEL_16:
  while (v2 != v3)
  {
    v13 = *v2++;
    operator delete(v13);
  }
  return std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::~__split_buffer((uint64_t)a1);
}

void std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(uint64_t a1, _QWORD *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(a1, *a2);
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::destroy(a1, a2[1]);
    std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)(a2 + 6), (_QWORD *)a2[7]);
    operator delete(a2);
  }
}

_OWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::__emplace_unique_key_args<std::array<unsigned char,16ul>,std::piecewise_construct_t const&,std::tuple<std::array<unsigned char,16ul> const&>,std::tuple<>>(uint64_t **a1, uint64_t a2, uint64_t a3, _OWORD **a4)
{
  void **v6;
  _OWORD *v7;
  uint64_t **v8;
  uint64_t v10;

  v6 = (void **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, &v10, a2);
  v7 = *v6;
  if (!*v6)
  {
    v8 = (uint64_t **)v6;
    v7 = operator new(0x48uLL);
    v7[2] = **a4;
    *((_QWORD *)v7 + 8) = 0;
    *((_QWORD *)v7 + 7) = 0;
    *((_QWORD *)v7 + 6) = (char *)v7 + 56;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v10, v8, (uint64_t *)v7);
  }
  return v7;
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_1E666E9E0, MEMORY[0x1E0DE42E0]);
}

void sub_1B3B78FB0(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x1E0DE5028] + 16);
  return result;
}

_QWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,std::set<std::array<unsigned char,16ul>>>>>::find<std::array<unsigned char,16ul>>(uint64_t a1, uint64_t a2)
{
  _QWORD *result;
  _QWORD *v3;
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;

  v4 = *(_QWORD **)(a1 + 8);
  result = (_QWORD *)(a1 + 8);
  v3 = v4;
  if (v4)
  {
    v5 = result;
    do
    {
      v6 = 0;
      while (1)
      {
        v7 = *((unsigned __int8 *)v3 + v6 + 32);
        v8 = *(unsigned __int8 *)(a2 + v6);
        if (v7 < v8)
          break;
        if (v8 < v7 || v6++ == 15)
        {
          v5 = v3;
          break;
        }
      }
      if (v7 < v8)
        ++v3;
      v3 = (_QWORD *)*v3;
    }
    while (v3);
    if (v5 != result)
    {
      v10 = 0;
      while (1)
      {
        v11 = *(unsigned __int8 *)(a2 + v10);
        v12 = *((unsigned __int8 *)v5 + v10 + 32);
        if (v11 < v12)
          break;
        if (v12 < v11 || v10++ == 15)
          return v5;
      }
    }
  }
  return result;
}

uint64_t *std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::map[abi:ne180100](uint64_t *a1, uint64_t a2)
{
  a1[2] = 0;
  a1[1] = 0;
  *a1 = (uint64_t)(a1 + 1);
  std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>>(a1, *(_QWORD **)a2, (_QWORD *)(a2 + 8));
  return a1;
}

void sub_1B3B790A8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t *std::map<std::array<unsigned char,16ul>,ARTexturedPlane>::insert[abi:ne180100]<std::__map_const_iterator<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>>(uint64_t *result, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  uint64_t **v5;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  BOOL v9;

  if (a2 != a3)
  {
    v4 = a2;
    v5 = (uint64_t **)result;
    v6 = result + 1;
    do
    {
      result = std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(v5, v6, (uint64_t)(v4 + 4), (uint64_t)(v4 + 4));
      v7 = (_QWORD *)v4[1];
      if (v7)
      {
        do
        {
          v8 = v7;
          v7 = (_QWORD *)*v7;
        }
        while (v7);
      }
      else
      {
        do
        {
          v8 = (_QWORD *)v4[2];
          v9 = *v8 == (_QWORD)v4;
          v4 = v8;
        }
        while (!v9);
      }
      v4 = v8;
    }
    while (v8 != a3);
  }
  return result;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_hint_unique_key_args<std::array<unsigned char,16ul>,std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t **a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;
  uint64_t v10;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(a1, a2, &v10, &v9, a3);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)a1, a4, (uint64_t)&v8);
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, v10, v6, v8);
    return v8;
  }
  return result;
}

_QWORD *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t a5)
{
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v13;
  _QWORD *v14;
  _QWORD *v15;
  _QWORD *v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v22;
  _QWORD *v23;
  _QWORD *v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;

  if (a1 + 1 != a2)
  {
    v5 = 0;
    while (1)
    {
      v6 = *(unsigned __int8 *)(a5 + v5);
      v7 = *((unsigned __int8 *)a2 + v5 + 32);
      if (v6 < v7)
        break;
      v8 = v7 < v6 || v5++ == 15;
      if (v8)
      {
        v9 = 0;
        while (1)
        {
          v10 = *((unsigned __int8 *)a2 + v9 + 32);
          v11 = *(unsigned __int8 *)(a5 + v9);
          if (v10 < v11)
            break;
          if (v11 < v10 || v9++ == 15)
          {
            *a3 = a2;
            *a4 = a2;
            return a4;
          }
        }
        v22 = a2[1];
        if (v22)
        {
          v23 = (_QWORD *)a2[1];
          do
          {
            a4 = v23;
            v23 = (_QWORD *)*v23;
          }
          while (v23);
        }
        else
        {
          v24 = a2;
          do
          {
            a4 = (_QWORD *)v24[2];
            v8 = *a4 == (_QWORD)v24;
            v24 = a4;
          }
          while (!v8);
        }
        if (a4 != a1 + 1)
        {
          v25 = 0;
          while (1)
          {
            v26 = *(unsigned __int8 *)(a5 + v25);
            v27 = *((unsigned __int8 *)a4 + v25 + 32);
            if (v26 < v27)
              break;
            if (v27 < v26 || v25++ == 15)
              return std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
          }
        }
        if (v22)
        {
          *a3 = a4;
        }
        else
        {
          *a3 = a2;
          return a2 + 1;
        }
        return a4;
      }
    }
  }
  v13 = *a2;
  if ((_QWORD *)*a1 == a2)
  {
    v15 = a2;
  }
  else
  {
    if (v13)
    {
      v14 = (_QWORD *)*a2;
      do
      {
        v15 = v14;
        v14 = (_QWORD *)v14[1];
      }
      while (v14);
    }
    else
    {
      v16 = a2;
      do
      {
        v15 = (_QWORD *)v16[2];
        v8 = *v15 == (_QWORD)v16;
        v16 = v15;
      }
      while (v8);
    }
    v17 = 0;
    while (1)
    {
      v18 = *((unsigned __int8 *)v15 + v17 + 32);
      v19 = *(unsigned __int8 *)(a5 + v17);
      if (v18 < v19)
        break;
      if (v19 < v18 || v17++ == 15)
        return std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__find_equal<std::array<unsigned char,16ul>>((uint64_t)a1, a3, a5);
    }
  }
  if (v13)
  {
    *a3 = v15;
    return v15 + 1;
  }
  else
  {
    *a3 = a2;
    return a2;
  }
}

uint64_t **std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__assign_multi<std::__tree_const_iterator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__tree_node<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,void *> *,long>>(uint64_t **result, _QWORD *a2, _QWORD *a3)
{
  uint64_t **v5;
  uint64_t *v6;
  uint64_t *v7;
  uint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  BOOL v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t **v14;
  uint64_t *v15;
  uint64_t *v16;
  _QWORD v17[2];

  v5 = result;
  if (result[2])
  {
    v6 = *result;
    v7 = result[1];
    *result = (uint64_t *)(result + 1);
    v7[2] = 0;
    result[1] = 0;
    result[2] = 0;
    if (v6[1])
      v8 = (uint64_t *)v6[1];
    else
      v8 = v6;
    v14 = result;
    v15 = v8;
    v16 = v8;
    if (v8)
    {
      v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v8);
      if (a2 != a3)
      {
        v9 = a2;
        do
        {
          v17[0] = v8 + 4;
          v17[1] = v8 + 6;
          std::pair<std::array<unsigned char,16ul> &,ARTexturedPlane &>::operator=[abi:ne180100]<std::array<unsigned char,16ul> const,ARTexturedPlane,(void *)0>((uint64_t)v17, (uint64_t)(v9 + 4));
          std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__node_insert_multi(v5, v16);
          v16 = v15;
          if (v15)
            v15 = std::__tree<std::array<unsigned char,16ul>>::_DetachedTreeCache::__detach_next((uint64_t)v15);
          v10 = (_QWORD *)v9[1];
          if (v10)
          {
            do
            {
              a2 = v10;
              v10 = (_QWORD *)*v10;
            }
            while (v10);
          }
          else
          {
            do
            {
              a2 = (_QWORD *)v9[2];
              v11 = *a2 == (_QWORD)v9;
              v9 = a2;
            }
            while (!v11);
          }
          v8 = v16;
          if (v16)
            v11 = a2 == a3;
          else
            v11 = 1;
          v9 = a2;
        }
        while (!v11);
      }
    }
    result = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)&v14);
  }
  if (a2 != a3)
  {
    do
    {
      result = (uint64_t **)std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_multi<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>((uint64_t)v5, (uint64_t)(a2 + 4));
      v12 = (_QWORD *)a2[1];
      if (v12)
      {
        do
        {
          v13 = v12;
          v12 = (_QWORD *)*v12;
        }
        while (v12);
      }
      else
      {
        do
        {
          v13 = (_QWORD *)a2[2];
          v11 = *v13 == (_QWORD)a2;
          a2 = v13;
        }
        while (!v11);
      }
      a2 = v13;
    }
    while (v13 != a3);
  }
  return result;
}

void sub_1B3B794A4(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100]((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__node_insert_multi(uint64_t **a1, uint64_t *a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t **v9;

  v3 = a1 + 1;
  v4 = a1[1];
  if (v4)
  {
LABEL_2:
    while (2)
    {
      v3 = (uint64_t **)v4;
      v5 = 32;
      while (1)
      {
        v6 = *((unsigned __int8 *)a2 + v5);
        v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7)
          break;
        if (v7 >= v6 && v5++ != 47)
          continue;
        v4 = v3[1];
        if (v4)
          goto LABEL_2;
        v9 = v3 + 1;
        goto LABEL_12;
      }
      v4 = *v3;
      v9 = v3;
      if (*v3)
        continue;
      break;
    }
  }
  else
  {
    v9 = a1 + 1;
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v3, v9, a2);
  return a2;
}

uint64_t std::pair<std::array<unsigned char,16ul> &,ARTexturedPlane &>::operator=[abi:ne180100]<std::array<unsigned char,16ul> const,ARTexturedPlane,(void *)0>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;

  *(_OWORD *)*(_QWORD *)a1 = *(_OWORD *)a2;
  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_OWORD *)(a2 + 16);
  v6 = *(_OWORD *)(a2 + 32);
  v7 = *(_OWORD *)(a2 + 64);
  *(_OWORD *)(v4 + 32) = *(_OWORD *)(a2 + 48);
  *(_OWORD *)(v4 + 48) = v7;
  *(_OWORD *)v4 = v5;
  *(_OWORD *)(v4 + 16) = v6;
  v8 = *(_OWORD *)(a2 + 80);
  v9 = *(_OWORD *)(a2 + 96);
  v10 = *(_OWORD *)(a2 + 128);
  *(_OWORD *)(v4 + 96) = *(_OWORD *)(a2 + 112);
  *(_OWORD *)(v4 + 112) = v10;
  *(_OWORD *)(v4 + 64) = v8;
  *(_OWORD *)(v4 + 80) = v9;
  v11 = *(_OWORD *)(a2 + 144);
  v12 = *(_OWORD *)(a2 + 160);
  v13 = *(_OWORD *)(a2 + 192);
  *(_OWORD *)(v4 + 160) = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(v4 + 176) = v13;
  *(_OWORD *)(v4 + 128) = v11;
  *(_OWORD *)(v4 + 144) = v12;
  if (v4 != a2 + 16)
    std::__tree<std::array<unsigned char,16ul>>::__assign_multi<std::__tree_const_iterator<std::array<unsigned char,16ul>,std::__tree_node<std::array<unsigned char,16ul>,void *> *,long>>((uint64_t **)(v4 + 192), *(_QWORD **)(a2 + 208), (_QWORD *)(a2 + 216));
  objc_storeStrong((id *)(v4 + 216), *(id *)(a2 + 232));
  return a1;
}

uint64_t std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::_DetachedTreeCache::~_DetachedTreeCache[abi:ne180100](uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;

  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(*(_QWORD *)a1, *(_QWORD **)(a1 + 16));
  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    v3 = (_QWORD *)v2[2];
    if (v3)
    {
      do
      {
        v2 = v3;
        v3 = (_QWORD *)v3[2];
      }
      while (v3);
      *(_QWORD *)(a1 + 8) = v2;
    }
    std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::destroy(*(_QWORD *)a1, v2);
  }
  return a1;
}

uint64_t *std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__emplace_multi<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(uint64_t a1, uint64_t a2)
{
  uint64_t **v3;
  uint64_t *v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  uint64_t **v9;
  uint64_t *v11;

  std::__tree<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::__map_value_compare<std::array<unsigned char,16ul>,std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>,std::less<std::array<unsigned char,16ul>>,true>,std::allocator<std::__value_type<std::array<unsigned char,16ul>,ARTexturedPlane>>>::__construct_node<std::pair<std::array<unsigned char,16ul> const,ARTexturedPlane> const&>(a1, a2, (uint64_t)&v11);
  v3 = (uint64_t **)(a1 + 8);
  v4 = *(uint64_t **)(a1 + 8);
  if (v4)
  {
LABEL_2:
    while (2)
    {
      v3 = (uint64_t **)v4;
      v5 = 32;
      while (1)
      {
        v6 = *((unsigned __int8 *)v11 + v5);
        v7 = *((unsigned __int8 *)v3 + v5);
        if (v6 < v7)
          break;
        if (v7 >= v6 && v5++ != 47)
          continue;
        v4 = v3[1];
        if (v4)
          goto LABEL_2;
        v9 = v3 + 1;
        goto LABEL_12;
      }
      v4 = *v3;
      v9 = v3;
      if (*v3)
        continue;
      break;
    }
  }
  else
  {
    v9 = (uint64_t **)(a1 + 8);
  }
LABEL_12:
  _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_((uint64_t **)a1, (uint64_t)v3, v9, v11);
  return v11;
}

id std::vector<ARTexturedPlane>::__construct_one_at_end[abi:ne180100]<ARTexturedPlane const&>(uint64_t a1, id *a2)
{
  uint64_t v4;
  __int128 v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  id result;

  v4 = *(_QWORD *)(a1 + 8);
  v5 = *(_OWORD *)a2;
  v6 = *((_OWORD *)a2 + 1);
  v7 = *((_OWORD *)a2 + 3);
  *(_OWORD *)(v4 + 32) = *((_OWORD *)a2 + 2);
  *(_OWORD *)(v4 + 48) = v7;
  *(_OWORD *)v4 = v5;
  *(_OWORD *)(v4 + 16) = v6;
  v8 = *((_OWORD *)a2 + 4);
  v9 = *((_OWORD *)a2 + 5);
  v10 = *((_OWORD *)a2 + 7);
  *(_OWORD *)(v4 + 96) = *((_OWORD *)a2 + 6);
  *(_OWORD *)(v4 + 112) = v10;
  *(_OWORD *)(v4 + 64) = v8;
  *(_OWORD *)(v4 + 80) = v9;
  v11 = *((_OWORD *)a2 + 8);
  v12 = *((_OWORD *)a2 + 9);
  v13 = *((_OWORD *)a2 + 11);
  *(_OWORD *)(v4 + 160) = *((_OWORD *)a2 + 10);
  *(_OWORD *)(v4 + 176) = v13;
  *(_OWORD *)(v4 + 128) = v11;
  *(_OWORD *)(v4 + 144) = v12;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100](v4 + 192, (uint64_t)(a2 + 24));
  result = a2[27];
  *(_QWORD *)(v4 + 216) = result;
  *(_QWORD *)(a1 + 8) = v4 + 224;
  return result;
}

void sub_1B3B79748(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<ARTexturedPlane>::__push_back_slow_path<ARTexturedPlane const&>(uint64_t *a1, id *a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  _QWORD *v10;
  _OWORD *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __int128 v19;
  __int128 v20;
  uint64_t v21;
  _QWORD v23[2];
  _OWORD *v24;
  char *v25;
  uint64_t *v26;

  v3 = *a1;
  v4 = 0x6DB6DB6DB6DB6DB7 * ((a1[1] - *a1) >> 5);
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) > 0x124924924924924)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0x6DB6DB6DB6DB6DB7 * ((a1[2] - v3) >> 5);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x92492492492492)
    v9 = 0x124924924924924;
  else
    v9 = v5;
  v26 = a1 + 2;
  if (v9)
    v10 = std::__allocate_at_least[abi:ne180100]<std::allocator<ARTexturedPlane>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[28 * v4];
  v23[0] = v10;
  v23[1] = v11;
  v24 = v11;
  v25 = (char *)&v10[28 * v9];
  v12 = *(_OWORD *)a2;
  v13 = *((_OWORD *)a2 + 1);
  v14 = *((_OWORD *)a2 + 3);
  v11[2] = *((_OWORD *)a2 + 2);
  v11[3] = v14;
  v15 = *((_OWORD *)a2 + 7);
  v17 = *((_OWORD *)a2 + 4);
  v16 = *((_OWORD *)a2 + 5);
  v11[6] = *((_OWORD *)a2 + 6);
  v11[7] = v15;
  v11[4] = v17;
  v11[5] = v16;
  v18 = *((_OWORD *)a2 + 11);
  v20 = *((_OWORD *)a2 + 8);
  v19 = *((_OWORD *)a2 + 9);
  v11[10] = *((_OWORD *)a2 + 10);
  v11[11] = v18;
  v11[8] = v20;
  v11[9] = v19;
  *v11 = v12;
  v11[1] = v13;
  std::set<std::array<unsigned char,16ul>>::set[abi:ne180100]((uint64_t)(v11 + 12), (uint64_t)(a2 + 24));
  v10[28 * v4 + 27] = a2[27];
  v24 += 14;
  std::vector<ARTexturedPlane>::__swap_out_circular_buffer(a1, v23);
  v21 = a1[1];
  std::__split_buffer<ARTexturedPlane>::~__split_buffer((uint64_t)v23);
  return v21;
}

void sub_1B3B798A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<ARTexturedPlane>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<ARTexturedPlane>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<ARTexturedPlane>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x124924924924925)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(224 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>,std::reverse_iterator<ARTexturedPlane*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  __int128 v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  _QWORD v24[3];
  char v25;
  __int128 v26;
  __int128 v27;

  v7 = a7;
  *(_QWORD *)&v27 = a6;
  *((_QWORD *)&v27 + 1) = a7;
  v26 = v27;
  v24[0] = a1;
  v24[1] = &v26;
  v24[2] = &v27;
  if (a3 == a5)
  {
    v22 = a6;
  }
  else
  {
    do
    {
      v8 = *(_OWORD *)(a3 - 224);
      v9 = *(_OWORD *)(a3 - 208);
      v10 = *(_OWORD *)(a3 - 176);
      *(_OWORD *)(v7 - 192) = *(_OWORD *)(a3 - 192);
      *(_OWORD *)(v7 - 176) = v10;
      *(_OWORD *)(v7 - 224) = v8;
      *(_OWORD *)(v7 - 208) = v9;
      v11 = *(_OWORD *)(a3 - 160);
      v12 = *(_OWORD *)(a3 - 144);
      v13 = *(_OWORD *)(a3 - 112);
      *(_OWORD *)(v7 - 128) = *(_OWORD *)(a3 - 128);
      *(_OWORD *)(v7 - 112) = v13;
      *(_OWORD *)(v7 - 160) = v11;
      *(_OWORD *)(v7 - 144) = v12;
      v14 = *(_OWORD *)(a3 - 96);
      v15 = *(_OWORD *)(a3 - 80);
      v16 = *(_OWORD *)(a3 - 48);
      *(_OWORD *)(v7 - 64) = *(_OWORD *)(a3 - 64);
      *(_OWORD *)(v7 - 48) = v16;
      *(_OWORD *)(v7 - 96) = v14;
      *(_OWORD *)(v7 - 80) = v15;
      *(_QWORD *)(v7 - 32) = *(_QWORD *)(a3 - 32);
      v17 = (_QWORD *)(a3 - 24);
      v18 = *(_QWORD *)(a3 - 24);
      *(_QWORD *)(v7 - 24) = v18;
      v19 = v7 - 24;
      v20 = *(_QWORD *)(a3 - 16);
      *(_QWORD *)(v7 - 16) = v20;
      if (v20)
      {
        *(_QWORD *)(v18 + 16) = v19;
        *(_QWORD *)(a3 - 32) = v17;
        *v17 = 0;
        *(_QWORD *)(a3 - 16) = 0;
      }
      else
      {
        *(_QWORD *)(v7 - 32) = v19;
      }
      v21 = *(_QWORD *)(a3 - 8);
      *(_QWORD *)(a3 - 8) = 0;
      *(_QWORD *)(v7 - 8) = v21;
      v7 = *((_QWORD *)&v27 + 1) - 224;
      *((_QWORD *)&v27 + 1) -= 224;
      a3 -= 224;
    }
    while (a3 != a5);
    v22 = v27;
  }
  v25 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v24);
  return v22;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<ARTexturedPlane>,std::reverse_iterator<ARTexturedPlane*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x1E0C80C00];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<ARTexturedPlane>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>,std::reverse_iterator<std::reverse_iterator<ARTexturedPlane*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;

  for (i = *(_QWORD *)(a2 + 32); i != *(_QWORD *)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {

    std::__tree<std::array<unsigned char,16ul>>::destroy(i + 192, *(_QWORD **)(i + 200));
    i = *(_QWORD *)(a2 + 32) + 224;
  }
}

uint64_t std::__split_buffer<ARTexturedPlane>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<ARTexturedPlane>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<ARTexturedPlane>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t i;

  for (i = *(_QWORD *)(a1 + 16); i != a2; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 224;

    std::__tree<std::array<unsigned char,16ul>>::destroy(i - 32, *(_QWORD **)(i - 24));
  }
}

void sub_1B3B7A18C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1B3B7A50C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7A578(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B7A5C8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t GetRelativeMotionAndYaw(const simd_double4x4 *a1, const simd_double4x4 *a2, double *a3, double *a4)
{
  double v7;
  double v8;
  uint64_t result;
  double v10;
  float64x2_t v11;
  float64x2_t v12;
  float64x2_t v13;
  double v14;
  double v15;
  float64x2_t v16;
  double v17;
  double v18;

  Transform4DofFromMatrix(a1, (uint64_t)&v16);
  v7 = v18;
  Transform4DofFromMatrix(a2, (uint64_t)&v13);
  v8 = v15;
  *a4 = 0.0;
  result = 1;
  v10 = v8 - v7 + ceil((v8 - v7) / -360.0) * 360.0;
  if (v10 > 180.0)
    v10 = v10 + -360.0;
  *a4 = v10;
  v11.f64[1] = v16.f64[1];
  v12 = vsubq_f64(v13, v16);
  v11.f64[0] = v14 - v17;
  *a3 = sqrt(vmulq_f64(v11, v11).f64[0] + vaddvq_f64(vmulq_f64(v12, v12)));
  return result;
}

float angleDiff(float a1, float a2)
{
  float result;

  for (result = a2 - a1; result < -180.0; result = result + 360.0)
    ;
  for (; result >= 180.0; result = result + -360.0)
    ;
  return result;
}

uint64_t SanityCheck(uint64_t a1, uint64_t a2, uint64_t a3, float64x2_t *a4)
{
  float v8;
  float v9;
  float i;
  float v11;
  float j;
  float k;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  double v18;
  int32x2_t v19;
  _BYTE v20[24];
  double v21;
  _BYTE v22[24];
  double v23;
  _BYTE v24[24];
  double v25;

  Transform4DofFromMatrix((const simd_double4x4 *)a1, (uint64_t)v24);
  Transform4DofFromMatrix((const simd_double4x4 *)a2, (uint64_t)v22);
  Transform4DofFromMatrix((const simd_double4x4 *)a3, (uint64_t)v20);
  v8 = v23;
  v9 = v21;
  for (i = v9 - v8; i < -180.0; i = i + 360.0)
    ;
  for (; i >= 180.0; i = i + -360.0)
    ;
  v11 = v25;
  for (j = v9 - v11; j < -180.0; j = j + 360.0)
    ;
  for (k = fabsf(i); j >= 180.0; j = j + -360.0)
    ;
  if (fabsf(j) + 0.001 < k)
    return 0;
  v16 = a4[6];
  v15 = a4[7];
  v17 = vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a3, v16.f64[0]), *(float64x2_t *)(a3 + 32), v16, 1), *(float64x2_t *)(a3 + 64), v15.f64[0]), *(float64x2_t *)(a3 + 96), v15, 1);
  *(_QWORD *)&v18 = *(_OWORD *)&vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a3 + 16), v16.f64[0]), *(float64x2_t *)(a3 + 48), v16, 1), *(float64x2_t *)(a3 + 80), v15.f64[0]), *(float64x2_t *)(a3 + 112), v15, 1);
  v19 = vmovn_s64(vcgeq_f64(vaddq_f64(vabdq_f64(v17, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a1, v16.f64[0]), *(float64x2_t *)(a1 + 32), v16, 1), *(float64x2_t *)(a1 + 64), v15.f64[0]), *(float64x2_t *)(a1 + 96), v15, 1)), (float64x2_t)vdupq_n_s64(0x3F50624DD2F1A9FCuLL)), vabdq_f64(v17, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)a2, v16.f64[0]), *(float64x2_t *)(a2 + 32), v16, 1), *(float64x2_t *)(a2 + 64),
                  v15.f64[0]),
                *(float64x2_t *)(a2 + 96),
                v15,
                1))));
  return (v19.i8[0] & (vabdd_f64(v18, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a2 + 16), v16.f64[0]), *(float64x2_t *)(a2 + 48), v16, 1), *(float64x2_t *)(a2 + 80), v15.f64[0]), *(float64x2_t *)(a2 + 112), v15, 1).f64[0]) <= vabdd_f64(v18, vmlaq_laneq_f64(vmlaq_n_f64(vmlaq_laneq_f64(vmulq_n_f64(*(float64x2_t *)(a1 + 16), v16.f64[0]), *(float64x2_t *)(a1 + 48),
                                                                  v16,
                                                                  1),
                                                                *(float64x2_t *)(a1 + 80),
                                                                v15.f64[0]),
                                                              *(float64x2_t *)(a1 + 112),
                                                              v15,
                                                              1).f64[0])
                                                        + 0.001)) & v19.i8[4];
}

void sub_1B3B7B8B4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_21()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void sub_1B3B7BBA4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7BD08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7BDDC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B7CF68(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,void *a49,void *a50,uint64_t a51,uint64_t a52,uint64_t a53,void *a54,uint64_t a55,uint64_t a56,uint64_t a57,void *a58)
{
  void *v58;
  void *v59;
  void *v60;

  _Unwind_Resume(a1);
}

void sub_1B3B7DA4C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  void *v20;

  _Unwind_Resume(a1);
}

void sub_1B3B7DDD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B7E154(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B7E4C0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B7E6A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B7E700(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B7E840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3B7EC04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, void *a10, void *a11, void *a12, void *a13, void *a14)
{
  void *v14;
  void *v15;
  void *v16;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_22()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void std::vector<ARTexturedPlane>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<ARTexturedPlane>::__base_destruct_at_end[abi:ne180100]((uint64_t)a1, *a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

double ARMatrix4x4MakeRowMajorTransform(double *a1)
{
  unsigned int v1;
  unsigned int v2;

  *(float *)&v1 = *a1;
  *(float *)&v2 = a1[3];
  return COERCE_DOUBLE(__PAIR64__(v2, v1));
}

float32x2_t ARMatrix4x4MakeColumnMajorTransform(float64x2_t *a1)
{
  return vcvt_f32_f64(*a1);
}

double ARMatrix4x4RowMajorRotationAndTranslation(float64x2_t *a1, float64x2_t *a2, int8x16_t a3, int8x16_t a4, __n128 a5, __n128 a6)
{
  float32x2_t v6;
  double result;

  a1->f64[0] = *(float *)a3.i32;
  a1->f64[1] = *(float *)a4.i32;
  v6 = (float32x2_t)vzip2_s32(*(int32x2_t *)a4.i8, (int32x2_t)a5.n128_u64[0]);
  a5.n128_u32[1] = a3.u32[1];
  a1[1] = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v6);
  a1[3] = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  a1[4].f64[0] = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

double ARMatrix3x3RowMajorArray(float64x2_t *a1, int8x16_t a2, int8x16_t a3, __n128 a4)
{
  float32x2_t v4;
  double result;

  v4 = (float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, (int32x2_t)a4.n128_u64[0]);
  a4.n128_u32[1] = a2.u32[1];
  a1->f64[0] = *(float *)a2.i32;
  a1->f64[1] = *(float *)a3.i32;
  a1[1] = vcvtq_f64_f32((float32x2_t)a4.n128_u64[0]);
  a1[2] = vcvtq_f64_f32(v4);
  a1[3] = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL)));
  result = a4.n128_f32[2];
  a1[4].f64[0] = a4.n128_f32[2];
  return result;
}

double ARRowMajor3x3MatrixArrayToColumnMajor3x3MatrixArray(uint64_t a1, uint64_t a2)
{
  double result;

  *(_QWORD *)a2 = *(_QWORD *)a1;
  *(_QWORD *)(a2 + 8) = *(_QWORD *)(a1 + 24);
  *(_QWORD *)(a2 + 16) = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a2 + 24) = *(_QWORD *)(a1 + 8);
  *(_QWORD *)(a2 + 32) = *(_QWORD *)(a1 + 32);
  *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a2 + 48) = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a2 + 56) = *(_QWORD *)(a1 + 40);
  result = *(double *)(a1 + 64);
  *(double *)(a2 + 64) = result;
  return result;
}

float32x2_t ARMatrix3x3MakeRowMajorTransform(float64_t *a1)
{
  float64x2_t v1;

  v1.f64[0] = *a1;
  v1.f64[1] = a1[3];
  return vcvt_f32_f64(v1);
}

float32x2_t ARMatrix3x3MakeColumnMajorTransform(float64x2_t *a1)
{
  return vcvt_f32_f64(*a1);
}

__n128 ARMatrix4x4MakeColumnMajorTransformFromArrayF(uint64_t a1)
{
  return *(__n128 *)a1;
}

double ARMatrix4x4MakeColumnMajorTransformFromArray(float64x2_t *a1)
{
  double result;

  *(_QWORD *)&result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a1), a1[1]).u64[0];
  return result;
}

uint64_t ARMatrix3x3IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  float32x4_t v3;
  uint32x4_t v4;

  v3.i64[0] = 0x3400000034000000;
  v3.i64[1] = 0x3400000034000000;
  v4 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v3, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v3, vabsq_f32(a2))), (int8x16_t)vcgeq_f32(v3, vabsq_f32(a3)));
  v4.i32[3] = v4.i32[2];
  return vminvq_u32(v4) >> 31;
}

uint64_t ARMatrix4x3IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4;
  uint32x4_t v5;

  v4.i64[0] = 0x3400000034000000;
  v4.i64[1] = 0x3400000034000000;
  v5 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a2))), vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a3)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a4))));
  v5.i32[3] = v5.i32[2];
  return vminvq_u32(v5) >> 31;
}

uint64_t ARMatrix4x4IsZero(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  float32x4_t v4;

  v4.i64[0] = 0x3400000034000000;
  v4.i64[1] = 0x3400000034000000;
  return vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a1)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a2))), vandq_s8((int8x16_t)vcgeq_f32(v4, vabsq_f32(a3)), (int8x16_t)vcgeq_f32(v4, vabsq_f32(a4))))) >> 31;
}

uint64_t ARMatrix3x3IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3)
{
  uint32x4_t v3;
  uint32x4_t v4;
  uint32x4_t v6;

  v3 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)));
  v3.i32[3] = v3.i32[2];
  if ((vminvq_u32(v3) & 0x80000000) == 0)
    return 0;
  v4 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)));
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0)
    return 0;
  v6 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)));
  v6.i32[3] = v6.i32[2];
  return vminvq_u32(v6) >> 31;
}

uint64_t ARMatrix4x3IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  uint32x4_t v4;
  uint32x4_t v5;
  uint32x4_t v6;
  uint32x4_t v8;

  v4 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)));
  v4.i32[3] = v4.i32[2];
  if ((vminvq_u32(v4) & 0x80000000) == 0)
    return 0;
  v5 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)));
  v5.i32[3] = v5.i32[2];
  if ((vminvq_u32(v5) & 0x80000000) == 0)
    return 0;
  v6 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)));
  v6.i32[3] = v6.i32[2];
  if ((vminvq_u32(v6) & 0x80000000) == 0)
    return 0;
  v8 = (uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a4), (int8x16_t)vcgezq_f32(a4)));
  v8.i32[3] = v8.i32[2];
  return vminvq_u32(v8) >> 31;
}

uint64_t ARMatrix4x4IsNAN(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4)
{
  if ((vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a1), (int8x16_t)vcgezq_f32(a1)))) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a2), (int8x16_t)vcgezq_f32(a2)))) & 0x80000000) != 0
    && (vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a3), (int8x16_t)vcgezq_f32(a3)))) & 0x80000000) != 0)
  {
    return vminvq_u32((uint32x4_t)vmvnq_s8(vorrq_s8((int8x16_t)vcltzq_f32(a4), (int8x16_t)vcgezq_f32(a4)))) >> 31;
  }
  else
  {
    return 0;
  }
}

double ARMatrix4x4ColumnMajorRotationAndTranslation(uint64_t a1, float64x2_t *a2, __n128 a3, __n128 a4, __n128 a5, __n128 a6)
{
  double result;

  *(float64x2_t *)a1 = vcvtq_f64_f32((float32x2_t)a3.n128_u64[0]);
  *(double *)(a1 + 16) = a3.n128_f32[2];
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a4.n128_u64[0]);
  *(double *)(a1 + 40) = a4.n128_f32[2];
  *(float64x2_t *)(a1 + 48) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(double *)(a1 + 64) = a5.n128_f32[2];
  *a2 = vcvtq_f64_f32((float32x2_t)a6.n128_u64[0]);
  result = a6.n128_f32[2];
  a2[1].f64[0] = a6.n128_f32[2];
  return result;
}

float64x2_t ARMatrix4x4ColumnMajorCopyValues(float64x2_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float64x2_t result;

  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  result = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[6] = result;
  a1[7] = vcvt_hight_f64_f32(a5);
  return result;
}

double ARMatrix4x4RowMajorCopyValues4x3(uint64_t a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, __n128 a5)
{
  float32x2_t v5;
  double result;

  *(double *)a1 = *(float *)a2.i32;
  *(double *)(a1 + 8) = *(float *)a3.i32;
  *(double *)(a1 + 16) = *(float *)a4.i32;
  v5 = (float32x2_t)vext_s8((int8x8_t)a5.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  a5.n128_u32[1] = a2.u32[1];
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(float64x2_t *)(a1 + 40) = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, *(int32x2_t *)a4.i8));
  *(float64x2_t *)(a1 + 56) = vcvtq_f64_f32(v5);
  *(float64x2_t *)(a1 + 72) = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  result = a5.n128_f32[2];
  *(double *)(a1 + 88) = a5.n128_f32[2];
  return result;
}

uint64_t ARMatrix3x3CopyValues(uint64_t result, __n128 a2, __n128 a3, __n128 a4)
{
  *(_DWORD *)(result + 8) = a2.n128_u32[2];
  *(_DWORD *)(result + 20) = a3.n128_u32[2];
  *(_QWORD *)result = a2.n128_u64[0];
  *(_QWORD *)(result + 12) = a3.n128_u64[0];
  *(_DWORD *)(result + 32) = a4.n128_u32[2];
  *(_QWORD *)(result + 24) = a4.n128_u64[0];
  return result;
}

__n128 *ARMatrix4x4CopyValues(__n128 *result, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  *result = a2;
  result[1] = a3;
  result[2] = a4;
  result[3] = a5;
  return result;
}

double ARMatrix4x4FromCMRotationMatrix(double *a1)
{
  unsigned int v1;
  unsigned int v2;

  *(float *)&v1 = *a1;
  *(float *)&v2 = a1[3];
  return COERCE_DOUBLE(__PAIR64__(v2, v1));
}

double ARMatrix4x3Inverse(simd_float4x4 a1)
{
  double result;

  a1.columns[0].i32[3] = 0;
  a1.columns[1].i32[3] = 0;
  a1.columns[2].i32[3] = 0;
  a1.columns[3].i32[3] = 1.0;
  *(_QWORD *)&result = (unint64_t)__invert_f4(a1);
  return result;
}

float ARAdjustIntrinsicsForViewportSize(float result, double a2, double a3, double a4, double a5, double a6, double a7)
{
  double v8;
  BOOL v9;
  double v10;

  if (a4 != a6 || a5 != a7)
  {
    v8 = result;
    v9 = a6 / a7 < a4 / a5;
    v10 = a6 / a4;
    if (v9)
      v10 = a7 / a5;
    return v10 * v8;
  }
  return result;
}

float ARMatrixMakeFrustum(float a1, double a2, double a3, float64_t a4, float64_t a5)
{
  float v6;

  ARLinkedOnOrAfterPeace();
  _Q2.f64[0] = a4;
  _Q2.f64[1] = a5;
  v6 = vcvt_f32_f64(_Q2).f32[0];
  __asm { FMOV            V2.2S, #1.0 }
  return (float)(a1 + a1) / v6;
}

double ARMatrixPerspectiveFlipZ(double a1, double a2, __n128 a3, __n128 a4)
{
  uint64_t v4;
  _OWORD v6[4];
  _OWORD v7[4];

  v4 = 0;
  v6[2] = a3;
  v6[3] = a4;
  memset(v7, 0, sizeof(v7));
  do
  {
    v7[v4] = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDC0, COERCE_FLOAT(v6[v4])), (float32x4_t)xmmword_1B3BDFDD0, *(float32x2_t *)&v6[v4], 1), (float32x4_t)xmmword_1B3BDFDE0, (float32x4_t)v6[v4], 2), (float32x4_t)xmmword_1B3C0B500, (float32x4_t)v6[v4], 3);
    ++v4;
  }
  while (v4 != 4);
  return *(double *)v7;
}

double ARMatrixMakePerspective(int a1, int8x16_t a2, float32x4_t a3, float a4, float a5, float a6, float32_t a7, double a8, float32x4_t a9)
{
  float v9;
  float v10;
  float v11;
  float v12;
  float v13;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float v23;
  float v24;
  float v25;
  float v26;
  double v27;
  float v29;
  float v30;
  __n128 v31;

  a9.i32[0] = 2139095040;
  if (a7 == 0.0)
    a7 = INFINITY;
  if (a6 == INFINITY)
    a6 = 0.000001;
  if (a6 < 0.000001)
    a6 = 0.000001;
  if (a7 < 0.000001)
    a7 = 0.000001;
  if ((float)(a3.f32[0] - *(float *)a2.i32) >= 0.000001)
    v9 = a3.f32[0];
  else
    v9 = *(float *)a2.i32 + 0.000001;
  if ((float)(a5 - a4) < 0.000001)
    a5 = a4 + 0.000001;
  if ((float)(a7 - a6) >= 0.000001)
    a3.f32[0] = a7;
  else
    a3.f32[0] = a6 + 0.000001;
  v10 = a6 * *(float *)a2.i32;
  v11 = v9 * a6;
  v12 = a5 * a6;
  v13 = a6 * a4;
  *(float *)a2.i32 = v11 - (float)(a6 * *(float *)a2.i32);
  __asm { FMOV            V6.4S, #1.0 }
  _Q6.i32[0] = a2.i32[0];
  *(float *)&a2.i32[1] = v12 - (float)(a6 * a4);
  *(float *)&a2.i32[2] = a3.f32[0] - a6;
  _Q6.i32[1] = a2.i32[1];
  v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vceqq_f32(a3, a9), 0), _Q6, a2);
  v19.i32[3] = 0;
  v20 = vrecpeq_f32(v19);
  v21 = vmulq_f32(v20, vrecpsq_f32(v19, v20));
  v22 = vmulq_f32(v21, vrecpsq_f32(v19, v21));
  v23 = (float)(a6 + a6) * v22.f32[0];
  v24 = vmuls_lane_f32(a6 + a6, *(float32x2_t *)v22.f32, 1);
  v25 = (float)(v10 + v11) * v22.f32[0];
  v26 = vmuls_lane_f32(v13 + v12, *(float32x2_t *)v22.f32, 1);
  if (a3.f32[0] == INFINITY)
  {
    LODWORD(v27) = 0;
    v22.i32[1] = 0;
    v22.f32[0] = (float)(a6 + a6) * v22.f32[0];
    *((float *)&v27 + 1) = v24;
    __asm { FMOV            V2.4S, #-1.0 }
    _Q2.n128_u64[0] = __PAIR64__(LODWORD(v26), LODWORD(v25));
    v29 = -a6;
  }
  else
  {
    v30 = vmuls_lane_f32(-a3.f32[0], v22, 2);
    v29 = a6 * v30;
    LODWORD(v27) = 0;
    v22.i64[0] = LODWORD(v23);
    *((float *)&v27 + 1) = v24;
    __asm { FMOV            V2.4S, #-1.0 }
    _Q2.n128_u64[0] = __PAIR64__(LODWORD(v26), LODWORD(v25));
    _Q2.n128_f32[2] = v30;
  }
  v31.n128_u64[0] = 0;
  v31.n128_u64[1] = LODWORD(v29);
  if (a1)
    *(double *)v22.i64 = ARMatrixPerspectiveFlipZ(*(double *)v22.i64, v27, _Q2, v31);
  return *(double *)v22.i64;
}

float ARIntrinsicsFromTangent(float a1, double a2)
{
  double v2;
  float v3;
  float v4;

  v2 = a1;
  v3 = 1.0 / a1;
  if (v2 < 0.000001)
    v3 = 0.000001;
  v4 = a2 * 0.5;
  __asm
  {
    FMOV            V2.2D, #0.5
    FMOV            V4.2D, #-0.5
    FMOV            V2.4S, #1.0
  }
  return v3 * v4;
}

float ARIntrinsicsFromTangents(int8x16_t a1, float64x2_t a2, float64_t a3, float a4)
{
  int32x2_t v4;
  float32x2_t v5;

  v4 = (int32x2_t)vextq_s8(a1, a1, 8uLL).u64[0];
  v5 = (float32x2_t)vzip1_s32(*(int32x2_t *)a1.i8, v4);
  a2.f64[1] = a3;
  __asm { FMOV            V2.4S, #1.0 }
  return (float)((float)-vcvt_f32_f64(vsubq_f64(vdivq_f64(vmulq_f64(a2, vcvtq_f64_f32(v5)), vcvtq_f64_f32(vsub_f32(v5, (float32x2_t)vzip2_s32(*(int32x2_t *)a1.i8, v4)))), (float64x2_t)vdupq_lane_s64(COERCE__INT64(a4), 0))).f32[0]- a4)/ *(float *)a1.i32;
}

float ARIntrinsicsFromDeviceFormat(void *a1)
{
  id v1;
  float v2;
  float v3;
  long double v4;
  int32_t width;

  v1 = a1;
  width = CMVideoFormatDescriptionGetDimensions((CMVideoFormatDescriptionRef)objc_msgSend(v1, "formatDescription")).width;
  objc_msgSend(v1, "videoFieldOfView");
  v3 = v2;

  v4 = tan(v3 * 3.14159265 / 180.0 * 0.5);
  __asm { FMOV            V2.4S, #1.0 }
  return (double)width / (v4 + v4);
}

float32x2_t ARCameraFieldOfViewFromIntrinsics(float a1, double a2, double a3, double a4, double a5)
{
  long double v6;
  float64x2_t v7;
  float v9;
  long double v10;

  v9 = *((float *)&a2 + 1);
  v10 = atan(a4 / (float)(a1 + a1));
  v6 = atan(a5 / (float)(v9 + v9));
  v7.f64[0] = v10;
  v7.f64[1] = v6;
  return vcvt_f32_f64(vaddq_f64(v7, v7));
}

double AREulerAnglesFromMatrix(__n128 a1, __n128 a2, __n128 a3)
{
  double v3;
  float v5;
  __n128 v6;
  float v7;
  float v8;

  if (a3.n128_f32[1] >= 1.0)
  {
    atan2f(-a1.n128_f32[2], -a2.n128_f32[2]);
    LODWORD(v3) = -1077342245;
LABEL_6:
    HIDWORD(v3) = 0;
    return v3;
  }
  if (a3.n128_f32[1] <= -1.0)
  {
    atan2f(a1.n128_f32[2], a2.n128_f32[2]);
    LODWORD(v3) = 1070141403;
    goto LABEL_6;
  }
  v6 = a3;
  v7 = a2.n128_f32[1];
  v5 = a1.n128_f32[1];
  v8 = asinf(-a3.n128_f32[1]);
  v6.n128_u32[0] = atan2f(v6.n128_f32[0], v6.n128_f32[2]);
  atan2f(v5, v7);
  return COERCE_DOUBLE(__PAIR64__(v6.n128_u32[0], LODWORD(v8)));
}

__n64 ARInnerScaleFromMatrix(float32x4_t a1, float32x4_t a2)
{
  float32x4_t v2;
  float32x4_t v3;
  __n64 result;

  v2 = vmulq_f32(a1, a1);
  result.n64_f32[0] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v2, 2), vaddq_f32(v2, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v2.f32, 1))).f32[0]);
  v3 = vmulq_f32(a2, a2);
  result.n64_u32[1] = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v3, 2), vaddq_f32(v3, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v3.f32, 1))).f32[0]);
  return result;
}

double ARNormalizedTransform(float32x4_t a1)
{
  int32x4_t v1;
  float32x2_t v2;
  float32x2_t v3;
  double result;

  v1 = (int32x4_t)vmulq_f32(a1, a1);
  v1.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v1, 2), vadd_f32(*(float32x2_t *)v1.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v1.i8, 1))).u32[0];
  v2 = vrsqrte_f32((float32x2_t)v1.u32[0]);
  v3 = vmul_f32(v2, vrsqrts_f32((float32x2_t)v1.u32[0], vmul_f32(v2, v2)));
  *(_QWORD *)&result = vmulq_n_f32(a1, vmul_f32(v3, vrsqrts_f32((float32x2_t)v1.u32[0], vmul_f32(v3, v3))).f32[0]).u64[0];
  return result;
}

double ARMatrixMakeLookAt(double a1, float32x4_t a2)
{
  int32x4_t v2;
  float32x4_t v3;
  float32x4_t v4;
  int32x4_t v5;
  float32x2_t v6;
  float32x2_t v7;
  double result;

  v2 = (int32x4_t)vnegq_f32(a2);
  v3 = vmlaq_f32(vmulq_f32((float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32(v2, v2), (int8x16_t)v2, 0xCuLL), (float32x4_t)xmmword_1B3C0B510), (float32x4_t)xmmword_1B3C0B520, a2);
  v4 = (float32x4_t)vextq_s8((int8x16_t)vuzp1q_s32((int32x4_t)v3, (int32x4_t)v3), (int8x16_t)v3, 0xCuLL);
  v5 = (int32x4_t)vmulq_f32(v3, v3);
  v5.i32[0] = vadd_f32((float32x2_t)vdup_lane_s32(*(int32x2_t *)v5.i8, 1), vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v5, 2), *(float32x2_t *)v5.i8)).u32[0];
  v6 = vrsqrte_f32((float32x2_t)v5.u32[0]);
  v7 = vmul_f32(v6, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v6, v6)));
  *(_QWORD *)&result = vmulq_n_f32(v4, vmul_f32(v7, vrsqrts_f32((float32x2_t)v5.u32[0], vmul_f32(v7, v7))).f32[0]).u64[0];
  return result;
}

uint64_t AREqualTransforms(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, float32x4_t a6, float32x4_t a7, float32x4_t a8)
{
  float32x4_t v8;
  float32x4_t v9;

  v8 = vabdq_f32(a1, a5);
  v9 = (float32x4_t)vdupq_n_s32(0x38FA0000u);
  return vminvq_u32((uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v9, v8), (int8x16_t)vcgeq_f32(v9, vabdq_f32(a2, a6))), vandq_s8((int8x16_t)vcgeq_f32(v9, vabdq_f32(a3, a7)), (int8x16_t)vcgeq_f32(v9, vabdq_f32(a4, a8))))) >> 31;
}

double ARVisionToRenderingCoordinateTransform()
{
  return *(double *)&_PromotedConst_5;
}

double ARRenderingToVisionCoordinateTransform()
{
  double result;
  simd_float4x4 v1;

  v1.columns[0] = (simd_float4)_PromotedConst_40;
  v1.columns[1] = (simd_float4)unk_1B3C0B5B0;
  v1.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v1.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  *(_QWORD *)&result = (unint64_t)__invert_f4(v1);
  return result;
}

double ARVisionCameraToRenderingCoordinateTransform()
{
  return simd_matrix4x4((float32x4_t)_PromotedConst_41);
}

double ARRenderingToVisionCameraCoordinateTransform()
{
  return simd_matrix4x4((float32x4_t)_PromotedConst_41);
}

double ARRFUToRUBCoordinateTransform()
{
  return *(double *)&_PromotedConst_42;
}

double ARLFUToRUBCoordinateTransform()
{
  return *(double *)&_PromotedConst_43;
}

double ARIMUtoCameraCoordinateTransform()
{
  return *(double *)&_PromotedConst_44;
}

double ARFrontFacingCameraFlip()
{
  return *(double *)&_PromotedConst_45;
}

double ARMatrix4x4MirrorX(double a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  uint64_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  __int128 v14;
  __n128 v15;
  __n128 v16;
  __n128 v17;
  float32x4_t v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;

  v4 = 0;
  v5 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v6 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 32);
  v7 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 48);
  v15 = a2;
  v16 = a3;
  v17 = a4;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v4) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BE00D0, COERCE_FLOAT(*(__int128 *)((char *)&v14 + v4))), v5, *(float32x2_t *)((char *)&v14 + v4), 1), v6, *(float32x4_t *)((char *)&v14 + v4), 2), v7, *(float32x4_t *)((char *)&v14 + v4), 3);
    v4 += 16;
  }
  while (v4 != 64);
  v8 = 0;
  v9 = v18;
  v10 = v19;
  v11 = v20;
  v12 = v21;
  v14 = xmmword_1B3BE00D0;
  v15 = (__n128)v5;
  v16 = (__n128)v6;
  v17 = (__n128)v7;
  v18 = 0u;
  v19 = 0u;
  v20 = 0u;
  v21 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v18 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v9, COERCE_FLOAT(*(__int128 *)((char *)&v14 + v8))), v10, *(float32x2_t *)((char *)&v14 + v8), 1), v11, *(float32x4_t *)((char *)&v14 + v8), 2), v12, *(float32x4_t *)((char *)&v14 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  return *(double *)v18.i64;
}

double ARCameraToWorldTransformFromCMRotationMatrix(double *a1, uint64_t a2, int a3)
{
  float32x4_t v3;
  float32_t v4;
  float v5;
  float32_t v6;
  float32x4_t v7;
  float v8;
  __n128 v9;
  float v10;
  float v11;
  __n128 v12;
  float v13;
  float v14;
  float v15;
  __n128 v16;
  unint64_t v17;
  unsigned int v18;
  float32x4_t v19;
  unint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v26;
  __n128 v27;
  __int128 v28;
  __n128 v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;

  v3 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v4 = a1[4];
  v7.i32[3] = HIDWORD(*MEMORY[0x1E0C83FF0]);
  v7.f32[0] = v4;
  v5 = a1[5];
  v7.f32[1] = -v5;
  v6 = a1[3];
  v7.f32[2] = v6;
  v8 = a1[1];
  v12.n128_u32[3] = v3.u32[3];
  v12.n128_f32[0] = -v8;
  v16 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 32);
  v9 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 48);
  v10 = a1[2];
  v12.n128_f32[1] = v10;
  v11 = *a1;
  v12.n128_f32[2] = -v11;
  v13 = a1[7];
  v16.n128_f32[0] = -v13;
  v14 = a1[8];
  v16.n128_f32[1] = v14;
  v15 = a1[6];
  v16.n128_f32[2] = -v15;
  if (a2 == 2)
  {
    v17 = 0;
    if (a3)
      v18 = -1;
    else
      v18 = 0;
    v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v18), *MEMORY[0x1E0C83FF0], (int8x16_t)xmmword_1B3BE00D0);
    v26 = v7;
    v27 = v12;
    v28 = (__int128)v16;
    v29 = v9;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v17))), v3, *(float32x2_t *)&v26.f32[v17 / 4], 1), (float32x4_t)xmmword_1B3BDFDE0, *(float32x4_t *)((char *)&v26 + v17), 2), (float32x4_t)v9, *(float32x4_t *)((char *)&v26 + v17), 3);
      v17 += 16;
    }
    while (v17 != 64);
    v20 = 0;
    v21 = v30;
    v22 = v31;
    v23 = v32;
    v24 = v33;
    v26 = v19;
    v27 = (__n128)v3;
    v28 = xmmword_1B3BDFDE0;
    v29 = v9;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v21, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v20))), v22, *(float32x2_t *)&v26.f32[v20 / 4], 1), v23, *(float32x4_t *)((char *)&v26 + v20), 2), v24, *(float32x4_t *)((char *)&v26 + v20), 3);
      v20 += 16;
    }
    while (v20 != 64);
    v7.i64[0] = v30.i64[0];
  }
  else if (a3)
  {
    *(double *)v7.i64 = ARMatrix4x4MirrorX(*(double *)v7.i64, v12, v16, v9);
  }
  return *(double *)v7.i64;
}

double ARWorldToCameraTransformFromCMRotationMatrix(double *a1, uint64_t a2, int a3)
{
  float32x4_t v3;
  float32_t v4;
  float v5;
  float v6;
  float32x4_t v7;
  float v8;
  float v9;
  unsigned int v10;
  __n128 v11;
  __n128 v12;
  float v13;
  float v14;
  float v15;
  __n128 v16;
  unint64_t v17;
  unsigned int v18;
  float32x4_t v19;
  unint64_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  float32x4_t v24;
  float32x4_t v26;
  __n128 v27;
  __int128 v28;
  __n128 v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;

  v3 = *(float32x4_t *)(MEMORY[0x1E0C83FF0] + 16);
  v4 = a1[4];
  v7.i32[3] = HIDWORD(*MEMORY[0x1E0C83FF0]);
  v7.f32[0] = v4;
  v5 = a1[1];
  v7.f32[1] = -v5;
  v6 = a1[7];
  v7.f32[2] = -v6;
  v8 = a1[5];
  v11.n128_f32[0] = -v8;
  v9 = a1[2];
  v11.n128_f32[1] = v9;
  *(float *)&v10 = a1[8];
  v11.n128_u64[1] = __PAIR64__(v3.u32[3], v10);
  v16 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 32);
  v12 = *(__n128 *)(MEMORY[0x1E0C83FF0] + 48);
  v13 = a1[3];
  v16.n128_f32[0] = v13;
  v14 = *a1;
  v16.n128_f32[1] = -v14;
  v15 = a1[6];
  v16.n128_f32[2] = -v15;
  if (a2 == 2)
  {
    v17 = 0;
    if (a3)
      v18 = -1;
    else
      v18 = 0;
    v19 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_n_s32(v18), *MEMORY[0x1E0C83FF0], (int8x16_t)xmmword_1B3BE00D0);
    v26 = v7;
    v27 = v11;
    v28 = (__int128)v16;
    v29 = v12;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v17) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v19, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v17))), v3, *(float32x2_t *)&v26.f32[v17 / 4], 1), (float32x4_t)xmmword_1B3BDFDE0, *(float32x4_t *)((char *)&v26 + v17), 2), (float32x4_t)v12, *(float32x4_t *)((char *)&v26 + v17), 3);
      v17 += 16;
    }
    while (v17 != 64);
    v20 = 0;
    v21 = v30;
    v22 = v31;
    v23 = v32;
    v24 = v33;
    v26 = v19;
    v27 = (__n128)v3;
    v28 = xmmword_1B3BDFDE0;
    v29 = v12;
    v30 = 0u;
    v31 = 0u;
    v32 = 0u;
    v33 = 0u;
    do
    {
      *(float32x4_t *)((char *)&v30 + v20) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v21, COERCE_FLOAT(*(_OWORD *)((char *)&v26 + v20))), v22, *(float32x2_t *)&v26.f32[v20 / 4], 1), v23, *(float32x4_t *)((char *)&v26 + v20), 2), v24, *(float32x4_t *)((char *)&v26 + v20), 3);
      v20 += 16;
    }
    while (v20 != 64);
    v7.i64[0] = v30.i64[0];
  }
  else if (a3)
  {
    *(double *)v7.i64 = ARMatrix4x4MirrorX(*(double *)v7.i64, v11, v16, v12);
  }
  return *(double *)v7.i64;
}

__n128 ARMatrix3x3FromArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  __n128 result;
  unsigned __int32 v6;
  __n128 v7;
  __n128 v8;

  v1 = a1;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = ARVector3FromArray(v2);
  objc_msgSend(v1, "objectAtIndexedSubscript:", 1);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = ARVector3FromArray(v3);
  objc_msgSend(v1, "objectAtIndexedSubscript:", 2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = ARVector3FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARVector3FromArray(void *a1)
{
  id v1;
  void *v2;
  unsigned __int32 v3;
  void *v4;
  unsigned __int32 v5;
  void *v6;
  unsigned __int32 v7;
  __n128 result;
  unsigned __int32 v9;
  unsigned __int32 v10;
  unsigned __int32 v11;

  v1 = a1;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "floatValue");
  v11 = v3;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "floatValue");
  v10 = v5;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v6, "floatValue");
  v9 = v7;

  result.n128_u32[0] = v11;
  result.n128_u32[1] = v10;
  result.n128_u32[2] = v9;
  return result;
}

__n128 ARMatrix3x3FromRowMajorFlatArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  __n128 result;
  unsigned __int32 v6;
  __n128 v7;
  __n128 v8;

  v1 = a1;
  objc_msgSend(v1, "subarrayWithRange:", 0, 3);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = ARVector3FromArray(v2);
  objc_msgSend(v1, "subarrayWithRange:", 3, 3);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = ARVector3FromArray(v3);
  objc_msgSend(v1, "subarrayWithRange:", 6, 3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = ARVector3FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARMatrix3x3FromColumnMajorFlatArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  __n128 v6;

  v1 = a1;
  objc_msgSend(v1, "subarrayWithRange:", 0, 3);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v6 = ARVector3FromArray(v2);
  objc_msgSend(v1, "subarrayWithRange:", 3, 3);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  ARVector3FromArray(v3);
  objc_msgSend(v1, "subarrayWithRange:", 6, 3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  ARVector3FromArray(v4);
  return v6;
}

__n128 ARMatrix4x3FromRowMajorFlatArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  __n128 result;
  unsigned __int32 v6;
  __n128 v7;
  __n128 v8;

  v1 = a1;
  objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = ARVector4FromArray(v2);
  objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = ARVector4FromArray(v3);
  objc_msgSend(v1, "subarrayWithRange:", 8, 4);
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = ARVector4FromArray(v4).n128_u32[0];
  result.n128_u64[0] = vzip1q_s32((int32x4_t)v8, (int32x4_t)v7).u64[0];
  result.n128_u32[2] = v6;
  return result;
}

__n128 ARVector4FromArray(void *a1)
{
  id v1;
  void *v2;
  unsigned int v3;
  void *v4;
  unsigned int v5;
  void *v6;
  unsigned int v7;
  void *v8;
  __int128 v9;
  unsigned int v10;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  __int128 v15;

  v1 = a1;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "floatValue");
  v14 = v3;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "floatValue");
  v13 = v5;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 2);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "floatValue");
  v12 = v7;
  objc_msgSend(v1, "objectAtIndexedSubscript:", 3);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v8, "floatValue");
  *(_QWORD *)&v9 = __PAIR64__(v13, v14);
  *((_QWORD *)&v9 + 1) = __PAIR64__(v10, v12);
  v15 = v9;

  return (__n128)v15;
}

id ARMatrix3x3ToColumnMajorFlatArray(__n128 a1, __n128 a2, __n128 a3)
{
  void *v3;
  double v4;
  void *v5;
  void *v6;
  void *v7;
  double v8;
  void *v9;
  void *v10;
  void *v11;
  double v12;
  void *v13;
  void *v14;
  void *v15;
  _QWORD v20[10];

  v20[9] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v20[0] = v3;
  HIDWORD(v4) = a1.n128_u32[1];
  LODWORD(v4) = a1.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v20[1] = v5;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v20[2] = v6;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a2.n128_f64[0]);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v20[3] = v7;
  HIDWORD(v8) = a2.n128_u32[1];
  LODWORD(v8) = a2.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v20[4] = v9;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[2])));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v20[5] = v10;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a3.n128_f64[0]);
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v20[6] = v11;
  HIDWORD(v12) = a3.n128_u32[1];
  LODWORD(v12) = a3.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v12);
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  v20[7] = v13;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[2])));
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v20[8] = v14;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v20, 9);
  v15 = (void *)objc_claimAutoreleasedReturnValue();

  return v15;
}

id ARMatrix4x4ToColumnMajorFlatArray(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  double v4;
  double v5;
  void *v6;
  void *v7;
  double v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  double v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  _QWORD v29[18];

  v29[16] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  v24 = (void *)objc_claimAutoreleasedReturnValue();
  v29[0] = v24;
  HIDWORD(v4) = a1.n128_u32[1];
  LODWORD(v4) = a1.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v4);
  v23 = (void *)objc_claimAutoreleasedReturnValue();
  v29[1] = v23;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v22 = (void *)objc_claimAutoreleasedReturnValue();
  v29[2] = v22;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[3])));
  a1.n128_u64[0] = objc_claimAutoreleasedReturnValue();
  v29[3] = a1.n128_u64[0];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a2.n128_f64[0]);
  v21 = (void *)objc_claimAutoreleasedReturnValue();
  v29[4] = v21;
  HIDWORD(v5) = a2.n128_u32[1];
  LODWORD(v5) = a2.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v5);
  v20 = (void *)objc_claimAutoreleasedReturnValue();
  v29[5] = v20;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[2])));
  v19 = (void *)objc_claimAutoreleasedReturnValue();
  v29[6] = v19;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a2.n128_u32[1], a2.n128_u32[3])));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  v29[7] = v6;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a3.n128_f64[0]);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  v29[8] = v7;
  HIDWORD(v8) = a3.n128_u32[1];
  LODWORD(v8) = a3.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v29[9] = v9;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[2])));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  v29[10] = v10;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a3.n128_u32[1], a3.n128_u32[3])));
  v11 = (void *)objc_claimAutoreleasedReturnValue();
  v29[11] = v11;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a4.n128_f64[0]);
  v12 = (void *)objc_claimAutoreleasedReturnValue();
  v29[12] = v12;
  HIDWORD(v13) = a4.n128_u32[1];
  LODWORD(v13) = a4.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v13);
  v14 = (void *)objc_claimAutoreleasedReturnValue();
  v29[13] = v14;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a4.n128_u32[1], a4.n128_u32[2])));
  v15 = (void *)objc_claimAutoreleasedReturnValue();
  v29[14] = v15;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a4.n128_u32[1], a4.n128_u32[3])));
  v16 = (void *)objc_claimAutoreleasedReturnValue();
  v29[15] = v16;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v29, 16);
  v17 = (void *)objc_claimAutoreleasedReturnValue();

  return v17;
}

float64x2_t ARMatrix4x4ToColumnMajorFlatCArray(float64x2_t *a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  float64x2_t result;

  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  result = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[6] = result;
  a1[7] = vcvt_hight_f64_f32(a5);
  return result;
}

float ARMatrix4x4ToColumnMajor3x4FlatCArray(uint64_t a1, uint64_t a2)
{
  float result;

  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 4);
  *(_DWORD *)(a2 + 8) = *(_DWORD *)(a1 + 8);
  *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 16);
  *(_DWORD *)(a2 + 16) = *(_DWORD *)(a1 + 20);
  *(_DWORD *)(a2 + 20) = *(_DWORD *)(a1 + 24);
  *(_DWORD *)(a2 + 24) = *(_DWORD *)(a1 + 32);
  *(_DWORD *)(a2 + 28) = *(_DWORD *)(a1 + 36);
  *(_DWORD *)(a2 + 32) = *(_DWORD *)(a1 + 40);
  *(_DWORD *)(a2 + 36) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(a2 + 40) = *(_DWORD *)(a1 + 52);
  result = *(float *)(a1 + 56);
  *(float *)(a2 + 44) = result;
  return result;
}

__n128 ARMatrix4x4FromRowMajorFlatArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __n128 v7;
  __n128 v8;
  __n128 v9;
  int32x4_t v10;

  v1 = a1;
  objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = ARVector4FromArray(v2);
  objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v8 = ARVector4FromArray(v3);
  objc_msgSend(v1, "subarrayWithRange:", 8, 4);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = ARVector4FromArray(v4);
  objc_msgSend(v1, "subarrayWithRange:", 12, 4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v10 = vzip1q_s32(vzip1q_s32((int32x4_t)v9, (int32x4_t)v7), vzip1q_s32((int32x4_t)v8, (int32x4_t)ARVector4FromArray(v5)));
  return (__n128)v10;
}

__n128 ARMatrix4x4FromColumnMajorFlatArray(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __n128 v7;

  v1 = a1;
  objc_msgSend(v1, "subarrayWithRange:", 0, 4);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v7 = ARVector4FromArray(v2);
  objc_msgSend(v1, "subarrayWithRange:", 4, 4);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  ARVector4FromArray(v3);
  objc_msgSend(v1, "subarrayWithRange:", 8, 4);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  ARVector4FromArray(v4);
  objc_msgSend(v1, "subarrayWithRange:", 12, 4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  ARVector4FromArray(v5);
  return v7;
}

__n128 ARVector3dFromArray@<Q0>(void *a1@<X0>, __n128 *a2@<X8>)
{
  id v3;
  void *v4;
  unint64_t v5;
  void *v6;
  unint64_t v7;
  void *v8;
  __n128 v9;
  __n128 result;
  __n128 v11;
  unint64_t v12;
  unint64_t v13;
  __n128 v14;

  v3 = a1;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 0);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "doubleValue");
  v13 = v5;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 1);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "doubleValue");
  v12 = v7;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 2);
  v8 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v8, "doubleValue");
  v11 = v9;
  v9.n128_u64[0] = v13;
  v9.n128_u64[1] = v12;
  v14 = v9;

  result = v14;
  *a2 = v14;
  a2[1] = v11;
  return result;
}

double ARVector3FromCArray(uint64_t a1)
{
  return *(double *)a1;
}

void ARVector4dFromArray(void *a1@<X0>, _OWORD *a2@<X8>)
{
  id v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  void *v7;
  uint64_t v8;
  void *v9;
  __int128 v10;
  uint64_t v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  id v16;

  v3 = a1;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 0);
  v16 = (id)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v16, "doubleValue");
  v15 = v4;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 1);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "doubleValue");
  v14 = v6;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 2);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v7, "doubleValue");
  v13 = v8;
  objc_msgSend(v3, "objectAtIndexedSubscript:", 3);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v9, "doubleValue");
  *(_QWORD *)&v10 = v13;
  *((_QWORD *)&v10 + 1) = v11;
  *(_QWORD *)&v12 = v15;
  *((_QWORD *)&v12 + 1) = v14;
  *a2 = v12;
  a2[1] = v10;

}

id ARVector3ToArray(__n128 a1)
{
  void *v1;
  double v2;
  void *v3;
  void *v4;
  void *v5;
  _QWORD v8[4];

  v8[3] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = v1;
  HIDWORD(v2) = a1.n128_u32[1];
  LODWORD(v2) = a1.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v8[1] = v3;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[2] = v4;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

id ARVector3dToArray(double *a1)
{
  double v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __int128 v7;
  _QWORD v8[4];

  v8[3] = *MEMORY[0x1E0C80C00];
  v7 = *(_OWORD *)a1;
  v1 = a1[2];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(_QWORD *)a1);
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v8[0] = v2;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((double *)&v7 + 1));
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v8[1] = v3;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v1);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v8[2] = v4;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v8, 3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

id ARVector4ToArray(__n128 a1)
{
  void *v1;
  double v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  _QWORD v9[5];

  v9[4] = *MEMORY[0x1E0C80C00];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = v1;
  HIDWORD(v2) = a1.n128_u32[1];
  LODWORD(v2) = a1.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v2);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v9[1] = v3;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[2])));
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v9[2] = v4;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a1.n128_u32[1], a1.n128_u32[3])));
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v9[3] = v5;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

id ARVector4dToArray(__int128 *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  __int128 v7;
  double v8[3];
  _QWORD v9[5];

  v9[4] = *MEMORY[0x1E0C80C00];
  v7 = *a1;
  *(_OWORD *)v8 = a1[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *(_QWORD *)a1);
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  v9[0] = v1;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", *((double *)&v7 + 1));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v9[1] = v2;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v8[0]);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v9[2] = v3;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithDouble:", v8[1]);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  v9[3] = v4;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v9, 4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

double ARVector2FromNSData(void *a1)
{
  double v2;

  v2 = 0.0;
  objc_msgSend(a1, "getBytes:length:", &v2, 8);
  return v2;
}

double ARVector3FromNSData(void *a1)
{
  double v2;
  int v3;

  v3 = 0;
  v2 = 0.0;
  objc_msgSend(a1, "getBytes:length:", &v2, 16);
  return v2;
}

double ARVector3dFromNSData@<D0>(void *a1@<X0>, _OWORD *a2@<X8>)
{
  double result;
  __int128 v4;
  __int128 v5;
  __int128 v6;

  *(_QWORD *)&v6 = 0;
  v5 = 0uLL;
  objc_msgSend(a1, "getBytes:length:", &v5, 32);
  result = *(double *)&v5;
  v4 = v6;
  *a2 = v5;
  a2[1] = v4;
  return result;
}

double ARMatrix3x3FromNSData(void *a1)
{
  _OWORD v2[3];

  memset(v2, 0, sizeof(v2));
  objc_msgSend(a1, "getBytes:length:", v2, 48);
  return *(double *)v2;
}

double ARMatrix4x3FromNSData(void *a1)
{
  _OWORD v2[4];

  memset(v2, 0, sizeof(v2));
  objc_msgSend(a1, "getBytes:length:", v2, 64);
  return *(double *)v2;
}

double ARMatrix4x4FromNSData(void *a1)
{
  _OWORD v2[4];

  memset(v2, 0, sizeof(v2));
  objc_msgSend(a1, "getBytes:length:", v2, 64);
  return *(double *)v2;
}

__n128 ARMatrix4x4FromDictionary(void *a1)
{
  id v1;
  void *v2;
  void *v3;
  char isKindOfClass;
  __n128 v5;
  float32x4_t v6;
  __float2 v7;
  float32x4_t v8;
  float32x4_t v9;
  void *v10;
  __n128 v11;
  float32x4_t v12;
  void *v13;
  unsigned __int32 v14;
  float32x4_t v15;
  float32x4_t v16;
  __n128 v18;
  float32x4_t v19;
  float32x4_t v20;
  float32x4_t v21;

  v1 = a1;
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("translation"));
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  v18 = 0u;
  if ((objc_opt_isKindOfClass() & 1) != 0)
    v18 = ARVector3FromArray(v2);
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("rotation"), *(_OWORD *)&v18);
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  isKindOfClass = objc_opt_isKindOfClass();
  v19 = *(float32x4_t *)MEMORY[0x1E0C83FE8];
  if ((isKindOfClass & 1) != 0)
  {
    v5 = ARVector4FromArray(v3);
    if (fabsf(v5.n128_f32[3]) > 0.00000011921)
    {
      v6 = vmulq_f32((float32x4_t)v5, (float32x4_t)v5);
      if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v6, 2), vaddq_f32(v6, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v6.f32, 1))).f32[0]) > 0.00000011921)
      {
        v20 = (float32x4_t)v5;
        v7 = __sincosf_stret(v5.n128_f32[3] * 0.5);
        v8 = vmulq_n_f32(v20, v7.__sinval);
        v8.i32[3] = LODWORD(v7.__cosval);
        *(double *)v9.i64 = simd_matrix4x4(v8);
        v19 = v9;
      }
    }
  }
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("scale"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v11 = ARVector3FromArray(v10);
    v12 = vmulq_f32((float32x4_t)v11, (float32x4_t)v11);
    if (sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v12, 2), vaddq_f32(v12, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v12.f32, 1))).f32[0]) > 0.00000011921)v19 = vmulq_n_f32(v19, v11.n128_f32[0]);

    v10 = 0;
  }
  objc_msgSend(v1, "objectForKeyedSubscript:", CFSTR("perspective"));
  v13 = (void *)objc_claimAutoreleasedReturnValue();
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0)
  {
    v14 = ARVector4FromArray(v13).n128_u32[0];
    v15 = v19;
    v15.i32[3] = v14;
    v21 = v15;
  }
  else
  {
    v16 = v19;
    v16.i32[3] = 0;
    v21 = v16;
  }

  return (__n128)v21;
}

void sub_1B3B817F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, __int128 a9, __int128 a10, __int128 a11, __int128 a12, __int16 buf)
{
  NSObject *v13;

  if (a2 == 1)
  {
    objc_begin_catch(a1);
    _ARLogGeneral_34();
    v13 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
    {
      buf = 0;
      _os_log_impl(&dword_1B3A68000, v13, OS_LOG_TYPE_ERROR, "Error reading matrix from dictionary", (uint8_t *)&buf, 2u);
    }

    objc_end_catch();
    JUMPOUT(0x1B3B817D0);
  }
  _Unwind_Resume(a1);
}

id _ARLogGeneral_34()
{
  if (_ARLogGeneral_onceToken_41 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_41, &__block_literal_global_37);
  return (id)_ARLogGeneral_logObj_41;
}

id ARMatrix4x4Dictionary(int a1, int a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, __n128 a6)
{
  void *v8;
  float32x4_t v9;
  int32x2_t v10;
  float32x4_t v11;
  int32x2_t v12;
  float32x4_t v13;
  int32x2_t v14;
  int32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float v20;
  float v21;
  unsigned int v22;
  float32x2_t v23;
  float32x2_t v24;
  float v25;
  float v26;
  float v27;
  float32x2_t v28;
  float32x2_t v29;
  float v30;
  float32x2_t v31;
  float32x2_t v32;
  float32x2_t v33;
  float32x2_t v34;
  float v35;
  float v40;
  float v41;
  float v42;
  unsigned int v43;
  float32x2_t v44;
  float32x2_t v45;
  float32x2_t v46;
  float32x4_t v47;
  float v48;
  float v49;
  void *v50;
  double v51;
  void *v52;
  void *v53;
  void *v54;
  float32x2_t v55;
  float32x2_t v56;
  float32x4_t v57;
  float32x4_t v58;
  float32x4_t v59;
  float32x4_t v60;
  int32x4_t v61;
  float32x2_t v62;
  float32x2_t v63;
  void *v64;
  double v65;
  void *v66;
  void *v67;
  double v68;
  void *v69;
  void *v70;
  float v71;
  BOOL v72;
  float v73;
  void *v75;
  void *v76;
  void *v77;
  void *v78;
  void *v79;
  double v80;
  void *v81;
  double v82;
  void *v83;
  double v84;
  void *v85;
  void *v86;
  float32x4_t v88;
  float32x4_t v89;
  float32x4_t v90;
  double v91;
  double v92;
  double v93;
  _QWORD v98[4];
  _QWORD v99[3];
  _QWORD v100[4];
  _QWORD v101[5];

  v101[3] = *MEMORY[0x1E0C80C00];
  v8 = (void *)objc_opt_new();
  v9 = vmulq_f32(a3, a3);
  *(float *)v10.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v9, 2), vaddq_f32(v9, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v9.f32, 1))).f32[0]);
  v11 = vmulq_f32(a4, a4);
  *(float *)v12.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v11, 2), vaddq_f32(v11, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v11.f32, 1))).f32[0]);
  v18 = a5;
  v13 = vmulq_f32(v18, v18);
  *(float *)v14.i32 = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v13, 2), vaddq_f32(v13, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v13.f32, 1))).f32[0]);
  v91 = *(double *)&v10;
  v92 = *(double *)&v12;
  v15 = (int32x4_t)vdivq_f32(a3, (float32x4_t)vdupq_lane_s32(v10, 0));
  v16 = vdivq_f32(a4, (float32x4_t)vdupq_lane_s32(v12, 0));
  v93 = *(double *)&v14;
  v17 = vdivq_f32(a5, (float32x4_t)vdupq_lane_s32(v14, 0));
  v18.f32[0] = v17.f32[2] + (float)(*(float *)v15.i32 + v16.f32[1]);
  if (v18.f32[0] >= 0.0)
  {
    v26 = sqrtf(v18.f32[0] + 1.0);
    v27 = v26 + v26;
    v28 = vrecpe_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26));
    v29 = vmul_f32(v28, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v28));
    LODWORD(v30) = vmul_f32(v29, vrecps_f32((float32x2_t)COERCE_UNSIGNED_INT(v26 + v26), v29)).u32[0];
    v18 = (float32x4_t)vzip2q_s32((int32x4_t)v16, vuzp1q_s32((int32x4_t)v16, (int32x4_t)v17));
    *(float32x2_t *)v18.f32 = vmul_n_f32(vsub_f32(*(float32x2_t *)v18.f32, (float32x2_t)*(_OWORD *)&vtrn2q_s32((int32x4_t)v17, vzip2q_s32((int32x4_t)v17, v15))), v30);
    v40 = vmuls_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1), v16).f32[0], v30);
    v41 = v27 * 0.25;
  }
  else if (*(float *)v15.i32 < v16.f32[1] || *(float *)v15.i32 < v17.f32[2])
  {
    v20 = 1.0 - *(float *)v15.i32;
    if (v16.f32[1] >= v17.f32[2])
    {
      v42 = sqrtf(v16.f32[1] + (float)(v20 - v17.f32[2]));
      *(float *)&v43 = v42 + v42;
      v44 = vrecpe_f32((float32x2_t)v43);
      v45 = vmul_f32(v44, vrecps_f32((float32x2_t)v43, v44));
      v46.i32[0] = vmul_f32(v45, vrecps_f32((float32x2_t)v43, v45)).u32[0];
      v18 = (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1);
      v18.i32[0] = vadd_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v16.f32).u32[0];
      v18.i32[1] = v43;
      v40 = vmuls_lane_f32(v46.f32[0], (float32x2_t)*(_OWORD *)&vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v17), 1);
      v41 = vmuls_n_f32(vsubq_f32(v17, (float32x4_t)vdupq_laneq_s32(v15, 2)).f32[0], v46.f32[0]);
      v46.i32[1] = 0.25;
      *(float32x2_t *)v18.f32 = vmul_f32(*(float32x2_t *)v18.f32, v46);
    }
    else
    {
      v21 = sqrtf(v17.f32[2] + (float)(v20 - v16.f32[1]));
      *(float *)&v22 = v21 + v21;
      v23 = vrecpe_f32((float32x2_t)v22);
      v24 = vmul_f32(v23, vrecps_f32((float32x2_t)v22, v23));
      LODWORD(v25) = vmul_f32(v24, vrecps_f32((float32x2_t)v22, v24)).u32[0];
      v18 = (float32x4_t)vzip2q_s32(v15, (int32x4_t)v16);
      *(float32x2_t *)v18.f32 = vmul_n_f32(vadd_f32(*(float32x2_t *)v18.f32, *(float32x2_t *)v17.f32), v25);
      v40 = *(float *)&v22 * 0.25;
      v41 = vmuls_n_f32(vsubq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)v15.i8, 1), v16).f32[0], v25);
    }
  }
  else
  {
    v31 = (float32x2_t)vdup_lane_s32(*(int32x2_t *)v16.f32, 0);
    v32 = vadd_f32(*(float32x2_t *)v15.i8, v31);
    v31.i32[0] = 2.0;
    v31.i32[0] = vmul_f32((float32x2_t)__PAIR64__(v15.u32[1], COERCE_UNSIGNED_INT(sqrtf(*(float *)v15.i32 + (float)((float)(1.0 - v16.f32[1])- v17.f32[2])))), v31).u32[0];
    v31.i32[1] = v32.i32[1];
    v33 = vrecpe_f32((float32x2_t)v31.u32[0]);
    v34 = vmul_f32(v33, vrecps_f32((float32x2_t)v31.u32[0], v33));
    LODWORD(v35) = vmul_f32(v34, vrecps_f32((float32x2_t)v31.u32[0], v34)).u32[0];
    __asm { FMOV            V5.2S, #0.25 }
    _D5.f32[1] = v35;
    *(float32x2_t *)v18.f32 = vmul_f32(v31, _D5);
    v40 = vmuls_n_f32(vaddq_f32((float32x4_t)vdupq_laneq_s32(v15, 2), v17).f32[0], v35);
    v41 = vmuls_lane_f32(v35, (float32x2_t)*(_OWORD *)&vsubq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v16, 2), v17), 1);
  }
  v18.f32[2] = v40;
  v47 = vmulq_f32(v18, v18);
  v88 = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v47, 2), vaddq_f32(v47, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v47.f32, 1)));
  v89 = v18;
  v48 = atan2f(sqrtf(v88.f32[0]), v41);
  v49 = v48 + v48;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", a6.n128_f64[0]);
  v50 = (void *)objc_claimAutoreleasedReturnValue();
  v101[0] = v50;
  HIDWORD(v51) = a6.n128_u32[1];
  LODWORD(v51) = a6.n128_u32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v51);
  v52 = (void *)objc_claimAutoreleasedReturnValue();
  v101[1] = v52;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(a6.n128_u32[1], a6.n128_u32[2])));
  v53 = (void *)objc_claimAutoreleasedReturnValue();
  v101[2] = v53;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v101, 3);
  v54 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "setObject:forKeyedSubscript:", v54, CFSTR("translation"));

  if (fabsf(v49) <= 0.00000011921)
  {
    objc_msgSend(v8, "setObject:forKeyedSubscript:", &unk_1E66CEDD8, CFSTR("rotation"));
    if (!a1)
      goto LABEL_25;
    goto LABEL_17;
  }
  v55 = vrsqrte_f32((float32x2_t)v88.u32[0]);
  v56 = vmul_f32(v55, vrsqrts_f32((float32x2_t)v88.u32[0], vmul_f32(v55, v55)));
  v57 = vmulq_n_f32(v89, vmul_f32(v56, vrsqrts_f32((float32x2_t)v88.u32[0], vmul_f32(v56, v56))).f32[0]);
  v58 = (float32x4_t)vdupq_laneq_s32((int32x4_t)v57, 2);
  v59 = vaddq_f32(v58, vaddq_f32(v57, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v57.f32, 1)));
  v58.i32[0] = 0;
  v60 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vcgtq_f32(v58, v59), 0), (int8x16_t)vnegq_f32(v57), (int8x16_t)v57);
  if (v59.f32[0] < 0.0)
    v49 = -v49;
  v61 = (int32x4_t)vmulq_f32(v60, v60);
  v61.i32[0] = vadd_f32((float32x2_t)*(_OWORD *)&vdupq_laneq_s32(v61, 2), vadd_f32(*(float32x2_t *)v61.i8, (float32x2_t)vdup_lane_s32(*(int32x2_t *)v61.i8, 1))).u32[0];
  v62 = vrsqrte_f32((float32x2_t)v61.u32[0]);
  v63 = vmul_f32(v62, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v62, v62)));
  v90 = vmulq_n_f32(v60, vmul_f32(v63, vrsqrts_f32((float32x2_t)v61.u32[0], vmul_f32(v63, v63))).f32[0]);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", *(_OWORD *)&v88);
  v64 = (void *)objc_claimAutoreleasedReturnValue();
  v100[0] = v64;
  HIDWORD(v65) = v90.i32[1];
  LODWORD(v65) = v90.i32[1];
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v65);
  v66 = (void *)objc_claimAutoreleasedReturnValue();
  v100[1] = v66;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", COERCE_DOUBLE(__PAIR64__(v90.u32[1], v90.u32[2])));
  v67 = (void *)objc_claimAutoreleasedReturnValue();
  v100[2] = v67;
  *(float *)&v68 = v49;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v68);
  v69 = (void *)objc_claimAutoreleasedReturnValue();
  v100[3] = v69;
  objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v100, 4);
  v70 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v8, "setObject:forKeyedSubscript:", v70, CFSTR("rotation"));

  if (a1)
  {
LABEL_17:
    v71 = fabsf(*(float *)&v92 + -1.0);
    v72 = fabsf(*(float *)&v91 + -1.0) <= 0.000011921 && v71 <= 0.000011921;
    v73 = fabsf(*(float *)&v93 + -1.0);
    if (!v72 || v73 > 0.000011921)
    {
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v91);
      v75 = (void *)objc_claimAutoreleasedReturnValue();
      v99[0] = v75;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v92);
      v76 = (void *)objc_claimAutoreleasedReturnValue();
      v99[1] = v76;
      objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v93);
      v77 = (void *)objc_claimAutoreleasedReturnValue();
      v99[2] = v77;
      objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v99, 3);
      v78 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v8, "setObject:forKeyedSubscript:", v78, CFSTR("scale"));

    }
  }
LABEL_25:
  if (a2
    && (fabsf(a3.f32[3]) > 0.00000011921
     || fabsf(a4.f32[3]) > 0.00000011921
     || fabsf(a5.f32[3]) > 0.00000011921
     || fabsf(a6.n128_f32[3] + -1.0) > 0.00000011921))
  {
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v88.i64[0]);
    v79 = (void *)objc_claimAutoreleasedReturnValue();
    v98[0] = v79;
    LODWORD(v80) = a4.i32[3];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v80);
    v81 = (void *)objc_claimAutoreleasedReturnValue();
    v98[1] = v81;
    LODWORD(v82) = a5.i32[3];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v82);
    v83 = (void *)objc_claimAutoreleasedReturnValue();
    v98[2] = v83;
    LODWORD(v84) = a6.n128_u32[3];
    objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithFloat:", v84);
    v85 = (void *)objc_claimAutoreleasedReturnValue();
    v98[3] = v85;
    objc_msgSend(MEMORY[0x1E0C99D20], "arrayWithObjects:count:", v98, 4);
    v86 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "setObject:forKeyedSubscript:", v86, CFSTR("perspective"));

  }
  return v8;
}

float32x2_t ARVector3ScalarMultiplication(float32x2_t a1, float a2)
{
  return vmul_n_f32(a1, a2);
}

double ARMatrix4x4DoubleToFloat(float64x2_t *a1)
{
  double result;

  *(_QWORD *)&result = vcvt_hight_f32_f64((int32x2_t)vcvt_f32_f64(*a1), a1[1]).u64[0];
  return result;
}

float64x2_t ARMatrix4x4FloatToDouble@<Q0>(float64x2_t *a1@<X8>, float32x4_t a2@<Q0>, float32x4_t a3@<Q1>, float32x4_t a4@<Q2>, float32x4_t a5@<Q3>)
{
  float64x2_t result;

  *a1 = vcvtq_f64_f32(*(float32x2_t *)a2.f32);
  a1[1] = vcvt_hight_f64_f32(a2);
  a1[2] = vcvtq_f64_f32(*(float32x2_t *)a3.f32);
  a1[3] = vcvt_hight_f64_f32(a3);
  a1[4] = vcvtq_f64_f32(*(float32x2_t *)a4.f32);
  a1[5] = vcvt_hight_f64_f32(a4);
  result = vcvt_hight_f64_f32(a5);
  a1[6] = vcvtq_f64_f32(*(float32x2_t *)a5.f32);
  a1[7] = result;
  return result;
}

void ARYawDifference(__n128 a1, __n128 a2, double a3, double a4, __n128 a5, __n128 a6)
{
  char v6;
  int v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float *v12;
  float *v13;
  float v14;
  float v15;
  __n128 v18;
  __n128 v19;
  __n128 v20;
  __n128 v21;
  __n128 v22;
  __n128 v23;
  __n128 v24;
  __n128 v25;

  v6 = 0;
  v7 = 0;
  v8 = 0.0;
  while (1)
  {
    v25 = a1;
    v9 = *(float *)((unint64_t)&v25 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)));
    v24 = a2;
    v10 = sqrtf((float)(*(float *)((unint64_t)&v24 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)))* *(float *)((unint64_t)&v24 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3))))+ (float)(v9 * v9));
    v23 = a5;
    v11 = *(float *)((unint64_t)&v23 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)));
    v22 = a6;
    if (vabds_f32(v10, sqrtf((float)(*(float *)((unint64_t)&v22 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3)))* *(float *)((unint64_t)&v22 & 0xFFFFFFFFFFFFFFF3 | (4 * (v7 & 3))))+ (float)(v11 * v11))) > 0.025)break;
    if (v10 > v8)
    {
      v8 = v10;
      v6 = v7;
    }
    if (++v7 == 3)
    {
      v21 = a2;
      v12 = (float *)((unint64_t)&v18 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      v13 = (float *)((unint64_t)&v19 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      v14 = *(float *)((unint64_t)&v21 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3)));
      v20 = a1;
      atan2f(v14, *(float *)((unint64_t)&v20 & 0xFFFFFFFFFFFFFFF3 | (4 * (v6 & 3))));
      v19 = a6;
      v15 = *v13;
      v18 = a5;
      atan2f(v15, *v12);
      return;
    }
  }
}

id ARMatrix4x4Description(int a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  float32x4_t v6;
  float32x4_t v7;
  void *v8;
  void *v9;

  *(double *)v6.i64 = AREulerAnglesFromMatrix(a2, a3, a4);
  v7 = vdivq_f32(vmulq_f32(v6, (float32x4_t)vdupq_n_s32(0x43340000u)), (float32x4_t)vdupq_n_s32(0x40490FDBu));
  objc_msgSend(MEMORY[0x1E0CB37A0], "stringWithFormat:", CFSTR("<translation=(%f %f %f) rotation=(%0.2f %0.2f %0.2f)"), a5.n128_f32[0], a5.n128_f32[1], a5.n128_f32[2], v7.f32[0], v7.f32[1], v7.f32[2]);
  v8 = (void *)objc_claimAutoreleasedReturnValue();
  v9 = v8;
  if (a1)
    objc_msgSend(v8, "appendFormat:", CFSTR(" matrix=\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n"), a2.n128_f32[0], a3.n128_f32[0], a4.n128_f32[0], a5.n128_f32[0], a2.n128_f32[1], a3.n128_f32[1], a4.n128_f32[1], a5.n128_f32[1], a2.n128_f32[2], a3.n128_f32[2], a4.n128_f32[2], a5.n128_f32[2], a2.n128_f32[3], a3.n128_f32[3], a4.n128_f32[3], a5.n128_f32[3]);
  objc_msgSend(v9, "appendString:", CFSTR(">"));
  return v9;
}

uint64_t ARMatrix3x3Description(__n128 a1, __n128 a2, __n128 a3)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<matrix=\n(%f, %f, %f)\n(%f, %f, %f)\n(%f, %f, %f)\n>"), a1.n128_f32[0], a2.n128_f32[0], a3.n128_f32[0], a1.n128_f32[1], a2.n128_f32[1], a3.n128_f32[1], a1.n128_f32[2], a2.n128_f32[2], a3.n128_f32[2]);
}

uint64_t ARMatrix4x3Description(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("<matrix=\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n(%f, %f, %f, %f)\n>"), a1.n128_f32[0], a2.n128_f32[0], a3.n128_f32[0], a4.n128_f32[0], a1.n128_f32[1], a2.n128_f32[1], a3.n128_f32[1], a4.n128_f32[1], a1.n128_f32[2], a2.n128_f32[2], a3.n128_f32[2], a4.n128_f32[2]);
}

uint64_t ARVector3Description(__n128 a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("(%f %f %f)"), a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2]);
}

uint64_t ARVector4Description(__n128 a1)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("(%f %f %f %f)"), a1.n128_f32[0], a1.n128_f32[1], a1.n128_f32[2], a1.n128_f32[3]);
}

uint64_t ARVector3MatlabDescription(uint64_t a1, __n128 a2)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ = [%f,%f,%f]\n"), a1, a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2]);
}

uint64_t ARVector4MatlabDescription(uint64_t a1, __n128 a2)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ = [%f,%f,%f,%f]\n"), a1, a2.n128_f32[0], a2.n128_f32[1], a2.n128_f32[2], a2.n128_f32[3]);
}

uint64_t ARMatrix3x3MatlabDescription(uint64_t a1, __n128 a2, __n128 a3, __n128 a4)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ = [%f,%f,%f;\n%f,%f,%f;\n%f,%f,%f]\n"),
           a1,
           a2.n128_f32[0],
           a3.n128_f32[0],
           a4.n128_f32[0],
           a2.n128_f32[1],
           a3.n128_f32[1],
           a4.n128_f32[1],
           a2.n128_f32[2],
           a3.n128_f32[2],
           a4.n128_f32[2]);
}

uint64_t ARMatrix4x4MatlabDescription(uint64_t a1, __n128 a2, __n128 a3, __n128 a4, __n128 a5)
{
  return objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ = [%f,%f,%f,%f;\n%f,%f,%f,%f;\n%f,%f,%f,%f;\n%f,%f,%f,%f]\n"),
           a1,
           a2.n128_f32[0],
           a3.n128_f32[0],
           a4.n128_f32[0],
           a5.n128_f32[0],
           a2.n128_f32[1],
           a3.n128_f32[1],
           a4.n128_f32[1],
           a5.n128_f32[1],
           a2.n128_f32[2],
           a3.n128_f32[2],
           a4.n128_f32[2],
           a5.n128_f32[2],
           a2.n128_f32[3],
           a3.n128_f32[3],
           a4.n128_f32[3],
           a5.n128_f32[3]);
}

void ARCGRectRotate(uint64_t a1, CGFloat a2, CGFloat a3, CGFloat a4, CGFloat a5)
{
  __int128 v9;
  __int128 v10;
  __int128 v11;
  CGAffineTransform v12;
  CGAffineTransform v13;
  CGAffineTransform v14;
  CGAffineTransform v15;
  CGRect v16;
  CGRect v17;
  CGRect v18;

  memset(&v15, 0, sizeof(v15));
  v11 = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 16);
  *(_OWORD *)&v14.a = *MEMORY[0x1E0C9BAA8];
  v10 = *(_OWORD *)&v14.a;
  *(_OWORD *)&v14.c = v11;
  *(_OWORD *)&v14.tx = *(_OWORD *)(MEMORY[0x1E0C9BAA8] + 32);
  v9 = *(_OWORD *)&v14.tx;
  CGAffineTransformRotate(&v15, &v14, (float)a1 * 3.14159265 / 180.0);
  *(_OWORD *)&v13.a = v10;
  *(_OWORD *)&v13.c = v11;
  *(_OWORD *)&v13.tx = v9;
  memset(&v14, 0, sizeof(v14));
  CGAffineTransformTranslate(&v14, &v13, -0.5, -0.5);
  v12 = v14;
  memset(&v13, 0, sizeof(v13));
  CGAffineTransformInvert(&v13, &v12);
  v12 = v14;
  v16.origin.x = a2;
  v16.origin.y = a3;
  v16.size.width = a4;
  v16.size.height = a5;
  v17 = CGRectApplyAffineTransform(v16, &v12);
  v12 = v15;
  v18 = CGRectApplyAffineTransform(v17, &v12);
  v12 = v13;
  CGRectApplyAffineTransform(v18, &v12);
}

double ARWorldTransformFromVisionTransform(simd_float4x4 a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  simd_float4 v5;
  uint64_t v6;
  simd_float4x4 v7;
  uint64_t v8;
  uint64_t v9;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  simd_float4x4 v19;
  simd_float4x4 v20;
  simd_float4x4 v21;

  v7 = __invert_f4(a1);
  v5 = v7.columns[3];
  v6 = 0;
  v19.columns[0] = v7.columns[0];
  v7.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v19.columns[1] = v7.columns[1];
  v19.columns[2] = v7.columns[2];
  v19.columns[3] = v5;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v6] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDE0, COERCE_FLOAT(*(_OWORD *)&v19.columns[v6])), (float32x4_t)xmmword_1B3BE00D0, *(float32x2_t *)v19.columns[v6].f32, 1), (float32x4_t)xmmword_1B3BDFDD0, (float32x4_t)v19.columns[v6], 2), (float32x4_t)v7.columns[3], (float32x4_t)v19.columns[v6], 3);
    ++v6;
  }
  while (v6 != 4);
  v13 = (float32x4_t)v20.columns[1];
  v14 = (float32x4_t)v20.columns[0];
  v11 = (float32x4_t)v20.columns[3];
  v12 = (float32x4_t)v20.columns[2];
  v7.columns[0] = (simd_float4)_PromotedConst_40;
  v7.columns[1] = (simd_float4)unk_1B3C0B5B0;
  v7.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v21 = __invert_f4(v7);
  v8 = 0;
  v19 = v21;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v8] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v14, COERCE_FLOAT(*(_OWORD *)&v19.columns[v8])), v13, *(float32x2_t *)v19.columns[v8].f32, 1), v12, (float32x4_t)v19.columns[v8], 2), v11, (float32x4_t)v19.columns[v8], 3);
    ++v8;
  }
  while (v8 != 4);
  v9 = 0;
  v19 = v20;
  memset(&v20, 0, sizeof(v20));
  do
  {
    v20.columns[v9] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2, COERCE_FLOAT(*(_OWORD *)&v19.columns[v9])), a3, *(float32x2_t *)v19.columns[v9].f32, 1), a4, (float32x4_t)v19.columns[v9], 2), a5, (float32x4_t)v19.columns[v9], 3);
    ++v9;
  }
  while (v9 != 4);
  return *(double *)v20.columns[0].i64;
}

double ARTransformFromVisionTransform(simd_float4x4 a1)
{
  simd_float4 v1;
  uint64_t v2;
  uint64_t v3;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  simd_float4x4 v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  simd_float4x4 v14;

  v1 = a1.columns[3];
  v2 = 0;
  v9.columns[0] = a1.columns[0];
  a1.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v9.columns[1] = a1.columns[1];
  v9.columns[2] = a1.columns[2];
  v9.columns[3] = v1;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v2 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)xmmword_1B3BDFDE0, COERCE_FLOAT(*(_OWORD *)&v9.columns[v2])), (float32x4_t)xmmword_1B3BE00D0, *(float32x2_t *)v9.columns[v2].f32, 1), (float32x4_t)xmmword_1B3BDFDD0, (float32x4_t)v9.columns[v2], 2), (float32x4_t)a1.columns[3], (float32x4_t)v9.columns[v2], 3);
    ++v2;
  }
  while (v2 != 4);
  v7 = v11;
  v8 = v10;
  v5 = v13;
  v6 = v12;
  a1.columns[0] = (simd_float4)_PromotedConst_40;
  a1.columns[1] = (simd_float4)unk_1B3C0B5B0;
  a1.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v14 = __invert_f4(a1);
  v3 = 0;
  v9 = v14;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v3 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v8, COERCE_FLOAT(*(_OWORD *)&v9.columns[v3])), v7, *(float32x2_t *)v9.columns[v3].f32, 1), v6, (float32x4_t)v9.columns[v3], 2), v5, (float32x4_t)v9.columns[v3], 3);
    ++v3;
  }
  while (v3 != 4);
  return *(double *)v10.i64;
}

double ARVisionTransformFromARTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4)
{
  uint64_t v4;
  uint64_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float32x4_t v8;
  float32x4_t v9;
  simd_float4 v15;
  __int128 v16;
  __int128 v17;
  __int128 v18;
  __n128 v19;
  float32x4_t v20;
  float32x4_t v21;
  float32x4_t v22;
  float32x4_t v23;
  simd_float4x4 v24;
  simd_float4x4 v25;

  v24.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v24.columns[0] = (simd_float4)_PromotedConst_40;
  v24.columns[1] = (simd_float4)unk_1B3C0B5B0;
  v24.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v15 = v24.columns[3];
  v25 = __invert_f4(v24);
  v4 = 0;
  v16 = (__int128)a1;
  v17 = (__int128)a2;
  v18 = (__int128)a3;
  v19 = a4;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v20 + v4) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v25.columns[0], COERCE_FLOAT(*(__int128 *)((char *)&v16 + v4))), (float32x4_t)v25.columns[1], *(float32x2_t *)((char *)&v16 + v4), 1), (float32x4_t)v25.columns[2], *(float32x4_t *)((char *)&v16 + v4), 2), (float32x4_t)v25.columns[3], *(float32x4_t *)((char *)&v16 + v4), 3);
    v4 += 16;
  }
  while (v4 != 64);
  v5 = 0;
  v6 = v20;
  v7 = v21;
  v8 = v22;
  v9 = v23;
  v16 = xmmword_1B3BDFDE0;
  v17 = xmmword_1B3BE00D0;
  v18 = xmmword_1B3BDFDD0;
  v19 = (__n128)v15;
  v20 = 0u;
  v21 = 0u;
  v22 = 0u;
  v23 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v20 + v5) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v6, COERCE_FLOAT(*(__int128 *)((char *)&v16 + v5))), v7, *(float32x2_t *)((char *)&v16 + v5), 1), v8, *(float32x4_t *)((char *)&v16 + v5), 2), v9, *(float32x4_t *)((char *)&v16 + v5), 3);
    v5 += 16;
  }
  while (v5 != 64);
  return *(double *)v20.i64;
}

double ARVisionTransformFromWorldTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  float32x4_t v14;
  double result;
  simd_float4 v16;
  simd_float4 v18;
  simd_float4 v20;
  simd_float4 v22;
  simd_float4 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __n128 v28;
  simd_float4x4 v29;
  simd_float4x4 v30;
  simd_float4x4 v31;
  simd_float4x4 v32;
  simd_float4x4 v33;

  v30.columns[0] = a5;
  v30.columns[1] = a6;
  v30.columns[2] = a7;
  v30.columns[3] = a8;
  v31 = __invert_f4(v30);
  v8 = 0;
  v25 = (__int128)a1;
  v26 = (__int128)a2;
  v27 = (__int128)a3;
  v28 = a4;
  memset(&v29, 0, sizeof(v29));
  do
  {
    v29.columns[v8 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v31.columns[0], COERCE_FLOAT(*(__int128 *)((char *)&v25 + v8))), (float32x4_t)v31.columns[1], *(float32x2_t *)((char *)&v25 + v8), 1), (float32x4_t)v31.columns[2], *(float32x4_t *)((char *)&v25 + v8), 2), (float32x4_t)v31.columns[3], *(float32x4_t *)((char *)&v25 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  v20 = v29.columns[1];
  v22 = v29.columns[0];
  v16 = v29.columns[3];
  v18 = v29.columns[2];
  v32.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v32.columns[0] = (simd_float4)_PromotedConst_40;
  v32.columns[1] = (simd_float4)unk_1B3C0B5B0;
  v32.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v24 = v32.columns[3];
  v33 = __invert_f4(v32);
  v9 = 0;
  v25 = (__int128)v22;
  v26 = (__int128)v20;
  v27 = (__int128)v18;
  v28 = (__n128)v16;
  memset(&v29, 0, sizeof(v29));
  do
  {
    v29.columns[v9 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v33.columns[0], COERCE_FLOAT(*(__int128 *)((char *)&v25 + v9))), (float32x4_t)v33.columns[1], *(float32x2_t *)((char *)&v25 + v9), 1), (float32x4_t)v33.columns[2], *(float32x4_t *)((char *)&v25 + v9), 2), (float32x4_t)v33.columns[3], *(float32x4_t *)((char *)&v25 + v9), 3);
    v9 += 16;
  }
  while (v9 != 64);
  v10 = 0;
  v11 = (float32x4_t)v29.columns[0];
  v12 = (float32x4_t)v29.columns[1];
  v13 = (float32x4_t)v29.columns[2];
  v14 = (float32x4_t)v29.columns[3];
  v25 = xmmword_1B3BDFDE0;
  v26 = xmmword_1B3BE00D0;
  v27 = xmmword_1B3BDFDD0;
  v28 = (__n128)v24;
  memset(&v29, 0, sizeof(v29));
  do
  {
    v29.columns[v10 / 0x10] = (simd_float4)vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v11, COERCE_FLOAT(*(__int128 *)((char *)&v25 + v10))), v12, *(float32x2_t *)((char *)&v25 + v10), 1), v13, *(float32x4_t *)((char *)&v25 + v10), 2), v14, *(float32x4_t *)((char *)&v25 + v10), 3);
    v10 += 16;
  }
  while (v10 != 64);
  *(_QWORD *)&result = (unint64_t)__invert_f4(v29);
  return result;
}

double ARVisionCameraTransformFromWorldTransform(__n128 a1, __n128 a2, __n128 a3, __n128 a4, simd_float4 a5, simd_float4 a6, simd_float4 a7, simd_float4 a8)
{
  unint64_t v8;
  unint64_t v9;
  __n128 v10;
  unint64_t v11;
  __n128 v12;
  __n128 v13;
  __n128 v14;
  __n128 v17;
  float32x4_t v18;
  __n128 v20;
  float32x4_t v21;
  __n128 v23;
  float32x4_t v24;
  __n128 v26;
  float32x4_t v27;
  __n128 v28;
  __n128 v29;
  __n128 v30;
  __n128 v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  simd_float4x4 v36;
  simd_float4x4 v37;
  simd_float4x4 v38;
  simd_float4x4 v39;

  v36.columns[0] = a5;
  v36.columns[1] = a6;
  v36.columns[2] = a7;
  v36.columns[3] = a8;
  v37 = __invert_f4(v36);
  v8 = 0;
  v28 = a1;
  v29 = a2;
  v30 = a3;
  v31 = a4;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v8) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v37.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v8))), (float32x4_t)v37.columns[1], (float32x2_t)v28.n128_u64[v8 / 8], 1), (float32x4_t)v37.columns[2], *(float32x4_t *)((char *)&v28 + v8), 2), (float32x4_t)v37.columns[3], *(float32x4_t *)((char *)&v28 + v8), 3);
    v8 += 16;
  }
  while (v8 != 64);
  v23 = (__n128)v33;
  v26 = (__n128)v32;
  v17 = (__n128)v35;
  v20 = (__n128)v34;
  v38.columns[0] = (simd_float4)_PromotedConst_40;
  v38.columns[1] = (simd_float4)unk_1B3C0B5B0;
  v38.columns[2] = (simd_float4)xmmword_1B3C0B5C0;
  v38.columns[3] = *(simd_float4 *)(MEMORY[0x1E0C83FF0] + 48);
  v39 = __invert_f4(v38);
  v9 = 0;
  v28 = v26;
  v29 = v23;
  v30 = v20;
  v31 = v17;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v9) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32((float32x4_t)v39.columns[0], COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v9))), (float32x4_t)v39.columns[1], (float32x2_t)v28.n128_u64[v9 / 8], 1), (float32x4_t)v39.columns[2], *(float32x4_t *)((char *)&v28 + v9), 2), (float32x4_t)v39.columns[3], *(float32x4_t *)((char *)&v28 + v9), 3);
    v9 += 16;
  }
  while (v9 != 64);
  v24 = v33;
  v27 = v32;
  v18 = v35;
  v21 = v34;
  v10.n128_f64[0] = simd_matrix4x4((float32x4_t)_PromotedConst_41);
  v11 = 0;
  v28 = v10;
  v29 = v12;
  v30 = v13;
  v31 = v14;
  v32 = 0u;
  v33 = 0u;
  v34 = 0u;
  v35 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v32 + v11) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v27, COERCE_FLOAT(*(_OWORD *)((char *)&v28 + v11))), v24, (float32x2_t)v28.n128_u64[v11 / 8], 1), v21, *(float32x4_t *)((char *)&v28 + v11), 2), v18, *(float32x4_t *)((char *)&v28 + v11), 3);
    v11 += 16;
  }
  while (v11 != 64);
  return *(double *)v32.i64;
}

double ARWorldVectorFromVisionVector(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  uint64_t v5;
  __int128 v6;
  float32x4_t v7;
  double result;
  _OWORD v9[4];
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;

  v5 = 0;
  v6 = *(_OWORD *)(MEMORY[0x1E0C83FF0] + 48);
  v9[2] = xmmword_1B3BDFDD0;
  v9[3] = v6;
  v10 = 0u;
  v11 = 0u;
  v12 = 0u;
  v13 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v10 + v5 * 16) = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a2, COERCE_FLOAT(v9[v5])), a3, *(float32x2_t *)&v9[v5], 1), a4, (float32x4_t)v9[v5], 2), a5, (float32x4_t)v9[v5], 3);
    ++v5;
  }
  while (v5 != 4);
  v7 = vaddq_f32(v13, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, a1.f32[0]), v11, *(float32x2_t *)a1.f32, 1), v12, a1, 2));
  *(_QWORD *)&result = vdivq_f32(v7, (float32x4_t)vdupq_laneq_s32((int32x4_t)v7, 3)).u64[0];
  return result;
}

double ARVisionVectorFromARVector(int32x4_t a1)
{
  double result;

  *(_QWORD *)&result = vnegq_f32((float32x4_t)vzip2q_s32(a1, vuzp1q_s32(a1, a1))).u64[0];
  return result;
}

float ARCameraDirectionFromCMAttitude(void *a1)
{
  id v1;
  void *v2;
  double v3;
  double v4;
  float v5;
  float v6;
  double v8;
  double v9;

  v1 = a1;
  v2 = v1;
  if (v1)
  {
    objc_msgSend(v1, "rotationMatrix");
    v3 = v9;
    objc_msgSend(v2, "rotationMatrix");
    v4 = v8;
  }
  else
  {
    v4 = 0.0;
    v3 = 0.0;
  }
  if (v4 * v4 + v3 * v3 >= 0.01)
  {
    v6 = atan2(v3, v4) * 0.318309886 * 180.0 + 90.0;
    if (v6 < 0.0)
      v6 = v6 + 360.0;
    if (v6 >= 360.0)
      v5 = v6 + -360.0;
    else
      v5 = v6;
  }
  else
  {
    v5 = NAN;
  }

  return v5;
}

double ARMatrix4x4FromRowMajorFlatBuffer(double *a1)
{
  unsigned int v1;
  unsigned int v2;
  double result;

  *(float *)&v1 = *a1;
  *(float *)&v2 = a1[4];
  result = COERCE_DOUBLE(__PAIR64__(v2, v1));
  __asm { FMOV            V3.4S, #1.0 }
  return result;
}

double ARMatrix4x4CopyToRowMajorFlatBuffer(uint64_t a1, int8x16_t a2, int8x16_t a3, int8x16_t a4, __n128 a5)
{
  float32x2_t v5;
  double result;

  v5 = (float32x2_t)vext_s8((int8x8_t)a5.n128_u64[0], (int8x8_t)*(_OWORD *)&vextq_s8(a2, a2, 8uLL), 4uLL);
  a5.n128_u32[1] = a2.u32[1];
  *(double *)a1 = *(float *)a2.i32;
  *(double *)(a1 + 8) = *(float *)a3.i32;
  *(double *)(a1 + 16) = *(float *)a4.i32;
  *(float64x2_t *)(a1 + 24) = vcvtq_f64_f32((float32x2_t)a5.n128_u64[0]);
  *(float64x2_t *)(a1 + 40) = vcvtq_f64_f32((float32x2_t)vzip2_s32(*(int32x2_t *)a3.i8, *(int32x2_t *)a4.i8));
  *(float64x2_t *)(a1 + 56) = vcvtq_f64_f32(v5);
  result = a5.n128_f32[2];
  *(float64x2_t *)(a1 + 72) = vcvtq_f64_f32((float32x2_t)vzip1_s32((int32x2_t)*(_OWORD *)&vextq_s8(a3, a3, 8uLL), (int32x2_t)*(_OWORD *)&vextq_s8(a4, a4, 8uLL)));
  *(double *)(a1 + 88) = a5.n128_f32[2];
  return result;
}

uint64_t ARMatrix4x4ContainsNANValues()
{
  uint64_t i;
  uint64_t j;

  for (i = 0; i != 4; ++i)
  {
    for (j = 0; j != 64; j += 16)
      ;
  }
  return 0;
}

BOOL ARMatrix4x4ContainsScale(int32x4_t a1, int32x4_t a2, int32x4_t a3, __n128 a4)
{
  uint64_t v5;
  int32x4_t v6;
  int32x4_t v7;
  int32x4_t v8;
  int32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  float32x4_t v12;
  float32x4_t v13;
  uint32x4_t v14;
  _OWORD v15[3];
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;

  if (fabsf(a4.n128_f32[3] + -1.0) > 0.0000011921)
    return 1;
  v5 = 0;
  v6 = a1;
  v6.i32[3] = 0;
  v7 = a2;
  v7.i32[3] = 0;
  v8 = a3;
  v8.i32[3] = 0;
  v9 = vdupq_lane_s32(*(int32x2_t *)a2.i8, 1);
  v10 = (float32x4_t)vzip1q_s32(a1, a2);
  v10.i32[2] = a3.i32[0];
  v11 = (float32x4_t)vzip2q_s32(a1, a2);
  v11.i32[2] = a3.i32[2];
  v12 = (float32x4_t)vzip2q_s32(vzip1q_s32(a1, a3), v9);
  v15[0] = v6;
  v15[1] = v7;
  v15[2] = v8;
  v16 = 0u;
  v17 = 0u;
  v18 = 0u;
  do
  {
    *(float32x4_t *)((char *)&v16 + v5 * 16) = vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(v10, COERCE_FLOAT(v15[v5])), v12, *(float32x2_t *)&v15[v5], 1), v11, (float32x4_t)v15[v5], 2);
    ++v5;
  }
  while (v5 != 3);
  v13 = (float32x4_t)vdupq_n_s32(0x35A00000u);
  v14 = (uint32x4_t)vandq_s8(vandq_s8((int8x16_t)vcgeq_f32(v13, vabdq_f32(v17, *(float32x4_t *)(MEMORY[0x1E0C83FE8] + 16))), (int8x16_t)vcgeq_f32(v13, vabdq_f32(v16, *MEMORY[0x1E0C83FE8]))), (int8x16_t)vcgeq_f32(v13, vabdq_f32(v18, *(float32x4_t *)(MEMORY[0x1E0C83FE8] + 32))));
  v14.i32[3] = v14.i32[2];
  return (vminvq_u32(v14) & 0x80000000) == 0;
}

void ARInterpolateBetweenTransforms(simd_float3x3 a1, double a2, simd_float3 a3, simd_float3 a4, simd_float3 a5, double a6, float a7)
{
  float32x4_t v14;
  float32x4_t v15;
  float32x4_t v16;
  float32x4_t v17;
  float32x4_t v18;
  float v19;
  float v20;
  float32x4_t v21;
  int8x16_t v22;
  float32x4_t v23;
  int8x16_t v24;
  float v25;
  float v26;
  BOOL v27;
  float v28;
  float v29;
  float32x2_t v30;
  float32x2_t v31;
  float v32;
  float32x4_t v33;
  float v34;
  float v35;
  float v36;
  float v37;
  float32x4_t v38;
  int8x16_t v39;
  float32x2_t v40;
  float32x4_t v41;
  unsigned __int32 v42;
  float32x2_t v43;
  float32x2_t v44;
  simd_float3x3 v45;
  float32x4_t v46;
  float v47;
  float v48;
  float32x4_t v49;
  float32x4_t v50;

  v45.columns[1] = a4;
  v45.columns[2] = a5;
  v45.columns[0] = a3;
  *(double *)v14.i64 = simd_quaternion(a1);
  v50 = v14;
  *(double *)v15.i64 = simd_quaternion(v45);
  v16 = vmulq_f32(v50, v15);
  v17 = (float32x4_t)vextq_s8((int8x16_t)v16, (int8x16_t)v16, 8uLL);
  *(float32x2_t *)v16.f32 = vadd_f32(*(float32x2_t *)v16.f32, *(float32x2_t *)v17.f32);
  v16.f32[0] = vaddv_f32(*(float32x2_t *)v16.f32);
  v17.i32[0] = 0;
  v18 = (float32x4_t)vbslq_s8((int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(v16, v17)), 0), (int8x16_t)vnegq_f32(v15), (int8x16_t)v15);
  v19 = 1.0;
  v20 = 1.0 - a7;
  v21 = vsubq_f32(v50, v18);
  v22 = (int8x16_t)vmulq_f32(v21, v21);
  v49 = v18;
  v23 = vaddq_f32(v50, v18);
  v24 = (int8x16_t)vmulq_f32(v23, v23);
  v25 = atan2f(sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v22.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v22, v22, 8uLL)))), sqrtf(vaddv_f32(vadd_f32(*(float32x2_t *)v24.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v24, v24, 8uLL)))));
  v26 = v25 + v25;
  v27 = (float)(v25 + v25) == 0.0;
  v28 = 1.0;
  if (!v27)
    v28 = sinf(v26) / v26;
  v29 = v28;
  v30 = vrecpe_f32((float32x2_t)LODWORD(v28));
  v31 = vmul_f32(v30, vrecps_f32((float32x2_t)LODWORD(v29), v30));
  LODWORD(v32) = vmul_f32(v31, vrecps_f32((float32x2_t)LODWORD(v29), v31)).u32[0];
  if ((float)(v20 * v26) != 0.0)
  {
    v47 = v32;
    v31.f32[0] = sinf(v20 * v26);
    v32 = v47;
    v19 = v31.f32[0] / (float)(v20 * v26);
  }
  v31.f32[0] = v20 * (float)(v32 * v19);
  v33 = (float32x4_t)vdupq_lane_s32((int32x2_t)v31, 0);
  v34 = a7;
  v35 = v26 * a7;
  v36 = 1.0;
  if (v35 != 0.0)
  {
    v46 = v33;
    v48 = v32;
    v37 = sinf(v35);
    v33 = v46;
    v32 = v48;
    v34 = a7;
    v36 = v37 / v35;
  }
  v38 = vmlaq_f32(vmulq_n_f32(v49, (float)(v32 * v36) * v34), v50, v33);
  v39 = (int8x16_t)vmulq_f32(v38, v38);
  v40 = vadd_f32(*(float32x2_t *)v39.i8, (float32x2_t)*(_OWORD *)&vextq_s8(v39, v39, 8uLL));
  if (vaddv_f32(v40) == 0.0)
  {
    v41 = (float32x4_t)xmmword_1B3BDFD50;
  }
  else
  {
    v42 = vadd_f32(v40, (float32x2_t)vdup_lane_s32((int32x2_t)v40, 1)).u32[0];
    v43 = vrsqrte_f32((float32x2_t)v42);
    v44 = vmul_f32(v43, vrsqrts_f32((float32x2_t)v42, vmul_f32(v43, v43)));
    v41 = vmulq_n_f32(v38, vmul_f32(v44, vrsqrts_f32((float32x2_t)v42, vmul_f32(v44, v44))).f32[0]);
  }
  simd_matrix4x4(v41);
}

uint64_t ARMinMax(_DWORD *a1, unsigned int a2, _DWORD *a3)
{
  BOOL v4;
  uint64_t result;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  float v9;
  uint64_t v10;
  uint64_t v11;

  if (a1)
    v4 = (int)a2 <= 0;
  else
    v4 = 1;
  result = !v4;
  if ((_DWORD)result == 1)
  {
    LODWORD(v6) = *a1;
    *a3 = *a1;
    HIDWORD(v6) = *a1;
    *(_QWORD *)a3 = v6;
    if (a2 >= 2)
    {
      v7 = (float *)(a1 + 1);
      v8 = a2 - 1;
      while (1)
      {
        v9 = *v7;
        if (*v7 > *((float *)&v6 + 1))
          break;
        if (v9 < *(float *)&v6)
        {
          v10 = 0;
          goto LABEL_14;
        }
LABEL_15:
        ++v7;
        if (!--v8)
          return result;
      }
      v10 = 1;
LABEL_14:
      v11 = v6;
      *(float *)((unint64_t)&v11 | (4 * v10)) = v9;
      v6 = v11;
      *(_QWORD *)a3 = v11;
      goto LABEL_15;
    }
  }
  return result;
}

uint64_t ARInterpolateSorted(float *a1, uint64_t a2, int a3, float *a4, float a5)
{
  uint64_t v5;
  uint64_t v6;
  float v7;
  uint64_t v9;
  int v10;
  char v11;
  float v12;
  int v13;
  uint64_t v14;

  v5 = 0;
  if (a1)
  {
    if (a2)
    {
      v6 = (a3 - 1);
      if (a3 >= 1)
      {
        v7 = *a1;
        if (*a1 > a5 || a1[v6] < a5)
          return 0;
        if (a3 >= 2)
        {
          v9 = 0;
          v10 = 0;
          v11 = 0;
          while (1)
          {
            v12 = v7;
            v7 = a1[v9 + 1];
            if (v12 > v7)
              return 0;
            if ((v11 & 1) != 0)
              v13 = v10;
            else
              v13 = v9;
            v14 = v9 + 1;
            v11 |= v7 >= a5;
            if (v7 >= a5)
              v10 = v13;
            ++v9;
            if (v6 == v14)
            {
              v7 = a1[v10];
              goto LABEL_19;
            }
          }
        }
        v10 = 0;
LABEL_19:
        *a4 = *(float *)(a2 + 4 * v10)
            + (float)((float)((float)(a5 - v7) * (float)(*(float *)(a2 + 4 * v10 + 4) - *(float *)(a2 + 4 * v10)))
                    / (float)(a1[v10 + 1] - v7));
        return 1;
      }
    }
  }
  return v5;
}

uint64_t kVTRotationFromARRotationAngle(uint64_t a1)
{
  uint64_t result;
  uint64_t v3;

  result = 0;
  if (a1 > 89)
  {
    if (a1 == 90)
    {
      v3 = MEMORY[0x1E0CEDA40];
    }
    else
    {
      if (a1 != 180)
        return result;
      v3 = MEMORY[0x1E0CEDA30];
    }
  }
  else if (a1 == -90)
  {
    v3 = MEMORY[0x1E0CEDA38];
  }
  else
  {
    if (a1)
      return result;
    v3 = MEMORY[0x1E0CEDA28];
  }
  return *(_QWORD *)v3;
}

void sub_1B3B837A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B837F8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B83C58(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1B3B846EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

uint64_t `anonymous namespace'::FillRegistrationDataFrom(uint64_t result, uint64_t a2, uint64_t a3, float *a4, uint64_t a5, uint64_t a6, uint64_t a7, double a8)
{
  uint64_t i;
  _DWORD *v9;
  unint64_t v10;
  _DWORD *v11;
  int v12;
  unint64_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  __int128 *v20;
  uint64_t j;
  __int128 v22;
  __int128 v23;
  _QWORD *exception;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  __int128 v28;

  if (a3 != 16 || a5 != 17 || *a4 != 0.0 || a4[1] != 0.0 || a4[2] != 0.0)
  {
    exception = __cxa_allocate_exception(8uLL);
    *exception = "Please sync with arkit team if this happen!";
    __cxa_throw(exception, MEMORY[0x1E0DE4E50], 0);
  }
  for (i = 0; i != 128; i += 8)
  {
    v9 = (_DWORD *)(result + i);
    *v9 = *(_QWORD *)(a2 + i);
    v9[1] = *(_DWORD *)(a2 + i + 4);
  }
  v10 = 0;
  v11 = (_DWORD *)(result + 136);
  do
  {
    if (v10 < 7)
      v12 = v10;
    else
      v12 = v10 + 1;
    v13 = v10 + 1;
    v14 = &a4[4 * v12];
    *(v11 - 2) = *(_DWORD *)v14;
    *(v11 - 1) = *((_DWORD *)v14 + 1);
    *v11 = *((_DWORD *)v14 + 2);
    v11 += 3;
    v10 = v13;
  }
  while (v13 != 16);
  v15 = 0;
  v16 = result + 320;
  do
  {
    v17 = 0;
    v18 = a6;
    do
    {
      *(_DWORD *)(v16 + v17) = *(_DWORD *)(v18 + 4 * (v15 & 3));
      v18 += 16;
      v17 += 12;
    }
    while (v17 != 36);
    ++v15;
    v16 += 4;
  }
  while (v15 != 3);
  v19 = 0;
  v25 = xmmword_1B3C0B710;
  v26 = unk_1B3C0B720;
  v27 = xmmword_1B3C0B730;
  v28 = unk_1B3C0B740;
  v20 = &v25;
  do
  {
    for (j = 0; j != 4; ++j)
      LODWORD(v20[j]) = *(_DWORD *)(a7 + j * 16 + 4 * (v19 & 3));
    ++v19;
    v20 = (__int128 *)((char *)v20 + 4);
  }
  while (v19 != 3);
  v22 = v26;
  *(_OWORD *)(result + 356) = v25;
  *(_OWORD *)(result + 372) = v22;
  v23 = v28;
  *(_OWORD *)(result + 388) = v27;
  *(_OWORD *)(result + 404) = v23;
  *(double *)(result + 488) = a8;
  return result;
}

void sub_1B3B84B6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3B84CFC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  v6 = v3;

  _Unwind_Resume(a1);
}

void sub_1B3B84DE0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B850E0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E2D57C](v1);
  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_23()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke_12()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

_QWORD *_ZNSt3__115allocate_sharedB8ne180100IN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEJEvEENS_10shared_ptrIT_EERKT0_DpOT1_@<X0>(_QWORD *a1@<X8>)
{
  _QWORD *v2;
  _QWORD *result;

  v2 = operator new(0x60uLL);
  result = _ZNSt3__120__shared_ptr_emplaceIN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(v2);
  *a1 = v2 + 3;
  a1[1] = v2;
  return result;
}

void sub_1B3B851A4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *_ZNSt3__120__shared_ptr_emplaceIN5arkit3btr15ScaleCorrectionENS_9allocatorIS3_EEEC2B8ne180100IJES5_Li0EEES5_DpOT_(_QWORD *a1)
{
  __int128 v3;
  uint64_t v4;
  __int128 v5;
  uint64_t v6;
  char v7;

  a1[2] = 0;
  *a1 = &unk_1E66705E0;
  a1[1] = 0;
  *(_QWORD *)&v3 = 10;
  *((_QWORD *)&v3 + 1) = 0x3CA3D70A3A83126FLL;
  v4 = 5;
  v5 = xmmword_1B3C0B700;
  v6 = 0x3FF9999A3D4CCCCDLL;
  v7 = 1;
  arkit::btr::ScaleCorrection::ScaleCorrection((uint64_t)(a1 + 3), &v3);
  return a1;
}

void sub_1B3B85238(_Unwind_Exception *a1)
{
  std::__shared_weak_count *v1;

  std::__shared_weak_count::~__shared_weak_count(v1);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::~__shared_ptr_emplace(std::__shared_weak_count *this)
{
  this->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66705E0;
  std::__shared_weak_count::~__shared_weak_count(this);
}

void std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::~__shared_ptr_emplace(std::__shared_weak_count *a1)
{
  a1->__vftable = (std::__shared_weak_count_vtbl *)&unk_1E66705E0;
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

uint64_t std::__shared_ptr_emplace<arkit::btr::ScaleCorrection>::__on_zero_shared(uint64_t a1)
{
  return std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100](a1 + 80);
}

float32x2_t dehomogenize3d(int32x4_t a1)
{
  return vdiv_f32(*(float32x2_t *)a1.i8, (float32x2_t)vdup_laneq_s32(a1, 2));
}

double dehomogenize4d(float32x4_t a1)
{
  double result;

  *(_QWORD *)&result = vdivq_f32(a1, (float32x4_t)vdupq_laneq_s32((int32x4_t)a1, 3)).u64[0];
  return result;
}

uint64_t ARIsBoxInViewFrustum(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5, double a6, double a7, double a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, float32x4_t a17, float32x4_t a18, float32x4_t a19, float32x4_t a20,float32x4_t a21,float32x4_t a22,float32x4_t a23,float a24,float a25)
{
  float32x2_t v22;
  int8x8_t v23;
  int v25;
  int v26;
  float32x4_t v27;
  int v28;
  float32x4_t v29;
  float32x4_t v30;
  float32x4_t v31;
  float32x4_t v32;
  float32x4_t v33;
  float32x4_t v34;
  float32x4_t v35;
  int32x4_t v36;
  float32x2_t v37;
  float32x4_t v40;
  float32x4_t v41;
  float32x4_t v46;

  if (fabsf(a5.f32[0]) != INFINITY
    || (v22.i32[1] = a5.i32[1],
        v22.i32[0] = vextq_s8((int8x16_t)a5, (int8x16_t)a5, 8uLL).u32[0],
        v23 = vmvn_s8((int8x8_t)vceq_f32(vabs_f32(v22), (float32x2_t)vdup_n_s32(0x7F800000u))),
        (v23.i8[4] & 1) != 0)
    || (v23.i8[0] & 1) != 0)
  {
    v41 = vnegq_f32(a5);
    v40 = vaddq_f32(a5, a5);
    v25 = 100;
    while (1)
    {
      v26 = rand();
      *(float32x2_t *)v27.f32 = vcvt_f32_s32((int32x2_t)__PAIR64__(rand(), v26));
      v46 = v27;
      v28 = rand();
      v29 = v46;
      v29.f32[2] = (float)v28;
      v30.i64[0] = 0x3000000030000000;
      v30.i64[1] = 0x3000000030000000;
      v31 = vmlaq_f32(v41, v40, vmulq_f32(v29, v30));
      v30.i64[0] = 0x3F0000003F000000;
      v30.i64[1] = 0x3F0000003F000000;
      v32 = vmulq_f32(v31, v30);
      v33 = vaddq_f32(a4, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v32.f32[0]), a2, *(float32x2_t *)v32.f32, 1), a3, v32, 2));
      v34 = vmlaq_laneq_f32(vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a17, v33.f32[0]), a18, *(float32x2_t *)v33.f32, 1), a19, v33, 2), a20, v33, 3);
      v35 = vdivq_f32(v34, (float32x4_t)vdupq_laneq_s32((int32x4_t)v34, 3));
      if (v35.f32[2] < 0.0)
      {
        v36 = (int32x4_t)vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a21, v35.f32[0]), a22, *(float32x2_t *)v35.f32, 1), a23, v35, 2);
        v37 = vdiv_f32(*(float32x2_t *)v36.i8, (float32x2_t)vdup_laneq_s32(v36, 2));
        if (v37.f32[0] >= 0.0 && v37.f32[0] < a24 && v37.f32[1] >= 0.0 && v37.f32[1] < a25)
          break;
      }
      if (!--v25)
        return 0;
    }
  }
  return 1;
}

double ARRandomBoxPointInWorldCoordinates(float32x4_t a1, float32x4_t a2, float32x4_t a3, float32x4_t a4, float32x4_t a5)
{
  int v5;
  float32x4_t v6;
  int v7;
  float32x4_t v8;
  float32x4_t v9;
  float32x4_t v10;
  float32x4_t v11;
  double result;
  float32x4_t v13;

  v5 = rand();
  *(float32x2_t *)v6.f32 = vcvt_f32_s32((int32x2_t)__PAIR64__(rand(), v5));
  v13 = v6;
  v7 = rand();
  v8 = v13;
  v8.f32[2] = (float)v7;
  v9.i64[0] = 0x3000000030000000;
  v9.i64[1] = 0x3000000030000000;
  v10 = vmlaq_f32(vnegq_f32(a5), vaddq_f32(a5, a5), vmulq_f32(v8, v9));
  v9.i64[0] = 0x3F0000003F000000;
  v9.i64[1] = 0x3F0000003F000000;
  v11 = vmulq_f32(v10, v9);
  *(_QWORD *)&result = vaddq_f32(a4, vmlaq_laneq_f32(vmlaq_lane_f32(vmulq_n_f32(a1, v11.f32[0]), a2, *(float32x2_t *)v11.f32, 1), a3, v11, 2)).u64[0];
  return result;
}

void ARLogErrorNoClassLongMessage(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  unint64_t v9;
  uint64_t i;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  id obj;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint8_t buf[4];
  __CFString *v29;
  __int16 v30;
  void *v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (ARLogErrorNoClassLongMessage_onceToken != -1)
    dispatch_once(&ARLogErrorNoClassLongMessage_onceToken, &__block_literal_global_100);
  v20 = v3;
  objc_msgSend(v3, "componentsSeparatedByCharactersInSet:", ARLogErrorNoClassLongMessage_newLineCharacterSet);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = v4;
  if (v4)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ "), v4, v4);
    v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v6 = &stru_1E6676798;
  }
  v7 = -[__CFString length](v6, "length");
  if ((unint64_t)objc_msgSend(v5, "count") >= 2)
  {
    _ARLogGeneral_35();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v6;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "%{public}@START", buf, 0xCu);
    }

  }
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  obj = v5;
  v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
  if (v23)
  {
    v9 = 1000 - v7;
    v22 = *(_QWORD *)v25;
    do
    {
      for (i = 0; i != v23; ++i)
      {
        if (*(_QWORD *)v25 != v22)
          objc_enumerationMutation(obj);
        v11 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * i);
        if (v9 >= objc_msgSend(v11, "length"))
        {
          v12 = 0;
        }
        else
        {
          v12 = 0;
          LODWORD(v13) = v9;
          do
          {
            _ARLogGeneral_35();
            v14 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
            {
              objc_msgSend(v11, "substringWithRange:", v12, v9);
              v15 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              v29 = v6;
              v30 = 2114;
              v31 = v15;
              _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_ERROR, "%{public}@%{public}@", buf, 0x16u);

            }
            v12 = (int)v13;
            v13 = v9 + (int)v13;
          }
          while (v13 < objc_msgSend(v11, "length"));
        }
        _ARLogGeneral_35();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          objc_msgSend(v11, "substringFromIndex:", v12);
          v17 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543618;
          v29 = v6;
          v30 = 2114;
          v31 = v17;
          _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_ERROR, "%{public}@%{public}@", buf, 0x16u);

        }
      }
      v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
    }
    while (v23);
  }

  if ((unint64_t)objc_msgSend(obj, "count") >= 2)
  {
    _ARLogGeneral_35();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v6;
      _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_ERROR, "%{public}@END", buf, 0xCu);
    }

  }
}

id _ARLogGeneral_35()
{
  if (_ARLogGeneral_onceToken_42 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_42, &__block_literal_global_6_1);
  return (id)_ARLogGeneral_logObj_42;
}

void ARLogDebugNoClassLongMessage(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  __CFString *v6;
  uint64_t v7;
  NSObject *v8;
  unint64_t v9;
  uint64_t i;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  NSObject *v14;
  void *v15;
  NSObject *v16;
  void *v17;
  NSObject *v18;
  void *v19;
  void *v20;
  id obj;
  uint64_t v22;
  uint64_t v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  uint8_t buf[4];
  __CFString *v29;
  __int16 v30;
  void *v31;
  _BYTE v32[128];
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  v3 = a1;
  v4 = a2;
  if (ARLogDebugNoClassLongMessage_onceToken != -1)
    dispatch_once(&ARLogDebugNoClassLongMessage_onceToken, &__block_literal_global_5);
  v20 = v3;
  objc_msgSend(v3, "componentsSeparatedByCharactersInSet:", ARLogDebugNoClassLongMessage_newLineCharacterSet);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  v19 = v4;
  if (v4)
  {
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@ "), v4, v4);
    v6 = (__CFString *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v6 = &stru_1E6676798;
  }
  v7 = -[__CFString length](v6, "length");
  if ((unint64_t)objc_msgSend(v5, "count") >= 2)
  {
    _ARLogGeneral_35();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v6;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_DEBUG, "%{public}@START", buf, 0xCu);
    }

  }
  v26 = 0u;
  v27 = 0u;
  v24 = 0u;
  v25 = 0u;
  obj = v5;
  v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
  if (v23)
  {
    v9 = 1000 - v7;
    v22 = *(_QWORD *)v25;
    do
    {
      for (i = 0; i != v23; ++i)
      {
        if (*(_QWORD *)v25 != v22)
          objc_enumerationMutation(obj);
        v11 = *(void **)(*((_QWORD *)&v24 + 1) + 8 * i);
        if (v9 >= objc_msgSend(v11, "length"))
        {
          v12 = 0;
        }
        else
        {
          v12 = 0;
          LODWORD(v13) = v9;
          do
          {
            _ARLogGeneral_35();
            v14 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              objc_msgSend(v11, "substringWithRange:", v12, v9);
              v15 = (void *)objc_claimAutoreleasedReturnValue();
              *(_DWORD *)buf = 138543618;
              v29 = v6;
              v30 = 2114;
              v31 = v15;
              _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_DEBUG, "%{public}@%{public}@", buf, 0x16u);

            }
            v12 = (int)v13;
            v13 = v9 + (int)v13;
          }
          while (v13 < objc_msgSend(v11, "length"));
        }
        _ARLogGeneral_35();
        v16 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
        {
          objc_msgSend(v11, "substringFromIndex:", v12);
          v17 = (void *)objc_claimAutoreleasedReturnValue();
          *(_DWORD *)buf = 138543618;
          v29 = v6;
          v30 = 2114;
          v31 = v17;
          _os_log_impl(&dword_1B3A68000, v16, OS_LOG_TYPE_DEBUG, "%{public}@%{public}@", buf, 0x16u);

        }
      }
      v23 = objc_msgSend(obj, "countByEnumeratingWithState:objects:count:", &v24, v32, 16);
    }
    while (v23);
  }

  if ((unint64_t)objc_msgSend(obj, "count") >= 2)
  {
    _ARLogGeneral_35();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      v29 = v6;
      _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_DEBUG, "%{public}@END", buf, 0xCu);
    }

  }
}

id ARSphericalHarmonicsDataWithCoefficients(uint64_t a1, float32x4_t a2, float32x4_t a3)
{
  int8x16_t v3;
  float32x4_t v4;
  float32x4_t v5;
  float32x4_t v6;
  uint64_t v7;
  float v8;
  float *v9;
  _OWORD v11[7];
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  if (a2.f32[0] <= 0.0)
  {
    v6 = (float32x4_t)xmmword_1B3BDFDC0;
  }
  else
  {
    a3.i32[0] = 1170939904;
    v3 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a3, a2)), 0);
    v4 = vaddq_f32((float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B3C0B7C0, (int8x16_t)xmmword_1B3C0B7B0), vdivq_f32((float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B3C0B7E0, (int8x16_t)xmmword_1B3C0B7D0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v3, (int8x16_t)xmmword_1B3C0B800, (int8x16_t)xmmword_1B3C0B7F0))));
    v4.i32[3] = 0;
    v5 = vmaxnmq_f32(v4, (float32x4_t)0);
    v5.i32[3] = 0;
    v6 = vminnmq_f32(v5, (float32x4_t)xmmword_1B3C0B810);
  }
  v7 = 0;
  memset(v11, 0, 108);
  do
  {
    v8 = *(float *)(a1 + v7);
    v9 = (float *)((char *)v11 + v7);
    *v9 = v6.f32[0] * v8;
    v9[9] = v6.f32[1] * v8;
    v9[18] = v6.f32[2] * v8;
    v7 += 4;
  }
  while (v7 != 36);
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", v11, 108);
  return (id)objc_claimAutoreleasedReturnValue();
}

double ARCCT2RGB(float32x4_t a1, float32x4_t a2)
{
  int8x16_t v2;
  float32x4_t v3;
  float32x4_t v4;
  double result;

  if (a1.f32[0] <= 0.0)
  {
    *(_QWORD *)&result = 1065353216;
  }
  else
  {
    a2.i32[0] = 1170939904;
    v2 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a2, a1)), 0);
    v3 = vaddq_f32((float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B3C0B7C0, (int8x16_t)xmmword_1B3C0B7B0), vdivq_f32((float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B3C0B7E0, (int8x16_t)xmmword_1B3C0B7D0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a1.f32, 0), (float32x4_t)vbslq_s8(v2, (int8x16_t)xmmword_1B3C0B800, (int8x16_t)xmmword_1B3C0B7F0))));
    v3.i32[3] = 0;
    v4 = vmaxnmq_f32(v3, (float32x4_t)0);
    v4.i32[3] = 0;
    *(_QWORD *)&result = vminnmq_f32(v4, (float32x4_t)xmmword_1B3C0B810).u64[0];
  }
  return result;
}

float32_t ARPrimaryLightFromSphericalHarmonics@<S0>(uint64_t a1@<X0>, float32x4_t *a2@<X8>, float a3@<S0>, float32x4_t a4@<Q1>)
{
  float32x4_t v4;
  float32x4_t v5;
  float v6;
  float32_t result;
  uint64_t v8;
  float v9;
  float32x2_t v10;
  float32x2_t v11;
  float32x4_t v13;
  float v20;
  double v21;
  float v22;
  float v23;
  float32_t v24;
  int v25;
  float32x4_t v26;
  float v27;
  float v28;
  float v29;
  float v30;

  a4.i32[0] = *(_DWORD *)(a1 + 12);
  a4.i32[1] = *(_DWORD *)(a1 + 4);
  v4 = vnegq_f32(a4);
  v4.i32[2] = *(_DWORD *)(a1 + 8);
  v5 = vmulq_f32(v4, v4);
  LODWORD(v6) = vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v5, 2), vaddq_f32(v5, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v5.f32, 1))).u32[0];
  if (sqrtf(v6) >= 0.00001)
  {
    v8 = 0;
    v9 = v6;
    v10 = vrsqrte_f32((float32x2_t)LODWORD(v6));
    v11 = vmul_f32(v10, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v10, v10)));
    _Q1 = vmulq_n_f32(v4, vmul_f32(v11, vrsqrts_f32((float32x2_t)LODWORD(v9), vmul_f32(v11, v11))).f32[0]);
    v25 = 1049652922;
    v13 = (float32x4_t)vextq_s8((int8x16_t)_Q1, (int8x16_t)_Q1, 4uLL);
    v13.i32[2] = _Q1.i32[0];
    *a2 = _Q1;
    _Q6.i64[0] = 0x3EFA2A1BBEFA2A1BLL;
    _Q6.i32[2] = -1090901477;
    _Q6.i32[3] = vmuls_lane_f32(1.0925, *(float32x2_t *)_Q1.f32, 1);
    v26 = vmulq_f32(v13, _Q6);
    _S5 = vmuls_lane_f32(3.0, _Q1, 2);
    __asm { FMLA            S6, S5, V1.S[2] }
    v27 = vmuls_lane_f32(vmuls_lane_f32(-1.0925, *(float32x2_t *)_Q1.f32, 1), _Q1, 2);
    v28 = _Q6.f32[0] * 0.31539;
    v29 = vmuls_lane_f32(-1.0925 * _Q1.f32[0], _Q1, 2);
    v30 = vmlas_n_f32(vmuls_lane_f32(-_Q1.f32[1], *(float32x2_t *)_Q1.f32, 1), _Q1.f32[0], _Q1.f32[0]) * 0.54627;
    v20 = 0.0;
    do
    {
      v20 = v20 + (float)(*(float *)(a1 + v8) * *(float *)((char *)&v25 + v8));
      v8 += 4;
    }
    while (v8 != 36);
    v21 = (float)(v20 * 867.0) / 992.743279;
    if (v21 < 0.0)
      v21 = 0.0;
    v22 = v21;
    v23 = (float)((float)(*(float *)a1 + (float)((float)((float)(v22 * -8.0) * 1.7725) / 17.0)) * 1.7725) * 0.5;
    if (v23 < 0.0)
      v23 = 0.0;
    v24 = v23 * a3;
    result = v22 * a3;
    a2[1].f32[0] = result;
    a2[1].f32[1] = v24;
  }
  else
  {
    *a2 = (float32x4_t)xmmword_1B3BDFF70;
    result = *(float *)a1 * a3;
    a2[1].f32[1] = result;
    a2[1].i32[0] = 0;
  }
  return result;
}

float ARSphericalHarmonicsWithDirection@<S0>(uint64_t a1@<X8>, int8x16_t _Q0@<Q0>)
{
  float32x4_t v2;
  float v9;
  float result;

  *(_DWORD *)a1 = 1049652922;
  v2 = (float32x4_t)vextq_s8(_Q0, _Q0, 4uLL);
  v2.i32[2] = _Q0.i32[0];
  _Q5.i64[0] = 0x3EFA2A1BBEFA2A1BLL;
  _Q5.i32[2] = -1090901477;
  _Q5.i32[3] = vmuls_lane_f32(1.0925, *(float32x2_t *)_Q0.i8, 1);
  *(float32x4_t *)(a1 + 4) = vmulq_f32(v2, _Q5);
  _S4 = vmuls_lane_f32(3.0, (float32x4_t)_Q0, 2);
  __asm { FMLA            S5, S4, V0.S[2] }
  *(float *)(a1 + 20) = vmuls_lane_f32(vmuls_lane_f32(-1.0925, *(float32x2_t *)_Q0.i8, 1), (float32x4_t)_Q0, 2);
  *(float *)(a1 + 24) = _Q5.f32[0] * 0.31539;
  v9 = vmuls_lane_f32(-1.0925 * *(float *)_Q0.i32, (float32x4_t)_Q0, 2);
  result = vmlas_n_f32(vmuls_lane_f32(-*(float *)&_Q0.i32[1], *(float32x2_t *)_Q0.i8, 1), *(float *)_Q0.i32, *(float *)_Q0.i32)* 0.54627;
  *(float *)(a1 + 28) = v9;
  *(float *)(a1 + 32) = result;
  return result;
}

float ARSphericalHarmonicsDotProduct(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  float result;

  v2 = 0;
  result = 0.0;
  do
  {
    result = result + (float)(*(float *)(a1 + v2) * *(float *)(a2 + v2));
    v2 += 4;
  }
  while (v2 != 36);
  return result;
}

double ARSphericalHarmonicsByFlippingZAxis@<D0>(__int128 *a1@<X0>, uint64_t a2@<X8>)
{
  __int128 v3;
  double result;
  __int128 v5;
  _OWORD v6[2];
  int v7;
  __int128 v8;
  __int128 v9;
  int v10;

  v10 = 0;
  v8 = 0u;
  v9 = 0u;
  if (&v8 != a1)
  {
    v3 = a1[1];
    v8 = *a1;
    v9 = v3;
    v10 = *((_DWORD *)a1 + 8);
  }
  arkit::shct::flipAxesShCoeff((uint64_t)&v8, 0, 0, 1, (uint64_t)v6);
  result = *(double *)v6;
  v5 = v6[1];
  *(_OWORD *)a2 = v6[0];
  *(_OWORD *)(a2 + 16) = v5;
  *(_DWORD *)(a2 + 32) = v7;
  return result;
}

double ARSphericalHarmonicsByApplyingRotation@<D0>(__int128 *a1@<X0>, uint64_t a2@<X8>, simd_float3x3 a3@<0:Q0, 16:Q1, 32:Q2>)
{
  __int128 v4;
  double result;
  __int128 v6;
  _OWORD v7[2];
  int v8;
  float v9[9];
  __int128 v10;
  __int128 v11;
  int v12;

  v12 = 0;
  v10 = 0u;
  v11 = 0u;
  if (&v10 != a1)
  {
    v4 = a1[1];
    v10 = *a1;
    v11 = v4;
    v12 = *((_DWORD *)a1 + 8);
  }
  ARCVAMatrixFromMatrix(a3, (uint64_t)v9);
  arkit::shct::rotateShCoeff((uint64_t)&v10, v9, (uint64_t)v7);
  result = *(double *)v7;
  v6 = v7[1];
  *(_OWORD *)a2 = v7[0];
  *(_OWORD *)(a2 + 16) = v6;
  *(_DWORD *)(a2 + 32) = v8;
  return result;
}

id ARSphericalHarmonicsDataWithAmbientLight(float a1, float32x4_t a2, double a3, float32x4_t a4)
{
  int8x16_t v4;
  float32x4_t v5;
  float32x4_t v6;
  float32x4_t v7;
  float v9;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  uint64_t v17;

  v17 = *MEMORY[0x1E0C80C00];
  v16 = 0;
  v14 = 0u;
  v15 = 0u;
  v12 = 0u;
  v13 = 0u;
  v10 = 0u;
  v11 = 0u;
  if (a2.f32[0] <= 0.0)
  {
    v7 = (float32x4_t)xmmword_1B3BDFDC0;
  }
  else
  {
    a4.i32[0] = 1170939904;
    v4 = (int8x16_t)vdupq_lane_s32((int32x2_t)*(_OWORD *)&vmvnq_s8((int8x16_t)vcgeq_f32(a4, a2)), 0);
    v5 = vaddq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B3C0B7C0, (int8x16_t)xmmword_1B3C0B7B0), vdivq_f32((float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B3C0B7E0, (int8x16_t)xmmword_1B3C0B7D0), vaddq_f32((float32x4_t)vdupq_lane_s32(*(int32x2_t *)a2.f32, 0), (float32x4_t)vbslq_s8(v4, (int8x16_t)xmmword_1B3C0B800, (int8x16_t)xmmword_1B3C0B7F0))));
    v5.i32[3] = 0;
    v6 = vmaxnmq_f32(v5, (float32x4_t)0);
    v6.i32[3] = 0;
    v7 = vminnmq_f32(v6, (float32x4_t)xmmword_1B3C0B810);
  }
  v9 = a1 * v7.f32[0];
  LODWORD(v12) = vmuls_lane_f32(a1, *(float32x2_t *)v7.f32, 1);
  DWORD1(v14) = vmuls_lane_f32(a1, v7, 2);
  objc_msgSend(MEMORY[0x1E0C99D50], "dataWithBytes:length:", &v9, 108);
  return (id)objc_claimAutoreleasedReturnValue();
}

id _ARLogSensor_9()
{
  if (_ARLogSensor_onceToken_14 != -1)
    dispatch_once(&_ARLogSensor_onceToken_14, &__block_literal_global_482);
  return (id)_ARLogSensor_logObj_14;
}

void sub_1B3B8AC70(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12, __int128 buf, int a14, __int16 a15, __int16 a16, id a17, __int128 a18)
{
  void *v18;
  void *v19;
  id v20;
  id v21;
  NSObject *v22;
  objc_class *v23;
  id v24;
  void *v25;
  void *v26;
  void *v27;

  if (a2 == 1)
  {
    v21 = objc_begin_catch(a1);
    _ARLogSensor_9();
    v22 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      v23 = (objc_class *)objc_opt_class();
      NSStringFromClass(v23);
      v20 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v18, "logPrefix");
      v24 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v21, "reason");
      v25 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138544130;
      *(_QWORD *)((char *)&buf + 4) = v20;
      WORD6(buf) = 2048;
      *(_QWORD *)((char *)&buf + 14) = v18;
      a16 = 2112;
      a17 = v24;
      LOWORD(a18) = 2112;
      *(_QWORD *)((char *)&a18 + 2) = v25;
      _os_log_impl(&dword_1B3A68000, v22, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set capture device active format: %@", (uint8_t *)&buf, 0x2Au);

    }
    objc_msgSend(v21, "reason");
    v26 = (void *)objc_claimAutoreleasedReturnValue();
    if (v26)
    {
      a11 = *MEMORY[0x1E0CB2D68];
      objc_msgSend(v21, "reason");
      v20 = (id)objc_claimAutoreleasedReturnValue();
      a12 = v20;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &a12, &a11, 1);
      v27 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v27 = (void *)MEMORY[0x1E0C9AA70];
    }
    ARErrorWithCodeAndUserInfo(102, v27);
    objc_claimAutoreleasedReturnValue();

    if (v26)
    {

    }
    objc_end_catch();
    JUMPOUT(0x1B3B8AC1CLL);
  }
  _Unwind_Resume(a1);
}

void sub_1B3B8B174(_Unwind_Exception *exception_object, int a2)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  id v5;
  NSObject *v6;
  objc_class *v7;
  id v8;
  id v9;
  void *v10;
  uint64_t v11;

  if (a2 == 1)
  {
    v5 = objc_begin_catch(exception_object);
    _ARLogSensor_9();
    v6 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      v7 = (objc_class *)objc_opt_class();
      NSStringFromClass(v7);
      v8 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v2, "logPrefix");
      v9 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "reason");
      v10 = (void *)objc_claimAutoreleasedReturnValue();
      *(_DWORD *)(v3 - 144) = 138544386;
      v11 = v3 - 144;
      *(_QWORD *)(v11 + 4) = v8;
      *(_WORD *)(v3 - 132) = 2048;
      *(_QWORD *)(v11 + 14) = v2;
      *(_WORD *)(v3 - 122) = 2112;
      *(_QWORD *)(v3 - 120) = v9;
      *(_WORD *)(v3 - 112) = 2048;
      *(_QWORD *)(v11 + 34) = v4;
      *(_WORD *)(v3 - 102) = 2112;
      *(_QWORD *)(v11 + 44) = v10;
      _os_log_impl(&dword_1B3A68000, v6, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set image sensor depth rate to %f: %@", (uint8_t *)(v3 - 144), 0x34u);

    }
    objc_end_catch();
    JUMPOUT(0x1B3B8B134);
  }
  _Unwind_Resume(exception_object);
}

void sub_1B3B8BB14(_Unwind_Exception *a1)
{
  objc_end_catch();
  _Unwind_Resume(a1);
}

void sub_1B3B8C02C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, __int128 location, int a16, __int16 a17, __int16 a18, id a19, __n128 a20,__n128 a21,uint64_t a22,__int128 a23)
{
  void *v23;
  void *v24;
  id *v25;
  float v26;
  float v27;
  float v28;
  id v31;
  NSObject *v32;
  objc_class *v33;
  id v34;
  id v35;
  float v36;
  float v37;
  void *v38;

  objc_destroyWeak(v25);
  objc_destroyWeak((id *)&location);
  if (a2 == 1)
  {
    v31 = objc_begin_catch(a1);
    _ARLogSensor_9();
    v32 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
    {
      v33 = (objc_class *)objc_opt_class();
      NSStringFromClass(v33);
      v34 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "logPrefix");
      v35 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v23, "maxWhiteBalanceGain");
      v37 = v36;
      objc_msgSend(v31, "reason");
      v38 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(location) = 138545154;
      *(_QWORD *)((char *)&location + 4) = v34;
      WORD6(location) = 2048;
      *(_QWORD *)((char *)&location + 14) = v24;
      a18 = 2112;
      a19 = v35;
      a20.n128_u16[0] = 2048;
      *(double *)((char *)a20.n128_f64 + 2) = v26;
      a20.n128_u16[5] = 2048;
      *(double *)((char *)&a20.n128_f64[1] + 4) = v27;
      a21.n128_u16[2] = 2048;
      *(double *)((char *)a21.n128_f64 + 6) = v28;
      a21.n128_u16[7] = 2048;
      *(double *)&a22 = v37;
      LOWORD(a23) = 2112;
      *(_QWORD *)((char *)&a23 + 2) = v38;
      _os_log_impl(&dword_1B3A68000, v32, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set custom white balance gains %.2f, %.2f, %.2f, valid range is [1.0-%.1f] : %@", (uint8_t *)&location, 0x52u);

    }
    objc_end_catch();
    JUMPOUT(0x1B3B8BF2CLL);
  }
  _Unwind_Resume(a1);
}

void sub_1B3B8C840(_Unwind_Exception *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location, id a18, __int128 buf, int a20,__int16 a21,__int16 a22,id a23,__int128 a24)
{
  void *v24;
  id *v25;
  id *v26;
  id v29;
  NSObject *v30;
  objc_class *v31;
  id v32;
  id v33;
  void *v34;

  objc_destroyWeak(v26);
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  objc_destroyWeak(&a18);
  if (a2 == 1)
  {
    v29 = objc_begin_catch(a1);
    _ARLogSensor_9();
    v30 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      v31 = (objc_class *)objc_opt_class();
      NSStringFromClass(v31);
      v32 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v24, "logPrefix");
      v33 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v29, "reason");
      v34 = (void *)objc_claimAutoreleasedReturnValue();
      LODWORD(buf) = 138544130;
      *(_QWORD *)((char *)&buf + 4) = v32;
      WORD6(buf) = 2048;
      *(_QWORD *)((char *)&buf + 14) = v24;
      a22 = 2112;
      a23 = v33;
      LOWORD(a24) = 2112;
      *(_QWORD *)((char *)&a24 + 2) = v34;
      _os_log_impl(&dword_1B3A68000, v30, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to set fixed lens position: %@", (uint8_t *)&buf, 0x2Au);

    }
    objc_end_catch();
    JUMPOUT(0x1B3B8C720);
  }
  _Unwind_Resume(a1);
}

void sub_1B3B8DE20(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,int buf,int a30,int a31,__int16 a32,int a33,__int16 a34,__int16 a35,uint64_t a36,__int16 a37)
{
  void *v37;
  id v38;
  uint64_t v39;
  id v40;
  NSObject *v41;
  objc_class *v42;
  id v43;
  void *v44;
  void *v45;
  void *v46;

  if (a2 == 1)
  {
    v40 = objc_begin_catch(exception_object);
    _ARLogSensor_9();
    v41 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      v42 = (objc_class *)objc_opt_class();
      NSStringFromClass(v42);
      v38 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v37, "logPrefix");
      v43 = (id)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v40, "reason");
      v44 = (void *)objc_claimAutoreleasedReturnValue();
      buf = 138544130;
      *(_QWORD *)(v39 + 4) = v38;
      a32 = 2048;
      *(_QWORD *)(v39 + 14) = v37;
      a35 = 2112;
      a36 = (uint64_t)v43;
      a37 = 2112;
      *(_QWORD *)(v39 + 34) = v44;
      _os_log_impl(&dword_1B3A68000, v41, OS_LOG_TYPE_ERROR, "%{public}@ <%p>: %@ Unable to setup vision data parameters: %@", (uint8_t *)&buf, 0x2Au);

    }
    objc_msgSend(v40, "reason");
    v45 = (void *)objc_claimAutoreleasedReturnValue();
    if (v45)
    {
      a27 = *MEMORY[0x1E0CB2D68];
      objc_msgSend(v40, "reason");
      v38 = (id)objc_claimAutoreleasedReturnValue();
      a28 = (uint64_t)v38;
      objc_msgSend(MEMORY[0x1E0C99D80], "dictionaryWithObjects:forKeys:count:", &a28, &a27, 1);
      v46 = (void *)objc_claimAutoreleasedReturnValue();
    }
    else
    {
      v46 = (void *)MEMORY[0x1E0C9AA70];
    }
    ARErrorWithCodeAndUserInfo(102, v46);
    objc_claimAutoreleasedReturnValue();
    if (v45)
    {

    }
    objc_end_catch();
    JUMPOUT(0x1B3B8D4C0);
  }
  _Unwind_Resume(exception_object);
}

const __CFString *NSStringFromMagneticFieldCalibrationAccuracy(int a1)
{
  if ((a1 + 1) > 3)
    return &stru_1E6676798;
  else
    return off_1E6675868[a1 + 1];
}

id NSStringFromAttitudeReferenceFrame(char a1)
{
  void *v2;
  void *v3;
  void *v4;

  objc_msgSend(MEMORY[0x1E0C99DE8], "array");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  v3 = v2;
  if ((a1 & 1) != 0)
  {
    objc_msgSend(v2, "addObject:", CFSTR("XArbitraryZVertical"));
    if ((a1 & 2) == 0)
    {
LABEL_3:
      if ((a1 & 4) == 0)
        goto LABEL_4;
LABEL_9:
      objc_msgSend(v3, "addObject:", CFSTR("XMagneticNorthZVertical"));
      if ((a1 & 8) == 0)
        goto LABEL_6;
      goto LABEL_5;
    }
  }
  else if ((a1 & 2) == 0)
  {
    goto LABEL_3;
  }
  objc_msgSend(v3, "addObject:", CFSTR("XArbitraryCorrectedZVertical"));
  if ((a1 & 4) != 0)
    goto LABEL_9;
LABEL_4:
  if ((a1 & 8) != 0)
LABEL_5:
    objc_msgSend(v3, "addObject:", CFSTR("XTrueNorthZVertical"));
LABEL_6:
  objc_msgSend(v3, "componentsJoinedByString:", CFSTR(" | "));
  v4 = (void *)objc_claimAutoreleasedReturnValue();

  return v4;
}

id _ARLogSensor_10()
{
  if (_ARLogSensor_onceToken_15 != -1)
    dispatch_once(&_ARLogSensor_onceToken_15, &__block_literal_global_102);
  return (id)_ARLogSensor_logObj_15;
}

void sub_1B3B90618(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
  id *v15;

  objc_destroyWeak(v15);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B90758(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

id _ARLogSensor_11()
{
  if (_ARLogSensor_onceToken_16 != -1)
    dispatch_once(&_ARLogSensor_onceToken_16, &__block_literal_global_438);
  return (id)_ARLogSensor_logObj_16;
}

id _ARLogGeneral_36()
{
  if (_ARLogGeneral_onceToken_43 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_43, &__block_literal_global_441);
  return (id)_ARLogGeneral_logObj_43;
}

void sub_1B3B99120(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;
  void *v12;

  _Unwind_Resume(a1);
}

void sub_1B3B99234(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3B992A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B99CD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _Unwind_Exception *exception_object, void *a11, void *a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27,void *a28,void *a29,void *a30,void *a31,void *a32,void *a33,void *a34,void *a35,void *a36,void *a37,void *a38,void *a39,void *a40,void *a41,void *a42,void *a43,void *a44,void *a45,void *a46,void *a47,void *a48,void *a49,void *a50,void *a51,void *a52)
{
  void *v52;
  void *v53;
  void *v54;
  void *v55;
  void *v56;
  void *v57;
  void *v58;
  void *v59;
  void *v60;
  void *v61;

  _Unwind_Resume(a1);
}

void sub_1B3B9A0E8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, id a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void *v14;

  _Unwind_Resume(a1);
}

void sub_1B3B9A178(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3B9A294(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B9A378(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B9A570(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B9A638(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL26ARFaceAnchorInitializeMapsv_block_invoke()
{
  void *v0;
  void *v1;
  void *v2;
  id v3;
  id v4;
  void *v5;
  id v6;
  void *v7;
  id v8;
  _QWORD v9[4];
  id v10;
  id v11;
  uint64_t v12;

  if (+[ARFaceTrackingInternalTechnique isSupported](ARFaceTrackingInternalTechnique, "isSupported"))
  {
    v12 = 0;
    CVAFaceTrackingCopySemantics();
    v0 = (void *)objc_opt_new();
    v1 = (void *)objc_opt_new();
    objc_msgSend(0, "objectForKeyedSubscript:", *MEMORY[0x1E0CFCC88]);
    v2 = (void *)objc_claimAutoreleasedReturnValue();
    v9[0] = MEMORY[0x1E0C809B0];
    v9[1] = 3221225472;
    v9[2] = ___ZL26ARFaceAnchorInitializeMapsv_block_invoke_2;
    v9[3] = &unk_1E6675C30;
    v3 = v0;
    v10 = v3;
    v4 = v1;
    v11 = v4;
    objc_msgSend(v2, "enumerateObjectsUsingBlock:", v9);
    v5 = (void *)_blendShapeLocationToIndexMap;
    _blendShapeLocationToIndexMap = (uint64_t)v3;
    v6 = v3;

    v7 = (void *)_indexToBlendShapeLocationMap;
    _indexToBlendShapeLocationMap = (uint64_t)v4;
    v8 = v4;

  }
}

void sub_1B3B9A848(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void ___ZL26ARFaceAnchorInitializeMapsv_block_invoke_2(uint64_t a1, void *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  void *v7;
  id v8;

  v8 = a2;
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a3);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(*(id *)(a1 + 32), "setObject:forKeyedSubscript:", v5, v8);

  v6 = *(void **)(a1 + 40);
  objc_msgSend(MEMORY[0x1E0CB37E8], "numberWithUnsignedInteger:", a3);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v6, "setObject:forKeyedSubscript:", v8, v7);

}

void sub_1B3B9A920(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_24()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

id _ARLogGeneral_37()
{
  if (_ARLogGeneral_onceToken_44[0] != -1)
    dispatch_once(_ARLogGeneral_onceToken_44, &__block_literal_global_106);
  return (id)_ARLogGeneral_logObj_44;
}

uint64_t arkit::Random::seedFromCurrentTime(arkit::Random *this)
{
  void *v1;
  double v2;
  uint64_t v3;

  objc_msgSend(MEMORY[0x1E0CB3898], "processInfo");
  v1 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "systemUptime");
  v3 = ((int)(uint64_t)(v2 * 1000000000.0) / 1000000);

  return v3;
}

void sub_1B3B9D058(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

int *arkit::Random::globalSeed(arkit::Random *this)
{
  unsigned __int8 v1;
  arkit::Random *v3;

  if ((v1 & 1) == 0)
  {
    if ((_DWORD)v3)
    {
      arkit::Random::globalSeed(void)::s_seed = arkit::Random::seedFromCurrentTime(v3);
    }
  }
  return &arkit::Random::globalSeed(void)::s_seed;
}

void sub_1B3B9D0C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void arkit::runSolver(uint64_t *a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X8>)
{
  int v5;
  unint64_t v6;
  float v7;
  unint64_t v8;
  unint64_t v9;
  int i;
  unint64_t v11;
  BOOL v12;
  char *v13;
  _QWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  _BYTE *v17;
  _BYTE v18[40];
  void *__p;
  _BYTE *v20;
  void *v21[3];
  char *v22;
  char *v23;
  uint64_t v24;
  void *v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;

  v5 = *(unsigned __int8 *)(a2 + 8);
  v6 = *(int *)(a2 + 12);
  v7 = *(float *)(a2 + 4);
  v8 = (a1[1] - *a1) >> 5;
  v28 = v8;
  v29 = v6;
  v25 = 0;
  v26 = 0;
  v27 = 0;
  if (v5 && v8 > v6)
  {
    kdebug_trace();
    v22 = 0;
    v23 = 0;
    v24 = 0;
    LODWORD(v9) = -1;
    for (i = 1; i != 33; ++i)
    {
      arkit::Random::sampleNumbers<unsigned long>((arkit::Random *)&v28, &v29, v21);
      arkit::FaceLightOptimizer::compute(a1, v21, (uint64_t)v18, v7);
      std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v22, (char *)__p, (uint64_t)v20, (v20 - (_BYTE *)__p) >> 3);
      v11 = (v23 - v22) >> 3;
      v12 = 1;
      if ((int)v9 < (int)v11)
      {
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v25, v22, (uint64_t)v23, v11);
        v9 = (unint64_t)(v23 - v22) >> 3;
        if ((float)((float)v28 * 0.9) < (float)(int)v9)
          v12 = 0;
      }
      if (__p)
      {
        v20 = __p;
        operator delete(__p);
      }
      if (v21[0])
      {
        v21[1] = v21[0];
        operator delete(v21[0]);
      }
      if (!v12)
        break;
    }
    kdebug_trace();
    v13 = v22;
    if (v22)
    {
      v23 = v22;
LABEL_23:
      operator delete(v13);
    }
  }
  else
  {
    std::vector<unsigned long long>::resize((uint64_t)&v25, v8);
    v14 = v25;
    v15 = v26;
    if (v25 != v26)
    {
      v16 = 0;
      do
        *v14++ = v16++;
      while (v14 != v15);
    }
    arkit::FaceLightOptimizer::compute(a1, &v25, (uint64_t)v18, v7);
    v17 = __p;
    if ((unint64_t)(v20 - (_BYTE *)__p) >= 0x41)
    {
      std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v25, (char *)__p, (uint64_t)v20, (v20 - (_BYTE *)__p) >> 3);
      v17 = __p;
    }
    if (v17)
    {
      v20 = v17;
      v13 = v17;
      goto LABEL_23;
    }
  }
  arkit::FaceLightOptimizer::compute(a1, &v25, a3, v7);
  if (v25)
  {
    v26 = v25;
    operator delete(v25);
  }
}

void sub_1B3B9D318(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25)
{
  if (__p)
    operator delete(__p);
  if (a24)
    operator delete(a24);
  _Unwind_Resume(exception_object);
}

arkit::Random *arkit::Random::sampleNumbers<unsigned long>@<X0>(arkit::Random *result@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  int *v11;
  double v12;
  double v13;
  unint64_t v14;
  _QWORD *v15;
  _QWORD *v16;

  v5 = *a2;
  v6 = *(_QWORD *)result;
  if (v5 > *(_QWORD *)result || v6 == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    v8 = (uint64_t *)result;
    if (v5 <= v6 >> 1)
    {
      result = (arkit::Random *)std::vector<unsigned long>::vector(a3, v5);
      if (*a2)
      {
        v9 = 0;
        while (1)
        {
          v10 = *v8;
          v11 = arkit::Random::globalSeed(result);
          result = (arkit::Random *)rand_r((unsigned int *)v11);
          v12 = (double)(int)result / 2147483650.0 * (double)(unint64_t)(v10 - 1);
          if (v12 >= 0.0)
            v13 = 0.5;
          else
            v13 = -0.5;
          v14 = (unint64_t)(v12 + v13);
          v15 = (_QWORD *)a3[1];
          v16 = (_QWORD *)*a3;
          if ((_QWORD *)*a3 != v15)
          {
            while (*v16 != v14)
            {
              if (++v16 == v15)
              {
                v16 = (_QWORD *)a3[1];
                break;
              }
            }
          }
          if (v16 == v15)
          {
            *(_QWORD *)(*a3 + 8 * v9++) = v14;
            if (v9 >= *a2)
              break;
          }
        }
      }
    }
    else
    {
      return arkit::Random::fisherYatesSample<unsigned long>(result, a2, a3);
    }
  }
  return result;
}

void sub_1B3B9D4D8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

arkit::Random *arkit::Random::fisherYatesSample<unsigned long>@<X0>(arkit::Random *result@<X0>, unint64_t *a2@<X1>, _QWORD *a3@<X8>)
{
  unint64_t v5;
  unint64_t v6;
  uint64_t *v8;
  _QWORD *v9;
  _QWORD *v10;
  uint64_t v11;
  _QWORD *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  double v18;
  double v19;
  unint64_t v20;
  _QWORD *v21;
  unint64_t v22;
  uint64_t v23;
  _QWORD *v24;

  v5 = *a2;
  v6 = *(_QWORD *)result;
  if (v5 > *(_QWORD *)result || v6 == 0)
  {
    *a3 = 0;
    a3[1] = 0;
    a3[2] = 0;
  }
  else
  {
    v8 = (uint64_t *)result;
    result = (arkit::Random *)std::vector<unsigned long>::vector(a3, v6);
    v10 = (_QWORD *)*a3;
    v9 = (_QWORD *)a3[1];
    if ((_QWORD *)*a3 != v9)
    {
      v11 = 0;
      v12 = (_QWORD *)*a3;
      do
        *v12++ = v11++;
      while (v12 != v9);
    }
    v13 = *a2;
    if (*a2)
    {
      v14 = 0;
      v15 = -1;
      do
      {
        v16 = *v8;
        v17 = arkit::Random::globalSeed(result);
        result = (arkit::Random *)rand_r((unsigned int *)v17);
        v18 = (double)(int)result / 2147483650.0 * (double)(unint64_t)(v15 + v16);
        if (v18 >= 0.0)
          v19 = 0.5;
        else
          v19 = -0.5;
        v20 = (unint64_t)(v18 + v19);
        if (v20)
        {
          v21 = (_QWORD *)*a3;
          v22 = v14 + v20;
          v23 = *(_QWORD *)(*a3 + 8 * v14);
          *(_QWORD *)(*a3 + 8 * v14) = *(_QWORD *)(*a3 + 8 * v22);
          v21[v22] = v23;
        }
        ++v14;
        v13 = *a2;
        --v15;
      }
      while (v14 < *a2);
      v10 = (_QWORD *)*a3;
      v9 = (_QWORD *)a3[1];
    }
    v24 = &v10[v13];
    if (v24 != v9)
      a3[1] = v24;
  }
  return result;
}

void sub_1B3B9D620(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<unsigned long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B3B9D694(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

id _ARLogGeneral_38()
{
  if (_ARLogGeneral_onceToken_45 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_45, &__block_literal_global_179);
  return (id)_ARLogGeneral_logObj_45;
}

void sub_1B3B9EF08(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B9F120(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  id *v14;
  void *v15;

  objc_destroyWeak(v14);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1B3B9F17C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3B9F3B8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9)
{
  void *v9;

  _Unwind_Resume(a1);
}

void sub_1B3B9F484(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B9F4E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3B9F5E4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3B9F740(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3B9FBAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3B9FD6C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_13()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_25()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

float arkit::mapColorTemperature(arkit *this, float a2)
{
  return fmin(fmax(a2 * 6.86031362 + -6982.00584 + a2 * a2 * -0.00121228514 + pow(a2, 3.0) * 0.0000000714547913, 2000.0), 7000.0);
}

void arkit::RTFSPContainer::loadRtfsp(_QWORD *a1@<X0>, uint64_t *a2@<X8>)
{
  uint64_t v4;
  const std::locale::facet *v5;
  unsigned __int8 v6;
  _QWORD *v7;
  void *v8;
  void *v9;
  const std::locale::facet *v10;
  unsigned __int8 v11;
  _QWORD *v12;
  _QWORD *v13;
  int *v14;
  _QWORD *v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  std::locale::__imp *v34;
  std::locale::__imp *v35;
  int __sz;
  std::locale __sz_4[2];
  uint64_t v38;
  void *__p;
  char v40;
  _BYTE v41[156];
  int v42;
  std::string v43;

  if ((*((_BYTE *)a1 + *(_QWORD *)(*a1 - 24) + 32) & 1) != 0)
  {
    *a2 = 0;
    return;
  }
  v4 = operator new();
  *(_OWORD *)v4 = 0u;
  *(_OWORD *)(v4 + 16) = 0u;
  *(_OWORD *)(v4 + 32) = 0u;
  *(_OWORD *)(v4 + 48) = 0u;
  *(_OWORD *)(v4 + 64) = 0u;
  *(_OWORD *)(v4 + 80) = 0u;
  *(_QWORD *)(v4 + 96) = 0;
  __sz = 0;
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
  v5 = std::locale::use_facet(__sz_4, MEMORY[0x1E0DE4A90]);
  v6 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(__sz_4);
  v7 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, v4, v6);
  if ((*((_BYTE *)v7 + *(_QWORD *)(*v7 - 24) + 32) & 5) == 0)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
    v10 = std::locale::use_facet(__sz_4, MEMORY[0x1E0DE4A90]);
    v11 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
    std::locale::~locale(__sz_4);
    v12 = std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, v4 + 24, v11);
    if ((*((_BYTE *)v12 + *(_QWORD *)(*v12 - 24) + 32) & 5) != 0)
      goto LABEL_13;
    v13 = (_QWORD *)MEMORY[0x1B5E2D498](a1, &__sz);
    if ((*((_BYTE *)v13 + *(_QWORD *)(*v13 - 24) + 32) & 5) != 0)
      goto LABEL_13;
    if (std::istream::peek() == 10)
      std::istream::ignore();
    v14 = (int *)(v4 + 96);
    v15 = (_QWORD *)MEMORY[0x1B5E2D498](a1, v4 + 96);
    if ((*((_BYTE *)v15 + *(_QWORD *)(*v15 - 24) + 32) & 5) != 0)
    {
LABEL_13:
      __sz_4[0].__locale_ = (std::locale::__imp *)(v4 + 72);
      std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100]((void ***)__sz_4);
      v16 = *(void **)(v4 + 48);
      if (v16)
      {
        *(_QWORD *)(v4 + 56) = v16;
        operator delete(v16);
      }
      if ((*(char *)(v4 + 47) & 0x80000000) == 0)
        goto LABEL_18;
      v9 = *(void **)(v4 + 24);
      goto LABEL_17;
    }
    if (std::istream::peek() == 10)
      std::istream::ignore();
    std::vector<int>::resize((std::vector<int> *)(v4 + 48), __sz);
    v17 = 0;
    v33 = __sz;
    memset(&v43, 0, sizeof(v43));
    v34 = *(std::locale::__imp **)(MEMORY[0x1E0DE4F58] + 24);
    v35 = (std::locale::__imp *)*MEMORY[0x1E0DE4F58];
    v18 = MEMORY[0x1E0DE4FB8] + 16;
    while (1)
    {
      v19 = std::operator>>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (uint64_t)&v43);
      if ((*((_BYTE *)v19 + *(_QWORD *)(*v19 - 24) + 32) & 5) != 0)
      {
LABEL_61:
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
          operator delete(v43.__r_.__value_.__l.__data_);
LABEL_63:
        arkit::RTFSPContainer::~RTFSPContainer((arkit::RTFSPContainer *)v4);
        goto LABEL_20;
      }
      if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
      {
        v20 = *v43.__r_.__value_.__l.__data_;
        if (v20 == 10)
          goto LABEL_61;
        if (v43.__r_.__value_.__l.__size_ != 1)
          goto LABEL_34;
      }
      else
      {
        v20 = v43.__r_.__value_.__s.__data_[0];
        if (v43.__r_.__value_.__s.__data_[0] == 10)
          goto LABEL_63;
        if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) != 1)
          goto LABEL_34;
      }
      if (v20 != 44 && v20 != 32)
      {
LABEL_34:
        v42 = 0;
        std::istringstream::basic_istringstream[abi:ne180100](__sz_4, &v43, 8);
        MEMORY[0x1B5E2D498](__sz_4, &v42);
        *(_DWORD *)(*(_QWORD *)(v4 + 48) + 4 * v17) = v42;
        __sz_4[0].__locale_ = v35;
        *(std::locale::__imp **)((char *)&__sz_4[0].__locale_ + *((_QWORD *)v35 - 3)) = v34;
        v38 = v18;
        if (v40 < 0)
          operator delete(__p);
        ++v17;
        std::streambuf::~streambuf();
        std::istream::~istream();
        MEMORY[0x1B5E2D57C](v41);
        if (v17 == v33)
        {
          if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
            operator delete(v43.__r_.__value_.__l.__data_);
          if (std::istream::peek() == 10)
            std::istream::ignore();
          v21 = (_QWORD *)(v4 + 72);
          std::vector<cva::Matrix<float,1u,0u,false>>::resize((uint64_t *)(v4 + 72), __sz);
          if (__sz < 1)
            goto LABEL_21;
          v22 = 0;
          v32 = MEMORY[0x1E0DE4FB8] + 16;
          while (2)
          {
            v31 = v22;
            v23 = 3 * v22;
            v24 = *v21 + 24 * v22;
            v25 = *v14;
            *(_DWORD *)(v24 + 16) = v25;
            cva::MatrixData<float,0ul,0ul,false>::reserve(v24, v25);
            v26 = 0;
            v27 = *v14;
            v28 = *v21 + 8 * v23;
            memset(&v43, 0, sizeof(v43));
LABEL_44:
            v29 = std::operator>>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(a1, (uint64_t)&v43);
            if ((*((_BYTE *)v29 + *(_QWORD *)(*v29 - 24) + 32) & 5) != 0)
              goto LABEL_61;
            if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
            {
              v30 = *v43.__r_.__value_.__l.__data_;
              if (v30 == 10)
                goto LABEL_61;
              if (v43.__r_.__value_.__l.__size_ != 1)
              {
LABEL_53:
                v42 = 0;
                std::istringstream::basic_istringstream[abi:ne180100](__sz_4, &v43, 8);
                MEMORY[0x1B5E2D48C](__sz_4, &v42);
                if (v26 >= *(unsigned int *)(v28 + 16))
                  __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
                *(_DWORD *)(*(_QWORD *)v28 + 4 * v26) = v42;
                __sz_4[0].__locale_ = v35;
                *(std::locale::__imp **)((char *)&__sz_4[0].__locale_ + *((_QWORD *)v35 - 3)) = v34;
                v38 = v32;
                if (v40 < 0)
                  operator delete(__p);
                ++v26;
                std::streambuf::~streambuf();
                std::istream::~istream();
                MEMORY[0x1B5E2D57C](v41);
                if (v26 == v27)
                {
                  if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) < 0)
                    operator delete(v43.__r_.__value_.__l.__data_);
                  v22 = v31 + 1;
                  if (v31 + 1 < __sz)
                    continue;
                  goto LABEL_21;
                }
                goto LABEL_44;
              }
            }
            else
            {
              v30 = v43.__r_.__value_.__s.__data_[0];
              if (v43.__r_.__value_.__s.__data_[0] == 10)
                goto LABEL_63;
              if (SHIBYTE(v43.__r_.__value_.__r.__words[2]) != 1)
                goto LABEL_53;
            }
            break;
          }
          if (v30 == 44 || v30 == 32)
            goto LABEL_44;
          goto LABEL_53;
        }
      }
    }
  }
  __sz_4[0].__locale_ = (std::locale::__imp *)(v4 + 72);
  std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100]((void ***)__sz_4);
  v8 = *(void **)(v4 + 48);
  if (v8)
  {
    *(_QWORD *)(v4 + 56) = v8;
    operator delete(v8);
  }
  if ((*(char *)(v4 + 47) & 0x80000000) == 0)
    goto LABEL_18;
  v9 = *(void **)(v4 + 24);
LABEL_17:
  operator delete(v9);
LABEL_18:
  if (*(char *)(v4 + 23) < 0)
    operator delete(*(void **)v4);
LABEL_20:
  MEMORY[0x1B5E2D5B8](v4, 0x1032C40D1F799DBLL);
  v4 = 0;
LABEL_21:
  *a2 = v4;
}

void sub_1B3BA057C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, std::locale a18)
{
  void **v18;
  uint64_t v19;

  std::istringstream::~istringstream((uint64_t)&a18);
  if (*(char *)(v19 - 89) < 0)
    operator delete(*v18);
  _Unwind_Resume(a1);
}

void arkit::RTFSPContainer::~RTFSPContainer(arkit::RTFSPContainer *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 72);
  std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = (void *)*((_QWORD *)this + 6);
  if (v2)
  {
    *((_QWORD *)this + 7) = v2;
    operator delete(v2);
  }
  if (*((char *)this + 47) < 0)
    operator delete(*((void **)this + 3));
  if (*((char *)this + 23) < 0)
    operator delete(*(void **)this);
}

void std::vector<int>::resize(std::vector<int> *this, std::vector<int>::size_type __sz)
{
  std::vector<int>::size_type v2;

  v2 = this->__end_ - this->__begin_;
  if (__sz <= v2)
  {
    if (__sz < v2)
      this->__end_ = &this->__begin_[__sz];
  }
  else
  {
    std::vector<int>::__append(this, __sz - v2);
  }
}

void std::vector<cva::Matrix<float,1u,0u,false>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  BOOL v5;
  unint64_t v6;
  uint64_t v7;
  void *v8;

  v3 = a1[1];
  v4 = 0xAAAAAAAAAAAAAAABLL * ((v3 - *a1) >> 3);
  v5 = a2 >= v4;
  v6 = a2 - v4;
  if (v6 != 0 && v5)
  {
    std::vector<cva::Matrix<float,1u,0u,false>>::__append(a1, v6);
  }
  else if (!v5)
  {
    v7 = *a1 + 24 * a2;
    while (v3 != v7)
    {
      v8 = *(void **)(v3 - 24);
      v3 -= 24;
      free(v8);
    }
    a1[1] = v7;
  }
}

void arkit::RTFSPContainer::loadRtfsp(uint64_t *a1@<X8>, uint64_t a2@<X0>)
{
  if (*(_BYTE *)(a2 + 24))
    arkit::RTFSPContainer::loadRtfsp(a1);
  else
    arkit::RTFSPContainer::loadRtfspDefault(a1);
}

uint64_t arkit::RTFSPContainer::loadRtfsp@<X0>(uint64_t *a1@<X8>)
{
  _QWORD v3[2];
  _QWORD v4[51];
  _QWORD v5[20];

  v5[19] = *MEMORY[0x1E0C80C00];
  std::ifstream::basic_ifstream(v3);
  if (v4[15])
    arkit::RTFSPContainer::loadRtfsp(v3, a1);
  else
    *a1 = 0;
  v3[0] = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)v3 + *(_QWORD *)(v3[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 24);
  MEMORY[0x1B5E2D450](v4);
  std::istream::~istream();
  return MEMORY[0x1B5E2D57C](v5);
}

void sub_1B3BA07B8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::ifstream::~ifstream((uint64_t *)va);
  _Unwind_Resume(a1);
}

void arkit::RTFSPContainer::loadRtfspDefault(uint64_t *a1@<X8>)
{
  _QWORD v3[12];
  char v4;
  uint64_t v5;
  std::string v6;

  std::string::basic_string[abi:ne180100]<0>(&v6, aDefaultTrained);
  std::istringstream::basic_istringstream[abi:ne180100](v3, &v6, 8);
  arkit::RTFSPContainer::loadRtfsp(v3, a1);
  v3[0] = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)((char *)v3 + *(_QWORD *)(v3[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 24);
  v3[2] = MEMORY[0x1E0DE4FB8] + 16;
  if (v4 < 0)
    operator delete((void *)v3[10]);
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E2D57C](&v5);
  if (SHIBYTE(v6.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v6.__r_.__value_.__l.__data_);
}

void sub_1B3BA08A0(_Unwind_Exception *a1, uint64_t a2, ...)
{
  uint64_t v2;
  va_list va;

  va_start(va, a2);
  std::istringstream::~istringstream((uint64_t)va);
  if (*(char *)(v2 - 33) < 0)
    operator delete(*(void **)(v2 - 56));
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::basic_ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x1E0DE4FA8];
  v3 = MEMORY[0x1E0DE4FA8] + 64;
  a1[53] = MEMORY[0x1E0DE4FA8] + 64;
  v4 = a1 + 2;
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 8);
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F40] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  a1[1] = 0;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 2);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[53] = v3;
  MEMORY[0x1B5E2D444](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_1B3BA09AC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x1B5E2D57C](v1 + 424);
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F40];
  v3 = *MEMORY[0x1E0DE4F40];
  *a1 = *MEMORY[0x1E0DE4F40];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1B5E2D450](a1 + 2);
  std::istream::~istream();
  MEMORY[0x1B5E2D57C](a1 + 53);
  return a1;
}

_QWORD *arkit::RTFSPContainer::rtfspDefault@<X0>(_QWORD *a1@<X8>)
{
  return std::string::basic_string[abi:ne180100]<0>(a1, aDefaultTrained);
}

_QWORD *std::istringstream::basic_istringstream[abi:ne180100](_QWORD *a1, const std::string *a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  std::ios_base *v11;

  v6 = MEMORY[0x1E0DE4FD8];
  v7 = MEMORY[0x1E0DE4FD8] + 64;
  a1[15] = MEMORY[0x1E0DE4FD8] + 64;
  v8 = (uint64_t)(a1 + 2);
  v9 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 8);
  v10 = *(_QWORD *)(MEMORY[0x1E0DE4F58] + 16);
  *a1 = v9;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v9 - 24)) = v10;
  a1[1] = 0;
  v11 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v11, a1 + 2);
  v11[1].__vftable = 0;
  v11[1].__fmtflags_ = -1;
  *a1 = v6 + 24;
  a1[15] = v7;
  std::stringbuf::basic_stringbuf[abi:ne180100](v8, a2, a3 | 8);
  return a1;
}

void sub_1B3BA0B08(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x1B5E2D57C](v1);
  _Unwind_Resume(a1);
}

uint64_t std::istringstream::~istringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F58];
  v3 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F58];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 16) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 103) < 0)
    operator delete(*(void **)(a1 + 80));
  std::streambuf::~streambuf();
  std::istream::~istream();
  MEMORY[0x1B5E2D57C](a1 + 120);
  return a1;
}

void std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  char *v2;
  char *v4;
  void *v5;
  void *v6;

  v1 = *a1;
  v2 = (char *)**a1;
  if (v2)
  {
    v4 = (char *)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = (void *)*((_QWORD *)v4 - 3);
        v4 -= 24;
        free(v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

_QWORD *std::getline[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(_QWORD *a1, uint64_t a2, unsigned __int8 a3)
{
  uint64_t v6;
  _QWORD *v7;
  _BYTE *v8;
  int v9;
  char v11;

  MEMORY[0x1B5E2D474](&v11, a1, 1);
  if (!v11)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v6 = 0;
  while (1)
  {
    v7 = *(_QWORD **)((char *)a1 + *(_QWORD *)(*a1 - 24) + 40);
    v8 = (_BYTE *)v7[3];
    if (v8 != (_BYTE *)v7[4])
    {
      v7[3] = v8 + 1;
      LOBYTE(v7) = *v8;
      goto LABEL_9;
    }
    LODWORD(v7) = (*(uint64_t (**)(_QWORD *))(*v7 + 80))(v7);
    if ((_DWORD)v7 == -1)
      break;
LABEL_9:
    if (v7 == a3)
    {
      v9 = 0;
      goto LABEL_17;
    }
    std::string::push_back((std::string *)a2, (std::string::value_type)v7);
    --v6;
    if (*(char *)(a2 + 23) < 0 && *(_QWORD *)(a2 + 8) == 0x7FFFFFFFFFFFFFF7)
    {
      v9 = 4;
      goto LABEL_17;
    }
  }
  if (v6)
    v9 = 2;
  else
    v9 = 6;
LABEL_17:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | v9);
  return a1;
}

void sub_1B3BA0E10(void *a1)
{
  _QWORD *v1;
  uint64_t v2;

  __cxa_begin_catch(a1);
  v2 = *v1;
  *(_DWORD *)((char *)v1 + *(_QWORD *)(*v1 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v1 + *(_QWORD *)(v2 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B3BA0DDCLL);
  }
  __cxa_rethrow();
}

void sub_1B3BA0E54(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

void std::vector<int>::__append(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *v5;
  int *value;
  int *end;
  std::vector<int>::pointer begin;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  int *v16;
  int *v17;
  int v18;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  v5 = value;
  end = p_end_cap[-1].__value_;
  if (__n <= value - end)
  {
    if (__n)
    {
      bzero(p_end_cap[-1].__value_, 4 * __n);
      end += __n;
    }
    this->__end_ = end;
  }
  else
  {
    begin = this->__begin_;
    v9 = (char *)end - (char *)this->__begin_;
    v10 = __n + (v9 >> 2);
    if (v10 >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 2;
    v12 = (char *)v5 - (char *)begin;
    if (v12 >> 1 > v10)
      v10 = v12 >> 1;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
      v13 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, v13);
      begin = this->__begin_;
      end = this->__end_;
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[4 * v11];
    v16 = (int *)&v14[4 * v13];
    bzero(v15, 4 * __n);
    v17 = (int *)&v15[4 * __n];
    while (end != begin)
    {
      v18 = *--end;
      *((_DWORD *)v15 - 1) = v18;
      v15 -= 4;
    }
    this->__begin_ = (std::vector<int>::pointer)v15;
    this->__end_ = v17;
    this->__end_cap_.__value_ = v16;
    if (begin)
      operator delete(begin);
  }
}

uint64_t *std::operator>>[abi:ne180100]<char,std::char_traits<char>,std::allocator<char>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  const std::locale::facet *v7;
  uint64_t v8;
  _QWORD *v9;
  uint64_t v10;
  _QWORD *v11;
  _BYTE *v12;
  int v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  std::locale v19;
  char v20;

  MEMORY[0x1B5E2D474](&v20, a1, 0);
  if (!v20)
    return a1;
  if (*(char *)(a2 + 23) < 0)
  {
    **(_BYTE **)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
  else
  {
    *(_BYTE *)a2 = 0;
    *(_BYTE *)(a2 + 23) = 0;
  }
  v4 = *(_QWORD *)(*a1 - 24);
  v5 = *(uint64_t *)((char *)a1 + v4 + 24);
  if (v5 <= 1)
    v6 = 1;
  else
    v6 = *(uint64_t *)((char *)a1 + v4 + 24);
  std::ios_base::getloc((const std::ios_base *)((char *)a1 + v4));
  v7 = std::locale::use_facet(&v19, MEMORY[0x1E0DE4A90]);
  std::locale::~locale(&v19);
  v8 = 0;
  v9 = a1 + 5;
  if (v5 >= 1)
    v10 = v6;
  else
    v10 = 0x7FFFFFFFFFFFFFF7;
  while (1)
  {
    v11 = *(_QWORD **)((char *)v9 + *(_QWORD *)(*a1 - 24));
    v12 = (_BYTE *)v11[3];
    if (v12 == (_BYTE *)v11[4])
      break;
    LOBYTE(v13) = *v12;
LABEL_14:
    if ((v13 & 0x80) == 0 && (*((_DWORD *)&v7[1].~facet + v13) & 0x4000) != 0)
    {
      v16 = 0;
      goto LABEL_23;
    }
    std::string::push_back((std::string *)a2, v13);
    v14 = *(_QWORD **)((char *)v9 + *(_QWORD *)(*a1 - 24));
    v15 = v14[3];
    if (v15 == v14[4])
      (*(void (**)(_QWORD *))(*v14 + 80))(v14);
    else
      v14[3] = v15 + 1;
    if (v10 == ++v8)
    {
      v16 = 0;
      v17 = *a1;
      *(uint64_t *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 24) = 0;
      goto LABEL_25;
    }
  }
  v13 = (*(uint64_t (**)(_QWORD *))(*v11 + 72))(v11);
  if (v13 != -1)
    goto LABEL_14;
  v16 = 2;
LABEL_23:
  v17 = *a1;
  *(uint64_t *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 24) = 0;
  if (!v8)
    v16 |= 4u;
LABEL_25:
  std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(v17 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(v17 - 24) + 32) | v16);
  return a1;
}

void sub_1B3BA1124(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, std::locale a9)
{
  _QWORD *v9;
  uint64_t v11;

  std::locale::~locale(&a9);
  __cxa_begin_catch(a1);
  v11 = *v9;
  *(_DWORD *)((char *)v9 + *(_QWORD *)(*v9 - 24) + 32) |= 1u;
  if ((*((_BYTE *)v9 + *(_QWORD *)(v11 - 24) + 36) & 1) == 0)
  {
    __cxa_end_catch();
    JUMPOUT(0x1B3BA10F0);
  }
  __cxa_rethrow();
}

void sub_1B3BA1188(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::vector<cva::Matrix<float,1u,0u,false>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  char *v16;
  uint64_t v17;
  _QWORD v18[5];

  v6 = a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(result - 8);
  if (0xAAAAAAAAAAAAAAABLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = v7 + 24 * a2;
      v14 = 24 * a2;
      do
      {
        *(_QWORD *)v7 = 0;
        *(_QWORD *)(v7 + 8) = 0;
        *(_DWORD *)(v7 + 16) = 0;
        v7 += 24;
        v14 -= 24;
      }
      while (v14);
      v7 = v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((v7 - *a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0xAAAAAAAAAAAAAAALL)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * ((v5 - *a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v9;
    v18[4] = result;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<float>>>(result, v11);
    else
      v12 = 0;
    v15 = &v12[24 * v8];
    v18[0] = v12;
    v18[1] = v15;
    v18[3] = &v12[24 * v11];
    v16 = &v15[24 * a2];
    v17 = 24 * a2;
    do
    {
      *(_QWORD *)v15 = 0;
      *((_QWORD *)v15 + 1) = 0;
      *((_DWORD *)v15 + 4) = 0;
      v15 += 24;
      v17 -= 24;
    }
    while (v17);
    v18[2] = v16;
    std::vector<cva::Matrix<float,1u,0u,false>>::__swap_out_circular_buffer(a1, v18);
    return std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer((uint64_t)v18);
  }
  return result;
}

void sub_1B3BA12D8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t *std::vector<cva::Matrix<float,1u,0u,false>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      v8 = *(_QWORD *)(v2 + v5 - 16);
      *(_QWORD *)(v6 - 24) = *(_QWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 16) = v8;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_DWORD *)(v6 - 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v7 - 8) = 0;
      v5 -= 24;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v9 = *result;
  *result = v4;
  a2[1] = v9;
  v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<cva::Matrix<float,1u,0u,false>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;
  void *v4;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    v4 = *(void **)(i - 24);
    *(_QWORD *)(a1 + 16) = i - 24;
    free(v4);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void cva::MatrixData<float,0ul,0ul,false>::reserve(uint64_t a1, unint64_t a2)
{
  if (a2)
  {
    if (*(_QWORD *)(a1 + 8) < a2)
    {
      free(*(void **)a1);
      *(_QWORD *)a1 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a1, a2);
    }
  }
  else
  {
    free(*(void **)a1);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
}

uint64_t cva::MatrixData<float,0ul,0ul,false>::allocate(void **a1, uint64_t a2)
{
  size_t v3;
  uint64_t result;
  void *v5;
  void *memptr;

  if (*a1)
    cva::MatrixData<float,0ul,0ul,false>::allocate();
  v3 = (4 * a2 + 31) & 0xFFFFFFFFFFFFFFE0;
  a1[1] = (void *)(v3 >> 2);
  memptr = 0;
  result = malloc_type_posix_memalign(&memptr, 0x20uLL, v3, 0x49090899uLL);
  v5 = memptr;
  *a1 = memptr;
  if (!v5)
    cva::MatrixData<float,0ul,0ul,false>::allocate();
  return result;
}

uint64_t std::stringbuf::basic_stringbuf[abi:ne180100](uint64_t a1, const std::string *a2, int a3)
{
  uint64_t v6;

  v6 = std::streambuf::basic_streambuf();
  *(_QWORD *)v6 = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(v6 + 64) = 0u;
  *(_OWORD *)(v6 + 80) = 0u;
  *(_DWORD *)(v6 + 96) = a3;
  std::string::operator=((std::string *)(v6 + 64), a2);
  std::stringbuf::__init_buf_ptrs[abi:ne180100](a1);
  return a1;
}

void sub_1B3BA14F4(_Unwind_Exception *a1)
{
  uint64_t v1;
  void **v2;

  if (*(char *)(v1 + 87) < 0)
    operator delete(*v2);
  std::streambuf::~streambuf();
  _Unwind_Resume(a1);
}

void std::stringbuf::__init_buf_ptrs[abi:ne180100](uint64_t a1)
{
  std::string *v2;
  char v3;
  std::string *v4;
  unint64_t v5;
  int v6;
  std::string::size_type v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  *(_QWORD *)(a1 + 88) = 0;
  v2 = (std::string *)(a1 + 64);
  v3 = *(_BYTE *)(a1 + 87);
  if (v3 < 0)
  {
    v4 = *(std::string **)(a1 + 64);
    v5 = *(_QWORD *)(a1 + 72);
  }
  else
  {
    v4 = v2;
    v5 = *(unsigned __int8 *)(a1 + 87);
  }
  v6 = *(_DWORD *)(a1 + 96);
  if ((v6 & 8) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    *(_QWORD *)(a1 + 16) = v4;
    *(_QWORD *)(a1 + 24) = v4;
    *(_QWORD *)(a1 + 32) = (char *)v4 + v5;
  }
  if ((v6 & 0x10) != 0)
  {
    *(_QWORD *)(a1 + 88) = (char *)v4 + v5;
    v7 = v3 < 0 ? (*(_QWORD *)(a1 + 80) & 0x7FFFFFFFFFFFFFFFLL) - 1 : 22;
    std::string::resize(v2, v7, 0);
    v8 = *(char *)(a1 + 87) < 0 ? *(_QWORD *)(a1 + 72) : *(unsigned __int8 *)(a1 + 87);
    *(_QWORD *)(a1 + 40) = v4;
    *(_QWORD *)(a1 + 48) = v4;
    *(_QWORD *)(a1 + 56) = (char *)v4 + v8;
    if ((*(_BYTE *)(a1 + 96) & 3) != 0)
    {
      if (v5 >> 31)
      {
        v9 = ((v5 - 0x80000000) * (unsigned __int128)0x200000005uLL) >> 64;
        v10 = 0x7FFFFFFF * ((v9 + ((v5 - 0x80000000 - v9) >> 1)) >> 30);
        v4 = (std::string *)((char *)v4 + v10 + 0x7FFFFFFF);
        v5 = v5 - v10 - 0x7FFFFFFF;
        *(_QWORD *)(a1 + 48) = v4;
      }
      if (v5)
        *(_QWORD *)(a1 + 48) = (char *)v4 + v5;
    }
  }
}

void GetConfidenceFromUncertainty(float a1)
{
  float v1;

  v1 = 1.0 - expf(a1 * 0.5);
  if (v1 < 0.0 || v1 > 1.0)
    GetConfidenceFromUncertainty();
}

void sub_1B3BA16FC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BA17CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::push_back[abi:ne180100](char **a1, __int128 *a2)
{
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  char *v7;
  uint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  uint64_t v17;
  char *v18;
  __int128 v19;
  unint64_t *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  char *v24;
  __int128 v25;
  int64x2_t v26;
  char *v27;
  uint64_t v28;
  int64x2_t v29;
  char *v30;
  uint64_t v31;

  v6 = (unint64_t)a1[2];
  result = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(result - 8);
  if ((unint64_t)v7 >= v6)
  {
    v12 = (v7 - *a1) >> 4;
    v13 = v12 + 1;
    if ((unint64_t)(v12 + 1) >> 60)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v14 = v5 - (_QWORD)*a1;
    if (v14 >> 3 > v13)
      v13 = v14 >> 3;
    if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
      v15 = 0xFFFFFFFFFFFFFFFLL;
    else
      v15 = v13;
    v31 = result;
    v16 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m(result, v15);
    v18 = &v16[16 * v12];
    v19 = *a2;
    *(_OWORD *)v18 = *a2;
    if (*((_QWORD *)&v19 + 1))
    {
      v20 = (unint64_t *)(*((_QWORD *)&v19 + 1) + 8);
      do
        v21 = __ldxr(v20);
      while (__stxr(v21 + 1, v20));
    }
    v23 = *a1;
    v22 = a1[1];
    if (v22 == *a1)
    {
      v26 = vdupq_n_s64((unint64_t)v22);
      v24 = &v16[16 * v12];
    }
    else
    {
      v24 = &v16[16 * v12];
      do
      {
        v25 = *((_OWORD *)v22 - 1);
        v22 -= 16;
        *((_OWORD *)v24 - 1) = v25;
        v24 -= 16;
        *(_QWORD *)v22 = 0;
        *((_QWORD *)v22 + 1) = 0;
      }
      while (v22 != v23);
      v26 = *(int64x2_t *)a1;
    }
    v11 = v18 + 16;
    *a1 = v24;
    a1[1] = v18 + 16;
    v29 = v26;
    v27 = a1[2];
    a1[2] = &v16[16 * v17];
    v30 = v27;
    v28 = v26.i64[0];
    result = std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::~__split_buffer((uint64_t)&v28);
  }
  else
  {
    *(_QWORD *)v7 = *(_QWORD *)a2;
    v8 = *((_QWORD *)a2 + 1);
    *((_QWORD *)v7 + 1) = v8;
    if (v8)
    {
      v9 = (unint64_t *)(v8 + 8);
      do
        v10 = __ldxr(v9);
      while (__stxr(v10 + 1, v9));
    }
    v11 = v7 + 16;
  }
  a1[1] = v11;
  return result;
}

void sub_1B3BA1A70(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA25EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id *a11, id *location, void *a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,void (*a28)(char *),uint64_t a29,uint64_t a30,char a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,char a36,uint64_t a37,uint64_t a38)
{
  void *v38;
  uint64_t v39;

  a28(&a26);
  objc_destroyWeak(location);

  objc_destroyWeak(a11);
  objc_destroyWeak((id *)(v39 - 256));
  (*(void (**)(uint64_t))(v39 - 232))(v39 - 248);
  (*(void (**)(uint64_t))(v39 - 192))(v39 - 208);
  _Unwind_Resume(a1);
}

void ARSetNSErrorByWrappingCFErrorWithFailureReasonMessage(_QWORD *a1, void *a2, void *a3)
{
  void *v5;
  void *v6;
  id v7;

  v7 = a3;
  if (a1)
  {
    v5 = (void *)objc_opt_new();
    v6 = v5;
    if (a2)
    {
      objc_msgSend(v5, "setObject:forKeyedSubscript:", a2, *MEMORY[0x1E0CB3388]);

    }
    if (v7)
      objc_msgSend(v6, "setObject:forKeyedSubscript:", v7, *MEMORY[0x1E0CB2D68]);
    *a1 = (id)objc_msgSend(objc_alloc(MEMORY[0x1E0CB35C8]), "initWithDomain:code:userInfo:", CFSTR("com.apple.arkit.ARSceneReconstructionHandler"), 1, v6);

  }
}

void sub_1B3BA2844(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_1B3BA28EC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA2960(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA2A1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3BA2A84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3BA2B68(_Unwind_Exception *a1)
{
  id *v1;
  uint64_t v2;

  objc_destroyWeak(v1);
  objc_destroyWeak((id *)(v2 - 40));
  _Unwind_Resume(a1);
}

void sub_1B3BA2BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_1B3BA2C48(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA2D90(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA3070(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BA3200(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BA3468(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3BA38EC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;

  _Unwind_Resume(a1);
}

void sub_1B3BA3C50(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BA4520(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,void *a25,char a26,uint64_t a27,void (*a28)(char *))
{
  void *v28;
  void *v29;
  uint64_t v30;

  a28(&a26);
  (*(void (**)(uint64_t))(v30 - 184))(v30 - 200);

  _Unwind_Resume(a1);
}

void sub_1B3BA49AC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BA4C04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  void *v12;
  void *v13;

  a12(&a10);

  _Unwind_Resume(a1);
}

void sub_1B3BA4DAC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3BA4ED8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, objc_super a10)
{
  a10.super_class = (Class)ARSceneReconstructionHandler;
  -[_Unwind_Exception dealloc](&a10, sel_dealloc);
  _Unwind_Resume(a1);
}

void ___ZL15_ARLogTechniquev_block_invoke_14()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void ___ZL13_ARLogGeneralv_block_invoke_26()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

uint64_t std::__split_buffer<std::shared_ptr<CV3DSLAMStateContext const>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 16;
    std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100](i - 16);
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::vector<std::shared_ptr<CV3DSLAMStateContext const>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = v2;
    if ((void *)v4 != v2)
    {
      do
        v4 = std::shared_ptr<arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>>::~shared_ptr[abi:ne180100](v4 - 16);
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

id _ARLogGeneral_39()
{
  if (_ARLogGeneral_onceToken_46 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_46, &__block_literal_global_191_1);
  return (id)_ARLogGeneral_logObj_46;
}

void sub_1B3BA62F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

void arkit::FaceLightOptimizer::compute(uint64_t *a1@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>, float a4@<S0>)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  cva::Logger *v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  char *v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  uint64_t v21;
  int *v22;
  int v23;
  int v24;
  const char *v25;
  const char *v26;
  char *v27;
  int v29;
  void *v30[2];
  unsigned int v31;
  int v32;
  void *v33[2];
  unsigned int v34;

  v8 = *a1;
  v7 = a1[1];
  if ((v7 - *a1) >> 5 >= (unint64_t)((uint64_t)(a2[1] - *a2) >> 3))
    v9 = (uint64_t)(a2[1] - *a2) >> 3;
  else
    v9 = (v7 - *a1) >> 5;
  if (v7 == v8)
    v10 = 0;
  else
    v10 = *(_DWORD *)(v8 + 24);
  v33[0] = 0;
  v33[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v33, v9);
  v34 = v9;
  v30[0] = 0;
  v30[1] = 0;
  v11 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate(v30, (v10 * v9));
  v31 = v9;
  v32 = v10;
  v29 = v10;
  if ((int)v9 >= 1)
  {
    v12 = 0;
    v26 = "matrixmixin.h";
    v27 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    v25 = "row";
    while (1)
    {
      if (v12 >= v34)
        __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
      v13 = *(_QWORD *)(*a2 + 8 * v12);
      v14 = *a1;
      *((_DWORD *)v33[0] + v12) = *(_DWORD *)(*a1 + 32 * v13);
      v15 = v31;
      if (v12 >= v31)
        break;
      v16 = v32;
      v17 = (char *)v30[0];
      v18 = v14 + 32 * v13;
      v19 = v18 + 8;
      if (v32 != *(_DWORD *)(v18 + 24))
      {
        cva::Logger::instance(v11);
        v11 = (cva::Logger *)cva::Logger::logInCategory();
        if (v16 != *(_DWORD *)(v19 + 16))
        {
          v24 = 163;
          v25 = "assert_equal_size";
          v26 = "matrixfun.h";
          v27 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix size"
                "s are not compatible!\")";
LABEL_28:
          __assert_rtn(v25, v26, v24, v27);
        }
      }
      if (v16)
        v20 = &v17[4 * v12];
      else
        v20 = 0;
      v21 = (uint64_t)&v17[4 * v12 + 4 * v16 * v15];
      if (!v16)
        v21 = 0;
      if (v20 != (char *)v21)
      {
        v22 = *(int **)v19;
        do
        {
          v23 = *v22++;
          *(_DWORD *)v20 = v23;
          v20 += 4 * (int)v15;
        }
        while (v20 != (char *)v21);
      }
      if (++v12 == v9)
        goto LABEL_22;
    }
    v24 = 1063;
    goto LABEL_28;
  }
LABEL_22:
  if (v29 <= (int)v9)
    arkit::FaceLightOptimizer::solveQuadratic((uint64_t)v33, (uint64_t)v30, 1, a4);
  *(_DWORD *)(a3 + 32) = 0;
  *(_OWORD *)a3 = 0u;
  *(_OWORD *)(a3 + 16) = 0u;
  *(_QWORD *)(a3 + 48) = 0;
  *(_QWORD *)(a3 + 56) = 0;
  *(_QWORD *)(a3 + 40) = 0;
  *(_DWORD *)(a3 + 64) = 0;
  free(v30[0]);
  free(v33[0]);
}

void sub_1B3BA6858(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,void *a32)
{
  uint64_t v32;

  free(a20);
  free(a29);
  free(a32);
  free(*(void **)(v32 - 152));
  free(*(void **)(v32 - 128));
  _Unwind_Resume(a1);
}

void arkit::FaceLightOptimizer::solveQuadratic(uint64_t a1, uint64_t a2, int a3, float a4)
{
  int v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  char *v12;
  unsigned int v13;
  unsigned int v14;
  _DWORD *v15;
  unsigned int *v16;
  _DWORD *v17;
  _DWORD *v18;
  unsigned int v19;
  int v20;
  int *v21;
  int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unsigned int v28;
  BOOL v29;
  uint64_t v30;
  uint64_t v31;
  _DWORD *v32;
  int *v33;
  uint64_t v34;
  int v35;
  unint64_t v36;
  unsigned int v37;
  uint64_t v38;
  _DWORD *v39;
  void *v40;
  uint64_t v41;
  int v42;
  arkit *v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  uint64_t v47;
  unint64_t v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  float *v52;
  _QWORD *v53;
  int v54;
  uint64_t v55;
  float *v56;
  uint64_t v57;
  double *v58;
  float v59;
  _QWORD *v61;
  unint64_t v62;
  _QWORD *v63;
  unint64_t v64;
  uint64_t v65;
  uint64_t i;
  uint64_t j;
  uint64_t v68;
  uint64_t v69;
  int64x2_t v70;
  _QWORD *v72;
  unint64_t v73;
  const char *v74;
  int v75;
  const char *v76;
  int v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  int v83;
  arkit *v84;
  uint64_t v85;
  _QWORD *v86;
  int v87;
  double *v88;
  void **v89;
  _QWORD *v90;
  void *v91;
  uint64_t v92;
  unsigned int v93;
  void *v94;
  uint64_t v95;
  uint64_t v96;
  void *v97[2];
  int v98;
  void *v99[2];
  unsigned int v100;
  unsigned int v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  char v105[8];
  void **v106;
  void **v107;
  int v108;
  uint64_t v109;

  v109 = *MEMORY[0x1E0C80C00];
  kdebug_trace();
  v8 = *(_DWORD *)(a1 + 16);
  if (v8 != *(_DWORD *)(a2 + 16))
    arkit::FaceLightOptimizer::solveQuadratic();
  v9 = *(unsigned int *)(a2 + 20);
  v10 = v8 + 14;
  v11 = (v9 * (v8 + 14));
  v99[0] = 0;
  v99[1] = 0;
  v12 = (char *)cva::MatrixData<float,0ul,0ul,false>::allocate(v99, v11);
  v100 = v10;
  v101 = v9;
  v13 = *(_DWORD *)(a2 + 16);
  v29 = v10 >= v13;
  v14 = v10 - v13;
  if (!v29)
  {
    v74 = "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index "
          "out of bounds!\")";
    v75 = 2252;
    v76 = "matrixmixin.h";
    v12 = "assert_in_bounds";
    goto LABEL_139;
  }
  v15 = v99[0];
  if ((_DWORD)v9 != *(_DWORD *)(a2 + 20))
  {
    cva::Logger::instance((cva::Logger *)v12);
    cva::Logger::logInCategory();
    v74 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are "
          "not compatible!\")";
    v75 = 163;
    v76 = "matrixfun.h";
    v12 = "assert_equal_size";
    if (v13 != *(_DWORD *)(a2 + 16) || (_DWORD)v9 != *(_DWORD *)(a2 + 20))
LABEL_139:
      __assert_rtn(v12, v76, v75, v74);
  }
  v16 = &v100;
  if (v13 * (_DWORD)v9)
    v17 = v15;
  else
    v17 = 0;
  if (v13 * (_DWORD)v9)
    v18 = &v15[v11];
  else
    v18 = 0;
  v19 = v9;
  if (v17 != v18)
  {
    v20 = 0;
    v21 = *(int **)a2;
    do
    {
      v22 = *v21++;
      *v17 = v22;
      if (v20 + 1 >= (int)v13)
        v23 = v14;
      else
        v23 = 0;
      v17 += v23 + 1;
      if (v20 + 1 < (int)v13)
        ++v20;
      else
        v20 = 0;
    }
    while (v17 != v18);
    v19 = *(_DWORD *)(a2 + 20);
  }
  v24 = 0;
  v25 = 0;
  v26 = 4 * (int)v9;
  do
  {
    if (v19)
    {
      v27 = 0;
      do
      {
        v12 = (char *)arkit::kFLEDarkCoefficients((arkit *)v12);
        v28 = *(_DWORD *)(a2 + 16) + v25;
        v29 = v100 <= v28 || v27 >= v101;
        if (v29)
          __assert_rtn("assert_in_bounds", "matrixmixin.h", 2269, "((row < mixed().rows()) && (col < mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
        *((_DWORD *)v99[0] + v28 + v100 * (_DWORD)v27) = *(_DWORD *)&v12[4 * v27 + v24];
        ++v27;
        v19 = *(_DWORD *)(a2 + 20);
      }
      while (v19 > v27);
    }
    ++v25;
    v24 += v26;
  }
  while (v25 != 14);
  v30 = (*(_DWORD *)(a1 + 16) + 14);
  v97[0] = 0;
  v97[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v97, v30);
  v98 = v30;
  v31 = *(unsigned int *)(a1 + 16);
  if (v31 > v30)
    __assert_rtn("assert_in_bounds", "matrixmixin.h", 2252, "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
  v32 = v97[0];
  if ((_DWORD)v31)
  {
    v33 = *(int **)a1;
    v34 = 4 * v31;
    do
    {
      v35 = *v33++;
      *v32++ = v35;
      v34 -= 4;
    }
    while (v34);
    v32 = v97[0];
  }
  v36 = 0;
  v37 = v30 - v31;
  if (v30 < v31)
    v37 = 0;
  v38 = 4 * v37;
  v39 = &v32[v31];
  do
  {
    if (v38 == v36)
      __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
    v39[v36 / 4] = 0;
    v36 += 4;
  }
  while (v36 != 56);
  v94 = 0;
  v95 = 0;
  v96 = 0;
  v91 = v99;
  if (v101)
  {
    if (!v99[0])
    {
      v102 = 0;
      v103 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v102, v101 * v101);
      LODWORD(v104) = *((_DWORD *)v91 + 5);
      HIDWORD(v104) = v101;
      v106 = &v91;
      v107 = v99;
      if (*((_DWORD *)v91 + 4) != v100)
        __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      v108 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v102, (uint64_t)v105);
      v40 = v94;
      v41 = v95;
      v94 = v102;
      v95 = v103;
      v102 = v40;
      v103 = v41;
      v96 = v104;
      v104 = 0;
      free(v40);
LABEL_49:
      v91 = 0;
      v92 = 0;
      v93 = 0;
      v89 = v97;
      if (v98 != v100)
        goto LABEL_54;
      if (v101)
      {
        if (!v97[0] || !v99[0])
        {
          v102 = 0;
          v103 = 0;
          cva::MatrixData<float,0ul,0ul,false>::allocate(&v102, v101);
          LODWORD(v104) = v101;
          v106 = (void **)&v89;
          v107 = v99;
          if (*((_DWORD *)v89 + 4) != v100)
            __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
          v108 = 1065353216;
          cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v102, (uint64_t)v105);
          v46 = v91;
          v47 = v92;
          v91 = v102;
          v92 = v103;
          v102 = v46;
          v103 = v47;
          v93 = v104;
          LODWORD(v104) = 0;
          free(v46);
LABEL_59:
          v89 = 0;
          v90 = 0;
          v87 = 0;
          v88 = 0;
          v85 = 0;
          v86 = 0;
          v83 = 0;
          v84 = 0;
          v81 = 0;
          v82 = 0;
          v79 = 0;
          v80 = 0;
          v77 = 0;
          v78 = 0;
          if ((_DWORD)v9)
          {
            LODWORD(v89) = v9;
            HIDWORD(v89) = v9;
            v90 = (_QWORD *)operator new[]();
            v43 = (arkit *)operator new[]();
            *v90 = v43;
            if (v9 >= 2)
            {
              v48 = 0;
              do
              {
                v90[v48 / 8 + 1] = v90[v48 / 8] + 8 * v9;
                v48 += 8;
              }
              while (8 * v9 - 8 != v48);
            }
          }
          if ((int)v9 >= 1)
          {
            v49 = 0;
            v50 = v96;
            do
            {
              if (v49 >= v50)
LABEL_136:
                __assert_rtn("assert_in_bounds", "matrixmixin.h", 2269, "((row < mixed().rows()) && (col < mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
              v51 = 0;
              v52 = (float *)v94;
              v53 = v90;
              v54 = v49;
              do
              {
                if (v51 >= HIDWORD(v96))
                  goto LABEL_136;
                *(double *)(v53[v51++] + 8 * v49) = v52[v54];
                v54 += v50;
              }
              while (v9 != v51);
              ++v49;
            }
            while (v49 != (v9 & ~((int)v9 >> 31)));
          }
          if (v87 != (_DWORD)v9)
          {
            if (v88)
              MEMORY[0x1B5E2D5A0](v88, 0x1000C8000313F17);
            v43 = (arkit *)operator new[]();
            v88 = (double *)v43;
            v87 = v9;
          }
          if ((int)v9 >= 1)
          {
            v55 = v93;
            v56 = (float *)v91;
            v57 = v9;
            v58 = v88;
            do
            {
              if (!v55)
                __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
              v59 = *v56++;
              *v58++ = (float)-v59;
              --v55;
              --v57;
            }
            while (v57);
          }
          if ((_DWORD)v85 != (_DWORD)v9 || HIDWORD(v85) != 0)
          {
            v61 = v86;
            if (v86)
            {
              if (*v86)
              {
                MEMORY[0x1B5E2D5A0](*v86, 0x1000C8000313F17);
                v61 = v86;
              }
              MEMORY[0x1B5E2D5A0](v61, 0x80C80B8603338, v44, v45);
            }
            v85 = v9;
            v86 = (_QWORD *)operator new[]();
            v43 = (arkit *)operator new[]();
            *v86 = v43;
            if (v9 >= 2)
            {
              v62 = 0;
              do
              {
                v86[v62 / 8 + 1] = v86[v62 / 8];
                v62 += 8;
              }
              while (8 * v9 - 8 != v62);
            }
          }
          if (v83)
          {
            if (v84)
              MEMORY[0x1B5E2D5A0](v84, 0x1000C8000313F17);
            v43 = (arkit *)operator new[]();
            v84 = v43;
            v83 = 0;
          }
          if (a3)
          {
            if (v81 != (v9 | 0x6400000000))
            {
              v63 = v82;
              if (v82)
              {
                if (*v82)
                {
                  MEMORY[0x1B5E2D5A0](*v82, 0x1000C8000313F17);
                  v63 = v82;
                }
                MEMORY[0x1B5E2D5A0](v63, 0x80C80B8603338, v44, v45);
              }
              v81 = v9 | 0x6400000000;
              v82 = (_QWORD *)operator new[]();
              v43 = (arkit *)operator new[]();
              *v82 = v43;
              if (v9 >= 2)
              {
                v64 = 0;
                do
                {
                  v82[v64 / 8 + 1] = v82[v64 / 8] + 800;
                  v64 += 8;
                }
                while (8 * v9 - 8 != v64);
              }
            }
            v65 = 0;
            for (i = 0; i != 100; ++i)
            {
              if ((int)v9 >= 1)
              {
                for (j = 0; j != v9; ++j)
                {
                  v43 = (arkit *)arkit::kFLEInequalityCoefficients(v43);
                  *(double *)(v82[j] + 8 * i) = *(float *)((char *)v43 + 4 * j + v65);
                }
              }
              v65 += v26;
            }
            v68 = v80;
            if (v79 != 100)
            {
              if (v80)
                MEMORY[0x1B5E2D5A0](v80, 0x1000C8000313F17);
              v68 = operator new[]();
              v80 = v68;
              v79 = 100;
            }
            v69 = 0;
            v70 = vdupq_lane_s64(COERCE__INT64((float)-a4), 0);
            do
            {
              *(int64x2_t *)(v68 + v69) = v70;
              v69 += 16;
            }
            while (v69 != 800);
          }
          else
          {
            if ((_DWORD)v81 != (_DWORD)v9 || HIDWORD(v81) != 0)
            {
              v72 = v82;
              if (v82)
              {
                if (*v82)
                {
                  MEMORY[0x1B5E2D5A0](*v82, 0x1000C8000313F17);
                  v72 = v82;
                }
                MEMORY[0x1B5E2D5A0](v72, 0x80C80B8603338, v44, v45);
              }
              v81 = v9;
              v82 = (_QWORD *)operator new[]();
              *v82 = operator new[]();
              if (v9 >= 2)
              {
                v73 = 0;
                do
                {
                  v82[v73 / 8 + 1] = v82[v73 / 8];
                  v73 += 8;
                }
                while (8 * v9 - 8 != v73);
              }
            }
            if (v79)
            {
              if (v80)
                MEMORY[0x1B5E2D5A0](v80, 0x1000C8000313F17);
              v80 = operator new[]();
              v79 = 0;
            }
          }
          if (v77 != (_DWORD)v9)
          {
            if (v78)
              MEMORY[0x1B5E2D5A0](v78, 0x1000C8000313F17);
            v78 = operator new[]();
            v77 = v9;
          }
          thirdparty::quadprogpp::solve_quadprog((unsigned int *)&v89, (uint64_t)&v87, &v85, &v83, &v81, &v79, (uint64_t)&v77);
        }
        v93 = v101;
        cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v91, v101);
        v42 = *((_DWORD *)v89 + 4);
        v106 = (void **)&v89;
        v107 = v99;
        if (v42 != v100)
LABEL_54:
          __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      }
      else
      {
        v106 = (void **)&v89;
        v107 = v99;
      }
      v108 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v91, (uint64_t)v105);
      goto LABEL_59;
    }
    LODWORD(v96) = v101;
    HIDWORD(v96) = v101;
    cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v94, v101 * v101);
    v16 = (unsigned int *)((char *)v91 + 16);
  }
  v106 = &v91;
  v107 = v99;
  if (*v16 != v100)
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v108 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v94, (uint64_t)v105);
  goto LABEL_49;
}

void sub_1B3BA75EC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, char a20,uint64_t a21,uint64_t a22,uint64_t a23,char a24,uint64_t a25,uint64_t a26,uint64_t a27,char a28,uint64_t a29,void *a30)
{
  void **v30;

  free(v30[9]);
  free(*v30);
  free(v30[3]);
  free(v30[6]);
  _Unwind_Resume(a1);
}

void arkit::FaceLightOptimizer::inlierSet(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, unint64_t **a4@<X8>, float a5@<S0>)
{
  uint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  _QWORD *v10;
  unint64_t *v11;
  unint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  unint64_t *v18;
  unint64_t v19;
  void *v20;
  unsigned int v21;

  if (a5 < 0.0)
    arkit::FaceLightOptimizer::inlierSet();
  v7 = *(unsigned int *)(a2 + 16);
  arkit::FaceLightOptimizer::penaltyFunction(a1, a2, a3, (uint64_t)&v20);
  *a4 = 0;
  a4[1] = 0;
  a4[2] = 0;
  if ((int)v7 >= 1)
  {
    v8 = 0;
    v9 = 0;
    v10 = a4 + 2;
    do
    {
      if (v9 >= v21)
        __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
      if (*((float *)v20 + v9) < a5)
      {
        if ((unint64_t)v8 >= *v10)
        {
          v12 = *a4;
          v13 = v8 - *a4;
          v14 = v13 + 1;
          if ((unint64_t)(v13 + 1) >> 61)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v15 = *v10 - (_QWORD)v12;
          if (v15 >> 2 > v14)
            v14 = v15 >> 2;
          if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8)
            v16 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v16 = v14;
          if (v16)
          {
            v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a4 + 2), v16);
            v12 = *a4;
            v8 = a4[1];
          }
          else
          {
            v17 = 0;
          }
          v18 = (unint64_t *)&v17[8 * v13];
          *v18 = v9;
          v11 = v18 + 1;
          while (v8 != v12)
          {
            v19 = *--v8;
            *--v18 = v19;
          }
          *a4 = v18;
          a4[1] = v11;
          a4[2] = (unint64_t *)&v17[8 * v16];
          if (v12)
            operator delete(v12);
        }
        else
        {
          *v8 = v9;
          v11 = v8 + 1;
        }
        a4[1] = v11;
        v8 = v11;
      }
      ++v9;
    }
    while (v9 != v7);
  }
  free(v20);
}

void sub_1B3BA78B0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  uint64_t v10;
  void *v12;

  v12 = *(void **)v10;
  if (*(_QWORD *)v10)
  {
    *(_QWORD *)(v10 + 8) = v12;
    operator delete(v12);
  }
  free(a10);
  _Unwind_Resume(a1);
}

float arkit::FaceLightOptimizer::computeConfidence(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float v3;
  uint64_t v4;
  float *v5;
  float v6;
  float v7;
  void *v9;
  unsigned int v10;

  arkit::FaceLightOptimizer::penaltyFunction(a1, a2, a3, (uint64_t)&v9);
  v3 = 0.0;
  if (v10)
  {
    v4 = v10;
    v5 = (float *)v9;
    do
    {
      v6 = *v5++;
      v3 = v3 + (float)(v6 * v6);
      --v4;
    }
    while (v4);
  }
  v7 = 1.0 / (float)((float)(v3 / (float)v10) + 1.0);
  free(v9);
  return v7;
}

void arkit::FaceLightOptimizer::solveLinear(uint64_t a1@<X0>, _DWORD *a2@<X1>, int a3@<W2>, uint64_t a4@<X8>)
{
  uint64_t v8;
  int v9;
  void *v10;
  uint64_t v11;
  float v12;
  uint64_t v13;
  char *v14;
  void *v15[2];
  __int128 v16;
  int v17;
  void *v18;
  void *v19[2];
  unsigned int v20;
  int v21;
  void *v22;
  uint64_t v23;
  unsigned int v24;
  unsigned int v25;
  void *v26;
  uint64_t v27;
  unsigned int v28;
  float v29;
  void **v30;
  uint64_t v31;
  int v32;
  uint64_t v33;

  v33 = *MEMORY[0x1E0C80C00];
  if (*(_DWORD *)(a1 + 16) != a2[4])
    arkit::FaceLightOptimizer::solveLinear();
  v25 = 869711765;
  v8 = a2[5];
  v22 = 0;
  v23 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(&v22, v8);
  v24 = v8;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::SVD<cva::Matrix<float,0u,0u,false>>((uint64_t)v15, a2, 3, 0);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v15, &v25, (uint64_t)v19);
  if (v21 != *(_DWORD *)(a1 + 16))
    goto LABEL_18;
  if (v20 == v24)
  {
    v30 = v19;
    v31 = a1;
LABEL_8:
    v32 = 1065353216;
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>((uint64_t)&v22, (uint64_t)&v29);
    goto LABEL_11;
  }
  if (v19[0] != v22 && *(void **)a1 != v22)
  {
    v24 = v20;
    cva::MatrixData<float,0ul,0ul,false>::reserve((uint64_t)&v22, v20);
    v9 = *(_DWORD *)(a1 + 16);
    v30 = v19;
    v31 = a1;
    if (v21 == v9)
      goto LABEL_8;
LABEL_18:
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  v26 = 0;
  v27 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(&v26, v20);
  v28 = v20;
  v30 = v19;
  v31 = a1;
  if (v21 != *(_DWORD *)(a1 + 16))
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v32 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>((uint64_t)&v26, (uint64_t)&v29);
  v10 = v22;
  v11 = v23;
  v22 = v26;
  v23 = v27;
  v26 = v10;
  v27 = v11;
  v24 = v28;
  v28 = 0;
  free(v10);
LABEL_11:
  free(v19[0]);
  free(v18);
  free(*((void **)&v16 + 1));
  free(v15[0]);
  v12 = 0.0;
  if (a3)
  {
    *(_OWORD *)v15 = 0u;
    v16 = 0u;
    v17 = 0;
    if (v24 != 9)
      __assert_rtn("MatrixData", "matrixdata.h", 96, "(size == sz) || cva::detail::assertMessage(\"Matrix data size mismatch.\")");
    v13 = 0;
    v14 = (char *)v22;
    do
    {
      *(_DWORD *)((char *)v15 + v13) = *(_DWORD *)&v14[v13];
      v13 += 4;
    }
    while (v13 != 36);
    v12 = arkit::FaceLightOptimizer::computeConfidence((uint64_t)v15, a1, (uint64_t)a2);
  }
  v29 = v12;
  std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>(a4, (uint64_t *)&v22, &v29);
  free(v22);
}

void sub_1B3BA7BEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,void *a23)
{
  uint64_t v23;

  free(*(void **)(v23 - 112));
  free(a20);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::~SVD((void **)&a9);
  free(a23);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(_DWORD *a1@<X0>, unsigned int *a2@<X1>, uint64_t a3@<X8>)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  _DWORD *v12;
  _QWORD v13[2];
  _QWORD v14[2];
  _DWORD *v15;
  _QWORD v16[2];
  _BYTE v17[8];
  _QWORD *v18;
  _QWORD *v19;
  int v20;
  uint64_t v21;

  v21 = *MEMORY[0x1E0C80C00];
  v15 = a1 + 6;
  v6 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S(a1);
  v13[0] = v6;
  v13[1] = v7;
  v9 = *a2;
  v14[0] = v13;
  v14[1] = v9;
  if (a1[10] != HIDWORD(v6))
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v6, v7, v8);
  v16[0] = &v15;
  v16[1] = v14;
  v12 = a1;
  if (a1[5] != (_DWORD)v6)
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v6, v7, v8);
  v10 = (a1[4] * a1[11]);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a3, v10);
  v11 = a1[4];
  *(_DWORD *)(a3 + 16) = v15[5];
  *(_DWORD *)(a3 + 20) = v11;
  v18 = v16;
  v19 = &v12;
  if (*(_DWORD *)v14[0] != a1[5])
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v20 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(a3, (uint64_t)v17);
}

void sub_1B3BA7D7C(_Unwind_Exception *a1)
{
  void **v1;

  free(*v1);
  _Unwind_Resume(a1);
}

void **cva::SVD<cva::Matrix<float,0u,0u,false>,true>::~SVD(void **a1)
{
  free(a1[6]);
  free(a1[3]);
  free(*a1);
  return a1;
}

void arkit::FaceLightOptimizer::penaltyFunction(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X8>)
{
  unint64_t v6;
  uint64_t v9;
  int v10;
  cva::Logger *v11;
  unsigned int v12;
  float *v13;
  uint64_t v14;
  float *v15;
  float *v16;
  uint64_t v17;
  float v18;
  float v19;
  float v20;
  cva::Logger *v21;
  unsigned int v22;
  float *v23;
  float *v24;
  float *v25;
  uint64_t v26;
  float *v27;
  float v28;
  float v29;
  float v30;
  float *v31;
  uint64_t v32;
  uint64_t v33;
  void *v34[2];
  unsigned int v35;
  float *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  uint64_t v40;

  v40 = *MEMORY[0x1E0C80C00];
  v6 = *(unsigned int *)(a2 + 16);
  if ((_DWORD)v6 != *(_DWORD *)(a3 + 16))
    arkit::FaceLightOptimizer::penaltyFunction();
  *(_QWORD *)a4 = 0;
  *(_QWORD *)(a4 + 8) = 0;
  *(_DWORD *)(a4 + 16) = v6;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a4, v6);
  if (*(_DWORD *)(a3 + 20) != 9)
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v9 = *(unsigned int *)(a3 + 16);
  v34[0] = 0;
  v34[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v34, v9);
  v10 = *(_DWORD *)(a3 + 20);
  v35 = *(_DWORD *)(a3 + 16);
  v37 = a3;
  v38 = a1;
  if (v10 != 9)
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v39 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>((uint64_t)v34, (uint64_t)&v36);
  v12 = v35;
  if (v35 != *(_DWORD *)(a2 + 16))
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
    v12 = v35;
    if (v35 != *(_DWORD *)(a2 + 16))
      __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  }
  if (v12 == *(_DWORD *)(a4 + 16))
    goto LABEL_7;
  if (v34[0] != *(void **)a4 && *(_QWORD *)a2 != *(_QWORD *)a4)
  {
    *(_DWORD *)(a4 + 16) = v12;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a4, v12);
    v12 = v35;
    if (*(_DWORD *)(a4 + 16) != v35)
    {
      cva::Logger::instance(v21);
      cva::Logger::logInCategory();
      v12 = *(_DWORD *)(a4 + 16);
      if (v12 != v35)
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
LABEL_7:
    if (v12)
    {
      v13 = *(float **)a4;
      v14 = v12;
      v15 = *(float **)a2;
      v16 = (float *)v34[0];
      v17 = 4 * v14;
      do
      {
        v18 = *v16++;
        v19 = v18;
        v20 = *v15++;
        *v13++ = (float)(v19 - v20) / (float)(v20 + 0.01);
        v17 -= 4;
      }
      while (v17);
    }
    goto LABEL_20;
  }
  v36 = 0;
  v37 = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate((void **)&v36, v12);
  v22 = v35;
  v23 = v36;
  if (v35)
  {
    v24 = *(float **)a2;
    v25 = (float *)v34[0];
    v26 = 4 * v35;
    v27 = v36;
    do
    {
      v28 = *v25++;
      v29 = v28;
      v30 = *v24++;
      *v27++ = (float)(v29 - v30) / (float)(v30 + 0.01);
      v26 -= 4;
    }
    while (v26);
  }
  v31 = *(float **)a4;
  v32 = *(_QWORD *)(a4 + 8);
  v33 = v37;
  *(_QWORD *)a4 = v23;
  *(_QWORD *)(a4 + 8) = v33;
  v36 = v31;
  v37 = v32;
  *(_DWORD *)(a4 + 16) = v22;
  LODWORD(v38) = 0;
  free(v31);
LABEL_20:
  free(v34[0]);
}

void sub_1B3BA80C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  void **v13;

  free(a13);
  free(*v13);
  _Unwind_Resume(a1);
}

float std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>(uint64_t a1, uint64_t *a2, float *a3)
{
  int v3;
  uint64_t v4;
  uint64_t v5;
  float result;

  v3 = *((_DWORD *)a2 + 4);
  *(_DWORD *)(a1 + 32) = 0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  if (v3 != 9)
    std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>();
  if (*((_DWORD *)a2 + 4) != 9)
    std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>();
  v4 = 0;
  v5 = *a2;
  do
  {
    *(_DWORD *)(a1 + v4) = *(_DWORD *)(v5 + v4);
    v4 += 4;
  }
  while (v4 != 36);
  result = *a3;
  *(float *)(a1 + 36) = *a3;
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = **(_QWORD **)(a2 + 8);
  if (*(_QWORD *)v5 == *(_QWORD *)a1 || *(_QWORD *)v4 == *(_QWORD *)a1)
  {
    v10 = (*(_DWORD *)(v4 + 20) * *(_DWORD *)(v5 + 20));
    v15 = 0;
    v16 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v15, v10);
    v11 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 20);
    LODWORD(v17) = *(_DWORD *)(**(_QWORD **)(a2 + 8) + 20);
    HIDWORD(v17) = v11;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(&v15, a2);
    v12 = *(void **)a1;
    v13 = *(_QWORD *)(a1 + 8);
    v14 = v16;
    *(_QWORD *)a1 = v15;
    *(_QWORD *)(a1 + 8) = v14;
    v15 = v12;
    v16 = v13;
    *(_QWORD *)(a1 + 16) = v17;
    v17 = 0;
    free(v12);
  }
  else
  {
    LODWORD(v6) = *(_DWORD *)(a1 + 16);
    if ((_DWORD)v6 != *(_DWORD *)(v5 + 20) || (v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 20)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      v8 = cva::Logger::logInCategory();
      v6 = *(unsigned int *)(a1 + 16);
      v5 = **(_QWORD **)(a2 + 8);
      if ((_DWORD)v6 != *(_DWORD *)(v5 + 20)
        || (v4 = *(_QWORD *)(a2 + 16), v7 = *(_DWORD *)(v4 + 20), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v8, v9, v6);
      }
    }
    if (*(_DWORD *)(v5 + 16) * (_DWORD)v6 && v7 * *(_DWORD *)(v4 + 16))
    {
      cva::VecLib<float>::gemm();
    }
    else if ((_DWORD)v6 * v7)
    {
      bzero(*(void **)a1, 4 * (v6 * v7));
    }
  }
}

void sub_1B3BA82FC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  int v16;

  v4 = *(_QWORD *)(a2 + 16);
  v5 = **(_QWORD **)(a2 + 8);
  if (*(_QWORD *)v5 == *(_QWORD *)a1 || *(_QWORD *)v4 == *(_QWORD *)a1)
  {
    v10 = *(unsigned int *)(v4 + 20);
    v14 = 0;
    v15 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v14, v10);
    v16 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 20);
    cva::assign<false,false,cva::Matrix<float,1u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,1u,false> const>,cva::Matrix<float,0u,0u,false>>(&v14, a2);
    v11 = *(void **)a1;
    v12 = *(_QWORD *)(a1 + 8);
    v13 = v15;
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v13;
    v14 = v11;
    v15 = v12;
    *(_DWORD *)(a1 + 16) = v16;
    v16 = 0;
    free(v11);
  }
  else
  {
    v6 = *(_DWORD *)(a1 + 16);
    if (v6 != *(_DWORD *)(v4 + 20))
    {
      cva::Logger::instance((cva::Logger *)a1);
      v7 = cva::Logger::logInCategory();
      v6 = *(_DWORD *)(a1 + 16);
      v4 = *(_QWORD *)(a2 + 16);
      if (v6 != *(_DWORD *)(v4 + 20))
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v7, v8, v9);
      v5 = **(_QWORD **)(a2 + 8);
    }
    if (*(_DWORD *)(v5 + 16) && v6 * *(_DWORD *)(v4 + 16))
    {
      cva::VecLib<float>::gemm();
    }
    else if (v6)
    {
      bzero(*(void **)a1, 4 * v6);
    }
  }
}

void sub_1B3BA8478(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

uint64_t thirdparty::quadprogpp::Matrix<double>::~Matrix(uint64_t a1)
{
  _QWORD *v2;

  v2 = *(_QWORD **)(a1 + 8);
  if (v2)
  {
    if (!*v2 || (MEMORY[0x1B5E2D5A0](*v2, 0x1000C8000313F17), *(_QWORD *)(a1 + 8)))
      MEMORY[0x1B5E2D5A0]();
  }
  return a1;
}

uint64_t cva::SVD<cva::Matrix<float,0u,0u,false>,true>::SVD<cva::Matrix<float,0u,0u,false>>(uint64_t a1, _DWORD *a2, char a3, int a4)
{
  *(_DWORD *)(a1 + 64) = 0;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_QWORD *)(a1 + 72) = 0;
  *(_BYTE *)(a1 + 80) = 0;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decompose<cva::Matrix<float,0u,0u,false> const&>(a1, a2, a3, a4);
  return a1;
}

void sub_1B3BA852C(_Unwind_Exception *a1)
{
  void **v1;

  free(v1[6]);
  free(v1[3]);
  free(*v1);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decompose<cva::Matrix<float,0u,0u,false> const&>(uint64_t a1, _DWORD *a2, char a3, int a4)
{
  int v5;
  int v6;
  void *v7;
  void *v8;
  void *v9;

  v5 = a2[4];
  v6 = a2[5];
  *(_DWORD *)(a1 + 72) = v5;
  *(_DWORD *)(a1 + 76) = v6;
  if (!(v5 | v6))
  {
    *(_BYTE *)(a1 + 80) = 1;
LABEL_8:
    v7 = *(void **)(a1 + 48);
    *(_DWORD *)(a1 + 64) = 0;
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    free(v7);
    v8 = *(void **)a1;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    free(v8);
    v9 = *(void **)(a1 + 24);
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 24) = 0;
    free(v9);
    return;
  }
  if (a4 && fabsf((float)(v5 - v6)) >= (float)((float)(v6 + v5) * 0.1))
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeRectangular<cva::Matrix<float,0u,0u,false>>(a1, a2, a3);
  else
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::Matrix<float,0u,0u,false>>(a1, (uint64_t)a2, a3);
  if (!*(_BYTE *)(a1 + 80))
    goto LABEL_8;
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  void *__dst[3];

  v6 = (*(_DWORD *)(a2 + 20) * *(_DWORD *)(a2 + 16));
  __dst[0] = 0;
  __dst[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(__dst, v6);
  if ((_DWORD)v6)
    memcpy(__dst[0], *(const void **)a2, 4 * v6);
  __dst[2] = *(void **)(a2 + 16);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)__dst, a3);
  free(__dst[0]);
}

void sub_1B3BA8688(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10)
{
  free(a10);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeRectangular<cva::Matrix<float,0u,0u,false>>(uint64_t a1, _DWORD *a2, int a3)
{
  char v3;
  uint64_t v6;
  float *v7;
  uint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  float *v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t *v19;
  int v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  int v34;
  int v35;
  void *v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t *v48;
  uint64_t *v49;
  void *v50;
  uint64_t v51;
  uint64_t v52;
  void **v53;
  void **v54;
  uint64_t **v55;
  int v56;
  uint64_t v57;

  v3 = a3;
  v57 = *MEMORY[0x1E0C80C00];
  if (a2[5] >= a2[4])
  {
    v50 = a2;
    v53 = (void **)a2;
    v54 = &v50;
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>>(a1, &v53, a3 != 0);
    if (!*(_BYTE *)(a1 + 80))
      return;
    v13 = *(unsigned int *)(a1 + 64);
    if ((_DWORD)v13)
    {
      v14 = *(float **)(a1 + 48);
      v15 = 4 * v13;
      do
      {
        *v14 = sqrtf(*v14);
        ++v14;
        v15 -= 4;
      }
      while (v15);
    }
    if ((v3 & 2) == 0)
      return;
    v16 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S((_DWORD *)a1);
    v43 = v16;
    v44 = v17;
    v45 = &v43;
    v46 = 925353388;
    v47 = a1;
    if (*(_DWORD *)(a1 + 20) != (_DWORD)v16)
      cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v16, (uint64_t)v17, v18);
    v48 = (uint64_t *)&v45;
    v49 = &v47;
    if (*(_DWORD *)(a1 + 16) != a2[4])
      cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v16, (uint64_t)v17, v18);
    v19 = (uint64_t *)(a1 + 24);
    v20 = HIDWORD(v43);
    if (__PAIR64__(a2[5], HIDWORD(v43)) == *(_QWORD *)(a1 + 40))
    {
      v54 = (void **)&v48;
      v55 = (uint64_t **)a2;
LABEL_30:
      v56 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(a1 + 24, (uint64_t)&v53);
      return;
    }
    v27 = *v19;
    if (*v17 == *v19)
    {
      v28 = a2[5];
    }
    else
    {
      v28 = a2[5];
      if (*(_QWORD *)a1 != v27 && *(_QWORD *)a2 != v27)
      {
        *(_DWORD *)(a1 + 40) = HIDWORD(v43);
        *(_DWORD *)(a1 + 44) = v28;
        cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 24, (v28 * v20));
        v32 = a2[4];
        v33 = *(_DWORD *)(*v49 + 16);
        v54 = (void **)&v48;
        v55 = (uint64_t **)a2;
        if (v33 != v32)
          cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v29, v30, v31);
        goto LABEL_30;
      }
    }
    v50 = 0;
    v51 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v50, (v28 * HIDWORD(v43)));
    v40 = a2[4];
    v39 = a2[5];
    LODWORD(v52) = *(_DWORD *)(*v48 + 4);
    HIDWORD(v52) = v39;
    v54 = (void **)&v48;
    v55 = (uint64_t **)a2;
    if (*(_DWORD *)(*v49 + 16) != v40)
      __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    v56 = 1065353216;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>((uint64_t)&v50, (uint64_t)&v53);
    v36 = *(void **)(a1 + 24);
    v41 = *(_QWORD *)(a1 + 32);
    v42 = v51;
    *(_QWORD *)(a1 + 24) = v50;
    *(_QWORD *)(a1 + 32) = v42;
    v50 = v36;
    v51 = v41;
    *(_QWORD *)(a1 + 40) = v52;
LABEL_36:
    v52 = 0;
    free(v36);
    return;
  }
  v50 = a2;
  v53 = &v50;
  v54 = (void **)a2;
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>>(a1, (uint64_t **)&v53, 2 * (a3 != 0));
  if (*(_BYTE *)(a1 + 80))
  {
    v6 = *(unsigned int *)(a1 + 64);
    if ((_DWORD)v6)
    {
      v7 = *(float **)(a1 + 48);
      v8 = 4 * v6;
      do
      {
        *v7 = sqrtf(*v7);
        ++v7;
        v8 -= 4;
      }
      while (v8);
    }
    if ((v3 & 1) != 0)
    {
      v47 = a1 + 24;
      v9 = cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S((_DWORD *)a1);
      v43 = v9;
      v44 = v10;
      v45 = &v43;
      v46 = 925353388;
      if (*(_DWORD *)(a1 + 40) != HIDWORD(v9))
        cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v9, (uint64_t)v10, v11);
      v48 = &v47;
      v49 = (uint64_t *)&v45;
      if (a2[5] != *(_DWORD *)(a1 + 44))
        cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v9, (uint64_t)v10, v11);
      v12 = a2[4];
      if (v12 == *(_DWORD *)(a1 + 16) && *(_DWORD *)(a1 + 20) == (_DWORD)v9)
      {
        v54 = (void **)a2;
        v55 = &v48;
LABEL_25:
        v56 = 1065353216;
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(a1, (uint64_t)&v53);
        return;
      }
      v21 = *(void **)a1;
      if (*(_QWORD *)a2 != *(_QWORD *)a1 && *(void **)(a1 + 24) != v21 && (void *)*v10 != v21)
      {
        *(_DWORD *)(a1 + 16) = v12;
        *(_DWORD *)(a1 + 20) = v9;
        cva::MatrixData<float,0ul,0ul,false>::reserve(a1, (v12 * v9));
        v25 = a2[5];
        v26 = *(_DWORD *)(*v48 + 20);
        v54 = (void **)a2;
        v55 = &v48;
        if (v25 != v26)
          cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(v22, v23, v24);
        goto LABEL_25;
      }
      v50 = 0;
      v51 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v50, (v12 * v9));
      v34 = *(_DWORD *)*v49;
      v35 = a2[5];
      LODWORD(v52) = a2[4];
      HIDWORD(v52) = v34;
      v54 = (void **)a2;
      v55 = &v48;
      if (v35 != *(_DWORD *)(*v48 + 20))
        __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      v56 = 1065353216;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>((uint64_t)&v50, (uint64_t)&v53);
      v36 = *(void **)a1;
      v37 = *(_QWORD *)(a1 + 8);
      v38 = v51;
      *(_QWORD *)a1 = v50;
      *(_QWORD *)(a1 + 8) = v38;
      v50 = v36;
      v51 = v37;
      *(_QWORD *)(a1 + 16) = v52;
      goto LABEL_36;
    }
  }
}

void sub_1B3BA8AD8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  free(a17);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v5;
  unsigned int v6;
  unint64_t v7;
  void *v8;
  void **v9;
  void *v10;
  cva::Logger *v11;
  void *v12[2];
  unsigned int v13;
  int v14;
  int v15;

  v6 = *(_DWORD *)(a2 + 16);
  v5 = *(_DWORD *)(a2 + 20);
  if ((int)v5 >= (int)v6)
    v7 = v6;
  else
    v7 = v5;
  *(_DWORD *)(a1 + 64) = v7;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 48, v7);
  if ((a3 & 1) != 0)
  {
    *(_DWORD *)(a1 + 16) = v6;
    *(_DWORD *)(a1 + 20) = v7;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a1, v7 * v6);
  }
  else
  {
    v8 = *(void **)a1;
    *(_QWORD *)(a1 + 8) = 0;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)a1 = 0;
    free(v8);
  }
  v9 = (void **)(a1 + 24);
  if ((a3 & 2) != 0)
  {
    *(_DWORD *)(a1 + 40) = v7;
    *(_DWORD *)(a1 + 44) = v5;
    cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 24, v7 * v5);
  }
  else
  {
    v10 = *v9;
    *(_QWORD *)(a1 + 32) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *v9 = 0;
    free(v10);
  }
  v15 = 0;
  v14 = 0;
  cva::vecLib::gesvd<float>();
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, 0.0);
  v13 = 0.0;
  v11 = (cva::Logger *)cva::vecLib::gesvd<float>();
  if (v14 < 0)
    __assert_rtn("decomposeDirect", "matrixsvd.h", 439, "(info >= 0) || cva::detail::assertMessage(\"gesvd() compute SVD failed!\")");
  if (v14)
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
  }
  free(v12[0]);
  *(_BYTE *)(a1 + 80) = v14 == 0;
}

void sub_1B3BA8D5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  free(a17);
  _Unwind_Resume(a1);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>>(uint64_t a1, uint64_t **a2, char a3)
{
  _QWORD **v6;
  uint64_t v7;
  uint64_t *v8;
  uint64_t v9;
  _DWORD *v10;
  int v11;
  void *v12[2];
  int v13;
  int v14;
  char v15[8];
  uint64_t *v16;
  _DWORD *v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = a2 + 1;
  v7 = (*((_DWORD *)a2[1] + 5) * *(_DWORD *)(**a2 + 20));
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, v7);
  v8 = *a2;
  v9 = **a2;
  v10 = *v6;
  v11 = *((_DWORD *)*v6 + 5);
  v13 = *(_DWORD *)(v9 + 20);
  v14 = v11;
  v16 = v8;
  v17 = v10;
  if (*(_DWORD *)(v9 + 16) != v10[4])
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v18 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)v12, (uint64_t)v15);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)v12, a3);
  free(v12[0]);
}

void sub_1B3BA8E74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  free(a9);
  _Unwind_Resume(a1);
}

uint64_t cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S(_DWORD *a1)
{
  uint64_t v1;
  unsigned int v2;

  v2 = a1[18];
  LODWORD(v1) = a1[19];
  if (v1 >= v2)
    v1 = v2;
  else
    v1 = v1;
  if (v1 > a1[16])
    cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S();
  return v1 | (v1 << 32);
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<cva::MatrixMultExpr<cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>>(uint64_t a1, _QWORD **a2, char a3)
{
  uint64_t **v6;
  uint64_t v7;
  _DWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  void *v12[2];
  int v13;
  int v14;
  char v15[8];
  _DWORD *v16;
  uint64_t *v17;
  int v18;
  uint64_t v19;

  v19 = *MEMORY[0x1E0C80C00];
  v6 = a2 + 1;
  v7 = (*(_DWORD *)(*a2[1] + 16) * *((_DWORD *)*a2 + 4));
  v12[0] = 0;
  v12[1] = 0;
  cva::MatrixData<float,0ul,0ul,false>::allocate(v12, v7);
  v8 = *a2;
  v9 = *v6;
  v10 = **v6;
  v11 = *(_DWORD *)(v10 + 16);
  v13 = *((_DWORD *)*a2 + 4);
  v14 = v11;
  v16 = v8;
  v17 = v9;
  if (v8[5] != *(_DWORD *)(v10 + 20))
    __assert_rtn("MatrixMultExpr", "matrixmultexpr.h", 100, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v18 = 1065353216;
  cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>((uint64_t)v12, (uint64_t)v15);
  cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>(a1, (uint64_t)v12, a3);
  free(v12[0]);
}

void sub_1B3BA8FCC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9)
{
  free(a9);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  int v6;
  _DWORD ***v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;

  v4 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)v4 == *(_QWORD *)a1)
  {
    v16 = (***(_DWORD ***)(*(_QWORD *)(a2 + 16) + 8) * *(_DWORD *)(v4 + 16));
    v20 = 0;
    v21 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v16);
    v17 = ***(_DWORD ***)(*(_QWORD *)(a2 + 16) + 8);
    LODWORD(v22) = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 16);
    HIDWORD(v22) = v17;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>>(&v20, a2);
    v14 = *(void **)a1;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = v21;
    *(_QWORD *)a1 = v20;
    *(_QWORD *)(a1 + 8) = v19;
    v20 = v14;
    v21 = v18;
    *(_QWORD *)(a1 + 16) = v22;
    v22 = 0;
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(a1 + 16);
  if (v5 != *(_DWORD *)(v4 + 16) || (v6 = *(_DWORD *)(a1 + 20), v7 = *(_DWORD ****)(a2 + 16), v6 != **v7[1]))
  {
    cva::Logger::instance((cva::Logger *)a1);
    v8 = cva::Logger::logInCategory();
    v5 = *(_DWORD *)(a1 + 16);
    v4 = *(_QWORD *)(a2 + 8);
    if (v5 != *(_DWORD *)(v4 + 16) || (v7 = *(_DWORD ****)(a2 + 16), v6 = **v7[1], *(_DWORD *)(a1 + 20) != v6))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v8, v9, v10);
  }
  if (*(_DWORD *)(v4 + 20) * v5)
  {
    v11 = (v6 * (**v7)[5]);
    if ((_DWORD)v11)
    {
      v20 = 0;
      v21 = 0;
      cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v11);
      v12 = **v7[1];
      LODWORD(v22) = (**v7)[5];
      HIDWORD(v22) = v12;
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((cva::Logger *)&v20, (uint64_t)v7, v13);
      cva::VecLib<float>::gemm();
      v14 = v20;
LABEL_12:
      free(v14);
      return;
    }
  }
  v15 = v5 * v6;
  if (v15)
    bzero(*(void **)a1, 4 * v15);
}

void sub_1B3BA9200(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>(cva::Logger *a1, uint64_t a2, uint64_t a3)
{
  cva::Logger *v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int **v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22[2];
  uint64_t v23;
  int v24;
  int v25;
  unsigned int ***v26;
  char v27;
  int v28;
  unsigned int v29;
  unsigned int ****v30;
  _DWORD v31[2];
  uint64_t *v32;
  uint64_t v33;
  _QWORD v34[3];
  unsigned int **v35;

  v4 = a1;
  v5 = *((_DWORD *)a1 + 4);
  v6 = *(uint64_t **)a2;
  v7 = **(_QWORD **)a2;
  if (v5 != *(_DWORD *)(v7 + 20) || (v8 = *((_DWORD *)a1 + 5), v9 = *(unsigned int ***)(a2 + 8), v10 = *v9, v8 != **v9))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *((_DWORD *)v4 + 4);
    v6 = *(uint64_t **)a2;
    v7 = **(_QWORD **)a2;
    if (v5 != *(_DWORD *)(v7 + 20)
      || (v9 = *(unsigned int ***)(a2 + 8), v10 = *v9, v8 = **v9, *((_DWORD *)v4 + 5) != v8))
    {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, a2, a3);
    }
  }
  v35 = v9;
  if (v8 >= v10[1])
    v8 = v10[1];
  if (v8 > *(_DWORD *)(v7 + 16))
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((uint64_t)a1, a2, a3);
  v31[0] = v5;
  v31[1] = v8;
  v32 = v6;
  v33 = 0;
  v26 = &v35;
  v28 = v5;
  v29 = v8;
  v30 = &v26;
  v34[0] = v31;
  v34[1] = &v27;
  v11 = *(_QWORD *)v4;
  v22[0] = v5;
  v22[1] = v8;
  v23 = v11;
  v24 = v5;
  v25 = 0;
  cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(v22, v34, a3);
  v12 = *(_DWORD *)(*v6 + 16);
  v13 = *((_DWORD *)v4 + 5);
  v14 = v13 >= v12;
  v15 = v13 - v12;
  if (v15 != 0 && v14)
  {
    v16 = *((_DWORD *)v4 + 4);
    v17 = *(_QWORD *)v4 + 4 * v16 * v12;
    v18 = v16 * v15;
    v19 = v18 == 0;
    if (v18)
      v20 = (_BYTE *)v17;
    else
      v20 = 0;
    v21 = (_BYTE *)(v17 + 4 * v18);
    if (v19)
      v21 = 0;
    if (v20 != v21)
      bzero(v20, ((v21 - v20 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
}

int *cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(int *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  cva::Logger *v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  _DWORD *v14;
  uint64_t v15;
  void *v16;
  int v17;
  unsigned int v18;
  int *v19;
  int v20;
  unsigned int v21;
  void *v23[2];
  int v24;
  int v25;

  v5 = *((_QWORD *)a1 + 1) - 4 * a1[5];
  if (***(_QWORD ***)(*a2 + 8) == v5 || **(_QWORD **)(****(_QWORD ****)(a2[1] + 16) + 8) == v5)
  {
    v6 = *a1;
    v7 = a1[1];
    v23[0] = 0;
    v23[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v23, (v7 * v6));
    v24 = v6;
    v25 = v7;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)v23, a2, v8);
    v10 = *a1;
    if (*a1 != v24 || (v11 = a1[1], v11 != v25))
    {
      cva::Logger::instance(v9);
      cva::Logger::logInCategory();
      v10 = *a1;
      if (*a1 != v24 || (v11 = a1[1], v11 != v25))
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
    v12 = a1[4];
    v13 = v10 * v11 == 0;
    if (v10 * v11)
      v14 = (_DWORD *)*((_QWORD *)a1 + 1);
    else
      v14 = 0;
    v15 = *((_QWORD *)a1 + 1) + 4 * (v12 * v11);
    if (v13)
      v15 = 0;
    v16 = v23[0];
    if (v14 != (_DWORD *)v15)
    {
      v17 = 0;
      v18 = v12 - v10;
      v19 = (int *)v23[0];
      do
      {
        v20 = *v19++;
        *v14 = v20;
        if (v17 + 1 >= v10)
          v21 = v18;
        else
          v21 = 0;
        v14 += v21 + 1;
        if (v17 + 1 < v10)
          ++v17;
        else
          v17 = 0;
      }
      while (v14 != (_DWORD *)v15);
    }
    free(v16);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)a1, a2, a3);
  }
  return a1;
}

void sub_1B3BA9550(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(cva::Logger *a1, _QWORD *a2, uint64_t a3)
{
  cva::Logger *v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  float v18;
  uint64_t v19;
  uint64_t v20;

  v4 = a1;
  v5 = *((_DWORD *)a1 + 4);
  v6 = (_DWORD *)*a2;
  if (v5 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)a1 + 5), v7 != v6[1]))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *((_DWORD *)v4 + 4);
    v6 = (_DWORD *)*a2;
    if (v5 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)v4 + 5), v7 != v6[1]))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, (uint64_t)a2, a3);
  }
  v8 = v7 * v5;
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = 0;
    v11 = a2[1];
    v12 = *(float **)v4;
    v13 = 4 * v8;
    do
    {
      if (v5 <= v10 || v6[1] <= HIDWORD(v10))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v14 = v6[5] + HIDWORD(v10);
      v15 = **((_QWORD **)v6 + 1);
      v16 = *(_DWORD *)(v15 + 16);
      if (v16 <= v14 || (v17 = v6[4] + v10, v17 >= *(_DWORD *)(v15 + 20)))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v18 = *(float *)(*(_QWORD *)v15 + 4 * (v14 + v16 * v17));
      *v12++ = v18
             * cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(v11, v9, HIDWORD(v9));
      v19 = (v10 + 1);
      v5 = *v6;
      if (*v6 <= (int)v19)
        v10 = (v10 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v10 = v10 & 0xFFFFFFFF00000000 | v19;
      v20 = (v9 + 1);
      if (*(_DWORD *)(v11 + 4) <= (int)v20)
        v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v9 = v9 & 0xFFFFFFFF00000000 | v20;
      v13 -= 4;
    }
    while (v13);
  }
}

void cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(cva::Logger *a1, _QWORD *a2, uint64_t a3)
{
  cva::Logger *v4;
  signed int v5;
  _DWORD *v6;
  int v7;
  int v8;
  int v9;
  float *v10;
  uint64_t v11;
  float *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;

  v4 = a1;
  v5 = *(_DWORD *)a1;
  v6 = (_DWORD *)*a2;
  if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)a1 + 1), v7 != v6[1]))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *(_DWORD *)v4;
    v6 = (_DWORD *)*a2;
    if (*(_DWORD *)v4 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)v4 + 1), v7 != v6[1]))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, (uint64_t)a2, a3);
  }
  v8 = v7 * v5;
  v9 = *((_DWORD *)v4 + 4);
  if (v7 * v5)
    v10 = (float *)*((_QWORD *)v4 + 1);
  else
    v10 = 0;
  v11 = *((_QWORD *)v4 + 1) + 4 * (v9 * v7);
  if (v8)
    v12 = (float *)v11;
  else
    v12 = 0;
  if (v10 != v12)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = a2[1];
    v17 = v9 - v5;
    v18 = v5;
    do
    {
      if (v18 <= v14 || v6[1] <= HIDWORD(v14))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v19 = v6[5] + HIDWORD(v14);
      v20 = **((_QWORD **)v6 + 1);
      v21 = *(_DWORD *)(v20 + 16);
      if (v21 <= v19 || (v22 = v6[4] + v14, v22 >= *(_DWORD *)(v20 + 20)))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v23 = *(float *)(*(_QWORD *)v20 + 4 * (v19 + v21 * v22));
      *v10 = v23
           * cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(v16, v13, HIDWORD(v13));
      v24 = (v14 + 1);
      v18 = *v6;
      if (*v6 <= (int)v24)
        v14 = (v14 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v14 = v14 & 0xFFFFFFFF00000000 | v24;
      v25 = (v13 + 1);
      if (*(_DWORD *)(v16 + 4) <= (int)v25)
        v13 = (v13 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v13 = v13 & 0xFFFFFFFF00000000 | v25;
      if (v15 + 1 >= v5)
        v26 = v17;
      else
        v26 = 0;
      v10 += v26 + 1;
      if (v15 + 1 < v5)
        ++v15;
      else
        v15 = 0;
    }
    while (v10 != v12);
  }
}

float cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  float v7;
  float v8;
  float result;

  if (*(_DWORD *)(a1 + 4) <= a2 || *(_DWORD *)(a1 + 8) <= a3)
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2, a3);
  v3 = ***(float ****)(a1 + 16);
  v4 = *(_DWORD *)(*(_QWORD *)v3 + 4);
  if (**(_DWORD **)v3 < v4)
    v4 = **(_DWORD **)v3;
  v5 = a3 % v4;
  v6 = *(_QWORD *)(*(_QWORD *)v3 + 8);
  if (*(_DWORD *)(v6 + 16) <= v5)
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2, a3);
  v7 = *(float *)(*(_QWORD *)v6 + 4 * v5);
  v8 = fabsf(v7);
  result = 1.0 / v7;
  if (v8 < v3[2])
    return 0.0;
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  uint64_t v17;

  v4 = *(_QWORD *)(a2 + 8);
  v5 = **(_QWORD **)(a2 + 16);
  if (*(_QWORD *)v4 == *(_QWORD *)a1 || *(_QWORD *)v5 == *(_QWORD *)a1)
  {
    v10 = (*(_DWORD *)(v5 + 16) * *(_DWORD *)(v4 + 16));
    v15 = 0;
    v16 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v15, v10);
    v11 = *(_DWORD *)(**(_QWORD **)(a2 + 16) + 16);
    LODWORD(v17) = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 16);
    HIDWORD(v17) = v11;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(&v15, a2);
    v12 = *(void **)a1;
    v13 = *(_QWORD *)(a1 + 8);
    v14 = v16;
    *(_QWORD *)a1 = v15;
    *(_QWORD *)(a1 + 8) = v14;
    v15 = v12;
    v16 = v13;
    *(_QWORD *)(a1 + 16) = v17;
    v17 = 0;
    free(v12);
  }
  else
  {
    LODWORD(v6) = *(_DWORD *)(a1 + 16);
    if ((_DWORD)v6 != *(_DWORD *)(v4 + 16) || (v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v5 + 16)))
    {
      cva::Logger::instance((cva::Logger *)a1);
      v8 = cva::Logger::logInCategory();
      v6 = *(unsigned int *)(a1 + 16);
      v4 = *(_QWORD *)(a2 + 8);
      if ((_DWORD)v6 != *(_DWORD *)(v4 + 16)
        || (v5 = **(_QWORD **)(a2 + 16), v7 = *(_DWORD *)(v5 + 16), *(_DWORD *)(a1 + 20) != v7))
      {
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v8, v9, v6);
      }
    }
    if (*(_DWORD *)(v4 + 20) * (_DWORD)v6 && v7 * *(_DWORD *)(v5 + 20))
    {
      cva::VecLib<float>::gemm();
    }
    else if ((_DWORD)v6 * v7)
    {
      bzero(*(void **)a1, 4 * (v6 * v7));
    }
  }
}

void sub_1B3BA9B04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  _QWORD **v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;

  v4 = *(_QWORD *)(a2 + 16);
  if (*(_QWORD *)v4 == *(_QWORD *)a1)
  {
    v16 = (*(_DWORD *)(v4 + 20) * *(_DWORD *)(***(_QWORD ***)(a2 + 8) + 4));
    v20 = 0;
    v21 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v16);
    v17 = *(_DWORD *)(*(_QWORD *)(a2 + 16) + 20);
    LODWORD(v22) = *(_DWORD *)(***(_QWORD ***)(a2 + 8) + 4);
    HIDWORD(v22) = v17;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>,cva::Matrix<float,0u,0u,false>>(&v20, a2);
    v14 = *(void **)a1;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = v21;
    *(_QWORD *)a1 = v20;
    *(_QWORD *)(a1 + 8) = v19;
    v20 = v14;
    v21 = v18;
    *(_QWORD *)(a1 + 16) = v22;
    v22 = 0;
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_QWORD ***)(a2 + 8);
  if (v5 != *(_DWORD *)(**v6 + 4) || (v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 20)))
  {
    cva::Logger::instance((cva::Logger *)a1);
    v8 = cva::Logger::logInCategory();
    v5 = *(_DWORD *)(a1 + 16);
    v6 = *(_QWORD ***)(a2 + 8);
    if (v5 != *(_DWORD *)(**v6 + 4)
      || (v4 = *(_QWORD *)(a2 + 16), v7 = *(_DWORD *)(v4 + 20), *(_DWORD *)(a1 + 20) != v7))
    {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v8, v9, v10);
    }
  }
  v11 = (*(_DWORD *)(*v6[1] + 16) * v5);
  if ((_DWORD)v11 && v7 * *(_DWORD *)(v4 + 16))
  {
    v20 = 0;
    v21 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v11);
    v12 = *(_DWORD *)(*v6[1] + 16);
    LODWORD(v22) = *(_DWORD *)(**v6 + 4);
    HIDWORD(v22) = v12;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>((cva::Logger *)&v20, (uint64_t)v6, v13);
    cva::VecLib<float>::gemm();
    v14 = v20;
LABEL_12:
    free(v14);
    return;
  }
  v15 = v5 * v7;
  if (v15)
    bzero(*(void **)a1, 4 * v15);
}

void sub_1B3BA9D30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

int *cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>>(cva::Logger *a1, uint64_t a2, uint64_t a3)
{
  cva::Logger *v4;
  unsigned int v5;
  unsigned int **v6;
  unsigned int *v7;
  int v8;
  uint64_t *v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  int *result;
  uint64_t v14;
  unsigned int v15;
  int v16;
  int v17;
  int v18;
  BOOL v19;
  _DWORD *v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  int v24[2];
  uint64_t v25;
  unsigned int v26;
  int v27;
  char v28;
  unsigned int v29;
  int v30;
  unsigned int ***v31;
  _DWORD v32[2];
  uint64_t *v33;
  uint64_t v34;
  _QWORD v35[3];
  unsigned int **v36;

  v4 = a1;
  v5 = *((_DWORD *)a1 + 4);
  v6 = *(unsigned int ***)a2;
  v7 = **(unsigned int ***)a2;
  if (v5 != v7[1] || (v8 = *((_DWORD *)a1 + 5), v9 = *(uint64_t **)(a2 + 8), v10 = *v9, v8 != *(_DWORD *)(*v9 + 16)))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *((_DWORD *)v4 + 4);
    v6 = *(unsigned int ***)a2;
    v7 = **(unsigned int ***)a2;
    if (v5 != v7[1] || (v9 = *(uint64_t **)(a2 + 8), v10 = *v9, v8 = *(_DWORD *)(*v9 + 16), *((_DWORD *)v4 + 5) != v8))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, a2, a3);
  }
  v36 = v6;
  v11 = *v7;
  if (*v7 >= v5)
    v11 = v5;
  if (v11 > *(_DWORD *)(v10 + 20))
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((uint64_t)a1, a2, a3);
  v32[0] = v11;
  v32[1] = v8;
  v33 = v9;
  v34 = 0;
  v29 = v11;
  v30 = v8;
  v31 = &v36;
  v35[0] = v32;
  v35[1] = &v28;
  v12 = *(_QWORD *)v4;
  v24[0] = v11;
  v24[1] = v8;
  v25 = v12;
  v26 = v5;
  v27 = 0;
  result = cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(v24, v35, a3);
  v14 = *(unsigned int *)(*v9 + 20);
  v15 = *((_DWORD *)v4 + 4);
  if (v15 > v14)
  {
    v16 = v15 - v14;
    v17 = *((_DWORD *)v4 + 5);
    v18 = v17 * (v15 - v14);
    v19 = v18 == 0;
    if (v18)
      v20 = (_DWORD *)(*(_QWORD *)v4 + 4 * v14);
    else
      v20 = 0;
    v21 = *(_QWORD *)v4 + 4 * v14 + 4 * v17 * v15;
    if (v19)
      v21 = 0;
    if (v20 != (_DWORD *)v21)
    {
      v22 = 0;
      do
      {
        *v20 = 0;
        if (v22 + 1 >= v16)
          v23 = v14;
        else
          v23 = 0;
        v20 += v23 + 1;
        if (v22 + 1 < v16)
          ++v22;
        else
          v22 = 0;
      }
      while (v20 != (_DWORD *)v21);
    }
  }
  return result;
}

int *cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(int *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  cva::Logger *v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  _DWORD *v14;
  uint64_t v15;
  void *v16;
  int v17;
  unsigned int v18;
  int *v19;
  int v20;
  unsigned int v21;
  void *v23[2];
  int v24;
  int v25;

  v5 = *((_QWORD *)a1 + 1) - 4 * a1[5];
  if (***(_QWORD ***)(*a2 + 8) == v5 || **(_QWORD **)(***(_QWORD ***)(a2[1] + 16) + 8) == v5)
  {
    v6 = *a1;
    v7 = a1[1];
    v23[0] = 0;
    v23[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v23, (v7 * v6));
    v24 = v6;
    v25 = v7;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>((cva::Logger *)v23, a2, v8);
    v10 = *a1;
    if (*a1 != v24 || (v11 = a1[1], v11 != v25))
    {
      cva::Logger::instance(v9);
      cva::Logger::logInCategory();
      v10 = *a1;
      if (*a1 != v24 || (v11 = a1[1], v11 != v25))
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
    v12 = a1[4];
    v13 = v10 * v11 == 0;
    if (v10 * v11)
      v14 = (_DWORD *)*((_QWORD *)a1 + 1);
    else
      v14 = 0;
    v15 = *((_QWORD *)a1 + 1) + 4 * (v12 * v11);
    if (v13)
      v15 = 0;
    v16 = v23[0];
    if (v14 != (_DWORD *)v15)
    {
      v17 = 0;
      v18 = v12 - v10;
      v19 = (int *)v23[0];
      do
      {
        v20 = *v19++;
        *v14 = v20;
        if (v17 + 1 >= v10)
          v21 = v18;
        else
          v21 = 0;
        v14 += v21 + 1;
        if (v17 + 1 < v10)
          ++v17;
        else
          v17 = 0;
      }
      while (v14 != (_DWORD *)v15);
    }
    free(v16);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>((cva::Logger *)a1, a2, a3);
  }
  return a1;
}

void sub_1B3BAA08C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(cva::Logger *a1, _QWORD *a2, uint64_t a3)
{
  cva::Logger *v4;
  unsigned int v5;
  _DWORD *v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  float *v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  float v18;
  uint64_t v19;
  uint64_t v20;

  v4 = a1;
  v5 = *((_DWORD *)a1 + 4);
  v6 = (_DWORD *)*a2;
  if (v5 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)a1 + 5), v7 != v6[1]))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *((_DWORD *)v4 + 4);
    v6 = (_DWORD *)*a2;
    if (v5 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)v4 + 5), v7 != v6[1]))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, (uint64_t)a2, a3);
  }
  v8 = v7 * v5;
  if ((_DWORD)v8)
  {
    v9 = 0;
    v10 = 0;
    v11 = a2[1];
    v12 = *(float **)v4;
    v13 = 4 * v8;
    do
    {
      if (v5 <= v10 || v6[1] <= HIDWORD(v10))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v14 = v6[5] + HIDWORD(v10);
      v15 = **((_QWORD **)v6 + 1);
      v16 = *(_DWORD *)(v15 + 16);
      if (v16 <= v14 || (v17 = v6[4] + v10, v17 >= *(_DWORD *)(v15 + 20)))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v18 = *(float *)(*(_QWORD *)v15 + 4 * (v14 + v16 * v17));
      *v12++ = v18
             * cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(v11, v9, HIDWORD(v9));
      v19 = (v10 + 1);
      v5 = *v6;
      if (*v6 <= (int)v19)
        v10 = (v10 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v10 = v10 & 0xFFFFFFFF00000000 | v19;
      v20 = (v9 + 1);
      if (*(_DWORD *)(v11 + 4) <= (int)v20)
        v9 = (v9 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v9 = v9 & 0xFFFFFFFF00000000 | v20;
      v13 -= 4;
    }
    while (v13);
  }
}

void cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>,cva::detail::MulOp>>(cva::Logger *a1, _QWORD *a2, uint64_t a3)
{
  cva::Logger *v4;
  signed int v5;
  _DWORD *v6;
  int v7;
  int v8;
  int v9;
  float *v10;
  uint64_t v11;
  float *v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  float v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;

  v4 = a1;
  v5 = *(_DWORD *)a1;
  v6 = (_DWORD *)*a2;
  if (*(_DWORD *)a1 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)a1 + 1), v7 != v6[1]))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *(_DWORD *)v4;
    v6 = (_DWORD *)*a2;
    if (*(_DWORD *)v4 != *(_DWORD *)*a2 || (v7 = *((_DWORD *)v4 + 1), v7 != v6[1]))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, (uint64_t)a2, a3);
  }
  v8 = v7 * v5;
  v9 = *((_DWORD *)v4 + 4);
  if (v7 * v5)
    v10 = (float *)*((_QWORD *)v4 + 1);
  else
    v10 = 0;
  v11 = *((_QWORD *)v4 + 1) + 4 * (v9 * v7);
  if (v8)
    v12 = (float *)v11;
  else
    v12 = 0;
  if (v10 != v12)
  {
    v13 = 0;
    v14 = 0;
    v15 = 0;
    v16 = a2[1];
    v17 = v9 - v5;
    v18 = v5;
    do
    {
      if (v18 <= v14 || v6[1] <= HIDWORD(v14))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v19 = v6[5] + HIDWORD(v14);
      v20 = **((_QWORD **)v6 + 1);
      v21 = *(_DWORD *)(v20 + 16);
      if (v21 <= v19 || (v22 = v6[4] + v14, v22 >= *(_DWORD *)(v20 + 20)))
        cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((uint64_t)a1, (uint64_t)a2, a3);
      v23 = *(float *)(*(_QWORD *)v20 + 4 * (v19 + v21 * v22));
      *v10 = v23
           * cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(v16, v13, HIDWORD(v13));
      v24 = (v14 + 1);
      v18 = *v6;
      if (*v6 <= (int)v24)
        v14 = (v14 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v14 = v14 & 0xFFFFFFFF00000000 | v24;
      v25 = (v13 + 1);
      if (*(_DWORD *)(v16 + 4) <= (int)v25)
        v13 = (v13 & 0xFFFFFFFF00000000) + 0x100000000;
      else
        v13 = v13 & 0xFFFFFFFF00000000 | v25;
      if (v15 + 1 >= v5)
        v26 = v17;
      else
        v26 = 0;
      v10 += v26 + 1;
      if (v15 + 1 < v5)
        ++v15;
      else
        v15 = 0;
    }
    while (v10 != v12);
  }
}

float cva::MatrixRepeatExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const>,1u,0u>::operator()(uint64_t a1, uint64_t a2, uint64_t a3)
{
  float *v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  float v7;
  float v8;
  float result;

  if (*(_DWORD *)(a1 + 4) <= a2 || *(_DWORD *)(a1 + 8) <= a3)
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2, a3);
  v3 = **(float ***)(a1 + 16);
  v4 = *(_DWORD *)(*(_QWORD *)v3 + 4);
  if (**(_DWORD **)v3 < v4)
    v4 = **(_DWORD **)v3;
  v5 = a2 % v4;
  v6 = *(_QWORD *)(*(_QWORD *)v3 + 8);
  if (*(_DWORD *)(v6 + 16) <= v5)
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(a1, a2, a3);
  v7 = *(float *)(*(_QWORD *)v6 + 4 * v5);
  v8 = fabsf(v7);
  result = 1.0 / v7;
  if (v8 < v3[2])
    return 0.0;
  return result;
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  int v5;
  _DWORD ***v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  void *v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  void *v20;
  uint64_t v21;
  uint64_t v22;

  v4 = **(_QWORD **)(a2 + 16);
  if (*(_QWORD *)v4 == *(_QWORD *)a1)
  {
    v16 = (*(_DWORD *)(v4 + 16) * *(_DWORD *)(***(_QWORD ***)(a2 + 8) + 20));
    v20 = 0;
    v21 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v16);
    v17 = *(_DWORD *)(**(_QWORD **)(a2 + 16) + 16);
    LODWORD(v22) = *(_DWORD *)(***(_QWORD ***)(a2 + 8) + 20);
    HIDWORD(v22) = v17;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixMultExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>>(&v20, a2);
    v14 = *(void **)a1;
    v18 = *(_QWORD *)(a1 + 8);
    v19 = v21;
    *(_QWORD *)a1 = v20;
    *(_QWORD *)(a1 + 8) = v19;
    v20 = v14;
    v21 = v18;
    *(_QWORD *)(a1 + 16) = v22;
    v22 = 0;
    goto LABEL_12;
  }
  v5 = *(_DWORD *)(a1 + 16);
  v6 = *(_DWORD ****)(a2 + 8);
  if (v5 != (**v6)[5] || (v7 = *(_DWORD *)(a1 + 20), v7 != *(_DWORD *)(v4 + 16)))
  {
    cva::Logger::instance((cva::Logger *)a1);
    v8 = cva::Logger::logInCategory();
    v5 = *(_DWORD *)(a1 + 16);
    v6 = *(_DWORD ****)(a2 + 8);
    if (v5 != (**v6)[5] || (v4 = **(_QWORD **)(a2 + 16), v7 = *(_DWORD *)(v4 + 16), *(_DWORD *)(a1 + 20) != v7))
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v8, v9, v10);
  }
  v11 = (**v6[1] * v5);
  if ((_DWORD)v11 && v7 * *(_DWORD *)(v4 + 20))
  {
    v20 = 0;
    v21 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v20, v11);
    v12 = **v6[1];
    LODWORD(v22) = (**v6)[5];
    HIDWORD(v22) = v12;
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((cva::Logger *)&v20, (uint64_t)v6, v13);
    cva::VecLib<float>::gemm();
    v14 = v20;
LABEL_12:
    free(v14);
    return;
  }
  v15 = v5 * v7;
  if (v15)
    bzero(*(void **)a1, 4 * v15);
}

void sub_1B3BAA6CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>(cva::Logger *a1, uint64_t a2, uint64_t a3)
{
  cva::Logger *v4;
  int v5;
  uint64_t *v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int **v9;
  unsigned int *v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  uint64_t v17;
  unsigned int v18;
  BOOL v19;
  _BYTE *v20;
  _BYTE *v21;
  int v22[2];
  uint64_t v23;
  int v24;
  int v25;
  unsigned int ***v26;
  char v27;
  int v28;
  unsigned int v29;
  unsigned int ****v30;
  _DWORD v31[2];
  uint64_t *v32;
  uint64_t v33;
  _QWORD v34[3];
  unsigned int **v35;

  v4 = a1;
  v5 = *((_DWORD *)a1 + 4);
  v6 = *(uint64_t **)a2;
  v7 = **(_QWORD **)a2;
  if (v5 != *(_DWORD *)(v7 + 20) || (v8 = *((_DWORD *)a1 + 5), v9 = *(unsigned int ***)(a2 + 8), v10 = *v9, v8 != **v9))
  {
    cva::Logger::instance(a1);
    a1 = (cva::Logger *)cva::Logger::logInCategory();
    v5 = *((_DWORD *)v4 + 4);
    v6 = *(uint64_t **)a2;
    v7 = **(_QWORD **)a2;
    if (v5 != *(_DWORD *)(v7 + 20)
      || (v9 = *(unsigned int ***)(a2 + 8), v10 = *v9, v8 = **v9, *((_DWORD *)v4 + 5) != v8))
    {
      cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>((uint64_t)a1, a2, a3);
    }
  }
  v35 = v9;
  if (v8 >= v10[1])
    v8 = v10[1];
  if (v8 > *(_DWORD *)(v7 + 16))
    cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>((uint64_t)a1, a2, a3);
  v31[0] = v5;
  v31[1] = v8;
  v32 = v6;
  v33 = 0;
  v26 = &v35;
  v28 = v5;
  v29 = v8;
  v30 = &v26;
  v34[0] = v31;
  v34[1] = &v27;
  v11 = *(_QWORD *)v4;
  v22[0] = v5;
  v22[1] = v8;
  v23 = v11;
  v24 = v5;
  v25 = 0;
  cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(v22, v34, a3);
  v12 = *(_DWORD *)(*v6 + 16);
  v13 = *((_DWORD *)v4 + 5);
  v14 = v13 >= v12;
  v15 = v13 - v12;
  if (v15 != 0 && v14)
  {
    v16 = *((_DWORD *)v4 + 4);
    v17 = *(_QWORD *)v4 + 4 * v16 * v12;
    v18 = v16 * v15;
    v19 = v18 == 0;
    if (v18)
      v20 = (_BYTE *)v17;
    else
      v20 = 0;
    v21 = (_BYTE *)(v17 + 4 * v18);
    if (v19)
      v21 = 0;
    if (v20 != v21)
      bzero(v20, ((v21 - v20 - 4) & 0xFFFFFFFFFFFFFFFCLL) + 4);
  }
}

int *cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(int *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v5;
  int v6;
  int v7;
  uint64_t v8;
  cva::Logger *v9;
  int v10;
  int v11;
  int v12;
  BOOL v13;
  _DWORD *v14;
  uint64_t v15;
  void *v16;
  int v17;
  unsigned int v18;
  int *v19;
  int v20;
  unsigned int v21;
  void *v23[2];
  int v24;
  int v25;

  v5 = *((_QWORD *)a1 + 1) - 4 * a1[5];
  if (***(_QWORD ***)(*a2 + 8) == v5 || **(_QWORD **)(****(_QWORD ****)(a2[1] + 16) + 8) == v5)
  {
    v6 = *a1;
    v7 = a1[1];
    v23[0] = 0;
    v23[1] = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(v23, (v7 * v6));
    v24 = v6;
    v25 = v7;
    cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)v23, a2, v8);
    v10 = *a1;
    if (*a1 != v24 || (v11 = a1[1], v11 != v25))
    {
      cva::Logger::instance(v9);
      cva::Logger::logInCategory();
      v10 = *a1;
      if (*a1 != v24 || (v11 = a1[1], v11 != v25))
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
    v12 = a1[4];
    v13 = v10 * v11 == 0;
    if (v10 * v11)
      v14 = (_DWORD *)*((_QWORD *)a1 + 1);
    else
      v14 = 0;
    v15 = *((_QWORD *)a1 + 1) + 4 * (v12 * v11);
    if (v13)
      v15 = 0;
    v16 = v23[0];
    if (v14 != (_DWORD *)v15)
    {
      v17 = 0;
      v18 = v12 - v10;
      v19 = (int *)v23[0];
      do
      {
        v20 = *v19++;
        *v14 = v20;
        if (v17 + 1 >= v10)
          v21 = v18;
        else
          v21 = 0;
        v14 += v21 + 1;
        if (v17 + 1 < v10)
          ++v17;
        else
          v17 = 0;
      }
      while (v14 != (_DWORD *)v15);
    }
    free(v16);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>((cva::Logger *)a1, a2, a3);
  }
  return a1;
}

void sub_1B3BAAA1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  int v14;

  v4 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)v4 == *(_QWORD *)a1 || **(_QWORD **)(a2 + 16) == *(_QWORD *)a1)
  {
    v8 = *(unsigned int *)(v4 + 16);
    v12 = 0;
    v13 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v12, v8);
    v14 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 16);
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,0u,1u,false>>(&v12, a2);
    v9 = *(void **)a1;
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v13;
    *(_QWORD *)a1 = v12;
    *(_QWORD *)(a1 + 8) = v11;
    v12 = v9;
    v13 = v10;
    *(_DWORD *)(a1 + 16) = v14;
    v14 = 0;
    free(v9);
  }
  else
  {
    LODWORD(v5) = *(_DWORD *)(a1 + 16);
    if ((_DWORD)v5 != *(_DWORD *)(v4 + 16))
    {
      cva::Logger::instance((cva::Logger *)a1);
      v6 = cva::Logger::logInCategory();
      v5 = *(unsigned int *)(a1 + 16);
      v4 = *(_QWORD *)(a2 + 8);
      if ((_DWORD)v5 != *(_DWORD *)(v4 + 16))
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v6, v5, v7);
    }
    if (*(_DWORD *)(v4 + 20) * (_DWORD)v5 && *(_DWORD *)(*(_QWORD *)(a2 + 16) + 16))
    {
      cva::VecLib<float>::gemv();
    }
    else if ((_DWORD)v5)
    {
      bzero(*(void **)a1, 4 * v5);
    }
  }
}

void sub_1B3BAAB88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  int v14;

  v4 = *(_QWORD *)(a2 + 8);
  if (*(_QWORD *)v4 == *(_QWORD *)a1 || *(_QWORD *)(a2 + 16) == *(_QWORD *)a1)
  {
    v8 = *(unsigned int *)(v4 + 16);
    v12 = 0;
    v13 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v12, v8);
    v14 = *(_DWORD *)(*(_QWORD *)(a2 + 8) + 16);
    cva::assign<false,false,cva::Matrix<float,0u,1u,false>,cva::Matrix<float,0u,0u,false>,cva::Matrix<float,9u,1u,false>>(&v12, a2);
    v9 = *(void **)a1;
    v10 = *(_QWORD *)(a1 + 8);
    v11 = v13;
    *(_QWORD *)a1 = v12;
    *(_QWORD *)(a1 + 8) = v11;
    v12 = v9;
    v13 = v10;
    *(_DWORD *)(a1 + 16) = v14;
    v14 = 0;
    free(v9);
  }
  else
  {
    LODWORD(v5) = *(_DWORD *)(a1 + 16);
    if ((_DWORD)v5 != *(_DWORD *)(v4 + 16))
    {
      cva::Logger::instance((cva::Logger *)a1);
      v6 = cva::Logger::logInCategory();
      v5 = *(unsigned int *)(a1 + 16);
      v4 = *(_QWORD *)(a2 + 8);
      if ((_DWORD)v5 != *(_DWORD *)(v4 + 16))
        cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(v6, v5, v7);
    }
    if (*(_DWORD *)(v4 + 20) * (_DWORD)v5)
    {
      cva::VecLib<float>::gemv();
    }
    else if ((_DWORD)v5)
    {
      bzero(*(void **)a1, 4 * v5);
    }
  }
}

void sub_1B3BAACE4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

void OUTLINED_FUNCTION_0_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 163, a4);
}

void OUTLINED_FUNCTION_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 2269, a4);
}

void OUTLINED_FUNCTION_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 100, a4);
}

void OUTLINED_FUNCTION_3(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 192, a4);
}

void OUTLINED_FUNCTION_4(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 2252, a4);
}

id _ARLogTechnique_13()
{
  if (_ARLogTechnique_onceToken_19 != -1)
    dispatch_once(&_ARLogTechnique_onceToken_19, &__block_literal_global_111);
  return (id)_ARLogTechnique_logObj_19;
}

id _ARLogGeneral_40()
{
  if (_ARLogGeneral_onceToken_47 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_47, &__block_literal_global_17);
  return (id)_ARLogGeneral_logObj_47;
}

uint64_t arkit::FaceTrackingData::FaceTrackingData(uint64_t a1, __int128 *a2, uint64_t *a3)
{
  __int128 v4;
  __int128 v5;

  v4 = *a2;
  v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>((char *)(a1 + 40), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 2));
  return a1;
}

{
  __int128 v4;
  __int128 v5;

  v4 = *a2;
  v5 = a2[1];
  *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
  *(_OWORD *)a1 = v4;
  *(_OWORD *)(a1 + 16) = v5;
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 40) = 0;
  std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>((char *)(a1 + 40), *a3, a3[1], 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 2));
  return a1;
}

void arkit::FaceTrackingData::filteredLandmarks(uint64_t a1@<X0>, int **a2@<X1>, uint64_t a3@<X8>)
{
  int *v6;
  int *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  unint64_t v12;
  unint64_t v13;
  char *v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  char *v19;
  uint64_t v20;
  char *v21;
  char *v22;
  char *v23;
  char *v24;
  uint64_t v25;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)(a3 + 16) = 0;
  std::vector<arkit::Landmark>::reserve((char **)a3, a2[1] - *a2);
  v6 = *a2;
  v7 = a2[1];
  if (*a2 != v7)
  {
    v8 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 48) - *(_QWORD *)(a1 + 40)) >> 2) - 1;
    do
    {
      v9 = *v6;
      if (v8 >= v9)
      {
        v10 = *(_QWORD *)(a1 + 40);
        v11 = (_QWORD *)(v10 + 12 * (int)v9);
        v12 = *(_QWORD *)(a3 + 8);
        v13 = *(_QWORD *)(a3 + 16);
        if (v12 >= v13)
        {
          v15 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v12 - *(_QWORD *)a3) >> 2);
          v16 = v15 + 1;
          if (v15 + 1 > 0x1555555555555555)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v17 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(v13 - *(_QWORD *)a3) >> 2);
          if (2 * v17 > v16)
            v16 = 2 * v17;
          if (v17 >= 0xAAAAAAAAAAAAAAALL)
            v18 = 0x1555555555555555;
          else
            v18 = v16;
          v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<float,3u,1u,false>>>(a3 + 16, v18);
          v21 = &v19[12 * v15];
          *(_QWORD *)v21 = *v11;
          v21[8] = *(_BYTE *)(v10 + 12 * (int)v9 + 8);
          v23 = *(char **)a3;
          v22 = *(char **)(a3 + 8);
          v24 = v21;
          if (v22 != *(char **)a3)
          {
            do
            {
              v25 = *(_QWORD *)(v22 - 12);
              v22 -= 12;
              *(_QWORD *)(v24 - 12) = v25;
              v24 -= 12;
              v24[8] = v22[8];
            }
            while (v22 != v23);
            v22 = *(char **)a3;
          }
          v14 = v21 + 12;
          *(_QWORD *)a3 = v24;
          *(_QWORD *)(a3 + 8) = v21 + 12;
          *(_QWORD *)(a3 + 16) = &v19[12 * v20];
          if (v22)
            operator delete(v22);
        }
        else
        {
          *(_QWORD *)v12 = *v11;
          *(_BYTE *)(v12 + 8) = *(_BYTE *)(v10 + 12 * (int)v9 + 8);
          v14 = (char *)(v12 + 12);
        }
        *(_QWORD *)(a3 + 8) = v14;
      }
      ++v6;
    }
    while (v6 != v7);
  }
}

void sub_1B3BABA20(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

unint64_t arkit::FaceTrackingData::nLandmarks(arkit::FaceTrackingData *this)
{
  return 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*((_QWORD *)this + 6) - *((_QWORD *)this + 5)) >> 2);
}

char *std::vector<arkit::Landmark>::__init_with_size[abi:ne180100]<arkit::Landmark*,arkit::Landmark*>(char *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  char *v6;
  uint64_t v7;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<float,3u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = *((_QWORD *)v6 + 1);
    while (a2 != a3)
    {
      *(_QWORD *)v7 = *(_QWORD *)a2;
      *(_BYTE *)(v7 + 8) = *(_BYTE *)(a2 + 8);
      v7 += 12;
      a2 += 12;
    }
    *((_QWORD *)v6 + 1) = v7;
  }
  return result;
}

void sub_1B3BABAC4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

id _ARLogGeneral_41()
{
  if (_ARLogGeneral_onceToken_48 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_48, &__block_literal_global_113);
  return (id)_ARLogGeneral_logObj_48;
}

BOOL ARFileDescriptorIsTTY(FILE *a1)
{
  int v2;
  BOOL v3;

  if (ARFileDescriptorIsTTY_onceToken != -1)
    dispatch_once(&ARFileDescriptorIsTTY_onceToken, &__block_literal_global_115);
  v2 = fileno(a1);
  if (isatty(v2))
    v3 = ARFileDescriptorIsTTY_isSSHTTY == 0;
  else
    v3 = 1;
  return !v3;
}

void _printFormat(FILE *a1, void *a2, uint64_t a3)
{
  objc_class *v5;
  id v6;
  void *v7;
  id v8;
  NSObject *v9;
  uint8_t buf[4];
  id v11;
  uint64_t v12;

  v12 = *MEMORY[0x1E0C80C00];
  v5 = (objc_class *)MEMORY[0x1E0CB3940];
  v6 = a2;
  v7 = (void *)objc_msgSend([v5 alloc], "initWithFormat:arguments:", v6, a3);

  v8 = objc_retainAutorelease(v7);
  fprintf(a1, "%s\n", (const char *)objc_msgSend(v8, "UTF8String"));
  _ARLogGeneral_42();
  v9 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v11 = v8;
    _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
  }

}

id _ARLogGeneral_42()
{
  if (_ARLogGeneral_onceToken_49 != -1)
    dispatch_once(&_ARLogGeneral_onceToken_49, &__block_literal_global_42);
  return (id)_ARLogGeneral_logObj_49;
}

void _printMessageWithColor(FILE *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  const char *v7;
  NSObject *v8;
  uint8_t buf[4];
  id v10;
  uint64_t v11;

  v11 = *MEMORY[0x1E0C80C00];
  v5 = a2;
  v6 = a3;
  if (ARFileDescriptorIsTTY(a1))
  {
    fputs((const char *)objc_msgSend(objc_retainAutorelease(v5), "UTF8String"), a1);
    fputs((const char *)objc_msgSend(objc_retainAutorelease(v6), "UTF8String"), a1);
    v7 = (const char *)objc_msgSend(CFSTR("\x1B[0m"), "UTF8String");
  }
  else
  {
    v7 = "";
    fputs("", a1);
    fputs((const char *)objc_msgSend(objc_retainAutorelease(v6), "UTF8String"), a1);
  }
  fprintf(a1, "%s\n", v7);
  _ARLogGeneral_42();
  v8 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 138543362;
    v10 = v6;
    _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_DEFAULT, "%{public}@", buf, 0xCu);
  }

}

void printMessage(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _printFormat((FILE *)*MEMORY[0x1E0C80C20], a1, (uint64_t)&a9);
}

void _printMessage(void *a1, uint64_t a2)
{
  _printFormat((FILE *)*MEMORY[0x1E0C80C20], a1, a2);
}

double printVector3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  double result;

  printMessage(CFSTR("%s: (%f, %f, %f)"), a2, a3, a4, a5, a6, a7, a8, a1);
  return result;
}

void printError(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _printError(a1, (uint64_t)&a9);
}

void _printError(void *a1, uint64_t a2)
{
  objc_class *v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  id v8;

  v3 = (objc_class *)MEMORY[0x1E0CB3940];
  v4 = a1;
  v5 = [v3 alloc];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@"), v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (id)objc_msgSend(v5, "initWithFormat:arguments:", v6, a2);
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("  ERROR: %@\n"), v8);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  _printMessageWithColor((FILE *)*MEMORY[0x1E0C80C10], CFSTR("\x1B[1;35m"), v7);

}

void printInfo(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _printInfo(a1, (uint64_t)&a9);
}

void _printInfo(void *a1, uint64_t a2)
{
  objc_class *v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  id v8;

  v3 = (objc_class *)MEMORY[0x1E0CB3940];
  v4 = a1;
  v5 = [v3 alloc];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@"), v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (id)objc_msgSend(v5, "initWithFormat:arguments:", v6, a2);
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("  INFO: %@\n"), v8);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  _printMessageWithColor((FILE *)*MEMORY[0x1E0C80C20], CFSTR("\x1B[1;35m"), v7);

}

void printWarning(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _printWarning(a1, (uint64_t)&a9);
}

void _printWarning(void *a1, uint64_t a2)
{
  objc_class *v3;
  id v4;
  id v5;
  void *v6;
  void *v7;
  id v8;

  v3 = (objc_class *)MEMORY[0x1E0CB3940];
  v4 = a1;
  v5 = [v3 alloc];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@"), v4);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  v8 = (id)objc_msgSend(v5, "initWithFormat:arguments:", v6, a2);
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("  WARNING: %@\n"), v8);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  _printMessageWithColor((FILE *)*MEMORY[0x1E0C80C20], CFSTR("\x1B[1;35m"), v7);

}

void printColoredMessage(void *a1, void *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _printColoredMessage(a1, a2, (uint64_t)&a9);
}

void _printColoredMessage(void *a1, void *a2, uint64_t a3)
{
  objc_class *v5;
  id v6;
  id v7;
  id v8;
  void *v9;
  id v10;

  v5 = (objc_class *)MEMORY[0x1E0CB3940];
  v6 = a2;
  v7 = a1;
  v8 = [v5 alloc];
  objc_msgSend(MEMORY[0x1E0CB3940], "stringWithFormat:", CFSTR("%@"), v6);
  v9 = (void *)objc_claimAutoreleasedReturnValue();

  v10 = (id)objc_msgSend(v8, "initWithFormat:arguments:", v9, a3);
  _printMessageWithColor((FILE *)*MEMORY[0x1E0C80C20], v7, v10);

}

void ARPrintUsageStrings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t vars0;

  printColoredMessage(CFSTR("\x1B[1m"), CFSTR("Usage:"), a3, a4, a5, a6, a7, a8, vars0);
  printMessage(CFSTR(" arkitctl <COMMAND> [help]\n"), v9, v10, v11, v12, v13, v14, v15, a9);
}

uint64_t ARPrintToiTerm(void *a1)
{
  id v1;
  void *v2;
  id v3;

  v1 = a1;
  printf("\x1B]1337;File=[size=%lld;inline=1;preserveAspectRatio=1]:", objc_msgSend(v1, "length"));
  objc_msgSend(v1, "base64EncodedStringWithOptions:", 0);
  v2 = (void *)objc_claimAutoreleasedReturnValue();

  v3 = objc_retainAutorelease(v2);
  puts((const char *)objc_msgSend(v3, "UTF8String"));

  return puts("\a");
}

uint64_t ARPrintEscapeEnableAlternativeBuffer()
{
  printf("%s", "\x1B[?1049h");
  return fflush((FILE *)*MEMORY[0x1E0C80C20]);
}

uint64_t ARPrintEscapeDisableAlternativeBuffer()
{
  printf("%s", "\x1B[?1049l");
  return fflush((FILE *)*MEMORY[0x1E0C80C20]);
}

uint64_t ARPrintEscapeEraseScreen()
{
  printf("%s", "\x1B[2J");
  return fflush((FILE *)*MEMORY[0x1E0C80C20]);
}

uint64_t ARPrintEscapeMoveToLocation(int a1, int a2)
{
  printf("\x1B[%d;%dH", a1, a2);
  return fflush((FILE *)*MEMORY[0x1E0C80C20]);
}

char *arkit::wrap@<X0>(arkit *this@<X0>, _QWORD *a2@<X8>)
{
  unsigned int WidthOfPlane;
  unsigned int HeightOfPlane;
  size_t BytesPerRowOfPlane;
  void *BaseAddressOfPlane;
  unsigned int v9;
  unint64_t v10;
  size_t v11;
  void *v12;
  unint64_t v13;
  size_t v14;
  char *result;

  if (CVPixelBufferGetPixelFormatType(this) != 875704422)
    arkit::wrap();
  a2[1] = 0;
  a2[2] = 0;
  a2[3] = 0;
  a2[6] = 0;
  a2[7] = 0;
  a2[5] = 0;
  a2[10] = 0;
  a2[11] = 0;
  a2[9] = 0;
  WidthOfPlane = CVPixelBufferGetWidthOfPlane(this, 0);
  HeightOfPlane = CVPixelBufferGetHeightOfPlane(this, 0);
  BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(this, 0);
  BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(this, 0);
  *a2 = 0;
  a2[1] = WidthOfPlane | ((unint64_t)HeightOfPlane << 32);
  a2[2] = (BytesPerRowOfPlane << 32) | 1;
  a2[3] = BaseAddressOfPlane;
  v9 = CVPixelBufferGetWidthOfPlane(this, 1uLL);
  v10 = v9 | ((unint64_t)CVPixelBufferGetHeightOfPlane(this, 1uLL) << 32);
  v11 = (CVPixelBufferGetBytesPerRowOfPlane(this, 1uLL) << 32) | 2;
  v12 = CVPixelBufferGetBaseAddressOfPlane(this, 1uLL);
  a2[4] = 0;
  a2[5] = v10;
  a2[6] = v11;
  a2[7] = v12;
  LODWORD(v10) = CVPixelBufferGetWidthOfPlane(this, 1uLL);
  v13 = v10 | ((unint64_t)CVPixelBufferGetHeightOfPlane(this, 1uLL) << 32);
  v14 = (CVPixelBufferGetBytesPerRowOfPlane(this, 1uLL) << 32) | 2;
  result = (char *)CVPixelBufferGetBaseAddressOfPlane(this, 1uLL);
  a2[8] = 0;
  a2[9] = v13;
  a2[10] = v14;
  a2[11] = result + 1;
  return result;
}

double arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::KeyMapBuffer(uint64_t a1, uint64_t a2)
{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = a2;
  return result;
}

{
  double result;

  result = 0.0;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  *(_OWORD *)(a1 + 40) = 0u;
  *(_OWORD *)(a1 + 56) = 0u;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_QWORD *)(a1 + 88) = a2;
  return result;
}

{
  return __ZN5arkit12KeyMapBufferIPKvNSt3__16vectorIhNS3_9allocatorIhEEEEEC1Em(a1, a2);
}

uint64_t *arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::insert(_QWORD *a1, std::locale::__imp *a2, char **a3)
{
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  uint64_t *result;
  unint64_t v10;
  unint64_t v11;
  std::locale v12;

  v6 = a1 + 5;
  std::deque<void const*>::push_front((uint64_t)(a1 + 5), a2);
  if (std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2))
  {
    v7 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)"Key already in buffer", 21);
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v12, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v12);
    std::ostream::put();
    std::ostream::flush();
  }
  v12.__locale_ = a2;
  result = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__emplace_unique_key_args<void const*,std::piecewise_construct_t const&,std::tuple<void const* const&>,std::tuple<>>((uint64_t)a1, a2, (uint64_t)&std::piecewise_construct, &v12)+ 3;
  if (result != (uint64_t *)a3)
    result = std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(result, *a3, a3[1], a3[1] - *a3);
  v10 = a1[10];
  if (v10 > a1[11])
  {
    v11 = v10 - 1;
    v12.__locale_ = *(std::locale::__imp **)(*(_QWORD *)(a1[6] + (((a1[9] + v11) >> 6) & 0x3FFFFFFFFFFFFF8))
                                           + 8 * ((a1[9] + v11) & 0x1FF));
    a1[10] = v11;
    std::deque<void const*>::__maybe_remove_back_spare[abi:ne180100](v6, 1);
    return std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__erase_unique<void const*>(a1, &v12);
  }
  return result;
}

{
  return __ZN5arkit12KeyMapBufferIPKvNSt3__16vectorIhNS3_9allocatorIhEEEEE6insertERKS2_RKS7_(a1, a2, a3);
}

void sub_1B3BAE5CC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

void std::deque<void const*>::push_front(uint64_t a1, _QWORD *a2)
{
  unint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = *(_QWORD *)(a1 + 32);
  if (!v4)
  {
    std::deque<void const*>::__add_front_capacity((void **)a1);
    v4 = *(_QWORD *)(a1 + 32);
  }
  v5 = *(_QWORD *)(a1 + 8);
  v6 = (_QWORD *)(v5 + 8 * (v4 >> 9));
  if (*(_QWORD *)(a1 + 16) == v5)
    v7 = 0;
  else
    v7 = *v6 + 8 * (v4 & 0x1FF);
  if (v7 == *v6)
    v7 = *(v6 - 1) + 4096;
  *(_QWORD *)(v7 - 8) = *a2;
  v8 = *(_QWORD *)(a1 + 40) + 1;
  *(_QWORD *)(a1 + 32) = v4 - 1;
  *(_QWORD *)(a1 + 40) = v8;
}

BOOL arkit::KeyMapBuffer<void const*,std::vector<unsigned char>>::find(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v4;
  _QWORD *v5;

  v4 = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2);
  v5 = v4;
  if (a3 && v4 && v4 + 3 != a3)
    std::vector<unsigned char>::__assign_with_size[abi:ne180100]<unsigned char *,unsigned char *>(a3, (char *)v4[3], (char *)v4[4], v4[4] - v4[3]);
  return v5 != 0;
}

{
  return __ZN5arkit12KeyMapBufferIPKvNSt3__16vectorIhNS3_9allocatorIhEEEEE4findERKS2_PS7_(a1, a2, a3);
}

void *arkit::wrapRawData@<X0>(arkit *this@<X0>, size_t a2@<X1>, _QWORD *a3@<X8>)
{
  void **v5;

  v5 = (void **)std::vector<unsigned char>::vector(a3, a2);
  return memcpy(*v5, this, a2);
}

double ARImageContextFromImageData(void *a1)
{
  double result;

  objc_msgSend(a1, "timestamp");
  return result;
}

void std::deque<void const*>::__add_front_capacity(void **a1)
{
  _BYTE *v2;
  _BYTE *v3;
  unint64_t v4;
  uint64_t v5;
  char *v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  char *v13;
  char *v14;
  int64_t v15;
  uint64_t v16;
  BOOL v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int64_t v21;
  char *v22;
  unint64_t v23;
  char *v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  char *v33;
  _QWORD *v34;
  uint64_t v35;
  void *v36;
  char *v37;
  char *v38;
  char *v39;
  uint64_t v40;
  void *v41;
  void *__p;
  char *v43;
  char *v44;
  char *v45;
  _QWORD *v46;

  v2 = a1[1];
  v3 = a1[2];
  v4 = v3 - v2;
  if (v3 == v2)
    v5 = 0;
  else
    v5 = ((v3 - v2) << 6) - 1;
  v6 = (char *)a1[4];
  if (v5 - (unint64_t)&v6[(_QWORD)a1[5]] < 0x200)
  {
    v7 = (uint64_t)(a1 + 3);
    v8 = a1[3];
    v9 = *a1;
    v10 = v8 - (_BYTE *)*a1;
    if (v4 >= v10)
    {
      if (v8 == v9)
        v11 = 1;
      else
        v11 = v10 >> 2;
      v46 = a1 + 3;
      __p = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v7, v11);
      v43 = (char *)__p;
      v44 = (char *)__p;
      v45 = (char *)__p + 8 * v12;
      v41 = operator new(0x1000uLL);
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *> &>::push_back(&__p, &v41);
      v13 = (char *)a1[1];
      v14 = v44;
      if (v13 == a1[2])
      {
        v33 = (char *)a1[1];
      }
      else
      {
        do
        {
          if (v14 == v45)
          {
            v15 = v43 - (_BYTE *)__p;
            if (v43 <= __p)
            {
              if (v14 == __p)
                v23 = 1;
              else
                v23 = (v14 - (_BYTE *)__p) >> 2;
              v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)v46, v23);
              v26 = v43;
              v14 = &v24[8 * (v23 >> 2)];
              v27 = v44 - v43;
              if (v44 != v43)
              {
                v14 = &v24[8 * (v23 >> 2) + (v27 & 0xFFFFFFFFFFFFFFF8)];
                v28 = 8 * (v27 >> 3);
                v29 = &v24[8 * (v23 >> 2)];
                do
                {
                  v30 = *(_QWORD *)v26;
                  v26 += 8;
                  *(_QWORD *)v29 = v30;
                  v29 += 8;
                  v28 -= 8;
                }
                while (v28);
              }
              v31 = __p;
              __p = v24;
              v43 = &v24[8 * (v23 >> 2)];
              v44 = v14;
              v45 = &v24[8 * v25];
              if (v31)
              {
                operator delete(v31);
                v14 = v44;
              }
            }
            else
            {
              v16 = v15 >> 3;
              v17 = v15 >> 3 < -1;
              v18 = (v15 >> 3) + 2;
              if (v17)
                v19 = v18;
              else
                v19 = v16 + 1;
              v20 = &v43[-8 * (v19 >> 1)];
              v21 = v14 - v43;
              if (v14 != v43)
              {
                memmove(&v43[-8 * (v19 >> 1)], v43, v14 - v43);
                v14 = v43;
              }
              v22 = &v14[-8 * (v19 >> 1)];
              v14 = &v20[v21];
              v43 = v22;
              v44 = &v20[v21];
            }
          }
          v32 = *(_QWORD *)v13;
          v13 += 8;
          *(_QWORD *)v14 = v32;
          v14 = v44 + 8;
          v44 += 8;
        }
        while (v13 != a1[2]);
        v33 = (char *)a1[1];
      }
      v36 = *a1;
      v37 = v43;
      *a1 = __p;
      a1[1] = v37;
      __p = v36;
      v43 = v33;
      v38 = (char *)a1[3];
      v39 = v45;
      a1[2] = v14;
      a1[3] = v39;
      v44 = v13;
      v45 = v38;
      if (v14 - v37 == 8)
        v40 = 256;
      else
        v40 = (uint64_t)a1[4] + 512;
      a1[4] = (void *)v40;
      if (v13 != v33)
        v44 = &v13[(v33 - v13 + 7) & 0xFFFFFFFFFFFFFFF8];
      if (v36)
        operator delete(v36);
    }
    else
    {
      if (v2 == v9)
      {
        __p = operator new(0x1000uLL);
        std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_back(a1, &__p);
        v34 = a1[2];
        __p = (void *)*(v34 - 1);
        a1[2] = v34 - 1;
      }
      else
      {
        __p = operator new(0x1000uLL);
      }
      std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &__p);
      if ((_BYTE *)a1[2] - (_BYTE *)a1[1] == 8)
        v35 = 256;
      else
        v35 = (uint64_t)a1[4] + 512;
      a1[4] = (void *)v35;
    }
  }
  else
  {
    a1[4] = v6 + 512;
    __p = (void *)*((_QWORD *)v3 - 1);
    a1[2] = v3 - 8;
    std::__split_buffer<std::pair<int,int> *,std::allocator<std::pair<int,int> *>>::push_front((uint64_t)a1, &__p);
  }
}

void sub_1B3BAE9BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, uint64_t a12)
{
  void *v12;

  operator delete(v12);
  if (__p)
    operator delete(__p);
  _Unwind_Resume(a1);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x1B5E2D4C8](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x1E0DE4A90]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x1B5E2D4D4](v13);
  return a1;
}

void sub_1B3BAEB10(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x1B5E2D4D4](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x1B3BAEAF0);
}

void sub_1B3BAEB58(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_1B3BAEC8C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

_QWORD *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__emplace_unique_key_args<void const*,std::piecewise_construct_t const&,std::tuple<void const* const&>,std::tuple<>>(uint64_t a1, _QWORD *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint8x8_t v11;
  _QWORD **v12;
  _QWORD *i;
  unint64_t v14;
  _QWORD *v15;
  float v16;
  float v17;
  _BOOL8 v18;
  unint64_t v19;
  unint64_t v20;
  size_t v21;
  uint64_t v22;
  _QWORD *v23;
  unint64_t v24;

  v7 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v8 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v7 >> 47) ^ v7);
  v9 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
  v10 = *(_QWORD *)(a1 + 8);
  if (v10)
  {
    v11 = (uint8x8_t)vcnt_s8((int8x8_t)v10);
    v11.i16[0] = vaddlv_u8(v11);
    if (v11.u32[0] > 1uLL)
    {
      v4 = 0x9DDFEA08EB382D69 * (v8 ^ (v8 >> 47));
      if (v9 >= v10)
        v4 = v9 % v10;
    }
    else
    {
      v4 = v9 & (v10 - 1);
    }
    v12 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v12)
    {
      for (i = *v12; i; i = (_QWORD *)*i)
      {
        v14 = i[1];
        if (v14 == v9)
        {
          if (i[2] == *a2)
            return i;
        }
        else
        {
          if (v11.u32[0] > 1uLL)
          {
            if (v14 >= v10)
              v14 %= v10;
          }
          else
          {
            v14 &= v10 - 1;
          }
          if (v14 != v4)
            break;
        }
      }
    }
  }
  v15 = (_QWORD *)(a1 + 16);
  i = operator new(0x30uLL);
  *i = 0;
  i[1] = v9;
  i[2] = **a4;
  i[3] = 0;
  i[4] = 0;
  i[5] = 0;
  v16 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v17 = *(float *)(a1 + 32);
  if (!v10 || (float)(v17 * (float)v10) < v16)
  {
    v18 = 1;
    if (v10 >= 3)
      v18 = (v10 & (v10 - 1)) != 0;
    v19 = v18 | (2 * v10);
    v20 = vcvtps_u32_f32(v16 / v17);
    if (v19 <= v20)
      v21 = v20;
    else
      v21 = v19;
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(a1, v21);
    v10 = *(_QWORD *)(a1 + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v9 >= v10)
        v4 = v9 % v10;
      else
        v4 = v9;
    }
    else
    {
      v4 = (v10 - 1) & v9;
    }
  }
  v22 = *(_QWORD *)a1;
  v23 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v23)
  {
    *i = *v23;
LABEL_38:
    *v23 = i;
    goto LABEL_39;
  }
  *i = *v15;
  *v15 = i;
  *(_QWORD *)(v22 + 8 * v4) = v15;
  if (*i)
  {
    v24 = *(_QWORD *)(*i + 8);
    if ((v10 & (v10 - 1)) != 0)
    {
      if (v24 >= v10)
        v24 %= v10;
    }
    else
    {
      v24 &= v10 - 1;
    }
    v23 = (_QWORD *)(*(_QWORD *)a1 + 8 * v24);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_1B3BAEFB8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10)
{
  _QWORD *v10;
  uint64_t v11;

  std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100](v11, v10);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100](uint64_t a1, _QWORD *__p)
{
  void *v3;

  if (*(_BYTE *)(a1 + 8))
  {
    v3 = (void *)__p[3];
    if (v3)
    {
      __p[4] = v3;
      operator delete(v3);
    }
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

uint64_t std::deque<void const*>::__maybe_remove_back_spare[abi:ne180100](_QWORD *a1, int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  int v7;

  v3 = a1[1];
  v2 = a1[2];
  if (v2 == v3)
    v4 = 0;
  else
    v4 = ((v2 - v3) << 6) - 1;
  v5 = v4 - (a1[5] + a1[4]);
  if (v5 < 0x200)
    a2 = 1;
  if (v5 < 0x400)
    v7 = a2;
  else
    v7 = 0;
  if ((v7 & 1) == 0)
  {
    operator delete(*(void **)(v2 - 8));
    a1[2] -= 8;
  }
  return v7 ^ 1u;
}

uint64_t *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__erase_unique<void const*>(_QWORD *a1, _QWORD *a2)
{
  uint64_t *result;

  result = std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(a1, a2);
  if (result)
  {
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::erase(a1, result);
    return (uint64_t *)1;
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::find<void const*>(_QWORD *a1, _QWORD *a2)
{
  int8x8_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint8x8_t v6;
  unint64_t v7;
  _QWORD *v8;
  _QWORD *result;
  unint64_t v10;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = 0x9DDFEA08EB382D69 * ((8 * *a2 + 8) ^ HIDWORD(*a2));
  v4 = 0x9DDFEA08EB382D69 * (HIDWORD(*a2) ^ (v3 >> 47) ^ v3);
  v5 = 0x9DDFEA08EB382D69 * (v4 ^ (v4 >> 47));
  v6 = (uint8x8_t)vcnt_s8(v2);
  v6.i16[0] = vaddlv_u8(v6);
  if (v6.u32[0] > 1uLL)
  {
    v7 = v5;
    if (v5 >= *(_QWORD *)&v2)
      v7 = v5 % *(_QWORD *)&v2;
  }
  else
  {
    v7 = v5 & (*(_QWORD *)&v2 - 1);
  }
  v8 = *(_QWORD **)(*a1 + 8 * v7);
  if (!v8)
    return 0;
  result = (_QWORD *)*v8;
  if (*v8)
  {
    do
    {
      v10 = result[1];
      if (v10 == v5)
      {
        if (result[2] == *a2)
          return result;
      }
      else
      {
        if (v6.u32[0] > 1uLL)
        {
          if (v10 >= *(_QWORD *)&v2)
            v10 %= *(_QWORD *)&v2;
        }
        else
        {
          v10 &= *(_QWORD *)&v2 - 1;
        }
        if (v10 != v7)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::erase(_QWORD *a1, uint64_t *a2)
{
  uint64_t v2;
  _QWORD *v3;
  void *__p;
  uint64_t v6;

  v2 = *a2;
  std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::remove(a1, a2, (uint64_t)&__p);
  v3 = __p;
  __p = 0;
  if (v3)
    std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<void const*,std::vector<unsigned char>>,void *>>>::operator()[abi:ne180100]((uint64_t)&v6, v3);
  return v2;
}

_QWORD *std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::remove@<X0>(_QWORD *result@<X0>, _QWORD *a2@<X1>, uint64_t a3@<X8>)
{
  int8x8_t v3;
  unint64_t v4;
  uint8x8_t v5;
  _QWORD *v6;
  _QWORD *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v3 = (int8x8_t)result[1];
  v4 = a2[1];
  v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(_QWORD *)&v3)
      v4 %= *(_QWORD *)&v3;
  }
  else
  {
    v4 &= *(_QWORD *)&v3 - 1;
  }
  v6 = *(_QWORD **)(*result + 8 * v4);
  do
  {
    v7 = v6;
    v6 = (_QWORD *)*v6;
  }
  while (v6 != a2);
  if (v7 == result + 2)
    goto LABEL_18;
  v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(_QWORD *)&v3)
      v8 %= *(_QWORD *)&v3;
  }
  else
  {
    v8 &= *(_QWORD *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a2)
      goto LABEL_19;
    v9 = *(_QWORD *)(*a2 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(_QWORD *)&v3)
        v9 %= *(_QWORD *)&v3;
    }
    else
    {
      v9 &= *(_QWORD *)&v3 - 1;
    }
    if (v9 != v4)
LABEL_19:
      *(_QWORD *)(*result + 8 * v4) = 0;
  }
  v10 = *a2;
  if (*a2)
  {
    v11 = *(_QWORD *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(_QWORD *)&v3)
        v11 %= *(_QWORD *)&v3;
    }
    else
    {
      v11 &= *(_QWORD *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(_QWORD *)(*result + 8 * v11) = v7;
      v10 = *a2;
    }
  }
  *v7 = v10;
  *a2 = 0;
  --result[3];
  *(_QWORD *)a3 = a2;
  *(_QWORD *)(a3 + 8) = result + 2;
  *(_BYTE *)(a3 + 16) = 1;
  return result;
}

id NSStringFromARCollaborationData(void *a1)
{
  void *v1;
  id v2;
  objc_class *v3;
  void *v4;
  void *v5;
  uint64_t v6;
  const __CFString *v7;
  uint64_t v8;
  void *v9;
  void *v10;
  void *v11;

  v1 = (void *)MEMORY[0x1E0CB37A0];
  v2 = a1;
  v3 = (objc_class *)objc_opt_class();
  NSStringFromClass(v3);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v1, "stringWithFormat:", CFSTR("<%@: %p"), v4, v2);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  v6 = objc_msgSend(v2, "priority");
  v7 = CFSTR("optional");
  if (!v6)
    v7 = CFSTR("critical");
  objc_msgSend(v5, "appendFormat:", CFSTR(" priority=%@"), v7);
  objc_msgSend(v5, "appendFormat:", CFSTR(" version=%ti"), objc_msgSend(v2, "version"));
  objc_msgSend(v2, "timestamp");
  objc_msgSend(v5, "appendFormat:", CFSTR(" timestamp=%f"), v8);
  objc_msgSend(v2, "vioData");
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "appendFormat:", CFSTR(" vioData=%tu"), objc_msgSend(v9, "length"));

  NSStringFromSLAMCMDataType(objc_msgSend(v2, "vioDataType"));
  v10 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v5, "appendFormat:", CFSTR(" vioDataType=%@"), v10);

  objc_msgSend(v5, "appendFormat:", CFSTR(" vioSessionID=%llX"), objc_msgSend(v2, "vioSessionID"));
  objc_msgSend(v2, "anchors");
  v11 = (void *)objc_claimAutoreleasedReturnValue();

  objc_msgSend(v5, "appendFormat:", CFSTR(" anchors=%tu"), objc_msgSend(v11, "count"));
  objc_msgSend(v5, "appendString:", CFSTR(">"));
  return v5;
}

void sub_1B3BAFDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, void (*a12)(char *))
{
  a12(&a10);
  _Unwind_Resume(a1);
}

uint64_t __bufferContainsSegmentedPeople_block_invoke(uint64_t a1)
{
  return CVPixelBufferUnlockBaseAddress(*(CVPixelBufferRef *)(a1 + 32), 1uLL);
}

uint64_t arkit::ChromaFilter::ycbcr2xyz@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v3[2];
  _OWORD v4[3];

  v4[0] = xmmword_1B3C0BA24;
  v4[1] = unk_1B3C0BA34;
  v4[2] = xmmword_1B3C0BA44;
  v3[0] = (uint64_t)v4;
  v3[1] = a1;
  *(_QWORD *)a2 = 0;
  *(_DWORD *)(a2 + 8) = 0;
  return cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(a2, v3);
}

BOOL arkit::ChromaFilter::xyz2uvl(float32x2_t *a1, float32x2_t *a2, double a3, double a4)
{
  _D0 = *a1;
  _S1 = 15.0;
  __asm { FMLA            S2, S1, V0.S[1] }
  *(float *)&a4 = _S2 + (float)(a1[1].f32[0] * 3.0);
  if (*(float *)&a4 > 0.0)
  {
    *a2 = vdiv_f32(vmul_f32(_D0, (float32x2_t)0x40C0000040800000), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a4, 0));
    a2[1].i32[0] = _D0.i32[1];
  }
  return *(float *)&a4 > 0.0;
}

uint64_t arkit::ChromaFilter::uvl2ind(uint64_t a1)
{
  uint64_t result;
  float32x2_t v3;
  float v4;
  float32x2_t v6;
  double v7;
  int32x2_t v13;

  result = 0;
  if (*(float *)a1 >= 0.15 && *(float *)a1 <= 0.65)
  {
    result = 0;
    v3.i32[0] = *(_DWORD *)(a1 + 4);
    if (v3.f32[0] >= 0.15 && v3.f32[0] <= 0.65)
    {
      v4 = *(float *)(a1 + 8);
      if (v4 >= 0.0 && v4 <= 1.0)
      {
        v3.i32[1] = *(_DWORD *)a1;
        v6 = vadd_f32(v3, (float32x2_t)vdup_n_s32(0xBE19999A));
        v7 = fmin((float)(ceilf(v4 * 50.0) + 1.0), 50.0);
        __asm { FMOV            V2.2S, #1.0 }
        v13 = vmul_s32((int32x2_t)vcvt_u32_f32(vadd_f32(vrndp_f32(vmul_f32(v6, (float32x2_t)vdup_n_s32(0x42C80000u))), _D2)), (int32x2_t)0x466F45D012740A5);
        return veor_s8((int8x8_t)v13, (int8x8_t)vdup_lane_s32(v13, 1)).u32[0] ^ (83492791 * v7);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t arkit::ChromaFilter::filter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  unsigned int *v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  int v19;
  int v20;
  float v22;
  float v23;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int32x2_t v34;
  uint64_t *v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  float32x2_t v41;
  float v42;
  _BYTE v43[3];
  uint64_t v44;
  uint64_t v45;
  _QWORD v46[5];
  uint64_t v47[2];
  _OWORD __dst[343];
  uint64_t v49;

  v8 = MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = v9;
  v11 = (unsigned int *)v8;
  v13 = v12;
  v49 = *MEMORY[0x1E0C80C00];
  memcpy(__dst, &unk_1B3C0BA54, sizeof(__dst));
  std::unordered_set<unsigned int>::unordered_set((uint64_t)v46, (unsigned int *)__dst, 1372);
  v14 = 0xAAAAAAAAAAAAAAABLL * ((v10[1] - *v10) >> 2);
  LOBYTE(__dst[0]) = 0;
  std::vector<BOOL>::vector(v13, v14, (unsigned __int8 *)__dst);
  v44 = 0;
  v45 = 0;
  v16 = *v10;
  v15 = v10[1];
  if (v15 != *v10)
  {
    v17 = 0;
    v18 = 0;
    v19 = 0;
    v20 = 0;
    _S8 = 15.0;
    while (1)
    {
      v22 = *(float *)(v16 + v17);
      if (v22 < (float)v11[2])
      {
        v23 = *(float *)(v16 + v17 + 4);
        if (v23 >= 0.0 && v22 >= 0.0 && v23 < (float)v11[3])
          break;
      }
LABEL_18:
      ++v18;
      v17 += 12;
      if (0xAAAAAAAAAAAAAAABLL * ((v15 - v16) >> 2) <= v18)
        goto LABEL_21;
    }
    arkit::ImageViewYUV::at((arkit::ImageViewYUV *)v11, v22, v23, v43);
    LOBYTE(v25) = v43[0];
    LOBYTE(v26) = v43[1];
    LOBYTE(v27) = v43[2];
    *(float *)&v44 = (float)v25 / 255.0;
    *((float *)&v44 + 1) = (float)v26 / 255.0;
    *(float *)&v45 = (float)v27 / 255.0;
    HIDWORD(v45) = 1065353216;
    __dst[0] = xmmword_1B3C0BA24;
    __dst[1] = unk_1B3C0BA34;
    __dst[2] = xmmword_1B3C0BA44;
    v47[0] = (uint64_t)__dst;
    v47[1] = (uint64_t)&v44;
    v41 = 0;
    v42 = 0.0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>((uint64_t)&v41, v47);
    _V0.S[1] = v41.i32[1];
    __asm { FMLA            S2, S8, V0.S[1] }
    *(float *)v34.i32 = _S2 + (float)(v42 * 3.0);
    if (*(float *)v34.i32 <= 0.0)
    {
      v36 = (uint64_t *)(*v13 + 8 * (v18 >> 6));
      v37 = 1 << v18;
    }
    else
    {
      *(float32x2_t *)&__dst[0] = vdiv_f32(vmul_f32(v41, (float32x2_t)0x40C0000040800000), (float32x2_t)vdup_lane_s32(v34, 0));
      DWORD2(__dst[0]) = v41.i32[1];
      LODWORD(v47[0]) = arkit::ChromaFilter::uvl2ind((uint64_t)__dst);
      v35 = std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(v46, (unsigned int *)v47);
      v36 = (uint64_t *)(*v13 + 8 * (v18 >> 6));
      v37 = 1 << v18;
      if (v35)
      {
        v38 = *v36 | v37;
LABEL_15:
        *v36 = v38;
        if ((v38 & v37) != 0)
          ++v20;
        ++v19;
        v16 = *v10;
        v15 = v10[1];
        goto LABEL_18;
      }
    }
    v38 = *v36 & ~v37;
    goto LABEL_15;
  }
  v20 = 0;
  v19 = 0;
LABEL_21:
  if (v19 > 2 * v20)
  {
    v39 = v13[1];
    if (v39)
    {
      *(_QWORD *)&__dst[0] = *v13;
      DWORD2(__dst[0]) = 0;
      std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(__dst, v39);
    }
  }
  return std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table((uint64_t)v46);
}

void sub_1B3BB1D38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  void **v6;
  va_list va;

  va_start(va, a6);
  if (*v6)
    operator delete(*v6);
  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t arkit::ImageViewYUV::at@<X0>(arkit::ImageViewYUV *this@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, _BYTE *a4@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  BOOL v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  BOOL v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t result;
  int v33;
  unint64_t v34;
  uint64_t v35;

  if (*((_DWORD *)this + 2) <= a2 || *((_DWORD *)this + 3) <= a3)
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  v4 = 0;
  v5 = *((_QWORD *)this + 1);
  v34 = a2 | (unint64_t)(a3 << 32);
  v35 = v5;
  do
  {
    v6 = *(_DWORD *)((char *)&v34 + v4);
    v7 = *(_DWORD *)((char *)&v35 + v4);
    v8 = v6 >= v7 || v4 == 4;
    v4 += 4;
  }
  while (!v8);
  if (v6 >= v7)
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  if (*((_DWORD *)this + 10) <= a2 >> 1
    || (v9 = a3 >> 1, *((_DWORD *)this + 11) <= v9))
  {
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  }
  v10 = 0;
  v11 = *((_QWORD *)this + 3);
  v12 = *(_QWORD *)this;
  v13 = *((_DWORD *)this + 4);
  v14 = *((_DWORD *)this + 5);
  v15 = a2 >> 1;
  v16 = *((_QWORD *)this + 5);
  v34 = v15 | (v9 << 32);
  v35 = v16;
  do
  {
    v17 = *(_DWORD *)((char *)&v34 + v10);
    v18 = *(_DWORD *)((char *)&v35 + v10);
    v19 = v17 >= v18 || v10 == 4;
    v10 += 4;
  }
  while (!v19);
  if (v17 >= v18)
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  if (*((_DWORD *)this + 18) <= v15 || *((_DWORD *)this + 19) <= v9)
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  v20 = 0;
  v21 = *((_QWORD *)this + 7);
  v22 = *((_QWORD *)this + 4);
  v23 = *((_DWORD *)this + 12);
  v24 = *((_DWORD *)this + 13);
  v34 = v15 | (v9 << 32);
  v35 = *((_QWORD *)this + 9);
  do
  {
    v25 = *(_DWORD *)((char *)&v34 + v20);
    v26 = *(_DWORD *)((char *)&v35 + v20);
    v27 = v25 >= v26 || v20 == 4;
    v20 += 4;
  }
  while (!v27);
  if (v25 >= v26)
    arkit::ImageViewYUV::at((uint64_t)this, a2, a3);
  v28 = v22 + (v23 * v15 + v24 * v9);
  v29 = v12 + (v13 * a2 + v14 * a3);
  v30 = *((_QWORD *)this + 11);
  v31 = *((_QWORD *)this + 8);
  v33 = *((_DWORD *)this + 20);
  result = *((unsigned int *)this + 21);
  *a4 = *(_BYTE *)(v11 + v29);
  a4[1] = *(_BYTE *)(v21 + v28);
  a4[2] = *(_BYTE *)(v30 + v31 + (v33 * v15 + result * v9));
  return result;
}

uint64_t *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::find<unsigned int>(_QWORD *a1, unsigned int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (v2.i32[0] - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

uint64_t cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(uint64_t result, uint64_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  float *v4;
  uint64_t i;
  uint64_t v6;
  float v7;
  float *v8;
  float v9;
  uint64_t v10;
  int v11;

  v2 = result;
  v3 = *a2;
  if (*a2 == result || (v4 = (float *)a2[1], v4 == (float *)result))
  {
    v11 = 0;
    v10 = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,4u,false>,cva::Matrix<float,4u,1u,false>>(&v10);
    *(_QWORD *)v2 = v10;
    *(_DWORD *)(v2 + 8) = v11;
  }
  else
  {
    for (i = 0; i != 3; ++i)
    {
      v6 = 0;
      v7 = 0.0;
      v8 = v4;
      do
      {
        v9 = *v8++;
        v7 = v7 + (float)(*(float *)(v3 + v6) * v9);
        v6 += 12;
      }
      while (v6 != 48);
      *(float *)(result + 4 * i) = v7;
      v3 += 4;
    }
  }
  return result;
}

uint64_t std::unordered_set<unsigned int>::unordered_set(uint64_t a1, unsigned int *a2, uint64_t a3)
{
  uint64_t v5;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = 1065353216;
  if (a3)
  {
    v5 = 4 * a3;
    do
    {
      std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(a1, a2, a2);
      ++a2;
      v5 -= 4;
    }
    while (v5);
  }
  return a1;
}

void sub_1B3BB20B8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t a1, unsigned int *a2, _DWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  *((_DWORD *)v10 + 4) = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<void const*,std::vector<unsigned char>>,std::__unordered_map_hasher<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::hash<void const*>,std::equal_to<void const*>,true>,std::__unordered_map_equal<void const*,std::__hash_value_type<void const*,std::vector<unsigned char>>,std::equal_to<void const*>,std::hash<void const*>,true>,std::allocator<std::__hash_value_type<void const*,std::vector<unsigned char>>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = ((_DWORD)v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_1B3BB22D4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

uint64_t std::__hash_table<unsigned int,std::hash<unsigned int>,std::equal_to<unsigned int>,std::allocator<unsigned int>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

_QWORD *std::vector<BOOL>::vector(_QWORD *a1, unint64_t a2, unsigned __int8 *a3)
{
  int v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v13;
  int v14;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<BOOL>::__vallocate[abi:ne180100](a1, a2);
    v6 = *a3;
    v7 = a1[1];
    v8 = v7 + a2;
    a1[1] = v7 + a2;
    if (v7)
    {
      v9 = v8 - 1;
      if (((v8 - 1) ^ (v7 - 1)) < 0x40)
      {
LABEL_10:
        v13 = *a1 + 8 * (v7 >> 6);
        v14 = v7 & 0x3F;
        if (v6)
          std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(&v13, a2);
        else
          std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>((uint64_t)&v13, a2);
        return a1;
      }
    }
    else
    {
      v9 = v8 - 1;
    }
    v10 = v9 >> 6;
    if (v8 >= 0x41)
      v11 = v10;
    else
      v11 = 0;
    *(_QWORD *)(*a1 + 8 * v11) = 0;
    goto LABEL_10;
  }
  return a1;
}

void *std::vector<BOOL>::__vallocate[abi:ne180100](_QWORD *a1, uint64_t a2)
{
  void *result;
  uint64_t v4;

  if (a2 < 0)
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  result = std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)(a1 + 2), ((unint64_t)(a2 - 1) >> 6) + 1);
  *a1 = result;
  a1[1] = 0;
  a1[2] = v4;
  return result;
}

_QWORD *std::__fill_n[abi:ne180100]<true,std::vector<BOOL>>(_QWORD *result, unint64_t a2)
{
  unint64_t v2;
  _QWORD *v3;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v3 = result;
  v4 = *((_DWORD *)result + 2);
  v5 = (_QWORD *)*result;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ |= (0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4);
    v2 = a2 - v6;
    *result = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    result = memset(v5, 255, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *v3 = v8;
    *v8 |= 0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F);
  }
  return result;
}

void std::__fill_n[abi:ne180100]<false,std::vector<BOOL>>(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  int v4;
  _QWORD *v5;
  unint64_t v6;
  unint64_t v7;
  _QWORD *v8;

  v2 = a2;
  v4 = *(_DWORD *)(a1 + 8);
  v5 = *(_QWORD **)a1;
  if (v4)
  {
    if ((64 - v4) >= a2)
      v6 = a2;
    else
      v6 = (64 - v4);
    *v5++ &= ~((0xFFFFFFFFFFFFFFFFLL >> (64 - v4 - v6)) & (-1 << v4));
    v2 = a2 - v6;
    *(_QWORD *)a1 = v5;
  }
  v7 = v2 >> 6;
  if (v2 >= 0x40)
    bzero(v5, 8 * v7);
  if ((v2 & 0x3F) != 0)
  {
    v8 = &v5[v7];
    *(_QWORD *)a1 = v8;
    *v8 &= ~(0xFFFFFFFFFFFFFFFFLL >> -(v2 & 0x3F));
  }
}

void OUTLINED_FUNCTION_0_2(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 321, a4);
}

void OUTLINED_FUNCTION_1_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 277, a4);
}

arkit::FacialLightEstimation *arkit::FacialLightEstimation::FacialLightEstimation(arkit::FacialLightEstimation *this)
{
  uint64_t v2;
  void *__p;
  char v5;
  char v6;

  *(_OWORD *)((char *)this + 24) = 0u;
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  *((_DWORD *)this + 4) = 0;
  *(_OWORD *)((char *)this + 40) = 0u;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *((_QWORD *)this + 11) = 0;
  v2 = operator new();
  LOBYTE(__p) = 0;
  v6 = 0;
  arkit::PrecomputedFaceData::PrecomputedFaceData(v2, &__p);
  std::shared_ptr<arkit::PrecomputedFaceData>::shared_ptr[abi:ne180100]<arkit::PrecomputedFaceData,void>((_QWORD *)this + 12, v2);
  if (v6 && v5 < 0)
    operator delete(__p);
  *((_BYTE *)this + 112) = 0;
  *((_BYTE *)this + 148) = 0;
  *((_QWORD *)this + 20) = 0;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 19) = 0;
  return this;
}

void sub_1B3BB2CE0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  uint64_t v15;
  void **v16;
  void *v18;
  void *v19;

  free(*(void **)(v15 + 72));
  v18 = *(void **)(v15 + 48);
  if (v18)
  {
    *(_QWORD *)(v15 + 56) = v18;
    operator delete(v18);
  }
  v19 = *v16;
  if (*v16)
  {
    *(_QWORD *)(v15 + 32) = v19;
    operator delete(v19);
  }
  free(*(void **)v15);
  _Unwind_Resume(a1);
}

void arkit::FacialLightEstimation::estimateLight(uint64_t a1@<X0>, uint64_t a2@<X1>, uint64_t a3@<X2>, uint64_t a4@<X3>, uint64_t a5@<X8>)
{
  void *v9;
  unsigned __int8 *v10;
  unsigned __int8 *v11;
  char *v12;
  int v13;
  char *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  char *v29;
  char *v30;
  unint64_t v31;
  unint64_t v32;
  _BOOL4 v33;
  char *v34;
  char *v35;
  int *v36;
  int64_t v37;
  unint64_t v38;
  float *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  int v43;
  uint64_t v44;
  uint64_t v45;
  void *v46;
  char *v47;
  uint64_t v48;
  unint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  uint64_t v54;
  int64x2_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  int64x2_t v60;
  uint64_t v61;
  char *v62;
  void **v63;
  _QWORD *v64;
  _QWORD *v65;
  _QWORD *v66;
  uint64_t v67;
  char *v68;
  char *v69;
  uint64_t v70;
  unint64_t v71;
  uint64_t v72;
  unint64_t v73;
  char *v74;
  char *v75;
  uint64_t v76;
  uint64_t i;
  __int128 v78;
  float v79;
  float v80;
  float v81;
  float32x2_t v82;
  float64x2_t v83;
  double v84;
  float v85;
  unsigned int v86;
  __int128 v87;
  uint64_t v88;
  float v89;
  _OWORD v91[2];
  int v92;
  __int128 v93[2];
  __int128 v94;
  __int128 v95;
  float v96;
  void *v97[2];
  __int128 v98;
  int v99;
  _BYTE __p[32];
  _QWORD *v101;
  void *v102;
  _QWORD *v103;
  int v104;
  int64x2_t v105;
  _QWORD v106[2];
  _BYTE *v107;
  _BYTE *v108;
  int *v109;
  int *v110;
  uint64_t v111;
  char *v112;
  char *v113;
  char *v114;
  unsigned __int8 *v115;
  unsigned __int8 *v116;

  arkit::PrecomputedFaceData::getValidSampleIDs(*(arkit::PrecomputedFaceData **)(a1 + 96), __p);
  v9 = *(void **)(a1 + 48);
  if (v9)
  {
    *(_QWORD *)(a1 + 56) = v9;
    operator delete(v9);
    *(_QWORD *)(a1 + 48) = 0;
    *(_QWORD *)(a1 + 56) = 0;
    *(_QWORD *)(a1 + 64) = 0;
  }
  *(_OWORD *)(a1 + 48) = *(_OWORD *)__p;
  *(_QWORD *)(a1 + 64) = *(_QWORD *)&__p[16];
  v88 = a3;
  arkit::FaceTrackingData::filteredLandmarks(a3, (int **)(a1 + 48), (uint64_t)&v115);
  v112 = 0;
  v113 = 0;
  v114 = 0;
  v10 = v115;
  v11 = v116;
  if (v115 != v116)
  {
    v12 = 0;
    do
    {
      v13 = v10[8];
      if (v12 >= v114)
      {
        v15 = v112;
        v16 = (v12 - v112) >> 2;
        v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62)
          std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
        v18 = v114 - v112;
        if ((v114 - v112) >> 1 > v17)
          v17 = v18 >> 1;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL)
          v19 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v19 = v17;
        if (v19)
        {
          v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v114, v19);
          v15 = v112;
          v12 = v113;
        }
        else
        {
          v20 = 0;
        }
        v21 = &v20[4 * v16];
        *(_DWORD *)v21 = v13;
        v14 = v21 + 4;
        while (v12 != v15)
        {
          v22 = *((_DWORD *)v12 - 1);
          v12 -= 4;
          *((_DWORD *)v21 - 1) = v22;
          v21 -= 4;
        }
        v112 = v21;
        v113 = v14;
        v114 = &v20[4 * v19];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *(_DWORD *)v12 = v13;
        v14 = v12 + 4;
      }
      v113 = v14;
      v10 += 12;
      v12 = v14;
    }
    while (v10 != v11);
  }
  if (*(_BYTE *)(a2 + 9))
  {
    kdebug_trace();
    arkit::ChromaFilter::filter(a4, (uint64_t)&v115, v23, v24, v25, v26, v27, v28);
    kdebug_trace();
    v29 = v112;
    v30 = *(char **)__p;
    if (v113 == v112)
    {
      if (!*(_QWORD *)__p)
        goto LABEL_33;
    }
    else
    {
      v31 = 0;
      v32 = (v113 - v112) >> 2;
      if (v32 <= 1)
        v32 = 1;
      do
      {
        v33 = ((*(_QWORD *)&v30[(v31 >> 3) & 0x1FFFFFFFFFFFFFF8] >> v31) & 1) != 0 && *(_DWORD *)&v29[4 * v31] == 1;
        *(_DWORD *)&v29[4 * v31++] = v33;
      }
      while (v32 != v31);
    }
    operator delete(v30);
  }
LABEL_33:
  v109 = 0;
  v110 = 0;
  v111 = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v109, *(const void **)(a1 + 48), *(_QWORD *)(a1 + 56), (uint64_t)(*(_QWORD *)(a1 + 56) - *(_QWORD *)(a1 + 48)) >> 2);
  v34 = v112;
  v35 = v113;
  if (v112 != v113)
  {
    v36 = v109;
    do
    {
      if (*(_DWORD *)v34)
      {
        ++v36;
      }
      else
      {
        v37 = (char *)v110 - (char *)(v36 + 1);
        if (v110 != v36 + 1)
          memmove(v36, v36 + 1, (char *)v110 - (char *)(v36 + 1));
        v110 = (int *)((char *)v36 + v37);
      }
      v34 += 4;
    }
    while (v34 != v35);
  }
  arkit::FaceTrackingData::filteredLandmarks(v88, &v109, (uint64_t)&v107);
  if (0xAAAAAAAAAAAAAAABLL * ((v108 - v107) >> 2) != v110 - v109)
    __assert_rtn("estimateLight", "FacialLightEstimation.cpp", 67, "sampleIndices.size() == samplePositions.size()");
  if (v108 == v107)
    goto LABEL_48;
  arkit::FacialLightEstimation::populateValidImageSamples(a1, a4, (uint64_t *)&v109, &v107, &v112);
  v38 = *(unsigned int *)(a1 + 16);
  if ((_DWORD)v38)
  {
    v39 = *(float **)a1;
    v40 = *(unsigned int *)(a1 + 16);
    do
    {
      *v39 = powf(*v39, 2.2);
      ++v39;
      --v40;
    }
    while (v40);
  }
  if ((_DWORD)v38 == *(_DWORD *)(a1 + 88) && v38 >= *(_DWORD *)(a1 + 92))
  {
    v105 = 0uLL;
    v106[0] = 0;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::reserve(v105.i64, v38);
    v41 = *(unsigned int *)(a1 + 88);
    if ((_DWORD)v41)
    {
      v42 = 0;
      do
      {
        if (v42 >= *(unsigned int *)(a1 + 16))
          __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
        if (v42 >= v41)
          __assert_rtn("row", "matrixmixin.h", 1063, "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")");
        v43 = *(_DWORD *)(a1 + 92);
        v44 = *(_QWORD *)(a1 + 72) + 4 * v42;
        LODWORD(v94) = *(_DWORD *)(*(_QWORD *)a1 + 4 * v42);
        DWORD2(v94) = v43;
        *(_QWORD *)&v95 = v44;
        *((_QWORD *)&v95 + 1) = __PAIR64__(v42, v41);
        std::pair<float,cva::Matrix<float,1u,0u,false>>::pair[abi:ne180100]<float,cva::MatrixRef<float,1u,0u,false>,0>((uint64_t)v97, (uint64_t)&v94);
        v45 = v105.i64[1];
        if (v105.i64[1] >= v106[0])
        {
          v48 = (v105.i64[1] - v105.i64[0]) >> 5;
          v49 = v48 + 1;
          if ((unint64_t)(v48 + 1) >> 59)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v50 = v106[0] - v105.i64[0];
          if ((v106[0] - v105.i64[0]) >> 4 > v49)
            v49 = v50 >> 4;
          if ((unint64_t)v50 >= 0x7FFFFFFFFFFFFFE0)
            v51 = 0x7FFFFFFFFFFFFFFLL;
          else
            v51 = v49;
          v101 = v106;
          v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>((uint64_t)v106, v51);
          v53 = &v52[32 * v48];
          *(_QWORD *)__p = v52;
          *(_QWORD *)&__p[8] = v53;
          *(_QWORD *)&__p[24] = &v52[32 * v54];
          *(_DWORD *)v53 = v97[0];
          *((_QWORD *)v53 + 1) = 0;
          *((_QWORD *)v53 + 2) = 0;
          *((void **)v53 + 1) = v97[1];
          v97[1] = 0;
          *((_QWORD *)v53 + 2) = v98;
          *(_QWORD *)&v98 = 0;
          *((_DWORD *)v53 + 6) = DWORD2(v98);
          DWORD2(v98) = 0;
          v47 = v53 + 32;
          *(_QWORD *)&__p[16] = v53 + 32;
          v55 = v105;
          v56 = *(_QWORD *)&__p[8];
          if (v105.i64[1] == v105.i64[0])
          {
            v60 = vdupq_n_s64(v105.u64[1]);
          }
          else
          {
            v57 = 0;
            do
            {
              v58 = v56 + v57;
              v59 = v55.i64[1] + v57;
              *(_DWORD *)(v58 - 32) = *(_DWORD *)(v55.i64[1] + v57 - 32);
              *(_QWORD *)(v58 - 24) = 0;
              *(_QWORD *)(v58 - 16) = 0;
              *(_QWORD *)(v58 - 24) = *(_QWORD *)(v55.i64[1] + v57 - 24);
              *(_QWORD *)(v59 - 24) = 0;
              *(_QWORD *)(v58 - 16) = *(_QWORD *)(v55.i64[1] + v57 - 16);
              *(_QWORD *)(v59 - 16) = 0;
              *(_DWORD *)(v58 - 8) = *(_DWORD *)(v55.i64[1] + v57 - 8);
              *(_DWORD *)(v59 - 8) = 0;
              v57 -= 32;
            }
            while (v55.i64[1] + v57 != v55.i64[0]);
            v60 = v105;
            v47 = *(char **)&__p[16];
            v56 += v57;
          }
          v105.i64[0] = v56;
          v105.i64[1] = (uint64_t)v47;
          *(int64x2_t *)&__p[8] = v60;
          v61 = v106[0];
          v106[0] = *(_QWORD *)&__p[24];
          *(_QWORD *)&__p[24] = v61;
          *(_QWORD *)__p = v60.i64[0];
          std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)__p);
          v46 = v97[1];
        }
        else
        {
          v46 = 0;
          *(_DWORD *)v105.i64[1] = v97[0];
          *(_QWORD *)(v45 + 8) = 0;
          *(_QWORD *)(v45 + 16) = 0;
          *(void **)(v45 + 8) = v97[1];
          *(_QWORD *)(v45 + 16) = v98;
          *(_DWORD *)(v45 + 24) = DWORD2(v98);
          v97[1] = 0;
          *(_QWORD *)&v98 = 0;
          DWORD2(v98) = 0;
          v47 = (char *)(v45 + 32);
        }
        ++v42;
        v105.i64[1] = (uint64_t)v47;
        free(v46);
        v41 = *(unsigned int *)(a1 + 88);
      }
      while (v42 < v41);
    }
    arkit::runSolver(v105.i64, a2, (uint64_t)__p);
    *(_OWORD *)v97 = *(_OWORD *)__p;
    v98 = *(_OWORD *)&__p[16];
    v99 = (int)v101;
    v63 = (void **)(a1 + 152);
    v62 = *(char **)(a1 + 152);
    *(_QWORD *)(a1 + 160) = v62;
    v64 = v102;
    v65 = v103;
    if (v102 != v103)
    {
      v66 = (_QWORD *)(a1 + 168);
      do
      {
        v67 = v109[*v64];
        if ((unint64_t)v62 >= *v66)
        {
          v69 = (char *)*v63;
          v70 = (v62 - (_BYTE *)*v63) >> 3;
          v71 = v70 + 1;
          if ((unint64_t)(v70 + 1) >> 61)
            std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
          v72 = *v66 - (_QWORD)v69;
          if (v72 >> 2 > v71)
            v71 = v72 >> 2;
          if ((unint64_t)v72 >= 0x7FFFFFFFFFFFFFF8)
            v73 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v73 = v71;
          if (v73)
          {
            v74 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(a1 + 168, v73);
            v69 = *(char **)(a1 + 152);
            v62 = *(char **)(a1 + 160);
          }
          else
          {
            v74 = 0;
          }
          v75 = &v74[8 * v70];
          *(_QWORD *)v75 = v67;
          v68 = v75 + 8;
          while (v62 != v69)
          {
            v76 = *((_QWORD *)v62 - 1);
            v62 -= 8;
            *((_QWORD *)v75 - 1) = v76;
            v75 -= 8;
          }
          *(_QWORD *)(a1 + 152) = v75;
          *(_QWORD *)(a1 + 160) = v68;
          *(_QWORD *)(a1 + 168) = &v74[8 * v73];
          if (v69)
            operator delete(v69);
        }
        else
        {
          *(_QWORD *)v62 = v67;
          v68 = v62 + 8;
        }
        *(_QWORD *)(a1 + 160) = v68;
        ++v64;
        v62 = v68;
      }
      while (v64 != v65);
    }
    for (i = 0; i != 36; i += 4)
      ;
    v78 = *(_OWORD *)(v88 + 16);
    v94 = *(_OWORD *)v88;
    v95 = v78;
    v96 = *(float *)(v88 + 32);
    arkit::shct::rotateShCoeff((uint64_t)v97, (float *)&v94, (uint64_t)v93);
    v79 = *((float *)&v94 + 2);
    v80 = *((float *)&v95 + 1);
    v81 = v96;
    v89 = atan2f(*((float *)&v95 + 1), v96);
    v82.f32[0] = atan2f(-v79, sqrtf((float)(v81 * v81) + (float)(v80 * v80)));
    v82.f32[1] = v89;
    v83 = vsubq_f64((float64x2_t)xmmword_1B3C0CFD0, vabsq_f64(vdivq_f64(vcvtq_f64_f32(vmul_f32(v82, (float32x2_t)vdup_n_s32(0x43340000u))), (float64x2_t)vdupq_n_s64(0x400921FB54442D18uLL))));
    if (v83.f64[0] >= v83.f64[1])
      v83.f64[0] = v83.f64[1];
    v84 = *(float *)a2;
    v85 = v83.f64[0];
    *(float *)&v86 = 1.0 / (float)(expf(v85 * -0.8) + 1.0) * v84;
    arkit::ExponentialSmoother<cva::Matrix<float,9u,1u,false>>::step(a1 + 112, v93, (uint64_t)v91, v86);
    v87 = v91[1];
    *(_OWORD *)a5 = v91[0];
    *(_OWORD *)(a5 + 16) = v87;
    *(_DWORD *)(a5 + 32) = v92;
    *(_DWORD *)(a5 + 36) = v104;
    if (v102)
    {
      v103 = v102;
      operator delete(v102);
    }
    *(_QWORD *)__p = &v105;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  }
  else
  {
LABEL_48:
    *(_QWORD *)(a5 + 32) = 0;
    *(_OWORD *)a5 = 0u;
    *(_OWORD *)(a5 + 16) = 0u;
  }
  if (v107)
  {
    v108 = v107;
    operator delete(v107);
  }
  if (v109)
  {
    v110 = v109;
    operator delete(v109);
  }
  if (v112)
  {
    v113 = v112;
    operator delete(v112);
  }
  if (v115)
  {
    v116 = v115;
    operator delete(v115);
  }
}

void sub_1B3BB35D8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,void *__p,uint64_t a39)
{
  uint64_t v39;
  void *v41;
  void *v42;
  void *v43;
  void *v44;

  if (__p)
  {
    a39 = (uint64_t)__p;
    operator delete(__p);
  }
  a27 = v39 - 256;
  std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a27);
  v41 = *(void **)(v39 - 224);
  if (v41)
  {
    *(_QWORD *)(v39 - 216) = v41;
    operator delete(v41);
  }
  v42 = *(void **)(v39 - 200);
  if (v42)
  {
    *(_QWORD *)(v39 - 192) = v42;
    operator delete(v42);
  }
  v43 = *(void **)(v39 - 176);
  if (v43)
  {
    *(_QWORD *)(v39 - 168) = v43;
    operator delete(v43);
  }
  v44 = *(void **)(v39 - 152);
  if (v44)
  {
    *(_QWORD *)(v39 - 144) = v44;
    operator delete(v44);
  }
  _Unwind_Resume(a1);
}

void arkit::FacialLightEstimation::populateValidImageSamples(uint64_t a1, uint64_t a2, uint64_t *a3, _QWORD *a4, _QWORD *a5)
{
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  float *v18;
  float v19;
  float v20;
  float v21;
  unint64_t v22;
  char *v23;
  _DWORD *v24;
  char *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unsigned int v36;
  unsigned int v37;
  BOOL v38;
  _QWORD *v39;
  cva::Logger *RTF;
  uint64_t v41;
  int v42;
  uint64_t v43;
  _DWORD *v44;
  uint64_t v45;
  void *v46;
  int *v47;
  int v48;
  int v49;
  const char *v50;
  const char *v51;
  char *v52;
  void **v53;
  uint64_t *v54;
  uint64_t v55;
  unsigned int v56;
  void *v57[2];
  int v58;
  _QWORD v59[2];

  v10 = 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 2);
  *(_DWORD *)(a1 + 16) = v10;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1, v10);
  *(_QWORD *)(a1 + 32) = *(_QWORD *)(a1 + 24);
  v11 = a4;
  std::vector<int>::reserve((std::vector<int> *)(a1 + 24), 0xAAAAAAAAAAAAAAABLL * ((uint64_t)(a4[1] - *a4) >> 2));
  v12 = (a4[1] - *a4) >> 2;
  *(_DWORD *)(a1 + 88) = -1431655765 * v12;
  *(_DWORD *)(a1 + 92) = 9;
  v53 = (void **)(a1 + 24);
  cva::MatrixData<float,0ul,0ul,false>::reserve(a1 + 72, (3 * v12));
  v14 = *a3;
  v13 = a3[1];
  v54 = a3;
  if (v13 != *a3)
  {
    v15 = 0;
    v56 = 0;
    LODWORD(v16) = 0;
    v52 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    v50 = "row";
    v51 = "matrixmixin.h";
    v55 = a2;
    while (1)
    {
      v17 = (uint64_t)(a5[1] - *a5) >> 2;
      if (v17 > (int)v16)
      {
        v16 = (int)v16;
        do
        {
          if (*(_DWORD *)(*a5 + 4 * v16))
            break;
          ++v16;
        }
        while (v17 > v16);
      }
      v18 = (float *)(*v11 + 12 * v15);
      v19 = *v18;
      if (*v18 >= 0.0 && v19 < (float)*(unsigned int *)(a2 + 8))
      {
        v20 = v18[1];
        if (v20 >= 0.0)
        {
          v21 = (float)*(unsigned int *)(a2 + 12);
          if (v20 < v21)
          {
            v23 = *(char **)(a1 + 32);
            v22 = *(_QWORD *)(a1 + 40);
            if ((unint64_t)v23 >= v22)
            {
              v25 = (char *)*v53;
              v26 = (v23 - (_BYTE *)*v53) >> 2;
              v27 = v26 + 1;
              if ((unint64_t)(v26 + 1) >> 62)
                std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
              v28 = v22 - (_QWORD)v25;
              if (v28 >> 1 > v27)
                v27 = v28 >> 1;
              if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
                v29 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v29 = v27;
              if (v29)
              {
                v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>(a1 + 40, v29);
                v25 = *(char **)(a1 + 24);
                v23 = *(char **)(a1 + 32);
              }
              else
              {
                v30 = 0;
              }
              v31 = &v30[4 * v26];
              *(_DWORD *)v31 = *(_DWORD *)(v14 + 4 * v15);
              v24 = v31 + 4;
              if (v23 == v25)
              {
                a2 = v55;
              }
              else
              {
                a2 = v55;
                do
                {
                  v32 = *((_DWORD *)v23 - 1);
                  v23 -= 4;
                  *((_DWORD *)v31 - 1) = v32;
                  v31 -= 4;
                }
                while (v23 != v25);
              }
              *(_QWORD *)(a1 + 24) = v31;
              *(_QWORD *)(a1 + 32) = v24;
              *(_QWORD *)(a1 + 40) = &v30[4 * v29];
              if (v25)
                operator delete(v25);
            }
            else
            {
              *(_DWORD *)v23 = *(_DWORD *)(v14 + 4 * v15);
              v24 = v23 + 4;
            }
            v33 = 0;
            *(_QWORD *)(a1 + 32) = v24;
            v34 = v19;
            v35 = v20;
            v59[0] = v34 | (v35 << 32);
            v57[0] = *(void **)(a2 + 8);
            do
            {
              v36 = *(_DWORD *)((char *)v59 + v33);
              v37 = *(_DWORD *)((char *)v57 + v33);
              v38 = v36 >= v37 || v33 == 4;
              v33 += 4;
            }
            while (!v38);
            if (v36 >= v37)
              arkit::FacialLightEstimation::populateValidImageSamples();
            if (v15 >= *(unsigned int *)(a1 + 16))
              arkit::FacialLightEstimation::populateValidImageSamples();
            v39 = v11;
            LOBYTE(v21) = *(_BYTE *)(*(_QWORD *)(a2 + 24)
                                   + *(_QWORD *)a2
                                   + (*(_DWORD *)(a2 + 16) * v34 + *(_DWORD *)(a2 + 20) * v35));
            *(float *)(*(_QWORD *)a1 + 4 * v15) = (float)LODWORD(v21) * 0.0039216;
            RTF = (cva::Logger *)arkit::PrecomputedFaceData::getRTF(*(arkit::PrecomputedFaceData **)(a1 + 96), v16, (uint64_t)v57);
            v41 = *(int *)(a1 + 88);
            if (v41 <= v56)
            {
              v49 = 1063;
              goto LABEL_58;
            }
            v42 = *(_DWORD *)(a1 + 92);
            v43 = *(_QWORD *)(a1 + 72);
            if (v42 != v58)
            {
              cva::Logger::instance(RTF);
              cva::Logger::logInCategory();
              if (v42 != v58)
              {
                v49 = 163;
                v50 = "assert_equal_size";
                v51 = "matrixfun.h";
                v52 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matri"
                      "x sizes are not compatible!\")";
LABEL_58:
                __assert_rtn(v50, v51, v49, v52);
              }
            }
            if (v42)
              v44 = (_DWORD *)(v43 + 4 * v56);
            else
              v44 = 0;
            v45 = v43 + 4 * v56 + 4 * (v42 * v41);
            if (!v42)
              v45 = 0;
            v46 = v57[0];
            if (v44 != (_DWORD *)v45)
            {
              v47 = (int *)v57[0];
              do
              {
                v48 = *v47++;
                *v44 = v48;
                v44 += v41;
              }
              while (v44 != (_DWORD *)v45);
            }
            ++v56;
            free(v46);
            LODWORD(v16) = v16 + 1;
            a2 = v55;
            v14 = *v54;
            v13 = v54[1];
            v11 = v39;
          }
        }
      }
      if (++v15 >= (v13 - v14) >> 2)
        goto LABEL_52;
    }
  }
  v56 = 0;
LABEL_52:
  cva::Matrix<float,0u,0u,false>::conservativeResize((uint64_t *)(a1 + 72), v56, 9u);
  cva::Matrix<float,0u,1u,false>::conservativeResize(a1, v56, 1);
}

void sub_1B3BB3AF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  free(a22);
  _Unwind_Resume(a1);
}

uint64_t std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::reserve(uint64_t *a1, unint64_t a2)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD v7[5];

  v4 = a1[2];
  result = (uint64_t)(a1 + 2);
  if (a2 > (v4 - *a1) >> 5)
  {
    if (a2 >> 59)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = a1[1] - *a1;
    v7[4] = result;
    v7[0] = std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::IntRect>>(result, a2);
    v7[1] = v7[0] + v5;
    v7[2] = v7[0] + v5;
    v7[3] = v7[0] + 32 * v6;
    std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__swap_out_circular_buffer(a1, v7);
    return std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)v7);
  }
  return result;
}

void sub_1B3BB3B8C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

__n128 arkit::ExponentialSmoother<cva::Matrix<float,9u,1u,false>>::step@<Q0>(uint64_t a1@<X0>, __int128 *a2@<X1>, uint64_t a3@<X8>, unsigned int a4@<S0>)
{
  __int128 v6;
  __int128 v7;
  __n128 result;
  __int128 v9;
  _QWORD v10[2];
  _QWORD v11[2];
  float *v12[3];

  if (*(_BYTE *)(a1 + 36))
  {
    v11[0] = a2;
    v11[1] = a4;
    v10[0] = a1;
    v10[1] = COERCE_UNSIGNED_INT(1.0 - *(float *)&a4);
    v12[0] = (float *)v11;
    v12[1] = (float *)v10;
    std::optional<cva::Matrix<float,9u,1u,false>>::operator=[abi:ne180100]<cva::MatrixBinaryExpr<cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::detail::AddOp>,void>(a1, v12);
    if (!*(_BYTE *)(a1 + 36))
      std::__throw_bad_optional_access[abi:ne180100]();
  }
  else
  {
    v6 = *a2;
    v7 = a2[1];
    *(_DWORD *)(a1 + 32) = *((_DWORD *)a2 + 8);
    *(_OWORD *)a1 = v6;
    *(_OWORD *)(a1 + 16) = v7;
    *(_BYTE *)(a1 + 36) = 1;
  }
  result = *(__n128 *)a1;
  v9 = *(_OWORD *)(a1 + 16);
  *(_OWORD *)a3 = *(_OWORD *)a1;
  *(_OWORD *)(a3 + 16) = v9;
  *(_DWORD *)(a3 + 32) = *(_DWORD *)(a1 + 32);
  return result;
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

void cva::Matrix<float,0u,0u,false>::conservativeResize(uint64_t *a1, unsigned int a2, unsigned int a3)
{
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  unsigned int v20;
  _DWORD v21[2];
  void *v22;
  unsigned int v23;
  int v24;
  _DWORD v25[2];
  uint64_t v26;
  unsigned int v27;
  int v28;
  void *v29;
  uint64_t v30;
  unint64_t v31;

  v6 = a3 * a2;
  if (a1[1] >= v6)
  {
    if (a3 >= 2)
    {
      v14 = *((_DWORD *)a1 + 4);
      if (v14 != a2)
      {
        v15 = *((_DWORD *)a1 + 5);
        if (v15 > 1)
        {
          if (v15 >= a3)
            v16 = a3;
          else
            v16 = v15;
          if (v14 <= a2)
          {
            v19 = v16 - 1;
            v20 = a2 * (v16 - 1);
            do
            {
              memmove((void *)(*a1 + 4 * v20), (const void *)(*a1 + 4 * (*((_DWORD *)a1 + 4) * v19)), 4 * *((unsigned int *)a1 + 4));
              v20 -= a2;
              --v19;
            }
            while (v19);
          }
          else
          {
            v17 = 1;
            v18 = a2;
            do
            {
              memmove((void *)(*a1 + 4 * v18), (const void *)(*a1 + 4 * (*((_DWORD *)a1 + 4) * v17++)), 4 * a2);
              v18 += a2;
            }
            while (v16 != v17);
          }
        }
      }
    }
    *((_DWORD *)a1 + 4) = a2;
    *((_DWORD *)a1 + 5) = a3;
  }
  else
  {
    v29 = 0;
    v30 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v29, v6);
    v31 = __PAIR64__(a3, a2);
    v7 = *((_DWORD *)a1 + 4);
    v8 = *((_DWORD *)a1 + 5);
    if (v7 >= a2)
      v9 = a2;
    else
      v9 = *((_DWORD *)a1 + 4);
    if (v8 >= a3)
      v8 = a3;
    v10 = *a1;
    v25[0] = v9;
    v25[1] = v8;
    v26 = v10;
    v27 = v7;
    v28 = 0;
    v21[0] = v9;
    v21[1] = v8;
    v22 = v29;
    v23 = a2;
    v24 = 0;
    cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixRef<float,0u,0u,false>>((cva::Logger *)v21, (uint64_t)v25);
    v11 = (void *)*a1;
    v12 = a1[1];
    v13 = v30;
    *a1 = (uint64_t)v29;
    a1[1] = v13;
    v29 = v11;
    v30 = v12;
    a1[2] = v31;
    v31 = 0;
    free(v11);
  }
}

void sub_1B3BB3E30(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  free(a16);
  _Unwind_Resume(a1);
}

uint64_t std::pair<float,cva::Matrix<float,1u,0u,false>>::pair[abi:ne180100]<float,cva::MatrixRef<float,1u,0u,false>,0>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _DWORD **v5;
  cva::Logger *v6;
  uint64_t v7;
  _DWORD *v8;
  _DWORD *v9;
  uint64_t v10;
  uint64_t v11;
  cva::Logger *v12;
  void *v13;
  _DWORD *v14;
  uint64_t v15;
  uint64_t v16;
  _DWORD *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  void *v22;
  uint64_t v23;
  unsigned int v24;

  *(_DWORD *)a1 = *(_DWORD *)a2;
  v4 = *(unsigned int *)(a2 + 8);
  *(_QWORD *)(a1 + 8) = 0;
  v5 = (_DWORD **)(a1 + 8);
  *(_QWORD *)(a1 + 16) = 0;
  v6 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)(a1 + 8), v4);
  v7 = *(unsigned int *)(a2 + 8);
  *(_DWORD *)(a1 + 24) = v7;
  v8 = *v5;
  if ((_DWORD *)(*(_QWORD *)(a2 + 16) - 4 * *(unsigned int *)(a2 + 28)) == *v5)
  {
    v22 = 0;
    v23 = 0;
    v12 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate(&v22, v7);
    v24 = v7;
    if ((_DWORD)v7 != *(_DWORD *)(a2 + 8))
    {
      cva::Logger::instance(v12);
      cva::Logger::logInCategory();
      v7 = v24;
      if (v24 != *(_DWORD *)(a2 + 8))
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
    }
    v13 = v22;
    if ((_DWORD)v7)
    {
      v14 = *(_DWORD **)(a2 + 16);
      v15 = 4 * v7;
      v16 = 4 * *(int *)(a2 + 24);
      v17 = v22;
      do
      {
        *v17++ = *v14;
        v14 = (_DWORD *)((char *)v14 + v16);
        v15 -= 4;
      }
      while (v15);
    }
    v18 = *(void **)(a1 + 8);
    v19 = *(_QWORD *)(a1 + 16);
    v20 = v23;
    *(_QWORD *)(a1 + 8) = v13;
    *(_QWORD *)(a1 + 16) = v20;
    v22 = v18;
    v23 = v19;
    *(_DWORD *)(a1 + 24) = v7;
    v24 = 0;
    free(v18);
  }
  else
  {
    if ((_DWORD)v7 != *(_DWORD *)(a2 + 8))
    {
      cva::Logger::instance(v6);
      cva::Logger::logInCategory();
      LODWORD(v7) = *(_DWORD *)(a1 + 24);
      if ((_DWORD)v7 != *(_DWORD *)(a2 + 8))
        __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
      v8 = *v5;
    }
    if ((_DWORD)v7)
    {
      v9 = *(_DWORD **)(a2 + 16);
      v10 = 4 * v7;
      v11 = 4 * *(int *)(a2 + 24);
      do
      {
        *v8++ = *v9;
        v9 = (_DWORD *)((char *)v9 + v11);
        v10 -= 4;
      }
      while (v10);
    }
  }
  return a1;
}

void sub_1B3BB4034(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  void **v14;

  free(a14);
  free(*v14);
  _Unwind_Resume(a1);
}

_QWORD *std::shared_ptr<arkit::PrecomputedFaceData>::shared_ptr[abi:ne180100]<arkit::PrecomputedFaceData,void>(_QWORD *a1, uint64_t a2)
{
  _QWORD *v4;

  *a1 = a2;
  v4 = (_QWORD *)operator new();
  *v4 = &unk_1E6670688;
  v4[1] = 0;
  v4[2] = 0;
  v4[3] = a2;
  a1[1] = v4;
  return a1;
}

void sub_1B3BB40BC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<arkit::PrecomputedFaceData>::reset[abi:ne180100]((arkit::PrecomputedFaceData **)va, 0);
  _Unwind_Resume(a1);
}

void std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::~__shared_ptr_pointer(std::__shared_weak_count *a1)
{
  std::__shared_weak_count::~__shared_weak_count(a1);
  JUMPOUT(0x1B5E2D5B8);
}

arkit::PrecomputedFaceData *std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::__on_zero_shared(uint64_t a1)
{
  arkit::PrecomputedFaceData *result;

  result = *(arkit::PrecomputedFaceData **)(a1 + 24);
  if (result)
  {
    arkit::PrecomputedFaceData::~PrecomputedFaceData(result);
    JUMPOUT(0x1B5E2D5B8);
  }
  return result;
}

uint64_t std::__shared_ptr_pointer<arkit::PrecomputedFaceData *,std::shared_ptr<arkit::PrecomputedFaceData>::__shared_ptr_default_delete<arkit::PrecomputedFaceData,arkit::PrecomputedFaceData>,std::allocator<arkit::PrecomputedFaceData>>::__get_deleter(uint64_t a1, uint64_t a2)
{
  {
    return a1 + 24;
  }
  else
  {
    return 0;
  }
}

arkit::PrecomputedFaceData *std::unique_ptr<arkit::PrecomputedFaceData>::reset[abi:ne180100](arkit::PrecomputedFaceData **a1, arkit::PrecomputedFaceData *a2)
{
  arkit::PrecomputedFaceData *result;

  result = *a1;
  *a1 = a2;
  if (result)
  {
    arkit::PrecomputedFaceData::~PrecomputedFaceData(result);
    JUMPOUT(0x1B5E2D5B8);
  }
  return result;
}

_QWORD *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<float>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3BB4208(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v6 = v4 - 4;
        free(*(v4 - 3));
        v4 = v6;
      }
      while (v6 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

uint64_t *std::vector<std::pair<float,cva::Matrix<float,1u,0u,false>>>::__swap_out_circular_buffer(uint64_t *result, _QWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  v3 = *result;
  v2 = result[1];
  v4 = a2[1];
  if (v2 != *result)
  {
    v5 = 0;
    do
    {
      v6 = v4 + v5;
      v7 = v2 + v5;
      *(_DWORD *)(v6 - 32) = *(_DWORD *)(v2 + v5 - 32);
      *(_QWORD *)(v6 - 24) = 0;
      *(_QWORD *)(v6 - 16) = 0;
      v8 = *(_QWORD *)(v2 + v5 - 16);
      *(_QWORD *)(v6 - 24) = *(_QWORD *)(v2 + v5 - 24);
      *(_QWORD *)(v6 - 16) = v8;
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_DWORD *)(v6 - 8) = *(_DWORD *)(v2 + v5 - 8);
      *(_DWORD *)(v7 - 8) = 0;
      v5 -= 32;
    }
    while (v2 + v5 != v3);
    v4 += v5;
  }
  a2[1] = v4;
  v9 = *result;
  *result = v4;
  a2[1] = v9;
  v10 = result[1];
  result[1] = a2[2];
  a2[2] = v10;
  v11 = result[2];
  result[2] = a2[3];
  a2[3] = v11;
  *a2 = a2[1];
  return result;
}

uint64_t std::__split_buffer<std::pair<float,cva::Matrix<float,1u,0u,false>>>::~__split_buffer(uint64_t a1)
{
  uint64_t i;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 8);
  for (i = *(_QWORD *)(a1 + 16); i != v3; i = *(_QWORD *)(a1 + 16))
  {
    *(_QWORD *)(a1 + 16) = i - 32;
    free(*(void **)(i - 24));
  }
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

uint64_t std::optional<cva::Matrix<float,9u,1u,false>>::operator=[abi:ne180100]<cva::MatrixBinaryExpr<cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::MatrixScalarExpr<cva::Matrix<float,9u,1u,false>,cva::detail::MulOp>,cva::detail::AddOp>,void>(uint64_t result, float **a2)
{
  uint64_t v2;
  float *v3;
  float *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  float *v8;
  float *v9;
  uint64_t v10;
  uint64_t v11;

  if (*(_BYTE *)(result + 36))
  {
    v2 = 0;
    v3 = *a2;
    v4 = a2[1];
    v5 = *(_QWORD *)*a2;
    v6 = *(_QWORD *)v4;
    do
    {
      *(float *)(result + v2) = (float)(*(float *)(v5 + v2) * v3[2]) + (float)(*(float *)(v6 + v2) * v4[2]);
      v2 += 4;
    }
    while (v2 != 36);
  }
  else
  {
    v7 = 0;
    *(_DWORD *)(result + 32) = 0;
    *(_OWORD *)result = 0u;
    *(_OWORD *)(result + 16) = 0u;
    v8 = *a2;
    v9 = a2[1];
    v10 = *(_QWORD *)*a2;
    v11 = *(_QWORD *)v9;
    do
    {
      *(float *)(result + v7) = (float)(*(float *)(v10 + v7) * v8[2]) + (float)(*(float *)(v11 + v7) * v9[2]);
      v7 += 4;
    }
    while (v7 != 36);
    *(_BYTE *)(result + 36) = 1;
  }
  return result;
}

void std::__throw_bad_optional_access[abi:ne180100]()
{
  _QWORD *exception;

  exception = __cxa_allocate_exception(8uLL);
  *exception = MEMORY[0x1E0DE5048] + 16;
  __cxa_throw(exception, MEMORY[0x1E0DE4E90], MEMORY[0x1E0DE4380]);
}

cva::Logger *cva::MatrixRef<float,0u,0u,false>::operator=<cva::MatrixRef<float,0u,0u,false>>(cva::Logger *a1, uint64_t a2)
{
  int v4;
  int v5;
  uint64_t v6;
  cva::Logger *v7;
  cva::Logger *v8;
  int v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  cva::Logger *v13;
  int v14;
  _DWORD *v15;
  int v16;
  _DWORD *v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  cva::Logger *v21;
  int v22;
  unsigned int v23;
  cva::Logger *v25[2];
  int v26;
  int v27;

  if (*(_QWORD *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20) != *((_QWORD *)a1 + 1) - 4 * *((unsigned int *)a1 + 5))
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>(a1, a2);
    return a1;
  }
  v4 = *(_DWORD *)a1;
  v5 = *((_DWORD *)a1 + 1);
  v6 = (v5 * *(_DWORD *)a1);
  v25[0] = 0;
  v25[1] = 0;
  v7 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)v25, v6);
  v26 = v4;
  v27 = v5;
  if (v4 != *(_DWORD *)a2 || v5 != *(_DWORD *)(a2 + 4))
  {
    cva::Logger::instance(v7);
    cva::Logger::logInCategory();
    v4 = v26;
    if (v26 != *(_DWORD *)a2)
      goto LABEL_38;
    v5 = v27;
    if (v27 != *(_DWORD *)(a2 + 4))
      goto LABEL_38;
    v6 = (v26 * v27);
  }
  v8 = v25[0];
  if ((_DWORD)v6)
  {
    v9 = 0;
    v10 = *(_DWORD *)(a2 + 16) - v4;
    v11 = *(_DWORD **)(a2 + 8);
    v12 = 4 * v6;
    v13 = v25[0];
    do
    {
      *(_DWORD *)v13 = *v11;
      v13 = (cva::Logger *)((char *)v13 + 4);
      if (v9 + 1 >= v4)
        v14 = v10;
      else
        v14 = 0;
      v15 = &v11[v14];
      if (v9 + 1 < v4)
        ++v9;
      else
        v9 = 0;
      v11 = v15 + 1;
      v12 -= 4;
    }
    while (v12);
  }
  if (*(_DWORD *)a1 == v4 && *((_DWORD *)a1 + 1) == v5)
    goto LABEL_22;
  cva::Logger::instance(v8);
  cva::Logger::logInCategory();
  v4 = *(_DWORD *)a1;
  if (*(_DWORD *)a1 != v26 || (v5 = *((_DWORD *)a1 + 1), v5 != v27))
LABEL_38:
    __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v8 = v25[0];
  LODWORD(v6) = v4 * v5;
LABEL_22:
  v16 = *((_DWORD *)a1 + 4);
  if ((_DWORD)v6)
    v17 = (_DWORD *)*((_QWORD *)a1 + 1);
  else
    v17 = 0;
  v18 = *((_QWORD *)a1 + 1) + 4 * (v16 * v5);
  if (!(_DWORD)v6)
    v18 = 0;
  if (v17 != (_DWORD *)v18)
  {
    v19 = 0;
    v20 = v16 - v4;
    v21 = v8;
    do
    {
      v22 = *(_DWORD *)v21;
      v21 = (cva::Logger *)((char *)v21 + 4);
      *v17 = v22;
      if (v19 + 1 >= v4)
        v23 = v20;
      else
        v23 = 0;
      v17 += v23 + 1;
      if (v19 + 1 < v4)
        ++v19;
      else
        v19 = 0;
    }
    while (v17 != (_DWORD *)v18);
  }
  free(v8);
  return a1;
}

void sub_1B3BB466C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

cva::Logger *cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>(cva::Logger *result, uint64_t a2)
{
  cva::Logger *v3;
  int v4;
  int v5;
  int v6;
  int v7;
  _DWORD *v8;
  uint64_t v9;
  int v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  _DWORD *v14;
  unsigned int v15;
  unsigned int v16;

  v3 = result;
  v4 = *(_DWORD *)result;
  if (*(_DWORD *)result != *(_DWORD *)a2 || (v5 = *((_DWORD *)result + 1), v5 != *(_DWORD *)(a2 + 4)))
  {
    cva::Logger::instance(result);
    result = (cva::Logger *)cva::Logger::logInCategory();
    v4 = *(_DWORD *)v3;
    if (*(_DWORD *)v3 != *(_DWORD *)a2 || (v5 = *((_DWORD *)v3 + 1), v5 != *(_DWORD *)(a2 + 4)))
      cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>();
  }
  v6 = v5 * v4;
  v7 = *((_DWORD *)v3 + 4);
  if (v5 * v4)
    v8 = (_DWORD *)*((_QWORD *)v3 + 1);
  else
    v8 = 0;
  v9 = *((_QWORD *)v3 + 1) + 4 * (v7 * v5);
  if (!v6)
    v9 = 0;
  if (v8 != (_DWORD *)v9)
  {
    v10 = 0;
    v11 = 0;
    v12 = *(_DWORD *)(a2 + 16) - v4;
    v13 = v7 - v4;
    if (v6)
      v14 = *(_DWORD **)(a2 + 8);
    else
      v14 = 0;
    do
    {
      *v8 = *v14;
      if (v10 + 1 >= v4)
        v15 = v12;
      else
        v15 = 0;
      v14 += v15 + 1;
      if (v10 + 1 < v4)
        ++v10;
      else
        v10 = 0;
      if (v11 + 1 >= v4)
        v16 = v13;
      else
        v16 = 0;
      v8 += v16 + 1;
      if (v11 + 1 < v4)
        ++v11;
      else
        v11 = 0;
    }
    while (v8 != (_DWORD *)v9);
  }
  return result;
}

void cva::Matrix<float,0u,1u,false>::conservativeResize(uint64_t a1, unsigned int a2, int a3)
{
  unsigned int v5;
  unsigned int v6;
  void *v7;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  void *v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  void *v16;
  unsigned int v17;
  int v18;
  void *v19;
  uint64_t v20;
  unsigned int v21;

  if (a3 != 1)
    cva::Matrix<float,0u,1u,false>::conservativeResize();
  if (*(_QWORD *)(a1 + 8) >= (unint64_t)a2)
  {
    *(_DWORD *)(a1 + 16) = a2;
  }
  else
  {
    v19 = 0;
    v20 = 0;
    cva::MatrixData<float,0ul,0ul,false>::allocate(&v19, a2);
    v21 = a2;
    v5 = *(_DWORD *)(a1 + 16);
    if (v5 >= a2)
      v6 = a2;
    else
      v6 = *(_DWORD *)(a1 + 16);
    v7 = *(void **)a1;
    v14 = 0;
    v15 = v6;
    v16 = v7;
    v17 = v5;
    v18 = 0;
    v11 = v6;
    v12 = v19;
    v13 = a2;
    cva::MatrixRef<float,0u,1u,false>::operator=<cva::MatrixRef<float,0u,1u,false>>(&v11, (uint64_t)&v15);
    v8 = *(void **)a1;
    v9 = *(_QWORD *)(a1 + 8);
    v10 = v20;
    *(_QWORD *)a1 = v19;
    *(_QWORD *)(a1 + 8) = v10;
    v19 = v8;
    v20 = v9;
    *(_DWORD *)(a1 + 16) = v21;
    v21 = 0;
    free(v8);
  }
}

void sub_1B3BB4858(_Unwind_Exception *a1)
{
  uint64_t v1;

  free(*(void **)(v1 - 40));
  _Unwind_Resume(a1);
}

unsigned int *cva::MatrixRef<float,0u,1u,false>::operator=<cva::MatrixRef<float,0u,1u,false>>(unsigned int *a1, uint64_t a2)
{
  _DWORD *v4;
  unsigned int v5;
  uint64_t v6;
  int *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  cva::Logger *v11;
  cva::Logger *v12;
  int *v13;
  uint64_t v14;
  cva::Logger *v15;
  int v16;
  _DWORD *v17;
  uint64_t v18;
  cva::Logger *v19;
  int v20;
  cva::Logger *v22[2];
  unsigned int v23;

  v4 = (_DWORD *)*((_QWORD *)a1 + 1);
  if ((_DWORD *)(*(_QWORD *)(a2 + 8) - 4 * *(unsigned int *)(a2 + 20)) != &v4[-a1[5]])
  {
    v5 = *a1;
    if (*a1 != *(_DWORD *)a2)
    {
      cva::Logger::instance((cva::Logger *)a1);
      cva::Logger::logInCategory();
      v5 = *a1;
      if (*a1 != *(_DWORD *)a2)
        cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>();
      v4 = (_DWORD *)*((_QWORD *)a1 + 1);
    }
    if (v5)
    {
      v6 = v5;
      v7 = *(int **)(a2 + 8);
      v8 = 4 * v6;
      do
      {
        v9 = *v7++;
        *v4++ = v9;
        v8 -= 4;
      }
      while (v8);
    }
    return a1;
  }
  v10 = *a1;
  v22[0] = 0;
  v22[1] = 0;
  v11 = (cva::Logger *)cva::MatrixData<float,0ul,0ul,false>::allocate((void **)v22, v10);
  v23 = v10;
  if ((_DWORD)v10 != *(_DWORD *)a2)
  {
    cva::Logger::instance(v11);
    cva::Logger::logInCategory();
    v10 = v23;
    if (v23 != *(_DWORD *)a2)
      goto LABEL_22;
  }
  v12 = v22[0];
  if ((_DWORD)v10)
  {
    v13 = *(int **)(a2 + 8);
    v14 = 4 * v10;
    v15 = v22[0];
    do
    {
      v16 = *v13++;
      *(_DWORD *)v15 = v16;
      v15 = (cva::Logger *)((char *)v15 + 4);
      v14 -= 4;
    }
    while (v14);
  }
  if (*a1 == (_DWORD)v10)
    goto LABEL_17;
  cva::Logger::instance(v12);
  cva::Logger::logInCategory();
  v10 = *a1;
  if ((_DWORD)v10 != v23)
LABEL_22:
    __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
  v12 = v22[0];
LABEL_17:
  if ((_DWORD)v10)
  {
    v17 = (_DWORD *)*((_QWORD *)a1 + 1);
    v18 = 4 * v10;
    v19 = v12;
    do
    {
      v20 = *(_DWORD *)v19;
      v19 = (cva::Logger *)((char *)v19 + 4);
      *v17++ = v20;
      v18 -= 4;
    }
    while (v18);
  }
  free(v12);
  return a1;
}

void sub_1B3BB4A68(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  free(a14);
  _Unwind_Resume(a1);
}

ARSkeletonJointName ARSkeletonJointNameForRecognizedPointKey(VNRecognizedPointKey recognizedPointKey)
{
  NSString *v1;
  void *v2;
  void *v3;
  int v4;
  NSString *v5;

  v1 = recognizedPointKey;
  +[ARSkeletonDefinition defaultBody2DSkeletonDefinition](ARSkeletonDefinition, "defaultBody2DSkeletonDefinition");
  v2 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v2, "jointNames");
  v3 = (void *)objc_claimAutoreleasedReturnValue();
  v4 = objc_msgSend(v3, "containsObject:", v1);

  if (v4)
    v5 = v1;
  else
    v5 = 0;

  return v5;
}

void sub_1B3BB5894(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3BB595C(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3BB59CC(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void sub_1B3BB5AC0(_Unwind_Exception *a1)
{
  os_unfair_lock_s *v1;

  os_unfair_lock_unlock(v1);
  _Unwind_Resume(a1);
}

void *arkit::kFLEInequalityCoefficients(arkit *this)
{
  return &arkit::kFLEInequalityCoefficients(void)::kVals;
}

void *arkit::kFLEDarkCoefficients(arkit *this)
{
  return &arkit::kFLEDarkCoefficients(void)::kVals;
}

void sub_1B3BB6288(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3BB63A8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB64F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3BB661C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3BB6708(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)ARMLImageProcessingTechnique;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

void sub_1B3BB69E4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB7238(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_1B3BB74D4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void std::vector<espresso_buffer_t>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;
  BOOL v3;
  unint64_t v4;

  v2 = 0xCF3CF3CF3CF3CF3DLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3);
  v3 = a2 >= v2;
  v4 = a2 - v2;
  if (v4 != 0 && v3)
  {
    std::vector<espresso_buffer_t>::__append((void **)a1, v4);
  }
  else if (!v3)
  {
    *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 168 * a2;
  }
}

void std::vector<__CVPixelBufferPool *>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<__CVPixelBufferPool *>::__append((void **)a1, a2 - v2);
  }
}

void sub_1B3BB76A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB77CC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB7924(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB7A88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB7B1C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB8070(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3BB83A4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB84E8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB8714(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB8BD0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB8DEC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3BB8EF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_1B3BB9004(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_1B3BB9150(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB926C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB9454(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BB9548(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BB9D88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *__p, uint64_t a17)
{
  void *v17;
  void *v18;

  if (__p)
    operator delete(__p);

  _Unwind_Resume(a1);
}

void sub_1B3BB9F4C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void ___ZL13_ARLogGeneralv_block_invoke_27()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void ___ZL15_ARLogTechniquev_block_invoke_15()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "Technique");
  v1 = (void *)_ARLogTechnique(void)::logObj;
  _ARLogTechnique(void)::logObj = (uint64_t)v0;

}

void std::vector<espresso_buffer_t>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  size_t v13;
  char *v14;
  char *v15;
  size_t v16;
  char *v17;
  char *v18;
  char *v19;
  __int128 v20;
  __int128 v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (0xCF3CF3CF3CF3CF3DLL * ((v6 - v7) >> 3) >= a2)
  {
    if (a2)
    {
      v13 = 168 * ((168 * a2 - 168) / 0xA8) + 168;
      bzero(*(void **)(v4 - 8), v13);
      v7 += v13;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = 0xCF3CF3CF3CF3CF3DLL * ((v7 - (_BYTE *)*a1) >> 3);
    v9 = v8 + a2;
    if (v8 + a2 > 0x186186186186186)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0xCF3CF3CF3CF3CF3DLL * ((v5 - (_BYTE *)*a1) >> 3);
    if (2 * v10 > v9)
      v9 = 2 * v10;
    if (v10 >= 0xC30C30C30C30C3)
      v11 = 0x186186186186186;
    else
      v11 = v9;
    if (v11)
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(v4, v11);
    else
      v12 = 0;
    v14 = &v12[168 * v8];
    v15 = &v12[168 * v11];
    v16 = 168 * ((168 * a2 - 168) / 0xA8) + 168;
    bzero(v14, v16);
    v17 = &v14[v16];
    v19 = (char *)*a1;
    v18 = (char *)a1[1];
    if (v18 != *a1)
    {
      do
      {
        v20 = *(_OWORD *)(v18 - 168);
        v21 = *(_OWORD *)(v18 - 152);
        *(_OWORD *)(v14 - 136) = *(_OWORD *)(v18 - 136);
        *(_OWORD *)(v14 - 152) = v21;
        *(_OWORD *)(v14 - 168) = v20;
        v22 = *(_OWORD *)(v18 - 120);
        v23 = *(_OWORD *)(v18 - 104);
        v24 = *(_OWORD *)(v18 - 88);
        *(_OWORD *)(v14 - 72) = *(_OWORD *)(v18 - 72);
        *(_OWORD *)(v14 - 88) = v24;
        *(_OWORD *)(v14 - 104) = v23;
        *(_OWORD *)(v14 - 120) = v22;
        v25 = *(_OWORD *)(v18 - 56);
        v26 = *(_OWORD *)(v18 - 40);
        v27 = *(_OWORD *)(v18 - 24);
        *((_QWORD *)v14 - 1) = *((_QWORD *)v18 - 1);
        *(_OWORD *)(v14 - 24) = v27;
        *(_OWORD *)(v14 - 40) = v26;
        *(_OWORD *)(v14 - 56) = v25;
        v14 -= 168;
        v18 -= 168;
      }
      while (v18 != v19);
      v18 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v17;
    a1[2] = v15;
    if (v18)
      operator delete(v18);
  }
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<espresso_buffer_t>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0x186186186186187)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(168 * a2);
}

void std::vector<__CVPixelBufferPool *>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 3);
    if (v9 >> 61)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 2 > v9)
      v9 = v11 >> 2;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF8)
      v12 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[8 * v10];
    v15 = &v13[8 * v12];
    bzero(v14, 8 * a2);
    v16 = &v14[8 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_QWORD *)v17 - 1);
        v17 -= 8;
        *((_QWORD *)v14 - 1) = v19;
        v14 -= 8;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

double arkit::shct::rotateShCoeff@<D0>(uint64_t a1@<X0>, float *a2@<X1>, uint64_t a3@<X8>)
{
  float v6;
  float v7;
  float v8;
  float v9;
  float v10;
  float v11;
  float v12;
  int v13;
  float v14;
  float v15;
  float v16;
  __int128 v17;
  float v18;
  float v19;
  float v20;
  int v21;
  float v22;
  double result;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  int v27;

  v6 = acosf(a2[8]);
  if (fabsf(v6) >= 0.001)
  {
    v9 = a2[6];
    v10 = a2[7];
    v7 = atan2f(a2[5], -a2[2]);
    v8 = atan2f(v10, v9);
  }
  else
  {
    v7 = atan2f(a2[1], *a2);
    v8 = 0.0;
  }
  v11 = -*(float *)(a3 + 4);
  v12 = -*(float *)(a3 + 20);
  v14 = *(float *)(a3 + 24);
  v13 = *(_DWORD *)(a3 + 28);
  v15 = *(float *)(a3 + 32);
  v16 = -*(float *)(a3 + 16);
  *(_DWORD *)(a3 + 4) = *(_DWORD *)(a3 + 8);
  *(float *)(a3 + 8) = v11;
  *(_DWORD *)(a3 + 16) = v13;
  *(float *)(a3 + 20) = v12;
  *(float *)(a3 + 24) = (float)(v14 + (float)(v15 * 1.7321)) * -0.5;
  *(float *)(a3 + 28) = v16;
  *(float *)(a3 + 32) = (float)(v15 + (float)(v14 * -1.7321)) * 0.5;
  v17 = v26;
  *(_OWORD *)a3 = v25;
  *(_OWORD *)(a3 + 16) = v17;
  *(_DWORD *)(a3 + 32) = v27;
  LODWORD(v17) = *(_DWORD *)(a3 + 4);
  v18 = *(float *)(a3 + 24);
  v19 = -*(float *)(a3 + 28);
  v20 = *(float *)(a3 + 32);
  v21 = *(_DWORD *)(a3 + 16);
  v22 = -*(float *)(a3 + 20);
  *(float *)(a3 + 4) = -*(float *)(a3 + 8);
  *(_DWORD *)(a3 + 8) = v17;
  *(float *)(a3 + 16) = v19;
  *(float *)(a3 + 20) = v22;
  *(float *)(a3 + 24) = (float)(v18 + (float)(v20 * 1.7321)) * -0.5;
  *(_DWORD *)(a3 + 28) = v21;
  *(float *)(a3 + 32) = (float)(v20 + (float)(v18 * -1.7321)) * 0.5;
  result = *(double *)&v25;
  v24 = v26;
  *(_OWORD *)a3 = v25;
  *(_OWORD *)(a3 + 16) = v24;
  *(_DWORD *)(a3 + 32) = v27;
  return result;
}

float arkit::`anonymous namespace'::rotateSHCoeffsAroundZ@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>, float a3@<S0>)
{
  __float2 v6;
  __float2 v7;
  float v8;
  float v9;
  int v10;
  float v11;
  float v12;
  float v13;
  float v14;
  int v15;
  float result;

  v6 = __sincosf_stret(a3);
  v7 = __sincosf_stret(a3 + a3);
  v8 = *(float *)(a1 + 4);
  v10 = *(_DWORD *)(a1 + 8);
  v9 = *(float *)(a1 + 12);
  *(_DWORD *)a2 = *(_DWORD *)a1;
  *(float *)(a2 + 4) = (float)(v6.__sinval * v9) + (float)(v6.__cosval * v8);
  *(_DWORD *)(a2 + 8) = v10;
  *(float *)(a2 + 12) = (float)(v6.__cosval * v9) - (float)(v6.__sinval * v8);
  v12 = *(float *)(a1 + 28);
  v11 = *(float *)(a1 + 32);
  v13 = *(float *)(a1 + 16);
  v14 = *(float *)(a1 + 20);
  v15 = *(_DWORD *)(a1 + 24);
  *(float *)(a2 + 16) = (float)(v7.__sinval * v11) + (float)(v7.__cosval * v13);
  *(float *)(a2 + 20) = (float)(v6.__sinval * v12) + (float)(v6.__cosval * v14);
  *(_DWORD *)(a2 + 24) = v15;
  *(float *)(a2 + 28) = (float)(v6.__cosval * v12) - (float)(v6.__sinval * v14);
  result = (float)(v7.__cosval * v11) - (float)(v7.__sinval * v13);
  *(float *)(a2 + 32) = result;
  return result;
}

uint64_t arkit::shct::flipAxesShCoeff@<X0>(uint64_t result@<X0>, int a2@<W1>, int a3@<W2>, int a4@<W3>, uint64_t a5@<X8>)
{
  float v5;
  float v6;
  float v7;
  float v8;
  float v9;
  int v10;
  float v11;
  int v12;

  v5 = *(float *)(result + 4);
  if (a3)
    v5 = -v5;
  *(_DWORD *)a5 = *(_DWORD *)result;
  *(float *)(a5 + 4) = v5;
  v7 = *(float *)(result + 8);
  v6 = *(float *)(result + 12);
  if (a4)
    v7 = -v7;
  *(_DWORD *)(a5 + 12) = 0;
  *(float *)(a5 + 8) = v7;
  if ((a2 & 1) != 0)
  {
    *(float *)(a5 + 12) = -v6;
    if ((a3 & 1) == 0)
    {
LABEL_7:
      v8 = -*(float *)(result + 16);
      goto LABEL_10;
    }
  }
  else
  {
    *(float *)(a5 + 12) = v6;
    if ((a3 & 1) != 0)
      goto LABEL_7;
  }
  v8 = *(float *)(result + 16);
LABEL_10:
  v9 = *(float *)(result + 20);
  v10 = *(_DWORD *)(result + 24);
  if (a3 != a4)
    v9 = -v9;
  *(float *)(a5 + 16) = v8;
  *(float *)(a5 + 20) = v9;
  v11 = *(float *)(result + 28);
  v12 = *(_DWORD *)(result + 32);
  if (a2 != a4)
    v11 = -v11;
  *(_DWORD *)(a5 + 24) = v10;
  *(float *)(a5 + 28) = v11;
  *(_DWORD *)(a5 + 32) = v12;
  return result;
}

id ARRemoteGeoTrackingTechniqueClientInterface()
{
  return ARRemoteTechniqueClientInterfaceWithProtocol((uint64_t)&unk_1EF0AB548);
}

id ARRemoteGeoTrackingTechniqueServiceInterface()
{
  return ARRemoteTechniqueServiceInterfaceWithProtocol((uint64_t)&unk_1EF0AB5A8);
}

void sub_1B3BBC244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  uint64_t v11;
  va_list va;

  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v11 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__6(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{

}

void sub_1B3BBC3D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3BBC4D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3BBC5DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3BBC6DC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_1B3BBC7D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

float homographySquareTo@<S0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t i;
  uint64_t j;
  float result;
  uint64_t k;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t *v18;
  uint64_t v19;
  int v20;

  *(_DWORD *)(a2 + 32) = 0;
  v4 = a1 + 12;
  v5 = a1 + 24;
  *(_OWORD *)a2 = 0u;
  *(_OWORD *)(a2 + 16) = 0u;
  v6 = a1 + 36;
  v15 = a1;
  v16 = a1 + 12;
  v13 = a1 + 24;
  v14 = a1 + 36;
  v17 = &v15;
  v18 = &v13;
  v11 = a2;
  v12 = 3;
  if (a1 == a2 || v4 == a2 || v5 == a2 || v6 == a2)
  {
    v20 = 0;
    v19 = 0;
    cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
    for (i = 0; i != 12; i += 4)
      *(_DWORD *)(a2 + i) = *(_DWORD *)((char *)&v19 + i);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  }
  v15 = a1;
  v16 = v6;
  v13 = v4;
  v14 = v5;
  v17 = &v15;
  v18 = &v13;
  v11 = a2 + 12;
  v12 = 0x300000003;
  if (a1 == a2 || v6 == a2 || v4 == a2 || v5 == a2)
  {
    v20 = 0;
    v19 = 0;
    cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
    for (j = 0; j != 12; j += 4)
      *(_DWORD *)(a2 + 12 + j) = *(_DWORD *)((char *)&v19 + j);
  }
  else
  {
    cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  }
  v15 = a1;
  v16 = v5;
  v13 = v4;
  v14 = v6;
  v17 = &v15;
  v18 = &v13;
  v11 = a2 + 24;
  v12 = 0x600000003;
  if (a1 != a2 && v5 != a2 && v4 != a2 && v6 != a2)
    return cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(&v11, (uint64_t)&v17);
  v20 = 0;
  v19 = 0;
  cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>((uint64_t)&v19, (uint64_t)&v17);
  for (k = 0; k != 12; k += 4)
  {
    result = *(float *)((char *)&v19 + k);
    *(float *)(a2 + 24 + k) = result;
  }
  return result;
}

BOOL hartleyNormalize(float *a1, _OWORD *a2, float32x2_t *a3, double a4, double a5, double a6)
{
  float v6;
  float32_t v7;
  float32_t v8;
  float32x2_t v9;
  uint64_t v10;
  float v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  float v15;
  float32x2_t v16;
  uint64_t v17;
  float v18;
  float32x2_t v19;
  float32x2_t v25;
  __int128 v28;
  int v30;
  uint64_t v31[2];
  uint64_t v32[2];
  uint64_t v33[2];
  uint64_t v34[2];
  _BYTE v35[32];
  __int128 v36;

  v6 = a1[2];
  v8 = a1[1] / v6;
  v9.f32[0] = *a1 / v6;
  v7 = v9.f32[0];
  v9.f32[1] = v8;
  v10 = (uint64_t)(a1 + 3);
  v11 = a1[5];
  *(float *)&v12 = a1[3] / v11;
  *(float *)&v13 = a1[4] / v11;
  v14 = (uint64_t)(a1 + 6);
  v15 = a1[8];
  v16.f32[0] = a1[6] / v15;
  v16.f32[1] = a1[7] / v15;
  v17 = (uint64_t)(a1 + 9);
  v18 = a1[11];
  v19.f32[0] = a1[9] / v18;
  v19.f32[1] = a1[10] / v18;
  __asm { FMOV            V5.2S, #0.25 }
  v25 = vmul_f32(vadd_f32(vadd_f32(vadd_f32(v9, (float32x2_t)__PAIR64__(v13, v12)), v16), v19), _D5);
  *(float *)&a6 = (float)((float)((float)(sqrtf((float)((float)(v7 - v25.f32[0]) * (float)(v7 - v25.f32[0]))+ (float)((float)(v8 - v25.f32[1]) * (float)(v8 - v25.f32[1])))+ sqrtf((float)((float)(*(float *)&v12 - v25.f32[0])* (float)(*(float *)&v12 - v25.f32[0]))+ (float)((float)(*(float *)&v13 - v25.f32[1])* (float)(*(float *)&v13 - v25.f32[1]))))+ sqrtf((float)((float)(v16.f32[0] - v25.f32[0]) * (float)(v16.f32[0] - v25.f32[0]))+ (float)((float)(v16.f32[1] - v25.f32[1]) * (float)(v16.f32[1] - v25.f32[1]))))+ sqrtf((float)((float)(v19.f32[0] - v25.f32[0]) * (float)(v19.f32[0] - v25.f32[0]))+ (float)((float)(v19.f32[1] - v25.f32[1]) * (float)(v19.f32[1] - v25.f32[1]))))/ 1.4142;
  if (*(float *)&a6 >= 0.00000011921)
  {
    a3->f32[0] = 1.0 / *(float *)&a6;
    a3[1] = 0;
    a3->i32[1] = 0;
    a3[2].f32[0] = 1.0 / *(float *)&a6;
    a3[2].i32[1] = 0;
    a3[3] = vdiv_f32(vneg_f32(v25), (float32x2_t)vdup_lane_s32(*(int32x2_t *)&a6, 0));
    a3[4].i32[0] = 1065353216;
    v34[0] = (uint64_t)a3;
    v34[1] = (uint64_t)a1;
    *(_QWORD *)v35 = 0;
    *(_DWORD *)&v35[8] = 0;
    v30 = LODWORD(a6);
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)v35, v34);
    v33[0] = (uint64_t)a3;
    v33[1] = v10;
    *(_QWORD *)&v35[12] = 0;
    *(_DWORD *)&v35[20] = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v35[12], v33);
    v32[0] = (uint64_t)a3;
    v32[1] = v14;
    *(_QWORD *)&v35[24] = 0;
    LODWORD(v36) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v35[24], v32);
    v31[0] = (uint64_t)a3;
    v31[1] = v17;
    *(_QWORD *)((char *)&v36 + 4) = 0;
    HIDWORD(v36) = 0;
    cva::assign<false,false,cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,1u,false>>((uint64_t)&v36 + 4, v31);
    LODWORD(a6) = v30;
    v28 = *(_OWORD *)&v35[16];
    *a2 = *(_OWORD *)v35;
    a2[1] = v28;
    a2[2] = v36;
  }
  return *(float *)&a6 >= 0.00000011921;
}

BOOL computeHomography(float *a1, float *a2, uint64_t a3, double a4, double a5, double a6)
{
  _BOOL4 v8;
  double v9;
  double v10;
  double v11;
  _BOOL8 result;
  simd_float3x3 v13;
  _OWORD v14[2];
  __int32 v15;
  _OWORD v16[2];
  __int32 v17;
  _QWORD v18[2];
  _QWORD v19[2];
  uint64_t v20[2];
  float v21[3];
  float v22;
  float v23;
  float v24;
  float v25;
  float v26;
  float v27;
  simd_float3x3 v28;
  _OWORD v29[3];
  _OWORD v30[3];
  _OWORD v31[2];
  __int32 v32;
  _OWORD v33[2];
  int v34;
  simd_float3x3 v35;
  simd_float3x3 v36;

  v34 = 0;
  memset(v33, 0, sizeof(v33));
  v32 = 0;
  memset(v31, 0, sizeof(v31));
  memset(v30, 0, sizeof(v30));
  memset(v29, 0, sizeof(v29));
  v8 = hartleyNormalize(a1, v30, (float32x2_t *)v33, 0.0, a5, a6);
  result = 0;
  if (v8)
  {
    result = hartleyNormalize(a2, v29, (float32x2_t *)v31, v9, v10, v11);
    if (result)
    {
      homographySquareTo((uint64_t)v30, (uint64_t)&v28);
      homographySquareTo((uint64_t)v29, (uint64_t)v21);
      if (fabsf((float)(v28.columns[0].f32[2]* (float)((float)(*(float *)&v28.columns[1].i32[3] * *(float *)&v28.columns[0].i32[3])- (float)(v28.columns[1].f32[0] * v28.columns[1].f32[2])))+ (float)((float)(v28.columns[0].f32[0]* (float)((float)(v28.columns[2].f32[0] * v28.columns[1].f32[0])- (float)(v28.columns[1].f32[1] * *(float *)&v28.columns[1].i32[3])))- (float)(v28.columns[0].f32[1]* (float)((float)(v28.columns[2].f32[0] * *(float *)&v28.columns[0].i32[3])- (float)(v28.columns[1].f32[1] * v28.columns[1].f32[2]))))) >= 1.1755e-38&& fabsf((float)(v21[2] * (float)((float)(v26 * v22) - (float)(v23 * v25)))+ (float)((float)(v21[0] * (float)((float)(v27 * v23) - (float)(v24 * v26)))- (float)(v21[1] * (float)((float)(v27 * v22) - (float)(v24 * v25))))) >= 1.1755e-38)
      {
        v13.columns[2].i64[0] = *((_QWORD *)&v31[1] + 1);
        v13.columns[2].i32[2] = v32;
        v13.columns[0] = (simd_float3)v31[0];
        v13.columns[1] = *(simd_float3 *)((char *)v31 + 12);
        v35 = __invert_f3(v13);
        v35.columns[0].i32[3] = v35.columns[1].i32[0];
        v16[0] = v35.columns[0];
        v16[1] = vextq_s8(vextq_s8((int8x16_t)v35.columns[1], (int8x16_t)v35.columns[1], 0xCuLL), (int8x16_t)v35.columns[2], 8uLL);
        v17 = v35.columns[2].i32[2];
        v18[0] = v16;
        v18[1] = v21;
        v35.columns[2].i64[0] = v28.columns[1].i64[1];
        v35.columns[2].i32[2] = v28.columns[2].i32[0];
        v35.columns[0] = v28.columns[0];
        v35.columns[1] = *(simd_float3 *)((char *)v28.columns + 12);
        v36 = __invert_f3(v35);
        v36.columns[0].i32[3] = v36.columns[1].i32[0];
        v14[0] = v36.columns[0];
        v14[1] = vextq_s8(vextq_s8((int8x16_t)v36.columns[1], (int8x16_t)v36.columns[1], 0xCuLL), (int8x16_t)v36.columns[2], 8uLL);
        v15 = v36.columns[2].i32[2];
        v19[0] = v18;
        v19[1] = v14;
        v20[0] = (uint64_t)v19;
        v20[1] = (uint64_t)v33;
        cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(a3, v20);
        return 1;
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

float cva::detail::assignNoAlias<cva::Matrix<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD **v3;
  _QWORD *v4;
  int v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  _QWORD *v10;
  int v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  float result;
  _QWORD v17[2];
  uint64_t v18;
  int v19;
  _BYTE v20[4];
  int v21;
  __int128 v22;
  int v23;
  _BYTE v24[4];
  int v25;
  int v26;
  unint64_t v27;
  uint64_t v28;

  v2 = 0;
  v3 = *(_QWORD ***)a2;
  v18 = 0;
  v19 = 0;
  v4 = v3[1];
  v5 = *((_DWORD *)*v3 + 2);
  *(_QWORD *)&v6 = **v3;
  v25 = DWORD1(v6);
  v7 = *(_QWORD *)((char *)v4 + 4);
  v26 = v5;
  v27 = __PAIR64__(HIDWORD(v7), v6);
  LODWORD(v28) = *(_DWORD *)v4;
  HIDWORD(v28) = v7;
  v21 = v5;
  *((_QWORD *)&v6 + 1) = v7;
  v22 = v6;
  v23 = v28;
  do
  {
    *(float *)((char *)&v18 + v2) = (float)(*(float *)&v24[v2 + 4] * *(float *)((char *)&v27 + v2 + 4))
                                  - (float)(*(float *)&v20[v2 + 4] * *(float *)((char *)&v22 + v2 + 8));
    v2 += 4;
  }
  while (v2 != 12);
  v8 = 0;
  v9 = *(_QWORD ***)(a2 + 8);
  memset(v17, 0, 12);
  v10 = v9[1];
  v11 = *((_DWORD *)*v9 + 2);
  *(_QWORD *)&v12 = **v9;
  v25 = DWORD1(v12);
  v13 = *(_QWORD *)((char *)v10 + 4);
  v26 = v11;
  v27 = __PAIR64__(HIDWORD(v13), v12);
  LODWORD(v28) = *(_DWORD *)v10;
  HIDWORD(v28) = v13;
  v21 = v11;
  *((_QWORD *)&v12 + 1) = v13;
  v22 = v12;
  v23 = v28;
  do
  {
    *(float *)((char *)v17 + v8) = (float)(*(float *)&v24[v8 + 4] * *(float *)((char *)&v27 + v8 + 4))
                                 - (float)(*(float *)&v20[v8 + 4] * *(float *)((char *)&v22 + v8 + 8));
    v8 += 4;
  }
  while (v8 != 12);
  v14 = 0;
  *(_QWORD *)&v15 = v18;
  v25 = HIDWORD(v18);
  v26 = v19;
  v27 = __PAIR64__(v17[1], v18);
  v28 = v17[0];
  v21 = v19;
  *((_QWORD *)&v15 + 1) = *(_QWORD *)((char *)v17 + 4);
  v22 = v15;
  v23 = v17[0];
  do
  {
    result = (float)(*(float *)&v24[v14 + 4] * *(float *)((char *)&v27 + v14 + 4))
           - (float)(*(float *)&v20[v14 + 4] * *(float *)((char *)&v22 + v14 + 8));
    *(float *)(a1 + v14) = result;
    v14 += 4;
  }
  while (v14 != 12);
  return result;
}

float cva::detail::assignNoAlias<cva::MatrixRef<float,3u,1u,false>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>,cva::MatrixCrossProdExpr<cva::Matrix<float,3u,1u,false>,cva::Matrix<float,3u,1u,false>>>(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  _QWORD **v3;
  _QWORD *v4;
  int v5;
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD **v9;
  _QWORD *v10;
  int v11;
  __int128 v12;
  uint64_t v13;
  uint64_t v14;
  __int128 v15;
  uint64_t v16;
  float result;
  _QWORD v18[2];
  uint64_t v19;
  int v20;
  _BYTE v21[4];
  int v22;
  __int128 v23;
  int v24;
  _BYTE v25[4];
  int v26;
  int v27;
  unint64_t v28;
  uint64_t v29;

  v2 = 0;
  v3 = *(_QWORD ***)a2;
  v19 = 0;
  v20 = 0;
  v4 = v3[1];
  v5 = *((_DWORD *)*v3 + 2);
  *(_QWORD *)&v6 = **v3;
  v26 = DWORD1(v6);
  v7 = *(_QWORD *)((char *)v4 + 4);
  v27 = v5;
  v28 = __PAIR64__(HIDWORD(v7), v6);
  LODWORD(v29) = *(_DWORD *)v4;
  HIDWORD(v29) = v7;
  v22 = v5;
  *((_QWORD *)&v6 + 1) = v7;
  v23 = v6;
  v24 = v29;
  do
  {
    *(float *)((char *)&v19 + v2) = (float)(*(float *)&v25[v2 + 4] * *(float *)((char *)&v28 + v2 + 4))
                                  - (float)(*(float *)&v21[v2 + 4] * *(float *)((char *)&v23 + v2 + 8));
    v2 += 4;
  }
  while (v2 != 12);
  v8 = 0;
  v9 = *(_QWORD ***)(a2 + 8);
  memset(v18, 0, 12);
  v10 = v9[1];
  v11 = *((_DWORD *)*v9 + 2);
  *(_QWORD *)&v12 = **v9;
  v26 = DWORD1(v12);
  v13 = *(_QWORD *)((char *)v10 + 4);
  v27 = v11;
  v28 = __PAIR64__(HIDWORD(v13), v12);
  LODWORD(v29) = *(_DWORD *)v10;
  HIDWORD(v29) = v13;
  v22 = v11;
  *((_QWORD *)&v12 + 1) = v13;
  v23 = v12;
  v24 = v29;
  do
  {
    *(float *)((char *)v18 + v8) = (float)(*(float *)&v25[v8 + 4] * *(float *)((char *)&v28 + v8 + 4))
                                 - (float)(*(float *)&v21[v8 + 4] * *(float *)((char *)&v23 + v8 + 8));
    v8 += 4;
  }
  while (v8 != 12);
  v14 = 0;
  *(_QWORD *)&v15 = v19;
  v26 = HIDWORD(v19);
  v27 = v20;
  v28 = __PAIR64__(v18[1], v19);
  v29 = v18[0];
  v22 = v20;
  *((_QWORD *)&v15 + 1) = *(_QWORD *)((char *)v18 + 4);
  v23 = v15;
  v24 = v18[0];
  v16 = *a1;
  do
  {
    result = (float)(*(float *)&v25[v14 + 4] * *(float *)((char *)&v28 + v14 + 4))
           - (float)(*(float *)&v21[v14 + 4] * *(float *)((char *)&v23 + v14 + 8));
    *(float *)(v16 + v14) = result;
    v14 += 4;
  }
  while (v14 != 12);
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v4;
  double result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  float *v11;
  float v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;

  if (a2[1] == a1)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(&v14, a2);
    result = *(double *)&v14;
    v13 = v15;
    *(_OWORD *)a1 = v14;
    *(_OWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v16;
  }
  else
  {
    v4 = *a2;
    v14 = 0u;
    v15 = 0u;
    v16 = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>((uint64_t)&v14, v4);
    v6 = 0;
    v7 = a2[1];
    do
    {
      v8 = 0;
      v9 = &v14;
      do
      {
        v10 = 0;
        LODWORD(result) = 0;
        v11 = (float *)(v7 + 12 * v6);
        do
        {
          v12 = *v11++;
          *(float *)&result = *(float *)&result + (float)(*(float *)((char *)v9 + v10) * v12);
          v10 += 12;
        }
        while (v10 != 36);
        *(_DWORD *)(a1 + 12 * v6 + 4 * v8++) = LODWORD(result);
        v9 = (__int128 *)((char *)v9 + 4);
      }
      while (v8 != 3);
      ++v6;
    }
    while (v6 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  double result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  __int128 *v9;
  uint64_t v10;
  float *v11;
  float v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  int v16;

  if (*(_QWORD *)(a2 + 8) == a1)
  {
    v16 = 0;
    v14 = 0u;
    v15 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::MatrixMultExpr<cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>,cva::Matrix<float,3u,3u,false>>(&v14, a2);
    result = *(double *)&v14;
    v13 = v15;
    *(_OWORD *)a1 = v14;
    *(_OWORD *)(a1 + 16) = v13;
    *(_DWORD *)(a1 + 32) = v16;
  }
  else
  {
    v4 = *(uint64_t **)a2;
    v14 = 0u;
    v15 = 0u;
    v16 = 0;
    result = cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>((uint64_t)&v14, v4);
    v6 = 0;
    v7 = *(_QWORD *)(a2 + 8);
    do
    {
      v8 = 0;
      v9 = &v14;
      do
      {
        v10 = 0;
        LODWORD(result) = 0;
        v11 = (float *)(v7 + 12 * v6);
        do
        {
          v12 = *v11++;
          *(float *)&result = *(float *)&result + (float)(*(float *)((char *)v9 + v10) * v12);
          v10 += 12;
        }
        while (v10 != 36);
        *(_DWORD *)(a1 + 12 * v6 + 4 * v8++) = LODWORD(result);
        v9 = (__int128 *)((char *)v9 + 4);
      }
      while (v8 != 3);
      ++v6;
    }
    while (v6 != 3);
  }
  return result;
}

double cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>(uint64_t a1, uint64_t *a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t i;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double result;
  float *v10;
  float v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  int v15;

  v3 = *a2;
  if (*a2 == a1 || (v4 = a2[1], v4 == a1))
  {
    v15 = 0;
    v13 = 0u;
    v14 = 0u;
    cva::assign<false,false,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>,cva::Matrix<float,3u,3u,false>>(&v13);
    result = *(double *)&v13;
    v12 = v14;
    *(_OWORD *)a1 = v13;
    *(_OWORD *)(a1 + 16) = v12;
    *(_DWORD *)(a1 + 32) = v15;
  }
  else
  {
    for (i = 0; i != 3; ++i)
    {
      v6 = 0;
      v7 = v3;
      do
      {
        v8 = 0;
        LODWORD(result) = 0;
        v10 = (float *)(v4 + 12 * i);
        do
        {
          v11 = *v10++;
          *(float *)&result = *(float *)&result + (float)(*(float *)(v7 + v8) * v11);
          v8 += 12;
        }
        while (v8 != 36);
        *(_DWORD *)(a1 + 12 * i + 4 * v6++) = LODWORD(result);
        v7 += 4;
      }
      while (v6 != 3);
    }
  }
  return result;
}

float ARMapExposureOffset(float a1)
{
  float v1;

  v1 = exp2(a1);
  return pow(v1, 1.20000005);
}

float ARMapLightIntensity(float a1)
{
  long double v1;

  v1 = pow(a1, 0.8333333);
  return log2(v1);
}

id ARCreateInstanceOfType(objc_class *a1)
{
  return class_createInstance(a1, 0);
}

id ARGetPropertiesForType(objc_class *a1)
{
  objc_property_t *v1;
  id v2;
  void *v3;
  unint64_t i;
  void *v5;
  unsigned int outCount;

  outCount = 0;
  v1 = class_copyPropertyList(a1, &outCount);
  v2 = objc_alloc(MEMORY[0x1E0C99DE8]);
  v3 = (void *)objc_msgSend(v2, "initWithCapacity:", outCount);
  if (outCount)
  {
    for (i = 0; i < outCount; ++i)
    {
      objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", property_getName(v1[i]));
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v3, "addObject:", v5);

    }
  }
  free(v1);
  return v3;
}

id ARGetTypeOfProperty(objc_class *a1, id a2)
{
  objc_property *Property;
  char *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  uint64_t v8;
  uint64_t v9;
  NSString *v10;
  void *v11;

  Property = class_getProperty(a1, (const char *)objc_msgSend(objc_retainAutorelease(a2), "UTF8String"));
  if (Property)
  {
    v3 = property_copyAttributeValue(Property, "T");
    objc_msgSend(MEMORY[0x1E0CB3940], "stringWithUTF8String:", v3);
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    free(v3);
    if (objc_msgSend(v4, "hasPrefix:", CFSTR("@")))
    {
      objc_msgSend(MEMORY[0x1E0CB38E8], "regularExpressionWithPattern:options:error:", CFSTR("@\"(.*)\""), 0, 0);
      v5 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v5, "matchesInString:options:range:", v4, 0, 0, objc_msgSend(v4, "length"));
      v6 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v6, "firstObject");
      v7 = (void *)objc_claimAutoreleasedReturnValue();
      if (objc_msgSend(v7, "numberOfRanges"))
      {
        v8 = objc_msgSend(v7, "rangeAtIndex:", 1);
        objc_msgSend(v4, "substringWithRange:", v8, v9);
        v10 = (NSString *)objc_claimAutoreleasedReturnValue();
        NSClassFromString(v10);
        v11 = (void *)objc_claimAutoreleasedReturnValue();

      }
      else
      {
        v11 = 0;
      }

    }
    else
    {
      v11 = 0;
    }

  }
  else
  {
    v11 = 0;
  }
  return v11;
}

id ARGetValueOfProperty(void *a1, void *a2)
{
  id v3;
  NSString *v4;
  SEL v5;
  objc_class *v6;
  void *v7;

  v3 = a1;
  v4 = a2;
  v5 = NSSelectorFromString(v4);
  if ((objc_opt_respondsToSelector() & 1) != 0 && (v6 = (objc_class *)objc_opt_class(), ARGetTypeOfProperty(v6, v4)))
  {
    ((void (*)(id, SEL))objc_msgSend(v3, "methodForSelector:", v5))(v3, v5);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
  }
  else
  {
    v7 = 0;
  }

  return v7;
}

void ARSetValueOfIvar(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  objc_class *v7;
  id v8;
  const char *v9;
  objc_ivar *InstanceVariable;
  id obj;

  v5 = a3;
  v6 = a2;
  obj = a1;
  v7 = (objc_class *)objc_opt_class();
  v8 = objc_retainAutorelease(v6);
  v9 = (const char *)objc_msgSend(v8, "UTF8String");

  InstanceVariable = class_getInstanceVariable(v7, v9);
  object_setIvar(obj, InstanceVariable, v5);

}

BOOL ARTypeIsSubclassOfType(objc_class *a1, objc_class *a2)
{
  objc_class *Superclass;
  _BOOL8 i;

  Superclass = class_getSuperclass(a1);
  for (i = Superclass != 0; Superclass != a2 && Superclass; i = Superclass != 0)
    Superclass = class_getSuperclass(Superclass);
  return i;
}

uint64_t *arkit::PrecomputedFaceData::PrecomputedFaceData(uint64_t *a1, __int128 *a2)
{
  std::string __p;
  char v5;

  std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](&__p, a2);
  arkit::RTFSPContainer::loadRtfsp(a1, (uint64_t)&__p);
  if (v5 && SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return a1;
}

void sub_1B3BBD7E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  if (a15)
  {
    if (a14 < 0)
      operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void arkit::PrecomputedFaceData::~PrecomputedFaceData(arkit::PrecomputedFaceData *this)
{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v1)
    std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100]((uint64_t)this, v1);
}

{
  uint64_t v1;

  v1 = *(_QWORD *)this;
  *(_QWORD *)this = 0;
  if (v1)
    std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100]((uint64_t)this, v1);
}

uint64_t arkit::PrecomputedFaceData::nSamples(arkit::PrecomputedFaceData *this)
{
  return (uint64_t)(*(_QWORD *)(*(_QWORD *)this + 56) - *(_QWORD *)(*(_QWORD *)this + 48)) >> 2;
}

uint64_t arkit::PrecomputedFaceData::getRTF@<X0>(arkit::PrecomputedFaceData *this@<X0>, int a2@<W1>, uint64_t a3@<X8>)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t result;

  v4 = *(_QWORD *)(*(_QWORD *)this + 72) + 24 * a2;
  v5 = *(unsigned int *)(v4 + 16);
  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  result = cva::MatrixData<float,0ul,0ul,false>::allocate((void **)a3, v5);
  if ((_DWORD)v5)
    result = (uint64_t)memcpy(*(void **)a3, *(const void **)v4, 4 * v5);
  *(_DWORD *)(a3 + 16) = *(_DWORD *)(v4 + 16);
  return result;
}

void arkit::PrecomputedFaceData::getRTF(arkit::PrecomputedFaceData *a1@<X0>, uint64_t *a2@<X1>, uint64_t a3@<X8>)
{
  unint64_t v6;
  int v7;
  uint64_t v8;
  unint64_t v9;
  cva::Logger *RTF;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _DWORD *v14;
  uint64_t v15;
  void *v16;
  int *v17;
  int v18;
  int v19;
  const char *v20;
  const char *v21;
  char *v22;
  void *v23;
  int v24;

  *(_QWORD *)a3 = 0;
  *(_QWORD *)(a3 + 8) = 0;
  v6 = (unint64_t)(a2[1] - *a2) >> 2;
  v7 = *(_DWORD *)(*(_QWORD *)a1 + 96);
  *(_DWORD *)(a3 + 16) = v6;
  *(_DWORD *)(a3 + 20) = v7;
  cva::MatrixData<float,0ul,0ul,false>::reserve(a3, (v7 * v6));
  v8 = *a2;
  if (a2[1] != *a2)
  {
    v9 = 0;
    v21 = "matrixmixin.h";
    v22 = "(row < mixed().rows()) || cva::detail::assertMessage(\"Index out of bounds.\")";
    v20 = "row";
    while (1)
    {
      RTF = (cva::Logger *)arkit::PrecomputedFaceData::getRTF(a1, *(_DWORD *)(v8 + 4 * v9), (uint64_t)&v23);
      v11 = *(unsigned int *)(a3 + 16);
      if (v9 >= v11)
        break;
      v12 = *(_DWORD *)(a3 + 20);
      v13 = *(_QWORD *)a3;
      if (v12 != v24)
      {
        cva::Logger::instance(RTF);
        cva::Logger::logInCategory();
        if (v12 != v24)
        {
          v19 = 163;
          v20 = "assert_equal_size";
          v21 = "matrixfun.h";
          v22 = "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix size"
                "s are not compatible!\")";
LABEL_18:
          __assert_rtn(v20, v21, v19, v22);
        }
      }
      if (v12)
        v14 = (_DWORD *)(v13 + 4 * v9);
      else
        v14 = 0;
      v15 = v13 + 4 * v9 + 4 * (v12 * v11);
      if (!v12)
        v15 = 0;
      v16 = v23;
      if (v14 != (_DWORD *)v15)
      {
        v17 = (int *)v23;
        do
        {
          v18 = *v17++;
          *v14 = v18;
          v14 += (int)v11;
        }
        while (v14 != (_DWORD *)v15);
      }
      ++v9;
      free(v16);
      v8 = *a2;
      if (v9 >= (a2[1] - *a2) >> 2)
        return;
    }
    v19 = 1063;
    goto LABEL_18;
  }
}

void sub_1B3BBDA98(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void **v16;

  free(*v16);
  _Unwind_Resume(a1);
}

uint64_t arkit::PrecomputedFaceData::nCoefficients(arkit::PrecomputedFaceData *this)
{
  return *(int *)(*(_QWORD *)this + 96);
}

uint64_t arkit::PrecomputedFaceData::getValidSampleIDs(arkit::PrecomputedFaceData *this, int a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)this;
  v3 = *(_QWORD *)(v2 + 48);
  if (a2 >= (unint64_t)((*(_QWORD *)(v2 + 56) - v3) >> 2))
    std::vector<int>::__throw_out_of_range[abi:ne180100]();
  return *(int *)(v3 + 4 * a2);
}

_QWORD *arkit::PrecomputedFaceData::getValidSampleIDs@<X0>(arkit::PrecomputedFaceData *this@<X0>, _QWORD *a2@<X8>)
{
  uint64_t v2;

  v2 = *(_QWORD *)this;
  a2[1] = 0;
  a2[2] = 0;
  *a2 = 0;
  return std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(a2, *(const void **)(v2 + 48), *(_QWORD *)(v2 + 56), (uint64_t)(*(_QWORD *)(v2 + 56) - *(_QWORD *)(v2 + 48)) >> 2);
}

std::string *std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](std::string *a1, __int128 *a2)
{
  a1->__r_.__value_.__s.__data_[0] = 0;
  a1[1].__r_.__value_.__s.__data_[0] = 0;
  std::__optional_storage_base<std::string const,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string const,false> const&>(a1, a2);
  return a1;
}

void sub_1B3BBDB4C(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(_BYTE *)(v1 + 24))
    std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](v1);
  _Unwind_Resume(exception_object);
}

void std::__optional_storage_base<std::string const,false>::__construct_from[abi:ne180100]<std::__optional_copy_base<std::string const,false> const&>(std::string *this, __int128 *a2)
{
  __int128 v3;

  if (*((_BYTE *)a2 + 24))
  {
    if (*((char *)a2 + 23) < 0)
    {
      std::string::__init_copy_ctor_external(this, *(const std::string::value_type **)a2, *((_QWORD *)a2 + 1));
    }
    else
    {
      v3 = *a2;
      this->__r_.__value_.__r.__words[2] = *((_QWORD *)a2 + 2);
      *(_OWORD *)&this->__r_.__value_.__l.__data_ = v3;
    }
    this[1].__r_.__value_.__s.__data_[0] = 1;
  }
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

void std::default_delete<arkit::RTFSPContainer const>::operator()[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v3;
  void **v4;

  if (a2)
  {
    v4 = (void **)(a2 + 72);
    std::vector<cva::Matrix<float,1u,0u,false>>::__destroy_vector::operator()[abi:ne180100](&v4);
    v3 = *(void **)(a2 + 48);
    if (v3)
    {
      *(_QWORD *)(a2 + 56) = v3;
      operator delete(v3);
    }
    if (*(char *)(a2 + 47) < 0)
      operator delete(*(void **)(a2 + 24));
    if (*(char *)(a2 + 23) < 0)
      operator delete(*(void **)a2);
    MEMORY[0x1B5E2D5B8](a2, 0x1032C40D1F799DBLL);
  }
}

void std::vector<int>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

void thirdparty::quadprogpp::solve_quadprog(unsigned int *a1, uint64_t a2, _DWORD *a3, _DWORD *a4, _DWORD *a5, _DWORD *a6, uint64_t a7)
{
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  double *v15;
  uint64_t v16;
  double v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  double **v23;
  double *v24;
  double v25;
  uint64_t v26;
  uint64_t i;
  uint64_t v28;
  double v29;
  double *v30;
  _QWORD *v31;
  uint64_t v32;
  double *v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  void *v37;
  _QWORD *v38;
  _QWORD *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  void *v43;
  _QWORD *v44;
  _QWORD *v45;
  void *v46;
  _QWORD *v47;
  _QWORD *v48;
  void *v49;
  _QWORD *v50;
  _QWORD *v51;
  void *exception;
  unsigned int *v54;
  _BYTE v57[8];
  uint64_t v58;
  _BYTE v59[8];
  uint64_t v60;
  uint64_t v61;

  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)&v61);
  v11 = a1[1];
  if ((_DWORD)v11 && *a1)
  {
    if (*a1 == (_DWORD)v11)
    {
      if (*a3 == (_DWORD)v11)
      {
        if (*a4 == a3[1])
        {
          if (*a5 == (_DWORD)v11)
          {
            if (*a6 == a5[1])
            {
              if (*(_DWORD *)a7 != (_DWORD)v11)
              {
                v12 = *(_QWORD *)(a7 + 8);
                if (v12)
                  MEMORY[0x1B5E2D5A0](v12, 0x1000C8000313F17);
                *(_QWORD *)(a7 + 8) = operator new[]();
                *(_DWORD *)a7 = v11;
              }
              thirdparty::quadprogpp::Matrix<double>::Matrix((uint64_t)v59, v11, v11);
              thirdparty::quadprogpp::Matrix<double>::Matrix((uint64_t)v57, v11, v11);
              v54 = a1;
              operator new[]();
              v13 = 8 * v11;
              v14 = (double *)operator new[]();
              operator new[]();
              v15 = (double *)operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              operator new[]();
              if ((int)v11 >= 1)
              {
                v16 = 0;
                v17 = 0.0;
                do
                {
                  v17 = v17 + *(double *)(*(_QWORD *)(*((_QWORD *)v54 + 1) + v16) + v16);
                  v16 += 8;
                }
                while (v13 != v16);
              }
              thirdparty::quadprogpp::cholesky_decomposition(v54);
              if ((int)v11 <= 0)
              {
                v21 = v54;
              }
              else
              {
                v18 = 0;
                v19 = v60;
                do
                {
                  v15[v18 / 8] = 0.0;
                  bzero(*(void **)(v19 + v18), 8 * v11);
                  v18 += 8;
                }
                while (v13 != v18);
                v20 = 0;
                v21 = v54;
                v22 = *v54;
                v23 = (double **)*((_QWORD *)v54 + 1);
                v24 = *v23;
                v25 = 0.0;
                v26 = v58;
                do
                {
                  v15[v20] = 1.0;
                  *v14 = *v15 / *v24;
                  if ((int)v22 >= 2)
                  {
                    for (i = 1; i != v22; ++i)
                    {
                      v28 = 0;
                      v29 = v15[i];
                      v14[i] = v29;
                      v30 = v23[i];
                      do
                      {
                        v29 = v29 - v30[v28] * v14[v28];
                        v14[i] = v29;
                        ++v28;
                      }
                      while (i != v28);
                      v14[i] = v29 / v30[i];
                    }
                  }
                  v31 = *(_QWORD **)(v26 + 8 * v20);
                  v32 = v11;
                  v33 = v14;
                  do
                  {
                    v34 = *(_QWORD *)v33++;
                    *v31++ = v34;
                    --v32;
                  }
                  while (v32);
                  v25 = v25 + v14[v20];
                  v15[v20++] = 0.0;
                }
                while (v20 != v11);
              }
              thirdparty::quadprogpp::cholesky_solve(v21, a7, a2);
            }
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The vector ci0 is incompatible (incorrect dimension ", 52);
            v50 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)", expecting ", 12);
            v51 = (_QWORD *)std::ostream::operator<<();
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v51, (uint64_t)")", 1);
            exception = __cxa_allocate_exception(0x10uLL);
            std::stringbuf::str();
            MEMORY[0x1B5E2D3C0](exception, v59);
            __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
          }
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The matrix CI is incompatible (incorrect number of rows ", 56);
          v47 = (_QWORD *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)" , expecting ", 13);
          v48 = (_QWORD *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v48, (uint64_t)")", 1);
          v49 = __cxa_allocate_exception(0x10uLL);
          std::stringbuf::str();
          MEMORY[0x1B5E2D3C0](v49, v59);
          __cxa_throw(v49, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
        }
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The vector ce0 is incompatible (incorrect dimension ", 52);
        v44 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v44, (uint64_t)", expecting ", 12);
        v45 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v45, (uint64_t)")", 1);
        v46 = __cxa_allocate_exception(0x10uLL);
        std::stringbuf::str();
        MEMORY[0x1B5E2D3C0](v46, v59);
        __cxa_throw(v46, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
      }
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The matrix CE is incompatible (incorrect number of rows ", 56);
      v41 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v41, (uint64_t)" , expecting ", 13);
      v42 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v42, (uint64_t)")", 1);
      v43 = __cxa_allocate_exception(0x10uLL);
      std::stringbuf::str();
      MEMORY[0x1B5E2D3C0](v43, v59);
      __cxa_throw(v43, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
    }
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The matrix G is not a squared matrix (", 38);
    v38 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v38, (uint64_t)" x ", 3);
    v39 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v39, (uint64_t)")", 1);
    v40 = __cxa_allocate_exception(0x10uLL);
    std::stringbuf::str();
    MEMORY[0x1B5E2D3C0](v40, v59);
    __cxa_throw(v40, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
  }
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v61, (uint64_t)"The matrix G has 0 dimension (", 30);
  v35 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v35, (uint64_t)" x ", 3);
  v36 = (_QWORD *)std::ostream::operator<<();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v36, (uint64_t)")", 1);
  v37 = __cxa_allocate_exception(0x10uLL);
  std::stringbuf::str();
  MEMORY[0x1B5E2D3C0](v37, v59);
  __cxa_throw(v37, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
}

void sub_1B3BC1910(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,char a32,uint64_t a33,void *__p,uint64_t a35,int a36,__int16 a37,char a38,char a39,char a40)
{
  void *v40;
  int v41;

  if (a39 < 0)
  {
    operator delete(__p);
    if ((v41 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a40);
      _Unwind_Resume(a1);
    }
  }
  else if (!v41)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v40);
  goto LABEL_6;
}

uint64_t std::ostringstream::basic_ostringstream[abi:ne180100](uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  std::ios_base *v6;

  v2 = MEMORY[0x1E0DE4FE0];
  v3 = MEMORY[0x1E0DE4FE0] + 64;
  *(_QWORD *)(a1 + 112) = MEMORY[0x1E0DE4FE0] + 64;
  v4 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 8);
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 16);
  *(_QWORD *)a1 = v4;
  *(_QWORD *)(a1 + *(_QWORD *)(v4 - 24)) = v5;
  v6 = (std::ios_base *)(a1 + *(_QWORD *)(*(_QWORD *)a1 - 24));
  std::ios_base::init(v6, (void *)(a1 + 8));
  v6[1].__vftable = 0;
  v6[1].__fmtflags_ = -1;
  *(_QWORD *)a1 = v2 + 24;
  *(_QWORD *)(a1 + 112) = v3;
  std::streambuf::basic_streambuf();
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_1B3BC1BF8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E2D57C](v1);
  _Unwind_Resume(a1);
}

unsigned int *thirdparty::quadprogpp::cholesky_decomposition(unsigned int *result)
{
  unint64_t v1;
  unsigned int *v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int **v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t v14;
  unsigned int **v15;
  unsigned int *v16;
  void *exception;
  uint64_t v18;
  _QWORD v19[33];

  v1 = *result;
  if ((int)v1 >= 1)
  {
    v2 = result;
    v3 = 0;
    v4 = *((_QWORD *)result + 1);
    v5 = (unsigned int **)(v4 + 8);
    v6 = 1;
    v7 = 8;
    do
    {
      v8 = *(_QWORD *)(v4 + 8 * v3);
      v9 = v3;
      do
      {
        v10 = *(double *)(v8 + 8 * v9);
        if (v3)
        {
          v11 = v6;
          do
          {
            result = (unsigned int *)(v11 - 2);
            v10 = v10
                - *(double *)(v8 + 8 * result)
                * *(double *)(*(_QWORD *)(v4 + 8 * v9) + 8 * result);
            --v11;
          }
          while (v11 > 1);
        }
        if (v3 == v9)
        {
          if (v10 <= 0.0)
          {
            std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v19);
            thirdparty::quadprogpp::print_matrix("A", v2, 0xFFFFFFFF, -1);
            std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)"Error in cholesky decomposition, sum: ", 38);
            std::ostream::operator<<();
            exception = __cxa_allocate_exception(0x10uLL);
            std::stringbuf::str();
            MEMORY[0x1B5E2D3C0](exception, &v18);
            __cxa_throw(exception, MEMORY[0x1E0DE4E70], MEMORY[0x1E0DE42A0]);
          }
          *(double *)(v8 + 8 * v3) = sqrt(v10);
        }
        else
        {
          *(double *)(*(_QWORD *)(v4 + 8 * v9) + 8 * v3) = v10 / *(double *)(v8 + 8 * v3);
        }
        ++v9;
      }
      while ((int)v1 > (int)v9);
      v12 = v3 + 1;
      if (v3 + 1 < v1)
      {
        v13 = (_QWORD *)(v8 + v7);
        v14 = v1;
        v15 = v5;
        do
        {
          v16 = *v15++;
          result = v16;
          *v13++ = *(_QWORD *)&v16[2 * v3];
          --v14;
        }
        while (v6 != v14);
      }
      ++v6;
      ++v5;
      v7 += 8;
      ++v3;
    }
    while (v12 != v1);
  }
  return result;
}

void sub_1B3BC1DB0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, char a15)
{
  void *v15;
  int v16;

  if (a14 < 0)
  {
    operator delete(__p);
    if ((v16 & 1) == 0)
    {
LABEL_6:
      std::ostringstream::~ostringstream((uint64_t)&a15);
      _Unwind_Resume(a1);
    }
  }
  else if (!v16)
  {
    goto LABEL_6;
  }
  __cxa_free_exception(v15);
  goto LABEL_6;
}

void thirdparty::quadprogpp::cholesky_solve(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  double *v6;
  uint64_t v7;
  double *v8;
  double **v9;
  uint64_t i;
  uint64_t v11;
  double v12;
  double *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double *v20;
  uint64_t v21;

  v6 = (double *)operator new[]();
  v7 = *a1;
  v8 = *(double **)(a3 + 8);
  v9 = (double **)*((_QWORD *)a1 + 1);
  *v6 = *v8 / **v9;
  if ((int)v7 >= 2)
  {
    for (i = 1; i != v7; ++i)
    {
      v11 = 0;
      v12 = v8[i];
      v6[i] = v12;
      v13 = v9[i];
      do
      {
        v12 = v12 - v13[v11] * v6[v11];
        v6[i] = v12;
        ++v11;
      }
      while (i != v11);
      v6[i] = v12 / v13[i];
    }
  }
  v14 = *(_QWORD *)(a2 + 8);
  *(double *)(v14 + 8 * (v7 - 1)) = v6[(v7 - 1)] / v9[(v7 - 1)][(int)v7 - 1];
  if ((int)v7 >= 2)
  {
    v15 = 0;
    v16 = (v7 - 2);
    v17 = v7 - 1;
    v18 = v7;
    do
    {
      v19 = v6[v16];
      *(double *)(v14 + 8 * v16) = v19;
      v20 = v9[v16];
      if (v16 < v17)
      {
        v21 = -1;
        do
        {
          v19 = v19 - v20[v18 + v21] * *(double *)(v14 + 8 * (v7 + v21));
          *(double *)(v14 + 8 * v16) = v19;
          ++v21;
        }
        while (v15 != (_DWORD)v21);
      }
      *(double *)(v14 + 8 * v16) = v19 / v20[v16];
      LODWORD(v7) = v7 - 1;
      ++v15;
      --v18;
    }
    while (v16-- > 0);
  }
  JUMPOUT(0x1B5E2D5A0);
}

BOOL thirdparty::quadprogpp::add_constraint(uint64_t a1, uint64_t a2, int *a3, _DWORD *a4, double *a5)
{
  int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  double v22;
  double v23;
  double v24;
  uint64_t v25;
  uint64_t *v26;
  uint64_t *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  double v32;
  double v33;

  v5 = *a3;
  v6 = *a4;
  v7 = (int)*a4 + 1;
  if (*a3 > (int)v7)
  {
    v8 = *((_QWORD *)a3 + 1);
    v9 = *(uint64_t **)(a2 + 8);
    v10 = *a3;
    do
    {
      v11 = v10 - 2;
      v12 = *(double *)(v8 + 8 * (v10-- - 2));
      v13 = *(double *)(v8 + 8 * v10);
      v14 = fabs(v12);
      v15 = fabs(v13);
      if (v14 <= v15)
      {
        if (v15 <= v14)
          v16 = v14 * 1.41421356;
        else
          v16 = v15 * sqrt(v14 / v15 * (v14 / v15) + 1.0);
      }
      else
      {
        v16 = v14 * sqrt(v15 / v14 * (v15 / v14) + 1.0);
      }
      if (fabs(v16) >= 2.22044605e-16)
      {
        *(_QWORD *)(v8 + 8 * v10) = 0;
        v17 = v13 / v16;
        v18 = v12 / v16;
        if (v18 < 0.0)
        {
          v16 = -v16;
          v18 = -v18;
          v17 = -v17;
        }
        *(double *)(v8 + 8 * v11) = v16;
        if (v5 >= 1)
        {
          v19 = v5;
          v20 = v9;
          do
          {
            v21 = *v20++;
            v22 = *(double *)(v21 + 8 * v11);
            v23 = *(double *)(v21 + 8 * v10);
            v24 = v17 * v23 + v22 * v18;
            *(double *)(v21 + 8 * v11) = v24;
            *(double *)(v21 + 8 * v10) = -(v23 - v17 / (v18 + 1.0) * (v22 + v24));
            --v19;
          }
          while (v19);
        }
      }
    }
    while (v10 > v7);
  }
  *a4 = v7;
  v25 = *((_QWORD *)a3 + 1);
  if ((v6 & 0x80000000) == 0)
  {
    v26 = *(uint64_t **)(a1 + 8);
    v7 = v7;
    v27 = (uint64_t *)*((_QWORD *)a3 + 1);
    do
    {
      v28 = *v27++;
      v29 = v28;
      v30 = *v26++;
      *(_QWORD *)(v30 + 8 * v6) = v29;
      --v7;
    }
    while (v7);
  }
  v31 = fabs(*(double *)(v25 + 8 * v6));
  v32 = *a5;
  v33 = *a5 * 2.22044605e-16;
  if (v31 > v33)
  {
    if (v32 < v31)
      v32 = v31;
    *a5 = v32;
  }
  return v31 > v33;
}

uint64_t thirdparty::quadprogpp::delete_constraint(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, int a5, int a6, int *a7, int a8)
{
  uint64_t v8;
  unsigned int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t *v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  double v28;
  uint64_t v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v34;
  double v35;
  double v36;
  uint64_t i;
  double v38;
  double v39;
  double v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  double v44;
  double v45;
  double v46;

  LODWORD(v8) = *a7;
  if (*a7 <= a6)
  {
LABEL_4:
    a6 = -1;
  }
  else
  {
    while (*(_DWORD *)(*(_QWORD *)(a3 + 8) + 4 * a6) != a8)
    {
      if ((_DWORD)v8 == ++a6)
        goto LABEL_4;
    }
  }
  v9 = v8 - 1;
  v10 = *(_QWORD *)(a3 + 8);
  v11 = *(_QWORD *)(a4 + 8);
  if (a6 < (int)v8 - 1)
  {
    v12 = *(uint64_t **)(result + 8);
    v13 = a6;
    do
    {
      v14 = v13++;
      *(_DWORD *)(v10 + 4 * v14) = *(_DWORD *)(v10 + 4 * v13);
      *(_QWORD *)(v11 + 8 * v14) = *(_QWORD *)(v11 + 8 * v13);
      if (a5 >= 1)
      {
        v15 = a5;
        v16 = v12;
        do
        {
          v17 = *v16++;
          *(_QWORD *)(v17 + 8 * v14) = *(_QWORD *)(v17 + 8 * v13);
          --v15;
        }
        while (v15);
      }
      v8 = *a7;
      v9 = v8 - 1;
    }
    while (v13 < v8 - 1);
  }
  *(_DWORD *)(v10 + 4 * v9) = *(_DWORD *)(v10 + 4 * v8);
  v18 = *a7;
  *(_QWORD *)(v11 + 8 * (v18 - 1)) = *(_QWORD *)(v11 + 8 * v18);
  *(_DWORD *)(v10 + 4 * v18) = 0;
  v19 = *a7;
  *(_QWORD *)(v11 + 8 * v19) = 0;
  if ((int)v19 <= 0)
  {
    LODWORD(v21) = v19 - 1;
  }
  else
  {
    v20 = *(uint64_t **)(result + 8);
    v21 = (v19 - 1);
    do
    {
      v22 = *v20++;
      *(_QWORD *)(v22 + 8 * v21) = 0;
      --v19;
    }
    while (v19);
  }
  *a7 = v21;
  if ((_DWORD)v21 && a6 < (int)v21)
  {
    v23 = *(_QWORD *)(result + 8);
    v24 = *(uint64_t **)(a2 + 8);
    v25 = a6;
    do
    {
      v26 = v25++;
      v27 = *(_QWORD *)(v23 + 8 * v26);
      v28 = *(double *)(v27 + 8 * v26);
      v29 = *(_QWORD *)(v23 + 8 * v25);
      v30 = *(double *)(v29 + 8 * v26);
      v31 = fabs(v28);
      v32 = fabs(v30);
      if (v31 <= v32)
      {
        if (v32 <= v31)
          v33 = v31 * 1.41421356;
        else
          v33 = v32 * sqrt(v31 / v32 * (v31 / v32) + 1.0);
      }
      else
      {
        v33 = v31 * sqrt(v32 / v31 * (v32 / v31) + 1.0);
      }
      if (fabs(v33) >= 2.22044605e-16)
      {
        v34 = v28 / v33;
        v35 = v30 / v33;
        *(_QWORD *)(v29 + 8 * v26) = 0;
        if (v34 < 0.0)
        {
          v33 = -v33;
          v34 = -v34;
          v35 = -v35;
        }
        *(double *)(v27 + 8 * v26) = v33;
        v36 = v35 / (v34 + 1.0);
        for (i = v25; i < (int)v21; ++i)
        {
          v38 = *(double *)(v27 + 8 * i);
          v39 = *(double *)(v29 + 8 * i);
          v40 = v35 * v39 + v38 * v34;
          *(double *)(v27 + 8 * i) = v40;
          *(double *)(v29 + 8 * i) = -(v39 - v36 * (v38 + v40));
        }
        v41 = a5;
        v42 = v24;
        if (a5 >= 1)
        {
          do
          {
            v43 = *v42++;
            v44 = *(double *)(v43 + 8 * v26);
            v45 = *(double *)(v43 + 8 * v25);
            v46 = v35 * v45 + v44 * v34;
            *(double *)(v43 + 8 * v26) = v46;
            *(double *)(v43 + 8 * v25) = -(v45 - v36 * (v44 + v46));
            --v41;
          }
          while (v41);
        }
      }
    }
    while (v25 != (int)v21);
  }
  return result;
}

uint64_t std::ostringstream::~ostringstream(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F60];
  v3 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)a1 = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)(a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  *(_QWORD *)(a1 + 8) = MEMORY[0x1E0DE4FB8] + 16;
  if (*(char *)(a1 + 95) < 0)
    operator delete(*(void **)(a1 + 72));
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  MEMORY[0x1B5E2D57C](a1 + 112);
  return a1;
}

uint64_t thirdparty::quadprogpp::print_matrix(const char *a1, unsigned int *a2, unsigned int a3, int a4)
{
  uint64_t v8;
  int v9;
  size_t v10;
  _QWORD *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t v14;
  std::locale::id *v15;
  uint64_t v16;
  _QWORD *v17;
  const std::locale::facet *v18;
  std::string::size_type size;
  std::string *p_str;
  std::string::size_type v21;
  _QWORD *v22;
  const std::locale::facet *v23;
  std::string v25;
  std::string __str;
  _QWORD v27[11];
  char v28;
  uint64_t v29;
  char v30[9];

  std::ostringstream::basic_ostringstream[abi:ne180100]((uint64_t)v27);
  memset(&__str, 0, sizeof(__str));
  if (a3 == -1)
    v8 = *a2;
  else
    v8 = a3;
  if (a4 == -1)
    v9 = a2[1];
  else
    v9 = a4;
  v10 = strlen(a1);
  v11 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)a1, v10);
  v12 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)": ", 2);
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet((const std::locale *)&v25, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale((std::locale *)&v25);
  std::ostream::put();
  std::ostream::flush();
  if ((int)v8 >= 1)
  {
    v14 = 0;
    v15 = (std::locale::id *)MEMORY[0x1E0DE4A90];
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v27, (uint64_t)" ", 1);
      if (v9 >= 1)
      {
        v16 = 0;
        do
        {
          v17 = (_QWORD *)std::ostream::operator<<();
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v17, (uint64_t)", ", 2);
          v16 += 8;
        }
        while (8 * v9 != v16);
      }
      std::ios_base::getloc((const std::ios_base *)((char *)v27 + *(_QWORD *)(v27[0] - 24)));
      v18 = std::locale::use_facet((const std::locale *)&v25, v15);
      ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
      std::locale::~locale((std::locale *)&v25);
      std::ostream::put();
      std::ostream::flush();
      ++v14;
    }
    while (v14 != v8);
  }
  std::stringbuf::str();
  __str = v25;
  size = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) != 0)
    size = v25.__r_.__value_.__l.__size_;
  std::string::basic_string(&v25, &__str, 0, size - 3, (std::allocator<char> *)v30);
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  __str = v25;
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    p_str = &__str;
  else
    p_str = (std::string *)v25.__r_.__value_.__r.__words[0];
  if ((v25.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v21 = HIBYTE(v25.__r_.__value_.__r.__words[2]);
  else
    v21 = v25.__r_.__value_.__l.__size_;
  v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x1E0DE4A60], (uint64_t)p_str, v21);
  std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(_QWORD *)(*v22 - 24)));
  v23 = std::locale::use_facet((const std::locale *)&v25, MEMORY[0x1E0DE4A90]);
  ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
  std::locale::~locale((std::locale *)&v25);
  std::ostream::put();
  std::ostream::flush();
  if (SHIBYTE(__str.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__str.__r_.__value_.__l.__data_);
  v27[0] = *MEMORY[0x1E0DE4F60];
  *(_QWORD *)((char *)v27 + *(_QWORD *)(v27[0] - 24)) = *(_QWORD *)(MEMORY[0x1E0DE4F60] + 24);
  v27[1] = MEMORY[0x1E0DE4FB8] + 16;
  if (v28 < 0)
    operator delete((void *)v27[9]);
  std::streambuf::~streambuf();
  std::ostream::~ostream();
  return MEMORY[0x1B5E2D57C](&v29);
}

void sub_1B3BC26B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11, uint64_t a12, void *__p, uint64_t a14, int a15, __int16 a16, char a17, char a18, char a19)
{
  if (a18 < 0)
    operator delete(__p);
  std::ostringstream::~ostringstream((uint64_t)&a19);
  _Unwind_Resume(a1);
}

uint64_t thirdparty::quadprogpp::Matrix<double>::Matrix(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v6;

  *(_QWORD *)(a1 + 8) = operator new[]();
  *(_DWORD *)a1 = a2;
  *(_DWORD *)(a1 + 4) = a3;
  **(_QWORD **)(a1 + 8) = operator new[]();
  if (a2 >= 2)
  {
    v6 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(a1 + 8) + v6 + 8) = *(_QWORD *)(*(_QWORD *)(a1 + 8) + v6) + 8 * a3;
      v6 += 8;
    }
    while (8 * a2 - 8 != v6);
  }
  return a1;
}

uint64_t ARSavePixelBufferPNG(__CVBuffer *a1, void *a2)
{
  id v3;
  signed int PixelFormatType;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  uint64_t v7;
  NSObject *v8;
  char v9;
  char v10;
  unint64_t v11;
  unint64_t v12;
  void *v13;
  unint64_t v14;
  int16x8_t v15;
  uint8_t permuteMap[4];
  vImage_Buffer dest;
  vImage_Buffer src;
  uint8_t buf[8];
  void *v21;
  uint64_t v22;
  void *v23;
  CVPixelBufferRef pixelBufferOut;

  v3 = a2;
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
  HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
  pixelBufferOut = 0;
  CVPixelBufferLockBaseAddress(a1, 1uLL);
  if (PixelFormatType > 1111970368)
  {
    if (PixelFormatType != 1111970369)
    {
      if (PixelFormatType == 1278226488)
      {
        cva::imageViewFromPixelBuffer<unsigned char>();
        objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
        v9 = cva::imwrite<unsigned char>();
      }
      else
      {
        if (PixelFormatType != 1380401729)
          goto LABEL_14;
        cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
        objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
        v9 = cva::imwrite<cva::Matrix<unsigned char,4u,1u,false>>();
      }
      v10 = v9;
      goto LABEL_23;
    }
  }
  else if (PixelFormatType != 32)
  {
    if (PixelFormatType == 875704422 || PixelFormatType == 875704438)
    {
      v7 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], WidthOfPlane, HeightOfPlane, 0x20u, 0, &pixelBufferOut);
      if ((_DWORD)v7)
      {
        _ARLogGeneral();
        v8 = objc_claimAutoreleasedReturnValue();
        if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "Could not create image buffer of type kCVPixelFormatType_32ARGB", buf, 2u);
        }
LABEL_30:

        goto LABEL_31;
      }
      ARPixelBufferConvertYCbCrToARGB(a1, &pixelBufferOut);
      PixelFormatType = 32;
      goto LABEL_18;
    }
LABEL_14:
    _ARLogGeneral();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "Supported formats are:  - kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange - kCVPixelFormatType_420YpCbCr8BiPlanarFullRange - kCVPixelFormatType_OneComponent8 - kCVPixelFormatType_32RGBA - kCVPixelFormatType_32ARGB - kCVPixelFormatType_32BGRA", buf, 2u);
    }
    v7 = 4294960616;
    goto LABEL_30;
  }
LABEL_18:
  cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>();
  v11 = (unint64_t)v21;
  v12 = v22;
  v13 = v23;
  *(_QWORD *)buf = 0;
  v21 = (void *)(WidthOfPlane | ((unint64_t)HeightOfPlane << 32));
  v14 = ((WidthOfPlane << 34) + 0xF00000000) & 0xFFFFFFF000000000;
  v22 = v14 | 4;
  src.data = v21;
  dest.data = (void *)(v14 | 4);
  v23 = cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate((uint64_t)&src, (uint64_t)&dest);
  src.data = v13;
  src.height = HIDWORD(v11);
  src.width = v11;
  src.rowBytes = HIDWORD(v12);
  dest.data = v23;
  dest.height = HeightOfPlane;
  dest.width = WidthOfPlane;
  dest.rowBytes = HIDWORD(v14);
  if (PixelFormatType == 32)
    v15.i64[0] = 0x300020001;
  else
    v15.i64[0] = 0x3000000010002;
  *(_DWORD *)permuteMap = vmovn_s16(v15).u32[0];
  vImagePermuteChannels_ARGB8888(&src, &dest, permuteMap, 0x10u);
  objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
  v10 = cva::imwrite<cva::Matrix<unsigned char,4u,1u,false>>();
  if (v23)
    free(v23);
LABEL_23:
  CVPixelBufferUnlockBaseAddress(a1, 1uLL);
  if (pixelBufferOut)
    CVPixelBufferRelease(pixelBufferOut);
  if ((v10 & 1) == 0)
  {
    _ARLogGeneral();
    v8 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v8, OS_LOG_TYPE_ERROR, "Could not save image to file", buf, 2u);
    }
    v7 = 4294960636;
    goto LABEL_30;
  }
  v7 = 0;
LABEL_31:

  return v7;
}

void sub_1B3BC2B28(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

uint64_t ARSaveFloatingPixelBufferAsPng16(void *a1, __CVBuffer *a2, float a3)
{
  id v5;
  OSType PixelFormatType;
  size_t Width;
  unsigned int Height;
  size_t BytesPerRow;
  float *BaseAddress;
  unint64_t v11;
  void *v12;
  float *v13;
  NSObject *v14;
  const char *v15;
  float v16;
  BOOL v17;
  int v18;
  id v19;
  uint64_t v20;
  uint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _WORD *v26;
  _QWORD v27[4];
  float *v28;
  uint8_t buf[8];
  unint64_t v30;
  unint64_t v31;
  void *v32;
  unint64_t v33;
  unint64_t v34;

  v5 = a1;
  if (!a2)
  {
    _ARLogGeneral();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v15 = "Input buffer cannot be null";
LABEL_23:
      _os_log_impl(&dword_1B3A68000, v14, OS_LOG_TYPE_ERROR, v15, buf, 2u);
    }
LABEL_24:

    v20 = 0;
    goto LABEL_25;
  }
  PixelFormatType = CVPixelBufferGetPixelFormatType(a2);
  if (PixelFormatType != 1278226534 && PixelFormatType != 1717855600 && PixelFormatType != 1717856627)
  {
    _ARLogGeneral();
    v14 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      v15 = "Supported formats are kCVPixelFormatType_OneComponent32Float, kCVPixelFormatType_DepthFloat32 or kCVPixelFor"
            "matType_DisparityFloat32";
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  CVPixelBufferLockBaseAddress(a2, 1uLL);
  Width = CVPixelBufferGetWidth(a2);
  Height = CVPixelBufferGetHeight(a2);
  BytesPerRow = CVPixelBufferGetBytesPerRow(a2);
  BaseAddress = (float *)CVPixelBufferGetBaseAddress(a2);
  v11 = Width | ((unint64_t)Height << 32);
  *(_QWORD *)buf = 0;
  v30 = v11;
  v31 = ((Width << 33) + 0xF00000000) & 0xFFFFFFF000000000 | 2;
  v34 = v11;
  v33 = v31;
  v12 = cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate((uint64_t)&v34, (uint64_t)&v33);
  v32 = v12;
  v27[0] = 0;
  v27[1] = v11;
  v27[3] = 0;
  v28 = 0;
  v27[2] = (BytesPerRow << 32) | 4;
  if (BaseAddress)
  {
    v28 = BaseAddress;
    v13 = (float *)((char *)BaseAddress + BytesPerRow * Height);
  }
  else
  {
    v13 = 0;
  }
  v22 = 0;
  v23 = v11;
  v25 = 0;
  v26 = 0;
  v24 = ((Width << 33) + 0xF00000000) & 0xFFFFFFF000000000 | 2;
  if (v12)
    v26 = v12;
  if (BaseAddress != v13)
  {
    do
    {
      v16 = *BaseAddress * a3;
      v17 = v16 > 65535.0 || v16 < 0.0;
      v18 = (int)v16;
      if (v17)
        LOWORD(v18) = 0;
      *v26 = v18;
      cva::ArrayIterator<float,2u>::increment((uint64_t)v27);
      cva::ArrayIterator<float,2u>::increment((uint64_t)&v22);
      BaseAddress = v28;
    }
    while (v28 != v13);
  }
  CVPixelBufferUnlockBaseAddress(a2, 1uLL);
  v19 = objc_retainAutorelease(v5);
  objc_msgSend(v19, "UTF8String", v22, v23, v24, v25);
  v20 = cva::imwrite<unsigned short>();
  if (v32)
    free(v32);
LABEL_25:

  return v20;
}

void sub_1B3BC2E04(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22)
{
  void *v22;

  _Unwind_Resume(a1);
}

uint64_t ARSavePixelBufferPGM(__CVBuffer *a1, void *a2)
{
  id v3;
  OSType PixelFormatType;
  size_t HeightOfPlane;
  size_t BytesPerRowOfPlane;
  char *BaseAddressOfPlane;
  _QWORD *v8;
  const std::locale::facet *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD *v12;
  _QWORD *v13;
  const std::locale::facet *v14;
  _QWORD *v15;
  const std::locale::facet *v16;
  uint64_t v17;
  NSObject *v18;
  std::locale v20;
  uint8_t buf[8];
  _BYTE v22[408];
  _QWORD v23[20];

  v23[19] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType == 875704422 || PixelFormatType == 875704438 || PixelFormatType == 1278226488)
  {
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferGetWidthOfPlane(a1, 0);
    HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
    BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(a1, 0);
    BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(a1, 0);
    objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
    std::ofstream::basic_ofstream(buf);
    v8 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"P5", 2);
    std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
    v9 = std::locale::use_facet(&v20, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    v10 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"# ARKit image dump", 18);
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v20, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    v12 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" ", 1);
    v13 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(_QWORD *)(*v13 - 24)));
    v14 = std::locale::use_facet(&v20, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"255", 3);
    std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(_QWORD *)(*v15 - 24)));
    v16 = std::locale::use_facet(&v20, MEMORY[0x1E0DE4A90]);
    ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
    std::locale::~locale(&v20);
    std::ostream::put();
    std::ostream::flush();
    for (; HeightOfPlane; --HeightOfPlane)
    {
      std::ostream::write();
      BaseAddressOfPlane += BytesPerRowOfPlane;
    }
    if (!std::filebuf::close())
      std::ios_base::clear((std::ios_base *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)], *(_DWORD *)&v22[*(_QWORD *)(*(_QWORD *)buf - 24) + 24] | 4);
    CVPixelBufferUnlockBaseAddress(a1, 0);
    *(_QWORD *)buf = *MEMORY[0x1E0DE4F48];
    *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 24);
    MEMORY[0x1B5E2D450](v22);
    std::ostream::~ostream();
    MEMORY[0x1B5E2D57C](v23);
    v17 = 0;
  }
  else
  {
    _ARLogGeneral();
    v18 = objc_claimAutoreleasedReturnValue();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1B3A68000, v18, OS_LOG_TYPE_ERROR, "Supported formats are kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange or kCVPixelFormatType_OneComponent8", buf, 2u);
    }

    v17 = 4294960616;
  }

  return v17;
}

void sub_1B3BC3208(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::basic_ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x1E0DE4FB0];
  v3 = MEMORY[0x1E0DE4FB0] + 64;
  a1[52] = MEMORY[0x1E0DE4FB0] + 64;
  v4 = a1 + 1;
  v5 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 8);
  v6 = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 1);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[52] = v3;
  MEMORY[0x1B5E2D444](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_1B3BC3334(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x1B5E2D57C](v1 + 416);
  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::~ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x1E0DE4F48];
  v3 = *MEMORY[0x1E0DE4F48];
  *a1 = *MEMORY[0x1E0DE4F48];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x1B5E2D450](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x1B5E2D57C](a1 + 52);
  return a1;
}

uint64_t ARSavePixelBufferPPM(__CVBuffer *a1, void *a2)
{
  id v3;
  signed int PixelFormatType;
  int v5;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  uint64_t v8;
  NSObject *v9;
  OSType v10;
  size_t v11;
  size_t v12;
  size_t BytesPerRowOfPlane;
  char *BaseAddressOfPlane;
  _QWORD *v15;
  const std::locale::facet *v16;
  _QWORD *v17;
  const std::locale::facet *v18;
  _QWORD *v19;
  _QWORD *v20;
  const std::locale::facet *v21;
  _QWORD *v22;
  const std::locale::facet *v23;
  uint64_t k;
  size_t v25;
  char *m;
  char v27;
  NSObject *v28;
  uint64_t v29;
  char *v30;
  size_t v31;
  char *i;
  uint64_t v33;
  char *v34;
  size_t v35;
  char *j;
  CVPixelBufferRef pixelBuffer;
  std::locale v39;
  uint8_t buf[8];
  _BYTE v41[408];
  _QWORD v42[20];

  v42[19] = *MEMORY[0x1E0C80C00];
  v3 = a2;
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType <= 875704437)
  {
    if (PixelFormatType == 32)
      goto LABEL_8;
    v5 = 875704422;
  }
  else
  {
    if (PixelFormatType == 875704438 || PixelFormatType == 1111970369)
    {
LABEL_8:
      pixelBuffer = 0;
      if ((PixelFormatType & 0xFFFFFFEF) == 0x34323066)
      {
        WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
        HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
        v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], WidthOfPlane, HeightOfPlane, 0x20u, 0, &pixelBuffer);
        if ((_DWORD)v8)
        {
          _ARLogGeneral();
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_ERROR, "Could not create image buffer of type kCVPixelFormatType_32ARGB", buf, 2u);
          }
LABEL_12:

          goto LABEL_46;
        }
        v8 = ARPixelBufferConvertYCbCrToARGB(a1, &pixelBuffer);
        if ((_DWORD)v8)
        {
          _ARLogGeneral();
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_WORD *)buf = 0;
            _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_ERROR, "Could not convert pixel formats", buf, 2u);
          }
          goto LABEL_12;
        }
      }
      else
      {
        pixelBuffer = a1;
        CVPixelBufferRetain(a1);
      }
      CVPixelBufferLockBaseAddress(pixelBuffer, 0);
      v10 = CVPixelBufferGetPixelFormatType(pixelBuffer);
      v11 = CVPixelBufferGetWidthOfPlane(pixelBuffer, 0);
      v12 = CVPixelBufferGetHeightOfPlane(pixelBuffer, 0);
      BytesPerRowOfPlane = CVPixelBufferGetBytesPerRowOfPlane(pixelBuffer, 0);
      BaseAddressOfPlane = (char *)CVPixelBufferGetBaseAddressOfPlane(pixelBuffer, 0);
      objc_msgSend(objc_retainAutorelease(v3), "UTF8String");
      std::ofstream::basic_ofstream(buf);
      v15 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"P6", 2);
      std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(_QWORD *)(*v15 - 24)));
      v16 = std::locale::use_facet(&v39, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      v17 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"# ARKit image dump", 18);
      std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
      v18 = std::locale::use_facet(&v39, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      v19 = (_QWORD *)std::ostream::operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v19, (uint64_t)" ", 1);
      v20 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v20 + *(_QWORD *)(*v20 - 24)));
      v21 = std::locale::use_facet(&v39, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v21->__vftable[2].~facet_0)(v21, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      v22 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(buf, (uint64_t)"255", 3);
      std::ios_base::getloc((const std::ios_base *)((char *)v22 + *(_QWORD *)(*v22 - 24)));
      v23 = std::locale::use_facet(&v39, MEMORY[0x1E0DE4A90]);
      ((void (*)(const std::locale::facet *, uint64_t))v23->__vftable[2].~facet_0)(v23, 10);
      std::locale::~locale(&v39);
      std::ostream::put();
      std::ostream::flush();
      switch(v10)
      {
        case 0x20u:
          if (v12)
          {
            v29 = 0;
            v30 = BaseAddressOfPlane + 3;
            do
            {
              v31 = v11;
              for (i = v30; v31; --v31)
              {
                ARSavePixelBufferPPM::color = *(i - 2);
                byte_1EF082AB1 = *(i - 1);
                byte_1EF082AB2 = *i;
                std::ostream::write();
                i += 4;
              }
              ++v29;
              v30 += BytesPerRowOfPlane;
            }
            while (v29 != v12);
          }
          break;
        case 0x42475241u:
          if (v12)
          {
            v33 = 0;
            v34 = BaseAddressOfPlane + 2;
            do
            {
              v35 = v11;
              for (j = v34; v35; --v35)
              {
                ARSavePixelBufferPPM::color = *j;
                byte_1EF082AB4 = *(j - 1);
                byte_1EF082AB5 = *(j - 2);
                std::ostream::write();
                j += 4;
              }
              ++v33;
              v34 += BytesPerRowOfPlane;
            }
            while (v33 != v12);
          }
          break;
        case 0x4C303038u:
          if (v12)
          {
            for (k = 0; k != v12; ++k)
            {
              v25 = v11;
              for (m = BaseAddressOfPlane; v25; --v25)
              {
                ARSavePixelBufferPPM::color = *m;
                byte_1EF082AB7 = *m;
                v27 = *m++;
                byte_1EF082AB8 = v27;
                std::ostream::write();
              }
              BaseAddressOfPlane += BytesPerRowOfPlane;
            }
          }
          break;
        default:
          v8 = 4294960616;
          goto LABEL_43;
      }
      v8 = 0;
LABEL_43:
      if (!std::filebuf::close())
        std::ios_base::clear((std::ios_base *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)], *(_DWORD *)&v41[*(_QWORD *)(*(_QWORD *)buf - 24) + 24] | 4);
      CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
      CVPixelBufferRelease(pixelBuffer);
      *(_QWORD *)buf = *MEMORY[0x1E0DE4F48];
      *(_QWORD *)&buf[*(_QWORD *)(*(_QWORD *)buf - 24)] = *(_QWORD *)(MEMORY[0x1E0DE4F48] + 24);
      MEMORY[0x1B5E2D450](v41);
      std::ostream::~ostream();
      MEMORY[0x1B5E2D57C](v42);
      goto LABEL_46;
    }
    v5 = 1278226488;
  }
  if (PixelFormatType == v5)
    goto LABEL_8;
  _ARLogGeneral();
  v28 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v28, OS_LOG_TYPE_ERROR))
  {
    *(_WORD *)buf = 0;
    _os_log_impl(&dword_1B3A68000, v28, OS_LOG_TYPE_ERROR, "Supported formats are kCVPixelFormatType_420YpCbCr8BiPlanarVideoRange, kCVPixelFormatType_420YpCbCr8BiPlanarFullRange, kCVPixelFormatType_OneComponent8 or kCVPixelFormatType_32ARGB", buf, 2u);
  }

  v8 = 4294960616;
LABEL_46:

  return v8;
}

void sub_1B3BC3A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, char a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

uint64_t ARSavePixelBufferEXR(__CVBuffer *a1, void *a2)
{
  id v3;
  OSType PixelFormatType;
  OSType v5;
  size_t WidthOfPlane;
  size_t HeightOfPlane;
  uint64_t v8;
  NSObject *v9;
  const char *v10;
  NSObject *v11;
  void *BaseAddressOfPlane;
  size_t DataSize;
  CGDataProvider *v14;
  CGColorSpace *DeviceRGB;
  size_t BytesPerRow;
  CGImage *v17;
  const __CFAllocator *v18;
  const __CFString *v19;
  CGImageDestination *v20;
  const __CFDictionary *v21;
  BOOL v22;
  NSObject *v23;
  uint8_t buf[16];
  CVPixelBufferRef pixelBufferOut;
  void *values;
  void *keys[2];

  keys[1] = *(void **)MEMORY[0x1E0C80C00];
  v3 = a2;
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  v5 = PixelFormatType;
  if (PixelFormatType == 843264104 || PixelFormatType == 1380411457)
  {
    WidthOfPlane = CVPixelBufferGetWidthOfPlane(a1, 0);
    HeightOfPlane = CVPixelBufferGetHeightOfPlane(a1, 0);
    pixelBufferOut = 0;
    if (v5 != 1380411457)
    {
      if (v5 == 843264104)
      {
        v8 = CVPixelBufferCreate((CFAllocatorRef)*MEMORY[0x1E0C9AE00], WidthOfPlane, HeightOfPlane, 0x52476841u, 0, &pixelBufferOut);
        if ((_DWORD)v8)
        {
          _ARLogGeneral();
          v9 = objc_claimAutoreleasedReturnValue();
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            LODWORD(keys[0]) = 67109120;
            HIDWORD(keys[0]) = v8;
            v10 = "CVPixelBufferCreate failed to create pixel buffer of type kCVPixelFormatType_128RGBAFloat with error %i";
LABEL_19:
            _os_log_impl(&dword_1B3A68000, v9, OS_LOG_TYPE_ERROR, v10, (uint8_t *)keys, 8u);
            goto LABEL_23;
          }
          goto LABEL_23;
        }
        v8 = ARPixelBufferConvertTwoComponent16HalfToRGBAHalf(a1, &pixelBufferOut);
        if (!(_DWORD)v8)
        {
LABEL_12:
          CVPixelBufferLockBaseAddress(pixelBufferOut, 0);
          BaseAddressOfPlane = CVPixelBufferGetBaseAddressOfPlane(pixelBufferOut, 0);
          DataSize = CVPixelBufferGetDataSize(pixelBufferOut);
          v14 = CGDataProviderCreateWithData(0, BaseAddressOfPlane, DataSize, 0);
          DeviceRGB = CGColorSpaceCreateDeviceRGB();
          BytesPerRow = CVPixelBufferGetBytesPerRow(pixelBufferOut);
          v17 = CGImageCreate(WidthOfPlane, HeightOfPlane, 0x10uLL, 0x40uLL, BytesPerRow, DeviceRGB, 0x1103u, v14, 0, 0, kCGRenderingIntentDefault);
          objc_msgSend(MEMORY[0x1E0C99E98], "fileURLWithPath:isDirectory:", v3, 0);
          v9 = objc_claimAutoreleasedReturnValue();
          v18 = (const __CFAllocator *)*MEMORY[0x1E0C9AE00];
          v19 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E0C9AE00], "com.ilm.openexr-image", 0x8000100u);
          v20 = CGImageDestinationCreateWithURL((CFURLRef)v9, v19, 1uLL, 0);
          keys[0] = *(void **)MEMORY[0x1E0CBC768];
          values = (void *)*MEMORY[0x1E0C9AE50];
          v21 = CFDictionaryCreate(v18, (const void **)keys, (const void **)&values, 1, MEMORY[0x1E0C9B390], MEMORY[0x1E0C9B3A0]);
          CGImageDestinationAddImage(v20, v17, v21);
          v22 = CGImageDestinationFinalize(v20);
          if (v20)
            CFRelease(v20);
          CFRelease(v21);
          CFRelease(v19);
          CGImageRelease(v17);
          CGColorSpaceRelease(DeviceRGB);
          CGDataProviderRelease(v14);
          CVPixelBufferUnlockBaseAddress(pixelBufferOut, 0);
          CVPixelBufferRelease(pixelBufferOut);
          if (v22)
          {
            v8 = 0;
          }
          else
          {
            _ARLogGeneral();
            v23 = objc_claimAutoreleasedReturnValue();
            if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
            {
              *(_WORD *)buf = 0;
              _os_log_impl(&dword_1B3A68000, v23, OS_LOG_TYPE_ERROR, "Could not save image to file", buf, 2u);
            }

            v8 = 4294960636;
          }
          goto LABEL_23;
        }
      }
      else
      {
        v8 = 4294960636;
      }
      _ARLogGeneral();
      v9 = objc_claimAutoreleasedReturnValue();
      if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
      {
        LODWORD(keys[0]) = 67109120;
        HIDWORD(keys[0]) = v8;
        v10 = "Could not convert pixel formats with error: %i";
        goto LABEL_19;
      }
LABEL_23:

      goto LABEL_24;
    }
    pixelBufferOut = a1;
    CVPixelBufferRetain(a1);
    goto LABEL_12;
  }
  _ARLogGeneral();
  v11 = objc_claimAutoreleasedReturnValue();
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    LOWORD(pixelBufferOut) = 0;
    _os_log_impl(&dword_1B3A68000, v11, OS_LOG_TYPE_ERROR, "Supported pixel formats are kCVPixelFormatType_64RGBAHalf, kCVPixelFormatType_TwoComponent16Half", (uint8_t *)&pixelBufferOut, 2u);
  }

  v8 = 4294960616;
LABEL_24:

  return v8;
}

void sub_1B3BC3E88(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t ARResizeBufferWithNearestNeighbors(__CVBuffer *a1, __CVBuffer *a2, size_t a3)
{
  size_t Height;
  size_t Width;
  size_t v8;
  size_t v9;
  OSType PixelFormatType;
  uint64_t result;
  float v12;
  float v13;
  size_t BytesPerRow;
  char *v15;
  size_t v16;
  unint64_t i;
  size_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  __CVBuffer *pixelBuffer;
  __CVBuffer *v23;
  char *BaseAddress;

  Height = CVPixelBufferGetHeight(a1);
  Width = CVPixelBufferGetWidth(a1);
  v8 = CVPixelBufferGetHeight(a2);
  v9 = CVPixelBufferGetWidth(a2);
  PixelFormatType = CVPixelBufferGetPixelFormatType(a1);
  if (PixelFormatType != CVPixelBufferGetPixelFormatType(a2))
    return 4294960616;
  result = 4294960615;
  if (Height && Width && v8 && v9)
  {
    v12 = (float)Height / (float)v8;
    v13 = (float)Width / (float)v9;
    CVPixelBufferLockBaseAddress(a1, 0);
    CVPixelBufferLockBaseAddress(a2, 0);
    BaseAddress = (char *)CVPixelBufferGetBaseAddress(a1);
    pixelBuffer = a1;
    BytesPerRow = CVPixelBufferGetBytesPerRow(a1);
    v15 = (char *)CVPixelBufferGetBaseAddress(a2);
    v23 = a2;
    v16 = CVPixelBufferGetBytesPerRow(a2);
    for (i = 0; i != v18; ++i)
    {
      v18 = v8;
      v19 = 0;
      v20 = &BaseAddress[BytesPerRow * vcvtms_u32_f32(v12 * (float)i)];
      v21 = v15;
      do
      {
        memcpy(v21, &v20[vcvtas_u32_f32(v13 * (float)v19++) * a3], a3);
        v21 += a3;
      }
      while (v9 != v19);
      v15 += v16;
      v8 = v18;
    }
    CVPixelBufferUnlockBaseAddress(pixelBuffer, 0);
    CVPixelBufferUnlockBaseAddress(v23, 0);
    return 0;
  }
  return result;
}

BOOL ARDrawNormalizedCGRectIntoYUVPixelBuffer(__CVBuffer *a1, int a2, CGFloat a3, CGFloat a4, CGFloat a5, CGFloat a6)
{
  OSType v12;
  double x;
  double y;
  double width;
  unint64_t v16;
  double v17;
  unint64_t v18;
  vImagePixelCount v19;
  unint64_t v20;
  unint64_t v21;
  double v22;
  double v23;
  double v24;
  double v25;
  int v26;
  unint64_t v27;
  uint64_t v28;
  double v29;
  unint64_t v30;
  double v31;
  unint64_t v32;
  vImagePixelCount v33;
  unint64_t v34;
  unint64_t v35;
  float v36;
  unint64_t v37;
  float v38;
  float v39;
  unint64_t v40;
  unint64_t v42;
  int v43;
  int v44;
  double height;
  vImage_Buffer v46;
  vImage_Buffer dest;
  __int128 v48;
  __int128 v49;
  __int128 v50;
  __int128 v51;
  CGRect v52;
  CGRect v53;
  CGRect v54;

  v12 = CVPixelBufferGetPixelFormatType(a1) & 0xFFFFFFEF;
  if (v12 == 875704422)
  {
    v54.origin.x = 0.0;
    v54.origin.y = 0.0;
    v54.size.width = 1.0;
    v54.size.height = 1.0;
    v52.origin.x = a3;
    v52.origin.y = a4;
    v52.size.width = a5;
    v52.size.height = a6;
    v53 = CGRectIntersection(v52, v54);
    x = v53.origin.x;
    y = v53.origin.y;
    width = v53.size.width;
    height = v53.size.height;
    CVPixelBufferLockBaseAddress(a1, 0);
    v50 = 0u;
    v51 = 0u;
    ARWrapCVPixelBufferPlaneVImage(a1, 0, (void **)&v50);
    v48 = 0u;
    v49 = 0u;
    ARWrapCVPixelBufferPlaneVImage(a1, 1uLL, (void **)&v48);
    v16 = (unint64_t)(x * (double)(unint64_t)v51);
    v17 = (double)*((unint64_t *)&v50 + 1);
    v18 = (unint64_t)(y * (double)*((unint64_t *)&v50 + 1));
    v19 = (unint64_t)(width * (double)(unint64_t)v51);
    v20 = v49;
    v21 = *((_QWORD *)&v48 + 1);
    v22 = (double)a2;
    v23 = (double)BYTE1(a2);
    v24 = (double)BYTE2(a2);
    v25 = v23 * 0.504 + v22 * 0.257 + v24 * 0.098 + 16.0;
    v26 = (int)v25;
    v27 = v19 + v16;
    if (v19 + v16 <= (uint64_t)v51 - 1)
    {
      v28 = v49;
      if (v18 + 5 <= *((_QWORD *)&v50 + 1) - 1)
      {
        dest.data = (void *)(v50 + *((_QWORD *)&v51 + 1) * v18 + v16);
        dest.height = 5;
        dest.width = (unint64_t)(width * (double)(unint64_t)v51);
        dest.rowBytes = *((_QWORD *)&v51 + 1);
        vImageOverwriteChannelsWithScalar_Planar8((int)v25, &dest, 0x10u);
        v28 = v49;
      }
    }
    else
    {
      v28 = v49;
    }
    v29 = (double)v20;
    v30 = (unint64_t)(x * (double)v20);
    v31 = (double)v21;
    v32 = (unint64_t)(y * (double)v21);
    v33 = (unint64_t)(width * v29);
    v44 = (int)(v23 * -0.291 + v22 * -0.148 + v24 * 0.439 + 128.0);
    v43 = (int)(v23 * -0.368 + v22 * 0.439 + v24 * -0.071 + 128.0);
    v34 = v33 + v30;
    if (v33 + v30 <= v28 - 1 && v32 + 5 <= *((_QWORD *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((_QWORD *)&v49 + 1) * v32 + 2 * v30);
      v46.height = 5;
      v46.width = (unint64_t)(width * v29);
      v46.rowBytes = *((_QWORD *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
      v32 = (unint64_t)(y * (double)v21);
    }
    v42 = v18;
    v35 = v18 + (unint64_t)(height * v17);
    if (v27 <= (uint64_t)v51 - 1)
    {
      v36 = (float)v35 + -5.0;
      if ((unint64_t)v36 + 5 <= *((_QWORD *)&v50 + 1) - 1)
      {
        dest.data = (void *)(v50 + *((_QWORD *)&v51 + 1) * (unint64_t)v36 + v16);
        dest.height = 5;
        dest.width = v19;
        dest.rowBytes = *((_QWORD *)&v51 + 1);
        vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
        v32 = (unint64_t)(y * (double)v21);
      }
    }
    v37 = v32 + (unint64_t)(height * v31);
    if (v34 <= (uint64_t)v49 - 1)
    {
      v38 = (float)v37 + -5.0;
      if ((unint64_t)v38 + 5 <= *((_QWORD *)&v48 + 1) - 1)
      {
        v46.data = (void *)(v48 + *((_QWORD *)&v49 + 1) * (unint64_t)v38 + 2 * v30);
        v46.height = 5;
        v46.width = v33;
        v46.rowBytes = *((_QWORD *)&v49 + 1);
        vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
        v32 = (unint64_t)(y * (double)v21);
      }
    }
    if (v16 + 5 <= (uint64_t)v51 - 1 && v35 <= *((_QWORD *)&v50 + 1) - 1)
    {
      dest.data = (void *)(v50 + *((_QWORD *)&v51 + 1) * v42 + v16);
      dest.height = (unint64_t)(height * v17);
      dest.width = 5;
      dest.rowBytes = *((_QWORD *)&v51 + 1);
      vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
      v32 = (unint64_t)(y * (double)v21);
    }
    if (v30 + 5 <= (uint64_t)v49 - 1 && v37 <= *((_QWORD *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((_QWORD *)&v49 + 1) * v32 + 2 * v30);
      v46.height = (unint64_t)(height * v31);
      v46.width = 5;
      v46.rowBytes = *((_QWORD *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
      v32 = (unint64_t)(y * (double)v21);
    }
    v39 = (float)v27 + -5.0;
    if ((unint64_t)v39 + 5 <= (uint64_t)v51 - 1 && v35 <= *((_QWORD *)&v50 + 1) - 1)
    {
      dest.data = (void *)(v50 + *((_QWORD *)&v51 + 1) * v42 + (unint64_t)v39);
      dest.height = (unint64_t)(height * v17);
      dest.width = 5;
      dest.rowBytes = *((_QWORD *)&v51 + 1);
      vImageOverwriteChannelsWithScalar_Planar8(v26, &dest, 0x10u);
      v32 = (unint64_t)(y * (double)v21);
    }
    v40 = (unint64_t)(float)((float)v34 + -5.0);
    if (v40 + 5 <= (uint64_t)v49 - 1 && v37 <= *((_QWORD *)&v48 + 1) - 1)
    {
      v46.data = (void *)(v48 + *((_QWORD *)&v49 + 1) * v32 + 2 * v40);
      v46.height = (unint64_t)(height * v31);
      v46.width = 5;
      v46.rowBytes = *((_QWORD *)&v49 + 1);
      vImageOverwriteChannelsWithScalar_Planar16U(v44 | ((_WORD)v43 << 8), &v46, 0x10u);
    }
    CVPixelBufferUnlockBaseAddress(a1, 0);
  }
  return v12 == 875704422;
}

void ___ZL13_ARLogGeneralv_block_invoke_28()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

void *cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate(uint64_t a1, uint64_t a2)
{
  void *result;
  unint64_t size;

  size = *(unsigned int *)(a1 + 4) * (unint64_t)*(unsigned int *)(a2 + 4);
  if (!size)
    return 0;
  result = malloc_type_malloc(size, 0xA153FF5uLL);
  if (!result)
    cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate();
  return result;
}

uint64_t cva::ArrayIterator<float,2u>::increment(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  int v4;
  int v5;

  v1 = *(_QWORD *)(result + 32);
  if (!v1)
    cva::ArrayIterator<float,2u>::increment();
  v2 = *(unsigned int *)(result + 16);
  v3 = v1 + v2;
  v4 = *(_DWORD *)(result + 24) + 1;
  *(_DWORD *)(result + 24) = v4;
  if (v4 == *(_DWORD *)(result + 8))
  {
    v3 = v3 - (v2 * v4) + *(unsigned int *)(result + 20);
    v5 = *(_DWORD *)(result + 28) + 1;
    *(_DWORD *)(result + 24) = 0;
    *(_DWORD *)(result + 28) = v5;
  }
  *(_QWORD *)(result + 32) = v3;
  return result;
}

uint64_t **thirdparty::quadprogpp::seq@<X0>(uint64_t **this@<X0>, unsigned int a2@<W1>, uint64_t a3@<X8>)
{
  unsigned int i;

  *(_QWORD *)(a3 + 16) = 0;
  *(_QWORD *)(a3 + 8) = 0;
  *(_QWORD *)a3 = a3 + 8;
  for (i = this; i <= a2; ++i)
    this = std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a3, &i, &i);
  return this;
}

void sub_1B3BC4724(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t **thirdparty::quadprogpp::singleton@<X0>(thirdparty::quadprogpp *this@<X0>, uint64_t a2@<X8>)
{
  unsigned int v3;

  v3 = this;
  *(_QWORD *)(a2 + 16) = 0;
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)a2 = a2 + 8;
  return std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>((uint64_t **)a2, &v3, &v3);
}

void sub_1B3BC4780(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__tree<std::array<unsigned char,16ul>>::destroy(v1, *(_QWORD **)(v1 + 8));
  _Unwind_Resume(a1);
}

uint64_t **std::__tree<unsigned int>::__emplace_unique_key_args<unsigned int,unsigned int const&>(uint64_t **a1, unsigned int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  unsigned int v7;
  uint64_t **v8;
  unsigned int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

void sub_1B3BC4BE8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_1B3BC5A04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,void *a21,void *a22,void *a23,void *a24,void *a25,void *a26,void *a27)
{
  void *v27;
  void *v28;
  void *v30;

  v30 = (void *)STACK[0x268];
  if (STACK[0x268])
  {
    STACK[0x270] = (unint64_t)v30;
    operator delete(v30);
  }

  _Unwind_Resume(a1);
}

void ARNoiseModel::~ARNoiseModel(ARNoiseModel *this)
{
  void *v2;
  void **v3;

  v3 = (void **)((char *)this + 24);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&v3);
  v2 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v2;
    operator delete(v2);
  }
}

void ___ZL13_ARLogGeneralv_block_invoke_29()
{
  os_log_t v0;
  void *v1;

  v0 = os_log_create("com.apple.ARKit", "General");
  v1 = (void *)_ARLogGeneral(void)::logObj;
  _ARLogGeneral(void)::logObj = (uint64_t)v0;

}

float std::normal_distribution<float>::operator()<std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>>(uint64_t a1, std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this, float *a3)
{
  float v5;
  float v7;
  float v8;
  float v9;
  float v10;

  if (*(_BYTE *)(a1 + 12))
  {
    *(_BYTE *)(a1 + 12) = 0;
    v5 = *(float *)(a1 + 8);
  }
  else
  {
    do
    {
      do
      {
        v7 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this)
                           * 2.3283e-10)
                   * 2.0)
           + -1.0;
        v8 = (float)((float)((float)std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(this)
                           * 2.3283e-10)
                   * 2.0)
           + -1.0;
        v9 = (float)(v8 * v8) + (float)(v7 * v7);
      }
      while (v9 > 1.0);
    }
    while (v9 == 0.0);
    v10 = sqrtf((float)(logf((float)(v8 * v8) + (float)(v7 * v7)) * -2.0) / v9);
    *(float *)(a1 + 8) = v8 * v10;
    *(_BYTE *)(a1 + 12) = 1;
    v5 = v7 * v10;
  }
  return *a3 + (float)(v5 * a3[1]);
}

std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type std::mersenne_twister_engine<unsigned int,32ul,624ul,397ul,31ul,2567483615u,11ul,4294967295u,7ul,2636928640u,15ul,4022730752u,18ul,1812433253u>::operator()(std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253> *this)
{
  size_t i;
  size_t v2;
  std::mersenne_twister_engine<unsigned int, 32, 624, 397, 31, 2567483615, 11, 4294967295, 7, 2636928640, 15, 4022730752, 18, 1812433253>::result_type v3;

  i = this->__i_;
  v2 = (i + 1) % 0x270;
  v3 = this->__x_[(i + 397) % 0x270] ^ ((this->__x_[v2] & 0x7FFFFFFE | this->__x_[i] & 0x80000000) >> 1) ^ ((int)(this->__x_[v2] << 31) >> 31) & 0x9908B0DF;
  this->__x_[i] = v3;
  this->__i_ = v2;
  LODWORD(i) = ((v3 ^ (v3 >> 11)) << 7) & 0x9D2C5680 ^ v3 ^ (v3 >> 11);
  return ((_DWORD)i << 15) & 0xEFC60000 ^ i ^ ((((_DWORD)i << 15) & 0xEFC60000 ^ i) >> 18);
}

void sub_1B3BC71B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, uint64_t a20,char a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a17, 8);
  _Block_object_dispose(&a21, 8);
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__7(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__7(uint64_t a1)
{

}

void sub_1B3BC7B8C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void std::vector<simd_float4x4>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 6;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + (a2 << 6);
  }
  else
  {
    std::vector<simd_float4x4>::__append((void **)a1, a2 - v2);
  }
}

void sub_1B3BC7DD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v13 = v11;

  _Unwind_Resume(a1);
}

void sub_1B3BC8060(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_1B3BC825C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_1B3BC836C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BC83BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BC840C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BC8988(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void *a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32)
{
  void *v32;

  _Unwind_Resume(a1);
}

void sub_1B3BC8AE0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_1B3BC8BD8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<simd_float4x4>::__init_with_size[abi:ne180100]<simd_float4x4 const*,simd_float4x4 const*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<simd_float4x4>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3BC8CA4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<ARSRT>::__init_with_size[abi:ne180100]<ARSRT const*,ARSRT const*>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<ARSRT>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3BC8D1C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<simd_float4x4>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;
  __int128 v19;
  __int128 v20;
  __int128 v21;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 6)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), a2 << 6);
      v7 += 64 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 6);
    if (v9 >> 58)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 6;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 5 > v9)
      v9 = v11 >> 5;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFC0)
      v12 = 0x3FFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<arkit::BoundingBoxGroup>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[64 * v10];
    v15 = &v13[64 * v12];
    bzero(v14, a2 << 6);
    v16 = &v14[64 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        v19 = *((_OWORD *)v17 - 4);
        v20 = *((_OWORD *)v17 - 3);
        v21 = *((_OWORD *)v17 - 1);
        *((_OWORD *)v14 - 2) = *((_OWORD *)v17 - 2);
        *((_OWORD *)v14 - 1) = v21;
        *((_OWORD *)v14 - 4) = v19;
        *((_OWORD *)v14 - 3) = v20;
        v14 -= 64;
        v17 -= 64;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

char *std::vector<simd_float4x4>::__assign_with_size[abi:ne180100]<simd_float4x4*,simd_float4x4*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 6)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 58)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 5;
    if (v8 >> 5 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFC0)
      v11 = 0x3FFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<simd_float4x4>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 6;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[64 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<ARSRT>::__assign_with_size[abi:ne180100]<ARSRT*,ARSRT*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  void **v13;
  char *v14;
  _BYTE *v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (0xAAAAAAAAAAAAAAABLL * ((v8 - *(_QWORD *)result) >> 4) < a4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 > 0x555555555555555)
      std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
    v10 = 0xAAAAAAAAAAAAAAABLL * (v8 >> 4);
    v11 = 2 * v10;
    if (2 * v10 <= a4)
      v11 = a4;
    if (v10 >= 0x2AAAAAAAAAAAAAALL)
      v12 = 0x555555555555555;
    else
      v12 = v11;
    result = std::vector<ARSRT>::__vallocate[abi:ne180100](v7, v12);
    v14 = (char *)v7[1];
    v13 = (void **)(v7 + 1);
    v9 = v14;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v13 = (void **)(result + 8);
  v15 = (_BYTE *)*((_QWORD *)result + 1);
  if (0xAAAAAAAAAAAAAAABLL * ((v15 - v9) >> 4) >= a4)
    goto LABEL_16;
  v16 = &__src[16 * ((v15 - v9) >> 4)];
  if (v15 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v15 - v9);
    v9 = (char *)*v13;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v13 = &v9[v17];
  return result;
}

void ARCoreAnalyticsEventCreateAndReport(void *a1, void *a2)
{
  id v3;
  id v4;

  v4 = a1;
  v3 = a2;
  if (ARShouldNotReportToCoreAnalytics_onceToken != -1)
    dispatch_once(&ARShouldNotReportToCoreAnalytics_onceToken, &__block_literal_global_126);
  if (!ARShouldNotReportToCoreAnalytics_shouldNotReportToCoreAnalytics)
    AnalyticsSendEvent();

}

void ARLabHistogramCreate(void *a1@<X8>)
{
  bzero(a1, 0x404uLL);
}

float AREarthMoversDistance(uint64_t a1, uint64_t a2, double a3, __n128 a4)
{
  uint64_t v6;
  uint64_t i;
  uint64_t j;
  float v9;
  float v10;
  double v11;
  double *v12;
  double *v13;
  double *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  double *v20;
  uint64_t v21;
  __n128 *v22;
  __n128 *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  char *v27;
  __n128 *v28;
  __n128 *v29;
  __n128 *v30;
  __n128 v31;
  double v32;
  double *v33;
  double *v34;
  double *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  unint64_t v39;
  char *v40;
  double *v41;
  uint64_t v42;
  __n128 *v43;
  __n128 *v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  char *v48;
  __n128 *v49;
  __n128 *v50;
  __n128 *v51;
  __n128 v52;
  double *v53;
  double *v54;
  uint64_t v55;
  unint64_t v56;
  double *v57;
  double *v58;
  unint64_t v59;
  float32x4_t *v60;
  float32x4_t *v61;
  double **v62;
  double *v63;
  float32x4_t *v64;
  unint64_t v65;
  float32x4_t v66;
  float32x4_t v67;
  float32x4_t v68;
  float v69;
  __n128 v71;
  uint64_t v72;
  void *v73[3];
  double **v74[3];
  void *v75;
  __n128 *v76;
  __n128 *v77;
  void *__p;
  double *v79;
  double *v80;
  __n128 *v81;
  __n128 *v82;
  __n128 *v83;
  double *v84;
  double *v85;
  double *v86;

  v6 = 0;
  v84 = 0;
  v85 = 0;
  v86 = 0;
  v81 = 0;
  v82 = 0;
  v83 = 0;
  __p = 0;
  v79 = 0;
  v80 = 0;
  v75 = 0;
  v76 = 0;
  v77 = 0;
  do
  {
    for (i = 0; i != 8; ++i)
    {
      for (j = 0; j != 4; ++j)
      {
        v9 = *(float *)(a1 + (j << 8) + 32 * i + 4 * v6 + 4);
        v10 = *(float *)(a2 + (j << 8) + 32 * i + 4 * v6 + 4);
        if (v9 > 0.0 || v10 > 0.0)
        {
          v11 = v9;
          v12 = v85;
          if (v85 >= v86)
          {
            v14 = v84;
            v15 = v85 - v84;
            v16 = v15 + 1;
            if ((unint64_t)(v15 + 1) >> 61)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v17 = (char *)v86 - (char *)v84;
            if (((char *)v86 - (char *)v84) >> 2 > v16)
              v16 = v17 >> 2;
            if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFF8)
              v18 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v18 = v16;
            if (v18)
            {
              v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)&v86, v18);
              v14 = v84;
              v12 = v85;
            }
            else
            {
              v19 = 0;
            }
            v20 = (double *)&v19[8 * v15];
            *v20 = v11;
            v13 = v20 + 1;
            while (v12 != v14)
            {
              v21 = *((_QWORD *)v12-- - 1);
              *((_QWORD *)v20-- - 1) = v21;
            }
            v84 = v20;
            v85 = v13;
            v86 = (double *)&v19[8 * v18];
            if (v14)
              operator delete(v14);
          }
          else
          {
            *v85 = v11;
            v13 = v12 + 1;
          }
          a4.n128_f32[0] = (float)(int)j + (float)(int)j;
          a4.n128_f32[1] = (float)(int)i;
          v85 = v13;
          a4.n128_f32[2] = (float)(int)v6;
          v22 = v82;
          v71 = a4;
          if (v82 >= v83)
          {
            v24 = v82 - v81;
            if ((unint64_t)(v24 + 1) >> 60)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v25 = ((char *)v83 - (char *)v81) >> 3;
            if (v25 <= v24 + 1)
              v25 = v24 + 1;
            if ((unint64_t)((char *)v83 - (char *)v81) >= 0x7FFFFFFFFFFFFFF0)
              v26 = 0xFFFFFFFFFFFFFFFLL;
            else
              v26 = v25;
            if (v26)
              v27 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v83, v26);
            else
              v27 = 0;
            v28 = (__n128 *)&v27[16 * v24];
            *v28 = v71;
            v23 = v28 + 1;
            v30 = v81;
            v29 = v82;
            if (v82 != v81)
            {
              do
              {
                v31 = v29[-1];
                --v29;
                v28[-1] = v31;
                --v28;
              }
              while (v29 != v30);
              v29 = v81;
            }
            v81 = v28;
            v82 = v23;
            v83 = (__n128 *)&v27[16 * v26];
            if (v29)
              operator delete(v29);
          }
          else
          {
            *v82 = a4;
            v23 = v22 + 1;
          }
          v82 = v23;
          v32 = v10;
          v33 = v79;
          if (v79 >= v80)
          {
            v35 = (double *)__p;
            v36 = ((char *)v79 - (_BYTE *)__p) >> 3;
            v37 = v36 + 1;
            if ((unint64_t)(v36 + 1) >> 61)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v38 = (char *)v80 - (_BYTE *)__p;
            if (((char *)v80 - (_BYTE *)__p) >> 2 > v37)
              v37 = v38 >> 2;
            if ((unint64_t)v38 >= 0x7FFFFFFFFFFFFFF8)
              v39 = 0x1FFFFFFFFFFFFFFFLL;
            else
              v39 = v37;
            if (v39)
            {
              v40 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<cva::Matrix<unsigned int,2u,1u,false>>>((uint64_t)&v80, v39);
              v35 = (double *)__p;
              v33 = v79;
            }
            else
            {
              v40 = 0;
            }
            v41 = (double *)&v40[8 * v36];
            *v41 = v32;
            v34 = v41 + 1;
            while (v33 != v35)
            {
              v42 = *((_QWORD *)v33-- - 1);
              *((_QWORD *)v41-- - 1) = v42;
            }
            __p = v41;
            v79 = v34;
            v80 = (double *)&v40[8 * v39];
            if (v35)
              operator delete(v35);
          }
          else
          {
            *v79 = v32;
            v34 = v33 + 1;
          }
          v79 = v34;
          v43 = v76;
          if (v76 >= v77)
          {
            v45 = ((char *)v76 - (_BYTE *)v75) >> 4;
            if ((unint64_t)(v45 + 1) >> 60)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v46 = ((char *)v77 - (_BYTE *)v75) >> 3;
            if (v46 <= v45 + 1)
              v46 = v45 + 1;
            if ((unint64_t)((char *)v77 - (_BYTE *)v75) >= 0x7FFFFFFFFFFFFFF0)
              v47 = 0xFFFFFFFFFFFFFFFLL;
            else
              v47 = v46;
            if (v47)
              v48 = (char *)_ZNSt3__119__allocate_at_leastB8ne180100INS_9allocatorIDv3_fEEEENS_19__allocation_resultINS_16allocator_traitsIT_E7pointerEEERS6_m((uint64_t)&v77, v47);
            else
              v48 = 0;
            v49 = (__n128 *)&v48[16 * v45];
            *v49 = v71;
            v44 = v49 + 1;
            v51 = (__n128 *)v75;
            v50 = v76;
            if (v76 != v75)
            {
              do
              {
                v52 = v50[-1];
                --v50;
                v49[-1] = v52;
                --v49;
              }
              while (v50 != v51);
              v50 = (__n128 *)v75;
            }
            v75 = v49;
            v76 = v44;
            v77 = (__n128 *)&v48[16 * v47];
            if (v50)
              operator delete(v50);
          }
          else
          {
            *v76 = v71;
            v44 = v43 + 1;
          }
          v76 = v44;
        }
      }
    }
    ++v6;
  }
  while (v6 != 8);
  v54 = v84;
  v53 = v85;
  v72 = 0;
  std::vector<double>::vector(v73, ((char *)v79 - (_BYTE *)__p) >> 3, &v72);
  std::vector<std::vector<double>>::vector(v74, v53 - v54, (uint64_t)v73);
  if (v73[0])
  {
    v73[1] = v73[0];
    operator delete(v73[0]);
  }
  if (v85 == v84)
    goto LABEL_87;
  v55 = 0;
  v56 = v85 - v84;
  v58 = (double *)__p;
  v57 = v79;
  v59 = ((char *)v79 - (_BYTE *)__p) >> 3;
  v60 = (float32x4_t *)v81;
  v61 = (float32x4_t *)v75;
  v62 = v74[0];
  if (v59 <= 1)
    v59 = 1;
  if (v56 <= 1)
    v56 = 1;
  do
  {
    if (v57 != v58)
    {
      v63 = v62[3 * v55];
      v64 = v61;
      v65 = v59;
      do
      {
        v66 = *v64++;
        v67 = vsubq_f32(v60[v55], v66);
        v68 = vmulq_f32(v67, v67);
        *v63++ = sqrtf(vaddq_f32((float32x4_t)vdupq_laneq_s32((int32x4_t)v68, 2), vaddq_f32(v68, (float32x4_t)vdupq_lane_s32(*(int32x2_t *)v68.f32, 1))).f32[0]);
        --v65;
      }
      while (v65);
    }
    ++v55;
  }
  while (v55 != v56);
  if (v79 == __p)
LABEL_87:
    v69 = INFINITY;
  else
    v69 = emd_hat_gd_metric<double,(FLOW_TYPE_T)0>::operator()(-1.0, (uint64_t)v73, (uint64_t)&v84, (uint64_t)&__p, v74);
  v73[0] = v74;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)v73);
  if (v75)
  {
    v76 = (__n128 *)v75;
    operator delete(v75);
  }
  if (__p)
  {
    v79 = (double *)__p;
    operator delete(__p);
  }
  if (v81)
  {
    v82 = v81;
    operator delete(v81);
  }
  if (v84)
  {
    v85 = v84;
    operator delete(v84);
  }
  return v69;
}

void sub_1B3BC969C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,void *__p,uint64_t a27,uint64_t a28,void *a29,uint64_t a30)
{
  uint64_t v30;
  void *v32;
  void *v33;

  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  if (__p)
  {
    a27 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a29)
  {
    a30 = (uint64_t)a29;
    operator delete(a29);
  }
  v32 = *(void **)(v30 - 152);
  if (v32)
  {
    *(_QWORD *)(v30 - 144) = v32;
    operator delete(v32);
  }
  v33 = *(void **)(v30 - 128);
  if (v33)
  {
    *(_QWORD *)(v30 - 120) = v33;
    operator delete(v33);
  }
  _Unwind_Resume(a1);
}

double emd_hat_gd_metric<double,(FLOW_TYPE_T)0>::operator()(double a1, uint64_t a2, uint64_t a3, uint64_t a4, double ***a5)
{
  char *v9;
  uint64_t v10;
  unint64_t v11;
  double *v12;
  double *v13;
  double v14;
  double v15;
  double *v16;
  double v17;
  char v19;
  void *__p;
  void *v21;
  uint64_t v22;
  void *v23;
  _BYTE *v24;
  uint64_t v25;

  v23 = 0;
  v24 = 0;
  v25 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&v23, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
  __p = 0;
  v21 = 0;
  v22 = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, *(const void **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
  v9 = (char *)v23;
  if (v24 != v23)
  {
    v10 = 0;
    v11 = (v24 - (_BYTE *)v23) >> 3;
    v12 = (double *)__p;
    if (v11 <= 1)
      v11 = 1;
    v13 = (double *)v23;
    do
    {
      v14 = *v13;
      v15 = *v12;
      if (*v13 >= *v12)
      {
        *v13 = v14 - v15;
        v16 = v12;
      }
      else
      {
        v16 = (double *)&v9[8 * v10];
        *v12 = v15 - v14;
      }
      *v16 = 0.0;
      ++v10;
      ++v12;
      ++v13;
      --v11;
    }
    while (v11);
  }
  v17 = emd_hat_impl<double,(FLOW_TYPE_T)0>::operator()(a1, (uint64_t)&v19, (uint64_t *)a3, (uint64_t *)a4, (uint64_t *)&v23, (uint64_t *)&__p, a5);
  if (__p)
  {
    v21 = __p;
    operator delete(__p);
  }
  if (v23)
  {
    v24 = v23;
    operator delete(v23);
  }
  return v17;
}

void sub_1B3BC9868(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *__p, uint64_t a12, uint64_t a13, void *a14, uint64_t a15)
{
  if (__p)
    operator delete(__p);
  if (a14)
    operator delete(a14);
  _Unwind_Resume(exception_object);
}

float ARCubemapSimilarity(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;
  void *v9;
  void *v10;
  id v11;
  id v12;
  void *v13;
  float v14;
  void *v15;
  void *v16;
  double v17;
  __n128 v18;
  _BYTE v20[1028];
  _BYTE __dst[1028];
  _BYTE v22[1040];
  _BYTE __src[1040];

  v8 = (void *)MEMORY[0x1E0C80A78](a1, a2, a3, a4, a5, a6, a7, a8);
  v10 = v9;
  v11 = v8;
  v12 = v10;
  v13 = v12;
  v14 = INFINITY;
  if (v11 && v12)
  {
    v15 = (void *)objc_opt_new();
    v16 = v15;
    memset(__src, 0, 512);
    if (v15)
    {
      objc_msgSend(v15, "colorHistogramForCubemap:", v11);
      memset(v22, 0, 512);
      objc_msgSend(v16, "colorHistogramForCubemap:", v13);
    }
    else
    {
      bzero(__src, 0x404uLL);
      bzero(v22, 0x404uLL);
    }
    memcpy(__dst, __src, sizeof(__dst));
    memcpy(v20, v22, sizeof(v20));
    v14 = AREarthMoversDistance((uint64_t)__dst, (uint64_t)v20, v17, v18);

  }
  return v14;
}

void sub_1B3BC9A6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

_QWORD *std::vector<double>::vector(_QWORD *a1, unint64_t a2, _QWORD *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = &v6[a2];
    v8 = 8 * a2;
    do
    {
      *v6++ = *a3;
      v8 -= 8;
    }
    while (v8);
    a1[1] = v7;
  }
  return a1;
}

void sub_1B3BC9AF8(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::vector<double>>::vector(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = 3 * a2;
    v8 = &v6[3 * a2];
    v9 = 8 * v7;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B3BC9BAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3BC9C28(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

double emd_hat_impl<double,(FLOW_TYPE_T)0>::operator()(double a1, uint64_t a2, uint64_t *a3, uint64_t *a4, uint64_t *a5, uint64_t *a6, double ***a7)
{
  uint64_t v13;
  double **v14;
  double v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  double *v20;
  uint64_t v21;
  double v22;
  double v23;
  uint64_t v24;
  double v25;
  double v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  double v36;
  double *v37;
  _QWORD *v38;
  uint64_t v39;
  double v40;
  uint64_t v41;
  double v42;
  double v43;
  double v44;
  void *v46[3];
  void *__p[3];
  uint64_t v48[3];
  void *v49[3];
  void *v50[3];
  void *v51[3];
  void *v52[3];
  char v53;

  v13 = a5[1] - *a5;
  std::vector<long long>::vector(v52, (int)(v13 >> 3));
  std::vector<long long>::vector(v51, (int)(v13 >> 3));
  std::vector<long long>::vector(v50, (int)(v13 >> 3));
  std::vector<long long>::vector(v49, (int)(v13 >> 3));
  std::vector<long long>::vector(__p, (int)(v13 >> 3));
  std::vector<std::vector<long long>>::vector(v48, (int)(v13 >> 3), (uint64_t)__p);
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  std::vector<long long>::vector(v46, (int)(v13 >> 3));
  std::vector<std::vector<long long>>::vector(__p, (int)(v13 >> 3), (uint64_t)v46);
  if (v46[0])
  {
    v46[1] = v46[0];
    operator delete(v46[0]);
  }
  v14 = *a7;
  v15 = ***a7;
  if ((int)((unint64_t)v13 >> 3) <= 0)
  {
    v25 = 0.0;
    v26 = INFINITY;
    v18 = 0.0;
    v19 = 0.0;
    v36 = 1000000.0 / v15;
  }
  else
  {
    v16 = 0;
    v17 = ((unint64_t)v13 >> 3);
    v18 = 0.0;
    v19 = 0.0;
    do
    {
      v18 = v18 + *(double *)(*a3 + 8 * v16);
      v19 = v19 + *(double *)(*a4 + 8 * v16);
      v20 = v14[3 * v16];
      v21 = ((unint64_t)v13 >> 3);
      do
      {
        v22 = *v20++;
        v23 = v22;
        if (v22 > v15)
          v15 = v23;
        --v21;
      }
      while (v21);
      ++v16;
    }
    while (v16 != v17);
    v24 = 0;
    if (v18 >= v19)
      v25 = v18;
    else
      v25 = v19;
    v26 = 1000000.0 / v25;
    v27 = *a3;
    v28 = v52[0];
    v29 = *a4;
    v30 = v51[0];
    v31 = *a5;
    v32 = v50[0];
    v33 = *a6;
    v34 = v49[0];
    v35 = v48[0];
    v36 = 1000000.0 / v15;
    do
    {
      v28[v24] = vcvtmd_s64_f64(*(double *)(v27 + 8 * v24) * v26 + 0.5);
      v30[v24] = vcvtmd_s64_f64(*(double *)(v29 + 8 * v24) * v26 + 0.5);
      v32[v24] = vcvtmd_s64_f64(*(double *)(v31 + 8 * v24) * v26 + 0.5);
      v34[v24] = vcvtmd_s64_f64(*(double *)(v33 + 8 * v24) * v26 + 0.5);
      v37 = v14[3 * v24];
      v38 = *(_QWORD **)(v35 + 24 * v24);
      v39 = ((unint64_t)v13 >> 3);
      do
      {
        v40 = *v37++;
        *v38++ = vcvtmd_s64_f64(v40 * v36 + 0.5);
        --v39;
      }
      while (v39);
      ++v24;
    }
    while (v24 != v17);
  }
  v41 = emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()((uint64_t)&v53, (uint64_t)v52, (uint64_t)v51, (uint64_t)v50, (uint64_t)v49, v48, 0);
  v46[0] = __p;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)v46);
  __p[0] = v48;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  if (v49[0])
  {
    v49[1] = v49[0];
    operator delete(v49[0]);
  }
  if (v50[0])
  {
    v50[1] = v50[0];
    operator delete(v50[0]);
  }
  if (v51[0])
  {
    v51[1] = v51[0];
    operator delete(v51[0]);
  }
  if (v52[0])
  {
    v52[1] = v52[0];
    operator delete(v52[0]);
  }
  if (v19 >= v18)
    v42 = v18;
  else
    v42 = v19;
  v43 = v25 - v42;
  if (a1 == -1.0)
    v44 = v15;
  else
    v44 = a1;
  return (double)v41 / v26 / v36 + v43 * v44;
}

void sub_1B3BC9F44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *a9, uint64_t a10, uint64_t a11, char *a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, void *__p, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,uint64_t a23,void *a24,uint64_t a25,uint64_t a26,void *a27,uint64_t a28)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a9);
  a12 = &a15;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a12);
  if (__p)
  {
    a19 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a21)
  {
    a22 = (uint64_t)a21;
    operator delete(a21);
  }
  if (a24)
  {
    a25 = (uint64_t)a24;
    operator delete(a24);
  }
  if (a27)
  {
    a28 = (uint64_t)a27;
    operator delete(a27);
  }
  _Unwind_Resume(a1);
}

_QWORD *std::vector<long long>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    bzero(v4, 8 * a2);
    a1[1] = &v4[8 * a2];
  }
  return a1;
}

void sub_1B3BCA05C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::vector<long long>>::vector(_QWORD *a1, unint64_t a2, uint64_t a3)
{
  _QWORD *v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v6 = (_QWORD *)a1[1];
    v7 = 3 * a2;
    v8 = &v6[3 * a2];
    v9 = 8 * v7;
    do
    {
      *v6 = 0;
      v6[1] = 0;
      v6[2] = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v6, *(const void **)a3, *(_QWORD *)(a3 + 8), (uint64_t)(*(_QWORD *)(a3 + 8) - *(_QWORD *)a3) >> 3);
      v6 += 3;
      v9 -= 24;
    }
    while (v9);
    a1[1] = v8;
  }
  return a1;
}

void sub_1B3BCA110(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<cva::Matrix<unsigned int,2u,1u,false>>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_1B3BCA18C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t *a6, uint64_t a7)
{
  unint64_t v7;
  uint64_t v8;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  uint64_t *v28;
  uint64_t v29;
  int v30;
  int v31;
  _QWORD *v32;
  uint64_t *v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t *v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _QWORD *v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t *v52;
  uint64_t v53;
  _DWORD *v54;
  uint64_t v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  char *v61;
  _DWORD *v62;
  uint64_t v63;
  int v64;
  uint64_t *v65;
  _DWORD *v66;
  uint64_t v67;
  uint64_t v68;
  char *v69;
  uint64_t v70;
  uint64_t *v71;
  uint64_t v72;
  _DWORD *v73;
  uint64_t v74;
  _DWORD *v75;
  uint64_t v76;
  uint64_t v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  _QWORD *v82;
  _QWORD **v83;
  _QWORD *v84;
  _QWORD **v85;
  uint64_t v86;
  _QWORD *v87;
  _QWORD *v88;
  _QWORD **v89;
  _QWORD *v90;
  _QWORD **v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  std::vector<int>::pointer end;
  int *v96;
  std::vector<int>::pointer begin;
  int64_t v98;
  unint64_t v99;
  int64_t v100;
  unint64_t v101;
  char *v102;
  int *v103;
  int v104;
  int *value;
  std::vector<int>::pointer v106;
  int *v107;
  std::vector<int>::pointer v108;
  int64_t v109;
  unint64_t v110;
  int64_t v111;
  unint64_t v112;
  char *v113;
  int *v114;
  int v115;
  int *v116;
  std::vector<int>::pointer v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  char *v122;
  int *v123;
  int *v124;
  int v125;
  _QWORD *v126;
  _QWORD *v127;
  int v128;
  unint64_t v129;
  std::vector<int>::pointer v130;
  int v131;
  uint64_t v132;
  unint64_t v133;
  std::vector<int>::pointer v134;
  char *v135;
  uint64_t v136;
  uint64_t v137;
  int v138;
  int v139;
  uint64_t v140;
  _DWORD *v141;
  uint64_t *v142;
  uint64_t v143;
  uint64_t *v144;
  unint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  int v152;
  uint64_t v153;
  int v155;
  uint64_t v156;
  uint64_t v157;
  char *v158;
  int v159;
  unint64_t v160;
  uint64_t v161[3];
  char **v162;
  void *__p;
  void *v164;
  uint64_t v165;
  uint64_t v166[3];
  void *v167;
  _BYTE *v168;
  std::vector<int> v169;
  std::vector<int> v170;
  std::vector<int>::value_type __x;
  char *v172;
  char *v173;
  uint64_t *v174;
  _QWORD *v175[2];
  uint64_t *v176;
  _QWORD *v177[2];
  _QWORD *v178;
  _BYTE *v179;
  _QWORD v180[3];
  uint64_t *v181;
  uint64_t *v182;
  uint64_t v183;
  uint64_t *v184;
  uint64_t *v185;
  uint64_t v186;
  void **v187;

  v7 = *(_QWORD *)(a4 + 8) - *(_QWORD *)a4;
  v8 = (int)((uint64_t)v7 >> 3);
  if (v8 != (uint64_t)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 3)
    emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()();
  v184 = 0;
  v185 = 0;
  v186 = 0;
  v181 = 0;
  v182 = 0;
  v183 = 0;
  memset(v180, 0, sizeof(v180));
  std::vector<std::vector<long long>>::__init_with_size[abi:ne180100]<std::vector<long long>*,std::vector<long long>*>(v180, *a6, a6[1], 0xAAAAAAAAAAAAAAABLL * ((a6[1] - *a6) >> 3));
  v12 = v7 >> 3;
  v13 = (v7 >> 3);
  if ((int)(v7 >> 3) < 1)
  {
    v18 = 0;
    v14 = 0;
  }
  else
  {
    v14 = 0;
    v15 = *(uint64_t **)a4;
    v16 = v13;
    do
    {
      v17 = *v15++;
      v14 += v17;
      --v16;
    }
    while (v16);
    v18 = 0;
    v19 = *(uint64_t **)a5;
    v20 = v13;
    do
    {
      v21 = *v19++;
      v18 += v21;
      --v20;
    }
    while (v20);
    if (v18 > v14)
    {
      if (&v184 != (uint64_t **)a5)
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v184, *(char **)a5, *(_QWORD *)(a5 + 8), (uint64_t)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 3);
      if (&v181 != (uint64_t **)a4)
        std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v181, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
      v22 = 0;
      v23 = *a6;
      v24 = v180[0];
      v25 = v18 - v14;
      do
      {
        v26 = *(_QWORD **)(v24 + 24 * v22);
        v27 = v13;
        v28 = (uint64_t *)v23;
        do
        {
          v29 = *v28;
          v28 += 3;
          *v26++ = *(_QWORD *)(v29 + 8 * v22);
          --v27;
        }
        while (v27);
        ++v22;
      }
      while (v22 != v13);
      goto LABEL_23;
    }
  }
  if (&v184 != (uint64_t **)a4)
    std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v184, *(char **)a4, *(_QWORD *)(a4 + 8), (uint64_t)(*(_QWORD *)(a4 + 8) - *(_QWORD *)a4) >> 3);
  if (&v181 != (uint64_t **)a5)
    std::vector<unsigned long>::__assign_with_size[abi:ne180100]<unsigned long *,unsigned long *>((char *)&v181, *(char **)a5, *(_QWORD *)(a5 + 8), (uint64_t)(*(_QWORD *)(a5 + 8) - *(_QWORD *)a5) >> 3);
  v25 = v14 - v18;
LABEL_23:
  v30 = 2 * v12;
  std::vector<long long>::vector(&v178, 2 * (int)v12 + 2);
  v31 = (2 * v12) | 1;
  v32 = v178;
  if ((int)v12 >= 1)
  {
    v33 = v184;
    v34 = v13;
    v35 = v178;
    do
    {
      v36 = *v33++;
      *v35++ = v36;
      --v34;
    }
    while (v34);
  }
  if (v30 <= (int)v12)
  {
    v38 = v30;
  }
  else
  {
    v37 = v181;
    v38 = v30;
    v39 = &v32[v8];
    v40 = v30 - v8;
    do
    {
      v41 = *v37++;
      *v39++ = v41;
      --v40;
    }
    while (v40);
  }
  v157 = v38;
  v32[v38] = -v25;
  v32[v31] = 0;
  if ((int)v12 < 1)
  {
    v43 = 0;
  }
  else
  {
    v42 = 0;
    v43 = 0;
    do
    {
      v44 = *(uint64_t **)(v180[0] + 24 * v42);
      v45 = v13;
      do
      {
        v47 = *v44++;
        v46 = v47;
        if (v47 < 0)
          __assert_rtn("operator()", "emd_hat_impl.hpp", 154, "C[i][j]>=0");
        if (v46 > v43)
          v43 = v46;
        --v45;
      }
      while (v45);
      ++v42;
    }
    while (v42 != v13);
  }
  v177[0] = 0;
  v177[1] = 0;
  v155 = 2 * v12;
  v175[1] = 0;
  v176 = (uint64_t *)v177;
  v174 = (uint64_t *)v175;
  v175[0] = 0;
  std::vector<std::list<edge<long long>>>::vector(&v172, (v179 - (_BYTE *)v32) >> 3);
  v153 = v25;
  if ((int)v12 > 0)
  {
    v159 = v12;
    v152 = v30 | 1;
    v48 = 0;
    v49 = v178;
    do
    {
      if (v49[v48])
      {
        v50 = 0;
        v51 = (_QWORD *)(v180[0] + 24 * v48);
        v52 = (uint64_t *)&v172[24 * v48];
        do
        {
          if (v49[v8 + v50])
          {
            v53 = *(_QWORD *)(*v51 + 8 * v50);
            if (v53 != v43)
            {
              v54 = operator new(0x20uLL);
              v54[4] = v8 + v50;
              *((_QWORD *)v54 + 3) = v53;
              *((_QWORD *)v54 + 1) = v52;
              v55 = *v52;
              *(_QWORD *)v54 = *v52;
              *(_QWORD *)(v55 + 8) = v54;
              *v52 = (uint64_t)v54;
              ++v52[2];
            }
          }
          ++v50;
        }
        while (v13 != v50);
      }
      ++v48;
    }
    while (v48 != v13);
    v56 = 0;
    LODWORD(v162) = 0;
    v31 = v152;
    LODWORD(v12) = v159;
    do
    {
      if (v178[v56])
      {
        v57 = 0;
        v58 = v8;
        do
        {
          if (v178[v58] && *(_QWORD *)(*(_QWORD *)(v180[0] + 24 * (int)v162) + v57) != v43)
          {
            std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v176, (int *)&v162, &v162);
            LODWORD(v170.__begin_) = v58;
            std::__tree<int>::__emplace_unique_key_args<int,int const&>(&v174, (int *)&v170, &v170);
          }
          ++v58;
          v57 += 8;
        }
        while (8 * v13 != v57);
        v56 = (int)v162;
        LODWORD(v12) = v159;
      }
      LODWORD(v162) = ++v56;
    }
    while (v56 < (int)v12);
  }
  if (v155 > (int)v12)
  {
    v59 = &v178[v8];
    v60 = v157 - v8;
    do
    {
      *v59 = -*v59;
      ++v59;
      --v60;
    }
    while (v60);
  }
  if ((int)v12 >= 1)
  {
    v61 = v172;
    do
    {
      v62 = operator new(0x20uLL);
      v62[4] = v155;
      *((_QWORD *)v62 + 3) = 0;
      *((_QWORD *)v62 + 1) = v61;
      v63 = *(_QWORD *)v61;
      *(_QWORD *)v62 = *(_QWORD *)v61;
      *(_QWORD *)(v63 + 8) = v62;
      *(_QWORD *)v61 = v62;
      ++*((_QWORD *)v61 + 2);
      v61 += 24;
      --v13;
    }
    while (v13);
    v64 = 0;
    v65 = (uint64_t *)&v172[24 * (int)v157];
    do
    {
      v66 = operator new(0x20uLL);
      v66[4] = v12 + v64;
      *((_QWORD *)v66 + 3) = v43;
      *((_QWORD *)v66 + 1) = v65;
      v67 = *v65;
      *(_QWORD *)v66 = *v65;
      *(_QWORD *)(v67 + 8) = v66;
      *v65 = (uint64_t)v66;
      ++v65[2];
      ++v64;
    }
    while ((_DWORD)v12 != v64);
  }
  if ((v12 & 0x80000000) == 0)
  {
    v68 = 0;
    v69 = v172;
    v70 = v43 + 1;
    v71 = (uint64_t *)&v172[24 * v31];
    if (v31 <= 1)
      v72 = 1;
    else
      v72 = v31;
    do
    {
      v73 = operator new(0x20uLL);
      v73[4] = v31;
      *((_QWORD *)v73 + 3) = v70;
      *((_QWORD *)v73 + 1) = v69;
      v74 = *(_QWORD *)v69;
      *(_QWORD *)v73 = *(_QWORD *)v69;
      *(_QWORD *)(v74 + 8) = v73;
      *(_QWORD *)v69 = v73;
      ++*((_QWORD *)v69 + 2);
      v75 = operator new(0x20uLL);
      v75[4] = v68;
      *((_QWORD *)v75 + 3) = v70;
      *((_QWORD *)v75 + 1) = v71;
      v76 = *v71;
      *(_QWORD *)v75 = *v71;
      *(_QWORD *)(v76 + 8) = v75;
      *v71 = (uint64_t)v75;
      ++v71[2];
      ++v68;
      v69 += 24;
    }
    while (v72 != v68);
  }
  __x = -1;
  std::vector<int>::vector(&v170, (v179 - (_BYTE *)v178) >> 3, &__x);
  memset(&v169, 0, sizeof(v169));
  std::vector<int>::reserve(&v169, (v179 - (_BYTE *)v178) >> 3);
  if ((int)v12 < 1)
  {
    v79 = 0;
    v78 = 0;
  }
  else
  {
    v77 = 0;
    v78 = 0;
    v79 = 0;
    if (v155 <= 1)
      v80 = 1;
    else
      v80 = v155;
    do
    {
      v81 = v178[v77];
      if (v81)
      {
        v82 = v177[0];
        if (v177[0])
        {
          v83 = v177;
          do
          {
            v84 = v82;
            v85 = v83;
            v86 = *((int *)v82 + 7);
            v87 = v82 + 1;
            if (v77 <= v86)
            {
              v87 = v84;
              v83 = (_QWORD **)v84;
            }
            v82 = (_QWORD *)*v87;
          }
          while (v82);
          if (v83 != v177)
          {
            if (v77 > v86)
              v84 = v85;
            if (v77 >= *((int *)v84 + 7))
              goto LABEL_98;
          }
        }
        v88 = v175[0];
        if (!v175[0])
          goto LABEL_95;
        v89 = v175;
        do
        {
          v90 = v88;
          v91 = v89;
          v92 = *((int *)v88 + 7);
          v93 = v88 + 1;
          if (v77 <= v92)
          {
            v93 = v90;
            v89 = (_QWORD **)v90;
          }
          v88 = (_QWORD *)*v93;
        }
        while (v88);
        if (v89 == v175)
          goto LABEL_95;
        if (v77 > v92)
          v90 = v91;
        if (v77 >= *((int *)v90 + 7))
        {
LABEL_98:
          v170.__begin_[v77] = v78;
          end = v169.__end_;
          if (v169.__end_ >= v169.__end_cap_.__value_)
          {
            begin = v169.__begin_;
            v98 = v169.__end_ - v169.__begin_;
            v99 = v98 + 1;
            if ((unint64_t)(v98 + 1) >> 62)
              std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
            v100 = (char *)v169.__end_cap_.__value_ - (char *)v169.__begin_;
            if (((char *)v169.__end_cap_.__value_ - (char *)v169.__begin_) >> 1 > v99)
              v99 = v100 >> 1;
            if ((unint64_t)v100 >= 0x7FFFFFFFFFFFFFFCLL)
              v101 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v101 = v99;
            if (v101)
            {
              v102 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v101);
              begin = v169.__begin_;
              end = v169.__end_;
            }
            else
            {
              v102 = 0;
            }
            v103 = (int *)&v102[4 * v98];
            *v103 = v77;
            v96 = v103 + 1;
            while (end != begin)
            {
              v104 = *--end;
              *--v103 = v104;
            }
            v169.__begin_ = v103;
            v169.__end_ = v96;
            v169.__end_cap_.__value_ = (int *)&v102[4 * v101];
            if (begin)
              operator delete(begin);
          }
          else
          {
            *v169.__end_ = v77;
            v96 = end + 1;
          }
          v169.__end_ = v96;
          ++v78;
        }
        else
        {
LABEL_95:
          v94 = v81 * v43;
          if (v77 < v8)
            v94 = 0;
          v79 -= v94;
          v178[v157] += v81;
        }
      }
      ++v77;
    }
    while (v77 != v80);
  }
  v170.__begin_[v157] = v78;
  v106 = v169.__end_;
  value = v169.__end_cap_.__value_;
  if (v169.__end_ >= v169.__end_cap_.__value_)
  {
    v108 = v169.__begin_;
    v109 = v169.__end_ - v169.__begin_;
    v110 = v109 + 1;
    if ((unint64_t)(v109 + 1) >> 62)
      goto LABEL_195;
    v111 = (char *)v169.__end_cap_.__value_ - (char *)v169.__begin_;
    if (((char *)v169.__end_cap_.__value_ - (char *)v169.__begin_) >> 1 > v110)
      v110 = v111 >> 1;
    if ((unint64_t)v111 >= 0x7FFFFFFFFFFFFFFCLL)
      v112 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v112 = v110;
    if (v112)
    {
      v113 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v112);
      v108 = v169.__begin_;
      v106 = v169.__end_;
    }
    else
    {
      v113 = 0;
    }
    v114 = (int *)&v113[4 * v109];
    value = (int *)&v113[4 * v112];
    *v114 = v155;
    v107 = v114 + 1;
    while (v106 != v108)
    {
      v115 = *--v106;
      *--v114 = v115;
    }
    v169.__begin_ = v114;
    v169.__end_ = v107;
    v169.__end_cap_.__value_ = value;
    if (v108)
    {
      operator delete(v108);
      value = v169.__end_cap_.__value_;
    }
  }
  else
  {
    *v169.__end_ = v155;
    v107 = v106 + 1;
  }
  v169.__end_ = v107;
  v170.__begin_[v31] = v78 + 1;
  if (v107 < value)
  {
    *v107 = v31;
    v116 = v107 + 1;
    goto LABEL_151;
  }
  v117 = v169.__begin_;
  v118 = v107 - v169.__begin_;
  v119 = v118 + 1;
  if ((unint64_t)(v118 + 1) >> 62)
LABEL_195:
    std::vector<cva::Matrix<float,3u,1u,false>>::__throw_length_error[abi:ne180100]();
  v120 = (char *)value - (char *)v169.__begin_;
  if (v120 >> 1 > v119)
    v119 = v120 >> 1;
  if ((unint64_t)v120 >= 0x7FFFFFFFFFFFFFFCLL)
    v121 = 0x3FFFFFFFFFFFFFFFLL;
  else
    v121 = v119;
  if (v121)
  {
    v122 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<float>>((uint64_t)&v169.__end_cap_, v121);
    v117 = v169.__begin_;
    v107 = v169.__end_;
  }
  else
  {
    v122 = 0;
  }
  v123 = (int *)&v122[4 * v118];
  v124 = (int *)&v122[4 * v121];
  *v123 = v31;
  v116 = v123 + 1;
  while (v107 != v117)
  {
    v125 = *--v107;
    *--v123 = v125;
  }
  v169.__begin_ = v123;
  v169.__end_ = v116;
  v169.__end_cap_.__value_ = v124;
  if (v117)
    operator delete(v117);
LABEL_151:
  v169.__end_ = v116;
  std::vector<long long>::vector(&v167, v78 + 2);
  v126 = v178;
  v127 = v167;
  if (v179 != (_BYTE *)v178)
  {
    v128 = 0;
    v129 = (v179 - (_BYTE *)v178) >> 3;
    v130 = v170.__begin_;
    if (v129 <= 1)
      v129 = 1;
    do
    {
      v131 = *v130++;
      if (v131 != -1)
        v127[v128++] = *v126;
      ++v126;
      --v129;
    }
    while (v129);
    v127 = v167;
  }
  v156 = v79;
  std::vector<std::list<edge<long long>>>::vector(v166, (v168 - (_BYTE *)v127) >> 3);
  v158 = v172;
  if (v173 != v172)
  {
    v132 = 0;
    v133 = (v173 - v172) / 24;
    v134 = v170.__begin_;
    if (v133 <= 1)
      v133 = 1;
    v160 = v133;
    do
    {
      if (v134[v132] != -1)
      {
        v135 = &v158[24 * v132];
        v136 = *((_QWORD *)v135 + 1);
        if ((char *)v136 != v135)
        {
          v137 = v166[0];
          do
          {
            v138 = v134[*(int *)(v136 + 16)];
            if (v138 != -1)
            {
              v139 = v134[v132];
              v140 = *(_QWORD *)(v136 + 24);
              v141 = operator new(0x20uLL);
              v142 = (uint64_t *)(v137 + 24 * v139);
              v141[4] = v138;
              *((_QWORD *)v141 + 3) = v140;
              *((_QWORD *)v141 + 1) = v142;
              v143 = *v142;
              *(_QWORD *)v141 = *v142;
              *(_QWORD *)(v143 + 8) = v141;
              *v142 = (uint64_t)v141;
              ++v142[2];
            }
            v136 = *(_QWORD *)(v136 + 8);
          }
          while ((char *)v136 != v135);
        }
      }
      ++v132;
    }
    while (v132 != v160);
  }
  v144 = (uint64_t *)v167;
  v145 = (v168 - (_BYTE *)v167) >> 3;
  if (v168 != v167)
  {
    v146 = 0;
    v147 = v145 <= 1 ? 1 : (v168 - (_BYTE *)v167) >> 3;
    do
    {
      v148 = *v144++;
      v146 += v148;
      --v147;
    }
    while (v147);
    if (v146)
      __assert_rtn("operator()", "emd_hat_impl.hpp", 277, "DEBUG_sum_bb==0");
  }
  __p = 0;
  v164 = 0;
  v165 = 0;
  std::vector<std::list<edge0<long long>>>::vector(v161, v145);
  v149 = min_cost_flow<long long>::operator()((unsigned int *)&v162, (uint64_t *)&v167, v166, v161);
  v187 = (void **)v161;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&v187);
  if (__p)
  {
    v164 = __p;
    operator delete(__p);
  }
  v162 = (char **)v166;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  if (v167)
  {
    v168 = v167;
    operator delete(v167);
  }
  if (v169.__begin_)
  {
    v169.__end_ = v169.__begin_;
    operator delete(v169.__begin_);
  }
  if (v170.__begin_)
  {
    v170.__end_ = v170.__begin_;
    operator delete(v170.__begin_);
  }
  v162 = &v172;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v174, v175[0]);
  std::__tree<std::array<unsigned char,16ul>>::destroy((uint64_t)&v176, v177[0]);
  if (v178)
  {
    v179 = v178;
    operator delete(v178);
  }
  v162 = (char **)v180;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v162);
  if (v181)
  {
    v182 = v181;
    operator delete(v181);
  }
  if (v184)
  {
    v185 = v184;
    operator delete(v184);
  }
  v150 = a7;
  if (a7 == -1)
    v150 = v43;
  return v156 + v150 * v153 + v149;
}

void sub_1B3BCAD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char *a21,void *__p,uint64_t a23,uint64_t a24,char a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34,uint64_t a35,uint64_t a36,uint64_t a37,char a38)
{
  uint64_t v38;
  uint64_t v39;
  void *v41;
  void *v42;
  void *v43;

  *(_QWORD *)(v39 - 96) = v38;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v39 - 96));
  if (__p)
  {
    a23 = (uint64_t)__p;
    operator delete(__p);
  }
  a21 = &a25;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  if (a28)
  {
    a29 = (uint64_t)a28;
    operator delete(a28);
  }
  if (a31)
  {
    a32 = (uint64_t)a31;
    operator delete(a31);
  }
  if (a34)
  {
    a35 = (uint64_t)a34;
    operator delete(a34);
  }
  a21 = &a38;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  std::__tree<std::array<unsigned char,16ul>>::destroy(v39 - 240, *(_QWORD **)(v39 - 232));
  std::__tree<std::array<unsigned char,16ul>>::destroy(v39 - 216, *(_QWORD **)(v39 - 208));
  v41 = *(void **)(v39 - 192);
  if (v41)
  {
    *(_QWORD *)(v39 - 184) = v41;
    operator delete(v41);
  }
  a21 = (char *)(v39 - 168);
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  v42 = *(void **)(v39 - 144);
  if (v42)
  {
    *(_QWORD *)(v39 - 136) = v42;
    operator delete(v42);
  }
  v43 = *(void **)(v39 - 120);
  if (v43)
  {
    *(_QWORD *)(v39 - 112) = v43;
    operator delete(v43);
  }
  _Unwind_Resume(a1);
}

uint64_t min_cost_flow<long long>::operator()(unsigned int *a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t v4;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t *v12;
  int v13;
  uint64_t v14;
  _DWORD *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  _DWORD *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t *v27;
  int v28;
  uint64_t v29;
  _DWORD *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void **v35;
  uint64_t v36;
  uint64_t i;
  int v38;
  uint64_t v39;
  _DWORD *v40;
  void **v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  int v47;
  std::vector<int>::pointer begin;
  void **v49;
  int v50;
  int v51;
  void **v52;
  uint64_t v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  int v59;
  void **v60;
  void **v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  _QWORD *j;
  int *v70;
  int v71;
  std::vector<int> v72;
  void *__p[3];
  void **v74[3];
  uint64_t v75[3];

  v4 = a2[1] - *a2;
  if (v4 >> 3 != 0xAAAAAAAAAAAAAAABLL * ((a3[1] - *a3) >> 3))
    min_cost_flow<long long>::operator()();
  if (0xAAAAAAAAAAAAAAABLL * ((a4[1] - *a4) >> 3) != v4 >> 3)
    min_cost_flow<long long>::operator()();
  *a1 = (unint64_t)v4 >> 3;
  std::vector<int>::resize((std::vector<int> *)(a1 + 2), (int)(v4 >> 3));
  v70 = (int *)a1;
  v6 = *a1;
  if ((int)v6 >= 1)
  {
    v7 = 0;
    v8 = *a3;
    v9 = *a4;
    do
    {
      v10 = v8 + 24 * v7;
      v11 = *(_QWORD *)(v10 + 8);
      if (v11 != v10)
      {
        v12 = (uint64_t *)(v9 + 24 * v7);
        do
        {
          v13 = *(_DWORD *)(v11 + 16);
          v14 = *(_QWORD *)(v11 + 24);
          v15 = operator new(0x28uLL);
          v15[4] = v13;
          *((_QWORD *)v15 + 3) = v14;
          *((_QWORD *)v15 + 4) = 0;
          *((_QWORD *)v15 + 1) = v12;
          v16 = *v12;
          *(_QWORD *)v15 = *v12;
          *(_QWORD *)(v16 + 8) = v15;
          *v12 = (uint64_t)v15;
          ++v12[2];
          v17 = (uint64_t *)(v9 + 24 * *(int *)(v11 + 16));
          v18 = -*(_QWORD *)(v11 + 24);
          v19 = operator new(0x28uLL);
          v19[4] = v7;
          *((_QWORD *)v19 + 3) = v18;
          *((_QWORD *)v19 + 4) = 0;
          *((_QWORD *)v19 + 1) = v17;
          v20 = *v17;
          *(_QWORD *)v19 = *v17;
          *(_QWORD *)(v20 + 8) = v19;
          *v17 = (uint64_t)v19;
          ++v17[2];
          v11 = *(_QWORD *)(v11 + 8);
        }
        while (v11 != v10);
      }
      ++v7;
    }
    while (v7 != v6);
  }
  std::vector<std::list<edge1<long long>>>::vector(v75, (int)v6);
  v21 = *v70;
  if ((int)v21 >= 1)
  {
    v22 = 0;
    v23 = *a3;
    v24 = v75[0];
    do
    {
      v25 = v23 + 24 * v22;
      v26 = *(_QWORD *)(v25 + 8);
      if (v26 != v25)
      {
        v27 = (uint64_t *)(v24 + 24 * v22);
        do
        {
          v28 = *(_DWORD *)(v26 + 16);
          v29 = *(_QWORD *)(v26 + 24);
          v30 = operator new(0x20uLL);
          v30[4] = v28;
          *((_QWORD *)v30 + 3) = v29;
          *((_QWORD *)v30 + 1) = v27;
          v31 = *v27;
          *(_QWORD *)v30 = *v27;
          *(_QWORD *)(v31 + 8) = v30;
          *v27 = (uint64_t)v30;
          ++v27[2];
          v26 = *(_QWORD *)(v26 + 8);
        }
        while (v26 != v25);
      }
      ++v22;
    }
    while (v22 != v21);
  }
  std::vector<std::list<edge2<long long>>>::vector(v74, (int)v21);
  v32 = *v70;
  if ((int)v32 >= 1)
  {
    v33 = 0;
    v34 = *a3;
    v35 = v74[0];
    do
    {
      v36 = v34 + 24 * v33;
      for (i = *(_QWORD *)(v36 + 8); i != v36; i = *(_QWORD *)(i + 8))
      {
        v38 = *(_DWORD *)(i + 16);
        v39 = *(_QWORD *)(i + 24);
        v40 = operator new(0x28uLL);
        v41 = &v35[3 * v38];
        v40[4] = v33;
        *((_QWORD *)v40 + 3) = -v39;
        *((_QWORD *)v40 + 4) = 0;
        *((_QWORD *)v40 + 1) = v41;
        v42 = *v41;
        *(_QWORD *)v40 = *v41;
        v42[1] = v40;
        *v41 = v40;
        v41[2] = (char *)v41[2] + 1;
      }
      ++v33;
    }
    while (v33 != v32);
  }
  std::vector<long long>::vector(__p, (int)v32);
  std::vector<int>::vector(&v72, *v70);
  v43 = *v70;
  if ((int)v43 < 1)
  {
LABEL_49:
    v62 = 0;
  }
  else
  {
    while (1)
    {
      v44 = 0;
      v45 = 0;
      v46 = 0;
      do
      {
        if (*(_QWORD *)(*a2 + 8 * v44) > 0 && v46 < *(_QWORD *)(*a2 + 8 * v44))
        {
          v46 = *(_QWORD *)(*a2 + 8 * v44);
          v45 = v44;
        }
        ++v44;
      }
      while (v43 != v44);
      if (!v46)
        break;
      v71 = 0;
      min_cost_flow<long long>::compute_shortest_path(v70, (uint64_t *)__p, &v72, v45, v75, (uint64_t *)v74, a2, &v71);
      v47 = v71;
      begin = v72.__begin_;
      v49 = v74[0];
      v50 = v71;
      do
      {
        v51 = v72.__begin_[v50];
        if (v51 == v50)
          __assert_rtn("operator()", "min_cost_flow.hpp", 167, "from!=to");
        v52 = &v74[0][3 * v51];
        while (1)
        {
          v52 = (void **)v52[1];
          if (v52 == &v74[0][3 * v51])
            break;
          if (*((_DWORD *)v52 + 4) == v50)
          {
            if ((uint64_t)v52[4] < v46)
              v46 = (uint64_t)v52[4];
            break;
          }
        }
        v50 = v72.__begin_[v50];
      }
      while (v51 != v45);
      v53 = *a4;
      v54 = *a2;
      do
      {
        v55 = begin[v47];
        if (v55 == v47)
          __assert_rtn("operator()", "min_cost_flow.hpp", 187, "from!=to");
        v56 = v47;
        v47 = begin[v47];
        v57 = v53 + 24 * v55 + 8;
        do
        {
          v58 = *(_QWORD *)v57;
          v59 = *(_DWORD *)(*(_QWORD *)v57 + 16);
          v57 = *(_QWORD *)v57 + 8;
        }
        while (v59 != (_DWORD)v56);
        *(_QWORD *)(v58 + 32) += v46;
        v60 = &v49[3 * (int)v56];
        while (1)
        {
          v60 = (void **)v60[1];
          if (v60 == &v49[3 * (int)v56])
            break;
          if (*((_DWORD *)v60 + 4) == v55)
          {
            v60[4] = (char *)v60[4] + v46;
            break;
          }
        }
        v61 = &v49[3 * v55];
        while (1)
        {
          v61 = (void **)v61[1];
          if (v61 == &v49[3 * v55])
            break;
          if (*((_DWORD *)v61 + 4) == (_DWORD)v56)
          {
            v61[4] = (char *)v61[4] - v46;
            break;
          }
        }
        *(_QWORD *)(v54 + 8 * v56) += v46;
        *(_QWORD *)(v54 + 8 * v55) -= v46;
      }
      while (v55 != v45);
      v43 = *v70;
      if ((int)v43 <= 0)
        goto LABEL_49;
    }
    v63 = 0;
    v62 = 0;
    do
    {
      v64 = *a4 + 24 * v63;
      for (j = *(_QWORD **)(v64 + 8); j != (_QWORD *)v64; j = (_QWORD *)j[1])
        v62 += j[4] * j[3];
      ++v63;
    }
    while (v63 != v43);
  }
  if (v72.__begin_)
  {
    v72.__end_ = v72.__begin_;
    operator delete(v72.__begin_);
  }
  if (__p[0])
  {
    __p[1] = __p[0];
    operator delete(__p[0]);
  }
  __p[0] = v74;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)__p);
  v74[0] = (void **)v75;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](v74);
  return v62;
}

void sub_1B3BCB3DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t *__p, uint64_t *a19, uint64_t a20,uint64_t a21)
{
  uint64_t v21;

  if (__p)
  {
    a19 = __p;
    operator delete(__p);
  }
  __p = &a21;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  a21 = v21 - 104;
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::vector<long long>>::__init_with_size[abi:ne180100]<std::vector<long long>*,std::vector<long long>*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<long long>>,std::vector<long long>*,std::vector<long long>*,std::vector<long long>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_1B3BCB4B4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<float>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<long long>>,std::vector<long long>*,std::vector<long long>*,std::vector<long long>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<long long>::__init_with_size[abi:ne180100]<long long *,long long *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 3);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::vector<long long>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_1B3BCB570(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::vector<long long>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<long long>>,std::vector<long long>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<float>>,std::vector<float>*>::operator()[abi:ne180100](a1);
  return a1;
}

_QWORD *std::vector<std::list<edge<long long>>>::vector(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (_QWORD *)a1[1];
    v5 = &v4[3 * a2];
    do
    {
      *v4 = v4;
      v4[1] = v4;
      v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3BCB624(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  _QWORD *v2;
  _QWORD *v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        std::__list_imp<edge<long long>>::clear(v4);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::__list_imp<edge<long long>>::clear(_QWORD *result)
{
  _QWORD *v1;
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;

  if (result[2])
  {
    v1 = result;
    result = (_QWORD *)result[1];
    v2 = *v1;
    v3 = *result;
    *(_QWORD *)(v3 + 8) = *(_QWORD *)(*v1 + 8);
    **(_QWORD **)(v2 + 8) = v3;
    v1[2] = 0;
    if (result != v1)
    {
      do
      {
        v4 = (_QWORD *)result[1];
        operator delete(result);
        result = v4;
      }
      while (v4 != v1);
    }
  }
  return result;
}

uint64_t **std::__tree<int>::__emplace_unique_key_args<int,int const&>(uint64_t **a1, int *a2, _DWORD *a3)
{
  uint64_t *v5;
  uint64_t **v6;
  int v7;
  uint64_t **v8;
  int v9;
  uint64_t *v10;

  v6 = a1 + 1;
  v5 = a1[1];
  if (v5)
  {
    v7 = *a2;
    while (1)
    {
      while (1)
      {
        v8 = (uint64_t **)v5;
        v9 = *((_DWORD *)v5 + 7);
        if (v7 >= v9)
          break;
        v5 = *v8;
        v6 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (v9 >= v7)
        break;
      v5 = v8[1];
      if (!v5)
      {
        v6 = v8 + 1;
        goto LABEL_10;
      }
    }
  }
  else
  {
    v8 = a1 + 1;
LABEL_10:
    v10 = (uint64_t *)operator new(0x20uLL);
    *((_DWORD *)v10 + 7) = *a3;
    _ZNSt3__16__treeINS_12__value_typeIyDv4_fEENS_19__map_value_compareIyS3_NS_4lessIyEELb1EEENS_9allocatorIS3_EEE16__insert_node_atEPNS_15__tree_end_nodeIPNS_16__tree_node_baseIPvEEEERSF_SF_(a1, (uint64_t)v8, v6, v10);
    return (uint64_t **)v10;
  }
  return v8;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  std::vector<int>::pointer end;
  int *v7;
  std::vector<int>::size_type v8;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    v7 = &end[__n];
    v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_1B3BCB824(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::list<edge0<long long>>>::vector(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (_QWORD *)a1[1];
    v5 = &v4[3 * a2];
    do
    {
      *v4 = v4;
      v4[1] = v4;
      v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3BCB8AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

void min_cost_flow<long long>::compute_shortest_path(int *a1, uint64_t *a2, _QWORD *a3, int a4, uint64_t *a5, uint64_t *a6, _QWORD *a7, int *a8)
{
  _QWORD *v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  uint64_t v19;
  int64_t v20;
  int64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int *begin;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  std::vector<int>::value_type __x;
  std::vector<int> v61;
  void *__p;
  _BYTE *v63;

  std::vector<edge3<long long>>::vector(&__p, *a1);
  v13 = __p;
  *(_DWORD *)__p = a4;
  v15 = a1 + 2;
  v14 = *((_QWORD *)a1 + 1);
  *(_DWORD *)(v14 + 4 * a4) = 0;
  v13[1] = 0;
  if (a4 < 1)
  {
    v19 = 1;
  }
  else
  {
    v16 = 0;
    v17 = v13 + 3;
    do
    {
      *((_DWORD *)v17 - 2) = v16;
      v18 = v16 + 1;
      *(_DWORD *)(v14 + 4 * v16) = v16 + 1;
      *v17 = 0x7FFFFFFFFFFFFFFFLL;
      v17 += 2;
      v16 = v18;
    }
    while (a4 != v18);
    v19 = v18 + 1;
  }
  LODWORD(v20) = a4 + 1;
  v21 = *a1;
  if (a4 + 1 < (int)v21)
  {
    v20 = (int)v20;
    v22 = &v13[2 * v19 + 1];
    do
    {
      *((_DWORD *)v22 - 2) = v20;
      *(_DWORD *)(v14 + 4 * v20) = v19;
      *v22 = 0x7FFFFFFFFFFFFFFFLL;
      v22 += 2;
      ++v20;
      v21 = *a1;
      LODWORD(v19) = v19 + 1;
    }
    while (v20 < v21);
  }
  __x = 0;
  std::vector<int>::vector(&v61, v21, &__x);
  v23 = __p;
  while (1)
  {
    v24 = *(_DWORD *)v23;
    *(_QWORD *)(*a2 + 8 * v24) = v23[1];
    v61.__begin_[v24] = 1;
    if ((*(_QWORD *)(*a7 + 8 * v24) & 0x8000000000000000) != 0)
      break;
    min_cost_flow<long long>::heap_remove_first((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1);
    v25 = *a5;
    v26 = *a5 + 24 * v24;
    v27 = *(_QWORD *)(v26 + 8);
    while (v27 != v26)
    {
      v28 = *(_QWORD *)(v27 + 24);
      if (v28 < 0)
        __assert_rtn("compute_shortest_path", "min_cost_flow.hpp", 318, "it->_reduced_cost>=0");
      v29 = *(int *)(v27 + 16);
      v30 = *(int *)(*v15 + 4 * v29);
      if (v30 < (v63 - (_BYTE *)__p) >> 4)
      {
        v31 = *(_QWORD *)(*a2 + 8 * v24) + v28;
        if (v31 < *((_QWORD *)__p + 2 * v30 + 1))
        {
          min_cost_flow<long long>::heap_decrease_key((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1, *(_DWORD *)(v27 + 16), v31);
          *(_DWORD *)(*a3 + 4 * v29) = v24;
          v25 = *a5;
        }
      }
      v27 = *(_QWORD *)(v27 + 8);
      v26 = v25 + 24 * v24;
    }
    v32 = *a6;
    v33 = *a6 + 24 * v24;
    v34 = *(_QWORD *)(v33 + 8);
    while (v34 != v33)
    {
      if (*(uint64_t *)(v34 + 32) >= 1)
      {
        v35 = *(_QWORD *)(v34 + 24);
        if (v35 < 0)
          __assert_rtn("compute_shortest_path", "min_cost_flow.hpp", 329, "it->_reduced_cost>=0");
        v36 = *(int *)(v34 + 16);
        v37 = *(int *)(*v15 + 4 * v36);
        if (v37 < (v63 - (_BYTE *)__p) >> 4)
        {
          v38 = *(_QWORD *)(*a2 + 8 * v24) + v35;
          if (v38 < *((_QWORD *)__p + 2 * v37 + 1))
          {
            min_cost_flow<long long>::heap_decrease_key((uint64_t)a1, (uint64_t *)&__p, (uint64_t *)a1 + 1, *(_DWORD *)(v34 + 16), v38);
            *(_DWORD *)(*a3 + 4 * v36) = v24;
            v32 = *a6;
          }
        }
      }
      v34 = *(_QWORD *)(v34 + 8);
      v33 = v32 + 24 * v24;
    }
    v23 = __p;
    if (__p == v63)
      goto LABEL_29;
  }
  *a8 = v24;
LABEL_29:
  v39 = *a1;
  begin = v61.__begin_;
  if ((int)v39 >= 1)
  {
    v41 = 0;
    v42 = *a5;
    do
    {
      v43 = v42 + 24 * v41;
      v44 = *(_QWORD *)(v43 + 8);
      if (v44 != v43)
      {
        v45 = begin[v41];
        v46 = *a2;
        v47 = *a8;
        do
        {
          if (v45)
            *(_QWORD *)(v44 + 24) += *(_QWORD *)(v46 + 8 * v41) - *(_QWORD *)(v46 + 8 * v47);
          v48 = *(int *)(v44 + 16);
          if (begin[v48])
            *(_QWORD *)(v44 + 24) += *(_QWORD *)(v46 + 8 * v47) - *(_QWORD *)(v46 + 8 * v48);
          v44 = *(_QWORD *)(v44 + 8);
        }
        while (v44 != v43);
      }
      ++v41;
    }
    while (v41 != v39);
    v49 = 0;
    v50 = *a6;
    do
    {
      v51 = v50 + 24 * v49;
      v52 = *(_QWORD *)(v51 + 8);
      if (v52 != v51)
      {
        v53 = begin[v49];
        v54 = *a2;
        v55 = *a8;
        do
        {
          if (v53)
            *(_QWORD *)(v52 + 24) += *(_QWORD *)(v54 + 8 * v49) - *(_QWORD *)(v54 + 8 * v55);
          v56 = *(int *)(v52 + 16);
          if (begin[v56])
            *(_QWORD *)(v52 + 24) += *(_QWORD *)(v54 + 8 * v55) - *(_QWORD *)(v54 + 8 * v56);
          v52 = *(_QWORD *)(v52 + 8);
        }
        while (v52 != v51);
      }
      ++v49;
    }
    while (v49 != v39);
  }
  if (begin)
  {
    v61.__end_ = begin;
    operator delete(begin);
    v23 = __p;
  }
  if (v23)
  {
    v63 = v23;
    operator delete(v23);
  }
}

void sub_1B3BCBCC4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, void *__p, uint64_t a17)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::vector<std::list<edge1<long long>>>::vector(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (_QWORD *)a1[1];
    v5 = &v4[3 * a2];
    do
    {
      *v4 = v4;
      v4[1] = v4;
      v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3BCBD74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::list<edge2<long long>>>::vector(_QWORD *a1, unint64_t a2)
{
  _QWORD *v4;
  _QWORD *v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<float>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (_QWORD *)a1[1];
    v5 = &v4[3 * a2];
    do
    {
      *v4 = v4;
      v4[1] = v4;
      v4[2] = 0;
      v4 += 3;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3BCBDF4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::list<edge<long long>>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::vector<int>::pointer end;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<float>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_1B3BCBE60(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

__n128 min_cost_flow<long long>::heap_remove_first(uint64_t a1, uint64_t *a2, uint64_t *a3)
{
  int v3;
  __int128 v4;
  _OWORD *v5;
  uint64_t v6;
  __n128 result;

  v3 = ((unint64_t)(a2[1] - *a2) >> 4) - 1;
  v4 = *(_OWORD *)*a2;
  *(_OWORD *)*a2 = *(_OWORD *)(*a2 + 16 * v3);
  *(_OWORD *)(*a2 + 16 * v3) = v4;
  v5 = (_OWORD *)*a2;
  v6 = *a3;
  *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * v3)) = v3;
  *(_DWORD *)(v6 + 4 * *(int *)v5) = 0;
  a2[1] -= 16;
  min_cost_flow<long long>::heapify(a1, a2, a3, 0);
  return result;
}

__n128 min_cost_flow<long long>::heap_decrease_key(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;
  __n128 result;
  uint64_t v10;

  v5 = *(int *)(*a3 + 4 * a4);
  v6 = *a2;
  *(_QWORD *)(*a2 + 16 * v5 + 8) = a5;
  if ((int)v5 >= 1)
  {
    do
    {
      v7 = v5 - 1;
      v8 = (v5 - 1) >> 1;
      if (*(_QWORD *)(v6 + 16 * v8 + 8) <= *(_QWORD *)(v6 + 16 * v5 + 8))
        break;
      result = *(__n128 *)(v6 + 16 * v5);
      *(_OWORD *)(v6 + 16 * v5) = *(_OWORD *)(v6 + 16 * v8);
      *(__n128 *)(*a2 + 16 * v8) = result;
      v6 = *a2;
      v10 = *a3;
      *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * v8)) = v8;
      *(_DWORD *)(v10 + 4 * *(int *)(v6 + 16 * v5)) = v5;
      LODWORD(v5) = v7 >> 1;
    }
    while (v7 > 1);
  }
  return result;
}

_QWORD *std::vector<edge3<long long>>::vector(_QWORD *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    _ZNSt3__16vectorIDv3_fNS_9allocatorIS1_EEE11__vallocateB8ne180100Em(a1, a2);
    v4 = a1[1];
    v5 = v4 + 16 * a2;
    do
    {
      *(_DWORD *)v4 = 0;
      *(_QWORD *)(v4 + 8) = 0;
      v4 += 16;
    }
    while (v4 != v5);
    a1[1] = v5;
  }
  return a1;
}

void sub_1B3BCBFBC(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void min_cost_flow<long long>::heapify(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  __int128 v8;
  uint64_t v9;

  v4 = *a2;
  while (1)
  {
    v5 = (2 * (int)a4) | 1;
    v6 = (a2[1] - v4) >> 4;
    if (v6 <= v5 || *(_QWORD *)(v4 + 16 * v5 + 8) >= *(_QWORD *)(v4 + 16 * (int)a4 + 8))
      v5 = a4;
    v7 = 2 * a4 + 2;
    if (v6 > (int)v7)
    {
      if (*(_QWORD *)(v4 + 16 * (int)v7 + 8) >= *(_QWORD *)(v4 + 16 * (int)v5 + 8))
        v5 = v5;
      else
        v5 = v7;
    }
    if ((_DWORD)v5 == (_DWORD)a4)
      break;
    v8 = *(_OWORD *)(v4 + 16 * (int)a4);
    *(_OWORD *)(v4 + 16 * (int)a4) = *(_OWORD *)(v4 + 16 * (int)v5);
    *(_OWORD *)(*a2 + 16 * (int)v5) = v8;
    v4 = *a2;
    v9 = *a3;
    *(_DWORD *)(*a3 + 4 * *(int *)(*a2 + 16 * (int)v5)) = v5;
    *(_DWORD *)(v9 + 4 * *(int *)(v4 + 16 * (int)a4)) = a4;
    a4 = v5;
  }
}

BOOL ARCheckConfidenceJasper(float a1)
{
  return a1 > 0.8;
}

void __getARDaemonClass_block_invoke_cold_1()
{
  uint64_t v0;

  v0 = abort_report_np();
  __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1(v0);
}

void __getARDaemonReplayBlockDelegateClass_block_invoke_cold_1()
{
  uint64_t v0;

  v0 = abort_report_np();
  -[ARImageBasedTechnique getDeviceOrientationFromImageData:].cold.1(v0);
}

void cnmatrix::CNMatrixBase<double>::operator=()
{
  __assert_rtn("operator=", "cnmatrixbase.h", 619, "this->max_num_rows_ >= A.num_rows_");
}

{
  __assert_rtn("operator=", "cnmatrixbase.h", 620, "this->max_num_cols_ >= A.num_cols_");
}

void cnmatrix::CNMatrix<3u,3u,double>::TransposeDataFootprint()
{
  __assert_rtn("TransposeDataFootprint", "cnmatrix.h", 122, "scratch != nullptr");
}

{
  __assert_rtn("TransposeDataFootprint", "cnmatrix.h", 128, "lead_dim > 0");
}

void cnmatrix::CNMatrixBase<double>::operator()()
{
  __assert_rtn("operator()", "cnmatrixbase.h", 782, "data_ != __null");
}

{
  __assert_rtn("operator()", "cnmatrixbase.h", 783, "idx >= 0");
}

{
  __assert_rtn("operator()", "cnmatrixbase.h", 784, "idx < num_elements_");
}

void ARC3DShapeTriangulationCheckConsistency_cold_1()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 194, "neighborB != t");
}

void ARC3DShapeTriangulationCheckConsistency_cold_2()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 195, "neighborB != UNDEFINED_NEIGHBOR");
}

void ARC3DShapeTriangulationCheckConsistency_cold_3()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 215, "t->constrain[j] == false");
}

void ARC3DShapeTriangulationCheckConsistency_cold_4()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 214, "neighborCount == 0");
}

void ARC3DShapeTriangulationCheckConsistency_cold_5()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 219, "neighborA->constrain[link] == t->constrain[j]");
}

void ARC3DShapeTriangulationCheckConsistency_cold_6()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 218, "neighborA->neighbors[link] == t");
}

void ARC3DShapeTriangulationCheckConsistency_cold_7()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 217, "neighborCount == 1");
}

void ARC3DShapeTriangulationCheckConsistency_cold_8()
{
  __assert_rtn("ARC3DShapeTriangulationCheckConsistency", "ARC3DShapeTriangulation.m", 211, "neighborA == neighborB");
}

void ARC3DLinkIndexFromTriangleToTriangle_cold_1(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0("ARC3DLinkIndexFromTriangleToTriangle", "ARC3DShapeTriangulation.m", a3, "0");
}

void ARC3DVertexNotSharedByTriangles_cold_1()
{
  __assert_rtn("ARC3DVertexNotSharedByTriangles", "ARC3DShapeTriangulation.m", 510, "L");
}

void ARC3DVertexNotSharedByTriangles_cold_2()
{
  __assert_rtn("ARC3DVertexNotSharedByTriangles", "ARC3DShapeTriangulation.m", 511, "K");
}

void ARC3DShapeConnectedComponentTriangulatePseudopolygon_cold_1()
{
  __assert_rtn("ARC3DShapeConnectedComponentTriangulatePseudopolygon", "ARC3DShapeTriangulation.m", 556, "list->count > 1");
}

void ARC3DShapeTriangulationAddEdge_cold_1()
{
  __assert_rtn("ARC3DShapeTriangulationAddEdge", "ARC3DShapeTriangulation.m", 898, "recycledTriangles.count == 0");
}

void arkit::ExponentialSmoother<float>::step()
{
  __assert_rtn("step", "ExponentialSmoother.h", 66, "0.f < targetAlpha && targetAlpha <= 1.f");
}

{
  __assert_rtn("step", "ExponentialSmoother.h", 68, "0.f < samplingInterval");
}

{
  __assert_rtn("step", "ExponentialSmoother.h", 69, "0.f < targetSamplingInterval");
}

void ar_rt_ring_buffer_init_cold_1()
{
  uint64_t v0;

  v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_reset_cold_1(v0);
}

void ar_rt_ring_buffer_reset_cold_1()
{
  uint64_t v0;

  v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_empty_cold_1(v0);
}

void ar_rt_ring_buffer_empty_cold_1()
{
  __realtime_assert_rtn();
  ar_rt_ring_buffer_increment_index_cold_1();
}

void ar_rt_ring_buffer_increment_index_cold_1()
{
  uint64_t v0;

  v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_decrement_index_cold_1(v0);
}

void ar_rt_ring_buffer_decrement_index_cold_1()
{
  __realtime_assert_rtn();
  ar_rt_ring_buffer_add_element_cold_1();
}

void ar_rt_ring_buffer_add_element_cold_1()
{
  uint64_t v0;

  v0 = __realtime_assert_rtn();
  ar_rt_ring_buffer_filled_cold_1(v0);
}

void ar_rt_ring_buffer_filled_cold_1()
{
  uint64_t v0;

  v0 = __realtime_assert_rtn();
  ARAnchorsFromCV3DAnchorsArray_cold_1(v0);
}

void ARAnchorsFromCV3DAnchorsArray_cold_1(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4)
{
  void *v4;
  void *v5;
  void *v6;
  id v7;

  v4 = (void *)MEMORY[0x1E0CB3940];
  ARMatrix4x4Description(1, *a1, *a2, *a3, *a4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringWithFormat:", CFSTR("SLAM returned invalid anchor pose %@"), v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "stringWithFormat:", CFSTR("ARCrash: %@"), v6);
  v7 = objc_retainAutorelease((id)objc_claimAutoreleasedReturnValue());
  qword_1EF081328 = (uint64_t)strdup((const char *)objc_msgSend(v7, "UTF8String"));

  abort();
}

void HeadingFromRot()
{
  __assert_rtn("HeadingFromRot", "ARGeoTrackingFilterUtilities.mm", 39, "heading_deg_pos < 360.0");
}

void arkit::gaussianKernel()
{
  __assert_rtn("gaussianKernel", "ARNoiseKernels.cpp", 24, "kernelSize > 0");
}

{
  __assert_rtn("gaussianKernel", "ARNoiseKernels.cpp", 25, "kernelSize % 2 == 1");
}

void arkit::unflatten()
{
  __assert_rtn("unflatten", "ARNoiseKernels.cpp", 48, "c*n == src.size()");
}

{
  __assert_rtn("unflatten", "ARNoiseKernels.cpp", 67, "k*c*n == src.size()");
}

void arkit::sum()
{
  __assert_rtn("sum", "ARNoiseKernels.cpp", 83, "dim == 0 || dim == 1");
}

void arkit::unflattenParams()
{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 185, "wk_flat.size() == vk_flat.size()");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 184, "wk_flat.size()/c % n == 0");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 183, "wk_flat.size()/n % c == 0");
}

{
  __assert_rtn("unflattenParams", "ARNoiseKernels.cpp", 182, "vp_flat.size() % n == 0");
}

void arkit::loadParams()
{
  __assert_rtn("loadParams", "ARNoiseKernels.cpp", 1202, "0");
}

void cva::MatrixRef<float,3u,3u,false>::operator=<cva::MatrixTransposeExpr<cva::MatrixRef<float const,3u,3u,false>>>()
{
  __assert_rtn("assert_in_bounds", "matrixmixin.h", 2269, "((row < mixed().rows()) && (col < mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void ARConsensusAndAverageFilterImpl::GetInliers()
{
  __assert_rtn("GetInliers", "ARGeoTrackingConsensusAndAverageFilter.mm", 180, "idx < aligned_poses.size()");
}

void ARC3DComputeLinesIntersection_cold_1()
{
  __assert_rtn("ARC3DComputeLinesIntersection", "ARC3DShapeUtils.m", 35, "denom != 0");
}

void ARC3DComputeLinesIntersectionForPoints_cold_1()
{
  __assert_rtn("ARC3DComputeLinesIntersectionForPoints", "ARC3DShapeUtils.m", 46, "denom != 0");
}

void ARNeutralBodySkeleton3DModelTransforms_cold_1()
{
  __assert_rtn("ARNeutralBodySkeleton3DModelTransforms", "ARRigDependencyData.mm", 821, "dataVector.size() == OUTPUT_JOINT_COUNT");
}

void ARNeutralBodySkeleton3DLocalTransforms_cold_1()
{
  __assert_rtn("ARNeutralBodySkeleton3DLocalTransforms", "ARRigDependencyData.mm", 1285, "dataVector.size() == OUTPUT_JOINT_COUNT");
}

void cva::MatrixData<float,0ul,0ul,false>::allocate()
{
  __assert_rtn("allocate", "matrixdata.h", 490, "(m_data) || cva::detail::assertMessage(\"Matrix data must be allocated on exit.\")");
}

{
  __assert_rtn("allocate", "matrixdata.h", 479, "(!m_data) || cva::detail::assertMessage(\"No matrix data must be allocated.\")");
}

void GetConfidenceFromUncertainty()
{
  __assert_rtn("GetConfidenceFromUncertainty", "ARSceneReconstructionHandler.mm", 39, "(confidence >= 0.f) && (confidence <= 1.f)");
}

void arkit::FaceLightOptimizer::solveQuadratic()
{
  __assert_rtn("solveQuadratic", "FaceLightOptimizer.cpp", 68, "luminances.rows() == rtf.rows()");
}

void arkit::FaceLightOptimizer::inlierSet()
{
  __assert_rtn("inlierSet", "FaceLightOptimizer.cpp", 214, "thresh >= 0");
}

void arkit::FaceLightOptimizer::solveLinear()
{
  __assert_rtn("solveLinear", "FaceLightOptimizer.cpp", 179, "luminances.rows() == rtf.rows()");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::inverse(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_2("MatrixMultExpr", "matrixmultexpr.h", a3, "((lhs.ref().columns() == rhs.ref().rows())) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
}

void arkit::FaceLightOptimizer::penaltyFunction()
{
  __assert_rtn("penaltyFunction", "FaceLightOptimizer.cpp", 200, "luminances.rows() == rtf.rows()");
}

void std::pair<cva::Matrix<float,9u,1u,false>,float>::pair[abi:ne180100]<cva::Matrix<float,0u,1u,false> &,float const&,0>()
{
  __assert_rtn("MatrixSize", "matrixsize.h", 36, "(ROWS == rows && COLS == cols) || cva::detail::assertMessage(\"Row and column values and templates need to be the same.\")");
}

{
  __assert_rtn("MatrixData", "matrixdata.h", 96, "(size == sz) || cva::detail::assertMessage(\"Matrix data size mismatch.\")");
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false> const>,cva::Matrix<float,0u,0u,false>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0_1("assert_equal_size", "matrixfun.h", a3, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::decomposeDirect<0u,0u>()
{
  __assert_rtn("decomposeDirect", "matrixsvd.h", 433, "(info == 0) || cva::detail::assertMessage(\"gesvd() query workspace size failed!\")");
}

void cva::SVD<cva::Matrix<float,0u,0u,false>,true>::S()
{
  __assert_rtn("VectorAsDiagonalExpr", "vectorasdiagexpr.h", 211, "(std::min(rows, cols) <= vector.elements()) || cva::detail::assertMessage(\"The matrix can't be in both dimensions larger than its diagonal.\")");
}

void cva::assign<false,false,cva::Matrix<float,0u,0u,false>,cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>>,cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_4("assert_in_bounds", "matrixmixin.h", a3, "((row + nRows <= mixed().rows()) && (col + nCols <= mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void cva::detail::assignNoAlias<cva::Matrix<float,0u,0u,false>,cva::MatrixBinaryExpr<cva::MatrixSubExpr<cva::MatrixTransposeExpr<cva::Matrix<float,0u,0u,false>> const,0u,0u>,cva::MatrixRepeatExpr<cva::MatrixTransposeExpr<cva::MatrixDiagonalExpr<cva::DiagonalMatrixInverseExpr<cva::VectorAsDiagonalExpr<cva::Matrix<float,0u,1u,false>,0u,0u>> const> const>,0u,1u>,cva::detail::MulOp>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1("assert_in_bounds", "matrixmixin.h", a3, "((row < mixed().rows()) && (col < mixed().columns())) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

{
  OUTLINED_FUNCTION_3("operator()", "matrixsubexpr.h", a3, "(row < rows() && column < columns()) || cva::detail::assertMessage(\"Out of range index being used on submatrix expression.\")");
}

void arkit::wrap()
{
  __assert_rtn("wrap", "ImageHelpers.cpp", 15, "format == kCVPixelFormatType_420YpCbCr8BiPlanarFullRange");
}

void arkit::ImageViewYUV::at(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_1_0("operator[]", "arrayview.h", a3, "(check_bounds(*this, idx)) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

{
  OUTLINED_FUNCTION_0_2("operator()", "arrayview.h", a3, "((x < size(0)) && (y < size(1))) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void arkit::FacialLightEstimation::populateValidImageSamples()
{
  __assert_rtn("assert_in_bounds", "matrixmixin.h", 2283, "(i < mixed().elements()) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

{
  __assert_rtn("operator[]", "arrayview.h", 277, "(check_bounds(*this, idx)) || cva::detail::assertMessage(\"Index out of bounds!\")");
}

void cva::detail::assignNoAlias<cva::MatrixRef<float,0u,0u,false>,cva::MatrixRef<float,0u,0u,false>>()
{
  __assert_rtn("assert_equal_size", "matrixfun.h", 163, "(lhs.rows() == rhs.rows() && lhs.columns() == rhs.columns()) || cva::detail::assertMessage(\"Matrix sizes are not compatible!\")");
}

void cva::Matrix<float,0u,1u,false>::conservativeResize()
{
  __assert_rtn("conservativeResize", "matrix.h", 1530, "(detail::compatibleSize<COLS>(columns)) || cva::detail::assertMessage(\"For fixed sizes, the given number of columns should match\")");
}

void std::__optional_copy_base<std::string const,false>::__optional_copy_base[abi:ne180100](uint64_t a1)
{
  if (*(char *)(a1 + 23) < 0)
    operator delete(*(void **)a1);
}

void cva::Array<cva::Matrix<unsigned char,4u,1u,false>,2u,16u>::allocate()
{
  __assert_rtn("allocate", "array.h", 257, "(nullptr != ptr) || cva::detail::assertMessage(\"Out of memory!\")");
}

void cva::ArrayIterator<float,2u>::increment()
{
  __assert_rtn("increment", "arrayiterator.h", 103, "(m_ptr != nullptr) || cva::detail::assertMessage(\"Cannot increment empty iterator\")");
}

void emd_hat_impl_integral_types<long long,(FLOW_TYPE_T)0>::operator()()
{
  __assert_rtn("operator()", "emd_hat_impl.hpp", 100, "Qc.size()==N");
}

void min_cost_flow<long long>::operator()()
{
  __assert_rtn("operator()", "min_cost_flow.hpp", 89, "x.size()==c.size()");
}

{
  __assert_rtn("operator()", "min_cost_flow.hpp", 88, "e.size()==c.size()");
}

uint64_t AVCaptureSessionSetAuthorizedToUseCameraInMultipleForegroundAppLayout()
{
  return MEMORY[0x1E0C8A1C0]();
}

uint64_t AnalyticsSendEvent()
{
  return MEMORY[0x1E0D15420]();
}

uint64_t AnalyticsSendEventLazy()
{
  return MEMORY[0x1E0D15428]();
}

uint64_t AppC3DConfigCreate()
{
  return MEMORY[0x1E0CF8760]();
}

uint64_t AppC3DConfigRelease()
{
  return MEMORY[0x1E0CF8768]();
}

uint64_t AppC3DConfigSetMaxNumberCodesToTrack()
{
  return MEMORY[0x1E0CF8778]();
}

uint64_t AppC3DConfigSetTrackingConfig()
{
  return MEMORY[0x1E0CF8780]();
}

uint64_t AppC3DConfigSetTrackingMode()
{
  return MEMORY[0x1E0CF8788]();
}

uint64_t AppC3DCreate()
{
  return MEMORY[0x1E0CF8790]();
}

uint64_t AppC3DProcess()
{
  return MEMORY[0x1E0CF87A0]();
}

uint64_t AppC3DProcessCameraFrameData()
{
  return MEMORY[0x1E0CF87A8]();
}

uint64_t AppC3DRelease()
{
  return MEMORY[0x1E0CF87B0]();
}

uint64_t AppC3DSetPerformanceMode()
{
  return MEMORY[0x1E0CF87B8]();
}

uint64_t AppC3DSetUpdateCallback()
{
  return MEMORY[0x1E0CF87C0]();
}

uint64_t AppC3DTrackingResultCopyTransform()
{
  return MEMORY[0x1E0CF87C8]();
}

uint64_t AppC3DTrackingResultCreateData()
{
  return MEMORY[0x1E0CF87D8]();
}

uint64_t AppC3DTrackingResultGetConfidence()
{
  return MEMORY[0x1E0CF87E0]();
}

uint64_t AppC3DTrackingResultGetDataVersion()
{
  return MEMORY[0x1E0CF87E8]();
}

uint64_t AppC3DTrackingResultGetId()
{
  return MEMORY[0x1E0CF87F0]();
}

uint64_t AppC3DTrackingResultGetMetadata()
{
  return MEMORY[0x1E0CF87F8]();
}

uint64_t AppC3DTrackingResultGetNumberOfTrackingData()
{
  return MEMORY[0x1E0CF8800]();
}

uint64_t AppC3DTrackingResultGetSize()
{
  return MEMORY[0x1E0CF8808]();
}

uint64_t AppC3DTrackingResultIsScaleReliable()
{
  return MEMORY[0x1E0CF8810]();
}

CFTimeInterval CACurrentMediaTime(void)
{
  CFTimeInterval result;

  MEMORY[0x1E0CD2388]();
  return result;
}

unsigned __int8 *__cdecl CC_SHA1(const void *data, CC_LONG len, unsigned __int8 *md)
{
  return (unsigned __int8 *)MEMORY[0x1E0C80328](data, *(_QWORD *)&len, md);
}

CFAbsoluteTime CFAbsoluteTimeGetCurrent(void)
{
  CFAbsoluteTime result;

  MEMORY[0x1E0C97C58]();
  return result;
}

void CFArrayAppendValue(CFMutableArrayRef theArray, const void *value)
{
  MEMORY[0x1E0C97CF8](theArray, value);
}

CFMutableArrayRef CFArrayCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFArrayCallBacks *callBacks)
{
  return (CFMutableArrayRef)MEMORY[0x1E0C97D38](allocator, capacity, callBacks);
}

CFIndex CFArrayGetCount(CFArrayRef theArray)
{
  return MEMORY[0x1E0C97D60](theArray);
}

const void *__cdecl CFArrayGetValueAtIndex(CFArrayRef theArray, CFIndex idx)
{
  return (const void *)MEMORY[0x1E0C97D98](theArray, idx);
}

void CFArrayRemoveValueAtIndex(CFMutableArrayRef theArray, CFIndex idx)
{
  MEMORY[0x1E0C97DC0](theArray, idx);
}

CFStringRef CFCopyDescription(CFTypeRef cf)
{
  return (CFStringRef)MEMORY[0x1E0C98350](cf);
}

const UInt8 *__cdecl CFDataGetBytePtr(CFDataRef theData)
{
  return (const UInt8 *)MEMORY[0x1E0C983E0](theData);
}

CFIndex CFDataGetLength(CFDataRef theData)
{
  return MEMORY[0x1E0C983F8](theData);
}

void CFDictionaryAddValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98500](theDict, key, value);
}

CFDictionaryRef CFDictionaryCreate(CFAllocatorRef allocator, const void **keys, const void **values, CFIndex numValues, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFDictionaryRef)MEMORY[0x1E0C98530](allocator, keys, values, numValues, keyCallBacks, valueCallBacks);
}

CFMutableDictionaryRef CFDictionaryCreateMutable(CFAllocatorRef allocator, CFIndex capacity, const CFDictionaryKeyCallBacks *keyCallBacks, const CFDictionaryValueCallBacks *valueCallBacks)
{
  return (CFMutableDictionaryRef)MEMORY[0x1E0C98550](allocator, capacity, keyCallBacks, valueCallBacks);
}

const void *__cdecl CFDictionaryGetValue(CFDictionaryRef theDict, const void *key)
{
  return (const void *)MEMORY[0x1E0C985B8](theDict, key);
}

void CFDictionarySetValue(CFMutableDictionaryRef theDict, const void *key, const void *value)
{
  MEMORY[0x1E0C98610](theDict, key, value);
}

CFStringRef CFErrorCopyDescription(CFErrorRef err)
{
  return (CFStringRef)MEMORY[0x1E0C98630](err);
}

CFTypeID CFGetTypeID(CFTypeRef cf)
{
  return MEMORY[0x1E0C98738](cf);
}

CFNotificationCenterRef CFNotificationCenterGetDarwinNotifyCenter(void)
{
  return (CFNotificationCenterRef)MEMORY[0x1E0C988B8]();
}

void CFNotificationCenterPostNotification(CFNotificationCenterRef center, CFNotificationName name, const void *object, CFDictionaryRef userInfo, Boolean deliverImmediately)
{
  MEMORY[0x1E0C988E0](center, name, object, userInfo, deliverImmediately);
}

CFNumberRef CFNumberCreate(CFAllocatorRef allocator, CFNumberType theType, const void *valuePtr)
{
  return (CFNumberRef)MEMORY[0x1E0C98928](allocator, theType, valuePtr);
}

CFTypeID CFNumberGetTypeID(void)
{
  return MEMORY[0x1E0C989B8]();
}

Boolean CFNumberGetValue(CFNumberRef number, CFNumberType theType, void *valuePtr)
{
  return MEMORY[0x1E0C989C0](number, theType, valuePtr);
}

void CFRelease(CFTypeRef cf)
{
  MEMORY[0x1E0C98BC0](cf);
}

CFTypeRef CFRetain(CFTypeRef cf)
{
  return (CFTypeRef)MEMORY[0x1E0C98BD0](cf);
}

void CFRunLoopAddObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BE8](rl, observer, mode);
}

void CFRunLoopAddSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98BF8](rl, source, mode);
}

CFRunLoopRef CFRunLoopGetCurrent(void)
{
  return (CFRunLoopRef)MEMORY[0x1E0C98C30]();
}

CFRunLoopObserverRef CFRunLoopObserverCreateWithHandler(CFAllocatorRef allocator, CFOptionFlags activities, Boolean repeats, CFIndex order, void *block)
{
  return (CFRunLoopObserverRef)MEMORY[0x1E0C98C68](allocator, activities, repeats, order, block);
}

void CFRunLoopPerformBlock(CFRunLoopRef rl, CFTypeRef mode, void *block)
{
  MEMORY[0x1E0C98C80](rl, mode, block);
}

void CFRunLoopRemoveObserver(CFRunLoopRef rl, CFRunLoopObserverRef observer, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C88](rl, observer, mode);
}

void CFRunLoopRemoveSource(CFRunLoopRef rl, CFRunLoopSourceRef source, CFRunLoopMode mode)
{
  MEMORY[0x1E0C98C90](rl, source, mode);
}

void CFRunLoopRun(void)
{
  MEMORY[0x1E0C98CA8]();
}

CFRunLoopSourceRef CFRunLoopSourceCreate(CFAllocatorRef allocator, CFIndex order, CFRunLoopSourceContext *context)
{
  return (CFRunLoopSourceRef)MEMORY[0x1E0C98CC8](allocator, order, context);
}

void CFRunLoopStop(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D00](rl);
}

void CFRunLoopWakeUp(CFRunLoopRef rl)
{
  MEMORY[0x1E0C98D68](rl);
}

CFStringRef CFStringCreateWithCString(CFAllocatorRef alloc, const char *cStr, CFStringEncoding encoding)
{
  return (CFStringRef)MEMORY[0x1E0C98FD0](alloc, cStr, *(_QWORD *)&encoding);
}

const char *__cdecl CFStringGetCStringPtr(CFStringRef theString, CFStringEncoding encoding)
{
  return (const char *)MEMORY[0x1E0C990A0](theString, *(_QWORD *)&encoding);
}

CFTypeID CFStringGetTypeID(void)
{
  return MEMORY[0x1E0C99170]();
}

CFURLRef CFURLCreateWithFileSystemPath(CFAllocatorRef allocator, CFStringRef filePath, CFURLPathStyle pathStyle, Boolean isDirectory)
{
  return (CFURLRef)MEMORY[0x1E0C99420](allocator, filePath, pathStyle, isDirectory);
}

CFUUIDRef CFUUIDCreate(CFAllocatorRef alloc)
{
  return (CFUUIDRef)MEMORY[0x1E0C99518](alloc);
}

CFUUIDRef CFUUIDCreateFromUUIDBytes(CFAllocatorRef alloc, CFUUIDBytes bytes)
{
  return (CFUUIDRef)MEMORY[0x1E0C99530](alloc, *(_QWORD *)&bytes.byte0, *(_QWORD *)&bytes.byte8);
}

CFStringRef CFUUIDCreateString(CFAllocatorRef alloc, CFUUIDRef uuid)
{
  return (CFStringRef)MEMORY[0x1E0C99538](alloc, uuid);
}

CFUUIDBytes CFUUIDGetUUIDBytes(CFUUIDRef uuid)
{
  uint64_t v1;
  uint64_t v2;
  CFUUIDBytes result;

  v1 = MEMORY[0x1E0C99568](uuid);
  result.byte8 = v2;
  result.byte9 = BYTE1(v2);
  result.byte10 = BYTE2(v2);
  result.byte11 = BYTE3(v2);
  result.byte12 = BYTE4(v2);
  result.byte13 = BYTE5(v2);
  result.byte14 = BYTE6(v2);
  result.byte15 = HIBYTE(v2);
  result.byte0 = v1;
  result.byte1 = BYTE1(v1);
  result.byte2 = BYTE2(v1);
  result.byte3 = BYTE3(v1);
  result.byte4 = BYTE4(v1);
  result.byte5 = BYTE5(v1);
  result.byte6 = BYTE6(v1);
  result.byte7 = HIBYTE(v1);
  return result;
}

BOOL CGAffineTransformEqualToTransform(CGAffineTransform *t1, CGAffineTransform *t2)
{
  return MEMORY[0x1E0C9BAA0](t1, t2);
}

CGAffineTransform *__cdecl CGAffineTransformInvert(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAB0](retstr, t);
}

CGAffineTransform *__cdecl CGAffineTransformMakeRotation(CGAffineTransform *__return_ptr retstr, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAD0](retstr, angle);
}

CGAffineTransform *__cdecl CGAffineTransformRotate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat angle)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BAF0](retstr, t, angle);
}

CGAffineTransform *__cdecl CGAffineTransformTranslate(CGAffineTransform *__return_ptr retstr, CGAffineTransform *t, CGFloat tx, CGFloat ty)
{
  return (CGAffineTransform *)MEMORY[0x1E0C9BB00](retstr, t, tx, ty);
}

CGContextRef CGBitmapContextCreate(void *data, size_t width, size_t height, size_t bitsPerComponent, size_t bytesPerRow, CGColorSpaceRef space, uint32_t bitmapInfo)
{
  return (CGContextRef)MEMORY[0x1E0C9BB10](data, width, height, bitsPerComponent, bytesPerRow, space, *(_QWORD *)&bitmapInfo);
}

CGColorSpaceRef CGColorSpaceCreateDeviceRGB(void)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BDF0]();
}

CGColorSpaceRef CGColorSpaceCreateWithName(CFStringRef name)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9BE50](name);
}

CGColorSpaceModel CGColorSpaceGetModel(CGColorSpaceRef space)
{
  return MEMORY[0x1E0C9BEC8](space);
}

void CGColorSpaceRelease(CGColorSpaceRef space)
{
  MEMORY[0x1E0C9BF30](space);
}

void CGContextConcatCTM(CGContextRef c, CGAffineTransform *transform)
{
  MEMORY[0x1E0C9C050](c, transform);
}

void CGContextDrawImage(CGContextRef c, CGRect rect, CGImageRef image)
{
  MEMORY[0x1E0C9C170](c, image, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

void CGContextRelease(CGContextRef c)
{
  MEMORY[0x1E0C9C340](c);
}

CFDataRef CGDataProviderCopyData(CGDataProviderRef provider)
{
  return (CFDataRef)MEMORY[0x1E0C9C5D8](provider);
}

CGDataProviderRef CGDataProviderCreateWithData(void *info, const void *data, size_t size, CGDataProviderReleaseDataCallback releaseData)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9C600](info, data, size, releaseData);
}

void CGDataProviderRelease(CGDataProviderRef provider)
{
  MEMORY[0x1E0C9C638](provider);
}

CGImageRef CGImageCreate(size_t width, size_t height, size_t bitsPerComponent, size_t bitsPerPixel, size_t bytesPerRow, CGColorSpaceRef space, CGBitmapInfo bitmapInfo, CGDataProviderRef provider, const CGFloat *decode, BOOL shouldInterpolate, CGColorRenderingIntent intent)
{
  return (CGImageRef)MEMORY[0x1E0C9CB80](width, height, bitsPerComponent, bitsPerPixel, bytesPerRow, space, *(_QWORD *)&bitmapInfo, provider);
}

void CGImageDestinationAddImage(CGImageDestinationRef idst, CGImageRef image, CFDictionaryRef properties)
{
  MEMORY[0x1E0CBC308](idst, image, properties);
}

CGImageDestinationRef CGImageDestinationCreateWithURL(CFURLRef url, CFStringRef type, size_t count, CFDictionaryRef options)
{
  return (CGImageDestinationRef)MEMORY[0x1E0CBC348](url, type, count, options);
}

BOOL CGImageDestinationFinalize(CGImageDestinationRef idst)
{
  return MEMORY[0x1E0CBC358](idst);
}

CGImageAlphaInfo CGImageGetAlphaInfo(CGImageRef image)
{
  return MEMORY[0x1E0C9CBE8](image);
}

size_t CGImageGetBitsPerComponent(CGImageRef image)
{
  return MEMORY[0x1E0C9CBF8](image);
}

size_t CGImageGetBitsPerPixel(CGImageRef image)
{
  return MEMORY[0x1E0C9CC00](image);
}

size_t CGImageGetBytesPerRow(CGImageRef image)
{
  return MEMORY[0x1E0C9CC08](image);
}

CGColorSpaceRef CGImageGetColorSpace(CGImageRef image)
{
  return (CGColorSpaceRef)MEMORY[0x1E0C9CC20](image);
}

CGDataProviderRef CGImageGetDataProvider(CGImageRef image)
{
  return (CGDataProviderRef)MEMORY[0x1E0C9CC38](image);
}

size_t CGImageGetHeight(CGImageRef image)
{
  return MEMORY[0x1E0C9CC60](image);
}

size_t CGImageGetWidth(CGImageRef image)
{
  return MEMORY[0x1E0C9CCD0](image);
}

void CGImageRelease(CGImageRef image)
{
  MEMORY[0x1E0C9CDA0](image);
}

CGImageRef CGImageSourceCreateImageAtIndex(CGImageSourceRef isrc, size_t index, CFDictionaryRef options)
{
  return (CGImageRef)MEMORY[0x1E0CBC568](isrc, index, options);
}

CGImageSourceRef CGImageSourceCreateWithURL(CFURLRef url, CFDictionaryRef options)
{
  return (CGImageSourceRef)MEMORY[0x1E0CBC5C0](url, options);
}

BOOL CGPointMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGPoint *point)
{
  return MEMORY[0x1E0C9D530](dict, point);
}

CGRect CGRectApplyAffineTransform(CGRect rect, CGAffineTransform *t)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D548](t, (__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectContainsPoint(CGRect rect, CGPoint point)
{
  return MEMORY[0x1E0C9D550]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height, (__n128)point, *(__n128 *)&point.y);
}

CFDictionaryRef CGRectCreateDictionaryRepresentation(CGRect a1)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9D560]((__n128)a1.origin, *(__n128 *)&a1.origin.y, (__n128)a1.size, *(__n128 *)&a1.size.height);
}

BOOL CGRectEqualToRect(CGRect rect1, CGRect rect2)
{
  return MEMORY[0x1E0C9D570]((__n128)rect1.origin, *(__n128 *)&rect1.origin.y, (__n128)rect1.size, *(__n128 *)&rect1.size.height, (__n128)rect2.origin, *(__n128 *)&rect2.origin.y, (__n128)rect2.size, *(__n128 *)&rect2.size.height);
}

CGRect CGRectIntersection(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D5F8]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

BOOL CGRectIsEmpty(CGRect rect)
{
  return MEMORY[0x1E0C9D608]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
}

BOOL CGRectMakeWithDictionaryRepresentation(CFDictionaryRef dict, CGRect *rect)
{
  return MEMORY[0x1E0C9D620](dict, rect);
}

CGRect CGRectStandardize(CGRect rect)
{
  double v1;
  double v2;
  double v3;
  double v4;
  CGRect result;

  MEMORY[0x1E0C9D638]((__n128)rect.origin, *(__n128 *)&rect.origin.y, (__n128)rect.size, *(__n128 *)&rect.size.height);
  result.size.height = v4;
  result.size.width = v3;
  result.origin.y = v2;
  result.origin.x = v1;
  return result;
}

CGRect CGRectUnion(CGRect r1, CGRect r2)
{
  double v2;
  double v3;
  double v4;
  double v5;
  CGRect result;

  MEMORY[0x1E0C9D640]((__n128)r1.origin, *(__n128 *)&r1.origin.y, (__n128)r1.size, *(__n128 *)&r1.size.height, (__n128)r2.origin, *(__n128 *)&r2.origin.y, (__n128)r2.size, *(__n128 *)&r2.size.height);
  result.size.height = v5;
  result.size.width = v4;
  result.origin.y = v3;
  result.origin.x = v2;
  return result;
}

CLLocationCoordinate2D CLLocationCoordinate2DMake(CLLocationDegrees latitude, CLLocationDegrees longitude)
{
  double v2;
  double v3;
  CLLocationCoordinate2D result;

  MEMORY[0x1E0C9E308](latitude, longitude);
  result.longitude = v3;
  result.latitude = v2;
  return result;
}

OSStatus CMAudioFormatDescriptionCreate(CFAllocatorRef allocator, const AudioStreamBasicDescription *asbd, size_t layoutSize, const AudioChannelLayout *layout, size_t magicCookieSize, const void *magicCookie, CFDictionaryRef extensions, CMAudioFormatDescriptionRef *formatDescriptionOut)
{
  return MEMORY[0x1E0C9EA80](allocator, asbd, layoutSize, layout, magicCookieSize, magicCookie, extensions, formatDescriptionOut);
}

CMTime *__cdecl CMClockGetTime(CMTime *__return_ptr retstr, CMClockRef clock)
{
  return (CMTime *)MEMORY[0x1E0C9ED48](retstr, clock);
}

FourCharCode CMFormatDescriptionGetMediaSubType(CMFormatDescriptionRef desc)
{
  return MEMORY[0x1E0C9EDD8](desc);
}

CFTypeRef CMGetAttachment(CMAttachmentBearerRef target, CFStringRef key, CMAttachmentMode *attachmentModeOut)
{
  return (CFTypeRef)MEMORY[0x1E0C9EE00](target, key, attachmentModeOut);
}

uint64_t CMPointCloudFormatDescriptionGetNumberOfPoints()
{
  return MEMORY[0x1E0C9EF00]();
}

CVImageBufferRef CMSampleBufferGetImageBuffer(CMSampleBufferRef sbuf)
{
  return (CVImageBufferRef)MEMORY[0x1E0C9EFD8](sbuf);
}

CMTime *__cdecl CMSampleBufferGetPresentationTimeStamp(CMTime *__return_ptr retstr, CMSampleBufferRef sbuf)
{
  return (CMTime *)MEMORY[0x1E0C9F008](retstr, sbuf);
}

int32_t CMTimeCompare(CMTime *time1, CMTime *time2)
{
  return MEMORY[0x1E0C9F2D8](time1, time2);
}

CFDictionaryRef CMTimeCopyAsDictionary(CMTime *time, CFAllocatorRef allocator)
{
  return (CFDictionaryRef)MEMORY[0x1E0C9F2F0](time, allocator);
}

Float64 CMTimeGetSeconds(CMTime *time)
{
  Float64 result;

  MEMORY[0x1E0C9F310](time);
  return result;
}

CMTime *__cdecl CMTimeMake(CMTime *__return_ptr retstr, int64_t value, int32_t timescale)
{
  return (CMTime *)MEMORY[0x1E0C9F318](retstr, value, *(_QWORD *)&timescale);
}

CMTime *__cdecl CMTimeMakeFromDictionary(CMTime *__return_ptr retstr, CFDictionaryRef dictionaryRepresentation)
{
  return (CMTime *)MEMORY[0x1E0C9F320](retstr, dictionaryRepresentation);
}

CMTime *__cdecl CMTimeMakeWithSeconds(CMTime *__return_ptr retstr, Float64 seconds, int32_t preferredTimescale)
{
  return (CMTime *)MEMORY[0x1E0C9F330](retstr, *(_QWORD *)&preferredTimescale, seconds);
}

CMTime *__cdecl CMTimeSubtract(CMTime *__return_ptr retstr, CMTime *lhs, CMTime *rhs)
{
  return (CMTime *)MEMORY[0x1E0C9F400](retstr, lhs, rhs);
}

CMVideoDimensions CMVideoFormatDescriptionGetDimensions(CMVideoFormatDescriptionRef videoDesc)
{
  return (CMVideoDimensions)MEMORY[0x1E0C9F558](videoDesc);
}

uint64_t CV3DGetVersionInfo()
{
  return MEMORY[0x1E0CFC260]();
}

uint64_t CV3DHitTestingDefaultParameters()
{
  return MEMORY[0x1E0CFC268]();
}

uint64_t CV3DKeyframeWithPointsRelease()
{
  return MEMORY[0x1E0CFC270]();
}

uint64_t CV3DLoggingCreateHandle()
{
  return MEMORY[0x1E0CFC278]();
}

uint64_t CV3DLoggingEnable()
{
  return MEMORY[0x1E0CFC280]();
}

uint64_t CV3DLoggingEnableInternal()
{
  return MEMORY[0x1E0CFC288]();
}

uint64_t CV3DLoggingReleaseHandle()
{
  return MEMORY[0x1E0CFC290]();
}

uint64_t CV3DMLModelCreate()
{
  return MEMORY[0x1E0CFC298]();
}

uint64_t CV3DMLModelRelease()
{
  return MEMORY[0x1E0CFC2A0]();
}

uint64_t CV3DModelsCreateObjectRegionProposalModelData()
{
  return MEMORY[0x1E0CFCBF8]();
}

uint64_t CV3DNormalEstimationCreate()
{
  return MEMORY[0x1E0CFC2A8]();
}

uint64_t CV3DNormalEstimationSessionCompute()
{
  return MEMORY[0x1E0CFC2B0]();
}

uint64_t CV3DNormalEstimationSessionRelease()
{
  return MEMORY[0x1E0CFC2B8]();
}

uint64_t CV3DODTAdd3dObject()
{
  return MEMORY[0x1E0CFC2C0]();
}

uint64_t CV3DODTAddPlanarObject()
{
  return MEMORY[0x1E0CFC2C8]();
}

uint64_t CV3DODTConfigCreate()
{
  return MEMORY[0x1E0CFC2D0]();
}

uint64_t CV3DODTConfigRelease()
{
  return MEMORY[0x1E0CFC2D8]();
}

uint64_t CV3DODTCreateWithOptionsConfigAndModel()
{
  return MEMORY[0x1E0CFC2E0]();
}

uint64_t CV3DODTDetectWithMetadata()
{
  return MEMORY[0x1E0CFC2E8]();
}

uint64_t CV3DODTGetMaxSupportedNumberImagesToTrack()
{
  return MEMORY[0x1E0CFC2F0]();
}

uint64_t CV3DODTImagePredict()
{
  return MEMORY[0x1E0CFC2F8]();
}

uint64_t CV3DODTImagePredictInWorld()
{
  return MEMORY[0x1E0CFC300]();
}

uint64_t CV3DODTObjectInfoRelease()
{
  return MEMORY[0x1E0CFC308]();
}

uint64_t CV3DODTRelease()
{
  return MEMORY[0x1E0CFC310]();
}

uint64_t CV3DODTSetMaximumTrackingTime()
{
  return MEMORY[0x1E0CFC318]();
}

uint64_t CV3DODTSetPerformanceMode()
{
  return MEMORY[0x1E0CFC320]();
}

uint64_t CV3DODTTrack()
{
  return MEMORY[0x1E0CFC328]();
}

uint64_t CV3DODTTrackAndEstimateScale()
{
  return MEMORY[0x1E0CFC330]();
}

uint64_t CV3DODTVerifyReferenceImage()
{
  return MEMORY[0x1E0CFC338]();
}

uint64_t CV3DODTWaitForAllObjectsAddToFinish()
{
  return MEMORY[0x1E0CFC340]();
}

uint64_t CV3DPerformHitTestPointCloud()
{
  return MEMORY[0x1E0CFC348]();
}

uint64_t CV3DPlaneDetectionAlignedBoundingBoxMax()
{
  return MEMORY[0x1E0D83CA0]();
}

uint64_t CV3DPlaneDetectionAlignedBoundingBoxMin()
{
  return MEMORY[0x1E0D83CA8]();
}

uint64_t CV3DPlaneDetectionConfigurationCreate()
{
  return MEMORY[0x1E0D83CB0]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableDeterministicMode()
{
  return MEMORY[0x1E0D83CB8]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableLowQosScheduling()
{
  return MEMORY[0x1E0D83CC0]();
}

uint64_t CV3DPlaneDetectionConfigurationEnableMLSegmentDetector()
{
  return MEMORY[0x1E0D83CC8]();
}

uint64_t CV3DPlaneDetectionConfigurationEqualConfigurations()
{
  return MEMORY[0x1E0D83CD0]();
}

uint64_t CV3DPlaneDetectionConfigurationRelease()
{
  return MEMORY[0x1E0D83CD8]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDesiredExtent()
{
  return MEMORY[0x1E0D83CE0]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDesiredOrientations()
{
  return MEMORY[0x1E0D83CE8]();
}

uint64_t CV3DPlaneDetectionConfigurationSetDetectionPolicy()
{
  return MEMORY[0x1E0D83CF0]();
}

uint64_t CV3DPlaneDetectionConfigurationSetMinVergenceAngle()
{
  return MEMORY[0x1E0D83CF8]();
}

uint64_t CV3DPlaneDetectionConvexHullPointsNum()
{
  return MEMORY[0x1E0D83D00]();
}

uint64_t CV3DPlaneDetectionConvexHullPointsRawPtr()
{
  return MEMORY[0x1E0D83D08]();
}

uint64_t CV3DPlaneDetectionDepthAndSemanticFrameCreate()
{
  return MEMORY[0x1E0D83D10]();
}

uint64_t CV3DPlaneDetectionDepthAndSemanticFrameRelease()
{
  return MEMORY[0x1E0D83D18]();
}

uint64_t CV3DPlaneDetectionDepthCameraFrameCreateFromAD()
{
  return MEMORY[0x1E0D83D20]();
}

uint64_t CV3DPlaneDetectionDepthCameraFrameRelease()
{
  return MEMORY[0x1E0D83D28]();
}

uint64_t CV3DPlaneDetectionErasePlaneDetections()
{
  return MEMORY[0x1E0D83D30]();
}

uint64_t CV3DPlaneDetectionExtentGridAtIndex()
{
  return MEMORY[0x1E0D83D38]();
}

uint64_t CV3DPlaneDetectionExtentGridLength()
{
  return MEMORY[0x1E0D83D40]();
}

uint64_t CV3DPlaneDetectionExtentTypesCreate()
{
  return MEMORY[0x1E0D83D48]();
}

uint64_t CV3DPlaneDetectionExtentTypesRelease()
{
  return MEMORY[0x1E0D83D50]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetAll()
{
  return MEMORY[0x1E0D83D58]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetAxisAlignedBox()
{
  return MEMORY[0x1E0D83D60]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetConvexHull()
{
  return MEMORY[0x1E0D83D68]();
}

uint64_t CV3DPlaneDetectionExtentTypesSetOrientedBox()
{
  return MEMORY[0x1E0D83D70]();
}

uint64_t CV3DPlaneDetectionGetNumSemanticLabels()
{
  return MEMORY[0x1E0D83D78]();
}

uint64_t CV3DPlaneDetectionGetSemanticLabel()
{
  return MEMORY[0x1E0D83D80]();
}

uint64_t CV3DPlaneDetectionGetSemanticProbability()
{
  return MEMORY[0x1E0D83D88]();
}

uint64_t CV3DPlaneDetectionLoadMap()
{
  return MEMORY[0x1E0D83D90]();
}

uint64_t CV3DPlaneDetectionParametersCreate()
{
  return MEMORY[0x1E0D83D98]();
}

uint64_t CV3DPlaneDetectionParametersEqualParameters()
{
  return MEMORY[0x1E0D83DA0]();
}

uint64_t CV3DPlaneDetectionParametersRelease()
{
  return MEMORY[0x1E0D83DA8]();
}

uint64_t CV3DPlaneDetectionParametersSetInverseDepthDetector()
{
  return MEMORY[0x1E0D83DB0]();
}

uint64_t CV3DPlaneDetectionParametersSetMinClusterSize()
{
  return MEMORY[0x1E0D83DB8]();
}

uint64_t CV3DPlaneDetectionParametersSetMinDepthConfidence()
{
  return MEMORY[0x1E0D83DC0]();
}

uint64_t CV3DPlaneDetectionParametersSetMinDetections()
{
  return MEMORY[0x1E0D83DC8]();
}

uint64_t CV3DPlaneDetectionParametersSetMinNormalDotProduct()
{
  return MEMORY[0x1E0D83DD0]();
}

uint64_t CV3DPlaneDetectionParametersSetMinimumCellSize()
{
  return MEMORY[0x1E0D83DD8]();
}

uint64_t CV3DPlaneDetectionParametersSetPlaneFitThreshold()
{
  return MEMORY[0x1E0D83DE0]();
}

uint64_t CV3DPlaneDetectionPlaneAge()
{
  return MEMORY[0x1E0D83DE8]();
}

uint64_t CV3DPlaneDetectionPlaneAtIndex()
{
  return MEMORY[0x1E0D83DF0]();
}

uint64_t CV3DPlaneDetectionPlaneConvexHull2D()
{
  return MEMORY[0x1E0D83DF8]();
}

uint64_t CV3DPlaneDetectionPlaneCopyUUID()
{
  return MEMORY[0x1E0D83E00]();
}

uint64_t CV3DPlaneDetectionPlaneCreateTriangulatedPolygons()
{
  return MEMORY[0x1E0D83E08]();
}

uint64_t CV3DPlaneDetectionPlaneExtentAlignedBoundingBox()
{
  return MEMORY[0x1E0D83E10]();
}

uint64_t CV3DPlaneDetectionPlaneExtentOrientedBoundingBox()
{
  return MEMORY[0x1E0D83E18]();
}

uint64_t CV3DPlaneDetectionPlaneExtentPolygons()
{
  return MEMORY[0x1E0D83E20]();
}

uint64_t CV3DPlaneDetectionPlaneGetOrientation()
{
  return MEMORY[0x1E0D83E28]();
}

uint64_t CV3DPlaneDetectionPlaneListLength()
{
  return MEMORY[0x1E0D83E30]();
}

uint64_t CV3DPlaneDetectionPlaneListRelease()
{
  return MEMORY[0x1E0D83E38]();
}

uint64_t CV3DPlaneDetectionPlaneListRetain()
{
  return MEMORY[0x1E0D83E40]();
}

uint64_t CV3DPlaneDetectionPlaneMergedIds()
{
  return MEMORY[0x1E0D83E48]();
}

uint64_t CV3DPlaneDetectionPlaneTransformationToWorld()
{
  return MEMORY[0x1E0D83E50]();
}

uint64_t CV3DPlaneDetectionPlaneUncertaintyAlongNormal()
{
  return MEMORY[0x1E0D83E58]();
}

uint64_t CV3DPlaneDetectionPolygonAtIndex()
{
  return MEMORY[0x1E0D83E60]();
}

uint64_t CV3DPlaneDetectionPolygonListLength()
{
  return MEMORY[0x1E0D83E68]();
}

uint64_t CV3DPlaneDetectionPolygonPointsNum()
{
  return MEMORY[0x1E0D83E70]();
}

uint64_t CV3DPlaneDetectionPolygonPointsRawPtr()
{
  return MEMORY[0x1E0D83E78]();
}

uint64_t CV3DPlaneDetectionPushDepthAndSemanticFrame()
{
  return MEMORY[0x1E0D83E80]();
}

uint64_t CV3DPlaneDetectionPushSemanticFrame()
{
  return MEMORY[0x1E0D83E88]();
}

uint64_t CV3DPlaneDetectionPushSlamMetadata()
{
  return MEMORY[0x1E0D83E90]();
}

uint64_t CV3DPlaneDetectionPushSparseDepthFrame()
{
  return MEMORY[0x1E0D83E98]();
}

uint64_t CV3DPlaneDetectionSemanticFrameCreate()
{
  return MEMORY[0x1E0D83EA0]();
}

uint64_t CV3DPlaneDetectionSemanticFrameRelease()
{
  return MEMORY[0x1E0D83EA8]();
}

uint64_t CV3DPlaneDetectionSerialize()
{
  return MEMORY[0x1E0D83EB0]();
}

uint64_t CV3DPlaneDetectionSessionCreateWithConfig()
{
  return MEMORY[0x1E0D83EB8]();
}

uint64_t CV3DPlaneDetectionSessionRegisterUpdateCallback()
{
  return MEMORY[0x1E0D83EC0]();
}

uint64_t CV3DPlaneDetectionSessionRelease()
{
  return MEMORY[0x1E0D83EC8]();
}

uint64_t CV3DPlaneDetectionSessionSetAnchoringFunctors()
{
  return MEMORY[0x1E0D83ED0]();
}

uint64_t CV3DPlaneDetectionSessionSetSingleShotPlanesCallback()
{
  return MEMORY[0x1E0D83ED8]();
}

uint64_t CV3DPlaneDetectionSetConfiguration()
{
  return MEMORY[0x1E0D83EE0]();
}

uint64_t CV3DPlaneDetectionSingleShotPlaneListRelease()
{
  return MEMORY[0x1E0D83EE8]();
}

uint64_t CV3DPlaneDetectionSingleShotPlaneListRetain()
{
  return MEMORY[0x1E0D83EF0]();
}

uint64_t CV3DPlaneDetectionSlamMetadataCreateFromSlamState()
{
  return MEMORY[0x1E0CFC350]();
}

uint64_t CV3DPlaneDetectionSlamMetadataRelease()
{
  return MEMORY[0x1E0D83EF8]();
}

uint64_t CV3DPosePredictionConfigCreate()
{
  return MEMORY[0x1E0CFC358]();
}

uint64_t CV3DPosePredictionConfigRelease()
{
  return MEMORY[0x1E0CFC360]();
}

uint64_t CV3DPosePredictionCreate()
{
  return MEMORY[0x1E0CFC368]();
}

uint64_t CV3DPosePredictionGetPose()
{
  return MEMORY[0x1E0CFC370]();
}

uint64_t CV3DPosePredictionPushAccel()
{
  return MEMORY[0x1E0CFC378]();
}

uint64_t CV3DPosePredictionPushGyro()
{
  return MEMORY[0x1E0CFC380]();
}

uint64_t CV3DPosePredictionPushSLAMMetadata()
{
  return MEMORY[0x1E0CFC388]();
}

uint64_t CV3DPosePredictionRelease()
{
  return MEMORY[0x1E0CFC390]();
}

uint64_t CV3DRayCastResultAtIndex()
{
  return MEMORY[0x1E0CFC398]();
}

uint64_t CV3DRayCastResultListFromId()
{
  return MEMORY[0x1E0CFC3A0]();
}

uint64_t CV3DRayCastResultMapIds()
{
  return MEMORY[0x1E0CFC3A8]();
}

uint64_t CV3DRayCastResultMapLength()
{
  return MEMORY[0x1E0CFC3B0]();
}

uint64_t CV3DRayCastResultsLength()
{
  return MEMORY[0x1E0CFC3B8]();
}

uint64_t CV3DRaycastDenseFrameCreate()
{
  return MEMORY[0x1E0CFC3C0]();
}

uint64_t CV3DRaycastDenseFrameRelease()
{
  return MEMORY[0x1E0CFC3C8]();
}

uint64_t CV3DRaycastGetResultOrientation()
{
  return MEMORY[0x1E0CFC3D0]();
}

uint64_t CV3DRaycastIntentCreate()
{
  return MEMORY[0x1E0CFC3D8]();
}

uint64_t CV3DRaycastIntentEnableTracking()
{
  return MEMORY[0x1E0CFC3E0]();
}

uint64_t CV3DRaycastIntentRelease()
{
  return MEMORY[0x1E0CFC3E8]();
}

uint64_t CV3DRaycastIntentSetConsideredGeometry()
{
  return MEMORY[0x1E0CFC3F0]();
}

uint64_t CV3DRaycastIntentSetConsideredOrientations()
{
  return MEMORY[0x1E0CFC3F8]();
}

uint64_t CV3DRaycastIntentSetExtentCheckForTrackedPlanes()
{
  return MEMORY[0x1E0CFC400]();
}

uint64_t CV3DRaycastInvalidateDenseFrame()
{
  return MEMORY[0x1E0CFC408]();
}

uint64_t CV3DRaycastPushChunks()
{
  return MEMORY[0x1E0CFC410]();
}

uint64_t CV3DRaycastPushDenseFrame()
{
  return MEMORY[0x1E0CFC418]();
}

uint64_t CV3DRaycastPushJasperPointCloud()
{
  return MEMORY[0x1E0CFC420]();
}

uint64_t CV3DRaycastPushPlanes()
{
  return MEMORY[0x1E0CFC428]();
}

uint64_t CV3DRaycastPushSlamState()
{
  return MEMORY[0x1E0CFC430]();
}

uint64_t CV3DRaycastRemoveTrackableRay()
{
  return MEMORY[0x1E0CFC438]();
}

uint64_t CV3DRaycastResultExtentChecked()
{
  return MEMORY[0x1E0CFC440]();
}

uint64_t CV3DRaycastResultListRelease()
{
  return MEMORY[0x1E0CFC448]();
}

uint64_t CV3DRaycastResultOriginatedFrom()
{
  return MEMORY[0x1E0CFC450]();
}

uint64_t CV3DRaycastResultPlaneIdentifier()
{
  return MEMORY[0x1E0CFC458]();
}

uint64_t CV3DRaycastResultTransformationToWorld()
{
  return MEMORY[0x1E0CFC460]();
}

uint64_t CV3DRaycastSessionAttemptWithIntent()
{
  return MEMORY[0x1E0CFC468]();
}

uint64_t CV3DRaycastSessionConfigurationCreate()
{
  return MEMORY[0x1E0CFC470]();
}

uint64_t CV3DRaycastSessionConfigurationEnableDeterministicMode()
{
  return MEMORY[0x1E0CFC478]();
}

uint64_t CV3DRaycastSessionConfigurationRelease()
{
  return MEMORY[0x1E0CFC480]();
}

uint64_t CV3DRaycastSessionCreateWithConfig()
{
  return MEMORY[0x1E0CFC488]();
}

uint64_t CV3DRaycastSessionRegisterOnTrackableUpdateCallback()
{
  return MEMORY[0x1E0CFC490]();
}

uint64_t CV3DRaycastSessionRelease()
{
  return MEMORY[0x1E0CFC498]();
}

uint64_t CV3DRaycastSessionSetAnchoringFunctors()
{
  return MEMORY[0x1E0CFC4A0]();
}

uint64_t CV3DRaycastTriggerUpdateFromTrackableIntentsAsync()
{
  return MEMORY[0x1E0CFC4A8]();
}

uint64_t CV3DReconFrameBundleAddSlamMetadata()
{
  return MEMORY[0x1E0D83F00]();
}

uint64_t CV3DReconFrameBundleCreate()
{
  return MEMORY[0x1E0D83F08]();
}

uint64_t CV3DReconFrameBundleRelease()
{
  return MEMORY[0x1E0D83F10]();
}

uint64_t CV3DReconFrameBundleSetColorImage()
{
  return MEMORY[0x1E0D83F18]();
}

uint64_t CV3DReconFrameBundleSetDepthConfidenceImage()
{
  return MEMORY[0x1E0D83F20]();
}

uint64_t CV3DReconFrameBundleSetDepthImage()
{
  return MEMORY[0x1E0D83F28]();
}

uint64_t CV3DReconFrameBundleSetNormalsImage()
{
  return MEMORY[0x1E0D83F30]();
}

uint64_t CV3DReconFrameBundleSetSemanticsImage()
{
  return MEMORY[0x1E0D83F38]();
}

uint64_t CV3DReconKeyframeCreatePointCloud()
{
  return MEMORY[0x1E0D83F40]();
}

uint64_t CV3DReconKeyframeGetCreationTime()
{
  return MEMORY[0x1E0D83F48]();
}

uint64_t CV3DReconKeyframeListCopyKeyframeAtIndex()
{
  return MEMORY[0x1E0D83F50]();
}

uint64_t CV3DReconKeyframeListGetCount()
{
  return MEMORY[0x1E0D83F58]();
}

uint64_t CV3DReconKeyframeListGetKeyframeToWorldTransformAtIndex()
{
  return MEMORY[0x1E0D83F60]();
}

uint64_t CV3DReconKeyframeListGetKeyframeUUIDAtIndex()
{
  return MEMORY[0x1E0D83F68]();
}

uint64_t CV3DReconKeyframeListRelease()
{
  return MEMORY[0x1E0D83F70]();
}

uint64_t CV3DReconKeyframeListRetain()
{
  return MEMORY[0x1E0D83F78]();
}

uint64_t CV3DReconKeyframeRelease()
{
  return MEMORY[0x1E0D83F80]();
}

uint64_t CV3DReconLoggingHandleCreate()
{
  return MEMORY[0x1E0D83F88]();
}

uint64_t CV3DReconLoggingHandleEnable()
{
  return MEMORY[0x1E0D83F90]();
}

uint64_t CV3DReconLoggingHandleEnableInternal()
{
  return MEMORY[0x1E0D83F98]();
}

uint64_t CV3DReconLoggingHandleRelease()
{
  return MEMORY[0x1E0D83FA0]();
}

uint64_t CV3DReconMeshGetFaceSemanticLabelsAsMTLBufferForDevice()
{
  return MEMORY[0x1E0D83FA8]();
}

uint64_t CV3DReconMeshGetFaceSemanticLabelsRawPtr()
{
  return MEMORY[0x1E0D83FB0]();
}

uint64_t CV3DReconMeshGetFacesAsMTLBufferForDevice()
{
  return MEMORY[0x1E0D83FB8]();
}

uint64_t CV3DReconMeshGetFacesCount()
{
  return MEMORY[0x1E0D83FC0]();
}

uint64_t CV3DReconMeshGetFacesRawPtr()
{
  return MEMORY[0x1E0D83FC8]();
}

uint64_t CV3DReconMeshGetLocalToWorldTransform()
{
  return MEMORY[0x1E0D83FD0]();
}

uint64_t CV3DReconMeshGetVertexColorsAsMTLBufferForDevice()
{
  return MEMORY[0x1E0D83FD8]();
}

uint64_t CV3DReconMeshGetVertexNormalsAsMTLBufferForDevice()
{
  return MEMORY[0x1E0D83FE0]();
}

uint64_t CV3DReconMeshGetVertexNormalsRawPtr()
{
  return MEMORY[0x1E0D83FE8]();
}

uint64_t CV3DReconMeshGetVerticesAsMTLBufferForDevice()
{
  return MEMORY[0x1E0D83FF0]();
}

uint64_t CV3DReconMeshGetVerticesCount()
{
  return MEMORY[0x1E0D83FF8]();
}

uint64_t CV3DReconMeshGetVerticesRawPtr()
{
  return MEMORY[0x1E0D84000]();
}

uint64_t CV3DReconMeshListCopyMeshAtIndex()
{
  return MEMORY[0x1E0D84008]();
}

uint64_t CV3DReconMeshListGetCount()
{
  return MEMORY[0x1E0D84010]();
}

uint64_t CV3DReconMeshListGetMeshUUIDAtIndex()
{
  return MEMORY[0x1E0D84018]();
}

uint64_t CV3DReconMeshListRelease()
{
  return MEMORY[0x1E0D84020]();
}

uint64_t CV3DReconMeshListRetain()
{
  return MEMORY[0x1E0D84028]();
}

uint64_t CV3DReconMeshRelease()
{
  return MEMORY[0x1E0D84030]();
}

uint64_t CV3DReconMeshingConfigurationAddMeshIntegrationAttribute()
{
  return MEMORY[0x1E0D84038]();
}

uint64_t CV3DReconMeshingConfigurationAddPrivateMeshIntegrationAttribute()
{
  return MEMORY[0x1E0D84040]();
}

uint64_t CV3DReconMeshingConfigurationCreateWithPrivatePreset()
{
  return MEMORY[0x1E0D84048]();
}

uint64_t CV3DReconMeshingConfigurationEnableOccupancyMapping()
{
  return MEMORY[0x1E0D84050]();
}

uint64_t CV3DReconMeshingConfigurationHasOccupancyMapping()
{
  return MEMORY[0x1E0D84058]();
}

uint64_t CV3DReconMeshingConfigurationRelease()
{
  return MEMORY[0x1E0D84060]();
}

uint64_t CV3DReconMeshingConfigurationRemoveMeshIntegrationAttribute()
{
  return MEMORY[0x1E0D84068]();
}

uint64_t CV3DReconMeshingConfigurationSetBucketsOrderOfMagnitude()
{
  return MEMORY[0x1E0D84070]();
}

uint64_t CV3DReconMeshingConfigurationSetMinMeshingPeriod()
{
  return MEMORY[0x1E0D84078]();
}

uint64_t CV3DReconMeshingConfigurationSetVoxelSize()
{
  return MEMORY[0x1E0D84080]();
}

uint64_t CV3DReconOccupancyQueryRequestCreateFromPoints()
{
  return MEMORY[0x1E0D84088]();
}

uint64_t CV3DReconOccupancyQueryRequestRelease()
{
  return MEMORY[0x1E0D84090]();
}

uint64_t CV3DReconOccupancyQueryResultGetRawPtr()
{
  return MEMORY[0x1E0D84098]();
}

uint64_t CV3DReconOccupancyQueryResultGetWidth()
{
  return MEMORY[0x1E0D840A0]();
}

uint64_t CV3DReconOccupancyQueryResultRelease()
{
  return MEMORY[0x1E0D840A8]();
}

uint64_t CV3DReconPointCloudGetColorRawPtr()
{
  return MEMORY[0x1E0D840B0]();
}

uint64_t CV3DReconPointCloudGetNormalsRawPtr()
{
  return MEMORY[0x1E0D840B8]();
}

uint64_t CV3DReconPointCloudGetPointsCount()
{
  return MEMORY[0x1E0D840C0]();
}

uint64_t CV3DReconPointCloudGetPointsRawPtr()
{
  return MEMORY[0x1E0D840C8]();
}

uint64_t CV3DReconPointCloudGetSemanticHistogramLabelsRawPtr()
{
  return MEMORY[0x1E0D840D0]();
}

uint64_t CV3DReconPointCloudGetSemanticHistogramVotesRawPtr()
{
  return MEMORY[0x1E0D840D8]();
}

uint64_t CV3DReconPointCloudRelease()
{
  return MEMORY[0x1E0D840E0]();
}

uint64_t CV3DReconSessionAddOnKeyframeListUpdateCallback()
{
  return MEMORY[0x1E0D840F0]();
}

uint64_t CV3DReconSessionAddOnMeshListUpdateCallback()
{
  return MEMORY[0x1E0D840F8]();
}

uint64_t CV3DReconSessionConfigurationAddMappingAttribute()
{
  return MEMORY[0x1E0D84100]();
}

uint64_t CV3DReconSessionConfigurationAddPrivateMappingAttribute()
{
  return MEMORY[0x1E0D84108]();
}

uint64_t CV3DReconSessionConfigurationCreateWithPrivatePreset()
{
  return MEMORY[0x1E0D84110]();
}

uint64_t CV3DReconSessionConfigurationEnableConsumeVIOMetadata()
{
  return MEMORY[0x1E0D84118]();
}

uint64_t CV3DReconSessionConfigurationEnableDeterministicBehavior()
{
  return MEMORY[0x1E0D84120]();
}

uint64_t CV3DReconSessionConfigurationEnableLowQosScheduling()
{
  return MEMORY[0x1E0D84128]();
}

uint64_t CV3DReconSessionConfigurationEnableSynchronousScheduling()
{
  return MEMORY[0x1E0D84130]();
}

uint64_t CV3DReconSessionConfigurationRelease()
{
  return MEMORY[0x1E0D84138]();
}

uint64_t CV3DReconSessionConfigurationSetMeshingConfiguration()
{
  return MEMORY[0x1E0D84140]();
}

uint64_t CV3DReconSessionConfigurationSetMinDepthConfidence()
{
  return MEMORY[0x1E0D84148]();
}

uint64_t CV3DReconSessionConfigurationSetSlamAdapter()
{
  return MEMORY[0x1E0D84150]();
}

uint64_t CV3DReconSessionCreateWithConfiguration()
{
  return MEMORY[0x1E0D84158]();
}

uint64_t CV3DReconSessionDisable()
{
  return MEMORY[0x1E0D84160]();
}

uint64_t CV3DReconSessionEnable()
{
  return MEMORY[0x1E0D84168]();
}

uint64_t CV3DReconSessionEnableMeshPlaneHarmony()
{
  return MEMORY[0x1E0D84170]();
}

uint64_t CV3DReconSessionEnablePerFrameMeshColor()
{
  return MEMORY[0x1E0D84178]();
}

uint64_t CV3DReconSessionEnablePerFrameMeshSemantics()
{
  return MEMORY[0x1E0D84180]();
}

uint64_t CV3DReconSessionHasKeyframingCapability()
{
  return MEMORY[0x1E0D84188]();
}

uint64_t CV3DReconSessionHasMeshingCapability()
{
  return MEMORY[0x1E0D84190]();
}

uint64_t CV3DReconSessionProcessFrameBundle()
{
  return MEMORY[0x1E0D84198]();
}

uint64_t CV3DReconSessionProcessPlaneList()
{
  return MEMORY[0x1E0D841A0]();
}

uint64_t CV3DReconSessionQueryOccupancyAsync()
{
  return MEMORY[0x1E0D841A8]();
}

uint64_t CV3DReconSessionRelease()
{
  return MEMORY[0x1E0D841B0]();
}

uint64_t CV3DReconSessionReset()
{
  return MEMORY[0x1E0D841B8]();
}

uint64_t CV3DReconSessionRetain()
{
  return MEMORY[0x1E0D841C0]();
}

uint64_t CV3DReconSessionWait()
{
  return MEMORY[0x1E0D841C8]();
}

uint64_t CV3DReconSlamAdapterCreate()
{
  return MEMORY[0x1E0D841D0]();
}

uint64_t CV3DReconSlamAdapterRelease()
{
  return MEMORY[0x1E0D841D8]();
}

uint64_t CV3DReconSlamAdapterSetAnchoringCallbacks()
{
  return MEMORY[0x1E0D841E0]();
}

uint64_t CV3DReconSlamMetadataCreateFromSlamState()
{
  return MEMORY[0x1E0CFC4B0]();
}

uint64_t CV3DReconSlamMetadataRelease()
{
  return MEMORY[0x1E0D841E8]();
}

uint64_t CV3DReleaseHitTestResults()
{
  return MEMORY[0x1E0CFC4B8]();
}

uint64_t CV3DSLAMAnchorCopyAnchorID()
{
  return MEMORY[0x1E0CFC4C0]();
}

uint64_t CV3DSLAMAnchorCopyPose()
{
  return MEMORY[0x1E0CFC4C8]();
}

uint64_t CV3DSLAMAnchorCopySessionID()
{
  return MEMORY[0x1E0CFC4D0]();
}

uint64_t CV3DSLAMCalibrationAddCameraParameters2()
{
  return MEMORY[0x1E0CFC4D8]();
}

uint64_t CV3DSLAMCalibrationAddIMUParameters()
{
  return MEMORY[0x1E0CFC4E0]();
}

uint64_t CV3DSLAMCalibrationCreate()
{
  return MEMORY[0x1E0CFC4E8]();
}

uint64_t CV3DSLAMCalibrationDetectRuntimeHardware()
{
  return MEMORY[0x1E0CFC4F0]();
}

uint64_t CV3DSLAMCalibrationRelease()
{
  return MEMORY[0x1E0CFC4F8]();
}

uint64_t CV3DSLAMCameraFrameAddHWFP()
{
  return MEMORY[0x1E0CFC500]();
}

uint64_t CV3DSLAMCameraFrameCreate()
{
  return MEMORY[0x1E0CFC508]();
}

uint64_t CV3DSLAMCameraFrameRelease()
{
  return MEMORY[0x1E0CFC510]();
}

uint64_t CV3DSLAMCameraModelTypeFromString()
{
  return MEMORY[0x1E0CFC518]();
}

uint64_t CV3DSLAMCameraVideoModeFromString()
{
  return MEMORY[0x1E0CFC520]();
}

uint64_t CV3DSLAMConfigAnchorStrategy()
{
  return MEMORY[0x1E0CFC528]();
}

uint64_t CV3DSLAMConfigAsString()
{
  return MEMORY[0x1E0CFC530]();
}

uint64_t CV3DSLAMConfigCalcFeaturePointDetectionResolution()
{
  return MEMORY[0x1E0CFC538]();
}

uint64_t CV3DSLAMConfigCalcLineDetectionResolution()
{
  return MEMORY[0x1E0CFC540]();
}

uint64_t CV3DSLAMConfigCreate2()
{
  return MEMORY[0x1E0CFC548]();
}

uint64_t CV3DSLAMConfigCreateAVCaptureConfig()
{
  return MEMORY[0x1E0CFC550]();
}

uint64_t CV3DSLAMConfigDisableCameraSwitchingAndUsePrimaryCamera()
{
  return MEMORY[0x1E0CFC558]();
}

uint64_t CV3DSLAMConfigDisableLineTracking()
{
  return MEMORY[0x1E0CFC560]();
}

uint64_t CV3DSLAMConfigDisableMLRelocalization()
{
  return MEMORY[0x1E0CFC568]();
}

uint64_t CV3DSLAMConfigDisablePlaneTracking()
{
  return MEMORY[0x1E0CFC570]();
}

uint64_t CV3DSLAMConfigEnableCollaborativeMapping()
{
  return MEMORY[0x1E0CFC578]();
}

uint64_t CV3DSLAMConfigEnableLacc()
{
  return MEMORY[0x1E0CFC580]();
}

uint64_t CV3DSLAMConfigEnableLineTracking()
{
  return MEMORY[0x1E0CFC588]();
}

uint64_t CV3DSLAMConfigEnableLineTrackingAlways()
{
  return MEMORY[0x1E0CFC590]();
}

uint64_t CV3DSLAMConfigEnableMLRelocalization()
{
  return MEMORY[0x1E0CFC598]();
}

uint64_t CV3DSLAMConfigEnablePlaneTracking()
{
  return MEMORY[0x1E0CFC5A0]();
}

uint64_t CV3DSLAMConfigEnableTransformToExternalSubmap()
{
  return MEMORY[0x1E0CFC5A8]();
}

uint64_t CV3DSLAMConfigGetLaccSupported()
{
  return MEMORY[0x1E0CFC5B0]();
}

uint64_t CV3DSLAMConfigIsMLRelocalizationSupported()
{
  return MEMORY[0x1E0CFC5B8]();
}

uint64_t CV3DSLAMConfigOutputCollaborativeMappingStatistics()
{
  return MEMORY[0x1E0CFC5C0]();
}

uint64_t CV3DSLAMConfigOverrideSessionID()
{
  return MEMORY[0x1E0CFC5C8]();
}

uint64_t CV3DSLAMConfigPresetFromString()
{
  return MEMORY[0x1E0CFC5D0]();
}

uint64_t CV3DSLAMConfigRelease()
{
  return MEMORY[0x1E0CFC5D8]();
}

uint64_t CV3DSLAMConfigSetMapFromCFData()
{
  return MEMORY[0x1E0CFC5E0]();
}

uint64_t CV3DSLAMConfigSetMappingDirectory()
{
  return MEMORY[0x1E0CFC5E8]();
}

uint64_t CV3DSLAMConfigSetRelocalizationEnabled()
{
  return MEMORY[0x1E0CFC5F0]();
}

uint64_t CV3DSLAMConfigUseDeterministicMode()
{
  return MEMORY[0x1E0CFC5F8]();
}

uint64_t CV3DSLAMConfigUseHWFeaturePoints()
{
  return MEMORY[0x1E0CFC600]();
}

uint64_t CV3DSLAMConfigUseSWProxyFeaturePoints()
{
  return MEMORY[0x1E0CFC608]();
}

uint64_t CV3DSLAMIsFatalError()
{
  return MEMORY[0x1E0CFC610]();
}

uint64_t CV3DSLAMJasperPointCloudCreateFromADPointCloud()
{
  return MEMORY[0x1E0CFC618]();
}

uint64_t CV3DSLAMJasperPointCloudRelease()
{
  return MEMORY[0x1E0CFC620]();
}

uint64_t CV3DSLAMJasperPointCloudSetProjectorMode()
{
  return MEMORY[0x1E0CFC628]();
}

uint64_t CV3DSLAMSessionAddAnchor()
{
  return MEMORY[0x1E0CFC630]();
}

uint64_t CV3DSLAMSessionClearMap()
{
  return MEMORY[0x1E0CFC638]();
}

uint64_t CV3DSLAMSessionCopyJasperCameraCalibration()
{
  return MEMORY[0x1E0CFC640]();
}

uint64_t CV3DSLAMSessionCreate()
{
  return MEMORY[0x1E0CFC648]();
}

uint64_t CV3DSLAMSessionCreateCMPoseAnchorData()
{
  return MEMORY[0x1E0CFC650]();
}

uint64_t CV3DSLAMSessionDeregisterNewStateBlock()
{
  return MEMORY[0x1E0CFC658]();
}

uint64_t CV3DSLAMSessionGetCMOjbectAnchorMetadata()
{
  return MEMORY[0x1E0CFC660]();
}

uint64_t CV3DSLAMSessionGetCMPoseAnchorTransformation()
{
  return MEMORY[0x1E0CFC668]();
}

uint64_t CV3DSLAMSessionGetSessionID()
{
  return MEMORY[0x1E0CFC670]();
}

uint64_t CV3DSLAMSessionPushAccel()
{
  return MEMORY[0x1E0CFC678]();
}

uint64_t CV3DSLAMSessionPushCMData()
{
  return MEMORY[0x1E0CFC680]();
}

uint64_t CV3DSLAMSessionPushCamera()
{
  return MEMORY[0x1E0CFC688]();
}

uint64_t CV3DSLAMSessionPushGyro()
{
  return MEMORY[0x1E0CFC690]();
}

uint64_t CV3DSLAMSessionPushJasperPointCloud()
{
  return MEMORY[0x1E0CFC698]();
}

uint64_t CV3DSLAMSessionRegisterNewStateBlock()
{
  return MEMORY[0x1E0CFC6A0]();
}

uint64_t CV3DSLAMSessionRelease()
{
  return MEMORY[0x1E0CFC6A8]();
}

uint64_t CV3DSLAMSessionRemoveAnchor()
{
  return MEMORY[0x1E0CFC6B0]();
}

uint64_t CV3DSLAMSessionRetain()
{
  return MEMORY[0x1E0CFC6B8]();
}

uint64_t CV3DSLAMSessionSerializeMap()
{
  return MEMORY[0x1E0CFC6C0]();
}

uint64_t CV3DSLAMSessionSetCMDataBlock()
{
  return MEMORY[0x1E0CFC6C8]();
}

uint64_t CV3DSLAMSessionSetLineEnablementPolicy()
{
  return MEMORY[0x1E0CFC6D0]();
}

uint64_t CV3DSLAMSessionSetOutputMapPoints()
{
  return MEMORY[0x1E0CFC6D8]();
}

uint64_t CV3DSLAMSessionWait()
{
  return MEMORY[0x1E0CFC6E0]();
}

uint64_t CV3DSLAMSetErrorBlock()
{
  return MEMORY[0x1E0CFC6E8]();
}

uint64_t CV3DSLAMSetNewStateBlock()
{
  return MEMORY[0x1E0CFC6F0]();
}

uint64_t CV3DSLAMStateConvertPoseToCameraFrame()
{
  return MEMORY[0x1E0CFC6F8]();
}

uint64_t CV3DSLAMStateCopyCameraFrameRates()
{
  return MEMORY[0x1E0CFC700]();
}

uint64_t CV3DSLAMStateCopyCurrentTrackingCameraIds()
{
  return MEMORY[0x1E0CFC708]();
}

uint64_t CV3DSLAMStateCopyNewAnchors()
{
  return MEMORY[0x1E0CFC710]();
}

uint64_t CV3DSLAMStateCopyRemovedAnchors()
{
  return MEMORY[0x1E0CFC718]();
}

uint64_t CV3DSLAMStateCopyUpdatedAnchors()
{
  return MEMORY[0x1E0CFC720]();
}

uint64_t CV3DSLAMStateCreateFromData()
{
  return MEMORY[0x1E0CFC728]();
}

uint64_t CV3DSLAMStateGetCameraSwitchingStatistics()
{
  return MEMORY[0x1E0CFC730]();
}

uint64_t CV3DSLAMStateGetCameraTrackRatiosPerCamera()
{
  return MEMORY[0x1E0CFC738]();
}

uint64_t CV3DSLAMStateGetCollaborativeMapStatistics()
{
  return MEMORY[0x1E0CFC740]();
}

uint64_t CV3DSLAMStateGetExternalAnchorNames()
{
  return MEMORY[0x1E0CFC748]();
}

uint64_t CV3DSLAMStateGetLineCloud()
{
  return MEMORY[0x1E0CFC750]();
}

uint64_t CV3DSLAMStateGetMapKeyFrameQuality()
{
  return MEMORY[0x1E0CFC758]();
}

uint64_t CV3DSLAMStateGetMapMergeStats()
{
  return MEMORY[0x1E0CFC760]();
}

uint64_t CV3DSLAMStateGetMapSize()
{
  return MEMORY[0x1E0CFC768]();
}

uint64_t CV3DSLAMStateGetNumberOfVOToVIOStateTransitions()
{
  return MEMORY[0x1E0CFC770]();
}

uint64_t CV3DSLAMStateGetOldestStateCovarianceMatrices()
{
  return MEMORY[0x1E0CFC778]();
}

uint64_t CV3DSLAMStateGetPointCloud()
{
  return MEMORY[0x1E0CFC780]();
}

uint64_t CV3DSLAMStateGetPoseInCameraFrame()
{
  return MEMORY[0x1E0CFC788]();
}

uint64_t CV3DSLAMStateGetRelocalizationTimestamp()
{
  return MEMORY[0x1E0CFC790]();
}

uint64_t CV3DSLAMStateGetSLAMMode()
{
  return MEMORY[0x1E0CFC798]();
}

uint64_t CV3DSLAMStateGetStatus()
{
  return MEMORY[0x1E0CFC7A0]();
}

uint64_t CV3DSLAMStateGetTimestamp()
{
  return MEMORY[0x1E0CFC7A8]();
}

uint64_t CV3DSLAMStateGetVisualSLAMState()
{
  return MEMORY[0x1E0CFC7B0]();
}

uint64_t CV3DSLAMStateIsGlobalRelocalization()
{
  return MEMORY[0x1E0CFC7B8]();
}

uint64_t CV3DSLAMStateIsInitFinished()
{
  return MEMORY[0x1E0CFC7C0]();
}

uint64_t CV3DSLAMStateIsPoseLocked()
{
  return MEMORY[0x1E0CFC7C8]();
}

uint64_t CV3DSLAMStateNumReinit()
{
  return MEMORY[0x1E0CFC7D0]();
}

uint64_t CV3DSLAMStateRelease()
{
  return MEMORY[0x1E0CFC7D8]();
}

uint64_t CV3DSLAMStateRelocalizationEvent()
{
  return MEMORY[0x1E0CFC7E0]();
}

uint64_t CV3DSLAMStateRelocalizationSucceeded()
{
  return MEMORY[0x1E0CFC7E8]();
}

uint64_t CV3DSLAMStateRetain()
{
  return MEMORY[0x1E0CFC7F0]();
}

uint64_t CV3DSLAMStateSerializeToData()
{
  return MEMORY[0x1E0CFC7F8]();
}

uint64_t CV3DSLAMStateShouldUseVisualSLAM()
{
  return MEMORY[0x1E0CFC800]();
}

uint64_t CV3DSLAMStateSnapshotCreate()
{
  return MEMORY[0x1E0CFC808]();
}

uint64_t CV3DSLAMStateSnapshotCreateSLAMState()
{
  return MEMORY[0x1E0CFC810]();
}

uint64_t CV3DSLAMStateSnapshotGetPose()
{
  return MEMORY[0x1E0CFC818]();
}

uint64_t CV3DSLAMStateSnapshotRelease()
{
  return MEMORY[0x1E0CFC820]();
}

uint64_t CV3DSLAMStateWasTrackingMap()
{
  return MEMORY[0x1E0CFC828]();
}

uint64_t CV3DSurfaceDetectionCreateWithArgs()
{
  return MEMORY[0x1E0CFC830]();
}

uint64_t CV3DSurfaceDetectionDefaultParameters()
{
  return MEMORY[0x1E0CFC838]();
}

uint64_t CV3DSurfaceDetectionRelease()
{
  return MEMORY[0x1E0CFC840]();
}

uint64_t CV3DSurfaceDetectionResultRelease()
{
  return MEMORY[0x1E0CFC848]();
}

uint64_t CV3DSurfaceDetectionSingleShotSurfaces()
{
  return MEMORY[0x1E0CFC850]();
}

uint64_t CV3DUpdateHitTestResultPose()
{
  return MEMORY[0x1E0CFC858]();
}

uint64_t CV3DVIOAddCameraCalibrationToDictionaryV2()
{
  return MEMORY[0x1E0CFC860]();
}

uint64_t CV3DVIOAlignAndMergeMaps()
{
  return MEMORY[0x1E0CFC868]();
}

uint64_t CV3DVIOCreateKeyframesFromMap()
{
  return MEMORY[0x1E0CFC870]();
}

uint64_t CV3DVIOCreatePointsFromMap()
{
  return MEMORY[0x1E0CFC878]();
}

uint64_t CV3DVIOExtractObjectMap()
{
  return MEMORY[0x1E0CFC880]();
}

uint64_t CV3DVIOGetMapBounds()
{
  return MEMORY[0x1E0CFC888]();
}

uint64_t CV3DVIOIsVideoModeSupported()
{
  return MEMORY[0x1E0CFC890]();
}

uint64_t CV3PosePredictionInitialize()
{
  return MEMORY[0x1E0CFC898]();
}

uint64_t CVAFaceTrackingCopySemantics()
{
  return MEMORY[0x1E0CFCC00]();
}

uint64_t CVAFaceTrackingCreate()
{
  return MEMORY[0x1E0CFCC08]();
}

uint64_t CVAFaceTrackingGetErrorDescription()
{
  return MEMORY[0x1E0CFCC10]();
}

uint64_t CVAFaceTrackingMaximumNumberOfTrackedFaces()
{
  return MEMORY[0x1E0CFCC18]();
}

uint64_t CVAFaceTrackingProcess()
{
  return MEMORY[0x1E0CFCC28]();
}

CFTypeRef CVBufferCopyAttachment(CVBufferRef buffer, CFStringRef key, CVAttachmentMode *attachmentMode)
{
  return (CFTypeRef)MEMORY[0x1E0CA8900](buffer, key, attachmentMode);
}

CFDictionaryRef CVBufferCopyAttachments(CVBufferRef buffer, CVAttachmentMode attachmentMode)
{
  return (CFDictionaryRef)MEMORY[0x1E0CA8908](buffer, *(_QWORD *)&attachmentMode);
}

void CVBufferPropagateAttachments(CVBufferRef sourceBuffer, CVBufferRef destinationBuffer)
{
  MEMORY[0x1E0CA8928](sourceBuffer, destinationBuffer);
}

void CVBufferRelease(CVBufferRef buffer)
{
  MEMORY[0x1E0CA8930](buffer);
}

CVBufferRef CVBufferRetain(CVBufferRef buffer)
{
  return (CVBufferRef)MEMORY[0x1E0CA8948](buffer);
}

void CVBufferSetAttachment(CVBufferRef buffer, CFStringRef key, CFTypeRef value, CVAttachmentMode attachmentMode)
{
  MEMORY[0x1E0CA8950](buffer, key, value, *(_QWORD *)&attachmentMode);
}

uint64_t CVDataBufferGetIOSurface()
{
  return MEMORY[0x1E0CA8990]();
}

CVReturn CVPixelBufferCreate(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8A98](allocator, width, height, *(_QWORD *)&pixelFormatType, pixelBufferAttributes, pixelBufferOut);
}

CVReturn CVPixelBufferCreateWithBytes(CFAllocatorRef allocator, size_t width, size_t height, OSType pixelFormatType, void *baseAddress, size_t bytesPerRow, CVPixelBufferReleaseBytesCallback releaseCallback, void *releaseRefCon, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8AB8](allocator, width, height, *(_QWORD *)&pixelFormatType, baseAddress, bytesPerRow, releaseCallback, releaseRefCon);
}

CVReturn CVPixelBufferCreateWithIOSurface(CFAllocatorRef allocator, IOSurfaceRef surface, CFDictionaryRef pixelBufferAttributes, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8AC0](allocator, surface, pixelBufferAttributes, pixelBufferOut);
}

void *__cdecl CVPixelBufferGetBaseAddress(CVPixelBufferRef pixelBuffer)
{
  return (void *)MEMORY[0x1E0CA8AE0](pixelBuffer);
}

void *__cdecl CVPixelBufferGetBaseAddressOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return (void *)MEMORY[0x1E0CA8AE8](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetBytesPerRow(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8AF8](pixelBuffer);
}

size_t CVPixelBufferGetBytesPerRowOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B00](pixelBuffer, planeIndex);
}

size_t CVPixelBufferGetDataSize(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B08](pixelBuffer);
}

size_t CVPixelBufferGetHeight(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B20](pixelBuffer);
}

size_t CVPixelBufferGetHeightOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B28](pixelBuffer, planeIndex);
}

IOSurfaceRef CVPixelBufferGetIOSurface(CVPixelBufferRef pixelBuffer)
{
  return (IOSurfaceRef)MEMORY[0x1E0CA8B30](pixelBuffer);
}

OSType CVPixelBufferGetPixelFormatType(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B38](pixelBuffer);
}

size_t CVPixelBufferGetPlaneCount(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B40](pixelBuffer);
}

size_t CVPixelBufferGetWidth(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B50](pixelBuffer);
}

size_t CVPixelBufferGetWidthOfPlane(CVPixelBufferRef pixelBuffer, size_t planeIndex)
{
  return MEMORY[0x1E0CA8B58](pixelBuffer, planeIndex);
}

Boolean CVPixelBufferIsPlanar(CVPixelBufferRef pixelBuffer)
{
  return MEMORY[0x1E0CA8B68](pixelBuffer);
}

CVReturn CVPixelBufferLockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags lockFlags)
{
  return MEMORY[0x1E0CA8B70](pixelBuffer, lockFlags);
}

CVReturn CVPixelBufferPoolCreate(CFAllocatorRef allocator, CFDictionaryRef poolAttributes, CFDictionaryRef pixelBufferAttributes, CVPixelBufferPoolRef *poolOut)
{
  return MEMORY[0x1E0CA8B78](allocator, poolAttributes, pixelBufferAttributes, poolOut);
}

CVReturn CVPixelBufferPoolCreatePixelBuffer(CFAllocatorRef allocator, CVPixelBufferPoolRef pixelBufferPool, CVPixelBufferRef *pixelBufferOut)
{
  return MEMORY[0x1E0CA8B80](allocator, pixelBufferPool, pixelBufferOut);
}

CFDictionaryRef CVPixelBufferPoolGetPixelBufferAttributes(CVPixelBufferPoolRef pool)
{
  return (CFDictionaryRef)MEMORY[0x1E0CA8BA8](pool);
}

void CVPixelBufferPoolRelease(CVPixelBufferPoolRef pixelBufferPool)
{
  MEMORY[0x1E0CA8BC8](pixelBufferPool);
}

void CVPixelBufferRelease(CVPixelBufferRef texture)
{
  MEMORY[0x1E0CA8BF0](texture);
}

CVPixelBufferRef CVPixelBufferRetain(CVPixelBufferRef texture)
{
  return (CVPixelBufferRef)MEMORY[0x1E0CA8BF8](texture);
}

CVReturn CVPixelBufferUnlockBaseAddress(CVPixelBufferRef pixelBuffer, CVPixelBufferLockFlags unlockFlags)
{
  return MEMORY[0x1E0CA8C00](pixelBuffer, unlockFlags);
}

uint64_t CoreIKCreateAltruisticSolverInstance()
{
  return MEMORY[0x1E0D16AE0]();
}

uint64_t CoreIKDestroySolver()
{
  return MEMORY[0x1E0D16AE8]();
}

uint64_t CoreIKSolverGetTargetBufferSize()
{
  return MEMORY[0x1E0D16AF0]();
}

uint64_t CoreIKSolverGetTargetName()
{
  return MEMORY[0x1E0D16AF8]();
}

uint64_t CoreIKSolverGetTargetParentName()
{
  return MEMORY[0x1E0D16B00]();
}

uint64_t CreateABPK3DLiftingAlgorithm()
{
  return MEMORY[0x1E0CF7818]();
}

uint64_t FigCFDictionaryGetCGRectIfPresent()
{
  return MEMORY[0x1E0C9FBB8]();
}

uint64_t IOHIDEventGetFloatValue()
{
  return MEMORY[0x1E0CBB128]();
}

uint64_t IOHIDEventGetTimeStamp()
{
  return MEMORY[0x1E0CBB158]();
}

uint64_t IOHIDEventGetType()
{
  return MEMORY[0x1E0CBB168]();
}

CFArrayRef IOHIDEventSystemClientCopyServices(IOHIDEventSystemClientRef client)
{
  return (CFArrayRef)MEMORY[0x1E0CBB1E8](client);
}

uint64_t IOHIDEventSystemClientCreateWithType()
{
  return MEMORY[0x1E0CBB1F8]();
}

uint64_t IOHIDEventSystemClientRegisterEventCallback()
{
  return MEMORY[0x1E0CBB220]();
}

uint64_t IOHIDEventSystemClientScheduleWithDispatchQueue()
{
  return MEMORY[0x1E0CBB248]();
}

uint64_t IOHIDEventSystemClientSetMatching()
{
  return MEMORY[0x1E0CBB268]();
}

uint64_t IOHIDEventSystemClientUnregisterEventCallback()
{
  return MEMORY[0x1E0CBB298]();
}

uint64_t IOHIDEventSystemClientUnscheduleFromDispatchQueue()
{
  return MEMORY[0x1E0CBB2B8]();
}

CFTypeRef IOHIDServiceClientCopyProperty(IOHIDServiceClientRef service, CFStringRef key)
{
  return (CFTypeRef)MEMORY[0x1E0CBB4B0](service, key);
}

Boolean IOHIDServiceClientSetProperty(IOHIDServiceClientRef service, CFStringRef key, CFTypeRef property)
{
  return MEMORY[0x1E0CBB4F0](service, key, property);
}

size_t IOSurfaceGetAllocSize(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB38](buffer);
}

void *__cdecl IOSurfaceGetBaseAddress(IOSurfaceRef buffer)
{
  return (void *)MEMORY[0x1E0CBBB40](buffer);
}

size_t IOSurfaceGetBytesPerElement(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB80](buffer);
}

size_t IOSurfaceGetBytesPerRow(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBB90](buffer);
}

size_t IOSurfaceGetHeight(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC28](buffer);
}

size_t IOSurfaceGetHeightOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBC38](buffer, planeIndex);
}

IOSurfaceID IOSurfaceGetID(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC48](buffer);
}

OSType IOSurfaceGetPixelFormat(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBC68](buffer);
}

int32_t IOSurfaceGetUseCount(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBCD0](buffer);
}

size_t IOSurfaceGetWidth(IOSurfaceRef buffer)
{
  return MEMORY[0x1E0CBBCE0](buffer);
}

size_t IOSurfaceGetWidthOfPlane(IOSurfaceRef buffer, size_t planeIndex)
{
  return MEMORY[0x1E0CBBCF0](buffer, planeIndex);
}

kern_return_t IOSurfaceLock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBD28](buffer, *(_QWORD *)&options, seed);
}

IOSurfaceRef IOSurfaceLookup(IOSurfaceID csid)
{
  return (IOSurfaceRef)MEMORY[0x1E0CBBD38](*(_QWORD *)&csid);
}

uint64_t IOSurfaceNotifierCreate()
{
  return MEMORY[0x1E0CBBD58]();
}

uint64_t IOSurfaceNotifierSetDispatchQueue()
{
  return MEMORY[0x1E0CBBD60]();
}

void IOSurfaceSetValue(IOSurfaceRef buffer, CFStringRef key, CFTypeRef value)
{
  MEMORY[0x1E0CBBE40](buffer, key, value);
}

kern_return_t IOSurfaceUnlock(IOSurfaceRef buffer, IOSurfaceLockOptions options, uint32_t *seed)
{
  return MEMORY[0x1E0CBBE88](buffer, *(_QWORD *)&options, seed);
}

uint64_t MGCopyAnswer()
{
  return MEMORY[0x1E0DE2B20]();
}

uint64_t MGGetBoolAnswer()
{
  return MEMORY[0x1E0DE2B50]();
}

uint64_t MGGetProductType()
{
  return MEMORY[0x1E0DE2B68]();
}

uint64_t MGGetSInt32Answer()
{
  return MEMORY[0x1E0DE2B70]();
}

uint64_t MGIsDeviceOneOfType()
{
  return MEMORY[0x1E0DE2B90]();
}

id MTLCreateSystemDefaultDevice(void)
{
  return (id)MEMORY[0x1E0CC6980]();
}

Class NSClassFromString(NSString *aClassName)
{
  return (Class)MEMORY[0x1E0CB28A0](aClassName);
}

uint64_t NSLocalizedFileSizeDescription()
{
  return MEMORY[0x1E0CB2D70]();
}

uint64_t NSPopAutoreleasePool()
{
  return MEMORY[0x1E0CB3038]();
}

uint64_t NSPushAutoreleasePool()
{
  return MEMORY[0x1E0CB3120]();
}

NSArray *__cdecl NSSearchPathForDirectoriesInDomains(NSSearchPathDirectory directory, NSSearchPathDomainMask domainMask, BOOL expandTilde)
{
  return (NSArray *)MEMORY[0x1E0CB3178](directory, domainMask, expandTilde);
}

SEL NSSelectorFromString(NSString *aSelectorName)
{
  return (SEL)MEMORY[0x1E0CB3190](aSelectorName);
}

NSString *__cdecl NSStringFromClass(Class aClass)
{
  return (NSString *)MEMORY[0x1E0CB3200](aClass);
}

NSString *__cdecl NSStringFromSelector(SEL aSelector)
{
  return (NSString *)MEMORY[0x1E0CB3230](aSelector);
}

NSString *NSTemporaryDirectory(void)
{
  return (NSString *)MEMORY[0x1E0CB3250]();
}

int32_t NSVersionOfRunTimeLibrary(const char *libraryName)
{
  return MEMORY[0x1E0C805D0](libraryName);
}

SCNetworkReachabilityRef SCNetworkReachabilityCreateWithAddress(CFAllocatorRef allocator, const sockaddr *address)
{
  return (SCNetworkReachabilityRef)MEMORY[0x1E0CE88B8](allocator, address);
}

Boolean SCNetworkReachabilityGetFlags(SCNetworkReachabilityRef target, SCNetworkReachabilityFlags *flags)
{
  return MEMORY[0x1E0CE88D8](target, flags);
}

uint64_t SetDefaultCameraCalibrationData()
{
  return MEMORY[0x1E0CFC8A0]();
}

uint64_t SetDefaultImuCalibrationData()
{
  return MEMORY[0x1E0CFC8A8]();
}

uint64_t SetDefaultJasperCalibrationData()
{
  return MEMORY[0x1E0CFC8B0]();
}

OSStatus VTPixelRotationSessionCreate(CFAllocatorRef allocator, VTPixelRotationSessionRef *pixelRotationSessionOut)
{
  return MEMORY[0x1E0CECCD8](allocator, pixelRotationSessionOut);
}

void VTPixelRotationSessionInvalidate(VTPixelRotationSessionRef session)
{
  MEMORY[0x1E0CECCE8](session);
}

OSStatus VTPixelRotationSessionRotateImage(VTPixelRotationSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1E0CECCF0](session, sourceBuffer, destinationBuffer);
}

OSStatus VTPixelTransferSessionCreate(CFAllocatorRef allocator, VTPixelTransferSessionRef *pixelTransferSessionOut)
{
  return MEMORY[0x1E0CECD18](allocator, pixelTransferSessionOut);
}

void VTPixelTransferSessionInvalidate(VTPixelTransferSessionRef session)
{
  MEMORY[0x1E0CECD28](session);
}

OSStatus VTPixelTransferSessionTransferImage(VTPixelTransferSessionRef session, CVPixelBufferRef sourceBuffer, CVPixelBufferRef destinationBuffer)
{
  return MEMORY[0x1E0CECD38](session, sourceBuffer, destinationBuffer);
}

OSStatus VTSessionSetProperties(VTSessionRef session, CFDictionaryRef propertyDictionary)
{
  return MEMORY[0x1E0CECD78](session, propertyDictionary);
}

OSStatus VTSessionSetProperty(VTSessionRef session, CFStringRef propertyKey, CFTypeRef propertyValue)
{
  return MEMORY[0x1E0CECD80](session, propertyKey, propertyValue);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x1E0C80948](a1, *(_QWORD *)&a2);
}

uint64_t _CFRunLoopSetPerCalloutAutoreleasepoolEnabled()
{
  return MEMORY[0x1E0C9A488]();
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x1E0C80A20](exception_object);
}

void cnnavigation::ENUToECEFJacobian::~ENUToECEFJacobian(cnnavigation::ENUToECEFJacobian *this)
{
  MEMORY[0x1E0D17540](this);
}

uint64_t cnnavigation::ECEFToENU()
{
  return MEMORY[0x1E0D17548]();
}

uint64_t cnnavigation::ECEFToLLA()
{
  return MEMORY[0x1E0D17550]();
}

uint64_t cnnavigation::ENUToECEF()
{
  return MEMORY[0x1E0D17558]();
}

{
  return MEMORY[0x1E0D17560]();
}

uint64_t cnnavigation::LLAToECEF()
{
  return MEMORY[0x1E0D17568]();
}

uint64_t cva::imageViewFromPixelBuffer<cva::Matrix<unsigned char,4u,1u,false>>()
{
  return off_1E666E7B0();
}

uint64_t cva::imageViewFromPixelBuffer<unsigned char>()
{
  return off_1E666E7B8();
}

uint64_t cva::Logger::logInCategory()
{
  return MEMORY[0x1E0D15580]();
}

uint64_t cva::Logger::instance(cva::Logger *this)
{
  return MEMORY[0x1E0D15590](this);
}

uint64_t cva::VecLib<float>::gemm()
{
  return off_1E666E7D8();
}

uint64_t cva::VecLib<float>::gemv()
{
  return off_1E666E7E0();
}

uint64_t cva::vecLib::gesvd<float>()
{
  return MEMORY[0x1E0D155A0]();
}

uint64_t cva::imwrite<cva::Matrix<unsigned char,4u,1u,false>>()
{
  return MEMORY[0x1E0D155B8]();
}

uint64_t cva::imwrite<unsigned char>()
{
  return MEMORY[0x1E0D155C0]();
}

uint64_t cva::imwrite<unsigned short>()
{
  return MEMORY[0x1E0D155C8]();
}

uint64_t std::stringbuf::str()
{
  return MEMORY[0x1E0DE41F0]();
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x1E0DE4248](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x1E0DE4258](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const std::string *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4280](this, a2);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x1E0DE4288](this, a2);
}

std::runtime_error *__cdecl std::runtime_error::runtime_error(std::runtime_error *this, const char *a2)
{
  return (std::runtime_error *)MEMORY[0x1E0DE4308](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x1E0DE4388](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x1E0DE43E8](__n);
}

void std::string::resize(std::string *this, std::string::size_type __n, std::string::value_type __c)
{
  MEMORY[0x1E0DE4480](this, __n, __c);
}

void std::string::push_back(std::string *this, std::string::value_type __c)
{
  MEMORY[0x1E0DE44B8](this, __c);
}

std::string *__cdecl std::string::basic_string(std::string *this, const std::string *__str, std::string::size_type __pos, std::string::size_type __n, std::allocator<char> *__a)
{
  return (std::string *)MEMORY[0x1E0DE44C8](this, __str, __pos, __n, __a);
}

std::string *__cdecl std::string::operator=(std::string *this, const std::string *__str)
{
  return (std::string *)MEMORY[0x1E0DE44D8](this, __str);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x1E0DE4590]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x1E0DE4598]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x1E0DE45A8]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x1E0DE45B0]();
}

uint64_t std::istream::peek()
{
  return MEMORY[0x1E0DE45C8]();
}

uint64_t std::istream::ignore()
{
  return MEMORY[0x1E0DE4600]();
}

uint64_t std::istream::sentry::sentry()
{
  return MEMORY[0x1E0DE4608]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x1E0DE4628]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x1E0DE4640]();
}

{
  return MEMORY[0x1E0DE4648]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x1E0DE4698]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x1E0DE46A0]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x1E0DE46A8]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x1E0DE46B0]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x1E0DE46B8]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x1E0DE46C8]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x1E0DE46E8]();
}

{
  return MEMORY[0x1E0DE4700]();
}

{
  return MEMORY[0x1E0DE4708]();
}

{
  return MEMORY[0x1E0DE4718]();
}

uint64_t std::streambuf::basic_streambuf()
{
  return MEMORY[0x1E0DE47E0]();
}

uint64_t std::streambuf::~streambuf()
{
  return MEMORY[0x1E0DE47E8]();
}

void std::__shared_weak_count::__release_weak(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE48F0](this);
}

void std::__shared_weak_count::~__shared_weak_count(std::__shared_weak_count *this)
{
  MEMORY[0x1E0DE4900](this);
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x1E0DE4B98](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x1E0DE4C50](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x1E0DE4C68](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x1E0DE4C80](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x1E0DE4D28]();
}

void std::exception::~exception(std::exception *this)
{
  MEMORY[0x1E0DE4DD8](this);
}

void std::terminate(void)
{
  MEMORY[0x1E0DE4E18]();
}

uint64_t operator delete[]()
{
  return off_1E666EA68();
}

void operator delete(void *__p)
{
  off_1E666EA70(__p);
}

uint64_t operator delete()
{
  return off_1E666EA78();
}

uint64_t operator new[]()
{
  return off_1E666EA80();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_1E666EA88(__sz);
}

uint64_t operator new()
{
  return off_1E666EA90();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x1E0C80A58](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x1E0DE5068](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x1E0C80A98](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x1E0DE5080](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x1E0DE5098]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x1E0DE50A0](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x1E0DE50B0](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x1E0DE50B8](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x1E0DE50C0](a1);
}

void __cxa_rethrow(void)
{
  MEMORY[0x1E0DE50D0]();
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x1E0DE50D8](a1, lptinfo, a3);
}

double __exp10(double a1)
{
  double result;

  MEMORY[0x1E0C80AC8](a1);
  return result;
}

float __exp10f(float a1)
{
  float result;

  MEMORY[0x1E0C80AD0](a1);
  return result;
}

uint64_t __invert_d4()
{
  return MEMORY[0x1E0C80B20]();
}

simd_float3x3 __invert_f3(simd_float3x3 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  simd_float3x3 result;

  MEMORY[0x1E0C80B30]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2]);
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

simd_float4x4 __invert_f4(simd_float4x4 a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  simd_float4x4 result;

  MEMORY[0x1E0C80B38]((__n128)a1.columns[0], (__n128)a1.columns[1], (__n128)a1.columns[2], (__n128)a1.columns[3]);
  result.columns[3].i64[1] = v8;
  result.columns[3].i64[0] = v7;
  result.columns[2].i64[1] = v6;
  result.columns[2].i64[0] = v5;
  result.columns[1].i64[1] = v4;
  result.columns[1].i64[0] = v3;
  result.columns[0].i64[1] = v2;
  result.columns[0].i64[0] = v1;
  return result;
}

uint64_t __memcpy_chk()
{
  return MEMORY[0x1E0C80B68]();
}

uint64_t __memset_chk()
{
  return MEMORY[0x1E0C80B78]();
}

uint64_t __realtime_assert_rtn()
{
  return MEMORY[0x1E0DE8478]();
}

__double2 __sincos_stret(double a1)
{
  double v1;
  double v2;
  __double2 result;

  MEMORY[0x1E0C80BC8](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

__float2 __sincosf_stret(float a1)
{
  float v1;
  float v2;
  __float2 result;

  MEMORY[0x1E0C80BD0](a1);
  result.__cosval = v2;
  result.__sinval = v1;
  return result;
}

const mach_header *__cdecl _dyld_get_image_header(uint32_t image_index)
{
  return (const mach_header *)MEMORY[0x1E0C80E60](*(_QWORD *)&image_index);
}

uint32_t _dyld_image_count(void)
{
  return MEMORY[0x1E0C80EB8]();
}

os_activity_t _os_activity_create(void *dso, const char *description, os_activity_t activity, os_activity_flag_t flags)
{
  return (os_activity_t)MEMORY[0x1E0C80FC0](dso, description, activity, *(_QWORD *)&flags);
}

void _os_log_error_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81038](dso, log, type, format, buf, *(_QWORD *)&size);
}

void _os_log_impl(void *dso, os_log_t log, os_log_type_t type, const char *format, uint8_t *buf, uint32_t size)
{
  MEMORY[0x1E0C81048](dso, log, type, format, buf, *(_QWORD *)&size);
}

uint64_t _os_log_send_and_compose_impl()
{
  return MEMORY[0x1E0C81068]();
}

uint64_t _sl_dlopen()
{
  return MEMORY[0x1E0DA88F0]();
}

void abort(void)
{
  MEMORY[0x1E0C813A8]();
}

uint64_t abort_report_np()
{
  return MEMORY[0x1E0C813B0]();
}

long double acos(long double __x)
{
  long double result;

  MEMORY[0x1E0C81500](__x);
  return result;
}

float acosf(float a1)
{
  float result;

  MEMORY[0x1E0C81508](a1);
  return result;
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x1E0C81588](*(_QWORD *)&__upper_bound);
}

uint64_t archive_entry_filetype()
{
  return MEMORY[0x1E0DE3DC0]();
}

uint64_t archive_entry_free()
{
  return MEMORY[0x1E0DE3DC8]();
}

uint64_t archive_entry_new()
{
  return MEMORY[0x1E0DE3DD0]();
}

uint64_t archive_entry_pathname()
{
  return MEMORY[0x1E0DE3DD8]();
}

uint64_t archive_entry_set_atime()
{
  return MEMORY[0x1E0DE3DF0]();
}

uint64_t archive_entry_set_birthtime()
{
  return MEMORY[0x1E0DE3DF8]();
}

uint64_t archive_entry_set_ctime()
{
  return MEMORY[0x1E0DE3E00]();
}

uint64_t archive_entry_set_filetype()
{
  return MEMORY[0x1E0DE3E08]();
}

uint64_t archive_entry_set_mtime()
{
  return MEMORY[0x1E0DE3E10]();
}

uint64_t archive_entry_set_pathname()
{
  return MEMORY[0x1E0DE3E18]();
}

uint64_t archive_entry_set_perm()
{
  return MEMORY[0x1E0DE3E20]();
}

uint64_t archive_entry_set_size()
{
  return MEMORY[0x1E0DE3E28]();
}

uint64_t archive_error_string()
{
  return MEMORY[0x1E0DE3E60]();
}

uint64_t archive_read_data()
{
  return MEMORY[0x1E0DE3E80]();
}

uint64_t archive_read_free()
{
  return MEMORY[0x1E0DE3EF8]();
}

uint64_t archive_read_new()
{
  return MEMORY[0x1E0DE3F00]();
}

uint64_t archive_read_next_header()
{
  return MEMORY[0x1E0DE3F08]();
}

uint64_t archive_read_open_filename()
{
  return MEMORY[0x1E0DE3F28]();
}

uint64_t archive_read_open_memory()
{
  return MEMORY[0x1E0DE3F30]();
}

uint64_t archive_read_support_filter_compress()
{
  return MEMORY[0x1E0DE3F58]();
}

uint64_t archive_read_support_format_zip()
{
  return MEMORY[0x1E0DE3F90]();
}

uint64_t archive_set_error()
{
  return MEMORY[0x1E0DE3FA0]();
}

uint64_t archive_write_data()
{
  return MEMORY[0x1E0DE3FC8]();
}

uint64_t archive_write_free()
{
  return MEMORY[0x1E0DE4000]();
}

uint64_t archive_write_header()
{
  return MEMORY[0x1E0DE4008]();
}

uint64_t archive_write_new()
{
  return MEMORY[0x1E0DE4010]();
}

uint64_t archive_write_open()
{
  return MEMORY[0x1E0DE4018]();
}

uint64_t archive_write_open_filename()
{
  return MEMORY[0x1E0DE4028]();
}

uint64_t archive_write_set_format_zip()
{
  return MEMORY[0x1E0DE4068]();
}

float asinf(float a1)
{
  float result;

  MEMORY[0x1E0C815A0](a1);
  return result;
}

long double atan(long double __x)
{
  long double result;

  MEMORY[0x1E0C81618](__x);
  return result;
}

long double atan2(long double __y, long double __x)
{
  long double result;

  MEMORY[0x1E0C81620](__y, __x);
  return result;
}

float atan2f(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C81628](a1, a2);
  return result;
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x1E0C81758](a1, a2);
}

objc_property_t *__cdecl class_copyPropertyList(Class cls, unsigned int *outCount)
{
  return (objc_property_t *)MEMORY[0x1E0DE7A80](cls, outCount);
}

id class_createInstance(Class cls, size_t extraBytes)
{
  return (id)MEMORY[0x1E0DE7A90](cls, extraBytes);
}

Ivar class_getInstanceVariable(Class cls, const char *name)
{
  return (Ivar)MEMORY[0x1E0DE7AB8](cls, name);
}

IMP class_getMethodImplementation(Class cls, SEL name)
{
  return (IMP)MEMORY[0x1E0DE7AC0](cls, name);
}

objc_property_t class_getProperty(Class cls, const char *name)
{
  return (objc_property_t)MEMORY[0x1E0DE7AD0](cls, name);
}

Class class_getSuperclass(Class cls)
{
  return (Class)MEMORY[0x1E0DE7AD8](cls);
}

__uint64_t clock_gettime_nsec_np(clockid_t __clock_id)
{
  return MEMORY[0x1E0C82670](*(_QWORD *)&__clock_id);
}

long double cos(long double __x)
{
  long double result;

  MEMORY[0x1E0C82B40](__x);
  return result;
}

float cosf(float a1)
{
  float result;

  MEMORY[0x1E0C82B48](a1);
  return result;
}

void dispatch_activate(dispatch_object_t object)
{
  MEMORY[0x1E0C82BC0](object);
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82BC8](when, queue, block);
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BE8](queue);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  MEMORY[0x1E0C82BF8](queue);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82C00](queue, block);
}

void *__cdecl dispatch_get_specific(const void *key)
{
  return (void *)MEMORY[0x1E0C82D08](key);
}

dispatch_group_t dispatch_group_create(void)
{
  return (dispatch_group_t)MEMORY[0x1E0C82D20]();
}

void dispatch_group_enter(dispatch_group_t group)
{
  MEMORY[0x1E0C82D28](group);
}

void dispatch_group_leave(dispatch_group_t group)
{
  MEMORY[0x1E0C82D30](group);
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82D48](group, timeout);
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  MEMORY[0x1E0C82E08](predicate, block);
}

uint64_t dispatch_pthread_root_queue_create()
{
  return MEMORY[0x1E0C82E18]();
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E20](attr);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E28](attr, frequency);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  return (dispatch_queue_attr_t)MEMORY[0x1E0C82E38](attr, *(_QWORD *)&qos_class, *(_QWORD *)&relative_priority);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E48](label, attr);
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)MEMORY[0x1E0C82E50](label, attr, target);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  return (const char *)MEMORY[0x1E0C82E58](queue);
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  MEMORY[0x1E0C82E80](queue, key, context, destructor);
}

void dispatch_resume(dispatch_object_t object)
{
  MEMORY[0x1E0C82EA0](object);
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  return (dispatch_semaphore_t)MEMORY[0x1E0C82EB8](value);
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  return MEMORY[0x1E0C82EC8](dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  return MEMORY[0x1E0C82ED8](dsema, timeout);
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  MEMORY[0x1E0C82F08](object, queue);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  MEMORY[0x1E0C82F10](source);
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  return (dispatch_source_t)MEMORY[0x1E0C82F20](type, handle, mask, queue);
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  MEMORY[0x1E0C82F58](source, handler);
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  MEMORY[0x1E0C82F78](source, start, interval, leeway);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x1E0C82F90](queue, block);
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  return MEMORY[0x1E0C82FB8](when, delta);
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  return (dispatch_workloop_t)MEMORY[0x1E0C82FE0](label);
}

uint64_t dispatch_workloop_set_qos_class_floor()
{
  return MEMORY[0x1E0C83008]();
}

void *__cdecl dlopen(const char *__path, int __mode)
{
  return (void *)MEMORY[0x1E0C83040](__path, *(_QWORD *)&__mode);
}

void *__cdecl dlsym(void *__handle, const char *__symbol)
{
  return (void *)MEMORY[0x1E0C83050](__handle, __symbol);
}

uint64_t dyld_image_header_containing_address()
{
  return MEMORY[0x1E0C830F8]();
}

uint64_t dyld_program_sdk_at_least()
{
  return MEMORY[0x1E0C83158]();
}

uint64_t espresso_context_destroy()
{
  return MEMORY[0x1E0D1FF10]();
}

uint64_t espresso_context_set_low_precision_accumulation()
{
  return MEMORY[0x1E0D1FF28]();
}

uint64_t espresso_create_context()
{
  return MEMORY[0x1E0D1FF38]();
}

uint64_t espresso_create_plan()
{
  return MEMORY[0x1E0D1FF40]();
}

uint64_t espresso_network_bind_buffer()
{
  return MEMORY[0x1E0D1FFB8]();
}

uint64_t espresso_network_bind_direct_cvpixelbuffer()
{
  return MEMORY[0x1E0D1FFD8]();
}

uint64_t espresso_network_bind_input_vimagebuffer_bgra8()
{
  return MEMORY[0x1E0D1FFF0]();
}

uint64_t espresso_network_declare_input()
{
  return MEMORY[0x1E0D20038]();
}

uint64_t espresso_network_declare_output()
{
  return MEMORY[0x1E0D20040]();
}

uint64_t espresso_network_get_version()
{
  return MEMORY[0x1E0D20058]();
}

uint64_t espresso_network_query_blob_dimensions()
{
  return MEMORY[0x1E0D20060]();
}

uint64_t espresso_network_select_configuration()
{
  return MEMORY[0x1E0D20080]();
}

uint64_t espresso_plan_add_network()
{
  return MEMORY[0x1E0D200B0]();
}

uint64_t espresso_plan_build()
{
  return MEMORY[0x1E0D200C8]();
}

uint64_t espresso_plan_build_clean()
{
  return MEMORY[0x1E0D200D8]();
}

uint64_t espresso_plan_destroy()
{
  return MEMORY[0x1E0D200E8]();
}

uint64_t espresso_plan_execute_sync()
{
  return MEMORY[0x1E0D20100]();
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x1E0C83280](__x);
  return result;
}

long double exp2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83288](__x);
  return result;
}

float expf(float a1)
{
  float result;

  MEMORY[0x1E0C83298](a1);
  return result;
}

int fflush(FILE *a1)
{
  return MEMORY[0x1E0C83370](a1);
}

int fileno(FILE *a1)
{
  return MEMORY[0x1E0C833B0](a1);
}

long double fmod(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C83440](__x, __y);
  return result;
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x1E0C83478](a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x1E0C83490](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x1E0C834A8](a1);
}

long double hypot(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C838E8](__x, __y);
  return result;
}

int isatty(int a1)
{
  return MEMORY[0x1E0C839A8](*(_QWORD *)&a1);
}

uint64_t kdebug_trace()
{
  return MEMORY[0x1E0C83A20]();
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BB8](__x);
  return result;
}

long double log10(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BC0](__x);
  return result;
}

long double log2(long double __x)
{
  long double result;

  MEMORY[0x1E0C83BE8](__x);
  return result;
}

float log2f(float a1)
{
  float result;

  MEMORY[0x1E0C83BF0](a1);
  return result;
}

float logf(float a1)
{
  float result;

  MEMORY[0x1E0C83C00](a1);
  return result;
}

uint64_t mach_absolute_time(void)
{
  return MEMORY[0x1E0C83C50]();
}

uint64_t mach_get_times()
{
  return MEMORY[0x1E0C83C88]();
}

kern_return_t mach_timebase_info(mach_timebase_info_t info)
{
  return MEMORY[0x1E0C83DB8](info);
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83EF8](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F00](size, type_id);
}

int malloc_type_posix_memalign(void **memptr, size_t alignment, size_t size, malloc_type_id_t type_id)
{
  return MEMORY[0x1E0C83F08](memptr, alignment, size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x1E0C83F10](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x1E0C84078](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x1E0C84088](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x1E0C84098](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x1E0C840B0](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x1E0C840B8](__b, __pattern16, __len);
}

uint32_t notify_cancel(int token)
{
  return MEMORY[0x1E0C843D8](*(_QWORD *)&token);
}

uint32_t notify_get_state(int token, uint64_t *state64)
{
  return MEMORY[0x1E0C843E8](*(_QWORD *)&token, state64);
}

uint32_t notify_register_dispatch(const char *name, int *out_token, dispatch_queue_t queue, notify_handler_t handler)
{
  return MEMORY[0x1E0C84408](name, out_token, queue, handler);
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x1E0DE7BA8](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x1E0DE7BB8]();
}

id objc_autorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7BD0](a1);
}

void objc_autoreleasePoolPop(void *context)
{
  MEMORY[0x1E0DE7BD8](context);
}

void *objc_autoreleasePoolPush(void)
{
  return (void *)MEMORY[0x1E0DE7BE0]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7BE8](a1);
}

id objc_begin_catch(void *exc_buf)
{
  return (id)MEMORY[0x1E0DE7BF0](exc_buf);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x1E0DE7BF8]();
}

void objc_copyStruct(void *dest, const void *src, ptrdiff_t size, BOOL atomic, BOOL hasStrong)
{
  MEMORY[0x1E0DE7C30](dest, src, size, atomic, hasStrong);
}

void objc_copyWeak(id *to, id *from)
{
  MEMORY[0x1E0DE7C38](to, from);
}

void objc_destroyWeak(id *location)
{
  MEMORY[0x1E0DE7C60](location);
}

void objc_end_catch(void)
{
  MEMORY[0x1E0DE7C80]();
}

void objc_enumerateClasses(const void *image, const char *namePrefix, Protocol *conformingTo, Class subclassing, void *block)
{
  MEMORY[0x1E0DE7C88](image, namePrefix, conformingTo, subclassing, block);
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x1E0DE7C90](obj);
}

void objc_exception_rethrow(void)
{
  MEMORY[0x1E0DE7C98]();
}

void objc_exception_throw(id exception)
{
  MEMORY[0x1E0DE7CA0](exception);
}

Class objc_getClass(const char *name)
{
  return (Class)MEMORY[0x1E0DE7CB0](name);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x1E0DE7CD0](self, _cmd, offset, atomic);
}

id objc_initWeak(id *location, id val)
{
  return (id)MEMORY[0x1E0DE7CE0](location, val);
}

id objc_loadWeakRetained(id *location)
{
  return (id)MEMORY[0x1E0DE7D08](location);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x1E0DE7D30](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x1E0DE7D38]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x1E0DE7D40]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x1E0DE7D48]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x1E0DE7D50]();
}

uint64_t objc_opt_self()
{
  return MEMORY[0x1E0DE7D58]();
}

void objc_release(id a1)
{
  MEMORY[0x1E0DE7D78](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x1E0DE7E50](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x1E0DE7E58](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E60](a1);
}

id objc_retainAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7E68](a1);
}

id objc_retainBlock(id a1)
{
  return (id)MEMORY[0x1E0DE7E70](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F88](self, _cmd, newValue, offset);
}

void objc_setProperty_atomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F90](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7F98](self, _cmd, newValue, offset);
}

void objc_setProperty_nonatomic_copy(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x1E0DE7FA0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x1E0DE7FB0](location, obj);
}

id objc_storeWeak(id *location, id obj)
{
  return (id)MEMORY[0x1E0DE7FB8](location, obj);
}

int objc_sync_enter(id obj)
{
  return MEMORY[0x1E0DE7FC8](obj);
}

int objc_sync_exit(id obj)
{
  return MEMORY[0x1E0DE7FD0](obj);
}

void objc_terminate(void)
{
  MEMORY[0x1E0DE7FD8]();
}

id objc_unsafeClaimAutoreleasedReturnValue(id a1)
{
  return (id)MEMORY[0x1E0DE7FE0](a1);
}

Class object_getClass(id a1)
{
  return (Class)MEMORY[0x1E0DE7FF8](a1);
}

void object_setIvar(id obj, Ivar ivar, id value)
{
  MEMORY[0x1E0DE8048](obj, ivar, value);
}

void os_activity_scope_enter(os_activity_t activity, os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84510](activity, state);
}

void os_activity_scope_leave(os_activity_scope_state_t state)
{
  MEMORY[0x1E0C84518](state);
}

os_log_t os_log_create(const char *subsystem, const char *category)
{
  return (os_log_t)MEMORY[0x1E0C84728](subsystem, category);
}

BOOL os_log_type_enabled(os_log_t oslog, os_log_type_t type)
{
  return MEMORY[0x1E0C84780](oslog, type);
}

uint64_t os_transaction_create()
{
  return MEMORY[0x1E0C84970]();
}

void os_unfair_lock_assert_not_owner(const os_unfair_lock *lock)
{
  MEMORY[0x1E0C84988](lock);
}

void os_unfair_lock_assert_owner(const os_unfair_lock *lock)
{
  MEMORY[0x1E0C84990](lock);
}

void os_unfair_lock_lock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C84998](lock);
}

uint64_t os_unfair_lock_lock_with_options()
{
  return MEMORY[0x1E0C849A0]();
}

void os_unfair_lock_unlock(os_unfair_lock_t lock)
{
  MEMORY[0x1E0C849B0](lock);
}

uint64_t os_variant_has_internal_content()
{
  return MEMORY[0x1E0C849F0]();
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x1E0C84BB8](__x, __y);
  return result;
}

float powf(float a1, float a2)
{
  float result;

  MEMORY[0x1E0C84BC0](a1, a2);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x1E0C84BD0](a1);
}

int proc_listallpids(void *buffer, int buffersize)
{
  return MEMORY[0x1E0C84C08](buffer, *(_QWORD *)&buffersize);
}

int proc_name(int pid, void *buffer, uint32_t buffersize)
{
  return MEMORY[0x1E0C84C20](*(_QWORD *)&pid, buffer, *(_QWORD *)&buffersize);
}

char *__cdecl property_copyAttributeValue(objc_property_t property, const char *attributeName)
{
  return (char *)MEMORY[0x1E0DE8060](property, attributeName);
}

const char *__cdecl property_getName(objc_property_t property)
{
  return (const char *)MEMORY[0x1E0DE8070](property);
}

int pthread_attr_destroy(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CB0](a1);
}

int pthread_attr_getschedparam(const pthread_attr_t *a1, sched_param *a2)
{
  return MEMORY[0x1E0C84CB8](a1, a2);
}

int pthread_attr_init(pthread_attr_t *a1)
{
  return MEMORY[0x1E0C84CC8](a1);
}

int pthread_attr_setinheritsched(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CE0](a1, *(_QWORD *)&a2);
}

int pthread_attr_setschedparam(pthread_attr_t *a1, const sched_param *a2)
{
  return MEMORY[0x1E0C84CE8](a1, a2);
}

int pthread_attr_setschedpolicy(pthread_attr_t *a1, int a2)
{
  return MEMORY[0x1E0C84CF0](a1, *(_QWORD *)&a2);
}

uint64_t pthread_set_fixedpriority_self()
{
  return MEMORY[0x1E0C84EE8]();
}

int puts(const char *a1)
{
  return MEMORY[0x1E0C84F60](a1);
}

int rand(void)
{
  return MEMORY[0x1E0C84FB0]();
}

int rand_r(unsigned int *a1)
{
  return MEMORY[0x1E0C84FB8](a1);
}

float sinf(float a1)
{
  float result;

  MEMORY[0x1E0C85420](a1);
  return result;
}

int snprintf(char *__str, size_t __size, const char *__format, ...)
{
  return MEMORY[0x1E0C85440](__str, __size, __format);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x1E0C85520](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x1E0C85540](__s1);
}

char *__cdecl strerror(int __errnum)
{
  return (char *)MEMORY[0x1E0C85548](*(_QWORD *)&__errnum);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x1E0C85578](__s);
}

int strncmp(const char *__s1, const char *__s2, size_t __n)
{
  return MEMORY[0x1E0C855A8](__s1, __s2, __n);
}

int sysctl(int *a1, u_int a2, void *a3, size_t *a4, void *a5, size_t a6)
{
  return MEMORY[0x1E0C85798](a1, *(_QWORD *)&a2, a3, a4, a5, a6);
}

int sysctlnametomib(const char *a1, int *a2, size_t *a3)
{
  return MEMORY[0x1E0C857B0](a1, a2, a3);
}

long double tan(long double __x)
{
  long double result;

  MEMORY[0x1E0C857E8](__x);
  return result;
}

float tanf(float a1)
{
  float result;

  MEMORY[0x1E0C857F0](a1);
  return result;
}

kern_return_t task_info(task_name_t target_task, task_flavor_t flavor, task_info_t task_info_out, mach_msg_type_number_t *task_info_outCnt)
{
  return MEMORY[0x1E0C85838](*(_QWORD *)&target_task, *(_QWORD *)&flavor, task_info_out, task_info_outCnt);
}

time_t time(time_t *a1)
{
  return MEMORY[0x1E0C85950](a1);
}

vImage_Error vImageBuffer_Init(vImage_Buffer *buf, vImagePixelCount height, vImagePixelCount width, uint32_t pixelBits, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CC00](buf, height, width, *(_QWORD *)&pixelBits, *(_QWORD *)&flags);
}

void vImageCVImageFormat_Release(vImageCVImageFormatRef fmt)
{
  MEMORY[0x1E0C8CCD0](fmt);
}

vImage_Error vImageConvert_420Yp8_CbCr8ToARGB8888(const vImage_Buffer *srcYp, const vImage_Buffer *srcCbCr, const vImage_Buffer *dest, const vImage_YpCbCrToARGB *info, const uint8_t permuteMap[4], const uint8_t alpha, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CD70](srcYp, srcCbCr, dest, info, permuteMap, alpha, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_Planar16FtoPlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8CF28](src, dest, *(_QWORD *)&flags);
}

vImage_Error vImageConvert_YpCbCrToARGB_GenerateConversion(const vImage_YpCbCrToARGBMatrix *matrix, const vImage_YpCbCrPixelRange *pixelRange, vImage_YpCbCrToARGB *outInfo, vImageYpCbCrType inYpCbCrType, vImageARGBType outARGBType, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D0F8](matrix, pixelRange, outInfo, *(_QWORD *)&inYpCbCrType, *(_QWORD *)&outARGBType, *(_QWORD *)&flags);
}

vImage_Error vImageCopyBuffer(const vImage_Buffer *src, const vImage_Buffer *dest, size_t pixelSize, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D1E0](src, dest, pixelSize, *(_QWORD *)&flags);
}

vImage_Error vImageExtractChannel_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint64_t channelIndex, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D288](src, dest, channelIndex, *(_QWORD *)&flags);
}

vImage_Error vImageHorizontalReflect_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D360](src, dest, *(_QWORD *)&flags);
}

uint64_t vImageMapping_CreateFromMap_Image8U()
{
  return MEMORY[0x1E0C8D400]();
}

uint64_t vImageMapping_Release()
{
  return MEMORY[0x1E0C8D408]();
}

vImage_Error vImageMin_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImagePixelCount srcOffsetToROI_X, vImagePixelCount srcOffsetToROI_Y, vImagePixelCount kernel_height, vImagePixelCount kernel_width, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D478](src, dest, tempBuffer, srcOffsetToROI_X, srcOffsetToROI_Y, kernel_height, kernel_width, *(_QWORD *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_Planar16U(Pixel_16U scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4C8](scalar, dest, *(_QWORD *)&flags);
}

vImage_Error vImageOverwriteChannelsWithScalar_Planar8(Pixel_8 scalar, const vImage_Buffer *dest, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D4D0](scalar, dest, *(_QWORD *)&flags);
}

vImage_Error vImagePermuteChannels_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, const uint8_t permuteMap[4], vImage_Flags flags)
{
  return MEMORY[0x1E0C8D520](src, dest, permuteMap, *(_QWORD *)&flags);
}

uint64_t vImageRemap_Image8U()
{
  return MEMORY[0x1E0C8D640]();
}

vImage_Error vImageRotate90_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_8888 backColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D658](src, dest, rotationConstant, backColor, *(_QWORD *)&flags);
}

vImage_Error vImageRotate90_ARGBFFFF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, const Pixel_FFFF backColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D668](src, dest, rotationConstant, backColor, *(_QWORD *)&flags);
}

vImage_Error vImageRotate90_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_8 backColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D688](src, dest, rotationConstant, backColor, *(_QWORD *)&flags);
}

vImage_Error vImageRotate90_PlanarF(const vImage_Buffer *src, const vImage_Buffer *dest, uint8_t rotationConstant, Pixel_F backColor, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D690](src, dest, rotationConstant, *(_QWORD *)&flags, backColor);
}

vImage_Error vImageScale_ARGB8888(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D6E8](src, dest, tempBuffer, *(_QWORD *)&flags);
}

vImage_Error vImageScale_Planar8(const vImage_Buffer *src, const vImage_Buffer *dest, void *tempBuffer, vImage_Flags flags)
{
  return MEMORY[0x1E0C8D728](src, dest, tempBuffer, *(_QWORD *)&flags);
}

xpc_type_t xpc_get_type(xpc_object_t object)
{
  return (xpc_type_t)MEMORY[0x1E0C86520](object);
}

