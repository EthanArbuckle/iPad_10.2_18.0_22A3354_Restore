double *CPMLOnlineSvm::ConditionalUpdate(double *this, uint64_t a2, uint64_t a3)
{
  double v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  double v7;
  double v8;

  if (a2 != a3)
  {
    v3 = this[20];
    v4 = *((_QWORD *)this + 45);
    v5 = *((_QWORD *)this + 39);
    v6 = *(double *)(v5 + 8 * a3) - fmin(v3 * *(double *)(v4 + 8 * a3), 0.0);
    if (v6 > 0.0)
    {
      v7 = fmax(v3 * *(double *)(v4 + 8 * a2), 0.0) - *(double *)(v5 + 8 * a2);
      if (v7 > 0.0)
      {
        v8 = *(double *)(*((_QWORD *)this + 48) + 8 * a2) - *(double *)(*((_QWORD *)this + 48) + 8 * a3);
        if (v8 > this[21])
          return (double *)CPMLOnlineSvm::Update(this, a2, a3, v7, v6, v8);
      }
    }
  }
  return this;
}

_QWORD *CPMLOnlineSvm::Update(_QWORD *this, uint64_t a2, uint64_t a3, double a4, double a5, double a6)
{
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  uint64_t v18;
  double *v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  double *v27;
  double *v28;
  double v29;
  double v30;
  double v31;

  v6 = (unint64_t *)this[54];
  v7 = v6[a2];
  v8 = this[13];
  if (v8 <= v7)
    CPMLOnlineSvm::Update((uint64_t)this, a2, a3);
  v9 = this[14];
  if (v9 <= v7)
    CPMLOnlineSvm::Update((uint64_t)this, a2, a3);
  v10 = v6[a3];
  if (v8 <= v10)
    CPMLOnlineSvm::Update((uint64_t)this, a2, a3);
  if (v9 <= v10)
    CPMLOnlineSvm::Update((uint64_t)this, a2, a3);
  v11 = this[12];
  v12 = this[15];
  v13 = this[16];
  v14 = v12 * v7;
  v15 = v13 * v7;
  v16 = v10 * v13;
  v17 = a6
      / (*(double *)(v11 + 8 * (v15 + v14))
       + *(double *)(v11 + 8 * v10 * (v13 + v12))
       + *(double *)(v11 + 8 * (v10 * v13 + v14)) * -2.0);
  if (a5 < a4)
    a4 = a5;
  v18 = this[39];
  if (a4 >= v17)
    a4 = v17;
  *(double *)(v18 + 8 * a2) = *(double *)(v18 + 8 * a2) + a4;
  *(double *)(v18 + 8 * a3) = *(double *)(v18 + 8 * a3) - a4;
  v19 = (double *)this[48];
  v20 = this[49] - (_QWORD)v19;
  if (v20)
  {
    v21 = v20 >> 3;
    if (v21 <= 1)
      v21 = 1;
    do
    {
      v23 = *v6++;
      v22 = v23;
      if (v8 <= v23)
        CPMLOnlineSvm::Update((uint64_t)this, a2, a3);
      *v19 = *v19 - (*(double *)(v11 + 8 * (v22 * v12 + v15)) - *(double *)(v11 + 8 * (v22 * v12 + v16))) * a4;
      ++v19;
      --v21;
    }
    while (v21);
  }
  v24 = (double *)this[52];
  v25 = (double *)this[53];
  if (v24 != v25)
  {
    v26 = this[42];
    v27 = *(double **)(v26 + 16 * a2);
    v28 = *(double **)(v26 + 16 * a3);
    do
    {
      v29 = *v27++;
      v30 = v29;
      v31 = *v28++;
      *v24 = *v24 + a4 * (v30 - v31);
      ++v24;
    }
    while (v24 != v25);
  }
  return this;
}

uint64_t CPMLOnlineSvm::ChooseArgminJ(CPMLOnlineSvm *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  double v5;

  v1 = *((_QWORD *)this + 43) - *((_QWORD *)this + 42);
  if (!v1)
  {
    v5 = 1.79769313e308;
    goto LABEL_12;
  }
  v2 = 0;
  v3 = v1 >> 4;
  if ((unint64_t)(v1 >> 4) <= 1)
    v3 = 1;
  v4 = -1.0;
  v5 = 1.79769313e308;
  do
  {
    if (*(double *)(*((_QWORD *)this + 39) + 8 * v2) > fmin(*((double *)this + 20)* *(double *)(*((_QWORD *)this + 45) + 8 * v2), 0.0)&& *(double *)(*((_QWORD *)this + 48) + 8 * v2) < v5)
    {
      v4 = (double)(int)v2;
      v5 = *(double *)(*((_QWORD *)this + 48) + 8 * v2);
    }
    ++v2;
  }
  while (v3 != v2);
  if (v4 == -1.0)
  {
LABEL_12:
    printf("current_min = %lf\n", v5);
    printf("# of sv = %lu\n", (uint64_t)(*((_QWORD *)this + 43) - *((_QWORD *)this + 42)) >> 4);
    exit(1);
  }
  return (int)v4;
}

uint64_t CPMLOnlineSvm::ChooseArgmaxI(CPMLOnlineSvm *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  double v5;

  v1 = *((_QWORD *)this + 43) - *((_QWORD *)this + 42);
  if (!v1)
    goto LABEL_11;
  v2 = 0;
  v3 = v1 >> 4;
  if ((unint64_t)(v1 >> 4) <= 1)
    v3 = 1;
  v4 = -1.0;
  v5 = -1.79769313e308;
  do
  {
    if (*(double *)(*((_QWORD *)this + 39) + 8 * v2) < fmax(*((double *)this + 20)* *(double *)(*((_QWORD *)this + 45) + 8 * v2), 0.0)&& *(double *)(*((_QWORD *)this + 48) + 8 * v2) > v5)
    {
      v4 = (double)(int)v2;
      v5 = *(double *)(*((_QWORD *)this + 48) + 8 * v2);
    }
    ++v2;
  }
  while (v3 != v2);
  if (v4 == -1.0)
LABEL_11:
    CPMLOnlineSvm::ChooseArgmaxI();
  return (int)v4;
}

double *CPMLOnlineSvm::Process(CPMLOnlineSvm *a1, uint64_t a2, uint64_t a3, double a4)
{
  uint64_t *v6;
  uint64_t *v7;
  double *v8;
  double v9;
  double v10;
  double v11;
  double v12;
  double *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  double v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  void *__p;
  _BYTE *v26;

  v6 = *(uint64_t **)a2;
  v7 = *(uint64_t **)(a2 + 8);
  if (*(uint64_t **)a2 == v7)
  {
    v9 = 0.0;
  }
  else
  {
    v8 = (double *)*((_QWORD *)a1 + 52);
    v9 = 0.0;
    do
    {
      v10 = *(double *)v6++;
      v11 = v10;
      v12 = *v8++;
      v9 = v9 + v11 * v12;
    }
    while (v6 != v7);
  }
  if (!((*((_QWORD *)a1 + 33) - *((_QWORD *)a1 + 32)) >> 14))
  {
    v13 = (double *)*((_QWORD *)a1 + 39);
    v14 = *((_QWORD *)a1 + 40) - (_QWORD)v13;
    if (v14)
    {
      v15 = v14 >> 3;
      v16 = (unint64_t *)*((_QWORD *)a1 + 54);
      v17 = *((_QWORD *)a1 + 57) + 1;
      if (v15 <= 1)
        v15 = 1;
      v9 = 0.0;
      do
      {
        v19 = *v16++;
        v18 = v19;
        if (*((_QWORD *)a1 + 13) <= v19)
          CPMLOnlineSvm::Update((uint64_t)a1, a2, a3);
        if (*((_QWORD *)a1 + 14) <= v17)
          CPMLOnlineSvm::Update((uint64_t)a1, a2, a3);
        v20 = *v13++;
        v9 = v9
           + v20 * *(double *)(*((_QWORD *)a1 + 12) + 8 * (*((_QWORD *)a1 + 15) * v18 + *((_QWORD *)a1 + 16) * v17));
        --v15;
      }
      while (v15);
    }
    else
    {
      v9 = 0.0;
    }
  }
  v21 = a4 - v9;
  std::valarray<double>::valarray(&__p, (uint64_t **)a2);
  CPMLOnlineSvm::AddNewSv(a1, (uint64_t **)&__p, a4, 0.0, v21);
  if (__p)
  {
    if (v26 != __p)
      v26 += ((_BYTE *)__p - v26 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(__p);
    __p = 0;
    v26 = 0;
  }
  if (a4 == 1.0)
  {
    v22 = ((uint64_t)(*((_QWORD *)a1 + 43) - *((_QWORD *)a1 + 42)) >> 4) - 1;
    v23 = (int)CPMLOnlineSvm::ChooseArgminJ(a1);
  }
  else
  {
    v22 = (int)CPMLOnlineSvm::ChooseArgmaxI(a1);
    v23 = ((uint64_t)(*((_QWORD *)a1 + 43) - *((_QWORD *)a1 + 42)) >> 4) - 1;
  }
  return CPMLOnlineSvm::ConditionalUpdate((double *)a1, v22, v23);
}

void sub_209CB6F18(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CPMLOnlineSvm::AddNewSv(_QWORD *a1, uint64_t **a2, double a3, double a4, double a5)
{
  double *v9;
  unint64_t v10;
  double *v11;
  double *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  double *v18;
  char *v19;
  uint64_t v20;
  double *v21;
  unint64_t v22;
  double *v23;
  double *v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  double *v30;
  char *v31;
  uint64_t v32;
  double *v33;
  unint64_t v34;
  double *v35;
  double *v36;
  uint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t v40;
  char *v41;
  double *v42;
  char *v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  _QWORD *v48;
  uint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  char *v54;
  uint64_t *v55;
  char *v56;
  uint64_t v57;

  std::vector<std::valarray<double>>::push_back[abi:ne180100](a1 + 42, a2);
  v9 = (double *)a1[46];
  v10 = a1[47];
  if ((unint64_t)v9 >= v10)
  {
    v12 = (double *)a1[45];
    v13 = v9 - v12;
    if ((unint64_t)(v13 + 1) >> 61)
      goto LABEL_66;
    v14 = v10 - (_QWORD)v12;
    v15 = (uint64_t)(v10 - (_QWORD)v12) >> 2;
    if (v15 <= v13 + 1)
      v15 = v13 + 1;
    if (v14 >= 0x7FFFFFFFFFFFFFF8)
      v16 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v16 = v15;
    if (v16)
    {
      v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 47), v16);
      v12 = (double *)a1[45];
      v9 = (double *)a1[46];
    }
    else
    {
      v17 = 0;
    }
    v18 = (double *)&v17[8 * v13];
    v19 = &v17[8 * v16];
    *v18 = a3;
    v11 = v18 + 1;
    while (v9 != v12)
    {
      v20 = *((_QWORD *)v9-- - 1);
      *((_QWORD *)v18-- - 1) = v20;
    }
    a1[45] = v18;
    a1[46] = v11;
    a1[47] = v19;
    if (v12)
      operator delete(v12);
  }
  else
  {
    *v9 = a3;
    v11 = v9 + 1;
  }
  a1[46] = v11;
  v21 = (double *)a1[40];
  v22 = a1[41];
  if ((unint64_t)v21 >= v22)
  {
    v24 = (double *)a1[39];
    v25 = v21 - v24;
    if ((unint64_t)(v25 + 1) >> 61)
      goto LABEL_66;
    v26 = v22 - (_QWORD)v24;
    v27 = (uint64_t)(v22 - (_QWORD)v24) >> 2;
    if (v27 <= v25 + 1)
      v27 = v25 + 1;
    if (v26 >= 0x7FFFFFFFFFFFFFF8)
      v28 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v28 = v27;
    if (v28)
    {
      v29 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 41), v28);
      v24 = (double *)a1[39];
      v21 = (double *)a1[40];
    }
    else
    {
      v29 = 0;
    }
    v30 = (double *)&v29[8 * v25];
    v31 = &v29[8 * v28];
    *v30 = a4;
    v23 = v30 + 1;
    while (v21 != v24)
    {
      v32 = *((_QWORD *)v21-- - 1);
      *((_QWORD *)v30-- - 1) = v32;
    }
    a1[39] = v30;
    a1[40] = v23;
    a1[41] = v31;
    if (v24)
      operator delete(v24);
  }
  else
  {
    *v21 = a4;
    v23 = v21 + 1;
  }
  a1[40] = v23;
  v33 = (double *)a1[49];
  v34 = a1[50];
  if ((unint64_t)v33 < v34)
  {
    *v33 = a5;
    v35 = v33 + 1;
    goto LABEL_49;
  }
  v36 = (double *)a1[48];
  v37 = v33 - v36;
  if ((unint64_t)(v37 + 1) >> 61)
LABEL_66:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v38 = v34 - (_QWORD)v36;
  v39 = (uint64_t)(v34 - (_QWORD)v36) >> 2;
  if (v39 <= v37 + 1)
    v39 = v37 + 1;
  if (v38 >= 0x7FFFFFFFFFFFFFF8)
    v40 = 0x1FFFFFFFFFFFFFFFLL;
  else
    v40 = v39;
  if (v40)
  {
    v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 50), v40);
    v36 = (double *)a1[48];
    v33 = (double *)a1[49];
  }
  else
  {
    v41 = 0;
  }
  v42 = (double *)&v41[8 * v37];
  v43 = &v41[8 * v40];
  *v42 = a5;
  v35 = v42 + 1;
  while (v33 != v36)
  {
    v44 = *((_QWORD *)v33-- - 1);
    *((_QWORD *)v42-- - 1) = v44;
  }
  a1[48] = v42;
  a1[49] = v35;
  a1[50] = v43;
  if (v36)
    operator delete(v36);
LABEL_49:
  a1[49] = v35;
  v45 = a1[56];
  v46 = a1[57] + 1;
  a1[57] = v46;
  v47 = (uint64_t *)a1[55];
  if ((unint64_t)v47 >= v45)
  {
    v49 = (uint64_t *)a1[54];
    v50 = v47 - v49;
    if ((unint64_t)(v50 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v51 = v45 - (_QWORD)v49;
    v52 = (uint64_t)(v45 - (_QWORD)v49) >> 2;
    if (v52 <= v50 + 1)
      v52 = v50 + 1;
    if (v51 >= 0x7FFFFFFFFFFFFFF8)
      v53 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v53 = v52;
    if (v53)
    {
      v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 56), v53);
      v49 = (uint64_t *)a1[54];
      v47 = (uint64_t *)a1[55];
      v46 = a1[57];
    }
    else
    {
      v54 = 0;
    }
    v55 = (uint64_t *)&v54[8 * v50];
    v56 = &v54[8 * v53];
    *v55 = v46;
    v48 = v55 + 1;
    while (v47 != v49)
    {
      v57 = *--v47;
      *--v55 = v57;
    }
    a1[54] = v55;
    a1[55] = v48;
    a1[56] = v56;
    if (v49)
      operator delete(v49);
  }
  else
  {
    *v47 = v46;
    v48 = v47 + 1;
  }
  a1[55] = v48;
}

uint64_t std::valarray<double>::~valarray(uint64_t a1)
{
  _BYTE *v2;
  _BYTE *v3;

  v2 = *(_BYTE **)a1;
  if (v2)
  {
    v3 = *(_BYTE **)(a1 + 8);
    if (v3 != v2)
      *(_QWORD *)(a1 + 8) = &v3[(v2 - v3 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v2);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  return a1;
}

void CPMLOnlineSvm::Train(CPMLOnlineSvm *this)
{
  uint64_t v2;
  uint64_t v3;

  CPMLOnlineSvm::Init(this);
  CPMLOnlineSvm::OnlineIteration(this, v2, v3);
}

void CPMLOnlineSvm::Init(CPMLOnlineSvm *this)
{
  uint64_t v2;
  int v3;
  BOOL v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t **v7;
  uint64_t **v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t i;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  double v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  double *v40;
  double *v41;
  uint64_t v42;
  double *v43;
  double *v44;
  double v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  _BYTE *v49;
  void *v50;
  _BYTE *v51;
  void *__p;
  _BYTE *v53;

  v2 = (uint64_t)(*((_QWORD *)this + 33) - *((_QWORD *)this + 32)) >> 4;
  CoreMatrix::Matrix<double>::Resize((_QWORD *)this + 12, v2 * v2);
  *((_QWORD *)this + 13) = v2;
  *((_QWORD *)this + 14) = v2;
  v3 = *((_DWORD *)this + 36);
  v4 = v3 == 1;
  if (v3 == 1)
    v5 = 1;
  else
    v5 = v2;
  if (v4)
    v6 = v2;
  else
    v6 = 1;
  *((_QWORD *)this + 15) = v5;
  *((_QWORD *)this + 16) = v6;
  v7 = (uint64_t **)*((_QWORD *)this + 32);
  v8 = (uint64_t **)*((_QWORD *)this + 33);
  if (v8 == v7)
  {
    v7 = (uint64_t **)*((_QWORD *)this + 33);
  }
  else
  {
    v9 = 0;
    v10 = 0;
    do
    {
      v11 = ((char *)v8 - (char *)v7) >> 4;
      v12 = v9;
      for (i = v10; v11 > i; v12 += 16)
      {
        if (*((_QWORD *)this + 28))
        {
          v17 = CPMLOnlineSvm::SparseKernel((uint64_t)this, (char **)(*((_QWORD *)this + 35) + 16 * v10), (char **)(*((_QWORD *)this + 35) + v12));
          v18 = *((_QWORD *)this + 13);
          if (v18 <= v10)
            CPMLOnlineSvm::Update(v14, v15, v16);
          v19 = *((_QWORD *)this + 14);
          if (v19 <= i)
            CPMLOnlineSvm::Update(v14, v15, v16);
          v20 = *((_QWORD *)this + 12);
          v21 = *((_QWORD *)this + 15);
          v22 = *((_QWORD *)this + 16);
          *(double *)(v20 + 8 * (v21 * v10 + v22 * i)) = v17;
          if (v18 <= i)
            CPMLOnlineSvm::Update(v14, v15, v16);
          if (v19 <= v10)
            CPMLOnlineSvm::Update(v14, v15, v16);
        }
        else
        {
          v17 = CPMLOnlineSvm::DenseKernel((uint64_t)this, (uint64_t)&v7[2 * v10], (double **)((char *)v7 + v12));
          v26 = *((_QWORD *)this + 13);
          if (v26 <= v10)
            CPMLOnlineSvm::Update(v23, v24, v25);
          v27 = *((_QWORD *)this + 14);
          if (v27 <= i)
            CPMLOnlineSvm::Update(v23, v24, v25);
          v20 = *((_QWORD *)this + 12);
          v21 = *((_QWORD *)this + 15);
          v22 = *((_QWORD *)this + 16);
          *(double *)(v20 + 8 * (v21 * v10 + v22 * i)) = v17;
          if (v26 <= i)
            CPMLOnlineSvm::Update(v23, v24, v25);
          if (v27 <= v10)
            CPMLOnlineSvm::Update(v23, v24, v25);
        }
        *(double *)(v20 + 8 * (v21 * i++ + v22 * v10)) = v17;
        v7 = (uint64_t **)*((_QWORD *)this + 32);
        v8 = (uint64_t **)*((_QWORD *)this + 33);
        v11 = ((char *)v8 - (char *)v7) >> 4;
      }
      ++v10;
      v9 += 16;
    }
    while (v11 > v10);
  }
  v28 = **((_DWORD **)this + 29);
  std::valarray<double>::valarray(&__p, v7);
  CPMLOnlineSvm::AddNewSv(this, (uint64_t **)&__p, (double)v28, 0.0, (double)v28);
  if (__p)
  {
    if (v53 != __p)
      v53 += ((_BYTE *)__p - v53 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(__p);
    __p = 0;
    v53 = 0;
  }
  if (*(_DWORD *)(*((_QWORD *)this + 29) + 4) == v28)
  {
    v29 = 0;
    v30 = 16;
    do
    {
      std::valarray<double>::valarray(&v50, (uint64_t **)(*((_QWORD *)this + 32) + v30));
      v31 = (double)*(int *)(*((_QWORD *)this + 29) + 4 * v29 + 4);
      CPMLOnlineSvm::AddNewSv(this, (uint64_t **)&v50, v31, 0.0, v31);
      if (v50)
      {
        if (v51 != v50)
          v51 += ((_BYTE *)v50 - v51 + 7) & 0xFFFFFFFFFFFFFFF8;
        operator delete(v50);
        v50 = 0;
        v51 = 0;
      }
      v32 = *(_DWORD *)(*((_QWORD *)this + 29) + 4 * v29++ + 8);
      v30 += 16;
    }
    while (v32 == v28);
    v33 = (v29 + 2);
    v34 = v29 + 1;
  }
  else
  {
    v34 = 1;
    v33 = 2;
  }
  std::valarray<double>::valarray(&v48, (uint64_t **)(*((_QWORD *)this + 32) + 16 * v34));
  v35 = (double)*(int *)(*((_QWORD *)this + 29) + 4 * v34);
  CPMLOnlineSvm::AddNewSv(this, (uint64_t **)&v48, v35, 0.0, v35);
  if (v48)
  {
    if (v49 != v48)
      v49 += ((_BYTE *)v48 - v49 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(v48);
    v48 = 0;
    v49 = 0;
  }
  v36 = *((_QWORD *)this + 42);
  v37 = (*((_QWORD *)this + 43) - v36) >> 4;
  if (*((_QWORD *)this + 43) == v36)
  {
    *((_QWORD *)this + 58) = v33;
  }
  else
  {
    v38 = 0;
    v39 = *((_QWORD *)this + 39);
    v40 = (double *)*((_QWORD *)this + 52);
    v41 = (double *)*((_QWORD *)this + 53);
    if (v37 <= 1)
      v42 = 1;
    else
      v42 = (*((_QWORD *)this + 43) - v36) >> 4;
    do
    {
      if (v40 != v41)
      {
        v43 = *(double **)(v36 + 16 * v38);
        v44 = v40;
        do
        {
          v45 = *v43++;
          *v44 = *v44 + v45 * *(double *)(v39 + 8 * v38);
          ++v44;
        }
        while (v44 != v41);
      }
      ++v38;
    }
    while (v38 != v42);
    v46 = 0;
    *((_QWORD *)this + 58) = v33;
    v47 = *((_QWORD *)this + 54);
    do
    {
      *(_QWORD *)(v47 + 8 * v46) = v46;
      ++v46;
    }
    while (v42 != v46);
  }
  *((_QWORD *)this + 57) = v37 - 1;
}

void sub_209CB7664(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, _BYTE *__p, _BYTE *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  uint64_t v14;

  if (__p)
  {
    if (a10 != __p)
      *(_QWORD *)(v14 + 8) = &a10[(__p - a10 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(__p);
  }
  _Unwind_Resume(exception_object);
}

void CPMLOnlineSvm::OnlineIteration(CPMLOnlineSvm *this, uint64_t a2, uint64_t a3)
{
  unint64_t v4;
  uint64_t v5;
  FILE **v6;
  uint64_t v7;
  _QWORD *v8;
  int v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = *((_QWORD *)this + 58);
  v5 = *((_QWORD *)this + 32);
  v6 = (FILE **)MEMORY[0x24BDAC8E8];
  if (v4 < (*((_QWORD *)this + 33) - v5) >> 4)
  {
    v7 = 16 * v4;
    do
    {
      if (500 * (v4 / 0x1F4) == v4)
      {
        v8 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v8, (uint64_t)"... ", 4);
        fflush(*v6);
        v5 = *((_QWORD *)this + 32);
      }
      CPMLOnlineSvm::Process(this, v5 + v7, a3, (double)*(int *)(*((_QWORD *)this + 29) + 4 * v4));
      CPMLOnlineSvm::Reprocess(this);
      ++v4;
      v5 = *((_QWORD *)this + 32);
      v7 += 16;
    }
    while (v4 < (*((_QWORD *)this + 33) - v5) >> 4);
  }
  if (*((int *)this + 45) >= 1)
  {
    v9 = 0;
    do
    {
      if (*((double *)this + 51) <= *((double *)this + 21))
        break;
      if (1000 * (v9 / 0x3E8u) == v9)
      {
        v10 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v10, (uint64_t)" (", 2);
        v11 = (_QWORD *)std::ostream::operator<<();
        std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v11, (uint64_t)")... ", 5);
        fflush(*v6);
      }
      CPMLOnlineSvm::Reprocess(this);
      ++v9;
    }
    while (v9 < *((_DWORD *)this + 45));
  }
}

void *std::vector<std::valarray<double>>::push_back[abi:ne180100](uint64_t *a1, uint64_t **a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  void *result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  void *v15;
  char *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 4;
    if ((unint64_t)(v10 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 3;
    if (v11 >> 3 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v13 = 0xFFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[16 * v10];
    v18 = &v14[16 * v13];
    std::valarray<double>::valarray(v16, a2);
    v17 = v16 + 16;
    std::vector<std::valarray<double>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<std::valarray<double>>::~__split_buffer(&v15);
  }
  else
  {
    result = std::valarray<double>::valarray(*(_QWORD **)(v4 - 8), a2);
    v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return result;
}

void sub_209CB7964(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

double CPMLOnlineSvm::Reprocess(CPMLOnlineSvm *this)
{
  int v2;
  int v3;
  int v4;
  int v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;
  uint64_t v10;
  double v11;
  double **v12;
  double *v13;
  double *v14;
  double *v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  double result;
  char v38;

  v2 = CPMLOnlineSvm::ChooseArgmaxI(this);
  v3 = CPMLOnlineSvm::ChooseArgminJ(this);
  CPMLOnlineSvm::ConditionalUpdate((double *)this, v2, v3);
  v4 = CPMLOnlineSvm::ChooseArgmaxI(this);
  v5 = CPMLOnlineSvm::ChooseArgminJ(this);
  v6 = *((_QWORD *)this + 43) - *((_QWORD *)this + 42);
  if (v6)
  {
    v7 = 0;
    v8 = 0;
    v9 = v6 >> 4;
    do
    {
      v10 = *((_QWORD *)this + 39);
      if (*(double *)(v10 + 8 * v7) == 0.0)
      {
        if ((v11 = *(double *)(*((_QWORD *)this + 45) + 8 * v7), v11 == 1.0)
          && *(double *)(*((_QWORD *)this + 48) + 8 * v7) <= *(double *)(*((_QWORD *)this + 48) + 8 * v5)
          || v11 != 1.0
          && *(double *)(*((_QWORD *)this + 48) + 8 * v7) >= *(double *)(*((_QWORD *)this + 48) + 8 * v4))
        {
          v12 = (double **)(*((_QWORD *)this + 42) + 16 * v7);
          v13 = (double *)*((_QWORD *)this + 52);
          v14 = (double *)*((_QWORD *)this + 53);
          if (v13 != v14)
          {
            v15 = *v12;
            do
            {
              v16 = *v15++;
              *v13 = *v13 - *(double *)(v10 + 8 * v7) * v16;
              ++v13;
            }
            while (v13 != v14);
          }
          std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::valarray<double> *,std::valarray<double> *,std::valarray<double> *>((uint64_t)&v38, (uint64_t)(v12 + 2), *((_QWORD *)this + 43), (uint64_t)v12);
          v18 = v17;
          v19 = *((_QWORD *)this + 43);
          if (v19 != v17)
          {
            do
            {
              v19 -= 16;
              std::allocator<std::valarray<double>>::destroy[abi:ne180100]((uint64_t)this + 352, v19);
            }
            while (v19 != v18);
          }
          *((_QWORD *)this + 43) = v18;
          v20 = *((_QWORD *)this + 45);
          v21 = *((_QWORD *)this + 46);
          v22 = v20 + 8 * v7;
          v23 = v21 - (v22 + 8);
          if (v21 != v22 + 8)
            memmove((void *)(v20 + 8 * v7), (const void *)(v22 + 8), v21 - (v22 + 8));
          *((_QWORD *)this + 46) = v22 + v23;
          v24 = *((_QWORD *)this + 39);
          v25 = *((_QWORD *)this + 40);
          v26 = v24 + 8 * v7;
          v27 = v25 - (v26 + 8);
          if (v25 != v26 + 8)
            memmove((void *)(v24 + 8 * v7), (const void *)(v26 + 8), v25 - (v26 + 8));
          *((_QWORD *)this + 40) = v26 + v27;
          v28 = *((_QWORD *)this + 48);
          v29 = *((_QWORD *)this + 49);
          v30 = v28 + 8 * v7;
          v31 = v29 - (v30 + 8);
          if (v29 != v30 + 8)
            memmove((void *)(v28 + 8 * v7), (const void *)(v30 + 8), v29 - (v30 + 8));
          *((_QWORD *)this + 49) = v30 + v31;
          v32 = *((_QWORD *)this + 54);
          v33 = *((_QWORD *)this + 55);
          v34 = v32 + 8 * v7;
          v35 = v33 - (v34 + 8);
          if (v33 != v34 + 8)
            memmove((void *)(v32 + 8 * v7), (const void *)(v34 + 8), v33 - (v34 + 8));
          *((_QWORD *)this + 55) = v34 + v35;
          v4 -= v4 > v8;
          v5 -= v5 > v8;
          --v9;
          --v8;
        }
      }
      v7 = ++v8;
    }
    while (v9 > v8);
  }
  v36 = *((_QWORD *)this + 48);
  *((double *)this + 38) = (*(double *)(v36 + 8 * v4) + *(double *)(v36 + 8 * v5)) * 0.5;
  result = *(double *)(v36 + 8 * v4) - *(double *)(v36 + 8 * v5);
  *((double *)this + 51) = result;
  return result;
}

double CPMLOnlineSvm::SparseKernel(uint64_t a1, char **a2, char **a3)
{
  int v4;
  double v6;
  int v7;
  _QWORD *v8;

  v4 = *(_DWORD *)(a1 + 152);
  if (v4 == 2)
    return CPMLOnlineSvm::RbfSparseKernel(a1, (uint64_t)a2, (uint64_t)a3);
  if (v4 == 1)
  {
    v6 = *(double *)(a1 + 192);
    v7 = CPMLOnlineSvm::LinearSparseKernel(a1, a2, a3);
    return pow(*(double *)(a1 + 200) + v6 * (double)v7, *(long double *)(a1 + 208));
  }
  else
  {
    if (v4)
    {
      v8 = std::operator<<[abi:ne180100]<std::char_traits<char>>(MEMORY[0x24BEDB310], "Only three kernels are supported now: linear, poly, and rbf.");
      std::endl[abi:ne180100]<char,std::char_traits<char>>(v8);
      exit(1);
    }
    return (double)(int)CPMLOnlineSvm::LinearSparseKernel(a1, a2, a3);
  }
}

double CPMLOnlineSvm::DenseKernel(uint64_t a1, uint64_t a2, double **a3)
{
  int v3;
  double *v4;
  double *v5;
  double *v6;
  double result;
  double v8;
  double v9;
  double v10;
  _QWORD *v11;

  v3 = *(_DWORD *)(a1 + 152);
  if (v3 == 2)
    return CPMLOnlineSvm::RbfDenseKernel(a1, a2, (uint64_t)a3);
  if (v3 == 1)
    return CPMLOnlineSvm::PolyDenseKernel((double *)a1, (double **)a2, a3);
  if (v3)
  {
    v11 = std::operator<<[abi:ne180100]<std::char_traits<char>>(MEMORY[0x24BEDB310], "Only three kernels are supported now: linear, poly, and rbf.");
    std::endl[abi:ne180100]<char,std::char_traits<char>>(v11);
    exit(1);
  }
  v4 = *(double **)a2;
  v5 = *(double **)(a2 + 8);
  if (*(double **)a2 == v5)
    return 0.0;
  v6 = *a3;
  result = 0.0;
  do
  {
    v8 = *v4++;
    v9 = v8;
    v10 = *v6++;
    result = result + v9 * v10;
  }
  while (v4 != v5);
  return result;
}

_QWORD *std::operator<<[abi:ne180100]<std::char_traits<char>>(_QWORD *a1, char *__s)
{
  size_t v4;

  v4 = strlen(__s);
  return std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(a1, (uint64_t)__s, v4);
}

uint64_t CPMLOnlineSvm::Evaluate(uint64_t a1, uint64_t a2)
{
  double v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v7;
  double *v8;
  double *v9;
  double *v10;
  double v11;
  double v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v2 = *(double *)(a1 + 304);
  v3 = *(_QWORD *)(a1 + 336);
  v4 = *(_QWORD *)(a1 + 344);
  if (v4 != v3)
  {
    v7 = 0;
    do
    {
      switch(*(_DWORD *)(a1 + 152))
      {
        case 0:
          v8 = *(double **)a2;
          v9 = *(double **)(a2 + 8);
          if (*(double **)a2 == v9)
          {
            v11 = 0.0;
          }
          else
          {
            v10 = *(double **)(v3 + 16 * v7);
            v11 = 0.0;
            do
            {
              v12 = *v8++;
              v13 = v12;
              v14 = *v10++;
              v11 = v11 + v13 * v14;
            }
            while (v8 != v9);
          }
          v2 = v2 + *(double *)(*(_QWORD *)(a1 + 312) + 8 * v7) * v11;
          break;
        case 1:
          v15 = *(double *)(*(_QWORD *)(a1 + 312) + 8 * v7);
          v16 = CPMLOnlineSvm::PolyDenseKernel((double *)a1, (double **)a2, (double **)(v3 + 16 * v7));
          goto LABEL_11;
        case 2:
          v17 = *(double *)(*(_QWORD *)(a1 + 312) + 8 * v7);
          v2 = v2 + v17 * CPMLOnlineSvm::RbfDenseKernel(a1, a2, v3 + 16 * v7);
          v3 = *(_QWORD *)(a1 + 336);
          v4 = *(_QWORD *)(a1 + 344);
          break;
        case 3:
          v15 = *(double *)(*(_QWORD *)(a1 + 312) + 8 * v7);
          v16 = CPMLOnlineSvm::SigmoidDenseKernel(a1, (double **)a2, (double **)(v3 + 16 * v7));
LABEL_11:
          v2 = v2 + v15 * v16;
          break;
        default:
          break;
      }
      ++v7;
    }
    while (v7 < (v4 - v3) >> 4);
  }
  if (v2 > 0.0)
    return 1;
  else
    return 0xFFFFFFFFLL;
}

double CPMLOnlineSvm::LinearDenseKernel(uint64_t a1, double **a2, double **a3)
{
  double *v3;
  double *v4;
  double *v5;
  double result;
  double v7;
  double v8;
  double v9;

  v3 = *a2;
  v4 = a2[1];
  if (*a2 == v4)
    return 0.0;
  v5 = *a3;
  result = 0.0;
  do
  {
    v7 = *v3++;
    v8 = v7;
    v9 = *v5++;
    result = result + v8 * v9;
  }
  while (v3 != v4);
  return result;
}

double CPMLOnlineSvm::RbfDenseKernel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  double *v4;
  double *v5;
  char *v6;
  double v7;
  double *v8;
  double v9;
  double v10;
  double v12[3];
  double *v13;
  double *v14;

  *(_QWORD *)&v12[1] = a2;
  *(_QWORD *)&v12[2] = a3;
  std::__val_expr<std::_BinaryOp<std::minus<double>,std::valarray<double>,std::valarray<double>>>::operator std::valarray<double>(v12, &v13);
  v4 = v13;
  v5 = v14;
  v6 = (char *)((char *)v13 - (char *)v14);
  if (v13 == v14)
  {
    v10 = exp(*(double *)(a1 + 184) * -0.0);
    if (v4)
      goto LABEL_7;
  }
  else
  {
    v7 = 0.0;
    v8 = v13;
    do
    {
      v9 = *v8++;
      v7 = v7 + v9 * v9;
    }
    while (v8 != v14);
    v10 = exp(-(*(double *)(a1 + 184) * v7));
    if (v4)
    {
      v14 = (double *)((char *)v5 + ((unint64_t)(v6 + 7) & 0xFFFFFFFFFFFFFFF8));
LABEL_7:
      operator delete(v4);
    }
  }
  return v10;
}

double CPMLOnlineSvm::PolyDenseKernel(double *a1, double **a2, double **a3)
{
  double *v3;
  double *v4;
  double *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  long double v11;

  v3 = *a2;
  v4 = a2[1];
  if (*a2 == v4)
  {
    v6 = 0.0;
  }
  else
  {
    v5 = *a3;
    v6 = 0.0;
    do
    {
      v7 = *v3++;
      v8 = v7;
      v9 = *v5++;
      v6 = v6 + v8 * v9;
    }
    while (v3 != v4);
  }
  v10 = a1[25] + a1[24] * v6;
  v11 = a1[26];
  if (v11 == 2.0)
    return v10 * v10;
  if (v11 == 3.0)
    return v10 * (v10 * v10);
  return pow(v10, v11);
}

double CPMLOnlineSvm::SigmoidDenseKernel(uint64_t a1, double **a2, double **a3)
{
  double *v3;
  double *v4;
  double *v5;
  double v6;
  double v7;
  double v8;
  double v9;

  v3 = *a2;
  v4 = a2[1];
  if (*a2 == v4)
  {
    v6 = 0.0;
  }
  else
  {
    v5 = *a3;
    v6 = 0.0;
    do
    {
      v7 = *v3++;
      v8 = v7;
      v9 = *v5++;
      v6 = v6 + v8 * v9;
    }
    while (v3 != v4);
  }
  return tanh(*(double *)(a1 + 200) + *(double *)(a1 + 192) * v6);
}

uint64_t CPMLOnlineSvm::serialize(CPMLOnlineSvm *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;
  _QWORD *v5;
  uint64_t v6;
  unint64_t i;
  uint64_t v8;
  unint64_t j;
  unint64_t v11;
  unint64_t v12;
  char v13[30];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  v5 = (_QWORD *)*((_QWORD *)this + 42);
  v6 = (uint64_t)(v5[1] - *v5) >> 3;
  v11 = (uint64_t)(*((_QWORD *)this + 43) - (_QWORD)v5) >> 4;
  v12 = v6;
  (*(void (**)(_QWORD, unint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), &v12, "num_feature", 1, 0);
  (*(void (**)(_QWORD, unint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), &v11, "num_sv", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), (char *)this + 304, "bias_", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 39), "alphas_", v11, 0);
  if (v11)
  {
    for (i = 0; i < v11; ++i)
    {
      sprintf(v13, "support_vectors_%d", i);
      if (v12)
      {
        v8 = 0;
        for (j = 0; j < v12; ++j)
        {
          (*(void (**)(_QWORD, uint64_t, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 42) + 16 * i) + v8, v13, 1, 0);
          v8 += 8;
        }
      }
    }
  }
  return 0;
}

uint64_t CPMLOnlineSvm::Serialize(uint64_t a1)
{
  _QWORD *v2;
  const std::locale::facet *v3;
  _QWORD *v4;
  const std::locale::facet *v5;
  _QWORD *v6;
  const std::locale::facet *v7;
  _QWORD *v8;
  const std::locale::facet *v9;
  int v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  _QWORD *v13;
  const std::locale::facet *v14;
  _QWORD *v15;
  const std::locale::facet *v16;
  _QWORD *v17;
  const std::locale::facet *v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  _QWORD *v21;
  const std::locale::facet *v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  std::locale::id *v26;
  const std::locale::facet *v27;
  _QWORD *v28;
  unint64_t v29;
  _QWORD *v31;
  std::locale v32;
  uint64_t v33;
  _BYTE v34[408];
  _QWORD v35[20];

  v35[19] = *MEMORY[0x24BDAC8D0];
  std::ofstream::basic_ofstream(&v33);
  if ((v34[*(_QWORD *)(v33 - 24) + 24] & 5) != 0)
  {
    v31 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB310], (uint64_t)"cannot open output file", 23);
    std::endl[abi:ne180100]<char,std::char_traits<char>>(v31);
    exit(1);
  }
  v2 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(_QWORD *)(*v2 - 24)));
  v3 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v4 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v4 + *(_QWORD *)(*v4 - 24)));
  v5 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v5->__vftable[2].~facet_0)(v5, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v6 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(_QWORD *)(*v6 - 24)));
  v7 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v8 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v8 + *(_QWORD *)(*v8 - 24)));
  v9 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v9->__vftable[2].~facet_0)(v9, 10);
  std::locale::~locale(&v32);
  std::ostream::put();
  std::ostream::flush();
  v10 = *(_DWORD *)(a1 + 152);
  switch(v10)
  {
    case 1:
      v17 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
      v18 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      std::ostream::flush();
      v19 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
      v20 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      std::ostream::flush();
      v21 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v21 + *(_QWORD *)(*v21 - 24)));
      v22 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      break;
    case 3:
      v13 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(_QWORD *)(*v13 - 24)));
      v14 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      std::ostream::flush();
      v15 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(_QWORD *)(*v15 - 24)));
      v16 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      break;
    case 2:
      v11 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
      v12 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      break;
    default:
      goto LABEL_9;
  }
  std::ostream::flush();
LABEL_9:
  std::ostream::operator<<();
  if (*(_QWORD *)(a1 + 320) - *(_QWORD *)(a1 + 312) >= 9uLL)
  {
    v23 = 1;
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, (uint64_t)" ", 1);
      std::ostream::operator<<();
      ++v23;
    }
    while (v23 < (uint64_t)(*(_QWORD *)(a1 + 320) - *(_QWORD *)(a1 + 312)) >> 3);
  }
  v24 = *(_QWORD *)(a1 + 336);
  if (*(_QWORD *)(a1 + 344) != v24)
  {
    v25 = 0;
    v26 = (std::locale::id *)MEMORY[0x24BEDB350];
    do
    {
      std::ios_base::getloc((const std::ios_base *)&v34[*(_QWORD *)(v33 - 24) - 8]);
      v27 = std::locale::use_facet(&v32, v26);
      ((void (*)(const std::locale::facet *, uint64_t))v27->__vftable[2].~facet_0)(v27, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      std::ostream::flush();
      std::ostream::operator<<();
      v28 = (_QWORD *)(v24 + 16 * v25);
      if (v28[1] - *v28 >= 9uLL)
      {
        v29 = 1;
        do
        {
          std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v33, (uint64_t)" ", 1);
          std::ostream::operator<<();
          ++v29;
        }
        while (v29 < (uint64_t)(v28[1] - *v28) >> 3);
      }
      ++v25;
      v24 = *(_QWORD *)(a1 + 336);
    }
    while (v25 < (*(_QWORD *)(a1 + 344) - v24) >> 4);
  }
  v33 = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)&v34[*(_QWORD *)(v33 - 24) - 8] = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 24);
  MEMORY[0x20BD187C4](v34);
  std::ostream::~ostream();
  return MEMORY[0x20BD188B4](v35);
}

void sub_209CB8820(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10, uint64_t a11)
{
  std::locale::~locale(&a10);
  std::ofstream::~ofstream(&a11);
  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::basic_ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x24BEDB840];
  v3 = MEMORY[0x24BEDB840] + 64;
  a1[52] = MEMORY[0x24BEDB840] + 64;
  v4 = a1 + 1;
  v5 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 8);
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 1);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[52] = v3;
  MEMORY[0x20BD187B8](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_209CB895C(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::ostream::~ostream();
  MEMORY[0x20BD188B4](v1 + 416);
  _Unwind_Resume(a1);
}

_QWORD *std::endl[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1)
{
  const std::locale::facet *v2;
  std::locale v4;

  std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
  v2 = std::locale::use_facet(&v4, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v4);
  std::ostream::put();
  std::ostream::flush();
  return a1;
}

void sub_209CB8A10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::ofstream::~ofstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB7E8];
  v3 = *MEMORY[0x24BEDB7E8];
  *a1 = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x20BD187C4](a1 + 1);
  std::ostream::~ostream();
  MEMORY[0x20BD188B4](a1 + 52);
  return a1;
}

uint64_t CPMLOnlineSvm::PrintParam(CPMLOnlineSvm *this)
{
  _QWORD *v1;
  const std::locale::facet *v2;
  _QWORD *v3;
  const std::locale::facet *v4;
  _QWORD *v5;
  const std::locale::facet *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  _QWORD *v9;
  const std::locale::facet *v10;
  _QWORD *v11;
  const std::locale::facet *v12;
  _QWORD *v13;
  const std::locale::facet *v14;
  _QWORD *v15;
  const std::locale::facet *v16;
  _QWORD *v17;
  const std::locale::facet *v18;
  _QWORD *v19;
  const std::locale::facet *v20;
  _QWORD *v21;
  const std::locale::facet *v22;
  std::locale v24;

  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"kernel = ", 9);
  v1 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v1 + *(_QWORD *)(*v1 - 24)));
  v2 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v2->__vftable[2].~facet_0)(v2, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"param_C = ", 10);
  v3 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v3 + *(_QWORD *)(*v3 - 24)));
  v4 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v4->__vftable[2].~facet_0)(v4, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"tolerance = ", 12);
  v5 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v5 + *(_QWORD *)(*v5 - 24)));
  v6 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v6->__vftable[2].~facet_0)(v6, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"num_online_reprocess = ", 23);
  v7 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
  v8 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"num_final_reprocess = ", 22);
  v9 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v9 + *(_QWORD *)(*v9 - 24)));
  v10 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"rbf_gamma = ", 12);
  v11 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v11 + *(_QWORD *)(*v11 - 24)));
  v12 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v12->__vftable[2].~facet_0)(v12, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"prod_slope = ", 13);
  v13 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(_QWORD *)(*v13 - 24)));
  v14 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"prod_intercept = ", 17);
  v15 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v15 + *(_QWORD *)(*v15 - 24)));
  v16 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v16->__vftable[2].~facet_0)(v16, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"poly_degree = ", 14);
  v17 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
  v18 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"num_features = ", 15);
  v19 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v19 + *(_QWORD *)(*v19 - 24)));
  v20 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v20->__vftable[2].~facet_0)(v20, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"num_compact_features = ", 23);
  v21 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v21 + *(_QWORD *)(*v21 - 24)));
  v22 = std::locale::use_facet(&v24, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v22->__vftable[2].~facet_0)(v22, 10);
  std::locale::~locale(&v24);
  std::ostream::put();
  return std::ostream::flush();
}

void sub_209CB8FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

uint64_t CPMLOnlineSvm::Deserialize(uint64_t a1)
{
  int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t *v8;
  size_t v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v14;
  void *__p;
  char *v16;
  int v17;
  unint64_t v18;
  unint64_t v19;
  _QWORD v20[2];
  _BYTE v21[408];
  _QWORD v22[20];

  v22[19] = *MEMORY[0x24BDAC8D0];
  std::ifstream::basic_ifstream(v20);
  if ((v21[*(_QWORD *)(v20[0] - 24) + 16] & 5) != 0)
  {
    v14 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB310], (uint64_t)"cannot open input file", 22);
    std::endl[abi:ne180100]<char,std::char_traits<char>>(v14);
    exit(1);
  }
  v18 = 0;
  v19 = 0;
  MEMORY[0x20BD187F4](v20, &v19);
  MEMORY[0x20BD187F4](v20, &v18);
  MEMORY[0x20BD187DC](v20, a1 + 304);
  v17 = 0;
  MEMORY[0x20BD187E8](v20, &v17);
  v2 = v17;
  *(_DWORD *)(a1 + 152) = v17;
  switch(v2)
  {
    case 1:
      MEMORY[0x20BD187DC](v20, a1 + 192);
      MEMORY[0x20BD187DC](v20, a1 + 200);
      v3 = a1 + 208;
      break;
    case 2:
      v3 = a1 + 184;
      break;
    case 3:
      MEMORY[0x20BD187DC](v20, a1 + 192);
      v3 = a1 + 200;
      break;
    default:
      goto LABEL_9;
  }
  MEMORY[0x20BD187DC](v20, v3);
LABEL_9:
  std::vector<double>::resize(a1 + 312, v18);
  v4 = *(_QWORD *)(a1 + 312);
  if (*(_QWORD *)(a1 + 320) != v4)
  {
    v5 = 0;
    v6 = 0;
    do
    {
      MEMORY[0x20BD187DC](v20, v4 + v5);
      ++v6;
      v4 = *(_QWORD *)(a1 + 312);
      v5 += 8;
    }
    while (v6 < (*(_QWORD *)(a1 + 320) - v4) >> 3);
  }
  if (v18)
  {
    v7 = 0;
    v8 = (uint64_t *)(a1 + 336);
    do
    {
      __p = 0;
      v16 = 0;
      if (v19)
      {
        if (v19 >> 61)
          std::__throw_bad_array_new_length[abi:ne180100]();
        v9 = 8 * v19;
        v10 = (char *)operator new(8 * v19);
        __p = v10;
        bzero(v10, v9);
        v11 = 0;
        v12 = 0;
        v16 = &v10[v9];
        do
        {
          MEMORY[0x20BD187DC](v20, &v10[v11]);
          ++v12;
          v10 = (char *)__p;
          v11 += 8;
        }
        while (v12 < (v16 - (_BYTE *)__p) >> 3);
      }
      std::vector<std::valarray<double>>::push_back[abi:ne180100](v8, (uint64_t **)&__p);
      if (__p)
      {
        if (v16 != __p)
          v16 += ((_BYTE *)__p - v16 + 7) & 0xFFFFFFFFFFFFFFF8;
        operator delete(__p);
      }
      ++v7;
    }
    while (v18 > v7);
  }
  v20[0] = *MEMORY[0x24BEDB7E0];
  *(_QWORD *)((char *)v20 + *(_QWORD *)(v20[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 24);
  MEMORY[0x20BD187C4](v21);
  std::istream::~istream();
  return MEMORY[0x20BD188B4](v22);
}

void sub_209CB92A4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14)
{
  std::ifstream::~ifstream(&a14);
  _Unwind_Resume(a1);
}

_QWORD *std::ifstream::basic_ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;
  _QWORD *v4;
  uint64_t v5;
  uint64_t v6;
  std::ios_base *v7;

  v2 = MEMORY[0x24BEDB838];
  v3 = MEMORY[0x24BEDB838] + 64;
  a1[53] = MEMORY[0x24BEDB838] + 64;
  v4 = a1 + 2;
  v5 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 8);
  v6 = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 16);
  *a1 = v5;
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v5 - 24)) = v6;
  a1[1] = 0;
  v7 = (std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24));
  std::ios_base::init(v7, a1 + 2);
  v7[1].__vftable = 0;
  v7[1].__fmtflags_ = -1;
  *a1 = v2 + 24;
  a1[53] = v3;
  MEMORY[0x20BD187B8](v4);
  if (!std::filebuf::open())
    std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 4);
  return a1;
}

void sub_209CB93EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::istream::~istream();
  MEMORY[0x20BD188B4](v1 + 424);
  _Unwind_Resume(a1);
}

void std::vector<double>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 8 * a2;
  }
  else
  {
    std::vector<double>::__append((char **)a1, a2 - v2);
  }
}

_QWORD *std::ifstream::~ifstream(_QWORD *a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = MEMORY[0x24BEDB7E0];
  v3 = *MEMORY[0x24BEDB7E0];
  *a1 = *MEMORY[0x24BEDB7E0];
  *(_QWORD *)((char *)a1 + *(_QWORD *)(v3 - 24)) = *(_QWORD *)(v2 + 24);
  MEMORY[0x20BD187C4](a1 + 2);
  std::istream::~istream();
  MEMORY[0x20BD188B4](a1 + 53);
  return a1;
}

double *std::__val_expr<std::_BinaryOp<std::minus<double>,std::valarray<double>,std::valarray<double>>>::operator std::valarray<double>@<X0>(double *result@<X0>, double **a2@<X8>)
{
  uint64_t v3;
  uint64_t v4;
  double *v5;
  uint64_t v6;
  double *v7;
  uint64_t v8;
  double *v9;
  double v10;
  double v11;
  double v12;

  *a2 = 0;
  a2[1] = 0;
  v3 = *((_QWORD *)result + 1);
  v5 = *(double **)v3;
  v4 = *(_QWORD *)(v3 + 8);
  v6 = v4 - *(_QWORD *)v3;
  if (v4 != *(_QWORD *)v3)
  {
    if (v6 < 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v7 = result;
    result = (double *)operator new(v4 - *(_QWORD *)v3);
    v8 = v6 >> 3;
    *a2 = result;
    a2[1] = result;
    v9 = (double *)**((_QWORD **)v7 + 2);
    do
    {
      v10 = *v5++;
      v11 = v10;
      v12 = *v9++;
      *result++ = v11 - v12;
      --v8;
    }
    while (v8);
    a2[1] = result;
  }
  return result;
}

void sub_209CB9528(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::valarray<double>::~valarray(v1);
  _Unwind_Resume(a1);
}

uint64_t CPMLOnlineSvm::LinearSparseKernel(uint64_t a1, char **a2, char **a3)
{
  char v3;
  char *v4;
  char *v5;
  char *v6;
  int v7;
  int v8;
  int v9;

  v3 = 0;
  v4 = *a2;
  v5 = *a3;
  v6 = a3[1];
  do
  {
LABEL_2:
    if (v4 == a2[1] || v5 == v6)
      break;
    v7 = *v4;
    while (1)
    {
      v8 = *v5;
      if (v7 < v8)
      {
        ++v4;
        goto LABEL_2;
      }
      if (v7 <= v8)
        break;
      if (++v5 == v6)
        return v3;
    }
    ++v3;
    v9 = *++v4;
    ++v5;
  }
  while (v9);
  return v3;
}

double CPMLOnlineSvm::PolySparseKernel(uint64_t a1, char **a2, char **a3)
{
  double v4;
  int v5;

  v4 = *(double *)(a1 + 192);
  v5 = CPMLOnlineSvm::LinearSparseKernel(a1, a2, a3);
  return pow(*(double *)(a1 + 200) + v4 * (double)v5, *(long double *)(a1 + 208));
}

double CPMLOnlineSvm::RbfSparseKernel(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned __int8 *v6;
  int v7;
  unsigned __int8 *v8;
  int v9;
  long double v10;

  v3 = *(_QWORD *)(a2 + 8);
  v4 = *(_QWORD *)(a3 + 8);
  v5 = v3 + v4 - *(_QWORD *)a2 - *(_QWORD *)a3 + 2;
  v6 = (unsigned __int8 *)(v3 - 1);
  do
  {
    v7 = *v6--;
    --v5;
  }
  while (!v7);
  v8 = (unsigned __int8 *)(v4 - 1);
  do
  {
    v9 = *v8--;
    --v5;
  }
  while (!v9);
  v10 = -(*(double *)(a1 + 184)
        * (double)(unint64_t)(v5 - 2 * (int)CPMLOnlineSvm::LinearSparseKernel(a1, (char **)a2, (char **)a3)));
  return exp(v10);
}

double CPMLOnlineSvm::SigmoidSparseKernel(uint64_t a1, char **a2, char **a3)
{
  long double v3;

  v3 = *(double *)(a1 + 200) + *(double *)(a1 + 192) * (double)(int)CPMLOnlineSvm::LinearSparseKernel(a1, a2, a3);
  return tanh(v3);
}

void CPMLOnlineSvm::CompressPredictors(CPMLOnlineSvm *this, int a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  unint64_t v8;
  uint64_t v9;
  char *v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  void *__p;
  char *v16;

  v4 = (uint64_t *)*((_QWORD *)this + 32);
  v6 = *v4;
  v5 = v4[1];
  v7 = (uint64_t *)((char *)this + 280);
  std::vector<std::valarray<char>>::__base_destruct_at_end[abi:ne180100]((uint64_t)this + 280, *((_QWORD **)this + 35));
  if (*((_QWORD *)this + 33) != *((_QWORD *)this + 32))
  {
    v8 = 0;
    if ((unint64_t)((v5 - v6) >> 3) <= 1)
      v9 = 1;
    else
      v9 = (v5 - v6) >> 3;
    do
    {
      __p = 0;
      v16 = 0;
      if (a2)
      {
        v10 = (char *)operator new(a2);
        __p = v10;
        v16 = v10;
        v11 = a2;
        do
        {
          *v10 = 0;
          v10 = ++v16;
          --v11;
        }
        while (v11);
      }
      if (v5 != v6)
      {
        v12 = 0;
        v13 = 0;
        do
        {
          if (*(double *)(*(_QWORD *)(*((_QWORD *)this + 32) + 16 * v8) + 8 * v12) != 0.0 && v13 < a2)
            *((_BYTE *)__p + v13++) = v12;
          ++v12;
        }
        while (v9 != v12);
      }
      std::vector<std::valarray<char>>::push_back[abi:ne180100](v7, (char **)&__p);
      if (__p)
      {
        if (v16 != __p)
          v16 = (char *)__p;
        operator delete(__p);
      }
      ++v8;
    }
    while (v8 < (uint64_t)(*((_QWORD *)this + 33) - *((_QWORD *)this + 32)) >> 4);
  }
}

void sub_209CB9794(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::valarray<char>>::push_back[abi:ne180100](uint64_t *a1, char **a2)
{
  uint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  _QWORD *v17;
  char *v18;
  uint64_t v19;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (v7 >= v6)
  {
    v10 = (uint64_t)(v7 - *a1) >> 4;
    if ((unint64_t)(v10 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - *a1;
    v12 = v11 >> 3;
    if (v11 >> 3 <= (unint64_t)(v10 + 1))
      v12 = v10 + 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v13 = 0xFFFFFFFFFFFFFFFLL;
    else
      v13 = v12;
    v19 = v4;
    if (v13)
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(v4, v13);
    else
      v14 = 0;
    v15 = v14;
    v16 = &v14[16 * v10];
    v18 = &v14[16 * v13];
    std::valarray<char>::valarray(v16, a2);
    v17 = v16 + 16;
    std::vector<std::valarray<char>>::__swap_out_circular_buffer(a1, &v15);
    v9 = a1[1];
    result = std::__split_buffer<std::valarray<char>>::~__split_buffer((uint64_t)&v15);
  }
  else
  {
    result = (uint64_t)std::valarray<char>::valarray(*(_QWORD **)(v4 - 8), a2);
    v9 = v7 + 16;
    a1[1] = v7 + 16;
  }
  a1[1] = v9;
  return result;
}

void sub_209CB98AC(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10)
{
  uint64_t v10;
  uint64_t v11;

  *(_QWORD *)(v10 + 8) = v11;
  _Unwind_Resume(exception_object);
}

void CPMLOnlineSvm::~CPMLOnlineSvm(CPMLOnlineSvm *this)
{
  CPMLOnlineSvm::~CPMLOnlineSvm(this);
  JUMPOUT(0x20BD188E4);
}

{
  _BYTE *v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  void *v8;
  _BYTE *v9;
  _BYTE *v10;
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  uint64_t v15;
  void **v16;

  *(_QWORD *)this = &off_24C255288;
  v2 = (_BYTE *)*((_QWORD *)this + 63);
  if (v2)
  {
    v3 = (_BYTE *)*((_QWORD *)this + 64);
    if (v3 != v2)
      *((_QWORD *)this + 64) = &v3[(v2 - v3 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v2);
    *((_QWORD *)this + 63) = 0;
    *((_QWORD *)this + 64) = 0;
  }
  v4 = (_BYTE *)*((_QWORD *)this + 61);
  if (v4)
  {
    v5 = (_BYTE *)*((_QWORD *)this + 62);
    if (v5 != v4)
      *((_QWORD *)this + 62) = &v5[(v4 - v5 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v4);
    *((_QWORD *)this + 61) = 0;
    *((_QWORD *)this + 62) = 0;
  }
  v6 = (_BYTE *)*((_QWORD *)this + 59);
  if (v6)
  {
    v7 = (_BYTE *)*((_QWORD *)this + 60);
    if (v7 != v6)
      *((_QWORD *)this + 60) = &v7[(v6 - v7 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v6);
    *((_QWORD *)this + 59) = 0;
    *((_QWORD *)this + 60) = 0;
  }
  v8 = (void *)*((_QWORD *)this + 54);
  if (v8)
  {
    *((_QWORD *)this + 55) = v8;
    operator delete(v8);
  }
  v9 = (_BYTE *)*((_QWORD *)this + 52);
  if (v9)
  {
    v10 = (_BYTE *)*((_QWORD *)this + 53);
    if (v10 != v9)
      *((_QWORD *)this + 53) = &v10[(v9 - v10 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v9);
    *((_QWORD *)this + 52) = 0;
    *((_QWORD *)this + 53) = 0;
  }
  v11 = (void *)*((_QWORD *)this + 48);
  if (v11)
  {
    *((_QWORD *)this + 49) = v11;
    operator delete(v11);
  }
  v12 = (void *)*((_QWORD *)this + 45);
  if (v12)
  {
    *((_QWORD *)this + 46) = v12;
    operator delete(v12);
  }
  v16 = (void **)((char *)this + 336);
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100](&v16);
  v13 = (void *)*((_QWORD *)this + 39);
  if (v13)
  {
    *((_QWORD *)this + 40) = v13;
    operator delete(v13);
  }
  v16 = (void **)((char *)this + 280);
  std::vector<std::valarray<char>>::__destroy_vector::operator()[abi:ne180100](&v16);
  v16 = (void **)((char *)this + 256);
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100](&v16);
  v14 = (void *)*((_QWORD *)this + 29);
  if (v14)
  {
    *((_QWORD *)this + 30) = v14;
    operator delete(v14);
  }
  if (*((_QWORD *)this + 17))
  {
    v15 = *((_QWORD *)this + 12);
    if (v15)
      MEMORY[0x20BD188CC](v15, 0x1000C8000313F17);
  }
  CPModelClose(this);
}

uint64_t CPMLOnlineSvm::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t *RealVector;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  int v11;
  double v12;
  void *__p;
  _BYTE *v15;

  RealVector = (uint64_t *)CPMLFeatureVector::getRealVector(this);
  v5 = *RealVector;
  v6 = (RealVector[1] - *RealVector) >> 3;
  __p = 0;
  v15 = 0;
  v7 = v6 - 1;
  if (v6 != 1)
  {
    if (v7 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v8 = operator new(8 * v7);
    __p = v8;
    bzero(v8, 8 * v7);
    v15 = &v8[v7];
    v9 = (uint64_t *)(v5 + 8);
    do
    {
      v10 = *v9++;
      *v8++ = v10;
      --v7;
    }
    while (v7);
  }
  v11 = CPMLOnlineSvm::Evaluate(a1, (uint64_t)&__p);
  v12 = 0.0;
  if (v11 != -1)
    v12 = 1.0;
  CPMLFeatureVector::setYHat((uint64_t)this, v12);
  if (__p)
  {
    if (v15 != __p)
      v15 += ((_BYTE *)__p - v15 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(__p);
  }
  return 0;
}

void sub_209CB99E4(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLOnlineSvm::train(CPMLOnlineSvm *this)
{
  uint64_t v2;
  uint64_t v3;

  CPMLOnlineSvm::Init(this);
  CPMLOnlineSvm::OnlineIteration(this, v2, v3);
  return 0;
}

uint64_t CPMLAlgorithm::requireIntsOnly(CPMLAlgorithm *this)
{
  return 0;
}

uint64_t CPMLOnlineSvm::requireRealOnly(CPMLOnlineSvm *this)
{
  return 1;
}

uint64_t CPMLOnlineSvm::errorString(CPMLOnlineSvm *this)
{
  return 0;
}

uint64_t CPMLAlgorithm::getModelData(CPMLAlgorithm *this)
{
  return 0;
}

void __clang_call_terminate(void *a1)
{
  __cxa_begin_catch(a1);
  std::terminate();
}

void std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void *v2;
  uint64_t v4;
  void *v5;

  v1 = *a1;
  v2 = **a1;
  if (v2)
  {
    v4 = (uint64_t)v1[1];
    v5 = **a1;
    if ((void *)v4 != v2)
    {
      do
      {
        v4 -= 16;
        std::allocator<std::valarray<double>>::destroy[abi:ne180100]((uint64_t)(v1 + 2), v4);
      }
      while ((void *)v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

void std::allocator<std::valarray<double>>::destroy[abi:ne180100](uint64_t a1, uint64_t a2)
{
  _BYTE *v2;
  _BYTE *v4;

  v2 = *(_BYTE **)a2;
  if (*(_QWORD *)a2)
  {
    v4 = *(_BYTE **)(a2 + 8);
    if (v4 != v2)
      *(_QWORD *)(a2 + 8) = &v4[(v2 - v4 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v2);
    *(_QWORD *)a2 = 0;
    *(_QWORD *)(a2 + 8) = 0;
  }
}

void std::vector<std::valarray<char>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::valarray<char>>::__base_destruct_at_end[abi:ne180100]((uint64_t)v2, *v2);
    operator delete(**a1);
  }
}

void std::vector<std::valarray<char>>::__base_destruct_at_end[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  _QWORD *v4;
  _QWORD *v5;
  void *v6;
  void *v7;

  v4 = *(_QWORD **)(a1 + 8);
  if (v4 != a2)
  {
    v5 = *(_QWORD **)(a1 + 8);
    do
    {
      v7 = (void *)*(v5 - 2);
      v5 -= 2;
      v6 = v7;
      if (v7)
      {
        if ((void *)v5[1] != v6)
          *(v4 - 1) = v6;
        operator delete(v6);
        *v5 = 0;
        v5[1] = 0;
      }
      v4 = v5;
    }
    while (v5 != a2);
  }
  *(_QWORD *)(a1 + 8) = a2;
}

_QWORD *CoreMatrix::Matrix<double>::Resize(_QWORD *result, unint64_t a2)
{
  _QWORD *v3;
  unint64_t v4;

  v3 = result;
  v4 = result[5];
  if (v4 < a2)
  {
    if (v4 && *result)
      MEMORY[0x20BD188CC]();
    result = (_QWORD *)operator new[]();
    *v3 = result;
  }
  v3[5] = a2;
  return result;
}

void std::vector<double>::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("vector");
}

void std::__throw_length_error[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::length_error::length_error[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24C254820, MEMORY[0x24BEDAAF0]);
}

void sub_209CB9E64(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::length_error::length_error[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8B8] + 16);
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 61)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(8 * a2);
}

void std::__throw_bad_array_new_length[abi:ne180100]()
{
  std::bad_array_new_length *exception;
  std::bad_array_new_length *v1;

  exception = (std::bad_array_new_length *)__cxa_allocate_exception(8uLL);
  v1 = std::bad_array_new_length::bad_array_new_length(exception);
  __cxa_throw(v1, MEMORY[0x24BEDB748], MEMORY[0x24BEDABB8]);
}

_QWORD *std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  const std::locale::facet *v10;
  uint64_t v11;
  _BYTE v13[16];
  std::locale v14;

  MEMORY[0x20BD18824](v13, a1);
  if (v13[0])
  {
    v6 = (uint64_t)a1 + *(_QWORD *)(*a1 - 24);
    v7 = *(_QWORD *)(v6 + 40);
    v8 = *(_DWORD *)(v6 + 8);
    v9 = *(_DWORD *)(v6 + 144);
    if (v9 == -1)
    {
      std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)));
      v10 = std::locale::use_facet(&v14, MEMORY[0x24BEDB350]);
      v9 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v10->__vftable[2].~facet_0)(v10, 32);
      std::locale::~locale(&v14);
      *(_DWORD *)(v6 + 144) = v9;
    }
    if ((v8 & 0xB0) == 0x20)
      v11 = a2 + a3;
    else
      v11 = a2;
    if (!std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(v7, a2, v11, a2 + a3, v6, (char)v9))
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(_QWORD *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(_QWORD *)(*a1 - 24) + 32) | 5);
  }
  MEMORY[0x20BD18830](v13);
  return a1;
}

void sub_209CBA000(void *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char a10, uint64_t a11, std::locale a12)
{
  _QWORD *v12;

  MEMORY[0x20BD18830](&a10);
  __cxa_begin_catch(a1);
  std::ios_base::__set_badbit_and_consider_rethrow((std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  __cxa_end_catch();
  JUMPOUT(0x209CB9FE0);
}

void sub_209CBA048(_Unwind_Exception *a1)
{
  __cxa_end_catch();
  _Unwind_Resume(a1);
}

uint64_t std::__pad_and_output[abi:ne180100]<char,std::char_traits<char>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, int __c)
{
  uint64_t v6;
  uint64_t v11;
  int64_t v12;
  void **v13;
  uint64_t v14;
  uint64_t v15;
  void *__p[2];
  char v18;

  v6 = a1;
  if (a1)
  {
    v11 = *(_QWORD *)(a5 + 24);
    if (v11 <= a4 - a2)
      v12 = 0;
    else
      v12 = v11 - (a4 - a2);
    if (a3 - a2 >= 1 && (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 96))(a1) != a3 - a2)
      return 0;
    if (v12 >= 1)
    {
      std::string::basic_string[abi:ne180100](__p, v12, __c);
      v13 = v18 >= 0 ? __p : (void **)__p[0];
      v14 = (*(uint64_t (**)(uint64_t, void **, int64_t))(*(_QWORD *)v6 + 96))(v6, v13, v12);
      if (v18 < 0)
        operator delete(__p[0]);
      if (v14 != v12)
        return 0;
    }
    v15 = a4 - a3;
    if (v15 < 1 || (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 96))(v6, a3, v15) == v15)
      *(_QWORD *)(a5 + 24) = 0;
    else
      return 0;
  }
  return v6;
}

void sub_209CBA17C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

_QWORD *std::string::basic_string[abi:ne180100](_QWORD *__b, size_t __len, int __c)
{
  void *v6;
  size_t v7;
  size_t v8;

  if (__len >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  if (__len >= 0x17)
  {
    v7 = (__len & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__len | 7) != 0x17)
      v7 = __len | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    __b[1] = __len;
    __b[2] = v8 | 0x8000000000000000;
    *__b = v6;
  }
  else
  {
    *((_BYTE *)__b + 23) = __len;
    v6 = __b;
    if (!__len)
      goto LABEL_9;
  }
  memset(v6, __c, __len);
LABEL_9:
  *((_BYTE *)v6 + __len) = 0;
  return __b;
}

void std::string::__throw_length_error[abi:ne180100]()
{
  std::__throw_length_error[abi:ne180100]("basic_string");
}

_QWORD *std::valarray<char>::valarray(_QWORD *a1, char **a2)
{
  char *v3;
  _BYTE *v5;
  char *v6;
  char v7;

  *a1 = 0;
  a1[1] = 0;
  v3 = a2[1];
  if (v3 != *a2)
  {
    v5 = operator new(v3 - *a2);
    *a1 = v5;
    a1[1] = v5;
    v6 = *a2;
    while (v6 != a2[1])
    {
      v7 = *v6++;
      *v5 = v7;
      v5 = (_BYTE *)(a1[1] + 1);
      a1[1] = v5;
    }
  }
  return a1;
}

uint64_t std::vector<std::valarray<char>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>,std::reverse_iterator<std::valarray<char>*>,std::reverse_iterator<std::valarray<char>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 60)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(16 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>,std::reverse_iterator<std::valarray<char>*>,std::reverse_iterator<std::valarray<char>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_OWORD *)(a7 - 16);
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<char>>,std::reverse_iterator<std::valarray<char>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t *v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t v7;
  _BYTE v8[8];
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _BYTE v13[8];
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;

  v18 = *MEMORY[0x24BDAC8D0];
  v1 = (uint64_t *)a1[2];
  v3 = *v1;
  v2 = v1[1];
  v14 = v3;
  v15 = v2;
  v16 = v3;
  v17 = v2;
  v4 = *a1;
  v5 = (uint64_t *)a1[1];
  v7 = *v5;
  v6 = v5[1];
  v9 = v7;
  v10 = v6;
  v11 = v7;
  v12 = v6;
  std::__allocator_destroy[abi:ne180100]<std::allocator<std::valarray<char>>,std::reverse_iterator<std::reverse_iterator<std::valarray<char>*>>,std::reverse_iterator<std::reverse_iterator<std::valarray<char>*>>>(v4, (uint64_t)v13, (uint64_t)v8);
}

void std::__allocator_destroy[abi:ne180100]<std::allocator<std::valarray<char>>,std::reverse_iterator<std::reverse_iterator<std::valarray<char>*>>,std::reverse_iterator<std::reverse_iterator<std::valarray<char>*>>>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t i;
  void *v6;

  for (i = *(_QWORD *)(a2 + 32); i != *(_QWORD *)(a3 + 32); *(_QWORD *)(a2 + 32) = i)
  {
    v6 = *(void **)i;
    if (*(_QWORD *)i)
    {
      if (*(void **)(i + 8) != v6)
        *(_QWORD *)(i + 8) = v6;
      operator delete(v6);
      *(_QWORD *)i = 0;
      *(_QWORD *)(i + 8) = 0;
      i = *(_QWORD *)(a2 + 32);
    }
    i += 16;
  }
}

uint64_t std::__split_buffer<std::valarray<char>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::valarray<char>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD **)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::valarray<char>>::__destruct_at_end[abi:ne180100](uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v5;
  void *v6;
  void *v7;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2 != a2)
  {
    v5 = *(_QWORD **)(a1 + 16);
    do
    {
      v7 = (void *)*(v5 - 2);
      v5 -= 2;
      v6 = v7;
      *(_QWORD *)(a1 + 16) = v5;
      if (v7)
      {
        if ((void *)v5[1] != v6)
          *(v2 - 1) = v6;
        operator delete(v6);
        *v5 = 0;
        v5[1] = 0;
        v5 = *(_QWORD **)(a1 + 16);
      }
      v2 = v5;
    }
    while (v5 != a2);
  }
}

uint64_t std::vector<std::valarray<double>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>,std::reverse_iterator<std::valarray<double>*>,std::reverse_iterator<std::valarray<double>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>,std::reverse_iterator<std::valarray<double>*>,std::reverse_iterator<std::valarray<double>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  _OWORD *v8;
  __int128 v9;
  uint64_t v10;
  _QWORD v12[3];
  char v13;
  __int128 v14;
  __int128 v15;

  v7 = a7;
  *(_QWORD *)&v15 = a6;
  *((_QWORD *)&v15 + 1) = a7;
  v14 = v15;
  v12[0] = a1;
  v12[1] = &v14;
  v12[2] = &v15;
  if (a3 == a5)
  {
    v10 = a6;
  }
  else
  {
    v8 = (_OWORD *)(a7 - 16);
    do
    {
      v9 = *((_OWORD *)a3 - 1);
      a3 -= 2;
      *v8 = v9;
      *a3 = 0;
      a3[1] = 0;
      *((_QWORD *)&v15 + 1) = v8;
      v7 -= 16;
      --v8;
    }
    while (a3 != a5);
    v10 = v15;
  }
  v13 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v12);
  return v10;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>>::operator()[abi:ne180100]((uint64_t *)a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::valarray<double>>,std::reverse_iterator<std::valarray<double>*>>::operator()[abi:ne180100](uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;

  v1 = *(_QWORD *)(a1[2] + 8);
  v2 = *(_QWORD *)(a1[1] + 8);
  if (v1 != v2)
  {
    v3 = *a1;
    do
    {
      std::allocator<std::valarray<double>>::destroy[abi:ne180100](v3, v1);
      v1 += 16;
    }
    while (v1 != v2);
  }
}

void **std::__split_buffer<std::valarray<double>>::~__split_buffer(void **a1)
{
  std::__split_buffer<std::valarray<double>>::clear[abi:ne180100](a1);
  if (*a1)
    operator delete(*a1);
  return a1;
}

void std::__split_buffer<std::valarray<double>>::clear[abi:ne180100](_QWORD *a1)
{
  uint64_t i;
  uint64_t v2;
  uint64_t v4;

  v2 = a1[1];
  for (i = a1[2]; i != v2; i = a1[2])
  {
    v4 = a1[4];
    a1[2] = i - 16;
    std::allocator<std::valarray<double>>::destroy[abi:ne180100](v4, i - 16);
  }
}

void std::vector<double>::__append(char **a1, unint64_t a2)
{
  uint64_t v4;
  char *v5;
  char *v6;
  char *v7;
  char *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 3)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 8 * a2);
      v7 += 8 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = *a1;
    v9 = v7 - *a1;
    v10 = a2 + (v9 >> 3);
    if (v10 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v9 >> 3;
    v12 = v5 - v8;
    if (v12 >> 2 > v10)
      v10 = v12 >> 2;
    if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFF8)
      v13 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v13 = v10;
    if (v13)
    {
      v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v4, v13);
      v8 = *a1;
      v7 = a1[1];
    }
    else
    {
      v14 = 0;
    }
    v15 = &v14[8 * v11];
    v16 = &v14[8 * v13];
    bzero(v15, 8 * a2);
    v17 = &v15[8 * a2];
    while (v7 != v8)
    {
      v18 = *((_QWORD *)v7 - 1);
      v7 -= 8;
      *((_QWORD *)v15 - 1) = v18;
      v15 -= 8;
    }
    *a1 = v15;
    a1[1] = v17;
    a1[2] = v16;
    if (v8)
      operator delete(v8);
  }
}

_QWORD *std::valarray<double>::valarray(_QWORD *a1, uint64_t **a2)
{
  uint64_t *v3;
  size_t v4;
  char *v6;
  uint64_t *v7;
  char *v8;
  uint64_t v9;

  *a1 = 0;
  a1[1] = 0;
  v3 = a2[1];
  v4 = (char *)v3 - (char *)*a2;
  if (v3 != *a2)
  {
    if ((v4 & 0x8000000000000000) != 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v6 = (char *)operator new(v4);
    *a1 = v6;
    a1[1] = v6;
    v7 = *a2;
    if (*a2 != a2[1])
    {
      v8 = v6 + 8;
      do
      {
        v9 = *v7++;
        *((_QWORD *)v8 - 1) = v9;
        a1[1] = v8;
        v8 += 8;
      }
      while (v7 != a2[1]);
    }
  }
  return a1;
}

uint64_t std::__move_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::valarray<double> *,std::valarray<double> *,std::valarray<double> *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;
  _BYTE *v7;
  _BYTE *v8;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      v7 = *(_BYTE **)a4;
      if (*(_QWORD *)a4)
      {
        v8 = *(_BYTE **)(a4 + 8);
        if (v8 != v7)
          *(_QWORD *)(a4 + 8) = &v8[(v7 - v8 + 7) & 0xFFFFFFFFFFFFFFF8];
        operator delete(v7);
        *(_QWORD *)a4 = 0;
        *(_QWORD *)(a4 + 8) = 0;
      }
      *(_OWORD *)a4 = *(_OWORD *)v5;
      a4 += 16;
      *(_QWORD *)v5 = 0;
      *(_QWORD *)(v5 + 8) = 0;
      v5 += 16;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void OUTLINED_FUNCTION_0(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 88, a4);
}

void OUTLINED_FUNCTION_1(const char *a1, const char *a2, uint64_t a3, const char *a4)
{
  __assert_rtn(a1, a2, 89, a4);
}

double CPMLLINEARSVMClassifier::establishParam(CPMLLINEARSVMClassifier *this, CPMLTunableData *a2)
{
  int v18;
  double result;
  uint64_t v20;
  _BYTE v21[19];
  uint64_t v22;

  v22 = *MEMORY[0x24BDAC8D0];
  if (!a2 || (int)CPMLTunableData::getNumberOfItems(a2) < 1)
  {
    *((_DWORD *)this + 40) = 1;
    *(_OWORD *)((char *)this + 168) = xmmword_209CFFFA0;
    *((_DWORD *)this + 46) = 0;
    *((_DWORD *)this + 56) = 0;
    *((_QWORD *)this + 24) = 0;
    *((_QWORD *)this + 25) = 0;
    result = 0.1;
    *((_OWORD *)this + 13) = xmmword_209CFFFB0;
LABEL_72:
    v20 = *((int *)this + 40);
    if (v20 <= 0xD && ((0x38FFu >> v20) & 1) != 0)
    {
      result = dbl_209CFFFE0[v20];
      *((double *)this + 21) = result;
    }
    return result;
  }
  CPMLTunableData::tDataGetString(a2, "solver_type", v21, 0x18uLL);
  if (*(_DWORD *)v21 == 1599222348 && *(unsigned __int16 *)&v21[4] == 21068)
  {
    *((_DWORD *)this + 40) = 0;
    goto LABEL_69;
  }
  if (*(_QWORD *)v21 != 0x4F4C324C5F52324CLL
    || *(_QWORD *)&v21[8] != 0x445F4356535F5353
    || *(_QWORD *)&v21[11] != 0x4C4155445F435653)
  {
    if (*(_QWORD *)v21 == 0x4F4C324C5F52324CLL && *(_QWORD *)&v21[6] == 0x4356535F53534F4CLL)
    {
      v18 = 2;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x4F4C314C5F52324CLL
      && *(_QWORD *)&v21[8] == 0x445F4356535F5353
      && *(_QWORD *)&v21[11] == 0x4C4155445F435653)
    {
      v18 = 3;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x53435F4D5653434DLL)
    {
      v18 = 4;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x4F4C324C5F52314CLL && *(_QWORD *)&v21[6] == 0x4356535F53534F4CLL)
    {
      v18 = 5;
      goto LABEL_68;
    }
    if (*(_DWORD *)v21 == 1599222092 && *(unsigned __int16 *)&v21[4] == 21068)
    {
      v18 = 6;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x445F524C5F52324CLL && *(_QWORD *)&v21[3] == 0x4C4155445F524C5FLL)
    {
      v18 = 7;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x4F4C324C5F52324CLL && *(_QWORD *)&v21[6] == 0x5256535F53534F4CLL)
    {
      v18 = 11;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x4F4C324C5F52324CLL
      && *(_QWORD *)&v21[8] == 0x445F5256535F5353
      && *(_QWORD *)&v21[11] == 0x4C4155445F525653)
    {
      v18 = 12;
      goto LABEL_68;
    }
    if (*(_QWORD *)v21 == 0x4F4C314C5F52324CLL
      && *(_QWORD *)&v21[8] == 0x445F5256535F5353
      && *(_QWORD *)&v21[11] == 0x4C4155445F525653)
    {
      v18 = 13;
      goto LABEL_68;
    }
  }
  v18 = 1;
LABEL_68:
  *((_DWORD *)this + 40) = v18;
LABEL_69:
  CPMLTunableData::tDataGetDouble(a2, "C", (double *)this + 22);
  CPMLTunableData::tDataGetDouble(a2, "eps", (double *)this + 21);
  CPMLTunableData::tDataGetDouble(a2, "p", (double *)this + 26);
  if (CPMLTunableData::tDataGetDouble(a2, "bias", (double *)this + 27) == -1)
    *((_QWORD *)this + 27) = 0xBFF0000000000000;
  CPMLTunableData::tDataGetInt(a2, "cross_validation", (int *)this + 56);
  *((_DWORD *)this + 46) = 0;
  *((_QWORD *)this + 24) = 0;
  *((_QWORD *)this + 25) = 0;
  result = *((double *)this + 21);
  if (result == INFINITY)
    goto LABEL_72;
  return result;
}

void CPMLLINEARSVMClassifier::CPMLLINEARSVMClassifier(CPMLLINEARSVMClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v7;
  CPMLStatistics *var0;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Iterator;
  uint64_t v21;
  int v22;
  CPMLFeatureVector *v23;
  char *v24;
  uint64_t *IntVector;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  int v29;
  int v30;
  uint64_t v31;
  int v32;
  double v33;
  double *v34;
  uint64_t RealVector;
  double *v36;
  unint64_t v37;
  int v38;
  uint64_t v39;
  double v40;
  double *v41;
  double v42;
  double *v43;
  double *v44;
  double YHat;
  uint64_t v46;
  uint64_t v47;
  uint64_t i;
  uint64_t v49;
  int *v50;
  int v51;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v7 = &off_24C255818;
  strcpy((char *)(v7 + 8), "1.96");
  var0 = a2->var0;
  v9 = *((int *)a2->var0 + 30);
  v11 = *((int *)a2->var0 + 32);
  v10 = *((int *)a2->var0 + 33);
  *(_QWORD *)(v7 + 96) = *((int *)a2->var0 + 31);
  *(_QWORD *)(v7 + 104) = v10;
  v12 = *((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3);
  v13 = *(_QWORD *)var0;
  v14 = ((*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2);
  *(_QWORD *)(v7 + 128) = v14;
  *(_QWORD *)(v7 + 136) = v13;
  *(_BYTE *)(v7 + 272) = 0;
  v15 = v12 >> 3;
  *(_QWORD *)(v7 + 112) = v9;
  *(_QWORD *)(v7 + 120) = v15;
  LODWORD(var0) = *(_DWORD *)(*((_QWORD *)var0 + 9) + 4 * v11);
  v16 = (_DWORD)var0 == 0;
  if ((_DWORD)var0)
    v17 = v15;
  else
    v17 = v14;
  v18 = 120;
  if (v16)
    v18 = 128;
  *(_QWORD *)(v7 + v18) = v17 - 1;
  CPMLLINEARSVMClassifier::establishParam((CPMLLINEARSVMClassifier *)v7, a4);
  v19 = *((_QWORD *)this + 14);
  *((_DWORD *)this + 58) = v19;
  *((_QWORD *)this + 30) = malloc_type_calloc((int)v19, 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 31) = malloc_type_calloc(*((int *)this + 58), 8uLL, 0x2004093837F09uLL);
  *((_QWORD *)this + 32) = *((_QWORD *)this + 27);
  Iterator = CPMLCDB::getIterator(a2, 0, 0, 0);
  v21 = 0;
  v22 = 0;
  for (*((_QWORD *)this + 10) = Iterator; ; Iterator = *((_QWORD *)this + 10))
  {
    v23 = (CPMLFeatureVector *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
    if (!v23)
      break;
    v24 = (char *)malloc_type_calloc(*((_QWORD *)this + 12) + 2, 0x10uLL, 0x1000040F7F8B94BuLL);
    IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(v23);
    v26 = *IntVector;
    v27 = IntVector[1] - *IntVector;
    if ((int)(v27 >> 2) < 1)
    {
      v30 = 0;
      v29 = 0;
    }
    else
    {
      v28 = 0;
      v29 = 0;
      v30 = 0;
      v31 = (v27 >> 2);
      do
      {
        v32 = *(_DWORD *)(v26 + 4 * v28);
        if (v32)
        {
          v33 = (double)v32;
          ++v28;
          v34 = (double *)&v24[16 * v30];
          *(_DWORD *)v34 = v28;
          v34[1] = v33;
          ++v30;
          v29 = v28;
        }
        else
        {
          ++v28;
        }
      }
      while (v28 != v31);
    }
    RealVector = CPMLFeatureVector::getRealVector(v23);
    v36 = *(double **)RealVector;
    v37 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
    if ((int)(v37 >> 3) >= 1)
    {
      v38 = ((unint64_t)(IntVector[1] - *IntVector) >> 2) + 1;
      v39 = (v37 >> 3);
      do
      {
        v40 = *v36;
        if (*v36 != 0.0)
        {
          v41 = (double *)&v24[16 * v30];
          *(_DWORD *)v41 = v38;
          v41[1] = v40;
          ++v30;
          v29 = v38;
        }
        ++v36;
        ++v38;
        --v39;
      }
      while (v39);
    }
    if (v29 > v22)
      v22 = v29;
    v42 = *((double *)this + 27);
    if (v42 >= 0.0)
    {
      v43 = (double *)&v24[16 * v30];
      v43[1] = v42;
      *(_DWORD *)v43 = 0;
      ++v30;
    }
    v44 = (double *)&v24[16 * v30];
    *(_DWORD *)v44 = -1;
    v44[1] = nan("");
    *(_QWORD *)(*((_QWORD *)this + 31) + 8 * v21) = malloc_type_realloc(v24, 16 * (v30 + 1), 0x1000040F7F8B94BuLL);
    if (*((_QWORD *)this + 13) == 2)
    {
      if (CPMLFeatureVector::getYHat(v23) == 0.0)
        YHat = -1.0;
      else
        YHat = 1.0;
    }
    else
    {
      YHat = CPMLFeatureVector::getYHat(v23);
    }
    *(double *)(*((_QWORD *)this + 30) + 8 * v21++) = YHat;
  }
  if (*((double *)this + 32) >= 0.0)
  {
    *((_DWORD *)this + 59) = v22 + 1;
    v46 = *((unsigned int *)this + 58);
    if ((int)v46 >= 2)
    {
      v47 = *((_QWORD *)this + 31);
      for (i = 1; i != v46; ++i)
      {
        v49 = 0xFFFFFFFE00000000;
        v50 = *(int **)(v47 + 8 * i);
        do
        {
          v51 = *v50;
          v50 += 4;
          v49 += 0x100000000;
        }
        while (v51 != -1);
        *(_DWORD *)(*(_QWORD *)(v47 + 8 * i) + (v49 >> 28)) = v22 + 1;
      }
    }
  }
  else
  {
    *((_DWORD *)this + 59) = v22;
  }
}

void sub_209CBB078(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLLINEARSVMClassifier::CPMLLINEARSVMClassifier(CPMLLINEARSVMClassifier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v5;
  void *v6;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v5 = &off_24C255818;
  *(_BYTE *)(v5 + 272) = 0;
  (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, v5 + 8, "version", 5, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 112, "totalRows", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 96, "featureVectorSpace", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 104, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 120, "continousFeatureCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 128, "discreteFeatureCount", 1, 0);
  v6 = malloc_type_calloc(1uLL, 0x58uLL, 0x10900405E350820uLL);
  *((_QWORD *)this + 33) = v6;
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), (uint64_t)v6 + 56, "model_nr_class", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), *((_QWORD *)this + 33) + 60, "model_nr_feature", 1, 0);
  *(_QWORD *)(*((_QWORD *)this + 33) + 64) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 33) + 60)* (uint64_t)*(int *)(*((_QWORD *)this + 33) + 56), 8uLL, 0x100004000313F17uLL);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11));
  *(_QWORD *)(*((_QWORD *)this + 33) + 72) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 33) + 56), 4uLL, 0x100004052888210uLL);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11));
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), (char *)this + 216, "bias", 1, 0);
}

void sub_209CBB2F4(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLLINEARSVMClassifier::CPMLLINEARSVMClassifier(CPMLLINEARSVMClassifier *this, int *a2, CPMLTunableData *a3)
{
  uint64_t v4;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, 0, a3);
  *(_QWORD *)v4 = &off_24C255818;
  *(_QWORD *)(v4 + 264) = a2;
  *(_BYTE *)(v4 + 272) = 1;
  *(_QWORD *)(v4 + 240) = 0;
  *(_QWORD *)(v4 + 248) = 0;
  *(_QWORD *)(v4 + 104) = a2[14];
}

void CPMLLINEARSVMClassifier::~CPMLLINEARSVMClassifier(CPMLLINEARSVMClassifier *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C255818;
  v2 = (void *)*((_QWORD *)this + 30);
  if (v2)
    free(v2);
  *((_QWORD *)this + 30) = 0;
  v3 = (void *)*((_QWORD *)this + 31);
  if (v3)
    free(v3);
  *((_QWORD *)this + 31) = 0;
  if (*((_QWORD *)this + 33) && !*((_BYTE *)this + 272))
    free_and_destroy_model((uint64_t *)this + 33);
  *((_QWORD *)this + 33) = 0;
  CPModelClose(this);
}

{
  CPMLLINEARSVMClassifier::~CPMLLINEARSVMClassifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLLINEARSVMClassifier::serialize(CPMLLINEARSVMClassifier *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;

  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 112, "totalRows", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 120, "continousFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 128, "discreteFeatureCount", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *((_QWORD *)this + 33) + 56, "model_nr_class", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *((_QWORD *)this + 33) + 60, "model_nr_feature", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 33) + 64), "model_w", *(int *)(*((_QWORD *)this + 33) + 60) * (uint64_t)*(int *)(*((_QWORD *)this + 33) + 56), 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 33) + 72), "model_label", *(int *)(*((_QWORD *)this + 33) + 56), 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), (char *)this + 216, "bias", 1, 0);
  return 0;
}

uint64_t CPMLLINEARSVMClassifier::train(CPMLLINEARSVMClassifier *this)
{
  double *v2;
  char *v3;
  const char *v4;
  uint64_t result;
  _DWORD *v6;

  v2 = (double *)((char *)this + 232);
  v3 = (char *)this + 160;
  v4 = check_parameter((uint64_t)this + 232, (double *)this + 20);
  if (v4)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ERROR: %s\n", v4);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v6 = train(v2, (uint64_t)v3);
    result = 0;
    *((_QWORD *)this + 33) = v6;
  }
  return result;
}

uint64_t CPMLLINEARSVMClassifier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t *IntVector;
  double **RealVector;
  char *v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  int v15;
  double *v16;
  double *v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  double *v22;
  double v23;
  double *v24;
  double *v25;
  _DWORD *v26;
  double v27;
  double v28;

  IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(this);
  RealVector = (double **)CPMLFeatureVector::getRealVector(this);
  v6 = (char *)malloc_type_calloc(((IntVector[1] - *IntVector) >> 2) + RealVector[1] - *RealVector + 2, 0x10uLL, 0x1000040F7F8B94BuLL);
  v7 = v6;
  v8 = *IntVector;
  v9 = IntVector[1] - *IntVector;
  v10 = v9 >> 2;
  if ((int)(v9 >> 2) < 1)
  {
    v13 = 0;
    v12 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = 0;
    v14 = (v9 >> 2);
    do
    {
      v15 = *(_DWORD *)(v8 + 4 * v11++);
      if (v15)
      {
        v16 = (double *)&v6[16 * v13];
        *(_DWORD *)v16 = v11;
        v16[1] = (double)v15;
        ++v13;
        v12 = v11;
      }
    }
    while (v11 != v14);
  }
  v17 = *RealVector;
  v18 = (char *)RealVector[1] - (char *)*RealVector;
  if ((int)(v18 >> 3) >= 1)
  {
    v19 = v10 + 1;
    v20 = (v18 >> 3);
    do
    {
      v21 = *v17;
      if (*v17 != 0.0)
      {
        v22 = (double *)&v6[16 * v13];
        *(_DWORD *)v22 = v19;
        v22[1] = v21;
        ++v13;
        v12 = v19;
      }
      ++v17;
      ++v19;
      --v20;
    }
    while (v20);
  }
  v23 = *(double *)(a1 + 216);
  if (v23 >= 0.0)
  {
    v24 = (double *)&v6[16 * v13];
    *(_DWORD *)v24 = v12;
    v24[1] = v23;
    ++v13;
  }
  v25 = (double *)&v6[16 * v13];
  *(_DWORD *)v25 = -1;
  v25[1] = nan("");
  v26 = malloc_type_realloc(v7, 16 * (v13 + 1), 0x1000040F7F8B94BuLL);
  v27 = predict(*(_QWORD *)(a1 + 264), v26);
  v28 = 1.0;
  if (v27 == -1.0)
    v28 = 0.0;
  if (*(_QWORD *)(a1 + 104) == 2)
    v27 = v28;
  CPMLFeatureVector::setYHat((uint64_t)this, v27);
  free(v26);
  return 0;
}

void CPMLLINEARSVMClassifier::update(CPMLLINEARSVMClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s No Update Allowed", "update");
  __assert_rtn("update", "CPMLLINEARSVM.c", 377, "0");
}

uint64_t CPMLLINEARSVMClassifier::errorString(CPMLLINEARSVMClassifier *this)
{
  return 0;
}

uint64_t CPMLLINEARSVMClassifier::requireRealOnly(CPMLLINEARSVMClassifier *this)
{
  return 1;
}

CPMLAnalysisHandler *CPMLCreateLIBSVMAnalysis(int *a1, CPMLTunableData *a2)
{
  CPMLLIBSVMClassifier *v4;
  CPMLAnalysisHandler *v5;

  v4 = (CPMLLIBSVMClassifier *)operator new();
  CPMLLIBSVMClassifier::CPMLLIBSVMClassifier(v4, a1, a2);
  v5 = (CPMLAnalysisHandler *)operator new();
  CPMLAnalysisHandler::CPMLAnalysisHandler(v5);
  *(_QWORD *)v5 = off_24C255A78;
  *((_QWORD *)v5 + 1) = v4;
  return v5;
}

void sub_209CBB8F8(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x20BD188E4](v2, 0xA1C4034F8F590);
  _Unwind_Resume(a1);
}

void CPMLLIBSVMAnalysisHandler::CPMLLIBSVMAnalysisHandler(CPMLLIBSVMAnalysisHandler *this, CPMLAlgorithm *a2)
{
  _QWORD *v3;

  CPMLAnalysisHandler::CPMLAnalysisHandler(this);
  *v3 = off_24C255A78;
  v3[1] = a2;
}

_QWORD *CPMLDestroyLIBSVMAnalysis(_QWORD *result)
{
  void *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    *result = off_24C255A78;
    v2 = result[1];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    CPModelClose(v1);
    JUMPOUT(0x20BD188E4);
  }
  return result;
}

void CPMLLIBSVMAnalysisHandler::~CPMLLIBSVMAnalysisHandler(CPMLLIBSVMAnalysisHandler *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24C255A78;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPModelClose(this);
}

double CPMLLIBSVMAnalysisHandler::classify(CPMLLIBSVMAnalysisHandler *this, int a2, double *a3)
{
  uint64_t v4;
  CPMLFeatureVector *v6;
  double v7;
  double YHat;

  LODWORD(v4) = a2;
  v6 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v6);
  if ((int)v4 >= 1)
  {
    v4 = v4;
    do
    {
      v7 = *a3++;
      CPMLFeatureVector::insertRealVClass(v6, v7);
      --v4;
    }
    while (v4);
  }
  (*(void (**)(_QWORD, CPMLFeatureVector *, _QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1), v6, 0);
  YHat = CPMLFeatureVector::getYHat(v6);
  CPMLFeatureVector::~CPMLFeatureVector(v6);
  MEMORY[0x20BD188E4]();
  return YHat;
}

void sub_209CBBAC0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x1020C4087C48359);
  _Unwind_Resume(a1);
}

double CPMLLIBSVMAnalysisHandler::regression(CPMLLIBSVMAnalysisHandler *this, int a2, double *a3)
{
  return nan("");
}

void CPMLDelegateEngine::CPMLDelegateEngine(CPMLDelegateEngine *this, void *a2, void *a3)
{
  this->var0 = a2;
  this->var1 = a3;
}

_QWORD *CPMLlinearSVM::l2r_lr_fun::l2r_lr_fun(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  *a1 = &off_24C255F48;
  a1[4] = a2;
  a1[2] = operator new[]();
  a1[3] = operator new[]();
  a1[1] = a3;
  return a1;
}

void CPMLlinearSVM::l2r_lr_fun::~l2r_lr_fun(CPMLlinearSVM::l2r_lr_fun *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &off_24C255F48;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x20BD188CC](v2, 0x1000C8000313F17);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8000313F17);
}

{
  CPMLlinearSVM::l2r_lr_fun::~l2r_lr_fun(this);
  JUMPOUT(0x20BD188E4);
}

double CPMLlinearSVM::l2r_lr_fun::fun(CPMLlinearSVM::l2r_lr_fun *this, double *a2)
{
  unsigned int *v4;
  double *v5;
  uint64_t v6;
  int v7;
  uint64_t v8;
  double v9;
  double v10;
  double v11;
  double *v12;
  double *v13;
  char *v14;
  double v15;
  double v16;
  long double v17;
  double v18;
  long double v19;

  v4 = (unsigned int *)*((_QWORD *)this + 4);
  v5 = (double *)*((_QWORD *)v4 + 1);
  v6 = *v4;
  v7 = (*(uint64_t (**)(CPMLlinearSVM::l2r_lr_fun *))(*(_QWORD *)this + 24))(this);
  CPMLlinearSVM::l2r_lr_fun::Xv((uint64_t)this, a2, *((double **)this + 2));
  if (v7 < 1)
  {
    v11 = 0.0;
  }
  else
  {
    v8 = v7;
    v9 = 0.0;
    do
    {
      v10 = *a2++;
      v9 = v9 + v10 * v10;
      --v8;
    }
    while (v8);
    v11 = v9 * 0.5;
  }
  if ((int)v6 >= 1)
  {
    v14 = (char *)this + 8;
    v12 = (double *)*((_QWORD *)this + 1);
    v13 = (double *)*((_QWORD *)v14 + 1);
    do
    {
      v15 = *v5 * *v13;
      v16 = *v12;
      if (v15 >= 0.0)
      {
        v19 = exp(-v15);
        v18 = log(v19 + 1.0);
      }
      else
      {
        v17 = exp(*v5 * *v13);
        v18 = log(v17 + 1.0) - v15;
      }
      v11 = v11 + v16 * v18;
      ++v12;
      ++v13;
      ++v5;
      --v6;
    }
    while (v6);
  }
  return v11;
}

uint64_t CPMLlinearSVM::l2r_lr_fun::Xv(uint64_t this, double *a2, double *a3)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  double *v9;
  double v10;
  int v11;

  v3 = *(unsigned int **)(this + 32);
  v4 = *v3;
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = *((_QWORD *)v3 + 2);
    do
    {
      v7 = *(_DWORD **)(v6 + 8 * v5);
      a3[v5] = 0.0;
      v8 = *v7;
      if (*v7 != -1)
      {
        v9 = (double *)(v7 + 4);
        v10 = 0.0;
        do
        {
          v10 = v10 + a2[v8 - 1] * *(v9 - 1);
          a3[v5] = v10;
          v11 = *(_DWORD *)v9;
          v9 += 2;
          v8 = v11;
        }
        while (v11 != -1);
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return this;
}

void CPMLlinearSVM::l2r_lr_fun::grad(CPMLlinearSVM::l2r_lr_fun *this, double *a2, double *a3)
{
  unsigned int *v6;
  double *v7;
  uint64_t v8;
  int v9;
  double *v10;
  double *v11;
  double *v12;
  double *v13;
  long double v14;
  double v15;
  double v16;
  double v17;
  uint64_t v18;
  double v19;

  v6 = (unsigned int *)*((_QWORD *)this + 4);
  v7 = (double *)*((_QWORD *)v6 + 1);
  v8 = *v6;
  v9 = (*(uint64_t (**)(CPMLlinearSVM::l2r_lr_fun *))(*(_QWORD *)this + 24))(this);
  v10 = (double *)*((_QWORD *)this + 2);
  if ((int)v8 >= 1)
  {
    v11 = (double *)*((_QWORD *)this + 3);
    v12 = (double *)*((_QWORD *)this + 1);
    v13 = (double *)*((_QWORD *)this + 2);
    do
    {
      v14 = 1.0 / (exp(-(*v7 * *v13)) + 1.0);
      *v13 = v14;
      *v11++ = v14 * (1.0 - v14);
      v15 = *v12++;
      v16 = v15 * (*v13 + -1.0);
      v17 = *v7++;
      *v13++ = v17 * v16;
      --v8;
    }
    while (v8);
  }
  CPMLlinearSVM::l2r_lr_fun::XTv(this, v10, a3);
  if (v9 >= 1)
  {
    v18 = v9;
    do
    {
      v19 = *a2++;
      *a3 = v19 + *a3;
      ++a3;
      --v18;
    }
    while (v18);
  }
}

void CPMLlinearSVM::l2r_lr_fun::XTv(CPMLlinearSVM::l2r_lr_fun *this, double *a2, double *a3)
{
  uint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t i;
  _DWORD *v10;
  int v11;
  double *v12;
  int v13;

  v6 = **((unsigned int **)this + 4);
  v7 = (*(uint64_t (**)(CPMLlinearSVM::l2r_lr_fun *))(*(_QWORD *)this + 24))(this);
  v8 = *(_QWORD *)(*((_QWORD *)this + 4) + 16);
  if (v7 >= 1)
    bzero(a3, 8 * v7);
  if ((int)v6 >= 1)
  {
    for (i = 0; i != v6; ++i)
    {
      v10 = *(_DWORD **)(v8 + 8 * i);
      v11 = *v10;
      if (*v10 != -1)
      {
        v12 = (double *)(v10 + 4);
        do
        {
          a3[v11 - 1] = a3[v11 - 1] + a2[i] * *(v12 - 1);
          v13 = *(_DWORD *)v12;
          v12 += 2;
          v11 = v13;
        }
        while (v13 != -1);
      }
    }
  }
}

uint64_t CPMLlinearSVM::l2r_lr_fun::get_nr_variable(CPMLlinearSVM::l2r_lr_fun *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 4) + 4);
}

void CPMLlinearSVM::l2r_lr_fun::Hv(CPMLlinearSVM::l2r_lr_fun *this, double *a2, double *a3)
{
  int v6;
  int v7;
  double *v8;
  uint64_t v9;
  double *v10;
  double *v11;
  double *v12;
  double v13;
  double v14;
  double v15;
  uint64_t v16;
  double v17;

  v6 = **((_DWORD **)this + 4);
  v7 = (*(uint64_t (**)(CPMLlinearSVM::l2r_lr_fun *))(*(_QWORD *)this + 24))(this);
  v8 = (double *)operator new[]();
  CPMLlinearSVM::l2r_lr_fun::Xv((uint64_t)this, a2, v8);
  if (v6 >= 1)
  {
    v9 = v6;
    v10 = (double *)*((_QWORD *)this + 1);
    v11 = (double *)*((_QWORD *)this + 3);
    v12 = v8;
    do
    {
      v13 = *v10++;
      v14 = v13;
      v15 = *v11++;
      *v12 = v14 * v15 * *v12;
      ++v12;
      --v9;
    }
    while (v9);
  }
  CPMLlinearSVM::l2r_lr_fun::XTv(this, v8, a3);
  if (v7 >= 1)
  {
    v16 = v7;
    do
    {
      v17 = *a2++;
      *a3 = v17 + *a3;
      ++a3;
      --v16;
    }
    while (v16);
  }
  JUMPOUT(0x20BD188CCLL);
}

_QWORD *CPMLlinearSVM::l2r_l2_svc_fun::l2r_l2_svc_fun(_QWORD *a1, uint64_t a2, uint64_t a3)
{
  *a1 = &off_24C255F88;
  a1[6] = a2;
  a1[2] = operator new[]();
  a1[3] = operator new[]();
  a1[4] = operator new[]();
  a1[1] = a3;
  return a1;
}

void CPMLlinearSVM::l2r_l2_svc_fun::~l2r_l2_svc_fun(CPMLlinearSVM::l2r_l2_svc_fun *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;

  *(_QWORD *)this = &off_24C255F88;
  v2 = *((_QWORD *)this + 2);
  if (v2)
    MEMORY[0x20BD188CC](v2, 0x1000C8000313F17);
  v3 = *((_QWORD *)this + 3);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8000313F17);
  v4 = *((_QWORD *)this + 4);
  if (v4)
    MEMORY[0x20BD188CC](v4, 0x1000C8052888210);
}

{
  CPMLlinearSVM::l2r_l2_svc_fun::~l2r_l2_svc_fun(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLlinearSVM::l2r_l2_svc_fun::fun(CPMLlinearSVM::l2r_l2_svc_fun *this, double *a2)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  uint64_t v14;
  double v15;
  double v16;

  v4 = (unsigned int *)*((_QWORD *)this + 6);
  v5 = *((_QWORD *)v4 + 1);
  v6 = *v4;
  v7 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svc_fun *))(*(_QWORD *)this + 24))(this);
  result = CPMLlinearSVM::l2r_l2_svc_fun::Xv((uint64_t)this, a2, *((double **)this + 2));
  if (v7 < 1)
  {
    v12 = 0.0;
  }
  else
  {
    v9 = v7;
    v10 = 0.0;
    do
    {
      v11 = *a2++;
      v10 = v10 + v11 * v11;
      --v9;
    }
    while (v9);
    v12 = v10 * 0.5;
  }
  if ((int)v6 >= 1)
  {
    v13 = 0;
    v14 = *((_QWORD *)this + 2);
    do
    {
      v15 = *(double *)(v5 + v13) * *(double *)(v14 + v13);
      *(double *)(v14 + v13) = v15;
      v16 = 1.0 - v15;
      if (v16 > 0.0)
        v12 = v12 + v16 * *(double *)(*((_QWORD *)this + 1) + v13) * v16;
      v13 += 8;
    }
    while (8 * v6 != v13);
  }
  return result;
}

uint64_t CPMLlinearSVM::l2r_l2_svc_fun::Xv(uint64_t this, double *a2, double *a3)
{
  unsigned int *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  double *v9;
  double v10;
  int v11;

  v3 = *(unsigned int **)(this + 48);
  v4 = *v3;
  if ((int)v4 >= 1)
  {
    v5 = 0;
    v6 = *((_QWORD *)v3 + 2);
    do
    {
      v7 = *(_DWORD **)(v6 + 8 * v5);
      a3[v5] = 0.0;
      v8 = *v7;
      if (*v7 != -1)
      {
        v9 = (double *)(v7 + 4);
        v10 = 0.0;
        do
        {
          v10 = v10 + a2[v8 - 1] * *(v9 - 1);
          a3[v5] = v10;
          v11 = *(_DWORD *)v9;
          v9 += 2;
          v8 = v11;
        }
        while (v11 != -1);
      }
      ++v5;
    }
    while (v5 != v4);
  }
  return this;
}

void CPMLlinearSVM::l2r_l2_svc_fun::grad(CPMLlinearSVM::l2r_l2_svc_fun *this, double *a2, double *a3)
{
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  double *v10;
  int v11;
  uint64_t i;
  double v13;
  uint64_t v14;
  double v15;

  v6 = (unsigned int *)*((_QWORD *)this + 6);
  v7 = *((_QWORD *)v6 + 1);
  v8 = *v6;
  v9 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svc_fun *))(*(_QWORD *)this + 24))(this);
  *((_DWORD *)this + 10) = 0;
  v10 = (double *)*((_QWORD *)this + 2);
  if ((int)v8 >= 1)
  {
    v11 = 0;
    for (i = 0; i != v8; ++i)
    {
      v13 = v10[i];
      if (v13 < 1.0)
      {
        v10[v11] = (v13 + -1.0) * (*(double *)(*((_QWORD *)this + 1) + 8 * i) * *(double *)(v7 + 8 * i));
        *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v11) = i;
        v11 = *((_DWORD *)this + 10) + 1;
        *((_DWORD *)this + 10) = v11;
      }
    }
  }
  CPMLlinearSVM::l2r_l2_svc_fun::subXTv(this, v10, a3);
  if (v9 >= 1)
  {
    v14 = v9;
    do
    {
      v15 = *a2++;
      *a3 = v15 + *a3 * 2.0;
      ++a3;
      --v14;
    }
    while (v14);
  }
}

void CPMLlinearSVM::l2r_l2_svc_fun::subXTv(CPMLlinearSVM::l2r_l2_svc_fun *this, double *a2, double *a3)
{
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _DWORD *v11;
  int v12;
  double *v13;
  int v14;

  v6 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svc_fun *))(*(_QWORD *)this + 24))(this);
  v7 = *(_QWORD *)(*((_QWORD *)this + 6) + 16);
  if (v6 >= 1)
    bzero(a3, 8 * v6);
  v8 = *((unsigned int *)this + 10);
  if ((int)v8 >= 1)
  {
    v9 = 0;
    v10 = *((_QWORD *)this + 4);
    do
    {
      v11 = *(_DWORD **)(v7 + 8 * *(int *)(v10 + 4 * v9));
      v12 = *v11;
      if (*v11 != -1)
      {
        v13 = (double *)(v11 + 4);
        do
        {
          a3[v12 - 1] = a3[v12 - 1] + a2[v9] * *(v13 - 1);
          v14 = *(_DWORD *)v13;
          v13 += 2;
          v12 = v14;
        }
        while (v14 != -1);
      }
      ++v9;
    }
    while (v9 != v8);
  }
}

uint64_t CPMLlinearSVM::l2r_l2_svc_fun::get_nr_variable(CPMLlinearSVM::l2r_l2_svc_fun *this)
{
  return *(unsigned int *)(*((_QWORD *)this + 6) + 4);
}

void CPMLlinearSVM::l2r_l2_svc_fun::Hv(CPMLlinearSVM::l2r_l2_svc_fun *this, double *a2, double *a3)
{
  int v6;
  double *v7;
  uint64_t v8;
  uint64_t v9;
  int *v10;
  double *v11;
  uint64_t v12;
  uint64_t v13;
  double v14;

  v6 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svc_fun *))(*(_QWORD *)this + 24))(this);
  v7 = (double *)operator new[]();
  CPMLlinearSVM::l2r_l2_svc_fun::subXv((uint64_t)this, a2, v7);
  v8 = *((unsigned int *)this + 10);
  if ((int)v8 >= 1)
  {
    v9 = *((_QWORD *)this + 1);
    v10 = (int *)*((_QWORD *)this + 4);
    v11 = v7;
    do
    {
      v12 = *v10++;
      *v11 = *(double *)(v9 + 8 * v12) * *v11;
      ++v11;
      --v8;
    }
    while (v8);
  }
  CPMLlinearSVM::l2r_l2_svc_fun::subXTv(this, v7, a3);
  if (v6 >= 1)
  {
    v13 = v6;
    do
    {
      v14 = *a2++;
      *a3 = v14 + *a3 * 2.0;
      ++a3;
      --v13;
    }
    while (v13);
  }
  JUMPOUT(0x20BD188CCLL);
}

uint64_t CPMLlinearSVM::l2r_l2_svc_fun::subXv(uint64_t this, double *a2, double *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  int v8;
  double *v9;
  double v10;
  int v11;

  v3 = *(unsigned int *)(this + 40);
  if ((int)v3 >= 1)
  {
    v4 = 0;
    v5 = *(_QWORD *)(*(_QWORD *)(this + 48) + 16);
    v6 = *(_QWORD *)(this + 32);
    do
    {
      v7 = *(_DWORD **)(v5 + 8 * *(int *)(v6 + 4 * v4));
      a3[v4] = 0.0;
      v8 = *v7;
      if (*v7 != -1)
      {
        v9 = (double *)(v7 + 4);
        v10 = 0.0;
        do
        {
          v10 = v10 + a2[v8 - 1] * *(v9 - 1);
          a3[v4] = v10;
          v11 = *(_DWORD *)v9;
          v9 += 2;
          v8 = v11;
        }
        while (v11 != -1);
      }
      ++v4;
    }
    while (v4 != v3);
  }
  return this;
}

double *CPMLlinearSVM::l2r_l2_svr_fun::l2r_l2_svr_fun(_QWORD *a1, uint64_t a2, uint64_t a3, double a4)
{
  double *result;

  result = (double *)CPMLlinearSVM::l2r_l2_svc_fun::l2r_l2_svc_fun(a1, a2, a3);
  *(_QWORD *)result = &off_24C255FC8;
  result[7] = a4;
  return result;
}

uint64_t CPMLlinearSVM::l2r_l2_svr_fun::fun(CPMLlinearSVM::l2r_l2_svr_fun *this, double *a2)
{
  unsigned int *v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  uint64_t result;
  uint64_t v9;
  double v10;
  double v11;
  double v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;

  v4 = (unsigned int *)*((_QWORD *)this + 6);
  v5 = *((_QWORD *)v4 + 1);
  v6 = *v4;
  v7 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svr_fun *))(*(_QWORD *)this + 24))(this);
  result = CPMLlinearSVM::l2r_l2_svc_fun::Xv((uint64_t)this, a2, *((double **)this + 2));
  if (v7 < 1)
  {
    v12 = 0.0;
  }
  else
  {
    v9 = v7;
    v10 = 0.0;
    do
    {
      v11 = *a2++;
      v10 = v10 + v11 * v11;
      --v9;
    }
    while (v9);
    v12 = v10 * 0.5;
  }
  if ((int)v6 >= 1)
  {
    v13 = 0;
    v14 = *((double *)this + 7);
    while (1)
    {
      v15 = *(double *)(*((_QWORD *)this + 2) + v13) - *(double *)(v5 + v13);
      if (v15 < -v14)
        break;
      if (v15 > v14)
      {
        v16 = *(double *)(*((_QWORD *)this + 1) + v13);
        v17 = v15 - v14;
        goto LABEL_12;
      }
LABEL_13:
      v13 += 8;
      if (8 * v6 == v13)
        return result;
    }
    v16 = *(double *)(*((_QWORD *)this + 1) + v13);
    v17 = v15 + v14;
LABEL_12:
    v12 = v12 + v17 * v16 * v17;
    goto LABEL_13;
  }
  return result;
}

void CPMLlinearSVM::l2r_l2_svr_fun::grad(CPMLlinearSVM::l2r_l2_svr_fun *this, double *a2, double *a3)
{
  unsigned int *v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  double *v10;
  int v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  uint64_t v17;
  double v18;

  v6 = (unsigned int *)*((_QWORD *)this + 6);
  v7 = *((_QWORD *)v6 + 1);
  v8 = *v6;
  v9 = (*(uint64_t (**)(CPMLlinearSVM::l2r_l2_svr_fun *))(*(_QWORD *)this + 24))(this);
  *((_DWORD *)this + 10) = 0;
  v10 = (double *)*((_QWORD *)this + 2);
  if ((int)v8 >= 1)
  {
    v11 = 0;
    v12 = 0;
    while (1)
    {
      v13 = v10[v12] - *(double *)(v7 + 8 * v12);
      v14 = *((double *)this + 7);
      if (v13 < -v14)
        break;
      if (v13 > v14)
      {
        v15 = *(double *)(*((_QWORD *)this + 1) + 8 * v12);
        v16 = v13 - v14;
        goto LABEL_7;
      }
LABEL_8:
      if (v8 == ++v12)
        goto LABEL_9;
    }
    v15 = *(double *)(*((_QWORD *)this + 1) + 8 * v12);
    v16 = v13 + v14;
LABEL_7:
    v10[v11] = v16 * v15;
    *(_DWORD *)(*((_QWORD *)this + 4) + 4 * v11) = v12;
    v11 = *((_DWORD *)this + 10) + 1;
    *((_DWORD *)this + 10) = v11;
    goto LABEL_8;
  }
LABEL_9:
  CPMLlinearSVM::l2r_l2_svc_fun::subXTv(this, v10, a3);
  if (v9 >= 1)
  {
    v17 = v9;
    do
    {
      v18 = *a2++;
      *a3 = v18 + *a3 * 2.0;
      ++a3;
      --v17;
    }
    while (v17);
  }
}

uint64_t CPMLlinearSVM::Solver_MCSVM_CS::Solver_MCSVM_CS(uint64_t a1, int32x2_t *a2, int a3, uint64_t a4, int a5, double a6)
{
  uint64_t v8;

  *(int32x2_t *)(a1 + 24) = vrev64_s32(*a2);
  *(double *)(a1 + 40) = a6;
  *(_DWORD *)(a1 + 32) = a3;
  *(_DWORD *)(a1 + 36) = a5;
  *(_QWORD *)(a1 + 48) = a2;
  *(_QWORD *)a1 = operator new[]();
  v8 = operator new[]();
  *(_QWORD *)(a1 + 8) = a4;
  *(_QWORD *)(a1 + 16) = v8;
  return a1;
}

void CPMLlinearSVM::Solver_MCSVM_CS::~Solver_MCSVM_CS(CPMLlinearSVM::Solver_MCSVM_CS *this)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)this;
  if (v2)
    MEMORY[0x20BD188CC](v2, 0x1000C8000313F17);
  v3 = *((_QWORD *)this + 2);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8000313F17);
}

void CPMLlinearSVM::Solver_MCSVM_CS::solve_sub_problem(const void **this, double a2, int a3, double a4, int a5, double *a6)
{
  const void *v12;
  size_t v13;
  size_t v14;
  double *v15;
  double v16;
  int v17;
  uint64_t v18;
  double v19;
  uint64_t v20;
  double v21;
  double *v22;
  double v23;

  v12 = *this;
  v13 = a5;
  v14 = 8 * a5;
  v15 = (double *)operator new[]();
  memcpy(v15, v12, v14);
  if (a3 < a5)
    v15[a3] = v15[a3] + a2 * a4;
  qsort(v15, v13, 8uLL, (int (__cdecl *)(const void *, const void *))CPMLlinearSVM::compare_double);
  v16 = *v15 - a2 * a4;
  if (a5 <= 1)
  {
    v17 = 1;
  }
  else
  {
    v17 = a5;
    v18 = 1;
    while (1)
    {
      v19 = v15[v18];
      if (v16 >= v19 * (double)(int)v18)
        break;
      v16 = v16 + v19;
      if (a5 == ++v18)
        goto LABEL_10;
    }
    v17 = v18;
  }
LABEL_10:
  if (a5 >= 1)
  {
    v20 = 0;
    v21 = v16 / (double)v17;
    do
    {
      v22 = (double *)*this;
      if (a3 == v20)
      {
        v23 = (v21 - v22[a3]) / a2;
        if (v23 > a4)
          v23 = a4;
      }
      else
      {
        v23 = (v21 - v22[v20]) / a2;
        if (v23 > 0.0)
          v23 = 0.0;
      }
      a6[v20++] = v23;
    }
    while (a5 != v20);
  }
  JUMPOUT(0x20BD188CCLL);
}

uint64_t CPMLlinearSVM::compare_double(CPMLlinearSVM *this, double *a2, const void *a3)
{
  if (*(double *)this > *a2)
    return 0xFFFFFFFFLL;
  else
    return *(double *)this < *a2;
}

BOOL CPMLlinearSVM::Solver_MCSVM_CS::be_shrunk(CPMLlinearSVM::Solver_MCSVM_CS *this, int a2, int a3, int a4, double a5, double a6)
{
  double v6;

  v6 = 0.0;
  if (a3 == a4)
    v6 = *(double *)(*((_QWORD *)this + 1) + 8 * (int)*(double *)(*(_QWORD *)(*((_QWORD *)this + 6) + 8) + 8 * a2));
  return v6 == a5 && *(double *)(*((_QWORD *)this + 2) + 8 * a3) < a6;
}

void CPMLlinearSVM::Solver_MCSVM_CS::Solve(CPMLlinearSVM::Solver_MCSVM_CS *this, double *a2)
{
  void *v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;
  _DWORD *v16;
  double *v17;
  double v18;
  int v19;
  int v20;
  double v21;
  double v22;
  double v23;
  BOOL v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  double *v30;
  uint64_t v31;
  int v32;
  double v33;
  int v34;
  uint64_t v35;
  int v36;
  int v37;
  int *v38;
  uint64_t v39;
  double *v40;
  int j;
  double *v42;
  double *v43;
  uint64_t v44;
  int *v45;
  uint64_t v46;
  int v47;
  double *v48;
  double *v49;
  uint64_t v50;
  int *v51;
  uint64_t v52;
  double v53;
  double v54;
  double v55;
  int v57;
  uint64_t v58;
  uint64_t v59;
  int v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  double v64;
  double *v65;
  uint64_t v66;
  _DWORD *v67;
  double v68;
  uint64_t v69;
  double v70;
  double v71;
  int v73;
  double *v74;
  double *v75;
  uint64_t v76;
  int *v77;
  double v78;
  double v79;
  uint64_t v80;
  unint64_t v81;
  int v82;
  uint64_t v83;
  _DWORD *v84;
  uint64_t v85;
  uint64_t v86;
  double v87;
  double v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  double *v92;
  double v93;
  int v94;
  uint64_t v95;
  double *v96;
  double v97;
  uint64_t v98;
  BOOL v99;
  uint64_t v100;
  uint64_t v101;
  double *v102;
  int v103;
  double *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;

  v4 = (void *)operator new[]();
  v102 = (double *)operator new[]();
  v5 = operator new[]();
  v105 = operator new[]();
  v101 = operator new[]();
  v100 = operator new[]();
  v107 = operator new[]();
  v108 = operator new[]();
  v6 = *((_DWORD *)this + 7);
  v7 = operator new[]();
  v8 = *((double *)this + 5);
  v9 = *((unsigned int *)this + 7);
  v10 = *((unsigned int *)this + 8);
  v106 = v7;
  if ((int)v10 * (int)v9 >= 1)
  {
    bzero(v4, 8 * (v10 * v9));
    v7 = v106;
  }
  v104 = (double *)v4;
  if (*((_DWORD *)this + 6) * (int)v10 >= 1)
  {
    bzero(a2, 8 * (*((_DWORD *)this + 6) * v10));
    v7 = v106;
  }
  if ((int)v9 >= 1)
  {
    v11 = 0;
    v13 = *(_QWORD *)(*((_QWORD *)this + 6) + 8);
    v12 = *(_QWORD *)(*((_QWORD *)this + 6) + 16);
    v14 = v107;
    do
    {
      if ((int)v10 >= 1)
      {
        for (i = 0; i != v10; ++i)
          *(_DWORD *)(v14 + 4 * i) = i;
      }
      v16 = *(_DWORD **)(v12 + 8 * v11);
      *(_QWORD *)(v105 + 8 * v11) = 0;
      if (*v16 != -1)
      {
        v17 = (double *)(v16 + 4);
        v18 = 0.0;
        do
        {
          v18 = v18 + *(v17 - 1) * *(v17 - 1);
          *(double *)(v105 + 8 * v11) = v18;
          v19 = *(_DWORD *)v17;
          v17 += 2;
        }
        while (v19 != -1);
      }
      *(_DWORD *)(v7 + 4 * v11) = v10;
      *(_DWORD *)(v108 + 4 * v11) = (int)*(double *)(v13 + 8 * v11);
      *(_DWORD *)(v5 + 4 * v11) = v11;
      ++v11;
      v14 += 4 * (int)v10;
    }
    while (v11 != v9);
  }
  if (*((int *)this + 9) < 1)
  {
    v20 = 0;
LABEL_90:
    info("\noptimization finished, #iter = %d\n", v20);
    if (v20 >= *((_DWORD *)this + 9))
      info("\nWARNING: reaching max number of iterations\n");
    v85 = *((int *)this + 8);
    v86 = (v85 * *((_DWORD *)this + 6));
    v87 = 0.0;
    if ((int)v86 >= 1)
    {
      do
      {
        v88 = *a2++;
        v87 = v87 + v88 * v88;
        --v86;
      }
      while (v86);
      v87 = v87 * 0.5;
    }
    v89 = *((unsigned int *)this + 7);
    v90 = (v89 * v85);
    if ((int)v90 < 1)
    {
      v91 = 0;
    }
    else
    {
      v91 = 0;
      v92 = v104;
      do
      {
        v93 = *v92++;
        v87 = v87 + v93;
        v94 = v93 < 0.0;
        if (v93 > 0.0)
          v94 = 1;
        v91 += v94;
        --v90;
      }
      while (v90);
    }
    if ((int)v89 >= 1)
    {
      v95 = 0;
      v96 = *(double **)(*((_QWORD *)this + 6) + 8);
      do
      {
        v97 = *v96++;
        v98 = v95 + (int)v97;
        v95 += v85;
        v87 = v87 - v104[v98];
        --v89;
      }
      while (v89);
    }
    info("Objective value = %lf\n", v87);
    info("nSV = %d\n", v91);
    MEMORY[0x20BD188CC](v104, 0x1000C8000313F17);
    MEMORY[0x20BD188CC](v102, 0x1000C8000313F17);
    MEMORY[0x20BD188CC](v5, 0x1000C8052888210);
    MEMORY[0x20BD188CC](v105, 0x1000C8000313F17);
    MEMORY[0x20BD188CC](v101, 0x1000C8052888210);
    MEMORY[0x20BD188CC](v100, 0x1000C8000313F17);
    MEMORY[0x20BD188CC](v107, 0x1000C8052888210);
    MEMORY[0x20BD188CC](v108, 0x1000C8052888210);
    JUMPOUT(0x20BD188CCLL);
  }
  v20 = 0;
  v21 = v8 * 10.0;
  v22 = 1.0;
  v23 = fmax(v8 * 10.0, 1.0);
  v24 = 1;
  while (1)
  {
    v99 = v24;
    v103 = v20;
    if (v6 >= 1)
      break;
LABEL_77:
    v20 = v103 + 1;
    HIDWORD(v81) = -858993459 * (v103 + 1);
    LODWORD(v81) = HIDWORD(v81);
    if ((v81 >> 1) <= 0x19999999)
    {
      info(".", v21, v22);
      v7 = v106;
    }
    v24 = v23 > -INFINITY;
    if (v23 > -INFINITY)
    {
      if (v99 && *((double *)this + 5) > -INFINITY)
        goto LABEL_90;
      v6 = *((_DWORD *)this + 7);
      if (v6 >= 1)
      {
        v82 = *((_DWORD *)this + 8);
        v83 = *((unsigned int *)this + 7);
        v84 = (_DWORD *)v7;
        do
        {
          *v84++ = v82;
          --v83;
        }
        while (v83);
      }
      info("*");
      v7 = v106;
      v21 = v23 * 0.5;
      v22 = *((double *)this + 5);
      if (v23 * 0.5 <= v22)
        v23 = *((double *)this + 5);
      else
        v23 = v23 * 0.5;
    }
    if (v20 >= *((_DWORD *)this + 9))
      goto LABEL_90;
  }
  v25 = 0;
  v26 = v6;
  do
  {
    v27 = v25 + rand() % v6;
    v28 = *(_DWORD *)(v5 + 4 * v25);
    *(_DWORD *)(v5 + 4 * v25) = *(_DWORD *)(v5 + 4 * v27);
    *(_DWORD *)(v5 + 4 * v27) = v28;
    ++v25;
    --v6;
  }
  while (v26 != v25);
  v29 = 0;
  v6 = v26;
  v30 = v104;
  v31 = v105;
  v7 = v106;
  while (1)
  {
    v32 = *(_DWORD *)(v5 + 4 * v29);
    v33 = *(double *)(v31 + 8 * v32);
    if (v33 > 0.0)
    {
      v34 = *((_DWORD *)this + 8);
      v35 = *(unsigned int *)(v7 + 4 * v32);
      if ((int)v35 >= 1)
      {
        memset_pattern16(*((void **)this + 2), &unk_209D00180, 8 * v35);
        v31 = v105;
        v7 = v106;
        v30 = v104;
      }
      v36 = *(_DWORD *)(v108 + 4 * v32);
      if (v36 < (int)v35)
        *(_QWORD *)(*((_QWORD *)this + 2) + 8 * v36) = 0;
      v37 = v34 * v32;
      v38 = (int *)(v107 + 4 * v34 * v32);
      v39 = *((_QWORD *)this + 6);
      v40 = *(double **)(*(_QWORD *)(v39 + 16) + 8 * v32);
      for (j = *(_DWORD *)v40; j != -1; j = v47)
      {
        if ((int)v35 >= 1)
        {
          v42 = &a2[(j - 1) * v34];
          v43 = (double *)*((_QWORD *)this + 2);
          v44 = v35;
          v45 = (int *)(v107 + 4 * v34 * v32);
          do
          {
            v46 = *v45++;
            *v43 = *v43 + v42[v46] * v40[1];
            ++v43;
            --v44;
          }
          while (v44);
        }
        v47 = *((_DWORD *)v40 + 4);
        v40 += 2;
      }
      v48 = &v30[v37];
      if ((int)v35 < 1)
      {
        v21 = -INFINITY;
        v22 = INFINITY;
      }
      else
      {
        v49 = (double *)*((_QWORD *)this + 2);
        v22 = INFINITY;
        v21 = -INFINITY;
        v50 = v35;
        v51 = v38;
        do
        {
          v52 = *v51++;
          v53 = v48[v52];
          v54 = *v49++;
          v55 = v54;
          if (v54 < v22 && v53 < 0.0)
            v22 = v55;
          if (v55 > v21)
            v21 = v55;
          --v50;
        }
        while (v50);
      }
      if (v36 < (int)v35)
      {
        v57 = (int)*(double *)(*(_QWORD *)(v39 + 8) + 8 * v32);
        if (v48[v57] < *(double *)(*((_QWORD *)this + 1) + 8 * v57)
          && *(double *)(*((_QWORD *)this + 2) + 8 * v36) < v22)
        {
          v22 = *(double *)(*((_QWORD *)this + 2) + 8 * v36);
        }
      }
      if ((int)v35 <= 0)
      {
        *(_DWORD *)(v7 + 4 * v32) = v35;
      }
      else
      {
        v58 = 0;
        v59 = v107 + 4 * v37;
        v60 = v35;
        do
        {
          v61 = 0.0;
          if (v58 == v36)
            v61 = *(double *)(*((_QWORD *)this + 1) + 8 * (int)*(double *)(*(_QWORD *)(v39 + 8) + 8 * v32));
          v62 = v38[v58];
          if (v61 == v48[v62])
          {
            v63 = *((_QWORD *)this + 2);
            v64 = *(double *)(v63 + 8 * v58);
            if (v64 < v22)
            {
              v65 = (double *)(v63 + 8 * v60);
              v66 = v60 - 1;
              v67 = (_DWORD *)(v59 + 4 * v60);
              do
              {
                v60 = v66;
                if (v66 <= v58)
                  goto LABEL_68;
                v68 = 0.0;
                if (v36 == (_DWORD)v66)
                  v68 = *(double *)(*((_QWORD *)this + 1) + 8 * (int)*(double *)(*(_QWORD *)(v39 + 8) + 8 * v32));
                v69 = (int)*(v67 - 1);
                v70 = *--v65;
                v71 = v70;
                --v66;
                --v67;
              }
              while (v68 == v48[v69] && v71 < v22);
              v38[v58] = v69;
              *v67 = v62;
              *(double *)(v63 + 8 * v58) = v71;
              *v65 = v64;
              if (v58 == v36)
                v73 = v66 + 1;
              else
                v73 = v36;
              if (v36 == v60)
                v36 = v58;
              else
                v36 = v73;
              v60 = v66 + 1;
            }
          }
LABEL_68:
          ++v58;
        }
        while (v58 < v60);
        *(_DWORD *)(v108 + 4 * v32) = v36;
        *(_DWORD *)(v7 + 4 * v32) = v60;
        if (v60 > 1)
        {
          v21 = v21 - v22;
          if (v21 > 1.0e-12)
          {
            v74 = (double *)*((_QWORD *)this + 2);
            v75 = *(double **)this;
            v76 = v60;
            v77 = v38;
            do
            {
              v78 = *v74++;
              v79 = v78;
              v80 = *v77++;
              *v75++ = v79 + -v33 * v48[v80];
              --v76;
            }
            while (v76);
            CPMLlinearSVM::Solver_MCSVM_CS::solve_sub_problem((const void **)this, v33, v36, *(double *)(*((_QWORD *)this + 1) + 8 * (int)*(double *)(*(_QWORD *)(v39 + 8) + 8 * v32)), v60, v102);
          }
          goto LABEL_76;
        }
      }
      *(_DWORD *)(v5 + 4 * v29) = *(_DWORD *)(v5 + 4 * --v6);
      *(_DWORD *)(v5 + 4 * v6) = v32;
      --v29;
    }
LABEL_76:
    if (++v29 >= v6)
      goto LABEL_77;
  }
}

uint64_t info(const char *a1, ...)
{
  char v2[1024];
  uint64_t v3;
  va_list va;

  va_start(va, a1);
  v3 = *MEMORY[0x24BDAC8D0];
  vsprintf(v2, a1, va);
  return liblinear_print_string(v2);
}

{
  char v2[1024];
  uint64_t v3;
  va_list va;

  va_start(va, a1);
  v3 = *MEMORY[0x24BDAC8D0];
  vsprintf(v2, a1, va);
  return svm_print_string(v2);
}

_DWORD *train(double *a1, uint64_t a2)
{
  double *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _DWORD *v7;
  _DWORD *v8;
  __int128 v9;
  __int128 v10;
  __int128 v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  _DWORD *v15;
  int *v16;
  uint64_t v17;
  int v18;
  int v19;
  int32x2_t *v20;
  int v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double *v25;
  int32x2_t *v26;
  int32x2_t *v27;
  int *v28;
  _DWORD *v29;
  uint64_t v30;
  _DWORD *v31;
  _DWORD *v32;
  int v33;
  uint64_t v34;
  _DWORD *v35;
  int32x2_t *v36;
  __int32 v37;
  uint64_t i;
  int v39;
  uint64_t v40;
  _DWORD *v41;
  int32x2_t *v42;
  __int32 v43;
  _DWORD *v44;
  uint64_t v45;
  int *v46;
  int v47;
  double *v48;
  double *v49;
  uint64_t j;
  int v51;
  uint64_t v52;
  FILE **v53;
  uint64_t v54;
  size_t v55;
  char *v56;
  char *v57;
  void *v58;
  uint64_t v59;
  int *v60;
  char *v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  double *v69;
  int v70;
  int32x2_t *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  __int32 v76;
  int v77;
  double *v78;
  _QWORD *v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v84;
  void *v85;
  void *v86;
  int *v87;
  uint64_t v88;
  uint64_t v89;
  _DWORD *v90;
  int *v91;
  double *v92;
  int32x2_t *v93;
  uint64_t v94;
  _QWORD v95[3];
  int v96;
  int v97;
  int v98;
  int v99;
  uint64_t v100;
  unsigned int *v101;
  unsigned int v102[2];
  char *v103;
  char *v104;

  v3 = a1;
  v5 = *(unsigned int *)a1;
  v4 = *((unsigned int *)a1 + 1);
  v6 = (int)v4;
  v7 = malloc_type_malloc(0x58uLL, 0x10900405E350820uLL);
  v8 = v7;
  v94 = v4;
  v7[15] = v4 - (v3[3] >= 0.0);
  v9 = *(_OWORD *)a2;
  v10 = *(_OWORD *)(a2 + 16);
  v11 = *(_OWORD *)(a2 + 32);
  *((_QWORD *)v7 + 6) = *(_QWORD *)(a2 + 48);
  *((_OWORD *)v7 + 1) = v10;
  *((_OWORD *)v7 + 2) = v11;
  *(_OWORD *)v7 = v9;
  *((double *)v7 + 10) = v3[3];
  if ((*v7 - 11) <= 2)
  {
    v12 = (double *)malloc_type_malloc(8 * (int)v4, 0x100004000313F17uLL);
    v8[14] = 2;
    *((_QWORD *)v8 + 8) = v12;
    *((_QWORD *)v8 + 9) = 0;
    train_one((unsigned int *)v3, a2, v12, 0.0, 0.0);
    return v8;
  }
  v90 = v7;
  v87 = (int *)malloc_type_malloc(4 * (int)v5, 0x100004052888210uLL);
  v13 = *(int *)v3;
  v14 = *(unsigned int *)v3;
  v15 = malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
  v93 = (int32x2_t *)malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
  v16 = (int *)malloc_type_malloc(4 * v13, 0x100004052888210uLL);
  v88 = v5;
  v84 = v6;
  v85 = (void *)(int)v5;
  if ((int)v13 < 1)
  {
    v18 = 0;
  }
  else
  {
    v17 = 0;
    v18 = 0;
    v19 = 16;
    v20 = v93;
    v91 = v16;
    do
    {
      v21 = (int)*(double *)(*((_QWORD *)v3 + 1) + 8 * v17);
      if (v18 < 1)
      {
        LODWORD(v22) = 0;
      }
      else
      {
        v22 = 0;
        while (v15[v22] != v21)
        {
          if (v18 == ++v22)
          {
            v16[v17] = v18;
            goto LABEL_13;
          }
        }
        ++v20->i32[v22];
      }
      v16[v17] = v22;
      if ((_DWORD)v22 == v18)
      {
LABEL_13:
        if (v18 == v19)
        {
          v23 = v14;
          v24 = a2;
          v25 = v3;
          v26 = v20;
          v15 = malloc_type_realloc(v15, 8 * v18, 0x100004052888210uLL);
          v27 = v26;
          v3 = v25;
          a2 = v24;
          v14 = v23;
          v20 = (int32x2_t *)malloc_type_realloc(v27, 8 * v18, 0x100004052888210uLL);
          v19 = 2 * v18;
          v16 = v91;
        }
        v15[v18] = v21;
        v20->i32[v18++] = 1;
      }
      ++v17;
    }
    while (v17 != v14);
    v93 = v20;
    if (v18 == 2)
    {
      v28 = v87;
      if (*v15 == -1 && v15[1] == 1)
      {
        *(_QWORD *)v15 = 0xFFFFFFFF00000001;
        *v20 = vrev64_s32(*v20);
        v29 = v16;
        v30 = v14;
        do
        {
          *v29 = *v29 == 0;
          ++v29;
          --v30;
        }
        while (v30);
      }
      v18 = 2;
      goto LABEL_25;
    }
  }
  v28 = v87;
LABEL_25:
  v31 = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
  v32 = v31;
  *v31 = 0;
  if (v18 > 1)
  {
    v33 = 0;
    v34 = v18 - 1;
    v35 = v31 + 1;
    v36 = v93;
    do
    {
      v37 = v36->i32[0];
      v36 = (int32x2_t *)((char *)v36 + 4);
      v33 += v37;
      *v35++ = v33;
      --v34;
    }
    while (v34);
  }
  if ((int)v14 >= 1)
  {
    for (i = 0; i != v14; ++i)
      v28[v31[v16[i]]++] = i;
  }
  *v31 = 0;
  if (v18 > 1)
  {
    v39 = 0;
    v40 = v18 - 1;
    v41 = v31 + 1;
    v42 = v93;
    do
    {
      v43 = v42->i32[0];
      v42 = (int32x2_t *)((char *)v42 + 4);
      v39 += v43;
      *v41++ = v39;
      --v40;
    }
    while (v40);
  }
  free(v16);
  v90[14] = v18;
  v44 = malloc_type_malloc(4 * v18, 0x100004052888210uLL);
  *((_QWORD *)v90 + 9) = v44;
  if (v18 <= 0)
  {
    v49 = (double *)malloc_type_malloc(8 * v18, 0x100004000313F17uLL);
  }
  else
  {
    v45 = v18;
    v46 = v15;
    do
    {
      v47 = *v46++;
      *v44++ = v47;
      --v45;
    }
    while (v45);
    v48 = (double *)malloc_type_malloc(8 * v18, 0x100004000313F17uLL);
    v49 = v48;
    for (j = 0; j != v18; ++j)
      v48[j] = *(double *)(a2 + 16);
  }
  v51 = *(_DWORD *)(a2 + 24);
  if (v51 >= 1)
  {
    v52 = 0;
    v53 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      if (v18 < 1)
      {
        LODWORD(v54) = 0;
      }
      else
      {
        v54 = 0;
        while (*(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v52) != v15[v54])
        {
          if (v18 == ++v54)
            goto LABEL_50;
        }
      }
      if ((_DWORD)v54 == v18)
      {
LABEL_50:
        fprintf(*v53, "WARNING: class label %d specified in weight is not found\n", *(_DWORD *)(*(_QWORD *)(a2 + 32) + 4 * v52));
        v51 = *(_DWORD *)(a2 + 24);
      }
      else
      {
        v49[v54] = *(double *)(*(_QWORD *)(a2 + 40) + 8 * v52) * v49[v54];
      }
      ++v52;
    }
    while (v52 < v51);
  }
  v55 = 8 * (_QWORD)v85;
  v56 = (char *)malloc_type_malloc(8 * (_QWORD)v85, 0x2004093837F09uLL);
  v57 = v56;
  v58 = v87;
  if ((int)v88 >= 1)
  {
    v59 = v88;
    v60 = v87;
    v61 = v56;
    do
    {
      v62 = *v60++;
      *(_QWORD *)v61 = *(_QWORD *)(*((_QWORD *)v3 + 2) + 8 * v62);
      v61 += 8;
      --v59;
    }
    while (v59);
  }
  v102[0] = v88;
  v102[1] = v94;
  v104 = (char *)malloc_type_malloc(v55, 0x2004093837F09uLL);
  v103 = (char *)malloc_type_malloc(v55, 0x100004000313F17uLL);
  if ((int)v88 >= 1)
  {
    v63 = 0;
    do
    {
      *(_QWORD *)&v104[v63] = *(_QWORD *)&v57[v63];
      v63 += 8;
    }
    while (8 * v88 != v63);
  }
  v86 = v57;
  v8 = v90;
  if (*(_DWORD *)a2 == 4)
  {
    *((_QWORD *)v90 + 8) = malloc_type_malloc(8 * v18 * (int)v94, 0x100004000313F17uLL);
    if (v18 > 0)
    {
      v64 = 0;
      v65 = v103;
      do
      {
        v66 = v93->i32[v64];
        if ((int)v66 >= 1)
        {
          v67 = (int)v32[v64];
          v68 = v66 + v67;
          do
            *(double *)&v65[8 * v67++] = (double)(int)v64;
          while (v67 < v68);
        }
        ++v64;
      }
      while (v64 != v18);
    }
    v82 = *(_QWORD *)(a2 + 8);
    v96 = v94;
    v97 = v88;
    v100 = v82;
    v98 = v18;
    v99 = 100000;
    v101 = v102;
    v95[0] = operator new[]();
    v95[1] = v49;
    v95[2] = operator new[]();
    CPMLlinearSVM::Solver_MCSVM_CS::Solve((CPMLlinearSVM::Solver_MCSVM_CS *)v95, *((double **)v90 + 8));
    CPMLlinearSVM::Solver_MCSVM_CS::~Solver_MCSVM_CS((CPMLlinearSVM::Solver_MCSVM_CS *)v95);
  }
  else
  {
    if (v18 == 2)
    {
      v69 = (double *)malloc_type_malloc(8 * v84, 0x100004000313F17uLL);
      *((_QWORD *)v90 + 8) = v69;
      v70 = v93->i32[0] + *v32;
      if (v70 < 1)
        v70 = 0;
      else
        memset_pattern16(v103, &unk_209D00180, 8 * (v70 - 1) + 8);
      if (v70 < (int)v88)
        memset_pattern16(&v103[8 * v70], &unk_209D00190, 8 * (v88 + ~v70) + 8);
      train_one(v102, a2, v69, *v49, v49[1]);
    }
    else
    {
      *((_QWORD *)v90 + 8) = malloc_type_malloc(8 * v18 * (int)v94, 0x100004000313F17uLL);
      v92 = (double *)malloc_type_malloc(8 * v84, 0x100004000313F17uLL);
      v71 = v93;
      if (v18 >= 1)
      {
        v72 = 0;
        v73 = 0;
        v74 = 8 * v18;
        v89 = v18;
        do
        {
          v75 = v32[v73];
          v76 = v71->i32[v73];
          if ((int)v75 < 1)
          {
            v77 = 0;
          }
          else
          {
            memset_pattern16(v103, &unk_209D00190, 8 * v75);
            v77 = v75;
          }
          if (v77 < v76 + (int)v75)
          {
            memset_pattern16(&v103[8 * v77], &unk_209D00180, 8 * (~v77 + v76 + v75) + 8);
            v77 = v76 + v75;
          }
          if (v77 < (int)v102[0])
            memset_pattern16(&v103[8 * v77], &unk_209D00190, 8 * (v102[0] + ~v77) + 8);
          train_one(v102, a2, v92, v49[v73], *(double *)(a2 + 16));
          if ((int)v94 >= 1)
          {
            v78 = v92;
            v79 = (_QWORD *)(*((_QWORD *)v90 + 8) + v72);
            v80 = v94;
            do
            {
              v81 = *(_QWORD *)v78++;
              *v79 = v81;
              v79 = (_QWORD *)((char *)v79 + v74);
              --v80;
            }
            while (v80);
          }
          ++v73;
          v72 += 8;
          v71 = v93;
        }
        while (v73 != v89);
      }
      free(v92);
      v8 = v90;
    }
    v58 = v87;
  }
  free(v86);
  free(v15);
  free(v32);
  free(v93);
  free(v58);
  free(v104);
  free(v103);
  free(v49);
  return v8;
}

void sub_209CBDE00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  CPMLlinearSVM::Solver_MCSVM_CS::~Solver_MCSVM_CS((CPMLlinearSVM::Solver_MCSVM_CS *)va);
  _Unwind_Resume(a1);
}

BOOL check_regression_model(_DWORD *a1)
{
  return *a1 == 11 || *a1 == 13 || *a1 == 12;
}

size_t train_one(unsigned int *a1, uint64_t a2, double *a3, double a4, double a5)
{
  uint64_t v10;
  int v11;
  double *v12;
  uint64_t v13;
  double v14;
  int v15;
  double v16;
  double v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  double *v22;
  double v23;
  double v24;
  _QWORD *v25;
  uint64_t v26;
  double *v27;
  double v28;
  double v29;
  double v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  double *v34;
  double *v35;
  double v36;
  double v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  void *v45;
  uint64_t v46;
  uint64_t v47;
  double *v48;
  char *v49;
  _QWORD *v50;
  uint64_t v51;
  double v52;
  char v53;
  uint64_t v54;
  double v55;
  double v56;
  _DWORD *v57;
  int v58;
  double *v59;
  double v60;
  uint64_t v61;
  double v62;
  int v63;
  uint64_t v64;
  uint64_t v65;
  double v66;
  double *v67;
  char *v68;
  uint64_t v69;
  double v70;
  char v71;
  double *v72;
  char *v73;
  uint64_t v74;
  uint64_t v75;
  double v76;
  double v77;
  uint64_t v78;
  uint64_t v79;
  _DWORD *v80;
  int v81;
  double v82;
  double *v83;
  double v84;
  double v85;
  int v86;
  unsigned int v87;
  double v88;
  uint64_t v89;
  int v90;
  int v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  double *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  double v99;
  double v100;
  _DWORD *v101;
  int v102;
  double v103;
  double *v104;
  int v105;
  int v106;
  double v107;
  double v108;
  int v109;
  int v110;
  double v111;
  double v112;
  double v113;
  double v114;
  double v115;
  double v116;
  double v117;
  uint64_t v118;
  unsigned int v119;
  double v120;
  double v121;
  double v122;
  unsigned int v123;
  double *v124;
  int v125;
  unsigned int v126;
  unint64_t v127;
  double v128;
  double v129;
  double *v130;
  size_t result;
  int v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  _QWORD *v136;
  uint64_t v137;
  double *v138;
  _QWORD *v139;
  char *v140;
  uint64_t v141;
  double v142;
  char v143;
  double v144;
  uint64_t v145;
  _DWORD *v146;
  int v147;
  double *v148;
  double v149;
  uint64_t v150;
  uint64_t v151;
  double v152;
  unsigned int v153;
  double v154;
  double v155;
  double v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  int v160;
  double v161;
  double v162;
  double v163;
  uint64_t v164;
  int v165;
  int *v166;
  int v167;
  double v168;
  double v169;
  double *v170;
  int v171;
  uint64_t v172;
  double v173;
  double v174;
  double v175;
  int v176;
  uint64_t v177;
  double v178;
  double v179;
  double v180;
  double v181;
  double v182;
  double v183;
  double v185;
  double v186;
  BOOL v187;
  double v188;
  double v189;
  int v190;
  double v191;
  double v192;
  double v193;
  double *v194;
  double v195;
  int v196;
  double v197;
  double v198;
  double v199;
  double *v200;
  int v201;
  uint64_t v202;
  double v203;
  int v204;
  double *v205;
  int v206;
  uint64_t v207;
  double v208;
  double v209;
  int v210;
  double v211;
  uint64_t v212;
  double v213;
  _DWORD *v214;
  int v215;
  double v216;
  double *v217;
  int v218;
  int v219;
  unint64_t v220;
  double *v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  _QWORD *v226;
  _QWORD *v227;
  uint64_t v228;
  uint64_t v229;
  double *v230;
  double *v231;
  int v232;
  uint64_t v233;
  double v234;
  double v235;
  double v236;
  double *v237;
  char *v238;
  long double v239;
  double v240;
  long double v241;
  long double v242;
  uint64_t v243;
  long double v244;
  unsigned int v245;
  long double *v246;
  char *v247;
  double *v248;
  double *v249;
  uint64_t v250;
  long double v251;
  uint64_t v252;
  long double v253;
  double v254;
  uint64_t v255;
  double v256;
  uint64_t v257;
  double v258;
  double v259;
  double v260;
  int v261;
  double *v262;
  uint64_t v263;
  int v264;
  double v265;
  double v266;
  double v267;
  int v268;
  double v269;
  double *v270;
  double *v271;
  int v272;
  _DWORD *v273;
  int v274;
  double v275;
  double *v276;
  double v277;
  int v278;
  double v279;
  int v280;
  double v281;
  double v282;
  double v283;
  double v284;
  double v285;
  BOOL v286;
  unsigned int v287;
  int v288;
  unsigned int v289;
  double v290;
  double v291;
  int v292;
  uint64_t v293;
  uint64_t v294;
  uint64_t v295;
  int v296;
  int v297;
  double v298;
  double v299;
  double v300;
  double v301;
  int v302;
  double v303;
  _DWORD *v304;
  double v305;
  double v306;
  int v307;
  double *v308;
  int v309;
  int v310;
  double v311;
  double v312;
  double v313;
  double v314;
  double v315;
  double v317;
  double v318;
  double v319;
  double v320;
  double *v321;
  int v322;
  double v323;
  double v324;
  double v325;
  uint64_t v326;
  double *v327;
  double *v328;
  double *v329;
  double v330;
  double v331;
  double v332;
  double v333;
  double v334;
  double v335;
  unsigned __int8 *v336;
  uint64_t v337;
  double *v338;
  int v339;
  int v340;
  double v341;
  double v342;
  double *v343;
  double *v344;
  char *v345;
  double v346;
  double *v347;
  uint64_t v348;
  long double v349;
  long double v350;
  double v351;
  long double v352;
  uint64_t v353;
  double v354;
  double *v355;
  double *v356;
  uint64_t v357;
  double v358;
  double v359;
  double v360;
  double v361;
  double v362;
  double *v363;
  uint64_t v364;
  double *v365;
  char *v366;
  double *v367;
  double *v368;
  uint64_t v369;
  double v370;
  double v371;
  double v372;
  uint64_t v373;
  double v374;
  double v375;
  uint64_t v376;
  double v377;
  _DWORD *v378;
  int v379;
  double *v380;
  int v381;
  long double *v382;
  uint64_t v383;
  double v384;
  uint64_t v385;
  uint64_t v386;
  int v387;
  double v388;
  double v389;
  double v390;
  BOOL v391;
  double v392;
  char *v393;
  double *v394;
  uint64_t v395;
  uint64_t v396;
  double v397;
  double v398;
  uint64_t v399;
  int v400;
  double v401;
  double *v402;
  _DWORD *v403;
  int v404;
  double *v405;
  double v406;
  double v407;
  BOOL v408;
  double v409;
  double *v410;
  char *v411;
  double v412;
  uint64_t v413;
  uint64_t v414;
  uint64_t v415;
  uint64_t v416;
  int v417;
  double v418;
  double v419;
  double v420;
  double v421;
  uint64_t v422;
  unsigned int v423;
  unsigned int *v424;
  double v425;
  uint64_t v426;
  int v427;
  double *v428;
  double v429;
  double v430;
  int v431;
  unsigned int v432;
  double v433;
  unsigned __int8 *v434;
  size_t __len;
  double *__lena;
  double v437;
  int v438;
  double v439;
  double v440;
  unsigned int v441;
  double v442;
  double *__src;
  double __srca;
  int __srcb;
  uint64_t v446;
  uint64_t v447;
  int v448;
  uint64_t v449;
  double v450;
  double v451;
  double v453;
  uint64_t v454;
  unsigned int v455;
  size_t v456;
  double v457;
  double *v458;
  double v459;
  double v460;
  uint64_t v461;
  double v462;
  uint64_t v463;

  v463 = *MEMORY[0x24BDAC8D0];
  v10 = *a1;
  if ((int)v10 < 1)
  {
    v11 = 0;
  }
  else
  {
    v11 = 0;
    v12 = (double *)*((_QWORD *)a1 + 1);
    v13 = *a1;
    do
    {
      v14 = *v12++;
      if (v14 > 0.0)
        ++v11;
      --v13;
    }
    while (v13);
  }
  if (v11 >= (int)v10 - v11)
    v11 = v10 - v11;
  if (v11 <= 1)
    v15 = 1;
  else
    v15 = v11;
  v16 = *(double *)(a2 + 8);
  v17 = v16 * (double)v15 / (double)(int)v10;
  switch(*(_DWORD *)a2)
  {
    case 0:
      v18 = operator new[]();
      v19 = v18;
      v20 = *a1;
      if ((int)v20 >= 1)
      {
        v21 = (double *)*((_QWORD *)a1 + 1);
        v22 = (double *)v18;
        do
        {
          v23 = *v21++;
          if (v23 <= 0.0)
            v24 = a5;
          else
            v24 = a4;
          *v22++ = v24;
          --v20;
        }
        while (v20);
      }
      v25 = (_QWORD *)operator new();
      CPMLlinearSVM::l2r_lr_fun::l2r_lr_fun(v25, (uint64_t)a1, v19);
      v26 = CPMLlinearSVM::TRON::TRON((uint64_t)&v457, (uint64_t)v25, 1000, v17);
      CPMLlinearSVM::TRON::set_print_string(v26, (void (*)(const char *))liblinear_print_string);
      CPMLlinearSVM::TRON::tron((CPMLlinearSVM::TRON *)&v457, a3);
      goto LABEL_29;
    case 1:
      v27 = a3;
      v28 = v16;
      v29 = a4;
      v30 = a5;
      v31 = 1;
      goto LABEL_116;
    case 2:
      v32 = operator new[]();
      v19 = v32;
      v33 = *a1;
      if ((int)v33 >= 1)
      {
        v34 = (double *)*((_QWORD *)a1 + 1);
        v35 = (double *)v32;
        do
        {
          v36 = *v34++;
          if (v36 <= 0.0)
            v37 = a5;
          else
            v37 = a4;
          *v35++ = v37;
          --v33;
        }
        while (v33);
      }
      v25 = (_QWORD *)operator new();
      CPMLlinearSVM::l2r_l2_svc_fun::l2r_l2_svc_fun(v25, (uint64_t)a1, v19);
      v38 = CPMLlinearSVM::TRON::TRON((uint64_t)&v457, (uint64_t)v25, 1000, v17);
      CPMLlinearSVM::TRON::set_print_string(v38, (void (*)(const char *))liblinear_print_string);
      CPMLlinearSVM::TRON::tron((CPMLlinearSVM::TRON *)&v457, a3);
LABEL_29:
      (*(void (**)(_QWORD *))(*v25 + 40))(v25);
      v39 = v19;
      goto LABEL_211;
    case 3:
      v27 = a3;
      v28 = v16;
      v29 = a4;
      v30 = a5;
      v31 = 3;
LABEL_116:
      solve_l2r_l1l2_svc((uint64_t)a1, v27, v31, v28, v29, v30);
    case 5:
      v456 = 0;
      transpose((int *)a1, (uint64_t *)&v456, (uint64_t)&v457);
      v454 = LODWORD(v457);
      v132 = HIDWORD(v457);
      v133 = HIDWORD(v457);
      v134 = operator new[]();
      v135 = operator new[]();
      v136 = (_QWORD *)operator new[]();
      v137 = operator new[]();
      v460 = a5;
      v461 = 0;
      v462 = a4;
      v447 = v137;
      if (v132 >= 1)
      {
        bzero(a3, 8 * v133);
        v137 = v447;
      }
      if ((int)v454 >= 1)
      {
        v138 = v458;
        v139 = v136;
        v140 = (char *)v135;
        v141 = v454;
        do
        {
          *v139++ = 0x3FF0000000000000;
          v142 = *v138++;
          if (v142 > 0.0)
            v143 = 1;
          else
            v143 = -1;
          *v140++ = v143;
          --v141;
        }
        while (v141);
      }
      v144 = v459;
      if (v132 >= 1)
      {
        v145 = 0;
        do
        {
          *(_DWORD *)(v134 + 4 * v145) = v145;
          *(_QWORD *)(v137 + 8 * v145) = 0;
          v146 = *(_DWORD **)(*(_QWORD *)&v144 + 8 * v145);
          v147 = *v146;
          if (*v146 != -1)
          {
            v148 = (double *)(v146 + 2);
            v149 = 0.0;
            do
            {
              v150 = v147 - 1;
              v151 = *(char *)(v135 + v150);
              v152 = *v148 * (double)(int)v151;
              *v148 = v152;
              *(double *)&v136[v150] = *(double *)&v136[v150] - a3[v145] * v152;
              v149 = v149 + v152 * *(&v460 + v151 + 1) * v152;
              *(double *)(v137 + 8 * v145) = v149;
              v147 = *((_DWORD *)v148 + 2);
              v148 += 2;
            }
            while (v147 != -1);
          }
          ++v145;
        }
        while (v145 != v133);
      }
      v153 = 0;
      v433 = (double)(int)v454;
      v154 = 0.0;
      v155 = INFINITY;
      v156 = -1.0;
      __srcb = v132;
      while (2)
      {
        v441 = v153;
        v439 = v156;
        if (v132 >= 1)
        {
          v157 = 0;
          v158 = v132;
          do
          {
            v159 = v157 + rand() % (int)v158;
            v160 = *(_DWORD *)(v134 + 4 * v159);
            *(_DWORD *)(v134 + 4 * v159) = *(_DWORD *)(v134 + 4 * v157);
            *(_DWORD *)(v134 + 4 * v157++) = v160;
            --v158;
          }
          while (v158);
          v451 = v155 / v433;
          v161 = -v155;
          v162 = 0.0;
          v155 = 0.0;
          v163 = v161 / v433;
          v164 = v447;
          while (1)
          {
            v165 = *(_DWORD *)(v134 + 4 * (int)v158);
            v166 = *(int **)(*(_QWORD *)&v144 + 8 * v165);
            v167 = *v166;
            v168 = 0.0;
            v169 = 0.0;
            if (*v166 != -1)
            {
              v170 = (double *)(v166 + 4);
              v171 = *v166;
              do
              {
                v172 = v171 - 1;
                v173 = *(double *)&v136[v172];
                if (v173 > 0.0)
                {
                  v174 = *(v170 - 1);
                  v175 = v174 * *(&v460 + *(char *)(v135 + v172) + 1);
                  v168 = v168 - v175 * v173;
                  v169 = v169 + v175 * v174;
                }
                v176 = *(_DWORD *)v170;
                v170 += 2;
                v171 = v176;
              }
              while (v176 != -1);
            }
            v177 = v165;
            v178 = v168 + v168;
            v179 = v178 + 1.0;
            v180 = v178 + -1.0;
            v181 = a3[v165];
            if (v181 == 0.0)
            {
              if (v179 >= 0.0)
              {
                v182 = v178 + -1.0;
                if (v180 <= 0.0)
                {
                  v182 = 0.0;
                  if (v179 > v451 && v180 < v163)
                  {
                    *(_DWORD *)(v134 + 4 * (int)v158) = *(_DWORD *)(v134 + 4 * --v132);
                    *(_DWORD *)(v134 + 4 * v132) = v165;
                    LODWORD(v158) = v158 - 1;
                    goto LABEL_195;
                  }
                }
              }
              else
              {
                v182 = -(v178 + 1.0);
              }
            }
            else
            {
              v182 = fabs(v180);
              v183 = fabs(v179);
              if (v181 > 0.0)
                v182 = v183;
            }
            v185 = fmax(v169 + v169, 1.0e-12);
            if (v155 <= v182)
              v155 = v182;
            v162 = v162 + v182;
            v186 = v181 * v185;
            v187 = v180 <= v181 * v185;
            v188 = -v180 / v185;
            if (v187)
              v188 = -v181;
            v189 = -(v178 + 1.0) / v185;
            if (v179 >= v186)
              v189 = v188;
            if (fabs(v189) >= 1.0e-12)
              break;
LABEL_195:
            LODWORD(v158) = v158 + 1;
            if ((int)v158 >= v132)
              goto LABEL_198;
          }
          v190 = 0;
          v191 = fabs(v181);
          v192 = fabs(v181 + v189) - v191 + v178 * v189;
          v193 = *(double *)(v164 + 8 * v177);
          v194 = (double *)(v166 + 4);
          v195 = 0.0;
          v196 = v167;
          while (1)
          {
            v197 = v195 - v189;
            v198 = fabs(v181 + v189) - v191 + v192 * -0.01;
            if (v178 * v189 + v193 * v189 * v189 + v198 <= 0.0)
            {
              while (v196 != -1)
              {
                *(double *)&v136[v196 - 1] = *(double *)&v136[v196 - 1] + v197 * *(v194 - 1);
                v219 = *(_DWORD *)v194;
                v194 += 2;
                v196 = v219;
              }
LABEL_193:
              a3[v177] = v181 + v189;
              goto LABEL_195;
            }
            if (v190)
            {
              if (v196 != -1)
              {
                v199 = 0.0;
                v200 = v194;
                v201 = v196;
                do
                {
                  v202 = v201 - 1;
                  v203 = *(double *)&v136[v202] + v197 * *(v200 - 1);
                  *(double *)&v136[v202] = v203;
                  if (v203 > 0.0)
                    v199 = v199 + v203 * *(&v460 + *(char *)(v135 + v202) + 1) * v203;
                  v204 = *(_DWORD *)v200;
                  v200 += 2;
                  v201 = v204;
                }
                while (v204 != -1);
                goto LABEL_179;
              }
            }
            else
            {
              if (v167 != -1)
              {
                v199 = 0.0;
                v205 = v194;
                v206 = v167;
                v154 = 0.0;
                do
                {
                  v207 = v206 - 1;
                  v208 = *(double *)&v136[v207];
                  if (v208 > 0.0)
                    v154 = v154 + v208 * *(&v460 + *(char *)(v135 + v207) + 1) * v208;
                  v209 = v208 + v197 * *(v205 - 1);
                  *(double *)&v136[v207] = v209;
                  if (v209 > 0.0)
                    v199 = v199 + v209 * *(&v460 + *(char *)(v135 + v207) + 1) * v209;
                  v210 = *(_DWORD *)v205;
                  v205 += 2;
                  v206 = v210;
                }
                while (v210 != -1);
                v196 = v167;
                goto LABEL_179;
              }
              v154 = 0.0;
              v196 = -1;
            }
            v199 = 0.0;
LABEL_179:
            if (v198 + v199 - v154 <= 0.0)
              goto LABEL_193;
            v211 = v189 * 0.5;
            v192 = v192 * 0.5;
            ++v190;
            v195 = v189;
            v189 = v189 * 0.5;
            if (v190 == 20)
            {
              a3[v177] = v181 + v211;
              info("#");
              if ((int)v454 >= 1)
                memset_pattern16(v136, &unk_209D00180, 8 * v454);
              v164 = v447;
              if (__srcb >= 1)
              {
                v212 = 0;
                do
                {
                  v213 = a3[v212];
                  if (v213 != 0.0)
                  {
                    v214 = *(_DWORD **)(*(_QWORD *)&v144 + 8 * v212);
                    v215 = *v214;
                    if (*v214 != -1)
                    {
                      v216 = -v213;
                      v217 = (double *)(v214 + 4);
                      do
                      {
                        *(double *)&v136[v215 - 1] = *(double *)&v136[v215 - 1] + v216 * *(v217 - 1);
                        v218 = *(_DWORD *)v217;
                        v217 += 2;
                        v215 = v218;
                      }
                      while (v218 != -1);
                    }
                  }
                  ++v212;
                }
                while (v212 != v133);
              }
              goto LABEL_195;
            }
          }
        }
        v155 = 0.0;
        v162 = 0.0;
LABEL_198:
        v156 = v439;
        if (!v441)
          v156 = v162;
        HIDWORD(v220) = -858993459 * (v441 + 1);
        LODWORD(v220) = HIDWORD(v220);
        if ((v220 >> 1) <= 0x19999999)
          info(".");
        if (v162 > v17 * v156)
          goto LABEL_205;
        v391 = v132 == __srcb;
        v132 = __srcb;
        if (!v391)
        {
          info("*");
          v155 = INFINITY;
LABEL_205:
          v153 = v441 + 1;
          v221 = a3;
          if (v441 == 999)
          {
            info("\noptimization finished, #iter = %d\n", 1000);
            v132 = __srcb;
            goto LABEL_369;
          }
          continue;
        }
        break;
      }
      info("\noptimization finished, #iter = %d\n", v441 + 1);
      v221 = a3;
      if (v441 >= 0x3E7)
LABEL_369:
        info("\nWARNING: reaching max number of iterations\n");
      if (v132 < 1)
      {
        v400 = 0;
        v401 = 0.0;
      }
      else
      {
        v399 = 0;
        v400 = 0;
        v401 = 0.0;
        v402 = v458;
        do
        {
          v403 = *(_DWORD **)(*(_QWORD *)&v144 + 8 * v399);
          v404 = *v403;
          if (*v403 != -1)
          {
            v405 = (double *)(v403 + 2);
            do
            {
              *v405 = v402[v404 - 1] * *v405;
              v404 = *((_DWORD *)v405 + 2);
              v405 += 2;
            }
            while (v404 != -1);
          }
          v406 = v221[v399];
          v407 = fabs(v406);
          v408 = v406 == 0.0;
          v409 = -0.0;
          if (!v408)
            v409 = v407;
          v401 = v401 + v409;
          if (!v408)
            ++v400;
          ++v399;
        }
        while (v399 != v133);
      }
      if ((int)v454 >= 1)
      {
        v410 = (double *)v136;
        v411 = (char *)v135;
        do
        {
          if (*v410 > 0.0)
            v401 = v401 + *v410 * *(&v460 + *v411 + 1) * *v410;
          ++v411;
          ++v410;
          --v454;
        }
        while (v454);
      }
      info("Objective value = %lf\n", v401);
      info("#nonzeros/#features = %d/%d\n", v400, v132);
      MEMORY[0x20BD188CC](v134, 0x1000C8052888210);
      MEMORY[0x20BD188CC](v135, 0x1000C8077774924);
      MEMORY[0x20BD188CC](v136, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v447, 0x1000C8000313F17);
      if (v458)
        MEMORY[0x20BD188CC](v458, 0x1000C8000313F17);
      if (v144 != 0.0)
        goto LABEL_390;
      goto LABEL_391;
    case 6:
      v456 = 0;
      transpose((int *)a1, (uint64_t *)&v456, (uint64_t)&v457);
      v449 = LODWORD(v457);
      v40 = HIDWORD(v457);
      v426 = HIDWORD(v457);
      v41 = operator new[]();
      v42 = operator new[]();
      v43 = operator new[]();
      v414 = operator new[]();
      __src = (double *)operator new[]();
      v44 = operator new[]();
      v45 = (void *)operator new[]();
      v46 = operator new[]();
      v428 = (double *)operator new[]();
      v416 = operator new[]();
      v47 = operator new[]();
      v460 = a5;
      v461 = 0;
      v462 = a4;
      if (v40 >= 1)
        bzero(a3, 8 * v426);
      if ((int)v449 >= 1)
      {
        v48 = v458;
        v49 = (char *)v42;
        v50 = (_QWORD *)v46;
        v51 = v449;
        do
        {
          v52 = *v48++;
          if (v52 > 0.0)
            v53 = 1;
          else
            v53 = -1;
          *v49++ = v53;
          *v50++ = 0;
          --v51;
        }
        while (v51);
      }
      if (v40 < 1)
      {
        v437 = 0.0;
      }
      else
      {
        v54 = 0;
        v437 = 0.0;
        v55 = v459;
        do
        {
          v56 = a3[v54];
          __src[v54] = v56;
          *(_DWORD *)(v41 + 4 * v54) = v54;
          *(_QWORD *)(v44 + 8 * v54) = 0;
          v57 = *(_DWORD **)(*(_QWORD *)&v55 + 8 * v54);
          v58 = *v57;
          if (*v57 != -1)
          {
            v59 = (double *)(v57 + 4);
            v60 = 0.0;
            do
            {
              v61 = v58 - 1;
              v62 = *(v59 - 1);
              *(double *)(v46 + 8 * v61) = *(double *)(v46 + 8 * v61) + v56 * v62;
              if (*(unsigned __int8 *)(v42 + v61) == 255)
              {
                v60 = v60 + a5 * v62;
                *(double *)(v44 + 8 * v54) = v60;
              }
              v63 = *(_DWORD *)v59;
              v59 += 2;
              v58 = v63;
            }
            while (v63 != -1);
          }
          v437 = v437 + fabs(v56);
          ++v54;
        }
        while (v54 != v426);
      }
      v434 = (unsigned __int8 *)v42;
      __lena = (double *)v46;
      v413 = v44;
      v431 = v40;
      v425 = a5;
      v412 = a4;
      if ((int)v449 >= 1)
      {
        v247 = (char *)v42;
        v246 = (long double *)v46;
        v248 = (double *)v416;
        v249 = (double *)v47;
        v250 = v449;
        do
        {
          v251 = exp(*v246);
          *v246++ = v251;
          v252 = *v247++;
          v253 = 1.0 / (v251 + 1.0);
          v254 = *(&v460 + v252 + 1);
          *v248++ = v254 * v253;
          *v249++ = v253 * (v253 * (v251 * v254));
          --v250;
        }
        while (v250);
      }
      v423 = 0;
      v255 = v449;
      v256 = (double)(int)v449;
      v415 = 8 * v449;
      v257 = v426;
      v258 = -1.0;
      v442 = v459;
      v259 = INFINITY;
      v260 = -1.0;
      v420 = v17;
      v421 = 1.0;
      v261 = v431;
      v262 = (double *)v414;
      v263 = v416;
LABEL_231:
      if (v261 >= 1)
      {
        v264 = 0;
        v265 = v259 / v256;
        v266 = -v259;
        v259 = 0.0;
        v267 = 0.0;
        v268 = v261;
        v269 = v266 / v256;
        v270 = a3;
        v271 = __src;
        while (1)
        {
          v272 = *(_DWORD *)(v41 + 4 * v264);
          *(_QWORD *)(v43 + 8 * v272) = 0x3D719799812DEA11;
          v273 = *(_DWORD **)(*(_QWORD *)&v442 + 8 * v272);
          v274 = *v273;
          v275 = 0.0;
          if (*v273 != -1)
          {
            v276 = (double *)(v273 + 4);
            v277 = 1.0e-12;
            do
            {
              v278 = v274 - 1;
              v279 = *(v276 - 1);
              v277 = v277 + v279 * v279 * *(double *)(v47 + 8 * v278);
              *(double *)(v43 + 8 * v272) = v277;
              v275 = v275 + v279 * *(double *)(v263 + 8 * v278);
              v280 = *(_DWORD *)v276;
              v276 += 2;
              v274 = v280;
            }
            while (v280 != -1);
          }
          v281 = *(double *)(v413 + 8 * v272) - v275;
          v262[v272] = v281;
          v282 = v281 + 1.0;
          v283 = v281 + v258;
          v284 = a3[v272];
          if (v284 != 0.0)
            break;
          if (v282 < 0.0)
          {
            v283 = -v282;
LABEL_247:
            if (v267 <= v283)
              v267 = v283;
            v259 = v259 + v283;
            goto LABEL_250;
          }
          if (v283 > 0.0)
            goto LABEL_247;
          v286 = v282 > v265 && v283 < v269;
          v283 = 0.0;
          if (!v286)
            goto LABEL_247;
          *(_DWORD *)(v41 + 4 * v264) = *(_DWORD *)(v41 + 4 * --v268);
          *(_DWORD *)(v41 + 4 * v268) = v272;
          --v264;
LABEL_250:
          if (++v264 >= v268)
            goto LABEL_254;
        }
        v283 = fabs(v283);
        v285 = fabs(v282);
        if (v284 > 0.0)
          v283 = v285;
        goto LABEL_247;
      }
      v267 = 0.0;
      v268 = v261;
      v259 = 0.0;
      v270 = a3;
      v271 = __src;
LABEL_254:
      v287 = v423;
      if (!v423)
        v260 = v259;
      if (v259 > v17 * v260)
      {
        v419 = v267;
        v288 = v268;
        if ((int)v255 >= 1)
        {
          bzero(v45, v415);
          v268 = v288;
          v255 = v449;
        }
        v289 = 0;
        v418 = v260;
        v290 = v421 * v260;
        v291 = INFINITY;
        v292 = v268;
        while (1)
        {
          v455 = v289;
          if (v292 >= 1)
            break;
          v291 = 0.0;
          v300 = 0.0;
LABEL_293:
          if (v300 <= v290)
          {
            if (v292 == v268)
            {
              v417 = v455 + 1;
              if (v455 >= 0x3E7)
              {
LABEL_299:
                info("WARNING: reaching max number of inner iterations\n");
                v255 = v449;
              }
              v323 = 0.0;
              v324 = 0.0;
              v325 = 0.0;
              v326 = v426;
              if (v431 >= 1)
              {
                v327 = v262;
                v328 = v271;
                v329 = v270;
                do
                {
                  v330 = *v327++;
                  v331 = v330;
                  v332 = *v328++;
                  v333 = v332;
                  v334 = *v329++;
                  v325 = v325 + v331 * (v333 - v334);
                  v335 = fabs(v333);
                  if (v333 == 0.0)
                    v335 = -0.0;
                  v324 = v324 + v335;
                  --v326;
                }
                while (v326);
              }
              if ((int)v255 >= 1)
              {
                v323 = 0.0;
                v336 = v434;
                v337 = v255;
                v338 = (double *)v45;
                do
                {
                  v339 = *v336++;
                  if (v339 == 255)
                    v323 = v323 + v425 * *v338;
                  ++v338;
                  --v337;
                }
                while (v337);
              }
              v340 = 0;
              v341 = v325 + v324 - v437;
              while (1)
              {
                v448 = v340;
                v342 = v323;
                v343 = (double *)v45;
                v345 = (char *)v434;
                v344 = __lena;
                v346 = v323 + v324 - v437 + v341 * -0.01;
                v347 = v428;
                v348 = v255;
                if ((int)v255 >= 1)
                {
                  do
                  {
                    v349 = *v343++;
                    v350 = exp(v349);
                    v351 = *v344++;
                    v352 = v351 * v350;
                    *v347++ = v351 * v350;
                    v353 = *v345++;
                    v354 = *(&v460 + v353 + 1);
                    v346 = v346 + v354 * log((v352 + 1.0) / (v350 + v352));
                    --v348;
                  }
                  while (v348);
                }
                if (v346 <= 0.0)
                  break;
                v261 = v431;
                v355 = __src;
                v324 = 0.0;
                if (v431 < 1)
                {
                  v255 = v449;
                  v358 = v342;
                }
                else
                {
                  v356 = a3;
                  v357 = v426;
                  v255 = v449;
                  v358 = v342;
                  do
                  {
                    v359 = *v356++;
                    v360 = (v359 + *v355) * 0.5;
                    *v355++ = v360;
                    v361 = fabs(v360);
                    v391 = v360 == 0.0;
                    v362 = -0.0;
                    if (!v391)
                      v362 = v361;
                    v324 = v324 + v362;
                    --v357;
                  }
                  while (v357);
                }
                v341 = v341 * 0.5;
                v323 = v358 * 0.5;
                v363 = (double *)v45;
                v364 = v255;
                if ((int)v255 < 1)
                {
                  v340 = v448 + 1;
                  if (v448 == 19)
                    goto LABEL_333;
                }
                else
                {
                  do
                  {
                    *v363 = *v363 * 0.5;
                    ++v363;
                    --v364;
                  }
                  while (v364);
                  v340 = v448 + 1;
                  if (v448 == 19)
                  {
                    bzero(__lena, v415);
                    v255 = v449;
LABEL_333:
                    v263 = v416;
                    v257 = v426;
                    v256 = (double)(int)v449;
                    v258 = -1.0;
                    if (v431 >= 1)
                    {
                      v376 = 0;
                      do
                      {
                        v377 = a3[v376];
                        if (v377 != 0.0)
                        {
                          v378 = *(_DWORD **)(*(_QWORD *)&v442 + 8 * v376);
                          v379 = *v378;
                          if (*v378 != -1)
                          {
                            v380 = (double *)(v378 + 4);
                            do
                            {
                              __lena[v379 - 1] = __lena[v379 - 1] + v377 * *(v380 - 1);
                              v381 = *(_DWORD *)v380;
                              v380 += 2;
                              v379 = v381;
                            }
                            while (v381 != -1);
                          }
                        }
                        ++v376;
                      }
                      while (v376 != v426);
                    }
                    v382 = __lena;
                    v383 = v255;
                    if ((int)v255 >= 1)
                    {
                      do
                      {
                        *v382 = exp(*v382);
                        ++v382;
                        --v383;
                      }
                      while (v383);
                    }
                    v324 = v437;
                    v262 = (double *)v414;
                    goto LABEL_343;
                  }
                }
              }
              v261 = v431;
              v262 = (double *)v414;
              if (v431 >= 1)
                memcpy(a3, __src, 8 * v426);
              v263 = v416;
              v257 = v426;
              v256 = (double)(int)v449;
              v258 = -1.0;
              if ((int)v449 >= 1)
              {
                v365 = v428;
                memcpy(__lena, v428, v415);
                v366 = (char *)v434;
                v367 = (double *)v416;
                v368 = (double *)v47;
                v369 = v449;
                do
                {
                  v370 = *v365++;
                  v371 = v370;
                  v372 = v370 + 1.0;
                  v373 = *v366++;
                  v374 = 1.0 / v372;
                  v375 = *(&v460 + v373 + 1);
                  *v367++ = v374 * v375;
                  *v368++ = v374 * (v374 * (v371 * v375));
                  --v369;
                }
                while (v369);
              }
LABEL_343:
              v384 = v421;
              if (!v455)
                v384 = v421 * 0.25;
              v421 = v384;
              info("iter %3d  #CD cycles %d\n", v423 + 1, v417);
              v437 = v324;
              ++v423;
              v259 = v419;
              v17 = v420;
              v255 = v449;
              v260 = v418;
              if (v423 == 100)
              {
                v287 = 100;
                v270 = a3;
                goto LABEL_347;
              }
              goto LABEL_231;
            }
            v291 = INFINITY;
            v292 = v268;
          }
          v289 = v455 + 1;
          if (v455 == 999)
          {
            v455 = 999;
            v417 = 1000;
            goto LABEL_299;
          }
        }
        v293 = 0;
        v294 = v292;
        do
        {
          v295 = v293 + rand() % (int)v294;
          v296 = *(_DWORD *)(v41 + 4 * v295);
          *(_DWORD *)(v41 + 4 * v295) = *(_DWORD *)(v41 + 4 * v293);
          *(_DWORD *)(v41 + 4 * v293++) = v296;
          --v294;
        }
        while (v294);
        v297 = 0;
        v298 = v291 / v256;
        v299 = -v291;
        v300 = 0.0;
        v291 = 0.0;
        v301 = v299 / v256;
        v255 = v449;
        v270 = a3;
        v271 = __src;
        v268 = v288;
        while (1)
        {
          v302 = *(_DWORD *)(v41 + 4 * v297);
          v303 = *(double *)(v43 + 8 * v302);
          v304 = *(_DWORD **)(*(_QWORD *)&v442 + 8 * v302);
          v305 = __src[v302];
          v306 = v262[v302] + (v305 - a3[v302]) * 1.0e-12;
          v307 = *v304;
          if (*v304 != -1)
          {
            v308 = (double *)(v304 + 4);
            v309 = *v304;
            do
            {
              v306 = v306 + *(v308 - 1) * *(double *)(v47 + 8 * (v309 - 1)) * *((double *)v45 + v309 - 1);
              v310 = *(_DWORD *)v308;
              v308 += 2;
              v309 = v310;
            }
            while (v310 != -1);
          }
          v311 = v306 + 1.0;
          v312 = v306 + v258;
          v313 = -(v306 + 1.0);
          if (v305 != 0.0)
            break;
          if (v311 < 0.0)
          {
            v314 = v313;
LABEL_278:
            if (v291 <= v314)
              v291 = v314;
            v300 = v300 + v314;
            v317 = v303 * v305;
            v187 = v312 <= v303 * v305;
            v318 = -v312 / v303;
            if (v187)
              v318 = -v305;
            v319 = v313 / v303;
            if (v311 >= v317)
              v319 = v318;
            if (fabs(v319) >= 1.0e-12)
            {
              v320 = fmin(fmax(v319, -10.0), 10.0);
              __src[v302] = v305 + v320;
              if (v307 != -1)
              {
                v321 = (double *)(v304 + 4);
                do
                {
                  *((double *)v45 + v307 - 1) = *((double *)v45 + v307 - 1) + *(v321 - 1) * v320;
                  v322 = *(_DWORD *)v321;
                  v321 += 2;
                  v307 = v322;
                }
                while (v322 != -1);
              }
            }
            goto LABEL_290;
          }
          v314 = v312;
          if (v312 > 0.0)
            goto LABEL_278;
          v314 = 0.0;
          if (v311 <= v298 || v312 >= v301)
            goto LABEL_278;
          *(_DWORD *)(v41 + 4 * v297) = *(_DWORD *)(v41 + 4 * --v292);
          *(_DWORD *)(v41 + 4 * v292) = v302;
          --v297;
LABEL_290:
          if (++v297 >= v292)
            goto LABEL_293;
        }
        v314 = fabs(v312);
        v315 = fabs(v311);
        if (v305 > 0.0)
          v314 = v315;
        goto LABEL_278;
      }
LABEL_347:
      info("=========================\n", v259);
      info("optimization finished, #iter = %d\n", v287);
      if (v287 >= 0x64)
        info("WARNING: reaching max number of iterations\n");
      v385 = v449;
      if (v261 < 1)
      {
        v387 = 0;
        v388 = 0.0;
      }
      else
      {
        v386 = v257;
        v387 = 0;
        v388 = 0.0;
        do
        {
          v389 = *v270++;
          v390 = fabs(v389);
          v391 = v389 == 0.0;
          v392 = -0.0;
          if (v389 != 0.0)
            v392 = v390;
          v388 = v388 + v392;
          if (!v391)
            ++v387;
          --v386;
        }
        while (v386);
      }
      if ((int)v449 >= 1)
      {
        v393 = (char *)v434;
        v394 = __lena;
        do
        {
          v396 = *v393++;
          v395 = v396;
          if (v396 == 1)
          {
            v397 = v412;
            v398 = 1.0 / *v394;
          }
          else
          {
            v397 = *(&v460 + v395 + 1);
            v398 = *v394;
          }
          v388 = v388 + v397 * log(v398 + 1.0);
          ++v394;
          --v385;
        }
        while (v385);
      }
      info("Objective value = %lf\n", v388);
      info("#nonzeros/#features = %d/%d\n", v387, v261);
      MEMORY[0x20BD188CC](v41, 0x1000C8052888210);
      MEMORY[0x20BD188CC](v434, 0x1000C8077774924);
      MEMORY[0x20BD188CC](v43, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v414, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](__src, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v413, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v45, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](__lena, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v428, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v416, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v47, 0x1000C8000313F17);
      if (v458)
        MEMORY[0x20BD188CC](v458, 0x1000C8000313F17);
      if (v442 != 0.0)
LABEL_390:
        MEMORY[0x20BD188CC]();
LABEL_391:
      result = v456;
      if (v456)
      {
        v245 = -134694581;
        return MEMORY[0x20BD188CC](result, v245 | 0x1000C8000000000);
      }
      return result;
    case 7:
      v422 = a1[1];
      v64 = operator new[]();
      v65 = operator new[]();
      v446 = operator new[]();
      __len = operator new[]();
      v457 = a5;
      if (v16 <= 0.00000001)
        v66 = v16;
      else
        v66 = 0.00000001;
      v429 = v66;
      v458 = 0;
      v459 = a4;
      if ((int)v10 >= 1)
      {
        v67 = (double *)*((_QWORD *)a1 + 1);
        v68 = (char *)__len;
        v69 = v10;
        do
        {
          v70 = *v67++;
          if (v70 > 0.0)
            v71 = 1;
          else
            v71 = -1;
          *v68++ = v71;
          --v69;
        }
        while (v69);
        v72 = (double *)(v446 + 8);
        v73 = (char *)__len;
        v74 = v10;
        do
        {
          v75 = *v73++;
          v76 = *(&v457 + v75 + 1);
          v77 = fmin(v76 * 0.001, 0.00000001);
          *(v72 - 1) = v77;
          *v72 = v76 - v77;
          v72 += 2;
          --v74;
        }
        while (v74);
      }
      if ((int)v422 >= 1)
        bzero(a3, 8 * v422);
      if ((int)v10 > 0)
      {
        v78 = 0;
        v79 = *((_QWORD *)a1 + 2);
        do
        {
          *(_QWORD *)(v64 + 8 * v78) = 0;
          v80 = *(_DWORD **)(v79 + 8 * v78);
          v81 = *v80;
          if (*v80 != -1)
          {
            v82 = *(double *)(v446 + 16 * v78) * (double)*(char *)(__len + v78);
            v83 = (double *)(v80 + 4);
            v84 = 0.0;
            do
            {
              v85 = *(v83 - 1);
              v84 = v84 + v85 * v85;
              *(double *)(v64 + 8 * v78) = v84;
              a3[v81 - 1] = a3[v81 - 1] + v82 * v85;
              v86 = *(_DWORD *)v83;
              v83 += 2;
              v81 = v86;
            }
            while (v86 != -1);
          }
          *(_DWORD *)(v65 + 4 * v78) = v78;
          ++v78;
        }
        while (v78 != v10);
      }
      v430 = v16;
      v424 = a1;
      v87 = 0;
      v427 = (int)v10 / 10;
      v453 = 0.01;
      v88 = 0.5;
      while (1)
      {
        v432 = v87;
        if ((int)v10 < 1)
        {
          v438 = 0;
          v450 = 0.0;
        }
        else
        {
          v89 = 0;
          v90 = v10;
          do
          {
            v91 = v89 + rand() % v90;
            v92 = *(_DWORD *)(v65 + 4 * v89);
            *(_DWORD *)(v65 + 4 * v89) = *(_DWORD *)(v65 + 4 * v91);
            *(_DWORD *)(v65 + 4 * v91) = v92;
            ++v89;
            --v90;
          }
          while (v10 != v89);
          v93 = 0;
          v438 = 0;
          v94 = *((_QWORD *)v424 + 2);
          v450 = 0.0;
          v95 = a3;
          do
          {
            v96 = *(int *)(v65 + 4 * v93);
            v97 = *(char *)(__len + v96);
            v98 = v64;
            v99 = *(double *)(v64 + 8 * v96);
            v100 = *(&v457 + v97 + 1);
            v101 = *(_DWORD **)(v94 + 8 * v96);
            v102 = *v101;
            v103 = 0.0;
            if (*v101 != -1)
            {
              v104 = (double *)(v101 + 4);
              v105 = *v101;
              do
              {
                v103 = v103 + v95[v105 - 1] * *(v104 - 1);
                v106 = *(_DWORD *)v104;
                v104 += 2;
                v105 = v106;
              }
              while (v106 != -1);
            }
            __srca = (double)(char)v97;
            v107 = v103 * __srca;
            v108 = v107 + v99 * v88 * (*(double *)(v446 + 8 * ((2 * v96) | 1)) - *(double *)(v446 + 16 * (_DWORD)v96));
            if (v108 >= 0.0)
              v109 = 2 * v96;
            else
              v109 = (2 * v96) | 1;
            if (v108 >= 0.0)
              v110 = (2 * v96) | 1;
            else
              v110 = 2 * v96;
            if (v108 >= 0.0)
              v111 = 1.0;
            else
              v111 = -1.0;
            v112 = *(double *)(v446 + 8 * v109);
            if (v100 - v112 >= v100 * v88)
              v113 = *(double *)(v446 + 8 * v109);
            else
              v113 = v112 * 0.1;
            v440 = v111;
            v114 = v107 * v111;
            v115 = v107 * v111 + v99 * (v113 - v112) + log(v113 / (v100 - v113));
            v116 = fabs(v115);
            v117 = v450;
            if (v450 <= v116)
              v117 = v116;
            v450 = v117;
            if (v116 >= v453)
            {
              v118 = v10;
              v119 = 0;
              do
              {
                v120 = v113 - v115 / (v99 + v100 / (v100 - v113) / v113);
                if (v120 <= 0.0)
                  v113 = v113 * 0.1;
                else
                  v113 = v120;
                v121 = v113 - v112;
                v122 = log(v113 / (v100 - v113));
                v123 = v119 + 1;
                if (v119 > 0x63)
                  break;
                v115 = v114 + v99 * v121 + v122;
                ++v119;
              }
              while (fabs(v115) >= v453);
              *(double *)(v446 + 8 * v109) = v113;
              *(double *)(v446 + 8 * v110) = v100 - v113;
              v438 += v123;
              if (v102 == -1)
              {
                v95 = a3;
                v10 = v118;
              }
              else
              {
                v124 = (double *)(v101 + 4);
                v95 = a3;
                v10 = v118;
                do
                {
                  a3[v102 - 1] = a3[v102 - 1] + v440 * v121 * __srca * *(v124 - 1);
                  v125 = *(_DWORD *)v124;
                  v124 += 2;
                  v102 = v125;
                }
                while (v125 != -1);
              }
              v88 = 0.5;
            }
            else
            {
              v95 = a3;
            }
            ++v93;
            v64 = v98;
          }
          while (v93 != v10);
        }
        v126 = v432 + 1;
        HIDWORD(v127) = -858993459 * (v432 + 1);
        LODWORD(v127) = HIDWORD(v127);
        if ((v127 >> 1) <= 0x19999999)
          info(".");
        if (v450 < v430)
          break;
        v128 = v453;
        v129 = v453 * 0.1;
        if (v429 > v453 * 0.1)
          v129 = v429;
        if (v438 <= v427)
          v128 = v129;
        v453 = v128;
        v87 = v432 + 1;
        v391 = v126 == 1000;
        v130 = a3;
        if (v391)
        {
          info("\noptimization finished, #iter = %d\n", 1000);
          goto LABEL_216;
        }
      }
      info("\noptimization finished, #iter = %d\n", v126);
      v130 = a3;
      if (v432 < 0x3E7)
        goto LABEL_217;
LABEL_216:
      info("\nWARNING: reaching max number of iterations\nUsing -s 0 may be faster (also see FAQ)\n\n");
LABEL_217:
      v233 = v422;
      if ((int)v422 < 1)
      {
        v236 = 0.0;
      }
      else
      {
        v234 = 0.0;
        do
        {
          v235 = *v130++;
          v234 = v234 + v235 * v235;
          --v233;
        }
        while (v233);
        v236 = v234 * 0.5;
      }
      if ((int)v10 >= 1)
      {
        v237 = (double *)(v446 + 8);
        v238 = (char *)__len;
        do
        {
          v239 = *(v237 - 1);
          v240 = log(v239);
          v241 = *v237;
          v237 += 2;
          v242 = v241 * log(v241) + v239 * v240;
          v243 = *v238++;
          v244 = *(&v457 + v243 + 1);
          v236 = v236 + v242 - v244 * log(v244);
          --v10;
        }
        while (v10);
      }
      info("Objective value = %lf\n", v236);
      MEMORY[0x20BD188CC](v64, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](v446, 0x1000C8000313F17);
      MEMORY[0x20BD188CC](__len, 0x1000C8077774924);
      result = v65;
      v245 = 1384677904;
      return MEMORY[0x20BD188CC](result, v245 | 0x1000C8000000000);
    case 0xB:
      v222 = operator new[]();
      v223 = v222;
      v224 = *a1;
      if ((int)v224 >= 1)
      {
        v225 = *(_QWORD *)(a2 + 16);
        v226 = (_QWORD *)v222;
        do
        {
          *v226++ = v225;
          --v224;
        }
        while (v224);
      }
      v227 = (_QWORD *)operator new();
      v228 = *(_QWORD *)(a2 + 48);
      CPMLlinearSVM::l2r_l2_svc_fun::l2r_l2_svc_fun(v227, (uint64_t)a1, v223);
      *v227 = &off_24C255FC8;
      v227[7] = v228;
      v229 = CPMLlinearSVM::TRON::TRON((uint64_t)&v457, (uint64_t)v227, 1000, *(double *)(a2 + 8));
      CPMLlinearSVM::TRON::set_print_string(v229, (void (*)(const char *))liblinear_print_string);
      CPMLlinearSVM::TRON::tron((CPMLlinearSVM::TRON *)&v457, a3);
      (*(void (**)(_QWORD *))(*v227 + 40))(v227);
      v39 = v223;
LABEL_211:
      MEMORY[0x20BD188CC](v39, 0x1000C8000313F17);
      return CPModelClose(&v457);
    case 0xC:
      v230 = a3;
      v231 = (double *)a2;
      v232 = 12;
      goto LABEL_214;
    case 0xD:
      v230 = a3;
      v231 = (double *)a2;
      v232 = 13;
LABEL_214:
      solve_l2r_l1l2_svr(a1, v230, v231, v232);
    default:
      return fwrite("ERROR: unknown solver_type\n", 0x1BuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  }
}

void sub_209CBFE2C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10F1C408938F244);
  _Unwind_Resume(a1);
}

void cross_validation(unsigned int *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v7;
  int *v8;
  uint64_t v9;
  int *v10;
  uint64_t i;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  int v16;
  int *v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  uint64_t j;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  int *v27;
  uint64_t v28;
  _DWORD *v29;
  int *v30;
  int v31;
  double v32;
  uint64_t v33;
  uint64_t v34;
  double v36;
  void *v37;
  void *v38;
  uint64_t v39;

  v7 = *a1;
  v8 = (int *)malloc_type_malloc(4 * (int)v7, 0x100004052888210uLL);
  if ((int)v7 < a3)
  {
    fwrite("WARNING: # folds > # data. Will use # folds = # data instead (i.e., leave-one-out cross validation)\n", 0x64uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    a3 = v7;
  }
  v9 = (a3 + 1);
  v10 = (int *)malloc_type_malloc(4 * (int)v9, 0x100004052888210uLL);
  if ((int)v7 >= 1)
  {
    for (i = 0; i != v7; ++i)
      v8[i] = i;
    v12 = 0;
    v13 = v7;
    do
    {
      v14 = v12 + rand() % (int)v13;
      v15 = v8[v12];
      v8[v12] = v8[v14];
      v8[v14] = v15;
      ++v12;
      --v13;
    }
    while (v13);
  }
  if ((a3 & 0x80000000) == 0)
  {
    v16 = 0;
    v17 = v10;
    do
    {
      *v17++ = v16 / a3;
      v16 += v7;
      --v9;
    }
    while (v9);
    if (a3 >= 1)
    {
      v18 = 0;
      v34 = a3;
      do
      {
        v19 = v10[v18++];
        v20 = v10[v18];
        v39 = *((_QWORD *)a1 + 3);
        v21 = a1[1];
        LODWORD(v36) = v19 - v20 + v7;
        HIDWORD(v36) = v21;
        v38 = malloc_type_malloc(8 * SLODWORD(v36), 0x2004093837F09uLL);
        v37 = malloc_type_malloc(8 * SLODWORD(v36), 0x100004000313F17uLL);
        if ((int)v19 < 1)
        {
          v24 = 0;
        }
        else
        {
          for (j = 0; j != v19; ++j)
          {
            v23 = v8[j];
            *((_QWORD *)v38 + j) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v23);
            *((_QWORD *)v37 + j) = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v23);
          }
          v24 = v19;
        }
        if ((int)v20 < (int)v7)
        {
          v25 = (int)v7 - v20;
          v26 = 8 * v24;
          v27 = &v8[v20];
          do
          {
            v28 = *v27++;
            *(_QWORD *)((char *)v38 + v26) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v28);
            *(_QWORD *)((char *)v37 + v26) = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v28);
            v26 += 8;
            --v25;
          }
          while (v25);
        }
        v29 = train(&v36, a2);
        if ((int)v19 < (int)v20)
        {
          v30 = &v8[(int)v19];
          v31 = v20 - v19;
          do
          {
            v32 = predict((uint64_t)v29, *(_DWORD **)(*((_QWORD *)a1 + 2) + 8 * *v30));
            v33 = *v30++;
            *(double *)(a4 + 8 * v33) = v32;
            --v31;
          }
          while (v31);
        }
        if (v29)
        {
          free_model_content((uint64_t)v29);
          free(v29);
        }
        free(v38);
        free(v37);
      }
      while (v18 != v34);
    }
  }
  free(v10);
  free(v8);
}

double predict(uint64_t a1, _DWORD *a2)
{
  double *v4;
  double v5;

  v4 = (double *)malloc_type_malloc(8 * *(int *)(a1 + 56), 0x100004000313F17uLL);
  v5 = predict_values(a1, a2, v4);
  free(v4);
  return v5;
}

void free_and_destroy_model(uint64_t *a1)
{
  void *v1;

  v1 = (void *)*a1;
  if (*a1)
  {
    free_model_content(*a1);
    free(v1);
  }
}

double predict_values_vn(uint64_t a1, double *a2, double *a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  float64x2_t *v10;
  int v11;
  signed int v12;
  float64x2_t v13;
  double *v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  int v19;
  float64x2_t v20;
  float64x2_t v21;
  float64x2_t v22;
  float64x2_t v23;
  float64x2_t v24;
  float64x2_t v25;
  float64x2_t v26;
  int v27;
  double v28;
  int v29;
  double v30;
  float64x2_t *v31;
  float64x2_t *v32;
  double v33;
  float64x2_t *v34;
  int v35;
  signed int v36;
  float64x2_t v37;
  double *v38;
  float64x2_t v39;
  float64x2_t v40;
  float64x2_t v41;
  int v42;
  float64x2_t v43;
  float64x2_t v44;
  float64x2_t v45;
  float64x2_t v46;
  float64x2_t v47;
  int v48;
  double v49;
  int v50;
  double v51;
  float64x2_t *v52;
  float64x2_t *v53;
  double v54;
  float64x2_t *v55;
  int i;
  signed int v57;
  float64x2_t v58;
  double *v59;
  float64x2_t v60;
  float64x2_t v61;
  int v62;
  float64x2_t v63;
  float64x2_t v64;
  float64x2_t v65;
  double v66;
  int v67;
  double v68;
  int v69;
  float64x2_t *v70;
  float64x2_t *v71;
  double v72;
  float64x2_t *v73;
  int j;
  unsigned int v75;
  float64x2_t v76;
  double *v77;
  float64x2_t v78;
  float64x2_t v79;
  int v80;
  float64x2_t v81;
  float64x2_t v82;
  float64x2_t v83;
  double v84;
  int v85;
  double v86;
  int v87;
  double v88;
  int v89;
  double v90;
  int v91;
  signed int v92;
  double v93;
  int v94;
  double v95;
  int v96;
  int v97;
  float64x2_t v98;
  signed int v99;
  double v100;
  double v101;
  int v102;
  double v103;
  int v104;
  double v105;
  int v106;
  double v107;
  double result;
  int *v109;
  int v110;
  uint64_t k;
  uint64_t v112;

  v4 = *(_QWORD *)(a1 + 64);
  v5 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v5 == 2)
  {
    v6 = v4 - 8;
    v7 = v4 - 8 * v5;
    if (*(_DWORD *)a1 == 4)
      v8 = 2;
    else
      v8 = 1;
    v9 = 0;
    if (*(_DWORD *)a1 != 4)
      v7 = v6;
    goto LABEL_10;
  }
  v7 = v4 - 8 * (int)v5;
  if ((int)v5 < 8)
  {
    v9 = 0;
    v8 = *(_DWORD *)(a1 + 56);
LABEL_10:
    v10 = (float64x2_t *)a3;
    goto LABEL_21;
  }
  v9 = v5 & 0x7FFFFFF8;
  v11 = 8;
  v10 = (float64x2_t *)a3;
  do
  {
    if (a4 >= 2)
    {
      v18 = 0uLL;
      v19 = 2;
      v20 = 0uLL;
      v21 = 0uLL;
      v22 = 0uLL;
      v23 = 0uLL;
      v24 = 0uLL;
      v25 = 0uLL;
      v14 = a2;
      v26 = 0uLL;
      do
      {
        v27 = *(_DWORD *)v14;
        v28 = v14[1];
        v29 = *((_DWORD *)v14 + 4);
        v30 = v14[3];
        v14 += 4;
        v31 = (float64x2_t *)(v7 + 8 * v27 * (int)v5);
        v32 = (float64x2_t *)(v7 + 8 * v29 * (int)v5);
        v18 = vmlaq_n_f64(v18, *v31, v28);
        v20 = vmlaq_n_f64(v20, v31[1], v28);
        v21 = vmlaq_n_f64(v21, *v32, v30);
        v22 = vmlaq_n_f64(v22, v32[1], v30);
        v23 = vmlaq_n_f64(v23, v31[2], v28);
        v24 = vmlaq_n_f64(v24, v31[3], v28);
        v25 = vmlaq_n_f64(v25, v32[2], v30);
        v26 = vmlaq_n_f64(v26, v32[3], v30);
        v19 += 2;
      }
      while (v19 <= a4);
      v13 = vaddq_f64(v21, v18);
      v15 = vaddq_f64(v22, v20);
      v16 = vaddq_f64(v25, v23);
      v12 = a4 & 0xFFFFFFFE;
      v17 = vaddq_f64(v26, v24);
    }
    else
    {
      v12 = 0;
      v13 = 0uLL;
      v14 = a2;
      v15 = 0uLL;
      v16 = 0uLL;
      v17 = 0uLL;
    }
    if (v12 < a4)
    {
      v33 = v14[1];
      v34 = (float64x2_t *)(v7 + 8 * *(_DWORD *)v14 * (int)v5);
      v13 = vmlaq_n_f64(v13, *v34, v33);
      v15 = vmlaq_n_f64(v15, v34[1], v33);
      v16 = vmlaq_n_f64(v16, v34[2], v33);
      v17 = vmlaq_n_f64(v17, v34[3], v33);
    }
    *v10 = v13;
    v10[1] = v15;
    v10[2] = v16;
    v10[3] = v17;
    v10 += 4;
    v7 += 64;
    v11 += 8;
  }
  while (v11 <= (int)v5);
  v8 = v5;
LABEL_21:
  v35 = v9 | 6;
  if ((v9 | 6) <= v8)
  {
    do
    {
      v9 = v35;
      if (a4 >= 2)
      {
        v41 = 0uLL;
        v42 = 2;
        v43 = 0uLL;
        v44 = 0uLL;
        v45 = 0uLL;
        v38 = a2;
        v46 = 0uLL;
        v47 = 0uLL;
        do
        {
          v48 = *(_DWORD *)v38;
          v49 = v38[1];
          v50 = *((_DWORD *)v38 + 4);
          v51 = v38[3];
          v38 += 4;
          v52 = (float64x2_t *)(v7 + 8 * v48 * v8);
          v53 = (float64x2_t *)(v7 + 8 * v50 * v8);
          v41 = vmlaq_n_f64(v41, *v52, v49);
          v43 = vmlaq_n_f64(v43, v52[1], v49);
          v44 = vmlaq_n_f64(v44, *v53, v51);
          v45 = vmlaq_n_f64(v45, v53[1], v51);
          v47 = vmlaq_n_f64(v47, v52[2], v49);
          v46 = vmlaq_n_f64(v46, v53[2], v51);
          v42 += 2;
        }
        while (v42 <= a4);
        v37 = vaddq_f64(v44, v41);
        v39 = vaddq_f64(v45, v43);
        v40 = vaddq_f64(v47, v46);
        v36 = a4 & 0xFFFFFFFE;
      }
      else
      {
        v36 = 0;
        v37 = 0uLL;
        v38 = a2;
        v39 = 0uLL;
        v40 = 0uLL;
      }
      if (v36 < a4)
      {
        v54 = v38[1];
        v55 = (float64x2_t *)(v7 + 8 * *(_DWORD *)v38 * v8);
        v37 = vmlaq_n_f64(v37, *v55, v54);
        v39 = vmlaq_n_f64(v39, v55[1], v54);
        v40 = vmlaq_n_f64(v40, v55[2], v54);
      }
      *v10 = v37;
      v10[1] = v39;
      v10[2] = v40;
      v10 += 3;
      v7 += 48;
      v35 = v9 + 6;
    }
    while (v9 + 6 <= v8);
  }
  for (i = v9 + 4; v9 + 4 <= v8; i = v9 + 4)
  {
    v9 = i;
    if (a4 >= 2)
    {
      v61 = 0uLL;
      v62 = 2;
      v63 = 0uLL;
      v64 = 0uLL;
      v59 = a2;
      v65 = 0uLL;
      do
      {
        v66 = v59[1];
        v67 = *(_DWORD *)v59;
        v68 = v59[3];
        v69 = *((_DWORD *)v59 + 4);
        v59 += 4;
        v70 = (float64x2_t *)(v7 + 8 * v67 * v8);
        v71 = (float64x2_t *)(v7 + 8 * v69 * v8);
        v61 = vmlaq_n_f64(v61, *v70, v66);
        v63 = vmlaq_n_f64(v63, v70[1], v66);
        v64 = vmlaq_n_f64(v64, *v71, v68);
        v65 = vmlaq_n_f64(v65, v71[1], v68);
        v62 += 2;
      }
      while (v62 <= a4);
      v58 = vaddq_f64(v64, v61);
      v60 = vaddq_f64(v65, v63);
      v57 = a4 & 0xFFFFFFFE;
    }
    else
    {
      v57 = 0;
      v58 = 0uLL;
      v59 = a2;
      v60 = 0uLL;
    }
    if (v57 < a4)
    {
      v72 = v59[1];
      v73 = (float64x2_t *)(v7 + 8 * *(_DWORD *)v59 * v8);
      v58 = vmlaq_n_f64(v58, *v73, v72);
      v60 = vmlaq_n_f64(v60, v73[1], v72);
    }
    *v10 = v58;
    v10[1] = v60;
    v10 += 2;
    v7 += 32;
  }
  for (j = v9 + 2; v9 + 2 <= v8; j = v9 + 2)
  {
    v9 = j;
    if (a4 >= 4)
    {
      v79 = 0uLL;
      v80 = 4;
      v81 = 0uLL;
      v82 = 0uLL;
      v77 = a2;
      v83 = 0uLL;
      do
      {
        v84 = v77[1];
        v85 = *(_DWORD *)v77;
        v86 = v77[3];
        v87 = *((_DWORD *)v77 + 4);
        v88 = v77[5];
        v89 = *((_DWORD *)v77 + 8);
        v90 = v77[7];
        v91 = *((_DWORD *)v77 + 12);
        v77 += 8;
        v79 = vmlaq_n_f64(v79, *(float64x2_t *)(v7 + 8 * v85 * v8), v84);
        v81 = vmlaq_n_f64(v81, *(float64x2_t *)(v7 + 8 * v87 * v8), v86);
        v83 = vmlaq_n_f64(v83, *(float64x2_t *)(v7 + 8 * v89 * v8), v88);
        v82 = vmlaq_n_f64(v82, *(float64x2_t *)(v7 + 8 * v91 * v8), v90);
        v80 += 4;
      }
      while (v80 <= a4);
      v76 = vaddq_f64(v83, v79);
      v78 = vaddq_f64(v82, v81);
      v75 = a4 & 0xFFFFFFFC;
    }
    else
    {
      v75 = 0;
      v76 = 0uLL;
      v77 = a2;
      v78 = 0uLL;
    }
    if ((int)(v75 | 2) <= a4)
    {
      do
      {
        v93 = v77[1];
        v94 = *(_DWORD *)v77;
        v95 = v77[3];
        v96 = *((_DWORD *)v77 + 4);
        v77 += 4;
        v76 = vmlaq_n_f64(v76, *(float64x2_t *)(v7 + 8 * v94 * v8), v93);
        v78 = vmlaq_n_f64(v78, *(float64x2_t *)(v7 + 8 * v96 * v8), v95);
        v92 = v75 + 2;
        v97 = v75 + 4;
        v75 += 2;
      }
      while (v97 <= a4);
    }
    else
    {
      v92 = v75;
    }
    v98 = vaddq_f64(v78, v76);
    if (v92 < a4)
      v98 = vmlaq_n_f64(v98, *(float64x2_t *)(v7 + 8 * *(_DWORD *)v77 * v8), v77[1]);
    *v10++ = v98;
    v7 += 16;
  }
  if (v9 < v8)
  {
    if (a4 >= 2)
    {
      v99 = a4 & 0xFFFFFFFE;
      v101 = 0.0;
      v102 = 2;
      v103 = 0.0;
      do
      {
        v104 = *(_DWORD *)a2;
        v105 = a2[1];
        v106 = *((_DWORD *)a2 + 4);
        v107 = a2[3];
        a2 += 4;
        v103 = v103 + *(double *)(v7 + 8 * v104 * v8) * v105;
        v101 = v101 + *(double *)(v7 + 8 * v106 * v8) * v107;
        v102 += 2;
      }
      while (v102 <= a4);
      v100 = v103 + v101;
    }
    else
    {
      v99 = 0;
      v100 = 0.0;
    }
    if (v99 < a4)
      v100 = v100 + *(double *)(v7 + 8 * *(_DWORD *)a2 * v8) * a2[1];
    v10->f64[0] = v100;
  }
  if ((_DWORD)v5 == 2)
  {
    result = *a3;
    if ((*(_DWORD *)a1 - 11) < 3)
      return result;
    v109 = (int *)(*(_QWORD *)(a1 + 72) + 4 * (result <= 0.0));
  }
  else
  {
    if ((int)v5 < 2)
    {
      v112 = 0;
    }
    else
    {
      v110 = 0;
      for (k = 1; k != v5; ++k)
      {
        if (a3[k] > a3[v110])
          v110 = k;
      }
      v112 = v110;
    }
    v109 = (int *)(*(_QWORD *)(a1 + 72) + 4 * v112);
  }
  return (double)*v109;
}

double predict_values(uint64_t a1, _DWORD *a2, double *a3)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  int v6;
  float64x2_t *v7;
  int v8;
  int v9;
  float64x2_t v10;
  double *v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  double v15;
  float64x2_t *v16;
  int v17;
  int v18;
  int v19;
  float64x2_t v20;
  double *v21;
  float64x2_t v22;
  double v23;
  float64x2_t *v24;
  int v25;
  int i;
  int v27;
  float64x2_t v28;
  double *v29;
  int v30;
  int v31;
  double *v32;
  double v33;
  int v34;
  double result;
  int *v36;
  int v37;
  uint64_t j;
  uint64_t v39;

  v3 = *(_QWORD *)(a1 + 64);
  v4 = *(unsigned int *)(a1 + 56);
  if ((_DWORD)v4 == 2)
  {
    v5 = 0;
    if (*(_DWORD *)a1 == 4)
      v6 = 2;
    else
      v6 = 1;
    goto LABEL_7;
  }
  if ((int)v4 < 8)
  {
    v5 = 0;
    v6 = *(_DWORD *)(a1 + 56);
LABEL_7:
    v7 = (float64x2_t *)a3;
    goto LABEL_16;
  }
  v5 = v4 & 0x7FFFFFF8;
  v8 = 8;
  v7 = (float64x2_t *)a3;
  do
  {
    v9 = *a2;
    if (*a2 == -1)
    {
      v14 = 0uLL;
      v13 = 0uLL;
      v12 = 0uLL;
      v10 = 0uLL;
    }
    else
    {
      v10 = 0uLL;
      v11 = (double *)(a2 + 4);
      v12 = 0uLL;
      v13 = 0uLL;
      v14 = 0uLL;
      do
      {
        v15 = *(v11 - 1);
        v16 = (float64x2_t *)(v3 + 8 * (v9 - 1) * (int)v4);
        v10 = vmlaq_n_f64(v10, *v16, v15);
        v12 = vmlaq_n_f64(v12, v16[1], v15);
        v14 = vmlaq_n_f64(v14, v16[2], v15);
        v13 = vmlaq_n_f64(v13, v16[3], v15);
        v17 = *(_DWORD *)v11;
        v11 += 2;
        v9 = v17;
      }
      while (v17 != -1);
    }
    *v7 = v10;
    v7[1] = v12;
    v7[2] = v14;
    v7[3] = v13;
    v7 += 4;
    v3 += 64;
    v8 += 8;
  }
  while (v8 <= (int)v4);
  v6 = v4;
LABEL_16:
  v18 = v5 | 4;
  if ((v5 | 4) <= v6)
  {
    do
    {
      v5 = v18;
      v19 = *a2;
      if (*a2 == -1)
      {
        v22 = 0uLL;
        v20 = 0uLL;
      }
      else
      {
        v20 = 0uLL;
        v21 = (double *)(a2 + 4);
        v22 = 0uLL;
        do
        {
          v23 = *(v21 - 1);
          v24 = (float64x2_t *)(v3 + 8 * (v19 - 1) * v6);
          v20 = vmlaq_n_f64(v20, *v24, v23);
          v22 = vmlaq_n_f64(v22, v24[1], v23);
          v25 = *(_DWORD *)v21;
          v21 += 2;
          v19 = v25;
        }
        while (v25 != -1);
      }
      *v7 = v20;
      v7[1] = v22;
      v7 += 2;
      v3 += 32;
      v18 = v5 + 4;
    }
    while (v5 + 4 <= v6);
  }
  for (i = v5 + 2; v5 + 2 <= v6; i = v5 + 2)
  {
    v5 = i;
    v27 = *a2;
    v28 = 0uLL;
    if (*a2 != -1)
    {
      v29 = (double *)(a2 + 4);
      do
      {
        v28 = vmlaq_n_f64(v28, *(float64x2_t *)(v3 + 8 * (v27 - 1) * v6), *(v29 - 1));
        v30 = *(_DWORD *)v29;
        v29 += 2;
        v27 = v30;
      }
      while (v30 != -1);
    }
    *v7++ = v28;
    v3 += 16;
  }
  if (v5 < v6)
  {
    v31 = *a2;
    if (*a2 == -1)
    {
      v33 = 0.0;
    }
    else
    {
      v32 = (double *)(a2 + 4);
      v33 = 0.0;
      do
      {
        v33 = v33 + *(double *)(v3 + 8 * (v31 - 1) * v6) * *(v32 - 1);
        v34 = *(_DWORD *)v32;
        v32 += 2;
        v31 = v34;
      }
      while (v34 != -1);
    }
    v7->f64[0] = v33;
  }
  if ((_DWORD)v4 == 2)
  {
    result = *a3;
    if ((*(_DWORD *)a1 - 11) < 3)
      return result;
    v36 = (int *)(*(_QWORD *)(a1 + 72) + 4 * (result <= 0.0));
  }
  else
  {
    if ((int)v4 < 2)
    {
      v39 = 0;
    }
    else
    {
      v37 = 0;
      for (j = 1; j != v4; ++j)
      {
        if (a3[j] > a3[v37])
          v37 = j;
      }
      v39 = v37;
    }
    v36 = (int *)(*(_QWORD *)(a1 + 72) + 4 * v39);
  }
  return (double)*v36;
}

double predict_vn()
{
  uint64_t v0;
  uint64_t v1;
  double *v2;
  int v3;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  v0 = MEMORY[0x24BDAC7A8]();
  return predict_values_vn(v0, v2, (double *)((char *)v5 - ((v1 + 15) & 0xFFFFFFFF0)), v3);
}

double predict_probability(_DWORD *a1, _DWORD *a2, double *a3)
{
  double *v4;
  uint64_t v5;
  uint64_t v6;
  double v7;
  long double *v8;
  double v9;
  uint64_t v10;
  double *v11;
  double v12;

  if (*a1 > 7u || ((1 << *a1) & 0xC1) == 0)
    return 0.0;
  v4 = a3;
  v5 = a1[14];
  if ((_DWORD)v5 == 2)
    v6 = 1;
  else
    v6 = v5;
  v7 = predict_values((uint64_t)a1, a2, a3);
  if ((int)v6 >= 1)
  {
    v8 = v4;
    do
    {
      *v8 = 1.0 / (exp(-*v8) + 1.0);
      ++v8;
      --v6;
    }
    while (v6);
  }
  if ((_DWORD)v5 == 2)
  {
    v4[1] = 1.0 - *v4;
  }
  else if ((int)v5 >= 1)
  {
    v9 = 0.0;
    v10 = v5;
    v11 = v4;
    do
    {
      v12 = *v11++;
      v9 = v9 + v12;
      --v10;
    }
    while (v10);
    do
    {
      *v4 = *v4 / v9;
      ++v4;
      --v5;
    }
    while (v5);
  }
  return v7;
}

BOOL check_probability_model(_DWORD *a1)
{
  BOOL v1;

  if (*a1)
    v1 = *a1 == 7;
  else
    v1 = 1;
  return v1 || *a1 == 6;
}

uint64_t save_model(const char *a1, double *a2)
{
  unsigned int v3;
  uint64_t v4;
  FILE *v5;
  FILE *v6;
  char *v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t i;
  uint64_t v15;
  uint64_t v16;
  char *v18;

  v3 = *((_DWORD *)a2 + 15);
  if (a2[10] < 0.0)
    v4 = v3;
  else
    v4 = v3 + 1;
  v5 = fopen(a1, "w");
  if (!v5)
    return 0xFFFFFFFFLL;
  v6 = v5;
  v7 = setlocale(0, 0);
  v18 = strdup(v7);
  setlocale(0, "C");
  v8 = *((_DWORD *)a2 + 14);
  v9 = *(int *)a2;
  if (v9 != 4 && v8 == 2)
    v11 = 1;
  else
    v11 = v8;
  fprintf(v6, "solver_type %s\n", solver_type_table[v9]);
  fprintf(v6, "nr_class %d\n", *((_DWORD *)a2 + 14));
  if (*((_QWORD *)a2 + 9))
  {
    fwrite("label", 5uLL, 1uLL, v6);
    if (*((int *)a2 + 14) >= 1)
    {
      v12 = 0;
      do
        fprintf(v6, " %d", *(_DWORD *)(*((_QWORD *)a2 + 9) + 4 * v12++));
      while (v12 < *((int *)a2 + 14));
    }
    fputc(10, v6);
  }
  fprintf(v6, "nr_feature %d\n", v3);
  fprintf(v6, "bias %.16g\n", a2[10]);
  fwrite("w\n", 2uLL, 1uLL, v6);
  if ((int)v4 >= 1)
  {
    v13 = 0;
    for (i = 0; i != v4; ++i)
    {
      if ((int)v11 >= 1)
      {
        v15 = v11;
        v16 = v13;
        do
        {
          fprintf(v6, "%.16g ", *(double *)(*((_QWORD *)a2 + 8) + v16));
          v16 += 8;
          --v15;
        }
        while (v15);
      }
      fputc(10, v6);
      v13 += 8 * (int)v11;
    }
  }
  setlocale(0, v18);
  free(v18);
  if (ferror(v6))
    return 0xFFFFFFFFLL;
  if (fclose(v6))
    return 0xFFFFFFFFLL;
  return 0;
}

FILE *load_model(const char *a1)
{
  FILE *result;
  FILE *v2;
  int *v3;
  char *v4;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t i;
  uint64_t v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  int v21;
  int v22;
  _BYTE __s2[72];
  uint64_t v24;

  v24 = *MEMORY[0x24BDAC8D0];
  result = fopen(a1, "r");
  if (result)
  {
    v2 = result;
    v21 = 0;
    v22 = 0;
    v20 = 0;
    v3 = (int *)malloc_type_malloc(0x58uLL, 0x10900405E350820uLL);
    *((_QWORD *)v3 + 9) = 0;
    v4 = setlocale(0, 0);
    v19 = strdup(v4);
    setlocale(0, "C");
    while (1)
    {
      while (1)
      {
        while (1)
        {
          while (1)
          {
            while (1)
            {
              fscanf(v2, "%80s", __s2);
              if (*(_QWORD *)__s2 != 0x745F7265766C6F73 || *(_DWORD *)&__s2[8] != 6647929)
                break;
              fscanf(v2, "%80s", __s2);
              v11 = 0;
              while (strcmp(solver_type_table[v11], __s2))
              {
                if (++v11 == 14)
                {
                  fwrite("unknown solver type.\n", 0x15uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
                  goto LABEL_31;
                }
              }
              *v3 = v11;
            }
            if (*(_QWORD *)__s2 ^ 0x7373616C635F726ELL | __s2[8])
              break;
            fscanf(v2, "%d", &v21);
            v3[14] = v21;
          }
          if (*(_QWORD *)__s2 != 0x75746165665F726ELL || *(_QWORD *)&__s2[3] != 0x65727574616566)
            break;
          fscanf(v2, "%d", &v22);
          v3[15] = v22;
        }
        if (*(_DWORD *)__s2 ^ 0x73616962 | __s2[4])
          break;
        fscanf(v2, "%lf", &v20);
        *((_QWORD *)v3 + 10) = v20;
      }
      if (*(unsigned __int16 *)__s2 == 119)
        break;
      if (*(_DWORD *)__s2 != 1700946284 || *(unsigned __int16 *)&__s2[4] != 108)
      {
        fprintf((FILE *)*MEMORY[0x24BDAC8D8], "unknown text in model file: [%s]\n", __s2);
LABEL_31:
        setlocale(0, v19);
        free(*((void **)v3 + 9));
        free(v3);
        free(v19);
        return 0;
      }
      v8 = v3[14];
      *((_QWORD *)v3 + 9) = malloc_type_malloc(4 * v8, 0x100004052888210uLL);
      if ((int)v8 >= 1)
      {
        v9 = 0;
        v10 = 4 * v8;
        do
        {
          fscanf(v2, "%d", *((_QWORD *)v3 + 9) + v9);
          v9 += 4;
        }
        while (v10 != v9);
      }
    }
    v12 = v3[15];
    v22 = v12;
    if (*((double *)v3 + 10) < 0.0)
      v13 = v12;
    else
      v13 = v12 + 1;
    v14 = v21;
    if (v21 == 2 && *v3 != 4)
      v14 = 1;
    *((_QWORD *)v3 + 8) = malloc_type_malloc(8 * v14 * (int)v13, 0x100004000313F17uLL);
    if ((int)v13 >= 1)
    {
      v15 = 0;
      for (i = 0; i != v13; ++i)
      {
        if (v14 >= 1)
        {
          v17 = v14;
          v18 = v15;
          do
          {
            fscanf(v2, "%lf ", *((_QWORD *)v3 + 8) + v18);
            v18 += 8;
            --v17;
          }
          while (v17);
        }
        fscanf(v2, "\n");
        v15 += 8 * v14;
      }
    }
    setlocale(0, v19);
    free(v19);
    if (ferror(v2))
      return 0;
    if (fclose(v2))
      return 0;
    else
      return (FILE *)v3;
  }
  return result;
}

uint64_t get_nr_feature(uint64_t a1)
{
  return *(unsigned int *)(a1 + 60);
}

uint64_t get_nr_class(uint64_t a1)
{
  return *(unsigned int *)(a1 + 56);
}

uint64_t get_labels(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 72);
  if (v2 && *(int *)(result + 56) >= 1)
  {
    v3 = 0;
    do
    {
      *(_DWORD *)(a2 + 4 * v3) = *(_DWORD *)(v2 + 4 * v3);
      ++v3;
    }
    while (v3 < *(int *)(result + 56));
  }
  return result;
}

double get_decfun_coef(uint64_t a1, int a2, int a3)
{
  double result;
  uint64_t v4;
  uint64_t v5;
  int v6;

  result = 0.0;
  if (*(_DWORD *)(a1 + 60) >= a2)
  {
    v4 = (a2 - 1);
    if (a2 >= 1)
    {
      v5 = *(_QWORD *)(a1 + 64);
      if ((*(_DWORD *)a1 - 11) <= 2)
        return *(double *)(v5 + 8 * v4);
      if ((a3 & 0x80000000) == 0)
      {
        v6 = *(_DWORD *)(a1 + 56);
        if (v6 > a3)
        {
          if (v6 == 2 && *(_DWORD *)a1 != 4)
          {
            result = *(double *)(v5 + 8 * v4);
            if (a3)
              return -result;
            return result;
          }
          v4 = a3 + v6 * (int)v4;
          return *(double *)(v5 + 8 * v4);
        }
      }
    }
  }
  return result;
}

double get_decfun_bias(uint64_t a1, int a2)
{
  double v2;
  double result;
  uint64_t v4;
  uint64_t v5;
  int v6;

  v2 = *(double *)(a1 + 80);
  result = 0.0;
  if (v2 > 0.0)
  {
    v4 = *(unsigned int *)(a1 + 60);
    if ((v4 & 0x80000000) == 0)
    {
      v5 = *(_QWORD *)(a1 + 64);
      if ((*(_DWORD *)a1 - 11) > 2)
      {
        if (a2 < 0)
          return v2 * result;
        v6 = *(_DWORD *)(a1 + 56);
        if (v6 <= a2)
          return v2 * result;
        if (v6 == 2 && *(_DWORD *)a1 != 4)
        {
          result = *(double *)(v5 + 8 * v4);
          if (a2)
            result = -result;
          return v2 * result;
        }
        v4 = a2 + v6 * (int)v4;
      }
      result = *(double *)(v5 + 8 * v4);
    }
    return v2 * result;
  }
  return result;
}

void free_model_content(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 64);
  if (v2)
    free(v2);
  v3 = *(void **)(a1 + 72);
  if (v3)
    free(v3);
}

void destroy_param(uint64_t a1)
{
  void *v2;
  void *v3;

  v2 = *(void **)(a1 + 32);
  if (v2)
    free(v2);
  v3 = *(void **)(a1 + 40);
  if (v3)
    free(v3);
}

const char *check_parameter(uint64_t a1, double *a2)
{
  uint64_t v3;

  if (a2[1] <= 0.0)
    return "eps <= 0";
  if (a2[2] <= 0.0)
    return "C <= 0";
  if (a2[6] < 0.0)
    return "p < 0";
  v3 = *(int *)a2;
  if (v3 > 0xD)
    return "unknown solver type";
  else
    return (const char *)qword_24C256070[v3];
}

uint64_t (*set_print_string_function(uint64_t (*result)(const char *)))(const char *)
{
  uint64_t (*v1)(const char *);

  v1 = print_string_stdout;
  if (result)
    v1 = result;
  liblinear_print_string = v1;
  return result;
}

uint64_t print_string_stdout(const char *a1)
{
  FILE **v1;

  v1 = (FILE **)MEMORY[0x24BDAC8E8];
  fputs(a1, (FILE *)*MEMORY[0x24BDAC8E8]);
  return fflush(*v1);
}

{
  FILE **v1;

  v1 = (FILE **)MEMORY[0x24BDAC8E8];
  fputs(a1, (FILE *)*MEMORY[0x24BDAC8E8]);
  return fflush(*v1);
}

void CPMLlinearSVM::l2r_l2_svr_fun::~l2r_l2_svr_fun(CPMLlinearSVM::l2r_l2_svr_fun *this)
{
  CPMLlinearSVM::l2r_l2_svc_fun::~l2r_l2_svc_fun(this);
  JUMPOUT(0x20BD188E4);
}

void solve_l2r_l1l2_svc(uint64_t a1, double *a2, int a3, double a4, double a5, double a6)
{
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  void *v15;
  uint64_t v16;
  char *v17;
  double *v18;
  uint64_t v19;
  char *v20;
  double v21;
  char v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  _DWORD *v27;
  int v28;
  double v29;
  double *v30;
  double v31;
  int v32;
  double v33;
  double v34;
  int v35;
  unsigned int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  uint64_t v42;
  double v43;
  double v44;
  int v45;
  uint64_t v46;
  _DWORD *v47;
  int v48;
  double *v49;
  double v50;
  int v51;
  int v52;
  double v53;
  double v54;
  uint64_t v55;
  double v56;
  double v57;
  double v58;
  double v59;
  double v60;
  double v61;
  double *v62;
  int v63;
  unsigned int v64;
  unint64_t v65;
  unsigned int v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  double v70;
  double v71;
  int v72;
  double *v73;
  char *v74;
  double v75;
  double v76;
  uint64_t v77;
  uint64_t v78;
  int v79;
  unsigned int v81;
  __int128 v82;
  double v83;
  double v84[2];
  double v85;
  uint64_t v86;

  v86 = *MEMORY[0x24BDAC8D0];
  v11 = *(unsigned int *)(a1 + 4);
  v12 = *(_DWORD *)a1;
  v13 = operator new[]();
  v14 = operator new[]();
  v15 = (void *)operator new[]();
  v16 = operator new[]();
  v17 = (char *)v16;
  v84[0] = 0.5 / a6;
  v84[1] = 0.0;
  v85 = 0.5 / a5;
  v82 = xmmword_209D00160;
  v83 = INFINITY;
  if (a3 == 3)
  {
    v84[0] = 0.0;
    v85 = 0.0;
    *(double *)&v82 = a6;
    v83 = a5;
  }
  if (v12 >= 1)
  {
    v18 = *(double **)(a1 + 8);
    v19 = v12;
    v20 = (char *)v16;
    do
    {
      v21 = *v18++;
      if (v21 > 0.0)
        v22 = 1;
      else
        v22 = -1;
      *v20++ = v22;
      --v19;
    }
    while (v19);
    bzero(v15, 8 * v12);
  }
  if ((int)v11 >= 1)
    bzero(a2, 8 * v11);
  if (v12 >= 1)
  {
    v23 = 0;
    v24 = *(_QWORD *)(a1 + 16);
    do
    {
      v25 = v17[v23];
      v26 = v84[v25 + 1];
      *(double *)(v13 + 8 * v23) = v26;
      v27 = *(_DWORD **)(v24 + 8 * v23);
      v28 = *v27;
      if (*v27 != -1)
      {
        v29 = *((double *)v15 + v23) * (double)(char)v25;
        v30 = (double *)(v27 + 4);
        do
        {
          v31 = *(v30 - 1);
          v26 = v26 + v31 * v31;
          *(double *)(v13 + 8 * v23) = v26;
          a2[v28 - 1] = a2[v28 - 1] + v29 * v31;
          v32 = *(_DWORD *)v30;
          v30 += 2;
          v28 = v32;
        }
        while (v32 != -1);
      }
      *(_DWORD *)(v14 + 4 * v23) = v23;
      ++v23;
    }
    while (v23 != v12);
  }
  v78 = v12;
  v33 = INFINITY;
  v34 = -INFINITY;
  v79 = v12;
  v35 = v12;
  v36 = 0;
  while (v35 < 1)
  {
    v44 = INFINITY;
    v43 = -INFINITY;
LABEL_50:
    v64 = v36 + 1;
    HIDWORD(v65) = -858993459 * (v36 + 1);
    LODWORD(v65) = HIDWORD(v65);
    if ((v65 >> 1) <= 0x19999999)
      info(".");
    if (v43 - v44 <= a4)
    {
      v66 = v36;
      v67 = v79;
      if (v35 == v79)
      {
        info("\noptimization finished, #iter = %d\n", v64);
        if (v66 >= 0x3E7)
LABEL_64:
          info("\nWARNING: reaching max number of iterations\nUsing -s 2 may be faster (also see FAQ)\n\n");
        v69 = v78;
        v68 = v11;
        v70 = 0.0;
        if ((int)v11 >= 1)
        {
          do
          {
            v71 = *a2++;
            v70 = v70 + v71 * v71;
            --v68;
          }
          while (v68);
        }
        if (v67 < 1)
        {
          v72 = 0;
        }
        else
        {
          v72 = 0;
          v73 = (double *)v15;
          v74 = v17;
          do
          {
            v75 = *v73++;
            v76 = v75;
            v77 = *v74++;
            v70 = v70 + v76 * (v76 * v84[v77 + 1] + -2.0);
            if (v76 > 0.0)
              ++v72;
            --v69;
          }
          while (v69);
        }
        info("Objective value = %lf\n", v70 * 0.5);
        info("nSV = %d\n", v72);
        MEMORY[0x20BD188CC](v13, 0x1000C8000313F17);
        MEMORY[0x20BD188CC](v15, 0x1000C8000313F17);
        MEMORY[0x20BD188CC](v17, 0x1000C8077774924);
        JUMPOUT(0x20BD188CCLL);
      }
      info("*", v43 - v44);
      v34 = -INFINITY;
      v33 = INFINITY;
      v35 = v79;
    }
    else
    {
      if (v43 <= 0.0)
        v33 = INFINITY;
      else
        v33 = v43;
      if (v44 >= 0.0)
        v34 = -INFINITY;
      else
        v34 = v44;
    }
    v36 = v64;
    if (v64 == 1000)
    {
      info("\noptimization finished, #iter = %d\n", 1000);
      v67 = v79;
      goto LABEL_64;
    }
  }
  v81 = v36;
  v37 = 0;
  v38 = v35;
  do
  {
    v39 = v37 + rand() % v35;
    v40 = *(_DWORD *)(v14 + 4 * v37);
    *(_DWORD *)(v14 + 4 * v37) = *(_DWORD *)(v14 + 4 * v39);
    *(_DWORD *)(v14 + 4 * v39) = v40;
    ++v37;
    --v35;
  }
  while (v38 != v37);
  v41 = 0;
  v42 = *(_QWORD *)(a1 + 16);
  v43 = -INFINITY;
  v44 = INFINITY;
  v35 = v38;
  v36 = v81;
  while (1)
  {
    v45 = *(_DWORD *)(v14 + 4 * v41);
    v46 = v17[v45];
    v47 = *(_DWORD **)(v42 + 8 * v45);
    v48 = *v47;
    if (*v47 == -1)
    {
      v50 = 0.0;
    }
    else
    {
      v49 = (double *)(v47 + 4);
      v50 = 0.0;
      v51 = *v47;
      do
      {
        v50 = v50 + a2[v51 - 1] * *(v49 - 1);
        v52 = *(_DWORD *)v49;
        v49 += 2;
        v51 = v52;
      }
      while (v52 != -1);
    }
    v53 = (double)(int)v46;
    v54 = v50 * (double)(int)v46 + -1.0;
    v55 = 8 * v46 + 8;
    v56 = *(double *)((char *)&v82 + v55);
    v57 = *((double *)v15 + v45);
    v58 = v54 + v57 * *(double *)((char *)v84 + v55);
    if (v57 == 0.0)
    {
      if (v58 <= v33)
      {
        v59 = 0.0;
        if (v58 < 0.0)
          goto LABEL_36;
        goto LABEL_37;
      }
    }
    else
    {
      v59 = v58;
      if (v57 != v56)
        goto LABEL_37;
      if (v58 >= v34)
      {
        v59 = 0.0;
        if (v58 > 0.0)
LABEL_36:
          v59 = v58;
LABEL_37:
        if (v43 <= v59)
          v43 = v59;
        if (v44 >= v59)
          v44 = v59;
        if (fabs(v59) > 1.0e-12)
        {
          v60 = fmax(v57 - v58 / *(double *)(v13 + 8 * v45), 0.0);
          if (v60 < v56)
            v56 = v60;
          *((double *)v15 + v45) = v56;
          if (v48 != -1)
          {
            v61 = (v56 - v57) * v53;
            v62 = (double *)(v47 + 4);
            do
            {
              a2[v48 - 1] = a2[v48 - 1] + v61 * *(v62 - 1);
              v63 = *(_DWORD *)v62;
              v62 += 2;
              v48 = v63;
            }
            while (v63 != -1);
          }
        }
        goto LABEL_47;
      }
    }
    *(_DWORD *)(v14 + 4 * v41) = *(_DWORD *)(v14 + 4 * --v35);
    *(_DWORD *)(v14 + 4 * v35) = v45;
    --v41;
LABEL_47:
    if (++v41 >= v35)
      goto LABEL_50;
  }
}

void transpose(int *a1, uint64_t *a2, uint64_t a3)
{
  int v6;
  int v7;
  uint64_t v8;
  uint64_t *v9;
  uint64_t *v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int *v17;
  int v18;
  int *v19;
  int v20;
  _QWORD *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t i;
  uint64_t v26;
  uint64_t v27;
  int *v28;
  int v29;
  _DWORD *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  int v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;

  v7 = *a1;
  v6 = a1[1];
  v8 = *a1;
  v9 = (uint64_t *)operator new[]();
  *(_DWORD *)a3 = v7;
  *(_DWORD *)(a3 + 4) = v6;
  *(_QWORD *)(a3 + 8) = operator new[]();
  *(_QWORD *)(a3 + 16) = operator new[]();
  if (v7 >= 1)
  {
    v10 = (uint64_t *)*((_QWORD *)a1 + 1);
    v11 = *(_QWORD **)(a3 + 8);
    v12 = v8;
    do
    {
      v13 = *v10++;
      *v11++ = v13;
      --v12;
    }
    while (v12);
  }
  if ((v6 & 0x80000000) == 0)
    bzero(v9, 8 * (v6 + 1));
  if ((int)v8 >= 1)
  {
    v14 = 0;
    v15 = 0;
    v16 = *((_QWORD *)a1 + 2);
    do
    {
      v17 = *(int **)(v16 + 8 * v14);
      v18 = *v17;
      if (*v17 != -1)
      {
        v19 = v17 + 4;
        do
        {
          ++v15;
          ++v9[v18];
          v20 = *v19;
          v19 += 4;
          v18 = v20;
        }
        while (v20 != -1);
      }
      ++v14;
    }
    while (v14 != v8);
  }
  if (v6 >= 1)
  {
    v21 = v9 + 1;
    v22 = *v9;
    v23 = (v6 + 1) - 1;
    do
    {
      v22 += *v21 + 1;
      *v21++ = v22;
      --v23;
    }
    while (v23);
  }
  v24 = operator new[]();
  if (v6 >= 1)
  {
    for (i = 0; i != v6; ++i)
      *(_QWORD *)(*(_QWORD *)(a3 + 16) + i * 8) = v24 + 16 * v9[i];
  }
  if ((int)v8 >= 1)
  {
    v26 = 0;
    v27 = *((_QWORD *)a1 + 2);
    do
    {
      v28 = *(int **)(v27 + 8 * v26);
      v29 = *v28;
      ++v26;
      if (*v28 != -1)
      {
        v30 = v28 + 4;
        do
        {
          v31 = v29 - 1;
          v32 = v9[v31];
          v33 = v24 + 16 * v32;
          *(_DWORD *)v33 = v26;
          *(_QWORD *)(v33 + 8) = *((_QWORD *)v30 - 1);
          v9[v31] = v32 + 1;
          v34 = *v30;
          v30 += 4;
          v29 = v34;
        }
        while (v34 != -1);
      }
    }
    while (v26 != v8);
  }
  if (v6 >= 1)
  {
    v35 = v6;
    v36 = v9;
    do
    {
      v37 = *v36++;
      *(_DWORD *)(v24 + 16 * v37) = -1;
      --v35;
    }
    while (v35);
  }
  *a2 = v24;
  JUMPOUT(0x20BD188CCLL);
}

void solve_l2r_l1l2_svr(unsigned int *a1, double *a2, double *a3, int a4)
{
  int v7;
  uint64_t v8;
  double v9;
  double v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  double *v14;
  double v15;
  double v16;
  uint64_t v17;
  uint64_t v18;
  _DWORD *v19;
  int v20;
  double v21;
  double *v22;
  double v23;
  double v24;
  int v25;
  unsigned int v26;
  double v27;
  double v28;
  double v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  int v34;
  uint64_t v35;
  double v36;
  double v37;
  int v38;
  double v39;
  double v40;
  _DWORD *v41;
  int v42;
  double *v43;
  int v44;
  int v45;
  double v46;
  double v47;
  double v48;
  double v49;
  double v50;
  double v52;
  double v53;
  BOOL v54;
  double v55;
  double v56;
  double v57;
  double v58;
  BOOL v59;
  double *v60;
  int v61;
  double v62;
  unsigned int v63;
  unint64_t v64;
  uint64_t v65;
  double v66;
  double v67;
  int v68;
  double *v69;
  double v70;
  double v71;
  double v72;
  double v73;
  uint64_t v74;
  int v75;
  unsigned int *v76;
  double v77;
  double v78;

  v7 = *a1;
  v74 = a1[1];
  v8 = *a1;
  v9 = a3[6];
  v10 = a3[2];
  v77 = a3[1];
  v11 = operator new[]();
  v12 = (void *)operator new[]();
  v13 = operator new[]();
  v76 = a1;
  v14 = (double *)*((_QWORD *)a1 + 1);
  if (a4 == 13)
    v15 = 0.0;
  else
    v15 = 0.5 / v10;
  if (a4 == 13)
    v16 = v10;
  else
    v16 = INFINITY;
  if (v7 >= 1)
    bzero(v12, 8 * v8);
  if ((int)v74 >= 1)
    bzero(a2, 8 * v74);
  if (v7 >= 1)
  {
    v17 = 0;
    v18 = *((_QWORD *)a1 + 2);
    do
    {
      *(_QWORD *)(v13 + 8 * v17) = 0;
      v19 = *(_DWORD **)(v18 + 8 * v17);
      v20 = *v19;
      if (*v19 != -1)
      {
        v21 = *((double *)v12 + v17);
        v22 = (double *)(v19 + 4);
        v23 = 0.0;
        do
        {
          v24 = *(v22 - 1);
          v23 = v23 + v24 * v24;
          *(double *)(v13 + 8 * v17) = v23;
          a2[v20 - 1] = a2[v20 - 1] + v21 * v24;
          v25 = *(_DWORD *)v22;
          v22 += 2;
          v20 = v25;
        }
        while (v25 != -1);
      }
      *(_DWORD *)(v11 + 4 * v17) = v17;
      ++v17;
    }
    while (v17 != v8);
  }
  v26 = 0;
  v27 = -v16;
  v28 = -1.0;
  v78 = -1.0;
  v29 = INFINITY;
  v75 = v7;
  while (v7 < 1)
  {
    v37 = 0.0;
    v36 = 0.0;
LABEL_66:
    v62 = v78;
    if (!v26)
      v62 = v36;
    v63 = v26 + 1;
    HIDWORD(v64) = -858993459 * (v26 + 1);
    LODWORD(v64) = HIDWORD(v64);
    if ((v64 >> 1) <= 0x19999999)
      info(".", v28);
    v28 = v77 * v62;
    v78 = v62;
    if (v36 <= v77 * v62)
    {
      v59 = v7 == v75;
      v7 = v75;
      if (v59)
      {
        info("\noptimization finished, #iter = %d\n", v26 + 1);
        if (v26 >= 0x3E7)
LABEL_76:
          info("\nWARNING: reaching max number of iterations\nUsing -s 11 may be faster\n\n");
        v65 = v74;
        v66 = 0.0;
        if ((int)v74 >= 1)
        {
          do
          {
            v67 = *a2++;
            v66 = v66 + v67 * v67;
            --v65;
          }
          while (v65);
          v66 = v66 * 0.5;
        }
        if (v7 < 1)
        {
          v68 = 0;
        }
        else
        {
          v68 = 0;
          v69 = (double *)v12;
          do
          {
            v70 = *v69++;
            v71 = v70;
            v72 = fabs(v70);
            v73 = *v14++;
            v66 = v66 + v9 * v72 - v73 * v71 + v15 * 0.5 * v71 * v71;
            if (v71 != 0.0)
              ++v68;
            --v8;
          }
          while (v8);
        }
        info("Objective value = %lf\n", v66);
        info("nSV = %d\n", v68);
        MEMORY[0x20BD188CC](v12, 0x1000C8000313F17);
        MEMORY[0x20BD188CC](v13, 0x1000C8000313F17);
        JUMPOUT(0x20BD188CCLL);
      }
      info("*");
      v37 = INFINITY;
    }
    v29 = v37;
    ++v26;
    if (v63 == 1000)
    {
      info("\noptimization finished, #iter = %d\n", 1000);
      v7 = v75;
      goto LABEL_76;
    }
  }
  v30 = 0;
  v31 = v7;
  do
  {
    v32 = v30 + rand() % v7;
    v33 = *(_DWORD *)(v11 + 4 * v30);
    *(_DWORD *)(v11 + 4 * v30) = *(_DWORD *)(v11 + 4 * v32);
    *(_DWORD *)(v11 + 4 * v32) = v33;
    ++v30;
    --v7;
  }
  while (v31 != v30);
  v34 = 0;
  v35 = *((_QWORD *)v76 + 2);
  v28 = -v29;
  v36 = 0.0;
  v37 = 0.0;
  v7 = v31;
  while (1)
  {
    v38 = *(_DWORD *)(v11 + 4 * v34);
    v39 = *((double *)v12 + v38);
    v40 = -(v14[v38] - v15 * v39);
    v41 = *(_DWORD **)(v35 + 8 * v38);
    v42 = *v41;
    if (*v41 != -1)
    {
      v43 = (double *)(v41 + 4);
      v44 = *v41;
      do
      {
        v40 = v40 + *(v43 - 1) * a2[v44 - 1];
        v45 = *(_DWORD *)v43;
        v43 += 2;
        v44 = v45;
      }
      while (v45 != -1);
    }
    v46 = v9 + v40;
    v47 = v40 - v9;
    v48 = -(v9 + v40);
    if (v39 == 0.0)
    {
      if (v46 < 0.0)
      {
        v49 = v48;
LABEL_46:
        v52 = v15 + *(double *)(v13 + 8 * v38);
        if (v37 <= v49)
          v37 = v49;
        v36 = v36 + v49;
        v53 = v39 * v52;
        v54 = v47 <= v39 * v52;
        v55 = -v47 / v52;
        if (v54)
          v55 = -v39;
        v56 = v48 / v52;
        if (v46 >= v53)
          v56 = v55;
        if (fabs(v56) >= 1.0e-12)
        {
          v57 = v39 + v56;
          if (v57 <= v27)
            v57 = -v16;
          if (v57 >= v16)
            v57 = v16;
          *((double *)v12 + v38) = v57;
          v58 = v57 - v39;
          v59 = v58 == 0.0 || v42 == -1;
          if (!v59)
          {
            v60 = (double *)(v41 + 4);
            do
            {
              a2[v42 - 1] = a2[v42 - 1] + v58 * *(v60 - 1);
              v61 = *(_DWORD *)v60;
              v60 += 2;
              v42 = v61;
            }
            while (v61 != -1);
          }
        }
        goto LABEL_63;
      }
      v49 = v47;
      if (v47 > 0.0)
        goto LABEL_46;
      v49 = 0.0;
      if (v46 <= v29 || v47 >= v28)
        goto LABEL_46;
    }
    else if (v39 >= v16)
    {
      v49 = v46;
      if (v46 > 0.0)
        goto LABEL_46;
      v49 = 0.0;
      if (v46 >= v28)
        goto LABEL_46;
    }
    else
    {
      if (v39 > v27)
      {
        v49 = fabs(v47);
        v50 = fabs(v46);
        if (v39 > 0.0)
          v49 = v50;
        goto LABEL_46;
      }
      if (v47 < 0.0)
      {
        v49 = -v47;
        goto LABEL_46;
      }
      v49 = 0.0;
      if (v47 <= v29)
        goto LABEL_46;
    }
    *(_DWORD *)(v11 + 4 * v34) = *(_DWORD *)(v11 + 4 * --v7);
    *(_DWORD *)(v11 + 4 * v7) = v38;
    --v34;
LABEL_63:
    if (++v34 >= v7)
      goto LABEL_66;
  }
}

void CPMLSerialization::CPMLSerialization(CPMLSerialization *this, sqlite3 *a2)
{
  this->var0 = (void **)&off_24C255408;
  this->var1 = 1;
  *(_QWORD *)&this->var2 = 0xFFFFFFFFLL;
  this->var4 = 0;
  this->var5 = a2;
}

void CPMLSerialization::~CPMLSerialization(CPMLSerialization *this)
{
  void *var4;
  size_t var3;
  CPMLLog *v4;
  pthread_mutex_t *CPMLLog;
  int var2;

  this->var0 = (void **)&off_24C255408;
  var4 = this->var4;
  if (var4)
  {
    var3 = this->var3;
    if ((int)var3 >= 1)
    {
      v4 = (CPMLLog *)munmap(var4, var3);
      if ((v4 & 0x80000000) != 0)
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v4);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "~CPMLSerialization", "unmap failed");
      }
    }
  }
  var2 = this->var2;
  if ((var2 & 0x80000000) == 0)
    close(var2);
}

{
  CPMLSerialization::~CPMLSerialization(this);
  JUMPOUT(0x20BD188E4);
}

void *CPMLLog::getCPMLLog(CPMLLog *this)
{
  unsigned __int8 v1;

  {
    CPMLLog::CPMLLog((CPMLLog *)&CPMLLog::getCPMLLog(void)::instance);
    __cxa_atexit((void (*)(void *))CPMLLog::~CPMLLog, &CPMLLog::getCPMLLog(void)::instance, &dword_209CB5000);
  }
  return &CPMLLog::getCPMLLog(void)::instance;
}

void sub_209CC23A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, int *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, unsigned int *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, unint64_t *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, float *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, double *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_write(CPMLSerialization *this, char *a2, const char *a3, unint64_t a4, const char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, int *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, unsigned int *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, unint64_t *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, float *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, double *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_read(CPMLSerialization *this, char *a2, const char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_doSerialization(CPMLSerialization *this)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_doSerialization", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::reset(CPMLSerialization *this)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "reset", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_query_uint64_t(CPMLSerialization *this, unint64_t *a2, unint64_t a3, char *a4, char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_query_uint64_t", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_query_double(CPMLSerialization *this, double *a2, unint64_t a3, char *a4, char *a5)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_query_double", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_update_int(CPMLSerialization *this, int a2, char *a3, char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_int", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_update_uint64_t(CPMLSerialization *this, unint64_t a2, char *a3, char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_uint64_t", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_update_double(CPMLSerialization *this, double a2, char *a3, char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_double", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_singleQuery_string(CPMLSerialization *this, char *a2, unint64_t a3, char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_string", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_singleQuery_uint64_t(CPMLSerialization *this, unint64_t *a2, char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_uint64_t", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_multiQuery_int(CPMLSerialization *this, int *a2, unint64_t a3, const char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_multiQuery_int", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_multiQuery_uint64_t(CPMLSerialization *this, unint64_t *a2, unint64_t a3, const char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_multiQuery_uint64_t", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_multiQuery_double(CPMLSerialization *this, double *a2, unint64_t a3, const char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_multiQuery_double", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

uint64_t CPMLSerialization::cp_singleQuery_double(CPMLSerialization *this, double *a2, char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_double", "unimplemented function.");
  return 0xFFFFFFFFLL;
}

pthread_mutex_t *CPMLSerialization::cp_createTable(CPMLSerialization *this, char *a2, char *a3)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  return CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_createTable", "unimplemented function.");
}

pthread_mutex_t *CPMLSerialization::cp_insertIntoTable(CPMLSerialization *this, char *a2, char *a3, char *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  return CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_insertIntoTable", "unimplemented function.");
}

uint64_t CPMLSerialization::cp_saveCache(CPMLSerialization *this, char *a2, void *__buf, int a4)
{
  int var2;
  CPMLLog *v8;
  uint64_t result;
  pthread_mutex_t *CPMLLog;

  var2 = this->var2;
  if (var2 == -1)
  {
    var2 = open(a2, 513, 448);
    this->var2 = var2;
  }
  v8 = (CPMLLog *)write(var2, __buf, a4);
  if (v8 == (CPMLLog *)a4)
    return 0;
  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v8);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_saveCache", "cache saved incorrectly.\n");
  close(this->var2);
  result = 0xFFFFFFFFLL;
  this->var2 = -1;
  return result;
}

uint64_t CPMLSerialization::cp_loadCache(CPMLSerialization *this, char *a2, void **a3, int a4)
{
  int var2;
  uint64_t result;
  void *v9;
  void *v10;

  var2 = this->var2;
  if (var2 != -1 || (result = open(a2, 2, 0), var2 = result, this->var2 = result, (_DWORD)result != -1))
  {
    v9 = mmap(0, a4, 1, 2, var2, 0);
    *a3 = v9;
    if (v9 == (void *)-1)
    {
      close(this->var2);
      result = 0xFFFFFFFFLL;
      this->var2 = -1;
    }
    else
    {
      v10 = v9;
      result = 0;
      this->var3 = a4;
      this->var4 = v10;
    }
  }
  return result;
}

CPMLLog *CPMLSerialization::cp_beginTransaction(CPMLSerialization *this)
{
  return CPMLsql_beginTransaction(this->var5, 0);
}

CPMLLog *CPMLSerialization::cp_endTransaction(CPMLSerialization *this)
{
  return CPMLsql_commitTransaction(this->var5);
}

id CPMLTrainDataWith(void *a1, void *a2)
{
  id v3;
  id v4;
  void *v5;
  void *v6;
  uint64_t v8;
  uint64_t v9;

  v3 = a1;
  v4 = a2;
  if (v4)
  {
    objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfFile:", v4);
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    if (!v5)
    {
      NSLog(CFSTR("%s plist incorrect."), "CPMLTrainDataWith");
      goto LABEL_7;
    }
    v8 = 0;
    v9 = 100;
    objc_msgSend(MEMORY[0x24BDD1770], "propertyListWithData:options:format:error:", v5, 0, &v9, &v8);
    v6 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v6 = 0;
  }
  CPMLTrainDataWithDict(v3, v6);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

LABEL_7:
  return v5;
}

CPMLModel *CPMLTrainDataWithDict(void *a1, void *a2)
{
  id v3;
  id v4;
  id v5;
  CPMLModel *v6;
  void *v7;
  void *v8;
  void *v9;
  CPMLModelEvaluate *v10;

  v3 = a2;
  v4 = a1;
  v5 = -[CPMLTrainer init:withModelDBPath:withPropertyList:]([CPMLTrainer alloc], "init:withModelDBPath:withPropertyList:", v4, 0, v3);

  objc_msgSend(v5, "train:", 0);
  v6 = objc_alloc_init(CPMLModel);
  objc_msgSend(v3, "objectForKey:", CFSTR("modelFilenameAndPath"));
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  if (!v7)
  {
    objc_msgSend(MEMORY[0x24BDD1488], "mainBundle");
    v8 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v8, "bundleIdentifier");
    v9 = (void *)objc_claimAutoreleasedReturnValue();

    v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithFormat:", CFSTR("/tmp/_MODEL_%@"), v9);
  }
  v10 = -[CPMLModelEvaluate initWithModel:withPropertyList:]([CPMLModelEvaluate alloc], "initWithModel:withPropertyList:", v7, v3);
  -[CPMLModel setCpModelEvaluate:](v6, "setCpModelEvaluate:", v10);

  return v6;
}

id CPMLTrainDataFrom(void *a1, void *a2)
{
  id v3;
  id v4;
  CPMLDB *v5;
  void *v6;

  v3 = a2;
  v4 = a1;
  v5 = -[CPMLDB initWithDBName:withPlistPath:withWriteOptions:]([CPMLDB alloc], "initWithDBName:withPlistPath:withWriteOptions:", v4, v3, 3);

  CPMLTrainDataWith(v5, v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

id CPMLTrainDataFromDict(void *a1, void *a2)
{
  id v3;
  id v4;
  CPMLDB *v5;
  void *v6;

  v3 = a2;
  v4 = a1;
  v5 = -[CPMLDB initWithDBName:withConfiguration:withWriteOptions:]([CPMLDB alloc], "initWithDBName:withConfiguration:withWriteOptions:", v4, v3, 3);

  CPMLTrainDataWithDict(v5, v3);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

void CPMLTrainAndSaveDataWith(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  uint64_t v8;
  void *v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;

  v5 = a1;
  v6 = a2;
  v7 = a3;
  if (v6)
  {
    objc_msgSend(MEMORY[0x24BDBCE50], "dataWithContentsOfFile:", v6);
    v8 = objc_claimAutoreleasedReturnValue();
    if (!v8)
    {
      NSLog(CFSTR("%s plist incorrect."), "CPMLTrainAndSaveDataWith");
      goto LABEL_7;
    }
    v9 = (void *)v8;
    v11 = 0;
    v12 = 100;
    objc_msgSend(MEMORY[0x24BDD1770], "propertyListWithData:options:format:error:", v8, 0, &v12, &v11);
    v10 = (void *)objc_claimAutoreleasedReturnValue();

  }
  else
  {
    v10 = 0;
  }
  CPMLTrainAndSaveDataWithDict(v5, v10, v7);

LABEL_7:
}

void CPMLTrainAndSaveDataWithDict(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  id v8;

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = -[CPMLTrainer init:withModelDBPath:withPropertyList:]([CPMLTrainer alloc], "init:withModelDBPath:withPropertyList:", v7, v5, v6);

  if (v8)
    objc_msgSend(v8, "train:", 1);
  else
    NSLog(CFSTR("Cannot TrainAndSaveData"));

}

void CPMLTrainAndSaveDataFrom(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  CPMLDB *v8;

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = -[CPMLDB initWithDBName:withPlistPath:withWriteOptions:]([CPMLDB alloc], "initWithDBName:withPlistPath:withWriteOptions:", v7, v6, 1);

  CPMLTrainAndSaveDataWith(v8, v6, v5);
}

void CPMLTrainAndSaveDataFromDict(void *a1, void *a2, void *a3)
{
  id v5;
  id v6;
  id v7;
  CPMLDB *v8;

  v5 = a3;
  v6 = a2;
  v7 = a1;
  v8 = -[CPMLDB initWithDBName:withConfiguration:withWriteOptions:]([CPMLDB alloc], "initWithDBName:withConfiguration:withWriteOptions:", v7, v6, 1);

  CPMLTrainAndSaveDataWithDict(v8, v6, v5);
}

void *CPMLTrainOBJDataWith(void *a1, uint64_t a2)
{
  objc_class *v3;
  id v4;
  void *v5;
  void *v6;

  v3 = (objc_class *)MEMORY[0x24BDD17C8];
  v4 = a1;
  v5 = (void *)objc_msgSend([v3 alloc], "initWithCString:encoding:", a2, 4);
  CPMLTrainDataWith(v4, v5);
  v6 = (void *)objc_claimAutoreleasedReturnValue();

  return v6;
}

void *CPMLTrainOBJDataFrom(uint64_t a1, uint64_t a2)
{
  void *v3;
  void *v4;
  void *v5;

  v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a1, 4);
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  CPMLTrainDataFrom(v3, v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

void CPMLTrainAndSaveOBJDataWith(void *a1, uint64_t a2, uint64_t a3)
{
  objc_class *v5;
  id v6;
  void *v7;
  id v8;

  v5 = (objc_class *)MEMORY[0x24BDD17C8];
  v6 = a1;
  v8 = (id)objc_msgSend([v5 alloc], "initWithCString:encoding:", a2, 4);
  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a3, 4);
  CPMLTrainAndSaveDataWith(v6, v8, v7);

}

void CPMLTrainAndSaveOBJDataFrom(uint64_t a1, uint64_t a2, uint64_t a3)
{
  void *v5;
  void *v6;
  id v7;

  v7 = (id)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a1, 4);
  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a3, 4);
  CPMLTrainAndSaveDataFrom(v7, v5, v6);

}

void CPMLLog::CPMLLog(CPMLLog *this)
{
  pthread_mutexattr_t *v2;
  int v3;
  FILE **v4;
  int v5;
  int v6;

  *(_QWORD *)this = 850045863;
  *(_OWORD *)((char *)this + 8) = 0u;
  *(_OWORD *)((char *)this + 24) = 0u;
  *(_OWORD *)((char *)this + 40) = 0u;
  *((_QWORD *)this + 7) = 0;
  v2 = (pthread_mutexattr_t *)((char *)this + 64);
  v3 = pthread_mutexattr_init((pthread_mutexattr_t *)this + 4);
  v4 = (FILE **)MEMORY[0x24BDAC8D8];
  if (v3)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "pthread_mutexattr_init fail %d\n", v3);
  v5 = pthread_mutexattr_settype(v2, 2);
  if (v5)
    fprintf(*v4, "pthread_mutexattr_settype fail %d\n", v5);
  v6 = pthread_mutex_init((pthread_mutex_t *)this, v2);
  if (v6)
    fprintf(*v4, "pthread_mutex_init fail %d\n", v6);
}

void CPMLLog::~CPMLLog(pthread_mutexattr_t *this)
{
  int v2;
  FILE **v3;
  int v4;

  v2 = pthread_mutexattr_destroy(this + 4);
  v3 = (FILE **)MEMORY[0x24BDAC8D8];
  if (v2)
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "pthread_mutexattr_destroy fail %d\n", v2);
  v4 = pthread_mutex_destroy((pthread_mutex_t *)this);
  if (v4)
    fprintf(*v3, "pthread_mutex_destroy fail %d\n", v4);
}

pthread_mutex_t *CPMLLog::log(pthread_mutex_t *this, int a2, const char *a3, const char *a4, ...)
{
  pthread_mutex_t *v6;
  char __str[512];
  uint64_t v8;
  va_list va;

  va_start(va, a4);
  v6 = this;
  v8 = *MEMORY[0x24BDAC8D0];
  if (a2 < 4 || *(_QWORD *)&this[1].__opaque[8])
  {
    pthread_mutex_lock(this);
    vsnprintf(__str, 0x200uLL, a4, va);
    if ((v6[1].__opaque[8] & 1) != 0)
      fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s: %s", a3, __str);
    return (pthread_mutex_t *)pthread_mutex_unlock(v6);
  }
  return this;
}

void CPMLNaiveBayesSuggestions::predict_sorted(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, _QWORD *a5)
{
  unsigned int **v10;
  uint64_t v12;
  std::vector<int>::pointer end;
  int *v14;
  int *v15;
  std::vector<int>::pointer begin;
  uint64_t v17;
  unint64_t v18;
  int64_t v19;
  unint64_t v20;
  char *v21;
  int *v22;
  int v23;
  _QWORD *v24;
  _QWORD *v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  const void **v30;
  _QWORD *v31;
  uint64_t v32;
  _QWORD *v33;
  unint64_t v34;
  std::vector<int> v35;
  void *__p;
  void *v37;
  uint64_t v38;
  void **v39;

  v10 = (unsigned int **)*a2;
  if (*(_DWORD *)(a1 + 72) >= (signed int)(-1431655765 * ((unint64_t)(a2[1] - (_QWORD)v10) >> 3)))
  {
    CPMLNaiveBayes::predict_sorted(a1, a2, a3, a4, a5);
  }
  else
  {
    __p = 0;
    v37 = 0;
    v38 = 0;
    CPMLNaiveBayes::sort_candidates(a1, v10, (uint64_t)&__p);
    std::vector<int>::vector(&v35, *(int *)(a1 + 72));
    v31 = a5;
    std::vector<std::vector<int>>::vector(&v32, *(int *)(a1 + 72));
    if (*(int *)(a1 + 72) >= 1)
    {
      v12 = 0;
      end = v35.__end_;
      do
      {
        v14 = (int *)((char *)__p + 16 * v12 + 8);
        if (end >= v35.__end_cap_.__value_)
        {
          begin = v35.__begin_;
          v17 = end - v35.__begin_;
          v18 = v17 + 1;
          if ((unint64_t)(v17 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v19 = (char *)v35.__end_cap_.__value_ - (char *)v35.__begin_;
          if (((char *)v35.__end_cap_.__value_ - (char *)v35.__begin_) >> 1 > v18)
            v18 = v19 >> 1;
          if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
            v20 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v20 = v18;
          if (v20)
          {
            v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v35.__end_cap_, v20);
            begin = v35.__begin_;
            end = v35.__end_;
          }
          else
          {
            v21 = 0;
          }
          v22 = (int *)&v21[4 * v17];
          *v22 = *v14;
          v15 = v22 + 1;
          while (end != begin)
          {
            v23 = *--end;
            *--v22 = v23;
          }
          v35.__begin_ = v22;
          v35.__end_ = v15;
          v35.__end_cap_.__value_ = (int *)&v21[4 * v20];
          if (begin)
            operator delete(begin);
        }
        else
        {
          *end = *v14;
          v15 = end + 1;
        }
        v35.__end_ = v15;
        ++v12;
        end = v15;
      }
      while (v12 < *(int *)(a1 + 72));
    }
    v24 = v33;
    if ((unint64_t)v33 >= v34)
    {
      v25 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v32, (uint64_t)&v35);
    }
    else
    {
      *v33 = 0;
      v24[1] = 0;
      v24[2] = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v24, v35.__begin_, (uint64_t)v35.__end_, v35.__end_ - v35.__begin_);
      v25 = v24 + 3;
    }
    v33 = v25;
    v26 = *a2;
    if (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) >= 2)
    {
      v27 = 0;
      v28 = 1;
      do
      {
        v29 = v26 + v27;
        v30 = (const void **)(v29 + 24);
        if ((unint64_t)v25 >= v34)
        {
          v25 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v32, (uint64_t)v30);
        }
        else
        {
          *v25 = 0;
          v25[1] = 0;
          v25[2] = 0;
          std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v25, *v30, *(_QWORD *)(v29 + 32), (uint64_t)(*(_QWORD *)(v29 + 32) - (_QWORD)*v30) >> 2);
          v25 += 3;
        }
        v33 = v25;
        ++v28;
        v26 = *a2;
        v27 += 24;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v28);
    }
    CPMLNaiveBayes::predict_sorted(a1, &v32, a3, a4, v31);
    v39 = (void **)&v32;
    std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&v39);
    if (v35.__begin_)
    {
      v35.__end_ = v35.__begin_;
      operator delete(v35.__begin_);
    }
    if (__p)
    {
      v37 = __p;
      operator delete(__p);
    }
  }
}

void sub_209CC37E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, void *a17, uint64_t a18, uint64_t a19, char *a20)
{
  a20 = &a11;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a20);
  if (__p)
  {
    a15 = (uint64_t)__p;
    operator delete(__p);
  }
  if (a17)
  {
    a18 = (uint64_t)a17;
    operator delete(a17);
  }
  _Unwind_Resume(a1);
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::vector<int>::pointer end;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<int>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    bzero(end, 4 * __n);
    this->__end_ = &end[__n];
  }
  return this;
}

void sub_209CC38A4(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<int>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 62)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[4 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 62)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(4 * a2);
}

_QWORD *std::vector<std::vector<int>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<int>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_209CC39C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<std::vector<int>>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<int>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[24 * v4];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<int>>>(uint64_t a1, unint64_t a2)
{
  if (a2 >= 0xAAAAAAAAAAAAAABLL)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(24 * a2);
}

void std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<std::vector<int>>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<std::vector<int>>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  void *v5;
  void *v6;

  v3 = *a1;
  v2 = a1[1];
  if (v2 != *a1)
  {
    v4 = a1[1];
    do
    {
      v6 = *(void **)(v4 - 24);
      v4 -= 24;
      v5 = v6;
      if (v6)
      {
        *(_QWORD *)(v2 - 16) = v5;
        operator delete(v5);
      }
      v2 = v4;
    }
    while (v4 != v3);
  }
  a1[1] = v3;
}

uint64_t std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = 0xAAAAAAAAAAAAAAABLL * ((a1[1] - *a1) >> 3);
  v5 = v4 + 1;
  if (v4 + 1 > 0xAAAAAAAAAAAAAAALL)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = 0xAAAAAAAAAAAAAAABLL * ((a1[2] - v3) >> 3);
  if (2 * v8 > v5)
    v5 = 2 * v8;
  if (v8 >= 0x555555555555555)
    v9 = 0xAAAAAAAAAAAAAAALL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::vector<int>>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[24 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[24 * v9];
  *(_QWORD *)v11 = 0;
  *((_QWORD *)v11 + 1) = 0;
  *((_QWORD *)v11 + 2) = 0;
  std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v11, *(const void **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 2);
  v15 += 24;
  std::vector<std::vector<int>>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<std::vector<int>>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_209CC3BFC(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::vector<int>>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<int>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_209CC3C6C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

uint64_t std::vector<std::vector<int>>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>>((uint64_t)(a1 + 2), a1[1], (_QWORD *)a1[1], *a1, (_QWORD *)*a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>,std::reverse_iterator<std::vector<int>*>>(uint64_t a1, uint64_t a2, _QWORD *a3, uint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  __int128 v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      *(_QWORD *)(v7 - 24) = 0;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      v8 = *(_OWORD *)(a3 - 3);
      a3 -= 3;
      *(_OWORD *)(v7 - 24) = v8;
      *(_QWORD *)(v7 - 8) = a3[2];
      *a3 = 0;
      a3[1] = 0;
      a3[2] = 0;
      v7 = *((_QWORD *)&v14 + 1) - 24;
      *((_QWORD *)&v14 + 1) -= 24;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::reverse_iterator<std::vector<int>*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v3;
      operator delete(v3);
    }
    v1 += 24;
  }
}

uint64_t std::__split_buffer<std::vector<int>>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<std::vector<int>>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<std::vector<int>>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    v5 = *(void **)(v2 - 24);
    *(_QWORD *)(a1 + 16) = v2 - 24;
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 24;
    }
  }
}

double *CPRTgrowTree(unsigned int a1, unsigned int a2, unsigned int a3, double (*a4)(double *, double *, unsigned int, unsigned int, unsigned int *, double *, unsigned int *, double), uint64_t a5, unsigned int a6, double *a7, double *a8, unsigned int a9)
{
  _DWORD *v17;
  uint64_t v18;
  double v19;
  double *v20;
  double *v21;
  double v22;
  CPMLLog *v23;
  size_t v24;
  _QWORD *v25;
  size_t v26;
  char *v27;
  char *v28;
  double (*v29)(double *, double *, unsigned int, unsigned int, unsigned int *, double *, unsigned int *, double);
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  double v34;
  int v35;
  double *v36;
  double *v37;
  double *v38;
  double *v39;
  uint64_t v40;
  uint64_t v41;
  int v42;
  int v43;
  double v44;
  double *v45;
  uint64_t v46;
  int v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  double *v55;
  unsigned int v56;
  int v57;
  pthread_mutex_t *CPMLLog;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63[2];
  _QWORD *v64;
  _DWORD *v65;
  _DWORD *v66;
  double *v67;
  _DWORD *v68;
  double *v69;
  unsigned int v70;

  v17 = malloc_type_malloc(0x40uLL, 0x10800407B512463uLL);
  v17[4] = a6;
  v17[5] = a5;
  v67 = a8;
  v68 = v17;
  v17[7] = a9;
  if (a6)
  {
    v18 = 8 * a6;
    v19 = 0.0;
    v20 = a8;
    v21 = (double *)v17;
    do
    {
      v22 = *v20++;
      v19 = v19 + v22;
      v18 -= 8;
    }
    while (v18);
  }
  else
  {
    v19 = 0.0;
    v21 = (double *)v17;
  }
  v21[7] = v19 / (double)a6;
  *(_DWORD *)v21 = 2;
  *((_DWORD *)v21 + 8) = 0;
  *((_DWORD *)v21 + 6) = 0;
  v21[5] = 0.0;
  v21[6] = 0.0;
  v23 = (CPMLLog *)malloc_type_malloc(0x10uLL, 0x2004093837F09uLL);
  *((_QWORD *)v21 + 1) = v23;
  *(_QWORD *)v23 = 0;
  *(_QWORD *)(*((_QWORD *)v21 + 1) + 8) = 0;
  if (a3)
  {
    if (*((_DWORD *)v21 + 4) > a2 && *((_DWORD *)v21 + 7) < a1)
    {
      v62 = a1;
      v61 = a2;
      *(_QWORD *)v63 = a3;
      v70 = a6;
      v69 = (double *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
      v24 = 8 * a3;
      v25 = malloc_type_malloc(v24, 0x100004000313F17uLL);
      v60 = a3;
      v26 = 4 * a3;
      v27 = (char *)malloc_type_malloc(v26, 0x100004052888210uLL);
      v28 = (char *)malloc_type_malloc(v26, 0x100004052888210uLL);
      v29 = a4;
      v30 = a5;
      v31 = 0;
      v65 = v28;
      v66 = v27;
      do
      {
        v69[v31 / 8] = v29(a7, v67, v70, v30, (unsigned int *)v27, (double *)&v25[v31 / 8], (unsigned int *)v28, v21[7]);
        v27 += 4;
        v31 += 8;
        v28 += 4;
      }
      while (v24 != v31);
      v64 = v25;
      v32 = 0;
      v33 = 0;
      v34 = *v69;
      do
      {
        if (v34 < v69[v32])
        {
          v33 = v32;
          v34 = v69[v32];
        }
        ++v32;
      }
      while (*(_QWORD *)v63 != v32);
      v35 = v65[v33];
      v68[6] = v35;
      v68[8] = v66[v33];
      *((_QWORD *)v68 + 5) = v25[v33];
      *((double *)v68 + 6) = v69[v33];
      if (v35)
      {
        v36 = (double *)malloc_type_calloc((v35 * v30), 8uLL, 0x100004000313F17uLL);
        v37 = (double *)malloc_type_calloc((v70 - v68[6]) * v30, 8uLL, 0x100004000313F17uLL);
        v38 = (double *)malloc_type_calloc(v68[6], 8uLL, 0x100004000313F17uLL);
        v39 = (double *)malloc_type_calloc(v70 - v68[6], 8uLL, 0x100004000313F17uLL);
        v40 = v68[4];
        if ((_DWORD)v40)
        {
          v41 = 0;
          v42 = 0;
          v43 = 0;
          v44 = *((double *)v68 + 5);
          v45 = &a7[(v40 * v68[8])];
          v46 = v68[5];
          do
          {
            if (v45[v41] >= v44)
            {
              if ((_DWORD)v46)
              {
                v51 = v40 - v68[6];
                v52 = v41;
                v53 = v42;
                v54 = v46;
                do
                {
                  v37[v53] = a7[v52];
                  v53 += v51;
                  v52 += v40;
                  --v54;
                }
                while (v54);
              }
              v39[v42++] = v67[v41];
            }
            else
            {
              if ((_DWORD)v46)
              {
                v47 = v68[6];
                v48 = v41;
                v49 = v43;
                v50 = v46;
                do
                {
                  v36[v49] = a7[v48];
                  v49 += v47;
                  v48 += v40;
                  --v50;
                }
                while (v50);
              }
              v38[v43++] = v67[v41];
            }
            ++v41;
          }
          while (v41 != v40);
        }
        v55 = v39;
        v56 = v68[6];
        if (v56)
        {
          **((_QWORD **)v68 + 1) = CPRTgrowTree(v62, v61, v63[0], v29, v30, v56, v36, v38, a9 + 1);
          v57 = v68[6];
        }
        else
        {
          v57 = 0;
        }
        if (v70 != v57)
          *(_QWORD *)(*((_QWORD *)v68 + 1) + 8) = CPRTgrowTree(v62, v61, v60, v29, v30, v70 - v57, v37, v55, a9 + 1);
        free(v36);
        free(v37);
        free(v38);
        free(v55);
        v25 = v64;
      }
      free(v65);
      free(v66);
      free(v25);
      free(v69);
      return (double *)v68;
    }
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v23);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPRTgrowTree", "nSplits should not be zero.");
  }
  return v21;
}

uint64_t CPRTcostTargetSD(double *a1, double *a2, unsigned int a3, uint32_t __upper_bound, unsigned int *a5, double *a6, unsigned int *a7, double a8)
{
  uint32_t v15;
  double *v16;
  uint64_t v17;
  double v18;
  double v19;
  double *v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  double v24;
  double *v25;
  double *v26;
  double *v27;
  double v28;
  double v29;
  double *v30;
  double *v31;
  double v32;
  double v33;
  double v34;
  uint64_t result;
  double v36;
  unsigned int v37;
  unsigned int v38;
  double v39;
  uint64_t v40;
  double *v41;
  double v42;
  double *v43;
  double v44;
  double v45;
  double v46;
  BOOL v47;
  double v48;
  double v49;
  double v50;
  double v51;
  double v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v57;
  double v58;
  double v59;

  v15 = arc4random_uniform(__upper_bound);
  v16 = &a1[v15 * a3];
  v17 = a3;
  if (a3 > 1)
  {
    v20 = v16 + 1;
    v21 = *v16;
    v22 = 8 * a3 - 8;
    v23 = v22;
    v24 = *v16;
    v25 = v16 + 1;
    v26 = v16;
    v27 = v16 + 1;
    do
    {
      v28 = *v27++;
      v29 = v28;
      if (v28 < v24)
      {
        v24 = v29;
        v26 = v25;
      }
      v25 = v27;
      v23 -= 8;
    }
    while (v23);
    v19 = *v26;
    v30 = v16;
    v31 = v16 + 1;
    do
    {
      v32 = *v31++;
      v33 = v32;
      if (v21 < v32)
      {
        v21 = v33;
        v30 = v20;
      }
      v20 = v31;
      v22 -= 8;
    }
    while (v22);
    v18 = *v30;
  }
  else
  {
    v18 = *v16;
    v19 = *v16;
  }
  v34 = v18 - v19;
  result = arc4random_uniform(0x7FFFFFFFu);
  v36 = v19 + v34 * (double)result / 2147483650.0;
  *a5 = v15;
  *a6 = v36;
  if (a3)
  {
    v37 = 0;
    v38 = 0;
    v39 = 0.0;
    v40 = a3;
    v41 = a2;
    v42 = 0.0;
    v43 = v16;
    do
    {
      v44 = *v43++;
      v45 = v44;
      v46 = *v41++;
      v47 = v45 < v36;
      v48 = v42 + v46;
      v49 = v39 + v46;
      if (v47)
        ++v38;
      else
        ++v37;
      if (v47)
        v42 = v48;
      else
        v39 = v49;
      --v40;
    }
    while (v40);
    v50 = v42 / (double)v38;
    v51 = 0.0;
    v52 = 0.0;
    v53 = 0.0;
    v54 = v39 / (double)v37;
    do
    {
      v55 = *a2++;
      v56 = v55;
      v53 = v53 + (v55 - a8) * (v55 - a8);
      v57 = *v16++;
      v58 = v51 + (v56 - v54) * (v56 - v54);
      v59 = v52 + (v56 - v50) * (v56 - v50);
      if (v57 >= v36)
        v51 = v58;
      else
        v52 = v59;
      --v17;
    }
    while (v17);
  }
  else
  {
    v38 = 0;
  }
  *a7 = v38;
  return result;
}

double *CPRTpredictRegressTree(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  double *v8;
  CPMLLog *v9;
  CPMLLog *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  CPMLLog *v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  double v19;
  pthread_mutex_t *CPMLLog;

  v8 = (double *)malloc_type_malloc(8 * a3, 0x100004000313F17uLL);
  v9 = (CPMLLog *)malloc_type_malloc(8 * a4, 0x100004000313F17uLL);
  v10 = v9;
  if (a3)
  {
    v11 = 0;
    do
    {
      v12 = a1;
      v13 = a4;
      v14 = v11;
      v15 = v10;
      if (a4)
      {
        do
        {
          *(_QWORD *)v15 = *(_QWORD *)(a2 + 8 * v14);
          v15 = (CPMLLog *)((char *)v15 + 8);
          v14 += a3;
          --v13;
        }
        while (v13);
        v12 = a1;
      }
      while (1)
      {
        v16 = v12;
        v17 = *(uint64_t **)(v12 + 8);
        v12 = *v17;
        if (!*v17 && !v17[1])
        {
LABEL_12:
          v19 = *(double *)(v16 + 56);
          goto LABEL_14;
        }
        v18 = *(unsigned int *)(v16 + 32);
        if (v18 >= a4)
          break;
        if (*((double *)v10 + v18) > *(double *)(v16 + 40))
          v12 = v17[1];
        if (!v12)
          goto LABEL_12;
      }
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
      v9 = (CPMLLog *)CPMLLog::log(CPMLLog, CPML_LOG_ERR, "predictTreeOnePoint", "Incorrect attribute. corrupted tree\n");
      v19 = -1.0;
LABEL_14:
      v8[v11++] = v19;
    }
    while (v11 != a3);
  }
  free(v10);
  return v8;
}

void CPRTdestroyTree(_QWORD *a1)
{
  _QWORD *v2;

  v2 = (_QWORD *)a1[1];
  if (*v2)
  {
    CPRTdestroyTree(*v2);
    v2 = (_QWORD *)a1[1];
  }
  if (v2[1])
  {
    CPRTdestroyTree(v2[1]);
    v2 = (_QWORD *)a1[1];
  }
  free(v2);
  free(a1);
}

pthread_mutex_t *CPRTprintTree(CPMLLog *a1)
{
  pthread_mutex_t *CPMLLog;
  CPMLLog *v3;
  pthread_mutex_t *v4;
  CPMLLog *v5;
  pthread_mutex_t *v6;
  CPMLLog *v7;
  pthread_mutex_t *v8;
  CPMLLog *v9;
  _QWORD *v10;
  pthread_mutex_t *v11;
  CPMLLog *v12;
  pthread_mutex_t *v13;
  CPMLLog *v14;
  pthread_mutex_t *v15;
  CPMLLog *v16;
  pthread_mutex_t *v17;
  pthread_mutex_t *v18;
  pthread_mutex_t *result;
  unint64_t v20;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(a1);
  v3 = (CPMLLog *)CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "CPRTprintTree", "** Level :%d **\n", *((_DWORD *)a1 + 7));
  v4 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v3);
  v5 = (CPMLLog *)CPMLLog::log(v4, CPML_LOG_DEBUG, "CPRTprintTree", "N :%d\n", *((_DWORD *)a1 + 4));
  v6 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v5);
  v7 = (CPMLLog *)CPMLLog::log(v6, CPML_LOG_DEBUG, "CPRTprintTree", "M :%d\n", *((_DWORD *)a1 + 5));
  v8 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v7);
  v9 = (CPMLLog *)CPMLLog::log(v8, CPML_LOG_DEBUG, "CPRTprintTree", "Mean Target :%f\n", *((double *)a1 + 7));
  v10 = (_QWORD *)*((_QWORD *)a1 + 1);
  if (*v10 || v10[1])
  {
    v11 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
    v12 = (CPMLLog *)CPMLLog::log(v11, CPML_LOG_DEBUG, "CPRTprintTree", "Children :%d\n", *(_DWORD *)a1);
    v13 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v12);
    v14 = (CPMLLog *)CPMLLog::log(v13, CPML_LOG_DEBUG, "CPRTprintTree", "Split Attribute :%d\n", *((_DWORD *)a1 + 8));
    v15 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v14);
    v16 = (CPMLLog *)CPMLLog::log(v15, CPML_LOG_DEBUG, "CPRTprintTree", "Split Threshold :%f\n", *((double *)a1 + 5));
    v17 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v16);
    v9 = (CPMLLog *)CPMLLog::log(v17, CPML_LOG_DEBUG, "CPRTprintTree", "Split Cost :%f\n", *((double *)a1 + 6));
  }
  v18 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
  result = CPMLLog::log(v18, CPML_LOG_DEBUG, "CPRTprintTree", "********\n");
  if (*(_DWORD *)a1)
  {
    v20 = 0;
    do
    {
      result = *(pthread_mutex_t **)(*((_QWORD *)a1 + 1) + 8 * v20);
      if (!result)
        break;
      result = (pthread_mutex_t *)CPRTprintTree();
      ++v20;
    }
    while (v20 < *(unsigned int *)a1);
  }
  return result;
}

void sub_209CC4968(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void sub_209CC50D8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;

  MEMORY[0x20BD188E4](v18, 0x10A1C405A95AE37);

  _Unwind_Resume(a1);
}

void sub_209CC5458(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CC552C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_209CC5BFC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;

  MEMORY[0x20BD188E4](v10, 0x10B1C4066637EEELL);

  _Unwind_Resume(a1);
}

void CPMLOnlineSvm::CPMLOnlineSvm(CPMLOnlineSvm *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;
  void **v7;
  uint64_t *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t Iterator;
  CPMLFeatureVector *v12;
  char *v13;
  int **IntVector;
  int *v15;
  uint64_t v16;
  unint64_t v17;
  double *v18;
  int v19;
  uint64_t RealVector;
  uint64_t *v21;
  uint64_t v22;
  unint64_t v23;
  _QWORD *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  int *v28;
  _DWORD *v29;
  int *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  int *v36;
  int v37;
  void *__p;
  char *v39;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_OWORD *)(v6 + 96) = 0u;
  *(_QWORD *)v6 = &off_24C255288;
  *(_OWORD *)(v6 + 112) = 0u;
  *(_OWORD *)(v6 + 128) = 0u;
  *(_DWORD *)(v6 + 144) = 1;
  *(_DWORD *)(v6 + 152) = 2;
  *(_OWORD *)(v6 + 160) = xmmword_209D001F0;
  *(_QWORD *)(v6 + 176) = 0x186A000000001;
  *(_OWORD *)(v6 + 184) = xmmword_209D00200;
  *(_OWORD *)(v6 + 200) = xmmword_209D00210;
  *(_OWORD *)(v6 + 232) = 0u;
  v7 = (void **)(v6 + 232);
  v8 = (uint64_t *)(v6 + 256);
  v9 = v6 + 416;
  *(_OWORD *)(v6 + 248) = 0u;
  *(_QWORD *)(v6 + 296) = 0;
  *(_OWORD *)(v6 + 264) = 0u;
  *(_OWORD *)(v6 + 280) = 0u;
  *(_OWORD *)(v6 + 312) = 0u;
  *(_OWORD *)(v6 + 328) = 0u;
  *(_OWORD *)(v6 + 344) = 0u;
  *(_OWORD *)(v6 + 360) = 0u;
  *(_OWORD *)(v6 + 376) = 0u;
  *(_OWORD *)(v6 + 392) = 0u;
  *(_QWORD *)(v6 + 448) = 0;
  *(_OWORD *)(v6 + 416) = 0u;
  *(_OWORD *)(v6 + 432) = 0u;
  *(_OWORD *)(v6 + 472) = 0u;
  *(_OWORD *)(v6 + 488) = 0u;
  *(_OWORD *)(v6 + 504) = 0u;
  strcpy((char *)(v6 + 8), "1.0.0");
  v10 = *((int *)a2->var0 + 31);
  Iterator = CPMLCDB::getIterator(a2, 0, 0, 0);
  while (1)
  {
    v12 = (CPMLFeatureVector *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 24))(Iterator);
    if (!v12)
      break;
    __p = 0;
    v39 = 0;
    if ((_DWORD)v10 != 1)
    {
      if ((int)v10 <= 0)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v13 = (char *)operator new(8 * (v10 - 1));
      __p = v13;
      bzero(v13, 8 * (v10 - 1));
      v39 = &v13[8 * v10 - 8];
    }
    IntVector = (int **)CPMLFeatureVector::getIntVector(v12);
    v15 = *IntVector;
    v16 = (char *)IntVector[1] - (char *)*IntVector;
    if (v16)
    {
      v17 = v16 >> 2;
      v18 = (double *)__p;
      if (v17 <= 1)
        v17 = 1;
      do
      {
        v19 = *v15++;
        *v18++ = (double)v19;
        --v17;
      }
      while (v17);
    }
    RealVector = CPMLFeatureVector::getRealVector(v12);
    v21 = *(uint64_t **)RealVector;
    v22 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
    if (v22)
    {
      v23 = v22 >> 3;
      if (v23 <= 1)
        v23 = 1;
      v24 = (char *)__p + 2 * ((char *)IntVector[1] - (char *)*IntVector);
      do
      {
        v25 = *v21++;
        *v24++ = v25;
        --v23;
      }
      while (v23);
    }
    std::vector<std::valarray<double>>::push_back[abi:ne180100](v8, (uint64_t **)&__p);
    if (CPMLFeatureVector::getYHat(v12) == 0.0)
      v26 = -1;
    else
      v26 = 1;
    v28 = (int *)*((_QWORD *)this + 30);
    v27 = *((_QWORD *)this + 31);
    if ((unint64_t)v28 >= v27)
    {
      v30 = (int *)*v7;
      v31 = ((char *)v28 - (_BYTE *)*v7) >> 2;
      v32 = v31 + 1;
      if ((unint64_t)(v31 + 1) >> 62)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v33 = v27 - (_QWORD)v30;
      if (v33 >> 1 > v32)
        v32 = v33 >> 1;
      if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFFCLL)
        v34 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v34 = v32;
      if (v34)
      {
        v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 248, v34);
        v30 = (int *)*((_QWORD *)this + 29);
        v28 = (int *)*((_QWORD *)this + 30);
      }
      else
      {
        v35 = 0;
      }
      v36 = (int *)&v35[4 * v31];
      *v36 = v26;
      v29 = v36 + 1;
      while (v28 != v30)
      {
        v37 = *--v28;
        *--v36 = v37;
      }
      *((_QWORD *)this + 29) = v36;
      *((_QWORD *)this + 30) = v29;
      *((_QWORD *)this + 31) = &v35[4 * v34];
      if (v30)
        operator delete(v30);
    }
    else
    {
      *v28 = v26;
      v29 = v28 + 1;
    }
    *((_QWORD *)this + 30) = v29;
    if (__p)
    {
      if (v39 != __p)
        v39 += ((_BYTE *)__p - v39 + 7) & 0xFFFFFFFFFFFFFFF8;
      operator delete(__p);
    }
  }
  *((_QWORD *)this + 27) = v10 - 1;
  *((_QWORD *)this + 28) = 0;
  std::valarray<double>::resize(v9, v10, 0.0);
  *((_OWORD *)this + 10) = xmmword_209D001F0;
  *((_DWORD *)this + 38) = 0;
  *((_DWORD *)this + 45) = 0;
}

void sub_209CC60F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, _QWORD *a10, uint64_t a11, void **a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *__p, uint64_t a18)
{
  _QWORD *v18;
  void **v19;
  uint64_t v20;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  std::valarray<double>::~valarray((uint64_t)(v18 + 63));
  std::valarray<double>::~valarray((uint64_t)(v18 + 61));
  std::valarray<double>::~valarray(a11);
  v22 = (void *)v18[54];
  if (v22)
  {
    v18[55] = v22;
    operator delete(v22);
  }
  std::valarray<double>::~valarray(v20);
  v23 = (void *)v18[48];
  if (v23)
  {
    v18[49] = v23;
    operator delete(v23);
  }
  v24 = (void *)v18[45];
  if (v24)
  {
    v18[46] = v24;
    operator delete(v24);
  }
  __p = v18 + 42;
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v25 = *a12;
  if (*a12)
  {
    v18[40] = v25;
    operator delete(v25);
  }
  __p = v18 + 35;
  std::vector<std::valarray<char>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  v26 = *v19;
  if (*v19)
  {
    v18[30] = v26;
    operator delete(v26);
  }
  if (v18[17])
  {
    if (*a10)
      MEMORY[0x20BD188CC](*a10, 0x1000C8000313F17);
  }
  CPModelClose(v18);
  _Unwind_Resume(a1);
}

void std::valarray<double>::resize(uint64_t a1, unint64_t a2, double a3)
{
  _BYTE *v6;
  _BYTE *v7;
  double *v8;

  v6 = *(_BYTE **)a1;
  if (v6)
  {
    v7 = *(_BYTE **)(a1 + 8);
    if (v7 != v6)
      *(_QWORD *)(a1 + 8) = &v7[(v6 - v7 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v6);
    *(_QWORD *)a1 = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v8 = (double *)operator new(8 * a2);
    *(_QWORD *)a1 = v8;
    do
    {
      *v8++ = a3;
      --a2;
    }
    while (a2);
    *(_QWORD *)(a1 + 8) = v8;
  }
}

CPMLLibSVM::Cache *CPMLLibSVM::Cache::Cache(CPMLLibSVM::Cache *this, int a2, uint64_t a3)
{
  void *v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  uint64_t v8;

  *(_DWORD *)this = a2;
  *((_QWORD *)this + 1) = a3;
  v4 = malloc_type_calloc(a2, 0x20uLL, 0x10A004007F91357uLL);
  v5 = *(int *)this;
  v6 = (*((_QWORD *)this + 1) >> 2) - 8 * (v5 & 0x7FFFFFFFFFFFFFFLL);
  v7 = v6 <= 2 * v5;
  v8 = 2 * v5;
  if (v7)
    v6 = v8;
  *((_QWORD *)this + 1) = v6;
  *((_QWORD *)this + 2) = v4;
  *((_QWORD *)this + 3) = (char *)this + 24;
  *((_QWORD *)this + 4) = (char *)this + 24;
  return this;
}

void CPMLLibSVM::Cache::~Cache(CPMLLibSVM::Cache *this)
{
  char *v2;
  uint64_t i;

  v2 = (char *)this + 24;
  for (i = *((_QWORD *)this + 4); (char *)i != v2; i = *(_QWORD *)(i + 8))
    free(*(void **)(i + 16));
  free(*((void **)this + 2));
}

void CPMLLibSVM::Cache::lru_delete(uint64_t a1, uint64_t *a2)
{
  uint64_t v2;

  v2 = *a2;
  *(_QWORD *)(v2 + 8) = a2[1];
  *(_QWORD *)a2[1] = v2;
}

uint64_t CPMLLibSVM::Cache::lru_insert(uint64_t a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 24);
  result = a1 + 24;
  *a2 = v3;
  a2[1] = result;
  *(_QWORD *)(v3 + 8) = a2;
  *(_QWORD *)a2[1] = a2;
  return result;
}

uint64_t CPMLLibSVM::Cache::get_data(CPMLLibSVM::Cache *this, int a2, float **a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;
  int v10;
  _DWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t *v14;
  uint64_t v15;
  void *v16;
  uint64_t v17;
  uint64_t v18;
  float *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  v4 = a4;
  v7 = *((_QWORD *)this + 2);
  v8 = a2;
  v9 = (uint64_t *)(v7 + 32 * a2);
  v11 = v9 + 3;
  v10 = *((_DWORD *)v9 + 6);
  if (v10)
  {
    v12 = *v9;
    *(_QWORD *)(v12 + 8) = v9[1];
    *(_QWORD *)v9[1] = v12;
  }
  v13 = (a4 - v10);
  if ((int)a4 <= v10)
  {
    v19 = *(float **)(v7 + 32 * a2 + 16);
  }
  else
  {
    if (*((_QWORD *)this + 1) < (uint64_t)v13)
    {
      do
      {
        v14 = (uint64_t *)*((_QWORD *)this + 4);
        v15 = *v14;
        *(_QWORD *)(v15 + 8) = v14[1];
        v16 = (void *)v14[2];
        *(_QWORD *)v14[1] = v15;
        free(v16);
        v17 = *((_QWORD *)this + 1) + *((int *)v14 + 6);
        *((_QWORD *)this + 1) = v17;
        v14[2] = 0;
        *((_DWORD *)v14 + 6) = 0;
      }
      while (v17 < v13);
    }
    v18 = v7 + 32 * v8;
    v19 = (float *)malloc_type_realloc(*(void **)(v18 + 16), 4 * (int)v4, 0x100004052888210uLL);
    *(_QWORD *)(v18 + 16) = v19;
    *((_QWORD *)this + 1) -= v13;
    v20 = *v11;
    *v11 = v4;
    v4 = v20;
  }
  v21 = v7 + 32 * v8;
  v22 = *((_QWORD *)this + 3);
  *(_QWORD *)(v21 + 8) = (char *)this + 24;
  *v9 = v22;
  *(_QWORD *)(v22 + 8) = v9;
  **(_QWORD **)(v21 + 8) = v9;
  *a3 = v19;
  return v4;
}

void CPMLLibSVM::Cache::swap_index(CPMLLibSVM::Cache *this, int a2, int a3)
{
  uint64_t v4;
  uint64_t *v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  _QWORD *v17;
  int v18;
  int v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v23;
  int v24;
  uint64_t v25;
  void *v26;

  if (a2 != a3)
  {
    v4 = *((_QWORD *)this + 2);
    v5 = (uint64_t *)(v4 + 32 * a2);
    if (*((_DWORD *)v5 + 6))
    {
      v6 = *v5;
      *(_QWORD *)(v6 + 8) = v5[1];
      *(_QWORD *)v5[1] = v6;
    }
    v7 = (uint64_t *)(v4 + 32 * a3);
    if (*((_DWORD *)v7 + 6))
    {
      v8 = *v7;
      *(_QWORD *)(v8 + 8) = v7[1];
      *(_QWORD *)v7[1] = v8;
    }
    v9 = v4 + 32 * a2;
    v10 = *(_QWORD *)(v9 + 16);
    *(_QWORD *)(v9 + 16) = v7[2];
    v7[2] = v10;
    v11 = *((_QWORD *)this + 2);
    v12 = v11 + 32 * a2;
    v13 = v11 + 32 * a3;
    v14 = *(_DWORD *)(v12 + 24);
    *(_DWORD *)(v12 + 24) = *(_DWORD *)(v13 + 24);
    *(_DWORD *)(v13 + 24) = v14;
    if (*(_DWORD *)(v12 + 24))
    {
      v15 = *((_QWORD *)this + 3);
      *(_QWORD *)v12 = v15;
      *(_QWORD *)(v12 + 8) = (char *)this + 24;
      *(_QWORD *)(v15 + 8) = v12;
      **(_QWORD **)(v12 + 8) = v12;
    }
    if (v14)
    {
      v16 = *((_QWORD *)this + 3);
      v17 = (_QWORD *)(v11 + 32 * a3);
      *v17 = v16;
      v17[1] = (char *)this + 24;
      *(_QWORD *)(v16 + 8) = v17;
      *(_QWORD *)v17[1] = v17;
    }
    if (a2 >= a3)
      v18 = a3;
    else
      v18 = a2;
    if (a2 <= a3)
      v19 = a3;
    else
      v19 = a2;
    v20 = (char *)this + 24;
    v21 = (char *)*((_QWORD *)this + 4);
    if (v21 != (char *)this + 24)
    {
      do
      {
        v22 = *((_DWORD *)v21 + 6);
        if (v22 > v18)
        {
          if (v22 <= v19)
          {
            v25 = *(_QWORD *)v21;
            *(_QWORD *)(v25 + 8) = *((_QWORD *)v21 + 1);
            v26 = (void *)*((_QWORD *)v21 + 2);
            **((_QWORD **)v21 + 1) = v25;
            free(v26);
            *((_QWORD *)this + 1) += *((int *)v21 + 6);
            *((_QWORD *)v21 + 2) = 0;
            *((_DWORD *)v21 + 6) = 0;
          }
          else
          {
            v23 = *((_QWORD *)v21 + 2);
            v24 = *(_DWORD *)(v23 + 4 * v18);
            *(_DWORD *)(v23 + 4 * v18) = *(_DWORD *)(v23 + 4 * v19);
            *(_DWORD *)(v23 + 4 * v19) = v24;
          }
        }
        v21 = (char *)*((_QWORD *)v21 + 1);
      }
      while (v21 != v20);
    }
  }
}

uint64_t CPMLLibSVM::Kernel::Kernel(uint64_t a1, int a2, const void *a3, uint64_t a4)
{
  uint64_t v7;
  void *v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  int v14;
  double v15;
  double *v16;
  int v17;

  *(_QWORD *)a1 = &unk_24C255EA0;
  v7 = *(_QWORD *)(a4 + 4);
  *(_QWORD *)(a1 + 40) = v7;
  *(_OWORD *)(a1 + 48) = *(_OWORD *)(a4 + 16);
  v8 = CPMLLibSVM::Kernel::kernel_linear;
  switch((int)v7)
  {
    case 0:
      goto LABEL_6;
    case 1:
      v8 = CPMLLibSVM::Kernel::kernel_poly;
      goto LABEL_6;
    case 2:
      v8 = CPMLLibSVM::Kernel::kernel_rbf;
      goto LABEL_6;
    case 3:
      v8 = CPMLLibSVM::Kernel::kernel_sigmoid;
      goto LABEL_6;
    case 4:
      v8 = CPMLLibSVM::Kernel::kernel_precomputed;
LABEL_6:
      *(_QWORD *)(a1 + 8) = v8;
      *(_QWORD *)(a1 + 16) = 0;
      break;
    default:
      break;
  }
  v9 = (void *)operator new[]();
  *(_QWORD *)(a1 + 24) = v9;
  memcpy(v9, a3, 8 * a2);
  if (*(_DWORD *)(a1 + 40) == 2)
  {
    v10 = operator new[]();
    *(_QWORD *)(a1 + 32) = v10;
    if (a2 >= 1)
    {
      v11 = 0;
      v12 = *(_QWORD *)(a1 + 24);
      do
      {
        v13 = *(double **)(v12 + 8 * v11);
        v14 = *(_DWORD *)v13;
        v15 = 0.0;
        if (*(_DWORD *)v13 != -1)
        {
          v16 = *(double **)(v12 + 8 * v11);
          v17 = *(_DWORD *)v13;
          do
          {
            if (v14 == v17)
            {
              v15 = v15 + v13[1] * v16[1];
              v13 += 2;
              v16 += 2;
            }
            else if (v14 > v17)
            {
              v16 += 2;
            }
            else
            {
              v13 += 2;
            }
            v14 = *(_DWORD *)v13;
            if (*(_DWORD *)v13 == -1)
              break;
            v17 = *(_DWORD *)v16;
          }
          while (*(_DWORD *)v16 != -1);
        }
        *(double *)(v10 + 8 * v11++) = v15;
      }
      while (v11 != a2);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 32) = 0;
  }
  return a1;
}

double CPMLLibSVM::Kernel::kernel_linear(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  uint64_t v3;
  double *v4;
  int v5;
  double *v6;
  double result;
  int v8;

  v3 = *((_QWORD *)this + 3);
  v4 = *(double **)(v3 + 8 * a2);
  v5 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 == -1)
    return 0.0;
  v6 = *(double **)(v3 + 8 * a3);
  result = 0.0;
  do
  {
    v8 = *(_DWORD *)v6;
    if (*(_DWORD *)v6 == -1)
      break;
    if (v5 == v8)
    {
      result = result + v4[1] * v6[1];
      v4 += 2;
      v6 += 2;
    }
    else if (v5 > v8)
    {
      v6 += 2;
    }
    else
    {
      v4 += 2;
    }
    v5 = *(_DWORD *)v4;
  }
  while (*(_DWORD *)v4 != -1);
  return result;
}

double CPMLLibSVM::Kernel::kernel_poly(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  uint64_t v3;
  double *v4;
  int v5;
  double *v6;
  double v7;
  int v8;
  int v9;
  double v10;
  double result;
  double v12;
  BOOL v13;

  v3 = *((_QWORD *)this + 3);
  v4 = *(double **)(v3 + 8 * a2);
  v5 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 == -1)
  {
    v7 = 0.0;
  }
  else
  {
    v6 = *(double **)(v3 + 8 * a3);
    v7 = 0.0;
    do
    {
      v8 = *(_DWORD *)v6;
      if (*(_DWORD *)v6 == -1)
        break;
      if (v5 == v8)
      {
        v7 = v7 + v4[1] * v6[1];
        v4 += 2;
        v6 += 2;
      }
      else if (v5 > v8)
      {
        v6 += 2;
      }
      else
      {
        v4 += 2;
      }
      v5 = *(_DWORD *)v4;
    }
    while (*(_DWORD *)v4 != -1);
  }
  v9 = *((_DWORD *)this + 11);
  if (v9 < 1)
    return 1.0;
  v10 = *((double *)this + 7) + *((double *)this + 6) * v7;
  result = 1.0;
  do
  {
    if ((v9 & 1) != 0)
      v12 = v10;
    else
      v12 = 1.0;
    result = result * v12;
    v10 = v10 * v10;
    v13 = v9 > 1;
    v9 = v9 >> 1;
  }
  while (v13);
  return result;
}

long double CPMLLibSVM::Kernel::kernel_rbf(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  double v5;
  double v6;
  double *v7;
  int v8;
  double *v9;
  double v10;
  int v11;

  v4 = *((_QWORD *)this + 3);
  v3 = *((_QWORD *)this + 4);
  v5 = *(double *)(v3 + 8 * a2);
  v6 = *(double *)(v3 + 8 * a3);
  v7 = *(double **)(v4 + 8 * a2);
  v8 = *(_DWORD *)v7;
  if (*(_DWORD *)v7 == -1)
  {
    v10 = 0.0;
  }
  else
  {
    v9 = *(double **)(v4 + 8 * a3);
    v10 = 0.0;
    do
    {
      v11 = *(_DWORD *)v9;
      if (*(_DWORD *)v9 == -1)
        break;
      if (v8 == v11)
      {
        v10 = v10 + v7[1] * v9[1];
        v7 += 2;
        v9 += 2;
      }
      else if (v8 > v11)
      {
        v9 += 2;
      }
      else
      {
        v7 += 2;
      }
      v8 = *(_DWORD *)v7;
    }
    while (*(_DWORD *)v7 != -1);
  }
  return exp(-(*((double *)this + 6) * (v5 + v6 + v10 * -2.0)));
}

long double CPMLLibSVM::Kernel::kernel_sigmoid(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  uint64_t v3;
  double *v4;
  int v5;
  double *v6;
  double v7;
  int v8;

  v3 = *((_QWORD *)this + 3);
  v4 = *(double **)(v3 + 8 * a2);
  v5 = *(_DWORD *)v4;
  if (*(_DWORD *)v4 == -1)
  {
    v7 = 0.0;
  }
  else
  {
    v6 = *(double **)(v3 + 8 * a3);
    v7 = 0.0;
    do
    {
      v8 = *(_DWORD *)v6;
      if (*(_DWORD *)v6 == -1)
        break;
      if (v5 == v8)
      {
        v7 = v7 + v4[1] * v6[1];
        v4 += 2;
        v6 += 2;
      }
      else if (v5 > v8)
      {
        v6 += 2;
      }
      else
      {
        v4 += 2;
      }
      v5 = *(_DWORD *)v4;
    }
    while (*(_DWORD *)v4 != -1);
  }
  return tanh(*((double *)this + 7) + *((double *)this + 6) * v7);
}

double CPMLLibSVM::Kernel::kernel_precomputed(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  return *(double *)(*(_QWORD *)(*((_QWORD *)this + 3) + 8 * a2)
                   + 16 * (int)*(double *)(*(_QWORD *)(*((_QWORD *)this + 3) + 8 * a3) + 8)
                   + 8);
}

double *CPMLLibSVM::Kernel::dot(double *result, double *a2)
{
  int v2;
  double v3;
  int v4;

  v2 = *(_DWORD *)result;
  v3 = 0.0;
  while (v2 != -1)
  {
    v4 = *(_DWORD *)a2;
    if (*(_DWORD *)a2 == -1)
      break;
    if (v2 == v4)
    {
      v3 = v3 + result[1] * a2[1];
      result += 2;
      a2 += 2;
    }
    else if (v2 > v4)
    {
      a2 += 2;
    }
    else
    {
      result += 2;
    }
    v2 = *(_DWORD *)result;
  }
  return result;
}

void CPMLLibSVM::Kernel::~Kernel(CPMLLibSVM::Kernel *this)
{
  uint64_t v2;
  uint64_t v3;

  *(_QWORD *)this = &unk_24C255EA0;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x20BD188CC](v2, 0x60C8044C4A2DFLL);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8000313F17);
}

double CPMLLibSVM::Kernel::k_function(double *a1, double *a2, uint64_t a3)
{
  double result;
  int v4;
  int v5;
  int v6;
  int v7;
  int v8;
  double v9;
  int v10;
  int v11;
  double v12;
  double v13;
  BOOL v14;

  result = 0.0;
  switch(*(_DWORD *)(a3 + 4))
  {
    case 0:
      while (1)
      {
        v4 = *(_DWORD *)a1;
        if (*(_DWORD *)a1 == -1)
          break;
        v5 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 == -1)
          break;
        if (v4 == v5)
        {
          result = result + a1[1] * a2[1];
          a1 += 2;
          a2 += 2;
        }
        else if (v4 > v5)
        {
          a2 += 2;
        }
        else
        {
          a1 += 2;
        }
      }
      break;
    case 1:
      while (1)
      {
        v6 = *(_DWORD *)a1;
        if (*(_DWORD *)a1 == -1)
          break;
        v7 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 == -1)
          break;
        if (v6 == v7)
        {
          result = result + a1[1] * a2[1];
          a1 += 2;
          a2 += 2;
        }
        else if (v6 > v7)
        {
          a2 += 2;
        }
        else
        {
          a1 += 2;
        }
      }
      v11 = *(_DWORD *)(a3 + 8);
      if (v11 < 1)
      {
        result = 1.0;
      }
      else
      {
        v12 = *(double *)(a3 + 24) + *(double *)(a3 + 16) * result;
        result = 1.0;
        do
        {
          if ((v11 & 1) != 0)
            v13 = v12;
          else
            v13 = 1.0;
          result = result * v13;
          v12 = v12 * v12;
          v14 = v11 >= 2;
          v11 = v11 >> 1;
        }
        while (v14);
      }
      break;
    case 3:
      v8 = *(_DWORD *)a1;
      v9 = 0.0;
      while (v8 != -1)
      {
        v10 = *(_DWORD *)a2;
        if (*(_DWORD *)a2 == -1)
          break;
        if (v8 == v10)
        {
          v9 = v9 + a1[1] * a2[1];
          a1 += 2;
          a2 += 2;
        }
        else if (v8 > v10)
        {
          a2 += 2;
        }
        else
        {
          a1 += 2;
        }
        v8 = *(_DWORD *)a1;
      }
      result = tanh(*(double *)(a3 + 24) + *(double *)(a3 + 16) * v9);
      break;
    case 4:
      result = a1[2 * (int)a2[1] + 1];
      break;
    default:
      return result;
  }
  return result;
}

void CPMLLibSVM::Kernel::k_function_rbf(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t *a26,uint64_t a27,unint64_t a28,uint64_t a29,uint64_t *a30,uint64_t a31,unint64_t a32)
{
  signed int v32;
  unint64_t v33;
  size_t v34;
  qos_class_t v35;
  NSObject *global_queue;
  _QWORD var10[4];

  v32 = *(_DWORD *)(a2 + 108);
  v33 = v32;
  if (libsvm_cpu_count < v32)
    v32 = libsvm_cpu_count;
  v34 = v32;
  a29 = 0;
  a30 = &a29;
  a31 = 0x2000000000;
  a32 = v33 / v32;
  a25 = 0;
  a26 = &a25;
  a27 = 0x2000000000;
  a28 = v33 % v32;
  var10[0] = MEMORY[0x24BDAC760];
  var10[1] = 0x40000000;
  var10[2] = ___ZN10CPMLLibSVM6Kernel14k_function_rbfEPK8svm_nodePK9svm_modelPd_block_invoke;
  var10[3] = &unk_24C256110;
  if (v32 == 1)
  {
    ___ZN10CPMLLibSVM6Kernel14k_function_rbfEPK8svm_nodePK9svm_modelPd_block_invoke((uint64_t)var10, 0);
  }
  else
  {
    v35 = qos_class_self();
    global_queue = dispatch_get_global_queue(v35, 0);
    dispatch_apply(v34, global_queue, var10);
  }
  _Block_object_dispose(&a25, 8);
  _Block_object_dispose(&a29, 8);
}

void sub_209CC6D90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,char a29,uint64_t a30,uint64_t a31,uint64_t a32,char a33)
{
  _Block_object_dispose(&a29, 8);
  _Block_object_dispose(&a33, 8);
  _Unwind_Resume(a1);
}

void ___ZN10CPMLLibSVM6Kernel14k_function_rbfEPK8svm_nodePK9svm_modelPd_block_invoke(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  float64x2_t *v9;
  float64x2_t v10;
  int8x16_t v11;
  float64x2_t v12;
  float64x2_t v13;
  float64x2_t v14;
  float64x2_t v15;
  float64x2_t v16;
  float64x2_t v17;
  float64x2_t v18;
  float64x2_t v19;
  int8x16_t v20;
  int8x16_t v21;
  float64x2_t v27;
  float64x2_t v28;
  float64x2_t v29;
  uint64_t v30;
  uint64_t v31;
  double *v32;
  int v33;
  unint64_t v34;
  double *v35;
  double v36;
  int v37;
  double *v38;
  int v39;
  double v40;
  double *v41;
  int v42;
  double *v43;
  int v44;
  int8x16_t v45;
  int8x16_t v46;
  int8x16_t v47;
  int8x16_t v48;
  float64x2_t v49;
  float64x2_t v50;
  float64x2_t v51;
  float64x2_t v52;
  float64x2_t v53;
  float64x2_t v54;
  float64x2_t v55;
  float64x2_t v56;
  float64x2_t v57;
  float64x2_t v58;
  float64x2_t v59;
  float64x2_t v60;
  float64x2_t v61;
  float64x2_t v62;
  int64x2_t v63;
  int64x2_t v64;
  int64x2_t v65;
  int64x2_t v66;
  float64x2_t v67;
  int8x16_t v68;
  int8x16_t v69;
  int8x16_t v70;
  float64x2_t v71;
  float64x2_t v72;
  float64x2_t v73;
  unint64_t v74;
  double *v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  uint64_t v79;
  double *v80;
  double v81;
  int v82;
  double *v83;
  int v84;
  double v85;
  double *v86;
  int v87;
  double *v88;
  int v89;
  float64x2_t v90;
  float64x2_t v91;
  float64x2_t v92;
  float64x2_t v93;

  v2 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  v3 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
  v4 = a2 - v3;
  if (a2 < v3)
    v4 = 0;
  v5 = (v2 + 1) * a2 - v4;
  if (v3 <= a2)
    v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  else
    v6 = v2 + 1;
  v7 = v6 + v5;
  if (v5 + 8 > v6 + v5)
  {
    v8 = (v2 + 1) * a2 - v4;
    goto LABEL_30;
  }
  v9 = (float64x2_t *)(*(_QWORD *)(a1 + 48) + 8 * v5);
  v10 = 0uLL;
  v11 = (int8x16_t)vdupq_n_s64(0x7FF0000000000000uLL);
  v12 = (float64x2_t)vdupq_n_s64(0xC086232BDD7ABCD4);
  v13 = (float64x2_t)vdupq_n_s64(0x40671547652B82FDuLL);
  v14 = (float64x2_t)vdupq_n_s64(0xBF762E4000000000);
  v15 = (float64x2_t)vdupq_n_s64(0xBE47F7D1CF79ABCALL);
  v16 = (float64x2_t)vdupq_n_s64(0x3F8111116E99AC77uLL);
  v17 = (float64x2_t)vdupq_n_s64(0x3FA55555CA407CCBuLL);
  v18 = (float64x2_t)vdupq_n_s64(0x3FC55555555553F0uLL);
  v19 = (float64x2_t)vdupq_n_s64(0x3FDFFFFFFFFFFE1FuLL);
  v20 = (int8x16_t)vdupq_n_s64(0x7FuLL);
  v21 = (int8x16_t)vdupq_n_s64(0xFFF0000000000000);
  __asm { FMOV            V20.2D, #1.0 }
  v27 = 0uLL;
  v28 = 0uLL;
  v29 = 0uLL;
  do
  {
    v30 = 0;
    v31 = *(_QWORD *)(a1 + 56);
    v32 = *(double **)(a1 + 128);
    v33 = *(_DWORD *)v32;
    v8 = v5 + 8;
    v34 = v5;
    do
    {
      v35 = *(double **)(v31 + 8 * v34);
      v36 = 0.0;
      if (v33 != -1)
      {
        v37 = v33;
        v38 = v32;
        while (1)
        {
          v39 = *(_DWORD *)v35;
          if (*(_DWORD *)v35 == -1)
            goto LABEL_22;
          if (v37 == v39)
          {
            v40 = v38[1] - v35[1];
            v36 = v36 + v40 * v40;
            v38 += 2;
          }
          else
          {
            if (v37 <= v39)
            {
              v36 = v36 + v38[1] * v38[1];
              v38 += 2;
              goto LABEL_19;
            }
            v36 = v36 + v35[1] * v35[1];
          }
          v35 += 2;
LABEL_19:
          v37 = *(_DWORD *)v38;
          if (*(_DWORD *)v38 == -1)
            goto LABEL_25;
        }
      }
      v38 = v32;
LABEL_22:
      if (*(_DWORD *)v38 != -1)
      {
        v41 = v38 + 2;
        do
        {
          v36 = v36 + *(v41 - 1) * *(v41 - 1);
          v42 = *(_DWORD *)v41;
          v41 += 2;
        }
        while (v42 != -1);
      }
LABEL_25:
      if (*(_DWORD *)v35 != -1)
      {
        v43 = v35 + 2;
        do
        {
          v36 = v36 + *(v43 - 1) * *(v43 - 1);
          v44 = *(_DWORD *)v43;
          v43 += 2;
        }
        while (v44 != -1);
      }
      v90 = v10;
      v91 = v27;
      v92 = v28;
      v93 = v29;
      v90.f64[v30 & 7] = v36;
      v28 = v92;
      v29 = v93;
      ++v30;
      ++v34;
      v10 = v90;
      v27 = v91;
    }
    while (v30 != 8);
    v45 = (int8x16_t)vmulq_f64(v90, *(float64x2_t *)(a1 + 64));
    v46 = (int8x16_t)vmulq_f64(v91, *(float64x2_t *)(a1 + 80));
    v47 = (int8x16_t)vmulq_f64(v92, *(float64x2_t *)(a1 + 96));
    v48 = (int8x16_t)vmulq_f64(v93, *(float64x2_t *)(a1 + 112));
    v49 = (float64x2_t)vbicq_s8(v48, (int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v48, v11)));
    v50 = (float64x2_t)vbicq_s8(v47, (int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v47, v11)));
    v51 = vmaxq_f64((float64x2_t)vbicq_s8(v45, (int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v45, v11))), v12);
    v52 = vmaxq_f64((float64x2_t)vbicq_s8(v46, (int8x16_t)vceqzq_s64((int64x2_t)vandq_s8(v46, v11))), v12);
    v53 = vmaxq_f64(v50, v12);
    v54 = vmaxq_f64(v49, v12);
    v55 = vrndmq_f64(vmulq_f64(v51, v13));
    v56 = vrndmq_f64(vmulq_f64(v52, v13));
    v57 = vrndmq_f64(vmulq_f64(v53, v13));
    v58 = vrndmq_f64(vmulq_f64(v54, v13));
    v59 = vmlaq_f64(vmlaq_f64(v51, v14, v55), v15, v55);
    v60 = vmlaq_f64(vmlaq_f64(v52, v14, v56), v15, v56);
    v61 = vmlaq_f64(vmlaq_f64(v53, v14, v57), v15, v57);
    v62 = vmlaq_f64(vmlaq_f64(v54, v14, v58), v15, v58);
    v63 = vcvtq_s64_f64(v55);
    v64 = vcvtq_s64_f64(v56);
    v65 = vcvtq_s64_f64(v57);
    v66 = vcvtq_s64_f64(v58);
    v67 = (float64x2_t)vandq_s8((int8x16_t)v66, v20);
    v68 = vandq_s8((int8x16_t)v65, v20);
    v69 = vandq_s8((int8x16_t)v64, v20);
    v70 = vandq_s8((int8x16_t)v63, v20);
    *(_QWORD *)&v67.f64[0] = _ZZL5vexp8Dv8_dE9exp2table[*(_QWORD *)&v67.f64[0]];
    *(_QWORD *)&v67.f64[1] = _ZZL5vexp8Dv8_dE9exp2table[*(_QWORD *)&v67.f64[1]];
    *(_QWORD *)&v71.f64[0] = _ZZL5vexp8Dv8_dE9exp2table[v68.i64[0]];
    *(_QWORD *)&v71.f64[1] = _ZZL5vexp8Dv8_dE9exp2table[v68.i64[1]];
    *(_QWORD *)&v72.f64[0] = _ZZL5vexp8Dv8_dE9exp2table[v69.i64[0]];
    *(_QWORD *)&v72.f64[1] = _ZZL5vexp8Dv8_dE9exp2table[v69.i64[1]];
    *(_QWORD *)&v73.f64[0] = _ZZL5vexp8Dv8_dE9exp2table[v70.i64[0]];
    *(_QWORD *)&v73.f64[1] = _ZZL5vexp8Dv8_dE9exp2table[v70.i64[1]];
    *v9 = vmulq_f64(vmlaq_f64(v73, v73, vmulq_f64(v59, vmlaq_f64(_Q20, vmlaq_f64(v19, vmlaq_f64(v18, vmlaq_f64(v17, v16, v59), v59), v59), v59))), (float64x2_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vshlq_n_s64(v63, 0x2DuLL), v21), (int64x2_t)_Q20));
    v9[1] = vmulq_f64(vmlaq_f64(v72, v72, vmulq_f64(v60, vmlaq_f64(_Q20, vmlaq_f64(v19, vmlaq_f64(v18, vmlaq_f64(v17, v16, v60), v60), v60), v60))), (float64x2_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vshlq_n_s64(v64, 0x2DuLL), v21), (int64x2_t)_Q20));
    v9[2] = vmulq_f64(vmlaq_f64(v71, v71, vmulq_f64(v61, vmlaq_f64(_Q20, vmlaq_f64(v19, vmlaq_f64(v18, vmlaq_f64(v17, v16, v61), v61), v61), v61))), (float64x2_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vshlq_n_s64(v65, 0x2DuLL), v21), (int64x2_t)_Q20));
    v9[3] = vmulq_f64(vmlaq_f64(v67, v67, vmulq_f64(v62, vmlaq_f64(_Q20, vmlaq_f64(v19, vmlaq_f64(v18, vmlaq_f64(v17, v16, v62), v62), v62), v62))), (float64x2_t)vaddq_s64((int64x2_t)vandq_s8((int8x16_t)vshlq_n_s64(v66, 0x2DuLL), v21), (int64x2_t)_Q20));
    v9 += 4;
    v74 = v5 + 16;
    v5 += 8;
  }
  while (v74 <= v7);
LABEL_30:
  if (v8 < v7)
  {
    v75 = *(double **)(a1 + 128);
    v76 = *(_QWORD *)(a1 + 136);
    v77 = *(_DWORD *)v75;
    v79 = *(_QWORD *)(a1 + 48);
    v78 = *(_QWORD *)(a1 + 56);
    while (1)
    {
      v80 = *(double **)(v78 + 8 * v8);
      v81 = 0.0;
      if (v77 != -1)
        break;
      v83 = v75;
LABEL_44:
      if (*(_DWORD *)v83 != -1)
      {
        v86 = v83 + 2;
        do
        {
          v81 = v81 + *(v86 - 1) * *(v86 - 1);
          v87 = *(_DWORD *)v86;
          v86 += 2;
        }
        while (v87 != -1);
      }
LABEL_47:
      if (*(_DWORD *)v80 != -1)
      {
        v88 = v80 + 2;
        do
        {
          v81 = v81 + *(v88 - 1) * *(v88 - 1);
          v89 = *(_DWORD *)v88;
          v88 += 2;
        }
        while (v89 != -1);
      }
      *(long double *)(v79 + 8 * v8++) = exp(-(*(double *)(v76 + 16) * v81));
      if (v8 >= v7)
        return;
    }
    v82 = v77;
    v83 = v75;
    while (2)
    {
      v84 = *(_DWORD *)v80;
      if (*(_DWORD *)v80 == -1)
        goto LABEL_44;
      if (v82 == v84)
      {
        v85 = v83[1] - v80[1];
        v81 = v81 + v85 * v85;
        v83 += 2;
        goto LABEL_39;
      }
      if (v82 <= v84)
      {
        v81 = v81 + v83[1] * v83[1];
        v83 += 2;
      }
      else
      {
        v81 = v81 + v80[1] * v80[1];
LABEL_39:
        v80 += 2;
      }
      v82 = *(_DWORD *)v83;
      if (*(_DWORD *)v83 == -1)
        goto LABEL_47;
      continue;
    }
  }
}

double CPMLLibSVM::Solver::swap_index(CPMLLibSVM::Solver *this, int a2, int a3)
{
  uint64_t v6;
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double result;

  (*(void (**)(_QWORD))(**((_QWORD **)this + 6) + 16))(*((_QWORD *)this + 6));
  v6 = *((_QWORD *)this + 2);
  v7 = *(_BYTE *)(v6 + a2);
  *(_BYTE *)(v6 + a2) = *(_BYTE *)(v6 + a3);
  *(_BYTE *)(v6 + a3) = v7;
  v8 = *((_QWORD *)this + 3);
  v9 = *((_QWORD *)this + 4);
  v10 = *(_QWORD *)(v8 + 8 * a2);
  *(_QWORD *)(v8 + 8 * a2) = *(_QWORD *)(v8 + 8 * a3);
  *(_QWORD *)(v8 + 8 * a3) = v10;
  LOBYTE(v8) = *(_BYTE *)(v9 + a2);
  *(_BYTE *)(v9 + a2) = *(_BYTE *)(v9 + a3);
  *(_BYTE *)(v9 + a3) = v8;
  v11 = *((_QWORD *)this + 5);
  v12 = *(_QWORD *)(v11 + 8 * a2);
  *(_QWORD *)(v11 + 8 * a2) = *(_QWORD *)(v11 + 8 * a3);
  *(_QWORD *)(v11 + 8 * a3) = v12;
  v13 = *((_QWORD *)this + 11);
  v14 = *((_QWORD *)this + 12);
  v15 = *(_QWORD *)(v13 + 8 * a2);
  *(_QWORD *)(v13 + 8 * a2) = *(_QWORD *)(v13 + 8 * a3);
  *(_QWORD *)(v13 + 8 * a3) = v15;
  LODWORD(v13) = *(_DWORD *)(v14 + 4 * a2);
  *(_DWORD *)(v14 + 4 * a2) = *(_DWORD *)(v14 + 4 * a3);
  *(_DWORD *)(v14 + 4 * a3) = v13;
  v16 = *((_QWORD *)this + 13);
  result = *(double *)(v16 + 8 * a2);
  *(_QWORD *)(v16 + 8 * a2) = *(_QWORD *)(v16 + 8 * a3);
  *(double *)(v16 + 8 * a3) = result;
  return result;
}

uint64_t CPMLLibSVM::Solver::reconstruct_gradient(uint64_t this)
{
  uint64_t v1;
  int v2;
  uint64_t v3;
  double *v4;
  double *v5;
  double *v6;
  uint64_t v7;
  double v8;
  double v9;
  double v10;
  int v11;
  unsigned __int8 *v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  double v21;
  float *v22;
  double *v23;
  uint64_t v24;
  float v25;

  v1 = *(unsigned int *)(this + 8);
  v2 = *(_DWORD *)(this + 112);
  if ((_DWORD)v1 != v2)
  {
    v3 = this;
    if ((int)v1 < v2)
    {
      v4 = (double *)(*(_QWORD *)(this + 104) + 8 * (int)v1);
      v5 = (double *)(*(_QWORD *)(this + 88) + 8 * (int)v1);
      v6 = (double *)(*(_QWORD *)(this + 24) + 8 * (int)v1);
      v7 = v2 - (uint64_t)(int)v1;
      do
      {
        v8 = *v4++;
        v9 = v8;
        v10 = *v5++;
        *v6++ = v9 + v10;
        --v7;
      }
      while (v7);
    }
    if ((int)v1 < 1)
    {
      v11 = 0;
    }
    else
    {
      v11 = 0;
      v12 = *(unsigned __int8 **)(this + 32);
      v13 = v1;
      do
      {
        v14 = *v12++;
        if (v14 == 2)
          ++v11;
        --v13;
      }
      while (v13);
    }
    if ((int)v1 > 2 * v11)
    {
      this = info("\nWARNING: using -h 0 may be faster\n");
      v2 = *(_DWORD *)(v3 + 112);
      v1 = *(unsigned int *)(v3 + 8);
    }
    if (v2 * v11 <= 2 * (int)v1 * (v2 - (int)v1))
    {
      if ((int)v1 >= 1)
      {
        v19 = 0;
        do
        {
          if (*(_BYTE *)(*(_QWORD *)(v3 + 32) + v19) == 2)
          {
            this = (***(uint64_t (****)(_QWORD, uint64_t))(v3 + 48))(*(_QWORD *)(v3 + 48), v19);
            LODWORD(v1) = *(_DWORD *)(v3 + 8);
            v20 = *(_DWORD *)(v3 + 112);
            if ((int)v1 < v20)
            {
              v21 = *(double *)(*(_QWORD *)(v3 + 40) + 8 * v19);
              v22 = (float *)(this + 4 * (int)v1);
              v23 = (double *)(*(_QWORD *)(v3 + 24) + 8 * (int)v1);
              v24 = v20 - (uint64_t)(int)v1;
              do
              {
                v25 = *v22++;
                *v23 = *v23 + v21 * v25;
                ++v23;
                --v24;
              }
              while (v24);
            }
          }
          ++v19;
        }
        while (v19 < (int)v1);
      }
    }
    else if (v2 > (int)v1)
    {
      v15 = (int)v1;
      v16 = v1;
      do
      {
        this = (***(uint64_t (****)(_QWORD, uint64_t, uint64_t))(v3 + 48))(*(_QWORD *)(v3 + 48), v15, v16);
        v16 = *(unsigned int *)(v3 + 8);
        if ((int)v16 >= 1)
        {
          v17 = 0;
          v18 = *(_QWORD *)(v3 + 32);
          do
          {
            if (*(_BYTE *)(v18 + v17) == 2)
              *(double *)(*(_QWORD *)(v3 + 24) + 8 * v15) = *(double *)(*(_QWORD *)(v3 + 24) + 8 * v15)
                                                          + *(double *)(*(_QWORD *)(v3 + 40) + 8 * v17)
                                                          * *(float *)(this + 4 * v17);
            ++v17;
          }
          while (v16 != v17);
        }
        ++v15;
      }
      while (v15 < *(int *)(v3 + 112));
    }
  }
  return this;
}

uint64_t CPMLLibSVM::Solver::Solve(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, const void *a5, _QWORD *a6, uint64_t a7, int a8, double a9, double a10, double a11)
{
  void *v20;
  void *v21;
  void *v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  _QWORD *v30;
  uint64_t *v31;
  _QWORD *v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  float *v37;
  double v38;
  double *v39;
  uint64_t v40;
  float *v41;
  float v42;
  uint64_t v43;
  double *v44;
  uint64_t v45;
  double *v46;
  float v47;
  unsigned int v48;
  int v49;
  int v50;
  int v51;
  float *v52;
  float *v53;
  uint64_t v54;
  uint64_t v55;
  double *v56;
  int v57;
  uint64_t v58;
  double v59;
  uint64_t v60;
  int v61;
  uint64_t v62;
  double v63;
  uint64_t v64;
  double v65;
  double v66;
  uint64_t v67;
  double v68;
  double v69;
  double v70;
  double v71;
  double v72;
  double v73;
  double v74;
  double v75;
  double v76;
  double v77;
  double v78;
  double v79;
  double v80;
  double v81;
  double v82;
  uint64_t v83;
  double v84;
  double v85;
  float v86;
  double v87;
  float v88;
  uint64_t v89;
  int v90;
  int v91;
  uint64_t v92;
  double v93;
  char v94;
  double v95;
  uint64_t v96;
  uint64_t v97;
  char v98;
  float *v99;
  double *v100;
  uint64_t v101;
  float v102;
  double *v103;
  uint64_t v104;
  float v105;
  float *v106;
  double *v107;
  uint64_t v108;
  float v109;
  double *v110;
  uint64_t v111;
  float v112;
  double *v113;
  double *v114;
  double v115;
  uint64_t v116;
  double *v117;
  double v118;
  double v119;
  double v120;
  double v121;
  double v122;
  uint64_t *v123;
  int *v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t result;
  _QWORD *v135;
  int v137;
  unsigned int v139;
  uint64_t v140;

  *(_DWORD *)(a1 + 112) = a2;
  *(_QWORD *)(a1 + 48) = a3;
  *(_QWORD *)(a1 + 56) = (*(uint64_t (**)(uint64_t))(*(_QWORD *)a3 + 8))(a3);
  v20 = (void *)operator new[]();
  *(_QWORD *)(a1 + 88) = v20;
  memcpy(v20, a4, 8 * (int)a2);
  v21 = (void *)operator new[]();
  *(_QWORD *)(a1 + 16) = v21;
  memcpy(v21, a5, (int)a2);
  v22 = (void *)operator new[]();
  *(_QWORD *)(a1 + 40) = v22;
  v135 = a6;
  memcpy(v22, a6, 8 * (int)a2);
  *(double *)(a1 + 72) = a9;
  *(double *)(a1 + 80) = a10;
  *(double *)(a1 + 64) = a11;
  *(_BYTE *)(a1 + 116) = 0;
  *(_QWORD *)(a1 + 32) = operator new[]();
  v23 = a2;
  if ((int)a2 >= 1)
  {
    v24 = 0;
    do
    {
      v25 = *(double *)(*(_QWORD *)(a1 + 40) + 8 * v24);
      if (*(char *)(*(_QWORD *)(a1 + 16) + v24) <= 0)
        v26 = 80;
      else
        v26 = 72;
      if (v25 >= *(double *)(a1 + v26))
      {
        *(_BYTE *)(*(_QWORD *)(a1 + 32) + v24) = 1;
      }
      else
      {
        v27 = *(_QWORD *)(a1 + 32);
        if (v25 <= 0.0)
          *(_BYTE *)(v27 + v24) = 0;
        else
          *(_BYTE *)(v27 + v24) = 2;
      }
      ++v24;
    }
    while (a2 != v24);
  }
  v28 = operator new[]();
  *(_QWORD *)(a1 + 96) = v28;
  if ((int)a2 >= 1)
  {
    v29 = 0;
    do
    {
      *(_DWORD *)(v28 + 4 * v29) = v29;
      ++v29;
    }
    while (a2 != v29);
  }
  *(_DWORD *)(a1 + 8) = a2;
  *(_QWORD *)(a1 + 24) = operator new[]();
  v30 = (_QWORD *)operator new[]();
  *(_QWORD *)(a1 + 104) = v30;
  if ((int)a2 >= 1)
  {
    v31 = *(uint64_t **)(a1 + 88);
    v32 = *(_QWORD **)(a1 + 24);
    v33 = a2;
    do
    {
      v34 = *v31++;
      *v32++ = v34;
      *v30++ = 0;
      --v33;
    }
    while (v33);
    v35 = 0;
    v36 = *(_QWORD *)(a1 + 32);
    do
    {
      if (*(_BYTE *)(v36 + v35))
      {
        v37 = (float *)(**(uint64_t (***)(uint64_t, uint64_t, uint64_t))a3)(a3, v35, a2);
        v38 = *(double *)(*(_QWORD *)(a1 + 40) + 8 * v35);
        v39 = *(double **)(a1 + 24);
        v40 = a2;
        v41 = v37;
        do
        {
          v42 = *v41++;
          *v39 = *v39 + v38 * v42;
          ++v39;
          --v40;
        }
        while (v40);
        v36 = *(_QWORD *)(a1 + 32);
        if (*(_BYTE *)(v36 + v35) == 1)
        {
          v43 = *(_QWORD *)(a1 + 16);
          v44 = *(double **)(a1 + 104);
          v45 = a2;
          do
          {
            if (*(char *)(v43 + v35) <= 0)
              v46 = (double *)(a1 + 80);
            else
              v46 = (double *)(a1 + 72);
            v47 = *v37++;
            *v44 = *v44 + *v46 * v47;
            ++v44;
            --v45;
          }
          while (v45);
        }
      }
      ++v35;
    }
    while (v35 != a2);
  }
  v48 = 0;
  v49 = 100 * a2;
  if (100 * (int)a2 <= 10000000)
    v49 = 10000000;
  if ((int)a2 > 21474836)
    v49 = 0x7FFFFFFF;
  v139 = v49;
  if ((int)a2 >= 1000)
    v50 = 1000;
  else
    v50 = a2;
  v137 = v50;
  v51 = v50 + 1;
  while (1)
  {
    if (!--v51)
    {
      if (a8)
        (*(void (**)(uint64_t))(*(_QWORD *)a1 + 32))(a1);
      info(".");
      v51 = v137;
    }
    v140 = 0;
    if ((*(unsigned int (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 16))(a1, (char *)&v140 + 4, &v140))
    {
      break;
    }
LABEL_44:
    v52 = (float *)(**(uint64_t (***)(uint64_t, _QWORD, _QWORD))a3)(a3, HIDWORD(v140), *(unsigned int *)(a1 + 8));
    v53 = (float *)(**(uint64_t (***)(uint64_t, _QWORD, _QWORD))a3)(a3, v140, *(unsigned int *)(a1 + 8));
    v54 = SHIDWORD(v140);
    v55 = *(_QWORD *)(a1 + 16);
    v56 = *(double **)(a1 + 24);
    v57 = *(unsigned __int8 *)(v55 + SHIDWORD(v140));
    if ((char)v57 <= 0)
      v58 = 80;
    else
      v58 = 72;
    v59 = *(double *)(a1 + v58);
    v60 = (int)v140;
    v61 = *(unsigned __int8 *)(v55 + (int)v140);
    if ((char)v61 <= 0)
      v62 = 80;
    else
      v62 = 72;
    v63 = *(double *)(a1 + v62);
    v64 = *(_QWORD *)(a1 + 56);
    v65 = *(double *)(v64 + 8 * SHIDWORD(v140));
    v66 = *(double *)(v64 + 8 * (int)v140);
    v67 = *(_QWORD *)(a1 + 40);
    v68 = *(double *)(v67 + 8 * SHIDWORD(v140));
    v69 = *(double *)(v67 + 8 * (int)v140);
    v70 = v65 + v66;
    v71 = (float)(v52[(int)v140] + v52[(int)v140]);
    v72 = v56[SHIDWORD(v140)];
    if (v57 == v61)
    {
      v73 = v70 - v71;
      if (v73 <= 0.0)
        v73 = 1.0e-12;
      v74 = (v72 - v56[(int)v140]) / v73;
      v75 = v68 + v69;
      *(double *)(v67 + 8 * SHIDWORD(v140)) = v68 - v74;
      v76 = *(double *)(v67 + 8 * v60) + v74;
      *(double *)(v67 + 8 * v60) = v76;
      if (v68 + v69 <= v59)
      {
        if (v76 < 0.0)
        {
          *(_QWORD *)(v67 + 8 * v60) = 0;
          *(double *)(v67 + 8 * v54) = v75;
        }
      }
      else if (*(double *)(v67 + 8 * v54) > v59)
      {
        *(double *)(v67 + 8 * v54) = v59;
        *(double *)(v67 + 8 * v60) = v75 - v59;
      }
      if (v75 <= v63)
      {
        if (*(double *)(v67 + 8 * v54) >= 0.0)
          goto LABEL_77;
        *(_QWORD *)(v67 + 8 * v54) = 0;
        goto LABEL_73;
      }
      if (*(double *)(v67 + 8 * v60) <= v63)
        goto LABEL_77;
      *(double *)(v67 + 8 * v60) = v63;
      v81 = v75 - v63;
      goto LABEL_76;
    }
    v77 = v70 + v71;
    if (v77 <= 0.0)
      v77 = 1.0e-12;
    v78 = (-v72 - v56[(int)v140]) / v77;
    v79 = v68 - v69;
    *(double *)(v67 + 8 * SHIDWORD(v140)) = v68 + v78;
    v80 = *(double *)(v67 + 8 * v60) + v78;
    *(double *)(v67 + 8 * v60) = v80;
    if (v68 - v69 <= 0.0)
    {
      if (*(double *)(v67 + 8 * v54) < 0.0)
      {
        *(_QWORD *)(v67 + 8 * v54) = 0;
        *(double *)(v67 + 8 * v60) = -v79;
      }
    }
    else if (v80 < 0.0)
    {
      *(_QWORD *)(v67 + 8 * v60) = 0;
      *(double *)(v67 + 8 * v54) = v79;
    }
    if (v79 > v59 - v63)
    {
      if (*(double *)(v67 + 8 * v54) <= v59)
        goto LABEL_77;
      *(double *)(v67 + 8 * v54) = v59;
      v75 = v59 - v79;
LABEL_73:
      *(double *)(v67 + 8 * v60) = v75;
      goto LABEL_77;
    }
    if (*(double *)(v67 + 8 * v60) > v63)
    {
      *(double *)(v67 + 8 * v60) = v63;
      v81 = v63 + v79;
LABEL_76:
      *(double *)(v67 + 8 * v54) = v81;
    }
LABEL_77:
    v82 = *(double *)(v67 + 8 * v54);
    v83 = *(unsigned int *)(a1 + 8);
    if ((int)v83 >= 1)
    {
      v84 = v82 - v68;
      v85 = *(double *)(v67 + 8 * v60) - v69;
      do
      {
        v86 = *v52++;
        v87 = v86;
        v88 = *v53++;
        *v56 = *v56 + v85 * v88 + v87 * v84;
        ++v56;
        --v83;
      }
      while (v83);
      v82 = *(double *)(v67 + 8 * v54);
    }
    v89 = *(_QWORD *)(a1 + 32);
    v90 = *(unsigned __int8 *)(v89 + v54);
    v91 = *(unsigned __int8 *)(v89 + v60);
    if (*(char *)(v55 + v54) <= 0)
      v92 = 80;
    else
      v92 = 72;
    v93 = *(double *)(a1 + v92);
    v94 = 2 * (v82 > 0.0);
    if (v82 >= v93)
      v94 = 1;
    *(_BYTE *)(v89 + v54) = v94;
    v95 = *(double *)(*(_QWORD *)(a1 + 40) + 8 * (int)v140);
    if (*(char *)(*(_QWORD *)(a1 + 16) + (int)v140) <= 0)
      v96 = 80;
    else
      v96 = 72;
    if (v95 >= *(double *)(a1 + v96))
    {
      v97 = *(_QWORD *)(a1 + 32);
      v98 = 1;
    }
    else
    {
      v97 = *(_QWORD *)(a1 + 32);
      if (v95 <= 0.0)
      {
        *(_BYTE *)(v97 + (int)v140) = 0;
        goto LABEL_95;
      }
      v98 = 2;
    }
    *(_BYTE *)(v97 + (int)v140) = v98;
LABEL_95:
    if ((v90 == 1) != (*(_BYTE *)(*(_QWORD *)(a1 + 32) + SHIDWORD(v140)) == 1))
    {
      v99 = (float *)(**(uint64_t (***)(uint64_t))a3)(a3);
      if (v90 == 1)
      {
        if ((int)a2 >= 1)
        {
          v100 = *(double **)(a1 + 104);
          v101 = a2;
          do
          {
            v102 = *v99++;
            *v100 = *v100 + -v59 * v102;
            ++v100;
            --v101;
          }
          while (v101);
        }
      }
      else if ((int)a2 >= 1)
      {
        v103 = *(double **)(a1 + 104);
        v104 = a2;
        do
        {
          v105 = *v99++;
          *v103 = *v103 + v59 * v105;
          ++v103;
          --v104;
        }
        while (v104);
      }
    }
    if ((v91 == 1) != (*(_BYTE *)(*(_QWORD *)(a1 + 32) + (int)v140) == 1))
    {
      v106 = (float *)(**(uint64_t (***)(uint64_t))a3)(a3);
      if (v91 == 1)
      {
        if ((int)a2 >= 1)
        {
          v107 = *(double **)(a1 + 104);
          v108 = a2;
          do
          {
            v109 = *v106++;
            *v107 = *v107 + -v63 * v109;
            ++v107;
            --v108;
          }
          while (v108);
        }
      }
      else if ((int)a2 >= 1)
      {
        v110 = *(double **)(a1 + 104);
        v111 = a2;
        do
        {
          v112 = *v106++;
          *v110 = *v110 + v63 * v112;
          ++v110;
          --v111;
        }
        while (v111);
      }
    }
    if (++v48 == v139)
    {
      v48 = v139;
      goto LABEL_116;
    }
  }
  CPMLLibSVM::Solver::reconstruct_gradient(a1);
  *(_DWORD *)(a1 + 8) = a2;
  info("*");
  if (!(*(unsigned int (**)(uint64_t, char *, uint64_t *))(*(_QWORD *)a1 + 16))(a1, (char *)&v140 + 4, &v140))
  {
    v51 = 1;
    goto LABEL_44;
  }
  if (v48 < v139)
    goto LABEL_119;
LABEL_116:
  if (*(_DWORD *)(a1 + 8) < (int)a2)
  {
    CPMLLibSVM::Solver::reconstruct_gradient(a1);
    *(_DWORD *)(a1 + 8) = a2;
    info("*");
  }
  fwrite("\nWARNING: reaching max number of iterations\n", 0x2CuLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
LABEL_119:
  *(double *)(a7 + 8) = (*(double (**)(uint64_t))(*(_QWORD *)a1 + 24))(a1);
  if ((int)a2 <= 0)
  {
    *(_QWORD *)a7 = 0;
  }
  else
  {
    v113 = *(double **)(a1 + 40);
    v114 = *(double **)(a1 + 24);
    v115 = 0.0;
    v116 = a2;
    v117 = *(double **)(a1 + 88);
    do
    {
      v118 = *v113++;
      v119 = v118;
      v120 = *v114++;
      v121 = v120;
      v122 = *v117++;
      v115 = v115 + v119 * (v121 + v122);
      --v116;
    }
    while (v116);
    *(double *)a7 = v115 * 0.5;
    v123 = *(uint64_t **)(a1 + 40);
    v124 = *(int **)(a1 + 96);
    do
    {
      v125 = *v123++;
      v126 = v125;
      v127 = *v124++;
      v135[v127] = v126;
      --v23;
    }
    while (v23);
  }
  *(double *)(a7 + 16) = a9;
  *(double *)(a7 + 24) = a10;
  info("\noptimization finished, #iter = %d\n", v48);
  v128 = *(_QWORD *)(a1 + 88);
  if (v128)
    MEMORY[0x20BD188CC](v128, 0x1000C8000313F17);
  v129 = *(_QWORD *)(a1 + 16);
  if (v129)
    MEMORY[0x20BD188CC](v129, 0x1000C8077774924);
  v130 = *(_QWORD *)(a1 + 40);
  if (v130)
    MEMORY[0x20BD188CC](v130, 0x1000C8000313F17);
  v131 = *(_QWORD *)(a1 + 32);
  if (v131)
    MEMORY[0x20BD188CC](v131, 0x1000C8077774924);
  v132 = *(_QWORD *)(a1 + 96);
  if (v132)
    MEMORY[0x20BD188CC](v132, 0x1000C8052888210);
  v133 = *(_QWORD *)(a1 + 24);
  if (v133)
    MEMORY[0x20BD188CC](v133, 0x1000C8000313F17);
  result = *(_QWORD *)(a1 + 104);
  if (result)
    return MEMORY[0x20BD188CC](result, 0x1000C8000313F17);
  return result;
}

uint64_t CPMLLibSVM::Solver::select_working_set(CPMLLibSVM::Solver *this, int *a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  double v10;
  uint64_t v11;
  double v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  double v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  uint64_t result;

  v6 = *((unsigned int *)this + 2);
  if ((int)v6 < 1)
  {
    LODWORD(v8) = -1;
    v9 = -INFINITY;
    v12 = -INFINITY;
    v13 = -1;
    goto LABEL_35;
  }
  v7 = 0;
  v8 = 0xFFFFFFFFLL;
  v9 = -INFINITY;
  do
  {
    if (*(_BYTE *)(*((_QWORD *)this + 2) + v7) == 1)
    {
      if (*(_BYTE *)(*((_QWORD *)this + 4) + v7) != 1)
      {
        v10 = -*(double *)(*((_QWORD *)this + 3) + 8 * v7);
        if (v9 <= v10)
          goto LABEL_9;
      }
    }
    else if (*(_BYTE *)(*((_QWORD *)this + 4) + v7))
    {
      v10 = *(double *)(*((_QWORD *)this + 3) + 8 * v7);
      if (v10 >= v9)
      {
LABEL_9:
        v9 = v10;
        v8 = v7;
      }
    }
    ++v7;
  }
  while (v6 != v7);
  if ((_DWORD)v8 == -1)
  {
    v11 = 0;
    LODWORD(v8) = -1;
  }
  else
  {
    v11 = (***((uint64_t (****)(_QWORD, uint64_t))this + 6))(*((_QWORD *)this + 6), v8);
    LODWORD(v6) = *((_DWORD *)this + 2);
  }
  if ((int)v6 >= 1)
  {
    v14 = 0;
    v15 = *((_QWORD *)this + 2);
    v13 = -1;
    v12 = -INFINITY;
    v16 = INFINITY;
    while (1)
    {
      if (*(_BYTE *)(v15 + v14) == 1)
      {
        if (!*(_BYTE *)(*((_QWORD *)this + 4) + v14))
          goto LABEL_32;
        v17 = *((_QWORD *)this + 3);
        v18 = *(double *)(v17 + 8 * v14);
        v19 = v9 + v18;
        if (v18 >= v12)
          v12 = *(double *)(v17 + 8 * v14);
        if (v19 <= 0.0)
          goto LABEL_32;
        v20 = *(double *)(*((_QWORD *)this + 7) + 8 * (int)v8) + *(double *)(*((_QWORD *)this + 7) + 8 * v14);
        v21 = *(float *)(v11 + 4 * v14);
        v22 = (double)*(char *)(v15 + (int)v8) * -2.0;
      }
      else
      {
        if (*(_BYTE *)(*((_QWORD *)this + 4) + v14) == 1)
          goto LABEL_32;
        v23 = *(double *)(*((_QWORD *)this + 3) + 8 * v14);
        v19 = v9 - v23;
        v24 = -v23;
        if (v12 <= v24)
          v12 = v24;
        if (v19 <= 0.0)
          goto LABEL_32;
        v20 = *(double *)(*((_QWORD *)this + 7) + 8 * (int)v8) + *(double *)(*((_QWORD *)this + 7) + 8 * v14);
        v22 = (double)*(char *)(v15 + (int)v8) + (double)*(char *)(v15 + (int)v8);
        v21 = *(float *)(v11 + 4 * v14);
      }
      v25 = v20 + v22 * v21;
      v26 = -(v19 * v19);
      if (v25 <= 0.0)
        v25 = 1.0e-12;
      v27 = v26 / v25;
      if (v27 <= v16)
      {
        v13 = v14;
        v16 = v27;
      }
LABEL_32:
      if (v6 == ++v14)
        goto LABEL_35;
    }
  }
  v13 = -1;
  v12 = -INFINITY;
LABEL_35:
  if (v9 + v12 < *((double *)this + 8))
    return 1;
  result = 0;
  *a2 = v8;
  *a3 = v13;
  return result;
}

BOOL CPMLLibSVM::Solver::be_shrunk(CPMLLibSVM::Solver *this, int a2, double a3, double a4)
{
  double v4;
  BOOL v5;

  if (*(_BYTE *)(*((_QWORD *)this + 4) + a2))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 4) + a2) != 1)
      return 0;
    v4 = -*(double *)(*((_QWORD *)this + 3) + 8 * a2);
    if (*(_BYTE *)(*((_QWORD *)this + 2) + a2) != 1)
      goto LABEL_4;
  }
  else
  {
    v4 = *(double *)(*((_QWORD *)this + 3) + 8 * a2);
    if (*(_BYTE *)(*((_QWORD *)this + 2) + a2) == 1)
    {
LABEL_4:
      v5 = v4 <= a4;
      return !v5;
    }
  }
  v5 = v4 <= a3;
  return !v5;
}

void CPMLLibSVM::Solver::do_shrinking(CPMLLibSVM::Solver *this)
{
  int v2;
  unsigned __int8 *v3;
  double *v4;
  unsigned __int8 *v5;
  double v6;
  uint64_t v7;
  double v8;
  int v9;
  int v10;
  int v11;
  int v12;
  double v13;
  int i;

  v2 = *((_DWORD *)this + 2);
  if (v2 < 1)
  {
    v8 = -INFINITY;
    v6 = -INFINITY;
  }
  else
  {
    v4 = (double *)*((_QWORD *)this + 3);
    v3 = (unsigned __int8 *)*((_QWORD *)this + 4);
    v5 = (unsigned __int8 *)*((_QWORD *)this + 2);
    v6 = -INFINITY;
    v7 = *((unsigned int *)this + 2);
    v8 = -INFINITY;
    do
    {
      v10 = *v5++;
      v9 = v10;
      v12 = *v3++;
      v11 = v12;
      v13 = *v4;
      if (v9 == 1)
      {
        if (v11 == 1)
          goto LABEL_8;
        if (v8 <= -v13)
          v8 = -v13;
        if (v11)
        {
LABEL_8:
          if (v13 >= v6)
            v6 = *v4;
        }
      }
      else
      {
        if (v11 == 1)
          goto LABEL_15;
        if (v6 <= -v13)
          v6 = -v13;
        if (v11)
        {
LABEL_15:
          if (v13 >= v8)
            v8 = *v4;
        }
      }
      ++v4;
      --v7;
    }
    while (v7);
  }
  if (!*((_BYTE *)this + 116) && v8 + v6 <= *((double *)this + 8) * 10.0)
  {
    *((_BYTE *)this + 116) = 1;
    CPMLLibSVM::Solver::reconstruct_gradient((uint64_t)this);
    *((_DWORD *)this + 2) = *((_DWORD *)this + 28);
    info("*");
    v2 = *((_DWORD *)this + 2);
  }
  if (v2 >= 1)
  {
    for (i = 0; i < v2; ++i)
    {
      if (CPMLLibSVM::Solver::be_shrunk(this, i, v8, v6))
      {
        while (1)
        {
          *((_DWORD *)this + 2) = --v2;
          if (v2 <= i)
            break;
          if (!CPMLLibSVM::Solver::be_shrunk(this, v2, v8, v6))
          {
            CPMLLibSVM::Solver::swap_index(this, i, v2);
            v2 = *((_DWORD *)this + 2);
            break;
          }
        }
      }
    }
  }
}

double CPMLLibSVM::Solver::calculate_rho(CPMLLibSVM::Solver *this)
{
  uint64_t v1;
  int v2;
  unsigned __int8 *v3;
  double *v4;
  unsigned __int8 *v5;
  double v6;
  double v7;
  double v8;
  int v9;
  int v10;
  double v11;
  double v12;
  double v13;
  int v14;
  double v15;
  double v16;
  double v17;
  double v18;
  int v19;
  double v20;

  v1 = *((unsigned int *)this + 2);
  if ((int)v1 < 1)
  {
    v7 = INFINITY;
    v8 = -INFINITY;
  }
  else
  {
    v2 = 0;
    v3 = (unsigned __int8 *)*((_QWORD *)this + 2);
    v4 = (double *)*((_QWORD *)this + 3);
    v5 = (unsigned __int8 *)*((_QWORD *)this + 4);
    v6 = 0.0;
    v7 = INFINITY;
    v8 = -INFINITY;
    do
    {
      v10 = *v3++;
      v9 = v10;
      v11 = (double)(char)v10;
      v12 = *v4++;
      v13 = v12 * v11;
      LODWORD(v12) = *v5++;
      v14 = LODWORD(v12);
      if (v8 <= v13)
        v15 = v13;
      else
        v15 = v8;
      if (v7 >= v13)
        v16 = v13;
      else
        v16 = v7;
      if (v9 == 1)
        v15 = v8;
      else
        v16 = v7;
      v17 = v6 + v13;
      if (v8 <= v13)
        v18 = v13;
      else
        v18 = v8;
      if (v7 < v13)
        v13 = v7;
      if (v9 == 255)
        v18 = v8;
      else
        v13 = v7;
      if (v14 == 1)
        v19 = v2;
      else
        v19 = v2 + 1;
      if (v14 == 1)
      {
        v7 = v13;
        v8 = v18;
        v20 = v6;
      }
      else
      {
        v20 = v17;
      }
      if (v14)
      {
        v2 = v19;
      }
      else
      {
        v7 = v16;
        v8 = v15;
      }
      if (v14)
        v6 = v20;
      --v1;
    }
    while (v1);
    if (v2 > 0)
      return v6 / (double)v2;
  }
  return (v7 + v8) * 0.5;
}

uint64_t CPMLLibSVM::Solver_NU::select_working_set(CPMLLibSVM::Solver_NU *this, int *a2, int *a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  double v9;
  uint64_t v10;
  double v11;
  uint64_t v12;
  double v13;
  double v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  uint64_t v19;
  double v20;
  double v21;
  double v22;
  float v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  uint64_t result;
  int v32;

  v6 = *((unsigned int *)this + 2);
  if ((int)v6 < 1)
  {
    LODWORD(v8) = -1;
    v9 = -INFINITY;
    LODWORD(v10) = -1;
    v11 = -INFINITY;
    v13 = -INFINITY;
    v14 = -INFINITY;
    v15 = -1;
  }
  else
  {
    v7 = 0;
    v8 = 0xFFFFFFFFLL;
    v9 = -INFINITY;
    v10 = 0xFFFFFFFFLL;
    v11 = -INFINITY;
    do
    {
      if (*(_BYTE *)(*((_QWORD *)this + 2) + v7) == 1)
      {
        if (*(_BYTE *)(*((_QWORD *)this + 4) + v7) != 1 && v11 <= -*(double *)(*((_QWORD *)this + 3) + 8 * v7))
        {
          v11 = -*(double *)(*((_QWORD *)this + 3) + 8 * v7);
          v10 = v7;
        }
      }
      else if (*(_BYTE *)(*((_QWORD *)this + 4) + v7) && *(double *)(*((_QWORD *)this + 3) + 8 * v7) >= v9)
      {
        v9 = *(double *)(*((_QWORD *)this + 3) + 8 * v7);
        v8 = v7;
      }
      ++v7;
    }
    while (v6 != v7);
    if ((_DWORD)v10 == -1)
    {
      v12 = 0;
      LODWORD(v10) = -1;
    }
    else
    {
      v12 = (***((uint64_t (****)(_QWORD, uint64_t))this + 6))(*((_QWORD *)this + 6), v10);
      v6 = *((unsigned int *)this + 2);
    }
    if ((_DWORD)v8 == -1)
    {
      v16 = 0;
      LODWORD(v8) = -1;
    }
    else
    {
      v16 = (***((uint64_t (****)(_QWORD, uint64_t, uint64_t))this + 6))(*((_QWORD *)this + 6), v8, v6);
      LODWORD(v6) = *((_DWORD *)this + 2);
    }
    if ((int)v6 >= 1)
    {
      v17 = 0;
      v15 = -1;
      v14 = -INFINITY;
      v18 = INFINITY;
      v13 = -INFINITY;
      while (1)
      {
        if (*(_BYTE *)(*((_QWORD *)this + 2) + v17) == 1)
        {
          if (!*(_BYTE *)(*((_QWORD *)this + 4) + v17))
            goto LABEL_35;
          v19 = *((_QWORD *)this + 3);
          v20 = *(double *)(v19 + 8 * v17);
          v21 = v11 + v20;
          if (v20 >= v13)
            v13 = *(double *)(v19 + 8 * v17);
          if (v21 <= 0.0)
            goto LABEL_35;
          v22 = *(double *)(*((_QWORD *)this + 7) + 8 * (int)v10) + *(double *)(*((_QWORD *)this + 7) + 8 * v17);
          v23 = *(float *)(v12 + 4 * v17);
        }
        else
        {
          if (*(_BYTE *)(*((_QWORD *)this + 4) + v17) == 1)
            goto LABEL_35;
          v24 = *(double *)(*((_QWORD *)this + 3) + 8 * v17);
          v21 = v9 - v24;
          v25 = -v24;
          if (v14 <= v25)
            v14 = v25;
          if (v21 <= 0.0)
            goto LABEL_35;
          v22 = *(double *)(*((_QWORD *)this + 7) + 8 * (int)v8) + *(double *)(*((_QWORD *)this + 7) + 8 * v17);
          v23 = *(float *)(v16 + 4 * v17);
        }
        v26 = v22 - (float)(v23 + v23);
        v27 = -(v21 * v21);
        if (v26 <= 0.0)
          v26 = 1.0e-12;
        v28 = v27 / v26;
        if (v28 <= v18)
        {
          v15 = v17;
          v18 = v28;
        }
LABEL_35:
        if (v6 == ++v17)
          goto LABEL_38;
      }
    }
    v15 = -1;
    v13 = -INFINITY;
    v14 = -INFINITY;
  }
LABEL_38:
  v29 = v11 + v13;
  v30 = v9 + v14;
  if (v29 > v30)
    v30 = v29;
  if (v30 < *((double *)this + 8))
    return 1;
  result = 0;
  if (*(_BYTE *)(*((_QWORD *)this + 2) + v15) == 1)
    v32 = v10;
  else
    v32 = v8;
  *a2 = v32;
  *a3 = v15;
  return result;
}

BOOL CPMLLibSVM::Solver_NU::be_shrunk(CPMLLibSVM::Solver_NU *this, int a2, double a3, double a4, double a5, double a6)
{
  double v6;
  BOOL v7;
  double v8;

  if (*(_BYTE *)(*((_QWORD *)this + 4) + a2))
  {
    if (*(_BYTE *)(*((_QWORD *)this + 4) + a2) != 1)
      return 0;
    v6 = -*(double *)(*((_QWORD *)this + 3) + 8 * a2);
    if (*(_BYTE *)(*((_QWORD *)this + 2) + a2) == 1)
      v7 = v6 <= a3;
    else
      v7 = v6 <= a6;
  }
  else
  {
    v8 = *(double *)(*((_QWORD *)this + 3) + 8 * a2);
    if (*(_BYTE *)(*((_QWORD *)this + 2) + a2) == 1)
      v7 = v8 <= a4;
    else
      v7 = v8 <= a5;
  }
  return !v7;
}

void CPMLLibSVM::Solver_NU::do_shrinking(CPMLLibSVM::Solver_NU *this)
{
  uint64_t v2;
  uint64_t v3;
  double v4;
  double v5;
  double v6;
  double v7;
  int v8;
  double v9;
  double v10;
  double v11;
  int v12;

  v2 = *((unsigned int *)this + 2);
  if ((int)v2 < 1)
  {
    v7 = -INFINITY;
    v6 = -INFINITY;
    v5 = -INFINITY;
    v4 = -INFINITY;
  }
  else
  {
    v3 = 0;
    v4 = -INFINITY;
    v5 = -INFINITY;
    v6 = -INFINITY;
    v7 = -INFINITY;
    do
    {
      v8 = *(unsigned __int8 *)(*((_QWORD *)this + 2) + v3);
      if (*(_BYTE *)(*((_QWORD *)this + 4) + v3) == 1)
        goto LABEL_10;
      v9 = -*(double *)(*((_QWORD *)this + 3) + 8 * v3);
      if (v8 == 1)
      {
        if (v7 < v9)
          v7 = -*(double *)(*((_QWORD *)this + 3) + 8 * v3);
      }
      else if (v4 < v9)
      {
        v4 = -*(double *)(*((_QWORD *)this + 3) + 8 * v3);
      }
      if (*(_BYTE *)(*((_QWORD *)this + 4) + v3))
      {
LABEL_10:
        v10 = *(double *)(*((_QWORD *)this + 3) + 8 * v3);
        if (v8 == 1)
        {
          if (v10 > v6)
            v6 = *(double *)(*((_QWORD *)this + 3) + 8 * v3);
        }
        else if (v10 > v5)
        {
          v5 = *(double *)(*((_QWORD *)this + 3) + 8 * v3);
        }
      }
      ++v3;
    }
    while (v2 != v3);
  }
  if (!*((_BYTE *)this + 116))
  {
    v11 = v7 + v6;
    if (v7 + v6 <= v5 + v4)
      v11 = v5 + v4;
    if (v11 <= *((double *)this + 8) * 10.0)
    {
      *((_BYTE *)this + 116) = 1;
      CPMLLibSVM::Solver::reconstruct_gradient((uint64_t)this);
      LODWORD(v2) = *((_DWORD *)this + 28);
      *((_DWORD *)this + 2) = v2;
    }
  }
  if ((int)v2 >= 1)
  {
    v12 = 0;
    do
    {
      if (CPMLLibSVM::Solver_NU::be_shrunk(this, v12, v7, v6, v5, v4))
      {
        while (1)
        {
          LODWORD(v2) = v2 - 1;
          *((_DWORD *)this + 2) = v2;
          if ((int)v2 <= v12)
            break;
          if (!CPMLLibSVM::Solver_NU::be_shrunk(this, v2, v7, v6, v5, v4))
          {
            CPMLLibSVM::Solver::swap_index(this, v12, v2);
            LODWORD(v2) = *((_DWORD *)this + 2);
            break;
          }
        }
      }
      ++v12;
    }
    while (v12 < (int)v2);
  }
}

double CPMLLibSVM::Solver_NU::calculate_rho(CPMLLibSVM::Solver_NU *this)
{
  uint64_t v1;
  uint64_t v2;
  int v3;
  int v4;
  double v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  int v11;
  double v12;
  double v13;

  v1 = *((unsigned int *)this + 2);
  if ((int)v1 < 1)
  {
    v3 = 0;
    v5 = 0.0;
    v6 = INFINITY;
    v7 = -INFINITY;
    v9 = -INFINITY;
    v10 = INFINITY;
  }
  else
  {
    v2 = 0;
    v3 = 0;
    v4 = 0;
    v5 = 0.0;
    v6 = INFINITY;
    v7 = -INFINITY;
    v8 = 0.0;
    v9 = -INFINITY;
    v10 = INFINITY;
    do
    {
      v11 = *(unsigned __int8 *)(*((_QWORD *)this + 4) + v2);
      if (*(_BYTE *)(*((_QWORD *)this + 2) + v2) == 1)
      {
        if (*(_BYTE *)(*((_QWORD *)this + 4) + v2))
        {
          if (v11 == 1)
          {
            if (v9 <= *(double *)(*((_QWORD *)this + 3) + 8 * v2))
              v9 = *(double *)(*((_QWORD *)this + 3) + 8 * v2);
          }
          else
          {
            ++v4;
            v8 = v8 + *(double *)(*((_QWORD *)this + 3) + 8 * v2);
          }
        }
        else if (v10 >= *(double *)(*((_QWORD *)this + 3) + 8 * v2))
        {
          v10 = *(double *)(*((_QWORD *)this + 3) + 8 * v2);
        }
      }
      else if (*(_BYTE *)(*((_QWORD *)this + 4) + v2))
      {
        if (v11 == 1)
        {
          if (v7 <= *(double *)(*((_QWORD *)this + 3) + 8 * v2))
            v7 = *(double *)(*((_QWORD *)this + 3) + 8 * v2);
        }
        else
        {
          ++v3;
          v5 = v5 + *(double *)(*((_QWORD *)this + 3) + 8 * v2);
        }
      }
      else if (v6 >= *(double *)(*((_QWORD *)this + 3) + 8 * v2))
      {
        v6 = *(double *)(*((_QWORD *)this + 3) + 8 * v2);
      }
      ++v2;
    }
    while (v1 != v2);
    if (v4 > 0)
    {
      v12 = v8 / (double)v4;
      goto LABEL_27;
    }
  }
  v12 = (v10 + v9) * 0.5;
LABEL_27:
  if (v3 < 1)
    v13 = (v6 + v7) * 0.5;
  else
    v13 = v5 / (double)v3;
  *(double *)(*((_QWORD *)this + 15) + 32) = (v12 + v13) * 0.5;
  return (v12 - v13) * 0.5;
}

char *svm_train(int *a1, uint64_t a2)
{
  char *v4;
  char *v5;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;
  __int128 v10;
  void **v11;
  double *v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  double *v17;
  double v18;
  uint64_t v19;
  double *v20;
  double v21;
  double v22;
  int v23;
  double v24;
  double v25;
  uint64_t v26;
  double *v27;
  double v28;
  double v29;
  BOOL v30;
  size_t v31;
  size_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  size_t v37;
  int *v38;
  _QWORD *v39;
  uint64_t v40;
  double *v41;
  double *v42;
  uint64_t v43;
  double *v44;
  int v45;
  uint64_t v46;
  _DWORD *v47;
  FILE **v48;
  uint64_t v49;
  char *v50;
  char *v51;
  uint64_t v52;
  size_t v53;
  uint64_t *v54;
  uint64_t v55;
  uint64_t v56;
  double v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t *v68;
  uint64_t v69;
  double v70;
  double v71;
  int *v72;
  double *v73;
  uint64_t i;
  int v75;
  uint64_t j;
  uint64_t v77;
  int v78;
  int v79;
  int v80;
  uint64_t v81;
  int v82;
  double *v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  int *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  int v91;
  int v92;
  double v93;
  int *v94;
  uint64_t v95;
  uint64_t v96;
  BOOL v97;
  BOOL v98;
  __int128 v99;
  __int128 v100;
  __int128 v101;
  double *v102;
  uint64_t v103;
  int **v104;
  uint64_t v105;
  int *v106;
  uint64_t v107;
  uint64_t v108;
  int *v109;
  uint64_t v110;
  uint64_t v111;
  int *v112;
  uint64_t v113;
  uint64_t v114;
  int v115;
  uint64_t v116;
  double *v117;
  double v118;
  double v119;
  double v120;
  double *v121;
  uint64_t v122;
  double v123;
  double *v124;
  double v125;
  double v126;
  double *v127;
  double *v128;
  uint64_t v129;
  double v130;
  double *v131;
  double v132;
  double v133;
  double v134;
  double v135;
  double v136;
  double v137;
  double v138;
  long double v139;
  int v140;
  double v141;
  double v142;
  double v143;
  double v144;
  double *v145;
  double *v146;
  uint64_t v147;
  double v148;
  double v149;
  double v150;
  double v151;
  double v152;
  double v153;
  long double v154;
  double v155;
  double v156;
  long double v157;
  double v158;
  double v159;
  double v160;
  double v161;
  double v162;
  double v163;
  double v164;
  double *v165;
  double *v166;
  uint64_t v167;
  double v168;
  double v169;
  double v170;
  double v171;
  double v172;
  double v173;
  double v174;
  double v175;
  long double v176;
  double *v177;
  double **v178;
  double *v179;
  uint64_t v180;
  char *v181;
  double *v182;
  double *v183;
  char *v184;
  size_t v185;
  _DWORD *v186;
  int *v187;
  uint64_t v188;
  int v189;
  _QWORD *v190;
  uint64_t v191;
  uint64_t *v192;
  uint64_t v193;
  _QWORD *v194;
  _QWORD *v195;
  uint64_t v196;
  double *v197;
  uint64_t v198;
  uint64_t v199;
  int *v200;
  _DWORD *v201;
  uint64_t v202;
  int v203;
  int32x2_t *v204;
  int *v205;
  uint64_t v206;
  int v207;
  char *v208;
  int v209;
  size_t v210;
  void *v211;
  unsigned __int8 *v212;
  int v213;
  uint64_t v214;
  _QWORD *v215;
  _DWORD *v216;
  _DWORD *v218;
  double *v219;
  int v220;
  _DWORD *v221;
  uint64_t v222;
  int *v223;
  int v224;
  uint64_t v225;
  _QWORD *v226;
  int *v227;
  int32x2_t *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  int v234;
  char *v235;
  uint64_t v236;
  uint64_t v237;
  uint64_t v238;
  uint64_t v239;
  int v240;
  int v241;
  char *v242;
  uint64_t v243;
  uint64_t v245;
  void **v246;
  void *v247;
  double v248;
  uint64_t v249;
  uint64_t v250;
  _QWORD *v251;
  uint64_t v252;
  unsigned int v253;
  double *v254;
  double v255;
  int v256;
  int v257;
  uint64_t v258;
  int v259;
  double v260;
  uint64_t v262;
  uint64_t v263;
  unsigned int size;
  size_t v265;
  unsigned int v266;
  int *v267;
  int v268;
  char *v269;
  uint64_t v270;
  uint64_t v271;
  uint64_t v272;
  _QWORD *v273;
  uint64_t v274;
  double *v275;
  uint64_t v276;
  int32x2_t *v277;
  int *v278;
  char *v279;
  _QWORD *v280;
  int v281;
  uint64_t v282;
  uint64_t v283;
  uint64_t v284;
  uint64_t v285;
  uint64_t v286;
  uint64_t v287;
  uint64_t v288;
  double *v289;
  uint64_t v290;
  uint64_t *v291;
  double v292;
  double v293;
  double v294;
  double v295;
  double v296;
  double v297;
  int v298;
  void *v299;
  void *v300;
  int32x2_t *v301;
  int *v302;
  void *v303;
  unsigned int v304;
  __int128 v305;
  __int128 v306;
  __int128 v307;
  __int128 v308;
  void *v309[2];
  __int128 v310;
  uint64_t v311;
  int v312;
  double *v313;
  _QWORD *v314;

  v4 = (char *)malloc_type_malloc(0xB8uLL, 0x109004003BC950CuLL);
  v5 = v4;
  v6 = *(_OWORD *)a2;
  v7 = *(_OWORD *)(a2 + 32);
  *((_OWORD *)v4 + 1) = *(_OWORD *)(a2 + 16);
  *((_OWORD *)v4 + 2) = v7;
  *(_OWORD *)v4 = v6;
  v8 = *(_OWORD *)(a2 + 48);
  v9 = *(_OWORD *)(a2 + 64);
  v10 = *(_OWORD *)(a2 + 80);
  *((_QWORD *)v4 + 12) = *(_QWORD *)(a2 + 96);
  *((_OWORD *)v4 + 4) = v9;
  *((_OWORD *)v4 + 5) = v10;
  *((_OWORD *)v4 + 3) = v8;
  *((_DWORD *)v4 + 44) = 0;
  if ((*(_DWORD *)a2 - 2) <= 2)
  {
    *((_QWORD *)v4 + 17) = 0;
    v11 = (void **)(v4 + 136);
    *((_DWORD *)v4 + 26) = 2;
    *((_QWORD *)v4 + 18) = 0;
    *((_QWORD *)v4 + 20) = 0;
    *((_QWORD *)v4 + 21) = 0;
    *((_QWORD *)v4 + 15) = malloc_type_malloc(8uLL, 0x80040B8603338uLL);
    if (*(_DWORD *)(a2 + 100) && (*(_DWORD *)a2 - 3) <= 1)
    {
      *v11 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
      v12 = (double *)malloc_type_malloc(8 * *a1, 0x100004000313F17uLL);
      v311 = *(_QWORD *)(a2 + 96);
      v13 = *(_OWORD *)(a2 + 64);
      v310 = *(_OWORD *)(a2 + 80);
      v14 = *(_OWORD *)(a2 + 16);
      v305 = *(_OWORD *)a2;
      v306 = v14;
      v15 = *(_OWORD *)(a2 + 32);
      v308 = *(_OWORD *)(a2 + 48);
      *(_OWORD *)v309 = v13;
      v307 = v15;
      HIDWORD(v311) = 0;
      svm_cross_validation(a1, &v305, 5, (uint64_t)v12);
      v16 = *a1;
      if ((int)v16 < 1)
      {
        v23 = 0;
        v25 = 0.0;
      }
      else
      {
        v17 = (double *)*((_QWORD *)a1 + 1);
        v18 = 0.0;
        v19 = *a1;
        v20 = v12;
        do
        {
          v21 = *v17++;
          v22 = *v20;
          *v20 = v21 - *v20;
          ++v20;
          v18 = v18 + vabdd_f64(v21, v22);
          --v19;
        }
        while (v19);
        v23 = 0;
        v24 = sqrt(v18 / (double)(int)v16 * (v18 / (double)(int)v16 + v18 / (double)(int)v16)) * 5.0;
        v25 = 0.0;
        v26 = v16;
        v27 = v12;
        do
        {
          v28 = *v27++;
          v29 = fabs(v28);
          v30 = v29 <= v24;
          if (v29 > v24)
            v29 = -0.0;
          v25 = v25 + v29;
          if (!v30)
            ++v23;
          --v26;
        }
        while (v26);
      }
      v248 = v25 / (double)((int)v16 - v23);
      info("Prob. model for test data: target value = predicted value + z,\nz: Laplace distribution e^(-|z|/sigma)/(2sigma),sigma= %g\n", v248);
      free(v12);
      *(double *)*v11 = v248;
    }
    v219 = (double *)svm_train_one(a1, a2, 0.0, 0.0);
    v250 = v249;
    v251 = malloc_type_malloc(8uLL, 0x100004000313F17uLL);
    *((_QWORD *)v5 + 16) = v251;
    *v251 = v250;
    v252 = *a1;
    if ((int)v252 < 1)
    {
      v253 = 0;
    }
    else
    {
      v253 = 0;
      v254 = v219;
      do
      {
        v255 = *v254++;
        v256 = v255 < 0.0;
        if (v255 > 0.0)
          v256 = 1;
        v253 += v256;
        --v252;
      }
      while (v252);
    }
    *((_DWORD *)v5 + 27) = v253;
    *((_QWORD *)v5 + 14) = malloc_type_malloc(8 * v253, 0x2004093837F09uLL);
    **((_QWORD **)v5 + 15) = malloc_type_malloc(8 * v253, 0x100004000313F17uLL);
    *((_QWORD *)v5 + 19) = malloc_type_malloc(4 * v253, 0x100004052888210uLL);
    v257 = *a1;
    if (*a1 >= 1)
    {
      v258 = 0;
      v259 = 0;
      do
      {
        v260 = v219[v258];
        if (v260 < 0.0 || v260 > 0.0)
        {
          *(_QWORD *)(*((_QWORD *)v5 + 14) + 8 * v259) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v258);
          *(double *)(**((_QWORD **)v5 + 15) + 8 * v259) = v260;
          *(_DWORD *)(*((_QWORD *)v5 + 19) + 4 * v259++) = ++v258;
          v257 = *a1;
        }
        else
        {
          ++v258;
        }
      }
      while (v258 < v257);
    }
    goto LABEL_232;
  }
  v31 = *a1;
  v32 = *a1;
  v304 = 0;
  v302 = 0;
  v303 = 0;
  v301 = 0;
  v267 = (int *)malloc_type_malloc(4 * v31, 0x100004052888210uLL);
  svm_group_classes(a1, (int *)&v304, &v303, &v302, &v301, (uint64_t)v267);
  v33 = v304;
  if (v304 == 1)
    info("WARNING: training data in only one class. See README for details.\n");
  v34 = (int)v33;
  v35 = malloc_type_malloc(8 * v31, 0x2004093837F09uLL);
  v36 = v35;
  if ((int)v32 >= 1)
  {
    v37 = v32;
    v38 = v267;
    v39 = v35;
    do
    {
      v40 = *v38++;
      *v39++ = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v40);
      --v37;
    }
    while (v37);
  }
  size = v31;
  v265 = v32;
  v41 = (double *)malloc_type_malloc(8 * (int)v33, 0x100004000313F17uLL);
  v42 = v41;
  v266 = v33 - 1;
  if ((int)v33 >= 1)
  {
    v43 = v33;
    v44 = v41;
    do
    {
      *v44++ = *(double *)(a2 + 48);
      --v43;
    }
    while (v43);
  }
  v276 = a2;
  v45 = *(_DWORD *)(a2 + 56);
  if (v45 >= 1)
  {
    v46 = 0;
    v47 = v303;
    v48 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      if ((int)v33 < 1)
      {
        LODWORD(v49) = 0;
      }
      else
      {
        v49 = 0;
        while (*(_DWORD *)(*(_QWORD *)(v276 + 64) + 4 * v46) != v47[v49])
        {
          if (v33 == ++v49)
            goto LABEL_31;
        }
      }
      if ((_DWORD)v49 == (_DWORD)v33)
      {
LABEL_31:
        fprintf(*v48, "WARNING: class label %d specified in weight is not found\n", *(_DWORD *)(*(_QWORD *)(v276 + 64) + 4 * v46));
        v45 = *(_DWORD *)(v276 + 56);
      }
      else
      {
        v42[v49] = *(double *)(*(_QWORD *)(v276 + 72) + 8 * v46) * v42[v49];
      }
      ++v46;
    }
    while (v46 < v45);
  }
  v50 = (char *)malloc_type_malloc(v31, 0x100004077774924uLL);
  v51 = v50;
  if ((int)v265 >= 1)
    bzero(v50, v265);
  v279 = v51;
  v268 = v266 * v33;
  v280 = malloc_type_malloc(16 * ((int)(v266 * v33) / 2), 0x1080040FC6463CFuLL);
  v52 = v276;
  v263 = (uint64_t)(int)(v266 * v33 + ((int)(v266 * v33) < 0)) >> 1;
  v53 = 8 * v263;
  v262 = 8 * v263;
  if (*(_DWORD *)(v276 + 100))
  {
    v54 = (uint64_t *)malloc_type_malloc(v53, 0x100004000313F17uLL);
    v289 = (double *)malloc_type_malloc(v53, 0x100004000313F17uLL);
  }
  else
  {
    v54 = 0;
    v289 = 0;
  }
  v274 = v33;
  v275 = v42;
  v291 = v54;
  v270 = (int)v33;
  if ((int)v33 < 1)
    goto LABEL_162;
  v55 = 0;
  LODWORD(v56) = 0;
  v277 = v301;
  v278 = v302;
  v57 = -1.0;
  v58 = 1;
  v269 = v5;
  v273 = v36;
  do
  {
    v59 = v55 + 1;
    if (v55 + 1 >= v34)
      goto LABEL_161;
    v271 = v55 + 1;
    v272 = v58;
    v56 = (int)v56;
    v60 = v58;
    v288 = v55;
    do
    {
      v61 = v33;
      v284 = v278[v55];
      v62 = v36;
      v63 = v277->i32[v55];
      v286 = v278[v60];
      v287 = v277->u32[v55];
      v64 = v277->u32[v60];
      v298 = v64 + v63;
      v300 = malloc_type_malloc(8 * ((int)v64 + (int)v63), 0x2004093837F09uLL);
      v299 = malloc_type_malloc(8 * v298, 0x100004000313F17uLL);
      v285 = v63;
      v30 = (int)v63 < 1;
      v36 = v62;
      if (!v30)
      {
        v65 = 0;
        do
        {
          *(_QWORD *)((char *)v300 + v65 * 8) = v62[v284 + v65];
          *(_QWORD *)((char *)v299 + v65 * 8) = 0x3FF0000000000000;
          ++v65;
        }
        while (v287 != v65);
      }
      if ((int)v64 >= 1)
      {
        v66 = 8 * v285;
        v67 = v64;
        v68 = &v62[v286];
        do
        {
          v69 = *v68++;
          *(_QWORD *)((char *)v300 + v66) = v69;
          *(_QWORD *)((char *)v299 + v66) = 0xBFF0000000000000;
          v66 += 8;
          --v67;
        }
        while (v67);
      }
      v33 = v61;
      if (!*(_DWORD *)(v52 + 100))
        goto LABEL_147;
      v282 = v64;
      v283 = v60;
      v290 = v56;
      v70 = v42[v288];
      v71 = v42[v60];
      v72 = (int *)malloc_type_malloc(4 * v298, 0x100004052888210uLL);
      v73 = (double *)malloc_type_malloc(8 * v298, 0x100004000313F17uLL);
      if (v298 >= 1)
      {
        for (i = 0; i < v298; ++i)
          v72[i] = i;
        if (v298 >= 1)
        {
          v75 = 0;
          for (j = 0; j < v298; ++j)
          {
            v77 = j + rand() % (v75 + v298);
            v78 = v72[j];
            v72[j] = v72[v77];
            v72[v77] = v78;
            --v75;
          }
        }
      }
      v79 = 0;
      do
      {
        v80 = v298 * v79;
        v81 = (v298 * v79++ / 5);
        v82 = v298 * v79 / 5;
        v312 = v81 - v82 + v298;
        v314 = malloc_type_malloc(8 * v312, 0x2004093837F09uLL);
        v83 = (double *)malloc_type_malloc(8 * v312, 0x100004000313F17uLL);
        v313 = v83;
        if (v80 < 5)
        {
          LODWORD(v86) = 0;
        }
        else
        {
          v84 = 0;
          do
          {
            v85 = v72[v84];
            v314[v84] = *((_QWORD *)v300 + v85);
            v83 = v313;
            v313[v84++] = *((double *)v299 + v85);
          }
          while (v81 != v84);
          LODWORD(v86) = v80 / 5;
        }
        if (v82 < v298)
        {
          v87 = &v72[v82];
          v88 = v86;
          v89 = v298 - (uint64_t)v82;
          do
          {
            v90 = *v87++;
            v314[v88] = *((_QWORD *)v300 + v90);
            v83 = v313;
            v313[v88++] = *((double *)v299 + v90);
            LODWORD(v86) = v86 + 1;
            --v89;
          }
          while (v89);
        }
        if ((_DWORD)v86)
        {
          v91 = 0;
          v92 = 0;
          v86 = v86;
          do
          {
            v93 = *v83++;
            if (v93 <= 0.0)
              ++v91;
            else
              ++v92;
            --v86;
          }
          while (v86);
        }
        else
        {
          v92 = 0;
          v91 = 0;
        }
        if (v92 | v91)
        {
          if (v92)
            v97 = v91 == 0;
          else
            v97 = 0;
          if (v97)
          {
            if ((int)v81 < v82)
            {
              v109 = &v72[(int)v81];
              v110 = v82 - (uint64_t)(int)v81;
              do
              {
                v111 = *v109++;
                v73[v111] = 1.0;
                --v110;
              }
              while (v110);
            }
          }
          else
          {
            if (v92)
              v98 = 1;
            else
              v98 = v91 == 0;
            if (v98)
            {
              v311 = *(_QWORD *)(v52 + 96);
              v99 = *(_OWORD *)(v52 + 64);
              v310 = *(_OWORD *)(v52 + 80);
              v100 = *(_OWORD *)(v52 + 16);
              v305 = *(_OWORD *)v52;
              v306 = v100;
              v101 = *(_OWORD *)(v52 + 32);
              HIDWORD(v308) = HIDWORD(*(_OWORD *)(v52 + 48));
              *(_OWORD *)v309 = v99;
              v307 = v101;
              HIDWORD(v311) = 0;
              *(_QWORD *)&v308 = 0x3FF0000000000000;
              DWORD2(v308) = 2;
              v309[0] = malloc_type_malloc(8uLL, 0x100004052888210uLL);
              v102 = (double *)malloc_type_malloc(0x10uLL, 0x100004000313F17uLL);
              v309[1] = v102;
              *(_QWORD *)v309[0] = 0xFFFFFFFF00000001;
              *v102 = v70;
              v102[1] = v71;
              v103 = svm_train(&v312, &v305);
              v104 = (int **)v103;
              if ((int)v81 >= v82)
              {
                if (v103)
                  goto LABEL_100;
              }
              else
              {
                v105 = v82;
                v106 = &v72[(int)v81];
                v107 = v105 - (int)v81;
                do
                {
                  svm_predict_values((uint64_t)v104, *((double **)v300 + *v106), &v73[*v106]);
                  v108 = *v106++;
                  v73[v108] = v73[v108] * (double)*v104[20];
                  --v107;
                }
                while (v107);
LABEL_100:
                svm_free_model_content((uint64_t)v104);
                free(v104);
              }
              free(v309[0]);
              free(v309[1]);
              goto LABEL_102;
            }
            if ((int)v81 < v82)
            {
              v112 = &v72[(int)v81];
              v113 = v82 - (uint64_t)(int)v81;
              do
              {
                v114 = *v112++;
                v73[v114] = -1.0;
                --v113;
              }
              while (v113);
            }
          }
        }
        else if ((int)v81 < v82)
        {
          v94 = &v72[(int)v81];
          v95 = v82 - (uint64_t)(int)v81;
          do
          {
            v96 = *v94++;
            v73[v96] = 0.0;
            --v95;
          }
          while (v95);
        }
LABEL_102:
        free(v314);
        free(v313);
      }
      while (v79 != 5);
      v115 = v298;
      v116 = v298;
      v117 = (double *)v299;
      v118 = 0.0;
      v119 = 0.0;
      v120 = 0.0;
      if (v298 >= 1)
      {
        v121 = (double *)v299;
        v122 = v298;
        do
        {
          v123 = *v121++;
          if (v123 <= 0.0)
            v120 = v120 + 1.0;
          else
            v119 = v119 + 1.0;
          --v122;
        }
        while (v122);
      }
      v124 = (double *)malloc_type_malloc(8 * v298, 0x100004000313F17uLL);
      v291[v290] = 0;
      v125 = log((v120 + 1.0) / (v119 + 1.0));
      v289[v290] = v125;
      v281 = v115;
      if ((int)v116 < 1)
      {
        v131 = v289;
        v135 = v125;
      }
      else
      {
        v126 = (v119 + 1.0) / (v119 + 2.0);
        v118 = 0.0;
        v127 = v124;
        v128 = v73;
        v129 = v116;
        v130 = 1.0 / (v120 + 2.0);
        v131 = v289;
        do
        {
          v132 = *v117++;
          if (v132 <= 0.0)
            v133 = v130;
          else
            v133 = v126;
          *v127++ = v133;
          v134 = *v128++;
          v135 = v289[v290];
          v136 = v135 + v134 * *(double *)&v291[v290];
          v137 = -v136;
          if (v136 >= 0.0)
          {
            v138 = v133;
          }
          else
          {
            v137 = v136;
            v138 = v133 + v57;
          }
          v139 = exp(v137);
          v118 = v118 + log(v139 + 1.0) + v138 * v136;
          --v129;
        }
        while (v129);
      }
      v289 = v131;
      v140 = 0;
      v54 = v291;
      v52 = v276;
      v56 = v290;
      v141 = 1.0;
      v142 = v135;
      while (1)
      {
        v296 = v118;
        v297 = v142;
        if (v281 < 1)
        {
          v149 = 0.0;
          v151 = 1.0e-12;
          v150 = 1.0e-12;
          v148 = 0.0;
          v144 = 0.0;
        }
        else
        {
          v143 = *(double *)&v54[v56];
          v144 = 0.0;
          v145 = v73;
          v146 = v124;
          v147 = v116;
          v148 = 0.0;
          v149 = 0.0;
          v150 = 1.0e-12;
          v151 = 1.0e-12;
          do
          {
            v152 = *v145;
            v153 = v142 + *v145 * v143;
            if (v153 >= 0.0)
            {
              v157 = exp(-v153);
              v142 = v297;
              v155 = v157 / (v157 + v141);
              v156 = v141 / (v157 + v141);
            }
            else
            {
              v154 = exp(v153);
              v142 = v297;
              v155 = v141 / (v154 + v141);
              v156 = v154 / (v154 + v141);
            }
            v158 = v155 * v156;
            v150 = v150 + v152 * v152 * v158;
            v151 = v151 + v158;
            v159 = *v146++;
            v149 = v149 + v152 * v158;
            v148 = v148 + v152 * (v159 - v155);
            v144 = v144 + v159 - v155;
            ++v145;
            --v147;
          }
          while (v147);
        }
        v56 = v290;
        v54 = v291;
        if (fabs(v148) < 0.00001 && fabs(v144) < 0.00001)
          break;
        v160 = v150 * v151 - v149 * v149;
        v294 = -(v150 * v144 + -v149 * v148) / v160;
        v295 = -(v151 * v148 - v149 * v144) / v160;
        v292 = *(double *)&v291[v290];
        v293 = v144 * v294 + v148 * v295;
        v161 = 1.0;
        while (1)
        {
          v162 = v292 + v161 * v295;
          v163 = v142 + v161 * v294;
          v164 = 0.0;
          if ((int)v116 >= 1)
          {
            v165 = v73;
            v166 = v124;
            v167 = v116;
            do
            {
              v168 = *v165++;
              v169 = v168;
              v170 = *v166++;
              v171 = v170;
              v172 = v163 + v169 * v162;
              v173 = -v172;
              v174 = v170 + -1.0;
              if (v172 >= 0.0)
              {
                v175 = v171;
              }
              else
              {
                v173 = v172;
                v175 = v174;
              }
              v176 = exp(v173);
              v164 = v164 + log(v176 + 1.0) + v175 * v172;
              --v167;
            }
            while (v167);
          }
          if (v164 < v296 + v161 * 0.0001 * v293)
            break;
          v161 = v161 * 0.5;
          v142 = v297;
          if (v161 < 1.0e-10)
          {
            v56 = v290;
            v54 = v291;
            v141 = 1.0;
            v118 = v296;
            goto LABEL_142;
          }
        }
        v56 = v290;
        v54 = v291;
        *(double *)&v291[v290] = v162;
        v289[v290] = v163;
        v142 = v163;
        v118 = v164;
        v141 = 1.0;
LABEL_142:
        if (v161 < 1.0e-10)
        {
          info("Line search fails in two-class probability estimates\n");
          break;
        }
        if (++v140 == 100)
        {
          info("Reaching maximal iterations in two-class probability estimates\n");
          break;
        }
      }
      free(v124);
      free(v73);
      free(v72);
      v36 = v273;
      v33 = v274;
      v42 = v275;
      v57 = -1.0;
      v64 = v282;
      v60 = v283;
LABEL_147:
      v177 = (double *)svm_train_one(&v298, v52, v42[v288], v42[v60]);
      v178 = (double **)&v280[2 * v56];
      *v178 = v177;
      v178[1] = v179;
      v180 = v287;
      if ((int)v287 >= 1)
      {
        v181 = &v279[v284];
        v182 = v177;
        do
        {
          if (!*v181 && *v182 != 0.0)
            *v181 = 1;
          ++v181;
          ++v182;
          --v180;
        }
        while (v180);
      }
      if ((int)v64 >= 1)
      {
        v183 = &v177[v285];
        v184 = &v279[v286];
        do
        {
          if (!*v184 && *v183 != 0.0)
            *v184 = 1;
          ++v183;
          ++v184;
          --v64;
        }
        while (v64);
      }
      free(v300);
      free(v299);
      ++v56;
      ++v60;
      v55 = v288;
    }
    while (v60 != v33);
    v5 = v269;
    v34 = v270;
    v59 = v271;
    v58 = v272;
LABEL_161:
    ++v58;
    v55 = v59;
  }
  while (v59 != v33);
LABEL_162:
  *((_DWORD *)v5 + 26) = v33;
  v185 = 4 * v34;
  v186 = malloc_type_malloc(4 * v34, 0x100004052888210uLL);
  *((_QWORD *)v5 + 20) = v186;
  if ((int)v33 >= 1)
  {
    v187 = (int *)v303;
    v188 = v33;
    do
    {
      v189 = *v187++;
      *v186++ = v189;
      --v188;
    }
    while (v188);
  }
  v190 = malloc_type_malloc(v262, 0x100004000313F17uLL);
  *((_QWORD *)v5 + 16) = v190;
  if (v268 > 1)
  {
    v191 = v263;
    v192 = v280 + 1;
    do
    {
      v193 = *v192;
      v192 += 2;
      *v190++ = v193;
      --v191;
    }
    while (v191);
  }
  if (*(_DWORD *)(v52 + 100))
  {
    *((_QWORD *)v5 + 17) = malloc_type_malloc(v262, 0x100004000313F17uLL);
    v194 = malloc_type_malloc(v262, 0x100004000313F17uLL);
    *((_QWORD *)v5 + 18) = v194;
    if (v268 > 1)
    {
      v195 = (_QWORD *)*((_QWORD *)v5 + 17);
      v196 = v263;
      v197 = v289;
      do
      {
        v198 = *v54++;
        *v195++ = v198;
        v199 = *(_QWORD *)v197++;
        *v194++ = v199;
        --v196;
      }
      while (v196);
    }
  }
  else
  {
    *((_QWORD *)v5 + 17) = 0;
    *((_QWORD *)v5 + 18) = 0;
  }
  v200 = (int *)malloc_type_malloc(4 * v34, 0x100004052888210uLL);
  v201 = malloc_type_malloc(4 * v34, 0x100004052888210uLL);
  *((_QWORD *)v5 + 21) = v201;
  if ((int)v33 < 1)
  {
    v203 = 0;
  }
  else
  {
    v202 = 0;
    v203 = 0;
    v204 = v301;
    v205 = v302;
    do
    {
      v206 = v204->u32[v202];
      if ((int)v206 < 1)
      {
        v207 = 0;
      }
      else
      {
        v207 = 0;
        v208 = &v279[v205[v202]];
        do
        {
          v209 = *v208++;
          v203 += v209;
          v207 += v209;
          --v206;
        }
        while (v206);
      }
      v201[v202] = v207;
      v200[v202++] = v207;
    }
    while (v202 != v33);
  }
  info("Total nSV = %d\n", v203);
  *((_DWORD *)v5 + 27) = v203;
  v210 = 8 * v203;
  *((_QWORD *)v5 + 14) = malloc_type_malloc(v210, 0x2004093837F09uLL);
  v211 = malloc_type_malloc(4 * v203, 0x100004052888210uLL);
  v212 = (unsigned __int8 *)v279;
  *((_QWORD *)v5 + 19) = v211;
  if ((int)v265 >= 1)
  {
    v213 = 0;
    v214 = size;
    v215 = v36;
    v216 = v267;
    do
    {
      if (*v212++)
      {
        *(_QWORD *)(*((_QWORD *)v5 + 14) + 8 * v213) = *v215;
        *(_DWORD *)(*((_QWORD *)v5 + 19) + 4 * v213++) = *v216 + 1;
      }
      ++v216;
      ++v215;
      --v214;
    }
    while (v214);
  }
  v218 = malloc_type_malloc(v185, 0x100004052888210uLL);
  v219 = (double *)v218;
  *v218 = 0;
  if ((int)v33 <= 1)
  {
    *((_QWORD *)v5 + 15) = malloc_type_malloc(8 * (int)v266, 0x80040B8603338uLL);
    v226 = v5 + 120;
  }
  else
  {
    v220 = 0;
    v221 = v218 + 1;
    v222 = v33 - 1;
    v223 = v200;
    do
    {
      v224 = *v223++;
      v220 += v224;
      *v221++ = v220;
      --v222;
    }
    while (v222);
    v225 = 0;
    *((_QWORD *)v5 + 15) = malloc_type_malloc(8 * (int)v266, 0x80040B8603338uLL);
    v226 = v5 + 120;
    do
    {
      *(_QWORD *)(*v226 + v225) = malloc_type_malloc(v210, 0x100004000313F17uLL);
      v225 += 8;
    }
    while (8 * v266 != v225);
    v33 = v274;
  }
  v228 = v301;
  v227 = v302;
  if ((int)v33 >= 1)
  {
    v229 = 0;
    LODWORD(v230) = 0;
    v231 = 1;
    do
    {
      v232 = v229 + 1;
      if (v229 + 1 < v270)
      {
        v233 = v228->u32[v229];
        v234 = *((_DWORD *)v219 + v229);
        v230 = (int)v230;
        v235 = &v279[v227[v229]];
        v236 = v231;
        do
        {
          v237 = v227[v236];
          v238 = v228->u32[v236];
          if ((int)v233 >= 1)
          {
            v239 = 0;
            v240 = v234;
            do
            {
              if (v235[v239])
                *(_QWORD *)(*(_QWORD *)(*v226 + 8 * (v236 - 1)) + 8 * v240++) = *(_QWORD *)(v280[2 * v230] + 8 * v239);
              ++v239;
            }
            while (v233 != v239);
          }
          if ((int)v238 >= 1)
          {
            v241 = *((_DWORD *)v219 + v236);
            v242 = &v279[v237];
            v243 = 8 * (int)v233;
            do
            {
              if (*v242++)
                *(_QWORD *)(*(_QWORD *)(*v226 + 8 * v229) + 8 * v241++) = *(_QWORD *)(v280[2 * v230] + v243);
              v243 += 8;
              --v238;
            }
            while (v238);
          }
          ++v230;
          ++v236;
        }
        while (v236 != v33);
      }
      ++v231;
      ++v229;
    }
    while (v232 != v33);
  }
  free(v303);
  free(v291);
  free(v289);
  free(v228);
  free(v267);
  free(v227);
  free(v36);
  free(v275);
  free(v279);
  if (v268 > 1)
  {
    v245 = v263;
    v246 = (void **)v280;
    do
    {
      v247 = *v246;
      v246 += 2;
      free(v247);
      --v245;
    }
    while (v245);
  }
  free(v280);
  free(v200);
LABEL_232:
  free(v219);
  return v5;
}

_QWORD *svm_train_one(int *a1, uint64_t a2, double a3, double a4)
{
  _QWORD *v8;
  int v9;
  uint64_t v10;
  _QWORD *v11;
  char *v12;
  char *v13;
  double *v14;
  _QWORD *v15;
  _QWORD *v16;
  char *v17;
  uint64_t v18;
  double v19;
  char v20;
  double v21;
  double *v22;
  uint64_t v23;
  double v24;
  char *v25;
  double *v26;
  int v27;
  size_t v28;
  void *v29;
  char *v30;
  int v31;
  int v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  double *v36;
  uint64_t v37;
  uint64_t v38;
  double v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  double v43;
  uint64_t v44;
  double v45;
  double v46;
  double v47;
  uint64_t v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  double v52;
  double *v53;
  double *v54;
  double *v55;
  _BYTE *v56;
  uint64_t v57;
  double v58;
  double v59;
  double v60;
  int v61;
  uint64_t i;
  uint64_t v63;
  uint64_t v64;
  double v65;
  uint64_t v66;
  char *v67;
  double *v68;
  char *v69;
  uint64_t v70;
  double v71;
  char v72;
  double v73;
  unsigned __int8 *v74;
  double *v75;
  uint64_t v76;
  double v77;
  int v78;
  int v79;
  double v80;
  double v81;
  char *v82;
  double v83;
  int v84;
  double v85;
  char *v86;
  double *v87;
  int v88;
  float64x2_t v89;
  unsigned int v90;
  uint64_t v91;
  unint64_t v92;
  int v93;
  int v94;
  uint64_t v95;
  double v96;
  double v97;
  double v99;
  float64x2_t v100;
  double v101;
  double v102;
  double v103;
  _QWORD v104[16];
  _QWORD v105[15];
  float64x2_t *v106;

  v8 = malloc_type_malloc(8 * *a1, 0x100004000313F17uLL);
  switch(*(_DWORD *)a2)
  {
    case 0:
      v9 = *a1;
      v10 = *a1;
      v11 = (_QWORD *)operator new[]();
      v12 = (char *)operator new[]();
      v13 = v12;
      if (v9 >= 1)
      {
        v14 = (double *)*((_QWORD *)a1 + 1);
        v15 = v8;
        v16 = v11;
        v17 = v12;
        v18 = v10;
        do
        {
          *v15++ = 0;
          *v16++ = 0xBFF0000000000000;
          v19 = *v14++;
          if (v19 > 0.0)
            v20 = 1;
          else
            v20 = -1;
          *v17++ = v20;
          --v18;
        }
        while (v18);
      }
      v105[0] = &off_24C255ED8;
      CPMLLibSVM::SVC_Q::SVC_Q(v104, a1, a2, v12);
      CPMLLibSVM::Solver::Solve((uint64_t)v105, v10, (uint64_t)v104, v11, v13, v8, (uint64_t)&v100, *(_DWORD *)(a2 + 96), a3, a4, *(double *)(a2 + 40));
      CPMLLibSVM::SVC_Q::~SVC_Q((CPMLLibSVM::SVC_Q *)v104);
      v21 = 0.0;
      if ((int)v10 >= 1)
      {
        v22 = (double *)v8;
        v23 = v10;
        do
        {
          v24 = *v22++;
          v21 = v21 + v24;
          --v23;
        }
        while (v23);
      }
      if (a3 == a4)
        info("nu = %f\n", v21 / ((double)*a1 * a3));
      if ((int)v10 >= 1)
      {
        v25 = v13;
        v26 = (double *)v8;
        do
        {
          v27 = *v25++;
          *v26 = *v26 * (double)v27;
          ++v26;
          --v10;
        }
        while (v10);
      }
      goto LABEL_69;
    case 1:
      v63 = *a1;
      v64 = *a1;
      v65 = *(double *)(a2 + 80);
      v66 = operator new[]();
      v67 = (char *)v66;
      if ((int)v63 < 1)
      {
        v82 = (char *)operator new[]();
      }
      else
      {
        v68 = (double *)*((_QWORD *)a1 + 1);
        v69 = (char *)v66;
        v70 = v64;
        do
        {
          v71 = *v68++;
          if (v71 > 0.0)
            v72 = 1;
          else
            v72 = -1;
          *v69++ = v72;
          --v70;
        }
        while (v70);
        v73 = v65 * (double)(int)v64 * 0.5;
        v74 = (unsigned __int8 *)v66;
        v75 = (double *)v8;
        v76 = v64;
        v77 = v73;
        do
        {
          v79 = *v74++;
          v78 = v79;
          if (v73 <= 1.0)
            v80 = v73;
          else
            v80 = 1.0;
          if (v77 <= 1.0)
            v81 = v77;
          else
            v81 = 1.0;
          if (v78 == 1)
          {
            v80 = v81;
            v77 = v77 - v81;
          }
          else
          {
            v73 = v73 - v80;
          }
          *v75++ = v80;
          --v76;
        }
        while (v76);
        v82 = (char *)operator new[]();
        bzero(v82, 8 * v64);
      }
      v105[0] = &off_24C255F10;
      CPMLLibSVM::SVC_Q::SVC_Q(v104, a1, a2, v67);
      v83 = *(double *)(a2 + 40);
      v84 = *(_DWORD *)(a2 + 96);
      v106 = &v100;
      CPMLLibSVM::Solver::Solve((uint64_t)v105, v63, (uint64_t)v104, v82, v67, v8, (uint64_t)&v100, v84, 1.0, 1.0, v83);
      CPMLLibSVM::SVC_Q::~SVC_Q((CPMLLibSVM::SVC_Q *)v104);
      v99 = v103;
      v85 = 1.0 / v103;
      info("C = %f\n", 1.0 / v103);
      if ((int)v64 >= 1)
      {
        v86 = v67;
        v87 = (double *)v8;
        do
        {
          v88 = *v86++;
          *v87 = *v87 * ((double)v88 / v99);
          ++v87;
          --v64;
        }
        while (v64);
      }
      v89.f64[0] = v99 * v99;
      v89.f64[1] = v99;
      v100 = vdivq_f64(v100, v89);
      v101 = v85;
      v102 = v85;
      MEMORY[0x20BD188CC](v67, 0x1000C8077774924);
      v33 = v82;
      v90 = 3227415;
      goto LABEL_71;
    case 2:
      v28 = *a1;
      v29 = (void *)operator new[]();
      v30 = (char *)operator new[]();
      v31 = *a1;
      v32 = (int)(*(double *)(a2 + 80) * (double)*a1);
      if (v32 >= 1)
        memset_pattern16(v8, &unk_209D00180, 8 * (int)(*(double *)(a2 + 80) * (double)*a1));
      if (v31 > v32)
        *(double *)&v8[v32] = -((double)v32 - *(double *)(a2 + 80) * (double)v31);
      if (v32 + 1 < (int)v28)
        bzero(&v8[v32 + 1], 8 * (v28 - v32 - 2) + 8);
      if ((int)v28 >= 1)
      {
        bzero(v29, 8 * v28);
        memset(v30, 1, v28);
      }
      v105[0] = &off_24C255ED8;
      CPMLLibSVM::ONE_CLASS_Q::ONE_CLASS_Q(v104, a1, a2);
      CPMLLibSVM::Solver::Solve((uint64_t)v105, v28, (uint64_t)v104, v29, v30, v8, (uint64_t)&v100, *(_DWORD *)(a2 + 96), 1.0, 1.0, *(double *)(a2 + 40));
      CPMLLibSVM::ONE_CLASS_Q::~ONE_CLASS_Q((CPMLLibSVM::ONE_CLASS_Q *)v104);
      MEMORY[0x20BD188CC](v29, 0x1000C8000313F17);
      v33 = v30;
      goto LABEL_70;
    case 3:
      v34 = *a1;
      v35 = *a1;
      v36 = (double *)operator new[]();
      v11 = (_QWORD *)operator new[]();
      v37 = operator new[]();
      v13 = (char *)v37;
      if ((int)v34 >= 1)
      {
        v38 = 0;
        v39 = *(double *)(a2 + 88);
        v40 = *((_QWORD *)a1 + 1);
        v41 = v35;
        v42 = v35;
        do
        {
          v36[v38] = 0.0;
          v43 = *(double *)(v40 + 8 * v38);
          *(double *)&v11[v38] = v39 - v43;
          *(_BYTE *)(v37 + v38) = 1;
          v36[v41] = 0.0;
          *(double *)&v11[v41] = v39 + v43;
          *(_BYTE *)(v37 + v41) = -1;
          ++v38;
          ++v41;
          --v42;
        }
        while (v42);
      }
      v104[0] = &off_24C255ED8;
      CPMLLibSVM::SVR_Q::SVR_Q((uint64_t)v105, (uint64_t)a1, a2);
      CPMLLibSVM::Solver::Solve((uint64_t)v104, 2 * v34, (uint64_t)v105, v11, v13, v36, (uint64_t)&v100, *(_DWORD *)(a2 + 96), *(double *)(a2 + 48), *(double *)(a2 + 48), *(double *)(a2 + 40));
      CPMLLibSVM::SVR_Q::~SVR_Q((CPMLLibSVM::SVR_Q *)v105);
      if ((int)v35 < 1)
      {
        v45 = 0.0;
      }
      else
      {
        v44 = 0;
        v45 = 0.0;
        do
        {
          v46 = v36[v44];
          v47 = v36[v35 + v44];
          *(double *)&v8[v44] = v46 - v47;
          v45 = v45 + vabdd_f64(v46, v47);
          ++v44;
        }
        while (v35 != v44);
      }
      info("nu = %f\n", v45 / (*(double *)(a2 + 48) * (double)(int)v35));
      goto LABEL_68;
    case 4:
      v48 = *a1;
      v49 = *a1;
      v50 = *(double *)(a2 + 48);
      v36 = (double *)operator new[]();
      v11 = (_QWORD *)operator new[]();
      v51 = operator new[]();
      v13 = (char *)v51;
      if ((int)v48 >= 1)
      {
        v52 = v50 * *(double *)(a2 + 80) * (double)(int)v49 * 0.5;
        v53 = (double *)*((_QWORD *)a1 + 1);
        v54 = v36;
        v55 = (double *)v11;
        v56 = (_BYTE *)v51;
        v57 = v49;
        do
        {
          if (v52 >= v50)
            v58 = v50;
          else
            v58 = v52;
          v54[v49] = v58;
          *v54++ = v58;
          v59 = *v53++;
          v52 = v52 - v58;
          v55[v49] = v59;
          v56[v49] = -1;
          *v55++ = -v59;
          *v56++ = 1;
          --v57;
        }
        while (v57);
      }
      v105[0] = &off_24C255F10;
      CPMLLibSVM::SVR_Q::SVR_Q((uint64_t)v104, (uint64_t)a1, a2);
      v60 = *(double *)(a2 + 40);
      v61 = *(_DWORD *)(a2 + 96);
      v106 = &v100;
      CPMLLibSVM::Solver::Solve((uint64_t)v105, 2 * v48, (uint64_t)v104, v11, v13, v36, (uint64_t)&v100, v61, v50, v50, v60);
      CPMLLibSVM::SVR_Q::~SVR_Q((CPMLLibSVM::SVR_Q *)v104);
      info("epsilon = %f\n", -v103);
      if ((int)v49 >= 1)
      {
        for (i = 0; i != v49; ++i)
          *(double *)&v8[i] = v36[i] - v36[v49 + i];
      }
LABEL_68:
      MEMORY[0x20BD188CC](v36, 0x1000C8000313F17);
LABEL_69:
      MEMORY[0x20BD188CC](v11, 0x1000C8000313F17);
      v33 = v13;
LABEL_70:
      v90 = 2004306212;
LABEL_71:
      MEMORY[0x20BD188CC](v33, v90 | 0x1000C8000000000);
      break;
    default:
      break;
  }
  info("obj = %f, rho = %f\n", v100.f64[0], v100.f64[1]);
  v91 = *a1;
  if ((int)v91 >= 1)
  {
    v92 = 0;
    v93 = 0;
    v94 = 0;
    v95 = 8 * v91;
    while (1)
    {
      v96 = *(double *)&v8[v92 / 8];
      if (v96 != 0.0)
      {
        v97 = fabs(v96);
        ++v94;
        if (*(double *)(*((_QWORD *)a1 + 1) + v92) > 0.0)
        {
          if (v97 < v101)
            goto LABEL_80;
LABEL_79:
          ++v93;
          goto LABEL_80;
        }
        if (v97 >= v102)
          goto LABEL_79;
      }
LABEL_80:
      v92 += 8;
      if (v95 == v92)
        goto LABEL_83;
    }
  }
  v94 = 0;
  v93 = 0;
LABEL_83:
  info("nSV = %d, nBSV = %d\n", v94, v93);
  return v8;
}

void sub_209CCA894(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_list va;

  va_start(va, a11);
  CPMLLibSVM::SVC_Q::~SVC_Q((CPMLLibSVM::SVC_Q *)va);
  _Unwind_Resume(a1);
}

void svm_group_classes(int *a1, int *a2, _QWORD *a3, _QWORD *a4, int32x2_t **a5, uint64_t a6)
{
  uint64_t v10;
  uint64_t v11;
  _DWORD *v12;
  int32x2_t *v13;
  int *v14;
  uint64_t v15;
  int v16;
  int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _DWORD *v21;
  _DWORD *v22;
  int v23;
  _DWORD *v24;
  uint64_t v25;
  int32x2_t *v26;
  __int32 v27;
  uint64_t i;
  int v29;
  _DWORD *v30;
  uint64_t v31;
  int32x2_t *v32;
  __int32 v33;
  _QWORD *v34;
  _QWORD *v35;
  int32x2_t **v36;

  v10 = *a1;
  v11 = *a1;
  v12 = malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
  v13 = (int32x2_t *)malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
  v14 = (int *)malloc_type_malloc(4 * v10, 0x100004052888210uLL);
  if ((int)v10 < 1)
  {
    v16 = 0;
  }
  else
  {
    v34 = a3;
    v35 = a4;
    v36 = a5;
    v15 = 0;
    v16 = 0;
    v17 = 16;
    do
    {
      v18 = (int)*(double *)(*((_QWORD *)a1 + 1) + 8 * v15);
      if (v16 < 1)
      {
        LODWORD(v19) = 0;
      }
      else
      {
        v19 = 0;
        while (v12[v19] != v18)
        {
          if (v16 == ++v19)
          {
            v14[v15] = v16;
            goto LABEL_11;
          }
        }
        ++v13->i32[v19];
      }
      v14[v15] = v19;
      if ((_DWORD)v19 == v16)
      {
LABEL_11:
        if (v16 == v17)
        {
          v17 = 2 * v16;
          v12 = malloc_type_realloc(v12, 8 * v16, 0x100004052888210uLL);
          v13 = (int32x2_t *)malloc_type_realloc(v13, 8 * v16, 0x100004052888210uLL);
        }
        v12[v16] = v18;
        v13->i32[v16++] = 1;
      }
      ++v15;
    }
    while (v15 != v11);
    if (v16 == 2)
    {
      if (*v12 == -1 && v12[1] == 1)
      {
        *(_QWORD *)v12 = 0xFFFFFFFF00000001;
        *v13 = vrev64_s32(*v13);
        v20 = v11;
        v21 = v14;
        do
        {
          *v21 = *v21 == 0;
          ++v21;
          --v20;
        }
        while (v20);
      }
      else
      {
        v16 = 2;
      }
    }
    a4 = v35;
    a5 = v36;
    a3 = v34;
  }
  v22 = malloc_type_malloc(4 * v16, 0x100004052888210uLL);
  *v22 = 0;
  if (v16 > 1)
  {
    v23 = 0;
    v24 = v22 + 1;
    v25 = v16 - 1;
    v26 = v13;
    do
    {
      v27 = v26->i32[0];
      v26 = (int32x2_t *)((char *)v26 + 4);
      v23 += v27;
      *v24++ = v23;
      --v25;
    }
    while (v25);
  }
  if ((int)v11 >= 1)
  {
    for (i = 0; i != v11; ++i)
      *(_DWORD *)(a6 + 4 * (int)v22[v14[i]]++) = i;
  }
  *v22 = 0;
  if (v16 > 1)
  {
    v29 = 0;
    v30 = v22 + 1;
    v31 = v16 - 1;
    v32 = v13;
    do
    {
      v33 = v32->i32[0];
      v32 = (int32x2_t *)((char *)v32 + 4);
      v29 += v33;
      *v30++ = v29;
      --v31;
    }
    while (v31);
  }
  *a2 = v16;
  *a3 = v12;
  *a4 = v22;
  *a5 = v13;
  free(v14);
}

void svm_cross_validation(int *a1, _DWORD *a2, int a3, uint64_t a4)
{
  uint64_t v8;
  int *v9;
  uint64_t v10;
  int *v11;
  BOOL v12;
  uint64_t j;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  int v17;
  int v18;
  int *v19;
  _DWORD *v20;
  _DWORD *v21;
  uint64_t v22;
  int *v23;
  _DWORD *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  _DWORD *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  uint64_t v36;
  int *v37;
  uint64_t v38;
  int *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  int *v43;
  int v44;
  int v45;
  _DWORD *v46;
  uint64_t v47;
  int *v48;
  int v49;
  char v50;
  uint64_t v51;
  _DWORD *v52;
  _DWORD *v53;
  uint64_t v54;
  int v55;
  int v56;
  uint64_t v57;
  int v58;
  int v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  int v63;
  _DWORD *v64;
  uint64_t v65;
  int *v66;
  int v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t k;
  uint64_t v73;
  unsigned int v74;
  uint64_t v75;
  uint64_t v76;
  int *v77;
  uint64_t v78;
  uint64_t v79;
  void *v80;
  void *v81;
  int *v82;
  int v83;
  double v84;
  uint64_t v85;
  int *v86;
  int v87;
  uint64_t v88;
  uint64_t v89;
  int *v90;
  uint64_t v91;
  uint64_t v92;
  _DWORD *v93;
  uint64_t v94;
  int v95;
  uint64_t i;
  uint64_t v97;
  void *v98;
  void *v99;
  void *v100;
  void *v101;
  void *v102;
  unsigned int v103;

  v8 = *a1;
  v9 = (int *)malloc_type_malloc(4 * (int)v8, 0x100004052888210uLL);
  if ((int)v8 < a3)
  {
    fwrite("WARNING: # folds > # data. Will use # folds = # data instead (i.e., leave-one-out cross validation)\n", 0x64uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    a3 = v8;
  }
  v10 = (a3 + 1);
  v11 = (int *)malloc_type_malloc(4 * (int)v10, 0x100004052888210uLL);
  v12 = a3 >= (int)v8 || *a2 >= 2u;
  v93 = a2;
  v94 = a4;
  v95 = v8;
  if (!v12)
  {
    v103 = 0;
    v98 = 0;
    v101 = 0;
    v102 = 0;
    svm_group_classes(a1, (int *)&v103, &v102, &v98, (int32x2_t **)&v101, (uint64_t)v9);
    v90 = (int *)malloc_type_malloc(4 * a3, 0x100004052888210uLL);
    v20 = malloc_type_malloc(4 * (int)v8, 0x100004052888210uLL);
    v21 = v20;
    if ((int)v8 >= 1)
    {
      v22 = v8;
      v23 = v9;
      v24 = v20;
      do
      {
        v25 = *v23++;
        *v24++ = v25;
        --v22;
      }
      while (v22);
    }
    v26 = v103;
    if ((int)v103 >= 1)
    {
      v27 = 0;
      v28 = v101;
      v29 = v98;
      for (i = v103; i != v27; v26 = i)
      {
        if ((int)v28[v27] >= 1)
        {
          v30 = 0;
          v31 = 0;
          do
          {
            v32 = rand();
            v33 = v31 + v29[v27];
            v34 = v33 + v32 % (v30 + v28[v27]);
            v35 = v21[v34];
            v21[v34] = v21[v33];
            v21[v33] = v35;
            ++v31;
            --v30;
          }
          while (v31 < v28[v27]);
        }
        ++v27;
      }
    }
    if (a3 <= 0)
    {
      *v11 = 0;
      v50 = 1;
      LODWORD(v8) = v95;
      v39 = v90;
      v38 = (a3 + 1);
    }
    else
    {
      v36 = 0;
      v37 = (int *)v101;
      v39 = v90;
      v38 = (a3 + 1);
      do
      {
        v90[v36] = 0;
        v40 = v36 + 1;
        if ((int)v26 >= 1)
        {
          v41 = 0;
          v42 = v26;
          v43 = v37;
          do
          {
            v44 = *v43++;
            v41 += v44 * (int)v40 / a3 - v44 * (int)v36 / a3;
            v90[v36] = v41;
            --v42;
          }
          while (v42);
        }
        ++v36;
      }
      while (v40 != a3);
      *v11 = 0;
      v45 = 0;
      v46 = v11 + 1;
      v47 = (a3 + 1) - 1;
      v48 = v90;
      do
      {
        v49 = *v48++;
        v45 += v49;
        *v46++ = v45;
        --v47;
      }
      while (v47);
      v50 = 0;
      LODWORD(v8) = v95;
    }
    if ((int)v26 >= 1)
    {
      v51 = 0;
      v52 = v98;
      v53 = v101;
      do
      {
        if (a3 >= 1)
        {
          v54 = 0;
          do
          {
            v55 = v53[v51];
            v56 = v55 * (int)v54 / a3;
            v57 = v54 + 1;
            v58 = v55 * ((int)v54 + 1) / a3;
            if (v56 < v58)
            {
              v59 = v52[v51];
              v60 = v56 + v59;
              v61 = v58 + v59;
              v62 = v11[v54];
              do
              {
                v9[v62] = v21[v60];
                v62 = v11[v54] + 1;
                v11[v54] = v62;
                ++v60;
              }
              while (v60 < v61);
            }
            ++v54;
          }
          while (v57 != a3);
        }
        ++v51;
      }
      while (v51 != v26);
    }
    *v11 = 0;
    if ((v50 & 1) == 0)
    {
      v63 = 0;
      v64 = v11 + 1;
      v65 = v38 - 1;
      v66 = v39;
      do
      {
        v67 = *v66++;
        v63 += v67;
        *v64++ = v63;
        --v65;
      }
      while (v65);
    }
    free(v98);
    free(v102);
    free(v101);
    free(v21);
    free(v39);
    goto LABEL_49;
  }
  if ((int)v8 >= 1)
  {
    for (j = 0; j != v8; ++j)
      v9[j] = j;
    v14 = 0;
    v15 = v8;
    do
    {
      v16 = v14 + rand() % (int)v15;
      v17 = v9[v14];
      v9[v14] = v9[v16];
      v9[v16] = v17;
      ++v14;
      --v15;
    }
    while (v15);
  }
  if ((a3 & 0x80000000) == 0)
  {
    v18 = 0;
    v19 = v11;
    do
    {
      *v19++ = v18 / a3;
      v18 += v8;
      --v10;
    }
    while (v10);
LABEL_49:
    if (a3 >= 1)
    {
      v68 = 0;
      v91 = (int)v8;
      v92 = a3;
      do
      {
        v69 = v11[v68];
        v70 = v68 + 1;
        v71 = v11[v70];
        LODWORD(v98) = v69 - v71 + v8;
        v100 = malloc_type_malloc(8 * (int)v98, 0x2004093837F09uLL);
        v99 = malloc_type_malloc(8 * (int)v98, 0x100004000313F17uLL);
        v97 = v70;
        if ((int)v69 < 1)
        {
          v74 = 0;
        }
        else
        {
          for (k = 0; k != v69; ++k)
          {
            v73 = v9[k];
            *((_QWORD *)v100 + k) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v73);
            *((_QWORD *)v99 + k) = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v73);
          }
          v74 = v69;
        }
        if ((int)v71 < (int)v8)
        {
          v75 = v91 - v71;
          v76 = 8 * v74;
          v77 = &v9[v71];
          do
          {
            v78 = *v77++;
            *(_QWORD *)((char *)v100 + v76) = *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * v78);
            *(_QWORD *)((char *)v99 + v76) = *(_QWORD *)(*((_QWORD *)a1 + 1) + 8 * v78);
            v76 += 8;
            --v75;
          }
          while (v75);
        }
        v79 = svm_train(&v98, v93);
        v80 = (void *)v79;
        if (v93[25] && *v93 <= 1u)
        {
          v81 = malloc_type_malloc(8 * *(int *)(v79 + 104), 0x100004000313F17uLL);
          if ((int)v69 < (int)v71)
          {
            v82 = &v9[(int)v69];
            v83 = v71 - v69;
            do
            {
              v84 = svm_predict_probability((uint64_t)v80, *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * *v82), (uint64_t)v81);
              v85 = *v82++;
              *(double *)(v94 + 8 * v85) = v84;
              --v83;
            }
            while (v83);
          }
          free(v81);
        }
        else if ((int)v69 < (int)v71)
        {
          v86 = &v9[(int)v69];
          v87 = v71 - v69;
          do
          {
            svm_predict((uint64_t)v80, *(_QWORD *)(*((_QWORD *)a1 + 2) + 8 * *v86));
            v88 = *v86++;
            *(_QWORD *)(v94 + 8 * v88) = v89;
            --v87;
          }
          while (v87);
        }
        if (v80)
        {
          svm_free_model_content((uint64_t)v80);
          free(v80);
        }
        free(v100);
        free(v99);
        LODWORD(v8) = v95;
        v68 = v97;
      }
      while (v97 != v92);
    }
  }
  free(v11);
  free(v9);
}

uint64_t svm_get_nr_class(uint64_t a1)
{
  return *(unsigned int *)(a1 + 104);
}

double svm_predict_probability(uint64_t a1, uint64_t a2, uint64_t a3)
{
  _QWORD *v4;
  uint64_t v6;
  double *v7;
  double *v8;
  uint64_t v9;
  void **v10;
  void **v11;
  uint64_t v12;
  void **v13;
  int v14;
  void **v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void **v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  double v27;
  double v28;
  double v29;
  double v30;
  int v31;
  void **v32;
  _QWORD *v33;
  double v34;
  uint64_t v35;
  uint64_t *v36;
  uint64_t v37;
  uint64_t v38;
  _QWORD *v39;
  uint64_t i;
  double v41;
  uint64_t v42;
  double *v43;
  double *v44;
  uint64_t *v45;
  uint64_t v46;
  uint64_t v47;
  double v48;
  double v49;
  uint64_t v50;
  double result;
  int v52;
  double v53;
  uint64_t v54;
  double v55;
  uint64_t v56;
  double *v57;
  double v58;
  uint64_t v59;
  double v60;
  double v61;
  uint64_t v62;
  uint64_t v63;
  double *v64;
  double v65;
  double v66;
  double v67;
  void **v68;
  uint64_t v69;
  void *v70;
  int v71;
  uint64_t v72;
  uint64_t v73;
  void **v74;
  void *v75;
  uint64_t v76;
  _QWORD *v77;
  double *v78;
  void **v79;
  int v80;
  int v81;
  uint64_t size;
  uint64_t v83;

  v4 = (_QWORD *)a1;
  if (*(_DWORD *)a1 <= 1u && *(_QWORD *)(a1 + 136) && *(_QWORD *)(a1 + 144))
  {
    v6 = *(int *)(a1 + 104);
    v7 = (double *)malloc_type_malloc(8 * (((int)v6 - 1) * (int)v6 / 2), 0x100004000313F17uLL);
    v8 = (double *)a2;
    v9 = v6;
    v78 = v7;
    svm_predict_values((uint64_t)v4, v8, v7);
    size = 8 * v6;
    v10 = (void **)malloc_type_malloc(8 * v6, 0x80040B8603338uLL);
    v11 = v10;
    v12 = v6;
    v79 = v10;
    v83 = v6;
    if ((int)v6 >= 1)
    {
      v6 = v6;
      v13 = v10;
      do
      {
        *v13++ = malloc_type_malloc(size, 0x100004000313F17uLL);
        --v6;
      }
      while (v6);
      v14 = 0;
      v15 = v11 + 1;
      v16 = v12 - 1;
      v17 = 8;
      v76 = v9;
      v77 = v4;
      do
      {
        v18 = v6 + 1;
        if (v6 + 1 < v9)
        {
          v19 = v11;
          v20 = 0;
          v21 = v4[17];
          v22 = v4[18];
          v23 = &v78[v14];
          v24 = v21 + 8 * v14;
          v80 = v14;
          v25 = v22 + 8 * v14;
          v26 = (uint64_t)v19[v6] + v17;
          do
          {
            v27 = *(double *)(v25 + 8 * v20) + v23[v20] * *(double *)(v24 + 8 * v20);
            if (v27 >= 0.0)
            {
              v28 = exp(-v27);
              v29 = v28;
            }
            else
            {
              v28 = exp(v27);
              v29 = 1.0;
            }
            v30 = fmin(fmax(v29 / (v28 + 1.0), 0.0000001), 0.9999999);
            *(double *)(v26 + 8 * v20) = v30;
            *((double *)v15[v20++] + v6) = 1.0 - v30;
          }
          while (v16 != v20);
          v14 = v80 + v20;
          v9 = v76;
          v4 = v77;
          v11 = v79;
          v18 = v6 + 1;
          v12 = v83;
        }
        ++v15;
        v17 += 8;
        --v16;
        v6 = v18;
      }
      while (v18 != v12);
    }
    if ((int)v9 <= 100)
      v31 = 100;
    else
      v31 = v9;
    v32 = (void **)malloc_type_malloc(size, 0x80040B8603338uLL);
    v33 = malloc_type_malloc(size, 0x100004000313F17uLL);
    v34 = (double)(int)v12;
    if ((int)v12 <= 0)
    {
      v50 = v9;
    }
    else
    {
      v81 = v31;
      v35 = 0;
      v36 = (uint64_t *)(v11 + 1);
      v37 = 1;
      v38 = 1;
      do
      {
        *(double *)(a3 + 8 * v35) = 1.0 / v34;
        v39 = malloc_type_malloc(size, 0x100004000313F17uLL);
        v32[v35] = v39;
        v39[v35] = 0;
        if (v35)
        {
          for (i = 0; i != v35; ++i)
          {
            v41 = *((double *)v11[i] + v35);
            *(double *)&v39[v35] = *(double *)&v39[v35] + v41 * v41;
            v39[i] = *((_QWORD *)v32[i] + v35);
          }
        }
        v42 = v35 + 1;
        if (v35 + 1 < v9)
        {
          v43 = (double *)&v39[v38];
          v44 = (double *)((char *)v11[v35] + v38 * 8);
          v45 = v36;
          v46 = v83;
          do
          {
            v47 = *v45++;
            *(double *)&v39[v35] = *(double *)&v39[v35] + *(double *)(v47 + 8 * v35) * *(double *)(v47 + 8 * v35);
            v48 = *(double *)(v47 + 8 * v35);
            v49 = *v44++;
            *v43++ = -(v48 * v49);
            --v46;
          }
          while (v37 != v46);
        }
        ++v37;
        ++v38;
        ++v36;
        ++v35;
      }
      while (v42 != v83);
      LODWORD(v12) = v83;
      v50 = v83;
      v31 = v81;
    }
    v52 = 0;
    v53 = 0.005 / v34;
    do
    {
      if ((int)v12 < 1)
      {
        if (v53 > 0.0)
          goto LABEL_53;
      }
      else
      {
        v54 = 0;
        v55 = 0.0;
        do
        {
          v56 = 0;
          v33[v54] = 0;
          v57 = (double *)v32[v54];
          v58 = 0.0;
          do
          {
            v58 = v58 + v57[v56] * *(double *)(a3 + 8 * v56);
            *(double *)&v33[v54] = v58;
            ++v56;
          }
          while (v50 != v56);
          v55 = v55 + *(double *)(a3 + 8 * v54++) * v58;
        }
        while (v54 != v50);
        v59 = 0;
        v60 = 0.0;
        do
        {
          v61 = vabdd_f64(*(double *)&v33[v59], v55);
          if (v61 > v60)
            v60 = v61;
          ++v59;
        }
        while (v50 != v59);
        if (v60 < v53)
          goto LABEL_50;
        v62 = 0;
        do
        {
          v63 = 0;
          v64 = (double *)v32[v62];
          v65 = (v55 - *(double *)&v33[v62]) / v64[v62];
          *(double *)(a3 + 8 * v62) = *(double *)(a3 + 8 * v62) + v65;
          v66 = *(double *)&v33[v62] + *(double *)&v33[v62] + v65 * v64[v62];
          v67 = v65 + 1.0;
          do
          {
            *(double *)&v33[v63] = (*(double *)&v33[v63] + v65 * v64[v63]) / v67;
            *(double *)(a3 + 8 * v63) = *(double *)(a3 + 8 * v63) / v67;
            ++v63;
          }
          while (v50 != v63);
          v55 = (v55 + v65 * v66) / v67 / v67;
          ++v62;
        }
        while (v62 != v50);
      }
      ++v52;
    }
    while (v52 != v31);
    info("Exceeds max_iter in multiclass_prob\n", 1.0);
LABEL_50:
    if ((int)v12 >= 1)
    {
      v68 = v32;
      v69 = v50;
      do
      {
        v70 = *v68++;
        free(v70);
        --v69;
      }
      while (v69);
    }
LABEL_53:
    free(v32);
    free(v33);
    if ((int)v12 <= 1)
    {
      v73 = 0;
    }
    else
    {
      v71 = 0;
      v72 = 1;
      do
      {
        if (*(double *)(a3 + 8 * v72) > *(double *)(a3 + 8 * v71))
          v71 = v72;
        ++v72;
      }
      while (v50 != v72);
      v73 = v71;
    }
    if ((int)v9 >= 1)
    {
      v74 = v79;
      do
      {
        v75 = *v74++;
        free(v75);
        --v50;
      }
      while (v50);
    }
    free(v78);
    free(v79);
    return (double)*(int *)(v4[20] + 4 * v73);
  }
  else
  {
    svm_predict(a1, a2);
  }
  return result;
}

void svm_predict(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  double *v4;
  _QWORD v5[2];

  v5[1] = *MEMORY[0x24BDAC8D0];
  v2 = MEMORY[0x24BDAC7A8](a1, a2);
  svm_predict_values(v2, v4, (double *)((char *)v5 - v3));
}

void svm_free_and_destroy_model(void **a1)
{
  void *v2;

  if (a1)
  {
    v2 = *a1;
    if (v2)
    {
      svm_free_model_content((uint64_t)v2);
      free(*a1);
      *a1 = 0;
    }
  }
}

uint64_t svm_get_svm_type(unsigned int *a1)
{
  return *a1;
}

uint64_t svm_get_labels(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 160);
  if (v2 && *(int *)(result + 104) >= 1)
  {
    v3 = 0;
    do
    {
      *(_DWORD *)(a2 + 4 * v3) = *(_DWORD *)(v2 + 4 * v3);
      ++v3;
    }
    while (v3 < *(int *)(result + 104));
  }
  return result;
}

uint64_t svm_get_sv_indices(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;

  v2 = *(_QWORD *)(result + 152);
  if (v2 && *(int *)(result + 108) >= 1)
  {
    v3 = 0;
    do
    {
      *(_DWORD *)(a2 + 4 * v3) = *(_DWORD *)(v2 + 4 * v3);
      ++v3;
    }
    while (v3 < *(int *)(result + 108));
  }
  return result;
}

uint64_t svm_get_nr_sv(uint64_t a1)
{
  return *(unsigned int *)(a1 + 108);
}

double svm_get_svr_probability(uint64_t a1)
{
  uint64_t v1;

  if ((*(_DWORD *)a1 - 3) <= 1)
  {
    v1 = *(_QWORD *)(a1 + 136);
    if (v1)
      return *(double *)v1;
  }
  fwrite("Model doesn't contain information for SVR probability inference\n", 0x40uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
  return 0.0;
}

void svm_predict_values(uint64_t a1, double *a2, double *a3)
{
  uint64_t v5;
  double **v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  double *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  double *v21;
  double **v22;
  double *v23;
  double *v24;
  _DWORD *v25;
  char *v26;
  int v27;
  int *v28;
  _DWORD *v29;
  uint64_t v30;
  int v31;
  _DWORD *v32;
  _DWORD *v33;
  uint64_t v34;
  uint64_t v35;
  int v36;
  char *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  vDSP_Length v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  char *v50;
  uint64_t v51;
  const double *v52;
  double v53;
  uint64_t v54;
  int v55;
  uint64_t v56;
  uint64_t v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  double *v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  int v69;
  uint64_t v70;
  _DWORD *v71;
  uint64_t v72;
  char *v73;
  void *v74;
  const double *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  vDSP_Length __N;
  vDSP_Length __Na;
  uint64_t v82;
  double v83;
  uint64_t __C[8];

  v65 = a3;
  if ((*(_DWORD *)a1 - 2) > 2)
  {
    v13 = *(int *)(a1 + 104);
    v12 = *(int *)(a1 + 108);
    v14 = *(unsigned int *)(a1 + 104);
    v15 = (double *)malloc_type_malloc(8 * v12, 0x100004000313F17uLL);
    v21 = v15;
    if (*(_DWORD *)(a1 + 4) == 2)
    {
      CPMLLibSVM::Kernel::k_function_rbf((uint64_t)a2, a1, (uint64_t)v15, v16, v17, v18, v19, v20, v57, v59, v61, v63, (uint64_t)v65, v66, v68, v70, v72, (uint64_t)v74, v76,
        v77,
        v78,
        __N,
        v82,
        *(uint64_t *)&v83,
        __C[0],
        (uint64_t *)__C[1],
        __C[2],
        __C[3],
        __C[4],
        (uint64_t *)__C[5],
        __C[6],
        __C[7]);
    }
    else
    {
      v12 = v12;
      if ((int)v12 >= 1)
      {
        v22 = *(double ***)(a1 + 112);
        v23 = v15;
        do
        {
          v24 = *v22++;
          *v23++ = CPMLLibSVM::Kernel::k_function(a2, v24, a1);
          --v12;
        }
        while (v12);
      }
    }
    v25 = malloc_type_malloc(4 * v13, 0x100004052888210uLL);
    v26 = (char *)v25;
    *v25 = 0;
    if ((int)v13 > 1)
    {
      v27 = 0;
      v28 = *(int **)(a1 + 168);
      v29 = v25 + 1;
      v30 = v14 - 1;
      do
      {
        v31 = *v28++;
        v27 += v31;
        *v29++ = v27;
        --v30;
      }
      while (v30);
    }
    v32 = malloc_type_malloc(4 * v13, 0x100004052888210uLL);
    v33 = v32;
    if ((int)v14 >= 1)
    {
      v58 = v14;
      v75 = v21;
      v34 = v13;
      bzero(v32, 4 * v13);
      v35 = 0;
      v36 = 0;
      v37 = v26 + 4;
      v60 = -(uint64_t)v13;
      v62 = v13;
      v38 = 1;
      v39 = 4;
      v40 = 0;
      v64 = v13;
      v71 = v33;
      v73 = v26;
      do
      {
        v41 = v40 + 1;
        if (v40 + 1 < v13)
        {
          v67 = v40 + 1;
          v69 = v36;
          v42 = 0;
          v79 = v36;
          do
          {
            v43 = *(int *)&v26[4 * v40];
            v44 = *(int *)&v37[4 * v42];
            v45 = *(_QWORD *)(a1 + 168);
            v46 = *(int *)(v45 + 4 * v40);
            __Na = *(int *)(v45 + v39 + 4 * v42);
            v47 = *(_QWORD *)(a1 + 120);
            v48 = *(_QWORD *)(v47 + v35 + 8 * v42);
            v49 = *(_QWORD *)(v47 + 8 * v40);
            v83 = 0.0;
            __C[0] = 0;
            v50 = v37;
            v51 = v40;
            vDSP_dotprD((const double *)(v48 + 8 * v43), 1, &v75[v43], 1, (double *)__C, v46);
            v52 = (const double *)(v49 + 8 * v44);
            v33 = v71;
            v26 = v73;
            vDSP_dotprD(v52, 1, &v75[v44], 1, &v83, __Na);
            v40 = v51;
            v37 = v50;
            *(double *)__C = v83 + *(double *)__C;
            v53 = *(double *)__C - *(double *)(*(_QWORD *)(a1 + 128) + v79 * 8 + 8 * v42);
            v65[v79 + v42] = v53;
            v54 = v38 + v42;
            if (v53 > 0.0)
              v54 = v51;
            ++v71[v54];
            ++v42;
          }
          while (v60 + v38 + v42);
          v41 = v67;
          v36 = v69 + v42;
          v34 = v62;
          v13 = v64;
        }
        ++v38;
        v39 += 4;
        v37 += 4;
        v35 += 8;
        v40 = v41;
      }
      while (v41 != v34);
      v21 = (double *)v75;
      if (v58 >= 2)
      {
        v55 = 0;
        v56 = 1;
        do
        {
          if (v33[v56] > v33[v55])
            v55 = v56;
          ++v56;
        }
        while (v34 != v56);
      }
    }
    free(v21);
    free(v26);
    free(v33);
  }
  else
  {
    v5 = *(unsigned int *)(a1 + 108);
    if ((int)v5 < 1)
    {
      v8 = 0.0;
    }
    else
    {
      v6 = *(double ***)(a1 + 112);
      v7 = **(double ***)(a1 + 120);
      v8 = 0.0;
      do
      {
        v9 = *v7++;
        v10 = v9;
        v11 = *v6++;
        v8 = v8 + v10 * CPMLLibSVM::Kernel::k_function(a2, v11, a1);
        --v5;
      }
      while (v5);
    }
    *v65 = v8 - **(double **)(a1 + 128);
  }
}

uint64_t svm_save_model(const char *a1, double *a2)
{
  FILE *v3;
  FILE *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t *v21;
  uint64_t v22;
  double *v23;
  int v24;
  double *v25;
  int v26;
  char *v28;
  uint64_t v29;

  v3 = fopen(a1, "w");
  if (!v3)
    return 0xFFFFFFFFLL;
  v4 = v3;
  v5 = setlocale(0, 0);
  v28 = strdup(v5);
  setlocale(0, "C");
  fprintf(v4, "svm_type %s\n", svm_type_table[*(int *)a2]);
  fprintf(v4, "kernel_type %s\n", kernel_type_table[*((int *)a2 + 1)]);
  v6 = *((_DWORD *)a2 + 1);
  if (v6 == 1)
  {
    fprintf(v4, "degree %d\n", *((_DWORD *)a2 + 2));
    v6 = *((_DWORD *)a2 + 1);
  }
  if ((v6 - 1) <= 2)
  {
    fprintf(v4, "gamma %g\n", a2[2]);
    v6 = *((_DWORD *)a2 + 1);
  }
  if ((v6 | 2) == 3)
    fprintf(v4, "coef0 %g\n", a2[3]);
  v8 = *((unsigned int *)a2 + 26);
  v7 = *((unsigned int *)a2 + 27);
  fprintf(v4, "nr_class %d\n", *((_DWORD *)a2 + 26));
  v29 = v7;
  fprintf(v4, "total_sv %d\n", v7);
  fwrite("rho", 3uLL, 1uLL, v4);
  v9 = (v8 - 1) * v8;
  if (v9 >= 0)
    v10 = (v8 - 1) * v8;
  else
    v10 = v9 + 1;
  v11 = (v10 >> 1);
  if (v9 >= 2)
  {
    v12 = 0;
    do
      fprintf(v4, " %g", *(double *)(*((_QWORD *)a2 + 16) + 8 * v12++));
    while (v11 != v12);
  }
  fputc(10, v4);
  if (*((_QWORD *)a2 + 20))
  {
    fwrite("label", 5uLL, 1uLL, v4);
    if ((int)v8 >= 1)
    {
      v13 = 0;
      do
      {
        fprintf(v4, " %d", *(_DWORD *)(*((_QWORD *)a2 + 20) + v13));
        v13 += 4;
      }
      while (4 * v8 != v13);
    }
    fputc(10, v4);
  }
  if (*((_QWORD *)a2 + 17))
  {
    fwrite("probA", 5uLL, 1uLL, v4);
    if (v9 >= 2)
    {
      v14 = 0;
      do
        fprintf(v4, " %g", *(double *)(*((_QWORD *)a2 + 17) + 8 * v14++));
      while (v11 != v14);
    }
    fputc(10, v4);
  }
  if (*((_QWORD *)a2 + 18))
  {
    fwrite("probB", 5uLL, 1uLL, v4);
    if (v9 >= 2)
    {
      v15 = 0;
      do
        fprintf(v4, " %g", *(double *)(*((_QWORD *)a2 + 18) + 8 * v15++));
      while (v11 != v15);
    }
    fputc(10, v4);
  }
  if (*((_QWORD *)a2 + 21))
  {
    fwrite("nr_sv", 5uLL, 1uLL, v4);
    if ((int)v8 >= 1)
    {
      v16 = 0;
      do
      {
        fprintf(v4, " %d", *(_DWORD *)(*((_QWORD *)a2 + 21) + v16));
        v16 += 4;
      }
      while (4 * v8 != v16);
    }
    fputc(10, v4);
  }
  fwrite("SV\n", 3uLL, 1uLL, v4);
  if ((int)v29 >= 1)
  {
    v17 = 0;
    v18 = *((_QWORD *)a2 + 14);
    v19 = (uint64_t *)*((_QWORD *)a2 + 15);
    do
    {
      v20 = (v8 - 1);
      v21 = v19;
      if ((int)v8 >= 2)
      {
        do
        {
          v22 = *v21++;
          fprintf(v4, "%.16g ", *(double *)(v22 + 8 * v17));
          --v20;
        }
        while (v20);
      }
      v23 = *(double **)(v18 + 8 * v17);
      if (*((_DWORD *)a2 + 1) == 4)
      {
        fprintf(v4, "0:%d ", (int)v23[1]);
      }
      else
      {
        v24 = *(_DWORD *)v23;
        if (*(_DWORD *)v23 != -1)
        {
          v25 = v23 + 2;
          do
          {
            fprintf(v4, "%d:%.8g ", v24, *(v25 - 1));
            v26 = *(_DWORD *)v25;
            v25 += 2;
            v24 = v26;
          }
          while (v26 != -1);
        }
      }
      fputc(10, v4);
      ++v17;
    }
    while (v17 != v29);
  }
  setlocale(0, v28);
  free(v28);
  if (ferror(v4))
    return 0xFFFFFFFFLL;
  if (fclose(v4))
    return 0xFFFFFFFFLL;
  return 0;
}

_DWORD *svm_load_model(const char *a1)
{
  FILE *v1;
  FILE *v2;
  char *v3;
  char *v4;
  _DWORD *v5;
  void **v6;
  BOOL v9;
  BOOL v10;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  int v20;
  int v21;
  int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  int v28;
  int v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  FILE *v36;
  const char *v37;
  size_t v38;
  int v40;
  uint64_t v41;
  int v42;
  int v43;
  int v44;
  uint64_t v45;
  unsigned int v46;
  size_t v47;
  uint64_t v48;
  char *v49;
  uint64_t v50;
  int v51;
  uint64_t v52;
  char *v53;
  uint64_t v54;
  char *v55;
  uint64_t v56;
  char *v57;
  char *v58;
  char *v59;
  uint64_t v60;
  double *v61;
  char *v62;
  char *v63;
  _DWORD *v64;
  int v65;
  uint64_t v66;
  char __s2[8];
  int v68;
  uint64_t v69;

  v69 = *MEMORY[0x24BDAC8D0];
  v1 = fopen(a1, "rb");
  if (!v1)
    return 0;
  v2 = v1;
  v3 = setlocale(0, 0);
  v4 = strdup(v3);
  setlocale(0, "C");
  v5 = malloc_type_malloc(0xB8uLL, 0x109004003BC950CuLL);
  *((_OWORD *)v5 + 8) = 0u;
  v6 = (void **)(v5 + 32);
  *((_OWORD *)v5 + 9) = 0u;
  *((_OWORD *)v5 + 10) = 0u;
  if (fscanf(v2, "%80s", __s2) != 1)
  {
LABEL_94:
    fwrite("ERROR: fscanf failed to read model\n", 0x23uLL, 1uLL, (FILE *)*MEMORY[0x24BDAC8D8]);
    setlocale(0, v4);
    free(v4);
    free(*((void **)v5 + 16));
    free(*((void **)v5 + 20));
    free(*((void **)v5 + 21));
    free(v5);
    return 0;
  }
  while (1)
  {
    if (!(*(_QWORD *)__s2 ^ 0x657079745F6D7673 | v68))
    {
      if (fscanf(v2, "%80s", __s2) == 1)
      {
        for (i = 0; i != 5; ++i)
        {
          if (!strcmp(svm_type_table[i], __s2))
          {
            *v5 = i;
            goto LABEL_60;
          }
        }
        v36 = (FILE *)*MEMORY[0x24BDAC8D8];
        v37 = "unknown svm type.\n";
        v38 = 18;
LABEL_93:
        fwrite(v37, v38, 1uLL, v36);
      }
      goto LABEL_94;
    }
    if (*(_QWORD *)__s2 == 0x745F6C656E72656BLL && v68 == 6647929)
    {
      if (fscanf(v2, "%80s", __s2) != 1)
        goto LABEL_94;
      v19 = 0;
      while (strcmp(kernel_type_table[v19], __s2))
      {
        if (++v19 == 5)
        {
          v36 = (FILE *)*MEMORY[0x24BDAC8D8];
          v37 = "unknown kernel function.\n";
          v38 = 25;
          goto LABEL_93;
        }
      }
      v5[1] = v19;
      goto LABEL_60;
    }
    if (*(_DWORD *)__s2 == 1919378788 && *(_DWORD *)&__s2[3] == 6645106)
    {
LABEL_56:
      v20 = fscanf(v2, "%d");
      goto LABEL_59;
    }
    v9 = *(_DWORD *)__s2 == 1835884903 && *(unsigned __int16 *)&__s2[4] == 97;
    if (v9 || (*(_DWORD *)__s2 == 1717923683 ? (v10 = *(unsigned __int16 *)&__s2[4] == 48) : (v10 = 0), v10))
    {
      v20 = fscanf(v2, "%lf");
LABEL_59:
      if (v20 != 1)
        goto LABEL_94;
      goto LABEL_60;
    }
    if (!(*(_QWORD *)__s2 ^ 0x7373616C635F726ELL | v68)
      || !(*(_QWORD *)__s2 ^ 0x76735F6C61746F74 | v68))
    {
      goto LABEL_56;
    }
    if (*(_DWORD *)__s2 != 7301234)
      break;
    v64 = v5 + 26;
    v21 = (*v64 - 1) * *v64;
    if (v21 >= 0)
      v22 = (*v64 - 1) * *v64;
    else
      v22 = v21 + 1;
    v23 = (v22 >> 1);
    *v6 = malloc_type_malloc(8 * (int)v23, 0x100004000313F17uLL);
    if (v21 >= 2)
    {
      v24 = 0;
      while (fscanf(v2, "%lf", (char *)*v6 + v24) == 1)
      {
        v24 += 8;
        if (!--v23)
          goto LABEL_60;
      }
      goto LABEL_94;
    }
LABEL_60:
    if (fscanf(v2, "%80s", __s2) != 1)
      goto LABEL_94;
  }
  if (*(_DWORD *)__s2 == 1700946284 && *(unsigned __int16 *)&__s2[4] == 108)
  {
    v25 = (int)v5[26];
    *((_QWORD *)v5 + 20) = malloc_type_malloc(4 * v25, 0x100004052888210uLL);
    if ((int)v25 >= 1)
    {
      v26 = 0;
      v27 = 4 * v25;
      while (fscanf(v2, "%d", *((_QWORD *)v5 + 20) + v26) == 1)
      {
        v26 += 4;
        if (v27 == v26)
          goto LABEL_60;
      }
      goto LABEL_94;
    }
    goto LABEL_60;
  }
  if (*(_DWORD *)__s2 == 1651470960 && *(unsigned __int16 *)&__s2[4] == 65)
  {
    v28 = (v5[26] - 1) * v5[26];
    if (v28 >= 0)
      v29 = (v5[26] - 1) * v5[26];
    else
      v29 = v28 + 1;
    v30 = (v29 >> 1);
    *((_QWORD *)v5 + 17) = malloc_type_malloc(8 * (int)v30, 0x100004000313F17uLL);
    if (v28 >= 2)
    {
      v31 = 0;
      while (fscanf(v2, "%lf", *((_QWORD *)v5 + 17) + v31) == 1)
      {
        v31 += 8;
        if (!--v30)
          goto LABEL_60;
      }
      goto LABEL_94;
    }
    goto LABEL_60;
  }
  if (*(_DWORD *)__s2 == 1651470960 && *(unsigned __int16 *)&__s2[4] == 66)
  {
    v32 = (v5[26] - 1) * v5[26];
    if (v32 >= 0)
      v33 = (v5[26] - 1) * v5[26];
    else
      v33 = v32 + 1;
    v34 = (v33 >> 1);
    *((_QWORD *)v5 + 18) = malloc_type_malloc(8 * (int)v34, 0x100004000313F17uLL);
    if (v32 >= 2)
    {
      v35 = 0;
      while (fscanf(v2, "%lf", *((_QWORD *)v5 + 18) + v35) == 1)
      {
        v35 += 8;
        if (!--v34)
          goto LABEL_60;
      }
      goto LABEL_94;
    }
    goto LABEL_60;
  }
  if (*(_DWORD *)__s2 == 1935635054 && *(unsigned __int16 *)&__s2[4] == 118)
  {
    v15 = (int)v5[26];
    *((_QWORD *)v5 + 21) = malloc_type_malloc(4 * v15, 0x100004052888210uLL);
    if ((int)v15 >= 1)
    {
      v16 = 0;
      v17 = 4 * v15;
      while (fscanf(v2, "%d", *((_QWORD *)v5 + 21) + v16) == 1)
      {
        v16 += 4;
        if (v17 == v16)
          goto LABEL_60;
      }
      goto LABEL_94;
    }
    goto LABEL_60;
  }
  if (*(unsigned __int16 *)__s2 ^ 0x5653 | __s2[2])
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "unknown text in model file: [%s]\n", __s2);
    goto LABEL_94;
  }
  do
    v40 = getc(v2);
  while (v40 != -1 && v40 != 10);
  v41 = MEMORY[0x20BD18B18](v2);
  max_line_len = 1024;
  line = (uint64_t)malloc_type_malloc(0x400uLL, 0x100004077774924uLL);
  *(_QWORD *)__s2 = 0;
  v42 = 0;
  while (readline(v2))
  {
    strtok((char *)line, ":");
    --v42;
    do
      ++v42;
    while (strtok(0, ":"));
  }
  v43 = v5[27];
  fseek(v2, v41, 0);
  v44 = v5[26];
  v45 = (int)v5[27];
  v46 = v44 - 1;
  v66 = v5[27];
  *((_QWORD *)v5 + 15) = malloc_type_malloc(8 * (v44 - 1), 0x80040B8603338uLL);
  v47 = 8 * v45;
  v65 = v44;
  if (v44 > 1)
  {
    v48 = 0;
    do
    {
      *(_QWORD *)(*((_QWORD *)v5 + 15) + v48) = malloc_type_malloc(v47, 0x100004000313F17uLL);
      v48 += 8;
    }
    while (8 * v46 != v48);
  }
  *((_QWORD *)v5 + 14) = malloc_type_malloc(v47, 0x2004093837F09uLL);
  if ((int)v66 >= 1)
  {
    v49 = (char *)malloc_type_malloc(16 * (v43 + v42), 0x1000040F7F8B94BuLL);
    v50 = 0;
    v51 = 0;
    v52 = 8 * v46;
    v62 = v49 + 8;
    v63 = v49;
    do
    {
      readline(v2);
      *(_QWORD *)(*((_QWORD *)v5 + 14) + 8 * v50) = &v49[16 * v51];
      v53 = strtok((char *)line, " \t");
      *(double *)(**((_QWORD **)v5 + 15) + 8 * v50) = strtod(v53, (char **)__s2);
      if (v65 >= 3)
      {
        v54 = 8;
        do
        {
          v55 = strtok(0, " \t");
          *(double *)(*(_QWORD *)(*((_QWORD *)v5 + 15) + v54) + 8 * v50) = strtod(v55, (char **)__s2);
          v54 += 8;
        }
        while (v52 != v54);
      }
      v56 = v51;
      v57 = strtok(0, ":");
      v58 = strtok(0, " \t");
      if (v58)
      {
        v59 = v58;
        v60 = (uint64_t)v51 << 32;
        v61 = (double *)&v62[16 * v51];
        do
        {
          *((_DWORD *)v61 - 2) = strtol(v57, (char **)__s2, 10);
          *v61 = strtod(v59, (char **)__s2);
          v61 += 2;
          v57 = strtok(0, ":");
          v59 = strtok(0, " \t");
          v60 += 0x100000000;
          ++v51;
        }
        while (v59);
        v56 = v60 >> 32;
        v49 = v63;
      }
      ++v51;
      *(_DWORD *)&v49[16 * v56] = -1;
      ++v50;
      v52 = 8 * v46;
    }
    while (v50 != v66);
  }
  free((void *)line);
  setlocale(0, v4);
  free(v4);
  if (!ferror(v2) && !fclose(v2))
  {
    v5[44] = 1;
    return v5;
  }
  return 0;
}

void *readline(__sFILE *a1)
{
  void *v2;
  size_t v3;
  int v4;

  if (!fgets((char *)line, max_line_len, a1))
    return 0;
  while (1)
  {
    v2 = (void *)line;
    if (strrchr((char *)line, 10))
      break;
    v3 = 2 * max_line_len;
    max_line_len *= 2;
    line = (uint64_t)malloc_type_realloc(v2, v3, 0x78C8D676uLL);
    v4 = strlen((const char *)line);
    if (!fgets((char *)(line + v4), max_line_len - v4, a1))
      return (void *)line;
  }
  return v2;
}

void svm_free_model_content(uint64_t a1)
{
  void **v2;
  uint64_t v3;

  if (*(_DWORD *)(a1 + 176))
  {
    if (*(int *)(a1 + 108) >= 1)
    {
      v2 = *(void ***)(a1 + 112);
      if (v2)
        free(*v2);
    }
  }
  if (*(_QWORD *)(a1 + 120) && *(int *)(a1 + 104) >= 2)
  {
    v3 = 0;
    do
      free(*(void **)(*(_QWORD *)(a1 + 120) + 8 * v3++));
    while (v3 < *(int *)(a1 + 104) - 1);
  }
  free(*(void **)(a1 + 112));
  *(_QWORD *)(a1 + 112) = 0;
  free(*(void **)(a1 + 120));
  *(_QWORD *)(a1 + 120) = 0;
  free(*(void **)(a1 + 128));
  *(_QWORD *)(a1 + 128) = 0;
  free(*(void **)(a1 + 160));
  *(_QWORD *)(a1 + 160) = 0;
  free(*(void **)(a1 + 136));
  *(_QWORD *)(a1 + 136) = 0;
  free(*(void **)(a1 + 144));
  *(_QWORD *)(a1 + 144) = 0;
  free(*(void **)(a1 + 152));
  *(_QWORD *)(a1 + 152) = 0;
  free(*(void **)(a1 + 168));
  *(_QWORD *)(a1 + 168) = 0;
}

void svm_destroy_param(uint64_t a1)
{
  free(*(void **)(a1 + 64));
  free(*(void **)(a1 + 72));
}

const char *svm_check_parameter(unsigned int *a1, uint64_t a2)
{
  unsigned int v2;
  const char *result;
  double v6;
  unsigned int v7;
  uint64_t v9;
  _DWORD *v10;
  _DWORD *v11;
  uint64_t v12;
  int v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  int v22;
  double v23;

  v2 = *(_DWORD *)a2;
  if (*(_DWORD *)a2 > 4u)
    return "unknown svm type";
  if (*(_DWORD *)(a2 + 4) > 4u)
    return "unknown kernel type";
  if (*(double *)(a2 + 16) < 0.0)
    return "gamma < 0";
  if ((*(_DWORD *)(a2 + 8) & 0x80000000) != 0)
    return "degree of polynomial kernel < 0";
  if (*(double *)(a2 + 32) <= 0.0)
    return "cache_size <= 0";
  if (*(double *)(a2 + 40) <= 0.0)
    return "eps <= 0";
  if (v2 <= 4 && ((1 << v2) & 0x19) != 0 && *(double *)(a2 + 48) <= 0.0)
    return "C <= 0";
  if (v2 - 1 < 2)
    goto LABEL_16;
  if (v2 == 3)
  {
LABEL_19:
    if (*(double *)(a2 + 88) < 0.0)
      return "p < 0";
    goto LABEL_25;
  }
  if (v2 == 4)
  {
LABEL_16:
    v6 = *(double *)(a2 + 80);
    result = "nu <= 0 or nu > 1";
    if (v6 <= 0.0 || v6 > 1.0)
      return result;
    if (v2 == 3)
      goto LABEL_19;
  }
LABEL_25:
  if (*(_DWORD *)(a2 + 96) > 1u)
    return "shrinking != 0 and shrinking != 1";
  v7 = *(_DWORD *)(a2 + 100);
  if (v7 > 1)
    return "probability != 0 and probability != 1";
  if (v7 == 1 && v2 == 2)
    result = "one-class SVM probability output not supported yet";
  else
    result = 0;
  if (v2 == 1)
  {
    v9 = *a1;
    v10 = malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
    v11 = malloc_type_malloc(0x40uLL, 0x100004052888210uLL);
    if ((int)v9 < 1)
      goto LABEL_57;
    v12 = 0;
    v13 = 0;
    v14 = 16;
    do
    {
      v15 = (int)*(double *)(*((_QWORD *)a1 + 1) + 8 * v12);
      if (v13 < 1)
      {
        LODWORD(v16) = 0;
      }
      else
      {
        v16 = 0;
        while (v10[v16] != v15)
        {
          if (v13 == ++v16)
            goto LABEL_44;
        }
        ++v11[v16];
      }
      if ((_DWORD)v16 == v13)
      {
LABEL_44:
        if (v13 == v14)
        {
          v14 = 2 * v13;
          v10 = malloc_type_realloc(v10, 8 * v13, 0x100004052888210uLL);
          v11 = malloc_type_realloc(v11, 8 * v13, 0x100004052888210uLL);
        }
        v10[v13] = v15;
        v11[v13++] = 1;
      }
      ++v12;
    }
    while (v12 != v9);
    if (v13 < 1)
    {
LABEL_57:
      free(v10);
      free(v11);
      return 0;
    }
    else
    {
      v17 = 0;
      v18 = 1;
      while (1)
      {
        v19 = v17 + 1;
        if (v17 + 1 < (unint64_t)v13)
          break;
LABEL_56:
        ++v18;
        v17 = v19;
        if (v19 == v13)
          goto LABEL_57;
      }
      v20 = v11[v17];
      v21 = v18;
      while (1)
      {
        v22 = v11[v21];
        v23 = *(double *)(a2 + 80) * (double)(v22 + v20) * 0.5;
        if (v20 < v22)
          v22 = v20;
        if (v23 > (double)v22)
          break;
        if (v13 == ++v21)
          goto LABEL_56;
      }
      free(v10);
      free(v11);
      return "specified nu is infeasible";
    }
  }
  return result;
}

BOOL svm_check_probability_model(uint64_t a1)
{
  if (*(_DWORD *)a1 > 1u)
  {
    if ((*(_DWORD *)a1 - 3) <= 1)
      return *(_QWORD *)(a1 + 136) != 0;
  }
  else if (*(_QWORD *)(a1 + 136) && *(_QWORD *)(a1 + 144))
  {
    return 1;
  }
  return 0;
}

uint64_t (*svm_set_print_string_function(uint64_t (*result)(const char *)))(const char *)
{
  uint64_t (*v1)(const char *);

  v1 = print_string_stdout;
  if (result)
    v1 = result;
  svm_print_string = v1;
  return result;
}

double CPMLLibSVM::Kernel::swap_index(CPMLLibSVM::Kernel *this, int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double result;

  v3 = *((_QWORD *)this + 3);
  v4 = *(_QWORD *)(v3 + 8 * a2);
  *(_QWORD *)(v3 + 8 * a2) = *(_QWORD *)(v3 + 8 * a3);
  *(_QWORD *)(v3 + 8 * a3) = v4;
  v5 = *((_QWORD *)this + 4);
  if (v5)
  {
    result = *(double *)(v5 + 8 * a2);
    *(_QWORD *)(v5 + 8 * a2) = *(_QWORD *)(v5 + 8 * a3);
    *(double *)(v5 + 8 * a3) = result;
  }
  return result;
}

void CPMLLibSVM::Solver::~Solver(CPMLLibSVM::Solver *this)
{
  JUMPOUT(0x20BD188E4);
}

void CPMLLibSVM::Solver_NU::~Solver_NU(CPMLLibSVM::Solver_NU *this)
{
  JUMPOUT(0x20BD188E4);
}

_QWORD *CPMLLibSVM::SVC_Q::SVC_Q(_QWORD *a1, int *a2, uint64_t a3, const void *a4)
{
  size_t v8;
  void *v9;
  CPMLLibSVM::Cache *v10;
  uint64_t v11;
  double (*v12)(_QWORD *, uint64_t, uint64_t);
  uint64_t v13;
  _QWORD *v14;

  *(_QWORD *)CPMLLibSVM::Kernel::Kernel((uint64_t)a1, *a2, *((const void **)a2 + 2), a3) = &unk_24C255E30;
  v8 = *a2;
  v9 = (void *)operator new[]();
  a1[8] = v9;
  memcpy(v9, a4, v8);
  v10 = (CPMLLibSVM::Cache *)operator new();
  CPMLLibSVM::Cache::Cache(v10, *a2, vcvtd_n_s64_f64(*(double *)(a3 + 32), 0x14uLL));
  a1[9] = v10;
  a1[10] = operator new[]();
  if (*a2 >= 1)
  {
    v11 = 0;
    do
    {
      v12 = (double (*)(_QWORD *, uint64_t, uint64_t))a1[1];
      v13 = a1[2];
      v14 = (_QWORD *)((char *)a1 + (v13 >> 1));
      if ((v13 & 1) != 0)
        v12 = *(double (**)(_QWORD *, uint64_t, uint64_t))(*v14 + v12);
      *(double *)(a1[10] + 8 * v11) = v12(v14, v11, v11);
      ++v11;
    }
    while (v11 < *a2);
  }
  return a1;
}

void sub_209CCD1C0(_Unwind_Exception *a1)
{
  CPMLLibSVM::Kernel *v1;
  uint64_t v2;

  MEMORY[0x20BD188E4](v2, 0x10A0C408A4F435CLL);
  CPMLLibSVM::Kernel::~Kernel(v1);
  _Unwind_Resume(a1);
}

float *CPMLLibSVM::SVC_Q::get_Q(CPMLLibSVM::Cache **this, uint64_t a2, uint64_t a3)
{
  int v3;
  int data;
  float *v7;
  uint64_t v8;
  CPMLLibSVM::Cache *v9;
  uint64_t v10;
  _QWORD *v11;
  double v12;
  float v13;
  float *v15;

  v3 = a3;
  v15 = 0;
  data = CPMLLibSVM::Cache::get_data(this[9], a2, &v15, a3);
  v7 = v15;
  if (data < v3)
  {
    v8 = data;
    do
    {
      v9 = this[1];
      v10 = (uint64_t)this[2];
      v11 = (CPMLLibSVM::Cache **)((char *)this + (v10 >> 1));
      if ((v10 & 1) != 0)
        v9 = *(CPMLLibSVM::Cache **)(*v11 + v9);
      v12 = (double)(*((char *)this[8] + v8) * *((char *)this[8] + (int)a2));
      v13 = ((double (*)(_QWORD *, uint64_t, uint64_t))v9)(v11, a2, v8) * v12;
      v7[v8++] = v13;
    }
    while (v3 != (_DWORD)v8);
  }
  return v7;
}

uint64_t CPMLLibSVM::SVC_Q::get_QD(CPMLLibSVM::SVC_Q *this)
{
  return *((_QWORD *)this + 10);
}

double CPMLLibSVM::SVC_Q::swap_index(CPMLLibSVM::Cache **this, int a2, int a3)
{
  CPMLLibSVM::Cache *v6;
  uint64_t v7;
  CPMLLibSVM::Cache *v8;
  uint64_t v9;
  CPMLLibSVM::Cache *v10;
  char v11;
  CPMLLibSVM::Cache *v12;
  double result;

  CPMLLibSVM::Cache::swap_index(this[9], a2, a3);
  v6 = this[3];
  v7 = *((_QWORD *)v6 + a2);
  *((_QWORD *)v6 + a2) = *((_QWORD *)v6 + a3);
  *((_QWORD *)v6 + a3) = v7;
  v8 = this[4];
  if (v8)
  {
    v9 = *((_QWORD *)v8 + a2);
    *((_QWORD *)v8 + a2) = *((_QWORD *)v8 + a3);
    *((_QWORD *)v8 + a3) = v9;
  }
  v10 = this[8];
  v11 = *((_BYTE *)v10 + a2);
  *((_BYTE *)v10 + a2) = *((_BYTE *)v10 + a3);
  *((_BYTE *)v10 + a3) = v11;
  v12 = this[10];
  result = *((double *)v12 + a2);
  *((_QWORD *)v12 + a2) = *((_QWORD *)v12 + a3);
  *((double *)v12 + a3) = result;
  return result;
}

void CPMLLibSVM::SVC_Q::~SVC_Q(CPMLLibSVM::SVC_Q *this)
{
  CPMLLibSVM::SVC_Q::~SVC_Q(this);
  JUMPOUT(0x20BD188E4);
}

{
  uint64_t v2;
  CPMLLibSVM::Cache *v3;
  uint64_t v4;

  *(_QWORD *)this = &unk_24C255E30;
  v2 = *((_QWORD *)this + 8);
  if (v2)
    MEMORY[0x20BD188CC](v2, 0x1000C8077774924);
  v3 = (CPMLLibSVM::Cache *)*((_QWORD *)this + 9);
  if (v3)
  {
    CPMLLibSVM::Cache::~Cache(v3);
    MEMORY[0x20BD188E4]();
  }
  v4 = *((_QWORD *)this + 10);
  if (v4)
    MEMORY[0x20BD188CC](v4, 0x1000C8000313F17);
  CPMLLibSVM::Kernel::~Kernel(this);
}

_QWORD *CPMLLibSVM::ONE_CLASS_Q::ONE_CLASS_Q(_QWORD *a1, int *a2, uint64_t a3)
{
  CPMLLibSVM::Cache *v6;
  uint64_t v7;
  double (*v8)(_QWORD *, uint64_t, uint64_t);
  uint64_t v9;
  _QWORD *v10;

  *(_QWORD *)CPMLLibSVM::Kernel::Kernel((uint64_t)a1, *a2, *((const void **)a2 + 2), a3) = &unk_24C255DF8;
  v6 = (CPMLLibSVM::Cache *)operator new();
  CPMLLibSVM::Cache::Cache(v6, *a2, vcvtd_n_s64_f64(*(double *)(a3 + 32), 0x14uLL));
  a1[8] = v6;
  a1[9] = operator new[]();
  if (*a2 >= 1)
  {
    v7 = 0;
    do
    {
      v8 = (double (*)(_QWORD *, uint64_t, uint64_t))a1[1];
      v9 = a1[2];
      v10 = (_QWORD *)((char *)a1 + (v9 >> 1));
      if ((v9 & 1) != 0)
        v8 = *(double (**)(_QWORD *, uint64_t, uint64_t))(*v10 + v8);
      *(double *)(a1[9] + 8 * v7) = v8(v10, v7, v7);
      ++v7;
    }
    while (v7 < *a2);
  }
  return a1;
}

void sub_209CCD4EC(_Unwind_Exception *a1)
{
  CPMLLibSVM::Kernel *v1;
  uint64_t v2;

  MEMORY[0x20BD188E4](v2, 0x10A0C408A4F435CLL);
  CPMLLibSVM::Kernel::~Kernel(v1);
  _Unwind_Resume(a1);
}

float *CPMLLibSVM::ONE_CLASS_Q::get_Q(CPMLLibSVM::Cache **this, uint64_t a2, uint64_t a3)
{
  int v3;
  uint64_t data;
  float *v7;
  uint64_t v8;
  float *v9;
  CPMLLibSVM::Cache *v10;
  uint64_t v11;
  _QWORD *v12;
  float v13;
  float *v15;

  v3 = a3;
  v15 = 0;
  data = CPMLLibSVM::Cache::get_data(this[8], a2, &v15, a3);
  v7 = v15;
  if ((int)data < v3)
  {
    v8 = data;
    v9 = &v15[(int)data];
    do
    {
      v10 = this[1];
      v11 = (uint64_t)this[2];
      v12 = (CPMLLibSVM::Cache **)((char *)this + (v11 >> 1));
      if ((v11 & 1) != 0)
        v10 = *(CPMLLibSVM::Cache **)(*v12 + v10);
      v13 = ((double (*)(_QWORD *, uint64_t, uint64_t))v10)(v12, a2, v8);
      *v9++ = v13;
      v8 = (v8 + 1);
    }
    while (v3 != (_DWORD)v8);
  }
  return v7;
}

uint64_t CPMLLibSVM::ONE_CLASS_Q::get_QD(CPMLLibSVM::ONE_CLASS_Q *this)
{
  return *((_QWORD *)this + 9);
}

double CPMLLibSVM::ONE_CLASS_Q::swap_index(CPMLLibSVM::Cache **this, int a2, int a3)
{
  CPMLLibSVM::Cache *v6;
  uint64_t v7;
  CPMLLibSVM::Cache *v8;
  uint64_t v9;
  CPMLLibSVM::Cache *v10;
  double result;

  CPMLLibSVM::Cache::swap_index(this[8], a2, a3);
  v6 = this[3];
  v7 = *((_QWORD *)v6 + a2);
  *((_QWORD *)v6 + a2) = *((_QWORD *)v6 + a3);
  *((_QWORD *)v6 + a3) = v7;
  v8 = this[4];
  if (v8)
  {
    v9 = *((_QWORD *)v8 + a2);
    *((_QWORD *)v8 + a2) = *((_QWORD *)v8 + a3);
    *((_QWORD *)v8 + a3) = v9;
  }
  v10 = this[9];
  result = *((double *)v10 + a2);
  *((_QWORD *)v10 + a2) = *((_QWORD *)v10 + a3);
  *((double *)v10 + a3) = result;
  return result;
}

void CPMLLibSVM::ONE_CLASS_Q::~ONE_CLASS_Q(CPMLLibSVM::ONE_CLASS_Q *this)
{
  CPMLLibSVM::ONE_CLASS_Q::~ONE_CLASS_Q(this);
  JUMPOUT(0x20BD188E4);
}

{
  CPMLLibSVM::Cache *v2;
  uint64_t v3;

  *(_QWORD *)this = &unk_24C255DF8;
  v2 = (CPMLLibSVM::Cache *)*((_QWORD *)this + 8);
  if (v2)
  {
    CPMLLibSVM::Cache::~Cache(v2);
    MEMORY[0x20BD188E4]();
  }
  v3 = *((_QWORD *)this + 9);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8000313F17);
  CPMLLibSVM::Kernel::~Kernel(this);
}

uint64_t CPMLLibSVM::SVR_Q::SVR_Q(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v6;
  CPMLLibSVM::Cache *v7;
  uint64_t v8;
  uint64_t v9;
  double (*v10)(_QWORD *, uint64_t, uint64_t);
  uint64_t v11;
  _QWORD *v12;
  double v13;
  uint64_t v14;
  uint64_t v15;

  v6 = CPMLLibSVM::Kernel::Kernel(a1, *(_DWORD *)a2, *(const void **)(a2 + 16), a3);
  *(_QWORD *)v6 = &unk_24C255E68;
  *(_DWORD *)(v6 + 64) = *(_DWORD *)a2;
  v7 = (CPMLLibSVM::Cache *)operator new();
  CPMLLibSVM::Cache::Cache(v7, *(_DWORD *)(a1 + 64), vcvtd_n_s64_f64(*(double *)(a3 + 32), 0x14uLL));
  *(_QWORD *)(a1 + 72) = v7;
  *(_QWORD *)(a1 + 120) = operator new[]();
  *(_QWORD *)(a1 + 80) = operator new[]();
  *(_QWORD *)(a1 + 88) = operator new[]();
  if (*(int *)(a1 + 64) >= 1)
  {
    v8 = 0;
    do
    {
      *(_BYTE *)(*(_QWORD *)(a1 + 80) + v8) = 1;
      *(_BYTE *)(*(_QWORD *)(a1 + 80) + *(int *)(a1 + 64) + v8) = -1;
      v9 = *(_QWORD *)(a1 + 88);
      *(_DWORD *)(v9 + 4 * v8) = v8;
      *(_DWORD *)(v9 + 4 * (v8 + *(int *)(a1 + 64))) = v8;
      v10 = *(double (**)(_QWORD *, uint64_t, uint64_t))(a1 + 8);
      v11 = *(_QWORD *)(a1 + 16);
      v12 = (_QWORD *)(a1 + (v11 >> 1));
      if ((v11 & 1) != 0)
        v10 = *(double (**)(_QWORD *, uint64_t, uint64_t))(*v12 + v10);
      v13 = v10(v12, v8, v8);
      v14 = *(_QWORD *)(a1 + 120);
      *(double *)(v14 + 8 * v8) = v13;
      v15 = *(int *)(a1 + 64);
      *(double *)(v14 + 8 * (v8 + v15)) = v13;
      ++v8;
    }
    while (v8 < v15);
  }
  *(_QWORD *)(a1 + 104) = operator new[]();
  *(_QWORD *)(a1 + 112) = operator new[]();
  *(_DWORD *)(a1 + 96) = 0;
  return a1;
}

void sub_209CCD8B4(_Unwind_Exception *a1)
{
  CPMLLibSVM::Kernel *v1;
  uint64_t v2;

  MEMORY[0x20BD188E4](v2, 0x10A0C408A4F435CLL);
  CPMLLibSVM::Kernel::~Kernel(v1);
  _Unwind_Resume(a1);
}

float *CPMLLibSVM::SVR_Q::get_Q(CPMLLibSVM::SVR_Q *this, int a2, int a3)
{
  uint64_t v6;
  uint64_t v7;
  int data;
  int v9;
  uint64_t v11;
  float *v12;
  double (*v13)(_QWORD *, uint64_t, uint64_t);
  uint64_t v14;
  _QWORD *v15;
  float v16;
  uint64_t v17;
  float *result;
  char *v19;
  int *v20;
  float v21;
  float *v22;
  uint64_t v23;
  float *v24;
  int v25;
  float v26;
  uint64_t v27;
  float *v28;

  v28 = 0;
  v6 = *((_QWORD *)this + 11);
  v7 = *(unsigned int *)(v6 + 4 * a2);
  data = CPMLLibSVM::Cache::get_data(*((CPMLLibSVM::Cache **)this + 9), *(_DWORD *)(v6 + 4 * a2), &v28, *((unsigned int *)this + 16));
  v9 = *((_DWORD *)this + 16);
  if (data < v9 && v9 >= 1)
  {
    v11 = 0;
    v12 = v28;
    do
    {
      v13 = (double (*)(_QWORD *, uint64_t, uint64_t))*((_QWORD *)this + 1);
      v14 = *((_QWORD *)this + 2);
      v15 = (_QWORD *)((char *)this + (v14 >> 1));
      if ((v14 & 1) != 0)
        v13 = *(double (**)(_QWORD *, uint64_t, uint64_t))(*v15 + v13);
      v16 = v13(v15, v7, v11);
      v12[v11++] = v16;
    }
    while (v11 < *((int *)this + 16));
  }
  v17 = *((int *)this + 24);
  result = (float *)*((_QWORD *)this + v17 + 13);
  *((_DWORD *)this + 24) = 1 - v17;
  if (a3 >= 1)
  {
    v19 = (char *)*((_QWORD *)this + 10);
    v20 = (int *)*((_QWORD *)this + 11);
    v21 = (float)v19[a2];
    v22 = v28;
    v23 = a3;
    v24 = result;
    do
    {
      v25 = *v19++;
      v26 = v21 * (float)v25;
      v27 = *v20++;
      *v24++ = v26 * v22[v27];
      --v23;
    }
    while (v23);
  }
  return result;
}

uint64_t CPMLLibSVM::SVR_Q::get_QD(CPMLLibSVM::SVR_Q *this)
{
  return *((_QWORD *)this + 15);
}

double CPMLLibSVM::SVR_Q::swap_index(CPMLLibSVM::SVR_Q *this, int a2, int a3)
{
  uint64_t v3;
  char v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  double result;

  v3 = *((_QWORD *)this + 10);
  v4 = *(_BYTE *)(v3 + a2);
  *(_BYTE *)(v3 + a2) = *(_BYTE *)(v3 + a3);
  *(_BYTE *)(v3 + a3) = v4;
  v5 = *((_QWORD *)this + 11);
  v6 = *(_DWORD *)(v5 + 4 * a2);
  *(_DWORD *)(v5 + 4 * a2) = *(_DWORD *)(v5 + 4 * a3);
  *(_DWORD *)(v5 + 4 * a3) = v6;
  v7 = *((_QWORD *)this + 15);
  result = *(double *)(v7 + 8 * a2);
  *(_QWORD *)(v7 + 8 * a2) = *(_QWORD *)(v7 + 8 * a3);
  *(double *)(v7 + 8 * a3) = result;
  return result;
}

void CPMLLibSVM::SVR_Q::~SVR_Q(CPMLLibSVM::SVR_Q *this)
{
  CPMLLibSVM::SVR_Q::~SVR_Q(this);
  JUMPOUT(0x20BD188E4);
}

{
  CPMLLibSVM::Cache *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &unk_24C255E68;
  v2 = (CPMLLibSVM::Cache *)*((_QWORD *)this + 9);
  if (v2)
  {
    CPMLLibSVM::Cache::~Cache(v2);
    MEMORY[0x20BD188E4]();
  }
  v3 = *((_QWORD *)this + 10);
  if (v3)
    MEMORY[0x20BD188CC](v3, 0x1000C8077774924);
  v4 = *((_QWORD *)this + 11);
  if (v4)
    MEMORY[0x20BD188CC](v4, 0x1000C8052888210);
  v5 = *((_QWORD *)this + 13);
  if (v5)
    MEMORY[0x20BD188CC](v5, 0x1000C8052888210);
  v6 = *((_QWORD *)this + 14);
  if (v6)
    MEMORY[0x20BD188CC](v6, 0x1000C8052888210);
  v7 = *((_QWORD *)this + 15);
  if (v7)
    MEMORY[0x20BD188CC](v7, 0x1000C8000313F17);
  CPMLLibSVM::Kernel::~Kernel(this);
}

void CPMLUserDefinedAlgorithm::CPMLUserDefinedAlgorithm(CPMLUserDefinedAlgorithm *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  _QWORD *v6;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *v6 = &off_24C255968;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
}

void sub_209CCDB8C(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLUserDefinedAlgorithm::CPMLUserDefinedAlgorithm(CPMLUserDefinedAlgorithm *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v3;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v3 = &off_24C255968;
  CPMLDelegate::deSerializeCPMLAlgorithm(*(CPMLDelegate **)(v3 + 56));
}

void sub_209CCDBE8(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLUserDefinedAlgorithm::~CPMLUserDefinedAlgorithm(CPMLUserDefinedAlgorithm *this)
{
  CPModelClose(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLUserDefinedAlgorithm::update(CPMLUserDefinedAlgorithm *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v5;
  CPMLFeatureVector *v6;

  v5 = (*(uint64_t (**)(_QWORD, CPMLCDB *, CPMLSerialization *, CPMLTunableData *))(**((_QWORD **)this + 10)
                                                                                            + 32))(*((_QWORD *)this + 10), a2, a3, a4);
  if (v5)
  {
    v6 = (CPMLFeatureVector *)v5;
    do
    {
      CPMLDelegate::updateCPMLAlgorithm(*((CPMLDelegate **)this + 7), v6);
      v6 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v6);
  }
  return 0;
}

uint64_t CPMLUserDefinedAlgorithm::eval(uint64_t a1, CPMLFeatureVector *a2)
{
  double v4;

  v4 = -1.0;
  CPMLDelegate::evaluateCPMLAlgorithm(*(id **)(a1 + 56), a2, 0, &v4);
  CPMLFeatureVector::setYHat((uint64_t)a2, v4);
  return 0;
}

uint64_t CPMLUserDefinedAlgorithm::serialize(CPMLDelegate **this)
{
  CPMLDelegate::serializeCPMLAlgorithm(this[7]);
  return 0;
}

uint64_t CPMLUserDefinedAlgorithm::train(CPMLUserDefinedAlgorithm *this)
{
  uint64_t v2;
  CPMLFeatureVector *v3;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    v3 = (CPMLFeatureVector *)v2;
    do
    {
      CPMLDelegate::trainCPMLAlgorithm(*((CPMLDelegate **)this + 7), v3);
      v3 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v3);
  }
  return 0;
}

uint64_t CPMLUserDefinedAlgorithm::errorString(CPMLUserDefinedAlgorithm *this)
{
  return 0;
}

uint64_t CPMLUserDefinedAlgorithm::requireRealOnly(CPMLUserDefinedAlgorithm *this)
{
  return 1;
}

void CPMLNaiveBayesSpotLightAdaptor::CPMLNaiveBayesSpotLightAdaptor(CPMLNaiveBayesSpotLightAdaptor *this, CPMLSerialization *a2)
{
  _QWORD *v2;

  CPMLNaiveBayesAdaptor::CPMLNaiveBayesAdaptor(this, a2);
  *v2 = &off_24C255CB0;
}

double CPMLNaiveBayesSpotLightAdaptor::get_cx_given_y(CPMLNaiveBayesSpotLightAdaptor *this, int a2, int a3, int a4, double *a5)
{
  double v10;
  char *v11;
  char *v12;
  char *v13;
  uint64_t v14;
  char *v15;
  char *v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  char *v21;
  int *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  char *v27;
  char *v28;
  int v29;
  _BOOL4 v30;
  char *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char *v35;
  char *v36;
  int v37;
  uint64_t v38;
  uint64_t v39;
  char *v40;
  char *v41;
  int *v42;
  uint64_t v43;
  unint64_t v44;
  uint64_t v45;
  unint64_t v46;
  char *v47;
  char *v48;
  int v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t v53;
  char *v54;
  int *v55;
  int *v56;
  unint64_t v57;
  char *v58;
  double v59;
  _QWORD v60[2];
  int *v61;
  char *v62;
  char *v63;
  unint64_t v64;
  double v65;
  int v66;
  char v67[512];
  uint64_t v68;

  v68 = *MEMORY[0x24BDAC8D0];
  v66 = a3;
  if (a2 >= 2)
    return CPMLNaiveBayesAdaptor::get_cx_given_y(this, a2, a3, a4, a5);
  v10 = 0.0;
  if (a2 != 1)
  {
    v64 = 0xBFF0000000000000;
    v65 = -1.0;
    v11 = sqlite3_mprintf("select xCardinality from xCardinality%d where yMap=%d;", a2, a4);
    (*(void (**)(_QWORD, unint64_t *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v64, v11);
    if (v11)
      sqlite3_free(v11);
    if (fabs(v65) == INFINITY)
    {
      *a5 = 0.0;
      return -2.0;
    }
    else
    {
      *(_QWORD *)a5 = v64;
      v61 = 0;
      v62 = 0;
      v63 = 0;
      v12 = sqlite3_mprintf("select keyValue from cacheString where indexValue=%d;", a3);
      (*(void (**)(_QWORD, char *, uint64_t, char *))(**((_QWORD **)this + 1) + 184))(*((_QWORD *)this + 1), v67, 512, v12);
      if (v67[0])
      {
        v13 = sqlite3_mprintf("select count(*) from xcol0;");
        (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v65, v13);
        sqlite3_free(v13);
        ((void (*)(void))MEMORY[0x24BDAC7A8])();
        v15 = (char *)v60 - v14;
        v16 = sqlite3_mprintf("select indexValue from INDEX0 where keyValue like \"%s%%\" ;", v67);
        v17 = (*(uint64_t (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 200))(*((_QWORD *)this + 1), v15, (int)v65, v16);
        v60[1] = v60;
        if (v17 < 1)
        {
          v31 = sqlite3_mprintf("select count(*) from xcol1;");
          (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v65, v31);
          sqlite3_free(v31);
          v60[0] = v60;
          MEMORY[0x24BDAC7A8](v32, v33);
          v35 = (char *)v60 - v34;
          v36 = sqlite3_mprintf("select indexValue from INDEX1 where keyValue like '%s%%';", v67);
          v37 = (*(uint64_t (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 200))(*((_QWORD *)this + 1), v35, (int)v65, v36);
          v30 = v37 > 0;
          if (v37 < 1)
          {
            std::vector<int>::push_back[abi:ne180100]((uint64_t)&v61, &v66);
          }
          else
          {
            v38 = 0;
            v39 = v37;
            v40 = v62;
            do
            {
              if (v40 >= v63)
              {
                v42 = v61;
                v43 = (v40 - (char *)v61) >> 2;
                v44 = v43 + 1;
                if ((unint64_t)(v43 + 1) >> 62)
                  std::vector<double>::__throw_length_error[abi:ne180100]();
                v45 = v63 - (char *)v61;
                if ((v63 - (char *)v61) >> 1 > v44)
                  v44 = v45 >> 1;
                if ((unint64_t)v45 >= 0x7FFFFFFFFFFFFFFCLL)
                  v46 = 0x3FFFFFFFFFFFFFFFLL;
                else
                  v46 = v44;
                if (v46)
                {
                  v47 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v63, v46);
                  v42 = v61;
                  v40 = v62;
                }
                else
                {
                  v47 = 0;
                }
                v48 = &v47[4 * v43];
                *(_DWORD *)v48 = *(_DWORD *)&v35[4 * v38];
                v41 = v48 + 4;
                while (v40 != (char *)v42)
                {
                  v49 = *((_DWORD *)v40 - 1);
                  v40 -= 4;
                  *((_DWORD *)v48 - 1) = v49;
                  v48 -= 4;
                }
                v61 = (int *)v48;
                v62 = v41;
                v63 = &v47[4 * v46];
                if (v42)
                  operator delete(v42);
              }
              else
              {
                *(_DWORD *)v40 = *(_DWORD *)&v35[4 * v38];
                v41 = v40 + 4;
              }
              v62 = v41;
              ++v38;
              v40 = v41;
            }
            while (v38 != v39);
          }
        }
        else
        {
          v18 = 0;
          v19 = v17;
          v20 = v62;
          do
          {
            if (v20 >= v63)
            {
              v22 = v61;
              v23 = (v20 - (char *)v61) >> 2;
              v24 = v23 + 1;
              if ((unint64_t)(v23 + 1) >> 62)
                std::vector<double>::__throw_length_error[abi:ne180100]();
              v25 = v63 - (char *)v61;
              if ((v63 - (char *)v61) >> 1 > v24)
                v24 = v25 >> 1;
              if ((unint64_t)v25 >= 0x7FFFFFFFFFFFFFFCLL)
                v26 = 0x3FFFFFFFFFFFFFFFLL;
              else
                v26 = v24;
              if (v26)
              {
                v27 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v63, v26);
                v22 = v61;
                v20 = v62;
              }
              else
              {
                v27 = 0;
              }
              v28 = &v27[4 * v23];
              *(_DWORD *)v28 = *(_DWORD *)&v15[4 * v18];
              v21 = v28 + 4;
              while (v20 != (char *)v22)
              {
                v29 = *((_DWORD *)v20 - 1);
                v20 -= 4;
                *((_DWORD *)v28 - 1) = v29;
                v28 -= 4;
              }
              v61 = (int *)v28;
              v62 = v21;
              v63 = &v27[4 * v26];
              if (v22)
                operator delete(v22);
            }
            else
            {
              *(_DWORD *)v20 = *(_DWORD *)&v15[4 * v18];
              v21 = v20 + 4;
            }
            v62 = v21;
            ++v18;
            v20 = v21;
          }
          while (v18 != v19);
          v30 = 0;
        }
        v55 = (int *)v62;
      }
      else
      {
        v50 = (v62 - (char *)v61) >> 2;
        v51 = v50 + 1;
        if ((unint64_t)(v50 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v52 = v63 - (char *)v61;
        if ((v63 - (char *)v61) >> 1 > v51)
          v51 = v52 >> 1;
        if ((unint64_t)v52 >= 0x7FFFFFFFFFFFFFFCLL)
          v53 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v53 = v51;
        if (v53)
          v54 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v63, v53);
        else
          v54 = 0;
        v56 = (int *)&v54[4 * v50];
        *v56 = a3;
        v55 = v56 + 1;
        v61 = v56;
        v63 = &v54[4 * v53];
        v30 = 0;
        v62 = (char *)(v56 + 1);
      }
      if (v55 == v61)
      {
        v10 = 0.0;
        if (!v55)
          return v10;
      }
      else
      {
        v57 = 0;
        v10 = 0.0;
        v55 = v61;
        do
        {
          v58 = sqlite3_mprintf("select xyCount from xcol%d where (xMap==%d and yMap==%d);", v30, v55[v57], a4);
          (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v65, v58);
          if (v58)
            sqlite3_free(v58);
          v59 = v65;
          if (fabs(v65) == INFINITY)
          {
            v65 = 0.0;
            v59 = 0.0;
          }
          v10 = v10 + v59;
          ++v57;
          v55 = v61;
        }
        while (v57 < (v62 - (char *)v61) >> 2);
        if (!v61)
          return v10;
      }
      v62 = (char *)v55;
      operator delete(v55);
    }
  }
  return v10;
}

void sub_209CCE3D0(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)(v1 + 16);
  if (v3)
  {
    *(_QWORD *)(v1 + 24) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

void std::vector<int>::push_back[abi:ne180100](uint64_t a1, _DWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  _DWORD *v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  int v16;

  v4 = a1 + 16;
  v5 = *(_QWORD *)(a1 + 16);
  v6 = *(_DWORD **)(a1 + 8);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *(_DWORD **)a1;
    v9 = ((uint64_t)v6 - *(_QWORD *)a1) >> 2;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - (_QWORD)v8;
    if (v11 >> 1 > v10)
      v10 = v11 >> 1;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFFCLL)
      v12 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
    {
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v4, v12);
      v8 = *(_DWORD **)a1;
      v6 = *(_DWORD **)(a1 + 8);
    }
    else
    {
      v13 = 0;
    }
    v14 = &v13[4 * v9];
    v15 = &v13[4 * v12];
    *(_DWORD *)v14 = *a2;
    v7 = v14 + 4;
    while (v6 != v8)
    {
      v16 = *--v6;
      *((_DWORD *)v14 - 1) = v16;
      v14 -= 4;
    }
    *(_QWORD *)a1 = v14;
    *(_QWORD *)(a1 + 8) = v7;
    *(_QWORD *)(a1 + 16) = v15;
    if (v8)
      operator delete(v8);
  }
  else
  {
    *v6 = *a2;
    v7 = v6 + 1;
  }
  *(_QWORD *)(a1 + 8) = v7;
}

double CPMLNaiveBayesDBAdaptor::getYCardinalityCount(CPMLNaiveBayesDBAdaptor *this)
{
  return *((double *)this + 3);
}

uint64_t CPMLNaiveBayesDBAdaptor::getDefaultCandidateList(CPMLNaiveBayesDBAdaptor *this)
{
  return (uint64_t)this + 160;
}

void CPMLIterator::CPMLIterator(CPMLIterator *this)
{
  *(_QWORD *)this = &off_24C2551D0;
  *((_QWORD *)this + 4) = 0;
}

uint64_t CPMLIterator::CPMLIterator(uint64_t a1, uint64_t a2, sqlite3 *a3, uint64_t a4, CPMLStatistics *a5, CPMLRemapper *a6, int a7, uint64_t a8)
{
  sqlite3_stmt **v14;
  CPMLFeatureVector *v15;
  CPMLLog *Table;
  int v17;
  pthread_mutex_t *CPMLLog;
  char *v19;
  int v20;
  CPMLLog *v21;
  int v22;
  pthread_mutex_t *v23;
  char *v24;
  char *v25;
  int v26;
  CPMLLog *v27;
  int v28;
  pthread_mutex_t *v29;

  *(_QWORD *)a1 = &off_24C2551D0;
  *(_DWORD *)(a1 + 12) = 0;
  *(_DWORD *)(a1 + 16) = 0;
  *(_QWORD *)(a1 + 24) = a2;
  *(_QWORD *)(a1 + 32) = a3;
  *(_QWORD *)(a1 + 40) = 0;
  v14 = (sqlite3_stmt **)(a1 + 40);
  *(_QWORD *)(a1 + 64) = a5;
  *(_QWORD *)(a1 + 72) = a8;
  v15 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v15);
  *(_QWORD *)(a1 + 48) = v15;
  if (a7 == 1)
  {
    Table = (CPMLLog *)CPMLsql_createTable(a3, "MODEL_TRAINING_STATS", "lastTrainingIndexPos integer", 1);
    if ((_DWORD)Table)
    {
      v17 = (int)Table;
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(Table);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLIterator", "MODEL_TRAINING_STATS table creation fail %d", v17);
    }
    v19 = sqlite3_mprintf("select lastTrainingIndexPos from MODEL_TRAINING_STATS ;");
    v20 = strlen(v19);
    v21 = (CPMLLog *)sqlite3_prepare_v2(a3, v19, v20, v14, 0);
    if ((_DWORD)v21)
    {
      v22 = (int)v21;
      v23 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v21);
      CPMLLog::log(v23, CPML_LOG_ERR, "CPMLIterator", "MODEL_TRAINING_STATS prepare fail %d", v22);
    }
    if (sqlite3_step(*v14) == 100)
      *(_DWORD *)(a1 + 12) = sqlite3_column_int(*(sqlite3_stmt **)(a1 + 40), 0);
    sqlite3_finalize(*v14);
    if (v19)
      sqlite3_free(v19);
  }
  if (a4)
  {
    v24 = sqlite3_mprintf("%q", a4);
  }
  else if (*(_DWORD *)(a1 + 12))
  {
    v24 = sqlite3_mprintf("select * from MAIN_TABLE where main_table.pKey > %d ;");
  }
  else
  {
    v24 = sqlite3_mprintf("select * from MAIN_TABLE ;");
  }
  v25 = v24;
  v26 = strlen(v24);
  v27 = (CPMLLog *)sqlite3_prepare_v2(*(sqlite3 **)(a1 + 24), v25, v26, v14, 0);
  if ((_DWORD)v27)
  {
    v28 = (int)v27;
    v29 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v27);
    CPMLLog::log(v29, CPML_LOG_ERR, "CPMLIterator", " %s: DB NOT OK %d\n", "CPMLIterator", v28);
  }
  if (v25)
    sqlite3_free(v25);
  if (a6)
  {
    *(_BYTE *)(a1 + 8) = 0;
  }
  else
  {
    *(_BYTE *)(a1 + 8) = 1;
    a6 = (CPMLRemapper *)operator new();
    CPMLRemapper::CPMLRemapper(a6, a3, a5, 0);
  }
  *(_QWORD *)(a1 + 56) = a6;
  return a1;
}

void sub_209CCE77C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x1020C40A6DF2F91);
  _Unwind_Resume(a1);
}

void CPMLIterator::~CPMLIterator(CPMLIterator *this)
{
  sqlite3 *v2;
  char *v3;
  CPMLLog *inserted;
  pthread_mutex_t *CPMLLog;
  CPMLFeatureVector *v6;
  CPMLRemapper *v7;

  *(_QWORD *)this = &off_24C2551D0;
  v2 = (sqlite3 *)*((_QWORD *)this + 4);
  if (v2)
  {
    if (!CPMLsql_createTable(v2, "MODEL_TRAINING_STATS", "lastTrainingIndexPos integer", 0))
    {
      v3 = sqlite3_mprintf("%d", *((_DWORD *)this + 3) + *((_DWORD *)this + 4));
      inserted = (CPMLLog *)CPMLsql_insertIntoTable(*((sqlite3 **)this + 4), "MODEL_TRAINING_STATS", "lastTrainingIndexPos", v3);
      if ((inserted & 0x80000000) != 0)
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(inserted);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "~CPMLIterator", "failed ot write out last training position %d %d", *((_DWORD *)this + 4), *((_DWORD *)this + 3));
      }
      if (v3)
        sqlite3_free(v3);
    }
    v6 = (CPMLFeatureVector *)*((_QWORD *)this + 6);
    if (v6)
    {
      CPMLFeatureVector::~CPMLFeatureVector(v6);
      MEMORY[0x20BD188E4]();
    }
    if (*((_BYTE *)this + 8))
    {
      v7 = (CPMLRemapper *)*((_QWORD *)this + 7);
      if (v7)
      {
        CPMLRemapper::~CPMLRemapper(v7);
        MEMORY[0x20BD188E4]();
      }
    }
    sqlite3_finalize(*((sqlite3_stmt **)this + 5));
  }
}

{
  CPMLIterator::~CPMLIterator(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLIterator::iterateAll(CPMLIterator *this)
{
  int v2;
  CPMLLog *v3;
  uint64_t v4;
  int v5;
  int v6;
  sqlite3_stmt *v7;
  int v8;
  double v9;
  double v10;
  char *v11;
  uint64_t v12;
  int v13;
  pthread_mutex_t *CPMLLog;

  CPMLFeatureVector::resetAll(*((CPMLFeatureVector **)this + 6));
  CPMLFeatureVector::resizeRealVector(*((CPMLFeatureVector **)this + 6), *(_DWORD *)(*((_QWORD *)this + 8) + 120) * *(_DWORD *)(*((_QWORD *)this + 8) + 124));
  if (*(int *)(*((_QWORD *)this + 8) + 120) < 1)
    return *((_QWORD *)this + 6);
  v2 = 0;
  while (1)
  {
    v3 = (CPMLLog *)sqlite3_step(*((sqlite3_stmt **)this + 5));
    if ((_DWORD)v3 != 100)
      break;
    v4 = *((_QWORD *)this + 8);
    if (*(int *)(v4 + 124) >= 1)
    {
      v5 = 0;
      do
      {
        ++CPMLIterator::iterateAll(void)::ct;
        v6 = sqlite3_column_type(*((sqlite3_stmt **)this + 5), v5);
        v7 = (sqlite3_stmt *)*((_QWORD *)this + 5);
        if (v6 == 2 || (v8 = sqlite3_column_type(v7, v5), v7 = (sqlite3_stmt *)*((_QWORD *)this + 5), v8 == 1))
        {
          v9 = sqlite3_column_double(v7, v5);
          v10 = CPMLRemapper::normalizeColumn(*((CPMLRemapper **)this + 7), v9, v5);
        }
        else
        {
          v11 = (char *)sqlite3_column_text(v7, v5);
          v10 = (double)(int)CPMLRemapper::remap(*((CPMLRemapper **)this + 7), v11, v5);
          v12 = *((_QWORD *)this + 8);
          if (*(_BYTE *)(v12 + 136))
            v10 = v10 / (double)*(int *)(v12 + 120);
        }
        CPMLFeatureVector::insertRealVClass(*((CPMLFeatureVector **)this + 6), v10, v2 + *(_DWORD *)(*((_QWORD *)this + 8) + 120) * v5++);
        v4 = *((_QWORD *)this + 8);
      }
      while (v5 < *(_DWORD *)(v4 + 124));
    }
    if (++v2 >= *(_DWORD *)(v4 + 120))
      return *((_QWORD *)this + 6);
  }
  v13 = (int)v3;
  if ((_DWORD)v3 == 101)
    return *((_QWORD *)this + 6);
  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v3);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "iterateAll", "CPCDBDefault: Error iterating All rows %d\n", v13);
  return 0;
}

uint64_t CPMLIterator::iterateFirst(CPMLIterator *this)
{
  int v2;
  int v3;
  uint64_t v4;
  uint64_t v5;
  char v6;
  uint64_t v7;
  sqlite3_stmt *v8;
  int v9;
  sqlite3_stmt *v10;
  int v11;
  int v12;
  double v13;
  int v14;
  sqlite3_stmt *v15;
  int v16;
  double v17;
  uint64_t v18;
  _BOOL4 isOptionAvailable;
  int v21;
  unsigned __int8 *v22;
  uint64_t v23;
  uint64_t v24;
  CPMLLog *v25;
  uint64_t v26;
  char *v27;
  int v28;
  int v29;
  sqlite3_stmt *v30;
  unsigned __int8 *v31;
  uint64_t v32;
  uint64_t v33;
  CPMLLog *v34;
  uint64_t v35;
  char *v36;
  int v37;
  int v38;
  char *v39;
  char *v40;
  uint64_t v41;
  uint64_t v42;
  size_t *v43;
  const char *v44;
  size_t v45;
  size_t v46;
  int v47;
  pthread_mutex_t *CPMLLog;
  _QWORD *YVectorVector;
  uint64_t v50;
  size_t *v51;
  const char *v52;
  size_t v53;
  int v54;
  pthread_mutex_t *v55;
  _QWORD v57[2];

  v57[1] = *MEMORY[0x24BDAC8D0];
  while (1)
  {
    v2 = sqlite3_step(*((sqlite3_stmt **)this + 5));
    if (v2 == 101)
      return 0;
    v3 = v2;
    CPMLFeatureVector::resetAll(*((CPMLFeatureVector **)this + 6));
    if (v3 != 100)
      return 0;
    ++*((_DWORD *)this + 4);
    v4 = *((_QWORD *)this + 8);
    if (*(int *)(v4 + 124) < 1)
      return *((_QWORD *)this + 6);
    v5 = 0;
    v6 = 1;
    do
    {
      v7 = *(unsigned int *)(v4 + 128);
      v8 = (sqlite3_stmt *)*((_QWORD *)this + 5);
      if (v5 == v7)
      {
        v9 = sqlite3_column_type(v8, v7);
        v10 = (sqlite3_stmt *)*((_QWORD *)this + 5);
        v11 = *(_DWORD *)(*((_QWORD *)this + 8) + 128);
        if (v9 == 2
          || (v12 = sqlite3_column_type(v10, v11),
              v10 = (sqlite3_stmt *)*((_QWORD *)this + 5),
              v11 = *(_DWORD *)(*((_QWORD *)this + 8) + 128),
              v12 == 1))
        {
          v13 = sqlite3_column_double(v10, v11);
        }
        else
        {
          if (sqlite3_column_type(v10, v11) == 4)
          {
            v21 = *(_DWORD *)(*((_QWORD *)this + 8) + 128);
            v22 = (unsigned __int8 *)sqlite3_column_blob(*((sqlite3_stmt **)this + 5), v21);
            v23 = sqlite3_column_bytes(*((sqlite3_stmt **)this + 5), v21);
            v25 = (CPMLLog *)MEMORY[0x24BDAC7A8](v23, v24);
            v27 = (char *)v57 - v26;
            v28 = *v22;
            if (v28 == 83)
            {
              v42 = *(_QWORD *)(v22 + 1);
              if (v42)
              {
                v43 = (size_t *)(v22 + 9);
                do
                {
                  v46 = *v43;
                  v44 = (const char *)(v43 + 1);
                  v45 = v46;
                  strlcpy(v27, v44, v46);
                  v47 = CPMLRemapper::remap(*((CPMLRemapper **)this + 7), v27, v21);
                  if ((v47 & 0x80000000) == 0)
                    CPMLFeatureVector::insertYIntVClass(*((CPMLFeatureVector **)this + 6), v47);
                  v43 = (size_t *)&v44[v45];
                  --v42;
                }
                while (v42);
                v13 = (double)v47;
                goto LABEL_44;
              }
            }
            else
            {
              if (v28 == 78)
              {
                v13 = (double)(int)CPMLRemapper::remap(*((CPMLRemapper **)this + 7), "", v21);
                goto LABEL_44;
              }
              CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v25);
              CPMLLog::log(CPMLLog, CPML_LOG_ERR, "iterateFirst", "Encoding unsupported");
            }
            v13 = 0.0;
LABEL_44:
            YVectorVector = (_QWORD *)CPMLFeatureVector::getYVectorVector(*((CPMLFeatureVector **)this + 6));
            if (YVectorVector[1] == *YVectorVector)
              v6 = 0;
            goto LABEL_17;
          }
          v39 = (char *)sqlite3_column_text(*((sqlite3_stmt **)this + 5), *(_DWORD *)(*((_QWORD *)this + 8) + 128));
          v13 = (double)(int)CPMLRemapper::remap(*((CPMLRemapper **)this + 7), v39, *(_DWORD *)(*((_QWORD *)this + 8) + 128));
        }
        CPMLFeatureVector::setYHat(*((_QWORD *)this + 6), v13);
      }
      else
      {
        v14 = sqlite3_column_type(v8, v5);
        v15 = (sqlite3_stmt *)*((_QWORD *)this + 5);
        if (v14 == 2 || (v16 = sqlite3_column_type(v15, v5), v15 = (sqlite3_stmt *)*((_QWORD *)this + 5), v16 == 1))
        {
          v17 = sqlite3_column_double(v15, v5);
          v13 = CPMLRemapper::normalizeColumn(*((CPMLRemapper **)this + 7), v17, v5);
        }
        else
        {
          v29 = sqlite3_column_type(v15, v5);
          v30 = (sqlite3_stmt *)*((_QWORD *)this + 5);
          if (v29 == 4)
          {
            v31 = (unsigned __int8 *)sqlite3_column_blob(v30, v5);
            v32 = sqlite3_column_bytes(*((sqlite3_stmt **)this + 5), v5);
            v34 = (CPMLLog *)MEMORY[0x24BDAC7A8](v32, v33);
            v36 = (char *)v57 - v35;
            v37 = *v31;
            if (v37 != 83)
            {
              if (v37 == 78)
              {
                v38 = CPMLRemapper::remap(*((CPMLRemapper **)this + 7), "", v5);
                CPMLFeatureVector::insertIntToLastVVClass(*((CPMLFeatureVector **)this + 6), v38);
              }
              else
              {
                v55 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v34);
                CPMLLog::log(v55, CPML_LOG_ERR, "iterateFirst", "Encoding unsupported");
              }
              goto LABEL_22;
            }
            v50 = *(_QWORD *)(v31 + 1);
            v13 = 666.666;
            if (v50)
            {
              v51 = (size_t *)(v31 + 9);
              do
              {
                v53 = *v51;
                v52 = (const char *)(v51 + 1);
                strlcpy(v36, v52, v53);
                v54 = CPMLRemapper::remap(*((CPMLRemapper **)this + 7), v36, v5);
                CPMLFeatureVector::insertIntToLastVVClass(*((CPMLFeatureVector **)this + 6), v54);
                v51 = (size_t *)&v52[v53];
                --v50;
              }
              while (v50);
              v13 = (double)v54;
            }
          }
          else
          {
            v40 = (char *)sqlite3_column_text(v30, v5);
            v13 = (double)(int)CPMLRemapper::remap(*((CPMLRemapper **)this + 7), v40, v5);
            v41 = *((_QWORD *)this + 8);
            if (*(_BYTE *)(v41 + 136))
              v13 = v13 / (double)*(int *)(v41 + 120);
          }
        }
        v18 = *((_QWORD *)this + 8);
        if (*(_DWORD *)(*(_QWORD *)(v18 + 72) + 4 * v5) || *(_BYTE *)(v18 + 136))
          CPMLFeatureVector::insertRealVClass(*((CPMLFeatureVector **)this + 6), v13);
        else
          CPMLFeatureVector::insertIntVClass(*((CPMLFeatureVector **)this + 6), (int)v13);
      }
LABEL_17:
      isOptionAvailable = CPMLTunableData::isOptionAvailable(*((CPMLTunableData **)this + 9), v5);
      if (v13 > 0.0 && isOptionAvailable)
        v6 = 0;
LABEL_22:
      ++v5;
      v4 = *((_QWORD *)this + 8);
    }
    while (v5 < *(int *)(v4 + 124));
    if ((v6 & 1) != 0)
      return *((_QWORD *)this + 6);
  }
}

uint64_t CPMLIterator::iterateNext(CPMLIterator *this)
{
  return (*(uint64_t (**)(CPMLIterator *))(*(_QWORD *)this + 24))(this);
}

uint64_t CPMLIterator::iterateReset(CPMLIterator *this)
{
  *((_DWORD *)this + 4) = 0;
  return sqlite3_reset(*((sqlite3_stmt **)this + 5));
}

void CPMLTunableData::CPMLTunableData(CPMLTunableData *this, void *a2, void *a3)
{
  void *v5;
  void *v6;

  v5 = a2;
  this->var1 = (void *)objc_msgSend(v5, "objectForKey:", CFSTR("tuneableDictionary"));
  objc_msgSend(v5, "objectForKey:", CFSTR("tuneableDictionary"));
  v6 = (void *)objc_claimAutoreleasedReturnValue();
  this->var0 = objc_msgSend(v6, "count");
  this->var2 = a3;

}

void sub_209CCEF9C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void *CPMLTunableData::getNSNumFrom(CPMLTunableData *this, const char *a2)
{
  void *v4;
  void *v5;

  if (!this->var1)
    NSLog(CFSTR("%s mData Empty"), "getNSNumFrom");
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  objc_msgSend(this->var1, "objectForKey:", v4);
  v5 = (void *)objc_claimAutoreleasedReturnValue();

  return v5;
}

void sub_209CCF044(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetBool(CPMLTunableData *this, const char *a2, BOOL *a3)
{
  void *v4;

  CPMLTunableData::getNSNumFrom(this, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *a3 = objc_msgSend(v4, "BOOLValue");

  return 0;
}

void sub_209CCF08C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetInt(CPMLTunableData *this, const char *a2, int *a3)
{
  void *v4;

  CPMLTunableData::getNSNumFrom(this, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *a3 = objc_msgSend(v4, "intValue");

  return 0;
}

void sub_209CCF0D4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetUInt(CPMLTunableData *this, const char *a2, unsigned int *a3)
{
  void *v4;

  CPMLTunableData::getNSNumFrom(this, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *a3 = objc_msgSend(v4, "unsignedIntValue");

  return 0;
}

void sub_209CCF11C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetUInt64(CPMLTunableData *this, const char *a2, unint64_t *a3)
{
  void *v4;

  CPMLTunableData::getNSNumFrom(this, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  *a3 = objc_msgSend(v4, "unsignedLongLongValue");

  return 0;
}

void sub_209CCF164(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetDouble(CPMLTunableData *this, const char *a2, double *a3)
{
  void *v4;
  uint64_t v5;

  CPMLTunableData::getNSNumFrom(this, a2);
  v4 = (void *)objc_claimAutoreleasedReturnValue();
  objc_msgSend(v4, "doubleValue");
  *(_QWORD *)a3 = v5;

  return 0;
}

void sub_209CCF1AC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::tDataGetString(CPMLTunableData *this, const char *a2, char *a3, size_t a4)
{
  void *v8;
  void *v9;
  void *v10;

  if (!this->var1)
    NSLog(CFSTR("%s mData Empty"), "tDataGetString");
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  objc_msgSend(this->var1, "objectForKey:", v8);
  v9 = (void *)objc_claimAutoreleasedReturnValue();
  v10 = v9;
  if (v9)
    strlcpy(a3, (const char *)objc_msgSend(objc_retainAutorelease(v9), "UTF8String"), a4);
  else
    strlcpy(a3, "", 0);

  return 0;
}

void sub_209CCF288(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLTunableData::getNumberOfItems(CPMLTunableData *this)
{
  return this->var0;
}

BOOL CPMLTunableData::isOptionAvailable(CPMLTunableData *this, int a2)
{
  void *v3;
  void *v4;
  void *v5;
  _BOOL8 v6;

  v3 = this->var2;
  if (objc_msgSend(v3, "count") <= (unint64_t)a2)
  {
    v6 = 0;
  }
  else
  {
    objc_msgSend(v3, "objectAtIndexedSubscript:");
    v4 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(MEMORY[0x24BDBCEF8], "null");
    v5 = (void *)objc_claimAutoreleasedReturnValue();
    v6 = v4 != v5;

  }
  return v6;
}

void sub_209CCF32C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void CPMLStatistics::allocateMemory(CPMLStatistics *this)
{
  std::vector<int>::reserve((std::vector<int> *)this + 3, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 3, *((int *)this + 31));
  std::vector<int>::reserve((std::vector<int> *)this, *((int *)this + 31));
  std::vector<int>::reserve((std::vector<int> *)this + 2, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 18, *((int *)this + 31));
  std::vector<int>::reserve((std::vector<int> *)this + 4, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 21, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 24, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 27, *((int *)this + 31));
  std::vector<double>::reserve((void **)this + 30, *((int *)this + 31));
}

void std::vector<int>::reserve(std::vector<int> *this, std::vector<int>::size_type __n)
{
  std::__compressed_pair<int *> *p_end_cap;
  int *value;
  int64_t v5;
  char *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  std::vector<int>::pointer begin;
  int *end;
  int *v12;
  int v13;

  value = this->__end_cap_.__value_;
  p_end_cap = &this->__end_cap_;
  if (__n > value - this->__begin_)
  {
    if (__n >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (char *)this->__end_ - (char *)this->__begin_;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)p_end_cap, __n);
    v7 = (int *)&v6[v5 & 0xFFFFFFFFFFFFFFFCLL];
    v9 = (int *)&v6[4 * v8];
    begin = this->__begin_;
    end = this->__end_;
    v12 = v7;
    if (end != this->__begin_)
    {
      v12 = v7;
      do
      {
        v13 = *--end;
        *--v12 = v13;
      }
      while (end != begin);
    }
    this->__begin_ = v12;
    this->__end_ = v7;
    this->__end_cap_.__value_ = v9;
    if (begin)
      operator delete(begin);
  }
}

void std::vector<double>::reserve(void **a1, unint64_t a2)
{
  uint64_t v3;
  _BYTE *v4;
  int64_t v5;
  char *v6;
  char *v7;
  uint64_t v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  uint64_t v13;

  v4 = a1[2];
  v3 = (uint64_t)(a1 + 2);
  if (a2 > (v4 - (_BYTE *)*a1) >> 3)
  {
    if (a2 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v5 = (_BYTE *)a1[1] - (_BYTE *)*a1;
    v6 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3, a2);
    v7 = &v6[v5 & 0xFFFFFFFFFFFFFFF8];
    v9 = &v6[8 * v8];
    v10 = (char *)*a1;
    v11 = (char *)a1[1];
    v12 = v7;
    if (v11 != *a1)
    {
      v12 = v7;
      do
      {
        v13 = *((_QWORD *)v11 - 1);
        v11 -= 8;
        *((_QWORD *)v12 - 1) = v13;
        v12 -= 8;
      }
      while (v11 != v10);
    }
    *a1 = v12;
    a1[1] = v7;
    a1[2] = v9;
    if (v10)
      operator delete(v10);
  }
}

uint64_t CPMLStatistics::CPMLStatistics(uint64_t a1, int a2, int a3)
{
  *(_OWORD *)(a1 + 144) = 0u;
  *(_QWORD *)(a1 + 112) = 0;
  *(_OWORD *)(a1 + 80) = 0u;
  *(_OWORD *)(a1 + 96) = 0u;
  *(_OWORD *)(a1 + 48) = 0u;
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 192) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_OWORD *)(a1 + 240) = 0u;
  *(_QWORD *)(a1 + 256) = 0;
  *(_DWORD *)(a1 + 124) = a2;
  *(_BYTE *)(a1 + 136) = a3 != 0;
  CPMLStatistics::allocateMemory((CPMLStatistics *)a1);
  return a1;
}

void sub_209CCF56C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void **v2;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;
  void *v12;
  void *v13;

  v4 = *(void **)(v1 + 240);
  if (v4)
  {
    *(_QWORD *)(v1 + 248) = v4;
    operator delete(v4);
  }
  v5 = *(void **)(v1 + 216);
  if (v5)
  {
    *(_QWORD *)(v1 + 224) = v5;
    operator delete(v5);
  }
  v6 = *(void **)(v1 + 192);
  if (v6)
  {
    *(_QWORD *)(v1 + 200) = v6;
    operator delete(v6);
  }
  v7 = *(void **)(v1 + 168);
  if (v7)
  {
    *(_QWORD *)(v1 + 176) = v7;
    operator delete(v7);
  }
  v8 = *v2;
  if (*v2)
  {
    *(_QWORD *)(v1 + 152) = v8;
    operator delete(v8);
  }
  v9 = *(void **)(v1 + 96);
  if (v9)
  {
    *(_QWORD *)(v1 + 104) = v9;
    operator delete(v9);
  }
  v10 = *(void **)(v1 + 72);
  if (v10)
  {
    *(_QWORD *)(v1 + 80) = v10;
    operator delete(v10);
  }
  v11 = *(void **)(v1 + 48);
  if (v11)
  {
    *(_QWORD *)(v1 + 56) = v11;
    operator delete(v11);
  }
  v12 = *(void **)(v1 + 24);
  if (v12)
  {
    *(_QWORD *)(v1 + 32) = v12;
    operator delete(v12);
  }
  v13 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v13;
    operator delete(v13);
  }
  _Unwind_Resume(exception_object);
}

uint64_t CPMLStatistics::CPMLStatistics(uint64_t a1, void *a2, int a3)
{
  void **v5;
  id v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  int v11;
  unint64_t v12;
  char *v13;
  _DWORD *v14;
  char *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  int v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  char *v26;
  _DWORD *v27;
  double v28;
  unint64_t v29;
  double *v30;
  double *v31;
  char *v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  unint64_t v36;
  char *v37;
  double *v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  unint64_t v42;
  char *v43;
  char *v44;
  int v45;
  double *v46;
  uint64_t v47;
  double v48;
  unint64_t v49;
  double *v50;
  double *v51;
  double *v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  unint64_t v56;
  char *v57;
  double *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  char *v63;
  _QWORD *v64;
  char *v65;
  uint64_t v66;
  unint64_t v67;
  uint64_t v68;
  unint64_t v69;
  char *v70;
  char *v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  char *v76;
  _QWORD *v77;
  char *v78;
  uint64_t v79;
  unint64_t v80;
  uint64_t v81;
  unint64_t v82;
  char *v83;
  char *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  char *v89;
  _QWORD *v90;
  char *v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  unint64_t v95;
  char *v96;
  char *v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  unint64_t v101;
  char *v102;
  _QWORD *v103;
  char *v104;
  uint64_t v105;
  unint64_t v106;
  uint64_t v107;
  unint64_t v108;
  char *v109;
  char *v110;
  uint64_t v111;
  void *v112;
  void *v113;
  void *v114;
  int v115;
  int v116;
  unint64_t v117;
  char *v118;
  _DWORD *v119;
  char *v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  unint64_t v124;
  char *v125;
  char *v126;
  int v127;
  unint64_t v128;
  _DWORD *v129;
  _DWORD *v130;
  _DWORD *v131;
  uint64_t v132;
  unint64_t v133;
  uint64_t v134;
  unint64_t v135;
  char *v136;
  char *v137;
  int v138;
  uint64_t v140;
  void **v141;
  void **v142;
  void **v143;
  void **v144;
  void **v145;
  void **v146;
  void **v147;
  void **v148;

  *(_OWORD *)(a1 + 48) = 0u;
  v142 = (void **)(a1 + 48);
  *(_OWORD *)(a1 + 96) = 0u;
  v143 = (void **)(a1 + 96);
  *(_OWORD *)(a1 + 144) = 0u;
  v148 = (void **)(a1 + 144);
  *(_OWORD *)(a1 + 192) = 0u;
  v146 = (void **)(a1 + 192);
  *(_OWORD *)(a1 + 240) = 0u;
  v144 = (void **)(a1 + 240);
  *(_QWORD *)(a1 + 112) = 0;
  v141 = (void **)(a1 + 24);
  *(_OWORD *)(a1 + 64) = 0u;
  *(_OWORD *)(a1 + 80) = 0u;
  v5 = (void **)(a1 + 72);
  v147 = (void **)(a1 + 168);
  *(_OWORD *)(a1 + 16) = 0u;
  *(_OWORD *)(a1 + 32) = 0u;
  v145 = (void **)(a1 + 216);
  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 160) = 0u;
  *(_OWORD *)(a1 + 176) = 0u;
  *(_OWORD *)(a1 + 208) = 0u;
  *(_OWORD *)(a1 + 224) = 0u;
  *(_QWORD *)(a1 + 256) = 0;
  *(_QWORD *)(a1 + 264) = a2;
  v6 = a2;
  *(_DWORD *)(a1 + 124) = objc_msgSend(v6, "getColumnCount");
  v7 = objc_msgSend(v6, "getYColumnPosition");
  *(_DWORD *)(a1 + 128) = v7;
  *(_DWORD *)(a1 + 132) = objc_msgSend(v6, "getCombinedRemapTableCardinality:", v7);
  *(_DWORD *)(a1 + 120) = objc_msgSend(v6, "getRowCount");
  *(_BYTE *)(a1 + 136) = a3 != 0;
  CPMLStatistics::allocateMemory((CPMLStatistics *)a1);
  v8 = *(_DWORD *)(a1 + 124);
  if (v8 >= 1)
  {
    v9 = 0;
    do
    {
      v10 = objc_msgSend(v6, "isColumnContinousData:", v9);
      v11 = v10;
      v13 = *(char **)(a1 + 80);
      v12 = *(_QWORD *)(a1 + 88);
      if ((unint64_t)v13 >= v12)
      {
        v15 = (char *)*v5;
        v16 = (v13 - (_BYTE *)*v5) >> 2;
        v17 = v16 + 1;
        if ((unint64_t)(v16 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v18 = v12 - (_QWORD)v15;
        if (v18 >> 1 > v17)
          v17 = v18 >> 1;
        if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL)
          v19 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v19 = v17;
        if (v19)
        {
          v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a1 + 88, v19);
          v15 = *(char **)(a1 + 72);
          v13 = *(char **)(a1 + 80);
        }
        else
        {
          v20 = 0;
        }
        v21 = &v20[4 * v16];
        *(_DWORD *)v21 = v11;
        v14 = v21 + 4;
        while (v13 != v15)
        {
          v22 = *((_DWORD *)v13 - 1);
          v13 -= 4;
          *((_DWORD *)v21 - 1) = v22;
          v21 -= 4;
        }
        *(_QWORD *)(a1 + 72) = v21;
        *(_QWORD *)(a1 + 80) = v14;
        *(_QWORD *)(a1 + 88) = &v20[4 * v19];
        if (v15)
          operator delete(v15);
      }
      else
      {
        *(_DWORD *)v13 = v10;
        v14 = v13 + 4;
      }
      *(_QWORD *)(a1 + 80) = v14;
      v9 = (v9 + 1);
      v8 = *(_DWORD *)(a1 + 124);
    }
    while ((int)v9 < v8);
  }
  if (v8)
  {
    v23 = 0;
    v140 = a1 + 16;
    do
    {
      v24 = objc_msgSend(v6, "getCardinality:", v23, v140);
      if (objc_msgSend(v6, "getSchemaType:", v23) == 7)
      {
        v26 = *(char **)(a1 + 56);
        v25 = *(_QWORD *)(a1 + 64);
        if ((unint64_t)v26 >= v25)
        {
          v32 = (char *)*v142;
          v33 = (v26 - (_BYTE *)*v142) >> 2;
          v34 = v33 + 1;
          if ((unint64_t)(v33 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v35 = v25 - (_QWORD)v32;
          if (v35 >> 1 > v34)
            v34 = v35 >> 1;
          if ((unint64_t)v35 >= 0x7FFFFFFFFFFFFFFCLL)
            v36 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v36 = v34;
          if (v36)
          {
            v37 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a1 + 64, v36);
            v32 = *(char **)(a1 + 48);
            v26 = *(char **)(a1 + 56);
          }
          else
          {
            v37 = 0;
          }
          v44 = &v37[4 * v33];
          *(_DWORD *)v44 = v24;
          v27 = v44 + 4;
          while (v26 != v32)
          {
            v45 = *((_DWORD *)v26 - 1);
            v26 -= 4;
            *((_DWORD *)v44 - 1) = v45;
            v44 -= 4;
          }
          *(_QWORD *)(a1 + 48) = v44;
          *(_QWORD *)(a1 + 56) = v27;
          *(_QWORD *)(a1 + 64) = &v37[4 * v36];
          if (v32)
            operator delete(v32);
        }
        else
        {
          *(_DWORD *)v26 = v24;
          v27 = v26 + 4;
        }
        *(_QWORD *)(a1 + 56) = v27;
      }
      else if (*((_DWORD *)*v5 + v23) || *(_BYTE *)(a1 + 136))
      {
        v28 = (double)v24;
        v30 = *(double **)(a1 + 32);
        v29 = *(_QWORD *)(a1 + 40);
        if ((unint64_t)v30 >= v29)
        {
          v38 = (double *)*v141;
          v39 = ((char *)v30 - (_BYTE *)*v141) >> 3;
          v40 = v39 + 1;
          if ((unint64_t)(v39 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v41 = v29 - (_QWORD)v38;
          if (v41 >> 2 > v40)
            v40 = v41 >> 2;
          if ((unint64_t)v41 >= 0x7FFFFFFFFFFFFFF8)
            v42 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v42 = v40;
          if (v42)
          {
            v43 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 40, v42);
            v38 = *(double **)(a1 + 24);
            v30 = *(double **)(a1 + 32);
          }
          else
          {
            v43 = 0;
          }
          v46 = (double *)&v43[8 * v39];
          *v46 = v28;
          v31 = v46 + 1;
          while (v30 != v38)
          {
            v47 = *((_QWORD *)v30-- - 1);
            *((_QWORD *)v46-- - 1) = v47;
          }
          *(_QWORD *)(a1 + 24) = v46;
          *(_QWORD *)(a1 + 32) = v31;
          *(_QWORD *)(a1 + 40) = &v43[8 * v42];
          if (v38)
            operator delete(v38);
        }
        else
        {
          *v30 = v28;
          v31 = v30 + 1;
        }
        *(_QWORD *)(a1 + 32) = v31;
      }
      else
      {
        v129 = *(_DWORD **)(a1 + 8);
        v128 = *(_QWORD *)(a1 + 16);
        if ((unint64_t)v129 >= v128)
        {
          v131 = *(_DWORD **)a1;
          v132 = ((uint64_t)v129 - *(_QWORD *)a1) >> 2;
          v133 = v132 + 1;
          if ((unint64_t)(v132 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v134 = v128 - (_QWORD)v131;
          if (v134 >> 1 > v133)
            v133 = v134 >> 1;
          if ((unint64_t)v134 >= 0x7FFFFFFFFFFFFFFCLL)
            v135 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v135 = v133;
          if (v135)
          {
            v136 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v140, v135);
            v131 = *(_DWORD **)a1;
            v129 = *(_DWORD **)(a1 + 8);
          }
          else
          {
            v136 = 0;
          }
          v137 = &v136[4 * v132];
          *(_DWORD *)v137 = v24;
          v130 = v137 + 4;
          while (v129 != v131)
          {
            v138 = *--v129;
            *((_DWORD *)v137 - 1) = v138;
            v137 -= 4;
          }
          *(_QWORD *)a1 = v137;
          *(_QWORD *)(a1 + 8) = v130;
          *(_QWORD *)(a1 + 16) = &v136[4 * v135];
          if (v131)
            operator delete(v131);
        }
        else
        {
          *v129 = v24;
          v130 = v129 + 1;
        }
        *(_QWORD *)(a1 + 8) = v130;
      }
      v48 = (double)v24;
      v50 = *(double **)(a1 + 152);
      v49 = *(_QWORD *)(a1 + 160);
      if ((unint64_t)v50 >= v49)
      {
        v52 = (double *)*v148;
        v53 = ((char *)v50 - (_BYTE *)*v148) >> 3;
        v54 = v53 + 1;
        if ((unint64_t)(v53 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v55 = v49 - (_QWORD)v52;
        if (v55 >> 2 > v54)
          v54 = v55 >> 2;
        if ((unint64_t)v55 >= 0x7FFFFFFFFFFFFFF8)
          v56 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v56 = v54;
        if (v56)
        {
          v57 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 160, v56);
          v52 = *(double **)(a1 + 144);
          v50 = *(double **)(a1 + 152);
        }
        else
        {
          v57 = 0;
        }
        v58 = (double *)&v57[8 * v53];
        *v58 = v48;
        v51 = v58 + 1;
        while (v50 != v52)
        {
          v59 = *((_QWORD *)v50-- - 1);
          *((_QWORD *)v58-- - 1) = v59;
        }
        *(_QWORD *)(a1 + 144) = v58;
        *(_QWORD *)(a1 + 152) = v51;
        *(_QWORD *)(a1 + 160) = &v57[8 * v56];
        if (v52)
          operator delete(v52);
      }
      else
      {
        *v50 = v48;
        v51 = v50 + 1;
      }
      *(_QWORD *)(a1 + 152) = v51;
      objc_msgSend(v6, "getMeanFor:", v23);
      v61 = v60;
      v63 = *(char **)(a1 + 176);
      v62 = *(_QWORD *)(a1 + 184);
      if ((unint64_t)v63 >= v62)
      {
        v65 = (char *)*v147;
        v66 = (v63 - (_BYTE *)*v147) >> 3;
        v67 = v66 + 1;
        if ((unint64_t)(v66 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v68 = v62 - (_QWORD)v65;
        if (v68 >> 2 > v67)
          v67 = v68 >> 2;
        if ((unint64_t)v68 >= 0x7FFFFFFFFFFFFFF8)
          v69 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v69 = v67;
        if (v69)
        {
          v70 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 184, v69);
          v65 = *(char **)(a1 + 168);
          v63 = *(char **)(a1 + 176);
        }
        else
        {
          v70 = 0;
        }
        v71 = &v70[8 * v66];
        *(_QWORD *)v71 = v61;
        v64 = v71 + 8;
        while (v63 != v65)
        {
          v72 = *((_QWORD *)v63 - 1);
          v63 -= 8;
          *((_QWORD *)v71 - 1) = v72;
          v71 -= 8;
        }
        *(_QWORD *)(a1 + 168) = v71;
        *(_QWORD *)(a1 + 176) = v64;
        *(_QWORD *)(a1 + 184) = &v70[8 * v69];
        if (v65)
          operator delete(v65);
      }
      else
      {
        *(_QWORD *)v63 = v60;
        v64 = v63 + 8;
      }
      *(_QWORD *)(a1 + 176) = v64;
      objc_msgSend(v6, "getStdDevFor:", v23);
      v74 = v73;
      v76 = *(char **)(a1 + 200);
      v75 = *(_QWORD *)(a1 + 208);
      if ((unint64_t)v76 >= v75)
      {
        v78 = (char *)*v146;
        v79 = (v76 - (_BYTE *)*v146) >> 3;
        v80 = v79 + 1;
        if ((unint64_t)(v79 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v81 = v75 - (_QWORD)v78;
        if (v81 >> 2 > v80)
          v80 = v81 >> 2;
        if ((unint64_t)v81 >= 0x7FFFFFFFFFFFFFF8)
          v82 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v82 = v80;
        if (v82)
        {
          v83 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 208, v82);
          v78 = *(char **)(a1 + 192);
          v76 = *(char **)(a1 + 200);
        }
        else
        {
          v83 = 0;
        }
        v84 = &v83[8 * v79];
        *(_QWORD *)v84 = v74;
        v77 = v84 + 8;
        while (v76 != v78)
        {
          v85 = *((_QWORD *)v76 - 1);
          v76 -= 8;
          *((_QWORD *)v84 - 1) = v85;
          v84 -= 8;
        }
        *(_QWORD *)(a1 + 192) = v84;
        *(_QWORD *)(a1 + 200) = v77;
        *(_QWORD *)(a1 + 208) = &v83[8 * v82];
        if (v78)
          operator delete(v78);
      }
      else
      {
        *(_QWORD *)v76 = v73;
        v77 = v76 + 8;
      }
      *(_QWORD *)(a1 + 200) = v77;
      objc_msgSend(v6, "getMinFor:", v23);
      v87 = v86;
      v89 = *(char **)(a1 + 224);
      v88 = *(_QWORD *)(a1 + 232);
      if ((unint64_t)v89 >= v88)
      {
        v91 = (char *)*v145;
        v92 = (v89 - (_BYTE *)*v145) >> 3;
        v93 = v92 + 1;
        if ((unint64_t)(v92 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v94 = v88 - (_QWORD)v91;
        if (v94 >> 2 > v93)
          v93 = v94 >> 2;
        if ((unint64_t)v94 >= 0x7FFFFFFFFFFFFFF8)
          v95 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v95 = v93;
        if (v95)
        {
          v96 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 232, v95);
          v91 = *(char **)(a1 + 216);
          v89 = *(char **)(a1 + 224);
        }
        else
        {
          v96 = 0;
        }
        v97 = &v96[8 * v92];
        *(_QWORD *)v97 = v87;
        v90 = v97 + 8;
        while (v89 != v91)
        {
          v98 = *((_QWORD *)v89 - 1);
          v89 -= 8;
          *((_QWORD *)v97 - 1) = v98;
          v97 -= 8;
        }
        *(_QWORD *)(a1 + 216) = v97;
        *(_QWORD *)(a1 + 224) = v90;
        *(_QWORD *)(a1 + 232) = &v96[8 * v95];
        if (v91)
          operator delete(v91);
      }
      else
      {
        *(_QWORD *)v89 = v86;
        v90 = v89 + 8;
      }
      *(_QWORD *)(a1 + 224) = v90;
      objc_msgSend(v6, "getMaxFor:", v23);
      v100 = v99;
      v102 = *(char **)(a1 + 248);
      v101 = *(_QWORD *)(a1 + 256);
      if ((unint64_t)v102 >= v101)
      {
        v104 = (char *)*v144;
        v105 = (v102 - (_BYTE *)*v144) >> 3;
        v106 = v105 + 1;
        if ((unint64_t)(v105 + 1) >> 61)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v107 = v101 - (_QWORD)v104;
        if (v107 >> 2 > v106)
          v106 = v107 >> 2;
        if ((unint64_t)v107 >= 0x7FFFFFFFFFFFFFF8)
          v108 = 0x1FFFFFFFFFFFFFFFLL;
        else
          v108 = v106;
        if (v108)
        {
          v109 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(a1 + 256, v108);
          v104 = *(char **)(a1 + 240);
          v102 = *(char **)(a1 + 248);
        }
        else
        {
          v109 = 0;
        }
        v110 = &v109[8 * v105];
        *(_QWORD *)v110 = v100;
        v103 = v110 + 8;
        while (v102 != v104)
        {
          v111 = *((_QWORD *)v102 - 1);
          v102 -= 8;
          *((_QWORD *)v110 - 1) = v111;
          v110 -= 8;
        }
        *(_QWORD *)(a1 + 240) = v110;
        *(_QWORD *)(a1 + 248) = v103;
        *(_QWORD *)(a1 + 256) = &v109[8 * v108];
        if (v104)
          operator delete(v104);
      }
      else
      {
        *(_QWORD *)v102 = v99;
        v103 = v102 + 8;
      }
      *(_QWORD *)(a1 + 248) = v103;
      objc_msgSend(v6, "getRemapTable");
      v112 = (void *)objc_claimAutoreleasedReturnValue();
      objc_msgSend(v112, "objectAtIndex:", v23);
      v113 = (void *)objc_claimAutoreleasedReturnValue();
      v114 = v113;
      if (v113)
      {
        v115 = objc_msgSend(v113, "intValue");
        v116 = v115;
        v118 = *(char **)(a1 + 104);
        v117 = *(_QWORD *)(a1 + 112);
        if ((unint64_t)v118 >= v117)
        {
          v120 = (char *)*v143;
          v121 = (v118 - (_BYTE *)*v143) >> 2;
          v122 = v121 + 1;
          if ((unint64_t)(v121 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v123 = v117 - (_QWORD)v120;
          if (v123 >> 1 > v122)
            v122 = v123 >> 1;
          if ((unint64_t)v123 >= 0x7FFFFFFFFFFFFFFCLL)
            v124 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v124 = v122;
          if (v124)
          {
            v125 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a1 + 112, v124);
            v120 = *(char **)(a1 + 96);
            v118 = *(char **)(a1 + 104);
          }
          else
          {
            v125 = 0;
          }
          v126 = &v125[4 * v121];
          *(_DWORD *)v126 = v116;
          v119 = v126 + 4;
          while (v118 != v120)
          {
            v127 = *((_DWORD *)v118 - 1);
            v118 -= 4;
            *((_DWORD *)v126 - 1) = v127;
            v126 -= 4;
          }
          *(_QWORD *)(a1 + 96) = v126;
          *(_QWORD *)(a1 + 104) = v119;
          *(_QWORD *)(a1 + 112) = &v125[4 * v124];
          if (v120)
            operator delete(v120);
        }
        else
        {
          *(_DWORD *)v118 = v115;
          v119 = v118 + 4;
        }
        *(_QWORD *)(a1 + 104) = v119;
      }

      ++v23;
    }
    while (v23 < *(unsigned int *)(a1 + 124));
  }

  return a1;
}

void sub_209CCFF58(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void **a13, void **a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void **a20,void **a21,void **a22,void **a23,void **a24)
{
  uint64_t v24;
  void *v25;
  void **v26;
  uint64_t v27;
  void *v29;
  void *v30;
  void *v31;
  void *v32;
  void *v33;
  void *v34;
  void *v35;
  void *v36;
  void *v37;
  void *v38;

  v29 = *a21;
  if (*a21)
  {
    *(_QWORD *)(v24 + 248) = v29;
    operator delete(v29);
  }
  v30 = *a22;
  if (*a22)
  {
    *(_QWORD *)(v24 + 224) = v30;
    operator delete(v30);
  }
  v31 = *a23;
  if (*a23)
  {
    *(_QWORD *)(v24 + 200) = v31;
    operator delete(v31);
  }
  v32 = *a24;
  if (*a24)
  {
    *(_QWORD *)(v24 + 176) = v32;
    operator delete(v32);
  }
  v33 = **(void ***)(v27 - 112);
  if (v33)
  {
    *(_QWORD *)(v24 + 152) = v33;
    operator delete(v33);
  }
  v34 = *a20;
  if (*a20)
  {
    *(_QWORD *)(v24 + 104) = v34;
    operator delete(v34);
  }
  v35 = *v26;
  if (*v26)
  {
    *(_QWORD *)(v24 + 80) = v35;
    operator delete(v35);
  }
  v36 = *a14;
  if (*a14)
  {
    *(_QWORD *)(v24 + 56) = v36;
    operator delete(v36);
  }
  v37 = *a13;
  if (*a13)
  {
    *(_QWORD *)(v24 + 32) = v37;
    operator delete(v37);
  }
  v38 = *(void **)v24;
  if (*(_QWORD *)v24)
  {
    *(_QWORD *)(v24 + 8) = v38;
    operator delete(v38);
  }
  _Unwind_Resume(a1);
}

void CPMLStatistics::~CPMLStatistics(CPMLStatistics *this)
{
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;
  void *v9;
  void *v10;
  void *v11;

  v2 = (void *)*((_QWORD *)this + 30);
  if (v2)
  {
    *((_QWORD *)this + 31) = v2;
    operator delete(v2);
  }
  v3 = (void *)*((_QWORD *)this + 27);
  if (v3)
  {
    *((_QWORD *)this + 28) = v3;
    operator delete(v3);
  }
  v4 = (void *)*((_QWORD *)this + 24);
  if (v4)
  {
    *((_QWORD *)this + 25) = v4;
    operator delete(v4);
  }
  v5 = (void *)*((_QWORD *)this + 21);
  if (v5)
  {
    *((_QWORD *)this + 22) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 18);
  if (v6)
  {
    *((_QWORD *)this + 19) = v6;
    operator delete(v6);
  }
  v7 = (void *)*((_QWORD *)this + 12);
  if (v7)
  {
    *((_QWORD *)this + 13) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 9);
  if (v8)
  {
    *((_QWORD *)this + 10) = v8;
    operator delete(v8);
  }
  v9 = (void *)*((_QWORD *)this + 6);
  if (v9)
  {
    *((_QWORD *)this + 7) = v9;
    operator delete(v9);
  }
  v10 = (void *)*((_QWORD *)this + 3);
  if (v10)
  {
    *((_QWORD *)this + 4) = v10;
    operator delete(v10);
  }
  v11 = *(void **)this;
  if (*(_QWORD *)this)
  {
    *((_QWORD *)this + 1) = v11;
    operator delete(v11);
  }
}

void CPMLStatistics::updateAllColumnTypeToReal(CPMLStatistics *this)
{
  id v2;
  unint64_t v3;
  unint64_t v4;
  id v5;

  v2 = *((id *)this + 33);
  if (*((_DWORD *)this + 31))
  {
    v3 = 0;
    v5 = v2;
    do
    {
      *(_DWORD *)(*((_QWORD *)this + 9) + 4 * v3) = 1;
      v4 = objc_msgSend(v2, "getCardinality:", v3);
      if (objc_msgSend(v5, "getSchemaType:", v3) != 7)
        *(double *)(*((_QWORD *)this + 3) + 8 * v3) = (double)v4;
      ++v3;
      v2 = v5;
    }
    while (v3 < *((unsigned int *)this + 31));
  }

}

void sub_209CD01F4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void *CPKNNClassfier::initializeNaiveKNNMemory(CPKNNClassfier *this)
{
  void *result;

  result = malloc_type_calloc(*((_QWORD *)this + 15), 8 * *((_QWORD *)this + 16) + 8, 0x100004000313F17uLL);
  *((_QWORD *)this + 14) = result;
  return result;
}

void CPKNNClassfier::CPKNNClassfier(CPKNNClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;
  uint64_t v7;
  __int128 v8;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v6 = &off_24C255378;
  strcpy((char *)(v6 + 8), "1.0.0");
  *(_BYTE *)(v6 + 244) = 0;
  v7 = *((_QWORD *)a2->var0 + 15);
  *(_QWORD *)&v8 = (int)v7;
  *((_QWORD *)&v8 + 1) = SHIDWORD(v7);
  *(_OWORD *)(v6 + 120) = v8;
  *(_OWORD *)(v6 + 96) = xmmword_209D00770;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  *((_QWORD *)this + 14) = malloc_type_calloc(*((_QWORD *)this + 15), 8 * *((_QWORD *)this + 16) + 8, 0x100004000313F17uLL);
}

void sub_209CD02F0(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPKNNClassfier::CPKNNClassfier(CPKNNClassfier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v6;
  _QWORD *v7;
  uint64_t *v8;
  char *v9;
  void **v10;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v6 = &off_24C255378;
  *(_BYTE *)(v6 + 244) = 1;
  if ((int)CPMLTunableData::getNumberOfItems(a3) < 1)
  {
    *((_QWORD *)this + 17) = 1;
    strlcpy((char *)this + 144, "/tmp/knn_buffer", 0x64uLL);
  }
  else
  {
    CPMLTunableData::tDataGetUInt64(a3, "kthValue", (unint64_t *)this + 17);
    CPMLTunableData::tDataGetString(a3, "cacheFileName", (char *)this + 144, 0x64uLL);
  }
  if (((*((uint64_t (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, (char *)this + 8, "version", 5, 0) & 0x80000000) != 0)strcpy((char *)this + 8, "1.0.0");
  if (((*((uint64_t (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 96, "totalDataCount", 1, 0) & 0x80000000) != 0)*((_QWORD *)this + 12) = 0;
  v7 = (_QWORD *)((char *)this + 128);
  if (((*((uint64_t (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 128, "totalCols", 1, 0) & 0x80000000) != 0)*v7 = 0;
  v8 = (uint64_t *)((char *)this + 120);
  if (((*((uint64_t (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 120, "totalRows", 1, 0) & 0x80000000) != 0)*v8 = 0;
  if (((*((uint64_t (**)(CPMLSerialization *, char *, const char *, uint64_t, uint64_t))a2->var0 + 10))(a2, (char *)this + 104, "KNNDistanceType", 1, 1) & 0x80000000) != 0)*((_QWORD *)this + 13) = 1;
  if (!*v7)
  {
    v9 = sqlite3_mprintf("select cptrainColumns from cptrainColumns;");
    (*((void (**)(CPMLSerialization *, char *, char *))a2->var0 + 24))(a2, (char *)this + 128, v9);
    if (v9)
      sqlite3_free(v9);
  }
  if (a2->var1)
  {
    v10 = (void **)((char *)this + 112);
    if ((*((unsigned int (**)(CPMLSerialization *, char *, char *, _QWORD))a2->var0 + 32))(a2, (char *)this + 144, (char *)this + 112, (8 * (*((_DWORD *)this + 30) + *((_DWORD *)this + 30) * *((_DWORD *)this + 32)))))
    {
      *((_BYTE *)this + 244) = 0;
      *v10 = malloc_type_calloc(*((_QWORD *)this + 15), 8 * *((_QWORD *)this + 16) + 8, 0x100004000313F17uLL);
      if (((*((uint64_t (**)(CPMLSerialization *))a2->var0 + 12))(a2) & 0x80000000) != 0)
      {
        v12 = *v8;
        v13 = *v7 + 1;
        v11 = *v10;
        if (v13 * v12)
          bzero(v11, 8 * v13 * v12);
      }
      else
      {
        v11 = *v10;
        v12 = *v8;
        v13 = *v7 + 1;
      }
      (*((void (**)(CPMLSerialization *, char *, void *, _QWORD))a2->var0 + 31))(a2, (char *)this + 144, v11, (8 * v12 * v13));
    }
  }
  else
  {
    *((_QWORD *)this + 14) = 0;
  }
}

void sub_209CD05F4(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPKNNClassfier::~CPKNNClassfier(void **this)
{
  *this = &off_24C255378;
  if (!*((_BYTE *)this + 244) && *((_BYTE *)this[11] + 8))
    free(this[14]);
  CPModelClose(this);
}

{
  CPKNNClassfier::~CPKNNClassfier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPKNNClassfier::serialize(CPKNNClassfier *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;

  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 96, "totalDataCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 128, "totalCols", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 120, "totalRows", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "KNNDistanceType", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 14), "KNNDataTable", *((_QWORD *)this + 15) + *((_QWORD *)this + 15) * *((_QWORD *)this + 16), 0);
  return 0;
}

uint64_t CPKNNClassfier::train(CPKNNClassfier *this)
{
  uint64_t v2;
  CPMLFeatureVector *v3;
  int **IntVector;
  int *v5;
  uint64_t v6;
  unint64_t v7;
  double *v8;
  int v9;
  uint64_t RealVector;
  uint64_t *v11;
  uint64_t v12;
  unint64_t v13;
  _QWORD *v14;
  uint64_t v15;
  double YHat;
  uint64_t v17;
  uint64_t v18;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    v3 = (CPMLFeatureVector *)v2;
    do
    {
      IntVector = (int **)CPMLFeatureVector::getIntVector(v3);
      v5 = *IntVector;
      v6 = (char *)IntVector[1] - (char *)*IntVector;
      if (v6)
      {
        v7 = v6 >> 2;
        if (v7 <= 1)
          v7 = 1;
        v8 = (double *)(*((_QWORD *)this + 14)
                      + 8 * (*((_QWORD *)this + 12) + *((_QWORD *)this + 12) * *((_QWORD *)this + 16)));
        do
        {
          v9 = *v5++;
          *v8++ = (double)v9;
          --v7;
        }
        while (v7);
      }
      RealVector = CPMLFeatureVector::getRealVector(v3);
      v11 = *(uint64_t **)RealVector;
      v12 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
      if (v12)
      {
        v13 = v12 >> 3;
        if (v13 <= 1)
          v13 = 1;
        v14 = (_QWORD *)(*((_QWORD *)this + 14)
                       + 8 * (*((_QWORD *)this + 12) + *((_QWORD *)this + 12) * *((_QWORD *)this + 16))
                       + 2 * ((char *)IntVector[1] - (char *)*IntVector));
        do
        {
          v15 = *v11++;
          *v14++ = v15;
          --v13;
        }
        while (v13);
      }
      YHat = CPMLFeatureVector::getYHat(v3);
      v17 = *((_QWORD *)this + 12);
      v18 = *((_QWORD *)this + 15);
      *(double *)(*((_QWORD *)this + 14)
                + 8
                * (v17
                 + v17 * *((_QWORD *)this + 16)
                 + ((*(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector) >> 3)
                 + ((unint64_t)((char *)IntVector[1] - (char *)*IntVector) >> 2))) = YHat;
      *((_QWORD *)this + 15) = v18 + 1;
      *((_QWORD *)this + 12) = v17 + 1;
      v3 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v3);
  }
  return 0;
}

uint64_t CPKNNClassfier::eval(uint64_t a1, CPMLFeatureVector *a2)
{
  double *v4;
  _QWORD *v5;
  int *v6;
  int *v7;
  uint64_t v8;
  int *v9;
  _QWORD *v10;
  int **IntVector;
  int *v12;
  uint64_t v13;
  unint64_t v14;
  double *v15;
  int v16;
  uint64_t RealVector;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  double *v28;
  double v29;
  double *v30;
  double v31;
  double v32;
  double v33;
  uint64_t v34;
  double *v35;
  uint64_t v36;
  double *v37;
  double v38;
  double v39;
  double v40;
  unint64_t v41;
  double v42;
  double *v43;
  int *v44;
  uint64_t v45;
  int v46;
  double v47;
  int v48;
  unint64_t v49;
  double v50;
  _BYTE *v51;
  double v52;
  double v53;
  CPMLFeatureVector *v55;
  double *v56;
  _QWORD v57[2];

  v57[1] = *MEMORY[0x24BDAC8D0];
  v4 = (double *)malloc_type_calloc(8 * *(_QWORD *)(a1 + 96), 1uLL, 0x5DFF3921uLL);
  v56 = (double *)malloc_type_calloc(8 * *(_QWORD *)(a1 + 128), 1uLL, 0x8486955uLL);
  v5 = malloc_type_calloc(8 * *(_QWORD *)(a1 + 136), 1uLL, 0x66C3D14FuLL);
  v6 = (int *)malloc_type_calloc(4 * *(_QWORD *)(a1 + 136), 1uLL, 0x1E5D2B32uLL);
  v7 = v6;
  v8 = *(_QWORD *)(a1 + 136);
  if (v8)
  {
    v9 = v6;
    v10 = v5;
    do
    {
      *v9++ = -1;
      *v10++ = 0x7FEFFFFFFFFFFFFFLL;
      --v8;
    }
    while (v8);
  }
  IntVector = (int **)CPMLFeatureVector::getIntVector(a2);
  v12 = *IntVector;
  v13 = (char *)IntVector[1] - (char *)*IntVector;
  if (v13)
  {
    v14 = v13 >> 2;
    if (v14 <= 1)
      v14 = 1;
    v15 = v56;
    do
    {
      v16 = *v12++;
      *v15++ = (double)v16;
      --v14;
    }
    while (v14);
  }
  RealVector = CPMLFeatureVector::getRealVector(a2);
  v19 = (_QWORD *)RealVector;
  v20 = *(uint64_t **)RealVector;
  v21 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
  if (v21)
  {
    v22 = v21 >> 3;
    if (v22 <= 1)
      v22 = 1;
    v23 = (char *)v56 + 2 * ((char *)IntVector[1] - (char *)*IntVector);
    do
    {
      v24 = *v20++;
      *(_QWORD *)v23 = v24;
      v23 += 8;
      --v22;
    }
    while (v22);
  }
  v55 = a2;
  if (*(_QWORD *)(a1 + 96))
  {
    v25 = 0;
    v26 = 0;
    do
    {
      if (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 8))
      {
        v27 = *(_QWORD *)(a1 + 128);
        if (v27)
        {
          v28 = (double *)(*(_QWORD *)(a1 + 112) + v25 * (v27 + 1));
          v29 = 0.0;
          v30 = v56;
          do
          {
            v31 = *v30++;
            v32 = v31;
            v33 = *v28++;
            v29 = v29 + (v32 - v33) * (v32 - v33);
            --v27;
          }
          while (v27);
        }
        else
        {
          v29 = 0.0;
        }
      }
      else
      {
        MEMORY[0x24BDAC7A8](RealVector, v18);
        v35 = (double *)((char *)&v55 - ((v34 + 15) & 0xFFFFFFFFFFFFFFF0));
        RealVector = (*(uint64_t (**)(_QWORD, double *, uint64_t, const char *, const char *, _QWORD))(**(_QWORD **)(a1 + 88) + 152))(*(_QWORD *)(a1 + 88), v35, *(_QWORD *)(a1 + 128) + 1, "KNNDataTable", "KNNDataTable", (v26 * (*(_DWORD *)(a1 + 128) + 1)));
        v36 = *(_QWORD *)(a1 + 128);
        if (v36)
        {
          v29 = 0.0;
          v37 = v56;
          do
          {
            v38 = *v37++;
            v39 = v38;
            v40 = *v35++;
            v29 = v29 + (v39 - v40) * (v39 - v40);
            --v36;
          }
          while (v36);
        }
        else
        {
          v29 = 0.0;
        }
      }
      v4[v26] = sqrt(v29);
      v41 = *(_QWORD *)(a1 + 136);
      if (v41)
      {
        v42 = v4[v26];
        v43 = (double *)v5;
        v44 = v7;
        v45 = *(_QWORD *)(a1 + 136);
        v46 = v26;
        do
        {
          v47 = *v43;
          if (v42 < *v43)
          {
            *v43 = v42;
            v4[v26] = v47;
            v48 = *v44;
            *v44 = v46;
            v46 = v48;
            v42 = v47;
          }
          ++v44;
          ++v43;
          --v45;
        }
        while (v45);
      }
      ++v26;
      v25 += 8;
    }
    while (*(_QWORD *)(a1 + 96) > v26);
  }
  else
  {
    v41 = *(_QWORD *)(a1 + 136);
  }
  if (v41)
  {
    v49 = 0;
    v50 = 0.0;
    do
    {
      v51 = *(_BYTE **)(a1 + 88);
      if (v51[8])
      {
        v52 = (double)(int)*(double *)(*(_QWORD *)(a1 + 112)
                                     + 8
                                     * (v7[v49]
                                      + v7[v49] * *(_QWORD *)(a1 + 128)
                                      + ((v19[1] - *v19) >> 3)
                                      + ((unint64_t)((char *)IntVector[1] - (char *)*IntVector) >> 2)));
      }
      else
      {
        (*(void (**)(_BYTE *, _QWORD *, uint64_t, const char *, const char *, _QWORD))(*(_QWORD *)v51 + 152))(v51, v57, 1, "KNNDataTable", "KNNDataTable", ((v19[1] - *v19) >> 3)+ ((unint64_t)((char *)IntVector[1] - (char *)*IntVector) >> 2)+ v7[v49]+ v7[v49] * *(_DWORD *)(a1 + 128));
        v52 = *(double *)v57;
        v41 = *(_QWORD *)(a1 + 136);
      }
      v50 = v50 + v52;
      ++v49;
    }
    while (v49 < v41);
  }
  else
  {
    v50 = 0.0;
  }
  v53 = 1.0;
  if (v50 / (double)v41 < 0.5)
    v53 = 0.0;
  CPMLFeatureVector::setYHat((uint64_t)v55, v53);
  free(v7);
  free(v5);
  free(v4);
  free(v56);
  return 0;
}

uint64_t CPKNNClassfier::update(CPKNNClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t Iterator;
  void *v8;
  uint64_t v9;
  uint64_t v10;
  CPMLFeatureVector *v11;
  _QWORD *IntVector;
  _QWORD *v13;
  unint64_t v14;
  _QWORD *RealVector;
  _QWORD *v16;
  unint64_t v17;
  double YHat;

  Iterator = CPMLCDB::getIterator(a2, 0, 0, 1);
  *((_QWORD *)this + 10) = Iterator;
  if (a3->var1)
  {
    v8 = malloc_type_calloc(*((int *)a2->var0 + 30), 8 * *((_QWORD *)this + 16) + 8, 0x100004000313F17uLL);
    memcpy(v8, *((const void **)this + 14), 8 * (*((_QWORD *)this + 12) + *((_QWORD *)this + 12) * *((_QWORD *)this + 16)));
    free(*((void **)this + 14));
    *((_QWORD *)this + 14) = v8;
    v9 = *((_QWORD *)this + 15);
    (*(void (**)(CPKNNClassfier *))(*(_QWORD *)this + 40))(this);
    if ((CPKNNClassfier::update(CPMLCDB *,CPMLSerialization *,CPMLTunableData *)::resetOccured & 1) != 0)
    {
      (*((void (**)(CPMLSerialization *, _QWORD, const char *, const char *, _QWORD))a3->var0 + 21))(a3, *((_QWORD *)this + 12), "totalDataCount", "totalDataCount", 0);
      (*((void (**)(CPMLSerialization *, _QWORD, const char *, const char *, uint64_t))a3->var0 + 21))(a3, *((_QWORD *)this + 16), "totalCols", "totalCols", 1);
      (*((void (**)(CPMLSerialization *, _QWORD, const char *, const char *, uint64_t))a3->var0 + 21))(a3, *((_QWORD *)this + 15), "totalRows", "totalRows", 2);
      (*((void (**)(CPMLSerialization *, _QWORD, const char *, const char *, uint64_t))a3->var0 + 21))(a3, *((_QWORD *)this + 13), "KNNDistanceType", "KNNDistanceType", 3);
      (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a3->var0 + 6))(a3, *((_QWORD *)this + 14) + 8 * (*((_QWORD *)this + 16) + 1) * v9, "KNNDataTable", (*((_QWORD *)this + 15) - v9) * (*((_QWORD *)this + 16) + 1), 0);
    }
    else
    {
      (*((void (**)(CPMLSerialization *))a3->var0 + 15))(a3);
      (*(void (**)(CPKNNClassfier *))(*(_QWORD *)this + 32))(this);
      CPKNNClassfier::update(CPMLCDB *,CPMLSerialization *,CPMLTunableData *)::resetOccured = 1;
    }
  }
  else
  {
    v10 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
    if (v10)
    {
      v11 = (CPMLFeatureVector *)v10;
      do
      {
        IntVector = (_QWORD *)CPMLFeatureVector::getIntVector(v11);
        if (IntVector[1] != *IntVector)
        {
          v13 = IntVector;
          v14 = 0;
          do
          {
            YHat = 0.0;
            YHat = (double)*(int *)(*v13 + 4 * v14);
            (*((void (**)(CPMLSerialization *, double *, const char *, uint64_t, _QWORD))a3->var0 + 6))(a3, &YHat, "KNNDataTable", 1, 0);
            ++v14;
          }
          while (v14 < (uint64_t)(v13[1] - *v13) >> 2);
        }
        RealVector = (_QWORD *)CPMLFeatureVector::getRealVector(v11);
        if (RealVector[1] != *RealVector)
        {
          v16 = RealVector;
          v17 = 0;
          do
          {
            YHat = 0.0;
            YHat = *(double *)(*v16 + 8 * v17);
            (*((void (**)(CPMLSerialization *, double *, const char *, uint64_t, _QWORD))a3->var0 + 6))(a3, &YHat, "KNNDataTable", 1, 0);
            ++v17;
          }
          while (v17 < (uint64_t)(v16[1] - *v16) >> 3);
        }
        YHat = 0.0;
        YHat = CPMLFeatureVector::getYHat(v11);
        (*((void (**)(CPMLSerialization *, double *, const char *, uint64_t, _QWORD))a3->var0 + 6))(a3, &YHat, "KNNDataTable", 1, 0);
        ++*((_QWORD *)this + 12);
        v11 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      }
      while (v11);
    }
    (*((void (**)(CPMLSerialization *, _QWORD, const char *, const char *, _QWORD))a3->var0 + 21))(a3, *((_QWORD *)this + 12), "totalDataCount", "totalDataCount", 0);
  }
  *((_QWORD *)this + 10) = 0;
  return 0;
}

uint64_t CPKNNClassfier::errorString(CPKNNClassfier *this)
{
  return 0;
}

uint64_t CPMLAlgorithm::requireRealOnly(CPMLAlgorithm *this)
{
  return 0;
}

void CPMLNaiveBayesClassifier::CPMLNaiveBayesClassifier(CPMLNaiveBayesClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  CPMLStatistics *var0;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  unint64_t v14;
  char v15[20];
  char v16[10];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v8 = &off_24C2558F0;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_QWORD *)(v8 + 376) = 0;
  *(_QWORD *)(v8 + 384) = 0;
  strcpy((char *)(v8 + 8), "1.0.1");
  *(_QWORD *)(v8 + 112) = 0;
  var0 = a2->var0;
  *(_QWORD *)(v8 + 96) = *((int *)a2->var0 + 31);
  v10 = *((int *)var0 + 33);
  *(_QWORD *)(v8 + 104) = v10;
  *(_QWORD *)(v8 + 120) = (uint64_t)(*((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3)) >> 3;
  v11 = *(_QWORD *)var0;
  *(_QWORD *)(v8 + 128) = (uint64_t)(*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2;
  *(_QWORD *)(v8 + 136) = v11;
  *(_QWORD *)(v8 + 144) = v10;
  *(_QWORD *)(v8 + 152) = (uint64_t)(*((_QWORD *)var0 + 7) - *((_QWORD *)var0 + 6)) >> 2;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "rowCountY", "rowCountY REAL");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "yCount", "yMap INTEGER, yCount REAL");
  if (*((_QWORD *)this + 12))
  {
    v12 = 0;
    do
    {
      sprintf(v16, "xcol%d", v12);
      sprintf(v15, "xCardinality%d", v12);
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v15, "yMap INTEGER, xCardinality REAL");
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v16, "xMap INTEGER, yMap INTEGER, xyCount REAL");
      ++v12;
    }
    while (*((_QWORD *)this + 12) > v12);
  }
  v13 = *((_QWORD *)this + 19);
  if (v13)
  {
    *((_QWORD *)this + 21) = malloc_type_calloc(v13, 8uLL, 0x10040436913F5uLL);
    *((_QWORD *)this + 20) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x100004000313F17uLL);
    if (*((_QWORD *)this + 19))
    {
      v14 = 0;
      do
        *(_QWORD *)(*((_QWORD *)this + 21) + 8 * v14++) = malloc_type_calloc(*((_QWORD *)this + 18) * *((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
      while (*((_QWORD *)this + 19) > v14);
    }
  }
  CPMLNaiveBayesClassifier::setTunableData(this, a4);
}

void sub_209CD12A8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;
  void *v5;

  v4 = (void *)v1[25];
  if (v4)
  {
    v1[26] = v4;
    operator delete(v4);
  }
  v5 = *v2;
  if (*v2)
  {
    v1[23] = v5;
    operator delete(v5);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifier::setTunableData(CPMLNaiveBayesClassifier *this, CPMLTunableData *a2)
{
  _OWORD *v4;
  CPMLLogger *v10;
  int v11;
  CPMLNaiveBayesSpotLightAdaptor *v12;
  CPMLNaiveBayesSpotLightAdaptor *v13;
  CPMLSerialization *v14;
  CPMLNaiveBayes *v15;
  unint64_t v16;
  void **v17;
  _QWORD *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  char *v27;
  int v28;

  v4 = (_OWORD *)((char *)this + 344);
  if ((int)CPMLTunableData::getNumberOfItems(a2) < 2)
  {
    __asm { FMOV            V0.2D, #1.0 }
    *v4 = _Q0;
    *((_DWORD *)this + 84) = 1;
    *((_QWORD *)this + 45) = 0x3CD203AF9EE75616;
    *((_WORD *)this + 112) = 0;
    *((_QWORD *)this + 41) = 20;
    strcpy((char *)this + 226, "defaultNBV3b");
  }
  else
  {
    CPMLTunableData::tDataGetInt(a2, "k", (int *)this + 82);
    CPMLTunableData::tDataGetDouble(a2, "decayRate", (double *)this + 43);
    CPMLTunableData::tDataGetDouble(a2, "smoothRate", (double *)this + 44);
    CPMLTunableData::tDataGetInt(a2, "smoothMode", (int *)this + 84);
    CPMLTunableData::tDataGetDouble(a2, "epsilonRate", (double *)this + 45);
    CPMLTunableData::tDataGetBool(a2, "enableLogging", (BOOL *)this + 225);
    CPMLTunableData::tDataGetString(a2, "logFilename", (char *)this + 226, 0x64uLL);
    CPMLTunableData::tDataGetBool(a2, "dataCollection", (BOOL *)this + 224);
    CPMLTunableData::tDataGetInt(a2, "nbAdatorVersion", (int *)this + 83);
  }
  v10 = (CPMLLogger *)operator new();
  CPMLLogger::CPMLLogger(v10, (char *)this + 226, *((_BYTE *)this + 225));
  *((_QWORD *)this + 46) = v10;
  v11 = *((_DWORD *)this + 83);
  v12 = (CPMLNaiveBayesSpotLightAdaptor *)operator new();
  v13 = v12;
  v14 = (CPMLSerialization *)*((_QWORD *)this + 11);
  if (v11 == 1)
    CPMLNaiveBayesSpotLightAdaptor::CPMLNaiveBayesSpotLightAdaptor(v12, v14);
  else
    CPMLNaiveBayesAdaptor::CPMLNaiveBayesAdaptor(v12, v14);
  *((_QWORD *)this + 48) = v13;
  v15 = (CPMLNaiveBayes *)operator new();
  CPMLNaiveBayes::CPMLNaiveBayes(v15, *((CPMLNaiveBayesDBAdaptor **)this + 48));
  *((_QWORD *)this + 47) = v15;
  CPMLNaiveBayes::set_decay_rate((uint64_t)v15, *((double *)this + 43));
  CPMLNaiveBayes::set_smooth_rate(*((_QWORD *)this + 47), *((double *)this + 44));
  CPMLNaiveBayes::set_epsilon_rate(*((_QWORD *)this + 47), *((double *)this + 45));
  CPMLNaiveBayes::set_smooth_mode(*((_QWORD *)this + 47), *((_DWORD *)this + 84));
  if (*((_QWORD *)this + 13))
  {
    v16 = 0;
    v17 = (void **)((char *)this + 200);
    v18 = (_QWORD *)((char *)this + 216);
    v19 = (char *)*((_QWORD *)this + 26);
    do
    {
      if ((unint64_t)v19 >= *v18)
      {
        v21 = (char *)*v17;
        v22 = (v19 - (_BYTE *)*v17) >> 2;
        v23 = v22 + 1;
        if ((unint64_t)(v22 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v24 = *v18 - (_QWORD)v21;
        if (v24 >> 1 > v23)
          v23 = v24 >> 1;
        if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
          v25 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v25 = v23;
        if (v25)
        {
          v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 216, v25);
          v21 = (char *)*((_QWORD *)this + 25);
          v19 = (char *)*((_QWORD *)this + 26);
        }
        else
        {
          v26 = 0;
        }
        v27 = &v26[4 * v22];
        *(_DWORD *)v27 = v16;
        v20 = v27 + 4;
        while (v19 != v21)
        {
          v28 = *((_DWORD *)v19 - 1);
          v19 -= 4;
          *((_DWORD *)v27 - 1) = v28;
          v27 -= 4;
        }
        *((_QWORD *)this + 25) = v27;
        *((_QWORD *)this + 26) = v20;
        *((_QWORD *)this + 27) = &v26[4 * v25];
        if (v21)
          operator delete(v21);
      }
      else
      {
        *(_DWORD *)v19 = v16;
        v20 = v19 + 4;
      }
      *((_QWORD *)this + 26) = v20;
      ++v16;
      v19 = v20;
    }
    while (*((_QWORD *)this + 13) > v16);
  }
  CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 47), (unsigned int **)this + 25);
}

void sub_209CD15F0(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10B1C40E26776D8);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifier::CPMLNaiveBayesClassifier(CPMLNaiveBayesClassifier *this, CPMLStatistics *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  _QWORD *v9;
  unint64_t v10;
  double v11;
  char v12[150];
  char v13[152];
  uint64_t v14;

  v14 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a3, a4);
  *(_QWORD *)v8 = &off_24C2558F0;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_OWORD *)(v8 + 192) = 0u;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_QWORD *)(v8 + 96) = *((int *)a2 + 31);
  v11 = 0.0;
  v9 = (_QWORD *)(v8 + 104);
  (*((void (**)(CPMLSerialization *, uint64_t, const char *))a3->var0 + 24))(a3, v8 + 104, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality INTEGER, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "CREATE TABLE IF NOT EXISTS rowCountY (rowCountY REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "CREATE TABLE IF NOT EXISTS yCount (yMap INTEGER, yCount REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "CREATE INDEX IF NOT EXISTS idxRowCountY on rowCountY (rowCountY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "CREATE INDEX IF NOT EXISTS idxYCount on yCount (yMap, yCount);");
  if (*((_QWORD *)this + 12))
  {
    v10 = 0;
    do
    {
      sprintf(v13, "CREATE TABLE IF NOT EXISTS xcol%d (xMap INTEGER, yMap INTEGER, xyCount REAL, pKey INTEGER PRIMARY KEY);",
        v10);
      sprintf(v12, "CREATE TABLE IF NOT EXISTS xCardinality%d (yMap INTEGER, xCardinality REAL, pKey INTEGER PRIMARY KEY);",
        v10);
      (*((void (**)(CPMLSerialization *, double *, char *))a3->var0 + 28))(a3, &v11, v12);
      (*((void (**)(CPMLSerialization *, double *, char *))a3->var0 + 28))(a3, &v11, v13);
      ++v10;
    }
    while (*((_QWORD *)this + 12) > v10);
  }
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v11, "select count(*) from yCount;");
  if (v11 >= 1.0)
  {
    *v9 = (unint64_t)v11;
  }
  else
  {
    *(_QWORD *)v13 = 0;
    (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD, double))a3->var0 + 4))(a3, v13, "resultCardinality", 1, 0, v11);
  }
  CPMLNaiveBayesClassifier::setTunableData(this, a4);
}

void sub_209CD188C(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v3;
  void *v4;

  v3 = (void *)v1[25];
  if (v3)
  {
    v1[26] = v3;
    operator delete(v3);
  }
  v4 = (void *)v1[22];
  if (v4)
  {
    v1[23] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifier::~CPMLNaiveBayesClassifier(CPMLNaiveBayesClassifier *this)
{
  CPMLLogger *v2;
  CPMLNaiveBayes *v3;
  CPMLNaiveBayesAdaptor *v4;
  void *v5;
  void *v6;
  void *v7;
  void *v8;

  *(_QWORD *)this = &off_24C2558F0;
  v2 = (CPMLLogger *)*((_QWORD *)this + 46);
  if (v2)
  {
    CPMLLogger::~CPMLLogger(v2);
    MEMORY[0x20BD188E4]();
  }
  v3 = (CPMLNaiveBayes *)*((_QWORD *)this + 47);
  if (v3)
  {
    CPMLNaiveBayes::~CPMLNaiveBayes(v3);
    MEMORY[0x20BD188E4]();
  }
  v4 = (CPMLNaiveBayesAdaptor *)*((_QWORD *)this + 48);
  if (v4)
  {
    CPMLNaiveBayesAdaptor::~CPMLNaiveBayesAdaptor(v4);
    MEMORY[0x20BD188E4]();
  }
  v5 = (void *)*((_QWORD *)this + 20);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 21);
  if (v6)
    free(v6);
  v7 = (void *)*((_QWORD *)this + 25);
  if (v7)
  {
    *((_QWORD *)this + 26) = v7;
    operator delete(v7);
  }
  v8 = (void *)*((_QWORD *)this + 22);
  if (v8)
  {
    *((_QWORD *)this + 23) = v8;
    operator delete(v8);
  }
  CPModelClose(this);
}

{
  CPMLNaiveBayesClassifier::~CPMLNaiveBayesClassifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLNaiveBayesClassifier::serialize(CPMLNaiveBayesClassifier *this)
{
  CPMLNaiveBayesClassifier *v1;
  uint64_t v2;
  size_t v3;

  v1 = this;
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  v2 = *((_QWORD *)v1 + 11);
  v1 = (CPMLNaiveBayesClassifier *)((char *)v1 + 8);
  v3 = strlen((const char *)v1);
  (*(void (**)(uint64_t, CPMLNaiveBayesClassifier *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v1, "version", v3, 0);
  return 0;
}

uint64_t CPMLNaiveBayesClassifier::train(CPMLNaiveBayesClassifier *this)
{
  CPMLFeatureVector *v2;
  CPMLLog *YVectorVector;
  char ***v4;
  unint64_t v5;
  pthread_mutex_t *CPMLLog;
  char *v7;
  char **v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  unint64_t v18;
  char *v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t i;
  unint64_t v23;
  char *v24;
  pthread_mutex_t *v26;
  char v27[30];
  uint64_t v28;

  v28 = *MEMORY[0x24BDAC8D0];
  v2 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    while (1)
    {
      YVectorVector = (CPMLLog *)CPMLFeatureVector::getYVectorVector(v2);
      v4 = *(char ****)YVectorVector;
      v5 = *((_QWORD *)YVectorVector + 1) - *(_QWORD *)YVectorVector;
      if (!v5)
        break;
      ++*((_QWORD *)this + 14);
      if (v5 < 0x11)
      {
        if (v5 == 16)
        {
          v8 = *v4;
          v7 = **v4;
          v9 = v8[1] - v7;
          v10 = v9 >> 2;
          if ((v9 >> 2))
          {
            if ((_DWORD)v10 == 1)
            {
              *(double *)(*((_QWORD *)this + 20) + 8 * *(int *)v7) = *(double *)(*((_QWORD *)this + 20)
                                                                                 + 8 * *(int *)v7)
                                                                     + 1.0;
            }
            else if ((int)v10 >= 1)
            {
              v11 = 0;
              v12 = *((_QWORD *)this + 20);
              v13 = (v9 >> 2);
              do
              {
                v14 = 0;
                v15 = *(int *)&v7[4 * v11];
                *(double *)(v12 + 8 * v15) = *(double *)(v12 + 8 * v15) + 1.0;
                do
                {
                  if (v11 != v14)
                  {
                    v16 = *(int *)&v7[4 * v14] + *((_QWORD *)this + 18) * v15;
                    ++*(_QWORD *)(**((_QWORD **)this + 21) + 8 * v16);
                  }
                  ++v14;
                }
                while (v13 != v14);
                ++v11;
              }
              while (v11 != v13);
            }
          }
        }
      }
      else
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "train", "Too many Y\n");
      }
      v2 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      if (!v2)
        goto LABEL_17;
    }
    v26 = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
    CPMLLog::log(v26, CPML_LOG_ERR, "train", "no vectors to process\n");
    return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_17:
    v17 = sqlite3_mprintf("%lf", (double)*((unint64_t *)this + 14));
    (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "rowCountY", "rowCountY", v17);
    if (v17)
      sqlite3_free(v17);
    if (*((_QWORD *)this + 13))
    {
      v18 = 0;
      do
      {
        v19 = sqlite3_mprintf("%d,%lf", v18, *(double *)(*((_QWORD *)this + 20) + 8 * v18));
        (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "yCount", "yMap,yCount", v19);
        if (v19)
          sqlite3_free(v19);
        ++v18;
      }
      while (*((_QWORD *)this + 13) > v18);
    }
    if (*((_QWORD *)this + 12))
    {
      v20 = 0;
      do
      {
        sprintf(v27, "xcol%d", v20);
        v21 = *((_QWORD *)this + 18);
        if (v21)
        {
          for (i = 0; i < v21; ++i)
          {
            v23 = 0;
            do
            {
              v24 = sqlite3_mprintf("%d,%d,%lf", i, v23, (double)*(unint64_t *)(**((_QWORD **)this + 21) + 8 * (v23 + i * v21)));
              (*(void (**)(_QWORD, char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), v27, "xMap,yMap,xyCount", v24);
              if (v24)
                sqlite3_free(v24);
              ++v23;
              v21 = *((_QWORD *)this + 18);
            }
            while (v21 > v23);
          }
        }
        ++v20;
      }
      while (*((_QWORD *)this + 12) > v20);
    }
    return 0;
  }
}

uint64_t CPMLNaiveBayesClassifier::eval(uint64_t a1, CPMLFeatureVector *this, uint64_t *a3)
{
  uint64_t v6;
  char *v7;
  unint64_t v8;
  int v9;
  char *v10;
  char *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  int v18;
  uint64_t v19;
  char *v20;
  unint64_t v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int v30;
  CPMLLog *XVectorVector;
  pthread_mutex_t *v32;
  uint64_t *IntVector;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  int v37;
  char *v38;
  char *v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  char *v44;
  char *v45;
  int v46;
  char *RealVector;
  char *v48;
  uint64_t v49;
  unint64_t v50;
  char *v51;
  int v52;
  char *v53;
  uint64_t v54;
  unint64_t v55;
  uint64_t v56;
  unint64_t v57;
  char *v58;
  int *v59;
  int v60;
  uint64_t v61;
  uint64_t v62;
  void (***v63)(_QWORD, uint64_t, void **, uint64_t, uint64_t);
  pthread_mutex_t *CPMLLog;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  void *v69;
  char *v70;
  char *v71;
  void *__p;
  char *v73;
  char *v74;
  void **v75;

  if (!*(_QWORD *)(a1 + 104))
    return 0xFFFFFFFFLL;
  __p = 0;
  v73 = 0;
  v74 = 0;
  v6 = *a3;
  if (a3[1] == *a3)
  {
    v20 = 0;
    v21 = 0;
    do
    {
      if (v20 >= v74)
      {
        v23 = (char *)__p;
        v24 = (v20 - (_BYTE *)__p) >> 2;
        v25 = v24 + 1;
        if ((unint64_t)(v24 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v26 = v74 - (_BYTE *)__p;
        if ((v74 - (_BYTE *)__p) >> 1 > v25)
          v25 = v26 >> 1;
        if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
          v27 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v27 = v25;
        if (v27)
        {
          v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v74, v27);
          v23 = (char *)__p;
          v20 = v73;
        }
        else
        {
          v28 = 0;
        }
        v29 = &v28[4 * v24];
        *(_DWORD *)v29 = v21;
        v22 = v29 + 4;
        while (v20 != v23)
        {
          v30 = *((_DWORD *)v20 - 1);
          v20 -= 4;
          *((_DWORD *)v29 - 1) = v30;
          v29 -= 4;
        }
        __p = v29;
        v73 = v22;
        v74 = &v28[4 * v27];
        if (v23)
          operator delete(v23);
      }
      else
      {
        *(_DWORD *)v20 = v21;
        v22 = v20 + 4;
      }
      v73 = v22;
      ++v21;
      v20 = v22;
    }
    while (*(_QWORD *)(a1 + 104) > v21);
  }
  else
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *(_DWORD *)(v6 + 4 * v8);
      if (v7 >= v74)
      {
        v11 = (char *)__p;
        v12 = (v7 - (_BYTE *)__p) >> 2;
        v13 = v12 + 1;
        if ((unint64_t)(v12 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v14 = v74 - (_BYTE *)__p;
        if ((v74 - (_BYTE *)__p) >> 1 > v13)
          v13 = v14 >> 1;
        if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFFCLL)
          v15 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v15 = v13;
        if (v15)
        {
          v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v74, v15);
          v11 = (char *)__p;
          v7 = v73;
        }
        else
        {
          v16 = 0;
        }
        v17 = &v16[4 * v12];
        *(_DWORD *)v17 = v9;
        v10 = v17 + 4;
        while (v7 != v11)
        {
          v18 = *((_DWORD *)v7 - 1);
          v7 -= 4;
          *((_DWORD *)v17 - 1) = v18;
          v17 -= 4;
        }
        __p = v17;
        v73 = v10;
        v74 = &v16[4 * v15];
        if (v11)
          operator delete(v11);
      }
      else
      {
        *(_DWORD *)v7 = v9;
        v10 = v7 + 4;
      }
      v73 = v10;
      ++v8;
      v6 = *a3;
      v7 = v10;
    }
    while (v8 < (a3[1] - *a3) >> 2);
  }
  XVectorVector = (CPMLLog *)CPMLFeatureVector::getXVectorVector(this);
  if (*((_QWORD *)XVectorVector + 1) == *(_QWORD *)XVectorVector)
  {
    v69 = 0;
    v70 = 0;
    v71 = 0;
    IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(this);
    v34 = *IntVector;
    if (IntVector[1] != *IntVector)
    {
      v35 = 0;
      v36 = v70;
      do
      {
        v37 = *(_DWORD *)(v34 + 4 * v35);
        if (v36 >= v71)
        {
          v39 = (char *)v69;
          v40 = (v36 - (_BYTE *)v69) >> 2;
          v41 = v40 + 1;
          if ((unint64_t)(v40 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v42 = v71 - (_BYTE *)v69;
          if ((v71 - (_BYTE *)v69) >> 1 > v41)
            v41 = v42 >> 1;
          if ((unint64_t)v42 >= 0x7FFFFFFFFFFFFFFCLL)
            v43 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v43 = v41;
          if (v43)
          {
            v44 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v71, v43);
            v39 = (char *)v69;
            v36 = v70;
          }
          else
          {
            v44 = 0;
          }
          v45 = &v44[4 * v40];
          *(_DWORD *)v45 = v37;
          v38 = v45 + 4;
          while (v36 != v39)
          {
            v46 = *((_DWORD *)v36 - 1);
            v36 -= 4;
            *((_DWORD *)v45 - 1) = v46;
            v45 -= 4;
          }
          v69 = v45;
          v70 = v38;
          v71 = &v44[4 * v43];
          if (v39)
            operator delete(v39);
        }
        else
        {
          *(_DWORD *)v36 = v37;
          v38 = v36 + 4;
        }
        v70 = v38;
        ++v35;
        v34 = *IntVector;
        v36 = v38;
      }
      while (v35 < (IntVector[1] - *IntVector) >> 2);
    }
    RealVector = (char *)CPMLFeatureVector::getRealVector(this);
    v48 = RealVector;
    v49 = *(_QWORD *)RealVector;
    if (*((_QWORD *)RealVector + 1) == *(_QWORD *)RealVector)
    {
      v53 = v70;
    }
    else
    {
      v50 = 0;
      v51 = v70;
      do
      {
        v52 = (int)*(double *)(v49 + 8 * v50);
        if (v51 >= v71)
        {
          RealVector = (char *)v69;
          v54 = (v51 - (_BYTE *)v69) >> 2;
          v55 = v54 + 1;
          if ((unint64_t)(v54 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v56 = v71 - (_BYTE *)v69;
          if ((v71 - (_BYTE *)v69) >> 1 > v55)
            v55 = v56 >> 1;
          if ((unint64_t)v56 >= 0x7FFFFFFFFFFFFFFCLL)
            v57 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v57 = v55;
          if (v57)
          {
            v58 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v71, v57);
            RealVector = (char *)v69;
            v51 = v70;
          }
          else
          {
            v58 = 0;
          }
          v59 = (int *)&v58[4 * v54];
          *v59 = v52;
          v53 = (char *)(v59 + 1);
          while (v51 != RealVector)
          {
            v60 = *((_DWORD *)v51 - 1);
            v51 -= 4;
            *--v59 = v60;
          }
          v69 = v59;
          v70 = v53;
          v71 = &v58[4 * v57];
          if (RealVector)
            operator delete(RealVector);
        }
        else
        {
          *(_DWORD *)v51 = v52;
          v53 = v51 + 4;
        }
        v70 = v53;
        ++v50;
        v49 = *(_QWORD *)v48;
        v51 = v53;
      }
      while (v50 < (uint64_t)(*((_QWORD *)v48 + 1) - *(_QWORD *)v48) >> 3);
    }
    if (v53 == v69)
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)RealVector);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "eval", "empty integer list");
      v19 = 0xFFFFFFFFLL;
    }
    else
    {
      v66 = 0;
      v67 = 0;
      v68 = 0;
      v61 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v66, (uint64_t)&v69);
      v62 = *(unsigned int *)(a1 + 328);
      v63 = *(void (****)(_QWORD, uint64_t, void **, uint64_t, uint64_t))(a1 + 376);
      v67 = v61;
      CPMLNaiveBayes::predict(v63, (uint64_t)&v66, (unsigned int **)&__p, v62, a1 + 176);
      v75 = (void **)&v66;
      std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&v75);
      CPMLFeatureVector::setYHatProbList((uint64_t)this, a1 + 176);
      v19 = 0;
      *(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 176);
    }
    if (v69)
    {
      v70 = (char *)v69;
      operator delete(v69);
    }
  }
  else
  {
    v32 = (pthread_mutex_t *)CPMLLog::getCPMLLog(XVectorVector);
    CPMLLog::log(v32, CPML_LOG_ERR, "eval", "no vector supported");
    v19 = 0xFFFFFFFFLL;
  }
  if (__p)
  {
    v73 = (char *)__p;
    operator delete(__p);
  }
  return v19;
}

void sub_209CD228C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *__p, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  if (a15)
    operator delete(a15);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLNaiveBayesClassifier::update(CPMLNaiveBayesClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  CPMLFeatureVector *v5;
  CPMLFeatureVector *v6;
  CPMLLog *XVectorVector;
  uint64_t *IntVector;
  uint64_t v9;
  unint64_t v10;
  char *v11;
  int v12;
  char *v13;
  char *v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  char *v19;
  char *v20;
  int v21;
  char *RealVector;
  char *v23;
  uint64_t v24;
  char *v25;
  unint64_t v26;
  int v27;
  char *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  int *v34;
  int v35;
  char *v36;
  double YHat;
  uint64_t v38;
  uint64_t v39;
  pthread_mutex_t *v40;
  double v41;
  int v42;
  int v43;
  void **v44;
  _QWORD *v45;
  int *v46;
  int *v47;
  int *v48;
  uint64_t v49;
  unint64_t v50;
  uint64_t v51;
  unint64_t v52;
  char *v53;
  int *v54;
  int v55;
  uint64_t result;
  pthread_mutex_t *CPMLLog;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  void *__p;
  char *v64;
  char *v65;
  void **v66;

  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 1);
  while (1)
  {
    v5 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    if (!v5)
      break;
    v6 = v5;
    XVectorVector = (CPMLLog *)CPMLFeatureVector::getXVectorVector(v5);
    if (*((_QWORD *)XVectorVector + 1) != *(_QWORD *)XVectorVector)
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(XVectorVector);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "update", "no vector supported");
      return 0xFFFFFFFFLL;
    }
    __p = 0;
    v64 = 0;
    v65 = 0;
    IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(v6);
    v9 = *IntVector;
    if (IntVector[1] != *IntVector)
    {
      v10 = 0;
      v11 = v64;
      do
      {
        v12 = *(_DWORD *)(v9 + 4 * v10);
        if (v11 >= v65)
        {
          v14 = (char *)__p;
          v15 = (v11 - (_BYTE *)__p) >> 2;
          v16 = v15 + 1;
          if ((unint64_t)(v15 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v17 = v65 - (_BYTE *)__p;
          if ((v65 - (_BYTE *)__p) >> 1 > v16)
            v16 = v17 >> 1;
          if ((unint64_t)v17 >= 0x7FFFFFFFFFFFFFFCLL)
            v18 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v18 = v16;
          if (v18)
          {
            v19 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v65, v18);
            v14 = (char *)__p;
            v11 = v64;
          }
          else
          {
            v19 = 0;
          }
          v20 = &v19[4 * v15];
          *(_DWORD *)v20 = v12;
          v13 = v20 + 4;
          while (v11 != v14)
          {
            v21 = *((_DWORD *)v11 - 1);
            v11 -= 4;
            *((_DWORD *)v20 - 1) = v21;
            v20 -= 4;
          }
          __p = v20;
          v64 = v13;
          v65 = &v19[4 * v18];
          if (v14)
            operator delete(v14);
        }
        else
        {
          *(_DWORD *)v11 = v12;
          v13 = v11 + 4;
        }
        v64 = v13;
        ++v10;
        v9 = *IntVector;
        v11 = v13;
      }
      while (v10 < (IntVector[1] - *IntVector) >> 2);
    }
    RealVector = (char *)CPMLFeatureVector::getRealVector(v6);
    v23 = RealVector;
    v24 = *(_QWORD *)RealVector;
    v25 = v64;
    if (*((_QWORD *)RealVector + 1) == *(_QWORD *)RealVector)
    {
      v28 = v64;
    }
    else
    {
      v26 = 0;
      do
      {
        v27 = (int)*(double *)(v24 + 8 * v26);
        if (v25 >= v65)
        {
          RealVector = (char *)__p;
          v29 = (v25 - (_BYTE *)__p) >> 2;
          v30 = v29 + 1;
          if ((unint64_t)(v29 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v31 = v65 - (_BYTE *)__p;
          if ((v65 - (_BYTE *)__p) >> 1 > v30)
            v30 = v31 >> 1;
          if ((unint64_t)v31 >= 0x7FFFFFFFFFFFFFFCLL)
            v32 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v32 = v30;
          if (v32)
          {
            v33 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v65, v32);
            RealVector = (char *)__p;
            v25 = v64;
          }
          else
          {
            v33 = 0;
          }
          v34 = (int *)&v33[4 * v29];
          *v34 = v27;
          v28 = (char *)(v34 + 1);
          while (v25 != RealVector)
          {
            v35 = *((_DWORD *)v25 - 1);
            v25 -= 4;
            *--v34 = v35;
          }
          __p = v34;
          v64 = v28;
          v65 = &v33[4 * v32];
          if (RealVector)
            operator delete(RealVector);
        }
        else
        {
          *(_DWORD *)v25 = v27;
          v28 = v25 + 4;
        }
        v64 = v28;
        ++v26;
        v24 = *(_QWORD *)v23;
        v25 = v28;
      }
      while (v26 < (uint64_t)(*((_QWORD *)v23 + 1) - *(_QWORD *)v23) >> 3);
    }
    v36 = (char *)__p;
    if (v28 == __p)
    {
      v40 = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)RealVector);
      CPMLLog::log(v40, CPML_LOG_ERR, "update", "empty integer list");
    }
    else
    {
      YHat = CPMLFeatureVector::getYHat(v6);
      v60 = 0;
      v61 = 0;
      v62 = 0;
      v38 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v60, (uint64_t)&__p);
      v39 = *((_QWORD *)this + 47);
      v61 = v38;
      CPMLNaiveBayes::update(v39, &v60, (int)YHat);
      v66 = (void **)&v60;
      std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&v66);
    }
    if (__p)
    {
      v64 = (char *)__p;
      operator delete(__p);
    }
    if (v28 == v36)
      return 0xFFFFFFFFLL;
  }
  v41 = (*(double (**)(_QWORD))(**((_QWORD **)this + 48) + 64))(*((_QWORD *)this + 48));
  if (v41 == (double)*((unint64_t *)this + 13))
    return 0;
  (*((void (**)(CPMLSerialization *, unint64_t, const char *, const char *, _QWORD))a3->var0 + 21))(a3, (unint64_t)v41, "resultCardinality", "resultCardinality", 0);
  v42 = *((_DWORD *)this + 26);
  v43 = (int)v41;
  if (v42 < (int)v41)
  {
    v44 = (void **)((char *)this + 200);
    v45 = (_QWORD *)((char *)this + 216);
    v46 = (int *)*((_QWORD *)this + 26);
    do
    {
      if ((unint64_t)v46 >= *v45)
      {
        v48 = (int *)*v44;
        v49 = ((char *)v46 - (_BYTE *)*v44) >> 2;
        v50 = v49 + 1;
        if ((unint64_t)(v49 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v51 = *v45 - (_QWORD)v48;
        if (v51 >> 1 > v50)
          v50 = v51 >> 1;
        if ((unint64_t)v51 >= 0x7FFFFFFFFFFFFFFCLL)
          v52 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v52 = v50;
        if (v52)
        {
          v53 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 216, v52);
          v48 = (int *)*((_QWORD *)this + 25);
          v46 = (int *)*((_QWORD *)this + 26);
        }
        else
        {
          v53 = 0;
        }
        v54 = (int *)&v53[4 * v49];
        *v54 = v42;
        v47 = v54 + 1;
        while (v46 != v48)
        {
          v55 = *--v46;
          *--v54 = v55;
        }
        *((_QWORD *)this + 25) = v54;
        *((_QWORD *)this + 26) = v47;
        *((_QWORD *)this + 27) = &v53[4 * v52];
        if (v48)
          operator delete(v48);
      }
      else
      {
        *v46 = v42;
        v47 = v46 + 1;
      }
      *((_QWORD *)this + 26) = v47;
      ++v42;
      v46 = v47;
    }
    while (v42 != v43);
  }
  CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 47), (unsigned int **)this + 25);
  result = 0;
  *((_QWORD *)this + 13) = (unint64_t)v41;
  *((_DWORD *)a2->var0 + 33) = v43;
  return result;
}

void sub_209CD2784(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, char a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLNaiveBayesClassifier::errorString(CPMLNaiveBayesClassifier *this)
{
  return 0;
}

CPMLModel *CPModelOpen(char *a1, char *a2)
{
  void *v3;
  void *v4;
  CPMLModel *v5;

  v3 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a1, 4);
  v4 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  v5 = -[CPMLModel initWithModelPath:withPropertyListPath:]([CPMLModel alloc], "initWithModelPath:withPropertyListPath:", v3, v4);

  return v5;
}

void sub_209CD2860(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CPModelPredictV(void *a1, char *a2, ...)
{
  return 0;
}

void sub_209CD2930(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CD29C4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CD2A6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_209CD2B44(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CD2C38(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy_(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose_(uint64_t a1)
{

}

void sub_209CD3250(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_209CD34D8(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPRegressionForestClassfier::serializeTree(uint64_t a1, uint64_t a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;

  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2, "nChildren", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2 + 16, "N", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2 + 20, "M", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2 + 24, "NL", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2 + 28, "level", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), a2 + 32, "splitAttr", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 48))(*(_QWORD *)(a1 + 88), a2 + 40, "splitThreshold", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 48))(*(_QWORD *)(a1 + 88), a2 + 48, "splitCost", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 48))(*(_QWORD *)(a1 + 88), a2 + 56, "meanTarget", 1, 0);
  v9 = 0;
  v4 = *(uint64_t **)(a2 + 8);
  v6 = *v4;
  v5 = v4[1];
  if (v6)
  {
    if (!v5)
    {
      v9 = 1;
      (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), &v9, "flagChildren", 1, 0);
      v7 = **(_QWORD **)(a2 + 8);
      goto LABEL_8;
    }
    v9 = 3;
    (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), &v9, "flagChildren", 1, 0);
    CPRegressionForestClassfier::serializeTree(a1, **(_QWORD **)(a2 + 8));
  }
  else
  {
    if (!v5)
    {
      (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), &v9, "flagChildren", 1, 0);
      return 0;
    }
    v9 = 2;
    (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**(_QWORD **)(a1 + 88) + 24))(*(_QWORD *)(a1 + 88), &v9, "flagChildren", 1, 0);
  }
  v7 = *(_QWORD *)(*(_QWORD *)(a2 + 8) + 8);
LABEL_8:
  CPRegressionForestClassfier::serializeTree(a1, v7);
  return 0;
}

void CPRegressionForestClassfier::CPRegressionForestClassfier(CPRegressionForestClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v7;
  _QWORD *v8;
  unsigned int *v9;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v7 = &off_24C255B28;
  strcpy((char *)(v7 + 8), "1.0.0");
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  if ((int)CPMLTunableData::getNumberOfItems(a4) > 4)
  {
    v9 = (unsigned int *)malloc_type_malloc(0x28uLL, 0x1080040F07CF49EuLL);
    *((_QWORD *)this + 12) = v9;
    CPMLTunableData::tDataGetUInt(a4, "numTrees", v9);
    CPMLTunableData::tDataGetUInt(a4, "maxDepth", (unsigned int *)(*((_QWORD *)this + 12) + 16));
    CPMLTunableData::tDataGetUInt(a4, "minCardinality", (unsigned int *)(*((_QWORD *)this + 12) + 20));
    CPMLTunableData::tDataGetUInt(a4, "nSplitsPerTest", (unsigned int *)(*((_QWORD *)this + 12) + 24));
    CPMLTunableData::tDataGetDouble(a4, "splitPerTree", (double *)(*((_QWORD *)this + 12) + 32));
  }
  else
  {
    v8 = malloc_type_malloc(0x28uLL, 0x1080040F07CF49EuLL);
    *(_DWORD *)v8 = 7;
    v8[2] = 0x100000003;
    *((_DWORD *)v8 + 6) = 12;
    v8[4] = 0x3FE6666666666666;
    v8[1] = malloc_type_malloc(0x38uLL, 0x2004093837F09uLL);
    *((_QWORD *)this + 12) = v8;
  }
}

void sub_209CD3950(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPRegressionForestClassfier::CPRegressionForestClassfier(CPRegressionForestClassfier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  _QWORD *v5;
  unsigned int *v6;
  uint64_t v7;
  unint64_t v8;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *v5 = &off_24C255B28;
  v6 = (unsigned int *)malloc_type_malloc(0x28uLL, 0x1080040F07CF49EuLL);
  *((_QWORD *)this + 12) = v6;
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, (char *)this + 8, "version", 5, 0);
  (*((void (**)(CPMLSerialization *, unsigned int *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, v6, "numTrees", 1, 0);
  (*((void (**)(CPMLSerialization *, unsigned int *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, v6 + 4, "maxDepth", 1, 0);
  (*((void (**)(CPMLSerialization *, unsigned int *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, v6 + 5, "minCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, unsigned int *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, v6 + 6, "nSplitsPerTest", 1, 0);
  (*((void (**)(CPMLSerialization *, unsigned int *, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, v6 + 8, "splitPerTree", 1, 0);
  *((_QWORD *)v6 + 1) = malloc_type_malloc(8 * *v6, 0x2004093837F09uLL);
  if (*v6)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      deSerializeTree((uint64_t)a2, (_QWORD *)(*((_QWORD *)v6 + 1) + v7), v8++);
      v7 += 8;
    }
    while (v8 < *v6);
  }
}

void sub_209CD3B08(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

_QWORD *deSerializeTree(uint64_t a1, _QWORD *a2, uint64_t a3)
{
  _QWORD *v6;
  _QWORD *result;
  uint64_t v8;
  uint64_t v9;
  int v10;

  v6 = malloc_type_malloc(0x40uLL, 0x10800407B512463uLL);
  *a2 = v6;
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v6, "nChildren", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v6 + 2, "N", 1, a3);
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, (uint64_t)v6 + 20, "M", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v6 + 3, "NL", 1, a3);
  (*(void (**)(uint64_t, uint64_t, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, (uint64_t)v6 + 28, "level", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v6 + 4, "splitAttr", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(a1, v6 + 5, "splitThreshold", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(a1, v6 + 6, "splitCost", 1, a3);
  (*(void (**)(uint64_t, _QWORD *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 96))(a1, v6 + 7, "meanTarget", 1, a3);
  v10 = 0;
  (*(void (**)(uint64_t, int *, const char *, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, &v10, "flagChildren", 1, a3);
  result = malloc_type_malloc(0x10uLL, 0x2004093837F09uLL);
  v6[1] = result;
  *result = 0;
  *(_QWORD *)(v6[1] + 8) = 0;
  if (v10 == 1)
  {
    v8 = v6[1];
LABEL_7:
    v9 = a3 + 1;
    return (_QWORD *)deSerializeTree(a1, v8, v9);
  }
  if (v10 == 2)
  {
    v8 = v6[1] + 8;
    goto LABEL_7;
  }
  if (v10 != 3)
    return result;
  deSerializeTree(a1, v6[1], a3 + 1);
  v8 = v6[1] + 8;
  v9 = a3 + 2;
  return (_QWORD *)deSerializeTree(a1, v8, v9);
}

void CPRegressionForestClassfier::~CPRegressionForestClassfier(CPRegressionForestClassfier *this)
{
  unsigned int *v2;
  unint64_t v3;

  *(_QWORD *)this = &off_24C255B28;
  v2 = (unsigned int *)*((_QWORD *)this + 12);
  if (*v2)
  {
    v3 = 0;
    do
      CPRTdestroyTree(*(_QWORD **)(*((_QWORD *)v2 + 1) + 8 * v3++));
    while (v3 < *v2);
  }
  free(*((void **)v2 + 1));
  CPModelClose(this);
}

{
  CPRegressionForestClassfier::~CPRegressionForestClassfier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPRegressionForestClassfier::serialize(CPRegressionForestClassfier *this)
{
  unsigned int *v2;
  uint64_t v3;
  uint64_t v4;
  char *v5;
  size_t v6;
  unint64_t v7;

  v3 = *((_QWORD *)this + 11);
  v2 = (unsigned int *)*((_QWORD *)this + 12);
  v4 = *((_QWORD *)v2 + 1);
  v5 = (char *)this + 8;
  v6 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v3 + 56))(v3, v5, "version", v6, 0);
  (*(void (**)(_QWORD, unsigned int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), v2, "numTrees", 1, 0);
  (*(void (**)(_QWORD, unsigned int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), v2 + 4, "maxDepth", 1, 0);
  (*(void (**)(_QWORD, unsigned int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), v2 + 5, "minCardinality", 1, 0);
  (*(void (**)(_QWORD, unsigned int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), v2 + 6, "nSplitsPerTest", 1, 0);
  (*(void (**)(_QWORD, unsigned int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v2 + 8, "splitPerTree", 1, 0);
  if (*v2)
  {
    v7 = 0;
    do
      CPRegressionForestClassfier::serializeTree((uint64_t)this, *(_QWORD *)(v4 + 8 * v7++));
    while (v7 < *v2);
  }
  return 0;
}

uint64_t CPRegressionForestClassfier::train(double **this)
{
  pthread_mutex_t *CPMLLog;
  CPMLFeatureVector *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  double *v8;
  uint64_t *RealVector;
  unsigned int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  float v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  double *v19;
  float v20;
  double *v21;
  uint64_t v22;
  double *v23;
  double *v24;
  unint64_t v25;
  uint64_t i;
  uint32_t v27;
  uint32_t v28;
  int v29;
  uint64_t v30;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "train", "start training Regression Forest\n");
  v3 = (CPMLFeatureVector *)(*(uint64_t (**)(double *))(*(_QWORD *)this[10] + 16))(this[10]);
  v4 = *(_QWORD *)this[6];
  v5 = *(unsigned int *)(v4 + 120);
  v6 = (*(_DWORD *)(v4 + 124) - 1);
  v7 = (double *)malloc_type_malloc(8 * v5 * v6, 0x73EFCCDCuLL);
  v8 = (double *)malloc_type_malloc(8 * v5, 0x85EA264uLL);
  RealVector = (uint64_t *)CPMLFeatureVector::getRealVector(v3);
  if ((_DWORD)v6)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      if ((_DWORD)v5)
      {
        v12 = *RealVector;
        v13 = v5;
        v14 = v10;
        do
        {
          v15 = *(double *)(v12 + 8 * v14);
          v7[v14++] = v15;
          --v13;
        }
        while (v13);
      }
      ++v11;
      v10 += v5;
    }
    while (v11 != (_DWORD)v6);
  }
  if ((_DWORD)v5)
  {
    v16 = v6 * v5;
    v17 = *RealVector;
    v18 = v5;
    v19 = v8;
    do
    {
      v20 = *(double *)(v17 + 8 * v16);
      *v19++ = v20;
      ++v16;
      --v18;
    }
    while (v18);
  }
  v21 = this[12];
  v22 = (v21[4] * (double)v5);
  v23 = (double *)malloc_type_malloc(8 * v22 * v6, 0x60E23D3DuLL);
  v24 = (double *)malloc_type_malloc(8 * v22, 0xF3567D95uLL);
  if (*(_DWORD *)v21)
  {
    v25 = 0;
    do
    {
      if ((_DWORD)v22)
      {
        for (i = 0; i != v22; ++i)
        {
          v27 = arc4random_uniform(v5);
          v28 = v27;
          v29 = i;
          v30 = v6;
          if ((_DWORD)v6)
          {
            do
            {
              v23[v29] = v7[v28];
              v29 += v22;
              v28 += v5;
              --v30;
            }
            while (v30);
          }
          v24[i] = v8[v27];
        }
      }
      *(_QWORD *)(*((_QWORD *)v21 + 1) + 8 * v25++) = CPRTgrowTree(*((_DWORD *)v21 + 4), *((_DWORD *)v21 + 5), *((_DWORD *)v21 + 6), (double (*)(double *, double *, unsigned int, unsigned int, unsigned int *, double *, unsigned int *, double))CPRTcostTargetSD, v6, v22, v23, v24, 0);
    }
    while (v25 < *(unsigned int *)v21);
  }
  free(v23);
  free(v24);
  free(v7);
  free(v8);
  return 0;
}

uint64_t CPRegressionForestClassfier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t **RealVector;
  unint64_t v5;
  unint64_t v6;
  void *v7;
  void *v8;
  uint64_t *v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  unsigned int *v13;
  double *v14;
  _QWORD *v15;
  _QWORD *v16;
  unint64_t v17;
  double *v18;
  unint64_t v19;
  double v20;
  pthread_mutex_t *v21;
  CPMLLog *v22;
  pthread_mutex_t *CPMLLog;

  RealVector = (uint64_t **)CPMLFeatureVector::getRealVector(this);
  v5 = (char *)RealVector[1] - (char *)*RealVector;
  v6 = v5 >> 3;
  v7 = malloc_type_malloc(v5 & 0x7FFFFFFF8, 0xACF3CB29uLL);
  v8 = v7;
  if ((v5 >> 3))
  {
    v9 = *RealVector;
    v10 = (v5 >> 3);
    v11 = v7;
    do
    {
      v12 = *v9++;
      *v11++ = v12;
      --v10;
    }
    while (v10);
  }
  v13 = *(unsigned int **)(a1 + 96);
  v14 = (double *)malloc_type_calloc(1uLL, 8uLL, 0x100004000313F17uLL);
  if (v14)
  {
    v15 = malloc_type_calloc(*v13, 8uLL, 0x80040B8603338uLL);
    if (v15)
    {
      v16 = v15;
      if (*v13)
      {
        v17 = 0;
        do
        {
          v18 = CPRTpredictRegressTree(*(_QWORD *)(*((_QWORD *)v13 + 1) + 8 * v17), (uint64_t)v8, 1u, v6);
          v16[v17] = v18;
          *v14 = *v18 + *v14;
          free(v18);
          ++v17;
          v19 = *v13;
        }
        while (v17 < v19);
        v20 = (double)v19;
      }
      else
      {
        v20 = 0.0;
      }
      *v14 = *v14 / v20;
      free(v16);
    }
    else
    {
      free(v14);
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v22);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "predictForest", "yt out of memory.");
      v14 = 0;
    }
  }
  else
  {
    v21 = (pthread_mutex_t *)CPMLLog::getCPMLLog(0);
    CPMLLog::log(v21, CPML_LOG_ERR, "predictForest", "y out of memory.");
  }
  CPMLFeatureVector::setYHat((uint64_t)this, *v14);
  free(v8);
  free(v14);
  return 0;
}

uint64_t CPRegressionForestClassfier::errorString(CPRegressionForestClassfier *this)
{
  return 0;
}

uint64_t CPRegressionForestClassfier::requireRealOnly(CPRegressionForestClassfier *this)
{
  return 1;
}

void CPMLNaiveBayesSuggestionsClassifier::CPMLNaiveBayesSuggestionsClassifier(CPMLNaiveBayesSuggestionsClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  CPMLStatistics *var0;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  size_t v13;
  unint64_t v14;
  char v15[20];
  char v16[10];
  uint64_t v17;

  v17 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v8 = &off_24C255D80;
  *(_QWORD *)(v8 + 176) = 0;
  *(_QWORD *)(v8 + 184) = 0;
  *(_QWORD *)(v8 + 192) = 0;
  *(_QWORD *)(v8 + 360) = 0;
  *(_QWORD *)(v8 + 368) = 0;
  strcpy((char *)(v8 + 8), "1.0.1");
  *(_QWORD *)(v8 + 112) = 0;
  var0 = a2->var0;
  *(_QWORD *)(v8 + 96) = *((int *)a2->var0 + 31);
  v10 = *((int *)var0 + 33);
  *(_QWORD *)(v8 + 104) = v10;
  *(_QWORD *)(v8 + 120) = (uint64_t)(*((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3)) >> 3;
  v11 = *(_QWORD *)var0;
  *(_QWORD *)(v8 + 128) = (uint64_t)(*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2;
  *(_QWORD *)(v8 + 136) = v11;
  *(_QWORD *)(v8 + 144) = v10;
  *(_QWORD *)(v8 + 152) = (uint64_t)(*((_QWORD *)var0 + 7) - *((_QWORD *)var0 + 6)) >> 2;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPMLNaiveBayesSuggestionsClassifier::setTunableData(this, a4);
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "version", "version TEXT");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "rowCountY", "rowCountY REAL");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "yCount", "yMap INTEGER, yCount REAL");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "resultCardinality", "resultCardinality REAL");
  if (*((_QWORD *)this + 12))
  {
    v12 = 0;
    do
    {
      sprintf(v16, "xcol%d", v12);
      sprintf(v15, "xCardinality%d", v12);
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v15, "yMap INTEGER, xCardinality REAL");
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v16, "xMap INTEGER, yMap INTEGER, xyCount REAL");
      ++v12;
    }
    while (*((_QWORD *)this + 12) > v12);
  }
  v13 = *((_QWORD *)this + 19);
  if (v13)
  {
    *((_QWORD *)this + 21) = malloc_type_calloc(v13, 8uLL, 0x10040436913F5uLL);
    *((_QWORD *)this + 20) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x100004000313F17uLL);
    if (*((_QWORD *)this + 19))
    {
      v14 = 0;
      do
        *(_QWORD *)(*((_QWORD *)this + 21) + 8 * v14++) = malloc_type_calloc(*((_QWORD *)this + 18) * *((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
      while (*((_QWORD *)this + 19) > v14);
    }
  }
}

void sub_209CD45E8(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    v1[23] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

CPMLLogger *CPMLNaiveBayesSuggestionsClassifier::setTunableData(CPMLNaiveBayesSuggestionsClassifier *this, CPMLTunableData *a2)
{
  int NumberOfItems;
  int *v5;
  _DWORD *v6;
  BOOL *v7;
  CPMLLogger *v13;
  CPMLLogger *result;

  NumberOfItems = CPMLTunableData::getNumberOfItems(a2);
  v5 = (int *)((char *)this + 304);
  v6 = (_DWORD *)((char *)this + 312);
  v7 = (BOOL *)this + 201;
  if (NumberOfItems < 2)
  {
    *((_QWORD *)this + 43) = 0x100000020;
    __asm { FMOV            V0.2D, #1.0 }
    *((_OWORD *)this + 20) = _Q0;
    *((_QWORD *)this + 42) = 0x3CD203AF9EE75616;
    *(_QWORD *)v5 = 0xA00000014;
    *v6 = 10;
    *v7 = 0;
    *((_BYTE *)this + 200) = 0;
    strcpy((char *)this + 202, "defaultNBV3");
  }
  else
  {
    CPMLTunableData::tDataGetInt(a2, "k", v5);
    CPMLTunableData::tDataGetInt(a2, "cacheLength", (int *)this + 86);
    CPMLTunableData::tDataGetInt(a2, "cacheAssocitivity", (int *)this + 87);
    CPMLTunableData::tDataGetDouble(a2, "decayRate", (double *)this + 40);
    CPMLTunableData::tDataGetDouble(a2, "smoothRate", (double *)this + 41);
    CPMLTunableData::tDataGetDouble(a2, "epsilonRate", (double *)this + 42);
    CPMLTunableData::tDataGetUInt(a2, "maxAllowedUpdate", (unsigned int *)this + 77);
    CPMLTunableData::tDataGetUInt(a2, "maxAllowedPredict", (unsigned int *)this + 78);
    CPMLTunableData::tDataGetBool(a2, "enableLogging", (BOOL *)this + 201);
    CPMLTunableData::tDataGetBool(a2, "dataCollection", (BOOL *)this + 200);
    CPMLTunableData::tDataGetString(a2, "logFilename", (char *)this + 202, 0x64uLL);
    CPMLTunableData::tDataGetString(a2, "versionMD", (char *)this + 8, 0x20uLL);
    if (!*((_DWORD *)this + 77))
      *((_DWORD *)this + 77) = 10;
    if (!*v6)
      *v6 = 10;
    if (!*((_BYTE *)this + 8))
      strcpy((char *)this + 8, "1.0.1");
  }
  v13 = (CPMLLogger *)operator new();
  result = CPMLLogger::CPMLLogger(v13, (char *)this + 202, *v7);
  *((_QWORD *)this + 44) = v13;
  return result;
}

void sub_209CD486C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10F2C40B74731EELL);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesSuggestionsClassifier::CPMLNaiveBayesSuggestionsClassifier(CPMLNaiveBayesSuggestionsClassifier *this, CPMLStatistics *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  unint64_t v9;
  CPMLNaiveBayesSuggestionsAdaptor *v10;
  CPMLNaiveBayes *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  int *v16;
  uint64_t v17;
  int v18;
  unsigned int *v19;
  unsigned int *v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  unint64_t v24;
  char *v25;
  unsigned int *v26;
  unsigned int v27;
  double v28;
  double v29;
  char v30[150];
  unsigned int *v31;
  unsigned int *v32;
  _QWORD v33[19];

  v33[17] = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a3, a4);
  *(_QWORD *)v8 = &off_24C255D80;
  *(_OWORD *)(v8 + 160) = 0u;
  *(_OWORD *)(v8 + 176) = 0u;
  *(_QWORD *)(v8 + 192) = 0;
  *(_QWORD *)(v8 + 96) = *((int *)a2 + 31);
  v28 = 0.0;
  v29 = 0.0;
  CPMLNaiveBayesSuggestionsClassifier::setTunableData((CPMLNaiveBayesSuggestionsClassifier *)v8, a4);
  (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 24))(a3, (char *)this + 104, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality INTEGER, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "CREATE TABLE IF NOT EXISTS rowCountY (rowCountY REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "CREATE TABLE IF NOT EXISTS yCount (yMap INTEGER, yCount REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "CREATE INDEX IF NOT EXISTS idxRowCountY on rowCountY (rowCountY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "CREATE INDEX IF NOT EXISTS idxYCount on yCount (yMap, yCount);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='version';");
  if (v28 == 0.0)
  {
    (*((void (**)(CPMLSerialization *, double *, const char *, double))a3->var0 + 28))(a3, &v28, "CREATE TABLE IF NOT EXISTS version (version TEXT, pKey INTEGER PRIMARY KEY);",
      v28);
    sprintf((char *)&v31, "\"%s\"", (const char *)this + 8);
    (*((void (**)(CPMLSerialization *, const char *, const char *, unsigned int **))a3->var0 + 17))(a3, "version", "version", &v31);
  }
  else
  {
    (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD, double))a3->var0 + 13))(a3, (char *)this + 8, "version", 32, 0, v28);
  }
  if (*((_QWORD *)this + 12))
  {
    v9 = 0;
    do
    {
      sprintf((char *)&v31, "CREATE TABLE IF NOT EXISTS xcol%d (xMap INTEGER, yMap INTEGER, xyCount REAL, pKey INTEGER PRIMARY KEY);",
        v9);
      sprintf(v30, "CREATE TABLE IF NOT EXISTS xCardinality%d (yMap INTEGER, xCardinality REAL, pKey INTEGER PRIMARY KEY);",
        v9);
      (*((void (**)(CPMLSerialization *, double *, char *))a3->var0 + 28))(a3, &v28, v30);
      (*((void (**)(CPMLSerialization *, double *, unsigned int **))a3->var0 + 28))(a3, &v28, &v31);
      ++v9;
    }
    while (*((_QWORD *)this + 12) > v9);
  }
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v29, "select count(*) from yCount;");
  if (v29 >= 1.0)
  {
    *((_QWORD *)this + 13) = (unint64_t)v29;
  }
  else
  {
    v31 = 0;
    (*((void (**)(CPMLSerialization *, unsigned int **, const char *, uint64_t, _QWORD, double))a3->var0 + 4))(a3, &v31, "resultCardinality", 1, 0, v29);
  }
  v10 = (CPMLNaiveBayesSuggestionsAdaptor *)operator new();
  CPMLNaiveBayesSuggestionsAdaptor::CPMLNaiveBayesSuggestionsAdaptor(v10, a3);
  *((_QWORD *)this + 46) = v10;
  v11 = (CPMLNaiveBayes *)operator new();
  CPMLNaiveBayes::CPMLNaiveBayes(v11, *((CPMLNaiveBayesDBAdaptor **)this + 46));
  *(_QWORD *)v11 = &unk_24C255A98;
  *((_DWORD *)v11 + 18) = 10;
  *((_QWORD *)this + 45) = v11;
  CPMLNaiveBayes::set_decay_rate((uint64_t)v11, *((double *)this + 40));
  CPMLNaiveBayes::set_smooth_rate(*((_QWORD *)this + 45), *((double *)this + 41));
  CPMLNaiveBayes::set_epsilon_rate(*((_QWORD *)this + 45), *((double *)this + 42));
  v12 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 46) + 80))(*((_QWORD *)this + 46), *((unsigned int *)this + 86), *((unsigned int *)this + 87));
  v31 = 0;
  v32 = 0;
  v33[0] = 0;
  MEMORY[0x24BDAC7A8](v12, v13);
  v15 = (char *)&v28 - v14;
  (*((void (**)(CPMLSerialization *, char *, unint64_t, const char *))a3->var0 + 27))(a3, (char *)&v28 - v14, (unint64_t)v29, "select yMap from yCount;");
  if ((int)v29 >= 1)
  {
    v16 = 0;
    v17 = 0;
    do
    {
      v18 = (int)*(double *)&v15[8 * v17];
      if ((unint64_t)v16 >= v33[0])
      {
        v20 = v31;
        v21 = ((char *)v16 - (char *)v31) >> 2;
        v22 = v21 + 1;
        if ((unint64_t)(v21 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v23 = v33[0] - (_QWORD)v31;
        if ((uint64_t)(v33[0] - (_QWORD)v31) >> 1 > v22)
          v22 = v23 >> 1;
        if ((unint64_t)v23 >= 0x7FFFFFFFFFFFFFFCLL)
          v24 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v24 = v22;
        if (v24)
        {
          v25 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)v33, v24);
          v20 = v31;
          v16 = (int *)v32;
        }
        else
        {
          v25 = 0;
        }
        v26 = (unsigned int *)&v25[4 * v21];
        *v26 = v18;
        v19 = v26 + 1;
        while (v16 != (int *)v20)
        {
          v27 = *--v16;
          *--v26 = v27;
        }
        v31 = v26;
        v32 = v19;
        v33[0] = &v25[4 * v24];
        if (v20)
          operator delete(v20);
      }
      else
      {
        *v16 = v18;
        v19 = (unsigned int *)(v16 + 1);
      }
      v32 = v19;
      ++v17;
      v16 = (int *)v19;
    }
    while (v17 < (int)v29);
  }
  CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 45), &v31);
  if (v31)
  {
    v32 = v31;
    operator delete(v31);
  }
}

void sub_209CD4D94(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void *v3;

  v3 = (void *)v1[22];
  if (v3)
  {
    v1[23] = v3;
    operator delete(v3);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesSuggestionsClassifier::~CPMLNaiveBayesSuggestionsClassifier(CPMLNaiveBayesSuggestionsClassifier *this)
{
  CPMLLogger *v2;
  CPMLNaiveBayes *v3;
  CPMLNaiveBayesAdaptor *v4;
  void *v5;
  void *v6;
  void *v7;

  *(_QWORD *)this = &off_24C255D80;
  v2 = (CPMLLogger *)*((_QWORD *)this + 44);
  if (v2)
  {
    CPMLLogger::~CPMLLogger(v2);
    MEMORY[0x20BD188E4]();
  }
  v3 = (CPMLNaiveBayes *)*((_QWORD *)this + 45);
  if (v3)
  {
    CPMLNaiveBayes::~CPMLNaiveBayes(v3);
    MEMORY[0x20BD188E4]();
  }
  v4 = (CPMLNaiveBayesAdaptor *)*((_QWORD *)this + 46);
  if (v4)
  {
    CPMLNaiveBayesAdaptor::~CPMLNaiveBayesAdaptor(v4);
    MEMORY[0x20BD188E4]();
  }
  v5 = (void *)*((_QWORD *)this + 20);
  if (v5)
    free(v5);
  v6 = (void *)*((_QWORD *)this + 21);
  if (v6)
    free(v6);
  v7 = (void *)*((_QWORD *)this + 22);
  if (v7)
  {
    *((_QWORD *)this + 23) = v7;
    operator delete(v7);
  }
  CPModelClose(this);
}

{
  CPMLNaiveBayesSuggestionsClassifier::~CPMLNaiveBayesSuggestionsClassifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLNaiveBayesSuggestionsClassifier::serialize(CPMLNaiveBayesSuggestionsClassifier *this)
{
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 56))(*((_QWORD *)this + 11), (char *)this + 8, "version", 32, 0);
  return 0;
}

uint64_t CPMLNaiveBayesSuggestionsClassifier::train(CPMLNaiveBayesSuggestionsClassifier *this)
{
  CPMLFeatureVector *v2;
  CPMLLog *YVectorVector;
  char ***v4;
  unint64_t v5;
  pthread_mutex_t *CPMLLog;
  char **v7;
  char *v8;
  int *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  unint64_t v22;
  char *v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t i;
  unint64_t v27;
  unint64_t v28;
  char *v29;
  pthread_mutex_t *v31;
  char v32[30];
  uint64_t v33;

  v33 = *MEMORY[0x24BDAC8D0];
  v2 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    while (1)
    {
      YVectorVector = (CPMLLog *)CPMLFeatureVector::getYVectorVector(v2);
      v4 = *(char ****)YVectorVector;
      v5 = *((_QWORD *)YVectorVector + 1) - *(_QWORD *)YVectorVector;
      if (!v5)
        break;
      ++*((_QWORD *)this + 14);
      if (v5 < 0x11)
      {
        if (v5 == 16)
        {
          v7 = *v4;
          v8 = **v4;
          v9 = (int *)v7[1];
          v10 = (char *)v9 - v8;
          if (((unint64_t)((char *)v9 - v8) >> 2))
          {
            v11 = (v10 >> 2);
            if (v11 == 1)
            {
              *(double *)(*((_QWORD *)this + 20) + 8 * *(int *)v8) = *(double *)(*((_QWORD *)this + 20)
                                                                                 + 8 * *(int *)v8)
                                                                     + 1.0;
            }
            else
            {
              v12 = *((unsigned int *)this + 77);
              if (v12 < v11)
              {
                v13 = v10 - 4;
                do
                {
                  v14 = v13;
                  --v9;
                  v15 = v13 >> 2;
                  v13 -= 4;
                }
                while (v12 < v15);
                v11 = (v14 >> 2);
                v7[1] = (char *)v9;
              }
              if ((int)v11 >= 1)
              {
                v16 = 0;
                v17 = *((_QWORD *)this + 20);
                do
                {
                  v18 = 0;
                  v19 = *(int *)&v8[4 * v16];
                  *(double *)(v17 + 8 * v19) = *(double *)(v17 + 8 * v19) + 1.0;
                  do
                  {
                    if (v16 != v18)
                    {
                      v20 = *(int *)&v8[4 * v18] + *((_QWORD *)this + 18) * v19;
                      ++*(_QWORD *)(**((_QWORD **)this + 21) + 8 * v20);
                    }
                    ++v18;
                  }
                  while (v11 != v18);
                  ++v16;
                }
                while (v16 != v11);
              }
            }
          }
        }
      }
      else
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "train", "Too many Y\n");
      }
      v2 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      if (!v2)
        goto LABEL_21;
    }
    v31 = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
    CPMLLog::log(v31, CPML_LOG_ERR, "train", "no vectors to process\n");
    return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_21:
    v21 = sqlite3_mprintf("%lf", (double)*((unint64_t *)this + 14));
    (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "rowCountY", "rowCountY", v21);
    if (v21)
      sqlite3_free(v21);
    if (*((_QWORD *)this + 13))
    {
      v22 = 0;
      do
      {
        v23 = sqlite3_mprintf("%d,%lf", v22, *(double *)(*((_QWORD *)this + 20) + 8 * v22));
        (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "yCount", "yMap,yCount", v23);
        if (v23)
          sqlite3_free(v23);
        ++v22;
      }
      while (*((_QWORD *)this + 13) > v22);
    }
    if (*((_QWORD *)this + 12))
    {
      v24 = 0;
      do
      {
        sprintf(v32, "xcol%d", v24);
        v25 = *((_QWORD *)this + 18);
        if (v25)
        {
          for (i = 0; i < v25; ++i)
          {
            v27 = 0;
            do
            {
              v28 = *(_QWORD *)(**((_QWORD **)this + 21) + 8 * (v27 + i * v25));
              if (v28)
              {
                v29 = sqlite3_mprintf("%d,%d,%lf", i, v27, (double)v28);
                (*(void (**)(_QWORD, char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), v32, "xMap,yMap,xyCount", v29);
                if (v29)
                  sqlite3_free(v29);
              }
              ++v27;
              v25 = *((_QWORD *)this + 18);
            }
            while (v25 > v27);
          }
        }
        ++v24;
      }
      while (*((_QWORD *)this + 12) > v24);
    }
    return 0;
  }
}

uint64_t CPMLNaiveBayesSuggestionsClassifier::eval(uint64_t a1, CPMLFeatureVector *this, uint64_t *a3)
{
  CPMLLog *XVectorVector;
  uint64_t *v7;
  uint64_t v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  unint64_t v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  int v26;
  uint64_t v27;
  uint64_t v28;
  void (***v29)(_QWORD, uint64_t, void **, uint64_t, uint64_t);
  uint64_t result;
  pthread_mutex_t *CPMLLog;
  unint64_t i;
  _QWORD *v33;
  char *v34;
  char *v35;
  char *v36;
  uint64_t v37;
  unint64_t v38;
  uint64_t v39;
  unint64_t v40;
  char *v41;
  char *v42;
  int v43;
  void ***v44;
  uint64_t v45;
  uint64_t v46;
  void *__p;
  char *v48;
  char *v49;
  _OWORD v50[2];
  int v51;
  void ****v52;

  if (!*(_QWORD *)(a1 + 104))
    return 0xFFFFFFFFLL;
  XVectorVector = (CPMLLog *)CPMLFeatureVector::getXVectorVector(this);
  if (*((_QWORD *)XVectorVector + 1) == *(_QWORD *)XVectorVector)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(XVectorVector);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "eval", "only vector support");
  }
  else
  {
    v7 = *(uint64_t **)(*(_QWORD *)XVectorVector + 16 * *(int *)this);
    v8 = v7[1];
    v9 = *(_DWORD *)(a1 + 312);
    v10 = v8 - *v7;
    if (v9 < (v10 >> 2))
    {
      v11 = v10 - 4;
      do
      {
        v8 -= 4;
        v12 = v11 >> 2;
        v11 -= 4;
      }
      while (v9 < v12);
      v7[1] = v8;
    }
    memset(v50, 0, sizeof(v50));
    v51 = 1065353216;
    v13 = *v7;
    if (v7[1] != *v7)
    {
      v14 = 0;
      do
      {
        LODWORD(v44) = 0;
        LODWORD(v44) = *(_DWORD *)(v13 + 4 * v14);
        __p = &v44;
        *((_DWORD *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v50, (int *)&v44, (uint64_t)&std::piecewise_construct, (_DWORD **)&__p)+ 5) = 1;
        ++v14;
        v13 = *v7;
      }
      while (v14 < (v7[1] - *v7) >> 2);
    }
    __p = 0;
    v48 = 0;
    v49 = 0;
    v15 = *a3;
    if (a3[1] == *a3)
    {
      for (i = 0; ; ++i)
      {
        v33 = (_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 368) + 72))(*(_QWORD *)(a1 + 368));
        if (i >= (uint64_t)(v33[1] - *v33) >> 2)
          break;
        LODWORD(v52) = 0;
        LODWORD(v52) = *(_DWORD *)(*(_QWORD *)(*(uint64_t (**)(_QWORD))(**(_QWORD **)(a1 + 368) + 72))(*(_QWORD *)(a1 + 368))
                                 + 4 * i);
        v44 = (void ***)&v52;
        if (*((_DWORD *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v50, (int *)&v52, (uint64_t)&std::piecewise_construct, (_DWORD **)&v44)+ 5) != 1)
        {
          v34 = v48;
          if (v48 >= v49)
          {
            v36 = (char *)__p;
            v37 = (v48 - (_BYTE *)__p) >> 2;
            v38 = v37 + 1;
            if ((unint64_t)(v37 + 1) >> 62)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v39 = v49 - (_BYTE *)__p;
            if ((v49 - (_BYTE *)__p) >> 1 > v38)
              v38 = v39 >> 1;
            if ((unint64_t)v39 >= 0x7FFFFFFFFFFFFFFCLL)
              v40 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v40 = v38;
            if (v40)
            {
              v41 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v49, v40);
              v36 = (char *)__p;
              v34 = v48;
            }
            else
            {
              v41 = 0;
            }
            v42 = &v41[4 * v37];
            *(_DWORD *)v42 = (_DWORD)v52;
            v35 = v42 + 4;
            while (v34 != v36)
            {
              v43 = *((_DWORD *)v34 - 1);
              v34 -= 4;
              *((_DWORD *)v42 - 1) = v43;
              v42 -= 4;
            }
            __p = v42;
            v48 = v35;
            v49 = &v41[4 * v40];
            if (v36)
              operator delete(v36);
          }
          else
          {
            *(_DWORD *)v48 = (_DWORD)v52;
            v35 = v34 + 4;
          }
          v48 = v35;
        }
      }
    }
    else
    {
      v16 = 0;
      do
      {
        LODWORD(v52) = 0;
        LODWORD(v52) = *(_DWORD *)(v15 + 4 * v16);
        v44 = (void ***)&v52;
        if (*((_DWORD *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v50, (int *)&v52, (uint64_t)&std::piecewise_construct, (_DWORD **)&v44)+ 5) != 1)
        {
          v17 = v48;
          if (v48 >= v49)
          {
            v19 = (char *)__p;
            v20 = (v48 - (_BYTE *)__p) >> 2;
            v21 = v20 + 1;
            if ((unint64_t)(v20 + 1) >> 62)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v22 = v49 - (_BYTE *)__p;
            if ((v49 - (_BYTE *)__p) >> 1 > v21)
              v21 = v22 >> 1;
            if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL)
              v23 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v23 = v21;
            if (v23)
            {
              v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v49, v23);
              v19 = (char *)__p;
              v17 = v48;
            }
            else
            {
              v24 = 0;
            }
            v25 = &v24[4 * v20];
            *(_DWORD *)v25 = (_DWORD)v52;
            v18 = v25 + 4;
            while (v17 != v19)
            {
              v26 = *((_DWORD *)v17 - 1);
              v17 -= 4;
              *((_DWORD *)v25 - 1) = v26;
              v25 -= 4;
            }
            __p = v25;
            v48 = v18;
            v49 = &v24[4 * v23];
            if (v19)
              operator delete(v19);
          }
          else
          {
            *(_DWORD *)v48 = (_DWORD)v52;
            v18 = v17 + 4;
          }
          v48 = v18;
        }
        ++v16;
        v15 = *a3;
      }
      while (v16 < (a3[1] - *a3) >> 2);
    }
    v44 = 0;
    v45 = 0;
    v46 = 0;
    v27 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>((uint64_t *)&v44, (uint64_t)v7);
    v28 = *(unsigned int *)(a1 + 304);
    v29 = *(void (****)(_QWORD, uint64_t, void **, uint64_t, uint64_t))(a1 + 360);
    v45 = v27;
    CPMLNaiveBayes::predict(v29, (uint64_t)&v44, (unsigned int **)&__p, v28, a1 + 176);
    v52 = &v44;
    std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v52);
    if (__p)
    {
      v48 = (char *)__p;
      operator delete(__p);
    }
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)v50);
  }
  CPMLFeatureVector::setYHatProbList((uint64_t)this, a1 + 176);
  result = 0;
  *(_QWORD *)(a1 + 184) = *(_QWORD *)(a1 + 176);
  return result;
}

void sub_209CD571C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, uint64_t a16, char a17)
{
  uint64_t v17;
  uint64_t v18;

  *(_QWORD *)(v18 - 88) = v17;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)(v18 - 88));
  if (__p)
    operator delete(__p);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)&a17);
  _Unwind_Resume(a1);
}

uint64_t CPMLNaiveBayesSuggestionsClassifier::update(CPMLNaiveBayesSuggestionsClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t Iterator;
  CPMLFeatureVector *v8;
  CPMLLog *YVectorVector;
  uint64_t **v10;
  unint64_t v11;
  pthread_mutex_t *CPMLLog;
  uint64_t *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unsigned int v18;
  unint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  double v25;
  unint64_t v26;
  uint64_t result;
  pthread_mutex_t *v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void **v32;

  Iterator = CPMLCDB::getIterator(a2, 0, 0, 1);
  *((_QWORD *)this + 10) = Iterator;
  v8 = (CPMLFeatureVector *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
  if (v8)
  {
    while (1)
    {
      YVectorVector = (CPMLLog *)CPMLFeatureVector::getYVectorVector(v8);
      v10 = *(uint64_t ***)YVectorVector;
      v11 = *((_QWORD *)YVectorVector + 1) - *(_QWORD *)YVectorVector;
      if (!v11)
        break;
      if (v11 < 0x11)
      {
        if (v11 == 16)
        {
          v13 = *v10;
          v15 = **v10;
          v14 = (*v10)[1];
          v16 = v14 - v15;
          v17 = (unint64_t)(v14 - v15) >> 2;
          if ((_DWORD)v17)
          {
            v18 = *((_DWORD *)this + 77);
            if (v18 < v17)
            {
              v19 = v16 - 4;
              do
              {
                v14 -= 4;
                v20 = v19 >> 2;
                v19 -= 4;
              }
              while (v18 < v20);
              v13[1] = v14;
            }
            v29 = 0;
            v30 = 0;
            v31 = 0;
            v21 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v29, (uint64_t)v13);
            v22 = *v13;
            v23 = v13[1];
            v30 = v21;
            if (v23 != v22)
            {
              v24 = 0;
              do
              {
                CPMLNaiveBayes::update(*((_QWORD *)this + 45), &v29, *(unsigned int *)(v22 + 4 * v24++));
                v22 = *v13;
              }
              while (v24 < (v13[1] - *v13) >> 2);
            }
            v32 = (void **)&v29;
            std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&v32);
          }
        }
      }
      else
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "update", "Too many Y\n");
      }
      v8 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      if (!v8)
        goto LABEL_16;
    }
    v28 = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
    CPMLLog::log(v28, CPML_LOG_ERR, "update", "no vectors to process\n");
    return 0xFFFFFFFFLL;
  }
  else
  {
LABEL_16:
    v25 = (*(double (**)(_QWORD))(**((_QWORD **)this + 46) + 64))(*((_QWORD *)this + 46));
    v26 = (unint64_t)v25;
    if (*((_QWORD *)this + 13) == (unint64_t)v25)
    {
      return 0;
    }
    else
    {
      (*((void (**)(CPMLSerialization *, unint64_t, const char *, const char *, _QWORD))a3->var0 + 21))(a3, (unint64_t)v25, "resultCardinality", "resultCardinality", 0);
      result = 0;
      *((_QWORD *)this + 13) = v26;
      *((_DWORD *)a2->var0 + 33) = v26;
    }
  }
  return result;
}

void sub_209CD5960(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  a12 = (void **)&a9;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100](&a12);
  _Unwind_Resume(a1);
}

uint64_t CPMLNaiveBayesSuggestionsClassifier::errorString(CPMLNaiveBayesSuggestionsClassifier *this)
{
  return 0;
}

uint64_t std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(uint64_t a1)
{
  _QWORD *v2;
  _QWORD *v3;
  void *v4;

  v2 = *(_QWORD **)(a1 + 16);
  if (v2)
  {
    do
    {
      v3 = (_QWORD *)*v2;
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
  v4 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v4)
    operator delete(v4);
  return a1;
}

_QWORD *std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x18uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  *((_DWORD *)v11 + 5) = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v21 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_209CD5BD8(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(uint64_t a1, size_t __n)
{
  size_t prime;
  int8x8_t v4;
  unint64_t v5;
  uint8x8_t v6;
  uint64_t v7;

  if (__n == 1)
  {
    prime = 2;
  }
  else
  {
    prime = __n;
    if ((__n & (__n - 1)) != 0)
      prime = std::__next_prime(__n);
  }
  v4 = *(int8x8_t *)(a1 + 8);
  if (prime > *(_QWORD *)&v4)
    goto LABEL_16;
  if (prime < *(_QWORD *)&v4)
  {
    v5 = vcvtps_u32_f32((float)*(unint64_t *)(a1 + 24) / *(float *)(a1 + 32));
    if (*(_QWORD *)&v4 < 3uLL || (v6 = (uint8x8_t)vcnt_s8(v4), v6.i16[0] = vaddlv_u8(v6), v6.u32[0] > 1uLL))
    {
      v5 = std::__next_prime(v5);
    }
    else
    {
      v7 = 1 << -(char)__clz(v5 - 1);
      if (v5 >= 2)
        v5 = v7;
    }
    if (prime <= v5)
      prime = v5;
    if (prime < *(_QWORD *)&v4)
LABEL_16:
      std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__do_rehash<true>(a1, prime);
  }
}

void std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__do_rehash<true>(uint64_t a1, unint64_t a2)
{
  void *v4;
  void *v5;
  uint64_t v6;
  _QWORD *v7;
  unint64_t v8;
  uint8x8_t v9;
  void *v10;
  _QWORD *v11;
  unint64_t v12;

  if (a2)
  {
    if (a2 >> 61)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v4 = operator new(8 * a2);
    v5 = *(void **)a1;
    *(_QWORD *)a1 = v4;
    if (v5)
      operator delete(v5);
    v6 = 0;
    *(_QWORD *)(a1 + 8) = a2;
    do
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v6++) = 0;
    while (a2 != v6);
    v7 = *(_QWORD **)(a1 + 16);
    if (v7)
    {
      v8 = v7[1];
      v9 = (uint8x8_t)vcnt_s8((int8x8_t)a2);
      v9.i16[0] = vaddlv_u8(v9);
      if (v9.u32[0] > 1uLL)
      {
        if (v8 >= a2)
          v8 %= a2;
      }
      else
      {
        v8 &= a2 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v8) = a1 + 16;
      v11 = (_QWORD *)*v7;
      if (*v7)
      {
        do
        {
          v12 = v11[1];
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= a2)
              v12 %= a2;
          }
          else
          {
            v12 &= a2 - 1;
          }
          if (v12 != v8)
          {
            if (!*(_QWORD *)(*(_QWORD *)a1 + 8 * v12))
            {
              *(_QWORD *)(*(_QWORD *)a1 + 8 * v12) = v7;
              goto LABEL_24;
            }
            *v7 = *v11;
            *v11 = **(_QWORD **)(*(_QWORD *)a1 + 8 * v12);
            **(_QWORD **)(*(_QWORD *)a1 + 8 * v12) = v11;
            v11 = v7;
          }
          v12 = v8;
LABEL_24:
          v7 = v11;
          v11 = (_QWORD *)*v11;
          v8 = v12;
        }
        while (v11);
      }
    }
  }
  else
  {
    v10 = *(void **)a1;
    *(_QWORD *)a1 = 0;
    if (v10)
      operator delete(v10);
    *(_QWORD *)(a1 + 8) = 0;
  }
}

void CPMLLogger::CPMLLogger(CPMLLogger *this, char *a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  char *v12;
  std::ios_base *v13;
  _QWORD *v14;
  const std::locale::facet *v15;
  std::string __p;
  std::locale v17;

  v6 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 8);
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 16);
  *((_QWORD *)this + 1) = v6;
  v8 = (_QWORD *)((char *)this + 8);
  v9 = (uint64_t *)((char *)this + 424);
  v10 = MEMORY[0x24BEDB840];
  v11 = MEMORY[0x24BEDB840] + 64;
  *((_QWORD *)this + 53) = MEMORY[0x24BEDB840] + 64;
  v12 = (char *)this + 16;
  *(_QWORD *)((char *)this + *(_QWORD *)(v6 - 24) + 8) = v7;
  v13 = (std::ios_base *)((char *)this + *(_QWORD *)(*((_QWORD *)this + 1) - 24) + 8);
  std::ios_base::init(v13, (char *)this + 16);
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  *v8 = v10 + 24;
  *v9 = v11;
  MEMORY[0x20BD187B8](v12);
  *((_QWORD *)this + 74) = 0;
  *((_OWORD *)this + 36) = 0u;
  *(_BYTE *)this = a3;
  std::string::basic_string[abi:ne180100]<0>(&__p, "/tmp/");
  std::string::append(&__p, a2);
  if (*(_BYTE *)this)
  {
    std::ofstream::open();
    time(0);
    v14 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v14 + *(_QWORD *)(*v14 - 24)));
    v15 = std::locale::use_facet(&v17, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v15->__vftable[2].~facet_0)(v15, 10);
    std::locale::~locale(&v17);
    std::ostream::put();
    std::ostream::flush();
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
}

void sub_209CD5FAC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  _QWORD *v15;
  uint64_t v16;

  if (*(char *)(v16 + 599) < 0)
    operator delete(*(void **)(v16 + 576));
  std::ofstream::~ofstream(v15);
  _Unwind_Resume(a1);
}

uint64_t CPMLLogger::CPMLLogger(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  std::ios_base *v13;
  int v14;
  const std::string::value_type *v15;
  std::string::size_type v16;
  _QWORD *v17;
  const std::locale::facet *v18;
  std::string __p;
  std::locale v21;

  v6 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 8);
  v7 = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 16);
  *(_QWORD *)(a1 + 8) = v6;
  v8 = (_QWORD *)(a1 + 8);
  v9 = (uint64_t *)(a1 + 424);
  v10 = MEMORY[0x24BEDB840];
  v11 = MEMORY[0x24BEDB840] + 64;
  *(_QWORD *)(a1 + 424) = MEMORY[0x24BEDB840] + 64;
  v12 = a1 + 16;
  *(_QWORD *)(a1 + 8 + *(_QWORD *)(v6 - 24)) = v7;
  v13 = (std::ios_base *)(a1 + 8 + *(_QWORD *)(*(_QWORD *)(a1 + 8) - 24));
  std::ios_base::init(v13, (void *)(a1 + 16));
  v13[1].__vftable = 0;
  v13[1].__fmtflags_ = -1;
  *v8 = v10 + 24;
  *v9 = v11;
  MEMORY[0x20BD187B8](v12);
  *(_QWORD *)(a1 + 592) = 0;
  *(_OWORD *)(a1 + 576) = 0u;
  *(_BYTE *)a1 = a3;
  std::string::basic_string[abi:ne180100]<0>(&__p, "/tmp/");
  v14 = *(char *)(a2 + 23);
  if (v14 >= 0)
    v15 = (const std::string::value_type *)a2;
  else
    v15 = *(const std::string::value_type **)a2;
  if (v14 >= 0)
    v16 = *(unsigned __int8 *)(a2 + 23);
  else
    v16 = *(_QWORD *)(a2 + 8);
  std::string::append(&__p, v15, v16);
  if (*(_BYTE *)a1)
  {
    std::ofstream::open();
    time(0);
    v17 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v17 + *(_QWORD *)(*v17 - 24)));
    v18 = std::locale::use_facet(&v21, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v18->__vftable[2].~facet_0)(v18, 10);
    std::locale::~locale(&v21);
    std::ostream::put();
    std::ostream::flush();
  }
  if (SHIBYTE(__p.__r_.__value_.__r.__words[2]) < 0)
    operator delete(__p.__r_.__value_.__l.__data_);
  return a1;
}

void sub_209CD61C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14, std::locale a15)
{
  _QWORD *v15;
  uint64_t v16;

  if (*(char *)(v16 + 599) < 0)
    operator delete(*(void **)(v16 + 576));
  std::ofstream::~ofstream(v15);
  _Unwind_Resume(a1);
}

void CPMLLogger::~CPMLLogger(CPMLLogger *this)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;

  v2 = (_QWORD *)((char *)this + 8);
  if ((*((_BYTE *)this + *(_QWORD *)(*((_QWORD *)this + 1) - 24) + 40) & 5) == 0
    && *((_QWORD *)this + 17)
    && !std::filebuf::close())
  {
    std::ios_base::clear((std::ios_base *)((char *)v2 + *(_QWORD *)(*v2 - 24)), *(_DWORD *)((char *)v2 + *(_QWORD *)(*v2 - 24) + 32) | 4);
  }
  if (*((char *)this + 599) < 0)
    operator delete(*((void **)this + 72));
  v3 = MEMORY[0x24BEDB7E8];
  v4 = *MEMORY[0x24BEDB7E8];
  *((_QWORD *)this + 1) = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)((char *)v2 + *(_QWORD *)(v4 - 24)) = *(_QWORD *)(v3 + 24);
  MEMORY[0x20BD187C4]((char *)this + 16);
  std::ostream::~ostream();
  MEMORY[0x20BD188B4]((char *)this + 424);
}

uint64_t CPMLLogger::cpmlLog(uint64_t this, const char *a2)
{
  _QWORD *v2;
  const std::locale::facet *v3;
  std::locale v4;

  if (*(_BYTE *)this)
  {
    v2 = (_QWORD *)(this + 8);
    if ((*(_BYTE *)(this + 8 + *(_QWORD *)(*(_QWORD *)(this + 8) - 24) + 32) & 5) == 0)
    {
      if (*(_QWORD *)(this + 136))
      {
        std::ostream::write();
        std::ios_base::getloc((const std::ios_base *)((char *)v2 + *(_QWORD *)(*v2 - 24)));
        v3 = std::locale::use_facet(&v4, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v3->__vftable[2].~facet_0)(v3, 10);
        std::locale::~locale(&v4);
        std::ostream::put();
        return std::ostream::flush();
      }
    }
  }
  return this;
}

void sub_209CD63B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *CPMLLogger::cpmlLog(_QWORD *result, uint64_t a2)
{
  _QWORD *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v6;
  const std::locale::facet *v7;
  std::locale v8;

  if (*(_BYTE *)result)
  {
    v2 = result;
    v3 = result[1];
    if ((*((_BYTE *)++result + *(_QWORD *)(v3 - 24) + 32) & 5) == 0)
    {
      if (v2[17])
      {
        v4 = *(_QWORD *)(a2 + 8);
        if (*(char *)(a2 + 23) >= 0)
        {
          v5 = *(unsigned __int8 *)(a2 + 23);
        }
        else
        {
          a2 = *(_QWORD *)a2;
          v5 = v4;
        }
        v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(result, a2, v5);
        std::ios_base::getloc((const std::ios_base *)((char *)v6 + *(_QWORD *)(*v6 - 24)));
        v7 = std::locale::use_facet(&v8, MEMORY[0x24BEDB350]);
        ((void (*)(const std::locale::facet *, uint64_t))v7->__vftable[2].~facet_0)(v7, 10);
        std::locale::~locale(&v8);
        std::ostream::put();
        return (_QWORD *)std::ostream::flush();
      }
    }
  }
  return result;
}

void sub_209CD6490(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, std::locale a10)
{
  std::locale::~locale(&a10);
  _Unwind_Resume(a1);
}

_QWORD *std::string::basic_string[abi:ne180100]<0>(_QWORD *a1, char *__s)
{
  size_t v4;
  size_t v5;
  void *v6;
  uint64_t v7;
  uint64_t v8;

  v4 = strlen(__s);
  if (v4 >= 0x7FFFFFFFFFFFFFF8)
    std::string::__throw_length_error[abi:ne180100]();
  v5 = v4;
  if (v4 >= 0x17)
  {
    v7 = (v4 & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((v4 | 7) != 0x17)
      v7 = v4 | 7;
    v8 = v7 + 1;
    v6 = operator new(v7 + 1);
    a1[1] = v5;
    a1[2] = v8 | 0x8000000000000000;
    *a1 = v6;
  }
  else
  {
    *((_BYTE *)a1 + 23) = v4;
    v6 = a1;
    if (!v4)
      goto LABEL_9;
  }
  memmove(v6, __s, v5);
LABEL_9:
  *((_BYTE *)v6 + v5) = 0;
  return a1;
}

void CPNaiveBayesV2Classifier::CPNaiveBayesV2Classifier(CPNaiveBayesV2Classifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  _QWORD *v6;
  CPMLStatistics *var0;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *v6 = &off_24C2559E0;
  v6[29] = 0;
  v6[30] = 0;
  v6[31] = 0;
  var0 = a2->var0;
  v8 = *((int *)a2->var0 + 33);
  v6[12] = *((int *)a2->var0 + 31);
  v6[13] = v8;
  v9 = (uint64_t)(*((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3)) >> 3;
  v6[19] = 0;
  v6[20] = v9;
  v10 = *(_QWORD *)var0;
  v6[21] = (uint64_t)(*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2;
  v6[22] = v10;
  v11 = (uint64_t)(*((_QWORD *)var0 + 7) - *((_QWORD *)var0 + 6)) >> 2;
  v6[25] = v8;
  v6[26] = v11;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPNaiveBayesV2Classifier::initializeNaiveBayesV2Memory(this);
}

void sub_209CD65FC(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    v1[30] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void *CPNaiveBayesV2Classifier::initializeNaiveBayesV2Memory(CPNaiveBayesV2Classifier *this)
{
  size_t v2;
  pthread_mutex_t *CPMLLog;
  size_t v4;
  size_t v5;
  size_t i;
  unint64_t v7;
  void *result;
  unint64_t v9;

  *((_QWORD *)this + 18) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x100004000313F17uLL);
  v2 = *((_QWORD *)this + 13);
  if (!v2)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(0);
    CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "initializeNaiveBayesV2Memory", "resultcardinality 0");
    v2 = 1;
    *((_QWORD *)this + 13) = 1;
  }
  if (*((_QWORD *)this + 21))
  {
    *((_QWORD *)this + 23) = malloc_type_calloc(v2, 8uLL, 0x80040B8603338uLL);
    if (*((_QWORD *)this + 13))
    {
      v4 = 0;
      v5 = *((_QWORD *)this + 21);
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 23) + 8 * v4) = malloc_type_calloc(v5, 8uLL, 0x10040436913F5uLL);
        v5 = *((_QWORD *)this + 21);
        if (v5)
        {
          for (i = 0; i < v5; ++i)
          {
            *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v4) + 8 * i) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 22) + 4 * i), 8uLL, 0x100004000313F17uLL);
            v5 = *((_QWORD *)this + 21);
          }
        }
        ++v4;
        v2 = *((_QWORD *)this + 13);
      }
      while (v2 > v4);
    }
    else
    {
      v2 = 0;
    }
  }
  if (*((_QWORD *)this + 20))
  {
    *((_QWORD *)this + 16) = malloc_type_calloc(v2, 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 17) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 14) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 15) = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x80040B8603338uLL);
    if (*((_QWORD *)this + 13))
    {
      v7 = 0;
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v7) = malloc_type_calloc(*((_QWORD *)this + 12), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 17) + 8 * v7) = malloc_type_calloc(*((_QWORD *)this + 12), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v7) = malloc_type_calloc(*((_QWORD *)this + 12), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 15) + 8 * v7++) = malloc_type_calloc(*((_QWORD *)this + 12), 8uLL, 0x100004000313F17uLL);
      }
      while (*((_QWORD *)this + 13) > v7);
    }
  }
  result = (void *)*((_QWORD *)this + 26);
  if (result)
  {
    *((_QWORD *)this + 24) = malloc_type_calloc((size_t)result, 8uLL, 0x10040436913F5uLL);
    result = malloc_type_calloc(*((_QWORD *)this + 13), 8uLL, 0x100004000313F17uLL);
    *((_QWORD *)this + 27) = result;
    if (*((_QWORD *)this + 26))
    {
      v9 = 0;
      do
      {
        result = malloc_type_calloc(*((_QWORD *)this + 25) * *((_QWORD *)this + 25), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 24) + 8 * v9++) = result;
      }
      while (*((_QWORD *)this + 26) > v9);
    }
  }
  return result;
}

void CPNaiveBayesV2Classifier::CPNaiveBayesV2Classifier(CPNaiveBayesV2Classifier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  _QWORD *v5;
  unint64_t *v6;
  uint64_t *v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  char v13[30];
  char v14[30];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  v5[29] = 0;
  *v5 = &off_24C2559E0;
  v5[30] = 0;
  v5[31] = 0;
  (*((void (**)(CPMLSerialization *, _QWORD *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, v5 + 19, "totalDataCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 96, "featureVectorSpace", 1, 0);
  v6 = (unint64_t *)((char *)this + 104);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 104, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 160, "continousFeatureCount", 1, 0);
  v7 = (uint64_t *)((char *)this + 168);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 168, "discreteFeatureCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 200, "vectorCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 208, "vectorFeatureCount", 1, 0);
  if (*((_QWORD *)this + 21))
  {
    *((_QWORD *)this + 22) = malloc_type_calloc(*((_QWORD *)this + 21), 4uLL, 0x100004052888210uLL);
    (*((void (**)(CPMLSerialization *))a2->var0 + 8))(a2);
  }
  CPNaiveBayesV2Classifier::initializeNaiveBayesV2Memory(this);
  v8 = *v6;
  if (*v7)
  {
    if (!v8)
      goto LABEL_15;
    v9 = 0;
    v10 = 1;
    do
    {
      if (v10)
      {
        v11 = 0;
        do
        {
          sprintf(v14, "discreteFeatureTable%d", v11);
          (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 10))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v9) + 8 * v11), v14, *(int *)(*((_QWORD *)this + 22) + 4 * v11), 0);
          ++v11;
          v10 = *v7;
        }
        while (*v7 > v11);
        v8 = *v6;
      }
      ++v9;
    }
    while (v8 > v9);
  }
  if (*((_QWORD *)this + 20) && v8)
  {
    v12 = 0;
    do
    {
      sprintf(v14, "datasetMean%d", v12);
      sprintf(v13, "datasetVariance%d", v12);
      (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v12), v14, *((_QWORD *)this + 12), 0);
      (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *(_QWORD *)(*((_QWORD *)this + 15) + 8 * v12++), v13, *((_QWORD *)this + 12), 0);
    }
    while (*v6 > v12);
  }
LABEL_15:
  (*((void (**)(CPMLSerialization *, _QWORD, const char *))a2->var0 + 10))(a2, *((_QWORD *)this + 18), "dist_datasetOutput");
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 27), "pY_tableFreqCount", *((_QWORD *)this + 13), 0);
}

void sub_209CD6C60(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    v1[30] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPNaiveBayesV2Classifier::~CPNaiveBayesV2Classifier(CPNaiveBayesV2Classifier *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C2559E0;
  if (*((_QWORD *)this + 21))
  {
    if (*((_QWORD *)this + 13))
    {
      v2 = 0;
      do
      {
        if (*((_QWORD *)this + 21))
        {
          v3 = 0;
          do
            free(*(void **)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v2) + 8 * v3++));
          while (*((_QWORD *)this + 21) > v3);
        }
        free(*(void **)(*((_QWORD *)this + 23) + 8 * v2++));
      }
      while (*((_QWORD *)this + 13) > v2);
    }
    free(*((void **)this + 23));
  }
  if (*((_QWORD *)this + 20))
  {
    if (*((_QWORD *)this + 13))
    {
      v4 = 0;
      do
      {
        free(*(void **)(*((_QWORD *)this + 16) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 17) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 14) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 15) + 8 * v4++));
      }
      while (*((_QWORD *)this + 13) > v4);
    }
    free(*((void **)this + 16));
    free(*((void **)this + 17));
    free(*((void **)this + 14));
    free(*((void **)this + 15));
  }
  free(*((void **)this + 18));
  free(*((void **)this + 27));
  v5 = (void *)*((_QWORD *)this + 29);
  if (v5)
  {
    *((_QWORD *)this + 30) = v5;
    operator delete(v5);
  }
  CPModelClose(this);
}

{
  CPNaiveBayesV2Classifier::~CPNaiveBayesV2Classifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPNaiveBayesV2Classifier::serialize(CPNaiveBayesV2Classifier *this)
{
  unint64_t *v2;
  uint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  char v9[30];
  char v10[30];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 152, "totalDataCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  v2 = (unint64_t *)((char *)this + 104);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 160, "continousFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 168, "discreteFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 200, "vectorCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 208, "vectorFeatureCount", 1, 0);
  v3 = *((_QWORD *)this + 21);
  if (v3)
  {
    (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *((_QWORD *)this + 22), "discreteCardinality", v3, 0);
    if (!*((_QWORD *)this + 13))
      goto LABEL_14;
    v4 = 0;
    do
    {
      sprintf(v10, "discreteFeatureTable%d", v4);
      if (*((_QWORD *)this + 21))
      {
        v5 = 0;
        do
        {
          (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v4) + 8 * v5), v10, *(int *)(*((_QWORD *)this + 22) + 4 * v5), 0);
          ++v5;
        }
        while (*((_QWORD *)this + 21) > v5);
      }
      ++v4;
      v6 = *v2;
    }
    while (*v2 > v4);
  }
  else
  {
    v6 = *v2;
  }
  if (*((_QWORD *)this + 20) && v6)
  {
    v7 = 0;
    do
    {
      sprintf(v10, "datasetMean%d", v7);
      sprintf(v9, "datasetVariance%d", v7);
      (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v7), v10, *((_QWORD *)this + 12), 0);
      (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 15) + 8 * v7++), v9, *((_QWORD *)this + 12), 0);
    }
    while (*((_QWORD *)this + 13) > v7);
  }
LABEL_14:
  (*(void (**)(_QWORD, _QWORD, const char *))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), *((_QWORD *)this + 18), "dist_datasetOutput");
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 27), "pY_tableFreqCount", *((_QWORD *)this + 13), 0);
  return 0;
}

uint64_t CPNaiveBayesV2Classifier::train(CPNaiveBayesV2Classifier *this)
{
  uint64_t result;
  CPMLFeatureVector *v3;
  CPMLLog *YVectorVector;
  char ***v5;
  unint64_t v6;
  CPMLLog *XVectorVector;
  pthread_mutex_t *CPMLLog;
  CPMLLog *v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  pthread_mutex_t *v19;
  char *v20;
  char **v21;
  unint64_t v22;
  unint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  pthread_mutex_t *v30;

  result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (result)
  {
    v3 = (CPMLFeatureVector *)result;
    while (1)
    {
      YVectorVector = (CPMLLog *)CPMLFeatureVector::getYVectorVector(v3);
      v5 = *(char ****)YVectorVector;
      v6 = *((_QWORD *)YVectorVector + 1) - *(_QWORD *)YVectorVector;
      if (!v6)
        break;
      ++*((_QWORD *)this + 19);
      if (v6 < 0x11)
      {
        if (v6 == 16)
        {
          v21 = *v5;
          v20 = **v5;
          v22 = v21[1] - v20;
          v23 = v22 >> 2;
          if ((v22 >> 2))
          {
            if ((_DWORD)v23 == 1)
            {
              *(double *)(*((_QWORD *)this + 27) + 8 * *(int *)v20) = *(double *)(*((_QWORD *)this + 27)
                                                                                  + 8 * *(int *)v20)
                                                                      + 1.0;
            }
            else if ((int)v23 >= 1)
            {
              v24 = 0;
              v25 = *((_QWORD *)this + 27);
              v26 = (v22 >> 2);
              do
              {
                v27 = 0;
                v28 = *(int *)&v20[4 * v24];
                *(double *)(v25 + 8 * v28) = *(double *)(v25 + 8 * v28) + 1.0;
                do
                {
                  if (v24 != v27)
                  {
                    v29 = *(int *)&v20[4 * v27] + *((_QWORD *)this + 25) * v28;
                    ++*(_QWORD *)(**((_QWORD **)this + 24) + 8 * v29);
                  }
                  ++v27;
                }
                while (v26 != v27);
                ++v24;
              }
              while (v24 != v26);
            }
          }
        }
      }
      else
      {
        XVectorVector = (CPMLLog *)CPMLFeatureVector::getXVectorVector(v3);
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(XVectorVector);
        v9 = (CPMLLog *)CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "train", "Too many Y\n");
        v11 = *(_QWORD *)XVectorVector;
        v10 = *((_QWORD *)XVectorVector + 1);
        if (v10 != *(_QWORD *)XVectorVector)
        {
          v12 = 0;
          do
          {
            v13 = *(_QWORD **)(v11 + 16 * v12);
            v14 = v13[1] - *v13;
            if (v14)
            {
              v15 = 0;
              v16 = v14 >> 2;
              do
              {
                v17 = 0;
                if (v16 <= 1)
                  v16 = 1;
                do
                {
                  if (v15 != v17)
                  {
                    v18 = *(_QWORD *)(*((_QWORD *)this + 24) + 8 * v12);
                    ++*(_QWORD *)(v18 + 8 * (v17 + v15 * *((_QWORD *)this + 25)));
                  }
                  ++v17;
                }
                while (v16 != v17);
                v19 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
                v9 = (CPMLLog *)CPMLLog::log(v19, CPML_LOG_DEBUG, "train", "%d \n", *(_DWORD *)(*v13 + 4 * v15++));
                v16 = (uint64_t)(v13[1] - *v13) >> 2;
              }
              while (v16 > v15);
              v11 = *(_QWORD *)XVectorVector;
              v10 = *((_QWORD *)XVectorVector + 1);
            }
            ++v12;
          }
          while (v12 < (v10 - v11) >> 4);
        }
      }
      result = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      v3 = (CPMLFeatureVector *)result;
      if (!result)
        return result;
    }
    v30 = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
    CPMLLog::log(v30, CPML_LOG_ERR, "train", "no vectors to process\n");
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CPNaiveBayesV2Classifier::eval(uint64_t a1, CPMLFeatureVector *a2)
{
  size_t v3;
  _QWORD *v5;
  long double *v6;
  unint64_t v7;
  long double *v8;
  uint64_t v9;
  double v10;
  uint64_t i;
  uint64_t v12;
  _QWORD *v13;
  CPMLLog *XVectorVector;
  size_t v15;
  CPMLLog *v16;
  size_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;
  int *v23;
  int **v24;
  uint64_t v25;
  double *v26;
  int *v27;
  uint64_t v28;
  double *v29;
  _DWORD *v30;
  int v31;
  int v32;
  uint64_t v33;
  uint64_t v34;
  double v35;
  double v36;
  long double v37;
  pthread_mutex_t *v38;
  pthread_mutex_t *CPMLLog;
  unint64_t v41;
  _QWORD *v42;
  _QWORD *v43;
  char *v44;
  char *v45;
  uint64_t v46;
  int v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  char *v52;
  char *v53;
  char *v54;
  char *v55;
  char *v56;
  _QWORD v57[2];

  v57[1] = *MEMORY[0x24BDAC8D0];
  v3 = *(_QWORD *)(a1 + 104);
  if (v3)
  {
    v5 = malloc_type_calloc(v3, 0x10uLL, 0x1000040F7F8B94BuLL);
    v6 = (long double *)malloc_type_calloc(*(_QWORD *)(a1 + 104), 8uLL, 0x100004000313F17uLL);
    *(_QWORD *)(a1 + 224) = v6;
    v7 = *(_QWORD *)(a1 + 104);
    if (v7)
    {
      v8 = v6;
      v9 = *(_QWORD *)(a1 + 216);
      v10 = log((double)v7 + (double)*(unint64_t *)(a1 + 152));
      for (i = 0; i != v7; ++i)
        v8[i] = log(*(double *)(v9 + 8 * i) + 1.0) - v10;
      v12 = 0;
      v13 = v5 + 1;
      do
      {
        *((_DWORD *)v13 - 2) = v12;
        *v13 = *(_QWORD *)&v8[v12];
        v13 += 2;
        ++v12;
      }
      while (v7 != v12);
    }
    XVectorVector = (CPMLLog *)CPMLFeatureVector::getXVectorVector(a2);
    if (*((_QWORD *)XVectorVector + 1) == *(_QWORD *)XVectorVector)
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(XVectorVector);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "eval", "only vector support");
      v15 = *(_QWORD *)(a1 + 104);
    }
    else if (*(_QWORD *)(a1 + 104))
    {
      v16 = XVectorVector;
      v17 = 0;
      do
      {
        v18 = (uint64_t)(*(_QWORD *)(**(_QWORD **)v16 + 8) - ***(_QWORD ***)v16) >> 2;
        v19 = v18;
        v20 = MEMORY[0x24BDAC7A8](XVectorVector, v15);
        MEMORY[0x24BDAC7A8](v20, v21);
        v26 = (double *)((char *)v57 - v25);
        if ((int)v18 >= 1)
        {
          v27 = *v24;
          v28 = v18;
          v29 = (double *)((char *)v57 - v25);
          v30 = v23;
          do
          {
            v32 = *v27++;
            v31 = v32;
            if (v32 == -1)
            {
              LODWORD(v18) = 0;
              v35 = *(double *)(*(_QWORD *)(a1 + 216) + 8 * v17);
              goto LABEL_22;
            }
            *v29++ = (double)*(unint64_t *)(**(_QWORD **)(a1 + 192) + 8 * (v17 + *(_QWORD *)(a1 + 200) * v31));
            *v30++ = v31;
            --v28;
          }
          while (v28);
          if ((v22 & 1) != 0)
          {
            v33 = v18;
            do
            {
              v34 = *v23++;
              v5[2 * v34 + 1] = 0xC202A05F20000000;
              --v33;
            }
            while (v33);
          }
        }
        v35 = *(double *)(*(_QWORD *)(a1 + 216) + 8 * v17);
        if ((_DWORD)v18)
        {
          v36 = 0.0;
          do
          {
            v37 = log(*v26 + 1.0);
            *v26++ = v37;
            v36 = v36 + v37;
            --v19;
          }
          while (v19);
        }
        else
        {
LABEL_22:
          v36 = 0.0;
        }
        *(long double *)&v5[2 * v17 + 1] = *(double *)&v5[2 * v17 + 1]
                                         + v36
                                         - (double)v18 * log(v35 + (double)v18);
        ++v17;
        v15 = *(_QWORD *)(a1 + 104);
      }
      while (v15 > v17);
    }
    else
    {
      v15 = 0;
    }
    qsort(v5, v15, 0x10uLL, (int (__cdecl *)(const void *, const void *))compareCPNaiveBayesResult);
    if (*(_QWORD *)(a1 + 104))
    {
      v41 = 0;
      v42 = (_QWORD *)(a1 + 232);
      v43 = (_QWORD *)(a1 + 248);
      v44 = *(char **)(a1 + 240);
      do
      {
        v45 = (char *)&v5[2 * v41];
        v46 = *((_QWORD *)v45 + 1);
        v47 = *(_DWORD *)v45;
        if ((unint64_t)v44 >= *v43)
        {
          v48 = (uint64_t)&v44[-*v42] >> 4;
          if ((unint64_t)(v48 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v49 = *v43 - *v42;
          v50 = v49 >> 3;
          if (v49 >> 3 <= (unint64_t)(v48 + 1))
            v50 = v48 + 1;
          if ((unint64_t)v49 >= 0x7FFFFFFFFFFFFFF0)
            v51 = 0xFFFFFFFFFFFFFFFLL;
          else
            v51 = v50;
          if (v51)
            v52 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(a1 + 248, v51);
          else
            v52 = 0;
          v53 = &v52[16 * v48];
          *(_QWORD *)v53 = v46;
          *((_DWORD *)v53 + 2) = v47;
          *((_DWORD *)v53 + 3) = 0;
          v55 = *(char **)(a1 + 232);
          v54 = *(char **)(a1 + 240);
          v56 = v53;
          if (v54 != v55)
          {
            do
            {
              *((_OWORD *)v56 - 1) = *((_OWORD *)v54 - 1);
              v56 -= 16;
              v54 -= 16;
            }
            while (v54 != v55);
            v54 = (char *)*v42;
          }
          v44 = v53 + 16;
          *(_QWORD *)(a1 + 232) = v56;
          *(_QWORD *)(a1 + 240) = v53 + 16;
          *(_QWORD *)(a1 + 248) = &v52[16 * v51];
          if (v54)
            operator delete(v54);
        }
        else
        {
          *(_QWORD *)v44 = v46;
          *((_DWORD *)v44 + 2) = v47;
          *((_DWORD *)v44 + 3) = 0;
          v44 += 16;
        }
        *(_QWORD *)(a1 + 240) = v44;
        ++v41;
      }
      while (v41 != 10 && *(_QWORD *)(a1 + 104) > v41);
    }
    CPMLFeatureVector::setYHatProbList((uint64_t)a2, a1 + 232);
    *(_QWORD *)(a1 + 240) = *(_QWORD *)(a1 + 232);
    free(v5);
    return 0;
  }
  else
  {
    v38 = (pthread_mutex_t *)CPMLLog::getCPMLLog(0);
    CPMLLog::log(v38, CPML_LOG_DEBUG, "eval", "resultcardinality 0");
    return 0xFFFFFFFFLL;
  }
}

uint64_t compareCPNaiveBayesResult(double *a1, double *a2)
{
  double v2;
  double v3;

  v2 = a1[1];
  v3 = a2[1];
  if (v2 > v3)
    return 0xFFFFFFFFLL;
  if (v2 == v3)
    return 0;
  return v2 < v3;
}

uint64_t CPNaiveBayesV2Classifier::errorString(CPNaiveBayesV2Classifier *this)
{
  return 0;
}

_QWORD *CPNaiveBayesV2Classifier::updateMeanV2(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double *v4;
  double v5;
  double *v6;
  uint64_t v7;
  double v8;

  v1 = this[13];
  if (v1)
  {
    v2 = 0;
    v3 = this[20];
    do
    {
      if (v3)
      {
        v4 = *(double **)(this[16] + 8 * v2);
        v5 = (double)*(unint64_t *)(this[18] + 8 * v2);
        v6 = *(double **)(this[14] + 8 * v2);
        v7 = v3;
        do
        {
          v8 = *v4++;
          *v6++ = v8 / v5;
          --v7;
        }
        while (v7);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return this;
}

_QWORD *CPNaiveBayesV2Classifier::updateVarianceV2(_QWORD *this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double *v4;
  double v5;
  double *v6;
  uint64_t v7;
  double v8;

  v1 = this[13];
  if (v1)
  {
    v2 = 0;
    v3 = this[20];
    do
    {
      if (v3)
      {
        v4 = *(double **)(this[17] + 8 * v2);
        v5 = (double)(unint64_t)(*(_QWORD *)(this[18] + 8 * v2) - 1);
        v6 = *(double **)(this[15] + 8 * v2);
        v7 = v3;
        do
        {
          v8 = *v4++;
          *v6++ = v8 / v5;
          --v7;
        }
        while (v7);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return this;
}

void CPLogisticRegressionClassfier::Normalize(double **a1, _QWORD *a2)
{
  uint64_t v4;
  unint64_t v5;
  double **v6;
  double **v7;
  double **v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  double *v14;
  double *v15;
  double *v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  double *v21;
  double *v22;
  uint64_t v23;
  double *v24;
  double *v25;
  double *v26;
  double v27;
  double v28;
  double v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  unint64_t v35;
  double *v36;
  uint64_t v37;
  uint64_t v38;
  double *v39;
  double *v40;
  double v41;
  double v42;
  double v43;
  _QWORD *v44;
  _QWORD *v45;
  _QWORD *v46;
  _QWORD *v47;

  if (a2[1] != *a2)
  {
    v4 = *(_QWORD *)(*a2 + 8) - *(_QWORD *)*a2;
    v5 = (unint64_t)v4 >> 3;
    v6 = a1 + 34;
    std::valarray<double>::resize((uint64_t)(a1 + 34), (int)(v4 >> 3), 2.22507386e-308);
    v7 = a1 + 32;
    std::valarray<double>::resize((uint64_t)(a1 + 32), (int)(v4 >> 3), 1.79769313e308);
    v8 = a1 + 36;
    std::valarray<double>::resize((uint64_t)(a1 + 36), (int)(v4 >> 3), 0.0);
    v9 = *a2;
    v10 = a2[1];
    v11 = v10 - *a2;
    if (v10 != *a2)
    {
      v12 = 0;
      v13 = v11 >> 4;
      if (v13 <= 1)
        v13 = 1;
      do
      {
        if ((int)v5 >= 1)
        {
          v14 = *v6;
          v15 = *(double **)(v9 + 16 * v12);
          v16 = *v7;
          v17 = ((unint64_t)v4 >> 3);
          do
          {
            v18 = *v14;
            if (*v14 < *v15)
              v18 = *v15;
            *v14++ = v18;
            v19 = *v15++;
            v20 = v19;
            if (v19 >= *v16)
              v20 = *v16;
            *v16++ = v20;
            --v17;
          }
          while (v17);
        }
        ++v12;
      }
      while (v12 != v13);
    }
    v22 = a1[34];
    v21 = a1[35];
    v23 = v21 - v22;
    if (v23 != a1[37] - a1[36])
      std::valarray<double>::resize((uint64_t)(a1 + 36), v21 - v22, 0.0);
    if (v21 != v22)
    {
      v24 = *v8;
      v25 = *v6;
      v26 = *v7;
      do
      {
        v27 = *v25++;
        v28 = v27;
        v29 = *v26++;
        *v24++ = v28 - v29;
        --v23;
      }
      while (v23);
    }
    if ((int)v5 >= 1)
    {
      v30 = 0;
      do
      {
        if ((*v8)[v30 / 8] == 0.0)
        {
          v44 = (_QWORD *)MEMORY[0x24BEDB318];
          v45 = std::operator<<[abi:ne180100]<std::char_traits<char>>(MEMORY[0x24BEDB318], "normalization failed due to zero range");
          std::endl[abi:ne180100]<char,std::char_traits<char>>(v45);
          std::operator<<[abi:ne180100]<std::char_traits<char>>(v44, "min: ");
          v46 = (_QWORD *)std::ostream::operator<<();
          std::operator<<[abi:ne180100]<std::char_traits<char>>(v46, "\tmax: ");
          v47 = (_QWORD *)std::ostream::operator<<();
          std::endl[abi:ne180100]<char,std::char_traits<char>>(v47);
          exit(1);
        }
        v30 += 8;
      }
      while ((v4 & 0x7FFFFFFF8) != v30);
    }
    v31 = *a2;
    v32 = a2[1];
    v33 = v32 - *a2;
    if (v32 != *a2)
    {
      v34 = 0;
      v35 = v33 >> 4;
      if (v35 <= 1)
        v35 = 1;
      do
      {
        v36 = *(double **)(v31 + 16 * v34);
        v37 = *(_QWORD *)(v31 + 16 * v34 + 8) - (_QWORD)v36;
        if (v37)
        {
          v38 = v37 >> 3;
          v39 = *v7;
          v40 = *v8;
          do
          {
            v41 = *v39++;
            v42 = *v36 - v41;
            v43 = *v40++;
            *v36++ = v42 / v43;
            --v38;
          }
          while (v38);
        }
        ++v34;
      }
      while (v34 != v35);
    }
  }
}

void CPLogisticRegressionClassfier::CPLogisticRegressionClassfier(CPLogisticRegressionClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;
  int v7;
  uint64_t Iterator;
  int v9;
  CPMLFeatureVector *v10;
  char *v11;
  uint64_t RealVector;
  uint64_t *v13;
  uint64_t v14;
  unint64_t v15;
  _QWORD *v16;
  uint64_t v17;
  int YHat;
  int *v19;
  int *v20;
  int *v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  unint64_t v25;
  char *v26;
  int *v27;
  int v28;
  _DWORD *v29;
  unint64_t v30;
  uint64_t v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  uint64_t *v36;
  _QWORD *v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t *v40;
  uint64_t *v41;
  unint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  const std::locale::facet *v45;
  char v46;
  _QWORD *v47;
  std::locale::id *v48;
  char v49;
  _QWORD *v50;
  _QWORD *v51;
  const std::locale::facet *v52;
  uint64_t v53;
  _QWORD *v54;
  uint64_t v55;
  uint64_t v56;
  CPMLStatistics *var0;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  BOOL v61;
  uint64_t v62;
  uint64_t v63;
  CPMLCDB *v64;
  uint64_t *v65[3];
  uint64_t *v66;
  uint64_t *v67;
  _QWORD *v68;
  uint64_t v69;
  uint64_t v70;
  void *__p;
  int *v72;
  int *v73;
  void *v74;
  void *v75;
  void *v76;
  uint64_t v77;
  std::vector<int> v78;
  std::locale v79;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v6 = &off_24C255C38;
  *(_QWORD *)(v6 + 200) = 0;
  *(_QWORD *)(v6 + 208) = 0;
  *(_QWORD *)(v6 + 216) = 0;
  *(_OWORD *)(v6 + 240) = 0u;
  *(_OWORD *)(v6 + 256) = 0u;
  *(_OWORD *)(v6 + 272) = 0u;
  *(_OWORD *)(v6 + 288) = 0u;
  strcpy((char *)(v6 + 8), "1.0.0");
  __p = 0;
  v72 = 0;
  v73 = 0;
  v68 = 0;
  v69 = 0;
  v70 = 0;
  v7 = *((_DWORD *)a2->var0 + 31);
  v64 = a2;
  Iterator = CPMLCDB::getIterator(a2, 0, 0, 0);
  v9 = v7 - 1;
  while (1)
  {
    v10 = (CPMLFeatureVector *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
    if (!v10)
      break;
    v74 = 0;
    v75 = 0;
    if (v7 != 1)
    {
      if (v7 <= 0)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v11 = (char *)operator new(8 * v9);
      v74 = v11;
      bzero(v11, 8 * v9);
      v75 = &v11[8 * v7 - 8];
    }
    RealVector = CPMLFeatureVector::getRealVector(v10);
    v13 = *(uint64_t **)RealVector;
    v14 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
    if (v14)
    {
      v15 = v14 >> 3;
      v16 = v74;
      if (v15 <= 1)
        v15 = 1;
      do
      {
        v17 = *v13++;
        *v16++ = v17;
        --v15;
      }
      while (v15);
    }
    std::vector<std::valarray<double>>::push_back[abi:ne180100]((uint64_t *)&v68, (uint64_t **)&v74);
    YHat = (int)CPMLFeatureVector::getYHat(v10);
    v19 = v72;
    if (v72 >= v73)
    {
      v21 = (int *)__p;
      v22 = ((char *)v72 - (_BYTE *)__p) >> 2;
      v23 = v22 + 1;
      if ((unint64_t)(v22 + 1) >> 62)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v24 = (char *)v73 - (_BYTE *)__p;
      if (((char *)v73 - (_BYTE *)__p) >> 1 > v23)
        v23 = v24 >> 1;
      if ((unint64_t)v24 >= 0x7FFFFFFFFFFFFFFCLL)
        v25 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v25 = v23;
      if (v25)
      {
        v26 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v73, v25);
        v21 = (int *)__p;
        v19 = v72;
      }
      else
      {
        v26 = 0;
      }
      v27 = (int *)&v26[4 * v22];
      *v27 = YHat;
      v20 = v27 + 1;
      while (v19 != v21)
      {
        v28 = *--v19;
        *--v27 = v28;
      }
      __p = v27;
      v72 = v20;
      v73 = (int *)&v26[4 * v25];
      if (v21)
        operator delete(v21);
    }
    else
    {
      *v72 = YHat;
      v20 = v19 + 1;
    }
    v72 = v20;
    if (v74)
    {
      if (v75 != v74)
        v75 = (char *)v75 + (((_BYTE *)v74 - (_BYTE *)v75 + 7) & 0xFFFFFFFFFFFFFFF8);
      operator delete(v74);
    }
  }
  std::vector<std::vector<data_record_t>>::vector(&v66, 2uLL);
  CPLogisticRegressionClassfier::Normalize((double **)this, &v68);
  std::vector<int>::vector(&v78, 2uLL);
  v29 = __p;
  if (v72 != __p)
  {
    v30 = 0;
    v31 = v68[1] - *v68;
    v32 = (unint64_t)v31 >> 3;
    v33 = (int)(v31 >> 3);
    v34 = ((unint64_t)v31 >> 3);
    do
    {
      v75 = 0;
      v76 = 0;
      v77 = 0;
      LODWORD(v74) = v29[v30];
      v35 = (int)v74;
      ++v78.__begin_[(int)v74];
      std::vector<double>::resize((uint64_t)&v75, v33);
      if ((int)v32 >= 1)
      {
        v36 = (uint64_t *)v68[2 * v30];
        v37 = v75;
        v38 = v34;
        do
        {
          v39 = *v36++;
          *v37++ = v39;
          --v38;
        }
        while (v38);
      }
      v40 = &v66[3 * v35];
      v41 = v40 + 1;
      v42 = v40[1];
      if (v42 >= v40[2])
      {
        v43 = std::vector<data_record_t>::__push_back_slow_path<data_record_t const&>(v40, (uint64_t)&v74);
      }
      else
      {
        std::vector<data_record_t>::__construct_one_at_end[abi:ne180100]<data_record_t const&>((uint64_t)v40, (uint64_t)&v74);
        v43 = v42 + 32;
      }
      *v41 = v43;
      if (v75)
      {
        v76 = v75;
        operator delete(v75);
      }
      ++v30;
      v29 = __p;
    }
    while (v30 < ((char *)v72 - (_BYTE *)__p) >> 2);
  }
  v44 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Number of records in each response class:", 41);
  std::ios_base::getloc((const std::ios_base *)((char *)v44 + *(_QWORD *)(*v44 - 24)));
  v45 = std::locale::use_facet(&v79, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v45->__vftable[2].~facet_0)(v45, 10);
  std::locale::~locale(&v79);
  std::ostream::put();
  std::ostream::flush();
  v46 = 1;
  v47 = (_QWORD *)MEMORY[0x24BEDB318];
  v48 = (std::locale::id *)MEMORY[0x24BEDB350];
  do
  {
    v49 = v46;
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v47, (uint64_t)"num_obs[", 8);
    v50 = (_QWORD *)std::ostream::operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v50, (uint64_t)"]=", 2);
    v51 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v51 + *(_QWORD *)(*v51 - 24)));
    v52 = std::locale::use_facet(&v79, v48);
    ((void (*)(const std::locale::facet *, uint64_t))v52->__vftable[2].~facet_0)(v52, 10);
    std::locale::~locale(&v79);
    std::ostream::put();
    std::ostream::flush();
    v46 = 0;
  }
  while ((v49 & 1) != 0);
  if (v78.__begin_)
  {
    v78.__end_ = v78.__begin_;
    operator delete(v78.__begin_);
  }
  v54 = v68;
  v53 = v69;
  v56 = *v68;
  v55 = v68[1];
  memset(v65, 0, sizeof(v65));
  std::vector<std::vector<data_record_t>>::__init_with_size[abi:ne180100]<std::vector<data_record_t>*,std::vector<data_record_t>*>(v65, v66, v67, 0xAAAAAAAAAAAAAAABLL * (v67 - v66));
  CPLogisticRegressionClassfier::Init((uint64_t)this, v65, 1, 2, (unint64_t)(v55 - v56) >> 3, (unint64_t)(v53 - (_QWORD)v54) >> 4);
  v74 = v65;
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
  *((_QWORD *)this + 14) = 0;
  var0 = v64->var0;
  v58 = *((int *)v64->var0 + 31);
  *((_QWORD *)this + 12) = v58;
  *((_QWORD *)this + 13) = *((int *)var0 + 33);
  v59 = (uint64_t)(*((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3)) >> 3;
  *((_QWORD *)this + 15) = v59;
  v60 = (uint64_t)(*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2;
  *((_QWORD *)this + 16) = v60;
  *((_QWORD *)this + 18) = v58 + 1;
  *((_QWORD *)this + 17) = *((int *)var0 + 30);
  LODWORD(var0) = *(_DWORD *)(*((_QWORD *)var0 + 9) + 4 * *((int *)var0 + 32));
  v61 = (_DWORD)var0 == 0;
  if ((_DWORD)var0)
    v62 = v59;
  else
    v62 = v60;
  v63 = 120;
  if (v61)
    v63 = 128;
  *(_QWORD *)((char *)this + v63) = v62 - 1;
  *((_QWORD *)this + 22) = 0x4049000000000000;
  *((_QWORD *)this + 23) = 10000;
  CPLogisticRegressionClassfier::initializeLogisticRegressionMemory(this);
  v74 = &v66;
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
  v74 = &v68;
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v74);
  if (__p)
  {
    v72 = (int *)__p;
    operator delete(__p);
  }
}

void sub_209CD8094(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, char *a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, char a18, uint64_t a19, uint64_t a20,void *__p,uint64_t a22,uint64_t a23,char *a24,void *a25,uint64_t a26)
{
  void *v26;

  a24 = &a15;
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  a24 = &a18;
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  if (__p)
  {
    a22 = (uint64_t)__p;
    operator delete(__p);
  }
  std::valarray<double>::~valarray((uint64_t)v26 + 288);
  std::valarray<double>::~valarray((uint64_t)v26 + 272);
  std::valarray<double>::~valarray((uint64_t)v26 + 256);
  std::valarray<double>::~valarray(a9);
  a24 = a10;
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a24);
  CPModelClose(v26);
  _Unwind_Resume(a1);
}

void CPLogisticRegressionClassfier::Init(uint64_t a1, uint64_t **a2, int a3, int a4, int a5, int a6)
{
  uint64_t v11;
  double *v12;
  uint64_t v13;
  unint64_t v14;

  v11 = a1 + 200;
  if ((uint64_t **)v11 != a2)
    std::vector<std::vector<data_record_t>>::__assign_with_size[abi:ne180100]<std::vector<data_record_t>*,std::vector<data_record_t>*>(v11, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * (a2[1] - *a2));
  *(_DWORD *)(a1 + 192) = a3;
  *(_DWORD *)(a1 + 224) = a4;
  *(_DWORD *)(a1 + 228) = a5;
  *(_DWORD *)(a1 + 232) = a6;
  v12 = *(double **)(a1 + 240);
  v13 = *(_QWORD *)(a1 + 248) - (_QWORD)v12;
  if (v13 >= 1)
  {
    v14 = ((unint64_t)v13 >> 3) + 1;
    do
    {
      *v12++ = (double)(a5 + 1);
      --v14;
    }
    while (v14 > 1);
  }
}

void *CPLogisticRegressionClassfier::initializeLogisticRegressionMemory(CPLogisticRegressionClassfier *this)
{
  unint64_t v2;
  void *result;

  *((_QWORD *)this + 21) = malloc_type_calloc(*((_QWORD *)this + 17), 8uLL, 0x80040B8603338uLL);
  if (*((_QWORD *)this + 17))
  {
    v2 = 0;
    do
      *(_QWORD *)(*((_QWORD *)this + 21) + 8 * v2++) = malloc_type_calloc(*((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
    while (*((_QWORD *)this + 17) > v2);
  }
  *((_QWORD *)this + 19) = malloc_type_calloc(*((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
  result = malloc_type_calloc(*((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 20) = result;
  return result;
}

double CPLogisticRegressionClassfier::ComputeSingleLogProb(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  unsigned int v8;
  size_t v9;
  void *v10;
  uint64_t v11;
  uint64_t v12;
  double *v13;
  uint64_t v14;
  uint64_t v15;
  double *v16;
  long double v17;
  double v18;
  double *v19;
  uint64_t v20;
  double *v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  unsigned int v28;

  if (a3 == 1)
    return -0.0;
  if (a3 <= 0)
    std::__throw_bad_array_new_length[abi:ne180100]();
  v8 = a3 - 1;
  v9 = 8 * (a3 - 1);
  v10 = operator new(v9);
  bzero(v10, v9);
  v11 = 0;
  v12 = *a2;
  v13 = *(double **)(a1 + 8);
  v14 = a4 + 1;
  v28 = v8;
  v15 = v8;
  v16 = (double *)(v12 + 8);
  v17 = 1.0;
  do
  {
    v18 = *(double *)(v12 + 8 * v11 * v14);
    v19 = v16;
    v20 = a4;
    v21 = v13;
    if (a4 >= 1)
    {
      do
      {
        v22 = *v21++;
        v23 = v22;
        v24 = *v19++;
        v18 = v18 + v23 * v24;
        --v20;
      }
      while (v20);
    }
    *((double *)v10 + v11) = v18;
    v17 = v17 + exp(v18);
    ++v11;
    v16 += v14;
  }
  while (v11 != v15);
  if (v28 == a5)
  {
    v25 = -log(v17);
  }
  else
  {
    v26 = *((double *)v10 + a5);
    v25 = v26 - log(v17);
  }
  operator delete(v10);
  return v25;
}

double CPLogisticRegressionClassfier::ObjectiveFunction(uint64_t *a1, uint64_t *a2)
{
  uint64_t v2;
  int v3;
  uint64_t v6;
  uint64_t v7;
  double v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v2 = *a2;
  v3 = -1431655765 * ((a2[1] - *a2) >> 3);
  if (v3 < 1)
    return 0.0;
  v6 = 0;
  v7 = (*(_QWORD *)(*(_QWORD *)v2 + 16) - *(_QWORD *)(*(_QWORD *)v2 + 8)) >> 3;
  v8 = 0.0;
  do
  {
    v9 = *(_QWORD *)(v2 + 24 * v6);
    if (*(_QWORD *)(v2 + 24 * v6 + 8) != v9)
    {
      v10 = 0;
      v11 = 0;
      do
      {
        v8 = v8 + CPLogisticRegressionClassfier::ComputeSingleLogProb(v9 + v10, a1, v3, v7, v6);
        ++v11;
        v2 = *a2;
        v9 = *(_QWORD *)(*a2 + 24 * v6);
        v10 += 32;
      }
      while (v11 < (*(_QWORD *)(*a2 + 24 * v6 + 8) - v9) >> 5);
    }
    ++v6;
  }
  while (v6 != v3);
  return v8;
}

double CPLogisticRegressionClassfier::ObjectiveFunction0(double **a1, uint64_t **a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  double v10;
  uint64_t v11;
  double v12;
  double *v13;
  double v14;
  uint64_t v15;
  unint64_t v16;
  double *v17;
  double v18;
  double v19;
  double v20;
  long double v21;
  double v22;
  unint64_t v23;
  double *v24;
  uint64_t i;
  uint64_t *v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  double v31;
  uint64_t v32;
  double v33;
  double *v34;
  double v35;
  uint64_t v36;
  unint64_t v37;
  double *v38;
  double v39;
  double v40;
  double v41;
  double v42;
  long double v43;

  v4 = *a2;
  v5 = **a2;
  v6 = (*a2)[1] - v5;
  if (v6)
  {
    v7 = 0;
    v8 = v6 >> 5;
    v9 = (uint64_t)(*a1 + 1);
    v10 = **a1;
    if (v8 <= 1)
      v11 = 1;
    else
      v11 = v8;
    v12 = 0.0;
    do
    {
      v13 = *(double **)(v5 + 32 * v7 + 8);
      v14 = v10;
      v15 = *(_QWORD *)(v5 + 32 * v7 + 16) - (_QWORD)v13;
      if (v15)
      {
        v16 = v15 >> 3;
        if (v16 <= 1)
          v16 = 1;
        v17 = (double *)v9;
        v14 = v10;
        do
        {
          v18 = *v13++;
          v19 = v18;
          v20 = *v17++;
          v14 = v14 + v19 * v20;
          --v16;
        }
        while (v16);
      }
      v21 = exp(v14);
      v12 = v12 + log(v21 + 1.0);
      ++v7;
    }
    while (v7 != v11);
  }
  else
  {
    v12 = 0.0;
  }
  v22 = -v12;
  v23 = 0xAAAAAAAAAAAAAAABLL * (a2[1] - v4);
  if (v23 >= 2)
  {
    v24 = *a1;
    for (i = 1; i != v23; ++i)
    {
      v26 = &v4[3 * i];
      v27 = *v26;
      v28 = v26[1] - *v26;
      if (v28)
      {
        v29 = 0;
        v30 = v28 >> 5;
        v31 = *v24;
        if (v30 <= 1)
          v32 = 1;
        else
          v32 = v30;
        v33 = 0.0;
        do
        {
          v34 = *(double **)(v27 + 32 * v29 + 8);
          v35 = v31;
          v36 = *(_QWORD *)(v27 + 32 * v29 + 16) - (_QWORD)v34;
          if (v36)
          {
            v37 = v36 >> 3;
            if (v37 <= 1)
              v37 = 1;
            v38 = v24 + 1;
            v35 = v31;
            do
            {
              v39 = *v34++;
              v40 = v39;
              v41 = *v38++;
              v35 = v35 + v40 * v41;
              --v37;
            }
            while (v37);
          }
          v42 = v33 + v35;
          v43 = exp(v35);
          v33 = v42 - log(v43 + 1.0);
          ++v29;
        }
        while (v29 != v32);
      }
      else
      {
        v33 = 0.0;
      }
      v22 = v22 + v33;
    }
  }
  return v22;
}

void CPLogisticRegressionClassfier::ComputeSingleGradient(uint64_t a1, uint64_t *a2, int a3, int a4, int a5, uint64_t *a6)
{
  int v6;
  uint64_t v8;
  uint64_t v9;
  uint64_t v12;
  void *v13;
  uint64_t v14;
  double *v15;
  uint64_t v16;
  double *v17;
  double v18;
  double v19;
  double *v20;
  uint64_t v21;
  double *v22;
  double v23;
  double v24;
  double v25;
  long double v26;
  uint64_t v27;
  double *v28;
  double *v29;
  double v30;
  double *v31;
  uint64_t v32;
  double *v33;
  double v34;
  int v35;
  uint64_t v36;
  double *v37;
  uint64_t v38;
  double *v39;
  double v40;
  int v41;
  uint64_t v42;

  if (a5 < 0 || (v6 = a5, a3 <= a5))
    CPLogisticRegressionClassfier::ComputeSingleGradient();
  v8 = *a2;
  v9 = *a6;
  if (a2[1] - *a2 != a6[1] - *a6)
    CPLogisticRegressionClassfier::ComputeSingleGradient();
  v12 = (a3 - 1);
  if (a3 == 1)
  {
    v13 = 0;
  }
  else
  {
    v13 = operator new(8 * (int)v12);
    bzero(v13, 8 * (int)v12);
    if (a3 >= 2)
    {
      v41 = v6;
      v14 = 0;
      v42 = a1;
      v15 = *(double **)(a1 + 8);
      v16 = a4 + 1;
      v17 = (double *)(v8 + 8);
      v18 = 1.0;
      do
      {
        v19 = *(double *)(v8 + 8 * v14 * v16);
        v20 = v17;
        v21 = a4;
        v22 = v15;
        if (a4 >= 1)
        {
          do
          {
            v23 = *v22++;
            v24 = v23;
            v25 = *v20++;
            v19 = v19 + v24 * v25;
            --v21;
          }
          while (v21);
        }
        v26 = exp(v19);
        *((long double *)v13 + v14) = v26;
        v18 = v18 + v26;
        ++v14;
        v17 += v16;
      }
      while (v14 != v12);
      v27 = 0;
      a1 = v42;
      v28 = *(double **)(v42 + 8);
      v29 = (double *)(v9 + 8);
      v6 = v41;
      do
      {
        v30 = *((double *)v13 + v27);
        *(double *)(v9 + 8 * v27 * v16) = -v30 / v18;
        v31 = v29;
        v32 = a4;
        v33 = v28;
        if (a4 >= 1)
        {
          do
          {
            v34 = *v33++;
            *v31++ = -(v34 * v30) / v18;
            --v32;
          }
          while (v32);
        }
        ++v27;
        v29 += v16;
      }
      while (v27 != v12);
    }
  }
  if ((_DWORD)v12 != v6)
  {
    v35 = v6 + v6 * a4;
    *(double *)(v9 + 8 * v35) = *(double *)(v9 + 8 * v35) + 1.0;
    if (a4 >= 1)
    {
      v36 = v35;
      v37 = *(double **)(a1 + 8);
      v38 = a4;
      v39 = (double *)(v9 + 8 * v36 + 8);
      do
      {
        v40 = *v37++;
        *v39 = v40 + *v39;
        ++v39;
        --v38;
      }
      while (v38);
    }
  }
  if (v13)
    operator delete(v13);
}

void CPLogisticRegressionClassfier::ObjectiveFunctionGradient(uint64_t *a1, uint64_t **a2, uint64_t a3)
{
  double *v3;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t *v10;
  uint64_t *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  double *v21;
  uint64_t v22;
  unint64_t v23;
  double *v24;
  double v25;
  char *v26;
  char *v27;

  v3 = *(double **)a3;
  v4 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  v6 = *a1;
  v5 = a1[1];
  if (v4 != v5 - *a1)
    CPLogisticRegressionClassfier::ObjectiveFunctionGradient();
  v11 = *a2;
  v10 = a2[1];
  v12 = **a2;
  v14 = *(_QWORD *)(v12 + 8);
  v13 = *(_QWORD *)(v12 + 16);
  v26 = 0;
  v27 = 0;
  if (v5 == v6)
  {
    v15 = 0;
  }
  else
  {
    if ((v4 & 0x8000000000000000) != 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v15 = (char *)operator new(v4);
    v26 = v15;
    bzero(v15, v4);
    v27 = &v15[v4];
  }
  v16 = 0xAAAAAAAAAAAAAAABLL * (v10 - v11);
  if ((uint64_t)v4 >= 1)
    bzero(v3, 8 * ((v4 >> 3) - (v4 > 7)) + 8);
  if ((int)v16 >= 1)
  {
    v17 = 0;
    v18 = (unint64_t)(v13 - v14) >> 3;
    do
    {
      v19 = v11[3 * v17];
      if (v11[3 * v17 + 1] != v19)
      {
        v20 = 0;
        do
        {
          CPLogisticRegressionClassfier::ComputeSingleGradient(v19 + 32 * v20, a1, v16, v18, v17, (uint64_t *)&v26);
          v21 = *(double **)a3;
          v22 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
          if (v22)
          {
            v23 = v22 >> 3;
            if (v23 <= 1)
              v23 = 1;
            v24 = (double *)v15;
            do
            {
              v25 = *v24++;
              *v21 = v25 + *v21;
              ++v21;
              --v23;
            }
            while (v23);
          }
          ++v20;
          v11 = *a2;
          v19 = (*a2)[3 * v17];
        }
        while (v20 < ((*a2)[3 * v17 + 1] - v19) >> 5);
      }
      ++v17;
    }
    while (v17 != v16);
  }
  if (v15)
    operator delete(v15);
}

void sub_209CD8B04(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void CPLogisticRegressionClassfier::ObjectiveFunctionGradient0(uint64_t a1, uint64_t **a2, void **a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t *v7;
  uint64_t *v8;
  unint64_t v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  double *v14;
  double *v15;
  uint64_t v16;
  double *v17;
  double v18;
  uint64_t v19;
  uint64_t v20;
  double v21;
  double *v22;
  double *v23;
  uint64_t v24;
  double *v25;
  double v26;
  double v27;
  double v28;
  double v29;
  char *v30;
  double *v31;
  uint64_t v32;
  double *v33;
  double v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void **v39;
  void *__p;
  double *v41;
  uint64_t v42;

  v5 = (_BYTE *)a3[1] - (_BYTE *)*a3;
  if (v5 >= 1)
    bzero(*a3, 8 * (((unint64_t)v5 >> 3) - ((unint64_t)v5 > 7)) + 8);
  v6 = (*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 3;
  v8 = *a2;
  v7 = a2[1];
  if (0xAAAAAAAAAAAAAAABLL * (v7 - *a2) < 2)
    goto LABEL_15;
  v9 = 1;
  do
  {
    v10 = &v8[3 * v9];
    v11 = *v10;
    v12 = v10[1];
    v13 = v12 - *v10;
    *(double *)*a3 = *(double *)*a3 + (double)(unint64_t)(v13 >> 5);
    if (!v13)
      goto LABEL_14;
    do
    {
      LODWORD(v39) = *(_DWORD *)v11;
      v41 = 0;
      v42 = 0;
      __p = 0;
      std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, *(const void **)(v11 + 8), *(_QWORD *)(v11 + 16), (uint64_t)(*(_QWORD *)(v11 + 16) - *(_QWORD *)(v11 + 8)) >> 3);
      v14 = (double *)__p;
      if ((int)v6 < 2)
      {
        if (!__p)
          goto LABEL_12;
      }
      else
      {
        v15 = (double *)((char *)*a3 + 8);
        v16 = (v6 - 1);
        v17 = (double *)__p;
        do
        {
          v18 = *v17++;
          *v15 = v18 + *v15;
          ++v15;
          --v16;
        }
        while (v16);
      }
      v41 = v14;
      operator delete(v14);
LABEL_12:
      v11 += 32;
    }
    while (v11 != v12);
    v8 = *a2;
    v7 = a2[1];
LABEL_14:
    ++v9;
  }
  while (0xAAAAAAAAAAAAAAABLL * (v7 - v8) > v9);
LABEL_15:
  if (v8 == v7)
    return;
  while (2)
  {
    v36 = 0;
    v37 = 0;
    v38 = 0;
    std::vector<data_record_t>::__init_with_size[abi:ne180100]<data_record_t*,data_record_t*>(&v36, *v8, v8[1], (v8[1] - *v8) >> 5);
    v20 = v36;
    v19 = v37;
    while (2)
    {
      if (v20 != v19)
      {
        LODWORD(v39) = *(_DWORD *)v20;
        v41 = 0;
        v42 = 0;
        __p = 0;
        std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&__p, *(const void **)(v20 + 8), *(_QWORD *)(v20 + 16), (uint64_t)(*(_QWORD *)(v20 + 16) - *(_QWORD *)(v20 + 8)) >> 3);
        v21 = **(double **)a1;
        v22 = (double *)__p;
        if ((int)v6 >= 2)
        {
          v23 = (double *)(*(_QWORD *)a1 + 8);
          v24 = (v6 - 1);
          v25 = (double *)__p;
          do
          {
            v26 = *v25++;
            v27 = v26;
            v28 = *v23++;
            v21 = v21 + v27 * v28;
            --v24;
          }
          while (v24);
        }
        v29 = exp(v21);
        v30 = (char *)*a3;
        *(double *)*a3 = *(double *)*a3 - v29 / (v29 + 1.0);
        if ((int)v6 < 2)
        {
          if (v22)
            goto LABEL_26;
        }
        else
        {
          v31 = (double *)(v30 + 8);
          v32 = (v6 - 1);
          v33 = v22;
          do
          {
            v34 = *v33++;
            *v31 = *v31 - v29 * v34 / (v29 + 1.0);
            ++v31;
            --v32;
          }
          while (v32);
LABEL_26:
          v41 = v22;
          operator delete(v22);
        }
        v20 += 32;
        continue;
      }
      break;
    }
    v39 = (void **)&v36;
    std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&v39);
    v8 += 3;
    if (v8 != v7)
      continue;
    break;
  }
}

void sub_209CD8DC0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, char a10, uint64_t a11, uint64_t a12, void **a13)
{
  a13 = (void **)&a10;
  std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&a13);
  _Unwind_Resume(a1);
}

void CPLogisticRegressionClassfier::ComputeSingleHessian(uint64_t a1, uint64_t *a2, int a3, int a4, double **a5)
{
  double *v5;
  int v6;
  uint64_t v9;
  int v10;
  unsigned int v11;
  size_t v12;
  char *v13;
  uint64_t v14;
  double *v15;
  double v16;
  double v17;
  double *v18;
  uint64_t v19;
  double *v20;
  double v21;
  double v22;
  double v23;
  long double v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  double *v28;
  uint64_t v29;
  double v30;
  int v31;
  double *v32;
  double v33;
  uint64_t v34;
  double v35;
  double *v36;
  uint64_t v37;
  double *v38;
  uint64_t v39;
  double *v40;
  int v41;
  uint64_t v42;
  int v43;
  double *v44;
  double v45;
  double *v46;
  uint64_t v47;

  v47 = *a2;
  v5 = *a5;
  if (((a2[1] - v47) >> 3) * ((a2[1] - v47) >> 3) != a5[1] - *a5)
    CPLogisticRegressionClassfier::ComputeSingleHessian();
  v6 = a3 - 1;
  if (a3 != 1)
  {
    if (a3 <= 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v9 = (a4 + 1);
    v10 = v9 * v6;
    v11 = a3 - 1;
    v12 = 8 * v6;
    v13 = (char *)operator new(v12);
    bzero(v13, v12);
    v14 = 0;
    v46 = *(double **)(a1 + 8);
    v15 = (double *)(v47 + 8);
    v16 = 1.0;
    do
    {
      v17 = *(double *)(v47 + 8 * v14 * (int)v9);
      v18 = v15;
      v19 = a4;
      v20 = v46;
      if (a4 >= 1)
      {
        do
        {
          v21 = *v20++;
          v22 = v21;
          v23 = *v18++;
          v17 = v17 + v22 * v23;
          --v19;
        }
        while (v19);
      }
      v24 = exp(v17);
      *(long double *)&v13[8 * v14] = v24;
      v16 = v16 + v24;
      ++v14;
      v15 += (int)v9;
    }
    while (v14 != v11);
    v25 = 0;
    do
    {
      *(double *)&v13[v25] = *(double *)&v13[v25] / v16;
      v25 += 8;
    }
    while (8 * v11 != v25);
    v26 = 0;
    v27 = v10 + 1;
    v28 = v5;
    do
    {
      v29 = 0;
      v30 = *(double *)&v13[8 * v26];
      v31 = v27;
      v32 = v28;
      do
      {
        if (v26 == v29)
          v33 = v30;
        else
          v33 = 0.0;
        if ((a4 & 0x80000000) == 0)
        {
          v34 = 0;
          v35 = v30 * *(double *)&v13[8 * v29] - v33;
          v36 = v32;
          do
          {
            v37 = v9;
            v38 = v36;
            do
            {
              *v38 = v35;
              v38 += v10;
              --v37;
            }
            while (v37);
            ++v34;
            ++v36;
          }
          while (v34 != v9);
          if (a4 >= 1)
          {
            v39 = 0;
            v40 = *(double **)(a1 + 8);
            v41 = v31;
            do
            {
              v42 = a4;
              v43 = v41;
              v44 = v40;
              do
              {
                v45 = *v44++;
                v5[v43] = v5[v43] * (v40[v39] * v45);
                v43 += v10;
                --v42;
              }
              while (v42);
              ++v39;
              ++v41;
            }
            while (v39 != a4);
          }
        }
        ++v29;
        v32 += (int)v9 * (uint64_t)v10;
        v31 += v11 * v9 * v9;
      }
      while (v29 != v11);
      ++v26;
      v28 += (int)v9;
      v27 += v9;
    }
    while (v26 != v11);
    operator delete(v13);
  }
}

void CPLogisticRegressionClassfier::ObjectiveFunctionHessian(uint64_t *a1, uint64_t **a2, double **a3)
{
  uint64_t *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  double *v11;
  double *v12;
  size_t v13;
  double *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  double *v20;
  uint64_t v21;
  unint64_t v22;
  double *v23;
  double v24;
  double *v25;
  char *v26;

  v7 = *a2;
  v6 = a2[1];
  v8 = **a2;
  v10 = *(_QWORD *)(v8 + 8);
  v9 = *(_QWORD *)(v8 + 16);
  v12 = *a3;
  v11 = a3[1];
  v25 = 0;
  v26 = 0;
  v13 = (char *)v11 - (char *)v12;
  if (v11 == v12)
  {
    v14 = 0;
  }
  else
  {
    if ((v13 & 0x8000000000000000) != 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v14 = (double *)operator new((char *)v11 - (char *)v12);
    v25 = v14;
    bzero(v14, v13);
    v26 = (char *)v14 + v13;
  }
  v15 = 0xAAAAAAAAAAAAAAABLL * (v6 - v7);
  if ((uint64_t)v13 >= 1)
    bzero(v12, 8 * ((v13 >> 3) - (v13 > 7)) + 8);
  if ((int)v15 >= 1)
  {
    v16 = 0;
    v17 = (unint64_t)(v9 - v10) >> 3;
    do
    {
      v18 = v7[3 * v16];
      if (v7[3 * v16 + 1] != v18)
      {
        v19 = 0;
        do
        {
          CPLogisticRegressionClassfier::ComputeSingleHessian(v18 + 32 * v19, a1, v15, v17, &v25);
          v20 = *a3;
          v21 = (char *)a3[1] - (char *)*a3;
          if (v21)
          {
            v22 = v21 >> 3;
            if (v22 <= 1)
              v22 = 1;
            v23 = v14;
            do
            {
              v24 = *v23++;
              *v20 = v24 + *v20;
              ++v20;
              --v22;
            }
            while (v22);
          }
          ++v19;
          v7 = *a2;
          v18 = (*a2)[3 * v16];
        }
        while (v19 < ((*a2)[3 * v16 + 1] - v18) >> 5);
      }
      ++v16;
    }
    while (v16 != v15);
  }
  if (v14)
    operator delete(v14);
}

void sub_209CD9200(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

void CPLogisticRegressionClassfier::ObjectiveFunctionHessian0(uint64_t a1, uint64_t **a2, uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD *v12;
  const std::locale::facet *v13;
  uint64_t *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double v19;
  double *v20;
  double *v21;
  uint64_t v22;
  double *v23;
  double v24;
  double v25;
  double v26;
  long double v27;
  double v28;
  double *v29;
  uint64_t v30;
  double *v31;
  double *v32;
  uint64_t v33;
  double v34;
  double v35;
  double *v36;
  double *v37;
  uint64_t v38;
  double *v39;
  double v40;
  double v41;
  uint64_t *v42;
  uint64_t *v43;
  uint64_t v44;
  std::locale v45;
  double *v46;
  double *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v6 = *(_QWORD *)(a3 + 8) - *(_QWORD *)a3;
  if (v6 >= 1)
    bzero(*(void **)a3, 8 * (((unint64_t)v6 >> 3) - ((unint64_t)v6 > 7)) + 8);
  v7 = *(_QWORD *)(a1 + 8) - *(_QWORD *)a1;
  v8 = (unint64_t)v7 >> 3;
  v9 = ((unint64_t)v7 >> 3) - 1;
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"num_predictor = ", 16);
  v10 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
  v11 = std::locale::use_facet(&v45, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
  std::locale::~locale(&v45);
  std::ostream::put();
  std::ostream::flush();
  std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"hessian size = ", 15);
  v12 = (_QWORD *)std::ostream::operator<<();
  std::ios_base::getloc((const std::ios_base *)((char *)v12 + *(_QWORD *)(*v12 - 24)));
  v13 = std::locale::use_facet(&v45, MEMORY[0x24BEDB350]);
  ((void (*)(const std::locale::facet *, uint64_t))v13->__vftable[2].~facet_0)(v13, 10);
  std::locale::~locale(&v45);
  std::ostream::put();
  std::ostream::flush();
  v14 = *a2;
  v42 = a2[1];
  if (*a2 != v42)
  {
    v15 = (int)(v7 >> 3);
    v16 = 8 * v15;
    v44 = 8 * v15 + 8;
    do
    {
      v49 = 0;
      v50 = 0;
      v51 = 0;
      v43 = v14;
      std::vector<data_record_t>::__init_with_size[abi:ne180100]<data_record_t*,data_record_t*>(&v49, *v14, v14[1], (v14[1] - *v14) >> 5);
      v17 = v49;
      v18 = v50;
      while (v17 != v18)
      {
        LODWORD(v45.__locale_) = *(_DWORD *)v17;
        v47 = 0;
        v48 = 0;
        v46 = 0;
        std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(&v46, *(const void **)(v17 + 8), *(_QWORD *)(v17 + 16), (uint64_t)(*(_QWORD *)(v17 + 16) - *(_QWORD *)(v17 + 8)) >> 3);
        v19 = **(double **)a1;
        v20 = v46;
        if ((int)v8 >= 2)
        {
          v21 = (double *)(*(_QWORD *)a1 + 8);
          v22 = v9;
          v23 = v46;
          do
          {
            v24 = *v23++;
            v25 = v24;
            v26 = *v21++;
            v19 = v19 + v25 * v26;
            --v22;
          }
          while (v22);
        }
        v27 = exp(v19);
        v28 = v27 / ((v27 + 1.0) * (v27 + 1.0));
        v29 = *(double **)a3;
        **(double **)a3 = **(double **)a3 - v28;
        if ((int)v8 < 2)
        {
          if (!v20)
            goto LABEL_18;
        }
        else
        {
          v30 = 0;
          v31 = (double *)((char *)v29 + v44);
          v32 = (double *)((char *)v29 + v44);
          do
          {
            v33 = v30;
            v34 = v20[v30++];
            v35 = v29[v30] - v34 * v28;
            v29[v30] = v35;
            v29[v30 * v15] = v35;
            v36 = v31;
            v37 = v32;
            v38 = v9;
            v39 = v20;
            do
            {
              v40 = *v39++;
              v41 = *v36 + -(v40 * v20[v33]) * v28;
              *v36++ = v41;
              *v37 = v41;
              v37 = (double *)((char *)v37 + v16);
              --v38;
            }
            while (v38);
            ++v32;
            v31 = (double *)((char *)v31 + v16);
          }
          while (v30 != v9);
        }
        v47 = v20;
        operator delete(v20);
LABEL_18:
        v17 += 32;
      }
      v45.__locale_ = (std::locale::__imp *)&v49;
      std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100]((void ***)&v45);
      v14 = v43 + 3;
    }
    while (v43 + 3 != v42);
  }
}

void sub_209CD952C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, std::locale a12, uint64_t a13, uint64_t a14, uint64_t a15, char a16)
{
  std::locale::~locale(&a12);
  _Unwind_Resume(a1);
}

uint64_t CPLogisticRegressionClassfier::Evaluate(uint64_t a1, double **a2)
{
  int v2;
  double *v3;
  double *v4;
  double *v5;
  double v6;
  double *v7;
  double v8;
  double v9;
  double v10;
  uint64_t result;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double *v16;
  uint64_t v17;
  double *v18;
  uint64_t v19;
  unsigned int v20;
  double v21;
  double v22;
  double *v23;
  double *v24;
  double v25;
  double v26;
  double v27;

  v2 = *(_DWORD *)(a1 + 224);
  if (v2 == 2)
  {
    v3 = *a2;
    v4 = a2[1];
    v5 = *(double **)(a1 + 240);
    v6 = *v5;
    if (*a2 != v4)
    {
      v7 = v5 + 1;
      do
      {
        v8 = *v3++;
        v9 = v8;
        v10 = *v7++;
        v6 = v6 + v9 * v10;
      }
      while (v3 != v4);
    }
    return v6 <= 0.0;
  }
  else
  {
    if (v2 < 2)
      goto LABEL_18;
    v12 = 0;
    v13 = (v2 - 1);
    v14 = *(int *)(a1 + 228);
    v15 = v14 + 1;
    v16 = a2[1];
    v17 = *(_QWORD *)(a1 + 240);
    v18 = (double *)(v17 + 8);
    v19 = 8 * v14 + 8;
    v20 = -1;
    v21 = 2.22507386e-308;
    do
    {
      v22 = *(double *)(v17 + 8 * v12 * v15);
      if (*a2 != v16)
      {
        v23 = v18;
        v24 = *a2;
        do
        {
          v25 = *v24++;
          v26 = v25;
          v27 = *v23++;
          v22 = v22 + v26 * v27;
        }
        while (v24 != v16);
      }
      if (v22 > v21)
      {
        v21 = v22;
        v20 = v12;
      }
      ++v12;
      v18 = (double *)((char *)v18 + v19);
    }
    while (v12 != v13);
    result = v21 >= 0.0 ? v20 : v13;
    if ((_DWORD)result == -1)
LABEL_18:
      CPLogisticRegressionClassfier::Evaluate();
  }
  return result;
}

uint64_t CPLogisticRegressionClassfier::Serialize(uint64_t a1)
{
  unint64_t v2;
  _QWORD *v4;
  uint64_t v5;
  _BYTE v6[408];
  _QWORD v7[20];

  v7[19] = *MEMORY[0x24BDAC8D0];
  std::ofstream::basic_ofstream(&v5);
  if ((v6[*(_QWORD *)(v5 - 24) + 24] & 5) != 0)
  {
    v4 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB310], (uint64_t)"cannot open output file", 23);
    std::endl[abi:ne180100]<char,std::char_traits<char>>(v4);
    exit(1);
  }
  std::ostream::operator<<();
  if (*(_QWORD *)(a1 + 248) - *(_QWORD *)(a1 + 240) >= 9uLL)
  {
    v2 = 1;
    do
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(&v5, (uint64_t)" ", 1);
      std::ostream::operator<<();
      ++v2;
    }
    while (v2 < (uint64_t)(*(_QWORD *)(a1 + 248) - *(_QWORD *)(a1 + 240)) >> 3);
  }
  v5 = *MEMORY[0x24BEDB7E8];
  *(_QWORD *)&v6[*(_QWORD *)(v5 - 24) - 8] = *(_QWORD *)(MEMORY[0x24BEDB7E8] + 24);
  MEMORY[0x20BD187C4](v6);
  std::ostream::~ostream();
  return MEMORY[0x20BD188B4](v7);
}

void sub_209CD9788(_Unwind_Exception *exception_object)
{
  _Unwind_Resume(exception_object);
}

uint64_t CPLogisticRegressionClassfier::Deserialize(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;
  unint64_t v4;
  _QWORD *v6;
  _QWORD v7[2];
  _BYTE v8[408];
  _QWORD v9[20];

  v9[19] = *MEMORY[0x24BDAC8D0];
  std::ifstream::basic_ifstream(v7);
  if ((v8[*(_QWORD *)(v7[0] - 24) + 16] & 5) != 0)
  {
    v6 = std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB310], (uint64_t)"cannot open input file", 22);
    std::endl[abi:ne180100]<char,std::char_traits<char>>(v6);
    exit(1);
  }
  v2 = *(_QWORD *)(a1 + 240);
  if (*(_QWORD *)(a1 + 248) != v2)
  {
    v3 = 0;
    v4 = 0;
    do
    {
      MEMORY[0x20BD187DC](v7, v2 + v3);
      ++v4;
      v2 = *(_QWORD *)(a1 + 240);
      v3 += 8;
    }
    while (v4 < (*(_QWORD *)(a1 + 248) - v2) >> 3);
  }
  v7[0] = *MEMORY[0x24BEDB7E0];
  *(_QWORD *)((char *)v7 + *(_QWORD *)(v7[0] - 24)) = *(_QWORD *)(MEMORY[0x24BEDB7E0] + 24);
  MEMORY[0x20BD187C4](v8);
  std::istream::~istream();
  return MEMORY[0x20BD188B4](v9);
}

void sub_209CD98C8(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::ifstream::~ifstream((uint64_t *)va);
  _Unwind_Resume(a1);
}

void CPLogisticRegressionClassfier::Train(CPLogisticRegressionClassfier *this)
{
  int v2;
  uint64_t *v3;
  uint64_t *v4;
  uint64_t v5;
  _QWORD *v6;
  _QWORD *v7;
  const std::locale::facet *v8;
  _QWORD *v9;
  _QWORD *v10;
  const std::locale::facet *v11;
  _QWORD *v12;
  _QWORD *v13;
  const std::locale::facet *v14;
  _QWORD *v15;
  _QWORD *v16;
  const std::locale::facet *v17;
  int v18;
  int v19;
  int v20;
  _BYTE *v21;
  _BYTE *v22;
  _QWORD *v23;
  const std::locale::facet *v24;
  unint64_t v25;
  void *v26[2];
  __int128 v27;
  void (*v28)(uint64_t *, uint64_t **, double **);
  char *v29;
  void *__p;
  _BYTE *v31;
  std::locale v32;
  double *v33;
  double *v34;
  _BYTE *v35;
  _BYTE *v36;
  uint64_t *v37;
  uint64_t *v38;

  v2 = *((_DWORD *)this + 56) - 1 + (*((_DWORD *)this + 56) - 1) * *((_DWORD *)this + 57);
  v37 = 0;
  v38 = 0;
  if (v2)
  {
    if (v2 < 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v3 = (uint64_t *)operator new(8 * v2);
    v37 = v3;
    bzero(v3, 8 * v2);
    v4 = &v3[v2];
    v38 = v4;
  }
  else
  {
    v4 = 0;
    v3 = 0;
  }
  v5 = (char *)v4 - (char *)v3;
  if (v5 >= 1)
    memset_pattern16(v3, &unk_209D00180, 8 * (((unint64_t)v5 >> 3) - ((unint64_t)v5 > 7)) + 8);
  if (*((int *)this + 48) >= 2)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Initial objective function for beta=", 36);
    v6 = (_QWORD *)operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v6, (uint64_t)" is ", 4);
    CPLogisticRegressionClassfier::ObjectiveFunction((uint64_t *)&v37, (uint64_t *)this + 25);
    v7 = (_QWORD *)std::ostream::operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v7 + *(_QWORD *)(*v7 - 24)));
    v8 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v8->__vftable[2].~facet_0)(v8, 10);
    std::locale::~locale(&v32);
    std::ostream::put();
    std::ostream::flush();
    v2 = *((_DWORD *)this + 56) - 1 + (*((_DWORD *)this + 56) - 1) * *((_DWORD *)this + 57);
  }
  CoreOptimization::gradient_t::gradient_t((CoreOptimization::gradient_t *)&v35, v2);
  CPLogisticRegressionClassfier::ObjectiveFunctionGradient((uint64_t *)&v37, (uint64_t **)this + 25, (uint64_t)&v35);
  if (*((int *)this + 48) >= 2)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Initial Gradient for beta=", 26);
    v9 = (_QWORD *)operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v9, (uint64_t)" is ", 4);
    v10 = (_QWORD *)operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v10 + *(_QWORD *)(*v10 - 24)));
    v11 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 10);
    std::locale::~locale(&v32);
    std::ostream::put();
    std::ostream::flush();
  }
  v33 = 0;
  v34 = 0;
  std::valarray<double>::resize((uint64_t)&v33, (*((_DWORD *)this + 56) - 1 + (*((_DWORD *)this + 56) - 1) * *((_DWORD *)this + 57))* (*((_DWORD *)this + 56) - 1 + (*((_DWORD *)this + 56) - 1) * *((_DWORD *)this + 57)), 0.0);
  CPLogisticRegressionClassfier::ObjectiveFunctionHessian((uint64_t *)&v37, (uint64_t **)this + 25, &v33);
  if (*((int *)this + 48) >= 2)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Initial Hessian for beta=", 25);
    v12 = (_QWORD *)operator<<();
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v12, (uint64_t)" is ", 4);
    v13 = (_QWORD *)operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v13 + *(_QWORD *)(*v13 - 24)));
    v14 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v14->__vftable[2].~facet_0)(v14, 10);
    std::locale::~locale(&v32);
    std::ostream::put();
    std::ostream::flush();
    if (*((int *)this + 48) >= 2)
    {
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Initial objective function for beta=", 36);
      v15 = (_QWORD *)operator<<();
      std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(v15, (uint64_t)" is ", 4);
      CPLogisticRegressionClassfier::ObjectiveFunction((uint64_t *)&v37, (uint64_t *)this + 25);
      v16 = (_QWORD *)std::ostream::operator<<();
      std::ios_base::getloc((const std::ios_base *)((char *)v16 + *(_QWORD *)(*v16 - 24)));
      v17 = std::locale::use_facet(&v32, MEMORY[0x24BEDB350]);
      ((void (*)(const std::locale::facet *, uint64_t))v17->__vftable[2].~facet_0)(v17, 10);
      std::locale::~locale(&v32);
      std::ostream::put();
      std::ostream::flush();
    }
  }
  v19 = *((_DWORD *)this + 57);
  v18 = *((_DWORD *)this + 58);
  v20 = *((_DWORD *)this + 56);
  std::valarray<double>::valarray(&__p, &v37);
  *(_QWORD *)&v27 = CPLogisticRegressionClassfier::ObjectiveFunction;
  *((_QWORD *)&v27 + 1) = CPLogisticRegressionClassfier::ObjectiveFunctionGradient;
  v28 = CPLogisticRegressionClassfier::ObjectiveFunctionHessian;
  v29 = (char *)this + 200;
  CoreOptimization::BFGS::BFGS((uint64_t)&v32, (uint64_t **)&__p, &v27, 1, 1.0 / (double)((v20 - 1) * v18 + (v20 - 1) * v18 * v19));
  if (__p)
  {
    if (v31 != __p)
      v31 += ((_BYTE *)__p - v31 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(__p);
    __p = 0;
    v31 = 0;
  }
  CoreOptimization::BFGS::Optimize((CoreOptimization::BFGS *)&v32);
  CoreOptimization::BFGS::GetSolution((CoreOptimization::BFGS *)&v32);
  v21 = (_BYTE *)*((_QWORD *)this + 30);
  if (v21)
  {
    v22 = (_BYTE *)*((_QWORD *)this + 31);
    if (v22 != v21)
      *((_QWORD *)this + 31) = &v22[(v21 - v22 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v21);
    *((_QWORD *)this + 30) = 0;
    *((_QWORD *)this + 31) = 0;
  }
  *((_OWORD *)this + 15) = *(_OWORD *)v26;
  if (*((int *)this + 48) >= 1)
  {
    std::__put_character_sequence[abi:ne180100]<char,std::char_traits<char>>(MEMORY[0x24BEDB318], (uint64_t)"Solution: ", 10);
    v23 = (_QWORD *)operator<<();
    std::ios_base::getloc((const std::ios_base *)((char *)v23 + *(_QWORD *)(*v23 - 24)));
    v24 = std::locale::use_facet((const std::locale *)v26, MEMORY[0x24BEDB350]);
    ((void (*)(const std::locale::facet *, uint64_t))v24->__vftable[2].~facet_0)(v24, 10);
    std::locale::~locale((std::locale *)v26);
    std::ostream::put();
    std::ostream::flush();
  }
  v25 = *((int *)this + 56) - 1 + (*((int *)this + 56) - 1) * *((int *)this + 57);
  v26[0] = 0;
  v26[1] = 0;
  std::valarray<double>::resize((uint64_t)v26, v25, 1.0);
  if (v26[0])
  {
    if (v26[1] != v26[0])
      v26[1] = (char *)v26[1] + (((char *)v26[0] - (char *)v26[1] + 7) & 0xFFFFFFFFFFFFFFF8);
    operator delete(v26[0]);
  }
  CoreOptimization::BFGS::~BFGS((CoreOptimization::BFGS *)&v32);
  if (v33)
  {
    if (v34 != v33)
      v34 = (double *)((char *)v34 + (((char *)v33 - (char *)v34 + 7) & 0xFFFFFFFFFFFFFFF8));
    operator delete(v33);
  }
  if (v35)
  {
    if (v36 != v35)
      v36 += (v35 - v36 + 7) & 0xFFFFFFFFFFFFFFF8;
    operator delete(v35);
  }
  if (v37)
  {
    if (v38 != v37)
      v38 = (uint64_t *)((char *)v38 + (((char *)v37 - (char *)v38 + 7) & 0xFFFFFFFFFFFFFFF8));
    operator delete(v37);
  }
}

void sub_209CD9EC8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, std::locale a17)
{
  uint64_t v17;
  _BYTE *v19;
  _BYTE *v20;
  _BYTE *v21;
  _BYTE *v22;
  _BYTE *v23;
  _BYTE *v24;

  std::locale::~locale(&a17);
  v19 = *(_BYTE **)(v17 - 112);
  if (v19)
  {
    v20 = *(_BYTE **)(v17 - 104);
    if (v20 != v19)
      *(_QWORD *)(v17 - 104) = &v20[(v19 - v20 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v19);
  }
  v21 = *(_BYTE **)(v17 - 88);
  if (v21)
  {
    v22 = *(_BYTE **)(v17 - 80);
    if (v22 != v21)
      *(_QWORD *)(v17 - 80) = &v22[(v21 - v22 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v21);
  }
  v23 = *(_BYTE **)(v17 - 64);
  if (v23)
  {
    v24 = *(_BYTE **)(v17 - 56);
    if (v24 != v23)
      *(_QWORD *)(v17 - 56) = &v24[(v23 - v24 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v23);
  }
  _Unwind_Resume(a1);
}

void CPLogisticRegressionClassfier::CPLogisticRegressionClassfier(CPLogisticRegressionClassfier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v5 = &off_24C255C38;
  *(_QWORD *)(v5 + 200) = 0;
  *(_QWORD *)(v5 + 208) = 0;
  *(_QWORD *)(v5 + 216) = 0;
  *(_OWORD *)(v5 + 240) = 0u;
  v6 = v5 + 240;
  v7 = v5 + 256;
  v8 = v5 + 272;
  v9 = v5 + 288;
  *(_OWORD *)(v5 + 256) = 0u;
  *(_OWORD *)(v5 + 272) = 0u;
  *(_OWORD *)(v5 + 288) = 0u;
  (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, v5 + 8, "version", 5, 0);
  v10 = 0;
  (*((void (**)(CPMLSerialization *, unint64_t *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, &v10, "min_predictors_length", 1, 0);
  std::valarray<double>::resize(v7, v10, 0.0);
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), *((_QWORD *)this + 32), "min_predictors_", v10, 0);
  (*((void (**)(CPMLSerialization *, unint64_t *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, &v10, "max_predictors_length", 1, 0);
  std::valarray<double>::resize(v8, v10, 0.0);
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), *((_QWORD *)this + 34), "max_predictors_", v10, 0);
  (*((void (**)(CPMLSerialization *, unint64_t *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, &v10, "range_predictors_length", 1, 0);
  std::valarray<double>::resize(v9, v10, 0.0);
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), *((_QWORD *)this + 36), "range_predictors_", v10, 0);
  (*((void (**)(CPMLSerialization *, unint64_t *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, &v10, "solution_length", 1, 0);
  std::valarray<double>::resize(v6, v10, 0.0);
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), *((_QWORD *)this + 30), "solution_", v10, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 112, "totalDataCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 96, "featureVectorSpace", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 104, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 120, "continousFeatureCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 128, "discreteFeatureCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 144, "totalCols", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 136, "totalRows", 1, 0);
  CPLogisticRegressionClassfier::initializeLogisticRegressionMemory(this);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 184, "iterations", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, (char *)this + 176, "alpha", 1, 0);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 19), "theta", *((_QWORD *)this + 18) - 1, 0);
}

void sub_209CDA38C(_Unwind_Exception *a1, uint64_t a2, ...)
{
  void *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  va_list va;

  va_start(va, a2);
  std::valarray<double>::~valarray(v6);
  std::valarray<double>::~valarray(v5);
  std::valarray<double>::~valarray(v4);
  std::valarray<double>::~valarray(v3);
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100]((void ***)va);
  CPModelClose(v2);
  _Unwind_Resume(a1);
}

void CPLogisticRegressionClassfier::~CPLogisticRegressionClassfier(CPLogisticRegressionClassfier *this)
{
  unint64_t v2;
  _BYTE *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;
  _BYTE *v7;
  _BYTE *v8;
  _BYTE *v9;
  _BYTE *v10;
  void **v11;

  *(_QWORD *)this = &off_24C255C38;
  if (*((_QWORD *)this + 17))
  {
    v2 = 0;
    do
      free(*(void **)(*((_QWORD *)this + 21) + 8 * v2++));
    while (*((_QWORD *)this + 17) > v2);
  }
  free(*((void **)this + 21));
  free(*((void **)this + 19));
  free(*((void **)this + 20));
  v3 = (_BYTE *)*((_QWORD *)this + 36);
  if (v3)
  {
    v4 = (_BYTE *)*((_QWORD *)this + 37);
    if (v4 != v3)
      *((_QWORD *)this + 37) = &v4[(v3 - v4 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v3);
    *((_QWORD *)this + 36) = 0;
    *((_QWORD *)this + 37) = 0;
  }
  v5 = (_BYTE *)*((_QWORD *)this + 34);
  if (v5)
  {
    v6 = (_BYTE *)*((_QWORD *)this + 35);
    if (v6 != v5)
      *((_QWORD *)this + 35) = &v6[(v5 - v6 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v5);
    *((_QWORD *)this + 34) = 0;
    *((_QWORD *)this + 35) = 0;
  }
  v7 = (_BYTE *)*((_QWORD *)this + 32);
  if (v7)
  {
    v8 = (_BYTE *)*((_QWORD *)this + 33);
    if (v8 != v7)
      *((_QWORD *)this + 33) = &v8[(v7 - v8 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v7);
    *((_QWORD *)this + 32) = 0;
    *((_QWORD *)this + 33) = 0;
  }
  v9 = (_BYTE *)*((_QWORD *)this + 30);
  if (v9)
  {
    v10 = (_BYTE *)*((_QWORD *)this + 31);
    if (v10 != v9)
      *((_QWORD *)this + 31) = &v10[(v9 - v10 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v9);
    *((_QWORD *)this + 30) = 0;
    *((_QWORD *)this + 31) = 0;
  }
  v11 = (void **)((char *)this + 200);
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100](&v11);
  CPModelClose(this);
}

{
  CPLogisticRegressionClassfier::~CPLogisticRegressionClassfier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPLogisticRegressionClassfier::serialize(CPLogisticRegressionClassfier *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;
  uint64_t v6;

  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  v6 = (uint64_t)(*((_QWORD *)this + 33) - *((_QWORD *)this + 32)) >> 3;
  (*(void (**)(_QWORD, uint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), &v6, "min_predictors_length", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 32), "min_predictors_", v6, 0);
  v6 = (uint64_t)(*((_QWORD *)this + 35) - *((_QWORD *)this + 34)) >> 3;
  (*(void (**)(_QWORD, uint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), &v6, "max_predictors_length", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 34), "max_predictors_", v6, 0);
  v6 = (uint64_t)(*((_QWORD *)this + 37) - *((_QWORD *)this + 36)) >> 3;
  (*(void (**)(_QWORD, uint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), &v6, "range_predictors_length", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 36), "range_predictors_", v6, 0);
  v6 = (uint64_t)(*((_QWORD *)this + 31) - *((_QWORD *)this + 30)) >> 3;
  (*(void (**)(_QWORD, uint64_t *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), &v6, "solution_length", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 30), "solution_", v6, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 112, "totalDataCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 120, "continousFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 128, "discreteFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 144, "totalCols", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 136, "totalRows", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 184, "iterations", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), (char *)this + 176, "alpha", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 19), "theta", *((_QWORD *)this + 18) - 1, 0);
  return 0;
}

uint64_t CPLogisticRegressionClassfier::train(CPLogisticRegressionClassfier *this)
{
  CPLogisticRegressionClassfier::Train(this);
  return 0;
}

uint64_t CPLogisticRegressionClassfier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t RealVector;
  uint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  double *v8;
  pthread_mutex_t *CPMLLog;
  uint64_t v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  double *v16;
  double *v17;
  double *v18;
  double v19;
  double v20;
  double v21;
  int v22;
  double *v23;
  unint64_t v24;

  if (*(_QWORD *)(a1 + 144))
  {
    RealVector = CPMLFeatureVector::getRealVector(this);
    *(_DWORD *)(a1 + 224) = 2;
    v5 = *(uint64_t **)RealVector;
    v6 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
    v7 = v6 << 29;
    v23 = 0;
    v24 = 0;
    if (v6 << 29)
    {
      if ((v7 & 0x8000000000000000) != 0)
        std::__throw_bad_array_new_length[abi:ne180100]();
      v8 = (double *)operator new(v6 & 0x7FFFFFFFFLL);
      v23 = v8;
      bzero(v8, v6 & 0x7FFFFFFFFLL);
      v7 = (unint64_t)v8 + (v6 & 0x7FFFFFFFFLL);
      v24 = v7;
    }
    else
    {
      v8 = 0;
    }
    if ((int)(v6 >> 3) >= 1)
    {
      v11 = (v6 >> 3);
      v12 = v8;
      do
      {
        v13 = *v5++;
        *(_QWORD *)v12++ = v13;
        --v11;
      }
      while (v11);
    }
    v14 = v7 - (_QWORD)v8;
    if (v14)
    {
      v15 = v14 >> 3;
      v16 = *(double **)(a1 + 256);
      v17 = *(double **)(a1 + 288);
      v18 = v8;
      do
      {
        v19 = *v16++;
        v20 = *v18 - v19;
        v21 = *v17++;
        *v18++ = v20 / v21;
        --v15;
      }
      while (v15);
    }
    v22 = CPLogisticRegressionClassfier::Evaluate(a1, &v23);
    CPMLFeatureVector::setYHat((uint64_t)this, (double)v22);
    if (v8)
      operator delete(v8);
    return 1;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)a1);
    CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "eval", "totalCols 0\n");
    return 0xFFFFFFFFLL;
  }
}

void sub_209CDA9E0(_Unwind_Exception *exception_object)
{
  void *v1;

  if (v1)
    operator delete(v1);
  _Unwind_Resume(exception_object);
}

uint64_t CPLogisticRegressionClassfier::errorString(CPLogisticRegressionClassfier *this)
{
  return 0;
}

void CPLogisticRegressionClassfier::findGradient(CPLogisticRegressionClassfier *this, double *a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  uint64_t v8;
  double *v9;
  double v10;
  double *v11;
  double *v12;
  uint64_t v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double v18;
  uint64_t v19;
  double *v20;
  double v21;
  uint64_t v22;
  double v23;

  v4 = *((_QWORD *)this + 14);
  if (!v4)
  {
    v22 = *((_QWORD *)this + 18);
    v8 = v22 - 1;
    if (v22 == 1)
      return;
    goto LABEL_13;
  }
  v5 = 0;
  v6 = *((_QWORD *)this + 21);
  v7 = (double *)*((_QWORD *)this + 19);
  v8 = *((_QWORD *)this + 18) - 1;
  do
  {
    v9 = *(double **)(v6 + 8 * v5);
    v10 = 0.0;
    if (v8)
    {
      v11 = *(double **)(v6 + 8 * v5);
      v12 = v7;
      v13 = v8;
      do
      {
        v14 = *v11++;
        v15 = v14;
        v16 = *v12++;
        v10 = v10 + v15 * v16;
        --v13;
      }
      while (v13);
    }
    v17 = pow(3.14159265, -v10);
    if (v8)
    {
      v18 = 1.0 / (v17 + 1.0) - v9[v8];
      v19 = v8;
      v20 = a2;
      do
      {
        v21 = *v9++;
        *v20 = *v20 + v21 * v18;
        ++v20;
        --v19;
      }
      while (v19);
    }
    ++v5;
  }
  while (v5 != v4);
  if (v8)
  {
LABEL_13:
    v23 = 1.0 / (double)*((unint64_t *)this + 17);
    do
    {
      *a2 = *a2 * v23;
      ++a2;
      --v8;
    }
    while (v8);
  }
}

void CPLogisticRegressionClassfier::gradientDescent(CPLogisticRegressionClassfier *this)
{
  double *v2;
  unint64_t v3;
  uint64_t v4;
  double *v5;
  double *v6;
  double v7;

  v2 = (double *)malloc_type_calloc(*((_QWORD *)this + 18), 8uLL, 0x100004000313F17uLL);
  if (*((_QWORD *)this + 23))
  {
    v3 = 0;
    do
    {
      CPLogisticRegressionClassfier::findGradient(this, v2);
      v4 = *((_QWORD *)this + 18) - 1;
      if (*((_QWORD *)this + 18) != 1)
      {
        v5 = (double *)*((_QWORD *)this + 19);
        v6 = v2;
        do
        {
          v7 = *v6++;
          *v5 = *v5 + -1.0 / ((double)(int)v3 + 1.0) * *((double *)this + 22) * v7;
          ++v5;
          --v4;
        }
        while (v4);
      }
      ++v3;
    }
    while (*((_QWORD *)this + 23) > v3);
  }
  free(v2);
}

void CPLogisticRegressionClassfier::getAlgoSolution(uint64_t a1, uint64_t a2)
{
  uint64_t v4;

  v4 = a1 + 240;
  std::valarray<double>::resize(a2, (uint64_t)(*(_QWORD *)(a1 + 248) - *(_QWORD *)(a1 + 240)) >> 3, 0.0);
  if (v4 != a2)
    std::valarray<double>::__assign_range(a2, *(_BYTE **)(a1 + 240), *(_BYTE **)(a1 + 248));
}

_QWORD *std::vector<data_record_t>::__construct_one_at_end[abi:ne180100]<data_record_t const&>(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  _QWORD *result;

  v3 = *(_QWORD *)(a1 + 8);
  *(_DWORD *)v3 = *(_DWORD *)a2;
  *(_QWORD *)(v3 + 16) = 0;
  *(_QWORD *)(v3 + 24) = 0;
  *(_QWORD *)(v3 + 8) = 0;
  result = std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>((_QWORD *)(v3 + 8), *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
  *(_QWORD *)(a1 + 8) = v3 + 32;
  return result;
}

void sub_209CDAC88(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

uint64_t std::vector<data_record_t>::__push_back_slow_path<data_record_t const&>(uint64_t *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  char *v10;
  char *v11;
  uint64_t v12;
  _QWORD v14[2];
  char *v15;
  char *v16;
  uint64_t *v17;

  v3 = *a1;
  v4 = (a1[1] - *a1) >> 5;
  v5 = v4 + 1;
  if ((unint64_t)(v4 + 1) >> 59)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  v7 = (uint64_t)(a1 + 2);
  v8 = a1[2] - v3;
  if (v8 >> 4 > v5)
    v5 = v8 >> 4;
  if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFE0)
    v9 = 0x7FFFFFFFFFFFFFFLL;
  else
    v9 = v5;
  v17 = a1 + 2;
  if (v9)
    v10 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<data_record_t>>(v7, v9);
  else
    v10 = 0;
  v11 = &v10[32 * v4];
  v14[0] = v10;
  v14[1] = v11;
  v15 = v11;
  v16 = &v10[32 * v9];
  *(_DWORD *)v11 = *(_DWORD *)a2;
  *((_QWORD *)v11 + 2) = 0;
  *((_QWORD *)v11 + 3) = 0;
  *((_QWORD *)v11 + 1) = 0;
  std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>((_QWORD *)v11 + 1, *(const void **)(a2 + 8), *(_QWORD *)(a2 + 16), (uint64_t)(*(_QWORD *)(a2 + 16) - *(_QWORD *)(a2 + 8)) >> 3);
  v15 += 32;
  std::vector<data_record_t>::__swap_out_circular_buffer(a1, v14);
  v12 = a1[1];
  std::__split_buffer<data_record_t>::~__split_buffer((uint64_t)v14);
  return v12;
}

void sub_209CDAD78(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<data_record_t>::~__split_buffer((uint64_t)va);
  _Unwind_Resume(a1);
}

uint64_t std::vector<data_record_t>::__swap_out_circular_buffer(uint64_t *a1, _QWORD *a2)
{
  uint64_t result;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>,std::reverse_iterator<data_record_t*>,std::reverse_iterator<data_record_t*>>((uint64_t)(a1 + 2), a1[1], a1[1], *a1, *a1, a2[1], a2[1]);
  a2[1] = v5;
  v6 = *a1;
  *a1 = v5;
  a2[1] = v6;
  v7 = a1[1];
  a1[1] = a2[2];
  a2[2] = v7;
  v8 = a1[2];
  a1[2] = a2[3];
  a2[3] = v8;
  *a2 = a2[1];
  return result;
}

void *std::__allocate_at_least[abi:ne180100]<std::allocator<data_record_t>>(uint64_t a1, unint64_t a2)
{
  if (a2 >> 59)
    std::__throw_bad_array_new_length[abi:ne180100]();
  return operator new(32 * a2);
}

uint64_t std::__uninitialized_allocator_move_if_noexcept[abi:ne180100]<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>,std::reverse_iterator<data_record_t*>,std::reverse_iterator<data_record_t*>>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  int v8;
  uint64_t v9;
  _QWORD v11[3];
  char v12;
  __int128 v13;
  __int128 v14;

  v7 = a7;
  *(_QWORD *)&v14 = a6;
  *((_QWORD *)&v14 + 1) = a7;
  v13 = v14;
  v11[0] = a1;
  v11[1] = &v13;
  v11[2] = &v14;
  if (a3 == a5)
  {
    v9 = a6;
  }
  else
  {
    do
    {
      v8 = *(_DWORD *)(a3 - 32);
      a3 -= 32;
      *(_DWORD *)(v7 - 32) = v8;
      *(_QWORD *)(v7 - 16) = 0;
      *(_QWORD *)(v7 - 8) = 0;
      *(_QWORD *)(v7 - 24) = 0;
      *(_OWORD *)(v7 - 24) = *(_OWORD *)(a3 + 8);
      *(_QWORD *)(v7 - 8) = *(_QWORD *)(a3 + 24);
      *(_QWORD *)(a3 + 8) = 0;
      *(_QWORD *)(a3 + 16) = 0;
      *(_QWORD *)(a3 + 24) = 0;
      v7 = *((_QWORD *)&v14 + 1) - 32;
      *((_QWORD *)&v14 + 1) -= 32;
    }
    while (a3 != a5);
    v9 = v14;
  }
  v12 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v11);
  return v9;
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,std::reverse_iterator<data_record_t*>>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = *(_QWORD *)(*(_QWORD *)(a1 + 16) + 8);
  v2 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 + 8);
    if (v3)
    {
      *(_QWORD *)(v1 + 16) = v3;
      operator delete(v3);
    }
    v1 += 32;
  }
}

uint64_t std::__split_buffer<data_record_t>::~__split_buffer(uint64_t a1)
{
  std::__split_buffer<data_record_t>::__destruct_at_end[abi:ne180100](a1, *(_QWORD *)(a1 + 8));
  if (*(_QWORD *)a1)
    operator delete(*(void **)a1);
  return a1;
}

void std::__split_buffer<data_record_t>::__destruct_at_end[abi:ne180100](uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  void *v5;

  v2 = *(_QWORD *)(a1 + 16);
  while (v2 != a2)
  {
    *(_QWORD *)(a1 + 16) = v2 - 32;
    v5 = *(void **)(v2 - 24);
    if (v5)
    {
      *(_QWORD *)(v2 - 16) = v5;
      operator delete(v5);
      v2 = *(_QWORD *)(a1 + 16);
    }
    else
    {
      v2 -= 32;
    }
  }
}

_QWORD *std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>(_QWORD *result, const void *a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;
  uint64_t v7;
  size_t v8;

  if (a4)
  {
    v6 = result;
    result = std::vector<double>::__vallocate[abi:ne180100](result, a4);
    v7 = v6[1];
    v8 = a3 - (_QWORD)a2;
    if (v8)
      result = memmove((void *)v6[1], a2, v8);
    v6[1] = v7 + v8;
  }
  return result;
}

void sub_209CDB03C(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

char *std::vector<double>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 61)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[8 * v4];
  return result;
}

CoreOptimization::gradient_t *CoreOptimization::gradient_t::gradient_t(CoreOptimization::gradient_t *this, int a2)
{
  *(_QWORD *)this = 0;
  *((_QWORD *)this + 1) = 0;
  std::valarray<double>::resize((uint64_t)this, a2, 0.0);
  return this;
}

void sub_209CDB0C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::valarray<double>::~valarray(v1);
  _Unwind_Resume(a1);
}

uint64_t CoreOptimization::BFGS::BFGS(uint64_t a1, uint64_t **a2, __int128 *a3, int a4, double a5)
{
  _QWORD *v9;
  __int128 v10;

  *(_DWORD *)a1 = a4;
  v9 = (_QWORD *)(a1 + 24);
  std::valarray<double>::valarray((_QWORD *)(a1 + 8), a2);
  std::valarray<double>::valarray(v9, a2);
  v10 = *a3;
  *(_OWORD *)(a1 + 56) = a3[1];
  *(_OWORD *)(a1 + 40) = v10;
  *(double *)(a1 + 72) = a5;
  return a1;
}

void sub_209CDB150(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::valarray<double>::~valarray(v1);
  _Unwind_Resume(a1);
}

void CoreOptimization::BFGS::~BFGS(CoreOptimization::BFGS *this)
{
  _BYTE *v2;
  _QWORD *v3;
  _BYTE *v4;
  _BYTE *v5;
  _BYTE *v6;

  v3 = (_QWORD *)((char *)this + 24);
  v2 = (_BYTE *)*((_QWORD *)this + 3);
  if (v2)
  {
    v4 = (_BYTE *)v3[1];
    if (v4 != v2)
      *((_QWORD *)this + 4) = &v4[(v2 - v4 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v2);
    *v3 = 0;
    v3[1] = 0;
  }
  v5 = (_BYTE *)*((_QWORD *)this + 1);
  if (v5)
  {
    v6 = (_BYTE *)*((_QWORD *)this + 2);
    if (v6 != v5)
      *((_QWORD *)this + 2) = &v6[(v5 - v6 + 7) & 0xFFFFFFFFFFFFFFF8];
    operator delete(v5);
    *((_QWORD *)this + 1) = 0;
    *((_QWORD *)this + 2) = 0;
  }
}

void std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v1;
  void **v2;
  void **v4;
  void *v5;
  void **v6;

  v1 = *a1;
  v2 = (void **)**a1;
  if (v2)
  {
    v4 = (void **)v1[1];
    v5 = **a1;
    if (v4 != v2)
    {
      do
      {
        v4 -= 3;
        v6 = v4;
        std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&v6);
      }
      while (v4 != v2);
      v5 = **a1;
    }
    v1[1] = v2;
    operator delete(v5);
  }
}

_QWORD *std::vector<std::vector<data_record_t>>::vector(_QWORD *a1, unint64_t a2)
{
  char *v4;
  size_t v5;

  *a1 = 0;
  a1[1] = 0;
  a1[2] = 0;
  if (a2)
  {
    std::vector<std::vector<int>>::__vallocate[abi:ne180100](a1, a2);
    v4 = (char *)a1[1];
    v5 = 24 * ((24 * a2 - 24) / 0x18) + 24;
    bzero(v4, v5);
    a1[1] = &v4[v5];
  }
  return a1;
}

void sub_209CDB2E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::vector<std::vector<data_record_t>>::__init_with_size[abi:ne180100]<std::vector<data_record_t>*,std::vector<data_record_t>*>(_QWORD *result, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<std::vector<int>>::__vallocate[abi:ne180100](result, a4);
    result = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*,std::vector<data_record_t>*,std::vector<data_record_t>*>((uint64_t)(v6 + 2), a2, a3, (_QWORD *)v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_209CDB360(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<std::vector<data_record_t>>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*,std::vector<data_record_t>*,std::vector<data_record_t>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t *v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<data_record_t>::__init_with_size[abi:ne180100]<data_record_t*,data_record_t*>(v4, *v6, v6[1], (v6[1] - *v6) >> 5);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 3;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_209CDB41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*>::operator()[abi:ne180100](uint64_t a1)
{
  void **v1;
  void **v2;
  void **v3;

  v1 = **(void ****)(a1 + 16);
  v2 = **(void ****)(a1 + 8);
  while (v1 != v2)
  {
    v1 -= 3;
    v3 = v1;
    std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&v3);
  }
}

_QWORD *std::vector<data_record_t>::__init_with_size[abi:ne180100]<data_record_t*,data_record_t*>(_QWORD *result, uint64_t a2, uint64_t a3, unint64_t a4)
{
  _QWORD *v6;

  if (a4)
  {
    v6 = result;
    std::vector<data_record_t>::__vallocate[abi:ne180100](result, a4);
    result = (_QWORD *)std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<data_record_t>,data_record_t*,data_record_t*,data_record_t*>((uint64_t)(v6 + 2), a2, a3, v6[1]);
    v6[1] = result;
  }
  return result;
}

void sub_209CDB510(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, void **a9)
{
  uint64_t v9;
  uint64_t v10;

  *(_QWORD *)(v9 + 8) = v10;
  std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&a9);
  _Unwind_Resume(a1);
}

char *std::vector<data_record_t>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 59)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<data_record_t>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[32 * v4];
  return result;
}

uint64_t std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<data_record_t>,data_record_t*,data_record_t*,data_record_t*>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  uint64_t v10;
  uint64_t v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *(_DWORD *)v4 = *(_DWORD *)v6;
      *(_QWORD *)(v4 + 16) = 0;
      *(_QWORD *)(v4 + 24) = 0;
      *(_QWORD *)(v4 + 8) = 0;
      std::vector<double>::__init_with_size[abi:ne180100]<double *,double *>((_QWORD *)(v4 + 8), *(const void **)(v6 + 8), *(_QWORD *)(v6 + 16), (uint64_t)(*(_QWORD *)(v6 + 16) - *(_QWORD *)(v6 + 8)) >> 3);
      v4 = v11 + 32;
      v11 += 32;
      v6 += 32;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,data_record_t*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_209CDB614(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,data_record_t*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,data_record_t*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,data_record_t*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<data_record_t>,data_record_t*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  while (v1 != v2)
  {
    v3 = *(void **)(v1 - 24);
    if (v3)
    {
      *(_QWORD *)(v1 - 16) = v3;
      operator delete(v3);
    }
    v1 -= 32;
  }
}

void std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](void ***a1)
{
  void **v2;

  v2 = *a1;
  if (*v2)
  {
    std::vector<data_record_t>::__clear[abi:ne180100]((uint64_t *)v2);
    operator delete(**a1);
  }
}

void std::vector<data_record_t>::__clear[abi:ne180100](uint64_t *a1)
{
  uint64_t v2;
  uint64_t i;
  void *v4;

  v2 = *a1;
  for (i = a1[1]; i != v2; i -= 32)
  {
    v4 = *(void **)(i - 24);
    if (v4)
    {
      *(_QWORD *)(i - 16) = v4;
      operator delete(v4);
    }
  }
  a1[1] = v2;
}

void std::vector<std::vector<data_record_t>>::__assign_with_size[abi:ne180100]<std::vector<data_record_t>*,std::vector<data_record_t>*>(uint64_t a1, uint64_t *a2, uint64_t *a3, unint64_t a4)
{
  uint64_t v8;
  void **v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  void **v14;
  void **v15;
  void **v16;
  char v17;
  char v18;
  void **v19;

  v8 = a1 + 16;
  v9 = *(void ***)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) < a4)
  {
    std::vector<std::vector<data_record_t>>::__vdeallocate((void ***)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<std::vector<int>>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*,std::vector<data_record_t>*,std::vector<data_record_t>*>(v8, a2, a3, *(_QWORD **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3) < a4)
  {
    v13 = &a2[(uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3];
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<data_record_t> *,std::vector<data_record_t> *,std::vector<data_record_t> *>((uint64_t)&v17, a2, v13, (uint64_t *)v9);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<data_record_t>>,std::vector<data_record_t>*,std::vector<data_record_t>*,std::vector<data_record_t>*>(v8, v13, a3, *(_QWORD **)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<data_record_t> *,std::vector<data_record_t> *,std::vector<data_record_t> *>((uint64_t)&v18, a2, a3, (uint64_t *)v9);
  v15 = v14;
  v16 = *(void ***)(a1 + 8);
  if (v16 != v14)
  {
    do
    {
      v16 -= 3;
      v19 = v16;
      std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&v19);
    }
    while (v16 != v15);
  }
  *(_QWORD *)(a1 + 8) = v15;
}

void sub_209CDB89C(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_209CDB8A4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<data_record_t>>::__vdeallocate(void ***a1)
{
  void **v1;
  void **v3;
  void **v4;
  void **v5;

  v1 = *a1;
  if (*a1)
  {
    v3 = a1[1];
    v4 = *a1;
    if (v3 != v1)
    {
      do
      {
        v3 -= 3;
        v5 = v3;
        std::vector<data_record_t>::__destroy_vector::operator()[abi:ne180100](&v5);
      }
      while (v3 != v1);
      v4 = *a1;
    }
    a1[1] = v1;
    operator delete(v4);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t *std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<data_record_t> *,std::vector<data_record_t> *,std::vector<data_record_t> *>(uint64_t a1, uint64_t *a2, uint64_t *a3, uint64_t *a4)
{
  uint64_t *v5;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if (v5 != a4)
        std::vector<data_record_t>::__assign_with_size[abi:ne180100]<data_record_t*,data_record_t*>(a4, *v5, v5[1], (v5[1] - *v5) >> 5);
      v5 += 3;
      a4 += 3;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void std::vector<data_record_t>::__assign_with_size[abi:ne180100]<data_record_t*,data_record_t*>(uint64_t *a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  void *v19;
  char v20;
  char v21;

  v8 = (uint64_t)(a1 + 2);
  v9 = *a1;
  if (a4 > (a1[2] - *a1) >> 5)
  {
    std::vector<data_record_t>::__vdeallocate(a1);
    if (a4 >> 59)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = a1[2] - *a1;
    v11 = v10 >> 4;
    if (v10 >> 4 <= a4)
      v11 = a4;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFE0)
      v12 = 0x7FFFFFFFFFFFFFFLL;
    else
      v12 = v11;
    std::vector<data_record_t>::__vallocate[abi:ne180100](a1, v12);
    v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<data_record_t>,data_record_t*,data_record_t*,data_record_t*>(v8, a2, a3, a1[1]);
    goto LABEL_11;
  }
  v14 = (a1[1] - v9) >> 5;
  if (v14 < a4)
  {
    v15 = a2 + 32 * v14;
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<data_record_t *,data_record_t *,data_record_t *>((uint64_t)&v20, a2, v15, v9);
    v13 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<data_record_t>,data_record_t*,data_record_t*,data_record_t*>(v8, v15, a3, a1[1]);
LABEL_11:
    a1[1] = v13;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<data_record_t *,data_record_t *,data_record_t *>((uint64_t)&v21, a2, a3, v9);
  v17 = v16;
  v18 = a1[1];
  if (v18 != v16)
  {
    do
    {
      v19 = *(void **)(v18 - 24);
      if (v19)
      {
        *(_QWORD *)(v18 - 16) = v19;
        operator delete(v19);
      }
      v18 -= 32;
    }
    while (v18 != v17);
  }
  a1[1] = v17;
}

void sub_209CDBACC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_209CDBAD4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<data_record_t>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<data_record_t>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<data_record_t *,data_record_t *,data_record_t *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      *(_DWORD *)a4 = *(_DWORD *)v5;
      if (v5 != a4)
        std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>((char *)(a4 + 8), *(char **)(v5 + 8), *(_QWORD *)(v5 + 16), (uint64_t)(*(_QWORD *)(v5 + 16) - *(_QWORD *)(v5 + 8)) >> 3);
      v5 += 32;
      a4 += 32;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

char *std::vector<double>::__assign_with_size[abi:ne180100]<double *,double *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 3)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 2;
    if (v8 >> 2 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<double>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 3;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[8 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

uint64_t std::valarray<double>::__assign_range(uint64_t a1, _BYTE *__src, _BYTE *a3)
{
  size_t v6;
  uint64_t v7;
  _BYTE *v8;
  _BYTE *v9;
  char *v11;

  v6 = a3 - __src;
  v7 = (a3 - __src) >> 3;
  v8 = *(_BYTE **)a1;
  v9 = *(_BYTE **)(a1 + 8);
  if (v7 == (v9 - v8) >> 3)
  {
    if (a3 != __src)
      memmove(v8, __src, a3 - __src);
  }
  else
  {
    if (v8)
    {
      if (v9 != v8)
        *(_QWORD *)(a1 + 8) = &v9[(v8 - v9 + 7) & 0xFFFFFFFFFFFFFFF8];
      operator delete(v8);
      *(_QWORD *)a1 = 0;
      *(_QWORD *)(a1 + 8) = 0;
    }
    if ((v6 & 0x8000000000000000) != 0)
      std::__throw_bad_array_new_length[abi:ne180100]();
    v11 = (char *)operator new(v6);
    *(_QWORD *)a1 = v11;
    *(_QWORD *)(a1 + 8) = &v11[8 * v7];
    if (__src != a3)
      memcpy(v11, __src, ((v6 - 8) & 0xFFFFFFFFFFFFFFF8) + 8);
  }
  return a1;
}

uint64_t CPMLDelegate::evaluateCPMLAlgorithm(id *a1, CPMLFeatureVector *a2, uint64_t *a3, _QWORD *a4)
{
  id v8;
  id v9;
  char v10;
  void *v11;
  uint64_t v12;
  unint64_t v13;
  void *v14;
  void *v15;
  void *v16;
  uint64_t v17;

  v8 = a1[1];
  v9 = *a1;
  v10 = objc_opt_respondsToSelector();
  if ((v10 & 1) != 0)
  {
    v11 = (void *)objc_opt_new();
    v12 = *a3;
    if (a3[1] != *a3)
    {
      v13 = 0;
      do
      {
        v14 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithInt:", *(unsigned int *)(v12 + 4 * v13));
        objc_msgSend(v11, "addObject:", v14);

        ++v13;
        v12 = *a3;
      }
      while (v13 < (a3[1] - *a3) >> 2);
    }
    CPMLconvertFV2Array(a2);
    v15 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v9, "evaluateCPMLAlgorithm:withFV:boundedList:", v8, v15, v11);
    v16 = (void *)objc_claimAutoreleasedReturnValue();
    objc_msgSend(v16, "doubleValue");
    *a4 = v17;

  }
  return v10 & 1;
}

void sub_209CDBE74(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

uint64_t CPMLDelegate::serializeCPMLAlgorithm(CPMLDelegate *this)
{
  void *v2;
  void *v3;
  char v4;

  v2 = this->var1;
  v3 = this->var0;
  v4 = objc_opt_respondsToSelector();
  if ((v4 & 1) != 0)
    objc_msgSend(v3, "serializeCPMLAlgorithm:", v2);

  return v4 & 1;
}

void sub_209CDBF28(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CPMLDelegate::deSerializeCPMLAlgorithm(CPMLDelegate *this)
{
  void *v2;
  void *v3;
  char v4;

  v2 = this->var1;
  v3 = this->var0;
  v4 = objc_opt_respondsToSelector();
  if ((v4 & 1) != 0)
    objc_msgSend(v3, "serializeCPMLAlgorithm:", v2);

  return v4 & 1;
}

void sub_209CDBFA4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CPMLDelegate::trainCPMLAlgorithm(CPMLDelegate *this, CPMLFeatureVector *a2)
{
  void *v4;
  void *v5;
  char v6;
  void *v7;
  void *v8;

  v4 = this->var1;
  v5 = this->var0;
  v6 = objc_opt_respondsToSelector();
  if ((v6 & 1) != 0)
  {
    CPMLconvertFV2Array(a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithDouble:", CPMLFeatureVector::getYHat(a2));
    objc_msgSend(v7, "addObject:", v8);
    objc_msgSend(v5, "trainCPMLAlgorithm:withFV:", v4, v7);

  }
  return v6 & 1;
}

void sub_209CDC078(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

uint64_t CPMLDelegate::updateCPMLAlgorithm(CPMLDelegate *this, CPMLFeatureVector *a2)
{
  void *v4;
  void *v5;
  char v6;
  void *v7;
  void *v8;

  v4 = this->var1;
  v5 = this->var0;
  v6 = objc_opt_respondsToSelector();
  if ((v6 & 1) != 0)
  {
    CPMLconvertFV2Array(a2);
    v7 = (void *)objc_claimAutoreleasedReturnValue();
    v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithDouble:", CPMLFeatureVector::getYHat(a2));
    objc_msgSend(v7, "addObject:", v8);
    objc_msgSend(v5, "trainCPMLAlgorithm:withFV:", v4, v7);

  }
  return v6 & 1;
}

void sub_209CDC168(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void CPMLAlgorithm::CPMLAlgorithm(CPMLAlgorithm *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  this->var0 = (void **)off_24C255210;
  this->var6 = a4;
  this->var3 = a2;
  this->var4 = 0;
  this->var8 = a3;
}

uint64_t CPMLAlgorithm::update(CPMLAlgorithm *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "update", "not implemented.");
  return 0xFFFFFFFFLL;
}

CPMLAlgorithm *CPMLAlgorithm::setDelegate(CPMLAlgorithm *this, CPMLDelegate *a2)
{
  this->var4 = a2;
  return this;
}

CPMLAlgorithm *CPMLAlgorithm::setDelegateEngine(CPMLAlgorithm *this, CPMLDelegateEngine *a2)
{
  this->var5 = a2;
  return this;
}

uint64_t CPLogCTypesV(void *a1, unint64_t a2, ...)
{
  void *v3;
  uint64_t v4;
  int *v5;
  id v6;
  void *v7;
  uint64_t v8;
  void *v9;
  int *v10;
  int v11;
  int v12;
  void *v13;
  double *v14;
  uint64_t v15;
  uint64_t v16;
  id v18;
  va_list v19;
  va_list va;

  va_start(va, a2);
  v3 = a1;
  v18 = objc_alloc_init(MEMORY[0x24BDBCED8]);
  va_copy(v19, va);
  if (!a2)
  {
LABEL_22:
    v16 = objc_msgSend(v3, "logNSDictionary:", v18);
    goto LABEL_25;
  }
  v4 = 0;
  v5 = (int *)a2;
  while (a2 < 2)
  {
LABEL_10:
    v10 = va_arg(v19, int *);
    v5 = v10;
    if (!v10)
      goto LABEL_22;
  }
  v6 = objc_alloc_init(MEMORY[0x24BEDCDF0]);
  objc_msgSend(v3, "getColumnName:", v4);
  v7 = (void *)objc_claimAutoreleasedReturnValue();
  switch(objc_msgSend(v3, "getSchemaType:", v4))
  {
    case 3u:
      v8 = objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithInteger:", *v5);
      goto LABEL_8;
    case 4u:
      v8 = objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithDouble:", *(double *)v5);
      goto LABEL_8;
    case 5u:
      v8 = objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", v5, 4);
LABEL_8:
      v9 = (void *)v8;

      goto LABEL_9;
    case 7u:
      v11 = *v5;
      v12 = objc_msgSend(v3, "getVectorContent:", v4);
      v13 = v6;
      if (!v11)
      {
        v9 = v6;
LABEL_9:
        objc_msgSend(v18, "setObject:forKey:", v9, v7);
        ++v4;

        goto LABEL_10;
      }
      while (1)
      {
        v14 = va_arg(v19, double *);
        if (v12 == 3)
        {
          v15 = objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithInteger:", *(int *)v14);
          goto LABEL_19;
        }
        if (v12 == 4)
        {
          v15 = objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithDouble:", *v14);
          goto LABEL_19;
        }
        if (v12 != 5)
          break;
        v15 = objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", v14, 4);
LABEL_19:
        v9 = (void *)v15;

        v13 = v9;
        if (!--v11)
          goto LABEL_9;
      }
      NSLog(CFSTR("%s unknown type"), "CPLogCTypesV");
LABEL_24:

      v16 = 0xFFFFFFFFLL;
LABEL_25:

      return v16;
    default:
      NSLog(CFSTR("%s: No support"), "CPLogCTypesV");
      goto LABEL_24;
  }
}

void sub_209CDC478(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

CPMLDB *CPOpenDB(char *a1, char *a2, uint64_t a3)
{
  void *v5;
  void *v6;
  CPMLDB *v7;

  v5 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a1, 4);
  v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  v7 = -[CPMLDB initWithDBName:withPlistPath:withWriteOptions:]([CPMLDB alloc], "initWithDBName:withPlistPath:withWriteOptions:", v5, v6, a3);

  return v7;
}

void sub_209CDC568(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

CPMLDB *CPOpenDBWithFile(char *a1, char *a2, char *a3, uint64_t a4)
{
  void *v7;
  void *v8;
  void *v9;
  CPMLDB *v10;

  v7 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a1, 4);
  v8 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a2, 4);
  v9 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD17C8]), "initWithCString:encoding:", a3, 4);
  v10 = -[CPMLDB initWithDBName:dataFromFile:withPlistPath:withWriteOptions:]([CPMLDB alloc], "initWithDBName:dataFromFile:withPlistPath:withWriteOptions:", v7, v8, v9, a4);

  return v10;
}

void sub_209CDC640(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_209CDC838(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CDC948(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_209CDCA34(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_209CDCDC4(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;
  void *v6;

  _Unwind_Resume(a1);
}

void sub_209CDCFFC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;
  void *v14;
  void *v15;
  void *v16;
  void *v17;
  void *v18;

  _Unwind_Resume(a1);
}

void sub_209CDD1A0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_209CDD2B8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;

  _Unwind_Resume(a1);
}

void sub_209CDD9E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  void *v20;
  void *v21;
  void *v22;
  void *v23;
  void *v24;
  void *v25;
  void *v26;

  _Unwind_Resume(a1);
}

void sub_209CDDC60(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDDCB4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  void *v9;
  void *v10;

  v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)CPMLDB;
  -[_Unwind_Exception dealloc](&a9, sel_dealloc);
  _Unwind_Resume(a1);
}

uint64_t callbackDBResponse(void *a1, int a2, char **a3, char **a4)
{
  return 0;
}

void sub_209CDDF3C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDE0F8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CDE250(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDE3BC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDE51C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDE684(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, ...)
{
  void *v11;
  void *v12;
  va_list va;

  va_start(va, a11);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_209CDE92C(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDEE14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11)
{
  void *v11;
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDEFBC(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CDF0F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_209CDF184(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_209CDF2A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  void *v16;
  void *v17;

  _Unwind_Resume(a1);
}

void sub_209CDF334(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{

  _Unwind_Resume(a1);
}

void sub_209CDF504(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDF59C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDF63C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDF6DC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDF790(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_209CDF834(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;

  _Unwind_Resume(a1);
}

void sub_209CDF8BC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CDF940(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CDFBA0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

void sub_209CDFEC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, id a11)
{
  void *v11;

  _Unwind_Resume(a1);
}

void sub_209CE00D0(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE0198(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE025C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE0320(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE0454(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE06A0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE07C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_209CE0AF8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE0C38(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, id a12)
{
  void *v12;
  void *v13;
  void *v14;

  _Unwind_Resume(a1);
}

void sub_209CE0D6C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE0E40(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE0F08(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE1068(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__0(uint64_t result, uint64_t a2)
{
  *(_QWORD *)(result + 40) = *(_QWORD *)(a2 + 40);
  *(_QWORD *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__0(uint64_t a1)
{

}

void sub_209CE1480(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE15B0(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE1868(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE193C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_list va;

  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_209CE1A04(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

uint64_t CPMLLIBSVMClassifier::establishParam(uint64_t this, CPMLTunableData *a2)
{
  uint64_t v2;
  int v9;
  int v14;
  _BYTE v15[11];
  uint64_t v16;

  v2 = this;
  v16 = *MEMORY[0x24BDAC8D0];
  if (a2)
  {
    this = CPMLTunableData::getNumberOfItems(a2);
    if ((int)this >= 1)
    {
      CPMLTunableData::tDataGetString(a2, "svm_type", v15, 0x10uLL);
      if (*(_DWORD *)v15 == 1448304451 && v15[4] == 67)
        goto LABEL_23;
      if (*(_DWORD *)v15 == 1398756686 && *(unsigned __int16 *)&v15[4] == 17238)
      {
        v9 = 1;
      }
      else if (*(_QWORD *)v15 == 0x53414C435F454E4FLL && v15[8] == 83)
      {
        v9 = 2;
      }
      else if (*(_QWORD *)v15 == 0x5F4E4F4C49535045 && *(_QWORD *)&v15[3] == 0x5256535F4E4F4C49)
      {
        v9 = 3;
      }
      else
      {
        if (*(_DWORD *)v15 != 1398756686 || *(unsigned __int16 *)&v15[4] != 21078)
        {
LABEL_23:
          *(_DWORD *)(v2 + 160) = 0;
          goto LABEL_30;
        }
        v9 = 4;
      }
      *(_DWORD *)(v2 + 160) = v9;
LABEL_30:
      CPMLTunableData::tDataGetString(a2, "kernel_type", v15, 0x10uLL);
      if (*(_DWORD *)v15 == 1162758476 && *(unsigned __int16 *)&v15[4] == 21057)
      {
        *(_DWORD *)(v2 + 164) = 0;
LABEL_53:
        CPMLTunableData::tDataGetInt(a2, "degree", (int *)(v2 + 168));
        CPMLTunableData::tDataGetDouble(a2, "gamma", (double *)(v2 + 176));
        CPMLTunableData::tDataGetDouble(a2, "coef0", (double *)(v2 + 184));
        CPMLTunableData::tDataGetDouble(a2, "nu", (double *)(v2 + 240));
        CPMLTunableData::tDataGetDouble(a2, "cache_size", (double *)(v2 + 192));
        CPMLTunableData::tDataGetDouble(a2, "C", (double *)(v2 + 208));
        CPMLTunableData::tDataGetDouble(a2, "eps", (double *)(v2 + 200));
        CPMLTunableData::tDataGetDouble(a2, "p", (double *)(v2 + 248));
        CPMLTunableData::tDataGetInt(a2, "shrinking", (int *)(v2 + 256));
        CPMLTunableData::tDataGetInt(a2, "probability", (int *)(v2 + 260));
        this = CPMLTunableData::tDataGetInt(a2, "cpu_count", &libsvm_cpu_count);
        goto LABEL_54;
      }
      if (*(_DWORD *)v15 == 1498173264)
      {
        v14 = 1;
      }
      else
      {
        if (*(unsigned __int16 *)v15 != 16978 || v15[2] != 70)
        {
          if (*(_DWORD *)v15 == 1296517459 && *(_DWORD *)&v15[3] == 1145655117)
          {
            v14 = 3;
            goto LABEL_52;
          }
          if (*(_QWORD *)v15 == 0x55504D4F43455250 && *(_QWORD *)&v15[3] == 0x44455455504D4F43)
          {
            v14 = 4;
            goto LABEL_52;
          }
        }
        v14 = 2;
      }
LABEL_52:
      *(_DWORD *)(v2 + 164) = v14;
      goto LABEL_53;
    }
  }
  *(_QWORD *)(v2 + 160) = 0x200000000;
  *(_DWORD *)(v2 + 168) = 3;
  *(_QWORD *)(v2 + 176) = 0;
  *(_QWORD *)(v2 + 184) = 0;
  *(_QWORD *)(v2 + 208) = 0x3FF0000000000000;
  *(_OWORD *)(v2 + 192) = xmmword_209D008B0;
  *(_OWORD *)(v2 + 240) = xmmword_209D008C0;
  *(_QWORD *)(v2 + 256) = 1;
LABEL_54:
  *(_DWORD *)(v2 + 216) = 0;
  *(_QWORD *)(v2 + 224) = 0;
  *(_QWORD *)(v2 + 232) = 0;
  return this;
}

void CPMLLIBSVMClassifier::CPMLLIBSVMClassifier(CPMLLIBSVMClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v7;
  CPMLStatistics *var0;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t Iterator;
  uint64_t v21;
  CPMLFeatureVector *v22;
  char *v23;
  uint64_t *IntVector;
  uint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int v28;
  uint64_t v29;
  int v30;
  double v31;
  double *v32;
  uint64_t RealVector;
  double *v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  double v38;
  double *v39;
  double *v40;
  double YHat;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v7 = &off_24C2556A0;
  strcpy((char *)(v7 + 8), "3.20.0");
  libsvm_cpu_count = 2;
  var0 = a2->var0;
  v9 = *((int *)a2->var0 + 30);
  v11 = *((int *)a2->var0 + 32);
  v10 = *((int *)a2->var0 + 33);
  *(_QWORD *)(v7 + 96) = *((int *)a2->var0 + 31);
  *(_QWORD *)(v7 + 104) = v10;
  v12 = *((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3);
  v13 = *(_QWORD *)var0;
  v14 = ((*((_QWORD *)var0 + 1) - *(_QWORD *)var0) >> 2);
  *(_QWORD *)(v7 + 128) = v14;
  *(_QWORD *)(v7 + 136) = v13;
  *(_BYTE *)(v7 + 296) = 0;
  v15 = v12 >> 3;
  *(_QWORD *)(v7 + 112) = v9;
  *(_QWORD *)(v7 + 120) = v15;
  LODWORD(var0) = *(_DWORD *)(*((_QWORD *)var0 + 9) + 4 * v11);
  v16 = (_DWORD)var0 == 0;
  if ((_DWORD)var0)
    v17 = v15;
  else
    v17 = v14;
  v18 = 120;
  if (v16)
    v18 = 128;
  *(_QWORD *)(v7 + v18) = v17 - 1;
  CPMLLIBSVMClassifier::establishParam(v7, a4);
  v19 = *((_QWORD *)this + 14);
  *((_DWORD *)this + 66) = v19;
  *((_QWORD *)this + 34) = malloc_type_calloc((int)v19, 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 35) = malloc_type_calloc(*((int *)this + 66), 8uLL, 0x2004093837F09uLL);
  Iterator = CPMLCDB::getIterator(a2, 0, 0, 0);
  v21 = 0;
  for (*((_QWORD *)this + 10) = Iterator; ; Iterator = *((_QWORD *)this + 10))
  {
    v22 = (CPMLFeatureVector *)(*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
    if (!v22)
      break;
    v23 = (char *)malloc_type_calloc(*((_QWORD *)this + 12) + 1, 0x10uLL, 0x1000040F7F8B94BuLL);
    IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(v22);
    v25 = *IntVector;
    v26 = IntVector[1] - *IntVector;
    if ((int)(v26 >> 2) < 1)
    {
      v28 = 0;
    }
    else
    {
      v27 = 0;
      v28 = 0;
      v29 = (v26 >> 2);
      do
      {
        v30 = *(_DWORD *)(v25 + 4 * v27);
        if (v30)
        {
          v31 = (double)v30;
          ++v27;
          v32 = (double *)&v23[16 * v28];
          *(_DWORD *)v32 = v27;
          v32[1] = v31;
          ++v28;
        }
        else
        {
          ++v27;
        }
      }
      while (v27 != v29);
    }
    RealVector = CPMLFeatureVector::getRealVector(v22);
    v34 = *(double **)RealVector;
    v35 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
    if ((int)(v35 >> 3) >= 1)
    {
      v36 = ((unint64_t)(IntVector[1] - *IntVector) >> 2) + 1;
      v37 = (v35 >> 3);
      do
      {
        v38 = *v34;
        if (*v34 != 0.0)
        {
          v39 = (double *)&v23[16 * v28];
          *(_DWORD *)v39 = v36;
          v39[1] = v38;
          ++v28;
        }
        ++v34;
        ++v36;
        --v37;
      }
      while (v37);
    }
    v40 = (double *)&v23[16 * v28];
    *(_DWORD *)v40 = -1;
    v40[1] = nan("");
    *(_QWORD *)(*((_QWORD *)this + 35) + 8 * v21) = malloc_type_realloc(v23, 16 * (v28 + 1), 0x1000040F7F8B94BuLL);
    if (*((_QWORD *)this + 13) == 2)
    {
      if (CPMLFeatureVector::getYHat(v22) == 0.0)
        YHat = -1.0;
      else
        YHat = 1.0;
    }
    else
    {
      YHat = CPMLFeatureVector::getYHat(v22);
    }
    *(double *)(*((_QWORD *)this + 34) + 8 * v21++) = YHat;
  }
}

void sub_209CE2134(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLLIBSVMClassifier::CPMLLIBSVMClassifier(CPMLLIBSVMClassifier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v5;
  void *v6;
  int v7;
  size_t v8;
  void *v9;
  uint64_t v10;
  uint64_t v11;
  void *v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  char *v20;
  int v21;
  char v22[30];
  char v23[30];
  char v24[30];
  uint64_t v25;

  v25 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v5 = &off_24C2556A0;
  *(_BYTE *)(v5 + 296) = 0;
  (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, v5 + 8, "version", 5, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 112, "totalRows", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 96, "featureVectorSpace", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 104, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 120, "continousFeatureCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 128, "discreteFeatureCount", 1, 0);
  v6 = malloc_type_calloc(1uLL, 0xB8uLL, 0x109004003BC950CuLL);
  *((_QWORD *)this + 36) = v6;
  *((_BYTE *)this + 296) = 0;
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 72))(*((_QWORD *)this + 11), (uint64_t)v6 + 104, "model_nr_class", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 72))(*((_QWORD *)this + 11), *((_QWORD *)this + 36) + 108, "model_l", 1, 0);
  v7 = (*(_DWORD *)(*((_QWORD *)this + 36) + 104) - 1) * *(_DWORD *)(*((_QWORD *)this + 36) + 104);
  v8 = (uint64_t)(v7 + (v7 < 0)) >> 1;
  *(_QWORD *)(*((_QWORD *)this + 36) + 128) = malloc_type_calloc(v8, 8uLL, 0x100004000313F17uLL);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11));
  *(_QWORD *)(*((_QWORD *)this + 36) + 160) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 36) + 104), 4uLL, 0x100004052888210uLL);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11));
  v21 = 0;
  (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), &v21, "testA", 1, 0);
  if (v21)
  {
    *(_QWORD *)(*((_QWORD *)this + 36) + 136) = malloc_type_calloc(v8, 8uLL, 0x100004000313F17uLL);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11));
  }
  (*(void (**)(_QWORD, int *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), &v21, "testB", 1, 0);
  if (v21)
  {
    *(_QWORD *)(*((_QWORD *)this + 36) + 144) = malloc_type_calloc(v8, 8uLL, 0x100004000313F17uLL);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11));
  }
  *(_QWORD *)(*((_QWORD *)this + 36) + 168) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 36) + 104), 4uLL, 0x100004052888210uLL);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 72))(*((_QWORD *)this + 11));
  v9 = malloc_type_calloc(*(int *)(*((_QWORD *)this + 36) + 104), 8uLL, 0x80040B8603338uLL);
  v10 = *((_QWORD *)this + 36);
  *(_QWORD *)(v10 + 120) = v9;
  if (*(int *)(v10 + 104) >= 2)
  {
    v11 = 0;
    do
    {
      *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 36) + 120) + 8 * v11++) = malloc_type_calloc(*(int *)(v10 + 108), 8uLL, 0x100004000313F17uLL);
      v10 = *((_QWORD *)this + 36);
    }
    while (v11 < *(int *)(v10 + 104) - 1);
  }
  v12 = malloc_type_calloc(*(int *)(v10 + 108), 8uLL, 0x2004093837F09uLL);
  v13 = *((_QWORD *)this + 36);
  *(_QWORD *)(v13 + 112) = v12;
  if (*(int *)(v13 + 108) >= 1)
  {
    v14 = 0;
    do
    {
      v15 = (char *)malloc_type_calloc(*((_QWORD *)this + 12) + 1, 0x10uLL, 0x1000040F7F8B94BuLL);
      sprintf(v24, "model_sv_coef%d", v14);
      sprintf(v23, "p_index%d", v14);
      sprintf(v22, "p_value%d", v14);
      v16 = *((_QWORD *)this + 36);
      if (*(int *)(v16 + 104) >= 2)
      {
        v17 = 0;
        do
        {
          (*(void (**)(_QWORD, uint64_t, char *, uint64_t, uint64_t))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), *(_QWORD *)(*(_QWORD *)(v16 + 120) + 8 * v17) + 8 * v14, v24, 1, v17);
          ++v17;
          v16 = *((_QWORD *)this + 36);
        }
        while (v17 < *(int *)(v16 + 104) - 1);
      }
      v18 = 0;
      v19 = 0;
      do
      {
        v20 = &v15[v18];
        (*(void (**)(_QWORD, char *, char *, uint64_t, uint64_t))(**((_QWORD **)this + 11) + 64))(*((_QWORD *)this + 11), &v15[v18], v23, 1, v19);
        (*(void (**)(_QWORD, char *, char *, uint64_t, uint64_t))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11), &v15[v18 + 8], v22, 1, v19++);
        v18 += 16;
      }
      while (*(_DWORD *)v20 != -1);
      *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 36) + 112) + 8 * v14++) = malloc_type_realloc(v15, v18 & 0xFFFFFFFF0, 0x1000040F7F8B94BuLL);
      v13 = *((_QWORD *)this + 36);
    }
    while (v14 < *(int *)(v13 + 108));
  }
  *(_DWORD *)(v13 + 176) = 1;
  *((_QWORD *)this + 34) = 0;
  *((_QWORD *)this + 35) = 0;
}

void sub_209CE2744(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLLIBSVMClassifier::CPMLLIBSVMClassifier(CPMLLIBSVMClassifier *this, int *a2, CPMLTunableData *a3)
{
  uint64_t v4;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, 0, a3);
  *(_QWORD *)v4 = &off_24C2556A0;
  strcpy((char *)(v4 + 8), "3.20.0");
  *(_QWORD *)(v4 + 288) = a2;
  *(_BYTE *)(v4 + 296) = 1;
  *(_QWORD *)(v4 + 104) = a2[26];
  *(_QWORD *)(v4 + 272) = 0;
  *(_QWORD *)(v4 + 280) = 0;
}

void CPMLLIBSVMClassifier::~CPMLLIBSVMClassifier(CPMLLIBSVMClassifier *this)
{
  void *v2;
  void *v3;

  *(_QWORD *)this = &off_24C2556A0;
  v2 = (void *)*((_QWORD *)this + 34);
  if (v2)
    free(v2);
  *((_QWORD *)this + 34) = 0;
  v3 = (void *)*((_QWORD *)this + 35);
  if (v3)
    free(v3);
  *((_QWORD *)this + 35) = 0;
  if (!*((_BYTE *)this + 296))
    svm_free_and_destroy_model((void **)this + 36);
  CPModelClose(this);
}

{
  CPMLLIBSVMClassifier::~CPMLLIBSVMClassifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLLIBSVMClassifier::serialize(CPMLLIBSVMClassifier *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;
  uint64_t v5;
  uint64_t v6;
  void (*v7)(void);
  void (*v8)(void);
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int *v12;
  int i;
  int v14;
  char v16[30];
  char v17[30];
  char v18[32];
  uint64_t v19;

  v19 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 112, "totalRows", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 120, "continousFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 128, "discreteFeatureCount", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), *((_QWORD *)this + 36) + 104, "model_nr_class", 1, 0);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), *((_QWORD *)this + 36) + 108, "model_l", 1, 0);
  v5 = *((_QWORD *)this + 36);
  v6 = *(_QWORD *)(v5 + 128);
  LODWORD(v5) = (*(_DWORD *)(v5 + 104) - 1) * *(_DWORD *)(v5 + 104);
  (*(void (**)(_QWORD, uint64_t, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v6, "model_rho", (uint64_t)(int)(v5 + ((int)v5 < 0)) >> 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 36) + 160), "model_label", *(int *)(*((_QWORD *)this + 36) + 104), 0);
  if (*(_QWORD *)(*((_QWORD *)this + 36) + 136))
  {
    *(_DWORD *)v18 = 1;
    (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v18, "testA", 1, 0);
    v7 = *(void (**)(void))(**((_QWORD **)this + 11) + 48);
  }
  else
  {
    *(_DWORD *)v18 = 0;
    v7 = *(void (**)(void))(**((_QWORD **)this + 11) + 16);
  }
  v7();
  if (*(_QWORD *)(*((_QWORD *)this + 36) + 144))
  {
    *(_DWORD *)v18 = 1;
    (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v18, "testB", 1, 0);
    v8 = *(void (**)(void))(**((_QWORD **)this + 11) + 48);
  }
  else
  {
    *(_DWORD *)v18 = 0;
    v8 = *(void (**)(void))(**((_QWORD **)this + 11) + 16);
  }
  v8();
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 36) + 168), "model_nSV", *(int *)(*((_QWORD *)this + 36) + 104), 0);
  if (*(int *)(*((_QWORD *)this + 36) + 108) >= 1)
  {
    v9 = 0;
    do
    {
      sprintf(v18, "model_sv_coef%d", v9);
      sprintf(v17, "p_index%d", v9);
      sprintf(v16, "p_value%d", v9);
      v10 = *((_QWORD *)this + 36);
      if (*(int *)(v10 + 104) >= 2)
      {
        v11 = 0;
        do
        {
          (*(void (**)(_QWORD, uint64_t, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*(_QWORD *)(v10 + 120) + 8 * v11++) + 8 * v9, v18, 1, 0);
          v10 = *((_QWORD *)this + 36);
        }
        while (v11 < *(int *)(v10 + 104) - 1);
      }
      v12 = *(int **)(*(_QWORD *)(v10 + 112) + 8 * v9);
      for (i = *v12; i != -1; i = v14)
      {
        (*(void (**)(_QWORD, int *, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v12, v17, 1, 0);
        (*(void (**)(_QWORD, int *, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v12 + 2, v16, 1, 0);
        v14 = v12[4];
        v12 += 4;
      }
      (*(void (**)(_QWORD, int *, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), v12, v17, 1, 0);
      (*(void (**)(_QWORD, int *, char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v12 + 2, v16, 1, 0);
      ++v9;
    }
    while (v9 < *(int *)(*((_QWORD *)this + 36) + 108));
  }
  return 0;
}

uint64_t CPMLLIBSVMClassifier::train(CPMLLIBSVMClassifier *this)
{
  int *v2;
  char *v3;
  const char *v4;
  uint64_t result;
  char *v6;

  v2 = (int *)((char *)this + 264);
  v3 = (char *)this + 160;
  v4 = svm_check_parameter((unsigned int *)this + 66, (uint64_t)this + 160);
  if (v4)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "ERROR: %s\n", v4);
    return 0xFFFFFFFFLL;
  }
  else
  {
    v6 = svm_train(v2, (uint64_t)v3);
    result = 0;
    *((_QWORD *)this + 36) = v6;
    *((_BYTE *)this + 296) = 0;
  }
  return result;
}

uint64_t CPMLLIBSVMClassifier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t *IntVector;
  double **RealVector;
  char *v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  int v14;
  double v15;
  double *v16;
  double *v17;
  unint64_t v18;
  int v19;
  uint64_t v20;
  double v21;
  double *v22;
  double *v23;
  void *v24;
  double v25;
  double v26;

  IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(this);
  RealVector = (double **)CPMLFeatureVector::getRealVector(this);
  v6 = (char *)malloc_type_calloc(((IntVector[1] - *IntVector) >> 2) + RealVector[1] - *RealVector + 1, 0x10uLL, 0x1000040F7F8B94BuLL);
  v7 = v6;
  v8 = *IntVector;
  v9 = IntVector[1] - *IntVector;
  v10 = v9 >> 2;
  if ((int)(v9 >> 2) < 1)
  {
    v12 = 0;
  }
  else
  {
    v11 = 0;
    v12 = 0;
    v13 = (v9 >> 2);
    do
    {
      v14 = *(_DWORD *)(v8 + 4 * v11);
      if (v14)
      {
        v15 = (double)v14;
        ++v11;
        v16 = (double *)&v6[16 * v12];
        *(_DWORD *)v16 = v11;
        v16[1] = v15;
        ++v12;
      }
      else
      {
        ++v11;
      }
    }
    while (v11 != v13);
  }
  v17 = *RealVector;
  v18 = (char *)RealVector[1] - (char *)*RealVector;
  if ((int)(v18 >> 3) >= 1)
  {
    v19 = v10 + 1;
    v20 = (v18 >> 3);
    do
    {
      v21 = *v17;
      if (*v17 != 0.0)
      {
        v22 = (double *)&v6[16 * v12];
        *(_DWORD *)v22 = v19;
        v22[1] = v21;
        ++v12;
      }
      ++v17;
      ++v19;
      --v20;
    }
    while (v20);
  }
  v23 = (double *)&v6[16 * v12];
  *(_DWORD *)v23 = -1;
  v23[1] = nan("");
  v24 = malloc_type_realloc(v7, 16 * (v12 + 1), 0x1000040F7F8B94BuLL);
  svm_predict(*(_QWORD *)(a1 + 288), (uint64_t)v24);
  v26 = 1.0;
  if (v25 == -1.0)
    v26 = 0.0;
  if (*(_QWORD *)(a1 + 104) == 2)
    v25 = v26;
  CPMLFeatureVector::setYHat((uint64_t)this, v25);
  free(v24);
  return 0;
}

void CPMLLIBSVMClassifier::update(CPMLLIBSVMClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s No Update Allowed", "update");
  __assert_rtn("update", "CPMLLIBSVM.c", 426, "0");
}

uint64_t CPMLLIBSVMClassifier::errorString(CPMLLIBSVMClassifier *this)
{
  return 0;
}

uint64_t CPMLLIBSVMClassifier::requireRealOnly(CPMLLIBSVMClassifier *this)
{
  return 1;
}

void CPMLDBSerialization::CPMLDBSerialization(CPMLDBSerialization *this, sqlite3 *a2)
{
  uint64_t v3;
  uint64_t **v4;
  char *v5;
  int v6;
  CPMLLog *v7;
  char *v8;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  char v11;
  sqlite3_stmt *ppStmt;
  void **v13;

  CPMLSerialization::CPMLSerialization((CPMLSerialization *)this, a2);
  *(_QWORD *)v3 = &off_24C255580;
  *(_QWORD *)(v3 + 120) = 0;
  *(_QWORD *)(v3 + 112) = v3 + 120;
  v4 = (uint64_t **)(v3 + 112);
  *(_QWORD *)(v3 + 128) = 0;
  *(_DWORD *)(v3 + 96) = -1;
  *(_QWORD *)(v3 + 104) = 0;
  *(_OWORD *)(v3 + 40) = 0u;
  *(_OWORD *)(v3 + 56) = 0u;
  *(_OWORD *)(v3 + 72) = 0u;
  *(_QWORD *)(v3 + 88) = 0;
  ppStmt = 0;
  v5 = sqlite3_mprintf("SELECT name FROM sqlite_master WHERE type = \"table\"");
  v6 = strlen(v5);
  sqlite3_prepare_v2(*((sqlite3 **)this + 4), v5, v6, &ppStmt, 0);
  if (v5)
    sqlite3_free(v5);
  while (1)
  {
    v7 = (CPMLLog *)sqlite3_step(ppStmt);
    if ((_DWORD)v7 != 100)
      break;
    v8 = (char *)sqlite3_column_text(ppStmt, 0);
    std::string::basic_string[abi:ne180100]<0>(__p, v8);
    v13 = __p;
    *((_DWORD *)std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(v4, (const void **)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v13)+ 14) = 1;
    if (v11 < 0)
      operator delete(__p[0]);
  }
  if ((_DWORD)v7 != 101)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v7);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLDBSerialization", "Serializer: Error iterating rows\n");
  }
  sqlite3_finalize(ppStmt);
}

void sub_209CE3104(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, void *__p, uint64_t a10, int a11, __int16 a12, char a13, char a14)
{
  uint64_t v14;
  uint64_t v15;

  std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::destroy(v15, *(char **)(v14 + 120));
  CPMLSerialization::~CPMLSerialization((CPMLSerialization *)v14);
  _Unwind_Resume(a1);
}

void CPMLDBSerialization::~CPMLDBSerialization(CPMLDBSerialization *this)
{
  int v2;
  void *v3;

  *(_QWORD *)this = &off_24C255580;
  v2 = *((_DWORD *)this + 24);
  if (v2 != -1)
  {
    close(v2);
    *((_DWORD *)this + 24) = -1;
  }
  v3 = (void *)*((_QWORD *)this + 13);
  if (v3)
    munmap(v3, *((int *)this + 25));
  std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::destroy((uint64_t)this + 112, *((char **)this + 15));
  CPMLSerialization::~CPMLSerialization((CPMLSerialization *)this);
}

{
  CPMLDBSerialization::~CPMLDBSerialization(this);
  JUMPOUT(0x20BD188E4);
}

void std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::destroy(uint64_t a1, char *a2)
{
  if (a2)
  {
    std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::destroy(a1, *(_QWORD *)a2);
    std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::destroy(a1, *((_QWORD *)a2 + 1));
    if (a2[55] < 0)
      operator delete(*((void **)a2 + 4));
    operator delete(a2);
  }
}

uint64_t *std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t **a1, const void **a2, uint64_t a3, __int128 **a4)
{
  uint64_t **v6;
  uint64_t *result;
  uint64_t *v8;
  uint64_t v9;

  v6 = (uint64_t **)std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__find_equal<std::string>((uint64_t)a1, &v9, a2);
  result = *v6;
  if (!*v6)
  {
    std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t)a1, a4, (uint64_t)&v8);
    std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__insert_node_at(a1, v9, v6, v8);
    return v8;
  }
  return result;
}

_QWORD *std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__find_equal<std::string>(uint64_t a1, _QWORD *a2, const void **a3)
{
  uint64_t v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  const void **v9;

  v5 = (_QWORD *)(a1 + 8);
  v4 = *(_QWORD *)(a1 + 8);
  if (v4)
  {
    v7 = a1 + 16;
    do
    {
      while (1)
      {
        v8 = (_QWORD *)v4;
        v9 = (const void **)(v4 + 32);
        if (!std::less<std::string>::operator()[abi:ne180100](v7, a3, (const void **)(v4 + 32)))
          break;
        v4 = *v8;
        v5 = v8;
        if (!*v8)
          goto LABEL_10;
      }
      if (!std::less<std::string>::operator()[abi:ne180100](v7, v9, a3))
        break;
      v5 = v8 + 1;
      v4 = v8[1];
    }
    while (v4);
  }
  else
  {
    v8 = (_QWORD *)(a1 + 8);
  }
LABEL_10:
  *a2 = v8;
  return v5;
}

void std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__construct_node<std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>(uint64_t a1@<X0>, __int128 **a2@<X2>, uint64_t a3@<X8>)
{
  uint64_t v5;
  char *v6;
  std::string *v7;
  __int128 *v8;
  __int128 v9;

  v5 = a1 + 8;
  v6 = (char *)operator new(0x40uLL);
  *(_QWORD *)a3 = v6;
  *(_QWORD *)(a3 + 8) = v5;
  *(_BYTE *)(a3 + 16) = 0;
  v7 = (std::string *)(v6 + 32);
  v8 = *a2;
  if (*((char *)*a2 + 23) < 0)
  {
    std::string::__init_copy_ctor_external(v7, *(const std::string::value_type **)v8, *((_QWORD *)v8 + 1));
  }
  else
  {
    v9 = *v8;
    *((_QWORD *)v6 + 6) = *((_QWORD *)v8 + 2);
    *(_OWORD *)&v7->__r_.__value_.__l.__data_ = v9;
  }
  *((_DWORD *)v6 + 14) = 0;
  *(_BYTE *)(a3 + 16) = 1;
}

void sub_209CE33E4(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  uint64_t v3;

  *v1 = 0;
  std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,int>,void *>>>::operator()[abi:ne180100](v3, v2);
  _Unwind_Resume(a1);
}

uint64_t *std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__insert_node_at(uint64_t **a1, uint64_t a2, uint64_t **a3, uint64_t *a4)
{
  uint64_t *v5;
  uint64_t *result;

  *a4 = 0;
  a4[1] = 0;
  a4[2] = a2;
  *a3 = a4;
  v5 = (uint64_t *)**a1;
  if (v5)
  {
    *a1 = v5;
    a4 = *a3;
  }
  result = std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(a1[1], a4);
  a1[2] = (uint64_t *)((char *)a1[2] + 1);
  return result;
}

BOOL std::less<std::string>::operator()[abi:ne180100](uint64_t a1, const void **a2, const void **a3)
{
  int v3;
  int v4;
  size_t v5;
  const void *v6;
  size_t v7;
  const void *v8;
  size_t v9;
  int v10;

  v3 = *((char *)a3 + 23);
  v4 = *((char *)a2 + 23);
  if (v4 >= 0)
    v5 = *((unsigned __int8 *)a2 + 23);
  else
    v5 = (size_t)a2[1];
  if (v4 >= 0)
    v6 = a2;
  else
    v6 = *a2;
  if (v3 >= 0)
    v7 = *((unsigned __int8 *)a3 + 23);
  else
    v7 = (size_t)a3[1];
  if (v3 >= 0)
    v8 = a3;
  else
    v8 = *a3;
  if (v7 >= v5)
    v9 = v5;
  else
    v9 = v7;
  v10 = memcmp(v6, v8, v9);
  if (v10)
    return v10 < 0;
  else
    return v5 < v7;
}

void std::string::__init_copy_ctor_external(std::string *this, const std::string::value_type *__s, std::string::size_type __sz)
{
  std::string *v5;
  std::string::size_type v6;
  std::string::size_type v7;
  std::string *v8;

  v5 = this;
  if (__sz > 0x16)
  {
    if (__sz >= 0x7FFFFFFFFFFFFFF8)
      std::string::__throw_length_error[abi:ne180100]();
    v6 = (__sz & 0xFFFFFFFFFFFFFFF8) + 8;
    if ((__sz | 7) != 0x17)
      v6 = __sz | 7;
    v7 = v6 + 1;
    v8 = (std::string *)operator new(v6 + 1);
    v5->__r_.__value_.__l.__size_ = __sz;
    v5->__r_.__value_.__r.__words[2] = v7 | 0x8000000000000000;
    v5->__r_.__value_.__r.__words[0] = (std::string::size_type)v8;
    v5 = v8;
  }
  else
  {
    *((_BYTE *)&this->__r_.__value_.__s + 23) = __sz;
  }
  memmove(v5, __s, __sz + 1);
}

uint64_t *std::__tree_balance_after_insert[abi:ne180100]<std::__tree_node_base<void *> *>(uint64_t *result, uint64_t *a2)
{
  uint64_t *v2;
  uint64_t *v3;
  uint64_t *v4;
  _BYTE *v5;
  int v6;
  uint64_t v7;
  int v8;
  uint64_t **v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  *((_BYTE *)a2 + 24) = a2 == result;
  if (a2 != result)
  {
    do
    {
      v2 = (uint64_t *)a2[2];
      if (*((_BYTE *)v2 + 24))
        return result;
      v3 = (uint64_t *)v2[2];
      v4 = (uint64_t *)*v3;
      if ((uint64_t *)*v3 == v2)
      {
        v7 = v3[1];
        if (!v7 || (v8 = *(unsigned __int8 *)(v7 + 24), v5 = (_BYTE *)(v7 + 24), v8))
        {
          if ((uint64_t *)*v2 == a2)
          {
            v9 = (uint64_t **)a2[2];
          }
          else
          {
            v9 = (uint64_t **)v2[1];
            v10 = *v9;
            v2[1] = (uint64_t)*v9;
            if (v10)
            {
              v10[2] = (uint64_t)v2;
              v3 = (uint64_t *)v2[2];
            }
            v9[2] = v3;
            *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = v9;
            *v9 = v2;
            v2[2] = (uint64_t)v9;
            v3 = v9[2];
            v2 = (uint64_t *)*v3;
          }
          *((_BYTE *)v9 + 24) = 1;
          *((_BYTE *)v3 + 24) = 0;
          v13 = v2[1];
          *v3 = v13;
          if (v13)
            *(_QWORD *)(v13 + 16) = v3;
          v2[2] = v3[2];
          *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
          v2[1] = (uint64_t)v3;
          goto LABEL_27;
        }
      }
      else if (!v4 || (v6 = *((unsigned __int8 *)v4 + 24), v5 = v4 + 3, v6))
      {
        if ((uint64_t *)*v2 == a2)
        {
          v11 = a2[1];
          *v2 = v11;
          if (v11)
          {
            *(_QWORD *)(v11 + 16) = v2;
            v3 = (uint64_t *)v2[2];
          }
          a2[2] = (uint64_t)v3;
          *(_QWORD *)(v2[2] + 8 * (*(_QWORD *)v2[2] != (_QWORD)v2)) = a2;
          a2[1] = (uint64_t)v2;
          v2[2] = (uint64_t)a2;
          v3 = (uint64_t *)a2[2];
        }
        else
        {
          a2 = (uint64_t *)a2[2];
        }
        *((_BYTE *)a2 + 24) = 1;
        *((_BYTE *)v3 + 24) = 0;
        v2 = (uint64_t *)v3[1];
        v12 = *v2;
        v3[1] = *v2;
        if (v12)
          *(_QWORD *)(v12 + 16) = v3;
        v2[2] = v3[2];
        *(_QWORD *)(v3[2] + 8 * (*(_QWORD *)v3[2] != (_QWORD)v3)) = v2;
        *v2 = (uint64_t)v3;
LABEL_27:
        v3[2] = (uint64_t)v2;
        return result;
      }
      *((_BYTE *)v2 + 24) = 1;
      a2 = v3;
      *((_BYTE *)v3 + 24) = v3 == result;
      *v5 = 1;
    }
    while (v3 != result);
  }
  return result;
}

void std::__tree_node_destructor<std::allocator<std::__tree_node<std::__value_type<std::string,int>,void *>>>::operator()[abi:ne180100](uint64_t a1, void **__p)
{
  if (*(_BYTE *)(a1 + 8))
  {
    if (*((char *)__p + 55) < 0)
      operator delete(__p[4]);
  }
  else if (!__p)
  {
    return;
  }
  operator delete(__p);
}

CPMLAnalysisHandler *CPMLCreateGMMAnalysis(int a1, int a2, int *a3, double *a4, double *a5, double *a6, double *a7, double *a8, CPMLTunableData *a9)
{
  CPGMMClassfier *v17;
  CPMLAnalysisHandler *v18;

  v17 = (CPGMMClassfier *)operator new();
  CPGMMClassfier::CPGMMClassfier(v17, a1, a2, a3, a4, a5, a6, a7, a8, a9);
  v18 = (CPMLAnalysisHandler *)operator new();
  CPMLAnalysisHandler::CPMLAnalysisHandler(v18);
  *(_QWORD *)v18 = off_24C255780;
  *((_QWORD *)v18 + 1) = v17;
  return v18;
}

void sub_209CE3800(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x20BD188E4](v2, 0xA1C4034F8F590);
  _Unwind_Resume(a1);
}

void CPMLGMMAnalysisHandler::CPMLGMMAnalysisHandler(CPMLGMMAnalysisHandler *this, CPMLAlgorithm *a2)
{
  _QWORD *v3;

  CPMLAnalysisHandler::CPMLAnalysisHandler(this);
  *v3 = off_24C255780;
  v3[1] = a2;
}

_QWORD *CPMLDestroyGMMAnalysis(_QWORD *result)
{
  void *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    *result = off_24C255780;
    v2 = result[1];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    CPModelClose(v1);
    JUMPOUT(0x20BD188E4);
  }
  return result;
}

void CPMLGMMAnalysisHandler::~CPMLGMMAnalysisHandler(CPMLGMMAnalysisHandler *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24C255780;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPModelClose(this);
}

double CPMLGMMAnalysisHandler::classify(CPMLGMMAnalysisHandler *this, int a2, double *a3)
{
  uint64_t v4;
  CPMLFeatureVector *v6;
  double v7;
  double YHat;

  LODWORD(v4) = a2;
  v6 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v6);
  if ((int)v4 >= 1)
  {
    v4 = v4;
    do
    {
      v7 = *a3++;
      CPMLFeatureVector::insertRealVClass(v6, v7);
      --v4;
    }
    while (v4);
  }
  (*(void (**)(_QWORD, CPMLFeatureVector *, _QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1), v6, 0);
  YHat = CPMLFeatureVector::getYHat(v6);
  CPMLFeatureVector::~CPMLFeatureVector(v6);
  MEMORY[0x20BD188E4]();
  return YHat;
}

void sub_209CE39C8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x1020C4087C48359);
  _Unwind_Resume(a1);
}

double CPMLGMMAnalysisHandler::regression(CPMLGMMAnalysisHandler *this, int a2, double *a3)
{
  return nan("");
}

uint64_t CPMLsql_callbackDBResponse(CPMLLog *a1, int a2, char **a3, char **a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(a1);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_callbackDBResponse", "CB response3");
  return 0;
}

uint64_t CPMLsql_stepAndFinalize(sqlite3_stmt *a1)
{
  uint64_t v2;
  uint64_t v3;
  pthread_mutex_t *CPMLLog;

  v2 = sqlite3_step(a1);
  v3 = v2;
  if ((_DWORD)v2 != 101)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)v2);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_stepAndFinalize", "%s %d", "Error step", v3);
    v3 = 0xFFFFFFFFLL;
  }
  sqlite3_finalize(a1);
  return v3;
}

uint64_t CPMLsql_dropTableCommand(sqlite3 *a1, char *a2)
{
  uint64_t result;
  pthread_mutex_t *CPMLLog;
  char *errmsg;
  char __s1[264];
  uint64_t v7;

  v7 = *MEMORY[0x24BDAC8D0];
  strcpy(__s1, "DROP TABLE IF EXISTS ");
  strcat(__s1, a2);
  errmsg = 0;
  result = sqlite3_exec(a1, __s1, (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, a1, &errmsg);
  if ((_DWORD)result)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)result);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_dropTableCommand", "SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CPMLsql_getRowCountForTable(sqlite3 *a1, char *a2)
{
  char *v3;
  int v4;
  CPMLLog *v5;
  int v6;
  pthread_mutex_t *CPMLLog;
  CPMLLog *v8;
  int v9;
  uint64_t v10;
  pthread_mutex_t *v11;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  v3 = sqlite3_mprintf("select count (*) from %q", a2);
  v4 = strlen(v3);
  v5 = (CPMLLog *)sqlite3_prepare_v2(a1, v3, v4, &ppStmt, 0);
  if ((_DWORD)v5)
  {
    v6 = (int)v5;
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v5);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_getRowCountForTable", "%s %d \n", "prepare fail", v6);
  }
  v8 = (CPMLLog *)sqlite3_step(ppStmt);
  if ((_DWORD)v8 != 101)
  {
    v9 = (int)v8;
    if ((_DWORD)v8 == 100)
    {
      v10 = sqlite3_column_int(ppStmt, 0);
      goto LABEL_8;
    }
    v11 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v8);
    CPMLLog::log(v11, CPML_LOG_ERR, "CPMLsql_getRowCountForTable", "Error iterating rows %d\n", v9);
  }
  v10 = 0;
LABEL_8:
  sqlite3_finalize(ppStmt);
  if (v3)
    sqlite3_free(v3);
  return v10;
}

uint64_t CPMLsql_createTable(sqlite3 *a1, char *a2, char *__s, char a4)
{
  size_t v8;
  CPMLLog *v9;
  pthread_mutex_t *v10;
  uint64_t v11;
  char *v12;
  int v13;
  CPMLLog *v14;
  int v15;
  pthread_mutex_t *CPMLLog;
  char *v17;
  int v18;
  CPMLLog *v19;
  int v20;
  pthread_mutex_t *v21;
  unsigned int v22;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  v8 = strlen(__s);
  v9 = (CPMLLog *)strlen(a2);
  if ((unint64_t)v9 + v8 < 0x101)
  {
    if ((a4 & 1) == 0)
    {
      v12 = sqlite3_mprintf("DROP TABLE IF EXISTS %q;", a2);
      v13 = strlen(v12);
      v14 = (CPMLLog *)sqlite3_prepare_v2(a1, v12, v13, &ppStmt, 0);
      if ((_DWORD)v14)
      {
        v15 = (int)v14;
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v14);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_createTable", "%s %d \n", "prepare fail", v15);
      }
      CPMLsql_stepAndFinalize(ppStmt);
      if (v12)
        sqlite3_free(v12);
    }
    v17 = sqlite3_mprintf("CREATE TABLE IF NOT EXISTS %q (%q, pKey INTEGER PRIMARY KEY);", a2, __s);
    v18 = strlen(v17);
    v19 = (CPMLLog *)sqlite3_prepare_v2(a1, v17, v18, &ppStmt, 0);
    if ((_DWORD)v19)
    {
      v20 = (int)v19;
      v21 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v19);
      CPMLLog::log(v21, CPML_LOG_ERR, "CPMLsql_createTable", "%s %d \n", "prepare fail", v20);
    }
    v22 = CPMLsql_stepAndFinalize(ppStmt);
    if (v22 == 101)
      v11 = 0;
    else
      v11 = v22;
    if (v17)
      sqlite3_free(v17);
  }
  else
  {
    v10 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
    CPMLLog::log(v10, CPML_LOG_ERR, "CPMLsql_createTable", "command too long.");
    return 0xFFFFFFFFLL;
  }
  return v11;
}

uint64_t CPMLsql_insertIntoTable(sqlite3 *a1, char *a2, char *__s, char *a4)
{
  size_t v8;
  size_t v9;
  CPMLLog *v10;
  pthread_mutex_t *v11;
  uint64_t v12;
  char *v13;
  int v14;
  CPMLLog *v15;
  int v16;
  pthread_mutex_t *CPMLLog;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  v8 = strlen(__s);
  v9 = strlen(a2) + v8;
  v10 = (CPMLLog *)strlen(a4);
  if ((unint64_t)v10 + v9 < 0x201)
  {
    v13 = sqlite3_mprintf("INSERT INTO %q (%q) values(%q);", a2, __s, a4);
    v14 = strlen(v13);
    v15 = (CPMLLog *)sqlite3_prepare_v2(a1, v13, v14, &ppStmt, 0);
    if ((_DWORD)v15)
    {
      v16 = (int)v15;
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v15);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_insertIntoTable", "%s %d \n", "prepare fail", v16);
    }
    v12 = CPMLsql_stepAndFinalize(ppStmt);
    if (v13)
      sqlite3_free(v13);
  }
  else
  {
    v11 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(v11, CPML_LOG_ERR, "CPMLsql_insertIntoTable", "command too long.");
    return 0xFFFFFFFFLL;
  }
  return v12;
}

uint64_t CPMLsql_insertBlobIntoTable(sqlite3 *a1, char *a2, char *a3, char *a4, int a5, void *a6, int a7)
{
  char *v11;
  int v12;
  CPMLLog *v13;
  int v14;
  pthread_mutex_t *CPMLLog;
  uint64_t v16;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  v11 = sqlite3_mprintf("INSERT INTO %q (%q) values(%q);", a2, a3, a4);
  v12 = strlen(v11);
  v13 = (CPMLLog *)sqlite3_prepare_v2(a1, v11, v12, &ppStmt, 0);
  if ((_DWORD)v13)
  {
    v14 = (int)v13;
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v13);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_insertBlobIntoTable", "%s %d \n", "prepare fail", v14);
  }
  sqlite3_bind_blob(ppStmt, a5, a6, a7, (void (__cdecl *)(void *))0xFFFFFFFFFFFFFFFFLL);
  v16 = CPMLsql_stepAndFinalize(ppStmt);
  if (v11)
    sqlite3_free(v11);
  return v16;
}

uint64_t CPMLsql_cardinalityCount(sqlite3 *a1, char *a2, char *a3)
{
  char *v4;
  int v5;
  CPMLLog *v6;
  int v7;
  pthread_mutex_t *CPMLLog;
  CPMLLog *v9;
  int v10;
  uint64_t v11;
  pthread_mutex_t *v12;
  sqlite3_stmt *ppStmt;

  ppStmt = 0;
  v4 = sqlite3_mprintf("select count (DISTINCT %q) from %q;", a3, a2);
  v5 = strlen(v4);
  v6 = (CPMLLog *)sqlite3_prepare_v2(a1, v4, v5, &ppStmt, 0);
  if ((_DWORD)v6)
  {
    v7 = (int)v6;
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v6);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_cardinalityCount", "%s %d \n", "prepare fail", v7);
  }
  v9 = (CPMLLog *)sqlite3_step(ppStmt);
  if ((_DWORD)v9 != 101)
  {
    v10 = (int)v9;
    if ((_DWORD)v9 == 100)
    {
      v11 = sqlite3_column_int(ppStmt, 0);
      goto LABEL_8;
    }
    v12 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
    CPMLLog::log(v12, CPML_LOG_ERR, "CPMLsql_cardinalityCount", "Error iterating rows %d\n", v10);
  }
  v11 = 0;
LABEL_8:
  sqlite3_finalize(ppStmt);
  if (v4)
    sqlite3_free(v4);
  return v11;
}

CPMLLog *CPMLsql_beginTransaction(sqlite3 *a1, unsigned int a2)
{
  CPMLLog *v2;
  CPMLLog *v3;
  pthread_mutex_t *CPMLLog;
  char *errmsg;

  errmsg = 0;
  if (a2 > 2)
    return 0;
  v2 = (CPMLLog *)sqlite3_exec(a1, off_24C2563E0[a2], (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, 0, &errmsg);
  v3 = v2;
  if ((_DWORD)v2)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v2);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_beginTransaction", "SQL Begin TransactionError %s.", errmsg);
    sqlite3_free(errmsg);
  }
  return v3;
}

CPMLLog *CPMLsql_commitTransaction(sqlite3 *a1)
{
  CPMLLog *v1;
  CPMLLog *v2;
  pthread_mutex_t *CPMLLog;
  char *errmsg;

  errmsg = 0;
  v1 = (CPMLLog *)sqlite3_exec(a1, "END TRANSACTION", (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, 0, &errmsg);
  v2 = v1;
  if ((_DWORD)v1)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v1);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "CPMLsql_commitTransaction", "SQL End TransactionError %s.", errmsg);
    sqlite3_free(errmsg);
  }
  return v2;
}

id CPMLconvertFV2Array(CPMLFeatureVector *a1)
{
  void *v2;
  uint64_t *IntVector;
  uint64_t v4;
  unint64_t v5;
  void *v6;
  uint64_t *RealVector;
  uint64_t v8;
  unint64_t v9;
  void *v10;

  v2 = (void *)objc_opt_new();
  IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(a1);
  v4 = *IntVector;
  if (IntVector[1] != *IntVector)
  {
    v5 = 0;
    do
    {
      v6 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithInt:", *(unsigned int *)(v4 + 4 * v5));
      objc_msgSend(v2, "addObject:", v6);

      ++v5;
      v4 = *IntVector;
    }
    while (v5 < (IntVector[1] - *IntVector) >> 2);
  }
  RealVector = (uint64_t *)CPMLFeatureVector::getRealVector(a1);
  v8 = *RealVector;
  if (RealVector[1] != *RealVector)
  {
    v9 = 0;
    do
    {
      v10 = (void *)objc_msgSend(objc_alloc(MEMORY[0x24BDD16E0]), "initWithDouble:", *(double *)(v8 + 8 * v9));
      objc_msgSend(v2, "addObject:", v10);

      ++v9;
      v8 = *RealVector;
    }
    while (v9 < (RealVector[1] - *RealVector) >> 3);
  }
  return v2;
}

void sub_209CE4324(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void CPMLAnalysisHandler::CPMLAnalysisHandler(CPMLAnalysisHandler *this)
{
  *(_QWORD *)this = &unk_24C255560;
}

uint64_t CPMLAnalysisClassify(uint64_t (***a1)(_QWORD))
{
  return (**a1)(a1);
}

uint64_t CPMLAnalysisRegressionPrediction(uint64_t a1)
{
  return (*(uint64_t (**)(uint64_t))(*(_QWORD *)a1 + 8))(a1);
}

CPMLAnalysisHandler *CPMLCreateLINEARSVMAnalysis(int *a1, CPMLTunableData *a2)
{
  CPMLLINEARSVMClassifier *v4;
  CPMLAnalysisHandler *v5;

  v4 = (CPMLLINEARSVMClassifier *)operator new();
  CPMLLINEARSVMClassifier::CPMLLINEARSVMClassifier(v4, a1, a2);
  v5 = (CPMLAnalysisHandler *)operator new();
  CPMLAnalysisHandler::CPMLAnalysisHandler(v5);
  *(_QWORD *)v5 = off_24C255BA0;
  *((_QWORD *)v5 + 1) = v4;
  return v5;
}

void sub_209CE4404(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x20BD188E4](v2, 0xA1C4034F8F590);
  _Unwind_Resume(a1);
}

void CPMLLINEARSVMAnalysisHandler::CPMLLINEARSVMAnalysisHandler(CPMLLINEARSVMAnalysisHandler *this, CPMLAlgorithm *a2)
{
  _QWORD *v3;

  CPMLAnalysisHandler::CPMLAnalysisHandler(this);
  *v3 = off_24C255BA0;
  v3[1] = a2;
}

_QWORD *CPMLDestroyLINEARSVMAnalysis(_QWORD *result)
{
  void *v1;
  uint64_t v2;

  if (result)
  {
    v1 = result;
    *result = off_24C255BA0;
    v2 = result[1];
    if (v2)
      (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
    CPModelClose(v1);
    JUMPOUT(0x20BD188E4);
  }
  return result;
}

void CPMLLINEARSVMAnalysisHandler::~CPMLLINEARSVMAnalysisHandler(CPMLLINEARSVMAnalysisHandler *this)
{
  uint64_t v2;

  *(_QWORD *)this = off_24C255BA0;
  v2 = *((_QWORD *)this + 1);
  if (v2)
    (*(void (**)(uint64_t))(*(_QWORD *)v2 + 8))(v2);
  CPModelClose(this);
}

double CPMLLINEARSVMAnalysisHandler::classify(CPMLLINEARSVMAnalysisHandler *this, int a2, double *a3)
{
  uint64_t v4;
  CPMLFeatureVector *v6;
  double v7;
  double YHat;

  LODWORD(v4) = a2;
  v6 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v6);
  if ((int)v4 >= 1)
  {
    v4 = v4;
    do
    {
      v7 = *a3++;
      CPMLFeatureVector::insertRealVClass(v6, v7);
      --v4;
    }
    while (v4);
  }
  (*(void (**)(_QWORD, CPMLFeatureVector *, _QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1), v6, 0);
  YHat = CPMLFeatureVector::getYHat(v6);
  CPMLFeatureVector::~CPMLFeatureVector(v6);
  MEMORY[0x20BD188E4]();
  return YHat;
}

void sub_209CE45CC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x1020C4087C48359);
  _Unwind_Resume(a1);
}

double CPMLLINEARSVMAnalysisHandler::regression(CPMLLINEARSVMAnalysisHandler *this, int a2, double *a3)
{
  return nan("");
}

void CPMLRemapper::CPMLRemapper(CPMLRemapper *this, sqlite3 *a2, CPMLStatistics *a3, int a4)
{
  std::vector<int> *v7;
  std::vector<int> *v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;

  *((_BYTE *)this + 2) = a4;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = a3;
  *(_WORD *)this = 0;
  v7 = (std::vector<int> *)operator new();
  std::vector<int>::vector(v7, *(int *)(*((_QWORD *)this + 2) + 124));
  *((_QWORD *)this + 3) = v7;
  v8 = (std::vector<int> *)operator new();
  std::vector<int>::vector(v8, *(int *)(*((_QWORD *)this + 2) + 124));
  *((_QWORD *)this + 4) = v8;
  v9 = *((_QWORD *)this + 2);
  if (*(int *)(v9 + 124) >= 1)
  {
    v10 = 0;
    do
    {
      *(_DWORD *)(**((_QWORD **)this + 3) + 4 * v10) = *(unsigned __int8 *)(v9 + 136);
      if (a4)
      {
        v11 = sqlite3_mprintf("INDEX%d ", *(_DWORD *)(*(_QWORD *)(v9 + 96) + 4 * v10));
        CPMLsql_createTable(a2, v11, "keyValue TEXT, indexValue INTEGER", 1);
        *(_DWORD *)(**((_QWORD **)this + 4) + 4 * v10) = CPMLsql_getRowCountForTable(a2, v11);
        if (v11)
          sqlite3_free(v11);
      }
      else
      {
        *(_DWORD *)(**((_QWORD **)this + 4) + 4 * v10) = 0;
      }
      ++v10;
      v9 = *((_QWORD *)this + 2);
    }
    while (v10 < *(int *)(v9 + 124));
  }
  if ((a4 & 1) == 0)
    CPMLRemapper::saveRemapper(this);
}

void sub_209CE4C38(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10C402FEFCB83);
  _Unwind_Resume(a1);
}

void CPMLRemapper::saveRemapper(CPMLRemapper *this)
{
  unsigned int v2;
  char *v3;
  char *v4;
  CPMLLog *v5;
  pthread_mutex_t *CPMLLog;
  char *errmsg;

  if (*(_DWORD *)(*((_QWORD *)this + 2) + 124))
  {
    v2 = 0;
    do
    {
      errmsg = 0;
      v3 = sqlite3_mprintf("INDEX%d ", v2);
      v4 = sqlite3_mprintf("create TABLE %q(keyValue TEXT, indexValue INT, pKey INTEGER PRIMARY KEY);", v3);
      CPMLsql_dropTableCommand(*((sqlite3 **)this + 1), v3);
      v5 = (CPMLLog *)sqlite3_exec(*((sqlite3 **)this + 1), v4, (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, this, &errmsg);
      if ((_DWORD)v5)
      {
        CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v5);
        CPMLLog::log(CPMLLog, CPML_LOG_ERR, "saveRemapper", "SQL error: %s \n", errmsg);
        sqlite3_free(errmsg);
      }
      if (v3)
        sqlite3_free(v3);
      if (v4)
        sqlite3_free(v4);
      ++v2;
    }
    while (v2 < *(_DWORD *)(*((_QWORD *)this + 2) + 124));
  }
}

void CPMLRemapper::~CPMLRemapper(CPMLRemapper *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;

  v2 = *((_QWORD *)this + 3);
  if (v2)
  {
    v3 = *(void **)v2;
    if (*(_QWORD *)v2)
    {
      *(_QWORD *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x20BD188E4](v2, 0x10C402FEFCB83);
  }
  v4 = *((_QWORD *)this + 4);
  if (v4)
  {
    v5 = *(void **)v4;
    if (*(_QWORD *)v4)
    {
      *(_QWORD *)(v4 + 8) = v5;
      operator delete(v5);
    }
    MEMORY[0x20BD188E4](v4, 0x10C402FEFCB83);
  }
}

double CPMLRemapper::normalizeColumn(CPMLRemapper *this, double result, int a3)
{
  _QWORD *v3;
  uint64_t v4;
  double v5;

  v3 = (_QWORD *)*((_QWORD *)this + 2);
  v4 = *(int *)(v3[12] + 4 * a3);
  if (*(_DWORD *)(**((_QWORD **)this + 3) + 4 * v4))
  {
    v5 = *(double *)(v3[24] + 8 * v4);
    if (v5 <= 0.0)
      v5 = 1.0;
    return (result - *(double *)(v3[21] + 8 * v4)) / v5;
  }
  return result;
}

char *CPMLRemapper::unmap(CPMLRemapper *this, int a2, int a3)
{
  int v4;
  char *v5;
  int v6;
  CPMLLog *v7;
  int v8;
  pthread_mutex_t *CPMLLog;
  CPMLLog *v10;
  int v11;
  const char *v12;
  pthread_mutex_t *v13;
  size_t v14;
  char *v15;
  sqlite3_stmt *ppStmt;

  v4 = *(_DWORD *)(*(_QWORD *)(*((_QWORD *)this + 2) + 96) + 4 * a3);
  ppStmt = 0;
  v5 = sqlite3_mprintf("select keyValue from INDEX%d where indexValue = %d; ", v4, a2);
  v6 = strlen(v5);
  v7 = (CPMLLog *)sqlite3_prepare_v2(*((sqlite3 **)this + 1), v5, v6, &ppStmt, 0);
  if ((_DWORD)v7)
  {
    v8 = (int)v7;
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v7);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "unmap", " getKeyValueWith: DB NOT OK %d\n", v8);
  }
  v10 = (CPMLLog *)sqlite3_step(ppStmt);
  if ((_DWORD)v10 != 101)
  {
    v11 = (int)v10;
    if ((_DWORD)v10 == 100)
    {
      v12 = (const char *)sqlite3_column_text(ppStmt, 0);
      goto LABEL_8;
    }
    v13 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(v13, CPML_LOG_ERR, "unmap", "getKeyValueWith: Error iterating rows %d\n", v11);
  }
  v12 = "error";
LABEL_8:
  v14 = strlen(v12) + 1;
  v15 = (char *)malloc_type_malloc(v14, 0x100004077774924uLL);
  strlcpy(v15, v12, v14);
  sqlite3_finalize(ppStmt);
  if (v5)
    sqlite3_free(v5);
  return v15;
}

uint64_t CPMLRemapper::remap(CPMLRemapper *this, char *a2, int a3)
{
  uint64_t v5;
  char *v6;
  int v7;
  CPMLLog *v8;
  int v9;
  pthread_mutex_t *CPMLLog;
  CPMLLog *v11;
  int v12;
  pthread_mutex_t *v13;
  double v14;
  char *v16;
  char *v17;
  CPMLLog *v18;
  pthread_mutex_t *v19;
  uint64_t v20;
  int v21;
  char *v22;
  CPMLLog *v23;
  pthread_mutex_t *v24;
  char *errmsg;
  sqlite3_stmt *ppStmt;

  if (!a2)
    return 0xFFFFFFFFLL;
  if (!*a2)
    return 0xFFFFFFFFLL;
  v5 = *(int *)(*(_QWORD *)(*((_QWORD *)this + 2) + 96) + 4 * a3);
  ppStmt = 0;
  v6 = sqlite3_mprintf("select indexValue from INDEX%d where keyValue='%q'; ", v5, a2);
  v7 = strlen(v6);
  v8 = (CPMLLog *)sqlite3_prepare_v2(*((sqlite3 **)this + 1), v6, v7, &ppStmt, 0);
  if ((_DWORD)v8)
  {
    v9 = (int)v8;
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v8);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "remap", "getIndexValueWith: DB NOT OK %d\n", v9);
  }
  v11 = (CPMLLog *)sqlite3_step(ppStmt);
  if ((_DWORD)v11 != 100)
  {
    v12 = (int)v11;
    if ((_DWORD)v11 != 101)
    {
      v13 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v11);
      CPMLLog::log(v13, CPML_LOG_ERR, "remap", "getIndexValueWith: Error iterating rows %d\n", v12);
    }
    sqlite3_finalize(ppStmt);
    v14 = -1.0;
LABEL_12:
    if (!*((_BYTE *)this + 2) || *(_BYTE *)this)
    {
      errmsg = 0;
      v16 = sqlite3_mprintf("INDEX%d ", v5);
      v17 = sqlite3_mprintf("insert into %q (keyValue, indexValue) VALUES('%q', %d);",
              v16,
              a2,
              *(unsigned int *)(**((_QWORD **)this + 4) + 4 * v5));
      v18 = (CPMLLog *)sqlite3_exec(*((sqlite3 **)this + 1), v17, (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, this, &errmsg);
      if ((_DWORD)v18)
      {
        v19 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v18);
        CPMLLog::log(v19, CPML_LOG_ERR, "remap", "SQL error: %s \n", errmsg);
        sqlite3_free(errmsg);
      }
      v20 = **((_QWORD **)this + 4);
      v21 = *(_DWORD *)(v20 + 4 * v5);
      *(_DWORD *)(v20 + 4 * v5) = v21 + 1;
      if (v16)
        sqlite3_free(v16);
      if (v17)
        sqlite3_free(v17);
      v14 = (double)v21;
      goto LABEL_21;
    }
LABEL_26:
    if (*((_BYTE *)this + 1))
    {
      errmsg = 0;
      v22 = sqlite3_mprintf("UPDATE cacheString SET keyValue='%q' WHERE indexValue=%d;", a2, (-10 - v5));
      v23 = (CPMLLog *)sqlite3_exec(*((sqlite3 **)this + 1), v22, (int (__cdecl *)(void *, int, char **, char **))CPMLsql_callbackDBResponse, this, &errmsg);
      if ((_DWORD)v23)
      {
        v24 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v23);
        CPMLLog::log(v24, CPML_LOG_ERR, "remap", "SQL error: %s \n", errmsg);
        sqlite3_free(errmsg);
      }
      if (v22)
        sqlite3_free(v22);
      v14 = (double)(-10 - (int)v5);
    }
    goto LABEL_21;
  }
  v14 = sqlite3_column_double(ppStmt, 0);
  sqlite3_finalize(ppStmt);
  if (v14 < 0.0)
    goto LABEL_12;
  if (*((_BYTE *)this + 2) && !*(_BYTE *)this)
    goto LABEL_26;
LABEL_21:
  if (v6)
    sqlite3_free(v6);
  return (int)v14;
}

void CPMLDBSerialization::cp_createTable(CPMLDBSerialization *this, char *a2, char *a3)
{
  void *__p[2];
  char v7;
  void **v8;

  std::string::basic_string[abi:ne180100]<0>(__p, a2);
  if ((CPMLDBSerialization *)((char *)this + 120) == (CPMLDBSerialization *)std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::find<std::string>((uint64_t)this + 112, (const void **)__p))
  {
    v8 = __p;
    *((_DWORD *)std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::__emplace_unique_key_args<std::string,std::piecewise_construct_t const&,std::tuple<std::string const&>,std::tuple<>>((uint64_t **)this + 14, (const void **)__p, (uint64_t)&std::piecewise_construct, (__int128 **)&v8)+ 14) = 1;
    CPMLsql_createTable(*((sqlite3 **)this + 4), a2, a3, 0);
  }
  else if (*(_DWORD *)(std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::find<std::string>((uint64_t)this + 112, (const void **)__p)+ 56) != 1)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s Corrupted match.\n", "cp_createTable");
  }
  if (v7 < 0)
    operator delete(__p[0]);
}

void sub_209CE5324(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11, int a12, __int16 a13, char a14, char a15)
{
  if (a15 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_insertIntoTable(sqlite3 **this, char *a2, char *a3, char *a4)
{
  return CPMLsql_insertIntoTable(this[4], a2, a3, a4);
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, int *a2, char *a3, unint64_t a4, char *a5)
{
  char *v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  char *v15;
  CPMLLog *v16;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  unsigned __int8 v20;
  std::string v21;
  char *errmsg;

  errmsg = 0;
  if (a5)
    v9 = a5;
  else
    v9 = a3;
  std::string::basic_string[abi:ne180100]<0>(&v21, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, " INTEGER");
  if ((v20 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v11 = v20;
  else
    v11 = (std::string::size_type)__p[1];
  std::string::append(&v21, (const std::string::value_type *)v10, v11);
  if ((char)v20 < 0)
    operator delete(__p[0]);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v21;
  else
    v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, char *, std::string *))*this + 33))(this, a3, v12);
  if (a4)
  {
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = sqlite3_mprintf("insert into %q (%q) VALUES(%d);", a3, v9, a2[v13]);
      v16 = (CPMLLog *)sqlite3_exec(this[4], v15, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, &errmsg);
      if ((_DWORD)v16)
        break;
      if (v15)
        sqlite3_free(v15);
      v14 = ++v13 < a4;
      if (a4 == v13)
        goto LABEL_21;
    }
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v16);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_writeDefault: SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    if (v15)
      sqlite3_free(v15);
  }
  else
  {
LABEL_21:
    v14 = 0;
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  return (v14 << 31 >> 31);
}

void sub_209CE54F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t callbackDBResponse2(CPMLLog *a1, int a2, char **a3, char **a4)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(a1);
  CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "callbackDBResponse2", "CB response2");
  return 0;
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, unsigned int *a2, char *a3, unint64_t a4, char *a5)
{
  char *v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  char *v15;
  CPMLLog *v16;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  unsigned __int8 v20;
  std::string v21;
  char *errmsg;

  errmsg = 0;
  if (a5)
    v9 = a5;
  else
    v9 = a3;
  std::string::basic_string[abi:ne180100]<0>(&v21, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, " INTEGER");
  if ((v20 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v11 = v20;
  else
    v11 = (std::string::size_type)__p[1];
  std::string::append(&v21, (const std::string::value_type *)v10, v11);
  if ((char)v20 < 0)
    operator delete(__p[0]);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v21;
  else
    v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, char *, std::string *))*this + 33))(this, a3, v12);
  if (a4)
  {
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = sqlite3_mprintf("insert into %q (%q) VALUES(%u);", a3, v9, a2[v13]);
      v16 = (CPMLLog *)sqlite3_exec(this[4], v15, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, &errmsg);
      if ((_DWORD)v16)
        break;
      if (v15)
        sqlite3_free(v15);
      v14 = ++v13 < a4;
      if (a4 == v13)
        goto LABEL_21;
    }
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v16);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_serialize_uintDefault: SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    if (v15)
      sqlite3_free(v15);
  }
  else
  {
LABEL_21:
    v14 = 0;
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  return (v14 << 31 >> 31);
}

void sub_209CE570C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, unint64_t *a2, char *a3, unint64_t a4, char *a5)
{
  char *v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  char *v15;
  CPMLLog *v16;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  unsigned __int8 v20;
  std::string v21;
  char *errmsg;

  errmsg = 0;
  if (a5)
    v9 = a5;
  else
    v9 = a3;
  std::string::basic_string[abi:ne180100]<0>(&v21, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, " INTEGER");
  if ((v20 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v20 & 0x80u) == 0)
    v11 = v20;
  else
    v11 = (std::string::size_type)__p[1];
  std::string::append(&v21, (const std::string::value_type *)v10, v11);
  if ((char)v20 < 0)
    operator delete(__p[0]);
  if ((v21.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v21;
  else
    v12 = (std::string *)v21.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, char *, std::string *))*this + 33))(this, a3, v12);
  if (a4)
  {
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = sqlite3_mprintf("insert into %q (%q) VALUES(%llu);", a3, v9, a2[v13]);
      v16 = (CPMLLog *)sqlite3_exec(this[4], v15, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, &errmsg);
      if ((_DWORD)v16)
        break;
      if (v15)
        sqlite3_free(v15);
      v14 = ++v13 < a4;
      if (a4 == v13)
        goto LABEL_21;
    }
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v16);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_serialize_uint64_tDefault: SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    if (v15)
      sqlite3_free(v15);
  }
  else
  {
LABEL_21:
    v14 = 0;
  }
  if (SHIBYTE(v21.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v21.__r_.__value_.__l.__data_);
  return (v14 << 31 >> 31);
}

void sub_209CE58F0(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, float *a2, char *a3, unint64_t a4, char *a5)
{
  char *v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  float v15;
  const char *v16;
  char *v17;
  CPMLLog *v18;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  unsigned __int8 v22;
  std::string v23;
  char *errmsg;

  errmsg = 0;
  if (a5)
    v9 = a5;
  else
    v9 = a3;
  std::string::basic_string[abi:ne180100]<0>(&v23, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, " REAL");
  if ((v22 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v22 & 0x80u) == 0)
    v11 = v22;
  else
    v11 = (std::string::size_type)__p[1];
  std::string::append(&v23, (const std::string::value_type *)v10, v11);
  if ((char)v22 < 0)
    operator delete(__p[0]);
  if ((v23.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v23;
  else
    v12 = (std::string *)v23.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, char *, std::string *))*this + 33))(this, a3, v12);
  if (a4)
  {
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = a2[v13];
      v16 = fabsf(v15) == INFINITY
          ? sqlite3_mprintf("insert into %q (%q) VALUES(NULL);", a3, v9)
          : sqlite3_mprintf("insert into %q (%q) VALUES(%f);", a3, v9, v15);
      v17 = (char *)v16;
      v18 = (CPMLLog *)sqlite3_exec(this[4], v16, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, &errmsg);
      if ((_DWORD)v18)
        break;
      if (v17)
        sqlite3_free(v17);
      v14 = ++v13 < a4;
      if (a4 == v13)
        goto LABEL_24;
    }
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v18);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_writeDefault: SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    if (v17)
      sqlite3_free(v17);
  }
  else
  {
LABEL_24:
    v14 = 0;
  }
  if (SHIBYTE(v23.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v23.__r_.__value_.__l.__data_);
  return (v14 << 31 >> 31);
}

void sub_209CE5B00(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, double *a2, char *a3, unint64_t a4, char *a5)
{
  char *v9;
  void **v10;
  std::string::size_type v11;
  std::string *v12;
  uint64_t v13;
  int v14;
  const char *v15;
  char *v16;
  CPMLLog *v17;
  pthread_mutex_t *CPMLLog;
  void *__p[2];
  unsigned __int8 v21;
  std::string v22;
  char *errmsg;

  errmsg = 0;
  if (a5)
    v9 = a5;
  else
    v9 = a3;
  std::string::basic_string[abi:ne180100]<0>(&v22, v9);
  std::string::basic_string[abi:ne180100]<0>(__p, " REAL");
  if ((v21 & 0x80u) == 0)
    v10 = __p;
  else
    v10 = (void **)__p[0];
  if ((v21 & 0x80u) == 0)
    v11 = v21;
  else
    v11 = (std::string::size_type)__p[1];
  std::string::append(&v22, (const std::string::value_type *)v10, v11);
  if ((char)v21 < 0)
    operator delete(__p[0]);
  if ((v22.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v12 = &v22;
  else
    v12 = (std::string *)v22.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, char *, std::string *))*this + 33))(this, a3, v12);
  if (a4)
  {
    v13 = 0;
    v14 = 1;
    while (1)
    {
      v15 = fabs(a2[v13]) == INFINITY
          ? sqlite3_mprintf("insert into %q (%q) VALUES(NULL);", a3, v9)
          : sqlite3_mprintf("insert into %q (%q) VALUES(%lf);", a3, v9, *(_QWORD *)&a2[v13]);
      v16 = (char *)v15;
      v17 = (CPMLLog *)sqlite3_exec(this[4], v15, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, &errmsg);
      if ((_DWORD)v17)
        break;
      if (v16)
        sqlite3_free(v16);
      v14 = ++v13 < a4;
      if (a4 == v13)
        goto LABEL_24;
    }
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v17);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_writeDefault: SQL error: %s \n", errmsg);
    sqlite3_free(errmsg);
    if (v16)
      sqlite3_free(v16);
  }
  else
  {
LABEL_24:
    v14 = 0;
  }
  if (SHIBYTE(v22.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v22.__r_.__value_.__l.__data_);
  return (v14 << 31 >> 31);
}

void sub_209CE5D0C(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, int a14, __int16 a15, char a16, char a17, void *__p, uint64_t a19, int a20,__int16 a21,char a22,char a23)
{
  if (a23 < 0)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_write(sqlite3 **this, char *a2, const char *a3, uint64_t a4, const char *a5)
{
  size_t v8;
  char *v9;
  char *v10;
  uint64_t v11;
  char *v12;
  char *v13;
  const std::string::value_type *v14;
  std::string::size_type v15;
  std::string *v16;
  char *v17;
  CPMLLog *v18;
  pthread_mutex_t *CPMLLog;
  uint64_t v20;
  void *v22[2];
  unsigned __int8 v23;
  std::string v24;
  char *errmsg[2];

  errmsg[1] = *(char **)MEMORY[0x24BDAC8D0];
  errmsg[0] = 0;
  v8 = a4 + 1;
  MEMORY[0x24BDAC7A8](this, a2);
  v12 = (char *)v22 - ((v11 + 16) & 0xFFFFFFFFFFFFFFF0);
  if (v10)
    v13 = v10;
  else
    v13 = v9;
  std::string::basic_string[abi:ne180100]<0>(&v24, v13);
  std::string::basic_string[abi:ne180100]<0>(v22, " TEXT");
  if ((v23 & 0x80u) == 0)
    v14 = (const std::string::value_type *)v22;
  else
    v14 = (const std::string::value_type *)v22[0];
  if ((v23 & 0x80u) == 0)
    v15 = v23;
  else
    v15 = (std::string::size_type)v22[1];
  std::string::append(&v24, v14, v15);
  if ((char)v23 < 0)
    operator delete(v22[0]);
  if ((v24.__r_.__value_.__r.__words[2] & 0x8000000000000000) == 0)
    v16 = &v24;
  else
    v16 = (std::string *)v24.__r_.__value_.__r.__words[0];
  (*((void (**)(sqlite3 **, const char *, std::string *))*this + 33))(this, a3, v16);
  strlcpy(v12, a2, v8);
  v17 = sqlite3_mprintf("insert into %q (%q) VALUES('%q');", a3, v13, v12);
  v18 = (CPMLLog *)sqlite3_exec(this[4], v17, (int (__cdecl *)(void *, int, char **, char **))callbackDBResponse2, this, errmsg);
  if ((_DWORD)v18)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v18);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_write", "cp_writeDefault: SQL error: %s \n", errmsg[0]);
    sqlite3_free(errmsg[0]);
    if (v17)
      sqlite3_free(v17);
    v20 = 0xFFFFFFFFLL;
  }
  else
  {
    if (v17)
      sqlite3_free(v17);
    v20 = 0;
  }
  if (SHIBYTE(v24.__r_.__value_.__r.__words[2]) < 0)
    operator delete(v24.__r_.__value_.__l.__data_);
  return v20;
}

void sub_209CE5F34(_Unwind_Exception *exception_object)
{
  uint64_t v1;

  if (*(char *)(v1 - 105) < 0)
    operator delete(*(void **)(v1 - 128));
  if (*(char *)(v1 - 81) < 0)
    operator delete(*(void **)(v1 - 104));
  _Unwind_Resume(exception_object);
}

uint64_t CPMLDBSerialization::cp_doSerialization(CPMLDBSerialization *this)
{
  return 0;
}

uint64_t CPMLDBSerialization::reset(CPMLDBSerialization *this)
{
  pthread_mutex_t *CPMLLog;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(this);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "reset", "%s unimplmented function.", "reset");
  return 0xFFFFFFFFLL;
}

uint64_t std::__tree<std::__value_type<std::string,int>,std::__map_value_compare<std::string,std::__value_type<std::string,int>,std::less<std::string>,true>,std::allocator<std::__value_type<std::string,int>>>::find<std::string>(uint64_t a1, const void **a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t *v8;

  v2 = a1 + 8;
  v3 = *(_QWORD *)(a1 + 8);
  if (!v3)
    return v2;
  v5 = a1 + 16;
  v6 = a1 + 8;
  do
  {
    v7 = std::less<std::string>::operator()[abi:ne180100](v5, (const void **)(v3 + 32), a2);
    v8 = (uint64_t *)(v3 + 8);
    if (!v7)
    {
      v8 = (uint64_t *)v3;
      v6 = v3;
    }
    v3 = *v8;
  }
  while (*v8);
  if (v6 == v2 || std::less<std::string>::operator()[abi:ne180100](v5, a2, (const void **)(v6 + 32)))
    return v2;
  return v6;
}

void sub_209CE6C74(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, _Unwind_Exception *exception_object)
{
  void *v13;
  void *v14;
  void *v15;
  uint64_t v16;

  MEMORY[0x20BD188E4](v16, 0x10A1C405A95AE37);

  _Unwind_Resume(a1);
}

void sub_209CE6FE4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE7078(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE72B8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CE7358(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE741C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

void sub_209CE75A4(_Unwind_Exception *a1)
{
  void *v1;

  _Unwind_Resume(a1);
}

void sub_209CE7764(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void sub_209CE7840(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CE7BF0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  void *v10;
  void *v11;

  _Unwind_Resume(a1);
}

void sub_209CE8148(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;
  void *v4;
  void *v5;

  _Unwind_Resume(a1);
}

void sub_209CE8660(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10B1C4066637EEELL);
  _Unwind_Resume(a1);
}

void sub_209CE88F8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  void *v10;

  _Unwind_Resume(a1);
}

void sub_209CE8ABC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, uint64_t a16, uint64_t a17, ...)
{
  void *v17;
  void *v18;
  uint64_t v19;
  uint64_t v20;
  va_list va;

  va_start(va, a17);
  MEMORY[0x20BD188E4](v19, 0x1090C40B6130435);

  _Block_object_dispose(va, 8);
  _Block_object_dispose((const void *)(v20 - 112), 8);

  _Unwind_Resume(a1);
}

void sub_209CE8B8C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A759441BLL);
  _Unwind_Resume(a1);
}

void sub_209CE8F10(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;

  MEMORY[0x20BD188E4](v10, 0x10A1C4021AD9D2ELL);

  _Unwind_Resume(a1);
}

void sub_209CE9004(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  uint64_t v10;

  MEMORY[0x20BD188E4](v10, 0x80C40803F642BLL);

  _Unwind_Resume(a1);
}

void CPMLOnlineSvm::CPMLOnlineSvm(CPMLOnlineSvm *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v5;
  _QWORD *v6;
  uint64_t *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  char v14[32];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v5 = &off_24C255288;
  *(_OWORD *)(v5 + 96) = 0u;
  *(_OWORD *)(v5 + 112) = 0u;
  *(_OWORD *)(v5 + 128) = 0u;
  *(_DWORD *)(v5 + 144) = 1;
  *(_DWORD *)(v5 + 152) = 2;
  *(_OWORD *)(v5 + 160) = xmmword_209D001F0;
  *(_QWORD *)(v5 + 176) = 0x186A000000001;
  *(_OWORD *)(v5 + 184) = xmmword_209D00200;
  *(_OWORD *)(v5 + 200) = xmmword_209D00210;
  *(_OWORD *)(v5 + 232) = 0u;
  v6 = (_QWORD *)(v5 + 312);
  v7 = (uint64_t *)(v5 + 336);
  *(_OWORD *)(v5 + 248) = 0u;
  *(_QWORD *)(v5 + 296) = 0;
  *(_OWORD *)(v5 + 264) = 0u;
  *(_OWORD *)(v5 + 280) = 0u;
  *(_OWORD *)(v5 + 312) = 0u;
  *(_OWORD *)(v5 + 328) = 0u;
  *(_OWORD *)(v5 + 344) = 0u;
  *(_OWORD *)(v5 + 360) = 0u;
  *(_OWORD *)(v5 + 376) = 0u;
  *(_OWORD *)(v5 + 392) = 0u;
  *(_QWORD *)(v5 + 448) = 0;
  *(_OWORD *)(v5 + 416) = 0u;
  *(_OWORD *)(v5 + 432) = 0u;
  *(_OWORD *)(v5 + 488) = 0u;
  *(_OWORD *)(v5 + 504) = 0u;
  *(_OWORD *)(v5 + 472) = 0u;
  (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, v5 + 8, "version", 5, 0);
  v13 = 0;
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, (char *)&v13 + 4, "num_feature", 1, 0);
  (*((void (**)(CPMLSerialization *, uint64_t *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, &v13, "num_sv", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, (char *)this + 304, "bias_", 1, 0);
  std::vector<double>::resize((uint64_t)v6, (int)v13);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *v6, "alphas_", (int)v13, 0);
  std::vector<std::valarray<double>>::resize(v7, (int)v13);
  if ((int)v13 >= 1)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      std::valarray<double>::resize(*v7 + v8, SHIDWORD(v13), 0.0);
      ++v9;
      v8 += 16;
    }
    while (v9 < (int)v13);
    if ((int)v13 >= 1)
    {
      v10 = 0;
      do
      {
        sprintf(v14, "support_vectors_%d", v10);
        if (SHIDWORD(v13) >= 1)
        {
          v11 = 0;
          v12 = 0;
          do
          {
            (*((void (**)(CPMLSerialization *, uint64_t, char *, uint64_t, uint64_t))a2->var0 + 12))(a2, *(_QWORD *)(*v7 + 16 * v10) + v11, v14, 1, v12++);
            v11 += 8;
          }
          while (v12 < SHIDWORD(v13));
        }
        ++v10;
      }
      while (v10 < (int)v13);
    }
  }
  *((_DWORD *)this + 38) = 0;
  *((_OWORD *)this + 10) = xmmword_209D001F0;
}

void sub_209CE93A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, _QWORD *a10, uint64_t a11, uint64_t a12, uint64_t a13, void **a14)
{
  uint64_t v14;
  void **v15;
  uint64_t v16;
  void **v17;
  void *v19;
  void *v20;
  void *v21;
  void *v22;
  void *v23;

  std::valarray<double>::~valarray(v14 + 504);
  std::valarray<double>::~valarray(v14 + 488);
  std::valarray<double>::~valarray(v16);
  v19 = *(void **)(v14 + 432);
  if (v19)
  {
    *(_QWORD *)(v14 + 440) = v19;
    operator delete(v19);
  }
  std::valarray<double>::~valarray(v14 + 416);
  v20 = *(void **)(v14 + 384);
  if (v20)
  {
    *(_QWORD *)(v14 + 392) = v20;
    operator delete(v20);
  }
  v21 = *(void **)(v14 + 360);
  if (v21)
  {
    *(_QWORD *)(v14 + 368) = v21;
    operator delete(v21);
  }
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100](&a14);
  v22 = *v15;
  if (*v15)
  {
    *(_QWORD *)(v14 + 320) = v22;
    operator delete(v22);
  }
  a14 = (void **)(v14 + 280);
  std::vector<std::valarray<char>>::__destroy_vector::operator()[abi:ne180100](&a14);
  a14 = (void **)(v14 + 256);
  std::vector<std::valarray<double>>::__destroy_vector::operator()[abi:ne180100](&a14);
  v23 = *v17;
  if (*v17)
  {
    *(_QWORD *)(v14 + 240) = v23;
    operator delete(v23);
  }
  if (*(_QWORD *)(v14 + 136))
  {
    if (*a10)
      MEMORY[0x20BD188CC](*a10, 0x1000C8000313F17);
  }
  CPModelClose((void *)v14);
  _Unwind_Resume(a1);
}

void std::vector<std::valarray<double>>::resize(uint64_t *a1, unint64_t a2)
{
  uint64_t v3;
  unint64_t v4;
  uint64_t v5;

  v3 = a1[1];
  v4 = (v3 - *a1) >> 4;
  if (a2 <= v4)
  {
    if (a2 < v4)
    {
      v5 = *a1 + 16 * a2;
      while (v3 != v5)
      {
        v3 -= 16;
        std::allocator<std::valarray<double>>::destroy[abi:ne180100]((uint64_t)(a1 + 2), v3);
      }
      a1[1] = v5;
    }
  }
  else
  {
    std::vector<std::valarray<double>>::__append(a1, a2 - v4);
  }
}

void std::vector<std::valarray<double>>::__append(uint64_t *a1, unint64_t a2)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  void *v14;
  char *v15;
  char *v16;
  char *v17;
  uint64_t v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(_QWORD *)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - *a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - *a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    v18 = v4;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(v4, v12);
    else
      v13 = 0;
    v14 = v13;
    v15 = &v13[16 * v10];
    v17 = &v13[16 * v12];
    bzero(v15, 16 * a2);
    v16 = &v15[16 * a2];
    std::vector<std::valarray<double>>::__swap_out_circular_buffer(a1, &v14);
    std::__split_buffer<std::valarray<double>>::~__split_buffer(&v14);
  }
}

void sub_209CE9604(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::__split_buffer<std::valarray<double>>::~__split_buffer((void **)va);
  _Unwind_Resume(a1);
}

void CPLinearRegressionClassfier::CPLinearRegressionClassfier(CPLinearRegressionClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v6 = &off_24C255AB0;
  *(_DWORD *)(v6 + 104) = *((_DWORD *)a2->var0 + 31) - 1;
  *(_DWORD *)(v6 + 96) = 1;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPLinearRegressionClassfier::initializeLinearRegressionMemory(this);
}

void sub_209CE9684(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

pthread_mutex_t *CPLinearRegressionClassfier::initializeLinearRegressionMemory(CPLinearRegressionClassfier *this)
{
  int v2;
  int v3;
  int v4;
  int v5;
  double v6;
  int v7;
  int v8;
  double v9;
  long double v10;
  long double v11;
  int v12;
  uint64_t v13;
  int v14;
  int v15;
  int *v16;
  uint64_t v17;
  int v18;
  pthread_mutex_t *result;
  pthread_mutex_t *CPMLLog;

  v2 = *((_DWORD *)this + 24);
  v3 = *((_DWORD *)this + 26);
  if (v2 < 2)
  {
    v15 = v3 + 1;
    *((_DWORD *)this + 25) = v15;
    *((_QWORD *)this + 15) = 0;
LABEL_11:
    *((_QWORD *)this + 14) = malloc_type_calloc(v15, 8uLL, 0x100004000313F17uLL);
    result = (pthread_mutex_t *)malloc_type_calloc(*((int *)this + 25), 8uLL, 0x100004000313F17uLL);
    *((_QWORD *)this + 16) = result;
    return result;
  }
  v4 = 0;
  v5 = 0;
  v6 = (double)v3;
  v7 = v2 - 1;
  v8 = v3 + 2;
  do
  {
    v9 = lgamma((double)(v8 + v4));
    v10 = v9 - lgamma((double)(v4 + 3));
    v11 = lgamma(v6);
    v5 += (int)(exp(v10 - v11) + 0.5);
    ++v4;
  }
  while (v7 != v4);
  v12 = *((_DWORD *)this + 26);
  *((_DWORD *)this + 25) = v5 + v12 + 1;
  v13 = (uint64_t)malloc_type_calloc(v12 * v5, 4uLL, 0x100004052888210uLL);
  *((_QWORD *)this + 15) = v13;
  if (*((int *)this + 24) >= 2)
  {
    v16 = (int *)v13;
    v14 = 0;
    v17 = *((unsigned int *)this + 26);
    v18 = 1;
    do
    {
      v13 = fillDegrees(v16, v17, v17, ++v18);
      v17 = *((unsigned int *)this + 26);
      v16 += (int)v17 * (int)v13;
      v14 += v13;
    }
    while (v18 < *((_DWORD *)this + 24));
  }
  else
  {
    v14 = 0;
  }
  if (v14 == v5)
  {
    v15 = *((_DWORD *)this + 25);
    goto LABEL_11;
  }
  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)v13);
  return CPMLLog::log(CPMLLog, CPML_LOG_ERR, "initializeLinearRegressionMemory", "PROGRAMMING ERROR. Computation of degree two coefficients has mismatch. Expect a crash.");
}

void CPLinearRegressionClassfier::CPLinearRegressionClassfier(CPLinearRegressionClassfier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  _QWORD *v5;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *v5 = &off_24C255AB0;
  (*((void (**)(CPMLSerialization *, _QWORD *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, v5 + 12, "maxDegree", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, (char *)this + 104, "numberInputFeatures", 1, 0);
  CPLinearRegressionClassfier::initializeLinearRegressionMemory(this);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 14), "coefficients", *((int *)this + 25), 0);
}

void sub_209CE991C(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPLinearRegressionClassfier::~CPLinearRegressionClassfier(void **this)
{
  void *v2;

  *this = &off_24C255AB0;
  free(this[14]);
  free(this[16]);
  v2 = this[15];
  if (v2)
    free(v2);
  CPModelClose(this);
}

{
  CPLinearRegressionClassfier::~CPLinearRegressionClassfier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPLinearRegressionClassfier::serialize(CPLinearRegressionClassfier *this)
{
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), (char *)this + 96, "maxDegree", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), (char *)this + 104, "numberInputFeatures", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 14), "coefficients", *((int *)this + 25), 0);
  return 0;
}

uint64_t CPLinearRegressionClassfier::train(CPLinearRegressionClassfier *this)
{
  uint64_t v2;
  int v3;
  long double *v4;
  char *v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  CPMLFeatureVector *v9;
  long double *v10;
  uint64_t *RealVector;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t i;
  double v18;
  __CLPK_doublereal *v19;
  __CLPK_doublereal *v20;
  uint64_t v21;
  uint64_t v22;
  double *v23;
  uint64_t v24;
  uint64_t v25;
  double v26;
  int v27;
  long double *v28;
  CPMLLog *v29;
  pthread_mutex_t *CPMLLog;
  uint64_t v31;
  void *v33;
  int v34;
  int v35;
  __CLPK_integer __nrhs;
  __CLPK_integer __info;
  __CLPK_integer __ldb;

  v2 = *((unsigned int *)this + 25);
  v35 = *((_DWORD *)this + 26);
  v3 = *(_DWORD *)(**((_QWORD **)this + 6) + 120);
  v4 = (long double *)malloc_type_calloc(v3 * (int)v2, 8uLL, 0x100004000313F17uLL);
  v33 = malloc_type_calloc(v3, 8uLL, 0x100004000313F17uLL);
  v5 = (char *)*((_QWORD *)this + 14);
  bzero(v5, 8 * (int)v2);
  v6 = *((_DWORD *)this + 25);
  v7 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  v8 = 8 * (int)v2;
  if (v7)
  {
    v9 = (CPMLFeatureVector *)v7;
    v34 = v6 + ~v35;
    v10 = v4;
    do
    {
      RealVector = (uint64_t *)CPMLFeatureVector::getRealVector(v9);
      *v10 = 1.0;
      v12 = *RealVector;
      v13 = RealVector[1];
      v14 = v13 - *RealVector;
      if (v13 != *RealVector)
      {
        v15 = 0;
        v16 = v14 >> 3;
        if (v16 <= 1)
          v16 = 1;
        do
        {
          v10[v15 + 1] = *(long double *)(v12 + 8 * v15);
          ++v15;
        }
        while (v16 != v15);
      }
      expandVector(*((int **)this + 15), v35, v34, v10 + 1, &v10[v35 + 1]);
      if ((int)v2 >= 1)
      {
        for (i = 0; i != v2; ++i)
        {
          v18 = v10[i];
          *(double *)&v5[i * 8] = *(double *)&v5[i * 8] + v18 * CPMLFeatureVector::getYHat(v9);
        }
      }
      v10 = (long double *)((char *)v10 + v8);
      v9 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v9);
  }
  v19 = (__CLPK_doublereal *)malloc_type_calloc((v2 * v2), 8uLL, 0x100004000313F17uLL);
  v20 = v19;
  if ((int)v2 >= 1)
  {
    v21 = 0;
    v22 = 0;
    v23 = v19;
    do
    {
      v24 = v21 * 8;
      v25 = v22;
      do
      {
        v26 = 0.0;
        if (v3 >= 1)
        {
          v27 = v3;
          v28 = v4;
          do
          {
            v26 = v26 + v28[v21] * *(long double *)((char *)v28 + v24);
            v28 = (long double *)((char *)v28 + v8);
            --v27;
          }
          while (v27);
        }
        *v23++ = v26;
        ++v25;
        v24 += 8;
      }
      while ((int)v2 > (int)v25);
      ++v22;
      ++v21;
    }
    while (v22 != v2);
  }
  __info = 0;
  __ldb = v2;
  __nrhs = 1;
  v29 = (CPMLLog *)dppsv_("L", &__ldb, &__nrhs, v19, (__CLPK_doublereal *)v5, &__ldb, &__info);
  if (__info)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v29);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "train", "Linear regression training failed.");
    v31 = __info;
  }
  else
  {
    v31 = 0;
  }
  free(v4);
  free(v33);
  free(v20);
  return v31;
}

void expandVector(int *a1, int a2, int a3, long double *a4, double *a5)
{
  int v9;
  uint64_t v10;
  uint64_t v11;
  double v12;
  uint64_t v13;
  long double *v14;
  int *v15;

  if (a3 >= 1)
  {
    v9 = 0;
    v10 = 4 * (a2 - 1) + 4;
    v11 = a2;
    do
    {
      v12 = 1.0;
      if (a2 >= 1)
      {
        v13 = v11;
        v14 = a4;
        v15 = a1;
        do
        {
          if (*v15)
            v12 = v12 * pow(*v14, (double)*v15);
          ++v15;
          ++v14;
          --v13;
        }
        while (v13);
        a1 = (int *)((char *)a1 + v10);
      }
      *a5++ = v12;
      ++v9;
    }
    while (v9 != a3);
  }
}

uint64_t CPLinearRegressionClassfier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t v4;
  uint64_t v5;
  _QWORD *IntVector;
  CPMLLog *RealVector;
  pthread_mutex_t *v8;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  double *v15;
  double v16;
  double v17;
  double v18;
  double v19;
  pthread_mutex_t *CPMLLog;

  v4 = *(unsigned int *)(a1 + 100);
  v5 = *(int *)(a1 + 104);
  IntVector = (_QWORD *)CPMLFeatureVector::getIntVector(this);
  RealVector = (CPMLLog *)CPMLFeatureVector::getRealVector(this);
  if (IntVector[1] == *IntVector)
  {
    v10 = *(uint64_t **)RealVector;
    if (v5 == (uint64_t)(*((_QWORD *)RealVector + 1) - *(_QWORD *)RealVector) >> 3)
    {
      v11 = *(_QWORD *)(a1 + 128);
      if ((int)v5 >= 1)
      {
        v12 = v5;
        v13 = (_QWORD *)(v11 + 8);
        do
        {
          v14 = *v10++;
          *v13++ = v14;
          --v12;
        }
        while (v12);
      }
      *(_QWORD *)v11 = 0x3FF0000000000000;
      expandVector(*(int **)(a1 + 120), v5, v4 + ~(_DWORD)v5, (long double *)(v11 + 8), (double *)(v11 + 8 * ((int)v5 + 1)));
      if ((int)v4 < 1)
      {
        v16 = 0.0;
      }
      else
      {
        v15 = *(double **)(a1 + 112);
        v16 = 0.0;
        do
        {
          v17 = *v15++;
          v18 = v17;
          v19 = *(double *)v11;
          v11 += 8;
          v16 = v16 + v18 * v19;
          --v4;
        }
        while (v4);
      }
      CPMLFeatureVector::setYHat((uint64_t)this, v16);
      return 0;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(RealVector);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "eval", "Feature count mismatch with training data in Linear Regression");
      return 2;
    }
  }
  else
  {
    v8 = (pthread_mutex_t *)CPMLLog::getCPMLLog(RealVector);
    CPMLLog::log(v8, CPML_LOG_ERR, "eval", "Feature vector in Linear Regression predict should not have integer features.");
    return 1;
  }
}

uint64_t CPLinearRegressionClassfier::errorString(CPLinearRegressionClassfier *this)
{
  return 0;
}

uint64_t fillDegrees(int *a1, int a2, uint64_t a3, int a4)
{
  uint64_t v4;
  int *v6;
  int v7;
  int v9;
  uint64_t v10;
  int v11;
  int v12;

  v4 = a3;
  if ((_DWORD)a3)
  {
    v6 = a1;
    v7 = a3 - 1;
    if ((_DWORD)a3 == 1)
    {
      *a1 = a4;
    }
    else if (a4 < 0)
    {
      return 0;
    }
    else
    {
      v9 = 0;
      LODWORD(v4) = 0;
      v10 = 4 * a2;
      do
      {
        v11 = fillDegrees(v6 + 1, a2, v7, a4 - v9);
        v12 = v11;
        if (v11 >= 1)
        {
          do
          {
            *v6 = v9;
            v6 = (int *)((char *)v6 + v10);
            --v12;
          }
          while (v12);
        }
        v4 = (v11 + v4);
      }
      while (a4 != v9++);
    }
  }
  return v4;
}

uint64_t CPLinearRegressionClassfier::requireRealOnly(CPLinearRegressionClassfier *this)
{
  return 1;
}

void CPMLNaiveBayesClassifierBase::CPMLNaiveBayesClassifierBase(CPMLNaiveBayesClassifierBase *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  CPMLStatistics *var0;
  unint64_t v10;
  char v11[40];
  char v12[32];
  uint64_t v13;

  v13 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v8 = &off_24C255BC0;
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_DWORD *)(v8 + 200) = 1065353216;
  *(_OWORD *)(v8 + 208) = 0u;
  *(_OWORD *)(v8 + 224) = 0u;
  *(_OWORD *)(v8 + 248) = 0u;
  *(_DWORD *)(v8 + 240) = 1065353216;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_DWORD *)(v8 + 280) = 1065353216;
  *(_OWORD *)(v8 + 288) = 0u;
  *(_OWORD *)(v8 + 304) = 0u;
  *(_DWORD *)(v8 + 320) = 1065353216;
  *(_OWORD *)(v8 + 328) = 0u;
  *(_OWORD *)(v8 + 344) = 0u;
  *(_DWORD *)(v8 + 360) = 1065353216;
  *(_OWORD *)(v8 + 368) = 0u;
  *(_OWORD *)(v8 + 384) = 0u;
  *(_DWORD *)(v8 + 400) = 1065353216;
  *(_OWORD *)(v8 + 576) = 0u;
  strcpy((char *)(v8 + 8), "2.0.0");
  *(_QWORD *)(v8 + 112) = 0;
  var0 = a2->var0;
  *(_QWORD *)(v8 + 96) = *((int *)a2->var0 + 31);
  *(_QWORD *)(v8 + 104) = *((int *)var0 + 33);
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPMLNaiveBayesClassifierBase::setTunableData(this, a4);
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "version", "version TEXT");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "rowCountY", "rowCountY REAL");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "yCount", "yMap INTEGER, yCount REAL");
  (*((void (**)(CPMLSerialization *, const char *, const char *))a3->var0 + 16))(a3, "resultCardinality", "resultCardinality REAL");
  if (*((_QWORD *)this + 12))
  {
    v10 = 0;
    do
    {
      sprintf(v11, "xcol%d", v10);
      sprintf(v12, "xCardinality%d", v10);
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v12, "yMap INTEGER, xCardinality REAL");
      (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v11, "xMap INTEGER, yMap INTEGER, xyCount REAL");
      ++v10;
    }
    while (*((_QWORD *)this + 12) > v10);
  }
  strcpy(v12, "xcolRealMean");
  strcpy(v11, "xcolRealVariance");
  (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v12, "xMap INTEGER, yMap INTEGER, mean REAL");
  (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 16))(a3, v11, "xMap INTEGER, yMap INTEGER, variance REAL");
}

void sub_209CEA27C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void **a12)
{
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  void *v17;
  void *v18;

  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)(v12 + 46));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(v15);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)(v12 + 36));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(v14);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(v13);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::~__hash_table(a11);
  v17 = (void *)v12[18];
  if (v17)
  {
    v12[19] = v17;
    operator delete(v17);
  }
  v18 = *a12;
  if (*a12)
  {
    v12[16] = v18;
    operator delete(v18);
  }
  CPModelClose(v12);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifierBase::setTunableData(CPMLNaiveBayesClassifierBase *this, CPMLTunableData *a2)
{
  _OWORD *v4;
  _DWORD *v5;
  CPMLLogger *v11;
  CPMLNaiveBayesAdaptor *v12;
  CPMLNaiveBayes *v13;
  unint64_t v14;
  void **v15;
  _QWORD *v16;
  char *v17;
  char *v18;
  char *v19;
  uint64_t v20;
  unint64_t v21;
  uint64_t v22;
  unint64_t v23;
  char *v24;
  char *v25;
  int v26;

  v4 = (_OWORD *)((char *)this + 552);
  if ((int)CPMLTunableData::getNumberOfItems(a2) < 2)
  {
    __asm { FMOV            V0.2D, #1.0 }
    *((_OWORD *)this + 33) = _Q0;
    *((_DWORD *)this + 130) = 1;
    *((_QWORD *)this + 68) = 0x3CD203AF9EE75616;
    *((_WORD *)this + 204) = 0;
    *v4 = xmmword_209D00960;
    *((_QWORD *)this + 64) = 20;
    strcpy((char *)this + 410, "defaultNBV3b");
  }
  else
  {
    CPMLTunableData::tDataGetInt(a2, "k", (int *)this + 128);
    CPMLTunableData::tDataGetInt(a2, "cacheLength", (int *)this + 138);
    CPMLTunableData::tDataGetInt(a2, "cacheAssocitivity", (int *)this + 139);
    CPMLTunableData::tDataGetDouble(a2, "decayRate", (double *)this + 66);
    CPMLTunableData::tDataGetDouble(a2, "smoothRate", (double *)this + 67);
    CPMLTunableData::tDataGetInt(a2, "smoothMode", (int *)this + 130);
    CPMLTunableData::tDataGetDouble(a2, "epsilonRate", (double *)this + 68);
    CPMLTunableData::tDataGetBool(a2, "enableLogging", (BOOL *)this + 409);
    CPMLTunableData::tDataGetString(a2, "logFilename", (char *)this + 410, 0x64uLL);
    CPMLTunableData::tDataGetBool(a2, "dataCollection", (BOOL *)this + 408);
    CPMLTunableData::tDataGetInt(a2, "nbAdatorVersion", (int *)this + 129);
    CPMLTunableData::tDataGetInt(a2, "maxAllowedUpdate", (int *)this + 140);
    v5 = (_DWORD *)((char *)this + 564);
    CPMLTunableData::tDataGetInt(a2, "maxAllowedPredict", (int *)this + 141);
    if (!*((_DWORD *)this + 140))
      *((_DWORD *)this + 140) = 10;
    if (!*v5)
      *v5 = 10;
    if (!*((_BYTE *)this + 8))
      strcpy((char *)this + 8, "2.0.0");
  }
  v11 = (CPMLLogger *)operator new();
  CPMLLogger::CPMLLogger(v11, (char *)this + 410, *((_BYTE *)this + 409));
  *((_QWORD *)this + 71) = v11;
  if (*((_DWORD *)this + 129) != 1)
  {
    v12 = (CPMLNaiveBayesAdaptor *)operator new();
    CPMLNaiveBayesAdaptor::CPMLNaiveBayesAdaptor(v12, *((CPMLSerialization **)this + 11));
    *((_QWORD *)this + 73) = v12;
  }
  v13 = (CPMLNaiveBayes *)operator new();
  CPMLNaiveBayes::CPMLNaiveBayes(v13, *((CPMLNaiveBayesDBAdaptor **)this + 73));
  *((_QWORD *)this + 72) = v13;
  CPMLNaiveBayes::set_decay_rate((uint64_t)v13, *((double *)this + 66));
  CPMLNaiveBayes::set_smooth_rate(*((_QWORD *)this + 72), *((double *)this + 67));
  CPMLNaiveBayes::set_epsilon_rate(*((_QWORD *)this + 72), *((double *)this + 68));
  CPMLNaiveBayes::set_smooth_mode(*((_QWORD *)this + 72), *((_DWORD *)this + 130));
  if (*((_QWORD *)this + 13))
  {
    v14 = 0;
    v15 = (void **)((char *)this + 144);
    v16 = (_QWORD *)((char *)this + 160);
    v17 = (char *)*((_QWORD *)this + 19);
    do
    {
      if ((unint64_t)v17 >= *v16)
      {
        v19 = (char *)*v15;
        v20 = (v17 - (_BYTE *)*v15) >> 2;
        v21 = v20 + 1;
        if ((unint64_t)(v20 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v22 = *v16 - (_QWORD)v19;
        if (v22 >> 1 > v21)
          v21 = v22 >> 1;
        if ((unint64_t)v22 >= 0x7FFFFFFFFFFFFFFCLL)
          v23 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v23 = v21;
        if (v23)
        {
          v24 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 160, v23);
          v19 = (char *)*((_QWORD *)this + 18);
          v17 = (char *)*((_QWORD *)this + 19);
        }
        else
        {
          v24 = 0;
        }
        v25 = &v24[4 * v20];
        *(_DWORD *)v25 = v14;
        v18 = v25 + 4;
        while (v17 != v19)
        {
          v26 = *((_DWORD *)v17 - 1);
          v17 -= 4;
          *((_DWORD *)v25 - 1) = v26;
          v25 -= 4;
        }
        *((_QWORD *)this + 18) = v25;
        *((_QWORD *)this + 19) = v18;
        *((_QWORD *)this + 20) = &v24[4 * v23];
        if (v19)
          operator delete(v19);
      }
      else
      {
        *(_DWORD *)v17 = v14;
        v18 = v17 + 4;
      }
      *((_QWORD *)this + 19) = v18;
      ++v14;
      v17 = v18;
    }
    while (*((_QWORD *)this + 13) > v14);
  }
  CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 72), (unsigned int **)this + 18);
}

void sub_209CEA6A4(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10B1C40E26776D8);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifierBase::CPMLNaiveBayesClassifierBase(CPMLNaiveBayesClassifierBase *this, CPMLStatistics *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  char *v13;
  uint64_t v14;
  int *v15;
  int v16;
  unsigned int *v17;
  unsigned int *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  char *v23;
  unsigned int *v24;
  unsigned int v25;
  _QWORD v26[6];
  double v27;
  double v28;
  char v29[150];
  unsigned int *v30;
  unsigned int *v31;
  _QWORD v32[19];

  v32[17] = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a3, a4);
  *(_OWORD *)(v8 + 120) = 0u;
  *(_OWORD *)(v8 + 168) = 0u;
  *(_QWORD *)v8 = &off_24C255BC0;
  *(_OWORD *)(v8 + 136) = 0u;
  *(_OWORD *)(v8 + 152) = 0u;
  *(_OWORD *)(v8 + 184) = 0u;
  *(_DWORD *)(v8 + 200) = 1065353216;
  *(_OWORD *)(v8 + 208) = 0u;
  v26[3] = v8 + 208;
  *(_OWORD *)(v8 + 224) = 0u;
  *(_DWORD *)(v8 + 240) = 1065353216;
  *(_OWORD *)(v8 + 248) = 0u;
  v26[2] = v8 + 248;
  *(_OWORD *)(v8 + 264) = 0u;
  *(_DWORD *)(v8 + 280) = 1065353216;
  *(_OWORD *)(v8 + 288) = 0u;
  *(_OWORD *)(v8 + 304) = 0u;
  *(_DWORD *)(v8 + 320) = 1065353216;
  *(_OWORD *)(v8 + 328) = 0u;
  *(_OWORD *)(v8 + 344) = 0u;
  v26[1] = v8 + 328;
  *(_DWORD *)(v8 + 360) = 1065353216;
  *(_OWORD *)(v8 + 368) = 0u;
  *(_OWORD *)(v8 + 384) = 0u;
  *(_DWORD *)(v8 + 400) = 1065353216;
  *(_QWORD *)(v8 + 96) = *((int *)a2 + 31);
  v27 = 0.0;
  v28 = 0.0;
  v26[4] = v8 + 168;
  v26[5] = v8 + 120;
  CPMLNaiveBayesClassifierBase::setTunableData((CPMLNaiveBayesClassifierBase *)v8, a4);
  (*((void (**)(CPMLSerialization *, char *, const char *))a3->var0 + 24))(a3, (char *)this + 104, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality INTEGER, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "CREATE TABLE IF NOT EXISTS rowCountY (rowCountY REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "CREATE TABLE IF NOT EXISTS yCount (yMap INTEGER, yCount REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "CREATE INDEX IF NOT EXISTS idxRowCountY on rowCountY (rowCountY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "CREATE INDEX IF NOT EXISTS idxYCount on yCount (yMap, yCount);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "SELECT count(*) FROM sqlite_master WHERE type='table' AND name='version';");
  if (v27 == 0.0)
  {
    (*((void (**)(CPMLSerialization *, double *, const char *, double))a3->var0 + 28))(a3, &v27, "CREATE TABLE IF NOT EXISTS version (version TEXT, pKey INTEGER PRIMARY KEY);",
      v27);
    sprintf((char *)&v30, "\"%s\"", (const char *)this + 8);
    (*((void (**)(CPMLSerialization *, const char *, const char *, unsigned int **))a3->var0 + 17))(a3, "version", "version", &v30);
  }
  else
  {
    (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD, double))a3->var0 + 13))(a3, (char *)this + 8, "version", 32, 0, v27);
  }
  if (*((_QWORD *)this + 12))
  {
    v9 = 0;
    do
    {
      sprintf((char *)&v30, "CREATE TABLE IF NOT EXISTS xcol%d (xMap INTEGER, yMap INTEGER, xyCount REAL, pKey INTEGER PRIMARY KEY);",
        v9);
      sprintf(v29, "CREATE TABLE IF NOT EXISTS xCardinality%d (yMap INTEGER, xCardinality REAL, pKey INTEGER PRIMARY KEY);",
        v9);
      (*((void (**)(CPMLSerialization *, double *, char *))a3->var0 + 28))(a3, &v27, v29);
      (*((void (**)(CPMLSerialization *, double *, unsigned int **))a3->var0 + 28))(a3, &v27, &v30);
      ++v9;
    }
    while (*((_QWORD *)this + 12) > v9);
  }
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v27, "CREATE TABLE IF NOT EXISTS resultCardinality (resultCardinality REAL, pKey INTEGER PRIMARY KEY);");
  (*((void (**)(CPMLSerialization *, double *, const char *))a3->var0 + 28))(a3, &v28, "select count(*) from yCount;");
  if (v28 >= 1.0)
  {
    *((_QWORD *)this + 13) = (unint64_t)v28;
  }
  else
  {
    v30 = 0;
    (*((void (**)(CPMLSerialization *, unsigned int **, const char *, uint64_t, _QWORD, double))a3->var0 + 4))(a3, &v30, "resultCardinality", 1, 0, v28);
  }
  CPMLNaiveBayes::set_decay_rate(*((_QWORD *)this + 72), *((double *)this + 66));
  CPMLNaiveBayes::set_smooth_rate(*((_QWORD *)this + 72), *((double *)this + 67));
  CPMLNaiveBayes::set_epsilon_rate(*((_QWORD *)this + 72), *((double *)this + 68));
  v10 = (*(uint64_t (**)(_QWORD, _QWORD, _QWORD))(**((_QWORD **)this + 73) + 80))(*((_QWORD *)this + 73), *((unsigned int *)this + 138), *((unsigned int *)this + 139));
  v30 = 0;
  v31 = 0;
  v32[0] = 0;
  MEMORY[0x24BDAC7A8](v10, v11);
  v13 = (char *)v26 - v12;
  (*((void (**)(CPMLSerialization *, char *, unint64_t, const char *))a3->var0 + 27))(a3, (char *)v26 - v12, (unint64_t)v28, "select yMap from yCount;");
  if ((int)v28 >= 1)
  {
    v14 = 0;
    v15 = (int *)v31;
    do
    {
      v16 = (int)*(double *)&v13[8 * v14];
      if ((unint64_t)v15 >= v32[0])
      {
        v18 = v30;
        v19 = ((char *)v15 - (char *)v30) >> 2;
        v20 = v19 + 1;
        if ((unint64_t)(v19 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v21 = v32[0] - (_QWORD)v30;
        if ((uint64_t)(v32[0] - (_QWORD)v30) >> 1 > v20)
          v20 = v21 >> 1;
        if ((unint64_t)v21 >= 0x7FFFFFFFFFFFFFFCLL)
          v22 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v22 = v20;
        if (v22)
        {
          v23 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)v32, v22);
          v18 = v30;
          v15 = (int *)v31;
        }
        else
        {
          v23 = 0;
        }
        v24 = (unsigned int *)&v23[4 * v19];
        *v24 = v16;
        v17 = v24 + 1;
        while (v15 != (int *)v18)
        {
          v25 = *--v15;
          *--v24 = v25;
        }
        v30 = v24;
        v31 = v17;
        v32[0] = &v23[4 * v22];
        if (v18)
          operator delete(v18);
      }
      else
      {
        *v15 = v16;
        v17 = (unsigned int *)(v15 + 1);
      }
      v31 = v17;
      ++v14;
      v15 = (int *)v17;
    }
    while (v14 < (int)v28);
  }
  CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 72), &v30);
  if (v30)
  {
    v31 = v30;
    operator delete(v30);
  }
}

void sub_209CEAC04(_Unwind_Exception *a1)
{
  uint64_t v1;
  _QWORD *v2;
  void *v4;
  void *v5;

  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)(v2 + 46));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(*(_QWORD *)(v1 + 8));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)(v2 + 36));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(*(_QWORD *)(v1 + 16));
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(*(_QWORD *)(v1 + 24));
  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::~__hash_table(*(_QWORD *)(v1 + 32));
  v4 = (void *)v2[18];
  if (v4)
  {
    v2[19] = v4;
    operator delete(v4);
  }
  v5 = **(void ***)(v1 + 40);
  if (v5)
  {
    v2[16] = v5;
    operator delete(v5);
  }
  CPModelClose(v2);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifierBase::~CPMLNaiveBayesClassifierBase(CPMLNaiveBayesClassifierBase *this)
{
  CPMLLogger *v2;
  CPMLNaiveBayes *v3;
  CPMLNaiveBayesAdaptor *v4;
  void *v5;
  void *v6;

  *(_QWORD *)this = &off_24C255BC0;
  v2 = (CPMLLogger *)*((_QWORD *)this + 71);
  if (v2)
  {
    CPMLLogger::~CPMLLogger(v2);
    MEMORY[0x20BD188E4]();
  }
  v3 = (CPMLNaiveBayes *)*((_QWORD *)this + 72);
  if (v3)
  {
    CPMLNaiveBayes::~CPMLNaiveBayes(v3);
    MEMORY[0x20BD188E4]();
  }
  v4 = (CPMLNaiveBayesAdaptor *)*((_QWORD *)this + 73);
  if (v4)
  {
    CPMLNaiveBayesAdaptor::~CPMLNaiveBayesAdaptor(v4);
    MEMORY[0x20BD188E4]();
  }
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 368);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 328);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 288);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 248);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 208);
  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::~__hash_table((uint64_t)this + 168);
  v5 = (void *)*((_QWORD *)this + 18);
  if (v5)
  {
    *((_QWORD *)this + 19) = v5;
    operator delete(v5);
  }
  v6 = (void *)*((_QWORD *)this + 15);
  if (v6)
  {
    *((_QWORD *)this + 16) = v6;
    operator delete(v6);
  }
  CPModelClose(this);
}

{
  CPMLNaiveBayesClassifierBase::~CPMLNaiveBayesClassifierBase(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLNaiveBayesClassifierBase::serialize(CPMLNaiveBayesClassifierBase *this)
{
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 104, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 56))(*((_QWORD *)this + 11), (char *)this + 8, "version", 32, 0);
  return 0;
}

uint64_t CPMLNaiveBayesClassifierBase::train(CPMLNaiveBayesClassifierBase *this)
{
  uint64_t v2;
  CPMLFeatureVector *v3;
  CPMLLog *v4;
  _QWORD *v5;
  _BYTE *v6;
  _BYTE *v7;
  unint64_t v8;
  _QWORD *v9;
  int v10;
  _QWORD *v11;
  uint64_t *v12;
  int v13;
  uint64_t *v14;
  int v15;
  uint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t jj;
  _QWORD *v20;
  uint64_t v21;
  _QWORD *v22;
  _QWORD *v23;
  uint64_t *v24;
  int v25;
  uint64_t *v26;
  int v27;
  uint64_t *v28;
  uint64_t v29;
  CPMLFeatureVector *v30;
  _QWORD *YVectorVector;
  _DWORD *v32;
  _DWORD *v33;
  unint64_t v34;
  _QWORD *v35;
  _QWORD *v36;
  uint64_t v37;
  unint64_t v38;
  int v39;
  _QWORD *v40;
  _QWORD *v41;
  _QWORD **v42;
  int v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  int64_t v49;
  uint64_t ii;
  uint64_t v51;
  unint64_t v52;
  int v53;
  int v54;
  _QWORD *XVectorVector;
  _QWORD *v56;
  _QWORD **v57;
  int v58;
  uint64_t *IntVector;
  uint64_t v60;
  uint64_t v61;
  _QWORD *RealVector;
  char *v63;
  uint64_t *i;
  char *v65;
  uint64_t **j;
  _DWORD *v67;
  uint64_t *k;
  char *v69;
  double *m;
  unint64_t v71;
  double v72;
  char *v73;
  double *n;
  unint64_t v75;
  double v76;
  char *v77;
  pthread_mutex_t *CPMLLog;
  void *__p;
  _BYTE *v81;
  uint64_t *v82;
  unint64_t v83;
  int v84;
  int v85;
  int v86[8];
  _DWORD *v87[8];

  v87[6] = *(_DWORD **)MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (!v2)
  {
LABEL_27:
    CPMLNaiveBayesClassifierBase::updateMean((double *)this);
    (*(void (**)(_QWORD))(**((_QWORD **)this + 10) + 40))(*((_QWORD *)this + 10));
    v29 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    v30 = (CPMLFeatureVector *)v29;
    if (!v29)
    {
LABEL_52:
      CPMLNaiveBayesClassifierBase::updateVariance((double *)this);
      v63 = sqlite3_mprintf("%lf", (double)*((unint64_t *)this + 14));
      (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "rowCountY", "rowCountY", v63);
      if (v63)
        sqlite3_free(v63);
      for (i = (uint64_t *)*((_QWORD *)this + 48); i; i = (uint64_t *)*i)
      {
        v65 = sqlite3_mprintf("%d,%lf", *((_DWORD *)i + 4), (double)*((int *)i + 5));
        (*(void (**)(_QWORD, const char *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), "yCount", "yMap,yCount", v65);
        if (v65)
          sqlite3_free(v65);
      }
      for (j = (uint64_t **)*((_QWORD *)this + 23); j; j = (uint64_t **)*j)
      {
        v87[0] = j[2];
        std::unordered_map<int,int>::unordered_map((uint64_t)&v87[1], (uint64_t)(j + 3));
        v67 = v87[0];
        std::unordered_map<int,int>::unordered_map((uint64_t)&__p, (uint64_t)&v87[1]);
        sprintf((char *)v86, "xcol%d", (unint64_t)v67 > 0x1F);
        for (k = v82; k; k = (uint64_t *)*k)
        {
          v69 = sqlite3_mprintf("%d,%d,%lf", *((_DWORD *)k + 4), (_DWORD)v67, (double)*((int *)k + 5));
          (*(void (**)(_QWORD, int *, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), v86, "xMap,yMap,xyCount", v69);
          if (v69)
            sqlite3_free(v69);
        }
        std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)&__p);
        std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)&v87[1]);
      }
      for (m = (double *)*((_QWORD *)this + 33); m; m = *(double **)m)
      {
        v71 = *((_QWORD *)m + 2);
        v72 = m[3];
        strcpy((char *)v87, "xcolRealMean");
        v73 = sqlite3_mprintf("%d,%d,%lf", v71 >> 31, v71, v72);
        (*(void (**)(_QWORD, _DWORD **, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), v87, "xMap,yMap,xyCount", v73);
        if (v73)
          sqlite3_free(v73);
      }
      for (n = (double *)*((_QWORD *)this + 43); n; n = *(double **)n)
      {
        v75 = *((_QWORD *)n + 2);
        v76 = n[3];
        strcpy((char *)v87, "xcolRealVariance");
        v77 = sqlite3_mprintf("%d,%d,%lf", v75 >> 31, v75, v76);
        (*(void (**)(_QWORD, _DWORD **, const char *, char *))(**((_QWORD **)this + 11) + 136))(*((_QWORD *)this + 11), v87, "xMap,yMap,xyCount", v77);
        if (v77)
          sqlite3_free(v77);
      }
      return 0;
    }
    while (1)
    {
      memset(v87, 0, 24);
      CPMLNaiveBayesClassifierBase::getResponseValues(v29, (uint64_t)v87, v30);
      YVectorVector = (_QWORD *)CPMLFeatureVector::getYVectorVector(v30);
      if (YVectorVector[1] == *YVectorVector)
        break;
      v32 = v87[0];
      v33 = v87[1];
      v34 = v87[1] - v87[0];
      if (v34)
      {
        if (v34 == 1)
        {
          v86[0] = 0;
          v86[0] = *v87[0];
          __p = v86;
          v35 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 368, v86, (uint64_t)&std::piecewise_construct, (_DWORD **)&__p);
          ++*((_DWORD *)v35 + 5);
        }
        else
        {
          v48 = *((int *)this + 140);
          if (v34 > v48)
          {
            v49 = (((char *)v87[1] - (char *)v87[0]) << 30) - 0x100000000;
            do
            {
              --v33;
              v34 = v49 >> 32;
              v49 -= 0x100000000;
            }
            while (v34 > v48);
            v87[1] = v33;
          }
          if (v34)
          {
            for (ii = 0; ii != v34; ++ii)
            {
              v51 = 0;
              v52 = 0;
              v53 = 0;
              v54 = v87[0][ii];
              while (1)
              {
                XVectorVector = (_QWORD *)CPMLFeatureVector::getXVectorVector(v30);
                if (v52 >= (uint64_t)(XVectorVector[1] - *XVectorVector) >> 4)
                  break;
                v56 = (_QWORD *)CPMLFeatureVector::getXVectorVector(v30);
                if (v52 >= (uint64_t)(v56[1] - *v56) >> 4)
                  std::vector<VectorClass>::__throw_out_of_range[abi:ne180100]();
                v57 = (_QWORD **)(*v56 + v51);
                v58 = v53 + (((*v57)[1] - **v57) >> 2);
                v53 = v58 + CPMLNaiveBayesClassifierBase::processDataSetVariance((uint64_t)this, v57[1], v58, v54);
                ++v52;
                v51 += 16;
              }
              IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(v30);
              v61 = *IntVector;
              v60 = IntVector[1];
              RealVector = (_QWORD *)CPMLFeatureVector::getRealVector(v30);
              CPMLNaiveBayesClassifierBase::processDataSetVariance((uint64_t)this, RealVector, v53 + ((unint64_t)(v60 - v61) >> 2), v54);
            }
          }
        }
LABEL_48:
        v32 = v87[0];
      }
      if (v32)
      {
        v87[1] = v32;
        operator delete(v32);
      }
      v29 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      v30 = (CPMLFeatureVector *)v29;
      if (!v29)
        goto LABEL_52;
    }
    v86[0] = 0;
    v86[0] = *v87[0];
    __p = v86;
    v36 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 368, v86, (uint64_t)&std::piecewise_construct, (_DWORD **)&__p);
    v37 = 0;
    v38 = 0;
    v39 = 0;
    ++*((_DWORD *)v36 + 5);
    while (1)
    {
      v40 = (_QWORD *)CPMLFeatureVector::getXVectorVector(v30);
      if (v38 >= (uint64_t)(v40[1] - *v40) >> 4)
        break;
      v41 = (_QWORD *)CPMLFeatureVector::getXVectorVector(v30);
      if (v38 >= (uint64_t)(v41[1] - *v41) >> 4)
        std::vector<VectorClass>::__throw_out_of_range[abi:ne180100]();
      v42 = (_QWORD **)(*v41 + v37);
      v43 = v39 + (((*v42)[1] - **v42) >> 2);
      v39 = v43 + CPMLNaiveBayesClassifierBase::processDataSetVariance((uint64_t)this, v42[1], v43, *v87[0]);
      ++v38;
      v37 += 16;
    }
    v44 = (uint64_t *)CPMLFeatureVector::getIntVector(v30);
    v46 = *v44;
    v45 = v44[1];
    v47 = (_QWORD *)CPMLFeatureVector::getRealVector(v30);
    CPMLNaiveBayesClassifierBase::processDataSetVariance((uint64_t)this, v47, v39 + ((unint64_t)(v45 - v46) >> 2), *v87[0]);
    goto LABEL_48;
  }
  v3 = (CPMLFeatureVector *)v2;
  while (1)
  {
    v4 = (CPMLLog *)CPMLFeatureVector::getXVectorVector(v3);
    if (*((_QWORD *)v4 + 1) != *(_QWORD *)v4)
      break;
    __p = 0;
    v81 = 0;
    v82 = 0;
    CPMLNaiveBayesClassifierBase::getResponseValues((int)v4, (uint64_t)&__p, v3);
    v5 = (_QWORD *)CPMLFeatureVector::getYVectorVector(v3);
    if (v5[1] == *v5)
    {
      v86[0] = 0;
      v86[0] = *(_DWORD *)__p;
      v87[0] = v86;
      v11 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 368, v86, (uint64_t)&std::piecewise_construct, v87);
      ++*((_DWORD *)v11 + 5);
      v12 = (uint64_t *)CPMLFeatureVector::getXVectorVector(v3);
      v13 = CPMLNaiveBayesClassifierBase::processVectorDataSet((uint64_t)this, v12, 0, v86[0]);
      v14 = (uint64_t *)CPMLFeatureVector::getIntVector(v3);
      v15 = CPMLNaiveBayesClassifierBase::processDiscreteDataSet((uint64_t)this, v14, v13, v86[0], 1);
      v16 = (uint64_t *)CPMLFeatureVector::getRealVector(v3);
      CPMLNaiveBayesClassifierBase::processContinousDataSet((uint64_t)this, v16, v15, v86[0], 1);
    }
    else
    {
      v6 = __p;
      v7 = v81;
      v8 = (v81 - (_BYTE *)__p) >> 2;
      if (!v8)
      {
        v10 = 2;
        if (!__p)
          goto LABEL_25;
LABEL_24:
        v81 = v6;
        operator delete(v6);
        goto LABEL_25;
      }
      if (v8 == 1)
      {
        v86[0] = 0;
        v86[0] = *(_DWORD *)__p;
        v87[0] = v86;
        v9 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 368, v86, (uint64_t)&std::piecewise_construct, v87);
        ++*((_DWORD *)v9 + 5);
        v10 = 2;
        goto LABEL_23;
      }
      v17 = *((int *)this + 140);
      if (v8 > v17)
      {
        v18 = ((v81 - (_BYTE *)__p) << 30) - 0x100000000;
        do
        {
          v7 -= 4;
          v8 = v18 >> 32;
          v18 -= 0x100000000;
        }
        while (v8 > v17);
        v81 = v7;
      }
      if (v8)
      {
        for (jj = 0; jj != v8; ++jj)
        {
          v85 = 0;
          v85 = *((_DWORD *)__p + jj);
          v87[0] = &v85;
          v20 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 368, &v85, (uint64_t)&std::piecewise_construct, v87);
          v21 = 0;
          ++*((_DWORD *)v20 + 5);
          do
          {
            v84 = 0;
            v84 = *((_DWORD *)__p + v21);
            if (jj != v21)
            {
              v83 = v85;
              *(_QWORD *)v86 = &v83;
              v22 = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 168, &v83, (uint64_t)&std::piecewise_construct, (_QWORD **)v86);
              std::unordered_map<int,int>::unordered_map((uint64_t)v87, (uint64_t)(v22 + 3));
              *(_QWORD *)v86 = &v84;
              v23 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v87, &v84, (uint64_t)&std::piecewise_construct, (_DWORD **)v86);
              ++*((_DWORD *)v23 + 5);
              std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)v87);
            }
            ++v21;
          }
          while (v8 != v21);
          v24 = (uint64_t *)CPMLFeatureVector::getXVectorVector(v3);
          v25 = CPMLNaiveBayesClassifierBase::processVectorDataSet((uint64_t)this, v24, 0, v85);
          v26 = (uint64_t *)CPMLFeatureVector::getIntVector(v3);
          v27 = CPMLNaiveBayesClassifierBase::processDiscreteDataSet((uint64_t)this, v26, v25, v85, 1);
          v28 = (uint64_t *)CPMLFeatureVector::getRealVector(v3);
          CPMLNaiveBayesClassifierBase::processContinousDataSet((uint64_t)this, v28, v27, v85, 1);
        }
      }
    }
    v10 = 0;
    ++*((_QWORD *)this + 14);
LABEL_23:
    v6 = __p;
    if (__p)
      goto LABEL_24;
LABEL_25:
    if ((v10 | 2) != 2)
      return 0xFFFFFFFFLL;
    v3 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    if (!v3)
      goto LABEL_27;
  }
  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v4);
  CPMLLog::log(CPMLLog, CPML_LOG_ERR, "train", "Does not support x vectors\n");
  return 0xFFFFFFFFLL;
}

void sub_209CEB730(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *__p, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CPMLNaiveBayesClassifierBase::getResponseValues(int a1, uint64_t a2, CPMLFeatureVector *this)
{
  CPMLLog *YVectorVector;
  uint64_t v6;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  int *v13;
  int v14;
  int *v15;
  int *v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  char *v21;
  char *v22;
  int v23;
  int YHat;
  unint64_t v25;
  int *v26;
  _DWORD *v27;
  pthread_mutex_t *CPMLLog;
  unint64_t v29;
  int *v30;
  int *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  int *v37;
  uint64_t v38;
  unint64_t v39;
  uint64_t v40;
  unint64_t v41;
  char *v42;
  int *v43;
  char *v44;
  int v45;
  char *v46;
  char *v47;
  _DWORD *v48;
  int v49;

  YVectorVector = (CPMLLog *)CPMLFeatureVector::getYVectorVector(this);
  v6 = *(_QWORD *)YVectorVector;
  if (*((_QWORD *)YVectorVector + 1) == *(_QWORD *)YVectorVector)
  {
    YHat = (int)CPMLFeatureVector::getYHat(this);
    v25 = *(_QWORD *)(a2 + 16);
    v26 = *(int **)(a2 + 8);
    if ((unint64_t)v26 >= v25)
    {
      v31 = *(int **)a2;
      v32 = ((uint64_t)v26 - *(_QWORD *)a2) >> 2;
      v33 = v32 + 1;
      if ((unint64_t)(v32 + 1) >> 62)
        goto LABEL_59;
      v34 = v25 - (_QWORD)v31;
      if (v34 >> 1 > v33)
        v33 = v34 >> 1;
      if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFFCLL)
        v35 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v35 = v33;
      if (v35)
      {
        v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a2 + 16, v35);
        v31 = *(int **)a2;
        v26 = *(int **)(a2 + 8);
      }
      else
      {
        v36 = 0;
      }
      v43 = (int *)&v36[4 * v32];
      v44 = &v36[4 * v35];
      *v43 = YHat;
      v27 = v43 + 1;
      while (v26 != v31)
      {
        v45 = *--v26;
        *--v43 = v45;
      }
      *(_QWORD *)a2 = v43;
      *(_QWORD *)(a2 + 8) = v27;
      *(_QWORD *)(a2 + 16) = v44;
      if (v31)
        operator delete(v31);
    }
    else
    {
      *v26 = YHat;
      v27 = v26 + 1;
    }
    *(_QWORD *)(a2 + 8) = v27;
    return;
  }
  v7 = *(_QWORD **)v6;
  v8 = (*(_QWORD *)(*(_QWORD *)v6 + 8) - **(_QWORD **)v6) << 30;
  if (!v8)
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(YVectorVector);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "getResponseValues", "No response values in vector\n");
    v29 = *(_QWORD *)(a2 + 16);
    v30 = *(int **)(a2 + 8);
    if ((unint64_t)v30 < v29)
    {
      *v30 = 0;
      *(_QWORD *)(a2 + 8) = v30 + 1;
      return;
    }
    v37 = *(int **)a2;
    v38 = ((uint64_t)v30 - *(_QWORD *)a2) >> 2;
    v39 = v38 + 1;
    if (!((unint64_t)(v38 + 1) >> 62))
    {
      v40 = v29 - (_QWORD)v37;
      if (v40 >> 1 > v39)
        v39 = v40 >> 1;
      if ((unint64_t)v40 >= 0x7FFFFFFFFFFFFFFCLL)
        v41 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v41 = v39;
      if (v41)
      {
        v42 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a2 + 16, v41);
        v37 = *(int **)a2;
        v30 = *(int **)(a2 + 8);
      }
      else
      {
        v42 = 0;
      }
      v46 = &v42[4 * v38];
      v47 = &v42[4 * v41];
      *(_DWORD *)v46 = 0;
      v48 = v46 + 4;
      while (v30 != v37)
      {
        v49 = *--v30;
        *((_DWORD *)v46 - 1) = v49;
        v46 -= 4;
      }
      *(_QWORD *)a2 = v46;
      *(_QWORD *)(a2 + 8) = v48;
      *(_QWORD *)(a2 + 16) = v47;
      if (v37)
        operator delete(v37);
      *(_QWORD *)(a2 + 8) = v48;
      return;
    }
LABEL_59:
    std::vector<double>::__throw_length_error[abi:ne180100]();
  }
  v9 = 0;
  v10 = v8 >> 32;
  v11 = (_QWORD *)(a2 + 16);
  if (v10 <= 1)
    v12 = 1;
  else
    v12 = v10;
  v13 = *(int **)(a2 + 8);
  do
  {
    v14 = *(_DWORD *)(*v7 + 4 * v9);
    if ((unint64_t)v13 >= *v11)
    {
      v16 = *(int **)a2;
      v17 = ((uint64_t)v13 - *(_QWORD *)a2) >> 2;
      v18 = v17 + 1;
      if ((unint64_t)(v17 + 1) >> 62)
        goto LABEL_59;
      v19 = *v11 - (_QWORD)v16;
      if (v19 >> 1 > v18)
        v18 = v19 >> 1;
      if ((unint64_t)v19 >= 0x7FFFFFFFFFFFFFFCLL)
        v20 = 0x3FFFFFFFFFFFFFFFLL;
      else
        v20 = v18;
      if (v20)
      {
        v21 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(a2 + 16, v20);
        v16 = *(int **)a2;
        v13 = *(int **)(a2 + 8);
      }
      else
      {
        v21 = 0;
      }
      v22 = &v21[4 * v17];
      *(_DWORD *)v22 = v14;
      v15 = (int *)(v22 + 4);
      while (v13 != v16)
      {
        v23 = *--v13;
        *((_DWORD *)v22 - 1) = v23;
        v22 -= 4;
      }
      *(_QWORD *)a2 = v22;
      *(_QWORD *)(a2 + 8) = v15;
      *(_QWORD *)(a2 + 16) = &v21[4 * v20];
      if (v16)
        operator delete(v16);
    }
    else
    {
      *v13 = v14;
      v15 = v13 + 1;
    }
    *(_QWORD *)(a2 + 8) = v15;
    ++v9;
    v13 = v15;
  }
  while (v9 != v12);
}

uint64_t CPMLNaiveBayesClassifierBase::processVectorDataSet(uint64_t a1, uint64_t *a2, uint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v8;
  unint64_t v9;
  uint64_t **v10;
  uint64_t *v11;
  int v12;

  v4 = *a2;
  if (a2[1] != *a2)
  {
    v8 = 0;
    v9 = 0;
    do
    {
      v10 = (uint64_t **)(v4 + v8);
      v11 = v10[1];
      v12 = CPMLNaiveBayesClassifierBase::processDiscreteDataSet(a1, *v10, a3, a4, 0);
      a3 = CPMLNaiveBayesClassifierBase::processContinousDataSet(a1, v11, v12, a4, 0);
      ++v9;
      v4 = *a2;
      v8 += 16;
    }
    while (v9 < (a2[1] - *a2) >> 4);
  }
  return a3;
}

uint64_t CPMLNaiveBayesClassifierBase::processDiscreteDataSet(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t v7;
  unint64_t v10;
  uint64_t v11;
  int v12;
  _QWORD *v13;
  _QWORD *v14;
  unint64_t v15;
  int v16;
  _BYTE v18[40];
  unint64_t v19;
  int v20;
  int *v21;

  v7 = *a2;
  if (a2[1] == *a2)
  {
    LODWORD(v15) = 0;
  }
  else
  {
    v10 = 0;
    v11 = a1 + 168;
    do
    {
      v20 = 0;
      v20 = *(_DWORD *)(v7 + 4 * v10);
      if (a5)
        v12 = v10;
      else
        v12 = 0;
      v19 = a4 | ((v12 + a3) << 31);
      v21 = (int *)&v19;
      v13 = std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v11, &v19, (uint64_t)&std::piecewise_construct, (_QWORD **)&v21);
      std::unordered_map<int,int>::unordered_map((uint64_t)v18, (uint64_t)(v13 + 3));
      v21 = &v20;
      v14 = std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)v18, &v20, (uint64_t)&std::piecewise_construct, &v21);
      ++*((_DWORD *)v14 + 5);
      std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)v18);
      ++v10;
      v7 = *a2;
      v15 = (a2[1] - *a2) >> 2;
    }
    while (v15 > v10);
  }
  if (a5)
    v16 = v15;
  else
    v16 = 1;
  return (v16 + a3);
}

void sub_209CEBC5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t CPMLNaiveBayesClassifierBase::processContinousDataSet(uint64_t a1, uint64_t *a2, int a3, int a4, int a5)
{
  uint64_t v7;
  unint64_t v10;
  uint64_t v11;
  double v12;
  int v13;
  double *v14;
  unint64_t v15;
  int v16;
  unint64_t v18;
  unint64_t *v19;

  v7 = *a2;
  if (a2[1] == *a2)
  {
    LODWORD(v15) = 0;
  }
  else
  {
    v10 = 0;
    v11 = a1 + 208;
    do
    {
      v12 = *(double *)(v7 + 8 * v10);
      if (a5)
        v13 = v10;
      else
        v13 = 0;
      v18 = a4 | ((v13 + a3) << 31);
      v19 = &v18;
      v14 = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v11, &v18, (uint64_t)&std::piecewise_construct, &v19);
      v14[3] = v12 + v14[3];
      ++v10;
      v7 = *a2;
      v15 = (a2[1] - *a2) >> 3;
    }
    while (v15 > v10);
  }
  if (a5)
    v16 = v15;
  else
    v16 = 1;
  return (v16 + a3);
}

double *CPMLNaiveBayesClassifierBase::updateMean(double *this)
{
  double *v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  double v5;
  int v6;
  unint64_t v7;
  int *v8;

  v1 = (double *)*((_QWORD *)this + 28);
  if (v1)
  {
    v2 = (uint64_t)(this + 46);
    v3 = (uint64_t)(this + 31);
    do
    {
      v4 = v1[3];
      v7 = *((_QWORD *)v1 + 2);
      v6 = v7;
      v8 = &v6;
      v5 = (double)*((int *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v2, &v6, (uint64_t)&std::piecewise_construct, &v8)+ 5)/ v4;
      v8 = (int *)&v7;
      this = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v3, &v7, (uint64_t)&std::piecewise_construct, (_QWORD **)&v8);
      this[3] = v5;
      v1 = *(double **)v1;
    }
    while (v1);
  }
  return this;
}

uint64_t CPMLNaiveBayesClassifierBase::processDataSetVariance(uint64_t a1, _QWORD *a2, int a3, int a4)
{
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  double v11;
  double *v12;
  unint64_t v13;
  unint64_t v15;
  unint64_t *v16;

  if (a2[1] == *a2)
  {
    LODWORD(v13) = 0;
  }
  else
  {
    v7 = 0;
    v8 = a1 + 248;
    v9 = a1 + 288;
    v10 = a3 << 31;
    do
    {
      v15 = v10 | a4;
      v16 = &v15;
      v11 = *(double *)(*a2 + 8 * v7)
          - *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v8, &v15, (uint64_t)&std::piecewise_construct, &v16)+ 3);
      v16 = &v15;
      v12 = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v9, &v15, (uint64_t)&std::piecewise_construct, &v16);
      v12[3] = v12[3] + v11 * v11;
      ++v7;
      v13 = (uint64_t)(a2[1] - *a2) >> 3;
      v10 += 0x80000000;
    }
    while (v13 > v7);
  }
  return (v13 + a3);
}

double *CPMLNaiveBayesClassifierBase::updateVariance(double *this)
{
  double *v1;
  uint64_t v2;
  uint64_t v3;
  double v4;
  double v5;
  int v6;
  unint64_t v7;
  int *v8;

  v1 = (double *)*((_QWORD *)this + 38);
  if (v1)
  {
    v2 = (uint64_t)(this + 46);
    v3 = (uint64_t)(this + 41);
    do
    {
      v4 = v1[3];
      v7 = *((_QWORD *)v1 + 2);
      v6 = v7;
      v8 = &v6;
      v5 = v4
         / ((double)*((int *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v2, &v6, (uint64_t)&std::piecewise_construct, &v8)+ 5)+ -1.0);
      v8 = (int *)&v7;
      this = (double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v3, &v7, (uint64_t)&std::piecewise_construct, (_QWORD **)&v8);
      this[3] = v5;
      v1 = *(double **)v1;
    }
    while (v1);
  }
  return this;
}

uint64_t CPMLNaiveBayesClassifierBase::eval(uint64_t a1, CPMLFeatureVector *a2, uint64_t *a3)
{
  uint64_t v5;
  unsigned int *v6;
  unint64_t v7;
  unsigned int *v8;
  unsigned int *v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;
  char *v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t *XVectorVector;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t v23;
  _QWORD *v24;
  _QWORD *IntVector;
  unint64_t v26;
  int v27;
  uint64_t v28;
  _DWORD *v29;
  char *v30;
  char *v31;
  _DWORD *v32;
  _DWORD *v33;
  int v34;
  _QWORD *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unsigned int *v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t *v45;
  double v46;
  uint64_t v47;
  uint64_t v48;
  unint64_t v49;
  int v50;
  _QWORD *v51;
  _QWORD *v52;
  unint64_t v53;
  int v54;
  double v55;
  double v56;
  double v57;
  double v58;
  unint64_t v59;
  unsigned int v60;
  double v61;
  double v62;
  double v63;
  double v64;
  char *v65;
  char *v66;
  uint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  _DWORD *v74;
  uint64_t v75;
  _QWORD *RealVector;
  uint64_t v78;
  uint64_t *v79;
  __int128 v80;
  unsigned int v81;
  std::vector<int>::value_type __x[4];
  __int128 v83;
  int v84;
  std::vector<int> v85;
  uint64_t v86;
  _QWORD *v87;
  unint64_t v88;
  unsigned int *v89;
  unsigned int *v90;
  char *v91;
  _DWORD *v92[2];

  if (!*(_QWORD *)(a1 + 104))
    return 0xFFFFFFFFLL;
  v89 = 0;
  v90 = 0;
  v91 = 0;
  if (!a3 || (v5 = *a3, a3[1] == *a3))
  {
    if (&v89 != (unsigned int **)(a1 + 144))
      std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>((char *)&v89, *(char **)(a1 + 144), *(_QWORD *)(a1 + 152), (uint64_t)(*(_QWORD *)(a1 + 152) - *(_QWORD *)(a1 + 144)) >> 2);
  }
  else
  {
    v6 = 0;
    v7 = 0;
    do
    {
      if (v6 >= (unsigned int *)v91)
      {
        v9 = v89;
        v10 = v6 - v89;
        v11 = v10 + 1;
        if ((unint64_t)(v10 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v12 = v91 - (char *)v89;
        if ((v91 - (char *)v89) >> 1 > v11)
          v11 = v12 >> 1;
        if ((unint64_t)v12 >= 0x7FFFFFFFFFFFFFFCLL)
          v13 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v13 = v11;
        if (v13)
        {
          v14 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v91, v13);
          v9 = v89;
          v6 = v90;
        }
        else
        {
          v14 = 0;
        }
        v15 = (unsigned int *)&v14[4 * v10];
        *v15 = *(_DWORD *)(v5 + 4 * v7);
        v8 = v15 + 1;
        while (v6 != v9)
        {
          v16 = *--v6;
          *--v15 = v16;
        }
        v89 = v15;
        v90 = v8;
        v91 = &v14[4 * v13];
        if (v9)
          operator delete(v9);
      }
      else
      {
        *v6 = *(_DWORD *)(v5 + 4 * v7);
        v8 = v6 + 1;
      }
      v90 = v8;
      ++v7;
      v5 = *a3;
      v6 = v8;
    }
    while (v7 < (a3[1] - *a3) >> 2);
  }
  v86 = 0;
  v87 = 0;
  v88 = 0;
  __x[0] = -1;
  std::vector<int>::vector(&v85, 1uLL, __x);
  XVectorVector = (uint64_t *)CPMLFeatureVector::getXVectorVector(a2);
  v18 = *XVectorVector;
  if (XVectorVector[1] != *XVectorVector)
  {
    v19 = 0;
    v20 = 0;
    v21 = v87;
    do
    {
      v22 = (uint64_t *)(v18 + v19);
      v23 = *v22;
      v24 = (_QWORD *)v22[1];
      if ((unint64_t)v21 >= v88)
      {
        v21 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v86, v23);
      }
      else
      {
        *v21 = 0;
        v21[1] = 0;
        v21[2] = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v21, *(const void **)v23, *(_QWORD *)(v23 + 8), (uint64_t)(*(_QWORD *)(v23 + 8) - *(_QWORD *)v23) >> 2);
        v21 += 3;
      }
      v87 = v21;
      if (v24[1] != *v24)
      {
        if ((unint64_t)v21 >= v88)
        {
          v21 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v86, (uint64_t)&v85);
        }
        else
        {
          *v21 = 0;
          v21[1] = 0;
          v21[2] = 0;
          std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v21, v85.__begin_, (uint64_t)v85.__end_, v85.__end_ - v85.__begin_);
          v21 += 3;
        }
        v87 = v21;
      }
      ++v20;
      v18 = *XVectorVector;
      v19 += 16;
    }
    while (v20 < (XVectorVector[1] - *XVectorVector) >> 4);
  }
  IntVector = (_QWORD *)CPMLFeatureVector::getIntVector(a2);
  if (IntVector[1] != *IntVector)
  {
    v26 = 0;
    do
    {
      memset(__x, 0, sizeof(__x));
      *(_QWORD *)&v83 = 0;
      v27 = *(_DWORD *)(*IntVector + 4 * v26);
      v29 = std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v83, 1uLL);
      v30 = *(char **)__x;
      v31 = *(char **)&__x[2];
      *v29 = v27;
      v32 = v29 + 1;
      v33 = v29;
      while (v31 != v30)
      {
        v34 = *((_DWORD *)v31 - 1);
        v31 -= 4;
        *--v33 = v34;
      }
      *(_QWORD *)__x = v33;
      *(_QWORD *)&__x[2] = v29 + 1;
      *(_QWORD *)&v83 = &v29[v28];
      if (v30)
        operator delete(v30);
      *(_QWORD *)&__x[2] = v32;
      v35 = v87;
      if ((unint64_t)v87 >= v88)
      {
        v36 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v86, (uint64_t)__x);
      }
      else
      {
        *v87 = 0;
        v35[1] = 0;
        v35[2] = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v35, *(const void **)__x, *(uint64_t *)&__x[2], (uint64_t)(*(_QWORD *)&__x[2] - *(_QWORD *)__x) >> 2);
        v36 = (uint64_t)(v35 + 3);
      }
      v87 = (_QWORD *)v36;
      if (*(_QWORD *)__x)
      {
        *(_QWORD *)&__x[2] = *(_QWORD *)__x;
        operator delete(*(void **)__x);
      }
      ++v26;
    }
    while (v26 < (uint64_t)(IntVector[1] - *IntVector) >> 2);
  }
  RealVector = (_QWORD *)CPMLFeatureVector::getRealVector(a2);
  if (RealVector[1] != *RealVector)
  {
    v37 = v87;
    if ((unint64_t)v87 >= v88)
    {
      v38 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v86, (uint64_t)&v85);
    }
    else
    {
      *v87 = 0;
      v37[1] = 0;
      v37[2] = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v37, v85.__begin_, (uint64_t)v85.__end_, v85.__end_ - v85.__begin_);
      v38 = (uint64_t)(v37 + 3);
    }
    v87 = (_QWORD *)v38;
  }
  v72 = a1 + 120;
  CPMLNaiveBayes::predict(*(void (****)(_QWORD, uint64_t, void **, uint64_t, uint64_t))(a1 + 576), (uint64_t)&v86, &v89, *(unsigned int *)(a1 + 512), a1 + 120);
  v73 = a1;
  v74 = IntVector;
  *(_OWORD *)__x = 0u;
  v83 = 0u;
  v84 = 1065353216;
  v40 = v89;
  if (v90 != v89)
  {
    v41 = 0;
    v75 = a1 + 368;
    v42 = a1 + 248;
    v43 = a1 + 328;
    do
    {
      v81 = 0;
      v81 = v40[v41];
      *(_QWORD *)&v80 = &v81;
      v44 = *((_DWORD *)std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(v75, (int *)&v81, (uint64_t)&std::piecewise_construct, (_DWORD **)&v80)+ 5);
      v45 = (uint64_t *)CPMLFeatureVector::getXVectorVector(a2);
      v78 = v41;
      v46 = (double)v44;
      v48 = *v45;
      v47 = v45[1];
      if (v47 == *v45)
      {
        v50 = 0;
      }
      else
      {
        v49 = 0;
        v50 = 0;
        v79 = v45;
        do
        {
          v51 = (_QWORD *)(v48 + 16 * v49);
          v52 = (_QWORD *)v51[1];
          v50 += (*(_QWORD *)(*v51 + 8) - *(_QWORD *)*v51) >> 2;
          if (v52[1] != *v52)
          {
            v53 = 0;
            v54 = v50 << 31;
            do
            {
              v92[0] = (_DWORD *)(int)(v81 | v54);
              v55 = *(double *)(*v52 + 8 * v53);
              *(_QWORD *)&v80 = v92;
              v56 = *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v42, (unint64_t *)v92, (uint64_t)&std::piecewise_construct, (_QWORD **)&v80)+ 3);
              *(_QWORD *)&v80 = v92;
              v57 = *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v43, (unint64_t *)v92, (uint64_t)&std::piecewise_construct, (_QWORD **)&v80)+ 3);
              v58 = 1.0;
              if (v57 != 0.0)
                v58 = exp(-((v55 - v56) * (v55 - v56)) / (v57 + v57)) / sqrt(v57 * 6.28318531);
              v46 = v46 * v58;
              ++v53;
              v54 += 0x80000000;
            }
            while (v53 < (uint64_t)(v52[1] - *v52) >> 3);
            v48 = *v79;
            v47 = v79[1];
            v50 += v53;
          }
          ++v49;
        }
        while (v49 < (v47 - v48) >> 4);
      }
      if (RealVector[1] != *RealVector)
      {
        v59 = 0;
        v60 = (v50 + ((v74[2] - *v74) >> 2)) << 31;
        do
        {
          v92[0] = (_DWORD *)(int)(v81 | v60);
          v61 = *(double *)(*RealVector + 8 * v59);
          *(_QWORD *)&v80 = v92;
          v62 = *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v42, (unint64_t *)v92, (uint64_t)&std::piecewise_construct, (_QWORD **)&v80)+ 3);
          *(_QWORD *)&v80 = v92;
          v63 = *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(v43, (unint64_t *)v92, (uint64_t)&std::piecewise_construct, (_QWORD **)&v80)+ 3);
          v64 = 1.0;
          if (v63 != 0.0)
            v64 = exp(-((v61 - v62) * (v61 - v62)) / (v63 + v63)) / sqrt(v63 * 6.28318531);
          v46 = v46 * v64;
          ++v59;
          v60 += 0x80000000;
        }
        while (v59 < (uint64_t)(RealVector[1] - *RealVector) >> 3);
      }
      *(_QWORD *)&v80 = &v81;
      *((double *)std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)__x, (int *)&v81, (uint64_t)&std::piecewise_construct, (_DWORD **)&v80)+ 3) = v46;
      v41 = v78 + 1;
      v40 = v89;
    }
    while (v78 + 1 < (unint64_t)(v90 - v89));
  }
  v65 = *(char **)(v73 + 120);
  v66 = *(char **)(v73 + 128);
  if (v66 == v65)
  {
    v69 = (v66 - v65) >> 4;
    v65 = *(char **)(v73 + 128);
  }
  else
  {
    v67 = 0;
    v68 = 0;
    do
    {
      v80 = *(_OWORD *)&v65[v67];
      v92[0] = (_DWORD *)&v80 + 2;
      std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)__x, (int *)&v80 + 2, (uint64_t)&std::piecewise_construct, v92);
      ++v68;
      v65 = *(char **)(v73 + 120);
      v66 = *(char **)(v73 + 128);
      v69 = (v66 - v65) >> 4;
      v67 += 16;
    }
    while (v69 > v68);
  }
  *(_QWORD *)&v80 = sortProbIndex;
  v70 = 126 - 2 * __clz(v69);
  if (v66 == v65)
    v71 = 0;
  else
    v71 = v70;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,false>(v65, v66, (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))&v80, v71, 1);
  CPMLFeatureVector::setYHatProbList((uint64_t)a2, v72);
  *(_QWORD *)(v73 + 128) = *(_QWORD *)(v73 + 120);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)__x);
  if (v85.__begin_)
  {
    v85.__end_ = v85.__begin_;
    operator delete(v85.__begin_);
  }
  *(_QWORD *)__x = &v86;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)__x);
  if (v89)
  {
    v90 = v89;
    operator delete(v89);
  }
  return 0;
}

void sub_209CEC754(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,char *a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *__p,uint64_t a28,uint64_t a29,char a30,uint64_t a31)
{
  uint64_t v31;
  void *v33;

  if (__p)
  {
    a28 = (uint64_t)__p;
    operator delete(__p);
  }
  a21 = &a30;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&a21);
  v33 = *(void **)(v31 - 176);
  if (v33)
  {
    *(_QWORD *)(v31 - 168) = v33;
    operator delete(v33);
  }
  _Unwind_Resume(a1);
}

void CPMLNaiveBayesClassifierBase::normalDistribution(CPMLNaiveBayesClassifierBase *this, double a2, double a3, double a4)
{
  if (a3 != 0.0)
    exp(-((a4 - a2) * (a4 - a2)) / (a3 + a3));
}

BOOL sortProbIndex(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(double *)&a1 < *(double *)&a3;
}

uint64_t CPMLNaiveBayesClassifierBase::update(CPMLNaiveBayesClassifierBase *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t Iterator;
  uint64_t v6;
  CPMLFeatureVector *v7;
  uint64_t *XVectorVector;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t *v13;
  uint64_t v14;
  _QWORD *v15;
  _QWORD *IntVector;
  unint64_t v17;
  int v18;
  uint64_t v19;
  _DWORD *v20;
  char *v21;
  char *v22;
  char *v23;
  _DWORD *v24;
  int v25;
  _QWORD *v26;
  uint64_t v27;
  _QWORD *RealVector;
  _QWORD *v29;
  uint64_t v30;
  unsigned int *v31;
  unint64_t v32;
  double v33;
  int v34;
  int v35;
  void **v36;
  _QWORD *v37;
  int *v38;
  int *v39;
  int *v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  char *v45;
  int *v46;
  int v47;
  std::vector<int>::value_type __x[2];
  char *v52;
  _DWORD *v53;
  std::vector<int> v54;
  uint64_t v55;
  _QWORD *v56;
  unint64_t v57;
  void *__p;
  _BYTE *v59;
  uint64_t v60;

  Iterator = CPMLCDB::getIterator(a2, 0, 0, 1);
  *((_QWORD *)this + 10) = Iterator;
  v6 = (*(uint64_t (**)(uint64_t))(*(_QWORD *)Iterator + 32))(Iterator);
  if (v6)
  {
    v7 = (CPMLFeatureVector *)v6;
    do
    {
      __p = 0;
      v59 = 0;
      v60 = 0;
      CPMLNaiveBayesClassifierBase::getResponseValues(v6, (uint64_t)&__p, v7);
      v55 = 0;
      v56 = 0;
      v57 = 0;
      __x[0] = -1;
      std::vector<int>::vector(&v54, 1uLL, __x);
      XVectorVector = (uint64_t *)CPMLFeatureVector::getXVectorVector(v7);
      v9 = *XVectorVector;
      if (XVectorVector[1] != *XVectorVector)
      {
        v10 = 0;
        v11 = 0;
        v12 = v56;
        do
        {
          v13 = (uint64_t *)(v9 + v10);
          v14 = *v13;
          v15 = (_QWORD *)v13[1];
          if ((unint64_t)v12 >= v57)
          {
            v12 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v55, v14);
          }
          else
          {
            *v12 = 0;
            v12[1] = 0;
            v12[2] = 0;
            std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v12, *(const void **)v14, *(_QWORD *)(v14 + 8), (uint64_t)(*(_QWORD *)(v14 + 8) - *(_QWORD *)v14) >> 2);
            v12 += 3;
          }
          v56 = v12;
          if (v15[1] != *v15)
          {
            if ((unint64_t)v12 >= v57)
            {
              v12 = (_QWORD *)std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v55, (uint64_t)&v54);
            }
            else
            {
              *v12 = 0;
              v12[1] = 0;
              v12[2] = 0;
              std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v12, v54.__begin_, (uint64_t)v54.__end_, v54.__end_ - v54.__begin_);
              v12 += 3;
            }
            v56 = v12;
          }
          ++v11;
          v9 = *XVectorVector;
          v10 += 16;
        }
        while (v11 < (XVectorVector[1] - *XVectorVector) >> 4);
      }
      IntVector = (_QWORD *)CPMLFeatureVector::getIntVector(v7);
      if (IntVector[1] != *IntVector)
      {
        v17 = 0;
        do
        {
          *(_QWORD *)__x = 0;
          v52 = 0;
          v53 = 0;
          v18 = *(_DWORD *)(*IntVector + 4 * v17);
          v20 = std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v53, 1uLL);
          v21 = *(char **)__x;
          v22 = v52;
          *v20 = v18;
          v23 = (char *)(v20 + 1);
          v24 = v20;
          while (v22 != v21)
          {
            v25 = *((_DWORD *)v22 - 1);
            v22 -= 4;
            *--v24 = v25;
          }
          *(_QWORD *)__x = v24;
          v52 = (char *)(v20 + 1);
          v53 = &v20[v19];
          if (v21)
            operator delete(v21);
          v52 = v23;
          v26 = v56;
          if ((unint64_t)v56 >= v57)
          {
            v27 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v55, (uint64_t)__x);
          }
          else
          {
            *v56 = 0;
            v26[1] = 0;
            v26[2] = 0;
            std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v26, *(const void **)__x, (uint64_t)v52, (uint64_t)&v52[-*(_QWORD *)__x] >> 2);
            v27 = (uint64_t)(v26 + 3);
          }
          v56 = (_QWORD *)v27;
          if (*(_QWORD *)__x)
          {
            v52 = *(char **)__x;
            operator delete(*(void **)__x);
          }
          ++v17;
        }
        while (v17 < (uint64_t)(IntVector[1] - *IntVector) >> 2);
      }
      RealVector = (_QWORD *)CPMLFeatureVector::getRealVector(v7);
      if (RealVector[1] != *RealVector)
      {
        v29 = v56;
        if ((unint64_t)v56 >= v57)
        {
          v30 = std::vector<std::vector<int>>::__push_back_slow_path<std::vector<int> const&>(&v55, (uint64_t)&v54);
        }
        else
        {
          *v56 = 0;
          v29[1] = 0;
          v29[2] = 0;
          std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v29, v54.__begin_, (uint64_t)v54.__end_, v54.__end_ - v54.__begin_);
          v30 = (uint64_t)(v29 + 3);
        }
        v56 = (_QWORD *)v30;
      }
      v31 = (unsigned int *)__p;
      if (v59 != __p)
      {
        v32 = 0;
        do
        {
          CPMLNaiveBayes::update(*((_QWORD *)this + 72), &v55, v31[v32++]);
          v31 = (unsigned int *)__p;
        }
        while (v32 < (v59 - (_BYTE *)__p) >> 2);
      }
      if (v54.__begin_)
      {
        v54.__end_ = v54.__begin_;
        operator delete(v54.__begin_);
      }
      v54.__begin_ = (std::vector<int>::pointer)&v55;
      std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&v54);
      if (__p)
      {
        v59 = __p;
        operator delete(__p);
      }
      v6 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      v7 = (CPMLFeatureVector *)v6;
    }
    while (v6);
  }
  v33 = (*(double (**)(_QWORD))(**((_QWORD **)this + 73) + 64))(*((_QWORD *)this + 73));
  if (v33 != (double)*((unint64_t *)this + 13))
  {
    (*((void (**)(CPMLSerialization *, unint64_t, const char *, const char *, _QWORD))a3->var0 + 21))(a3, (unint64_t)v33, "resultCardinality", "resultCardinality", 0);
    v34 = *((_DWORD *)this + 26);
    v35 = (int)v33;
    if (v34 < (int)v33)
    {
      v36 = (void **)((char *)this + 144);
      v37 = (_QWORD *)((char *)this + 160);
      v38 = (int *)*((_QWORD *)this + 19);
      do
      {
        if ((unint64_t)v38 >= *v37)
        {
          v40 = (int *)*v36;
          v41 = ((char *)v38 - (_BYTE *)*v36) >> 2;
          v42 = v41 + 1;
          if ((unint64_t)(v41 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v43 = *v37 - (_QWORD)v40;
          if (v43 >> 1 > v42)
            v42 = v43 >> 1;
          if ((unint64_t)v43 >= 0x7FFFFFFFFFFFFFFCLL)
            v44 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v44 = v42;
          if (v44)
          {
            v45 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 160, v44);
            v40 = (int *)*((_QWORD *)this + 18);
            v38 = (int *)*((_QWORD *)this + 19);
          }
          else
          {
            v45 = 0;
          }
          v46 = (int *)&v45[4 * v41];
          *v46 = v34;
          v39 = v46 + 1;
          while (v38 != v40)
          {
            v47 = *--v38;
            *--v46 = v47;
          }
          *((_QWORD *)this + 18) = v46;
          *((_QWORD *)this + 19) = v39;
          *((_QWORD *)this + 20) = &v45[4 * v44];
          if (v40)
            operator delete(v40);
        }
        else
        {
          *v38 = v34;
          v39 = v38 + 1;
        }
        *((_QWORD *)this + 19) = v39;
        ++v34;
        v38 = v39;
      }
      while (v34 != v35);
    }
    CPMLNaiveBayes::set_candidates(*((_QWORD *)this + 72), (unsigned int **)this + 18);
    *((_QWORD *)this + 13) = (unint64_t)v33;
    *((_DWORD *)a2->var0 + 33) = v35;
  }
  return 0;
}

void sub_209CECD00(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, char *__p, char *a15, uint64_t a16, char a17, uint64_t a18, uint64_t a19, void *a20,uint64_t a21)
{
  if (__p)
  {
    a15 = __p;
    operator delete(__p);
  }
  __p = &a17;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  if (a20)
  {
    a21 = (uint64_t)a20;
    operator delete(a20);
  }
  _Unwind_Resume(a1);
}

uint64_t CPMLNaiveBayesClassifierBase::errorString(CPMLNaiveBayesClassifierBase *this)
{
  return 0;
}

uint64_t CPMLNaiveBayesClassifierBase::setDelegateEngine(CPMLNaiveBayesClassifierBase *this, CPMLDelegateEngine *a2)
{
  CPMLNaiveBayes::set_engine(*((_QWORD *)this + 72), a2);
  return (*(uint64_t (**)(_QWORD, CPMLDelegateEngine *))(**((_QWORD **)this + 73) + 56))(*((_QWORD *)this + 73), a2);
}

void std::__throw_out_of_range[abi:ne180100](const char *a1)
{
  std::logic_error *exception;

  exception = (std::logic_error *)__cxa_allocate_exception(0x10uLL);
  std::out_of_range::out_of_range[abi:ne180100](exception, a1);
  __cxa_throw(exception, (struct type_info *)off_24C254828, MEMORY[0x24BEDAB00]);
}

void sub_209CECE18(_Unwind_Exception *a1)
{
  void *v1;

  __cxa_free_exception(v1);
  _Unwind_Resume(a1);
}

std::logic_error *std::out_of_range::out_of_range[abi:ne180100](std::logic_error *a1, const char *a2)
{
  std::logic_error *result;

  result = std::logic_error::logic_error(a1, a2);
  result->__vftable = (std::logic_error_vtbl *)(MEMORY[0x24BEDB8C0] + 16);
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::~__hash_table(uint64_t a1)
{
  void *v2;

  std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::__deallocate_node(a1, *(_QWORD **)(a1 + 16));
  v2 = *(void **)a1;
  *(_QWORD *)a1 = 0;
  if (v2)
    operator delete(v2);
  return a1;
}

void std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::__deallocate_node(uint64_t a1, _QWORD *a2)
{
  _QWORD *v2;
  _QWORD *v3;

  if (a2)
  {
    v2 = a2;
    do
    {
      v3 = (_QWORD *)*v2;
      std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)(v2 + 3));
      operator delete(v2);
      v2 = v3;
    }
    while (v3);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD *v10;
  _QWORD *v11;
  unint64_t v12;
  uint64_t v13;
  char *v14;
  float v15;
  float v16;
  _BOOL8 v17;
  unint64_t v18;
  unint64_t v19;
  size_t v20;
  _QWORD *v21;
  unint64_t v22;
  _QWORD v24[2];
  char v25;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = (_QWORD *)*v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (v11[2] == v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v13 = a1 + 16;
  v14 = (char *)operator new(0x40uLL);
  v24[0] = v14;
  v24[1] = a1 + 16;
  *(_QWORD *)v14 = 0;
  *((_QWORD *)v14 + 1) = v7;
  *((_QWORD *)v14 + 2) = **a4;
  *(_OWORD *)(v14 + 40) = 0u;
  *(_OWORD *)(v14 + 24) = 0u;
  *((_DWORD *)v14 + 14) = 1065353216;
  v25 = 1;
  v15 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v16 = *(float *)(a1 + 32);
  if (!v8 || (float)(v16 * (float)v8) < v15)
  {
    v17 = 1;
    if (v8 >= 3)
      v17 = (v8 & (v8 - 1)) != 0;
    v18 = v17 | (2 * v8);
    v19 = vcvtps_u32_f32(v15 / v16);
    if (v18 <= v19)
      v20 = v19;
    else
      v20 = v18;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v20);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v21 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v21)
  {
    *(_QWORD *)v24[0] = *v21;
    *v21 = v24[0];
  }
  else
  {
    *(_QWORD *)v24[0] = *(_QWORD *)(a1 + 16);
    *(_QWORD *)(a1 + 16) = v24[0];
    *(_QWORD *)(*(_QWORD *)a1 + 8 * v4) = v13;
    if (*(_QWORD *)v24[0])
    {
      v22 = *(_QWORD *)(*(_QWORD *)v24[0] + 8);
      if ((v8 & (v8 - 1)) != 0)
      {
        if (v22 >= v8)
          v22 %= v8;
      }
      else
      {
        v22 &= v8 - 1;
      }
      *(_QWORD *)(*(_QWORD *)a1 + 8 * v22) = v24[0];
    }
  }
  v11 = (_QWORD *)v24[0];
  v24[0] = 0;
  ++*(_QWORD *)(a1 + 24);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>>>>::reset[abi:ne180100]((uint64_t)v24, 0);
  return v11;
}

void sub_209CED118(_Unwind_Exception *a1, uint64_t a2, ...)
{
  va_list va;

  va_start(va, a2);
  std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>>>>::reset[abi:ne180100]((uint64_t)va, 0);
  _Unwind_Resume(a1);
}

void std::unique_ptr<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>,std::__hash_node_destructor<std::allocator<std::__hash_node<std::__hash_value_type<unsigned long long,std::unordered_map<int,int>>,void *>>>>::reset[abi:ne180100](uint64_t a1, uint64_t a2)
{
  void *v2;

  v2 = *(void **)a1;
  *(_QWORD *)a1 = a2;
  if (v2)
  {
    if (*(_BYTE *)(a1 + 16))
      std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)v2 + 24);
    operator delete(v2);
  }
}

uint64_t std::unordered_map<int,int>::unordered_map(uint64_t a1, uint64_t a2)
{
  int *i;

  *(_OWORD *)a1 = 0u;
  *(_OWORD *)(a1 + 16) = 0u;
  *(_DWORD *)(a1 + 32) = *(_DWORD *)(a2 + 32);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, *(_QWORD *)(a2 + 8));
  for (i = *(int **)(a2 + 16); i; i = *(int **)i)
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::pair<int const,int> const&>(a1, i + 4, (_QWORD *)i + 2);
  return a1;
}

void sub_209CED1D0(_Unwind_Exception *a1)
{
  uint64_t v1;

  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__emplace_unique_key_args<int,std::pair<int const,int> const&>(uint64_t a1, int *a2, _QWORD *a3)
{
  unint64_t v3;
  unint64_t v6;
  unint64_t v7;
  uint8x8_t v8;
  void **v9;
  _QWORD *v10;
  unint64_t v11;
  float v12;
  float v13;
  _BOOL8 v14;
  unint64_t v15;
  unint64_t v16;
  size_t v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;

  v6 = *a2;
  v7 = *(_QWORD *)(a1 + 8);
  if (v7)
  {
    v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      v3 = *a2;
      if (v7 <= v6)
        v3 = v6 % v7;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
    v9 = *(void ***)(*(_QWORD *)a1 + 8 * v3);
    if (v9)
    {
      v10 = *v9;
      if (*v9)
      {
        do
        {
          v11 = v10[1];
          if (v11 == v6)
          {
            if (*((_DWORD *)v10 + 4) == (_DWORD)v6)
              return v10;
          }
          else
          {
            if (v8.u32[0] > 1uLL)
            {
              if (v11 >= v7)
                v11 %= v7;
            }
            else
            {
              v11 &= v7 - 1;
            }
            if (v11 != v3)
              break;
          }
          v10 = (_QWORD *)*v10;
        }
        while (v10);
      }
    }
  }
  v10 = operator new(0x18uLL);
  *v10 = 0;
  v10[1] = v6;
  v10[2] = *a3;
  v12 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v13 = *(float *)(a1 + 32);
  if (!v7 || (float)(v13 * (float)v7) < v12)
  {
    v14 = 1;
    if (v7 >= 3)
      v14 = (v7 & (v7 - 1)) != 0;
    v15 = v14 | (2 * v7);
    v16 = vcvtps_u32_f32(v12 / v13);
    if (v15 <= v16)
      v17 = v16;
    else
      v17 = v15;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v17);
    v7 = *(_QWORD *)(a1 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v7 <= v6)
        v3 = v6 % v7;
      else
        v3 = v6;
    }
    else
    {
      v3 = (v7 - 1) & v6;
    }
  }
  v18 = *(_QWORD *)a1;
  v19 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v3);
  if (v19)
  {
    *v10 = *v19;
LABEL_38:
    *v19 = v10;
    goto LABEL_39;
  }
  *v10 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v10;
  *(_QWORD *)(v18 + 8 * v3) = a1 + 16;
  if (*v10)
  {
    v20 = *(_QWORD *)(*v10 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v20 >= v7)
        v20 %= v7;
    }
    else
    {
      v20 &= v7 - 1;
    }
    v19 = (_QWORD *)(*(_QWORD *)a1 + 8 * v20);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v10;
}

void sub_209CED3EC(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::vector<VectorClass>::__throw_out_of_range[abi:ne180100]()
{
  std::__throw_out_of_range[abi:ne180100]("vector");
}

char *std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 2)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 1;
    if (v8 >> 1 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<int>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 2;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[4 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

std::vector<int> *__cdecl std::vector<int>::vector(std::vector<int> *this, std::vector<int>::size_type __n, const std::vector<int>::value_type *__x)
{
  std::vector<int>::pointer end;
  int *v7;
  std::vector<int>::size_type v8;

  this->__begin_ = 0;
  this->__end_ = 0;
  this->__end_cap_.__value_ = 0;
  if (__n)
  {
    std::vector<int>::__vallocate[abi:ne180100](this, __n);
    end = this->__end_;
    v7 = &end[__n];
    v8 = 4 * __n;
    do
    {
      *end++ = *__x;
      v8 -= 4;
    }
    while (v8);
    this->__end_ = v7;
  }
  return this;
}

void sub_209CED580(_Unwind_Exception *exception_object)
{
  uint64_t v1;
  void *v3;

  v3 = *(void **)v1;
  if (*(_QWORD *)v1)
  {
    *(_QWORD *)(v1 + 8) = v3;
    operator delete(v3);
  }
  _Unwind_Resume(exception_object);
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_209CED7A4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

_QWORD *std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>(uint64_t a1, int *a2, uint64_t a3, _DWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  void **v10;
  _QWORD *v11;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v8 <= v7)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(void ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      v11 = *v10;
      if (*v10)
      {
        do
        {
          v12 = v11[1];
          if (v12 == v7)
          {
            if (*((_DWORD *)v11 + 4) == (_DWORD)v7)
              return v11;
          }
          else
          {
            if (v9.u32[0] > 1uLL)
            {
              if (v12 >= v8)
                v12 %= v8;
            }
            else
            {
              v12 &= v8 - 1;
            }
            if (v12 != v4)
              break;
          }
          v11 = (_QWORD *)*v11;
        }
        while (v11);
      }
    }
  }
  v11 = operator new(0x20uLL);
  *v11 = 0;
  v11[1] = v7;
  *((_DWORD *)v11 + 4) = **a4;
  v11[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v8 <= v7)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *v11 = *v20;
LABEL_38:
    *v20 = v11;
    goto LABEL_39;
  }
  *v11 = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = v11;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*v11)
  {
    v21 = *(_QWORD *)(*v11 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return v11;
}

void sub_209CED9C4(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,false>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4, char a5)
{
  char *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char v17;
  BOOL v18;
  uint64_t v19;
  uint64_t v20;
  char *v21;
  __int128 v22;
  __int128 v23;

LABEL_1:
  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = a2 - v9;
    v13 = (a2 - v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v19 = *((_QWORD *)a2 - 2);
        v20 = *((_QWORD *)a2 - 1);
        v21 = a2 - 16;
        if ((*a3)(v19, v20, *(_QWORD *)v9, *((_QWORD *)v9 + 1)))
        {
          v23 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *(_OWORD *)v21;
          *(_OWORD *)v21 = v23;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v9, (_QWORD *)v9 + 2, (_QWORD *)a2 - 2, a3);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v9, (_QWORD *)v9 + 2, (_QWORD *)v9 + 4, (_QWORD *)a2 - 2, a3);
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v9, (_QWORD *)v9 + 2, (_QWORD *)v9 + 4, (_QWORD *)v9 + 6, (_QWORD *)a2 - 2, a3);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((uint64_t)v9, a2, a3);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((uint64_t)v9, a2, a3);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = &v9[16 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(&v9[16 * (v13 >> 1)], v9, (_QWORD *)a2 - 2, a3);
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v9, &v9[16 * (v13 >> 1)], (_QWORD *)a2 - 2, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((_QWORD *)v9 + 2, (_QWORD *)v15 - 2, (_QWORD *)a2 - 4, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((_QWORD *)v9 + 4, &v9[16 * v14 + 16], (_QWORD *)a2 - 6, a3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((_QWORD *)v15 - 2, v15, &v9[16 * v14 + 16], a3);
            v22 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *(_OWORD *)v15;
            *(_OWORD *)v15 = v22;
            if ((a5 & 1) != 0)
              goto LABEL_11;
          }
          if (((*a3)(*((_QWORD *)v9 - 2), *((_QWORD *)v9 - 1), *(_QWORD *)v9, *((_QWORD *)v9 + 1)) & 1) == 0)
          {
            v9 = (char *)std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,BOOL (*&)(ProbIndex,ProbIndex)>(v9, a2, a3);
            goto LABEL_16;
          }
LABEL_11:
          v16 = (char *)std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,BOOL (*&)(ProbIndex,ProbIndex)>((uint64_t *)v9, (uint64_t *)a2, a3);
          if ((v17 & 1) == 0)
            goto LABEL_14;
          v18 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v9, v16, a3);
          v9 = v16 + 16;
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(v16 + 16, a2, a3))
          {
            v10 = v11 + 1;
            if (v18)
              continue;
LABEL_14:
            std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,false>(a1, v16, a3, -v11, a5 & 1);
            v9 = v16 + 16;
LABEL_16:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = v16;
          if (v18)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,ProbIndex*>(v9, a2, a2, a3);
        return;
    }
  }
}

  v9 = a1;
LABEL_2:
  v10 = 1 - a4;
  while (2)
  {
    a1 = v9;
    v11 = v10;
    v12 = (char *)a2 - (char *)v9;
    v13 = ((char *)a2 - (char *)v9) >> 4;
    switch(v13)
    {
      case 0uLL:
      case 1uLL:
        return;
      case 2uLL:
        v20 = (__int128 *)(a2 - 2);
        v21 = *(a2 - 2);
        if (v21 > *v9 || v21 == *v9 && *((_DWORD *)a2 - 2) < *((_DWORD *)v9 + 2))
        {
          v23 = *(_OWORD *)v9;
          *(_OWORD *)v9 = *v20;
          *v20 = v23;
        }
        return;
      case 3uLL:
        std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)v9, (__int128 *)v9 + 1, (__int128 *)a2 - 1);
        return;
      case 4uLL:
        std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)v9, (uint64_t)(v9 + 2), (uint64_t)(v9 + 4), (uint64_t)(a2 - 2));
        return;
      case 5uLL:
        std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__n128 *)v9, (__n128 *)v9 + 1, (__n128 *)v9 + 2, (__n128 *)v9 + 3, (__n128 *)a2 - 1);
        return;
      default:
        if (v12 <= 383)
        {
          if ((a5 & 1) != 0)
            std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(v9, a2);
          else
            std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(v9, a2);
          return;
        }
        if (v11 != 1)
        {
          v14 = v13 >> 1;
          v15 = (__int128 *)&v9[2 * (v13 >> 1)];
          if ((unint64_t)v12 < 0x801)
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)&v9[2 * (v13 >> 1)], (__int128 *)v9, (__int128 *)a2 - 1);
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          else
          {
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)v9, (__int128 *)&v9[2 * (v13 >> 1)], (__int128 *)a2 - 1);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)v9 + 1, v15 - 1, (__int128 *)a2 - 2);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)v9 + 2, (__int128 *)&v9[2 * v14 + 2], (__int128 *)a2 - 3);
            std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(v15 - 1, v15, (__int128 *)&v9[2 * v14 + 2]);
            v22 = *(_OWORD *)v9;
            *(_OWORD *)v9 = *v15;
            *v15 = v22;
            if ((a5 & 1) != 0)
              goto LABEL_13;
          }
          v16 = *(v9 - 2);
          if (v16 <= *v9 && (v16 != *v9 || *((_DWORD *)v9 - 2) >= *((_DWORD *)v9 + 2)))
          {
            v9 = std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,CPMLNBCompareProbIndexDescending &>((uint64_t)v9, (unint64_t)a2);
            goto LABEL_18;
          }
LABEL_13:
          v17 = std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,CPMLNBCompareProbIndexDescending &>((uint64_t)v9, (unint64_t)a2);
          if ((v18 & 1) == 0)
            goto LABEL_16;
          v19 = std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)v9, v17);
          v9 = (double *)(v17 + 16);
          if (!std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(v17 + 16, (uint64_t)a2))
          {
            v10 = v11 + 1;
            if (v19)
              continue;
LABEL_16:
            std::__introsort<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *,false>(a1, v17, a3, -v11, a5 & 1);
            v9 = (double *)(v17 + 16);
LABEL_18:
            a5 = 0;
            a4 = -v11;
            goto LABEL_2;
          }
          a4 = -v11;
          a2 = (double *)v17;
          if (v19)
            return;
          goto LABEL_1;
        }
        if (v9 != a2)
          std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *,ProbIndex *>((uint64_t)v9, (__int128 *)a2, (__int128 *)a2, a3);
        return;
    }
  }
}

uint64_t std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(uint64_t result, _QWORD *a2, uint64_t (**a3)(uint64_t, uint64_t, _QWORD, _QWORD))
{
  _QWORD *v4;
  _QWORD *v5;
  uint64_t v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (_QWORD *)(result + 16);
    if ((_QWORD *)(result + 16) != a2)
    {
      v7 = 0;
      v8 = (_QWORD *)result;
      do
      {
        v9 = v5;
        result = (*a3)(v8[2], v8[3], *v8, v8[1]);
        if ((_DWORD)result)
        {
          v10 = *v9;
          v11 = v8[3];
          v12 = v7;
          while (1)
          {
            *(_OWORD *)((char *)v4 + v12 + 16) = *(_OWORD *)((char *)v4 + v12);
            if (!v12)
              break;
            result = (*a3)(v10, v11, *(_QWORD *)((char *)v4 + v12 - 16), *(_QWORD *)((char *)v4 + v12 - 8));
            v12 -= 16;
            if ((result & 1) == 0)
            {
              v13 = (_QWORD *)((char *)v4 + v12 + 16);
              goto LABEL_10;
            }
          }
          v13 = v4;
LABEL_10:
          *v13 = v10;
          v13[1] = v11;
        }
        v5 = v9 + 2;
        v7 += 16;
        v8 = v9;
      }
      while (v9 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(uint64_t result, _QWORD *a2, uint64_t (**a3)(uint64_t, uint64_t, _QWORD, _QWORD))
{
  _QWORD *v4;
  _QWORD *v5;
  _QWORD *v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD *v10;
  _QWORD *v11;

  if ((_QWORD *)result != a2)
  {
    v4 = (_QWORD *)result;
    v5 = (_QWORD *)(result + 16);
    if ((_QWORD *)(result + 16) != a2)
    {
      do
      {
        v7 = v5;
        result = (*a3)(v4[2], v4[3], *v4, v4[1]);
        if ((_DWORD)result)
        {
          v8 = *v7;
          v9 = v4[3];
          v10 = v7;
          do
          {
            v11 = v10 - 1;
            *v10 = *(v10 - 1);
            result = (*a3)(v8, v9, *((_QWORD *)v10 - 4), *((_QWORD *)v10 - 3));
            v10 = v11;
          }
          while ((result & 1) != 0);
          *v11 = v8;
          v11[1] = v9;
        }
        v5 = v7 + 2;
        v4 = v7;
      }
      while (v7 + 2 != a2);
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, uint64_t (**a4)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  char v8;
  uint64_t result;
  __int128 v10;
  __int128 v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;

  v8 = (*a4)(*a2, a2[1], *a1, a1[1]);
  result = (*a4)(*a3, a3[1], *a2, a2[1]);
  if ((v8 & 1) == 0)
  {
    if (!(_DWORD)result)
      return result;
    v11 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v11;
    if (!(*a4)(*a2, a2[1], *a1, a1[1]))
      return 1;
    v12 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v12;
    return 2;
  }
  if (!(_DWORD)result)
  {
    v13 = *(_OWORD *)a1;
    *(_OWORD *)a1 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v13;
    if (!(*a4)(*a3, a3[1], *a2, a2[1]))
      return 1;
    v14 = *(_OWORD *)a2;
    *(_OWORD *)a2 = *(_OWORD *)a3;
    *(_OWORD *)a3 = v14;
    return 2;
  }
  v10 = *(_OWORD *)a1;
  *(_OWORD *)a1 = *(_OWORD *)a3;
  *(_OWORD *)a3 = v10;
  return 1;
}

_QWORD *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,BOOL (*&)(ProbIndex,ProbIndex)>(_QWORD *a1, _OWORD *a2, uint64_t (**a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  _OWORD *v4;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  __int128 v20;

  v4 = a2;
  v6 = *a1;
  v7 = a1[1];
  if (((*a3)(*a1, v7, *((_QWORD *)a2 - 2), *((_QWORD *)a2 - 1)) & 1) != 0)
  {
    v8 = a1;
    do
    {
      v9 = v8[2];
      v10 = v8[3];
      v8 += 2;
    }
    while (((*a3)(v6, v7, v9, v10) & 1) == 0);
  }
  else
  {
    v11 = a1 + 2;
    do
    {
      v8 = v11;
      if (v11 >= (_QWORD *)v4)
        break;
      v12 = (*a3)(v6, v7, *v11, v11[1]);
      v11 = v8 + 2;
    }
    while (!v12);
  }
  if (v8 < (_QWORD *)v4)
  {
    do
    {
      v13 = *((_QWORD *)v4 - 2);
      v14 = *((_QWORD *)v4-- - 1);
    }
    while (((*a3)(v6, v7, v13, v14) & 1) != 0);
  }
  while (v8 < (_QWORD *)v4)
  {
    v20 = *(_OWORD *)v8;
    *(_OWORD *)v8 = *v4;
    *v4 = v20;
    do
    {
      v15 = v8[2];
      v16 = v8[3];
      v8 += 2;
    }
    while (!(*a3)(v6, v7, v15, v16));
    do
    {
      v17 = *((_QWORD *)v4 - 2);
      v18 = *((_QWORD *)v4-- - 1);
    }
    while (((*a3)(v6, v7, v17, v18) & 1) != 0);
  }
  if (v8 - 2 != a1)
    *(_OWORD *)a1 = *((_OWORD *)v8 - 1);
  *(v8 - 2) = v6;
  *(v8 - 1) = v7;
  return v8;
}

uint64_t *std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,BOOL (*&)(ProbIndex,ProbIndex)>(uint64_t *a1, uint64_t *a2, uint64_t (**a3)(uint64_t, uint64_t, uint64_t, uint64_t))
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char v9;
  uint64_t *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *v15;
  uint64_t *v16;
  __int128 v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t *result;

  v6 = 0;
  v7 = *a1;
  v8 = a1[1];
  do
  {
    v9 = (*a3)(a1[v6 + 2], a1[v6 + 3], v7, v8);
    v6 += 2;
  }
  while ((v9 & 1) != 0);
  v10 = &a1[v6];
  if (v6 == 2)
  {
    do
    {
      if (v10 >= a2)
        break;
      v13 = *(a2 - 2);
      v14 = *(a2 - 1);
      a2 -= 2;
    }
    while (((*a3)(v13, v14, v7, v8) & 1) == 0);
  }
  else
  {
    do
    {
      v11 = *(a2 - 2);
      v12 = *(a2 - 1);
      a2 -= 2;
    }
    while (!(*a3)(v11, v12, v7, v8));
  }
  v15 = &a1[v6];
  if (v10 < a2)
  {
    v16 = a2;
    do
    {
      v17 = *(_OWORD *)v15;
      *(_OWORD *)v15 = *(_OWORD *)v16;
      *(_OWORD *)v16 = v17;
      do
      {
        v18 = v15[2];
        v19 = v15[3];
        v15 += 2;
      }
      while (((*a3)(v18, v19, v7, v8) & 1) != 0);
      do
      {
        v20 = *(v16 - 2);
        v21 = *(v16 - 1);
        v16 -= 2;
      }
      while (!(*a3)(v20, v21, v7, v8));
    }
    while (v15 < v16);
  }
  result = v15 - 2;
  if (v15 - 2 != a1)
    *(_OWORD *)a1 = *(_OWORD *)result;
  *(v15 - 2) = v7;
  *(v15 - 1) = v8;
  return result;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(char *a1, char *a2, uint64_t (**a3)(uint64_t, uint64_t, _QWORD, _QWORD))
{
  uint64_t v6;
  _BOOL8 result;
  char *v8;
  __int128 v9;
  char *v10;
  char *v11;
  uint64_t v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  char *v17;
  char *v18;

  v6 = (a2 - a1) >> 4;
  result = 1;
  switch(v6)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v8 = a2 - 16;
      if ((*a3)(*((_QWORD *)a2 - 2), *((_QWORD *)a2 - 1), *(_QWORD *)a1, *((_QWORD *)a1 + 1)))
      {
        v9 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *(_OWORD *)v8;
        *(_OWORD *)v8 = v9;
      }
      return 1;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a2 - 2, a3);
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a2 - 2, a3);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, (_QWORD *)a1 + 6, (_QWORD *)a2 - 2, a3);
      return 1;
    default:
      v10 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, (_QWORD *)a1 + 2, (_QWORD *)a1 + 4, a3);
      v11 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v12 = 0;
      v13 = 0;
      break;
  }
  while (1)
  {
    if ((*a3)(*(_QWORD *)v11, *((_QWORD *)v11 + 1), *(_QWORD *)v10, *((_QWORD *)v10 + 1)))
    {
      v14 = *(_QWORD *)v11;
      v15 = *((_QWORD *)v11 + 1);
      v16 = v12;
      while (1)
      {
        v17 = &a1[v16];
        *(_OWORD *)&a1[v16 + 48] = *(_OWORD *)&a1[v16 + 32];
        if (v16 == -32)
          break;
        v16 -= 16;
        if (((*a3)(v14, v15, *((_QWORD *)v17 + 2), *((_QWORD *)v17 + 3)) & 1) == 0)
        {
          v18 = &a1[v16 + 48];
          goto LABEL_12;
        }
      }
      v18 = a1;
LABEL_12:
      *(_QWORD *)v18 = v14;
      *((_QWORD *)v18 + 1) = v15;
      if (++v13 == 8)
        return v11 + 16 == a2;
    }
    v10 = v11;
    v12 += 16;
    v11 += 16;
    if (v11 == a2)
      return 1;
  }
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, uint64_t (**a5)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  __n128 result;
  __int128 v11;
  __int128 v12;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, a2, a3, a5);
  if ((*a5)(*a4, a4[1], *a3, a3[1]))
  {
    v11 = *(_OWORD *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(_OWORD *)a4 = v11;
    if ((*a5)(*a3, a3[1], *a2, a2[1]))
    {
      v12 = *(_OWORD *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(_OWORD *)a3 = v12;
      if ((*a5)(*a2, a2[1], *a1, a1[1]))
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(_QWORD *a1, _QWORD *a2, _QWORD *a3, _QWORD *a4, _QWORD *a5, uint64_t (**a6)(_QWORD, _QWORD, _QWORD, _QWORD))
{
  __n128 v12;
  __n128 result;
  __int128 v14;
  __int128 v15;
  __int128 v16;

  v12 = std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, a2, a3, a4, a6);
  if (((unsigned int (*)(_QWORD, _QWORD, _QWORD, _QWORD, __n128))*a6)(*a5, a5[1], *a4, a4[1], v12))
  {
    v14 = *(_OWORD *)a4;
    *(_OWORD *)a4 = *(_OWORD *)a5;
    *(_OWORD *)a5 = v14;
    if ((*a6)(*a4, a4[1], *a3, a3[1]))
    {
      v15 = *(_OWORD *)a3;
      *(_OWORD *)a3 = *(_OWORD *)a4;
      *(_OWORD *)a4 = v15;
      if ((*a6)(*a3, a3[1], *a2, a2[1]))
      {
        v16 = *(_OWORD *)a2;
        *(_OWORD *)a2 = *(_OWORD *)a3;
        *(_OWORD *)a3 = v16;
        if ((*a6)(*a2, a2[1], *a1, a1[1]))
        {
          result = *(__n128 *)a1;
          *(_OWORD *)a1 = *(_OWORD *)a2;
          *(__n128 *)a2 = result;
        }
      }
    }
  }
  return result;
}

char *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,ProbIndex*>(char *a1, char *a2, char *a3, uint64_t (**a4)(_QWORD, _QWORD, uint64_t, uint64_t))
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  __int128 v15;
  uint64_t v16;
  char *v17;
  char *v18;
  __int128 v21;

  if (a1 != a2)
  {
    v8 = a2 - a1;
    v9 = (a2 - a1) >> 4;
    if (a2 - a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = &a1[16 * v10];
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD, _QWORD, _QWORD))a4, v9, v12);
        v12 -= 16;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if ((*a4)(*(_QWORD *)v14, *((_QWORD *)v14 + 1), *(_QWORD *)a1, *((_QWORD *)a1 + 1)))
        {
          v15 = *(_OWORD *)v14;
          *(_OWORD *)v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((uint64_t)a1, (unsigned int (**)(_QWORD, _QWORD, _QWORD, _QWORD))a4, v9, a1);
        }
        v14 += 16;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      v16 = (unint64_t)v8 >> 4;
      v17 = a2 - 16;
      do
      {
        v21 = *(_OWORD *)a1;
        v18 = (char *)std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(a1, (unsigned int (**)(_QWORD, _QWORD, _QWORD, _QWORD))a4, v16);
        if (v17 == v18)
        {
          *(_OWORD *)v18 = v21;
        }
        else
        {
          *(_OWORD *)v18 = *(_OWORD *)v17;
          *(_OWORD *)v17 = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>((uint64_t)a1, (uint64_t)(v18 + 16), a4, (v18 + 16 - a1) >> 4);
        }
        v17 -= 16;
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(uint64_t result, unsigned int (**a2)(_QWORD, _QWORD, _QWORD, _QWORD), uint64_t a3, _QWORD *a4)
{
  unint64_t v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v9;
  uint64_t v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  int64_t v17;

  v4 = a3 - 2;
  if (a3 >= 2)
  {
    v5 = a4;
    v6 = result;
    v17 = v4 >> 1;
    if ((uint64_t)(v4 >> 1) >= ((uint64_t)a4 - result) >> 4)
    {
      v9 = ((uint64_t)a4 - result) >> 3;
      v10 = v9 + 1;
      v11 = (_QWORD *)(result + 16 * (v9 + 1));
      v12 = v9 + 2;
      if (v9 + 2 < a3 && (*a2)(*v11, v11[1], v11[2], v11[3]))
      {
        v11 += 2;
        v10 = v12;
      }
      result = ((uint64_t (*)(_QWORD, _QWORD, _QWORD, _QWORD))*a2)(*v11, v11[1], *v5, v5[1]);
      if ((result & 1) == 0)
      {
        v13 = *v5;
        v14 = v5[1];
        do
        {
          v15 = v11;
          *(_OWORD *)v5 = *(_OWORD *)v11;
          if (v17 < v10)
            break;
          v16 = (2 * v10) | 1;
          v11 = (_QWORD *)(v6 + 16 * v16);
          if (2 * v10 + 2 < a3)
          {
            if ((*a2)(*v11, v11[1], v11[2], v11[3]))
            {
              v11 += 2;
              v16 = 2 * v10 + 2;
            }
          }
          result = ((uint64_t (*)(_QWORD, _QWORD, uint64_t, uint64_t))*a2)(*v11, v11[1], v13, v14);
          v5 = v15;
          v10 = v16;
        }
        while (!(_DWORD)result);
        *v15 = v13;
        v15[1] = v14;
      }
    }
  }
  return result;
}

_OWORD *std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(_OWORD *a1, unsigned int (**a2)(_QWORD, _QWORD, _QWORD, _QWORD), uint64_t a3)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _OWORD *v9;
  uint64_t v10;
  uint64_t v11;

  v6 = 0;
  v7 = a3 - 2;
  if (a3 < 2)
    v7 = a3 - 1;
  v8 = v7 >> 1;
  do
  {
    v9 = &a1[v6 + 1];
    v10 = (2 * v6) | 1;
    v11 = 2 * v6 + 2;
    if (v11 < a3
      && (*a2)(*(_QWORD *)&a1[v6 + 1], *((_QWORD *)&a1[v6 + 1] + 1), *(_QWORD *)&a1[v6 + 2], *((_QWORD *)&a1[v6 + 2] + 1)))
    {
      ++v9;
      v10 = v11;
    }
    *a1 = *v9;
    a1 = v9;
    v6 = v10;
  }
  while (v10 <= v8);
  return v9;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*>(uint64_t result, uint64_t a2, uint64_t (**a3)(_QWORD, _QWORD, uint64_t, uint64_t), uint64_t a4)
{
  unint64_t v4;
  uint64_t v7;
  unint64_t v8;
  _QWORD *v9;
  _OWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v7 = result;
    v8 = v4 >> 1;
    v9 = (_QWORD *)(result + 16 * (v4 >> 1));
    v10 = (_OWORD *)(a2 - 16);
    result = (*a3)(*v9, v9[1], *(_QWORD *)(a2 - 16), *(_QWORD *)(a2 - 8));
    if ((_DWORD)result)
    {
      v11 = *(_QWORD *)(a2 - 16);
      v12 = *(_QWORD *)(a2 - 8);
      do
      {
        v13 = v9;
        *v10 = *(_OWORD *)v9;
        if (!v8)
          break;
        v8 = (v8 - 1) >> 1;
        v9 = (_QWORD *)(v7 + 16 * v8);
        result = (*a3)(*v9, v9[1], v11, v12);
        v10 = v13;
      }
      while ((result & 1) != 0);
      *v13 = v11;
      v13[1] = v12;
    }
  }
  return result;
}

void CPGMMClassfier::CPGMMClassfier(CPGMMClassfier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;
  int v7;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v6 = &off_24C255300;
  *(_BYTE *)(v6 + 184) = 0;
  v7 = *((_DWORD *)a2->var0 + 33);
  *(_DWORD *)(v6 + 96) = *((_DWORD *)a2->var0 + 31) - 1;
  *(_DWORD *)(v6 + 100) = v7;
  *(_DWORD *)(v6 + 104) = 2;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPGMMClassfier::initializeGMMMemory(this);
}

void sub_209CEE9C0(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void *CPGMMClassfier::initializeGMMMemory(CPGMMClassfier *this)
{
  void *result;

  *((_QWORD *)this + 15) = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 16) = malloc_type_calloc((*((_DWORD *)this + 24) * *((_DWORD *)this + 24)), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 17) = malloc_type_calloc(*((int *)this + 25) * (uint64_t)*((int *)this + 24) * *((int *)this + 26), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 18) = malloc_type_calloc(*((int *)this + 24)* (uint64_t)*((int *)this + 24)* *((int *)this + 25)* *((int *)this + 26), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 19) = malloc_type_calloc(*((int *)this + 26) * (uint64_t)*((int *)this + 25), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 20) = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 21) = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
  result = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 22) = result;
  return result;
}

void CPGMMClassfier::CPGMMClassfier(CPGMMClassfier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  uint64_t v5;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *(_QWORD *)v5 = &off_24C255300;
  *(_BYTE *)(v5 + 184) = 0;
  (*((void (**)(CPMLSerialization *, uint64_t, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, v5 + 96, "featureVectorSpace", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, (char *)this + 100, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 8))(a2, (char *)this + 104, "numberClusters", 1, 0);
  CPGMMClassfier::initializeGMMMemory(this);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 15), "preMean", *((int *)this + 24), 0);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 16), "preWhiten", (*((_DWORD *)this + 24) * *((_DWORD *)this + 24)), 0);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 17), "means", *((int *)this + 25) * (uint64_t)*((int *)this + 24) * *((int *)this + 26), 0);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 18), "inverseCovariances", *((int *)this + 24) * (uint64_t)*((int *)this + 24) * *((int *)this + 25) * *((int *)this + 26), 0);
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, uint64_t, _QWORD))a2->var0 + 12))(a2, *((_QWORD *)this + 19), "weights", *((int *)this + 26) * (uint64_t)*((int *)this + 25), 0);
}

void sub_209CEECA8(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPGMMClassfier::CPGMMClassfier(CPGMMClassfier *this, int a2, int a3, int *a4, double *a5, double *a6, double *a7, double *a8, double *a9, CPMLTunableData *a10)
{
  uint64_t v18;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, 0, a10);
  *(_QWORD *)v18 = &off_24C255300;
  *(_DWORD *)(v18 + 96) = a2;
  *(_DWORD *)(v18 + 100) = a3;
  *(_DWORD *)(v18 + 104) = -1;
  *(_QWORD *)(v18 + 112) = a4;
  *(_QWORD *)(v18 + 120) = a5;
  *(_QWORD *)(v18 + 128) = a6;
  *(_QWORD *)(v18 + 136) = a7;
  *(_QWORD *)(v18 + 144) = a8;
  *(_QWORD *)(v18 + 152) = a9;
  *((_BYTE *)this + 184) = 1;
  *((_QWORD *)this + 20) = malloc_type_calloc(a2, 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 21) = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 22) = malloc_type_calloc(*((int *)this + 24), 8uLL, 0x100004000313F17uLL);
}

{
  CPGMMClassfier::CPGMMClassfier(this, a2, a3, a4, a5, a6, a7, a8, a9, a10);
}

void sub_209CEEDB8(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPGMMClassfier::~CPGMMClassfier(void **this)
{
  *this = &off_24C255300;
  if (!*((_BYTE *)this + 184))
  {
    free(this[15]);
    free(this[16]);
    free(this[17]);
    free(this[18]);
    free(this[19]);
  }
  free(this[20]);
  free(this[21]);
  free(this[22]);
  CPModelClose(this);
}

{
  CPGMMClassfier::~CPGMMClassfier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPGMMClassfier::serialize(CPGMMClassfier *this)
{
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), (char *)this + 100, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), (char *)this + 104, "numberClusters", 1, 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 15), "preMean", *((int *)this + 24), 0);
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 16), "preWhiten", (*((_DWORD *)this + 24) * *((_DWORD *)this + 24)), 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 17), "means", *((int *)this + 25) * (uint64_t)*((int *)this + 24) * *((int *)this + 26), 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 18), "inverseCovariances", *((int *)this + 24) * (uint64_t)*((int *)this + 24) * *((int *)this + 25) * *((int *)this + 26), 0);
  (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *((_QWORD *)this + 19), "weights", *((int *)this + 26) * (uint64_t)*((int *)this + 25), 0);
  return 0;
}

uint64_t CPGMMClassfier::train(void **this)
{
  void **v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  int *v5;
  uint64_t v6;
  CPMLFeatureVector *v7;
  int v8;
  double **v9;
  CPMLLog *v10;
  int v11;
  double *v12;
  uint64_t v13;
  uint64_t v14;
  double *v15;
  double *v16;
  uint64_t v17;
  double *v18;
  double v19;
  uint64_t v20;
  int v21;
  size_t v22;
  pthread_mutex_t *v23;
  __CLPK_doublereal *v24;
  __CLPK_doublereal *v25;
  uint64_t v26;
  int v27;
  uint64_t v28;
  double v29;
  double *v30;
  uint64_t v31;
  uint64_t v32;
  double *v33;
  double *v34;
  uint64_t v35;
  double *v36;
  double *v37;
  double v38;
  __CLPK_doublereal *v39;
  int *v40;
  uint64_t v41;
  uint64_t v42;
  double *v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  double v47;
  double *v48;
  uint64_t v49;
  double v50;
  uint64_t v51;
  CPMLFeatureVector *v52;
  uint64_t RealVector;
  int YHat;
  uint64_t v55;
  int v56;
  double *v57;
  uint64_t v58;
  unint64_t v59;
  double *v60;
  double *v61;
  double v62;
  double v63;
  double v64;
  uint64_t v65;
  int v66;
  char *v67;
  char *v68;
  double *v69;
  double v70;
  double *v71;
  uint64_t v72;
  double v73;
  double v74;
  double v75;
  uint64_t v76;
  int v77;
  uint64_t v78;
  double v79;
  uint64_t v80;
  uint64_t v81;
  char *v82;
  __CLPK_doublereal *v83;
  char *v84;
  uint64_t v85;
  double *v86;
  uint64_t v87;
  uint64_t v88;
  CPMLLog *v89;
  uint64_t v90;
  uint64_t v91;
  int v92;
  CPMLLog *v93;
  _QWORD *v94;
  uint64_t v95;
  uint64_t v96;
  int v97;
  double *v98;
  double *v99;
  unsigned int v100;
  char *v101;
  double *v102;
  uint64_t v103;
  double v104;
  pthread_mutex_t *v105;
  uint64_t i;
  uint64_t v107;
  char *v108;
  uint64_t v109;
  char *v110;
  int v111;
  char *v112;
  char *v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  char *v117;
  int v118;
  double v119;
  char *v120;
  uint64_t v121;
  pthread_mutex_t *v122;
  uint64_t v123;
  double *v124;
  int v125;
  char *v126;
  double v127;
  double *v128;
  uint64_t v129;
  double v130;
  int v131;
  int v132;
  int v133;
  int v134;
  char *v135;
  int v136;
  int v137;
  double *v138;
  char *v139;
  double v140;
  uint64_t v141;
  double v142;
  uint64_t v143;
  double v144;
  char *v145;
  double v146;
  char *v147;
  double *v148;
  uint64_t v149;
  double v150;
  double v151;
  double v152;
  double v153;
  char *v154;
  char *v155;
  double *v156;
  uint64_t v157;
  double v158;
  uint64_t v159;
  int v160;
  int v161;
  int v162;
  double *v163;
  char *v164;
  uint64_t v165;
  double v166;
  uint64_t v167;
  char *v168;
  uint64_t v169;
  char *v170;
  double v171;
  uint64_t v172;
  uint64_t v173;
  double *v174;
  int v175;
  char *v176;
  uint64_t v177;
  double *v178;
  uint64_t v179;
  int v180;
  uint64_t v181;
  int v182;
  uint64_t v183;
  __CLPK_integer v184;
  int v185;
  uint64_t v186;
  uint64_t v187;
  __CLPK_doublereal *v188;
  int v189;
  int v190;
  uint64_t v191;
  int v192;
  uint64_t v193;
  int v194;
  double v195;
  int v196;
  double v197;
  uint64_t v198;
  CPMLLog *v199;
  pthread_mutex_t *v200;
  int v201;
  int v202;
  uint64_t v203;
  pthread_mutex_t *v205;
  pthread_mutex_t *v206;
  pthread_mutex_t *CPMLLog;
  __CLPK_doublereal *v208;
  int *v209;
  size_t v210;
  void **v211;
  int *v212;
  int v213;
  char *v214;
  size_t v215;
  uint64_t v216;
  double *v217;
  char *v218;
  uint64_t v219;
  int v220;
  size_t v221;
  char *v222;
  char *v223;
  double *v224;
  uint64_t v225;
  CPMLLog *v226;
  void *v227;
  __CLPK_doublereal *v228;
  unsigned int v229;
  uint64_t v230;
  char *v231;
  void *v232;
  __CLPK_integer __lda;
  __CLPK_integer __info;
  __CLPK_integer __lwork[3];

  v1 = this;
  bzero(this[15], 8 * *((int *)this + 24));
  bzero(v1[16], 8 * *((int *)v1 + 24) * (uint64_t)*((int *)v1 + 24));
  v2 = *((unsigned int *)v1 + 24);
  v3 = (int)v2;
  v4 = *((unsigned int *)v1 + 25);
  v5 = (int *)malloc_type_calloc(*((int *)v1 + 25), 4uLL, 0x100004052888210uLL);
  bzero(v5, 4 * *((int *)v1 + 25));
  v6 = (*(uint64_t (**)(void *))(*(_QWORD *)v1[10] + 32))(v1[10]);
  if (!v6)
  {
    v8 = 0;
LABEL_14:
    if ((int)v4 >= 1)
    {
      v20 = 0;
      while (v5[v20])
      {
        if (v4 == ++v20)
          goto LABEL_18;
      }
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(0);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "train", "You must specify an exmaple for all classes: %d not found.\n", v20);
      free(v5);
      return 3;
    }
LABEL_18:
    v21 = 3 * v2 - 1;
    v229 = v2 * v2;
    if ((int)v2 * (int)v2 <= v21)
      v22 = v21;
    else
      v22 = (v2 * v2);
    if (!v8)
    {
      v23 = (pthread_mutex_t *)CPMLLog::getCPMLLog(0);
      CPMLLog::log(v23, CPML_LOG_ERR, "train", "dataCount 0 \n");
      v8 = 1;
    }
    v24 = (__CLPK_doublereal *)malloc_type_calloc(v22, 8uLL, 0x100004000313F17uLL);
    v25 = (__CLPK_doublereal *)malloc_type_calloc((int)v2, 8uLL, 0x100004000313F17uLL);
    v232 = malloc_type_malloc(4 * ((int)v2 + 1), 0x100004052888210uLL);
    v218 = (char *)malloc_type_calloc(*((int *)v1 + 24) * (uint64_t)v8, 8uLL, 0x100004000313F17uLL);
    v217 = (double *)malloc_type_calloc(v8, 8uLL, 0x100004000313F17uLL);
    v212 = (int *)malloc_type_calloc(*((int *)v1 + 25), 4uLL, 0x100004052888210uLL);
    *v212 = 0;
    if (*((int *)v1 + 25) > 1)
    {
      v26 = 0;
      v27 = 0;
      do
      {
        v27 += v5[v26];
        v212[v26 + 1] = v27;
        v28 = v26 + 2;
        ++v26;
      }
      while (v28 < *((int *)v1 + 25));
    }
    (*(void (**)(void *))(*(_QWORD *)v1[10] + 40))(v1[10]);
    v225 = 8 * (int)v2;
    if ((int)v2 >= 1)
    {
      v29 = (double)v8;
      v30 = (double *)v1[15];
      v31 = v2;
      do
      {
        *v30 = *v30 / v29;
        ++v30;
        --v31;
      }
      while (v31);
      v32 = 0;
      v34 = (double *)v1[15];
      v33 = (double *)v1[16];
      do
      {
        v35 = v2;
        v36 = v34;
        v37 = v33;
        do
        {
          v38 = *v36++;
          *v37 = (*v37 + -(v34[v32] * v38) * v29) / v29;
          ++v37;
          --v35;
        }
        while (v35);
        ++v32;
        v33 = (double *)((char *)v33 + v225);
      }
      while (v32 != v2);
    }
    v39 = (__CLPK_doublereal *)v1[16];
    __info = 0;
    __lwork[0] = 3 * v2 - 1;
    __lda = v2;
    dsyev_("V", "U", &__lda, v39, &__lda, v25, v24, __lwork, &__info);
    memcpy(v24, v39, 8 * v229);
    bzero(v39, 8 * v229);
    v40 = v212;
    v41 = 8 * (int)v2;
    if ((int)v2 >= 1)
    {
      v42 = 0;
      v43 = v24;
      do
      {
        v44 = v25[v42];
        if (v44 > 0.0)
        {
          v45 = 0;
          LODWORD(v46) = 0;
          v47 = 1.0 / sqrt(v44);
          do
          {
            v46 = (int)v46;
            v48 = v43;
            v49 = v2;
            do
            {
              v50 = *v48++;
              v39[v46] = v39[v46] + v24[v45 + v42 * v2] * v50 * v47;
              ++v46;
              --v49;
            }
            while (v49);
            ++v45;
          }
          while (v45 != v2);
        }
        ++v42;
        v43 += v2;
      }
      while (v42 != v2);
    }
    v51 = (*(uint64_t (**)(void *))(*(_QWORD *)v1[10] + 32))(v1[10]);
    if (v51)
    {
      v52 = (CPMLFeatureVector *)v51;
      do
      {
        RealVector = CPMLFeatureVector::getRealVector(v52);
        YHat = (int)CPMLFeatureVector::getYHat(v52);
        v55 = v212[YHat];
        v56 = *((_DWORD *)v1 + 24);
        v57 = *(double **)RealVector;
        v58 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
        if (v58)
        {
          v59 = v58 >> 3;
          v60 = (double *)v1[15];
          if (v59 <= 1)
            v59 = 1;
          v61 = v25;
          do
          {
            v62 = *v57++;
            v63 = v62;
            v64 = *v60++;
            *v61++ = v63 - v64;
            --v59;
          }
          while (v59);
        }
        v41 = 8 * (int)v2;
        if ((int)v2 >= 1)
        {
          v65 = 0;
          v66 = 0;
          v67 = &v218[8 * v56 * (int)v55];
          v68 = (char *)v1[16];
          do
          {
            v69 = (double *)&v68[8 * v66];
            v70 = 0.0;
            v71 = v25;
            v72 = v2;
            do
            {
              v73 = *v69++;
              v74 = v73;
              v75 = *v71++;
              v70 = v70 + v74 * v75;
              --v72;
            }
            while (v72);
            *(double *)&v67[8 * v65] = v70;
            v66 += v2;
            ++v65;
          }
          while (v65 != v2);
        }
        v217[v55] = (double)YHat;
        v212[YHat] = v55 + 1;
        v52 = (CPMLFeatureVector *)(*(uint64_t (**)(void *))(*(_QWORD *)v1[10] + 32))(v1[10]);
      }
      while (v52);
    }
    v208 = v25;
    *v212 = 0;
    if (*((int *)v1 + 25) > 1)
    {
      v76 = 0;
      v77 = 0;
      do
      {
        v77 += v5[v76];
        v212[v76 + 1] = v77;
        v78 = v76 + 2;
        ++v76;
      }
      while (v78 < *((int *)v1 + 25));
    }
    v221 = *((int *)v1 + 26);
    v227 = malloc_type_calloc(v221, 8uLL, 0x100004000313F17uLL);
    if (*((int *)v1 + 25) < 1)
    {
LABEL_191:
      free(v227);
      free(v24);
      free(v208);
      free(v218);
      free(v232);
      free(v217);
      free(v40);
      free(v5);
      return 0;
    }
    v215 = v41 * v221;
    v210 = v41 * v221 * (int)v2;
    v79 = pow(6.28318531, (double)(int)v2);
    v220 = 0;
    v80 = 0;
    v81 = 0;
    v209 = v5;
    v211 = v1;
    while (1)
    {
      v219 = v81;
      v222 = (char *)v1[17];
      v82 = &v222[8 * v81 * v3 * v221];
      v214 = (char *)v1[18];
      v83 = (__CLPK_doublereal *)&v214[8 * (int)v221 * (int)v2 * (int)v81 * (int)v3];
      v84 = (char *)v1[19] + 8 * v81 * v221;
      v223 = v82;
      bzero(v82, v215);
      v228 = v83;
      bzero(v83, v210);
      bzero(v84, 8 * v221);
      v85 = v40[v219];
      v216 = (int)v85 * (int)v2;
      v86 = &v217[v85];
      v87 = v5[v219];
      v88 = v5[v219];
      v224 = v86;
      v213 = v5[v219];
      v230 = v88;
      if ((int)v87 <= (int)v221)
      {
        if ((int)v88 >= 1)
        {
          for (i = 0; i != v88; ++i)
            v86[i] = (double)(int)i;
        }
        v107 = (int)v2;
        v108 = v222;
        if ((int)v221 >= 1)
        {
          v109 = 0;
          v110 = &v222[v80];
          do
          {
            *((_QWORD *)v227 + v109) = 0;
            if ((int)v2 >= 1)
            {
              if (v109 >= v87)
                v111 = v87 - 1;
              else
                v111 = v109;
              v112 = &v218[8 * v216 + 8 * v111 * (int)v2];
              v113 = v110;
              v114 = v2;
              do
              {
                v115 = *(_QWORD *)v112;
                v112 += 8;
                *(_QWORD *)v113 = v115;
                v113 += 8;
                --v114;
              }
              while (v114);
            }
            ++v109;
            v110 += v41;
          }
          while (v109 != v221);
        }
      }
      else
      {
        v89 = (CPMLLog *)malloc_type_malloc(4 * v221, 0x100004052888210uLL);
        v91 = v230;
        v90 = v221;
        v226 = v89;
        if ((int)v221 >= 1)
        {
          v92 = 0;
          v93 = v89;
          v94 = v227;
          v95 = v221;
          do
          {
            *(_DWORD *)v93 = 0;
            *v94 = 0;
            if ((int)v2 >= 1)
            {
              bzero(&v223[8 * v92], 8 * v2);
              v89 = v226;
              v91 = v230;
              v90 = v221;
            }
            v92 += v2;
            ++v94;
            v93 = (CPMLLog *)((char *)v93 + 4);
            --v95;
          }
          while (v95);
        }
        if ((int)v91 < 1)
        {
          v97 = 0;
          v99 = v224;
          v41 = 8 * (int)v2;
        }
        else
        {
          v96 = 0;
          v97 = 0;
          v98 = (double *)&v218[8 * v216];
          v99 = v224;
          do
          {
            v100 = (int)v96 % (int)v221;
            v99[v96] = (double)((int)v96 % (int)v221);
            if ((v90 & 0x80000000) != 0)
            {
              v105 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v89);
              CPMLLog::log(v105, CPML_LOG_ERR, "kmeans", "Data point assigned to nonexistant cluster: %d.\n", (int)v96 % (int)v221);
              v89 = v226;
              v91 = v230;
              v90 = v221;
              v99 = v224;
              v97 = 1;
            }
            else
            {
              ++*((_DWORD *)v89 + v100);
              if ((int)v2 >= 1)
              {
                v101 = &v222[8 * (int)(v100 * v2)];
                v102 = v98;
                v103 = v2;
                do
                {
                  v104 = *v102++;
                  *(double *)&v101[v80] = v104 + *(double *)&v101[v80];
                  v101 += 8;
                  --v103;
                }
                while (v103);
              }
            }
            v41 = 8 * (int)v2;
            ++v96;
            v98 = (double *)((char *)v98 + v225);
          }
          while (v96 != v91);
        }
        if ((int)v90 < 1)
        {
          v5 = v209;
        }
        else
        {
          v116 = 0;
          v117 = v222;
          v5 = v209;
          do
          {
            v118 = *((_DWORD *)v89 + v116);
            if (v118)
            {
              if ((int)v2 >= 1)
              {
                v119 = 1.0 / (double)v118;
                v120 = v117;
                v121 = v2;
                do
                {
                  *(double *)&v120[v80] = v119 * *(double *)&v120[v80];
                  v120 += 8;
                  --v121;
                }
                while (v121);
              }
            }
            else
            {
              v122 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v89);
              CPMLLog::log(v122, CPML_LOG_ERR, "kmeans", "Initialized cluster is empty.");
              v89 = v226;
              v91 = v230;
              v90 = v221;
              v99 = v224;
              v97 = 1;
            }
            ++v116;
            v117 += v41;
          }
          while (v116 != v90);
        }
        v107 = (int)v2;
        v108 = v222;
        if (!v97 && (int)v91 >= 1)
        {
          v123 = 0;
          v124 = (double *)&v218[8 * v216];
          do
          {
            v125 = (int)v99[v123];
            if ((int)v2 < 1)
            {
              v127 = 0.0;
            }
            else
            {
              v126 = &v222[8 * (int)v2 * v125];
              v127 = 0.0;
              v128 = v124;
              v129 = v2;
              do
              {
                v130 = *v128++;
                v127 = v127 + (*(double *)&v126[v80] - v130) * (*(double *)&v126[v80] - v130);
                v126 += 8;
                --v129;
              }
              while (v129);
            }
            *((double *)v227 + v125) = v127 + *((double *)v227 + v125);
            ++v123;
            v124 = (double *)((char *)v124 + v41);
          }
          while (v123 != v91);
          v131 = 0;
          v132 = 0;
          v133 = 0;
          v134 = 0;
          v135 = &v218[8 * v216];
          do
          {
            v136 = (int)v99[v132];
            v137 = *((_DWORD *)v89 + v136);
            if (v137 >= 2)
            {
              if ((int)v2 < 1)
              {
                v140 = 0.0;
              }
              else
              {
                v138 = (double *)&v135[8 * v132 * (int)v2];
                v139 = &v222[8 * (int)v2 * v136];
                v140 = 0.0;
                v141 = v2;
                do
                {
                  v142 = *v138++;
                  v140 = v140 + (*(double *)&v139[v80] - v142) * (*(double *)&v139[v80] - v142);
                  v139 += 8;
                  --v141;
                }
                while (v141);
              }
              if ((int)v221 < 1)
              {
                v144 = 1.79769313e308;
              }
              else
              {
                v143 = 0;
                v144 = 1.79769313e308;
                v145 = v222;
                do
                {
                  if (v143 != (int)v99[v132])
                  {
                    v146 = 0.0;
                    if ((int)v2 >= 1)
                    {
                      v147 = v145;
                      v148 = (double *)&v135[8 * v132 * (int)v2];
                      v149 = v2;
                      do
                      {
                        v150 = *v148++;
                        v146 = v146 + (*(double *)&v147[v80] - v150) * (*(double *)&v147[v80] - v150);
                        v147 += 8;
                        --v149;
                      }
                      while (v149);
                    }
                    v151 = (double)*((int *)v89 + v143) / ((double)*((int *)v89 + v143) + 1.0) * v146;
                    if (v151 <= v144)
                    {
                      v134 = v143;
                      v133 = *((_DWORD *)v89 + v143);
                      v144 = v151;
                    }
                  }
                  ++v143;
                  v145 += v41;
                }
                while (v143 != v90);
              }
              v152 = (double)v137 + -1.0;
              v153 = (double)v137 / v152 * v140;
              if (v144 >= v153)
              {
                ++v131;
              }
              else
              {
                *((double *)v227 + v136) = *((double *)v227 + v136) - v153;
                *((double *)v227 + v134) = v144 + *((double *)v227 + v134);
                if ((int)v2 >= 1)
                {
                  v154 = &v222[8 * v134 * (int)v2];
                  v155 = &v222[8 * (int)v2 * v136];
                  v156 = (double *)&v135[8 * v132 * (int)v2];
                  v157 = v2;
                  do
                  {
                    v158 = *v156++;
                    *(double *)&v155[v80] = 1.0 / v152 * -(v158 - (double)v137 * *(double *)&v155[v80]);
                    *(double *)&v154[v80] = 1.0 / ((double)v133 + 1.0) * (v158 + (double)v133 * *(double *)&v154[v80]);
                    v154 += 8;
                    v155 += 8;
                    --v157;
                  }
                  while (v157);
                }
                v131 = 0;
                v99[v132] = (double)v134;
                *((_DWORD *)v89 + v136) = v137 - 1;
                ++*((_DWORD *)v89 + v134);
              }
            }
            if (v132 < (int)v91 - 1)
              ++v132;
            else
              v132 = 0;
          }
          while (v131 < (int)v91);
        }
        free(v89);
      }
      bzero(v223, v215);
      if ((int)v230 >= 1)
      {
        v159 = 0;
        v160 = 0;
        do
        {
          v161 = (int)v224[v159];
          *(double *)&v84[8 * v161] = *(double *)&v84[8 * v161] + 1.0;
          if ((int)v2 >= 1)
          {
            v162 = v2 * v161;
            v163 = (double *)&v218[8 * v216 + 8 * v160];
            v164 = &v108[8 * v162];
            v160 += v2;
            v165 = v2;
            do
            {
              v166 = *v163++;
              *(double *)&v164[v80] = v166 + *(double *)&v164[v80];
              v164 += 8;
              --v165;
            }
            while (v165);
          }
          ++v159;
        }
        while (v159 != v230);
      }
      if ((int)v221 >= 1)
      {
        v167 = 0;
        v168 = v108;
        do
        {
          v169 = v2;
          v170 = v168;
          if ((int)v2 >= 1)
          {
            do
            {
              v171 = *(double *)&v84[8 * v167];
              if (v171 > 0.0)
                *(double *)&v170[v80] = *(double *)&v170[v80] / v171;
              v170 += 8;
              --v169;
            }
            while (v169);
          }
          ++v167;
          v168 += v41;
        }
        while (v167 != v221);
      }
      v172 = 8 * v220;
      if ((int)v230 >= 1)
      {
        v173 = 0;
        v174 = (double *)&v218[8 * v216];
        do
        {
          v175 = (int)v224[v173];
          *(double *)&v84[8 * v175] = *(double *)&v84[8 * v175] + 1.0;
          if ((int)v2 >= 1)
          {
            v176 = &v108[8 * (int)v2 * v175];
            v177 = v2;
            v178 = v174;
            do
            {
              *v178 = *v178 - *(double *)&v176[v80];
              ++v178;
              v176 += 8;
              --v177;
            }
            while (v177);
            v179 = 0;
            v180 = 0;
            do
            {
              v181 = 0;
              v182 = v180;
              v183 = (uint64_t)&v214[8 * (int)v2 * v175 * (int)v2 + 8 * v180 + v172];
              do
              {
                *(double *)(v183 + 8 * v181) = *(double *)(v183 + 8 * v181)
                                             + *(double *)&v218[8 * v216 + 8 * v179 + 8 * v173 * v107] * v174[v181];
                ++v181;
              }
              while (v2 != v181);
              ++v179;
              v180 = v182 + v181;
            }
            while (v179 != v2);
          }
          ++v173;
          v174 = (double *)((char *)v174 + v41);
        }
        while (v173 != v213);
      }
      v184 = v2 * v2;
      if ((int)v221 >= 1)
        break;
LABEL_190:
      v81 = v219 + 1;
      v1 = v211;
      v40 = v212;
      v80 += 8 * (int)v2 * (uint64_t)(int)v221;
      v220 += v221 * v229;
      v3 = (int)v2;
      v41 = 8 * (int)v2;
      if (v219 + 1 >= *((int *)v211 + 25))
        goto LABEL_191;
    }
    v185 = 0;
    v186 = 0;
    v231 = &v214[v172];
    while (1)
    {
      v187 = 8 * v185;
      v188 = &v228[v184 * (int)v186];
      if (*(double *)&v84[8 * v186] <= (double)(int)v2)
      {
        if ((int)v2 >= 1)
        {
          v192 = 0;
          LODWORD(v193) = 0;
          do
          {
            v194 = 0;
            v193 = (int)v193;
            do
            {
              if (v192 == v194)
                v195 = 1.0;
              else
                v195 = 0.0;
              *(double *)&v231[8 * v185 + 8 * v193++] = v195;
              ++v194;
            }
            while ((_DWORD)v2 != v194);
            ++v192;
          }
          while (v192 != (_DWORD)v2);
          goto LABEL_178;
        }
      }
      else if ((int)v2 >= 1)
      {
        v189 = 0;
        v190 = 0;
        do
        {
          v191 = 0;
          do
          {
            *(double *)&v231[8 * v189 + 8 * v191 + v187] = *(double *)&v231[8 * v189 + 8 * v191 + v187]
                                                         / *(double *)&v84[8 * v186];
            ++v191;
          }
          while ((_DWORD)v2 != (_DWORD)v191);
          ++v190;
          v189 += v2;
        }
        while (v190 != (_DWORD)v2);
LABEL_178:
        __info = v184;
        __lwork[0] = 0;
        __lda = v2;
        dgetrf_(&__lda, &__lda, v188, &__lda, (__CLPK_integer *)v232, __lwork);
        v196 = 0;
        v197 = 1.0;
        v198 = v2;
        do
        {
          v197 = v197 * v188[v196];
          v196 += v2 + 1;
          --v198;
        }
        while (v198);
        goto LABEL_182;
      }
      __info = v184;
      __lwork[0] = 0;
      __lda = v2;
      dgetrf_(&__lda, &__lda, &v228[v184 * (int)v186], &__lda, (__CLPK_integer *)v232, __lwork);
      v197 = 1.0;
LABEL_182:
      v199 = (CPMLLog *)dgetri_(&__lda, v188, &__lda, (__CLPK_integer *)v232, v24, &__info, __lwork);
      if (v197 == 0.0)
      {
        v200 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v199);
        CPMLLog::log(v200, CPML_LOG_ERR, "train", "Covariance matrix has determinant zero.");
      }
      *(double *)&v84[8 * v186] = *(double *)&v84[8 * v186] / (double)v5[v186] / sqrt(v79 * fabs(v197));
      v184 = v2 * v2;
      if ((int)v2 >= 1)
      {
        v201 = 0;
        v202 = 0;
        do
        {
          v203 = 0;
          do
          {
            *(double *)&v231[8 * v201 + 8 * v203 + v187] = *(double *)&v231[8 * v201 + 8 * v203 + v187] * 0.5;
            ++v203;
          }
          while ((_DWORD)v2 != (_DWORD)v203);
          ++v202;
          v201 += v2;
        }
        while (v202 != (_DWORD)v2);
      }
      ++v186;
      v185 += v229;
      if (v186 == v221)
        goto LABEL_190;
    }
  }
  v7 = (CPMLFeatureVector *)v6;
  v8 = 0;
  while (1)
  {
    v9 = (double **)CPMLFeatureVector::getRealVector(v7);
    v11 = (int)CPMLFeatureVector::getYHat(v7);
    if (v11 < 0 || (int)v4 <= v11)
    {
      v205 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
      CPMLLog::log(v205, CPML_LOG_ERR, "train", "ERROR: Result cardinality does not match the response class number: !(0 <= %d < %d)", v11, v4);
      free(v5);
      return 1;
    }
    v12 = *v9;
    if ((int)v2 != v9[1] - *v9)
      break;
    if ((int)v2 >= 1)
    {
      v13 = 0;
      LODWORD(v14) = 0;
      v15 = (double *)v1[15];
      v16 = (double *)v1[16];
      do
      {
        v15[v13] = v12[v13] + v15[v13];
        v14 = (int)v14;
        v17 = v2;
        v18 = v12;
        do
        {
          v19 = *v18++;
          v16[v14] = v16[v14] + v12[v13] * v19;
          ++v14;
          --v17;
        }
        while (v17);
        ++v13;
      }
      while (v13 != v2);
    }
    ++v5[v11];
    ++v8;
    v7 = (CPMLFeatureVector *)(*(uint64_t (**)(void *))(*(_QWORD *)v1[10] + 32))(v1[10]);
    if (!v7)
      goto LABEL_14;
  }
  v206 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
  CPMLLog::log(v206, CPML_LOG_ERR, "train", "ERROR: Model dimension and feature dimension mismatch: %d != %d\n", (unint64_t)((char *)v9[1] - (char *)*v9) >> 3, v2);
  free(v5);
  return 2;
}

uint64_t CPGMMClassfier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  CPMLFeatureVector *v2;
  _QWORD *v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  double *v9;
  _QWORD *IntVector;
  CPMLLog *RealVector;
  pthread_mutex_t *CPMLLog;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  uint64_t v19;
  double *v20;
  uint64_t v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  double *v25;
  double v26;
  double *v27;
  uint64_t v28;
  double v29;
  double v30;
  double v31;
  uint64_t v32;
  double v33;
  int v34;
  int v35;
  double *v36;
  int v37;
  int v38;
  double *v39;
  double v40;
  double v41;
  uint64_t i;
  uint64_t v43;
  int v44;
  uint64_t v45;
  double v46;
  double *v47;
  uint64_t v48;
  double v49;
  uint64_t v50;
  double *v51;
  double *v52;
  double v53;
  double v54;
  double v55;
  double v56;
  double v59;
  CPMLFeatureVector *v60;
  uint64_t v61;
  _QWORD *v62;
  uint64_t v63;
  int v64;
  uint64_t v65;
  double *v66;
  int v67;

  v2 = this;
  v3 = (_QWORD *)a1;
  v4 = *(unsigned int *)(a1 + 96);
  v5 = *(unsigned int *)(a1 + 100);
  v6 = *(_DWORD *)(a1 + 104);
  v7 = *(_QWORD *)(a1 + 136);
  v8 = *(_QWORD *)(a1 + 144);
  v9 = *(double **)(a1 + 152);
  IntVector = (_QWORD *)CPMLFeatureVector::getIntVector(this);
  RealVector = (CPMLLog *)CPMLFeatureVector::getRealVector(v2);
  if (IntVector[1] == *IntVector)
  {
    v14 = *(_QWORD *)RealVector;
    v15 = *((_QWORD *)RealVector + 1);
    v16 = v15 - *(_QWORD *)RealVector;
    if (v15 == *(_QWORD *)RealVector)
    {
      v20 = (double *)v3[21];
    }
    else
    {
      v17 = 0;
      v18 = v16 >> 3;
      v19 = v3[15];
      v20 = (double *)v3[21];
      if (v18 <= 1)
        v18 = 1;
      do
      {
        v20[v17] = *(double *)(v14 + 8 * v17) - *(double *)(v19 + 8 * v17);
        ++v17;
      }
      while (v18 != v17);
    }
    v21 = v3[20];
    if ((int)v4 >= 1)
    {
      v22 = 0;
      v23 = 0;
      v24 = v3[16];
      do
      {
        v25 = (double *)(v24 + 8 * v23);
        v26 = 0.0;
        v27 = v20;
        v28 = v4;
        do
        {
          v29 = *v25++;
          v30 = v29;
          v31 = *v27++;
          v26 = v26 + v30 * v31;
          --v28;
        }
        while (v28);
        *(double *)(v21 + 8 * v22) = v26;
        v23 += v4;
        ++v22;
      }
      while (v22 != v4);
    }
    if ((int)v5 < 1)
    {
      v59 = -1.0;
    }
    else
    {
      v60 = v2;
      v61 = v5;
      v32 = 0;
      v33 = 0.0;
      v34 = -1;
      v35 = v6;
      v36 = v9;
      v62 = v3;
      do
      {
        v37 = v35;
        if (v35 <= 0 && (v37 = *(_DWORD *)(v3[14] + 4 * v32), v37 < 1))
        {
          v40 = 0.0;
        }
        else
        {
          v64 = v34;
          v65 = v32;
          v66 = v36;
          v38 = 0;
          v39 = (double *)v3[22];
          v63 = (v37 - 1);
          v40 = 0.0;
          v67 = v37;
          do
          {
            v41 = 0.0;
            if ((int)v4 >= 1)
            {
              for (i = 0; i != v4; ++i)
                v20[i] = *(double *)(v21 + i * 8) - *(double *)(v7 + i * 8);
              v43 = 0;
              v44 = 0;
              do
              {
                v45 = 8 * v44;
                v46 = 0.0;
                v47 = v20;
                v48 = v4;
                do
                {
                  v49 = *v47++;
                  v46 = v46 + *(double *)(v8 + v45) * v49;
                  v45 += 8;
                  --v48;
                }
                while (v48);
                v39[v43] = v46;
                v44 += v4;
                ++v43;
              }
              while (v43 != v4);
              v41 = 0.0;
              v50 = v4;
              v51 = v20;
              v52 = v39;
              do
              {
                v53 = *v51++;
                v54 = v53;
                v55 = *v52++;
                v41 = v41 - v54 * v55;
                --v50;
              }
              while (v50);
            }
            v56 = *v36++;
            v40 = v40 + v56 * exp(v41);
            v7 += 8 * (int)v4;
            v8 += 8 * (v4 * v4);
            ++v38;
          }
          while (v38 != v67);
          v32 = v65;
          v36 = &v66[v63 + 1];
          v5 = v61;
          v3 = v62;
          v35 = v6;
          v34 = v64;
        }
        if (v40 > v33 || v34 < 0)
        {
          v33 = v40;
          v34 = v32;
        }
        ++v32;
      }
      while (v32 != v5);
      v59 = (double)v34;
      v2 = v60;
    }
    CPMLFeatureVector::setYHat((uint64_t)v2, v59);
    return 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(RealVector);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "eval", "Feature vector in Gaussian mixture model predict should not have integer features.");
    return 1;
  }
}

uint64_t CPGMMClassfier::errorString(CPGMMClassfier *this)
{
  return 0;
}

uint64_t CPGMMClassfier::requireRealOnly(CPGMMClassfier *this)
{
  return 1;
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessGetCountAndYCardinality(id *this, double *a2, double *a3)
{
  id v6;
  id v7;
  _BOOL8 v8;

  v6 = this[1];
  v7 = *this;
  v8 = (objc_opt_respondsToSelector() & 1) != 0
    && objc_msgSend(v7, "preProcessGetCountAndYCardinality:count:withCardY:", v6, a2, a3) == 1;

  return v8;
}

void sub_209CF136C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessGetCountY(id *this, double *a2, int a3)
{
  id v6;
  id v7;
  _BOOL8 v8;

  v6 = this[1];
  v7 = *this;
  v8 = (objc_opt_respondsToSelector() & 1) != 0 && objc_msgSend(v7, "preProcessGetCountY:count:withY:", v6, a2, a3) == 1;

  return v8;
}

void sub_209CF1408(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessGetCountXGivenYAndSetXCardinality(id *this, double *a2, int a3, int a4, int a5, double *a6)
{
  id v12;
  id v13;
  _BOOL8 v14;

  v12 = this[1];
  v13 = *this;
  v14 = (objc_opt_respondsToSelector() & 1) != 0
     && objc_msgSend(v13, "preProcessGetCountXGivenYAndSetXCardinality:count:withXCol:withX:withY:withCardinalityX:", v12, a2, a3, a4, a5, a6) == 1;

  return v14;
}

void sub_209CF14CC(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessSetCount(id *this, double a2)
{
  id v4;
  id v5;
  _BOOL8 v6;

  v4 = this[1];
  v5 = *this;
  v6 = (objc_opt_respondsToSelector() & 1) != 0 && objc_msgSend(v5, "preProcessSetCount:withNumberY:", v4, a2) == 1;

  return v6;
}

void sub_209CF1568(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessSetCountY(id *this, int a2, double a3)
{
  id v6;
  id v7;
  _BOOL8 v8;

  v6 = this[1];
  v7 = *this;
  v8 = (objc_opt_respondsToSelector() & 1) != 0
    && objc_msgSend(v7, "preProcessSetCountY:withY:withCount:", v6, a2, a3) == 1;

  return v8;
}

void sub_209CF160C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessSetCountXGivenY(id *this, int a2, int a3, int a4, double a5)
{
  id v10;
  id v11;
  _BOOL8 v12;

  v10 = this[1];
  v11 = *this;
  v12 = (objc_opt_respondsToSelector() & 1) != 0
     && objc_msgSend(v11, "preProcessSetCountXGivenY:withXCol:withX:withY:withValue:", v10, a2, a3, a4, a5) == 1;

  return v12;
}

void sub_209CF16C8(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessSetCardinalityXGivenY(id *this, int a2, int a3, double a4)
{
  id v8;
  id v9;
  _BOOL8 v10;

  v8 = this[1];
  v9 = *this;
  v10 = (objc_opt_respondsToSelector() & 1) != 0
     && objc_msgSend(v9, "preProcessSetCardinalityXGivenY:withXCol:withY:cardinalityValue:", v8, a2, a3, a4) == 1;

  return v10;
}

void sub_209CF1774(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessUpdateNaiveBayes(id *a1, uint64_t *a2, uint64_t a3)
{
  id v6;
  id v7;
  void *v8;
  uint64_t v9;
  unint64_t v10;
  void *v11;
  unint64_t v12;
  id v13;
  void *v14;
  _BOOL8 v15;
  uint64_t v17;
  void *v18;
  void *__p;
  _BYTE *v20;
  uint64_t v21;

  v6 = a1[1];
  v7 = *a1;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v17 = a3;
    v18 = v7;
    v8 = (void *)objc_opt_new();
    v9 = *a2;
    if (a2[1] != *a2)
    {
      v10 = 0;
      do
      {
        __p = 0;
        v20 = 0;
        v21 = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)(v9 + 24 * v10), *(_QWORD *)(v9 + 24 * v10 + 8), (uint64_t)(*(_QWORD *)(v9 + 24 * v10 + 8) - *(_QWORD *)(v9 + 24 * v10)) >> 2);
        v11 = (void *)objc_opt_new();
        if (v20 != __p)
        {
          v12 = 0;
          do
          {
            v13 = objc_alloc(MEMORY[0x24BDD16E0]);
            v14 = (void *)objc_msgSend(v13, "initWithInt:", *((unsigned int *)__p + v10));
            objc_msgSend(v11, "addObject:", v14);

            ++v12;
          }
          while (v12 < (v20 - (_BYTE *)__p) >> 2);
        }
        objc_msgSend(v8, "addObject:", v11, v17);

        if (__p)
        {
          v20 = __p;
          operator delete(__p);
        }
        ++v10;
        v9 = *a2;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v10);
    }
    v15 = objc_msgSend(v18, "preProcessUpdateNaiveBayes:withRow:withY:", v6, v8, (int)v17, v17) == 1;

    v7 = v18;
  }
  else
  {
    v15 = 0;
  }

  return v15;
}

void sub_209CF1924(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *a10, void *a11, void *__p, uint64_t a13)
{
  void *v13;

  _Unwind_Resume(a1);
}

BOOL CPMLDelegateEngineNaiveBayes::preProcessPredictSorted(id *a1, uint64_t *a2, _QWORD *a3)
{
  id v5;
  id v6;
  void *v7;
  uint64_t v8;
  unint64_t v9;
  void *v10;
  unint64_t v11;
  id v12;
  void *v13;
  unint64_t i;
  uint64_t v15;
  void *v16;
  unint64_t j;
  void *v18;
  int v19;
  int v20;
  char *v21;
  char *v22;
  char *v23;
  uint64_t v24;
  unint64_t v25;
  uint64_t v26;
  unint64_t v27;
  char *v28;
  char *v29;
  int v30;
  _BOOL8 v31;
  uint64_t v33;
  void *v34;
  void *__p;
  char *v37;
  char *v38;

  v5 = a1[1];
  v6 = *a1;
  if ((objc_opt_respondsToSelector() & 1) != 0)
  {
    v34 = v6;
    v7 = (void *)objc_opt_new();
    v8 = *a2;
    if (a2[1] != *a2)
    {
      v9 = 0;
      do
      {
        __p = 0;
        v37 = 0;
        v38 = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)(v8 + 24 * v9), *(_QWORD *)(v8 + 24 * v9 + 8), (uint64_t)(*(_QWORD *)(v8 + 24 * v9 + 8) - *(_QWORD *)(v8 + 24 * v9)) >> 2);
        v10 = (void *)objc_opt_new();
        if (v37 != __p)
        {
          v11 = 0;
          do
          {
            v12 = objc_alloc(MEMORY[0x24BDD16E0]);
            v13 = (void *)objc_msgSend(v12, "initWithInt:", *((unsigned int *)__p + v9));
            objc_msgSend(v10, "addObject:", v13);

            ++v11;
          }
          while (v11 < (v37 - (_BYTE *)__p) >> 2);
        }
        objc_msgSend(v7, "addObject:", v10);

        if (__p)
        {
          v37 = (char *)__p;
          operator delete(__p);
        }
        ++v9;
        v8 = *a2;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v9);
    }
    v33 = objc_msgSend(v34, "preProcessPredictSorted:withRow:", v5, v7);
    for (i = 0; i < objc_msgSend(v7, "count"); ++i)
    {
      v15 = *a3 + 24 * i;
      v37 = 0;
      v38 = 0;
      __p = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)v15, *(_QWORD *)(v15 + 8), (uint64_t)(*(_QWORD *)(v15 + 8) - *(_QWORD *)v15) >> 2);
      objc_msgSend(v7, "objectAtIndexedSubscript:", i);
      v16 = (void *)objc_claimAutoreleasedReturnValue();
      for (j = 0; j < objc_msgSend(v16, "count"); ++j)
      {
        objc_msgSend(v16, "objectAtIndexedSubscript:", i);
        v18 = (void *)objc_claimAutoreleasedReturnValue();
        v19 = objc_msgSend(v18, "integerValue");
        v20 = v19;
        v21 = v37;
        if (v37 >= v38)
        {
          v23 = (char *)__p;
          v24 = (v37 - (_BYTE *)__p) >> 2;
          v25 = v24 + 1;
          if ((unint64_t)(v24 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v26 = v38 - (_BYTE *)__p;
          if ((v38 - (_BYTE *)__p) >> 1 > v25)
            v25 = v26 >> 1;
          if ((unint64_t)v26 >= 0x7FFFFFFFFFFFFFFCLL)
            v27 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v27 = v25;
          if (v27)
          {
            v28 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)&v38, v27);
            v23 = (char *)__p;
            v21 = v37;
          }
          else
          {
            v28 = 0;
          }
          v29 = &v28[4 * v24];
          *(_DWORD *)v29 = v20;
          v22 = v29 + 4;
          while (v21 != v23)
          {
            v30 = *((_DWORD *)v21 - 1);
            v21 -= 4;
            *((_DWORD *)v29 - 1) = v30;
            v29 -= 4;
          }
          __p = v29;
          v37 = v22;
          v38 = &v28[4 * v27];
          if (v23)
            operator delete(v23);
        }
        else
        {
          *(_DWORD *)v37 = v19;
          v22 = v21 + 4;
        }
        v37 = v22;

      }
      if (__p)
      {
        v37 = (char *)__p;
        operator delete(__p);
      }
    }
    v31 = v33 == 1;

    v6 = v34;
  }
  else
  {
    v31 = 0;
  }

  return v31;
}

void sub_209CF1C84(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, void *a11, void *a12, uint64_t a13, void *__p, uint64_t a15)
{
  void *v15;

  _Unwind_Resume(a1);
}

void CPMLFeatureVector::CPMLFeatureVector(CPMLFeatureVector *this)
{
  _QWORD *v2;
  _QWORD *v3;

  v2 = (_QWORD *)operator new();
  v2[1] = 0;
  v2[2] = 0;
  *v2 = 0;
  *((_QWORD *)this + 1) = v2;
  v3 = (_QWORD *)operator new();
  v3[1] = 0;
  v3[2] = 0;
  *v3 = 0;
  *((_QWORD *)this + 2) = v3;
  *((_QWORD *)this + 3) = 0;
  *((_QWORD *)this + 4) = 0;
  *((_QWORD *)this + 5) = 0;
  *(_OWORD *)((char *)this + 56) = 0u;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((double *)this + 6) = nan("");
}

void CPMLFeatureVector::~CPMLFeatureVector(CPMLFeatureVector *this)
{
  uint64_t v2;
  void *v3;
  uint64_t v4;
  void *v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  void *v10;
  uint64_t v11;
  void *v12;
  char *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  void *v17;
  uint64_t v18;
  void *v19;
  void *v20;
  void *v21;

  *((_QWORD *)this + 6) = 0x7FEFFFFFFFFFFFFFLL;
  v2 = *((_QWORD *)this + 1);
  if (v2)
  {
    v3 = *(void **)v2;
    if (*(_QWORD *)v2)
    {
      *(_QWORD *)(v2 + 8) = v3;
      operator delete(v3);
    }
    MEMORY[0x20BD188E4](v2, 0x10C402FEFCB83);
  }
  v4 = *((_QWORD *)this + 2);
  if (v4)
  {
    v5 = *(void **)v4;
    if (*(_QWORD *)v4)
    {
      *(_QWORD *)(v4 + 8) = v5;
      operator delete(v5);
    }
    MEMORY[0x20BD188E4](v4, 0x80C40D6874129);
  }
  v6 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) != v6)
  {
    v7 = 0;
    v8 = 0;
    do
    {
      v9 = *(_QWORD *)(v6 + v7);
      if (v9)
      {
        v10 = *(void **)v9;
        if (*(_QWORD *)v9)
        {
          *(_QWORD *)(v9 + 8) = v10;
          operator delete(v10);
        }
        MEMORY[0x20BD188E4](v9, 0x10C402FEFCB83);
      }
      v11 = *(_QWORD *)(v6 + v7 + 8);
      if (v11)
      {
        v12 = *(void **)v11;
        if (*(_QWORD *)v11)
        {
          *(_QWORD *)(v11 + 8) = v12;
          operator delete(v12);
        }
        MEMORY[0x20BD188E4](v11, 0x80C40D6874129);
      }
      ++v8;
      v6 = *((_QWORD *)this + 3);
      v7 += 16;
    }
    while (v8 < (*((_QWORD *)this + 4) - v6) >> 4);
  }
  v13 = (char *)*((_QWORD *)this + 8);
  if (v13 != *((char **)this + 7))
  {
    v14 = 0;
    v15 = 0;
    v13 = (char *)*((_QWORD *)this + 7);
    do
    {
      v16 = *(_QWORD *)&v13[v14];
      if (v16)
      {
        v17 = *(void **)v16;
        if (*(_QWORD *)v16)
        {
          *(_QWORD *)(v16 + 8) = v17;
          operator delete(v17);
        }
        MEMORY[0x20BD188E4](v16, 0x10C402FEFCB83);
      }
      v18 = *(_QWORD *)&v13[v14 + 8];
      if (v18)
      {
        v19 = *(void **)v18;
        if (*(_QWORD *)v18)
        {
          *(_QWORD *)(v18 + 8) = v19;
          operator delete(v19);
        }
        MEMORY[0x20BD188E4](v18, 0x80C40D6874129);
      }
      ++v15;
      v13 = (char *)*((_QWORD *)this + 7);
      v14 += 16;
    }
    while (v15 < (uint64_t)(*((_QWORD *)this + 8) - (_QWORD)v13) >> 4);
  }
  v20 = (void *)*((_QWORD *)this + 10);
  if (v20)
  {
    *((_QWORD *)this + 11) = v20;
    operator delete(v20);
    v13 = (char *)*((_QWORD *)this + 7);
  }
  if (v13)
  {
    *((_QWORD *)this + 8) = v13;
    operator delete(v13);
  }
  v21 = (void *)*((_QWORD *)this + 3);
  if (v21)
  {
    *((_QWORD *)this + 4) = v21;
    operator delete(v21);
  }
}

uint64_t CPMLFeatureVector::getIntVector(CPMLFeatureVector *this)
{
  return *((_QWORD *)this + 1);
}

uint64_t CPMLFeatureVector::getRealVector(CPMLFeatureVector *this)
{
  return *((_QWORD *)this + 2);
}

uint64_t CPMLFeatureVector::getXVectorVector(CPMLFeatureVector *this)
{
  return (uint64_t)this + 24;
}

uint64_t CPMLFeatureVector::getYVectorVector(CPMLFeatureVector *this)
{
  return (uint64_t)this + 56;
}

double CPMLFeatureVector::getYHat(CPMLFeatureVector *this)
{
  return *((double *)this + 6);
}

void CPMLFeatureVector::insertIntVClass(CPMLFeatureVector *this, int a2)
{
  uint64_t v3;
  _DWORD *v4;
  unint64_t v5;
  _DWORD *v6;
  _DWORD *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  char *v13;
  char *v14;
  int v15;

  v3 = *((_QWORD *)this + 1);
  v4 = *(_DWORD **)(v3 + 8);
  v5 = *(_QWORD *)(v3 + 16);
  if ((unint64_t)v4 >= v5)
  {
    v7 = *(_DWORD **)v3;
    v8 = ((uint64_t)v4 - *(_QWORD *)v3) >> 2;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)v7;
    if (v10 >> 1 > v9)
      v9 = v10 >> 1;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFFCLL)
      v11 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v3 + 16, v11);
      v7 = *(_DWORD **)v3;
      v4 = *(_DWORD **)(v3 + 8);
    }
    else
    {
      v12 = 0;
    }
    v13 = &v12[4 * v8];
    v14 = &v12[4 * v11];
    *(_DWORD *)v13 = a2;
    v6 = v13 + 4;
    while (v4 != v7)
    {
      v15 = *--v4;
      *((_DWORD *)v13 - 1) = v15;
      v13 -= 4;
    }
    *(_QWORD *)v3 = v13;
    *(_QWORD *)(v3 + 8) = v6;
    *(_QWORD *)(v3 + 16) = v14;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v4 = a2;
    v6 = v4 + 1;
  }
  *(_QWORD *)(v3 + 8) = v6;
}

void CPMLFeatureVector::insertRealVClass(CPMLFeatureVector *this, double a2)
{
  uint64_t v3;
  double *v4;
  unint64_t v5;
  double *v6;
  double *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t v11;
  char *v12;
  double *v13;
  char *v14;
  uint64_t v15;

  v3 = *((_QWORD *)this + 2);
  v4 = *(double **)(v3 + 8);
  v5 = *(_QWORD *)(v3 + 16);
  if ((unint64_t)v4 >= v5)
  {
    v7 = *(double **)v3;
    v8 = ((uint64_t)v4 - *(_QWORD *)v3) >> 3;
    v9 = v8 + 1;
    if ((unint64_t)(v8 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v5 - (_QWORD)v7;
    if (v10 >> 2 > v9)
      v9 = v10 >> 2;
    if ((unint64_t)v10 >= 0x7FFFFFFFFFFFFFF8)
      v11 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v11 = v9;
    if (v11)
    {
      v12 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v3 + 16, v11);
      v7 = *(double **)v3;
      v4 = *(double **)(v3 + 8);
    }
    else
    {
      v12 = 0;
    }
    v13 = (double *)&v12[8 * v8];
    v14 = &v12[8 * v11];
    *v13 = a2;
    v6 = v13 + 1;
    while (v4 != v7)
    {
      v15 = *((_QWORD *)v4-- - 1);
      *((_QWORD *)v13-- - 1) = v15;
    }
    *(_QWORD *)v3 = v13;
    *(_QWORD *)(v3 + 8) = v6;
    *(_QWORD *)(v3 + 16) = v14;
    if (v7)
      operator delete(v7);
  }
  else
  {
    *v4 = a2;
    v6 = v4 + 1;
  }
  *(_QWORD *)(v3 + 8) = v6;
}

_QWORD *CPMLFeatureVector::insertRealVClass(CPMLFeatureVector *this, double a2, int a3)
{
  _QWORD *result;

  result = (_QWORD *)*((_QWORD *)this + 2);
  if (a3 >= (unint64_t)((uint64_t)(result[1] - *result) >> 3))
    std::vector<VectorClass>::__throw_out_of_range[abi:ne180100]();
  *(double *)(*result + 8 * a3) = a2;
  return result;
}

void CPMLFeatureVector::insertIntToLastVVClass(CPMLFeatureVector *this, int a2)
{
  uint64_t v3;
  char **v4;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _DWORD *v22;
  unint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  int v33;

  v3 = *((_QWORD *)this + 4);
  v4 = (char **)((char *)this + 24);
  if (v3 == *((_QWORD *)this + 3))
  {
    v6 = (_QWORD *)operator new();
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v6 = v7;
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    v6[1] = v8;
    v9 = *((_QWORD *)this + 5);
    v10 = (_OWORD *)*((_QWORD *)this + 4);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *v4) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v14 = v9 - (_QWORD)*v4;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)this + 40, v15);
      else
        v16 = 0;
      v17 = &v16[16 * v12];
      v18 = &v16[16 * v15];
      *(_OWORD *)v17 = *(_OWORD *)v6;
      v11 = v17 + 16;
      v20 = (char *)*((_QWORD *)this + 3);
      v19 = (char *)*((_QWORD *)this + 4);
      if (v19 != v20)
      {
        do
        {
          *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
          v17 -= 16;
          v19 -= 16;
        }
        while (v19 != v20);
        v19 = *v4;
      }
      *((_QWORD *)this + 3) = v17;
      *((_QWORD *)this + 4) = v11;
      *((_QWORD *)this + 5) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v10 = *(_OWORD *)v6;
      v11 = v10 + 1;
    }
    *((_QWORD *)this + 4) = v11;
    MEMORY[0x20BD188E4](v6, 0x20C40A4A59CD2);
    v3 = *((_QWORD *)this + 4);
  }
  v21 = *(_QWORD *)(v3 - 16);
  v22 = *(_DWORD **)(v21 + 8);
  v23 = *(_QWORD *)(v21 + 16);
  if ((unint64_t)v22 >= v23)
  {
    v25 = *(_DWORD **)v21;
    v26 = ((uint64_t)v22 - *(_QWORD *)v21) >> 2;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v28 = v23 - (_QWORD)v25;
    if (v28 >> 1 > v27)
      v27 = v28 >> 1;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
      v29 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    if (v29)
    {
      v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v21 + 16, v29);
      v25 = *(_DWORD **)v21;
      v22 = *(_DWORD **)(v21 + 8);
    }
    else
    {
      v30 = 0;
    }
    v31 = &v30[4 * v26];
    v32 = &v30[4 * v29];
    *(_DWORD *)v31 = a2;
    v24 = v31 + 4;
    while (v22 != v25)
    {
      v33 = *--v22;
      *((_DWORD *)v31 - 1) = v33;
      v31 -= 4;
    }
    *(_QWORD *)v21 = v31;
    *(_QWORD *)(v21 + 8) = v24;
    *(_QWORD *)(v21 + 16) = v32;
    if (v25)
      operator delete(v25);
  }
  else
  {
    *v22 = a2;
    v24 = v22 + 1;
  }
  *(_QWORD *)(v21 + 8) = v24;
}

void sub_209CF23EC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertRealToLastVVClass(CPMLFeatureVector *this, double a2)
{
  uint64_t v3;
  char **v4;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  double *v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  double *v31;
  char *v32;
  uint64_t v33;

  v3 = *((_QWORD *)this + 4);
  v4 = (char **)((char *)this + 24);
  if (v3 == *((_QWORD *)this + 3))
  {
    v6 = (_QWORD *)operator new();
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v6 = v7;
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    v6[1] = v8;
    v9 = *((_QWORD *)this + 5);
    v10 = (_OWORD *)*((_QWORD *)this + 4);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *v4) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v14 = v9 - (_QWORD)*v4;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)this + 40, v15);
      else
        v16 = 0;
      v17 = &v16[16 * v12];
      v18 = &v16[16 * v15];
      *(_OWORD *)v17 = *(_OWORD *)v6;
      v11 = v17 + 16;
      v20 = (char *)*((_QWORD *)this + 3);
      v19 = (char *)*((_QWORD *)this + 4);
      if (v19 != v20)
      {
        do
        {
          *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
          v17 -= 16;
          v19 -= 16;
        }
        while (v19 != v20);
        v19 = *v4;
      }
      *((_QWORD *)this + 3) = v17;
      *((_QWORD *)this + 4) = v11;
      *((_QWORD *)this + 5) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v10 = *(_OWORD *)v6;
      v11 = v10 + 1;
    }
    *((_QWORD *)this + 4) = v11;
    MEMORY[0x20BD188E4](v6, 0x20C40A4A59CD2);
    v3 = *((_QWORD *)this + 4);
  }
  v21 = *(_QWORD *)(v3 - 8);
  v22 = *(double **)(v21 + 8);
  v23 = *(_QWORD *)(v21 + 16);
  if ((unint64_t)v22 >= v23)
  {
    v25 = *(double **)v21;
    v26 = ((uint64_t)v22 - *(_QWORD *)v21) >> 3;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v28 = v23 - (_QWORD)v25;
    if (v28 >> 2 > v27)
      v27 = v28 >> 2;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    if (v29)
    {
      v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v21 + 16, v29);
      v25 = *(double **)v21;
      v22 = *(double **)(v21 + 8);
    }
    else
    {
      v30 = 0;
    }
    v31 = (double *)&v30[8 * v26];
    v32 = &v30[8 * v29];
    *v31 = a2;
    v24 = v31 + 1;
    while (v22 != v25)
    {
      v33 = *((_QWORD *)v22-- - 1);
      *((_QWORD *)v31-- - 1) = v33;
    }
    *(_QWORD *)v21 = v31;
    *(_QWORD *)(v21 + 8) = v24;
    *(_QWORD *)(v21 + 16) = v32;
    if (v25)
      operator delete(v25);
  }
  else
  {
    *v22 = a2;
    v24 = v22 + 1;
  }
  *(_QWORD *)(v21 + 8) = v24;
}

void sub_209CF2650(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertNewVCIntoVVClass(CPMLFeatureVector *this)
{
  _QWORD *v2;
  _QWORD *v3;
  _QWORD *v4;
  unint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  v2 = (_QWORD *)operator new();
  v3 = (_QWORD *)operator new();
  *v3 = 0;
  v3[1] = 0;
  v3[2] = 0;
  *v2 = v3;
  v4 = (_QWORD *)operator new();
  *v4 = 0;
  v4[1] = 0;
  v4[2] = 0;
  v2[1] = v4;
  v5 = *((_QWORD *)this + 5);
  v6 = (_OWORD *)*((_QWORD *)this + 4);
  if ((unint64_t)v6 >= v5)
  {
    v8 = *((_QWORD *)this + 3);
    v9 = ((uint64_t)v6 - v8) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)this + 40, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v9];
    v15 = &v13[16 * v12];
    *(_OWORD *)v14 = *(_OWORD *)v2;
    v7 = v14 + 16;
    v17 = (char *)*((_QWORD *)this + 3);
    v16 = (char *)*((_QWORD *)this + 4);
    if (v16 != v17)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      v16 = (char *)*((_QWORD *)this + 3);
    }
    *((_QWORD *)this + 3) = v14;
    *((_QWORD *)this + 4) = v7;
    *((_QWORD *)this + 5) = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = *(_OWORD *)v2;
    v7 = v6 + 1;
  }
  *((_QWORD *)this + 4) = v7;
  JUMPOUT(0x20BD188E4);
}

void sub_209CF27DC(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertIntVectorToVVClass(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  unint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  v4 = (_QWORD *)operator new();
  VectorClass::VectorClass(v4, a2, 0);
  v5 = a1[5];
  v6 = (_OWORD *)a1[4];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[3];
    v9 = ((uint64_t)v6 - v8) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)(a1 + 5), v12);
    else
      v13 = 0;
    v14 = &v13[16 * v9];
    v15 = &v13[16 * v12];
    *(_OWORD *)v14 = *(_OWORD *)v4;
    v7 = v14 + 16;
    v17 = (char *)a1[3];
    v16 = (char *)a1[4];
    if (v16 != v17)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      v16 = (char *)a1[3];
    }
    a1[3] = v14;
    a1[4] = v7;
    a1[5] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = *(_OWORD *)v4;
    v7 = v6 + 1;
  }
  a1[4] = v7;
  JUMPOUT(0x20BD188E4);
}

void sub_209CF2930(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertRealVectorToVVClass(_QWORD *a1, uint64_t *a2)
{
  _QWORD *v4;
  unint64_t v5;
  _OWORD *v6;
  _OWORD *v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;

  v4 = (_QWORD *)operator new();
  VectorClass::VectorClass(v4, 0, a2);
  v5 = a1[5];
  v6 = (_OWORD *)a1[4];
  if ((unint64_t)v6 >= v5)
  {
    v8 = a1[3];
    v9 = ((uint64_t)v6 - v8) >> 4;
    v10 = v9 + 1;
    if ((unint64_t)(v9 + 1) >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v11 = v5 - v8;
    if (v11 >> 3 > v10)
      v10 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v10;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)(a1 + 5), v12);
    else
      v13 = 0;
    v14 = &v13[16 * v9];
    v15 = &v13[16 * v12];
    *(_OWORD *)v14 = *(_OWORD *)v4;
    v7 = v14 + 16;
    v17 = (char *)a1[3];
    v16 = (char *)a1[4];
    if (v16 != v17)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v16 - 1);
        v14 -= 16;
        v16 -= 16;
      }
      while (v16 != v17);
      v16 = (char *)a1[3];
    }
    a1[3] = v14;
    a1[4] = v7;
    a1[5] = v15;
    if (v16)
      operator delete(v16);
  }
  else
  {
    *v6 = *(_OWORD *)v4;
    v7 = v6 + 1;
  }
  a1[4] = v7;
  JUMPOUT(0x20BD188E4);
}

void sub_209CF2A84(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertYIntVClass(CPMLFeatureVector *this, int a2)
{
  uint64_t v3;
  char **v4;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  _DWORD *v22;
  unint64_t v23;
  _DWORD *v24;
  _DWORD *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  char *v31;
  char *v32;
  int v33;

  v3 = *((_QWORD *)this + 8);
  v4 = (char **)((char *)this + 56);
  if (v3 == *((_QWORD *)this + 7))
  {
    v6 = (_QWORD *)operator new();
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v6 = v7;
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    v6[1] = v8;
    v9 = *((_QWORD *)this + 9);
    v10 = (_OWORD *)*((_QWORD *)this + 8);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *v4) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v14 = v9 - (_QWORD)*v4;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)this + 72, v15);
      else
        v16 = 0;
      v17 = &v16[16 * v12];
      v18 = &v16[16 * v15];
      *(_OWORD *)v17 = *(_OWORD *)v6;
      v11 = v17 + 16;
      v20 = (char *)*((_QWORD *)this + 7);
      v19 = (char *)*((_QWORD *)this + 8);
      if (v19 != v20)
      {
        do
        {
          *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
          v17 -= 16;
          v19 -= 16;
        }
        while (v19 != v20);
        v19 = *v4;
      }
      *((_QWORD *)this + 7) = v17;
      *((_QWORD *)this + 8) = v11;
      *((_QWORD *)this + 9) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v10 = *(_OWORD *)v6;
      v11 = v10 + 1;
    }
    *((_QWORD *)this + 8) = v11;
    MEMORY[0x20BD188E4](v6, 0x20C40A4A59CD2);
    v3 = *((_QWORD *)this + 8);
  }
  v21 = *(_QWORD *)(v3 - 16);
  v22 = *(_DWORD **)(v21 + 8);
  v23 = *(_QWORD *)(v21 + 16);
  if ((unint64_t)v22 >= v23)
  {
    v25 = *(_DWORD **)v21;
    v26 = ((uint64_t)v22 - *(_QWORD *)v21) >> 2;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 62)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v28 = v23 - (_QWORD)v25;
    if (v28 >> 1 > v27)
      v27 = v28 >> 1;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFFCLL)
      v29 = 0x3FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    if (v29)
    {
      v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(v21 + 16, v29);
      v25 = *(_DWORD **)v21;
      v22 = *(_DWORD **)(v21 + 8);
    }
    else
    {
      v30 = 0;
    }
    v31 = &v30[4 * v26];
    v32 = &v30[4 * v29];
    *(_DWORD *)v31 = a2;
    v24 = v31 + 4;
    while (v22 != v25)
    {
      v33 = *--v22;
      *((_DWORD *)v31 - 1) = v33;
      v31 -= 4;
    }
    *(_QWORD *)v21 = v31;
    *(_QWORD *)(v21 + 8) = v24;
    *(_QWORD *)(v21 + 16) = v32;
    if (v25)
      operator delete(v25);
  }
  else
  {
    *v22 = a2;
    v24 = v22 + 1;
  }
  *(_QWORD *)(v21 + 8) = v24;
}

void sub_209CF2CE8(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

void CPMLFeatureVector::insertYRealVClass(CPMLFeatureVector *this, double a2)
{
  uint64_t v3;
  char **v4;
  _QWORD *v6;
  _QWORD *v7;
  _QWORD *v8;
  unint64_t v9;
  _OWORD *v10;
  _OWORD *v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  unint64_t v15;
  char *v16;
  char *v17;
  char *v18;
  char *v19;
  char *v20;
  uint64_t v21;
  double *v22;
  unint64_t v23;
  double *v24;
  double *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  unint64_t v29;
  char *v30;
  double *v31;
  char *v32;
  uint64_t v33;

  v3 = *((_QWORD *)this + 8);
  v4 = (char **)((char *)this + 56);
  if (v3 == *((_QWORD *)this + 7))
  {
    v6 = (_QWORD *)operator new();
    v7 = (_QWORD *)operator new();
    *v7 = 0;
    v7[1] = 0;
    v7[2] = 0;
    *v6 = v7;
    v8 = (_QWORD *)operator new();
    *v8 = 0;
    v8[1] = 0;
    v8[2] = 0;
    v6[1] = v8;
    v9 = *((_QWORD *)this + 9);
    v10 = (_OWORD *)*((_QWORD *)this + 8);
    if ((unint64_t)v10 >= v9)
    {
      v12 = ((char *)v10 - *v4) >> 4;
      v13 = v12 + 1;
      if ((unint64_t)(v12 + 1) >> 60)
        std::vector<double>::__throw_length_error[abi:ne180100]();
      v14 = v9 - (_QWORD)*v4;
      if (v14 >> 3 > v13)
        v13 = v14 >> 3;
      if ((unint64_t)v14 >= 0x7FFFFFFFFFFFFFF0)
        v15 = 0xFFFFFFFFFFFFFFFLL;
      else
        v15 = v13;
      if (v15)
        v16 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)this + 72, v15);
      else
        v16 = 0;
      v17 = &v16[16 * v12];
      v18 = &v16[16 * v15];
      *(_OWORD *)v17 = *(_OWORD *)v6;
      v11 = v17 + 16;
      v20 = (char *)*((_QWORD *)this + 7);
      v19 = (char *)*((_QWORD *)this + 8);
      if (v19 != v20)
      {
        do
        {
          *((_OWORD *)v17 - 1) = *((_OWORD *)v19 - 1);
          v17 -= 16;
          v19 -= 16;
        }
        while (v19 != v20);
        v19 = *v4;
      }
      *((_QWORD *)this + 7) = v17;
      *((_QWORD *)this + 8) = v11;
      *((_QWORD *)this + 9) = v18;
      if (v19)
        operator delete(v19);
    }
    else
    {
      *v10 = *(_OWORD *)v6;
      v11 = v10 + 1;
    }
    *((_QWORD *)this + 8) = v11;
    MEMORY[0x20BD188E4](v6, 0x20C40A4A59CD2);
    v3 = *((_QWORD *)this + 8);
  }
  v21 = *(_QWORD *)(v3 - 8);
  v22 = *(double **)(v21 + 8);
  v23 = *(_QWORD *)(v21 + 16);
  if ((unint64_t)v22 >= v23)
  {
    v25 = *(double **)v21;
    v26 = ((uint64_t)v22 - *(_QWORD *)v21) >> 3;
    v27 = v26 + 1;
    if ((unint64_t)(v26 + 1) >> 61)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v28 = v23 - (_QWORD)v25;
    if (v28 >> 2 > v27)
      v27 = v28 >> 2;
    if ((unint64_t)v28 >= 0x7FFFFFFFFFFFFFF8)
      v29 = 0x1FFFFFFFFFFFFFFFLL;
    else
      v29 = v27;
    if (v29)
    {
      v30 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v21 + 16, v29);
      v25 = *(double **)v21;
      v22 = *(double **)(v21 + 8);
    }
    else
    {
      v30 = 0;
    }
    v31 = (double *)&v30[8 * v26];
    v32 = &v30[8 * v29];
    *v31 = a2;
    v24 = v31 + 1;
    while (v22 != v25)
    {
      v33 = *((_QWORD *)v22-- - 1);
      *((_QWORD *)v31-- - 1) = v33;
    }
    *(_QWORD *)v21 = v31;
    *(_QWORD *)(v21 + 8) = v24;
    *(_QWORD *)(v21 + 16) = v32;
    if (v25)
      operator delete(v25);
  }
  else
  {
    *v22 = a2;
    v24 = v22 + 1;
  }
  *(_QWORD *)(v21 + 8) = v24;
}

void sub_209CF2F4C(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x20C40A4A59CD2);
  _Unwind_Resume(a1);
}

uint64_t CPMLFeatureVector::setYHat(uint64_t this, double a2)
{
  *(double *)(this + 48) = a2;
  return this;
}

char *CPMLFeatureVector::setYHatProbList(uint64_t a1, uint64_t a2)
{
  char *result;
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 80);
  result = (char *)(a1 + 80);
  *((_QWORD *)result + 1) = v3;
  if (result != (char *)a2)
    return std::vector<ProbIndex>::__assign_with_size[abi:ne180100]<ProbIndex*,ProbIndex*>(result, *(char **)a2, *(_QWORD *)(a2 + 8), (uint64_t)(*(_QWORD *)(a2 + 8) - *(_QWORD *)a2) >> 4);
  return result;
}

_DWORD *CPMLFeatureVector::setYHatVectorPosition(_DWORD *this, int a2)
{
  *this = a2;
  return this;
}

void CPMLFeatureVector::resetAll(CPMLFeatureVector *this)
{
  _QWORD *v2;

  v2 = (_QWORD *)*((_QWORD *)this + 2);
  *(_QWORD *)(*((_QWORD *)this + 1) + 8) = **((_QWORD **)this + 1);
  v2[1] = *v2;
  *((_QWORD *)this + 4) = *((_QWORD *)this + 3);
  *((double *)this + 6) = nan("");
  *((_QWORD *)this + 8) = *((_QWORD *)this + 7);
}

pthread_mutex_t *CPMLFeatureVector::dumpVectorClass(CPMLLog *a1, _QWORD **a2)
{
  pthread_mutex_t *CPMLLog;
  CPMLLog *v4;
  unint64_t v5;
  pthread_mutex_t *v6;
  pthread_mutex_t *v7;
  CPMLLog *v8;
  pthread_mutex_t *v9;
  CPMLLog *v10;
  unint64_t v11;
  pthread_mutex_t *v12;
  pthread_mutex_t *v13;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(a1);
  v4 = (CPMLLog *)CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "dumpVectorClass", "INT: ");
  if ((*a2)[1] != **a2)
  {
    v5 = 0;
    do
    {
      v6 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v4);
      v4 = (CPMLLog *)CPMLLog::log(v6, CPML_LOG_DEBUG, "dumpVectorClass", "%d ", *(_DWORD *)(**a2 + 4 * v5++));
    }
    while (v5 < (uint64_t)((*a2)[1] - **a2) >> 2);
  }
  v7 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v4);
  v8 = (CPMLLog *)CPMLLog::log(v7, CPML_LOG_DEBUG, "dumpVectorClass", "\n ");
  v9 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v8);
  v10 = (CPMLLog *)CPMLLog::log(v9, CPML_LOG_DEBUG, "dumpVectorClass", "REAL: ");
  if (a2[1][1] != *a2[1])
  {
    v11 = 0;
    do
    {
      v12 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
      v10 = (CPMLLog *)CPMLLog::log(v12, CPML_LOG_DEBUG, "dumpVectorClass", "%f \n", *(double *)(*a2[1] + 8 * v11++));
    }
    while (v11 < (uint64_t)(a2[1][1] - *a2[1]) >> 3);
  }
  v13 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
  return CPMLLog::log(v13, CPML_LOG_DEBUG, "dumpVectorClass", "\n ");
}

CPMLLog *CPMLFeatureVector::dumpAll(CPMLFeatureVector *this)
{
  pthread_mutex_t *CPMLLog;
  CPMLLog *v3;
  CPMLLog *v4;
  pthread_mutex_t *v5;
  CPMLLog *v6;
  pthread_mutex_t *v7;
  CPMLLog *v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  CPMLLog *v12;
  pthread_mutex_t *v13;
  pthread_mutex_t *v14;
  CPMLLog *result;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  CPMLLog *v19;
  pthread_mutex_t *v20;

  CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(this);
  v3 = (CPMLLog *)CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "dumpAll", "-- DUMPALL--\n");
  v4 = (CPMLLog *)CPMLFeatureVector::dumpVectorClass(v3, (_QWORD **)this + 1);
  v5 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v4);
  v6 = (CPMLLog *)CPMLLog::log(v5, CPML_LOG_DEBUG, "dumpAll", "yHat %lf \n", *((double *)this + 6));
  v7 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v6);
  v8 = (CPMLLog *)CPMLLog::log(v7, CPML_LOG_DEBUG, "dumpAll", "-- DUMP X VECTOR--\n");
  v9 = *((_QWORD *)this + 3);
  if (*((_QWORD *)this + 4) != v9)
  {
    v10 = 0;
    v11 = 0;
    do
    {
      v12 = (CPMLLog *)CPMLFeatureVector::dumpVectorClass(v8, (_QWORD **)(v9 + v10));
      v13 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v12);
      v8 = (CPMLLog *)CPMLLog::log(v13, CPML_LOG_DEBUG, "dumpAll", "\n");
      ++v11;
      v9 = *((_QWORD *)this + 3);
      v10 += 16;
    }
    while (v11 < (*((_QWORD *)this + 4) - v9) >> 4);
  }
  v14 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v8);
  result = (CPMLLog *)CPMLLog::log(v14, CPML_LOG_DEBUG, "dumpAll", "-- DUMP Y VECTOR--");
  v16 = *((_QWORD *)this + 7);
  if (*((_QWORD *)this + 8) != v16)
  {
    v17 = 0;
    v18 = 0;
    do
    {
      v19 = (CPMLLog *)CPMLFeatureVector::dumpVectorClass(result, (_QWORD **)(v16 + v17));
      v20 = (pthread_mutex_t *)CPMLLog::getCPMLLog(v19);
      result = (CPMLLog *)CPMLLog::log(v20, CPML_LOG_DEBUG, "dumpAll", "\n");
      ++v18;
      v16 = *((_QWORD *)this + 7);
      v17 += 16;
    }
    while (v18 < (*((_QWORD *)this + 8) - v16) >> 4);
  }
  return result;
}

void CPMLFeatureVector::resizeRealVector(CPMLFeatureVector *this, int a2)
{
  std::vector<double>::resize(*((_QWORD *)this + 2), a2);
}

_QWORD *VectorClass::VectorClass(_QWORD *a1, uint64_t *a2, uint64_t *a3)
{
  _QWORD *v6;
  _QWORD *v7;
  uint64_t v8;
  unint64_t v9;
  int v10;
  uint64_t v11;
  _DWORD *v12;
  unint64_t v13;
  _DWORD *v14;
  _DWORD *v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  char *v20;
  char *v21;
  int v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  unint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  unint64_t v32;
  uint64_t v33;
  unint64_t v34;
  char *v35;
  char *v36;
  uint64_t v37;

  v6 = (_QWORD *)operator new();
  v6[1] = 0;
  v6[2] = 0;
  *v6 = 0;
  *a1 = v6;
  v7 = (_QWORD *)operator new();
  v7[1] = 0;
  v7[2] = 0;
  *v7 = 0;
  a1[1] = v7;
  if (a2)
  {
    v8 = *a2;
    if (a2[1] != *a2)
    {
      v9 = 0;
      do
      {
        v10 = *(_DWORD *)(v8 + 4 * v9);
        v11 = *a1;
        v12 = *(_DWORD **)(*a1 + 8);
        v13 = *(_QWORD *)(*a1 + 16);
        if ((unint64_t)v12 >= v13)
        {
          v15 = *(_DWORD **)v11;
          v16 = ((uint64_t)v12 - *(_QWORD *)v11) >> 2;
          v17 = v16 + 1;
          if ((unint64_t)(v16 + 1) >> 62)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v18 = v13 - (_QWORD)v15;
          if (v18 >> 1 > v17)
            v17 = v18 >> 1;
          if ((unint64_t)v18 >= 0x7FFFFFFFFFFFFFFCLL)
            v19 = 0x3FFFFFFFFFFFFFFFLL;
          else
            v19 = v17;
          if (v19)
          {
            v20 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>(*a1 + 16, v19);
            v15 = *(_DWORD **)v11;
            v12 = *(_DWORD **)(v11 + 8);
          }
          else
          {
            v20 = 0;
          }
          v21 = &v20[4 * v16];
          *(_DWORD *)v21 = v10;
          v14 = v21 + 4;
          while (v12 != v15)
          {
            v22 = *--v12;
            *((_DWORD *)v21 - 1) = v22;
            v21 -= 4;
          }
          *(_QWORD *)v11 = v21;
          *(_QWORD *)(v11 + 8) = v14;
          *(_QWORD *)(v11 + 16) = &v20[4 * v19];
          if (v15)
            operator delete(v15);
        }
        else
        {
          *v12 = v10;
          v14 = v12 + 1;
        }
        *(_QWORD *)(v11 + 8) = v14;
        ++v9;
        v8 = *a2;
      }
      while (v9 < (a2[1] - *a2) >> 2);
    }
  }
  if (a3)
  {
    v23 = *a3;
    if (a3[1] != *a3)
    {
      v24 = 0;
      do
      {
        v25 = *(_QWORD *)(v23 + 8 * v24);
        v26 = a1[1];
        v27 = *(_QWORD **)(v26 + 8);
        v28 = *(_QWORD *)(v26 + 16);
        if ((unint64_t)v27 >= v28)
        {
          v30 = *(_QWORD **)v26;
          v31 = ((uint64_t)v27 - *(_QWORD *)v26) >> 3;
          v32 = v31 + 1;
          if ((unint64_t)(v31 + 1) >> 61)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v33 = v28 - (_QWORD)v30;
          if (v33 >> 2 > v32)
            v32 = v33 >> 2;
          if ((unint64_t)v33 >= 0x7FFFFFFFFFFFFFF8)
            v34 = 0x1FFFFFFFFFFFFFFFLL;
          else
            v34 = v32;
          if (v34)
          {
            v35 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<double>>(v26 + 16, v34);
            v30 = *(_QWORD **)v26;
            v27 = *(_QWORD **)(v26 + 8);
          }
          else
          {
            v35 = 0;
          }
          v36 = &v35[8 * v31];
          *(_QWORD *)v36 = v25;
          v29 = v36 + 8;
          while (v27 != v30)
          {
            v37 = *--v27;
            *((_QWORD *)v36 - 1) = v37;
            v36 -= 8;
          }
          *(_QWORD *)v26 = v36;
          *(_QWORD *)(v26 + 8) = v29;
          *(_QWORD *)(v26 + 16) = &v35[8 * v34];
          if (v30)
            operator delete(v30);
        }
        else
        {
          *v27 = v25;
          v29 = v27 + 1;
        }
        *(_QWORD *)(v26 + 8) = v29;
        ++v24;
        v23 = *a3;
      }
      while (v24 < (a3[1] - *a3) >> 3);
    }
  }
  return a1;
}

char *std::vector<ProbIndex>::__assign_with_size[abi:ne180100]<ProbIndex*,ProbIndex*>(char *result, char *__src, uint64_t a3, unint64_t a4)
{
  _QWORD *v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  unint64_t v11;
  void **v12;
  char *v13;
  _BYTE *v14;
  unint64_t v15;
  char *v16;
  size_t v17;
  void *v18;
  char *v19;

  v7 = result;
  v8 = *((_QWORD *)result + 2);
  v9 = *(char **)result;
  if (a4 > (v8 - *(_QWORD *)result) >> 4)
  {
    if (v9)
    {
      *((_QWORD *)result + 1) = v9;
      operator delete(v9);
      v8 = 0;
      *v7 = 0;
      v7[1] = 0;
      v7[2] = 0;
    }
    if (a4 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 3;
    if (v8 >> 3 <= a4)
      v10 = a4;
    if ((unint64_t)v8 >= 0x7FFFFFFFFFFFFFF0)
      v11 = 0xFFFFFFFFFFFFFFFLL;
    else
      v11 = v10;
    result = std::vector<ProbIndex>::__vallocate[abi:ne180100](v7, v11);
    v13 = (char *)v7[1];
    v12 = (void **)(v7 + 1);
    v9 = v13;
LABEL_16:
    v17 = a3 - (_QWORD)__src;
    if (v17)
    {
      v18 = v9;
      v19 = __src;
      goto LABEL_18;
    }
    goto LABEL_19;
  }
  v12 = (void **)(result + 8);
  v14 = (_BYTE *)*((_QWORD *)result + 1);
  v15 = (v14 - v9) >> 4;
  if (v15 >= a4)
    goto LABEL_16;
  v16 = &__src[16 * v15];
  if (v14 != v9)
  {
    result = (char *)memmove(*(void **)result, __src, v14 - v9);
    v9 = (char *)*v12;
  }
  v17 = a3 - (_QWORD)v16;
  if (v17)
  {
    v18 = v9;
    v19 = v16;
LABEL_18:
    result = (char *)memmove(v18, v19, v17);
  }
LABEL_19:
  *v12 = &v9[v17];
  return result;
}

char *std::vector<ProbIndex>::__vallocate[abi:ne180100](_QWORD *a1, unint64_t a2)
{
  char *result;
  uint64_t v4;

  if (a2 >> 60)
    std::vector<double>::__throw_length_error[abi:ne180100]();
  result = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)(a1 + 2), a2);
  *a1 = result;
  a1[1] = result;
  a1[2] = &result[16 * v4];
  return result;
}

void CPMLNaiveBayesAdaptor::CPMLNaiveBayesAdaptor(CPMLNaiveBayesAdaptor *this, CPMLSerialization *a2)
{
  *((_OWORD *)this + 2) = 0u;
  *((_OWORD *)this + 3) = 0u;
  *((_DWORD *)this + 16) = 1065353216;
  *(_OWORD *)((char *)this + 72) = 0u;
  *(_OWORD *)((char *)this + 88) = 0u;
  *((_DWORD *)this + 26) = 1065353216;
  *((_OWORD *)this + 7) = 0u;
  *((_OWORD *)this + 8) = 0u;
  *((_DWORD *)this + 36) = 1065353216;
  *((_QWORD *)this + 21) = 0;
  *((_QWORD *)this + 22) = 0;
  *((_QWORD *)this + 19) = 0;
  *((_QWORD *)this + 20) = 0;
  *(_QWORD *)this = &off_24C255718;
  *((_QWORD *)this + 1) = a2;
  *((_QWORD *)this + 2) = 0;
  *((_QWORD *)this + 3) = 0;
}

void CPMLNaiveBayesAdaptor::~CPMLNaiveBayesAdaptor(CPMLNaiveBayesAdaptor *this)
{
  void *v2;

  *(_QWORD *)this = &unk_24C255890;
  v2 = (void *)*((_QWORD *)this + 20);
  if (v2)
  {
    *((_QWORD *)this + 21) = v2;
    operator delete(v2);
  }
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 112);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 72);
  std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::~__hash_table((uint64_t)this + 32);
}

double CPMLNaiveBayesAdaptor::get_count(CPMLNaiveBayesAdaptor *this, double *a2)
{
  id *v4;
  char *v6;
  double v7;
  char *v8;
  char *v9;
  uint64_t v10;
  double *v11;
  double v12;

  v4 = (id *)*((_QWORD *)this + 19);
  if (v4)
  {
    v12 = -1.0;
    if (CPMLDelegateEngineNaiveBayes::preProcessGetCountAndYCardinality(v4, &v12, a2))
      return v12;
  }
  v6 = (char *)this + 16;
  if (*((double *)this + 2) <= 0.0 || (v7 = *((double *)this + 3), v7 <= 0.0))
  {
    v8 = sqlite3_mprintf("select rowCountY from rowCountY;");
    (*(void (**)(_QWORD, char *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), (char *)this + 16, v8);
    if (v8)
      sqlite3_free(v8);
    v9 = sqlite3_mprintf("select count (DISTINCT yMap) from yCount;");
    v10 = *((_QWORD *)this + 1);
    v11 = (double *)((char *)this + 24);
    (*(void (**)(uint64_t, double *, char *))(*(_QWORD *)v10 + 224))(v10, v11, v9);
    if (v9)
      sqlite3_free(v9);
    v7 = *v11;
  }
  *a2 = v7;
  return *(double *)v6;
}

void CPMLNaiveBayesAdaptor::get_cy(CPMLNaiveBayesAdaptor *this, int a2)
{
  id *v3;
  char *v4;
  int v5;
  double v6;
  unint64_t v7;
  char *v8;
  _DWORD *v9;
  char *v10;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  char *v15;
  char *v16;
  char *v17;
  int v18;
  double v19;
  int v20;
  int *v21;

  v20 = a2;
  v19 = -1.0;
  v3 = (id *)*((_QWORD *)this + 19);
  if (!v3 || !CPMLDelegateEngineNaiveBayes::preProcessGetCountY(v3, &v19, a2))
  {
    if (std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::find<int>((_QWORD *)this + 4, &v20))
    {
      v21 = &v20;
      std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 32, &v20, (uint64_t)&std::piecewise_construct, &v21);
    }
    else
    {
      v4 = sqlite3_mprintf("select yCount from yCount where yMap=%d;", v20);
      v5 = (*(uint64_t (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v19, v4);
      if (v4)
        sqlite3_free(v4);
      v6 = v19;
      if (fabs(v19) != INFINITY)
      {
        v21 = &v20;
        *((double *)std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 32, &v20, (uint64_t)&std::piecewise_construct, &v21)+ 3) = v6;
        if (v5 != 101)
        {
          v7 = *((_QWORD *)this + 22);
          v8 = (char *)*((_QWORD *)this + 21);
          if ((unint64_t)v8 >= v7)
          {
            v10 = (char *)*((_QWORD *)this + 20);
            v11 = (v8 - v10) >> 2;
            if ((unint64_t)(v11 + 1) >> 62)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v12 = v7 - (_QWORD)v10;
            v13 = (uint64_t)(v7 - (_QWORD)v10) >> 1;
            if (v13 <= v11 + 1)
              v13 = v11 + 1;
            if (v12 >= 0x7FFFFFFFFFFFFFFCLL)
              v14 = 0x3FFFFFFFFFFFFFFFLL;
            else
              v14 = v13;
            if (v14)
            {
              v15 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 176, v14);
              v10 = (char *)*((_QWORD *)this + 20);
              v8 = (char *)*((_QWORD *)this + 21);
            }
            else
            {
              v15 = 0;
            }
            v16 = &v15[4 * v11];
            v17 = &v15[4 * v14];
            *(_DWORD *)v16 = v20;
            v9 = v16 + 4;
            while (v8 != v10)
            {
              v18 = *((_DWORD *)v8 - 1);
              v8 -= 4;
              *((_DWORD *)v16 - 1) = v18;
              v16 -= 4;
            }
            *((_QWORD *)this + 20) = v16;
            *((_QWORD *)this + 21) = v9;
            *((_QWORD *)this + 22) = v17;
            if (v10)
              operator delete(v10);
          }
          else
          {
            *(_DWORD *)v8 = v20;
            v9 = v8 + 4;
          }
          *((_QWORD *)this + 21) = v9;
        }
      }
    }
  }
}

double CPMLNaiveBayesAdaptor::get_cx_given_y(CPMLNaiveBayesAdaptor *this, int a2, int a3, int a4, double *a5)
{
  id *v10;
  double result;
  char *v12;
  char *v13;
  unint64_t v14;
  double v15;

  v14 = 0xBFF0000000000000;
  v15 = -1.0;
  v10 = (id *)*((_QWORD *)this + 19);
  if (v10 && CPMLDelegateEngineNaiveBayes::preProcessGetCountXGivenYAndSetXCardinality(v10, &v15, a2, a3, a4, a5))
    return v15;
  v12 = sqlite3_mprintf("select xCardinality from xCardinality%d where yMap=%d;", a2, a4);
  (*(void (**)(_QWORD, unint64_t *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v14, v12);
  if (v12)
    sqlite3_free(v12);
  if (fabs(v15) == INFINITY)
    goto LABEL_10;
  *(_QWORD *)a5 = v14;
  v13 = sqlite3_mprintf("select xyCount from xcol%d where (xMap==%d and yMap==%d);", a2, a3, a4);
  (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v15, v13);
  if (v13)
    sqlite3_free(v13);
  result = v15;
  if (fabs(v15) == INFINITY)
  {
LABEL_10:
    *a5 = 0.0;
    return -2.0;
  }
  return result;
}

void CPMLNaiveBayesAdaptor::set_count(CPMLNaiveBayesAdaptor *this, double a2)
{
  id *v4;
  char *v5;
  char *v6;
  char *v7;
  double v8;

  v4 = (id *)*((_QWORD *)this + 19);
  if (!v4 || !CPMLDelegateEngineNaiveBayes::preProcessSetCount(v4, a2))
  {
    v8 = 1.0;
    v5 = sqlite3_mprintf("select count(*) from rowCountY;");
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v8, v5);
    if (v5)
      sqlite3_free(v5);
    if (v8 == 0.0)
    {
      v6 = sqlite3_mprintf("insert into rowCountY (rowCountY) VALUES(0.0);", v8);
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v8, v6);
      if (v6)
        sqlite3_free(v6);
    }
    v7 = sqlite3_mprintf("update rowCountY set rowCountY=%lf;", a2);
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v8, v7);
    if (v7)
      sqlite3_free(v7);
    *((double *)this + 2) = a2;
  }
}

void CPMLNaiveBayesAdaptor::set_cy(CPMLNaiveBayesAdaptor *this, int a2, double a3)
{
  id *v6;
  char *v7;
  char *v8;
  unint64_t v9;
  int *v10;
  _DWORD *v11;
  int *v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  char *v17;
  int *v18;
  char *v19;
  int v20;
  char *v21;
  char *v22;
  double v23;
  int v24;
  int *v25;

  v24 = a2;
  v6 = (id *)*((_QWORD *)this + 19);
  if (!v6 || !CPMLDelegateEngineNaiveBayes::preProcessSetCountY(v6, a2, a3))
  {
    v23 = 1.0;
    v7 = sqlite3_mprintf("select count(*) from yCount where yMap=%d;", a2);
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v23, v7);
    if (v7)
      sqlite3_free(v7);
    if (v23 == 0.0)
    {
      v8 = sqlite3_mprintf("insert into yCount (yMap, yCount) VALUES(%d, 0.0);", a2);
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v23, v8);
      if (v8)
        sqlite3_free(v8);
      v9 = *((_QWORD *)this + 22);
      *((double *)this + 3) = *((double *)this + 3) + 1.0;
      v10 = (int *)*((_QWORD *)this + 21);
      if ((unint64_t)v10 >= v9)
      {
        v12 = (int *)*((_QWORD *)this + 20);
        v13 = v10 - v12;
        if ((unint64_t)(v13 + 1) >> 62)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v14 = v9 - (_QWORD)v12;
        v15 = (uint64_t)(v9 - (_QWORD)v12) >> 1;
        if (v15 <= v13 + 1)
          v15 = v13 + 1;
        if (v14 >= 0x7FFFFFFFFFFFFFFCLL)
          v16 = 0x3FFFFFFFFFFFFFFFLL;
        else
          v16 = v15;
        if (v16)
        {
          v17 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<int>>((uint64_t)this + 176, v16);
          v12 = (int *)*((_QWORD *)this + 20);
          v10 = (int *)*((_QWORD *)this + 21);
        }
        else
        {
          v17 = 0;
        }
        v18 = (int *)&v17[4 * v13];
        v19 = &v17[4 * v16];
        *v18 = a2;
        v11 = v18 + 1;
        while (v10 != v12)
        {
          v20 = *--v10;
          *--v18 = v20;
        }
        *((_QWORD *)this + 20) = v18;
        *((_QWORD *)this + 21) = v11;
        *((_QWORD *)this + 22) = v19;
        if (v12)
          operator delete(v12);
      }
      else
      {
        *v10 = a2;
        v11 = v10 + 1;
      }
      *((_QWORD *)this + 21) = v11;
    }
    if (fabs(a3) == INFINITY)
      v21 = sqlite3_mprintf("update yCount set yCount=NULL where yMap=%d;");
    else
      v21 = sqlite3_mprintf("update yCount set yCount=%lf where yMap=%d;");
    v22 = v21;
    v25 = &v24;
    *((double *)std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::__emplace_unique_key_args<int,std::piecewise_construct_t const&,std::tuple<int const&>,std::tuple<>>((uint64_t)this + 32, &v24, (uint64_t)&std::piecewise_construct, &v25)+ 3) = a3;
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v23, v22);
    if (v22)
      sqlite3_free(v22);
  }
}

void CPMLNaiveBayesAdaptor::set_cx_given_y(CPMLNaiveBayesAdaptor *this, int a2, uint64_t a3, unsigned int a4, double a5)
{
  id *v10;
  char *v11;
  char *v12;
  char *v13;
  char *v14;
  char *v15;
  unint64_t v16;
  double v17;
  unint64_t *v18;

  v10 = (id *)*((_QWORD *)this + 19);
  if (!v10 || !CPMLDelegateEngineNaiveBayes::preProcessSetCountXGivenY(v10, a2, a3, a4, a5))
  {
    v16 = a4 | (unint64_t)(a3 << 32);
    v17 = 1.0;
    v11 = sqlite3_mprintf("select count(*) from xcol%d where (xMap=%d and yMap=%d);", a2, a3, a4);
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v17, v11);
    if (v11)
      sqlite3_free(v11);
    if (v17 == 0.0)
    {
      if (fabs(a5) == INFINITY)
        v12 = sqlite3_mprintf("insert into xcol%d (xMap, yMap, xyCount) VALUES(%d, %d, NULL);");
      else
        v12 = sqlite3_mprintf("insert into xcol%d (xMap, yMap, xyCount) VALUES(%d, %d, %lf);");
      v14 = v12;
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v17, v12);
      if (v14)
        sqlite3_free(v14);
    }
    else
    {
      if (fabs(a5) == INFINITY)
        v13 = sqlite3_mprintf("update xcol%d set xyCount=NULL where (xMap=%d and yMap=%d);");
      else
        v13 = sqlite3_mprintf("update xcol%d set xyCount=%lf where (xMap=%d and yMap=%d);");
      v15 = v13;
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v17, v13);
      if (v15)
        sqlite3_free(v15);
      v18 = &v16;
      *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 72, &v16, (uint64_t)&std::piecewise_construct, &v18)+ 3) = a5;
    }
  }
}

void CPMLNaiveBayesAdaptor::set_cardinalityx_given_y(CPMLNaiveBayesAdaptor *this, int a2, int a3, double a4)
{
  id *v8;
  char *v9;
  char *v10;
  char *v11;
  char *v12;
  unint64_t v13;
  double v14;
  unint64_t *v15;

  v8 = (id *)*((_QWORD *)this + 19);
  if (!v8 || !CPMLDelegateEngineNaiveBayes::preProcessSetCardinalityXGivenY(v8, a2, a3, a4))
  {
    v14 = 1.0;
    v9 = sqlite3_mprintf("select count(*) from xcol%d where yMap=%d;", a2, a3);
    (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v14, v9);
    if (v9)
      sqlite3_free(v9);
    if (v14 == 0.0)
    {
      if (fabs(a4) == INFINITY)
        v10 = sqlite3_mprintf("insert into xCardinality%d (yMap, xCardinality) VALUES(%d, NULL);");
      else
        v10 = sqlite3_mprintf("insert into xCardinality%d (yMap, xCardinality) VALUES(%d, %lf);");
      v12 = v10;
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v14, v10);
      if (v12)
LABEL_12:
        sqlite3_free(v12);
    }
    else
    {
      if (fabs(a4) == INFINITY)
        v11 = sqlite3_mprintf("update xCardinality%d set xCardinality=NULL where yMap=%d;");
      else
        v11 = sqlite3_mprintf("update xCardinality%d set xCardinality=%lf where yMap=%d;");
      v12 = v11;
      (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v14, v11);
      v13 = a3;
      v15 = &v13;
      *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t)this + 112, &v13, (uint64_t)&std::piecewise_construct, &v15)+ 3) = a4;
      if (v12)
        goto LABEL_12;
    }
  }
}

uint64_t CPMLNaiveBayesAdaptor::set_engine(uint64_t this, CPMLDelegateEngine *a2)
{
  *(_QWORD *)(this + 152) = a2;
  return this;
}

uint64_t *std::__hash_table<std::__hash_value_type<int,double>,std::__unordered_map_hasher<int,std::__hash_value_type<int,double>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,double>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,double>>>::find<int>(_QWORD *a1, int *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  uint64_t **v6;
  uint64_t *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (*(_QWORD *)&v2 <= v3)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(uint64_t ***)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  for (result = *v6; result; result = (uint64_t *)*result)
  {
    v8 = result[1];
    if (v8 == v3)
    {
      if (*((_DWORD *)result + 4) == (_DWORD)v3)
        return result;
    }
    else
    {
      if (v4.u32[0] > 1uLL)
      {
        if (v8 >= *(_QWORD *)&v2)
          v8 %= *(_QWORD *)&v2;
      }
      else
      {
        v8 &= *(_QWORD *)&v2 - 1;
      }
      if (v8 != v5)
        return 0;
    }
  }
  return result;
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>(uint64_t a1, unint64_t *a2, uint64_t a3, _QWORD **a4)
{
  unint64_t v4;
  unint64_t v7;
  unint64_t v8;
  uint8x8_t v9;
  _QWORD **v10;
  _QWORD *i;
  unint64_t v12;
  float v13;
  float v14;
  _BOOL8 v15;
  unint64_t v16;
  unint64_t v17;
  size_t v18;
  uint64_t v19;
  _QWORD *v20;
  unint64_t v21;

  v7 = *a2;
  v8 = *(_QWORD *)(a1 + 8);
  if (v8)
  {
    v9 = (uint8x8_t)vcnt_s8((int8x8_t)v8);
    v9.i16[0] = vaddlv_u8(v9);
    if (v9.u32[0] > 1uLL)
    {
      v4 = *a2;
      if (v7 >= v8)
        v4 = v7 % v8;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
    v10 = *(_QWORD ***)(*(_QWORD *)a1 + 8 * v4);
    if (v10)
    {
      for (i = *v10; i; i = (_QWORD *)*i)
      {
        v12 = i[1];
        if (v12 == v7)
        {
          if (i[2] == v7)
            return i;
        }
        else
        {
          if (v9.u32[0] > 1uLL)
          {
            if (v12 >= v8)
              v12 %= v8;
          }
          else
          {
            v12 &= v8 - 1;
          }
          if (v12 != v4)
            break;
        }
      }
    }
  }
  i = operator new(0x20uLL);
  *i = 0;
  i[1] = v7;
  i[2] = **a4;
  i[3] = 0;
  v13 = (float)(unint64_t)(*(_QWORD *)(a1 + 24) + 1);
  v14 = *(float *)(a1 + 32);
  if (!v8 || (float)(v14 * (float)v8) < v13)
  {
    v15 = 1;
    if (v8 >= 3)
      v15 = (v8 & (v8 - 1)) != 0;
    v16 = v15 | (2 * v8);
    v17 = vcvtps_u32_f32(v13 / v14);
    if (v16 <= v17)
      v18 = v17;
    else
      v18 = v16;
    std::__hash_table<std::__hash_value_type<int,int>,std::__unordered_map_hasher<int,std::__hash_value_type<int,int>,std::hash<int>,std::equal_to<int>,true>,std::__unordered_map_equal<int,std::__hash_value_type<int,int>,std::equal_to<int>,std::hash<int>,true>,std::allocator<std::__hash_value_type<int,int>>>::__rehash<true>(a1, v18);
    v8 = *(_QWORD *)(a1 + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v7 >= v8)
        v4 = v7 % v8;
      else
        v4 = v7;
    }
    else
    {
      v4 = (v8 - 1) & v7;
    }
  }
  v19 = *(_QWORD *)a1;
  v20 = *(_QWORD **)(*(_QWORD *)a1 + 8 * v4);
  if (v20)
  {
    *i = *v20;
LABEL_38:
    *v20 = i;
    goto LABEL_39;
  }
  *i = *(_QWORD *)(a1 + 16);
  *(_QWORD *)(a1 + 16) = i;
  *(_QWORD *)(v19 + 8 * v4) = a1 + 16;
  if (*i)
  {
    v21 = *(_QWORD *)(*i + 8);
    if ((v8 & (v8 - 1)) != 0)
    {
      if (v21 >= v8)
        v21 %= v8;
    }
    else
    {
      v21 &= v8 - 1;
    }
    v20 = (_QWORD *)(*(_QWORD *)a1 + 8 * v21);
    goto LABEL_38;
  }
LABEL_39:
  ++*(_QWORD *)(a1 + 24);
  return i;
}

void sub_209CF44D0(_Unwind_Exception *a1)
{
  void *v1;

  operator delete(v1);
  _Unwind_Resume(a1);
}

void CPMLNaiveBayes::CPMLNaiveBayes(CPMLNaiveBayes *this)
{
  *(_QWORD *)this = &off_24C2553F0;
  *((_QWORD *)this + 7) = 0;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 8) = _Q0;
  *(_OWORD *)((char *)this + 24) = xmmword_209D009F0;
}

uint64_t CPMLNaiveBayes::set_decay_rate(uint64_t this, double a2)
{
  if (a2 <= 0.0)
    CPMLNaiveBayes::set_decay_rate();
  if (a2 > 1.0)
    CPMLNaiveBayes::set_decay_rate();
  *(double *)(this + 8) = a2;
  *(double *)(this + 16) = 1.0 / a2;
  return this;
}

uint64_t CPMLNaiveBayes::set_epsilon_rate(uint64_t this, double a2)
{
  if (a2 < 0.0)
    CPMLNaiveBayes::set_epsilon_rate();
  *(double *)(this + 24) = a2;
  return this;
}

uint64_t CPMLNaiveBayes::set_smooth_rate(uint64_t this, double a2)
{
  if (a2 < 0.0)
    CPMLNaiveBayes::set_smooth_rate();
  *(double *)(this + 32) = a2;
  return this;
}

void CPMLNaiveBayes::CPMLNaiveBayes(CPMLNaiveBayes *this, CPMLNaiveBayesDBAdaptor *a2)
{
  *(_QWORD *)this = &off_24C2553F0;
  if (!a2)
    CPMLNaiveBayes::CPMLNaiveBayes();
  *((_QWORD *)this + 7) = a2;
  *((_QWORD *)this + 8) = 0;
  *((_QWORD *)this + 6) = 0;
  __asm { FMOV            V0.2D, #1.0 }
  *(_OWORD *)((char *)this + 8) = _Q0;
  *(_OWORD *)((char *)this + 24) = xmmword_209D009F0;
  *((_DWORD *)this + 10) = 0;
}

uint64_t CPMLNaiveBayes::set_smooth_mode(uint64_t this, int a2)
{
  *(_DWORD *)(this + 40) = a2;
  return this;
}

void CPMLNaiveBayes::~CPMLNaiveBayes(CPMLNaiveBayes *this)
{
  uint64_t v1;
  void *v2;

  *(_QWORD *)this = &off_24C2553F0;
  v1 = *((_QWORD *)this + 6);
  if (v1)
  {
    v2 = *(void **)v1;
    if (*(_QWORD *)v1)
    {
      *(_QWORD *)(v1 + 8) = v2;
      operator delete(v2);
    }
    MEMORY[0x20BD188E4](v1, 0x20C40960023A9);
  }
}

uint64_t CPMLNaiveBayes::set_engine(uint64_t this, CPMLDelegateEngine *a2)
{
  *(_QWORD *)(this + 64) = a2;
  return this;
}

double CPMLNaiveBayes::get_nb_probability(CPMLNaiveBayes *a1, _QWORD *a2, uint64_t a3, double a4, double a5, double a6)
{
  double v6;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _BYTE *v15;
  unint64_t v16;
  uint64_t v17;
  double v18;
  _BOOL4 v19;
  void *__p;
  _BYTE *v22;
  uint64_t v23;

  if (a4 >= a6)
  {
    v6 = a4;
    if ((int)(-1431655765 * ((uint64_t)(a2[1] - *a2) >> 3)) < 1)
      return v6;
    v12 = 0;
    v13 = -1431655765 * ((uint64_t)(a2[1] - *a2) >> 3);
    while (1)
    {
      v14 = *a2 + 24 * v12;
      v22 = 0;
      v23 = 0;
      __p = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&__p, *(const void **)v14, *(_QWORD *)(v14 + 8), (uint64_t)(*(_QWORD *)(v14 + 8) - *(_QWORD *)v14) >> 2);
      v15 = v22;
      if (v22 == __p)
      {
        v19 = 0;
        if (!v22)
          goto LABEL_13;
      }
      else
      {
        v16 = 0;
        v15 = __p;
        do
        {
          v17 = *(unsigned int *)&v15[4 * v16];
          if ((_DWORD)v17 != -1)
          {
            CPMLNaiveBayes::get_px_given_y(a1, v12, v17, a3, a5);
            v6 = v6 * v18;
            v15 = __p;
          }
          v19 = v6 < a6;
          if (v6 < a6)
            break;
          ++v16;
        }
        while (v16 < (v22 - v15) >> 2);
        if (!v15)
          goto LABEL_13;
      }
      v22 = v15;
      operator delete(v15);
LABEL_13:
      if (v19)
        return 0.0;
      if (++v12 == v13)
        return v6;
    }
  }
  return 0.0;
}

void sub_209CF4788(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

uint64_t CPMLNaiveBayes::get_px_given_y(CPMLNaiveBayes *this, uint64_t a2, uint64_t a3, uint64_t a4, double a5)
{
  uint64_t v6;

  v6 = 0;
  return (*(uint64_t (**)(_QWORD, uint64_t, uint64_t, uint64_t, uint64_t *))(**((_QWORD **)this + 7) + 16))(*((_QWORD *)this + 7), a2, a3, a4, &v6);
}

void CPMLNaiveBayes::sort_candidates(uint64_t a1, unsigned int **a2, uint64_t a3)
{
  unsigned int *v6;
  unsigned int *v7;
  unsigned int v8;
  double v9;
  double v10;
  unint64_t v11;
  unint64_t v12;
  double *v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t v17;
  char *v18;
  char *v19;
  double *v20;
  double *v21;
  char *v22;
  unint64_t v23;
  uint64_t v24;
  char v25;

  std::vector<ProbIndex>::resize(a3, 0);
  v6 = *a2;
  v7 = a2[1];
  if (*a2 == v7)
  {
    v13 = *(double **)(a3 + 8);
  }
  else
  {
    do
    {
      v8 = *v6;
      v9 = (*(double (**)(_QWORD, _QWORD))(**(_QWORD **)(a1 + 56) + 8))(*(_QWORD *)(a1 + 56), *v6);
      v10 = v9;
      v11 = *(_QWORD *)(a3 + 8);
      v12 = *(_QWORD *)(a3 + 16);
      if (v11 >= v12)
      {
        v14 = (uint64_t)(v11 - *(_QWORD *)a3) >> 4;
        v15 = v14 + 1;
        if ((unint64_t)(v14 + 1) >> 60)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v16 = v12 - *(_QWORD *)a3;
        if (v16 >> 3 > v15)
          v15 = v16 >> 3;
        if ((unint64_t)v16 >= 0x7FFFFFFFFFFFFFF0)
          v17 = 0xFFFFFFFFFFFFFFFLL;
        else
          v17 = v15;
        if (v17)
          v18 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(a3 + 16, v17);
        else
          v18 = 0;
        v19 = &v18[16 * v14];
        *(double *)v19 = v10;
        *((_DWORD *)v19 + 2) = v8;
        *((_DWORD *)v19 + 3) = 0;
        v21 = *(double **)a3;
        v20 = *(double **)(a3 + 8);
        v22 = v19;
        if (v20 != *(double **)a3)
        {
          do
          {
            *((_OWORD *)v22 - 1) = *((_OWORD *)v20 - 1);
            v22 -= 16;
            v20 -= 2;
          }
          while (v20 != v21);
          v20 = *(double **)a3;
        }
        v13 = (double *)(v19 + 16);
        *(_QWORD *)a3 = v22;
        *(_QWORD *)(a3 + 8) = v19 + 16;
        *(_QWORD *)(a3 + 16) = &v18[16 * v17];
        if (v20)
          operator delete(v20);
      }
      else
      {
        *(double *)v11 = v9;
        v13 = (double *)(v11 + 16);
        *(_DWORD *)(v11 + 8) = v8;
        *(_DWORD *)(v11 + 12) = 0;
      }
      *(_QWORD *)(a3 + 8) = v13;
      ++v6;
    }
    while (v6 != v7);
  }
  v23 = 126 - 2 * __clz(((uint64_t)v13 - *(_QWORD *)a3) >> 4);
  if (v13 == *(double **)a3)
    v24 = 0;
  else
    v24 = v23;
  std::__introsort<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *,false>(*(double **)a3, v13, (uint64_t)&v25, v24, 1);
}

void std::vector<ProbIndex>::resize(uint64_t a1, unint64_t a2)
{
  unint64_t v2;

  v2 = (uint64_t)(*(_QWORD *)(a1 + 8) - *(_QWORD *)a1) >> 4;
  if (a2 <= v2)
  {
    if (a2 < v2)
      *(_QWORD *)(a1 + 8) = *(_QWORD *)a1 + 16 * a2;
  }
  else
  {
    std::vector<ProbIndex>::__append((void **)a1, a2 - v2);
  }
}

void CPMLNaiveBayes::set_candidates(uint64_t a1, unsigned int **a2)
{
  _QWORD *v4;

  v4 = *(_QWORD **)(a1 + 48);
  if (!v4)
  {
    v4 = (_QWORD *)operator new();
    v4[1] = 0;
    v4[2] = 0;
    *v4 = 0;
    *(_QWORD *)(a1 + 48) = v4;
  }
  CPMLNaiveBayes::sort_candidates(a1, a2, (uint64_t)v4);
}

void CPMLNaiveBayes::predict(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 48);
  if (v6)
    (**(void (***)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))a1)(a1, a2, v6, a3, a4);
  else
    std::vector<ProbIndex>::resize(a4, 0);
}

void CPMLNaiveBayes::predict(void (***a1)(_QWORD, uint64_t, void **, uint64_t, uint64_t), uint64_t a2, unsigned int **a3, uint64_t a4, uint64_t a5)
{
  void *__p;
  void *v10;
  uint64_t v11;

  __p = 0;
  v10 = 0;
  v11 = 0;
  CPMLNaiveBayes::sort_candidates((uint64_t)a1, a3, (uint64_t)&__p);
  (**a1)(a1, a2, &__p, a4, a5);
  if (__p)
  {
    v10 = __p;
    operator delete(__p);
  }
}

void sub_209CF4B04(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void CPMLNaiveBayes::predict_sorted(uint64_t a1, uint64_t *a2, uint64_t *a3, int a4, _QWORD *a5)
{
  id *v9;
  double v10;
  uint64_t v11;
  uint64_t v12;
  double v13;
  double v14;
  double v15;
  double v16;
  double v17;
  double nb_probability;
  double v19;
  int v20;
  uint64_t v21;
  _BYTE *v22;
  uint64_t v23;
  unint64_t v24;
  uint64_t v25;
  _OWORD *v26;
  _OWORD *v27;
  unint64_t v28;
  uint64_t v29;
  unint64_t v30;
  char *v31;
  uint64_t v32;
  unint64_t v33;
  uint64_t v34;
  unint64_t v35;
  char *v36;
  double *v37;
  char *v38;
  char *v39;
  double *v40;
  double *v41;
  char *v42;
  char *v43;
  double *v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _BYTE *v48;
  double *v49;
  double *v50;
  double *v51;
  double v52;
  void *__p;
  double *v54;
  _QWORD v55[2];
  _QWORD v56[3];
  char v57;
  __int128 v58;

  memset(v56, 0, sizeof(v56));
  v9 = *(id **)(a1 + 64);
  if (v9)
  {
    if (CPMLDelegateEngineNaiveBayes::preProcessPredictSorted(v9, a2, v56))
      goto LABEL_67;
  }
  else if (v56 != a2)
  {
    std::vector<std::vector<int>>::__assign_with_size[abi:ne180100]<std::vector<int>*,std::vector<int>*>((uint64_t)v56, *a2, a2[1], 0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3));
  }
  __p = 0;
  v54 = 0;
  v55[0] = 0;
  v52 = 0.0;
  (***(void (****)(_QWORD, double *))(a1 + 56))(*(_QWORD *)(a1 + 56), &v52);
  v11 = *a3;
  v12 = a3[1];
  if (*a3 != v12)
  {
    v13 = v10;
    v14 = 0.0;
    do
    {
      v15 = *(double *)v11;
      if (*(_DWORD *)(a1 + 40))
      {
        v16 = 0.001;
        if (v15 != 0.0)
          v16 = v15 / v13;
      }
      else
      {
        v17 = v52;
        if (v15 == 0.0)
          v17 = v52 + 1.0;
        v16 = (v15 + *(double *)(a1 + 32)) / (v13 + (*(double *)(a1 + 32) + *(double *)(a1 + 24)) * v17);
      }
      nb_probability = CPMLNaiveBayes::get_nb_probability((CPMLNaiveBayes *)a1, v56, *(unsigned int *)(v11 + 8), v16, v15, v14);
      v19 = nb_probability;
      v20 = *(_DWORD *)(v11 + 8);
      v22 = __p;
      v21 = (uint64_t)v54;
      v23 = (char *)v54 - (_BYTE *)__p;
      v24 = ((char *)v54 - (_BYTE *)__p) >> 4;
      if (v24 >= a4)
      {
        v14 = *(double *)__p;
        if (nb_probability > *(double *)__p)
        {
          if (v23 >= 17)
          {
            v58 = *(_OWORD *)__p;
            std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)__p, (uint64_t)&v57, (unint64_t)v23 >> 4);
            v27 = (_OWORD *)(v21 - 16);
            if ((_OWORD *)(v21 - 16) == v26)
            {
              *v26 = v58;
            }
            else
            {
              *v26 = *v27;
              *v27 = v58;
              std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)v22, (uint64_t)(v26 + 1), (uint64_t)&v57, ((char *)(v26 + 1) - v22) >> 4);
            }
            v21 = (uint64_t)v54;
          }
          v54 = (double *)(v21 - 16);
          if ((unint64_t)(v21 - 16) >= v55[0])
          {
            v32 = (v21 - 16 - (uint64_t)__p) >> 4;
            v33 = v32 + 1;
            if ((unint64_t)(v32 + 1) >> 60)
              std::vector<double>::__throw_length_error[abi:ne180100]();
            v34 = v55[0] - (_QWORD)__p;
            if ((uint64_t)(v55[0] - (_QWORD)__p) >> 3 > v33)
              v33 = v34 >> 3;
            if ((unint64_t)v34 >= 0x7FFFFFFFFFFFFFF0)
              v35 = 0xFFFFFFFFFFFFFFFLL;
            else
              v35 = v33;
            if (v35)
              v36 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)v55, v35);
            else
              v36 = 0;
            v41 = (double *)&v36[16 * v32];
            *v41 = v19;
            *((_DWORD *)v41 + 2) = v20;
            *((_DWORD *)v41 + 3) = 0;
            v43 = (char *)__p;
            v42 = (char *)v54;
            v44 = v41;
            if (v54 != __p)
            {
              do
              {
                *((_OWORD *)v44 - 1) = *((_OWORD *)v42 - 1);
                v44 -= 2;
                v42 -= 16;
              }
              while (v42 != v43);
              v42 = (char *)__p;
            }
            v21 = (uint64_t)(v41 + 2);
            __p = v44;
            v54 = v41 + 2;
            v55[0] = &v36[16 * v35];
            if (v42)
              operator delete(v42);
          }
          else
          {
            *(double *)(v21 - 16) = v19;
            *(_DWORD *)(v21 - 8) = v20;
            *(_DWORD *)(v21 - 4) = 0;
          }
          v54 = (double *)v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)__p, v21, (uint64_t)&v58, (v21 - (uint64_t)__p) >> 4);
          v14 = v19;
        }
      }
      else if (nb_probability > *(double *)(a1 + 24))
      {
        if ((unint64_t)v54 >= v55[0])
        {
          v28 = v24 + 1;
          if ((v24 + 1) >> 60)
            std::vector<double>::__throw_length_error[abi:ne180100]();
          v29 = v55[0] - (_QWORD)__p;
          if ((uint64_t)(v55[0] - (_QWORD)__p) >> 3 > v28)
            v28 = v29 >> 3;
          if ((unint64_t)v29 >= 0x7FFFFFFFFFFFFFF0)
            v30 = 0xFFFFFFFFFFFFFFFLL;
          else
            v30 = v28;
          if (v30)
            v31 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>((uint64_t)v55, v30);
          else
            v31 = 0;
          v37 = (double *)&v31[16 * v24];
          *v37 = v19;
          *((_DWORD *)v37 + 2) = v20;
          *((_DWORD *)v37 + 3) = 0;
          v39 = (char *)__p;
          v38 = (char *)v54;
          v40 = v37;
          if (v54 != __p)
          {
            do
            {
              *((_OWORD *)v40 - 1) = *((_OWORD *)v38 - 1);
              v40 -= 2;
              v38 -= 16;
            }
            while (v38 != v39);
            v38 = (char *)__p;
          }
          v25 = (uint64_t)(v37 + 2);
          __p = v40;
          v54 = v37 + 2;
          v55[0] = &v31[16 * v30];
          if (v38)
            operator delete(v38);
        }
        else
        {
          *v54 = nb_probability;
          v25 = v21 + 16;
          *(_DWORD *)(v21 + 8) = v20;
          *(_DWORD *)(v21 + 12) = 0;
        }
        v54 = (double *)v25;
        std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)__p, v25, (uint64_t)&v58, (v25 - (uint64_t)__p) >> 4);
      }
      v11 += 16;
    }
    while (v11 != v12);
  }
  v45 = (char *)v54 - (_BYTE *)__p;
  std::vector<ProbIndex>::resize((uint64_t)a5, (int)(((char *)v54 - (_BYTE *)__p) >> 4));
  if ((int)(v45 >> 4) >= 1)
  {
    v46 = (v45 >> 4);
    v47 = (v45 >> 4 << 32) - 0x100000000;
    do
    {
      *(_OWORD *)(*a5 + (v47 >> 28)) = *(_OWORD *)__p;
      v48 = __p;
      v49 = v54;
      if ((char *)v54 - (_BYTE *)__p >= 17)
      {
        v58 = *(_OWORD *)__p;
        std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)__p, (uint64_t)&v57, (unint64_t)((char *)v54 - (_BYTE *)__p) >> 4);
        v51 = v49 - 2;
        if (v49 - 2 == v50)
        {
          *(_OWORD *)v50 = v58;
        }
        else
        {
          *(_OWORD *)v50 = *(_OWORD *)v51;
          *(_OWORD *)v51 = v58;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)v48, (uint64_t)(v50 + 2), (uint64_t)&v57, ((char *)(v50 + 2) - v48) >> 4);
        }
        v49 = v54;
      }
      v54 = v49 - 2;
      v47 -= 0x100000000;
      --v46;
    }
    while (v46);
  }
  if (__p)
  {
    v54 = (double *)__p;
    operator delete(__p);
  }
LABEL_67:
  __p = v56;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
}

void sub_209CF4FD0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, char *__p, uint64_t a12, uint64_t a13, uint64_t a14, char a15)
{
  __p = &a15;
  std::vector<std::vector<int>>::__destroy_vector::operator()[abi:ne180100]((void ***)&__p);
  _Unwind_Resume(a1);
}

uint64_t CPMLNaiveBayes::update(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  id *v6;
  uint64_t result;
  uint64_t v8;
  unint64_t v9;
  unsigned int *v10;
  unint64_t v11;
  double v12;
  uint64_t v13;
  double v14;
  uint64_t v15;
  double v16;
  double v17;
  unsigned int *v18;
  unsigned int *v19;
  uint64_t v20;

  v6 = *(id **)(a1 + 64);
  if (!v6 || (result = CPMLDelegateEngineNaiveBayes::preProcessUpdateNaiveBayes(v6, a2, a3), (result & 1) == 0))
  {
    v8 = *a2;
    if (a2[1] != *a2)
    {
      v9 = 0;
      do
      {
        v18 = 0;
        v19 = 0;
        v20 = 0;
        std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(&v18, *(const void **)(v8 + 24 * v9), *(_QWORD *)(v8 + 24 * v9 + 8), (uint64_t)(*(_QWORD *)(v8 + 24 * v9 + 8) - *(_QWORD *)(v8 + 24 * v9)) >> 2);
        v10 = v19;
        if (v19 != v18)
        {
          v11 = 0;
          v10 = v18;
          do
          {
            v17 = 0.0;
            v12 = (*(double (**)(_QWORD, unint64_t, _QWORD, uint64_t, double *))(**(_QWORD **)(a1 + 56)
                                                                                                + 16))(*(_QWORD *)(a1 + 56), v9, v10[v11], a3, &v17);
            if (v12 == 0.0)
              (*(void (**)(_QWORD, unint64_t, uint64_t, double))(**(_QWORD **)(a1 + 56) + 48))(*(_QWORD *)(a1 + 56), v9, a3, v17 + 1.0);
            (*(void (**)(_QWORD, unint64_t, _QWORD, uint64_t, double))(**(_QWORD **)(a1 + 56) + 40))(*(_QWORD *)(a1 + 56), v9, v18[v11++], a3, v12 + *(double *)(a1 + 16));
            v10 = v18;
          }
          while (v11 < v19 - v18);
        }
        if (v10)
        {
          v19 = v10;
          operator delete(v10);
        }
        ++v9;
        v8 = *a2;
      }
      while (0xAAAAAAAAAAAAAAABLL * ((a2[1] - *a2) >> 3) > v9);
    }
    v13 = *(_QWORD *)(a1 + 56);
    v14 = (*(double (**)(uint64_t, uint64_t))(*(_QWORD *)v13 + 8))(v13, a3);
    (*(void (**)(uint64_t, uint64_t, double))(*(_QWORD *)v13 + 32))(v13, a3, v14 + *(double *)(a1 + 16));
    v18 = 0;
    v15 = *(_QWORD *)(a1 + 56);
    v16 = (**(double (***)(uint64_t, void **))v15)(v15, (void **)&v18);
    return (*(uint64_t (**)(uint64_t, double))(*(_QWORD *)v15 + 24))(v15, v16 + *(double *)(a1 + 16));
  }
  return result;
}

void sub_209CF51F8(_Unwind_Exception *exception_object, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, void *__p, uint64_t a11)
{
  if (__p)
    operator delete(__p);
  _Unwind_Resume(exception_object);
}

void std::vector<ProbIndex>::__append(void **a1, unint64_t a2)
{
  uint64_t v4;
  _BYTE *v5;
  _BYTE *v6;
  char *v7;
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  char *v14;
  char *v15;
  char *v16;
  char *v17;
  char *v18;

  v6 = a1[2];
  v4 = (uint64_t)(a1 + 2);
  v5 = v6;
  v7 = *(char **)(v4 - 8);
  if (a2 <= (v6 - v7) >> 4)
  {
    if (a2)
    {
      bzero(*(void **)(v4 - 8), 16 * a2);
      v7 += 16 * a2;
    }
    a1[1] = v7;
  }
  else
  {
    v8 = v7 - (_BYTE *)*a1;
    v9 = a2 + (v8 >> 4);
    if (v9 >> 60)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = v8 >> 4;
    v11 = v5 - (_BYTE *)*a1;
    if (v11 >> 3 > v9)
      v9 = v11 >> 3;
    if ((unint64_t)v11 >= 0x7FFFFFFFFFFFFFF0)
      v12 = 0xFFFFFFFFFFFFFFFLL;
    else
      v12 = v9;
    if (v12)
      v13 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(v4, v12);
    else
      v13 = 0;
    v14 = &v13[16 * v10];
    v15 = &v13[16 * v12];
    bzero(v14, 16 * a2);
    v16 = &v14[16 * a2];
    v18 = (char *)*a1;
    v17 = (char *)a1[1];
    if (v17 != *a1)
    {
      do
      {
        *((_OWORD *)v14 - 1) = *((_OWORD *)v17 - 1);
        v14 -= 16;
        v17 -= 16;
      }
      while (v17 != v18);
      v17 = (char *)*a1;
    }
    *a1 = v14;
    a1[1] = v16;
    a1[2] = v15;
    if (v17)
      operator delete(v17);
  }
}

void std::__introsort<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *,false>(double *a1, double *a2, uint64_t a3, uint64_t a4, char a5)
{
  double *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  __int128 *v15;
  double v16;
  unint64_t v17;
  char v18;
  BOOL v19;
  __int128 *v20;
  double v21;
  __int128 v22;
  __int128 v23;

double *std::__insertion_sort[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(double *result, double *a2)
{
  double *v2;
  uint64_t v3;
  double *v4;
  double *v5;
  double v6;
  int v7;
  int v8;
  double *v9;
  uint64_t v10;
  double v11;

  if (result != a2)
  {
    v2 = result + 2;
    if (result + 2 != a2)
    {
      v3 = 0;
      v4 = result;
      while (1)
      {
        v5 = v4;
        v4 = v2;
        v6 = v5[2];
        if (v6 > *v5)
          break;
        if (v6 == *v5)
        {
          v7 = *((_DWORD *)v5 + 6);
          if (v7 < *((_DWORD *)v5 + 2))
            goto LABEL_8;
        }
LABEL_17:
        v2 = v4 + 2;
        v3 += 16;
        if (v4 + 2 == a2)
          return result;
      }
      v7 = *((_DWORD *)v5 + 6);
LABEL_8:
      v8 = *((_DWORD *)v5 + 7);
      *(_OWORD *)v4 = *(_OWORD *)v5;
      v9 = result;
      if (v5 != result)
      {
        v10 = v3;
        do
        {
          v11 = *(double *)((char *)result + v10 - 16);
          if (v6 <= v11)
          {
            if (v6 != v11)
            {
              v9 = v5;
              goto LABEL_16;
            }
            v9 = (double *)((char *)result + v10);
            if (v7 >= *(_DWORD *)((char *)result + v10 - 8))
              goto LABEL_16;
          }
          v5 -= 2;
          *(_OWORD *)((char *)result + v10) = *(_OWORD *)((char *)result + v10 - 16);
          v10 -= 16;
        }
        while (v10);
        v9 = result;
      }
LABEL_16:
      *v9 = v6;
      *((_DWORD *)v9 + 2) = v7;
      *((_DWORD *)v9 + 3) = v8;
      goto LABEL_17;
    }
  }
  return result;
}

double *std::__insertion_sort_unguarded[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(double *result, double *a2)
{
  double *v2;
  double v3;
  int v4;
  int v5;
  double *i;
  double v7;

  if (result != a2)
  {
    while (1)
    {
      if (result + 2 == a2)
        return result;
      v2 = result;
      result += 2;
      v3 = v2[2];
      if (v3 <= *v2)
      {
        if (v3 == *v2)
        {
          v4 = *((_DWORD *)v2 + 6);
          if (v4 < *((_DWORD *)v2 + 2))
            goto LABEL_7;
        }
      }
      else
      {
        v4 = *((_DWORD *)v2 + 6);
LABEL_7:
        v5 = *((_DWORD *)v2 + 7);
        for (i = result; ; i -= 2)
        {
          *(_OWORD *)i = *((_OWORD *)i - 1);
          v7 = *(i - 4);
          if (v3 <= v7 && (v3 != v7 || v4 >= *((_DWORD *)i - 6)))
            break;
        }
        *(i - 2) = v3;
        *((_DWORD *)i - 2) = v4;
        *((_DWORD *)i - 1) = v5;
      }
    }
  }
  return result;
}

uint64_t std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(__int128 *a1, __int128 *a2, __int128 *a3)
{
  double v3;
  __int128 v4;
  __int128 v6;
  __int128 v7;
  __int128 v8;
  __int128 v9;

  v3 = *(double *)a2;
  if (*(double *)a2 > *(double *)a1 || *(double *)a2 == *(double *)a1 && *((_DWORD *)a2 + 2) < *((_DWORD *)a1 + 2))
  {
    if (*(double *)a3 > v3 || *(double *)a3 == v3 && *((_DWORD *)a3 + 2) < *((_DWORD *)a2 + 2))
    {
      v4 = *a1;
      *a1 = *a3;
      *a3 = v4;
      return 1;
    }
    v8 = *a1;
    *a1 = *a2;
    *a2 = v8;
    if (*(double *)a3 <= *(double *)a2
      && (*(double *)a3 != *(double *)a2 || *((_DWORD *)a3 + 2) >= *((_DWORD *)a2 + 2)))
    {
      return 1;
    }
    v9 = *a2;
    *a2 = *a3;
    *a3 = v9;
    return 2;
  }
  if (*(double *)a3 > v3 || *(double *)a3 == v3 && *((_DWORD *)a3 + 2) < *((_DWORD *)a2 + 2))
  {
    v6 = *a2;
    *a2 = *a3;
    *a3 = v6;
    if (*(double *)a2 <= *(double *)a1
      && (*(double *)a2 != *(double *)a1 || *((_DWORD *)a2 + 2) >= *((_DWORD *)a1 + 2)))
    {
      return 1;
    }
    v7 = *a1;
    *a1 = *a2;
    *a2 = v7;
    return 2;
  }
  return 0;
}

double *std::__partition_with_equals_on_left[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,CPMLNBCompareProbIndexDescending &>(uint64_t a1, unint64_t a2)
{
  double v2;
  uint64_t v3;
  double v4;
  double *v5;
  double v6;
  double v7;
  double v8;
  double v9;
  double v10;
  double v11;
  BOOL v12;
  __int128 v14;

  v2 = *(double *)a1;
  v3 = *(_QWORD *)(a1 + 8);
  v4 = *(double *)(a2 - 16);
  if (*(double *)a1 > v4 || *(double *)a1 == v4 && (int)v3 < *(_DWORD *)(a2 - 8))
  {
    v5 = (double *)(a1 + 16);
    v6 = *(double *)(a1 + 16);
    if (v2 <= v6)
    {
      do
      {
        if (v2 == v6 && (int)v3 < *((_DWORD *)v5 + 2))
          break;
        v7 = v5[2];
        v5 += 2;
        v6 = v7;
      }
      while (v2 <= v7);
    }
  }
  else
  {
    v5 = (double *)(a1 + 16);
    if (a1 + 16 < a2)
    {
      do
      {
        if (v2 > *v5 || v2 == *v5 && (int)v3 < *((_DWORD *)v5 + 2))
          break;
        v5 += 2;
      }
      while ((unint64_t)v5 < a2);
    }
  }
  if ((unint64_t)v5 < a2)
  {
    for (a2 -= 16; v2 > v4 || v2 == v4 && (int)v3 < *(_DWORD *)(a2 + 8); a2 -= 16)
    {
      v8 = *(double *)(a2 - 16);
      v4 = v8;
    }
  }
  while ((unint64_t)v5 < a2)
  {
    v14 = *(_OWORD *)v5;
    *(_OWORD *)v5 = *(_OWORD *)a2;
    *(_OWORD *)a2 = v14;
    do
    {
      v9 = v5[2];
      v5 += 2;
      v10 = v9;
    }
    while (v2 <= v9 && (v2 != v10 || (int)v3 >= *((_DWORD *)v5 + 2)));
    do
    {
      do
      {
        v11 = *(double *)(a2 - 16);
        a2 -= 16;
        v12 = v2 == v11;
      }
      while (v2 > v11);
    }
    while (v12 && (int)v3 < *(_DWORD *)(a2 + 8));
  }
  if (v5 - 2 != (double *)a1)
    *(_OWORD *)a1 = *((_OWORD *)v5 - 1);
  *(v5 - 2) = v2;
  *((_QWORD *)v5 - 1) = v3;
  return v5;
}

unint64_t std::__partition_with_equals_on_right[abi:ne180100]<std::_ClassicAlgPolicy,ProbIndex *,CPMLNBCompareProbIndexDescending &>(uint64_t a1, unint64_t a2)
{
  uint64_t v2;
  double v3;
  uint64_t v4;
  double v5;
  unint64_t v6;
  double v7;
  double v8;
  double v9;
  double v10;
  unint64_t v12;
  unint64_t v13;
  double v14;
  BOOL v15;
  double v16;
  double v17;
  __int128 v19;

  v2 = 0;
  v3 = *(double *)a1;
  v4 = *(_QWORD *)(a1 + 8);
  while (1)
  {
    v5 = *(double *)(a1 + v2 + 16);
    if (v5 <= v3 && (v5 != v3 || *(_DWORD *)(a1 + v2 + 24) >= (int)v4))
      break;
    v2 += 16;
  }
  v6 = a1 + v2 + 16;
  if (v2)
  {
    do
    {
      v7 = *(double *)(a2 - 16);
      a2 -= 16;
      v8 = v7;
    }
    while (v7 <= v3 && (v8 != v3 || *(_DWORD *)(a2 + 8) >= (int)v4));
  }
  else
  {
LABEL_19:
    if (v6 < a2)
    {
      do
      {
        v9 = *(double *)(a2 - 16);
        a2 -= 16;
        v10 = v9;
        if (v9 > v3)
          break;
        if (v10 != v3)
          goto LABEL_19;
      }
      while (*(_DWORD *)(a2 + 8) >= (int)v4 && v6 < a2);
    }
  }
  v12 = a1 + v2 + 16;
  if (v6 < a2)
  {
    v13 = a2;
    do
    {
      v19 = *(_OWORD *)v12;
      *(_OWORD *)v12 = *(_OWORD *)v13;
      *(_OWORD *)v13 = v19;
      do
      {
        do
        {
          v14 = *(double *)(v12 + 16);
          v12 += 16;
          v15 = v14 == v3;
        }
        while (v14 > v3);
      }
      while (v15 && *(_DWORD *)(v12 + 8) < (int)v4);
      do
      {
        v16 = *(double *)(v13 - 16);
        v13 -= 16;
        v17 = v16;
      }
      while (v16 <= v3 && (v17 != v3 || *(_DWORD *)(v13 + 8) >= (int)v4));
    }
    while (v12 < v13);
  }
  if (v12 - 16 != a1)
    *(_OWORD *)a1 = *(_OWORD *)(v12 - 16);
  *(double *)(v12 - 16) = v3;
  *(_QWORD *)(v12 - 8) = v4;
  return v12 - 16;
}

BOOL std::__insertion_sort_incomplete[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(uint64_t a1, uint64_t a2)
{
  uint64_t v4;
  _BOOL8 result;
  __int128 *v6;
  double v7;
  __int128 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  double v13;
  int v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  double v18;

  v4 = (a2 - a1) >> 4;
  result = 1;
  switch(v4)
  {
    case 0:
    case 1:
      return result;
    case 2:
      v6 = (__int128 *)(a2 - 16);
      v7 = *(double *)(a2 - 16);
      if (v7 > *(double *)a1 || v7 == *(double *)a1 && *(_DWORD *)(a2 - 8) < *(_DWORD *)(a1 + 8))
      {
        v8 = *(_OWORD *)a1;
        *(_OWORD *)a1 = *v6;
        *v6 = v8;
      }
      return result;
    case 3:
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)a1, (__int128 *)(a1 + 16), (__int128 *)(a2 - 16));
      return 1;
    case 4:
      std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(a1, a1 + 16, a1 + 32, a2 - 16);
      return 1;
    case 5:
      std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__n128 *)a1, (__n128 *)(a1 + 16), (__n128 *)(a1 + 32), (__n128 *)(a1 + 48), (__n128 *)(a2 - 16));
      return 1;
    default:
      v9 = a1 + 32;
      std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)a1, (__int128 *)(a1 + 16), (__int128 *)(a1 + 32));
      v10 = a1 + 48;
      if (a1 + 48 == a2)
        return 1;
      v11 = 0;
      v12 = 0;
      break;
  }
  while (1)
  {
    v13 = *(double *)v10;
    if (*(double *)v10 > *(double *)v9)
      break;
    if (*(double *)v10 == *(double *)v9)
    {
      v14 = *(_DWORD *)(v10 + 8);
      if (v14 < *(_DWORD *)(v9 + 8))
        goto LABEL_12;
    }
LABEL_22:
    v9 = v10;
    v11 += 16;
    v10 += 16;
    if (v10 == a2)
      return 1;
  }
  v14 = *(_DWORD *)(v10 + 8);
LABEL_12:
  v15 = *(_DWORD *)(v10 + 12);
  *(_OWORD *)v10 = *(_OWORD *)v9;
  v16 = a1;
  if (v9 != a1)
  {
    v17 = v11;
    while (1)
    {
      v18 = *(double *)(a1 + v17 + 16);
      if (v13 <= v18)
      {
        if (v13 != v18)
        {
          v16 = v9;
          goto LABEL_21;
        }
        if (v14 >= *(_DWORD *)(a1 + v17 + 24))
          break;
      }
      v9 -= 16;
      *(_OWORD *)(a1 + v17 + 32) = *(_OWORD *)(a1 + v17 + 16);
      v17 -= 16;
      if (v17 == -32)
      {
        v16 = a1;
        goto LABEL_21;
      }
    }
    v16 = a1 + v17 + 32;
  }
LABEL_21:
  *(double *)v16 = v13;
  *(_DWORD *)(v16 + 8) = v14;
  *(_DWORD *)(v16 + 12) = v15;
  if (++v12 != 8)
    goto LABEL_22;
  return v10 + 16 == a2;
}

__n128 std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __n128 result;

  std::__sort3[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((__int128 *)a1, (__int128 *)a2, (__int128 *)a3);
  result.n128_u64[0] = *(_QWORD *)a4;
  if (*(double *)a4 > *(double *)a3 || *(double *)a4 == *(double *)a3 && *(_DWORD *)(a4 + 8) < *(_DWORD *)(a3 + 8))
  {
    result = *(__n128 *)a3;
    *(_OWORD *)a3 = *(_OWORD *)a4;
    *(__n128 *)a4 = result;
    result.n128_u64[0] = *(_QWORD *)a3;
    if (*(double *)a3 > *(double *)a2 || *(double *)a3 == *(double *)a2 && *(_DWORD *)(a3 + 8) < *(_DWORD *)(a2 + 8))
    {
      result = *(__n128 *)a2;
      *(_OWORD *)a2 = *(_OWORD *)a3;
      *(__n128 *)a3 = result;
      result.n128_u64[0] = *(_QWORD *)a2;
      if (*(double *)a2 > *(double *)a1 || *(double *)a2 == *(double *)a1 && *(_DWORD *)(a2 + 8) < *(_DWORD *)(a1 + 8))
      {
        result = *(__n128 *)a1;
        *(_OWORD *)a1 = *(_OWORD *)a2;
        *(__n128 *)a2 = result;
      }
    }
  }
  return result;
}

__n128 std::__sort5[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(__n128 *a1, __n128 *a2, __n128 *a3, __n128 *a4, __n128 *a5)
{
  __n128 result;

  std::__sort4[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>((uint64_t)a1, (uint64_t)a2, (uint64_t)a3, (uint64_t)a4);
  result.n128_u64[0] = a5->n128_u64[0];
  if (a5->n128_f64[0] > a4->n128_f64[0]
    || a5->n128_f64[0] == a4->n128_f64[0] && (signed __int32)a5->n128_u32[2] < (signed __int32)a4->n128_u32[2])
  {
    result = *a4;
    *a4 = *a5;
    *a5 = result;
    result.n128_u64[0] = a4->n128_u64[0];
    if (a4->n128_f64[0] > a3->n128_f64[0]
      || a4->n128_f64[0] == a3->n128_f64[0] && (signed __int32)a4->n128_u32[2] < (signed __int32)a3->n128_u32[2])
    {
      result = *a3;
      *a3 = *a4;
      *a4 = result;
      result.n128_u64[0] = a3->n128_u64[0];
      if (a3->n128_f64[0] > a2->n128_f64[0]
        || a3->n128_f64[0] == a2->n128_f64[0] && (signed __int32)a3->n128_u32[2] < (signed __int32)a2->n128_u32[2])
      {
        result = *a2;
        *a2 = *a3;
        *a3 = result;
        result.n128_u64[0] = a2->n128_u64[0];
        if (a2->n128_f64[0] > a1->n128_f64[0]
          || a2->n128_f64[0] == a1->n128_f64[0] && (signed __int32)a2->n128_u32[2] < (signed __int32)a1->n128_u32[2])
        {
          result = *a1;
          *a1 = *a2;
          *a2 = result;
        }
      }
    }
  }
  return result;
}

__int128 *std::__partial_sort_impl[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *,ProbIndex *>(uint64_t a1, __int128 *a2, __int128 *a3, uint64_t a4)
{
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  __int128 *v13;
  __int128 *v14;
  __int128 v15;
  uint64_t v16;
  __int128 *v17;
  __int128 *v18;
  __int128 v21;

  if ((__int128 *)a1 != a2)
  {
    v8 = (uint64_t)a2 - a1;
    v9 = ((uint64_t)a2 - a1) >> 4;
    if ((uint64_t)a2 - a1 >= 17)
    {
      v10 = (unint64_t)(v9 - 2) >> 1;
      v11 = v10 + 1;
      v12 = a1 + 16 * v10;
      do
      {
        std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(a1, a4, v9, v12);
        v12 -= 16;
        --v11;
      }
      while (v11);
    }
    v13 = a2;
    if (a2 != a3)
    {
      v14 = a2;
      do
      {
        if (*(double *)v14 > *(double *)a1
          || *(double *)v14 == *(double *)a1 && *((_DWORD *)v14 + 2) < *(_DWORD *)(a1 + 8))
        {
          v15 = *v14;
          *v14 = *(_OWORD *)a1;
          *(_OWORD *)a1 = v15;
          std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(a1, a4, v9, a1);
        }
        ++v14;
      }
      while (v14 != a3);
      v13 = a3;
    }
    if (v8 >= 17)
    {
      v16 = (unint64_t)v8 >> 4;
      v17 = a2 - 1;
      do
      {
        v21 = *(_OWORD *)a1;
        std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(a1, a4, v16);
        if (v17 == v18)
        {
          *v18 = v21;
        }
        else
        {
          *v18 = *v17;
          *v17 = v21;
          std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(a1, (uint64_t)(v18 + 1), a4, ((uint64_t)v18 - a1 + 16) >> 4);
        }
        --v17;
      }
      while (v16-- > 2);
    }
    return v13;
  }
  return a3;
}

uint64_t std::__sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  int64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  double v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  double v17;

  if (a3 >= 2)
  {
    v4 = a4 - result;
    v5 = (unint64_t)(a3 - 2) >> 1;
    if (v5 >= (a4 - result) >> 4)
    {
      v6 = v4 >> 3;
      v7 = (v4 >> 3) + 1;
      v8 = result + 16 * v7;
      v9 = v6 + 2;
      if (v9 < a3)
      {
        v10 = *(double *)(v8 + 16);
        if (*(double *)v8 > v10 || *(double *)v8 == v10 && *(_DWORD *)(result + 16 * v7 + 8) < *(_DWORD *)(v8 + 24))
        {
          v8 += 16;
          v7 = v9;
        }
      }
      v11 = *(double *)a4;
      if (*(double *)v8 <= *(double *)a4)
      {
        if (*(double *)v8 == *(double *)a4)
        {
          v12 = *(_DWORD *)(a4 + 8);
          if (*(_DWORD *)(v8 + 8) < v12)
            return result;
        }
        else
        {
          v12 = *(_DWORD *)(a4 + 8);
        }
        v13 = *(_DWORD *)(a4 + 12);
        *(_OWORD *)a4 = *(_OWORD *)v8;
        if (v5 >= v7)
        {
          while (1)
          {
            v15 = 2 * v7;
            v7 = (2 * v7) | 1;
            v14 = result + 16 * v7;
            v16 = v15 + 2;
            if (v16 < a3)
            {
              v17 = *(double *)(v14 + 16);
              if (*(double *)v14 > v17
                || *(double *)v14 == v17 && *(_DWORD *)(result + 16 * v7 + 8) < *(_DWORD *)(v14 + 24))
              {
                v14 += 16;
                v7 = v16;
              }
            }
            if (*(double *)v14 > v11 || *(double *)v14 == v11 && *(_DWORD *)(v14 + 8) < v12)
              break;
            *(_OWORD *)v8 = *(_OWORD *)v14;
            v8 = v14;
            if (v5 < v7)
              goto LABEL_24;
          }
        }
        v14 = v8;
LABEL_24:
        *(double *)v14 = v11;
        *(_DWORD *)(v14 + 8) = v12;
        *(_DWORD *)(v14 + 12) = v13;
      }
    }
  }
  return result;
}

__n128 std::__floyd_sift_down[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _OWORD *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  double v10;
  __n128 result;

  v3 = 0;
  v4 = a3 - 2;
  if (a3 < 2)
    v4 = a3 - 1;
  v5 = v4 >> 1;
  do
  {
    v6 = (_OWORD *)a1;
    v7 = v3 + 1;
    a1 += 16 * (v3 + 1);
    v8 = 2 * v3;
    v3 = (2 * v3) | 1;
    v9 = v8 + 2;
    if (v9 < a3)
    {
      v10 = *(double *)(a1 + 16);
      if (*(double *)a1 > v10 || *(double *)a1 == v10 && SDWORD2(v6[v7]) < *(_DWORD *)(a1 + 24))
      {
        a1 += 16;
        v3 = v9;
      }
    }
    result = *(__n128 *)a1;
    *v6 = *(_OWORD *)a1;
  }
  while (v3 <= v5);
  return result;
}

uint64_t std::__sift_up[abi:ne180100]<std::_ClassicAlgPolicy,CPMLNBCompareProbIndexDescending &,ProbIndex *>(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  double *v6;
  double v7;
  int v8;
  int v9;
  double *v10;
  unint64_t v11;

  v4 = a4 - 2;
  if (a4 >= 2)
  {
    v5 = v4 >> 1;
    v6 = (double *)(result + 16 * (v4 >> 1));
    v7 = *(double *)(a2 - 16);
    if (*v6 <= v7)
    {
      if (*v6 != v7)
        return result;
      v8 = *(_DWORD *)(a2 - 8);
      if (*(_DWORD *)(result + 16 * v5 + 8) >= v8)
        return result;
    }
    else
    {
      v8 = *(_DWORD *)(a2 - 8);
    }
    v9 = *(_DWORD *)(a2 - 4);
    *(_OWORD *)(a2 - 16) = *(_OWORD *)v6;
    if (v4 >= 2)
    {
      while (1)
      {
        v11 = v5 - 1;
        v5 = (v5 - 1) >> 1;
        v10 = (double *)(result + 16 * v5);
        if (*v10 <= v7 && (*v10 != v7 || *(_DWORD *)(result + 16 * v5 + 8) >= v8))
          break;
        *(_OWORD *)v6 = *(_OWORD *)v10;
        v6 = (double *)(result + 16 * v5);
        if (v11 <= 1)
          goto LABEL_12;
      }
    }
    v10 = v6;
LABEL_12:
    *v10 = v7;
    *((_DWORD *)v10 + 2) = v8;
    *((_DWORD *)v10 + 3) = v9;
  }
  return result;
}

void std::vector<std::vector<int>>::__assign_with_size[abi:ne180100]<std::vector<int>*,std::vector<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4)
{
  uint64_t v8;
  char *v9;
  unint64_t v10;
  unint64_t v11;
  _QWORD *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *v18;
  void *v19;
  char v20;
  char v21;

  v8 = a1 + 16;
  v9 = *(char **)a1;
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) < a4)
  {
    std::vector<std::vector<int>>::__vdeallocate((uint64_t *)a1);
    if (a4 > 0xAAAAAAAAAAAAAAALL)
      std::vector<double>::__throw_length_error[abi:ne180100]();
    v10 = 0x5555555555555556 * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3);
    if (v10 <= a4)
      v10 = a4;
    if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 16) - *(_QWORD *)a1) >> 3) >= 0x555555555555555)
      v11 = 0xAAAAAAAAAAAAAAALL;
    else
      v11 = v10;
    std::vector<std::vector<int>>::__vallocate[abi:ne180100]((_QWORD *)a1, v11);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<int>>,std::vector<int>*,std::vector<int>*,std::vector<int>*>(v8, a2, a3, *(_QWORD **)(a1 + 8));
    goto LABEL_11;
  }
  if (0xAAAAAAAAAAAAAAABLL * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3) < a4)
  {
    v13 = a2 + 8 * ((uint64_t)(*(_QWORD *)(a1 + 8) - (_QWORD)v9) >> 3);
    std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<int> *,std::vector<int> *,std::vector<int> *>((int)&v20, a2, v13, v9);
    v12 = std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<int>>,std::vector<int>*,std::vector<int>*,std::vector<int>*>(v8, v13, a3, *(_QWORD **)(a1 + 8));
LABEL_11:
    *(_QWORD *)(a1 + 8) = v12;
    return;
  }
  std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<int> *,std::vector<int> *,std::vector<int> *>((int)&v21, a2, a3, v9);
  v15 = v14;
  v16 = *(_QWORD *)(a1 + 8);
  if (v16 != v14)
  {
    v17 = *(_QWORD *)(a1 + 8);
    do
    {
      v19 = *(void **)(v17 - 24);
      v17 -= 24;
      v18 = v19;
      if (v19)
      {
        *(_QWORD *)(v16 - 16) = v18;
        operator delete(v18);
      }
      v16 = v17;
    }
    while (v17 != v15);
  }
  *(_QWORD *)(a1 + 8) = v15;
}

void sub_209CF64E4(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void sub_209CF64EC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  *(_QWORD *)(v1 + 8) = v2;
  _Unwind_Resume(a1);
}

void std::vector<std::vector<int>>::__vdeallocate(uint64_t *a1)
{
  if (*a1)
  {
    std::vector<std::vector<int>>::__clear[abi:ne180100](a1);
    operator delete((void *)*a1);
    *a1 = 0;
    a1[1] = 0;
    a1[2] = 0;
  }
}

_QWORD *std::__uninitialized_allocator_copy_impl[abi:ne180100]<std::allocator<std::vector<int>>,std::vector<int>*,std::vector<int>*,std::vector<int>*>(uint64_t a1, uint64_t a2, uint64_t a3, _QWORD *a4)
{
  _QWORD *v4;
  uint64_t v6;
  _QWORD v8[3];
  char v9;
  _QWORD *v10;
  _QWORD *v11;

  v4 = a4;
  v10 = a4;
  v11 = a4;
  v8[0] = a1;
  v8[1] = &v10;
  v8[2] = &v11;
  v9 = 0;
  if (a2 != a3)
  {
    v6 = a2;
    do
    {
      *v4 = 0;
      v4[1] = 0;
      v4[2] = 0;
      std::vector<int>::__init_with_size[abi:ne180100]<int *,int *>(v4, *(const void **)v6, *(_QWORD *)(v6 + 8), (uint64_t)(*(_QWORD *)(v6 + 8) - *(_QWORD *)v6) >> 2);
      v4 = v11 + 3;
      v11 += 3;
      v6 += 24;
    }
    while (v6 != a3);
  }
  v9 = 1;
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)v8);
  return v4;
}

void sub_209CF65C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>>::~__exception_guard_exceptions[abi:ne180100]((uint64_t)&a9);
  _Unwind_Resume(a1);
}

uint64_t std::__exception_guard_exceptions<std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>>::~__exception_guard_exceptions[abi:ne180100](uint64_t a1)
{
  if (!*(_BYTE *)(a1 + 24))
    std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>::operator()[abi:ne180100](a1);
  return a1;
}

void std::_AllocatorDestroyRangeReverse<std::allocator<std::vector<int>>,std::vector<int>*>::operator()[abi:ne180100](uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  void *v4;
  void *v5;

  v1 = **(_QWORD **)(a1 + 16);
  v2 = **(_QWORD **)(a1 + 8);
  if (v1 != v2)
  {
    v3 = **(_QWORD **)(a1 + 16);
    do
    {
      v5 = *(void **)(v3 - 24);
      v3 -= 24;
      v4 = v5;
      if (v5)
      {
        *(_QWORD *)(v1 - 16) = v4;
        operator delete(v4);
      }
      v1 = v3;
    }
    while (v3 != v2);
  }
}

uint64_t std::__copy_loop<std::_ClassicAlgPolicy>::operator()[abi:ne180100]<std::vector<int> *,std::vector<int> *,std::vector<int> *>(int a1, uint64_t a2, uint64_t a3, char *a4)
{
  uint64_t v5;

  v5 = a2;
  if (a2 != a3)
  {
    do
    {
      if ((char *)v5 != a4)
        std::vector<int>::__assign_with_size[abi:ne180100]<int *,int *>(a4, *(char **)v5, *(_QWORD *)(v5 + 8), (uint64_t)(*(_QWORD *)(v5 + 8) - *(_QWORD *)v5) >> 2);
      v5 += 24;
      a4 += 24;
    }
    while (v5 != a3);
    return a3;
  }
  return v5;
}

void CPMLKMeans::CPMLKMeans(CPMLKMeans *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  _QWORD *v6;
  uint64_t v7;
  uint64_t v8;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *v6 = &off_24C255158;
  v7 = *((int *)a2->var0 + 30);
  v8 = *((int *)a2->var0 + 31);
  v6[16] = v8 + 1;
  v6[17] = v7;
  v6[15] = v8 + 2;
  v6[23] = 0;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  *((_QWORD *)this + 14) = -1;
  CPMLKMeans::initializeKMeans(this);
}

void sub_209CF6740(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

_QWORD *CPMLKMeans::initializeKMeans(CPMLKMeans *this)
{
  CPMLTunableData *v2;
  void *v3;
  void *v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  FILE **v8;
  void *v9;
  uint64_t v10;
  unint64_t v11;
  _QWORD *result;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t i;
  _QWORD *v18;
  uint64_t v19;
  uint64_t j;
  uint64_t k;

  v2 = (CPMLTunableData *)*((_QWORD *)this + 9);
  if (v2)
  {
    if ((int)CPMLTunableData::getNumberOfItems(v2) < 1)
    {
      *((_QWORD *)this + 13) = 20;
      *((_QWORD *)this + 20) = 0x3F847AE147AE147BLL;
      *((_WORD *)this + 76) = 0;
      if (*((_QWORD *)this + 14) == -1)
        *((_QWORD *)this + 14) = 2;
    }
    else
    {
      CPMLTunableData::tDataGetUInt64(*((CPMLTunableData **)this + 9), "maxIterations", (unint64_t *)this + 13);
      CPMLTunableData::tDataGetUInt64(*((CPMLTunableData **)this + 9), "kValue", (unint64_t *)this + 14);
      CPMLTunableData::tDataGetDouble(*((CPMLTunableData **)this + 9), "minConvergeValue", (double *)this + 20);
      CPMLTunableData::tDataGetBool(*((CPMLTunableData **)this + 9), "useWeightedkMeans", (BOOL *)this + 152);
      CPMLTunableData::tDataGetBool(*((CPMLTunableData **)this + 9), "useRandomCluster", (BOOL *)this + 153);
    }
  }
  v3 = malloc_type_calloc(*((_QWORD *)this + 17), 8 * *((_QWORD *)this + 15), 0x100004000313F17uLL);
  *((_QWORD *)this + 21) = v3;
  if (!v3)
    return (_QWORD *)fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s cannot initialize kMeansDataSet\n");
  v4 = malloc_type_calloc(*((_QWORD *)this + 14), 0x30uLL, 0x1080040ECFC1FCFuLL);
  *((_QWORD *)this + 22) = v4;
  if (!v4)
    return (_QWORD *)fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s cannot initialize centroidData\n");
  v5 = *((_QWORD *)this + 14);
  if (!v5)
    goto LABEL_17;
  v6 = 0;
  v7 = 0;
  v8 = (FILE **)MEMORY[0x24BDAC8D8];
  do
  {
    *(_QWORD *)(*((_QWORD *)this + 22) + v6 + 32) = malloc_type_calloc(*((_QWORD *)this + 15), 8uLL, 0x100004000313F17uLL);
    v9 = malloc_type_calloc(*((_QWORD *)this + 15), 8uLL, 0x100004000313F17uLL);
    v10 = *((_QWORD *)this + 22) + v6;
    *(_QWORD *)(v10 + 40) = v9;
    if (*(_QWORD *)(v10 + 32))
    {
      if (v9)
        goto LABEL_12;
    }
    else
    {
      fprintf(*v8, "%s cannot initialize centroidData positionInSpace\n", "initializeKMeans");
      if (*(_QWORD *)(*((_QWORD *)this + 22) + v6 + 40))
        goto LABEL_12;
    }
    fprintf(*v8, "%s cannot initialize centroidData nextPositionInSpace\n", "initializeKMeans");
LABEL_12:
    ++v7;
    v11 = *((_QWORD *)this + 14);
    v6 += 48;
  }
  while (v7 < v11);
  v5 = 8 * v11;
LABEL_17:
  v13 = v5 + 8 * *((_QWORD *)this + 17) + 56;
  v14 = v5 + *((_QWORD *)this + 16) * v5 + 40;
  *((_QWORD *)this + 12) = v14 + v13;
  result = malloc_type_calloc(1uLL, v14 + v13, 0x73BA11F4uLL);
  *((_QWORD *)this + 5) = result;
  *result = v13 >> 3;
  result[1] = *((_QWORD *)this + 13);
  result[2] = *((_QWORD *)this + 14);
  result[3] = *((_QWORD *)this + 16);
  result[4] = *((_QWORD *)this + 17);
  result[5] = *((_QWORD *)this + 17) + 6;
  result[6] = 6;
  if (*((_QWORD *)this + 17))
  {
    v15 = 0;
    do
      result[v15++ + 6] = -2;
    while (*((_QWORD *)this + 17) > v15);
  }
  v16 = *((_QWORD *)this + 14);
  if (v16)
  {
    for (i = 0; i < v16; ++i)
    {
      result[i + result[5]] = 0;
      v16 = *((_QWORD *)this + 14);
    }
  }
  v18 = &result[v13 >> 3];
  *(double *)v18 = (double)(v14 >> 3);
  v18[1] = *((_QWORD *)this + 20);
  *((_OWORD *)v18 + 1) = xmmword_209D00A20;
  v19 = *((_QWORD *)this + 16) * v16;
  *((double *)v18 + 4) = (double)(unint64_t)(v19 + 5);
  if (v19)
  {
    for (j = 0; j != v19; ++j)
      v18[j + (unint64_t)*((double *)v18 + 3)] = 0xC010000000000000;
  }
  if (v16)
  {
    for (k = 0; k != v16; ++k)
      v18[k + (unint64_t)*((double *)v18 + 4)] = 0xC014000000000000;
  }
  return result;
}

void CPMLKMeans::CPMLKMeans(CPMLKMeans *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  _QWORD *v5;
  uint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  char v10[128];
  uint64_t v11;

  v11 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  *v5 = &off_24C255158;
  (*((void (**)(CPMLSerialization *, _QWORD *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, v5 + 16, "totalCols", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 136, "totalRows", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 112, "kValue", 1, 0);
  *((_QWORD *)this + 23) = 0;
  v6 = *((_QWORD *)this + 16) + 1;
  *((_QWORD *)this + 14) = -1;
  *((_QWORD *)this + 15) = v6;
  CPMLKMeans::initializeKMeans(this);
  if (*((_QWORD *)this + 14))
  {
    v7 = 0;
    v8 = 32;
    do
    {
      v9 = *(_QWORD *)(*((_QWORD *)this + 22) + v8);
      sprintf(v10, "centroid%lld", v7);
      (*((void (**)(CPMLSerialization *, uint64_t, char *, _QWORD, _QWORD))a2->var0 + 12))(a2, v9, v10, *((_QWORD *)this + 15), 0);
      ++v7;
      v8 += 48;
    }
    while (v7 < *((_QWORD *)this + 14));
  }
  (*(void (**)(_QWORD, _QWORD, const char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 80))(*((_QWORD *)this + 11), *((_QWORD *)this + 5), "modelDataInt", **((_QWORD **)this + 5), 0);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 96))(*((_QWORD *)this + 11));
}

void sub_209CF6CB0(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLKMeans::CPMLKMeans(CPMLKMeans *this, int a2, int a3, double **a4, int a5, int a6, double a7, int a8, CPMLTunableData *a9)
{
  uint64_t v18;
  CPMLMemoryIterator *v19;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, 0, a9);
  *(_QWORD *)v18 = &off_24C255158;
  *(_QWORD *)(v18 + 120) = a2 + 1;
  *(_QWORD *)(v18 + 128) = a2;
  *(_QWORD *)(v18 + 136) = a3;
  *(_QWORD *)(v18 + 104) = a6;
  *(_QWORD *)(v18 + 112) = a5;
  *(double *)(v18 + 160) = a7;
  *(_BYTE *)(v18 + 152) = a8 & 1;
  *(_BYTE *)(v18 + 153) = a8 < 0;
  CPMLKMeans::initializeKMeans((CPMLKMeans *)v18);
  v19 = (CPMLMemoryIterator *)operator new();
  CPMLMemoryIterator::CPMLMemoryIterator(v19, a2, a3, a4, a9);
  *((_QWORD *)this + 23) = v19;
  *((_QWORD *)this + 10) = v19;
}

void sub_209CF6DC0(_Unwind_Exception *a1)
{
  void *v1;
  uint64_t v2;

  MEMORY[0x20BD188E4](v2, 0x10A1C40B2F27C95);
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLKMeans::~CPMLKMeans(CPMLKMeans *this)
{
  uint64_t v2;
  char *v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;

  *(_QWORD *)this = &off_24C255158;
  v2 = *((_QWORD *)this + 14);
  v3 = (char *)*((_QWORD *)this + 22);
  if (v2)
  {
    v4 = 0;
    v5 = 0;
    do
    {
      free(*(void **)&v3[v4 + 32]);
      v6 = *((_QWORD *)this + 22) + v4;
      *(_QWORD *)(v6 + 32) = 0;
      free(*(void **)(v6 + 40));
      v3 = (char *)*((_QWORD *)this + 22);
      *(_QWORD *)&v3[v4 + 40] = 0;
      ++v5;
      v4 += 48;
    }
    while (v5 < *((_QWORD *)this + 14));
  }
  free(v3);
  *((_QWORD *)this + 22) = 0;
  free(*((void **)this + 21));
  *((_QWORD *)this + 21) = 0;
  free(*((void **)this + 5));
  *((_QWORD *)this + 5) = 0;
  v7 = *((_QWORD *)this + 23);
  if (v7)
  {
    (*(void (**)(uint64_t))(*(_QWORD *)v7 + 8))(v7);
    *((_QWORD *)this + 23) = 0;
  }
  CPModelClose(this);
}

{
  CPMLKMeans::~CPMLKMeans(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLKMeans::serialize(CPMLKMeans *this)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  double *v5;
  unint64_t v6;
  char v8[128];
  uint64_t v9;

  v9 = *MEMORY[0x24BDAC8D0];
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 128, "totalCols", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 136, "totalRows", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 112, "kValue", 1, 0);
  if (*((_QWORD *)this + 14))
  {
    v2 = 0;
    v3 = 32;
    do
    {
      v4 = *(_QWORD *)(*((_QWORD *)this + 22) + v3);
      sprintf(v8, "centroid%lld", v2);
      (*(void (**)(_QWORD, uint64_t, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v4, v8, *((_QWORD *)this + 15), 0);
      ++v2;
      v3 += 48;
    }
    while (v2 < *((_QWORD *)this + 14));
  }
  v5 = (double *)(*((_QWORD *)this + 5) + 8 * **((_QWORD **)this + 5));
  v6 = (unint64_t)*v5;
  (*(void (**)(_QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11));
  (*(void (**)(_QWORD, double *, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), v5, "modelDataReal", v6, 0);
  return 0;
}

uint64_t CPMLKMeans::train(CPMLKMeans *this)
{
  uint64_t v2;
  uint64_t v3;
  CPMLFeatureVector *v4;
  uint64_t v5;
  unint64_t v6;
  int **IntVector;
  int *v8;
  uint64_t v9;
  unint64_t v10;
  double *v11;
  int v12;
  uint64_t RealVector;
  uint64_t *v14;
  uint64_t v15;
  unint64_t v16;
  _QWORD *v17;
  uint64_t v18;
  double YHat;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unint64_t v23;
  uint64_t v24;
  char *v25;
  unsigned int v26;
  unint64_t v27;
  unint64_t i;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  _QWORD *v34;
  uint64_t *v35;
  uint64_t v36;
  _QWORD *v37;
  uint64_t v38;
  unint64_t v39;
  double v40;
  uint64_t v41;
  void **v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t NearestCentroid;
  uint64_t v49;
  double *v50;
  double v51;
  unint64_t v52;
  double v53;
  double v54;
  double v55;
  double v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  double *v61;
  _QWORD *v62;
  _QWORD *v63;
  uint64_t *v64;
  unint64_t v65;
  uint64_t v66;
  FILE **v67;
  unint64_t v68;
  uint64_t v69;
  uint64_t v70;
  double *v71;
  uint64_t v72;
  uint64_t *v73;
  uint64_t *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t *v78;
  uint64_t *v79;
  uint64_t *v80;
  uint64_t v81;
  uint64_t v82;
  _QWORD v84[2];

  v84[1] = *MEMORY[0x24BDAC8D0];
  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    v4 = (CPMLFeatureVector *)v2;
    v5 = 0;
    v6 = 0;
    while (1)
    {
      IntVector = (int **)CPMLFeatureVector::getIntVector(v4);
      v8 = *IntVector;
      v9 = (char *)IntVector[1] - (char *)*IntVector;
      if (v9)
      {
        v10 = v9 >> 2;
        if (v10 <= 1)
          v10 = 1;
        v11 = (double *)(*((_QWORD *)this + 21) + *((_QWORD *)this + 15) * v5);
        do
        {
          v12 = *v8++;
          *v11++ = (double)v12;
          --v10;
        }
        while (v10);
      }
      RealVector = CPMLFeatureVector::getRealVector(v4);
      v14 = *(uint64_t **)RealVector;
      v15 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
      if (v15)
      {
        v16 = v15 >> 3;
        if (v16 <= 1)
          v16 = 1;
        v17 = (_QWORD *)(*((_QWORD *)this + 21)
                       + 8
                       * (*((_QWORD *)this + 15) * v6
                        + ((unint64_t)((char *)IntVector[1] - (char *)*IntVector) >> 2)));
        do
        {
          v18 = *v14++;
          *v17++ = v18;
          --v16;
        }
        while (v16);
      }
      YHat = CPMLFeatureVector::getYHat(v4);
      v20 = *((_QWORD *)this + 15);
      v21 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
      v22 = (char *)IntVector[1] - (char *)*IntVector;
      v23 = v20 * v6 + (v21 >> 3) + (v22 >> 2);
      *(double *)(*((_QWORD *)this + 21) + 8 * v23) = YHat;
      if (v23 > *((_QWORD *)this + 17) * v20)
        break;
      ++v6;
      v4 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
      v5 += 8;
      if (!v4)
        goto LABEL_17;
    }
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "Index access beyond allocated. %d : %d : %d : %d\n", v6, *((_QWORD *)this + 16), v21 >> 3, v22 >> 2);
    return 0xFFFFFFFFLL;
  }
  v6 = 0;
LABEL_17:
  if (*((_QWORD *)this + 14) > v6)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "kMeans %s cannot have more centroid than training rows\n", "train");
    return 0xFFFFFFFFLL;
  }
  MEMORY[0x24BDAC7A8](0, v3);
  v25 = (char *)v84 - ((v24 + 15) & 0xFFFFFFFFFFFFFFF0);
  v26 = time(0);
  srand(v26);
  v27 = *((_QWORD *)this + 14);
  if (v27)
  {
    for (i = 0; i < v27; ++i)
    {
      if (*((_BYTE *)this + 153))
        v29 = rand() % v6;
      else
        v29 = v6 / v27 * i;
      v30 = *((_QWORD *)this + 16);
      v31 = *((_QWORD *)this + 22);
      if (v30)
      {
        v32 = v31 + 48 * i;
        v33 = *(uint64_t **)(v32 + 32);
        v34 = *(_QWORD **)(v32 + 40);
        v35 = (uint64_t *)(*((_QWORD *)this + 21) + 8 * v29 * *((_QWORD *)this + 15));
        do
        {
          *v33++ = *v35;
          v36 = *v35++;
          *v34++ = v36;
          --v30;
        }
        while (v30);
      }
      v37 = (_QWORD *)(v31 + 48 * i);
      *v37 = 0xBFF0000000000000;
      v37[3] = 0;
      *(_QWORD *)&v25[8 * i] = v29;
      v27 = *((_QWORD *)this + 14);
      if (i && v27 < v6)
      {
        v38 = 0;
        while (*(_QWORD *)&v25[8 * v38] != v29)
        {
          if (i == ++v38)
            goto LABEL_34;
        }
        --i;
      }
LABEL_34:
      ;
    }
  }
  v39 = 0;
  v40 = 0.0;
  do
  {
    if (v27)
    {
      v41 = *((_QWORD *)this + 16);
      v42 = (void **)(*((_QWORD *)this + 22) + 40);
      v43 = v27;
      do
      {
        *(v42 - 4) = 0;
        *(v42 - 3) = 0;
        *(v42 - 2) = 0;
        if (v41)
          bzero(*v42, 8 * v41);
        v42 += 6;
        --v43;
      }
      while (v43);
    }
    v44 = *((_QWORD *)this + 17);
    if (v44)
    {
      v45 = 0;
      v46 = *((_QWORD *)this + 21);
      v47 = *((_QWORD *)this + 15);
      do
      {
        NearestCentroid = CPMLKMeans::findNearestCentroid(this, (double *)(v46 + 8 * v47 * v45));
        v47 = *((_QWORD *)this + 15);
        v46 = *((_QWORD *)this + 21);
        v49 = *((_QWORD *)this + 22);
        *(double *)(v46 + 8 * (*((_QWORD *)this + 16) + v47 * v45)) = (double)NearestCentroid;
        *(double *)(v49 + 48 * NearestCentroid + 24) = *(double *)(v49 + 48 * NearestCentroid + 24) + 1.0;
        ++v45;
        v44 = *((_QWORD *)this + 17);
      }
      while (v44 > v45);
      v27 = *((_QWORD *)this + 14);
    }
    if (v27)
    {
      v50 = (double *)*((_QWORD *)this + 22);
      v51 = 0.0;
      v52 = v27;
      do
      {
        v53 = v50[3];
        if (v53 == 0.0)
          v54 = *((double *)this + 20);
        else
          v54 = v50[1] / v53;
        *v50 = v54;
        v50 += 6;
        v51 = v51 + v54;
        --v52;
      }
      while (v52);
    }
    else
    {
      v51 = 0.0;
    }
    v55 = vabdd_f64(v40, v51);
    v56 = *((double *)this + 20);
    if (v55 > v56 && ++v39 < *((_QWORD *)this + 13))
    {
      if (v27)
      {
        v57 = 0;
        v58 = *((_QWORD *)this + 16);
        do
        {
          if (v58)
          {
            v59 = 0;
            v60 = *((_QWORD *)this + 22) + 48 * v57;
            v61 = (double *)(v60 + 24);
            v62 = (_QWORD *)(v60 + 40);
            v63 = (_QWORD *)(v60 + 32);
            do
            {
              if (*v61 != 0.0)
                *(double *)(*v63 + 8 * v59) = *(double *)(*v62 + 8 * v59) / *v61;
              ++v59;
            }
            while (v58 != v59);
          }
          ++v57;
        }
        while (v57 != v27);
        v56 = *((double *)this + 20);
      }
    }
    if (v55 <= v56)
      break;
    v40 = v51;
  }
  while (v39 < *((_QWORD *)this + 13));
  v64 = (uint64_t *)*((_QWORD *)this + 5);
  if (v44)
  {
    v65 = 0;
    v66 = v64[5];
    v67 = (FILE **)MEMORY[0x24BDAC8D8];
    do
    {
      v68 = (unint64_t)*(double *)(*((_QWORD *)this + 21)
                                        + 8 * (*((_QWORD *)this + 16) + *((_QWORD *)this + 15) * v65));
      if (*((_QWORD *)this + 14) <= v68)
      {
        fprintf(*v67, "%s Cluster value shouldn't be greater than kValue\n", "train");
      }
      else
      {
        v69 = *((_QWORD *)this + 5);
        *(_QWORD *)(v69 + 8 * v65 + 48) = v68;
        ++*(_QWORD *)(v69 + 8 * (v66 + v68));
      }
      ++v65;
    }
    while (v65 < *((_QWORD *)this + 17));
    v64 = (uint64_t *)*((_QWORD *)this + 5);
    v27 = *((_QWORD *)this + 14);
  }
  v70 = *v64;
  v71 = (double *)&v64[*v64];
  v71[2] = CPMLKMeans::findTotss(this, *((double **)this + 21));
  if (v27)
  {
    v72 = 0;
    v73 = &v64[(unint64_t)v71[4] + v70];
    v74 = (uint64_t *)(*((_QWORD *)this + 22) + 16);
    do
    {
      v75 = *v74;
      v74 += 6;
      v73[v72++] = v75;
    }
    while (v27 != v72);
    v76 = 0;
    v77 = *((_QWORD *)this + 16);
    v78 = &v64[(unint64_t)v71[3] + v70];
    do
    {
      if (v77)
      {
        v79 = *(uint64_t **)(*((_QWORD *)this + 22) + 48 * v76 + 32);
        v80 = v78;
        v81 = v77;
        do
        {
          v82 = *v79++;
          *v80++ = v82;
          --v81;
        }
        while (v81);
      }
      ++v76;
      v78 += v77;
    }
    while (v76 != v27);
  }
  return 0;
}

uint64_t CPMLKMeans::findNearestCentroid(CPMLKMeans *this, double *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unint64_t v5;
  uint64_t v8;
  double *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  double v14;
  double v15;
  double *v16;
  double v17;
  double *v18;
  unint64_t v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double *v24;
  uint64_t v25;
  double v26;
  uint64_t v27;
  double v28;
  _QWORD v30[2];
  uint64_t v31;
  uint64_t v32;

  v32 = *MEMORY[0x24BDAC8D0];
  v2 = *((char *)this + 152);
  v3 = *((_QWORD *)this + 16);
  v4 = *((_QWORD *)this + 14);
  v5 = v3 - v2;
  if (v3 == v2 || !v4)
  {
    fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s feature vector length %lld or kValue %lld\n", "findNearestCentroid", v5, v4);
    return 0;
  }
  else
  {
    v30[1] = v30;
    v8 = MEMORY[0x24BDAC7A8](this, a2);
    v9 = (double *)((char *)v30 - ((8 * v5 + 15) & 0xFFFFFFFFFFFFFFF0));
    v10 = *(_QWORD *)(v8 + 112);
    v31 = *(_QWORD *)(v8 + 176);
    if (v10)
    {
      v11 = 0;
      v12 = 0;
      v13 = *((unsigned __int8 *)this + 152);
      v14 = 1.79769313e308;
      v15 = 1.79769313e308;
      do
      {
        v16 = *(double **)(v31 + 48 * v11 + 32);
        memcpy((char *)v30 - ((8 * v5 + 15) & 0xFFFFFFFFFFFFFFF0), a2, 8 * v5);
        v17 = 0.0;
        v18 = a2;
        v19 = v5;
        do
        {
          v20 = *v18++;
          v21 = v20;
          v22 = *v16++;
          v17 = v17 + (v21 - v22) * (v21 - v22);
          --v19;
        }
        while (v19);
        v23 = sqrt(v17);
        if (v13)
          v23 = v23 * a2[*((_QWORD *)this + 16) - 1];
        if (v23 < v15)
        {
          v12 = v11;
          v15 = v23;
          v14 = v23 * v23;
        }
        ++v11;
      }
      while (v11 != v10);
    }
    else
    {
      v12 = 0;
      v15 = 1.79769313e308;
      v14 = 1.79769313e308;
    }
    v24 = *(double **)(v31 + 48 * v12 + 40);
    if (v5 <= 1)
      v25 = 1;
    else
      v25 = v5;
    do
    {
      v26 = *v9++;
      *v24 = v26 + *v24;
      ++v24;
      --v25;
    }
    while (v25);
    v27 = v31 + 48 * v12;
    v28 = v14 + *(double *)(v27 + 16);
    *(double *)(v27 + 8) = v15 + *(double *)(v27 + 8);
    *(double *)(v27 + 16) = v28;
  }
  return v12;
}

double CPMLKMeans::findTotss(CPMLKMeans *this, double *a2)
{
  uint64_t v4;
  size_t v5;
  uint64_t v6;
  double *v7;
  unint64_t v8;
  uint64_t v9;
  uint64_t i;
  double *v11;
  double *v12;
  uint64_t v13;
  double v14;
  double *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  double result;
  double *v20;
  double *v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  _QWORD v26[2];

  v26[1] = *MEMORY[0x24BDAC8D0];
  v4 = *((_QWORD *)this + 16) - *((char *)this + 152);
  MEMORY[0x24BDAC7A8](this, 8 * v4);
  v7 = (double *)((char *)v26 - v6);
  if (v4)
    bzero((char *)v26 - v6, v5);
  v8 = *((_QWORD *)this + 17);
  if (v8)
  {
    v9 = 0;
    for (i = 0; i != v8; ++i)
    {
      if (v4)
      {
        v11 = (double *)((char *)a2 + *((_QWORD *)this + 15) * v9);
        v12 = v7;
        v13 = v4;
        do
        {
          v14 = *v11++;
          *v12 = v14 + *v12;
          ++v12;
          --v13;
        }
        while (v13);
      }
      v9 += 8;
    }
  }
  if (v4)
  {
    v15 = v7;
    v16 = v4;
    do
    {
      *v15 = *v15 / (double)v8;
      ++v15;
      --v16;
    }
    while (v16);
  }
  if (!v8)
    return 0.0;
  v17 = 0;
  v18 = 0;
  result = 0.0;
  do
  {
    if (v4)
    {
      v20 = (double *)((char *)a2 + *((_QWORD *)this + 15) * v17);
      v21 = v7;
      v22 = v4;
      do
      {
        v23 = *v20++;
        v24 = v23;
        v25 = *v21++;
        result = result + (v24 - v25) * (v24 - v25);
        --v22;
      }
      while (v22);
    }
    ++v18;
    v17 += 8;
  }
  while (v18 != v8);
  return result;
}

uint64_t CPMLKMeans::eval(_QWORD *a1, CPMLFeatureVector *a2)
{
  double *v4;
  int **IntVector;
  int *v6;
  uint64_t v7;
  unint64_t v8;
  double *v9;
  int v10;
  uint64_t RealVector;
  uint64_t *v12;
  uint64_t v13;
  unint64_t v14;
  _QWORD *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  double v20;
  double *v21;
  double v22;
  uint64_t v23;
  double *v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;

  v4 = (double *)malloc_type_calloc(8 * a1[15], 1uLL, 0x30327CF8uLL);
  IntVector = (int **)CPMLFeatureVector::getIntVector(a2);
  v6 = *IntVector;
  v7 = (char *)IntVector[1] - (char *)*IntVector;
  if (v7)
  {
    v8 = v7 >> 2;
    if (v8 <= 1)
      v8 = 1;
    v9 = v4;
    do
    {
      v10 = *v6++;
      *v9++ = (double)v10;
      --v8;
    }
    while (v8);
  }
  RealVector = CPMLFeatureVector::getRealVector(a2);
  v12 = *(uint64_t **)RealVector;
  v13 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
  if (v13)
  {
    v14 = v13 >> 3;
    if (v14 <= 1)
      v14 = 1;
    v15 = (_QWORD *)((char *)v4 + 2 * ((char *)IntVector[1] - (char *)*IntVector));
    do
    {
      v16 = *v12++;
      *v15++ = v16;
      --v14;
    }
    while (v14);
  }
  v17 = a1[14];
  if (v17)
  {
    v18 = 0;
    v19 = 0x7FFFFFFFFFFFFFFFLL;
    v20 = 1.79769313e308;
    do
    {
      if (a1[16])
      {
        v21 = *(double **)(a1[22] + 48 * v18 + 32);
        v22 = 0.0;
        v23 = a1[16];
        v24 = v4;
        do
        {
          v25 = *v24++;
          v26 = v25;
          v27 = *v21++;
          v22 = v22 + (v26 - v27) * (v26 - v27);
          --v23;
        }
        while (v23);
      }
      else
      {
        v22 = 0.0;
      }
      v28 = sqrt(v22);
      if (v28 < v20)
      {
        v19 = v18;
        v20 = v28;
      }
      ++v18;
    }
    while (v18 != v17);
    v29 = (double)v19;
  }
  else
  {
    v29 = 9.22337204e18;
  }
  CPMLFeatureVector::setYHat((uint64_t)a2, v29);
  free(v4);
  return 0;
}

void CPMLKMeans::update(CPMLKMeans *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  fprintf((FILE *)*MEMORY[0x24BDAC8D8], "%s No Update Allowed", "update");
  __assert_rtn("update", "CPMLKMeans.cpp", 410, "0");
}

uint64_t CPMLKMeans::errorString(CPMLKMeans *this)
{
  return 0;
}

uint64_t CPMLKMeans::getModelData(CPMLKMeans *this)
{
  return *((_QWORD *)this + 5);
}

uint64_t CPMLKMeans::requireRealOnly(CPMLKMeans *this)
{
  return 1;
}

void CPMLCDB::CPMLCDB(CPMLCDB *this, sqlite3 *a2, sqlite3 *a3, CPMLTunableData *a4)
{
  this->var1 = a2;
  this->var2 = a3;
  this->var3 = 0;
  this->var4 = 0;
  this->var5 = a4;
}

void CPMLCDB::CPMLCDB(CPMLCDB *this, sqlite3 *a2, sqlite3 *a3, CPMLRemapper *a4, CPMLTunableData *a5)
{
  this->var1 = a2;
  this->var2 = a3;
  this->var3 = 0;
  this->var4 = a4;
  this->var5 = a5;
}

void CPMLCDB::~CPMLCDB(CPMLCDB *this)
{
  CPMLIterator *var3;

  var3 = this->var3;
  if (var3)
    (*(void (**)(CPMLIterator *))(*(_QWORD *)var3 + 8))(var3);
}

uint64_t CPMLCDB::getIterator(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v7;

  v7 = operator new();
  CPMLIterator::CPMLIterator(v7, a1[1], a1[2], a3, *a1, a1[4], a4, a1[5]);
  a1[3] = v7;
  return v7;
}

void sub_209CF7C24(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x10A1C4023273D81);
  _Unwind_Resume(a1);
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, int *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  return CPMLDBSerialization::do_cp_read(this, a2, a4, v8);
}

uint64_t CPMLDBSerialization::do_cp_read(CPMLDBSerialization *this, int *a2, uint64_t a3, char *__s)
{
  sqlite3 *v8;
  int v9;
  sqlite3_stmt **v10;
  uint64_t v11;
  CPMLLog *v12;
  pthread_mutex_t *CPMLLog;

  v8 = (sqlite3 *)*((_QWORD *)this + 4);
  v9 = strlen(__s);
  v10 = (sqlite3_stmt **)((char *)this + 40);
  sqlite3_prepare_v2(v8, __s, v9, v10, 0);
  if (__s)
    sqlite3_free(__s);
  if (a3)
  {
    v11 = 0;
    while (1)
    {
      v12 = (CPMLLog *)sqlite3_step(*v10);
      if ((_DWORD)v12 != 100)
        break;
      a2[v11++] = sqlite3_column_int(*v10, 0);
      if (a3 == v11)
        goto LABEL_7;
    }
    if ((_DWORD)v12 == 101)
    {
      sqlite3_finalize(*v10);
      return v11;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v12);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "do_cp_read", "Serializer: Error iterating rows\n");
      sqlite3_finalize(*v10);
      return 0xFFFFFFFFLL;
    }
  }
  else
  {
LABEL_7:
    sqlite3_finalize(*v10);
  }
  return a3;
}

uint64_t CPMLDBSerialization::cp_update_int(CPMLDBSerialization *this, uint64_t a2, char *a3, char *a4, int a5)
{
  char *v6;
  sqlite3 *v7;
  int v8;
  sqlite3_stmt **v9;
  CPMLLog *v10;
  uint64_t v11;
  pthread_mutex_t *CPMLLog;

  v6 = sqlite3_mprintf("UPDATE %q SET %q=%d where pKey=%d", a3, a4, a2, (a5 + 1));
  v7 = (sqlite3 *)*((_QWORD *)this + 4);
  v8 = strlen(v6);
  v9 = (sqlite3_stmt **)((char *)this + 40);
  sqlite3_prepare_v2(v7, v6, v8, v9, 0);
  if (v6)
    sqlite3_free(v6);
  v10 = (CPMLLog *)sqlite3_step(*v9);
  if ((_DWORD)v10 == 101)
  {
    v11 = 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_int", "Serializer: Error iterating rows\n");
    v11 = 0xFFFFFFFFLL;
  }
  sqlite3_finalize(*v9);
  return v11;
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, unsigned int *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;
  char *v9;
  sqlite3 *v10;
  int v11;
  sqlite3_stmt **v12;
  CPMLLog *v13;
  pthread_mutex_t *CPMLLog;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  v9 = v8;
  v10 = (sqlite3 *)*((_QWORD *)this + 4);
  v11 = strlen(v8);
  v12 = (sqlite3_stmt **)((char *)this + 48);
  sqlite3_prepare_v2(v10, v9, v11, v12, 0);
  if (v9)
    sqlite3_free(v9);
  if (a4)
  {
    while (1)
    {
      v13 = (CPMLLog *)sqlite3_step(*v12);
      if ((_DWORD)v13 != 100)
        break;
      *a2++ = sqlite3_column_int(*v12, 0);
      if (!--a4)
        goto LABEL_13;
    }
    if ((_DWORD)v13 == 101)
    {
      a4 = 0;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v13);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "Serializer: Error iterating rows\n");
      a4 = 0xFFFFFFFFLL;
    }
  }
LABEL_13:
  sqlite3_finalize(*v12);
  return a4;
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, sqlite3_int64 *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  return CPMLDBSerialization::do_cp_read(this, a2, a4, v8);
}

uint64_t CPMLDBSerialization::do_cp_read(CPMLDBSerialization *this, sqlite3_int64 *a2, uint64_t a3, char *__s)
{
  sqlite3 *v8;
  int v9;
  sqlite3_stmt **v10;
  CPMLLog *v11;
  int v12;
  pthread_mutex_t *CPMLLog;

  v8 = (sqlite3 *)*((_QWORD *)this + 4);
  v9 = strlen(__s);
  v10 = (sqlite3_stmt **)((char *)this + 56);
  sqlite3_prepare_v2(v8, __s, v9, v10, 0);
  if (__s)
    sqlite3_free(__s);
  if (a3)
  {
    while (1)
    {
      v11 = (CPMLLog *)sqlite3_step(*v10);
      if ((_DWORD)v11 != 100)
        break;
      *a2++ = sqlite3_column_int64(*v10, 0);
      if (!--a3)
        goto LABEL_10;
    }
    v12 = (int)v11;
    if ((_DWORD)v11 == 101)
    {
      a3 = 0;
      *a2 = 0;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v11);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "do_cp_read", "cp_readDefault Error iterating rows %d\n", v12);
      a3 = 0xFFFFFFFFLL;
    }
  }
LABEL_10:
  sqlite3_finalize(*v10);
  return a3;
}

uint64_t CPMLDBSerialization::cp_multiQuery_uint64_t(CPMLDBSerialization *this, sqlite3_int64 *a2, uint64_t a3, const char *a4)
{
  char *v7;

  v7 = sqlite3_mprintf("%s", a4);
  return CPMLDBSerialization::do_cp_read(this, a2, a3, v7);
}

uint64_t CPMLDBSerialization::cp_query_uint64_t(CPMLDBSerialization *this, sqlite3_int64 *a2, uint64_t a3, char *a4, char *a5, int a6)
{
  char *v9;

  v9 = sqlite3_mprintf("select %q from %q where pKey BETWEEN %d AND %d", a5, a4, (a6 + 1), a3 + a6 + 1);
  return CPMLDBSerialization::do_cp_read(this, a2, a3, v9);
}

uint64_t CPMLDBSerialization::cp_update_uint64_t(CPMLDBSerialization *this, uint64_t a2, char *a3, char *a4, int a5)
{
  char *v6;
  sqlite3 *v7;
  int v8;
  sqlite3_stmt **v9;
  CPMLLog *v10;
  uint64_t v11;
  pthread_mutex_t *CPMLLog;

  v6 = sqlite3_mprintf("UPDATE %q SET %q=%ld where pKey=%d", a3, a4, a2, (a5 + 1));
  v7 = (sqlite3 *)*((_QWORD *)this + 4);
  v8 = strlen(v6);
  v9 = (sqlite3_stmt **)((char *)this + 56);
  sqlite3_prepare_v2(v7, v6, v8, v9, 0);
  if (v6)
    sqlite3_free(v6);
  v10 = (CPMLLog *)sqlite3_step(*v9);
  if ((_DWORD)v10 == 101)
  {
    v11 = 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_uint64_t", "Serializer: Error iterating rows\n");
    v11 = 0xFFFFFFFFLL;
  }
  sqlite3_finalize(*v9);
  return v11;
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, float *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;
  char *v9;
  sqlite3 *v10;
  int v11;
  sqlite3_stmt **v12;
  CPMLLog *v13;
  float v14;
  pthread_mutex_t *CPMLLog;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  v9 = v8;
  v10 = (sqlite3 *)*((_QWORD *)this + 4);
  v11 = strlen(v8);
  v12 = (sqlite3_stmt **)((char *)this + 64);
  sqlite3_prepare_v2(v10, v9, v11, v12, 0);
  if (v9)
    sqlite3_free(v9);
  if (a4)
  {
    while (1)
    {
      v13 = (CPMLLog *)sqlite3_step(*v12);
      if ((_DWORD)v13 != 100)
        break;
      if (sqlite3_column_type(*v12, 0) == 5)
        v14 = nanf("");
      else
        v14 = sqlite3_column_double(*v12, 0);
      *a2++ = v14;
      if (!--a4)
        goto LABEL_16;
    }
    if ((_DWORD)v13 == 101)
    {
      a4 = 0;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v13);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_read", "Serializer: Error iterating rows\n");
      a4 = 0xFFFFFFFFLL;
    }
  }
LABEL_16:
  sqlite3_finalize(*v12);
  return a4;
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, double *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  return CPMLDBSerialization::do_cp_read(this, a2, a4, v8);
}

uint64_t CPMLDBSerialization::do_cp_read(CPMLDBSerialization *this, double *a2, uint64_t a3, char *__s)
{
  sqlite3 *v8;
  int v9;
  sqlite3_stmt **v10;
  CPMLLog *v11;
  double v12;
  pthread_mutex_t *CPMLLog;

  v8 = (sqlite3 *)*((_QWORD *)this + 4);
  v9 = strlen(__s);
  v10 = (sqlite3_stmt **)((char *)this + 72);
  sqlite3_prepare_v2(v8, __s, v9, v10, 0);
  if (__s)
    sqlite3_free(__s);
  if (a3)
  {
    while (1)
    {
      v11 = (CPMLLog *)sqlite3_step(*v10);
      if ((_DWORD)v11 != 100)
        break;
      if (sqlite3_column_type(*v10, 0) == 5)
        v12 = nan("");
      else
        v12 = sqlite3_column_double(*v10, 0);
      *a2++ = v12;
      if (!--a3)
        goto LABEL_13;
    }
    if ((_DWORD)v11 == 101)
    {
      a3 = 0;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v11);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "do_cp_read", "Serializer: Error iterating rows\n");
      a3 = 0xFFFFFFFFLL;
    }
  }
LABEL_13:
  sqlite3_finalize(*v10);
  return a3;
}

uint64_t CPMLDBSerialization::cp_multiQuery_double(CPMLDBSerialization *this, double *a2, uint64_t a3, const char *a4)
{
  char *v7;

  v7 = sqlite3_mprintf("%s", a4);
  return CPMLDBSerialization::do_cp_read(this, a2, a3, v7);
}

uint64_t CPMLDBSerialization::cp_query_double(CPMLDBSerialization *this, double *a2, uint64_t a3, char *a4, char *a5, int a6)
{
  char *v9;

  v9 = sqlite3_mprintf("select %q from %q where pKey BETWEEN %d AND %d", a5, a4, (a6 + 1), a3 + a6 + 1);
  return CPMLDBSerialization::do_cp_read(this, a2, a3, v9);
}

uint64_t CPMLDBSerialization::cp_update_double(CPMLDBSerialization *this, double a2, char *a3, char *a4, int a5)
{
  char *v6;
  sqlite3 *v7;
  int v8;
  sqlite3_stmt **v9;
  CPMLLog *v10;
  uint64_t v11;
  pthread_mutex_t *CPMLLog;

  v6 = sqlite3_mprintf("UPDATE %q SET %q=%lf where pKey=%d", a3, a4, *(_QWORD *)&a2, (a5 + 1));
  v7 = (sqlite3 *)*((_QWORD *)this + 4);
  v8 = strlen(v6);
  v9 = (sqlite3_stmt **)((char *)this + 72);
  sqlite3_prepare_v2(v7, v6, v8, v9, 0);
  if (v6)
    sqlite3_free(v6);
  v10 = (CPMLLog *)sqlite3_step(*v9);
  if ((_DWORD)v10 == 101)
  {
    v11 = 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_update_double", "Serializer: Error iterating rows\n");
    v11 = 0xFFFFFFFFLL;
  }
  sqlite3_finalize(*v9);
  return v11;
}

uint64_t CPMLDBSerialization::cp_read(CPMLDBSerialization *this, char *a2, const char *a3, uint64_t a4, uint64_t a5)
{
  char *v8;

  if (a5)
    v8 = sqlite3_mprintf("select * from %q where pkey=%d", a3, a5 + 1);
  else
    v8 = sqlite3_mprintf("select * from %q", a3);
  return (*(uint64_t (**)(CPMLDBSerialization *, char *, uint64_t, char *))(*(_QWORD *)this + 184))(this, a2, a4, v8);
}

uint64_t CPMLDBSerialization::cp_singleQuery_string(CPMLDBSerialization *this, char *a2, size_t a3, char *__s)
{
  sqlite3_stmt **v6;
  sqlite3 *v8;
  int v9;
  CPMLLog *v10;
  uint64_t v11;
  const unsigned __int8 *v12;
  pthread_mutex_t *CPMLLog;

  v6 = (sqlite3_stmt **)((char *)this + 80);
  if (!*((_QWORD *)this + 10))
  {
    v8 = (sqlite3 *)*((_QWORD *)this + 4);
    v9 = strlen(__s);
    sqlite3_prepare_v2(v8, __s, v9, v6, 0);
    if (__s)
      sqlite3_free(__s);
  }
  v10 = (CPMLLog *)sqlite3_step(*v6);
  if ((_DWORD)v10 == 100)
  {
    v12 = sqlite3_column_text(*v6, 0);
    strlcpy(a2, (const char *)v12, a3);
    v11 = 0;
  }
  else if ((_DWORD)v10 == 101)
  {
    v11 = 0;
    *a2 = 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v10);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_string", "Serializer: Error iterating rows\n");
    v11 = 0xFFFFFFFFLL;
  }
  sqlite3_finalize(*v6);
  *v6 = 0;
  return v11;
}

uint64_t CPMLDBSerialization::cp_singleQuery_uint64_t(CPMLDBSerialization *this, sqlite3_int64 *a2, char *__s)
{
  sqlite3 *v6;
  int v7;
  sqlite3_stmt **v8;
  CPMLLog *v9;
  uint64_t result;
  sqlite3_int64 v11;
  pthread_mutex_t *CPMLLog;

  v6 = (sqlite3 *)*((_QWORD *)this + 4);
  v7 = strlen(__s);
  v8 = (sqlite3_stmt **)((char *)this + 88);
  sqlite3_prepare_v2(v6, __s, v7, (sqlite3_stmt **)this + 11, 0);
  v9 = (CPMLLog *)sqlite3_step(*((sqlite3_stmt **)this + 11));
  if ((_DWORD)v9 == 100)
  {
    if (sqlite3_column_type(*v8, 0) == 5)
      v11 = 0;
    else
      v11 = sqlite3_column_int64(*v8, 0);
    *a2 = v11;
    sqlite3_finalize(*v8);
    return 0;
  }
  else if ((_DWORD)v9 == 101)
  {
    sqlite3_finalize(*v8);
    result = 0;
    *a2 = 0;
  }
  else
  {
    CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
    CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_uint64_t", "Serializer: Error iterating rows\n");
    sqlite3_finalize(*v8);
    return 0xFFFFFFFFLL;
  }
  return result;
}

uint64_t CPMLDBSerialization::cp_singleQuery_double(CPMLDBSerialization *this, double *a2, char *__s)
{
  sqlite3 *v6;
  int v7;
  sqlite3_stmt **v8;
  CPMLLog *v9;
  int v10;
  double v12;
  pthread_mutex_t *CPMLLog;

  v6 = (sqlite3 *)*((_QWORD *)this + 4);
  v7 = strlen(__s);
  v8 = (sqlite3_stmt **)((char *)this + 88);
  sqlite3_prepare_v2(v6, __s, v7, (sqlite3_stmt **)this + 11, 0);
  v9 = (CPMLLog *)sqlite3_step(*((sqlite3_stmt **)this + 11));
  if ((_DWORD)v9 == 100)
  {
    if (sqlite3_column_type(*v8, 0) == 5)
      v12 = nan("");
    else
      v12 = sqlite3_column_double(*v8, 0);
    *a2 = v12;
    sqlite3_finalize(*v8);
    return 0;
  }
  else
  {
    v10 = (int)v9;
    if ((_DWORD)v9 == 101)
    {
      sqlite3_finalize(*v8);
      *a2 = 0.0;
      return 101;
    }
    else
    {
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog(v9);
      CPMLLog::log(CPMLLog, CPML_LOG_ERR, "cp_singleQuery_double", "Serializer: Error %d iterating rows: %s\n", v10, __s);
      sqlite3_finalize(*v8);
      return 0xFFFFFFFFLL;
    }
  }
}

void CPNaiveBayesClassifier::CPNaiveBayesClassifier(CPNaiveBayesClassifier *this, CPMLCDB *a2, CPMLSerialization *a3, CPMLTunableData *a4)
{
  uint64_t v6;
  CPMLStatistics *var0;
  int v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  uint64_t v12;
  unint64_t v13;

  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, a2, a3, a4);
  *(_QWORD *)v6 = &off_24C2557A0;
  *(_QWORD *)(v6 + 192) = 0;
  *(_QWORD *)(v6 + 200) = 0;
  *(_QWORD *)(v6 + 208) = 0;
  strcpy((char *)(v6 + 8), "1.0.0");
  var0 = a2->var0;
  v8 = *((_DWORD *)a2->var0 + 33);
  v9 = *((int *)a2->var0 + 32);
  *(_DWORD *)(v6 + 96) = *((_DWORD *)a2->var0 + 31);
  *(_DWORD *)(v6 + 100) = v8;
  v10 = *((_QWORD *)var0 + 4) - *((_QWORD *)var0 + 3);
  v11 = *((_QWORD *)var0 + 1) - *(_QWORD *)var0;
  *(_QWORD *)(v6 + 176) = *(_QWORD *)var0;
  v12 = v10 >> 3;
  *(_QWORD *)(v6 + 152) = 0;
  *(_QWORD *)(v6 + 160) = v12;
  v13 = v11 >> 2;
  *(_DWORD *)(v6 + 168) = v13;
  if (*(_DWORD *)(*((_QWORD *)var0 + 9) + 4 * v9))
    *((_QWORD *)this + 20) = v12 - 1;
  else
    *((_DWORD *)this + 42) = v13 - 1;
  *((_QWORD *)this + 10) = CPMLCDB::getIterator(a2, 0, 0, 0);
  CPNaiveBayesClassifier::initializeNaiveBayesMemory(this);
}

void sub_209CF8BF0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    v1[25] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

size_t CPNaiveBayesClassifier::initializeNaiveBayesMemory(CPNaiveBayesClassifier *this)
{
  size_t result;
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  pthread_mutex_t *CPMLLog;
  unint64_t v7;

  if ((int)CPMLTunableData::getNumberOfItems(*((CPMLTunableData **)this + 9)) < 1)
    *((_QWORD *)this + 17) = 0x4008000000000000;
  else
    CPMLTunableData::tDataGetDouble(*((CPMLTunableData **)this + 9), "laplaceParameter", (double *)this + 17);
  result = (size_t)malloc_type_calloc(*((unsigned int *)this + 25), 8uLL, 0x100004000313F17uLL);
  *((_QWORD *)this + 18) = result;
  if (*((_DWORD *)this + 42))
  {
    result = (size_t)malloc_type_calloc(*((unsigned int *)this + 25), 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 23) = result;
    if (*((_DWORD *)this + 25))
    {
      v3 = 0;
      result = *((unsigned int *)this + 42);
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 23) + 8 * v3) = malloc_type_calloc(result, 8uLL, 0x10040436913F5uLL);
        if (*((_DWORD *)this + 42))
        {
          v4 = 0;
          do
          {
            *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v3) + 8 * v4) = malloc_type_calloc(*(int *)(*((_QWORD *)this + 22)+ 4 * v4), 8uLL, 0x100004000313F17uLL);
            ++v4;
            result = *((unsigned int *)this + 42);
          }
          while (v4 < result);
        }
        else
        {
          result = 0;
        }
        ++v3;
      }
      while (v3 < *((unsigned int *)this + 25));
    }
  }
  if (*((_QWORD *)this + 20))
  {
    v5 = *((_DWORD *)this + 25);
    if (!v5)
    {
      *((_DWORD *)this + 25) = 2;
      CPMLLog = (pthread_mutex_t *)CPMLLog::getCPMLLog((CPMLLog *)result);
      CPMLLog::log(CPMLLog, CPML_LOG_DEBUG, "initializeNaiveBayesMemory", "resultCardinality 0\n");
      v5 = *((_DWORD *)this + 25);
    }
    *((_QWORD *)this + 15) = malloc_type_calloc(v5, 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 16) = malloc_type_calloc(*((unsigned int *)this + 25), 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 13) = malloc_type_calloc(*((unsigned int *)this + 25), 8uLL, 0x80040B8603338uLL);
    result = (size_t)malloc_type_calloc(*((unsigned int *)this + 25), 8uLL, 0x80040B8603338uLL);
    *((_QWORD *)this + 14) = result;
    if (*((_DWORD *)this + 25))
    {
      v7 = 0;
      do
      {
        *(_QWORD *)(*((_QWORD *)this + 15) + 8 * v7) = malloc_type_calloc(*((unsigned int *)this + 24), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 16) + 8 * v7) = malloc_type_calloc(*((unsigned int *)this + 24), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 13) + 8 * v7) = malloc_type_calloc(*((unsigned int *)this + 24), 8uLL, 0x100004000313F17uLL);
        result = (size_t)malloc_type_calloc(*((unsigned int *)this + 24), 8uLL, 0x100004000313F17uLL);
        *(_QWORD *)(*((_QWORD *)this + 14) + 8 * v7++) = result;
      }
      while (v7 < *((unsigned int *)this + 25));
    }
  }
  return result;
}

void CPNaiveBayesClassifier::CPNaiveBayesClassifier(CPNaiveBayesClassifier *this, CPMLSerialization *a2, CPMLTunableData *a3)
{
  _QWORD *v5;
  _DWORD *v6;
  _DWORD *v7;
  size_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t i;
  char v14[30];
  char v15[30];
  uint64_t v16;

  v16 = *MEMORY[0x24BDAC8D0];
  CPMLAlgorithm::CPMLAlgorithm((CPMLAlgorithm *)this, 0, a2, a3);
  v5[24] = 0;
  *v5 = &off_24C2557A0;
  v5[25] = 0;
  v5[26] = 0;
  (*((void (**)(CPMLSerialization *, _QWORD *, const char *, uint64_t, _QWORD))a2->var0 + 13))(a2, v5 + 1, "version", 5, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 152, "totalDataCount", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, (char *)this + 96, "featureVectorSpace", 1, 0);
  v6 = (_DWORD *)((char *)this + 100);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, (char *)this + 100, "resultCardinality", 1, 0);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 10))(a2, (char *)this + 160, "continousFeatureCount", 1, 0);
  v7 = (_DWORD *)((char *)this + 168);
  (*((void (**)(CPMLSerialization *, char *, const char *, uint64_t, _QWORD))a2->var0 + 9))(a2, (char *)this + 168, "discreteFeatureCount", 1, 0);
  v8 = *((unsigned int *)this + 42);
  if ((_DWORD)v8)
  {
    *((_QWORD *)this + 22) = malloc_type_calloc(v8, 4uLL, 0x100004052888210uLL);
    (*((void (**)(CPMLSerialization *))a2->var0 + 8))(a2);
  }
  CPNaiveBayesClassifier::initializeNaiveBayesMemory(this);
  v9 = *v6;
  if (*v7)
  {
    if (!*v6)
      goto LABEL_15;
    v10 = 0;
    LODWORD(v11) = 1;
    do
    {
      if ((_DWORD)v11)
      {
        v12 = 0;
        do
        {
          sprintf(v15, "discreteFeatureTable_%d_%d", v10, v12);
          (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 10))(a2, *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v10) + 8 * v12), v15, *(int *)(*((_QWORD *)this + 22) + 4 * v12), 0);
          ++v12;
          v11 = *v7;
        }
        while (v12 < v11);
        v9 = *v6;
      }
      ++v10;
    }
    while (v10 < v9);
  }
  if (*((_QWORD *)this + 20) && v9)
  {
    for (i = 0; i < v9; ++i)
    {
      sprintf(v15, "datasetMean%d", i);
      sprintf(v14, "datasetVariance%d", i);
      (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *(_QWORD *)(*((_QWORD *)this + 13) + 8 * i), v15, *((unsigned int *)this + 24), 0);
      (*((void (**)(CPMLSerialization *, _QWORD, char *, _QWORD, _QWORD))a2->var0 + 12))(a2, *(_QWORD *)(*((_QWORD *)this + 14) + 8 * i), v14, *((unsigned int *)this + 24), 0);
      v9 = *v6;
    }
  }
LABEL_15:
  (*((void (**)(CPMLSerialization *, _QWORD, const char *, unint64_t, _QWORD))a2->var0 + 10))(a2, *((_QWORD *)this + 18), "dist_datasetOutput", v9, 0);
}

void sub_209CF91C0(_Unwind_Exception *a1)
{
  _QWORD *v1;
  void **v2;
  void *v4;

  v4 = *v2;
  if (*v2)
  {
    v1[25] = v4;
    operator delete(v4);
  }
  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPNaiveBayesClassifier::~CPNaiveBayesClassifier(CPNaiveBayesClassifier *this)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  void *v5;

  *(_QWORD *)this = &off_24C2557A0;
  if (*((_DWORD *)this + 42))
  {
    if (*((_DWORD *)this + 25))
    {
      v2 = 0;
      do
      {
        if (*((_DWORD *)this + 42))
        {
          v3 = 0;
          do
            free(*(void **)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v2) + 8 * v3++));
          while (v3 < *((unsigned int *)this + 42));
        }
        free(*(void **)(*((_QWORD *)this + 23) + 8 * v2++));
      }
      while (v2 < *((unsigned int *)this + 25));
    }
    free(*((void **)this + 23));
  }
  if (*((_QWORD *)this + 20))
  {
    if (*((_DWORD *)this + 25))
    {
      v4 = 0;
      do
      {
        free(*(void **)(*((_QWORD *)this + 15) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 16) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 13) + 8 * v4));
        free(*(void **)(*((_QWORD *)this + 14) + 8 * v4++));
      }
      while (v4 < *((unsigned int *)this + 25));
    }
    free(*((void **)this + 15));
    free(*((void **)this + 16));
    free(*((void **)this + 13));
    free(*((void **)this + 14));
  }
  free(*((void **)this + 18));
  v5 = (void *)*((_QWORD *)this + 24);
  if (v5)
  {
    *((_QWORD *)this + 25) = v5;
    operator delete(v5);
  }
  CPModelClose(this);
}

{
  CPNaiveBayesClassifier::~CPNaiveBayesClassifier(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPNaiveBayesClassifier::serialize(CPNaiveBayesClassifier *this)
{
  uint64_t v2;
  char *v3;
  size_t v4;
  unsigned int *v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t i;
  char v13[30];
  char v14[30];
  uint64_t v15;

  v15 = *MEMORY[0x24BDAC8D0];
  v2 = *((_QWORD *)this + 11);
  v3 = (char *)this + 8;
  v4 = strlen((const char *)this + 8);
  (*(void (**)(uint64_t, char *, const char *, size_t, _QWORD))(*(_QWORD *)v2 + 56))(v2, v3, "version", v4, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 152, "totalDataCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), (char *)this + 96, "featureVectorSpace", 1, 0);
  v5 = (unsigned int *)((char *)this + 100);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), (char *)this + 100, "resultCardinality", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), (char *)this + 160, "continousFeatureCount", 1, 0);
  (*(void (**)(_QWORD, char *, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 24))(*((_QWORD *)this + 11), (char *)this + 168, "discreteFeatureCount", 1, 0);
  v6 = *((unsigned int *)this + 42);
  if ((_DWORD)v6)
  {
    (*(void (**)(_QWORD, _QWORD, const char *, uint64_t, _QWORD))(**((_QWORD **)this + 11) + 16))(*((_QWORD *)this + 11), *((_QWORD *)this + 22), "discreteCardinality", v6, 0);
    v7 = *((unsigned int *)this + 25);
    if (!(_DWORD)v7)
    {
      v7 = 0;
      goto LABEL_17;
    }
    v8 = 0;
    LODWORD(v9) = *((_DWORD *)this + 42);
    do
    {
      if ((_DWORD)v9)
      {
        v10 = 0;
        do
        {
          sprintf(v14, "discreteFeatureTable_%d_%d", v8, v10);
          (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), *(_QWORD *)(*(_QWORD *)(*((_QWORD *)this + 23) + 8 * v8) + 8 * v10), v14, *(int *)(*((_QWORD *)this + 22) + 4 * v10), 0);
          ++v10;
          v9 = *((unsigned int *)this + 42);
        }
        while (v10 < v9);
        v7 = *v5;
      }
      ++v8;
    }
    while (v8 < v7);
  }
  else
  {
    v7 = *v5;
  }
  if (*((_QWORD *)this + 20) && v7)
  {
    for (i = 0; i < v7; ++i)
    {
      sprintf(v14, "datasetMean%d", i);
      sprintf(v13, "datasetVariance%d", i);
      (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 13) + 8 * i), v14, *((unsigned int *)this + 24), 0);
      (*(void (**)(_QWORD, _QWORD, char *, _QWORD, _QWORD))(**((_QWORD **)this + 11) + 48))(*((_QWORD *)this + 11), *(_QWORD *)(*((_QWORD *)this + 14) + 8 * i), v13, *((unsigned int *)this + 24), 0);
      v7 = *((unsigned int *)this + 25);
    }
  }
LABEL_17:
  (*(void (**)(_QWORD, _QWORD, const char *, unint64_t, _QWORD))(**((_QWORD **)this + 11) + 32))(*((_QWORD *)this + 11), *((_QWORD *)this + 18), "dist_datasetOutput", v7, 0);
  return 0;
}

uint64_t CPNaiveBayesClassifier::train(CPNaiveBayesClassifier *this)
{
  uint64_t v2;
  CPMLFeatureVector *v3;
  uint64_t YHat;
  uint64_t IntVector;
  int *v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t RealVector;
  double *v14;
  uint64_t v15;
  unint64_t v16;
  double *v17;
  double v18;
  uint64_t v19;
  CPMLFeatureVector *v20;
  double v21;
  uint64_t v22;
  double *v23;
  uint64_t v24;
  uint64_t v25;
  double *v26;
  unint64_t v27;
  double *v28;
  uint64_t v29;
  double v30;
  double v31;
  double v32;

  v2 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v2)
  {
    v3 = (CPMLFeatureVector *)v2;
    do
    {
      YHat = (int)CPMLFeatureVector::getYHat(v3);
      ++*(_QWORD *)(*((_QWORD *)this + 18) + 8 * YHat);
      ++*((_QWORD *)this + 19);
      IntVector = CPMLFeatureVector::getIntVector(v3);
      v6 = *(int **)IntVector;
      v7 = *(_QWORD *)(IntVector + 8) - *(_QWORD *)IntVector;
      if (v7)
      {
        v8 = v7 >> 2;
        v9 = *(uint64_t **)(*((_QWORD *)this + 23) + 8 * YHat);
        if (v8 <= 1)
          v8 = 1;
        do
        {
          v11 = *v6++;
          v10 = v11;
          v12 = *v9++;
          ++*(_QWORD *)(v12 + 8 * v10);
          --v8;
        }
        while (v8);
      }
      RealVector = CPMLFeatureVector::getRealVector(v3);
      v14 = *(double **)RealVector;
      v15 = *(_QWORD *)(RealVector + 8) - *(_QWORD *)RealVector;
      if (v15)
      {
        v16 = v15 >> 3;
        v17 = *(double **)(*((_QWORD *)this + 15) + 8 * YHat);
        if (v16 <= 1)
          v16 = 1;
        do
        {
          v18 = *v14++;
          *v17 = v18 + *v17;
          ++v17;
          --v16;
        }
        while (v16);
      }
      v3 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v3);
  }
  CPNaiveBayesClassifier::updateMean((uint64_t)this);
  (*(void (**)(_QWORD))(**((_QWORD **)this + 10) + 40))(*((_QWORD *)this + 10));
  v19 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
  if (v19)
  {
    v20 = (CPMLFeatureVector *)v19;
    do
    {
      v21 = CPMLFeatureVector::getYHat(v20);
      v22 = CPMLFeatureVector::getRealVector(v20);
      v23 = *(double **)v22;
      v24 = *(_QWORD *)(v22 + 8);
      v25 = v24 - *(_QWORD *)v22;
      if (v24 != *(_QWORD *)v22)
      {
        v26 = *(double **)(*((_QWORD *)this + 13) + 8 * (int)v21);
        v27 = v25 >> 3;
        v28 = *(double **)(*((_QWORD *)this + 16) + 8 * (int)v21);
        if (v27 <= 1)
          v29 = 1;
        else
          v29 = v27;
        do
        {
          v30 = *v26++;
          v31 = v30;
          v32 = *v23++;
          *v28 = *v28 + (v32 - v31) * (v32 - v31);
          ++v28;
          --v29;
        }
        while (v29);
      }
      v20 = (CPMLFeatureVector *)(*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 10) + 32))(*((_QWORD *)this + 10));
    }
    while (v20);
  }
  CPNaiveBayesClassifier::updateVariance((uint64_t)this);
  return 0;
}

uint64_t CPNaiveBayesClassifier::updateMean(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double *v4;
  double v5;
  double *v6;
  uint64_t v7;
  double v8;

  v1 = *(unsigned int *)(this + 100);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(this + 160);
    do
    {
      if (v3)
      {
        v4 = *(double **)(*(_QWORD *)(this + 120) + 8 * v2);
        v5 = (double)*(unint64_t *)(*(_QWORD *)(this + 144) + 8 * v2);
        v6 = *(double **)(*(_QWORD *)(this + 104) + 8 * v2);
        v7 = v3;
        do
        {
          v8 = *v4++;
          *v6++ = v8 / v5;
          --v7;
        }
        while (v7);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return this;
}

uint64_t CPNaiveBayesClassifier::updateVariance(uint64_t this)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  double *v4;
  double v5;
  double *v6;
  uint64_t v7;
  double v8;

  v1 = *(unsigned int *)(this + 100);
  if ((_DWORD)v1)
  {
    v2 = 0;
    v3 = *(_QWORD *)(this + 160);
    do
    {
      if (v3)
      {
        v4 = *(double **)(*(_QWORD *)(this + 128) + 8 * v2);
        v5 = (double)(unint64_t)(*(_QWORD *)(*(_QWORD *)(this + 144) + 8 * v2) - 1);
        v6 = *(double **)(*(_QWORD *)(this + 112) + 8 * v2);
        v7 = v3;
        do
        {
          v8 = *v4++;
          *v6++ = v8 / v5;
          --v7;
        }
        while (v7);
      }
      ++v2;
    }
    while (v2 != v1);
  }
  return this;
}

uint64_t CPNaiveBayesClassifier::eval(uint64_t a1, CPMLFeatureVector *this)
{
  uint64_t *IntVector;
  _QWORD *RealVector;
  double *v6;
  double *v7;
  size_t v8;
  unint64_t *v9;
  double v10;
  uint64_t v11;
  long double *v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  double v18;
  double v19;
  long double v20;
  double v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  double v25;
  double *v26;
  uint64_t v27;
  uint64_t i;
  double v29;
  double v30;
  uint64_t v31;
  double *v32;
  double v33;
  double v34;
  double *v35;
  double *v36;
  uint64_t v37;
  unint64_t v38;
  int v39;
  _QWORD *v40;
  _QWORD *v41;
  char *v42;
  double v43;
  double v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  unint64_t v48;
  char *v49;
  char *v50;
  char *v51;
  char *v52;
  char *v53;
  double v54;
  char *v55;
  char *v56;
  _QWORD *v57;
  unint64_t v58;
  uint64_t v59;
  CPMLFeatureVector *v61;
  BOOL (*v62)(uint64_t, uint64_t, uint64_t);

  IntVector = (uint64_t *)CPMLFeatureVector::getIntVector(this);
  v61 = this;
  RealVector = (_QWORD *)CPMLFeatureVector::getRealVector(this);
  v6 = (double *)malloc_type_calloc(*(unsigned int *)(a1 + 100), 8uLL, 0x100004000313F17uLL);
  v7 = v6;
  v8 = *(unsigned int *)(a1 + 100);
  if ((_DWORD)v8)
  {
    v9 = *(unint64_t **)(a1 + 144);
    v10 = (double)*(unint64_t *)(a1 + 152);
    v11 = *(unsigned int *)(a1 + 100);
    v12 = v6;
    do
    {
      v13 = *v9++;
      *v12++ = log((double)v13 / v10);
      --v11;
    }
    while (v11);
    v14 = *(_QWORD *)(a1 + 160);
    v15 = *(unsigned int *)(a1 + 168);
    do
    {
      if (v14)
      {
        v16 = 0;
        v17 = *(_QWORD *)(*(_QWORD *)(a1 + 112) + 8 * v11);
        v18 = v7[v11];
        do
        {
          v19 = *(double *)(v17 + 8 * v16);
          v20 = 1.0;
          if (v19 != 0.0)
          {
            v21 = *(double *)(*RealVector + 8 * v16)
                - *(double *)(*(_QWORD *)(*(_QWORD *)(a1 + 104) + 8 * v11) + 8 * v16);
            v20 = exp(-(v21 * v21) / (v19 + v19)) / sqrt(v19 * 6.28318531);
          }
          v18 = v18 + log(v20);
          v7[v11] = v18;
          ++v16;
        }
        while (v14 != v16);
      }
      if ((_DWORD)v15)
      {
        v22 = 0;
        v23 = *IntVector;
        do
        {
          v24 = *(unsigned int *)(v23 + 4 * v22);
          if ((v24 & 0x80000000) != 0)
            v25 = 0.0;
          else
            v25 = log((*(double *)(a1 + 136)+ (double)*(unint64_t *)(*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 184) + 8 * v11) + 8 * v22)+ 8 * v24))/ ((double)*(unint64_t *)(*(_QWORD *)(a1 + 144) + 8 * v11)+ *(double *)(a1 + 136) * (double)(unint64_t)*(int *)(*(_QWORD *)(a1 + 176) + 4 * v22)));
          v7[v11] = v7[v11] + v25;
          ++v22;
        }
        while (v15 != v22);
      }
      ++v11;
    }
    while (v11 != v8);
  }
  else
  {
    v8 = 0;
  }
  v26 = (double *)malloc_type_calloc(v8, 8uLL, 0x100004000313F17uLL);
  v27 = *(unsigned int *)(a1 + 100);
  if ((_DWORD)v27)
  {
    for (i = 0; i != v27; ++i)
    {
      v29 = v7[i];
      v30 = 0.0;
      v31 = v27;
      v32 = v7;
      do
      {
        v33 = *v32++;
        v30 = v30 + exp(v33 - v29);
        --v31;
      }
      while (v31);
      v34 = 1.0 / v30;
      if (v30 <= 0.0)
        v34 = 1.0;
      v26[i] = v34;
    }
    v35 = v26;
    v36 = v7;
    do
    {
      v37 = *(_QWORD *)v35++;
      *(_QWORD *)v36++ = v37;
      --v27;
    }
    while (v27);
  }
  free(v26);
  if (*(_DWORD *)(a1 + 100))
  {
    v38 = 0;
    v39 = 0;
    v40 = (_QWORD *)(a1 + 192);
    v41 = (_QWORD *)(a1 + 208);
    v42 = *(char **)(a1 + 200);
    v43 = 0.0;
    do
    {
      v44 = v7[v38];
      if (v44 > v43)
      {
        v43 = v7[v38];
        v39 = v38;
      }
      if ((unint64_t)v42 >= *v41)
      {
        v45 = (uint64_t)&v42[-*v40] >> 4;
        if ((unint64_t)(v45 + 1) >> 60)
          std::vector<double>::__throw_length_error[abi:ne180100]();
        v46 = *v41 - *v40;
        v47 = v46 >> 3;
        if (v46 >> 3 <= (unint64_t)(v45 + 1))
          v47 = v45 + 1;
        if ((unint64_t)v46 >= 0x7FFFFFFFFFFFFFF0)
          v48 = 0xFFFFFFFFFFFFFFFLL;
        else
          v48 = v47;
        if (v48)
          v49 = (char *)std::__allocate_at_least[abi:ne180100]<std::allocator<std::valarray<char>>>(a1 + 208, v48);
        else
          v49 = 0;
        v50 = &v49[16 * v45];
        *(double *)v50 = v44;
        *((_DWORD *)v50 + 2) = v38;
        *((_DWORD *)v50 + 3) = 0;
        v52 = *(char **)(a1 + 192);
        v51 = *(char **)(a1 + 200);
        v53 = v50;
        if (v51 != v52)
        {
          do
          {
            *((_OWORD *)v53 - 1) = *((_OWORD *)v51 - 1);
            v53 -= 16;
            v51 -= 16;
          }
          while (v51 != v52);
          v51 = (char *)*v40;
        }
        v42 = v50 + 16;
        *(_QWORD *)(a1 + 192) = v53;
        *(_QWORD *)(a1 + 200) = v50 + 16;
        *(_QWORD *)(a1 + 208) = &v49[16 * v48];
        if (v51)
          operator delete(v51);
      }
      else
      {
        *(double *)v42 = v44;
        *((_DWORD *)v42 + 2) = v38;
        *((_DWORD *)v42 + 3) = 0;
        v42 += 16;
      }
      *(_QWORD *)(a1 + 200) = v42;
      ++v38;
    }
    while (v38 < *(unsigned int *)(a1 + 100));
    v54 = (double)v39;
  }
  else
  {
    v54 = 0.0;
  }
  free(v7);
  v55 = *(char **)(a1 + 192);
  v56 = *(char **)(a1 + 200);
  v57 = (_QWORD *)(a1 + 192);
  v58 = 126 - 2 * __clz((v56 - v55) >> 4);
  v62 = sortProbIndexClassic;
  if (v56 == v55)
    v59 = 0;
  else
    v59 = v58;
  std::__introsort<std::_ClassicAlgPolicy,BOOL (*&)(ProbIndex,ProbIndex),ProbIndex*,false>(v55, v56, (uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))&v62, v59, 1);
  CPMLFeatureVector::setYHat((uint64_t)v61, v54);
  CPMLFeatureVector::setYHatProbList((uint64_t)v61, (uint64_t)v57);
  v57[1] = *v57;
  return 0;
}

BOOL sortProbIndexClassic(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return *(double *)&a1 > *(double *)&a3;
}

uint64_t CPNaiveBayesClassifier::errorString(CPNaiveBayesClassifier *this)
{
  return 0;
}

void CPMLMemoryIterator::CPMLMemoryIterator(CPMLMemoryIterator *this, int a2, int a3, double **a4, CPMLTunableData *a5)
{
  uint64_t v9;
  CPMLFeatureVector *v10;

  CPMLIterator::CPMLIterator((CPMLIterator *)this);
  *(_QWORD *)v9 = &off_24C255520;
  *(_DWORD *)(v9 + 88) = 0;
  v10 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v10);
  *((_DWORD *)this + 20) = a2;
  *((_DWORD *)this + 21) = a3;
  *((_QWORD *)this + 12) = a4;
  *((_QWORD *)this + 13) = v10;
}

void sub_209CF9CF0(_Unwind_Exception *a1)
{
  CPMLIterator *v1;
  uint64_t v2;

  MEMORY[0x20BD188E4](v2, 0x1020C4087C48359);
  CPMLIterator::~CPMLIterator(v1);
  _Unwind_Resume(a1);
}

void CPMLMemoryIterator::~CPMLMemoryIterator(CPMLIterator *this)
{
  CPMLFeatureVector *v2;

  *(_QWORD *)this = &off_24C255520;
  v2 = (CPMLFeatureVector *)*((_QWORD *)this + 13);
  if (v2)
  {
    CPMLFeatureVector::~CPMLFeatureVector(v2);
    MEMORY[0x20BD188E4]();
  }
  *((_QWORD *)this + 13) = 0;
  CPMLIterator::~CPMLIterator(this);
}

{
  CPMLMemoryIterator::~CPMLMemoryIterator(this);
  JUMPOUT(0x20BD188E4);
}

uint64_t CPMLMemoryIterator::iterateAll(CPMLMemoryIterator *this)
{
  return 0;
}

uint64_t CPMLMemoryIterator::iterateFirst(CPMLMemoryIterator *this)
{
  uint64_t v3;
  uint64_t v4;
  CPMLFeatureVector *v5;
  double v6;

  if (!*((_QWORD *)this + 12) || *((_DWORD *)this + 22) == *((_DWORD *)this + 21))
    return 0;
  CPMLFeatureVector::resetAll(*((CPMLFeatureVector **)this + 13));
  LODWORD(v3) = *((_DWORD *)this + 20);
  if ((int)v3 >= 1)
  {
    v4 = 0;
    do
    {
      v5 = (CPMLFeatureVector *)*((_QWORD *)this + 13);
      v6 = *(double *)(*(_QWORD *)(*((_QWORD *)this + 12) + 8 * v4++) + 8 * *((int *)this + 22));
      if (v4 >= (int)v3)
        CPMLFeatureVector::setYHat((uint64_t)v5, v6);
      else
        CPMLFeatureVector::insertRealVClass(v5, v6);
      v3 = *((int *)this + 20);
    }
    while (v4 < v3);
  }
  ++*((_DWORD *)this + 22);
  return *((_QWORD *)this + 13);
}

uint64_t CPMLMemoryIterator::iterateNext(CPMLMemoryIterator *this)
{
  return (*(uint64_t (**)(CPMLMemoryIterator *))(*(_QWORD *)this + 24))(this);
}

uint64_t CPMLMemoryIterator::iterateReset(uint64_t this)
{
  *(_DWORD *)(this + 88) = 0;
  return this;
}

void CPMLNaiveBayesSuggestionsAdaptor::CPMLNaiveBayesSuggestionsAdaptor(CPMLNaiveBayesSuggestionsAdaptor *this, CPMLSerialization *a2)
{
  _QWORD *v2;

  CPMLNaiveBayesAdaptor::CPMLNaiveBayesAdaptor(this, a2);
  *v2 = &off_24C255D18;
}

double CPMLNaiveBayesSuggestionsAdaptor::get_cx_given_y(CPMLNaiveBayesSuggestionsAdaptor *this, int a2, unsigned int a3, int a4, double *a5)
{
  char *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  _QWORD *v13;
  unint64_t v15;
  unint64_t *v16;

  v9 = (char *)this + 112;
  v10 = a4;
  v16 = (unint64_t *)a4;
  if (std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::find<unsigned long long>((_QWORD *)this + 14, (unint64_t *)&v16))
  {
    v15 = v10;
    v16 = &v15;
    v11 = std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long &&>,std::tuple<>>((uint64_t)v9, &v15, (uint64_t)&std::piecewise_construct, &v16)[3];
  }
  else
  {
    v11 = 0;
  }
  *(_QWORD *)a5 = v11;
  v15 = v10 | ((unint64_t)a3 << 32);
  v12 = (_QWORD *)((char *)this + 72);
  v13 = std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::find<unsigned long long>(v12, &v15);
  if (a3 == -1 || a4 == -1)
  {
    *a5 = 0.0;
  }
  else
  {
    if (v13)
    {
      v16 = &v15;
      return *((double *)std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v12, &v15, (uint64_t)&std::piecewise_construct, &v16)+ 3);
    }
    v16 = &v15;
    std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v12, &v15, (uint64_t)&std::piecewise_construct, &v16)[3] = 0;
  }
  return 0.0;
}

void CPMLNaiveBayesSuggestionsAdaptor::set_cx_given_y(CPMLNaiveBayesSuggestionsAdaptor *this, int a2, uint64_t a3, unsigned int a4, double a5)
{
  CPMLNaiveBayesAdaptor::set_cx_given_y(this, 0, a3, a4, a5);
}

void CPMLNaiveBayesSuggestionsAdaptor::set_cardinalityx_given_y(CPMLNaiveBayesSuggestionsAdaptor *this, int a2, int a3, double a4)
{
  CPMLNaiveBayesAdaptor::set_cardinalityx_given_y(this, 0, a3, a4);
}

void CPMLNaiveBayesSuggestionsAdaptor::setCacheSize(CPMLNaiveBayesSuggestionsAdaptor *this, int a2, int a3)
{
  char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  char *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  char *v15;
  uint64_t v16;
  uint64_t v17;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  unint64_t v22;
  uint64_t v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  char *v32;
  char *v33;
  char *v34;
  unint64_t v35;
  char *v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t v39;
  double v40;
  _QWORD *v41[2];

  v41[1] = *(_QWORD **)MEMORY[0x24BDAC8D0];
  CPMLNaiveBayesAdaptor::setCacheSize(this, a2, a3);
  v40 = 0.0;
  v6 = sqlite3_mprintf("select count(*) from xcol0;");
  (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v40, v6);
  sqlite3_free(v6);
  if (v40 > (double)(a3 * a2))
    v40 = (double)(a3 * a2);
  v9 = MEMORY[0x24BDAC7A8](v7, v8);
  v11 = (char *)&v38 - v10;
  v13 = MEMORY[0x24BDAC7A8](v9, v12);
  v15 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFF0);
  MEMORY[0x24BDAC7A8](v13, v16);
  v18 = (char *)&v38 - v17;
  v19 = sqlite3_mprintf("select xMap from xcol0;");
  (*(void (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 208))(*((_QWORD *)this + 1), v11, (int)v40, v19);
  sqlite3_free(v19);
  v20 = sqlite3_mprintf("select yMap from xcol0;");
  (*(void (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 208))(*((_QWORD *)this + 1), v15, (int)v40, v20);
  sqlite3_free(v20);
  v21 = sqlite3_mprintf("select xyCount from xcol0;");
  (*(void (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 216))(*((_QWORD *)this + 1), v18, (int)v40, v21);
  sqlite3_free(v21);
  if ((unint64_t)v40)
  {
    v22 = 0;
    do
    {
      v39 = *(unsigned int *)&v15[8 * v22] | (*(_QWORD *)&v11[8 * v22] << 32);
      v23 = *(_QWORD *)&v18[8 * v22];
      v41[0] = &v39;
      std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)this + 72, &v39, (uint64_t)&std::piecewise_construct, v41)[3] = v23;
      ++v22;
    }
    while (v22 < (unint64_t)v40);
  }
  v24 = sqlite3_mprintf("select count(*) from xCardinality0;");
  (*(void (**)(_QWORD, double *, char *))(**((_QWORD **)this + 1) + 224))(*((_QWORD *)this + 1), &v40, v24);
  sqlite3_free(v24);
  v27 = MEMORY[0x24BDAC7A8](v25, v26);
  v29 = (uint64_t *)((char *)&v38 - ((v28 + 15) & 0xFFFFFFFF0));
  MEMORY[0x24BDAC7A8](v27, v30);
  v32 = (char *)&v38 - v31;
  v33 = sqlite3_mprintf("select yMap from xCardinality0;");
  (*(void (**)(_QWORD, _QWORD *, _QWORD, char *))(**((_QWORD **)this + 1) + 208))(*((_QWORD *)this + 1), v29, (int)v40, v33);
  sqlite3_free(v33);
  v34 = sqlite3_mprintf("select xCardinality from xCardinality0;");
  (*(void (**)(_QWORD, char *, _QWORD, char *))(**((_QWORD **)this + 1) + 216))(*((_QWORD *)this + 1), v32, (int)v40, v34);
  sqlite3_free(v34);
  if ((unint64_t)v40)
  {
    v35 = 0;
    v36 = (char *)this + 112;
    do
    {
      v37 = *(_QWORD *)&v32[8 * v35];
      v41[0] = v29;
      std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::__emplace_unique_key_args<unsigned long long,std::piecewise_construct_t const&,std::tuple<unsigned long long const&>,std::tuple<>>((uint64_t)v36, v29, (uint64_t)&std::piecewise_construct, v41)[3] = v37;
      ++v35;
      ++v29;
    }
    while (v35 < (unint64_t)v40);
  }
}

_QWORD *std::__hash_table<std::__hash_value_type<unsigned long long,double>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,double>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,double>>>::find<unsigned long long>(_QWORD *a1, unint64_t *a2)
{
  int8x8_t v2;
  unint64_t v3;
  uint8x8_t v4;
  unint64_t v5;
  _QWORD *v6;
  _QWORD *result;
  unint64_t v8;

  v2 = (int8x8_t)a1[1];
  if (!*(_QWORD *)&v2)
    return 0;
  v3 = *a2;
  v4 = (uint8x8_t)vcnt_s8(v2);
  v4.i16[0] = vaddlv_u8(v4);
  if (v4.u32[0] > 1uLL)
  {
    v5 = *a2;
    if (v3 >= *(_QWORD *)&v2)
      v5 = v3 % *(_QWORD *)&v2;
  }
  else
  {
    v5 = (*(_QWORD *)&v2 - 1) & v3;
  }
  v6 = *(_QWORD **)(*a1 + 8 * v5);
  if (!v6)
    return 0;
  result = (_QWORD *)*v6;
  if (*v6)
  {
    do
    {
      v8 = result[1];
      if (v8 == v3)
      {
        if (result[2] == v3)
          return result;
      }
      else
      {
        if (v4.u32[0] > 1uLL)
        {
          if (v8 >= *(_QWORD *)&v2)
            v8 %= *(_QWORD *)&v2;
        }
        else
        {
          v8 &= *(_QWORD *)&v2 - 1;
        }
        if (v8 != v5)
          return 0;
      }
      result = (_QWORD *)*result;
    }
    while (result);
  }
  return result;
}

uint64_t CPMLlinearSVM::TRON::info(uint64_t (**this)(char *), const char *a2, ...)
{
  char v4[1024];
  uint64_t v5;
  va_list va;

  va_start(va, a2);
  v5 = *MEMORY[0x24BDAC8D0];
  vsprintf(v4, a2, va);
  return this[3](v4);
}

uint64_t CPMLlinearSVM::TRON::TRON(uint64_t result, uint64_t a2, int a3, double a4)
{
  *(double *)result = a4;
  *(_DWORD *)(result + 8) = a3;
  *(_QWORD *)(result + 16) = a2;
  *(_QWORD *)(result + 24) = default_print;
  return result;
}

uint64_t default_print(const char *a1)
{
  FILE **v1;

  v1 = (FILE **)MEMORY[0x24BDAC8E8];
  fputs(a1, (FILE *)*MEMORY[0x24BDAC8E8]);
  return fflush(*v1);
}

uint64_t CPMLlinearSVM::TRON::tron(CPMLlinearSVM::TRON *this, double *a2)
{
  int v4;
  double *v5;
  double *v6;
  void *v7;
  double *v8;
  double v9;
  int v10;
  double v11;
  const char *v12;
  double v13;
  double v14;
  int v15;
  double v16;
  double v17;
  double v18;
  double v19;
  double v20;
  double v21;
  double v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v32;
  double v33;
  double v36;
  int incx;
  double da;
  int n[3];

  v4 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
  n[0] = v4;
  da = 1.0;
  incx = 1;
  v5 = (double *)operator new[]();
  v6 = (double *)operator new[]();
  v7 = (void *)operator new[]();
  v8 = (double *)operator new[]();
  if (v4 >= 1)
    bzero(a2, 8 * v4);
  v9 = (***((double (****)(_QWORD, double *))this + 2))(*((_QWORD *)this + 2), a2);
  (*(void (**)(_QWORD, double *, double *))(**((_QWORD **)this + 2) + 8))(*((_QWORD *)this + 2), a2, v8);
  v36 = dnrm2_(n, v8, &incx);
  if (v36 > v36 * *(double *)this)
  {
    v10 = 1;
    v11 = 0.25;
    v12 = "WARNING: f < -1.0e+32\n";
    v13 = v36;
    v14 = v36;
    while (v10 <= *((_DWORD *)this + 2))
    {
      v15 = CPMLlinearSVM::TRON::trcg(this, v14, v8, v5, v6);
      memcpy(v7, a2, 8 * n[0]);
      daxpy_(n, &da, v5, &incx, (double *)v7, &incx);
      v16 = ddot_(n, v8, &incx, v5, &incx);
      v17 = ddot_(n, v5, &incx, v6, &incx);
      v18 = (***((double (****)(_QWORD, void *))this + 2))(*((_QWORD *)this + 2), v7);
      v19 = dnrm2_(n, v5, &incx);
      if (v14 >= v19)
        v20 = v19;
      else
        v20 = v14;
      if (v10 != 1)
        v20 = v14;
      v21 = v18 - v9 - v16;
      v22 = 4.0;
      if (v21 > 0.0)
      {
        v22 = v16 / v21 * -0.5;
        v11 = 0.25;
        if (v22 < 0.25)
          v22 = 0.25;
      }
      v23 = (v16 - v17) * -0.5;
      v24 = v9 - v18;
      if (v9 - v18 >= v23 * 0.0001)
      {
        v11 = 0.25;
        v27 = v20 * 0.25;
        v28 = v19 * v22;
        if (v24 >= v23 * 0.25)
        {
          v30 = v20 * 4.0;
          if (v28 >= v20 * 4.0)
            v31 = v20 * 4.0;
          else
            v31 = v28;
          if (v20 <= v31)
            v20 = v31;
          if (v28 >= v30)
            v28 = v30;
          if (v27 > v28)
            v28 = v27;
          if (v24 < v23 * 0.75)
            v14 = v28;
          else
            v14 = v20;
        }
        else
        {
          v29 = v20 * 0.5;
          if (v28 >= v29)
            v28 = v29;
          if (v27 <= v28)
            v14 = v28;
          else
            v14 = v27;
        }
      }
      else
      {
        v25 = v19 * fmax(v22, v11);
        v26 = v20 * 0.5;
        if (v25 >= v26)
          v14 = v26;
        else
          v14 = v25;
      }
      CPMLlinearSVM::TRON::info((uint64_t (**)(char *))this, "iter %2d act %5.3e pre %5.3e delta %5.3e f %5.3e |g| %5.3e CG %3d\n", v10, v9 - v18, v23, v14, v9, v13, v15);
      if (v24 > v23 * 0.0001)
      {
        memcpy(a2, v7, 8 * n[0]);
        (*(void (**)(_QWORD, double *, double *))(**((_QWORD **)this + 2) + 8))(*((_QWORD *)this + 2), a2, v8);
        v13 = dnrm2_(n, v8, &incx);
        if (v13 <= v36 * *(double *)this)
          break;
        ++v10;
        v9 = v18;
      }
      if (v9 < -1.0e32)
        goto LABEL_48;
      if (v24 == 0.0 && v23 <= 0.0)
      {
        v12 = "WARNING: actred and prered <= 0\n";
LABEL_48:
        CPMLlinearSVM::TRON::info((uint64_t (**)(char *))this, v12);
        break;
      }
      v32 = fabs(v9) * 1.0e-12;
      v33 = fabs(v23);
      if (fabs(v24) <= v32 && v33 <= v32)
      {
        CPMLlinearSVM::TRON::info((uint64_t (**)(char *))this, "WARNING: actred and prered too small\n");
        break;
      }
    }
  }
  MEMORY[0x20BD188CC](v8, 0x1000C8000313F17);
  MEMORY[0x20BD188CC](v6, 0x1000C8000313F17);
  MEMORY[0x20BD188CC](v7, 0x1000C8000313F17);
  return MEMORY[0x20BD188CC](v5, 0x1000C8000313F17);
}

uint64_t CPMLlinearSVM::TRON::trcg(CPMLlinearSVM::TRON *this, double a2, double *a3, double *a4, double *a5)
{
  int v10;
  double *v11;
  double *v12;
  double *v13;
  double *v14;
  double *v15;
  double *v16;
  uint64_t v17;
  double v18;
  double v19;
  double v20;
  uint64_t v21;
  uint64_t v22;
  double v23;
  double v24;
  double v25;
  double v26;
  double v27;
  double v28;
  double v29;
  double v30;
  double v31;
  double v33;
  double da;
  double v35;
  int n;
  int incx;

  incx = 1;
  v10 = (*(uint64_t (**)(_QWORD))(**((_QWORD **)this + 2) + 24))(*((_QWORD *)this + 2));
  n = v10;
  v35 = 1.0;
  v11 = (double *)operator new[]();
  v12 = (double *)operator new[]();
  if (v10 >= 1)
  {
    v13 = a4;
    v14 = a3;
    v15 = a5;
    v16 = v11;
    v17 = v10;
    do
    {
      *v13++ = 0.0;
      v18 = *v14++;
      *v15++ = -v18;
      *v16++ = -v18;
      --v17;
    }
    while (v17);
  }
  v33 = 0.0;
  da = 0.0;
  v19 = dnrm2_(&n, a3, &incx) * 0.1;
  v20 = ddot_(&n, a5, &incx, a5, &incx);
  if (dnrm2_(&n, a5, &incx) <= v19)
  {
    v22 = 0;
  }
  else
  {
    v21 = 1;
    while (1)
    {
      v22 = v21;
      (*(void (**)(_QWORD, double *, double *))(**((_QWORD **)this + 2) + 16))(*((_QWORD *)this + 2), v11, v12);
      da = v20 / ddot_(&n, v11, &incx, v12, &incx);
      daxpy_(&n, &da, v11, &incx, a4, &incx);
      if (dnrm2_(&n, a4, &incx) > a2)
        break;
      da = -da;
      daxpy_(&n, &da, v12, &incx, a5, &incx);
      v23 = ddot_(&n, a5, &incx, a5, &incx);
      v33 = v23 / v20;
      dscal_(&n, &v33, v11, &incx);
      daxpy_(&n, &v35, a5, &incx, v11, &incx);
      v24 = dnrm2_(&n, a5, &incx);
      v21 = (v22 + 1);
      v20 = v23;
      if (v24 <= v19)
        goto LABEL_13;
    }
    CPMLlinearSVM::TRON::info((uint64_t (**)(char *))this, "cg reaches trust region boundary\n");
    da = -da;
    daxpy_(&n, &da, v11, &incx, a4, &incx);
    v25 = ddot_(&n, a4, &incx, v11, &incx);
    v26 = ddot_(&n, a4, &incx, a4, &incx);
    v27 = ddot_(&n, v11, &incx, v11, &incx);
    v28 = a2 * a2 - v26;
    v29 = sqrt(v27 * v28 + v25 * v25);
    v30 = (v29 - v25) / v27;
    v31 = v28 / (v25 + v29);
    if (v25 >= 0.0)
      v30 = v31;
    da = v30;
    daxpy_(&n, &da, v11, &incx, a4, &incx);
    da = -da;
    daxpy_(&n, &da, v12, &incx, a5, &incx);
  }
LABEL_13:
  MEMORY[0x20BD188CC](v11, 0x1000C8000313F17);
  MEMORY[0x20BD188CC](v12, 0x1000C8000313F17);
  return v22;
}

void CPMLlinearSVM::TRON::norm_inf(CPMLlinearSVM::TRON *this, int a2, double *a3)
{
  double v3;
  double *v4;
  uint64_t v5;
  double v6;
  double v7;

  v3 = fabs(*a3);
  if (a2 >= 2)
  {
    v4 = a3 + 1;
    v5 = a2 - 1;
    do
    {
      v6 = *v4++;
      v7 = fabs(v6);
      if (v7 >= v3)
        v3 = v7;
      --v5;
    }
    while (v5);
  }
}

uint64_t CPMLlinearSVM::TRON::set_print_string(uint64_t this, void (*a2)(const char *))
{
  *(_QWORD *)(this + 24) = a2;
  return this;
}

CPMLKMeansAnalysisHandler *CPMLCreateKMEANSAnalysis(int a1, int a2, double **a3, int a4, int a5, int a6, void *a7, double a8)
{
  CPMLKMeans *v16;
  CPMLKMeansAnalysisHandler *v17;

  v16 = (CPMLKMeans *)operator new();
  CPMLKMeans::CPMLKMeans(v16, a1, a2, a3, a4, a5, a8, a6, a7);
  (*(void (**)(CPMLKMeans *))(*(_QWORD *)v16 + 40))(v16);
  v17 = (CPMLKMeansAnalysisHandler *)operator new();
  CPMLKMeansAnalysisHandler::CPMLKMeansAnalysisHandler(v17, (CPMLAlgorithm *)v16);
  return v17;
}

void sub_209CFB1DC(_Unwind_Exception *a1)
{
  uint64_t v1;
  uint64_t v2;

  v2 = v1;
  MEMORY[0x20BD188E4](v2, 0xB1C40B9B0C43ELL);
  _Unwind_Resume(a1);
}

CPMLKMeansAnalysisHandler *CPMLDestroyKMEANSAnalysis(CPMLKMeansAnalysisHandler *result)
{
  if (result)
  {
    CPMLKMeansAnalysisHandler::~CPMLKMeansAnalysisHandler(result);
    JUMPOUT(0x20BD188E4);
  }
  return result;
}

uint64_t CPMLKMeansAnalysisHandler::cluster(CPMLKMeansAnalysisHandler *this, int **a2)
{
  int *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  v5 = *((_QWORD *)this + 2);
  v4 = (int *)*((_QWORD *)this + 3);
  v6 = *(_QWORD *)(v5 + 32);
  if (!v4)
  {
    v4 = (int *)operator new[]();
    *((_QWORD *)this + 3) = v4;
    if ((int)v6 >= 1)
    {
      v7 = 0;
      v8 = *((_QWORD *)this + 2) + 48;
      do
      {
        v4[v7] = *(_QWORD *)(v8 + 8 * v7);
        ++v7;
      }
      while (v6 != v7);
    }
  }
  *a2 = v4;
  return v6;
}

uint64_t CPMLKMeansAnalysisHandler::centers(CPMLKMeansAnalysisHandler *this, double **a2)
{
  uint64_t *v4;
  uint64_t v5;
  uint64_t v6;
  double *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t *v11;
  double *v12;
  uint64_t v13;
  uint64_t *v14;
  double *v15;
  uint64_t v16;

  v4 = (uint64_t *)*((_QWORD *)this + 2);
  v5 = v4[2];
  v6 = v4[3];
  v7 = (double *)*((_QWORD *)this + 4);
  if (!v7)
  {
    v8 = *v4;
    v7 = (double *)operator new[]();
    *((_QWORD *)this + 4) = v7;
    if ((int)v5 >= 1)
    {
      v9 = 0;
      v10 = 8 * (int)v6;
      v11 = &v4[(unint64_t)*(double *)&v4[v8 + 3] + v8];
      v12 = v7;
      do
      {
        v13 = v6;
        v14 = v11;
        v15 = v12;
        if ((int)v6 >= 1)
        {
          do
          {
            v16 = *v14++;
            *(_QWORD *)v15++ = v16;
            --v13;
          }
          while (v13);
        }
        ++v9;
        v12 = (double *)((char *)v12 + v10);
        v11 = (uint64_t *)((char *)v11 + v10);
      }
      while (v9 != v5);
    }
  }
  *a2 = v7;
  return (v6 * v5);
}

double CPMLTotssKMeansAnalysis(uint64_t a1)
{
  return *(double *)(*(_QWORD *)(a1 + 16) + 8 * **(_QWORD **)(a1 + 16) + 16);
}

double CPMLKMeansAnalysisHandler::totss(CPMLKMeansAnalysisHandler *this)
{
  return *(double *)(*((_QWORD *)this + 2) + 8 * **((_QWORD **)this + 2) + 16);
}

uint64_t CPMLKMeansAnalysisHandler::withinss(CPMLKMeansAnalysisHandler *this, double **a2)
{
  uint64_t *v4;
  uint64_t v5;
  double *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t *v9;

  v4 = (uint64_t *)*((_QWORD *)this + 2);
  v5 = v4[2];
  v6 = (double *)*((_QWORD *)this + 5);
  if (!v6)
  {
    v7 = *v4;
    v6 = (double *)operator new[]();
    *((_QWORD *)this + 5) = v6;
    if ((int)v5 >= 1)
    {
      v8 = 0;
      v9 = &v4[(unint64_t)*(double *)&v4[v7 + 4] + v7];
      do
      {
        *(_QWORD *)&v6[v8] = v9[v8];
        ++v8;
      }
      while (v5 != v8);
    }
  }
  *a2 = v6;
  return v5;
}

double CPMLKMeansAnalysisHandler::totalWithinss(CPMLKMeansAnalysisHandler *this)
{
  int v1;
  double *v2;
  uint64_t v3;
  double result;
  double v5;
  double *v6;

  v6 = 0;
  v1 = CPMLKMeansAnalysisHandler::withinss(this, &v6);
  if (v1 < 1)
    return 0.0;
  v2 = v6;
  v3 = v1;
  result = 0.0;
  do
  {
    v5 = *v2++;
    result = result + v5;
    --v3;
  }
  while (v3);
  return result;
}

double CPMLBetweenssKMeansAnalysis(CPMLKMeansAnalysisHandler *a1)
{
  double v1;

  v1 = *(double *)(*((_QWORD *)a1 + 2) + 8 * **((_QWORD **)a1 + 2) + 16);
  return v1 - CPMLKMeansAnalysisHandler::totalWithinss(a1);
}

double CPMLKMeansAnalysisHandler::betweenss(CPMLKMeansAnalysisHandler *this)
{
  double v1;

  v1 = *(double *)(*((_QWORD *)this + 2) + 8 * **((_QWORD **)this + 2) + 16);
  return v1 - CPMLKMeansAnalysisHandler::totalWithinss(this);
}

uint64_t CPMLKMeansAnalysisHandler::size(CPMLKMeansAnalysisHandler *this, int **a2)
{
  uint64_t v4;
  int *v5;
  uint64_t v6;
  uint64_t v7;

  v4 = *(_QWORD *)(*((_QWORD *)this + 2) + 16);
  v5 = (int *)*((_QWORD *)this + 6);
  if (!v5)
  {
    v5 = (int *)operator new[]();
    *((_QWORD *)this + 6) = v5;
    if ((int)v4 >= 1)
    {
      v6 = 0;
      v7 = *((_QWORD *)this + 2) + 8 * *(_QWORD *)(*((_QWORD *)this + 2) + 40);
      do
      {
        v5[v6] = *(_QWORD *)(v7 + 8 * v6);
        ++v6;
      }
      while (v4 != v6);
    }
  }
  *a2 = v5;
  return v4;
}

double CPMLIterKMeansAnalysis(uint64_t a1)
{
  return (double)*(unint64_t *)(*(_QWORD *)(a1 + 16) + 8);
}

double CPMLKMeansAnalysisHandler::iter(CPMLKMeansAnalysisHandler *this)
{
  return (double)*(unint64_t *)(*((_QWORD *)this + 2) + 8);
}

void CPMLKMeansAnalysisHandler::CPMLKMeansAnalysisHandler(CPMLKMeansAnalysisHandler *this, CPMLAlgorithm *a2)
{
  uint64_t v4;

  CPMLAnalysisHandler::CPMLAnalysisHandler(this);
  *(_OWORD *)(v4 + 24) = 0u;
  *(_OWORD *)(v4 + 40) = 0u;
  *(_QWORD *)v4 = off_24C255A58;
  *(_QWORD *)(v4 + 8) = a2;
  *((_QWORD *)this + 2) = (*((uint64_t (**)(CPMLAlgorithm *))a2->var0 + 11))(a2);
}

void sub_209CFB680(_Unwind_Exception *a1)
{
  void *v1;

  CPModelClose(v1);
  _Unwind_Resume(a1);
}

void CPMLKMeansAnalysisHandler::~CPMLKMeansAnalysisHandler(CPMLKMeansAnalysisHandler *this)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  *(_QWORD *)this = off_24C255A58;
  v2 = *((_QWORD *)this + 3);
  if (v2)
    MEMORY[0x20BD188E4](v2, 0x1000C4052888210);
  v3 = *((_QWORD *)this + 4);
  if (v3)
    MEMORY[0x20BD188E4](v3, 0x1000C4000313F17);
  v4 = *((_QWORD *)this + 5);
  if (v4)
    MEMORY[0x20BD188E4](v4, 0x1000C4000313F17);
  v5 = *((_QWORD *)this + 6);
  if (v5)
    MEMORY[0x20BD188E4](v5, 0x1000C4052888210);
  v6 = *((_QWORD *)this + 1);
  if (v6)
    (*(void (**)(uint64_t))(*(_QWORD *)v6 + 8))(v6);
  CPModelClose(this);
}

double CPMLKMeansAnalysisHandler::classify(CPMLKMeansAnalysisHandler *this, int a2, double *a3)
{
  uint64_t v4;
  CPMLFeatureVector *v6;
  double v7;
  double YHat;

  LODWORD(v4) = a2;
  v6 = (CPMLFeatureVector *)operator new();
  CPMLFeatureVector::CPMLFeatureVector(v6);
  if ((int)v4 >= 1)
  {
    v4 = v4;
    do
    {
      v7 = *a3++;
      CPMLFeatureVector::insertRealVClass(v6, v7);
      --v4;
    }
    while (v4);
  }
  (*(void (**)(_QWORD, CPMLFeatureVector *, _QWORD))(**((_QWORD **)this + 1) + 24))(*((_QWORD *)this + 1), v6, 0);
  YHat = CPMLFeatureVector::getYHat(v6);
  CPMLFeatureVector::~CPMLFeatureVector(v6);
  MEMORY[0x20BD188E4]();
  return YHat;
}

void sub_209CFB800(_Unwind_Exception *a1)
{
  uint64_t v1;

  MEMORY[0x20BD188E4](v1, 0x1020C4087C48359);
  _Unwind_Resume(a1);
}

double CPMLKMeansAnalysisHandler::regression(CPMLKMeansAnalysisHandler *this, int a2, double *a3)
{
  return nan("");
}

void CPMLOnlineSvm::Update(uint64_t a1, uint64_t a2, uint64_t a3)
{
  OUTLINED_FUNCTION_0("operator()", "matrix-base-impl.h", a3, "row < this->_rows && \"row index exceeds matrix dimension\"");
}

{
  OUTLINED_FUNCTION_1("operator()", "matrix-base-impl.h", a3, "col < this->_cols && \"col index exceeds matrix dimension\"");
}

void CPMLOnlineSvm::ChooseArgmaxI()
{
  __assert_rtn("ChooseArgmaxI", "online-svm.cpp", 98, "current_argmax != -1");
}

void CPLogisticRegressionClassfier::ComputeSingleGradient()
{
  __assert_rtn("ComputeSingleGradient", "CPLogisticRegression.c", 289, "responseLevel >= 0 && responseLevel <= numResponse-1");
}

{
  __assert_rtn("ComputeSingleGradient", "CPLogisticRegression.c", 290, "allBeta.size() == gradient.size()");
}

void CPLogisticRegressionClassfier::ObjectiveFunctionGradient()
{
  __assert_rtn("ObjectiveFunctionGradient", "CPLogisticRegression.c", 347, "g.v.size() == b.size()");
}

void CPLogisticRegressionClassfier::ComputeSingleHessian()
{
  __assert_rtn("ComputeSingleHessian", "CPLogisticRegression.c", 411, "allBeta.size()*allBeta.size() == hessian.size()");
}

void CPLogisticRegressionClassfier::Evaluate()
{
  __assert_rtn("Evaluate", "CPLogisticRegression.c", 577, "max_r != -1");
}

void CPMLNaiveBayes::set_decay_rate()
{
  __assert_rtn("set_decay_rate", "CPMLNaiveBayes.cpp", 78, "rate > 0");
}

{
  __assert_rtn("set_decay_rate", "CPMLNaiveBayes.cpp", 79, "rate <= 1");
}

void CPMLNaiveBayes::set_epsilon_rate()
{
  __assert_rtn("set_epsilon_rate", "CPMLNaiveBayes.cpp", 94, "rate >= 0");
}

void CPMLNaiveBayes::set_smooth_rate()
{
  __assert_rtn("set_smooth_rate", "CPMLNaiveBayes.cpp", 87, "rate >= 0");
}

void CPMLNaiveBayes::CPMLNaiveBayes()
{
  __assert_rtn("CPMLNaiveBayes", "CPMLNaiveBayes.cpp", 61, "nullptr != idb");
}

void NSLog(NSString *format, ...)
{
  MEMORY[0x24BDD1000](format);
}

void _Block_object_dispose(const void *a1, const int a2)
{
  MEMORY[0x24BDAC730](a1, *(_QWORD *)&a2);
}

void _Unwind_Resume(_Unwind_Exception *exception_object)
{
  MEMORY[0x24BDAC780](exception_object);
}

uint64_t CoreOptimization::BFGS::GetSolution(CoreOptimization::BFGS *this)
{
  return MEMORY[0x24BE1F810](this);
}

uint64_t CoreOptimization::BFGS::Optimize(CoreOptimization::BFGS *this)
{
  return MEMORY[0x24BE1F818](this);
}

const std::locale::facet *__cdecl std::locale::use_facet(const std::locale *this, std::locale::id *a2)
{
  return (const std::locale::facet *)MEMORY[0x24BEDAA60](this, a2);
}

std::locale std::ios_base::getloc(const std::ios_base *this)
{
  return (std::locale)MEMORY[0x24BEDAA70](this);
}

std::logic_error *__cdecl std::logic_error::logic_error(std::logic_error *this, const char *a2)
{
  return (std::logic_error *)MEMORY[0x24BEDAAA8](this, a2);
}

std::bad_array_new_length *__cdecl std::bad_array_new_length::bad_array_new_length(std::bad_array_new_length *this)
{
  return (std::bad_array_new_length *)MEMORY[0x24BEDABB0](this);
}

size_t std::__next_prime(size_t __n)
{
  return MEMORY[0x24BEDABE8](__n);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s)
{
  return (std::string *)MEMORY[0x24BEDAC38](this, __s);
}

std::string *__cdecl std::string::append(std::string *this, const std::string::value_type *__s, std::string::size_type __n)
{
  return (std::string *)MEMORY[0x24BEDAC40](this, __s, __n);
}

uint64_t std::filebuf::open()
{
  return MEMORY[0x24BEDADD8]();
}

uint64_t std::filebuf::close()
{
  return MEMORY[0x24BEDADE0]();
}

uint64_t std::filebuf::basic_filebuf()
{
  return MEMORY[0x24BEDADF0]();
}

uint64_t std::filebuf::~filebuf()
{
  return MEMORY[0x24BEDADF8]();
}

uint64_t std::istream::~istream()
{
  return MEMORY[0x24BEDAE70]();
}

uint64_t std::istream::operator>>()
{
  return MEMORY[0x24BEDAE80]();
}

{
  return MEMORY[0x24BEDAE90]();
}

{
  return MEMORY[0x24BEDAEA8]();
}

uint64_t std::ostream::put()
{
  return MEMORY[0x24BEDAEE0]();
}

uint64_t std::ostream::flush()
{
  return MEMORY[0x24BEDAEE8]();
}

uint64_t std::ostream::write()
{
  return MEMORY[0x24BEDAEF0]();
}

uint64_t std::ostream::sentry::sentry()
{
  return MEMORY[0x24BEDAEF8]();
}

uint64_t std::ostream::sentry::~sentry()
{
  return MEMORY[0x24BEDAF00]();
}

uint64_t std::ostream::~ostream()
{
  return MEMORY[0x24BEDAF10]();
}

uint64_t std::ostream::operator<<()
{
  return MEMORY[0x24BEDAF30]();
}

{
  return MEMORY[0x24BEDAF48]();
}

{
  return MEMORY[0x24BEDAF58]();
}

{
  return MEMORY[0x24BEDAF60]();
}

uint64_t std::ofstream::open()
{
  return MEMORY[0x24BEDB018]();
}

void std::locale::~locale(std::locale *this)
{
  MEMORY[0x24BEDB448](this);
}

void std::ios_base::__set_badbit_and_consider_rethrow(std::ios_base *this)
{
  MEMORY[0x24BEDB500](this);
}

void std::ios_base::init(std::ios_base *this, void *__sb)
{
  MEMORY[0x24BEDB518](this, __sb);
}

void std::ios_base::clear(std::ios_base *this, std::ios_base::iostate __state)
{
  MEMORY[0x24BEDB530](this, *(_QWORD *)&__state);
}

uint64_t std::ios::~ios()
{
  return MEMORY[0x24BEDB5E8]();
}

void std::terminate(void)
{
  MEMORY[0x24BEDB6C0]();
}

uint64_t operator delete[]()
{
  return off_24C254868();
}

void operator delete(void *__p)
{
  off_24C254870(__p);
}

uint64_t operator delete()
{
  return off_24C254878();
}

uint64_t operator<<()
{
  return MEMORY[0x24BE1F820]();
}

{
  return MEMORY[0x24BE1F828]();
}

{
  return MEMORY[0x24BE1F830]();
}

uint64_t operator new[]()
{
  return off_24C254898();
}

void *__cdecl operator new(size_t __sz)
{
  return (void *)off_24C2548A0(__sz);
}

uint64_t operator new()
{
  return off_24C2548A8();
}

void __assert_rtn(const char *a1, const char *a2, int a3, const char *a4)
{
  MEMORY[0x24BDAC7A0](a1, a2, *(_QWORD *)&a3, a4);
}

void *__cxa_allocate_exception(size_t thrown_size)
{
  return (void *)MEMORY[0x24BEDB8F8](thrown_size);
}

int __cxa_atexit(void (*lpfunc)(void *), void *obj, void *lpdso_handle)
{
  return MEMORY[0x24BDAC7B0](lpfunc, obj, lpdso_handle);
}

void *__cxa_begin_catch(void *a1)
{
  return (void *)MEMORY[0x24BEDB910](a1);
}

void __cxa_end_catch(void)
{
  MEMORY[0x24BEDB928]();
}

void __cxa_free_exception(void *a1)
{
  MEMORY[0x24BEDB930](a1);
}

void __cxa_guard_abort(__guard *a1)
{
  MEMORY[0x24BEDB940](a1);
}

int __cxa_guard_acquire(__guard *a1)
{
  return MEMORY[0x24BEDB948](a1);
}

void __cxa_guard_release(__guard *a1)
{
  MEMORY[0x24BEDB950](a1);
}

void __cxa_throw(void *a1, struct type_info *lptinfo, void (*a3)(void *))
{
  MEMORY[0x24BEDB960](a1, lptinfo, a3);
}

uint32_t arc4random_uniform(uint32_t __upper_bound)
{
  return MEMORY[0x24BDAD170](*(_QWORD *)&__upper_bound);
}

void bzero(void *a1, size_t a2)
{
  MEMORY[0x24BDAD320](a1, a2);
}

int close(int a1)
{
  return MEMORY[0x24BDAD9D8](*(_QWORD *)&a1);
}

int daxpy_(int *n, double *da, double *dx, int *incx, double *dy, int *incy)
{
  return MEMORY[0x24BDB2C60](n, da, dx, incx, dy, incy);
}

double ddot_(int *n, double *dx, int *incx, double *dy, int *incy)
{
  double result;

  MEMORY[0x24BDB2C70](n, dx, incx, dy, incy);
  return result;
}

int dgetrf_(__CLPK_integer *__m, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_integer *__info)
{
  return MEMORY[0x24BDB2D38](__m, __n, __a, __lda, __ipiv, __info);
}

int dgetri_(__CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_integer *__ipiv, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x24BDB2D48](__n, __a, __lda, __ipiv, __work, __lwork, __info);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  MEMORY[0x24BDADC70](iterations, queue, block);
}

void dispatch_async(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADCC0](queue, block);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  return (dispatch_queue_global_t)MEMORY[0x24BDADDA8](identifier, flags);
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)MEMORY[0x24BDADED0](label, attr);
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  MEMORY[0x24BDADFE8](queue, block);
}

double dnrm2_(int *n, double *x, int *incx)
{
  double result;

  MEMORY[0x24BDB2DA0](n, x, incx);
  return result;
}

int dppsv_(char *__uplo, __CLPK_integer *__n, __CLPK_integer *__nrhs, __CLPK_doublereal *__ap, __CLPK_doublereal *__b, __CLPK_integer *__ldb, __CLPK_integer *__info)
{
  return MEMORY[0x24BDB2DF8](__uplo, __n, __nrhs, __ap, __b, __ldb, __info);
}

int dscal_(int *n, double *da, double *dx, int *incx)
{
  return MEMORY[0x24BDB2E08](n, da, dx, incx);
}

int dsyev_(char *__jobz, char *__uplo, __CLPK_integer *__n, __CLPK_doublereal *__a, __CLPK_integer *__lda, __CLPK_doublereal *__w, __CLPK_doublereal *__work, __CLPK_integer *__lwork, __CLPK_integer *__info)
{
  return MEMORY[0x24BDB2E28](__jobz, __uplo, __n, __a, __lda, __w, __work, __lwork);
}

void exit(int a1)
{
  MEMORY[0x24BDAE268](*(_QWORD *)&a1);
}

long double exp(long double __x)
{
  long double result;

  MEMORY[0x24BDAE270](__x);
  return result;
}

int fclose(FILE *a1)
{
  return MEMORY[0x24BDAE2E0](a1);
}

int ferror(FILE *a1)
{
  return MEMORY[0x24BDAE330](a1);
}

int fflush(FILE *a1)
{
  return MEMORY[0x24BDAE350](a1);
}

char *__cdecl fgets(char *a1, int a2, FILE *a3)
{
  return (char *)MEMORY[0x24BDAE380](a1, *(_QWORD *)&a2, a3);
}

FILE *__cdecl fopen(const char *__filename, const char *__mode)
{
  return (FILE *)MEMORY[0x24BDAE410](__filename, __mode);
}

int fprintf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE428](a1, a2);
}

int fputc(int a1, FILE *a2)
{
  return MEMORY[0x24BDAE438](*(_QWORD *)&a1, a2);
}

int fputs(const char *a1, FILE *a2)
{
  return MEMORY[0x24BDAE440](a1, a2);
}

void free(void *a1)
{
  MEMORY[0x24BDAE450](a1);
}

int fscanf(FILE *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAE4C8](a1, a2);
}

int fseek(FILE *a1, uint64_t a2, int a3)
{
  return MEMORY[0x24BDAE4D8](a1, a2, *(_QWORD *)&a3);
}

uint64_t ftell(FILE *a1)
{
  return MEMORY[0x24BDAE530](a1);
}

size_t fwrite(const void *__ptr, size_t __size, size_t __nitems, FILE *__stream)
{
  return MEMORY[0x24BDAE590](__ptr, __size, __nitems, __stream);
}

int getc(FILE *a1)
{
  return MEMORY[0x24BDAE5C8](a1);
}

long double lgamma(long double __x)
{
  long double result;

  MEMORY[0x24BDAEA50](__x);
  return result;
}

long double log(long double __x)
{
  long double result;

  MEMORY[0x24BDAEAA8](__x);
  return result;
}

void *__cdecl malloc_type_calloc(size_t count, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED70](count, size, type_id);
}

void *__cdecl malloc_type_malloc(size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED78](size, type_id);
}

void *__cdecl malloc_type_realloc(void *ptr, size_t size, malloc_type_id_t type_id)
{
  return (void *)MEMORY[0x24BDAED88](ptr, size, type_id);
}

int memcmp(const void *__s1, const void *__s2, size_t __n)
{
  return MEMORY[0x24BDAEE78](__s1, __s2, __n);
}

void *__cdecl memcpy(void *__dst, const void *__src, size_t __n)
{
  return (void *)MEMORY[0x24BDAEE80](__dst, __src, __n);
}

void *__cdecl memmove(void *__dst, const void *__src, size_t __len)
{
  return (void *)MEMORY[0x24BDAEE98](__dst, __src, __len);
}

void *__cdecl memset(void *__b, int __c, size_t __len)
{
  return (void *)MEMORY[0x24BDAEEA8](__b, *(_QWORD *)&__c, __len);
}

void memset_pattern16(void *__b, const void *__pattern16, size_t __len)
{
  MEMORY[0x24BDAEEB0](__b, __pattern16, __len);
}

void *__cdecl mmap(void *a1, size_t a2, int a3, int a4, int a5, off_t a6)
{
  return (void *)MEMORY[0x24BDAEFA8](a1, a2, *(_QWORD *)&a3, *(_QWORD *)&a4, *(_QWORD *)&a5, a6);
}

int munmap(void *a1, size_t a2)
{
  return MEMORY[0x24BDAEFF0](a1, a2);
}

double nan(const char *a1)
{
  double result;

  MEMORY[0x24BDAEFF8](a1);
  return result;
}

float nanf(const char *a1)
{
  float result;

  MEMORY[0x24BDAF000](a1);
  return result;
}

long double nanl(const char *a1)
{
  long double result;

  MEMORY[0x24BDAF008](a1);
  return result;
}

id objc_alloc(Class a1)
{
  return (id)MEMORY[0x24BEDCF68](a1);
}

uint64_t objc_alloc_init()
{
  return MEMORY[0x24BEDCF88]();
}

id objc_autoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDCFD0](a1);
}

uint64_t objc_claimAutoreleasedReturnValue()
{
  return MEMORY[0x24BEDCFE8]();
}

void objc_enumerationMutation(id obj)
{
  MEMORY[0x24BEDD068](obj);
}

id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic)
{
  return (id)MEMORY[0x24BEDD0B0](self, _cmd, offset, atomic);
}

id objc_msgSendSuper2(objc_super *a1, SEL a2, ...)
{
  return (id)MEMORY[0x24BEDD120](a1, a2);
}

uint64_t objc_opt_class()
{
  return MEMORY[0x24BEDD130]();
}

uint64_t objc_opt_isKindOfClass()
{
  return MEMORY[0x24BEDD138]();
}

uint64_t objc_opt_new()
{
  return MEMORY[0x24BEDD148]();
}

uint64_t objc_opt_respondsToSelector()
{
  return MEMORY[0x24BEDD160]();
}

void objc_release(id a1)
{
  MEMORY[0x24BEDD188](a1);
}

id objc_retain(id a1)
{
  return (id)MEMORY[0x24BEDD2A0](a1);
}

id objc_retainAutorelease(id a1)
{
  return (id)MEMORY[0x24BEDD2A8](a1);
}

id objc_retainAutoreleaseReturnValue(id a1)
{
  return (id)MEMORY[0x24BEDD2B0](a1);
}

void objc_setProperty_atomic(id self, SEL _cmd, id newValue, ptrdiff_t offset)
{
  MEMORY[0x24BEDD3D0](self, _cmd, newValue, offset);
}

void objc_storeStrong(id *location, id obj)
{
  MEMORY[0x24BEDD410](location, obj);
}

int open(const char *a1, int a2, ...)
{
  return MEMORY[0x24BDAF228](a1, *(_QWORD *)&a2);
}

long double pow(long double __x, long double __y)
{
  long double result;

  MEMORY[0x24BDAF688](__x, __y);
  return result;
}

int printf(const char *a1, ...)
{
  return MEMORY[0x24BDAF6A8](a1);
}

int pthread_mutex_destroy(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8C0](a1);
}

int pthread_mutex_init(pthread_mutex_t *a1, const pthread_mutexattr_t *a2)
{
  return MEMORY[0x24BDAF8C8](a1, a2);
}

int pthread_mutex_lock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8D0](a1);
}

int pthread_mutex_unlock(pthread_mutex_t *a1)
{
  return MEMORY[0x24BDAF8E0](a1);
}

int pthread_mutexattr_destroy(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8E8](a1);
}

int pthread_mutexattr_init(pthread_mutexattr_t *a1)
{
  return MEMORY[0x24BDAF8F0](a1);
}

int pthread_mutexattr_settype(pthread_mutexattr_t *a1, int a2)
{
  return MEMORY[0x24BDAF908](a1, *(_QWORD *)&a2);
}

qos_class_t qos_class_self(void)
{
  return MEMORY[0x24BDAFA10]();
}

void qsort(void *__base, size_t __nel, size_t __width, int (__cdecl *__compar)(const void *, const void *))
{
  MEMORY[0x24BDAFA18](__base, __nel, __width, __compar);
}

int rand(void)
{
  return MEMORY[0x24BDAFA38]();
}

char *__cdecl setlocale(int a1, const char *a2)
{
  return (char *)MEMORY[0x24BDAFD40](*(_QWORD *)&a1, a2);
}

int sprintf(char *a1, const char *a2, ...)
{
  return MEMORY[0x24BDAFE60](a1, a2);
}

int sqlite3_bind_blob(sqlite3_stmt *a1, int a2, const void *a3, int n, void (__cdecl *a5)(void *))
{
  return MEMORY[0x24BEDDF48](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&n, a5);
}

int sqlite3_bind_double(sqlite3_stmt *a1, int a2, double a3)
{
  return MEMORY[0x24BEDDF58](a1, *(_QWORD *)&a2, a3);
}

int sqlite3_bind_int(sqlite3_stmt *a1, int a2, int a3)
{
  return MEMORY[0x24BEDDF60](a1, *(_QWORD *)&a2, *(_QWORD *)&a3);
}

int sqlite3_bind_text(sqlite3_stmt *a1, int a2, const char *a3, int a4, void (__cdecl *a5)(void *))
{
  return MEMORY[0x24BEDDF98](a1, *(_QWORD *)&a2, a3, *(_QWORD *)&a4, a5);
}

int sqlite3_close(sqlite3 *a1)
{
  return MEMORY[0x24BEDE010](a1);
}

const void *__cdecl sqlite3_column_blob(sqlite3_stmt *a1, int iCol)
{
  return (const void *)MEMORY[0x24BEDE020](a1, *(_QWORD *)&iCol);
}

int sqlite3_column_bytes(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x24BEDE028](a1, *(_QWORD *)&iCol);
}

double sqlite3_column_double(sqlite3_stmt *a1, int iCol)
{
  double result;

  MEMORY[0x24BEDE048](a1, *(_QWORD *)&iCol);
  return result;
}

int sqlite3_column_int(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x24BEDE050](a1, *(_QWORD *)&iCol);
}

sqlite3_int64 sqlite3_column_int64(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x24BEDE058](a1, *(_QWORD *)&iCol);
}

const unsigned __int8 *__cdecl sqlite3_column_text(sqlite3_stmt *a1, int iCol)
{
  return (const unsigned __int8 *)MEMORY[0x24BEDE068](a1, *(_QWORD *)&iCol);
}

int sqlite3_column_type(sqlite3_stmt *a1, int iCol)
{
  return MEMORY[0x24BEDE078](a1, *(_QWORD *)&iCol);
}

int sqlite3_exec(sqlite3 *a1, const char *sql, int (__cdecl *callback)(void *, int, char **, char **), void *a4, char **errmsg)
{
  return MEMORY[0x24BEDE118](a1, sql, callback, a4, errmsg);
}

int sqlite3_finalize(sqlite3_stmt *pStmt)
{
  return MEMORY[0x24BEDE140](pStmt);
}

void sqlite3_free(void *a1)
{
  MEMORY[0x24BEDE148](a1);
}

char *sqlite3_mprintf(const char *a1, ...)
{
  return (char *)MEMORY[0x24BEDE1A8](a1);
}

int sqlite3_open(const char *filename, sqlite3 **ppDb)
{
  return MEMORY[0x24BEDE1B8](filename, ppDb);
}

int sqlite3_prepare_v2(sqlite3 *db, const char *zSql, int nByte, sqlite3_stmt **ppStmt, const char **pzTail)
{
  return MEMORY[0x24BEDE1D0](db, zSql, *(_QWORD *)&nByte, ppStmt, pzTail);
}

int sqlite3_reset(sqlite3_stmt *pStmt)
{
  return MEMORY[0x24BEDE1E0](pStmt);
}

int sqlite3_step(sqlite3_stmt *a1)
{
  return MEMORY[0x24BEDE2A8](a1);
}

void srand(unsigned int a1)
{
  MEMORY[0x24BDAFE80](*(_QWORD *)&a1);
}

char *__cdecl strcat(char *__s1, const char *__s2)
{
  return (char *)MEMORY[0x24BDAFEE0](__s1, __s2);
}

int strcmp(const char *__s1, const char *__s2)
{
  return MEMORY[0x24BDAFEF0](__s1, __s2);
}

char *__cdecl strdup(const char *__s1)
{
  return (char *)MEMORY[0x24BDAFF10](__s1);
}

size_t strlcpy(char *__dst, const char *__source, size_t __size)
{
  return MEMORY[0x24BDAFF38](__dst, __source, __size);
}

size_t strlen(const char *__s)
{
  return MEMORY[0x24BDAFF40](__s);
}

char *__cdecl strrchr(char *__s, int __c)
{
  return (char *)MEMORY[0x24BDAFFA8](__s, *(_QWORD *)&__c);
}

double strtod(const char *a1, char **a2)
{
  double result;

  MEMORY[0x24BDAFFD0](a1, a2);
  return result;
}

char *__cdecl strtok(char *__str, const char *__sep)
{
  return (char *)MEMORY[0x24BDAFFF0](__str, __sep);
}

uint64_t strtol(const char *__str, char **__endptr, int __base)
{
  return MEMORY[0x24BDB0000](__str, __endptr, *(_QWORD *)&__base);
}

long double tanh(long double __x)
{
  long double result;

  MEMORY[0x24BDB0148](__x);
  return result;
}

time_t time(time_t *a1)
{
  return MEMORY[0x24BDB0240](a1);
}

void vDSP_dotprD(const double *__A, vDSP_Stride __IA, const double *__B, vDSP_Stride __IB, double *__C, vDSP_Length __N)
{
  MEMORY[0x24BDB31D8](__A, __IA, __B, __IB, __C, __N);
}

int vsnprintf(char *__str, size_t __size, const char *__format, va_list a4)
{
  return MEMORY[0x24BDB0448](__str, __size, __format, a4);
}

int vsprintf(char *a1, const char *a2, va_list a3)
{
  return MEMORY[0x24BDB0458](a1, a2, a3);
}

ssize_t write(int __fd, const void *__buf, size_t __nbyte)
{
  return MEMORY[0x24BDB0558](*(_QWORD *)&__fd, __buf, __nbyte);
}

