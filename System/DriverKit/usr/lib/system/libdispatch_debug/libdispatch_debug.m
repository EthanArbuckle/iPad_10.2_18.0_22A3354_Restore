void _os_eventlink_xref_dispose(unsigned int *a1)
{
  _os_object_release_internal(a1);
}

void _os_eventlink_explicit_dispose(void *a1)
{
  _os_eventlink_dispose((uint64_t)a1);
  free(a1);
}

void _os_eventlink_dispose(uint64_t a1)
{
  if ((*(_QWORD *)(a1 + 24) & 1) != 0)
    free(*(void **)(a1 + 16));
  if (*(_DWORD *)(a1 + 32) && *(_DWORD *)(a1 + 32) != -1)
    mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 32));
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != -1)
      mach_port_deallocate(mach_task_self_, *(_DWORD *)(a1 + 36));
  }
}

_QWORD *os_eventlink_create(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
}

_QWORD *_os_eventlink_create_internal(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  const char *v9;
  _QWORD *v10;

  v10 = _os_object_alloc(_OS_os_eventlink_vtable, 0x30uLL, a3, a4, a5, a6, a7, a8);
  if (v10)
  {
    if (a1)
    {
      v9 = _dispatch_strdup_if_mutable(a1);
      if (v9 != a1)
        v10[3] |= 1uLL;
      v10[2] = v9;
    }
    return v10;
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return 0;
  }
}

uint64_t os_eventlink_activate(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;
  unint64_t v3;
  unsigned int v5;
  _QWORD __b[6];
  unsigned int v7;
  uint64_t v8;
  uint64_t v10;
  uint64_t v11;

  v8 = a1;
  v7 = 0;
  if (!*(_DWORD *)(a1 + 32) || *(_DWORD *)(v8 + 32) == -1)
  {
    if (_os_eventlink_is_cancelled(*(_QWORD *)(v8 + 24)))
    {
      v7 = 89;
      v10 = 1;
      v11 = 1;
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return v7;
    }
    else
    {
      memset(__b, 0, sizeof(__b));
      v5 = mach_eventlink_create(mach_task_self_, 1, &__b[4]);
      if (v5)
        return _mach_error_to_errno(v5);
      v1 = (unint64_t *)(v8 + 32);
      v2 = __b[4];
      do
        v3 = __ldaxr(v1);
      while (!v3 && __stlxr(v2, v1));
      if (!v3)
      {
        return _mach_error_to_errno(v5);
      }
      else
      {
        if (LODWORD(__b[4]) && LODWORD(__b[4]) != -1)
          mach_port_deallocate(mach_task_self_, __b[4]);
        if (HIDWORD(__b[4]) && HIDWORD(__b[4]) != -1)
          mach_port_deallocate(mach_task_self_, HIDWORD(__b[4]));
        return 22;
      }
    }
  }
  else
  {
    return v7;
  }
}

BOOL _os_eventlink_is_cancelled(char a1)
{
  return (a1 & 2) == 2;
}

uint64_t _mach_error_to_errno(unsigned int a1)
{
  if (a1 <= 0x31uLL)
    __asm { BR              X8 }
  return 0xFFFFFFFFLL;
}

uint64_t os_eventlink_extract_remote_port(uint64_t a1, unsigned int *a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v5;
  unsigned int v6;

  if (!_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
      return 89;
    }
    v6 = *(_DWORD *)(a1 + 36);
    do
    {
      v2 = v6;
      v5 = (unsigned int *)(a1 + 36);
      do
        v3 = __ldaxr(v5);
      while (v3 == v6 && __stlxr(0, v5));
      v6 = v3;
    }
    while (v3 != v2);
    if (v3 && v3 != -1)
    {
      *a2 = v3;
      return 0;
    }
  }
  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 22;
}

BOOL _os_eventlink_inactive(int a1)
{
  return a1 == 0;
}

_QWORD *os_eventlink_create_with_port(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;
  uint64_t v10;
  _QWORD *internal;
  mach_port_name_t v12;

  v12 = a2;
  internal = _os_eventlink_create_internal(a1, a2, a3, a4, a5, a6, a7, a8);
  if (!internal)
    return 0;
  if (mach_port_mod_refs(mach_task_self_, v12, 0, 1))
  {
    v10 = _os_assert_log(0);
    _os_crash(v10);
    __break(1u);
  }
  if (*((_DWORD *)internal + 8))
  {
    v9 = _os_assert_log(*((_DWORD *)internal + 8) == 0);
    _os_crash(v9);
    __break(1u);
  }
  *((_DWORD *)internal + 8) = v12;
  return internal;
}

_QWORD *os_eventlink_create_remote_with_eventlink(const char *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v9;
  int v10;
  mach_port_name_t name;
  uint64_t v12;
  const char *v13;
  uint64_t v15;
  uint64_t v16;
  unint64_t StatusReg;

  v13 = a1;
  v12 = a2;
  name = 0;
  v10 = os_eventlink_extract_remote_port(a2, &name);
  if (v10)
  {
    v15 = 1;
    v16 = 1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = v10;
    return 0;
  }
  else
  {
    v9 = os_eventlink_create_with_port(v13, name, v2, v3, v4, v5, v6, v7);
    mach_port_mod_refs(mach_task_self_, name, 0, -1);
    return v9;
  }
}

uint64_t os_eventlink_associate(uint64_t a1, uint64_t a2)
{
  unsigned int v3;
  unsigned int v4;

  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    if (a2 == 1)
      v3 = 0;
    else
      v3 = _dispatch_thread_getspecific(3uLL);
    v4 = mach_eventlink_associate(*(unsigned int *)(a1 + 32), v3, 0, 0, 0, 0, a2 == 1);
    return _mach_error_to_errno(v4);
  }
}

void *_dispatch_thread_getspecific(pthread_key_t a1)
{
  char v1;
  char v2;

  if (v1)
    v2 = 1;
  else
    v2 = 0;
  if ((v2 & 1) != 0)
    return pthread_getspecific(a1);
  else
    return *(void **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * a1);
}

uint64_t os_eventlink_disassociate(uint64_t a1)
{
  unsigned int v2;

  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
  {
    return 0;
  }
  else
  {
    v2 = mach_eventlink_disassociate(*(unsigned int *)(a1 + 32), 0);
    if (v2 == 37)
      return 0;
    else
      return _mach_error_to_errno(v2);
  }
}

uint64_t os_eventlink_wait_until(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v6;

  v6 = _os_clockid_normalize_to_machabs(a2, a3);
  v4 = mach_absolute_time();
  return os_eventlink_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t _os_clockid_normalize_to_machabs(int a1, uint64_t a2)
{
  uint64_t v3;

  v3 = 0;
  if (a1 == 32)
    return a2;
  return v3;
}

uint64_t os_eventlink_wait_until_internal(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;

  if (a2 != 32)
  {
    v8 = _os_assert_log(a2 == 32);
    _os_crash(v8);
    __break(1u);
  }
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 40);
    v7 = mach_eventlink_wait_until(*(unsigned int *)(a1 + 32), a1 + 40, 0, 1, a3);
    if (v7 || !a4)
    {
      if (v7 == 15 && !_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
      {
        v5 = _os_assert_log(0);
        _os_crash(v5);
        __break(1u);
      }
    }
    else
    {
      *a4 = *(_QWORD *)(a1 + 40) - v6;
    }
    return _mach_error_to_errno(v7);
  }
}

uint64_t os_eventlink_wait(uint64_t a1, _QWORD *a2)
{
  return os_eventlink_wait_until_internal(a1, 32, 0, a2);
}

uint64_t os_eventlink_signal(uint64_t a1)
{
  unsigned int v2;

  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    v2 = mach_eventlink_signal(*(unsigned int *)(a1 + 32), 0);
    return _mach_error_to_errno(v2);
  }
}

uint64_t os_eventlink_signal_and_wait(uint64_t a1, _QWORD *a2)
{
  return os_eventlink_signal_and_wait_until_internal(a1, 32, 0, a2);
}

uint64_t os_eventlink_signal_and_wait_until_internal(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;

  if (a2 != 32)
  {
    v7 = _os_assert_log(a2 == 32);
    _os_crash(v7);
    __break(1u);
  }
  if (_os_eventlink_inactive(*(_DWORD *)(a1 + 32)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 22;
  }
  else if (_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 89;
    return 89;
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 40);
    v8 = mach_eventlink_signal_wait_until(*(unsigned int *)(a1 + 32), a1 + 40, 0, 0, 1, a3);
    if (v8 || !a4)
    {
      if (v8 == 15 && !_os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24)))
      {
        v5 = _os_assert_log(0);
        _os_crash(v5);
        __break(1u);
      }
    }
    else
    {
      *a4 = *(_QWORD *)(a1 + 40) - v6;
    }
    return _mach_error_to_errno(v8);
  }
}

uint64_t os_eventlink_signal_and_wait_until(uint64_t a1, int a2, uint64_t a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v6;

  v6 = _os_clockid_normalize_to_machabs(a2, a3);
  v4 = mach_absolute_time();
  return os_eventlink_signal_and_wait_until_internal(a1, a2, v4 + v6, a4);
}

uint64_t os_eventlink_cancel(uint64_t a1)
{
  uint64_t result;
  unint64_t v2;
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t v6;
  mach_port_name_t name;

  result = _os_eventlink_is_cancelled(*(_QWORD *)(a1 + 24));
  if ((result & 1) == 0)
  {
    v4 = (unint64_t *)(a1 + 24);
    v5 = *(_QWORD *)(a1 + 24);
    do
    {
      v2 = v5;
      do
        v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 | 2, v4));
      v5 = v3;
    }
    while (v3 != v2);
    name = *(_DWORD *)(a1 + 32);
    if (name && name != -1)
    {
      if (mach_port_mod_refs(mach_task_self_, name, 0, 1))
      {
        v6 = _os_assert_log(0);
        _os_crash(v6);
        __break(1u);
      }
      return mach_eventlink_destroy(name);
    }
  }
  return result;
}

void _os_workgroup_explicit_xref_dispose(unsigned int *a1)
{
  _os_workgroup_xref_dispose((uint64_t)a1);
  _os_object_release_internal(a1);
}

void _os_workgroup_explicit_dispose(void *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _os_workgroup_dispose((uint64_t)a1, a2, a3, a4, a5, a6, a7, a8);
  free(a1);
}

void _os_workgroup_interval_explicit_xref_dispose(unsigned int *a1)
{
  _os_workgroup_interval_xref_dispose((uint64_t)a1);
  _os_workgroup_explicit_xref_dispose(a1);
}

void _os_workgroup_interval_explicit_dispose(void *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _os_workgroup_interval_dispose((uint64_t)a1);
  _os_workgroup_explicit_dispose(a1, v1, v2, v3, v4, v5, v6, v7);
}

void _os_workgroup_xref_dispose(uint64_t a1)
{
  void (**v1)(_QWORD);

  v1 = *(void (***)(_QWORD))(a1 + 48);
  if (v1)
  {
    v1[1](*v1);
    free(v1);
  }
}

uint64_t _os_workgroup_interval_xref_dispose(uint64_t result)
{
  if ((*(_QWORD *)(result + 24) & 8) != 0)
  {
    _os_crash("BUG IN CLIENT: Releasing last reference to workgroup interval while an interval has been started");
    __break(1u);
    JUMPOUT(0x2D50);
  }
  return result;
}

void _os_workgroup_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  BOOL v9;
  uint64_t v10;

  if (*(_DWORD *)(a1 + 60))
    _dispatch_abort(165, *(_DWORD *)(a1 + 60) == 0, a3, a4, a5, a6, a7, a8);
  v10 = *(_QWORD *)(a1 + 24);
  if (_os_workgroup_has_backing_workinterval(a1))
  {
    v8 = mach_port_mod_refs(mach_task_self_, *(_DWORD *)(a1 + 40), 0, -1) == 0;
    if (!v8)
      _os_assumes_log(v8);
    if (_os_workgroup_is_configurable(v10))
    {
      v9 = work_interval_destroy(*(_QWORD *)(a1 + 32)) == 0;
      if (!v9)
        _os_assumes_log(v9);
    }
  }
  if ((v10 & 4) != 0)
    free(*(void **)(a1 + 16));
}

BOOL _os_workgroup_has_backing_workinterval(uint64_t a1)
{
  return *(_DWORD *)(a1 + 40) != 0;
}

BOOL _os_workgroup_is_configurable(char a1)
{
  return (a1 & 1) == 1;
}

uint64_t _os_workgroup_interval_dispose(uint64_t a1)
{
  return work_interval_instance_free(*(_QWORD *)(a1 + 72));
}

uint64_t _os_workgroup_tsd_cleanup(uint64_t result)
{
  char v1[512];

  if (result)
  {
    __snprintf_chk(v1, 0x200uLL, 0, 0x200uLL, "BUG IN CLIENT: Thread exiting without leaving workgroup '%s'", *(const char **)(result + 16));
    _os_crash(v1);
    __break(1u);
    JUMPOUT(0x2FF4);
  }
  return result;
}

void _os_workgroup_join_token_tsd_cleanup(uint64_t a1)
{
  uint64_t v1;

  if (a1)
  {
    if (*(_QWORD *)(a1 + 8))
    {
      v1 = _os_assert_log(*(_QWORD *)(a1 + 8) == 0);
      _os_crash(v1);
      __break(1u);
    }
    _os_workgroup_leave_update_wg(*(_DWORD **)(a1 + 16));
    free((void *)a1);
  }
}

void _os_workgroup_leave_update_wg(_DWORD *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;

  if (_os_workgroup_get_current() != a1)
  {
    v5 = _os_assert_log(0);
    _os_crash(v5);
    __break(1u);
  }
  v3 = a1 + 15;
  v4 = a1[15];
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    v4 = v2;
  }
  while (v2 != v1);
  if (!v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Joined count underflowed";
    __break(1u);
  }
  _os_workgroup_set_current(0);
}

uint64_t _workgroup_init()
{
  return pthread_install_workgroup_functions_np(&_os_workgroup_pthread_functions);
}

uint64_t _os_workgroup_get_backing_workinterval(uint64_t a1)
{
  if (a1 && _os_workgroup_has_backing_workinterval(a1))
    return *(unsigned int *)(a1 + 40);
  else
    return 0;
}

uint64_t os_workgroup_interval_data_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  if (!_os_workgroup_client_interval_data_is_valid(a1) || (a2 & 0xFFFFFFFE) != 0)
    return 22;
  else
    a1[1] = a2;
  return v3;
}

BOOL _os_workgroup_client_interval_data_is_valid(_DWORD *a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
    return _os_workgroup_client_interval_data_initialized(a1);
  return v2;
}

uint64_t os_workgroup_interval_data_set_telemetry(uint64_t a1, __int16 a2, uint64_t a3, uint64_t a4)
{
  if (_os_workgroup_telemetry_flavor_is_valid(a2) && (a2 != 1 || a4 == 40))
  {
    *(_WORD *)(a1 + 16) = a2;
    *(_QWORD *)(a1 + 8) = a3;
    *(_WORD *)(a1 + 18) = a4;
    return 0;
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

BOOL _os_workgroup_telemetry_flavor_is_valid(__int16 a1)
{
  return a1 == 1;
}

uint64_t os_workgroup_attr_set_interval_type(uint64_t a1, unsigned __int16 a2)
{
  unsigned int v3;

  v3 = 0;
  if (_os_workgroup_client_attr_is_valid((_DWORD *)a1) && _os_workgroup_type_is_interval_type(a2))
    *(_WORD *)(a1 + 8) = a2;
  else
    return 22;
  return v3;
}

BOOL _os_workgroup_client_attr_is_valid(_DWORD *a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
    return _os_workgroup_client_attr_initialized(a1);
  return v2;
}

BOOL _os_workgroup_type_is_interval_type(unsigned __int16 a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
    return a1 <= 0xAu;
  return v2;
}

uint64_t os_workgroup_attr_set_flags(_DWORD *a1, int a2)
{
  unsigned int v3;

  v3 = 0;
  if (_os_workgroup_client_attr_is_valid(a1))
    a1[1] = a2;
  else
    return 22;
  return v3;
}

uint64_t os_workgroup_attr_set_telemetry_flavor(uint64_t a1, __int16 a2)
{
  unsigned int v3;

  v3 = 0;
  if (_os_workgroup_client_attr_is_valid((_DWORD *)a1) && _os_workgroup_telemetry_flavor_is_valid(a2))
    *(_WORD *)(a1 + 10) = a2;
  else
    return 22;
  return v3;
}

__int16 *os_workgroup_interval_copy_current_4AudioToolbox()
{
  __int16 *object;

  object = (__int16 *)_os_workgroup_get_current();
  if (object)
  {
    if (_os_workgroup_type_is_audio_type(object[28]))
      return (__int16 *)os_retain(object);
    else
      return 0;
  }
  return object;
}

void *_os_workgroup_get_current()
{
  return _dispatch_thread_getspecific(0x74uLL);
}

BOOL _os_workgroup_type_is_audio_type(__int16 a1)
{
  BOOL v2;

  v2 = 1;
  if (a1 != 4)
    return a1 == 3;
  return v2;
}

_QWORD *os_workgroup_create(const char *a1, _DWORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  _DWORD __b[16];
  uint64_t work_interval;
  _QWORD *v12;
  _DWORD *v13;
  const char *v14;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t StatusReg;
  unint64_t v27;

  v14 = a1;
  v13 = a2;
  v12 = 0;
  work_interval = 0;
  memset(__b, 0, sizeof(__b));
  v13 = _os_workgroup_client_attr_resolve(__b, v13, (uint64_t)&_os_workgroup_attr_default);
  if (v13)
  {
    if (_os_workgroup_type_is_default_type(*((_WORD *)v13 + 4)))
    {
      if (_os_workgroup_attr_is_propagating((uint64_t)v13))
      {
        v18 = 1;
        v21 = 1;
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 45;
        return 0;
      }
      else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v13))
      {
        v19 = 1;
        v20 = 1;
        v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v27 + 8) = 45;
        return 0;
      }
      else
      {
        v9 = 0;
        work_interval = _os_workgroup_create_work_interval((uint64_t)v13, (uint64_t)&v9);
        if (work_interval)
        {
          v12 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
          v12[4] = work_interval;
          *((_DWORD *)v12 + 10) = v9;
          v12[3] = 1;
          *((_WORD *)v12 + 28) = *((_WORD *)v13 + 4);
          _os_workgroup_set_name((uint64_t)v12, v14);
          return v12;
        }
        else
        {
          return 0;
        }
      }
    }
    else
    {
      v17 = 1;
      v22 = 1;
      v25 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v25 + 8) = 22;
      return 0;
    }
  }
  else
  {
    v16 = 1;
    v23 = 1;
    v24 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v24 + 8) = 22;
    return 0;
  }
}

_DWORD *_os_workgroup_client_attr_resolve(_DWORD *a1, _DWORD *a2, uint64_t a3)
{
  void *v4;

  if (a2)
  {
    if (!_os_workgroup_client_attr_is_valid(a2))
      return 0;
    memcpy(a1, a2, 0x40uLL);
    if (*a1 == 799564724)
    {
      if (!a1[1])
        a1[1] = *(_DWORD *)(a3 + 4);
      if (!*((_WORD *)a1 + 4))
        *((_WORD *)a1 + 4) = *(_WORD *)(a3 + 8);
    }
    else if (*a1 != 799564740)
    {
      return 0;
    }
    *a1 = 2015762650;
  }
  else
  {
    memcpy(a1, (const void *)a3, 0x40uLL);
  }
  if (!_os_workgroup_attr_is_resolved(a1))
  {
    v4 = (void *)_os_assert_log(0);
    _os_crash(v4);
    __break(1u);
    JUMPOUT(0x3B1CLL);
  }
  return a1;
}

BOOL _os_workgroup_type_is_default_type(__int16 a1)
{
  return a1 == 0;
}

BOOL _os_workgroup_attr_is_propagating(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 2) == 0;
}

BOOL _os_workgroup_attr_has_telemetry_enabled(uint64_t a1)
{
  return *(_WORD *)(a1 + 10) != 0;
}

uint64_t _os_workgroup_create_work_interval(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a2;
  v4 = _wg_type_to_wi_flags(*(_WORD *)(a1 + 8)) | 1;
  if (_os_workgroup_attr_is_differentiated(v6))
    v4 |= 2u;
  if (_os_workgroup_attr_has_workload_id(v6))
    v4 |= 0x80u;
  if (_os_workgroup_attr_has_telemetry_enabled(v6))
    v4 |= 0x100u;
  v3 = 0;
  if (work_interval_create(&v3, v4))
    return 0;
  if ((int)work_interval_copy_port(v3, v5) >= 0)
    return v3;
  work_interval_destroy(v3);
  return 0;
}

void _os_workgroup_set_name(uint64_t a1, const char *a2)
{
  uint64_t v2;
  const char *v3;
  uint64_t v4;

  v4 = (uint64_t)a2;
  if (a2)
  {
    v3 = _dispatch_strdup_if_mutable(a2);
    if (v3 != (const char *)v4)
    {
      *(_QWORD *)(a1 + 24) |= 4uLL;
      v4 = (uint64_t)v3;
    }
  }
  *(_QWORD *)(a1 + 16) = v4;
  v2 = *(_QWORD *)(a1 + 24);
  if (_os_workgroup_has_backing_workinterval(a1) && _os_workgroup_is_configurable(v2))
    _os_workgroup_set_work_interval_name(a1, v4);
}

_QWORD *os_workgroup_interval_create(const char *a1, int a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v11;
  _DWORD __b[16];
  uint64_t work_interval;
  _QWORD *v14;
  _DWORD *v15;
  int v16;
  const char *v17;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t StatusReg;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = 0;
  work_interval = 0;
  memset(__b, 0, sizeof(__b));
  v15 = _os_workgroup_client_attr_resolve(__b, v15, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v15)
  {
    if (_os_workgroup_type_is_interval_type(*((_WORD *)v15 + 4)))
    {
      if (_os_workgroup_attr_is_differentiated((uint64_t)v15))
      {
        if (_os_workgroup_attr_is_propagating((uint64_t)v15))
        {
          v22 = 1;
          v23 = 1;
          StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(StatusReg + 8) = 45;
          return 0;
        }
        else
        {
          v11 = 0;
          work_interval = _os_workgroup_create_work_interval((uint64_t)v15, (uint64_t)&v11);
          if (work_interval)
          {
            v14 = _os_object_alloc(_OS_os_workgroup_interval_vtable, 0x50uLL, v3, v4, v5, v6, v7, v8);
            v14[4] = work_interval;
            *((_DWORD *)v14 + 10) = v11;
            *((_DWORD *)v14 + 16) = v16;
            v9 = work_interval_instance_alloc(work_interval);
            v14[9] = v9;
            *((_DWORD *)v14 + 17) = 0;
            *((_WORD *)v14 + 28) = *((_WORD *)v15 + 4);
            v14[3] = 1;
            *((_WORD *)v14 + 22) = *((_WORD *)v15 + 5);
            _os_workgroup_set_name((uint64_t)v14, v17);
            return v14;
          }
          else
          {
            return 0;
          }
        }
      }
      else
      {
        v21 = 1;
        v24 = 1;
        v29 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v29 + 8) = 22;
        return 0;
      }
    }
    else
    {
      v20 = 1;
      v25 = 1;
      v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v28 + 8) = 22;
      return 0;
    }
  }
  else
  {
    v19 = 1;
    v26 = 1;
    v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v27 + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_attr_is_differentiated(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 4) & 4) == 0;
}

unsigned int *os_workgroup_create_with_workload_id(const char *a1, const char *a2, _DWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  unsigned int v38;
  _DWORD __b[16];
  _DWORD *v40;
  uint64_t work_interval;
  unsigned int *v42;
  _DWORD *v43;
  const char *v44;
  const char *v45;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t StatusReg;
  unint64_t v64;

  v45 = a1;
  v44 = a2;
  v43 = a3;
  v42 = 0;
  work_interval = 0;
  v40 = &_os_workgroup_with_workload_id_attr_default;
  memset(__b, 0, sizeof(__b));
  v43 = _os_workgroup_client_attr_resolve(__b, v43, (uint64_t)&_os_workgroup_with_workload_id_attr_default);
  if (v43)
  {
    v43 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v44, (uint64_t)v43, (uint64_t)v40);
    if (v43)
    {
      if (v43[1] == v40[1])
      {
        if (_os_workgroup_type_is_default_type(*((_WORD *)v43 + 4)))
        {
          if (_os_workgroup_attr_is_propagating((uint64_t)v43))
          {
            _dispatch_log("BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x", v24, v25, v26, v27, v28, v29, v30, (uint64_t)"os_workgroup_create_with_workload_id");
            v51 = 1;
            v54 = 1;
            StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(StatusReg + 8) = 45;
            return 0;
          }
          else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)v43))
          {
            v52 = 1;
            v53 = 1;
            v64 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v64 + 8) = 45;
            return 0;
          }
          else
          {
            v38 = 0;
            work_interval = _os_workgroup_create_work_interval((uint64_t)v43, (uint64_t)&v38);
            if (work_interval)
            {
              v42 = (unsigned int *)_os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v31, v32, v33, v34, v35, v36);
              *((_QWORD *)v42 + 4) = work_interval;
              v42[10] = v38;
              *((_QWORD *)v42 + 3) = 1;
              *((_WORD *)v42 + 28) = *((_WORD *)v43 + 4);
              if (_os_workgroup_set_work_interval_workload_id((uint64_t)v42, (uint64_t)v44, v43[3]))
              {
                _os_object_release(v42);
                return 0;
              }
              else
              {
                _os_workgroup_set_name((uint64_t)v42, v45);
                return v42;
              }
            }
            else
            {
              return 0;
            }
          }
        }
        else
        {
          _dispatch_log("BUG IN CLIENT of %s: Non-default workload type: %s (%hd)", v17, v18, v19, v20, v21, v22, v23, (uint64_t)"os_workgroup_create_with_workload_id");
          v50 = 1;
          v55 = 1;
          v62 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v62 + 8) = 22;
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Non-default attribute flags: 0x%x", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"os_workgroup_create_with_workload_id");
        v49 = 1;
        v56 = 1;
        v61 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v61 + 8) = 22;
        return 0;
      }
    }
    else
    {
      _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd", v10, v11, v12, v13, v14, v15, v16, (uint64_t)"os_workgroup_create_with_workload_id");
      v48 = 1;
      v57 = 1;
      v60 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v60 + 8) = 22;
      return 0;
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid attribute pointer", v3, v4, v5, v6, v7, v8, v9, (uint64_t)"os_workgroup_create_with_workload_id");
    v47 = 1;
    v58 = 1;
    v59 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v59 + 8) = 22;
    return 0;
  }
}

uint64_t _os_workgroup_workload_id_attr_resolve(const char *a1, uint64_t a2, uint64_t a3)
{
  __int16 v4;
  unsigned __int16 v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = 0;
  v4 = _os_workgroup_lookup_type_from_workload_id(a1, (unsigned int *)(a2 + 12), (__int16 *)&v5);
  if (!_os_workgroup_type_is_default_type(v4))
  {
    if (*(unsigned __int16 *)(v7 + 8) == *(unsigned __int16 *)(v6 + 8))
    {
      *(_WORD *)(v7 + 8) = v4;
    }
    else if (*(unsigned __int16 *)(v7 + 8) == v5)
    {
      *(_WORD *)(v7 + 8) = v4;
    }
    else if (v4 != *(_WORD *)(v7 + 8))
    {
      return 0;
    }
    return v7;
  }
  return v7;
}

uint64_t _os_workgroup_set_work_interval_workload_id(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v11;
  _DWORD v12[2];
  _BYTE *v13;
  __int128 v14;
  int v15;
  uint64_t v16;
  unsigned int v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;
  unint64_t StatusReg;
  uint64_t v25;
  uint64_t v26;
  _BYTE v27[64];

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = 0;
  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(v20 + 40) == -1)
  {
    v16 = 0;
    v3 = *(unsigned int *)(v20 + 40);
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x45CCLL);
  }
  if (v18)
  {
    v18 &= ~1u;
    __strlcpy_chk(v27, v19, 64, 64);
    v15 = 0;
    v15 = _wg_type_to_wi_flags(*(_WORD *)(v20 + 56));
    v12[0] = v18;
    v12[1] = v15;
    v13 = v27;
    v14 = 0uLL;
    v17 = __work_interval_ctl(11, *(unsigned int *)(v20 + 40), v12, 32);
    if (v17 == -1)
    {
      v22 = 1;
      v23 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v17 = **(_DWORD **)(StatusReg + 8);
      v26 = (int)v17;
      v25 = 576;
      if (v17)
        _dispatch_bug(v25, v26, v4, v5, v6, v7, v8, v9);
    }
    if (v17 || (v12[0] & 1) != 0)
    {
      if (v17)
        v11 = 0;
      else
        v11 = v12[0];
      _dispatch_log("BUG IN CLIENT of %s: Unable to set kernel workload ID: %s (0x%x) -> %d (0x%x)", v17, v11, v5, v6, v7, v8, v9, (uint64_t)"_os_workgroup_set_work_interval_workload_id");
      if (!v17)
        return 37;
    }
    else
    {
      *(_QWORD *)(v20 + 24) |= 0x10uLL;
    }
    return v17;
  }
  else
  {
    return v17;
  }
}

unsigned int *os_workgroup_interval_create_with_workload_id(const char *a1, const char *a2, unsigned int a3, _DWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unsigned int v47;
  _DWORD __b[16];
  _DWORD *v49;
  uint64_t work_interval;
  unsigned int *v51;
  _DWORD *v52;
  unsigned int v53;
  const char *v54;
  const char *v55;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t StatusReg;

  v55 = a1;
  v54 = a2;
  v53 = a3;
  v52 = a4;
  v51 = 0;
  work_interval = 0;
  v49 = &_os_workgroup_interval_attr_default;
  memset(__b, 0, sizeof(__b));
  v52 = _os_workgroup_client_attr_resolve(__b, v52, (uint64_t)&_os_workgroup_interval_attr_default);
  if (v52)
  {
    v52 = (_DWORD *)_os_workgroup_workload_id_attr_resolve(v54, (uint64_t)v52, (uint64_t)v49);
    if (v52)
    {
      if (v52[1] == v49[1])
      {
        if (_os_workgroup_type_is_interval_type(*((_WORD *)v52 + 4)))
        {
          if (_os_workgroup_attr_is_differentiated((uint64_t)v52))
          {
            if (_os_workgroup_attr_is_propagating((uint64_t)v52))
            {
              _dispatch_log("BUG IN CLIENT of %s: Unsupported attribute flags: 0x%x", v32, v33, v34, v35, v36, v37, v38, (uint64_t)"os_workgroup_interval_create_with_workload_id");
              v62 = 1;
              v63 = 1;
              StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
              **(_DWORD **)(StatusReg + 8) = 45;
              return 0;
            }
            else
            {
              v47 = 0;
              work_interval = _os_workgroup_create_work_interval((uint64_t)v52, (uint64_t)&v47);
              if (work_interval)
              {
                v51 = (unsigned int *)_os_object_alloc(_OS_os_workgroup_interval_vtable, 0x50uLL, v39, v40, v41, v42, v43, v44);
                *((_QWORD *)v51 + 4) = work_interval;
                v51[10] = v47;
                v51[16] = v53;
                v45 = work_interval_instance_alloc(work_interval);
                *((_QWORD *)v51 + 9) = v45;
                v51[17] = 0;
                *((_WORD *)v51 + 28) = *((_WORD *)v52 + 4);
                *((_QWORD *)v51 + 3) = 1;
                *((_WORD *)v51 + 22) = *((_WORD *)v52 + 5);
                if (_os_workgroup_set_work_interval_workload_id((uint64_t)v51, (uint64_t)v54, v52[3]))
                {
                  _os_object_release(v51);
                  return 0;
                }
                else
                {
                  _os_workgroup_set_name((uint64_t)v51, v55);
                  return v51;
                }
              }
              else
              {
                return 0;
              }
            }
          }
          else
          {
            _dispatch_log("BUG IN CLIENT of %s: Invalid attribute flags: 0x%x", v25, v26, v27, v28, v29, v30, v31, (uint64_t)"os_workgroup_interval_create_with_workload_id");
            v61 = 1;
            v64 = 1;
            v73 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            **(_DWORD **)(v73 + 8) = 22;
            return 0;
          }
        }
        else
        {
          _dispatch_log("BUG IN CLIENT of %s: Invalid workload interval type: %s (%hd)", v18, v19, v20, v21, v22, v23, v24, (uint64_t)"os_workgroup_interval_create_with_workload_id");
          v60 = 1;
          v65 = 1;
          v72 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          **(_DWORD **)(v72 + 8) = 22;
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Non-default attribute flags: 0x%x", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"os_workgroup_interval_create_with_workload_id");
        v59 = 1;
        v66 = 1;
        v71 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(v71 + 8) = 22;
        return 0;
      }
    }
    else
    {
      _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and attribute interval type: %s vs %hd", v11, v12, v13, v14, v15, v16, v17, (uint64_t)"os_workgroup_interval_create_with_workload_id");
      v58 = 1;
      v67 = 1;
      v70 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v70 + 8) = 22;
      return 0;
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid attribute pointer", v4, v5, v6, v7, v8, v9, v10, (uint64_t)"os_workgroup_interval_create_with_workload_id");
    v57 = 1;
    v68 = 1;
    v69 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v69 + 8) = 22;
    return 0;
  }
}

uint64_t os_workgroup_join_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
  return os_workgroup_join(a1, a2);
}

int os_workgroup_join(os_workgroup_t wg, os_workgroup_join_token_t token_out)
{
  int v3;
  uint64_t v4;

  if (_os_workgroup_get_current())
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 37;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else
  {
    v4 = *((_QWORD *)wg + 3);
    if ((v4 & 2) != 0)
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
    else
    {
      v3 = 0;
      if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
      {
        if (_os_workgroup_is_configurable(v4))
          v3 = work_interval_join(*((_QWORD *)wg + 4));
        else
          v3 = work_interval_join_port(*((unsigned int *)wg + 10));
      }
      if (v3)
      {
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
      else
      {
        _os_workgroup_join_update_wg((uint64_t)wg, (uint64_t)token_out);
        return 0;
      }
    }
  }
}

void os_workgroup_leave_self(os_workgroup_s *a1, os_workgroup_join_token_opaque_s *a2)
{
  os_workgroup_leave(a1, a2);
}

void os_workgroup_leave(os_workgroup_t wg, os_workgroup_join_token_t token)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  os_workgroup_s *current;

  if (!_os_workgroup_join_token_initialized(token))
  {
    _os_crash("Join token is corrupt");
    __break(1u);
  }
  v8 = *(_DWORD *)token->opaque;
  if (v8 != _dispatch_thread_getspecific(3uLL))
  {
    _os_crash("Join token provided is for a different thread");
    __break(1u);
  }
  current = (os_workgroup_s *)_os_workgroup_get_current();
  if (*(os_workgroup_s **)&token->opaque[12] != current || current != wg)
  {
    _os_crash("Join token provided is for a different workgroup than the last one joined by thread");
    __break(1u);
  }
  if (*(_QWORD *)&token->opaque[4])
  {
    v9 = _os_assert_log(*(_QWORD *)&token->opaque[4] == 0);
    _os_crash(v9);
    __break(1u);
  }
  if (_os_workgroup_has_backing_workinterval((uint64_t)wg) && work_interval_leave())
    _dispatch_bug(1686, 0, v2, v3, v4, v5, v6, v7);
  _os_workgroup_leave_update_wg(wg);
}

os_workgroup_parallel_t os_workgroup_parallel_create(const char *name, os_workgroup_attr_t attr)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v9;
  _DWORD __b[16];
  _QWORD *v11;
  void *__src;
  const char *v13;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t StatusReg;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;

  v13 = name;
  __src = attr;
  v11 = 0;
  memset(__b, 0, sizeof(__b));
  if (__src)
  {
    if (!_os_workgroup_client_attr_is_valid(__src))
    {
      v15 = 1;
      v24 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(StatusReg + 8) = 22;
      return 0;
    }
    memcpy(__b, __src, sizeof(__b));
    __src = __b;
    if (__b[0] == 799564724)
    {
      if (!*((_DWORD *)__src + 1))
        *((_DWORD *)__src + 1) = 6;
      if (!*((_WORD *)__src + 4))
        *((_WORD *)__src + 4) = 64;
    }
    else if (__b[0] != 799564740)
    {
      v16 = 1;
      v23 = 1;
      v26 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v26 + 8) = 22;
      return 0;
    }
    *(_DWORD *)__src = 2015762650;
  }
  else
  {
    memcpy(__b, &_os_workgroup_parallel_attr_default, sizeof(__b));
    __src = __b;
  }
  if (!_os_workgroup_attr_is_resolved(__src))
  {
    v9 = (void *)_os_assert_log(0);
    _os_crash(v9);
    __break(1u);
    JUMPOUT(0x52D8);
  }
  if (_os_workgroup_type_is_parallel_type(*((_WORD *)__src + 4)))
  {
    if (_os_workgroup_attr_is_propagating((uint64_t)__src))
    {
      v18 = 1;
      v21 = 1;
      v28 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v28 + 8) = 45;
      return 0;
    }
    else if (_os_workgroup_attr_has_telemetry_enabled((uint64_t)__src))
    {
      v19 = 1;
      v20 = 1;
      v29 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      **(_DWORD **)(v29 + 8) = 45;
      return 0;
    }
    else
    {
      v11 = _os_object_alloc(_OS_os_workgroup_parallel_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
      v11[4] = 0;
      v11[3] = 1;
      *((_WORD *)v11 + 28) = *((_WORD *)__src + 4);
      _os_workgroup_set_name((uint64_t)v11, v13);
      return (os_workgroup_parallel_t)v11;
    }
  }
  else
  {
    v17 = 1;
    v22 = 1;
    v27 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(v27 + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_attr_is_resolved(_DWORD *a1)
{
  return *a1 == 2015762650;
}

BOOL _os_workgroup_type_is_parallel_type(__int16 a1)
{
  return a1 == 64;
}

int os_workgroup_copy_port(os_workgroup_t wg, mach_port_t *mach_port_out)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v9;
  uint64_t v10;

  if (!wg)
  {
    v10 = _os_assert_log(0);
    _os_crash(v10);
    __break(1u);
  }
  if (!mach_port_out)
  {
    v9 = _os_assert_log(0);
    _os_crash(v9);
    __break(1u);
  }
  *mach_port_out = 0;
  if ((*((_QWORD *)wg + 3) & 2) != 0)
    return 22;
  if (!_os_workgroup_has_backing_workinterval((uint64_t)wg))
    return 22;
  if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
  {
    _dispatch_bug(1419, 0, v2, v3, v4, v5, v6, v7);
    return 12;
  }
  else
  {
    *mach_port_out = *((_DWORD *)wg + 10);
    return 0;
  }
}

os_workgroup_t os_workgroup_create_with_port(const char *name, mach_port_t mach_port)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v9;
  _BOOL4 v10;
  __int16 v11;
  mach_port_name_t namea;
  const char *v13;
  uint64_t v15;
  _BOOL8 v16;
  uint64_t v17;

  v13 = name;
  namea = mach_port;
  if (mach_port && namea != -1)
  {
    v11 = 0;
    if (_os_workgroup_get_wg_wi_types_from_port(namea, &v11, 0))
    {
      return 0;
    }
    else
    {
      v10 = mach_port_mod_refs(mach_task_self_, namea, 0, 1) == 0;
      v16 = v10;
      v15 = 1443;
      if (v10)
      {
        v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
        *((_DWORD *)v9 + 10) = namea;
        *((_WORD *)v9 + 28) = v11;
        _os_workgroup_set_name((uint64_t)v9, v13);
        return (os_workgroup_t)v9;
      }
      else
      {
        _dispatch_bug(v15, v16, v2, v3, v4, v5, v6, v7);
        return 0;
      }
    }
  }
  else
  {
    v17 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
}

uint64_t _os_workgroup_get_wg_wi_types_from_port(unsigned int a1, _WORD *a2, _DWORD *a3)
{
  unsigned int flags_from_port;
  int v5;
  int v6;
  __int16 v7;
  _DWORD *v8;
  _WORD *v9;
  unsigned int v10;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = 0;
  v6 = 0;
  v5 = 0;
  flags_from_port = work_interval_get_flags_from_port(a1, &v5);
  if (flags_from_port)
  {
    return flags_from_port;
  }
  else
  {
    v7 = _wi_flags_to_wg_type(v5);
    v6 = _wi_flags_to_wi_type(v5);
    if (v9)
      *v9 = v7;
    if (v8)
      *v8 = v6;
    return 0;
  }
}

_QWORD *os_workgroup_create_with_workload_id_and_port(const char *a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  _QWORD *v36;
  _BOOL4 v37;
  int v38;
  int wg_wi_types_from_port;
  int v40;
  __int16 v41;
  mach_port_name_t name;
  const char *v43;
  const char *v44;
  uint64_t v46;
  _BOOL8 v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t StatusReg;

  v44 = a1;
  v43 = a2;
  name = a3;
  if ((_DWORD)a3 && name != -1)
  {
    v41 = 0;
    v40 = 0;
    wg_wi_types_from_port = _os_workgroup_get_wg_wi_types_from_port(name, &v41, &v40);
    if (wg_wi_types_from_port)
    {
      _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", v8, v9, v10, v11, v12, v13, v14, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
      return 0;
    }
    else
    {
      v38 = 0;
      if (_os_workgroup_workload_id_is_valid_for_wi_type(v43, v40, (unsigned int *)&v38))
      {
        v37 = mach_port_mod_refs(mach_task_self_, name, 0, 1) == 0;
        v47 = v37;
        v46 = 1488;
        if (v37)
        {
          v36 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v22, v23, v24, v25, v26, v27);
          *((_DWORD *)v36 + 10) = name;
          *((_WORD *)v36 + 28) = v41;
          wg_wi_types_from_port = _os_workgroup_set_work_interval_workload_id((uint64_t)v36, (uint64_t)v43, v38);
          if (!wg_wi_types_from_port || wg_wi_types_from_port == 37)
          {
            _os_workgroup_set_name((uint64_t)v36, v44);
            return v36;
          }
          else
          {
            _os_object_release((unsigned int *)v36);
            return 0;
          }
        }
        else
        {
          _dispatch_bug(v46, v47, v22, v23, v24, v25, v26, v27);
          _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", v28, v29, v30, v31, v32, v33, v34, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
          return 0;
        }
      }
      else
      {
        _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and port interval type: %s vs %hd", v15, v16, v17, v18, v19, v20, v21, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
        v49 = 1;
        v50 = 1;
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        **(_DWORD **)(StatusReg + 8) = 22;
        return 0;
      }
    }
  }
  else
  {
    _dispatch_log("BUG IN CLIENT of %s: Invalid mach port 0x%x", (uint64_t)a2, a3, a4, a5, a6, a7, a8, (uint64_t)"os_workgroup_create_with_workload_id_and_port");
    v48 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
}

BOOL _os_workgroup_workload_id_is_valid_for_wi_type(const char *a1, int a2, unsigned int *a3)
{
  __int16 v4;
  unsigned __int16 v5;
  unsigned int *v6;
  int v7;
  const char *v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  v5 = 0;
  v4 = _os_workgroup_lookup_type_from_workload_id(a1, a3, (__int16 *)&v5);
  return _os_workgroup_type_is_default_type(v4)
      || _wg_type_to_wi_type(v5) == v7
      || _wg_type_to_wi_type(v4) == v7;
}

os_workgroup_t os_workgroup_create_with_workgroup(const char *name, os_workgroup_t wg)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v9;

  if ((*((_QWORD *)wg + 3) & 2) == 0)
  {
    v9 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v2, v3, v4, v5, v6, v7);
    *((_WORD *)v9 + 28) = *((_WORD *)wg + 28);
    if (_os_workgroup_has_backing_workinterval((uint64_t)wg))
    {
      if (mach_port_mod_refs(mach_task_self_, *((_DWORD *)wg + 10), 0, 1))
      {
        free(v9);
        return 0;
      }
      *((_DWORD *)v9 + 10) = *((_DWORD *)wg + 10);
    }
    _os_workgroup_set_name((uint64_t)v9, name);
    return (os_workgroup_t)v9;
  }
  **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
  return 0;
}

_QWORD *os_workgroup_create_with_workload_id_and_workgroup(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  const char *v24;
  int v25;
  _QWORD *v26;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  const char *v33;
  const char *v34;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t StatusReg;

  v34 = a1;
  v33 = (const char *)a2;
  v32 = a3;
  v31 = 0;
  v30 = 0;
  v29 = *(_QWORD *)(a3 + 24);
  v30 = v29;
  v28 = v29;
  v31 = v29;
  if ((v29 & 2) != 0)
  {
    _dispatch_log("BUG IN CLIENT of %s: Workgroup already cancelled", a2, a3, a4, a5, a6, a7, a8, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    v36 = 1;
    v39 = 1;
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return 0;
  }
  else
  {
    v27 = 0;
    v24 = v33;
    v8 = _wg_type_to_wi_type(*(_WORD *)(v32 + 56));
    if (_os_workgroup_workload_id_is_valid_for_wi_type(v24, v8, (unsigned int *)&v27))
    {
      v26 = _os_object_alloc(_OS_os_workgroup_vtable, 0x40uLL, v10, v11, v12, v13, v14, v15);
      *((_WORD *)v26 + 28) = *(_WORD *)(v32 + 56);
      if (_os_workgroup_has_backing_workinterval(v32))
      {
        if (mach_port_mod_refs(mach_task_self_, *(_DWORD *)(v32 + 40), 0, 1))
        {
          _dispatch_log("BUG IN CLIENT of %s: Invalid workgroup port 0x%x", v16, v17, v18, v19, v20, v21, v22, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
          free(v26);
          return 0;
        }
        *((_DWORD *)v26 + 10) = *(_DWORD *)(v32 + 40);
        v25 = _os_workgroup_set_work_interval_workload_id((uint64_t)v26, (uint64_t)v33, v27);
        if (v25 && v25 != 37)
        {
          _os_object_release((unsigned int *)v26);
          return 0;
        }
      }
      _os_workgroup_set_name((uint64_t)v26, v34);
      return v26;
    }
    _dispatch_log("BUG IN CLIENT of %s: Mismatched workload ID and workgroup interval type: %s vs %hd", v9, v10, v11, v12, v13, v14, v15, (uint64_t)"os_workgroup_create_with_workload_id_and_workgroup");
    v37 = 1;
    v38 = 1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = 22;
    return 0;
  }
}

uint64_t _wg_type_to_wi_type(unsigned __int16 a1)
{
  int v1;

  v1 = _wg_type_to_wi_flags(a1);
  return _wi_flags_to_wi_type(v1);
}

int os_workgroup_max_parallel_threads(os_workgroup_t wg, os_workgroup_mpt_attr_t attr)
{
  uint64_t v4;

  if (!wg)
  {
    v4 = _os_assert_log(0);
    _os_crash(v4);
    __break(1u);
  }
  if (*((_WORD *)wg + 28) != 4 && *((_WORD *)wg + 28) != 3)
    return pthread_qos_max_parallelism(33, 0);
  else
    return pthread_time_constraint_max_parallelism(0);
}

void _os_workgroup_join_update_wg(uint64_t a1, uint64_t a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;

  if (_os_workgroup_get_current())
    __assert_rtn("_os_workgroup_join_update_wg", "workgroup.c", 1653, "cur_wg == NULL");
  v4 = (unsigned int *)(a1 + 60);
  v5 = *(_DWORD *)(a1 + 60);
  do
  {
    v2 = v5;
    do
      v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 + 1, v4));
    v5 = v3;
  }
  while (v3 != v2);
  __memset_chk(a2, 0, 40, -1);
  *(_DWORD *)a2 = 1298094680;
  *(_DWORD *)(a2 + 4) = _dispatch_thread_getspecific(3uLL);
  *(_QWORD *)(a2 + 8) = 0;
  *(_QWORD *)(a2 + 16) = a1;
  _os_workgroup_set_current(a1);
}

void _os_workgroup_set_current(uint64_t a1)
{
  unsigned int *current;

  if (a1)
    _os_object_retain_internal(a1);
  current = (unsigned int *)_os_workgroup_get_current();
  _dispatch_thread_setspecific(116, a1);
  if (current)
    _os_object_release_internal(current);
}

BOOL _os_workgroup_join_token_initialized(_DWORD *a1)
{
  return *a1 == 1298094680;
}

uint64_t os_workgroup_set_working_arena(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  unsigned __int128 v6;
  __int128 v7;
  unsigned __int128 v8;
  void (**v9)(_QWORD);
  unsigned __int128 *v11;
  _BOOL4 v12;
  void (**v13)(_QWORD);
  __int128 v14;
  _DWORD *v15;
  unint64_t v16;

  v16 = 4 * a3;
  if (!is_mul_ok(4uLL, a3)
    || v16 >= 0xFFFFFFFFFFFFFFE8
    || (v15 = (_DWORD *)malloc_type_calloc(v16 + 24, 1, 187101423)) == 0)
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 12;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else
  {
    v15[4] = a3;
    *(_QWORD *)v15 = a2;
    *((_QWORD *)v15 + 1) = a4;
    v13 = 0;
    v12 = 0;
    v11 = (unsigned __int128 *)(a1 + 48);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(0))
      {
        v6 = __ldaxp(v11);
        v4 = *((_QWORD *)&v6 + 1);
        v5 = v6;
      }
      else
      {
        v8 = __ldxp(v11);
        v4 = *((_QWORD *)&v8 + 1);
        v5 = v8;
      }
      *(_QWORD *)&v7 = v5;
      *((_QWORD *)&v7 + 1) = v4;
      v14 = v7;
      if (_wg_joined_cnt(v5, v4))
        break;
      _wg_arena(v14, *((unint64_t *)&v14 + 1));
      v13 = v9;
      if (_os_atomic_mo_has_release(0))
        v12 = __stlxp((unint64_t)v15, v11) == 0;
      else
        v12 = __stxp((unint64_t)v15, v11) == 0;
      if (v12)
        goto LABEL_14;
    }
    __clrex();
LABEL_14:
    if (v12)
    {
      if (v13)
      {
        v13[1](*v13);
        free(v13);
      }
      return 0;
    }
    else
    {
      free(v15);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
}

BOOL _os_atomic_mo_has_acquire(int a1)
{
  BOOL v1;
  _BOOL4 v4;

  v1 = a1 == 2 || a1 == 1;
  v4 = 1;
  if (!v1 && a1 != 5 && a1 != 4)
    return 0;
  return v4;
}

unint64_t _wg_joined_cnt(uint64_t a1, uint64_t a2)
{
  return (a2 & 0xFFFFFFFF00000000) >> 32;
}

__n128 _wg_arena(unint64_t a1, unint64_t a2)
{
  __n128 result;

  result.n128_u64[0] = a1;
  result.n128_u64[1] = a2;
  return result;
}

BOOL _os_atomic_mo_has_release(int a1)
{
  return (a1 - 3) <= 2;
}

uint64_t os_workgroup_get_working_arena(uint64_t a1, unsigned int *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int i;
  char v15;
  unsigned int v16;
  unsigned int *v17;

  if (_os_workgroup_get_current() != (void *)a1)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x69A8);
  }
  if (!*(_DWORD *)(a1 + 60))
    _dispatch_abort(1765, *(_DWORD *)(a1 + 60) != 0, v2, v3, v4, v5, v6, v7);
  v17 = *(unsigned int **)(a1 + 48);
  if (!v17)
    return 0;
  if (a2 && !v17[4])
  {
    _os_crash("The arena associated with workgroup is not to be partitioned");
    __break(1u);
    JUMPOUT(0x6A78);
  }
  if (a2)
  {
    v16 = 0;
    v15 = 0;
    for (i = 0; i < v17[4]; ++i)
    {
      v13 = v17[i + 6];
      if (v13 == _dispatch_thread_getspecific(3uLL))
      {
        v16 = i;
        v15 = 1;
        break;
      }
    }
    if ((v15 & 1) == 0)
    {
      v11 = v17 + 5;
      v12 = v17[5];
      do
      {
        v8 = v12;
        do
          v9 = __ldaxr(v11);
        while (v9 == v12 && __stlxr(v12 + 1, v11));
        v12 = v9;
      }
      while (v9 != v8);
      v16 = v9;
      if (v9 >= v17[4])
      {
        _os_crash("Exceeded the maximum number of workers who can access the arena");
        __break(1u);
        JUMPOUT(0x6BF8);
      }
      v17[v9 + 6] = _dispatch_thread_getspecific(3uLL);
    }
    *a2 = v16;
  }
  return *(_QWORD *)v17;
}

void os_workgroup_cancel(os_workgroup_t wg)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;

  v3 = (unint64_t *)((char *)wg + 24);
  v4 = *((_QWORD *)wg + 3);
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 | 2, v3));
    v4 = v2;
  }
  while (v2 != v1);
}

BOOL os_workgroup_testcancel(os_workgroup_t wg)
{
  return (*((_QWORD *)wg + 3) & 2) != 0;
}

int os_workgroup_interval_start(os_workgroup_interval_t wg, uint64_t start, uint64_t deadline, os_workgroup_interval_data_t data)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t *v8;
  unint64_t v9;
  uint64_t v10;
  unint64_t *v11;
  _BOOL4 v12;
  unint64_t v13;
  unint64_t v14;
  int v15;
  int v16;
  _BOOL8 v17;

  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x6DBCLL);
  }
  if (!_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data)
    && deadline >= start
    && _start_time_is_in_past(*((_DWORD *)wg + 16), start))
  {
    if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
    {
      v17 = _os_workgroup_interval_data_complexity(data);
      v15 = 0;
      v11 = (unint64_t *)((char *)wg + 24);
      while (1)
      {
        if (_os_atomic_mo_has_acquire(0))
          v4 = __ldaxr(v11);
        else
          v4 = __ldxr(v11);
        v14 = v4;
        if ((v4 & 0xA) != 0)
        {
          v15 = 22;
          __clrex();
          goto LABEL_25;
        }
        if (!_os_workgroup_is_configurable(v4))
        {
          v15 = 1;
          __clrex();
          goto LABEL_25;
        }
        if (v17 && !_os_workgroup_has_workload_id(v14))
          break;
        v13 = v14 | 8;
        if (_os_atomic_mo_has_release(0))
          v12 = __stlxr(v13, v11) == 0;
        else
          v12 = __stxr(v13, v11) == 0;
        if (v12)
          goto LABEL_25;
      }
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
      __clrex();
LABEL_25:
      if (v15)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = v15;
        return v15;
      }
      else
      {
        v10 = *((_QWORD *)wg + 9);
        work_interval_instance_clear(v10);
        work_interval_instance_set_start(v10, start);
        work_interval_instance_set_deadline(v10, deadline);
        work_interval_instance_set_complexity(v10, v17);
        v16 = work_interval_instance_start(v10);
        if (v16)
        {
          v8 = (unint64_t *)((char *)wg + 24);
          v9 = *((_QWORD *)wg + 3);
          do
          {
            v5 = v9;
            do
              v6 = __ldaxr(v8);
            while (v6 == v9 && __stlxr(v9 & 0xFFFFFFFFFFFFFFF7, v8));
            v9 = v6;
          }
          while (v6 != v5);
        }
        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v16;
      }
    }
    else
    {
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

BOOL _os_workgroup_interval_invalid_telemetry_request(uint64_t a1, uint64_t a2)
{
  BOOL v3;

  v3 = 0;
  if (_os_workgroup_interval_data_telemetry_requested(a2))
    return *(unsigned __int16 *)(a2 + 16) != *(unsigned __int16 *)(a1 + 44);
  return v3;
}

BOOL _start_time_is_in_past(int a1, uint64_t a2)
{
  BOOL v3;

  if (a1 == 32)
    return a2 <= mach_absolute_time();
  return v3;
}

BOOL _os_workgroup_interval_data_complexity(_DWORD *a1)
{
  uint64_t v2;

  v2 = 0;
  if (_os_workgroup_client_interval_data_is_valid(a1))
    return (a1[1] & 1) != 0;
  return v2;
}

BOOL _os_workgroup_has_workload_id(char a1)
{
  return (a1 & 0x10) != 0;
}

BOOL _os_workgroup_interval_data_telemetry_requested(uint64_t a1)
{
  BOOL v2;

  v2 = 0;
  if (a1)
    return _os_workgroup_telemetry_flavor_is_valid(*(_WORD *)(a1 + 16));
  return v2;
}

uint64_t _os_workgroup_interval_copy_telemetry_data(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  _QWORD *v3;
  _QWORD __b[5];
  uint64_t v5;
  uint64_t v6;

  v6 = a1;
  v5 = a2;
  memset(__b, 0, sizeof(__b));
  result = work_interval_instance_get_telemetry_data(*(_QWORD *)(v6 + 72), __b, 40);
  if (*(_WORD *)(v5 + 16) == 1)
  {
    v3 = *(_QWORD **)(v5 + 8);
    *v3 = __b[0];
    v3[3] = __b[3];
    v3[4] = __b[4];
    v3[1] = __b[1];
    v3[2] = __b[2];
  }
  return result;
}

int os_workgroup_interval_update(os_workgroup_interval_t wg, uint64_t deadline, os_workgroup_interval_data_t data)
{
  int v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v7;

  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x7574);
  }
  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    v7 = _os_workgroup_interval_data_complexity(data);
    v6 = *((_QWORD *)wg + 3);
    if (_os_workgroup_is_configurable(v6))
    {
      if ((!v7 || _os_workgroup_has_workload_id(v6)) && (v6 & 8) != 0)
      {
        v5 = *((_QWORD *)wg + 9);
        work_interval_instance_set_deadline(v5, deadline);
        work_interval_instance_set_complexity(v5, v7);
        v4 = work_interval_instance_update(v5);
        if (v4)
        {
          v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }
        else if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
        {
          _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v4;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

int os_workgroup_interval_finish(os_workgroup_interval_t wg, os_workgroup_interval_data_t data)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t *v5;
  unint64_t v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _BOOL8 v11;

  if (_os_workgroup_get_current() != wg)
  {
    _os_crash("Thread is not a member of the workgroup");
    __break(1u);
    JUMPOUT(0x7974);
  }
  if (_os_workgroup_interval_invalid_telemetry_request((uint64_t)wg, (uint64_t)data))
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
  else if (os_unfair_lock_trylock((os_unfair_lock_t)wg + 17))
  {
    v11 = _os_workgroup_interval_data_complexity(data);
    v10 = *((_QWORD *)wg + 3);
    if (_os_workgroup_is_configurable(v10))
    {
      if ((!v11 || _os_workgroup_has_workload_id(v10)) && (v10 & 8) != 0)
      {
        v9 = *((_QWORD *)wg + 9);
        v8 = 0;
        if (*((_DWORD *)wg + 16) == 32)
          v8 = mach_absolute_time();
        work_interval_instance_set_finish(v9, v8);
        work_interval_instance_set_complexity(v9, v11);
        v7 = work_interval_instance_finish(v9);
        if (v7)
        {
          v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        }
        else
        {
          v5 = (unint64_t *)((char *)wg + 24);
          v6 = *((_QWORD *)wg + 3);
          do
          {
            v2 = v6;
            do
              v3 = __ldaxr(v5);
            while (v3 == v6 && __stlxr(v6 & 0xFFFFFFFFFFFFFFF7, v5));
            v6 = v3;
          }
          while (v3 != v2);
          if (_os_workgroup_interval_data_telemetry_requested((uint64_t)data))
            _os_workgroup_interval_copy_telemetry_data((uint64_t)wg, (uint64_t)data);
        }
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        return v7;
      }
      else
      {
        os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
        **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 22;
        return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      }
    }
    else
    {
      os_unfair_lock_unlock((os_unfair_lock_t)wg + 17);
      **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 1;
      return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    }
  }
  else
  {
    **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) = 16;
    return **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  }
}

uint64_t _os_workgroup_pthread_create_with_workgroup(pthread_t *a1, unsigned int *a2, const pthread_attr_t *a3, uint64_t a4, uint64_t a5)
{
  unsigned int v6;
  _QWORD *v7;

  v7 = (_QWORD *)_dispatch_calloc(1, 24);
  _os_object_retain_internal((uint64_t)a2);
  *v7 = a2;
  v7[1] = a4;
  v7[2] = a5;
  v6 = pthread_create(a1, a3, (void *(__cdecl *)(void *))_os_workgroup_pthread_start, v7);
  if (v6)
  {
    _os_object_release_internal(a2);
    free(v7);
  }
  return v6;
}

uint64_t _os_workgroup_pthread_start(os_workgroup_s **a1)
{
  uint64_t v2;
  int v3;
  os_workgroup_join_token_opaque_s token_out;
  os_workgroup_s *v5;
  os_workgroup_s *v6;
  os_workgroup_s *v7;
  os_workgroup_s **v8;
  os_workgroup_s **v9;

  v9 = a1;
  v8 = a1;
  v7 = 0;
  v7 = *a1;
  v6 = 0;
  v6 = a1[1];
  v5 = 0;
  v5 = a1[2];
  free(a1);
  memset(&token_out, 0, sizeof(token_out));
  v3 = os_workgroup_join(v7, &token_out);
  if (v3)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: pthread_start os_workgroup_join failed";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x7F88);
  }
  v2 = ((uint64_t (*)(os_workgroup_s *))v6)(v5);
  os_workgroup_leave(v7, &token_out);
  _os_object_release_internal((unsigned int *)v7);
  return v2;
}

BOOL _os_workgroup_client_interval_data_initialized(_DWORD *a1)
{
  return *a1 == 1386695757;
}

BOOL _os_workgroup_client_attr_initialized(_DWORD *a1)
{
  BOOL v2;

  v2 = 1;
  if (*a1 != 799564724)
    return *a1 == 799564740;
  return v2;
}

uint64_t _wg_type_to_wi_flags(unsigned __int16 a1)
{
  uint64_t result;

  if (a1 <= 0xAuLL)
    __asm { BR              X8 }
  result = _os_crash("Creating an os_workgroup of unknown type");
  __break(1u);
  return result;
}

uint64_t sub_8148()
{
  uint64_t v0;

  return *(unsigned int *)(v0 - 4);
}

BOOL _os_workgroup_attr_has_workload_id(uint64_t a1)
{
  return (*(_DWORD *)(a1 + 12) & 1) != 0;
}

void _os_workgroup_set_work_interval_name(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  _BYTE v12[32];

  if (!*(_DWORD *)(a1 + 40) || *(_DWORD *)(a1 + 40) == -1)
  {
    v2 = *(unsigned int *)(a1 + 40);
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workgroup port";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x8234);
  }
  if (a2)
    v9 = __strlcpy_chk(v12, a2, 32, 32);
  else
    v9 = 0;
  if (v9)
  {
    if (__work_interval_ctl(10, *(unsigned int *)(a1 + 40), v12, 32) == -1)
    {
      v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v10)
        _dispatch_bug(534, v10, v3, v4, v5, v6, v7, v8);
    }
  }
}

uint64_t _os_workgroup_lookup_type_from_workload_id(const char *a1, unsigned int *a2, __int16 *a3)
{
  unint64_t i;
  unsigned int v5;
  __int16 v6;
  unsigned __int16 v7;

  v7 = 0;
  v6 = 0;
  v5 = 0;
  if (!a1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Workload identifier must not be NULL";
    __break(1u);
    JUMPOUT(0x83E0);
  }
  for (i = 0; i < 2; ++i)
  {
    if (!strcasecmp(a1, (&_os_workgroup_workload_id_table)[2 * i]))
    {
      v7 = (unsigned __int16)(&_os_workgroup_workload_id_table)[2 * i + 1];
      v6 = *((_WORD *)&_os_workgroup_workload_id_table + 8 * i + 5);
      if (_os_workgroup_type_is_default_type(v6))
        v6 = v7;
      v5 = *((_DWORD *)&_os_workgroup_workload_id_table + 4 * i + 3) & 0xFFFFFFFA | 1;
      if (_os_workgroup_type_is_default_type(v7))
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid workload ID type";
        qword_E4DA8 = i;
        __break(1u);
        JUMPOUT(0x84FCLL);
      }
      break;
    }
  }
  if (!v5)
    v5 = 1;
  *a2 = v5;
  *a3 = v6;
  return v7;
}

uint64_t _wi_flags_to_wg_type(int a1)
{
  int v3;
  BOOL v4;
  char v7[512];

  v4 = (a1 & 4) != 0;
  v3 = _wi_flags_to_wi_type(a1);
  if (v3)
  {
    switch(v3)
    {
      case 268435456:
        if (v4)
          return 3;
        else
          return 4;
      case 536870912:
        return 5;
      case 805306368:
        return 2;
      case 1073741824:
        return 7;
      case 1342177280:
        return 8;
      case 1610612736:
        return 9;
      case 1879048192:
        return 10;
      default:
        __snprintf_chk(v7, 0x200uLL, 0, 0x200uLL, "BUG IN DISPATCH: Invalid wi flags = %u", a1);
        _os_crash(v7);
        __break(1u);
        JUMPOUT(0x8718);
    }
  }
  else
  {
    return 0;
  }
}

uint64_t _wi_flags_to_wi_type(int a1)
{
  return a1 & 0xF0000000;
}

uint64_t _dispatch_thread_setspecific(uint64_t result, uint64_t a2)
{
  char v2;
  char v3;

  if (v2)
    v3 = 1;
  else
    v3 = 0;
  if ((v3 & 1) != 0)
  {
    __break(1u);
    JUMPOUT(0x87D8);
  }
  *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = a2;
  return result;
}

uint64_t dispatch_atfork_prepare()
{
  uint64_t v0;

  v0 = _voucher_atfork_prepare();
  return _os_object_atfork_prepare(v0);
}

void *dispatch_atfork_parent(uint64_t a1)
{
  _os_object_atfork_prepare(a1);
  return _voucher_atfork_parent();
}

void dispatch_atfork_child(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  _os_object_atfork_prepare(a1);
  _voucher_atfork_child();
  _dispatch_event_loop_atfork_child();
  if ((_dispatch_unsafe_fork & 1) != 0)
    _dispatch_child_of_unsafe_fork = 1;
  _dispatch_queue_atfork_child(v1, v2, v3, v4, v5, v6, v7, v8);
  _dispatch_unsafe_fork = 0;
}

uint64_t _dispatch_sigmask()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  sigset_t v8[10];
  uint64_t v9;
  uint64_t v10;

  v8[9] = 4;
  v8[8] = 5;
  v8[7] = 7;
  v8[6] = 8;
  v8[5] = 10;
  v8[4] = 11;
  v8[3] = 12;
  v8[2] = 13;
  v8[1] = 27;
  v8[0] = -67116761;
  v7 = pthread_sigmask(1, v8, 0);
  v10 = v7;
  v9 = 108;
  if (v7)
    _dispatch_bug(v9, v10, v0, v1, v2, v3, v4, v5);
  return v7;
}

BOOL _dispatch_is_multithreaded()
{
  return (_dispatch_unsafe_fork & 1) != 0;
}

uint64_t _dispatch_is_fork_of_multithreaded_parent()
{
  return _dispatch_child_of_unsafe_fork & 1;
}

dispatch_queue_t dispatch_get_current_queue(void)
{
  dispatch_queue_s *v2;

  v2 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
  if (v2)
    return v2;
  else
    return (dispatch_queue_t)&off_E46C0;
}

unint64_t _dispatch_queue_attr_to_info(uint64_t *a1)
{
  uint64_t v1;
  int v2;
  unint64_t v4;
  unsigned int v5;
  int v6;

  v5 = 0;
  if (a1)
  {
    if (a1 < (uint64_t *)&_dispatch_queue_attr_concurrent || a1 >= qword_E0A78)
    {
      v1 = *a1;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x8D8CLL);
    }
    HIWORD(v6) = (unint64_t)((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 1) << 21) | ((((((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) & 2) == 0) << 20)) >> 16;
    BYTE1(v6) = -(((unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 2) & 0xF);
    v4 = (unint64_t)(((char *)a1 - (char *)&_dispatch_queue_attr_concurrent) >> 4) >> 6;
    v2 = (v4 * (unsigned __int128)0x2492492492492493uLL) >> 64;
    LOBYTE(v6) = v4 - 7 * ((v2 + ((v4 - v2) >> 1)) >> 2);
    v4 /= 7uLL;
    return v6 & 0xFFF0FFFF | (((_DWORD)v4 - (((v4 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3))) << 18) | (((v4 / 3) - (((v4 / 3 / 3) & 0x7FFFFFFF) + 2 * (v4 / 3 / 3))) << 16);
  }
  return v5;
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_qos_class(dispatch_queue_attr_t attr, dispatch_qos_class_t qos_class, int relative_priority)
{
  unint64_t v4;
  BOOL v5;
  int v6;
  unsigned __int8 v7;
  BOOL v10;

  v7 = relative_priority;
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    v5 = 0;
    if (relative_priority >= -15)
      v5 = relative_priority <= 0;
    v10 = v5;
  }
  else
  {
    v10 = 0;
  }
  if (!v10)
    return attr;
  v6 = _dispatch_queue_attr_to_info((uint64_t *)attr);
  v4 = qos_class - 5;
  if (v4 <= 0x1C)
    __asm { BR              X8 }
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v6 & 0xFFFF0000 | (v7 << 8));
}

char *_dispatch_queue_attr_from_info(unsigned int a1)
{
  return (char *)&_dispatch_queue_attr_concurrent
       + 21504 * (BYTE2(a1) & 3)
       + 7168 * ((a1 >> 18) & 3)
       + 1024 * a1
       + 32 * (((a1 >> 20) & 1) == 0)
       + 16 * ((a1 >> 21) & 1)
       + -64 * ((__int16)a1 >> 8);
}

dispatch_queue_attr_t dispatch_queue_attr_make_initially_inactive(dispatch_queue_attr_t attr)
{
  unsigned int v2;

  v2 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFDFFFFF | 0x200000;
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v2);
}

char *dispatch_queue_attr_make_with_overcommit(uint64_t *a1, char a2)
{
  int v3;
  unsigned int v4;
  char v5;

  v5 = a2 & 1;
  v3 = _dispatch_queue_attr_to_info(a1);
  if ((v5 & 1) != 0)
    v4 = v3 & 0xFFFCFFFF | 0x10000;
  else
    v4 = v3 & 0xFFFCFFFF | 0x20000;
  return _dispatch_queue_attr_from_info(v4);
}

dispatch_queue_attr_t dispatch_queue_attr_make_with_autorelease_frequency(dispatch_queue_attr_t attr, dispatch_autorelease_frequency_t frequency)
{
  unsigned int v3;

  v3 = _dispatch_queue_attr_to_info((uint64_t *)attr) & 0xFFF3FFFF | ((frequency & 3) << 18);
  return (dispatch_queue_attr_t)_dispatch_queue_attr_from_info(v3);
}

void _dispatch_object_no_invoke(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 16);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: do_invoke called";
  qword_E4DA8 = v1;
  __break(1u);
}

void _dispatch_object_no_dispose(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 16);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: do_dispose called";
  qword_E4DA8 = v1;
  __break(1u);
}

uint64_t _dispatch_object_missing_debug(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return __strlcpy_chk(a2, "missing do_debug vtable slot: ", a3, -1);
}

void _dispatch_queue_no_activate(uint64_t a1)
{
  uint64_t v1;

  v1 = *(_QWORD *)(*(_QWORD *)a1 + 16);
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dq_activate called";
  qword_E4DA8 = v1;
  __break(1u);
}

void _dispatch_data_destructor_free_block_invoke(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: free destructor called";
  __break(1u);
}

void _dispatch_data_destructor_none_block_invoke_2(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: none destructor called";
  __break(1u);
}

void _dispatch_data_destructor_vm_deallocate_block_invoke_3(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: vmdeallocate destructor called";
  __break(1u);
}

void _dispatch_data_destructor_inline_block_invoke_4(id a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: inline destructor called";
  __break(1u);
}

BOOL _dispatch_parse_BOOL(const char *a1)
{
  BOOL v2;

  v2 = 1;
  if (strcasecmp(a1, "YES"))
  {
    v2 = 1;
    if (strcasecmp(a1, "Y"))
    {
      v2 = 1;
      if (strcasecmp(a1, "TRUE"))
        return atoi(a1) != 0;
    }
  }
  return v2;
}

BOOL _dispatch_getenv_BOOL(const char *a1, char a2)
{
  _BYTE v3[12];
  char v4;

  v4 = a2 & 1;
  *(_QWORD *)&v3[4] = getenv(a1);
  if (*(_QWORD *)&v3[4])
    *(_DWORD *)v3 = _dispatch_parse_BOOL(*(const char **)&v3[4]);
  else
    *(_QWORD *)v3 = v4 & 1;
  return *(_DWORD *)v3 != 0;
}

uint64_t _dispatch_build_init(size_t a1)
{
  size_t v2[2];
  int v3[2];

  v2[1] = a1;
  *(_QWORD *)v3 = 0x4100000001;
  v2[0] = 16;
  return sysctl(v3, 2u, &_dispatch_build, v2, 0, 0);
}

uint64_t _dispatch_continuation_get_function_symbol(uint64_t a1)
{
  uint64_t v1;
  uint64_t v4;
  uint64_t v5;

  if ((*(_BYTE *)a1 & 0x20) != 0)
  {
    v4 = *(_QWORD *)(a1 + 40);
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(v4) == ___dispatch_block_create_block_invoke)
    {
      if (*(_QWORD *)(v4 + 32) != 3512316172)
      {
        v1 = *(_QWORD *)(v4 + 32);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x98D4);
      }
      v5 = v4 + 32;
    }
    else
    {
      v5 = 0;
    }
    return _Block_get_invoke_fn(*(_QWORD *)(v5 + 40));
  }
  else if ((*(_BYTE *)a1 & 0x10) != 0)
  {
    return _Block_get_invoke_fn(*(_QWORD *)(a1 + 40));
  }
  else
  {
    return *(_QWORD *)(a1 + 32);
  }
}

uint64_t _Block_get_invoke_fn(uint64_t a1)
{
  return *(_QWORD *)(a1 + 16);
}

void _dispatch_debugv(uint64_t a1, const char *a2, va_list a3)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  char v23[2048];

  v14 = _dispatch_uptime() - dispatch_log_basetime;
  v3 = _dispatch_thread_getspecific(0);
  v16 = __snprintf_chk(v23, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t\t%p\t", v14, v3);
  if (v16 >= 0)
  {
    if ((unint64_t)v16 <= 0x800)
      v12 = v16;
    else
      v12 = 2048;
    v13 = v12;
  }
  else
  {
    v13 = 0;
  }
  if (a1)
  {
    v18 = v13 + _dispatch_object_debug2(a1, (uint64_t)&v23[v13], 2048 - v13);
    if ((unint64_t)(v18 + 2) >= 0x800)
      _dispatch_abort(1433, (unint64_t)(v18 + 2) < 0x800, v4, v5, v6, v7, v8, v9);
    v23[v18] = 58;
    v10 = v18 + 1;
    v19 = v18 + 2;
    v23[v10] = 32;
    v23[v19] = 0;
  }
  else
  {
    v19 = v13 + __strlcpy_chk(&v23[v13], "NULL: ", 2048 - v13, -1);
  }
  v17 = __vsnprintf_chk(&v23[v19], 2048 - v19, 0, 0xFFFFFFFFFFFFFFFFLL, a2, a3);
  if (v17 >= 0)
    v11 = v17;
  else
    v11 = 0;
  v15 = v19 + v11;
  if ((unint64_t)(v19 + v11) > 0x7FF)
    v15 = 2047;
  if (_dispatch_logv_pred != -1)
    dispatch_once_f(&_dispatch_logv_pred, 0, (dispatch_function_t)_dispatch_logv_init);
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1)
      _dispatch_syslog((uint64_t)v23);
    else
      _dispatch_log_file((uint64_t)v23, v15);
  }
}

void _dispatch_object_debug(uint64_t a1, const char *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  _dispatch_debugv(a1, a2, &a9);
}

uint64_t _dispatch_temporary_resource_shortage()
{
  return sleep_NOCANCEL(1);
}

uint64_t _dispatch_calloc(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  while (1)
  {
    v3 = malloc_type_calloc(a1, a2, 458526829);
    if (v3)
      break;
    _dispatch_temporary_resource_shortage();
  }
  return v3;
}

const char *_dispatch_strdup_if_mutable(const char *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  size_t v9;

  v9 = strlen(a1) + 1;
  if (((_dyld_is_memory_immutable(a1, v9) ^ 1) & 1) == 0)
    return a1;
  v8 = malloc_type_malloc(v9, 312244285);
  if (v8)
    __memcpy_chk(v8, a1, v9, -1);
  else
    _dispatch_bug(1515, 0, v1, v2, v3, v4, v5, v6);
  return (const char *)v8;
}

void *_dispatch_Block_copy(const void *a1)
{
  void *v2;

  if (!a1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: NULL was passed where a block should have been";
    __break(1u);
    JUMPOUT(0x9FC8);
  }
  while (1)
  {
    v2 = _Block_copy(a1);
    if (v2)
      break;
    _dispatch_temporary_resource_shortage();
  }
  return v2;
}

void _dispatch_call_block_and_release(void (**a1)(void))
{
  a1[2]();
  _Block_release(a1);
}

uint64_t _dispatch_client_callout(uint64_t a1, uint64_t (*a2)(uint64_t))
{
  return a2(a1);
}

uint64_t _dispatch_client_callout2(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t))
{
  return a3(a1, a2);
}

uint64_t _dispatch_client_callout3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t (*a4)(uint64_t, uint64_t, uint64_t))
{
  return a4(a1, a2, a3);
}

uint64_t _dispatch_client_callout4(uint64_t a1, uint64_t a2, uint64_t a3, unsigned int a4, uint64_t (*a5)(uint64_t, uint64_t, uint64_t, _QWORD))
{
  return a5(a1, a2, a3, a4);
}

_QWORD *_os_object_alloc_bridged(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
}

_QWORD *_os_objc_alloc(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;

  if (a2 < 8)
    _dispatch_abort(1693, a2 >= 8, a3, a4, a5, a6, a7, a8);
  while (1)
  {
    v9 = (_QWORD *)malloc_type_calloc(1, a2, 3970180825);
    if (v9)
      break;
    _dispatch_temporary_resource_shortage();
  }
  *v9 = a1;
  return v9;
}

_QWORD *_os_object_alloc_realized(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *result;

  if (a2 < 0x10)
    _dispatch_abort(1711, a2 >= 0x10, a3, a4, a5, a6, a7, a8);
  result = _os_objc_alloc(a1, a2, a3, a4, a5, a6, a7, a8);
  *((_DWORD *)result + 2) = 1;
  *((_DWORD *)result + 3) = 1;
  return result;
}

_QWORD *_os_object_alloc(void *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;

  v9 = a1;
  if (!a1)
    v9 = &_os_object_vtable;
  return _os_object_alloc_realized((uint64_t)v9, a2, a3, a4, a5, a6, a7, a8);
}

void _os_object_dealloc(_QWORD *a1)
{
  *a1 = 512;
  free(a1);
}

void _os_object_xref_dispose(unsigned int *a1)
{
  atomic_load(a1 + 3);
  if (**(_QWORD **)a1)
    (**(void (***)(unsigned int *))a1)(a1);
  else
    _os_object_release_internal(a1);
}

void _os_object_dispose(unsigned int *a1)
{
  atomic_load(a1 + 2);
  if (*(_QWORD *)(*(_QWORD *)a1 + 8))
    (*(void (**)(unsigned int *))(*(_QWORD *)a1 + 8))(a1);
  else
    _os_object_dealloc(a1);
}

void *__cdecl os_retain(void *object)
{
  if (object)
    return (void *)_os_object_retain((uint64_t)object);
  else
    return 0;
}

void os_release(void *object)
{
  if (object)
    _os_object_release((unsigned int *)object);
}

uint64_t _dispatch_autorelease_pool_push()
{
  uint64_t v1;

  v1 = 0;
  if (_dispatch_begin_NSAutoReleasePool)
    return _dispatch_begin_NSAutoReleasePool();
  return v1;
}

uint64_t _dispatch_autorelease_pool_pop(uint64_t result)
{
  if (_dispatch_end_NSAutoReleasePool)
    return _dispatch_end_NSAutoReleasePool(result);
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_push(uint64_t a1)
{
  uint64_t result;

  result = _dispatch_autorelease_pool_push();
  *(_QWORD *)(a1 + 24) = result;
  return result;
}

uint64_t _dispatch_last_resort_autorelease_pool_pop(uint64_t a1)
{
  uint64_t result;

  result = _dispatch_autorelease_pool_pop(*(_QWORD *)(a1 + 24));
  *(_QWORD *)(a1 + 24) = 0;
  return result;
}

uint64_t dispatch_mach_msg_get_context(uint64_t a1)
{
  uint64_t v2;
  uint64_t v3;

  v2 = 0;
  v3 = a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  if (*(_DWORD *)(v3 + 4) >= 0x3Cu)
    return *(_QWORD *)(v3 + 52);
  return v2;
}

uint64_t _dispatch_wakeup_runloop_thread()
{
  return 0;
}

void _dispatch_mach_notify_port_destroyed(uint64_t a1, unsigned int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of port-destroyed";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A790()
{
  return 5;
}

void _dispatch_mach_notify_no_senders(uint64_t a1, unsigned int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: unexpected receipt of no-more-senders";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A7E8()
{
  return 5;
}

uint64_t _dispatch_mach_notify_send_once(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v9;

  _dispatch_log("Corruption: An app/library deleted a libdispatch dead-name notification", a2, a3, a4, a5, a6, a7, a8, v9);
  return 0;
}

uint64_t _dispatch_mach_xpc_no_handle_message()
{
  return 0;
}

uint64_t _dispatch_mach_msg_context_no_async_reply_queue()
{
  return 0;
}

void _dispatch_mach_default_async_reply_handler()
{
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_mach_default_async_reply_handler called";
  qword_E4DA8 = (uint64_t)_dispatch_mach_xpc_hooks;
  __break(1u);
}

void sub_A8AC()
{
  __break(1u);
}

uint64_t _dispatch_mach_enable_sigterm()
{
  return 1;
}

char *_dispatch_logv_init(uint64_t a1)
{
  char *result;
  pid_t v2;
  pid_t v3;
  const char *v4;
  int v5;
  const char *v6;
  timeval v7;
  char *__s1;
  char v9;
  uint64_t v10;
  char v11[1024];

  v10 = a1;
  v9 = 1;
  result = getenv("LIBDISPATCH_LOG");
  __s1 = result;
  if (result)
  {
    result = (char *)strcmp(__s1, "YES");
    if ((_DWORD)result)
    {
      result = (char *)strcmp(__s1, "NO");
      if ((_DWORD)result)
      {
        result = (char *)strcmp(__s1, "syslog");
        if ((_DWORD)result)
        {
          result = (char *)strcmp(__s1, "file");
          if ((_DWORD)result)
          {
            result = (char *)strcmp(__s1, "stderr");
            if (!(_DWORD)result)
            {
              v9 = 1;
              dispatch_logfile = 2;
            }
          }
          else
          {
            v9 = 1;
          }
        }
        else
        {
          v9 = 0;
        }
      }
      else
      {
        dispatch_log_disabled = 1;
      }
    }
  }
  if ((dispatch_log_disabled & 1) == 0)
  {
    if ((v9 & 1) != 0 && dispatch_logfile == -1)
    {
      v2 = getpid();
      __snprintf_chk(v11, 0x400uLL, 0, 0x400uLL, "/var/tmp/libdispatch.%d.log", v2);
      result = (char *)open_NOCANCEL(v11, 16777993);
      dispatch_logfile = (int)result;
    }
    if (dispatch_logfile != -1)
    {
      v7.tv_sec = 0;
      *(_QWORD *)&v7.tv_usec = 0;
      gettimeofday(&v7, 0);
      dispatch_log_basetime = _dispatch_uptime();
      v5 = dispatch_logfile;
      v6 = getprogname();
      if (v6)
        v4 = v6;
      else
        v4 = "";
      v3 = getpid();
      return (char *)dprintf(v5, "=== log file opened for %s[%u] at %ld.%06u ===\n", v4, v3, v7.tv_sec, v7.tv_usec);
    }
  }
  return result;
}

uint64_t _dispatch_log_file(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;

  v3 = a2 + 1;
  *(_BYTE *)(a1 + a2) = 10;
  do
    result = write_NOCANCEL(dispatch_logfile, a1, v3);
  while (result == -1 && **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) == 4);
  return result;
}

uint64_t _dispatch_logv_file(const char *a1, va_list a2)
{
  uint64_t v2;
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unint64_t v7;
  char v10[2048];

  v2 = _dispatch_uptime();
  v6 = __snprintf_chk(v10, 0x800uLL, 0, 0xFFFFFFFFFFFFFFFFLL, "%llu\t", v2 - dispatch_log_basetime);
  if (v6 >= 0)
  {
    if ((unint64_t)v6 <= 0x800)
      v4 = v6;
    else
      v4 = 2048;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  result = __vsnprintf_chk(&v10[v5], 2048 - v5, 0, 0xFFFFFFFFFFFFFFFFLL, a1, a2);
  if ((int)result >= 0)
  {
    v7 = v5 + (int)result;
    if (v7 > 0x7FF)
      v7 = 2047;
    return _dispatch_log_file((uint64_t)v10, v7);
  }
  return result;
}

uint64_t _dispatch_syslog(uint64_t a1)
{
  return _simple_asl_log(5, "com.apple.libsystem.libdispatch", a1);
}

void _dispatch_vsyslog(char *a1, char *a2)
{
  char *v2[3];

  v2[2] = a1;
  v2[1] = a2;
  v2[0] = 0;
  vasprintf(v2, a1, a2);
  if (v2[0])
  {
    _dispatch_syslog((uint64_t)v2[0]);
    free(v2[0]);
  }
}

uint64_t _dispatch_uptime()
{
  return mach_absolute_time();
}

uint64_t _dispatch_object_debug2(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 40))(a1, a2, a3);
}

uint64_t _os_object_retain_internal(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 8);
    v4 = *(_DWORD *)(result + 8);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2;
  }
  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xB06CLL);
  }
  return result;
}

uint64_t _os_object_retain_internal_n(uint64_t result, unsigned __int16 a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  int v6;

  v6 = *(_DWORD *)(result + 8);
  if (v6 != 0x7FFFFFFF)
  {
    v4 = (unsigned int *)(result + 8);
    v5 = *(_DWORD *)(result + 8);
    do
    {
      v2 = v5;
      do
        v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 + a2, v4));
      v5 = v3;
    }
    while (v3 != v2);
    v6 = v3;
  }
  if (v6 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xB1C4);
  }
  return result;
}

void _os_object_release_internal(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  int v6;

  v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    v3 = a1 + 2;
    v4 = a1[2];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v6 = v2 - 1;
  }
  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB360);
    }
    v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0xB3C0);
    }
    _os_object_dispose(a1);
  }
}

void _os_object_release_internal_n(unsigned int *a1, unsigned __int16 a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  int v6;
  int v7;

  v7 = a1[2];
  if (v7 != 0x7FFFFFFF)
  {
    v4 = a1 + 2;
    v5 = a1[2];
    do
    {
      v2 = v5;
      do
        v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 - a2, v4));
      v5 = v3;
    }
    while (v3 != v2);
    v7 = v3 - a2;
  }
  if (v7 < 1)
  {
    if (v7 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xB56CLL);
    }
    v6 = a1[3];
    if (v6 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0xB5CCLL);
    }
    _os_object_dispose(a1);
  }
}

uint64_t _os_object_retain(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 12);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 12);
    v4 = *(_DWORD *)(result + 12);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2;
  }
  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xB720);
  }
  return result;
}

uint64_t _os_object_retain_with_resurrect(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  v6 = *(_DWORD *)(a1 + 12);
  if (v6 != 0x7FFFFFFF)
  {
    v4 = (unsigned int *)(a1 + 12);
    v5 = *(_DWORD *)(a1 + 12);
    do
    {
      v1 = v5;
      do
        v2 = __ldaxr(v4);
      while (v2 == v5 && __stlxr(v5 + 1, v4));
      v5 = v2;
    }
    while (v2 != v1);
    v6 = v2;
  }
  if ((int)(v6 + 1) <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an over-released object";
    __break(1u);
    JUMPOUT(0xB878);
  }
  if (!v6)
    _os_object_retain_internal(a1);
  return a1;
}

void _os_object_release(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  char v6;

  v5 = a1[3];
  if (v5 != 0x7FFFFFFF)
  {
    v3 = a1 + 3;
    v4 = a1[3];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2 - 1;
  }
  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xBA38);
    }
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  if (v6 == 1)
    _os_object_xref_dispose(a1);
}

void _os_object_release_without_xref_dispose(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  char v6;

  v5 = a1[3];
  if (v5 != 0x7FFFFFFF)
  {
    v3 = a1 + 3;
    v4 = a1[3];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2 - 1;
  }
  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xBBFCLL);
    }
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  if (v6 == 1)
    _os_object_release_internal(a1);
}

_QWORD *_dispatch_object_alloc(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _os_object_alloc_realized(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_object_dealloc(_QWORD *a1)
{
  *a1 = 0;
  free(a1);
}

void dispatch_retain(dispatch_object_t object)
{
  _os_object_retain((uint64_t)object);
}

void dispatch_release(dispatch_object_t object)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  char v6;

  v5 = *((_DWORD *)object + 3);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)((char *)object + 12);
    v4 = *((_DWORD *)object + 3);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2 - 1;
  }
  if (v5 < 1)
  {
    if (v5 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xBE4CLL);
    }
    v6 = 1;
  }
  else
  {
    v6 = 0;
  }
  if (v6 == 1)
  {
    atomic_load((unsigned int *)object + 3);
    _dispatch_xref_dispose((unsigned int *)object);
  }
}

void _dispatch_xref_dispose(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if ((*(_QWORD *)(*(_QWORD *)a1 + 16) & 0xF0) == 0x10)
  {
    _dispatch_queue_xref_dispose((uint64_t)a1);
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    switch(v8)
    {
      case 275:
        _dispatch_source_xref_dispose((uint64_t)a1);
        break;
      case 531:
        _dispatch_channel_xref_dispose((uint64_t)a1);
        break;
      case 787:
        if (((*((_WORD *)a1 + 58) >> 4) & 1) != 0)
          *(_QWORD *)(*((_QWORD *)a1 + 11) + 48) = 195952365;
        break;
      case 395025:
        _dispatch_runloop_queue_xref_dispose((uint64_t)a1, v1, v2, v3, v4, v5, v6, v7);
        break;
    }
  }
  _dispatch_release_tailcall(a1);
}

void _dispatch_release_tailcall(unsigned int *a1)
{
  _os_object_release_internal(a1);
}

void _dispatch_dispose(uint64_t a1)
{
  uint64_t v1;
  BOOL v2;
  char v3;
  void *context;
  dispatch_function_t work;
  dispatch_queue_t queue;
  _QWORD *v7;
  uint64_t v8;
  int v9;
  uint64_t v10;
  int v11;

  v7 = (_QWORD *)a1;
  queue = 0;
  queue = *(dispatch_queue_t *)(a1 + 24);
  work = 0;
  v8 = a1;
  work = *(dispatch_function_t *)(a1 + 40);
  context = 0;
  context = *(void **)(a1 + 32);
  v3 = 1;
  if (*(_QWORD *)(a1 + 16) != -1985229329)
  {
    v1 = v7[2];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while enqueued";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xC0B4);
  }
  v2 = 0;
  if (queue)
    v2 = *((_QWORD *)queue + 8) == 22;
  if (v2)
  {
    v11 = 4;
    v10 = 0;
    v9 = 0;
    queue = (dispatch_queue_t)&off_E4640;
  }
  (*(void (**)(_QWORD *, char *))(*v7 + 32))(v7, &v3);
  if ((v3 & 1) != 0)
  {
    _dispatch_object_finalize();
    _dispatch_object_dealloc(v7);
  }
  if (work && context)
    dispatch_channel_async_f(queue, context, work);
  if (queue)
    _dispatch_release_tailcall((unsigned int *)queue);
}

void *__cdecl dispatch_get_context(dispatch_object_t object)
{
  if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0x40000) != 0)
    return 0;
  else
    return (void *)*((_QWORD *)object + 4);
}

void dispatch_set_context(dispatch_object_t object, void *context)
{
  if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0x40000) == 0)
    *((_QWORD *)object + 4) = context;
}

void dispatch_set_finalizer_f(dispatch_object_t object, dispatch_function_t finalizer)
{
  if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0x40000) == 0)
    *((_QWORD *)object + 5) = finalizer;
}

void dispatch_set_target_queue(dispatch_object_t object, dispatch_queue_t queue)
{
  unsigned int *v2;
  unsigned int *v3;
  unint64_t *v4;
  unsigned int *v5;
  BOOL is_timer;
  char v7;
  char v8;
  int v9;
  char v10;
  uint64_t (***v11)();
  char v13;

  v11 = (uint64_t (***)())queue;
  v10 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v9) = 1;
    if ((*(_BYTE *)(*(_QWORD *)object + 18) & 1) == 0)
      v9 = (*(unsigned __int8 *)(*(_QWORD *)object + 18) >> 1) & 1;
    v10 = v9;
  }
  if ((v10 & 1) == 0)
  {
    v8 = 0;
    if (queue)
    {
      v8 = 0;
      if ((*((_BYTE *)queue + 87) & 8) != 0)
      {
        if (*(_QWORD *)object >= 0x1000uLL)
        {
          v7 = 1;
          if (*(_QWORD *)(*(_QWORD *)object + 16) != 1)
          {
            is_timer = 0;
            if (*(_BYTE *)(*(_QWORD *)object + 16) == 19)
              is_timer = _dispatch_source_is_timer((uint64_t)object);
            v7 = is_timer;
          }
          v13 = v7 & 1;
        }
        else
        {
          v13 = 1;
        }
        v8 = v13 ^ 1;
      }
    }
    if ((v8 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)object;
      __break(1u);
      JUMPOUT(0xC538);
    }
    if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0xF0) == 0x10)
    {
      _dispatch_lane_set_target_queue((uint64_t)object, v11);
    }
    else if (*(_QWORD *)(*(_QWORD *)object + 16) == 4)
    {
      _dispatch_io_set_target_queue((uint64_t)object, (uint64_t)v11);
    }
    else
    {
      if (!v11)
        v11 = &off_E4640;
      _dispatch_retain((uint64_t)v11);
      v4 = (unint64_t *)((char *)object + 24);
      v5 = (unsigned int *)*((_QWORD *)object + 3);
      do
      {
        v2 = v5;
        do
          v3 = (unsigned int *)__ldaxr(v4);
        while (v3 == v5 && __stlxr((unint64_t)v11, v4));
        v5 = v3;
      }
      while (v3 != v2);
      if (v3)
        _dispatch_release(v3);
    }
  }
}

void dispatch_activate(dispatch_object_t object)
{
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    if (*(_BYTE *)(*(_QWORD *)object + 16) == 18)
    {
      _dispatch_workloop_activate((uint64_t)object);
    }
    else if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0xF0) == 0x10)
    {
      _dispatch_lane_resume((unsigned __int16 *)object, 1);
    }
  }
}

void dispatch_suspend(dispatch_object_t object)
{
  BOOL v1;
  int v2;
  char v3;

  v3 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v2) = 1;
    if ((*(_BYTE *)(*(_QWORD *)object + 18) & 1) == 0)
      v2 = (*(unsigned __int8 *)(*(_QWORD *)object + 18) >> 1) & 1;
    v3 = v2;
  }
  if ((v3 & 1) == 0 && (*(_QWORD *)(*(_QWORD *)object + 16) & 0xF0) == 0x10)
  {
    v1 = 0;
    if (*(_BYTE *)(*(_QWORD *)object + 16) == 18)
      v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
    if (v1)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Object type does not support suspension";
      __break(1u);
      JUMPOUT(0xC868);
    }
    _dispatch_lane_suspend((uint64_t)object);
  }
}

void dispatch_resume(dispatch_object_t object)
{
  BOOL v1;
  int v2;
  char v3;

  v3 = 1;
  if (*((_DWORD *)object + 2) != 0x7FFFFFFF)
  {
    LOBYTE(v2) = 1;
    if ((*(_BYTE *)(*(_QWORD *)object + 18) & 1) == 0)
      v2 = (*(unsigned __int8 *)(*(_QWORD *)object + 18) >> 1) & 1;
    v3 = v2;
  }
  if ((v3 & 1) == 0 && (*(_QWORD *)(*(_QWORD *)object + 16) & 0xF0) == 0x10)
  {
    v1 = 0;
    if (*(_BYTE *)(*(_QWORD *)object + 16) == 18)
      v1 = _dispatch_workloop_uses_bound_thread((uint64_t)object);
    if (v1)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Object type does not support resume";
      __break(1u);
      JUMPOUT(0xC9A0);
    }
    _dispatch_lane_resume((unsigned __int16 *)object, 0);
  }
}

uint64_t _dispatch_retain(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 8);
    v4 = *(_DWORD *)(result + 8);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2;
  }
  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0xCB10);
  }
  return result;
}

void _dispatch_release(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  int v6;

  v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    v3 = a1 + 2;
    v4 = a1[2];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v6 = v2 - 1;
  }
  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0xCCA8);
    }
    v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0xCD08);
    }
    _os_object_dispose(a1);
  }
}

void *_dispatch_block_create(void *a1, void *a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v9;
  void **v10;
  int v11;
  int v12;
  void (*v13)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v14;
  _QWORD v15[2];
  int v16;
  int v17;
  uint64_t v18;
  void *v19;
  const void *v20;
  dispatch_group_s *v21;
  unsigned int *v22;
  int v23;
  _QWORD v24[2];
  int v25;
  int v26;
  uint64_t v27;
  void *v28;
  const void *v29;
  dispatch_group_s *v30;
  unsigned int *v31;
  int v32;
  const void *v33;
  uint64_t v34;
  void *v35;
  void *v36;
  const void *v37;
  uint64_t v38;
  void *v39;
  void *v40;
  _QWORD *v41;
  _QWORD *v42;
  _QWORD *v43;
  _QWORD *v44;
  _QWORD *v45;
  const void *v46;
  uint64_t v47;
  void *v48;
  void *v49;
  _QWORD *v50;
  _QWORD *v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  _QWORD *v55;
  _QWORD *v56;
  _QWORD *v57;

  v36 = a1;
  v35 = a2;
  v34 = a3;
  v33 = a4;
  v41 = v24;
  v40 = a1;
  v39 = a2;
  v38 = a3;
  v37 = a4;
  v50 = v24;
  v49 = a1;
  v48 = a2;
  v47 = a3;
  v46 = a4;
  v24[0] = 0;
  v24[1] = a1;
  v25 = 0;
  v26 = 0;
  v27 = a3;
  v28 = a2;
  v29 = a4;
  v30 = 0;
  v31 = 0;
  v32 = 0;
  v10 = _NSConcreteStackBlock;
  v11 = 1174405120;
  v12 = 0;
  v13 = ___dispatch_block_create_block_invoke;
  v14 = &__block_descriptor_tmp_0;
  v43 = v15;
  v42 = v24;
  v52 = v15;
  v51 = v24;
  v53 = v15;
  v15[0] = 3512316172;
  v15[1] = a1;
  v16 = 0;
  v17 = 0;
  v18 = a3;
  v19 = a2;
  v20 = 0;
  v21 = 0;
  v22 = 0;
  v23 = 0;
  if (a2 && v19 != (void *)-1)
    a1 = voucher_retain(v19);
  if (v51[5])
  {
    a1 = _dispatch_Block_copy((const void *)v51[5]);
    v20 = a1;
  }
  if (*v51)
    v21 = (dispatch_group_s *)_dispatch_group_create_and_enter((uint64_t)a1, (uint64_t)a2, a3, (uint64_t)a4, a5, a6, a7, a8);
  v9 = _dispatch_Block_copy(&v10);
  v45 = v15;
  v54 = v15;
  v55 = v15;
  if (v15[0] == 3512316172)
  {
    if (v21)
    {
      if (!v17)
        dispatch_group_leave(v21);
      _os_object_release_without_xref_dispose((unsigned int *)v21);
    }
    if (v22)
      _os_object_release_internal_n(v22, 2u);
    if (v20)
      _Block_release(v20);
    if (v19 && v19 != (void *)-1)
      voucher_release(v19);
  }
  v44 = v24;
  v56 = v24;
  v57 = v24;
  if (v24[0] == 3512316172)
  {
    if (v30)
    {
      if (!v26)
        dispatch_group_leave(v30);
      _os_object_release_without_xref_dispose((unsigned int *)v30);
    }
    if (v31)
      _os_object_release_internal_n(v31, 2u);
    if (v29)
      _Block_release(v29);
    if (v28 && v28 != (void *)-1)
      voucher_release(v28);
  }
  return v9;
}

void ___dispatch_block_create_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_block_invoke_direct(a1 + 32, a2, a3, a4, a5, a6, a7, a8);
}

char *__copy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s(char *result, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char *v8;
  _QWORD *v9;

  v9 = a2 + 4;
  v8 = result + 32;
  *((_QWORD *)result + 4) = 3512316172;
  *((_QWORD *)result + 5) = a2[5];
  *((_DWORD *)result + 12) = 0;
  *((_DWORD *)result + 13) = 0;
  *((_QWORD *)result + 7) = a2[7];
  *((_QWORD *)result + 8) = a2[8];
  *((_QWORD *)result + 9) = 0;
  *((_QWORD *)result + 10) = 0;
  *((_QWORD *)result + 11) = 0;
  *((_DWORD *)result + 24) = 0;
  if (*((_QWORD *)result + 8) && *((_QWORD *)result + 8) != -1)
    result = (char *)voucher_retain(*((void **)result + 8));
  if (v9[5])
  {
    result = (char *)_dispatch_Block_copy((const void *)v9[5]);
    *((_QWORD *)v8 + 5) = result;
  }
  if (*v9)
  {
    result = (char *)_dispatch_group_create_and_enter((uint64_t)result, (uint64_t)a2, a3, a4, a5, a6, a7, a8);
    *((_QWORD *)v8 + 6) = result;
  }
  return result;
}

void __destroy_helper_block_8_32c35_ZTS29dispatch_block_private_data_s(uint64_t a1)
{
  uint64_t v1;

  v1 = a1 + 32;
  if (*(_QWORD *)(a1 + 32) == 3512316172)
  {
    if (*(_QWORD *)(a1 + 80))
    {
      if (!*(_DWORD *)(a1 + 52))
        dispatch_group_leave(*(dispatch_group_t *)(a1 + 80));
      _os_object_release_without_xref_dispose(*(unsigned int **)(v1 + 48));
    }
    if (*(_QWORD *)(v1 + 56))
      _os_object_release_internal_n(*(unsigned int **)(v1 + 56), 2u);
    if (*(_QWORD *)(v1 + 40))
      _Block_release(*(const void **)(v1 + 40));
    if (*(_QWORD *)(v1 + 32))
    {
      if (*(_QWORD *)(v1 + 32) != -1)
        voucher_release(*(void **)(v1 + 32));
    }
  }
}

void _dispatch_sema4_create_slow(unsigned int *a1, int a2)
{
  unsigned int v2;
  unsigned int *v3;
  semaphore_t v4;
  unsigned int v5;
  kern_return_t v6;
  kern_return_t v7;
  semaphore_t semaphore;
  int policy;
  unsigned int *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t StatusReg;

  v10 = a1;
  policy = a2;
  semaphore = 0;
  if ((_dispatch_unsafe_fork & 1) == 0)
    _dispatch_fork_becomes_unsafe_slow();
  if (policy)
  {
    v6 = semaphore_create(mach_task_self_, &semaphore, policy, 0);
    if (v6 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0xD68CLL);
    }
    if (v6 == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15;
      __break(1u);
      JUMPOUT(0xD6E0);
    }
    if (v6)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0xD730);
    }
    v3 = v10;
    v4 = semaphore;
    do
      v5 = __ldaxr(v3);
    while (!v5 && __stlxr(v4, v3));
    if (v5)
    {
      v7 = semaphore_destroy(mach_task_self_, semaphore);
      if (v7 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0xD848);
      }
      if (v7 == 15)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
        qword_E4DA8 = 15;
        __break(1u);
        JUMPOUT(0xD89CLL);
      }
      if (v7)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_E4DA8 = v7;
        __break(1u);
        JUMPOUT(0xD8ECLL);
      }
    }
  }
  else
  {
    v11 = 0;
    v16 = 9;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v11 = *(_QWORD *)(StatusReg + 72);
    if (v11)
    {
      v20 = 9;
      v19 = 0;
      v21 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      *(_QWORD *)(v21 + 72) = 0;
      v12 = v11;
    }
    else
    {
      v12 = _os_semaphore_create();
    }
    semaphore = v12;
    do
      v2 = __ldaxr(v10);
    while (!v2 && __stlxr(v12, v10));
    if (v2)
    {
      v14 = semaphore;
      v13 = 0;
      v15 = 9;
      v13 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
      v18 = 9;
      v17 = semaphore;
      *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
      if (v13)
        _os_semaphore_dispose(v13);
    }
  }
}

semaphore_t *_dispatch_sema4_dispose_slow(semaphore_t *result, int a2)
{
  semaphore_t semaphore;
  uint64_t v3;

  semaphore = *result;
  *result = -1;
  if (a2)
  {
    result = (semaphore_t *)semaphore_destroy(mach_task_self_, semaphore);
    if ((_DWORD)result == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0xDA3CLL);
    }
    if ((_DWORD)result == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15;
      __break(1u);
      JUMPOUT(0xDA90);
    }
    if ((_DWORD)result)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = (int)result;
      __break(1u);
      JUMPOUT(0xDAE0);
    }
  }
  else
  {
    v3 = *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72);
    *(_QWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 72) = semaphore;
    if (v3)
      return (semaphore_t *)_os_semaphore_dispose(v3);
  }
  return result;
}

uint64_t _dispatch_sema4_signal(semaphore_t *a1, uint64_t a2)
{
  uint64_t result;

  do
  {
    result = semaphore_signal(*a1);
    if ((_DWORD)result == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0xDB7CLL);
    }
    if ((_DWORD)result == 15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15;
      __break(1u);
      JUMPOUT(0xDBD0);
    }
    if ((_DWORD)result)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
      qword_E4DA8 = (int)result;
      __break(1u);
      JUMPOUT(0xDC20);
    }
    --a2;
  }
  while (a2);
  return result;
}

uint64_t _dispatch_sema4_wait(semaphore_t *a1)
{
  uint64_t result;

  do
    result = semaphore_wait(*a1);
  while ((_DWORD)result == 14);
  if ((_DWORD)result == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0xDCE4);
  }
  if ((_DWORD)result == 15)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
    qword_E4DA8 = 15;
    __break(1u);
    JUMPOUT(0xDD38);
  }
  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0xDD88);
  }
  return result;
}

uint64_t _dispatch_sema4_timedwait(semaphore_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  mach_timespec_t v8;
  unint64_t v10;
  kern_return_t v11;
  mach_timespec_t v12;

  do
  {
    v10 = _dispatch_timeout(a2, a2, a3, a4, a5, a6, a7, a8);
    v12.tv_sec = v10 / 0x3B9ACA00;
    v12.tv_nsec = v10 % 0x3B9ACA00;
    v8 = v12;
    v11 = semaphore_timedwait(*a1, v8);
  }
  while (v11 == 14);
  switch(v11)
  {
    case 49:
      return 1;
    case -301:
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0xDEBCLL);
    case 15:
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Use-after-free of dispatch_semaphore_t or dispatch_group_t";
      qword_E4DA8 = 15;
      __break(1u);
      JUMPOUT(0xDF10);
    default:
      if (v11)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach semaphore API failure";
        qword_E4DA8 = v11;
        __break(1u);
        JUMPOUT(0xDF60);
      }
      return 0;
  }
}

uint64_t _dispatch_wait_on_address(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v16;
  unint64_t v17;
  unsigned int v18;
  uint64_t v19;
  unint64_t v20;
  int v22;
  unsigned int v24;

  v24 = a2;
  v22 = a4;
  v20 = _dispatch_timeout(a3, a2, a3, a4, a5, a6, a7, a8);
  if (v20)
  {
    if (v20 == -1)
    {
      return _dispatch_ulock_wait(a1, v24, 0, v22);
    }
    else
    {
      do
      {
        if (v20 % 0x3E8)
          v17 = v20 / 0x3E8 + 1;
        else
          v17 = v20 / 0x3E8;
        v19 = v17;
        if (v17 > 0xFFFFFFFF)
          v19 = 0xFFFFFFFFLL;
        v18 = _dispatch_ulock_wait(a1, v24, v19, v22);
        v16 = 0;
        if (v19 == 0xFFFFFFFFLL)
        {
          v16 = 0;
          if (v18 == 60)
          {
            v20 = _dispatch_timeout(a3, v8, v9, v10, v11, v12, v13, v14);
            v16 = v20 != 0;
          }
        }
      }
      while (v16);
      return v18;
    }
  }
  else
  {
    return 60;
  }
}

uint64_t _dispatch_ulock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  return _dlock_wait(a1, a2, a3, a4 | 1u);
}

uint64_t _dispatch_wake_by_address(uint64_t a1)
{
  return _dispatch_ulock_wake(a1, 256);
}

uint64_t _dispatch_ulock_wake(uint64_t a1, int a2)
{
  return _dlock_wake(a1, a2 | 1u);
}

uint64_t _dispatch_thread_event_signal_slow(uint64_t a1)
{
  return _dispatch_ulock_wake(a1, 0);
}

BOOL _dispatch_thread_event_wait_slow(_BOOL8 result)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _BOOL4 v8;
  int v9;
  unsigned int *v10;

  v10 = (unsigned int *)result;
  while (1)
  {
    v1 = atomic_load(v10);
    if (!v1)
      break;
    if (v1 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt thread event value";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0xE2A8);
    }
    v9 = _dispatch_ulock_wait((uint64_t)v10, 0xFFFFFFFF, 0, 0);
    v8 = 1;
    if (v9)
    {
      v8 = 1;
      if (v9 != 14)
        v8 = v9 == 4;
    }
    result = v8;
    if (!v8)
      _dispatch_abort(559, v8, v2, v3, v4, v5, v6, v7);
  }
  return result;
}

uint64_t _dispatch_unfair_lock_lock_slow(unsigned int *a1, int a2)
{
  uint64_t v2;
  uint64_t result;
  _BOOL4 v4;
  unsigned int v5;
  unsigned int v6;
  int v7;
  unsigned int v8;

  v8 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v5 = v8;
  while (1)
  {
    do
    {
      if (_os_atomic_mo_has_acquire(2))
        v2 = __ldaxr(a1);
      else
        v2 = __ldxr(a1);
      result = v2;
      v7 = v2;
      if ((v2 & 0xFFFFFFFC) != 0)
      {
        v6 = v2 | 1;
        if ((v2 | 1) == (_DWORD)v2)
        {
          __clrex();
          break;
        }
      }
      else
      {
        v6 = v5;
      }
      if (_os_atomic_mo_has_release(2))
      {
        result = v6;
        v4 = __stlxr(v6, a1) == 0;
      }
      else
      {
        result = v6;
        v4 = __stxr(v6, a1) == 0;
      }
    }
    while (!v4);
    if (((v7 ^ v8) & 0xFFFFFFFC) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
      __break(1u);
      JUMPOUT(0xE50CLL);
    }
    if (v6 == v5)
      return result;
    if (_dispatch_unfair_lock_wait((uint64_t)a1, v6, 0, a2) == 66)
      v5 |= 1u;
  }
}

uint64_t _dispatch_unfair_lock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  return _dlock_wait(a1, a2, a3, a4 | 2u);
}

void *_dispatch_unfair_lock_unlock_slow(uint64_t a1, unsigned int a2)
{
  void *result;

  result = _dispatch_thread_getspecific(3uLL);
  if (((a2 ^ result) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xE634);
  }
  if ((a2 & 1) != 0)
    return (void *)_dispatch_unfair_lock_wake(a1, 0);
  return result;
}

uint64_t _dispatch_unfair_lock_wake(uint64_t a1, int a2)
{
  return _dlock_wake(a1, a2 | 2u);
}

BOOL _dispatch_once_wait(unint64_t *a1)
{
  _BOOL8 result;
  unint64_t v2;
  _BOOL4 v3;
  uint64_t v4;
  int v5;
  unsigned int v6;

  v6 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  while (1)
  {
    result = _os_atomic_mo_has_acquire(0);
    if (result)
      v2 = __ldaxr(a1);
    else
      v2 = __ldxr(a1);
    v5 = v2;
    if (v2 == -1)
    {
      __clrex();
      return result;
    }
    if ((v2 & 3) == 2)
      break;
    v4 = v2 | 1;
    if ((v2 | 1) == v2)
    {
      __clrex();
LABEL_16:
      if (((v5 ^ v6) & 0xFFFFFFFC) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to lock recursively";
        __break(1u);
        JUMPOUT(0xE8D8);
      }
      _dispatch_unfair_lock_wait((uint64_t)a1, v4, 0, 0);
    }
    else
    {
      if (_os_atomic_mo_has_release(0))
        v3 = __stlxr(v4, a1) == 0;
      else
        v3 = __stxr(v4, a1) == 0;
      if (v3)
        goto LABEL_16;
    }
  }
  __clrex();
  __dmb(9u);
  if (4 * MEMORY[0xFFFFFC180] - v2 + 2 >= 0x10)
    *a1 = -1;
  return result;
}

uint64_t _dispatch_gate_broadcast_slow(uint64_t a1, unsigned int a2)
{
  if (((a2 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: lock not owned by current thread";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xE988);
  }
  return _dispatch_unfair_lock_wake(a1, 256);
}

uint64_t _dispatch_firehose_gate_wait(uint64_t a1, unsigned int a2, int a3)
{
  return _dispatch_unfair_lock_wait(a1, a2, 0, a3);
}

uint64_t _dlock_wait(uint64_t a1, unsigned int a2, unsigned int a3, int a4)
{
  int v5;
  int v6;

  while (1)
  {
    v6 = __ulock_wait(a4 | 0x1000000u, a1, a2, a3);
    if (v6 >= 1)
      return 66;
    v5 = -v6;
    if (!v6)
      return 0;
    if (v5 != 4)
      break;
    if (a3)
      return -v6;
  }
  if (v5 != 14 && v5 != 60)
  {
    if (v5 != 105)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wait() failed";
      qword_E4DA8 = -v6;
      __break(1u);
      JUMPOUT(0xEB64);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Owner in ulock is unknown - possible memory corruption";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0xEB10);
  }
  return -v6;
}

uint64_t _dlock_wake(uint64_t a1, int a2)
{
  uint64_t result;

  result = __ulock_wake(a2 | 0x1000000u, a1, 0);
  if ((_DWORD)result && (_DWORD)result != -2)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: ulock_wake() failed";
    qword_E4DA8 = -(int)result;
    __break(1u);
    JUMPOUT(0xEC20);
  }
  return result;
}

dispatch_semaphore_t dispatch_semaphore_create(intptr_t value)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v7;

  if (value < 0)
    return 0;
  v7 = _dispatch_object_alloc((uint64_t)_OS_dispatch_semaphore_vtable, 0x48uLL, v1, v2, v3, v4, v5, v6);
  v7[2] = -1985229329;
  v7[3] = &off_E4640;
  v7[6] = value;
  *((_DWORD *)v7 + 16) = 0;
  v7[7] = value;
  return (dispatch_semaphore_t)v7;
}

semaphore_t *_dispatch_semaphore_dispose(semaphore_t *result)
{
  uint64_t v1;

  if (*((_QWORD *)result + 6) < *((_QWORD *)result + 7))
  {
    v1 = *((_QWORD *)result + 7) - *((_QWORD *)result + 6);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Semaphore object deallocated while in use (current value < original value)";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xED5CLL);
  }
  if (result[16])
    return _dispatch_sema4_dispose_slow(result + 16, 0);
  return result;
}

uint64_t _dispatch_semaphore_signal_slow(uint64_t a1)
{
  if (!*(_DWORD *)(a1 + 64))
    _dispatch_sema4_create_slow((unsigned int *)(a1 + 64), 0);
  _dispatch_sema4_signal((semaphore_t *)(a1 + 64), 1);
  return 1;
}

intptr_t dispatch_semaphore_signal(dispatch_semaphore_t dsema)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t *v4;
  unint64_t v5;

  v4 = (unint64_t *)((char *)dsema + 48);
  v5 = *((_QWORD *)dsema + 6);
  do
  {
    v1 = v5;
    do
      v2 = __ldaxr(v4);
    while (v2 == v5 && __stlxr(v5 + 1, v4));
    v5 = v2;
  }
  while (v2 != v1);
  if ((uint64_t)(v2 + 1) >= 1)
    return 0;
  if (v2 == 0x7FFFFFFFFFFFFFFFLL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_semaphore_signal()";
    qword_E4DA8 = 0x8000000000000000;
    __break(1u);
    JUMPOUT(0xEF60);
  }
  return _dispatch_semaphore_signal_slow((uint64_t)dsema);
}

intptr_t dispatch_semaphore_wait(dispatch_semaphore_t dsema, dispatch_time_t timeout)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t *v11;
  unint64_t v12;

  v11 = (unint64_t *)((char *)dsema + 48);
  v12 = *((_QWORD *)dsema + 6);
  do
  {
    v8 = v12;
    do
      v9 = __ldaxr(v11);
    while (v9 == v12 && __stlxr(v12 - 1, v11));
    v12 = v9;
  }
  while (v9 != v8);
  if ((uint64_t)(v9 - 1) < 0)
    return _dispatch_semaphore_wait_slow((uint64_t)dsema, timeout, v2, v3, v4, v5, v6, v7);
  else
    return 0;
}

uint64_t _dispatch_semaphore_wait_slow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  unint64_t v9;
  BOOL v11;
  uint64_t v12;
  uint64_t v13;

  if (!*(_DWORD *)(a1 + 64))
    _dispatch_sema4_create_slow((unsigned int *)(a1 + 64), 0);
  if (a2 != -1)
  {
    if (a2 && (_dispatch_sema4_timedwait((semaphore_t *)(a1 + 64), a2, a3, a4, a5, a6, a7, a8) & 1) == 0)
      return 0;
    v13 = *(_QWORD *)(a1 + 48);
    while (v13 < 0)
    {
      v12 = v13;
      v8 = (unint64_t *)(a1 + 48);
      do
        v9 = __ldaxr(v8);
      while (v9 == v13 && __stlxr(v13 + 1, v8));
      v11 = v9 == v13;
      if (v9 != v13)
        v12 = v9;
      v13 = v12;
      if (v11)
        return 49;
    }
  }
  _dispatch_sema4_wait((semaphore_t *)(a1 + 64));
  return 0;
}

dispatch_group_t dispatch_group_create(void)
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  dispatch_group_s *v7;

  v7 = (dispatch_group_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, v0, v1, v2, v3, v4, v5);
  *((_QWORD *)v7 + 2) = -1985229329;
  *((_QWORD *)v7 + 3) = &off_E4640;
  return v7;
}

_QWORD *_dispatch_group_create_and_enter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;

  v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_group_vtable, 0x48uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329;
  v9[3] = &off_E4640;
  *((_DWORD *)v9 + 12) = -4;
  _dispatch_retain((uint64_t)v9);
  return v9;
}

uint64_t _dispatch_group_dispose(uint64_t result)
{
  uint64_t v1;

  v1 = *(_QWORD *)(result + 48);
  if ((_DWORD)v1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Group object deallocated while in use";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0xF46CLL);
  }
  return result;
}

intptr_t dispatch_group_wait(dispatch_group_t group, dispatch_time_t timeout)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t *v9;
  _BOOL4 v10;
  unint64_t v11;

  v9 = (unint64_t *)((char *)group + 48);
  while (1)
  {
    if (_os_atomic_mo_has_acquire(0))
      v7 = __ldaxr(v9);
    else
      v7 = __ldxr(v9);
    if ((v7 & 0xFFFFFFFC) == 0)
    {
      __dmb(9u);
      return 0;
    }
    if (!timeout)
    {
      __clrex();
      return 49;
    }
    v11 = v7 | 1;
    if ((v7 & 1) != 0)
      break;
    if (_os_atomic_mo_has_release(0))
      v10 = __stlxr(v11, v9) == 0;
    else
      v10 = __stxr(v11, v9) == 0;
    if (v10)
      return _dispatch_group_wait_slow((uint64_t)group, HIDWORD(v11), timeout, v2, v3, v4, v5, v6);
  }
  __clrex();
  return _dispatch_group_wait_slow((uint64_t)group, HIDWORD(v11), timeout, v2, v3, v4, v5, v6);
}

uint64_t _dispatch_group_wait_slow(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  int v11;

  do
  {
    v11 = _dispatch_wait_on_address(a1 + 52, a2, a3, 0, a5, a6, a7, a8);
    v8 = a2;
    v9 = atomic_load((unsigned int *)(a1 + 52));
    if (v8 != v9)
      return 0;
  }
  while (v11 != 60);
  return 49;
}

void dispatch_group_leave(dispatch_group_t group)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  BOOL v5;
  unint64_t *v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;

  v6 = (unint64_t *)((char *)group + 48);
  v7 = *((_QWORD *)group + 6);
  do
  {
    v1 = v7;
    do
      v2 = __ldaxr(v6);
    while (v2 == v7 && __stlxr(v7 + 4, v6));
    v7 = v2;
  }
  while (v2 != v1);
  if ((v2 & 0xFFFFFFFC) == 0xFFFFFFFC)
  {
    v9 = v2 + 4;
    do
    {
      if ((v9 & 0xFFFFFFFC) != 0)
        v10 = v9 & 0xFFFFFFFFFFFFFFFDLL;
      else
        v10 = v9 & 0xFFFFFFFFFFFFFFFCLL;
      if (v9 == v10)
        break;
      v8 = v9;
      v3 = (unint64_t *)((char *)group + 48);
      do
        v4 = __ldaxr(v3);
      while (v4 == v9 && __stlxr(v10, v3));
      v5 = v4 == v9;
      if (v4 != v9)
        v8 = v4;
      v9 = v8;
    }
    while (!v5);
    _dispatch_group_wake((uint64_t)group, v9, 1);
  }
  else if ((v2 & 0xFFFFFFFC) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unbalanced call to dispatch_group_leave()";
    qword_E4DA8 = 0;
    __break(1u);
    JUMPOUT(0xF948);
  }
}

void _dispatch_group_wake(uint64_t a1, char a2, char a3)
{
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  _QWORD *v8;
  unint64_t *v9;
  unint64_t v10;
  uint64_t v11;
  _QWORD *v12;
  unsigned int *v13;
  uint64_t v14;
  _QWORD *v15;
  unsigned __int16 v16;

  v16 = (a3 & 1) != 0;
  if ((a2 & 2) != 0)
  {
    v14 = *(_QWORD *)(a1 + 56);
    if (!v14)
      v14 = _dispatch_wait_for_enqueuer((unint64_t *)(a1 + 56), a1 + 64);
    *(_QWORD *)(a1 + 56) = 0;
    v9 = (unint64_t *)(a1 + 64);
    v10 = *(_QWORD *)(a1 + 64);
    do
    {
      v3 = v10;
      do
        v4 = __ldaxr(v9);
      while (v4 == v10 && __stlxr(0, v9));
      v8 = (_QWORD *)v4;
      v10 = v4;
    }
    while (v4 != v3);
    v15 = (_QWORD *)v14;
    do
    {
      v13 = (unsigned int *)v15[6];
      v12 = 0;
      if (v15 != v8)
      {
        v11 = v15[2];
        if (!v11)
          v11 = _dispatch_wait_for_enqueuer(v15 + 2, 0);
        v12 = (_QWORD *)v11;
      }
      v5 = (v15[1] & 0x3FFF00uLL) >> 8;
      v6 = __clz(__rbit32(v5));
      if (v5)
        v7 = v6 + 1;
      else
        v7 = 0;
      (*(void (**)(unsigned int *, _QWORD *, _QWORD))(*(_QWORD *)v13 + 72))(v13, v15, v7);
      _dispatch_release(v13);
      v15 = v12;
    }
    while (v12);
    ++v16;
  }
  if ((a2 & 1) != 0)
    _dispatch_wake_by_address(a1 + 52);
  if (v16)
    _dispatch_release_n((unsigned int *)a1, v16);
}

void dispatch_group_enter(dispatch_group_t group)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  unsigned int v6;

  v4 = (unsigned int *)((char *)group + 48);
  v5 = *((_DWORD *)group + 12);
  do
  {
    v1 = v5;
    do
      v2 = __ldaxr(v4);
    while (v2 == v5 && __stlxr(v5 - 4, v4));
    v3 = v2;
    v5 = v2;
  }
  while (v2 != v1);
  v6 = v2 & 0xFFFFFFFC;
  if ((v2 & 0xFFFFFFFC) == 0)
    _dispatch_retain((uint64_t)group);
  if (v6 == 4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_group_enter()";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0xFE68);
  }
}

void dispatch_group_notify_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  _QWORD *v21;
  unint64_t *v22;
  _BOOL4 v23;
  unint64_t v24;
  uint64_t v25;
  _QWORD *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;
  void *v30;
  uint64_t v31;

  v26 = _dispatch_thread_getspecific(0x16uLL);
  if (v26)
  {
    _dispatch_thread_setspecific(22, v26[2]);
    v21 = v26;
  }
  else
  {
    v21 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v21 = 260;
  v21[4] = work;
  v21[5] = context;
  v28 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v28 <= 0x10FF)
    v29 = v28;
  else
    v29 = 4351;
  v30 = _dispatch_thread_getspecific(0x1CuLL);
  if (v30)
    os_retain(v30);
  v21[3] = v30;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  v31 = v21[3];
  if (v31 != -1)
  {
    v16 = v31 ? *(_DWORD *)(v31 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v16, v21, 0, 0);
  }
  v27 = v29;
  if (v29 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0)
    v27 = 0;
  v21[1] = v27;
  v21[6] = queue;
  _dispatch_retain((uint64_t)queue);
  v21[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)group + 64);
  v14 = (unint64_t *)((char *)group + 64);
  v15 = *((_QWORD *)group + 8);
  do
  {
    v11 = v15;
    do
      v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr((unint64_t)v21, v14));
    v15 = v12;
  }
  while (v12 != v11);
  v24 = v12;
  if (!v12)
    _dispatch_retain((uint64_t)group);
  if (v24)
    *(_QWORD *)(v24 + 16) = v21;
  else
    *((_QWORD *)group + 7) = v21;
  _dispatch_thread_setspecific(122, 0);
  if (!v24)
  {
    v22 = (unint64_t *)((char *)group + 48);
    while (1)
    {
      v13 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v22) : __ldxr(v22);
      v25 = v13 | 2;
      if (!(_DWORD)v13)
        break;
      if (_os_atomic_mo_has_release(3))
        v23 = __stlxr(v25, v22) == 0;
      else
        v23 = __stxr(v25, v22) == 0;
      if (v23)
        return;
    }
    __clrex();
    _dispatch_group_wake((uint64_t)group, v25, 0);
  }
}

void dispatch_group_notify(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unsigned int v15;
  uint64_t *v19;
  unint64_t *v20;
  _BOOL4 v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;
  uint64_t *v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  void *v29;
  uint64_t v30;

  v25 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v25)
  {
    _dispatch_thread_setspecific(22, v25[2]);
    v19 = v25;
  }
  else
  {
    v19 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v24 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *v19 = 276;
    v19[5] = (uint64_t)v24;
    _dispatch_continuation_init_slow(v19, (unsigned int *)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *v19 = 276;
    v19[4] = (uint64_t)_dispatch_call_block_and_release;
    v19[5] = (uint64_t)v24;
    v27 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v27 <= 0x10FF)
      v28 = v27;
    else
      v28 = 4351;
    v29 = _dispatch_thread_getspecific(0x1CuLL);
    if (v29)
      os_retain(v29);
    v19[3] = (uint64_t)v29;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    v30 = v19[3];
    if (v30 != -1)
    {
      v15 = v30 ? *(_DWORD *)(v30 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v15, v19, 0, 0);
    }
    v26 = v28;
    if (v28 && (*((_DWORD *)queue + 21) & 0x40000000) == 0 && (*((_DWORD *)queue + 21) & 0xFFF) != 0)
      v26 = 0;
    v19[1] = v26;
  }
  v19[6] = (uint64_t)queue;
  _dispatch_retain((uint64_t)queue);
  v19[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)group + 64);
  v13 = (unint64_t *)((char *)group + 64);
  v14 = *((_QWORD *)group + 8);
  do
  {
    v10 = v14;
    do
      v11 = __ldaxr(v13);
    while (v11 == v14 && __stlxr((unint64_t)v19, v13));
    v14 = v11;
  }
  while (v11 != v10);
  v22 = v11;
  if (!v11)
    _dispatch_retain((uint64_t)group);
  if (v22)
    *(_QWORD *)(v22 + 16) = v19;
  else
    *((_QWORD *)group + 7) = v19;
  _dispatch_thread_setspecific(122, 0);
  if (!v22)
  {
    v20 = (unint64_t *)((char *)group + 48);
    while (1)
    {
      v12 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v20) : __ldxr(v20);
      v23 = v12 | 2;
      if (!(_DWORD)v12)
        break;
      if (_os_atomic_mo_has_release(3))
        v21 = __stlxr(v23, v20) == 0;
      else
        v21 = __stxr(v23, v20) == 0;
      if (v21)
        return;
    }
    __clrex();
    _dispatch_group_wake((uint64_t)group, v23, 0);
  }
}

void dispatch_group_async_f(dispatch_group_t group, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _QWORD *v19;
  _QWORD *v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;

  v20 = _dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22, v20[2]);
    v19 = v20;
  }
  else
  {
    v19 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v19 = 268;
  v19[4] = work;
  v19[5] = context;
  v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v23 <= 0x10FF)
    v24 = v23;
  else
    v24 = 4351;
  v25 = _dispatch_thread_getspecific(0x1CuLL);
  if (v25)
    os_retain(v25);
  v19[3] = v25;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  v26 = v19[3];
  if (v26 != -1)
  {
    v14 = v26 ? *(_DWORD *)(v26 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v14, v19, 0, 0);
  }
  v22 = v24;
  v21 = 0;
  if (v24)
  {
    if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
    {
      v11 = v24 >> 8;
      v12 = __clz(__rbit32(v11));
      if (v11)
        v13 = v12 + 1;
      else
        v13 = 0;
      v21 = v13;
    }
    else
    {
      v22 = 0;
    }
  }
  v19[1] = v22;
  dispatch_group_enter(group);
  v19[6] = group;
  (*(void (**)(dispatch_queue_t, _QWORD *, _QWORD))(*(_QWORD *)queue + 72))(queue, v19, v21);
}

void dispatch_group_async(dispatch_group_t group, dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t *v17;
  void *v18;
  unsigned int inited;
  uint64_t *v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  void *v25;
  uint64_t v26;

  v20 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v20)
  {
    _dispatch_thread_setspecific(22, v20[2]);
    v17 = v20;
  }
  else
  {
    v17 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v18 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *v17 = 284;
    v17[5] = (uint64_t)v18;
    inited = _dispatch_continuation_init_slow(v17, (unsigned int *)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *v17 = 284;
    v17[4] = (uint64_t)_dispatch_call_block_and_release;
    v17[5] = (uint64_t)v18;
    v23 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v23 <= 0x10FF)
      v24 = v23;
    else
      v24 = 4351;
    v25 = _dispatch_thread_getspecific(0x1CuLL);
    if (v25)
      os_retain(v25);
    v17[3] = (uint64_t)v25;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    v26 = v17[3];
    if (v26 != -1)
    {
      v13 = v26 ? *(_DWORD *)(v26 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v13, v17, 0, 0);
    }
    v22 = v24;
    v21 = 0;
    if (v24)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        v10 = v24 >> 8;
        v11 = __clz(__rbit32(v10));
        if (v10)
          v12 = v11 + 1;
        else
          v12 = 0;
        v21 = v12;
      }
      else
      {
        v22 = 0;
      }
    }
    v17[1] = v22;
    inited = v21;
  }
  dispatch_group_enter(group);
  v17[6] = (uint64_t)group;
  (*(void (**)(dispatch_queue_t, uint64_t *, _QWORD))(*(_QWORD *)queue + 72))(queue, v17, inited);
}

void _dispatch_release_n(unsigned int *a1, int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  int v6;
  int v7;

  v7 = a1[2];
  if (v7 != 0x7FFFFFFF)
  {
    v4 = a1 + 2;
    v5 = a1[2];
    do
    {
      v2 = v5;
      do
        v3 = __ldaxr(v4);
      while (v3 == v5 && __stlxr(v5 - a2, v4));
      v5 = v3;
    }
    while (v3 != v2);
    v7 = v3 - a2;
  }
  if (v7 < 1)
  {
    if (v7 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x11FA4);
    }
    v6 = a1[3];
    if (v6 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x12004);
    }
    _os_object_dispose(a1);
  }
}

void dispatch_once(dispatch_once_t *predicate, dispatch_block_t block)
{
  void (__cdecl *v2)(void *);

  v2 = (void (__cdecl *)(void *))_Block_get_invoke_fn((uint64_t)block);
  dispatch_once_f(predicate, block, v2);
}

void dispatch_once_f(dispatch_once_t *predicate, void *context, dispatch_function_t function)
{
  unint64_t v3;
  unsigned int v4;
  unint64_t v5;

  v3 = atomic_load((unint64_t *)predicate);
  if (v3 != -1)
  {
    if ((v3 & 3) == 2)
    {
      if (4 * MEMORY[0xFFFFFC180] + 2 - v3 >= 0x10)
        *predicate = -1;
    }
    else
    {
      v4 = _dispatch_thread_getspecific(3uLL);
      do
        v5 = __ldaxr((unint64_t *)predicate);
      while (!v5 && __stlxr(v4 & 0xFFFFFFFC, (unint64_t *)predicate));
      if (v5)
        _dispatch_once_wait((unint64_t *)predicate);
      else
        _dispatch_once_callout((unint64_t *)predicate, (uint64_t)context, (void (*)(void (**)(void)))function);
    }
  }
}

uint64_t _dispatch_once_callout(unint64_t *a1, uint64_t a2, void (*a3)(void (**a1)(void)))
{
  uint64_t result;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;

  if (a3 == _dispatch_call_block_and_release && a2)
    _Block_get_invoke_fn(a2);
  _dispatch_client_callout(a2, (uint64_t (*)(uint64_t))a3);
  result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  v6 = 4 * MEMORY[0xFFFFFC180] + 2;
  v7 = *a1;
  do
  {
    v4 = v7;
    do
      v5 = __ldaxr(a1);
    while (v5 == v7 && __stlxr(v6, a1));
    v7 = v5;
  }
  while (v5 != v4);
  if ((_DWORD)v5 != (result & 0xFFFFFFFC))
    return _dispatch_gate_broadcast_slow((uint64_t)a1, v5);
  return result;
}

void dispatch_assert_queue_V2(dispatch_queue_t queue)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  dispatch_queue_t v8;
  void **v9;
  dispatch_queue_t v10;
  char v11;
  int v12;
  void **v13;
  void *v14;
  _BYTE *v15;
  void **v16;
  void **v17;

  v6 = *(unsigned __int8 *)(*(_QWORD *)queue + 16);
  v5 = 0;
  if (v6 != 17)
    v5 = v6 != 18;
  if (v5)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue()";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x12600);
  }
  v12 = *((_QWORD *)queue + 7);
  if (((v12 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    v10 = queue;
    v9 = 0;
    v8 = 0;
    v13 = (void **)&v8;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v8, 0x15uLL, (pthread_key_t *)&v9, v1, v2, v3, v4);
    while (v8)
    {
      if (v8 == v10)
      {
        v11 = 1;
        goto LABEL_18;
      }
      v17 = (void **)&v8;
      v16 = v9;
      v15 = v8;
      if (v9)
      {
        v14 = 0;
        v14 = (void *)*((_QWORD *)v15 + 3);
        if (v14)
        {
          *v17 = v14;
          if (v15 == *v16)
            v17[1] = v16[1];
        }
        else
        {
          *v17 = *v16;
          v17[1] = v16[1];
        }
      }
      else
      {
        *v17 = (void *)*((_QWORD *)v15 + 3);
      }
    }
    v11 = 0;
LABEL_18:
    if (!v11)
      _dispatch_assert_queue_fail(queue, 1);
  }
}

void _dispatch_assert_queue_fail(_QWORD *a1, char a2)
{
  const char *v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  char *v11;
  char *v12;
  char v13;
  _QWORD *v14;

  v14 = a1;
  v13 = a2 & 1;
  v12 = 0;
  v2 = "";
  if ((a2 & 1) == 0)
    v2 = "not ";
  v10 = (const char *)v14[9];
  if (v10)
    asprintf(&v12, "%sBlock was %sexpected to execute on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v2, v10, v14);
  else
    asprintf(&v12, "%sBlock was %sexpected to execute on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v2, "", v14);
  v11 = v12;
  _dispatch_log("%s", v3, v4, v5, v6, v7, v8, v9, (uint64_t)v12);
  qword_E4D78 = (uint64_t)v11;
  __break(1u);
}

void sub_128EC()
{
  uint64_t v0;

  free(*(void **)(v0 - 24));
  __break(1u);
}

void dispatch_assert_queue_not_V2(dispatch_queue_t queue)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  BOOL v5;
  uint64_t v6;
  dispatch_queue_t v8;
  void **v9;
  dispatch_queue_t v10;
  char v11;
  int v12;
  void **v13;
  void *v14;
  _BYTE *v15;
  void **v16;
  void **v17;

  v6 = *(unsigned __int8 *)(*(_QWORD *)queue + 16);
  v5 = 0;
  if (v6 != 17)
    v5 = v6 != 18;
  if (v5)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: invalid queue passed to dispatch_assert_queue_not()";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x1299CLL);
  }
  v12 = *((_QWORD *)queue + 7);
  if (((v12 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
    _dispatch_assert_queue_fail(queue, 0);
  v10 = queue;
  v9 = 0;
  v8 = 0;
  v13 = (void **)&v8;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v8, 0x15uLL, (pthread_key_t *)&v9, v1, v2, v3, v4);
  while (v8)
  {
    if (v8 == v10)
    {
      v11 = 1;
      goto LABEL_19;
    }
    v17 = (void **)&v8;
    v16 = v9;
    v15 = v8;
    if (v9)
    {
      v14 = 0;
      v14 = (void *)*((_QWORD *)v15 + 3);
      if (v14)
      {
        *v17 = v14;
        if (v15 == *v16)
          v17[1] = v16[1];
      }
      else
      {
        *v17 = *v16;
        v17[1] = v16[1];
      }
    }
    else
    {
      *v17 = (void *)*((_QWORD *)v15 + 3);
    }
  }
  v11 = 0;
LABEL_19:
  if (v11)
    _dispatch_assert_queue_fail(queue, 0);
}

void dispatch_assert_queue_barrier(dispatch_queue_t queue)
{
  dispatch_assert_queue_V2(queue);
  if (*((_WORD *)queue + 40) != 1 && (!*((_QWORD *)queue + 3) || (*((_QWORD *)queue + 7) & 0x40000000000000) == 0))
    _dispatch_assert_queue_barrier_fail(queue);
}

void _dispatch_assert_queue_barrier_fail(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  const char *v8;
  char *v9;
  char *v10;
  const void *v11;

  v11 = a1;
  v10 = 0;
  v8 = (const char *)a1[9];
  if (v8)
    asprintf(&v10, "%sBlock was expected to act as a barrier on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", v8, v11);
  else
    asprintf(&v10, "%sBlock was expected to act as a barrier on queue [%s (%p)]", "BUG IN CLIENT OF LIBDISPATCH: Assertion failed: ", "", v11);
  v9 = v10;
  _dispatch_log("%s", v1, v2, v3, v4, v5, v6, v7, (uint64_t)v10);
  qword_E4D78 = (uint64_t)v9;
  __break(1u);
}

void sub_12D30()
{
  uint64_t v0;

  free(*(void **)(v0 - 16));
  __break(1u);
}

uint64_t dispatch_allow_send_signals(unsigned int a1)
{
  return _pthread_workqueue_allow_send_signals(a1);
}

void _dispatch_set_priority_and_mach_voucher_slow(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  _BYTE *v10;
  uint64_t v11;
  unsigned int v12;
  uint64_t v14;

  v14 = a1;
  v12 = 0;
  if (a1)
  {
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v11 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      if (v14 != v11)
      {
        if ((v11 & 0x1000000) != 0)
        {
          v12 = 16;
          v14 |= (unint64_t)_dispatch_thread_getspecific(0x19uLL) & 0x80000000;
        }
        else
        {
          v14 |= v11 & 0x88000000;
        }
        if ((v11 & 0xFFFFFF) != 0)
          v12 |= 1u;
        v8 = qword_E4178;
        if (((v8 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Changing the QoS while on the manager queue";
          qword_E4DA8 = v14;
          __break(1u);
          JUMPOUT(0x12F68);
        }
        if (((BYTE3(v14) >> 1) & 1) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Cannot raise oneself to manager";
          qword_E4DA8 = v14;
          __break(1u);
          JUMPOUT(0x12FBCLL);
        }
        if ((v11 & 0x2000000) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Cannot turn a manager thread into a normal one";
          qword_E4DA8 = v11;
          __break(1u);
          JUMPOUT(0x1300CLL);
        }
      }
    }
  }
  if (a2 != -1)
    v12 |= 2u;
  v10 = _dispatch_thread_getspecific(0x1DuLL);
  if (v10 && (v10[45] & 2) != 0)
    _dispatch_event_loop_drain(1u);
  if (v12)
  {
    v9 = _pthread_set_properties_self(v12, v14, a2);
    if (v9 == 22)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: _pthread_set_properties_self failed";
      qword_E4DA8 = v14;
      __break(1u);
      JUMPOUT(0x130F4);
    }
    if (v9)
      _dispatch_bug(206, v9, v2, v3, v4, v5, v6, v7);
  }
}

uint64_t _dispatch_set_priority_and_voucher_slow(uint64_t a1, _DWORD *a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v11;
  int v12;
  int v13;
  BOOL v14;
  unsigned int v15;
  uint64_t v16;
  int v20;

  v16 = -1;
  v15 = -1;
  if (a2 != (_DWORD *)-1)
  {
    v14 = (a3 & 4) != 0;
    v16 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
    if ((_DWORD *)v16 == a2 && (a3 & 2) != 0)
    {
      if (v14 && a2)
        os_release(a2);
      v16 = -1;
    }
    else
    {
      if (!v14 && a2)
        os_retain(a2);
      if ((_DWORD *)v16 == a2)
      {
        v20 = -1;
      }
      else
      {
        _dispatch_thread_setspecific(28, (uint64_t)a2);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v3, v4, v5, v6, v7, v8, v9, 400);
        if (a2)
          v13 = a2[8];
        else
          v13 = 0;
        if (v16)
          v12 = *(_DWORD *)(v16 + 32);
        else
          v12 = 0;
        if (v13 == v12)
          v11 = -1;
        else
          v11 = v13;
        v20 = v11;
      }
      v15 = v20;
    }
  }
  if ((a3 & 8) == 0)
    _dispatch_set_priority_and_mach_voucher_slow(a1, v15);
  if (v16 != -1 && (a3 & 2) != 0)
  {
    if (v16)
      os_release((void *)v16);
    return -1;
  }
  return v16;
}

void _dispatch_async_redirect_invoke(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  BOOL v36;
  int v37;
  void *v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  unsigned int v42;
  int v43;
  int v44;
  _QWORD *v45;
  uint64_t v46;
  unsigned int v47;
  void *v48;
  uint64_t i;
  uint64_t v50;
  uint64_t v51;
  int v52;
  _QWORD *v53;
  __int128 v54;
  unsigned int v55;
  uint64_t v56;
  _QWORD *v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _DWORD *v61;
  uint64_t v62;
  _QWORD *v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  unint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *object;
  void *v74;
  unsigned int v75;
  _QWORD *v76;
  _DWORD *v77;
  int v78;
  uint64_t v79;
  uint64_t v80;
  _QWORD *v81;
  uint64_t v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  int v86;
  _DWORD *v87;
  uint64_t v88;
  uint64_t v89;
  void *v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  unint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  _BOOL8 v107;
  unsigned int v108;
  BOOL v109;
  unint64_t v110;
  uint64_t v111;
  unsigned int v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  unint64_t v116;
  unsigned int v117;
  uint64_t v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  uint64_t v122;
  uint64_t v123;
  unsigned int v124;
  uint64_t v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  unsigned int v131;
  unsigned int v132;
  int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  int v140;
  unsigned int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  __int128 *v145;
  uint64_t v146;
  __int128 *v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  __int128 *v152;

  v57 = a1;
  v56 = a2;
  v55 = a3;
  v54 = 0uLL;
  v53 = (_QWORD *)a1[7];
  v52 = a1[5];
  v51 = a1[4];
  v50 = a1[6];
  if (v52)
    v55 = v55 & 0xFCFFFFFF | v52;
  v48 = _dispatch_thread_getspecific(0x14uLL);
  if (v51)
  {
    v127 = v51;
    v126 = _dispatch_thread_getspecific(0x19uLL);
    v129 = *(_QWORD *)(*(_QWORD *)v51 + 16) & 0x10000;
    v128 = 1883;
    if (!v129)
      _dispatch_abort(v128, 0, v3, v4, v5, v6, v7, v8);
    v149 = *(_DWORD *)(v127 + 84);
    v148 = _dispatch_thread_getspecific(0x19uLL);
    v149 = v149 & 0xFFF0FFFF | v148 & 0xF0000;
    _dispatch_thread_setspecific(25, v149);
    v125 = v127;
    v130 = v127;
    _dispatch_thread_setspecific(20, v127);
    v47 = v126;
    v140 = *(_DWORD *)(v50 + 84);
    v139 = _dispatch_thread_getspecific(0x19uLL);
    v138 = v139;
    if (v139)
    {
      if ((v140 & 0xFFF) != 0)
      {
        v138 &= 0x880F0000;
        if ((v139 & 0xFFF) <= (v140 & 0xFFFu))
          v44 = v140 & 0xFFF;
        else
          v44 = v139 & 0xFFF;
        v138 |= v44;
        v142 = v140 & 0xF000;
        v144 = v138 & 0xF00;
        if (v142 >> 12 <= v144 >> 8)
          v140 &= 0x40000000u;
        else
          v140 &= 0x4400F000u;
        v138 |= v140;
      }
      else
      {
        if ((v138 & 0xFFF) != 0)
          v138 |= 0x40000000u;
        v141 = v140 & 0xF000;
        v143 = v138 & 0xF00;
        if (v141 >> 12 > v143 >> 8)
          v138 = v138 & 0xFFFF0FFF | v140 & 0x400F000;
      }
    }
    else
    {
      v138 = v140 & 0xFFF0FFFF;
    }
    _dispatch_thread_setspecific(25, v138);
  }
  else
  {
    v133 = *(_DWORD *)(v50 + 84);
    v132 = _dispatch_thread_getspecific(0x19uLL);
    v131 = v132;
    if (v132)
    {
      if ((v133 & 0xFFF) != 0)
      {
        v131 &= 0x880F0000;
        if ((v132 & 0xFFF) <= (v133 & 0xFFFu))
          v43 = v133 & 0xFFF;
        else
          v43 = v132 & 0xFFF;
        v131 |= v43;
        v135 = v133 & 0xF000;
        v137 = v131 & 0xF00;
        if (v135 >> 12 <= v137 >> 8)
          v133 &= 0x40000000u;
        else
          v133 &= 0x4400F000u;
        v131 |= v133;
      }
      else
      {
        if ((v131 & 0xFFF) != 0)
          v131 |= 0x40000000u;
        v134 = v133 & 0xF000;
        v136 = v131 & 0xF00;
        if (v134 >> 12 > v136 >> 8)
          v131 = v131 & 0xFFFF0FFF | v133 & 0x400F000;
      }
    }
    else
    {
      v131 = v133 & 0xFFF0FFFF;
    }
    _dispatch_thread_setspecific(25, v131);
    v47 = v132;
  }
  v146 = v50;
  v145 = &v54;
  v152 = &v54;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v54, v9, v10, v11, v12, v13);
  _dispatch_thread_setspecific_pair(20, v146, 21, (uint64_t)v145, v14, v15, v16, v17);
  v46 = (uint64_t)v57;
  v63 = v57;
  v62 = 516;
  v61 = 0;
  v61 = (_DWORD *)v57[3];
  v60 = 4;
  v85 = 1;
  v84 = 600;
  v63[3] = -1;
  if (v61 != (_DWORD *)-1)
  {
    v78 = 771817480;
    v77 = v61;
    v76 = v63;
    v75 = 0;
    if (v61)
      v42 = v77[8];
    else
      v42 = 0;
    v75 = v42;
    v83 = v78;
    v82 = v42;
    v81 = v76;
    v80 = 0;
    v79 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v83, v82, v81, v80, v79);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v24, v25, v26, v27, v28, v29, v30, 607);
  }
  v67 = v63[1];
  v66 = (uint64_t)v61;
  v65 = v60 | 2;
  v64 = 0;
  if (v67 != -1)
  {
    v114 = v67;
    v113 = v65;
    v112 = 0;
    v112 = _dispatch_thread_getspecific(0x19uLL);
    v111 = 0;
    v120 = v112;
    v121 = v112 & 0xF00;
    v119 = v121 >> 8;
    v118 = v112;
    if (v121 >> 8)
      v118 |= 1 << (v119 + 7);
    v111 = v118;
    v122 = v118;
    v110 = v118 & 0xFFFFFF00;
    v109 = 0;
    v41 = 1;
    if ((v113 & 1) == 0)
      v41 = (v114 & 0x10000000) != 0;
    v109 = v41;
    v116 = v114;
    v114 &= 0xFFFFFFu;
    if (v114)
    {
      if (v114 >= v110)
      {
        if (v109 || (v112 & 0x44000000) != 0)
          v115 = v114;
        else
          v115 = v111;
      }
      else
      {
        v115 = v111;
      }
    }
    else
    {
      v117 = v112 & 0xF000;
      v108 = v117 >> 12;
      if (v117 >> 12)
      {
        v124 = v108;
        v123 = 1 << (v108 + 7);
        v40 = v123 | 0xFF;
      }
      else
      {
        v40 = v111;
      }
      v115 = v40;
    }
    v64 = v115;
  }
  v71 = v64;
  v70 = v66;
  v69 = v65;
  v94 = v64;
  v107 = v64 != -1;
  v106 = 2332;
  if (v64 == -1)
    _dispatch_abort(v106, v107, v18, v19, v20, v21, v22, v23);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v105 = v94;
    v104 = 4261412863;
    v103 = 0;
    v94 &= 0xFFFFFFFF02FFFFFFLL;
    v93 = 0;
    v96 = 0;
    v96 = _dispatch_thread_getspecific(4uLL);
    v93 = (unint64_t)v96;
    v92 = 0x1000000;
    v91 = 2281701376;
    if ((v96 & 0x1000000) != 0)
    {
      if (v94)
      {
        v39 = v94;
      }
      else
      {
        v102 = v93;
        v101 = v92;
        v100 = 0;
        v39 = v93 & (~v92 | 0xFFFFFF);
      }
      v95 = v39;
    }
    else
    {
      v99 = v93;
      v98 = v91;
      v97 = 0;
      v93 &= ~v91 | 0xFFFFFF;
      if (v94 == v93)
        v95 = 0;
      else
        v95 = v94;
    }
  }
  else
  {
    v95 = 0;
  }
  v71 = v95;
  if (v95)
    goto LABEL_88;
  if (v70 == -1)
  {
    v72 = -1;
    goto LABEL_89;
  }
  v38 = (void *)v70;
  if (v38 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_88:
    v72 = _dispatch_set_priority_and_voucher_slow(v71, (_DWORD *)v70, v69);
  }
  else
  {
    v68 = (v69 & 4) != 0;
    if ((v69 & 2) != 0)
    {
      if (v68 && v70)
      {
        object = (void *)v70;
        os_release((void *)v70);
      }
      v70 = -1;
    }
    else if (!v68 && v70)
    {
      v74 = (void *)v70;
      os_retain((void *)v70);
    }
    v72 = v70;
  }
LABEL_89:
  v88 = v46;
  v87 = 0;
  v87 = _dispatch_thread_getspecific(0x16uLL);
  v86 = 0;
  if (v87)
    v37 = v87[2] + 1;
  else
    v37 = 1;
  v86 = v37;
  if (v37 <= _dispatch_continuation_cache_limit)
  {
    *(_QWORD *)(v88 + 16) = v87;
    *(_DWORD *)(v88 + 8) = v86;
    _dispatch_thread_setspecific(22, v88);
    v89 = 0;
  }
  else
  {
    v89 = v88;
  }
  v45 = (_QWORD *)v89;
  _dispatch_continuation_pop(v53, v56, v55, v50);
  if (v45)
    _dispatch_continuation_free_to_cache_limit(v45);
  v147 = &v54;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v54, v31, v32, v33, v34, v35);
  if (v51)
  {
    v90 = v48;
    _dispatch_thread_setspecific(20, (uint64_t)v48);
  }
  v151 = v47;
  v150 = 0;
  v150 = _dispatch_thread_getspecific(0x19uLL);
  v151 &= 0xFFF0FFFF;
  v151 |= v150 & 0xF0000;
  _dispatch_thread_setspecific(25, v151);
  for (i = *(_QWORD *)(v50 + 24); ; i = *(_QWORD *)(i + 24))
  {
    v36 = 0;
    if (*(_QWORD *)(i + 24))
      v36 = i != (_QWORD)v48;
    if (!v36)
      break;
    v58 = i;
    v59 = i;
    _dispatch_lane_non_barrier_complete(i, 0);
  }
  _dispatch_lane_non_barrier_complete(v50, 1u);
}

_QWORD *_dispatch_workloop_stealer_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  _QWORD *result;
  int v16;
  unint64_t v17;
  uint64_t v18;
  unsigned int v19;
  int v21;
  _DWORD *v24;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v28;
  _QWORD *v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  int v33;
  unsigned int v34;
  uint64_t v35;
  unint64_t v36;
  int v37;

  v21 = a3;
  v24 = *(_DWORD **)(a1 + 24);
  *(_QWORD *)(a1 + 24) = -1;
  if (v24 != (_DWORD *)-1)
  {
    if (v24)
      v19 = v24[8];
    else
      v19 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817480, v19, a1, 0, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v8, v9, v10, v11, v12, v13, v14, 607);
  }
  v27 = *(_QWORD *)(a1 + 8);
  v26 = 0;
  if (v27 != -1)
  {
    v34 = _dispatch_thread_getspecific(0x19uLL);
    v37 = (unsigned __int16)(v34 & 0xF00) >> 8;
    v36 = v34;
    if (v37)
      v36 = v34 | (unint64_t)(1 << (v37 + 7));
    if ((v27 & 0xFFFFFF) != 0)
    {
      if ((v27 & 0xFFFFFFuLL) >= (v36 & 0xFFFFFF00))
      {
        if ((v27 & 0x10000000) != 0 || (v34 & 0x44000000) != 0)
          v35 = v27 & 0xFFFFFF;
        else
          v35 = v36;
      }
      else
      {
        v35 = v36;
      }
    }
    else
    {
      v33 = (unsigned __int16)(v34 & 0xF000) >> 12;
      if (v33)
        v18 = (1 << (v33 + 7)) | 0xFF;
      else
        v18 = v36;
      v35 = v18;
    }
    v26 = v35;
  }
  if (v26 == -1)
    _dispatch_abort(2332, 0, a3, a4, a5, a6, a7, a8);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v31 = v26 & 0xFFFFFFFF02FFFFFFLL;
    v30 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v30 & 0x1000000) != 0)
    {
      if (v31)
        v17 = v26 & 0xFFFFFFFF02FFFFFFLL;
      else
        v17 = v30 & 0xFFFFFFFFFEFFFFFFLL;
      v32 = v17;
    }
    else if (v31 == (v30 & 0xFFFFFFFF77FFFFFFLL))
    {
      v32 = 0;
    }
    else
    {
      v32 = v26 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v32 = 0;
  }
  if (v32)
    goto LABEL_41;
  if (v24 == (_DWORD *)-1)
    goto LABEL_42;
  if (v24 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_41:
    _dispatch_set_priority_and_voucher_slow(v32, v24, 6);
  }
  else if (v24)
  {
    os_release(v24);
  }
LABEL_42:
  v28 = _dispatch_thread_getspecific(0x16uLL);
  if (v28)
    v16 = v28[2] + 1;
  else
    v16 = 1;
  if (v16 <= _dispatch_continuation_cache_limit)
  {
    *(_QWORD *)(a1 + 16) = v28;
    *(_DWORD *)(a1 + 8) = v16;
    _dispatch_thread_setspecific(22, a1);
    v29 = 0;
  }
  else
  {
    v29 = (_QWORD *)a1;
  }
  result = (_QWORD *)(*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 48) + 48))(*(_QWORD *)(a1 + 48), a2, v21 | 1u);
  if (v29)
    return _dispatch_continuation_free_to_cache_limit(v29);
  return result;
}

uint64_t _dispatch_queue_override_invoke(_QWORD *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  int v37;
  unint64_t v38;
  uint64_t v39;
  unsigned int v40;
  int v41;
  unint64_t v42;
  uint64_t v43;
  unsigned int v44;
  __int16 v45;
  _QWORD *v46;
  void *v47;
  _DWORD *v51;
  unint64_t v52;
  uint64_t v53;
  _DWORD *v54;
  _QWORD *v55;
  uint64_t v56;
  uint64_t v57;
  _QWORD *v58;
  void (*v59)(void (**)(void));
  uint64_t v60;
  uint64_t v61;
  _DWORD *v62;
  unint64_t v63;
  uint64_t v64;
  _DWORD *v65;
  _QWORD *v66;
  dispatch_group_s *group;
  void (*v68)(void (**)(void));
  uint64_t v69;
  unint64_t v70;
  unint64_t v71;
  unint64_t v72;
  unint64_t v73;
  unint64_t v74;
  unint64_t v75;
  int v76;
  unsigned int v77;
  unint64_t v78;
  int v79;
  unsigned int v80;
  unint64_t v81;
  unint64_t v82;
  int v83;
  unint64_t v84;
  int v85;
  unsigned int v86;
  _DWORD *v87;
  int v88;
  unsigned int v89;
  unsigned int v90;

  v47 = _dispatch_thread_getspecific(0x14uLL);
  v45 = 4;
  v46 = (_QWORD *)a1[6];
  v87 = (_DWORD *)a1[7];
  v86 = _dispatch_thread_getspecific(0x19uLL);
  if ((*(_QWORD *)(*(_QWORD *)v87 + 16) & 0x10000) == 0)
    _dispatch_abort(1883, 0, v3, v4, v5, v6, v7, v8);
  v88 = v87[21];
  v89 = v88 & 0xFFF0FFFF | _dispatch_thread_getspecific(0x19uLL) & 0xF0000;
  _dispatch_thread_setspecific(25, v89);
  _dispatch_thread_setspecific(20, (uint64_t)v87);
  if (*(_QWORD *)(*a1 + 16) == 1792)
  {
    a3 |= 1u;
    v45 = 516;
  }
  v51 = (_DWORD *)a1[3];
  a1[3] = -1;
  if (v51 != (_DWORD *)-1)
  {
    if (v51)
      v44 = v51[8];
    else
      v44 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817480, v44, a1, 0, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v15, v16, v17, v18, v19, v20, v21, 607);
  }
  v53 = a1[1];
  v52 = 0;
  if (v53 != -1)
  {
    v80 = _dispatch_thread_getspecific(0x19uLL);
    v83 = (unsigned __int16)(v80 & 0xF00) >> 8;
    v82 = v80;
    if (v83)
      v82 = v80 | (unint64_t)(1 << (v83 + 7));
    if ((v53 & 0xFFFFFF) != 0)
    {
      if ((v53 & 0xFFFFFF) >= (unint64_t)(v82 & 0xFFFFFF00))
      {
        if ((v53 & 0x10000000) != 0 || (v80 & 0x44000000) != 0)
          v81 = v53 & 0xFFFFFF;
        else
          v81 = v82;
      }
      else
      {
        v81 = v82;
      }
    }
    else
    {
      v79 = (unsigned __int16)(v80 & 0xF000) >> 12;
      if (v79)
        v43 = (1 << (v79 + 7)) | 0xFF;
      else
        v43 = v82;
      v81 = v43;
    }
    v52 = v81;
  }
  if (v52 == -1)
    _dispatch_abort(2332, 0, v9, v10, v11, v12, v13, v14);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v74 = v52 & 0xFFFFFFFF02FFFFFFLL;
    v73 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v73 & 0x1000000) != 0)
    {
      if (v74)
        v42 = v52 & 0xFFFFFFFF02FFFFFFLL;
      else
        v42 = v73 & 0xFFFFFFFFFEFFFFFFLL;
      v75 = v42;
    }
    else if (v74 == (v73 & 0xFFFFFFFF77FFFFFFLL))
    {
      v75 = 0;
    }
    else
    {
      v75 = v52 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v75 = 0;
  }
  if (v75)
    goto LABEL_45;
  if (v51 == (_DWORD *)-1)
    goto LABEL_46;
  if (v51 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_45:
    _dispatch_set_priority_and_voucher_slow(v75, v51, v45 & 4 | 2);
  }
  else if (v51)
  {
    os_release(v51);
  }
LABEL_46:
  v54 = _dispatch_thread_getspecific(0x16uLL);
  if (v54)
    v41 = v54[2] + 1;
  else
    v41 = 1;
  if (v41 <= _dispatch_continuation_cache_limit)
  {
    a1[2] = v54;
    *((_DWORD *)a1 + 2) = v41;
    _dispatch_thread_setspecific(22, (uint64_t)a1);
    v55 = 0;
  }
  else
  {
    v55 = a1;
  }
  if (*v46 >= 0x1000uLL)
  {
    if (*(_QWORD *)(*v46 + 16) == 1)
      (*(void (**)(_QWORD *, _QWORD, _QWORD))(*v46 + 24))(v46, 0, (a3 >> 21) & 1);
    else
      (*(void (**)(_QWORD *, uint64_t, _QWORD))(*v46 + 48))(v46, a2, a3);
    goto LABEL_129;
  }
  v57 = 0;
  if ((a3 & 0x1000000) != 0)
    v57 = _dispatch_autorelease_pool_push();
  v56 = *v46;
  v62 = (_DWORD *)v46[3];
  v61 = *v46 & 4;
  if (v61)
    v46[3] = -1;
  if (v62 != (_DWORD *)-1)
  {
    if (v62)
      v40 = v62[8];
    else
      v40 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817480, v40, v46, 0, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v28, v29, v30, v31, v32, v33, v34, 607);
  }
  v64 = v46[1];
  v63 = 0;
  if (v64 != -1)
  {
    v77 = _dispatch_thread_getspecific(0x19uLL);
    v85 = (unsigned __int16)(v77 & 0xF00) >> 8;
    v84 = v77;
    if (v85)
      v84 = v77 | (unint64_t)(1 << (v85 + 7));
    if ((v64 & 0xFFFFFF) != 0)
    {
      if ((v64 & 0xFFFFFF) >= (unint64_t)(v84 & 0xFFFFFF00))
      {
        if ((v64 & 0x10000000) != 0 || (v77 & 0x44000000) != 0)
          v78 = v64 & 0xFFFFFF;
        else
          v78 = v84;
      }
      else
      {
        v78 = v84;
      }
    }
    else
    {
      v76 = (unsigned __int16)(v77 & 0xF000) >> 12;
      if (v76)
        v39 = (1 << (v76 + 7)) | 0xFF;
      else
        v39 = v84;
      v78 = v39;
    }
    v63 = v78;
  }
  if (v63 == -1)
    _dispatch_abort(2332, 0, v22, v23, v24, v25, v26, v27);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v71 = v63 & 0xFFFFFFFF02FFFFFFLL;
    v70 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v70 & 0x1000000) != 0)
    {
      if (v71)
        v38 = v63 & 0xFFFFFFFF02FFFFFFLL;
      else
        v38 = v70 & 0xFFFFFFFFFEFFFFFFLL;
      v72 = v38;
    }
    else if (v71 == (v70 & 0xFFFFFFFF77FFFFFFLL))
    {
      v72 = 0;
    }
    else
    {
      v72 = v63 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v72 = 0;
  }
  if (v72)
  {
LABEL_101:
    _dispatch_set_priority_and_voucher_slow(v72, v62, v61 | 2);
    goto LABEL_102;
  }
  if (v62 != (_DWORD *)-1)
  {
    if (v62 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v61 & 4) != 0 && v62)
        os_release(v62);
      goto LABEL_102;
    }
    goto LABEL_101;
  }
LABEL_102:
  if ((v56 & 4) != 0)
  {
    v65 = _dispatch_thread_getspecific(0x16uLL);
    if (v65)
      v37 = v65[2] + 1;
    else
      v37 = 1;
    if (v37 <= _dispatch_continuation_cache_limit)
    {
      v46[2] = v65;
      *((_DWORD *)v46 + 2) = v37;
      _dispatch_thread_setspecific(22, (uint64_t)v46);
      v66 = 0;
    }
    else
    {
      v66 = v46;
    }
    v58 = v66;
  }
  else
  {
    v58 = 0;
  }
  if ((v56 & 8) != 0)
  {
    group = (dispatch_group_s *)v46[6];
    if (*(_QWORD *)(*(_QWORD *)group + 16) != 514)
    {
      v35 = *(_QWORD *)(*(_QWORD *)group + 16);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_E4DA8 = v35;
      __break(1u);
      JUMPOUT(0x16E8CLL);
    }
    v69 = v46[5];
    v68 = (void (*)(void (**)(void)))v46[4];
    if (v68 == _dispatch_call_block_and_release && v69)
      _Block_get_invoke_fn(v69);
    _dispatch_client_callout(v69, (uint64_t (*)(uint64_t))v68);
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(772079660, v46, 0, 0, 0);
    dispatch_group_leave(group);
  }
  else
  {
    v60 = v46[5];
    v59 = (void (*)(void (**)(void)))v46[4];
    if (v59 == _dispatch_call_block_and_release && v60)
      _Block_get_invoke_fn(v60);
    _dispatch_client_callout(v60, (uint64_t (*)(uint64_t))v59);
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(772079660, v46, 0, 0, 0);
  }
  if (v58)
    _dispatch_continuation_free_to_cache_limit(v58);
  if (v57)
    _dispatch_autorelease_pool_pop(v57);
LABEL_129:
  if ((v45 & 0x200) == 0 && MEMORY[0xFFFFFC100])
    kdebug_trace(772079660, a1, 0, 0, 0);
  if (v55)
    _dispatch_continuation_free_to_cache_limit(v55);
  v90 = _dispatch_thread_getspecific(0x19uLL);
  _dispatch_thread_setspecific(25, v86 & 0xFFF0FFFF | v90 & 0xF0000);
  return _dispatch_thread_setspecific(20, (uint64_t)v47);
}

_QWORD *_dispatch_continuation_free_to_cache_limit(_QWORD *a1)
{
  _QWORD *result;
  BOOL v2;
  int v3;
  uint64_t v4;
  _QWORD *v5;

  _dispatch_continuation_free_to_heap(a1);
  result = _dispatch_thread_getspecific(0x16uLL);
  v5 = result;
  if (result)
  {
    v3 = *((_DWORD *)result + 2) - _dispatch_continuation_cache_limit;
    if (v3 > 0)
    {
      do
      {
        v4 = v5[2];
        _dispatch_continuation_free_to_heap(v5);
        --v3;
        v2 = 0;
        if (v3)
        {
          v5 = (_QWORD *)v4;
          v2 = v4 != 0;
        }
      }
      while (v2);
      return (_QWORD *)_dispatch_thread_setspecific(22, v4);
    }
  }
  return result;
}

void _dispatch_continuation_pop(_QWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  _dispatch_continuation_pop_inline(a1, a2, a3, a4);
}

void _dispatch_continuation_pop_inline(_QWORD *a1, uint64_t a2, int a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  int v19;
  unint64_t v20;
  uint64_t v21;
  unsigned int v22;
  void (**v23)(uint64_t);
  unsigned int v24;
  unsigned __int16 v25;
  uint64_t v29;
  uint64_t v30;
  _QWORD *v31;
  void (*v32)(void (**)(void));
  uint64_t v33;
  uint64_t v34;
  _DWORD *v35;
  uint64_t v36;
  uint64_t v37;
  _DWORD *v38;
  _QWORD *v39;
  dispatch_group_s *group;
  void (*v41)(void (**)(void));
  uint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  int v46;
  uint64_t v47;
  unint64_t v48;
  int v49;

  v25 = HIWORD(a3);
  v23 = (void (**)(uint64_t))_dispatch_thread_getspecific(0x18uLL);
  if (v23)
    (*v23)(a4);
  v24 = v25 << 16;
  if (*a1 >= 0x1000uLL)
  {
    if (*(_QWORD *)(*a1 + 16) == 1)
      (*(void (**)(_QWORD *, _QWORD, _QWORD))(*a1 + 24))(a1, 0, (v24 >> 21) & 1);
    else
      (*(void (**)(_QWORD *, uint64_t, _QWORD))(*a1 + 48))(a1, a2, v24);
    goto LABEL_80;
  }
  v30 = 0;
  if ((v24 & 0x1000000) != 0)
    v30 = _dispatch_autorelease_pool_push();
  v29 = *a1;
  v35 = (_DWORD *)a1[3];
  v34 = *a1 & 4;
  if (v34)
    a1[3] = -1;
  if (v35 != (_DWORD *)-1)
  {
    if (v35)
      v22 = v35[8];
    else
      v22 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817480, v22, a1, 0, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v10, v11, v12, v13, v14, v15, v16, 607);
  }
  v37 = a1[1];
  v36 = 0;
  if (v37 != -1)
  {
    v17 = _dispatch_thread_getspecific(0x19uLL);
    v49 = (unsigned __int16)(v17 & 0xF00) >> 8;
    v48 = v17;
    if (v49)
      v48 = v17 | (unint64_t)(1 << (v49 + 7));
    if ((v37 & 0xFFFFFF) != 0)
    {
      if ((v37 & 0xFFFFFFuLL) >= (v48 & 0xFFFFFF00))
      {
        if ((v37 & 0x10000000) != 0 || (v17 & 0x44000000) != 0)
          v47 = v37 & 0xFFFFFF;
        else
          v47 = v48;
      }
      else
      {
        v47 = v48;
      }
    }
    else
    {
      v46 = (unsigned __int16)(v17 & 0xF000) >> 12;
      if (v46)
        v21 = (1 << (v46 + 7)) | 0xFF;
      else
        v21 = v48;
      v47 = v21;
    }
    v36 = v47;
  }
  if (v36 == -1)
    _dispatch_abort(2332, 0, v4, v5, v6, v7, v8, v9);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v44 = v36 & 0xFFFFFFFF02FFFFFFLL;
    v43 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v43 & 0x1000000) != 0)
    {
      if (v44)
        v20 = v36 & 0xFFFFFFFF02FFFFFFLL;
      else
        v20 = v43 & 0xFFFFFFFFFEFFFFFFLL;
      v45 = v20;
    }
    else if (v44 == (v43 & 0xFFFFFFFF77FFFFFFLL))
    {
      v45 = 0;
    }
    else
    {
      v45 = v36 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v45 = 0;
  }
  if (v45)
  {
LABEL_52:
    _dispatch_set_priority_and_voucher_slow(v45, v35, v34 | 2);
    goto LABEL_53;
  }
  if (v35 != (_DWORD *)-1)
  {
    if (v35 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if ((v34 & 4) != 0 && v35)
        os_release(v35);
      goto LABEL_53;
    }
    goto LABEL_52;
  }
LABEL_53:
  if ((v29 & 4) != 0)
  {
    v38 = _dispatch_thread_getspecific(0x16uLL);
    if (v38)
      v19 = v38[2] + 1;
    else
      v19 = 1;
    if (v19 <= _dispatch_continuation_cache_limit)
    {
      a1[2] = v38;
      *((_DWORD *)a1 + 2) = v19;
      _dispatch_thread_setspecific(22, (uint64_t)a1);
      v39 = 0;
    }
    else
    {
      v39 = a1;
    }
    v31 = v39;
  }
  else
  {
    v31 = 0;
  }
  if ((v29 & 8) != 0)
  {
    group = (dispatch_group_s *)a1[6];
    if (*(_QWORD *)(*(_QWORD *)group + 16) != 514)
    {
      v18 = *(_QWORD *)(*(_QWORD *)group + 16);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected object type";
      qword_E4DA8 = v18;
      __break(1u);
      JUMPOUT(0x181E0);
    }
    v42 = a1[5];
    v41 = (void (*)(void (**)(void)))a1[4];
    if (v41 == _dispatch_call_block_and_release && v42)
      _Block_get_invoke_fn(v42);
    _dispatch_client_callout(v42, (uint64_t (*)(uint64_t))v41);
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(772079660, a1, 0, 0, 0);
    dispatch_group_leave(group);
  }
  else
  {
    v33 = a1[5];
    v32 = (void (*)(void (**)(void)))a1[4];
    if (v32 == _dispatch_call_block_and_release && v33)
      _Block_get_invoke_fn(v33);
    _dispatch_client_callout(v33, (uint64_t (*)(uint64_t))v32);
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(772079660, a1, 0, 0, 0);
  }
  if (v31)
    _dispatch_continuation_free_to_cache_limit(v31);
  if (v30)
    _dispatch_autorelease_pool_pop(v30);
LABEL_80:
  if (v23)
    v23[1](a4);
}

dispatch_block_t dispatch_block_create(dispatch_block_flags_t flags, dispatch_block_t block)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if ((flags & 0xFFFFFF00) != 0)
    return 0;
  else
    return _dispatch_block_create_with_voucher_and_priority(flags, 0, 0, block, v2, v3, v4, v5);
}

_QWORD *_dispatch_block_create_with_voucher_and_priority(uint64_t a1, uint64_t a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v18;
  uint64_t v22;
  uint64_t v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  unint64_t v28;
  uint64_t v29;

  v22 = a3;
  v25 = a1;
  if ((a1 & 0xA) != 0)
    v25 = a1 | 0x40000000;
  if ((v25 & 0x20) != 0)
    v25 &= ~0x10uLL;
  v24 = v25;
  if ((v25 & 0x80000000) == 0)
  {
    if ((v25 & 2) != 0)
    {
      a2 = 0;
      v24 = v25 | 0x80000000;
    }
    else if ((v25 & 0x40) != 0)
    {
      a2 = -1;
      v24 = v25 | 0x80000000;
    }
    else if ((v25 & 4) != 0)
    {
      a2 = -3;
      v24 = v25 | 0x80000000;
    }
  }
  if (a2 == -3)
    a2 = (uint64_t)_dispatch_thread_getspecific(0x1CuLL);
  if ((v25 & 4) != 0 && (v24 & 0x40000000) == 0)
  {
    v28 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v28 <= 0x10FF)
      v29 = v28;
    else
      v29 = 4351;
    v22 = v29;
    v24 |= 0x40000000uLL;
  }
  v18 = _dispatch_block_create((void *)v24, (void *)a2, v22, a4, a5, a6, a7, a8);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)v18) == ___dispatch_block_create_block_invoke)
  {
    if (v18[4] != 3512316172)
    {
      v14 = v18[4];
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v14;
      __break(1u);
      JUMPOUT(0x18860);
    }
    v26 = (char *)(v18 + 4);
  }
  else
  {
    v26 = 0;
  }
  if (!v26)
    _dispatch_abort(405, 0, v8, v9, v10, v11, v12, v13);
  v17 = _Block_get_invoke_fn((uint64_t)a4);
  if ((a1 & 0x40000000) != 0)
    v16 = a3;
  else
    v16 = 0xFFFFFFFFLL;
  v27 = v22 | ((_QWORD)_dispatch_thread_getspecific(4uLL) << 32);
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(772079628, v18, v17, v16 | (a1 << 32), v27);
  return v18;
}

dispatch_block_t dispatch_block_create_with_qos_class(dispatch_block_flags_t flags, dispatch_qos_class_t qos_class, int relative_priority, dispatch_block_t block)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;
  BOOL v14;

  if ((flags & 0xFFFFFF00) != 0)
    return 0;
  if (qos_class == QOS_CLASS_UNSPECIFIED
    || qos_class == 5
    || qos_class == QOS_CLASS_BACKGROUND
    || qos_class == QOS_CLASS_UTILITY
    || qos_class == QOS_CLASS_DEFAULT
    || qos_class == QOS_CLASS_USER_INITIATED
    || qos_class == QOS_CLASS_USER_INTERACTIVE)
  {
    v10 = 0;
    if (relative_priority >= -15)
      v10 = relative_priority <= 0;
    v14 = v10;
  }
  else
  {
    v14 = 0;
  }
  if (!v14)
    return 0;
  v4 = _pthread_qos_class_encode(qos_class, relative_priority, 0);
  return _dispatch_block_create_with_voucher_and_priority(flags | 0x40000000, 0, v4, block, v5, v6, v7, v8);
}

_QWORD *dispatch_block_create_with_voucher(uint64_t a1, uint64_t a2, const void *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a1 & 0xFFFFFF00) != 0)
    return 0;
  else
    return _dispatch_block_create_with_voucher_and_priority(a1 & 0xFFFFFFFF7FFFFFBFLL | 0x80000000, a2, 0, a3, a5, a6, a7, a8);
}

_QWORD *dispatch_block_create_with_voucher_and_qos_class(uint64_t a1, uint64_t a2, unsigned int a3, int a4, const void *a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  BOOL v11;
  BOOL v16;

  if ((a1 & 0xFFFFFF00) != 0)
    return 0;
  if (!a3 || a3 == 5 || a3 == 9 || a3 == 17 || a3 == 21 || a3 == 25 || a3 == 33)
  {
    v11 = 0;
    if (a4 >= -15)
      v11 = a4 <= 0;
    v16 = v11;
  }
  else
  {
    v16 = 0;
  }
  if (!v16)
    return 0;
  v5 = _pthread_qos_class_encode(a3, a4, 0);
  return _dispatch_block_create_with_voucher_and_priority(a1 & 0xFFFFFFFF3FFFFFB7 | 0xC0000000, a2, v5, a5, v6, v7, v8, v9);
}

void dispatch_block_perform(dispatch_block_flags_t flags, dispatch_block_t block)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _OWORD v8[2];
  uint64_t v9;
  dispatch_block_t v10;
  __int128 v11;
  uint64_t v12;
  uint64_t v13;
  dispatch_block_t v14;
  dispatch_block_flags_t v15;
  dispatch_block_flags_t v16;
  dispatch_block_flags_t v17;

  v15 = flags;
  v14 = block;
  v16 = flags;
  if ((flags & 0xFFFFFF00) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid flags passed to dispatch_block_perform()";
    qword_E4DA8 = v15;
    __break(1u);
    JUMPOUT(0x18DF0);
  }
  v17 = v15;
  if ((v15 & 0xA) != 0)
    v17 |= 0x40000000uLL;
  if ((v17 & 0x20) != 0)
    v17 &= ~0x10uLL;
  v15 = v17;
  v13 = -1;
  if ((v17 & 2) != 0)
  {
    v13 = 0;
    v15 |= 0x80000000uLL;
  }
  v12 = 0;
  v8[0] = 0xD159B10CuLL;
  *((_QWORD *)&v8[0] + 1) = v15;
  v8[1] = 8uLL;
  v9 = v13;
  v10 = v14;
  v11 = 0uLL;
  _dispatch_block_invoke_direct((uint64_t)v8, (uint64_t)block, v2, v3, v4, v5, v6, v7);
}

void _dispatch_block_invoke_direct(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v20;
  unint64_t v21;
  void *v22;
  uint64_t v23;
  void (*v24)(void (**)(void));
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;

  v18 = *(_QWORD *)(a1 + 8);
  v17 = *(_DWORD *)(a1 + 16);
  if (((v17 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v17;
    __break(1u);
    JUMPOUT(0x18F84);
  }
  if ((v17 & 1) != 0)
    goto LABEL_54;
  v16 = 0;
  v20 = 0;
  if ((v18 & 0x40000000) != 0 && ((v18 & 0x20) != 0 || (v18 & 0x10) == 0))
  {
    v21 = *(_QWORD *)(a1 + 24) & 0xFFFFFFLL;
    v22 = _dispatch_thread_getspecific(4uLL);
    if ((v22 & 0xFFFFFF) != 0 && (v22 & 0xFFFFFF) < v21)
      v20 = v22 & 0xFFFFFF;
  }
  if (v20)
    v16 = *(_QWORD *)(a1 + 24);
  v15 = -1;
  if ((v18 & 0x80000000) != 0)
    v15 = *(_QWORD *)(a1 + 32);
  if (v16 == -1)
    _dispatch_abort(2332, 0, a3, a4, a5, a6, a7, a8);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v28 = v16 & 0xFFFFFFFF02FFFFFFLL;
    v8 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v8 & 0x1000000) != 0)
    {
      if (v28)
        v14 = v16 & 0xFFFFFFFF02FFFFFFLL;
      else
        v14 = v8 & 0xFFFFFFFFFEFFFFFFLL;
      v29 = v14;
    }
    else if (v28 == (v8 & 0xFFFFFFFF77FFFFFFLL))
    {
      v29 = 0;
    }
    else
    {
      v29 = v16 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v29 = 0;
  }
  if (!v29)
  {
    if (v15 == -1)
    {
      v23 = -1;
      goto LABEL_34;
    }
    if ((void *)v15 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if (v15)
        os_retain((void *)v15);
      v23 = v15;
      goto LABEL_34;
    }
  }
  v23 = _dispatch_set_priority_and_voucher_slow(v29, v15, 0);
LABEL_34:
  *(_DWORD *)(a1 + 64) = _dispatch_thread_getspecific(3uLL);
  v25 = *(_QWORD *)(a1 + 40);
  v24 = (void (*)(void (**)(void)))_Block_get_invoke_fn(v25);
  if (v24 == _dispatch_call_block_and_release && v25)
    _Block_get_invoke_fn(v25);
  _dispatch_client_callout(v25, (uint64_t (*)(uint64_t))v24);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v26 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v26 & 0x1000000) != 0)
    {
      if ((v20 & 0x2FFFFFF) != 0)
        v13 = v20 & 0x2FFFFFF;
      else
        v13 = v26 & 0xFFFFFFFFFEFFFFFFLL;
      v27 = v13;
    }
    else if ((v20 & 0x2FFFFFF) == (v26 & 0xFFFFFFFF77FFFFFFLL))
    {
      v27 = 0;
    }
    else
    {
      v27 = v20 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v27 = 0;
  }
  if (v27)
    goto LABEL_53;
  if (v23 == -1)
    goto LABEL_54;
  if ((void *)v23 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_53:
    _dispatch_set_priority_and_voucher_slow(v27, v23, 6);
  }
  else if (v23)
  {
    os_release((void *)v23);
  }
LABEL_54:
  if ((v17 & 8) == 0)
  {
    v11 = (unsigned int *)(a1 + 20);
    v12 = *(_DWORD *)(a1 + 20);
    do
    {
      v9 = v12;
      do
        v10 = __ldaxr(v11);
      while (v10 == v12 && __stlxr(v12 + 1, v11));
      v12 = v10;
    }
    while (v10 != v9);
    if (!v10)
      dispatch_group_leave(*(dispatch_group_t *)(a1 + 48));
  }
}

void _dispatch_block_sync_invoke(uint64_t a1)
{
  uint64_t v1;
  unsigned __int16 v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int *v11;
  unsigned int *v12;
  unint64_t *v13;
  unsigned int *v14;
  unsigned int *v15;
  unsigned int v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v22;
  _DWORD *v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  int v30;
  unint64_t v31;
  int v32;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a1) == ___dispatch_block_create_block_invoke)
  {
    if (*(_QWORD *)(a1 + 32) != 3512316172)
    {
      v1 = *(_QWORD *)(a1 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x19A40);
    }
    v22 = a1 + 32;
  }
  else
  {
    v22 = 0;
  }
  v20 = *(_DWORD *)(v22 + 16);
  if (((v20 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v20;
    __break(1u);
    JUMPOUT(0x19ACCLL);
  }
  if ((v20 & 1) != 0)
    goto LABEL_48;
  v19 = -1;
  if ((*(_QWORD *)(v22 + 8) & 0x80000000) != 0)
  {
    v23 = *(_DWORD **)(v22 + 32);
    v2 = (unsigned __int16)_dispatch_thread_getspecific(0x19uLL);
    v32 = (unsigned __int16)(v2 & 0xF00) >> 8;
    v31 = v2;
    if (v32)
      v31 = v2 | (unint64_t)(1 << (v32 + 7));
    v30 = (unsigned __int16)(v2 & 0xF000) >> 12;
    if (v30)
      v18 = (1 << (v30 + 7)) | 0xFF;
    else
      v18 = v31;
    if (v18 == -1)
      _dispatch_abort(2332, 0, v3, v4, v5, v6, v7, v8);
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v28 = v18 & 0xFFFFFFFF02FFFFFFLL;
      v27 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v27 & 0x1000000) != 0)
      {
        if (v28)
          v17 = v18 & 0xFFFFFFFF02FFFFFFLL;
        else
          v17 = v27 & 0xFFFFFFFFFEFFFFFFLL;
        v29 = v17;
      }
      else if (v28 == (v27 & 0xFFFFFFFF77FFFFFFLL))
      {
        v29 = 0;
      }
      else
      {
        v29 = v18 & 0xFFFFFFFF02FFFFFFLL;
      }
    }
    else
    {
      v29 = 0;
    }
    if (!v29)
    {
      if (v23 == (_DWORD *)-1)
      {
        v24 = -1;
LABEL_35:
        v19 = v24;
        goto LABEL_36;
      }
      if (v23 == _dispatch_thread_getspecific(0x1CuLL))
      {
        if (v23)
          os_retain(v23);
        v24 = (uint64_t)v23;
        goto LABEL_35;
      }
    }
    v24 = _dispatch_set_priority_and_voucher_slow(v29, v23, 0);
    goto LABEL_35;
  }
LABEL_36:
  (*(void (**)(void))(*(_QWORD *)(v22 + 40) + 16))();
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v25 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v25 & 0x1000000) != 0)
      v26 = v25 & 0xFFFFFFFFFEFFFFFFLL;
    else
      v26 = 0;
  }
  else
  {
    v26 = 0;
  }
  if (v26)
    goto LABEL_47;
  if (v19 == -1)
    goto LABEL_48;
  if ((void *)v19 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_47:
    _dispatch_set_priority_and_voucher_slow(v26, (_DWORD *)v19, 6);
    goto LABEL_48;
  }
  if (v19)
    os_release((void *)v19);
LABEL_48:
  if ((v20 & 8) == 0)
  {
    v15 = (unsigned int *)(v22 + 20);
    v16 = *(_DWORD *)(v22 + 20);
    do
    {
      v9 = v16;
      do
        v10 = __ldaxr(v15);
      while (v10 == v16 && __stlxr(v16 + 1, v15));
      v16 = v10;
    }
    while (v10 != v9);
    if (!v10)
      dispatch_group_leave(*(dispatch_group_t *)(v22 + 48));
  }
  v13 = (unint64_t *)(v22 + 56);
  v14 = *(unsigned int **)(v22 + 56);
  do
  {
    v11 = v14;
    do
      v12 = (unsigned int *)__ldaxr(v13);
    while (v12 == v14 && __stlxr(0, v13));
    v14 = v12;
  }
  while (v12 != v11);
  if (v12)
    _dispatch_release_2(v12);
}

void _dispatch_release_2(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;
  int v6;

  v6 = a1[2];
  if (v6 != 0x7FFFFFFF)
  {
    v3 = a1 + 2;
    v4 = a1[2];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 2, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v6 = v2 - 2;
  }
  if (v6 < 1)
  {
    if (v6 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x1A668);
    }
    v5 = a1[3];
    if (v5 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x1A6C8);
    }
    _os_object_dispose(a1);
  }
}

void dispatch_block_cancel(dispatch_block_t block)
{
  uint64_t v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;
  char *v7;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((_QWORD *)block + 4) != 3512316172)
    {
      v1 = *((_QWORD *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x1A7B8);
    }
    v7 = (char *)block + 32;
  }
  else
  {
    v7 = 0;
  }
  if (!v7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_cancel()";
    __break(1u);
    JUMPOUT(0x1A800);
  }
  v4 = (unsigned int *)(v7 + 16);
  v5 = *((_DWORD *)v7 + 4);
  do
  {
    v2 = v5;
    do
      v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 | 1, v4));
    v5 = v3;
  }
  while (v3 != v2);
}

intptr_t dispatch_block_testcancel(dispatch_block_t block)
{
  uint64_t v1;
  char *v4;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((_QWORD *)block + 4) != 3512316172)
    {
      v1 = *((_QWORD *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v1;
      __break(1u);
      JUMPOUT(0x1A9B0);
    }
    v4 = (char *)block + 32;
  }
  else
  {
    v4 = 0;
  }
  if (!v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_testcancel()";
    __break(1u);
    JUMPOUT(0x1A9F8);
  }
  return *((_DWORD *)v4 + 4) & 1;
}

intptr_t dispatch_block_wait(dispatch_block_t block, dispatch_time_t timeout)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unint64_t v5;
  unint64_t v6;
  unsigned int v7;
  unsigned int v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  BOOL v19;
  char v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unsigned int *v24;
  unsigned int v25;
  intptr_t v26;
  int v27;
  unsigned int v28;
  unint64_t v29;
  char *v32;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((_QWORD *)block + 4) != 3512316172)
    {
      v2 = *((_QWORD *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x1AAF4);
    }
    v32 = (char *)block + 32;
  }
  else
  {
    v32 = 0;
  }
  if (!v32)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_wait()";
    __break(1u);
    JUMPOUT(0x1AB3CLL);
  }
  v24 = (unsigned int *)(v32 + 16);
  v25 = *((_DWORD *)v32 + 4);
  do
  {
    v3 = v25;
    do
      v4 = __ldaxr(v24);
    while (v4 == v25 && __stlxr(v25 | 2, v24));
    v25 = v4;
  }
  while (v4 != v3);
  if ((v4 & 6) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be waited for more than once";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x1AC34);
  }
  v29 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  v22 = (unint64_t *)(v32 + 56);
  v23 = *((_QWORD *)v32 + 7);
  do
  {
    v5 = v23;
    do
      v6 = __ldaxr(v22);
    while (v6 == v23 && __stlxr(0, v22));
    v21 = v6;
    v23 = v6;
  }
  while (v6 != v5);
  if (v6)
  {
    v7 = (v29 & 0x3FFF00) >> 8;
    v8 = __clz(__rbit32(v7));
    if (v7)
      v9 = v8 + 1;
    else
      v9 = 0;
    (*(void (**)(unint64_t, uint64_t, uint64_t))(*(_QWORD *)v6 + 64))(v6, v9, 9);
  }
  v28 = *((_DWORD *)v32 + 16);
  if (v28 && (_dispatch_set_qos_class_enabled & 1) != 0)
    _pthread_qos_override_start_direct(v28, v29, v32);
  v27 = *((_DWORD *)v32 + 5);
  v20 = 1;
  if (v27 <= 1)
  {
    v19 = 0;
    if (v28)
      v19 = v21 != 0;
    v20 = v19;
  }
  if ((v20 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v27;
    __break(1u);
    JUMPOUT(0x1AE90);
  }
  v26 = dispatch_group_wait(*((dispatch_group_t *)v32 + 6), timeout);
  if (v28 && (_dispatch_set_qos_class_enabled & 1) != 0)
    _pthread_qos_override_end_direct(v28, v32);
  if (v26)
  {
    v17 = (unsigned int *)(v32 + 16);
    v18 = *((_DWORD *)v32 + 4);
    do
    {
      v10 = v18;
      do
        v11 = __ldaxr(v17);
      while (v11 == v18 && __stlxr(v18 & 0xFFFFFFFD, v17));
      v18 = v11;
    }
    while (v11 != v10);
  }
  else
  {
    v15 = (unsigned int *)(v32 + 16);
    v16 = *((_DWORD *)v32 + 4);
    do
    {
      v12 = v16;
      do
        v13 = __ldaxr(v15);
      while (v13 == v16 && __stlxr(v16 | 4, v15));
      v16 = v13;
    }
    while (v13 != v12);
  }
  return v26;
}

void dispatch_block_notify(dispatch_block_t block, dispatch_queue_t queue, dispatch_block_t notification_block)
{
  uint64_t v3;
  int v4;
  char *v9;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    if (*((_QWORD *)block + 4) != 3512316172)
    {
      v3 = *((_QWORD *)block + 4);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x1B190);
    }
    v9 = (char *)block + 32;
  }
  else
  {
    v9 = 0;
  }
  if (!v9)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid block object passed to dispatch_block_notify()";
    qword_E4DA8 = (uint64_t)block;
    __break(1u);
    JUMPOUT(0x1B1F0);
  }
  v4 = *((_DWORD *)v9 + 5);
  if (v4 >= 2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and observed";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x1B274);
  }
  dispatch_group_notify(*((dispatch_group_t *)v9 + 6), queue, notification_block);
}

uint64_t _dispatch_continuation_init_slow(uint64_t *a1, unsigned int *a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  void *v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  int v36;
  uint64_t v39;
  _QWORD *v40;
  unint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  void *v48;

  v39 = a1[5];
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(v39) == ___dispatch_block_create_block_invoke)
  {
    if (*(_QWORD *)(v39 + 32) != 3512316172)
    {
      v3 = *(_QWORD *)(v39 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x1B380);
    }
    v40 = (_QWORD *)(v39 + 32);
  }
  else
  {
    v40 = 0;
  }
  v34 = v40[1];
  v33 = *a1;
  _dispatch_retain_2((uint64_t)a2);
  v10 = v40 + 7;
  do
    v11 = __ldaxr(v10);
  while (!v11 && __stlxr((unint64_t)a2, v10));
  if (v11)
    _dispatch_release_2(a2);
  if ((v33 & 4) != 0)
    a1[4] = (uint64_t)_dispatch_block_async_invoke_and_release;
  else
    a1[4] = (uint64_t)_dispatch_block_async_invoke;
  v36 = a3 | v34;
  if ((v34 & 0x40000000) != 0)
  {
    v32 = v40[3] & 0xFFFFFFLL;
  }
  else if ((v36 & 0x40000000) != 0)
  {
    v32 = 0;
  }
  else
  {
    v46 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v46 <= 0x10FF)
      v47 = v46;
    else
      v47 = 4351;
    v32 = v47;
  }
  v42 = v32;
  if (v32)
  {
    if ((v36 & 0x20) != 0)
    {
      v42 = v32 | 0x10000000;
    }
    else if ((a2[21] & 0x40000000) == 0 && (a2[21] & 0xFFF) != 0)
    {
      v42 = 0;
    }
  }
  a1[1] = v42;
  if ((v34 & 1) != 0)
    v33 |= 2uLL;
  if ((v34 & 0x80000000) != 0)
  {
    v31 = (void *)v40[4];
    if (!v31 || v31 == (void *)-1)
    {
      v30 = v40[4];
    }
    else
    {
      os_retain(v31);
      v30 = (uint64_t)v31;
    }
    a1[3] = v30;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v12, v13, v14, v15, v16, v17, v18, 746);
    v43 = a1[3];
    if (v43 != -1)
    {
      v29 = v43 ? *(_DWORD *)(v43 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v29, a1, 0, 0);
    }
  }
  else
  {
    v44 = 0;
    if (v36 < 0)
      _dispatch_abort(583, v36 >= 0, v4, v5, v6, v7, v8, v9);
    if ((v36 & 0x40) == 0)
    {
      v48 = _dispatch_thread_getspecific(0x1CuLL);
      if (v48)
        os_retain(v48);
      v44 = (uint64_t)v48;
    }
    a1[3] = v44;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v19, v20, v21, v22, v23, v24, v25, 589);
    v45 = a1[3];
    if (v45 != -1)
    {
      v28 = v45 ? *(_DWORD *)(v45 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v28, a1, 0, 0);
    }
  }
  *a1 = v33 | 0x20;
  v41 = (a1[1] & 0x3FFF00uLL) >> 8;
  v26 = __clz(__rbit32(v41));
  if ((_DWORD)v41)
    return v26 + 1;
  else
    return 0;
}

void _dispatch_block_async_invoke_and_release(_QWORD *a1)
{
  _dispatch_block_async_invoke2(a1, 1);
}

void _dispatch_block_async_invoke(_QWORD *a1)
{
  _dispatch_block_async_invoke2(a1, 0);
}

void dispatch_barrier_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void *v23;

  v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22, v17[2]);
    *v17 = 262;
    v17[4] = work;
    v17[5] = context;
    v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v21 <= 0x10FF)
      v22 = v21;
    else
      v22 = 4351;
    v23 = _dispatch_thread_getspecific(0x1CuLL);
    if (v23)
      os_retain(v23);
    v17[3] = v23;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    v20 = v17[3];
    if (v20 != -1)
    {
      v13 = v20 ? *(_DWORD *)(v20 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v13, v17, 0, 0);
    }
    v19 = v22;
    v18 = 0;
    if (v22)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        v10 = v22 >> 8;
        v11 = __clz(__rbit32(v10));
        if (v10)
          v12 = v11 + 1;
        else
          v12 = 0;
        v18 = v12;
      }
      else
      {
        v19 = 0;
      }
    }
    v17[1] = v19;
    (*(void (**)(dispatch_queue_t, _QWORD *, _QWORD))(*(_QWORD *)queue + 72))(queue, v17, v18);
  }
  else
  {
    _dispatch_async_f_slow(queue, (uint64_t)context, (uint64_t)work, 0, 6);
  }
}

uint64_t _dispatch_async_f_slow(_DWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v25;
  _QWORD *v26;
  unint64_t v32;
  unsigned int v33;
  uint64_t v34;
  void *v35;
  uint64_t v36;
  unint64_t v37;
  uint64_t v38;
  void *v39;

  v26 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  v32 = 0;
  *v26 = a5 | 0x100;
  v26[4] = a3;
  v26[5] = a2;
  if ((a4 & 0x40000000) == 0)
  {
    v37 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v37 <= 0x10FF)
      v38 = v37;
    else
      v38 = 4351;
    v32 = v38;
  }
  v35 = 0;
  if (a4 < 0)
    _dispatch_abort(583, a4 >= 0, v5, v6, v7, v8, v9, v10);
  if ((a4 & 0x40) == 0)
  {
    v39 = _dispatch_thread_getspecific(0x1CuLL);
    if (v39)
      os_retain(v39);
    v35 = v39;
  }
  v26[3] = v35;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589);
  v36 = v26[3];
  if (v36 != -1)
  {
    v25 = v36 ? *(_DWORD *)(v36 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v25, v26, 0, 0);
  }
  v34 = v32;
  v33 = 0;
  if (v32)
  {
    if ((a4 & 0x20) != 0)
    {
      v34 = v32 | 0x10000000;
      v18 = (v32 | 0x10000000) >> 8;
      v19 = __clz(__rbit32(v18));
      if (v18)
        v20 = v19 + 1;
      else
        v20 = 0;
      v33 = v20;
    }
    else if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      v21 = v32 >> 8;
      v22 = __clz(__rbit32(v21));
      if (v21)
        v23 = v22 + 1;
      else
        v23 = 0;
      v33 = v23;
    }
    else
    {
      v34 = 0;
    }
  }
  v26[1] = v34;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v26, v33);
}

uint64_t _dispatch_barrier_async_detached_f(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD *v10;
  _QWORD *v11;

  v11 = _dispatch_thread_getspecific(0x16uLL);
  if (v11)
  {
    _dispatch_thread_setspecific(22, v11[2]);
    v10 = v11;
  }
  else
  {
    v10 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v10 = 262;
  v10[4] = a3;
  v10[5] = a2;
  v10[3] = -1;
  v10[1] = -1;
  return (*(uint64_t (**)(uint64_t, _QWORD *, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 72))(a1, v10, 0, v3, v4, v5);
}

void dispatch_barrier_async(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t *v15;
  uint64_t *v16;
  void *v17;
  unsigned int inited;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;

  v16 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v16)
  {
    _dispatch_thread_setspecific(22, v16[2]);
    v15 = v16;
  }
  else
  {
    v15 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v17 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *v15 = 278;
    v15[5] = (uint64_t)v17;
    inited = _dispatch_continuation_init_slow(v15, (unsigned int *)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *v15 = 278;
    v15[4] = (uint64_t)_dispatch_call_block_and_release;
    v15[5] = (uint64_t)v17;
    v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF)
      v23 = v22;
    else
      v23 = 4351;
    v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24)
      os_retain(v24);
    v15[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    v21 = v15[3];
    if (v21 != -1)
    {
      v12 = v21 ? *(_DWORD *)(v21 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v12, v15, 0, 0);
    }
    v20 = v23;
    v19 = 0;
    if (v23)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        v9 = v23 >> 8;
        v10 = __clz(__rbit32(v9));
        if (v9)
          v11 = v10 + 1;
        else
          v11 = 0;
        v19 = v11;
      }
      else
      {
        v20 = 0;
      }
    }
    v15[1] = v20;
    inited = v19;
  }
  (*(void (**)(dispatch_queue_t, uint64_t *, _QWORD))(*(_QWORD *)queue + 72))(queue, v15, inited);
}

void dispatch_channel_async_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v17;
  unsigned int v18;
  unint64_t v19;
  uint64_t v20;
  unint64_t v21;
  unint64_t v22;
  void *v23;

  v17 = _dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22, v17[2]);
    *v17 = 260;
    v17[4] = work;
    v17[5] = context;
    v21 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v21 <= 0x10FF)
      v22 = v21;
    else
      v22 = 4351;
    v23 = _dispatch_thread_getspecific(0x1CuLL);
    if (v23)
      os_retain(v23);
    v17[3] = v23;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    v20 = v17[3];
    if (v20 != -1)
    {
      v13 = v20 ? *(_DWORD *)(v20 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v13, v17, 0, 0);
    }
    v19 = v22;
    v18 = 0;
    if (v22)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        v10 = v22 >> 8;
        v11 = __clz(__rbit32(v10));
        if (v10)
          v12 = v11 + 1;
        else
          v12 = 0;
        v18 = v12;
      }
      else
      {
        v19 = 0;
      }
    }
    v17[1] = v19;
    (*(void (**)(dispatch_queue_t, _QWORD *, _QWORD))(*(_QWORD *)queue + 72))(queue, v17, v18);
  }
  else
  {
    _dispatch_async_f_slow(queue, (uint64_t)context, (uint64_t)work, 0, 4);
  }
}

uint64_t dispatch_async_enforce_qos_class_f(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _QWORD *v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  uint64_t v23;
  void *v24;

  v18 = _dispatch_thread_getspecific(0x16uLL);
  if (!v18)
    return _dispatch_async_f_slow(a1, a2, a3, 32, 4);
  _dispatch_thread_setspecific(22, v18[2]);
  *v18 = 260;
  v18[4] = a3;
  v18[5] = a2;
  v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF)
    v23 = v22;
  else
    v23 = 4351;
  v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24)
    os_retain(v24);
  v18[3] = v24;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  v21 = v18[3];
  if (v21 != -1)
  {
    v14 = v21 ? *(_DWORD *)(v21 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v14, v18, 0, 0);
  }
  v20 = v23;
  v19 = 0;
  if (v23)
  {
    v20 = v23 | 0x10000000;
    v11 = (v23 | 0x10000000uLL) >> 8;
    v12 = __clz(__rbit32(v11));
    if (v11)
      v13 = v12 + 1;
    else
      v13 = 0;
    v19 = v13;
  }
  v18[1] = v20;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v18, v19);
}

void dispatch_channel_async(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t *v15;
  uint64_t *v16;
  void *v17;
  unsigned int inited;
  unsigned int v19;
  unint64_t v20;
  uint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;

  v16 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v16)
  {
    _dispatch_thread_setspecific(22, v16[2]);
    v15 = v16;
  }
  else
  {
    v15 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v17 = _dispatch_Block_copy(block);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    *v15 = 276;
    v15[5] = (uint64_t)v17;
    inited = _dispatch_continuation_init_slow(v15, (unsigned int *)queue, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)block);
    *v15 = 276;
    v15[4] = (uint64_t)_dispatch_call_block_and_release;
    v15[5] = (uint64_t)v17;
    v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF)
      v23 = v22;
    else
      v23 = 4351;
    v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24)
      os_retain(v24);
    v15[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    v21 = v15[3];
    if (v21 != -1)
    {
      v12 = v21 ? *(_DWORD *)(v21 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v12, v15, 0, 0);
    }
    v20 = v23;
    v19 = 0;
    if (v23)
    {
      if ((*((_DWORD *)queue + 21) & 0x40000000) != 0 || (*((_DWORD *)queue + 21) & 0xFFF) == 0)
      {
        v9 = v23 >> 8;
        v10 = __clz(__rbit32(v9));
        if (v9)
          v11 = v10 + 1;
        else
          v11 = 0;
        v19 = v11;
      }
      else
      {
        v20 = 0;
      }
    }
    v15[1] = v20;
    inited = v19;
  }
  (*(void (**)(dispatch_queue_t, uint64_t *, _QWORD))(*(_QWORD *)queue + 72))(queue, v15, inited);
}

uint64_t _dispatch_barrier_trysync_or_async_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), unsigned int a4)
{
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unint64_t *v15;
  _BOOL4 v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;

  v4 = _dispatch_thread_getspecific(3uLL);
  v19 = (4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  v18 = v4 & 0xFFFFFFFC | 0x60000000000002 | ((unint64_t)((a4 & 1) != 0) << 58);
  v16 = 0;
  v15 = (unint64_t *)(a1 + 56);
  while (1)
  {
    v9 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v15) : __ldxr(v15);
    if (v9 != (v19 | v9 & 0x3000000000))
      break;
    v17 = v18 | v9 & 0x3000000000;
    if (_os_atomic_mo_has_release(2))
      v16 = __stlxr(v17, v15) == 0;
    else
      v16 = __stxr(v17, v15) == 0;
    if (v16)
      goto LABEL_11;
  }
  __clrex();
LABEL_11:
  if (!v16)
    return _dispatch_barrier_async_detached_f(a1, a2, (uint64_t)a3);
  if ((a4 & 1) != 0)
    _dispatch_retain_2(a1);
  return _dispatch_barrier_trysync_or_async_f_complete((unint64_t *)a1, a2, a3, a4, v5, v6, v7, v8);
}

uint64_t _dispatch_retain_2(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 8);
    v4 = *(_DWORD *)(result + 8);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + 2, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2;
  }
  if (v5 <= 0)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
    __break(1u);
    JUMPOUT(0x1E990);
  }
  return result;
}

uint64_t _dispatch_barrier_trysync_or_async_f_complete(unint64_t *a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v20;
  unint64_t v21;
  uint64_t (*v22)(uint64_t);
  unsigned int v23;
  char v24;
  __int128 v26;
  uint64_t (*v27)(uint64_t);
  uint64_t v28;
  unint64_t *v29;
  int v30;
  int v31;
  int v32;
  int v33;
  uint64_t (*v34)(uint64_t);
  uint64_t (*v35)(uint64_t);
  uint64_t v36;
  uint64_t (*v37)(uint64_t);
  uint64_t v38;
  uint64_t (*v39)(uint64_t);
  uint64_t v40;
  __int128 *v41;
  unint64_t *v42;
  __int128 *v43;
  __int128 *v44;

  v24 = a4;
  v23 = 4;
  v29 = a1;
  v28 = a2;
  v27 = a3;
  v26 = 0uLL;
  v42 = a1;
  v41 = &v26;
  v44 = &v26;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v26, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v42, 21, (uint64_t)v41, v8, v9, v10, v11);
  v36 = v28;
  v35 = v27;
  v34 = 0;
  if ((char *)v27 == (char *)_dispatch_call_block_and_release && v36)
    v22 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v36);
  else
    v22 = v35;
  v34 = v22;
  v38 = v36;
  v37 = v22;
  v33 = 0;
  v32 = 0;
  v31 = 0;
  v30 = 0;
  _dispatch_client_callout(v36, v35);
  v40 = v36;
  v39 = v34;
  v43 = &v26;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v26, v12, v13, v14, v15, v16);
  if ((v24 & 1) != 0)
  {
    v20 = a1 + 7;
    v21 = a1[7];
    do
    {
      v17 = v21;
      do
        v18 = __ldaxr(v20);
      while (v18 == v21 && __stlxr(v21 - 0x400000000000000, v20));
      v21 = v18;
    }
    while (v18 != v17);
    if (((v18 - 0x400000000000000) & 0xFF80000000000000) == 0)
      v23 = 5;
  }
  return (*(uint64_t (**)(unint64_t *, _QWORD, _QWORD))(*a1 + 64))(a1, 0, v23);
}

void dispatch_barrier_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  _BYTE v9[12];
  char v13;
  unint64_t *v14;
  _BOOL4 v15;
  unint64_t v16;
  unint64_t v17;

  *(_DWORD *)&v9[8] = 0;
  *(_QWORD *)v9 = _dispatch_thread_getspecific(3uLL);
  if (*(_BYTE *)(*(_QWORD *)queue + 16) != 17)
    goto LABEL_5;
  LOBYTE(v8) = 0;
  if ((*((_DWORD *)queue + 20) & 0x1000000) != 0)
    v8 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
  if ((v8 & 1) == 0)
    v13 = 1;
  else
LABEL_5:
    v13 = 0;
  if ((v13 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x1EEA8);
  }
  v17 = (unint64_t)(4096 - *((unsigned __int16 *)queue + 40)) << 41;
  v15 = 0;
  v14 = (unint64_t *)((char *)queue + 56);
  while (1)
  {
    v7 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v14) : __ldxr(v14);
    if (v7 != (v17 | v7 & 0x3000000000))
      break;
    v16 = *(_DWORD *)v9 & 0xFFFFFFFC | 0x60000000000002 | v7 & 0x3000000000;
    if (_os_atomic_mo_has_release(2))
      v15 = __stlxr(v16, v14) == 0;
    else
      v15 = __stxr(v16, v14) == 0;
    if (v15)
      goto LABEL_19;
  }
  __clrex();
LABEL_19:
  if (v15)
  {
    if (*(_QWORD *)(*((_QWORD *)queue + 3) + 24))
      _dispatch_sync_recurse((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, *(_QWORD *)&v9[4] | 2);
    else
      _dispatch_lane_barrier_sync_invoke_and_complete((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, v3, v4, v5, v6);
  }
  else
  {
    _dispatch_sync_f_slow((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 2, (uint64_t)queue, *(_QWORD *)&v9[4] | 2, v5, v6);
  }
}

void dispatch_sync_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  int v8;
  char v12;
  unint64_t *v13;
  _BOOL4 v14;
  unint64_t v15;
  char v16;

  if (*((_WORD *)queue + 40) == 1)
  {
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0);
  }
  else
  {
    if (*(_BYTE *)(*(_QWORD *)queue + 16) != 17)
      goto LABEL_7;
    LOBYTE(v8) = 0;
    if ((*((_DWORD *)queue + 20) & 0x1000000) != 0)
      v8 = (BYTE2(*((_DWORD *)queue + 20)) >> 2) & 1;
    if ((v8 & 1) == 0)
      v12 = 1;
    else
LABEL_7:
      v12 = 0;
    if ((v12 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x1F2B8);
    }
    if (*((_QWORD *)queue + 6))
    {
      v16 = 0;
    }
    else
    {
      v13 = (unint64_t *)((char *)queue + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v7 = __ldaxr(v13);
        else
          v7 = __ldxr(v13);
        if (v7 >> 54 || (v7 & 0x8000000000) != 0 || (v7 & 0x10000000000) != 0)
        {
          __clrex();
          v16 = 0;
          goto LABEL_26;
        }
        v15 = v7 + 0x20000000000;
        if (_os_atomic_mo_has_release(0))
          v14 = __stlxr(v15, v13) == 0;
        else
          v14 = __stxr(v15, v13) == 0;
      }
      while (!v14);
      v16 = 1;
    }
LABEL_26:
    if ((v16 & 1) != 0)
    {
      if (*(_QWORD *)(*((_QWORD *)queue + 3) + 24))
        _dispatch_sync_recurse((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0);
      else
        _dispatch_sync_invoke_and_complete((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, v3, v4, v5, v6);
    }
    else
    {
      _dispatch_sync_f_slow((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, 0, (uint64_t)queue, 0, v5, v6);
    }
  }
}

void dispatch_barrier_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t (*v2)(uint64_t);

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    _dispatch_sync_block_with_privdata((unsigned int *)queue, (uint64_t)block, 18);
  }
  else
  {
    v2 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn((uint64_t)block);
    _dispatch_barrier_sync_f((uint64_t)queue, (uint64_t)block, v2, 18);
  }
}

void _dispatch_sync_block_with_privdata(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v23;
  uint64_t v26;
  unint64_t v27;
  void *v28;
  uint64_t v29;
  _QWORD *v31;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a2) == ___dispatch_block_create_block_invoke)
  {
    if (*(_QWORD *)(a2 + 32) != 3512316172)
    {
      v9 = *(_QWORD *)(a2 + 32);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v9;
      __break(1u);
      JUMPOUT(0x1F6ACLL);
    }
    v31 = (_QWORD *)(a2 + 32);
  }
  else
  {
    v31 = 0;
  }
  v21 = 0;
  v20 = v31[1];
  if ((v20 & 1) != 0)
    v23 = a3 | 0x22;
  else
    v23 = a3 | 0x20;
  v26 = 0;
  if ((v20 & 0x40000000) != 0 && ((v20 & 0x20) != 0 || (v20 & 0x10) == 0))
  {
    v27 = v31[3] & 0xFFFFFFLL;
    v28 = _dispatch_thread_getspecific(4uLL);
    if ((v28 & 0xFFFFFF) != 0 && (v28 & 0xFFFFFF) < v27)
      v26 = v28 & 0xFFFFFF;
  }
  if (v26)
    v21 = v31[3];
  v19 = -1;
  if ((v20 & 0x80000000) != 0)
    v19 = v31[4];
  if (v21 == -1)
    _dispatch_abort(2332, 0, v3, v4, v5, v6, v7, v8);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v34 = v21 & 0xFFFFFFFF02FFFFFFLL;
    v10 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v10 & 0x1000000) != 0)
    {
      if (v34)
        v18 = v21 & 0xFFFFFFFF02FFFFFFLL;
      else
        v18 = v10 & 0xFFFFFFFFFEFFFFFFLL;
      v35 = v18;
    }
    else if (v34 == (v10 & 0xFFFFFFFF77FFFFFFLL))
    {
      v35 = 0;
    }
    else
    {
      v35 = v21 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v35 = 0;
  }
  if (!v35)
  {
    if (v19 == -1)
    {
      v29 = -1;
      goto LABEL_39;
    }
    if ((void *)v19 == _dispatch_thread_getspecific(0x1CuLL))
    {
      if (v19)
        os_retain((void *)v19);
      v29 = v19;
      goto LABEL_39;
    }
  }
  v29 = _dispatch_set_priority_and_voucher_slow(v35, (_DWORD *)v19, 0);
LABEL_39:
  _dispatch_retain_2((uint64_t)a1);
  v15 = v31 + 7;
  do
    v16 = __ldaxr(v15);
  while (!v16 && __stlxr((unint64_t)a1, v15));
  if (v16)
    _dispatch_release_2(a1);
  if ((v23 & 2) != 0)
    _dispatch_barrier_sync_f((uint64_t)a1, a2, (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke, v23);
  else
    _dispatch_sync_f((uint64_t)a1, a2, (uint64_t (*)(uint64_t))_dispatch_block_sync_invoke, v23, v11, v12, v13, v14);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v32 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v32 & 0x1000000) != 0)
    {
      if ((v26 & 0x2FFFFFF) != 0)
        v17 = v26 & 0x2FFFFFF;
      else
        v17 = v32 & 0xFFFFFFFFFEFFFFFFLL;
      v33 = v17;
    }
    else if ((v26 & 0x2FFFFFF) == (v32 & 0xFFFFFFFF77FFFFFFLL))
    {
      v33 = 0;
    }
    else
    {
      v33 = v26 & 0xFFFFFFFF02FFFFFFLL;
    }
  }
  else
  {
    v33 = 0;
  }
  if (v33)
    goto LABEL_63;
  if (v29 == -1)
    return;
  if ((void *)v29 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_63:
    _dispatch_set_priority_and_voucher_slow(v33, (_DWORD *)v29, 6);
  }
  else if (v29)
  {
    os_release((void *)v29);
  }
}

void _dispatch_barrier_sync_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  int v9;
  unsigned int v10;
  char v15;
  unint64_t *v16;
  _BOOL4 v17;
  unint64_t v18;
  unint64_t v19;

  v10 = _dispatch_thread_getspecific(3uLL);
  if (*(_BYTE *)(*(_QWORD *)a1 + 16) != 17)
    goto LABEL_5;
  LOBYTE(v9) = 0;
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0)
    v9 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
  if ((v9 & 1) == 0)
    v15 = 1;
  else
LABEL_5:
    v15 = 0;
  if ((v15 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
    __break(1u);
    JUMPOUT(0x2007CLL);
  }
  v19 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  v17 = 0;
  v16 = (unint64_t *)(a1 + 56);
  while (1)
  {
    v8 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v16) : __ldxr(v16);
    if (v8 != (v19 | v8 & 0x3000000000))
      break;
    v18 = v10 & 0xFFFFFFFC | 0x60000000000002 | v8 & 0x3000000000;
    if (_os_atomic_mo_has_release(2))
      v17 = __stlxr(v18, v16) == 0;
    else
      v17 = __stxr(v18, v16) == 0;
    if (v17)
      goto LABEL_19;
  }
  __clrex();
LABEL_19:
  if (v17)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 24))
      _dispatch_sync_recurse(a1, a2, a3, a4 | 2);
    else
      _dispatch_lane_barrier_sync_invoke_and_complete(a1, a2, a3, 0, v4, v5, v6, v7);
  }
  else
  {
    _dispatch_sync_f_slow(a1, a2, a3, 2, a1, a4 | 2, v6, v7);
  }
}

void dispatch_sync(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t (*v2)(uint64_t);
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
  {
    _dispatch_sync_block_with_privdata((unsigned int *)queue, (uint64_t)block, 16);
  }
  else
  {
    v2 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn((uint64_t)block);
    _dispatch_sync_f((uint64_t)queue, (uint64_t)block, v2, 16, v3, v4, v5, v6);
  }
}

void _dispatch_sync_f(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  int v9;
  char v14;
  unint64_t *v15;
  _BOOL4 v16;
  unint64_t v17;
  char v18;

  if (*(_WORD *)(a1 + 80) == 1)
  {
    _dispatch_barrier_sync_f(a1, a2, a3, a4);
  }
  else
  {
    if (*(_BYTE *)(*(_QWORD *)a1 + 16) != 17)
      goto LABEL_7;
    LOBYTE(v9) = 0;
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0)
      v9 = (BYTE2(*(_DWORD *)(a1 + 80)) >> 2) & 1;
    if ((v9 & 1) == 0)
      v14 = 1;
    else
LABEL_7:
      v14 = 0;
    if ((v14 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue type doesn't support dispatch_sync";
      __break(1u);
      JUMPOUT(0x20538);
    }
    if (*(_QWORD *)(a1 + 48))
    {
      v18 = 0;
    }
    else
    {
      v15 = (unint64_t *)(a1 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v8 = __ldaxr(v15);
        else
          v8 = __ldxr(v15);
        if (v8 >> 54 || (v8 & 0x8000000000) != 0 || (v8 & 0x10000000000) != 0)
        {
          __clrex();
          v18 = 0;
          goto LABEL_26;
        }
        v17 = v8 + 0x20000000000;
        if (_os_atomic_mo_has_release(0))
          v16 = __stlxr(v17, v15) == 0;
        else
          v16 = __stxr(v17, v15) == 0;
      }
      while (!v16);
      v18 = 1;
    }
LABEL_26:
    if ((v18 & 1) != 0)
    {
      if (*(_QWORD *)(*(_QWORD *)(a1 + 24) + 24))
        _dispatch_sync_recurse(a1, a2, a3, a4);
      else
        _dispatch_sync_invoke_and_complete(a1, a2, a3, 0, a5, a6, a7, a8);
    }
    else
    {
      _dispatch_sync_f_slow(a1, a2, a3, 0, a1, a4, a7, a8);
    }
  }
}

void dispatch_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if (*((_QWORD *)queue + 3))
  {
    v8 = 128;
    if (*((_WORD *)queue + 40) == 1)
      v8 = 130;
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, v8);
  }
  else
  {
    _dispatch_sync_function_invoke((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, v3, v4, v5, v6, v7);
  }
}

uint64_t _dispatch_sync_function_invoke(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v18)(uint64_t);
  __int128 v19;
  uint64_t (*v20)(uint64_t);
  uint64_t v21;
  uint64_t v22;
  int v23;
  int v24;
  int v25;
  int v26;
  uint64_t (*v27)(uint64_t);
  uint64_t (*v28)(uint64_t);
  uint64_t v29;
  uint64_t (*v30)(uint64_t);
  uint64_t v31;
  uint64_t (*v32)(uint64_t);
  uint64_t v33;
  __int128 *v34;
  uint64_t v35;
  __int128 *v36;
  __int128 *v37;

  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = 0uLL;
  v35 = a1;
  v34 = &v19;
  v37 = &v19;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v19, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v35, 21, (uint64_t)v34, v8, v9, v10, v11);
  v29 = v21;
  v28 = v20;
  v27 = 0;
  if ((char *)v20 == (char *)_dispatch_call_block_and_release && v29)
    v18 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v29);
  else
    v18 = v28;
  v27 = v18;
  v31 = v29;
  v30 = v18;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  v23 = 0;
  _dispatch_client_callout(v29, v28);
  v33 = v29;
  v32 = v27;
  v36 = &v19;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v19, v12, v13, v14, v15, v16);
}

void _dispatch_async_and_wait_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _QWORD __b[14];
  int v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unint64_t v11;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  v11 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  v6 = v11;
  v5 = _dispatch_thread_getspecific(3uLL);
  memset(__b, 0, sizeof(__b));
  __b[0] = v7;
  __b[1] = v11 | 0x10000000;
  __b[2] = 0;
  __b[3] = _dispatch_thread_getspecific(0x1CuLL);
  __b[4] = _dispatch_async_and_wait_invoke;
  __b[5] = __b;
  __b[6] = 0;
  __b[7] = v10;
  __b[8] = v8;
  __b[9] = v9;
  memset(&__b[10], 0, 20);
  HIDWORD(__b[12]) = v5;
  LOWORD(__b[13]) = 0;
  BYTE2(__b[13]) = 0;
  _dispatch_async_and_wait_recurse(v10, (uint64_t)__b, v5, v7);
}

void dispatch_barrier_async_and_wait_f(dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*((_QWORD *)queue + 3))
    _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)context, (uint64_t)work, 130);
  else
    _dispatch_sync_function_invoke((uint64_t)queue, (uint64_t)context, (uint64_t (*)(uint64_t))work, v3, v4, v5, v6, v7);
}

void dispatch_barrier_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v2;

  if (*((_QWORD *)queue + 3))
  {
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((unsigned int *)queue, (uint64_t)block, 146);
    }
    else
    {
      v2 = _Block_get_invoke_fn((uint64_t)block);
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v2, 146);
    }
  }
  else
  {
    dispatch_barrier_sync(queue, block);
  }
}

void _dispatch_async_and_wait_block_with_privdata(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  _QWORD v7[10];
  __int128 v8;
  int v9;
  int v10;
  char v11;
  _BYTE v12[7];
  int v13;
  void *v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int *v20;
  void *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t *v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t *v33;
  unsigned int *v34;
  _BOOL4 v35;
  BOOL v36;
  unsigned int *v37;
  unsigned int *v38;
  unsigned int *v39;
  _BOOL4 v40;
  unint64_t v41;
  unsigned int *v42;
  unsigned int *v43;
  uint64_t *v44;
  uint64_t v45;

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = 0;
  v32 = a2;
  v45 = a2;
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn(a2) == ___dispatch_block_create_block_invoke)
  {
    v31 = v32 + 32;
    v30 = (uint64_t *)(v32 + 32);
    if (*(_QWORD *)(v32 + 32) != 3512316172)
    {
      v29 = 0;
      v3 = *v30;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x20E64);
    }
    v33 = v30;
  }
  else
  {
    v33 = 0;
  }
  v17 = v33;
  v16 = 0;
  v16 = v33[1];
  v15 = 0;
  v14 = 0;
  if ((v33[1] & 1) != 0)
    v18 |= 0x22uLL;
  else
    v18 |= 0x20uLL;
  v4 = v17[3];
  v25 = v16;
  v24 = v4;
  v23 = 0;
  v22 = 0;
  if ((v16 & 0x40000000) != 0 && ((v25 & 0x20) != 0 || (v25 & 0x10) == 0))
  {
    v28 = v24;
    v24 &= 0xFFFFFFuLL;
    v26 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    v27 = v26;
    v23 = v26 & 0xFFFFFF;
    if ((v26 & 0xFFFFFF) != 0 && v23 < v24)
      v22 = v23;
  }
  if (v22)
  {
    v15 = v17[3];
  }
  else
  {
    v21 = _dispatch_thread_getspecific(4uLL);
    v15 = (unint64_t)v21;
  }
  if ((*((_BYTE *)v17 + 11) & 0x80) != 0)
    v14 = (void *)v17[4];
  else
    v14 = _dispatch_thread_getspecific(0x1CuLL);
  v44 = v17;
  v43 = v20;
  v42 = v20;
  _dispatch_retain_2((uint64_t)v20);
  v41 = 0;
  v40 = 0;
  v5 = (unint64_t *)(v17 + 7);
  v38 = v20;
  v37 = v20;
  v39 = v20;
  do
    v6 = __ldaxr(v5);
  while (!v6 && __stlxr((unint64_t)v20, v5));
  if (v6)
    v41 = v6;
  v36 = v6 == 0;
  v40 = v6 == 0;
  v35 = v40;
  if (v6)
  {
    v34 = v43;
    _dispatch_release_2(v43);
  }
  v13 = _dispatch_thread_getspecific(3uLL);
  v7[0] = v18;
  v7[1] = v15 | 0x10000000;
  v7[2] = 0;
  v7[3] = v14;
  v7[4] = _dispatch_async_and_wait_invoke;
  v7[5] = v7;
  v7[6] = 0;
  v7[7] = v20;
  v7[8] = _dispatch_block_sync_invoke;
  v7[9] = v19;
  v8 = 0uLL;
  v9 = 0;
  v10 = v13;
  v11 = 0;
  memset(v12, 0, sizeof(v12));
  _dispatch_async_and_wait_recurse((uint64_t)v20, (uint64_t)v7, v13, v18);
}

void dispatch_async_and_wait(dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v2;
  uint64_t v3;

  if (*((_QWORD *)queue + 3))
  {
    v3 = 144;
    if (*((_WORD *)queue + 40) == 1)
      v3 = 146;
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)block) == ___dispatch_block_create_block_invoke)
    {
      _dispatch_async_and_wait_block_with_privdata((unsigned int *)queue, (uint64_t)block, v3);
    }
    else
    {
      v2 = _Block_get_invoke_fn((uint64_t)block);
      _dispatch_async_and_wait_f((uint64_t)queue, (uint64_t)block, v2, v3);
    }
  }
  else
  {
    dispatch_sync(queue, block);
  }
}

void dispatch_queue_set_specific(dispatch_queue_t queue, const void *key, void *context, dispatch_function_t destructor)
{
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  BOOL v8;
  _QWORD *v9;
  uint64_t v10;
  BOOL v15;
  unsigned int v16;
  uint64_t *i;
  uint64_t *v18;
  unsigned int v19;

  if (key)
  {
    v10 = *((_QWORD *)queue + 11);
    if (*(_BYTE *)(*(_QWORD *)queue + 16) == 17)
    {
      v8 = 1;
      if (*(_QWORD *)(*(_QWORD *)queue + 16) != 394769)
        v8 = (*(_BYTE *)(*(_QWORD *)queue + 18) & 2) == 0;
      v15 = v8;
    }
    else
    {
      v15 = *(_BYTE *)(*(_QWORD *)queue + 16) == 18;
    }
    if (!v15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Queue doesn't support dispatch_queue_set_specific";
      __break(1u);
      JUMPOUT(0x21424);
    }
    if (!context || v10)
    {
      if (!v10)
        return;
    }
    else
    {
      _dispatch_queue_init_specific((uint64_t)queue);
      v10 = *((_QWORD *)queue + 11);
    }
    v16 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      v4 = __ldaxr((unsigned int *)v10);
    while (!v4 && __stlxr(v16, (unsigned int *)v10));
    if (v4)
      _dispatch_unfair_lock_lock_slow((unsigned int *)v10, 0x10000);
    for (i = *(uint64_t **)(v10 + 8); i; i = (uint64_t *)i[3])
    {
      if (*i == (_QWORD)key)
      {
        v18 = i;
        goto LABEL_24;
      }
    }
    v18 = 0;
LABEL_24:
    if (v18)
    {
      if (v18[2])
        _dispatch_barrier_async_detached_f((uint64_t)&off_E4640, v18[1], v18[2]);
      if (context)
      {
        v18[1] = (uint64_t)context;
        v18[2] = (uint64_t)destructor;
      }
      else
      {
        if (v18[3])
          *(_QWORD *)(v18[3] + 32) = v18[4];
        else
          *(_QWORD *)(v10 + 16) = v18[4];
        *(_QWORD *)v18[4] = v18[3];
        v18[3] = -1;
        v18[4] = -1;
        free(v18);
      }
    }
    else if (context)
    {
      v9 = (_QWORD *)_dispatch_calloc(1, 40);
      *v9 = key;
      v9[1] = context;
      v9[2] = destructor;
      v9[3] = 0;
      v9[4] = *(_QWORD *)(v10 + 16);
      **(_QWORD **)(v10 + 16) = v9;
      *(_QWORD *)(v10 + 16) = v9 + 3;
    }
    v19 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v7 = *(_DWORD *)v10;
    do
    {
      v5 = v7;
      do
        v6 = __ldaxr((unsigned int *)v10);
      while (v6 == v7 && __stlxr(0, (unsigned int *)v10));
      v7 = v6;
    }
    while (v6 != v5);
    if (v6 != v19)
      _dispatch_unfair_lock_unlock_slow(v10, v6);
  }
}

void _dispatch_queue_init_specific(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;
  _QWORD *v3;

  v3 = (_QWORD *)_dispatch_calloc(1, 24);
  v3[1] = 0;
  v3[2] = v3 + 1;
  v1 = (unint64_t *)(a1 + 88);
  do
    v2 = __ldaxr(v1);
  while (!v2 && __stlxr((unint64_t)v3, v1));
  if (v2)
    _dispatch_queue_specific_head_dispose(v3);
}

void *__cdecl dispatch_queue_get_specific(dispatch_queue_t queue, const void *key)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  void *v10;
  uint64_t v11;
  BOOL v13;
  unsigned int v14;
  uint64_t i;
  uint64_t v16;
  unsigned int v17;

  if (!key)
    return 0;
  v11 = *((_QWORD *)queue + 11);
  v10 = 0;
  if (*(_BYTE *)(*(_QWORD *)queue + 16) == 17)
  {
    v8 = 1;
    if (*(_QWORD *)(*(_QWORD *)queue + 16) != 394769)
      v8 = (*(_QWORD *)(*(_QWORD *)queue + 16) & 0x20000) == 0;
    v13 = v8;
  }
  else
  {
    v13 = *(_BYTE *)(*(_QWORD *)queue + 16) == 18;
  }
  v7 = 0;
  if (v13)
    v7 = v11 != 0;
  if (v7)
  {
    v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      v2 = __ldaxr((unsigned int *)v11);
    while (!v2 && __stlxr(v14, (unsigned int *)v11));
    if (v2)
      _dispatch_unfair_lock_lock_slow((unsigned int *)v11, 0x10000);
    for (i = *(_QWORD *)(v11 + 8); i; i = *(_QWORD *)(i + 24))
    {
      if (*(const void **)i == key)
      {
        v16 = i;
        goto LABEL_22;
      }
    }
    v16 = 0;
LABEL_22:
    if (v16)
      v10 = *(void **)(v16 + 8);
    v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v6 = *(_DWORD *)v11;
    do
    {
      v3 = v6;
      do
        v4 = __ldaxr((unsigned int *)v11);
      while (v4 == v6 && __stlxr(0, (unsigned int *)v11));
      v6 = v4;
    }
    while (v4 != v3);
    if (v4 != v17)
      _dispatch_unfair_lock_unlock_slow(v11, v4);
  }
  return v10;
}

void *__cdecl dispatch_get_specific(const void *key)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  BOOL v5;
  unsigned int v6;
  BOOL v7;
  BOOL v8;
  void *v9;
  __int128 v10;
  void *v11;
  uint64_t v12;
  BOOL v13;
  unsigned int v14;
  _QWORD *i;
  _QWORD *v16;
  unsigned int v17;

  *((_QWORD *)&v10 + 1) = key;
  *(_QWORD *)&v10 = _dispatch_thread_getspecific(0x14uLL);
  v9 = 0;
  if (v10 != 0)
  {
    do
    {
      v12 = *(_QWORD *)(v10 + 88);
      v11 = 0;
      if (*(_BYTE *)(*(_QWORD *)v10 + 16) == 17)
      {
        v8 = 1;
        if (*(_QWORD *)(*(_QWORD *)v10 + 16) != 394769)
          v8 = (*(_QWORD *)(*(_QWORD *)v10 + 16) & 0x20000) == 0;
        v13 = v8;
      }
      else
      {
        v13 = *(_BYTE *)(*(_QWORD *)v10 + 16) == 18;
      }
      v7 = 0;
      if (v13)
        v7 = v12 != 0;
      if (v7)
      {
        v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        do
          v1 = __ldaxr((unsigned int *)v12);
        while (!v1 && __stlxr(v14, (unsigned int *)v12));
        if (v1)
          _dispatch_unfair_lock_lock_slow((unsigned int *)v12, 0x10000);
        for (i = *(_QWORD **)(v12 + 8); i; i = (_QWORD *)i[3])
        {
          if (*i == *((_QWORD *)&v10 + 1))
          {
            v16 = i;
            goto LABEL_21;
          }
        }
        v16 = 0;
LABEL_21:
        if (v16)
          v11 = (void *)v16[1];
        v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
        v6 = *(_DWORD *)v12;
        do
        {
          v2 = v6;
          do
            v3 = __ldaxr((unsigned int *)v12);
          while (v3 == v6 && __stlxr(0, (unsigned int *)v12));
          v6 = v3;
        }
        while (v3 != v2);
        if (v3 != v17)
          _dispatch_unfair_lock_unlock_slow(v12, v3);
      }
      v9 = v11;
      *(_QWORD *)&v10 = *(_QWORD *)(v10 + 24);
      v5 = 0;
      if (!v11)
        v5 = (_QWORD)v10 != 0;
    }
    while (v5);
  }
  return v9;
}

uint64_t dispatch_queue_set_label_nocopy(uint64_t result, uint64_t a2)
{
  if (*(_DWORD *)(result + 8) != 0x7FFFFFFF)
  {
    if (((BYTE2(*(_DWORD *)(result + 80)) >> 5) & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change label for this queue";
      qword_E4DA8 = result;
      __break(1u);
      JUMPOUT(0x2231CLL);
    }
    *(_QWORD *)(result + 72) = a2;
  }
  return result;
}

uint64_t _dispatch_queue_compute_priority_and_wlh(uint64_t a1, uint64_t *a2)
{
  unsigned int v2;
  unsigned int v3;
  int v5;
  BOOL v6;
  BOOL v7;
  uint64_t v8;
  unsigned int *v9;
  unsigned int v10;
  uint64_t v11;
  BOOL v12;
  int v13;
  unsigned int v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v19;
  int v20;

  v20 = *(_DWORD *)(a1 + 84);
  v18 = v20 & 0xFFF;
  v17 = (unsigned __int16)(v20 & 0xF000) >> 12;
  v16 = *(_QWORD *)(a1 + 24);
  v15 = -4;
  if ((*(_QWORD *)(a1 + 56) & 0x2000000000) != 0)
    v15 = a1;
  while (1)
  {
    if ((*(_QWORD *)(*(_QWORD *)v16 + 16) & 0x10000) != 0)
    {
LABEL_46:
      v7 = 0;
      if (v16 >= (unint64_t)&_dispatch_root_queues)
        v7 = v16 < (unint64_t)&_dispatch_queue_serial_numbers;
      v6 = 1;
      if (!v7)
        v6 = *(_QWORD *)(v16 + 64) == 22;
      if (v6)
      {
        if (!v17)
          v17 = (*(_DWORD *)(v16 + 84) & 0xF000u) >> 12;
        if (v18 < (*(_DWORD *)(v16 + 84) & 0xFFFu))
          v18 = *(_DWORD *)(v16 + 84) & 0xFFF;
        v19 = v18 | *(_DWORD *)(v16 + 84) & 0x88000000;
        if ((v20 & 0x40000000) != 0 || (v20 & 0xFFF) == 0)
        {
          v19 |= v20 & 0x40000000;
          if (v17 > (unsigned __int16)(v19 & 0xF00) >> 8)
          {
            if (v17)
              v5 = (v17 << 12) & 0xF000 | 0x4000000;
            else
              v5 = 0;
            v19 |= v5;
          }
        }
        if (a2)
          *a2 = v15;
        return v19;
      }
      else
      {
        if (a2)
          *a2 = -4;
        return 0x2000000;
      }
    }
    if ((uint64_t (***)())v16 == &_dispatch_mgr_q)
    {
      if (a2)
        *a2 = -4;
      return 0x2000000;
    }
    v12 = 0;
    if ((*(_DWORD *)(v16 + 80) & 0x40000) != 0)
      v12 = (*(_DWORD *)(v16 + 80) & 0x1000000) == 0;
    if (v12)
    {
      if (a2)
        *a2 = -4;
      return *(unsigned int *)(v16 + 84);
    }
    if ((*(_QWORD *)(v16 + 56) & 0xFF80000000000000) != 0)
    {
      if (*(_BYTE *)(*(_QWORD *)a1 + 16) == 19)
        v11 = a1;
      else
        v11 = 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771883024, a1, v11, 0, 0);
      if (a2)
        *a2 = 0;
      return 0;
    }
    if ((*(_QWORD *)(v16 + 56) & 0x2000000000) == 0)
      break;
    v15 = v16;
    if (*(_BYTE *)(*(_QWORD *)v16 + 16) == 18)
    {
      v9 = (unsigned int *)(a1 + 80);
      v10 = *(_DWORD *)(a1 + 80);
      do
      {
        v2 = v10;
        do
          v3 = __ldaxr(v9);
        while (v3 == v10 && __stlxr(v10 & 0xFFBFFFFF, v9));
        v10 = v3;
      }
      while (v3 != v2);
    }
LABEL_40:
    v13 = *(_DWORD *)(v16 + 84);
    v16 = *(_QWORD *)(v16 + 24);
    if ((v13 & 0x20000000) != 0)
      goto LABEL_46;
    if (!v17)
      v17 = (unsigned __int16)(v13 & 0xF000) >> 12;
    v14 = v13 & 0xFFF;
    if (v18 < v14)
      v18 = v14;
  }
  if ((*(_DWORD *)(v16 + 80) & 0x400000) == 0)
    goto LABEL_40;
  if (*(_BYTE *)(*(_QWORD *)a1 + 16) == 19)
    v8 = a1;
  else
    v8 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(771883024, a1, v8, 0, 0);
  if (a2)
    *a2 = 0;
  return 0;
}

void dispatch_set_qos_class_floor(dispatch_object_t object, dispatch_qos_class_t qos_class, int relative_priority)
{
  int v3;
  int v4;
  int v5;
  uint64_t v6;

  if ((*(_QWORD *)(*(_QWORD *)object + 16) & 0xF0) != 0x10)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_floor called on invalid object type";
    __break(1u);
    JUMPOUT(0x22C80);
  }
  if (*(_BYTE *)(*(_QWORD *)object + 16) == 18)
  {
    dispatch_workloop_set_qos_class_floor((uint64_t)object, qos_class, relative_priority, 0);
  }
  else
  {
    switch(qos_class)
    {
      case 5u:
        v5 = 1;
        break;
      case 9u:
        v5 = 2;
        break;
      case 0x11u:
        v5 = 3;
        break;
      case 0x15u:
        v5 = 4;
        break;
      case 0x19u:
        v5 = 5;
        break;
      case 0x21u:
        v5 = 6;
        break;
      default:
        v5 = 0;
        break;
    }
    if (v5)
      v3 = (relative_priority - 1) | ((v5 & 0xF) << 8);
    else
      v3 = 0;
    v4 = v3;
    if (v3)
      v4 = v3 | 0x40000000;
    *((_DWORD *)object + 21) = v4 | *((_DWORD *)object + 21) & 0xBFFFF000;
    v6 = *((_QWORD *)object + 7);
    if ((~v6 & 0x180000000000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x22E90);
    }
  }
}

uint64_t dispatch_workloop_set_qos_class_floor(uint64_t result, int a2, char a3, char a4)
{
  uint64_t v7;
  int v8;
  uint64_t v9;

  v7 = result;
  v9 = *(_QWORD *)(result + 56);
  if ((~v9 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x22FCCLL);
  }
  if (!*(_QWORD *)(result + 200))
  {
    result = _dispatch_calloc(1, 56);
    *(_QWORD *)(v7 + 200) = result;
  }
  switch(a2)
  {
    case 5:
      v8 = 1;
      break;
    case 9:
      v8 = 2;
      break;
    case 17:
      v8 = 3;
      break;
    case 21:
      v8 = 4;
      break;
    case 25:
      v8 = 5;
      break;
    case 33:
      v8 = 6;
      break;
    default:
      v8 = 0;
      break;
  }
  if (v8)
  {
    *(_DWORD *)(*(_QWORD *)(v7 + 200) + 4) = (a3 - 1) | ((v8 & 0xF) << 8);
    **(_DWORD **)(v7 + 200) |= 8u;
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(v7 + 200) + 4) = 0;
    **(_DWORD **)(v7 + 200) &= ~8u;
  }
  if ((a4 & 1) != 0)
  {
    *(_DWORD *)(*(_QWORD *)(v7 + 200) + 16) = 2;
    **(_DWORD **)(v7 + 200) |= 2u;
  }
  else
  {
    **(_DWORD **)(v7 + 200) &= ~2u;
  }
  return result;
}

uint64_t dispatch_set_qos_class(uint64_t result, int a2, char a3)
{
  int v3;
  int v4;
  uint64_t v5;

  if ((*(_QWORD *)(*(_QWORD *)result + 16) & 0xF0) != 0x10 || *(_BYTE *)(*(_QWORD *)result + 16) == 18)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class called on invalid object type";
    __break(1u);
    JUMPOUT(0x2326CLL);
  }
  switch(a2)
  {
    case 5:
      v4 = 1;
      break;
    case 9:
      v4 = 2;
      break;
    case 17:
      v4 = 3;
      break;
    case 21:
      v4 = 4;
      break;
    case 25:
      v4 = 5;
      break;
    case 33:
      v4 = 6;
      break;
    default:
      v4 = 0;
      break;
  }
  if (v4)
    v3 = (a3 - 1) | ((v4 & 0xF) << 8);
  else
    v3 = 0;
  *(_DWORD *)(result + 84) = v3 | *(_DWORD *)(result + 84) & 0xBFFFF000;
  v5 = *(_QWORD *)(result + 56);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x23430);
  }
  return result;
}

uint64_t dispatch_set_qos_class_fallback(uint64_t result, int a2)
{
  int v2;
  int v3;
  uint64_t v4;

  if ((*(_QWORD *)(*(_QWORD *)result + 16) & 0xF0) != 0x10)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_set_qos_class_fallback called on invalid object type";
    __break(1u);
    JUMPOUT(0x234FCLL);
  }
  switch(a2)
  {
    case 5:
      v3 = 1;
      break;
    case 9:
      v3 = 2;
      break;
    case 17:
      v3 = 3;
      break;
    case 21:
      v3 = 4;
      break;
    case 25:
      v3 = 5;
      break;
    case 33:
      v3 = 6;
      break;
    default:
      v3 = 0;
      break;
  }
  if (v3)
    v2 = ((v3 & 0xF) << 12) | 0x4000000;
  else
    v2 = 0;
  *(_DWORD *)(result + 84) = v2 | *(_DWORD *)(result + 84) & 0xFBFF0FFF;
  v4 = *(_QWORD *)(result + 56);
  if ((~v4 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x236B8);
  }
  return result;
}

dispatch_queue_t dispatch_queue_create_with_target_V2(const char *label, dispatch_queue_attr_t attr, dispatch_queue_t target)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target(label, (uint64_t *)attr, (uint64_t (***)())target, 0);
}

_QWORD *_dispatch_lane_create_with_target(const char *a1, uint64_t *a2, uint64_t (***a3)(), char a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v31;
  int v32;
  unsigned int v33;
  _QWORD *v34;
  const char *v35;
  int v36;
  uint64_t (**v37)();
  int v38;
  unsigned int v39;
  unsigned int v40;
  int v44;

  v40 = _dispatch_queue_attr_to_info(a2);
  v39 = v40;
  v38 = BYTE2(v40) & 3;
  if ((v40 & 0x30000) != 0 && a3 && a3[3])
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify both overcommit and a non-global target queue";
    qword_E4DA8 = (uint64_t)a3;
    __break(1u);
    JUMPOUT(0x23830);
  }
  if (a3 && (*a3)[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    if ((v40 & 0x30000) == 0)
    {
      if ((*((_BYTE *)a3 + 87) & 0x80) != 0)
        v38 = 1;
      else
        v38 = 2;
    }
    if (!(_BYTE)v40)
      v39 = (*((_DWORD *)a3 + 21) & 0xF00u) >> 8;
    a3 = 0;
  }
  else
  {
    if (a3 && (*((_BYTE *)a3 + 87) & 8) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x23948);
    }
    if (!a3 || a3[3])
    {
      if ((v40 & 0x30000) == 0)
      {
        if (((v40 >> 20) & 1) != 0)
          v10 = 2;
        else
          v10 = 1;
        v38 = v10;
      }
    }
    else if ((v40 & 0x30000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot specify an overcommit attribute and use this kind of target queue";
      qword_E4DA8 = (uint64_t)a3;
      __break(1u);
      JUMPOUT(0x239B4);
    }
  }
  if (!a3)
  {
    if (v39)
      v33 = v39;
    else
      v33 = 4;
    if (v33 > 6)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_E4DA8 = v33;
      __break(1u);
      JUMPOUT(0x23ABCLL);
    }
    v44 = 0;
    if (((2 * (v38 == 1)) & 2) != 0)
    {
      v44 = 1;
    }
    else if (((2 * (v38 == 1)) & 4) != 0)
    {
      v44 = 2;
    }
    a3 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v33 + v44 - 3)];
    if (!a3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue attribute";
      qword_E4DA8 = v39;
      __break(1u);
      JUMPOUT(0x23B74);
    }
  }
  if ((a4 & 1) != 0 && ((v40 & 0x200000) != 0 || ((v40 >> 18) & 3) != 0))
    a4 = 0;
  if ((a4 & 1) != 0)
    v11 = 0x400000;
  else
    v11 = 0;
  v36 = v11;
  if ((v40 & 0x100000) != 0)
    v37 = _OS_dispatch_queue_concurrent_vtable;
  else
    v37 = _OS_dispatch_queue_serial_vtable;
  v32 = (v40 >> 18) & 3;
  if (v32 == 1)
  {
    v36 = v11 | 0x10000;
  }
  else if (v32 == 2)
  {
    v36 = v11 | 0x20000;
  }
  if (a1)
  {
    v35 = _dispatch_strdup_if_mutable(a1);
    if (v35 != a1)
    {
      v36 |= 0x200000u;
      a1 = v35;
    }
  }
  v34 = _dispatch_object_alloc((uint64_t)v37, 0x78uLL, v4, v5, v6, v7, v8, v9);
  if (((v40 >> 21) & 1) != 0)
    v16 = 0x180000000000000;
  else
    v16 = 0;
  if (((v40 >> 20) & 1) != 0)
    v17 = 4094;
  else
    v17 = 1;
  _dispatch_queue_init((uint64_t)v34, v36, v17, v16, v12, v13, v14, v15);
  v34[9] = a1;
  if ((_BYTE)v40)
    v31 = (BYTE1(v40) - 1) | ((v40 & 0xF) << 8);
  else
    v31 = 0;
  *((_DWORD *)v34 + 21) = v31;
  if (v38 == 1)
    *((_DWORD *)v34 + 21) |= 0x80000000;
  if ((v40 & 0x200000) == 0)
  {
    _dispatch_queue_priority_inherit_from_target((uint64_t)v34, (unint64_t)a3);
    _dispatch_lane_inherit_wlh_from_target((uint64_t)v34, a3, v18, v19, v20, v21, v22, v23);
  }
  _dispatch_retain((uint64_t)a3);
  v34[3] = a3;
  _dispatch_object_debug((uint64_t)v34, "%s", v24, v25, v26, v27, v28, v29, (char)"_dispatch_lane_create_with_target");
  return v34;
}

dispatch_queue_t dispatch_queue_create(const char *label, dispatch_queue_attr_t attr)
{
  return (dispatch_queue_t)_dispatch_lane_create_with_target(label, (uint64_t *)attr, 0, 1);
}

void dispatch_queue_create_with_accounting_override_voucher()
{
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported interface";
  __break(1u);
}

uint64_t sub_23E94()
{
  uint64_t v1;

  return v1;
}

void _dispatch_lane_class_dispose(uint64_t a1, _BYTE *a2)
{
  uint64_t v2;
  unint64_t v3;
  uint64_t v4;

  if (*(_QWORD *)(a1 + 48))
  {
    v2 = *(_QWORD *)(a1 + 48);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue while items are enqueued";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x23F18);
  }
  *(_QWORD *)(a1 + 104) = 512;
  *(_QWORD *)(a1 + 48) = 512;
  v4 = *(_QWORD *)(a1 + 56);
  v3 = (unint64_t)(4096 - *(unsigned __int16 *)(a1 + 80)) << 41;
  if ((*(_BYTE *)(*(_QWORD *)a1 + 18) & 1) != 0)
    v3 = 0x60000000000000;
  if ((*(_QWORD *)(a1 + 56) & 0xFFFFFF48FFFFFFFFLL) != v3)
  {
    if ((*(_DWORD *)(a1 + 56) & 0xFFFFFFFC) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Premature release of a locked queue";
      qword_E4DA8 = v4;
      __break(1u);
      JUMPOUT(0x24040);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a queue with corrupt state";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x24084);
  }
  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_queue_dispose(uint64_t a1, _BYTE *a2)
{
  _QWORD *v2;
  _QWORD *v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v7;
  unint64_t *v8;
  _QWORD *v9;

  if (*(_QWORD *)(a1 + 72) && (*(_DWORD *)(a1 + 80) & 0x200000) != 0)
    free(*(void **)(a1 + 72));
  v8 = (unint64_t *)(a1 + 88);
  v9 = *(_QWORD **)(a1 + 88);
  do
  {
    v2 = v9;
    do
      v3 = (_QWORD *)__ldaxr(v8);
    while (v3 == v9 && __stlxr(0x200uLL, v8));
    v9 = v3;
  }
  while (v3 != v2);
  if (v3)
    _dispatch_queue_specific_head_dispose(v3);
  if (*(_DWORD *)(a1 + 96))
  {
    _dispatch_object_finalize();
    *a2 = 0;
    *(_QWORD *)(a1 + 72) = "<released queue, pending free>";
    *(_QWORD *)(a1 + 24) = 0;
    *(_QWORD *)(a1 + 40) = 0;
    *(_QWORD *)(a1 + 32) = 0;
    v6 = (unsigned int *)(a1 + 96);
    v7 = *(_DWORD *)(a1 + 96);
    do
    {
      v4 = v7;
      do
        v5 = __ldaxr(v6);
      while (v5 == v7 && __stlxr(v7 - 1, v6));
      v7 = v5;
    }
    while (v5 != v4);
    if (((v5 - 1) & 0x80000000) != 0)
    {
      if ((int)(v5 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x2439CLL);
      }
      *(_QWORD *)(a1 + 56) = 0xDEAD000000000000;
      _dispatch_object_dealloc((_QWORD *)a1);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 56) = 0xDEAD000000000000;
  }
}

void _dispatch_lane_dispose(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_lane_dispose");
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(772079624, *(_QWORD *)(a1 + 64), 0, 0, 0);
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_queue_xref_dispose(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;

  v5 = *(_QWORD *)(result + 56);
  if ((v5 & 0xFF80000000000000) != 0)
  {
    if ((v5 & 0x180000000000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of an inactive object";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x2456CLL);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a suspended object";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x245B0);
  }
  v3 = (unsigned int *)(result + 80);
  v4 = *(_DWORD *)(result + 80);
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 | 0x800000, v3));
    v4 = v2;
  }
  while (v2 != v1);
  return result;
}

uint64_t _dispatch_lane_suspend(uint64_t a1)
{
  unint64_t v1;
  uint64_t result;
  unint64_t *v3;
  _BOOL4 v4;
  unint64_t v5;
  unint64_t v6;

  v3 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v1 = __ldaxr(v3);
    else
      v1 = __ldxr(v3);
    v6 = v1;
    v5 = v1 + 0x400000000000000;
    if (v1 >= 0xFC00000000000000)
    {
      __clrex();
      return _dispatch_lane_suspend_slow(a1);
    }
    result = _os_atomic_mo_has_release(0);
    if ((_DWORD)result)
      v4 = __stlxr(v5, v3) == 0;
    else
      v4 = __stxr(v5, v3) == 0;
  }
  while (!v4);
  if ((v6 & 0xFF80000000000000) == 0)
    return _dispatch_retain_2(a1);
  return result;
}

uint64_t _dispatch_lane_suspend_slow(uint64_t a1)
{
  unsigned int v1;
  unint64_t v2;
  unsigned int v3;
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  unsigned int *v10;
  unsigned int v11;
  char v12;
  unsigned int *v13;
  unsigned int v14;
  unint64_t *v15;
  _BOOL4 v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v20;
  unsigned int *v21;
  unsigned int v22;
  BOOL v23;
  unsigned int v24;
  BOOL v25;

  v21 = (unsigned int *)(a1 + 100);
  v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    v1 = __ldaxr(v21);
  while (!v1 && __stlxr(v20, v21));
  if (v1)
    _dispatch_unfair_lock_lock_slow(v21, 0x10000);
  v17 = 0x7C00000000000000;
  if (!*(_DWORD *)(a1 + 112))
    v17 = 0x7A00000000000000;
  v15 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v2 = __ldaxr(v15);
    else
      v2 = __ldxr(v15);
    v18 = v2 - v17;
    if (v2 < v17)
    {
      __clrex();
      v24 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      v10 = (unsigned int *)(a1 + 100);
      v11 = *(_DWORD *)(a1 + 100);
      do
      {
        v7 = v11;
        do
          v8 = __ldaxr(v10);
        while (v8 == v11 && __stlxr(0, v10));
        v9 = v8;
        v11 = v8;
      }
      while (v8 != v7);
      if (v8 == v24)
      {
        v25 = 0;
      }
      else
      {
        _dispatch_unfair_lock_unlock_slow(a1 + 100, v8);
        v25 = (v9 & 2) != 0;
      }
      if (v25)
      {
        v22 = _dispatch_thread_getspecific(0x19uLL);
        if (!((v22 & 0xF0000) >> 16))
          _dispatch_thread_setspecific(25, v22 & 0xFFF0FFFF | 0x10000);
      }
      return _dispatch_lane_suspend(a1);
    }
    if (_os_atomic_mo_has_release(0))
      v16 = __stlxr(v18, v15) == 0;
    else
      v16 = __stxr(v18, v15) == 0;
  }
  while (!v16);
  v3 = *(_DWORD *)(a1 + 112);
  *(_DWORD *)(a1 + 112) = v3 + 32;
  if (v3 >= 0xFFFFFFE0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many nested calls to dispatch_suspend()";
    __break(1u);
    JUMPOUT(0x24A88);
  }
  result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  v13 = (unsigned int *)(a1 + 100);
  v14 = *(_DWORD *)(a1 + 100);
  do
  {
    v5 = v14;
    do
      v6 = __ldaxr(v13);
    while (v6 == v14 && __stlxr(0, v13));
    v12 = v6;
    v14 = v6;
  }
  while (v6 != v5);
  if (v6 == (result & 0xFFFFFFFC))
  {
    v23 = 0;
  }
  else
  {
    result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v6);
    v23 = (v12 & 2) != 0;
  }
  if (v23)
  {
    result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
    if (!((result & 0xF0000) >> 16))
      return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
  }
  return result;
}

void _dispatch_lane_resume(unsigned __int16 *a1, int a2)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unsigned int v5;
  unint64_t *v6;
  _BOOL4 v7;
  unint64_t *v8;
  _BOOL4 v9;
  unint64_t *v10;
  _BOOL4 v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  BOOL v16;
  unint64_t v17;
  unint64_t v18;

  v18 = (unint64_t)(a1[40] - 1) << 41;
  v17 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
  v16 = *(_BYTE *)(*(_QWORD *)a1 + 16) == 19;
  if (a2 == 1)
  {
    v10 = (unint64_t *)(a1 + 28);
    while (1)
    {
      v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v10) : __ldxr(v10);
      v15 = v2;
      if ((~v2 & 0x180000000000000) != 0)
        break;
      if (v2 >> 58)
        v12 = v2 - 0x80000000000000;
      else
        v12 = v2 - 0x100000000000000;
      if (_os_atomic_mo_has_release(0))
        v11 = __stlxr(v12, v10) == 0;
      else
        v11 = __stxr(v12, v10) == 0;
      if (v11)
        goto LABEL_60;
    }
    __clrex();
  }
  else
  {
    if (a2 != 2)
    {
      v6 = (unint64_t *)(a1 + 28);
      while (1)
      {
        if (_os_atomic_mo_has_acquire(3))
          v4 = __ldaxr(v6);
        else
          v4 = __ldxr(v6);
        v15 = v4;
        if (v16 && v4 >> 55 == 3)
        {
          v12 = v4 - 0x100000000000000;
        }
        else
        {
          v14 = v4 - 0x400000000000000;
          if (v4 < 0x400000000000000)
          {
            __clrex();
            if ((v4 & 0x200000000000000) == 0)
            {
              if ((~v4 & 0x180000000000000) == 0)
              {
                qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an inactive object";
                qword_E4DA8 = (uint64_t)a1;
                __break(1u);
                JUMPOUT(0x255FCLL);
              }
              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Over-resume of an object";
              qword_E4DA8 = (uint64_t)a1;
              __break(1u);
              JUMPOUT(0x25640);
            }
            _dispatch_lane_resume_slow((uint64_t)a1);
            return;
          }
          if ((v14 & 0x180000000000000) == 0x100000000000000)
          {
            v12 = v4 - 0x480000000000000;
          }
          else if (v14 >> 53)
          {
            v12 = v14 | 0x8000000000;
          }
          else if ((v4 & 0xFFFFFFFC) != 0)
          {
            v12 = v14 | 0x8000000000;
          }
          else if (v16 || (v14 & 0x10000000000) == 0 && (v14 + v18) >> 53)
          {
            v12 = v14 & 0xFFFFFFF000000001;
          }
          else
          {
            v12 = v14 & 0x7700000001 | v17;
          }
        }
        if (_os_atomic_mo_has_release(3))
          v7 = __stlxr(v12, v6) == 0;
        else
          v7 = __stxr(v12, v6) == 0;
        if (v7)
          goto LABEL_60;
      }
    }
    v8 = (unint64_t *)(a1 + 28);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v3 = __ldaxr(v8);
      else
        v3 = __ldxr(v8);
      v15 = v3;
      if ((v3 & 0x180000000000000) == 0)
      {
        __clrex();
        _dispatch_release_2_tailcall((unsigned int *)a1);
        return;
      }
      v13 = v3 - 0x80000000000000;
      if ((v3 - 0x80000000000000) >> 53)
      {
        v12 = v13 | 0x8000000000;
      }
      else if ((v3 & 0xFFFFFFFC) != 0)
      {
        v12 = v13 | 0x8000000000;
      }
      else
      {
        v12 = v13 & 0xFFFFFFF000000001;
      }
      if (_os_atomic_mo_has_release(3))
        v9 = __stlxr(v12, v8) == 0;
      else
        v9 = __stxr(v12, v8) == 0;
    }
    while (!v9);
    if ((v12 & 0x180000000000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt activation state";
      qword_E4DA8 = (uint64_t)a1;
      __break(1u);
      JUMPOUT(0x251C8);
    }
LABEL_60:
    if ((v12 & 0x180000000000000) == 0x80000000000000)
    {
      _dispatch_lane_resume_activate((uint64_t)a1);
      return;
    }
    if ((v12 & 0xFF80000000000000) == 0)
    {
      v5 = 1;
      if (((v15 ^ v12) & 0x40000000000000) != 0)
      {
        v5 = 5;
      }
      else if (v12 >> 53)
      {
        if ((v15 & 0x2000000000) != 0)
          _dispatch_event_loop_assert_not_owned((uint64_t)a1);
        _dispatch_release_2((unsigned int *)a1);
        return;
      }
      (*(void (**)(unsigned __int16 *, unint64_t, _QWORD))(*(_QWORD *)a1 + 64))(a1, (v15 & 0x700000000) >> 32, v5);
    }
  }
}

void _dispatch_release_2_tailcall(unsigned int *a1)
{
  _os_object_release_internal_n(a1, 2u);
}

uint64_t _dispatch_lane_resume_slow(uint64_t a1)
{
  unsigned int v1;
  unint64_t v2;
  BOOL v3;
  uint64_t result;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  char v9;
  unsigned int *v10;
  unsigned int v11;
  char v12;
  unsigned int *v13;
  unsigned int v14;
  int v15;
  unint64_t *v16;
  _BOOL4 v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  BOOL v25;
  unsigned int v26;
  BOOL v27;

  v23 = (unsigned int *)(a1 + 100);
  v22 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    v1 = __ldaxr(v23);
  while (!v1 && __stlxr(v22, v23));
  if (v1)
    _dispatch_unfair_lock_lock_slow(v23, 0x10000);
  v18 = 0x7C00000000000000;
  v15 = *(_DWORD *)(a1 + 112);
  if (v15)
  {
    if (v15 == 32)
      v18 = 0x7A00000000000000;
    v16 = (unint64_t *)(a1 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v2 = __ldaxr(v16);
      else
        v2 = __ldxr(v16);
      v20 = v2;
      v3 = __CFADD__(v2, v18);
      v19 = v20 + v18;
      if (v3)
      {
        __clrex();
        goto LABEL_36;
      }
      if (_os_atomic_mo_has_release(0))
        v17 = __stlxr(v19, v16) == 0;
      else
        v17 = __stxr(v19, v16) == 0;
    }
    while (!v17);
    *(_DWORD *)(a1 + 112) -= 32;
    result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    v13 = (unsigned int *)(a1 + 100);
    v14 = *(_DWORD *)(a1 + 100);
    do
    {
      v5 = v14;
      do
        v6 = __ldaxr(v13);
      while (v6 == v14 && __stlxr(0, v13));
      v12 = v6;
      v14 = v6;
    }
    while (v6 != v5);
    if (v6 == (result & 0xFFFFFFFC))
    {
      v25 = 0;
    }
    else
    {
      result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v6);
      v25 = (v12 & 2) != 0;
    }
    if (v25)
    {
      result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      if (!((result & 0xF0000) >> 16))
        return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
    }
  }
  else
  {
LABEL_36:
    v26 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v10 = (unsigned int *)(a1 + 100);
    v11 = *(_DWORD *)(a1 + 100);
    do
    {
      v7 = v11;
      do
        v8 = __ldaxr(v10);
      while (v8 == v11 && __stlxr(0, v10));
      v9 = v8;
      v11 = v8;
    }
    while (v8 != v7);
    if (v8 == v26)
    {
      v27 = 0;
    }
    else
    {
      _dispatch_unfair_lock_unlock_slow(a1 + 100, v8);
      v27 = (v9 & 2) != 0;
    }
    if (v27)
    {
      v24 = _dispatch_thread_getspecific(0x19uLL);
      if (!((v24 & 0xF0000) >> 16))
        _dispatch_thread_setspecific(25, v24 & 0xFFF0FFFF | 0x10000);
    }
    return _dispatch_lane_resume(a1, 0);
  }
  return result;
}

uint64_t _dispatch_lane_resume_activate(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)a1 + 56))
    (*(void (**)(uint64_t))(*(_QWORD *)a1 + 56))(a1);
  return _dispatch_lane_resume(a1, 2);
}

const char *__cdecl dispatch_queue_get_label(dispatch_queue_t queue)
{
  uint64_t (***v3)();
  uint64_t (***v4)();
  dispatch_queue_t v5;

  v5 = queue;
  if (!queue)
  {
    v4 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
    if (v4)
      v3 = v4;
    else
      v3 = &off_E46C0;
    v5 = (dispatch_queue_t)v3;
  }
  if (*((_QWORD *)v5 + 9))
    return (const char *)*((_QWORD *)v5 + 9);
  else
    return "";
}

dispatch_qos_class_t dispatch_queue_get_qos_class(dispatch_queue_t queue, int *relative_priority_ptr)
{
  unint64_t v3;
  int v4;
  unsigned int v5;
  int v6;
  int v7;

  v5 = (*((_DWORD *)queue + 21) & 0xF00u) >> 8;
  if (relative_priority_ptr)
  {
    if (v5)
    {
      v6 = *((_DWORD *)queue + 21);
      if ((v6 & 0xF00) != 0)
        v7 = (char)v6 + 1;
      else
        v7 = 0;
      v4 = v7;
    }
    else
    {
      v4 = 0;
    }
    *relative_priority_ptr = v4;
  }
  v3 = v5 - 1;
  if (v3 <= 5)
    __asm { BR              X8 }
  return 0;
}

uint64_t dispatch_queue_set_width(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = *(_QWORD *)(*(_QWORD *)a1 + 16);
  if (*(_BYTE *)(*(_QWORD *)a1 + 16) != 17)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x25FE0);
  }
  if (v3 != 529)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot set width of a serial queue";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x26034);
  }
  if ((a2 & 0x80000000) != 0)
    return _dispatch_barrier_async_detached_f(a1, a2, (uint64_t)_dispatch_lane_set_width);
  else
    return _dispatch_barrier_trysync_or_async_f(a1, a2, (uint64_t (*)(uint64_t))_dispatch_lane_set_width, 1u);
}

void _dispatch_lane_set_width(int a1)
{
  void *v1;
  unsigned int v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t v20;
  int v21;
  unsigned int *v22;
  _BOOL4 v23;
  unsigned int v24;
  char *v25;
  unsigned int v26;
  int v28;
  int v29;
  int v30;
  unsigned int v31;
  int v32;
  int v33;

  v25 = (char *)_dispatch_thread_getspecific(0x14uLL);
  if (a1 >= 0)
  {
    if (a1)
      v21 = a1;
    else
      v21 = 1;
    v26 = v21;
    goto LABEL_38;
  }
  v1 = _dispatch_thread_getspecific(4uLL);
  v2 = 0;
  v3 = (v1 & 0x3FFF00) >> 8;
  v4 = __clz(__rbit32(v3));
  if (v3)
    v2 = v4 + 1;
  switch(a1)
  {
    case -3:
      goto LABEL_30;
    case -2:
      v32 = 0;
      if (v2)
      {
        v20 = v2 - 1;
        if (v20 <= 5)
          __asm { BR              X8 }
        v32 = pthread_qos_max_parallelism(0, 1);
      }
      if (v32 <= 0)
        v33 = MEMORY[0xFFFFFC035];
      else
        v33 = v32;
      v26 = v33;
      break;
    case -1:
      v30 = 0;
      if (v2)
      {
        v19 = v2 - 1;
        if (v19 <= 5)
          __asm { BR              X8 }
        v30 = pthread_qos_max_parallelism(0, 0);
      }
      if (v30 <= 0)
        v31 = MEMORY[0xFFFFFC036];
      else
        v31 = v30;
      if (MEMORY[0xFFFFFC034] < v31)
        v31 = MEMORY[0xFFFFFC034];
      v26 = v31;
      break;
    default:
LABEL_30:
      v28 = 0;
      if (v2)
      {
        v18 = v2 - 1;
        if (v18 <= 5)
          __asm { BR              X8 }
        v28 = pthread_qos_max_parallelism(0, 0);
      }
      if (v28 <= 0)
        v29 = MEMORY[0xFFFFFC036];
      else
        v29 = v28;
      v26 = v29;
      break;
  }
LABEL_38:
  if (v26 > 0xFFEuLL)
    LOWORD(v26) = 4094;
  v22 = (unsigned int *)(v25 + 80);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v5 = __ldaxr(v22);
    else
      v5 = __ldxr(v22);
    v24 = v5 & 0xFFFF0000 | (unsigned __int16)v26;
    if (_os_atomic_mo_has_release(0))
      v23 = __stlxr(v24, v22) == 0;
    else
      v23 = __stxr(v24, v22) == 0;
  }
  while (!v23);
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v25, *((_DWORD **)v25 + 3), v6, v7, v8, v9, v10, v11);
  _dispatch_object_debug((uint64_t)v25, "%s", v12, v13, v14, v15, v16, v17, (char)"_dispatch_lane_set_width");
}

void _dispatch_lane_set_target_queue(uint64_t a1, uint64_t (***a2)())
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int *v10;
  unsigned int *v11;
  unint64_t *v12;
  unsigned int *v13;
  int v14;
  uint64_t v15;
  uint64_t (***v16)();
  unint64_t *v18;
  _BOOL4 v19;
  unint64_t v20;
  __int16 v21;
  char v22;

  v16 = a2;
  if (!a2)
    v16 = &(&_dispatch_root_queues)[16 * (unint64_t)((*(_WORD *)(a1 + 80) == 1) + 9)];
  v18 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v9 = __ldaxr(v18);
    else
      v9 = __ldxr(v18);
    v21 = HIWORD(v9);
    if ((~v9 & 0x180000000000000) != 0)
    {
      __clrex();
      v22 = 0;
      goto LABEL_18;
    }
    v20 = v9 + 0x400000000000000;
    if (_os_atomic_mo_has_release(0))
      v19 = __stlxr(v20, v18) == 0;
    else
      v19 = __stxr(v20, v18) == 0;
  }
  while (!v19);
  LOBYTE(v14) = 1;
  if ((v21 & 0xFF80) != 0)
    v14 = (HIBYTE(v21) >> 1) & 1;
  if ((v14 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x2734CLL);
  }
  v22 = 1;
LABEL_18:
  if (v22 == 1)
  {
    _dispatch_retain((uint64_t)v16);
    v12 = (unint64_t *)(a1 + 24);
    v13 = *(unsigned int **)(a1 + 24);
    do
    {
      v10 = v13;
      do
        v11 = (unsigned int *)__ldaxr(v12);
      while (v11 == v13 && __stlxr((unint64_t)v16, v12));
      v13 = v11;
    }
    while (v11 != v10);
    if (v11)
      _dispatch_release(v11);
    _dispatch_lane_resume((unsigned __int16 *)a1, 0);
  }
  else
  {
    if (((BYTE2(*(_DWORD *)(a1 + 80)) >> 6) & 1) == 0)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of a queue already targeted by oth"
                               "er dispatch objects";
        __break(1u);
        JUMPOUT(0x27510);
      }
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
      __break(1u);
      JUMPOUT(0x2753CLL);
    }
    v15 = *(unsigned __int8 *)(*(_QWORD *)a1 + 16);
    if (v15 == 17)
    {
      if ((*(_DWORD *)(a1 + 80) & 0x100000) != 0)
        _dispatch_bug_deprecated((uint64_t)"Changing the target of a queue already targeted by other dispatch objects", v2, v3, v4, v5, v6, v7, v8);
    }
    else
    {
      if (*(_BYTE *)(*(_QWORD *)a1 + 16) != 19)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected dispatch object type";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x2768CLL);
      }
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771883016, a1, 0, 0, 0);
      _dispatch_bug_deprecated((uint64_t)"Changing the target of a source after it has been activated", v2, v3, v4, v5, v6, v7, v8);
    }
    _dispatch_retain((uint64_t)v16);
    _dispatch_barrier_trysync_or_async_f(a1, (uint64_t)v16, (uint64_t (*)(uint64_t))_dispatch_lane_legacy_set_target_queue, 1u);
  }
}

void _dispatch_lane_legacy_set_target_queue(unint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int *v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  char v24;
  unsigned int *v25;
  unsigned int v26;
  unsigned int *v27;
  uint64_t (***v28)();
  char *v29;
  unsigned int v31;
  unsigned int v32;
  unsigned int v33;
  BOOL v34;

  v29 = (char *)_dispatch_thread_getspecific(0x14uLL);
  v27 = (unsigned int *)*((_QWORD *)v29 + 3);
  if ((*((_DWORD *)v29 + 20) & 0x100000) != 0)
  {
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771883012, v29, v27, a1, 0);
    _dispatch_bug_deprecated((uint64_t)"Changing the target of a queue already targeted by other dispatch objects", v1, v2, v3, v4, v5, v6, v7);
  }
  v28 = _dispatch_queue_priority_inherit_from_target((uint64_t)v29, a1);
  _dispatch_lane_inherit_wlh_from_target((uint64_t)v29, v28, v8, v9, v10, v11, v12, v13);
  v31 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v14 = (unsigned int *)(v29 + 100);
  do
    v15 = __ldaxr(v14);
  while (!v15 && __stlxr(v31, v14));
  if (v15)
    _dispatch_unfair_lock_lock_slow((unsigned int *)v29 + 25, 0x10000);
  if (((BYTE2(*((_DWORD *)v29 + 20)) >> 6) & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change the target of this object after it has been activated";
    __break(1u);
    JUMPOUT(0x27988);
  }
  *((_QWORD *)v29 + 3) = v28;
  v33 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v25 = (unsigned int *)(v29 + 100);
  v26 = *((_DWORD *)v29 + 25);
  do
  {
    v22 = v26;
    do
      v23 = __ldaxr(v25);
    while (v23 == v26 && __stlxr(0, v25));
    v24 = v23;
    v26 = v23;
  }
  while (v23 != v22);
  if (v23 == v33)
  {
    v34 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)(v29 + 100), v23);
    v34 = (v24 & 2) != 0;
  }
  if (v34)
  {
    v32 = _dispatch_thread_getspecific(0x19uLL);
    if (!((v32 & 0xF0000) >> 16))
      _dispatch_thread_setspecific(25, v32 & 0xFFF0FFFF | 0x10000);
  }
  _dispatch_object_debug((uint64_t)v29, "%s", v16, v17, v18, v19, v20, v21, (char)"_dispatch_lane_legacy_set_target_queue");
  _dispatch_release_tailcall(v27);
}

void _dispatch_poll_for_events_4launchd()
{
  _dispatch_return_to_kernel();
}

void _dispatch_return_to_kernel()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  BOOL v6;
  _QWORD *v7;

  v7 = _dispatch_thread_getspecific(0x1DuLL);
  v6 = 0;
  if (v7)
    v6 = v7[3] != -4;
  if (v6)
  {
    if ((*((_BYTE *)v7 + 45) & 4) == 0)
      _dispatch_abort(3612, (*((_BYTE *)v7 + 45) & 4) != 0, v0, v1, v2, v3, v4, v5);
    _dispatch_event_loop_drain(1u);
  }
  else
  {
    _dispatch_thread_setspecific(5, 0);
  }
}

BOOL dispatch_swift_job_should_yield()
{
  return _dispatch_thread_getspecific(0x78uLL) != 0;
}

uint64_t _dispatch_lane_serial_drain(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL4 v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v34;
  char v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  __int128 v46;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BOOL8 v57;
  uint64_t v58;
  unint64_t v59;
  unsigned int *v60;
  unint64_t v61;
  _QWORD *v62;
  _QWORD *v64;
  int v66;
  int v67;
  int v68;
  int v69;
  _DWORD *v70;
  BOOL v71;
  _BOOL4 v72;
  unint64_t *v73;
  _BOOL4 v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  BOOL v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  _BOOL4 v106;
  BOOL v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _BOOL4 v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  _QWORD *v132;
  _BOOL4 v133;
  BOOL v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  _BOOL4 v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  _QWORD *v147;
  _QWORD *v148;
  uint64_t v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  __int128 *v153;
  uint64_t v154;
  __int128 *v155;
  __int128 *v156;
  __int128 *v157;
  __int128 *v158;
  void *v159;
  uint64_t v160;
  _BOOL4 v161;
  unint64_t *v162;
  _BOOL4 v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  unint64_t v170;
  _DWORD *v171;
  char v172;
  _QWORD *v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  _QWORD *v185;
  unint64_t v186;
  unsigned __int16 v187;
  _QWORD *v188;
  uint64_t v189;
  uint64_t v190;
  int v191;
  int v192;
  int v193;
  int v194;
  _DWORD *v195;
  BOOL v196;
  _QWORD *v197;

  v52 = a1;
  v51 = a2;
  v50 = a3 & 0xFFFDFFFF;
  v49 = a4;
  v48 = 1;
  v47 = 0;
  v47 = *(_QWORD *)(a1 + 24);
  v46 = 0uLL;
  v42 = *a4;
  if (!*(_QWORD *)(a1 + 48))
    return 0;
  v154 = v52;
  v153 = &v46;
  v158 = &v46;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v46, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v154, 21, (uint64_t)v153, v8, v9, v10, v11);
  if ((v48 & 1) != 0 || (v54 = v42, (v42 & 0x40000000000000) != 0))
    v43 = 0x40000000000000;
  else
    v43 = v42 & 0x3FFE0000000000;
  v95 = v52;
  v94 = (unint64_t *)(v52 + 104);
  v93 = 0;
  v92 = 0;
  v91 = *(_QWORD *)(v52 + 104);
  v92 = v91;
  v90 = v91;
  v93 = v91;
  if (!v91)
    v93 = _dispatch_wait_for_enqueuer(v94, v95 + 48);
  v89 = v93;
  v45 = (_QWORD *)v93;
  while (1)
  {
    v55 = *(_QWORD *)(v52 + 56);
    if ((v55 & 0xFF80000000000000) != 0 || v47 != *(_QWORD *)(v52 + 24))
      break;
    if ((v48 & 1) != 0)
      goto LABEL_35;
    v70 = v45;
    v69 = 0;
    v150 = v45;
    if (*v45 > 0xFFFuLL)
    {
      if ((*(_QWORD *)(*(_QWORD *)v70 + 16) & 0xF0) == 0x10)
      {
        v68 = 0;
        v67 = v70[20];
        v68 = v67;
        v66 = v67;
        v69 = v67;
        v71 = (v67 & 0x80000) != 0;
      }
      else
      {
        v71 = 0;
      }
    }
    else
    {
      v71 = (*v70 & 2) != 0;
    }
    if (v71)
    {
LABEL_35:
      if ((v48 & 1) == 0 && v43 != 0x40000000000000)
      {
        v168 = v52;
        v167 = v43;
        v166 = 0;
        v165 = 0;
        v164 = 0;
        v164 = ((unint64_t)(*(unsigned __int16 *)(v52 + 80) - 1) << 41) | 0x10000000000;
        v163 = 0;
        v162 = (unint64_t *)(v52 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2))
            v19 = __ldaxr(v162);
          else
            v19 = __ldxr(v162);
          v166 = v19;
          v165 = v19 - v167;
          v170 = v19;
          if ((v19 & 0x10000000000) == 0)
            v165 += v164;
          v169 = v165;
          if (!(v165 >> 53))
          {
            v165 += 0x20000000000;
            v165 += 0x40000000000000;
            v165 -= 0x10000000000;
          }
          v165 &= ~0x8000000000uLL;
          if (_os_atomic_mo_has_release(2))
            v163 = __stlxr(v165, v162) == 0;
          else
            v163 = __stxr(v165, v162) == 0;
        }
        while (!v163);
        v161 = v163;
        if ((v165 & 0x40000000000000) == 0)
          goto LABEL_138;
        v43 = 0x40000000000000;
      }
      v171 = v45;
      v173 = v45;
      if (*v45 >= 0x1000uLL)
        v172 = 0;
      else
        v172 = *v171 & 1;
      if (v172 == 1 && (v50 & 0x80000) == 0)
      {
        *(_QWORD *)(v51 + 8) = v45;
        if ((v50 & 8) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x28F3CLL);
        }
        v155 = &v46;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
        return *(_QWORD *)(v52 + 24);
      }
      v122 = v52;
      v121 = v45;
      v120 = v45;
      v119 = 0;
      v118 = 0;
      v117 = v45[2];
      v118 = v117;
      v116 = v117;
      v119 = v117;
      v115 = v117;
      v114 = v117;
      *(_QWORD *)(v52 + 104) = v117;
      v113 = v115;
      v40 = 0;
      if (!v119)
      {
        v112 = (unint64_t)v120;
        v111 = 0;
        v20 = (unint64_t *)(v122 + 48);
        v109 = 0;
        v108 = 0;
        v110 = 0;
        v21 = v120;
        do
          v22 = __ldaxr(v20);
        while ((_QWORD *)v22 == v21 && __stlxr(0, v20));
        if ((_QWORD *)v22 != v21)
          v112 = v22;
        v107 = v22 == (_QWORD)v21;
        v111 = v22 == (_QWORD)v21;
        v106 = v111;
        v40 = v22 != (_QWORD)v21;
      }
      if (v40)
      {
        v105 = v120;
        v104 = 0;
        v103 = 0;
        v102 = v120[2];
        v103 = v102;
        v101 = v102;
        v104 = v102;
        if (!v102)
          v104 = _dispatch_wait_for_enqueuer(v105 + 2, v122 + 48);
        v100 = v104;
        v119 = v104;
        v99 = v104;
        v98 = v104;
        *(_QWORD *)(v122 + 104) = v104;
        v97 = v99;
      }
      v96 = v119;
      v44 = (_QWORD *)v119;
LABEL_121:
      _dispatch_continuation_pop_inline(v45, v51, v50, v52);
      goto LABEL_10;
    }
    if (v43 == 0x40000000000000)
    {
      v38 = (unint64_t *)(v52 + 56);
      v39 = *(_QWORD *)(v52 + 56);
      do
      {
        v23 = v39;
        do
          v24 = __ldaxr(v38);
        while (v24 == v39 && __stlxr(v39 ^ 0x40000000000000, v38));
        v39 = v24;
      }
      while (v24 != v23);
      v43 = (unint64_t)*(unsigned __int16 *)(v52 + 80) << 41;
    }
    else if (!v43)
    {
      v62 = v45;
      v152 = v45;
      if (*v45 < 0x1000uLL && (*v62 & 0x81) != 0)
      {
        v184 = v52;
        v182 = 0x20000000000;
        v181 = 0x20000000000;
        v183 = 0x20000000000;
        v179 = 0;
        v177 = 0x20000000000;
        v176 = 0x20000000000;
        v178 = 0x20000000000;
        v36 = (unint64_t *)(v52 + 56);
        v37 = *(_QWORD *)(v52 + 56);
        do
        {
          v25 = v37;
          do
            v26 = __ldaxr(v36);
          while (v26 == v37 && __stlxr(v37 + 0x20000000000, v36));
          v37 = v26;
        }
        while (v26 != v25);
        v175 = v26;
        v179 = v26;
        v174 = v26;
        v180 = v26 + v183;
      }
      else
      {
        v77 = v52;
        v76 = 0;
        v75 = 0;
        v74 = 0;
        v73 = (unint64_t *)(v52 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2))
            v27 = __ldaxr(v73);
          else
            v27 = __ldxr(v73);
          v76 = v27;
          v79 = v27;
          v35 = 1;
          if (!(v27 >> 53))
          {
            v81 = v76;
            v35 = 1;
            if ((v76 & 0x8000000000) == 0)
            {
              v80 = v76;
              v35 = BYTE5(v76) & 1;
            }
          }
          if ((v35 & 1) != 0)
          {
            __clrex();
            v78 = 0;
            goto LABEL_101;
          }
          v75 = v76 + 0x20000000000;
          if (_os_atomic_mo_has_release(2))
            v74 = __stlxr(v75, v73) == 0;
          else
            v74 = __stxr(v75, v73) == 0;
        }
        while (!v74);
        v72 = v74;
        v78 = v74;
LABEL_101:
        if (!v78)
        {
LABEL_138:
          *v49 &= 0x4000000001uLL;
          v156 = &v46;
          _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
          return -1;
        }
      }
      v43 = 0x20000000000;
    }
    v149 = v52;
    v148 = v45;
    v147 = v45;
    v146 = 0;
    v145 = 0;
    v144 = v45[2];
    v145 = v144;
    v143 = v144;
    v146 = v144;
    v142 = v144;
    v141 = v144;
    *(_QWORD *)(v52 + 104) = v144;
    v140 = v142;
    v34 = 0;
    if (!v146)
    {
      v139 = (unint64_t)v147;
      v138 = 0;
      v28 = (unint64_t *)(v149 + 48);
      v136 = 0;
      v135 = 0;
      v137 = 0;
      v29 = v147;
      do
        v30 = __ldaxr(v28);
      while ((_QWORD *)v30 == v29 && __stlxr(0, v28));
      if ((_QWORD *)v30 != v29)
        v139 = v30;
      v134 = v30 == (_QWORD)v29;
      v138 = v30 == (_QWORD)v29;
      v133 = v138;
      v34 = v30 != (_QWORD)v29;
    }
    if (v34)
    {
      v132 = v147;
      v131 = 0;
      v130 = 0;
      v129 = v147[2];
      v130 = v129;
      v128 = v129;
      v131 = v129;
      if (!v129)
        v131 = _dispatch_wait_for_enqueuer(v132 + 2, v149 + 48);
      v127 = v131;
      v146 = v131;
      v126 = v131;
      v125 = v131;
      *(_QWORD *)(v149 + 104) = v131;
      v124 = v126;
    }
    v123 = v146;
    v44 = (_QWORD *)v146;
    v64 = v45;
    v151 = v45;
    if (*v45 < 0x1000uLL && (*v64 & 0x81) != 0)
    {
      v43 -= 0x20000000000;
      _dispatch_non_barrier_waiter_redirect_or_wake(v52, (uint64_t)v45, v12, v13, v14, v15, v16, v17);
    }
    else
    {
      if ((v50 & 0x20000) == 0)
        goto LABEL_121;
      v43 -= 0x20000000000;
      v58 = v52;
      v59 = (unint64_t)*(unsigned int *)(v52 + 60) << 32;
      v59 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push(v52, v45, HIDWORD(v59));
    }
LABEL_10:
    v18 = *(_QWORD *)(v51 + 8) == 0;
    v57 = *(_QWORD *)(v51 + 8) == 0;
    v56 = 3803;
    if (!v18)
      _dispatch_abort(v56, v57, v31, v13, v14, v15, v16, v17);
    v45 = v44;
    if (!v44)
    {
      if (!*(_QWORD *)(v52 + 48))
        break;
      v88 = v52;
      v87 = (unint64_t *)(v52 + 104);
      v86 = 0;
      v85 = 0;
      v84 = *(_QWORD *)(v52 + 104);
      v85 = v84;
      v83 = v84;
      v86 = v84;
      if (!v84)
        v86 = _dispatch_wait_for_enqueuer(v87, v88 + 48);
      v82 = v86;
      v45 = (_QWORD *)v86;
    }
    if (_dispatch_thread_getspecific(5uLL))
      _dispatch_return_to_kernel();
    if ((v48 & 1) == (*(_WORD *)(v52 + 80) == 1))
    {
      v41 = 0;
      if ((v50 & 0x4000000) == 0)
      {
        v160 = v51;
        v159 = 0;
        v159 = _dispatch_thread_getspecific(0x78uLL);
        v41 = v159 & 1;
      }
      if ((v41 & 1) == 0)
      {
        if ((v50 & 0x100000) == 0)
          continue;
        v60 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        v61 = (unint64_t)v60[15] << 32;
        v61 &= 0x700000000uLL;
        if (HIDWORD(v61) <= *((unsigned __int8 *)v60 + 100))
          continue;
      }
    }
    break;
  }
  if (v43 == 0x40000000000000)
    v43 = ((unint64_t)*(unsigned __int16 *)(v52 + 80) << 41) + 0x40000000000000;
  if (v45)
  {
    v190 = v52;
    v189 = v43;
    v188 = v45;
    v187 = 0;
    v187 = *(_WORD *)(v52 + 80);
    v186 = 0;
    if (v187 >= 2u)
    {
      v185 = v188;
      v195 = v188;
      v194 = 0;
      v197 = v188;
      if (*v188 > 0xFFFuLL)
      {
        if ((*(_QWORD *)(*(_QWORD *)v195 + 16) & 0xF0) == 0x10)
        {
          v193 = 0;
          v192 = v195[20];
          v193 = v192;
          v191 = v192;
          v194 = v192;
          v196 = (v192 & 0x80000) != 0;
        }
        else
        {
          v196 = 0;
        }
      }
      else
      {
        v196 = (*v195 & 2) != 0;
      }
      if (v196)
      {
        v186 = ((unint64_t)(v187 - 1) << 41) + 0x10000000000;
        v189 -= v186;
      }
    }
    v43 = v189;
  }
  *v49 &= 0x4000000001uLL;
  *v49 |= v43;
  v157 = &v46;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
  if (v45)
    return *(_QWORD *)(v52 + 24);
  else
    return 0;
}

void _dispatch_queue_invoke_finish(unsigned int *a1, uint64_t a2, uint64_t (***a3)(), uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  unint64_t *v12;
  _BOOL4 v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v21;
  unsigned int v24;

  v19 = *(_QWORD *)(a2 + 8);
  v18 = *(_DWORD *)(a2 + 16);
  if (v19)
  {
    *(_BYTE *)(v19 + 106) = *(_BYTE *)(v19 + 106) & 0x7F | 0x80;
    *(_QWORD *)(a2 + 8) = 0;
    *(_DWORD *)(a2 + 16) = 0;
    v21 = a4 & 0x4000000001;
    if (v18)
      _dispatch_workloop_drain_barrier_waiter((uint64_t)a1, v19, v18, 1u, v21);
    else
      _dispatch_lane_drain_barrier_waiter((uint64_t)a1, v19, 1u, v21);
  }
  else
  {
    v14 = 1;
    if (a3 == &_dispatch_mgr_q)
      v14 = 0x4000000000;
    v12 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v4 = __ldaxr(v12);
      else
        v4 = __ldxr(v12);
      v16 = v4;
      v15 = (v4 - a4) & 0xFFFFFF7700000001 | 0x8000000000;
      if (v15 < 0x20000000000000 && ((v4 - a4) & 0x4000000001) == 0)
        v15 |= v14;
      if (_os_atomic_mo_has_release(3))
        v13 = __stlxr(v15, v12) == 0;
      else
        v13 = __stxr(v15, v12) == 0;
    }
    while (!v13);
    v17 = v16 - a4;
    v11 = 0;
    if ((v17 & 0x1000000000) != 0)
      v11 = (v17 & 0x800000000) != 0;
    if (v11)
    {
      v24 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v15) & 7u) > (v24 & 0xF0000) >> 16)
        _dispatch_thread_setspecific(25, v24 & 0xFFF0FFFF | ((BYTE4(v15) & 7) << 16));
    }
    if (((v17 ^ v15) & v14) != 0)
    {
      if ((v15 & 0x4000000001) == 0)
        _dispatch_abort(3979, (v15 & 0x4000000001) != 0, v5, v6, v7, v8, v9, v10);
      if ((v15 & 0x2000000000) != 0)
        _dispatch_event_loop_poke(a1, v15, 1, v6, v7, v8, v9, v10);
      else
        ((void (*)(uint64_t (***)(), unsigned int *, unint64_t, uint64_t, uint64_t, uint64_t))(*a3)[9])(a3, a1, (v15 & 0x700000000) >> 32, v6, v7, v8);
    }
    else
    {
      _dispatch_release_2_tailcall(a1);
    }
  }
}

void _dispatch_workloop_drain_barrier_waiter(uint64_t a1, uint64_t a2, int a3, unsigned int a4, uint64_t a5)
{
  unint64_t *v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  BOOL v19;
  unint64_t *v20;
  _BOOL4 v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  int i;
  char v35;

  v27 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  v23 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 104 + 8 * (a3 - 1)) = v23;
  v19 = 0;
  if (!v23)
  {
    v5 = (unint64_t *)(a1 + 152 + 8 * (a3 - 1));
    do
      v6 = __ldaxr(v5);
    while (v6 == a2 && __stlxr(0, v5));
    v19 = v6 != a2;
  }
  if (v19)
  {
    v22 = *(_QWORD *)(a2 + 16);
    if (!v22)
      v22 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 152 + 8 * (a3 - 1));
    v23 = v22;
    *(_QWORD *)(a1 + 104 + 8 * (a3 - 1)) = v22;
  }
  v24 = v23 != 0;
LABEL_11:
  if (!v24)
  {
    for (i = 6; i; --i)
    {
      if (*(_QWORD *)(a1 + 152 + 8 * (i - 1)))
      {
        v35 = 1;
        goto LABEL_18;
      }
    }
    v35 = 0;
LABEL_18:
    v24 = v35;
  }
  v20 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v7 = __ldaxr(v20);
    else
      v7 = __ldxr(v20);
    v26 = v7;
    if ((v7 & 0x2000000000) != 0 && (v7 & 2) != 0 && (v7 & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      v17 = (unint64_t *)(a1 + 56);
      v18 = *(_QWORD *)(a1 + 56);
      do
      {
        v8 = v18;
        do
          v9 = __ldaxr(v17);
        while (v9 == v18 && __stlxr(v18 & 0xFFFFFFF7FFFFFFFDLL, v17));
        v18 = v9;
      }
      while (v9 != v8);
      __clrex();
      goto LABEL_11;
    }
    v25 = v7 & 0xFFFFFF7700000001 | v27;
    if ((v7 & 0x2000000000) != 0)
    {
      if (!v24)
      {
        if ((v7 & 0x8000000000) != 0)
        {
          __clrex();
          v15 = (unint64_t *)(a1 + 56);
          v16 = *(_QWORD *)(a1 + 56);
          do
          {
            v10 = v16;
            do
              v11 = __ldaxr(v15);
            while (v11 == v16 && __stlxr(v16 ^ 0x8000000000, v15));
            v16 = v11;
          }
          while (v11 != v10);
          goto LABEL_11;
        }
        v25 = v7 & 0xFFFFFF7000000000 | v27 & 0xFFFFFFF8FFFFFFFELL;
      }
    }
    else
    {
      v25 -= a5;
    }
    if (_os_atomic_mo_has_release(3))
      v21 = __stlxr(v25, v20) == 0;
    else
      v21 = __stxr(v25, v20) == 0;
  }
  while (!v21);
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a4, v26, v25, v12, v13, v14);
}

void _dispatch_lane_drain_barrier_waiter(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4)
{
  unint64_t *v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  BOOL v18;
  unint64_t *v19;
  _BOOL4 v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v29;
  uint64_t v30;

  v23 = *(_DWORD *)(a2 + 100) & 0xFFFFFFFC;
  v30 = *(_QWORD *)(a2 + 16);
  *(_QWORD *)(a1 + 104) = v30;
  v18 = 0;
  if (!v30)
  {
    v4 = (unint64_t *)(a1 + 48);
    do
      v5 = __ldaxr(v4);
    while (v5 == a2 && __stlxr(0, v4));
    v18 = v5 != a2;
  }
  if (v18)
  {
    v29 = *(_QWORD *)(a2 + 16);
    if (!v29)
      v29 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 48);
    v30 = v29;
    *(_QWORD *)(a1 + 104) = v29;
  }
  v24 = v30;
LABEL_11:
  v19 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v6 = __ldaxr(v19);
    else
      v6 = __ldxr(v19);
    v22 = v6;
    if ((v6 & 0x2000000000) != 0 && (v6 & 2) != 0 && (v6 & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      v16 = (unint64_t *)(a1 + 56);
      v17 = *(_QWORD *)(a1 + 56);
      do
      {
        v7 = v17;
        do
          v8 = __ldaxr(v16);
        while (v8 == v17 && __stlxr(v17 & 0xFFFFFFF7FFFFFFFDLL, v16));
        v17 = v8;
      }
      while (v8 != v7);
      __clrex();
      goto LABEL_11;
    }
    v21 = v6 & 0xFFFFFF7700000001 | v23;
    if ((v6 & 0x2000000000) != 0)
    {
      if (!v24)
      {
        if ((v6 & 0x8000000000) != 0)
        {
          __clrex();
          v14 = (unint64_t *)(a1 + 56);
          v15 = *(_QWORD *)(a1 + 56);
          do
          {
            v9 = v15;
            do
              v10 = __ldaxr(v14);
            while (v10 == v15 && __stlxr(v15 ^ 0x8000000000, v14));
            v15 = v10;
          }
          while (v10 != v9);
          v24 = *(_QWORD *)(a1 + 104);
          goto LABEL_11;
        }
        v21 = v6 & 0xFFFFFF7000000000 | v23 & 0xFFFFFFF8FFFFFFFELL;
      }
    }
    else
    {
      v21 -= a4;
    }
    if (_os_atomic_mo_has_release(3))
      v20 = __stlxr(v21, v19) == 0;
    else
      v20 = __stxr(v21, v19) == 0;
  }
  while (!v20);
  _dispatch_barrier_waiter_redirect_or_wake(a1, a2, a3, v22, v21, v11, v12, v13);
}

void _dispatch_lane_activate(uint64_t a1)
{
  uint64_t (***v1)();
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  unint64_t v9;

  v9 = *(_QWORD *)(a1 + 24);
  v8 = *(_DWORD *)(a1 + 84);
  if ((unsigned __int16)(v8 & 0xF000) >> 12 <= ((unsigned __int16)(v8 & 0xF00) >> 8)
    || (unsigned __int16)(v8 & 0xF00) >> 8 && (v8 & 0x40000000) == 0)
  {
    *(_DWORD *)(a1 + 84) = v8 & 0xFBFF0FFF;
  }
  v1 = _dispatch_queue_priority_inherit_from_target(a1, v9);
  _dispatch_lane_inherit_wlh_from_target(a1, v1, v2, v3, v4, v5, v6, v7);
}

uint64_t (***_dispatch_queue_priority_inherit_from_target(uint64_t a1, unint64_t a2))()
{
  BOOL v3;
  BOOL v4;
  BOOL v5;
  BOOL v6;
  unsigned int v7;
  unsigned int v8;
  unint64_t v9;
  int v11;
  int v12;

  v9 = a2;
  v8 = *(_DWORD *)(a1 + 84);
  v6 = 0;
  if ((v8 & 0x20000000) == 0)
    v6 = (v8 & 0x44000FFF) != 0;
  if (v6)
  {
    v5 = 0;
    if (a2 >= (unint64_t)&_dispatch_root_queues)
      v5 = a2 < (unint64_t)&_dispatch_queue_serial_numbers;
    if (v5)
    {
      v7 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      if (!v7)
        v7 = 4;
      v12 = 2 * (v8 >> 31);
      v4 = 1;
      if (v7)
        v4 = v7 > 6;
      if (v4)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
        qword_E4DA8 = v7;
        __break(1u);
        JUMPOUT(0x2A8CCLL);
      }
      v11 = 0;
      if ((v12 & 2) != 0)
      {
        v11 = 1;
      }
      else if ((v12 & 4) != 0)
      {
        v11 = 2;
      }
      return &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v7 + v11 - 3)];
    }
    return (uint64_t (***)())v9;
  }
  else
  {
    v3 = 0;
    if (a2 >= (unint64_t)&_dispatch_root_queues)
      v3 = a2 < (unint64_t)&_dispatch_queue_serial_numbers;
    if (v3)
    {
      v8 = *(_DWORD *)(a2 + 84) | 0x20000000;
    }
    else if ((v8 & 0x20000000) != 0)
    {
      v8 &= 0xFBFF0FFF;
    }
    *(_DWORD *)(a1 + 84) = v8;
    return (uint64_t (***)())a2;
  }
}

void _dispatch_lane_inherit_wlh_from_target(uint64_t a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int *v16;
  unsigned int v17;
  BOOL v18;
  int v19;
  int v20;
  _QWORD *v21;
  unint64_t *v22;
  _BOOL4 v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unsigned int *v29;
  _BOOL4 v30;
  unsigned int v31;

  if ((*(_QWORD *)(*(_QWORD *)a2 + 16) & 0x10000) != 0)
  {
    if ((_dispatch_base_lane_is_wlh(a1, (unint64_t)a2, a3, a4, a5, a6, a7, a8) & 1) != 0)
      v24 = 0x2000000000;
    else
      v24 = 0x1000000000;
  }
  else
  {
    v24 = 0;
  }
  v22 = (unint64_t *)(a1 + 56);
  while (1)
  {
    v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v22) : __ldxr(v22);
    v26 = v8;
    v25 = v8 & 0xFFFFFFCFFFFFFFFFLL | v24;
    if (v26 == (v26 & 0xFFFFFFCFFFFFFFFFLL | v24))
      break;
    if (_os_atomic_mo_has_release(0))
      v23 = __stlxr(v25, v22) == 0;
    else
      v23 = __stxr(v25, v22) == 0;
    if (v23)
      goto LABEL_16;
  }
  __clrex();
LABEL_16:
  if ((v26 & 0x2000000000) != 0 && (v25 & 0x2000000000) == 0)
  {
    v21 = _dispatch_thread_getspecific(0x1DuLL);
    if (v21)
    {
      if (v21[3] == a1)
        _dispatch_event_loop_leave_immediate(v25);
    }
  }
  if ((*(_QWORD *)(*(_QWORD *)a2 + 16) & 0x10000) == 0)
  {
    v20 = 0;
    v19 = 0;
    if (*(_BYTE *)(*(_QWORD *)a2 + 16) == 18)
    {
      v20 = 0x400000;
      v18 = 0;
      if (*((_QWORD *)a2 + 3) >= (unint64_t)&_dispatch_root_queues)
        v18 = *((_QWORD *)a2 + 3) < (unint64_t)&_dispatch_queue_serial_numbers;
      if (!v18)
      {
        v19 = 0x1000000;
        if (_dispatch_workloop_uses_bound_thread((uint64_t)a2))
          v19 = 17039360;
      }
    }
    else
    {
      v19 = a2[20] & 0x1000000;
      if (v19)
        v19 = a2[20] & 0x1040000;
    }
    if (v20)
    {
      v29 = a2 + 20;
      while (1)
      {
        v9 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v29) : __ldxr(v29);
        v31 = (v9 | 0x100000) & ~v20;
        if (v31 == v9)
          break;
        if (_os_atomic_mo_has_release(0))
          v30 = __stlxr(v31, v29) == 0;
        else
          v30 = __stxr(v31, v29) == 0;
        if (v30)
          goto LABEL_48;
      }
      __clrex();
    }
    else
    {
      v16 = a2 + 20;
      v17 = a2[20];
      do
      {
        v10 = v17;
        do
          v11 = __ldaxr(v16);
        while (v11 == v17 && __stlxr(v17 | 0x100000, v16));
        v17 = v11;
      }
      while (v11 != v10);
    }
LABEL_48:
    if (v19)
    {
      v14 = (unsigned int *)(a1 + 80);
      v15 = *(_DWORD *)(a1 + 80);
      do
      {
        v12 = v15;
        do
          v13 = __ldaxr(v14);
        while (v13 == v15 && __stlxr(v15 | v19, v14));
        v15 = v13;
      }
      while (v13 != v12);
    }
  }
}

void _dispatch_lane_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  unint64_t *v37;
  unint64_t v38;
  BOOL v39;
  unsigned int *v40;
  unsigned int v41;
  int v42;
  BOOL v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  __int128 v47;
  unsigned int *v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  void *v52;
  uint64_t v53;
  _BYTE v54[9];
  unsigned int *v55;
  uint64_t (*v56)(uint64_t, uint64_t, int, _QWORD *);
  int v57;
  unsigned int v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int *v64;
  unsigned int v65;
  unsigned int v66;
  int v67;
  int v68;
  int v69;
  unsigned int v70;
  int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  unsigned int *v76;
  uint64_t v77;
  _BOOL8 v78;
  int v79;
  int v80;
  unsigned int *v81;
  void *v82;
  unsigned int *v83;
  unsigned int v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  __int128 *v91;
  unsigned int *v92;
  __int128 *v93;
  unsigned int v94;
  unsigned int v95;
  __int128 *v96;
  _BOOL4 v97;
  unint64_t *v98;
  _BOOL4 v99;
  unsigned int v100;
  uint64_t v101;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  uint64_t v105;
  uint64_t v106;
  int v107;
  unsigned int *v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  _BOOL8 v112;
  uint64_t v113;
  _BOOL8 v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  int v122;
  int v123;
  unsigned int v124;
  unsigned int *v125;
  int v126;
  unint64_t v127;
  unint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unint64_t v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t *v137;
  int v138;
  unint64_t v139;
  unint64_t v140;
  BOOL v141;
  uint64_t v142;
  unsigned int *v143;
  char v144;
  unint64_t v145;
  unint64_t v146;
  uint64_t v147;
  unint64_t v148;
  uint64_t v149;
  unint64_t v150;
  int v151;
  unsigned int v152;
  unint64_t v153;
  uint64_t v154;
  unint64_t v155;
  unsigned int v156;
  unint64_t v157;
  uint64_t v158;
  unsigned int v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  uint64_t v163;
  unsigned int v164;
  int v165;
  int v166;
  uint64_t v167;
  unsigned int *v168;
  unsigned int v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int *v172;
  uint64_t v173;
  uint64_t v174;
  unsigned int *v175;
  void *v176;
  unsigned int *v177;
  uint64_t v178;
  uint64_t v179;
  uint64_t v180;
  unsigned int *v181;
  unsigned int v182;
  unsigned int *v183;

  v60 = a1;
  v59 = a2;
  v58 = a3;
  v57 = 0;
  v56 = _dispatch_lane_invoke2;
  v55 = a1;
  v54[8] = 0;
  *(_QWORD *)v54 = (a3 & 1) == 0;
  v53 = 0;
  if ((a3 & 3) == 0)
  {
    *((_QWORD *)v55 + 2) = -1985229329;
    v52 = _dispatch_thread_getspecific(0x14uLL);
    v51 = v55;
    v82 = v52;
    v81 = v55;
    v80 = 0;
    v79 = 0;
    v176 = v52;
    v175 = v55;
  }
  v58 |= v57;
  if ((v58 & 2) != 0)
  {
    v53 = 0x40020000000001;
    goto LABEL_54;
  }
  v108 = v55;
  v107 = v58;
  v106 = 0;
  v106 = (uint64_t)(*((unsigned __int16 *)v55 + 40) - 1) << 41;
  v121 = _dispatch_thread_getspecific(3uLL);
  v105 = v121 & 0xFFFFFFFC | 0x20000000000000;
  v103 = 0;
  v102 = 0;
  v101 = 0;
  v104 = 0xFFE00000FFFFFFFCLL;
  if ((v58 & 1) != 0)
  {
    v104 |= 0x4000000000uLL;
    v101 = 0;
  }
  else if ((v107 & 0x40000) != 0)
  {
    v101 = 0x4000000000;
  }
  else
  {
    v104 |= 0x4000000000uLL;
    v101 = 1;
  }
  v114 = (v107 & 2) == 0;
  v113 = 1323;
  if ((v107 & 2) != 0)
    _dispatch_abort(v113, v114, v3, v4, v5, v6, v7, v8);
  v100 = 0;
  v118 = _dispatch_thread_getspecific(0x19uLL);
  v120 = v118 & 0xF00;
  v117 = v120 >> 8;
  v119 = v118 & 0xF000;
  v116 = v119 >> 12;
  v122 = v118 & 0xF0000;
  v115 = (v118 & 0xF0000) >> 16;
  if (v120 >> 8 <= v119 >> 12)
    v46 = v116;
  else
    v46 = v117;
  if (v46 <= v115)
  {
    v44 = v115;
  }
  else
  {
    if (v117 <= v116)
      v45 = v116;
    else
      v45 = v117;
    v44 = v45;
  }
  v100 = v44;
LABEL_22:
  v99 = 0;
  v98 = (unint64_t *)(v108 + 14);
  while (1)
  {
    v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v98) : __ldxr(v98);
    v103 = v15;
    v102 = v15;
    if ((v15 & v104) != 0)
      break;
    v153 = v103;
    v152 = v100;
    v155 = v103;
    v43 = 0;
    if ((v103 & 0x1000000000) != 0)
    {
      v154 = v153 & 0x700000000;
      v43 = v152 < (v153 & 0x700000000) >> 32;
    }
    if (v43)
    {
      __clrex();
      v157 = v103;
      v158 = v103 & 0x700000000;
      v156 = (v103 & 0x700000000) >> 32;
      v162 = _dispatch_thread_getspecific(3uLL);
      v161 = v156;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v164 = v161;
        v163 = 0;
        if (v161)
          v163 = 1 << (v164 + 7);
        _pthread_workqueue_override_start_direct(v162, v163 | 0xFF);
      }
      v160 = v156;
      v159 = _dispatch_thread_getspecific(0x19uLL);
      v165 = v159 & 0xF0000;
      if (v156 > (v159 & 0xF0000) >> 16)
      {
        v159 = v159 & 0xFFF0FFFF | (v160 << 16);
        _dispatch_thread_setspecific(25, v159);
      }
      v100 = v156;
      goto LABEL_22;
    }
    v102 = v102 & 0x7700000001 | v105;
    v110 = v103;
    if ((v103 & 0x10000000000) != 0 || v103 + v106 < 0x20000000000000)
      v102 |= 0x40000000000000uLL;
LABEL_44:
    if (_os_atomic_mo_has_release(2))
      v99 = __stlxr(v102, v98) == 0;
    else
      v99 = __stxr(v102, v98) == 0;
    if (v99)
      goto LABEL_48;
  }
  if (v101)
  {
    v102 ^= v101;
    goto LABEL_44;
  }
  __clrex();
LABEL_48:
  v97 = v99;
  v112 = (v103 & v101) == v101;
  v111 = 1356;
  if ((v103 & v101) != v101)
    _dispatch_abort(v111, v112, v9, v10, v11, v12, v13, v14);
  if ((v103 & v104) != 0)
  {
    v109 = 0;
  }
  else
  {
    v102 &= v101 | 0x60000000000000;
    v103 &= 0x3FFE0000000000uLL;
    v109 = v102 - v103;
  }
  v53 = v109;
LABEL_54:
  if (v53)
  {
    v50 = 0;
    if ((v58 & 0x40000) != 0)
    {
      v50 = 0;
    }
    else
    {
      v86 = v55[21];
      v85 = _dispatch_thread_getspecific(0x19uLL);
      v84 = v85;
      if (v85)
      {
        if ((v86 & 0xFFF) != 0)
        {
          v84 &= 0x880F0000;
          if ((v85 & 0xFFF) <= (v86 & 0xFFF))
            v42 = v86 & 0xFFF;
          else
            v42 = v85 & 0xFFF;
          v84 |= v42;
          v88 = v86 & 0xF000;
          v90 = v84 & 0xF00;
          if (v88 >> 12 <= v90 >> 8)
            v86 &= 0x40000000u;
          else
            v86 &= 0x4400F000u;
          v84 |= v86;
        }
        else
        {
          if ((v84 & 0xFFF) != 0)
            v84 |= 0x40000000u;
          v87 = v86 & 0xF000;
          v89 = v84 & 0xF00;
          if (v87 >> 12 > v89 >> 8)
            v84 = v84 & 0xFFFF0FFF | v86 & 0x400F000;
        }
      }
      else
      {
        v84 = v86 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v84);
      v50 = v85;
    }
    if ((v58 & 0x100000) != 0)
    {
      v64 = v60;
      v63 = 0;
      v62 = v60[20];
      v63 = v62;
      v61 = v62;
      if ((v62 & 0x400000) != 0)
      {
        v76 = v60;
        v75 = 0x400000;
        v73 = -4194305;
        v72 = -4194305;
        v74 = -4194305;
        v70 = 0;
        v40 = v60 + 20;
        v68 = -4194305;
        v67 = -4194305;
        v69 = -4194305;
        v41 = v60[20];
        do
        {
          v16 = v41;
          do
            v17 = __ldaxr(v40);
          while (v17 == v41 && __stlxr(v41 & 0xFFBFFFFF, v40));
          v41 = v17;
        }
        while (v17 != v16);
        v66 = v17;
        v70 = v17;
        v65 = v17;
        v71 = v17 & v74;
      }
    }
    v49 = v55;
    v125 = v55;
    v124 = v58;
    v123 = 0;
    v168 = v55;
    v167 = 256;
    v174 = 1;
    v173 = 730;
    v166 = 0;
    v172 = v55;
    v171 = 0;
    v170 = v55[20];
    v171 = v170;
    v169 = v170;
    v166 = v170 & 0x30000;
    v123 = (v170 & 0x30000) << 8;
    if (v123)
      v124 = v124 & 0xFCFFFFFF | v123;
    v58 = v124;
    do
    {
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
        _dispatch_last_resort_autorelease_pool_push(v59);
      v48 = v55;
      *(_QWORD *)&v54[1] = v56((uint64_t)v55, v59, v58, &v53);
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
      {
        v47 = 0uLL;
        v92 = v55;
        v91 = &v47;
        v96 = &v47;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v47, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20, (uint64_t)v92, 21, (uint64_t)v91, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v59);
        v93 = &v47;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v47, v28, v29, v30, v31, v32);
      }
      v78 = *(_QWORD *)&v54[1] != 1;
      v77 = 1955;
      if (*(_QWORD *)&v54[1] == 1)
        _dispatch_abort(v77, v78, v18, v19, v20, v21, v22, v23);
      v39 = 0;
      if (*(_QWORD *)&v54[1])
        v39 = *(_QWORD *)&v54[1] != -1;
      if (v39)
        break;
      v143 = v55;
      v142 = v53;
      v141 = *(_QWORD *)&v54[1] == 0;
      v140 = 0;
      v139 = 0;
      v138 = 0;
      v137 = (unint64_t *)(v55 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v33 = __ldaxr(v137);
        else
          v33 = __ldxr(v137);
        v140 = v33;
        v139 = (v33 - v142) & 0xFFFFFFF700000001;
        v145 = v33;
        if ((v33 & 0xFF80000000000000) == 0)
        {
          v146 = v140;
          if ((v140 & 0x8000000000) != 0)
          {
            __clrex();
            v135 = 0x8000000000;
            v134 = 0x8000000000;
            v136 = 0x8000000000;
            v132 = 0;
            v37 = (unint64_t *)(v143 + 14);
            v130 = 0x8000000000;
            v129 = 0x8000000000;
            v131 = 0x8000000000;
            v38 = *((_QWORD *)v143 + 7);
            do
            {
              v34 = v38;
              do
                v35 = __ldaxr(v37);
              while (v35 == v38 && __stlxr(v38 ^ 0x8000000000, v37));
              v38 = v35;
            }
            while (v35 != v34);
            v128 = v35;
            v132 = v35;
            v127 = v35;
            v133 = v35 ^ v136;
            v144 = 0;
            goto LABEL_119;
          }
          if (v141)
            v139 &= 0xFFFFFFF8FFFFFFFFLL;
          else
            v139 |= 0x8000000000uLL;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v138) = __stlxr(v139, v137) == 0;
          v138 = v138;
        }
        else
        {
          LOBYTE(v138) = __stxr(v139, v137) == 0;
          v138 = v138;
        }
      }
      while (!v138);
      v126 = v138;
      v148 = v140;
      v150 = v140;
      v36 = 0;
      if ((v140 & 0x1000000000) != 0)
        v36 = (v148 & 0x800000000) != 0;
      if (v36)
      {
        v147 = v140 & 0x700000000;
        v149 = v140 & 0x700000000;
        LODWORD(v149) = _dispatch_thread_getspecific(0x19uLL);
        v151 = v149 & 0xF0000;
        if (HIDWORD(v149) > (v149 & 0xF0000) >> 16)
        {
          LODWORD(v149) = v149 & 0xFFF0FFFF;
          LODWORD(v149) = v149 | (HIDWORD(v149) << 16);
          _dispatch_thread_setspecific(25, v149);
        }
      }
      v144 = 1;
LABEL_119:
      if ((v144 & 1) != 0)
      {
        v53 = 0;
        *(_QWORD *)&v54[1] = 0;
        break;
      }
      *(_QWORD *)&v54[1] = _dispatch_thread_getspecific(0x14uLL);
    }
    while ((*(_QWORD *)(**(_QWORD **)&v54[1] + 16) & 0x10000) != 0 || (v54[0] & 1) == 0);
    if ((v58 & 0x40000) == 0)
    {
      v95 = v50;
      v94 = 0;
      v94 = _dispatch_thread_getspecific(0x19uLL);
      v95 &= 0xFFF0FFFF;
      v95 |= v94 & 0xF0000;
      _dispatch_thread_setspecific(25, v95);
    }
  }
  if ((v54[0] & 1) != 0)
  {
    v83 = v55;
    v177 = v55;
    v182 = 772079660;
    v181 = v55;
    v180 = 0;
    v179 = 0;
    v178 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v182, v181, v180, v179, v178);
    v183 = v83;
  }
  if (*(_QWORD *)&v54[1])
    _dispatch_queue_invoke_finish(v55, v59, *(uint64_t (****)())&v54[1], v53);
  else
    _dispatch_release_2_tailcall(v55);
}

uint64_t _dispatch_lane_invoke2(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  void *v9;

  v9 = *(void **)(a1 + 24);
  if (_dispatch_thread_getspecific(0x14uLL) != v9)
    return (uint64_t)v9;
  if (*(_WORD *)(a1 + 80) == 1)
    return _dispatch_lane_serial_drain(a1, a2, a3, a4, v4, v5, v6, v7);
  return _dispatch_lane_concurrent_drain(a1, a2, a3, a4, v4, v5, v6, v7);
}

uint64_t dispatch_workloop_copy_current()
{
  void *v2;
  uint64_t v3;

  v2 = _dispatch_thread_getspecific(0x1BuLL);
  if (v2 && v2 != (void *)-4)
  {
    if (*(_BYTE *)(*(_QWORD *)v2 + 16) == 18)
      v3 = (uint64_t)v2;
    else
      v3 = 0;
  }
  else
  {
    v3 = 0;
  }
  if (!v3)
    return 0;
  _os_object_retain_with_resurrect(v3);
  return v3;
}

BOOL dispatch_workloop_is_current(void *a1)
{
  return _dispatch_thread_getspecific(0x1BuLL) == a1;
}

BOOL _dispatch_workloop_uses_bound_thread(uint64_t a1)
{
  _DWORD *v2;

  v2 = *(_DWORD **)(a1 + 200);
  return v2 && (*v2 & 0x40) != 0;
}

BOOL _dispatch_workloop_should_yield_4NW()
{
  unsigned int *v2;
  unsigned int *v3;

  v2 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
  if (v2 && v2 != (unsigned int *)-4)
  {
    if (*(_BYTE *)(*(_QWORD *)v2 + 16) == 18)
      v3 = v2;
    else
      v3 = 0;
  }
  else
  {
    v3 = 0;
  }
  return v3 && (((unint64_t)v3[15] << 32) & 0x700000000) >> 32 > *((unsigned __int8 *)v3 + 100);
}

dispatch_workloop_t dispatch_workloop_create(const char *label)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0, v1, v2, v3, v4, v5, v6);
}

_QWORD *_dispatch_workloop_create(const char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _QWORD *v19;
  const char *v20;
  int v21;
  uint64_t v23;
  const char *v24;
  uint64_t v25;

  v24 = a1;
  v21 = 0x10000;
  if (a1)
  {
    v20 = _dispatch_strdup_if_mutable(a1);
    if (v20 != v24)
    {
      v21 = 2162688;
      v24 = v20;
    }
  }
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
    v25 = 0x2000000000;
  else
    v25 = 0x1000000000;
  v23 = a2 | v25;
  v19 = _dispatch_object_alloc((uint64_t)_OS_dispatch_workloop_vtable, 0xD0uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init((uint64_t)v19, v21, 1, v23, v8, v9, v10, v11);
  v19[9] = v24;
  v19[3] = &off_E46C0;
  if ((v23 & 0x180000000000000) == 0)
    *((_DWORD *)v19 + 21) = -2080358400;
  _dispatch_object_debug((uint64_t)v19, "%s", v12, v13, v14, v15, v16, v17, (char)"_dispatch_workloop_create");
  return v19;
}

dispatch_workloop_t dispatch_workloop_create_inactive(const char *label)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  return (dispatch_workloop_t)_dispatch_workloop_create(label, 0x180000000000000, v1, v2, v3, v4, v5, v6);
}

void dispatch_workloop_set_autorelease_frequency(dispatch_workloop_t workloop, dispatch_autorelease_frequency_t frequency)
{
  unsigned int v2;
  unsigned int v3;
  uint64_t v5;
  unsigned int *v6;
  _BOOL4 v7;
  unsigned int v8;
  unsigned int *v9;
  _BOOL4 v10;
  unsigned int v11;

  if (frequency == DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM)
  {
    v9 = (unsigned int *)((char *)workloop + 80);
    while (1)
    {
      v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v9) : __ldxr(v9);
      v11 = v2 & 0xFFFCFFFF | 0x10000;
      if (v11 == v2)
        break;
      if (_os_atomic_mo_has_release(0))
        v10 = __stlxr(v11, v9) == 0;
      else
        v10 = __stxr(v11, v9) == 0;
      if (v10)
        goto LABEL_22;
    }
  }
  else
  {
    v6 = (unsigned int *)((char *)workloop + 80);
    while (1)
    {
      v3 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v6) : __ldxr(v6);
      v8 = v3 & 0xFFFCFFFF | 0x20000;
      if (v8 == v3)
        break;
      if (_os_atomic_mo_has_release(0))
        v7 = __stlxr(v8, v6) == 0;
      else
        v7 = __stxr(v8, v6) == 0;
      if (v7)
        goto LABEL_22;
    }
  }
  __clrex();
LABEL_22:
  v5 = *((_QWORD *)workloop + 7);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2CEBCLL);
  }
}

uint64_t dispatch_workloop_set_scheduler_priority(uint64_t result, int a2, char a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = result;
  v6 = *(_QWORD *)(result + 56);
  if ((~v6 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x2CF7CLL);
  }
  if (!*(_QWORD *)(result + 200))
  {
    result = _dispatch_calloc(1, 56);
    *(_QWORD *)(v5 + 200) = result;
  }
  if (a2)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 200) + 8) = a2;
    **(_DWORD **)(v5 + 200) |= 1u;
  }
  else
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 200) + 8) = 0;
    **(_DWORD **)(v5 + 200) &= ~1u;
  }
  if ((a3 & 1) != 0)
  {
    *(_DWORD *)(*(_QWORD *)(v5 + 200) + 16) = 2;
    **(_DWORD **)(v5 + 200) |= 2u;
  }
  else
  {
    **(_DWORD **)(v5 + 200) &= ~2u;
  }
  return result;
}

uint64_t dispatch_workloop_set_uses_bound_thread(uint64_t a1)
{
  uint64_t v4;

  if (_dispatch_workloop_bound_thread_pred != -1)
    dispatch_once_f(&_dispatch_workloop_bound_thread_pred, 0, (dispatch_function_t)_dispatch_workloop_bound_thread_init_once);
  if ((_dispatch_thread_bound_kqwl_enabled & 1) != 0)
  {
    v4 = *(_QWORD *)(a1 + 56);
    if ((~v4 & 0x180000000000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
      qword_E4DA8 = v4;
      __break(1u);
      JUMPOUT(0x2D180);
    }
    if (!*(_QWORD *)(a1 + 200))
      *(_QWORD *)(a1 + 200) = _dispatch_calloc(1, 56);
    **(_DWORD **)(a1 + 200) |= 0x40u;
    return 0;
  }
  else
  {
    return -1;
  }
}

void dispatch_workloop_set_os_workgroup(dispatch_workloop_t workloop, os_workgroup_t workgroup)
{
  unsigned int *v2;
  uint64_t v5;

  v5 = *((_QWORD *)workloop + 7);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2D298);
  }
  if (!*((_QWORD *)workloop + 25))
    *((_QWORD *)workloop + 25) = _dispatch_calloc(1, 56);
  v2 = *(unsigned int **)(*((_QWORD *)workloop + 25) + 32);
  if (v2)
    _os_object_release(v2);
  _os_object_retain((uint64_t)workgroup);
  *(_QWORD *)(*((_QWORD *)workloop + 25) + 32) = workgroup;
}

uint64_t dispatch_workloop_set_qos_class(uint64_t a1, int a2, char a3)
{
  return dispatch_workloop_set_qos_class_floor(a1, a2, 0, a3);
}

uint64_t dispatch_workloop_set_cpupercent(uint64_t result, char a2, int a3)
{
  uint64_t v5;
  uint64_t v6;

  v5 = result;
  v6 = *(_QWORD *)(result + 56);
  if ((~v6 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x2D410);
  }
  if (!*(_QWORD *)(result + 200))
  {
    result = _dispatch_calloc(1, 56);
    *(_QWORD *)(v5 + 200) = result;
  }
  if ((**(_BYTE **)(v5 + 200) & 9) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: workloop qos class or priority must be set before cpupercent";
    __break(1u);
    JUMPOUT(0x2D48CLL);
  }
  *(_BYTE *)(*(_QWORD *)(v5 + 200) + 20) = a2;
  *(_DWORD *)(*(_QWORD *)(v5 + 200) + 24) = a3;
  **(_DWORD **)(v5 + 200) |= 4u;
  return result;
}

__n128 _dispatch_workloop_set_observer_hooks_4IOHID(uint64_t a1, __n128 *a2)
{
  __n128 result;
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 56);
  if ((~v5 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x2D580);
  }
  if (!*(_QWORD *)(a1 + 200))
    *(_QWORD *)(a1 + 200) = _dispatch_calloc(1, 56);
  result = *a2;
  *(__n128 *)(*(_QWORD *)(a1 + 200) + 40) = *a2;
  **(_DWORD **)(a1 + 200) |= 0x20u;
  return result;
}

void _dispatch_workloop_dispose(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v20;
  unint64_t j;
  uint64_t v22;
  unint64_t i;
  uint64_t v24;
  uint64_t v27;

  v24 = *(_QWORD *)(a1 + 56);
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
    v27 = 0x2000000000;
  else
    v27 = 0x1000000000;
  if (v24 != (v27 | 0x1FFE0000000000))
  {
    if ((v24 & 0xFFFFFFFC) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a locked workloop";
      qword_E4DA8 = v24;
      __break(1u);
      JUMPOUT(0x2D6ECLL);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop with corrupt state";
    qword_E4DA8 = v24;
    __break(1u);
    JUMPOUT(0x2D730);
  }
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_workloop_dispose");
  for (i = 0; i < 6; ++i)
  {
    if (*(_QWORD *)(a1 + 8 * i + 152))
    {
      v22 = *(_QWORD *)(a1 + 8 * i + 152);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a workloop while items are enqueued";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x2D7FCLL);
    }
    *(_QWORD *)(a1 + 8 * i + 152) = 512;
    *(_QWORD *)(a1 + 8 * i + 104) = 512;
  }
  if (*(_QWORD *)(a1 + 48))
  {
    for (j = 0; j <= 5; ++j)
    {
      if (*(_DWORD *)(*(_QWORD *)(a1 + 48) + 32 * j))
        _dispatch_abort(4557, *(_DWORD *)(*(_QWORD *)(a1 + 48) + 32 * j) == 0, v8, v9, v10, v11, v12, v13);
    }
    free(*(void **)(a1 + 48));
    *(_QWORD *)(a1 + 48) = 0;
  }
  if (*(_QWORD *)(a1 + 200))
  {
    if ((**(_BYTE **)(a1 + 200) & 0x10) != 0)
    {
      v20 = _pthread_workloop_destroy(a1);
      if (v20)
        _dispatch_bug(4566, v20, v14, v15, v16, v17, v18, v19);
    }
  }
  if (*(_QWORD *)(a1 + 200))
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 200) + 32))
      _os_object_release(*(unsigned int **)(*(_QWORD *)(a1 + 200) + 32));
    free(*(void **)(a1 + 200));
  }
  _dispatch_queue_dispose(a1, a2);
}

void _dispatch_workloop_activate(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v5;
  unint64_t v6;
  unint64_t *v7;
  unint64_t v8;

  v7 = (unint64_t *)(a1 + 56);
  v8 = *(_QWORD *)(a1 + 56);
  do
  {
    v1 = v8;
    do
      v2 = __ldaxr(v7);
    while (v2 == v8 && __stlxr(v8 & 0xFEFFFFFFFFFFFFFFLL, v7));
    v8 = v2;
  }
  while (v2 != v1);
  if ((v2 & 0x180000000000000) == 0x180000000000000)
  {
    if (*(_QWORD *)(a1 + 200))
      _dispatch_workloop_activate_attributes(a1);
    if (!*(_DWORD *)(a1 + 84))
      *(_DWORD *)(a1 + 84) = 67125248;
    *(_DWORD *)(a1 + 84) |= 0x80000000;
    v5 = (unint64_t *)(a1 + 56);
    v6 = *(_QWORD *)(a1 + 56);
    do
    {
      v3 = v6;
      do
        v4 = __ldaxr(v5);
      while (v4 == v6 && __stlxr(v6 & 0xFF7FFFFFFFFFFFFFLL, v5));
      v6 = v4;
    }
    while (v4 != v3);
    _dispatch_workloop_wakeup(a1, 0, 1u);
  }
}

uint64_t _dispatch_workloop_activate_attributes(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v8;
  char v9;
  BOOL v10;
  int v11;
  unsigned int backing_workinterval;
  uint64_t v13;
  uint64_t v14;
  pthread_attr_t v16;

  v14 = *(_QWORD *)(a1 + 200);
  memset(&v16, 0, sizeof(v16));
  v13 = 0;
  pthread_attr_init(&v16);
  if ((*(_BYTE *)v14 & 8) != 0)
    *(_DWORD *)(a1 + 84) |= *(_DWORD *)(v14 + 4) | 0x40000000;
  if ((*(_BYTE *)v14 & 1) != 0)
  {
    pthread_attr_setschedparam(&v16, (const sched_param *)(v14 + 8));
    *(_QWORD *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
  }
  if (*(_QWORD *)(v14 + 32))
  {
    *(_QWORD *)(a1 + 24) = &_dispatch_custom_workloop_root_queue;
    backing_workinterval = _os_workgroup_get_backing_workinterval(*(_QWORD *)(v14 + 32));
    if (backing_workinterval)
      pthread_attr_setworkinterval_np(&v16, backing_workinterval);
  }
  if ((*(_BYTE *)v14 & 0x40) != 0)
  {
    if (_dispatch_root_queues_pred != -1)
      dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
    v13 = 1;
    *(_QWORD *)(a1 + 24) = &_dispatch_custom_workloop_overcommit_root_queue;
  }
  if ((*(_BYTE *)v14 & 2) != 0)
    pthread_attr_setschedpolicy(&v16, *(_DWORD *)(v14 + 16));
  if ((*(_BYTE *)v14 & 4) != 0)
    pthread_attr_setcpupercent_np(&v16, *(unsigned __int8 *)(v14 + 20), *(unsigned int *)(v14 + 24));
  v10 = 0;
  if (*(_QWORD *)(a1 + 200))
    v10 = (**(_BYTE **)(a1 + 200) & 0x47) != 0;
  v9 = 1;
  if (!v10)
  {
    v8 = 0;
    if (*(_QWORD *)(a1 + 200))
    {
      v8 = 0;
      if (*(_QWORD *)(*(_QWORD *)(a1 + 200) + 32))
        v8 = _os_workgroup_get_backing_workinterval(*(_QWORD *)(*(_QWORD *)(a1 + 200) + 32)) != 0;
    }
    v9 = v8;
  }
  if ((v9 & 1) != 0)
  {
    v11 = _pthread_workloop_create(a1, v13, &v16);
    if (v11)
    {
      switch(v11)
      {
        case '!':
          if ((*(_DWORD *)v14 & 0x40) == 0)
            _dispatch_abort(4509, 0, v1, v2, v3, v4, v5, v6);
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Process has too many threads.";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x2DFACLL);
        case '-':
          _dispatch_workloop_activate_tg_unsupported_fallback(a1);
          break;
        case 'N':
          _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&v16, v1, v2, v3, v4, v5, v6);
          break;
        default:
          _dispatch_abort(4514, v11, v1, v2, v3, v4, v5, v6);
      }
    }
    else
    {
      *(_DWORD *)v14 |= 0x10u;
    }
  }
  return pthread_attr_destroy(&v16);
}

void _dispatch_workloop_wakeup(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  _BOOL4 v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v17;

  if (((a3 >> 2) & 1) != 0)
  {
    _dispatch_workloop_barrier_complete(a1, a2, a3);
    return;
  }
  if ((a3 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid way to wake up a workloop";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x2E0A0);
  }
  if (((a3 >> 3) & 1) != 0)
    goto LABEL_43;
  v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v3 = __ldaxr(v10);
    else
      v3 = __ldxr(v10);
    v13 = v3;
    v17 = v3;
    if ((v3 & 0x700000000) < (unint64_t)a2 << 32)
    {
      v17 = v3 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a2 << 32);
      if ((v17 & 0x1000000000) != 0)
        v17 |= 0x800000000uLL;
    }
    v12 = v17;
    if ((v17 & 0x700000000) >> 32)
      v12 = v17 | 1;
    if ((a3 & 2) != 0)
    {
      v12 |= 0x8000000000uLL;
    }
    else if (v12 == v3)
    {
      __clrex();
      goto LABEL_43;
    }
    if (_os_atomic_mo_has_release(3))
      v11 = __stlxr(v12, v10) == 0;
    else
      v11 = __stxr(v12, v10) == 0;
  }
  while (!v11);
  if ((v13 & 0xFF80000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waking up an inactive workloop";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x2E2C8);
  }
  if (((v13 ^ v12) & 1) != 0)
  {
    if ((a3 & 1) == 0)
      _dispatch_abort(1866, a3 & 1, v4, v5, v6, v7, v8, v9);
    if ((v12 & 0x2000000000) != 0)
      _dispatch_event_loop_poke((unsigned int *)a1, v12, 1, v5, v6, v7, v8, v9);
    else
      (*(void (**)(_QWORD, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24)
                                                                                           + 72))(*(_QWORD *)(a1 + 24), a1, (v12 & 0x700000000uLL) >> 32, v5, v6, v7);
    return;
  }
  if (((v13 ^ v12) & 0x700000000) == 0)
  {
LABEL_43:
    _dispatch_release_2_tailcall((unsigned int *)a1);
    return;
  }
  if ((v12 & 0xFF80000000000000) != 0 || (v12 & 0x4000000000) != 0 || (v12 & 1) == 0 && (v12 & 0xFFFFFFFC) == 0)
    _dispatch_abort(5301, 0, v4, v5, v6, v7, v8, v9);
  if ((v12 & 0x2000000000) != 0)
    _dispatch_event_loop_poke((unsigned int *)a1, v12, a3 | 0x80000000, v5, v6, v7, v8, v9);
  else
    _dispatch_queue_wakeup_with_override_slow(a1, v12, a3);
}

void _dispatch_workloop_invoke(unsigned int *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  unsigned int *v41;
  unsigned int v42;
  int v43;
  BOOL v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  __int128 v48;
  unsigned int *v49;
  unsigned int *v50;
  unsigned int v51;
  unsigned int *v52;
  void *v53;
  uint64_t v54;
  _BYTE v55[9];
  unsigned int *v56;
  uint64_t (*v57)(uint64_t, uint64_t, int, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v58;
  unsigned int v59;
  uint64_t v60;
  unsigned int *v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int v64;
  unsigned int *v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  unsigned int *v77;
  uint64_t v78;
  _BOOL8 v79;
  int v80;
  int v81;
  unsigned int *v82;
  void *v83;
  unsigned int *v84;
  unsigned int v85;
  unsigned int v86;
  unsigned int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  __int128 *v92;
  unsigned int *v93;
  __int128 *v94;
  unsigned int v95;
  unsigned int v96;
  __int128 *v97;
  _BOOL4 v98;
  unint64_t *v99;
  _BOOL4 v100;
  unsigned int v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unsigned int v108;
  unsigned int *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  _BOOL8 v113;
  uint64_t v114;
  _BOOL8 v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  int v124;
  unsigned int v125;
  unsigned int *v126;
  int v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t *v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  BOOL v142;
  uint64_t v143;
  unsigned int *v144;
  char v145;
  unint64_t v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  unint64_t v151;
  int v152;
  unsigned int v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  unsigned int v157;
  unint64_t v158;
  uint64_t v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  unsigned int v165;
  int v166;
  int v167;
  uint64_t v168;
  unsigned int *v169;
  unsigned int v170;
  unsigned int v171;
  unsigned int v172;
  unsigned int *v173;
  uint64_t v174;
  uint64_t v175;
  unsigned int *v176;
  void *v177;
  unsigned int *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  unsigned int *v182;
  unsigned int v183;
  unsigned int *v184;

  v61 = a1;
  v60 = a2;
  v59 = a3 & 0xFFEDFFFF | 0x100000;
  v58 = 0;
  v57 = _dispatch_workloop_invoke2;
  v56 = a1;
  v55[8] = 0;
  *(_QWORD *)v55 = (a3 & 1) == 0;
  v54 = 0;
  if ((a3 & 3) == 0)
  {
    *((_QWORD *)v56 + 2) = -1985229329;
    v53 = _dispatch_thread_getspecific(0x14uLL);
    v52 = v56;
    v83 = v53;
    v82 = v56;
    v81 = 0;
    v80 = 0;
    v177 = v53;
    v176 = v56;
  }
  v59 |= v58;
  if ((v59 & 2) != 0)
  {
    v54 = 0x40020000000001;
    goto LABEL_54;
  }
  v109 = v56;
  v108 = v59;
  v107 = 0;
  v107 = (uint64_t)(*((unsigned __int16 *)v56 + 40) - 1) << 41;
  v122 = _dispatch_thread_getspecific(3uLL);
  v106 = v122 & 0xFFFFFFFC | 0x20000000000000;
  v104 = 0;
  v103 = 0;
  v102 = 0;
  v105 = 0xFFE00000FFFFFFFCLL;
  if ((v59 & 1) != 0)
  {
    v105 |= 0x4000000000uLL;
    v102 = 0;
  }
  else if ((v108 & 0x40000) != 0)
  {
    v102 = 0x4000000000;
  }
  else
  {
    v105 |= 0x4000000000uLL;
    v102 = 1;
  }
  v115 = (v108 & 2) == 0;
  v114 = 1323;
  if ((v108 & 2) != 0)
    _dispatch_abort(v114, v115, v8, v9, v10, v11, v12, v13);
  v101 = 0;
  v119 = _dispatch_thread_getspecific(0x19uLL);
  v121 = v119 & 0xF00;
  v118 = v121 >> 8;
  v120 = v119 & 0xF000;
  v117 = v120 >> 12;
  v123 = v119 & 0xF0000;
  v116 = (v119 & 0xF0000) >> 16;
  if (v121 >> 8 <= v120 >> 12)
    v47 = v117;
  else
    v47 = v118;
  if (v47 <= v116)
  {
    v45 = v116;
  }
  else
  {
    if (v118 <= v117)
      v46 = v117;
    else
      v46 = v118;
    v45 = v46;
  }
  v101 = v45;
LABEL_22:
  v100 = 0;
  v99 = (unint64_t *)(v109 + 14);
  while (1)
  {
    v16 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v99) : __ldxr(v99);
    v104 = v16;
    v103 = v16;
    if ((v16 & v105) != 0)
      break;
    v154 = v104;
    v153 = v101;
    v156 = v104;
    v44 = 0;
    if ((v104 & 0x1000000000) != 0)
    {
      v155 = v154 & 0x700000000;
      v44 = v153 < (v154 & 0x700000000) >> 32;
    }
    if (v44)
    {
      __clrex();
      v158 = v104;
      v159 = v104 & 0x700000000;
      v157 = (v104 & 0x700000000) >> 32;
      v163 = _dispatch_thread_getspecific(3uLL);
      v162 = v157;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v165 = v162;
        v164 = 0;
        if (v162)
          v164 = 1 << (v165 + 7);
        _pthread_workqueue_override_start_direct(v163, v164 | 0xFF);
      }
      v161 = v157;
      v160 = _dispatch_thread_getspecific(0x19uLL);
      v166 = v160 & 0xF0000;
      if (v157 > (v160 & 0xF0000) >> 16)
      {
        v160 = v160 & 0xFFF0FFFF | (v161 << 16);
        _dispatch_thread_setspecific(25, v160);
      }
      v101 = v157;
      goto LABEL_22;
    }
    v103 = v103 & 0x7700000001 | v106;
    v111 = v104;
    if ((v104 & 0x10000000000) != 0 || v104 + v107 < 0x20000000000000)
      v103 |= 0x40000000000000uLL;
LABEL_44:
    if (_os_atomic_mo_has_release(2))
      v100 = __stlxr(v103, v99) == 0;
    else
      v100 = __stxr(v103, v99) == 0;
    if (v100)
      goto LABEL_48;
  }
  if (v102)
  {
    v103 ^= v102;
    goto LABEL_44;
  }
  __clrex();
LABEL_48:
  v98 = v100;
  v113 = (v104 & v102) == v102;
  v112 = 1356;
  if ((v104 & v102) != v102)
    _dispatch_abort(v112, v113, v14, v15, a5, a6, a7, a8);
  if ((v104 & v105) != 0)
  {
    v110 = 0;
  }
  else
  {
    v103 &= v102 | 0x60000000000000;
    v104 &= 0x3FFE0000000000uLL;
    v110 = v103 - v104;
  }
  v54 = v110;
LABEL_54:
  if (v54)
  {
    v51 = 0;
    if ((v59 & 0x40000) != 0)
    {
      v51 = 0;
    }
    else
    {
      v87 = v56[21];
      v86 = _dispatch_thread_getspecific(0x19uLL);
      v85 = v86;
      if (v86)
      {
        if ((v87 & 0xFFF) != 0)
        {
          v85 &= 0x880F0000;
          if ((v86 & 0xFFF) <= (v87 & 0xFFF))
            v43 = v87 & 0xFFF;
          else
            v43 = v86 & 0xFFF;
          v85 |= v43;
          v89 = v87 & 0xF000;
          v91 = v85 & 0xF00;
          if (v89 >> 12 <= v91 >> 8)
            v87 &= 0x40000000u;
          else
            v87 &= 0x4400F000u;
          v85 |= v87;
        }
        else
        {
          if ((v85 & 0xFFF) != 0)
            v85 |= 0x40000000u;
          v88 = v87 & 0xF000;
          v90 = v85 & 0xF00;
          if (v88 >> 12 > v90 >> 8)
            v85 = v85 & 0xFFFF0FFF | v87 & 0x400F000;
        }
      }
      else
      {
        v85 = v87 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v85);
      v51 = v86;
    }
    if ((v59 & 0x100000) != 0)
    {
      v65 = v61;
      v64 = 0;
      v63 = v61[20];
      v64 = v63;
      v62 = v63;
      if ((v63 & 0x400000) != 0)
      {
        v77 = v61;
        v76 = 0x400000;
        v74 = -4194305;
        v73 = -4194305;
        v75 = -4194305;
        v71 = 0;
        v41 = v61 + 20;
        v69 = -4194305;
        v68 = -4194305;
        v70 = -4194305;
        v42 = v61[20];
        do
        {
          v17 = v42;
          do
            v18 = __ldaxr(v41);
          while (v18 == v42 && __stlxr(v42 & 0xFFBFFFFF, v41));
          v42 = v18;
        }
        while (v18 != v17);
        v67 = v18;
        v71 = v18;
        v66 = v18;
        v72 = v18 & v75;
      }
    }
    v50 = v56;
    v126 = v56;
    v125 = v59;
    v124 = 0;
    v169 = v56;
    v168 = 256;
    v175 = 1;
    v174 = 730;
    v167 = 0;
    v173 = v56;
    v172 = 0;
    v171 = v56[20];
    v172 = v171;
    v170 = v171;
    v167 = v171 & 0x30000;
    v124 = (v171 & 0x30000) << 8;
    if (v124)
      v125 = v125 & 0xFCFFFFFF | v124;
    v59 = v125;
    do
    {
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
        _dispatch_last_resort_autorelease_pool_push(v60);
      v49 = v56;
      *(_QWORD *)&v55[1] = v57((uint64_t)v56, v60, v59, (uint64_t)&v54, a5, a6, a7, a8);
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
      {
        v48 = 0uLL;
        v93 = v56;
        v92 = &v48;
        v97 = &v48;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v48, v20, v21, v22, v23, v24);
        _dispatch_thread_setspecific_pair(20, (uint64_t)v93, 21, (uint64_t)v92, v25, v26, v27, v28);
        _dispatch_last_resort_autorelease_pool_pop(v60);
        v94 = &v48;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v48, v29, v30, v31, v32, v33);
      }
      v79 = *(_QWORD *)&v55[1] != 1;
      v78 = 1955;
      if (*(_QWORD *)&v55[1] == 1)
        _dispatch_abort(v78, v79, v19, v20, v21, v22, v23, v24);
      v40 = 0;
      if (*(_QWORD *)&v55[1])
        v40 = *(_QWORD *)&v55[1] != -1;
      if (v40)
        break;
      v144 = v56;
      v143 = v54;
      v142 = *(_QWORD *)&v55[1] == 0;
      v141 = 0;
      v140 = 0;
      v139 = 0;
      v138 = (unint64_t *)(v56 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v34 = __ldaxr(v138);
        else
          v34 = __ldxr(v138);
        v141 = v34;
        v140 = (v34 - v143) & 0xFFFFFFF700000001;
        v146 = v34;
        if ((v34 & 0xFF80000000000000) == 0)
        {
          v147 = v141;
          if ((v141 & 0x8000000000) != 0)
          {
            __clrex();
            v136 = 0x8000000000;
            v135 = 0x8000000000;
            v137 = 0x8000000000;
            v133 = 0;
            v38 = (unint64_t *)(v144 + 14);
            v131 = 0x8000000000;
            v130 = 0x8000000000;
            v132 = 0x8000000000;
            v39 = *((_QWORD *)v144 + 7);
            do
            {
              v35 = v39;
              do
                v36 = __ldaxr(v38);
              while (v36 == v39 && __stlxr(v39 ^ 0x8000000000, v38));
              v39 = v36;
            }
            while (v36 != v35);
            v129 = v36;
            v133 = v36;
            v128 = v36;
            v134 = v36 ^ v137;
            v145 = 0;
            goto LABEL_119;
          }
          if (v142)
            v140 &= 0xFFFFFFF8FFFFFFFFLL;
          else
            v140 |= 0x8000000000uLL;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v139) = __stlxr(v140, v138) == 0;
          v139 = v139;
        }
        else
        {
          LOBYTE(v139) = __stxr(v140, v138) == 0;
          v139 = v139;
        }
      }
      while (!v139);
      v127 = v139;
      v149 = v141;
      v151 = v141;
      v37 = 0;
      if ((v141 & 0x1000000000) != 0)
        v37 = (v149 & 0x800000000) != 0;
      if (v37)
      {
        v148 = v141 & 0x700000000;
        v150 = v141 & 0x700000000;
        LODWORD(v150) = _dispatch_thread_getspecific(0x19uLL);
        v152 = v150 & 0xF0000;
        if (HIDWORD(v150) > (v150 & 0xF0000) >> 16)
        {
          LODWORD(v150) = v150 & 0xFFF0FFFF;
          LODWORD(v150) = v150 | (HIDWORD(v150) << 16);
          _dispatch_thread_setspecific(25, v150);
        }
      }
      v145 = 1;
LABEL_119:
      if ((v145 & 1) != 0)
      {
        v54 = 0;
        *(_QWORD *)&v55[1] = 0;
        break;
      }
      *(_QWORD *)&v55[1] = _dispatch_thread_getspecific(0x14uLL);
    }
    while ((*(_QWORD *)(**(_QWORD **)&v55[1] + 16) & 0x10000) != 0 || (v55[0] & 1) == 0);
    if ((v59 & 0x40000) == 0)
    {
      v96 = v51;
      v95 = 0;
      v95 = _dispatch_thread_getspecific(0x19uLL);
      v96 &= 0xFFF0FFFF;
      v96 |= v95 & 0xF0000;
      _dispatch_thread_setspecific(25, v96);
    }
  }
  if ((v55[0] & 1) != 0)
  {
    v84 = v56;
    v178 = v56;
    v183 = 772079660;
    v182 = v56;
    v181 = 0;
    v180 = 0;
    v179 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v183, v182, v181, v180, v179);
    v184 = v84;
  }
  if (*(_QWORD *)&v55[1])
    _dispatch_queue_invoke_finish(v56, v60, *(uint64_t (****)())&v55[1], v54);
  else
    _dispatch_release_2_tailcall(v56);
}

uint64_t _dispatch_workloop_invoke2(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  BOOL v23;
  BOOL v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  _QWORD *v28;
  uint64_t v29;
  unint64_t *v30;
  unsigned int i;
  _QWORD *v32;
  __int128 v33;
  _DWORD *v34;
  _QWORD *v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v40;
  unint64_t v41;
  __int128 *v42;
  uint64_t v43;
  __int128 *v44;
  __int128 *v45;
  __int128 *v46;
  _QWORD *v47;
  _QWORD *v49;
  uint64_t v50;
  uint64_t v51;
  _DWORD *v52;
  _BYTE *v53;
  int v54;
  unint64_t v55;
  unint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unint64_t v60;
  unint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  unint64_t *v65;
  int v66;
  unint64_t v67;
  unint64_t v68;
  unint64_t v69;
  unsigned int v70;
  uint64_t v71;
  char v72;
  unint64_t v73;
  unsigned int v74;

  v38 = a1;
  v37 = a2;
  v36 = a3;
  v35 = (_QWORD *)a4;
  v34 = 0;
  v34 = *(_DWORD **)(a1 + 200);
  v33 = 0uLL;
  if (v34 && (*v34 & 0x20) != 0)
  {
    v52 = v34 + 10;
    _dispatch_thread_setspecific(24, (uint64_t)(v34 + 10));
  }
  v43 = v38;
  v42 = &v33;
  v46 = &v33;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v33, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v43, 21, (uint64_t)v42, v8, v9, v10, v11);
  do
  {
LABEL_5:
    for (i = 6; i && !*(_QWORD *)(v38 + 152 + 8 * (int)(i - 1)); --i)
      ;
    if (!i)
    {
      *v35 = (*v35 & 1) + 0x40020000000000;
      v45 = &v33;
      _dispatch_thread_setspecific_packed_pair(20, 21, &v33, v12, v13, v14, v15, v16);
      v51 = 0;
      _dispatch_thread_setspecific(24, 0);
      return 0;
    }
    v71 = v38;
    v70 = i;
    v69 = 0;
    v68 = 0;
    v74 = i;
    v67 = (unint64_t)i << 32;
    v66 = 0;
    v65 = (unint64_t *)(v38 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v17 = __ldaxr(v65);
      else
        v17 = __ldxr(v65);
      v69 = v17;
      if ((v17 & 0x700000000) <= v67)
      {
        __clrex();
        v72 = 1;
        goto LABEL_31;
      }
      v73 = v69;
      if ((v69 & 0x8000000000) != 0)
      {
        __clrex();
        v63 = 0x8000000000;
        v62 = 0x8000000000;
        v64 = 0x8000000000;
        v60 = 0;
        v25 = (unint64_t *)(v71 + 56);
        v58 = 0x8000000000;
        v57 = 0x8000000000;
        v59 = 0x8000000000;
        v26 = *(_QWORD *)(v71 + 56);
        do
        {
          v18 = v26;
          do
            v19 = __ldaxr(v25);
          while (v19 == v26 && __stlxr(v26 ^ 0x8000000000, v25));
          v26 = v19;
        }
        while (v19 != v18);
        v56 = v19;
        v60 = v19;
        v55 = v19;
        v61 = v19 ^ v64;
        v72 = 0;
        goto LABEL_31;
      }
      v68 = v69 & 0xFFFFFFF8FFFFFFFFLL | v67;
      if (_os_atomic_mo_has_release(0))
      {
        LOBYTE(v66) = __stlxr(v68, v65) == 0;
        v66 = v66;
      }
      else
      {
        LOBYTE(v66) = __stxr(v68, v65) == 0;
        v66 = v66;
      }
    }
    while (!v66);
    v54 = v66;
    v53 = 0;
    v53 = _dispatch_thread_getspecific(0x1DuLL);
    if (v53)
    {
      v53[45] = v53[45] & 0xFD | 2;
      _dispatch_return_to_kernel();
    }
    v72 = 1;
LABEL_31:
    ;
  }
  while (((v72 ^ 1) & 1) != 0);
  *(_BYTE *)(v38 + 100) = i;
  v30 = (unint64_t *)(v38 + 104 + 8 * (int)(i - 1));
  v29 = *v30;
  if (!*v30)
    v29 = _dispatch_wait_for_enqueuer(v30, v38 + 152 + 8 * (int)(i - 1));
  v32 = (_QWORD *)v29;
  while (1)
  {
    v47 = v32;
    v49 = v32;
    if (*v32 <= 0xFFFuLL && (*v47 & 1) != 0)
      break;
    v28 = (_QWORD *)v32[2];
    *(_QWORD *)(v38 + 104 + 8 * (int)(i - 1)) = v28;
    v24 = 0;
    if (!v28)
    {
      v20 = (unint64_t *)(v38 + 152 + 8 * (int)(i - 1));
      do
        v21 = __ldaxr(v20);
      while ((_QWORD *)v21 == v32 && __stlxr(0, v20));
      v24 = v21 != (_QWORD)v32;
    }
    if (v24)
    {
      v27 = v32[2];
      if (!v27)
        v27 = _dispatch_wait_for_enqueuer(v32 + 2, v38 + 152 + 8 * (int)(i - 1));
      v28 = (_QWORD *)v27;
      *(_QWORD *)(v38 + 104 + 8 * (int)(i - 1)) = v27;
    }
    if (_dispatch_thread_getspecific(5uLL))
      _dispatch_return_to_kernel();
    _dispatch_continuation_pop_inline(v32, v37, v36, v38);
    i = *(unsigned __int8 *)(v38 + 100);
    v32 = v28;
    v23 = 0;
    if (v28)
    {
      v40 = v38;
      v41 = (unint64_t)*(unsigned int *)(v38 + 60) << 32;
      v41 &= 0x700000000uLL;
      v23 = HIDWORD(v41) <= i;
    }
    if (!v23)
      goto LABEL_5;
  }
  *(_DWORD *)(v37 + 16) = i;
  *(_QWORD *)(v37 + 8) = v32;
  *(_BYTE *)(v38 + 100) = 0;
  v44 = &v33;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v33, v12, v13, v14, v15, v16);
  v50 = 0;
  _dispatch_thread_setspecific(24, 0);
  return *(_QWORD *)(v38 + 24);
}

void _dispatch_workloop_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v14;
  BOOL v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  BOOL v20;
  unint64_t *v21;
  _BOOL4 v22;
  unint64_t v23;
  unint64_t v24;
  _QWORD *v25;
  unint64_t *v26;
  unsigned int i;
  uint64_t v28;
  unsigned int v32;
  unint64_t v33;
  unint64_t v34;
  BOOL v36;

  v28 = 0;
LABEL_2:
  for (i = 6; i; --i)
  {
    if (*(_QWORD *)(a1 + 152 + 8 * (int)(i - 1)))
    {
      v26 = (unint64_t *)(a1 + 104 + 8 * (int)(i - 1));
      v25 = (_QWORD *)*v26;
      if (!*v26)
        v25 = (_QWORD *)_dispatch_wait_for_enqueuer(v26, a1 + 152 + 8 * (int)(i - 1));
      if (*v25 <= 0xFFFuLL && (*v25 & 0x81) != 0)
      {
        _dispatch_workloop_drain_barrier_waiter(a1, v25, i, a3, 0);
        return;
      }
      v28 = 1;
    }
  }
  v20 = 0;
  if (v28)
    v20 = (a3 & 1) == 0;
  if (v20)
  {
    _dispatch_retain_2(a1);
    a3 |= 1u;
  }
LABEL_18:
  v21 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v3 = __ldaxr(v21);
    else
      v3 = __ldxr(v21);
    v24 = v3;
    if ((v3 & 0x2000000000) != 0 && (v3 & 2) != 0 && (v3 & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership(a1);
      v18 = (unint64_t *)(a1 + 56);
      v19 = *(_QWORD *)(a1 + 56);
      do
      {
        v4 = v19;
        do
          v5 = __ldaxr(v18);
        while (v5 == v19 && __stlxr(v19 & 0xFFFFFFF7FFFFFFFDLL, v18));
        v19 = v5;
      }
      while (v5 != v4);
      __clrex();
      goto LABEL_18;
    }
    v34 = v3;
    v33 = (unint64_t)a2 << 32;
    if ((v3 & 0x700000000) < v33)
    {
      v34 = v3 & 0xFFFFFFF8FFFFFFFFLL | v33;
      if (v3 & 0x1000000000 | v33 & 0x1000000000)
        v34 |= 0x800000000uLL;
    }
    if (v28)
    {
      v23 = (v34 - 0x40020000000000) & 0xFFFFFFF700000000 | 1;
    }
    else
    {
      if ((v3 & 0x8000000000) != 0)
      {
        __clrex();
        v16 = (unint64_t *)(a1 + 56);
        v17 = *(_QWORD *)(a1 + 56);
        do
        {
          v6 = v17;
          do
            v7 = __ldaxr(v16);
          while (v7 == v17 && __stlxr(v17 ^ 0x8000000000, v16));
          v17 = v7;
        }
        while (v7 != v6);
        goto LABEL_2;
      }
      if ((v3 & 0x2000000000) != 0)
        v23 = (v34 - 0x40020000000000) & 0xFFFFFFF000000000;
      else
        v23 = (v34 - 0x40020000000000) & 0xFFFFFFF000000001;
    }
    if (_os_atomic_mo_has_release(3))
      v22 = __stlxr(v23, v21) == 0;
    else
      v22 = __stxr(v23, v21) == 0;
  }
  while (!v22);
  v14 = ((v24 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v14)
    _dispatch_abort(4827, v14, v8, v9, v10, v11, v12, v13);
  if ((v24 & 0x4000000000) != 0)
    _dispatch_abort(4828, (v24 & 0x4000000000) == 0, v8, v9, v10, v11, v12, v13);
  if ((v24 & 0x2000000000) != 0)
  {
    if ((v23 & 0x4000000000) != 0)
      _dispatch_abort(4845, (v23 & 0x4000000000) == 0, v8, v9, v10, v11, v12, v13);
    if ((v24 & 1) != 0 || (v23 & 1) != 0 || (v24 & 2) == 0)
    {
      _dispatch_event_loop_end_ownership((unsigned int *)a1, v24, v23, a3, v10, v11, v12, v13);
      return;
    }
    _dispatch_event_loop_assert_not_owned(a1);
    goto LABEL_96;
  }
  v15 = 0;
  if ((v24 & 0x1000000000) != 0)
    v15 = (v24 & 0x800000000) != 0;
  if (v15)
  {
    v32 = _dispatch_thread_getspecific(0x19uLL);
    if ((BYTE4(v24) & 7u) > (v32 & 0xF0000) >> 16)
      _dispatch_thread_setspecific(25, v32 & 0xFFF0FFFF | ((BYTE4(v24) & 7) << 16));
  }
  if (!v28)
    goto LABEL_96;
  if (((v24 ^ v23) & 1) != 0)
  {
    if ((v23 & 0x4000000001) == 0)
      _dispatch_abort(4864, (v23 & 0x4000000001) != 0, v8, v9, v10, v11, v12, v13);
    if ((a3 & 1) == 0)
      _dispatch_abort(1866, a3 & 1, v8, v9, v10, v11, v12, v13);
    if ((v23 & 0x2000000000) != 0)
      _dispatch_event_loop_poke((unsigned int *)a1, v23, 1, v9, v10, v11, v12, v13);
    else
      (*(void (**)(_QWORD, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24)
                                                                                           + 72))(*(_QWORD *)(a1 + 24), a1, (v23 & 0x700000000) >> 32, v9, v10, v11);
    return;
  }
  if ((v23 & 0xFF80000000000000) != 0 || (v23 & 0x4000000000) != 0 || (v23 & 1) == 0 && (v23 & 0xFFFFFFFC) == 0)
  {
LABEL_96:
    if ((a3 & 1) != 0)
      _dispatch_release_2_tailcall((unsigned int *)a1);
    return;
  }
  v36 = (v23 & 0xFF80000000000000) == 0 && (v23 & 0x4000000000) == 0 && ((v23 & 1) != 0 || (v23 & 0xFFFFFFFC) != 0);
  if (!v36)
    _dispatch_abort(5301, v36, v8, v9, v10, v11, v12, v13);
  if ((v23 & 0x2000000000) != 0)
    _dispatch_event_loop_poke((unsigned int *)a1, v23, a3 | 0x80000000, v9, v10, v11, v12, v13);
  else
    _dispatch_queue_wakeup_with_override_slow(a1, v23, a3);
}

void _dispatch_workloop_push(uint64_t a1, _QWORD *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v12;
  unsigned int v13;

  v13 = a3;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81) != 0)
  {
    _dispatch_workloop_push_waiter(a1, (unint64_t)a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    if (a3 < (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8)
      v13 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
    if (!v13)
      v13 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    a2[2] = 0;
    _dispatch_thread_setspecific(122, a1 + 152 + 8 * (int)(v13 - 1));
    v10 = (unint64_t *)(a1 + 152 + 8 * (int)(v13 - 1));
    v11 = *v10;
    do
    {
      v8 = v11;
      do
        v9 = __ldaxr(v10);
      while (v9 == v11 && __stlxr((unint64_t)a2, v10));
      v11 = v9;
    }
    while (v9 != v8);
    v12 = v9;
    if (!v9)
      _dispatch_retain_2_unsafe(a1);
    if (v12)
      *(_QWORD *)(v12 + 16) = a2;
    else
      *(_QWORD *)(a1 + 104 + 8 * (int)(v13 - 1)) = a2;
    _dispatch_thread_setspecific(122, 0);
    if (!v12)
      _dispatch_workloop_wakeup(a1, v13, 3);
  }
}

void _dispatch_workloop_push_waiter(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  __int16 v9;
  __int16 v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  BOOL v22;
  int v23;
  BOOL v24;
  unint64_t *v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t *v30;
  unint64_t *v31;
  _BOOL4 v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v37;
  unsigned int v38;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  BOOL v44;
  uint64_t v45;
  BOOL v46;

  v38 = a3;
  v45 = *(_QWORD *)(a2 + 8);
  if ((v45 & 0x20000000) != 0)
    _dispatch_abort(447, (*(_QWORD *)(a2 + 8) & 0x20000000) == 0, a3, a4, a5, a6, a7, a8);
  v8 = (v45 & 0x3FFF00uLL) >> 8;
  v9 = __clz(__rbit32(v8));
  if (v8)
    v10 = v9 + 1;
  else
    v10 = 0;
  if (a3 < (unsigned __int16)((v10 << 8) & 0xF00) >> 8)
    v38 = (unsigned __int16)((v10 << 8) & 0xF00) >> 8;
  if (!v38)
    v38 = 4;
  *(_QWORD *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, a1 + 152 + 8 * (int)(v38 - 1));
  v25 = (unint64_t *)(a1 + 152 + 8 * (int)(v38 - 1));
  v26 = *v25;
  do
  {
    v11 = v26;
    do
      v12 = __ldaxr(v25);
    while (v12 == v26 && __stlxr(a2, v25));
    v26 = v12;
  }
  while (v12 != v11);
  v37 = v12;
  if (v12)
    *(_QWORD *)(v12 + 16) = a2;
  else
    *(_QWORD *)(a1 + 104 + 8 * (int)(v38 - 1)) = a2;
  _dispatch_thread_setspecific(122, 0);
  if (!v37)
  {
    if ((*(_QWORD *)a2 & 0x80) == 0)
      goto LABEL_24;
    v41 = *(_QWORD *)(a1 + 24);
    v24 = 0;
    if (v41 >= (unint64_t)&_dispatch_root_queues)
      v24 = v41 < (unint64_t)&_dispatch_queue_serial_numbers;
    if (v24)
    {
LABEL_24:
      v35 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
      v31 = (unint64_t *)(a1 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v13 = __ldaxr(v31);
        else
          v13 = __ldxr(v31);
        v34 = v13;
        v43 = v13;
        v42 = (unint64_t)v38 << 32;
        if ((v13 & 0x700000000) < v42)
        {
          v43 = v13 & 0xFFFFFFF8FFFFFFFFLL | v42;
          if (v13 & 0x1000000000 | v42 & 0x1000000000)
            v43 |= 0x800000000uLL;
        }
        v33 = v43 | 0x8000000000;
        if ((v13 & 0xFFFFFFFC) == 0 && (v13 & 0x4000000001) == 0)
          v33 = v43 & 0x7700000001 | v35;
        if (_os_atomic_mo_has_release(3))
          v32 = __stlxr(v33, v31) == 0;
        else
          v32 = __stxr(v33, v31) == 0;
      }
      while (!v32);
      if ((v33 & 0x2000000000) != 0 && *(_QWORD *)(a2 + 48) != -4)
      {
        v23 = *(_DWORD *)(a2 + 100);
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFB | (4
                                                            * (v23 == _dispatch_thread_getspecific(3uLL)));
      }
      if (((v34 ^ v33) & 0x40000000000000) != 0)
      {
        if ((*(_BYTE *)(a2 + 106) & 4) == 0)
          goto LABEL_58;
        v30 = (unint64_t *)(a1 + 104 + 8 * (int)(v38 - 1));
        v29 = *v30;
        if (!*v30)
          v29 = _dispatch_wait_for_enqueuer(v30, a1 + 152 + 8 * (int)(v38 - 1));
        if (v29 == a2)
        {
          *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xF7 | 8;
          if ((*(_QWORD *)a2 & 0x80) != 0)
            *(_QWORD *)(a2 + 56) = a1;
          v28 = *(_QWORD *)(a2 + 16);
          *(_QWORD *)(a1 + 104 + 8 * (int)(v38 - 1)) = v28;
          v22 = 0;
          if (!v28)
          {
            v20 = (unint64_t *)(a1 + 152 + 8 * (int)(v38 - 1));
            do
              v21 = __ldaxr(v20);
            while (v21 == a2 && __stlxr(0, v20));
            v22 = v21 != a2;
          }
          if (v22)
          {
            v27 = *(_QWORD *)(a2 + 16);
            if (!v27)
              v27 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 152 + 8 * (int)(v38 - 1));
            *(_QWORD *)(a1 + 104 + 8 * (int)(v38 - 1)) = v27;
          }
        }
        else
        {
LABEL_58:
          _dispatch_workloop_barrier_complete(a1, v38, 0);
        }
      }
      else if (((v34 ^ v33) & 0x700000000) != 0)
      {
        if ((v33 & 0xFF80000000000000) != 0 || (v33 & 0x4000000000) != 0)
          v46 = 0;
        else
          v46 = (v33 & 1) != 0 || (v33 & 0x2000000000) == 0 && (v33 & 0xFFFFFFFC) != 0;
        if (v46)
        {
          v44 = (v33 & 0xFF80000000000000) == 0
             && (v33 & 0x4000000000) == 0
             && ((v33 & 1) != 0 || (v33 & 0xFFFFFFFC) != 0);
          if (!v44)
            _dispatch_abort(5301, v44, v14, v15, v16, v17, v18, v19);
          if ((v33 & 0x2000000000) != 0)
            _dispatch_event_loop_poke((unsigned int *)a1, v33, 0x80000000, v15, v16, v17, v18, v19);
          else
            _dispatch_queue_wakeup_with_override_slow(a1, v33, 0);
        }
      }
    }
    else
    {
      *(_QWORD *)(a2 + 56) = a1;
      *(_QWORD *)a2 &= ~0x80uLL;
      _dispatch_retain_2_unsafe(a1);
      _dispatch_workloop_wakeup(a1, v38, 3);
    }
  }
}

uint64_t _dispatch_retain_2_unsafe(uint64_t a1)
{
  return _dispatch_retain_n_unsafe(a1, 2);
}

uint64_t dispatch_thread_get_current_override_qos_floor()
{
  void *v0;
  unint64_t v2;
  unsigned int v3;
  int v4;
  unsigned int v5;
  uint64_t v6;
  unsigned int v7;

  v6 = 0;
  v0 = _dispatch_thread_getspecific(0x19uLL);
  v7 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
  if ((unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8 <= v7)
    v5 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
  else
    v5 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
  if (v5 <= (v0 & 0xF0000) >> 16)
  {
    v3 = (v0 & 0xF0000) >> 16;
  }
  else
  {
    if ((unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8 <= v7)
      v4 = (unsigned __int16)((unsigned __int16)v0 & 0xF000) >> 12;
    else
      v4 = (unsigned __int16)((unsigned __int16)v0 & 0xF00) >> 8;
    v3 = v4;
  }
  if (v3 != 15)
  {
    LODWORD(v6) = 1;
    v2 = v3 - 1;
    if (v2 <= 5)
      __asm { BR              X8 }
    HIDWORD(v6) = 0;
  }
  return v6;
}

uint64_t dispatch_thread_override_self(int a1)
{
  unint64_t v2;
  unsigned int v3;

  v2 = (a1 - 5);
  if (v2 <= 0x1C)
    __asm { BR              X8 }
  v3 = _dispatch_thread_getspecific(3uLL);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
    _pthread_workqueue_override_start_direct(v3, 255);
  _dispatch_thread_getspecific(0x19uLL);
  return 0;
}

uint64_t dispatch_lock_override_start_with_debounce(uint64_t a1, unsigned int a2, int a3)
{
  unint64_t v4;

  v4 = (a3 - 5);
  if (v4 <= 0x1C)
    __asm { BR              X8 }
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
    return _pthread_workqueue_override_start_direct_check_owner(a2, 255, a1);
  else
    return 0;
}

uint64_t dispatch_lock_override_end(int a1)
{
  unint64_t v2;

  v2 = (a1 - 5);
  if (v2 <= 0x1C)
    __asm { BR              X8 }
  _dispatch_thread_getspecific(0x19uLL);
  return 0;
}

void _dispatch_queue_wakeup(_DWORD *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  BOOL v16;
  BOOL v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t (***v20)();
  unint64_t *v21;
  _BOOL4 v22;
  unint64_t *v23;
  _BOOL4 v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  uint64_t (***v29)();
  unsigned int v30;
  unint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unsigned int v36;
  unsigned int v37;

  v30 = a3;
  v29 = (uint64_t (***)())a4;
  v25 = 1;
  if (a4 == -1)
    _dispatch_abort(5360, 0, a3, -1, a5, a6, a7, a8);
  if (a4 && (a3 & 1) == 0)
  {
    _dispatch_retain_2((uint64_t)a1);
    v30 |= 1u;
  }
  if ((v30 & 4) != 0)
  {
    if (*(_BYTE *)(*(_QWORD *)a1 + 16) != 19)
      _dispatch_abort(5378, *(unsigned __int8 *)(*(_QWORD *)a1 + 16) == 19, a3, a4, a5, a6, a7, a8);
    v37 = a2;
    if (!a2)
      v37 = (a1[21] & 0xF000u) >> 12;
    if (v37 <= (a1[21] & 0xF00u) >> 8)
      v19 = (a1[21] & 0xF00u) >> 8;
    else
      v19 = v37;
    _dispatch_lane_class_barrier_complete(a1, v19, v30, v29, 0x40020000000000);
    return;
  }
  if (v29)
  {
    if (v29 == &_dispatch_mgr_q)
      v25 = 0x4000000000;
    v36 = a2;
    if (!a2)
      v36 = (a1[21] & 0xF000u) >> 12;
    if (v36 <= (a1[21] & 0xF00u) >> 8)
      v18 = (a1[21] & 0xF00u) >> 8;
    else
      v18 = v36;
    v23 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v8 = __ldaxr(v23);
      else
        v8 = __ldxr(v23);
      v27 = v8;
      v35 = v8;
      v34 = (unint64_t)v18 << 32;
      if ((v8 & 0x700000000) < v34)
      {
        v35 = v8 & 0xFFFFFFF8FFFFFFFFLL | v34;
        if (v8 & 0x1000000000 | v34 & 0x1000000000)
          v35 |= 0x800000000uLL;
      }
      v26 = v35;
      if ((v30 & 0x20) != 0 && (v8 & 0x180000000000000) == 0x80000000000000)
        v26 = v35 & 0xFF7FFFFFFFFFFFFFLL;
      v17 = 0;
      if ((v26 & 0xFF80000000000000) == 0)
      {
        v17 = 0;
        if ((v8 & 0x4000000001) == 0)
        {
          v16 = 1;
          if ((v8 & 0xFFFFFFFC) != 0)
            v16 = v25 != 0x4000000000;
          v17 = v16;
        }
      }
      if (v17)
        v26 |= v25;
      if ((v30 & 2) != 0)
      {
        v26 |= 0x8000000000uLL;
      }
      else if (v26 == v8)
      {
        goto LABEL_64;
      }
      if (_os_atomic_mo_has_release(3))
        v24 = __stlxr(v26, v23) == 0;
      else
        v24 = __stxr(v26, v23) == 0;
    }
    while (!v24);
  }
  else
  {
    if (!a2)
      goto LABEL_104;
    v21 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v15 = __ldaxr(v21);
      else
        v15 = __ldxr(v21);
      v27 = v15;
      if ((v15 & 0xFFFFFFFC) == 0 && (v15 & 0x4000000001) == 0)
        goto LABEL_64;
      v33 = v15;
      v32 = (unint64_t)a2 << 32;
      if ((v15 & 0x700000000) < v32)
      {
        v33 = v15 & 0xFFFFFFF8FFFFFFFFLL | v32;
        if (v15 & 0x1000000000 | v32 & 0x1000000000)
          v33 |= 0x800000000uLL;
      }
      v26 = v33;
      if ((v15 & 0x2000000000) != 0 && (v15 & 0xFF80000000000000) == 0 && (v15 & 0x4000000000) == 0)
        v26 = v33 | 1;
      if (v26 == v15)
      {
LABEL_64:
        __clrex();
        goto LABEL_104;
      }
      if (_os_atomic_mo_has_release(0))
        v22 = __stlxr(v26, v21) == 0;
      else
        v22 = __stxr(v26, v21) == 0;
    }
    while (!v22);
    v29 = (uint64_t (***)())(&dword_0 + 1);
    if (((v27 ^ v26) & 1) != 0 && (v30 & 1) == 0)
    {
      _dispatch_retain_2((uint64_t)a1);
      v30 |= 1u;
    }
  }
  if (((v27 ^ v26) & v25) != 0)
  {
    if (v29 == (uint64_t (***)())((char *)&dword_0 + 1))
      v20 = (uint64_t (***)())*((_QWORD *)a1 + 3);
    else
      v20 = v29;
    if ((v26 & 0x4000000001) == 0)
      _dispatch_abort(5519, (v26 & 0x4000000001) != 0, v9, v10, v11, v12, v13, v14);
    if ((v30 & 1) == 0)
      _dispatch_abort(1866, v30 & 1, v9, v10, v11, v12, v13, v14);
    if ((v26 & 0x2000000000) != 0)
      _dispatch_event_loop_poke(a1, v26, 1, v10, v11, v12, v13, v14);
    else
      ((void (*)(uint64_t (***)(), _DWORD *, unint64_t, uint64_t, uint64_t, uint64_t))(*v20)[9])(v20, a1, (v26 & 0x700000000) >> 32, v10, v11, v12);
    return;
  }
  if (((v27 ^ v26) & 0x700000000) != 0
    && (v26 & 0xFF80000000000000) == 0
    && (v26 & 0x4000000000) == 0
    && ((v26 & 1) != 0 || (v26 & 0xFFFFFFFC) != 0))
  {
    if ((v26 & 0xFF80000000000000) != 0 || (v26 & 0x4000000000) != 0 || (v26 & 1) == 0 && (v26 & 0xFFFFFFFC) == 0)
      _dispatch_abort(5301, 0, v9, v10, v11, v12, v13, v14);
    if ((v26 & 0x2000000000) != 0)
      _dispatch_event_loop_poke(a1, v26, v30 | 0x80000000, v10, v11, v12, v13, v14);
    else
      _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v26, v30);
    return;
  }
LABEL_104:
  if ((v30 & 1) != 0)
    _dispatch_release_2_tailcall(a1);
}

void _dispatch_lane_class_barrier_complete(unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t (***a4)(), uint64_t a5)
{
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v16;
  BOOL v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t *v20;
  unint64_t v21;
  uint64_t (***v22)();
  unint64_t *v23;
  _BOOL4 v24;
  uint64_t (***v25)();
  uint64_t v26;
  unint64_t v27;
  unint64_t v28;
  uint64_t v29;
  unsigned int v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;

  if (a4 == &_dispatch_mgr_q)
  {
    v25 = &_dispatch_mgr_q;
    v26 = 0x4000000000;
  }
  else if (a4)
  {
    if (a4 == (uint64_t (***)())((char *)&dword_0 + 1))
      v22 = (uint64_t (***)())*((_QWORD *)a1 + 3);
    else
      v22 = a4;
    v25 = v22;
    v26 = 1;
  }
  else
  {
    v25 = 0;
    v26 = 0;
  }
LABEL_9:
  v23 = (unint64_t *)(a1 + 14);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v5 = __ldaxr(v23);
    else
      v5 = __ldxr(v23);
    v28 = v5;
    if ((v5 & 0x2000000000) != 0 && (v5 & 2) != 0 && (v5 & 0x800000001) != 0)
    {
      _dispatch_event_loop_ensure_ownership((uint64_t)a1);
      v20 = (unint64_t *)(a1 + 14);
      v21 = *((_QWORD *)a1 + 7);
      do
      {
        v6 = v21;
        do
          v7 = __ldaxr(v20);
        while (v7 == v21 && __stlxr(v21 & 0xFFFFFFF7FFFFFFFDLL, v20));
        v21 = v7;
      }
      while (v7 != v6);
      __clrex();
      goto LABEL_9;
    }
    v36 = v5 - a5;
    v35 = (unint64_t)a2 << 32;
    if (((v5 - a5) & 0x700000000) < v35)
    {
      v36 = v36 & 0xFFFFFFF8FFFFFFFFLL | v35;
      if ((v36 & 0x1000000000) != 0)
        v36 |= 0x800000000uLL;
    }
    v27 = v36 & 0xFFFFFFF700000001;
    if ((v5 & 0xFF80000000000000) != 0)
    {
      if ((v5 & 0x2000000000) != 0)
        v27 = v36 & 0xFFFFFFF700000000;
    }
    else if (v26)
    {
      if ((v5 & 0x4000000001) == 0)
        v27 |= v26;
    }
    else
    {
      if ((v5 & 0x8000000000) != 0)
      {
        __clrex();
        v18 = (unint64_t *)(a1 + 14);
        v19 = *((_QWORD *)a1 + 7);
        do
        {
          v8 = v19;
          do
            v9 = __ldaxr(v18);
          while (v9 == v19 && __stlxr(v19 ^ 0x8000000000, v18));
          v19 = v9;
        }
        while (v9 != v8);
        (*(void (**)(unsigned int *, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, a2, a3 | 4);
        return;
      }
      v27 = v36 & 0xFFFFFFF000000001;
    }
    if (_os_atomic_mo_has_release(3))
      v24 = __stlxr(v27, v23) == 0;
    else
      v24 = __stxr(v27, v23) == 0;
  }
  while (!v24);
  v29 = v28 - a5;
  v16 = ((v29 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
  if (!v16)
    _dispatch_abort(1424, v16, v10, v11, v12, v13, v14, v15);
  if ((v29 & 0x4000000000) != 0)
    _dispatch_abort(1425, (v29 & 0x4000000000) == 0, v10, v11, v12, v13, v14, v15);
  if ((v29 & 0x2000000000) == 0)
  {
    v17 = 0;
    if ((v29 & 0x1000000000) != 0)
      v17 = (v29 & 0x800000000) != 0;
    if (v17)
    {
      v34 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v29) & 7u) > (v34 & 0xF0000) >> 16)
        _dispatch_thread_setspecific(25, v34 & 0xFFF0FFFF | ((BYTE4(v29) & 7) << 16));
    }
    if (v25)
    {
      if (((v29 ^ v27) & v26) != 0)
      {
        if ((v27 & 0x4000000001) == 0)
          _dispatch_abort(1464, (v27 & 0x4000000001) != 0, v10, v11, v12, v13, v14, v15);
        if ((a3 & 1) == 0)
          _dispatch_abort(1866, a3 & 1, v10, v11, v12, v13, v14, v15);
        if ((v27 & 0x2000000000) != 0)
          _dispatch_event_loop_poke(a1, v27, 1, v11, v12, v13, v14, v15);
        else
          ((void (*)(uint64_t (***)(), unsigned int *, unint64_t, uint64_t, uint64_t, uint64_t))(*v25)[9])(v25, a1, (v27 & 0x700000000) >> 32, v11, v12, v13);
        return;
      }
      if ((v27 & 0xFF80000000000000) == 0
        && (v27 & 0x4000000000) == 0
        && ((v27 & 1) != 0 || (v27 & 0xFFFFFFFC) != 0))
      {
        v37 = (v27 & 0xFF80000000000000) == 0
           && (v27 & 0x4000000000) == 0
           && ((v27 & 1) != 0 || (v27 & 0xFFFFFFFC) != 0);
        if (!v37)
          _dispatch_abort(5301, v37, v10, v11, v12, v13, v14, v15);
        if ((v27 & 0x2000000000) != 0)
          _dispatch_event_loop_poke(a1, v27, a3 | 0x80000000, v11, v12, v13, v14, v15);
        else
          _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v27, a3);
        return;
      }
    }
    if ((a3 & 1) == 0)
      return;
LABEL_93:
    _dispatch_release_2_tailcall(a1);
    return;
  }
  if ((v27 & 0x4000000000) != 0)
    _dispatch_abort(1442, (v27 & 0x4000000000) == 0, v10, v11, v12, v13, v14, v15);
  if ((v29 & 1) != 0 || (v27 & 1) != 0 || (v29 & 2) == 0)
  {
    _dispatch_event_loop_end_ownership(a1, v29, v27, a3, v12, v13, v14, v15);
    return;
  }
  _dispatch_event_loop_assert_not_owned((uint64_t)a1);
  if ((a3 & 1) != 0)
    goto LABEL_93;
}

void _dispatch_lane_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a3 & 4) != 0)
    _dispatch_lane_barrier_complete(a1, a2, a3, a4, a5, a6, a7, a8);
  else
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(_QWORD *)(a1 + 48) != 0, a5, a6, a7, a8);
}

void _dispatch_lane_barrier_complete(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  uint64_t (***v10)();
  BOOL v14;
  BOOL v15;
  _DWORD *v16;

  v10 = 0;
  if (*(_QWORD *)(a1 + 48) && (*(_QWORD *)(a1 + 56) & 0xFF80000000000000) == 0)
  {
    v16 = *(_DWORD **)(a1 + 104);
    if (!v16)
      v16 = (_DWORD *)_dispatch_wait_for_enqueuer((unint64_t *)(a1 + 104), a1 + 48);
    v8 = 1;
    if (*(_WORD *)(a1 + 80) != 1)
    {
      if (*(_QWORD *)v16 > 0xFFFuLL)
        v15 = (*(_QWORD *)(*(_QWORD *)v16 + 16) & 0xF0) == 0x10 && (v16[20] & 0x80000) != 0;
      else
        v15 = (*(_QWORD *)v16 & 2) != 0;
      v8 = v15;
    }
    if ((v8 & 1) != 0)
    {
      if (*(_QWORD *)v16 <= 0xFFFuLL && (*(_QWORD *)v16 & 0x81) != 0)
      {
        _dispatch_lane_drain_barrier_waiter(a1, (uint64_t)v16, a3, 0);
        return;
      }
    }
    else if (*(unsigned __int16 *)(a1 + 80) > 1u)
    {
      if (*(_QWORD *)v16 > 0xFFFuLL)
        v14 = (*(_QWORD *)(*(_QWORD *)v16 + 16) & 0xF0) == 0x10 && (v16[20] & 0x80000) != 0;
      else
        v14 = (*(_QWORD *)v16 & 2) != 0;
      if (!v14)
      {
        _dispatch_lane_drain_non_barriers(a1, (uint64_t)v16, a3, a4, a5, a6, a7, a8);
        return;
      }
    }
    if ((a3 & 1) == 0)
    {
      _dispatch_retain_2(a1);
      a3 |= 1u;
    }
    v10 = (uint64_t (***)())(&dword_0 + 1);
  }
  _dispatch_lane_class_barrier_complete((unsigned int *)a1, a2, a3, v10, ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000);
}

void _dispatch_lane_push(uint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  BOOL v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unsigned int v14;
  unsigned int v18;
  unsigned int v19;

  v14 = 0;
  if (*a2 <= 0xFFFuLL && (*a2 & 0x81) != 0)
  {
    _dispatch_lane_push_waiter((unsigned int *)a1, (unint64_t)a2, a3);
  }
  else
  {
    if (*(_DWORD *)(a1 + 8) == 0x7FFFFFFF)
      _dispatch_abort(5669, *(_DWORD *)(a1 + 8) != 0x7FFFFFFF, a3, a4, a5, a6, a7, a8);
    if (a3 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8)
      v18 = 0;
    else
      v18 = a3;
    a2[2] = 0;
    _dispatch_thread_setspecific(122, a1 + 48);
    v11 = (unint64_t *)(a1 + 48);
    v12 = *(_QWORD *)(a1 + 48);
    do
    {
      v8 = v12;
      do
        v9 = __ldaxr(v11);
      while (v9 == v12 && __stlxr((unint64_t)a2, v11));
      v12 = v9;
    }
    while (v9 != v8);
    v13 = v9;
    if (v9)
    {
      v19 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32;
      v10 = 1;
      if (v19)
        v10 = v19 < v18;
      if (v10)
      {
        _dispatch_retain_2_unsafe(a1);
        v14 = 1;
      }
    }
    else
    {
      _dispatch_retain_2_unsafe(a1);
      v14 = 3;
    }
    if (v13)
      *(_QWORD *)(v13 + 16) = a2;
    else
      *(_QWORD *)(a1 + 104) = a2;
    _dispatch_thread_setspecific(122, 0);
    if (v14)
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, v18, v14);
  }
}

void _dispatch_lane_push_waiter(unsigned int *a1, unint64_t a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  BOOL v16;
  int v17;
  BOOL v18;
  BOOL v19;
  char v20;
  char v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  _BOOL4 v25;
  unint64_t *v26;
  _BOOL4 v27;
  unint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v35;
  unint64_t v36;
  unint64_t v37;
  unint64_t v38;
  BOOL v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  unint64_t v43;
  BOOL v44;
  BOOL v45;
  char v46;

  if (*(_QWORD *)(a2 + 48) != -4)
    a3 = 0;
  *(_QWORD *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(a1 + 12));
  v22 = (unint64_t *)(a1 + 12);
  v23 = *((_QWORD *)a1 + 6);
  do
  {
    v3 = v23;
    do
      v4 = __ldaxr(v22);
    while (v4 == v23 && __stlxr(a2, v22));
    v23 = v4;
  }
  while (v4 != v3);
  v43 = v4;
  if (v4)
    *(_QWORD *)(v4 + 16) = a2;
  else
    *((_QWORD *)a1 + 13) = a2;
  _dispatch_thread_setspecific(122, 0);
  if (!v43)
  {
    if ((a1[20] & 0x40000) == 0 || (a1[20] & 0x1000000) != 0)
    {
      if ((*(_QWORD *)a2 & 0x80) != 0)
      {
        v21 = 1;
        if ((a1[20] & 0x1000000) == 0)
        {
          v20 = 0;
          if ((*((_QWORD *)a1 + 7) & 0x3000000000) != 0)
          {
            v19 = 0;
            if (*((_QWORD *)a1 + 3) >= (unint64_t)&_dispatch_root_queues)
              v19 = *((_QWORD *)a1 + 3) < (unint64_t)&_dispatch_queue_serial_numbers;
            v20 = !v19;
          }
          v21 = v20;
        }
        v46 = v21 & 1;
      }
      else
      {
        v46 = 0;
      }
    }
    else
    {
      v46 = 1;
    }
    if ((v46 & 1) != 0)
    {
      *(_QWORD *)a2 &= ~0x80uLL;
      *(_QWORD *)(a2 + 56) = a1;
      (*(void (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3, 2);
      return;
    }
    v29 = (uint64_t)(*((unsigned __int16 *)a1 + 40) - 1) << 41;
    v28 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000002;
    v26 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v5 = __ldaxr(v26);
      else
        v5 = __ldxr(v26);
      v31 = v5;
      v38 = v5;
      v37 = (unint64_t)a3 << 32;
      if ((v5 & 0x700000000) < v37)
      {
        v38 = v5 & 0xFFFFFFF8FFFFFFFFLL | v37;
        if (v5 & 0x1000000000 | v37 & 0x1000000000)
          v38 |= 0x800000000uLL;
      }
      v30 = v38 | 0x8000000000;
      v18 = 1;
      if ((v5 & 0xFFFFFFFC) == 0)
        v18 = v5 >= 0x20000000000000;
      if (!v18
        && ((v5 & 0x2000000000) == 0 || (v5 & 0x4000000001) == 0)
        && ((v5 & 0x10000000000) != 0 || (unint64_t)(v30 + v29) < 0x20000000000000))
      {
        v30 = v38 & 0x7700000001 | v28;
      }
      if (_os_atomic_mo_has_release(3))
        v27 = __stlxr(v30, v26) == 0;
      else
        v27 = __stxr(v30, v26) == 0;
    }
    while (!v27);
    if ((v31 & 0x2000000000) != 0 && *(_QWORD *)(a2 + 48) != -4)
    {
      v17 = *(_DWORD *)(a2 + 100);
      *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFB | (4 * (v17 == _dispatch_thread_getspecific(3uLL)));
    }
    if (((v31 ^ v30) & 0x40000000000000) != 0)
    {
      if ((*(_BYTE *)(a2 + 106) & 4) != 0 && *((_QWORD *)a1 + 13) == a2)
      {
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xF7 | 8;
        if ((*(_QWORD *)a2 & 0x80) != 0)
          *(_QWORD *)(a2 + 56) = a1;
        v42 = *(_QWORD *)(a2 + 16);
        *((_QWORD *)a1 + 13) = v42;
        v16 = 0;
        if (!v42)
        {
          v12 = (unint64_t *)(a1 + 12);
          do
            v13 = __ldaxr(v12);
          while (v13 == a2 && __stlxr(0, v12));
          v16 = v13 != a2;
        }
        if (v16)
        {
          v41 = *(_QWORD *)(a2 + 16);
          if (!v41)
            v41 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), (uint64_t)(a1 + 12));
          *((_QWORD *)a1 + 13) = v41;
        }
      }
      else
      {
        _dispatch_lane_barrier_complete((uint64_t)a1, a3, 0, v7, v8, v9, v10, v11);
      }
      return;
    }
    if (((v31 ^ v30) & 0x700000000) == 0)
      return;
    if ((v30 & 0xFF80000000000000) != 0 || (v30 & 0x4000000000) != 0)
      v45 = 0;
    else
      v45 = (v30 & 1) != 0 || (v30 & 0x2000000000) == 0 && (v30 & 0xFFFFFFFC) != 0;
    if (!v45)
      return;
    v39 = (v30 & 0xFF80000000000000) == 0
       && (v30 & 0x4000000000) == 0
       && ((v30 & 1) != 0 || (v30 & 0xFFFFFFFC) != 0);
    if (!v39)
      _dispatch_abort(5301, v39, v6, v7, v8, v9, v10, v11);
    if ((v30 & 0x2000000000) == 0)
    {
      _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v30, 0);
      return;
    }
LABEL_83:
    _dispatch_event_loop_poke(a1, v30, 0x80000000, v7, v8, v9, v10, v11);
    return;
  }
  if (a3)
  {
    v24 = (unint64_t *)(a1 + 14);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v14 = __ldaxr(v24);
      else
        v14 = __ldxr(v24);
      v36 = v14;
      v35 = (unint64_t)a3 << 32;
      if ((v14 & 0x700000000) < v35)
      {
        v36 = v14 & 0xFFFFFFF8FFFFFFFFLL | v35;
        if (v14 & 0x1000000000 | v35 & 0x1000000000)
          v36 |= 0x800000000uLL;
      }
      v30 = v36;
      if (v14 == v36)
      {
        __clrex();
        return;
      }
      if (_os_atomic_mo_has_release(0))
        v25 = __stlxr(v36, v24) == 0;
      else
        v25 = __stxr(v36, v24) == 0;
    }
    while (!v25);
    if ((v36 & 0xFF80000000000000) != 0 || (v36 & 0x4000000000) != 0)
      v44 = 0;
    else
      v44 = (v36 & 1) != 0 || (v36 & 0x2000000000) == 0 && (v36 & 0xFFFFFFFC) != 0;
    if (v44)
    {
      v40 = (v36 & 0xFF80000000000000) == 0
         && (v36 & 0x4000000000) == 0
         && ((v36 & 1) != 0 || (v36 & 0xFFFFFFFC) != 0);
      if (!v40)
        _dispatch_abort(5301, v40, v15, v7, v8, v9, v10, v11);
      if ((v36 & 0x2000000000) == 0)
      {
        _dispatch_queue_wakeup_with_override_slow((uint64_t)a1, v36, 0);
        return;
      }
      goto LABEL_83;
    }
  }
}

void _dispatch_lane_concurrent_push(uint64_t a1, _DWORD *a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  char v9;
  BOOL is_timer;
  char v11;
  char v12;
  char v17;
  BOOL v18;
  unint64_t *v19;
  _BOOL4 v20;
  unint64_t v21;
  char v22;

  v12 = 0;
  if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    if (*(_QWORD *)a2 >= 0x1000uLL)
    {
      v11 = 1;
      if (*(_QWORD *)(*(_QWORD *)a2 + 16) != 1)
      {
        is_timer = 0;
        if (*(_BYTE *)(*(_QWORD *)a2 + 16) == 19)
          is_timer = _dispatch_source_is_timer((uint64_t)a2);
        v11 = is_timer;
      }
      v17 = v11 & 1;
    }
    else
    {
      v17 = 1;
    }
    v12 = v17 ^ 1;
  }
  if ((v12 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
    qword_E4DA8 = (uint64_t)a2;
    __break(1u);
    JUMPOUT(0x36AF8);
  }
  if (*(_QWORD *)(a1 + 48))
    goto LABEL_39;
  if (*(_QWORD *)a2 < 0x1000uLL && (*(_QWORD *)a2 & 0x81) != 0)
    goto LABEL_39;
  if (*(_QWORD *)a2 > 0xFFFuLL)
    v18 = (*(_QWORD *)(*(_QWORD *)a2 + 16) & 0xF0) == 0x10 && (a2[20] & 0x80000) != 0;
  else
    v18 = (*a2 & 2) != 0;
  if (v18)
    goto LABEL_39;
  v19 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(2))
      v8 = __ldaxr(v19);
    else
      v8 = __ldxr(v19);
    v9 = 1;
    if (!(v8 >> 53))
    {
      v9 = 1;
      if ((v8 & 0x8000000000) == 0)
        v9 = BYTE5(v8) & 1;
    }
    if ((v9 & 1) != 0)
    {
      __clrex();
      v22 = 0;
      goto LABEL_37;
    }
    v21 = v8 + 0x20000000000;
    if (_os_atomic_mo_has_release(2))
      v20 = __stlxr(v21, v19) == 0;
    else
      v20 = __stxr(v21, v19) == 0;
  }
  while (!v20);
  v22 = 1;
LABEL_37:
  if (v22 != 1)
LABEL_39:
    _dispatch_lane_push(a1, a2, a3, a4, a5, a6, a7, a8);
  else
    _dispatch_continuation_redirect_push(a1, a2, a3);
}

uint64_t _dispatch_continuation_redirect_push(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  BOOL v4;
  _DWORD *v5;
  _QWORD *v8;
  _QWORD *v10;
  _QWORD *v11;

  v8 = a2;
  v4 = 0;
  if (*a2 > 0xFFFuLL)
    v4 = *(_QWORD *)(*a2 + 16) == 256;
  if (!v4)
  {
    v11 = _dispatch_thread_getspecific(0x16uLL);
    if (v11)
    {
      _dispatch_thread_setspecific(22, v11[2]);
      v10 = v11;
    }
    else
    {
      v10 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    }
    v8[2] = 0;
    *v10 = &unk_E0C98;
    v10[4] = 0;
    v10[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
    v10[6] = a1;
    v10[7] = v8;
    v10[3] = -1;
    v10[1] = -1;
    _dispatch_retain_2(a1);
    v8 = v10;
  }
  else if (!a2[5])
  {
    a2[5] = (*(_DWORD *)(a1 + 80) & 0x30000u) << 8;
  }
  v5 = *(_DWORD **)(a1 + 24);
  if (!a3)
    a3 = (v5[21] & 0xF00u) >> 8;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)v5 + 72))(v5, v8, a3);
}

uint64_t dispatch_async_swift_job(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v4;
  unsigned int v5;

  v4 = *(_QWORD *)(*(_QWORD *)a2 + 16);
  if (v4 != 1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Used Swift only SPI to enqueue non-Swift runtime objects into dispatch";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x371B8);
  }
  switch(a3)
  {
    case 5:
      v5 = 1;
      break;
    case 9:
      v5 = 2;
      break;
    case 17:
      v5 = 3;
      break;
    case 21:
      v5 = 4;
      break;
    case 25:
      v5 = 5;
      break;
    case 33:
      v5 = 6;
      break;
    default:
      v5 = 0;
      break;
  }
  return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)a1 + 72))(a1, a2, v5);
}

void _dispatch_channel_dispose(uint64_t a1, _BYTE *a2)
{
  *(_QWORD *)(a1 + 88) = 0;
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_channel_xref_dispose(uint64_t a1)
{
  if (*(_QWORD *)(*(_QWORD *)(a1 + 88) + 24) && (*(_DWORD *)(a1 + 80) & 0x10000000) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a channel that has not been cancelled, but has a can"
                           "cel acknowledgement callback";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x373F8);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 2);
}

void _dispatch_channel_invoke(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;
  BOOL v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  unsigned int *v41;
  unsigned int v42;
  int v43;
  BOOL v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  __int128 v48;
  _QWORD *v49;
  _QWORD *v50;
  unsigned int v51;
  _QWORD *v52;
  void *v53;
  uint64_t v54;
  _BYTE v55[9];
  _QWORD *v56;
  uint64_t (*v57)(_QWORD *, uint64_t, int, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  int v58;
  unsigned int v59;
  uint64_t v60;
  _QWORD *v61;
  int v62;
  int v63;
  int v64;
  _QWORD *v65;
  unsigned int v66;
  unsigned int v67;
  int v68;
  int v69;
  int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  int v75;
  int v76;
  _QWORD *v77;
  uint64_t v78;
  _BOOL8 v79;
  int v80;
  int v81;
  _QWORD *v82;
  void *v83;
  _QWORD *v84;
  unsigned int v85;
  unsigned int v86;
  int v87;
  unsigned int v88;
  unsigned int v89;
  unsigned int v90;
  unsigned int v91;
  __int128 *v92;
  _QWORD *v93;
  __int128 *v94;
  unsigned int v95;
  unsigned int v96;
  __int128 *v97;
  _BOOL4 v98;
  unint64_t *v99;
  _BOOL4 v100;
  unsigned int v101;
  uint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  int v108;
  _QWORD *v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  _BOOL8 v113;
  uint64_t v114;
  _BOOL8 v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unsigned int v119;
  unsigned int v120;
  unsigned int v121;
  unsigned int v122;
  int v123;
  int v124;
  unsigned int v125;
  _QWORD *v126;
  int v127;
  unint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  unint64_t v133;
  unint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t *v138;
  int v139;
  unint64_t v140;
  unint64_t v141;
  BOOL v142;
  uint64_t v143;
  _QWORD *v144;
  char v145;
  unint64_t v146;
  unint64_t v147;
  uint64_t v148;
  unint64_t v149;
  uint64_t v150;
  unint64_t v151;
  int v152;
  unsigned int v153;
  unint64_t v154;
  uint64_t v155;
  unint64_t v156;
  unsigned int v157;
  unint64_t v158;
  uint64_t v159;
  unsigned int v160;
  unsigned int v161;
  unsigned int v162;
  unsigned int v163;
  uint64_t v164;
  unsigned int v165;
  int v166;
  int v167;
  uint64_t v168;
  _QWORD *v169;
  int v170;
  int v171;
  int v172;
  _QWORD *v173;
  uint64_t v174;
  uint64_t v175;
  _QWORD *v176;
  void *v177;
  _QWORD *v178;
  uint64_t v179;
  uint64_t v180;
  uint64_t v181;
  _QWORD *v182;
  unsigned int v183;
  _QWORD *v184;

  v61 = a1;
  v60 = a2;
  v59 = a3;
  v58 = 8;
  v57 = _dispatch_channel_invoke2;
  v56 = a1;
  v55[8] = 0;
  *(_QWORD *)v55 = (a3 & 1) == 0;
  v54 = 0;
  if ((a3 & 3) == 0)
  {
    v56[2] = -1985229329;
    v53 = _dispatch_thread_getspecific(0x14uLL);
    v52 = v56;
    v83 = v53;
    v82 = v56;
    v81 = 0;
    v80 = 0;
    v177 = v53;
    v176 = v56;
  }
  v59 |= v58;
  if ((v59 & 2) != 0)
  {
    v54 = 0x40020000000001;
    goto LABEL_54;
  }
  v109 = v56;
  v108 = v59;
  v107 = 0;
  v107 = (uint64_t)(*((unsigned __int16 *)v56 + 40) - 1) << 41;
  v122 = _dispatch_thread_getspecific(3uLL);
  v106 = v122 & 0xFFFFFFFC | 0x20000000000000;
  v104 = 0;
  v103 = 0;
  v102 = 0;
  v105 = 0xFFE00000FFFFFFFCLL;
  if ((v59 & 1) != 0)
  {
    v105 |= 0x4000000000uLL;
    v102 = 0;
  }
  else if ((v108 & 0x40000) != 0)
  {
    v102 = 0x4000000000;
  }
  else
  {
    v105 |= 0x4000000000uLL;
    v102 = 1;
  }
  v115 = (v108 & 2) == 0;
  v114 = 1323;
  if ((v108 & 2) != 0)
    _dispatch_abort(v114, v115, v8, v9, v10, v11, v12, v13);
  v101 = 0;
  v119 = _dispatch_thread_getspecific(0x19uLL);
  v121 = v119 & 0xF00;
  v118 = v121 >> 8;
  v120 = v119 & 0xF000;
  v117 = v120 >> 12;
  v123 = v119 & 0xF0000;
  v116 = (v119 & 0xF0000) >> 16;
  if (v121 >> 8 <= v120 >> 12)
    v47 = v117;
  else
    v47 = v118;
  if (v47 <= v116)
  {
    v45 = v116;
  }
  else
  {
    if (v118 <= v117)
      v46 = v117;
    else
      v46 = v118;
    v45 = v46;
  }
  v101 = v45;
LABEL_22:
  v100 = 0;
  v99 = v109 + 7;
  while (1)
  {
    v16 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v99) : __ldxr(v99);
    v104 = v16;
    v103 = v16;
    if ((v16 & v105) != 0)
      break;
    v154 = v104;
    v153 = v101;
    v156 = v104;
    v44 = 0;
    if ((v104 & 0x1000000000) != 0)
    {
      v155 = v154 & 0x700000000;
      v44 = v153 < (v154 & 0x700000000) >> 32;
    }
    if (v44)
    {
      __clrex();
      v158 = v104;
      v159 = v104 & 0x700000000;
      v157 = (v104 & 0x700000000) >> 32;
      v163 = _dispatch_thread_getspecific(3uLL);
      v162 = v157;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v165 = v162;
        v164 = 0;
        if (v162)
          v164 = 1 << (v165 + 7);
        _pthread_workqueue_override_start_direct(v163, v164 | 0xFF);
      }
      v161 = v157;
      v160 = _dispatch_thread_getspecific(0x19uLL);
      v166 = v160 & 0xF0000;
      if (v157 > (v160 & 0xF0000) >> 16)
      {
        v160 = v160 & 0xFFF0FFFF | (v161 << 16);
        _dispatch_thread_setspecific(25, v160);
      }
      v101 = v157;
      goto LABEL_22;
    }
    v103 = v103 & 0x7700000001 | v106;
    v111 = v104;
    if ((v104 & 0x10000000000) != 0 || v104 + v107 < 0x20000000000000)
      v103 |= 0x40000000000000uLL;
LABEL_44:
    if (_os_atomic_mo_has_release(2))
      v100 = __stlxr(v103, v99) == 0;
    else
      v100 = __stxr(v103, v99) == 0;
    if (v100)
      goto LABEL_48;
  }
  if (v102)
  {
    v103 ^= v102;
    goto LABEL_44;
  }
  __clrex();
LABEL_48:
  v98 = v100;
  v113 = (v104 & v102) == v102;
  v112 = 1356;
  if ((v104 & v102) != v102)
    _dispatch_abort(v112, v113, v14, v15, a5, a6, a7, a8);
  if ((v104 & v105) != 0)
  {
    v110 = 0;
  }
  else
  {
    v103 &= v102 | 0x60000000000000;
    v104 &= 0x3FFE0000000000uLL;
    v110 = v103 - v104;
  }
  v54 = v110;
LABEL_54:
  if (v54)
  {
    v51 = 0;
    if ((v59 & 0x40000) != 0)
    {
      v51 = 0;
    }
    else
    {
      v87 = *((_DWORD *)v56 + 21);
      v86 = _dispatch_thread_getspecific(0x19uLL);
      v85 = v86;
      if (v86)
      {
        if ((v87 & 0xFFF) != 0)
        {
          v85 &= 0x880F0000;
          if ((v86 & 0xFFF) <= (v87 & 0xFFFu))
            v43 = v87 & 0xFFF;
          else
            v43 = v86 & 0xFFF;
          v85 |= v43;
          v89 = v87 & 0xF000;
          v91 = v85 & 0xF00;
          if (v89 >> 12 <= v91 >> 8)
            v87 &= 0x40000000u;
          else
            v87 &= 0x4400F000u;
          v85 |= v87;
        }
        else
        {
          if ((v85 & 0xFFF) != 0)
            v85 |= 0x40000000u;
          v88 = v87 & 0xF000;
          v90 = v85 & 0xF00;
          if (v88 >> 12 > v90 >> 8)
            v85 = v85 & 0xFFFF0FFF | v87 & 0x400F000;
        }
      }
      else
      {
        v85 = v87 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v85);
      v51 = v86;
    }
    if ((v59 & 0x100000) != 0)
    {
      v65 = v61;
      v64 = 0;
      v63 = *((_DWORD *)v61 + 20);
      v64 = v63;
      v62 = v63;
      if ((v63 & 0x400000) != 0)
      {
        v77 = v61;
        v76 = 0x400000;
        v74 = -4194305;
        v73 = -4194305;
        v75 = -4194305;
        v71 = 0;
        v41 = (unsigned int *)(v61 + 10);
        v69 = -4194305;
        v68 = -4194305;
        v70 = -4194305;
        v42 = *((_DWORD *)v61 + 20);
        do
        {
          v17 = v42;
          do
            v18 = __ldaxr(v41);
          while (v18 == v42 && __stlxr(v42 & 0xFFBFFFFF, v41));
          v42 = v18;
        }
        while (v18 != v17);
        v67 = v18;
        v71 = v18;
        v66 = v18;
        v72 = v18 & v75;
      }
    }
    v50 = v56;
    v126 = v56;
    v125 = v59;
    v124 = 0;
    v169 = v56;
    v168 = 256;
    v175 = 1;
    v174 = 730;
    v167 = 0;
    v173 = v56;
    v172 = 0;
    v171 = *((_DWORD *)v56 + 20);
    v172 = v171;
    v170 = v171;
    v167 = v171 & 0x30000;
    v124 = (v171 & 0x30000) << 8;
    if (v124)
      v125 = v125 & 0xFCFFFFFF | v124;
    v59 = v125;
    do
    {
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
        _dispatch_last_resort_autorelease_pool_push(v60);
      v49 = v56;
      *(_QWORD *)&v55[1] = v57(v56, v60, v59, (uint64_t)&v54, a5, a6, a7, a8);
      if ((v59 & 2) != 0 && (v59 & 0x1000000) == 0)
      {
        v48 = 0uLL;
        v93 = v56;
        v92 = &v48;
        v97 = &v48;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v48, v20, v21, v22, v23, v24);
        _dispatch_thread_setspecific_pair(20, (uint64_t)v93, 21, (uint64_t)v92, v25, v26, v27, v28);
        _dispatch_last_resort_autorelease_pool_pop(v60);
        v94 = &v48;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v48, v29, v30, v31, v32, v33);
      }
      v79 = *(_QWORD *)&v55[1] != 1;
      v78 = 1955;
      if (*(_QWORD *)&v55[1] == 1)
        _dispatch_abort(v78, v79, v19, v20, v21, v22, v23, v24);
      v40 = 0;
      if (*(_QWORD *)&v55[1])
        v40 = *(_QWORD *)&v55[1] != -1;
      if (v40)
        break;
      v144 = v56;
      v143 = v54;
      v142 = *(_QWORD *)&v55[1] == 0;
      v141 = 0;
      v140 = 0;
      v139 = 0;
      v138 = v56 + 7;
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v34 = __ldaxr(v138);
        else
          v34 = __ldxr(v138);
        v141 = v34;
        v140 = (v34 - v143) & 0xFFFFFFF700000001;
        v146 = v34;
        if ((v34 & 0xFF80000000000000) == 0)
        {
          v147 = v141;
          if ((v141 & 0x8000000000) != 0)
          {
            __clrex();
            v136 = 0x8000000000;
            v135 = 0x8000000000;
            v137 = 0x8000000000;
            v133 = 0;
            v38 = v144 + 7;
            v131 = 0x8000000000;
            v130 = 0x8000000000;
            v132 = 0x8000000000;
            v39 = v144[7];
            do
            {
              v35 = v39;
              do
                v36 = __ldaxr(v38);
              while (v36 == v39 && __stlxr(v39 ^ 0x8000000000, v38));
              v39 = v36;
            }
            while (v36 != v35);
            v129 = v36;
            v133 = v36;
            v128 = v36;
            v134 = v36 ^ v137;
            v145 = 0;
            goto LABEL_119;
          }
          if (v142)
            v140 &= 0xFFFFFFF8FFFFFFFFLL;
          else
            v140 |= 0x8000000000uLL;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v139) = __stlxr(v140, v138) == 0;
          v139 = v139;
        }
        else
        {
          LOBYTE(v139) = __stxr(v140, v138) == 0;
          v139 = v139;
        }
      }
      while (!v139);
      v127 = v139;
      v149 = v141;
      v151 = v141;
      v37 = 0;
      if ((v141 & 0x1000000000) != 0)
        v37 = (v149 & 0x800000000) != 0;
      if (v37)
      {
        v148 = v141 & 0x700000000;
        v150 = v141 & 0x700000000;
        LODWORD(v150) = _dispatch_thread_getspecific(0x19uLL);
        v152 = v150 & 0xF0000;
        if (HIDWORD(v150) > (v150 & 0xF0000) >> 16)
        {
          LODWORD(v150) = v150 & 0xFFF0FFFF;
          LODWORD(v150) = v150 | (HIDWORD(v150) << 16);
          _dispatch_thread_setspecific(25, v150);
        }
      }
      v145 = 1;
LABEL_119:
      if ((v145 & 1) != 0)
      {
        v54 = 0;
        *(_QWORD *)&v55[1] = 0;
        break;
      }
      *(_QWORD *)&v55[1] = _dispatch_thread_getspecific(0x14uLL);
    }
    while ((*(_QWORD *)(**(_QWORD **)&v55[1] + 16) & 0x10000) != 0 || (v55[0] & 1) == 0);
    if ((v59 & 0x40000) == 0)
    {
      v96 = v51;
      v95 = 0;
      v95 = _dispatch_thread_getspecific(0x19uLL);
      v96 &= 0xFFF0FFFF;
      v96 |= v95 & 0xF0000;
      _dispatch_thread_setspecific(25, v96);
    }
  }
  if ((v55[0] & 1) != 0)
  {
    v84 = v56;
    v178 = v56;
    v183 = 772079660;
    v182 = v56;
    v181 = 0;
    v180 = 0;
    v179 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v183, v182, v181, v180, v179);
    v184 = v84;
  }
  if (*(_QWORD *)&v55[1])
    _dispatch_queue_invoke_finish((unsigned int *)v56, v60, *(uint64_t (****)())&v55[1], v54);
  else
    _dispatch_release_2_tailcall((unsigned int *)v56);
}

uint64_t _dispatch_channel_invoke2(_QWORD *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  _QWORD *v18;
  unint64_t v19;
  BOOL v21;
  uint64_t v22;
  _QWORD *v23;
  __int128 v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  __int128 v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t v33;
  _QWORD *v34;
  _DWORD *v35;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t *v42;
  _QWORD *v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  _QWORD *v53;
  _BOOL4 v54;
  BOOL v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  _BOOL4 v59;
  unint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  _QWORD *v68;
  _QWORD *v69;
  _QWORD *v70;
  _QWORD *v71;
  uint64_t v72;
  _QWORD *v73;
  char *v74;
  char *v75;
  _DWORD *v76;
  char v77;
  _QWORD *v78;

  v34 = a1;
  v33 = a2;
  v32 = a3;
  v31 = a4;
  v30 = 0;
  v30 = a1[11];
  v24 = (unint64_t)a1;
  v25 = 0;
  v26 = a2;
  v27 = a3 & 0xFFFDFFFF;
  v28 = 0;
  v29 = 0uLL;
  v73 = a1;
  v72 = (uint64_t)&v24 + 8;
  v75 = (char *)&v24 + 8;
  _dispatch_thread_getspecific_packed_pair(20, 21, (__int128 *)((char *)&v24 + 8), a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v73, 21, v72, v8, v9, v10, v11);
  if ((_dispatch_channel_invoke_cancel_check((uint64_t)v34, (uint64_t)&v24, v30) & 1) != 0)
  {
    do
    {
      v23 = (_QWORD *)v29;
      if (!(_QWORD)v29)
      {
        if (!v34[6])
          break;
        v43 = v34;
        v42 = v34 + 13;
        v41 = 0;
        v40 = 0;
        v39 = v34[13];
        v40 = v39;
        v38 = v39;
        v41 = v39;
        if (!v39)
          v41 = _dispatch_wait_for_enqueuer(v42, (uint64_t)(v43 + 6));
        v37 = v41;
        v23 = (_QWORD *)v41;
      }
      v76 = v23;
      v78 = v23;
      if (*v23 >= 0x1000uLL)
        v77 = 0;
      else
        v77 = *v76 & 1;
      if (v77)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: sync waiter found on channel";
        __break(1u);
        JUMPOUT(0x38B48);
      }
      v35 = v23;
      v71 = v23;
      if (*v23 < 0x1000uLL && (*v35 & 0x400) != 0)
      {
        *(_QWORD *)&v29 = v23;
        BYTE8(v29) = 0;
        v22 = 0;
        if ((v27 & 0x1000000) != 0)
          v22 = _dispatch_autorelease_pool_push();
        if ((*(unsigned int (**)(_QWORD *, __int128 *, _QWORD))(v30 + 16))(v34, &v24, v34[4]))
        {
          if ((BYTE8(v29) & 1) == 0)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel didn't call dispatch_channel_drain";
            __break(1u);
            JUMPOUT(0x38C30);
          }
        }
        else
        {
          v28 = -1;
        }
        if (v22)
          _dispatch_autorelease_pool_pop(v22);
      }
      else
      {
        v70 = v34;
        v69 = v23;
        v68 = v23;
        v67 = 0;
        v66 = 0;
        v65 = v23[2];
        v66 = v65;
        v64 = v65;
        v67 = v65;
        v63 = v65;
        v62 = v65;
        v34[13] = v65;
        v61 = v63;
        v21 = 0;
        if (!v67)
        {
          v60 = (unint64_t)v68;
          v59 = 0;
          v17 = v70 + 6;
          v57 = 0;
          v56 = 0;
          v58 = 0;
          v18 = v68;
          do
            v19 = __ldaxr(v17);
          while ((_QWORD *)v19 == v18 && __stlxr(0, v17));
          if ((_QWORD *)v19 != v18)
            v60 = v19;
          v55 = v19 == (_QWORD)v18;
          v59 = v19 == (_QWORD)v18;
          v54 = v59;
          v21 = v19 != (_QWORD)v18;
        }
        if (v21)
        {
          v53 = v68;
          v52 = 0;
          v51 = 0;
          v50 = v68[2];
          v51 = v50;
          v49 = v50;
          v52 = v50;
          if (!v50)
            v52 = _dispatch_wait_for_enqueuer(v53 + 2, (uint64_t)(v70 + 6));
          v48 = v52;
          v67 = v52;
          v47 = v52;
          v46 = v52;
          v70[13] = v52;
          v45 = v47;
        }
        v44 = v67;
        *(_QWORD *)&v29 = v67;
        _dispatch_continuation_pop_inline(v23, v33, v32, (uint64_t)v34);
        if ((_dispatch_channel_invoke_checks((uint64_t)v34, (uint64_t)&v24, v30) & 1) == 0)
          break;
      }
    }
    while (!v28);
  }
  v74 = (char *)&v24 + 8;
  _dispatch_thread_setspecific_packed_pair(20, 21, (__int128 *)((char *)&v24 + 8), v12, v13, v14, v15, v16);
  return v28;
}

uint64_t dispatch_channel_foreach_work_item_peek_f(uint64_t result, uint64_t a2, uint64_t (*a3)(uint64_t, _QWORD))
{
  _QWORD *v3;
  _QWORD *i;
  uint64_t v5;

  if ((*(_BYTE *)(result + 56) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called peek after drain";
    __break(1u);
    JUMPOUT(0x38F40);
  }
  v5 = *(_QWORD *)result;
  for (i = *(_QWORD **)(result + 48); *i < 0x1000uLL && (*(_DWORD *)i & 0x400) != 0; i = v3)
  {
    result = a3(a2, i[5]);
    if ((result & 1) == 0 || i == *(_QWORD **)(v5 + 48))
      break;
    v3 = (_QWORD *)i[2];
    if (!v3)
    {
      result = _dispatch_wait_for_enqueuer(i + 2, v5 + 48);
      v3 = (_QWORD *)result;
    }
  }
  return result;
}

void dispatch_channel_drain_f(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  _QWORD *v9;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  unsigned int v41;
  int v42;
  void *v43;
  uint64_t v44;
  uint64_t v45;
  int v46;
  unsigned int v47;
  BOOL v48;
  uint64_t v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  __int16 v53;
  _QWORD *v54;
  uint64_t v55;
  char v56;
  uint64_t v57;
  uint64_t v58;
  _QWORD *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t (*v62)(uint64_t, _QWORD, uint64_t *);
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  _QWORD *v70;
  _QWORD *v71;
  BOOL v72;
  BOOL v73;
  BOOL v74;
  _QWORD *v75;
  unsigned int v76;
  uint64_t v77;
  unint64_t v78;
  _QWORD *v79;
  _QWORD *v80;
  void *v81;
  uint64_t v82;
  _QWORD *v83;
  unsigned int v84;
  _QWORD *v85;
  uint64_t v86;
  int v87;
  _QWORD *v88;
  _QWORD *v89;
  _QWORD *v90;
  uint64_t v91;
  uint64_t v92;
  _QWORD *v93;
  uint64_t v94;
  unsigned int v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  unint64_t v99;
  _QWORD *v100;
  _QWORD *v101;
  _QWORD *v102;
  _QWORD *v103;
  _QWORD *v104;
  _QWORD *v105;
  uint64_t v106;
  _BOOL8 v107;
  _DWORD *v108;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  unint64_t *v115;
  _QWORD *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  _QWORD *v126;
  _BOOL4 v127;
  BOOL v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  _BOOL4 v132;
  unint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  _QWORD *v141;
  _QWORD *v142;
  _QWORD *v143;
  uint64_t v144;
  _DWORD *v145;
  uint64_t v146;
  _QWORD *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  unint64_t v151;
  BOOL v152;
  uint64_t v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  void *object;
  void *v158;
  unsigned int v159;
  _QWORD *v160;
  _DWORD *v161;
  int v162;
  uint64_t v163;
  uint64_t v164;
  _QWORD *v165;
  uint64_t v166;
  unsigned int v167;
  uint64_t v168;
  uint64_t v169;
  int v170;
  int v171;
  _QWORD *v172;
  _QWORD *v173;
  int v174;
  _DWORD *v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  _QWORD *v179;
  uint64_t v180;
  uint64_t v181;
  unint64_t v182;
  uint64_t v183;
  uint64_t v184;
  void *v185;
  uint64_t v186;
  uint64_t v187;
  unint64_t v188;
  uint64_t v189;
  uint64_t v190;
  unint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  _BOOL8 v196;
  unsigned int v197;
  char v198;
  unint64_t v199;
  uint64_t v200;
  unsigned int v201;
  uint64_t v202;
  unint64_t v203;
  uint64_t v204;
  unint64_t v205;
  unsigned int v206;
  uint64_t v207;
  unsigned int v208;
  unsigned int v209;
  unsigned int v210;
  uint64_t v211;
  uint64_t v212;
  unsigned int v213;
  int v214;
  unint64_t v215;
  uint64_t v216;
  unint64_t v217;
  unint64_t v218;
  uint64_t v219;
  int v220;
  uint64_t v221;
  int v222;
  unint64_t v223;
  unint64_t v224;
  void *v225;
  void *v226;
  _QWORD *v227;
  _QWORD *v228;
  uint64_t v229;
  uint64_t v230;
  uint64_t v231;
  uint64_t v232;
  uint64_t v233;
  unsigned int v234;
  uint64_t v235;

  v64 = a1;
  v63 = a2;
  v62 = (uint64_t (*)(uint64_t, _QWORD, uint64_t *))a3;
  v61 = 0;
  v61 = *(_QWORD **)a1;
  v60 = 0;
  v60 = v61[11];
  v59 = 0;
  v58 = 1028;
  v57 = 0;
  if ((*(_BYTE *)(a1 + 56) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Called drain twice in the same invoke";
    __break(1u);
    JUMPOUT(0x39134);
  }
  *(_BYTE *)(v64 + 56) = 1;
  do
  {
    v59 = *(_QWORD **)(v64 + 48);
    if (!v59)
    {
      if (!v61[6])
        break;
      v116 = v61;
      v115 = v61 + 13;
      v114 = 0;
      v113 = 0;
      v112 = v61[13];
      v113 = v112;
      v111 = v112;
      v114 = v112;
      if (!v112)
        v114 = _dispatch_wait_for_enqueuer(v115, (uint64_t)(v116 + 6));
      v110 = v114;
      v59 = (_QWORD *)v114;
    }
    v108 = v59;
    v179 = v59;
    if (*v59 >= 0x1000uLL || (*v108 & 0x400) == 0)
      break;
    v143 = v61;
    v142 = v59;
    v141 = v59;
    v140 = 0;
    v139 = 0;
    v138 = v59[2];
    v139 = v138;
    v137 = v138;
    v140 = v138;
    v136 = v138;
    v135 = v138;
    v61[13] = v138;
    v134 = v136;
    v48 = 0;
    if (!v140)
    {
      v133 = (unint64_t)v141;
      v132 = 0;
      v8 = v143 + 6;
      v130 = 0;
      v129 = 0;
      v131 = 0;
      v9 = v141;
      do
        v10 = __ldaxr(v8);
      while ((_QWORD *)v10 == v9 && __stlxr(0, v8));
      if ((_QWORD *)v10 != v9)
        v133 = v10;
      v128 = v10 == (_QWORD)v9;
      v132 = v10 == (_QWORD)v9;
      v127 = v132;
      v48 = v10 != (_QWORD)v9;
    }
    if (v48)
    {
      v126 = v141;
      v125 = 0;
      v124 = 0;
      v123 = v141[2];
      v124 = v123;
      v122 = v123;
      v125 = v123;
      if (!v123)
        v125 = _dispatch_wait_for_enqueuer(v126 + 2, (uint64_t)(v143 + 6));
      v121 = v125;
      v140 = v125;
      v120 = v125;
      v119 = v125;
      v143[13] = v125;
      v118 = v120;
    }
    v117 = v140;
    *(_QWORD *)(v64 + 48) = v140;
    v104 = v59;
    v105 = v59;
    v55 = (uint64_t)v59;
    v53 = v58;
    v147 = v59;
    v146 = v58;
    v145 = 0;
    v145 = (_DWORD *)v59[3];
    v144 = v58 & 4;
    v169 = 1;
    v168 = 600;
    if ((v58 & 4) != 0)
      v147[3] = -1;
    if (v145 != (_DWORD *)-1)
    {
      v162 = 771817480;
      v161 = v145;
      v160 = v147;
      v159 = 0;
      if (v145)
        v47 = v161[8];
      else
        v47 = 0;
      v159 = v47;
      v167 = v162;
      v166 = v47;
      v165 = v160;
      v164 = 0;
      v163 = 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(v167, v166, v165, v164, v163);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v11, v12, v13, v14, v15, v16, v17, 607);
    }
    v151 = v147[1];
    v150 = (uint64_t)v145;
    v149 = v144 | 2;
    v148 = 0;
    if (v151 != -1)
    {
      v203 = v151;
      v202 = v149;
      v201 = 0;
      v201 = _dispatch_thread_getspecific(0x19uLL);
      v200 = 0;
      v209 = v201;
      v210 = v201 & 0xF00;
      v208 = v210 >> 8;
      v207 = v201;
      if (v210 >> 8)
        v207 |= 1 << (v208 + 7);
      v200 = v207;
      v211 = v207;
      v199 = v207 & 0xFFFFFF00;
      v198 = 0;
      LOBYTE(v46) = 1;
      if ((v202 & 1) == 0)
        v46 = (BYTE3(v203) >> 4) & 1;
      v198 = v46;
      v205 = v203;
      v203 &= 0xFFFFFFuLL;
      if (v203)
      {
        if (v203 >= v199)
        {
          if ((v198 & 1) != 0 || (v201 & 0x44000000) != 0)
            v204 = v203;
          else
            v204 = v200;
        }
        else
        {
          v204 = v200;
        }
      }
      else
      {
        v206 = v201 & 0xF000;
        v197 = v206 >> 12;
        if (v206 >> 12)
        {
          v213 = v197;
          v212 = 1 << (v197 + 7);
          v45 = v212 | 0xFF;
        }
        else
        {
          v45 = v200;
        }
        v204 = v45;
      }
      v148 = v204;
    }
    v155 = v148;
    v154 = v150;
    v153 = v149;
    v183 = v148;
    v196 = v148 != -1;
    v195 = 2332;
    if (v148 == -1)
      _dispatch_abort(v195, v196, a3, a4, a5, a6, a7, a8);
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v194 = v183;
      v193 = 4261412863;
      v192 = 0;
      v183 &= 0xFFFFFFFF02FFFFFFLL;
      v182 = 0;
      v185 = 0;
      v185 = _dispatch_thread_getspecific(4uLL);
      v182 = (unint64_t)v185;
      v181 = 0x1000000;
      v180 = 2281701376;
      if ((v185 & 0x1000000) != 0)
      {
        if (v183)
        {
          v44 = v183;
        }
        else
        {
          v191 = v182;
          v190 = v181;
          v189 = 0;
          v44 = v182 & (~v181 | 0xFFFFFF);
        }
        v184 = v44;
      }
      else
      {
        v188 = v182;
        v187 = v180;
        v186 = 0;
        v182 &= ~v180 | 0xFFFFFF;
        if (v183 == v182)
          v184 = 0;
        else
          v184 = v183;
      }
    }
    else
    {
      v184 = 0;
    }
    v155 = v184;
    if (v184)
      goto LABEL_75;
    if (v154 != -1)
    {
      v43 = (void *)v154;
      if (v43 == _dispatch_thread_getspecific(0x1CuLL))
      {
        v152 = (v153 & 4) != 0;
        if ((v153 & 2) != 0)
        {
          if (v152 && v154)
          {
            object = (void *)v154;
            os_release((void *)v154);
          }
          v154 = -1;
        }
        else if (!v152 && v154)
        {
          v158 = (void *)v154;
          os_retain((void *)v154);
        }
        v156 = v154;
        goto LABEL_76;
      }
LABEL_75:
      v156 = _dispatch_set_priority_and_voucher_slow(v155, (_DWORD *)v154, v153);
      goto LABEL_76;
    }
    v156 = -1;
LABEL_76:
    if ((v53 & 0x200) == 0)
    {
      v102 = v59;
      v103 = v59;
      v173 = v61;
      v172 = v59;
      v171 = 0;
      v170 = 0;
      v228 = v61;
      v227 = v59;
    }
    if ((v53 & 4) != 0)
    {
      v176 = v55;
      v175 = 0;
      v175 = _dispatch_thread_getspecific(0x16uLL);
      v174 = 0;
      if (v175)
        v42 = v175[2] + 1;
      else
        v42 = 1;
      v174 = v42;
      if (v42 <= _dispatch_continuation_cache_limit)
      {
        *(_QWORD *)(v176 + 16) = v175;
        *(_DWORD *)(v176 + 8) = v174;
        _dispatch_thread_setspecific(22, v176);
        v177 = 0;
      }
      else
      {
        v177 = v176;
      }
      v54 = (_QWORD *)v177;
    }
    else
    {
      v54 = 0;
    }
    v52 = 0;
    if ((*(_BYTE *)(v64 + 35) & 1) != 0)
      v52 = _dispatch_autorelease_pool_push();
    v100 = v59;
    v101 = v59;
    v56 = v62(v63, v59[5], &v57) ^ 1;
    if (v52)
      _dispatch_autorelease_pool_pop(v52);
    if ((v53 & 0x200) == 0)
    {
      v178 = v55;
      v229 = v55;
      v234 = 772079660;
      v233 = v55;
      v232 = 0;
      v231 = 0;
      v230 = 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(v234, v233, v232, v231, v230);
      v235 = v178;
    }
    if (v54)
      _dispatch_continuation_free_to_cache_limit(v54);
  }
  while ((v56 & 1) == 0 && (_dispatch_channel_invoke_checks((uint64_t)v61, v64, v60) & 1) != 0);
  if (v57)
  {
    v88 = 0;
    v90 = 0;
    v90 = _dispatch_thread_getspecific(0x16uLL);
    if (v90)
      _dispatch_thread_setspecific(22, v90[2]);
    v88 = v90;
    if (v90)
      v89 = v88;
    else
      v89 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    v51 = (unint64_t)v89;
    v71 = v61;
    v70 = v89;
    v69 = v57;
    v68 = 0;
    v67 = 0;
    v66 = v58;
    v65 = 0;
    *v89 = v58 | 0x100;
    v70[4] = v68;
    v70[5] = v69;
    if ((v67 & 0x40000000) == 0)
    {
      v215 = 0;
      v214 = 1;
      v217 = 0;
      v217 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      v218 = v217;
      v215 = v217 & 0xFFFFFF;
      if ((v214 & 2) != 0 || (v222 = 5, v221 = 4096, v215 <= 0x10FF))
      {
        v216 = v215;
      }
      else
      {
        v220 = 5;
        v219 = 4096;
        v216 = 4351;
      }
      v65 = v216;
    }
    v83 = v70;
    v82 = v67;
    v81 = 0;
    v107 = (int)v67 >= 0;
    v106 = 583;
    if ((int)v67 < 0)
      _dispatch_abort(v106, v107, v18, v19, v20, v21, v22, v23);
    if ((v82 & 0x40) == 0)
    {
      v225 = 0;
      v225 = _dispatch_thread_getspecific(0x1CuLL);
      if (v225)
      {
        v226 = v225;
        os_retain(v225);
      }
      v81 = v225;
    }
    v83[3] = v81;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v24, v25, v26, v27, v28, v29, v30, 589);
    v31 = v83[3];
    v87 = 771817476;
    v86 = v31;
    v85 = v83;
    if (v31 != -1)
    {
      v84 = 0;
      v41 = v86 ? *(_DWORD *)(v86 + 32) : 0;
      v84 = v41;
      v95 = v87;
      v94 = v41;
      v93 = v85;
      v92 = 0;
      v91 = 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(v95, v94, v93, v92, v91);
    }
    v80 = v71;
    v79 = v70;
    v78 = v65;
    v77 = v67;
    v76 = 0;
    v75 = v71;
    if (v65)
    {
      v74 = (v77 & 0x20) != 0;
      v73 = 0;
      v73 = (*((_DWORD *)v75 + 21) & 0x40000000) != 0;
      v72 = 0;
      v72 = (*((_DWORD *)v75 + 21) & 0xFFF) != 0;
      if ((v77 & 0x20) != 0)
      {
        v78 |= 0x10000000uLL;
        v223 = v78 >> 8;
        v32 = v78 >> 8;
        v33 = __clz(__rbit32(v32));
        if (v32)
          v34 = v33 + 1;
        else
          v34 = 0;
        v76 = v34;
      }
      else if (v73 || !v72)
      {
        v224 = v78 >> 8;
        v35 = v78 >> 8;
        v36 = __clz(__rbit32(v35));
        if (v35)
          v37 = v36 + 1;
        else
          v37 = 0;
        v76 = v37;
      }
      else
      {
        v78 = 0;
      }
    }
    v79[1] = v78;
    v98 = v51;
    v99 = v51;
    v50 = *(_QWORD *)(v64 + 48);
    *(_QWORD *)(v51 + 16) = v50;
    v40 = 0;
    if (!v50)
    {
      v38 = v61 + 6;
      do
        v39 = __ldaxr(v38);
      while (!v39 && __stlxr(v51, v38));
      v40 = v39 != 0;
    }
    if (v40)
    {
      v49 = v61[13];
      if (!v49)
        v49 = _dispatch_wait_for_enqueuer(v61 + 13, (uint64_t)(v61 + 6));
      *(_QWORD *)(v51 + 16) = v49;
    }
    v61[13] = v51;
    v96 = v51;
    v97 = v51;
    *(_QWORD *)(v64 + 48) = v51;
  }
}

uint64_t _dispatch_channel_invoke_checks(uint64_t a1, uint64_t a2, uint64_t a3)
{
  char v6;
  unsigned int *v7;

  if ((_dispatch_channel_invoke_cancel_check(a1, a2, a3) & 1) != 0)
  {
    if (_dispatch_thread_getspecific(5uLL))
      _dispatch_return_to_kernel();
    if ((*(_DWORD *)(a2 + 32) & 0x100000) != 0
      && (v7 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL),
          (((unint64_t)v7[15] << 32) & 0x700000000) >> 32 > *((unsigned __int8 *)v7 + 100)))
    {
      *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 24);
      v6 = 0;
    }
    else if (((unint64_t)_dispatch_thread_getspecific(0x78uLL) & 1) != 0)
    {
      *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 24);
      v6 = 0;
    }
    else if ((*(_QWORD *)(a1 + 56) & 0xFF80000000000000) != 0)
    {
      *(_QWORD *)(a2 + 40) = *(_QWORD *)(a1 + 24);
      v6 = 0;
    }
    else
    {
      v6 = 1;
    }
  }
  else
  {
    v6 = 0;
  }
  return v6 & 1;
}

uint64_t dispatch_channel_foreach_work_item_peek(uint64_t a1, uint64_t a2)
{
  uint64_t (*v2)(uint64_t, _QWORD);

  v2 = (uint64_t (*)(uint64_t, _QWORD))_Block_get_invoke_fn(a2);
  return dispatch_channel_foreach_work_item_peek_f(a1, a2, v2);
}

void dispatch_channel_drain(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  v2 = _Block_get_invoke_fn(a2);
  dispatch_channel_drain_f(a1, a2, v2, v3, v4, v5, v6, v7);
}

void _dispatch_channel_wakeup(uint64_t a1, unsigned int a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL8 v8;

  v8 = 0;
  if ((((*(unsigned __int8 (**)(uint64_t, _QWORD))(*(_QWORD *)(a1 + 88) + 8))(a1, *(_QWORD *)(a1 + 32)) ^ 1) & 1) != 0)
  {
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, -1, v3, v4, v5, v6);
  }
  else if (*(_QWORD *)(a1 + 48))
  {
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, 1, v3, v4, v5, v6);
  }
  else
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
      v8 = ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0;
    _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, v8, v3, v4, v5, v6);
  }
}

_QWORD *dispatch_channel_create(const char *a1, uint64_t (***a2)(), uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v14;
  const char *v15;
  int v16;
  const char *v20;

  v20 = a1;
  v16 = 0x4000000;
  if (!*a4)
  {
    v8 = *a4;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unsupported callbacks version";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0x3ACB0);
  }
  if (a1)
  {
    v15 = _dispatch_strdup_if_mutable(a1);
    if (v15 != v20)
    {
      v16 = 69206016;
      v20 = v15;
    }
  }
  if (a2)
    _dispatch_retain((uint64_t)a2);
  else
    a2 = &off_E46C0;
  v14 = _dispatch_object_alloc((uint64_t)_OS_dispatch_channel_vtable, 0x78uLL, a3, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_queue_init((uint64_t)v14, v16, 1, 0x180000000000000, v9, v10, v11, v12);
  v14[9] = v20;
  v14[3] = a2;
  v14[11] = a4;
  v14[4] = a3;
  if (!a4[3])
  {
    *((_WORD *)v14 + 58) |= 8u;
    --*((_DWORD *)v14 + 2);
  }
  return v14;
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> _dispatch_queue_init(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  uint64_t v10;

  if ((a4 & 0xFE7FFFCFFFFFFFFFLL) != 0)
    _dispatch_abort(1223, (a4 & 0xFE7FFFCFFFFFFFFFLL) == 0, a3, a4, a5, a6, a7, a8);
  if ((a4 & 0x180000000000000) != 0)
  {
    *(_DWORD *)(a1 + 8) += 2;
    if (*(_BYTE *)(*(_QWORD *)a1 + 16) == 19)
      ++*(_DWORD *)(a1 + 8);
  }
  *(_QWORD *)(a1 + 16) = -1985229329;
  *(_DWORD *)(a1 + 80) = a2 | (unsigned __int16)a3;
  *(_QWORD *)(a1 + 56) = ((4096 - (unsigned __int16)a3) << 41) | a4;
  v10 = _dispatch_queue_serial_numbers;
  do
  {
    v8 = v10;
    do
      v9 = __ldaxr((unint64_t *)&_dispatch_queue_serial_numbers);
    while (v9 == v10 && __stlxr(v10 + 1, (unint64_t *)&_dispatch_queue_serial_numbers));
    v10 = v9;
  }
  while (v9 != v8);
  *(_QWORD *)(a1 + 64) = v9;
}

uint64_t dispatch_channel_enqueue(_DWORD *a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  _QWORD *v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void *v22;

  v16 = _dispatch_thread_getspecific(0x16uLL);
  if (!v16)
    return _dispatch_channel_enqueue_slow(a1, a2);
  _dispatch_thread_setspecific(22, v16[2]);
  *v16 = 1284;
  v16[4] = 0;
  v16[5] = a2;
  v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF)
    v21 = v20;
  else
    v21 = 4351;
  v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22)
    os_retain(v22);
  v16[3] = v22;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  v19 = v16[3];
  if (v19 != -1)
  {
    v13 = v19 ? *(_DWORD *)(v19 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v13, v16, 0, 0);
  }
  v18 = v21;
  v17 = 0;
  if (v21)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      v10 = v21 >> 8;
      v11 = __clz(__rbit32(v10));
      if (v10)
        v12 = v11 + 1;
      else
        v12 = 0;
      v17 = v12;
    }
    else
    {
      v18 = 0;
    }
  }
  v16[1] = v18;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v16, v17);
}

uint64_t _dispatch_channel_enqueue_slow(_DWORD *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v13;
  _QWORD *v14;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  void *v22;

  v14 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  *v14 = 1284;
  v14[4] = 0;
  v14[5] = a2;
  v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF)
    v21 = v20;
  else
    v21 = 4351;
  v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22)
    os_retain(v22);
  v14[3] = v22;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
  v19 = v14[3];
  if (v19 != -1)
  {
    v13 = v19 ? *(_DWORD *)(v19 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v13, v14, 0, 0);
  }
  v18 = v21;
  v17 = 0;
  if (v21)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      v9 = v21 >> 8;
      v10 = __clz(__rbit32(v9));
      if (v9)
        v11 = v10 + 1;
      else
        v11 = 0;
      v17 = v11;
    }
    else
    {
      v18 = 0;
    }
  }
  v14[1] = v18;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v14, v17);
}

uint64_t dispatch_channel_wakeup(uint64_t a1, int a2)
{
  unint64_t v3;

  v3 = (a2 - 5);
  if (v3 <= 0x1C)
    __asm { BR              X8 }
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 2);
}

uint64_t _dispatch_mgr_queue_push(_QWORD *a1, _QWORD *a2)
{
  unint64_t v2;
  unint64_t v3;
  uint64_t result;
  unint64_t v5;
  unint64_t v6;
  int v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t v15;

  if (*a2 < 0x1000uLL && (*a2 & 0x81) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Waiter pushed onto manager";
    __break(1u);
    JUMPOUT(0x3BD94);
  }
  a2[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(a1 + 6));
  v10 = a1 + 6;
  v11 = a1[6];
  do
  {
    v2 = v11;
    do
      v3 = __ldaxr(v10);
    while (v3 == v11 && __stlxr((unint64_t)a2, v10));
    v11 = v3;
  }
  while (v3 != v2);
  v15 = v3;
  if (v3)
    *(_QWORD *)(v3 + 16) = a2;
  else
    a1[13] = a2;
  result = _dispatch_thread_setspecific(122, 0);
  if (!v15)
  {
    v8 = a1 + 7;
    v9 = a1[7];
    do
    {
      v5 = v9;
      do
        v6 = __ldaxr(v8);
      while (v6 == v9 && __stlxr(v9 | 0x8000000000, v8));
      v7 = v6;
      v9 = v6;
    }
    while (v6 != v5);
    result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    if (((v7 ^ result) & 0xFFFFFFFC) != 0)
      return _dispatch_event_loop_poke(-8, 0, 0);
  }
  return result;
}

void _dispatch_mgr_queue_wakeup()
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override the manager";
  __break(1u);
}

void sub_3C0E8()
{
  __break(1u);
}

void _dispatch_mgr_thread(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3;
  _opaque_pthread_t *v4;
  BOOL v5;
  _OWORD v6[128];
  uint64_t (***v7)();
  int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t (***v11)();
  _BOOL4 v12;
  uint64_t v13;
  unint64_t *v14;
  _BOOL4 v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t (***v19)();
  uint64_t v20;
  unint64_t v21;
  unsigned int v22;
  int v23;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Manager queue invoked with kevent workqueue enabled";
    __break(1u);
    JUMPOUT(0x3C14CLL);
  }
  v7 = &_dispatch_mgr_q;
  v11 = &_dispatch_mgr_q;
  _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
  _dispatch_mgr_priority_init();
  v19 = &_dispatch_mgr_q;
  v18 = 0;
  v17 = 0;
  v22 = _dispatch_thread_getspecific(3uLL);
  v16 = v22 & 0xFFFFFFFC | 0x40020000000000;
  v15 = 0;
  v14 = (unint64_t *)&qword_E4178;
  while (1)
  {
    if (_os_atomic_mo_has_acquire(2))
      v3 = __ldaxr(v14);
    else
      v3 = __ldxr(v14);
    v18 = v3;
    v17 = v3;
    v21 = v3;
    v5 = 1;
    if (!(v3 >> 53))
    {
      v20 = v18;
      v23 = v18;
      v5 = (v18 & 0xFFFFFFFC) != 0;
    }
    if (v5)
    {
      v13 = v18;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
      qword_E4DA8 = v18;
      __break(1u);
      JUMPOUT(0x3C2ACLL);
    }
    v17 = v17 & 0x7700000001 | v16;
    if (_os_atomic_mo_has_release(2))
      v15 = __stlxr(v17, v14) == 0;
    else
      v15 = __stxr(v17, v14) == 0;
    if (v15)
    {
      v12 = v15;
      memset(v6, 0, 512);
      v4 = pthread_self();
      *(_QWORD *)&v6[0] = pthread_get_stackaddr_np(v4);
      __memset_chk((char *)v6 + 8, 0, *(_QWORD *)&v6[0] - ((_QWORD)v6 + 8), -1);
      _dispatch_mgr_invoke();
    }
  }
}

void _dispatch_mgr_priority_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  qos_class_t __qos_class[2];
  qos_class_t v8;
  sched_param v9;
  pthread_attr_t *__attr;
  void *v11;
  uint64_t v12;
  uint64_t v13;

  v11 = off_E40E0;
  __attr = (pthread_attr_t *)off_E40E0;
  v9 = 0;
  v8 = pthread_attr_getschedparam((const pthread_attr_t *)off_E40E0, &v9);
  v13 = (int)v8;
  v12 = 6262;
  if (v8)
    _dispatch_bug(v12, v13, v0, v1, v2, v3, v4, v5);
  __qos_class[1] = v8;
  __qos_class[0] = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(__attr, __qos_class, 0);
  if (dword_E505C > __qos_class[0] && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    pthread_set_qos_class_self_np((qos_class_t)dword_E505C, 0);
    v6 = _dispatch_mgr_sched_qos2prio(dword_E505C);
    if (v6 > v9.sched_priority)
      v9.sched_priority = v6;
  }
  if (_dispatch_mgr_sched > v9.sched_priority)
    _dispatch_mgr_priority_apply();
}

void _dispatch_mgr_invoke()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  _QWORD __b[6];
  char v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (***v12)();
  _QWORD *v13;

  memset(__b, 0, sizeof(__b));
  memset(__b, 0, 20);
  __b[3] = -4;
  __b[4] = &v7;
  LODWORD(__b[5]) = 0x100000;
  WORD2(__b[5]) &= 0xFE00u;
  BYTE5(__b[5]) &= ~2u;
  BYTE5(__b[5]) &= ~4u;
  v13 = __b;
  _dispatch_thread_setspecific(29, (uint64_t)__b);
  while (1)
  {
    _dispatch_mgr_queue_drain();
    if (byte_E4E16)
      _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v0, v1, v2, v3, v4, v5);
    v12 = &_dispatch_mgr_q;
    v9 = qword_E4170;
    v10 = qword_E4170;
    v8 = qword_E4170;
    v11 = qword_E4170;
    _dispatch_event_loop_drain(qword_E4170 != 0);
  }
}

void _dispatch_kevent_workqueue_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  uint64_t v7;
  int v8;

  if (_dispatch_root_queues_pred != -1)
    dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    if (_dispatch_mgr_sched_pred != -1)
      dispatch_once_f(&_dispatch_mgr_sched_pred, 0, (dispatch_function_t)_dispatch_mgr_sched_init);
    v8 = _dispatch_mgr_sched;
    v7 = 0;
    if (dword_E505C)
      v7 = _pthread_qos_class_encode(dword_E505C, 0, 0);
    if (v8 > dword_E5060)
      v7 = v8 | 0x20000000;
    if (v7)
    {
      v6 = _pthread_workqueue_set_event_manager_priority(v7);
      if (v6)
        _dispatch_bug(6510, v6, v0, v1, v2, v3, v4, v5);
    }
  }
}

uint64_t _dispatch_mgr_sched_init(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t result;
  int v20;
  int v21;
  int v22;
  int v23;
  pthread_attr_t *v24;
  sched_param v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;

  v26 = a1;
  v25 = 0;
  v24 = (pthread_attr_t *)off_E40E0;
  v23 = pthread_attr_init((pthread_attr_t *)off_E40E0);
  v32 = v23;
  v31 = 6165;
  if (v23)
    _dispatch_bug(v31, v32, v1, v2, v3, v4, v5, v6);
  v22 = pthread_attr_getschedpolicy(v24, &dword_E5064);
  v30 = v22;
  v29 = 6167;
  if (v22)
    _dispatch_bug(v29, v30, v7, v8, v9, v10, v11, v12);
  v21 = pthread_attr_getschedparam(v24, &v25);
  v28 = v21;
  v27 = 6168;
  if (v21)
    _dispatch_bug(v27, v28, v13, v14, v15, v16, v17, v18);
  result = qos_class_main();
  v20 = result;
  if ((_DWORD)result == 21)
    v20 = 25;
  if (v20)
  {
    dword_E505C = v20;
    result = _dispatch_mgr_sched_qos2prio(v20);
    v25.sched_priority = result;
  }
  dword_E5060 = v25.sched_priority;
  _dispatch_mgr_sched = v25.sched_priority;
  return result;
}

void _dispatch_root_queue_poke(unsigned int *a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int *v8;
  unsigned int v9;
  BOOL v10;

  if (*((_QWORD *)a1 + 6))
  {
    v10 = 1;
    if (*(_QWORD *)(*(_QWORD *)a1 + 16) != 328465)
      v10 = *(_QWORD *)(*(_QWORD *)a1 + 16) == 330001;
    if (!v10)
      goto LABEL_9;
    v8 = a1 + 28;
    do
      v9 = __ldaxr(v8);
    while (!v9 && __stlxr(a2, v8));
    if (!v9)
LABEL_9:
      _dispatch_root_queue_poke_slow((uint64_t (***)())a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_root_queue_poke_slow(uint64_t (***a1)(), signed int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int *v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v34;
  unsigned int *v35;
  unsigned int v36;
  signed int v37;
  unsigned int *v38;
  unsigned int v39;
  pthread_t *v40;
  uint64_t v41;
  pthread_attr_t *v42;
  int v43;
  BOOL v44;
  int v45;
  int v46;
  int v47;
  _BOOL4 v48;
  unsigned int v49;
  unsigned int v50;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  unsigned int v55;
  unsigned int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  signed int v61;
  int v62;
  signed int v63;
  signed int v64;
  _BOOL4 v65;
  BOOL v66;
  signed int v67;
  signed int v68;
  signed int v69;
  _BOOL4 v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int v73;
  signed int v74;
  signed int v75;
  signed int v76;
  unsigned int v77;
  unsigned int v78;
  signed int v79;
  signed int v80;
  signed int v81;
  BOOL v82;
  uint64_t (**v83)();
  int v84;
  int v85;
  int v86;
  int v87;
  int v88;
  signed int v89;
  int v90;
  signed int v91;
  uint64_t (***v92)();
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t (***v100)();
  int v101;
  dispatch_function_t v102;
  void *v103;
  dispatch_once_t *v104;
  uint64_t v105;
  int v106;
  int v107;
  uint64_t v108;
  uint64_t v109;
  _BOOL8 v110;
  uint64_t v111;
  int v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  _BOOL8 v116;

  v92 = a1;
  v91 = a2;
  v90 = a3;
  v89 = a2;
  v88 = 78;
  v104 = &_dispatch_root_queues_pred;
  v103 = 0;
  v102 = (dispatch_function_t)_dispatch_root_queues_init_once;
  if (_dispatch_root_queues_pred != -1)
    dispatch_once_f(v104, v103, v102);
  v101 = 3;
  v100 = v92;
  v99 = v91;
  if ((*v92)[2] == (uint64_t (*)())((char *)&loc_50310 + 1))
  {
    v113 = *((_DWORD *)v92 + 21);
    v112 = 0;
    v111 = 0;
    if ((v113 & 0x4000000) != 0)
    {
      v111 = v113 & 0x8E000000 | 0xFFLL;
      v112 = (unsigned __int16)(v113 & 0xF000) >> 12;
      v116 = v112 != 0;
      v115 = 512;
      if (!v112)
        _dispatch_abort(v115, v116, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      v111 = v113 & 0x8E0000FF;
      v112 = (unsigned __int16)(v113 & 0xF00) >> 8;
      if (!v112)
      {
        v114 = v111;
LABEL_11:
        v87 = _pthread_workqueue_addthreads(v89, v114);
        v98 = v87;
        v97 = 6840;
        if (v87)
          _dispatch_bug(v97, v98, v8, v9, v10, v11, v12, v13);
        v86 = v87;
        return;
      }
    }
    v114 = v111 | (1 << (v112 + 7));
    goto LABEL_11;
  }
  if ((*v92)[2] == (uint64_t (*)())((char *)&loc_50910 + 1))
  {
    v107 = *((_DWORD *)v92 + 21);
    v106 = 0;
    v105 = 0;
    if ((v107 & 0x4000000) != 0)
    {
      v105 = v107 & 0x8E000000 | 0xFFLL;
      v106 = (unsigned __int16)(v107 & 0xF000) >> 12;
      v110 = v106 != 0;
      v109 = 512;
      if (!v106)
        _dispatch_abort(v109, v110, a3, a4, a5, a6, a7, a8);
    }
    else
    {
      v105 = v107 & 0x8E0000FF;
      v106 = (unsigned __int16)(v107 & 0xF00) >> 8;
      if (!v106)
      {
        v108 = v105;
LABEL_22:
        v85 = _pthread_workqueue_add_cooperativethreads(v89, v108);
        v96 = v85;
        v95 = 6848;
        if (v85)
          _dispatch_bug(v95, v96, v14, v15, v16, v17, v18, v19);
        v84 = v85;
        return;
      }
    }
    v108 = v105 | (1 << (v106 + 7));
    goto LABEL_22;
  }
  v83 = 0;
  v83 = v92[4];
  if (v83[9])
  {
    while (dispatch_semaphore_signal((dispatch_semaphore_t)(v83 + 9)))
    {
      if (!--v89)
        return;
    }
  }
  v82 = 0;
  v82 = *((int *)v92 + 21) < 0;
  if (v82)
  {
    v80 = v89;
    v79 = v89;
    v81 = v89;
    v77 = 0;
    v38 = (unsigned int *)(v92 + 14);
    v75 = v89;
    v74 = v89;
    v76 = v89;
    v39 = *((_DWORD *)v92 + 28);
    do
    {
      v20 = v39;
      do
        v21 = __ldaxr(v38);
      while (v21 == v39 && __stlxr(v39 + v89, v38));
      v39 = v21;
    }
    while (v21 != v20);
    v73 = v21;
    v77 = v21;
    v72 = v21;
    v78 = v21 + v81;
  }
  else
  {
    v71 = 0;
    v70 = 0;
    v22 = (unsigned int *)(v92 + 14);
    v68 = v89;
    v67 = v89;
    v69 = v89;
    do
      v23 = __ldaxr(v22);
    while (!v23 && __stlxr(v89, v22));
    if (v23)
      v71 = v23;
    v66 = v23 == 0;
    v70 = v23 == 0;
    v65 = v70;
    if (v23)
      return;
  }
  v64 = 0;
  v63 = 0;
  v62 = 0;
  v61 = *((_DWORD *)v92 + 25);
  v62 = v61;
  v60 = v61;
  v63 = v61;
  while (1)
  {
    if (v63 >= v90)
      v37 = v63 - v90;
    else
      v37 = 0;
    v64 = v37;
    if (v89 > v37)
    {
      v58 = v89 - v64;
      v57 = v89 - v64;
      v59 = v89 - v64;
      v55 = 0;
      v35 = (unsigned int *)(v92 + 14);
      v53 = v89 - v64;
      v52 = v89 - v64;
      v54 = v89 - v64;
      v36 = *((_DWORD *)v92 + 28);
      do
      {
        v24 = v36;
        do
          v25 = __ldaxr(v35);
        while (v25 == v36 && __stlxr(v36 - (v89 - v64), v35));
        v36 = v25;
      }
      while (v25 != v24);
      v51 = v25;
      v55 = v25;
      v50 = v25;
      v56 = v25 - v59;
      v89 = v64;
    }
    if (!v89)
      break;
    v49 = v63;
    v48 = 0;
    v26 = (unsigned int *)v92 + 25;
    v46 = v63 - v89;
    v45 = v63 - v89;
    v47 = v63 - v89;
    do
      v27 = __ldaxr(v26);
    while (v27 == v63 && __stlxr(v63 - v89, v26));
    v34 = v27 == v63;
    if (v27 != v63)
      v49 = v27;
    v44 = v27 == v63;
    v48 = v27 == v63;
    v63 = v49;
    v43 = v34;
    if (v34)
    {
      v42 = (pthread_attr_t *)v83;
      v41 = 0;
      v40 = (pthread_t *)&v41;
      if (v92 == &_dispatch_mgr_root_queue)
        v40 = (pthread_t *)_dispatch_mgr_root_queue_init();
      do
      {
        _dispatch_retain((uint64_t)v92);
        while (1)
        {
          v88 = pthread_create(v40, v42, (void *(__cdecl *)(void *))_dispatch_worker_thread, v92);
          if (!v88)
            break;
          if (v88 != 35)
          {
            v94 = v88;
            v93 = 6907;
            _dispatch_bug(6907, v88, v28, v29, v30, v31, v32, v33);
          }
          _dispatch_temporary_resource_shortage();
        }
        --v89;
      }
      while (v89);
      return;
    }
  }
}

void _dispatch_root_queue_poke_and_wakeup(uint64_t (***a1)(), signed int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  BOOL v10;
  unsigned int *v11;
  _BOOL4 v12;
  int v13;

  v10 = 1;
  if ((*a1)[2] != (uint64_t (*)())((char *)&loc_50310 + 1))
    v10 = (*a1)[2] == (uint64_t (*)())((char *)&loc_50910 + 1);
  if (!v10)
    goto LABEL_16;
  v11 = (unsigned int *)(a1 + 14);
  do
  {
    if (_os_atomic_mo_has_acquire(3))
      v8 = __ldaxr(v11);
    else
      v8 = __ldxr(v11);
    v13 = v8;
    if (v8)
      v9 = v8;
    else
      v9 = a2;
    if (_os_atomic_mo_has_release(3))
      v12 = __stlxr(v9, v11) == 0;
    else
      v12 = __stxr(v9, v11) == 0;
  }
  while (!v12);
  if (v13 <= 0)
LABEL_16:
    _dispatch_root_queue_poke_slow(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_root_queue_wakeup(unsigned int *a1, uint64_t a2, char a3)
{
  uint64_t v3;

  if ((a3 & 8) == 0)
  {
    v3 = a1[21];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Don't try to wake up or override a root queue";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x3D7C0);
  }
  if ((a3 & 1) != 0)
    _dispatch_release_2_tailcall(a1);
}

void _dispatch_root_queue_push(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t v10;
  unint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  BOOL v19;
  BOOL v20;
  BOOL is_timer;
  char v22;
  char v23;
  BOOL v24;
  char v25;
  unsigned int v26;
  uint64_t v27;
  unsigned int v28;
  _QWORD *v29;
  _BYTE *v30;
  char v34;
  unsigned int v35;
  unsigned int v36;
  BOOL v37;
  unint64_t v38;

  v30 = _dispatch_thread_getspecific(0x1DuLL);
  v25 = 0;
  if (v30)
    v25 = v30[44];
  if ((v25 & 1) == 0)
    goto LABEL_11;
  v29 = (_QWORD *)*((_QWORD *)v30 + 1);
  v28 = *(_DWORD *)(a1 + 84) & 0x80000000;
  v24 = 1;
  if (v29)
    v24 = *(int *)(a1 + 84) < 0;
  if (!v24)
    goto LABEL_11;
  v27 = *(_QWORD *)v30;
  v26 = *((_DWORD *)v30 + 4);
  *(_QWORD *)v30 = a1;
  *((_QWORD *)v30 + 1) = a2;
  *((_DWORD *)v30 + 4) = a3;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tdeferring item %p, rq %p, qos %d", v3, v4, v5, v6, v7, v8, v9, 7572);
  if (v28)
    v30[44] = 0;
  if (v29)
  {
    a3 = v26;
    a1 = v27;
    a2 = v29;
LABEL_11:
    v23 = 0;
    if ((*(_BYTE *)(a1 + 87) & 8) != 0)
    {
      if (*a2 >= 0x1000uLL)
      {
        v22 = 1;
        if (*(_QWORD *)(*a2 + 16) != 1)
        {
          is_timer = 0;
          if (*(_BYTE *)(*a2 + 16) == 19)
            is_timer = _dispatch_source_is_timer((uint64_t)a2);
          v22 = is_timer;
        }
        v34 = v22 & 1;
      }
      else
      {
        v34 = 1;
      }
      v23 = v34 ^ 1;
    }
    if ((v23 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target the cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x3DAB4);
    }
    v36 = (*(_DWORD *)(a1 + 84) & 0xF000u) >> 12;
    if (v36)
    {
      v20 = 0;
      if (a3)
        v20 = a3 != v36;
      v37 = v20;
    }
    else
    {
      v35 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
      v19 = 0;
      if (v35)
        v19 = a3 > v35;
      v37 = v19;
    }
    if (v37)
    {
      _dispatch_root_queue_push_override(a1, a2, a3);
    }
    else
    {
      a2[2] = 0;
      _dispatch_thread_setspecific(122, a1 + 48);
      v17 = (unint64_t *)(a1 + 48);
      v18 = *(_QWORD *)(a1 + 48);
      do
      {
        v10 = v18;
        do
          v11 = __ldaxr(v17);
        while (v11 == v18 && __stlxr((unint64_t)a2, v17));
        v18 = v11;
      }
      while (v11 != v10);
      v38 = v11;
      if (v11)
        *(_QWORD *)(v11 + 16) = a2;
      else
        *(_QWORD *)(a1 + 104) = a2;
      _dispatch_thread_setspecific(122, 0);
      if (!v38)
        _dispatch_root_queue_poke_and_wakeup((uint64_t (***)())a1, 1, 0, v12, v13, v14, v15, v16);
    }
  }
}

void _dispatch_root_queue_push_override(uint64_t a1, _QWORD *a2, unsigned int a3)
{
  uint64_t (**v3)();
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t (**v11)();
  BOOL v12;
  BOOL v13;
  unint64_t v14;
  uint64_t (***v15)();
  char v16;
  _QWORD *v19;
  _QWORD *v20;
  unint64_t v21;
  int v22;

  v16 = 0;
  if ((*(_BYTE *)(a1 + 87) & 0x80) != 0)
  {
    v16 = 2;
  }
  else if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    v16 = 4;
  }
  v13 = 1;
  if (a3)
    v13 = a3 > 6;
  if (v13)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x3DEC0);
  }
  v22 = 0;
  if ((v16 & 2) != 0)
  {
    v22 = 1;
  }
  else if ((v16 & 4) != 0)
  {
    v22 = 2;
  }
  v15 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v22 - 3)];
  v14 = (unint64_t)a2;
  v12 = 0;
  if (*a2 >= 0x1000uLL)
    v12 = *(_QWORD *)(*a2 + 16) == 256;
  if (v12)
  {
    a2[4] = a1;
  }
  else
  {
    v20 = _dispatch_thread_getspecific(0x16uLL);
    if (v20)
    {
      _dispatch_thread_setspecific(22, v20[2]);
      v19 = v20;
    }
    else
    {
      v19 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    }
    v14 = (unint64_t)v19;
    *v19 = &unk_E0E20;
    v19[5] = v19;
    v19[7] = a1;
    v19[6] = a2;
    v19[1] = -1;
    v19[3] = -1;
  }
  *(_QWORD *)(v14 + 16) = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(v15 + 6));
  v10 = (unint64_t *)(v15 + 6);
  v11 = v15[6];
  do
  {
    v3 = v11;
    do
      v4 = __ldaxr(v10);
    while ((uint64_t (**)())v4 == v11 && __stlxr(v14, v10));
    v11 = (uint64_t (**)())v4;
  }
  while (v4 != (_QWORD)v3);
  v21 = v4;
  if (v4)
    *(_QWORD *)(v4 + 16) = v14;
  else
    v15[13] = (uint64_t (**)())v14;
  _dispatch_thread_setspecific(122, 0);
  if (!v21)
    _dispatch_root_queue_poke_and_wakeup(v15, 1, 0, v5, v6, v7, v8, v9);
}

_QWORD *dispatch_pthread_root_queue_create(const char *a1, int a2, uint64_t a3, const void *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_pthread_root_queue_create(a1, a2, a3, a4, 0, a6, a7, a8);
}

_QWORD *_dispatch_pthread_root_queue_create(const char *a1, int a2, uint64_t a3, const void *a4, _OWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v25;
  int v26;
  int v27;
  pthread_attr_t *v28;
  _QWORD *v29;
  const char *v30;
  int v31;
  const char *v35;

  v35 = a1;
  v31 = 0;
  if (a2 < 0)
    v25 = (char)a2;
  else
    v25 = 0;
  if (a1)
  {
    v30 = _dispatch_strdup_if_mutable(a1);
    if (v30 != v35)
    {
      v31 = 0x200000;
      v35 = v30;
    }
  }
  v29 = _dispatch_object_alloc((uint64_t)_OS_dispatch_queue_pthread_root_vtable, 0x140uLL, a3, (uint64_t)a4, (uint64_t)a5, a6, a7, a8);
  _dispatch_queue_init((uint64_t)v29, v31, 4095, 0, v8, v9, v10, v11);
  v29[9] = v35;
  v29[7] = 0x60000000000000;
  *((_DWORD *)v29 + 21) = 0x80000000;
  v29[4] = v29 + 15;
  v28 = (pthread_attr_t *)(v29 + 15);
  _dispatch_root_queue_init_pthread_pool((uint64_t)v29, v25, 0x80000000);
  if (a3)
  {
    __memcpy_chk(v28, a3, 64, -1);
    _dispatch_mgr_priority_raise(v28);
  }
  else
  {
    v27 = pthread_attr_init(v28);
    if (v27)
      _dispatch_bug(7641, v27, v12, v13, v14, v15, v16, v17);
  }
  v26 = pthread_attr_setdetachstate(v28, 2);
  if (v26)
    _dispatch_bug(7644, v26, v18, v19, v20, v21, v22, v23);
  if (a4)
    v29[23] = _dispatch_Block_copy(a4);
  if (a5)
    *(_OWORD *)(v29 + 33) = *a5;
  _dispatch_object_debug((uint64_t)v29, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_pthread_root_queue_create");
  return v29;
}

_QWORD *_dispatch_pthread_root_queue_create_with_observer_hooks_4IOHID(const char *a1, int a2, uint64_t a3, uint64_t a4, const void *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_QWORD *)a4 || !*(_QWORD *)(a4 + 8))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid pthread root queue observer hooks";
    __break(1u);
    JUMPOUT(0x3E5FCLL);
  }
  return _dispatch_pthread_root_queue_create(a1, a2, a3, a5, (_OWORD *)a4, a6, a7, a8);
}

BOOL _dispatch_queue_is_exclusively_owned_by_current_thread_4IOHID(uint64_t a1)
{
  uint64_t v1;
  int v3;

  if (*(_WORD *)(a1 + 80) != 1)
  {
    v1 = *(unsigned __int16 *)(a1 + 80);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid queue type";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x3E68CLL);
  }
  v3 = *(_QWORD *)(a1 + 56);
  return ((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0;
}

_QWORD *dispatch_pthread_root_queue_copy_current()
{
  _QWORD *v1;

  v1 = _dispatch_thread_getspecific(0x14uLL);
  if (!v1)
    return 0;
  while (v1[3])
    v1 = (_QWORD *)v1[3];
  if (*(_QWORD *)(*v1 + 16) != 328721)
    return 0;
  _os_object_retain_with_resurrect((uint64_t)v1);
  return v1;
}

void _dispatch_pthread_root_queue_dispose(_QWORD *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  pthread_attr_t *v8;

  v8 = (pthread_attr_t *)a1[4];
  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_pthread_root_queue_dispose");
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(772079624, a1[8], 0, 0, 0);
  pthread_attr_destroy(v8);
  _dispatch_semaphore_dispose((semaphore_t *)v8[1].__opaque);
  if (v8[1].__sig)
    _Block_release((const void *)v8[1].__sig);
  a1[3] = &off_E4640;
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

void _dispatch_runloop_queue_wakeup(uint64_t a1, unsigned int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unsigned int v16;
  int v18;
  unsigned int v19;

  if ((*(_DWORD *)(a1 + 80) & 0x800000) != 0)
    goto LABEL_2;
  if ((a3 & 2) == 0)
    goto LABEL_29;
  v14 = (unint64_t *)(a1 + 56);
  v15 = *(_QWORD *)(a1 + 56);
  do
  {
    v8 = v15;
    do
      v9 = __ldaxr(v14);
    while (v9 == v15 && __stlxr(v15 | 0x8000000000, v14));
    v15 = v9;
  }
  while (v9 != v8);
  if ((v9 & 0xFFFFFFFC) == 0)
  {
LABEL_2:
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
LABEL_29:
    if (*(_QWORD *)(a1 + 48))
    {
      _dispatch_runloop_queue_poke((unint64_t *)a1, a2, a3);
    }
    else
    {
      v12 = (unint64_t *)(a1 + 56);
      v13 = *(_QWORD *)(a1 + 56);
      do
      {
        v10 = v13;
        do
          v11 = __ldaxr(v12);
        while (v11 == v13 && __stlxr(v13 & 0xFFFFFFF0FFFFFFFFLL, v12));
        v13 = v11;
      }
      while (v11 != v10);
      v16 = (v11 & 0x700000000) >> 32;
      if (v16)
      {
        v18 = *(_QWORD *)(a1 + 56);
        if ((v18 & 0xFFFFFFFC) != 0)
          v19 = v18 | 3;
        else
          v19 = 0;
        if (*(_QWORD *)(a1 + 48))
          _dispatch_runloop_queue_poke((unint64_t *)a1, v16, a3);
        if ((_dispatch_set_qos_class_enabled & 1) != 0)
          _pthread_qos_override_end_direct(v19, a1);
      }
      else if ((a3 & 1) != 0)
      {
        _dispatch_release_2_tailcall((unsigned int *)a1);
      }
    }
  }
}

void _dispatch_runloop_queue_poke(unint64_t *a1, unsigned int a2, char a3)
{
  unint64_t v3;
  unsigned int v4;
  unsigned int v5;
  unint64_t *v6;
  _BOOL4 v7;
  unint64_t v8;
  unint64_t v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;

  if (*(_QWORD *)(*a1 + 16) == 394769 && _dispatch_main_q_handle_pred != -1)
    dispatch_once_f(&_dispatch_main_q_handle_pred, a1, (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  v13 = a2;
  if (!a2)
    v13 = (*((_DWORD *)a1 + 21) & 0xF000u) >> 12;
  if (v13 <= (*((_DWORD *)a1 + 21) & 0xF00u) >> 8)
    v4 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
  else
    v4 = v13;
  v6 = a1 + 7;
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v3 = __ldaxr(v6);
    else
      v3 = __ldxr(v6);
    v8 = v3;
    v12 = v3;
    if ((v3 & 0x700000000) < (unint64_t)v4 << 32)
    {
      v12 = v3 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)v4 << 32);
      if (v3 & 0x1000000000 | ((unint64_t)v4 << 32) & 0x1000000000)
        v12 |= 0x800000000uLL;
    }
    if (v3 == v12)
    {
      __clrex();
      goto LABEL_33;
    }
    if (_os_atomic_mo_has_release(0))
      v7 = __stlxr(v12, v6) == 0;
    else
      v7 = __stxr(v12, v6) == 0;
  }
  while (!v7);
  v5 = (*((_DWORD *)a1 + 21) & 0xF00u) >> 8;
  if (v4 > v5)
  {
    if ((v12 & 0xFFFFFFFC) != 0)
      v15 = v12 | 3;
    else
      v15 = 0;
    v14 = 0;
    if (v4)
      v14 = 1 << (v4 + 7);
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
      _pthread_qos_override_start_direct(v15, v14 | 0xFF, a1);
    if ((v8 & 0x700000000) >> 32 > v5 && (_dispatch_set_qos_class_enabled & 1) != 0)
      _pthread_qos_override_end_direct(v15, a1);
  }
LABEL_33:
  _dispatch_runloop_queue_class_poke((uint64_t)a1);
  if ((a3 & 1) != 0)
    _dispatch_release_2_tailcall((unsigned int *)a1);
}

_QWORD *_dispatch_runloop_root_queue_create_4CF(const char *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  BOOL v35;
  const char *v36;
  _QWORD *v37;
  unsigned int v38;
  unint64_t *v42;
  _BOOL4 v43;
  unint64_t v44;

  v38 = _dispatch_thread_getspecific(4uLL);
  if (a2)
    return 0;
  v37 = _dispatch_object_alloc((uint64_t)_OS_dispatch_queue_runloop_vtable, 0x78uLL, v2, v3, v4, v5, v6, v7);
  _dispatch_queue_init((uint64_t)v37, 0x40000, 1, 0x1000000000, v8, v9, v10, v11);
  v37[3] = &off_E46C0;
  if (a1)
    v36 = a1;
  else
    v36 = "runloop-queue";
  v37[9] = v36;
  v35 = 0;
  if ((v38 & 0x22000000) == 0)
    v35 = (v38 & 0x3F00) != 0;
  if (v35)
  {
    if ((v38 & 0x20000000) != 0)
      _dispatch_abort(447, (v38 & 0x20000000) == 0, v12, v13, v14, v15, v16, v17);
    v18 = (v38 & 0x3FFF00) >> 8;
    v19 = __clz(__rbit32(v18));
    if (v18)
      v20 = v19 + 1;
    else
      v20 = 0;
    *((_DWORD *)v37 + 21) = v38 | (v20 << 8);
  }
  _dispatch_runloop_queue_handle_init(v37);
  if ((v37[10] & 0x40000) == 0)
    _dispatch_abort(2077, (v37[10] & 0x40000) != 0, v21, v22, v23, v24, v25, v26);
  if ((v37[10] & 0x1000000) != 0)
    _dispatch_abort(2083, (v37[10] & 0x1000000) == 0, v21, v22, v23, v24, v25, v26);
  v42 = v37 + 7;
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v27 = __ldaxr(v42);
    else
      v27 = __ldxr(v42);
    v44 = v27 & 0xFFFFFFFF00000003 | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    if (_os_atomic_mo_has_release(0))
      v43 = __stlxr(v44, v42) == 0;
    else
      v43 = __stxr(v44, v42) == 0;
  }
  while (!v43);
  _dispatch_object_debug((uint64_t)v37, "%s", v28, v29, v30, v31, v32, v33, (char)"_dispatch_runloop_root_queue_create_4CF");
  return v37;
}

void _dispatch_runloop_queue_handle_init(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  mach_port_name_t name;
  kern_return_t v8;
  mach_port_context_t context;
  mach_port_options_t options;
  mach_port_name_t v11;
  _QWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  uint64_t v15;
  mach_port_name_t v16;
  _QWORD *v17;

  v13 = a1;
  v12 = a1;
  v11 = 0;
  if ((_dispatch_unsafe_fork & 1) == 0)
    _dispatch_fork_becomes_unsafe_slow();
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_C2930;
  context = (mach_port_context_t)v12;
  v8 = 0;
  name = 0;
  if (*(_QWORD *)(*v12 + 16) == 394769)
  {
    options.flags |= 2u;
    options.mpl.mpl_qlimit = 1;
  }
  v8 = mach_port_construct(mach_task_self_, &options, context, &name);
  if (v8 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x3F7DCLL);
  }
  v15 = v8;
  v14 = 7808;
  if (v8)
    _dispatch_bug(v14, v15, v1, v2, v3, v4, v5, v6);
  v11 = name;
  v17 = v12;
  v16 = name;
  v12[4] = name;
  _dispatch_program_is_probably_callback_driven = 1;
}

uint64_t _dispatch_runloop_queue_xref_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  unint64_t *v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t result;
  unint64_t *v20;
  unint64_t v21;
  unint64_t v22;
  unsigned int v23;
  unsigned int v25;

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_runloop_queue_xref_dispose");
  v22 = *(_QWORD *)(a1 + 56);
  do
  {
    v14 = v22;
    v15 = (unint64_t *)(a1 + 56);
    do
      v16 = __ldaxr(v15);
    while (v16 == v22 && __stlxr(v22 & 0xFFFFFFF0FFFFFFFFLL, v15));
    v22 = v16;
  }
  while (v16 != v14);
  v23 = (v16 & 0x700000000) >> 32;
  if ((*(_DWORD *)(a1 + 80) & 0x40000) == 0)
    _dispatch_abort(2097, (*(_DWORD *)(a1 + 80) & 0x40000) != 0, v8, v9, v10, v11, v12, v13);
  if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0)
    _dispatch_abort(2103, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, v8, v9, v10, v11, v12, v13);
  v20 = (unint64_t *)(a1 + 56);
  v21 = *(_QWORD *)(a1 + 56);
  do
  {
    v17 = v21;
    do
      v18 = __ldaxr(v20);
    while (v18 == v21 && __stlxr(v21 & 0xFFFFFFFF00000003, v20));
    v21 = v18;
  }
  while (v18 != v17);
  result = (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, v23, 2);
  if (v23)
  {
    if ((*(_QWORD *)(a1 + 56) & 0xFFFFFFFC) != 0)
      v25 = *(_QWORD *)(a1 + 56) | 3;
    else
      v25 = 0;
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
      return _pthread_qos_override_end_direct(v25, a1);
  }
  return result;
}

void _dispatch_runloop_queue_dispose(mach_port_context_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_runloop_queue_dispose");
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(772079624, *(_QWORD *)(a1 + 64), 0, 0, 0);
  _dispatch_runloop_queue_handle_dispose(a1);
  _dispatch_lane_class_dispose(a1, a2);
}

void _dispatch_runloop_queue_handle_dispose(mach_port_context_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v7;
  kern_return_t v8;
  mach_port_name_t v9;

  v9 = *(_QWORD *)(a1 + 32);
  v7 = 0;
  if (v9)
    v7 = v9 != -1;
  if (v7)
  {
    *(_QWORD *)(a1 + 32) = 0;
    v8 = mach_port_destruct(mach_task_self_, v9, -1, a1);
    if (v8 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x3FE10);
    }
    if (v8)
      _dispatch_bug(7864, v8, v1, v2, v3, v4, v5, v6);
  }
}

BOOL _dispatch_runloop_root_queue_perform_4CF(dispatch_object_s *a1)
{
  uint64_t v1;
  BOOL v3;

  if (*(_QWORD *)(*(_QWORD *)a1 + 16) != 395025)
  {
    v1 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x3FEE0);
  }
  dispatch_retain(a1);
  v3 = _dispatch_runloop_queue_drain_one((unint64_t *)a1);
  dispatch_release(a1);
  return v3;
}

BOOL _dispatch_runloop_queue_drain_one(unint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t *v28;
  uint64_t v29;
  unint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  _BOOL4 v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  void *v59;
  uint64_t v60;
  BOOL v61;
  int v62;
  unsigned int *v63;
  unsigned int v64;
  uint64_t v65;
  _QWORD *v66;
  _OWORD v67[2];
  unsigned int v68;
  uint64_t v69;
  unsigned int v70;
  void *v71;
  unint64_t *v72;
  char v73;
  __int128 v74;
  unint64_t *v75;
  void *v77;
  uint64_t v78;
  uint64_t v79;
  BOOL v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void *object;
  void *v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t *v94;
  unint64_t *v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  _BOOL4 v106;
  BOOL v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _BOOL4 v111;
  unint64_t v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unint64_t v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t *v122;
  unsigned int v123;
  char v124;
  void *v125;
  unint64_t v126;
  uint64_t v127;
  _BOOL8 v128;
  uint64_t v129;
  uint64_t v130;
  unint64_t v131;
  uint64_t v132;
  uint64_t v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  unint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  _BOOL8 v145;
  void *v146;
  void *v147;
  unsigned int v148;
  unsigned int v149;
  unsigned int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  __int128 *v155;
  unint64_t *v156;
  __int128 *v157;
  unsigned int v158;
  unsigned int v159;
  __int128 *v160;
  int v161;
  unsigned int v162;
  unsigned int v163;
  BOOL v164;
  int v165;
  uint64_t v166;
  _BOOL8 v167;
  unint64_t v168;
  char v169;
  unint64_t v170;
  unint64_t v171;
  unint64_t v172;
  _QWORD *v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  int v177;
  int v178;
  unsigned int v179;
  unsigned int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  _QWORD *v185;

  v75 = a1;
  if (!a1[6])
    return 0;
  v74 = 0uLL;
  v73 = 0;
  v170 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  v168 = v170 & 0xFFFFFFFFFFFFFFFELL;
  if ((v170 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    v169 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825);
    v172 = v168;
    if (v168 && v172 != -4)
    {
      v171 = v172;
      v185 = (_QWORD *)v172;
      v184 = 0;
      v182 = 1;
      v181 = 1;
      v183 = 1;
      v179 = 0;
      v177 = 1;
      v176 = 1;
      v178 = 1;
      v63 = (unsigned int *)(v172 + 96);
      v64 = *(_DWORD *)(v172 + 96);
      do
      {
        v13 = v64;
        do
          v14 = __ldaxr(v63);
        while (v14 == v64 && __stlxr(v64 - 1, v63));
        v64 = v14;
      }
      while (v14 != v13);
      v175 = v14;
      v179 = v14;
      v174 = v14;
      v180 = v14 - v183;
      v184 = v14 - v183;
      if (((v14 - v183) & 0x80000000) != 0)
      {
        if (v184 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x40148);
        }
        v185[7] = 0xDEAD000000000000;
        v173 = v185;
        _dispatch_object_dealloc(v185);
      }
    }
    _dispatch_thread_setspecific(27, -4);
    v169 = 1;
  }
  v73 = v169;
  v72 = v75;
  v156 = v75;
  v155 = &v74;
  v160 = &v74;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v74, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20, (uint64_t)v156, 21, (uint64_t)v155, v15, v16, v17, v18);
  v77 = 0;
  v77 = _dispatch_thread_getspecific(4uLL);
  v71 = v77;
  v70 = 0;
  v125 = v77;
  v124 = 1;
  v128 = (v77 & 0x20000000) == 0;
  v127 = 447;
  if ((v77 & 0x20000000) != 0)
    _dispatch_abort(v127, v128, v19, v20, v21, v22, v23, v24);
  v123 = v125 & 0x8E0000FF;
  v126 = (unint64_t)(v125 & 0x3FFF00) >> 8;
  v25 = (v125 & 0x3FFF00) >> 8;
  v26 = __clz(__rbit32(v25));
  if (v25)
    v27 = v26 + 1;
  else
    v27 = 0;
  v123 |= v27 << 8;
  v70 = v123;
  v69 = 0;
  v146 = 0;
  v146 = _dispatch_thread_getspecific(0x1CuLL);
  if (v146)
  {
    v147 = v146;
    os_retain(v146);
  }
  v69 = (uint64_t)v146;
  v68 = 0;
  v150 = v70;
  v149 = 0;
  v149 = _dispatch_thread_getspecific(0x19uLL);
  v148 = v149;
  if (v149)
  {
    if ((v150 & 0xFFF) != 0)
    {
      v148 &= 0x880F0000;
      if ((v149 & 0xFFF) > (v150 & 0xFFF))
        v62 = v149 & 0xFFF;
      else
        v62 = v150 & 0xFFF;
      v148 |= v62;
      v152 = v150 & 0xF000;
      v154 = v148 & 0xF00;
      if (v152 >> 12 > v154 >> 8)
        v150 &= 0x4400F000u;
      else
        v150 &= 0x40000000u;
      v148 |= v150;
    }
    else
    {
      if ((v148 & 0xFFF) != 0)
        v148 |= 0x40000000u;
      v151 = v150 & 0xF000;
      v153 = v148 & 0xF00;
      if (v151 >> 12 > v153 >> 8)
      {
        v148 &= 0xFFFF0FFF;
        v148 |= v150 & 0x400F000;
      }
    }
  }
  else
  {
    v148 = v150 & 0xFFF0FFFF;
  }
  _dispatch_thread_setspecific(25, v148);
  v68 = v149;
  v88 = 15;
  v87 = 0;
  v87 = _dispatch_thread_getspecific(0x19uLL);
  v161 = v87 & 0xF0000;
  if ((v87 & 0xF0000) >> 16 < v88)
  {
    v87 &= 0xFFF0FFFF;
    v87 |= v88 << 16;
    _dispatch_thread_setspecific(25, v87);
  }
  memset(v67, 0, sizeof(v67));
  v95 = v75;
  v94 = v75 + 13;
  v93 = 0;
  v92 = 0;
  v91 = v75[13];
  v92 = v91;
  v90 = v91;
  v93 = v91;
  if (!v91)
    v93 = _dispatch_wait_for_enqueuer(v94, (uint64_t)(v95 + 6));
  v89 = v93;
  v66 = (_QWORD *)v93;
  v122 = v75;
  v121 = v93;
  v120 = v93;
  v119 = 0;
  v118 = 0;
  v117 = *(_QWORD *)(v93 + 16);
  v118 = v117;
  v116 = v117;
  v119 = v117;
  v115 = v117;
  v114 = v117;
  v75[13] = v117;
  v113 = v115;
  v61 = 0;
  if (!v119)
  {
    v112 = v120;
    v111 = 0;
    v28 = v122 + 6;
    v109 = 0;
    v108 = 0;
    v110 = 0;
    v29 = v120;
    do
      v30 = __ldaxr(v28);
    while (v30 == v29 && __stlxr(0, v28));
    if (v30 != v29)
      v112 = v30;
    v107 = v30 == v29;
    v111 = v30 == v29;
    v106 = v111;
    v61 = v30 != v29;
  }
  if (v61)
  {
    v105 = v120;
    v104 = 0;
    v103 = 0;
    v102 = *(_QWORD *)(v120 + 16);
    v103 = v102;
    v101 = v102;
    v104 = v102;
    if (!v102)
      v104 = _dispatch_wait_for_enqueuer((unint64_t *)(v105 + 16), (uint64_t)(v122 + 6));
    v100 = v104;
    v119 = v104;
    v99 = v104;
    v98 = v104;
    v122[13] = v104;
    v97 = v99;
  }
  v96 = v119;
  v65 = v119;
  _dispatch_continuation_pop_inline(v66, (uint64_t)v67, 0x80000, (uint64_t)v75);
  if (!v65)
    (*(void (**)(unint64_t *, _QWORD))(*v75 + 64))(v75, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: runloop queue restore", v31, v32, v33, v34, v35, v36, v37, 8135);
  v159 = v68;
  v158 = 0;
  v158 = _dispatch_thread_getspecific(0x19uLL);
  v159 &= 0xFFF0FFFF;
  v159 |= v158 & 0xF0000;
  _dispatch_thread_setspecific(25, v159);
  v163 = 0;
  v163 = _dispatch_thread_getspecific(0x19uLL);
  v165 = v163 & 0xF0000;
  v162 = (v163 & 0xF0000) >> 16;
  if ((v163 & 0xF0000) >> 16)
  {
    v163 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25, v163);
    v164 = v162 != 15;
  }
  else
  {
    v164 = 0;
  }
  v79 = (uint64_t)v71;
  v78 = v69;
  if (v71 == (void *)-1)
    v79 = 0;
  v83 = v79;
  v82 = v78;
  v81 = 6;
  v132 = v79;
  v145 = v79 != -1;
  v144 = 2332;
  if (v79 == -1)
    _dispatch_abort(v144, v145, v38, v39, v40, v41, v42, v43);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v143 = v132;
    v142 = 4261412863;
    v141 = 0;
    v132 &= 0xFFFFFFFF02FFFFFFLL;
    v131 = 0;
    v134 = 0;
    v134 = _dispatch_thread_getspecific(4uLL);
    v131 = (unint64_t)v134;
    v130 = 0x1000000;
    v129 = 2281701376;
    if ((v134 & 0x1000000) != 0)
    {
      if (v132)
      {
        v60 = v132;
      }
      else
      {
        v140 = v131;
        v139 = v130;
        v138 = 0;
        v60 = v131 & (~v130 | 0xFFFFFF);
      }
      v133 = v60;
    }
    else
    {
      v137 = v131;
      v136 = v129;
      v135 = 0;
      v131 &= ~v129 | 0xFFFFFF;
      if (v132 == v131)
        v133 = 0;
      else
        v133 = v132;
    }
  }
  else
  {
    v133 = 0;
  }
  v83 = v133;
  if (v133)
  {
LABEL_85:
    v84 = _dispatch_set_priority_and_voucher_slow(v83, (_DWORD *)v82, v81);
    goto LABEL_86;
  }
  if (v82 != -1)
  {
    v59 = (void *)v82;
    if (v59 == _dispatch_thread_getspecific(0x1CuLL))
    {
      v80 = (v81 & 4) != 0;
      if ((v81 & 2) != 0)
      {
        if (v80 && v82)
        {
          object = (void *)v82;
          os_release((void *)v82);
        }
        v82 = -1;
      }
      else if (!v80 && v82)
      {
        v86 = (void *)v82;
        os_retain((void *)v82);
      }
      v84 = v82;
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  v84 = -1;
LABEL_86:
  v157 = &v74;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v74, v39, v40, v41, v42, v43);
  if ((v73 & 1) != 0)
  {
    v50 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
    v167 = v50;
    v166 = 871;
    if (!v50)
      _dispatch_abort(v166, v167, v44, v45, v46, v47, v48, v49);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: clear current", v51, v52, v53, v54, v55, v56, v57, 872);
    _dispatch_thread_setspecific(27, 0);
    _dispatch_thread_setspecific(5, 0);
  }
  _dispatch_force_cache_cleanup();
  return v65 != 0;
}

void _dispatch_runloop_root_queue_wakeup_4CF(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;

  if (*(_QWORD *)(*(_QWORD *)a1 + 16) != 395025)
  {
    v8 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0x40DECLL);
  }
  _dispatch_runloop_queue_wakeup(a1, 0, 0, a4, a5, a6, a7, a8);
}

uint64_t _dispatch_runloop_root_queue_get_port_4CF(unsigned int *a1)
{
  uint64_t v1;

  if (*(_QWORD *)(*(_QWORD *)a1 + 16) != 395025)
  {
    v1 = *(_QWORD *)(*(_QWORD *)a1 + 16);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Not a runloop queue";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x40E9CLL);
  }
  return a1[8];
}

uint64_t _dispatch_get_main_queue_handle_4CF()
{
  if (_dispatch_main_q_handle_pred != -1)
    dispatch_once_f(&_dispatch_main_q_handle_pred, &_dispatch_main_q, (dispatch_function_t)_dispatch_runloop_queue_handle_init);
  return unk_E4060;
}

uint64_t _dispatch_get_main_queue_port_4CF()
{
  return _dispatch_get_main_queue_handle_4CF();
}

void _dispatch_main_queue_callback_4CF()
{
  if (!dword_E40B0)
  {
    dword_E40B0 = 1;
    _dispatch_main_queue_drain((uint64_t)&_dispatch_main_q);
    dword_E40B0 = 0;
  }
}

void _dispatch_main_queue_drain(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  _BOOL4 v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *v57;
  uint64_t v58;
  _QWORD *v59;
  unint64_t *v60;
  unint64_t v61;
  int v62;
  unsigned int *v63;
  unsigned int v64;
  uint64_t v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD *v68;
  _BYTE v69[44];
  unsigned int v70;
  uint64_t v71;
  unsigned int v72;
  unsigned int v73;
  void *v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  __int128 v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  BOOL v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  void *object;
  void *v94;
  uint64_t v95;
  int v96;
  int v97;
  int v98;
  uint64_t v99;
  unsigned int v100;
  unsigned int v101;
  unsigned int v102;
  unsigned int v103;
  dispatch_function_t function;
  void *context;
  dispatch_once_t *predicate;
  unsigned int v107;
  char v108;
  void *v109;
  unint64_t v110;
  uint64_t v111;
  _BOOL8 v112;
  int v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  void *v119;
  uint64_t v120;
  uint64_t v121;
  unint64_t v122;
  uint64_t v123;
  uint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  _BOOL8 v130;
  void *v131;
  void *v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  unsigned int v139;
  __int128 *v140;
  unsigned int v141;
  unsigned int v142;
  uint64_t v143;
  __int128 *v144;
  uint64_t v145;
  __int128 *v146;
  int v147;
  unsigned int v148;
  unsigned int v149;
  BOOL v150;
  int v151;
  uint64_t v152;
  _BOOL8 v153;
  unint64_t v154;
  char v155;
  unint64_t v156;
  unint64_t v157;
  unint64_t v158;
  _QWORD *v159;
  unsigned int v160;
  unsigned int v161;
  int v162;
  int v163;
  int v164;
  unsigned int v165;
  unsigned int v166;
  int v167;
  int v168;
  int v169;
  int v170;
  _QWORD *v171;

  v83 = a1;
  v82 = 0uLL;
  if (!*(_QWORD *)(a1 + 48))
    return;
  v81 = v83;
  v95 = v83;
  v99 = v83;
  v98 = 0;
  v97 = *(_DWORD *)(v83 + 80);
  v98 = v97;
  v96 = v97;
  if (((BYTE2(v97) >> 2) & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called after dispatch_main()";
    __break(1u);
    JUMPOUT(0x41088);
  }
  v80 = 0;
  v79 = 0;
  v78 = *(_QWORD *)(v83 + 56);
  v79 = v78;
  v77 = v78;
  v80 = v78;
  v84 = v78;
  v113 = v78;
  if (((v78 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    v76 = v80;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_main_queue_callback_4CF called from the wrong thread";
    qword_E4DA8 = v80;
    __break(1u);
    JUMPOUT(0x41138);
  }
  predicate = &_dispatch_main_q_handle_pred;
  context = (void *)v83;
  function = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1)
    dispatch_once_f(predicate, context, function);
  v156 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  v154 = v156 & 0xFFFFFFFFFFFFFFFELL;
  if ((v156 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    v155 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v6, v7, v8, v9, v10, v11, v12, 825);
    v158 = v154;
    if (v154 && v158 != -4)
    {
      v157 = v158;
      v171 = (_QWORD *)v158;
      v170 = 0;
      v168 = 1;
      v167 = 1;
      v169 = 1;
      v165 = 0;
      v163 = 1;
      v162 = 1;
      v164 = 1;
      v63 = (unsigned int *)(v158 + 96);
      v64 = *(_DWORD *)(v158 + 96);
      do
      {
        v13 = v64;
        do
          v14 = __ldaxr(v63);
        while (v14 == v64 && __stlxr(v64 - 1, v63));
        v64 = v14;
      }
      while (v14 != v13);
      v161 = v14;
      v165 = v14;
      v160 = v14;
      v166 = v14 - v169;
      v170 = v14 - v169;
      if (((v14 - v169) & 0x80000000) != 0)
      {
        if (v170 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x41344);
        }
        v171[7] = 0xDEAD000000000000;
        v159 = v171;
        _dispatch_object_dealloc(v171);
      }
    }
    _dispatch_thread_setspecific(27, -4);
    v155 = 1;
  }
  if ((v155 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x413B4);
  }
  v75 = v83;
  v145 = v83;
  v144 = &v82;
  v143 = 0;
  v146 = &v82;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v82, v1, v2, v3, v4, v5);
  _dispatch_thread_setspecific_pair(20, v145, 21, v143, v15, v16, v17, v18);
  v85 = 0;
  v85 = _dispatch_thread_getspecific(4uLL);
  v74 = v85;
  v73 = 0;
  v109 = v85;
  v108 = 1;
  v112 = (v85 & 0x20000000) == 0;
  v111 = 447;
  if ((v85 & 0x20000000) != 0)
    _dispatch_abort(v111, v112, v19, v20, v21, v22, v23, v24);
  v107 = v109 & 0x8E0000FF;
  v110 = (unint64_t)(v109 & 0x3FFF00) >> 8;
  v25 = (v109 & 0x3FFF00) >> 8;
  v26 = __clz(__rbit32(v25));
  if (v25)
    v27 = v26 + 1;
  else
    v27 = 0;
  v107 |= v27 << 8;
  v73 = v107;
  v101 = v107 & 0xF00;
  v72 = v101 >> 8;
  v71 = 0;
  v131 = 0;
  v131 = _dispatch_thread_getspecific(0x1CuLL);
  if (v131)
  {
    v132 = v131;
    os_retain(v131);
  }
  v71 = (uint64_t)v131;
  LOWORD(v100) = *(_DWORD *)(v83 + 84);
  v100 &= 0xF00u;
  if (v72 != v100 >> 8)
    _dispatch_main_queue_update_priority_from_thread();
  v70 = 0;
  v135 = v73;
  v134 = 0;
  v134 = _dispatch_thread_getspecific(0x19uLL);
  v133 = v134;
  if (v134)
  {
    if ((v135 & 0xFFF) != 0)
    {
      v133 &= 0x880F0000;
      if ((v134 & 0xFFF) > (v135 & 0xFFF))
        v62 = v134 & 0xFFF;
      else
        v62 = v135 & 0xFFF;
      v133 |= v62;
      v137 = v135 & 0xF000;
      v139 = v133 & 0xF00;
      if (v137 >> 12 > v139 >> 8)
        v135 &= 0x4400F000u;
      else
        v135 &= 0x40000000u;
      v133 |= v135;
    }
    else
    {
      if ((v133 & 0xFFF) != 0)
        v133 |= 0x40000000u;
      v136 = v135 & 0xF000;
      v138 = v133 & 0xF00;
      if (v136 >> 12 > v138 >> 8)
      {
        v133 &= 0xFFFF0FFF;
        v133 |= v135 & 0x400F000;
      }
    }
  }
  else
  {
    v133 = v135 & 0xFFF0FFFF;
  }
  _dispatch_thread_setspecific(25, v133);
  v70 = v134;
  v103 = 15;
  v102 = 0;
  v102 = _dispatch_thread_getspecific(0x19uLL);
  v147 = v102 & 0xF0000;
  if ((v102 & 0xF0000) >> 16 < v103)
  {
    v102 &= 0xFFF0FFFF;
    v102 |= v103 << 16;
    _dispatch_thread_setspecific(25, v102);
  }
  memset(v69, 0, 32);
  v67 = *(_QWORD *)(v83 + 104);
  if (!v67)
    v67 = _dispatch_wait_for_enqueuer((unint64_t *)(v83 + 104), v83 + 48);
  *(_QWORD *)(v83 + 104) = 0;
  v60 = (unint64_t *)(v83 + 48);
  v61 = *(_QWORD *)(v83 + 48);
  do
  {
    v28 = v61;
    do
      v29 = __ldaxr(v60);
    while (v29 == v61 && __stlxr(0, v60));
    v59 = (_QWORD *)v29;
    v61 = v29;
  }
  while (v29 != v28);
  v68 = (_QWORD *)v67;
  do
  {
    v66 = 0;
    if (v68 != v59)
    {
      v65 = v68[2];
      if (!v65)
        v65 = _dispatch_wait_for_enqueuer(v68 + 2, 0);
      v66 = (_QWORD *)v65;
    }
    _dispatch_continuation_pop_inline(v68, (uint64_t)v69, 0x80000, v83);
    v68 = v66;
  }
  while (v66);
  (*(void (**)(uint64_t, _QWORD))(*(_QWORD *)v83 + 64))(v83, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: main queue restore", v30, v31, v32, v33, v34, v35, v36, 8098);
  v142 = v70;
  v141 = 0;
  v141 = _dispatch_thread_getspecific(0x19uLL);
  v142 &= 0xFFF0FFFF;
  v142 |= v141 & 0xF0000;
  _dispatch_thread_setspecific(25, v142);
  v149 = 0;
  v149 = _dispatch_thread_getspecific(0x19uLL);
  v151 = v149 & 0xF0000;
  v148 = (v149 & 0xF0000) >> 16;
  if ((v149 & 0xF0000) >> 16)
  {
    v149 &= 0xFFF0FFFF;
    _dispatch_thread_setspecific(25, v149);
    v150 = v148 != 15;
  }
  else
  {
    v150 = 0;
  }
  v87 = (uint64_t)v74;
  v86 = v71;
  if (v74 == (void *)-1)
    v87 = 0;
  v91 = v87;
  v90 = v86;
  v89 = 6;
  v117 = v87;
  v130 = v87 != -1;
  v129 = 2332;
  if (v87 == -1)
    _dispatch_abort(v129, v130, v37, v38, v39, v40, v41, v42);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v128 = v117;
    v127 = 4261412863;
    v126 = 0;
    v117 &= 0xFFFFFFFF02FFFFFFLL;
    v116 = 0;
    v119 = 0;
    v119 = _dispatch_thread_getspecific(4uLL);
    v116 = (unint64_t)v119;
    v115 = 0x1000000;
    v114 = 2281701376;
    if ((v119 & 0x1000000) != 0)
    {
      if (v117)
      {
        v58 = v117;
      }
      else
      {
        v125 = v116;
        v124 = v115;
        v123 = 0;
        v58 = v116 & (~v115 | 0xFFFFFF);
      }
      v118 = v58;
    }
    else
    {
      v122 = v116;
      v121 = v114;
      v120 = 0;
      v116 &= ~v114 | 0xFFFFFF;
      if (v117 == v116)
        v118 = 0;
      else
        v118 = v117;
    }
  }
  else
  {
    v118 = 0;
  }
  v91 = v118;
  if (v118)
  {
LABEL_92:
    v92 = _dispatch_set_priority_and_voucher_slow(v91, (_DWORD *)v90, v89);
    goto LABEL_93;
  }
  if (v90 != -1)
  {
    v57 = (void *)v90;
    if (v57 == _dispatch_thread_getspecific(0x1CuLL))
    {
      v88 = (v89 & 4) != 0;
      if ((v89 & 2) != 0)
      {
        if (v88 && v90)
        {
          object = (void *)v90;
          os_release((void *)v90);
        }
        v90 = -1;
      }
      else if (!v88 && v90)
      {
        v94 = (void *)v90;
        os_retain((void *)v90);
      }
      v92 = v90;
      goto LABEL_93;
    }
    goto LABEL_92;
  }
  v92 = -1;
LABEL_93:
  v140 = &v82;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v82, v38, v39, v40, v41, v42);
  v49 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
  v153 = v49;
  v152 = 871;
  if (!v49)
    _dispatch_abort(v152, v153, v43, v44, v45, v46, v47, v48);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v50, v51, v52, v53, v54, v55, v56, 872);
  _dispatch_thread_setspecific(27, 0);
  _dispatch_thread_setspecific(5, 0);
  _dispatch_force_cache_cleanup();
}

uint64_t _dispatch_main_queue_push(uint64_t a1, unint64_t a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t *v4;
  unint64_t v5;
  uint64_t result;
  BOOL v7;
  unint64_t v8;
  unsigned int v11;
  unsigned int v12;
  unint64_t v14;

  *(_QWORD *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, a1 + 48);
  v8 = *(_QWORD *)(a1 + 48);
  do
  {
    v3 = v8;
    v4 = (unint64_t *)(a1 + 48);
    do
      v5 = __ldaxr(v4);
    while (v5 == v8 && __stlxr(a2, v4));
    v8 = v5;
  }
  while (v5 != v3);
  v14 = v5;
  if (v5)
    *(_QWORD *)(v5 + 16) = a2;
  else
    *(_QWORD *)(a1 + 104) = a2;
  result = _dispatch_thread_setspecific(122, 0);
  if (!v14)
    return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, a3, 2);
  if (a3 <= (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8)
    v11 = 0;
  else
    v11 = a3;
  v12 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32;
  v7 = 1;
  if (v12)
    v7 = v12 < v11;
  if (v7)
    return (*(uint64_t (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, v11, 0);
  return result;
}

void _dispatch_main_queue_wakeup(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x1000000) != 0)
      _dispatch_abort(8282, (*(_DWORD *)(a1 + 80) & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    _dispatch_runloop_queue_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
  else
  {
    _dispatch_lane_wakeup(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void dispatch_main(void)
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (_dispatch_root_queues_pred != -1)
    dispatch_once_f(&_dispatch_root_queues_pred, 0, (dispatch_function_t)_dispatch_root_queues_init_once);
  if (pthread_main_np())
  {
    if (!dword_E40B0)
    {
      dword_E40B0 = 1;
      _dispatch_main_queue_drain((uint64_t)&_dispatch_main_q);
      dword_E40B0 = 0;
      _dispatch_object_debug((uint64_t)&_dispatch_main_q, "%s", v0, v1, v2, v3, v4, v5, (char)"dispatch_main");
      _dispatch_program_is_probably_callback_driven = 1;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(735838216, 0, 0, 0, 0);
      pthread_exit(0);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main called from a block on the main queue";
    __break(1u);
  }
  else
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_main() must be called on the main thread";
    __break(1u);
  }
  JUMPOUT(0x42444);
}

void sub_42534()
{
  __break(1u);
}

dispatch_queue_global_t dispatch_get_global_queue(intptr_t identifier, uintptr_t flags)
{
  int v4;
  int v5;
  int v6;

  if ((flags & 0xFFFFFFFFFFFFFFF9) != 0)
    return 0;
  if ((flags & 2) != 0 && (flags & 4) != 0)
    return 0;
  switch(identifier)
  {
    case -32768:
      v4 = 2;
      break;
    case -128:
      v4 = 3;
      break;
    case -2:
      v4 = 3;
      break;
    default:
      if (identifier)
      {
        if (identifier == 2)
        {
          v4 = 5;
        }
        else
        {
          switch((int)identifier)
          {
            case 5:
              v5 = 1;
              break;
            case 9:
              v5 = 2;
              break;
            case 17:
              v5 = 3;
              break;
            case 21:
              v5 = 4;
              break;
            case 25:
              v5 = 5;
              break;
            case 33:
              v5 = 6;
              break;
            default:
              v5 = 0;
              break;
          }
          v4 = v5;
        }
      }
      else
      {
        v4 = 4;
      }
      break;
  }
  if (!v4)
    return 0;
  v6 = 0;
  if ((flags & 2) != 0)
  {
    v6 = 1;
  }
  else if ((flags & 4) != 0)
  {
    v6 = 2;
  }
  return (dispatch_queue_global_t)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v4 + v6 - 3)];
}

uint64_t libdispatch_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v10;
  unsigned int v11;
  _BOOL4 v12;
  unint64_t v13;

  if (_dispatch_getenv_BOOL("LIBDISPATCH_STRICT", 0))
    _dispatch_mode |= 1u;
  if (_dispatch_getenv_BOOL("LIBDISPATCH_COOPERATIVE_POOL_STRICT", 0))
    _dispatch_mode |= 4u;
  if (getenv("LIBDISPATCH_DISABLE_KEVENT_WQ"))
    _dispatch_kevent_workqueue_enabled = 0;
  v10 = qos_class_main() - 5;
  if (v10 <= 0x1C)
    __asm { BR              X8 }
  dword_E4094 = 0;
  if (!getenv("LIBDISPATCH_DISABLE_SET_QOS"))
    _dispatch_set_qos_class_enabled = 1;
  _dispatch_thread_key_create(&dispatch_priority_key, 0);
  _dispatch_thread_key_create(&dispatch_r2k_key, 0);
  _dispatch_thread_key_create(&dispatch_queue_key, (uint64_t)_dispatch_queue_cleanup);
  _dispatch_thread_key_create(&dispatch_frame_key, (uint64_t)_dispatch_frame_cleanup);
  _dispatch_thread_key_create(&dispatch_cache_key, (uint64_t)_dispatch_cache_cleanup);
  _dispatch_thread_key_create(&dispatch_context_key, (uint64_t)_dispatch_context_cleanup);
  _dispatch_thread_key_create(&dispatch_pthread_root_queue_observer_hooks_key, 0);
  _dispatch_thread_key_create(&dispatch_basepri_key, 0);
  _dispatch_thread_key_create(&dispatch_wlh_key, (uint64_t)_dispatch_wlh_cleanup);
  _dispatch_thread_key_create(&dispatch_voucher_key, (uint64_t)_voucher_thread_cleanup);
  _dispatch_thread_key_create(&dispatch_deferred_items_key, (uint64_t)_dispatch_deferred_items_cleanup);
  _dispatch_thread_key_create(&dispatch_quantum_key, 0);
  _dispatch_thread_key_create(&dispatch_dsc_key, 0);
  _dispatch_thread_key_create(&os_workgroup_join_token_key, (uint64_t)_os_workgroup_join_token_tsd_cleanup);
  _dispatch_thread_key_create(&os_workgroup_key, (uint64_t)_os_workgroup_tsd_cleanup);
  _dispatch_thread_key_create(&dispatch_enqueue_key, 0);
  _dispatch_thread_key_create(&dispatch_msgv_aux_key, (uint64_t)&_free);
  _dispatch_thread_key_create(&dispatch_set_threadname_key, 0);
  _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_main_q);
  if ((unk_E4090 & 0x40000) == 0)
    _dispatch_abort(2077, (unk_E4090 & 0x40000) != 0, v0, v1, v2, v3, v4, v5);
  if ((unk_E4090 & 0x1000000) != 0)
    _dispatch_abort(2083, (unk_E4090 & 0x1000000) == 0, v0, v1, v2, v3, v4, v5);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v6 = __ldaxr((unint64_t *)&dword_E4078);
    else
      v6 = __ldxr((unint64_t *)&dword_E4078);
    v13 = v6 & 0xFFFFFFFF00000003 | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    if (_os_atomic_mo_has_release(0))
      v12 = __stlxr(v13, (unint64_t *)&dword_E4078) == 0;
    else
      v12 = __stxr(v13, (unint64_t *)&dword_E4078) == 0;
  }
  while (!v12);
  v11 = _dispatch_thread_getspecific(0x19uLL);
  if ((v11 & 0xF0000) >> 16 < 0xF)
    _dispatch_thread_setspecific(25, v11 & 0xFFF0FFFF | 0xF0000);
  _dispatch_time_init();
  v8 = _os_object_atfork_prepare(v7);
  _os_object_atfork_prepare(v8);
  _voucher_init();
  return _workgroup_init();
}

_QWORD *_dispatch_thread_key_create(_QWORD *result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  if (*result && a2)
  {
    result = (_QWORD *)pthread_key_init_np(*result, a2);
    if ((_DWORD)result)
      _dispatch_abort(119, (int)result, v2, v3, v4, v5, v6, v7);
  }
  return result;
}

void _dispatch_queue_cleanup(dispatch_queue_s *a1)
{
  if (a1 != &_dispatch_main_q)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch queue is running";
    qword_E4DA8 = (uint64_t)a1;
    __break(1u);
    JUMPOUT(0x42FC8);
  }
  _dispatch_queue_cleanup2();
}

void _dispatch_frame_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch frame is active";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_4301C()
{
  __break(1u);
}

void _dispatch_cache_cleanup(_QWORD *a1)
{
  _QWORD *v2;

  while (1)
  {
    v2 = a1;
    if (!a1)
      break;
    a1 = (_QWORD *)a1[2];
    _dispatch_continuation_free_to_heap(v2);
  }
}

void _dispatch_context_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit while a dispatch context is set";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_430CC()
{
  __break(1u);
}

void _dispatch_wlh_cleanup(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  _QWORD *v5;

  v5 = (_QWORD *)(a1 & 0xFFFFFFFFFFFFFFFELL);
  v3 = (unsigned int *)((a1 & 0xFFFFFFFFFFFFFFFELL) + 96);
  v4 = *v3;
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    v4 = v2;
  }
  while (v2 != v1);
  if (((v2 - 1) & 0x80000000) != 0)
  {
    if ((int)(v2 - 1) <= -2)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x4321CLL);
    }
    v5[7] = 0xDEAD000000000000;
    _dispatch_object_dealloc(v5);
  }
}

void _dispatch_deferred_items_cleanup(uint64_t a1)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread exit with unhandled deferred items";
  qword_E4DA8 = a1;
  __break(1u);
}

void sub_43290()
{
  __break(1u);
}

void _dispatch_queue_atfork_child(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t i;
  _BOOL4 v10;
  unint64_t v11;

  if ((unk_E4090 & 0x40000) != 0)
  {
    if ((unk_E4090 & 0x1000000) != 0)
      _dispatch_abort(2083, (unk_E4090 & 0x1000000) == 0, a3, a4, a5, a6, a7, a8);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v8 = __ldaxr((unint64_t *)&unk_E4078);
      else
        v8 = __ldxr((unint64_t *)&unk_E4078);
      v11 = v8 & 0xFFFFFFFF00000003 | (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      if (_os_atomic_mo_has_release(0))
        v10 = __stlxr(v11, (unint64_t *)&unk_E4078) == 0;
      else
        v10 = __stxr(v11, (unint64_t *)&unk_E4078) == 0;
    }
    while (!v10);
  }
  if ((_dispatch_unsafe_fork & 1) != 0)
  {
    unk_E40A8 = 256;
    unk_E4070 = 256;
    qword_E41A8 = 256;
    qword_E4170 = 256;
    for (i = 0; i < 0x12; ++i)
    {
      (&_dispatch_root_queues)[16 * i + 13] = (uint64_t (**)())(&stru_B8 + 72);
      (&_dispatch_root_queues)[16 * i + 6] = (uint64_t (**)())(&stru_B8 + 72);
    }
  }
}

void _dispatch_fork_becomes_unsafe_slow()
{
  unsigned __int8 v0;
  int v1;
  unsigned __int8 v2;

  v2 = _dispatch_unsafe_fork;
  do
  {
    v0 = v2;
    do
      v1 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
    while (v1 == v2 && __stlxr(v2 | 1, (unsigned __int8 *)&_dispatch_unsafe_fork));
    v2 = v1;
  }
  while (v1 != v0);
  if ((v1 & 2) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Transition to multithreaded is prohibited";
    __break(1u);
    JUMPOUT(0x436D8);
  }
}

uint64_t _dispatch_prohibit_transition_to_multithreaded(uint64_t result)
{
  unsigned __int8 v1;
  int v2;
  unsigned __int8 v3;
  int v4;
  unsigned __int8 v5;
  unsigned __int8 v6;

  if ((result & 1) != 0)
  {
    v6 = _dispatch_unsafe_fork;
    do
    {
      v1 = v6;
      do
        v2 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
      while (v2 == v6 && __stlxr(v6 | 2, (unsigned __int8 *)&_dispatch_unsafe_fork));
      v6 = v2;
    }
    while (v2 != v1);
    if ((v2 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: The executable is already multithreaded";
      __break(1u);
      JUMPOUT(0x43804);
    }
  }
  else
  {
    v5 = _dispatch_unsafe_fork;
    do
    {
      v3 = v5;
      do
        v4 = __ldaxr((unsigned __int8 *)&_dispatch_unsafe_fork);
      while (v4 == v5 && __stlxr(v5 & 0xFD, (unsigned __int8 *)&_dispatch_unsafe_fork));
      v5 = v4;
    }
    while (v4 != v3);
  }
  return result;
}

pthread_key_t _dispatch_thread_getspecific_pair(pthread_key_t result, void **a2, pthread_key_t a3, pthread_key_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  char v9;
  __int128 v10;

  if (v8)
    v9 = 1;
  else
    v9 = 0;
  if ((v9 & 1) != 0)
  {
    *a2 = _dispatch_thread_getspecific(result);
    result = (pthread_key_t)_dispatch_thread_getspecific(a3);
    *a4 = result;
  }
  else
  {
    if (a3 != result + 1)
      _dispatch_abort(295, a3 == result + 1, a3, (uint64_t)a4, a5, a6, a7, a8);
    v10 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
    *a2 = (void *)v10;
    *a4 = *((_QWORD *)&v10 + 1);
  }
  return result;
}

void _dispatch_block_async_invoke2(_QWORD *a1, char a2)
{
  uint64_t v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int *v6;
  unint64_t *v7;
  unsigned int *v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  _QWORD *v15;

  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a1) == ___dispatch_block_create_block_invoke)
  {
    if (a1[4] != 3512316172)
    {
      v2 = a1[4];
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption of dispatch block object";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x43AB0);
    }
    v15 = a1 + 4;
  }
  else
  {
    v15 = 0;
  }
  v11 = *((_DWORD *)v15 + 4);
  if (((v11 >> 2) & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: A block object may not be both run more than once and waited for";
    qword_E4DA8 = v11;
    __break(1u);
    JUMPOUT(0x43B28);
  }
  if ((v11 & 1) == 0)
    (*(void (**)(void))(v15[5] + 16))();
  if ((v11 & 8) == 0)
  {
    v9 = (unsigned int *)v15 + 5;
    v10 = *((_DWORD *)v15 + 5);
    do
    {
      v3 = v10;
      do
        v4 = __ldaxr(v9);
      while (v4 == v10 && __stlxr(v10 + 1, v9));
      v10 = v4;
    }
    while (v4 != v3);
    if (!v4)
      dispatch_group_leave((dispatch_group_t)v15[6]);
  }
  v7 = v15 + 7;
  v8 = (unsigned int *)v15[7];
  do
  {
    v5 = v8;
    do
      v6 = (unsigned int *)__ldaxr(v7);
    while (v6 == v8 && __stlxr(0, v7));
    v8 = v6;
  }
  while (v6 != v5);
  if (v6)
    _dispatch_release_2(v6);
  if ((a2 & 1) != 0)
    _Block_release(a1);
}

void _dispatch_lane_non_barrier_complete(uint64_t a1, unsigned int a2)
{
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;
  unint64_t *v10;
  _BOOL4 v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;

  v12 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v2 = __ldaxr(v10);
    else
      v2 = __ldxr(v10);
    v14 = v2;
    v13 = v2 - 0x20000000000;
    if ((v2 & 0xFFFFFFFC) != 0)
    {
      v13 |= 0x8000000000uLL;
    }
    else if (v13 < 0x20000000000000)
    {
      v18 = v2 - 0x20000000000;
      if ((v13 & 0x10000000000) != 0)
        v17 = v2 + 0x3FFF0000000000;
      else
        v17 = v13 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41) + 0x40000000000000;
      if ((v17 & 0x3FFE0000000000) == 0x20000000000000)
      {
        v18 = v17 & 0xFFFFFF7FFFFFFFFFLL | v12;
      }
      else if ((v2 & 0x8000000000) != 0)
      {
        v18 = v13 | 1;
      }
      v13 = v18;
    }
    if (_os_atomic_mo_has_release(0))
      v11 = __stlxr(v13, v10) == 0;
    else
      v11 = __stxr(v13, v10) == 0;
  }
  while (!v11);
  v9 = 0;
  if ((v14 & 0x1000000000) != 0)
    v9 = (v14 & 0x800000000) != 0;
  if (v9)
  {
    v19 = v14 & 0x700000000;
    LODWORD(v19) = _dispatch_thread_getspecific(0x19uLL);
    if ((v14 & 0x700000000) >> 32 > (v19 & 0xF0000) >> 16)
      _dispatch_thread_setspecific(25, v19 & 0xFFF0FFFF | (HIDWORD(v19) << 16));
  }
  if (((v14 ^ v13) & 0x40000000000000) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0, a2, v4, v5, v6, v7, v8);
  }
  else if (((v14 ^ v13) & 1) != 0)
  {
    if ((a2 & 1) == 0)
      _dispatch_retain_2(a1);
    if ((v13 & 0x2000000000) != 0)
      _dispatch_abort(1002, 0, v3, v4, v5, v6, v7, v8);
    (*(void (**)(_QWORD, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24) + 72))(*(_QWORD *)(a1 + 24), a1, (v13 & 0x700000000) >> 32, v4, v5, v6);
  }
  else if ((a2 & 1) != 0)
  {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }
}

uint64_t _dispatch_thread_setspecific_pair(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  char v9;
  __int128 v10;

  if (v8)
    v9 = 1;
  else
    v9 = 0;
  if ((v9 & 1) != 0)
  {
    _dispatch_thread_setspecific(result, a2);
    return _dispatch_thread_setspecific(a3, a4);
  }
  else
  {
    if (a3 != result + 1)
      _dispatch_abort(339, a3 == result + 1, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)&v10 = a2;
    *((_QWORD *)&v10 + 1) = a4;
    *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = v10;
  }
  return result;
}

uint64_t _dispatch_thread_getspecific_packed_pair(uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1)
    _dispatch_abort(318, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  *a3 = *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result);
  return result;
}

uint64_t _dispatch_thread_setspecific_packed_pair(uint64_t result, uint64_t a2, _OWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 != result + 1)
    _dispatch_abort(360, a2 == result + 1, (uint64_t)a3, a4, a5, a6, a7, a8);
  *(_OWORD *)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8 * result) = *a3;
  return result;
}

void _dispatch_sync_f_slow(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  _QWORD __b[16];
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t (*v16)(uint64_t);
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  int v21;
  int v22;
  _QWORD *v23;
  uint64_t v24;
  int v25;
  int v26;
  _QWORD *v27;
  uint64_t v28;
  _QWORD *v29;
  uint64_t v30;
  uint64_t v31;
  _QWORD *v32;
  uint64_t v33;

  v19 = a1;
  v18 = a5;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a6;
  v13 = a1;
  v12 = a5;
  if (*(_QWORD *)(a5 + 24))
  {
    v20 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    __b[14] = v20;
    memset(__b, 0, 0x70uLL);
    __b[0] = v14 | 1;
    __b[1] = v20 | 0x10000000;
    __b[2] = 0;
    __b[3] = _dispatch_thread_getspecific(0x1CuLL);
    __b[4] = _dispatch_async_and_wait_invoke;
    __b[5] = __b;
    __b[6] = 0;
    __b[7] = v13;
    __b[8] = v16;
    __b[9] = v17;
    memset(&__b[10], 0, 20);
    HIDWORD(__b[12]) = _dispatch_thread_getspecific(3uLL);
    LOWORD(__b[13]) = 0;
    BYTE2(__b[13]) &= 0xFCu;
    BYTE2(__b[13]) &= ~4u;
    BYTE2(__b[13]) &= ~8u;
    BYTE2(__b[13]) &= ~0x10u;
    BYTE2(__b[13]) &= ~0x20u;
    BYTE2(__b[13]) &= ~0x40u;
    BYTE2(__b[13]) &= ~0x80u;
    v24 = v13;
    v23 = __b;
    v22 = 0;
    v21 = 0;
    v30 = v13;
    v29 = __b;
    __DISPATCH_WAIT_FOR_QUEUE__((uint64_t)__b, v12);
    if (__b[8])
    {
      v31 = v13;
      v28 = v13;
      v27 = __b;
      v26 = 0;
      v25 = 0;
      v33 = v13;
      v32 = __b;
      _dispatch_sync_invoke_and_complete_recurse(v13, v17, v16, v15, (uint64_t)__b, v8, v9, v10);
    }
    else
    {
      _dispatch_sync_complete_recurse(v13, __b[7], v15);
    }
  }
  else
  {
    __b[15] = v12;
    _dispatch_sync_function_invoke(v12, v17, v16, a4, a5, a6, a7, a8);
  }
}

void _dispatch_sync_recurse(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unint64_t *v15;
  _BOOL4 v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t *v19;
  _BOOL4 v20;
  unint64_t v21;
  char v22;

  v10 = _dispatch_thread_getspecific(3uLL);
  v9 = *(_QWORD *)(a1 + 24);
  do
  {
    if (*(_WORD *)(v9 + 80) == 1)
    {
      v18 = (4096 - *(unsigned __int16 *)(v9 + 80)) << 41;
      v16 = 0;
      v15 = (unint64_t *)(v9 + 56);
      while (1)
      {
        v7 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v15) : __ldxr(v15);
        if (v7 != (v18 | v7 & 0x3000000000))
          break;
        v17 = v10 & 0xFFFFFFFC | 0x60000000000002 | v7 & 0x3000000000;
        if (_os_atomic_mo_has_release(2))
          v16 = __stlxr(v17, v15) == 0;
        else
          v16 = __stxr(v17, v15) == 0;
        if (v16)
          goto LABEL_13;
      }
      __clrex();
LABEL_13:
      if (!v16)
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v9, 2, v5, v6);
        return;
      }
    }
    else
    {
      if (*(_QWORD *)(v9 + 48))
      {
        v22 = 0;
      }
      else
      {
        v19 = (unint64_t *)(v9 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0))
            v8 = __ldaxr(v19);
          else
            v8 = __ldxr(v19);
          if (v8 >= 0x40000000000000 || (v8 & 0x8000000000) != 0 || (v8 & 0x10000000000) != 0)
          {
            __clrex();
            v22 = 0;
            goto LABEL_31;
          }
          v21 = v8 + 0x20000000000;
          if (_os_atomic_mo_has_release(0))
            v20 = __stlxr(v21, v19) == 0;
          else
            v20 = __stxr(v21, v19) == 0;
        }
        while (!v20);
        v22 = 1;
      }
LABEL_31:
      if (((v22 ^ 1) & 1) != 0)
      {
        _dispatch_sync_f_slow(a1, a2, a3, a4, v9, 0, v5, v6);
        return;
      }
    }
    v9 = *(_QWORD *)(v9 + 24);
  }
  while (*(_QWORD *)(v9 + 24));
  _dispatch_sync_invoke_and_complete_recurse(a1, a2, a3, a4, 0, v4, v5, v6);
}

void _dispatch_lane_barrier_sync_invoke_and_complete(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t v27;
  BOOL v28;
  uint64_t (*v29)(uint64_t);
  unint64_t *v30;
  _BOOL4 v31;
  unint64_t v32;
  unint64_t v33;
  __int128 v36;
  uint64_t (*v37)(uint64_t);
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  uint64_t (*v44)(uint64_t);
  uint64_t (*v45)(uint64_t);
  uint64_t v46;
  uint64_t (*v47)(uint64_t);
  uint64_t v48;
  uint64_t (*v49)(uint64_t);
  uint64_t v50;
  __int128 *v51;
  uint64_t v52;
  __int128 *v53;
  __int128 *v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int v60;
  uint64_t v61;

  v39 = a1;
  v38 = a2;
  v37 = a3;
  v36 = 0uLL;
  v52 = a1;
  v51 = &v36;
  v54 = &v36;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v36, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v52, 21, (uint64_t)v51, v8, v9, v10, v11);
  v46 = v38;
  v45 = v37;
  v44 = 0;
  if ((char *)v37 == (char *)_dispatch_call_block_and_release && v46)
    v29 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v46);
  else
    v29 = v45;
  v44 = v29;
  v48 = v46;
  v47 = v29;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  _dispatch_client_callout(v46, v45);
  v50 = v46;
  v49 = v44;
  v53 = &v36;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v36, v12, v13, v14, v15, v16);
  v55 = a4;
  v60 = 772079660;
  v59 = a4;
  v58 = 0;
  v57 = 0;
  v56 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v60, v59, v58, v57, v56);
  v61 = a4;
  v28 = 1;
  if (!*(_QWORD *)(a1 + 48))
    v28 = *(unsigned __int16 *)(a1 + 80) > 1u;
  if (v28)
  {
    _dispatch_lane_barrier_complete(a1, 0, 0, v17, v18, v19, v20, v21);
  }
  else
  {
    v30 = (unint64_t *)(a1 + 56);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v27 = __ldaxr(v30);
      else
        v27 = __ldxr(v30);
      v33 = v27;
      v32 = (v27 - 0x40020000000000) & 0xFFFFFFF000000001;
      if ((v27 & 0xFF80008800000001) != 0)
      {
        __clrex();
        _dispatch_lane_barrier_complete(a1, 0, 0, v22, v23, v24, v25, v26);
        return;
      }
      if (_os_atomic_mo_has_release(3))
        v31 = __stlxr(v32, v30) == 0;
      else
        v31 = __stxr(v32, v30) == 0;
    }
    while (!v31);
    if ((v33 & 0x2000000000) != 0)
      _dispatch_event_loop_assert_not_owned(a1);
  }
}

void *_dispatch_async_and_wait_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t (*v12)(uint64_t);
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  void *result;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int v26;
  unsigned int v27;
  unsigned int *v28;
  unsigned int v29;
  uint64_t (*v30)(uint64_t);
  __int128 v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  uint64_t (*v41)(uint64_t);
  uint64_t (*v42)(uint64_t);
  uint64_t v43;
  uint64_t (*v44)(uint64_t);
  uint64_t v45;
  uint64_t (*v46)(uint64_t);
  uint64_t v47;
  __int128 *v48;
  uint64_t v49;
  uint64_t v50;
  __int128 *v51;
  uint64_t v52;
  __int128 *v53;
  unsigned int v54;
  unsigned int v55;
  int v56;
  int v57;
  int v58;
  unsigned int v59;
  uint64_t v60;

  v36 = a1;
  v35 = a1;
  v34 = 0;
  v34 = *(_QWORD *)(a1 + 56);
  v33 = 0;
  v33 = (*(_BYTE *)(a1 + 106) & 3) << 24;
  v32 = 0;
  if ((v33 & 0x1000000) != 0)
    v32 = _dispatch_autorelease_pool_push();
  v31 = 0uLL;
  v49 = v34;
  v52 = v34;
  v51 = &v31;
  v50 = v35 + 80;
  v53 = &v31;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v31, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v52, 21, v50, v8, v9, v10, v11);
  v12 = *(uint64_t (**)(uint64_t))(v35 + 64);
  v43 = *(_QWORD *)(v35 + 72);
  v42 = v12;
  v41 = 0;
  if ((char *)v12 == (char *)_dispatch_call_block_and_release && v43)
    v30 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v43);
  else
    v30 = v42;
  v41 = v30;
  v45 = v43;
  v44 = v30;
  v40 = 0;
  v39 = 0;
  v38 = 0;
  v37 = 0;
  _dispatch_client_callout(v43, v42);
  v47 = v43;
  v46 = v41;
  v48 = &v31;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v31, v13, v14, v15, v16, v17);
  if (v32)
    _dispatch_autorelease_pool_pop(v32);
  result = _dispatch_thread_getspecific(0x14uLL);
  *(_QWORD *)(v35 + 56) = result;
  *(_QWORD *)(v35 + 64) = 0;
  if (*(_QWORD *)(v35 + 48) != -4)
    return (void *)_dispatch_event_loop_cancel_waiter(v35, v19, v20, v21, v22, v23, v24, v25);
  v60 = v35 + 96;
  v59 = 0;
  v28 = (unsigned int *)(v35 + 96);
  v57 = 1;
  v56 = 1;
  v58 = 1;
  v29 = *(_DWORD *)(v35 + 96);
  do
  {
    v26 = v29;
    do
      v27 = __ldaxr(v28);
    while (v27 == v29 && __stlxr(v29 + 1, v28));
    v29 = v27;
  }
  while (v27 != v26);
  v55 = v27;
  v59 = v27;
  v54 = v27;
  if (v27)
    return (void *)_dispatch_thread_event_signal_slow(v60);
  return result;
}

uint64_t __DISPATCH_WAIT_FOR_QUEUE__(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t result;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unsigned int *v26;
  unsigned int v27;
  char v28;
  int v29;
  unsigned int v30;
  unint64_t v33;
  unsigned int v34;
  unsigned int v35;
  unsigned int v36;
  unsigned int v37;
  unint64_t *v38;
  _BOOL4 v39;
  unint64_t v40;
  uint64_t v41;

  v38 = (unint64_t *)(a2 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v7 = __ldaxr(v38);
    else
      v7 = __ldxr(v38);
    if ((v7 & 0xFF80000000000000) != 0 || (v7 & 0x2000000000) == 0 || (v7 & 2) == 0)
    {
      __clrex();
      v41 = v7;
      goto LABEL_14;
    }
    v40 = v7 | 0x800000000;
    if (_os_atomic_mo_has_release(0))
      v39 = __stlxr(v40, v38) == 0;
    else
      v39 = __stxr(v40, v38) == 0;
  }
  while (!v39);
  v41 = v40;
LABEL_14:
  if (((v41 ^ *(_DWORD *)(a1 + 100)) & 0xFFFFFFFC) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_sync called on queue already owned by current thread";
    qword_E4DA8 = v41;
    __break(1u);
    JUMPOUT(0x460DCLL);
  }
  _dispatch_thread_getspecific_packed_pair(20, 21, (_OWORD *)(a1 + 80), v2, v3, v4, v5, v6);
  if ((v41 & 0xFF80000000000000) != 0 || (v41 & 0x1000000000) != 0)
  {
    *(_QWORD *)(a1 + 48) = -4;
  }
  else if ((v41 & 0x2000000000) != 0)
  {
    *(_QWORD *)(a1 + 48) = a2;
  }
  else
  {
    _dispatch_wait_compute_wlh(a2, a1);
  }
  if (*(_QWORD *)(a1 + 48) == -4)
  {
    v37 = _dispatch_thread_getspecific(0x19uLL);
    v36 = (unsigned __int16)(v37 & 0xF00) >> 8;
    v35 = (unsigned __int16)(v37 & 0xF000) >> 12;
    if (v36 <= v35)
      v30 = (unsigned __int16)(v37 & 0xF000) >> 12;
    else
      v30 = (unsigned __int16)(v37 & 0xF00) >> 8;
    if (v30 <= (v37 & 0xF0000) >> 16)
    {
      v28 = (v37 & 0xF0000) >> 16;
    }
    else
    {
      if (v36 <= v35)
        v29 = (unsigned __int16)(v37 & 0xF000) >> 12;
      else
        v29 = (unsigned __int16)(v37 & 0xF00) >> 8;
      v28 = v29;
    }
    *(_BYTE *)(a1 + 105) = v28;
    *(_BYTE *)(a1 + 104) = v28;
    *(_DWORD *)(a1 + 96) = 0;
  }
  _dispatch_thread_setspecific(121, a1);
  v33 = (*(_QWORD *)(a1 + 8) & 0x3FFF00uLL) >> 8;
  v8 = __clz(__rbit32(v33));
  if ((_DWORD)v33)
    v9 = v8 + 1;
  else
    v9 = 0;
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)a2 + 72))(a2, a1, v9);
  if (*(_QWORD *)(a1 + 48) == -4)
  {
    v26 = (unsigned int *)(a1 + 96);
    v27 = *(_DWORD *)(a1 + 96);
    do
    {
      v17 = v27;
      do
        v18 = __ldaxr(v26);
      while (v18 == v27 && __stlxr(v27 - 1, v26));
      v27 = v18;
    }
    while (v18 != v17);
    if (v18 != 1)
      _dispatch_thread_event_wait_slow(a1 + 96);
  }
  else if ((*(_BYTE *)(a1 + 106) & 8) == 0)
  {
    _dispatch_event_loop_wait_for_ownership(a1, v10, v11, v12, v13, v14, v15, v16);
  }
  result = _dispatch_thread_setspecific(121, 0);
  if (*(_QWORD *)(a1 + 48) == -4)
  {
    if (*(_DWORD *)(a1 + 96))
      _dispatch_abort(339, *(_DWORD *)(a1 + 96) == 0, v20, v21, v22, v23, v24, v25);
    if (*(unsigned __int8 *)(a1 + 105) > (int)*(unsigned __int8 *)(a1 + 104))
    {
      v34 = *(unsigned __int8 *)(a1 + 105);
      result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      if ((result & 0xF0000) >> 16 < v34)
        return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | (v34 << 16));
    }
  }
  return result;
}

void _dispatch_sync_complete_recurse(uint64_t a1, uint64_t a2, char a3)
{
  BOOL v3;

  v3 = (a3 & 2) != 0;
  do
  {
    if (a1 == a2)
      break;
    if (v3)
      (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 4);
    else
      _dispatch_lane_non_barrier_complete(a1, 0);
    a1 = *(_QWORD *)(a1 + 24);
    v3 = *(unsigned __int16 *)(a1 + 80) == 1;
  }
  while (*(_QWORD *)(a1 + 24));
}

void _dispatch_sync_invoke_and_complete_recurse(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t);
  char v19;
  __int128 v21;
  uint64_t (*v22)(uint64_t);
  uint64_t v23;
  uint64_t v24;
  int v25;
  int v26;
  int v27;
  int v28;
  uint64_t (*v29)(uint64_t);
  uint64_t (*v30)(uint64_t);
  uint64_t v31;
  uint64_t (*v32)(uint64_t);
  uint64_t v33;
  uint64_t (*v34)(uint64_t);
  uint64_t v35;
  __int128 *v36;
  uint64_t v37;
  __int128 *v38;
  __int128 *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unsigned int v45;
  uint64_t v46;

  v19 = a4;
  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = 0uLL;
  v37 = a1;
  v36 = &v21;
  v39 = &v21;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v21, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v37, 21, (uint64_t)v36, v8, v9, v10, v11);
  v31 = v23;
  v30 = v22;
  v29 = 0;
  if ((char *)v22 == (char *)_dispatch_call_block_and_release && v31)
    v17 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v31);
  else
    v17 = v30;
  v29 = v17;
  v33 = v31;
  v32 = v17;
  v28 = 0;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  _dispatch_client_callout(v31, v30);
  v35 = v31;
  v34 = v29;
  v38 = &v21;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v21, v12, v13, v14, v15, v16);
  v40 = a5;
  v45 = 772079660;
  v44 = a5;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v45, v44, v43, v42, v41);
  v46 = a5;
  _dispatch_sync_complete_recurse(a1, 0, v19);
}

uint64_t _dispatch_wait_compute_wlh(uint64_t a1, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  uint64_t result;
  unint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  _DWORD *v19;
  int v22;
  unint64_t *v23;
  _BOOL4 v24;
  unint64_t v25;
  int v26;
  unsigned int v27;
  unsigned int *v28;
  BOOL v29;

  v22 = *(_DWORD *)(a1 + 80);
  if ((v22 & 0x400000) != 0)
  {
    *(_BYTE *)(a2 + 106) |= 0x40u;
    v28 = (unsigned int *)(a1 + 100);
    v27 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v2 = (unsigned int *)(a1 + 100);
    do
      v3 = __ldaxr(v2);
    while (!v3 && __stlxr(v27, v2));
    if (v3)
      _dispatch_unfair_lock_lock_slow(v28, 0x10000);
  }
  v19 = *(_DWORD **)(a1 + 24);
  v23 = (unint64_t *)(v19 + 14);
  do
  {
    result = _os_atomic_mo_has_acquire(0);
    if ((_DWORD)result)
      v5 = __ldaxr(v23);
    else
      v5 = __ldxr(v23);
    if ((v5 & 0xFF80000000000000) != 0 || (v5 & 0x2000000000) == 0 || (v5 & 2) == 0)
    {
      __clrex();
      v26 = HIDWORD(v5);
      goto LABEL_20;
    }
    v25 = v5 | 0x800000000;
    result = _os_atomic_mo_has_release(0);
    if ((_DWORD)result)
      v24 = __stlxr(v25, v23) == 0;
    else
      v24 = __stxr(v25, v23) == 0;
  }
  while (!v24);
  v26 = HIDWORD(v25);
LABEL_20:
  if ((v26 & 0xFF800000) != 0 || (v26 & 0x10) != 0)
  {
    *(_BYTE *)(a2 + 106) &= ~0x40u;
    *(_QWORD *)(a2 + 48) = -4;
  }
  else if ((v26 & 0x20) != 0)
  {
    if (*(_BYTE *)(*(_QWORD *)v19 + 16) == 18)
    {
      *(_BYTE *)(a2 + 106) |= 0x10u;
      *(_BYTE *)(a2 + 106) &= ~0x40u;
    }
    else if ((*(_BYTE *)(a2 + 106) & 0x40) != 0)
    {
      v17 = v19 + 24;
      v18 = v19[24];
      do
      {
        v6 = v18;
        do
          v7 = __ldaxr(v17);
        while (v7 == v18 && __stlxr(v18 + 1, v17));
        v18 = v7;
      }
      while (v7 != v6);
      if ((int)(v7 + 1) <= 0)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
        __break(1u);
        JUMPOUT(0x46E60);
      }
    }
    *(_QWORD *)(a2 + 48) = v19;
  }
  else
  {
    result = _dispatch_wait_compute_wlh(v19, a2);
  }
  if ((v22 & 0x400000) != 0)
  {
    if ((*(_BYTE *)(a2 + 106) & 0x10) != 0)
    {
      v15 = (unsigned int *)(a1 + 80);
      v16 = *(_DWORD *)(a1 + 80);
      do
      {
        v8 = v16;
        do
          v9 = __ldaxr(v15);
        while (v9 == v16 && __stlxr(v16 & 0xFFBFFFFF, v15));
        v16 = v9;
      }
      while (v9 != v8);
    }
    result = (uint64_t)_dispatch_thread_getspecific(3uLL);
    v13 = (unsigned int *)(a1 + 100);
    v14 = *(_DWORD *)(a1 + 100);
    do
    {
      v10 = v14;
      do
        v11 = __ldaxr(v13);
      while (v11 == v14 && __stlxr(0, v13));
      v12 = v11;
      v14 = v11;
    }
    while (v11 != v10);
    if (v11 == (result & 0xFFFFFFFC))
    {
      v29 = 0;
    }
    else
    {
      result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a1 + 100, v11);
      v29 = (v12 & 2) != 0;
    }
    if (v29)
    {
      result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
      if (!((result & 0xF0000) >> 16))
        return _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
    }
  }
  return result;
}

void _dispatch_sync_invoke_and_complete(uint64_t a1, uint64_t a2, uint64_t (*a3)(uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t (*v17)(uint64_t);
  __int128 v20;
  uint64_t (*v21)(uint64_t);
  uint64_t v22;
  uint64_t v23;
  int v24;
  int v25;
  int v26;
  int v27;
  uint64_t (*v28)(uint64_t);
  uint64_t (*v29)(uint64_t);
  uint64_t v30;
  uint64_t (*v31)(uint64_t);
  uint64_t v32;
  uint64_t (*v33)(uint64_t);
  uint64_t v34;
  __int128 *v35;
  uint64_t v36;
  __int128 *v37;
  __int128 *v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  uint64_t v45;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = 0uLL;
  v36 = a1;
  v35 = &v20;
  v38 = &v20;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v20, a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v36, 21, (uint64_t)v35, v8, v9, v10, v11);
  v30 = v22;
  v29 = v21;
  v28 = 0;
  if ((char *)v21 == (char *)_dispatch_call_block_and_release && v30)
    v17 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v30);
  else
    v17 = v29;
  v28 = v17;
  v32 = v30;
  v31 = v17;
  v27 = 0;
  v26 = 0;
  v25 = 0;
  v24 = 0;
  _dispatch_client_callout(v30, v29);
  v34 = v30;
  v33 = v28;
  v37 = &v20;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v20, v12, v13, v14, v15, v16);
  v39 = a4;
  v44 = 772079660;
  v43 = a4;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v44, v43, v42, v41, v40);
  v45 = a4;
  _dispatch_lane_non_barrier_complete(a1, 0);
}

void _dispatch_async_and_wait_recurse(uint64_t a1, uint64_t a2, int a3, uint64_t a4)
{
  unint64_t v4;
  unint64_t v5;
  BOOL v6;
  char v7;
  char v8;
  uint64_t i;
  uint64_t v10;
  BOOL v15;
  unint64_t *v16;
  _BOOL4 v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t *v20;
  _BOOL4 v21;
  unint64_t v22;
  char v23;
  unint64_t v24;
  unsigned int v25;

  v10 = a1;
  for (i = a4; ; *(_QWORD *)a2 = i)
  {
    v8 = 1;
    if ((*(_DWORD *)(v10 + 80) & 0x1000000) == 0)
    {
      v7 = 0;
      if ((*(_QWORD *)(v10 + 56) & 0x3000000000) != 0)
      {
        v6 = 0;
        if (*(_QWORD *)(v10 + 24) >= (unint64_t)&_dispatch_root_queues)
          v6 = *(_QWORD *)(v10 + 24) < (unint64_t)&_dispatch_queue_serial_numbers;
        v7 = !v6;
      }
      v8 = v7;
    }
    if ((v8 & 1) != 0)
    {
      *(_QWORD *)a2 &= ~0x80uLL;
      *(_QWORD *)(a2 + 56) = v10;
      v15 = 0;
    }
    else if ((i & 2) != 0)
    {
      v19 = (4096 - *(unsigned __int16 *)(v10 + 80)) << 41;
      v17 = 0;
      v16 = (unint64_t *)(v10 + 56);
      while (1)
      {
        v4 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v16) : __ldxr(v16);
        if (v4 != (v19 | v4 & 0x3000000000))
          break;
        v18 = a3 & 0xFFFFFFFC | 0x60000000000002 | v4 & 0x3000000000;
        if (_os_atomic_mo_has_release(2))
          v17 = __stlxr(v18, v16) == 0;
        else
          v17 = __stxr(v18, v16) == 0;
        if (v17)
          goto LABEL_21;
      }
      __clrex();
LABEL_21:
      v15 = v17;
    }
    else
    {
      if (*(_QWORD *)(v10 + 48))
      {
        v23 = 0;
      }
      else
      {
        v20 = (unint64_t *)(v10 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0))
            v5 = __ldaxr(v20);
          else
            v5 = __ldxr(v20);
          if (v5 >= 0x40000000000000 || (v5 & 0x8000000000) != 0 || (v5 & 0x10000000000) != 0)
          {
            __clrex();
            v23 = 0;
            goto LABEL_37;
          }
          v22 = v5 + 0x20000000000;
          if (_os_atomic_mo_has_release(0))
            v21 = __stlxr(v22, v20) == 0;
          else
            v21 = __stxr(v22, v20) == 0;
        }
        while (!v21);
        v23 = 1;
      }
LABEL_37:
      v15 = v23;
    }
    if (!v15)
    {
      _dispatch_async_and_wait_f_slow(a1, a4, a2, v10);
      return;
    }
    if ((*(_DWORD *)(v10 + 84) & 0xFFF) != 0)
    {
      v25 = (*(_DWORD *)(v10 + 84) & 0xF00u) >> 8;
      v24 = *(unsigned __int8 *)(v10 + 84);
      if (v25)
        v24 = *(unsigned __int8 *)(v10 + 84) | (unint64_t)(1 << (v25 + 7));
      if (v24 > (*(_QWORD *)(a2 + 8) & 0xFFFFFFuLL))
        *(_QWORD *)(a2 + 8) = v24 | 0x10000000;
    }
    if ((*(_BYTE *)(a2 + 106) & 3) == 0)
      *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(v10 + 80) & 0x30000u) / 0x10000) & 3;
    if (!*(_QWORD *)(*(_QWORD *)(v10 + 24) + 24))
      break;
    v10 = *(_QWORD *)(v10 + 24);
    if (*(_WORD *)(v10 + 80) == 1)
      i |= 2uLL;
    else
      i &= ~2uLL;
  }
  _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a2, v10, a4);
}

void _dispatch_async_and_wait_f_slow(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  __DISPATCH_WAIT_FOR_QUEUE__(a3, a4);
  if (*(_QWORD *)(a3 + 64))
    _dispatch_async_and_wait_invoke_and_complete_recurse(a1, a3, *(_QWORD *)(a3 + 56), a2);
  else
    _dispatch_sync_complete_recurse(a1, *(_QWORD *)(a3 + 56), a2);
}

void _dispatch_async_and_wait_invoke_and_complete_recurse(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t (*v19)(uint64_t);
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  void *v26;
  uint64_t v27;
  uint64_t (*v28)(uint64_t);
  void *v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  __int128 v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  unint64_t v47;
  uint64_t v48;
  void *v49;
  void *v50;
  unint64_t v51;
  BOOL v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  void *object;
  void *v58;
  int v59;
  int v60;
  int v61;
  int v62;
  uint64_t (*v63)(uint64_t);
  uint64_t (*v64)(uint64_t);
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  BOOL v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  void *v73;
  void *v74;
  int v75;
  int v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  unint64_t v82;
  uint64_t v83;
  uint64_t v84;
  void *v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  unint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  _BOOL8 v96;
  uint64_t v97;
  uint64_t v98;
  unint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _BOOL8 v113;
  uint64_t (*v114)(uint64_t);
  uint64_t v115;
  uint64_t (*v116)(uint64_t);
  uint64_t v117;
  __int128 *v118;
  uint64_t v119;
  __int128 *v120;
  __int128 *v121;
  uint64_t v122;
  void *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  uint64_t v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unsigned int v138;
  uint64_t v139;

  v44 = a1;
  v43 = a2;
  v42 = a3;
  v41 = a4;
  v40 = 0;
  v39 = 0;
  v128 = a3;
  v127 = -4;
  if (*(_BYTE *)(*(_QWORD *)a3 + 16) == 18
    || (v126 = 0, v125 = *(_QWORD *)(v128 + 56), v126 = v125, v124 = v125, v129 = v125, (v125 & 0x2000000000) != 0))
  {
    v127 = v128;
  }
  v123 = _dispatch_thread_getspecific(0x1BuLL);
  _dispatch_thread_setspecific(27, v127);
  v39 = (uint64_t)v123;
  v40 = (*(_BYTE *)(v43 + 106) & 3) << 24;
  v38 = 0;
  if ((v40 & 0x1000000) != 0)
    v38 = _dispatch_autorelease_pool_push();
  v37 = 0x40000000;
  v36 = 0uLL;
  v34 = *(_QWORD *)(v43 + 8);
  v32 = *(_QWORD *)(v43 + 24);
  v122 = v44;
  v119 = v44;
  v118 = &v36;
  v121 = &v36;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v36, v4, v5, v6, v7, v8);
  _dispatch_thread_setspecific_pair(20, v119, 21, (uint64_t)v118, v9, v10, v11, v12);
  v48 = v37;
  v47 = v34;
  v46 = 0;
  v45 = 0;
  if ((v37 & 0x40000000) != 0 && ((v48 & 0x20) != 0 || (v48 & 0x10) == 0))
  {
    v51 = v47;
    v47 &= 0xFFFFFFu;
    v49 = 0;
    v49 = _dispatch_thread_getspecific(4uLL);
    v50 = v49;
    v46 = v49 & 0xFFFFFF;
    if ((v49 & 0xFFFFFF) != 0 && v46 < v47)
      v45 = v46;
  }
  v35 = v45;
  if (v45)
    v31 = v34;
  else
    v31 = 0;
  v55 = v31;
  v54 = v32;
  v53 = 0;
  v100 = v31;
  v113 = v31 != -1;
  v112 = 2332;
  if (v31 == -1)
    _dispatch_abort(v112, v113, v13, v14, v15, v16, v17, v18);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v111 = v100;
    v110 = 4261412863;
    v109 = 0;
    v100 &= 0xFFFFFFFF02FFFFFFLL;
    v99 = 0;
    v102 = 0;
    v102 = _dispatch_thread_getspecific(4uLL);
    v99 = (unint64_t)v102;
    v98 = 0x1000000;
    v97 = 2281701376;
    if ((v102 & 0x1000000) != 0)
    {
      if (v100)
      {
        v30 = v100;
      }
      else
      {
        v108 = v99;
        v107 = v98;
        v106 = 0;
        v30 = v99 & (~v98 | 0xFFFFFF);
      }
      v101 = v30;
    }
    else
    {
      v105 = v99;
      v104 = v97;
      v103 = 0;
      v99 &= ~v97 | 0xFFFFFF;
      if (v100 == v99)
        v101 = 0;
      else
        v101 = v100;
    }
  }
  else
  {
    v101 = 0;
  }
  v55 = v101;
  if (!v101)
  {
    if (v54 == -1)
    {
      v56 = -1;
      goto LABEL_41;
    }
    v29 = (void *)v54;
    if (v29 == _dispatch_thread_getspecific(0x1CuLL))
    {
      v52 = (v53 & 4) != 0;
      if ((v53 & 2) != 0)
      {
        if (v52 && v54)
        {
          object = (void *)v54;
          os_release((void *)v54);
        }
        v54 = -1;
      }
      else if (!v52 && v54)
      {
        v58 = (void *)v54;
        os_retain((void *)v54);
      }
      v56 = v54;
      goto LABEL_41;
    }
  }
  v56 = _dispatch_set_priority_and_voucher_slow(v55, (_DWORD *)v54, v53);
LABEL_41:
  v33 = v56;
  v78 = v44;
  v77 = v43;
  v76 = 0;
  v75 = 0;
  v132 = v44;
  v131 = v43;
  v19 = *(uint64_t (**)(uint64_t))(v43 + 64);
  v65 = *(_QWORD *)(v43 + 72);
  v64 = v19;
  v63 = 0;
  if ((char *)v19 == (char *)_dispatch_call_block_and_release && v65)
    v28 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v65);
  else
    v28 = v64;
  v63 = v28;
  v115 = v65;
  v114 = v28;
  v62 = 0;
  v61 = 0;
  v60 = 0;
  v59 = 0;
  _dispatch_client_callout(v65, v64);
  v117 = v65;
  v116 = v63;
  v67 = v35;
  v66 = v33;
  if (v35 == -1)
    v67 = 0;
  v71 = v67;
  v70 = v66;
  v69 = 6;
  v83 = v67;
  v96 = v67 != -1;
  v95 = 2332;
  if (v67 == -1)
    _dispatch_abort(v95, v96, v20, v21, v22, v23, v24, v25);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v94 = v83;
    v93 = 4261412863;
    v92 = 0;
    v83 &= 0xFFFFFFFF02FFFFFFLL;
    v82 = 0;
    v85 = 0;
    v85 = _dispatch_thread_getspecific(4uLL);
    v82 = (unint64_t)v85;
    v81 = 0x1000000;
    v80 = 2281701376;
    if ((v85 & 0x1000000) != 0)
    {
      if (v83)
      {
        v27 = v83;
      }
      else
      {
        v91 = v82;
        v90 = v81;
        v89 = 0;
        v27 = v82 & (~v81 | 0xFFFFFF);
      }
      v84 = v27;
    }
    else
    {
      v88 = v82;
      v87 = v80;
      v86 = 0;
      v82 &= ~v80 | 0xFFFFFF;
      if (v83 == v82)
        v84 = 0;
      else
        v84 = v83;
    }
  }
  else
  {
    v84 = 0;
  }
  v71 = v84;
  if (v84)
    goto LABEL_72;
  if (v70 == -1)
  {
    v72 = -1;
    goto LABEL_73;
  }
  v26 = (void *)v70;
  if (v26 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_72:
    v72 = _dispatch_set_priority_and_voucher_slow(v71, (_DWORD *)v70, v69);
  }
  else
  {
    v68 = (v69 & 4) != 0;
    if ((v69 & 2) != 0)
    {
      if (v68 && v70)
      {
        v73 = (void *)v70;
        os_release((void *)v70);
      }
      v70 = -1;
    }
    else if (!v68 && v70)
    {
      v74 = (void *)v70;
      os_retain((void *)v70);
    }
    v72 = v70;
  }
LABEL_73:
  v120 = &v36;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v36, v21, v22, v23, v24, v25);
  if (v38)
    _dispatch_autorelease_pool_pop(v38);
  v79 = v43;
  v133 = v43;
  v138 = 772079660;
  v137 = v43;
  v136 = 0;
  v135 = 0;
  v134 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v138, v137, v136, v135, v134);
  v139 = v79;
  v130 = v39;
  _dispatch_thread_setspecific(27, v39);
  _dispatch_sync_complete_recurse(v44, 0, v41);
}

void _dispatch_queue_specific_head_dispose(_QWORD *a1)
{
  char v1;
  _QWORD *v2;
  void **v3;
  _QWORD *v4;
  _QWORD *i;
  uint64_t (***v6)();
  _QWORD *v7;

  v7 = a1;
  v6 = &off_E4640;
  i = 0;
  v4 = 0;
  v2 = 0;
  v3 = (void **)&v2;
  if (a1[1])
  {
    *v3 = (void *)v7[1];
    *(_QWORD *)(v7[1] + 32) = v3;
    v3 = (void **)v7[2];
    v7[1] = 0;
    v7[2] = v7 + 1;
  }
  for (i = v2; ; i = v4)
  {
    v1 = 0;
    if (i)
    {
      v4 = (_QWORD *)i[3];
      v1 = 1;
    }
    if ((v1 & 1) == 0)
      break;
    if (i[2])
    {
      i[3] = 0;
      i[4] = v7[2];
      *(_QWORD *)v7[2] = i;
      v7[2] = i + 3;
    }
    else
    {
      free(i);
    }
  }
  if (v7[1])
    _dispatch_barrier_async_detached_f((uint64_t)v6, (uint64_t)v7, (uint64_t)_dispatch_queue_specific_head_dispose_slow);
  else
    free(v7);
}

void _dispatch_queue_specific_head_dispose_slow(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  _QWORD *v9;
  _QWORD *i;
  void (*v12)(void (**)(void));
  uint64_t v13;

  v9 = 0;
  for (i = (_QWORD *)a1[1]; ; i = v9)
  {
    v8 = 0;
    if (i)
    {
      v9 = (_QWORD *)i[3];
      v8 = 1;
    }
    if ((v8 & 1) == 0)
      break;
    if (!i[2])
      _dispatch_abort(2313, 0, a3, a4, a5, a6, a7, a8);
    v13 = i[1];
    v12 = (void (*)(void (**)(void)))i[2];
    if (v12 == _dispatch_call_block_and_release)
    {
      if (v13)
        _Block_get_invoke_fn(v13);
    }
    _dispatch_client_callout(v13, (uint64_t (*)(uint64_t))v12);
    free(i);
  }
  free(a1);
}

uint64_t _dispatch_non_barrier_waiter_redirect_or_wake(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v14;
  _BOOL4 v15;
  unint64_t v16;
  char v17;
  unint64_t v18;
  unsigned int v19;

  if ((*(_QWORD *)a2 & 2) != 0)
    _dispatch_abort(1211, (*(_QWORD *)a2 & 2) == 0, a3, a4, a5, a6, a7, a8);
  while (1)
  {
    v11 = *(_QWORD *)(a1 + 56);
    if (*(unsigned __int8 *)(a2 + 105) < ((v11 & 0x700000000uLL) >> 32))
      *(_BYTE *)(a2 + 105) = (v11 & 0x700000000uLL) >> 32;
    if ((*(_QWORD *)a2 & 0x80) != 0)
    {
      if ((*(_DWORD *)(a1 + 84) & 0xFFF) != 0)
      {
        v19 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
        v18 = *(unsigned __int8 *)(a1 + 84);
        if (v19)
          v18 = *(unsigned __int8 *)(a1 + 84) | (unint64_t)(1 << (v19 + 7));
        if (v18 > (*(_QWORD *)(a2 + 8) & 0xFFFFFFuLL))
          *(_QWORD *)(a2 + 8) = v18 | 0x10000000;
      }
      if ((*(_BYTE *)(a2 + 106) & 3) == 0)
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(a1 + 80) & 0x30000u) / 0x10000) & 3;
    }
    if ((v11 & 0x3000000000) != 0)
      break;
    v10 = *(_QWORD *)(a1 + 24);
    if (*(_WORD *)(v10 + 80) == 1)
    {
      *(_QWORD *)a2 |= 2uLL;
      return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v10 + 72))(v10, a2, 0);
    }
    *(_QWORD *)a2 &= ~2uLL;
    if (*(_QWORD *)(v10 + 48))
    {
      v17 = 0;
    }
    else
    {
      v14 = (unint64_t *)(v10 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v8 = __ldaxr(v14);
        else
          v8 = __ldxr(v14);
        if (v8 >= 0x40000000000000 || (v8 & 0x8000000000) != 0 || (v8 & 0x10000000000) != 0)
        {
          __clrex();
          v17 = 0;
          goto LABEL_31;
        }
        v16 = v8 + 0x20000000000;
        if (_os_atomic_mo_has_release(0))
          v15 = __stlxr(v16, v14) == 0;
        else
          v15 = __stxr(v16, v14) == 0;
      }
      while (!v15);
      v17 = 1;
    }
LABEL_31:
    if ((v17 & 1) == 0)
      return (*(uint64_t (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v10 + 72))(v10, a2, 0);
    a1 = v10;
  }
  if ((*(_QWORD *)a2 & 0x80) != 0)
    *(_QWORD *)(a2 + 56) = a1;
  return _dispatch_waiter_wake_wlh_anon(a2);
}

uint64_t _dispatch_waiter_wake_wlh_anon(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  uint64_t v5;
  uint64_t v6;

  v5 = result;
  if (*(unsigned __int8 *)(result + 105) > (int)*(unsigned __int8 *)(result + 104)
    && (_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v6 = 0;
    if (*(_BYTE *)(result + 105))
      v6 = 1 << (*(_BYTE *)(result + 105) + 7);
    result = _pthread_workqueue_override_start_direct(*(unsigned int *)(result + 100), v6 | 0xFF);
  }
  v3 = (unsigned int *)(v5 + 96);
  v4 = *(_DWORD *)(v5 + 96);
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 + 1, v3));
    v4 = v2;
  }
  while (v2 != v1);
  if (v2)
    return _dispatch_thread_event_signal_slow(v5 + 96);
  return result;
}

void _dispatch_barrier_waiter_redirect_or_wake(uint64_t a1, uint64_t a2, uint64_t a3, unint64_t a4, unint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  BOOL v9;
  uint64_t v10;
  uint64_t v11;
  char v16;
  unsigned int v18;
  unint64_t *v19;
  _BOOL4 v20;
  unint64_t v21;
  char v22;
  unint64_t v23;
  unsigned int v24;

  v16 = a3;
  v11 = -4;
  if (*(_QWORD *)(a2 + 48) == -4 && *(unsigned __int8 *)(a2 + 105) < ((a4 & 0x700000000) >> 32))
    *(_BYTE *)(a2 + 105) = (a4 & 0x700000000) >> 32;
  if ((a4 & 0x2000000000) != 0)
  {
    v11 = a1;
  }
  else
  {
    v9 = 0;
    if ((a4 & 0x1000000000) != 0)
      v9 = (a4 & 0x800000000) != 0;
    if (v9)
    {
      v18 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(a4) & 7u) > (v18 & 0xF0000) >> 16)
        _dispatch_thread_setspecific(25, v18 & 0xFFF0FFFF | ((BYTE4(a4) & 7) << 16));
    }
  }
  if ((v16 & 1) != 0)
  {
    if ((a4 & 0x2000000000) == 0 || (a5 & 1) == 0)
    {
      _dispatch_release_2_no_dispose(a1);
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if ((a4 & 0x2000000000) != 0 && (a4 & 1) != 0 && (a5 & 1) == 0)
LABEL_18:
    _dispatch_release_no_dispose(a1);
LABEL_19:
  if ((a4 & 0x3000000000) != 0)
  {
    if ((*(_QWORD *)a2 & 0x80) != 0)
      *(_QWORD *)(a2 + 56) = a1;
    _dispatch_waiter_wake(a2, v11, a4, a5);
  }
  else
  {
    v10 = *(_QWORD *)(a1 + 24);
    if ((*(_QWORD *)a2 & 0x80) != 0)
    {
      if ((*(_DWORD *)(a1 + 84) & 0xFFF) != 0)
      {
        v24 = (*(_DWORD *)(a1 + 84) & 0xF00u) >> 8;
        v23 = *(unsigned __int8 *)(a1 + 84);
        if (v24)
          v23 = *(unsigned __int8 *)(a1 + 84) | (unint64_t)(1 << (v24 + 7));
        if (v23 > (*(_QWORD *)(a2 + 8) & 0xFFFFFFuLL))
          *(_QWORD *)(a2 + 8) = v23 | 0x10000000;
      }
      if ((*(_BYTE *)(a2 + 106) & 3) == 0)
        *(_BYTE *)(a2 + 106) = *(_BYTE *)(a2 + 106) & 0xFC | ((*(_DWORD *)(a1 + 80) & 0x30000u) / 0x10000) & 3;
    }
    if (*(_WORD *)(v10 + 80) == 1)
    {
      *(_QWORD *)a2 |= 2uLL;
    }
    else
    {
      *(_QWORD *)a2 &= ~2uLL;
      if (*(_QWORD *)(v10 + 48))
      {
        v22 = 0;
      }
      else
      {
        v19 = (unint64_t *)(v10 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(0))
            v8 = __ldaxr(v19);
          else
            v8 = __ldxr(v19);
          if (v8 >= 0x40000000000000 || (v8 & 0x8000000000) != 0 || (v8 & 0x10000000000) != 0)
          {
            __clrex();
            v22 = 0;
            goto LABEL_45;
          }
          v21 = v8 + 0x20000000000;
          if (_os_atomic_mo_has_release(0))
            v20 = __stlxr(v21, v19) == 0;
          else
            v20 = __stxr(v21, v19) == 0;
        }
        while (!v20);
        v22 = 1;
      }
LABEL_45:
      if ((v22 & 1) != 0)
      {
        _dispatch_non_barrier_waiter_redirect_or_wake(v10, a2, a3, a4, a5, a6, a7, a8);
        return;
      }
    }
    *(_BYTE *)(a2 + 106) &= ~0x80u;
    (*(void (**)(uint64_t, uint64_t, unint64_t))(*(_QWORD *)v10 + 72))(v10, a2, (a4 & 0x700000000) >> 32);
  }
}

uint64_t _dispatch_release_no_dispose(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 8);
    v4 = *(_DWORD *)(result + 8);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 1, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2 - 1;
  }
  if (v5 < 1)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4A354);
  }
  return result;
}

uint64_t _dispatch_release_2_no_dispose(uint64_t result)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;
  int v5;

  v5 = *(_DWORD *)(result + 8);
  if (v5 != 0x7FFFFFFF)
  {
    v3 = (unsigned int *)(result + 8);
    v4 = *(_DWORD *)(result + 8);
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 - 2, v3));
      v4 = v2;
    }
    while (v2 != v1);
    v5 = v2 - 2;
  }
  if (v5 < 1)
  {
    qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
    __break(1u);
    JUMPOUT(0x4A4D8);
  }
  return result;
}

void _dispatch_waiter_wake(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 48);
  if ((a3 & 0x2000000000) != 0 && *(char *)(a1 + 106) >= 0 || (a4 & 0x2000000000) != 0 || v4 != -4)
    _dispatch_event_loop_wake_owner(a1, a2, a3, a4);
  if (v4 == -4)
    _dispatch_waiter_wake_wlh_anon(a1);
}

uint64_t _dispatch_base_lane_is_wlh(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;
  char v10;
  char v11;

  if (((_dispatch_kevent_workqueue_enabled ^ 1) & 1) != 0)
  {
    v11 = 0;
  }
  else if (*(_QWORD *)(*(_QWORD *)a1 + 16) == 133137)
  {
    v11 = 1;
  }
  else
  {
    if (*(_BYTE *)(*(_QWORD *)a1 + 16) == 19)
    {
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 88) + 29) & 0x20) == 0)
      {
        v11 = 0;
        return v11 & 1;
      }
      if ((*(_BYTE *)(*(_QWORD *)(a1 + 88) + 29) & 1) == 0)
        _dispatch_abort(2510, *(_BYTE *)(*(_QWORD *)(a1 + 88) + 29) & 1, a3, a4, a5, a6, a7, a8);
    }
    v10 = 0;
    if (*(_WORD *)(a1 + 80) == 1)
    {
      v9 = 0;
      if (a2 >= (unint64_t)&_dispatch_root_queues)
        v9 = a2 < (unint64_t)&_dispatch_queue_serial_numbers;
      v10 = v9;
    }
    v11 = v10;
  }
  return v11 & 1;
}

uint64_t _dispatch_lane_concurrent_drain(uint64_t a1, uint64_t a2, int a3, _QWORD *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  _BOOL4 v18;
  unint64_t v19;
  unint64_t *v20;
  _QWORD *v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  _QWORD *v29;
  unint64_t v30;
  uint64_t v31;
  BOOL v34;
  char v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t *v38;
  unint64_t v39;
  BOOL v40;
  char v41;
  uint64_t v42;
  uint64_t v43;
  _QWORD *v44;
  _QWORD *v45;
  __int128 v46;
  uint64_t v47;
  char v48;
  _QWORD *v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  _BOOL8 v57;
  uint64_t v58;
  unint64_t v59;
  unsigned int *v60;
  unint64_t v61;
  _QWORD *v62;
  _QWORD *v64;
  int v66;
  int v67;
  int v68;
  int v69;
  _DWORD *v70;
  BOOL v71;
  _BOOL4 v72;
  unint64_t *v73;
  _BOOL4 v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  BOOL v78;
  unint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t *v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  unint64_t *v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  uint64_t v103;
  uint64_t v104;
  _QWORD *v105;
  _BOOL4 v106;
  BOOL v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _BOOL4 v111;
  unint64_t v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  _QWORD *v120;
  _QWORD *v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  _QWORD *v132;
  _BOOL4 v133;
  BOOL v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  _BOOL4 v138;
  unint64_t v139;
  uint64_t v140;
  uint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  _QWORD *v147;
  _QWORD *v148;
  uint64_t v149;
  _QWORD *v150;
  _QWORD *v151;
  _QWORD *v152;
  __int128 *v153;
  uint64_t v154;
  __int128 *v155;
  __int128 *v156;
  __int128 *v157;
  __int128 *v158;
  void *v159;
  uint64_t v160;
  _BOOL4 v161;
  unint64_t *v162;
  _BOOL4 v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  uint64_t v167;
  uint64_t v168;
  unint64_t v169;
  unint64_t v170;
  _DWORD *v171;
  char v172;
  _QWORD *v173;
  unint64_t v174;
  unint64_t v175;
  uint64_t v176;
  uint64_t v177;
  uint64_t v178;
  unint64_t v179;
  unint64_t v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  _QWORD *v185;
  unint64_t v186;
  unsigned __int16 v187;
  _QWORD *v188;
  uint64_t v189;
  uint64_t v190;
  int v191;
  int v192;
  int v193;
  int v194;
  _DWORD *v195;
  BOOL v196;
  _QWORD *v197;

  v52 = a1;
  v51 = a2;
  v50 = a3;
  v49 = a4;
  v48 = 0;
  v47 = 0;
  v47 = *(_QWORD *)(a1 + 24);
  v46 = 0uLL;
  v42 = *a4;
  if (!*(_QWORD *)(a1 + 48))
    return 0;
  v154 = v52;
  v153 = &v46;
  v158 = &v46;
  _dispatch_thread_getspecific_packed_pair(20, 21, &v46, (uint64_t)a4, a5, a6, a7, a8);
  _dispatch_thread_setspecific_pair(20, v154, 21, (uint64_t)v153, v8, v9, v10, v11);
  if ((v48 & 1) != 0 || (v54 = v42, (v42 & 0x40000000000000) != 0))
    v43 = 0x40000000000000;
  else
    v43 = v42 & 0x3FFE0000000000;
  v95 = v52;
  v94 = (unint64_t *)(v52 + 104);
  v93 = 0;
  v92 = 0;
  v91 = *(_QWORD *)(v52 + 104);
  v92 = v91;
  v90 = v91;
  v93 = v91;
  if (!v91)
    v93 = _dispatch_wait_for_enqueuer(v94, v95 + 48);
  v89 = v93;
  v45 = (_QWORD *)v93;
  while (1)
  {
    v55 = *(_QWORD *)(v52 + 56);
    if ((v55 & 0xFF80000000000000) != 0 || v47 != *(_QWORD *)(v52 + 24))
      break;
    if ((v48 & 1) != 0)
      goto LABEL_35;
    v70 = v45;
    v69 = 0;
    v150 = v45;
    if (*v45 > 0xFFFuLL)
    {
      if ((*(_QWORD *)(*(_QWORD *)v70 + 16) & 0xF0) == 0x10)
      {
        v68 = 0;
        v67 = v70[20];
        v68 = v67;
        v66 = v67;
        v69 = v67;
        v71 = (v67 & 0x80000) != 0;
      }
      else
      {
        v71 = 0;
      }
    }
    else
    {
      v71 = (*v70 & 2) != 0;
    }
    if (v71)
    {
LABEL_35:
      if ((v48 & 1) == 0 && v43 != 0x40000000000000)
      {
        v168 = v52;
        v167 = v43;
        v166 = 0;
        v165 = 0;
        v164 = 0;
        v164 = ((unint64_t)(*(unsigned __int16 *)(v52 + 80) - 1) << 41) | 0x10000000000;
        v163 = 0;
        v162 = (unint64_t *)(v52 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2))
            v19 = __ldaxr(v162);
          else
            v19 = __ldxr(v162);
          v166 = v19;
          v165 = v19 - v167;
          v170 = v19;
          if ((v19 & 0x10000000000) == 0)
            v165 += v164;
          v169 = v165;
          if (!(v165 >> 53))
          {
            v165 += 0x20000000000;
            v165 += 0x40000000000000;
            v165 -= 0x10000000000;
          }
          v165 &= ~0x8000000000uLL;
          if (_os_atomic_mo_has_release(2))
            v163 = __stlxr(v165, v162) == 0;
          else
            v163 = __stxr(v165, v162) == 0;
        }
        while (!v163);
        v161 = v163;
        if ((v165 & 0x40000000000000) == 0)
          goto LABEL_138;
        v43 = 0x40000000000000;
      }
      v171 = v45;
      v173 = v45;
      if (*v45 >= 0x1000uLL)
        v172 = 0;
      else
        v172 = *v171 & 1;
      if (v172 == 1 && (v50 & 0x80000) == 0)
      {
        *(_QWORD *)(v51 + 8) = v45;
        if ((v50 & 8) != 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Deferred continuation on source, mach channel or mgr";
          __break(1u);
          JUMPOUT(0x4BA44);
        }
        v155 = &v46;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
        return *(_QWORD *)(v52 + 24);
      }
      v122 = v52;
      v121 = v45;
      v120 = v45;
      v119 = 0;
      v118 = 0;
      v117 = v45[2];
      v118 = v117;
      v116 = v117;
      v119 = v117;
      v115 = v117;
      v114 = v117;
      *(_QWORD *)(v52 + 104) = v117;
      v113 = v115;
      v40 = 0;
      if (!v119)
      {
        v112 = (unint64_t)v120;
        v111 = 0;
        v20 = (unint64_t *)(v122 + 48);
        v109 = 0;
        v108 = 0;
        v110 = 0;
        v21 = v120;
        do
          v22 = __ldaxr(v20);
        while ((_QWORD *)v22 == v21 && __stlxr(0, v20));
        if ((_QWORD *)v22 != v21)
          v112 = v22;
        v107 = v22 == (_QWORD)v21;
        v111 = v22 == (_QWORD)v21;
        v106 = v111;
        v40 = v22 != (_QWORD)v21;
      }
      if (v40)
      {
        v105 = v120;
        v104 = 0;
        v103 = 0;
        v102 = v120[2];
        v103 = v102;
        v101 = v102;
        v104 = v102;
        if (!v102)
          v104 = _dispatch_wait_for_enqueuer(v105 + 2, v122 + 48);
        v100 = v104;
        v119 = v104;
        v99 = v104;
        v98 = v104;
        *(_QWORD *)(v122 + 104) = v104;
        v97 = v99;
      }
      v96 = v119;
      v44 = (_QWORD *)v119;
LABEL_121:
      _dispatch_continuation_pop_inline(v45, v51, v50, v52);
      goto LABEL_10;
    }
    if (v43 == 0x40000000000000)
    {
      v38 = (unint64_t *)(v52 + 56);
      v39 = *(_QWORD *)(v52 + 56);
      do
      {
        v23 = v39;
        do
          v24 = __ldaxr(v38);
        while (v24 == v39 && __stlxr(v39 ^ 0x40000000000000, v38));
        v39 = v24;
      }
      while (v24 != v23);
      v43 = (unint64_t)*(unsigned __int16 *)(v52 + 80) << 41;
    }
    else if (!v43)
    {
      v62 = v45;
      v152 = v45;
      if (*v45 < 0x1000uLL && (*v62 & 0x81) != 0)
      {
        v184 = v52;
        v182 = 0x20000000000;
        v181 = 0x20000000000;
        v183 = 0x20000000000;
        v179 = 0;
        v177 = 0x20000000000;
        v176 = 0x20000000000;
        v178 = 0x20000000000;
        v36 = (unint64_t *)(v52 + 56);
        v37 = *(_QWORD *)(v52 + 56);
        do
        {
          v25 = v37;
          do
            v26 = __ldaxr(v36);
          while (v26 == v37 && __stlxr(v37 + 0x20000000000, v36));
          v37 = v26;
        }
        while (v26 != v25);
        v175 = v26;
        v179 = v26;
        v174 = v26;
        v180 = v26 + v183;
      }
      else
      {
        v77 = v52;
        v76 = 0;
        v75 = 0;
        v74 = 0;
        v73 = (unint64_t *)(v52 + 56);
        do
        {
          if (_os_atomic_mo_has_acquire(2))
            v27 = __ldaxr(v73);
          else
            v27 = __ldxr(v73);
          v76 = v27;
          v79 = v27;
          v35 = 1;
          if (!(v27 >> 53))
          {
            v81 = v76;
            v35 = 1;
            if ((v76 & 0x8000000000) == 0)
            {
              v80 = v76;
              v35 = BYTE5(v76) & 1;
            }
          }
          if ((v35 & 1) != 0)
          {
            __clrex();
            v78 = 0;
            goto LABEL_101;
          }
          v75 = v76 + 0x20000000000;
          if (_os_atomic_mo_has_release(2))
            v74 = __stlxr(v75, v73) == 0;
          else
            v74 = __stxr(v75, v73) == 0;
        }
        while (!v74);
        v72 = v74;
        v78 = v74;
LABEL_101:
        if (!v78)
        {
LABEL_138:
          *v49 &= 0x4000000001uLL;
          v156 = &v46;
          _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
          return -1;
        }
      }
      v43 = 0x20000000000;
    }
    v149 = v52;
    v148 = v45;
    v147 = v45;
    v146 = 0;
    v145 = 0;
    v144 = v45[2];
    v145 = v144;
    v143 = v144;
    v146 = v144;
    v142 = v144;
    v141 = v144;
    *(_QWORD *)(v52 + 104) = v144;
    v140 = v142;
    v34 = 0;
    if (!v146)
    {
      v139 = (unint64_t)v147;
      v138 = 0;
      v28 = (unint64_t *)(v149 + 48);
      v136 = 0;
      v135 = 0;
      v137 = 0;
      v29 = v147;
      do
        v30 = __ldaxr(v28);
      while ((_QWORD *)v30 == v29 && __stlxr(0, v28));
      if ((_QWORD *)v30 != v29)
        v139 = v30;
      v134 = v30 == (_QWORD)v29;
      v138 = v30 == (_QWORD)v29;
      v133 = v138;
      v34 = v30 != (_QWORD)v29;
    }
    if (v34)
    {
      v132 = v147;
      v131 = 0;
      v130 = 0;
      v129 = v147[2];
      v130 = v129;
      v128 = v129;
      v131 = v129;
      if (!v129)
        v131 = _dispatch_wait_for_enqueuer(v132 + 2, v149 + 48);
      v127 = v131;
      v146 = v131;
      v126 = v131;
      v125 = v131;
      *(_QWORD *)(v149 + 104) = v131;
      v124 = v126;
    }
    v123 = v146;
    v44 = (_QWORD *)v146;
    v64 = v45;
    v151 = v45;
    if (*v45 < 0x1000uLL && (*v64 & 0x81) != 0)
    {
      v43 -= 0x20000000000;
      _dispatch_non_barrier_waiter_redirect_or_wake(v52, (uint64_t)v45, v12, v13, v14, v15, v16, v17);
    }
    else
    {
      if ((v50 & 0x20000) == 0)
        goto LABEL_121;
      v43 -= 0x20000000000;
      v58 = v52;
      v59 = (unint64_t)*(unsigned int *)(v52 + 60) << 32;
      v59 &= 0x700000000uLL;
      _dispatch_continuation_redirect_push(v52, v45, HIDWORD(v59));
    }
LABEL_10:
    v18 = *(_QWORD *)(v51 + 8) == 0;
    v57 = *(_QWORD *)(v51 + 8) == 0;
    v56 = 3803;
    if (!v18)
      _dispatch_abort(v56, v57, v31, v13, v14, v15, v16, v17);
    v45 = v44;
    if (!v44)
    {
      if (!*(_QWORD *)(v52 + 48))
        break;
      v88 = v52;
      v87 = (unint64_t *)(v52 + 104);
      v86 = 0;
      v85 = 0;
      v84 = *(_QWORD *)(v52 + 104);
      v85 = v84;
      v83 = v84;
      v86 = v84;
      if (!v84)
        v86 = _dispatch_wait_for_enqueuer(v87, v88 + 48);
      v82 = v86;
      v45 = (_QWORD *)v86;
    }
    if (_dispatch_thread_getspecific(5uLL))
      _dispatch_return_to_kernel();
    if ((v48 & 1) == (*(_WORD *)(v52 + 80) == 1))
    {
      v41 = 0;
      if ((v50 & 0x4000000) == 0)
      {
        v160 = v51;
        v159 = 0;
        v159 = _dispatch_thread_getspecific(0x78uLL);
        v41 = v159 & 1;
      }
      if ((v41 & 1) == 0)
      {
        if ((v50 & 0x100000) == 0)
          continue;
        v60 = (unsigned int *)_dispatch_thread_getspecific(0x1BuLL);
        v61 = (unint64_t)v60[15] << 32;
        v61 &= 0x700000000uLL;
        if (HIDWORD(v61) <= *((unsigned __int8 *)v60 + 100))
          continue;
      }
    }
    break;
  }
  if (v43 == 0x40000000000000)
    v43 = ((unint64_t)*(unsigned __int16 *)(v52 + 80) << 41) + 0x40000000000000;
  if (v45)
  {
    v190 = v52;
    v189 = v43;
    v188 = v45;
    v187 = 0;
    v187 = *(_WORD *)(v52 + 80);
    v186 = 0;
    if (v187 >= 2u)
    {
      v185 = v188;
      v195 = v188;
      v194 = 0;
      v197 = v188;
      if (*v188 > 0xFFFuLL)
      {
        if ((*(_QWORD *)(*(_QWORD *)v195 + 16) & 0xF0) == 0x10)
        {
          v193 = 0;
          v192 = v195[20];
          v193 = v192;
          v191 = v192;
          v194 = v192;
          v196 = (v192 & 0x80000) != 0;
        }
        else
        {
          v196 = 0;
        }
      }
      else
      {
        v196 = (*v195 & 2) != 0;
      }
      if (v196)
      {
        v186 = ((unint64_t)(v187 - 1) << 41) + 0x10000000000;
        v189 -= v186;
      }
    }
    v43 = v189;
  }
  *v49 &= 0x4000000001uLL;
  *v49 |= v43;
  v157 = &v46;
  _dispatch_thread_setspecific_packed_pair(20, 21, &v46, v13, v14, v15, v16, v17);
  if (v45)
    return *(_QWORD *)(v52 + 24);
  else
    return 0;
}

void _dispatch_workloop_bound_thread_init_once(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  size_t v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = a1;
  v9 = 0;
  v8 = 4;
  v7 = sysctlbyname("kern.kern_event.thread_bound_kqwl_support_enabled", &v9, &v8, 0, 0);
  v12 = v7;
  v11 = 4220;
  if (v7)
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
  if (v9)
    _dispatch_thread_bound_kqwl_enabled = 1;
}

BOOL _dispatch_workloop_activate_simulator_fallback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  _BOOL8 result;
  unint64_t *v10;
  _BOOL4 v11;
  dispatch_object_s *v12;
  unint64_t v13;

  v12 = (dispatch_object_s *)dispatch_pthread_root_queue_create("com.apple.libdispatch.workloop_fallback", 0, a2, 0, a5, a6, a7, a8);
  *(_QWORD *)(a1 + 24) = v12;
  _dispatch_retain((uint64_t)v12);
  dispatch_release(v12);
  v10 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v8 = __ldaxr(v10);
    else
      v8 = __ldxr(v10);
    v13 = v8 & 0xFFFFFFCFFFFFFFFFLL | 0x1000000000;
    result = _os_atomic_mo_has_release(0);
    if (result)
      v11 = __stlxr(v13, v10) == 0;
    else
      v11 = __stxr(v13, v10) == 0;
  }
  while (!v11);
  return result;
}

uint64_t _dispatch_workloop_activate_tg_unsupported_fallback(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v8;
  const sched_param *v9;
  pthread_attr_t __b;

  v9 = *(const sched_param **)(a1 + 200);
  memset(&__b, 0, sizeof(__b));
  pthread_attr_init(&__b);
  if ((v9->sched_priority & 1) != 0)
    pthread_attr_setschedparam(&__b, v9 + 1);
  if ((v9->sched_priority & 2) != 0)
    pthread_attr_setschedpolicy(&__b, v9[2].sched_priority);
  if ((v9->sched_priority & 4) != 0)
    pthread_attr_setcpupercent_np(&__b, v9[2].__opaque[0], v9[3].sched_priority);
  v8 = _pthread_workloop_create(a1, 0, &__b);
  if (v8)
  {
    if (v8 != 45)
      _dispatch_abort(4396, v8, v1, v2, v3, v4, v5, v6);
    _dispatch_workloop_activate_simulator_fallback(a1, (uint64_t)&__b, v1, v2, v3, v4, v5, v6);
  }
  else
  {
    v9->sched_priority |= 0x10u;
  }
  return pthread_attr_destroy(&__b);
}

uint64_t _dispatch_retain_n_unsafe(uint64_t result, int a2)
{
  unsigned int v2;
  unsigned int v3;
  unsigned int *v4;
  unsigned int v5;

  v4 = (unsigned int *)(result + 8);
  v5 = *(_DWORD *)(result + 8);
  do
  {
    v2 = v5;
    do
      v3 = __ldaxr(v4);
    while (v3 == v5 && __stlxr(v5 + a2, v4));
    v5 = v3;
  }
  while (v3 != v2);
  return result;
}

void _dispatch_queue_wakeup_with_override_slow(uint64_t a1, uint64_t a2, char a3)
{
  unsigned int v3;
  unsigned int v4;
  BOOL v5;
  BOOL v6;
  char v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;
  char v17;
  uint64_t v18;
  int v19;
  unsigned int v20;
  int v21;
  uint64_t v22;
  int v23;
  uint64_t v24;
  char v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  int v29;
  unsigned int *v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  unsigned int v34;
  uint64_t *v35;
  unsigned int *v36;
  unsigned int v37;
  unsigned int v38;
  unsigned int v39;
  unsigned int v40;
  int v41;
  int v42;
  unsigned int *v43;
  int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t v47;
  char v48;
  unsigned int v49;

  v9 = (a2 & 0x700000000uLL) >> 32;
  v8 = *(unsigned int **)(a1 + 24);
  if ((a2 & 0x1000000000) != 0)
  {
    v6 = 0;
    if (v8 >= (unsigned int *)&_dispatch_root_queues)
      v6 = v8 < (unsigned int *)&_dispatch_queue_serial_numbers;
    if (!v6)
      goto LABEL_81;
    if ((a2 & 0xFFFFFFFC) != 0)
      v14 = a2 | 3;
    else
      v14 = 0;
    if (v14)
    {
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v13 = 0;
        if (v9)
          v13 = 1 << (v9 + 7);
        _pthread_workqueue_override_start_direct_check_owner(v14, v13 | 0xFF, a1 + 56);
      }
      goto LABEL_81;
    }
    v7 = 0;
  }
  else if ((*(_DWORD *)(a1 + 80) & 0x400000) != 0)
  {
    v16 = a1;
    v15 = a2 & 0x700000000;
    v36 = (unsigned int *)(a1 + 100);
    v35 = &v15;
    v34 = 0;
    v37 = _dispatch_thread_getspecific(3uLL);
    v34 = v37 & 0xFFFFFFFC;
    v33 = 0;
    v32 = 0;
    v31 = 0;
    v30 = v36;
    do
    {
      if (_os_atomic_mo_has_acquire(2))
        v3 = __ldaxr(v30);
      else
        v3 = __ldxr(v30);
      v33 = v3;
      v39 = v3;
      if ((v3 & 0xFFFFFFFC) != 0)
        v32 = v33 | 2;
      else
        v32 = v34;
      if (_os_atomic_mo_has_release(2))
      {
        LOBYTE(v31) = __stlxr(v32, v30) == 0;
        v31 = v31;
      }
      else
      {
        LOBYTE(v31) = __stxr(v32, v30) == 0;
        v31 = v31;
      }
    }
    while (!v31);
    v29 = v31;
    if (v35)
    {
      v40 = v32;
      if ((v32 & 0xFFFFFFFC) != 0)
        v41 = v40 | 3;
      else
        v41 = 0;
      *(_DWORD *)v35 = v41;
    }
    v38 = v33;
    if ((v33 & 0xFFFFFFFC) != 0)
    {
      v19 = HIDWORD(v15);
      v20 = v15;
      v18 = v16 + 100;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v23 = v19;
        v22 = 0;
        if (v19)
          v22 = 1 << (v23 + 7);
        v21 = _pthread_workqueue_override_start_direct_check_owner(v20, v22 | 0xFF, v18);
      }
      else
      {
        v21 = 0;
      }
      v17 = 0;
    }
    else
    {
      v17 = 1;
    }
    if ((v17 & 1) == 0)
    {
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771883028, a1, 0, 0, 0);
      goto LABEL_81;
    }
    v7 = 1;
    v8 = *(unsigned int **)(a1 + 24);
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771883028, a1, 0, 0, 0);
  }
  else
  {
    v7 = 0;
  }
LABEL_45:
  if ((*(_QWORD *)(*(_QWORD *)v8 + 16) & 0x10000) != 0)
  {
    if (v9 > (v8[21] & 0xF00) >> 8)
      _dispatch_root_queue_push_override_stealer((uint64_t)v8, a1, v9);
  }
  else if (*(_BYTE *)(*(_QWORD *)v8 + 16) == 18)
  {
    _dispatch_workloop_push_stealer((uint64_t)v8, a1, v9);
  }
  else
  {
    v12 = (((unint64_t)v8[15] << 32) & 0x700000000) >> 32;
    v5 = 1;
    if (v12)
      v5 = v12 < v9;
    if (v5)
      (*(void (**)(unsigned int *, _QWORD, _QWORD))(*(_QWORD *)v8 + 64))(v8, v9, 0);
  }
  if (((v7 ^ 1) & 1) == 0)
  {
    while (1)
    {
      v24 = a1;
      v47 = a1 + 100;
      v46 = 0;
      v45 = 0;
      v44 = 0;
      v43 = (unsigned int *)(a1 + 100);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v4 = __ldaxr(v43);
        else
          v4 = __ldxr(v43);
        v46 = v4;
        if ((v4 & 2) != 0)
          v45 = v46 ^ 2;
        else
          v45 = 0;
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v44) = __stlxr(v45, v43) == 0;
          v44 = v44;
        }
        else
        {
          LOBYTE(v44) = __stxr(v45, v43) == 0;
          v44 = v44;
        }
      }
      while (!v44);
      v42 = v44;
      if (v45)
      {
        __dmb(9u);
        v48 = 0;
      }
      else
      {
        v49 = v46;
        if ((v46 & 1) != 0)
          _dispatch_unfair_lock_unlock_slow(v47, v46);
        v48 = 1;
      }
      if ((v48 & 1) != 0)
      {
        v25 = 1;
      }
      else
      {
        v27 = 1;
        v26 = 0;
        v26 = _dispatch_thread_getspecific(0x19uLL);
        v28 = v26 & 0xF0000;
        if (v27 > (v26 & 0xF0000) >> 16)
        {
          v26 &= 0xFFF0FFFF;
          v26 |= v27 << 16;
          _dispatch_thread_setspecific(25, v26);
        }
        v25 = 0;
      }
      if (((v25 ^ 1) & 1) == 0)
        break;
      if ((((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32 > v9)
      {
        v9 = (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32;
        goto LABEL_45;
      }
    }
  }
LABEL_81:
  if ((a3 & 1) != 0)
    _dispatch_release_2_tailcall((unsigned int *)a1);
}

void _dispatch_root_queue_push_override_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t (**v3)();
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  uint64_t (**v11)();
  BOOL v12;
  uint64_t (***v13)();
  char v14;
  uint64_t (**v17)();
  uint64_t (**v18)();
  unint64_t v19;
  int v20;

  v14 = 0;
  if ((*(_BYTE *)(a1 + 87) & 0x80) != 0)
  {
    v14 = 2;
  }
  else if ((*(_BYTE *)(a1 + 87) & 8) != 0)
  {
    v14 = 4;
  }
  v12 = 1;
  if (a3)
    v12 = a3 > 6;
  if (v12)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x4CB44);
  }
  v20 = 0;
  if ((v14 & 2) != 0)
  {
    v20 = 1;
  }
  else if ((v14 & 4) != 0)
  {
    v20 = 2;
  }
  v13 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * a3 + v20 - 3)];
  v18 = (uint64_t (**)())_dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22, (uint64_t)v18[2]);
    v17 = v18;
  }
  else
  {
    v17 = (uint64_t (**)())_dispatch_continuation_alloc_from_heap();
  }
  *v17 = (uint64_t (*)())&unk_E0DE8;
  _dispatch_retain_2(a2);
  v17[4] = 0;
  v17[5] = (uint64_t (*)())v17;
  v17[7] = (uint64_t (*)())a1;
  v17[6] = (uint64_t (*)())a2;
  v17[1] = (uint64_t (*)())-1;
  v17[3] = (uint64_t (*)())-1;
  v17[2] = 0;
  _dispatch_thread_setspecific(122, (uint64_t)(v13 + 6));
  v10 = (unint64_t *)(v13 + 6);
  v11 = v13[6];
  do
  {
    v3 = v11;
    do
      v4 = __ldaxr(v10);
    while ((uint64_t (**)())v4 == v11 && __stlxr((unint64_t)v17, v10));
    v11 = (uint64_t (**)())v4;
  }
  while (v4 != (_QWORD)v3);
  v19 = v4;
  if (v4)
    *(_QWORD *)(v4 + 16) = v17;
  else
    v13[13] = v17;
  _dispatch_thread_setspecific(122, 0);
  if (!v19)
    _dispatch_root_queue_poke_and_wakeup(v13, 1, 0, v5, v6, v7, v8, v9);
}

void _dispatch_workloop_push_stealer(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v11;
  _QWORD *v12;

  v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22, v12[2]);
    v11 = v12;
  }
  else
  {
    v11 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v11 = &unk_E0DB0;
  _dispatch_retain_2(a2);
  v11[4] = 0;
  v11[5] = v11;
  v11[7] = 0;
  v11[6] = a2;
  v11[1] = -1;
  v11[3] = -1;
  _dispatch_workloop_push(a1, v11, a3, v3, v4, v5, v6, v7);
}

void _dispatch_lane_drain_non_barriers(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t *v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  unint64_t *v25;
  unint64_t v26;
  BOOL v27;
  BOOL v28;
  BOOL v29;
  unint64_t *v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t *v34;
  _BOOL4 v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  _DWORD *v40;
  uint64_t v41;
  unsigned int v42;
  BOOL v47;
  unint64_t *v48;
  _BOOL4 v49;
  unint64_t v50;
  char v51;
  uint64_t v52;
  _DWORD *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  unsigned __int16 v60;
  uint64_t v61;
  BOOL v62;

  v42 = a3;
  v41 = *(unsigned __int16 *)(a1 + 80);
  v32 = (unint64_t *)(a1 + 56);
  v33 = *(_QWORD *)(a1 + 56);
  do
  {
    v8 = v33;
    do
      v9 = __ldaxr(v32);
    while (v9 == v33 && __stlxr(v33 & 0xFFBFFFFFFFFFFFFFLL, v32));
    v33 = v9;
  }
  while (v9 != v8);
  while (1)
  {
    if (v41)
    {
      --v41;
      goto LABEL_33;
    }
    if (*(_QWORD *)a2 > 0xFFFuLL || (*(_QWORD *)a2 & 0x81) == 0)
      break;
    v30 = (unint64_t *)(a1 + 56);
    v31 = *(_QWORD *)(a1 + 56);
    do
    {
      v10 = v31;
      do
        v11 = __ldaxr(v30);
      while (v11 == v31 && __stlxr(v31 + 0x20000000000, v30));
      v31 = v11;
    }
    while (v11 != v10);
LABEL_33:
    v53 = *(_DWORD **)(a2 + 16);
    *(_QWORD *)(a1 + 104) = v53;
    v28 = 0;
    if (!v53)
    {
      v13 = (unint64_t *)(a1 + 48);
      do
        v14 = __ldaxr(v13);
      while (v14 == a2 && __stlxr(0, v13));
      v28 = v14 != a2;
    }
    if (v28)
    {
      v52 = *(_QWORD *)(a2 + 16);
      if (!v52)
        v52 = _dispatch_wait_for_enqueuer((unint64_t *)(a2 + 16), a1 + 48);
      v53 = (_DWORD *)v52;
      *(_QWORD *)(a1 + 104) = v52;
    }
    v40 = v53;
    if (*(_QWORD *)a2 <= 0xFFFuLL && (*(_QWORD *)a2 & 0x81) != 0)
      _dispatch_non_barrier_waiter_redirect_or_wake(a1, a2, a3, a4, a5, a6, a7, a8);
    else
      _dispatch_continuation_redirect_push(a1, (_QWORD *)a2, (((unint64_t)*(unsigned int *)(a1 + 60) << 32) & 0x700000000) >> 32);
LABEL_48:
    a2 = (uint64_t)v40;
    v27 = 0;
    if (v40)
    {
      if (*(_QWORD *)v40 > 0xFFFuLL)
        v47 = (*(_QWORD *)(*(_QWORD *)v40 + 16) & 0xF0) == 0x10 && (v40[20] & 0x80000) != 0;
      else
        v47 = (*(_QWORD *)v40 & 2) != 0;
      v27 = !v47;
    }
    if (!v27)
      goto LABEL_56;
  }
  v48 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(2))
      v12 = __ldaxr(v48);
    else
      v12 = __ldxr(v48);
    v29 = 1;
    if (v12 < 0x20000000000000)
    {
      v29 = 1;
      if ((v12 & 0x8000000000) == 0)
        v29 = (v12 & 0x10000000000) != 0;
    }
    if (v29)
    {
      __clrex();
      v51 = 0;
      goto LABEL_32;
    }
    v50 = v12 + 0x20000000000;
    if (_os_atomic_mo_has_release(2))
      v49 = __stlxr(v50, v48) == 0;
    else
      v49 = __stxr(v50, v48) == 0;
  }
  while (!v49);
  v51 = 1;
LABEL_32:
  if ((v51 & 1) != 0)
    goto LABEL_33;
LABEL_56:
  v37 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v36 = v41 << 41;
  if (a2)
  {
    v61 = v41 << 41;
    v60 = *(_WORD *)(a1 + 80);
    if (v60 > 1u)
    {
      if (*(_QWORD *)a2 > 0xFFFuLL)
        v62 = (*(_QWORD *)(*(_QWORD *)a2 + 16) & 0xF0) == 0x10 && (*(_DWORD *)(a2 + 80) & 0x80000) != 0;
      else
        v62 = (*(_QWORD *)a2 & 2) != 0;
      if (v62)
        v61 = v36 - (((uint64_t)(v60 - 1) << 41) + 0x10000000000);
    }
    v36 = v61;
  }
  v34 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v15 = __ldaxr(v34);
    else
      v15 = __ldxr(v34);
    v39 = v15;
    v38 = (v15 - v36) & 0xFFFFFF7700000001;
    if (a2)
    {
      v57 = v38 | 0x8000000000;
      v54 = v38 | 0x8000000000;
      if (((v15 - v36) & 0x10000000000) != 0)
        v55 = v54 + 0x10000000000;
      else
        v55 = v54 + ((unint64_t)*(unsigned __int16 *)(a1 + 80) << 41);
      v56 = v55 + 0x40000000000000;
      if ((v56 & 0x3FFE0000000000) == 0x20000000000000)
      {
        v57 = v56 & 0xFFFFFF7FFFFFFFFFLL | v37;
      }
      else if ((v15 & 0x8000000000) != 0)
      {
        v57 = (v15 - v36) & 0xFFFFFF7700000000 | 0x8000000001;
      }
      v38 = v57;
    }
    else if ((v15 & 0x8000000000) != 0)
    {
      __clrex();
      v25 = (unint64_t *)(a1 + 56);
      v26 = *(_QWORD *)(a1 + 56);
      do
      {
        v16 = v26;
        do
          v17 = __ldaxr(v25);
        while (v17 == v26 && __stlxr(v26 ^ 0x8000000000, v25));
        v26 = v17;
      }
      while (v17 != v16);
      v40 = *(_DWORD **)(a1 + 104);
      goto LABEL_48;
    }
    if (_os_atomic_mo_has_release(0))
      v35 = __stlxr(v38, v34) == 0;
    else
      v35 = __stxr(v38, v34) == 0;
  }
  while (!v35);
  v58 = v39 - v36;
  v24 = 0;
  if (((v39 - v36) & 0x1000000000) != 0)
    v24 = ((v39 - v36) & 0x800000000) != 0;
  if (v24)
  {
    v59 = v58 & 0x700000000;
    LODWORD(v59) = _dispatch_thread_getspecific(0x19uLL);
    if ((v58 & 0x700000000) >> 32 > (v59 & 0xF0000) >> 16)
      _dispatch_thread_setspecific(25, v59 & 0xFFF0FFFF | (HIDWORD(v59) << 16));
  }
  if (((v58 ^ v38) & 0x40000000000000) != 0)
  {
    _dispatch_lane_barrier_complete(a1, 0, v42);
  }
  else if (((v58 ^ v38) & 1) != 0)
  {
    if ((v42 & 1) == 0)
      _dispatch_retain_2(a1);
    if ((v38 & 0x2000000000) != 0)
      _dispatch_abort(1002, 0, v18, v19, v20, v21, v22, v23);
    (*(void (**)(_QWORD, uint64_t, unint64_t, uint64_t, uint64_t, uint64_t))(**(_QWORD **)(a1 + 24) + 72))(*(_QWORD *)(a1 + 24), a1, (v38 & 0x700000000) >> 32, v19, v20, v21);
  }
  else if ((v42 & 1) != 0)
  {
    _dispatch_release_2_tailcall((unsigned int *)a1);
  }
}

uint64_t _dispatch_channel_invoke_cancel_check(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  char v5;

  v5 = 1;
  if (((*(_WORD *)(a1 + 116) >> 3) & 1) == 0 && (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    v4 = 0;
    if ((*(_DWORD *)(a2 + 32) & 0x1000000) != 0)
      v4 = _dispatch_autorelease_pool_push();
    v5 = (*(uint64_t (**)(uint64_t, _QWORD))(a3 + 24))(a1, *(_QWORD *)(a1 + 32)) & 1;
    if (v4)
      _dispatch_autorelease_pool_pop(v4);
    if ((v5 & 1) != 0)
    {
      *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
      _dispatch_release_no_dispose(a1);
    }
    else
    {
      *(_QWORD *)(a2 + 40) = -1;
    }
  }
  return v5 & 1;
}

uint64_t _dispatch_mgr_sched_qos2prio(int a1)
{
  unint64_t v2;

  if (a1 == 5)
  {
    return 4;
  }
  else
  {
    v2 = (a1 - 9);
    if (v2 <= 0x18)
      __asm { BR              X8 }
    return 0;
  }
}

void _dispatch_mgr_priority_apply()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  sched_param v7;
  uint64_t v8;
  uint64_t v9;

  v7 = 0;
  do
  {
    v7.sched_priority = _dispatch_mgr_sched;
    if (_dispatch_mgr_sched > dword_E5060)
    {
      v6 = pthread_setschedparam((pthread_t)qword_E5068, dword_E5064, &v7);
      v9 = v6;
      v8 = 6239;
      if (v6)
        _dispatch_bug(v8, v9, v0, v1, v2, v3, v4, v5);
    }
  }
  while (_dispatch_mgr_sched > v7.sched_priority);
}

void _dispatch_mgr_queue_drain()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  int v19;
  int v20;
  uint64_t v21;
  uint64_t (***v22)();
  _OWORD v23[2];
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  BOOL v30;
  int v31;
  void *v32;
  uint64_t v33;
  void *v34;
  _BYTE *v35;
  uint64_t v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  uint64_t v43;
  _BYTE *v44;
  unsigned int v45;
  unsigned int v46;

  v24 = 0x40000;
  memset(v23, 0, sizeof(v23));
  v22 = &_dispatch_mgr_q;
  v21 = 0x40020000000000;
  if (qword_E4170)
  {
    v26 = 15;
    v25 = _dispatch_thread_getspecific(0x19uLL);
    v27 = v25 & 0xF0000;
    if ((v25 & 0xF0000) >> 16 < 0xF)
    {
      v25 = v25 & 0xFFF0FFFF | (v26 << 16);
      _dispatch_thread_setspecific(25, v25);
    }
    if (_dispatch_lane_serial_drain((uint64_t)v22, (uint64_t)v23, 0x40000, &v21, v0, v1, v2, v3))
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Interrupted drain on manager queue";
      __break(1u);
      JUMPOUT(0x4E87CLL);
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: mgr queue clear", v4, v5, v6, v7, v8, v9, v10, 6387);
    v33 = 0;
    v32 = 0;
    v36 = 0;
    v35 = 0;
    v35 = _dispatch_thread_getspecific(0x1CuLL);
    v44 = v35;
    v43 = v36;
    if (v35 == (_BYTE *)v36)
    {
      v45 = -1;
    }
    else
    {
      if (v44)
      {
        v42 = 0;
        v41 = 0;
      }
      _dispatch_thread_setspecific(28, v43);
      if (v43)
      {
        v40 = 0;
        v39 = 0;
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v11, v12, v13, v14, v15, v16, v17, 400);
      v38 = 0;
      if (v43)
        v20 = *(_DWORD *)(v43 + 32);
      else
        v20 = 0;
      v38 = v20;
      v37 = 0;
      if (v44)
        v19 = *((_DWORD *)v44 + 8);
      else
        v19 = 0;
      v37 = v19;
      if (v38 == v19)
        v18 = -1;
      else
        v18 = v38;
      v45 = v18;
    }
    v46 = v45;
    if (v45 != -1)
      _dispatch_set_priority_and_mach_voucher_slow(0, v46);
    v32 = v35;
    if (v35)
    {
      v34 = v32;
      os_release(v32);
    }
    v29 = 0;
    v29 = _dispatch_thread_getspecific(0x19uLL);
    v31 = v29 & 0xF0000;
    v28 = (v29 & 0xF0000) >> 16;
    if ((v29 & 0xF0000) >> 16)
    {
      v29 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25, v29);
      v30 = v28 != 15;
    }
    else
    {
      v30 = 0;
    }
  }
  if ((_dispatch_kevent_workqueue_enabled & 1) == 0)
    _dispatch_force_cache_cleanup();
}

void _dispatch_force_cache_cleanup()
{
  _QWORD *v0;

  v0 = _dispatch_thread_getspecific(0x16uLL);
  if (v0)
  {
    _dispatch_thread_setspecific(22, 0);
    _dispatch_cache_cleanup(v0);
  }
}

uint64_t *_dispatch_mgr_root_queue_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  int v19;
  int v20;
  int v21;
  sched_param v22;
  pthread_attr_t *__attr;
  void *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  dispatch_function_t v31;
  void *v32;
  dispatch_once_t *v33;

  v33 = &_dispatch_mgr_sched_pred;
  v32 = 0;
  v31 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1)
    dispatch_once_f(v33, v32, v31);
  v24 = off_E40E0;
  __attr = (pthread_attr_t *)off_E40E0;
  v22 = 0;
  v21 = pthread_attr_setdetachstate((pthread_attr_t *)off_E40E0, 2);
  v30 = v21;
  v29 = 6200;
  if (v21)
    _dispatch_bug(v29, v30, v0, v1, v2, v3, v4, v5);
  if (dword_E505C)
  {
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v20 = pthread_attr_set_qos_class_np(__attr, (qos_class_t)dword_E505C, 0);
      v28 = v20;
      v27 = 6209;
      if (v20)
        _dispatch_bug(v27, v28, v6, v7, v8, v9, v10, v11);
    }
  }
  v22.sched_priority = _dispatch_mgr_sched;
  if (_dispatch_mgr_sched > dword_E5060)
  {
    v19 = pthread_attr_setschedparam(__attr, &v22);
    v26 = v19;
    v25 = 6215;
    if (v19)
      _dispatch_bug(v25, v26, v12, v13, v14, v15, v16, v17);
  }
  return &qword_E5068;
}

uint64_t _dispatch_worker_thread(uint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  dispatch_time_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v23;
  unsigned int v24;
  unint64_t v25;
  BOOL v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  void *v31;
  uint64_t v32;
  unint64_t v34;
  unint64_t v35;
  unint64_t v36;

  v32 = *(_QWORD *)(a1 + 32);
  v27 = (unsigned int *)(a1 + 112);
  v28 = *(_DWORD *)(a1 + 112);
  do
  {
    v1 = v28;
    do
      v2 = __ldaxr(v27);
    while (v2 == v28 && __stlxr(v28 - 1, v27));
    v28 = v2;
  }
  while (v2 != v1);
  if (((v2 - 1) & 0x80000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Pending thread request underflow";
    qword_E4DA8 = (int)(v2 - 1);
    __break(1u);
    JUMPOUT(0x4EF34);
  }
  if (*(_QWORD *)(v32 + 144))
    _dispatch_thread_setspecific(24, v32 + 144);
  if (*(_QWORD *)(a1 + 72))
    pthread_setname_np(*(const char **)(a1 + 72));
  if (*(_QWORD *)(v32 + 64))
    (*(void (**)(void))(*(_QWORD *)(v32 + 64) + 16))();
  _dispatch_sigmask();
  v31 = _dispatch_thread_getspecific(4uLL);
  v29 = *(_DWORD *)(a1 + 84);
  if ((v29 & 0x46000FFF) == 0)
  {
    v30 = v29 & 0x80000000;
    v26 = 0;
    if ((BYTE3(v31) & 0x22) == 0)
      v26 = (BYTE1(v31) & 0x3F) != 0;
    if (v26)
    {
      if ((v31 & 0x20000000) != 0)
        _dispatch_abort(447, (v31 & 0x20000000) == 0, v3, v4, v5, v6, v7, v8);
      v9 = (v31 & 0x3FFF00) >> 8;
      v10 = __clz(__rbit32(v9));
      if (v9)
        v11 = v10 + 1;
      else
        v11 = 0;
      v29 = v30 | v31 & 0x8E0000FF | (v11 << 8);
    }
    else
    {
      v29 = v30 | 0xF0000;
    }
  }
  do
  {
    _dispatch_root_queue_drain(a1, v29, 0x20000);
    v34 = (unint64_t)v31;
    if (v31 == (void *)-1)
      v34 = 0;
    if (v34 == -1)
      _dispatch_abort(2332, 0, v12, v13, v14, v15, v16, v17);
    if ((_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v35 = v34 & 0xFFFFFFFF02FFFFFFLL;
      v18 = (unint64_t)_dispatch_thread_getspecific(4uLL);
      if ((v18 & 0x1000000) != 0)
      {
        if (v35)
          v25 = v34 & 0xFFFFFFFF02FFFFFFLL;
        else
          v25 = v18 & 0xFFFFFFFFFEFFFFFFLL;
        v36 = v25;
      }
      else if (v35 == (v18 & 0xFFFFFFFF77FFFFFFLL))
      {
        v36 = 0;
      }
      else
      {
        v36 = v34 & 0xFFFFFFFF02FFFFFFLL;
      }
    }
    else
    {
      v36 = 0;
    }
    if (v36 || _dispatch_thread_getspecific(0x1CuLL))
      _dispatch_set_priority_and_voucher_slow(v36, 0, 6);
    v19 = dispatch_time(0, 5000000000);
  }
  while (!dispatch_semaphore_wait((dispatch_semaphore_t)(v32 + 72), v19));
  v23 = (unsigned int *)(a1 + 100);
  v24 = *(_DWORD *)(a1 + 100);
  do
  {
    v20 = v24;
    do
      v21 = __ldaxr(v23);
    while (v21 == v24 && __stlxr(v24 + 1, v23));
    v24 = v21;
  }
  while (v21 != v20);
  _dispatch_root_queue_poke(a1, 1, 0);
  _dispatch_release((unsigned int *)a1);
  return 0;
}

uint64_t _dispatch_root_queue_drain(uint64_t a1, unsigned int a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  _BOOL4 v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unsigned int *v41;
  unsigned int v42;
  _OWORD v43[2];
  BOOL v44;
  _QWORD *v45;
  uint64_t v46;
  void *v47;
  void *v48;
  int v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  void *v53;
  _OWORD *v54;
  unsigned int v55;
  unsigned int v56;
  BOOL v57;
  int v58;
  unsigned int v59;
  uint64_t v60;
  _BOOL8 v61;
  uint64_t v62;
  _BOOL8 v63;
  unint64_t v64;
  char v65;
  unint64_t v66;
  unint64_t v67;
  unint64_t v68;
  _QWORD *v69;
  unsigned int v70;
  unsigned int v71;
  int v72;
  int v73;
  int v74;
  unsigned int v75;
  unsigned int v76;
  int v77;
  int v78;
  int v79;
  int v80;
  _QWORD *v81;

  v51 = a1;
  v50 = a2;
  v49 = a3;
  v48 = _dispatch_thread_getspecific(0x14uLL);
  if (v48)
  {
    v47 = v48;
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Premature thread recycling";
    qword_E4DA8 = (uint64_t)v48;
    __break(1u);
    JUMPOUT(0x4F638);
  }
  v46 = v51;
  v52 = v51;
  _dispatch_thread_setspecific(20, v51);
  v59 = v50;
  v9 = _dispatch_thread_getspecific(0x19uLL) == 0;
  v61 = v9;
  v60 = 2256;
  if (!v9)
    _dispatch_abort(v60, v61, v3, v4, v5, v6, v7, v8);
  _dispatch_thread_setspecific(25, v59);
  v66 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
  v64 = v66 & 0xFFFFFFFFFFFFFFFELL;
  if ((v66 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
  {
    v65 = 0;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v10, v11, v12, v13, v14, v15, v16, 825);
    v68 = v64;
    if (v64 && v68 != -4)
    {
      v67 = v68;
      v81 = (_QWORD *)v68;
      v80 = 0;
      v78 = 1;
      v77 = 1;
      v79 = 1;
      v75 = 0;
      v73 = 1;
      v72 = 1;
      v74 = 1;
      v41 = (unsigned int *)(v68 + 96);
      v42 = *(_DWORD *)(v68 + 96);
      do
      {
        v17 = v42;
        do
          v18 = __ldaxr(v41);
        while (v18 == v42 && __stlxr(v42 - 1, v41));
        v42 = v18;
      }
      while (v18 != v17);
      v71 = v18;
      v75 = v18;
      v70 = v18;
      v76 = v18 - v79;
      v80 = v18 - v79;
      if (((v18 - v79) & 0x80000000) != 0)
      {
        if (v80 <= -2)
        {
          qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
          __break(1u);
          JUMPOUT(0x4F874);
        }
        v81[7] = 0xDEAD000000000000;
        v69 = v81;
        _dispatch_object_dealloc(v81);
      }
    }
    _dispatch_thread_setspecific(27, -4);
    v65 = 1;
  }
  if ((v65 & 1) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
    __break(1u);
    JUMPOUT(0x4F8E4);
  }
  v45 = 0;
  v44 = 0;
  memset(v43, 0, sizeof(v43));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v43);
  while (1)
  {
    v45 = (_QWORD *)_dispatch_root_queue_drain_one(v51, v19, v20, v21, v22, v23, v24, v25);
    if (!v45)
      break;
    if (v44 && (_dispatch_set_qos_class_enabled & 1) != 0)
      _pthread_workqueue_override_reset();
    _dispatch_continuation_pop_inline(v45, (uint64_t)v43, v49, v51);
    v56 = 0;
    v56 = _dispatch_thread_getspecific(0x19uLL);
    v58 = v56 & 0xF0000;
    v55 = (v56 & 0xF0000) >> 16;
    if ((v56 & 0xF0000) >> 16)
    {
      v56 &= 0xFFF0FFFF;
      _dispatch_thread_setspecific(25, v56);
      v57 = v55 != 15;
    }
    else
    {
      v57 = 0;
    }
    v44 = v57;
    v54 = v43;
    v53 = 0;
    v53 = _dispatch_thread_getspecific(0x78uLL);
    if ((v53 & 1) != 0)
      break;
    _dispatch_thread_setspecific(120, 0);
  }
  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v43);
  v32 = _dispatch_thread_getspecific(0x1BuLL) == (void *)-4;
  v63 = v32;
  v62 = 871;
  if (!v32)
    _dispatch_abort(v62, v63, v26, v27, v28, v29, v30, v31);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\twlh[anon]: clear current", v33, v34, v35, v36, v37, v38, v39, 872);
  _dispatch_thread_setspecific(27, 0);
  _dispatch_thread_setspecific(5, 0);
  _dispatch_thread_setspecific(25, 0);
  return _dispatch_thread_setspecific(20, 0);
}

unint64_t _dispatch_root_queue_drain_one(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;

  while (1)
  {
    while (1)
    {
      v16 = (unint64_t *)(a1 + 104);
      v17 = *(_QWORD *)(a1 + 104);
      do
      {
        v8 = v17;
        do
          v9 = __ldaxr(v16);
        while (v9 == v17 && __stlxr(0xFFFFFFFFFFFFFFFFLL, v16));
        v15 = v9;
        v17 = v9;
      }
      while (v9 != v8);
      if (v9)
        break;
      v10 = (unint64_t *)(a1 + 104);
      do
        v11 = __ldaxr(v10);
      while (v11 == -1 && __stlxr(0, v10));
      if (v11 == -1
        && (!*(_QWORD *)(a1 + 48)
         || !__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(a1, _dispatch_root_queue_head_tail_quiesced, a3, a4, a5, a6, a7, a8)))
      {
        return 0;
      }
    }
    if (v9 != -1)
      break;
    if (!__DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(a1, (uint64_t (*)(uint64_t))_dispatch_root_queue_mediator_is_gone, a3, a4, a5, a6, a7, a8))return 0;
  }
  v19 = *(_QWORD *)(v9 + 16);
  if (!v19)
  {
    *(_QWORD *)(a1 + 104) = 0;
    v12 = (unint64_t *)(a1 + 48);
    do
      v13 = __ldaxr(v12);
    while (v13 == v9 && __stlxr(0, v12));
    if (v13 == v9)
      return v15;
    v18 = *(_QWORD *)(v9 + 16);
    if (!v18)
      v18 = _dispatch_wait_for_enqueuer((unint64_t *)(v9 + 16), a1 + 48);
    v19 = v18;
  }
  *(_QWORD *)(a1 + 104) = v19;
  _dispatch_root_queue_poke((unsigned int *)a1, 1u, 0, a4, a5, a6, a7, a8);
  return v15;
}

BOOL __DISPATCH_ROOT_QUEUE_CONTENDED_WAIT__(uint64_t a1, uint64_t (*a2)(uint64_t), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  int v25;
  BOOL v26;
  char v27;
  int v28;
  mach_msg_timeout_t v29;

  v29 = 500;
  v28 = 1;
  v27 = 0;
  while (1)
  {
    v26 = 0;
    v25 = 79;
    do
    {
      if (!v25--)
        break;
      __yield();
      v28 = a2(a1);
      v26 = v28 != 0;
    }
    while (!v28);
    if (v26)
      break;
    if ((v27 & 1) == 0)
    {
      v23 = (unsigned int *)(a1 + 112);
      v24 = *(_DWORD *)(a1 + 112);
      do
      {
        v9 = v24;
        do
          v10 = __ldaxr(v23);
        while (v10 == v24 && __stlxr(v24 + 1, v23));
        v24 = v10;
      }
      while (v10 != v9);
      v27 = 1;
    }
    thread_switch(0, 3, v29);
    v28 = a2(a1);
    if (v28)
      break;
    v29 *= 2;
    if (v29 >= 0x186A0)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tcontention on global queue: %p", v11, v12, v13, v14, v15, v16, v17, 7076);
      break;
    }
  }
  if ((v27 & 1) != 0)
  {
    v21 = (unsigned int *)(a1 + 112);
    v22 = *(_DWORD *)(a1 + 112);
    do
    {
      v18 = v22;
      do
        v19 = __ldaxr(v21);
      while (v19 == v22 && __stlxr(v22 - 1, v21));
      v22 = v19;
    }
    while (v19 != v18);
    if (*(_QWORD *)(a1 + 48))
      v28 = 1;
  }
  if (!v28)
    _dispatch_root_queue_poke((unsigned int *)a1, 1u, 0, a4, a5, a6, a7, a8);
  return v28 == 1;
}

uint64_t _dispatch_root_queue_head_tail_quiesced(uint64_t a1)
{
  uint64_t v2;

  v2 = *(_QWORD *)(a1 + 48);
  if ((*(_QWORD *)(a1 + 104) == 0) == (v2 == 0))
  {
    if (v2)
      return 1;
    else
      return 2;
  }
  else
  {
    return 0;
  }
}

BOOL _dispatch_root_queue_mediator_is_gone(uint64_t a1)
{
  return *(_QWORD *)(a1 + 104) != -1;
}

void _dispatch_root_queue_init_pthread_pool(uint64_t a1, int a2, int a3)
{
  unint64_t v3;
  int v4;
  int v5;
  uint64_t v6;

  v6 = *(_QWORD *)(a1 + 32);
  v5 = 32;
  if (a3 >= 0)
    v5 = MEMORY[0xFFFFFC034];
  if (a2 && a2 < v5)
    v5 = a2;
  *(_DWORD *)(a1 + 100) = v5;
  if ((unsigned __int16)(a3 & 0xF00) >> 8)
    v4 = (unsigned __int16)(a3 & 0xF00) >> 8;
  else
    v4 = (unsigned __int16)(a3 & 0xF000) >> 12;
  v3 = (v4 - 1);
  if (v3 <= 5)
    __asm { BR              X8 }
  *(_QWORD *)(v6 + 72) = _OS_dispatch_semaphore_vtable;
  *(_DWORD *)(v6 + 136) = 0;
  if (!*(_DWORD *)(v6 + 136))
    _dispatch_sema4_create_slow((unsigned int *)(v6 + 136), 2);
}

void _dispatch_mgr_priority_raise(pthread_attr_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  qos_class_t v7;
  signed int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  _BOOL4 v17;
  signed int sched_priority;
  _BOOL4 v19;
  qos_class_t __qos_class;
  qos_class_t v21;
  int v22;
  int v23;
  sched_param v24;
  pthread_attr_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  dispatch_function_t v30;
  void *v31;
  dispatch_once_t *v32;
  dispatch_function_t v33;
  void *v34;
  dispatch_once_t *v35;

  v25 = a1;
  v35 = &_dispatch_mgr_sched_pred;
  v34 = 0;
  v33 = (dispatch_function_t)_dispatch_mgr_sched_init;
  if (_dispatch_mgr_sched_pred != -1)
    dispatch_once_f(v35, v34, v33);
  v24 = 0;
  v23 = pthread_attr_getschedparam(v25, &v24);
  v29 = v23;
  v28 = 6293;
  if (v23)
    _dispatch_bug(v28, v29, v1, v2, v3, v4, v5, v6);
  v22 = v23;
  v21 = QOS_CLASS_UNSPECIFIED;
  __qos_class = QOS_CLASS_UNSPECIFIED;
  pthread_attr_get_qos_class_np(v25, &__qos_class, 0);
  if (__qos_class)
  {
    v24.sched_priority = _dispatch_mgr_sched_qos2prio(__qos_class);
    while (1)
    {
      v7 = _os_atomic_mo_has_acquire(0) ? __ldaxr((unsigned int *)&dword_E505C) : __ldxr((unsigned int *)&dword_E505C);
      v21 = v7;
      if (v7 >= __qos_class)
        break;
      if (_os_atomic_mo_has_release(0))
        v19 = __stlxr(__qos_class, (unsigned int *)&dword_E505C) == 0;
      else
        v19 = __stxr(__qos_class, (unsigned int *)&dword_E505C) == 0;
      if (v19)
        goto LABEL_16;
    }
    __clrex();
  }
LABEL_16:
  sched_priority = v24.sched_priority;
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v8 = __ldaxr((unsigned int *)&_dispatch_mgr_sched);
    else
      v8 = __ldxr((unsigned int *)&_dispatch_mgr_sched);
    if (v8 >= sched_priority)
    {
      __clrex();
      return;
    }
    if (_os_atomic_mo_has_release(0))
      v17 = __stlxr(sched_priority, (unsigned int *)&_dispatch_mgr_sched) == 0;
    else
      v17 = __stxr(sched_priority, (unsigned int *)&_dispatch_mgr_sched) == 0;
  }
  while (!v17);
  v32 = &_dispatch_root_queues_pred;
  v31 = 0;
  v30 = (dispatch_function_t)_dispatch_root_queues_init_once;
  if (_dispatch_root_queues_pred != -1)
    dispatch_once_f(v32, v31, v30);
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    v16 = 0;
    if (sched_priority <= dword_E5060)
    {
      if (__qos_class)
        v16 = _pthread_qos_class_encode(__qos_class, 0, 0);
    }
    else
    {
      v16 = sched_priority | 0x20000000;
    }
    if (v16)
    {
      v15 = _pthread_workqueue_set_event_manager_priority(v16);
      v27 = v15;
      v26 = 6325;
      if (v15)
        _dispatch_bug(v26, v27, v9, v10, v11, v12, v13, v14);
    }
  }
  else if (qword_E5068)
  {
    _dispatch_mgr_priority_apply();
  }
}

void _dispatch_runloop_queue_class_poke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  BOOL v8;
  int v9;
  unsigned int v10;

  v10 = *(_QWORD *)(a1 + 32);
  v8 = 0;
  if (v10)
    v8 = v10 != -1;
  if (v8)
  {
    v9 = _dispatch_send_wakeup_runloop_thread(v10, 0);
    if (v9 != 16 && v9 != 268435460 && v9 != 268435459)
    {
      if (v9)
        _dispatch_bug(7895, v9, v1, v2, v3, v4, v5, v6);
    }
  }
}

uint64_t _dispatch_main_queue_update_priority_from_thread()
{
  uint64_t result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v13 = *(_QWORD *)&dword_E4078;
  if ((dword_E4078 & 0xFFFFFFFC) != 0)
    v15 = dword_E4078 | 3;
  else
    v15 = 0;
  result = (uint64_t)_dispatch_thread_getspecific(4uLL);
  if ((result & 0x20000000) != 0)
    _dispatch_abort(447, (result & 0x20000000) == 0, v1, v2, v3, v4, v5, v6);
  v7 = (result & 0x3FFF00) >> 8;
  v8 = __clz(__rbit32(v7));
  if (v7)
    v9 = v8 + 1;
  else
    v9 = 0;
  v12 = ((result | (v9 << 8)) & 0xF00) >> 8;
  v11 = (v13 & 0x700000000uLL) >> 32;
  v10 = (unsigned __int16)(dword_E4094 & 0xF00) >> 8;
  dword_E4094 = result | (v9 << 8);
  if (v10 < v11 && !v12)
  {
    if ((_dispatch_set_qos_class_enabled & 1) == 0)
      return result;
    return _pthread_qos_override_end_direct(v15, &_dispatch_main_q);
  }
  if (v10 >= v11 || v11 > v12)
  {
    if (v12 < v11 && v11 <= v10)
    {
      v14 = 0;
      if (v11)
        v14 = 1 << (v11 + 7);
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
        return _pthread_qos_override_start_direct(v15, v14 | 0xFF, &_dispatch_main_q);
    }
  }
  else if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    return _pthread_qos_override_end_direct(v15, &_dispatch_main_q);
  }
  return result;
}

uint64_t _dispatch_root_queues_init_once(uint64_t a1)
{
  uint64_t result;
  uint64_t v2;
  int v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t StatusReg;

  v10 = a1;
  if ((_dispatch_unsafe_fork & 1) == 0)
    _dispatch_fork_becomes_unsafe_slow();
  v9 = _pthread_workqueue_supported();
  v8 = 45;
  if ((v9 & 0x10) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: QoS Maintenance support required";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x51224);
  }
  v4 = 0x200000000uLL;
  v5 = 0uLL;
  v6 = 64;
  v7 = 72;
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    if ((v9 & 0x80) != 0)
    {
      *((_QWORD *)&v5 + 1) = _dispatch_worker_thread2;
      *((_QWORD *)&v4 + 1) = _dispatch_kevent_worker_thread;
      *(_QWORD *)&v5 = _dispatch_workloop_worker_thread;
      result = pthread_workqueue_setup(&v4, 48);
      v8 = result;
    }
    else
    {
      if ((v9 & 0x40) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Missing Kevent WORKQ support";
        qword_E4DA8 = v9;
        __break(1u);
        JUMPOUT(0x5136CLL);
      }
      *((_QWORD *)&v5 + 1) = _dispatch_worker_thread2;
      *((_QWORD *)&v4 + 1) = _dispatch_kevent_worker_thread;
      result = pthread_workqueue_setup(&v4, 48);
      v8 = result;
    }
  }
  else
  {
    *((_QWORD *)&v5 + 1) = _dispatch_worker_thread2;
    result = pthread_workqueue_setup(&v4, 48);
    v8 = result;
  }
  if (v8)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Root queue initialization failed";
    qword_E4DA8 = v9 | (v8 << 16);
    __break(1u);
    JUMPOUT(0x513D4);
  }
  if ((_dispatch_mode & 4) != 0)
  {
    v3 = -1;
    result = sysctlbyname("kern.wq_limit_cooperative_threads", 0, 0, &v3, 4uLL);
    v8 = result;
    if ((_DWORD)result)
    {
      v11 = 1;
      v12 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v2 = **(int **)(StatusReg + 8);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to limit cooperative pool size";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x51494);
    }
  }
  return result;
}

uint64_t _dispatch_worker_thread2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  char v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v20;
  unsigned int v21;
  BOOL v22;
  char v23;
  int v24;
  uint64_t (***v25)();
  BOOL v26;
  BOOL v27;
  unint64_t v29;
  unint64_t v30;
  int v31;
  unint64_t v32;
  unint64_t v33;

  _dispatch_thread_setspecific(120, 0);
  v27 = (int)a1 < 0;
  v26 = (a1 & 0x8000000) != 0;
  v29 = a1 & 0xFFFFFFFF88FFFFFFLL;
  _dispatch_thread_setspecific(4, v29);
  v24 = 0;
  if (v26)
  {
    v23 = 4;
    v24 = 0x200000;
  }
  else
  {
    if (v27)
      v7 = 2;
    else
      v7 = 0;
    v23 = v7;
  }
  v30 = (v29 & 0x3FFF00) >> 8;
  v8 = __clz(__rbit32(v30));
  if ((_DWORD)v30)
    v9 = v8 + 1;
  else
    v9 = 0;
  v22 = 1;
  if (v9)
    v22 = v9 > 6;
  if (v22)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x51674);
  }
  v31 = 0;
  if ((v23 & 2) != 0)
  {
    v31 = 1;
  }
  else if ((v23 & 4) != 0)
  {
    v31 = 2;
  }
  v25 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v9 + v31 - 3)];
  v20 = (unsigned int *)(v25 + 14);
  v21 = *((_DWORD *)v25 + 28);
  do
  {
    v10 = v21;
    do
      v11 = __ldaxr(v20);
    while (v11 == v21 && __stlxr(v21 - 1, v20));
    v21 = v11;
  }
  while (v11 != v10);
  if ((int)(v11 - 1) < 0)
    _dispatch_abort(7396, 0, v1, v2, v3, v4, v5, v6);
  _dispatch_root_queue_drain((uint64_t)v25, *((_DWORD *)v25 + 21), v24 | 0x30000);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v12, v13, v14, v15, v16, v17, v18, 7400);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v32 = (unint64_t)_dispatch_thread_getspecific(4uLL);
    if ((v32 & 0x1000000) != 0)
      v33 = v32 & 0xFFFFFFFFFEFFFFFFLL;
    else
      v33 = 0;
  }
  else
  {
    v33 = 0;
  }
  if (v33 || _dispatch_thread_getspecific(0x1CuLL))
    _dispatch_set_priority_and_voucher_slow(v33, 0, 14);
  return _dispatch_thread_setspecific(120, 0);
}

void _dispatch_kevent_worker_thread(uint64_t *a1, unsigned int *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  _BOOL4 v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  unint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  BOOL v94;
  unsigned int *v95;
  unsigned int v96;
  BOOL v97;
  unint64_t v100;
  char v101;
  int v102;
  os_workgroup_s *wg;
  os_workgroup_join_token_opaque_s token_out;
  BOOL v105;
  char v106;
  uint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  __int128 v111;
  unsigned int *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  _BOOL8 v116;
  uint64_t v117;
  uint64_t v118;
  int v119;
  uint64_t v120;
  uint64_t v121;
  int v122;
  uint64_t v123;
  uint64_t v124;
  int v125;
  uint64_t v126;
  uint64_t (***v127)();
  int v128;
  uint64_t v129;
  uint64_t (***v130)();
  int v131;
  uint64_t v132;
  uint64_t v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t *v137;
  uint64_t (***v138)();
  unint64_t v139;
  uint64_t *v140;
  char v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t (***v151)();
  _BOOL4 v152;
  uint64_t v153;
  unint64_t *v154;
  _BOOL4 v155;
  uint64_t v156;
  unint64_t v157;
  uint64_t v158;
  uint64_t (***v159)();
  uint64_t v160;
  unint64_t v161;
  unsigned int v162;
  int v163;
  uint64_t v164;
  BOOL v165;
  uint64_t v166;
  uint64_t (***v167)();
  int v168;
  uint64_t v169;
  uint64_t v170;
  unsigned int v171;
  uint64_t v172;
  _BOOL8 v173;
  _BOOL4 v174;
  unint64_t *v175;
  _BOOL4 v176;
  unint64_t v177;
  unint64_t v178;
  uint64_t (***v179)();
  unint64_t v180;

  v97 = 0;
  if (a1)
    v97 = a2 != 0;
  if (v97)
  {
    if (*a2 && *a1)
    {
      v100 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL) & 0xFFFFFFFFFFFFFFFELL;
      if (v100 == -4)
      {
        v101 = 0;
      }
      else
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[anon]: set current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 825);
        if (v100)
        {
          v95 = (unsigned int *)(v100 + 96);
          v96 = *(_DWORD *)(v100 + 96);
          do
          {
            v15 = v96;
            do
              v16 = __ldaxr(v95);
            while (v16 == v96 && __stlxr(v96 - 1, v95));
            v96 = v16;
          }
          while (v16 != v15);
          if (((v16 - 1) & 0x80000000) != 0)
          {
            if ((int)(v16 - 1) <= -2)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
              __break(1u);
              JUMPOUT(0x51E58);
            }
            *(_QWORD *)(v100 + 56) = 0xDEAD000000000000;
            _dispatch_object_dealloc((_QWORD *)v100);
          }
        }
        _dispatch_thread_setspecific(27, -4);
        v101 = 1;
      }
      if ((v101 & 1) == 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
        __break(1u);
        JUMPOUT(0x51EC8);
      }
      v17 = *a1;
      v114 = -4;
      v113 = v17;
      v112 = a2;
      _dispatch_thread_setspecific(120, 0);
      v111 = 0u;
      v109 = 0;
      v107 = 0;
      v108 = 0;
      v110 = -4;
      *(_QWORD *)&v111 = v113;
      DWORD2(v111) = 0;
      WORD6(v111) = 0;
      v106 = 0;
      v105 = _dispatch_wlh_uses_bound_thread(-4);
      memset(&token_out, 0, sizeof(token_out));
      wg = 0;
      if (v105)
      {
        _dispatch_wlh_uses_bound_thread_setup(v114);
      }
      else
      {
        wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup((_QWORD *)v114);
        if (wg)
        {
          v102 = os_workgroup_join(wg, &token_out);
          if (v102 == 22)
          {
            _dispatch_thread_getspecific(0);
            _dispatch_log("%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p", v24, v25, v26, v27, v28, v29, v30, 6679);
            wg = 0;
          }
          else if (v102)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
            qword_E4DA8 = v102;
            __break(1u);
            JUMPOUT(0x5207CLL);
          }
        }
      }
      v140 = &v107;
      v150 = v110;
      v149 = 6518;
      if (!v110)
        _dispatch_abort(v149, 0, v18, v19, v20, v21, v22, v23);
      v139 = 0;
      v142 = 0;
      v142 = (uint64_t)_dispatch_thread_getspecific(4uLL);
      v139 = v142;
      if ((v142 & 0x2000000) != 0)
      {
        if ((v139 & 0x20000000) != 0)
        {
          v170 = v139;
          v139 = (unint64_t)BYTE3(v139) << 24;
        }
        v145 = v139;
        v144 = 0x1000000;
        v143 = 0;
        v139 &= ~0x1000000uLL;
        _dispatch_thread_setspecific(4, v139);
        v171 = 0x2000000;
        v44 = _dispatch_thread_getspecific(0x19uLL) == 0;
        v173 = v44;
        v172 = 2268;
        if (!v44)
          _dispatch_abort(v172, v173, v38, v39, v40, v41, v42, v43);
        v171 |= 0xF0000u;
        _dispatch_thread_setspecific(25, v171);
        v138 = &_dispatch_mgr_q;
        v151 = &_dispatch_mgr_q;
        _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
        v159 = &_dispatch_mgr_q;
        v158 = 0;
        v157 = 0;
        v156 = 0;
        v162 = _dispatch_thread_getspecific(3uLL);
        v156 = v162 & 0xFFFFFFFC | 0x40020000000000;
        v155 = 0;
        v154 = (unint64_t *)(v159 + 7);
        do
        {
          if (_os_atomic_mo_has_acquire(2))
            v45 = __ldaxr(v154);
          else
            v45 = __ldxr(v154);
          v158 = v45;
          v157 = v45;
          v161 = v45;
          v94 = 1;
          if (!(v45 >> 53))
          {
            v160 = v158;
            v163 = v158;
            v94 = (v158 & 0xFFFFFFFC) != 0;
          }
          if (v94)
          {
            v153 = v158;
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
            qword_E4DA8 = v158;
            __break(1u);
            JUMPOUT(0x523E8);
          }
          v157 &= 0x7700000001uLL;
          v157 |= v156;
          if (_os_atomic_mo_has_release(2))
            v155 = __stlxr(v157, v154) == 0;
          else
            v155 = __stxr(v157, v154) == 0;
        }
        while (!v155);
        v152 = v155;
        v141 = 1;
      }
      else
      {
        v148 = v139;
        v147 = 2013265919;
        v146 = 0;
        v139 &= 0xFFFFFFFF88FFFFFFLL;
        if (v140[3] == -4)
          v139 |= 0x1000000uLL;
        _dispatch_thread_setspecific(4, v139);
        if (v140[3] == -4)
        {
          *((_BYTE *)v140 + 44) = 1;
        }
        else
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\twlh[%p]: handling events", v31, v32, v33, v34, v35, v36, v37, 6538);
        }
        v141 = 0;
      }
      v106 = v141;
      if ((v141 & 1) != 0)
      {
        v47 = (int)*v112;
        v131 = 1;
        v130 = &_dispatch_mgr_q;
        v129 = v47;
        v110 = -4;
      }
      else
      {
        if (v114 == -4)
          v93 = 0;
        else
          v93 = v114;
        v46 = (int)*v112;
        v134 = 1;
        v133 = v93;
        v132 = v46;
      }
      v137 = &v107;
      _dispatch_thread_setspecific(29, (uint64_t)&v107);
      _dispatch_event_loop_merge(v113, *v112);
      if ((v106 & 1) != 0)
      {
        v128 = 2;
        v127 = &_dispatch_mgr_q;
        v126 = 0;
        _dispatch_mgr_queue_drain();
        if (byte_E4E16)
          _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v48, v49, v50, v51, v52, v53);
        v165 = 0;
        v179 = &_dispatch_mgr_q;
        v178 = 0;
        v177 = 0;
        v176 = 0;
        v175 = (unint64_t *)&qword_E4178;
        do
        {
          if (_os_atomic_mo_has_acquire(3))
            v54 = __ldaxr(v175);
          else
            v54 = __ldxr(v175);
          v178 = v54;
          v177 = (v54 - 0x40020000000000) & 0xFFFFFFF000000001;
          if (_os_atomic_mo_has_release(3))
            v176 = __stlxr(v177, v175) == 0;
          else
            v176 = __stxr(v177, v175) == 0;
        }
        while (!v176);
        v174 = v176;
        v180 = v178;
        v165 = (v178 & 0x8000000000) != 0;
        _dispatch_thread_setspecific(25, 0);
        v164 = 0;
        v169 = 0;
        _dispatch_thread_setspecific(20, 0);
        if (v165)
        {
          v168 = 3;
          v167 = &_dispatch_mgr_q;
          v166 = 1;
          _dispatch_event_loop_poke((unsigned int *)0xFFFFFFFFFFFFFFF8, 0, 0, v55, v56, v57, v58, v59);
        }
      }
      else if (v108)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v60, v61, v62, v63, v64, v65, v66, 6708);
        if (v110 == -4)
        {
          v116 = WORD4(v111) == 0;
          v115 = 6710;
          if (WORD4(v111))
            _dispatch_abort(v115, v116, v67, v68, v69, v70, v71, v72);
          v136 = 0;
          _dispatch_thread_setspecific(29, 0);
          v125 = 2;
          v124 = v107;
          v123 = 0;
          _dispatch_root_queue_drain_deferred_item(&v107);
        }
        else
        {
          v122 = 2;
          v121 = v114;
          v120 = 0;
          _dispatch_root_queue_drain_deferred_wlh(&v107);
        }
      }
      if (!v105 && wg)
        os_workgroup_leave(wg, &token_out);
      v135 = 0;
      _dispatch_thread_setspecific(29, 0);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\treturning %d deferred kevents", v73, v74, v75, v76, v77, v78, v79, 6735);
      _dispatch_thread_setspecific(5, 0);
      _dispatch_thread_setspecific(120, 0);
      *v112 = WORD4(v111);
      v119 = 4;
      v118 = 0;
      v117 = 0;
      if (_dispatch_thread_getspecific(0x1BuLL) != (void *)-4)
        _dispatch_abort(871, 0, v80, v81, v82, v83, v84, v85);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\twlh[anon]: clear current", v86, v87, v88, v89, v90, v91, v92, 872);
      _dispatch_thread_setspecific(27, 0);
      _dispatch_thread_setspecific(5, 0);
    }
  }
  else
  {
    _dispatch_bug(6755, v97, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_workloop_worker_thread(_QWORD *a1, uint64_t *a2, unsigned int *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  _BOOL4 v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  unint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t v98;
  uint64_t v99;
  _BOOL4 v100;
  void *v101;
  _QWORD *v102;
  BOOL v103;
  unsigned int *v104;
  unsigned int v105;
  unsigned int *v106;
  unsigned int v107;
  BOOL v108;
  _QWORD *v109;
  _BOOL4 v110;
  int v114;
  os_workgroup_s *wg;
  os_workgroup_join_token_opaque_s token_out;
  BOOL v117;
  char v118;
  uint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  __int128 v123;
  unsigned int *v124;
  uint64_t v125;
  _QWORD *v126;
  uint64_t v127;
  _BOOL8 v128;
  uint64_t v129;
  uint64_t v130;
  int v131;
  uint64_t v132;
  _QWORD *v133;
  int v134;
  uint64_t v135;
  uint64_t v136;
  int v137;
  uint64_t v138;
  uint64_t (***v139)();
  int v140;
  uint64_t v141;
  uint64_t (***v142)();
  int v143;
  uint64_t v144;
  _QWORD *v145;
  int v146;
  uint64_t v147;
  uint64_t v148;
  uint64_t *v149;
  uint64_t (***v150)();
  unint64_t v151;
  uint64_t *v152;
  char v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  uint64_t v158;
  uint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  uint64_t (***v163)();
  _BOOL4 v164;
  uint64_t v165;
  unint64_t *v166;
  _BOOL4 v167;
  uint64_t v168;
  unint64_t v169;
  uint64_t v170;
  uint64_t (***v171)();
  uint64_t v172;
  unint64_t v173;
  unsigned int v174;
  int v175;
  uint64_t v176;
  BOOL v177;
  uint64_t v178;
  uint64_t (***v179)();
  int v180;
  uint64_t v181;
  uint64_t v182;
  unsigned int v183;
  uint64_t v184;
  _BOOL8 v185;
  _BOOL4 v186;
  unint64_t *v187;
  _BOOL4 v188;
  unint64_t v189;
  unint64_t v190;
  uint64_t (***v191)();
  unint64_t v192;
  unint64_t v193;
  _QWORD *v194;
  uint64_t v195;
  uint64_t v196;
  unint64_t v197;
  unint64_t v198;
  unint64_t v199;
  _QWORD *v200;
  unsigned int v201;
  unsigned int v202;
  int v203;
  int v204;
  int v205;
  unsigned int v206;
  unsigned int v207;
  int v208;
  int v209;
  int v210;
  int v211;
  _QWORD *v212;
  unint64_t v213;
  uint64_t v214;
  _BOOL8 v215;
  uint64_t v216;
  _BOOL8 v217;
  uint64_t v218;
  uint64_t v219;
  unsigned int v220;
  unsigned int v221;
  int v222;
  int v223;
  int v224;
  unsigned int v225;
  unsigned int v226;
  int v227;
  int v228;
  int v229;
  unsigned int v230;
  uint64_t v231;

  v108 = 0;
  if (a1)
  {
    v108 = 0;
    if (a2)
      v108 = a3 != 0;
  }
  if (v108)
  {
    v110 = *a1 != 0;
    if (!*a1)
      _dispatch_bug(6777, *a1 != 0, (uint64_t)a3, a4, a5, a6, a7, a8);
    if (v110)
    {
      if (*a3 && *a2)
      {
        v109 = (_QWORD *)*a1;
        v194 = (_QWORD *)*a1;
        v197 = (unint64_t)_dispatch_thread_getspecific(0x1BuLL);
        v193 = v197 & 0xFFFFFFFFFFFFFFFELL;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\twlh[%p]: adopt current (releasing %p)", v8, v9, v10, v11, v12, v13, v14, 845);
        if ((v197 & 0xFFFFFFFFFFFFFFFELL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Lingering DISPATCH_WLH_ANON";
          __break(1u);
          JUMPOUT(0x52B4CLL);
        }
        if (v193 != (_QWORD)v194)
        {
          v196 = (uint64_t)v194;
          v195 = 850;
          if (!v194)
            _dispatch_abort(v195, 0, v15, v16, v17, v18, v19, v20);
          v199 = v193;
          if (v193)
          {
            v198 = v199;
            v212 = (_QWORD *)v199;
            v211 = 0;
            v209 = 1;
            v208 = 1;
            v210 = 1;
            v206 = 0;
            v204 = 1;
            v203 = 1;
            v205 = 1;
            v106 = (unsigned int *)(v199 + 96);
            v107 = *(_DWORD *)(v199 + 96);
            do
            {
              v21 = v107;
              do
                v22 = __ldaxr(v106);
              while (v22 == v107 && __stlxr(v107 - 1, v106));
              v107 = v22;
            }
            while (v22 != v21);
            v202 = v22;
            v206 = v22;
            v201 = v22;
            v207 = v22 - v210;
            v211 = v22 - v210;
            if (((v22 - v210) & 0x80000000) != 0)
            {
              if (v211 <= -2)
              {
                qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
                __break(1u);
                JUMPOUT(0x52CD4);
              }
              v212[7] = 0xDEAD000000000000;
              v200 = v212;
              _dispatch_object_dealloc(v212);
            }
          }
          v219 = (uint64_t)v194;
          if (v194 && v219 != -4)
          {
            v218 = v219;
            v231 = v219;
            v230 = 0;
            v228 = 1;
            v227 = 1;
            v229 = 1;
            v225 = 0;
            v223 = 1;
            v222 = 1;
            v224 = 1;
            v104 = (unsigned int *)(v219 + 96);
            v105 = *(_DWORD *)(v219 + 96);
            do
            {
              v23 = v105;
              do
                v24 = __ldaxr(v104);
              while (v24 == v105 && __stlxr(v105 + 1, v104));
              v105 = v24;
            }
            while (v24 != v23);
            v221 = v24;
            v225 = v24;
            v220 = v24;
            v226 = v24 + v229;
            v230 = v24 + v229;
            if ((int)(v24 + v229) <= 0)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
              __break(1u);
              JUMPOUT(0x52E34);
            }
          }
        }
        _dispatch_thread_setspecific(27, (uint64_t)v194);
        v25 = *a2;
        v126 = v109;
        v125 = v25;
        v124 = a3;
        _dispatch_thread_setspecific(120, 0);
        v123 = 0u;
        v121 = 0;
        v119 = 0;
        v120 = 0;
        v122 = (uint64_t)v109;
        *(_QWORD *)&v123 = v125;
        DWORD2(v123) = 0;
        WORD6(v123) = 0;
        v118 = 0;
        v117 = _dispatch_wlh_uses_bound_thread((uint64_t)v109);
        memset(&token_out, 0, sizeof(token_out));
        wg = 0;
        if (v117)
        {
          _dispatch_wlh_uses_bound_thread_setup((uint64_t)v126);
        }
        else
        {
          wg = (os_workgroup_s *)_dispatch_wlh_get_workgroup(v126);
          if (wg)
          {
            v114 = os_workgroup_join(wg, &token_out);
            if (v114 == 22)
            {
              _dispatch_thread_getspecific(0);
              _dispatch_log("%u\t%p\twlh[%p]: Failed to join cancelled workgroup %p", v32, v33, v34, v35, v36, v37, v38, 6679);
              wg = 0;
            }
            else if (v114)
            {
              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_workloop os_workgroup_join failed";
              qword_E4DA8 = v114;
              __break(1u);
              JUMPOUT(0x52FFCLL);
            }
          }
        }
        v152 = &v119;
        v162 = v122;
        v161 = 6518;
        if (!v122)
          _dispatch_abort(v161, 0, v26, v27, v28, v29, v30, v31);
        v151 = 0;
        v154 = 0;
        v154 = (uint64_t)_dispatch_thread_getspecific(4uLL);
        v151 = v154;
        if ((v154 & 0x2000000) != 0)
        {
          if ((v151 & 0x20000000) != 0)
          {
            v182 = v151;
            v151 = (unint64_t)BYTE3(v151) << 24;
          }
          v157 = v151;
          v156 = 0x1000000;
          v155 = 0;
          v151 &= ~0x1000000uLL;
          _dispatch_thread_setspecific(4, v151);
          v183 = 0x2000000;
          v52 = _dispatch_thread_getspecific(0x19uLL) == 0;
          v185 = v52;
          v184 = 2268;
          if (!v52)
            _dispatch_abort(v184, v185, v46, v47, v48, v49, v50, v51);
          v183 |= 0xF0000u;
          _dispatch_thread_setspecific(25, v183);
          v150 = &_dispatch_mgr_q;
          v163 = &_dispatch_mgr_q;
          _dispatch_thread_setspecific(20, (uint64_t)&_dispatch_mgr_q);
          v171 = &_dispatch_mgr_q;
          v170 = 0;
          v169 = 0;
          v168 = 0;
          v174 = _dispatch_thread_getspecific(3uLL);
          v168 = v174 & 0xFFFFFFFC | 0x40020000000000;
          v167 = 0;
          v166 = (unint64_t *)(v171 + 7);
          do
          {
            if (_os_atomic_mo_has_acquire(2))
              v53 = __ldaxr(v166);
            else
              v53 = __ldxr(v166);
            v170 = v53;
            v169 = v53;
            v173 = v53;
            v103 = 1;
            if (!(v53 >> 53))
            {
              v172 = v170;
              v175 = v170;
              v103 = (v170 & 0xFFFFFFFC) != 0;
            }
            if (v103)
            {
              v165 = v170;
              qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Locking the manager should not fail";
              qword_E4DA8 = v170;
              __break(1u);
              JUMPOUT(0x53368);
            }
            v169 &= 0x7700000001uLL;
            v169 |= v168;
            if (_os_atomic_mo_has_release(2))
              v167 = __stlxr(v169, v166) == 0;
            else
              v167 = __stxr(v169, v166) == 0;
          }
          while (!v167);
          v164 = v167;
          v153 = 1;
        }
        else
        {
          v160 = v151;
          v159 = 2013265919;
          v158 = 0;
          v151 &= 0xFFFFFFFF88FFFFFFLL;
          if (v152[3] == -4)
            v151 |= 0x1000000uLL;
          _dispatch_thread_setspecific(4, v151);
          if (v152[3] == -4)
          {
            *((_BYTE *)v152 + 44) = 1;
          }
          else
          {
            _dispatch_thread_getspecific(0);
            _dispatch_log("%u\t%p\twlh[%p]: handling events", v39, v40, v41, v42, v43, v44, v45, 6538);
          }
          v153 = 0;
        }
        v118 = v153;
        if ((v153 & 1) != 0)
        {
          v55 = (int)*v124;
          v143 = 1;
          v142 = &_dispatch_mgr_q;
          v141 = v55;
          v122 = -4;
        }
        else
        {
          if (v126 == (_QWORD *)-4)
            v102 = 0;
          else
            v102 = v126;
          v54 = (int)*v124;
          v146 = 1;
          v145 = v102;
          v144 = v54;
        }
        v149 = &v119;
        _dispatch_thread_setspecific(29, (uint64_t)&v119);
        _dispatch_event_loop_merge(v125, *v124);
        if ((v118 & 1) != 0)
        {
          v140 = 2;
          v139 = &_dispatch_mgr_q;
          v138 = 0;
          _dispatch_mgr_queue_drain();
          if (byte_E4E16)
            _dispatch_event_loop_drain_timers((uint64_t)&_dispatch_timers_heap, 9u, v56, v57, v58, v59, v60, v61);
          v177 = 0;
          v191 = &_dispatch_mgr_q;
          v190 = 0;
          v189 = 0;
          v188 = 0;
          v187 = (unint64_t *)&qword_E4178;
          do
          {
            if (_os_atomic_mo_has_acquire(3))
              v62 = __ldaxr(v187);
            else
              v62 = __ldxr(v187);
            v190 = v62;
            v189 = (v62 - 0x40020000000000) & 0xFFFFFFF000000001;
            if (_os_atomic_mo_has_release(3))
              v188 = __stlxr(v189, v187) == 0;
            else
              v188 = __stxr(v189, v187) == 0;
          }
          while (!v188);
          v186 = v188;
          v192 = v190;
          v177 = (v190 & 0x8000000000) != 0;
          _dispatch_thread_setspecific(25, 0);
          v176 = 0;
          v181 = 0;
          _dispatch_thread_setspecific(20, 0);
          if (v177)
          {
            v180 = 3;
            v179 = &_dispatch_mgr_q;
            v178 = 1;
            _dispatch_event_loop_poke((unsigned int *)0xFFFFFFFFFFFFFFF8, 0, 0, v63, v64, v65, v66, v67);
          }
        }
        else if (v120)
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\twlh[%p]: draining deferred item %p", v68, v69, v70, v71, v72, v73, v74, 6708);
          if (v122 == -4)
          {
            v128 = WORD4(v123) == 0;
            v127 = 6710;
            if (WORD4(v123))
              _dispatch_abort(v127, v128, v75, v76, v77, v78, v79, v80);
            v148 = 0;
            _dispatch_thread_setspecific(29, 0);
            v137 = 2;
            v136 = v119;
            v135 = 0;
            _dispatch_root_queue_drain_deferred_item(&v119);
          }
          else
          {
            v134 = 2;
            v133 = v126;
            v132 = 0;
            _dispatch_root_queue_drain_deferred_wlh(&v119);
          }
        }
        if (!v117 && wg)
          os_workgroup_leave(wg, &token_out);
        v147 = 0;
        _dispatch_thread_setspecific(29, 0);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\treturning %d deferred kevents", v81, v82, v83, v84, v85, v86, v87, 6735);
        _dispatch_thread_setspecific(5, 0);
        _dispatch_thread_setspecific(120, 0);
        *v124 = WORD4(v123);
        v131 = 4;
        v130 = 0;
        v129 = 0;
        v213 = (unint64_t)v109;
        v217 = (_QWORD *)((char *)v109 + 4) != 0;
        v216 = 861;
        if (v109 == (_QWORD *)-4)
          _dispatch_abort(v216, v217, v88, v89, v90, v91, v92, v93);
        v101 = (void *)v213;
        v100 = v101 == _dispatch_thread_getspecific(0x1BuLL);
        v215 = v100;
        v214 = 862;
        if (!v100)
          _dispatch_abort(v214, v215, v94, v95, v96, v97, v98, v99);
        _dispatch_thread_setspecific(27, v213 | 1);
      }
    }
    else
    {
      _dispatch_kevent_worker_thread(a2, a3, (uint64_t)a3, a4, a5, a6, a7, a8);
    }
  }
  else
  {
    _dispatch_bug(6774, v108, (uint64_t)a3, a4, a5, a6, a7, a8);
  }
}

BOOL _dispatch_wlh_uses_bound_thread(uint64_t a1)
{
  return a1 != -4 && *(_QWORD *)(*(_QWORD *)a1 + 16) == 131090 && _dispatch_workloop_uses_bound_thread(a1);
}

uint64_t _dispatch_wlh_uses_bound_thread_setup(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;

  v2 = result;
  if (*(_QWORD *)(result + 72))
  {
    result = (uint64_t)_dispatch_thread_getspecific(0x7CuLL);
    if (!result)
    {
      pthread_setname_np(*(const char **)(v2 + 72));
      result = _dispatch_thread_setspecific(124, 1);
    }
  }
  if (*(_QWORD *)(v2 + 200) && *(_QWORD *)(*(_QWORD *)(v2 + 200) + 32))
  {
    result = (uint64_t)_dispatch_thread_getspecific(0x73uLL);
    if (!result)
    {
      v1 = _dispatch_calloc(1, 40);
      _os_workgroup_join_update_wg(*(_QWORD *)(*(_QWORD *)(v2 + 200) + 32), v1);
      return _dispatch_thread_setspecific(115, v1);
    }
  }
  return result;
}

uint64_t _dispatch_wlh_get_workgroup(_QWORD *a1)
{
  uint64_t v2;

  v2 = 0;
  if (a1 != (_QWORD *)-4 && *(_QWORD *)(*a1 + 16) == 131090 && a1[25])
    return *(_QWORD *)(a1[25] + 32);
  return v2;
}

void _dispatch_root_queue_drain_deferred_item(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void *v14;
  uint64_t v15;
  _OWORD v16[2];
  uint64_t v17;
  uint64_t v18;
  uint64_t *v19;
  uint64_t v20;
  uint64_t v21;
  BOOL v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void *object;
  void *v28;
  uint64_t v29;
  uint64_t v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  unint64_t v36;
  uint64_t v37;
  uint64_t v38;
  void *v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  uint64_t v43;
  uint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  unsigned int v51;
  uint64_t v52;
  _BOOL8 v53;

  v19 = a1;
  v18 = 0;
  v18 = *a1;
  v17 = v18;
  v33 = v18;
  _dispatch_thread_setspecific(20, v18);
  v31 = 2;
  v30 = 0;
  v29 = 0;
  memset(v16, 0, sizeof(v16));
  _dispatch_last_resort_autorelease_pool_push((uint64_t)v16);
  v51 = *(_DWORD *)(v18 + 84);
  v53 = _dispatch_thread_getspecific(0x19uLL) == 0;
  v52 = 2256;
  if (!v53)
    _dispatch_abort(v52, 0, v1, v2, v3, v4, v5, v6);
  _dispatch_thread_setspecific(25, v51);
  _dispatch_continuation_pop_inline((_QWORD *)v19[1], (uint64_t)v16, 196608, v18);
  _dispatch_last_resort_autorelease_pool_pop((uint64_t)v16);
  _dispatch_thread_setspecific(25, 0);
  v32 = 0;
  _dispatch_thread_setspecific(20, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v7, v8, v9, v10, v11, v12, v13, 7301);
  v21 = 0;
  v20 = 14;
  v25 = 0;
  v24 = 0;
  v23 = 14;
  v37 = 0;
  v50 = 1;
  v49 = 2332;
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v48 = v37;
    v47 = 4261412863;
    v46 = 0;
    v37 &= 0xFFFFFFFF02FFFFFFLL;
    v36 = 0;
    v39 = 0;
    v39 = _dispatch_thread_getspecific(4uLL);
    v36 = (unint64_t)v39;
    v35 = 0x1000000;
    v34 = 2281701376;
    if ((v39 & 0x1000000) != 0)
    {
      if (v37)
      {
        v15 = v37;
      }
      else
      {
        v45 = v36;
        v44 = v35;
        v43 = 0;
        v15 = v36 & (~v35 | 0xFFFFFF);
      }
      v38 = v15;
    }
    else
    {
      v42 = v36;
      v41 = v34;
      v40 = 0;
      v36 &= ~v34 | 0xFFFFFF;
      if (v37 == v36)
        v38 = 0;
      else
        v38 = v37;
    }
  }
  else
  {
    v38 = 0;
  }
  v25 = v38;
  if (v38)
    goto LABEL_26;
  if (v24 == -1)
  {
    v26 = -1;
    return;
  }
  v14 = (void *)v24;
  if (v14 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_26:
    _dispatch_set_priority_and_voucher_slow(v25, (_DWORD *)v24, v23);
  }
  else
  {
    v22 = (v23 & 4) != 0;
    if ((v23 & 2) != 0)
    {
      if (v22)
      {
        if (v24)
        {
          object = (void *)v24;
          os_release((void *)v24);
        }
      }
      v24 = -1;
    }
    else if (!v22 && v24)
    {
      v28 = (void *)v24;
      os_retain((void *)v24);
    }
    v26 = v24;
  }
}

void _dispatch_root_queue_drain_deferred_wlh(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  void *v34;
  uint64_t v35;
  BOOL v36;
  int v37;
  unint64_t v38;
  unsigned int v39;
  _OWORD v40[2];
  uint64_t v41;
  _QWORD *v42;
  uint64_t v43;
  uint64_t *v44;
  uint64_t v45;
  uint64_t v46;
  BOOL v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  void *object;
  void *v53;
  int v54;
  int v55;
  _QWORD *v56;
  uint64_t v57;
  unint64_t v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  uint64_t v63;
  _BOOL8 v64;
  uint64_t v65;
  _BOOL8 v66;
  uint64_t v67;
  _BOOL8 v68;
  uint64_t v69;
  uint64_t v70;
  int v71;
  int v72;
  _QWORD *v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  uint64_t v81;
  void *v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  uint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  _QWORD *v94;
  uint64_t v95;
  int v96;
  unint64_t v97;
  _QWORD *v98;
  uint64_t v99;
  unsigned int v100;
  uint64_t v101;
  _BOOL8 v102;
  uint64_t v103;
  _BOOL4 v104;
  unint64_t *v105;
  _BOOL4 v106;
  uint64_t v107;
  unint64_t v108;
  uint64_t v109;
  unint64_t *v110;
  _QWORD *v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unsigned int v118;
  uint64_t v119;
  int v120;
  int v121;
  uint64_t v122;

  v44 = a1;
  v43 = 0;
  v43 = *a1;
  v42 = 0;
  v42 = (_QWORD *)a1[1];
  v41 = v43;
  v76 = v43;
  _dispatch_thread_setspecific(20, v43);
  memset(v40, 0, sizeof(v40));
  v39 = 196610;
  v38 = 0;
  v100 = *(_DWORD *)(v43 + 84);
  v7 = _dispatch_thread_getspecific(0x19uLL) == 0;
  v102 = v7;
  v101 = 2268;
  if (!v7)
    _dispatch_abort(v101, v102, v1, v2, v3, v4, v5, v6);
  v100 |= 0xF0000u;
  _dispatch_thread_setspecific(25, v100);
  *((_BYTE *)v44 + 45) |= 4u;
  while (2)
  {
    v70 = *((_BYTE *)v44 + 45) & 1;
    v69 = 7189;
    if (!v70)
      _dispatch_abort(v69, 0, v8, v9, v10, v11, v12, v13);
    v74 = v43;
    v73 = v42;
    v72 = 0;
    v71 = 0;
    v99 = v43;
    v98 = v42;
    v111 = v42;
    v110 = &v38;
    v109 = 0;
    v108 = 0;
    v107 = 0;
    v118 = _dispatch_thread_getspecific(3uLL);
    v107 = v118 & 0xFFFFFFFC | 0x60000000000000;
    v106 = 0;
    v105 = v111 + 7;
    while (1)
    {
      v20 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v105) : __ldxr(v105);
      v109 = v20;
      v108 = v20;
      v114 = v20;
      if ((v20 & 0xFF80000000000000) == 0)
        break;
      v108 &= ~1uLL;
LABEL_17:
      if (_os_atomic_mo_has_release(2))
        v106 = __stlxr(v108, v105) == 0;
      else
        v106 = __stxr(v108, v105) == 0;
      if (v106)
        goto LABEL_21;
    }
    v116 = v109;
    v120 = v109;
    if ((v109 & 0xFFFFFFFC) == 0)
    {
      v108 &= 0x7700000001uLL;
      v108 |= v107;
      goto LABEL_17;
    }
    v119 = v109;
    if ((v109 & 2) != 0)
    {
      v108 |= 0x800000000uLL;
      goto LABEL_17;
    }
    __clrex();
LABEL_21:
    v104 = v106;
    v112 = v109;
    LOBYTE(v37) = 1;
    if ((v109 & 0x2000000000) != 0)
    {
      v122 = v109;
      LOBYTE(v37) = 1;
      if ((v109 & 1) != 0)
      {
        v117 = v109;
        v37 = (BYTE4(v109) >> 6) & 1;
      }
    }
    if ((v37 & 1) != 0)
    {
      v103 = v109;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh state";
      qword_E4DA8 = v109;
      __break(1u);
      JUMPOUT(0x545D0);
    }
    if (v110)
      *v110 = v108;
    v113 = v109;
    v36 = 0;
    if ((v109 & 0xFF80000000000000) == 0)
    {
      v115 = v109;
      v121 = v109;
      v36 = (v109 & 0xFFFFFFFC) == 0;
    }
    if (!v36)
    {
      v59 = v38;
      if ((v38 & 0xFF80000000000000) != 0)
      {
        v62 = v38;
        v68 = (v38 & 0x4000000001) == 0;
        v67 = 7253;
        if ((v38 & 0x4000000001) != 0)
          _dispatch_abort(v67, v68, v14, v15, v16, v17, v18, v19);
        _dispatch_release_2_no_dispose((uint64_t)v42);
      }
      else
      {
        v61 = v38;
        v66 = (v38 & 0x4000000001) != 0;
        v65 = 7256;
        if ((v38 & 0x4000000001) == 0)
          _dispatch_abort(v65, v66, v14, v15, v16, v17, v18, v19);
        v60 = v38;
        v96 = v38;
        v64 = (v38 & 0xFFFFFFFC) != 0;
        v63 = 7257;
        if ((v38 & 0xFFFFFFFC) == 0)
          _dispatch_abort(v63, v64, v14, v15, v16, v17, v18, v19);
        _dispatch_release_no_dispose((uint64_t)v42);
      }
      goto LABEL_45;
    }
    (*(void (**)(_QWORD *, _OWORD *, _QWORD))(*v42 + 48))(v42, v40, v39);
    if ((*((_BYTE *)v44 + 45) & 1) != 0)
    {
      v38 = v42[7];
      v58 = v38;
      if (((BYTE4(v38) >> 5) & 1) != 0)
      {
        v97 = v38;
        if ((v38 & 1) != 0)
        {
          _dispatch_retain((uint64_t)v42);
          v57 = v42[3];
          v56 = v42;
          v55 = 0;
          v54 = 0;
          v95 = v57;
          v94 = v42;
          continue;
        }
LABEL_45:
        _dispatch_event_loop_leave_deferred((uint64_t)v44, v38, v21, v22, v23, v24, v25, v26);
      }
    }
    break;
  }
  _dispatch_thread_setspecific(25, 0);
  v75 = 0;
  _dispatch_thread_setspecific(20, 0);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: root queue clear", v27, v28, v29, v30, v31, v32, v33, 7270);
  v46 = 0;
  v45 = 14;
  v50 = 0;
  v49 = 0;
  v48 = 14;
  v80 = 0;
  v93 = 1;
  v92 = 2332;
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v91 = v80;
    v90 = 4261412863;
    v89 = 0;
    v80 &= 0xFFFFFFFF02FFFFFFLL;
    v79 = 0;
    v82 = 0;
    v82 = _dispatch_thread_getspecific(4uLL);
    v79 = (unint64_t)v82;
    v78 = 0x1000000;
    v77 = 2281701376;
    if ((v82 & 0x1000000) != 0)
    {
      if (v80)
      {
        v35 = v80;
      }
      else
      {
        v88 = v79;
        v87 = v78;
        v86 = 0;
        v35 = v79 & (~v78 | 0xFFFFFF);
      }
      v81 = v35;
    }
    else
    {
      v85 = v79;
      v84 = v77;
      v83 = 0;
      v79 &= ~v77 | 0xFFFFFF;
      if (v80 == v79)
        v81 = 0;
      else
        v81 = v80;
    }
  }
  else
  {
    v81 = 0;
  }
  v50 = v81;
  if (v81)
    goto LABEL_69;
  if (v49 == -1)
  {
    v51 = -1;
    return;
  }
  v34 = (void *)v49;
  if (v34 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_69:
    v51 = _dispatch_set_priority_and_voucher_slow(v50, (_DWORD *)v49, v48);
  }
  else
  {
    v47 = (v48 & 4) != 0;
    if ((v48 & 2) != 0)
    {
      if (v47 && v49)
      {
        object = (void *)v49;
        os_release((void *)v49);
      }
      v49 = -1;
    }
    else if (!v47 && v49)
    {
      v53 = (void *)v49;
      os_retain((void *)v49);
    }
    v51 = v49;
  }
}

void _dispatch_queue_cleanup2()
{
  unint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int v9;
  int v10;
  pthread_t v11[3];
  _BOOL4 v12;
  unint64_t *v13;
  _BOOL4 v14;
  unint64_t v15;
  unint64_t v16;
  dispatch_queue_s *v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  int v24;
  int v25;
  int v26;
  int v27;
  int v28;
  dispatch_queue_s *v29;
  dispatch_function_t v30;
  dispatch_queue_s *v31;
  dispatch_once_t *v32;
  pthread_attr_t v33;

  v17 = &_dispatch_main_q;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = (unint64_t *)&dword_E4078;
  do
  {
    if (_os_atomic_mo_has_acquire(2))
      v0 = __ldaxr(v13);
    else
      v0 = __ldxr(v13);
    v16 = v0;
    v15 = (v0 & 0xFFFFFF7FFFFFFFFFLL) + 0x40020000000000;
    if (_os_atomic_mo_has_release(2))
      v14 = __stlxr(v15, v13) == 0;
    else
      v14 = __stxr(v15, v13) == 0;
  }
  while (!v14);
  v12 = v14;
  v11[2] = (pthread_t)v17;
  v29 = v17;
  v28 = 0x40000;
  v26 = -262145;
  v25 = -262145;
  v27 = -262145;
  v23 = 0;
  v21 = -262145;
  v20 = -262145;
  v22 = -262145;
  v8 = (unsigned int *)((char *)v17 + 80);
  v9 = *((_DWORD *)v17 + 20);
  do
  {
    v6 = v9;
    do
      v7 = __ldaxr(v8);
    while (v7 == v9 && __stlxr(v9 & 0xFFFBFFFF, v8));
    v9 = v7;
  }
  while (v7 != v6);
  v19 = v7;
  v23 = v7;
  v18 = v7;
  v24 = v7 & v27;
  v11[1] = (pthread_t)v17;
  _dispatch_lane_barrier_complete((uint64_t)v17, 0, 0, v1, v2, v3, v4, v5);
  if ((_dispatch_program_is_probably_callback_driven & 1) != 0)
  {
    memset(&v33, 0, sizeof(v33));
    pthread_attr_init(&v33);
    pthread_attr_setdetachstate(&v33, 2);
    v11[0] = 0;
    v10 = pthread_create(v11, &v33, (void *(__cdecl *)(void *))_dispatch_sig_thread, 0);
    if (v10)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to create signal thread";
      qword_E4DA8 = v10;
      __break(1u);
      JUMPOUT(0x550E8);
    }
    pthread_attr_destroy(&v33);
    sleep_NOCANCEL(1);
  }
  v32 = &_dispatch_main_q_handle_pred;
  v31 = v17;
  v30 = (dispatch_function_t)_dispatch_runloop_queue_handle_init;
  if (_dispatch_main_q_handle_pred != -1)
    dispatch_once_f(v32, v31, v30);
  _dispatch_runloop_queue_handle_dispose((mach_port_context_t)v17);
}

void _dispatch_sig_thread(uint64_t a1)
{
  _opaque_pthread_t *v1;
  _BYTE *stackaddr_np;
  uint64_t v3;

  v3 = a1;
  stackaddr_np = 0;
  v1 = pthread_self();
  stackaddr_np = pthread_get_stackaddr_np(v1);
  __memset_chk(&v3, 0, stackaddr_np - (_BYTE *)&v3, -1);
  _dispatch_sigsuspend();
}

void _dispatch_sigsuspend()
{
  pthread_sigmask(3, _dispatch_sigsuspend_mask, 0);
  while (1)
    sigsuspend_NOCANCEL(_dispatch_sigsuspend_mask);
}

void _dispatch_apply_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _QWORD v17[3];
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL8 v29;
  void (*v30)();
  void *v31;
  dispatch_once_t *v32;
  dispatch_function_t v33;
  _QWORD *v34;
  dispatch_once_t *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  int v39;
  _DWORD *v40;
  uint64_t v41;
  _QWORD *v42;

  v27 = a1;
  v26 = 0;
  i = 0;
  v24 = 0;
  v23 = 0;
  v21 = 1;
  v20 = 1;
  v22 = 1;
  v16 = *(_DWORD *)(a1 + 52);
  do
  {
    v8 = v16;
    v9 = (unsigned int *)(a1 + 52);
    do
      v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    v16 = v10;
  }
  while (v10 != v8);
  v19 = v10;
  v23 = v10;
  v18 = v10;
  v24 = v10;
  v29 = v10 < *(_DWORD *)(v27 + 48);
  v28 = 210;
  if (!v29)
    _dispatch_abort(v28, 0, a3, a4, a5, a6, a7, a8);
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  v35 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * v24);
  v34 = v17;
  v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1)
    dispatch_once_f(v35, v34, v33);
  _dispatch_apply_clear_attr_behavior(*(_QWORD *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        v32 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * i);
        v31 = 0;
        v30 = _dispatch_no_op;
        if (*v32 != -1)
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
      }
    }
  }
  v14 = (unsigned int *)(v27 + 44);
  v15 = *(_DWORD *)(v27 + 44);
  do
  {
    v11 = v15;
    do
      v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    v15 = v12;
  }
  while (v12 != v11);
  if (v12 == 1)
  {
    v36 = v27;
    if (*(_QWORD *)(v27 + 32))
      free(*(void **)(v36 + 32));
    if (*(_QWORD *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(_QWORD *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }
    v37 = v36;
    v38 = (_QWORD *)v36;
    v41 = v36;
    v40 = 0;
    v40 = _dispatch_thread_getspecific(0x16uLL);
    v39 = 0;
    if (v40)
      v13 = v40[2] + 1;
    else
      v13 = 1;
    v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22, v41);
      v42 = 0;
    }
    else
    {
      v42 = (_QWORD *)v41;
    }
    v38 = v42;
    if (v42)
      _dispatch_continuation_free_to_cache_limit(v38);
  }
}

void _dispatch_apply_redirect_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _QWORD v17[3];
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL8 v29;
  void (*v30)();
  void *v31;
  dispatch_once_t *v32;
  dispatch_function_t v33;
  _QWORD *v34;
  dispatch_once_t *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  int v39;
  _DWORD *v40;
  uint64_t v41;
  _QWORD *v42;

  v27 = a1;
  v26 = 1;
  i = 0;
  v24 = 0;
  v23 = 0;
  v21 = 1;
  v20 = 1;
  v22 = 1;
  v16 = *(_DWORD *)(a1 + 52);
  do
  {
    v8 = v16;
    v9 = (unsigned int *)(a1 + 52);
    do
      v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    v16 = v10;
  }
  while (v10 != v8);
  v19 = v10;
  v23 = v10;
  v18 = v10;
  v24 = v10;
  v29 = v10 < *(_DWORD *)(v27 + 48);
  v28 = 210;
  if (!v29)
    _dispatch_abort(v28, 0, a3, a4, a5, a6, a7, a8);
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  v35 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * v24);
  v34 = v17;
  v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1)
    dispatch_once_f(v35, v34, v33);
  _dispatch_apply_clear_attr_behavior(*(_QWORD *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        v32 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * i);
        v31 = 0;
        v30 = _dispatch_no_op;
        if (*v32 != -1)
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
      }
    }
  }
  v14 = (unsigned int *)(v27 + 44);
  v15 = *(_DWORD *)(v27 + 44);
  do
  {
    v11 = v15;
    do
      v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    v15 = v12;
  }
  while (v12 != v11);
  if (v12 == 1)
  {
    v36 = v27;
    if (*(_QWORD *)(v27 + 32))
      free(*(void **)(v36 + 32));
    if (*(_QWORD *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(_QWORD *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }
    v37 = v36;
    v38 = (_QWORD *)v36;
    v41 = v36;
    v40 = 0;
    v40 = _dispatch_thread_getspecific(0x16uLL);
    v39 = 0;
    if (v40)
      v13 = v40[2] + 1;
    else
      v13 = 1;
    v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22, v41);
      v42 = 0;
    }
    else
    {
      v42 = (_QWORD *)v41;
    }
    v38 = v42;
    if (v42)
      _dispatch_continuation_free_to_cache_limit(v38);
  }
}

void dispatch_apply_f(size_t iterations, dispatch_queue_t queue, void *context, void (__cdecl *work)(void *, size_t))
{
  _dispatch_apply_with_attr_f(iterations, 0, queue, (uint64_t)context, (uint64_t)work, 1);
}

void _dispatch_apply_with_attr_f(unint64_t a1, uint64_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  unsigned int v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t (*v40)();
  unsigned int v41;
  unsigned int v42;
  unsigned int v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  uint64_t (**v47)();
  unint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  unint64_t *v61;
  unint64_t v62;
  uint64_t (**v63)();
  BOOL v64;
  unsigned int v65;
  BOOL v66;
  int v67;
  BOOL v68;
  uint64_t v69;
  unint64_t v70;
  uint64_t v71;
  unsigned int v72;
  BOOL v73;
  int v74;
  BOOL v75;
  BOOL v76;
  unint64_t v77;
  __int128 v78;
  uint64_t v79;
  uint64_t v80;
  void *context;
  _OWORD v82[3];
  uint64_t v83;
  dispatch_queue_t v84;
  uint64_t v85;
  uint64_t v86;
  unint64_t v87;
  unsigned int v88;
  dispatch_queue_t queue;
  dispatch_queue_s *v90;
  unint64_t v91;
  _QWORD *v92;
  uint64_t v93;
  uint64_t v94;
  __int128 v95;
  dispatch_queue_s *v96;
  uint64_t v97;
  unint64_t v98;
  _QWORD *i;
  const char *v100;
  _QWORD *v101;
  int v102;
  void *v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  unint64_t v107;
  unint64_t v108;
  unint64_t v109;
  unint64_t v110;
  dispatch_queue_s *v111;
  unsigned int v112;
  unsigned int v113;
  unint64_t v114;
  unint64_t v115;
  uint64_t v116;
  uint64_t v117;
  unint64_t v118;
  uint64_t v119;
  char v120;
  unsigned int v121;
  unint64_t v122;
  uint64_t v123;
  __int128 *v124;
  dispatch_queue_t v125;
  __int128 *v126;
  __int128 *v127;
  unint64_t v128;
  unint64_t v129;
  void *v130;
  void *v131;
  _QWORD *v132;
  unint64_t v133;
  dispatch_queue_t v134;
  uint64_t v135;
  uint64_t (**v136)();
  uint64_t (**v137)();
  uint64_t (**v138)();
  uint64_t (**v139)();
  uint64_t (***v140)();
  uint64_t v141;
  uint64_t (**v142)();
  int v143;
  unint64_t v144;
  uint64_t (**v145)();
  uint64_t (**v146)();
  int j;
  void (*v148)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v149)();
  uint64_t (***v150)();
  uint64_t v151;
  uint64_t v152;
  void *v153;
  unint64_t v154;
  unint64_t v155;
  unint64_t v156;
  unint64_t v157;
  dispatch_queue_t v158;
  dispatch_queue_t v159;
  uint64_t (**v160)();
  uint64_t (**v161)();
  _QWORD *v162;
  _QWORD *v163;
  _QWORD *v164;
  uint64_t (**v165)();
  int v166;
  uint64_t v167;
  uint64_t v168;
  uint64_t v169;
  void (*v170)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t (*v171)();
  uint64_t (**v172)();
  uint64_t (***v173)();
  uint64_t (***v174)();
  int v175;
  int v176;
  uint64_t (**v177)();
  int v178;
  int v179;
  uint64_t (***v180)();
  uint64_t (**v181)();
  uint64_t (**v182)();
  _BOOL4 v183;
  uint64_t (**v184)();
  uint64_t (**v185)();
  uint64_t (**v186)();
  uint64_t (**v187)();
  uint64_t (**v188)();
  uint64_t (**v189)();
  unint64_t v190;
  unint64_t v191;
  unint64_t v192;
  unint64_t v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  unint64_t v201;
  unint64_t v202;
  uint64_t (**v203)();
  uint64_t (**v204)();
  signed int v205;
  uint64_t (***v206)();
  uint64_t (**v207)();
  uint64_t (**v208)();
  uint64_t (*v209)();
  uint64_t v210;
  uint64_t (**v211)();
  uint64_t v212;
  _BOOL8 v213;
  BOOL v214;
  BOOL v215;
  BOOL v216;
  uint64_t (***v217)();
  unsigned int v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t (**v221)();
  uint64_t (***v222)();
  int v223;
  unint64_t v224;
  uint64_t v225;
  void *v226;
  void *v227;
  uint64_t v228;
  int v229;
  uint64_t v230;
  int v231;
  void *v232;
  unsigned int v233;
  uint64_t (**v234)();
  uint64_t (*v235)();
  int v236;
  void *object;
  uint64_t v238;
  uint64_t v239;
  uint64_t (**v240)();
  uint64_t v241;
  unsigned int v242;
  unint64_t v243;
  unint64_t v244;
  uint64_t (**v245)();
  uint64_t (**v246)();
  uint64_t (***v247)();
  unint64_t v248;
  int v249;
  uint64_t v250;
  uint64_t v251;
  unsigned int v252;
  unsigned int v253;
  int v254;
  unsigned int v255;
  uint64_t v256;
  unsigned int v257;
  unsigned int v258;
  int v259;
  unsigned int v260;
  uint64_t v261;
  unsigned int v262;
  int v263;
  unint64_t v264;
  unsigned int v265;
  uint64_t v266;
  unsigned int v267;
  unsigned int v268;
  unsigned int v269;
  unsigned int v270;
  uint64_t v271;
  int v272;
  uint64_t v273;
  int v274;
  uint64_t v275;
  int v276;
  uint64_t v277;
  int v278;
  int v279;
  int v280;
  unsigned int v281;
  unsigned int v282;
  unsigned int v283;

  v98 = a1;
  v97 = a2;
  v96 = a3;
  *((_QWORD *)&v95 + 1) = a4;
  *(_QWORD *)&v95 = a5;
  v94 = a6;
  if (a1)
  {
    if (v97 && !_dispatch_attr_is_initialized(v97))
    {
      v93 = v97;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v97;
      __break(1u);
      JUMPOUT(0x55C60);
    }
    v92 = 0;
    v100 = "apply";
    for (i = _dispatch_thread_getspecific(0x17uLL); i; i = (_QWORD *)*i)
    {
      if (i[1] == (_QWORD)v100)
      {
        v101 = i;
        goto LABEL_11;
      }
    }
    v101 = 0;
LABEL_11:
    v92 = v101;
    v91 = 0;
    if (v101)
      v77 = v92[2];
    else
      v77 = 0;
    v91 = v77;
    v90 = (dispatch_queue_s *)_dispatch_thread_getspecific(0x14uLL);
    queue = 0;
    if (v96)
    {
      queue = v96;
    }
    else
    {
      v110 = (unint64_t)v90;
      v109 = 0;
      if (v90)
      {
        while (*(_QWORD *)(v110 + 24))
        {
          v109 = *(_QWORD *)(v110 + 24);
          v133 = v110;
          v76 = 1;
          if (*(_QWORD *)(v110 + 24) != (_QWORD)&_dispatch_custom_workloop_root_queue)
            v76 = *(_QWORD *)(v133 + 24) == (_QWORD)&_dispatch_custom_workloop_overcommit_root_queue;
          if (v76)
          {
            v108 = v110;
            v154 = v110;
            v155 = v110;
            v107 = v110;
            v111 = (dispatch_queue_s *)v110;
            goto LABEL_38;
          }
          v110 = v109;
        }
      }
      if (!v110)
        goto LABEL_27;
      v106 = v110;
      v248 = v110;
      v75 = 0;
      if (v110 >= (unint64_t)&_dispatch_root_queues)
        v75 = v248 < (unint64_t)&_dispatch_queue_serial_numbers;
      if (v75)
      {
LABEL_27:
        v130 = _dispatch_thread_getspecific(4uLL);
        v103 = v130;
        v102 = 0;
        v128 = (unint64_t)(v130 & 0x3FFF00) >> 8;
        v6 = (v130 & 0x3FFF00) >> 8;
        v7 = __clz(__rbit32(v6));
        if (v6)
          v8 = v7 + 1;
        else
          v8 = 0;
        v102 = v8;
        if (v8)
          v74 = v102;
        else
          v74 = 4;
        v252 = v74;
        v251 = 0;
        v73 = 1;
        if (v74)
          v73 = v252 > 6;
        if (v73)
        {
          v250 = v252;
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
          qword_E4DA8 = v252;
          __break(1u);
          JUMPOUT(0x55FBCLL);
        }
        v249 = 0;
        v111 = (dispatch_queue_s *)&(&_dispatch_root_queues)[16 * (unint64_t)(3 * v252 - 3)];
      }
      else
      {
        v105 = v110;
        v156 = v110;
        v157 = v110;
        v104 = v110;
        v111 = (dispatch_queue_s *)v110;
      }
LABEL_38:
      queue = v111;
    }
    v88 = 0;
    v112 = *((_DWORD *)queue + 21) & 0xF00;
    if (v112 >> 8)
    {
      v72 = v112 >> 8;
    }
    else
    {
      v113 = *((_DWORD *)queue + 21) & 0xF000;
      v72 = v113 >> 12;
    }
    v88 = v72;
    if (*((_QWORD *)queue + 3))
    {
      v131 = _dispatch_thread_getspecific(4uLL);
      v129 = (unint64_t)(v131 & 0x3FFF00) >> 8;
      v9 = (v131 & 0x3FFF00) >> 8;
      v10 = __clz(__rbit32(v9));
      if (v9)
        v11 = v10 + 1;
      else
        v11 = 0;
      v88 = v11;
    }
    v87 = 0;
    v123 = v97;
    v122 = v91;
    v121 = v88;
    v120 = 1;
    if (v97 && !_dispatch_attr_is_initialized(v123))
    {
      v119 = v123;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v123;
      __break(1u);
      JUMPOUT(0x561A0);
    }
    v118 = 0;
    if (v123)
    {
      if (v122)
      {
        v118 = 1;
      }
      else
      {
        v116 = 2;
        v115 = 0;
        v262 = v121;
        v261 = 2;
        v260 = 0;
        v259 = 0;
        if (v121)
        {
          v267 = v262;
          switch(v262)
          {
            case 1u:
              v268 = 5;
              break;
            case 2u:
              v268 = 9;
              break;
            case 3u:
              v268 = 17;
              break;
            case 4u:
              v268 = 21;
              break;
            case 5u:
              v268 = 25;
              break;
            case 6u:
              v268 = 33;
              break;
            default:
              v268 = 0;
              break;
          }
          v259 = pthread_qos_max_parallelism(v268, v261 & 1);
        }
        if (v259 < 1)
        {
          v274 = 0;
          v273 = 0xFFFFFC036;
          v260 = MEMORY[0xFFFFFC036];
        }
        else
        {
          v260 = v259;
        }
        v272 = 2;
        v271 = 0xFFFFFC034;
        v258 = MEMORY[0xFFFFFC034];
        if (MEMORY[0xFFFFFC034] < v260)
          v260 = v258;
        v115 = v260;
        v114 = 0;
        v266 = v123;
        v265 = v121;
        v264 = -1;
        if (*(_QWORD *)(v123 + 8))
        {
          v263 = 0;
          v281 = v265;
          v280 = 0;
          v279 = 0;
          v282 = v265;
          switch(v265)
          {
            case 1u:
              v283 = 5;
              break;
            case 2u:
              v283 = 9;
              break;
            case 3u:
              v283 = 17;
              break;
            case 4u:
              v283 = 21;
              break;
            case 5u:
              v283 = 25;
              break;
            case 6u:
              v283 = 33;
              break;
            default:
              v283 = 0;
              break;
          }
          v279 = pthread_qos_max_parallelism(v283, 2);
          if (v279 >= 1)
            v280 = v279;
          v263 = v280;
          if (v280)
            v264 = (v263 * *(_DWORD *)(v266 + 8));
          else
            v264 = 0;
        }
        v114 = v264;
        if (v115 >= v264)
          v70 = v114;
        else
          v70 = v115;
        v118 = v70;
      }
    }
    else
    {
      v117 = 2;
      v257 = v121;
      v256 = 2;
      v255 = 0;
      v254 = 0;
      if (v121)
      {
        v269 = v257;
        switch(v257)
        {
          case 1u:
            v270 = 5;
            break;
          case 2u:
            v270 = 9;
            break;
          case 3u:
            v270 = 17;
            break;
          case 4u:
            v270 = 21;
            break;
          case 5u:
            v270 = 25;
            break;
          case 6u:
            v270 = 33;
            break;
          default:
            v270 = 0;
            break;
        }
        v254 = pthread_qos_max_parallelism(v270, v256 & 1);
      }
      if (v254 < 1)
      {
        v278 = 0;
        v277 = 0xFFFFFC036;
        v255 = MEMORY[0xFFFFFC036];
      }
      else
      {
        v255 = v254;
      }
      v276 = 2;
      v275 = 0xFFFFFC034;
      v253 = MEMORY[0xFFFFFC034];
      if (MEMORY[0xFFFFFC034] < v255)
        v255 = v253;
      v118 = v255;
      if (v122)
      {
        if (v122 >= v118)
          v71 = 1;
        else
          v71 = v118 / v122;
        v118 = v71;
      }
    }
    v87 = v118;
    if (!v118)
    {
      v86 = v97;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: attribute's properties are invalid or meaningless on this system";
      qword_E4DA8 = v97;
      __break(1u);
      JUMPOUT(0x56D58);
    }
    v85 = 0;
    if (v97)
    {
      v85 = 0xFFFFLL;
    }
    else if (v91)
    {
      if (v91 > 0xFFFE || v98 > 0xFFFE)
        v69 = 0xFFFFLL;
      else
        v69 = v91 * v98;
      v85 = v69;
    }
    else
    {
      v85 = v98;
    }
    if (v98 < v87)
      v87 = v98;
    memset(v82, 0, 32);
    v82[2] = v95;
    v83 = v94;
    v84 = queue;
    context = 0;
    v132 = 0;
    v162 = 0;
    v164 = _dispatch_thread_getspecific(0x16uLL);
    if (v164)
      _dispatch_thread_setspecific(22, v164[2]);
    v162 = v164;
    if (v164)
      v163 = v162;
    else
      v163 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    v132 = v163;
    context = v163;
    v163[1] = 0;
    *((_QWORD *)context + 2) = v98;
    *((_QWORD *)context + 3) = v85;
    *((_DWORD *)context + 11) = v87;
    *((_DWORD *)context + 13) = 0;
    _dispatch_apply_da_copy_attr((uint64_t)context, v97);
    *((_QWORD *)context + 4) = 0;
    *(_QWORD *)context = v82;
    *((_DWORD *)context + 10) = 0;
    v134 = queue;
    v68 = 1;
    if (*((_QWORD *)queue + 3) != (_QWORD)&_dispatch_custom_workloop_root_queue)
      v68 = *((_QWORD *)v134 + 3) == (_QWORD)&_dispatch_custom_workloop_overcommit_root_queue;
    if (v68)
    {
      v80 = 0;
      v79 = 0;
      v135 = *((_QWORD *)queue + 7);
      v166 = v135;
      v67 = v135;
      if (((v67 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
        dispatch_async_and_wait_f(queue, context, (dispatch_function_t)_dispatch_apply_serial);
      else
        _dispatch_apply_serial((uint64_t)context);
      return;
    }
    v66 = 1;
    if (*((_WORD *)queue + 40) != 1)
      v66 = v87 < 2;
    if (v66)
    {
LABEL_135:
      dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_serial);
      return;
    }
    if (*((_QWORD *)queue + 3))
    {
      if (queue != v90)
      {
        dispatch_sync_f(queue, context, (dispatch_function_t)_dispatch_apply_redirect);
        return;
      }
      goto LABEL_135;
    }
    v78 = 0uLL;
    v125 = queue;
    v124 = &v78;
    v127 = &v78;
    _dispatch_thread_getspecific_packed_pair(20, 21, &v78, v12, v13, v14, v15, v16);
    _dispatch_thread_setspecific_pair(20, (uint64_t)v125, 21, (uint64_t)v124, v17, v18, v19, v20);
    v158 = queue;
    v159 = queue;
    v150 = (uint64_t (***)())queue;
    v149 = (uint64_t (*)())context;
    v148 = _dispatch_apply_invoke;
    j = 0;
    v146 = 0;
    v145 = 0;
    v144 = 0;
    v153 = 0;
    v153 = _dispatch_thread_getspecific(4uLL);
    v144 = (unint64_t)v153;
    v143 = 0;
    v143 = *((_DWORD *)v149 + 11) - 1;
    v152 = v143;
    v151 = 336;
    if (!v143)
      _dispatch_abort(v151, v152, v21, v22, v23, v24, v25, v26);
    for (j = 0; j < v143; ++j)
    {
      v142 = 0;
      v160 = 0;
      v165 = 0;
      v165 = (uint64_t (**)())_dispatch_thread_getspecific(0x16uLL);
      if (v165)
        _dispatch_thread_setspecific(22, (uint64_t)v165[2]);
      v160 = v165;
      if (v165)
        v161 = v160;
      else
        v161 = (uint64_t (**)())_dispatch_continuation_alloc_from_heap();
      v142 = v161;
      v141 = 4;
      v140 = v150;
      v173 = v150;
      v172 = v161;
      v171 = v149;
      v170 = v148;
      v169 = 0x40000000;
      v168 = 4;
      v167 = 0;
      *v161 = (uint64_t (*)())(&stru_B8 + 76);
      v172[4] = (uint64_t (*)())v170;
      v172[5] = v171;
      if ((v169 & 0x40000000) == 0)
      {
        v224 = 0;
        v223 = 1;
        v226 = 0;
        v226 = _dispatch_thread_getspecific(4uLL);
        v227 = v226;
        v224 = v226 & 0xFFFFFF;
        if ((v223 & 2) != 0 || (v231 = 5, v230 = 4096, v224 <= 0x10FF))
        {
          v225 = v224;
        }
        else
        {
          v229 = 5;
          v228 = 4096;
          v225 = 4351;
        }
        v167 = v225;
      }
      v211 = v172;
      v210 = v169;
      v209 = 0;
      v213 = (int)v169 >= 0;
      v212 = 583;
      if ((int)v169 < 0)
        _dispatch_abort(v212, v213, v27, v28, v29, v30, v31, v32);
      if ((v210 & 0x40) == 0)
      {
        v232 = 0;
        v232 = _dispatch_thread_getspecific(0x1CuLL);
        if (v232)
        {
          object = v232;
          os_retain(v232);
        }
        v209 = (uint64_t (*)())v232;
      }
      v211[3] = v209;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v33, v34, v35, v36, v37, v38, v39, 589);
      v40 = v211[3];
      v236 = 771817476;
      v235 = v40;
      v234 = v211;
      if (v40 != (uint64_t (*)())-1)
      {
        v233 = 0;
        v65 = v235 ? *((_DWORD *)v235 + 8) : 0;
        v233 = v65;
        v242 = v236;
        v241 = v65;
        v240 = v234;
        v239 = 0;
        v238 = 0;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(v242, v241, v240, v239, v238);
      }
      v222 = v173;
      v221 = v172;
      v220 = v167;
      v219 = v169;
      v218 = 0;
      v217 = v173;
      if (v167)
      {
        v216 = (v219 & 0x20) != 0;
        v215 = 0;
        v215 = (*((_DWORD *)v217 + 21) & 0x40000000) != 0;
        v214 = 0;
        v214 = (*((_DWORD *)v217 + 21) & 0xFFF) != 0;
        if ((v219 & 0x20) != 0)
        {
          v220 |= 0x10000000uLL;
          v243 = v220 >> 8;
          v41 = v220 >> 8;
          v42 = __clz(__rbit32(v41));
          if (v41)
            v43 = v42 + 1;
          else
            v43 = 0;
          v218 = v43;
        }
        else if (v215 || !v214)
        {
          v244 = v220 >> 8;
          v44 = v220 >> 8;
          v45 = __clz(__rbit32(v44));
          if (v44)
            v46 = v45 + 1;
          else
            v46 = 0;
          v218 = v46;
        }
        else
        {
          v220 = 0;
        }
      }
      v221[1] = (uint64_t (*)())v220;
      v142[1] = (uint64_t (*)())(v144 | 0x10000000);
      v142[2] = (uint64_t (*)())v146;
      v146 = v142;
      if (!v145)
        v145 = v142;
    }
    *((_DWORD *)v149 + 12) = *((_DWORD *)v149 + 11);
    *((_QWORD *)v149 + 4) = _dispatch_calloc(*((int *)v149 + 11), 8);
    v139 = v146;
    v138 = v145;
    v182 = v146;
    v181 = v145;
    v180 = v150;
    v179 = 0;
    v178 = 0;
    if (MEMORY[0xFFFFFC100])
    {
      v177 = v182;
      do
      {
        v176 = 0;
        v175 = 0;
        v64 = 0;
        if (v177 != v181)
        {
          v177 = (uint64_t (**)())v177[2];
          v64 = v177 != 0;
        }
      }
      while (v64);
    }
    v174 = v180;
    v247 = v180;
    v246 = v182;
    v245 = v181;
    v137 = v146;
    v136 = v145;
    v208 = v146;
    v207 = v145;
    v206 = v150;
    v205 = v143;
    v204 = v146;
    v203 = v145;
    v202 = 0;
    v201 = (unint64_t)v145;
    v200 = 0;
    v199 = 0;
    v145[2] = 0;
    v198 = v200;
    _dispatch_thread_setspecific(122, (uint64_t)(v206 + 6));
    v196 = 0;
    v194 = v201;
    v193 = v201;
    v195 = v201;
    v61 = (unint64_t *)(v206 + 6);
    v62 = v201;
    v63 = v206[6];
    do
    {
      v47 = v63;
      do
        v48 = __ldaxr(v61);
      while ((uint64_t (**)())v48 == v63 && __stlxr(v62, v61));
      v63 = (uint64_t (**)())v48;
    }
    while (v48 != (_QWORD)v47);
    v192 = v48;
    v196 = v48;
    v191 = v48;
    v197 = v48;
    v202 = v48;
    v190 = v48;
    if (v48)
    {
      v189 = v204;
      v188 = v204;
      *(_QWORD *)(v190 + 16) = v204;
      v187 = v189;
    }
    else
    {
      v186 = v204;
      v185 = v204;
      v206[13] = v204;
      v184 = v186;
    }
    _dispatch_thread_setspecific(122, 0);
    v183 = v202 == 0;
    if (!v202)
      _dispatch_root_queue_poke_and_wakeup(v206, v205, 0, v51, v52, v53, v54, v55);
    _dispatch_apply_invoke_and_wait((uint64_t)v149, v49, v50, v51, v52, v53, v54, v55);
    v126 = &v78;
    _dispatch_thread_setspecific_packed_pair(20, 21, &v78, v56, v57, v58, v59, v60);
  }
}

void dispatch_apply_with_attr_f(unint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  _dispatch_apply_with_attr_f(a1, a2, 0, a3, a4, 2);
}

void dispatch_apply(size_t iterations, dispatch_queue_t queue, void *block)
{
  void (__cdecl *v3)(void *, size_t);
  void *context;

  context = _dispatch_Block_copy(block);
  v3 = (void (__cdecl *)(void *, size_t))_Block_get_invoke_fn((uint64_t)context);
  dispatch_apply_f(iterations, queue, context, v3);
  _Block_release(context);
}

void dispatch_apply_with_attr(unint64_t a1, uint64_t a2, const void *a3)
{
  uint64_t v3;
  void *v4;

  v4 = _dispatch_Block_copy(a3);
  v3 = _Block_get_invoke_fn((uint64_t)v4);
  dispatch_apply_with_attr_f(a1, a2, (uint64_t)v4, v3);
  _Block_release(v4);
}

uint64_t dispatch_apply_attr_init(uint64_t a1)
{
  uint64_t result;

  result = __memset_chk(a1, 0, 64, -1);
  *(_DWORD *)a1 = -1592086528;
  *(_QWORD *)(a1 + 16) = ~a1;
  return result;
}

uint64_t dispatch_apply_attr_destroy(uint64_t a1)
{
  return __memset_chk(a1, 0, 64, -1);
}

BOOL dispatch_apply_attr_set_parallelism(_BOOL8 result, uint64_t a2, unint64_t a3)
{
  if (a2 == -1)
    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  if (a2 != 1)
  {
    if (a2 != 2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unknown entity";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x58044);
    }
    return dispatch_apply_attr_set_per_cluster_parallelism(result, a3);
  }
  if (a3 != 1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_entity value for CPU entity";
    qword_E4DA8 = a3;
    __break(1u);
    JUMPOUT(0x57FECLL);
  }
  return result;
}

BOOL dispatch_apply_attr_set_per_cluster_parallelism(_BOOL8 result, unint64_t a2)
{
  uint64_t v3;

  v3 = result;
  if (!a2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: 0 is an invalid threads_per_cluster value";
    qword_E4DA8 = 0;
    __break(1u);
    JUMPOUT(0x580B4);
  }
  if (a2 >= 2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid threads_per_cluster value, only acceptable value is 1";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0x58108);
  }
  if (result)
  {
    result = _dispatch_attr_is_initialized(result);
    if (!result)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
      qword_E4DA8 = v3;
      __break(1u);
      JUMPOUT(0x58168);
    }
  }
  *(_QWORD *)(v3 + 8) = a2;
  return result;
}

unint64_t dispatch_apply_attr_query(uint64_t a1, uint64_t a2, uint64_t a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v11;
  unsigned int v12;
  BOOL v13;
  BOOL v14;
  unint64_t v15;
  uint64_t v19;
  _QWORD *i;
  _QWORD *v21;
  uint64_t *v22;
  uint64_t (***v23)();
  unsigned int v24;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  int v29;
  unsigned int v30;
  int v31;
  unsigned int v32;
  int v33;
  unsigned int v34;
  int v35;
  unsigned int v36;
  int v37;
  int v39;
  unsigned int v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  int v51;
  unsigned int v52;
  int v53;
  int v54;
  unsigned int v55;

  for (i = _dispatch_thread_getspecific(0x17uLL); i; i = (_QWORD *)*i)
  {
    if (i[1] == (_QWORD)"apply")
    {
      v21 = i;
      goto LABEL_7;
    }
  }
  v21 = 0;
LABEL_7:
  if (v21)
    v15 = v21[2];
  else
    v15 = 0;
  v22 = (uint64_t *)_dispatch_thread_getspecific(0x14uLL);
  if (v22)
  {
    while (v22[3])
    {
      v14 = 1;
      if (v22[3] != (_QWORD)&_dispatch_custom_workloop_root_queue)
        v14 = v22[3] == (_QWORD)&_dispatch_custom_workloop_overcommit_root_queue;
      if (v14)
      {
        v23 = (uint64_t (***)())v22;
        goto LABEL_31;
      }
      v22 = (uint64_t *)v22[3];
    }
  }
  if (!v22)
    goto LABEL_22;
  v13 = 0;
  if (v22 >= (uint64_t *)&_dispatch_root_queues)
    v13 = v22 < &_dispatch_queue_serial_numbers;
  if (v13)
  {
LABEL_22:
    v28 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
    v3 = __clz(__rbit32(v28));
    if ((_DWORD)v28)
      v4 = v3 + 1;
    else
      v4 = 0;
    if (v4)
      v12 = v4;
    else
      v12 = 4;
    if (v12 > 6)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupted priority";
      qword_E4DA8 = v12;
      __break(1u);
      JUMPOUT(0x58528);
    }
    v23 = &(&_dispatch_root_queues)[16 * (unint64_t)(3 * v12 - 3)];
  }
  else
  {
    v23 = (uint64_t (***)())v22;
  }
LABEL_31:
  v24 = *((_DWORD *)v23 + 21) & 0xF00;
  if (v24 >> 8)
    v11 = v24 >> 8;
  else
    v11 = (*((_DWORD *)v23 + 21) & 0xF000u) >> 12;
  switch(a2)
  {
    case 0:
      return dispatch_apply_attr_query(a1, 1, a3) != 0;
    case 1:
      if ((a3 & 1) != 0)
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x59434);
        }
        if (a1)
        {
          if (v15)
          {
            return 1;
          }
          else
          {
            v35 = 0;
            if (v11)
            {
              switch(v11)
              {
                case 1u:
                  v44 = 5;
                  break;
                case 2u:
                  v44 = 9;
                  break;
                case 3u:
                  v44 = 17;
                  break;
                case 4u:
                  v44 = 21;
                  break;
                case 5u:
                  v44 = 25;
                  break;
                case 6u:
                  v44 = 33;
                  break;
                default:
                  v44 = 0;
                  break;
              }
              v35 = pthread_qos_max_parallelism(v44, 0);
            }
            if (v35 < 1)
              v36 = MEMORY[0xFFFFFC036];
            else
              v36 = v35;
            if (MEMORY[0xFFFFFC034] < v36)
              v36 = MEMORY[0xFFFFFC034];
            v42 = -1;
            if (*(_QWORD *)(a1 + 8))
            {
              v51 = 0;
              switch(v11)
              {
                case 1u:
                  v52 = 5;
                  break;
                case 2u:
                  v52 = 9;
                  break;
                case 3u:
                  v52 = 17;
                  break;
                case 4u:
                  v52 = 21;
                  break;
                case 5u:
                  v52 = 25;
                  break;
                case 6u:
                  v52 = 33;
                  break;
                default:
                  v52 = 0;
                  break;
              }
              v50 = pthread_qos_max_parallelism(v52, 2);
              if (v50 >= 1)
                v51 = v50;
              if (v51)
                v42 = (v51 * *(_DWORD *)(a1 + 8));
              else
                v42 = 0;
            }
            if (v36 >= v42)
              return v42;
            else
              return v36;
          }
        }
        else
        {
          v33 = 0;
          if (v11)
          {
            switch(v11)
            {
              case 1u:
                v45 = 5;
                break;
              case 2u:
                v45 = 9;
                break;
              case 3u:
                v45 = 17;
                break;
              case 4u:
                v45 = 21;
                break;
              case 5u:
                v45 = 25;
                break;
              case 6u:
                v45 = 33;
                break;
              default:
                v45 = 0;
                break;
            }
            v33 = pthread_qos_max_parallelism(v45, 0);
          }
          if (v33 < 1)
            v34 = MEMORY[0xFFFFFC036];
          else
            v34 = v33;
          if (MEMORY[0xFFFFFC034] < v34)
            v34 = MEMORY[0xFFFFFC034];
          v26 = v34;
          if (v15)
          {
            if (v15 >= v34)
              return 1;
            else
              return v34 / v15;
          }
        }
        return v26;
      }
      else
      {
        if (a1 && !_dispatch_attr_is_initialized(a1))
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
          qword_E4DA8 = a1;
          __break(1u);
          JUMPOUT(0x5A160);
        }
        if (a1)
        {
          v39 = pthread_qos_max_parallelism(33, 0);
          if (v39 < 1)
            v40 = MEMORY[0xFFFFFC036];
          else
            v40 = v39;
          v43 = -1;
          if (*(_QWORD *)(a1 + 8))
          {
            v49 = 0;
            v48 = pthread_qos_max_parallelism(33, 2);
            if (v48 >= 1)
              v49 = v48;
            if (v49)
              v43 = (v49 * *(_DWORD *)(a1 + 8));
            else
              v43 = 0;
          }
          if (v40 >= v43)
            return v43;
          else
            return v40;
        }
        else
        {
          v37 = pthread_qos_max_parallelism(33, 0);
          if (v37 < 1)
            return MEMORY[0xFFFFFC036];
          else
            return v37;
        }
      }
    case 2:
      if (a1 && !_dispatch_attr_is_initialized(a1))
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_apply_attr not initialized using dispatch_apply_attr_init";
        qword_E4DA8 = a1;
        __break(1u);
        JUMPOUT(0x586FCLL);
      }
      if (a1)
      {
        if (v15)
        {
          return 1;
        }
        else
        {
          v31 = 0;
          if (v11)
          {
            switch(v11)
            {
              case 1u:
                v46 = 5;
                break;
              case 2u:
                v46 = 9;
                break;
              case 3u:
                v46 = 17;
                break;
              case 4u:
                v46 = 21;
                break;
              case 5u:
                v46 = 25;
                break;
              case 6u:
                v46 = 33;
                break;
              default:
                v46 = 0;
                break;
            }
            v31 = pthread_qos_max_parallelism(v46, 0);
          }
          if (v31 < 1)
            v32 = MEMORY[0xFFFFFC036];
          else
            v32 = v31;
          if (MEMORY[0xFFFFFC034] < v32)
            v32 = MEMORY[0xFFFFFC034];
          v41 = -1;
          if (*(_QWORD *)(a1 + 8))
          {
            v54 = 0;
            switch(v11)
            {
              case 1u:
                v55 = 5;
                break;
              case 2u:
                v55 = 9;
                break;
              case 3u:
                v55 = 17;
                break;
              case 4u:
                v55 = 21;
                break;
              case 5u:
                v55 = 25;
                break;
              case 6u:
                v55 = 33;
                break;
              default:
                v55 = 0;
                break;
            }
            v53 = pthread_qos_max_parallelism(v55, 2);
            if (v53 >= 1)
              v54 = v53;
            if (v54)
              v41 = (v54 * *(_DWORD *)(a1 + 8));
            else
              v41 = 0;
          }
          if (v32 >= v41)
            return v41;
          else
            return v32;
        }
      }
      else
      {
        v29 = 0;
        if (v11)
        {
          switch(v11)
          {
            case 1u:
              v47 = 5;
              break;
            case 2u:
              v47 = 9;
              break;
            case 3u:
              v47 = 17;
              break;
            case 4u:
              v47 = 21;
              break;
            case 5u:
              v47 = 25;
              break;
            case 6u:
              v47 = 33;
              break;
            default:
              v47 = 0;
              break;
          }
          v29 = pthread_qos_max_parallelism(v47, 0);
        }
        if (v29 < 1)
          v30 = MEMORY[0xFFFFFC036];
        else
          v30 = v29;
        if (MEMORY[0xFFFFFC034] < v30)
          v30 = MEMORY[0xFFFFFC034];
        v27 = v30;
        if (v15)
        {
          if (v15 >= v30)
            return 1;
          else
            return v30 / v15;
        }
      }
      return v27;
  }
  return v19;
}

int *_dispatch_apply_set_attr_behavior(int *result, uint64_t a2)
{
  if (result)
  {
    if (*((_QWORD *)result + 1))
    {
      result = (int *)__bsdthread_ctl(0x2000, 1, a2, *((_QWORD *)result + 1));
      if ((_DWORD)result)
      {
        result = __error();
        if (*result != 45)
        {
          __break(1u);
          JUMPOUT(0x5AFA0);
        }
      }
    }
  }
  return result;
}

_QWORD *_dispatch_apply_invoke3(_QWORD *result)
{
  unint64_t v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  _BOOL4 v26;
  unint64_t *v27;
  unint64_t v28;
  int v29;
  unint64_t *v30;
  unint64_t v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  unsigned int v35;
  __int128 v36;
  _QWORD v37[2];
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t (*v41)(uint64_t, uint64_t);
  unint64_t v42;
  unint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  unint64_t v49;
  unint64_t v50;
  uint64_t v51;
  _QWORD *v52;
  _QWORD *v53;
  _QWORD *v54;
  __int128 *v55;
  uint64_t v56;
  unsigned int v57;
  unsigned int v58;
  int v59;
  unsigned int v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  int v64;
  int v65;
  int v66;
  int v67;
  uint64_t (*v68)(uint64_t, uint64_t);
  uint64_t (*v69)(uint64_t, uint64_t);
  unint64_t v70;
  uint64_t v71;
  int v72;
  int v73;
  int v74;
  int v75;
  uint64_t (*v76)(uint64_t, uint64_t);
  uint64_t (*v77)(uint64_t, uint64_t);
  uint64_t v78;
  unint64_t v79;
  uint64_t v80;
  unsigned int v81;
  unsigned int v82;
  __int128 *v83;
  uint64_t *v84;
  uint64_t v85;
  _BOOL8 v86;
  __int128 *v87;
  uint64_t (*v88)(uint64_t, uint64_t);
  uint64_t v89;
  uint64_t (*v90)(uint64_t, uint64_t);
  uint64_t v91;
  uint64_t (*v92)(uint64_t, uint64_t);
  uint64_t v93;
  uint64_t (*v94)(uint64_t, uint64_t);
  uint64_t v95;

  v53 = result;
  v52 = result;
  v51 = 0;
  v51 = *result;
  v50 = 0;
  v50 = *(_QWORD *)(v51 + 16);
  v49 = 0;
  v48 = 0;
  v47 = 0;
  v45 = 1;
  v44 = 1;
  v46 = 1;
  v30 = (unint64_t *)(v51 + 8);
  v31 = *(_QWORD *)(v51 + 8);
  do
  {
    v1 = v31;
    do
      v2 = __ldaxr(v30);
    while (v2 == v31 && __stlxr(v31 + 1, v30));
    v31 = v2;
  }
  while (v2 != v1);
  v43 = v2;
  v47 = v2;
  v42 = v2;
  v49 = v2;
  if (v2 < v50)
  {
    v41 = 0;
    v41 = *(uint64_t (**)(uint64_t, uint64_t))(*(_QWORD *)v51 + 32);
    v40 = 0;
    v40 = *(_QWORD *)(*(_QWORD *)v51 + 40);
    v39 = 0;
    v39 = *(_QWORD *)(*(_QWORD *)v51 + 48);
    v38 = 0;
    v37[0] = 0;
    v37[1] = "apply";
    v38 = *(_QWORD *)(v51 + 24);
    v54 = v37;
    v37[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23, (uint64_t)v54);
    v36 = 0uLL;
    v35 = 0;
    if ((v52[1] & 1) != 0)
    {
      v56 = *(_QWORD *)(*(_QWORD *)v51 + 56);
      v34 = v56;
      v55 = &v36;
      v87 = &v36;
      _dispatch_thread_getspecific_packed_pair(20, 21, &v36, v3, v4, v5, v6, v7);
      _dispatch_thread_setspecific_pair(20, v56, 21, (uint64_t)v55, v8, v9, v10, v11);
      v59 = *(_DWORD *)(v34 + 84);
      v58 = 0;
      v58 = _dispatch_thread_getspecific(0x19uLL);
      v57 = v58;
      if (v58)
      {
        if ((v59 & 0xFFF) != 0)
        {
          v57 &= 0x880F0000;
          if ((v58 & 0xFFF) > (v59 & 0xFFFu))
            v29 = v58 & 0xFFF;
          else
            v29 = v59 & 0xFFF;
          v57 |= v29;
          v63 = v59 & 0xF000;
          v61 = v57 & 0xF00;
          if (v63 >> 12 > v61 >> 8)
            v59 &= 0x4400F000u;
          else
            v59 &= 0x40000000u;
          v57 |= v59;
        }
        else
        {
          if ((v57 & 0xFFF) != 0)
            v57 |= 0x40000000u;
          v62 = v59 & 0xF000;
          v60 = v57 & 0xF00;
          if (v62 >> 12 > v60 >> 8)
          {
            v57 &= 0xFFFF0FFF;
            v57 |= v59 & 0x400F000;
          }
        }
      }
      else
      {
        v57 = v59 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v57);
      v35 = v58;
    }
    v33 = *(_DWORD *)(v51 + 40);
    do
    {
      v32 = 0;
      if ((v33 & 0x1000000) != 0)
        v32 = _dispatch_autorelease_pool_push();
      if ((v39 & 1) != 0)
      {
        v71 = v40;
        v70 = v49;
        v69 = v41;
        v68 = v41;
        v91 = v40;
        v90 = v41;
        v67 = 0;
        v66 = 0;
        v65 = 0;
        v64 = 0;
        _dispatch_client_callout2(v40, v49, v41);
        v95 = v71;
        v94 = v68;
      }
      else
      {
        if ((v39 & 2) == 0)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
          qword_E4DA8 = v39;
          __break(1u);
          JUMPOUT(0x5B794);
        }
        v12 = *((unsigned int *)v52 + 4);
        v80 = v40;
        v79 = v49;
        v78 = v12;
        v77 = v41;
        v76 = v41;
        v89 = v40;
        v88 = v41;
        v75 = 0;
        v74 = 0;
        v73 = 0;
        v72 = 0;
        _dispatch_client_callout3(v40, v49, v12, (uint64_t (*)(uint64_t, uint64_t, uint64_t))v41);
        v93 = v80;
        v92 = v76;
      }
      ++v48;
      v27 = (unint64_t *)(v51 + 8);
      v28 = *(_QWORD *)(v51 + 8);
      do
      {
        v13 = v28;
        do
          v14 = __ldaxr(v27);
        while (v14 == v28 && __stlxr(v28 + 1, v27));
        v28 = v14;
      }
      while (v14 != v13);
      v49 = v14;
      if (v32)
        _dispatch_autorelease_pool_pop(v32);
    }
    while (v49 < v50);
    if ((v52[1] & 1) != 0)
    {
      v82 = v35;
      v81 = 0;
      v81 = _dispatch_thread_getspecific(0x19uLL);
      v82 &= 0xFFF0FFFF;
      v82 |= v81 & 0xF0000;
      _dispatch_thread_setspecific(25, v82);
      v83 = &v36;
      _dispatch_thread_setspecific_packed_pair(20, 21, &v36, v15, v16, v17, v18, v19);
    }
    v84 = v37;
    v26 = _dispatch_thread_getspecific(0x17uLL) == v37;
    v86 = v26;
    v85 = 449;
    if (!v26)
      _dispatch_abort(v85, v86, v20, v21, v22, v23, v24, v25);
    return (_QWORD *)_dispatch_thread_setspecific(23, *v84);
  }
  return result;
}

uint64_t _dispatch_apply_clear_attr_behavior(uint64_t result, uint64_t a2)
{
  if (result)
  {
    if (*(_QWORD *)(result + 8))
    {
      result = __bsdthread_ctl(0x2000, 2, a2, *(_QWORD *)(result + 8));
      if ((_DWORD)result)
      {
        __break(1u);
        JUMPOUT(0x5BA0CLL);
      }
    }
  }
  return result;
}

BOOL _dispatch_attr_is_initialized(uint64_t a1)
{
  BOOL v2;

  v2 = 0;
  if (*(_DWORD *)a1 == -1592086528)
    return ~*(_QWORD *)(a1 + 16) == a1;
  return v2;
}

uint64_t _dispatch_apply_da_copy_attr(uint64_t result, uint64_t a2)
{
  uint64_t v2;
  uint64_t v4;

  v4 = result;
  if (a2)
  {
    v2 = _dispatch_calloc(1, 64);
    result = dispatch_apply_attr_init(v2);
    *(_QWORD *)(v2 + 8) = *(_QWORD *)(a2 + 8);
    *(_DWORD *)(v2 + 4) = *(_DWORD *)(a2 + 4);
    *(_QWORD *)(v4 + 56) = v2;
  }
  else
  {
    *(_QWORD *)(result + 56) = 0;
  }
  return result;
}

_QWORD *_dispatch_apply_serial(uint64_t a1)
{
  uint64_t v1;
  _QWORD *result;
  int v3;
  BOOL v4;
  uint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  _QWORD *v10;
  int v11;
  uint64_t v12;

  v8 = *(_QWORD *)a1;
  v7 = *(_QWORD *)(a1 + 16);
  v6 = 0;
  v12 = *(_QWORD *)(*(_QWORD *)a1 + 56);
  v11 = 0;
  while (1)
  {
    v4 = 0;
    if (v12)
      v4 = v11 == 0;
    if (!v4)
      break;
    v11 = (*(_DWORD *)(v12 + 80) & 0x30000) << 8;
    v12 = *(_QWORD *)(v12 + 24);
  }
  do
  {
    v5 = 0;
    if ((v11 & 0x1000000) != 0)
      v5 = _dispatch_autorelease_pool_push();
    if ((*(_BYTE *)(v8 + 48) & 1) != 0)
    {
      _dispatch_client_callout2(*(_QWORD *)(v8 + 40), v6, *(uint64_t (**)(uint64_t, uint64_t))(v8 + 32));
    }
    else
    {
      if ((*(_BYTE *)(v8 + 48) & 2) == 0)
      {
        v1 = *(_QWORD *)(v8 + 48);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: apply continuation has invalid flags";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x5C010);
      }
      _dispatch_client_callout3(*(_QWORD *)(v8 + 40), v6, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v8 + 32));
    }
    if (v5)
      _dispatch_autorelease_pool_pop(v5);
    ++v6;
  }
  while (v6 < v7);
  if (*(_QWORD *)(a1 + 32))
    free(*(void **)(a1 + 32));
  if (*(_QWORD *)(a1 + 56))
  {
    dispatch_apply_attr_destroy(*(_QWORD *)(a1 + 56));
    free(*(void **)(a1 + 56));
  }
  result = _dispatch_thread_getspecific(0x16uLL);
  if (result)
    v3 = *((_DWORD *)result + 2) + 1;
  else
    v3 = 1;
  if (v3 <= _dispatch_continuation_cache_limit)
  {
    *(_QWORD *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v3;
    result = (_QWORD *)_dispatch_thread_setspecific(22, a1);
    v10 = 0;
  }
  else
  {
    v10 = (_QWORD *)a1;
  }
  if (v10)
    return _dispatch_continuation_free_to_cache_limit(v10);
  return result;
}

void _dispatch_apply_redirect(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  unint64_t *v30;
  unint64_t v31;
  BOOL v32;
  unsigned int v33;
  unint64_t *v34;
  unint64_t v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  int v39;
  signed int v41;
  unint64_t v42;
  unint64_t v43;
  _QWORD *v44;
  signed int j;
  _QWORD *v46;
  _QWORD *v47;
  unint64_t *v48;
  _BOOL4 v49;
  int v50;
  unint64_t v51;
  int v52;
  uint64_t k;
  uint64_t i;
  int v55;
  _QWORD *v56;
  unint64_t v57;
  void *v58;
  uint64_t v59;

  v39 = *(_DWORD *)(a1 + 44) - 1;
  v38 = *(_QWORD *)(*(_QWORD *)a1 + 56);
  v37 = v38;
  do
  {
    if (*(_WORD *)(v37 + 80) == 1)
    {
      v52 = 0;
    }
    else
    {
      v48 = (unint64_t *)(v37 + 56);
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v1 = __ldaxr(v48);
        else
          v1 = __ldxr(v48);
        if ((v1 & 0x20000000000000) != 0)
          v55 = 0;
        else
          v55 = 4096 - ((v1 & 0x3FFE0000000000) >> 41);
        v50 = v55;
        if (!v55)
        {
          __clrex();
          v52 = 0;
          goto LABEL_20;
        }
        if (v55 > v39)
          v50 = v39;
        v51 = v1 + ((uint64_t)v50 << 41);
        if (_os_atomic_mo_has_release(0))
          v49 = __stlxr(v51, v48) == 0;
        else
          v49 = __stxr(v51, v48) == 0;
      }
      while (!v49);
      v52 = v50;
    }
LABEL_20:
    if (v39 > v52)
    {
      v36 = v39 - v52;
      for (i = v38; i != v37; i = *(_QWORD *)(i + 24))
      {
        v34 = (unint64_t *)(i + 56);
        v35 = *(_QWORD *)(i + 56);
        do
        {
          v2 = v35;
          do
            v3 = __ldaxr(v34);
          while (v3 == v35 && __stlxr(v35 - ((uint64_t)(v39 - v52) << 41), v34));
          v35 = v3;
        }
        while (v3 != v2);
      }
      v39 = v52;
      if (!v52)
      {
        _dispatch_apply_serial(a1);
        return;
      }
      *(_DWORD *)(a1 + 44) -= v36;
    }
    if (!*(_DWORD *)(a1 + 40))
      *(_DWORD *)(a1 + 40) = (*(_DWORD *)(v37 + 80) & 0x30000) << 8;
    v37 = *(_QWORD *)(v37 + 24);
  }
  while (*(_QWORD *)(v37 + 24));
  v44 = 0;
  v43 = 0;
  v42 = (unint64_t)_dispatch_thread_getspecific(4uLL);
  v41 = *(_DWORD *)(a1 + 44) - 1;
  if (*(_DWORD *)(a1 + 44) == 1)
    _dispatch_abort(336, v41, v4, v5, v6, v7, v8, v9);
  for (j = 0; j < v41; ++j)
  {
    v47 = _dispatch_thread_getspecific(0x16uLL);
    if (v47)
    {
      _dispatch_thread_setspecific(22, v47[2]);
      v46 = v47;
    }
    else
    {
      v46 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    }
    *v46 = 260;
    v46[4] = _dispatch_apply_redirect_invoke;
    v46[5] = a1;
    v58 = _dispatch_thread_getspecific(0x1CuLL);
    if (v58)
      os_retain(v58);
    v46[3] = v58;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v10, v11, v12, v13, v14, v15, v16, 589);
    v59 = v46[3];
    if (v59 != -1)
    {
      v33 = v59 ? *(_DWORD *)(v59 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v33, v46, 0, 0);
    }
    v46[1] = 0;
    v46[1] = v42 | 0x10000000;
    v46[2] = v44;
    v44 = v46;
    if (!v43)
      v43 = (unint64_t)v46;
  }
  *(_DWORD *)(a1 + 48) = *(_DWORD *)(a1 + 44);
  *(_QWORD *)(a1 + 32) = _dispatch_calloc(*(int *)(a1 + 44), 8);
  if (MEMORY[0xFFFFFC100])
  {
    v56 = v44;
    do
    {
      v32 = 0;
      if (v56 != (_QWORD *)v43)
      {
        v56 = (_QWORD *)v56[2];
        v32 = v56 != 0;
      }
    }
    while (v32);
  }
  *(_QWORD *)(v43 + 16) = 0;
  _dispatch_thread_setspecific(122, v37 + 48);
  v30 = (unint64_t *)(v37 + 48);
  v31 = *(_QWORD *)(v37 + 48);
  do
  {
    v17 = v31;
    do
      v18 = __ldaxr(v30);
    while (v18 == v31 && __stlxr(v43, v30));
    v31 = v18;
  }
  while (v18 != v17);
  v57 = v18;
  if (v18)
    *(_QWORD *)(v18 + 16) = v44;
  else
    *(_QWORD *)(v37 + 104) = v44;
  _dispatch_thread_setspecific(122, 0);
  if (!v57)
    _dispatch_root_queue_poke_and_wakeup((uint64_t (***)())v37, v41, 0, v21, v22, v23, v24, v25);
  _dispatch_apply_invoke_and_wait(a1, v19, v20, v21, v22, v23, v24, v25);
  for (k = v38; k != v37; k = *(_QWORD *)(k + 24))
  {
    v28 = (unint64_t *)(k + 56);
    v29 = *(_QWORD *)(k + 56);
    do
    {
      v26 = v29;
      do
        v27 = __ldaxr(v28);
      while (v27 == v29 && __stlxr(v29 - ((uint64_t)v39 << 41), v28));
      v29 = v27;
    }
    while (v27 != v26);
  }
}

void _dispatch_apply_invoke_and_wait(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  int v13;
  unsigned int *v14;
  unsigned int v15;
  unsigned int v16;
  _QWORD v17[3];
  unsigned int v18;
  unsigned int v19;
  int v20;
  int v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  int i;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  _BOOL8 v29;
  void (*v30)();
  void *v31;
  dispatch_once_t *v32;
  dispatch_function_t v33;
  _QWORD *v34;
  dispatch_once_t *v35;
  uint64_t v36;
  uint64_t v37;
  _QWORD *v38;
  int v39;
  _DWORD *v40;
  uint64_t v41;
  _QWORD *v42;

  v27 = a1;
  v26 = 2;
  i = 0;
  v24 = 0;
  v23 = 0;
  v21 = 1;
  v20 = 1;
  v22 = 1;
  v16 = *(_DWORD *)(a1 + 52);
  do
  {
    v8 = v16;
    v9 = (unsigned int *)(a1 + 52);
    do
      v10 = __ldaxr(v9);
    while (v10 == v16 && __stlxr(v16 + 1, v9));
    v16 = v10;
  }
  while (v10 != v8);
  v19 = v10;
  v23 = v10;
  v18 = v10;
  v24 = v10;
  v29 = v10 < *(_DWORD *)(v27 + 48);
  v28 = 210;
  if (!v29)
    _dispatch_abort(v28, 0, a3, a4, a5, a6, a7, a8);
  v17[0] = v27;
  v17[1] = v26;
  v17[2] = v24;
  _dispatch_apply_set_attr_behavior(*(int **)(v27 + 56), v24);
  v35 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * v24);
  v34 = v17;
  v33 = (dispatch_function_t)_dispatch_apply_invoke3;
  if (*v35 != -1)
    dispatch_once_f(v35, v34, v33);
  _dispatch_apply_clear_attr_behavior(*(_QWORD *)(v27 + 56), v24);
  if ((v26 & 2) != 0)
  {
    for (i = 0; i < *(_DWORD *)(v27 + 48); ++i)
    {
      if (i != v24)
      {
        v32 = (dispatch_once_t *)(*(_QWORD *)(v27 + 32) + 8 * i);
        v31 = 0;
        v30 = _dispatch_no_op;
        if (*v32 != -1)
          dispatch_once_f(v32, v31, (dispatch_function_t)v30);
      }
    }
  }
  v14 = (unsigned int *)(v27 + 44);
  v15 = *(_DWORD *)(v27 + 44);
  do
  {
    v11 = v15;
    do
      v12 = __ldaxr(v14);
    while (v12 == v15 && __stlxr(v15 - 1, v14));
    v15 = v12;
  }
  while (v12 != v11);
  if (v12 == 1)
  {
    v36 = v27;
    if (*(_QWORD *)(v27 + 32))
      free(*(void **)(v36 + 32));
    if (*(_QWORD *)(v36 + 56))
    {
      dispatch_apply_attr_destroy(*(_QWORD *)(v36 + 56));
      free(*(void **)(v36 + 56));
    }
    v37 = v36;
    v38 = (_QWORD *)v36;
    v41 = v36;
    v40 = 0;
    v40 = _dispatch_thread_getspecific(0x16uLL);
    v39 = 0;
    if (v40)
      v13 = v40[2] + 1;
    else
      v13 = 1;
    v39 = v13;
    if (v13 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(v41 + 16) = v40;
      *(_DWORD *)(v41 + 8) = v39;
      _dispatch_thread_setspecific(22, v41);
      v42 = 0;
    }
    else
    {
      v42 = (_QWORD *)v41;
    }
    v38 = v42;
    if (v42)
      _dispatch_continuation_free_to_cache_limit(v38);
  }
}

dispatch_source_t dispatch_source_create(dispatch_source_type_t type, uintptr_t handle, uintptr_t mask, dispatch_queue_t queue)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v22;
  uint64_t v23;

  v23 = (*((uint64_t (**)(dispatch_source_type_t, uintptr_t, uintptr_t))type + 4))(type, handle, mask);
  if (!v23)
    return 0;
  v22 = (uint64_t)_dispatch_object_alloc((uint64_t)_OS_dispatch_source_vtable, 0x78uLL, v4, v5, v6, v7, v8, v9);
  if (((*(unsigned __int8 *)(*(_QWORD *)v23 + 10) >> 1) & 1) != 0)
    v14 = 0x4000000;
  else
    v14 = 0x400000;
  _dispatch_queue_init(v22, v14, 1, 0x180000000000000, v10, v11, v12, v13);
  *(_QWORD *)(v22 + 72) = "source";
  *(_QWORD *)(v22 + 88) = v23;
  *(_QWORD *)(v23 + 8) = ~v22;
  if (queue)
  {
    if ((*((_BYTE *)queue + 87) & 8) != 0 && (*(_BYTE *)(v23 + 29) & 2) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target source to the cooperative root queue - not implemented";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x5DA54);
    }
    _dispatch_retain((uint64_t)queue);
  }
  else
  {
    queue = (dispatch_queue_t)&off_E46C0;
  }
  *(_QWORD *)(v22 + 24) = queue;
  if ((*(_BYTE *)(v23 + 29) & 2) != 0 && (*(_BYTE *)(v23 + 30) & 0x10) != 0)
    dispatch_source_set_timer((dispatch_source_t)v22, 0, handle, 0xFFFFFFFFFFFFFFFFLL);
  _dispatch_object_debug(v22, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_source_create");
  return (dispatch_source_t)v22;
}

void dispatch_source_set_timer(dispatch_source_t source, dispatch_time_t start, uint64_t interval, uint64_t leeway)
{
  void *v4;
  void *v5;
  unint64_t *v6;
  void *v7;
  uint64_t *v8;
  uint64_t v9;
  int v11;

  v9 = *((_QWORD *)source + 11);
  if ((*(_BYTE *)(v9 + 29) & 2) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempt to set timer on a non-timer source";
    qword_E4DA8 = (uint64_t)source;
    __break(1u);
    JUMPOUT(0x5DB78);
  }
  if ((*(_BYTE *)(v9 + 30) & 0x10) != 0)
    v8 = (uint64_t *)_dispatch_interval_config_create(start, interval, leeway, v9);
  else
    v8 = (uint64_t *)_dispatch_timer_config_create(start, interval, leeway, v9);
  if (_dispatch_timer_flags_to_clock(*(_BYTE *)(v9 + 30)) != *((_DWORD *)v8 + 6)
    && *(char *)(v9 + 28) == -20)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Attempting to modify timer clock";
    __break(1u);
    JUMPOUT(0x5DC20);
  }
  v11 = *((_DWORD *)v8 + 6);
  if (_dispatch_source_timer_telemetry_pred != -1)
    dispatch_once_f(&_dispatch_source_timer_telemetry_pred, 0, (dispatch_function_t)_dispatch_source_timer_telemetry_init);
  if ((_dispatch_source_timer_use_telemetry & 1) != 0)
    _dispatch_source_timer_telemetry_slow((uint64_t)source, v11, v8);
  v6 = (unint64_t *)(v9 + 104);
  v7 = *(void **)(v9 + 104);
  do
  {
    v4 = v7;
    do
      v5 = (void *)__ldaxr(v6);
    while (v5 == v7 && __stlxr((unint64_t)v8, v6));
    v7 = v5;
  }
  while (v5 != v4);
  if (v5)
    free(v5);
  (*(void (**)(dispatch_source_t, _QWORD, uint64_t))(*(_QWORD *)source + 64))(source, 0, 2);
}

BOOL _dispatch_source_is_timer(uint64_t a1)
{
  return (*(_BYTE *)(*(_QWORD *)(a1 + 88) + 29) & 2) != 0;
}

void _dispatch_source_dispose(uint64_t a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  uint64_t v9;
  unint64_t v10;
  uint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unint64_t *v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_dispose");
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(772079668, a1, 0, 0, 0);
  v18 = (unint64_t *)(*(_QWORD *)(a1 + 88) + 56);
  v19 = *v18;
  do
  {
    v8 = v19;
    do
      v9 = __ldaxr(v18);
    while (v9 == v19 && __stlxr(0, v18));
    v19 = v9;
  }
  while (v9 != v8);
  if (v9)
    _dispatch_source_handler_dispose(v9);
  v16 = (unint64_t *)(*(_QWORD *)(a1 + 88) + 40);
  v17 = *v16;
  do
  {
    v10 = v17;
    do
      v11 = __ldaxr(v16);
    while (v11 == v17 && __stlxr(0, v16));
    v17 = v11;
  }
  while (v11 != v10);
  if (v11)
    _dispatch_source_handler_dispose(v11);
  v14 = (unint64_t *)(*(_QWORD *)(a1 + 88) + 48);
  v15 = *v14;
  do
  {
    v12 = v15;
    do
      v13 = __ldaxr(v14);
    while (v13 == v15 && __stlxr(0, v14));
    v15 = v13;
  }
  while (v13 != v12);
  if (v13)
    _dispatch_source_handler_dispose(v13);
  _dispatch_unote_dispose(*(_QWORD *)(a1 + 88));
  *(_QWORD *)(a1 + 88) = 0;
  _dispatch_lane_class_dispose(a1, a2);
}

uint64_t _dispatch_source_xref_dispose(uint64_t a1)
{
  BOOL v2;
  unsigned int v3;

  v3 = *(_DWORD *)(a1 + 80);
  v2 = 0;
  if ((v3 & 0x4000000) != 0)
  {
    v2 = 0;
    if ((v3 & 0x10000000) == 0)
      v2 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 48) != 0;
  }
  if (v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Release of a source that has not been cancelled, but has a mand"
                           "atory cancel handler";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x5E298);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 2);
}

intptr_t dispatch_source_testcancel(dispatch_source_t source)
{
  return (*((_DWORD *)source + 20) & 0x10000000) != 0;
}

uintptr_t dispatch_source_get_mask(dispatch_source_t source)
{
  uint64_t v2;

  v2 = *((_QWORD *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10000000) != 0)
    return 0;
  if ((*(_BYTE *)(v2 + 29) & 0x10) != 0)
    return 0x80000000;
  if ((*(_BYTE *)(v2 + 29) & 2) != 0)
    return *(unsigned __int8 *)(v2 + 30);
  return *(unsigned int *)(v2 + 32);
}

uintptr_t dispatch_source_get_handle(dispatch_source_t source)
{
  int v2;
  uint64_t v3;

  v3 = *((_QWORD *)source + 11);
  if (*(char *)(v3 + 28) != -20)
    return *(unsigned int *)(v3 + 24);
  v2 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v3 + 30));
  if (!v2)
    return 1;
  if (v2 == 1)
    return 2;
  if (v2 != 2)
    return *(unsigned int *)(v3 + 24);
  return 3;
}

uint64_t _dispatch_timer_flags_to_clock(char a1)
{
  return (a1 & 0xC) >> 2;
}

uintptr_t dispatch_source_get_data(dispatch_source_t source)
{
  uint64_t v3;

  v3 = *((_QWORD *)source + 11);
  if ((*(_BYTE *)(v3 + 29) & 0x10) != 0)
    return 0x80000000;
  if ((*(_BYTE *)(v3 + 29) & 4) != 0)
    return *(_QWORD *)(v3 + 64);
  else
    return *(_QWORD *)(v3 + 64);
}

uint64_t dispatch_source_get_extended_data(uint64_t a1, uintptr_t *a2, unint64_t a3)
{
  uint64_t v4;
  unint64_t v5;
  uintptr_t v6;
  uintptr_t data;
  uint64_t v8;

  v8 = *(_QWORD *)(a1 + 88);
  if (a3 >= 0x10)
    v4 = 16;
  else
    v4 = a3;
  if (a3)
  {
    v6 = 0;
    if ((*(_BYTE *)(v8 + 29) & 4) != 0)
    {
      v5 = *(_QWORD *)(v8 + 64);
      data = v5;
      v6 = HIDWORD(v5);
    }
    else
    {
      data = dispatch_source_get_data((dispatch_source_t)a1);
    }
    if (a3 >= 8)
      *a2 = data;
    if (a3 >= 0x10)
      a2[1] = v6;
    if (a3 > 0x10)
      __memset_chk(a2 + 2, 0, a3 - 16, -1);
  }
  return v4;
}

void dispatch_source_merge_data(dispatch_source_t source, uintptr_t value)
{
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t v5;
  uint64_t v6;
  unint64_t *v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  int v11;
  uint64_t v12;

  v12 = *((_QWORD *)source + 11);
  if ((*((_DWORD *)source + 20) & 0x10800000) == 0)
  {
    v11 = *(char *)(v12 + 28);
    switch(v11)
    {
      case -23:
        *(_QWORD *)(v12 + 72) = value;
        break;
      case -22:
        v7 = (unint64_t *)(v12 + 72);
        v8 = *(_QWORD *)(v12 + 72);
        do
        {
          v4 = v8;
          do
            v5 = __ldaxr(v7);
          while (v5 == v8 && __stlxr(v8 | value, v7));
          v8 = v5;
        }
        while (v5 != v4);
        break;
      case -21:
        v9 = (unint64_t *)(v12 + 72);
        v10 = *(_QWORD *)(v12 + 72);
        do
        {
          v2 = v10;
          do
            v3 = __ldaxr(v9);
          while (v3 == v10 && __stlxr(v10 + value, v9));
          v10 = v3;
        }
        while (v3 != v2);
        break;
      default:
        v6 = *(char *)(v12 + 28);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid source type";
        qword_E4DA8 = v6;
        __break(1u);
        JUMPOUT(0x5E99CLL);
    }
    (*(void (**)(dispatch_source_t, _QWORD, uint64_t))(*(_QWORD *)source + 64))(source, 0, 2);
  }
}

void dispatch_source_set_event_handler(dispatch_source_t source, dispatch_block_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 0, 1);
}

void _dispatch_source_set_handler(uint64_t a1, const void *a2, uint64_t a3, char a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  unint64_t *v28;
  unint64_t v29;
  int v30;
  int v31;
  unsigned int v32;
  unsigned int v33;
  int v34;
  uint64_t v38;
  char v39;
  unint64_t *v43;
  _BOOL4 v44;
  unint64_t v45;
  __int16 v46;
  char v47;
  unint64_t v48;
  _DWORD *v49;
  uint64_t *v50;
  uint64_t *v51;
  uint64_t v52;
  void *v53;
  uint64_t v54;
  uint64_t *v55;
  uint64_t v56;
  uint64_t v57;

  v39 = a4 & 1;
  v55 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v55)
  {
    _dispatch_thread_setspecific(22, v55[2]);
    v51 = v55;
  }
  else
  {
    v51 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  if (a2)
  {
    v38 = 0;
    if (a3)
      v38 = 4;
    if ((v39 & 1) != 0)
    {
      v53 = _dispatch_Block_copy(a2);
      if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
      {
        *v51 = v38 | 0x110;
        v51[5] = (uint64_t)v53;
        _dispatch_continuation_init_slow(v51, (unsigned int *)a1, 1073741888);
      }
      else
      {
        v52 = _Block_get_invoke_fn((uint64_t)a2);
        if ((v38 & 4) != 0)
          v52 = (uint64_t)_dispatch_call_block_and_release;
        *v51 = v38 | 0x110;
        v51[4] = v52;
        v51[5] = (uint64_t)v53;
        v51[3] = 0;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
        v56 = v51[3];
        if (v56 != -1)
        {
          v33 = v56 ? *(_DWORD *)(v56 + 32) : 0;
          if (MEMORY[0xFFFFFC100])
            kdebug_trace(771817476, v33, v51, 0, 0);
        }
        v51[1] = 0;
      }
    }
    else
    {
      v54 = *(_QWORD *)(a1 + 32);
      *v51 = v38 | 0x140;
      v51[4] = (uint64_t)a2;
      v51[5] = v54;
      v51[3] = 0;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v11, v12, v13, v14, v15, v16, v17, 589);
      v57 = v51[3];
      if (v57 != -1)
      {
        v32 = v57 ? *(_DWORD *)(v57 + 32) : 0;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(771817476, v32, v51, 0, 0);
      }
      v51[1] = 0;
    }
  }
  else
  {
    *v51 = 256;
    v51[4] = 0;
  }
  v43 = (unint64_t *)(a1 + 56);
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v25 = __ldaxr(v43);
    else
      v25 = __ldxr(v43);
    v46 = HIWORD(v25);
    if ((~v25 & 0x180000000000000) != 0)
    {
      __clrex();
      v47 = 0;
      goto LABEL_42;
    }
    v45 = v25 + 0x400000000000000;
    if (_os_atomic_mo_has_release(0))
      v44 = __stlxr(v45, v43) == 0;
    else
      v44 = __stxr(v45, v43) == 0;
  }
  while (!v44);
  LOBYTE(v31) = 1;
  if ((v46 & 0xFF80) != 0)
    v31 = (HIBYTE(v46) >> 1) & 1;
  if ((v31 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Too many calls to dispatch_suspend() prior to calling dispatch_"
                           "set_target_queue() or dispatch_set_*_handler()";
    __break(1u);
    JUMPOUT(0x5F6E0);
  }
  v47 = 1;
LABEL_42:
  if (v47 == 1)
  {
    v48 = (unint64_t)v51;
    if (v51[4])
    {
      if ((*(_BYTE *)v51 & 0x40) != 0)
        v51[5] = *(_QWORD *)(a1 + 32);
    }
    else
    {
      v49 = _dispatch_thread_getspecific(0x16uLL);
      if (v49)
        v30 = v49[2] + 1;
      else
        v30 = 1;
      if (v30 <= _dispatch_continuation_cache_limit)
      {
        v51[2] = (uint64_t)v49;
        *((_DWORD *)v51 + 2) = v30;
        _dispatch_thread_setspecific(22, (uint64_t)v51);
        v50 = 0;
      }
      else
      {
        v50 = v51;
      }
      if (v50)
        _dispatch_continuation_free_to_cache_limit(v50);
      v48 = 0;
    }
    v28 = (unint64_t *)(*(_QWORD *)(a1 + 88) + 8 * a3 + 40);
    v29 = *v28;
    do
    {
      v26 = v29;
      do
        v27 = __ldaxr(v28);
      while (v27 == v29 && __stlxr(v48, v28));
      v29 = v27;
    }
    while (v27 != v26);
    if (v27)
      _dispatch_source_handler_dispose(v27);
    _dispatch_lane_resume((unsigned __int16 *)a1, 0);
  }
  else
  {
    v34 = *(_DWORD *)(a1 + 80);
    if (((HIBYTE(v34) >> 2) & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot change a handler of this source after it has been activated";
      qword_E4DA8 = a3;
      __break(1u);
      JUMPOUT(0x5F9A0);
    }
    if ((v34 & 0x10000000) == 0)
    {
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771883020, a1, 0, 0, 0);
      if (a3 == 2)
      {
        _dispatch_bug_deprecated((uint64_t)"Setting registration handler after the source has been activated", v18, v19, v20, v21, v22, v23, v24);
      }
      else if (!a2)
      {
        _dispatch_bug_deprecated((uint64_t)"Clearing handler after the source has been activated", v18, v19, v20, v21, v22, v23, v24);
      }
    }
    v51[6] = a3;
    _dispatch_barrier_trysync_or_async_f(a1, v51, _dispatch_source_set_handler_slow, 0);
  }
}

void dispatch_source_set_event_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 0, 0);
}

void dispatch_source_set_cancel_handler(dispatch_source_t source, dispatch_block_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 1, 1);
}

void dispatch_source_set_mandatory_cancel_handler(dispatch_source_s *a1, void *a2)
{
  unsigned int v2;
  unsigned int *v5;
  _BOOL4 v6;
  unsigned int v7;

  v5 = (unsigned int *)((char *)a1 + 80);
  while (1)
  {
    v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v5) : __ldxr(v5);
    v7 = v2 & 0xFBBFFFFF | 0x4000000;
    if (v7 == v2)
      break;
    if (_os_atomic_mo_has_release(0))
      v6 = __stlxr(v7, v5) == 0;
    else
      v6 = __stxr(v7, v5) == 0;
    if (v6)
      goto LABEL_11;
  }
  __clrex();
LABEL_11:
  dispatch_source_set_cancel_handler(a1, a2);
}

void dispatch_source_set_cancel_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 1, 0);
}

void dispatch_source_set_mandatory_cancel_handler_f(dispatch_source_s *a1, void (__cdecl *a2)(void *))
{
  unsigned int v2;
  unsigned int *v5;
  _BOOL4 v6;
  unsigned int v7;

  v5 = (unsigned int *)((char *)a1 + 80);
  while (1)
  {
    v2 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v5) : __ldxr(v5);
    v7 = v2 & 0xFBBFFFFF | 0x4000000;
    if (v7 == v2)
      break;
    if (_os_atomic_mo_has_release(0))
      v6 = __stlxr(v7, v5) == 0;
    else
      v6 = __stxr(v7, v5) == 0;
    if (v6)
      goto LABEL_11;
  }
  __clrex();
LABEL_11:
  dispatch_source_set_cancel_handler_f(a1, a2);
}

void dispatch_source_set_registration_handler(dispatch_source_t source, dispatch_block_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 2, 1);
}

void dispatch_source_set_registration_handler_f(dispatch_source_t source, dispatch_function_t handler)
{
  _dispatch_source_set_handler((uint64_t)source, handler, 2, 0);
}

BOOL _dispatch_source_will_reenable_kevent_4NW(uint64_t a1)
{
  BOOL v2;
  int v3;
  uint64_t v5;

  v3 = *(_QWORD *)(a1 + 56);
  if (((v3 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: _dispatch_source_will_reenable_kevent_4NW not called from withi"
                           "n the event handler";
    __break(1u);
    JUMPOUT(0x5FF38);
  }
  v5 = *(_QWORD *)(*(_QWORD *)(a1 + 88) + 16);
  v2 = 0;
  if (v5)
  {
    v2 = 0;
    if ((v5 & 1) == 0)
      return (v5 & 2) == 0;
  }
  return v2;
}

void _dispatch_source_activate(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  BOOL v22;
  unsigned int *v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int *v30;
  int v31;
  int v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  int v40;
  int v41;
  int v42;
  int v43;
  _DWORD *v44;
  BOOL v45;
  unsigned int v46;
  unsigned int v47;
  int v48;
  int v49;
  int v50;
  unsigned int v51;
  int v52;
  int v53;
  int v54;
  int v55;
  int v56;
  unsigned int *v57;
  unsigned int v58;
  unsigned int v59;
  char v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  _BOOL8 v71;
  uint64_t v72;
  unsigned int v73;
  unsigned int v74;
  int v75;
  int v76;
  int v77;
  unsigned int v78;
  unsigned int v79;
  int v80;
  int v81;
  int v82;
  unsigned int v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;

  v30 = (unsigned int *)a1;
  v29 = 0;
  v28 = 0;
  v28 = *(_QWORD *)(a1 + 88);
  v27 = 0;
  v26 = 0;
  v34 = a1;
  v33 = 0;
  v32 = *(_DWORD *)(a1 + 80);
  v33 = v32;
  v31 = v32;
  if (((HIBYTE(v32) >> 4) & 1) != 0)
  {
    *((_WORD *)v30 + 58) |= 1u;
    _dispatch_source_refs_finalize_unregistration(v30);
  }
  else
  {
    v39 = v28;
    v38 = 0;
    v37 = 0;
    v36 = *(_QWORD *)(v28 + 40);
    v37 = v36;
    v35 = v36;
    v29 = v36;
    if (v36)
    {
      v44 = (_DWORD *)v29;
      v43 = 0;
      v72 = v29;
      if (*(_QWORD *)v29 > 0xFFFuLL)
      {
        if ((*(_QWORD *)(*(_QWORD *)v44 + 16) & 0xF0) == 0x10)
        {
          v42 = 0;
          v41 = v44[20];
          v42 = v41;
          v40 = v41;
          v43 = v41;
          v45 = (v41 & 0x80000) != 0;
        }
        else
        {
          v45 = 0;
        }
      }
      else
      {
        v45 = (*v44 & 2) != 0;
      }
      if (v45)
      {
        v57 = v30;
        v56 = 0x80000;
        v54 = 0x80000;
        v53 = 0x80000;
        v55 = 0x80000;
        v51 = 0;
        v49 = 0x80000;
        v48 = 0x80000;
        v50 = 0x80000;
        v23 = v30 + 20;
        v24 = v30[20];
        do
        {
          v8 = v24;
          do
            v9 = __ldaxr(v23);
          while (v9 == v24 && __stlxr(v24 | 0x80000, v23));
          v24 = v9;
        }
        while (v9 != v8);
        v47 = v9;
        v51 = v9;
        v46 = v9;
        v52 = v9 | v55;
      }
      if ((*(_BYTE *)(v29 + 11) & 0x10) != 0)
        goto LABEL_20;
      v58 = v30[21];
      v22 = 0;
      if ((v58 & 0x20000000) == 0)
        v22 = (v58 & 0x44000FFF) != 0;
      if (!v22)
      {
LABEL_20:
        v61 = *(_QWORD *)(v29 + 8);
        v60 = 0;
        v71 = (v61 & 0x20000000) == 0;
        v70 = 447;
        if ((v61 & 0x20000000) != 0)
          _dispatch_abort(v70, v71, a3, a4, a5, a6, a7, a8);
        v59 = v61;
        v69 = (unint64_t)(v61 & 0x3FFF00) >> 8;
        v10 = (v61 & 0x3FFF00) >> 8;
        v11 = __clz(__rbit32(v10));
        if (v10)
          v12 = v11 + 1;
        else
          v12 = 0;
        v59 |= v12 << 8;
        v30[21] = v59;
      }
      if ((*(_BYTE *)v29 & 0x40) != 0)
        *(_QWORD *)(v29 + 40) = *((_QWORD *)v30 + 4);
    }
    else
    {
      _dispatch_bug_deprecated((uint64_t)"dispatch source activated with no event handler set", a2, a3, a4, a5, a6, a7, a8);
    }
    _dispatch_lane_activate((uint64_t)v30);
    if (((*(_BYTE *)(v28 + 29) & 1) != 0 || (*(_BYTE *)(v28 + 29) & 2) != 0) && (v30[29] & 1) == 0)
    {
      v27 = _dispatch_queue_compute_priority_and_wlh((uint64_t)v30, &v26);
      if (v27)
      {
        v62 = v26;
        if (v26 && v62 != -4)
        {
          if (*(_BYTE *)(*(_QWORD *)v62 + 16) == 18)
            v63 = v62;
          else
            v63 = 0;
        }
        else
        {
          v63 = 0;
        }
        v25 = v63;
        if (v63 && *(char *)(v28 + 28) == -20 && *(_DWORD *)(v28 + 24) <= 5u)
        {
          if (!*(_QWORD *)(v63 + 48))
            *(_QWORD *)(v25 + 48) = _dispatch_calloc(6, 32);
          *(_BYTE *)(v28 + 29) |= 1u;
          v65 = v26;
          if (v26 && v65 != -4)
          {
            v64 = v65;
            v84 = v65;
            v83 = 0;
            v81 = 1;
            v80 = 1;
            v82 = 1;
            v78 = 0;
            v76 = 1;
            v75 = 1;
            v77 = 1;
            v20 = (unsigned int *)(v65 + 96);
            v21 = *(_DWORD *)(v65 + 96);
            do
            {
              v18 = v21;
              do
                v19 = __ldaxr(v20);
              while (v19 == v21 && __stlxr(v21 + 1, v20));
              v21 = v19;
            }
            while (v19 != v18);
            v74 = v19;
            v78 = v19;
            v73 = v19;
            v79 = v19 + v82;
            v83 = v19 + v82;
            if ((int)(v19 + v82) <= 0)
            {
              qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
              __break(1u);
              JUMPOUT(0x60664);
            }
          }
          v68 = v28;
          v67 = v26;
          v66 = 0;
          v89 = v28;
          v88 = v26;
          v87 = v26;
          v86 = v26;
          *(_QWORD *)(v28 + 16) = v26;
          v85 = v87;
        }
        _dispatch_source_install((uint64_t)v30, v26, v27, v13, v14, v15, v16, v17);
      }
    }
  }
}

void _dispatch_source_refs_finalize_unregistration(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int *v9;
  _BOOL4 v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;

  v9 = a1 + 20;
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v7 = __ldaxr(v9);
    else
      v7 = __ldxr(v9);
    v12 = v7;
    v11 = v7 & 0x1FFFFFFF | 0x80000000;
    if ((v12 & 0x1FFFFFFF | 0x80000000) == v12)
    {
      __clrex();
      v13 = v7;
      goto LABEL_12;
    }
    if (_os_atomic_mo_has_release(0))
      v10 = __stlxr(v11, v9) == 0;
    else
      v10 = __stxr(v11, v9) == 0;
  }
  while (!v10);
  v13 = v12;
LABEL_12:
  if ((v13 & 0x80000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Source finalized twice";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x6089CLL);
  }
  if ((v13 & 0x20000000) != 0)
    _dispatch_wake_by_address((uint64_t)(a1 + 20));
  _dispatch_object_debug((uint64_t)a1, "%s", v1, v2, v3, v4, v5, v6, (char)"_dispatch_source_refs_finalize_unregistration");
  _dispatch_release_tailcall(a1);
}

void _dispatch_source_install(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;

  v14 = a3;
  v13 = *(_QWORD *)(a1 + 88);
  if ((*(_WORD *)(a1 + 116) & 1) != 0)
    _dispatch_abort(660, (*(_WORD *)(a1 + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFE | 1;
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_install");
  if (!_dispatch_unote_register(v13, a2, v14, v8, v9, v10, v11, v12))
    _dispatch_source_refs_finalize_unregistration((unsigned int *)a1);
}

void _dispatch_source_invoke(unsigned int *a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  BOOL v42;
  unint64_t *v43;
  unint64_t v44;
  BOOL v45;
  unsigned int *v46;
  unsigned int v47;
  int v48;
  BOOL v49;
  unsigned int v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  _QWORD *v54;
  __int128 v56;
  unsigned int *v57;
  unsigned int *v58;
  unsigned int v59;
  unsigned int *v60;
  void *v61;
  uint64_t v62;
  _BYTE v63[9];
  unsigned int *v64;
  uint64_t (*v65)(uint64_t, uint64_t, unsigned int, _QWORD *);
  int v66;
  unsigned int v67;
  uint64_t v68;
  unsigned int *v69;
  unsigned int v70;
  unsigned int v71;
  unsigned int v72;
  unsigned int *v73;
  uint64_t v74;
  _BOOL8 v75;
  int v76;
  int v77;
  unsigned int *v78;
  void *v79;
  _BOOL4 v80;
  unint64_t *v81;
  _BOOL4 v82;
  unsigned int v83;
  uint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  uint64_t v88;
  uint64_t v89;
  unsigned int v90;
  unsigned int *v91;
  uint64_t v92;
  uint64_t v93;
  _BOOL8 v94;
  uint64_t v95;
  _BOOL8 v96;
  unsigned int v97;
  unsigned int v98;
  unsigned int v99;
  unsigned int v100;
  unsigned int v101;
  int v102;
  int v103;
  int v104;
  unsigned int v105;
  int v106;
  int v107;
  int v108;
  int v109;
  int v110;
  unsigned int *v111;
  int v112;
  unsigned int v113;
  unsigned int *v114;
  __int128 *v115;
  unsigned int *v116;
  __int128 *v117;
  int v118;
  unint64_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  unint64_t v124;
  unint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t *v129;
  int v130;
  unint64_t v131;
  unint64_t v132;
  BOOL v133;
  uint64_t v134;
  unsigned int *v135;
  char v136;
  unint64_t v137;
  unsigned int v138;
  unsigned int v139;
  unsigned int *v140;
  unsigned int *v141;
  void *v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int v145;
  unsigned int v146;
  unsigned int v147;
  unint64_t v148;
  unsigned int v149;
  unint64_t v150;
  unint64_t v151;
  unsigned int v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int v156;
  unsigned int v157;
  int v158;
  unint64_t v159;
  uint64_t v160;
  uint64_t v161;
  uint64_t v162;
  unsigned int v163;
  unsigned int v164;
  uint64_t v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  int v169;
  uint64_t v170;
  int v171;
  int v172;
  uint64_t v173;
  unsigned int *v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int v177;
  unsigned int *v178;
  uint64_t v179;
  uint64_t v180;
  __int128 *v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  unsigned int *v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  unsigned int *v189;
  unsigned int v190;
  unsigned int *v191;
  unsigned int v192;

  v69 = a1;
  v68 = a2;
  v67 = a3;
  v66 = 8;
  v65 = _dispatch_source_invoke2;
  v64 = a1;
  v63[8] = 0;
  *(_QWORD *)v63 = (a3 & 1) == 0;
  v62 = 0;
  if ((a3 & 3) == 0)
  {
    *((_QWORD *)v64 + 2) = -1985229329;
    v61 = _dispatch_thread_getspecific(0x14uLL);
    v60 = v64;
    v79 = v61;
    v78 = v64;
    v77 = 0;
    v76 = 0;
    v142 = v61;
    v141 = v64;
  }
  v67 |= v66;
  if ((v67 & 2) != 0)
  {
    v62 = 0x40020000000001;
    goto LABEL_54;
  }
  v91 = v64;
  v90 = v67;
  v89 = 0;
  v89 = (uint64_t)(*((unsigned __int16 *)v64 + 40) - 1) << 41;
  v192 = _dispatch_thread_getspecific(3uLL);
  v88 = v192 & 0xFFFFFFFC | 0x20000000000000;
  v86 = 0;
  v85 = 0;
  v84 = 0;
  v87 = 0xFFE00000FFFFFFFCLL;
  if ((v67 & 1) != 0)
  {
    v87 |= 0x4000000000uLL;
    v84 = 0;
  }
  else if ((v90 & 0x40000) != 0)
  {
    v84 = 0x4000000000;
  }
  else
  {
    v87 |= 0x4000000000uLL;
    v84 = 1;
  }
  v96 = (v90 & 2) == 0;
  v95 = 1323;
  if ((v90 & 2) != 0)
    _dispatch_abort(v95, v96, v3, v4, v5, v6, v7, v8);
  v83 = 0;
  v146 = _dispatch_thread_getspecific(0x19uLL);
  v152 = v146 & 0xF00;
  v145 = v152 >> 8;
  v155 = v146 & 0xF000;
  v144 = v155 >> 12;
  v158 = v146 & 0xF0000;
  v143 = (v146 & 0xF0000) >> 16;
  if (v152 >> 8 <= v155 >> 12)
    v52 = v144;
  else
    v52 = v145;
  if (v52 <= v143)
  {
    v50 = v143;
  }
  else
  {
    if (v145 <= v144)
      v51 = v144;
    else
      v51 = v145;
    v50 = v51;
  }
  v83 = v50;
LABEL_22:
  v82 = 0;
  v81 = (unint64_t *)(v91 + 14);
  while (1)
  {
    v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v81) : __ldxr(v81);
    v86 = v15;
    v85 = v15;
    if ((v15 & v87) != 0)
      break;
    v148 = v86;
    v147 = v83;
    v159 = v86;
    v49 = 0;
    if ((v86 & 0x1000000000) != 0)
    {
      v161 = v148 & 0x700000000;
      v49 = v147 < (v148 & 0x700000000) >> 32;
    }
    if (v49)
    {
      __clrex();
      v150 = v86;
      v160 = v86 & 0x700000000;
      v149 = (v86 & 0x700000000) >> 32;
      v164 = _dispatch_thread_getspecific(3uLL);
      v163 = v149;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v166 = v163;
        v165 = 0;
        if (v163)
          v165 = 1 << (v166 + 7);
        _pthread_workqueue_override_start_direct(v164, v165 | 0xFF);
      }
      v168 = v149;
      v167 = _dispatch_thread_getspecific(0x19uLL);
      v169 = v167 & 0xF0000;
      if (v149 > (v167 & 0xF0000) >> 16)
      {
        v167 = v167 & 0xFFF0FFFF | (v168 << 16);
        _dispatch_thread_setspecific(25, v167);
      }
      v83 = v149;
      goto LABEL_22;
    }
    v85 = v85 & 0x7700000001 | v88;
    v151 = v86;
    if ((v86 & 0x10000000000) != 0 || v86 + v89 < 0x20000000000000)
      v85 |= 0x40000000000000uLL;
LABEL_44:
    if (_os_atomic_mo_has_release(2))
      v82 = __stlxr(v85, v81) == 0;
    else
      v82 = __stxr(v85, v81) == 0;
    if (v82)
      goto LABEL_48;
  }
  if (v84)
  {
    v85 ^= v84;
    goto LABEL_44;
  }
  __clrex();
LABEL_48:
  v80 = v82;
  v94 = (v86 & v84) == v84;
  v93 = 1356;
  if ((v86 & v84) != v84)
    _dispatch_abort(v93, v94, v9, v10, v11, v12, v13, v14);
  if ((v86 & v87) != 0)
  {
    v92 = 0;
  }
  else
  {
    v85 &= v84 | 0x60000000000000;
    v86 &= 0x3FFE0000000000uLL;
    v92 = v85 - v86;
  }
  v62 = v92;
LABEL_54:
  if (v62)
  {
    v59 = 0;
    if ((v67 & 0x40000) != 0)
    {
      v59 = 0;
    }
    else
    {
      v99 = v64[21];
      v98 = _dispatch_thread_getspecific(0x19uLL);
      v97 = v98;
      if (v98)
      {
        if ((v99 & 0xFFF) != 0)
        {
          v97 &= 0x880F0000;
          if ((v98 & 0xFFF) <= (v99 & 0xFFF))
            v48 = v99 & 0xFFF;
          else
            v48 = v98 & 0xFFF;
          v97 |= v48;
          v156 = v99 & 0xF000;
          v153 = v97 & 0xF00;
          if (v156 >> 12 <= v153 >> 8)
            v99 &= 0x40000000u;
          else
            v99 &= 0x4400F000u;
          v97 |= v99;
        }
        else
        {
          if ((v97 & 0xFFF) != 0)
            v97 |= 0x40000000u;
          v157 = v99 & 0xF000;
          v154 = v97 & 0xF00;
          if (v157 >> 12 > v154 >> 8)
            v97 = v97 & 0xFFFF0FFF | v99 & 0x400F000;
        }
      }
      else
      {
        v97 = v99 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v97);
      v59 = v98;
    }
    if ((v67 & 0x100000) != 0)
    {
      v73 = v69;
      v72 = 0;
      v71 = v69[20];
      v72 = v71;
      v70 = v71;
      if ((v71 & 0x400000) != 0)
      {
        v111 = v69;
        v110 = 0x400000;
        v108 = -4194305;
        v107 = -4194305;
        v109 = -4194305;
        v105 = 0;
        v46 = v69 + 20;
        v103 = -4194305;
        v102 = -4194305;
        v104 = -4194305;
        v47 = v69[20];
        do
        {
          v16 = v47;
          do
            v17 = __ldaxr(v46);
          while (v17 == v47 && __stlxr(v47 & 0xFFBFFFFF, v46));
          v47 = v17;
        }
        while (v17 != v16);
        v101 = v17;
        v105 = v17;
        v100 = v17;
        v106 = v17 & v109;
      }
    }
    v58 = v64;
    v114 = v64;
    v113 = v67;
    v112 = 0;
    v174 = v64;
    v173 = 256;
    v180 = 1;
    v179 = 730;
    v172 = 0;
    v178 = v64;
    v177 = 0;
    v176 = v64[20];
    v177 = v176;
    v175 = v176;
    v172 = v176 & 0x30000;
    v112 = (v176 & 0x30000) << 8;
    if (v112)
      v113 = v113 & 0xFCFFFFFF | v112;
    v67 = v113;
    do
    {
      if ((v67 & 2) != 0 && (v67 & 0x1000000) == 0)
        _dispatch_last_resort_autorelease_pool_push(v68);
      v57 = v64;
      *(_QWORD *)&v63[1] = v65((uint64_t)v64, v68, v67, &v62);
      if ((v67 & 2) != 0 && (v67 & 0x1000000) == 0)
      {
        v56 = 0uLL;
        v116 = v64;
        v115 = &v56;
        v181 = &v56;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v56, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20, (uint64_t)v116, 21, (uint64_t)v115, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v68);
        v117 = &v56;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v56, v28, v29, v30, v31, v32);
      }
      v75 = *(_QWORD *)&v63[1] != 1;
      v74 = 1955;
      if (*(_QWORD *)&v63[1] == 1)
        _dispatch_abort(v74, v75, v18, v19, v20, v21, v22, v23);
      v45 = 0;
      if (*(_QWORD *)&v63[1])
        v45 = *(_QWORD *)&v63[1] != -1;
      if (v45)
        break;
      v135 = v64;
      v134 = v62;
      v133 = *(_QWORD *)&v63[1] == 0;
      v132 = 0;
      v131 = 0;
      v130 = 0;
      v129 = (unint64_t *)(v64 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v33 = __ldaxr(v129);
        else
          v33 = __ldxr(v129);
        v132 = v33;
        v131 = (v33 - v134) & 0xFFFFFFF700000001;
        v137 = v33;
        if ((v33 & 0xFF80000000000000) == 0)
        {
          v182 = v132;
          if ((v132 & 0x8000000000) != 0)
          {
            __clrex();
            v127 = 0x8000000000;
            v126 = 0x8000000000;
            v128 = 0x8000000000;
            v124 = 0;
            v43 = (unint64_t *)(v135 + 14);
            v122 = 0x8000000000;
            v121 = 0x8000000000;
            v123 = 0x8000000000;
            v44 = *((_QWORD *)v135 + 7);
            do
            {
              v34 = v44;
              do
                v35 = __ldaxr(v43);
              while (v35 == v44 && __stlxr(v44 ^ 0x8000000000, v43));
              v44 = v35;
            }
            while (v35 != v34);
            v120 = v35;
            v124 = v35;
            v119 = v35;
            v125 = v35 ^ v128;
            v136 = 0;
            goto LABEL_119;
          }
          if (v133)
            v131 &= 0xFFFFFFF8FFFFFFFFLL;
          else
            v131 |= 0x8000000000uLL;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v130) = __stlxr(v131, v129) == 0;
          v130 = v130;
        }
        else
        {
          LOBYTE(v130) = __stxr(v131, v129) == 0;
          v130 = v130;
        }
      }
      while (!v130);
      v118 = v130;
      v183 = v132;
      v184 = v132;
      v42 = 0;
      if ((v132 & 0x1000000000) != 0)
        v42 = (v183 & 0x800000000) != 0;
      if (v42)
      {
        v162 = v132 & 0x700000000;
        v170 = v132 & 0x700000000;
        LODWORD(v170) = _dispatch_thread_getspecific(0x19uLL);
        v171 = v170 & 0xF0000;
        if (HIDWORD(v170) > (v170 & 0xF0000) >> 16)
        {
          LODWORD(v170) = v170 & 0xFFF0FFFF;
          LODWORD(v170) = v170 | (HIDWORD(v170) << 16);
          _dispatch_thread_setspecific(25, v170);
        }
      }
      v136 = 1;
LABEL_119:
      if ((v136 & 1) != 0)
      {
        v62 = 0;
        *(_QWORD *)&v63[1] = 0;
        break;
      }
      *(_QWORD *)&v63[1] = _dispatch_thread_getspecific(0x14uLL);
    }
    while ((*(_QWORD *)(**(_QWORD **)&v63[1] + 16) & 0x10000) != 0 || (v63[0] & 1) == 0);
    if ((v67 & 0x40000) == 0)
    {
      v139 = v59;
      v138 = 0;
      v138 = _dispatch_thread_getspecific(0x19uLL);
      v139 &= 0xFFF0FFFF;
      v139 |= v138 & 0xF0000;
      _dispatch_thread_setspecific(25, v139);
    }
  }
  if ((v63[0] & 1) != 0)
  {
    v140 = v64;
    v185 = v64;
    v190 = 772079660;
    v189 = v64;
    v188 = 0;
    v187 = 0;
    v186 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v190, v189, v188, v187, v186);
    v191 = v140;
  }
  if (*(_QWORD *)&v63[1])
    _dispatch_queue_invoke_finish(v64, v68, *(uint64_t (****)())&v63[1], v62);
  else
    _dispatch_release_2_tailcall(v64);
  if ((a3 & 0x100000) != 0)
  {
    v54 = _dispatch_thread_getspecific(0x1BuLL);
    v53 = v54[6];
    if (v53)
    {
      if (*(_BYTE *)(v53 + 6))
        _dispatch_event_loop_drain_timers(v54[6], 6u, v36, v37, v38, v39, v40, v41);
    }
  }
}

uint64_t _dispatch_source_invoke2(uint64_t a1, uint64_t a2, unsigned int a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  BOOL v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  unsigned int v25;
  unsigned int v26;
  BOOL v27;
  uint64_t (***v28)();
  int v29;
  uint64_t v30;
  uint64_t (***v31)();
  uint64_t v32;
  int v35;
  BOOL v39;
  uint64_t v40;
  uint64_t v41;
  unint64_t v42;
  _QWORD *v43;
  _QWORD *v44;
  uint64_t v45;
  _QWORD *v46;

  v32 = 0;
  v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  v30 = *(_QWORD *)(a1 + 88);
  v24 = 0;
  if ((a3 & 0x40000) == 0)
  {
    v44 = _dispatch_thread_getspecific(0x1DuLL);
    if (v44)
      v45 = v44[3];
    else
      v45 = -4;
    v42 = *(_QWORD *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL;
    v23 = 0;
    if (v42)
    {
      v23 = 0;
      if (v42 != -4)
        v23 = v42 != v45;
    }
    v24 = v23;
  }
  if (v24)
    _dispatch_source_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  if (*(_QWORD *)(a1 + 48))
  {
    v35 = a3 | 0x4000000;
    v32 = _dispatch_lane_serial_drain(a1, a2, v35, a4, v7, v8, v9, v10);
    a3 = v35 & 0xFBFFFFFF;
  }
  v28 = &_dispatch_mgr_q;
  v27 = 0;
  if ((*(_BYTE *)(v30 + 29) & 1) != 0)
    v28 = *(uint64_t (****)())(a1 + 24);
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if (v31 != v28)
      return (uint64_t)v28;
    v26 = 0x2000000;
    if ((a3 & 0x10000) != 0)
      v26 = _dispatch_thread_getspecific(0x19uLL);
    v43 = _dispatch_thread_getspecific(0x1DuLL);
    if (v43)
      _dispatch_source_install(a1, v43[3], v26, v11, v12, v13, v14, v15);
    else
      _dispatch_source_install(a1, -4, v26, v11, v12, v13, v14, v15);
  }
  if ((*(_QWORD *)(a1 + 56) & 0xFF80000000000000) != 0)
    return *(_QWORD *)(a1 + 24);
  v22 = 0;
  if ((*(_BYTE *)(v30 + 29) & 2) != 0)
    v22 = *(_QWORD *)(v30 + 104) != 0;
  if (v22 && (*(_DWORD *)(a1 + 80) & 0x10800000) == 0)
  {
    if (v31 != v28)
      return (uint64_t)v28;
    _dispatch_timer_unote_configure(*(_QWORD *)(a1 + 88));
  }
  if (*(_QWORD *)(v30 + 56))
  {
    if (v31 != *(uint64_t (****)())(a1 + 24))
      return *(_QWORD *)(a1 + 24);
    _dispatch_source_registration_callout(a1, (uint64_t)v31, a3);
  }
  if ((*(_QWORD *)(v30 + 16) & 2) != 0)
    _dispatch_source_refs_unregister(a1, 5u, v5, v6, v7, v8, v9, v10);
  v29 = *(_DWORD *)(a1 + 80);
  if ((v29 & 0x10800000) == 0 && *(_QWORD *)(v30 + 72))
  {
    if (v31 != *(uint64_t (****)())(a1 + 24))
      return *(_QWORD *)(a1 + 24);
    _dispatch_source_latch_and_call(a1, (uint64_t)v31, a3, v6, v7, v8, v9, v10);
    v29 = *(_DWORD *)(a1 + 80);
    if ((v29 & 0x90000000) == 0)
    {
      v21 = 1;
      if (!v31[3])
        v21 = *((_DWORD *)v31 + 21) >= 0;
      v27 = v21;
    }
    *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFD | 2;
  }
  if ((v29 & 0x10800000) == 0 || v29 < 0)
    goto LABEL_61;
  if (((*(_BYTE *)(v30 + 29) & 2) == 0 || (*(_QWORD *)(v30 + 16) & 1) != 0) && v31 != v28)
    return (uint64_t)v28;
  v25 = 1;
  if ((v29 & 0x40000000) == 0)
    v25 = 3;
  _dispatch_source_refs_unregister(a1, v25, v5, v6, v7, v8, v9, v10);
  v29 = *(_DWORD *)(a1 + 80);
  if (v29 < 0)
  {
LABEL_61:
    if ((v29 & 0x10800000) != 0 && v29 < 0)
    {
      if (v31 != *(uint64_t (****)())(a1 + 24)
        && (*(_QWORD *)(v30 + 40) || *(_QWORD *)(v30 + 48) || *(_QWORD *)(v30 + 56)))
      {
        v32 = *(_QWORD *)(a1 + 24);
      }
      else
      {
        _dispatch_source_cancel_callout(a1, (uint64_t)v31, a3);
        v29 = *(_DWORD *)(a1 + 80);
      }
      v27 = 0;
    }
    if ((v29 & 0x10800000) == 0)
    {
      if ((*(_BYTE *)(v30 + 29) & 2) != 0)
      {
        if (*(_QWORD *)(v30 + 104))
        {
          v39 = 1;
        }
        else
        {
          v40 = *(_QWORD *)(v30 + 16);
          v18 = 0;
          if (v40)
          {
            v18 = 0;
            if ((v40 & 1) == 0)
              v18 = (v40 & 2) == 0;
          }
          v39 = v18 && *(_QWORD *)(v30 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
        }
      }
      else
      {
        v41 = *(_QWORD *)(v30 + 16);
        v19 = 0;
        if (v41)
        {
          v19 = 0;
          if ((v41 & 1) == 0)
            v19 = (v41 & 2) == 0;
        }
        v39 = v19;
      }
      if (v39)
      {
        if (v31 != v28)
          return (uint64_t)v28;
        if ((*(_QWORD *)(a1 + 56) & 0xFF80000000000000) != 0)
          return *(_QWORD *)(a1 + 24);
        if ((*(_BYTE *)(v30 + 29) & 1) != 0 && (*(_QWORD *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0xFFFFFFFFFFFFFFFCLL)
        {
          if (((*(_WORD *)(a1 + 116) >> 1) & 1) != 0)
          {
            *(_WORD *)(a1 + 116) &= ~2u;
            _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          }
          if (v27)
            return *(_QWORD *)(a1 + 24);
        }
        else
        {
          _dispatch_unote_resume(v30, v4, v5, v6, v7, v8, v9, v10);
          if (!v27)
          {
            v46 = _dispatch_thread_getspecific(0x1DuLL);
            v17 = 0;
            if (_dispatch_thread_getspecific(5uLL))
            {
              v17 = 0;
              if (v46)
              {
                v17 = 0;
                if (v46[3] != -4)
                  v17 = (*(_QWORD *)(v30 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v46[3];
              }
            }
            if (v17)
              _dispatch_event_loop_drain(1u);
          }
        }
      }
    }
    return v32;
  }
  if (v32)
    return v32;
  else
    return -1;
}

void _dispatch_source_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  BOOL v9;
  BOOL v10;
  _BYTE v11[12];
  uint64_t (***v12)();
  uint64_t v13;
  BOOL v14;
  uint64_t v15;
  uint64_t v16;

  v13 = *(_QWORD *)(a1 + 88);
  v12 = &_dispatch_mgr_q;
  *(_DWORD *)&v11[8] = 0;
  *(_QWORD *)v11 = *(unsigned int *)(a1 + 80);
  if ((*(_BYTE *)(v13 + 29) & 1) != 0)
    v12 = (uint64_t (***)())(&dword_0 + 1);
  if ((*(_WORD *)(a1 + 116) & 1) != 0)
  {
    if ((*(_DWORD *)v11 & 0x10800000) != 0)
      goto LABEL_55;
    v10 = 0;
    if ((*(_BYTE *)(v13 + 29) & 2) != 0)
      v10 = *(_QWORD *)(v13 + 104) != 0;
    if (!v10)
    {
LABEL_55:
      if (*(_QWORD *)(v13 + 56))
      {
        *(_QWORD *)&v11[4] = 1;
      }
      else if ((*(_QWORD *)(v13 + 16) & 2) != 0)
      {
        *(_QWORD *)&v11[4] = 1;
      }
      else if ((*(_DWORD *)v11 & 0x10800000) != 0 || !*(_QWORD *)(v13 + 72))
      {
        if ((*(_DWORD *)v11 & 0x10800000) != 0 && *(int *)v11 >= 0)
        {
          if ((*(_BYTE *)(v13 + 29) & 2) == 0 || (*(_QWORD *)(v13 + 16) & 1) != 0)
          {
            if ((*(_DWORD *)v11 & 0x40000000) == 0 || (a3 & 0x10) != 0)
              *(_QWORD *)&v11[4] = v12;
          }
          else
          {
            *(_QWORD *)&v11[4] = 1;
          }
        }
        else if ((*(_DWORD *)v11 & 0x10800000) != 0
               && *(int *)v11 < 0
               && (*(_QWORD *)(v13 + 40) || *(_QWORD *)(v13 + 48) || *(_QWORD *)(v13 + 56)))
        {
          *(_QWORD *)&v11[4] = 1;
        }
        else if ((*(_DWORD *)v11 & 0x10800000) == 0)
        {
          if ((*(_BYTE *)(v13 + 29) & 2) != 0)
          {
            if (*(_QWORD *)(v13 + 104))
            {
              v14 = 1;
            }
            else
            {
              v15 = *(_QWORD *)(v13 + 16);
              v8 = 0;
              if (v15)
              {
                v8 = 0;
                if ((v15 & 1) == 0)
                  v8 = (v15 & 2) == 0;
              }
              v14 = v8 && *(_QWORD *)(v13 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
            }
          }
          else
          {
            v16 = *(_QWORD *)(v13 + 16);
            v9 = 0;
            if (v16)
            {
              v9 = 0;
              if ((v16 & 1) == 0)
                v9 = (v16 & 2) == 0;
            }
            v14 = v9;
          }
          if (v14)
            *(_QWORD *)&v11[4] = v12;
        }
      }
      else
      {
        *(_QWORD *)&v11[4] = 1;
      }
    }
    else
    {
      *(_QWORD *)&v11[4] = v12;
    }
  }
  else
  {
    *(_QWORD *)&v11[4] = v12;
  }
  if (!*(_QWORD *)&v11[4])
    *(_QWORD *)&v11[4] = *(_QWORD *)(a1 + 48) != 0;
  if (*(_QWORD *)&v11[4] == 1 && *(uint64_t (****)())(a1 + 24) == &_dispatch_mgr_q)
    *(_QWORD *)&v11[4] = &_dispatch_mgr_q;
  _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(uint64_t *)&v11[4], a5, a6, a7, a8);
}

void dispatch_source_cancel(dispatch_source_t source)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;

  _dispatch_object_debug((uint64_t)source, "%s", v1, v2, v3, v4, v5, v6, (char)"dispatch_source_cancel");
  _dispatch_retain_2((uint64_t)source);
  v10 = *((_DWORD *)source + 20);
  do
  {
    v7 = v10;
    v8 = (unsigned int *)((char *)source + 80);
    do
      v9 = __ldaxr(v8);
    while (v9 == v10 && __stlxr(v10 | 0x10000000, v8));
    v10 = v9;
  }
  while (v9 != v7);
  if ((v9 & 0x10000000) != 0)
    _dispatch_release_2_tailcall((unsigned int *)source);
  else
    (*(void (**)(dispatch_source_t, _QWORD, uint64_t))(*(_QWORD *)source + 64))(source, 0, 3);
}

void dispatch_source_cancel_and_wait(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v22;
  unsigned int v23;
  BOOL v24;
  BOOL v25;
  BOOL v26;
  unsigned int v27;
  unsigned int v28;
  unint64_t *v29;
  _BOOL4 v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t v33;
  unsigned int *v34;
  _BOOL4 v35;
  uint64_t v36;
  unsigned int v37;
  __int16 v38;
  unint64_t v40;

  v36 = *(_QWORD *)(a1 + 88);
  if (*(_QWORD *)(v36 + 48))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source has a cancel handler";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x637F8);
  }
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_source_cancel_and_wait");
  v34 = (unsigned int *)(a1 + 80);
  while (1)
  {
    v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v34) : __ldxr(v34);
    v38 = HIWORD(v8);
    v37 = v8 | 0x10000000;
    if ((v8 & 0x20000000) != 0)
      break;
    if ((v8 & 0x80000000) == 0
      && ((v8 & 0x40000000) != 0 || (*(_BYTE *)(v36 + 29) & 2) != 0 || (*(_BYTE *)(v36 + 29) & 1) == 0))
    {
      v37 = v8 | 0x30000000;
    }
    if (_os_atomic_mo_has_release(0))
      v35 = __stlxr(v37, v34) == 0;
    else
      v35 = __stxr(v37, v34) == 0;
    if (v35)
      goto LABEL_18;
  }
  __clrex();
LABEL_18:
  if ((v38 & 0x80) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Dispatch source used after last release";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x639B4);
  }
  if ((v38 & 0x8000u) == 0)
  {
    if ((v37 & 0x20000000) != 0)
      goto LABEL_51;
    v33 = (unint64_t)_dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC | 0x60000000000000;
    v29 = (unint64_t *)(a1 + 56);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(5))
        v15 = __ldaxr(v29);
      else
        v15 = __ldxr(v29);
      v32 = v15;
      v26 = 0;
      if (!(v15 >> 53))
        v26 = (v15 & 0xFFFFFFFC) == 0;
      if (v26)
      {
        v31 = v15 & 0x7700000001 | v33;
      }
      else
      {
        if ((v38 & 0x1000) != 0)
        {
          __clrex();
LABEL_37:
          if ((v32 & 0xFF80000000000000) != 0)
          {
            if (v32 >> 58)
            {
              qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Source is suspended";
              qword_E4DA8 = a1;
              __break(1u);
              JUMPOUT(0x63BDCLL);
            }
            dispatch_activate((dispatch_object_t)a1);
            return;
          }
          v25 = 0;
          if (!(v32 >> 53))
            v25 = (v32 & 0xFFFFFFFC) == 0;
          if (v25)
          {
            if (!(HIBYTE(*(_DWORD *)(a1 + 80)) >> 7))
              _dispatch_source_refs_unregister(a1, 3u, v9, v10, v11, v12, v13, v14);
            if (HIBYTE(*(_DWORD *)(a1 + 80)) >> 7)
              _dispatch_source_cancel_callout(a1, 0, 0);
            (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 20);
LABEL_55:
            v28 = *(_DWORD *)(a1 + 80);
            do
            {
LABEL_56:
              if (HIBYTE(v28) >> 7)
                return;
              if (((HIBYTE(v28) >> 5) & 1) != 0)
                goto LABEL_65;
              v27 = v28;
              v22 = (unsigned int *)(a1 + 80);
              do
                v23 = __ldaxr(v22);
              while (v23 == v28 && __stlxr(v28 | 0x20000000, v22));
              v24 = v23 == v28;
              if (v23 != v28)
                v27 = v23;
              v28 = v27;
            }
            while (!v24);
            v28 = v27 | 0x20000000;
LABEL_65:
            _dispatch_wait_on_address(a1 + 80, v28, -1, 0, v16, v17, v18, v19);
            v28 = *(_DWORD *)(a1 + 80);
            goto LABEL_56;
          }
          if (((v32 ^ _dispatch_thread_getspecific(3uLL)) & 0xFFFFFFFC) == 0)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_source_cancel_and_wait called from a source handler";
            qword_E4DA8 = a1;
            __break(1u);
            JUMPOUT(0x63D90);
          }
LABEL_51:
          v40 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
          v20 = __clz(__rbit32(v40));
          if ((_DWORD)v40)
            v21 = v20 + 1;
          else
            v21 = 0;
          (*(void (**)(uint64_t, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, v21, 2);
          dispatch_activate((dispatch_object_t)a1);
          goto LABEL_55;
        }
        v31 = v15 | 0x8000000000;
      }
      if (_os_atomic_mo_has_release(5))
        v30 = __stlxr(v31, v29) == 0;
      else
        v30 = __stxr(v31, v29) == 0;
      if (v30)
        goto LABEL_37;
    }
  }
}

void _dispatch_source_refs_unregister(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int *v15;
  _BOOL4 v16;
  unsigned int v17;

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_source_refs_unregister");
  if ((_dispatch_unote_unregister(*(_QWORD *)(a1 + 88), a2, v8, v9, v10, v11, v12, v13) & 1) != 0)
  {
    _dispatch_source_refs_finalize_unregistration((unsigned int *)a1);
  }
  else
  {
    v15 = (unsigned int *)(a1 + 80);
    while (1)
    {
      v14 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v15) : __ldxr(v15);
      if ((v14 & 0xC0000000) != 0)
        break;
      v17 = v14 | 0x40000000;
      if (_os_atomic_mo_has_release(0))
        v16 = __stlxr(v17, v15) == 0;
      else
        v16 = __stxr(v17, v15) == 0;
      if (v16)
        return;
    }
    __clrex();
  }
}

void _dispatch_source_cancel_callout(uint64_t a1, uint64_t a2, int a3)
{
  unint64_t v3;
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t *v9;
  uint64_t v10;
  unint64_t *v11;
  uint64_t v12;
  _QWORD *v13;
  unint64_t *v14;
  unint64_t v15;
  uint64_t v16;
  unint64_t *v17;

  v17 = *(unint64_t **)(a1 + 88);
  v16 = 0;
  if ((a3 & 0x1000000) != 0)
    v16 = _dispatch_autorelease_pool_push();
  v15 = v17[6];
  do
  {
    v3 = v15;
    v14 = v17 + 6;
    do
      v4 = __ldaxr(v14);
    while (v4 == v15 && __stlxr(0, v14));
    v13 = (_QWORD *)v4;
    v15 = v4;
  }
  while (v4 != v3);
  v17[9] = 0;
  v17[8] = 0;
  v12 = v17[5];
  do
  {
    v5 = v12;
    v11 = v17 + 5;
    do
      v6 = __ldaxr(v11);
    while (v6 == v12 && __stlxr(0, v11));
    v12 = v6;
  }
  while (v6 != v5);
  if (v6)
    _dispatch_source_handler_dispose(v6);
  v10 = v17[7];
  do
  {
    v7 = v10;
    v9 = v17 + 7;
    do
      v8 = __ldaxr(v9);
    while (v8 == v10 && __stlxr(0, v9));
    v10 = v8;
  }
  while (v8 != v7);
  if (v8)
    _dispatch_source_handler_dispose(v8);
  if (v13)
  {
    if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
    {
      if ((*v13 & 0x40) != 0)
        v13[5] = *(_QWORD *)(a1 + 32);
      _dispatch_continuation_pop(v13, 0, a3 & 0xFEFFFFFF, a2);
    }
    else
    {
      _dispatch_source_handler_dispose((uint64_t)v13);
    }
  }
  if (v16)
    _dispatch_autorelease_pool_pop(v16);
}

uint64_t _dispatch_source_merge_evt(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t v23;
  unsigned int *v25;
  int v26;
  unsigned __int8 v27;
  unint64_t v29;

  v27 = BYTE1(a2);
  v26 = a4;
  v25 = (unsigned int *)~*(_QWORD *)(a1 + 8);
  if ((a2 & 0x100) == 0 && !*(_QWORD *)(a1 + 16) && (*(_BYTE *)(a1 + 29) & 2) == 0)
    _dispatch_source_refs_finalize_unregistration(v25);
  if (((v27 >> 1) & 1) != 0)
  {
    if ((v25[20] & 0x4000000) != 0)
    {
      v8 = *(unsigned int *)(a1 + 24);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports or f"
                             "ile descriptors)";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x64644);
    }
    _dispatch_bug_kevent_vanished(a1, a2, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 72) = 0;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent-source[%p]: merged kevent[%p]", v9, v10, v11, v12, v13, v14, v15, 1201);
  _dispatch_object_debug((uint64_t)v25, "%s", v16, v17, v18, v19, v20, v21, (char)"_dispatch_source_merge_evt");
  v29 = (unint64_t)(v26 & 0x3FFF00) >> 8;
  v22 = __clz(__rbit32(v29));
  if ((_DWORD)v29)
    v23 = v22 + 1;
  else
    v23 = 0;
  return (*(uint64_t (**)(unsigned int *, uint64_t, uint64_t))(*(_QWORD *)v25 + 64))(v25, v23, 51);
}

uint64_t _dispatch_interval_config_create(uint64_t a1, unint64_t a2, unint64_t a3, uint64_t a4)
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  BOOL v9;
  unint64_t v11;
  unint64_t v13;
  uint64_t v15;
  unint64_t v17;
  unint64_t v18;

  v9 = (*(_BYTE *)(a4 + 30) & 0x20) != 0;
  v8 = _dispatch_calloc(1, 32);
  *(_DWORD *)(v8 + 24) = 0;
  if (a1 == -1)
  {
    *(_QWORD *)v8 = 0x7FFFFFFFFFFFFFFFLL;
    *(_QWORD *)(v8 + 16) = 0x7FFFFFFFFFFFFFFFLL;
    *(_QWORD *)(v8 + 8) = 0x7FFFFFFFFFFFFFFFLL;
    return v8;
  }
  else
  {
    if (a1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Start value is not DISPATCH_TIME_NOW or DISPATCH_TIME_FOREVER";
      __break(1u);
      JUMPOUT(0x64814);
    }
    if (!a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Setting interval to 0";
      __break(1u);
      JUMPOUT(0x6484CLL);
    }
    v4 = 1892160075;
    if (!v9)
      v4 = 31536000000;
    if (a2 > v4)
    {
      v13 = 31536000000000000;
    }
    else
    {
      v5 = 1000000;
      if (v9)
        v5 = 16666666;
      v13 = a2 * v5;
    }
    if (_dispatch_host_time_nano2mach)
    {
      v18 = _dispatch_host_time_nano2mach(v13);
    }
    else if (v13)
    {
      if (v13 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v13 >= 0x5555555555555555)
        {
          v18 = 3 * (v13 / 0x7D);
        }
        else
        {
          v6 = (3 * v13 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
          v18 = (v6 + ((3 * v13 - v6) >> 1)) >> 6;
        }
      }
      else
      {
        v18 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v18 = 0;
    }
    v15 = (_dispatch_uptime() + v18) / v18 * v18;
    if (a3 > 0x3E8)
    {
      if (a3 != -1)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Passing an invalid leeway";
        __break(1u);
        JUMPOUT(0x64A50);
      }
      if (v9)
      {
        if (_dispatch_host_time_nano2mach)
          v17 = _dispatch_host_time_nano2mach(16666666);
        else
          v17 = (unint64_t)(((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)
                                 + ((unint64_t)(49999998
                                                     - ((0x2FAF07E * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64)) >> 1)) >> 6;
        v11 = v17;
      }
      else
      {
        v11 = v18 >> 1;
      }
    }
    else
    {
      v11 = v18 * a3 / 0x3E8;
    }
    *(_DWORD *)(v8 + 24) = 0;
    *(_QWORD *)v8 = v15;
    *(_QWORD *)(v8 + 8) = v15 + v11;
    *(_QWORD *)(v8 + 16) = v18;
    return v8;
  }
}

uint64_t _dispatch_timer_config_create(uint64_t a1, unint64_t a2, int64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  int v14;
  uint64_t v15;
  uint64_t v16;
  int64_t v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t v24;
  uint64_t *v25;
  int *v26;
  char v27;
  uint64_t v28;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = _dispatch_calloc(1, 32);
  if (v18)
  {
    if ((v18 & 0x8000000000000000) != 0)
      v18 = 0x7FFFFFFFFFFFFFFFLL;
  }
  else
  {
    if (v19 != -1)
      _dispatch_bug_deprecated((uint64_t)"Setting timer interval to 0 requests a 1ns timer, did you mean FOREVER (a one-shot timer)?", v4, v5, v6, v7, v8, v9, v10);
    v18 = 1;
  }
  if (v17 < 0)
    v17 = 0x7FFFFFFFFFFFFFFFLL;
  v14 = 0;
  v13 = 0;
  if (v19 == -1)
  {
    v13 = 0x7FFFFFFFFFFFFFFFLL;
    v14 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v16 + 30));
  }
  else
  {
    v28 = v19;
    v27 = 1;
    v26 = &v14;
    v25 = &v13;
    v24 = 0;
    if (v19 == 0x8000000000000000)
    {
      *v26 = 1;
      *v25 = _dispatch_monotonic_time();
    }
    else if (v19 == -2)
    {
      *v26 = 2;
      *v25 = _dispatch_get_nanoseconds();
    }
    else if (v19)
    {
      if (v28 >= 0)
      {
        *v26 = 0;
        v24 = v28;
      }
      else if ((v28 & 0x4000000000000000) != 0)
      {
        *v26 = 2;
        v24 = -v28;
      }
      else
      {
        *v26 = 1;
        v24 = v28 & 0x7FFFFFFFFFFFFFFFLL;
      }
      if (v24 <= 0x3FFFFFFFFFFFFFFFLL)
        v12 = v24;
      else
        v12 = -1;
      *v25 = v12;
    }
    else
    {
      *v26 = 0;
      *v25 = _dispatch_uptime();
    }
  }
  if (v14 != 2)
  {
    v22 = v18;
    if (_dispatch_host_time_nano2mach)
    {
      v23 = _dispatch_host_time_nano2mach(v22);
    }
    else if (v22)
    {
      if (v22 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v22 < 0x5555555555555555)
          v23 = 3 * v22 / 0x7D;
        else
          v23 = 3 * (v22 / 0x7D);
      }
      else
      {
        v23 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v23 = 0;
    }
    v18 = v23;
    if (!v23)
      v18 = 1;
    v20 = v17;
    if (_dispatch_host_time_nano2mach)
    {
      v21 = _dispatch_host_time_nano2mach(v20);
    }
    else if (v20)
    {
      if (v20 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v20 < 0x5555555555555555)
          v21 = 3 * v20 / 0x7D;
        else
          v21 = 3 * (v20 / 0x7D);
      }
      else
      {
        v21 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v21 = 0;
    }
    v17 = v21;
  }
  if (v18 < 0x7FFFFFFFFFFFFFFFLL && v17 > v18 / 2)
    v17 = v18 / 2;
  *(_DWORD *)(v15 + 24) = v14;
  *(_QWORD *)v15 = v13;
  *(_QWORD *)(v15 + 16) = v18;
  if ((unint64_t)(v13 + v17) >= 0x7FFFFFFFFFFFFFFFLL)
    *(_QWORD *)(v15 + 8) = 0x7FFFFFFFFFFFFFFFLL;
  else
    *(_QWORD *)(v15 + 8) = v13 + v17;
  return v15;
}

void dispatch_after_f(dispatch_time_t when, dispatch_queue_t queue, void *context, dispatch_function_t work)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  _QWORD *v33;
  _QWORD *v34;
  _QWORD *v35;
  _QWORD *v36;
  dispatch_queue_t v37;
  dispatch_queue_t v38;
  _QWORD *v39;
  unint64_t v40;
  unint64_t v41;
  dispatch_source_t v42;
  uint64_t v43;
  char v44;
  dispatch_block_t block;
  void *contexta;
  dispatch_queue_t queuea;
  dispatch_time_t v48;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  dispatch_block_t v54;
  void *v55;
  _QWORD *v56;
  dispatch_queue_t v57;
  _QWORD *v58;
  void *v59;
  uint64_t v60;
  _QWORD *v61;
  uint64_t v62;
  _BOOL8 v63;
  BOOL v64;
  BOOL v65;
  BOOL v66;
  dispatch_queue_t v67;
  unsigned int v68;
  uint64_t v69;
  unint64_t v70;
  _QWORD *v71;
  dispatch_queue_t v72;
  int v73;
  unint64_t v74;
  uint64_t v75;
  void *v76;
  void *v77;
  uint64_t v78;
  int v79;
  uint64_t v80;
  int v81;
  void *v82;
  unsigned int v83;
  _QWORD *v84;
  uint64_t v85;
  int v86;
  uint64_t v87;
  uint64_t v88;
  _QWORD *v89;
  uint64_t v90;
  unsigned int v91;
  void *v92;
  unint64_t v93;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  uint64_t *v98;
  int *v99;
  char v100;
  dispatch_time_t v101;
  int v102;
  int v103;
  _QWORD *v104;
  dispatch_queue_t v105;
  _QWORD *v106;
  dispatch_queue_t v107;

  v48 = when;
  queuea = queue;
  contexta = context;
  block = work;
  v44 = 0;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  if (when == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x6518CLL);
  }
  v40 = _dispatch_timeout(v48, (uint64_t)queue, (uint64_t)context, (uint64_t)work, v4, v5, v6, v7);
  if (v40)
  {
    v41 = _dispatch_after_leeway(v40);
    if (v41 <= 0xF423F)
      v41 = 1000000;
    if (v41 >= 0xDF8475801)
      v41 = 60000000000;
    v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0, 0, queuea);
    v43 = *((_QWORD *)v42 + 11);
    v39 = 0;
    v49 = 0;
    v58 = _dispatch_thread_getspecific(0x16uLL);
    if (v58)
      _dispatch_thread_setspecific(22, v58[2]);
    v49 = v58;
    if (v58)
      v50 = v49;
    else
      v50 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
    v39 = v50;
    v38 = queuea;
    v57 = queuea;
    v56 = v50;
    v55 = contexta;
    v54 = block;
    v53 = 0;
    v52 = 0;
    v51 = 0;
    *v50 = 256;
    v56[4] = v54;
    v56[5] = v55;
    if ((v53 & 0x40000000) == 0)
    {
      v73 = 1;
      v76 = _dispatch_thread_getspecific(4uLL);
      v77 = v76;
      v74 = v76 & 0xFFFFFF;
      v81 = 5;
      v80 = 4096;
      if (v74 <= 0x10FF)
      {
        v75 = v74;
      }
      else
      {
        v79 = 5;
        v78 = 4096;
        v75 = 4351;
      }
      v51 = v75;
    }
    v61 = v56;
    v60 = v53;
    v59 = 0;
    v63 = (int)v53 >= 0;
    v62 = 583;
    if ((int)v53 < 0)
      _dispatch_abort(v62, v63, v8, v9, v10, v11, v12, v13);
    if ((v60 & 0x40) == 0)
    {
      v82 = _dispatch_thread_getspecific(0x1CuLL);
      if (v82)
      {
        v92 = v82;
        os_retain(v82);
      }
      v59 = v82;
    }
    v61[3] = v59;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589);
    v21 = v61[3];
    v86 = 771817476;
    v85 = v21;
    v84 = v61;
    if (v21 != -1)
    {
      v83 = 0;
      v30 = v85 ? *(_DWORD *)(v85 + 32) : 0;
      v83 = v30;
      v91 = v86;
      v90 = v30;
      v89 = v84;
      v88 = 0;
      v87 = 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(v91, v90, v89, v88, v87);
    }
    v72 = v57;
    v71 = v56;
    v70 = v51;
    v69 = v53;
    v68 = 0;
    v67 = v57;
    if (v51)
    {
      v66 = (v69 & 0x20) != 0;
      v65 = 0;
      v65 = (*((_DWORD *)v67 + 21) & 0x40000000) != 0;
      v64 = 0;
      v64 = (*((_DWORD *)v67 + 21) & 0xFFF) != 0;
      if ((v69 & 0x20) != 0)
      {
        v70 |= 0x10000000uLL;
        v93 = v70 >> 8;
        v22 = v70 >> 8;
        v23 = __clz(__rbit32(v22));
        if (v22)
          v24 = v23 + 1;
        else
          v24 = 0;
        v68 = v24;
      }
      else if (v65 || !v64)
      {
        v94 = v70 >> 8;
        v25 = v70 >> 8;
        v26 = __clz(__rbit32(v25));
        if (v25)
          v27 = v26 + 1;
        else
          v27 = 0;
        v68 = v27;
      }
      else
      {
        v70 = 0;
      }
    }
    v71[1] = v70;
    v39[6] = v42;
    v37 = queuea;
    v36 = v39;
    v105 = queuea;
    v104 = v39;
    v103 = 0;
    v102 = 0;
    v107 = queuea;
    v106 = v39;
    v35 = v39;
    v34 = v39;
    *(_QWORD *)(v43 + 40) = v39;
    v33 = v35;
    v32 = 0;
    v31 = 0;
    v101 = v48;
    v100 = 0;
    v99 = &v32;
    v98 = &v31;
    v97 = 0;
    if ((v48 & 0x8000000000000000) != 0)
    {
      if ((v101 & 0x4000000000000000) != 0)
      {
        *v99 = 2;
        v97 = -(uint64_t)v101;
      }
      else
      {
        *v99 = 1;
        v97 = v101 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *v99 = 0;
      v97 = v101;
    }
    if (v97 >> 62)
      v29 = -1;
    else
      v29 = v97;
    *v98 = v29;
    if (v32 != 2)
    {
      v95 = v41;
      if (_dispatch_host_time_nano2mach)
      {
        v96 = _dispatch_host_time_nano2mach(v95);
      }
      else if (v95)
      {
        if (v95 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v95 >= 0x5555555555555555)
          {
            v96 = 3 * (v95 / 0x7D);
          }
          else
          {
            v28 = (3 * v95 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            v96 = (v28 + ((3 * v95 - v28) >> 1)) >> 6;
          }
        }
        else
        {
          v96 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }
      else
      {
        v96 = 0;
      }
      v41 = v96;
    }
    *(_BYTE *)(v43 + 30) |= _dispatch_timer_flags_from_clock(v32);
    *(_QWORD *)(v43 + 80) = v31;
    *(_QWORD *)(v43 + 96) = -1;
    *(_QWORD *)(v43 + 88) = v31 + v41;
    dispatch_activate(v42);
  }
  else
  {
    dispatch_channel_async_f(queuea, contexta, (dispatch_function_t)block);
  }
}

void dispatch_after(dispatch_time_t when, dispatch_queue_t queue, dispatch_block_t block)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  uint64_t *v34;
  uint64_t *v35;
  uint64_t *v36;
  dispatch_queue_t v37;
  dispatch_queue_t v38;
  uint64_t *v39;
  unint64_t v40;
  unint64_t v41;
  dispatch_source_t v42;
  uint64_t v43;
  char v44;
  dispatch_block_t blocka;
  void *context;
  dispatch_queue_t queuea;
  dispatch_time_t v48;
  uint64_t *v49;
  uint64_t *v50;
  uint64_t v51;
  void *v52;
  uint64_t v53;
  uint64_t v54;
  dispatch_block_t v55;
  uint64_t *v56;
  unsigned int *v57;
  int inited;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t *v64;
  unsigned int *v65;
  uint64_t *v66;
  dispatch_block_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t *v70;
  uint64_t v71;
  _BOOL8 v72;
  BOOL v73;
  BOOL v74;
  BOOL v75;
  unsigned int *v76;
  unsigned int v77;
  uint64_t v78;
  unint64_t v79;
  uint64_t *v80;
  unsigned int *v81;
  int v82;
  unint64_t v83;
  uint64_t v84;
  void *v85;
  void *v86;
  uint64_t v87;
  int v88;
  uint64_t v89;
  int v90;
  void *v91;
  unsigned int v92;
  uint64_t *v93;
  uint64_t v94;
  int v95;
  uint64_t v96;
  uint64_t v97;
  uint64_t *v98;
  uint64_t v99;
  unsigned int v100;
  void *object;
  unint64_t v102;
  unint64_t v103;
  unint64_t v104;
  unint64_t v105;
  unint64_t v106;
  uint64_t *v107;
  int *v108;
  char v109;
  dispatch_time_t v110;
  int v111;
  int v112;
  uint64_t *v113;
  dispatch_queue_t v114;
  uint64_t *v115;
  dispatch_queue_t v116;

  v48 = when;
  queuea = queue;
  context = 0;
  blocka = block;
  v44 = 1;
  v43 = 0;
  v42 = 0;
  v41 = 0;
  v40 = 0;
  if (when == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_after called with 'when' == infinity";
    __break(1u);
    JUMPOUT(0x66344);
  }
  v40 = _dispatch_timeout(v48, (uint64_t)queue, (uint64_t)block, v3, v4, v5, v6, v7);
  if (v40)
  {
    v41 = _dispatch_after_leeway(v40);
    if (v41 <= 0xF423F)
      v41 = 1000000;
    if (v41 >= 0xDF8475801)
      v41 = 60000000000;
    v42 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_after, 0, 0, queuea);
    v43 = *((_QWORD *)v42 + 11);
    v39 = 0;
    v49 = 0;
    v66 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
    if (v66)
      _dispatch_thread_setspecific(22, v66[2]);
    v49 = v66;
    if (v66)
      v50 = v49;
    else
      v50 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
    v39 = v50;
    v38 = queuea;
    v57 = (unsigned int *)queuea;
    v56 = v50;
    v55 = blocka;
    v54 = 0;
    v52 = _dispatch_Block_copy(blocka);
    v53 = 272;
    v67 = blocka;
    if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)blocka) == ___dispatch_block_create_block_invoke)
    {
      *v56 = v53;
      v56[5] = (uint64_t)v52;
      inited = _dispatch_continuation_init_slow(v56, v57, v54);
    }
    else
    {
      v51 = _Block_get_invoke_fn((uint64_t)v55);
      v65 = v57;
      v64 = v56;
      v63 = (uint64_t)v52;
      v62 = v51;
      v61 = v54;
      v60 = v53;
      v59 = 0;
      *v56 = v53 | 0x100;
      v64[4] = v62;
      v64[5] = v63;
      if ((v61 & 0x40000000) == 0)
      {
        v82 = 1;
        v85 = _dispatch_thread_getspecific(4uLL);
        v86 = v85;
        v83 = v85 & 0xFFFFFF;
        v90 = 5;
        v89 = 4096;
        if (v83 <= 0x10FF)
        {
          v84 = v83;
        }
        else
        {
          v88 = 5;
          v87 = 4096;
          v84 = 4351;
        }
        v59 = v84;
      }
      v70 = v64;
      v69 = v61;
      v68 = 0;
      v72 = (int)v61 >= 0;
      v71 = 583;
      if ((int)v61 < 0)
        _dispatch_abort(v71, v72, v8, v9, v10, v11, v12, v13);
      if ((v69 & 0x40) == 0)
      {
        v91 = _dispatch_thread_getspecific(0x1CuLL);
        if (v91)
        {
          object = v91;
          os_retain(v91);
        }
        v68 = (uint64_t)v91;
      }
      v70[3] = v68;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v14, v15, v16, v17, v18, v19, v20, 589);
      v21 = v70[3];
      v95 = 771817476;
      v94 = v21;
      v93 = v70;
      if (v21 != -1)
      {
        v92 = 0;
        v30 = v94 ? *(_DWORD *)(v94 + 32) : 0;
        v92 = v30;
        v100 = v95;
        v99 = v30;
        v98 = v93;
        v97 = 0;
        v96 = 0;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(v100, v99, v98, v97, v96);
      }
      v81 = v65;
      v80 = v64;
      v79 = v59;
      v78 = v61;
      v77 = 0;
      v76 = v65;
      if (v59)
      {
        v75 = (v78 & 0x20) != 0;
        v74 = 0;
        v74 = (v76[21] & 0x40000000) != 0;
        v73 = 0;
        v73 = (v76[21] & 0xFFF) != 0;
        if ((v78 & 0x20) != 0)
        {
          v79 |= 0x10000000uLL;
          v102 = v79 >> 8;
          v22 = v79 >> 8;
          v23 = __clz(__rbit32(v22));
          if (v22)
            v24 = v23 + 1;
          else
            v24 = 0;
          v77 = v24;
        }
        else if (v74 || !v73)
        {
          v103 = v79 >> 8;
          v25 = v79 >> 8;
          v26 = __clz(__rbit32(v25));
          if (v25)
            v27 = v26 + 1;
          else
            v27 = 0;
          v77 = v27;
        }
        else
        {
          v79 = 0;
        }
      }
      v80[1] = v79;
      inited = v77;
    }
    v39[6] = (uint64_t)v42;
    v37 = queuea;
    v36 = v39;
    v114 = queuea;
    v113 = v39;
    v112 = 0;
    v111 = 0;
    v116 = queuea;
    v115 = v39;
    v35 = v39;
    v34 = v39;
    *(_QWORD *)(v43 + 40) = v39;
    v33 = v35;
    v32 = 0;
    v31 = 0;
    v110 = v48;
    v109 = 0;
    v108 = &v32;
    v107 = &v31;
    v106 = 0;
    if ((v48 & 0x8000000000000000) != 0)
    {
      if ((v110 & 0x4000000000000000) != 0)
      {
        *v108 = 2;
        v106 = -(uint64_t)v110;
      }
      else
      {
        *v108 = 1;
        v106 = v110 & 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      *v108 = 0;
      v106 = v110;
    }
    if (v106 >> 62)
      v29 = -1;
    else
      v29 = v106;
    *v107 = v29;
    if (v32 != 2)
    {
      v104 = v41;
      if (_dispatch_host_time_nano2mach)
      {
        v105 = _dispatch_host_time_nano2mach(v104);
      }
      else if (v104)
      {
        if (v104 < 0x7FFFFFFFFFFFFFFFLL)
        {
          if (v104 >= 0x5555555555555555)
          {
            v105 = 3 * (v104 / 0x7D);
          }
          else
          {
            v28 = (3 * v104 * (unsigned __int128)0x624DD2F1A9FBE77uLL) >> 64;
            v105 = (v28 + ((3 * v104 - v28) >> 1)) >> 6;
          }
        }
        else
        {
          v105 = 0x7FFFFFFFFFFFFFFFLL;
        }
      }
      else
      {
        v105 = 0;
      }
      v41 = v105;
    }
    *(_BYTE *)(v43 + 30) |= _dispatch_timer_flags_from_clock(v32);
    *(_QWORD *)(v43 + 80) = v31;
    *(_QWORD *)(v43 + 96) = -1;
    *(_QWORD *)(v43 + 88) = v31 + v41;
    dispatch_activate(v42);
  }
  else
  {
    dispatch_channel_async(queuea, blocka);
  }
}

_QWORD *_dispatch_source_handler_dispose(uint64_t a1)
{
  _QWORD *result;
  int v2;
  _QWORD *v4;

  if ((*(_QWORD *)a1 & 0x10) != 0)
    _Block_release(*(const void **)(a1 + 40));
  if (*(_QWORD *)(a1 + 24))
  {
    os_release(*(void **)(a1 + 24));
    *(_QWORD *)(a1 + 24) = -1;
  }
  result = _dispatch_thread_getspecific(0x16uLL);
  if (result)
    v2 = *((_DWORD *)result + 2) + 1;
  else
    v2 = 1;
  if (v2 <= _dispatch_continuation_cache_limit)
  {
    *(_QWORD *)(a1 + 16) = result;
    *(_DWORD *)(a1 + 8) = v2;
    result = (_QWORD *)_dispatch_thread_setspecific(22, a1);
    v4 = 0;
  }
  else
  {
    v4 = (_QWORD *)a1;
  }
  if (v4)
    return _dispatch_continuation_free_to_cache_limit(v4);
  return result;
}

_QWORD *_dispatch_source_set_handler_slow(uint64_t a1)
{
  _QWORD *result;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  uint64_t v9;
  unint64_t *v10;
  unint64_t v11;
  int v12;
  uint64_t v13;
  _QWORD *v14;
  unint64_t v16;
  _QWORD *v17;

  result = _dispatch_thread_getspecific(0x14uLL);
  v14 = result;
  if (*(_QWORD *)(*result + 16) != 275)
    _dispatch_abort(323, *(_QWORD *)(*result + 16) == 275, v2, v3, v4, v5, v6, v7);
  v13 = *(_QWORD *)(a1 + 48);
  *(_QWORD *)(a1 + 48) = 0;
  v16 = a1;
  if (*(_QWORD *)(a1 + 32))
  {
    if ((*(_QWORD *)a1 & 0x40) != 0)
      *(_QWORD *)(a1 + 40) = result[4];
  }
  else
  {
    result = _dispatch_thread_getspecific(0x16uLL);
    if (result)
      v12 = *((_DWORD *)result + 2) + 1;
    else
      v12 = 1;
    if (v12 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(a1 + 16) = result;
      *(_DWORD *)(a1 + 8) = v12;
      result = (_QWORD *)_dispatch_thread_setspecific(22, a1);
      v17 = 0;
    }
    else
    {
      v17 = (_QWORD *)a1;
    }
    if (v17)
      result = _dispatch_continuation_free_to_cache_limit(v17);
    v16 = 0;
  }
  v10 = (unint64_t *)(v14[11] + 40 + 8 * v13);
  v11 = *v10;
  do
  {
    v8 = v11;
    do
      v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v16, v10));
    v11 = v9;
  }
  while (v9 != v8);
  if (v9)
    return _dispatch_source_handler_dispose(v9);
  return result;
}

void _dispatch_source_handle_wlh_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;

  v10 = (unsigned int *)(a1 + 80);
  v11 = *(_DWORD *)(a1 + 80);
  do
  {
    v8 = v11;
    do
      v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 | 0x8000000, v10));
    v11 = v9;
  }
  while (v9 != v8);
  if ((v9 & 0x400000) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after source was activated";
    __break(1u);
    JUMPOUT(0x679A0);
  }
  if ((v9 & 0x8000000) == 0)
    _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after source was activated", a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_source_registration_callout(uint64_t a1, uint64_t a2, int a3)
{
  _QWORD *v3;
  unint64_t *v4;
  _QWORD *v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  uint64_t v9;

  v7 = *(_QWORD *)(a1 + 88);
  v8 = *(_QWORD **)(v7 + 56);
  do
  {
    v3 = v8;
    v4 = (unint64_t *)(v7 + 56);
    do
      v5 = (_QWORD *)__ldaxr(v4);
    while (v5 == v8 && __stlxr(0, v4));
    v6 = (uint64_t)v5;
    v8 = v5;
  }
  while (v5 != v3);
  if ((*(_DWORD *)(a1 + 80) & 0x10800000) != 0)
  {
    v9 = 0;
    if ((a3 & 0x1000000) != 0)
      v9 = _dispatch_autorelease_pool_push();
    _dispatch_source_handler_dispose(v6);
    if (v9)
      _dispatch_autorelease_pool_pop(v9);
  }
  else
  {
    if ((*v5 & 0x40) != 0)
      v5[5] = *(_QWORD *)(a1 + 32);
    _dispatch_continuation_pop(v5, 0, a3, a2);
  }
}

void _dispatch_source_latch_and_call(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unint64_t *v12;
  uint64_t v13;
  BOOL v14;
  unsigned int v15;
  int v16;
  unint64_t *v17;
  unint64_t v18;
  uint64_t v19;
  unint64_t v20;
  _QWORD *v21;
  uint64_t v22;
  int v23;
  uint64_t function_symbol;
  unint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;

  v23 = a3;
  v22 = *(_QWORD *)(a1 + 88);
  v21 = *(_QWORD **)(v22 + 40);
  v17 = (unint64_t *)(v22 + 72);
  v18 = *(_QWORD *)(v22 + 72);
  do
  {
    v8 = v18;
    do
      v9 = __ldaxr(v17);
    while (v9 == v18 && __stlxr(0, v17));
    v18 = v9;
  }
  while (v9 != v8);
  v20 = v9;
  v16 = *(unsigned __int8 *)(*(_QWORD *)v22 + 9);
  if (v16 == 3)
  {
    *(_QWORD *)(v22 + 64) = ~v9;
  }
  else if (v16 == 5)
  {
    if ((v9 & 1) != 0)
    {
      v27 = v9 >> 1;
      v28 = *(_QWORD *)(a1 + 88);
      if (*(_QWORD *)(v28 + 80) < 0x7FFFFFFFFFFFFFFFuLL)
      {
        v15 = *(_DWORD *)(v28 + 24) / 3u;
        if (v15)
          v29 = v15 == 1 ? _dispatch_monotonic_time() : _dispatch_get_nanoseconds();
        else
          v29 = _dispatch_uptime();
        if (v29 >= *(_QWORD *)(v28 + 80))
        {
          v31 = (v29 - *(_QWORD *)(v28 + 80)) / *(_QWORD *)(v28 + 96) + 1;
          if (v31 + v27 > 0x7FFFFFFFFFFFFFFFLL)
            v31 = 0x7FFFFFFFFFFFFFFFLL - v27;
          if (*(_QWORD *)(v28 + 96) >= 0x7FFFFFFFFFFFFFFFuLL)
          {
            *(_QWORD *)(v28 + 80) = -1;
            *(_QWORD *)(v28 + 88) = -1;
          }
          else
          {
            v30 = v31 * *(_QWORD *)(v28 + 96);
            *(_QWORD *)(v28 + 80) += v30;
            *(_QWORD *)(v28 + 88) += v30;
          }
          v27 += v31;
        }
      }
      *(_QWORD *)(v22 + 64) = v27;
    }
    else
    {
      *(_QWORD *)(v22 + 64) = v9 >> 1;
    }
  }
  else
  {
    if (!v9 && *(char *)(v22 + 28) == -23)
      return;
    *(_QWORD *)(v22 + 64) = v9;
  }
  if (v21)
  {
    if (v20)
    {
      if (*(char *)(v22 + 28) == -14)
      {
        function_symbol = _dispatch_continuation_get_function_symbol((uint64_t)v21);
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(67240961, v20, function_symbol, 0, 0);
      }
      _dispatch_continuation_pop(v21, 0, v23, a2);
      if (*(char *)(v22 + 28) == -14 && MEMORY[0xFFFFFC100])
        kdebug_trace(67240962, 0, 0, 0, 0);
      if ((*(_BYTE *)(v22 + 29) & 2) != 0)
      {
        if ((v20 & 1) != 0)
        {
          v14 = 0;
          if ((*(_BYTE *)(v22 + 29) & 2) != 0)
            v14 = *(_QWORD *)(v22 + 104) != 0;
          if (v14)
            _dispatch_timer_unote_configure(*(_QWORD *)(a1 + 88));
        }
        if ((*(_BYTE *)(v22 + 30) & 0x40) != 0)
        {
          if (MEMORY[0xFFFFFC100])
            kdebug_trace(772079660, v21, 0, 0, 0);
          v19 = 0;
          if ((v23 & 0x1000000) != 0)
            v19 = _dispatch_autorelease_pool_push();
          v12 = (unint64_t *)(v22 + 40);
          v13 = *(_QWORD *)(v22 + 40);
          do
          {
            v10 = v13;
            do
              v11 = __ldaxr(v12);
            while (v11 == v13 && __stlxr(0, v12));
            v13 = v11;
          }
          while (v11 != v10);
          if (v11)
            _dispatch_source_handler_dispose(v11);
          if (v19)
            _dispatch_autorelease_pool_pop(v19);
          dispatch_release((dispatch_object_t)a1);
        }
      }
    }
    else
    {
      _dispatch_bug(586, v20 != 0, a3, a4, a5, a6, a7, a8);
    }
  }
  else if (MEMORY[0xFFFFFC100])
  {
    kdebug_trace(771883040, a1, 0, 0, 0);
  }
}

uint64_t _dispatch_monotonic_time()
{
  return mach_continuous_time();
}

__uint64_t _dispatch_get_nanoseconds()
{
  return clock_gettime_nsec_np(_CLOCK_REALTIME);
}

void _dispatch_source_timer_telemetry_slow(uint64_t a1, int a2, uint64_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;

  if ((_dispatch_source_timer_use_telemetry & 1) != 0)
  {
    if (a2 == 2)
      v9 = -*a3;
    else
      v9 = *a3;
    if (__telemetry(1, v9, a3[2], a3[1] - *a3) == -1)
    {
      v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (v10)
        _dispatch_bug(1254, v10, v3, v4, v5, v6, v7, v8);
    }
  }
}

char *_dispatch_source_timer_telemetry_init()
{
  char *result;

  result = getenv("LIBDISPATCH_TIMERS_USE_TELEMETRY");
  if (result)
    _dispatch_source_timer_use_telemetry = 1;
  return result;
}

uint64_t _dispatch_trace_timer_function(uint64_t a1)
{
  uint64_t v3;

  v3 = *(_QWORD *)(a1 + 40);
  if (v3)
    return *(_QWORD *)(v3 + 32);
  else
    return 0;
}

unint64_t _dispatch_after_leeway(unint64_t a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;

  v1 = ((unint64_t)_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  v2 = __clz(__rbit32(v1));
  if (v1)
    v3 = v2 + 1;
  else
    v3 = 0;
  if (v3 <= 3)
    return a1 / 0xA;
  if (v3 == 5 || v3 == 4)
    return a1 / 0xF;
  else
    return a1 / 0x14;
}

uint64_t _dispatch_timer_flags_from_clock(char a1)
{
  return (4 * a1);
}

uint64_t _dispatch_wait_for_enqueuer(unint64_t *a1, uint64_t a2)
{
  int v2;
  unint64_t v3;
  int v5;

  v5 = 10;
  while (1)
  {
    v2 = v5--;
    if (v2 <= 0)
      break;
    v3 = __ldxr(a1);
    if (v3)
    {
      __clrex();
      return v3;
    }
    __wfe();
  }
  return __DISPATCH_WAIT_FOR_ENQUEUER__((uint64_t)a1, a2);
}

uint64_t __DISPATCH_WAIT_FOR_ENQUEUER__(uint64_t a1, uint64_t a2)
{
  int v3;

  v3 = 0;
  while (!*(_QWORD *)a1)
  {
    ++v3;
    _pthread_yield_to_enqueuer_4dispatch(122, a2);
  }
  return *(_QWORD *)a1;
}

_QWORD *dispatch_mach_hooks_install_4libxpc(_QWORD *result)
{
  void *v1;

  if (*result <= 2uLL)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: trying to install hooks with unsupported version";
    qword_E4DA8 = (uint64_t)result;
    __break(1u);
    JUMPOUT(0x693BCLL);
  }
  do
    v1 = (void *)__ldaxr((unint64_t *)&_dispatch_mach_xpc_hooks);
  while (v1 == &_dispatch_mach_xpc_hooks_default
       && __stlxr((unint64_t)result, (unint64_t *)&_dispatch_mach_xpc_hooks));
  if (v1 != &_dispatch_mach_xpc_hooks_default)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_hooks_install_4libxpc called twice";
    qword_E4DA8 = (uint64_t)_dispatch_mach_xpc_hooks;
    __break(1u);
    JUMPOUT(0x694B8);
  }
  return result;
}

void _dispatch_mach_hooks_install_default()
{
  _dispatch_mach_xpc_hooks = &_dispatch_mach_xpc_hooks_default;
}

uint64_t dispatch_mach_create(uint64_t a1, uint64_t (***a2)(), const void *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  void *v8;

  v8 = _dispatch_Block_copy(a3);
  v3 = _Block_get_invoke_fn((uint64_t)v8);
  return _dispatch_mach_create(a1, a2, (uint64_t)v8, v3, 1, v4, v5, v6);
}

uint64_t _dispatch_mach_create(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  char v28;

  v28 = a5;
  v26 = (uint64_t)_dispatch_object_alloc((uint64_t)_OS_dispatch_mach_vtable, 0x88uLL, a3, a4, a5, a6, a7, a8);
  _dispatch_queue_init(v26, 0x400000, 1, 0x180000000000000, v8, v9, v10, v11);
  *(_QWORD *)(v26 + 72) = a1;
  *(_WORD *)(v26 + 116) = *(_WORD *)(v26 + 116) & 0xFFEF | (8 * (v28 & 2));
  *(_WORD *)(v26 + 116) = *(_WORD *)(v26 + 116) & 0xFF7F | (32 * (v28 & 4));
  v27 = _dispatch_unote_create_without_handle((uint64_t)&_dispatch_mach_type_recv, 0, 0);
  if ((*(_BYTE *)(v27 + 29) & 1) == 0)
    _dispatch_abort(131, 0, v12, v13, v14, v15, v16, v17);
  *(_QWORD *)(v27 + 8) = ~v26;
  *(_QWORD *)(v27 + 40) = a4;
  *(_QWORD *)(v27 + 48) = a3;
  *(_BYTE *)(v27 + 29) = *(_BYTE *)(v27 + 29) & 0xBF | ((v28 & 1) << 6);
  if ((*(_WORD *)(v26 + 116) & 0x80) != 0)
    *(_DWORD *)(v27 + 32) |= 0x200u;
  *(_QWORD *)(v26 + 88) = v27;
  v25 = _dispatch_mach_send_create((uint64_t)&_dispatch_mach_type_send, 0, 9);
  *(_QWORD *)(v25 + 8) = ~v26;
  *(_QWORD *)(v26 + 120) = v25;
  if (a2)
  {
    if ((*((_BYTE *)a2 + 87) & 8) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Cannot target object to cooperative root queue - not implemented";
      qword_E4DA8 = (uint64_t)a2;
      __break(1u);
      JUMPOUT(0x697A8);
    }
    _dispatch_retain((uint64_t)a2);
  }
  else
  {
    a2 = &off_E46C0;
  }
  *(_QWORD *)(v26 + 24) = a2;
  _dispatch_object_debug(v26, "%s", v18, v19, v20, v21, v22, v23, (char)"_dispatch_mach_create");
  return v26;
}

uint64_t dispatch_mach_create_f(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 0, a6, a7, a8);
}

uint64_t dispatch_mach_create_4libxpc(uint64_t a1, uint64_t (***a2)(), uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  return _dispatch_mach_create(a1, a2, a3, a4, 6, a6, a7, a8);
}

void _dispatch_mach_dispose(uint64_t *a1, _BYTE *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_dispose");
  _dispatch_unote_dispose(a1[11]);
  a1[11] = 0;
  _dispatch_unote_dispose(a1[15]);
  a1[15] = 0;
  if (a1[16])
  {
    _dispatch_unote_dispose(a1[16]);
    a1[16] = 0;
  }
  _dispatch_lane_class_dispose((uint64_t)a1, a2);
}

uint64_t dispatch_mach_request_no_senders(uint64_t result)
{
  uint64_t v1;

  *(_WORD *)(result + 116) |= 0x20u;
  v1 = *(_QWORD *)(result + 56);
  if ((~v1 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x69A04);
  }
  return result;
}

uint64_t dispatch_mach_notify_no_senders(uint64_t result, char a2)
{
  uint64_t v2;

  *(_WORD *)(result + 116) |= 0x20u;
  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFFBF | ((a2 & 1) << 6);
  v2 = *(_QWORD *)(result + 56);
  if ((~v2 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x69AE0);
  }
  return result;
}

uint64_t dispatch_mach_set_flags(uint64_t result, char a2)
{
  uint64_t v2;

  *(_WORD *)(result + 116) = *(_WORD *)(result + 116) & 0xFF7F | ((a2 & 1) << 7);
  v2 = *(_QWORD *)(result + 56);
  if ((~v2 & 0x180000000000000) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch queue/source property setter called after activation";
    qword_E4DA8 = v2;
    __break(1u);
    JUMPOUT(0x69BACLL);
  }
  return result;
}

void dispatch_mach_connect(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v12;

  v12 = *(_QWORD *)(a1 + 120);
  if (a2 && a2 != -1)
    *(_DWORD *)(*(_QWORD *)(a1 + 88) + 24) = a2;
  *(_DWORD *)(v12 + 92) = a3;
  if ((_DWORD)a3 && (_DWORD)a3 != -1)
  {
    if (a4)
    {
      dispatch_retain((dispatch_object_t)a4);
      *(_DWORD *)(a4 + 48) = _dispatch_mach_checkin_options();
      *(_DWORD *)(v12 + 96) = _dispatch_mach_msg_get_remote_port(a4);
    }
    *(_QWORD *)(v12 + 48) = a4;
  }
  if ((*(_WORD *)(a1 + 116) & 0x20) != 0 && !*(_QWORD *)(v12 + 48))
    _dispatch_mach_arm_no_senders(a1, 0);
  v10 = (unsigned int *)(v12 + 88);
  v11 = *(_DWORD *)(v12 + 88);
  do
  {
    v8 = v11;
    do
      v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 & 0x7FFFFFFF, v10));
    v11 = v9;
  }
  while (v9 != v8);
  if (!(HIBYTE(v9) >> 7))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel already connected";
    qword_E4DA8 = v9;
    __break(1u);
    JUMPOUT(0x69DC4);
  }
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_mach_connect");
  dispatch_activate((dispatch_object_t)a1);
}

uint64_t _dispatch_mach_checkin_options()
{
  return 0x40000;
}

uint64_t _dispatch_mach_msg_get_remote_port(uint64_t a1)
{
  return *(unsigned int *)(_dispatch_mach_msg_get_msg(a1) + 8);
}

void _dispatch_mach_arm_no_senders(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  kern_return_t v14;
  kern_return_t v15;
  mach_port_t previous;
  mach_port_name_t v17;
  char v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v19 = a1;
  v18 = a2;
  v17 = 0;
  v17 = *(_DWORD *)(*(_QWORD *)(a1 + 88) + 24);
  previous = 0;
  if (v17 && v17 != -1)
  {
    v14 = mach_port_request_notification(mach_task_self_, v17, 70, ((*(unsigned __int16 *)(v19 + 116) >> 6) & 1) == 0, v17, 0x15u, &previous);
    if (v14 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x69F5CLL);
    }
    v23 = v14;
    v22 = 252;
    if (v14)
      _dispatch_bug(v22, v23, v2, v3, v4, v5, v6, v7);
  }
  if (previous)
  {
    if ((v18 & 1) == 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Mach port notification collision";
      qword_E4DA8 = previous;
      __break(1u);
      JUMPOUT(0x6A000);
    }
    v15 = mach_port_deallocate(mach_task_self_, previous);
    if (v15 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x6A06CLL);
    }
    v21 = v15;
    v20 = 260;
    if (v15)
      _dispatch_bug(v20, v21, v8, v9, v10, v11, v12, v13);
  }
}

void _dispatch_mach_merge_msg(uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  unsigned int v38;
  dispatch_object_s *recv;
  BOOL is_kernel;
  unsigned int *v41;
  _QWORD *v49;
  _QWORD *v50;
  uint64_t v51;

  if ((a2 & 0x200) != 0)
  {
    v7 = *(unsigned int *)(a1 + 24);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    qword_E4DA8 = v7;
    __break(1u);
    JUMPOUT(0x6A140);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x", v8, v9, v10, v11, v12, v13, v14, 676);
  v41 = (unsigned int *)~*(_QWORD *)(a1 + 8);
  if (((HIBYTE(*(_DWORD *)(79 - *(_QWORD *)(a1 + 8))) >> 4) & 1) != 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v17, v18, v19, v20, v21, v22, v23, 681);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0)
      free(a3);
  }
  else if (a3->msgh_id == 70 && (*(_WORD *)(115 - *(_QWORD *)(a1 + 8)) & 0x20) != 0)
  {
    is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)a3);
    if (is_kernel)
    {
      v50 = _dispatch_thread_getspecific(0x16uLL);
      if (v50)
      {
        _dispatch_thread_setspecific(22, v50[2]);
        v49 = v50;
      }
      else
      {
        v49 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
      }
      *v49 = 260;
      v49[4] = _dispatch_mach_no_senders_invoke;
      v49[5] = v41;
      v49[3] = 0;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v30, v31, v32, v33, v34, v35, v36, 589);
      v51 = v49[3];
      if (v51 != -1)
      {
        v38 = v51 ? *(_DWORD *)(v51 + 32) : 0;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(771817476, v38, v49, 0, 0);
      }
      v49[1] = 0;
      (*(void (**)(unsigned int *, _QWORD *, _QWORD))(*(_QWORD *)v41 + 72))(v41, v49, 0);
    }
    else
    {
      _dispatch_bug(687, is_kernel, v24, v25, v26, v27, v28, v29);
    }
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0)
      free(a3);
  }
  else
  {
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, 0, a2, a6, v15, v16);
    _dispatch_mach_handle_or_push_received_msg((uint64_t)v41, recv, a7);
  }
  v37 = 1;
  if ((*(_QWORD *)(a1 + 16) & 2) == 0)
    v37 = (((unint64_t)v41[15] << 32) & 0x180000000000000) == 0x80000000000000;
  if (v37)
    (*(void (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)v41 + 64))(v41, 0, 51);
  else
    _dispatch_release_2_tailcall(v41);
}

uint64_t _dispatch_mach_no_senders_invoke(uint64_t result)
{
  if ((*(_DWORD *)(result + 80) & 0x10000000) == 0)
    return _dispatch_client_callout4(*(_QWORD *)(*(_QWORD *)(result + 88) + 48), 13, 0, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(result + 88) + 40));
  return result;
}

_QWORD *_dispatch_mach_msg_create_recv(_DWORD *a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v28;
  uint64_t v29;
  _QWORD *v30;
  _QWORD *v31;
  int v32;
  uint64_t v33;
  int v34;
  uint64_t v38;
  uint64_t v39;
  mach_port_name_t v40;
  unsigned int v41;

  v34 = a5;
  v32 = a6;
  if (a4)
  {
    v41 = (*a1 & 0x1F0000u) >> 16;
    v40 = a1[4];
    if ((v41 == 19 || v41 == 17) && v40)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v8, v9, v10, v11, v12, v13, v14, 520);
      if (v41 == 17)
        _voucher_dealloc_mach_voucher(v40);
      a1[4] = 0;
      *a1 &= 0xFFE0FFFF;
    }
    v33 = *(unsigned int *)(a4 + 40);
    v30 = *(_QWORD **)(a4 + 56);
    *(_QWORD *)(a4 + 56) = 0;
  }
  else
  {
    v30 = _voucher_create_with_mach_msgv(a1, a3, (uint64_t)a3, 0, a5, a6, a7, a8);
    if ((v32 & 0xFFFFFFu) <= 0x10FFuLL)
      v38 = v32 & 0xFFFFFF;
    else
      v38 = 4351;
    v33 = v38;
  }
  v31 = dispatch_mach_msg_create((uint64_t)a1, a2, (v34 & 0x10000) != 0, 0, a5, a6, a7, a8);
  if ((v34 & 0x10000) == 0 && MEMORY[0xFFFFFC100])
    kdebug_trace(771948548, a1, v31 + 11, 0, 0);
  v31[8] = v30;
  v31[7] = v33;
  if (a4)
    v29 = *(_QWORD *)(a4 + 48);
  else
    v29 = 0;
  v31[4] = v29;
  _dispatch_mach_msg_set_reason((uint64_t)v31, 0, 2, v15, v16, v17, v18, v19);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] create", v20, v21, v22, v23, v24, v25, v26, 646);
  v39 = v31[8];
  if (v39 != -1)
  {
    if (v39)
      v28 = *(_DWORD *)(v39 + 32);
    else
      v28 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817484, v28, v31, 0, 0);
  }
  return v31;
}

void _dispatch_mach_handle_or_push_received_msg(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  uint64_t reason;
  unsigned int v12;
  uint64_t v13;
  dispatch_object_s *v14;
  uint64_t v15;
  int v16;
  int v17;
  dispatch_object_s *v18;
  uint64_t v19;
  unint64_t v20;
  unsigned int v21;
  dispatch_object_s *v22;
  uint64_t v23;

  v15 = a1;
  v14 = a2;
  v13 = a3;
  v12 = 0;
  reason = _dispatch_mach_msg_get_reason((uint64_t)a2, (int *)&v12);
  if (reason != 2
    && ((*(_WORD *)(v15 + 116) >> 4) & 1) != 0
    && ((*(uint64_t (**)(_QWORD, uint64_t, dispatch_object_s *, _QWORD))((char *)&dword_8
                                                                                + (_QWORD)_dispatch_mach_xpc_hooks))(*(_QWORD *)(*(_QWORD *)(v15 + 88) + 48), reason, v14, v12) & 1) != 0)
  {
    *((_QWORD *)v14 + 2) = -1985229329;
    dispatch_release(v14);
  }
  else
  {
    v19 = v15;
    v18 = v14;
    v17 = 0;
    v16 = 0;
    v23 = v15;
    v22 = v14;
    v20 = v13 & 0x3FFF00;
    v20 >>= 8;
    v8 = __clz(__rbit32(v20));
    if ((_DWORD)v20)
      v9 = v8 + 1;
    else
      v9 = 0;
    v10 = v9;
    if (!v9)
    {
      v21 = *(_DWORD *)(v15 + 84);
      v21 &= 0xF00u;
      v10 = v21 >> 8;
    }
    _dispatch_lane_push(v15, v14, v10, v3, v4, v5, v6, v7);
  }
}

void _dispatch_mach_reply_merge_msg(uint64_t a1, unsigned int a2, mach_msg_header_t *a3, unsigned int a4, _DWORD *a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  char v35;
  uint64_t v36;
  dispatch_object_s *recv;
  BOOL v38;
  uint64_t v39;
  uint64_t v47;
  _QWORD *v48;

  v39 = ~*(_QWORD *)(a1 + 8);
  v38 = (*(_DWORD *)(79 - *(_QWORD *)(a1 + 8)) & 0x10000000) != 0;
  recv = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, reply on 0x%08x", v7, v8, v9, v10, v11, v12, v13, 737);
  if (!v38)
    recv = (dispatch_object_s *)_dispatch_mach_msg_create_recv(a3, a4, a5, a1, a2, a6, v14, v15);
  if (recv)
  {
    v36 = 0;
    if (((*(_WORD *)(v39 + 116) >> 4) & 1) != 0 && *((_QWORD *)recv + 4))
    {
      v47 = (*(uint64_t (**)(_QWORD))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(*((_QWORD *)recv + 4));
      if (!v47)
        v47 = v39;
      v36 = v47;
    }
    if (v36)
    {
      v48 = _dispatch_mach_msg_async_reply_wrap((uint64_t)recv, v39);
      v19 = (*((_QWORD *)recv + 7) & 0x3FFF00uLL) >> 8;
      v20 = __clz(__rbit32(v19));
      if (v19)
        v21 = v20 + 1;
      else
        v21 = 0;
      (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v36 + 72))(v36, v48, v21, v16, v17, v18);
    }
    else
    {
      _dispatch_mach_handle_or_push_received_msg(v39, recv, a7);
    }
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v28, v29, v30, v31, v32, v33, v34, 755);
    mach_msg_destroy(a3);
    if ((a2 & 0x10000) != 0)
      free(a3);
  }
  v35 = 101;
  if (v38)
    v35 = 117;
  if ((*(_QWORD *)(a1 + 16) & 2) == 0)
    _dispatch_abort(765, (*(_QWORD *)(a1 + 16) & 2) != 0, v22, v23, v24, v25, v26, v27);
  _dispatch_mach_reply_unregister((unsigned int *)v39, a1, v35);
}

void _dispatch_mach_reply_unregister(unsigned int *a1, uint64_t a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  unsigned int v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v39;
  unsigned int v40;
  uint64_t v41;
  unsigned int *v42;
  unsigned int v43;
  uint64_t v44;
  dispatch_object_s *reply_disconnected;
  char v46;
  BOOL v47;
  uint64_t v48;
  BOOL v49;
  uint64_t v53;
  _QWORD *v54;
  unsigned int v55;
  unsigned int v56;

  v49 = *(_QWORD *)a2 == -2;
  v48 = *((_QWORD *)a1 + 15);
  v47 = (a3 & 0x10) != 0;
  v46 = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistering for%s reply%s, ctxt %p", v3, v4, v5, v6, v7, v8, v9, 355);
  if ((a3 & 0x20) != 0)
  {
    v55 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v23 = (unsigned int *)(v48 + 40);
    do
      v24 = __ldaxr(v23);
    while (!v24 && __stlxr(v55, v23));
    if (v24)
      _dispatch_unfair_lock_lock_slow((unsigned int *)(v48 + 40), 0x10000);
    _dispatch_mach_reply_list_remove_locked(a2, v16, v17, v18, v19, v20, v21, v22);
    if (!*(_QWORD *)(v48 + 56) && *(_DWORD *)(v48 + 88))
      v46 = 1;
    v56 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    v42 = (unsigned int *)(v48 + 40);
    v43 = *(_DWORD *)(v48 + 40);
    do
    {
      v25 = v43;
      do
        v26 = __ldaxr(v42);
      while (v26 == v43 && __stlxr(0, v42));
      v43 = v26;
    }
    while (v26 != v25);
    if (v26 != v56)
      _dispatch_unfair_lock_unlock_slow(v48 + 40, v26);
  }
  if (!*(_QWORD *)(a2 + 16) || (_dispatch_unote_unregister(a2, a3 & 0xF, v10, v11, v12, v13, v14, v15) & 1) != 0)
  {
    reply_disconnected = 0;
    v44 = 0;
    if (v47)
    {
      if (((*((_WORD *)a1 + 58) >> 4) & 1) != 0 && *(_QWORD *)(a2 + 48))
      {
        v53 = (*(uint64_t (**)(_QWORD))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(*(_QWORD *)(a2 + 48));
        if (!v53)
          v53 = (uint64_t)a1;
        v44 = v53;
      }
      if (v44)
        v29 = 12;
      else
        v29 = 7;
      reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected(0, a2, v29, v11, v12, v13, v14, v15);
      if (*(_QWORD *)(a2 + 56))
        _dispatch_abort(387, *(_QWORD *)(a2 + 56) == 0, v30, v31, v32, v33, v34, v35);
    }
    else if (*(_QWORD *)(a2 + 56))
    {
      os_release(*(void **)(a2 + 56));
      *(_QWORD *)(a2 + 56) = 0;
    }
    if (!v49)
      _dispatch_unote_dispose(a2);
    if (reply_disconnected)
    {
      if (v44)
      {
        v54 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, (uint64_t)a1);
        v39 = (*((_QWORD *)reply_disconnected + 7) & 0x3FFF00uLL) >> 8;
        v40 = __clz(__rbit32(v39));
        if (v39)
          v41 = v40 + 1;
        else
          v41 = 0;
        (*(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v44 + 72))(v44, v54, v41, v36, v37, v38);
      }
      else
      {
        _dispatch_mach_handle_or_push_received_msg((uint64_t)a1, reply_disconnected, 0);
      }
    }
    if ((a3 & 0x40) != 0)
    {
      if ((v46 & 1) != 0)
        (*(void (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, 0, 3);
      else
        _dispatch_release_2_tailcall(a1);
    }
  }
  else
  {
    if (v49)
      _dispatch_abort(368, !v49, v27, v11, v12, v13, v14, v15);
    if (a3 < 0)
    {
      v28 = *(_QWORD *)(v48 + 56);
      *(_QWORD *)(a2 + 64) = v28;
      if (v28)
        *(_QWORD *)(*(_QWORD *)(v48 + 56) + 72) = a2 + 64;
      *(_QWORD *)(v48 + 56) = a2;
      *(_QWORD *)(a2 + 72) = v48 + 56;
    }
  }
}

uint64_t _dispatch_mach_send_barrier_drain_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v31;
  void *v32;
  uint64_t v33;
  uint64_t v34;
  BOOL v35;
  unsigned int v36;
  __int16 v37;
  _QWORD *v38;
  uint64_t v39;
  __int128 v40;
  uint64_t v41;
  void *v42;
  void *v43;
  uint64_t v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  void *v48;
  void *v49;
  __int128 *v50;
  uint64_t v51;
  _DWORD *v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v60;
  int v61;
  _DWORD *v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  __int128 *v66;
  unsigned int v67;
  uint64_t v68;
  _DWORD *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unsigned int v75;
  __int128 *v76;
  _OWORD *v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unsigned int v82;
  BOOL v83;
  unint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unsigned int v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void *object;
  uint64_t v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  unsigned int v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _BOOL8 v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  uint64_t v129;
  unsigned int v130;
  uint64_t v131;

  v47 = a1;
  v46 = a2;
  v45 = a3;
  v43 = _dispatch_thread_getspecific(0x14uLL);
  v48 = v43;
  v49 = v43;
  v42 = v43;
  v44 = (uint64_t)v43;
  v41 = 516;
  v40 = 0uLL;
  v50 = &v40;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v40, 0x15uLL, (pthread_key_t *)&v40 + 1, v3, v4, v5, v6);
  v77 = (_OWORD *)*((_QWORD *)v50 + 1);
  _dispatch_thread_setspecific_packed_pair(20, 21, v77, v7, v8, v9, v10, v11);
  v39 = v47;
  v37 = v41;
  v54 = v47;
  v53 = v41;
  v52 = 0;
  v52 = *(_DWORD **)(v47 + 24);
  v51 = v41 & 4;
  v56 = 1;
  v55 = 600;
  if ((v41 & 4) != 0)
    *(_QWORD *)(v54 + 24) = -1;
  if (v52 != (_DWORD *)-1)
  {
    v70 = 771817480;
    v69 = v52;
    v68 = v54;
    v67 = 0;
    if (v52)
      v36 = v69[8];
    else
      v36 = 0;
    v67 = v36;
    v75 = v70;
    v74 = v36;
    v73 = v68;
    v72 = 0;
    v71 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v75, v74, v73, v72, v71);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v18, v19, v20, v21, v22, v23, v24, 607);
  }
  v81 = *(_QWORD *)(v54 + 8);
  v80 = (uint64_t)v52;
  v79 = v51 | 2;
  v78 = 0;
  if (v81 != -1)
  {
    v88 = v81;
    v87 = v79;
    v86 = 0;
    v86 = _dispatch_thread_getspecific(0x19uLL);
    v85 = 0;
    v101 = v86;
    v104 = v86 & 0xF00;
    v100 = v104 >> 8;
    v99 = v86;
    if (v104 >> 8)
      v99 |= 1 << (v100 + 7);
    v85 = v99;
    v102 = v99;
    v84 = v99 & 0xFFFFFF00;
    v83 = 0;
    v35 = 1;
    if ((v87 & 1) == 0)
      v35 = (v88 & 0x10000000) != 0;
    v83 = v35;
    v90 = v88;
    v88 &= 0xFFFFFFu;
    if (v88)
    {
      if (v88 >= v84)
      {
        if (v83 || (v86 & 0x44000000) != 0)
          v89 = v88;
        else
          v89 = v85;
      }
      else
      {
        v89 = v85;
      }
    }
    else
    {
      v103 = v86 & 0xF000;
      v82 = v103 >> 12;
      if (v103 >> 12)
      {
        v92 = v82;
        v91 = 1 << (v82 + 7);
        v34 = v91 | 0xFF;
      }
      else
      {
        v34 = v85;
      }
      v89 = v34;
    }
    v78 = v89;
  }
  v96 = v78;
  v95 = v80;
  v94 = v79;
  v108 = v78;
  v111 = v78 != -1;
  v110 = 2332;
  if (v78 == -1)
    _dispatch_abort(v110, v111, v12, v13, v14, v15, v16, v17);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v122 = v108;
    v121 = 4261412863;
    v120 = 0;
    v108 &= 0xFFFFFFFF02FFFFFFLL;
    v107 = 0;
    v112 = 0;
    v112 = _dispatch_thread_getspecific(4uLL);
    v107 = (unint64_t)v112;
    v106 = 0x1000000;
    v105 = 2281701376;
    if ((v112 & 0x1000000) != 0)
    {
      if (v108)
      {
        v33 = v108;
      }
      else
      {
        v116 = v107;
        v115 = v106;
        v114 = 0;
        v33 = v107 & (~v106 | 0xFFFFFF);
      }
      v109 = v33;
    }
    else
    {
      v119 = v107;
      v118 = v105;
      v117 = 0;
      v107 &= ~v105 | 0xFFFFFF;
      if (v108 == v107)
        v109 = 0;
      else
        v109 = v108;
    }
  }
  else
  {
    v109 = 0;
  }
  v96 = v109;
  if (v109)
    goto LABEL_52;
  if (v95 == -1)
  {
    v97 = -1;
    goto LABEL_53;
  }
  v32 = (void *)v95;
  if (v32 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_52:
    v97 = _dispatch_set_priority_and_voucher_slow(v96, (_DWORD *)v95, v94);
  }
  else
  {
    v93 = (v94 & 4) != 0;
    if ((v94 & 2) != 0)
    {
      if (v93 && v95)
      {
        v113 = v95;
        os_release((void *)v95);
      }
      v95 = -1;
    }
    else if (!v93 && v95)
    {
      object = (void *)v95;
      os_retain((void *)v95);
    }
    v97 = v95;
  }
LABEL_53:
  if ((v37 & 0x200) == 0)
  {
    v60 = v44;
    v59 = v47;
    v58 = 0;
    v57 = 0;
    v124 = v44;
    v123 = v47;
  }
  if ((v37 & 4) != 0)
  {
    v63 = v39;
    v62 = 0;
    v62 = _dispatch_thread_getspecific(0x16uLL);
    v61 = 0;
    if (v62)
      v31 = v62[2] + 1;
    else
      v31 = 1;
    v61 = v31;
    if (v31 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(v63 + 16) = v62;
      *(_DWORD *)(v63 + 8) = v61;
      _dispatch_thread_setspecific(22, v63);
      v64 = 0;
    }
    else
    {
      v64 = v63;
    }
    v38 = (_QWORD *)v64;
  }
  else
  {
    v38 = 0;
  }
  _dispatch_mach_send_invoke(v44, v45, 6u);
  if ((v37 & 0x200) == 0)
  {
    v65 = v39;
    v125 = v39;
    v130 = 772079660;
    v129 = v39;
    v128 = 0;
    v127 = 0;
    v126 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v130, v129, v128, v127, v126);
    v131 = v65;
  }
  if (v38)
    _dispatch_continuation_free_to_cache_limit(v38);
  v66 = &v40;
  v76 = &v40;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v40, v25, v26, v27, v28, v29);
}

uint64_t _dispatch_mach_send_invoke(uint64_t a1, int a2, unsigned int a3)
{
  uint64_t result;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unint64_t v9;
  unsigned int v10;
  int v11;
  unsigned int v12;
  unint64_t *v13;
  _BOOL4 v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  unsigned int v29;
  uint64_t v30;
  unsigned int v31;

  v21 = *(_QWORD *)(a1 + 120);
  v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v17 = 0xFFFFFFFFLL;
  v16 = 0;
  if ((a3 & 2) != 0)
  {
    v17 = 0x10FFFFFFFFLL;
    v16 = 0x1000000000;
  }
  else if ((a3 & 4) == 0)
  {
    v17 = 0x10FFFFFFFFLL;
  }
  v26 = _dispatch_thread_getspecific(0x19uLL);
  v25 = (unsigned __int16)(v26 & 0xF000) >> 12;
  if ((unsigned __int16)(v26 & 0xF00) >> 8 <= v25)
    v12 = (unsigned __int16)(v26 & 0xF000) >> 12;
  else
    v12 = (unsigned __int16)(v26 & 0xF00) >> 8;
  if (v12 <= (v26 & 0xF0000) >> 16)
  {
    v10 = (v26 & 0xF0000) >> 16;
  }
  else
  {
    if ((unsigned __int16)(v26 & 0xF00) >> 8 <= v25)
      v11 = (unsigned __int16)(v26 & 0xF000) >> 12;
    else
      v11 = (unsigned __int16)(v26 & 0xF00) >> 8;
    v10 = v11;
  }
  v15 = v10;
LABEL_15:
  v13 = (unint64_t *)(v21 + 64);
  while (1)
  {
    result = _os_atomic_mo_has_acquire(2);
    v9 = (_DWORD)result ? __ldaxr(v13) : __ldxr(v13);
    v19 = v9;
    if ((v9 & v17) != v16)
      break;
    if (v15 < (v9 & 0x700000000) >> 32)
    {
      __clrex();
      v27 = (v9 & 0x700000000) >> 32;
      v29 = _dispatch_thread_getspecific(3uLL);
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v30 = 0;
        v28 = (v19 & 0x700000000) >> 32;
        if (v28)
          v30 = 1 << (v28 + 7);
        _pthread_workqueue_override_start_direct(v29, v30 | 0xFF);
      }
      v31 = _dispatch_thread_getspecific(0x19uLL);
      if (v27 > (v31 & 0xF0000) >> 16)
        _dispatch_thread_setspecific(25, v31 & 0xFFF0FFFF | (v27 << 16));
      v15 = (v19 & 0x700000000) >> 32;
      goto LABEL_15;
    }
    v18 = (v9 | v20) & 0xFFFFFFC7FFFFFFFFLL;
LABEL_32:
    result = _os_atomic_mo_has_release(2);
    if ((_DWORD)result)
      v14 = __stlxr(v18, v13) == 0;
    else
      v14 = __stxr(v18, v13) == 0;
    if (v14)
      goto LABEL_36;
  }
  if ((a3 & 1) != 0)
  {
    v18 = v9 | 0x2000000000;
    goto LABEL_32;
  }
  __clrex();
LABEL_36:
  if ((v19 & v17) == v16)
    return _dispatch_mach_send_drain(a1, a2, a3, v4, v5, v6, v7, v8);
  return result;
}

void _dispatch_mach_notification_merge_evt(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;

  v3 = ~*(_QWORD *)(a1 + 8);
  if ((a3 & *(_DWORD *)(a1 + 32)) != 0)
    _dispatch_mach_send_invoke(v3, 0x40000, 1u);
  _dispatch_release_2_tailcall((unsigned int *)v3);
}

uint64_t dispatch_mach_send(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if ((_WORD)a3)
    _dispatch_abort(1906, (unsigned __int16)a3, a3, a4, a5, a6, a7, a8);
  result = _dispatch_mach_send_msg(a1, a2, 0, a3 & 0xFFFF0000);
  if ((result & 1) != 0)
    _dispatch_abort(1909, !(result & 1), v9, v10, v11, v12, v13, v14);
  return result;
}

uint64_t _dispatch_mach_send_msg(uint64_t a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unsigned int v40;
  unint64_t v41;
  int v42;
  char v43;
  unsigned int v44;
  _DWORD *msg;
  unsigned int v46;
  uint64_t v47;
  unint64_t v52;
  uint64_t v53;
  char v54;
  int v55;
  uint64_t v57;
  unint64_t v58;
  uint64_t v59;
  void *v60;

  v47 = *(_QWORD *)(a1 + 120);
  if (*(_QWORD *)(a2 + 16) != -1985229329)
  {
    v4 = *(_QWORD *)(a2 + 16);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message already enqueued";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x6D958);
  }
  if ((*(_WORD *)(a1 + 116) & 0x10) != 0 && (a4 & 4) == 0 && _dispatch_mach_msg_get_reply_port(a2))
  {
    v57 = (*(uint64_t (**)(_QWORD))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(*(_QWORD *)(a2 + 32));
    if (!v57)
      v57 = a1;
    if (!v57)
      _dispatch_abort(1830, 0, v5, v6, v7, v8, v9, v10);
  }
  if ((a4 & 0x40000) != 0)
  {
    *(_QWORD *)(a2 + 56) = 0;
  }
  else
  {
    v54 = 1;
    if ((a4 & 4) != 0)
      v54 = 3;
    v58 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if ((v54 & 2) != 0 || v58 <= 0x10FF)
      v59 = v58;
    else
      v59 = 4351;
    *(_QWORD *)(a2 + 56) = v59;
  }
  v60 = _dispatch_thread_getspecific(0x1CuLL);
  if (v60)
    os_retain(v60);
  *(_QWORD *)(a2 + 64) = v60;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v11, v12, v13, v14, v15, v16, v17, 1847);
  v55 = a4 | _dispatch_mach_send_options();
  *(_DWORD *)(a2 + 48) = v55;
  dispatch_retain((dispatch_object_t)a2);
  v52 = (*(_QWORD *)(a2 + 56) & 0x3FFF00uLL) >> 8;
  v18 = __clz(__rbit32(v52));
  if ((_DWORD)v52)
    v19 = v18 + 1;
  else
    v19 = 0;
  v46 = v19;
  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a2);
  *(_DWORD *)(a2 + 52) = _dispatch_mach_msg_get_reply_port(a2);
  v42 = 0;
  if ((v55 & 1) != 0)
    v42 = 8;
  if ((*msg & 0x1F) != 0x12
    || *(_DWORD *)(a2 + 52)
    || *(_DWORD *)(v47 + 88)
    || (*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
  {
    v53 = *(_QWORD *)(a2 + 64);
    if (v53 != -1)
    {
      v40 = v53 ? *(_DWORD *)(v53 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817484, v40, a2, 0, 0);
    }
    v41 = a2;
    if (a3)
      v41 = a3;
    v43 = _dispatch_mach_send_push_and_trydrain(a1, v41, v46, v42);
  }
  else
  {
    if (a3)
      _dispatch_abort(1879, a3 == 0, v20, v21, v22, v23, v24, v25);
    v44 = _dispatch_mach_msg_send(a1, (_QWORD *)a2, 0, 0, v42);
    if (!v44)
      _dispatch_abort(1881, v44, v26, v27, v28, v29, v30, v31);
    v43 = (v44 & 2) != 0;
  }
  if ((v43 & 1) != 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] clear", v32, v33, v34, v35, v36, v37, v38, 1892);
    if (*(_QWORD *)(a2 + 64))
      os_release(*(void **)(a2 + 64));
    *(_QWORD *)(a2 + 64) = 0;
    *(_QWORD *)(a2 + 16) = -1985229329;
    dispatch_release((dispatch_object_t)a2);
  }
  return v43 & 1;
}

uint64_t dispatch_mach_send_with_result(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  char v11;
  _DWORD *v12;
  _QWORD *v13;
  uint64_t v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = (_QWORD *)a5;
  v12 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x6E018);
  }
  v19 = (unsigned __int16)v15;
  v18 = 1921;
  if ((_WORD)v15)
    _dispatch_abort(v18, v19, a3, 0, a5, a6, a7, a8);
  v15 = (HIWORD(v15) << 16) | 1;
  result = _dispatch_mach_send_msg(v17, v16, 0, v15);
  v11 = result;
  v10 = 10;
  v9 = 0;
  if ((result & 1) != 0)
  {
    result = _dispatch_mach_msg_get_reason(v16, &v9);
    v10 = result;
  }
  *v13 = v10;
  *v12 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reason(uint64_t a1, int *a2)
{
  uint64_t v2;
  int v4;

  v4 = *(_DWORD *)(a1 + 48);
  if ((v4 & 0xFC000000) == 0xF8000000 && ((v4 >> 14) & 0xFFF) == 0x3E0)
  {
    *a2 = 0;
    return v4 & 0x3FFF;
  }
  else
  {
    *a2 = v4;
    v2 = 4;
    if (!v4)
      return 3;
    return v2;
  }
}

uint64_t dispatch_mach_send_and_wait_for_reply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;
  unsigned __int8 v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = 0;
  v23 = (unsigned __int16)a3;
  v22 = 1994;
  if ((_WORD)a3)
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  v17 &= 0xFFFF0000;
  v15 = _dispatch_mach_send_and_wait_for_reply(v19, v18, v17, &v16);
  v21 = (v16 ^ 1) & 1;
  v20 = 1998;
  if (((v16 ^ 1) & 1) == 0)
    _dispatch_abort(v20, v21, v8, v9, v10, v11, v12, v13);
  return v15;
}

uint64_t _dispatch_mach_send_and_wait_for_reply(uint64_t a1, uint64_t a2, int a3, _BYTE *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _BOOL4 v10;
  __int128 *v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int128 v15;
  char v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  int v62;
  uint64_t v63;
  uint64_t v65;
  uint64_t v66;
  _BOOL4 v67;
  uint64_t v68;
  uint64_t v69;
  void *v70;
  pthread_key_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  mach_error_t v76;
  mach_msg_header_t *v77;
  _BYTE *v78;
  vm_size_t *v79;
  uint64_t *v80;
  _BOOL4 v81;
  uint64_t v82;
  __int128 v83;
  uint64_t v84;
  _QWORD v85[8];
  _DWORD *msg;
  uint64_t v87;
  mach_port_name_t reply_port;
  mach_port_name_t v89;
  __int128 *v90;
  __int128 v91;
  __int128 v92;
  __int128 v93;
  __int128 v94;
  __int128 v95;
  uint64_t v96;
  _BYTE *v97;
  int v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  _BOOL8 v102;
  _BYTE v103[12];
  uint64_t v104;
  mach_msg_header_t *v105;
  mach_msg_header_t *v106;
  mach_msg_header_t *v107;
  uint64_t msgh_size;
  mach_port_name_t v109;
  unsigned int v110;
  mach_error_t v111;
  mach_msg_size_t v112;
  _BYTE v113[12];
  mach_msg_header_t *v114;
  mach_msg_header_t *v115;
  uint64_t v116;
  uint64_t v117;
  mach_port_name_t v118;
  mach_port_name_t v119;
  __int128 *v120;
  uint64_t v121;
  uint64_t v122;
  uint64_t v123;
  mach_msg_header_t *v124;
  _BYTE *i;
  uint64_t v126;
  mach_msg_header_t *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  unsigned int v132;

  v100 = a1;
  v99 = a2;
  v98 = a3;
  v97 = a4;
  v84 = 0;
  v83 = 0u;
  v96 = 0;
  v95 = 0u;
  v94 = 0u;
  v93 = 0u;
  v92 = 0u;
  v91 = 0u;
  *(_QWORD *)&v91 = -2;
  *(_QWORD *)&v94 = *(_QWORD *)(a2 + 32);
  v96 = _dispatch_thread_getspecific(3uLL);
  v90 = &v91;
  v89 = 0;
  v87 = v99;
  reply_port = _dispatch_mach_msg_get_reply_port(v99);
  if (!reply_port)
  {
    reply_port = _dispatch_get_thread_reply_port();
    msg = (_DWORD *)_dispatch_mach_msg_get_msg(v99);
    v10 = ((*msg >> 8) & 0x1F) == 21;
    v102 = ((*msg >> 8) & 0x1F) == 21;
    v101 = 1956;
    if (!v10)
      _dispatch_abort(v101, v102, v4, v5, v6, v7, v8, v9);
    msg[3] = reply_port;
    *((_BYTE *)v90 + 30) = 1;
  }
  v98 |= 4u;
  v82 = 1;
  v11 = (__int128 *)_dispatch_calloc(1, 88);
  v90 = v11;
  v12 = v91;
  v11[1] = v92;
  *v11 = v12;
  v13 = v93;
  v14 = v94;
  v15 = v95;
  *((_QWORD *)v11 + 10) = v96;
  v11[4] = v15;
  v11[3] = v14;
  v11[2] = v13;
  v85[0] = 1;
  v85[1] = -1;
  v85[2] = 0;
  v85[3] = -1;
  v85[4] = 0;
  v85[5] = 0;
  v85[6] = v99;
  v85[7] = v90;
  v16 = _dispatch_mach_send_msg(v100, v99, (unint64_t)v85, v98);
  *v97 = v16;
  if ((*((_BYTE *)v90 + 30) & 1) != 0)
  {
    _dispatch_clear_thread_reply_port(reply_port);
    v89 = *(_DWORD *)(*(_QWORD *)(v100 + 120) + 92);
  }
  v80 = &v65;
  v121 = v100;
  v120 = v90;
  v119 = reply_port;
  v118 = v89;
  v81 = 0;
  if (reply_port)
    v81 = v119 != -1;
  if (!v81)
  {
    v117 = v119;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid reply port";
    qword_E4DA8 = v119;
    __break(1u);
    JUMPOUT(0x6E534);
  }
  v78 = 0;
  v116 = 0;
  v116 = *((_QWORD *)v120 + 6);
  v115 = 0;
  v114 = 0;
  *(_DWORD *)&v113[8] = 0;
  v112 = 0;
  v111 = 0;
  v110 = 0;
  v109 = 0;
  v79 = &vm_page_mask;
  *(_QWORD *)v113 = ((_DWORD)vm_page_mask + 0x4000) & ~(_DWORD)vm_page_mask;
  v77 = (mach_msg_header_t *)((char *)&v65 - ((*(unsigned int *)v113 + 15) & 0x1FFFFFFF0));
  bzero(v77, *(unsigned int *)v113);
  v115 = v77;
  v127 = v77;
  v126 = *(unsigned int *)v113;
  i = v78;
  for (i = (_BYTE *)(((unint64_t)v77 + vm_page_size) & ~*(_DWORD *)v79); i < (_BYTE *)v127 + v126; i += vm_page_size)
    *i = 0;
  v110 = 117440526;
  if (v118 && v118 != -1)
  {
    v109 = v118;
    v110 |= 0x4000u;
  }
  if ((*(_WORD *)(v121 + 116) & 0x80) != 0)
    v110 |= 0x200u;
  while (1)
  {
    v71 = 0;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG %s", v17, v18, v19, v20, v21, v22, v23, 815);
    v111 = mach_msg(v115, v110, 0, *(mach_msg_size_t *)v113, v119, 0, v109);
    *(_QWORD *)&v113[4] = v115;
    v75 = _dispatch_thread_getspecific(v71);
    v74 = v119;
    v73 = *(unsigned int *)v113;
    v72 = v110;
    mach_error_string(v111);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: MACH_RCV_MSG (size %u, opts 0x%x) returned: %s - 0x%x", v24, v25, v26, v27, v28, v29, v30, 822);
    v76 = v111;
    if (!v111)
      break;
    if (v76 == 268451842)
      goto LABEL_34;
    if (v76 != 268451844)
    {
      if (v76 != 268451846 && v76 != 268451849)
      {
        v104 = v111;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from mach_msg_receive";
        qword_E4DA8 = v111;
        __break(1u);
        JUMPOUT(0x6EB44);
      }
LABEL_34:
      v70 = _dispatch_thread_getspecific(0);
      v68 = v116;
      v69 = v119;
      mach_error_string(v111);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: sync reply port destroyed, ctxt %p: %s - 0x%x", v44, v45, v46, v47, v48, v49, v50, 849);
      if ((*((_BYTE *)v120 + 30) & 1) != 0)
        _dispatch_destruct_reply_port(v119, 2u);
LABEL_52:
      free(v114);
      v122 = 0;
      goto LABEL_53;
    }
    if (v115->msgh_size >= 0xFFFFFFBC)
    {
      msgh_size = 0;
      msgh_size = v115->msgh_size;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message";
      qword_E4DA8 = msgh_size;
      __break(1u);
      JUMPOUT(0x6E8A0);
    }
    if ((v110 & 4) == 0)
    {
      _dispatch_log("BUG in libdispatch client: dispatch_mach_send_and_wait_for_reply: dropped message too large to fit in memory: id = 0x%x, size = %u", v31, v32, v33, v34, v35, v36, v37, v115->msgh_id);
      goto LABEL_41;
    }
    v112 = v115->msgh_size + 68;
    v114 = (mach_msg_header_t *)malloc_type_malloc(v112, 1659555374);
    v107 = v114;
    v124 = v114;
    v123 = 831;
    if (!v114)
      _dispatch_bug(v123, 0, v38, v39, v40, v41, v42, v43);
    v106 = v107;
    if (v107)
    {
      v115 = v114;
      *(_DWORD *)v113 = v112;
    }
    v110 |= 0x100u;
    v110 &= ~4u;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: received msg id 0x%x, size = %u, reply on 0x%08x", v51, v52, v53, v54, v55, v56, v57, 861);
  *(_DWORD *)v113 = v115->msgh_size + 68;
  if (v114)
  {
    if (*(_DWORD *)v113 < v112)
    {
      v105 = 0;
      v105 = (mach_msg_header_t *)malloc_type_realloc(v114, v112, 2096623925);
      if (v105)
      {
        v114 = v105;
        v115 = v105;
      }
    }
  }
LABEL_41:
  _dispatch_mach_msg_reply_received(v121, (uint64_t)v120, v115->msgh_local_port);
  v115->msgh_local_port = 0;
  v62 = *(_DWORD *)(v121 + 80);
  v67 = 1;
  if ((v62 & 0x10000000) == 0)
    v67 = v111 != 0;
  if (v67)
  {
    if (!v111)
      mach_msg_destroy(v115);
    goto LABEL_52;
  }
  *(_DWORD *)&v103[8] = 0;
  *(_QWORD *)v103 = v114 != 0;
  *(_QWORD *)&v103[4] = dispatch_mach_msg_create((uint64_t)v115, *(unsigned int *)v113, *(uint64_t *)v103, 0, v58, v59, v60, v61);
  if (!v114 || v115 != *(mach_msg_header_t **)&v113[4])
  {
    v66 = *(_QWORD *)&v113[4];
    v63 = _dispatch_mach_msg_get_msg(*(uint64_t *)&v103[4]);
    v132 = 771948548;
    v131 = v66;
    v130 = v63;
    v129 = 0;
    v128 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v132, v131, v130, v129, v128);
  }
  *(_QWORD *)(*(_QWORD *)&v103[4] + 32) = v116;
  v122 = *(_QWORD *)&v103[4];
LABEL_53:
  v99 = v122;
  free(v90);
  return v99;
}

uint64_t dispatch_mach_send_with_result_and_wait_for_reply(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;
  uint64_t reason;
  uint64_t v11;
  char v12;
  _DWORD *v13;
  _QWORD *v14;
  uint64_t v15;
  int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = (_QWORD *)a5;
  v13 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v15;
    __break(1u);
    JUMPOUT(0x6ED7CLL);
  }
  v12 = 0;
  v11 = 0;
  v20 = (unsigned __int16)v16;
  v19 = 2014;
  if ((_WORD)v16)
    _dispatch_abort(v19, v20, a3, 0, a5, a6, a7, a8);
  v16 = HIWORD(v16) << 16;
  v16 |= 1u;
  v11 = _dispatch_mach_send_and_wait_for_reply(v18, v17, v16, &v12);
  reason = 10;
  v9 = 0;
  if ((v12 & 1) != 0)
    reason = _dispatch_mach_msg_get_reason(v17, &v9);
  *v14 = reason;
  *v13 = v9;
  return v11;
}

uint64_t dispatch_mach_send_with_result_and_async_reply_4libxpc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  int v9;
  uint64_t v10;
  char v11;
  uint64_t v12;
  _DWORD *v14;
  _QWORD *v15;
  uint64_t v16;
  int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  v19 = a1;
  v18 = a2;
  v17 = a3;
  v16 = a4;
  v15 = (_QWORD *)a5;
  v14 = (_DWORD *)a6;
  if (a4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid send flags";
    qword_E4DA8 = v16;
    __break(1u);
    JUMPOUT(0x6EEBCLL);
  }
  if ((*(_WORD *)(v19 + 116) & 0x10) == 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_send_with_result_and_wait_for_reply is XPC only";
    __break(1u);
    JUMPOUT(0x6EEF8);
  }
  v21 = (unsigned __int16)v17;
  v20 = 2044;
  if ((_WORD)v17)
    _dispatch_abort(v20, v21, a3, 0, a5, a6, a7, a8);
  v17 = (HIWORD(v17) << 16) | 1;
  v12 = v18;
  if (!_dispatch_mach_msg_get_reply_port(v18))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply port needed for async send with reply";
    __break(1u);
    JUMPOUT(0x6EF8CLL);
  }
  result = _dispatch_mach_send_msg(v19, v18, 0, v17);
  v11 = result;
  v10 = 10;
  v9 = 0;
  if ((result & 1) != 0)
  {
    result = _dispatch_mach_msg_get_reason(v18, &v9);
    v10 = result;
  }
  *v15 = v10;
  *v14 = v9;
  return result;
}

uint64_t _dispatch_mach_msg_get_reply_port(uint64_t a1)
{
  int v2;
  _DWORD *msg;

  msg = (_DWORD *)_dispatch_mach_msg_get_msg(a1);
  v2 = msg[3];
  if (v2 && v2 != -1 && (*msg & 0x1F00u) >> 8 == 21)
    return msg[3];
  else
    return 0;
}

void dispatch_mach_reconnect(uint64_t a1, unsigned int a2, dispatch_object_s *a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int *v5;
  unsigned int v6;
  uint64_t v7;
  uint64_t v8;
  _QWORD *v11;
  _QWORD *v12;

  v8 = (uint64_t)a3;
  v7 = *(_QWORD *)(a1 + 120);
  v5 = (unsigned int *)(v7 + 88);
  v6 = *(_DWORD *)(v7 + 88);
  do
  {
    v3 = v6;
    do
      v4 = __ldaxr(v5);
    while (v4 == v6 && __stlxr(v6 + 1, v5));
    v6 = v4;
  }
  while (v4 != v3);
  if (a2 && a2 != -1 && a3)
  {
    dispatch_retain(a3);
    *(_DWORD *)(v8 + 48) = _dispatch_mach_checkin_options();
    *(_DWORD *)(v7 + 96) = _dispatch_mach_msg_get_remote_port(v8);
  }
  else
  {
    if (a3 != (dispatch_object_s *)-1)
      v8 = 0;
    *(_DWORD *)(v7 + 96) = 0;
  }
  v12 = _dispatch_thread_getspecific(0x16uLL);
  if (v12)
  {
    _dispatch_thread_setspecific(22, v12[2]);
    v11 = v12;
  }
  else
  {
    v11 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v11 = 260;
  v11[4] = _dispatch_mach_reconnect_invoke;
  v11[5] = v11;
  v11[6] = v8;
  v11[7] = a2;
  v11[3] = -1;
  v11[1] = -1;
  _dispatch_mach_send_push((unsigned int *)a1, v11, 0);
}

BOOL _dispatch_mach_reconnect_invoke(unsigned int *a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int *v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int *v31;
  unsigned int v32;
  int v33;
  unsigned int *v34;
  unsigned int v35;
  char v36;
  dispatch_object_s *v37;
  int v38;
  uint64_t v39;
  uint64_t v40;
  char v41;
  BOOL v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t i;
  dispatch_object_s *v46;
  uint64_t v47;
  uint64_t v48;
  unsigned int *v49;
  unsigned int *v50;
  _QWORD *v51;
  unsigned int v52;
  unsigned int v53;
  unsigned int v54;
  unsigned int *v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  _QWORD *v61;
  int v62;
  _DWORD *v63;
  _QWORD *v64;
  _QWORD *v65;
  _BOOL4 v66;
  BOOL v67;
  unsigned int v68;
  unsigned int v69;
  unsigned int v70;
  _BOOL4 v71;
  unsigned int v72;
  unsigned int v73;
  unsigned int *v74;
  uint64_t v75;
  unsigned int v76;
  unsigned int v77;
  unsigned int v78;
  int v79;
  int v80;
  int v81;
  unsigned int v82;
  unsigned int v83;
  unsigned int v84;
  unsigned int *v85;
  BOOL v86;
  unsigned int v87;
  unsigned int v88;
  uint64_t v89;
  int v90;
  unsigned int *v91;

  v51 = a2;
  v50 = a1;
  v49 = a1;
  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_reconnect_invoke");
  v48 = 0;
  v48 = *((_QWORD *)v50 + 15);
  v47 = v48;
  v59 = v48;
  v58 = 0;
  v57 = *(_QWORD *)(v48 + 16);
  v58 = v57;
  v56 = v57;
  v60 = v57;
  if (v57)
  {
    v91 = v50;
    v90 = 5;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    v89 = *((_QWORD *)v50 + 15);
    _dispatch_unote_unregister(v89, 5, v13, v14, v15, v16, v17, v18);
    *(_DWORD *)(*((_QWORD *)v50 + 15) + 24) = 0;
  }
  if (*(_DWORD *)(v48 + 92) && *(_DWORD *)(v48 + 92) != -1)
  {
    _dispatch_mach_msg_disconnected((uint64_t)v50, 0, *(_DWORD *)(v48 + 92), v8, v9, v10, v11, v12);
    *(_DWORD *)(v48 + 92) = 0;
  }
  if (*(_QWORD *)(v48 + 48))
  {
    v46 = *(dispatch_object_s **)(v48 + 48);
    _dispatch_mach_msg_not_sent((uint64_t)v50, v46, 0);
    *(_QWORD *)(v48 + 48) = 0;
  }
  *((_WORD *)v50 + 59) &= ~1u;
  i = 0;
  v44 = 0;
  v43 = 0;
  v41 = -112;
  v55 = v50;
  v54 = 0;
  v53 = v50[20];
  v54 = v53;
  v52 = v53;
  if ((v53 & 0x40000000) == 0)
    v41 = -110;
  v74 = (unsigned int *)(v48 + 40);
  v76 = _dispatch_thread_getspecific(3uLL);
  v73 = v76 & 0xFFFFFFFC;
  v72 = 0;
  v71 = 0;
  v19 = (unsigned int *)(v48 + 40);
  v69 = v76 & 0xFFFFFFFC;
  v68 = v76 & 0xFFFFFFFC;
  v70 = v76 & 0xFFFFFFFC;
  do
    v20 = __ldaxr(v19);
  while (!v20 && __stlxr(v76 & 0xFFFFFFFC, v19));
  if (v20)
    v72 = v20;
  v67 = v20 == 0;
  v71 = v20 == 0;
  v66 = v71;
  if (v20)
    _dispatch_unfair_lock_lock_slow(v74, 0x10000);
  v39 = v43;
  v43 = *(_QWORD *)(v48 + 56);
  *(_QWORD *)(v48 + 56) = v39;
  if (v43)
    *(_QWORD *)(v43 + 72) = &v43;
  v40 = *(_QWORD *)(v48 + 56);
  if (v40)
    *(_QWORD *)(v40 + 72) = v48 + 56;
  for (i = v43; ; i = v44)
  {
    v36 = 0;
    if (i)
    {
      v44 = *(_QWORD *)(i + 64);
      v36 = 1;
    }
    if ((v36 & 1) == 0)
      break;
    *(_QWORD *)(i + 72) = 0;
    _dispatch_mach_reply_unregister(v50, i, v41);
  }
  v42 = *(_QWORD *)(v48 + 56) == 0;
  v75 = v48 + 40;
  v85 = (unsigned int *)(v48 + 40);
  v84 = 0;
  v83 = 0;
  v87 = _dispatch_thread_getspecific(3uLL);
  v83 = v87 & 0xFFFFFFFC;
  v82 = 0;
  v34 = v85;
  v80 = 0;
  v79 = 0;
  v81 = 0;
  v35 = *v85;
  do
  {
    v21 = v35;
    do
      v22 = __ldaxr(v34);
    while (v22 == v35 && __stlxr(0, v34));
    v35 = v22;
  }
  while (v22 != v21);
  v78 = v22;
  v82 = v22;
  v77 = v22;
  v84 = v22;
  if (v22 == v83)
  {
    v86 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v85, v84);
    v88 = v84;
    v86 = (v84 & 2) != 0;
  }
  if (v42)
  {
    v38 = v51[7];
    v37 = (dispatch_object_s *)v51[6];
    v61 = v51;
    v64 = v51;
    v63 = 0;
    v63 = _dispatch_thread_getspecific(0x16uLL);
    v62 = 0;
    if (v63)
      v33 = v63[2] + 1;
    else
      v33 = 1;
    v62 = v33;
    if (v33 <= _dispatch_continuation_cache_limit)
    {
      v64[2] = v63;
      *((_DWORD *)v64 + 2) = v62;
      _dispatch_thread_setspecific(22, (uint64_t)v64);
      v65 = 0;
    }
    else
    {
      v65 = v64;
    }
    v61 = v65;
    if (v65)
      _dispatch_continuation_free_to_cache_limit(v61);
    if (v37 == (dispatch_object_s *)-1)
    {
      *((_WORD *)v50 + 59) = *((_WORD *)v50 + 59) & 0xFFFD | 2;
      v37 = 0;
    }
    if (((*((_WORD *)v50 + 59) >> 1) & 1) != 0)
    {
      if (v38 && v38 != -1)
        _dispatch_mach_msg_disconnected((uint64_t)v50, 0, v38, v23, v24, v25, v26, v27);
      if (v37)
        _dispatch_mach_msg_not_sent((uint64_t)v50, v37, 0);
    }
    else
    {
      *(_DWORD *)(v48 + 92) = v38;
      *(_QWORD *)(v48 + 48) = v37;
    }
    v31 = (unsigned int *)(v48 + 88);
    v32 = *(_DWORD *)(v48 + 88);
    do
    {
      v28 = v32;
      do
        v29 = __ldaxr(v31);
      while (v29 == v32 && __stlxr(v32 - 1, v31));
      v32 = v29;
    }
    while (v29 != v28);
  }
  return v42;
}

void _dispatch_mach_send_push(unsigned int *a1, _QWORD *a2, unsigned int a3)
{
  unint64_t v3;
  unint64_t v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t *v10;
  _BOOL4 v11;
  unint64_t *v12;
  _BOOL4 v13;
  BOOL v14;
  uint64_t v15;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  unsigned int v22;
  unint64_t v25;
  unint64_t v26;
  unsigned int v27;
  uint64_t v28;

  v20 = *((_QWORD *)a1 + 15);
  v17 = 0;
  LODWORD(v15) = 0;
  v14 = 0;
  if (*a2 > 0xFFFuLL)
    v14 = *a2 == (_QWORD)&unk_E0D08;
  a2[2] = 0;
  _dispatch_thread_setspecific(122, v20 + 72);
  v8 = (unint64_t *)(v20 + 72);
  v9 = *(_QWORD *)(v20 + 72);
  do
  {
    v3 = v9;
    do
      v4 = __ldaxr(v8);
    while (v4 == v9 && __stlxr((unint64_t)a2, v8));
    v9 = v4;
  }
  while (v4 != v3);
  v16 = v4;
  if (v4)
    v5 = 2;
  else
    v5 = 4;
  _dispatch_retain_n_unsafe((uint64_t)a1, v5);
  if (v16)
    *(_QWORD *)(v16 + 16) = a2;
  else
    *(_QWORD *)(v20 + 80) = a2;
  _dispatch_thread_setspecific(122, 0);
  if (v16)
  {
    v10 = (unint64_t *)(v20 + 64);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(0))
        v7 = __ldaxr(v10);
      else
        v7 = __ldxr(v10);
      v19 = v7;
      v25 = v7;
      if ((v7 & 0x700000000) < (unint64_t)a3 << 32)
        v25 = v7 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      v18 = v25;
      if (v7 == v25)
        break;
      if (_os_atomic_mo_has_release(0))
        v11 = __stlxr(v25, v10) == 0;
      else
        v11 = __stxr(v25, v10) == 0;
      if (v11)
        goto LABEL_41;
    }
    __clrex();
  }
  else
  {
    v17 = 0xA000000000;
    v15 = 2;
    if (v14)
      v17 = 0xB000000000;
    v12 = (unint64_t *)(v20 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v6 = __ldaxr(v12);
      else
        v6 = __ldxr(v12);
      v19 = v6;
      v26 = v6;
      if ((v6 & 0x700000000) < (unint64_t)a3 << 32)
        v26 = v6 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      v18 = v26 | v17;
      if (_os_atomic_mo_has_release(3))
        v13 = __stlxr(v18, v12) == 0;
      else
        v13 = __stxr(v18, v12) == 0;
    }
    while (!v13);
    if (((v19 ^ v18) & 0x8000000000) == 0)
      _dispatch_release_2_no_dispose((uint64_t)a1);
  }
LABEL_41:
  v22 = (v18 & 0x700000000) >> 32;
  if ((v19 & 0xFFFFFFFC) != 0)
    v27 = v19 | 3;
  else
    v27 = 0;
  if (v27)
  {
    if ((v19 & 0x700000000) < (unint64_t)v22 << 32 && (_dispatch_set_qos_class_enabled & 1) != 0)
    {
      v28 = 0;
      if (v22)
        v28 = 1 << (v22 + 7);
      _pthread_workqueue_override_start_direct_check_owner(v27, v28 | 0xFF, v20 + 64);
    }
  }
  else if ((v17 & 0x1000000000) != 0)
  {
    _dispatch_mach_push_send_barrier_drain((uint64_t)a1, v22);
  }
  else
  {
    if ((_DWORD)v15 || *(_DWORD *)(v20 + 88) || (a1[20] & 0x10000000) != 0)
    {
      (*(void (**)(unsigned int *, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, v22, v15 | 1);
      return;
    }
    if ((v19 & 0x1000000000) != 0)
    {
      (*(void (**)(unsigned int *, _QWORD, uint64_t))(*(_QWORD *)a1 + 64))(a1, v22, 1);
      return;
    }
  }
  _dispatch_release_2_tailcall(a1);
}

uint64_t dispatch_mach_get_checkin_port(uint64_t a1)
{
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) != 0)
    return -1;
  else
    return *(unsigned int *)(*(_QWORD *)(a1 + 120) + 96);
}

BOOL dispatch_mach_can_handoff_4libxpc()
{
  BOOL v1;
  char *i;
  char *v3;

  for (i = (char *)_dispatch_thread_getspecific(0x17uLL); i; i = *(char **)i)
  {
    if (*((char **)i + 1) == "mach_msg")
    {
      v3 = i;
      goto LABEL_7;
    }
  }
  v3 = 0;
LABEL_7:
  v1 = 0;
  if (v3)
  {
    v1 = 0;
    if (*((_QWORD *)v3 + 2))
      return *(_QWORD *)(*((_QWORD *)v3 + 2) + 56) == 0;
  }
  return v1;
}

void dispatch_mach_handoff_reply_f(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  _QWORD *v15;
  _QWORD *v16;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;

  v16 = _dispatch_mach_handoff_context(a2);
  v15 = (_QWORD *)v16[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v15, a1);
  _dispatch_retain(a1);
  v16[3] = a1;
  *v15 = 260;
  v15[4] = a4;
  v15[5] = a3;
  v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF)
    v23 = v22;
  else
    v23 = 4351;
  v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24)
    os_retain(v24);
  v15[3] = v24;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v4, v5, v6, v7, v8, v9, v10, 589);
  v25 = v15[3];
  if (v25 != -1)
  {
    v14 = v25 ? *(_DWORD *)(v25 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v14, v15, 0, 0);
  }
  v21 = v23;
  v20 = 0;
  if (v23)
  {
    if ((*(_DWORD *)(a1 + 84) & 0x40000000) != 0 || (*(_DWORD *)(a1 + 84) & 0xFFF) == 0)
    {
      v11 = v23 >> 8;
      v12 = __clz(__rbit32(v11));
      if (v11)
        v13 = v12 + 1;
      else
        v13 = 0;
      v20 = v13;
    }
    else
    {
      v21 = 0;
    }
  }
  v15[1] = v21;
  *((_DWORD *)v16 + 8) = v20;
  *v15 = &unk_E0E58;
}

_QWORD *_dispatch_mach_handoff_context(unsigned int a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v4;
  unsigned int v5;
  uint64_t v6;
  _QWORD *i;
  _QWORD *v9;

  for (i = _dispatch_thread_getspecific(0x17uLL); i; i = (_QWORD *)*i)
  {
    if (i[1] == (_QWORD)"mach_msg")
    {
      v9 = i;
      goto LABEL_7;
    }
  }
  v9 = 0;
LABEL_7:
  if (!v9 || !v9[2])
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Trying to handoff IPC from non IPC context";
    __break(1u);
    JUMPOUT(0x70CFCLL);
  }
  if (*(_QWORD *)(*(_QWORD *)v9[2] + 16) == 515)
  {
    v9[2] = _dispatch_calloc(1, 80);
    v6 = v9[2];
    *(_DWORD *)(v6 + 72) = 1;
  }
  else
  {
    v6 = v9[2];
    v4 = (unsigned int *)(v6 + 72);
    v5 = *(_DWORD *)(v6 + 72);
    do
    {
      v1 = v5;
      do
        v2 = __ldaxr(v4);
      while (v2 == v5 && __stlxr(v5 + 1, v4));
      v5 = v2;
    }
    while (v2 != v1);
  }
  if (*(_QWORD *)(v6 + 56))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Calling dispatch_mach_handoff_reply multiple times from the same context";
    __break(1u);
    JUMPOUT(0x70CCCLL);
  }
  *(_QWORD *)(v6 + 56) = a1;
  return v9;
}

uint64_t _dispatch_mach_handoff_set_wlh(uint64_t result, uint64_t a2)
{
  unsigned int *v2;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;
  uint64_t v13;
  unsigned int v14;
  char v15;
  BOOL v16;

  v13 = result;
  while (*(_QWORD *)(a2 + 24))
  {
    if ((*(_DWORD *)(a2 + 80) & 0x400000) != 0)
    {
      v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
      v2 = (unsigned int *)(a2 + 100);
      do
        v3 = __ldaxr(v2);
      while (!v3 && __stlxr(v14, v2));
      if (v3)
        _dispatch_unfair_lock_lock_slow((unsigned int *)(a2 + 100), 0x10000);
      v10 = (unsigned int *)(a2 + 80);
      v11 = *(_DWORD *)(a2 + 80);
      do
      {
        v4 = v11;
        do
          v5 = __ldaxr(v10);
        while (v5 == v11 && __stlxr(v11 & 0xFFBFFFFF, v10));
        v11 = v5;
      }
      while (v5 != v4);
      result = (uint64_t)_dispatch_thread_getspecific(3uLL);
      v8 = (unsigned int *)(a2 + 100);
      v9 = *(_DWORD *)(a2 + 100);
      do
      {
        v6 = v9;
        do
          v7 = __ldaxr(v8);
        while (v7 == v9 && __stlxr(0, v8));
        v9 = v7;
      }
      while (v7 != v6);
      v15 = v7;
      if (v7 == (result & 0xFFFFFFFC))
      {
        v16 = 0;
      }
      else
      {
        result = (uint64_t)_dispatch_unfair_lock_unlock_slow(a2 + 100, v7);
        v16 = (v15 & 2) != 0;
      }
      if (v16)
      {
        result = (uint64_t)_dispatch_thread_getspecific(0x19uLL);
        if (!((result & 0xF0000) >> 16))
          result = _dispatch_thread_setspecific(25, result & 0xFFF0FFFF | 0x10000);
      }
    }
    if ((*(_QWORD *)(a2 + 56) & 0x2000000000) != 0)
    {
      *(_QWORD *)(v13 + 64) = a2;
      return result;
    }
    a2 = *(_QWORD *)(a2 + 24);
  }
  *(_QWORD *)(v13 + 64) = 0;
  return result;
}

void dispatch_mach_handoff_reply(unsigned int *a1, unsigned int a2, const void *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t *v14;
  _QWORD *v15;
  void *v18;
  int inited;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;

  v15 = _dispatch_mach_handoff_context(a2);
  v14 = (uint64_t *)v15[2];
  _dispatch_mach_handoff_set_wlh((uint64_t)v14, (uint64_t)a1);
  _dispatch_retain((uint64_t)a1);
  v15[3] = a1;
  v18 = _dispatch_Block_copy(a3);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a3) == ___dispatch_block_create_block_invoke)
  {
    *v14 = 276;
    v14[5] = (uint64_t)v18;
    inited = _dispatch_continuation_init_slow(v14, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a3);
    *v14 = 276;
    v14[4] = (uint64_t)_dispatch_call_block_and_release;
    v14[5] = (uint64_t)v18;
    v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF)
      v23 = v22;
    else
      v23 = 4351;
    v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24)
      os_retain(v24);
    v14[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
    v25 = v14[3];
    if (v25 != -1)
    {
      v13 = v25 ? *(_DWORD *)(v25 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v13, v14, 0, 0);
    }
    v21 = v23;
    v20 = 0;
    if (v23)
    {
      if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
      {
        v10 = v23 >> 8;
        v11 = __clz(__rbit32(v10));
        if (v10)
          v12 = v11 + 1;
        else
          v12 = 0;
        v20 = v12;
      }
      else
      {
        v21 = 0;
      }
    }
    v14[1] = v21;
    inited = v20;
  }
  *((_DWORD *)v15 + 8) = inited;
  v14[6] = *v14;
  *v14 = (uint64_t)&unk_E0E58;
}

void _dispatch_mach_ipc_handoff_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t (*v18)(uint64_t);
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  BOOL v25;
  uint64_t (*v26)(uint64_t);
  void *v27;
  uint64_t v28;
  uint64_t v29;
  BOOL v30;
  unsigned int v31;
  unint64_t *v32;
  uint64_t v33;
  uint64_t v34;
  unsigned int *v35;
  uint64_t v36;
  unsigned int v37;
  uint64_t v38;
  void *v39;
  _QWORD __b[5];
  unsigned int *v41;
  int v42;
  uint64_t v43;
  unsigned int *v44;
  uint64_t v45;
  _DWORD *v46;
  uint64_t v47;
  unsigned int *v48;
  uint64_t v49;
  uint64_t v50;
  int v51;
  int v52;
  unsigned int *v53;
  void *v54;
  unsigned int *v55;
  _QWORD *v56;
  int v57;
  int v58;
  int v59;
  int v60;
  uint64_t (*v61)(uint64_t);
  uint64_t (*v62)(uint64_t);
  uint64_t v63;
  uint64_t *v64;
  uint64_t v65;
  _BOOL8 v66;
  unsigned int v67;
  unsigned int *v68;
  _DWORD *v69;
  int v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  unsigned int v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unsigned int v80;
  BOOL v81;
  unint64_t v82;
  uint64_t v83;
  unsigned int v84;
  uint64_t v85;
  unint64_t v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unsigned int v90;
  BOOL v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void *object;
  uint64_t v97;
  unsigned int v98;
  unsigned int v99;
  uint64_t v100;
  unsigned int v101;
  unsigned int v102;
  uint64_t v103;
  uint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  _BOOL8 v109;
  void *v110;
  uint64_t v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unint64_t v117;
  uint64_t v118;
  uint64_t v119;
  uint64_t v120;
  unsigned int *v121;
  void *v122;
  unsigned int *v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  unsigned int *v127;
  unsigned int v128;
  unsigned int *v129;
  uint64_t (*v130)(uint64_t);
  uint64_t v131;
  uint64_t (*v132)(uint64_t);
  uint64_t v133;

  v44 = a1;
  v43 = a2;
  v42 = a3;
  v41 = a1;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v41;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  v39 = _dispatch_thread_getspecific(0x14uLL);
  v38 = *((_QWORD *)v44 + 6);
  v37 = *((_QWORD *)v44 + 7);
  v32 = (unint64_t *)(v41 + 16);
  v33 = *((_QWORD *)v41 + 8);
  do
  {
    v3 = v33;
    do
      v4 = __ldaxr(v32);
    while (v4 == v33 && __stlxr(0, v32));
    v33 = v4;
  }
  while (v4 != v3);
  v36 = v4;
  if (v4)
  {
    if ((v4 & 1) != 0)
      v36 = ~v4;
    else
      _dispatch_sync_ipc_handoff_begin(v4, v37, (uint64_t)(v41 + 16));
  }
  *((_QWORD *)v44 + 2) = -1985229329;
  *((_QWORD *)v44 + 7) = 0;
  v56 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v56);
  v35 = v44;
  v48 = v44;
  v47 = v38;
  v46 = 0;
  v46 = (_DWORD *)*((_QWORD *)v44 + 3);
  v45 = v38 & 4;
  v50 = 1;
  v49 = 600;
  if ((v38 & 4) != 0)
    *((_QWORD *)v48 + 3) = -1;
  if (v46 != (_DWORD *)-1)
  {
    v70 = 771817480;
    v69 = v46;
    v68 = v48;
    v67 = 0;
    if (v46)
      v31 = v69[8];
    else
      v31 = 0;
    v67 = v31;
    v75 = v70;
    v74 = v31;
    v73 = v68;
    v72 = 0;
    v71 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v75, v74, v73, v72, v71);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v11, v12, v13, v14, v15, v16, v17, 607);
  }
  v79 = *((_QWORD *)v48 + 1);
  v78 = (uint64_t)v46;
  v77 = v45 | 2;
  v76 = 0;
  if (v79 != -1)
  {
    v86 = v79;
    v85 = v77;
    v84 = 0;
    v84 = _dispatch_thread_getspecific(0x19uLL);
    v83 = 0;
    v99 = v84;
    v102 = v84 & 0xF00;
    v98 = v102 >> 8;
    v97 = v84;
    if (v102 >> 8)
      v97 |= 1 << (v98 + 7);
    v83 = v97;
    v100 = v97;
    v82 = v97 & 0xFFFFFF00;
    v81 = 0;
    v30 = 1;
    if ((v85 & 1) == 0)
      v30 = (v86 & 0x10000000) != 0;
    v81 = v30;
    v88 = v86;
    v86 &= 0xFFFFFFu;
    if (v86)
    {
      if (v86 >= v82)
      {
        if (v81 || (v84 & 0x44000000) != 0)
          v87 = v86;
        else
          v87 = v83;
      }
      else
      {
        v87 = v83;
      }
    }
    else
    {
      v101 = v84 & 0xF000;
      v80 = v101 >> 12;
      if (v101 >> 12)
      {
        v90 = v80;
        v89 = 1 << (v80 + 7);
        v29 = v89 | 0xFF;
      }
      else
      {
        v29 = v83;
      }
      v87 = v29;
    }
    v76 = v87;
  }
  v94 = v76;
  v93 = v78;
  v92 = v77;
  v106 = v76;
  v109 = v76 != -1;
  v108 = 2332;
  if (v76 == -1)
    _dispatch_abort(v108, v109, v5, v6, v7, v8, v9, v10);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v120 = v106;
    v119 = 4261412863;
    v118 = 0;
    v106 &= 0xFFFFFFFF02FFFFFFLL;
    v105 = 0;
    v110 = 0;
    v110 = _dispatch_thread_getspecific(4uLL);
    v105 = (unint64_t)v110;
    v104 = 0x1000000;
    v103 = 2281701376;
    if ((v110 & 0x1000000) != 0)
    {
      if (v106)
      {
        v28 = v106;
      }
      else
      {
        v114 = v105;
        v113 = v104;
        v112 = 0;
        v28 = v105 & (~v104 | 0xFFFFFF);
      }
      v107 = v28;
    }
    else
    {
      v117 = v105;
      v116 = v103;
      v115 = 0;
      v105 &= ~v103 | 0xFFFFFF;
      if (v106 == v105)
        v107 = 0;
      else
        v107 = v106;
    }
  }
  else
  {
    v107 = 0;
  }
  v94 = v107;
  if (v107)
    goto LABEL_61;
  if (v93 == -1)
  {
    v95 = -1;
    goto LABEL_62;
  }
  v27 = (void *)v93;
  if (v27 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_61:
    v95 = _dispatch_set_priority_and_voucher_slow(v94, (_DWORD *)v93, v92);
  }
  else
  {
    v91 = (v92 & 4) != 0;
    if ((v92 & 2) != 0)
    {
      if (v91 && v93)
      {
        v111 = v93;
        os_release((void *)v93);
      }
      v93 = -1;
    }
    else if (!v91 && v93)
    {
      object = (void *)v93;
      os_retain((void *)v93);
    }
    v95 = v93;
  }
LABEL_62:
  if ((v38 & 0x200) == 0)
  {
    v54 = v39;
    v53 = v44;
    v52 = 0;
    v51 = 0;
    v122 = v39;
    v121 = v44;
  }
  v34 = 0;
  if ((v42 & 0x1000000) != 0)
    v34 = _dispatch_autorelease_pool_push();
  v18 = (uint64_t (*)(uint64_t))*((_QWORD *)v44 + 4);
  v63 = *((_QWORD *)v44 + 5);
  v62 = v18;
  v61 = 0;
  if ((char *)v18 == (char *)_dispatch_call_block_and_release && v63)
    v26 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v63);
  else
    v26 = v62;
  v61 = v26;
  v131 = v63;
  v130 = v26;
  v60 = 0;
  v59 = 0;
  v58 = 0;
  v57 = 0;
  _dispatch_client_callout(v63, v62);
  v133 = v63;
  v132 = v61;
  if (v34)
    _dispatch_autorelease_pool_pop(v34);
  if ((v38 & 0x200) == 0)
  {
    v55 = v35;
    v123 = v35;
    v128 = 772079660;
    v127 = v35;
    v126 = 0;
    v125 = 0;
    v124 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v128, v127, v126, v125, v124);
    v129 = v55;
  }
  v64 = __b;
  v25 = _dispatch_thread_getspecific(0x17uLL) == __b;
  v66 = v25;
  v65 = 449;
  if (!v25)
    _dispatch_abort(v65, v66, v19, v20, v21, v22, v23, v24);
  _dispatch_thread_setspecific(23, *v64);
  if (__b[3])
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  else
    _dispatch_ipc_handoff_release(v41);
  if (v36)
    _dispatch_sync_ipc_handoff_end(v36, v37);
}

void _dispatch_mach_ipc_handoff_async(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;

  v5 = *(_QWORD *)(a1 + 16);
  v4 = *(_QWORD *)(v5 + 56);
  v3 = *(_QWORD *)(v5 + 64);
  (*(void (**)(_QWORD, uint64_t, _QWORD))(**(_QWORD **)(a1 + 24) + 72))(*(_QWORD *)(a1 + 24), v5, *(unsigned int *)(a1 + 32));
  if (v3)
  {
    _dispatch_sync_ipc_handoff_begin(v3, v4, v5 + 64);
    v1 = (unint64_t *)(v5 + 64);
    do
      v2 = __ldaxr(v1);
    while (v2 == v3 && __stlxr(~v3, v1));
  }
  _dispatch_ipc_handoff_release((unsigned int *)v5);
  _dispatch_release_tailcall(*(unsigned int **)(a1 + 24));
}

void _dispatch_ipc_handoff_release(unsigned int *a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int *v3;
  unsigned int v4;

  v3 = a1 + 18;
  v4 = a1[18];
  do
  {
    v1 = v4;
    do
      v2 = __ldaxr(v3);
    while (v2 == v4 && __stlxr(v4 - 1, v3));
    v4 = v2;
  }
  while (v2 != v1);
  if (!v2)
    free(a1);
}

uint64_t _dispatch_mach_msg_invoke(dispatch_object_s *a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  void *v48;
  uint64_t v49;
  uint64_t v50;
  BOOL v51;
  unsigned int v52;
  __int128 v53;
  int v54;
  uint64_t v55;
  dispatch_object_s *v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t *v59;
  __int128 *v60;
  dispatch_object_t v61;
  dispatch_object_s *v62;
  mach_msg_header_t *msg;
  uint64_t v64;
  uint64_t v65;
  dispatch_object_s *v66;
  uint64_t v67;
  _QWORD __b[5];
  uint64_t v69;
  uint64_t reason;
  unsigned int v71;
  uint64_t v72;
  uint64_t v73;
  int v74;
  dispatch_object_s *v75;
  int v76;
  int v77;
  int v78;
  uint64_t v79;
  int v80;
  int v81;
  dispatch_object_s *v82;
  uint64_t v83;
  dispatch_object_s *v84;
  _QWORD *v85;
  uint64_t *v86;
  uint64_t v87;
  _BOOL8 v88;
  unsigned int v89;
  dispatch_object_s *v90;
  uint64_t v91;
  int v92;
  uint64_t v93;
  uint64_t v94;
  dispatch_object_s *v95;
  uint64_t v96;
  unsigned int v97;
  __int128 *v98;
  _OWORD *v99;
  uint64_t v100;
  uint64_t v101;
  uint64_t v102;
  unint64_t v103;
  unsigned int v104;
  BOOL v105;
  unint64_t v106;
  uint64_t v107;
  unsigned int v108;
  uint64_t v109;
  unint64_t v110;
  uint64_t v111;
  unint64_t v112;
  uint64_t v113;
  unsigned int v114;
  BOOL v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  void *object;
  uint64_t v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  uint64_t v127;
  uint64_t v128;
  unint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  _BOOL8 v133;
  void *v134;
  uint64_t v135;
  uint64_t v136;
  uint64_t v137;
  unint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  uint64_t v142;
  uint64_t v143;
  uint64_t v144;
  dispatch_object_s *v145;
  uint64_t v146;
  dispatch_object_s *v147;
  uint64_t v148;
  uint64_t v149;
  uint64_t v150;
  dispatch_object_s *v151;
  unsigned int v152;
  dispatch_object_s *v153;

  v56 = a1;
  v55 = a2;
  v54 = a3;
  v53 = 0uLL;
  v59 = (uint64_t *)&v53;
  _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v53, 0x15uLL, (pthread_key_t *)&v53 + 1, a5, a6, a7, a8);
  v99 = (_OWORD *)v59[1];
  _dispatch_thread_setspecific_packed_pair(20, 21, v99, v8, v9, v10, v11, v12);
  v57 = *v59;
  v58 = v57;
  v75 = v56;
  v74 = v54;
  v73 = v57;
  v72 = 0;
  v71 = 0;
  reason = 0;
  reason = _dispatch_mach_msg_get_reason((uint64_t)v56, (int *)&v71);
  v69 = 7;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v75;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  v85 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v85);
  v67 = v73;
  v66 = v75;
  v83 = v73;
  v82 = v75;
  v81 = 0;
  v80 = 0;
  v146 = v73;
  v145 = v75;
  v72 = *(_QWORD *)(v73 + 88);
  *((_QWORD *)v75 + 2) = -1985229329;
  v13 = *((_QWORD *)v75 + 8);
  v92 = 771817488;
  v91 = v13;
  v90 = v75;
  if (v13 != -1)
  {
    v89 = 0;
    v52 = v91 ? *(_DWORD *)(v91 + 32) : 0;
    v89 = v52;
    v97 = v92;
    v96 = v52;
    v95 = v90;
    v94 = 0;
    v93 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v97, v96, v95, v94, v93);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v14, v15, v16, v17, v18, v19, v20, 2458);
  v27 = *((_QWORD *)v75 + 8);
  v103 = *((_QWORD *)v75 + 7);
  v102 = v27;
  v101 = v69;
  v100 = 0;
  if (v103 != -1)
  {
    v110 = v103;
    v109 = v101;
    v108 = 0;
    v108 = _dispatch_thread_getspecific(0x19uLL);
    v107 = 0;
    v123 = v108;
    v126 = v108 & 0xF00;
    v122 = v126 >> 8;
    v121 = v108;
    if (v126 >> 8)
      v121 |= 1 << (v122 + 7);
    v107 = v121;
    v124 = v121;
    v106 = v121 & 0xFFFFFF00;
    v105 = 0;
    v51 = 1;
    if ((v109 & 1) == 0)
      v51 = (v110 & 0x10000000) != 0;
    v105 = v51;
    v112 = v110;
    v110 &= 0xFFFFFFu;
    if (v110)
    {
      if (v110 >= v106)
      {
        if (v105 || (v108 & 0x44000000) != 0)
          v111 = v110;
        else
          v111 = v107;
      }
      else
      {
        v111 = v107;
      }
    }
    else
    {
      v125 = v108 & 0xF000;
      v104 = v125 >> 12;
      if (v125 >> 12)
      {
        v114 = v104;
        v113 = 1 << (v104 + 7);
        v50 = v113 | 0xFF;
      }
      else
      {
        v50 = v107;
      }
      v111 = v50;
    }
    v100 = v111;
  }
  v118 = v100;
  v117 = v102;
  v116 = v101;
  v130 = v100;
  v133 = v100 != -1;
  v132 = 2332;
  if (v100 == -1)
    _dispatch_abort(v132, v133, v21, v22, v23, v24, v25, v26);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v144 = v130;
    v143 = 4261412863;
    v142 = 0;
    v130 &= 0xFFFFFFFF02FFFFFFLL;
    v129 = 0;
    v134 = 0;
    v134 = _dispatch_thread_getspecific(4uLL);
    v129 = (unint64_t)v134;
    v128 = 0x1000000;
    v127 = 2281701376;
    if ((v134 & 0x1000000) != 0)
    {
      if (v130)
      {
        v49 = v130;
      }
      else
      {
        v138 = v129;
        v137 = v128;
        v136 = 0;
        v49 = v129 & (~v128 | 0xFFFFFF);
      }
      v131 = v49;
    }
    else
    {
      v141 = v129;
      v140 = v127;
      v139 = 0;
      v129 &= ~v127 | 0xFFFFFF;
      if (v130 == v129)
        v131 = 0;
      else
        v131 = v130;
    }
  }
  else
  {
    v131 = 0;
  }
  v118 = v131;
  if (v131)
    goto LABEL_49;
  if (v117 == -1)
  {
    v119 = -1;
    goto LABEL_50;
  }
  v48 = (void *)v117;
  if (v48 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    v119 = _dispatch_set_priority_and_voucher_slow(v118, (_DWORD *)v117, v116);
  }
  else
  {
    v115 = (v116 & 4) != 0;
    if ((v116 & 2) != 0)
    {
      if (v115 && v117)
      {
        v135 = v117;
        os_release((void *)v117);
      }
      v117 = -1;
    }
    else if (!v115 && v117)
    {
      object = (void *)v117;
      os_retain((void *)v117);
    }
    v119 = v117;
  }
LABEL_50:
  *((_QWORD *)v75 + 8) = 0;
  v65 = 0;
  if ((v74 & 0x1000000) != 0)
    v65 = _dispatch_autorelease_pool_push();
  if ((v74 & 4) != 0)
  {
    _dispatch_client_callout3(*(_QWORD *)(v72 + 48), reason, (uint64_t)v75, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (_QWORD)_dispatch_mach_xpc_hooks));
  }
  else
  {
    if (((*(_WORD *)(v73 + 116) >> 2) & 1) == 0)
      _dispatch_mach_connect_invoke(v73);
    if (reason == 2
      && (v64 = v73, v79 = v73, v78 = 0, v77 = *(_DWORD *)(v73 + 80), v78 = v77, v76 = v77, (v77 & 0x10000000) != 0))
    {
      msg = 0;
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v75);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v28, v29, v30, v31, v32, v33, v34, 2483);
      mach_msg_destroy(msg);
    }
    else
    {
      _dispatch_client_callout4(*(_QWORD *)(v72 + 48), reason, (uint64_t)v75, v71, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v72 + 40));
    }
  }
  if (v65)
    _dispatch_autorelease_pool_pop(v65);
  v62 = v75;
  v84 = v75;
  v147 = v75;
  v152 = 772079660;
  v151 = v75;
  v150 = 0;
  v149 = 0;
  v148 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v152, v151, v150, v149, v148);
  v153 = v84;
  v61 = v75;
  dispatch_release(v75);
  v86 = __b;
  v41 = _dispatch_thread_getspecific(0x17uLL) == __b;
  v88 = v41;
  v87 = 449;
  if (!v41)
    _dispatch_abort(v87, v88, v35, v36, v37, v38, v39, v40);
  _dispatch_thread_setspecific(23, *v86);
  if (__b[3])
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  v60 = &v53;
  v98 = &v53;
  return _dispatch_thread_setspecific_packed_pair(20, 21, &v53, v42, v43, v44, v45, v46);
}

uint64_t _dispatch_mach_barrier_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t (*v20)(uint64_t);
  uint64_t result;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t (*v27)(uint64_t);
  int v28;
  void *v29;
  uint64_t v30;
  uint64_t v31;
  BOOL v32;
  unsigned int v33;
  uint64_t v34;
  _QWORD *v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  __int128 v42;
  int v43;
  uint64_t v44;
  _QWORD *v45;
  __int128 *v46;
  uint64_t v47;
  _DWORD *v48;
  uint64_t v49;
  _QWORD *v50;
  uint64_t v51;
  uint64_t v52;
  int v53;
  int v54;
  _QWORD *v55;
  uint64_t v56;
  int v57;
  _DWORD *v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  __int128 *v62;
  int v63;
  int v64;
  int v65;
  int v66;
  uint64_t (*v67)(uint64_t);
  uint64_t (*v68)(uint64_t);
  uint64_t v69;
  _QWORD *v70;
  unsigned int v71;
  _QWORD *v72;
  _DWORD *v73;
  int v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  uint64_t v78;
  unsigned int v79;
  __int128 *v80;
  _OWORD *v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  unint64_t v85;
  unsigned int v86;
  BOOL v87;
  unint64_t v88;
  uint64_t v89;
  unsigned int v90;
  uint64_t v91;
  unint64_t v92;
  uint64_t v93;
  unint64_t v94;
  uint64_t v95;
  unsigned int v96;
  BOOL v97;
  uint64_t v98;
  uint64_t v99;
  uint64_t v100;
  uint64_t v101;
  void *object;
  uint64_t v103;
  unsigned int v104;
  unsigned int v105;
  uint64_t v106;
  unsigned int v107;
  unsigned int v108;
  uint64_t v109;
  uint64_t v110;
  unint64_t v111;
  uint64_t v112;
  uint64_t v113;
  uint64_t v114;
  _BOOL8 v115;
  void *v116;
  uint64_t v117;
  uint64_t v118;
  uint64_t v119;
  unint64_t v120;
  uint64_t v121;
  uint64_t v122;
  unint64_t v123;
  uint64_t v124;
  uint64_t v125;
  uint64_t v126;
  _QWORD *v127;
  uint64_t v128;
  uint64_t v129;
  uint64_t v130;
  uint64_t v131;
  uint64_t v132;
  uint64_t v133;
  unsigned int v134;
  uint64_t v135;
  uint64_t (*v136)(uint64_t);
  uint64_t v137;
  uint64_t (*v138)(uint64_t);
  uint64_t v139;

  v45 = a1;
  v44 = a2;
  v43 = a3;
  v42 = 0uLL;
  v41 = a1[7];
  v39 = a1[6];
  v70 = a1;
  v38 = *(_QWORD *)(*a1 + 16);
  if (v38 == 1024)
  {
    v46 = &v42;
    _dispatch_thread_getspecific_pair(0x14uLL, (void **)&v42, 0x15uLL, (pthread_key_t *)&v42 + 1, a5, a6, a7, a8);
    v81 = (_OWORD *)*((_QWORD *)v46 + 1);
    _dispatch_thread_setspecific_packed_pair(20, 21, v81, v8, v9, v10, v11, v12);
  }
  v40 = *(_QWORD *)(v41 + 88);
  if (((*(_WORD *)(v41 + 116) >> 2) & 1) == 0)
  {
    v37 = 0;
    if ((v43 & 0x1000000) != 0)
      v37 = _dispatch_autorelease_pool_push();
    _dispatch_mach_connect_invoke(v41);
    if (v37)
      _dispatch_autorelease_pool_pop(v37);
  }
  v36 = (uint64_t)v45;
  v50 = v45;
  v49 = v39;
  v48 = 0;
  v48 = (_DWORD *)v45[3];
  v47 = v39 & 4;
  v52 = 1;
  v51 = 600;
  if ((v39 & 4) != 0)
    v50[3] = -1;
  if (v48 != (_DWORD *)-1)
  {
    v74 = 771817480;
    v73 = v48;
    v72 = v50;
    v71 = 0;
    if (v48)
      v33 = v73[8];
    else
      v33 = 0;
    v71 = v33;
    v79 = v74;
    v78 = v33;
    v77 = v72;
    v76 = 0;
    v75 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v79, v78, v77, v76, v75);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] adopt", v13, v14, v15, v16, v17, v18, v19, 607);
  }
  v85 = v50[1];
  v84 = (uint64_t)v48;
  v83 = v47 | 2;
  v82 = 0;
  if (v85 != -1)
  {
    v92 = v85;
    v91 = v83;
    v90 = 0;
    v90 = _dispatch_thread_getspecific(0x19uLL);
    v89 = 0;
    v105 = v90;
    v108 = v90 & 0xF00;
    v104 = v108 >> 8;
    v103 = v90;
    if (v108 >> 8)
      v103 |= 1 << (v104 + 7);
    v89 = v103;
    v106 = v103;
    v88 = v103 & 0xFFFFFF00;
    v87 = 0;
    v32 = 1;
    if ((v91 & 1) == 0)
      v32 = (v92 & 0x10000000) != 0;
    v87 = v32;
    v94 = v92;
    v92 &= 0xFFFFFFu;
    if (v92)
    {
      if (v92 >= v88)
      {
        if (v87 || (v90 & 0x44000000) != 0)
          v93 = v92;
        else
          v93 = v89;
      }
      else
      {
        v93 = v89;
      }
    }
    else
    {
      v107 = v90 & 0xF000;
      v86 = v107 >> 12;
      if (v107 >> 12)
      {
        v96 = v86;
        v95 = 1 << (v86 + 7);
        v31 = v95 | 0xFF;
      }
      else
      {
        v31 = v89;
      }
      v93 = v31;
    }
    v82 = v93;
  }
  v100 = v82;
  v99 = v84;
  v98 = v83;
  v112 = v82;
  v115 = v82 != -1;
  v114 = 2332;
  if (v82 == -1)
    _dispatch_abort(v114, v115, a3, a4, a5, a6, a7, a8);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v126 = v112;
    v125 = 4261412863;
    v124 = 0;
    v112 &= 0xFFFFFFFF02FFFFFFLL;
    v111 = 0;
    v116 = 0;
    v116 = _dispatch_thread_getspecific(4uLL);
    v111 = (unint64_t)v116;
    v110 = 0x1000000;
    v109 = 2281701376;
    if ((v116 & 0x1000000) != 0)
    {
      if (v112)
      {
        v30 = v112;
      }
      else
      {
        v120 = v111;
        v119 = v110;
        v118 = 0;
        v30 = v111 & (~v110 | 0xFFFFFF);
      }
      v113 = v30;
    }
    else
    {
      v123 = v111;
      v122 = v109;
      v121 = 0;
      v111 &= ~v109 | 0xFFFFFF;
      if (v112 == v111)
        v113 = 0;
      else
        v113 = v112;
    }
  }
  else
  {
    v113 = 0;
  }
  v100 = v113;
  if (v113)
    goto LABEL_59;
  if (v99 == -1)
  {
    v101 = -1;
    goto LABEL_60;
  }
  v29 = (void *)v99;
  if (v29 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_59:
    v101 = _dispatch_set_priority_and_voucher_slow(v100, (_DWORD *)v99, v98);
  }
  else
  {
    v97 = (v98 & 4) != 0;
    if ((v98 & 2) != 0)
    {
      if (v97 && v99)
      {
        v117 = v99;
        os_release((void *)v99);
      }
      v99 = -1;
    }
    else if (!v97 && v99)
    {
      object = (void *)v99;
      os_retain((void *)v99);
    }
    v101 = v99;
  }
LABEL_60:
  if ((v39 & 0x200) == 0)
  {
    v56 = v41;
    v55 = v45;
    v54 = 0;
    v53 = 0;
    v128 = v41;
    v127 = v45;
  }
  if ((v39 & 4) != 0)
  {
    v59 = v36;
    v58 = 0;
    v58 = _dispatch_thread_getspecific(0x16uLL);
    v57 = 0;
    if (v58)
      v28 = v58[2] + 1;
    else
      v28 = 1;
    v57 = v28;
    if (v28 <= _dispatch_continuation_cache_limit)
    {
      *(_QWORD *)(v59 + 16) = v58;
      *(_DWORD *)(v59 + 8) = v57;
      _dispatch_thread_setspecific(22, v59);
      v60 = 0;
    }
    else
    {
      v60 = v59;
    }
    v35 = (_QWORD *)v60;
  }
  else
  {
    v35 = 0;
  }
  v34 = 0;
  if ((v43 & 0x1000000) != 0)
    v34 = _dispatch_autorelease_pool_push();
  v20 = (uint64_t (*)(uint64_t))v45[4];
  v69 = v45[5];
  v68 = v20;
  v67 = 0;
  if ((char *)v20 == (char *)_dispatch_call_block_and_release && v69)
    v27 = (uint64_t (*)(uint64_t))_Block_get_invoke_fn(v69);
  else
    v27 = v68;
  v67 = v27;
  v137 = v69;
  v136 = v27;
  v66 = 0;
  v65 = 0;
  v64 = 0;
  v63 = 0;
  _dispatch_client_callout(v69, v68);
  v139 = v69;
  v138 = v67;
  result = _dispatch_client_callout4(*(_QWORD *)(v40 + 48), 6, 0, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v40 + 40));
  if (v34)
    result = _dispatch_autorelease_pool_pop(v34);
  if ((v39 & 0x200) == 0)
  {
    v61 = v36;
    v129 = v36;
    v134 = 772079660;
    v133 = v36;
    v132 = 0;
    v131 = 0;
    v130 = 0;
    if (MEMORY[0xFFFFFC100])
      result = kdebug_trace(v134, v133, v132, v131, v130);
    v135 = v61;
  }
  if (v35)
    result = (uint64_t)_dispatch_continuation_free_to_cache_limit(v35);
  if (v38 == 1024)
  {
    v62 = &v42;
    v80 = &v42;
    return _dispatch_thread_setspecific_packed_pair(20, 21, &v42, v22, v23, v24, v25, v26);
  }
  return result;
}

uint64_t _dispatch_mach_connect_invoke(uint64_t a1)
{
  uint64_t result;

  result = _dispatch_client_callout4(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 48), 1, 0, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 88) + 40));
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFFB | 4;
  return result;
}

void dispatch_mach_send_barrier_f(unsigned int *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  _QWORD *v16;
  unint64_t v17;
  _QWORD *v18;
  uint64_t v19;
  unint64_t v20;
  uint64_t v21;
  void *v22;
  uint64_t v23;

  v18 = _dispatch_thread_getspecific(0x16uLL);
  if (v18)
  {
    _dispatch_thread_setspecific(22, v18[2]);
    v16 = v18;
  }
  else
  {
    v16 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v16 = 260;
  v16[4] = a3;
  v16[5] = a2;
  v20 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v20 <= 0x10FF)
    v21 = v20;
  else
    v21 = 4351;
  v22 = _dispatch_thread_getspecific(0x1CuLL);
  if (v22)
    os_retain(v22);
  v16[3] = v22;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  v23 = v16[3];
  if (v23 != -1)
  {
    v12 = v23 ? *(_DWORD *)(v23 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v12, v16, 0, 0);
  }
  v19 = v21;
  if (v21 && (a1[21] & 0x40000000) == 0 && (a1[21] & 0xFFF) != 0)
    v19 = 0;
  v16[1] = v19;
  v16[6] = *v16;
  v16[7] = a1;
  *v16 = &unk_E0D08;
  v17 = (v16[1] & 0x3FFF00uLL) >> 8;
  v10 = __clz(__rbit32(v17));
  if ((_DWORD)v17)
    v11 = v10 + 1;
  else
    v11 = 0;
  _dispatch_mach_send_push(a1, v16, v11);
}

void dispatch_mach_send_barrier(unsigned int *a1, const void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t *v14;
  void *v15;
  unint64_t v16;
  uint64_t *v17;
  uint64_t v18;
  unint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;

  v17 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v17)
  {
    _dispatch_thread_setspecific(22, v17[2]);
    v14 = v17;
  }
  else
  {
    v14 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v15 = _dispatch_Block_copy(a2);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
  {
    *v14 = 276;
    v14[5] = (uint64_t)v15;
    _dispatch_continuation_init_slow(v14, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    *v14 = 276;
    v14[4] = (uint64_t)_dispatch_call_block_and_release;
    v14[5] = (uint64_t)v15;
    v19 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v19 <= 0x10FF)
      v20 = v19;
    else
      v20 = 4351;
    v21 = _dispatch_thread_getspecific(0x1CuLL);
    if (v21)
      os_retain(v21);
    v14[3] = (uint64_t)v21;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    v22 = v14[3];
    if (v22 != -1)
    {
      v11 = v22 ? *(_DWORD *)(v22 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v11, v14, 0, 0);
    }
    v18 = v20;
    if (v20 && (a1[21] & 0x40000000) == 0 && (a1[21] & 0xFFF) != 0)
      v18 = 0;
    v14[1] = v18;
  }
  v14[6] = *v14;
  v14[7] = (uint64_t)a1;
  *v14 = (uint64_t)&unk_E0D08;
  v16 = (v14[1] & 0x3FFF00uLL) >> 8;
  v9 = __clz(__rbit32(v16));
  if ((_DWORD)v16)
    v10 = v9 + 1;
  else
    v10 = 0;
  _dispatch_mach_send_push(a1, v14, v10);
}

uint64_t dispatch_mach_receive_barrier_f(_DWORD *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v12;
  unsigned int v14;
  _QWORD *v18;
  _QWORD *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;

  v19 = _dispatch_thread_getspecific(0x16uLL);
  if (v19)
  {
    _dispatch_thread_setspecific(22, v19[2]);
    v18 = v19;
  }
  else
  {
    v18 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v18 = 260;
  v18[4] = a3;
  v18[5] = a2;
  v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
  if (v22 <= 0x10FF)
    v23 = v22;
  else
    v23 = 4351;
  v24 = _dispatch_thread_getspecific(0x1CuLL);
  if (v24)
    os_retain(v24);
  v18[3] = v24;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v3, v4, v5, v6, v7, v8, v9, 589);
  v25 = v18[3];
  if (v25 != -1)
  {
    v14 = v25 ? *(_DWORD *)(v25 + 32) : 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(771817476, v14, v18, 0, 0);
  }
  v21 = v23;
  v20 = 0;
  if (v23)
  {
    if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
    {
      v10 = v23 >> 8;
      v11 = __clz(__rbit32(v10));
      if (v10)
        v12 = v11 + 1;
      else
        v12 = 0;
      v20 = v12;
    }
    else
    {
      v21 = 0;
    }
  }
  v18[1] = v21;
  v18[6] = *v18;
  v18[7] = a1;
  *v18 = &unk_E0D40;
  return (*(uint64_t (**)(_DWORD *, _QWORD *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v18, v20);
}

uint64_t dispatch_mach_receive_barrier(unsigned int *a1, const void *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int v13;
  uint64_t *v16;
  void *v17;
  unsigned int inited;
  uint64_t *v19;
  unsigned int v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  void *v24;
  uint64_t v25;

  v19 = (uint64_t *)_dispatch_thread_getspecific(0x16uLL);
  if (v19)
  {
    _dispatch_thread_setspecific(22, v19[2]);
    v16 = v19;
  }
  else
  {
    v16 = (uint64_t *)_dispatch_continuation_alloc_from_heap();
  }
  v17 = _dispatch_Block_copy(a2);
  if ((void (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)a2) == ___dispatch_block_create_block_invoke)
  {
    *v16 = 276;
    v16[5] = (uint64_t)v17;
    inited = _dispatch_continuation_init_slow(v16, a1, 0);
  }
  else
  {
    _Block_get_invoke_fn((uint64_t)a2);
    *v16 = 276;
    v16[4] = (uint64_t)_dispatch_call_block_and_release;
    v16[5] = (uint64_t)v17;
    v22 = (unint64_t)_dispatch_thread_getspecific(4uLL) & 0xFFFFFF;
    if (v22 <= 0x10FF)
      v23 = v22;
    else
      v23 = 4351;
    v24 = _dispatch_thread_getspecific(0x1CuLL);
    if (v24)
      os_retain(v24);
    v16[3] = (uint64_t)v24;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: continuation[%p] set", v2, v3, v4, v5, v6, v7, v8, 589);
    v25 = v16[3];
    if (v25 != -1)
    {
      v13 = v25 ? *(_DWORD *)(v25 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817476, v13, v16, 0, 0);
    }
    v21 = v23;
    v20 = 0;
    if (v23)
    {
      if ((a1[21] & 0x40000000) != 0 || (a1[21] & 0xFFF) == 0)
      {
        v9 = v23 >> 8;
        v10 = __clz(__rbit32(v9));
        if (v9)
          v11 = v10 + 1;
        else
          v11 = 0;
        v20 = v11;
      }
      else
      {
        v21 = 0;
      }
    }
    v16[1] = v21;
    inited = v20;
  }
  v16[6] = *v16;
  v16[7] = (uint64_t)a1;
  *v16 = (uint64_t)&unk_E0D40;
  return (*(uint64_t (**)(unsigned int *, uint64_t *, _QWORD))(*(_QWORD *)a1 + 72))(a1, v16, inited);
}

void dispatch_mach_cancel(unsigned int *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  unsigned int v11;

  _dispatch_object_debug((uint64_t)a1, "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_mach_cancel");
  _dispatch_retain((uint64_t)a1);
  v11 = a1[20];
  do
  {
    v8 = v11;
    v9 = a1 + 20;
    do
      v10 = __ldaxr(v9);
    while (v10 == v11 && __stlxr(v11 | 0x10000000, v9));
    v11 = v10;
  }
  while (v10 != v8);
  if ((v10 & 0x10000000) == 0)
    dispatch_mach_reconnect((uint64_t)a1, 0, (dispatch_object_s *)0xFFFFFFFFFFFFFFFFLL);
  _dispatch_release_tailcall(a1);
}

void _dispatch_mach_activate(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v8;

  v8 = a1;
  v7 = 0;
  v6 = 0;
  _dispatch_lane_activate(a1);
  if ((*(_WORD *)(v8 + 116) & 1) == 0)
  {
    v7 = _dispatch_queue_compute_priority_and_wlh(v8, &v6);
    if (v7)
      _dispatch_mach_install(v8, v6, v7, v1, v2, v3, v4, v5);
  }
}

uint64_t _dispatch_mach_install(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  BOOL v16;
  unsigned int v17;
  uint64_t v19;

  v19 = result;
  v17 = a3;
  v16 = (*(_DWORD *)(result + 80) & 0x10000000) != 0;
  v15 = *(_QWORD *)(result + 88);
  if ((*(_WORD *)(result + 116) & 1) != 0)
    _dispatch_abort(2664, (*(_WORD *)(result + 116) & 1) == 0, a3, a4, a5, a6, a7, a8);
  *(_WORD *)(result + 116) |= 1u;
  v14 = *(_DWORD *)(*(_QWORD *)(result + 120) + 88);
  if (HIBYTE(v14) >> 7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Channel never connected";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x76D1CLL);
  }
  if (!*(_DWORD *)(result + 84))
    *(_DWORD *)(result + 84) = a3;
  if (!v16 && (*(_WORD *)(result + 116) & 0x10) != 0)
  {
    result = (*(uint64_t (**)(_QWORD))((char *)&stru_20.cmd + (_QWORD)_dispatch_mach_xpc_hooks))(*(_QWORD *)(v15 + 48));
    if ((_DWORD)result)
    {
      v13 = _dispatch_unote_create_with_handle((uint64_t)&_dispatch_xpc_type_sigterm, 15, 0);
      *(_QWORD *)(v13 + 8) = ~v19;
      *(_QWORD *)(v19 + 128) = v13;
      result = _dispatch_unote_register(*(_QWORD *)(v19 + 128), a2, v17, v8, v9, v10, v11, v12);
    }
  }
  if (!v16 && *(_DWORD *)(v15 + 24))
  {
    if ((*(_BYTE *)(v15 + 29) & 1) == 0)
      _dispatch_abort(2692, *(_BYTE *)(v15 + 29) & 1, a3, a4, a5, a6, a7, a8);
    return _dispatch_unote_register(v15, a2, v17, a4, a5, a6, a7, a8);
  }
  return result;
}

void _dispatch_mach_invoke(unsigned int *a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  BOOL v36;
  unint64_t *v37;
  unint64_t v38;
  BOOL v39;
  unsigned int *v40;
  unsigned int v41;
  int v42;
  BOOL v43;
  unsigned int v44;
  unsigned int v45;
  unsigned int v46;
  __int128 v47;
  unsigned int *v48;
  unsigned int *v49;
  unsigned int v50;
  unsigned int *v51;
  void *v52;
  uint64_t v53;
  _BYTE v54[9];
  unsigned int *v55;
  uint64_t (*v56)(uint64_t, uint64_t, int, _QWORD *);
  int v57;
  unsigned int v58;
  uint64_t v59;
  unsigned int *v60;
  unsigned int v61;
  unsigned int v62;
  unsigned int v63;
  unsigned int *v64;
  uint64_t v65;
  _BOOL8 v66;
  int v67;
  int v68;
  unsigned int *v69;
  void *v70;
  unsigned int *v71;
  __int128 *v72;
  unsigned int *v73;
  void *v74;
  unsigned int *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unsigned int *v79;
  unsigned int v80;
  unsigned int *v81;
  unsigned int v82;
  unsigned int v83;
  int v84;
  int v85;
  int v86;
  unsigned int v87;
  int v88;
  int v89;
  int v90;
  int v91;
  int v92;
  unsigned int *v93;
  _BOOL4 v94;
  unint64_t *v95;
  _BOOL4 v96;
  unsigned int v97;
  uint64_t v98;
  unint64_t v99;
  unint64_t v100;
  unint64_t v101;
  uint64_t v102;
  uint64_t v103;
  int v104;
  unsigned int *v105;
  uint64_t v106;
  uint64_t v107;
  _BOOL8 v108;
  uint64_t v109;
  _BOOL8 v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int v118;
  unint64_t v119;
  uint64_t v120;
  int v121;
  unsigned int v122;
  unsigned int v123;
  uint64_t v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  unsigned int v129;
  unsigned int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int v134;
  unsigned int v135;
  int v136;
  unsigned int v137;
  unsigned int *v138;
  __int128 *v139;
  unsigned int *v140;
  int v141;
  unint64_t v142;
  unint64_t v143;
  uint64_t v144;
  uint64_t v145;
  uint64_t v146;
  unint64_t v147;
  unint64_t v148;
  uint64_t v149;
  uint64_t v150;
  uint64_t v151;
  unint64_t *v152;
  int v153;
  unint64_t v154;
  unint64_t v155;
  BOOL v156;
  uint64_t v157;
  unsigned int *v158;
  char v159;
  unint64_t v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  unsigned int v166;
  unint64_t v167;
  uint64_t v168;
  unint64_t v169;
  unint64_t v170;
  int v171;
  uint64_t v172;
  unsigned int *v173;
  unsigned int v174;
  unsigned int v175;
  unsigned int v176;
  unsigned int *v177;
  uint64_t v178;
  uint64_t v179;
  __int128 *v180;
  unint64_t v181;
  unint64_t v182;
  unint64_t v183;

  v60 = a1;
  v59 = a2;
  v58 = a3;
  v57 = 8;
  v56 = _dispatch_mach_invoke2;
  v55 = a1;
  v54[8] = 0;
  *(_QWORD *)v54 = (a3 & 1) == 0;
  v53 = 0;
  if ((a3 & 3) == 0)
  {
    *((_QWORD *)v55 + 2) = -1985229329;
    v52 = _dispatch_thread_getspecific(0x14uLL);
    v51 = v55;
    v70 = v52;
    v69 = v55;
    v68 = 0;
    v67 = 0;
    v74 = v52;
    v73 = v55;
  }
  v58 |= v57;
  if ((v58 & 2) != 0)
  {
    v53 = 0x40020000000001;
    goto LABEL_54;
  }
  v105 = v55;
  v104 = v58;
  v103 = 0;
  v103 = (uint64_t)(*((unsigned __int16 *)v55 + 40) - 1) << 41;
  v111 = _dispatch_thread_getspecific(3uLL);
  v102 = v111 & 0xFFFFFFFC | 0x20000000000000;
  v100 = 0;
  v99 = 0;
  v98 = 0;
  v101 = 0xFFE00000FFFFFFFCLL;
  if ((v58 & 1) != 0)
  {
    v101 |= 0x4000000000uLL;
    v98 = 0;
  }
  else if ((v104 & 0x40000) != 0)
  {
    v98 = 0x4000000000;
  }
  else
  {
    v101 |= 0x4000000000uLL;
    v98 = 1;
  }
  v110 = (v104 & 2) == 0;
  v109 = 1323;
  if ((v104 & 2) != 0)
    _dispatch_abort(v109, v110, v3, v4, v5, v6, v7, v8);
  v97 = 0;
  v115 = _dispatch_thread_getspecific(0x19uLL);
  v117 = v115 & 0xF00;
  v114 = v117 >> 8;
  v116 = v115 & 0xF000;
  v113 = v116 >> 12;
  v121 = v115 & 0xF0000;
  v112 = (v115 & 0xF0000) >> 16;
  if (v117 >> 8 <= v116 >> 12)
    v46 = v113;
  else
    v46 = v114;
  if (v46 <= v112)
  {
    v44 = v112;
  }
  else
  {
    if (v114 <= v113)
      v45 = v113;
    else
      v45 = v114;
    v44 = v45;
  }
  v97 = v44;
LABEL_22:
  v96 = 0;
  v95 = (unint64_t *)(v105 + 14);
  while (1)
  {
    v15 = _os_atomic_mo_has_acquire(2) ? __ldaxr(v95) : __ldxr(v95);
    v100 = v15;
    v99 = v15;
    if ((v15 & v101) != 0)
      break;
    v167 = v100;
    v166 = v97;
    v170 = v100;
    v43 = 0;
    if ((v100 & 0x1000000000) != 0)
    {
      v168 = v167 & 0x700000000;
      v43 = v166 < (v167 & 0x700000000) >> 32;
    }
    if (v43)
    {
      __clrex();
      v119 = v100;
      v120 = v100 & 0x700000000;
      v118 = (v100 & 0x700000000) >> 32;
      v123 = _dispatch_thread_getspecific(3uLL);
      v122 = v118;
      if ((_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v125 = v122;
        v124 = 0;
        if (v122)
          v124 = 1 << (v125 + 7);
        _pthread_workqueue_override_start_direct(v123, v124 | 0xFF);
      }
      v127 = v118;
      v126 = _dispatch_thread_getspecific(0x19uLL);
      v128 = v126 & 0xF0000;
      if (v118 > (v126 & 0xF0000) >> 16)
      {
        v126 = v126 & 0xFFF0FFFF | (v127 << 16);
        _dispatch_thread_setspecific(25, v126);
      }
      v97 = v118;
      goto LABEL_22;
    }
    v99 = v99 & 0x7700000001 | v102;
    v169 = v100;
    if ((v100 & 0x10000000000) != 0 || v100 + v103 < 0x20000000000000)
      v99 |= 0x40000000000000uLL;
LABEL_44:
    if (_os_atomic_mo_has_release(2))
      v96 = __stlxr(v99, v95) == 0;
    else
      v96 = __stxr(v99, v95) == 0;
    if (v96)
      goto LABEL_48;
  }
  if (v98)
  {
    v99 ^= v98;
    goto LABEL_44;
  }
  __clrex();
LABEL_48:
  v94 = v96;
  v108 = (v100 & v98) == v98;
  v107 = 1356;
  if ((v100 & v98) != v98)
    _dispatch_abort(v107, v108, v9, v10, v11, v12, v13, v14);
  if ((v100 & v101) != 0)
  {
    v106 = 0;
  }
  else
  {
    v99 &= v98 | 0x60000000000000;
    v100 &= 0x3FFE0000000000uLL;
    v106 = v99 - v100;
  }
  v53 = v106;
LABEL_54:
  if (v53)
  {
    v50 = 0;
    if ((v58 & 0x40000) != 0)
    {
      v50 = 0;
    }
    else
    {
      v131 = v55[21];
      v130 = _dispatch_thread_getspecific(0x19uLL);
      v129 = v130;
      if (v130)
      {
        if ((v131 & 0xFFF) != 0)
        {
          v129 &= 0x880F0000;
          if ((v130 & 0xFFF) <= (v131 & 0xFFF))
            v42 = v131 & 0xFFF;
          else
            v42 = v130 & 0xFFF;
          v129 |= v42;
          v133 = v131 & 0xF000;
          v135 = v129 & 0xF00;
          if (v133 >> 12 <= v135 >> 8)
            v131 &= 0x40000000u;
          else
            v131 &= 0x4400F000u;
          v129 |= v131;
        }
        else
        {
          if ((v129 & 0xFFF) != 0)
            v129 |= 0x40000000u;
          v132 = v131 & 0xF000;
          v134 = v129 & 0xF00;
          if (v132 >> 12 > v134 >> 8)
            v129 = v129 & 0xFFFF0FFF | v131 & 0x400F000;
        }
      }
      else
      {
        v129 = v131 & 0xFFF0FFFF;
      }
      _dispatch_thread_setspecific(25, v129);
      v50 = v130;
    }
    if ((v58 & 0x100000) != 0)
    {
      v64 = v60;
      v63 = 0;
      v62 = v60[20];
      v63 = v62;
      v61 = v62;
      if ((v62 & 0x400000) != 0)
      {
        v93 = v60;
        v92 = 0x400000;
        v90 = -4194305;
        v89 = -4194305;
        v91 = -4194305;
        v87 = 0;
        v40 = v60 + 20;
        v85 = -4194305;
        v84 = -4194305;
        v86 = -4194305;
        v41 = v60[20];
        do
        {
          v16 = v41;
          do
            v17 = __ldaxr(v40);
          while (v17 == v41 && __stlxr(v41 & 0xFFBFFFFF, v40));
          v41 = v17;
        }
        while (v17 != v16);
        v83 = v17;
        v87 = v17;
        v82 = v17;
        v88 = v17 & v91;
      }
    }
    v49 = v55;
    v138 = v55;
    v137 = v58;
    v136 = 0;
    v173 = v55;
    v172 = 256;
    v179 = 1;
    v178 = 730;
    v171 = 0;
    v177 = v55;
    v176 = 0;
    v175 = v55[20];
    v176 = v175;
    v174 = v175;
    v171 = v175 & 0x30000;
    v136 = (v175 & 0x30000) << 8;
    if (v136)
      v137 = v137 & 0xFCFFFFFF | v136;
    v58 = v137;
    do
    {
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
        _dispatch_last_resort_autorelease_pool_push(v59);
      v48 = v55;
      *(_QWORD *)&v54[1] = v56((uint64_t)v55, v59, v58, &v53);
      if ((v58 & 2) != 0 && (v58 & 0x1000000) == 0)
      {
        v47 = 0uLL;
        v140 = v55;
        v139 = &v47;
        v180 = &v47;
        _dispatch_thread_getspecific_packed_pair(20, 21, &v47, v19, v20, v21, v22, v23);
        _dispatch_thread_setspecific_pair(20, (uint64_t)v140, 21, (uint64_t)v139, v24, v25, v26, v27);
        _dispatch_last_resort_autorelease_pool_pop(v59);
        v72 = &v47;
        _dispatch_thread_setspecific_packed_pair(20, 21, &v47, v28, v29, v30, v31, v32);
      }
      v66 = *(_QWORD *)&v54[1] != 1;
      v65 = 1955;
      if (*(_QWORD *)&v54[1] == 1)
        _dispatch_abort(v65, v66, v18, v19, v20, v21, v22, v23);
      v39 = 0;
      if (*(_QWORD *)&v54[1])
        v39 = *(_QWORD *)&v54[1] != -1;
      if (v39)
        break;
      v158 = v55;
      v157 = v53;
      v156 = *(_QWORD *)&v54[1] == 0;
      v155 = 0;
      v154 = 0;
      v153 = 0;
      v152 = (unint64_t *)(v55 + 14);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v33 = __ldaxr(v152);
        else
          v33 = __ldxr(v152);
        v155 = v33;
        v154 = (v33 - v157) & 0xFFFFFFF700000001;
        v160 = v33;
        if ((v33 & 0xFF80000000000000) == 0)
        {
          v181 = v155;
          if ((v155 & 0x8000000000) != 0)
          {
            __clrex();
            v150 = 0x8000000000;
            v149 = 0x8000000000;
            v151 = 0x8000000000;
            v147 = 0;
            v37 = (unint64_t *)(v158 + 14);
            v145 = 0x8000000000;
            v144 = 0x8000000000;
            v146 = 0x8000000000;
            v38 = *((_QWORD *)v158 + 7);
            do
            {
              v34 = v38;
              do
                v35 = __ldaxr(v37);
              while (v35 == v38 && __stlxr(v38 ^ 0x8000000000, v37));
              v38 = v35;
            }
            while (v35 != v34);
            v143 = v35;
            v147 = v35;
            v142 = v35;
            v148 = v35 ^ v151;
            v159 = 0;
            goto LABEL_119;
          }
          if (v156)
            v154 &= 0xFFFFFFF8FFFFFFFFLL;
          else
            v154 |= 0x8000000000uLL;
        }
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v153) = __stlxr(v154, v152) == 0;
          v153 = v153;
        }
        else
        {
          LOBYTE(v153) = __stxr(v154, v152) == 0;
          v153 = v153;
        }
      }
      while (!v153);
      v141 = v153;
      v182 = v155;
      v183 = v155;
      v36 = 0;
      if ((v155 & 0x1000000000) != 0)
        v36 = (v182 & 0x800000000) != 0;
      if (v36)
      {
        v161 = v155 & 0x700000000;
        v162 = v155 & 0x700000000;
        LODWORD(v162) = _dispatch_thread_getspecific(0x19uLL);
        v163 = v162 & 0xF0000;
        if (HIDWORD(v162) > (v162 & 0xF0000) >> 16)
        {
          LODWORD(v162) = v162 & 0xFFF0FFFF;
          LODWORD(v162) = v162 | (HIDWORD(v162) << 16);
          _dispatch_thread_setspecific(25, v162);
        }
      }
      v159 = 1;
LABEL_119:
      if ((v159 & 1) != 0)
      {
        v53 = 0;
        *(_QWORD *)&v54[1] = 0;
        break;
      }
      *(_QWORD *)&v54[1] = _dispatch_thread_getspecific(0x14uLL);
    }
    while ((*(_QWORD *)(**(_QWORD **)&v54[1] + 16) & 0x10000) != 0 || (v54[0] & 1) == 0);
    if ((v58 & 0x40000) == 0)
    {
      v165 = v50;
      v164 = 0;
      v164 = _dispatch_thread_getspecific(0x19uLL);
      v165 &= 0xFFF0FFFF;
      v165 |= v164 & 0xF0000;
      _dispatch_thread_setspecific(25, v165);
    }
  }
  if ((v54[0] & 1) != 0)
  {
    v71 = v55;
    v75 = v55;
    v80 = 772079660;
    v79 = v55;
    v78 = 0;
    v77 = 0;
    v76 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v80, v79, v78, v77, v76);
    v81 = v71;
  }
  if (*(_QWORD *)&v54[1])
    _dispatch_queue_invoke_finish(v55, v59, *(uint64_t (****)())&v54[1], v53);
  else
    _dispatch_release_2_tailcall(v55);
}

uint64_t _dispatch_mach_invoke2(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  BOOL v20;
  int v21;
  BOOL v22;
  BOOL v23;
  BOOL v24;
  BOOL v25;
  unsigned int v26;
  unsigned int v27;
  int v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t (***v31)();
  uint64_t v32;
  unint64_t v38;
  _QWORD *v39;
  _QWORD *v40;
  uint64_t v41;
  uint64_t v42;
  _QWORD *v43;

  v32 = 0;
  v31 = (uint64_t (***)())_dispatch_thread_getspecific(0x14uLL);
  v30 = *(_QWORD *)(a1 + 120);
  v29 = *(_QWORD *)(a1 + 88);
  v25 = 0;
  if ((a3 & 0x40000) == 0)
  {
    v25 = 0;
    if (v29)
    {
      v40 = _dispatch_thread_getspecific(0x1DuLL);
      if (v40)
        v41 = v40[3];
      else
        v41 = -4;
      v38 = *(_QWORD *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      v24 = 0;
      if (v38)
      {
        v24 = 0;
        if (v38 != -4)
          v24 = v38 != v41;
      }
      v25 = v24;
    }
  }
  if (v25)
    _dispatch_mach_handle_wlh_change(a1, v4, v5, v6, v7, v8, v9, v10);
  if ((*(_WORD *)(a1 + 116) & 1) == 0)
  {
    if ((a3 & 0x40000) != 0)
      return *(_QWORD *)(a1 + 24);
    v27 = 0x2000000;
    if ((a3 & 0x10000) != 0)
      v27 = _dispatch_thread_getspecific(0x19uLL);
    v39 = _dispatch_thread_getspecific(0x1DuLL);
    if (v39)
      _dispatch_mach_install(a1, v39[3], v27, v11, v12, v13, v14, v15);
    else
      _dispatch_mach_install(a1, -4, v27, v11, v12, v13, v14, v15);
  }
  if (!*(_QWORD *)(a1 + 48))
    goto LABEL_24;
  if (v31 != *(uint64_t (****)())(a1 + 24))
  {
    v32 = *(_QWORD *)(a1 + 24);
    goto LABEL_24;
  }
  while (1)
  {
    while (1)
    {
      v32 = _dispatch_lane_serial_drain(a1, a2, a3, a4, v7, v8, v9, v10);
LABEL_24:
      v28 = *(_DWORD *)(a1 + 80);
      if (v32 || (v28 & 0x10000000) != 0)
        break;
      v42 = *(_QWORD *)(v29 + 16);
      v23 = 0;
      if (v42)
      {
        v23 = 0;
        if ((v42 & 1) == 0)
          v23 = (v42 & 2) == 0;
      }
      if (!v23)
        break;
      _dispatch_unote_resume(v29, v4, v5, v6, v7, v8, v9, v10);
      if (v31 == *(uint64_t (****)())(a1 + 24) && !v31[3] && !*(_QWORD *)(v30 + 72) && *((int *)v31 + 21) < 0)
      {
        v43 = _dispatch_thread_getspecific(0x1DuLL);
        v22 = 0;
        if (_dispatch_thread_getspecific(5uLL))
        {
          v22 = 0;
          if (v43)
          {
            v22 = 0;
            if (v43[3] != -4)
              v22 = (*(_QWORD *)(v29 + 16) & 0xFFFFFFFFFFFFFFFCLL) == v43[3];
          }
        }
        if (v22)
        {
          _dispatch_event_loop_drain(1u);
          if (*(_QWORD *)(a1 + 48))
            continue;
        }
      }
      v28 = *(_DWORD *)(a1 + 80);
      break;
    }
    if (*(_QWORD *)(v30 + 72))
    {
      if ((*(_BYTE *)(v30 + 30) & 1) == 0 || *(_DWORD *)(v30 + 88))
      {
        if (*(_DWORD *)(v30 + 88))
          v21 = *(_QWORD *)(v30 + 16) != 0;
        else
          v21 = *(_WORD *)(a1 + 118) & 1;
        v20 = 0;
        if (v21)
          v20 = v31 != &_dispatch_mgr_q;
        if (v20)
        {
          if (v32)
            return v32;
          else
            return (uint64_t)&_dispatch_mgr_q;
        }
        v26 = 0;
        if (v31 != &_dispatch_mgr_q)
          v26 = 4;
        _dispatch_mach_send_invoke(a1, a3, v26);
        if (!v32 && *(_QWORD *)(a1 + 48))
          v32 = *(_QWORD *)(a1 + 24);
      }
      if (!v32 && *(_QWORD *)(v30 + 72))
        v32 = -1;
    }
    if ((v28 & 0x10000000) == 0)
      return v32;
    if (v28 >= 0 && !_dispatch_mach_cancel(a1, v4, v5, v6, v7, v8, v9, v10))
    {
      if (v32)
        return v32;
      else
        return -1;
    }
    if (((*(_WORD *)(a1 + 116) >> 3) & 1) != 0)
      return v32;
    if (v31 != *(uint64_t (****)())(a1 + 24))
      break;
    if ((*(_QWORD *)(a1 + 56) & 0xFF80000000000000) != 0)
      return *(_QWORD *)(a1 + 24);
    if (!*(_QWORD *)(a1 + 48))
    {
      _dispatch_mach_cancel_invoke(a1, a3);
      return v32;
    }
  }
  if (v32)
    return v32;
  else
    return *(_QWORD *)(a1 + 24);
}

void _dispatch_mach_wakeup(uint64_t a1, unsigned int a2, unsigned int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  _BYTE v9[12];
  uint64_t v10;

  v10 = *(_QWORD *)(a1 + 120);
  *(_DWORD *)&v9[8] = 0;
  *(_QWORD *)v9 = *(unsigned int *)(a1 + 80);
  if ((*(_WORD *)(a1 + 116) & 1) != 0)
  {
    if (*(_QWORD *)(a1 + 48))
    {
      *(_QWORD *)&v9[4] = 1;
    }
    else if (*(_QWORD *)(v10 + 72))
    {
      if ((*(_DWORD *)(v10 + 64) & 0xFFFFFFFC) == 0 && ((*(_BYTE *)(v10 + 30) & 1) == 0 || *(_DWORD *)(v10 + 88)))
      {
        if (*(_DWORD *)(v10 + 88))
          v8 = *(_QWORD *)(v10 + 16) != 0;
        else
          v8 = *(_WORD *)(a1 + 118) & 1;
        if (v8)
          *(_QWORD *)&v9[4] = &_dispatch_mgr_q;
        else
          *(_QWORD *)&v9[4] = 1;
      }
    }
    else if (((*(_DWORD *)v9 & 0x10000000) == 0 || (*(_DWORD *)v9 & 0x40000000) == 0 || (a3 & 0x10) != 0)
           && (*(_DWORD *)v9 & 0x10000000) != 0
           && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0)
    {
      *(_QWORD *)&v9[4] = 1;
    }
  }
  else
  {
    *(_QWORD *)&v9[4] = 1;
  }
  if (*(_QWORD *)&v9[4] == 1 && *(uint64_t (****)())(a1 + 24) == &_dispatch_mgr_q)
    *(_QWORD *)&v9[4] = &_dispatch_mgr_q;
  _dispatch_queue_wakeup((_DWORD *)a1, a2, a3, *(uint64_t *)&v9[4], a5, a6, a7, a8);
}

uint64_t _dispatch_xpc_sigterm_merge_evt(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  unsigned int v4;
  unsigned int v5;
  uint64_t v6;
  uint64_t v8;

  v8 = ~*(_QWORD *)(a1 + 8);
  _dispatch_barrier_async_detached_f(v8, v8, (uint64_t)_dispatch_mach_sigterm_invoke);
  v4 = (*(_QWORD *)&a4 & 0x3FFF00uLL) >> 8;
  v5 = __clz(__rbit32(v4));
  if (v4)
    v6 = v5 + 1;
  else
    v6 = 0;
  return (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(_QWORD *)v8 + 64))(v8, v6, 19);
}

uint64_t _dispatch_mach_sigterm_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;

  result = _dispatch_unote_unregister(*(_QWORD *)(a1 + 128), 5, a3, a4, a5, a6, a7, a8);
  if ((*(_DWORD *)(a1 + 80) & 0x10000000) == 0)
    return _dispatch_client_callout4(*(_QWORD *)(*(_QWORD *)(a1 + 88) + 48), 11, 0, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(*(_QWORD *)(a1 + 88) + 40));
  return result;
}

_QWORD *dispatch_mach_msg_create(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t *a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;
  char v10;
  unint64_t v11;
  _QWORD *v12;
  int v14;

  v14 = a3;
  v10 = 1;
  if (a2 >= 0x18)
  {
    v9 = 0;
    if ((_DWORD)a3)
      v9 = a1 == 0;
    v10 = v9;
  }
  if ((v10 & 1) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Empty message";
    qword_E4DA8 = a2;
    __break(1u);
    JUMPOUT(0x7931CLL);
  }
  v11 = 96;
  if (!(_DWORD)a3)
  {
    v11 = a2 + 88;
    if (a2 - 8 >= 0xFFFFFFFFFFFFFFA0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Message size too large";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x793A8);
    }
  }
  v12 = _dispatch_object_alloc((uint64_t)_OS_dispatch_mach_msg_vtable, v11, a3, (uint64_t)a4, a5, a6, a7, a8);
  if (v14)
  {
    v12[11] = a1;
  }
  else if (a1)
  {
    __memcpy_chk(v12 + 11, a1, a2, -1);
  }
  v12[2] = -1985229329;
  v12[3] = &off_E4640;
  *((_DWORD *)v12 + 18) = v14;
  v12[10] = a2;
  if (a4)
    *a4 = _dispatch_mach_msg_get_msg((uint64_t)v12);
  return v12;
}

uint64_t _dispatch_mach_msg_get_msg(uint64_t a1)
{
  if (*(_DWORD *)(a1 + 72))
    return *(_QWORD *)(a1 + 88);
  else
    return a1 + 88;
}

void _dispatch_mach_msg_dispose(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  kern_return_t v8;

  if (*(_QWORD *)(a1 + 64))
  {
    os_release(*(void **)(a1 + 64));
    *(_QWORD *)(a1 + 64) = 0;
  }
  v7 = *(_DWORD *)(a1 + 72);
  if (v7)
  {
    if (v7 == 1)
    {
      free(*(void **)(a1 + 88));
    }
    else if (v7 == 2)
    {
      v8 = mach_vm_deallocate(mach_task_self_, *(_QWORD *)(a1 + 88), *(_QWORD *)(a1 + 80));
      if (v8)
        _dispatch_bug(3000, v8, v1, v2, v3, v4, v5, v6);
    }
  }
}

uint64_t dispatch_mach_msg_get_msg(uint64_t a1, _QWORD *a2)
{
  if (a2)
    *a2 = *(_QWORD *)(a1 + 80);
  return _dispatch_mach_msg_get_msg(a1);
}

_QWORD *_dispatch_mach_msg_async_reply_invoke(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  BOOL v31;
  _QWORD *result;
  int v33;
  void *v34;
  uint64_t v35;
  uint64_t v36;
  BOOL v37;
  unsigned int v38;
  uint64_t v39;
  mach_msg_header_t *msg;
  uint64_t v42;
  _QWORD __b[5];
  uint64_t v44;
  uint64_t reason;
  unsigned int v46;
  uint64_t v47;
  uint64_t v48;
  int v49;
  _QWORD *v50;
  int v51;
  int v52;
  int v53;
  uint64_t v54;
  int v55;
  int v56;
  _QWORD *v57;
  uint64_t v58;
  _QWORD *v59;
  _QWORD *v60;
  uint64_t *v61;
  uint64_t v62;
  _BOOL8 v63;
  _QWORD *v64;
  int v65;
  _QWORD *v66;
  uint64_t v67;
  _QWORD *v68;
  unsigned int v69;
  _QWORD *v70;
  uint64_t v71;
  int v72;
  uint64_t v73;
  uint64_t v74;
  _QWORD *v75;
  uint64_t v76;
  unsigned int v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  unint64_t v81;
  unsigned int v82;
  BOOL v83;
  unint64_t v84;
  uint64_t v85;
  unsigned int v86;
  uint64_t v87;
  unint64_t v88;
  uint64_t v89;
  unint64_t v90;
  uint64_t v91;
  unsigned int v92;
  BOOL v93;
  uint64_t v94;
  uint64_t v95;
  uint64_t v96;
  uint64_t v97;
  void *object;
  uint64_t v99;
  unsigned int v100;
  unsigned int v101;
  uint64_t v102;
  unsigned int v103;
  unsigned int v104;
  uint64_t v105;
  uint64_t v106;
  unint64_t v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  _BOOL8 v111;
  void *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  unint64_t v116;
  uint64_t v117;
  uint64_t v118;
  unint64_t v119;
  uint64_t v120;
  uint64_t v121;
  uint64_t v122;
  _QWORD *v123;
  uint64_t v124;
  _QWORD *v125;
  uint64_t v126;
  uint64_t v127;
  uint64_t v128;
  _QWORD *v129;
  unsigned int v130;
  _QWORD *v131;

  v39 = *(_QWORD *)(a1 + 56);
  v50 = *(_QWORD **)(a1 + 48);
  v49 = a3 | 4;
  v48 = v39;
  v47 = 0;
  v46 = 0;
  reason = _dispatch_mach_msg_get_reason((uint64_t)v50, (int *)&v46);
  v44 = 7;
  memset(__b, 0, sizeof(__b));
  __b[0] = 0;
  __b[1] = "mach_msg";
  __b[2] = v50;
  __b[3] = 0;
  LODWORD(__b[4]) = 0;
  v60 = __b;
  __b[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v60);
  v58 = v48;
  v57 = v50;
  v56 = 0;
  v55 = 0;
  v124 = v48;
  v123 = v50;
  v47 = *(_QWORD *)(v48 + 88);
  v50[2] = -1985229329;
  v3 = v50[8];
  v72 = 771817488;
  v71 = v3;
  v70 = v50;
  if (v3 != -1)
  {
    v69 = 0;
    v38 = v71 ? *(_DWORD *)(v71 + 32) : 0;
    v69 = v38;
    v77 = v72;
    v76 = v38;
    v75 = v70;
    v74 = 0;
    v73 = 0;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v77, v76, v75, v74, v73);
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] adopt", v4, v5, v6, v7, v8, v9, v10, 2458);
  v17 = v50[8];
  v81 = v50[7];
  v80 = v17;
  v79 = v44;
  v78 = 0;
  if (v81 != -1)
  {
    v88 = v81;
    v87 = v79;
    v86 = 0;
    v86 = _dispatch_thread_getspecific(0x19uLL);
    v85 = 0;
    v101 = v86;
    v104 = v86 & 0xF00;
    v100 = v104 >> 8;
    v99 = v86;
    if (v104 >> 8)
      v99 |= 1 << (v100 + 7);
    v85 = v99;
    v102 = v99;
    v84 = v99 & 0xFFFFFF00;
    v83 = 0;
    v37 = 1;
    if ((v87 & 1) == 0)
      v37 = (v88 & 0x10000000) != 0;
    v83 = v37;
    v90 = v88;
    v88 &= 0xFFFFFFu;
    if (v88)
    {
      if (v88 >= v84)
      {
        if (v83 || (v86 & 0x44000000) != 0)
          v89 = v88;
        else
          v89 = v85;
      }
      else
      {
        v89 = v85;
      }
    }
    else
    {
      v103 = v86 & 0xF000;
      v82 = v103 >> 12;
      if (v103 >> 12)
      {
        v92 = v82;
        v91 = 1 << (v82 + 7);
        v36 = v91 | 0xFF;
      }
      else
      {
        v36 = v85;
      }
      v89 = v36;
    }
    v78 = v89;
  }
  v96 = v78;
  v95 = v80;
  v94 = v79;
  v108 = v78;
  v111 = v78 != -1;
  v110 = 2332;
  if (v78 == -1)
    _dispatch_abort(v110, v111, v11, v12, v13, v14, v15, v16);
  if ((_dispatch_set_qos_class_enabled & 1) != 0)
  {
    v122 = v108;
    v121 = 4261412863;
    v120 = 0;
    v108 &= 0xFFFFFFFF02FFFFFFLL;
    v107 = 0;
    v112 = 0;
    v112 = _dispatch_thread_getspecific(4uLL);
    v107 = (unint64_t)v112;
    v106 = 0x1000000;
    v105 = 2281701376;
    if ((v112 & 0x1000000) != 0)
    {
      if (v108)
      {
        v35 = v108;
      }
      else
      {
        v116 = v107;
        v115 = v106;
        v114 = 0;
        v35 = v107 & (~v106 | 0xFFFFFF);
      }
      v109 = v35;
    }
    else
    {
      v119 = v107;
      v118 = v105;
      v117 = 0;
      v107 &= ~v105 | 0xFFFFFF;
      if (v108 == v107)
        v109 = 0;
      else
        v109 = v108;
    }
  }
  else
  {
    v109 = 0;
  }
  v96 = v109;
  if (v109)
    goto LABEL_49;
  if (v95 == -1)
  {
    v97 = -1;
    goto LABEL_50;
  }
  v34 = (void *)v95;
  if (v34 != _dispatch_thread_getspecific(0x1CuLL))
  {
LABEL_49:
    v97 = _dispatch_set_priority_and_voucher_slow(v96, (_DWORD *)v95, v94);
  }
  else
  {
    v93 = (v94 & 4) != 0;
    if ((v94 & 2) != 0)
    {
      if (v93 && v95)
      {
        v113 = v95;
        os_release((void *)v95);
      }
      v95 = -1;
    }
    else if (!v93 && v95)
    {
      object = (void *)v95;
      os_retain((void *)v95);
    }
    v97 = v95;
  }
LABEL_50:
  v50[8] = 0;
  v42 = 0;
  if ((v49 & 0x1000000) != 0)
    v42 = _dispatch_autorelease_pool_push();
  if ((v49 & 4) != 0)
  {
    _dispatch_client_callout3(*(_QWORD *)(v47 + 48), reason, (uint64_t)v50, *(uint64_t (**)(uint64_t, uint64_t, uint64_t))((char *)&dword_18 + (_QWORD)_dispatch_mach_xpc_hooks));
  }
  else
  {
    if (((*(_WORD *)(v48 + 116) >> 2) & 1) == 0)
      _dispatch_mach_connect_invoke(v48);
    if (reason == 2 && (v54 = v48, v53 = 0, v52 = *(_DWORD *)(v48 + 80), v53 = v52, v51 = v52, (v52 & 0x10000000) != 0))
    {
      msg = (mach_msg_header_t *)_dispatch_mach_msg_get_msg((uint64_t)v50);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: drop msg id 0x%x, reply on 0x%08x", v18, v19, v20, v21, v22, v23, v24, 2483);
      mach_msg_destroy(msg);
    }
    else
    {
      _dispatch_client_callout4(*(_QWORD *)(v47 + 48), reason, (uint64_t)v50, v46, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v47 + 40));
    }
  }
  if (v42)
    _dispatch_autorelease_pool_pop(v42);
  v59 = v50;
  v125 = v50;
  v130 = 772079660;
  v129 = v50;
  v128 = 0;
  v127 = 0;
  v126 = 0;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v130, v129, v128, v127, v126);
  v131 = v59;
  dispatch_release((dispatch_object_t)v50);
  v61 = __b;
  v31 = _dispatch_thread_getspecific(0x17uLL) == __b;
  v63 = v31;
  v62 = 449;
  if (!v31)
    _dispatch_abort(v62, v63, v25, v26, v27, v28, v29, v30);
  _dispatch_thread_setspecific(23, *v61);
  if (__b[3])
    _dispatch_mach_ipc_handoff_async((uint64_t)__b);
  _dispatch_release(*(unsigned int **)(a1 + 56));
  v64 = (_QWORD *)a1;
  v67 = a1;
  v66 = 0;
  result = _dispatch_thread_getspecific(0x16uLL);
  v66 = result;
  v65 = 0;
  if (result)
    v33 = *((_DWORD *)v66 + 2) + 1;
  else
    v33 = 1;
  v65 = v33;
  if (v33 <= _dispatch_continuation_cache_limit)
  {
    *(_QWORD *)(v67 + 16) = v66;
    *(_DWORD *)(v67 + 8) = v65;
    result = (_QWORD *)_dispatch_thread_setspecific(22, v67);
    v68 = 0;
  }
  else
  {
    v68 = (_QWORD *)v67;
  }
  v64 = v68;
  if (v68)
    return _dispatch_continuation_free_to_cache_limit(v64);
  return result;
}

uint64_t dispatch_mach_msg_get_filter_policy_id(uint64_t a1, _DWORD *a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  unsigned int *v5;

  if (!a2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Filter id should be non-NULL";
    qword_E4DA8 = 0;
    __break(1u);
    JUMPOUT(0x7A508);
  }
  result = dispatch_mach_msg_get_msg(a1, 0);
  if (!result)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Messsage should be non-NULL";
    qword_E4DA8 = a1;
    __break(1u);
    JUMPOUT(0x7A56CLL);
  }
  v5 = (unsigned int *)(result + ((*(unsigned int *)(result + 4) + 3) & 0x1FFFFFFFCLL));
  if (*v5)
  {
    v3 = *v5;
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Trailer format is invalid";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x7A5DCLL);
  }
  if (v5[1] < 0x44)
  {
    v4 = v5[1];
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Trailer doesn't contain filter policy id";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x7A654);
  }
  *a2 = v5[15];
  return result;
}

uint64_t dispatch_mig_server(uint64_t a1, uint64_t a2, uint64_t (*a3)(mach_msg_header_t *, mach_msg_header_t *))
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  mach_msg_header_t *v25;
  _BYTE v27[12];
  int v28;
  int v29;
  int v30;
  int v31;
  unsigned int v32;
  mach_msg_header_t *v33;
  mach_msg_header_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  mach_msg_header_t *v38;
  size_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  uint64_t v45;
  size_t v46;
  char v47;
  int v48;
  int v49;
  uint64_t v50;
  int v51;
  unsigned int v52;
  mach_msg_header_t *v53;
  mach_msg_header_t *v54;
  mach_msg_header_t *v55;
  mach_msg_option_t v56;
  mach_msg_option_t v57;
  uint64_t (*v58)(mach_msg_header_t *, mach_msg_header_t *);
  uint64_t v59;
  uint64_t v60;
  int v61;
  int v62;
  int v63;
  uint64_t v64;
  _BYTE *j;
  size_t v66;
  mach_msg_header_t *v67;
  _BYTE *i;
  size_t v69;
  mach_msg_header_t *v70;
  uint64_t v71;
  void *v72;
  _QWORD *v73;
  void *v74;
  _DWORD *v75;
  uint64_t v76;
  unsigned int v77;
  int v78;
  int v79;
  int v80;
  int v81;
  int v82;
  int v83;
  uint64_t v84;
  _DWORD *v85;
  unsigned int v86;

  v60 = a1;
  v59 = a2;
  v58 = a3;
  v57 = 117442818;
  v56 = 0;
  v55 = 0;
  v54 = 0;
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v50 = 0;
  v49 = 1000;
  v48 = 0;
  v47 = 0;
  v46 = a2 + 68;
  v45 = 0;
  v45 = *(_QWORD *)(a1 + 88);
  v34 = (mach_msg_header_t *)&v27[-((a2 + 83) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v34, a2 + 68);
  v54 = v34;
  v34[1].msgh_remote_port = 0;
  v70 = v54;
  v69 = v46;
  for (i = (_BYTE *)(((unint64_t)v54 + vm_page_size) & ~(_DWORD)vm_page_mask);
        i < (_BYTE *)v70 + v69;
        i += vm_page_size)
  {
    *i = 0;
  }
  v33 = (mach_msg_header_t *)&v27[-((v46 + 15) & 0xFFFFFFFFFFFFFFF0)];
  bzero(v33, v46);
  v53 = v33;
  v33->msgh_size = 0;
  v67 = v53;
  v66 = v46;
  for (j = (_BYTE *)(((unint64_t)v53 + vm_page_size) & ~(_DWORD)vm_page_mask);
        j < (_BYTE *)v67 + v66;
        j += vm_page_size)
  {
    *j = 0;
  }
  v57 |= 4u;
  v56 = v57;
  while (1)
  {
    v44 = 0;
    v43 = v60;
    v64 = v60;
    v63 = 0;
    v62 = *(_DWORD *)(v60 + 80);
    v63 = v62;
    v61 = v62;
    v44 = v62;
    v42 = 0;
    v41 = *(_QWORD *)(v60 + 56);
    v42 = v41;
    v40 = v41;
    v71 = v41;
    if ((v41 & 0xFF80000000000000) != 0 || (v44 & 0x10000000) != 0 || (--v49, !v49))
    {
      v57 &= ~2u;
      v56 &= ~2u;
      if ((v56 & 1) == 0)
        break;
    }
    v52 = mach_msg(v53, v56, v53->msgh_size, v46, *(_DWORD *)(v45 + 24), 0, 0);
    v56 = v57;
    if (v52)
    {
      v32 = v52;
      if (v52 == 268435460 || v52 == 268435459)
      {
        _dispatch_mig_consume_unsent_message(v53, v3, v4, v5, v6, v7, v8, v9);
      }
      else if (v32 != 268451842)
      {
        if (v32 == 268451843)
        {
          if (v53->msgh_remote_port || (v47 & 1) != 0)
            return 0;
        }
        else
        {
          if (v32 == 268451844)
          {
            v56 &= 0xFFFFFFFA;
            v39 = 0;
            v39 = v53->msgh_size + 68;
            v38 = 0;
            v38 = (mach_msg_header_t *)malloc_type_malloc(v39, 4250307884);
            if (v38)
            {
              v46 = v39;
              v53 = v38;
            }
            if (!mach_msg(v53, v56, 0, v46, *(_DWORD *)(v45 + 24), 0, 0))
            {
              _dispatch_log("BUG in libdispatch client: dispatch_mig_server received message larger than requested size %zd: id = 0x%x, size = %d", v11, v12, v13, v14, v15, v16, v17, v59);
              mach_msg_destroy(v53);
            }
            if (v38)
              free(v38);
          }
          _dispatch_bug_mach_client((uint64_t)"dispatch_mig_server: mach_msg() failed", v52);
        }
      }
      return v52;
    }
    if ((v56 & 2) == 0)
      return v52;
    if (v50)
      v50 = 0;
    v47 = 1;
    v55 = v54;
    v54 = v53;
    v53 = v55;
    v73 = voucher_create_with_mach_msg(v54, v3, v4, v5, v6, v7, v8, v9);
    v72 = 0;
    v76 = (uint64_t)v73;
    v75 = 0;
    v75 = _dispatch_thread_getspecific(0x1CuLL);
    v85 = v75;
    v84 = v76;
    if (v75 == (_DWORD *)v76)
    {
      v86 = -1;
    }
    else
    {
      if (v85)
      {
        v83 = 0;
        v82 = 0;
      }
      _dispatch_thread_setspecific(28, v84);
      if (v84)
      {
        v81 = 0;
        v80 = 0;
      }
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v18, v19, v20, v21, v22, v23, v24, 400);
      v79 = 0;
      if (v84)
        v31 = *(_DWORD *)(v84 + 32);
      else
        v31 = 0;
      v79 = v31;
      v78 = 0;
      if (v85)
        v30 = v85[8];
      else
        v30 = 0;
      v78 = v30;
      if (v79 == v30)
        v29 = -1;
      else
        v29 = v79;
      v86 = v29;
    }
    v77 = v86;
    if (v86 != -1)
      _dispatch_set_priority_and_mach_voucher_slow(0, v77);
    v72 = v75;
    if (v75)
    {
      v74 = v72;
      os_release(v72);
    }
    v25 = v53;
    v35 = 0;
    v36 = 0;
    v37 = 0;
    *(_OWORD *)&v53->msgh_bits = 0u;
    *(_QWORD *)&v25->msgh_voucher_port = v37;
    v48 = v58(v54, v53);
    if (v48)
      v51 = _dispatch_mig_return_code((uint64_t)v53);
    else
      v51 = -303;
    v28 = v51;
    if (v51 == -305)
    {
      v53->msgh_remote_port = 0;
    }
    else if (v28)
    {
      v54->msgh_remote_port = 0;
      mach_msg_destroy(v54);
    }
    if (v53->msgh_remote_port)
    {
      v56 |= 1u;
      if ((v53->msgh_bits & 0x1F) != 0x12)
        v56 |= 0x10u;
    }
  }
  return v52;
}

void _dispatch_mig_consume_unsent_message(mach_msg_header_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  kern_return_t v9;
  mach_port_name_t msgh_local_port;

  msgh_local_port = a1->msgh_local_port;
  if (msgh_local_port && msgh_local_port != -1)
  {
    v9 = 0;
    v8 = (a1->msgh_bits >> 8) & 0x1F;
    if (v8 == 16)
    {
      v9 = mach_port_mod_refs(mach_task_self_, msgh_local_port, 1u, -1);
    }
    else if (v8 == 18 || v8 == 17)
    {
      v9 = mach_port_deallocate(mach_task_self_, msgh_local_port);
    }
    if (v9 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x7B0D0);
    }
    if (v9)
      _dispatch_bug(3170, v9, a3, a4, a5, a6, a7, a8);
  }
  mach_msg_destroy(a1);
}

uint64_t _dispatch_mig_return_code(uint64_t a1)
{
  if (*(int *)a1 >= 0)
    return *(unsigned int *)(a1 + 32);
  else
    return 0;
}

uint64_t dispatch_mach_mig_demux(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4)
{
  mach_msg_header_t *v4;
  __int128 v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _BOOL4 v19;
  uint64_t v21;
  mach_msg_return_t v22;
  int v23;
  uint64_t v24;
  mach_msg_header_t *v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  mach_msg_option_t v29;
  __int128 v30;
  uint64_t v31;
  mach_msg_return_t v32;
  unsigned int v33;
  mach_msg_header_t *v34;
  uint64_t v35;
  mach_msg_id_t msgh_id;
  mach_msg_header_t *msg;
  _QWORD v38[4];
  unint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _QWORD *v43;
  uint64_t *v44;
  uint64_t v45;
  _BOOL8 v46;
  _BYTE *i;
  uint64_t v48;
  mach_msg_header_t *v49;

  v41 = a1;
  v40 = a2;
  v39 = a3;
  v38[3] = a4;
  v26 = 0;
  v38[0] = 0;
  v38[1] = "mach_mig_demux";
  v38[2] = a1;
  msg = (mach_msg_header_t *)dispatch_mach_msg_get_msg(a4, 0);
  msgh_id = 0;
  msgh_id = msg->msgh_id;
  v34 = 0;
  v33 = 0;
  v32 = 0;
  v35 = _dispatch_mach_mig_resolve(msgh_id, v40, v39);
  if (v35)
  {
    v43 = v38;
    v24 = 23;
    v38[0] = _dispatch_thread_getspecific(0x17uLL);
    _dispatch_thread_setspecific(23, (uint64_t)v43);
    v33 = *(_DWORD *)(v35 + 32) + 68;
    v25 = (mach_msg_header_t *)((char *)&v21 - ((v33 + 15) & 0x1FFFFFFF0));
    bzero(v25, v33);
    v34 = v25;
    v49 = v25;
    v48 = v33;
    for (i = (_BYTE *)(((unint64_t)v25 + vm_page_size) & ~(_DWORD)vm_page_mask);
          i < (_BYTE *)v49 + v48;
          i += vm_page_size)
    {
      *i = 0;
    }
    v4 = v34;
    LODWORD(v30) = msg->msgh_bits & 0x1F;
    DWORD1(v30) = 36;
    *((_QWORD *)&v30 + 1) = msg->msgh_remote_port;
    LODWORD(v31) = 0;
    HIDWORD(v31) = msgh_id + 100;
    v5 = v30;
    *(_QWORD *)&v34->msgh_voucher_port = v31;
    *(_OWORD *)&v4->msgh_bits = v5;
    (*(void (**)(mach_msg_header_t *, mach_msg_header_t *))(v35 + 8))(msg, v34);
    v23 = _dispatch_mig_return_code((uint64_t)v34);
    if (v23 == -305)
    {
      v34->msgh_remote_port = 0;
    }
    else if (v23)
    {
      msg->msgh_remote_port = 0;
      mach_msg_destroy(msg);
    }
    if (v34->msgh_remote_port)
    {
      v29 = 1;
      if ((v34->msgh_bits & 0x1F) != 0x12)
        v29 |= 0x10u;
      v32 = mach_msg(v34, v29, v34->msgh_size, 0, 0, 0, 0);
      v22 = v32;
      if (v32)
      {
        if ((v22 - 268435459) >= 2)
        {
          if (v32 == -301)
          {
            v28 = -301;
            qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_E4DA8 = -301;
            __break(1u);
            JUMPOUT(0x7B4FCLL);
          }
          v27 = v32;
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux: mach_msg(MACH_SEND_MSG) failed";
          qword_E4DA8 = v32;
          __break(1u);
          JUMPOUT(0x7B540);
        }
        _dispatch_mig_consume_unsent_message(v34, v6, v7, v8, v9, v10, v11, v12);
      }
    }
    v44 = v38;
    v19 = _dispatch_thread_getspecific(0x17uLL) == v38;
    v46 = v19;
    v45 = 449;
    if (!v19)
      _dispatch_abort(v45, v46, v13, v14, v15, v16, v17, v18);
    _dispatch_thread_setspecific(23, *v44);
    return 1;
  }
  else
  {
    return 0;
  }
}

uint64_t _dispatch_mach_mig_resolve(int a1, uint64_t a2, unint64_t a3)
{
  unint64_t i;

  for (i = 0; ; ++i)
  {
    if (i >= a3)
      return 0;
    if (*(_DWORD *)(*(_QWORD *)(a2 + 8 * i) + 8) <= a1 && a1 < *(_DWORD *)(*(_QWORD *)(a2 + 8 * i) + 12))
      break;
  }
  if (*(_QWORD *)(*(_QWORD *)(a2 + 8 * i) + 32 + 40 * (a1 - *(_DWORD *)(*(_QWORD *)(a2 + 8 * i) + 8)) + 8))
    return *(_QWORD *)(a2 + 8 * i) + 32 + 40 * (a1 - *(_DWORD *)(*(_QWORD *)(a2 + 8 * i) + 8));
  else
    return 0;
}

uint64_t dispatch_mach_mig_demux_get_context()
{
  _QWORD *i;
  _QWORD *v2;

  for (i = _dispatch_thread_getspecific(0x17uLL); i; i = (_QWORD *)*i)
  {
    if (i[1] == (_QWORD)"mach_mig_demux")
    {
      v2 = i;
      goto LABEL_7;
    }
  }
  v2 = 0;
LABEL_7:
  if (!v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: dispatch_mach_mig_demux_get_context not called from dispatch_ma"
                           "ch_mig_demux context";
    __break(1u);
    JUMPOUT(0x7B7CCLL);
  }
  return v2[2];
}

uint64_t _dispatch_mach_msg_set_reason(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;

  if ((a3 & 0xFFFFFFFFFFFFC000) != 0)
    _dispatch_abort(597, a3 & 0xFFFFFFFFFFFFC000, a3, a4, a5, a6, a7, a8);
  if (!a2 && a3)
    v8 = a3 | 0xF8F80000;
  else
    v8 = a2;
  *(_DWORD *)(result + 48) = v8;
  return result;
}

uint64_t _dispatch_mach_reply_list_remove_locked(uint64_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_QWORD *)(result + 72))
    _dispatch_abort(310, *(_QWORD *)(result + 72) != 0, a3, a4, a5, a6, a7, a8);
  if (*(_QWORD *)(result + 64))
    *(_QWORD *)(*(_QWORD *)(result + 64) + 72) = *(_QWORD *)(result + 72);
  **(_QWORD **)(result + 72) = *(_QWORD *)(result + 64);
  *(_QWORD *)(result + 64) = -1;
  *(_QWORD *)(result + 72) = -1;
  *(_QWORD *)(result + 72) = 0;
  return result;
}

_QWORD *_dispatch_mach_msg_create_reply_disconnected(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v21;
  uint64_t v22[2];
  unsigned int v23;
  _QWORD *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  void *v35;

  v28 = a1;
  v27 = a2;
  v26 = a3;
  v25 = a1;
  v24 = 0;
  v23 = 0;
  if (a1)
    v21 = *(_DWORD *)(v25 + 52);
  else
    v21 = *(_DWORD *)(v27 + 24);
  v23 = v21;
  if (v21)
  {
    if (v27
      && (v22[1] = v27, v33 = v27, v32 = 0, v31 = *(_QWORD *)(v27 + 16), v32 = v31, v30 = v31, (v34 = v31) == 0)
      && (*(_BYTE *)(v27 + 30) & 1) != 0)
    {
      if (*(_QWORD *)(v27 + 56))
      {
        os_release(*(void **)(v27 + 56));
        *(_QWORD *)(v27 + 56) = 0;
      }
      _dispatch_destruct_reply_port(v23, 1u);
      return 0;
    }
    else
    {
      v22[0] = 0;
      v24 = dispatch_mach_msg_create(0, 0x18uLL, 0, v22, a5, a6, a7, a8);
      *(_DWORD *)(v22[0] + 12) = v23;
      if (v25)
      {
        v24[7] = *(_QWORD *)(v25 + 56);
        v24[4] = *(_QWORD *)(v25 + 32);
        v24[8] = *(_QWORD *)(v25 + 64);
        if (v24[8])
        {
          v35 = (void *)v24[8];
          os_retain(v35);
        }
      }
      else
      {
        v24[7] = *(unsigned int *)(v27 + 40);
        v24[4] = *(_QWORD *)(v27 + 48);
        v24[8] = *(_QWORD *)(v27 + 56);
        *(_QWORD *)(v27 + 56) = 0;
      }
      _dispatch_mach_msg_set_reason((uint64_t)v24, 0, v26, v8, v9, v10, v11, v12);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tmachport[0x%08x]: reply disconnected, ctxt %p", v13, v14, v15, v16, v17, v18, v19, 1005);
      return v24;
    }
  }
  else
  {
    if (!v25 && *(_QWORD *)(v27 + 56))
    {
      os_release(*(void **)(v27 + 56));
      *(_QWORD *)(v27 + 56) = 0;
    }
    return 0;
  }
}

void _dispatch_destruct_reply_port(unsigned int a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;

  v8 = thread_destruct_special_reply_port(a1, a2);
  if (v8 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x7BCCCLL);
  }
  if (v8)
    _dispatch_bug(515, v8, v2, v3, v4, v5, v6, v7);
}

uint64_t _dispatch_mach_send_drain(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t *v11;
  unint64_t v12;
  unint64_t v13;
  unint64_t v14;
  unsigned int v16;
  BOOL v17;
  BOOL v18;
  BOOL v19;
  unsigned int v20;
  BOOL v21;
  BOOL v22;
  unint64_t *v23;
  _BOOL4 v24;
  unint64_t *v25;
  _BOOL4 v26;
  uint64_t v27;
  unint64_t *v28;
  _BOOL4 v29;
  uint64_t v30;
  unint64_t *v31;
  int v32;
  uint64_t v33;
  unsigned int v34;
  char v35;
  int v36;
  unint64_t v37;
  unint64_t v38;
  unsigned int v39;
  unint64_t *v40;
  unint64_t *v41;
  uint64_t v42;
  uint64_t v43;
  int v44;
  char v47;
  unint64_t v48;
  unsigned int v49;

  v44 = a3;
  v43 = *(_QWORD *)(a1 + 120);
  v39 = (*(_QWORD *)(v43 + 64) & 0x700000000uLL) >> 32;
  v35 = 0;
  v34 = 0;
  do
  {
LABEL_2:
    if (!*(_QWORD *)(v43 + 72))
    {
      v28 = (unint64_t *)(v43 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v10 = __ldaxr(v28);
        else
          v10 = __ldxr(v28);
        v38 = v10;
        if ((v10 & 0x2000000000) != 0)
          v37 = v10 & 0xFFFFFFC7FFFFFFFFLL;
        else
          v37 = 0;
        if (_os_atomic_mo_has_release(3))
          v29 = __stlxr(v37, v28) == 0;
        else
          v29 = __stxr(v37, v28) == 0;
      }
      while (!v29);
      goto LABEL_94;
    }
    v33 = *(_QWORD *)(v43 + 80);
    if (!v33)
      v33 = _dispatch_wait_for_enqueuer((unint64_t *)(v43 + 80), v43 + 72);
    v40 = (unint64_t *)v33;
    while (1)
    {
      v32 = v44;
      v44 &= ~8u;
      v31 = (unint64_t *)v40[2];
      *(_QWORD *)(v43 + 80) = v31;
      v22 = 0;
      if (!v31)
      {
        v8 = (unint64_t *)(v43 + 72);
        do
          v9 = __ldaxr(v8);
        while ((unint64_t *)v9 == v40 && __stlxr(0, v8));
        v22 = v9 != (_QWORD)v40;
      }
      if (v22)
      {
        v30 = v40[2];
        if (!v30)
          v30 = _dispatch_wait_for_enqueuer(v40 + 2, v43 + 72);
        v31 = (unint64_t *)v30;
        *(_QWORD *)(v43 + 80) = v30;
      }
      v21 = 0;
      if (*v40 > 0xFFF)
        v21 = *(_QWORD *)(*v40 + 16) == 768;
      if (v21)
      {
        if ((v44 & 4) == 0)
          goto LABEL_62;
        _dispatch_continuation_pop(v40, 0, a2, a1);
        goto LABEL_48;
      }
      if (*v40 <= 0xFFF && (*v40 & 1) != 0)
      {
        v41 = (unint64_t *)v40[6];
        v42 = v40[7];
        goto LABEL_32;
      }
      if (*v40 > 0xFFF)
        break;
      if (*(_QWORD *)(v43 + 16) && _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
      {
        *(_WORD *)(a1 + 118) = *(_WORD *)(a1 + 118) & 0xFFFE | 1;
        v34 |= 2u;
        goto LABEL_62;
      }
      if (!_dispatch_mach_reconnect_invoke((unsigned int *)a1, v40, a3, a4, a5, a6, a7, a8))
        goto LABEL_62;
LABEL_48:
      v40 = v31;
      if (!v31)
        goto LABEL_2;
    }
    v41 = v40;
    v42 = 0;
LABEL_32:
    v48 = v41[8];
    if (v48 != -1)
    {
      v20 = v48 ? *(_DWORD *)(v48 + 32) : 0;
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771817488, v20, v41, 0, 0);
    }
    v19 = 1;
    if (!*(_DWORD *)(v43 + 88))
      v19 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
    if (v19)
    {
      _dispatch_mach_msg_not_sent(a1, (dispatch_object_s *)v41, v42);
      goto LABEL_48;
    }
    v36 = _dispatch_mach_msg_send(a1, v41, v42, v39, v32);
    if (v36)
    {
      if ((v36 & 2) != 0)
        v35 = 1;
      goto LABEL_48;
    }
    if ((*(_WORD *)(a1 + 118) & 1) != 0)
      v34 |= 2u;
LABEL_62:
    v40[2] = (unint64_t)v31;
    v18 = 0;
    if (!v31)
    {
      v11 = (unint64_t *)(v43 + 72);
      do
        v12 = __ldaxr(v11);
      while (!v12 && __stlxr((unint64_t)v40, v11));
      v18 = v12 != 0;
    }
    if (v18)
    {
      v27 = *(_QWORD *)(v43 + 80);
      if (!v27)
        v27 = _dispatch_wait_for_enqueuer((unint64_t *)(v43 + 80), v43 + 72);
      v40[2] = v27;
    }
    *(_QWORD *)(v43 + 80) = v40;
    v17 = 0;
    if (*v40 > 0xFFF)
      v17 = *(_QWORD *)(*v40 + 16) == 768;
    if (v17)
    {
      v25 = (unint64_t *)(v43 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v13 = __ldaxr(v25);
        else
          v13 = __ldxr(v25);
        v38 = v13;
        v37 = v13 & 0xFFFFFFC700000000 | 0x3000000000;
        if (_os_atomic_mo_has_release(3))
          v26 = __stlxr(v37, v25) == 0;
        else
          v26 = __stxr(v37, v25) == 0;
      }
      while (!v26);
    }
    else
    {
      v23 = (unint64_t *)(v43 + 64);
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v14 = __ldaxr(v23);
        else
          v14 = __ldxr(v23);
        v38 = v14;
        if ((v14 & 0x2800000000) != 0)
          v37 = v14 & 0xFFFFFFC7FFFFFFFFLL;
        else
          v37 = v14 & 0xFFFFFFDF00000000 | 0x2000000000;
        if (_os_atomic_mo_has_release(3))
          v24 = __stlxr(v37, v23) == 0;
        else
          v24 = __stxr(v37, v23) == 0;
      }
      while (!v24);
    }
LABEL_94:
    if ((v38 & 0x800000000) != 0)
    {
      v49 = _dispatch_thread_getspecific(0x19uLL);
      if ((BYTE4(v38) & 7u) > (v49 & 0xF0000) >> 16)
        _dispatch_thread_setspecific(25, v49 & 0xFFF0FFFF | ((BYTE4(v38) & 7) << 16));
    }
    v39 = (v37 & 0x700000000) >> 32;
  }
  while ((_DWORD)v37);
  if ((v37 & 0x1000000000) != 0)
  {
    _dispatch_mach_push_send_barrier_drain(a1, v39);
    v47 = v35 & 1;
  }
  else
  {
    if (!v37 && ((*(_WORD *)(a1 + 118) >> 1) & 1) != 0 && ((*(_WORD *)(a1 + 116) >> 3) & 1) == 0)
      v34 |= 0x12u;
    if (((v38 ^ v37) & 0x8000000000) != 0)
    {
      if (v34)
        v34 |= 1u;
      else
        _dispatch_release_2((unsigned int *)a1);
    }
    if (v34)
    {
      if ((*(_WORD *)(a1 + 118) & 1) != 0)
        v16 = (v37 & 0x700000000) >> 32;
      else
        v16 = 0;
      (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, v16, v34);
    }
    v47 = v35;
  }
  return v47 & 1;
}

void _dispatch_mach_msg_not_sent(uint64_t a1, dispatch_object_s *a2, uint64_t a3)
{
  void *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  void (*v32)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  unsigned int v33;
  uint64_t v34;
  _QWORD v35[8];
  uint64_t v36;
  _QWORD *v37;
  dispatch_object_s *v38;
  uint64_t v39;
  unsigned int v40;
  unsigned int *msg;
  uint64_t v42;
  dispatch_object_s *reply_disconnected;
  dispatch_object_s *v44;
  uint64_t v45;
  uint64_t v46;
  dispatch_object_s *v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  uint64_t v52;
  _QWORD *v53;
  uint64_t v54;
  _QWORD *v55;
  uint64_t v56;
  dispatch_object_s *v57;
  uint64_t v58;
  int v59;
  int v60;
  _QWORD *v61;
  uint64_t v62;
  unint64_t v63;
  _QWORD *v64;
  uint64_t v65;

  v47 = a2;
  v46 = a1;
  v45 = a3;
  v44 = a2;
  reply_disconnected = 0;
  v42 = 0;
  msg = (unsigned int *)_dispatch_mach_msg_get_msg((uint64_t)a2);
  v40 = 0;
  v40 = *((_DWORD *)v44 + 12);
  v3 = _dispatch_thread_getspecific(0);
  v4 = msg[2];
  v5 = msg[5];
  v6 = *((_QWORD *)v44 + 4);
  v7 = msg[4];
  v8 = *((unsigned int *)v44 + 13);
  v37 = v35;
  v35[1] = v3;
  v35[2] = v4;
  v35[3] = v5;
  v35[4] = v6;
  v35[5] = v40;
  v35[6] = v7;
  v35[7] = v8;
  _dispatch_log("%u\t%p\tmachport[0x%08x]: not sent msg id 0x%x, ctxt %p, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x", v9, v10, v11, v12, v13, v14, v15, 1021);
  v21 = 0;
  v39 = 0;
  if ((v40 & 2) == 0)
    v21 = 5;
  v39 = v21;
  if (((*(_WORD *)(v46 + 116) >> 4) & 1) != 0 && *((_QWORD *)v44 + 4))
  {
    v22 = *((_QWORD *)v44 + 4);
    v50 = v46;
    v49 = v22;
    v48 = 0;
    v48 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(v22);
    if (!v48)
      v48 = v50;
    v42 = v48;
  }
  v38 = v44;
  if (v45)
    v36 = v45;
  else
    v36 = 0;
  if (v42)
    v23 = 12;
  else
    v23 = 7;
  reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected((uint64_t)v38, v36, v23, v16, v17, v18, v19, v20);
  _dispatch_mach_msg_set_reason((uint64_t)v44, 0, v39, v24, v25, v26, v27, v28);
  _dispatch_mach_handle_or_push_received_msg(v46, v44, 0);
  if (reply_disconnected)
  {
    if (v42)
    {
      v58 = v46;
      v57 = reply_disconnected;
      v56 = v42;
      v55 = 0;
      v55 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, v46);
      v54 = v56;
      v53 = v55;
      v62 = v56;
      v61 = v55;
      v60 = 0;
      v59 = 0;
      v65 = v56;
      v64 = v55;
      v32 = *(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v56 + 72);
      v52 = v56;
      v51 = v55;
      v63 = *((_QWORD *)v57 + 7);
      v63 &= 0x3FFF00uLL;
      v63 >>= 8;
      v33 = __clz(__rbit32(v63));
      if ((_DWORD)v63)
        v34 = v33 + 1;
      else
        v34 = 0;
      v32(v52, v51, v34, v29, v30, v31);
    }
    else
    {
      _dispatch_mach_handle_or_push_received_msg(v46, reply_disconnected, 0);
    }
  }
}

uint64_t _dispatch_mach_msg_send(uint64_t a1, _QWORD *a2, uint64_t a3, unsigned int a4, int a5)
{
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  __int128 v43;
  void *v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  int v52;
  void *v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  const char *v61;
  char v62;
  unsigned __int8 v63;
  char *v64;
  __int128 v65;
  __int128 v66;
  char *v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  void *v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  uint64_t v80;
  uint64_t v81;
  uint64_t v82;
  const char *v83;
  _QWORD *v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  uint64_t v94;
  uint64_t v95;
  void (*v96)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t);
  unsigned int v97;
  uint64_t v98;
  uint64_t v100;
  void *v101;
  uint64_t v102;
  _QWORD *v103;
  const char *v104;
  uint64_t v105;
  uint64_t v106;
  uint64_t v107;
  uint64_t v108;
  char *v109;
  uint64_t v110;
  uint64_t v111;
  int v112;
  _BOOL4 v113;
  int v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  const char *v119;
  _QWORD *v120;
  uint64_t v121;
  void *v122;
  uint64_t *v123;
  int v124;
  char *v125;
  _DWORD *v126;
  _BOOL4 v127;
  int v128;
  uint64_t v129;
  unint64_t v130;
  _BOOL4 v131;
  _BOOL4 v132;
  uint64_t v133;
  _DWORD *v134;
  int v135;
  _QWORD *v136;
  uint64_t v137;
  uint64_t v138;
  uint64_t v139;
  mach_port_name_t v140;
  uint64_t v141;
  int v142;
  __int128 v143;
  uint64_t v144;
  __int128 v145;
  _DWORD v146[2];
  __int128 v147;
  uint64_t v148;
  __int128 v149;
  __int128 v150;
  char v151;
  char v152;
  char v153;
  uint64_t v154;
  uint64_t v155;
  unsigned int v156;
  unsigned int v157;
  int v158;
  mach_error_t error_value;
  void *v160;
  uint64_t v161;
  uint64_t v162;
  int v163;
  _DWORD v164[8];
  uint64_t v165;
  unsigned int v166;
  BOOL v167;
  uint64_t msg;
  char v169;
  unsigned int v170;
  uint64_t v171;
  uint64_t v172;
  dispatch_object_s *reply_disconnected;
  _QWORD *v174;
  uint64_t v175;
  int v176;
  unsigned int v177;
  uint64_t v178;
  unsigned int *v179;
  _QWORD *v180;
  uint64_t v181;
  uint64_t v182;
  uint64_t v183;
  uint64_t v184;
  uint64_t v185;
  uint64_t v186;
  uint64_t v187;
  uint64_t v188;
  uint64_t v189;
  uint64_t v190;
  uint64_t v191;
  uint64_t v192;
  uint64_t v193;
  uint64_t v194;
  uint64_t v195;
  uint64_t v196;
  uint64_t v197;
  uint64_t v198;
  uint64_t v199;
  uint64_t v200;
  uint64_t v201;
  uint64_t v202;
  unsigned int *v203;
  _QWORD *v204;
  uint64_t v205;
  _QWORD *v206;
  uint64_t v207;
  _QWORD *v208;
  uint64_t v209;
  dispatch_object_s *v210;
  unsigned int *v211;
  uint64_t v212;
  uint64_t v213;
  uint64_t v214;
  _BOOL8 v215;
  int v216;
  int v217;
  _QWORD *v218;
  uint64_t v219;
  unint64_t v220;
  uint64_t v221;
  uint64_t v222;
  uint64_t v223;
  uint64_t v224;
  uint64_t v225;
  void *v226;
  mach_port_name_t v227;
  mach_port_name_t v228;
  int v229;
  char v230;
  _DWORD *v231;
  int v232;
  uint64_t v233;
  int v234;
  uint64_t v235;
  unsigned int *v236;
  uint64_t v237;
  uint64_t v238;
  unsigned int *v239;
  uint64_t v240;
  uint64_t v241;
  int v242;
  unint64_t v243;
  uint64_t v244;
  void *v245;
  unint64_t v246;
  uint64_t v247;
  int v248;
  uint64_t v249;
  int v250;
  void *v251;
  void *object;
  BOOL v253;
  uint64_t v254;
  BOOL v255;
  int v256;
  unsigned int *v257;
  uint64_t v258;
  _BOOL8 v259;
  int mach_voucher;
  uint64_t v261;
  _DWORD *v262;
  char v263;
  int v264;
  unsigned __int8 v265;
  int *v266;
  unsigned int v267;
  _QWORD *v268;
  unsigned int v269;
  unint64_t v270;
  uint64_t v271;
  unsigned int v272;
  unsigned int *v273;
  char v274;
  unsigned int v275;
  _DWORD *v276;
  char v277;
  dispatch_function_t v278;
  void *v279;
  dispatch_once_t *v280;
  unsigned int v281;
  uint64_t v282;
  int v283;
  uint64_t v284;
  _QWORD *v285;
  uint64_t v286;
  _OWORD v287[3];

  v134 = v164;
  v180 = a2;
  v179 = (unsigned int *)a1;
  v178 = a3;
  v177 = a4;
  v176 = a5;
  v133 = 0;
  v175 = 0;
  v175 = *(_QWORD *)(a1 + 120);
  v174 = a2;
  reply_disconnected = 0;
  v172 = 0;
  v172 = a2[8];
  v171 = 0;
  v135 = 0;
  v170 = 0;
  v169 = 0;
  msg = 0;
  msg = _dispatch_mach_msg_get_msg((uint64_t)a2);
  v167 = 0;
  v167 = (*(_DWORD *)msg & 0x1F) == 18;
  v166 = 0;
  v166 = *((_DWORD *)v174 + 13);
  memset(v287, 0, sizeof(v287));
  v165 = 0;
  memset(v164, 0, sizeof(v164));
  v163 = 0;
  if (!v167)
  {
    *((_WORD *)v179 + 59) &= ~1u;
    v12 = *(_QWORD *)(v175 + 48);
    v132 = 0;
    if (v12)
      v132 = v174 != *(_QWORD **)(v175 + 48);
    if (v132)
    {
      v162 = v175;
      v200 = v175;
      v199 = 0;
      v198 = *(_QWORD *)(v175 + 16);
      v199 = v198;
      v197 = v198;
      v225 = v198;
      v131 = 0;
      if (v198)
        v131 = _dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q;
      if (v131)
      {
        *((_WORD *)v179 + 59) |= 1u;
        return v170;
      }
      v13 = *(_QWORD *)(v175 + 48);
      v236 = v179;
      v235 = v13;
      v234 = 0;
      if ((v179[29] & 0x10) != 0)
      {
        v233 = v235;
        if (_dispatch_mach_msg_get_reply_port(v235))
        {
          v14 = *(_QWORD *)(v235 + 32);
          v239 = v236;
          v238 = v14;
          v237 = 0;
          v237 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(v14);
          if (!v237)
            v237 = (uint64_t)v239;
          v241 = v237;
          v240 = 1830;
          if (!v237)
            _dispatch_abort(v240, 0, v15, v16, v17, v18, v19, v20);
        }
      }
      if ((v234 & 0x40000) != 0)
      {
        *(_QWORD *)(v235 + 56) = 0;
      }
      else
      {
        v232 = 1;
        if ((v234 & 4) != 0)
          v232 |= 2u;
        v243 = 0;
        v242 = v232;
        if ((v232 & 1) != 0)
        {
          v245 = 0;
          v245 = _dispatch_thread_getspecific(4uLL);
          v243 = (unint64_t)v245;
        }
        v246 = v243;
        v243 &= 0xFFFFFFu;
        if ((v242 & 2) != 0 || (v130 = v243, v250 = 5, v249 = 4096, v243 <= 0x10FF))
        {
          v244 = v243;
        }
        else
        {
          v248 = 5;
          v247 = 4096;
          v244 = 4351;
        }
        *(_QWORD *)(v235 + 56) = v244;
      }
      v251 = 0;
      v251 = _dispatch_thread_getspecific(0x1CuLL);
      if (v251)
      {
        object = v251;
        os_retain(v251);
      }
      *(_QWORD *)(v235 + 64) = v251;
      v129 = 0;
      v21 = _dispatch_thread_getspecific(0);
      v22 = *(_QWORD *)(v235 + 64);
      v103 = (_QWORD *)v235;
      v102 = v22;
      v101 = v21;
      _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] set", v23, v24, v25, v26, v27, v28, v29, 1847);
      v234 |= _dispatch_mach_send_options();
      *(_DWORD *)(v235 + 48) = v234;
      v161 = *(_QWORD *)(v175 + 48);
      if (!_dispatch_mach_msg_send(v179, v161, 0, v177, 0))
      {
        v160 = 0;
        v160 = *(void **)(*(_QWORD *)(v175 + 48) + 64);
        if (v160)
        {
          v226 = v160;
          os_release(v160);
          *(_QWORD *)(*(_QWORD *)(v175 + 48) + 64) = 0;
        }
        return v170;
      }
      if ((v179[29] & 0x20) != 0)
        _dispatch_mach_arm_no_senders((uint64_t)v179, 1);
      *(_QWORD *)(v175 + 48) = 0;
    }
  }
  error_value = 0;
  v158 = 0;
  v157 = 0;
  v157 = *((_DWORD *)v174 + 12);
  if ((v157 & 2) != 0)
    goto LABEL_117;
  v156 = 0;
  v158 = (HIWORD(v157) << 16) | 1;
  if (v167)
  {
LABEL_88:
    if ((v157 & 4) != 0)
    {
      if ((*(_BYTE *)(v178 + 30) & 1) != 0)
      {
        v158 |= 0x100000u;
        _dispatch_clear_thread_reply_port(v166);
      }
      _dispatch_mach_reply_waiter_register((uint64_t)v179, v178, v166, v174);
    }
    v147 = (unint64_t)msg;
    v148 = *(unsigned int *)(msg + 4);
    *(_QWORD *)&v287[1] = v148;
    *((_OWORD *)v134 + 67) = (unint64_t)msg;
    v125 = (char *)&v287[1] + 8;
    *(_QWORD *)&v145 = v164;
    *((_QWORD *)&v145 + 1) = 0;
    v126 = v146;
    if (v163)
      v124 = v164[0];
    else
      v124 = 0;
    v64 = v125;
    *v126 = v124;
    v146[1] = 0;
    v65 = v145;
    *((_QWORD *)v64 + 2) = v146[0];
    *(_OWORD *)v64 = v65;
    v66 = *(_OWORD *)msg;
    v144 = *(_QWORD *)(msg + 16);
    v143 = v66;
    error_value = mach_msg2((int **)v287, v158 | 0x500000000, (unsigned int *)&v143, 2u, 0, 0, 0, v156);
    v122 = _dispatch_thread_getspecific(0);
    v119 = (const char *)v174[4];
    v121 = *(unsigned int *)(msg + 8);
    v120 = (_QWORD *)*(unsigned int *)(msg + 20);
    v118 = v158;
    v117 = v157;
    v116 = *(unsigned int *)(msg + 16);
    v115 = v166;
    v67 = mach_error_string(error_value);
    v123 = &v100;
    v110 = error_value;
    v109 = v67;
    v108 = v115;
    v107 = v116;
    v106 = v117;
    v105 = v118;
    v104 = v119;
    v103 = v120;
    v102 = v121;
    v101 = v122;
    _dispatch_log("%u\t%p\tmachport[0x%08x]: sent msg id 0x%x, ctxt %p, opts 0x%x, msg_opts 0x%x, kvoucher 0x%08x, reply on 0x%08x: %s - 0x%x", v68, v69, v70, v71, v72, v73, v74, 1193);
    v114 = 0;
    if (error_value)
      v114 = (v157 >> 2) & 1;
    if ((v114 & 1) != 0)
    {
      v142 = 36;
      v213 = v178;
      v212 = 1196;
      if (!v178)
        _dispatch_abort(v212, 0, v6, v7, v8, v9, v10, v11);
      _dispatch_mach_reply_unregister(v179, v178, v142);
    }
    if ((v169 & 1) != 0)
    {
      if (error_value == 268435461 && *(_DWORD *)(msg + 16))
      {
        v141 = error_value;
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher port corruption";
        qword_E4DA8 = error_value;
        __break(1u);
        JUMPOUT(0x7E2A0);
      }
      v140 = 0;
      v231 = (_DWORD *)msg;
      v230 = 0;
      v229 = 0;
      v229 = HIWORD(*(_DWORD *)msg) & 0x1F;
      v228 = 0;
      v228 = *(_DWORD *)(msg + 16);
      v227 = 0;
      if ((v229 == 19 || v229 == 17) && v228)
      {
        v75 = _dispatch_thread_getspecific(0);
        if ((v230 & 1) != 0)
          v83 = "move-send";
        else
          v83 = "copy-send";
        v104 = v83;
        v103 = v231;
        v102 = v228;
        v101 = v75;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v76, v77, v78, v79, v80, v81, v82, 520);
        if (v229 == 17)
        {
          if ((v230 & 1) != 0)
            v227 = v228;
          else
            _voucher_dealloc_mach_voucher(v228);
        }
        v231[4] = 0;
        *v231 &= 0xFFE0FFFF;
      }
      v140 = v227;
    }
LABEL_117:
    if (error_value == 268435460 && (v158 & 0x10) != 0)
    {
      if (*(_DWORD *)(msg + 8) == -1)
      {
        *(_DWORD *)msg &= 0xFFFFFFE0;
        *(_DWORD *)msg |= 0x13u;
      }
      if ((v158 & 0x80) != 0)
        _dispatch_mach_notification_set_armed(v175, v5, v6, v7, v8, v9, v10, v11);
      else
        *((_WORD *)v179 + 59) |= 1u;
    }
    else
    {
      v139 = 0;
      v139 = *((_QWORD *)v179 + 11);
      if ((v157 & 4) == 0 && !error_value)
      {
        if (v166)
        {
          v138 = v139;
          v188 = v139;
          v187 = 0;
          v186 = *(_QWORD *)(v139 + 16);
          v187 = v186;
          v185 = v186;
          v222 = v186;
          if (!v186 || *(_DWORD *)(v139 + 24) != v166)
            _dispatch_mach_reply_kevent_register(v179, v166, v174);
        }
      }
      v113 = 0;
      if (!v167)
      {
        v84 = *(_QWORD **)(v175 + 48);
        v113 = 0;
        if (v174 == v84)
        {
          v137 = v175;
          v184 = v175;
          v183 = 0;
          v182 = *(_QWORD *)(v175 + 16);
          v183 = v182;
          v181 = v182;
          v221 = v182;
          v113 = v182 != 0;
        }
      }
      if (v113)
      {
        v273 = v179;
        v112 = 0;
        v272 = 5;
        dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
        v271 = *((_QWORD *)v273 + 15);
        _dispatch_unote_unregister(v271, v272, v85, v86, v87, v88, v89, v90);
        *(_DWORD *)(*((_QWORD *)v273 + 15) + 24) = v112;
      }
      if (error_value)
      {
        if ((v179[29] & 0x10) != 0 && v174[4])
        {
          v91 = v174[4];
          v203 = v179;
          v202 = v91;
          v201 = 0;
          v201 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(v91);
          if (!v201)
            v201 = (uint64_t)v203;
          v171 = v201;
        }
        v136 = v174;
        if (v178)
          v111 = v178;
        else
          v111 = 0;
        if (v171)
          v92 = 12;
        else
          v92 = 7;
        reply_disconnected = (dispatch_object_s *)_dispatch_mach_msg_create_reply_disconnected((uint64_t)v136, v111, v92, v7, v8, v9, v10, v11);
      }
      _dispatch_mach_msg_set_reason((uint64_t)v174, error_value, 0, v7, v8, v9, v10, v11);
      if ((v176 & 8) != 0 && (v157 & 1) != 0)
        v170 |= 2u;
      else
        _dispatch_mach_handle_or_push_received_msg((uint64_t)v179, (dispatch_object_s *)v174, 0);
      if (reply_disconnected)
      {
        if (v171)
        {
          v211 = v179;
          v210 = reply_disconnected;
          v209 = v171;
          v208 = 0;
          v208 = _dispatch_mach_msg_async_reply_wrap((uint64_t)reply_disconnected, (uint64_t)v179);
          v207 = v209;
          v206 = v208;
          v219 = v209;
          v218 = v208;
          v217 = 0;
          v216 = 0;
          v286 = v209;
          v285 = v208;
          v96 = *(void (**)(uint64_t, _QWORD *, uint64_t, uint64_t, uint64_t, uint64_t))(*(_QWORD *)v209 + 72);
          v205 = v209;
          v204 = v208;
          LODWORD(v220) = *((_QWORD *)v210 + 7);
          v220 &= 0x3FFF00u;
          v220 >>= 8;
          v97 = __clz(__rbit32(v220));
          if ((_DWORD)v220)
            v98 = v97 + 1;
          else
            v98 = 0;
          v96(v205, v204, v98, v93, v94, v95);
        }
        else
        {
          _dispatch_mach_handle_or_push_received_msg((uint64_t)v179, reply_disconnected, 0);
        }
      }
      v170 |= 1u;
    }
    return v170;
  }
  if (v174 != *(_QWORD **)(v175 + 48))
    *(_DWORD *)(msg + 8) = *(_DWORD *)(v175 + 92);
  if (_dispatch_thread_getspecific(0x14uLL) != &_dispatch_mgr_q)
  {
LABEL_47:
    v158 |= 0x10u;
    if (v172 && *(_QWORD *)(v172 + 48))
    {
      v42 = v134;
      v163 = 32;
      *(_QWORD *)&v149 = 59821818;
      *((_QWORD *)&v149 + 1) = *(_QWORD *)(v172 + 48);
      v150 = *(_OWORD *)(v172 + 56);
      v43 = v149;
      *(_OWORD *)(v134 + 6) = v150;
      *(_OWORD *)(v42 + 2) = v43;
    }
    if (v163)
      v164[0] = v163 + 8;
    v44 = _dispatch_thread_getspecific(0);
    v103 = v174;
    v102 = v172;
    v101 = v44;
    _dispatch_log("%u\t%p\tvoucher[%p]: mach-msg[%p] msg_set", v45, v46, v47, v48, v49, v50, v51, 1149);
    v262 = (_DWORD *)msg;
    v261 = v172;
    if ((*(_DWORD *)msg & 0x1F0000) != 0)
    {
      v263 = 0;
    }
    else
    {
      mach_voucher = 0;
      if (v261)
      {
        mach_voucher = _voucher_get_mach_voucher(v261);
      }
      else
      {
        v280 = &_voucher_task_mach_voucher_pred;
        v279 = 0;
        v278 = (dispatch_function_t)_voucher_task_mach_voucher_init;
        if (_voucher_task_mach_voucher_pred != -1)
          dispatch_once_f(v280, v279, v278);
        mach_voucher = _voucher_task_mach_voucher;
      }
      v276 = v262;
      v275 = mach_voucher;
      v274 = 0;
      if ((*v262 & 0x1F0000) != 0)
      {
        v277 = 0;
      }
      else if (v275)
      {
        v276[4] = v275;
        if ((v274 & 1) != 0)
          v52 = 1114112;
        else
          v52 = 1245184;
        *v276 |= v52;
        v53 = _dispatch_thread_getspecific(0);
        if ((v274 & 1) != 0)
          v61 = "move-send";
        else
          v61 = "copy-send";
        v104 = v61;
        v103 = v276;
        v102 = v275;
        v101 = v53;
        _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v54, v55, v56, v57, v58, v59, v60, 476);
        v277 = 1;
      }
      else
      {
        v277 = 0;
      }
      v263 = v277;
    }
    v169 = v263;
    v268 = v174;
    v267 = v177;
    v266 = &v158;
    v281 = v177;
    if (v177 > 4)
      v128 = 5;
    else
      v128 = v281;
    v267 = v128;
    if (v128)
    {
      v265 = 0;
      v264 = 0;
      v270 = v268[7];
      v270 &= 0x3FFF00uLL;
      v270 >>= 8;
      v62 = __clz(__rbit32(v270));
      if ((_DWORD)v270)
        v63 = v62 + 1;
      else
        v63 = 0;
      v265 = v63;
      v282 = v268[7];
      v284 = v282;
      v127 = 0;
      if ((v282 & 0x22000000) == 0)
        v127 = (v284 & 0x3F00) != 0;
      if (v127)
      {
        v282 = v282;
        v283 = (char)v282 + 1;
      }
      else
      {
        v283 = 0;
      }
      v264 = v283;
      *v266 |= 0x20u;
      v269 = mach_msg_priority_encode_inline(v267, v265, v264);
    }
    else
    {
      v269 = 0;
    }
    v156 = v269;
    if (v166 && (v179[29] & 0x80) != 0)
      v158 |= 0x200u;
    goto LABEL_88;
  }
  v155 = v175;
  v196 = v175;
  v195 = 0;
  v194 = *(_QWORD *)(v175 + 16);
  v195 = v194;
  v193 = v194;
  v224 = v194;
  if (!v194)
  {
    v30 = *(_DWORD *)(msg + 8);
    v257 = v179;
    v256 = v30;
    dispatch_assert_queue_V2((dispatch_queue_t)&_dispatch_mgr_q);
    *(_DWORD *)(*((_QWORD *)v257 + 15) + 24) = v256;
    v255 = 0;
    v254 = *((_QWORD *)v257 + 15);
    v255 = _dispatch_unote_register(v254, -4, 0x2000000, v31, v32, v33, v34, v35);
    v259 = v255;
    v258 = 1743;
    if (!v255)
      _dispatch_bug(v258, v259, v36, v37, v38, v39, v40, v41);
    v253 = v255;
    v154 = v175;
    v192 = v175;
    v191 = 0;
    v190 = *(_QWORD *)(v175 + 16);
    v191 = v190;
    v189 = v190;
    v223 = v190;
    v215 = v190 != 0;
    v214 = 1125;
    if (!v190)
      _dispatch_abort(v214, v215, v36, v37, v38, v39, v40, v41);
  }
  v153 = 0;
  v152 = *(_BYTE *)(v175 + 30);
  v153 = v152 & 1;
  v151 = v152 & 1;
  if ((v152 & 1) == 0)
  {
    v158 |= 0x80u;
    goto LABEL_47;
  }
  return v170;
}

void _dispatch_mach_push_send_barrier_drain(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v9;
  _QWORD *v10;

  v10 = _dispatch_thread_getspecific(0x16uLL);
  if (v10)
  {
    _dispatch_thread_setspecific(22, v10[2]);
    v9 = v10;
  }
  else
  {
    v9 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v9 = &unk_E0CD0;
  v9[4] = 0;
  v9[5] = 0;
  v9[3] = -1;
  v9[1] = -1;
  _dispatch_lane_push(a1, v9, a2, v2, v3, v4, v5, v6);
}

void _dispatch_clear_thread_reply_port(int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v15 = _dispatch_thread_getspecific(8uLL);
  if (a1 == v15)
  {
    _dispatch_thread_setspecific(8, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: cleared thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 555);
  }
  else if (v15)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: did not clear thread sync reply port (found 0x%08x)", v1, v2, v3, v4, v5, v6, v7, 548);
  }
}

void *_dispatch_mach_reply_waiter_register(uint64_t a1, uint64_t a2, int a3, _QWORD *a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  void *v15;

  *(_QWORD *)(a2 + 8) = ~a1;
  *(_BYTE *)(a2 + 28) = -8;
  *(_DWORD *)(a2 + 24) = a3;
  if ((*(_BYTE *)(a2 + 30) & 1) == 0)
  {
    if (a4[8])
    {
      v15 = (void *)a4[8];
      os_retain(v15);
      *(_QWORD *)(a2 + 56) = v15;
    }
    *(_DWORD *)(a2 + 40) = a4[7];
    *(_QWORD *)(a2 + 48) = a4[4];
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for sync reply, ctxt %p", v4, v5, v6, v7, v8, v9, v10, 432);
  return _dispatch_mach_reply_list_insert(*(_QWORD *)(a1 + 120), a2);
}

uint64_t mach_msg2(int **a1, uint64_t a2, unsigned int *a3, unsigned int a4, unsigned int a5, unsigned int a6, uint64_t a7, unsigned int a8)
{
  unsigned int v9;
  int *v10;

  if ((a2 & 0x100000000) != 0)
    v10 = *a1;
  else
    v10 = (int *)a1;
  if ((a2 & 1) != 0 && *v10 < 0)
    v9 = v10[6];
  else
    v9 = 0;
  return mach_msg2_internal(a1, a2, *a3 | ((unint64_t)a4 << 32), a3[2] | ((unint64_t)a3[3] << 32), a3[4] | (unint64_t)((uint64_t)(int)a3[5] << 32), v9 | ((unint64_t)a6 << 32), a5 | ((unint64_t)a8 << 32), a7);
}

void _dispatch_mach_reply_kevent_register(unsigned int *a1, unsigned int a2, _QWORD *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  BOOL v24;
  BOOL v25;
  unsigned int *v26;
  unint64_t v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  unsigned int v31;
  uint64_t v32;
  _QWORD *v33;
  unsigned int v34;
  unint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  unint64_t v46;
  uint64_t v47;
  uint64_t v48;
  void *v49;
  unsigned int v50;
  uint64_t v51;
  uint64_t v52;
  unsigned int *v53;
  unsigned int v54;
  char v55;
  uint64_t v56;
  uint64_t v57;
  _BOOL8 v58;
  unint64_t v59;

  v35 = (unint64_t)a1;
  v34 = a2;
  v33 = a3;
  v31 = 0;
  v30 = 0;
  v29 = 0;
  v28 = 0;
  v27 = 0;
  v32 = _dispatch_unote_create_with_handle((uint64_t)&_dispatch_mach_type_reply, a2, 0);
  v48 = *(_BYTE *)(v32 + 29) & 1;
  v47 = 447;
  if (!v48)
    _dispatch_abort(v47, 0, v3, v4, v5, v6, v7, v8);
  *(_QWORD *)(v32 + 8) = ~v35;
  if (v33[8])
  {
    v49 = (void *)v33[8];
    os_retain(v49);
    *(_QWORD *)(v32 + 56) = v49;
  }
  *(_DWORD *)(v32 + 40) = v33[7];
  *(_QWORD *)(v32 + 48) = v33[4];
  v26 = 0;
  if (((*(_WORD *)(v35 + 116) >> 4) & 1) != 0 && v33[4])
  {
    v9 = v33[4];
    v46 = v35;
    v45 = v9;
    v44 = 0;
    v44 = (*(uint64_t (**)(uint64_t))((char *)&dword_10 + (_QWORD)_dispatch_mach_xpc_hooks))(v9);
    if (!v44)
      v44 = v46;
    v26 = (unsigned int *)v44;
  }
  if (((*(_WORD *)(v35 + 116) >> 7) & 1) != 0)
    *(_DWORD *)(v32 + 32) |= 0x200u;
  if (!v26 || (v25 = 0, v26 == (unsigned int *)v35))
  {
    v43 = *(_QWORD *)(v35 + 88);
    v42 = 0;
    v41 = *(_QWORD *)(v43 + 16);
    v42 = v41;
    v40 = v41;
    v52 = v41;
    v25 = (v41 & 0xFFFFFFFFFFFFFFFCLL) != 0;
  }
  if (v25)
  {
    v39 = *(_QWORD *)(v35 + 88);
    v38 = 0;
    v37 = *(_QWORD *)(v39 + 16);
    v38 = v37;
    v36 = v37;
    v51 = v37;
    v27 = v37 & 0xFFFFFFFFFFFFFFFCLL;
    v30 = *(_DWORD *)(v35 + 84);
  }
  else if ((*(_QWORD *)(*(_QWORD *)v26 + 16) & 0x10000) != 0)
  {
    v27 = -4;
    v53 = v26;
    v24 = 0;
    if (v26 >= (unsigned int *)&_dispatch_root_queues)
      v24 = v53 < (unsigned int *)&_dispatch_queue_serial_numbers;
    if (v24)
      v30 = v26[21];
    else
      v30 = 0x2000000;
  }
  else
  {
    v30 = _dispatch_queue_compute_priority_and_wlh((uint64_t)v26, (uint64_t *)&v27);
    if (!v30)
    {
      v27 = -4;
      v30 = v26[21];
    }
  }
  v56 = v33[7];
  v55 = 0;
  v58 = (v56 & 0x20000000) == 0;
  v57 = 447;
  if ((v56 & 0x20000000) != 0)
    _dispatch_abort(v57, 0, v3, v4, v5, v6, v7, v8);
  v54 = v56;
  v59 = v56 & 0x3FFF00;
  v59 >>= 8;
  v10 = __clz(__rbit32(v59));
  if ((_DWORD)v59)
    v11 = v10 + 1;
  else
    v11 = 0;
  v54 |= v11 << 8;
  v31 = v54;
  v29 = v30 & 0x80000000;
  v50 = v30 & 0xF000;
  v28 = v50 >> 12;
  if ((v30 & 0xFFF) != 0)
  {
    v30 &= 0xFFFu;
    if (v30 < v31)
      v30 = v31;
    v30 |= v29;
  }
  else if (v28 && v31)
  {
    v30 = v31 | v29;
  }
  else if (!v28 || v31)
  {
    v30 = 0x2000000;
    v27 = -4;
  }
  else
  {
    v30 = (v28 << 8) & 0xF00 | 0xFF | v29;
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for reply, ctxt %p", v12, v13, v14, v15, v16, v17, v18, 495);
  _dispatch_mach_reply_list_insert(*(_QWORD *)(v35 + 120), v32);
  if (!_dispatch_unote_register(v32, v27, v30, v19, v20, v21, v22, v23))
    _dispatch_mach_reply_unregister((unsigned int *)v35, v32, 52);
}

uint64_t _dispatch_mach_send_options()
{
  unsigned int v0;
  unsigned int v1;
  unsigned int v2;
  BOOL v4;

  v0 = (_dispatch_thread_getspecific(4uLL) & 0x3FFF00) >> 8;
  v1 = __clz(__rbit32(v0));
  if (v0)
    v2 = v1 + 1;
  else
    v2 = 0;
  v4 = 0;
  if (v2)
    v4 = v2 <= 2;
  if (v4)
    return 0x40000;
  else
    return 0;
}

uint64_t mach_msg_priority_encode_inline(unsigned __int8 a1, unsigned __int8 a2, char a3)
{
  unsigned int v4;

  v4 = 0;
  if (a2 && a2 <= 6u)
    v4 = (a2 << 16) | ((a3 - 1) << 8);
  if (a1 && a1 <= 6u)
    v4 |= a1 << 20;
  return v4;
}

void *_dispatch_mach_reply_list_insert(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  uint64_t v9;
  void *result;
  unsigned int v11;
  unsigned int v12;
  unsigned int *v13;
  unsigned int v14;
  unsigned int v17;
  unsigned int *v18;

  v18 = (unsigned int *)(a1 + 40);
  v17 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    v8 = __ldaxr(v18);
  while (!v8 && __stlxr(v17, v18));
  if (v8)
    _dispatch_unfair_lock_lock_slow(v18, 0x10000);
  if (*(_QWORD *)(a2 + 72))
    _dispatch_abort(302, *(_QWORD *)(a2 + 72) == 0, v2, v3, v4, v5, v6, v7);
  v9 = *(_QWORD *)(a1 + 56);
  *(_QWORD *)(a2 + 64) = v9;
  if (v9)
    *(_QWORD *)(*(_QWORD *)(a1 + 56) + 72) = a2 + 64;
  *(_QWORD *)(a1 + 56) = a2;
  *(_QWORD *)(a2 + 72) = a1 + 56;
  result = _dispatch_thread_getspecific(3uLL);
  v13 = (unsigned int *)(a1 + 40);
  v14 = *(_DWORD *)(a1 + 40);
  do
  {
    v11 = v14;
    do
      v12 = __ldaxr(v13);
    while (v12 == v14 && __stlxr(0, v13));
    v14 = v12;
  }
  while (v12 != v11);
  if (v12 != (result & 0xFFFFFFFC))
    return _dispatch_unfair_lock_unlock_slow(a1 + 40, v12);
  return result;
}

_QWORD *_dispatch_mach_msg_async_reply_wrap(uint64_t a1, uint64_t a2)
{
  _QWORD *v5;
  _QWORD *v6;

  _dispatch_retain(a2);
  v6 = _dispatch_thread_getspecific(0x16uLL);
  if (v6)
  {
    _dispatch_thread_setspecific(22, v6[2]);
    v5 = v6;
  }
  else
  {
    v5 = (_QWORD *)_dispatch_continuation_alloc_from_heap();
  }
  *v5 = &unk_E0D78;
  v5[6] = a1;
  v5[7] = a2;
  v5[1] = -1;
  v5[3] = -1;
  return v5;
}

uint64_t _dispatch_mach_send_push_and_trydrain(uint64_t a1, unint64_t a2, unsigned int a3, unsigned int a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  BOOL v15;
  BOOL v16;
  unint64_t *v17;
  unint64_t v18;
  unint64_t *v19;
  _BOOL4 v20;
  unint64_t *v21;
  _BOOL4 v22;
  unint64_t *v23;
  _BOOL4 v24;
  unint64_t v25;
  unsigned int v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unsigned int v33;
  uint64_t v34;
  char v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unsigned int v43;
  uint64_t v44;

  v34 = *(_QWORD *)(a1 + 120);
  v33 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v27 = 0;
  v26 = 0;
  *(_QWORD *)(a2 + 16) = 0;
  _dispatch_thread_setspecific(122, v34 + 72);
  v17 = (unint64_t *)(v34 + 72);
  v18 = *(_QWORD *)(v34 + 72);
  do
  {
    v4 = v18;
    do
      v5 = __ldaxr(v17);
    while (v5 == v18 && __stlxr(a2, v17));
    v18 = v5;
  }
  while (v5 != v4);
  v25 = v5;
  if (!v5)
  {
    _dispatch_retain_2(a1);
    v27 = 0xA000000000;
    v26 = 3;
  }
  if (v25)
    *(_QWORD *)(v25 + 16) = a2;
  else
    *(_QWORD *)(v34 + 80) = a2;
  _dispatch_thread_setspecific(122, 0);
  v16 = 1;
  if (!*(_DWORD *)(v34 + 88))
    v16 = (*(_DWORD *)(a1 + 80) & 0x10000000) != 0;
  if (v16)
  {
    v23 = (unint64_t *)(v34 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v6 = __ldaxr(v23);
      else
        v6 = __ldxr(v23);
      v31 = v6;
      v42 = v6;
      if ((v6 & 0x700000000) < (unint64_t)a3 << 32)
        v42 = v6 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      v28 = v42 | v27;
      if (_os_atomic_mo_has_release(3))
        v24 = __stlxr(v28, v23) == 0;
      else
        v24 = __stxr(v28, v23) == 0;
    }
    while (!v24);
    if (((v31 ^ v28) & 0x8000000000) != 0)
      v26 &= ~1u;
    goto LABEL_70;
  }
  if (v27)
  {
    v21 = (unint64_t *)(v34 + 64);
    do
    {
      if (_os_atomic_mo_has_acquire(5))
        v7 = __ldaxr(v21);
      else
        v7 = __ldxr(v21);
      v32 = v7;
      v41 = v7;
      if ((v7 & 0x700000000) < (unint64_t)a3 << 32)
        v41 = v7 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      v29 = v41 | v27;
      if ((v7 & 0x10FFFFFFFFLL) == 0)
        v29 = (v29 | v33) & 0xFFFFFFC7FFFFFFFFLL;
      if (_os_atomic_mo_has_release(5))
        v22 = __stlxr(v29, v21) == 0;
      else
        v22 = __stxr(v29, v21) == 0;
    }
    while (!v22);
    if (((v32 ^ v29) & 0x8000000000) != 0)
      v26 &= ~1u;
LABEL_57:
    if ((v32 & 0xFFFFFFFC) != 0)
      v43 = v32 | 3;
    else
      v43 = 0;
    if (v43)
    {
      if ((v32 & 0x700000000) < (unint64_t)a3 << 32 && (_dispatch_set_qos_class_enabled & 1) != 0)
      {
        v44 = 0;
        if (a3)
          v44 = 1 << (a3 + 7);
        _pthread_workqueue_override_start_direct_check_owner(v43, v44 | 0xFF, v34 + 64);
      }
      if ((v26 & 1) != 0)
        _dispatch_release_2((unsigned int *)a1);
      v39 = 0;
    }
    else
    {
      if ((v32 & 0x1000000000) != 0)
      {
LABEL_70:
        (*(void (**)(uint64_t, _QWORD, _QWORD))(*(_QWORD *)a1 + 64))(a1, a3, v26);
        v39 = 0;
        return v39 & 1;
      }
      v15 = 0;
      if (v26)
        v15 = a2 == *(_QWORD *)(v34 + 80);
      if (!v15)
        a4 &= ~8u;
      if ((v26 & 1) != 0)
        _dispatch_release_2_no_dispose(a1);
      v39 = _dispatch_mach_send_drain(a1, 0, a4, v8, v9, v10, v11, v12) & 1;
    }
  }
  else
  {
    v19 = (unint64_t *)(v34 + 64);
    while (1)
    {
      if (_os_atomic_mo_has_acquire(2))
        v13 = __ldaxr(v19);
      else
        v13 = __ldxr(v19);
      v32 = v13;
      v40 = v13;
      if ((v13 & 0x700000000) < (unint64_t)a3 << 32)
        v40 = v13 & 0xFFFFFFF8FFFFFFFFLL | ((unint64_t)a3 << 32) | 0x2800000000;
      v30 = v40;
      if (v40 == v13)
        break;
      if ((v13 & 0x10FFFFFFFFLL) == 0)
        v30 = (v40 | v33) & 0xFFFFFFC7FFFFFFFFLL;
      if (_os_atomic_mo_has_release(2))
        v20 = __stlxr(v30, v19) == 0;
      else
        v20 = __stxr(v30, v19) == 0;
      if (v20)
        goto LABEL_57;
    }
    __clrex();
    v39 = 0;
  }
  return v39 & 1;
}

uint64_t _dispatch_get_thread_reply_port()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  BOOL v15;
  unsigned int v16;
  unsigned int special_reply_port;

  v16 = _dispatch_thread_getspecific(8uLL);
  if (v16)
  {
    special_reply_port = v16;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: borrowed thread sync reply port", v0, v1, v2, v3, v4, v5, v6, 526);
  }
  else
  {
    special_reply_port = thread_get_special_reply_port();
    _dispatch_thread_setspecific(8, special_reply_port);
    v15 = 0;
    if (special_reply_port)
      v15 = special_reply_port != -1;
    if (!v15)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate reply port, possible port leak";
      __break(1u);
      JUMPOUT(0x80740);
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: allocated thread sync reply port", v7, v8, v9, v10, v11, v12, v13, 535);
  }
  return special_reply_port;
}

void _dispatch_mach_msg_reply_received(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  dispatch_object_s *v19;
  uint64_t v20;
  unsigned int v21;
  BOOL v22;
  uint64_t v23;
  unsigned int v24;
  uint64_t v25;
  uint64_t v26;

  v26 = a1;
  v25 = a2;
  v24 = a3;
  v23 = a2;
  v22 = 0;
  v22 = _dispatch_mach_reply_list_tryremove(*(_QWORD *)(a1 + 120), a2);
  v21 = 0;
  v21 = *(_DWORD *)(v23 + 24);
  if (v22)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistered for sync reply, ctxt %p", v7, v8, v9, v10, v11, v12, v13, 906);
  }
  if ((*(_BYTE *)(v23 + 30) & 1) != 0)
  {
    if (v24 != v21 && (v22 || v24 && v24 != -1))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Reply received on unexpected port";
      qword_E4DA8 = v24;
      __break(1u);
      JUMPOUT(0x808C4);
    }
    if (v22)
      _dispatch_set_thread_reply_port(v21);
    else
      _dispatch_destruct_reply_port(v21, 2u);
  }
  else if (v24 && v24 != -1 && v22)
  {
    v20 = 0;
    v19 = (dispatch_object_s *)dispatch_mach_msg_create(0, 0x18uLL, 0, &v20, v3, v4, v5, v6);
    *(_DWORD *)(v20 + 12) = v24;
    *((_QWORD *)v19 + 8) = *(_QWORD *)(v23 + 56);
    *(_QWORD *)(v23 + 56) = 0;
    *((_QWORD *)v19 + 7) = *(unsigned int *)(v23 + 40);
    *((_QWORD *)v19 + 4) = *(_QWORD *)(v23 + 48);
    _dispatch_mach_msg_set_reason((uint64_t)v19, 0, 9, v14, v15, v16, v17, v18);
    _dispatch_mach_handle_or_push_received_msg(v26, v19, 0);
  }
}

BOOL _dispatch_mach_reply_list_tryremove(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v11;
  unsigned int *v13;
  unsigned int v14;
  BOOL v15;
  unsigned int v18;
  unsigned int *v19;
  unsigned int v20;

  v19 = (unsigned int *)(a1 + 40);
  v18 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    v9 = __ldaxr(v19);
  while (!v9 && __stlxr(v18, v19));
  if (v9)
    _dispatch_unfair_lock_lock_slow(v19, 0x10000);
  v15 = *(_QWORD *)(a2 + 72) != 0;
  if (*(_QWORD *)(a2 + 72))
    _dispatch_mach_reply_list_remove_locked(a2, v2, v3, v4, v5, v6, v7, v8);
  v20 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v13 = (unsigned int *)(a1 + 40);
  v14 = *(_DWORD *)(a1 + 40);
  do
  {
    v10 = v14;
    do
      v11 = __ldaxr(v13);
    while (v11 == v14 && __stlxr(0, v13));
    v14 = v11;
  }
  while (v11 != v10);
  if (v11 != v20)
    _dispatch_unfair_lock_unlock_slow(a1 + 40, v11);
  return v15;
}

void _dispatch_set_thread_reply_port(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if (_dispatch_thread_getspecific(8uLL))
  {
    _dispatch_destruct_reply_port(a1, 0);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: deallocated sync reply port (found 0x%08x)", v1, v2, v3, v4, v5, v6, v7, 567);
  }
  else
  {
    _dispatch_thread_setspecific(8, a1);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: restored thread sync reply port", v8, v9, v10, v11, v12, v13, v14, 571);
  }
}

void _dispatch_mach_msg_disconnected(uint64_t a1, int a2, int a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  dispatch_object_s *v20;
  uint64_t v21;
  int v22;
  int v23;
  uint64_t v24;

  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = 0;
  v20 = (dispatch_object_s *)dispatch_mach_msg_create(0, 0x18uLL, 0, &v21, a5, a6, a7, a8);
  if (v23)
    *(_DWORD *)(v21 + 12) = v23;
  if (v22)
    *(_DWORD *)(v21 + 8) = v22;
  _dispatch_mach_msg_set_reason((uint64_t)v20, 0, 7, v8, v9, v10, v11, v12);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: %s right disconnected", v13, v14, v15, v16, v17, v18, v19, 955);
  _dispatch_mach_handle_or_push_received_msg(v24, v20, 0);
}

void _dispatch_mach_handle_wlh_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int *v10;
  unsigned int v11;

  v10 = (unsigned int *)(a1 + 80);
  v11 = *(_DWORD *)(a1 + 80);
  do
  {
    v8 = v11;
    do
      v9 = __ldaxr(v10);
    while (v9 == v11 && __stlxr(v11 | 0x8000000, v10));
    v11 = v9;
  }
  while (v9 != v8);
  if ((v9 & 0x400000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after xpc connection was activated";
      __break(1u);
      JUMPOUT(0x80F64);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Changing target queue hierarchy after mach channel was connected";
    __break(1u);
    JUMPOUT(0x80F90);
  }
  if ((v9 & 0x8000000) == 0)
  {
    if ((*(_WORD *)(a1 + 116) & 0x10) != 0)
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after xpc connection was activated", a2, a3, a4, a5, a6, a7, a8);
    else
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy after mach channel was connected", a2, a3, a4, a5, a6, a7, a8);
  }
}

BOOL _dispatch_mach_cancel(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unsigned int *v23;
  unsigned int v24;
  int v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  BOOL v29;
  unsigned int *v31;
  _BOOL4 v32;
  unsigned int v33;
  unsigned int v34;
  unsigned int v35;

  v29 = (*(_BYTE *)(a1 + 118) & 2) != 0;
  if (*(_DWORD *)(*(_QWORD *)(a1 + 120) + 88))
    v29 = 0;
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_mach_cancel");
  v28 = 1;
  if ((*(_DWORD *)(a1 + 80) & 0x40000000) == 0)
    v28 = 3;
  v27 = *(_QWORD *)(a1 + 128);
  if (v27 && (_dispatch_unote_unregister(v27, v28, v8, v9, v10, v11, v12, v13) & 1) == 0)
    v29 = 0;
  v26 = *(_QWORD *)(a1 + 88);
  v25 = *(_DWORD *)(v26 + 24);
  if (v25)
  {
    if (_dispatch_unote_unregister(v26, v28, v8, v9, v10, v11, v12, v13))
    {
      _dispatch_mach_msg_disconnected(a1, v25, 0, v14, v15, v16, v17, v18);
      *(_DWORD *)(v26 + 24) = 0;
    }
    else
    {
      v29 = 0;
    }
  }
  if (v29)
  {
    v31 = (unsigned int *)(a1 + 80);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v19 = __ldaxr(v31);
      else
        v19 = __ldxr(v31);
      v34 = v19;
      v33 = v19 & 0x3FFFFFFF | 0x80000000;
      if ((v34 & 0x3FFFFFFF | 0x80000000) == v34)
      {
        __clrex();
        v35 = v19;
        goto LABEL_24;
      }
      if (_os_atomic_mo_has_release(0))
        v32 = __stlxr(v33, v31) == 0;
      else
        v32 = __stxr(v33, v31) == 0;
    }
    while (!v32);
    v35 = v34;
LABEL_24:
    if ((v35 & 0xA0000000) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corrupt channel state";
      qword_E4DA8 = v35;
      __break(1u);
      JUMPOUT(0x8132CLL);
    }
    _dispatch_release_no_dispose(a1);
  }
  else
  {
    v23 = (unsigned int *)(a1 + 80);
    v24 = *(_DWORD *)(a1 + 80);
    do
    {
      v20 = v24;
      do
        v21 = __ldaxr(v23);
      while (v21 == v24 && __stlxr(v24 | 0x40000000, v23));
      v24 = v21;
    }
    while (v21 != v20);
  }
  return v29;
}

uint64_t _dispatch_mach_cancel_invoke(uint64_t a1, int a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;

  v4 = *(_QWORD *)(a1 + 88);
  v3 = 0;
  if ((a2 & 0x1000000) != 0)
    v3 = _dispatch_autorelease_pool_push();
  if (((*(_WORD *)(a1 + 116) >> 2) & 1) == 0)
    _dispatch_mach_connect_invoke(a1);
  result = _dispatch_client_callout4(*(_QWORD *)(v4 + 48), 8, 0, 0, *(uint64_t (**)(uint64_t, uint64_t, uint64_t, _QWORD))(v4 + 40));
  if (v3)
    result = _dispatch_autorelease_pool_pop(v3);
  *(_WORD *)(a1 + 116) = *(_WORD *)(a1 + 116) & 0xFFF7 | 8;
  return result;
}

uint64_t _dispatch_unote_create_with_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
    return _dispatch_unote_create(a1, a2, a3);
  else
    return 0;
}

uint64_t _dispatch_unote_create(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v4;
  int v5;

  v5 = a3;
  if ((a3 & ~*(_DWORD *)(a1 + 20)) != 0)
    return 0;
  if (*(_DWORD *)(a1 + 20) && (*(_BYTE *)(a1 + 10) & 4) == 0 && !a3)
    return 0;
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0)
    v4 = _dispatch_calloc(1, *(unsigned int *)(a1 + 24));
  else
    v4 = _dispatch_calloc(1, *(unsigned int *)(a1 + 24) + 24) + 24;
  *(_QWORD *)v4 = a1;
  *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0xDF | (32 * (*(_BYTE *)(a1 + 10) & 1));
  *(_DWORD *)(v4 + 24) = a2;
  *(_BYTE *)(v4 + 28) = *(_BYTE *)(a1 + 8);
  *(_DWORD *)(v4 + 32) = v5;
  if ((*(_WORD *)(a1 + 12) & 0x100) != 0)
    *(_BYTE *)(v4 + 29) = *(_BYTE *)(v4 + 29) & 0xFE | 1;
  return v4;
}

uint64_t _dispatch_unote_create_with_fd(uint64_t a1, int a2, uint64_t a3)
{
  return _dispatch_unote_create(a1, a2, a3);
}

uint64_t _dispatch_unote_create_without_handle(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a2)
    return 0;
  else
    return _dispatch_unote_create(a1, 0, a3);
}

void _dispatch_unote_dispose(uint64_t a1)
{
  BOOL v1;
  void *v2;

  v2 = (void *)a1;
  if ((*(_BYTE *)(a1 + 29) & 0x40) != 0)
    _Block_release(*(const void **)(a1 + 48));
  if ((*(_BYTE *)(a1 + 29) & 2) != 0)
  {
    v1 = 1;
    if (*(_DWORD *)(a1 + 112) == -1)
      v1 = *(_DWORD *)(a1 + 116) != -1;
    if (v1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Disposing of timer still in its heap";
      __break(1u);
      JUMPOUT(0x8188CLL);
    }
    if (*(_QWORD *)(a1 + 104))
    {
      free(*(void **)(a1 + 104));
      *(_QWORD *)(a1 + 104) = 0;
    }
  }
  else if ((*(_BYTE *)(a1 + 29) & 1) == 0)
  {
    v2 = (void *)(a1 - 24);
  }
  free(v2);
}

BOOL _dispatch_unote_register(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;
  BOOL v10;
  int v11;
  unsigned int v12;

  v12 = a3;
  v10 = 1;
  if ((*(_BYTE *)(a1 + 29) & 2) == 0)
    v10 = *(_QWORD *)(a1 + 16) == 0;
  if (!v10)
    _dispatch_abort(127, v10, a3, a4, a5, a6, a7, a8);
  v11 = a3 & 0x4600FFFF;
  v9 = 1;
  if (a2 != -4)
    v9 = v11 != 0;
  if (!v9)
    _dispatch_abort(136, v9, a3, a4, a5, a6, a7, a8);
  if (v11 == 67125248 && MEMORY[0xFFFFFC100])
    kdebug_trace(771883044, ~*(_QWORD *)(a1 + 8), 0, 0, 0);
  *(_DWORD *)(a1 + 36) = v12;
  if ((*(char *)(a1 + 28) + 23) > 2)
  {
    if ((*(_BYTE *)(a1 + 29) & 2) != 0)
    {
      _dispatch_timer_unote_register(a1, a2, v12, a4, a5, a6, a7, a8);
      return 1;
    }
    else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
    {
      return _dispatch_unote_register_direct((uint64_t *)a1, a2);
    }
    else
    {
      return _dispatch_unote_register_muxed((uint64_t *)a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  else
  {
    *(_QWORD *)(a1 + 16) = -3;
    return 1;
  }
}

void _dispatch_timer_unote_register(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  unsigned int v11;
  int v12;

  v11 = (unsigned __int16)(a3 & 0xF00) >> 8;
  v8 = 0;
  if (v11)
    v8 = v11 <= 2;
  if (v8)
  {
    if ((*(_BYTE *)(a1 + 30) & 1) != 0)
    {
      if (MEMORY[0xFFFFFC100])
        kdebug_trace(771883032, ~*(_QWORD *)(a1 + 8), 0, 0, 0);
    }
    else
    {
      *(_BYTE *)(a1 + 30) |= 2u;
      v12 = _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30));
      if ((*(_BYTE *)(a1 + 30) & 3u) >= 3)
        _dispatch_abort(781, (*(_BYTE *)(a1 + 30) & 3u) < 3, a3, a4, a5, a6, a7, a8);
      *(_DWORD *)(a1 + 24) = 3 * v12 + (*(_BYTE *)(a1 + 30) & 3);
    }
  }
  if ((*(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != a2)
  {
    if ((*(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) != 0)
      _dispatch_abort(853, (*(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL) == 0, a3, a4, a5, a6, a7, a8);
    *(_QWORD *)(a1 + 16) = -4;
  }
  if (*(_QWORD *)(a1 + 104))
    _dispatch_timer_unote_configure(a1);
}

void _dispatch_unote_resume(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  char v9;
  uint64_t v10;

  v9 = 1;
  if ((*(_BYTE *)(a1 + 29) & 2) == 0)
  {
    v10 = *(_QWORD *)(a1 + 16);
    v8 = 0;
    if (v10)
    {
      v8 = 0;
      if ((v10 & 1) == 0)
        v8 = (v10 & 2) == 0;
    }
    v9 = v8;
  }
  if ((v9 & 1) == 0)
    _dispatch_abort(166, v9 & 1, a3, a4, a5, a6, a7, a8);
  if ((*(_BYTE *)(a1 + 29) & 2) != 0)
  {
    _dispatch_timer_unote_resume(a1);
  }
  else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
  {
    _dispatch_unote_resume_direct((uint64_t *)a1);
  }
  else
  {
    _dispatch_unote_resume_muxed(a1, a2, a3, a4, a5, a6, a7, a8);
  }
}

void _dispatch_timer_unote_resume(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  BOOL v13;
  BOOL v14;
  BOOL v15;
  void *v16;
  unsigned int v17;
  BOOL v18;
  unsigned int v20;
  int v21;
  BOOL v22;

  if ((*(_QWORD *)(55 - *(_QWORD *)(a1 + 8)) & 0xFF80000000000000) != 0)
  {
    v22 = 0;
  }
  else
  {
    v15 = 0;
    if (*(_DWORD *)(a1 + 24) != -1)
      v15 = *(_QWORD *)(a1 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
    v22 = v15;
  }
  v18 = (*(_QWORD *)(a1 + 16) & 1) != 0;
  v21 = _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30));
  v20 = *(_BYTE *)(a1 + 30) & 3;
  if (v20 >= 3)
    _dispatch_abort(781, v20 < 3, v1, v2, v3, v4, v5, v6);
  v17 = 3 * v21 + v20;
  v16 = _dispatch_timer_unote_heap(a1);
  v14 = 0;
  if (v18)
  {
    v13 = 1;
    if (v22)
      v13 = *(_DWORD *)(a1 + 24) != v17;
    v14 = v13;
  }
  if (v14)
    _dispatch_timer_unote_disarm(a1, (uint64_t)v16, v7, v8, v9, v10, v11, v12);
  if (v22)
  {
    if (!v18)
      _dispatch_retain_2(~*(_QWORD *)(a1 + 8));
    _dispatch_timer_unote_arm(a1, (uint64_t)v16, v17);
  }
  else if (v18)
  {
    _dispatch_release_2_tailcall((unsigned int *)~*(_QWORD *)(a1 + 8));
  }
}

uint64_t _dispatch_unote_unregister(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;

  if (*(_QWORD *)(a1 + 16))
  {
    if ((*(char *)(a1 + 28) + 23) > 2)
    {
      if ((*(_BYTE *)(a1 + 29) & 2) != 0)
      {
        _dispatch_timer_unote_unregister(a1);
        v9 = 1;
      }
      else if ((*(_BYTE *)(a1 + 29) & 1) != 0)
      {
        v9 = _dispatch_unote_unregister_direct(a1, a2) & 1;
      }
      else
      {
        if ((a2 & 1) == 0)
          _dispatch_abort(201, a2 & 1, a3, a4, a5, a6, a7, a8);
        v9 = _dispatch_unote_unregister_muxed(a1, a2, a3, a4, a5, a6, a7, a8) & 1;
      }
    }
    else
    {
      *(_QWORD *)(a1 + 16) = 0;
      v9 = 1;
    }
  }
  else
  {
    v9 = 1;
  }
  return v9 & 1;
}

void _dispatch_timer_unote_unregister(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  unsigned int v8;
  unsigned int *v9;
  unsigned int v10;
  void *v11;
  unint64_t v13;

  v11 = _dispatch_timer_unote_heap(a1);
  if ((*(_QWORD *)(a1 + 16) & 1) != 0)
  {
    _dispatch_timer_unote_disarm(a1, (uint64_t)v11, v1, v2, v3, v4, v5, v6);
    _dispatch_release_2_no_dispose(~*(_QWORD *)(a1 + 8));
  }
  v13 = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v13 && v13 != -4)
  {
    v9 = (unsigned int *)(v13 + 96);
    v10 = *(_DWORD *)(v13 + 96);
    do
    {
      v7 = v10;
      do
        v8 = __ldaxr(v9);
      while (v8 == v10 && __stlxr(v10 - 1, v9));
      v10 = v8;
    }
    while (v8 != v7);
    if (((v8 - 1) & 0x80000000) != 0)
    {
      if ((int)(v8 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x8291CLL);
      }
      *(_QWORD *)(v13 + 56) = 0xDEAD000000000000;
      _dispatch_object_dealloc((_QWORD *)v13);
    }
  }
  *(_QWORD *)(a1 + 16) = 0;
  *(_DWORD *)(a1 + 24) = -1;
}

uint64_t _dispatch_source_data_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;

  if (a2 || a3)
    return 0;
  v3 = _dispatch_calloc(1, *(unsigned int *)(a1 + 24));
  *(_QWORD *)v3 = a1;
  *(_BYTE *)(v3 + 28) = *(_BYTE *)(a1 + 8);
  *(_BYTE *)(v3 + 29) = *(_BYTE *)(v3 + 29) & 0xFE | 1;
  return v3;
}

uint64_t _dispatch_source_signal_create(uint64_t a1, unint64_t a2, uint64_t a3)
{
  if (a2 < 0x20)
    return _dispatch_unote_create_with_handle(a1, a2, a3);
  else
    return 0;
}

void _dispatch_timer_unote_configure(uint64_t a1)
{
  unint64_t v1;
  unint64_t v2;
  int v3;
  _DWORD *v4;
  unint64_t *v5;
  unint64_t v6;

  v6 = *(_QWORD *)(a1 + 104);
  do
  {
    v1 = v6;
    v5 = (unint64_t *)(a1 + 104);
    do
      v2 = __ldaxr(v5);
    while (v2 == v6 && __stlxr(0, v5));
    v4 = (_DWORD *)v2;
    v6 = v2;
  }
  while (v2 != v1);
  v3 = *(_DWORD *)(v2 + 24);
  if (v3 != _dispatch_timer_flags_to_clock(*(_BYTE *)(a1 + 30)))
  {
    *(_BYTE *)(a1 + 30) &= 0xF3u;
    *(_BYTE *)(a1 + 30) |= _dispatch_timer_flags_from_clock(v4[6]);
  }
  *(_OWORD *)(a1 + 80) = *(_OWORD *)v4;
  *(_QWORD *)(a1 + 96) = *((_QWORD *)v4 + 2);
  free(v4);
  *(_QWORD *)(a1 + 72) = 0;
  if ((*(_QWORD *)(a1 + 16) & 1) != 0)
    _dispatch_timer_unote_resume(a1);
}

uint64_t _dispatch_source_timer_create(uint64_t a1, unint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v10;
  unsigned int v11;
  unsigned int v14;
  int v15;

  v11 = a3;
  if ((a3 & 1) != 0)
    v11 = a3 & 0xFFFFFFFD;
  if ((v11 & ~*(_DWORD *)(a1 + 20)) != 0)
    return 0;
  if ((*(_BYTE *)(a1 + 11) & 0x10) != 0)
  {
    if (!a2)
      return 0;
    goto LABEL_16;
  }
  if (*(char *)(a1 + 8) == -20)
  {
    if (a2)
      return 0;
LABEL_16:
    v10 = _dispatch_calloc(1, *(unsigned int *)(a1 + 24));
    *(_QWORD *)v10 = a1;
    *(_BYTE *)(v10 + 28) = *(_BYTE *)(a1 + 8);
    *(_BYTE *)(v10 + 29) = *(_BYTE *)(v10 + 29) & 0xFD | 2;
    *(_BYTE *)(v10 + 30) |= v11 | *(_BYTE *)(a1 + 11);
    v15 = _dispatch_timer_flags_to_clock(*(_BYTE *)(v10 + 30));
    v14 = *(_BYTE *)(v10 + 30) & 3;
    if (v14 >= 3)
      _dispatch_abort(781, v14 < 3, v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(v10 + 24) = 3 * v15 + v14;
    *(_QWORD *)(v10 + 80) = -1;
    *(_QWORD *)(v10 + 88) = -1;
    *(_QWORD *)(v10 + 96) = -1;
    *(_DWORD *)(v10 + 112) = -1;
    *(_DWORD *)(v10 + 116) = -1;
    return v10;
  }
  if (a2 <= 3)
    __asm { BR              X8 }
  return 0;
}

void _dispatch_event_loop_drain_timers(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int i;
  unsigned int j;
  _QWORD v10[3];
  unsigned int v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  memset(v10, 0, sizeof(v10));
  do
  {
    for (i = 0; i < v11; ++i)
      _dispatch_timers_run(v12, i, (uint64_t)v10, a4, a5, a6, a7, a8);
    *(_BYTE *)(v12 + 6) = 0;
    for (j = 0; j < v11; ++j)
    {
      if ((*(_BYTE *)(v12 + 32 * j + 7) & 2) != 0)
        _dispatch_timers_program(v12, j, (uint64_t)v10, a4, a5, a6, a7, a8);
    }
  }
  while (*(_BYTE *)(v12 + 6));
}

void _dispatch_timers_run(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unint64_t v10;
  unint64_t v11;
  BOOL v12;
  unint64_t *v13;
  unint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  unsigned int v17;
  unint64_t v18;
  uint64_t v19;
  BOOL v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unsigned int v28;
  unint64_t v29;
  int v30;
  int v31;
  unint64_t v32;
  unint64_t v33;
  uint64_t v34;
  int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unint64_t v41;
  uint64_t v42;
  unint64_t v43;
  _QWORD *v44;

  while (1)
  {
    v19 = *(_QWORD *)(a1 + 32 * a2 + 8);
    if (!v19)
      break;
    v17 = *(_DWORD *)(v19 + 24);
    if (v17 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_E4DA8 = v17;
      __break(1u);
      JUMPOUT(0x83280);
    }
    if (!*(_QWORD *)(v19 + 80))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: missing target";
      qword_E4DA8 = 0;
      __break(1u);
      JUMPOUT(0x832E4);
    }
    v28 = a2 / 3;
    v27 = a3;
    if (!*(_QWORD *)(a3 + 8 * (a2 / 3)))
    {
      v26 = 0;
      v25 = 0;
      mach_get_times(v27, v27 + 8, &v25);
      *(_QWORD *)(v27 + 16) = 1000000000 * v25 + v26;
    }
    v29 = *(_QWORD *)(v27 + 8 * v28);
    if (*(_QWORD *)(v19 + 80) > v29)
      break;
    if ((*(_BYTE *)(v19 + 30) & 0x40) != 0)
    {
      _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
      v24 = *(_QWORD *)(v19 + 16) & 0xFFFFFFFFFFFFFFFCLL;
      if (v24 && v24 != -4)
      {
        v15 = (unsigned int *)(v24 + 96);
        v16 = *(_DWORD *)(v24 + 96);
        do
        {
          v8 = v16;
          do
            v9 = __ldaxr(v15);
          while (v9 == v16 && __stlxr(v16 - 1, v15));
          v16 = v9;
        }
        while (v9 != v8);
        if (((v9 - 1) & 0x80000000) != 0)
        {
          if ((int)(v9 - 1) <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x8355CLL);
          }
          *(_QWORD *)(v24 + 56) = 0xDEAD000000000000;
          _dispatch_object_dealloc((_QWORD *)v24);
        }
      }
      *(_QWORD *)(v19 + 16) = 0;
      *(_QWORD *)(v19 + 72) = 2;
      v39 = v19;
      v38 = 1;
      v37 = 1;
      v36 = 0;
      v35 = 0;
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v19 + 48))(v19, 16, 0);
    }
    else if (*(_QWORD *)(v19 + 104))
    {
      _dispatch_timer_unote_configure(v19);
    }
    else
    {
      if (*(_QWORD *)(v19 + 72))
      {
        _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
        v13 = (unint64_t *)(v19 + 72);
        v14 = *(_QWORD *)(v19 + 72);
        do
        {
          v10 = v14;
          do
            v11 = __ldaxr(v13);
          while (v11 == v14 && __stlxr(v14 | 1, v13));
          v14 = v11;
        }
        while (v11 != v10);
        v18 = v11;
      }
      else
      {
        v44 = (_QWORD *)v19;
        v43 = v29;
        v42 = 0;
        v41 = 0;
        v41 = (v29 - *(_QWORD *)(v19 + 80)) / *(_QWORD *)(v19 + 96);
        if ((++v41 & 0x8000000000000000) != 0)
          v41 = v42 ^ 0x7FFFFFFFFFFFFFFFLL;
        if (v44[12] > 0x7FFFFFFFFFFFFFFEuLL)
        {
          v44[10] = -1;
          v44[11] = -1;
        }
        else
        {
          v40 = 0;
          v40 = v41 * v44[12];
          v44[10] += v40;
          v44[11] += v40;
        }
        v42 += v41;
        v18 = 2 * v42;
        if ((*(_QWORD *)(55 - *(_QWORD *)(v19 + 8)) & 0xFF80000000000000) != 0)
        {
          if (MEMORY[0xFFFFFC100])
            kdebug_trace(771883036, ~*(_QWORD *)(v19 + 8), 0, 0, 0);
          v23 = 0;
        }
        else
        {
          v12 = 0;
          if (*(_DWORD *)(v19 + 24) != -1)
            v12 = *(_QWORD *)(v19 + 80) < 0x7FFFFFFFFFFFFFFFuLL;
          v23 = v12;
        }
        if (v23)
        {
          _dispatch_retain_2(~*(_QWORD *)(v19 + 8));
          _dispatch_timer_unote_arm(v19, a1, a2);
          *(_QWORD *)(v19 + 72) = v18;
        }
        else
        {
          _dispatch_timer_unote_disarm(v19, a1, a3, a4, a5, a6, a7, a8);
          v18 |= 1uLL;
          atomic_store(v18, (unint64_t *)(v19 + 72));
        }
      }
      v34 = v19;
      v33 = v18 >> 1;
      v32 = v18 >> 1;
      v31 = 0;
      v30 = 0;
      (*(void (**)(uint64_t, uint64_t, _QWORD))(*(_QWORD *)v19 + 48))(v19, 16, 0);
    }
  }
}

void _dispatch_timers_program(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  BOOL v10;
  unsigned int v11;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unsigned int v19;
  unint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  unsigned int v27;
  unint64_t v28;
  int v29;
  int v30;
  unint64_t v31;
  uint64_t v32;

  v11 = a2 % 3;
  v19 = a2 % 3;
  if (*(_QWORD *)(a1 + 32 * a2 + 8))
  {
    v18 = *(_QWORD *)(*(_QWORD *)(a1 + 32 * a2 + 8) + 80);
    v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32 * a2 + 16) + 88);
    v10 = 0;
    if (v18 <= v17)
      v10 = v18 < 0x7FFFFFFFFFFFFFFFLL;
    if (!v10)
      _dispatch_abort(1141, v10, a3, a4, a5, a6, a7, a8);
    v27 = a2 / 3;
    v26 = a3;
    if (!*(_QWORD *)(a3 + 8 * (a2 / 3)))
    {
      v24 = 0;
      v25 = 0;
      mach_get_times(v26, v26 + 8, &v24);
      *(_QWORD *)(v26 + 16) = 1000000000 * v24 + v25;
    }
    v28 = *(_QWORD *)(v26 + 8 * v27);
    v16 = v28;
    if (v18 > v28)
    {
      if (v19 < 3 && *(_DWORD *)(a1 + 32 * a2) > 2u)
      {
        v15 = _dispatch_kevent_coalescing_window[v19];
        if (v18 + v15 < v17)
          v18 = _dispatch_timer_heap_max_target_before(a1 + 32 * a2, v17 - v15);
      }
      if (v18 - v16 >= 0x7FFFFFFFFFFFFFFFLL)
        v9 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v9 = v18 - v16;
      v22 = v9;
      if (v17 - v18 >= 0x7FFFFFFFFFFFFFFFLL)
        v8 = 0x7FFFFFFFFFFFFFFFLL;
      else
        v8 = v17 - v18;
      v23 = v8;
    }
    else
    {
      v23 = 0;
      v22 = 0;
    }
  }
  else
  {
    v23 = 0x7FFFFFFFFFFFFFFFLL;
    v22 = 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v22)
  {
    if (v22 < 0x7FFFFFFFFFFFFFFFLL)
    {
      _dispatch_trace_next_timer[v11] = *(_QWORD *)(a1 + 32 * a2 + 8);
      v32 = _dispatch_trace_next_timer[v11];
      v31 = v22;
      v30 = 0;
      v29 = 0;
      _dispatch_event_loop_timer_arm(a1, a2, v22, v23, a3);
      *(_BYTE *)(a1 + 32 * a2 + 7) = *(_BYTE *)(a1 + 32 * a2 + 7) & 0xFE | 1;
      *(_BYTE *)(a1 + 32 * a2 + 7) &= ~2u;
      return;
    }
  }
  else
  {
    *(_BYTE *)(a1 + 6) |= (1 << (a2 % 3)) | 0x80;
  }
  _dispatch_trace_next_timer[v11] = 0;
  if ((*(_BYTE *)(a1 + 32 * a2 + 7) & 1) != 0)
    _dispatch_event_loop_timer_delete(a1, a2);
  *(_BYTE *)(a1 + 32 * a2 + 7) &= ~1u;
  *(_BYTE *)(a1 + 32 * a2 + 7) &= ~2u;
}

void *_dispatch_timer_unote_heap(uint64_t a1)
{
  unint64_t v2;

  v2 = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL;
  if (v2 == -4)
    return &_dispatch_timers_heap;
  else
    return *(void **)(v2 + 48);
}

void _dispatch_timer_unote_disarm(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;

  v15 = *(_DWORD *)(a1 + 24);
  if ((*(_QWORD *)(a1 + 16) & 1) == 0)
    _dispatch_abort(793, (*(_QWORD *)(a1 + 16) & 1) != 0, a3, a4, a5, a6, a7, a8);
  _dispatch_timer_heap_remove(a2 + 32 * v15, a1);
  *(_BYTE *)(a2 + 6) |= (1 << (v15 % 3)) | 0x80;
  *(_QWORD *)(a1 + 16) &= ~1uLL;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v8, v9, v10, v11, v12, v13, v14, 797);
}

uint64_t _dispatch_timer_unote_arm(uint64_t a1, uint64_t a2, unsigned int a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  unsigned int v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t result;
  unsigned int v19;
  unsigned int v20;
  uint64_t v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int v27;
  uint64_t v28;
  unsigned int v29;

  if ((*(_QWORD *)(a1 + 16) & 1) != 0)
  {
    v20 = *(_DWORD *)(a1 + 24);
    if (v20 != a3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: tidx";
      qword_E4DA8 = v20;
      __break(1u);
      JUMPOUT(0x84A30);
    }
    v24 = a2 + 32 * a3;
    if (*(_DWORD *)(a1 + 112) == -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_E4DA8 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x84AACLL);
    }
    if (*(_DWORD *)(a1 + 116) == -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_E4DA8 = 0xFFFFFFFFLL;
      __break(1u);
      JUMPOUT(0x84B0CLL);
    }
    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 112));
    _dispatch_timer_heap_resift(v24, a1, *(_DWORD *)(a1 + 116));
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v3, v4, v5, v6, v7, v8, v9, 807);
  }
  else
  {
    *(_DWORD *)(a1 + 24) = a3;
    v28 = a2 + 32 * a3;
    v10 = *(_DWORD *)v28;
    *(_DWORD *)v28 += 2;
    v27 = v10;
    v26 = *(_DWORD *)(a1 + 112);
    if (v26 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
      qword_E4DA8 = v26;
      __break(1u);
      JUMPOUT(0x84C24);
    }
    v25 = *(_DWORD *)(a1 + 116);
    if (v25 != -1)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
      qword_E4DA8 = v25;
      __break(1u);
      JUMPOUT(0x84C84);
    }
    if ((*(_DWORD *)(a1 + 36) & 0xF00u) >> 8 > (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12)
      v19 = (*(_DWORD *)(a1 + 36) & 0xF00u) >> 8;
    else
      v19 = (*(_DWORD *)(a1 + 36) & 0xF000u) >> 12;
    if (*(unsigned __int8 *)(v28 + 5) < v19)
    {
      *(_BYTE *)(v28 + 5) = v19;
      *(_BYTE *)(v28 + 7) |= 2u;
    }
    if (v10)
    {
      if (*(_BYTE *)(v28 + 4))
        v29 = (8 << (*(_BYTE *)(v28 + 4) - 1)) - (*(unsigned __int8 *)(v28 + 4) - 1) + 2;
      else
        v29 = 2;
      if (v10 + 2 > v29)
        _dispatch_timer_heap_grow(v28);
      _dispatch_timer_heap_resift(v28, a1, v27);
      _dispatch_timer_heap_resift(v28, a1, v27 + 1);
    }
    else
    {
      *(_BYTE *)(v28 + 7) |= 2u;
      *(_DWORD *)(a1 + 112) = 0;
      *(_DWORD *)(a1 + 116) = 1;
      *(_QWORD *)(v28 + 16) = a1;
      *(_QWORD *)(v28 + 8) = a1;
    }
    *(_QWORD *)(a1 + 16) |= 1uLL;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { ident = 0x%x }", v11, v12, v13, v14, v15, v16, v17, 812);
  }
  result = 2863311531;
  *(_BYTE *)(a2 + 6) |= (1 << (a3 % 3)) | 0x80;
  return result;
}

void _dispatch_timer_heap_remove(uint64_t a1, uint64_t a2)
{
  int v2;
  uint64_t v3;
  unsigned int i;
  uint64_t v5;
  uint64_t v6;
  unsigned int v7;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t *v15;
  unsigned int v16;

  v2 = *(_DWORD *)a1 - 2;
  *(_DWORD *)a1 = v2;
  v7 = v2;
  if (*(_DWORD *)(a2 + 112) == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target idx";
    qword_E4DA8 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x85040);
  }
  if (*(_DWORD *)(a2 + 116) == -1)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline idx";
    qword_E4DA8 = 0xFFFFFFFFLL;
    __break(1u);
    JUMPOUT(0x850A8);
  }
  if (v2)
  {
    for (i = 0; i <= 1; ++i)
    {
      v13 = v7 + i;
      v11 = *(unsigned __int8 *)(a1 + 4);
      if (v7 + i > 1)
      {
        v14 = v13 - 2;
        v12 = 29 - __clz(v14 | 7);
        if (v12 + 1 == v11)
          v10 = *(_QWORD *)(a1 + 24);
        else
          v10 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * (~v12 + (8 << (v11 - 2))));
        if (v12)
          v14 -= 8 << (v12 - 1);
        v15 = (uint64_t *)(v10 + 8 * v14);
      }
      else
      {
        v15 = (uint64_t *)(a1 + 8 * v13 + 8);
      }
      v3 = *v15;
      *v15 = 0;
      if (v3 != a2)
        _dispatch_timer_heap_resift(a1, v3, *(_DWORD *)(a2 + 4 * i + 112));
    }
    if (*(_BYTE *)(a1 + 4) == 1)
      v16 = 2;
    else
      v16 = (8 << (*(_BYTE *)(a1 + 4) - 2)) - (*(unsigned __int8 *)(a1 + 4) - 2) + 2;
    if (v7 <= v16)
      _dispatch_timer_heap_shrink(a1);
  }
  else
  {
    v6 = *(_QWORD *)(a1 + 8);
    if (v6 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: target slot";
      qword_E4DA8 = v6;
      __break(1u);
      JUMPOUT(0x85120);
    }
    v5 = *(_QWORD *)(a1 + 16);
    if (v5 != a2)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Timer: deadline slot";
      qword_E4DA8 = v5;
      __break(1u);
      JUMPOUT(0x8518CLL);
    }
    *(_BYTE *)(a1 + 7) |= 2u;
    *(_QWORD *)(a1 + 16) = 0;
    *(_QWORD *)(a1 + 8) = 0;
  }
  *(_DWORD *)(a2 + 112) = -1;
  *(_DWORD *)(a2 + 116) = -1;
}

uint64_t _dispatch_timer_heap_resift(uint64_t result, uint64_t a2, unsigned int a3)
{
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int v6;
  unsigned int v7;
  char v8;
  _QWORD *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  _QWORD *v13;
  uint64_t v14;
  unsigned int v15;
  uint64_t v16;
  int v17;
  unsigned int v18;
  unsigned int v19;
  _QWORD *v20;
  uint64_t v21;
  int v22;
  unsigned int v23;
  unsigned int v24;
  _QWORD *v25;
  uint64_t v26;
  int v27;
  unsigned int v28;
  unsigned int v29;
  unsigned int v30;
  _QWORD *v31;
  uint64_t v32;
  int v33;
  unsigned int v34;
  unsigned int v35;
  uint64_t v36;

  v15 = a3;
  v10 = *(_DWORD *)result;
  v8 = 0;
  v33 = *(unsigned __int8 *)(result + 4);
  if (a3 >= 2)
  {
    v35 = a3 - 2;
    v3 = __clz((a3 - 2) | 7);
    v34 = 29 - v3;
    if (30 - v3 == v33)
      v32 = *(_QWORD *)(result + 24);
    else
      v32 = *(_QWORD *)(*(_QWORD *)(result + 24) + 8 * ((8 << (v33 - 2)) - v34 - 1));
    if (v34)
      v35 -= 8 << (28 - v3);
    v36 = v32 + 8 * v35;
  }
  else
  {
    v36 = result + 8 + 8 * a3;
  }
  v9 = (_QWORD *)v36;
  while (v15 >= 2)
  {
    v29 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    v27 = *(unsigned __int8 *)(result + 4);
    if (v29 >= 2)
    {
      v30 = v29 - 2;
      v4 = __clz(v30 | 7);
      v28 = 29 - v4;
      if (30 - v4 == v27)
        v26 = *(_QWORD *)(result + 24);
      else
        v26 = *(_QWORD *)(*(_QWORD *)(result + 24) + 8 * ((8 << (v27 - 2)) - v28 - 1));
      if (v28)
        v30 -= 8 << (28 - v4);
      v31 = (_QWORD *)(v26 + 8 * v30);
    }
    else
    {
      v31 = (_QWORD *)(result + 8 + 8 * v29);
    }
    v14 = *v31;
    if (*(_QWORD *)(*v31 + 80 + 8 * (a3 & 1)) <= *(_QWORD *)(a2 + 80 + 8 * (a3 & 1)))
      break;
    *v9 = v14;
    *(_DWORD *)(v14 + 112 + 4 * (v15 & 1)) = v15;
    v9 = v31;
    v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
    v8 = 1;
  }
  if ((v8 & 1) == 0)
  {
    while (1)
    {
      v11 = 2 * v15 + 2 - (v15 & 1);
      if (v11 >= v10)
        break;
      v7 = v11 + 2;
      v22 = *(unsigned __int8 *)(result + 4);
      if (v11 >= 2)
      {
        v24 = 2 * v15 - (v15 & 1);
        v5 = __clz(v24 | 7);
        v23 = 29 - v5;
        if (30 - v5 == v22)
          v21 = *(_QWORD *)(result + 24);
        else
          v21 = *(_QWORD *)(*(_QWORD *)(result + 24) + 8 * ((8 << (v22 - 2)) - v23 - 1));
        if (v23)
          v24 -= 8 << (28 - v5);
        v25 = (_QWORD *)(v21 + 8 * v24);
      }
      else
      {
        v25 = (_QWORD *)(result + 8 + 8 * v11);
      }
      v13 = v25;
      v12 = *v25;
      if (v7 < v10)
      {
        v17 = *(unsigned __int8 *)(result + 4);
        if (v7 >= 2)
        {
          v19 = 2 * v15 + 2 - (v15 & 1);
          v6 = __clz(v11 | 7);
          v18 = 29 - v6;
          if (30 - v6 == v17)
            v16 = *(_QWORD *)(result + 24);
          else
            v16 = *(_QWORD *)(*(_QWORD *)(result + 24) + 8 * ((8 << (v17 - 2)) - v18 - 1));
          if (v18)
            v19 = v11 - (8 << (28 - v6));
          v20 = (_QWORD *)(v16 + 8 * v19);
        }
        else
        {
          v20 = (_QWORD *)(result + 8 + 8 * v7);
        }
        if (*(_QWORD *)(v12 + 80 + 8 * (a3 & 1)) > *(_QWORD *)(*v20 + 80 + 8 * (a3 & 1)))
        {
          v11 += 2;
          v12 = *v20;
          v13 = v20;
        }
      }
      if (*(_QWORD *)(a2 + 80 + 8 * (a3 & 1)) <= *(_QWORD *)(v12 + 80 + 8 * (a3 & 1)))
        break;
      if (v15 < 2)
        *(_BYTE *)(result + 7) = *(_BYTE *)(result + 7) & 0xFD | 2;
      *v9 = v12;
      *(_DWORD *)(v12 + 112 + 4 * (v15 & 1)) = v15;
      v9 = v13;
      v15 = v11;
    }
  }
  if (v15 < 2)
    *(_BYTE *)(result + 7) = *(_BYTE *)(result + 7) & 0xFD | 2;
  *v9 = a2;
  *(_DWORD *)(a2 + 112 + 4 * (v15 & 1)) = v15;
  return result;
}

void _dispatch_timer_heap_shrink(uint64_t a1)
{
  char v1;
  uint64_t v2;
  _QWORD *v3;
  unsigned int v4;
  unsigned int v5;

  v5 = 8;
  v1 = *(_BYTE *)(a1 + 4);
  *(_BYTE *)(a1 + 4) = v1 - 1;
  v4 = (v1 - 1);
  v3 = *(_QWORD **)(a1 + 24);
  v2 = 0;
  if (v1 != 1)
  {
    v5 = 8 << (v1 - 2);
    v2 = v3[v5 - v4];
  }
  if (v4 > 1)
    __memcpy_chk(v2 + 8 * ((v5 >> 1) - (v4 - 1)), &v3[v5 - (v4 - 1)], 8 * (v4 - 1), -1);
  *(_QWORD *)(a1 + 24) = v2;
  free(v3);
}

uint64_t _dispatch_timer_heap_grow(uint64_t a1)
{
  unsigned int v1;
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  unsigned int v5;
  unsigned int v6;

  v6 = 8;
  v1 = *(unsigned __int8 *)(a1 + 4);
  *(_BYTE *)(a1 + 4) = v1 + 1;
  v5 = v1;
  v3 = *(_QWORD *)(a1 + 24);
  if (v1)
    v6 = 8 << (v1 - 1);
  result = _dispatch_calloc(v6, 8);
  v4 = result;
  if (v5 > 1)
    result = __memcpy_chk(result + 8 * (v6 - (v5 - 1)), v3 + 8 * ((v6 >> 1) - (v5 - 1)), 8 * (v5 - 1), -1);
  if (v5)
    *(_QWORD *)(v4 + 8 * (v6 - v5)) = v3;
  *(_QWORD *)(a1 + 24) = v4;
  return result;
}

unint64_t _dispatch_timer_heap_max_target_before(uint64_t a1, unint64_t a2)
{
  unsigned int v2;
  int v4;
  int v5;
  unint64_t v6;
  unint64_t v7;
  unsigned int v8;
  unsigned int v9;
  uint64_t v10;
  int v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  int v17;
  unsigned int v18;
  unsigned int v19;

  v9 = 2;
  v8 = *(_DWORD *)a1;
  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 8) + 80);
  while (v9 < v8)
  {
    v11 = *(unsigned __int8 *)(a1 + 4);
    if (v9 >= 2)
    {
      v13 = v9 - 2;
      v2 = __clz((v9 - 2) | 7);
      v12 = 29 - v2;
      if (30 - v2 == v11)
        v10 = *(_QWORD *)(a1 + 24);
      else
        v10 = *(_QWORD *)(*(_QWORD *)(a1 + 24) + 8 * ((8 << (v11 - 2)) - v12 - 1));
      if (v12)
        v13 -= 8 << (28 - v2);
      v14 = v10 + 8 * v13;
    }
    else
    {
      v14 = a1 + 8 + 8 * v9;
    }
    v7 = *(_QWORD *)(*(_QWORD *)v14 + 80);
    if (v7 <= a2)
    {
      if (v7 > v6)
        v6 = *(_QWORD *)(*(_QWORD *)v14 + 80);
      if (2 * v9 + 2 - (v9 & 1) >= v8)
      {
        v18 = v9 - (v9 & 1);
        if (v18 + 2 == v8)
          v18 = ((v18 - 2) / 2) & 0xFFFFFFFE | v18 & 1;
        v19 = (v18 + 3) >> __clz(__rbit32(~(v18 + 3)));
        if (v19)
          v4 = 2 * v19 + (v9 & 1);
        else
          v4 = -1;
        v17 = v4;
      }
      else
      {
        v17 = 2 * v9 + 2 - (v9 & 1);
      }
      v9 = v17;
    }
    else
    {
      v15 = v9 - (v9 & 1);
      if (v15 + 2 == v8)
        v15 = ((v15 - 2) / 2) & 0xFFFFFFFE | v15 & 1;
      v16 = (v15 + 3) >> __clz(__rbit32(~(v15 + 3)));
      if (v16)
        v5 = 2 * v16 + (v9 & 1);
      else
        v5 = -1;
      v9 = v5;
    }
  }
  return v6;
}

uint64_t _dispatch_sync_ipc_handoff_begin(uint64_t a1, unsigned int a2, uint64_t a3)
{
  uint64_t result;
  BOOL v4;
  _QWORD v5[4];
  __int128 v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v5[0] = a2;
  v5[1] = 655343;
  v5[2] = a1;
  v5[3] = 2147483904;
  v6 = 0uLL;
  v7 = a3;
  v8 = -1;
  v9 = a1;
  result = _dispatch_kq_immediate_update(a1, (uint64_t)v5);
  v4 = 0;
  if ((_DWORD)result)
    v4 = (_DWORD)result != 2;
  if (v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0x864ECLL);
  }
  return result;
}

uint64_t _dispatch_kq_immediate_update(uint64_t a1, uint64_t a2)
{
  __int16 v2;
  _QWORD *v4;
  int i;
  uint64_t v8;

  v4 = _dispatch_thread_getspecific(0x1DuLL);
  if (v4 && v4[3] == a1)
  {
    v8 = v4[4];
    for (i = 0;
          i < *((unsigned __int16 *)v4 + 20)
       && (*(__int16 *)(v8 + 72 * i + 8) != *(__int16 *)(a2 + 8)
        || *(_QWORD *)(v8 + 72 * i) != *(_QWORD *)a2
        || *(_QWORD *)(v8 + 72 * i + 16) != *(_QWORD *)(a2 + 16));
    if (i < *((unsigned __int16 *)v4 + 20))
    {
      v2 = *((_WORD *)v4 + 20);
      *((_WORD *)v4 + 20) = v2 - 1;
      if (i != (unsigned __int16)(v2 - 1))
        memcpy((void *)(v4[4] + 72 * i), (const void *)(v4[4] + 72 * (unsigned __int16)(v2 - 1)), 0x48uLL);
    }
  }
  return _dispatch_kq_drain(a1, a2, 1, 3u);
}

void _dispatch_sync_ipc_handoff_end(uint64_t a1, unsigned int a2)
{
  uint64_t __b;
  __int16 v3;
  __int16 v4;
  int v5;
  unsigned int v6;
  int v7;
  uint64_t v8;
  __int128 v9;
  __int128 v10;
  unsigned int v11;

  v11 = a2;
  __b = a2;
  v3 = -17;
  v4 = 7;
  v5 = 0;
  v6 = 0x80000000;
  v7 = 0;
  v8 = 0;
  v9 = 0u;
  v10 = 0u;
  _dispatch_kq_deferred_update(a1, (__int16 *)&__b);
}

void _dispatch_kq_deferred_update(uint64_t a1, __int16 *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD *v8;
  int i;
  uint64_t v12;
  int v13;
  int v14;

  v8 = _dispatch_thread_getspecific(0x1DuLL);
  if (v8 && v8[3] == a1 && *((_WORD *)v8 + 21))
  {
    v12 = v8[4];
    for (i = 0;
          i < *((unsigned __int16 *)v8 + 20)
       && (*(__int16 *)(v12 + 72 * i + 8) != a2[4]
        || *(_QWORD *)(v12 + 72 * i) != *(_QWORD *)a2
        || *(_QWORD *)(v12 + 72 * i + 16) != *((_QWORD *)a2 + 2));
    v14 = i;
    if (a1 != -4)
      _dispatch_thread_setspecific(5, 1);
    if (i == *((unsigned __int16 *)v8 + 21))
    {
      v13 = *((unsigned __int16 *)v8 + 20);
      *((_WORD *)v8 + 20) = 1;
      _dispatch_kq_drain(a1, v8[4], v13, 3u);
      if (*((_WORD *)v8 + 20) != 1)
        _dispatch_abort(915, *((unsigned __int16 *)v8 + 20) == 1, v2, v3, v4, v5, v6, v7);
      v14 = 0;
    }
    else if (i == *((unsigned __int16 *)v8 + 20))
    {
      ++*((_WORD *)v8 + 20);
    }
    memcpy((void *)(v8[4] + 72 * v14), a2, 0x48uLL);
    if (a2[4] != -10)
      dispatch_kevent_debug("deferred", (uint64_t)a2, 0, 0, (uint64_t)"_dispatch_kq_deferred_update", 0x3B3u);
  }
  else
  {
    _dispatch_kq_drain(a1, (uint64_t)a2, 1, 3u);
  }
}

BOOL _dispatch_unote_register_muxed(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t *v24;
  int v25;
  BOOL v26;
  uint64_t v27;
  char *v28;
  unint64_t v30;
  uint64_t i;
  _QWORD __src[9];
  __int16 v33;
  uint64_t v34;
  unsigned int *v35;
  __int16 v36;
  void *v37;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t *v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t *v47;
  uint64_t v48;
  _BOOL8 v49;
  uint64_t v50;
  unsigned int v51;
  unsigned int v52;
  uint64_t v53;
  uint64_t v54;
  _BOOL8 v55;
  unsigned int v56;
  unsigned int v57;

  v30 = *((unsigned int *)a1 + 6);
  if (*((char *)a1 + 28) == -24 || *((char *)a1 + 28) == -8)
    v30 >>= 8;
  v28 = (char *)&_dispatch_sources + 8 * (v30 & 0x3F);
  v26 = 1;
  for (i = *(_QWORD *)v28;
        i && (*(_QWORD *)(i + 24) != *((_DWORD *)a1 + 6) || *(__int16 *)(i + 32) != *((char *)a1 + 28));
  v27 = i;
  if (i)
  {
    v25 = a1[4] & ~*(_DWORD *)(i + 48);
    if (v25)
    {
      *(_DWORD *)(i + 48) |= v25;
      v26 = *(_QWORD *)(*a1 + 40)
          ? (*(uint64_t (**)(uint64_t))(*a1 + 40))(i) & 1
          : _dispatch_kq_immediate_update(-4, i + 24) == 0;
      if (!v26)
        *(_DWORD *)(i + 48) &= ~v25;
    }
    goto LABEL_35;
  }
  v27 = _dispatch_calloc(1, 96);
  v38 = a1;
  v37 = (void *)(v27 + 24);
  v36 = 5;
  v35 = (unsigned int *)a1;
  v34 = 0;
  v34 = *a1;
  v33 = 0;
  v33 = *(_WORD *)(v34 + 12) | 5;
  if ((v33 & 0x200) != 0 && (v33 & 1) == 0)
    v33 &= ~0x200u;
  __src[0] = v35[6];
  LOWORD(__src[1]) = *(char *)(v34 + 8);
  WORD1(__src[1]) = v33;
  v52 = v35[9];
  v51 = 0;
  v50 = 0;
  if ((v52 & 0x4000000) != 0)
  {
    v50 = v52 & 0x8E000000 | 0xFFLL;
    v56 = v52 & 0xF000;
    v51 = v56 >> 12;
    v55 = v56 >> 12 != 0;
    v54 = 512;
    if (!(v56 >> 12))
      _dispatch_abort(v54, v55, v8, v9, v10, v11, v12, v13);
  }
  else
  {
    v50 = v52 & 0x8E0000FF;
    v57 = v52 & 0xF00;
    v51 = v57 >> 8;
    if (!(v57 >> 8))
    {
      v53 = v50;
      goto LABEL_27;
    }
  }
  v53 = v50 | (1 << (v51 + 7));
LABEL_27:
  HIDWORD(__src[1]) = v53;
  __src[2] = v35;
  __src[3] = v35[8] | (unint64_t)*(unsigned int *)(v34 + 16);
  __src[4] = *(unsigned __int16 *)(v34 + 14);
  memset(&__src[5], 0, 32);
  memcpy(v37, __src, 0x48uLL);
  *(_DWORD *)(v27 + 36) = 0x2000000;
  *(_QWORD *)(v27 + 40) = v27 | 1;
  if (*(_QWORD *)(*a1 + 40))
    v26 = (*(uint64_t (**)(uint64_t))(*a1 + 40))(v27) & 1;
  else
    v26 = _dispatch_kq_immediate_update(-4, v27 + 24) == 0;
  if (v26)
  {
    *(_WORD *)(v27 + 34) &= 0xFDFEu;
    v14 = *(_QWORD *)v28;
    *(_QWORD *)v27 = *(_QWORD *)v28;
    if (v14)
      *(_QWORD *)(*(_QWORD *)v28 + 8) = v27;
    *(_QWORD *)v28 = v27;
    *(_QWORD *)(v27 + 8) = v28;
  }
  else
  {
    free((void *)v27);
  }
LABEL_35:
  if (v26)
  {
    v39 = a1;
    v49 = (*((_BYTE *)a1 + 29) & 1) == 0;
    v48 = 588;
    if (!v49)
      _dispatch_abort(v48, 0, a3, a4, a5, a6, a7, a8);
    v24 = v39 - 3;
    v15 = *(_QWORD *)(v27 + 16);
    *(v39 - 3) = v15;
    if (v15)
      *(_QWORD *)(*(_QWORD *)(v27 + 16) + 8) = v24;
    *(_QWORD *)(v27 + 16) = v24;
    v24[1] = v27 + 16;
    if (*((char *)a1 + 28) == -24)
      *((_BYTE *)a1 + 30) = *(_QWORD *)(v27 + 64) != 0;
    v24[2] = v27;
    v42 = a1;
    v41 = -4;
    v40 = 1;
    v47 = a1;
    v46 = -3;
    v45 = -3;
    v44 = -3;
    a1[2] = -3;
    v43 = v45;
    _dispatch_thread_getspecific(0);
    _evfiltstr(*((char *)a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v16, v17, v18, v19, v20, v21, v22, 1183);
  }
  return v26;
}

const char *_evfiltstr(__int16 a1)
{
  unint64_t v2;

  v2 = (a1 + 24);
  if (v2 <= 0x17)
    __asm { BR              X8 }
  return "EVFILT_missing";
}

void _dispatch_unote_resume_muxed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  *(_QWORD *)(a1 + 16) |= 1uLL;
  if (*(_QWORD *)(*(_QWORD *)a1 + 40))
  {
    if ((*(_BYTE *)(a1 + 29) & 1) != 0)
      _dispatch_abort(588, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    (*(void (**)(_QWORD))(*(_QWORD *)a1 + 40))(*(_QWORD *)(a1 - 8));
  }
  else
  {
    if ((*(_BYTE *)(a1 + 29) & 1) != 0)
      _dispatch_abort(588, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
    _dispatch_kq_deferred_update(-4, (__int16 *)(*(_QWORD *)(a1 - 8) + 24));
  }
}

uint64_t _dispatch_unote_unregister_muxed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  char v23;
  BOOL v24;
  __int16 *v25;
  _QWORD *v26;
  uint64_t *i;
  char *v28;

  v28 = (char *)a1;
  if ((*(_BYTE *)(a1 + 29) & 1) != 0)
    _dispatch_abort(588, 0, a3, a4, a5, a6, a7, a8);
  v26 = (_QWORD *)(a1 - 24);
  v25 = *(__int16 **)(a1 - 8);
  v24 = 0;
  v23 = 0;
  if (v25[16] == -24)
    *(_BYTE *)(a1 + 30) = 0;
  *(_QWORD *)(a1 + 16) = 0;
  if (*v26)
    *(_QWORD *)(*(_QWORD *)(a1 - 24) + 8) = *(_QWORD *)(a1 - 16);
  **(_QWORD **)(a1 - 16) = *(_QWORD *)(a1 - 24);
  *v26 = -1;
  *(_QWORD *)(a1 - 16) = -1;
  *v26 = -1;
  *(_QWORD *)(a1 - 16) = -1;
  *(_QWORD *)(a1 - 8) = 0;
  if (*((_QWORD *)v25 + 2))
  {
    v22 = *(_DWORD *)(*(_QWORD *)a1 + 16);
    for (i = (uint64_t *)*((_QWORD *)v25 + 2); i; i = (uint64_t *)*i)
    {
      v28 = (char *)(i + 3);
      v22 |= *((_DWORD *)i + 14);
    }
    if ((*((_DWORD *)v25 + 12) & ~v22) != 0)
    {
      *((_DWORD *)v25 + 12) &= v22;
      v24 = 1;
    }
  }
  else
  {
    v23 = 1;
    v24 = (v25[17] & 2) == 0;
    v25[17] |= 2u;
  }
  if (v24)
  {
    if (*(_QWORD *)(*(_QWORD *)v28 + 40))
    {
      if (((*(uint64_t (**)(__int16 *))(*(_QWORD *)v28 + 40))(v25) & 1) == 0)
        _dispatch_bug(1236, 0, v8, v9, v10, v11, v12, v13);
    }
    else
    {
      _dispatch_kq_deferred_update(-4, v25 + 12);
    }
  }
  if ((v23 & 1) != 0)
  {
    if (*(_QWORD *)v25)
      *(_QWORD *)(*(_QWORD *)v25 + 8) = *((_QWORD *)v25 + 1);
    **((_QWORD **)v25 + 1) = *(_QWORD *)v25;
    *(_QWORD *)v25 = -1;
    *((_QWORD *)v25 + 1) = -1;
    free(v25);
  }
  _dispatch_thread_getspecific(0);
  _evfiltstr(v28[28]);
  _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v14, v15, v16, v17, v18, v19, v20, 1245);
  return 1;
}

BOOL _dispatch_unote_register_direct(uint64_t *a1, uint64_t a2)
{
  return _dispatch_kq_unote_update(a2, a1, 5);
}

BOOL _dispatch_kq_unote_update(uint64_t a1, uint64_t *a2, __int16 a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  unsigned int v9;
  unsigned int v10;
  __int16 v11;
  uint64_t v12;
  uint64_t v13;
  _BOOL4 v14;
  __int128 v15;
  __int128 v16;
  __int128 v17;
  unsigned __int16 v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  __int128 v22;
  __int128 v23;
  __int128 v24;
  __int128 v25;
  __int128 v26;
  __int128 v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unsigned int v44;
  unsigned int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  unsigned int *v61;
  unsigned int v62;
  unsigned int *v63;
  unsigned int v64;
  _OWORD *v65;
  _OWORD *v66;
  unsigned int *v67;
  unsigned int v68;
  _OWORD v69[4];
  uint64_t v70;
  unsigned int *v71;
  int v72;
  unsigned int *v73;
  int v74;
  _OWORD *v75;
  unsigned int *v76;
  _QWORD *v77;
  __int16 v78;
  uint64_t v79;
  unsigned int *v80;
  __int128 v82;
  __int128 v83;
  _BYTE v84[40];
  __int16 v85;
  uint64_t v86;
  unsigned int *v87;
  __int16 v88;
  _OWORD *v89;
  unsigned int *v90;
  __int128 v91;
  __int128 v92;
  _BYTE v93[40];
  __int16 v94;
  uint64_t v95;
  unsigned int *v96;
  __int16 v97;
  _OWORD *v98;
  unsigned int *v99;
  uint64_t v100;
  uint64_t v101;
  unsigned int *v102;
  uint64_t v103;
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unsigned int *v107;
  uint64_t v108;
  uint64_t v109;
  uint64_t v110;
  uint64_t v111;
  unsigned int *v112;
  uint64_t v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  unsigned int *v117;
  int i;
  uint64_t v119;
  unsigned int *v120;
  uint64_t v121;
  __int16 v122;
  _QWORD *v123;
  int v124;
  int v125;
  _QWORD *v126;
  _OWORD *v127;
  uint64_t v128;
  unsigned int v129;
  int v130;
  _QWORD *v131;
  uint64_t v132;
  uint64_t v133;
  _BOOL8 v134;
  unsigned int v135;
  uint64_t v136;
  uint64_t v137;
  uint64_t v138;
  unsigned int v139;
  unsigned int v140;
  uint64_t v141;
  uint64_t v142;
  _BOOL8 v143;
  uint64_t v144;
  unsigned int v145;
  unsigned int v146;
  uint64_t v147;
  uint64_t v148;
  _BOOL8 v149;
  unsigned int v150;
  unsigned int v151;
  unsigned int v152;
  unsigned int v153;
  uint64_t v154;
  uint64_t v155;
  uint64_t v156;
  uint64_t v157;
  _QWORD *v158;
  unsigned int v159;
  unsigned int v160;
  int v161;
  int v162;
  int v163;
  unsigned int v164;
  unsigned int v165;
  int v166;
  int v167;
  int v168;
  int v169;
  _QWORD *v170;
  uint64_t v171;
  uint64_t v172;
  _QWORD *v173;
  unsigned int v174;
  unsigned int v175;
  int v176;
  int v177;
  int v178;
  unsigned int v179;
  unsigned int v180;
  int v181;
  int v182;
  int v183;
  int v184;
  _QWORD *v185;
  uint64_t v186;
  uint64_t v187;
  unsigned int v188;
  unsigned int v189;
  int v190;
  int v191;
  int v192;
  unsigned int v193;
  unsigned int v194;
  int v195;
  int v196;
  int v197;
  unsigned int v198;
  uint64_t v199;

  v80 = (unsigned int *)a2;
  v79 = a1;
  v78 = a3;
  v77 = _dispatch_thread_getspecific(0x1DuLL);
  v76 = v80;
  v75 = 0;
  v74 = 0;
  if ((v78 & 1) != 0)
  {
    v155 = v79;
    if (v79 && v155 != -4)
    {
      v154 = v155;
      v199 = v155;
      v198 = 0;
      v196 = 1;
      v195 = 1;
      v197 = 1;
      v193 = 0;
      v191 = 1;
      v190 = 1;
      v192 = 1;
      v67 = (unsigned int *)(v155 + 96);
      v68 = *(_DWORD *)(v155 + 96);
      do
      {
        v9 = v68;
        do
          v10 = __ldaxr(v67);
        while (v10 == v68 && __stlxr(v68 + 1, v67));
        v68 = v10;
      }
      while (v10 != v9);
      v189 = v10;
      v193 = v10;
      v188 = v10;
      v194 = v10 + v197;
      v198 = v10 + v197;
      if ((int)(v10 + v197) <= 0)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Resurrection of an object";
        __break(1u);
        JUMPOUT(0x87D10);
      }
    }
    v73 = v76;
    v102 = v76;
    v101 = v79;
    v100 = 1;
    v107 = v76;
    v106 = v79 | 1;
    v105 = v79 | 1;
    v104 = v79 | 1;
    *((_QWORD *)v76 + 2) = v79 | 1;
    v103 = v105;
  }
  if (v77 && v77[3] == v79)
  {
    v72 = 0;
    v11 = *((char *)v76 + 28);
    v12 = v76[6];
    v123 = v77;
    v122 = v11;
    v121 = v12;
    v120 = v76;
    v119 = 0;
    v119 = v77[4];
    for (i = 0;
          i < *((unsigned __int16 *)v123 + 20)
       && (*(__int16 *)(v119 + 72 * i + 8) != v122
        || *(_QWORD *)(v119 + 72 * i) != v121
        || *(_QWORD *)(v119 + 72 * i + 16) != (_QWORD)v120);
    v72 = i;
    if (i < *((unsigned __int16 *)v77 + 20))
      v78 |= *(_WORD *)(v77[4] + 72 * v72 + 10) & 4;
    if ((v78 & 1) == 0 && (v78 & 4) != 0)
    {
      v132 = v79;
      v131 = v77;
      v130 = v72;
      if (v79 != -4)
        _dispatch_thread_setspecific(5, 1);
      if (v130 == *((unsigned __int16 *)v131 + 21))
      {
        v129 = 0;
        v129 = *((unsigned __int16 *)v131 + 20);
        *((_WORD *)v131 + 20) = 1;
        v13 = v131[4];
        v137 = v132;
        v136 = v13;
        v135 = v129;
        _dispatch_kq_drain(v132, v13, v129, 3);
        v14 = *((unsigned __int16 *)v131 + 20) == 1;
        v134 = *((unsigned __int16 *)v131 + 20) == 1;
        v133 = 915;
        if (!v14)
          _dispatch_abort(v133, v134, v3, v4, v5, v6, v7, v8);
        v130 = 0;
      }
      else if (v130 == *((unsigned __int16 *)v131 + 20))
      {
        ++*((_WORD *)v131 + 20);
      }
      v75 = (_OWORD *)(v131[4] + 72 * v130);
      v71 = v76;
      v99 = v76;
      v98 = v75;
      v97 = v78;
      v96 = v76;
      v95 = 0;
      v95 = *(_QWORD *)v76;
      v94 = 0;
      v94 = *(_WORD *)(v95 + 12) | v78;
      if ((v94 & 0x200) != 0 && (v94 & 1) == 0)
        v94 &= ~0x200u;
      v66 = v98;
      *(_QWORD *)&v91 = v96[6];
      WORD4(v91) = *(char *)(v95 + 8);
      WORD5(v91) = v94;
      v140 = v96[9];
      v139 = 0;
      v138 = 0;
      if ((v140 & 0x4000000) != 0)
      {
        v138 = v140 & 0x8E000000 | 0xFFLL;
        v151 = v140 & 0xF000;
        v139 = v151 >> 12;
        v143 = v151 >> 12 != 0;
        v142 = 512;
        if (!(v151 >> 12))
          _dispatch_abort(v142, v143, v3, v4, v5, v6, v7, v8);
      }
      else
      {
        v138 = v140 & 0x8E0000FF;
        v153 = v140 & 0xF00;
        v139 = v153 >> 8;
        if (!(v153 >> 8))
        {
          v141 = v138;
LABEL_42:
          HIDWORD(v91) = v141;
          *(_QWORD *)&v92 = v96;
          *((_QWORD *)&v92 + 1) = v96[8] | (unint64_t)*(unsigned int *)(v95 + 16);
          *(_QWORD *)v93 = *(unsigned __int16 *)(v95 + 14);
          memset(&v93[8], 0, 32);
          *v98 = v91;
          v15 = v92;
          v16 = *(_OWORD *)v93;
          v17 = *(_OWORD *)&v93[16];
          *((_QWORD *)v66 + 8) = *(_QWORD *)&v93[32];
          v66[3] = v17;
          v66[2] = v16;
          v66[1] = v15;
          dispatch_kevent_debug("deferred", (uint64_t)v75, 0, 0, (uint64_t)"_dispatch_kq_unote_update", 0x410u);
          goto LABEL_58;
        }
      }
      v141 = v138 | (1 << (v139 + 7));
      goto LABEL_42;
    }
    v126 = v77;
    v125 = v72;
    if (v72 < *((unsigned __int16 *)v77 + 20))
    {
      v124 = 0;
      v18 = *((_WORD *)v126 + 20) - 1;
      *((_WORD *)v126 + 20) = v18;
      v124 = v18;
      if (v125 != v18)
      {
        v19 = v126[4];
        v20 = v19 + 72 * v125;
        v21 = v19 + 72 * v124;
        *(_OWORD *)v20 = *(_OWORD *)v21;
        v22 = *(_OWORD *)(v21 + 16);
        v23 = *(_OWORD *)(v21 + 32);
        v24 = *(_OWORD *)(v21 + 48);
        *(_QWORD *)(v20 + 64) = *(_QWORD *)(v21 + 64);
        *(_OWORD *)(v20 + 48) = v24;
        *(_OWORD *)(v20 + 32) = v23;
        *(_OWORD *)(v20 + 16) = v22;
      }
    }
  }
  if (v78)
  {
    v70 = 0;
    memset(v69, 0, sizeof(v69));
    v90 = v76;
    v89 = v69;
    v88 = v78;
    v87 = v76;
    v86 = 0;
    v86 = *(_QWORD *)v76;
    v85 = 0;
    v85 = *(_WORD *)(v86 + 12) | v78;
    if ((v85 & 0x200) != 0 && (v85 & 1) == 0)
      v85 &= ~0x200u;
    v65 = v89;
    *(_QWORD *)&v82 = v87[6];
    WORD4(v82) = *(char *)(v86 + 8);
    WORD5(v82) = v85;
    v146 = v87[9];
    v145 = 0;
    v144 = 0;
    if ((v146 & 0x4000000) != 0)
    {
      v144 = v146 & 0x8E000000 | 0xFFLL;
      v150 = v146 & 0xF000;
      v145 = v150 >> 12;
      v149 = v150 >> 12 != 0;
      v148 = 512;
      if (!(v150 >> 12))
        _dispatch_abort(v148, v149, v3, v4, v5, v6, v7, v8);
    }
    else
    {
      v144 = v146 & 0x8E0000FF;
      v152 = v146 & 0xF00;
      v145 = v152 >> 8;
      if (!(v152 >> 8))
      {
        v147 = v144;
LABEL_57:
        HIDWORD(v82) = v147;
        *(_QWORD *)&v83 = v87;
        *((_QWORD *)&v83 + 1) = v87[8] | (unint64_t)*(unsigned int *)(v86 + 16);
        *(_QWORD *)v84 = *(unsigned __int16 *)(v86 + 14);
        memset(&v84[8], 0, 32);
        *v89 = v82;
        v25 = v83;
        v26 = *(_OWORD *)v84;
        v27 = *(_OWORD *)&v84[16];
        *((_QWORD *)v65 + 8) = *(_QWORD *)&v84[32];
        v65[3] = v27;
        v65[2] = v26;
        v65[1] = v25;
        v128 = v79;
        v127 = v69;
        v74 = _dispatch_kq_drain(v79, v69, 1, 3);
        goto LABEL_58;
      }
    }
    v147 = v144 | (1 << (v145 + 7));
    goto LABEL_57;
  }
LABEL_58:
  if ((v78 & 1) != 0)
  {
    if (v74)
    {
      v172 = v79;
      if (v79 && v172 != -4)
      {
        v171 = v172;
        v185 = (_QWORD *)v172;
        v184 = 0;
        v182 = 1;
        v181 = 1;
        v183 = 1;
        v179 = 0;
        v177 = 1;
        v176 = 1;
        v178 = 1;
        v63 = (unsigned int *)(v172 + 96);
        v64 = *(_DWORD *)(v172 + 96);
        do
        {
          v28 = v64;
          do
            v29 = __ldaxr(v63);
          while (v29 == v64 && __stlxr(v64 - 1, v63));
          v64 = v29;
        }
        while (v29 != v28);
        v175 = v29;
        v179 = v29;
        v174 = v29;
        v180 = v29 - v183;
        v184 = v29 - v183;
        if (((v29 - v183) & 0x80000000) != 0)
        {
          if (v184 <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x88760);
          }
          v185[7] = 0xDEAD000000000000;
          v173 = v185;
          _dispatch_object_dealloc(v185);
        }
      }
      v117 = v76;
      v116 = 0;
      v115 = 0;
      v114 = 0;
      *((_QWORD *)v76 + 2) = 0;
      v113 = v115;
    }
    else
    {
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v30, v31, v32, v33, v34, v35, v36, 1060);
    }
    return v74 == 0;
  }
  else
  {
    if ((v78 & 2) != 0)
    {
      if (v74 == 36)
      {
        _dispatch_thread_getspecific(0);
        _evfiltstr(*((char *)v76 + 28));
        _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v37, v38, v39, v40, v41, v42, v43, 1067);
        return 0;
      }
      v157 = v79;
      if (v79 && v157 != -4)
      {
        v156 = v157;
        v170 = (_QWORD *)v157;
        v169 = 0;
        v167 = 1;
        v166 = 1;
        v168 = 1;
        v164 = 0;
        v162 = 1;
        v161 = 1;
        v163 = 1;
        v61 = (unsigned int *)(v157 + 96);
        v62 = *(_DWORD *)(v157 + 96);
        do
        {
          v44 = v62;
          do
            v45 = __ldaxr(v61);
          while (v45 == v62 && __stlxr(v62 - 1, v61));
          v62 = v45;
        }
        while (v45 != v44);
        v160 = v45;
        v164 = v45;
        v159 = v45;
        v165 = v45 - v168;
        v169 = v45 - v168;
        if (((v45 - v168) & 0x80000000) != 0)
        {
          if (v169 <= -2)
          {
            qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
            __break(1u);
            JUMPOUT(0x88A5CLL);
          }
          v170[7] = 0xDEAD000000000000;
          v158 = v170;
          _dispatch_object_dealloc(v170);
        }
      }
      v112 = v76;
      v111 = 0;
      v110 = 0;
      v109 = 0;
      *((_QWORD *)v76 + 2) = 0;
      v108 = v110;
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v46, v47, v48, v49, v50, v51, v52, 1072);
    }
    else if ((v78 & 4) != 0)
    {
      _dispatch_thread_getspecific(0);
      _evfiltstr(*((char *)v76 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v53, v54, v55, v56, v57, v58, v59, 1074);
    }
    v187 = v74;
    v186 = 1077;
    if (v74)
      _dispatch_bug(v186, v187, v3, v4, v5, v6, v7, v8);
    return 1;
  }
}

BOOL _dispatch_unote_resume_direct(uint64_t *a1)
{
  a1[2] |= 1uLL;
  return _dispatch_kq_unote_update(a1[2] & 0xFFFFFFFFFFFFFFFCLL, a1, 4);
}

uint64_t _dispatch_unote_unregister_direct(uint64_t a1, char a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v10;
  __int16 v11;
  _QWORD *v12;
  unint64_t v13;
  uint64_t v14;

  v14 = *(_QWORD *)(a1 + 16);
  v13 = v14 & 0xFFFFFFFFFFFFFFFCLL;
  v12 = _dispatch_thread_getspecific(0x1DuLL);
  v11 = 2;
  v10 = 0;
  if ((v14 & 0xFFFFFFFFFFFFFFFCLL) != 0xFFFFFFFFFFFFFFFCLL)
  {
    v10 = 0;
    if (v12)
      v10 = v12[3] == v13;
  }
  if (v10)
  {
    v11 = 6;
    a2 |= 5u;
  }
  if ((v14 & 2) == 0 || (a2 & 1) != 0)
  {
    if (v14 == 2)
    {
      *(_QWORD *)(a1 + 16) = 0;
      _dispatch_thread_getspecific(0);
      _evfiltstr(*(char *)(a1 + 28));
      _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v2, v3, v4, v5, v6, v7, v8, 1285);
      return 1;
    }
    if ((v14 & 1) == 0)
    {
      v11 |= 4u;
      a2 |= 4u;
    }
    if (((v11 & 4) != 0 || (a2 & 2) != 0) && _dispatch_kq_unote_update(v13, (uint64_t *)a1, v11))
      return 1;
  }
  if ((a2 & 4) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unregistration failed";
    __break(1u);
    JUMPOUT(0x88FC8);
  }
  return 0;
}

void _dispatch_event_loop_atfork_child()
{
  _dispatch_mach_host_port_pred = 0;
  _dispatch_mach_host_port = 0;
}

void _dispatch_event_loop_poke(unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _QWORD *v13;
  _QWORD v14[4];
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  int v18;
  unint64_t v19;
  unsigned int *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL8 v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unint64_t v28;
  int v29;
  int v30;
  unsigned int *v31;
  uint64_t (***v32)();
  unsigned int *v33;
  uint64_t (***v34)();

  v20 = a1;
  v19 = a2;
  v18 = a3;
  if (a1 == (unsigned int *)-8)
  {
    v17 = 0;
    v16 = 0u;
    v15 = 0u;
    v14[1] = 65526;
    v14[0] = 1;
    v14[2] = -8;
    v14[3] = 0x1000000;
    _dispatch_kq_deferred_update(-4, (__int16 *)v14);
  }
  else
  {
    if (!v20 || v20 == (unsigned int *)-4)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unsupported wlh configuration";
      qword_E4DA8 = (uint64_t)v20;
      __break(1u);
      JUMPOUT(0x894E8);
    }
    v27 = v19;
    v26 = (v19 >> 37) & 1;
    v25 = 1890;
    if (!v26)
      _dispatch_abort(v25, 0, a3, a4, a5, a6, a7, a8);
    v28 = v19;
    if (((BYTE4(v19) >> 6) & 1) != 0)
    {
      v24 = v18 >= 0;
      v23 = 1892;
      if (v18 < 0)
        _dispatch_abort(v23, v24, a3, a4, a5, a6, a7, a8);
      v22 = v18 & 1;
      v21 = 1893;
      if ((v18 & 1) == 0)
        _dispatch_abort(v21, v22, a3, a4, a5, a6, a7, a8);
      v32 = &_dispatch_mgr_q;
      v31 = v20;
      v30 = 0;
      v29 = 0;
      v34 = &_dispatch_mgr_q;
      v33 = v20;
      (*(void (**)(_QWORD *, _QWORD *))((char *)&stru_20.fileoff + (_QWORD)_dispatch_mgr_q))(&_dispatch_mgr_q, v20);
    }
    else
    {
      v13 = _dispatch_thread_getspecific(0x1DuLL);
      if (v13 && v13[3] == (_QWORD)v20)
        _dispatch_kevent_workloop_poke_self((uint64_t)v13, v19, v18, v8, v9, v10, v11, v12);
      else
        _dispatch_kevent_workloop_poke(v20, v19, v18, v8, v9, v10, v11, v12);
    }
  }
}

void _dispatch_kevent_workloop_poke_self(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  v14 = *(_QWORD *)(a1 + 24);
  if ((*(_BYTE *)(a1 + 45) & 4) != 0)
  {
    if ((*(_BYTE *)(a1 + 45) & 1) == 0)
      _dispatch_abort(1790, *(_BYTE *)(a1 + 45) & 1, a3, a4, a5, a6, a7, a8);
    if ((int)a3 >= 0)
    {
      if ((a2 & 0xFFFFFFFC) != 0)
        _dispatch_abort(1802, (a2 & 0xFFFFFFFC) == 0, a3, a4, a5, a6, a7, a8);
      if ((a2 & 1) == 0)
        _dispatch_abort(1803, (a2 & 1) != 0, a3, a4, a5, a6, a7, a8);
      if ((a3 & 1) == 0)
        _dispatch_abort(1804, a3 & 1, a3, a4, a5, a6, a7, a8);
      _dispatch_release_no_dispose(v14);
      _dispatch_event_loop_leave_deferred(a1, a2, v8, v9, v10, v11, v12, v13);
    }
    else
    {
      _dispatch_kevent_workloop_override_self(a1, a2, a3, a4, a5, a6, a7, a8);
    }
  }
  else if ((*(_BYTE *)(a1 + 45) & 1) != 0)
  {
    if ((int)a3 >= 0)
      _dispatch_abort(1825, a3 & 0x80000000, a3, a4, a5, a6, a7, a8);
    if (!*(_QWORD *)(a1 + 8))
      _dispatch_abort(1826, 0, a3, a4, a5, a6, a7, a8);
    if ((a3 & 1) != 0)
      _dispatch_release_2_no_dispose(v14);
  }
  else
  {
    if ((int)a3 >= 0)
    {
      if ((a3 & 1) == 0)
        _dispatch_abort(1864, a3 & 1, a3, a4, a5, a6, a7, a8);
    }
    else if ((a3 & 1) != 0)
    {
      _dispatch_release_no_dispose(v14);
    }
    else
    {
      _dispatch_retain(v14);
    }
    if (*(_QWORD *)(a1 + 8))
      _dispatch_abort(1866, *(_QWORD *)(a1 + 8) == 0, a3, a4, a5, a6, a7, a8);
    *(_BYTE *)(a1 + 45) = *(_BYTE *)(a1 + 45) & 0xFE | 1;
    *(_BYTE *)(a1 + 45) = *(_BYTE *)(a1 + 45) & 0xFD | 2;
    *(_QWORD *)a1 = *(_QWORD *)(v14 + 24);
    *(_QWORD *)(a1 + 8) = v14;
    *(_DWORD *)(a1 + 16) = (a2 & 0x700000000) >> 32;
  }
}

void _dispatch_kevent_workloop_poke(unsigned int *a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD v14[2];
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;
  int v19;
  unint64_t v20;
  unsigned int *v21;
  uint64_t v22;
  _BOOL8 v23;
  uint64_t v24;
  unint64_t v25;
  unint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unint64_t v30;
  unint64_t v31;
  unsigned int v32;
  uint64_t v33;
  _OWORD *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  unint64_t v38;
  int v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  int v46;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = 3;
  v17 = 0;
  v16 = 0u;
  v15 = 0u;
  memset(v14, 0, sizeof(v14));
  v44 = a2;
  v25 = a2 & 1;
  v24 = 1737;
  if ((a2 & 1) == 0)
    _dispatch_abort(v24, 0, a3, a4, a5, a6, a7, a8);
  v26 = v20;
  v23 = (v20 & 0x4000000000) == 0;
  v22 = 1738;
  if ((v20 & 0x4000000000) != 0)
    _dispatch_abort(v22, v23, a3, a4, a5, a6, a7, a8);
  v38 = v20;
  v42 = v20;
  v41 = (v20 >> 37) & 1;
  v40 = 1659;
  if (!v41)
    _dispatch_abort(v40, 0, a3, a4, a5, a6, a7, a8);
  v43 = v38;
  if ((v38 & 1) != 0)
  {
    v45 = v38;
    v46 = v38;
    if ((v38 & 0xFFFFFFFC) != 0)
      v39 = 2;
    else
      v39 = 0;
  }
  else
  {
    v39 = 3;
  }
  _dispatch_kq_fill_workloop_event((uint64_t)v14, v39, (uint64_t)v21, v20, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v21, v14, 1, v14, 1, 0, 0, v18))
  {
    v34 = v14;
    v33 = 0;
    v32 = v15;
    dispatch_kevent_debug("received error", (uint64_t)v14, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    v37 = *((_WORD *)v34 + 5) & 0x4000;
    v36 = 1582;
    if (!v37)
      _dispatch_abort(v36, 0, v8, v9, v10, v11, v12, v13);
    *((_WORD *)v34 + 5) &= ~0x4000u;
    *((_DWORD *)v34 + 7) = v32;
    *((_QWORD *)v34 + 4) = 0;
    switch(v32)
    {
      case 2u:
        if ((v33 & 1) == 0
          || (*((_WORD *)v34 + 5) & 2) == 0
          || (*((_BYTE *)v34 + 24) & 8) == 0
          || (*((_BYTE *)v34 + 24) & 0x20) == 0)
        {
          v31 = 0;
          v31 = (unint64_t)*((unsigned int *)v34 + 6) << 32;
          v31 |= *((unsigned __int16 *)v34 + 5) << 16;
          v31 |= v32;
          v30 = v31;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v31;
          __break(1u);
          JUMPOUT(0x89C58);
        }
        v35 = 2;
        break;
      case 4u:
        if ((v33 & 4) == 0 || (*((_BYTE *)v34 + 24) & 4) == 0)
          goto LABEL_39;
        v35 = 4;
        break;
      case 0x22u:
        v29 = 0;
        v29 = *((int *)v34 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v29;
        __break(1u);
        JUMPOUT(0x89CE4);
      case 0x46u:
        if ((v33 & 2) == 0 || (*((_BYTE *)v34 + 25) & 1) != 0 || !*((_QWORD *)v34 + 6) || !*((_QWORD *)v34 + 7))
          goto LABEL_39;
        v35 = 70;
        break;
      case 0x69u:
        v28 = 0;
        v28 = *((_QWORD *)v34 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v28;
        __break(1u);
        JUMPOUT(0x89D24);
      default:
LABEL_39:
        v27 = (int)v32;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v32;
        __break(1u);
        JUMPOUT(0x89D64);
    }
    __break(1u);
  }
  if (v19 < 0)
  {
    if ((v19 & 1) != 0)
      _dispatch_release_2_tailcall(v21);
  }
  else
  {
    _dispatch_release_tailcall(v21);
  }
}

void _dispatch_event_loop_drain(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t v14;
  int v15;
  _QWORD *v16;
  _QWORD *v17;
  _QWORD *v19;
  int i;
  uint64_t v21;

  v17 = _dispatch_thread_getspecific(0x1DuLL);
  v16 = (_QWORD *)v17[3];
  do
  {
    if ((*((_BYTE *)v17 + 45) & 2) != 0)
    {
      v14 = v16[7];
      if ((*((_BYTE *)v17 + 45) & 1) == 0)
        _dispatch_abort(1925, 0, v1, v2, v3, v4, v5, v6);
      *((_BYTE *)v17 + 45) &= ~2u;
      v21 = v17[4];
      for (i = 0;
            i < *((unsigned __int16 *)v17 + 20)
         && (*(__int16 *)(v21 + 72 * i + 8) != -17
          || *(_QWORD **)(v21 + 72 * i) != v16
          || *(_QWORD **)(v21 + 72 * i + 16) != v16);
      if (i == *((unsigned __int16 *)v17 + 20))
      {
        if (i >= 16)
          _dispatch_abort(1496, i < 16, v1, v2, v3, v4, v5, v6);
        ++*((_WORD *)v17 + 20);
      }
      _dispatch_kq_fill_workloop_event(v17[4] + 72 * i, 2, (uint64_t)v16, v14, v3, v4, v5, v6);
    }
    v15 = *((unsigned __int16 *)v17 + 20);
    *((_WORD *)v17 + 20) = 0;
    _dispatch_kq_drain((uint64_t)v16, v17[4], v15, a1);
    if (v16 && v16 != (_QWORD *)-4)
    {
      if (*(_BYTE *)(*v16 + 16) == 18)
        v19 = v16;
      else
        v19 = 0;
    }
    else
    {
      v19 = 0;
    }
    if (v19)
    {
      v13 = v19[6];
      if (v13)
      {
        if (*(_BYTE *)(v13 + 6))
          _dispatch_event_loop_drain_timers(v13, 6u, v7, v8, v9, v10, v11, v12);
      }
    }
  }
  while ((a1 & 1) != 0 && (a1 & 2) == 0 && _dispatch_thread_getspecific(5uLL));
}

uint64_t _dispatch_kq_drain(uint64_t a1, uint64_t a2, int a3, unsigned int a4)
{
  uint64_t v5;
  uint64_t v6;
  _WORD *v7;
  uint64_t *v8;
  uint64_t *v9;
  uint64_t v10;
  uint64_t *v11;
  uint64_t *v12;
  int i;
  uint64_t v14;
  unsigned int v15;
  int v16;
  BOOL v17;
  unsigned int v18;
  int v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _WORD v24[576];

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = (a4 & 2) == 0;
  v16 = 0;
  v14 = 16;
  v15 = 16;
  i = 0;
  v12 = 0;
  v11 = 0;
  v10 = 0;
  if ((a4 & 2) == 0)
  {
    v23 = 1;
    v22 = 803;
    v9 = &v10;
    v10 = 0x8000;
    v8 = &v5 - 4096;
    bzero(&v5 - 4096, 0x8000uLL);
    v11 = v8;
    v12 = v9;
  }
  for (i = 0; i < v19; ++i)
    dispatch_kevent_debug(0, v20 + 72 * i, i, v19, (uint64_t)"_dispatch_kq_drain", 0x32Du);
  if (v17)
    _dispatch_thread_setspecific(5, 0);
  v19 = _dispatch_kq_poll(v21, v20, v19, v24, v15, v11, v12, v18);
  if (v19)
  {
    if ((v18 & 2) != 0)
    {
      v16 = 0;
      i = 0;
      while (v16 < v19)
      {
        if ((v24[36 * v16 + 5] & 0x4000) != 0 && *(_QWORD *)&v24[36 * v16 + 16])
        {
          v6 = 72;
          v7 = v24;
          _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16]);
          i = *(_QWORD *)((char *)v7 + v16 * v6 + 32);
        }
        ++v16;
      }
    }
    else
    {
      if ((v24[5] & 0x4000) != 0)
        _dispatch_thread_setspecific(5, 1);
      v16 = 0;
      i = 0;
      while (v16 < v19)
        _dispatch_kevent_drain((unsigned __int8 *)&v24[36 * v16++]);
    }
  }
  else
  {
    return 0;
  }
  return i;
}

void _dispatch_event_loop_merge(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  char *v9;
  uint64_t v10;
  int i;
  uint64_t v12;
  uint64_t *v13;
  _QWORD *v14;
  _QWORD *v15;
  unsigned int v16;
  uint64_t v17;

  v17 = a1;
  v16 = a2;
  v15 = _dispatch_thread_getspecific(0x1DuLL);
  v14 = 0;
  v14 = (_QWORD *)v15[3];
  v13 = &v8;
  v9 = (char *)&v8 - ((72 * v16 + 15) & 0xFFFFFFFFFFFFFFF0);
  v12 = v16;
  __memcpy_chk(v9, v17, 72 * v16, -1);
  *((_WORD *)v15 + 21) = 14;
  for (i = 0; i < (int)v16; ++i)
    _dispatch_kevent_drain((unsigned __int8 *)&v9[72 * i]);
  if (v14 == (_QWORD *)-4)
  {
    if (v15[1])
    {
      if (*((_WORD *)v15 + 20))
        _dispatch_event_loop_drain(3u);
    }
  }
  else if (*(_BYTE *)(*v14 + 16) == 18)
  {
    v10 = 0;
    v10 = v14[6];
    if (v10)
    {
      if (*(_BYTE *)(v10 + 6))
        _dispatch_event_loop_drain_timers(v10, 6u, v2, v3, v4, v5, v6, v7);
    }
  }
}

void _dispatch_kevent_drain(unsigned __int8 *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v8;
  uint64_t v9;

  if (*((__int16 *)a1 + 4) == -10)
  {
    dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x22Du);
    return;
  }
  if (*((__int16 *)a1 + 4) == -17)
  {
    _dispatch_kevent_workloop_poke_drain((uint64_t)a1);
    return;
  }
  dispatch_kevent_debug("received", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x235u);
  if ((*((_WORD *)a1 + 5) & 0x4000) != 0)
  {
    if (*((__int16 *)a1 + 4) != -5 || *((_QWORD *)a1 + 4) != 3)
    {
      _dispatch_kevent_print_error((uint64_t)a1);
      return;
    }
    *((_WORD *)a1 + 5) = 274;
    *((_DWORD *)a1 + 6) = -2080374784;
    *((_QWORD *)a1 + 4) = 0;
    dispatch_kevent_debug("synthetic NOTE_EXIT", (uint64_t)a1, 0, 0, (uint64_t)"_dispatch_kevent_drain", 0x23Eu);
  }
  if (*((__int16 *)a1 + 4) == -7)
  {
    v9 = *((_QWORD *)a1 + 2);
    v8 = *a1;
    if (*((uint64_t *)a1 + 4) <= 0)
      _dispatch_abort(2408, *((_QWORD *)a1 + 4) > 0, v1, v2, v3, v4, v5, v6);
    if (*(_QWORD *)a1 != (v8 | 0xFFFFFFFFFFFFFF00))
      _dispatch_abort(2409, *(_QWORD *)a1 == (v8 | 0xFFFFFFFFFFFFFF00), v1, v2, v3, v4, v5, v6);
    if (v8 >= 9)
      _dispatch_abort(2410, v8 < 9, v1, v2, v3, v4, v5, v6);
    *(_BYTE *)(v9 + 6) |= (1 << (*a1 % 3u)) | 0x80;
    *(_BYTE *)(v9 + 32 * v8 + 7) = *(_BYTE *)(v9 + 32 * v8 + 7) & 0xFD | 2;
    *(_BYTE *)(v9 + 32 * v8 + 7) &= ~1u;
  }
  else if (*((__int16 *)a1 + 4) == -8
         && (_dispatch_kevent_mach_msg_size((uint64_t)a1)
          || _dispatch_kevent_has_machmsg_rcv_error((uint64_t)a1)))
  {
    _dispatch_kevent_mach_msg_drain((uint64_t)a1);
  }
  else if ((*((_QWORD *)a1 + 2) & 1) != 0)
  {
    _dispatch_kevent_merge_muxed((uint64_t)a1);
  }
  else
  {
    _dispatch_kevent_merge(*((_QWORD *)a1 + 2), (uint64_t)a1);
  }
}

void _dispatch_event_loop_leave_immediate(unint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];
  __int128 v14;
  __int128 v15;
  uint64_t v16;
  unsigned int v17;
  uint64_t v18;
  _QWORD *v19;
  unint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  _BOOL8 v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unint64_t v29;
  unint64_t v30;
  unsigned int v31;
  uint64_t v32;
  _OWORD *v33;
  int v34;
  uint64_t v35;
  uint64_t v36;

  v20 = a1;
  v19 = _dispatch_thread_getspecific(0x1DuLL);
  v18 = 0;
  v18 = v19[3];
  v17 = 131075;
  v16 = 0;
  v15 = 0u;
  v14 = 0u;
  memset(v13, 0, sizeof(v13));
  v25 = v20;
  v24 = (v20 & 0x2000000000) == 0;
  v23 = 1994;
  if ((v20 & 0x2000000000) != 0)
    _dispatch_abort(v23, v24, v1, v2, v3, v4, v5, v6);
  v22 = *((_BYTE *)v19 + 45) & 1;
  v21 = 2004;
  if (!v22)
    _dispatch_abort(v21, 0, v1, v2, v3, v4, v5, v6);
  *((_BYTE *)v19 + 45) &= ~1u;
  *((_BYTE *)v19 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v13, 6, v18, v20, v3, v4, v5, v6);
  if (_dispatch_kq_poll(v18, (uint64_t)v13, 1u, (uint64_t)v13, 1u, 0, 0, v17))
  {
    v33 = v13;
    v32 = 0;
    v31 = v14;
    dispatch_kevent_debug("received error", (uint64_t)v13, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    v36 = *((_WORD *)v33 + 5) & 0x4000;
    v35 = 1582;
    if (!v36)
      _dispatch_abort(v35, 0, v7, v8, v9, v10, v11, v12);
    *((_WORD *)v33 + 5) &= ~0x4000u;
    *((_DWORD *)v33 + 7) = v31;
    *((_QWORD *)v33 + 4) = 0;
    switch(v31)
    {
      case 2u:
        if ((v32 & 1) == 0
          || (*((_WORD *)v33 + 5) & 2) == 0
          || (*((_BYTE *)v33 + 24) & 8) == 0
          || (*((_BYTE *)v33 + 24) & 0x20) == 0)
        {
          v30 = 0;
          v30 = (unint64_t)*((unsigned int *)v33 + 6) << 32;
          v30 |= *((unsigned __int16 *)v33 + 5) << 16;
          v30 |= v31;
          v29 = v30;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v30;
          __break(1u);
          JUMPOUT(0x8AE34);
        }
        v34 = 2;
        break;
      case 4u:
        if ((v32 & 4) == 0 || (*((_BYTE *)v33 + 24) & 4) == 0)
          goto LABEL_32;
        v34 = 4;
        break;
      case 0x22u:
        v28 = 0;
        v28 = *((int *)v33 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v28;
        __break(1u);
        JUMPOUT(0x8AEC0);
      case 0x46u:
        if ((v32 & 2) == 0 || (*((_BYTE *)v33 + 25) & 1) != 0 || !*((_QWORD *)v33 + 6) || !*((_QWORD *)v33 + 7))
          goto LABEL_32;
        v34 = 70;
        break;
      case 0x69u:
        v27 = 0;
        v27 = *((_QWORD *)v33 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v27;
        __break(1u);
        JUMPOUT(0x8AF00);
      default:
LABEL_32:
        v26 = (int)v31;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v31;
        __break(1u);
        JUMPOUT(0x8AF40);
    }
    __break(1u);
  }
}

void _dispatch_kq_fill_workloop_event(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  __int128 v8;
  __int128 v9;
  __int128 v10;
  __int16 v11;
  uint64_t v12;
  unsigned int v13;
  int v14;
  unsigned int v15;
  unsigned int v16;

  v14 = 0;
  v13 = 0;
  v12 = 0;
  switch(a2)
  {
    case 0:
    case 1:
    case 2:
      if (((a4 >> 37) & 1) == 0)
        _dispatch_abort(1439, 0, a3, a4, a5, a6, a7, a8);
      if ((a4 & 1) == 0)
        _dispatch_abort(1440, 0, a3, a4, a5, a6, a7, a8);
      v11 = 5;
      v12 = 0x3700000001;
      v13 = 272;
      if ((a4 & 2) != 0)
      {
        v13 = 400;
        v12 = 0x3700000003;
      }
      v16 = (a4 & 0x700000000) >> 32;
      v15 = *(_DWORD *)(*(_QWORD *)(a3 + 24) + 84);
      if (v16 < (unsigned __int16)(v15 & 0xF00) >> 8)
        v16 = (unsigned __int16)(v15 & 0xF00) >> 8;
      if (!v16)
        LOBYTE(v16) = 1;
      if ((v15 & 0x8000000) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Waking up a kq with cooperative thread request is not supported";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x8B204);
      }
      v14 = (1 << (v16 + 7)) | 0xFF | v15 & 0x80000000;
      break;
    case 3:
      goto LABEL_16;
    case 4:
    case 5:
      v13 = 256;
LABEL_16:
      if ((a4 & 1) != 0)
        _dispatch_abort(1459, (a4 & 1) == 0, a3, a4, a5, a6, a7, a8);
      v11 = 7;
      v12 = 1;
      break;
    case 6:
      v11 = 7;
      v13 = 32;
      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x8B300);
  }
  *(_QWORD *)&v8 = a3;
  WORD4(v8) = -17;
  WORD5(v8) = v11;
  HIDWORD(v8) = v14;
  *(_QWORD *)&v9 = a3;
  *((_QWORD *)&v9 + 1) = v13 | 1;
  *(_QWORD *)&v10 = a3 + 56;
  *((_QWORD *)&v10 + 1) = v12;
  *(_OWORD *)a1 = v8;
  *(_QWORD *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v10;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v9;
  dispatch_kevent_debug(_dispatch_workloop_actions[a2], a1, 0, 0, (uint64_t)"_dispatch_kq_fill_workloop_event", 0x5CDu);
}

uint64_t _dispatch_kq_poll(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, unsigned int a5, uint64_t a6, uint64_t a7, unsigned int a8)
{
  int v9;
  unsigned int v10;
  unsigned int v11;
  char v12;
  unsigned int v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  uint64_t v20;
  unsigned int v21;
  dispatch_function_t v22;
  char *v23;
  dispatch_once_t *v24;
  uint64_t v25;
  uint64_t v26;
  unint64_t StatusReg;

  v20 = a1;
  v19 = a2;
  v18 = a3;
  v17 = a4;
  v16 = a5;
  v15 = a6;
  v14 = a7;
  v13 = a8;
  v12 = 0;
  v24 = &_dispatch_kq_poll_pred;
  v23 = &v12;
  v22 = (dispatch_function_t)_dispatch_kq_init;
  if (_dispatch_kq_poll_pred != -1)
    dispatch_once_f(v24, v23, v22);
  if ((v12 & 1) != 0)
  {
    _dispatch_memorypressure_init();
    _voucher_activity_debug_channel_init();
  }
  while (2)
  {
    if (!v20)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid wlh";
      qword_E4DA8 = 0;
      __break(1u);
      JUMPOUT(0x8B4DCLL);
    }
    if (v20 == -4)
    {
      v10 = _dispatch_kq_fd();
      if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
        v13 |= 0x20u;
      v11 = kevent_qos(v10, v19, v18, v17, v16, v15);
    }
    else
    {
      v13 |= 0x400u;
      if ((v13 & 2) == 0)
        v13 |= 0x20000u;
      v11 = kevent_id(v20, v19, v18, v17, v16, v15, v14, v13);
    }
    if (v11 == -1)
    {
      v25 = 1;
      v26 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v9 = **(_DWORD **)(StatusReg + 8);
      switch(v9)
      {
        case 2:
          if ((v13 & 2) == 0 || (v13 & 0x20000) == 0)
            goto LABEL_21;
          v21 = 0;
          break;
        case 4:
          continue;
        case 9:
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Do not close random Unix descriptors";
          qword_E4DA8 = v9;
          __break(1u);
          JUMPOUT(0x8B674);
        case 12:
          _dispatch_temporary_resource_shortage();
          continue;
        default:
LABEL_21:
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v9;
          __break(1u);
          JUMPOUT(0x8B6E0);
      }
    }
    else
    {
      return v11;
    }
    return v21;
  }
}

void _dispatch_event_loop_leave_deferred(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v8;
  uint64_t v11;
  int j;
  uint64_t v13;
  int i;
  uint64_t v15;
  int v16;
  int v17;
  unsigned int v18;

  v8 = 0;
  if ((a2 & 0x2000000000) != 0)
    v8 = (a2 & 0x800000000) != 0;
  if (v8)
  {
    if ((a2 & 0xFFFFFFFC) != 0)
      v17 = a2 | 3;
    else
      v17 = 0;
    v15 = *(_QWORD *)(a1 + 32);
    for (i = 0;
          i < *(unsigned __int16 *)(a1 + 40)
       && (*(__int16 *)(v15 + 72 * i + 8) != -17
        || *(_QWORD *)(v15 + 72 * i) != *(_QWORD *)(a1 + 24)
        || *(_QWORD *)(v15 + 72 * i + 16) != v17);
    if (i == *(unsigned __int16 *)(a1 + 40))
    {
      if (i >= 16)
        _dispatch_abort(2028, i < 16, a3, a4, a5, a6, a7, a8);
      ++*(_WORD *)(a1 + 40);
    }
    if ((a2 & 0xFFFFFFFC) != 0)
      v18 = a2 | 3;
    else
      v18 = 0;
    _dispatch_kq_fill_workloop_sync_event(*(_QWORD *)(a1 + 32) + 72 * i, 7, *(_QWORD *)(a1 + 24), a2, v18, a6, a7, a8);
  }
  if ((a2 & 0x2000000000) == 0)
    _dispatch_abort(1659, 0, a3, a4, a5, a6, a7, a8);
  if ((a2 & 1) != 0)
  {
    if ((a2 & 0xFFFFFFFC) != 0)
      v16 = 2;
    else
      v16 = 0;
  }
  else
  {
    v16 = 3;
  }
  if ((*(_BYTE *)(a1 + 45) & 1) == 0)
    _dispatch_abort(2037, 0, a3, a4, a5, a6, a7, a8);
  *(_BYTE *)(a1 + 45) &= ~1u;
  *(_BYTE *)(a1 + 45) &= ~2u;
  v11 = *(_QWORD *)(a1 + 24);
  v13 = *(_QWORD *)(a1 + 32);
  for (j = 0;
        j < *(unsigned __int16 *)(a1 + 40)
     && (*(__int16 *)(v13 + 72 * j + 8) != -17
      || *(_QWORD *)(v13 + 72 * j) != *(_QWORD *)(a1 + 24)
      || *(_QWORD *)(v13 + 72 * j + 16) != *(_QWORD *)(a1 + 24));
  if (j == *(unsigned __int16 *)(a1 + 40))
  {
    if (j >= 16)
      _dispatch_abort(1496, j < 16, a3, a4, a5, a6, a7, a8);
    ++*(_WORD *)(a1 + 40);
  }
  _dispatch_kq_fill_workloop_event(*(_QWORD *)(a1 + 32) + 72 * j, v16, v11, a2, a5, a6, a7, a8);
}

void _dispatch_kq_fill_workloop_sync_event(uint64_t a1, int a2, uint64_t a3, unint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;
  int v11;
  __int128 v12;
  __int128 v13;
  __int128 v14;
  __int16 v15;
  uint64_t v16;
  unsigned int v17;
  unsigned int v18;
  unsigned int v20;

  v20 = a5;
  v18 = 0;
  v16 = 0;
  switch(a2)
  {
    case 7:
      LOBYTE(v11) = 0;
      if ((a4 & 0x2000000000) != 0)
        v11 = (BYTE4(a4) >> 3) & 1;
      if ((v11 & 1) == 0)
        _dispatch_abort(1516, v11 & 1, a3, a4, a5, a6, a7, a8);
      if (((a4 >> 1) & 1) == 0)
        _dispatch_abort(1517, 0, a3, a4, a5, a6, a7, a8);
      v15 = 9;
      v17 = 392;
      v16 = 0x3800000002;
      break;
    case 8:
      v15 = 9;
      v17 = 4;
      v18 = _dispatch_thread_getspecific(4uLL);
      v8 = (*(_QWORD *)&v18 & 0x3FFF00uLL) >> 8;
      v9 = __clz(__rbit32(v8));
      if (v8)
        v10 = v9 + 1;
      else
        v10 = 0;
      if (!v10)
        v18 = 2303;
      break;
    case 9:
      if (((a4 ^ a5) & 0xFFFFFFFC) != 0)
        _dispatch_abort(1540, ((a4 ^ a5) & 0xFFFFFFFC) == 0, a3, a4, a5, a6, a7, a8);
      v15 = 9;
      v17 = 136;
      break;
    case 10:
      v15 = 9;
      v17 = 8;
      break;
    case 11:
      v15 = 6;
      v17 = 40;
      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid transition";
      qword_E4DA8 = a2;
      __break(1u);
      JUMPOUT(0x8BFF4);
  }
  *(_QWORD *)&v12 = v20;
  WORD4(v12) = -17;
  WORD5(v12) = v15;
  HIDWORD(v12) = v18;
  *(_QWORD *)&v13 = a3;
  *((_QWORD *)&v13 + 1) = v17;
  *(_QWORD *)&v14 = 0;
  *((_QWORD *)&v14 + 1) = v16;
  *(_OWORD *)a1 = v12;
  *(_QWORD *)(a1 + 64) = a4;
  *(_OWORD *)(a1 + 48) = v14;
  *(_OWORD *)(a1 + 32) = 0uLL;
  *(_OWORD *)(a1 + 16) = v13;
  if ((v17 & 0x80) != 0)
    *(_QWORD *)(a1 + 48) = a3 + 56;
  dispatch_kevent_debug(_dispatch_workloop_actions[a2], a1, 0, 0, (uint64_t)"_dispatch_kq_fill_workloop_sync_event", 0x620u);
}

uint64_t _dispatch_event_loop_cancel_waiter(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _OWORD v16[2];
  __int128 v17;
  __int128 v18;
  uint64_t v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  unint64_t v26;
  unint64_t v27;
  unsigned int v28;
  _BOOL8 v29;
  _OWORD *v30;
  int v31;
  uint64_t v32;
  uint64_t v33;

  v22 = a1;
  v21 = 0;
  v21 = *(_QWORD *)(a1 + 48);
  v20 = 3;
  v19 = 0;
  v18 = 0u;
  v17 = 0u;
  memset(v16, 0, sizeof(v16));
  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)v16, 11, v21, 0, *(unsigned int *)(v22 + 100), a6, a7, a8);
    result = _dispatch_kq_poll(v21, (uint64_t)v16, 1u, (uint64_t)v16, 1u, 0, 0, v20);
    if (!(_DWORD)result)
      return result;
    v9 = ((*(unsigned __int8 *)(v22 + 106) >> 5) & 1) == 0;
    v30 = v16;
    v29 = v9;
    v28 = v17;
    dispatch_kevent_debug("received error", (uint64_t)v16, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    v33 = *((_WORD *)v30 + 5) & 0x4000;
    v32 = 1582;
    if (!v33)
      _dispatch_abort(v32, 0, v10, v11, v12, v13, v14, v15);
    *((_WORD *)v30 + 5) &= ~0x4000u;
    *((_DWORD *)v30 + 7) = v28;
    *((_QWORD *)v30 + 4) = 0;
    switch(v28)
    {
      case 2u:
        if (!v29
          || (*((_WORD *)v30 + 5) & 2) == 0
          || (*((_BYTE *)v30 + 24) & 8) == 0
          || (*((_BYTE *)v30 + 24) & 0x20) == 0)
        {
          v27 = 0;
          v27 = (unint64_t)*((unsigned int *)v30 + 6) << 32;
          v27 |= *((unsigned __int16 *)v30 + 5) << 16;
          v27 |= v28;
          v26 = v27;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v27;
          __break(1u);
          JUMPOUT(0x8C38CLL);
        }
        v31 = 2;
        break;
      case 4u:
        if (!(v29 & 4) || (*((_BYTE *)v30 + 24) & 4) == 0)
          goto LABEL_29;
        v31 = 4;
        break;
      case 0x22u:
        v25 = 0;
        v25 = *((int *)v30 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v25;
        __break(1u);
        JUMPOUT(0x8C418);
      case 0x46u:
        if (!(v29 & 2) || (*((_BYTE *)v30 + 25) & 1) != 0 || !*((_QWORD *)v30 + 6) || !*((_QWORD *)v30 + 7))
          goto LABEL_29;
        v31 = 70;
        break;
      case 0x69u:
        v24 = 0;
        v24 = *((_QWORD *)v30 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v24;
        __break(1u);
        JUMPOUT(0x8C458);
      default:
LABEL_29:
        v23 = (int)v28;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v28;
        __break(1u);
        JUMPOUT(0x8C498);
    }
    thread_switch(*(_DWORD *)(v22 + 100), 4, 1u);
  }
}

void _dispatch_event_loop_wake_owner(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unsigned int v16;
  unsigned int v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  BOOL v41;
  BOOL v42;
  unsigned int v43;
  unsigned int v44;
  int v45;
  uint64_t v46;
  _QWORD *v47;
  int v52;
  int i;
  uint64_t v54;
  int j;
  uint64_t v56;
  _BYTE v57[10];
  unsigned __int16 v58;
  int v59;
  unsigned int v60;
  int v61;
  uint64_t v62;
  uint64_t v63;

  v47 = _dispatch_thread_getspecific(0x1DuLL);
  v46 = *(_QWORD *)(a1 + 48);
  v44 = 0;
  if (((a4 ^ *(_DWORD *)(a1 + 100)) & 0xFFFFFFFC) != 0)
    _dispatch_abort(2105, 0, v4, v5, v6, v7, v8, v9);
  if (((*(unsigned __int8 *)(a1 + 106) >> 3) & 1) != 0)
    _dispatch_abort(2106, 0, v4, v5, v6, v7, v8, v9);
  if (a2 == -4 || !v47 || v47[3] != a2)
    goto LABEL_41;
  if ((*((_BYTE *)v47 + 45) & 1) == 0)
    _dispatch_abort(2109, 0, v4, v5, v6, v7, v8, v9);
  *((_BYTE *)v47 + 45) &= ~1u;
  *((_BYTE *)v47 + 45) &= ~2u;
  if (a2 == v46)
  {
    if ((a3 & 1) == 0)
      _dispatch_abort(2114, 0, v4, v5, v6, v7, v8, v9);
    if ((a3 & 2) != 0)
      _dispatch_abort(2115, 0, v4, v5, v6, v7, v8, v9);
    if ((a4 & 2) != 0)
      _dispatch_abort(2116, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
    if ((a4 & 1) != 0)
      v45 = 2;
    else
      v45 = 5;
    v54 = v47[4];
    for (i = 0;
          i < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v54 + 72 * i + 8) != -17
        || *(_QWORD *)(v54 + 72 * i) != a2
        || *(_QWORD *)(v54 + 72 * i + 16) != a2);
    if (i == *((unsigned __int16 *)v47 + 20))
    {
      if (i >= 16)
        _dispatch_abort(1496, 0, v4, v5, v6, v7, v8, v9);
      ++*((_WORD *)v47 + 20);
    }
    _dispatch_kq_fill_workloop_event(v47[4] + 72 * i, v45, a2, a4, v6, v7, v8, v9);
    v56 = v47[4];
    for (j = 0;
          j < *((unsigned __int16 *)v47 + 20)
       && (*(__int16 *)(v56 + 72 * j + 8) != -17
        || *(_QWORD *)(v56 + 72 * j) != a2
        || *(_QWORD *)(v56 + 72 * j + 16) != *(_DWORD *)(a1 + 100));
    if (j == *((unsigned __int16 *)v47 + 20))
    {
      if (j >= 16)
        _dispatch_abort(2128, j < 16, v10, v11, v12, v13, v14, v15);
      ++*((_WORD *)v47 + 20);
    }
    _dispatch_kq_fill_workloop_sync_event(v47[4] + 72 * j, 9, a2, a4, *(unsigned int *)(a1 + 100), v13, v14, v15);
  }
  else
  {
LABEL_41:
    if (((a3 ^ a4) & 1) != 0)
    {
      if ((a3 & 1) == 0)
        _dispatch_abort(2138, 0, v4, v5, v6, v7, v8, v9);
      if ((a4 & 2) != 0)
        _dispatch_abort(2139, (a4 & 2) == 0, v4, v5, v6, v7, v8, v9);
      v44 = 1;
      _dispatch_kq_fill_workloop_event((uint64_t)v57, 5, a2, a4, v6, v7, v8, v9);
    }
    if ((a4 & 0x2000000000) != 0)
    {
      v16 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v16], 9, a2, a4, *(unsigned int *)(a1 + 100), v7, v8, v9);
    }
    if ((*(_BYTE *)(a1 + 106) & 0x80) == 0 && (a3 & 0x2000000000) != 0 && (a3 & 2) == 0)
    {
      v43 = _dispatch_thread_getspecific(3uLL);
      v17 = v44++;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)&v57[72 * v17], 11, a2, a3, v43, v18, v19, v20);
    }
    if (_dispatch_kq_poll(a2, (uint64_t)v57, v44, (uint64_t)v57, v44, 0, 0, 3u))
    {
      v42 = 0;
      if (v46 != -4)
        v42 = v46 != a2;
      if (v42)
        _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight", v21, v22, v23, v24, v25, v26, v27);
      v52 = v62;
      dispatch_kevent_debug("received error", (uint64_t)v57, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
      if ((v58 & 0x4000) == 0)
        _dispatch_abort(1582, 0, v28, v29, v30, v31, v32, v33);
      v58 &= ~0x4000u;
      v61 = v52;
      v62 = 0;
      if (v52 != 2)
      {
        if (v52 != 4)
        {
          if (v52 == 34)
          {
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
            qword_E4DA8 = v59;
            __break(1u);
            JUMPOUT(0x8CFD0);
          }
          if (v52 == 105)
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
            qword_E4DA8 = v63;
            __break(1u);
            JUMPOUT(0x8D014);
          }
        }
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v52;
        __break(1u);
        JUMPOUT(0x8D058);
      }
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_E4DA8 = ((unint64_t)v60 << 32) | (v58 << 16) | 2;
      __break(1u);
      JUMPOUT(0x8CF34);
    }
    v41 = 0;
    if (v46 != -4)
      v41 = v46 != a2;
    if (v41)
    {
      _dispatch_bug_deprecated((uint64_t)"Changing target queue hierarchy with a dispatch_sync in flight", v21, v22, v23, v24, v25, v26, v27);
      _dispatch_event_loop_cancel_waiter(a1, v34, v35, v36, v37, v38, v39, v40);
    }
  }
}

void _dispatch_event_loop_wait_for_ownership(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int *v20;
  unsigned int v21;
  int v22;
  int v23;
  char v24;
  int v25;
  int v26;
  int i;
  unint64_t v28;
  uint64_t v29;
  int v31;
  _QWORD *v32;
  uint64_t v33;
  unsigned int v34;
  _QWORD v35[3];
  unsigned __int8 v36;
  unint64_t v37;

  v29 = *(_QWORD *)(a1 + 48);
  v25 = 0;
  v28 = *(_QWORD *)(v29 + 56);
  if ((v28 & 0xFFFFFFFC) != 0 || (v28 & 1) == 0)
  {
    LOBYTE(v23) = 0;
    if ((v28 & 0x2000000000) != 0)
      v23 = (BYTE4(v28) >> 3) & 1;
    if ((v23 & 1) != 0)
    {
      v25 = 1;
      if ((v28 & 0xFFFFFFFC) != 0)
        v34 = v28 | 3;
      else
        v34 = 0;
      _dispatch_kq_fill_workloop_sync_event((uint64_t)v35, 7, v29, v28, v34, a6, a7, a8);
    }
  }
  else
  {
    v25 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v35, 0, v29, v28, a5, a6, a7, a8);
  }
  while (1)
  {
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v35[9 * v25], 8, v29, v28, *(unsigned int *)(a1 + 100), a6, a7, a8);
    v26 = _dispatch_kq_poll(v29, (uint64_t)v35, v25 + 1, (uint64_t)v35, v25 + 1, 0, 0, 3u);
    for (i = 0; i < v26; ++i)
    {
      v24 = 0;
      if ((v35[9 * i + 3] & 4) != 0)
        v24 = 4;
      v32 = &v35[9 * i];
      v31 = v32[4];
      dispatch_kevent_debug("received error", (uint64_t)v32, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
      if ((*((_WORD *)v32 + 5) & 0x4000) == 0)
        _dispatch_abort(1582, 0, v9, v10, v11, v12, v13, v14);
      *((_WORD *)v32 + 5) &= ~0x4000u;
      *((_DWORD *)v32 + 7) = v31;
      v32[4] = 0;
      if (v31 == 2)
      {
        v15 = ((unint64_t)*((unsigned int *)v32 + 6) << 32) | (*((unsigned __int16 *)v32 + 5) << 16) | 2;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x8D560);
      }
      if (v31 != 4)
      {
        if (v31 == 34)
        {
          v16 = *((int *)v32 + 3);
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_E4DA8 = v16;
          __break(1u);
          JUMPOUT(0x8D5ECLL);
        }
        if (v31 == 105)
        {
          v17 = v32[8];
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_E4DA8 = v17;
          __break(1u);
          JUMPOUT(0x8D62CLL);
        }
LABEL_28:
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v31;
        __break(1u);
        JUMPOUT(0x8D66CLL);
      }
      if ((v24 & 4) == 0 || (v32[3] & 4) == 0)
        goto LABEL_28;
    }
    if (!v26)
      break;
    LOBYTE(v22) = 0;
    if (v26 == 1)
      v22 = (v36 >> 2) & 1;
    if ((v22 & 1) == 0)
      _dispatch_abort(2245, v22 & 1, v9, v10, v11, v12, v13, v14);
    dispatch_kevent_debug("restarting", (uint64_t)v35, 0, 0, (uint64_t)"_dispatch_event_loop_wait_for_ownership", 0x8C6u);
    v28 = v37;
    v25 = 0;
  }
  if ((*(_BYTE *)(a1 + 106) & 0x20) != 0)
  {
    _dispatch_event_loop_cancel_waiter(a1, v8, v9, v10, v11, v12, v13, v14);
    *(_BYTE *)(a1 + 106) &= ~0x20u;
  }
  if ((*(_BYTE *)(a1 + 106) & 0x40) != 0)
  {
    v33 = *(_QWORD *)(a1 + 48);
    v20 = (unsigned int *)(v33 + 96);
    v21 = *(_DWORD *)(v33 + 96);
    do
    {
      v18 = v21;
      do
        v19 = __ldaxr(v20);
      while (v19 == v21 && __stlxr(v21 - 1, v20));
      v21 = v19;
    }
    while (v19 != v18);
    if (((v19 - 1) & 0x80000000) != 0)
    {
      if ((int)(v19 - 1) <= -2)
      {
        qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
        __break(1u);
        JUMPOUT(0x8D888);
      }
      *(_QWORD *)(v33 + 56) = 0xDEAD000000000000;
      _dispatch_object_dealloc((_QWORD *)v33);
    }
  }
}

void dispatch_kevent_debug(const char *a1, uint64_t a2, int a3, int a4, uint64_t a5, unsigned int a6)
{
  const char *v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  _QWORD v16[20];
  void *v17;
  const char *v18;
  uint64_t v19;
  uint64_t v20;
  const char *v21;
  _QWORD *v22;
  unsigned int v23;
  uint64_t v24;
  int v25;
  int v26;
  uint64_t v27;
  const char *v28;
  char v29[31];
  char v30[256];

  v28 = a1;
  v27 = a2;
  v26 = a3;
  v25 = a4;
  v24 = a5;
  v23 = a6;
  if (a4 <= 1)
    v29[0] = 0;
  else
    __snprintf_chk(v29, 0x1FuLL, 0, 0x1FuLL, "%d/%d ", v26 + 1, v25);
  if (!v28)
  {
    if ((*(_WORD *)(v27 + 10) & 2) != 0)
    {
      v28 = "deleting";
    }
    else if ((*(_WORD *)(v27 + 10) & 1) != 0)
    {
      v28 = "adding";
    }
    else
    {
      v28 = "updating";
    }
  }
  v17 = _dispatch_thread_getspecific(0);
  v18 = v28;
  v19 = v27;
  v20 = *(_QWORD *)v27;
  v21 = _evfiltstr(*(_WORD *)(v27 + 8));
  v6 = _evflagstr(*(_WORD *)(v27 + 10), v30, 256);
  v7 = *(unsigned __int16 *)(v27 + 10);
  v8 = *(unsigned int *)(v27 + 24);
  v9 = *(_QWORD *)(v27 + 32);
  v10 = *(_QWORD *)(v27 + 16);
  v11 = *(unsigned int *)(v27 + 12);
  v12 = *(_QWORD *)(v27 + 40);
  v13 = *(_QWORD *)(v27 + 48);
  v14 = *(_QWORD *)(v27 + 56);
  v15 = *(_QWORD *)(v27 + 64);
  v22 = v16;
  v16[1] = v17;
  v16[2] = v28;
  v16[3] = v27;
  v16[4] = v29;
  v16[5] = v20;
  v16[6] = v21;
  v16[7] = v6;
  v16[8] = v7;
  v16[9] = v8;
  v16[10] = v9;
  v16[11] = v10;
  v16[12] = v11;
  v16[13] = v12;
  v16[14] = v13;
  v16[15] = v14;
  v16[16] = v15;
  v16[17] = v24;
  v16[18] = v23;
  _dispatch_log("%u\t%p\t%s kevent[%p] %s= { ident = 0x%llx, filter = %s, flags = %s (0x%x), fflags = 0x%x, data = 0x%llx, udata = 0x%llx, qos = 0x%x, ext[0] = 0x%llx, ext[1] = 0x%llx, ext[2] = 0x%llx, ext[3] = 0x%llx }: %s #%u", v7, v7, (uint64_t)v21, v20, (uint64_t)v29, (uint64_t)v28, (uint64_t)v17, 203);
}

void _dispatch_event_loop_ensure_ownership(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  _OWORD v10[2];
  __int128 v11;
  __int128 v12;
  uint64_t v13;
  unsigned int v14;
  unsigned int v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unsigned int v22;
  uint64_t v23;
  _OWORD *v24;
  int v25;
  uint64_t v26;
  uint64_t v27;

  v16 = a1;
  v15 = 3;
  v14 = _dispatch_thread_getspecific(3uLL);
  v13 = 0;
  v12 = 0u;
  v11 = 0u;
  memset(v10, 0, sizeof(v10));
  _dispatch_kq_fill_workloop_sync_event((uint64_t)v10, 9, v16, v14, v14, v1, v2, v3);
  if (_dispatch_kq_poll(v16, v10, 1, v10, 1, 0, 0, v15))
  {
    v24 = v10;
    v23 = 0;
    v22 = v11;
    dispatch_kevent_debug("received error", (uint64_t)v10, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    v27 = *((_WORD *)v24 + 5) & 0x4000;
    v26 = 1582;
    if (!v27)
      _dispatch_abort(v26, 0, v4, v5, v6, v7, v8, v9);
    *((_WORD *)v24 + 5) &= ~0x4000u;
    *((_DWORD *)v24 + 7) = v22;
    *((_QWORD *)v24 + 4) = 0;
    switch(v22)
    {
      case 2u:
        if ((v23 & 1) == 0
          || (*((_WORD *)v24 + 5) & 2) == 0
          || (*((_BYTE *)v24 + 24) & 8) == 0
          || (*((_BYTE *)v24 + 24) & 0x20) == 0)
        {
          v21 = 0;
          v21 = (unint64_t)*((unsigned int *)v24 + 6) << 32;
          v21 |= *((unsigned __int16 *)v24 + 5) << 16;
          v21 |= v22;
          v20 = v21;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v21;
          __break(1u);
          JUMPOUT(0x8DDE4);
        }
        v25 = 2;
        break;
      case 4u:
        if ((v23 & 4) == 0 || (*((_BYTE *)v24 + 24) & 4) == 0)
          goto LABEL_28;
        v25 = 4;
        break;
      case 0x22u:
        v19 = 0;
        v19 = *((int *)v24 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v19;
        __break(1u);
        JUMPOUT(0x8DE70);
      case 0x46u:
        if ((v23 & 2) == 0 || (*((_BYTE *)v24 + 25) & 1) != 0 || !*((_QWORD *)v24 + 6) || !*((_QWORD *)v24 + 7))
          goto LABEL_28;
        v25 = 70;
        break;
      case 0x69u:
        v18 = 0;
        v18 = *((_QWORD *)v24 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v18;
        __break(1u);
        JUMPOUT(0x8DEB0);
      default:
LABEL_28:
        v17 = (int)v22;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v22;
        __break(1u);
        JUMPOUT(0x8DEF0);
    }
    __break(1u);
  }
}

void _dispatch_event_loop_end_ownership(unsigned int *a1, char a2, unint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  int v24;
  unsigned int v25;
  unsigned int v26;
  char v27;
  int v31;
  _BYTE v32[10];
  unsigned __int16 v33;
  int v34;
  unsigned int v35;
  int v36;
  uint64_t v37;
  uint64_t v38;

  v27 = a4;
  v26 = 0;
  if (((a3 >> 37) & 1) == 0)
    _dispatch_abort(2289, 0, a3, a4, a5, a6, a7, a8);
  if ((a3 & 1) != 0)
  {
    v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 1, (uint64_t)a1, a3, a5, a6, a7, a8);
  }
  else if ((a2 & 1) != 0)
  {
    if ((a3 & 0xFF80000000000000) == 0)
      _dispatch_abort(2294, (a3 & 0xFF80000000000000) != 0, a3, a4, a5, a6, a7, a8);
    v26 = 1;
    _dispatch_kq_fill_workloop_event((uint64_t)v32, 4, (uint64_t)a1, a3, a5, a6, a7, a8);
  }
  if ((a2 & 2) == 0)
  {
    v25 = _dispatch_thread_getspecific(3uLL);
    v8 = v26++;
    _dispatch_kq_fill_workloop_sync_event((uint64_t)&v32[72 * v8], 11, (uint64_t)a1, a3, v25, v9, v10, v11);
  }
  if (_dispatch_kq_poll(a1, v32, v26, v32, v26, 0, 0, 3))
  {
    v31 = v37;
    dispatch_kevent_debug("received error", (uint64_t)v32, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    if ((v33 & 0x4000) == 0)
      _dispatch_abort(1582, 0, v12, v13, v14, v15, v16, v17);
    v33 &= ~0x4000u;
    v36 = v31;
    v37 = 0;
    if (v31 != 2)
    {
      if (v31 != 4)
      {
        if (v31 == 34)
        {
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
          qword_E4DA8 = v34;
          __break(1u);
          JUMPOUT(0x8E35CLL);
        }
        if (v31 == 105)
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
          qword_E4DA8 = v38;
          __break(1u);
          JUMPOUT(0x8E39CLL);
        }
      }
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x8E3DCLL);
    }
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
    qword_E4DA8 = ((unint64_t)v35 << 32) | (v33 << 16) | 2;
    __break(1u);
    JUMPOUT(0x8E2D0);
  }
  _dispatch_event_loop_assert_not_owned((uint64_t)a1);
  v24 = 2 * (v27 & 1);
  if ((a2 & 1) != 0)
    ++v24;
  if ((a3 & 1) != 0)
    --v24;
  if (v24 < 0)
    _dispatch_abort(2315, v24 >= 0, v18, v19, v20, v21, v22, v23);
  if (v24 >= 1)
    _dispatch_release_n(a1, v24);
}

uint64_t _dispatch_event_loop_assert_not_owned(uint64_t result)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD __b[9];
  uint64_t v8;
  uint64_t v9;
  _BOOL8 v10;
  unint64_t StatusReg;

  v8 = result;
  if (result != -4)
  {
    memset(__b, 0, sizeof(__b));
    result = _dispatch_kevent_workloop_get_info(v8, __b);
    if ((result & 1) != 0)
    {
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v10 = __b[5] != *(_QWORD *)(StatusReg - 8);
      v9 = 2330;
      if (!v10)
        _dispatch_abort(v9, 0, v1, v2, v3, v4, v5, v6);
    }
  }
  return result;
}

BOOL _dispatch_kevent_workloop_get_info(uint64_t a1, _WORD *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  _QWORD v10[9];
  _WORD __b[36];
  unsigned int v12;
  _WORD *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t v17;

  v14 = a1;
  v13 = a2;
  v12 = 131075;
  memset(__b, 0, sizeof(__b));
  __b[4] = -17;
  __b[5] = 5;
  memcpy(a2, __b, 0x48uLL);
  if (_dispatch_kq_poll(v14, v13, 1, v13, 1, 0, 0, v12))
  {
    v17 = v13[5] & 0x4000;
    v16 = 1375;
    if (!v17)
      _dispatch_abort(v16, 0, v2, v3, v4, v5, v6, v7);
    return *((_QWORD *)v13 + 4) == 16;
  }
  else
  {
    memset(v10, 0, sizeof(v10));
    WORD1(v10[1]) = 0x4000;
    v10[4] = 2;
    memcpy(v13, v10, 0x48uLL);
    return 1;
  }
}

void _dispatch_event_loop_timer_arm(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v6;
  unsigned int v7;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int v14;
  uint64_t v15;
  void (*v16)();
  void *v17;
  dispatch_once_t *v18;

  v7 = a2 / 3;
  v14 = a2 / 3;
  v13 = a5;
  if (!*(_QWORD *)(a5 + 8 * (a2 / 3)))
  {
    v11 = 0;
    v12 = 0;
    mach_get_times(v13, v13 + 8, &v11);
    *(_QWORD *)(v13 + 16) = 1000000000 * v11 + v12;
  }
  v15 = *(_QWORD *)(v13 + 8 * v14);
  v6 = a3 + v15;
  if ((_dispatch_timers_force_max_leeway & 1) != 0)
  {
    v6 += a4;
    a4 = 0;
  }
  _dispatch_event_loop_timer_program(a1, a2, v6, a4, 5);
  if (v7 == 2)
  {
    v18 = &_dispatch_mach_calendar_pred;
    v17 = 0;
    v16 = _dispatch_mach_host_notify_update;
    if (_dispatch_mach_calendar_pred != -1)
      dispatch_once_f(v18, v17, (dispatch_function_t)v16);
  }
}

void _dispatch_event_loop_timer_program(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, __int16 a5)
{
  _QWORD __b[9];
  uint64_t v6;
  void *v7;
  __int16 v8;
  uint64_t v9;
  uint64_t v10;
  unsigned int v11;
  uint64_t v12;
  uint64_t v13;
  int v14;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  v9 = a4;
  v8 = a5;
  v7 = _dispatch_thread_getspecific(0x1BuLL);
  v6 = 0x2000000;
  if (v7 != (void *)-4)
  {
    v14 = *(unsigned __int8 *)(v12 + 32 * v11 + 5);
    v13 = 0;
    if (v14)
      v13 = 1 << (v14 + 7);
    v6 = v13 | 0xFF;
  }
  memset(__b, 0, sizeof(__b));
  __b[0] = v11 | 0xFFFFFFFFFFFFFF00;
  LOWORD(__b[1]) = -7;
  WORD1(__b[1]) = v8 | 0x10;
  HIDWORD(__b[1]) = v6;
  __b[2] = v12;
  __b[3] = _dispatch_timer_index_to_fflags[v11];
  __b[4] = v10;
  __b[5] = 0;
  *(_OWORD *)&__b[7] = 0u;
  __b[6] = v9;
  _dispatch_kq_deferred_update((uint64_t)v7, (__int16 *)__b);
}

void _dispatch_event_loop_timer_delete(uint64_t a1, unsigned int a2)
{
  _dispatch_event_loop_timer_program(a1, a2, 0, 0, 2);
}

uint64_t _dispatch_source_proc_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  int v4;
  uint64_t v5;

  v4 = a3;
  v5 = _dispatch_unote_create_with_handle(a1, a2, a3);
  if (v5 && (v4 & 0x4000000) != 0)
    *(_BYTE *)(v5 + 29) = *(_BYTE *)(v5 + 29) & 0xFB | 4;
  return v5;
}

uint64_t _dispatch_source_vm_create(uint64_t a1, uint64_t a2)
{
  uint64_t v3;

  v3 = _dispatch_unote_create_without_handle((uint64_t)&_dispatch_source_type_memorystatus, a2, 2);
  if (v3)
    *(_BYTE *)(v3 + 29) = *(_BYTE *)(v3 + 29) & 0xEF | 0x10;
  return v3;
}

BOOL _dispatch_mach_msg_sender_is_kernel(uint64_t a1)
{
  uint64_t audit_trailer;

  audit_trailer = _dispatch_mach_msg_get_audit_trailer(a1);
  if (!audit_trailer)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: message received without expected trailer";
    __break(1u);
    JUMPOUT(0x8EB68);
  }
  return *(_DWORD *)(audit_trailer + 40) == 0;
}

uint64_t _dispatch_mach_msg_get_audit_trailer(uint64_t a1)
{
  uint64_t v2;
  _DWORD *v3;

  v2 = 0;
  v3 = (_DWORD *)(a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL));
  if (!*v3 && v3[1] >= 0x34uLL)
    return a1 + ((*(unsigned int *)(a1 + 4) + 3) & 0xFFFFFFFFFFFFFFFCLL);
  return v2;
}

uint64_t _dispatch_get_mach_host_port()
{
  if (_dispatch_mach_host_port_pred != -1)
    dispatch_once_f(&_dispatch_mach_host_port_pred, 0, (dispatch_function_t)_dispatch_mach_host_port_init);
  return _dispatch_mach_host_port;
}

void _dispatch_mach_host_port_init(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  mach_port_t v7;
  mach_port_t port;
  kern_return_t special_port;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;

  v10 = a1;
  special_port = 0;
  port = 0;
  v7 = mach_host_self();
  special_port = host_get_special_port(v7, -1, 1, &port);
  if (special_port == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x8ED08);
  }
  if (special_port)
  {
    if (special_port != 4)
    {
      v12 = special_port;
      v11 = 2859;
      _dispatch_bug(2859, special_port, v1, v2, v3, v4, v5, v6);
    }
  }
  else
  {
    special_port = mach_port_deallocate(mach_task_self_, v7);
    if (special_port == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x8ED80);
    }
    v7 = port;
  }
  if (!v7)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not get unprivileged host port";
    qword_E4DA8 = special_port;
    __break(1u);
    JUMPOUT(0x8EE38);
  }
  _dispatch_mach_host_port = v7;
}

uint64_t _dispatch_mach_notify_port_deleted(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int v14;

  v14 = a2;
  _dispatch_log("Corruption: Mach send/send-once/dead-name right 0x%x deleted prematurely", a2, a3, a4, a5, a6, a7, a8, a2);
  _dispatch_mach_notify_merge(v14, 4, 1, v8, v9, v10, v11, v12);
  return 0;
}

uint64_t _dispatch_mach_notify_merge(uint64_t result, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t *v17;
  unint64_t v18;
  char v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  uint64_t *v23;
  uint64_t *j;
  unsigned __int8 v25;
  uint64_t i;

  v25 = a3 & 1;
  v23 = 0;
  v22 = 4;
  for (i = _dispatch_sources[((unint64_t)result >> 8) & 0x3F];
        i && (*(_QWORD *)(i + 24) != result || *(__int16 *)(i + 32) != -24);
  if (i)
  {
    *(_QWORD *)(i + 56) &= 0xFFFFFFFFFFFFFFF2;
    if ((a3 & 1) != 0
      || (result = _dispatch_kevent_mach_notify_resume(i, a2, 0, a4, a5, a6, a7, a8), (result & 1) == 0))
    {
      v22 = 16;
      *(_WORD *)(i + 34) |= 2u;
    }
    *(_QWORD *)(i + 64) = 0;
    for (j = *(uint64_t **)(i + 16); ; j = v23)
    {
      v19 = 0;
      if (j)
      {
        v23 = (uint64_t *)*j;
        v19 = 1;
      }
      if ((v19 & 1) == 0)
        break;
      if (*(_QWORD *)(i + 64))
      {
        if (((v25 ^ 1) & 1) == 0)
          _dispatch_abort(3026, (v25 ^ 1) & 1, a3, a4, a5, a6, a7, a8);
        return result;
      }
      v21 = (uint64_t)(j + 3);
      v20 = a2 & j[7];
      *((_BYTE *)j + 54) = 0;
      if ((v25 & 1) != 0 || v20)
      {
        _dispatch_retain_2(~j[4]);
        if ((v25 & 1) != 0)
          _dispatch_unote_unregister_muxed(v21, v8, v9, v10, v11, v12, v13, v14);
        if (v20 && *(_BYTE *)(*(_QWORD *)v21 + 9) == 2)
        {
          v17 = (unint64_t *)(j + 12);
          v18 = j[12];
          do
          {
            v15 = v18;
            do
              v16 = __ldaxr(v17);
            while (v16 == v18 && __stlxr(v18 | v20, v17));
            v18 = v16;
          }
          while (v16 != v15);
        }
        result = (*(uint64_t (**)(uint64_t, _QWORD, _QWORD, _QWORD))(*(_QWORD *)v21 + 48))(v21, v22, v20, 0);
      }
    }
  }
  return result;
}

uint64_t _dispatch_mach_notify_dead_name(uint64_t a1, mach_port_name_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v15;

  v15 = a2;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: dead-name notification", v2, v3, v4, v5, v6, v7, v8, 3064);
  _dispatch_mach_notify_merge(v15, 1, 1, v9, v10, v11, v12, v13);
  if (mach_port_deallocate(mach_task_self_, a2) == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x8F44CLL);
  }
  return 0;
}

uint64_t _dispatch_mach_notify_send_possible(uint64_t a1, unsigned int a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tmachport[0x%08x]: send-possible notification", v2, v3, v4, v5, v6, v7, v8, 3080);
  _dispatch_mach_notify_merge(a2, 8, 0, v9, v10, v11, v12, v13);
  return 0;
}

void _dispatch_mach_notification_set_armed(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t *i;
  uint64_t v16;

  if ((*(_BYTE *)(a1 + 29) & 1) != 0)
    _dispatch_abort(588, (*(_BYTE *)(a1 + 29) & 1) == 0, a3, a4, a5, a6, a7, a8);
  v16 = *(_QWORD *)(a1 - 8);
  if (v16)
  {
    *(_QWORD *)(v16 + 64) = 1;
    for (i = *(uint64_t **)(v16 + 16); i; i = (uint64_t *)*i)
      *((_BYTE *)i + 54) = 1;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: send-possible notification armed", v8, v9, v10, v11, v12, v13, v14, 3099);
  }
}

uint64_t _dispatch_source_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;
  uint64_t v5;

  v5 = a2;
  v4 = a3;
  if (!a3)
    v4 = 1;
  if (!a2)
    v5 = 0xFFFFFFFFLL;
  return _dispatch_unote_create_with_handle(a1, v5, v4);
}

BOOL _dispatch_mach_send_update(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((*(_WORD *)(a1 + 34) & 2) != 0)
    return _dispatch_kevent_mach_notify_resume(a1, 0, *(unsigned int *)(a1 + 48), a4, a5, a6, a7, a8);
  else
    return _dispatch_kevent_mach_notify_resume(a1, *(_DWORD *)(a1 + 48), 0, a4, a5, a6, a7, a8);
}

uint64_t _dispatch_mach_send_create(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v4;

  v4 = _dispatch_unote_create_without_handle(a1, a2, a3);
  if (v4)
  {
    *(_DWORD *)(v4 + 88) = 0x80000000;
    *(_QWORD *)(v4 + 56) = 0;
  }
  return v4;
}

void _dispatch_mach_notification_event(uint64_t a1)
{
  uint64_t v1;

  v1 = *(unsigned int *)(a1 + 24);
  qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected non message event";
  qword_E4DA8 = v1;
  __break(1u);
}

void _dispatch_mach_notification_merge_msg(uint64_t a1, int a2, mach_msg_header_t *a3, int a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  int v27;
  BOOL is_kernel;
  _DWORD __b[9];
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  int v33;
  mach_msg_header_t *v34;
  int v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  _BOOL8 v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;

  v36 = a1;
  v35 = a2;
  v34 = a3;
  v33 = a4;
  v32 = a5;
  v31 = a6;
  v30 = a7;
  memset(__b, 0, sizeof(__b));
  v44 = 1;
  v43 = 2786;
  v42 = 1;
  v41 = 2788;
  if (v34->msgh_id <= 77)
  {
    is_kernel = _dispatch_mach_msg_sender_is_kernel((uint64_t)v34);
    v40 = is_kernel;
    v39 = 2790;
    if (!is_kernel)
      _dispatch_bug(v39, 0, v7, v8, v9, v10, v11, v12);
    if (!is_kernel)
      goto LABEL_18;
  }
  v27 = libdispatch_internal_protocol_server(v34, (uint64_t)__b);
  if (!v27 && __b[8] == -303 && (v34->msgh_id == 951 || v34->msgh_id == 950))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tcalendar-change notification", v20, v21, v22, v23, v24, v25, v26, 2799);
    _dispatch_timers_calendar_change();
    _dispatch_mach_host_notify_update();
    v27 = 1;
    __b[8] = 0;
  }
  v38 = v27;
  v37 = 2805;
  if (v27)
  {
    if (__b[8] != -305)
    {
      v46 = __b[8];
      v45 = 2806;
      if (__b[8])
        _dispatch_bug(v45, v46, v14, v15, v16, v17, v18, v19);
    }
  }
  else
  {
    _dispatch_bug(v37, v38, v14, v15, v16, v17, v18, v19);
  }
  if (!v27 || __b[8] && __b[8] != -305)
LABEL_18:
    mach_msg_destroy(v34);
  if ((v35 & 0x10000) != 0)
    free(v34);
  _dispatch_unote_resume(v36, v13, v14, v15, v16, v17, v18, v19);
}

uint64_t _dispatch_mach_recv_direct_merge_evt(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if ((a2 & 0x200) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
    __break(1u);
    JUMPOUT(0x8FBCCLL);
  }
  return _dispatch_source_merge_evt(a1, a2, a3, a4, a5, a6, a7, a8);
}

void _dispatch_mach_reply_merge_evt(uint64_t a1, unsigned int a2, int a3)
{
  if ((a2 & 0x200) != 0)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unexpected EV_VANISHED (do not destroy random mach ports)";
  }
  else
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected event";
    qword_E4DA8 = a3 | ((unint64_t)a2 << 32);
  }
  __break(1u);
  JUMPOUT(0x8FC38);
}

void sub_8FC98()
{
  __break(1u);
}

void _dispatch_kevent_workloop_override_self(uint64_t a1, unint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _OWORD v14[2];
  __int128 v15;
  __int128 v16;
  uint64_t v17;
  unsigned int v18;
  uint64_t v19;
  int v20;
  unint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned int v30;
  uint64_t v31;
  _OWORD *v32;
  int v33;
  uint64_t v34;
  uint64_t v35;

  v22 = a1;
  v21 = a2;
  v20 = a3;
  v19 = 0;
  v19 = *(_QWORD *)(a1 + 24);
  v18 = 3;
  v17 = 0;
  v16 = 0u;
  v15 = 0u;
  memset(v14, 0, sizeof(v14));
  v24 = *(_BYTE *)(a1 + 45) & 1;
  v23 = 1769;
  if (!v24)
    _dispatch_abort(v23, 0, a3, a4, a5, a6, a7, a8);
  *(_BYTE *)(v22 + 45) &= ~2u;
  _dispatch_kq_fill_workloop_event((uint64_t)v14, 0, v19, v21, a5, a6, a7, a8);
  if (_dispatch_kq_poll(v19, v14, 1, v14, 1, 0, 0, v18))
  {
    v32 = v14;
    v31 = 0;
    v30 = v15;
    dispatch_kevent_debug("received error", (uint64_t)v14, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    v35 = *((_WORD *)v32 + 5) & 0x4000;
    v34 = 1582;
    if (!v35)
      _dispatch_abort(v34, 0, v8, v9, v10, v11, v12, v13);
    *((_WORD *)v32 + 5) &= ~0x4000u;
    *((_DWORD *)v32 + 7) = v30;
    *((_QWORD *)v32 + 4) = 0;
    switch(v30)
    {
      case 2u:
        if ((v31 & 1) == 0
          || (*((_WORD *)v32 + 5) & 2) == 0
          || (*((_BYTE *)v32 + 24) & 8) == 0
          || (*((_BYTE *)v32 + 24) & 0x20) == 0)
        {
          v29 = 0;
          v29 = (unint64_t)*((unsigned int *)v32 + 6) << 32;
          v29 |= *((unsigned __int16 *)v32 + 5) << 16;
          v29 |= v30;
          v28 = v29;
          qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
          qword_E4DA8 = v29;
          __break(1u);
          JUMPOUT(0x8FF68);
        }
        v33 = 2;
        break;
      case 4u:
        if ((v31 & 4) == 0 || (*((_BYTE *)v32 + 24) & 4) == 0)
          goto LABEL_30;
        v33 = 4;
        break;
      case 0x22u:
        v27 = 0;
        v27 = *((int *)v32 + 3);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v27;
        __break(1u);
        JUMPOUT(0x8FFF4);
      case 0x46u:
        if ((v31 & 2) == 0 || (*((_BYTE *)v32 + 25) & 1) != 0 || !*((_QWORD *)v32 + 6) || !*((_QWORD *)v32 + 7))
          goto LABEL_30;
        v33 = 70;
        break;
      case 0x69u:
        v26 = 0;
        v26 = *((_QWORD *)v32 + 8);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v26;
        __break(1u);
        JUMPOUT(0x90034);
      default:
LABEL_30:
        v25 = (int)v30;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = (int)v30;
        __break(1u);
        JUMPOUT(0x90074);
    }
    __break(1u);
  }
  if ((v20 & 1) != 0)
    _dispatch_release_2_no_dispose(v19);
}

void _dispatch_kevent_workloop_poke_drain(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  unsigned int v30;
  unsigned int v31;
  BOOL v32;
  unint64_t v33;
  uint64_t v34;
  _QWORD *v35;
  int v37;
  int v38;
  unint64_t v39;
  unint64_t v40;

  v35 = _dispatch_thread_getspecific(0x1DuLL);
  v34 = *(_QWORD *)(a1 + 16);
  if ((*(_BYTE *)(a1 + 27) & 0x80) != 0)
  {
    v32 = 0;
    if ((*(_WORD *)(a1 + 10) & 0x4000) != 0)
      v32 = *(_QWORD *)(a1 + 32) == 2;
    if (!v32)
      _dispatch_abort(1679, v32, v1, v2, v3, v4, v5, v6);
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x690u);
    return;
  }
  if ((*(_DWORD *)(a1 + 24) & 1) == 0)
    _dispatch_abort(1684, 0, v1, v2, v3, v4, v5, v6);
  if ((*(_WORD *)(a1 + 10) & 0x4000) != 0)
  {
    v33 = *(_QWORD *)(a1 + 64);
    v37 = *(_QWORD *)(a1 + 32);
    dispatch_kevent_debug("received error", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_drain_error", 0x62Du);
    if ((*(_WORD *)(a1 + 10) & 0x4000) == 0)
      _dispatch_abort(1582, 0, v7, v8, v9, v10, v11, v12);
    *(_WORD *)(a1 + 10) &= ~0x4000u;
    *(_DWORD *)(a1 + 28) = v37;
    *(_QWORD *)(a1 + 32) = 0;
    switch(v37)
    {
      case 2:
        v13 = ((unint64_t)*(unsigned int *)(a1 + 24) << 32) | (*(unsigned __int16 *)(a1 + 10) << 16) | 2;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v13;
        __break(1u);
        JUMPOUT(0x903F4);
      case 4:
LABEL_26:
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unexpected error from kevent";
        qword_E4DA8 = v37;
        __break(1u);
        JUMPOUT(0x90514);
      case 34:
        v14 = *(int *)(a1 + 12);
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Broken priority";
        qword_E4DA8 = v14;
        __break(1u);
        JUMPOUT(0x90490);
    }
    if (v37 != 70)
    {
      if (v37 == 105)
      {
        v15 = *(_QWORD *)(a1 + 64);
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid workloop owner, possible memory corruption";
        qword_E4DA8 = v15;
        __break(1u);
        JUMPOUT(0x904D4);
      }
      goto LABEL_26;
    }
    if ((*(_BYTE *)(a1 + 25) & 1) != 0 || !*(_QWORD *)(a1 + 48) || !*(_QWORD *)(a1 + 56))
      goto LABEL_26;
    if ((v33 & 0x2000000000) != 0)
    {
      if (((v33 >> 37) & 1) == 0)
        _dispatch_abort(1659, 0, v7, v8, v9, v10, v11, v12);
      if ((v33 & 1) != 0)
      {
        if ((v33 & 0xFFFFFFFC) != 0)
          v38 = 2;
        else
          v38 = 0;
      }
      else
      {
        v38 = 3;
      }
      if (v38)
      {
        _dispatch_kq_fill_workloop_event(a1, v38, v34, v33, v9, v10, v11, v12);
        _dispatch_kq_deferred_update(v34, a1);
      }
      else
      {
        dispatch_kevent_debug("retry drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6ABu);
        if (v35[1])
          _dispatch_abort(1647, 0, v16, v17, v18, v19, v20, v21);
        *((_BYTE *)v35 + 45) |= 1u;
        _dispatch_retain(v34);
        *v35 = *(_QWORD *)(v34 + 24);
        v35[1] = v34;
        v39 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
        v22 = __clz(__rbit32(v39));
        if ((_DWORD)v39)
          v23 = v22 + 1;
        else
          v23 = 0;
        *((_DWORD *)v35 + 4) = v23;
      }
    }
    else
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0)
        _dispatch_abort(1692, (*(_WORD *)(a1 + 10) & 2) == 0, v7, v8, v9, v10, v11, v12);
      dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6A2u);
    }
  }
  else if ((*((_BYTE *)v35 + 45) & 1) != 0)
  {
    dispatch_kevent_debug("ignoring", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6B7u);
  }
  else
  {
    dispatch_kevent_debug("got drain", a1, 0, 0, (uint64_t)"_dispatch_kevent_workloop_poke_drain", 0x6BCu);
    if (v35[1])
      _dispatch_abort(1647, 0, v24, v25, v26, v27, v28, v29);
    *((_BYTE *)v35 + 45) |= 1u;
    _dispatch_retain(v34);
    *v35 = *(_QWORD *)(v34 + 24);
    v35[1] = v34;
    v40 = (unint64_t)(*(_DWORD *)(a1 + 12) & 0x3FFF00) >> 8;
    v30 = __clz(__rbit32(v40));
    if ((_DWORD)v40)
      v31 = v30 + 1;
    else
      v31 = 0;
    *((_DWORD *)v35 + 4) = v31;
  }
}

void _dispatch_kevent_print_error(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  const char *v9;
  uint64_t v10;
  const char *v11;
  uint64_t v12;
  uint64_t v13;

  v13 = 0;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkevent[0x%llx]: handling error", v1, v2, v3, v4, v5, v6, v7, 390);
  if ((*(_WORD *)(a1 + 10) & 2) != 0)
  {
    if ((*(_WORD *)(a1 + 10) & 0x100) != 0 && *(_QWORD *)(a1 + 32) == 36)
      return;
  }
  else if ((*(_BYTE *)(a1 + 16) & 1) != 0)
  {
    *(_WORD *)(a1 + 10) |= *(_WORD *)((*(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFELL) + 34);
  }
  else if (*(_QWORD *)(a1 + 16))
  {
    v13 = *(_QWORD *)(a1 + 16);
    if (!*(_QWORD *)(v13 + 16))
      *(_WORD *)(a1 + 10) |= 1u;
  }
  if (*(_QWORD *)(a1 + 32))
  {
    if (*(_QWORD *)(a1 + 32) == 34)
    {
      v8 = *(int *)(a1 + 12);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid kevent priority";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x90B00);
    }
    v9 = _evfiltstr(*(_WORD *)(a1 + 8));
    v12 = (uint64_t)v9;
    if (*(_QWORD *)(a1 + 16))
    {
      if ((*(_WORD *)(a1 + 10) & 2) != 0)
      {
        _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, (uint64_t)"delete", *(unsigned int *)(a1 + 32), *(_QWORD *)a1, *(_QWORD *)(a1 + 16), v13, v10);
      }
      else if ((*(_WORD *)(a1 + 10) & 1) != 0)
      {
        _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, (uint64_t)"add", *(unsigned int *)(a1 + 32), *(_QWORD *)a1, *(_QWORD *)(a1 + 16), v13, v10);
      }
      else
      {
        if ((*(_WORD *)(a1 + 10) & 4) != 0)
          v11 = "enable";
        else
          v11 = "monitor";
        _dispatch_bug_kevent_client((uint64_t)"kevent", v12, (uint64_t)v11, *(unsigned int *)(a1 + 32), *(_QWORD *)a1, *(_QWORD *)(a1 + 16), v13, v10);
      }
    }
    else
    {
      _dispatch_bug_kevent_client((uint64_t)"kevent", (uint64_t)v9, 0, *(unsigned int *)(a1 + 32), *(_QWORD *)a1, *(_QWORD *)(a1 + 16), v13, v10);
    }
  }
}

uint64_t _dispatch_kevent_mach_msg_size(uint64_t a1)
{
  return *(_QWORD *)(a1 + 48);
}

BOOL _dispatch_kevent_has_machmsg_rcv_error(uint64_t a1)
{
  BOOL v2;
  int v3;

  v3 = *(_DWORD *)(a1 + 24);
  v2 = 0;
  if ((v3 & 0xFC000000) == 0x10000000)
    return ((v3 >> 14) & 0xFFF) == 1;
  return v2;
}

void _dispatch_kevent_mach_msg_drain(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  _BOOL4 v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  int **v16;
  __int128 v17;
  uint64_t *v18;
  __int128 v19;
  unsigned int v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _BYTE v28[32];
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  uint64_t *v33;
  _DWORD *v34;
  unsigned int v35;
  _BYTE *v36;
  int v37;
  int **v38;
  unsigned int *v39;
  uint64_t v40;
  int v41;
  uint64_t v42;
  __int128 v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  __int128 v50;
  _QWORD v51[2];
  unsigned int *v52;
  __int128 v53;
  int *v54;
  signed int v55;
  int v56;
  uint64_t v57;
  uint64_t v58;
  uint64_t v59;
  uint64_t v60;
  mach_error_t v61;
  unsigned int v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  _BYTE v66[12];
  unsigned int v67;
  unsigned int *v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  unsigned int *v73;
  uint64_t v74;
  _BOOL8 v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  _BOOL8 v79;
  uint64_t v80;
  int *v81[3];
  uint64_t v82;

  v69 = a1;
  v42 = 0;
  v68 = (unsigned int *)_dispatch_kevent_mach_msg_buf(a1);
  v41 = 0;
  v67 = _dispatch_kevent_mach_msg_size(v69);
  *(_DWORD *)&v66[8] = 0;
  *(_QWORD *)v66 = _dispatch_kevent_mach_msg_aux_size(v69);
  v65 = *(unsigned int *)&v66[4];
  v76 = v69;
  v80 = v69;
  v9 = (*(_QWORD *)(v69 + 16) & 1) == 0;
  v79 = (*(_QWORD *)(v69 + 16) & 1) == 0;
  v78 = 380;
  if (!v9)
    _dispatch_abort(v78, v79, v3, v4, v5, v6, v7, v8);
  v77 = *(_QWORD *)(v76 + 16);
  v65 = v77;
  v64 = 0;
  v64 = *(unsigned int *)(v69 + 60);
  v63 = 0;
  v63 = *(int *)(v69 + 12);
  v62 = 0;
  v62 = *(unsigned __int16 *)(v69 + 10);
  v61 = 0;
  v61 = *(_DWORD *)(v69 + 24);
  if (v61 == 268451844)
  {
    if (!v67)
    {
      v60 = v61;
      v29 = v1;
      v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message size";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90DF4);
    }
    if (!*(_QWORD *)(v69 + 32))
    {
      v29 = v1;
      v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: MACH_RCV_LARGE_IDENTITY with no identity";
      __break(1u);
      JUMPOUT(0x90F7CLL);
    }
    if (_dispatch_kevent_mach_msg_size(v69) >= 0xFFFFFFBC)
    {
      v57 = _dispatch_kevent_mach_msg_size(v69);
      v29 = v1;
      v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with overlarge message";
      qword_E4DA8 = v57;
      __break(1u);
      JUMPOUT(0x90FDCLL);
    }
    v56 = 0;
    if ((*(_BYTE *)(v65 + 33) & 2) != 0)
      v56 |= 0x200u;
    v37 = 0;
    v55 = v56 & 0xF8FFF6F1 | 0x700090A;
    v67 += 68;
    v68 = (unsigned int *)malloc_type_malloc(v67, 3883670545);
    *(_DWORD *)v66 = 40;
    v36 = v28;
    bzero(v28, 0x28uLL);
    *(_QWORD *)&v66[4] = v36;
    v38 = v81;
    v53 = (unint64_t)v68;
    LODWORD(v54) = v37;
    v39 = (unsigned int *)&v54 + 1;
    v52 = v68;
    v73 = v68;
    v72 = 3256;
    if (!v68)
      _dispatch_bug(v72, 0, v10, v11, v12, v13, v14, v15);
    v51[1] = v52;
    if (v52)
      v35 = v67;
    else
      v35 = 0;
    v16 = v38;
    *v39 = v35;
    v17 = v53;
    v16[2] = v54;
    *(_OWORD *)v16 = v17;
    v33 = &v82;
    v50 = *(unint64_t *)&v66[4];
    LODWORD(v51[0]) = 0;
    v34 = (_DWORD *)v51 + 1;
    v49 = *(_QWORD *)&v66[4];
    v71 = *(_QWORD *)&v66[4];
    v70 = 3262;
    if (!*(_QWORD *)&v66[4])
      _dispatch_bug(v70, 0, v10, v11, v12, v13, v14, v15);
    v48 = v49;
    if (v49)
      v32 = *(_DWORD *)v66;
    else
      v32 = 0;
    v18 = v33;
    *v34 = v32;
    v19 = v50;
    v18[2] = v51[0];
    *(_OWORD *)v18 = v19;
    v47 = 0;
    v46 = 0;
    v45 = 0;
    v20 = *(_DWORD *)(v69 + 32);
    v44 = 0;
    v43 = 0u;
    v61 = mach_msg2(v81, v55 | 0x100000000, (unsigned int *)&v43, 0, 2u, v20, 0, 0);
    if (!v61)
    {
      v62 |= 0x10000u;
      if (!**(_DWORD **)&v66[4])
        *(_QWORD *)&v66[4] = 0;
      _dispatch_kevent_mach_msg_recv(v65, v62, v68, *(uint64_t *)&v66[4], v64, v63);
      return;
    }
    if (v61 == 268451844)
    {
      v31 = v68[5];
      _dispatch_kevent_mach_msg_size(v69);
      _dispatch_log("BUG in libdispatch client: _dispatch_kevent_mach_msg_drain: dropped message too large to fit in memory: id = 0x%x, size = %u", v21, v22, v23, v24, v25, v26, v27, v31);
      v61 = 0;
    }
    free(v68);
  }
  else
  {
    if (v61 == 268451848)
    {
      v75 = v67 == 0;
      v74 = 3214;
      if (v67)
        _dispatch_abort(v74, v75, v3, v4, v5, v6, v7, v8);
      v59 = v61;
      v29 = v1;
      v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to copyout msg, possible port leak";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90E88);
    }
    if (!v68)
    {
      v58 = v61;
      v29 = v1;
      v30 = v2;
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: EVFILT_MACHPORT with no message";
      qword_E4DA8 = v61;
      __break(1u);
      JUMPOUT(0x90ED8);
    }
    if (!v61)
    {
      if (*(_DWORD *)v66)
        v40 = (uint64_t)v68 + v67;
      else
        v40 = 0;
      *(_QWORD *)&v66[4] = v40;
      _dispatch_kevent_mach_msg_recv(v65, v62, v68, v40, v64, v63);
      return;
    }
  }
  if (v61)
    _dispatch_bug_mach_client((uint64_t)"_dispatch_kevent_mach_msg_drain: message reception failed", v61);
}

uint64_t _dispatch_kevent_merge_muxed(uint64_t result)
{
  char v1;
  _QWORD *v2;
  _QWORD *i;
  unint64_t v4;
  uint64_t v5;

  v5 = result;
  v4 = *(_QWORD *)(result + 16) & 0xFFFFFFFFFFFFFFFELL;
  v2 = 0;
  if ((*(_WORD *)(result + 10) & 0x12) != 0)
    *(_WORD *)(v4 + 34) |= 2u;
  for (i = *(_QWORD **)(v4 + 16); ; i = v2)
  {
    v1 = 0;
    if (i)
    {
      v2 = (_QWORD *)*i;
      v1 = 1;
    }
    if ((v1 & 1) == 0)
      break;
    result = _dispatch_kevent_merge((uint64_t)(i + 3), v5);
  }
  return result;
}

uint64_t _dispatch_kevent_merge(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unint64_t v8;
  unint64_t v9;
  unsigned int v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  int v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  _BOOL4 v27;
  unint64_t v28;
  unint64_t v29;
  uint64_t v30;
  unsigned __int8 v31;
  __int16 v34;

  v31 = *(_BYTE *)(*(_QWORD *)a1 + 9);
  _dispatch_retain_2(~*(_QWORD *)(a1 + 8));
  switch(v31)
  {
    case 0u:
      v30 = *(_QWORD *)(a2 + 32);
      break;
    case 1u:
      v30 = *(unsigned int *)(a2 + 24);
      if (*(char *)(a1 + 28) == -8)
        v30 = 2;
      break;
    case 2u:
      v30 = (*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32));
      if ((*(_BYTE *)(a1 + 29) & 4) != 0)
      {
        v28 = v30 | ((unint64_t)*(_QWORD *)(a2 + 32) << 32);
        v26 = (unint64_t *)(a1 + 72);
        do
        {
          if (_os_atomic_mo_has_acquire(0))
            v10 = __ldaxr(v26);
          else
            v10 = __ldxr(v26);
          v29 = v10 | v28;
          if (_os_atomic_mo_has_release(0))
            v27 = __stlxr(v29, v26) == 0;
          else
            v27 = __stxr(v29, v26) == 0;
        }
        while (!v27);
      }
      else if (*(char *)(a1 + 28) == -8)
      {
        v30 = 2;
        *(_QWORD *)(a1 + 72) = 2;
      }
      else if ((*(_DWORD *)(a2 + 24) & *(_DWORD *)(a1 + 32)) != 0)
      {
        v22 = (unint64_t *)(a1 + 72);
        v23 = *(_QWORD *)(a1 + 72);
        do
        {
          v11 = v23;
          do
            v12 = __ldaxr(v22);
          while (v12 == v23 && __stlxr(v23 | v30, v22));
          v23 = v12;
        }
        while (v12 != v11);
      }
      break;
    case 3u:
      if (*(uint64_t *)(a2 + 32) < 0)
        _dispatch_abort(494, 0, v2, v3, v4, v5, v6, v7);
      v30 = *(_QWORD *)(a2 + 32);
      *(_QWORD *)(a1 + 72) = ~v30;
      break;
    case 4u:
      v30 = *(_QWORD *)(a2 + 32);
      if (v30)
      {
        v24 = (unint64_t *)(a1 + 72);
        v25 = *(_QWORD *)(a1 + 72);
        do
        {
          v8 = v25;
          do
            v9 = __ldaxr(v24);
          while (v9 == v25 && __stlxr(v25 + v30, v24));
          v25 = v9;
        }
        while (v9 != v8);
      }
      break;
    default:
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Corrupt unote action";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x9190CLL);
  }
  v34 = *(_WORD *)(a2 + 10);
  LOBYTE(v21) = 0;
  if ((v34 & 0x100) == 0)
    v21 = (v34 >> 4) & 1;
  if ((v21 & 1) != 0)
  {
    _dispatch_unote_unregister(a1, 5, v2, v3, v4, v5, v6, v7);
  }
  else
  {
    if ((v34 & 2) != 0)
    {
      *(_QWORD *)(a1 + 16) = 2;
    }
    else if ((*(_WORD *)(a2 + 10) & 0x210) != 0)
    {
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    }
    else
    {
      if ((v34 & 0x80) == 0)
        return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, *(unsigned __int16 *)(a2 + 10), v30, *(_DWORD *)(a2 + 12) & 0xFFFFFFLL);
      *(_QWORD *)(a1 + 16) &= ~1uLL;
    }
    _dispatch_thread_getspecific(0);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v13, v14, v15, v16, v17, v18, v19, 460);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD, uint64_t, uint64_t))(*(_QWORD *)a1 + 48))(a1, *(unsigned __int16 *)(a2 + 10), v30, *(_DWORD *)(a2 + 12) & 0xFFFFFFLL);
}

uint64_t _dispatch_kevent_mach_msg_buf(uint64_t a1)
{
  return *(_QWORD *)(a1 + 40);
}

uint64_t _dispatch_kevent_mach_msg_aux_size(uint64_t a1)
{
  return *(_QWORD *)(a1 + 64);
}

uint64_t _dispatch_kevent_mach_msg_recv(uint64_t a1, unsigned int a2, _DWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v22;
  unsigned int v23;

  v23 = a3[1] + 68;
  if (((a3[1] + 68) & 0x100000000) != 0)
  {
    v6 = a3[1];
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Overlarge message received";
    qword_E4DA8 = v6;
    __break(1u);
    JUMPOUT(0x91D10);
  }
  if (!a3[3])
  {
    v7 = (int)a3[5];
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Received message with MACH_PORT_NULL msgh_local_port";
    qword_E4DA8 = v7;
    __break(1u);
    JUMPOUT(0x91D64);
  }
  _dispatch_retain_2(~*(_QWORD *)(a1 + 8));
  LOBYTE(v22) = 0;
  if ((a2 & 0x100) == 0)
    v22 = (a2 >> 4) & 1;
  if ((v22 & 1) != 0)
  {
    _dispatch_unote_unregister(a1, 5, v8, v9, v10, v11, v12, v13);
  }
  else
  {
    if ((a2 & 2) != 0)
    {
      *(_QWORD *)(a1 + 16) = 2;
    }
    else if ((a2 & 0x210) != 0)
    {
      *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 16) & 0xFFFFFFFFFFFFFFFCLL | 2;
    }
    else
    {
      if ((a2 & 0x80) == 0)
        return (*(uint64_t (**)(uint64_t, _QWORD, _DWORD *, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, a3, v23, a4, a5, a6);
      *(_QWORD *)(a1 + 16) &= ~1uLL;
    }
    _dispatch_thread_getspecific(0);
    _evfiltstr(*(char *)(a1 + 28));
    _dispatch_log("%u\t%p\tkevent-source[%p]: %s kevent[%p] { filter = %s, ident = 0x%x }", v14, v15, v16, v17, v18, v19, v20, 460);
  }
  return (*(uint64_t (**)(uint64_t, _QWORD, _DWORD *, _QWORD, uint64_t, uint64_t, uint64_t))(*(_QWORD *)a1 + 56))(a1, a2, a3, v23, a4, a5, a6);
}

void _dispatch_kq_init(_BYTE *a1)
{
  int v1;
  _QWORD v2[2];
  __int128 v3;
  __int128 v4;
  __int128 v5;
  uint64_t v6;
  unsigned int v7;
  int v8;
  _BYTE *v9;
  _BYTE *v10;
  int v11;
  int v12;
  uint64_t (***v13)();
  uint64_t (***v14)();
  uint64_t (***v15)();
  uint64_t (***v16)();
  uint64_t v17;
  uint64_t v18;
  unint64_t StatusReg;

  v10 = a1;
  v9 = a1;
  if ((_dispatch_unsafe_fork & 1) == 0)
    _dispatch_fork_becomes_unsafe_slow();
  if (getenv("LIBDISPATCH_TIMERS_FORCE_MAX_LEEWAY"))
    _dispatch_timers_force_max_leeway = 1;
  *v9 = 1;
  _dispatch_kevent_workqueue_init();
  if ((_dispatch_kevent_workqueue_enabled & 1) != 0)
  {
    v8 = 0;
    v7 = _dispatch_kq_fd();
    v6 = 0;
    v5 = 0u;
    v4 = 0u;
    v2[0] = 1;
    v2[1] = 0x20000000021FFF6;
    v3 = 0xFFFFFFFFFFFFFFF8;
    while (1)
    {
      v8 = kevent_qos(v7, v2, 1, 0, 0, 0);
      if (v8 != -1)
        break;
      v17 = 1;
      v18 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v1 = **(_DWORD **)(StatusReg + 8);
      if (v1 != 4)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Failed to initalize workqueue kevent";
        qword_E4DA8 = v1;
        __break(1u);
        JUMPOUT(0x92230);
      }
    }
  }
  else
  {
    _dispatch_kq_create(&qword_E4160);
    v14 = off_E4158;
    v13 = &_dispatch_mgr_q;
    v12 = 0;
    v11 = 0;
    v16 = off_E4158;
    v15 = &_dispatch_mgr_q;
    (*(void (**)(uint64_t, _QWORD *, unsigned int))((char *)&stru_20.fileoff + (_QWORD)*off_E4158))((uint64_t)off_E4158, &_dispatch_mgr_q, 0);
  }
}

void _dispatch_memorypressure_init()
{
  _dispatch_memorypressure_create(malloc_memorypressure_mask_default_4libdispatch);
}

uint64_t _dispatch_kq_fd()
{
  return qword_E4160;
}

void _dispatch_kq_create(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  _QWORD *v9;
  unsigned int v10;
  _QWORD *v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t StatusReg;

  v11 = a1;
  v10 = 0;
  if ((_dispatch_unsafe_fork & 1) == 0)
    _dispatch_fork_becomes_unsafe_slow();
  v9 = v11;
  v10 = guarded_kqueue_np(&v9, 3);
  if (v10 == -1)
  {
    v14 = 1;
    v15 = 1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v8 = **(_DWORD **)(StatusReg + 8);
    if (v8 != 12)
    {
      if (v8 != 23)
      {
        if (v8 == 24)
        {
          qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: process is out of file descriptors";
          qword_E4DA8 = 24;
          __break(1u);
          JUMPOUT(0x92698);
        }
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: kqueue() failure";
        qword_E4DA8 = v8;
        __break(1u);
        JUMPOUT(0x92764);
      }
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: system is out of file descriptors";
      qword_E4DA8 = 23;
      __break(1u);
      JUMPOUT(0x926DCLL);
    }
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: kqueue() failure: kernel is out of memory";
    qword_E4DA8 = 12;
    __break(1u);
    JUMPOUT(0x92720);
  }
  v7 = kevent_qos(v10, &_dispatch_kq_create_kev, 1, 0, 0, 0);
  v13 = v7;
  v12 = 640;
  if (v7)
    _dispatch_bug(v12, v13, v1, v2, v3, v4, v5, v6);
  *v11 = (int)v10;
}

void _dispatch_memorypressure_create(uintptr_t a1)
{
  dispatch_source_t v1;

  v1 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_memorystatus, 0, a1, (dispatch_queue_t)&_dispatch_mgr_q);
  dispatch_set_context(v1, v1);
  dispatch_source_set_event_handler_f(v1, (dispatch_function_t)_dispatch_memorypressure_handler);
  dispatch_activate(v1);
  if (_dispatch_memorypressure_source)
  {
    dispatch_source_cancel((dispatch_source_t)_dispatch_memorypressure_source);
    dispatch_release((dispatch_object_t)_dispatch_memorypressure_source);
  }
  _dispatch_memorypressure_source = (uint64_t)v1;
}

uint64_t _dispatch_memorypressure_handler(dispatch_source_s *a1)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t v3;
  unint64_t v4;
  unint64_t *v6;
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  uintptr_t data;
  _QWORD *v11;
  _QWORD *v12;

  data = dispatch_source_get_data(a1);
  if ((data & 0xF0000000) != 0
    && dispatch_source_get_mask((dispatch_source_t)_dispatch_memorypressure_source) != malloc_memorypressure_mask_msl_4libdispatch)
  {
    _dispatch_memorypressure_create(malloc_memorypressure_mask_msl_4libdispatch);
  }
  if ((data & 1) != 0)
  {
    _dispatch_memory_warn = 0;
    _dispatch_continuation_cache_limit = 112;
    if (_firehose_task_buffer)
    {
      v11 = (_QWORD *)_firehose_task_buffer;
      v8 = (unint64_t *)(_firehose_task_buffer + 512);
      v9 = *(_QWORD *)(_firehose_task_buffer + 512);
      do
      {
        v1 = v9;
        do
          v2 = __ldaxr(v8);
        while (v2 == v9 && __stlxr(v9 & 0xFFFFFFFFFFFFFFFELL, v8));
        v9 = v2;
      }
      while (v2 != v1);
      if (v2 != (v2 & 0xFFFFFFFFFFFFFFFELL))
        firehose_buffer_update_limits(v11);
    }
  }
  if ((data & 2) != 0)
  {
    _dispatch_memory_warn = 1;
    _dispatch_continuation_cache_limit = 16;
    if (_firehose_task_buffer)
    {
      v12 = (_QWORD *)_firehose_task_buffer;
      v6 = (unint64_t *)(_firehose_task_buffer + 512);
      v7 = *(_QWORD *)(_firehose_task_buffer + 512);
      do
      {
        v3 = v7;
        do
          v4 = __ldaxr(v6);
        while (v4 == v7 && __stlxr(v7 | 1, v6));
        v7 = v4;
      }
      while (v4 != v3);
      if (v4 != (v4 | 1))
        firehose_buffer_update_limits(v12);
    }
  }
  return malloc_memory_event_handler(data);
}

const char *_evflagstr(__int16 a1, const char *a2, uint64_t a3)
{
  const char *v3;
  size_t v5;
  __int16 v8;

  v8 = a1;
  *a2 = 0;
  while (v8)
  {
    v3 = _evflagstr2(&v8);
    __strlcat_chk(a2, v3, a3, -1);
  }
  v5 = strlen(a2);
  if (v5)
    a2[v5 - 1] = 0;
  return a2;
}

const char *_evflagstr2(_WORD *a1)
{
  if ((*a1 & 1) == 1)
  {
    *a1 &= ~1u;
    return "EV_ADD|";
  }
  else if ((*a1 & 2) == 2)
  {
    *a1 &= ~2u;
    return "EV_DELETE|";
  }
  else if ((*a1 & 4) == 4)
  {
    *a1 &= ~4u;
    return "EV_ENABLE|";
  }
  else if ((*a1 & 8) == 8)
  {
    *a1 &= ~8u;
    return "EV_DISABLE|";
  }
  else if ((*a1 & 0x10) == 0x10)
  {
    *a1 &= ~0x10u;
    return "EV_ONESHOT|";
  }
  else if ((*a1 & 0x20) == 0x20)
  {
    *a1 &= ~0x20u;
    return "EV_CLEAR|";
  }
  else if ((*a1 & 0x40) == 0x40)
  {
    *a1 &= ~0x40u;
    return "EV_RECEIPT|";
  }
  else if ((*a1 & 0x80) == 0x80)
  {
    *a1 &= ~0x80u;
    return "EV_DISPATCH|";
  }
  else if ((*a1 & 0x100) == 0x100)
  {
    *a1 &= ~0x100u;
    return "EV_UDATA_SPECIFIC|";
  }
  else if ((*a1 & 0x1000) == 0x1000)
  {
    *a1 &= ~0x1000u;
    return "EV_POLL|";
  }
  else if ((*a1 & 0x2000) == 0x2000)
  {
    *a1 &= ~0x2000u;
    return "EV_OOBAND|";
  }
  else if ((*a1 & 0x4000) == 0x4000)
  {
    *a1 &= ~0x4000u;
    return "EV_ERROR|";
  }
  else if ((*a1 & 0x8000) == 0x8000)
  {
    *a1 &= ~0x8000u;
    return "EV_EOF|";
  }
  else if ((*a1 & 0x200) == 0x200)
  {
    *a1 &= ~0x200u;
    return "EV_VANISHED|";
  }
  else
  {
    *a1 = 0;
    return "EV_UNKNOWN ";
  }
}

void _dispatch_mach_host_notify_update()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  host_t host;
  kern_return_t v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tregistering for calendar-change notification", v0, v1, v2, v3, v4, v5, v6, 2888);
  host = _dispatch_get_mach_host_port();
  if (_dispatch_mach_notify_port_pred != -1)
    dispatch_once_f(&_dispatch_mach_notify_port_pred, 0, (dispatch_function_t)_dispatch_mach_notify_port_init);
  v14 = host_request_notification(host, 1, _dispatch_mach_notify_port);
  if (v14 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x930F8);
  }
  if (v14)
    _dispatch_bug(2893, v14, v7, v8, v9, v10, v11, v12);
}

void _dispatch_mach_notify_port_init(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  uint64_t v13;
  kern_return_t v14;
  mach_port_options_t options;
  uint64_t v16;
  uint64_t v17;
  _BOOL8 v18;

  v16 = a1;
  options.reserved[1] = 0;
  *(_OWORD *)&options.flags = xmmword_C29D8;
  v14 = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)&_dispatch_mach_notify_port, (mach_port_name_t *)&_dispatch_mach_notify_port);
  if (v14)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: mach_port_construct() failed: cannot create receive right";
    qword_E4DA8 = v14;
    __break(1u);
    JUMPOUT(0x931F4);
  }
  v13 = _dispatch_unote_create_with_handle((uint64_t)&_dispatch_mach_type_notification, _dispatch_mach_notify_port, 0);
  *(_QWORD *)(v13 + 8) = ~(unint64_t)&_dispatch_mgr_q;
  v12 = _dispatch_unote_register(v13, -4, 0x2000000, v1, v2, v3, v4, v5);
  v18 = v12;
  v17 = 2842;
  if (!v12)
    _dispatch_bug(v17, v18, v6, v7, v8, v9, v10, v11);
  _dispatch_mach_notify_unote = v13;
}

BOOL _dispatch_kevent_mach_notify_resume(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v9;

  v9 = 0;
  if ((a2 & a3) != 0)
    _dispatch_abort(2986, a2 & a3, a3, a4, a5, a6, a7, a8);
  if ((a2 & 0xD) != 0 || (a3 & 0xD) != 0)
    v9 = _dispatch_mach_notify_update(a1, a2, a3, 0xDu, 66, 0);
  return v9 == 0;
}

uint64_t _dispatch_mach_notify_update(uint64_t a1, int a2, int a3, unsigned int a4, mach_msg_id_t a5, mach_port_mscount_t a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  mach_port_t task;
  int v46;
  mach_port_t v47;
  kern_return_t v48;
  kern_return_t v49;
  kern_return_t v50;
  uint64_t v51;
  mach_port_name_t v52;
  mach_port_t previous;
  mach_port_mscount_t v54;
  mach_msg_id_t v55;
  unsigned int v56;
  int v57;
  int v58;
  uint64_t v59;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  uint64_t v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  dispatch_function_t v71;
  void *v72;
  dispatch_once_t *v73;

  v59 = a1;
  v58 = a2;
  v57 = a3;
  v56 = a4;
  v55 = a5;
  v54 = a6;
  previous = 0;
  v52 = *(_QWORD *)(a1 + 24);
  v51 = *(_QWORD *)(a1 + 56);
  v48 = 0;
  *(_QWORD *)(a1 + 56) = v51 | (a2 | *(_DWORD *)(a1 + 48)) & a4;
  *(_QWORD *)(v59 + 56) &= ~(v57 & v56);
  if ((*(_QWORD *)(v59 + 56) & v56) == 0 || (v51 & v56) != 0)
  {
    if ((*(_QWORD *)(v59 + 56) & v56) != 0 || (v51 & v56) == 0)
      return 0;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: unregistering for send-possible notification", v25, v26, v27, v28, v29, v30, v31, 2953);
    previous = 0;
    v50 = mach_port_request_notification(mach_task_self_, v52, v55, v54, 0, 0x12u, &previous);
    if (v50 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x93834);
    }
    if (v50 != 4 && v50 != 15 && v50 != 17)
    {
      v64 = v50;
      v63 = 2966;
      if (v50)
        _dispatch_bug(v63, v64, v32, v33, v34, v35, v36, v37);
    }
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tmachport[0x%08x]: registering for send-possible notification", v6, v7, v8, v9, v10, v11, v12, 2920);
    previous = 0;
    task = mach_task_self_;
    v73 = &_dispatch_mach_notify_port_pred;
    v72 = 0;
    v71 = (dispatch_function_t)_dispatch_mach_notify_port_init;
    if (_dispatch_mach_notify_port_pred != -1)
      dispatch_once_f(v73, v72, v71);
    v48 = mach_port_request_notification(task, v52, v55, v54, _dispatch_mach_notify_port, 0x15u, &previous);
    if (v48 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x93578);
    }
    if (v48 == 15 || v48 == 17)
    {
      *(_QWORD *)(v59 + 56) &= ~v56;
    }
    else
    {
      v70 = v48;
      v69 = 2935;
      if (v48)
      {
        _dispatch_bug(v69, v70, v13, v14, v15, v16, v17, v18);
        *(_QWORD *)(v59 + 56) &= ~v56;
      }
      else
      {
        v47 = previous;
        v68 = previous;
        v67 = 2938;
        if (previous)
          _dispatch_bug(v67, v68, v13, v14, v15, v16, v17, v18);
        if (v47)
        {
          v49 = mach_port_deallocate(mach_task_self_, previous);
          if (v49 == -301)
          {
            qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
            qword_E4DA8 = -301;
            __break(1u);
            JUMPOUT(0x936F4);
          }
          v66 = v49;
          v65 = 2947;
          if (v49)
            _dispatch_bug(v65, v66, v19, v20, v21, v22, v23, v24);
          previous = 0;
        }
      }
    }
  }
  if (previous)
  {
    v46 = _dispatch_send_consume_send_once_right(previous);
    v62 = v46;
    v61 = 2976;
    if (v46)
      _dispatch_bug(v61, v62, v38, v39, v40, v41, v42, v43);
  }
  return v48;
}

void _dispatch_timers_calendar_change()
{
  unsigned int i;

  for (i = 0; i < 3; ++i)
  {
    byte_E4E16 |= (1 << ((i + 6) % 3)) | 0x80;
    *((_BYTE *)&_dispatch_timers_heap + 32 * i + 199) = *((_BYTE *)&_dispatch_timers_heap + 32 * i + 199) & 0xFD | 2;
  }
}

void _voucher_xref_dispose(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  unsigned int *v11;
  unsigned int v12;
  int v13;
  int v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: xref_dispose", v1, v2, v3, v4, v5, v6, v7, 782);
  _voucher_remove(a1);
  v14 = a1[2];
  if (v14 != 0x7FFFFFFF)
  {
    v11 = a1 + 2;
    v12 = a1[2];
    do
    {
      v8 = v12;
      do
        v9 = __ldaxr(v11);
      while (v9 == v12 && __stlxr(v12 - 1, v11));
      v12 = v9;
    }
    while (v9 != v8);
    v14 = v9 - 1;
  }
  if (v14 < 1)
  {
    if (v14 < 0)
    {
      qword_E4D78 = (uint64_t)"API MISUSE: Over-release of an object";
      __break(1u);
      JUMPOUT(0x93BE0);
    }
    v13 = a1[3];
    if (v13 >= 1)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Release while external references exist";
      qword_E4DA8 = v13;
      __break(1u);
      JUMPOUT(0x93C40);
    }
    _os_object_dispose(a1);
  }
}

void _voucher_dispose(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: dispose", v1, v2, v3, v4, v5, v6, v7, 791);
  if (*(_QWORD *)(a1 + 24))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v8, v9, v10, v11, v12, v13, v14, 793);
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
    __break(1u);
    JUMPOUT(0x93D48);
  }
  *(_QWORD *)(a1 + 24) = 0;
  *(_QWORD *)(a1 + 16) = -1985229329;
  if (*(_DWORD *)(a1 + 36))
  {
    if (*(_DWORD *)(a1 + 36) != *(_DWORD *)(a1 + 32))
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 36));
    *(_DWORD *)(a1 + 36) = 0;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    if (!*(_QWORD *)(a1 + 40))
      _voucher_dealloc_mach_voucher(*(_DWORD *)(a1 + 32));
    *(_DWORD *)(a1 + 32) = 0;
  }
  if (*(_QWORD *)(a1 + 40))
  {
    os_release(*(void **)(a1 + 40));
    *(_QWORD *)(a1 + 40) = 0;
  }
  *(_QWORD *)(a1 + 48) = 0;
  *(_QWORD *)(a1 + 56) = 0;
  *(_QWORD *)(a1 + 64) = 0;
  _os_object_dealloc((_QWORD *)a1);
}

_DWORD *voucher_adopt(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v9;
  int v10;
  int v11;
  void *v14;
  _DWORD *v15;
  unsigned int v16;

  if (a1 == -3)
  {
    v14 = _dispatch_thread_getspecific(0x1CuLL);
    if (v14)
      os_retain(v14);
    return v14;
  }
  else
  {
    v15 = _dispatch_thread_getspecific(0x1CuLL);
    if (v15 == (_DWORD *)a1)
    {
      v16 = -1;
    }
    else
    {
      _dispatch_thread_setspecific(28, a1);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400);
      if (a1)
        v11 = *(_DWORD *)(a1 + 32);
      else
        v11 = 0;
      if (v15)
        v10 = v15[8];
      else
        v10 = 0;
      if (v11 == v10)
        v9 = -1;
      else
        v9 = v11;
      v16 = v9;
    }
    if (v16 != -1)
      _dispatch_set_priority_and_mach_voucher_slow(0, v16);
    return v15;
  }
}

void *voucher_copy()
{
  void *v1;

  v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1)
    os_retain(v1);
  return v1;
}

_DWORD *voucher_copy_without_importance()
{
  _DWORD *v1;

  v1 = _dispatch_thread_getspecific(0x1CuLL);
  if (v1)
    return _voucher_create_without_importance(v1);
  return v1;
}

void *voucher_retain(void *a1)
{
  os_retain(a1);
  return a1;
}

void voucher_release(void *a1)
{
  os_release(a1);
}

void _voucher_thread_cleanup(void *a1)
{
  os_release(a1);
}

void _voucher_dealloc_mach_voucher(mach_port_name_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  kern_return_t v14;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tkvoucher[0x%08x]: dealloc", v1, v2, v3, v4, v5, v6, v7, 298);
  v14 = mach_voucher_deallocate(a1);
  if (v14 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x942BCLL);
  }
  if (v14)
    _dispatch_bug(302, v14, v8, v9, v10, v11, v12, v13);
}

uint64_t _voucher_task_mach_voucher_init(uint64_t a1)
{
  uint64_t result;
  int v2;
  int v3;
  uint64_t v4;

  v4 = a1;
  v3 = 0;
  v2 = 0;
  result = _voucher_create_mach_voucher(_voucher_task_mach_voucher_init_task_create_recipe, 16, (ipc_voucher_t *)&v2);
  v3 = result;
  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not create task mach voucher";
    qword_E4DA8 = v3;
    __break(1u);
    JUMPOUT(0x94398);
  }
  _voucher_default_task_mach_voucher = v2;
  _voucher_task_mach_voucher = v2;
  return result;
}

uint64_t _voucher_create_mach_voucher(uint8_t *a1, uint64_t a2, ipc_voucher_t *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  ipc_voucher_t voucher;
  host_t mach_host_port;
  unsigned int v13;
  ipc_voucher_t *v14;
  uint64_t v15;
  mach_voucher_attr_raw_recipe_array_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = 0;
  mach_host_port = _dispatch_get_mach_host_port();
  voucher = 0;
  v13 = host_create_mach_voucher(mach_host_port, v16, v15, &voucher);
  if (v13 == -301)
  {
    qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
    qword_E4DA8 = -301;
    __break(1u);
    JUMPOUT(0x94488);
  }
  if (!v13)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: create", v3, v4, v5, v6, v7, v8, v9, 319);
  }
  *v14 = voucher;
  return v13;
}

void voucher_replace_default_voucher()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v6;
  unsigned int v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  int v16;
  mach_port_name_t v17;
  int v18;
  _QWORD v19[2];
  int mach_voucher;
  _DWORD *v21;
  int v22;
  mach_port_name_t v23;
  uint64_t v24;
  uint64_t v25;
  dispatch_function_t v26;
  void *v27;
  dispatch_once_t *v28;

  v28 = &_voucher_task_mach_voucher_pred;
  v27 = 0;
  v26 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1)
    dispatch_once_f(v28, v27, v26);
  v23 = 0;
  v22 = 0;
  v21 = _dispatch_thread_getspecific(0x1CuLL);
  if (v21 && v21[8])
  {
    mach_voucher = 0;
    if (v21[9])
      v17 = v21[9];
    else
      v17 = v21[8];
    v23 = v17;
    v19[0] = 0x100000003;
    v19[1] = v17;
    mach_voucher = _voucher_create_mach_voucher((uint8_t *)v19, 16, (ipc_voucher_t *)&v22);
    v18 = mach_voucher;
    v25 = mach_voucher;
    v24 = 362;
    if (mach_voucher)
      _dispatch_bug(v24, v25, v0, v1, v2, v3, v4, v5);
    if (v18)
      v22 = 0;
  }
  if (!v22)
    v22 = _voucher_default_task_mach_voucher;
  v15 = v22;
  v16 = _voucher_task_mach_voucher;
  do
  {
    v6 = v16;
    do
      v7 = __ldaxr((unsigned int *)&_voucher_task_mach_voucher);
    while (v7 == v16 && __stlxr(v15, (unsigned int *)&_voucher_task_mach_voucher));
    v16 = v7;
  }
  while (v7 != v6);
  v23 = v7;
  if (v7 && v23 != _voucher_default_task_mach_voucher)
    _voucher_dealloc_mach_voucher(v23);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] replace default voucher", v8, v9, v10, v11, v12, v13, v14, 371);
}

uint64_t _voucher_get_mach_voucher(uint64_t a1)
{
  unsigned int v2;

  if (a1)
  {
    if (*(_DWORD *)(a1 + 36))
    {
      return *(unsigned int *)(a1 + 36);
    }
    else
    {
      v2 = *(_DWORD *)(a1 + 32);
      if (!v2)
      {
        if (_voucher_task_mach_voucher_pred != -1)
          dispatch_once_f(&_voucher_task_mach_voucher_pred, 0, (dispatch_function_t)_voucher_task_mach_voucher_init);
        return _voucher_task_mach_voucher;
      }
      return v2;
    }
  }
  else
  {
    return 0;
  }
}

_DWORD *_voucher_create_without_importance(_DWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  int v34;
  ipc_voucher_t v35;
  int v36;
  _DWORD *v37;
  _DWORD *v39;
  uint64_t v40;
  uint64_t v41;
  _DWORD *v42;
  __int16 v43;
  _QWORD *v44;
  unsigned int v45;
  __int16 v46;
  _DWORD *v47;
  void *v48;
  _DWORD v49[5];
  uint64_t v50;
  int v51;

  v37 = a1;
  if (!a1)
    return 0;
  if (v37[8] && (v37[18] & 1) != 0)
  {
    v36 = 0;
    v35 = 0;
    if (v37[9])
      v30 = v37[9];
    else
      v30 = v37[8];
    v49[0] = -1;
    v49[1] = 1;
    v49[2] = v30;
    v49[3] = 0;
    v49[4] = 2;
    v50 = 2;
    v51 = 0;
    v36 = _voucher_create_mach_voucher((uint8_t *)v49, 32, &v35);
    v34 = v36;
    v41 = v36;
    v40 = 639;
    if (v36)
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    if (v34 || !v35)
    {
      if (v37[9])
        return 0;
      v35 = 0;
    }
    if (v35 == v30)
    {
      _voucher_dealloc_mach_voucher(v35);
      v39 = v37;
      os_retain(v37);
      return v39;
    }
    else
    {
      v32 = _voucher_find_and_retain(v35);
      if (v32 && v37[9])
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find without importance from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 650);
        _voucher_dealloc_mach_voucher(v35);
        return (_DWORD *)v32;
      }
      else
      {
        v31 = v32;
        v47 = v37;
        v46 = 1;
        v45 = 0;
        v44 = 0;
        if (v37)
          v45 = 0;
        v44 = _voucher_alloc(v45, v7, v8, v9, v10, v11, v12, v13);
        if (v47)
        {
          v43 = ~v46;
          if ((v46 & 1) == 0 && v47[8])
          {
            v42 = 0;
            if (*((_QWORD *)v47 + 5))
              v29 = (_DWORD *)*((_QWORD *)v47 + 5);
            else
              v29 = v47;
            v42 = v29;
            v48 = v29;
            os_retain(v29);
            v44[5] = v48;
            *((_DWORD *)v44 + 8) = v42[8];
            *((_BYTE *)v44 + 72) = v44[9] & 0xFE | v42[18] & 1;
          }
          if ((v43 & 2) != 0)
          {
            v44[6] = *((_QWORD *)v47 + 6);
            v44[7] = *((_QWORD *)v47 + 7);
            v44[8] = *((_QWORD *)v47 + 8);
          }
        }
        v33 = v44;
        *((_DWORD *)v44 + 8) = v35;
        if (v37[9])
        {
          *((_DWORD *)v33 + 9) = v35;
          _voucher_insert(v33);
        }
        else if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v35);
        }
        if (!v31)
        {
          _dispatch_thread_getspecific(0);
          _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create without importance from voucher[%p]", v21, v22, v23, v24, v25, v26, v27, 667);
        }
        return v33;
      }
    }
  }
  else
  {
    os_retain(v37);
    return v37;
  }
}

uint64_t _voucher_find_and_retain(unsigned int a1)
{
  unsigned int v1;
  unsigned int v2;
  unsigned int v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unsigned int v18;
  unsigned int v19;
  int v20;
  unsigned int v21;
  int v23;
  unsigned int *v24;
  unsigned int v25;
  unsigned int v26;
  unsigned int *v27;
  unsigned int v28;
  unsigned int v29;
  uint64_t i;
  unsigned int v33;
  unsigned int v34;

  if (!a1)
    return 0;
  v33 = _dispatch_thread_getspecific(3uLL);
  do
    v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
  while (!v1 && __stlxr(v33 & 0xFFFFFFFC, (unsigned int *)&_voucher_hash_lock));
  if (v1)
    _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
  for (i = ~_voucher_hash[(a1 >> 8) & 0x3F]; i; i = ~*(_QWORD *)(i + 16))
  {
    if (*(_DWORD *)(i + 36) == a1)
    {
      v27 = (unsigned int *)(i + 12);
      v28 = *(_DWORD *)(i + 12);
      do
      {
        v2 = v28;
        do
          v3 = __ldaxr(v27);
        while (v3 == v28 && __stlxr(v28 + 1, v27));
        v26 = v3;
        v28 = v3;
      }
      while (v3 != v2);
      v29 = v3 + 1;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: retain  -> %d", v4, v5, v6, v7, v8, v9, v10, 234);
      if ((int)(v26 + 1) <= 0)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: over-release", v11, v12, v13, v14, v15, v16, v17, 236);
        qword_E4D78 = (uint64_t)"API MISUSE: Voucher over-release";
        __break(1u);
        JUMPOUT(0x9517CLL);
      }
      if (v29 == 1)
      {
        v24 = (unsigned int *)(i + 8);
        v25 = *(_DWORD *)(i + 8);
        do
        {
          v18 = v25;
          do
            v19 = __ldaxr(v24);
          while (v19 == v25 && __stlxr(v25 + 1, v24));
          v25 = v19;
        }
        while (v19 != v18);
      }
      break;
    }
  }
  v34 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  v23 = _voucher_hash_lock;
  do
  {
    v20 = v23;
    do
      v21 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (v21 == v23 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
    v23 = v21;
  }
  while (v21 != v20);
  if (v21 != v34)
    _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v21);
  return i;
}

_QWORD *_voucher_insert(_QWORD *result)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  int v32;
  unsigned int v33;
  int v34;
  unsigned int v35;
  unint64_t v36;
  unsigned int v37;
  unint64_t v38;
  unint64_t *v39;

  v36 = (unint64_t)result;
  v35 = *((_DWORD *)result + 9);
  if (v35)
  {
    v37 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (!v1 && __stlxr(v37, (unsigned int *)&_voucher_hash_lock));
    if (v1)
      _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
    if (*(_QWORD *)(v36 + 24))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 259);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x95568);
    }
    if (*(_QWORD *)(v36 + 48))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Activity data corruption", v9, v10, v11, v12, v13, v14, v15, 263);
      v16 = *(_QWORD *)(v36 + 48);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_E4DA8 = v16;
      __break(1u);
      JUMPOUT(0x955F4);
    }
    if (*(_QWORD *)(v36 + 40))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Incoming voucher with corrupted base", v17, v18, v19, v20, v21, v22, v23, 267);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: Corrupted base for incoming voucher", v24, v25, v26, v27, v28, v29, v30, 268);
      v31 = *(_QWORD *)(v36 + 40);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_E4DA8 = v31;
      __break(1u);
      JUMPOUT(0x956B8);
    }
    v39 = &_voucher_hash[(v35 >> 8) & 0x3F];
    v38 = ~*v39;
    *(_QWORD *)(v36 + 16) = *v39;
    if (v38)
      *(_QWORD *)(v38 + 24) = ~(v36 + 16);
    *v39 = ~v36;
    *(_QWORD *)(v36 + 24) = ~(unint64_t)v39;
    result = _dispatch_thread_getspecific(3uLL);
    v34 = _voucher_hash_lock;
    do
    {
      v32 = v34;
      do
        v33 = __ldaxr((unsigned int *)&_voucher_hash_lock);
      while (v33 == v34 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
      v34 = v33;
    }
    while (v33 != v32);
    if (v33 != (result & 0xFFFFFFFC))
      return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v33);
  }
  return result;
}

_QWORD *_voucher_create_accounting_voucher(_DWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  ipc_voucher_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  unsigned int v30;
  uint64_t v31;
  _QWORD *v32;
  int v33;
  _QWORD v34[2];
  ipc_voucher_t v35;
  unsigned int v36;
  int v37;
  _DWORD *v38;
  _DWORD *v40;
  uint64_t v41;
  uint64_t v42;

  v38 = a1;
  if (!a1 || !v38[8])
    return 0;
  v37 = 0;
  v36 = 0;
  v35 = 0;
  if (v38[9])
    v30 = v38[9];
  else
    v30 = v38[8];
  v36 = v30;
  v34[0] = 0x100000003;
  v34[1] = v30;
  v37 = _voucher_create_mach_voucher((uint8_t *)v34, 16, &v35);
  v33 = v37;
  v42 = v37;
  v41 = 689;
  if (v37)
    _dispatch_bug(v41, v42, v1, v2, v3, v4, v5, v6);
  if (v33 || !v35)
    return 0;
  v31 = _voucher_find_and_retain(v35);
  if (v31)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find accounting voucher from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 695);
    _voucher_dealloc_mach_voucher(v35);
    return (_QWORD *)v31;
  }
  else
  {
    v32 = _voucher_alloc(0, v7, v8, v9, v10, v11, v12, v13);
    v21 = v35;
    *((_DWORD *)v32 + 8) = v35;
    *((_DWORD *)v32 + 9) = v21;
    if (v35 == v36)
    {
      v40 = v38;
      os_retain(v38);
      v32[5] = v40;
      _voucher_dealloc_mach_voucher(v35);
    }
    _voucher_insert(v32);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create accounting voucher from voucher[%p]", v22, v23, v24, v25, v26, v27, v28, 708);
    return v32;
  }
}

_QWORD *_voucher_alloc(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v22;

  v22 = _os_object_alloc_realized((uint64_t)_OS_voucher_vtable, a1 + 80, a3, a4, a5, a6, a7, a8);
  if (a1)
    _dispatch_abort(62, a1 == 0, v8, v9, v10, v11, v12, v13);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: alloc", v14, v15, v16, v17, v18, v19, v20, 64);
  return v22;
}

_QWORD *_voucher_create_with_mach_msgv(_DWORD *a1, _DWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _DWORD *v9;
  unsigned int v10;
  unsigned int v11;
  uint64_t v12;
  unsigned int v13;
  _DWORD *v14;
  _DWORD *v15;
  int v16;
  unsigned int v17;
  int *v18;
  _DWORD *v19;
  unsigned int v20;

  v15 = a1;
  v14 = a2;
  v13 = 0;
  v12 = 0;
  v11 = 0;
  v19 = a1;
  v18 = (int *)&v13;
  if ((*a1 & 0x1F0000) != 0)
  {
    v17 = 0;
    v17 = v19[4];
    v19[4] = 0;
    v16 = 538902528;
    *v18 = *v19 & 0x201F0000;
    *v19 &= ~v16;
    v20 = v17;
  }
  else
  {
    *v18 = 0;
    v20 = 0;
  }
  if (a2)
  {
    v10 = *a2;
    if (*a2 <= 7u)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid msg aux data size.";
      qword_E4DA8 = v10;
      __break(1u);
      JUMPOUT(0x95DC0);
    }
    v11 = v10 - 8;
    if (v10 == 8)
      v9 = 0;
    else
      v9 = a2 + 2;
    v12 = (uint64_t)v9;
  }
  return _voucher_create_with_mach_voucher(v20, v13, v12, v11, a5, a6, a7, a8);
}

_QWORD *_voucher_create_with_mach_voucher(unsigned int a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  _QWORD *v34;
  unsigned int v35;
  int v37;
  _QWORD *v40;

  v37 = a2;
  v35 = a4;
  v33 = 0;
  if (a1)
  {
    v33 = _voucher_find_and_retain(a1);
    if (v33)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] found", v15, v16, v17, v18, v19, v20, v21, 485);
      _voucher_dealloc_mach_voucher(a1);
    }
    else
    {
      v33 = (uint64_t)_voucher_alloc(0, v8, v9, v10, v11, v12, v13, v14);
      *(_DWORD *)(v33 + 32) = a1;
      *(_DWORD *)(v33 + 36) = a1;
      *(_BYTE *)(v33 + 72) = *(_BYTE *)(v33 + 72) & 0xFE | ((v37 & 0x20000000) != 0);
      _voucher_insert((_QWORD *)v33);
    }
  }
  if (v35 < 0x20 || *(_DWORD *)a3 != 59821818 || !*(_QWORD *)(a3 + 8))
    return (_QWORD *)v33;
  if (v33)
  {
    if (*(_QWORD *)(v33 + 48))
    {
      v22 = *(_QWORD *)(v33 + 48);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has non-zero activity value";
      qword_E4DA8 = v22;
      __break(1u);
      JUMPOUT(0x95FF0);
    }
    if (*(_QWORD *)(v33 + 40))
    {
      v23 = *(_QWORD *)(v33 + 40);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: base voucher has nested base voucher";
      qword_E4DA8 = v23;
      __break(1u);
      JUMPOUT(0x96048);
    }
    v40 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
    if (*(_DWORD *)(v33 + 32))
    {
      if (*(_QWORD *)(v33 + 40))
        v32 = *(_QWORD *)(v33 + 40);
      else
        v32 = v33;
      os_retain((void *)v32);
      v40[5] = v32;
      *((_DWORD *)v40 + 8) = *(_DWORD *)(v32 + 32);
      *((_BYTE *)v40 + 72) = v40[9] & 0xFE | *(_BYTE *)(v32 + 72) & 1;
    }
    v34 = v40;
    voucher_release((void *)v33);
  }
  else
  {
    v34 = _voucher_alloc(0, a2, a3, a4, a5, a6, a7, a8);
  }
  v34[6] = *(_QWORD *)(a3 + 8);
  v34[7] = *(_QWORD *)(a3 + 16);
  v34[8] = *(_QWORD *)(a3 + 24);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create", v24, v25, v26, v27, v28, v29, v30, 521);
  return v34;
}

_QWORD *voucher_create_with_mach_msg(_DWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unsigned int v9;
  _DWORD *v10;
  int v11;
  unsigned int v12;
  int *v13;
  _DWORD *v14;
  unsigned int v15;

  v10 = a1;
  v9 = 0;
  v14 = a1;
  v13 = (int *)&v9;
  if ((*a1 & 0x1F0000u) >> 16)
  {
    v12 = 0;
    v12 = v14[4];
    v14[4] = 0;
    v11 = 538902528;
    *v13 = *v14 & 0x201F0000;
    *v14 &= ~v11;
    v15 = v12;
  }
  else
  {
    *v13 = 0;
    v15 = 0;
  }
  return _voucher_create_with_mach_voucher(v15, v9, 0, 0, a5, a6, a7, a8);
}

void voucher_decrement_importance_count4CF(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  ipc_voucher_t v14;
  mach_error_t v15;
  int v16;
  mach_msg_type_number_t out_contentCnt;
  int *v18;
  int v19;
  int *v20;
  int v21;
  ipc_voucher_t v22;
  mach_error_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v24 = a1;
  if (a1 && *(_DWORD *)(v24 + 32) && (*(_BYTE *)(v24 + 72) & 1) != 0)
  {
    v23 = 0;
    v22 = 0;
    if (*(_DWORD *)(v24 + 36))
      v14 = *(_DWORD *)(v24 + 36);
    else
      v14 = *(_DWORD *)(v24 + 32);
    v22 = v14;
    v21 = 1;
    v20 = &v21;
    v19 = 4;
    v16 = -1;
    v18 = &v16;
    out_contentCnt = 4;
    v23 = mach_voucher_attr_command(v14, 2u, 2u, (mach_voucher_attr_content_t)&v21, 4u, (mach_voucher_attr_content_t)&v16, &out_contentCnt);
    if (v23 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x964B0);
    }
    if (v23 != 16)
    {
      _dispatch_thread_getspecific(0);
      mach_error_string(v23);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] decrement importance count to %u: %s - 0x%x", v1, v2, v3, v4, v5, v6, v7, 764);
      v15 = v23;
      v26 = v23;
      v25 = 766;
      if (v23)
        _dispatch_bug(v25, v26, v8, v9, v10, v11, v12, v13);
      if (v15 == 5)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher importance count underflow";
        qword_E4DA8 = v23;
        __break(1u);
        JUMPOUT(0x965DCLL);
      }
    }
  }
}

_DWORD *_voucher_remove(_DWORD *result)
{
  unsigned int v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  unsigned int v10;
  int v11;
  int v12;
  _DWORD *v13;
  unsigned int v14;
  uint64_t v15;
  uint64_t v16;

  v13 = result;
  v12 = result[9];
  if (*((_QWORD *)result + 3))
  {
    v14 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
    do
      v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (!v1 && __stlxr(v14, (unsigned int *)&_voucher_hash_lock));
    if (v1)
      _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
    if (!v12)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: corruption", v2, v3, v4, v5, v6, v7, v8, 282);
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Voucher corruption";
      __break(1u);
      JUMPOUT(0x96784);
    }
    if ((int)v13[3] <= 0 && *((_QWORD *)v13 + 3))
    {
      v16 = *((_QWORD *)v13 + 2);
      v15 = *((_QWORD *)v13 + 3);
      if (v16 != -1)
        *(_QWORD *)(23 - v16) = v15;
      *(_QWORD *)~v15 = v16;
      *((_QWORD *)v13 + 3) = 0;
      *((_QWORD *)v13 + 2) = -1985229329;
    }
    result = _dispatch_thread_getspecific(3uLL);
    v11 = _voucher_hash_lock;
    do
    {
      v9 = v11;
      do
        v10 = __ldaxr((unsigned int *)&_voucher_hash_lock);
      while (v10 == v11 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
      v11 = v10;
    }
    while (v10 != v9);
    if (v10 != (result & 0xFFFFFFFC))
      return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v10);
  }
  return result;
}

void _voucher_activity_debug_channel_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  kern_return_t v8;
  mach_port_t special_port;
  uint64_t f;
  uint64_t v11;

  v11 = 0;
  if (_voucher_libtrace_hooks)
    v11 = *(_QWORD *)(_voucher_libtrace_hooks + 16);
  if (v11)
  {
    f = 0;
    special_port = 0;
    v8 = task_get_special_port(mach_task_self_, 10, &special_port);
    if (v8 == -301)
    {
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x96A84);
    }
    if (v8)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Couldn't get debug control port";
      qword_E4DA8 = v8;
      __break(1u);
      JUMPOUT(0x96AD4);
    }
    if (special_port)
    {
      f = dispatch_mach_create_f((uint64_t)"com.apple.debug-channel", 0, 0, v11, v0, v1, v2, v3);
      *(_BYTE *)(*(_QWORD *)(f + 88) + 29) &= ~0x20u;
      dispatch_mach_connect(f, special_port, 0, 0, v4, v5, v6, v7);
      _voucher_activity_debug_channel = f;
    }
  }
}

uint64_t _voucher_atfork_prepare()
{
  uint64_t result;
  unsigned int v1;

  result = (uint64_t)_dispatch_thread_getspecific(3uLL);
  do
    v1 = __ldaxr((unsigned int *)&_voucher_hash_lock);
  while (!v1 && __stlxr(result & 0xFFFFFFFC, (unsigned int *)&_voucher_hash_lock));
  if (v1)
    return _dispatch_unfair_lock_lock_slow((unsigned int *)&_voucher_hash_lock, 0x10000);
  return result;
}

void *_voucher_atfork_parent()
{
  void *result;
  int v1;
  unsigned int v2;
  int v3;

  result = _dispatch_thread_getspecific(3uLL);
  v3 = _voucher_hash_lock;
  do
  {
    v1 = v3;
    do
      v2 = __ldaxr((unsigned int *)&_voucher_hash_lock);
    while (v2 == v3 && __stlxr(0, (unsigned int *)&_voucher_hash_lock));
    v3 = v2;
  }
  while (v2 != v1);
  if (v2 != (result & 0xFFFFFFFC))
    return _dispatch_unfair_lock_unlock_slow((uint64_t)&_voucher_hash_lock, v2);
  return result;
}

uint64_t _voucher_atfork_child()
{
  uint64_t result;

  _voucher_hash_reset_locked();
  _voucher_hash_lock = 0;
  result = _dispatch_thread_setspecific(28, 0);
  _voucher_task_mach_voucher_pred = 0;
  _voucher_task_mach_voucher = 0;
  _voucher_default_task_mach_voucher = 0;
  _voucher_aid_next = 0;
  _firehose_task_buffer_pred = 0;
  _firehose_task_buffer = 0;
  return result;
}

void *_voucher_hash_reset_locked()
{
  uint64_t v1;
  _QWORD *v2;
  unsigned int i;
  uint64_t v4;
  uint64_t v5;

  for (i = 0; i < 0x40; ++i)
  {
    v2 = (_QWORD *)((char *)&_voucher_hash + 8 * i);
    while (1)
    {
      v1 = ~*v2;
      if (*v2 == -1)
        break;
      *(_DWORD *)(31 - *v2) = 0;
      *(_DWORD *)(v1 + 36) = 0;
      v5 = ~*(_QWORD *)(v1 + 16);
      v4 = *(_QWORD *)(v1 + 24);
      if (*(_QWORD *)(v1 + 16) != -1)
        *(_QWORD *)(23 - *(_QWORD *)(v1 + 16)) = v4;
      *(_QWORD *)~v4 = ~v5;
      *(_QWORD *)(v1 + 24) = 0;
      *(_QWORD *)(v1 + 16) = -1985229329;
    }
  }
  return memset(&_voucher_hash, -1, 0x200uLL);
}

uint64_t voucher_process_can_use_arbitrary_personas()
{
  if (_voucher_process_can_use_arbitrary_personas_pred != -1)
    dispatch_once_f(&_voucher_process_can_use_arbitrary_personas_pred, 0, (dispatch_function_t)_voucher_process_can_use_arbitrary_personas_init);
  return _voucher_process_can_use_arbitrary_personas & 1;
}

uint64_t _voucher_process_can_use_arbitrary_personas_init(uint64_t a1)
{
  uint64_t result;
  int v2;
  mach_msg_type_number_t out_contentCnt;
  mach_voucher_attr_content_t out_content;
  int v5;
  ipc_voucher_t voucher;
  uint64_t v7;
  dispatch_function_t v8;
  void *v9;
  dispatch_once_t *v10;

  v7 = a1;
  voucher = 0;
  v10 = &_voucher_task_mach_voucher_pred;
  v9 = 0;
  v8 = (dispatch_function_t)_voucher_task_mach_voucher_init;
  if (_voucher_task_mach_voucher_pred != -1)
    dispatch_once_f(v10, v9, v8);
  voucher = _voucher_task_mach_voucher;
  v5 = 0;
  v2 = 0;
  out_content = (mach_voucher_attr_content_t)&v2;
  out_contentCnt = 4;
  result = mach_voucher_attr_command(_voucher_task_mach_voucher, 3u, 4u, 0, 0, (mach_voucher_attr_content_t)&v2, &out_contentCnt);
  v5 = result;
  if ((_DWORD)result)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: mach_voucher_attr_command(BANK_PERSONA_ADOPT_ANY) failed";
    qword_E4DA8 = v5;
    __break(1u);
    JUMPOUT(0x970C4);
  }
  _voucher_process_can_use_arbitrary_personas = v2 != 0;
  return result;
}

uint64_t voucher_copy_with_persona_mach_voucher(unsigned int a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  _DWORD *v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  _QWORD *v33;
  int v34;
  _DWORD *v35;
  ipc_voucher_t v36;
  int v37;
  int v38;
  unsigned int v39;
  _DWORD *v41;
  uint64_t v42;
  uint64_t v43;
  _DWORD *v44;
  __int16 v45;
  _QWORD *v46;
  unsigned int v47;
  __int16 v48;
  _DWORD *v49;
  void *v50;
  _DWORD v51[6];
  uint64_t v52;

  v39 = a1;
  if (!a1)
    return (uint64_t)voucher_copy();
  v38 = 0;
  v37 = 0;
  v36 = 0;
  v35 = _dispatch_thread_getspecific(0x1CuLL);
  if (v35)
  {
    if (v35[9])
      v30 = v35[9];
    else
      v30 = v35[8];
    v37 = v30;
  }
  v51[0] = -1;
  v51[1] = 1;
  v51[2] = v37;
  v51[3] = 0;
  v51[4] = 3;
  v51[5] = 10;
  v52 = v39;
  v38 = _voucher_create_mach_voucher((uint8_t *)v51, 32, &v36);
  v34 = v38;
  v43 = v38;
  v42 = 944;
  if (v38)
    _dispatch_bug(v42, v43, v1, v2, v3, v4, v5, v6);
  if (v34)
  {
    if (v38 == 20)
      return -1;
    v36 = 0;
  }
  if (v36 == v37)
  {
    if (v36)
      _voucher_dealloc_mach_voucher(v36);
    v41 = v35;
    os_retain(v35);
    return (uint64_t)v41;
  }
  else
  {
    v32 = _voucher_find_and_retain(v36);
    if (v32 && (!v35 || v35[9]))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] find with persona from voucher[%p]", v14, v15, v16, v17, v18, v19, v20, 958);
      _voucher_dealloc_mach_voucher(v36);
      return v32;
    }
    else
    {
      v31 = v32;
      v49 = v35;
      v48 = 1;
      v47 = 0;
      v46 = 0;
      if (v35)
        v47 = 0;
      v46 = _voucher_alloc(v47, v7, v8, v9, v10, v11, v12, v13);
      if (v49)
      {
        v45 = ~v48;
        if ((v48 & 1) == 0 && v49[8])
        {
          v44 = 0;
          if (*((_QWORD *)v49 + 5))
            v29 = (_DWORD *)*((_QWORD *)v49 + 5);
          else
            v29 = v49;
          v44 = v29;
          v50 = v29;
          os_retain(v29);
          v46[5] = v50;
          *((_DWORD *)v46 + 8) = v44[8];
          *((_BYTE *)v46 + 72) = v46[9] & 0xFE | v44[18] & 1;
        }
        if ((v45 & 2) != 0)
        {
          v46[6] = *((_QWORD *)v49 + 6);
          v46[7] = *((_QWORD *)v49 + 7);
          v46[8] = *((_QWORD *)v49 + 8);
        }
      }
      v33 = v46;
      *((_DWORD *)v46 + 8) = v36;
      if (v35 && !v35[9])
      {
        if (v31)
        {
          v33[5] = v31;
          _voucher_dealloc_mach_voucher(v36);
        }
      }
      else
      {
        *((_DWORD *)v33 + 9) = v36;
        _voucher_insert(v33);
      }
      if (!v31)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\tvoucher[%p]: kvoucher[0x%08x] create with persona from voucher[%p]", v21, v22, v23, v24, v25, v26, v27, 975);
      }
      return (uint64_t)v33;
    }
  }
}

uint64_t mach_voucher_persona_self(_DWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int v8;
  ipc_voucher_t v9;
  _DWORD *v10;
  uint64_t v11;
  uint64_t v12;
  _OWORD v13[2];

  v10 = a1;
  v9 = 0;
  v13[0] = xmmword_C2A00;
  v13[1] = xmmword_C2A10;
  v8 = _voucher_create_mach_voucher((uint8_t *)v13, 32, &v9);
  v12 = (int)v8;
  v11 = 1000;
  if (v8)
  {
    _dispatch_bug(v11, v12, v1, v2, v3, v4, v5, v6);
    v9 = 0;
  }
  *v10 = v9;
  return v8;
}

uint64_t mach_voucher_persona_for_originator(unsigned int a1, unsigned int a2, uint64_t a3, _DWORD *a4)
{
  _QWORD *v4;
  uint64_t v5;
  _BYTE v7[52];
  uint8_t *v8;
  unsigned int v9;
  _QWORD *v10;
  uint64_t v11;
  ipc_voucher_t *v12;
  __int128 v13;
  __int128 v14;
  uint8_t *v15;
  uint64_t v16;
  _QWORD v17[2];
  unsigned int mach_voucher;
  int v19;
  _DWORD *v20;
  uint64_t v21;
  unsigned int v22;
  unsigned int v23;
  uint64_t v24;
  _QWORD *v25;
  uint8_t *v26;

  v23 = a1;
  v22 = a2;
  v21 = a3;
  v20 = a4;
  v12 = (ipc_voucher_t *)&v19;
  v9 = 0;
  v19 = 0;
  mach_voucher = 46;
  v10 = v17;
  v17[0] = a1;
  v17[1] = a3;
  v16 = 48;
  v15 = 0;
  v8 = v7;
  bzero(v7, 0x30uLL);
  v15 = v8;
  v11 = -1;
  __memset_chk(v8, v9, v16, -1);
  v4 = v10;
  v5 = v11;
  *(_QWORD *)&v14 = 0x100000003;
  *((_QWORD *)&v14 + 1) = v22;
  *(_OWORD *)v15 = v14;
  *(_QWORD *)&v13 = 0x26300000003;
  *((_QWORD *)&v13 + 1) = 0x1000000000;
  *((_OWORD *)v15 + 1) = v13;
  v26 = v15 + 32;
  v25 = v4;
  v24 = 16;
  __memcpy_chk(v15 + 32, v4, 16, v5);
  mach_voucher = _voucher_create_mach_voucher(v15, v16, v12);
  if (mach_voucher)
    v19 = 0;
  *v20 = v19;
  return mach_voucher;
}

uint64_t voucher_get_current_persona()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  int v7;
  unsigned int v8;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unint64_t StatusReg;

  v8 = -1;
  if (_voucher_get_current_persona_id((uint8_t *)&v8))
  {
    if ((int)kpersona_get(&v8) < 0)
    {
      v12 = 1;
      v13 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v7 = **(_DWORD **)(StatusReg + 8);
      if (v7 != 3)
      {
        v11 = v7;
        v10 = 1126;
        if (v7)
          _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
      }
    }
    return v8;
  }
  else
  {
    return v8;
  }
}

uint64_t _voucher_get_current_persona_id(uint8_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ipc_voucher_t v8;
  mach_msg_type_number_t out_contentCnt;
  mach_voucher_attr_content_t out_content;
  mach_msg_type_number_t in_contentCnt;
  mach_voucher_attr_content_t in_content;
  ipc_voucher_t v13;
  _DWORD *v14;
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;

  v16 = a1;
  v15 = 5;
  v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    v13 = 0;
    if (v14[9])
      v8 = v14[9];
    else
      v8 = v14[8];
    v13 = v8;
    in_content = 0;
    in_contentCnt = 0;
    out_content = v16;
    out_contentCnt = 4;
    v15 = mach_voucher_attr_command(v8, 3u, 3u, 0, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      v18 = v15;
      v17 = 1103;
      if (v15)
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
    }
  }
  return v15;
}

uint64_t voucher_get_current_persona_originator_info(void *a1)
{
  uint8_t __b[96];

  memset(__b, 0, sizeof(__b));
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }
  else
  {
    memcpy(a1, __b, 0x30uLL);
    return 0;
  }
}

uint64_t _voucher_get_current_persona_token(uint8_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  ipc_voucher_t v8;
  mach_msg_type_number_t out_contentCnt;
  mach_voucher_attr_content_t out_content;
  mach_msg_type_number_t in_contentCnt;
  mach_voucher_attr_content_t in_content;
  ipc_voucher_t v13;
  _DWORD *v14;
  kern_return_t v15;
  mach_voucher_attr_content_t v16;
  uint64_t v17;
  uint64_t v18;

  v16 = a1;
  v15 = 5;
  v14 = _dispatch_thread_getspecific(0x1CuLL);
  if (v14 && v14[8])
  {
    v13 = 0;
    if (v14[9])
      v8 = v14[9];
    else
      v8 = v14[8];
    v13 = v8;
    in_content = 0;
    in_contentCnt = 0;
    out_content = v16;
    out_contentCnt = 96;
    v15 = mach_voucher_attr_command(v8, 3u, 2u, 0, 0, v16, &out_contentCnt);
    if (v15 != 46 && v15 != 18 && v15 != 4)
    {
      v18 = v15;
      v17 = 1075;
      if (v15)
        _dispatch_bug(v17, v18, v1, v2, v3, v4, v5, v6);
    }
  }
  return v15;
}

uint64_t voucher_get_current_persona_proximate_info(void *a1)
{
  uint8_t __b[96];

  memset(__b, 0, sizeof(__b));
  if (_voucher_get_current_persona_token(__b))
  {
    return -1;
  }
  else
  {
    memcpy(a1, &__b[48], 0x30uLL);
    return 0;
  }
}

BOOLean_t voucher_mach_msg_set(mach_msg_header_t *msg)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mach_port_name_t mach_voucher;
  void *v10;
  char v12;
  char v13;

  v10 = _dispatch_thread_getspecific(0x1CuLL);
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    v12 = 0;
  }
  else
  {
    if (v10)
    {
      mach_voucher = _voucher_get_mach_voucher((uint64_t)v10);
    }
    else
    {
      if (_voucher_task_mach_voucher_pred != -1)
        dispatch_once_f(&_voucher_task_mach_voucher_pred, 0, (dispatch_function_t)_voucher_task_mach_voucher_init);
      mach_voucher = _voucher_task_mach_voucher;
    }
    if ((msg->msgh_bits & 0x1F0000) >> 16)
    {
      v13 = 0;
    }
    else if (mach_voucher)
    {
      msg->msgh_voucher_port = mach_voucher;
      msg->msgh_bits |= 0x130000u;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] set %s", v1, v2, v3, v4, v5, v6, v7, 476);
      v13 = 1;
    }
    else
    {
      v13 = 0;
    }
    v12 = v13;
  }
  return v12 & 1;
}

void voucher_mach_msg_clear(mach_msg_header_t *msg)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  mach_port_name_t msgh_voucher_port;
  mach_msg_bits_t v9;

  v9 = (msg->msgh_bits & 0x1F0000) >> 16;
  msgh_voucher_port = msg->msgh_voucher_port;
  if ((v9 == 19 || v9 == 17) && msgh_voucher_port)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tkvoucher[0x%08x]: msg[%p] clear %s", v1, v2, v3, v4, v5, v6, v7, 520);
    if (v9 == 17)
      _voucher_dealloc_mach_voucher(msgh_voucher_port);
    msg->msgh_voucher_port = 0;
    msg->msgh_bits &= 0xFFE0FFFF;
  }
}

voucher_mach_msg_state_t voucher_mach_msg_adopt(mach_msg_header_t *msg)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v13;
  int v14;
  int v15;
  unsigned int *v16;
  int v17;
  unsigned int *v18;
  unsigned int v19;
  unsigned int v20;
  uint64_t v21;
  unsigned int v22;
  mach_msg_header_t *v23;
  voucher_mach_msg_state_s *v25;
  voucher_mach_msg_state_s *v26;
  int v27;
  mach_port_name_t msgh_voucher_port;
  mach_msg_bits_t *v29;
  mach_msg_header_t *v30;
  unsigned int v31;
  unsigned int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  voucher_mach_msg_state_s *v39;
  voucher_mach_msg_state_s *v40;
  unsigned int v41;

  v23 = msg;
  v22 = 0;
  v21 = 0;
  v20 = 0;
  v30 = msg;
  v29 = &v22;
  if ((msg->msgh_bits & 0x1F0000) >> 16)
  {
    msgh_voucher_port = 0;
    msgh_voucher_port = v30->msgh_voucher_port;
    v30->msgh_voucher_port = 0;
    v27 = 538902528;
    *v29 = v30->msgh_bits & 0x201F0000;
    v30->msgh_bits &= ~v27;
    v31 = msgh_voucher_port;
  }
  else
  {
    *v29 = 0;
    v31 = 0;
  }
  v19 = v31;
  if (!v31)
    return (voucher_mach_msg_state_t)-1;
  v18 = (unsigned int *)_dispatch_thread_getspecific(0x7BuLL);
  if (v18)
  {
    v17 = *v18;
    if (*v18 >= 8uLL)
    {
      v20 = v17 - 8;
      if (v17 == 8)
        v16 = 0;
      else
        v16 = v18 + 2;
      v21 = (uint64_t)v16;
    }
  }
  v26 = (voucher_mach_msg_state_s *)_voucher_create_with_mach_voucher(v19, v22, v21, v20, v1, v2, v3, v4);
  v25 = 0;
  v25 = (voucher_mach_msg_state_s *)_dispatch_thread_getspecific(0x1CuLL);
  v40 = v25;
  v39 = v26;
  if (v25 == v26)
  {
    v41 = -1;
  }
  else
  {
    if (v40)
    {
      v38 = 0;
      v37 = 0;
    }
    _dispatch_thread_setspecific(28, (uint64_t)v39);
    if (v39)
    {
      v36 = 0;
      v35 = 0;
    }
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v5, v6, v7, v8, v9, v10, v11, 400);
    v34 = 0;
    if (v39)
      v15 = *((_DWORD *)v39 + 8);
    else
      v15 = 0;
    v34 = v15;
    v33 = 0;
    if (v40)
      v14 = *((_DWORD *)v40 + 8);
    else
      v14 = 0;
    v33 = v14;
    if (v34 == v14)
      v13 = -1;
    else
      v13 = v34;
    v41 = v13;
  }
  v32 = v41;
  if (v41 != -1)
    _dispatch_set_priority_and_mach_voucher_slow(0, v32);
  return v25;
}

void voucher_mach_msg_revert(voucher_mach_msg_state_t state)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  int v8;
  int v9;
  int v10;
  _DWORD *v12;
  unsigned int v13;

  if (state != (voucher_mach_msg_state_t)-1)
  {
    v12 = _dispatch_thread_getspecific(0x1CuLL);
    if (v12 == (_DWORD *)state)
    {
      v13 = -1;
    }
    else
    {
      _dispatch_thread_setspecific(28, (uint64_t)state);
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tvoucher[%p]: swap from voucher[%p]", v1, v2, v3, v4, v5, v6, v7, 400);
      if (state)
        v10 = *((_DWORD *)state + 8);
      else
        v10 = 0;
      if (v12)
        v9 = v12[8];
      else
        v9 = 0;
      if (v10 == v9)
        v8 = -1;
      else
        v8 = v10;
      v13 = v8;
    }
    if (v13 != -1)
      _dispatch_set_priority_and_mach_voucher_slow(0, v13);
    if (v12)
      os_release(v12);
  }
}

uint64_t *voucher_activity_initialize_4libtrace(uint64_t *result)
{
  uint64_t v1;
  unint64_t v2;

  if (*result <= 2)
  {
    v1 = *result;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: unsupported vah_version";
    qword_E4DA8 = v1;
    __break(1u);
    JUMPOUT(0x988E4);
  }
  do
    v2 = __ldaxr((unint64_t *)&_voucher_libtrace_hooks);
  while (!v2 && __stlxr((unint64_t)result, (unint64_t *)&_voucher_libtrace_hooks));
  if (v2)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: voucher_activity_initialize_4libtrace called twice";
    qword_E4DA8 = _voucher_libtrace_hooks;
    __break(1u);
    JUMPOUT(0x989D8);
  }
  return result;
}

uint64_t _voucher_init()
{
  return _voucher_libkernel_init();
}

uint64_t _voucher_libkernel_init()
{
  uint64_t result;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;

  result = __libkernel_voucher_init(&_voucher_libkernel_functions);
  if ((_DWORD)result)
    _dispatch_abort(1262, (_DWORD)result == 0, v1, v2, v3, v4, v5, v6);
  return result;
}

unint64_t voucher_activity_id_allocate(unsigned __int8 a1)
{
  unint64_t v1;
  _BOOL4 v3;
  unint64_t v4;
  unint64_t v5;

  while (1)
  {
    v1 = _os_atomic_mo_has_acquire(0)
       ? __ldaxr((unint64_t *)&_voucher_aid_next)
       : __ldxr((unint64_t *)&_voucher_aid_next);
    v5 = v1;
    v4 = v1 + 1;
    if (!v1 || !(v4 % 0x10))
      break;
    if (_os_atomic_mo_has_release(0))
      v3 = __stlxr(v4, (unint64_t *)&_voucher_aid_next) == 0;
    else
      v3 = __stxr(v4, (unint64_t *)&_voucher_aid_next) == 0;
    if (v3)
      return v5 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
  }
  __clrex();
  _voucher_activity_id_allocate_slow();
  return v5 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)a1 << 56);
}

mach_vm_address_t voucher_activity_get_logging_preferences(mach_vm_size_t *a1)
{
  BOOL v2;

  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  v2 = 1;
  if (_firehose_task_buffer)
    v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  if (!v2)
    return firehose_buffer_get_logging_prefs(_firehose_task_buffer, a1);
  *a1 = 0;
  return 0;
}

BOOL voucher_activity_should_send_strings(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  BOOL v9;

  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  v9 = 1;
  if (_firehose_task_buffer)
    v9 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  return !v9 && firehose_buffer_should_send_strings(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
}

uint64_t voucher_activity_get_metadata_buffer(_QWORD *a1)
{
  BOOL v2;
  uint64_t v3;

  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  v2 = 1;
  if (_firehose_task_buffer)
    v2 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  if (v2)
  {
    *a1 = 0;
    return 0;
  }
  else
  {
    v3 = _firehose_task_buffer;
    *a1 = 2048;
    return v3 + 4096 - *a1;
  }
}

_QWORD *voucher_activity_create_with_data_2(unint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, unint64_t a5, int a6)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned __int16 v13;
  BOOL v14;
  unint64_t v15;
  unsigned __int8 v16;
  unint64_t v17;
  unint64_t *v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t *v22;
  unint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unsigned __int8 v30;
  unint64_t v31;
  unint64_t *v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t v35;
  unint64_t *v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t v39;
  unint64_t *v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  char v47;
  unint64_t *v48;
  unint64_t v49;
  BOOL v50;
  char v51;
  int v52;
  BOOL v53;
  BOOL v54;
  char v55;
  int v56;
  BOOL v57;
  BOOL v58;
  _DWORD *v59;
  unint64_t *v60;
  unint64_t i;
  uint64_t v62;
  unint64_t *v63;
  _BOOL8 v64;
  _QWORD *v65;
  _QWORD *v66;
  unsigned __int16 v67;
  uint64_t v68;
  unint64_t v69;
  uint64_t v70;
  uint64_t v71;
  unint64_t v72;
  int v73;
  unint64_t v74;
  uint64_t v75;
  uint64_t v76;
  _QWORD *v77;
  unint64_t *v78;
  _DWORD *v79;
  __int16 v80;
  _QWORD *v81;
  unsigned int v82;
  __int16 v83;
  _QWORD *v84;
  void *object;
  unint64_t v86;
  uint64_t v87;
  unint64_t *v88;
  uint64_t v89;
  unint64_t *v90;
  unint64_t *v91;
  uint64_t v92;
  uint64_t *v93;
  unint64_t *v94;
  uint64_t v95;
  uint64_t *v96;
  unint64_t *v97;
  uint64_t v98;
  uint64_t *v99;
  unint64_t *v100;
  _BOOL4 v101;
  unint64_t *v102;
  _BOOL4 v103;
  unint64_t v104;
  unint64_t v105;
  uint64_t v106;
  uint64_t v107;
  dispatch_function_t function;
  void *context;
  dispatch_once_t *predicate;
  BOOL v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  uint64_t v115;
  _BOOL4 v116;
  BOOL v117;
  unint64_t v118;
  unint64_t v119;
  unint64_t v120;
  _BOOL4 v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  _BOOL4 v126;
  BOOL v127;
  unint64_t v128;
  unint64_t v129;
  unint64_t v130;
  _BOOL4 v131;
  unint64_t v132;
  BOOL v133;
  _BOOL4 v134;
  BOOL v135;
  unint64_t v136;
  unint64_t v137;
  unint64_t v138;
  _BOOL4 v139;
  unint64_t v140;
  uint64_t v141;
  unint64_t v142;
  unint64_t v143;
  unint64_t v144;
  unsigned __int8 v145;
  uint64_t v146;
  BOOL v147;
  char v148;
  unint64_t *v149;
  unint64_t v150;
  unint64_t v151;
  unint64_t *v152;
  _BYTE v153[9];
  unsigned __int16 v154;
  unsigned __int16 v155;
  unsigned __int8 v156;
  unint64_t v157;
  _QWORD *v158;
  char *v159;
  unint64_t v160;
  uint64_t v161;
  _BOOL4 v162;
  BOOL v163;
  unint64_t v164;
  unint64_t v165;
  unint64_t v166;
  _BOOL4 v167;
  unint64_t v168;
  unint64_t v169;
  unint64_t v170;
  unint64_t v171;
  _BOOL4 v172;
  BOOL v173;
  unint64_t v174;
  unint64_t v175;
  unint64_t v176;
  _BOOL4 v177;
  unint64_t v178;
  BOOL v179;
  _BOOL4 v180;
  BOOL v181;
  unint64_t v182;
  unint64_t v183;
  unint64_t v184;
  _BOOL4 v185;
  unint64_t v186;
  uint64_t v187;
  unint64_t v188;
  unint64_t v189;
  unint64_t v190;
  unsigned __int8 v191;
  uint64_t v192;
  BOOL v193;
  char v194;
  unint64_t *v195;
  unint64_t v196;
  unint64_t v197;
  unint64_t *v198;
  char v199;
  _QWORD *v200;
  unsigned __int16 v201;
  unsigned __int16 v202;
  unsigned __int8 v203;
  unint64_t v204;
  _QWORD *v205;
  char *v206;
  unint64_t v207;
  unint64_t *v208;
  mach_port_context_t v209;
  unint64_t v210;
  unint64_t v211;
  unint64_t *v212;
  unsigned int v213;
  unsigned int v214;
  unsigned __int8 v215;
  _QWORD *v216;
  unsigned __int8 v217;
  _QWORD *v218;
  _BOOL4 v219;
  __int16 v220;
  unint64_t *v221;
  _BOOL4 v222;
  BOOL v223;
  char v224;
  unint64_t v225;
  unint64_t v226;
  __int16 v227;
  _QWORD *v228;
  unsigned __int16 v229;
  unsigned __int16 v230;
  unsigned __int8 v231;
  unsigned __int8 v232;
  unint64_t v233;
  unint64_t *v234;
  uint64_t v235;
  _BOOL4 v236;
  __int16 v237;
  unint64_t *v238;
  _BOOL4 v239;
  BOOL v240;
  char v241;
  unint64_t v242;
  unint64_t v243;
  __int16 v244;
  _QWORD *v245;
  unsigned __int16 v246;
  unsigned __int16 v247;
  unsigned __int8 v248;
  unsigned __int8 v249;
  unint64_t v250;
  unint64_t *v251;
  uint64_t v252;
  unint64_t StatusReg;
  unint64_t v254;
  unint64_t v255;
  char *v256;
  uint64_t v257;
  uint64_t v258;
  unsigned __int16 v259;
  unint64_t v260;
  unint64_t *v261;
  unint64_t v262;
  char *v263;
  uint64_t v264;
  uint64_t v265;
  unsigned __int16 v266;
  unint64_t v267;
  unint64_t *v268;
  uint64_t v269;
  unint64_t v270;
  unint64_t v271;
  unint64_t v272;
  char v273;
  unsigned __int8 v274;
  unsigned __int8 v275;
  uint64_t v276;
  unint64_t v277;
  unint64_t v278;
  unint64_t v279;
  char v280;
  unsigned __int8 v281;
  unsigned __int8 v282;
  uint64_t v283;
  unint64_t v284;
  char v285;
  unint64_t v286;
  unint64_t v287;
  char v288;
  unsigned __int8 v289;
  unsigned __int8 v290;
  uint64_t v291;
  unint64_t v292;
  char v293;
  unint64_t v294;
  unint64_t v295;
  char v296;
  unsigned __int8 v297;
  unsigned __int8 v298;
  unint64_t v299;
  unint64_t v300;
  uint64_t v301;
  unint64_t v302;
  unint64_t v303;
  unint64_t v304;
  uint64_t v305;
  unint64_t v306;
  __int16 v307;
  unint64_t *v308;
  unsigned __int16 v309;
  unint64_t *v310;
  __int16 v311;
  unint64_t *v312;
  unsigned __int16 v313;
  unint64_t *v314;
  unint64_t v315;
  unint64_t v316;
  uint64_t v317;
  unint64_t v318;
  unsigned int v319;
  unint64_t v320;
  unint64_t v321;
  uint64_t v322;
  unint64_t v323;
  unsigned int v324;
  unint64_t v325;
  unint64_t v326;
  uint64_t v327;
  unint64_t v328;
  unsigned int v329;
  unint64_t v330;
  unint64_t v331;
  uint64_t v332;
  unint64_t v333;
  unsigned int v334;
  unint64_t v335;
  unint64_t v336;
  uint64_t v337;
  unint64_t v338;
  unsigned int v339;
  unint64_t v340;
  unint64_t v341;
  uint64_t v342;
  unint64_t v343;
  unsigned int v344;
  unint64_t v345;
  uint64_t v346;
  unint64_t v347;
  unint64_t v348;
  unint64_t *v349;
  unint64_t *v350;
  unint64_t v351;
  unint64_t v352;
  mach_port_context_t v353;

  v78 = a1;
  v77 = a2;
  v76 = a3;
  v75 = a4;
  v74 = a5;
  v73 = a6;
  v72 = 0;
  v71 = 0;
  v70 = 0;
  v69 = 0;
  v69 = *a1;
  v68 = 0;
  v66 = _dispatch_thread_getspecific(0x1CuLL);
  v64 = (v73 & 1) == 0;
  v13 = v74 + 8;
  v14 = v74 >= 0xFFFFFFFFFFFFFFF8;
  if (((v74 + 8) & 0xFFFFFFFFFFFF0000) != 0)
    v14 = 1;
  v67 = v74 + 8;
  v111 = v14;
  if (v14 || v13 >= 0x81u)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Absurd publen";
    qword_E4DA8 = v13;
    __break(1u);
    JUMPOUT(0x98FF0);
  }
  if (v77 == (_QWORD *)-3)
    v77 = v66;
  WORD1(v69) &= ~0x10u;
  if (v66)
  {
    v71 = v66[6];
    if (v71)
    {
      WORD1(v69) |= 1u;
      v67 = v74 + 16;
      v68 = v66[7];
      if (v68)
      {
        WORD1(v69) |= 0x10u;
        v67 = v74 + 24;
      }
    }
  }
  if (v77)
    v70 = v77[6];
  if (v70)
  {
    WORD1(v69) |= 0x200u;
    v67 += 8;
    v76 |= HIBYTE(v70);
  }
  if ((MEMORY[0xFFFFFC104] & 0x80) == 0)
    v76 |= 0x80uLL;
  v84 = v77;
  v83 = 2;
  v82 = 0;
  v81 = 0;
  if (v77)
    v82 = 0;
  v81 = _voucher_alloc(v82, v6, v7, v8, v9, v10, v11, v12);
  if (v84)
  {
    v80 = ~v83;
    if (*((_DWORD *)v84 + 8))
    {
      v79 = 0;
      if (v84[5])
        v59 = (_DWORD *)v84[5];
      else
        v59 = v84;
      v79 = v59;
      object = v59;
      os_retain(v59);
      v81[5] = v59;
      *((_DWORD *)v81 + 8) = v79[8];
      *((_BYTE *)v81 + 72) = v81[9] & 0xFE | v79[18] & 1;
    }
    if ((v80 & 2) != 0)
    {
      v81[6] = v84[6];
      v81[7] = v84[7];
      v81[8] = v84[8];
    }
  }
  v65 = v81;
  v106 = v76;
  v105 = 0;
  v104 = 0;
  v103 = 0;
  v102 = (unint64_t *)&_voucher_aid_next;
  while (1)
  {
    v15 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v102) : __ldxr(v102);
    v105 = v15;
    v104 = v15 + 1;
    if (!v15 || (v104 & 0xF) == 0)
      break;
    if (_os_atomic_mo_has_release(0))
      v103 = __stlxr(v104, v102) == 0;
    else
      v103 = __stxr(v104, v102) == 0;
    if (v103)
      goto LABEL_40;
  }
  __clrex();
  _voucher_activity_id_allocate_slow();
LABEL_40:
  v101 = v103;
  v72 = v105 & 0xFFFFFFFFFFFFFFLL | ((unint64_t)v106 << 56);
  v81[6] = v72;
  v65[7] = _voucher_unique_pid;
  v65[8] = v70;
  predicate = &_firehose_task_buffer_pred;
  context = 0;
  function = (dispatch_function_t)_firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(predicate, context, function);
  v107 = _firehose_task_buffer;
  v58 = 1;
  if (_firehose_task_buffer)
    v58 = *(_DWORD *)(v107 + 1552) == -1;
  if (!v58)
  {
    v112 = v76;
    if ((MEMORY[0xFFFFFC104] & 0x80) != 0 && (v112 & 0x80) == 0)
      v113 = mach_continuous_approximate_time();
    else
      v113 = mach_continuous_time();
    v62 = v113;
    for (i = 0; i < 2; ++i)
    {
      if (voucher_activity_create_with_data_2_streams[i] == 3)
      {
        v16 = voucher_activity_create_with_data_2_streams[i];
        v205 = (_QWORD *)_firehose_task_buffer;
        v204 = v62;
        v203 = v16;
        v202 = v67;
        v201 = 0;
        v200 = 0;
        v199 = 1;
        v198 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v16 << 7) + 640);
        v197 = 0;
        v196 = 0;
        v195 = 0;
        v194 = 0;
        v193 = 0;
        v192 = 0;
        v191 = 0;
        v190 = 0;
        v189 = *v198;
        v190 = v189;
        v188 = v189;
        v197 = v189;
        do
        {
          while (1)
          {
            while (1)
            {
              v196 = v197;
              v191 = BYTE4(v197);
              v57 = 0;
              if (BYTE4(v197))
                v57 = v191 != 255;
              if (v57)
              {
                v216 = v205;
                v215 = v191;
                v195 = &v205[512 * (unint64_t)v191];
                v234 = v195;
                v233 = v204;
                v232 = v203;
                v231 = 0;
                v230 = v202;
                v229 = v201;
                v228 = v200;
                v227 = 24;
                v226 = 0;
                v225 = 0;
                v224 = 0;
                v223 = 0;
                v223 = (v204 - v195[1]) >> 48 == 0;
                v222 = 0;
                v221 = v195;
                do
                {
                  if (_os_atomic_mo_has_acquire(0))
                    v17 = __ldaxr(v221);
                  else
                    v17 = __ldxr(v221);
                  v226 = v17;
                  if (!v17 || (HIWORD(v226) & 0x1FF) != (unint64_t)v232)
                  {
                    __clrex();
                    v235 = 0;
                    goto LABEL_85;
                  }
                  v225 = v226;
                  v314 = &v226;
                  v313 = v230 + v229 + 24;
                  if ((unsigned __int16)v226 + v313 <= WORD1(v226) && v223)
                  {
                    if (v231 > (int)BYTE5(v225))
                      BYTE5(v225) = v231;
                    if ((((_BYTE)v230 + 24) & 7) != 0)
                      v56 = ((v230 + 24) & 0x1FFF8) + 8;
                    else
                      v56 = v230 + 24;
                    v225 += v56;
                    v225 -= (unint64_t)v229 << 16;
                    v225 += 0x100000000;
                    v220 = 16;
                    v312 = &v225;
                    v311 = 40;
                    if ((unsigned __int16)v225 + 40 > WORD1(v225))
                      HIBYTE(v225) |= 1u;
                    v224 = 0;
                  }
                  else
                  {
                    HIBYTE(v225) |= 1u;
                    v224 = 1;
                  }
                  if (_os_atomic_mo_has_release(0))
                    v222 = __stlxr(v225, v221) == 0;
                  else
                    v222 = __stxr(v225, v221) == 0;
                }
                while (!v222);
                v219 = v222;
                if ((v224 & 1) != 0)
                {
                  if (BYTE4(v225))
                    v235 = 0;
                  else
                    v235 = -1;
                }
                else
                {
                  if (v228)
                    *v228 = (char *)v234 + WORD1(v225);
                  v235 = (unsigned __int16)v226;
                }
LABEL_85:
                v192 = v235;
                if (v235 >= 1)
                {
                  v187 = 0;
                  StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  v187 = *(_QWORD *)(StatusReg - 8);
                  v261 = v195;
                  v260 = v204;
                  v259 = v202;
                  v258 = v187;
                  v257 = v192;
                  v256 = (char *)v195 + v192;
                  v260 = (v204 - v195[1]) | ((unint64_t)v202 << 48);
                  v255 = v260;
                  *(unint64_t *)((char *)v195 + v192 + 16) = v260;
                  *((_QWORD *)v256 + 1) = v258;
                  v206 = v256;
                  goto LABEL_133;
                }
                if (v192 < 0)
                  firehose_buffer_ring_enqueue((mach_port_context_t)v205, BYTE4(v197));
                BYTE4(v196) = 0;
              }
              if ((v199 & 1) != 0 || ((v194 & 1) == 0 || (v197 & 0x400000000000) == 0) && !(BYTE5(v197) >> 7))
                break;
              if ((BYTE5(v197) & 0x3Fu) + 1 > 0x3E)
                v55 = 63;
              else
                v55 = (BYTE5(v197) & 0x3F) + 1;
              BYTE5(v196) = BYTE5(v196) & 0xC0 | v55 & 0x3F;
              v186 = v197;
              v185 = 0;
              v18 = v198;
              v183 = v196;
              v182 = v196;
              v184 = v196;
              v19 = v197;
              v20 = v196;
              do
                v21 = __ldaxr(v18);
              while (v21 == v19 && __stlxr(v20, v18));
              if (v21 != v19)
                v186 = v21;
              v181 = v21 == v19;
              v185 = v21 == v19;
              v197 = v186;
              v180 = v185;
              v193 = v21 == v19;
              if (v21 == v19)
              {
                v275 = v203;
                v274 = v191;
                v273 = v194 & 1;
                v272 = v197;
                v271 = v196;
                v270 = v203 | ((unint64_t)v191 << 8);
                v269 = v194 & 1;
                v344 = 772145156;
                v343 = v270;
                v342 = v269;
                v341 = v197;
                v340 = v196;
                if (MEMORY[0xFFFFFC100])
                  kdebug_trace(v344, v343, v342, v341, v340);
                v206 = 0;
                goto LABEL_133;
              }
            }
            if (!(_DWORD)v197)
              break;
            if ((v199 & 1) != 0)
              LODWORD(v196) = v196 | 1;
            else
              LODWORD(v196) = v196 | 2;
            v179 = v196 == v197;
            v54 = 1;
            if (v196 != v197)
            {
              v178 = v197;
              v177 = 0;
              v22 = v198;
              v175 = v196;
              v174 = v196;
              v176 = v196;
              v23 = v197;
              v24 = v196;
              do
                v25 = __ldaxr(v22);
              while (v25 == v23 && __stlxr(v24, v22));
              if (v25 != v23)
                v178 = v25;
              v173 = v25 == v23;
              v177 = v25 == v23;
              v197 = v178;
              v172 = v177;
              v54 = v25 == v23;
            }
            v193 = v54;
            if (v54)
            {
              v290 = v203;
              v289 = v191;
              v288 = v194 & 1;
              v287 = v197;
              v286 = v196;
              v285 = v199 & 1;
              v284 = v203 | ((unint64_t)v191 << 8);
              v283 = v194 & 1 | (2 * (v199 & 1));
              v334 = 772145160;
              v333 = v284;
              v332 = v283;
              v331 = v197;
              v330 = v196;
              if (MEMORY[0xFFFFFC100])
                kdebug_trace(v334, v333, v332, v331, v330);
              _dispatch_firehose_gate_wait((uint64_t)v198, v196, 0x10000);
              v194 = 1;
              v171 = 0;
              v170 = *v198;
              v171 = v170;
              v169 = v170;
              v197 = v170;
            }
          }
          v214 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v196) = v214 & 0xFFFFFFFC;
          v168 = v197;
          v167 = 0;
          v26 = v198;
          v165 = v196;
          v164 = v196;
          v166 = v196;
          v27 = v197;
          v28 = v196;
          do
            v29 = __ldaxr(v26);
          while (v29 == v27 && __stlxr(v28, v26));
          if (v29 != v27)
            v168 = v29;
          v163 = v29 == v27;
          v167 = v29 == v27;
          v197 = v168;
          v162 = v167;
          v193 = v29 == v27;
        }
        while (v29 != v27);
        v160 = v204;
        LOWORD(v161) = v202;
        WORD1(v161) = v201;
        WORD2(v161) = v203;
        HIWORD(v161) = ((1 << v203) & 0x13) != 0;
        BYTE6(v161) = (((1 << v203) & 0x13) != 0) | (2 * (*((_BYTE *)v205 + 1569) & 1));
        BYTE6(v161) = BYTE6(v161) & 0xFB | (4 * (v199 & 1));
        v302 = v204;
        v301 = v161;
        v300 = v197;
        v299 = v196;
        v324 = 772145164;
        v323 = v204;
        v322 = v161;
        v321 = v197;
        v320 = v196;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(v324, v323, v322, v321, v320);
        v206 = firehose_buffer_tracepoint_reserve_slow(v205, &v160, v200);
LABEL_133:
        v63 = (unint64_t *)v206;
      }
      else
      {
        v30 = voucher_activity_create_with_data_2_streams[i];
        v158 = (_QWORD *)_firehose_task_buffer;
        v157 = v62;
        v156 = v30;
        v155 = v67;
        v154 = 0;
        v153[8] = 0;
        *(_QWORD *)v153 = v64;
        v152 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v30 << 7) + 640);
        v151 = *(_QWORD *)&v153[1];
        v150 = *(_QWORD *)&v153[1];
        v149 = *(unint64_t **)&v153[1];
        v148 = 0;
        v147 = 0;
        v146 = *(_QWORD *)&v153[1];
        v145 = 0;
        v144 = *(_QWORD *)&v153[1];
        v143 = *v152;
        v144 = v143;
        v142 = v143;
        v151 = v143;
        do
        {
          while (1)
          {
            while (1)
            {
              v150 = v151;
              v145 = BYTE4(v151);
              v53 = 0;
              if (BYTE4(v151))
                v53 = v145 != 255;
              if (v53)
              {
                v218 = v158;
                v217 = v145;
                v149 = &v158[512 * (unint64_t)v145];
                v251 = v149;
                v250 = v157;
                v249 = v156;
                v248 = 0;
                v247 = v155;
                v246 = v154;
                v245 = *(_QWORD **)&v153[1];
                v244 = 24;
                v243 = 0;
                v242 = 0;
                v241 = 0;
                v240 = 0;
                v240 = (v157 - v149[1]) >> 48 == 0;
                v239 = 0;
                v238 = v149;
                do
                {
                  if (_os_atomic_mo_has_acquire(0))
                    v31 = __ldaxr(v238);
                  else
                    v31 = __ldxr(v238);
                  v243 = v31;
                  if (!v31 || (HIWORD(v243) & 0x1FF) != (unint64_t)v249)
                  {
                    __clrex();
                    v252 = 0;
                    goto LABEL_167;
                  }
                  v242 = v243;
                  v310 = &v243;
                  v309 = v247 + v246 + 24;
                  if ((unsigned __int16)v243 + v309 <= WORD1(v243) && v240)
                  {
                    if (v248 > (int)BYTE5(v242))
                      BYTE5(v242) = v248;
                    if ((((_BYTE)v247 + 24) & 7) != 0)
                      v52 = ((v247 + 24) & 0x1FFF8) + 8;
                    else
                      v52 = v247 + 24;
                    v242 += v52;
                    v242 -= (unint64_t)v246 << 16;
                    v242 += 0x100000000;
                    v237 = 16;
                    v308 = &v242;
                    v307 = 40;
                    if ((unsigned __int16)v242 + 40 > WORD1(v242))
                      HIBYTE(v242) |= 1u;
                    v241 = 0;
                  }
                  else
                  {
                    HIBYTE(v242) |= 1u;
                    v241 = 1;
                  }
                  if (_os_atomic_mo_has_release(0))
                    v239 = __stlxr(v242, v238) == 0;
                  else
                    v239 = __stxr(v242, v238) == 0;
                }
                while (!v239);
                v236 = v239;
                if ((v241 & 1) != 0)
                {
                  if (BYTE4(v242))
                    v252 = 0;
                  else
                    v252 = -1;
                }
                else
                {
                  if (v245)
                    *v245 = (char *)v251 + WORD1(v242);
                  v252 = (unsigned __int16)v243;
                }
LABEL_167:
                v146 = v252;
                if (v252 >= 1)
                {
                  v141 = 0;
                  v254 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
                  v141 = *(_QWORD *)(v254 - 8);
                  v268 = v149;
                  v267 = v157;
                  v266 = v155;
                  v265 = v141;
                  v264 = v146;
                  v263 = (char *)v149 + v146;
                  v267 = (v157 - v149[1]) | ((unint64_t)v155 << 48);
                  v262 = v267;
                  *(unint64_t *)((char *)v149 + v146 + 16) = v267;
                  *((_QWORD *)v263 + 1) = v265;
                  v159 = v263;
                  goto LABEL_215;
                }
                if (v146 < 0)
                  firehose_buffer_ring_enqueue((mach_port_context_t)v158, BYTE4(v151));
                BYTE4(v150) = 0;
              }
              if ((v153[0] & 1) != 0 || ((v148 & 1) == 0 || (v151 & 0x400000000000) == 0) && !(BYTE5(v151) >> 7))
                break;
              if ((BYTE5(v151) & 0x3Fu) + 1 > 0x3E)
                v51 = 63;
              else
                v51 = (BYTE5(v151) & 0x3F) + 1;
              BYTE5(v150) = BYTE5(v150) & 0xC0 | v51 & 0x3F;
              v140 = v151;
              v139 = 0;
              v32 = v152;
              v137 = v150;
              v136 = v150;
              v138 = v150;
              v33 = v151;
              v34 = v150;
              do
                v35 = __ldaxr(v32);
              while (v35 == v33 && __stlxr(v34, v32));
              if (v35 != v33)
                v140 = v35;
              v135 = v35 == v33;
              v139 = v35 == v33;
              v151 = v140;
              v134 = v139;
              v147 = v35 == v33;
              if (v35 == v33)
              {
                v282 = v156;
                v281 = v145;
                v280 = v148 & 1;
                v279 = v151;
                v278 = v150;
                v277 = v156 | ((unint64_t)v145 << 8);
                v276 = v148 & 1;
                v339 = 772145156;
                v338 = v277;
                v337 = v276;
                v336 = v151;
                v335 = v150;
                if (MEMORY[0xFFFFFC100])
                  kdebug_trace(v339, v338, v337, v336, v335);
                v159 = 0;
                goto LABEL_215;
              }
            }
            if (!(_DWORD)v151)
              break;
            if ((v153[0] & 1) != 0)
              LODWORD(v150) = v150 | 1;
            else
              LODWORD(v150) = v150 | 2;
            v133 = v150 == v151;
            v50 = 1;
            if (v150 != v151)
            {
              v132 = v151;
              v131 = 0;
              v36 = v152;
              v129 = v150;
              v128 = v150;
              v130 = v150;
              v37 = v151;
              v38 = v150;
              do
                v39 = __ldaxr(v36);
              while (v39 == v37 && __stlxr(v38, v36));
              if (v39 != v37)
                v132 = v39;
              v127 = v39 == v37;
              v131 = v39 == v37;
              v151 = v132;
              v126 = v131;
              v50 = v39 == v37;
            }
            v147 = v50;
            if (v50)
            {
              v298 = v156;
              v297 = v145;
              v296 = v148 & 1;
              v295 = v151;
              v294 = v150;
              v293 = v153[0] & 1;
              v292 = v156 | ((unint64_t)v145 << 8);
              v291 = v148 & 1 | (2 * (v153[0] & 1));
              v329 = 772145160;
              v328 = v292;
              v327 = v291;
              v326 = v151;
              v325 = v150;
              if (MEMORY[0xFFFFFC100])
                kdebug_trace(v329, v328, v327, v326, v325);
              _dispatch_firehose_gate_wait((uint64_t)v152, v150, 0x10000);
              v148 = 1;
              v125 = 0;
              v124 = *v152;
              v125 = v124;
              v123 = v124;
              v151 = v124;
            }
          }
          v213 = _dispatch_thread_getspecific(3uLL);
          LODWORD(v150) = v213 & 0xFFFFFFFC;
          v122 = v151;
          v121 = 0;
          v40 = v152;
          v119 = v150;
          v118 = v150;
          v120 = v150;
          v41 = v151;
          v42 = v150;
          do
            v43 = __ldaxr(v40);
          while (v43 == v41 && __stlxr(v42, v40));
          if (v43 != v41)
            v122 = v43;
          v117 = v43 == v41;
          v121 = v43 == v41;
          v151 = v122;
          v116 = v121;
          v147 = v43 == v41;
        }
        while (v43 != v41);
        v114 = v157;
        LOWORD(v115) = v155;
        WORD1(v115) = v154;
        WORD2(v115) = v156;
        HIWORD(v115) = ((1 << v156) & 0x13) != 0;
        BYTE6(v115) = (((1 << v156) & 0x13) != 0) | (2 * (*((_BYTE *)v158 + 1569) & 1));
        BYTE6(v115) = BYTE6(v115) & 0xFB | (4 * (v153[0] & 1));
        v306 = v157;
        v305 = v115;
        v304 = v151;
        v303 = v150;
        v319 = 772145164;
        v318 = v157;
        v317 = v115;
        v316 = v151;
        v315 = v150;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(v319, v318, v317, v316, v315);
        v159 = firehose_buffer_tracepoint_reserve_slow(v158, &v114, *(_QWORD **)&v153[1]);
LABEL_215:
        v63 = (unint64_t *)v159;
      }
      if (v63)
      {
        v60 = v63 + 3;
        if (v71)
        {
          v100 = v63 + 3;
          v99 = &v71;
          v98 = 8;
          __memcpy_chk(v60, &v71, 8, -1);
          v60 = &v100[(unint64_t)v98 / 8];
        }
        if (v68)
        {
          v97 = v60;
          v96 = &v68;
          v95 = 8;
          __memcpy_chk(v60, &v68, 8, -1);
          v60 = &v97[(unint64_t)v95 / 8];
        }
        if (v70)
        {
          v94 = v60;
          v93 = &v70;
          v92 = 8;
          __memcpy_chk(v60, &v70, 8, -1);
          v60 = &v94[(unint64_t)v92 / 8];
        }
        v91 = v60;
        v90 = &v72;
        v89 = 8;
        __memcpy_chk(v60, &v72, 8, -1);
        v88 = &v91[(unint64_t)v89 / 8];
        v87 = v75;
        v86 = v74;
        __memcpy_chk(&v91[(unint64_t)v89 / 8], v75, v74, -1);
        v210 = v69;
        v209 = _firehose_task_buffer;
        v208 = v63;
        v212 = v63;
        v211 = (unint64_t)v63 & 0xFFFFFFFFFFFFF000;
        v207 = (unint64_t)v63 & 0xFFFFFFFFFFFFF000;
        v351 = v69;
        v350 = (unint64_t *)((unint64_t)v63 & 0xFFFFFFFFFFFFF000);
        v349 = v63;
        v348 = 0;
        v347 = v69;
        atomic_store(v69, v63);
        v48 = v350;
        v346 = 0x100000000;
        v49 = *v350;
        do
        {
          v44 = v49;
          do
            v45 = __ldaxr(v48);
          while (v45 == v49 && __stlxr(v49 - 0x100000000, v48));
          v49 = v45;
        }
        while (v45 != v44);
        v345 = v45;
        v348 = v45;
        v47 = 0;
        if (BYTE4(v45) == 1)
          v47 = HIBYTE(v348) & 1;
        if ((v47 & 1) != 0)
        {
          v353 = v209;
          v352 = v207;
          firehose_buffer_ring_enqueue(v209, (v207 - v209) >> 12);
        }
      }
    }
  }
  *v78 = v69;
  return v65;
}

_QWORD *voucher_activity_create_with_data(unint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  return voucher_activity_create_with_data_2(a1, a2, a3, a4, a5, 0);
}

_QWORD *voucher_activity_create_with_location(unint64_t *a1, _QWORD *a2, uint64_t a3, uint64_t a4)
{
  _QWORD v5[4];

  v5[3] = a1;
  v5[2] = a2;
  v5[1] = a3;
  v5[0] = a4;
  return voucher_activity_create_with_data(a1, a2, a3, (uint64_t)v5, 8uLL);
}

uint64_t voucher_get_activity_id_and_creator(_QWORD *a1, _QWORD *a2, _QWORD *a3)
{
  _QWORD *v6;

  v6 = a1;
  if (a1 == (_QWORD *)-3)
    v6 = _dispatch_thread_getspecific(0x1CuLL);
  if (v6)
  {
    if (a2)
      *a2 = v6[7];
    if (a3)
      *a3 = v6[8];
    return v6[6];
  }
  else
  {
    if (a2)
      *a2 = 0;
    if (a3)
      *a3 = 0;
    return 0;
  }
}

uint64_t voucher_get_activity_id(_QWORD *a1, _QWORD *a2)
{
  return voucher_get_activity_id_and_creator(a1, 0, a2);
}

void voucher_activity_flush(unsigned __int8 a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  unint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  mach_port_context_t v17;
  unint64_t *v18;
  _BOOL4 v19;
  BOOL v20;
  char v21;
  unint64_t v22;
  unint64_t v23;
  __int16 v24;
  _QWORD *v25;
  unsigned __int16 v26;
  unsigned __int16 v27;
  unsigned __int8 v28;
  unsigned __int8 v29;
  uint64_t v30;
  unint64_t v31;
  uint64_t v32;
  __int16 v33;
  unint64_t *v34;
  unsigned __int16 v35;
  unint64_t *v36;

  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(&_firehose_task_buffer_pred, 0, (dispatch_function_t)_firehose_task_buffer_init);
  v11 = 1;
  if (_firehose_task_buffer)
    v11 = *(_DWORD *)(_firehose_task_buffer + 1552) == -1;
  if (!v11)
  {
    v17 = _firehose_task_buffer;
    v16 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)a1 << 7) + 640);
    v15 = *v16;
    if (BYTE4(*v16) && BYTE4(v15) != 255)
    {
      v31 = _firehose_task_buffer + ((unint64_t)BYTE4(v15) << 12);
      v30 = -1;
      v29 = a1;
      v28 = 0;
      v27 = 1;
      v26 = 0;
      v25 = 0;
      v24 = 24;
      v23 = 0;
      v22 = 0;
      v20 = (unint64_t)(-1 - *(_QWORD *)(v31 + 8)) >> 48 == 0;
      v18 = (unint64_t *)v31;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v8 = __ldaxr(v18);
        else
          v8 = __ldxr(v18);
        v23 = v8;
        if (!v8 || (HIWORD(v23) & 0x1FF) != (unint64_t)v29)
        {
          __clrex();
          v32 = 0;
          goto LABEL_38;
        }
        v22 = v23;
        v36 = &v23;
        v35 = v27 + v26 + 24;
        if ((unsigned __int16)v23 + v35 <= WORD1(v23) && v20)
        {
          if (v28 > (int)BYTE5(v22))
            BYTE5(v22) = v28;
          if ((((_BYTE)v27 + 24) & 7) != 0)
            v10 = ((v27 + 24) & 0x1FFF8) + 8;
          else
            v10 = v27 + 24;
          v22 += v10;
          v22 -= (unint64_t)v26 << 16;
          v22 += 0x100000000;
          v34 = &v22;
          v33 = 40;
          if ((unsigned __int16)v22 + 40 > WORD1(v22))
            HIBYTE(v22) |= 1u;
          v21 = 0;
        }
        else
        {
          HIBYTE(v22) |= 1u;
          v21 = 1;
        }
        if (_os_atomic_mo_has_release(0))
          v19 = __stlxr(v22, v18) == 0;
        else
          v19 = __stxr(v22, v18) == 0;
      }
      while (!v19);
      if ((v21 & 1) != 0)
      {
        if (BYTE4(v22))
          v32 = 0;
        else
          v32 = -1;
      }
      else
      {
        if (v25)
          *v25 = v31 + WORD1(v22);
        v32 = (unsigned __int16)v23;
      }
LABEL_38:
      v13 = v32;
      if (v32 < 0)
        firehose_buffer_ring_enqueue(v17, BYTE4(v15));
      if (v13 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v13;
        __break(1u);
        JUMPOUT(0x9B6E0);
      }
      v14 = v15;
      BYTE4(v14) = 0;
      do
        v9 = __ldaxr(v16);
      while (v9 == v15 && __stlxr(v14, v16));
    }
    else
    {
      firehose_buffer_force_connect(_firehose_task_buffer, a2, a3, a4, a5, a6, a7, a8);
    }
  }
}

unint64_t voucher_activity_trace_v_2(unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6, int a7)
{
  unint64_t v7;
  unint64_t *v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t *v12;
  unint64_t v13;
  unint64_t v14;
  unint64_t v15;
  unint64_t *v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;
  uint64_t v20;
  uint64_t v21;
  unint64_t v22;
  BOOL v23;
  unint64_t v24;
  char v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char v30;
  unint64_t v31;
  unint64_t v32;
  char v34;
  unint64_t *v35;
  unint64_t v36;
  BOOL v37;
  char v38;
  int v39;
  BOOL v40;
  uint64_t v41;
  uint64_t v42;
  BOOL v43;
  _WORD v44[2];
  uint64_t v45;
  uint64_t v46;
  _QWORD *v47;
  unint64_t v48;
  unint64_t *v49;
  uint64_t v50;
  unint64_t v51;
  uint64_t v52;
  unint64_t *v53;
  BOOL v54;
  uint64_t v55;
  __int16 v56;
  unint64_t v57;
  int v58;
  unint64_t v59;
  unint64_t v60;
  uint64_t *v61;
  unint64_t v62;
  unint64_t v63;
  unsigned __int8 v64;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  unint64_t *v71;
  uint64_t v72;
  _WORD *v73;
  unint64_t *v74;
  uint64_t v75;
  uint64_t *v76;
  unint64_t *v77;
  uint64_t v78;
  uint64_t *v79;
  unint64_t *v80;
  uint64_t v81;
  uint64_t (*v82)();
  void *v83;
  dispatch_once_t *v84;
  char v85;
  char v86;
  unint64_t v87;
  uint64_t v88;
  _BOOL4 v89;
  BOOL v90;
  unint64_t v91;
  unint64_t v92;
  unint64_t v93;
  _BOOL4 v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;
  _BOOL4 v99;
  BOOL v100;
  unint64_t v101;
  unint64_t v102;
  unint64_t v103;
  _BOOL4 v104;
  unint64_t v105;
  BOOL v106;
  _BOOL4 v107;
  BOOL v108;
  unint64_t v109;
  unint64_t v110;
  unint64_t v111;
  _BOOL4 v112;
  unint64_t v113;
  unint64_t v114;
  unint64_t v115;
  unint64_t v116;
  unint64_t v117;
  unsigned __int8 v118;
  uint64_t v119;
  BOOL v120;
  char v121;
  unint64_t *v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t *v125;
  BOOL v126;
  uint64_t *v127;
  unsigned __int16 v128;
  unsigned __int16 v129;
  unsigned __int8 v130;
  unint64_t v131;
  _QWORD *v132;
  unint64_t *v133;
  unint64_t v134;
  unint64_t *v135;
  uint64_t v136;
  unint64_t v137;
  uint64_t *v138;
  _QWORD *v139;
  unint64_t v140;
  unint64_t *v141;
  unint64_t v142;
  unint64_t *v143;
  unsigned int v144;
  unsigned __int8 v145;
  _QWORD *v146;
  _BOOL4 v147;
  __int16 v148;
  unint64_t *v149;
  _BOOL4 v150;
  BOOL v151;
  char v152;
  unint64_t v153;
  unint64_t v154;
  __int16 v155;
  uint64_t *v156;
  unsigned __int16 v157;
  unsigned __int16 v158;
  unsigned __int8 v159;
  unsigned __int8 v160;
  unint64_t v161;
  unint64_t *v162;
  uint64_t v163;
  unint64_t StatusReg;
  unint64_t v165;
  unint64_t *v166;
  uint64_t v167;
  unint64_t v168;
  unsigned __int16 v169;
  unint64_t v170;
  unint64_t *v171;
  uint64_t v172;
  unint64_t v173;
  unint64_t v174;
  unint64_t v175;
  char v176;
  unsigned __int8 v177;
  unsigned __int8 v178;
  uint64_t v179;
  unint64_t v180;
  BOOL v181;
  unint64_t v182;
  unint64_t v183;
  char v184;
  unsigned __int8 v185;
  unsigned __int8 v186;
  unint64_t v187;
  unint64_t v188;
  uint64_t v189;
  unint64_t v190;
  __int16 v191;
  unint64_t *v192;
  unsigned __int16 v193;
  unint64_t *v194;
  unint64_t v195;
  unint64_t v196;
  uint64_t v197;
  unint64_t v198;
  unsigned int v199;
  unint64_t v200;
  unint64_t v201;
  uint64_t v202;
  unint64_t v203;
  unsigned int v204;
  unint64_t v205;
  unint64_t v206;
  uint64_t v207;
  unint64_t v208;
  unsigned int v209;
  unint64_t v210;
  uint64_t v211;
  unint64_t v212;
  unint64_t v213;
  unint64_t *v214;
  unint64_t *v215;
  unint64_t v216;
  unint64_t v217;
  mach_port_context_t v218;

  v64 = a1;
  v63 = a2;
  v62 = a3;
  v61 = a4;
  v60 = a5;
  v59 = a6;
  v58 = a7;
  v57 = a2;
  v56 = 24;
  v55 = 4080;
  v54 = (a7 & 1) == 0;
  v84 = &_firehose_task_buffer_pred;
  v83 = 0;
  v82 = _firehose_task_buffer_init;
  if (_firehose_task_buffer_pred != -1)
    dispatch_once_f(v84, v83, (dispatch_function_t)v82);
  v81 = _firehose_task_buffer;
  v43 = 1;
  if (_firehose_task_buffer)
    v43 = *(_DWORD *)(v81 + 1552) == -1;
  if (v43)
    return 0;
  v53 = 0;
  v52 = 0;
  v51 = 0;
  v50 = 0;
  v49 = 0;
  v48 = v60;
  v47 = _dispatch_thread_getspecific(0x1CuLL);
  v46 = 0;
  v139 = v47;
  v138 = &v46;
  if (&v46)
  {
    if (v139)
      v42 = v139[7];
    else
      v42 = 0;
    *v138 = v42;
  }
  if (v139)
    v41 = v139[6];
  else
    v41 = 0;
  v52 = v41;
  if (v41)
  {
    WORD1(v57) |= 1u;
    v48 += 8;
  }
  if ((v57 & 0x100000) != 0)
  {
    if (v46)
      v48 += 8;
    else
      WORD1(v57) &= ~0x10u;
  }
  else
  {
    v46 = 0;
  }
  if (v59)
  {
    WORD1(v57) |= 0x100u;
    v48 += 4;
  }
  if (v48 + v59 + 24 >= 0xFF1)
  {
    v45 = v48 + v59 + 24;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Log is too large";
    qword_E4DA8 = v45;
    __break(1u);
    JUMPOUT(0x9BAACLL);
  }
  v132 = (_QWORD *)_firehose_task_buffer;
  v131 = v62;
  v130 = v64;
  v129 = v48;
  v128 = v59;
  v127 = &v50;
  v126 = v54;
  v125 = (unint64_t *)(_firehose_task_buffer + ((unint64_t)v64 << 7) + 640);
  v124 = 0;
  v123 = 0;
  v122 = 0;
  v121 = 0;
  v120 = 0;
  v119 = 0;
  v118 = 0;
  v117 = 0;
  v116 = *v125;
  v117 = v116;
  v115 = v116;
  v124 = v116;
  do
  {
    while (1)
    {
      while (1)
      {
        v123 = v124;
        v118 = BYTE4(v124);
        v40 = 0;
        if (BYTE4(v124))
          v40 = v118 != 255;
        if (v40)
        {
          v146 = v132;
          v145 = v118;
          v122 = &v132[512 * (unint64_t)v118];
          v162 = v122;
          v161 = v131;
          v160 = v130;
          v159 = 0;
          v158 = v129;
          v157 = v128;
          v156 = v127;
          v155 = 24;
          v154 = 0;
          v153 = 0;
          v152 = 0;
          v151 = 0;
          v151 = (v131 - v122[1]) >> 48 == 0;
          v150 = 0;
          v149 = v122;
          do
          {
            if (_os_atomic_mo_has_acquire(0))
              v7 = __ldaxr(v149);
            else
              v7 = __ldxr(v149);
            v154 = v7;
            if (!v7 || (HIWORD(v154) & 0x1FF) != (unint64_t)v160)
            {
              __clrex();
              v163 = 0;
              goto LABEL_59;
            }
            v153 = v154;
            v194 = &v154;
            v193 = v158 + v157 + 24;
            if ((unsigned __int16)v154 + v193 <= WORD1(v154) && v151)
            {
              if (v159 > (int)BYTE5(v153))
                BYTE5(v153) = v159;
              if ((((_BYTE)v158 + 24) & 7) != 0)
                v39 = ((v158 + 24) & 0x1FFF8) + 8;
              else
                v39 = v158 + 24;
              v153 += v39;
              v153 -= (unint64_t)v157 << 16;
              v153 += 0x100000000;
              v148 = 16;
              v192 = &v153;
              v191 = 40;
              if ((unsigned __int16)v153 + 40 > WORD1(v153))
                HIBYTE(v153) |= 1u;
              v152 = 0;
            }
            else
            {
              HIBYTE(v153) |= 1u;
              v152 = 1;
            }
            if (_os_atomic_mo_has_release(0))
              v150 = __stlxr(v153, v149) == 0;
            else
              v150 = __stxr(v153, v149) == 0;
          }
          while (!v150);
          v147 = v150;
          if ((v152 & 1) != 0)
          {
            if (BYTE4(v153))
              v163 = 0;
            else
              v163 = -1;
          }
          else
          {
            if (v156)
              *v156 = (uint64_t)v162 + WORD1(v153);
            v163 = (unsigned __int16)v154;
          }
LABEL_59:
          v119 = v163;
          if (v163 >= 1)
          {
            v114 = 0;
            StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
            v114 = *(_QWORD *)(StatusReg - 8);
            v171 = v122;
            v170 = v131;
            v169 = v129;
            v168 = v114;
            v167 = v119;
            v166 = (unint64_t *)((char *)v122 + v119);
            v170 = v131 - v122[1];
            v170 |= (unint64_t)v129 << 48;
            v165 = v170;
            *(unint64_t *)((char *)v122 + v119 + 16) = v170;
            v166[1] = v168;
            v133 = v166;
            goto LABEL_107;
          }
          if (v119 < 0)
            firehose_buffer_ring_enqueue((mach_port_context_t)v132, BYTE4(v124));
          BYTE4(v123) = 0;
        }
        if (v126 || ((v121 & 1) == 0 || (v124 & 0x400000000000) == 0) && !(BYTE5(v124) >> 7))
          break;
        if ((BYTE5(v124) & 0x3Fu) + 1 > 0x3E)
          v38 = 63;
        else
          v38 = (BYTE5(v124) & 0x3F) + 1;
        BYTE5(v123) = BYTE5(v123) & 0xC0 | v38 & 0x3F;
        v113 = v124;
        v112 = 0;
        v8 = v125;
        v110 = v123;
        v109 = v123;
        v111 = v123;
        v9 = v124;
        v10 = v123;
        do
          v11 = __ldaxr(v8);
        while (v11 == v9 && __stlxr(v10, v8));
        if (v11 != v9)
          v113 = v11;
        v108 = v11 == v9;
        v112 = v11 == v9;
        v124 = v113;
        v107 = v112;
        v120 = v11 == v9;
        if (v11 == v9)
        {
          v178 = v130;
          v177 = v118;
          v176 = v121 & 1;
          v175 = v124;
          v174 = v123;
          v173 = v130 | ((unint64_t)v118 << 8);
          v172 = v121 & 1;
          v209 = 772145156;
          v208 = v173;
          v207 = v172;
          v206 = v124;
          v205 = v123;
          if (MEMORY[0xFFFFFC100])
            kdebug_trace(v209, v208, v207, v206, v205);
          v133 = 0;
          goto LABEL_107;
        }
      }
      if (!(_DWORD)v124)
        break;
      if (v126)
        LODWORD(v123) = v123 | 1;
      else
        LODWORD(v123) = v123 | 2;
      v106 = v123 == v124;
      v37 = 1;
      if (v123 != v124)
      {
        v105 = v124;
        v104 = 0;
        v12 = v125;
        v102 = v123;
        v101 = v123;
        v103 = v123;
        v13 = v124;
        v14 = v123;
        do
          v15 = __ldaxr(v12);
        while (v15 == v13 && __stlxr(v14, v12));
        if (v15 != v13)
          v105 = v15;
        v100 = v15 == v13;
        v104 = v15 == v13;
        v124 = v105;
        v99 = v104;
        v37 = v15 == v13;
      }
      v120 = v37;
      if (v37)
      {
        v186 = v130;
        v185 = v118;
        v184 = v121 & 1;
        v183 = v124;
        v182 = v123;
        v181 = v126;
        v180 = v130 | ((unint64_t)v118 << 8);
        v179 = v121 & 1 | (2 * v126);
        v204 = 772145160;
        v203 = v180;
        v202 = v179;
        v201 = v124;
        v200 = v123;
        if (MEMORY[0xFFFFFC100])
          kdebug_trace(v204, v203, v202, v201, v200);
        _dispatch_firehose_gate_wait((uint64_t)v125, v123, 0x10000);
        v121 = 1;
        v98 = 0;
        v97 = *v125;
        v98 = v97;
        v96 = v97;
        v124 = v97;
      }
    }
    v144 = _dispatch_thread_getspecific(3uLL);
    LODWORD(v123) = v144 & 0xFFFFFFFC;
    v95 = v124;
    v94 = 0;
    v16 = v125;
    v92 = v123;
    v91 = v123;
    v93 = v123;
    v17 = v124;
    v18 = v123;
    do
      v19 = __ldaxr(v16);
    while (v19 == v17 && __stlxr(v18, v16));
    if (v19 != v17)
      v95 = v19;
    v90 = v19 == v17;
    v94 = v19 == v17;
    v124 = v95;
    v89 = v94;
    v120 = v19 == v17;
  }
  while (v19 != v17);
  v87 = v131;
  LOWORD(v88) = v129;
  WORD1(v88) = v128;
  WORD2(v88) = v130;
  HIWORD(v88) = ((1 << v130) & 0x13) != 0;
  BYTE6(v88) = (((1 << v130) & 0x13) != 0) | (2 * (*((_BYTE *)v132 + 1569) & 1));
  BYTE6(v88) = BYTE6(v88) & 0xFB | (4 * v126);
  v190 = v131;
  v189 = v88;
  v188 = v124;
  v187 = v123;
  v199 = 772145164;
  v198 = v131;
  v197 = v88;
  v196 = v124;
  v195 = v123;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v199, v198, v197, v196, v195);
  v133 = (unint64_t *)firehose_buffer_tracepoint_reserve_slow(v132, &v87, v127);
LABEL_107:
  v53 = v133;
  if (!v133)
    return 0;
  v49 = v53 + 3;
  if (v52)
  {
    v80 = v49;
    v79 = &v52;
    v78 = 8;
    __memcpy_chk(v49, &v52, 8, -1);
    v49 = &v80[(unint64_t)v78 / 8];
  }
  if (v46)
  {
    v77 = v49;
    v76 = &v46;
    v75 = 8;
    __memcpy_chk(v49, &v46, 8, -1);
    v49 = &v77[(unint64_t)v75 / 8];
  }
  if (v59)
  {
    v143 = v53;
    v142 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000;
    v51 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000;
    v44[0] = v50 - ((unsigned __int16)v53 & 0xF000);
    v44[1] = v59;
    v74 = v49;
    v73 = v44;
    v72 = 4;
    __memcpy_chk(v49, v44, 4, -1);
    v49 = (unint64_t *)((char *)v74 + v72);
  }
  while (v60)
  {
    v20 = *v61;
    v21 = v61[1];
    v71 = v49;
    v70 = v20;
    v69 = v21;
    __memcpy_chk(v49, v20, v21, -1);
    v49 = (unint64_t *)((char *)v71 + v69);
    v22 = v61[1];
    v23 = v60 >= v22;
    v24 = v60 - v22;
    v25 = !v23;
    v60 = v24;
    v86 = v25;
    if ((v25 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0x9C92CLL);
    }
    v61 += 2;
  }
  while (v59)
  {
    v26 = *v61;
    v27 = v61[1];
    v68 = v50;
    v67 = v26;
    v66 = v27;
    __memcpy_chk(v50, v26, v27, -1);
    v50 = v68 + v66;
    v28 = v61[1];
    v23 = v59 >= v28;
    v29 = v59 - v28;
    v30 = !v23;
    v59 = v29;
    v85 = v30;
    if ((v30 & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid arguments";
      __break(1u);
      JUMPOUT(0x9C9ECLL);
    }
    v61 += 2;
  }
  v137 = v57;
  v136 = _firehose_task_buffer;
  v135 = v53;
  v141 = v53;
  v140 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000;
  v134 = (unint64_t)v53 & 0xFFFFFFFFFFFFF000;
  v216 = v57;
  v215 = (unint64_t *)((unint64_t)v53 & 0xFFFFFFFFFFFFF000);
  v214 = v53;
  v213 = 0;
  v212 = v57;
  atomic_store(v57, v53);
  v35 = v215;
  v211 = 0x100000000;
  v36 = *v215;
  do
  {
    v31 = v36;
    do
      v32 = __ldaxr(v35);
    while (v32 == v36 && __stlxr(v36 - 0x100000000, v35));
    v36 = v32;
  }
  while (v32 != v31);
  v210 = v32;
  v213 = v32;
  v34 = 0;
  if (BYTE4(v32) == 1)
    v34 = HIBYTE(v213) & 1;
  if ((v34 & 1) != 0)
  {
    v218 = v136;
    v217 = v134;
    firehose_buffer_ring_enqueue(v218, (v134 - v218) >> 12);
  }
  return v57;
}

unint64_t voucher_activity_trace_v(unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t *a4, unint64_t a5, unint64_t a6)
{
  return voucher_activity_trace_v_2(a1, a2, a3, a4, a5, a6, 0);
}

unint64_t voucher_activity_trace(unsigned __int8 a1, unint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  uint64_t v6[6];
  unsigned __int8 v7;

  v7 = a1;
  v6[5] = a2;
  v6[4] = a3;
  v6[3] = a4;
  v6[2] = a5;
  v6[0] = a4;
  v6[1] = a5;
  return voucher_activity_trace_v(a1, a2, a3, v6, a5, 0);
}

unint64_t format_recipe_detail(uint64_t a1, uint64_t a2, unint64_t a3, unint64_t a4, const char *a5, unint64_t a6)
{
  unint64_t v6;
  size_t v8;
  size_t v9;
  size_t v10;
  uint64_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  size_t v33;
  size_t v34;
  size_t v35;
  size_t v36;
  size_t v37;
  size_t v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  int v47;
  int v48;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  unint64_t v54;
  unint64_t v55;
  unint64_t v56;

  v51 = a4;
  if (a5)
  {
    if (a3 <= a4)
      v38 = 0;
    else
      v38 = a3 - a4;
    v48 = __snprintf_chk((char *)(a2 + a4), v38, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
    if (v48 >= 0)
    {
      if (v48 <= v38)
        v36 = v48;
      else
        v36 = v38;
      v37 = v36;
    }
    else
    {
      v37 = 0;
    }
    v51 += v37;
  }
  if (a3 <= v51)
    v35 = 0;
  else
    v35 = a3 - v51;
  v47 = __snprintf_chk((char *)(a2 + v51), v35, 0, 0xFFFFFFFFFFFFFFFFLL, "Key: %u, ", *(_DWORD *)a1);
  if (v47 >= 0)
  {
    if (v47 <= v35)
      v33 = v47;
    else
      v33 = v35;
    v34 = v33;
  }
  else
  {
    v34 = 0;
  }
  v52 = v51 + v34;
  if (a3 <= v52)
    v32 = 0;
  else
    v32 = a3 - v52;
  v46 = __snprintf_chk((char *)(a2 + v52), v32, 0, 0xFFFFFFFFFFFFFFFFLL, "Command: %u, ", *(_DWORD *)(a1 + 4));
  if (v46 >= 0)
  {
    if (v46 <= v32)
      v30 = v46;
    else
      v30 = v32;
    v31 = v30;
  }
  else
  {
    v31 = 0;
  }
  v53 = v52 + v31;
  if (a3 <= v53)
    v29 = 0;
  else
    v29 = a3 - v53;
  v45 = __snprintf_chk((char *)(a2 + v53), v29, 0, 0xFFFFFFFFFFFFFFFFLL, "Previous voucher: 0x%x, ", *(_DWORD *)(a1 + 8));
  if (v45 >= 0)
  {
    if (v45 <= v29)
      v27 = v45;
    else
      v27 = v29;
    v28 = v27;
  }
  else
  {
    v28 = 0;
  }
  v54 = v53 + v28;
  if (a3 <= v54)
    v26 = 0;
  else
    v26 = a3 - v54;
  v44 = __snprintf_chk((char *)(a2 + v54), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "Content size: %u\n", *(_DWORD *)(a1 + 12));
  if (v44 >= 0)
  {
    if (v44 <= v26)
      v24 = v44;
    else
      v24 = v26;
    v25 = v24;
  }
  else
  {
    v25 = 0;
  }
  v55 = v54 + v25;
  if (*(_DWORD *)a1 == 2)
  {
    if (a5)
    {
      if (a3 <= v55)
        v23 = 0;
      else
        v23 = a3 - v55;
      v43 = __snprintf_chk((char *)(a2 + v55), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v43 >= 0)
      {
        if (v43 <= v23)
          v21 = v43;
        else
          v21 = v23;
        v22 = v21;
      }
      else
      {
        v22 = 0;
      }
      v55 += v22;
    }
    if (a3 <= v55)
      v20 = 0;
    else
      v20 = a3 - v55;
    v42 = __snprintf_chk((char *)(a2 + v55), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "IMPORTANCE INFO: %s", (const char *)(a1 + 16));
    if (v42 >= 0)
    {
      if (v42 <= v20)
        v18 = v42;
      else
        v18 = v20;
      v19 = v18;
    }
    else
    {
      v19 = 0;
    }
    v56 = v55 + v19;
  }
  else if (*(_DWORD *)a1 == 3)
  {
    if (a5)
    {
      if (a3 <= v55)
        v17 = 0;
      else
        v17 = a3 - v55;
      v41 = __snprintf_chk((char *)(a2 + v55), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", a5);
      if (v41 >= 0)
      {
        if (v41 <= v17)
          v15 = v41;
        else
          v15 = v17;
        v16 = v15;
      }
      else
      {
        v16 = 0;
      }
      v55 += v16;
    }
    if (a3 <= v55)
      v14 = 0;
    else
      v14 = a3 - v55;
    v40 = __snprintf_chk((char *)(a2 + v55), v14, 0, 0xFFFFFFFFFFFFFFFFLL, "RESOURCE ACCOUNTING INFO: %s", (const char *)(a1 + 16));
    if (v40 >= 0)
    {
      if (v40 <= v14)
        v12 = v40;
      else
        v12 = v14;
      v13 = v12;
    }
    else
    {
      v13 = 0;
    }
    v56 = v55 + v13;
  }
  else
  {
    v11 = a1 + 16;
    if (*(unsigned int *)(a1 + 12) >= a6)
      v6 = format_hex_data(a5, "Recipe Contents", v11, a6, a2, a3, v55);
    else
      v6 = format_hex_data(a5, "Recipe Contents", v11, *(unsigned int *)(a1 + 12), a2, a3, v55);
    v56 = v6;
  }
  if (*(_BYTE *)(a2 + v56 - 1) != 10)
  {
    if (a3 <= v56)
      v10 = 0;
    else
      v10 = a3 - v56;
    v39 = __snprintf_chk((char *)(a2 + v56), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "\n");
    if (v39 >= 0)
    {
      if (v39 <= v10)
        v8 = v39;
      else
        v8 = v10;
      v9 = v8;
    }
    else
    {
      v9 = 0;
    }
    v56 += v9;
  }
  return v56;
}

uint64_t voucher_mach_msg_fill_aux(uint64_t a1, unsigned int a2)
{
  __int128 v3;
  __int128 v4;
  char *v5;

  v5 = (char *)_dispatch_thread_getspecific(0x1CuLL);
  if (v5 && *((_QWORD *)v5 + 6))
  {
    if (a2 >= 0x28uLL)
    {
      *(_DWORD *)a1 = 40;
      *(_DWORD *)(a1 + 4) = 0;
      *(_QWORD *)&v3 = 59821818;
      *((_QWORD *)&v3 + 1) = *((_QWORD *)v5 + 6);
      v4 = *(_OWORD *)(v5 + 56);
      *(_OWORD *)(a1 + 8) = v3;
      *(_OWORD *)(a1 + 24) = v4;
      return 40;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

void __spoils<X1,X2,X3,X4,X5,X6,X7,X8,X9,X10,X11,X12,X13,X14,X15,X16,X17,Q0,Q1,Q2,Q3,Q4,Q5,Q6,Q7,Q16,Q17,Q18,Q19,Q20,Q21,Q22,Q23,Q24,Q25,Q26,Q27,Q28,Q29,Q30,Q31> _voucher_activity_id_allocate_slow()
{
  unint64_t v0;
  _BOOL4 v1;
  uint64_t v2;
  uint64_t activity_id;
  kern_return_t v4;
  uint64_t v5;

  v4 = 0;
  activity_id = 0;
  v4 = mach_generate_activity_id(mach_task_self_, 1, &activity_id);
  if (v4)
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not generate an activity ID";
    qword_E4DA8 = v4;
    __break(1u);
    JUMPOUT(0x9D884);
  }
  activity_id *= 16;
  activity_id &= 0xFFFFFFFFFFFFFFuLL;
  if (!activity_id)
    activity_id = 1;
  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v0 = __ldaxr((unint64_t *)&_voucher_aid_next);
    else
      v0 = __ldxr((unint64_t *)&_voucher_aid_next);
    v5 = v0;
    v2 = activity_id;
    if (!v0)
    {
      v2 = activity_id + 1;
      v5 = activity_id;
    }
    if (_os_atomic_mo_has_release(0))
      v1 = __stlxr(v2, (unint64_t *)&_voucher_aid_next) == 0;
    else
      v1 = __stxr(v2, (unint64_t *)&_voucher_aid_next) == 0;
  }
  while (!v1);
}

uint64_t _firehose_task_buffer_init()
{
  pid_t v0;
  uint64_t result;
  uint64_t v2;
  __int128 buffer;
  __int128 v4;
  __int128 v5;
  uint64_t v6;

  v6 = 0;
  v5 = 0u;
  v4 = 0u;
  buffer = 0u;
  v0 = getpid();
  result = proc_pidinfo(v0, 17, 1uLL, &buffer, 56);
  if ((_DWORD)result != 56)
  {
    if (!(_DWORD)result)
    {
      v2 = **(int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (error)";
      qword_E4DA8 = v2;
      __break(1u);
      JUMPOUT(0x9DAA4);
    }
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Unable to get the unique pid (size)";
    qword_E4DA8 = (int)result;
    __break(1u);
    JUMPOUT(0x9DAE8);
  }
  _voucher_unique_pid = v4;
  if (_voucher_libtrace_hooks)
  {
    result = (*(uint64_t (**)(void))(_voucher_libtrace_hooks + 8))();
    if ((_DWORD)result)
    {
      result = (uint64_t)firehose_buffer_create(result, _voucher_unique_pid, (_dispatch_memory_warn & 1) != 0);
      _firehose_task_buffer = result;
      if (*(uint64_t *)_voucher_libtrace_hooks >= 4)
      {
        if (*(_QWORD *)(_voucher_libtrace_hooks + 32))
          return (*(uint64_t (**)(uint64_t, uint64_t))(_voucher_libtrace_hooks + 32))(_firehose_task_buffer + 2048, 2048);
      }
    }
  }
  return result;
}

unint64_t format_hex_data(const char *a1, const char *a2, uint64_t a3, unint64_t a4, uint64_t a5, unint64_t a6, unint64_t a7)
{
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  char v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  int v27;
  int v28;
  int v29;
  int v30;
  int v31;
  unint64_t v32;
  int v33;
  unint64_t i;
  unint64_t v36;
  char v41[17];

  v36 = a7;
  if (a2)
  {
    if (a6 <= a7)
      v26 = 0;
    else
      v26 = a6 - a7;
    v33 = __snprintf_chk((char *)(a5 + a7), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s:\n", a1, a2);
    if (v33 >= 0)
    {
      if (v33 <= v26)
        v24 = v33;
      else
        v24 = v26;
      v25 = v24;
    }
    else
    {
      v25 = 0;
    }
    v36 += v25;
  }
  v32 = -1;
  for (i = 0; i < a4; ++i)
  {
    v32 = i % 0x10;
    if (!(i % 0x10))
    {
      if (i)
      {
        if (a6 <= v36)
          v23 = 0;
        else
          v23 = a6 - v36;
        v31 = __snprintf_chk((char *)(a5 + v36), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
        if (v31 >= 0)
        {
          if (v31 <= v23)
            v21 = v31;
          else
            v21 = v23;
          v22 = v21;
        }
        else
        {
          v22 = 0;
        }
        v36 += v22;
      }
      if (a6 <= v36)
        v20 = 0;
      else
        v20 = a6 - v36;
      v30 = __snprintf_chk((char *)(a5 + v36), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s  %04lx ", a1, i);
      if (v30 >= 0)
      {
        if (v30 <= v20)
          v18 = v30;
        else
          v18 = v20;
        v19 = v18;
      }
      else
      {
        v19 = 0;
      }
      v36 += v19;
    }
    if (a6 <= v36)
      v17 = 0;
    else
      v17 = a6 - v36;
    v29 = __snprintf_chk((char *)(a5 + v36), v17, 0, 0xFFFFFFFFFFFFFFFFLL, " %02x", *(unsigned __int8 *)(a3 + i));
    if (v29 >= 0)
    {
      if (v29 <= v17)
        v15 = v29;
      else
        v15 = v17;
      v16 = v15;
    }
    else
    {
      v16 = 0;
    }
    v36 += v16;
    if (*(unsigned __int8 *)(a3 + i) >= 0x20u && *(unsigned __int8 *)(a3 + i) <= 0x7Eu)
      v14 = *(_BYTE *)(a3 + i);
    else
      v14 = 46;
    v41[v32] = v14;
  }
  v41[v32 + 1] = 0;
  if (i % 0x10)
  {
    while (i % 0x10)
    {
      if (a6 <= v36)
        v13 = 0;
      else
        v13 = a6 - v36;
      v28 = __snprintf_chk((char *)(a5 + v36), v13, 0, 0xFFFFFFFFFFFFFFFFLL, "   ");
      if (v28 >= 0)
      {
        if (v28 <= v13)
          v11 = v28;
        else
          v11 = v13;
        v12 = v11;
      }
      else
      {
        v12 = 0;
      }
      v36 += v12;
      ++i;
    }
    if (a6 <= v36)
      v10 = 0;
    else
      v10 = a6 - v36;
    v27 = __snprintf_chk((char *)(a5 + v36), v10, 0, 0xFFFFFFFFFFFFFFFFLL, "  %s\n", v41);
    if (v27 >= 0)
    {
      if (v27 <= v10)
        v8 = v27;
      else
        v8 = v10;
      v9 = v8;
    }
    else
    {
      v9 = 0;
    }
    v36 += v9;
  }
  return v36;
}

_QWORD *firehose_buffer_create(mach_port_name_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned __int16 j;
  unint64_t i;
  kern_return_t v18;
  mach_vm_address_t address;
  _QWORD *v20;
  mach_vm_address_t v21;
  uint64_t v22;
  uint64_t v23;
  mach_port_name_t v24;
  uint64_t v26;
  uint64_t v27;
  kern_return_t v28;
  kern_return_t v29;
  uint64_t v30;
  kern_return_t v31;
  mach_port_name_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  kern_return_t v37;
  mach_port_options_t options;
  mach_port_name_t name;
  _QWORD *v40;
  int v41;
  int v42;

  v24 = a1;
  v23 = a2;
  v22 = a3;
  v21 = 0;
  v20 = 0;
  address = vm_page_size;
  if (0x4000 % vm_page_size)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Invalid values for MADVISE_CHUNK_COUNT / CHUNK_SIZE";
    qword_E4DA8 = 0x4000;
    __break(1u);
    JUMPOUT(0x9E4B4);
  }
  v18 = mach_vm_map(mach_task_self_, &address, 0x40000uLL, 0, 1308622851, 0, 0, 0, 3, 7, 2u);
  if (v18)
  {
    if (v18 != 3)
    {
      v27 = v18;
      v26 = 346;
      _dispatch_bug(v26, v27, v3, v4, v5, v6, v7, v8);
    }
    v32 = v24;
    v31 = 0;
    v31 = mach_port_deallocate(mach_task_self_, v24);
    if (v31 == -301)
    {
      v30 = -301;
      qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
      qword_E4DA8 = -301;
      __break(1u);
      JUMPOUT(0x9E5E4);
    }
    v29 = v31;
    v34 = v31;
    v33 = 91;
    if (v31)
      _dispatch_bug(v33, v34, v9, v10, v11, v12, v13, v14);
    v28 = v29;
    return 0;
  }
  else
  {
    v20 = (_QWORD *)address;
    v21 = address;
    *(_DWORD *)(address + 1548) = v24;
    *(_DWORD *)(v21 + 1544) = getpid();
    *(_QWORD *)(v21 + 1536) = v23;
    v42 = 49;
    v41 = 5;
    v40 = v20;
    name = 0;
    options.flags = 51;
    options.mpl.mpl_qlimit = 5;
    options.reserved[1] = 0;
    options.reserved[0] = 0;
    v37 = 0;
    v37 = mach_port_construct(mach_task_self_, &options, (mach_port_context_t)v20, &name);
    if (v37)
    {
      if (v37 == -301)
      {
        v36 = -301;
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0x9E748);
      }
      v35 = v37;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
      qword_E4DA8 = v37;
      __break(1u);
      JUMPOUT(0x9E784);
    }
    *(_DWORD *)(v21 + 1560) = name;
    *(_DWORD *)(v21 + 264) = 20180226;
    *(_QWORD *)(v21 + 512) = v22;
    for (i = 0; i < 7; ++i)
    {
      if (i != 3)
        *(_BYTE *)(v21 + (i << 7) + 644) = -1;
    }
    firehose_buffer_update_limits_unlocked(v20);
    *(_QWORD *)(v21 + 520) = 31;
    for (j = 0; j <= 3u; ++j)
      *(_WORD *)(v21 + 2 * j) = j + 1;
    *(_QWORD *)(v21 + 464) = 4;
    *(_WORD *)(v21 + 320) = 4;
    *(_QWORD *)(v21 + 256) = 0x40000;
    return v20;
  }
}

_QWORD *firehose_buffer_update_limits_unlocked(_QWORD *result)
{
  unint64_t v1;
  unint64_t v2;
  unint64_t *v3;
  unint64_t v4;
  int v5;
  __int16 v6;
  unsigned __int16 v7;
  int v8;
  uint64_t v9;
  unsigned __int16 v10;
  unint64_t i;
  unsigned __int16 v12;
  unsigned __int16 v13;
  __int16 v14;
  unsigned __int16 v15;
  uint64_t v16;
  uint64_t v17;

  v16 = result[64];
  v15 = 0;
  v14 = 0;
  for (i = 0; i < 7; ++i)
  {
    if (BYTE4(result[16 * i + 80]) != 255)
    {
      if (((1 << i) & 0x13) != 0)
        ++v15;
      else
        ++v14;
    }
  }
  if ((v16 & 1) != 0)
  {
    if ((v16 & 2) != 0)
      v12 = 4 * v14 + 1 + v15;
    else
      v12 = v14 + 3 + v15;
  }
  else if ((v16 & 2) != 0)
  {
    v12 = 6 * v14 + 1 + 3 * v15;
  }
  else
  {
    v12 = 2 * (v14 + v15) + 1;
  }
  v10 = vm_page_size / 0x1000;
  if (v10 > 1u)
  {
    if (v12 % (int)v10)
      v8 = v12 + v10 - v12 % (int)v10;
    else
      LOWORD(v8) = v12;
    v12 = v8;
  }
  if (v12 <= 4u)
    v7 = 4;
  else
    v7 = v12;
  v13 = v7;
  if ((v16 & 1) == 0)
  {
    if (v7 <= 8u)
      v6 = 8;
    else
      v6 = v7;
    v13 = v6;
  }
  LOWORD(v9) = v13 - 1;
  if (3 * v13 / 8 <= 2 * v15)
    LOWORD(v5) = 2 * v15;
  else
    v5 = 3 * v13 / 8;
  WORD1(v9) = v5;
  HIDWORD(v9) = (v13 + 1);
  v17 = result[66];
  result[66] = v9;
  if (v17 != v9)
  {
    v3 = result + 56;
    v4 = result[56];
    do
    {
      v1 = v4;
      do
        v2 = __ldaxr(v3);
      while (v2 == v4 && __stlxr(v4 + v9 - v17, v3));
      v4 = v2;
    }
    while (v2 != v1);
  }
  return result;
}

mach_vm_address_t firehose_buffer_get_logging_prefs(uint64_t a1, mach_vm_size_t *a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  BOOL v21;
  int logging_prefs;
  kern_return_t v23;
  kern_return_t v24;
  mach_vm_address_t address;
  mach_vm_size_t size;
  mach_port_name_t v27;
  int v28;
  mach_vm_size_t *v29;
  uint64_t v30;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v30 = a1;
  v29 = a2;
  v28 = 0;
  v28 = *(_DWORD *)(a1 + 1548);
  v27 = 0;
  size = 0;
  address = 0;
  v21 = 0;
  if (v28)
    v21 = v28 != -1;
  if (v21)
  {
    logging_prefs = firehose_send_get_logging_prefs(v28, &v27, &size);
    if (logging_prefs)
    {
      if (logging_prefs != 268435459)
      {
        if (logging_prefs == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9EE74);
        }
        v37 = logging_prefs;
        v36 = 601;
        _dispatch_bug(v36, v37, v2, v3, v4, v5, v6, v7);
      }
      *v29 = 0;
      return 0;
    }
    else
    {
      v23 = mach_vm_map(mach_task_self_, &address, size, 0, 1, v27, 0, 0, 1, 1, 2u);
      if (v23 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0x9EF68);
      }
      v35 = v23;
      v34 = 612;
      if (v23)
      {
        _dispatch_bug(v34, v35, v8, v9, v10, v11, v12, v13);
        address = 0;
        size = 0;
      }
      v24 = mach_port_deallocate(mach_task_self_, v27);
      if (v24 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0x9F034);
      }
      v33 = v24;
      v32 = 618;
      if (v24)
        _dispatch_bug(v32, v33, v14, v15, v16, v17, v18, v19);
      *v29 = size;
      return address;
    }
  }
  else
  {
    *v29 = 0;
    return 0;
  }
}

BOOL firehose_buffer_should_send_strings(mach_port_context_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v16;
  mach_port_t v17;
  int should_send_strings;
  mach_port_t v19;
  mach_port_context_t v20;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;

  v20 = a1;
  v19 = 0;
  v19 = *(_DWORD *)(a1 + 1552);
  should_send_strings = 0;
  v17 = 0;
  if (v19 != -1)
  {
    if (v19)
    {
      should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings)
        return v17 != 0;
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9F194);
        }
        v25 = should_send_strings;
        v24 = 642;
        _dispatch_bug(v24, v25, v8, a4, a5, a6, a7, a8);
      }
    }
    v19 = firehose_client_reconnect(v20, v19, 0, a4, a5, a6, a7, a8);
    v16 = 0;
    if (v19)
      v16 = v19 != -1;
    if (v16)
    {
      should_send_strings = firehose_send_should_send_strings(v19, &v17);
      if (!should_send_strings)
        return v17 != 0;
      if (should_send_strings != 268435459)
      {
        if (should_send_strings == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9F2C8);
        }
        v23 = should_send_strings;
        v22 = 654;
        _dispatch_bug(v22, v23, v9, v10, v11, v12, v13, v14);
      }
    }
    return 0;
  }
  return 0;
}

uint64_t firehose_client_reconnect(mach_port_context_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _BOOL4 v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int *v15;
  unsigned int v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  unsigned int v41;
  unsigned int v42;
  unsigned int *v44;
  unsigned int v45;
  int k;
  int m;
  int j;
  memory_object_offset_t offset;
  memory_object_size_t size;
  vm_prot_t permission;
  mach_port_name_t v52;
  int i;
  _BYTE v54[5];
  memory_object_size_t v55;
  mach_port_t v56;
  mach_port_t object_handle;
  unsigned int v58;
  unsigned __int8 v59;
  int v60;
  mach_port_context_t v61;
  uint64_t v62;
  uint64_t v63;
  kern_return_t v64;
  kern_return_t v65;
  uint64_t v66;
  kern_return_t v67;
  mach_port_name_t v68;
  uint64_t v69;
  uint64_t v70;
  kern_return_t v71;
  kern_return_t v72;
  uint64_t v73;
  kern_return_t v74;
  mach_port_name_t v75;
  uint64_t v76;
  uint64_t v77;
  kern_return_t v78;
  kern_return_t v79;
  uint64_t v80;
  kern_return_t v81;
  mach_port_name_t v82;
  uint64_t v83;
  uint64_t v84;
  kern_return_t v85;
  kern_return_t v86;
  uint64_t v87;
  kern_return_t v88;
  mach_port_name_t name;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  uint64_t v93;
  kern_return_t v94;
  mach_port_options_t options;
  mach_port_name_t v96;
  mach_port_context_t context;
  int v98;
  int v99;
  _BOOL4 v100;
  BOOL v101;
  unsigned int v102;
  unsigned int v103;
  unsigned int v104;
  _BOOL4 v105;
  unsigned int v106;
  unsigned int v107;
  unsigned int *v108;
  mach_port_context_t v109;
  uint64_t v110;
  uint64_t v111;
  uint64_t v112;
  _BOOL8 v113;
  uint64_t v114;
  uint64_t v115;
  uint64_t v116;
  uint64_t v117;
  uint64_t v118;
  kern_return_t v119;
  mach_port_context_t v120;
  mach_port_name_t v121;
  kern_return_t v122;
  mach_port_context_t v123;
  mach_port_name_t v124;
  unsigned int v125;
  unsigned int v126;
  unsigned int v127;
  int v128;
  int v129;
  int v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int *v134;
  BOOL v135;
  unsigned int v136;
  unsigned int v137;
  int v138[2];

  v61 = a1;
  v60 = a2;
  v59 = a3;
  v58 = 0;
  object_handle = 0;
  v56 = 0;
  v55 = 0;
  v54[4] = 0;
  *(_DWORD *)v54 = a2 != 0;
  v117 = *(unsigned int *)(a1 + 1548);
  v116 = 157;
  if (!v117)
    _dispatch_abort(v116, 0, a3, a4, a5, a6, a7, a8);
  v115 = *(unsigned int *)(v61 + 1560);
  v114 = 158;
  if (!v115)
    _dispatch_abort(v114, 0, a3, a4, a5, a6, a7, a8);
  v8 = *(_QWORD *)(v61 + 1536) != 0;
  v113 = *(_QWORD *)(v61 + 1536) != 0;
  v112 = 159;
  if (!v8)
    _dispatch_abort(v112, v113, a3, a4, a5, a6, a7, a8);
  v108 = (unsigned int *)(v61 + 1564);
  v125 = _dispatch_thread_getspecific(3uLL);
  v107 = v125 & 0xFFFFFFFC;
  v106 = 0;
  v15 = (unsigned int *)(v61 + 1564);
  v103 = v125 & 0xFFFFFFFC;
  v102 = v125 & 0xFFFFFFFC;
  v104 = v125 & 0xFFFFFFFC;
  do
    v16 = __ldaxr(v15);
  while (!v16 && __stlxr(v125 & 0xFFFFFFFC, v15));
  if (v16)
    v106 = v16;
  v101 = v16 == 0;
  v105 = v16 == 0;
  v100 = v105;
  if (v16)
    _dispatch_unfair_lock_lock_slow(v108, 0x10000);
  v58 = *(_DWORD *)(v61 + 4 * v59 + 1552);
  if (v58 == v60 && v58 != -1)
  {
    if ((v54[0] & 1) != 0)
    {
      for (i = 0; i <= 1; ++i)
      {
        v52 = 0;
        v52 = *(_DWORD *)(v61 + 4 * i + 1552);
        v111 = v52;
        v110 = 171;
        if (!v52)
          _dispatch_abort(v110, v111, v9, v10, v11, v12, v13, v14);
        v124 = v52;
        v123 = v61;
        v122 = mach_port_destruct(mach_task_self_, v52, 0, v61);
        if (v122 == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9F64CLL);
        }
        name = v52;
        v88 = mach_port_deallocate(mach_task_self_, v52);
        if (v88 == -301)
        {
          v87 = -301;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9F6C0);
        }
        v86 = v88;
        v91 = v88;
        v90 = 91;
        if (v88)
          _dispatch_bug(v90, v91, v9, v10, v11, v12, v13, v14);
        v85 = v86;
        *(_DWORD *)(v61 + 4 * i + 1552) = 0;
      }
    }
    permission = 4194305;
    size = 0x40000;
    offset = v61;
    *(_DWORD *)&v54[1] = mach_make_memory_entry_64(mach_task_self_, &size, v61, 4194305, &object_handle, 0);
    if (!(size >> 18))
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Invalid size for the firehose buffer";
      qword_E4DA8 = size;
      __break(1u);
      JUMPOUT(0x9F7D4);
    }
    if (*(_DWORD *)&v54[1])
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
      qword_E4DA8 = *(int *)&v54[1];
      __break(1u);
      JUMPOUT(0x9F824);
    }
    if ((v54[0] & 1) != 0)
    {
      if (*(_QWORD *)(_voucher_libtrace_hooks + 24))
      {
        *(_DWORD *)&v54[1] = (*(uint64_t (**)(memory_object_offset_t *, memory_object_size_t *))(_voucher_libtrace_hooks + 24))(&offset, &size);
        if (!*(_DWORD *)&v54[1] && offset && size)
        {
          v55 = size;
          *(_DWORD *)&v54[1] = mach_make_memory_entry_64(mach_task_self_, &size, offset, permission, &v56, 0);
          if (*(_DWORD *)&v54[1])
          {
            qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to make memory port";
            qword_E4DA8 = *(int *)&v54[1];
            __break(1u);
            JUMPOUT(0x9F90CLL);
          }
          *(_DWORD *)&v54[1] = mach_vm_deallocate(mach_task_self_, offset, size);
          v63 = *(int *)&v54[1];
          v62 = 209;
          if (*(_DWORD *)&v54[1])
            _dispatch_bug(v62, v63, v17, v18, v19, v20, v21, v22);
        }
      }
    }
    for (j = 0; j <= 1; ++j)
    {
      v99 = 21;
      v98 = 1;
      context = v61;
      v96 = 0;
      options.flags = 23;
      options.mpl.mpl_qlimit = 1;
      options.reserved[1] = 0;
      options.reserved[0] = 0;
      v94 = 0;
      v94 = mach_port_construct(mach_task_self_, &options, v61, &v96);
      if (v94)
      {
        if (v94 == -301)
        {
          v93 = -301;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9FA70);
        }
        v92 = v94;
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to allocate mach port";
        qword_E4DA8 = v94;
        __break(1u);
        JUMPOUT(0x9FAACLL);
      }
      v138[j] = v96;
    }
    v58 = v138[v59];
    *(_DWORD *)&v54[1] = firehose_send_register(*(_DWORD *)(v61 + 1548), object_handle, 0x40000, v138[0], v138[1], *(_DWORD *)(v61 + 1560), v56, v55);
    if (*(_DWORD *)&v54[1])
    {
      if (*(_DWORD *)&v54[1] != 268435459)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Unable to register with logd";
        qword_E4DA8 = *(int *)&v54[1];
        __break(1u);
        JUMPOUT(0x9FEE8);
      }
      for (k = 0; k <= 1; ++k)
      {
        v121 = v138[k];
        v120 = v61;
        v119 = 0;
        v119 = mach_port_destruct(mach_task_self_, v121, 0, v61);
        if (v119 == -301)
        {
          v118 = -301;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9FC34);
        }
        v82 = v138[k];
        v81 = 0;
        v81 = mach_port_deallocate(mach_task_self_, v82);
        if (v81 == -301)
        {
          v80 = -301;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9FCB0);
        }
        v79 = v81;
        v84 = v81;
        v83 = 91;
        if (v81)
          _dispatch_bug(v83, v84, v23, v24, v25, v26, v27, v28);
        v78 = v79;
        *(_DWORD *)(v61 + 4 * k + 1552) = -1;
      }
      v58 = -1;
      v75 = object_handle;
      v74 = 0;
      v74 = mach_port_deallocate(mach_task_self_, object_handle);
      if (v74 == -301)
      {
        v73 = -301;
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0x9FD98);
      }
      v72 = v74;
      v77 = v74;
      v76 = 91;
      if (v74)
        _dispatch_bug(v76, v77, v29, v30, v31, v32, v33, v34);
      v71 = v72;
      if (v56)
      {
        v68 = v56;
        v67 = 0;
        v67 = mach_port_deallocate(mach_task_self_, v56);
        if (v67 == -301)
        {
          v66 = -301;
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0x9FE5CLL);
        }
        v65 = v67;
        v70 = v67;
        v69 = 91;
        if (v67)
          _dispatch_bug(v69, v70, v35, v36, v37, v38, v39, v40);
        v64 = v65;
      }
    }
    else
    {
      for (m = 0; m <= 1; ++m)
        *(_DWORD *)(v61 + 4 * m + 1552) = v138[m];
    }
  }
  v109 = v61 + 1564;
  v134 = (unsigned int *)(v61 + 1564);
  v133 = 0;
  v132 = 0;
  v136 = _dispatch_thread_getspecific(3uLL);
  v132 = v136 & 0xFFFFFFFC;
  v131 = 0;
  v44 = v134;
  v129 = 0;
  v128 = 0;
  v130 = 0;
  v45 = *v134;
  do
  {
    v41 = v45;
    do
      v42 = __ldaxr(v44);
    while (v42 == v45 && __stlxr(0, v44));
    v45 = v42;
  }
  while (v42 != v41);
  v127 = v42;
  v131 = v42;
  v126 = v42;
  v133 = v42;
  if (v42 == v132)
  {
    v135 = 0;
  }
  else
  {
    _dispatch_unfair_lock_unlock_slow((uint64_t)v134, v133);
    v137 = v133;
    v135 = (v133 & 2) != 0;
  }
  return v58;
}

void firehose_client_push_reply(uint64_t a1, int a2)
{
  qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: firehose_push_reply should never be sent to the buffer receive port";
  qword_E4DA8 = a2;
  __break(1u);
}

uint64_t sub_A00AC()
{
  unsigned int v1;

  return v1;
}

uint64_t firehose_client_push_notify_async(uint64_t a1, unint64_t a2, unint64_t a3, int a4)
{
  char *i;
  char *v9;

  for (i = (char *)_dispatch_thread_getspecific(0x17uLL); i; i = *(char **)i)
  {
    if (*((char **)i + 1) == "firehose")
    {
      v9 = i;
      goto LABEL_7;
    }
  }
  v9 = 0;
LABEL_7:
  firehose_client_merge_updates(*((_QWORD *)v9 + 2), 1, a2, a3, a4 != 0, 0);
  return 0;
}

void firehose_client_merge_updates(uint64_t a1, char a2, unint64_t a3, unint64_t a4, char a5, _QWORD *a6)
{
  unsigned __int8 *v6;
  int v7;
  unint64_t v8;
  unint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  unint64_t v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  unint64_t *v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t *v28;
  uint64_t v29;
  unint64_t *v30;
  _BOOL4 v31;
  unint64_t *v32;
  _BOOL4 v33;
  unint64_t *v34;
  _BOOL4 v35;
  unsigned __int16 v36;
  unsigned __int16 v37;
  __int16 v38;
  __int16 v39;
  unint64_t v40;
  char v43;

  v43 = a2 & 1;
  v37 = 0;
  v36 = 0;
  if ((a5 & 1) != 0 && !*(_BYTE *)(a1 + 1568))
  {
    v6 = (unsigned __int8 *)(a1 + 1568);
    do
      v7 = __ldaxr(v6);
    while (!v7 && __stlxr(1u, v6));
  }
  v35 = 0;
  v34 = (unint64_t *)(a1 + 464);
  while (1)
  {
    v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v34) : __ldxr(v34);
    v38 = v8;
    if (v8 >= a3)
      break;
    if (_os_atomic_mo_has_release(0))
      v35 = __stlxr(a3, v34) == 0;
    else
      v35 = __stxr(a3, v34) == 0;
    if (v35)
      goto LABEL_16;
  }
  __clrex();
LABEL_16:
  if (v35)
    v36 = a3 - v38;
  v33 = 0;
  v32 = (unint64_t *)(a1 + 488);
  while (1)
  {
    v9 = _os_atomic_mo_has_acquire(0) ? __ldaxr(v32) : __ldxr(v32);
    v39 = v9;
    if (v9 >= a4)
      break;
    if (_os_atomic_mo_has_release(0))
      v33 = __stlxr(a4, v32) == 0;
    else
      v33 = __stxr(a4, v32) == 0;
    if (v33)
      goto LABEL_28;
  }
  __clrex();
LABEL_28:
  if (v33)
    v37 = a4 - v39;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tclient side: mem: +%d->%llx, io: +%d->%llx", v10, v11, v12, v13, v14, v15, v16, 544);
  if (v36 || v37)
  {
    v30 = (unint64_t *)(a1 + 256);
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v17 = __ldaxr(v30);
      else
        v17 = __ldxr(v30);
      v40 = v17;
      HIWORD(v40) = HIWORD(v17) + v37;
      WORD1(v40) = WORD1(v17) + v36;
      if (_os_atomic_mo_has_release(0))
        v31 = __stlxr(v40, v30) == 0;
      else
        v31 = __stxr(v40, v30) == 0;
    }
    while (!v31);
    v28 = (unint64_t *)(a1 + 448);
    v29 = *(_QWORD *)(a1 + 448);
    do
    {
      v18 = v29;
      do
        v19 = __ldaxr(v28);
      while (v19 == v29 && __stlxr(v29 + (((unint64_t)v37 << 16) | v36), v28));
      v29 = v19;
    }
    while (v19 != v18);
    if (a6)
      *a6 = v19 + (((unint64_t)v37 << 16) | v36);
    if ((v43 & 1) != 0)
    {
      if (v37)
      {
        v26 = (unint64_t *)(a1 + 496);
        v27 = *(_QWORD *)(a1 + 496);
        do
        {
          v20 = v27;
          do
            v21 = __ldaxr(v26);
          while (v21 == v27 && __stlxr(v27 + 1, v26));
          v27 = v21;
        }
        while (v21 != v20);
      }
      if (v36)
      {
        v24 = (unint64_t *)(a1 + 472);
        v25 = *(_QWORD *)(a1 + 472);
        do
        {
          v22 = v25;
          do
            v23 = __ldaxr(v24);
          while (v23 == v25 && __stlxr(v25 + 1, v24));
          v25 = v23;
        }
        while (v23 != v22);
      }
    }
  }
  else if (a6)
  {
    *a6 = *(_QWORD *)(a1 + 448);
  }
}

void *firehose_buffer_update_limits(_QWORD *a1)
{
  unsigned int v1;
  void *result;
  unsigned int v3;
  unsigned int v4;
  unsigned int v5;
  unsigned int *v6;
  unsigned int v8;
  unsigned int *v9;

  v6 = (unsigned int *)(a1 + 67);
  v9 = (unsigned int *)(a1 + 67);
  v8 = _dispatch_thread_getspecific(3uLL) & 0xFFFFFFFC;
  do
    v1 = __ldaxr(v9);
  while (!v1 && __stlxr(v8, v9));
  if (v1)
    _dispatch_unfair_lock_lock_slow(v9, 0x10000);
  firehose_buffer_update_limits_unlocked(a1);
  result = _dispatch_thread_getspecific(3uLL);
  v5 = *v6;
  do
  {
    v3 = v5;
    do
      v4 = __ldaxr(v6);
    while (v4 == v5 && __stlxr(0, v6));
    v5 = v4;
  }
  while (v4 != v3);
  if (v4 != (result & 0xFFFFFFFC))
    return _dispatch_unfair_lock_unlock_slow((uint64_t)v6, v4);
  return result;
}

void firehose_buffer_ring_enqueue(mach_port_context_t a1, unsigned __int8 a2)
{
  unsigned __int16 *v2;
  int v3;
  int v4;
  int v5;
  int v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  BOOL v12;
  BOOL v13;
  unsigned __int16 v14;
  int i;
  unsigned __int16 v16;
  BOOL v17;
  unsigned __int16 v18;
  unsigned __int16 v19;
  unsigned __int16 v20;
  unsigned __int16 *v21;
  mach_port_context_t v22;

  v17 = (*(_QWORD *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000) != 0;
  if ((*(_QWORD *)(a1 + ((unint64_t)a2 << 12)) & 0x200000000000000) != 0)
  {
    v22 = a1 + 128;
    v21 = (unsigned __int16 *)(a1 + 384);
  }
  else
  {
    v22 = a1;
    v21 = (unsigned __int16 *)(a1 + 320);
  }
  v20 = *v21;
  while (1)
  {
    while (1)
    {
      v19 = v20 & 0xFFC0;
      v18 = v20 & 0x3F;
      _dispatch_thread_setspecific(122, (uint64_t)v21);
      v2 = (unsigned __int16 *)(v22 + 2 * (v20 & 0x3F));
      v3 = v20 & 0xFFC0;
      do
        v4 = __ldaxr(v2);
      while (v4 == (unsigned __int16)v3 && __stlxr(v20 & 0xFFC0 | a2, v2));
      if (v3 == (unsigned __int16)v4)
        break;
      _dispatch_thread_setspecific(122, 0);
      for (i = -1024; ; ++i)
      {
        v14 = v20;
        v20 = *v21;
        v12 = 1;
        if (*v21 == v14)
          v12 = *(unsigned __int16 *)(v22 + 2 * v18) == v19;
        if (v12)
          break;
        v6 = i;
        if (v6 < 0)
          __yield();
        else
          _pthread_yield_to_enqueuer_4dispatch(122, v21);
      }
    }
    v16 = v20;
    do
      v5 = __ldaxr(v21);
    while (v5 == v20 && __stlxr(v20 + 1, v21));
    v13 = v20 == (unsigned __int16)v5;
    if (v20 != (unsigned __int16)v5)
      v16 = v5;
    v20 = v16;
    if (v13)
      break;
    *(_WORD *)(v22 + 2 * v18) = v19;
    _dispatch_thread_setspecific(122, 0);
  }
  _dispatch_thread_setspecific(122, 0);
  firehose_client_send_push_async(a1, 0, v17, v7, v8, v9, v10, v11);
}

void firehose_client_send_push_async(mach_port_context_t a1, int a2, char a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  BOOL v16;
  BOOL v17;
  int v18;
  int v19;
  int v20;
  int v21;
  unsigned __int8 v22;

  v22 = a3 & 1;
  v20 = *(_DWORD *)(a1 + 4 * (a3 & 1) + 1552);
  if (v20 == -1)
    return;
  if (!v20)
    goto LABEL_11;
  v18 = firehose_send_push_async(v20, a2, 0);
  v17 = 1;
  if (v18)
    v17 = v18 == 268435460;
  if (!v17)
  {
    if (v18 != 268435459)
    {
      if (v18 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0xA1150);
      }
      if (v18)
        _dispatch_bug(476, v18, v8, a4, a5, a6, a7, a8);
    }
LABEL_11:
    v21 = firehose_client_reconnect(a1, v20, v22, a4, a5, a6, a7, a8);
    v16 = 0;
    if (v21)
      v16 = v21 != -1;
    if (v16)
    {
      v19 = firehose_send_push_async(v21, a2, 0);
      v15 = 1;
      if (v19)
        v15 = v19 == 268435460;
      if (!v15 && v19 != 268435459)
      {
        if (v19 == -301)
        {
          qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
          qword_E4DA8 = -301;
          __break(1u);
          JUMPOUT(0xA12A4);
        }
        if (v19)
          _dispatch_bug(488, v19, v9, v10, v11, v12, v13, v14);
      }
    }
  }
}

mach_port_context_t firehose_buffer_force_connect(mach_port_context_t result, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (!*(_DWORD *)(result + 1552))
    return firehose_client_reconnect(result, 0, 0, a4, a5, a6, a7, a8);
  return result;
}

char *firehose_buffer_tracepoint_reserve_slow(_QWORD *a1, _BYTE *a2, _QWORD *a3)
{
  unint64_t *v3;
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  int v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int *v11;
  unsigned int v12;
  unsigned int v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  unsigned int v20;
  unsigned int v21;
  unint64_t v22;
  unint64_t v23;
  unsigned __int8 v24;
  unint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unint64_t v31;
  unint64_t v32;
  unint64_t *v34;
  uint64_t v35;
  unint64_t v36;
  BOOL v37;
  unsigned int *v38;
  unsigned int v39;
  unsigned int *v40;
  unsigned int v41;
  unint64_t *v42;
  uint64_t v43;
  unint64_t v44;
  unsigned __int8 v45;
  char v46;
  unint64_t v47;
  _QWORD *v48;
  int v49;
  _QWORD *v50;
  _BYTE *v51;
  _QWORD *v52;
  _BOOL4 v54;
  BOOL v55;
  unint64_t v56;
  unint64_t v57;
  unint64_t v58;
  _BOOL4 v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t v62;
  unint64_t *v63;
  BOOL v64;
  unint64_t *v65;
  BOOL v66;
  _QWORD *v67;
  char v68;
  __int16 v69;
  __int16 v70;
  __int16 v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  unint64_t v75;
  unint64_t v76;
  uint64_t v77;
  uint64_t v78;
  uint64_t v79;
  unint64_t v80;
  unint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  int v85;
  mach_msg_timeout_t option_time;
  int v87;
  int v88;
  unint64_t *v89;
  int v90;
  BOOL v91;
  _QWORD *v92;
  unsigned __int8 v93;
  unsigned __int16 v94;
  __int16 v95;
  __int16 v96;
  _QWORD *v97;
  unint64_t v98;
  unint64_t v99;
  _QWORD *v100;
  unsigned __int8 v101;
  char v102;
  _QWORD *v103;
  uint64_t v104;
  _QWORD *v105;
  uint64_t v106;
  uint64_t v107;
  unsigned __int8 v108;
  _QWORD *v109;
  _BOOL4 v110;
  BOOL v111;
  unsigned int v112;
  unsigned int v113;
  unsigned int v114;
  _BOOL4 v115;
  unsigned int v116;
  unsigned int v117;
  unsigned int *v118;
  _QWORD *v119;
  unsigned __int8 v120;
  _QWORD *v121;
  unint64_t v122;
  unsigned __int8 v123;
  __int16 v124;
  _QWORD *v125;
  _BOOL4 v126;
  BOOL v127;
  unsigned int v128;
  unsigned int v129;
  unsigned int v130;
  _BOOL4 v131;
  unsigned int v132;
  unsigned int v133;
  unsigned int *v134;
  _QWORD *v135;
  unint64_t v136;
  unint64_t v137;
  uint64_t v138;
  uint64_t v139;
  uint64_t v140;
  unint64_t v141;
  unint64_t v142;
  uint64_t v143;
  uint64_t v144;
  uint64_t v145;
  _QWORD *v146;
  BOOL v147;
  _QWORD *v148;
  int v149;
  unint64_t v150;
  unint64_t *v151;
  int v152;
  int v153;
  unint64_t v154;
  unint64_t *v155;
  int v156;
  unint64_t v157;
  unint64_t v158;
  unint64_t v159;
  unint64_t *v160;
  unint64_t v161;
  unint64_t v162;
  unsigned __int8 v163;
  _QWORD *v164;
  unsigned int v165;
  unsigned int v166;
  unsigned int v167;
  unsigned int v168;
  int v169;
  int v170;
  int v171;
  unsigned int v172;
  unsigned int v173;
  unsigned int v174;
  unsigned int *v175;
  BOOL v176;
  unsigned int v177;
  unsigned int v178;
  unsigned int v179;
  int v180;
  int v181;
  int v182;
  unsigned int v183;
  unsigned int v184;
  unsigned int v185;
  unsigned int *v186;
  BOOL v187;
  unsigned int v188;
  unsigned int v189;
  unsigned int v190;
  unint64_t v191;
  uint64_t v192;
  _BOOL8 v193;
  unint64_t v194;
  unint64_t v195;
  unint64_t v196;
  unsigned __int8 v197;
  unint64_t v198;
  unint64_t v199;
  unint64_t v200;
  uint64_t v201;
  unsigned int v202;

  v52 = a1;
  v51 = a2;
  v50 = a3;
  v49 = 0;
  v49 = a2[14] & 1;
  v48 = a1 + 56;
  v47 = 0;
  v45 = 0;
  firehose_drain_notifications_once((uint64_t)a1);
  v47 = *v48;
  v67 = v52;
  v66 = v49 != 0;
  v65 = &v47;
  v64 = 0;
  v63 = v52 + 56;
  v62 = v47;
  v61 = 0;
  do
  {
    if (!*((_WORD *)&v62 + v66))
    {
      v68 = 0;
      goto LABEL_11;
    }
    v61 = v62;
    --*((_WORD *)&v61 + v66);
    v60 = v62;
    v59 = 0;
    v3 = v63;
    v57 = v61;
    v56 = v61;
    v58 = v61;
    v4 = v62;
    v5 = v61;
    do
      v6 = __ldaxr(v3);
    while (v6 == v4 && __stlxr(v5, v3));
    if (v6 != v4)
      v60 = v6;
    v55 = v6 == v4;
    v59 = v6 == v4;
    v62 = v60;
    v54 = v59;
    v64 = v6 == v4;
  }
  while (v6 != v4);
  *v65 = v61;
  v68 = 1;
LABEL_11:
  v46 = v68;
  if ((v68 & 1) != 0)
  {
    while (!v45)
    {
      v100 = v52;
      v99 = 0;
      v98 = 0;
      v97 = 0;
      v96 = 0;
      v95 = 0;
      v94 = 0;
      v93 = 0;
      v92 = 0;
      v91 = 0;
      v90 = 0;
      v89 = v52 + 32;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v7 = __ldaxr(v89);
        else
          v7 = __ldxr(v89);
        v98 = v7;
        v99 = v7;
        if ((unsigned __int16)v98 == WORD1(v98))
        {
          if (WORD2(v98) == HIWORD(v98))
          {
            __clrex();
            v101 = 0;
            goto LABEL_44;
          }
          ++WORD2(v99);
        }
        else
        {
          LOWORD(v99) = v99 + 1;
        }
        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v90) = __stlxr(v99, v89) == 0;
          v90 = v90;
        }
        else
        {
          LOBYTE(v90) = __stxr(v99, v89) == 0;
          v90 = v90;
        }
      }
      while (!v90);
      v88 = v90;
      v91 = WORD2(v99) != WORD2(v98);
      if (WORD2(v99) == WORD2(v98))
      {
        v97 = v100;
        v94 = v98 & 0x3F;
      }
      else
      {
        v97 = v100 + 16;
        v94 = BYTE4(v98) & 0x3F;
      }
      v87 = 0;
      option_time = -1024;
      while (1)
      {
        v95 = *((_WORD *)v97 + v94);
        v87 = v95 & 0x3F;
        if (v87)
          break;
        v8 = option_time++;
        if (v8 < 0)
          __yield();
        else
          thread_switch(0, 4, option_time);
      }
      v85 = v87;
      v96 = (v95 & 0xFFC0) + 64;
      v93 = v95 & 0x3F;
      v103 = v100;
      v102 = v95 & 0x3F;
      v92 = &v100[512 * (unint64_t)(v95 & 0x3F)];
      if (!v91 && *((_BYTE *)v92 + 6) == 3)
      {
        v83 = ~(1 << v93);
        v82 = v83;
        v84 = v83;
        v80 = 0;
        v42 = v100 + 57;
        v78 = v83;
        v77 = v83;
        v79 = v83;
        v43 = v83;
        v44 = v100[57];
        do
        {
          v9 = v44;
          do
            v10 = __ldaxr(v42);
          while (v10 == v44 && __stlxr(v44 & v43, v42));
          v44 = v10;
        }
        while (v10 != v9);
        v76 = v10;
        v80 = v10;
        v75 = v10;
        v81 = v10 & v84;
      }
      v74 = 0x100000000000000;
      v73 = 0x100000000000000;
      *v92 = 0x100000000000000;
      v72 = v74;
      v71 = v96;
      v70 = v96;
      *((_WORD *)v97 + v94) = v96;
      v69 = v71;
      v101 = v93;
LABEL_44:
      v45 = v101;
      if (!v101)
        break;
      if (v101 >= (int)BYTE4(v47))
      {
        v109 = v52;
        v108 = v101;
        v107 = 0x4000;
        v106 = 15;
        v105 = v52 + 67;
        v104 = 0;
        v118 = (unsigned int *)(v52 + 67);
        v117 = 0;
        v165 = _dispatch_thread_getspecific(3uLL);
        v117 = v165 & 0xFFFFFFFC;
        v116 = 0;
        v115 = 0;
        v11 = v118;
        v113 = v165 & 0xFFFFFFFC;
        v112 = v165 & 0xFFFFFFFC;
        v114 = v165 & 0xFFFFFFFC;
        v12 = v165 & 0xFFFFFFFC;
        do
          v13 = __ldaxr(v11);
        while (!v13 && __stlxr(v12, v11));
        if (v13)
          v116 = v13;
        v111 = v13 == 0;
        v115 = v13 == 0;
        v110 = v115;
        if (v13)
          _dispatch_unfair_lock_lock_slow(v118, 0x10000);
        if (v108 >= (int)*((unsigned __int8 *)v109 + 532))
        {
          v14 = v109[65] & ~(1 << v108);
          v109[65] = v14;
          v104 = v14;
          v108 &= 0xFCu;
          if ((v14 & (15 << v108)) == 0)
          {
            v121 = v109;
            v120 = v108;
            madvise(&v109[512 * (unint64_t)v108], 0x4000uLL, 5);
          }
          v108 = 0;
        }
        v119 = v105;
        v186 = (unsigned int *)v105;
        v185 = 0;
        v184 = 0;
        v188 = _dispatch_thread_getspecific(3uLL);
        v184 = v188 & 0xFFFFFFFC;
        v183 = 0;
        v40 = v186;
        v181 = 0;
        v180 = 0;
        v182 = 0;
        v41 = *v186;
        do
        {
          v15 = v41;
          do
            v16 = __ldaxr(v40);
          while (v16 == v41 && __stlxr(0, v40));
          v41 = v16;
        }
        while (v16 != v15);
        v179 = v16;
        v183 = v16;
        v178 = v16;
        v185 = v16;
        if (v16 == v184)
        {
          v187 = 0;
        }
        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v186, v185);
          v189 = v185;
          v187 = (v185 & 2) != 0;
        }
        v45 = v108;
      }
    }
    if (!v45)
    {
      v125 = v48;
      v124 = BYTE4(v47);
      v123 = 0;
      v122 = 0;
      v134 = (unsigned int *)(v48 + 11);
      v133 = 0;
      v166 = _dispatch_thread_getspecific(3uLL);
      v133 = v166 & 0xFFFFFFFC;
      v132 = 0;
      v131 = 0;
      v17 = v134;
      v129 = v166 & 0xFFFFFFFC;
      v128 = v166 & 0xFFFFFFFC;
      v130 = v166 & 0xFFFFFFFC;
      v18 = v166 & 0xFFFFFFFC;
      do
        v19 = __ldaxr(v17);
      while (!v19 && __stlxr(v18, v17));
      if (v19)
        v132 = v19;
      v127 = v19 == 0;
      v131 = v19 == 0;
      v126 = v131;
      if (v19)
        _dispatch_unfair_lock_lock_slow(v134, 0x10000);
      v122 = ~(v125[9] | (-1 << v124));
      if (v122)
      {
        v191 = v122;
        v193 = v122 != 0;
        v192 = 45;
        v123 = __clz(__rbit64(v122));
        v125[9] |= (1 << v123);
      }
      v135 = v125 + 11;
      v175 = (unsigned int *)(v125 + 11);
      v174 = 0;
      v173 = 0;
      v177 = _dispatch_thread_getspecific(3uLL);
      v173 = v177 & 0xFFFFFFFC;
      v172 = 0;
      v38 = v175;
      v170 = 0;
      v169 = 0;
      v171 = 0;
      v39 = *v175;
      do
      {
        v20 = v39;
        do
          v21 = __ldaxr(v38);
        while (v21 == v39 && __stlxr(0, v38));
        v39 = v21;
      }
      while (v21 != v20);
      v168 = v21;
      v172 = v21;
      v167 = v21;
      v174 = v21;
      if (v21 == v173)
      {
        v176 = 0;
      }
      else
      {
        _dispatch_unfair_lock_unlock_slow((uint64_t)v175, v174);
        v190 = v174;
        v176 = (v174 & 2) != 0;
      }
      v45 = v123;
    }
  }
  v37 = 1;
  if (!v45)
    v37 = (v51[14] & 4) == 0;
  if (v37)
  {
    if (!v45 && (v46 & 1) != 0)
    {
      v148 = v52;
      v147 = v49 != 0;
      v146 = v52 + 56;
      v144 = 1 << (16 * (v49 != 0));
      v143 = v144;
      v145 = v144;
      v141 = 0;
      v34 = v52 + 56;
      v139 = v144;
      v138 = v144;
      v140 = v144;
      v35 = v144;
      v36 = v52[56];
      do
      {
        v22 = v36;
        do
          v23 = __ldaxr(v34);
        while (v23 == v36 && __stlxr(v36 + v35, v34));
        v36 = v23;
      }
      while (v23 != v22);
      v137 = v23;
      v141 = v23;
      v136 = v23;
      v142 = v23 + v145;
    }
    return firehose_buffer_stream_chunk_install(v52, (uint64_t)v51, v50, v45);
  }
  else
  {
    v24 = v51[12];
    v164 = v52;
    v163 = v24;
    v162 = 0;
    v161 = 0;
    v160 = &v52[16 * (unint64_t)v24 + 80];
    v159 = 0;
    v158 = *v160;
    v159 = v158;
    v157 = v158;
    v162 = v158;
    if ((v158 & 0x400000000000) != 0)
    {
      v152 = 0;
      v151 = v160;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v31 = __ldaxr(v151);
        else
          v31 = __ldxr(v151);
        v162 = v31;
        LODWORD(v150) = v31 & 0xFFFFFFFD;
        BYTE4(v150) = BYTE4(v31);
        BYTE5(v150) = BYTE5(v150) & 0xC0 | BYTE5(v31) & 0x3F;
        BYTE5(v150) = BYTE5(v150) & 0xBF | 0x40;
        BYTE5(v150) = BYTE5(v150) & 0x7F | 0x80;
        HIWORD(v150) = HIWORD(v31);
        v161 = v150;
        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v152) = __stlxr(v161, v151) == 0;
          v152 = v152;
        }
        else
        {
          LOBYTE(v152) = __stxr(v161, v151) == 0;
          v152 = v152;
        }
      }
      while (!v152);
      v149 = v152;
    }
    else
    {
      v160[1] = mach_continuous_time();
      v156 = 0;
      v155 = v160;
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v25 = __ldaxr(v155);
        else
          v25 = __ldxr(v155);
        v162 = v25;
        LODWORD(v154) = v25 & 0xFFFFFFFD;
        BYTE4(v154) = BYTE4(v25);
        BYTE5(v154) = BYTE5(v154) & 0xC0 | BYTE5(v25) & 0x3F;
        BYTE5(v154) = BYTE5(v154) & 0xBF | 0x40;
        BYTE5(v154) = BYTE5(v154) & 0x7F | 0x80;
        HIWORD(v154) = HIWORD(v25);
        v161 = v154;
        if (_os_atomic_mo_has_release(3))
        {
          LOBYTE(v156) = __stlxr(v161, v155) == 0;
          v156 = v156;
        }
        else
        {
          LOBYTE(v156) = __stxr(v161, v155) == 0;
          v156 = v156;
        }
      }
      while (!v156);
      v153 = v156;
    }
    v32 = v160[1];
    v197 = v163;
    v196 = v32;
    v195 = v162;
    v194 = v161;
    v202 = 772145168;
    v201 = v163;
    v200 = v32;
    v199 = v162;
    v198 = v161;
    if (MEMORY[0xFFFFFC100])
      kdebug_trace(v202, v201, v200, v199, v198);
    if ((v162 & 2) != 0)
      _dispatch_gate_broadcast_slow((uint64_t)v160, v162);
    v51[13] = v46 & 1;
    return firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(v52, (uint64_t)v51, v50, v26, v27, v28, v29, v30);
  }
}

BOOL firehose_drain_notifications_once(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  void *v3;
  uint64_t v4;
  _OWORD *v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _BOOL4 v12;
  _QWORD v14[6];
  _BYTE v15[144];
  _BOOL4 v16;
  _BOOL4 v17;
  uint64_t v18;
  uint64_t v19;
  _BYTE *v20;
  _QWORD *v21;
  mach_msg_header_t *v22;
  mach_msg_size_t v23;
  uint64_t v24;
  _QWORD v25[3];
  mach_msg_return_t v26;
  mach_msg_header_t *v27;
  mach_msg_size_t v28;
  uint64_t v29;
  uint64_t v30;
  mach_msg_option_t v31;
  uint64_t v32;
  _QWORD *v33;
  uint64_t v34;
  __int128 v35;
  uint64_t v36;
  BOOL v37;
  int v38;
  _QWORD *v39;
  mach_msg_header_t *v40;
  uint64_t v41;
  uint64_t (*v42)(_DWORD *, uint64_t);
  uint64_t *v43;
  uint64_t v44;
  _BOOL8 v45;

  v32 = a1;
  v23 = 0;
  v31 = 67109126;
  v30 = 56;
  v29 = 36;
  v28 = 124;
  v27 = 0;
  v22 = (mach_msg_header_t *)v15;
  bzero(v15, 0x7CuLL);
  v27 = v22;
  v26 = v23;
  v26 = mach_msg(v22, v31, v23, v28, *(_DWORD *)(v32 + 1560), v23, v23);
  if (v26)
  {
    if (v26 != 268451843)
    {
      v24 = v26;
      v14[4] = v1;
      v14[5] = v2;
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: firehose_drain_notifications_once() failed";
      qword_E4DA8 = v26;
      __break(1u);
      JUMPOUT(0xA294CLL);
    }
  }
  else
  {
    v19 = 0;
    v25[0] = 0;
    v25[1] = "firehose";
    v25[2] = v32;
    v33 = v25;
    v18 = 23;
    v3 = _dispatch_thread_getspecific(0x17uLL);
    v4 = v18;
    *v33 = v3;
    _dispatch_thread_setspecific(v4, (uint64_t)v33);
    v20 = v15;
    v42 = firehoseReply_server;
    v41 = 36;
    v40 = v27;
    v39 = (_QWORD *)v19;
    v21 = v14;
    bzero(v14, 0x24uLL);
    v39 = v21;
    v38 = 0;
    v37 = (v40->msgh_bits & 0x1F) == 18;
    v5 = v21;
    v36 = 0;
    v35 = 0uLL;
    v21[2] = 0;
    *v5 = 0uLL;
    if (v42(v40, (uint64_t)v39))
    {
      if ((*((_BYTE *)v39 + 3) & 0x80) != 0)
        v38 = 0;
      else
        v38 = *((_DWORD *)v39 + 8);
    }
    else
    {
      v38 = -303;
    }
    v17 = 0;
    if (!v38)
      v17 = v37;
    if (v17)
    {
      v34 = 0;
      v34 = *((int *)v39 + 5);
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: firehose_mig_server doesn't handle replies";
      qword_E4DA8 = v34;
      __break(1u);
      JUMPOUT(0xA2834);
    }
    v16 = 0;
    if (v38)
      v16 = v38 != -305;
    if (v16)
    {
      v40->msgh_remote_port = 0;
      mach_msg_destroy(v40);
    }
    v43 = v25;
    v12 = _dispatch_thread_getspecific(0x17uLL) == v25;
    v45 = v12;
    v44 = 449;
    if (!v12)
      _dispatch_abort(v44, v45, v6, v7, v8, v9, v10, v11);
    _dispatch_thread_setspecific(23, *v43);
  }
  return v26 == 0;
}

char *firehose_buffer_stream_chunk_install(_QWORD *a1, uint64_t a2, _QWORD *a3, unsigned __int8 a4)
{
  unint64_t v4;
  unint64_t v5;
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;
  unsigned __int8 *v14;
  int v15;
  char v17;
  char v18;
  int v19;
  unint64_t v20;
  unint64_t v21;
  unint64_t v22;
  unint64_t v23;
  int v24;
  unint64_t v25;
  unint64_t *v26;
  unint64_t v27;
  unint64_t v28;
  _BOOL4 v29;
  unint64_t v30;
  _BOOL4 v31;
  unint64_t v32;
  _QWORD v33[2];
  int v34;
  int v35;
  _BOOL4 v36;
  unint64_t v37;
  unint64_t *v38;
  _BOOL4 v39;
  unint64_t v40;
  unint64_t v41;
  unint64_t v42;
  uint64_t v43;
  unint64_t v44;
  _BOOL4 v45;
  unint64_t v46;
  unint64_t *v47;
  _BOOL4 v48;
  unint64_t v49;
  unint64_t v50;
  unint64_t v51;
  unint64_t v52;
  unint64_t v53;
  uint64_t v54;
  uint64_t v55;
  uint64_t v56;
  unint64_t v57;
  unint64_t v58;
  uint64_t v59;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  uint64_t v63;
  uint64_t v64;
  char *v65;
  BOOL v66;
  unint64_t v67;
  unint64_t *v68;
  _QWORD *v69;
  unint64_t *v70;
  char *v71;
  unint64_t v72;
  unint64_t v73;
  unsigned __int8 v74;
  _QWORD *v75;
  uint64_t v76;
  _QWORD *v77;
  unsigned __int8 v78;
  _QWORD *v79;
  unint64_t StatusReg;
  _WORD v81[4];
  unint64_t v82;
  unint64_t v83;
  unint64_t v84;
  unint64_t v85;
  unint64_t v86;
  unint64_t v87;
  __int16 v88;
  unint64_t v89;
  unint64_t v90;
  __int16 v91;
  unsigned __int16 v92;
  __int16 v93;
  __int16 v94;
  unint64_t v95;
  char *v96;
  unint64_t v97;
  unint64_t **v98;
  unint64_t v99;
  _QWORD *v100;
  uint64_t v101;
  _QWORD *v102;
  _WORD __src[4];
  uint64_t v104;
  uint64_t v105;
  uint64_t v106;
  unsigned __int16 v107;
  __int16 v108;
  __int16 v109;
  uint64_t v110;
  char *v111;
  uint64_t v112;
  uint64_t v113;
  unint64_t v114;
  _QWORD *v115;
  uint64_t v116;
  char *v117;
  unint64_t v118;
  unint64_t v119;
  uint64_t v120;
  unint64_t v121;
  unint64_t v122;
  unint64_t v123;
  unint64_t v124;
  unint64_t v125;
  _QWORD *v126;
  unint64_t v127;
  _QWORD *v128;
  unint64_t v129;
  unint64_t v130;
  uint64_t v131;
  unint64_t v132;
  unsigned int v133;

  v77 = a1;
  v76 = a2;
  v75 = a3;
  v74 = a4;
  v73 = 0;
  v72 = 0;
  v71 = 0;
  v70 = 0;
  v69 = a1;
  v68 = 0;
  v68 = &a1[16 * (unint64_t)*(unsigned __int8 *)(a2 + 12) + 80];
  if (a4)
  {
    v67 = 0;
    v66 = 0;
    v79 = v77;
    v78 = v74;
    v65 = (char *)&v77[512 * (unint64_t)v74];
    v64 = 0;
    v63 = *(_QWORD *)v65;
    v64 = v63;
    v62 = v63;
    if (v63)
      __memset_chk(v65 + 16, 0, 4080, -1);
    if (*(_BYTE *)(v76 + 12) == 3)
    {
      v60 = 1 << v74;
      v59 = 1 << v74;
      v61 = 1 << v74;
      v57 = 0;
      v26 = v69 + 57;
      v55 = 1 << v74;
      v54 = 1 << v74;
      v56 = 1 << v74;
      v27 = v69[57];
      do
      {
        v4 = v27;
        do
          v5 = __ldaxr(v26);
        while (v5 == v27 && __stlxr(v27 | (1 << v74), v26));
        v27 = v5;
      }
      while (v5 != v4);
      v53 = v5;
      v57 = v5;
      v52 = v5;
      v58 = v5 | v61;
    }
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    v67 = *(_QWORD *)(StatusReg - 8);
    v51 = 0;
    v50 = *v68;
    v51 = v50;
    v49 = v50;
    v73 = v50;
    if ((v50 & 0x3F0000000000) == 0)
    {
      v117 = v65;
      v116 = v76;
      v115 = v75;
      v114 = v67;
      v113 = 0;
      v112 = 0;
      v111 = 0;
      v110 = 0;
      v109 = 24;
      v108 = 16;
      v107 = 4096;
      v122 = *(_QWORD *)v76;
      if (v122 <= 0x1000000000)
        v25 = 0;
      else
        v25 = v122 - 0x1000000000;
      *((_QWORD *)v117 + 1) = v25;
      v111 = v117 + 16;
      if ((*(unsigned __int16 *)(v116 + 8) + 24) % 8)
        v24 = *(unsigned __int16 *)(v116 + 8) + 24 + 8 - (*(unsigned __int16 *)(v116 + 8) + 24) % 8;
      else
        LOWORD(v24) = *(_WORD *)(v116 + 8) + 24;
      v108 += v24;
      v107 -= *(_WORD *)(v116 + 10);
      v110 = *(_QWORD *)v116 - *((_QWORD *)v117 + 1);
      v110 |= (unint64_t)*(unsigned __int16 *)(v116 + 8) << 48;
      v106 = v110;
      v105 = v110;
      *((_QWORD *)v111 + 2) = v110;
      v104 = v106;
      *((_QWORD *)v111 + 1) = v114;
      __src[0] = v108;
      __src[1] = v107;
      __src[2] = 1;
      LOBYTE(__src[3]) = *(_BYTE *)(v116 + 12);
      HIBYTE(__src[3]) &= ~1u;
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFD | (2 * (*(_BYTE *)(v116 + 14) & 1));
      HIBYTE(__src[3]) = HIBYTE(__src[3]) & 0xFB | (4 * ((*(_BYTE *)(v116 + 14) & 2) != 0));
      HIBYTE(__src[3]) &= 7u;
      memcpy(v117, __src, 8uLL);
      if (v115)
        *v115 = &v117[v107];
      v71 = v111;
      v48 = 0;
      v47 = v68;
      while (1)
      {
        v6 = _os_atomic_mo_has_acquire(3) ? __ldaxr(v47) : __ldxr(v47);
        v73 = v6;
        if ((v6 & 0x3F0000000000) != 0)
          break;
        LODWORD(v46) = 0;
        WORD2(v46) = v74;
        HIWORD(v46) = HIWORD(v73) + 1;
        v72 = v46;
        if (_os_atomic_mo_has_release(3))
          v48 = __stlxr(v72, v47) == 0;
        else
          v48 = __stxr(v72, v47) == 0;
        if (v48)
          goto LABEL_30;
      }
      __clrex();
LABEL_30:
      v45 = v48;
      v66 = v48;
    }
    if (!v66)
    {
      v44 = 0;
      v43 = 0;
      v7 = atomic_load(v68);
      v41 = v7;
      v42 = v7;
      v40 = v7;
      v44 = v68[1];
      v68[1] = 0;
      v43 = mach_continuous_time();
      v102 = v65;
      v101 = v76;
      v100 = v75;
      v99 = v67;
      v98 = &v70;
      v97 = v44;
      v96 = 0;
      v95 = 0;
      v94 = 24;
      v93 = 16;
      v92 = 4096;
      if (&v70)
      {
        v91 = 24;
        v90 = 0;
        v89 = 0;
        v88 = 0;
        if (*(_QWORD *)v101 >= v97)
          v23 = v97;
        else
          v23 = *(_QWORD *)v101;
        v89 = v23;
        v123 = v23;
        if (v23 <= 0x1000000000)
          v22 = 0;
        else
          v22 = v123 - 0x1000000000;
        v102[1] = v22;
        v8 = *(_QWORD *)v101;
        v128 = v102;
        v127 = v8;
        if ((v8 - v102[1]) >> 48)
          v102[1] = *(_QWORD *)v101 - 0x1000000000;
        *v98 = v102 + 2;
        v126 = v102;
        v125 = v97;
        if ((v97 - v102[1]) >> 48)
          v21 = *(_QWORD *)v101;
        else
          v21 = v97;
        v90 = v21;
        v95 = v21 - v102[1];
        v95 |= 0x18000000000000uLL;
        v87 = v95;
        v9 = *v98;
        v86 = v95;
        v9[2] = v95;
        v85 = v87;
        (*v98)[1] = v99;
        v88 = 48;
        v93 += 48;
        v96 = (char *)(v102 + 8);
      }
      else
      {
        v124 = *(_QWORD *)v101;
        if (v124 <= 0x1000000000)
          v20 = 0;
        else
          v20 = v124 - 0x1000000000;
        v102[1] = v20;
        v96 = (char *)(v102 + 2);
      }
      if ((*(unsigned __int16 *)(v101 + 8) + 24) % 8)
        v19 = *(unsigned __int16 *)(v101 + 8) + 24 + 8 - (*(unsigned __int16 *)(v101 + 8) + 24) % 8;
      else
        LOWORD(v19) = *(_WORD *)(v101 + 8) + 24;
      v93 += v19;
      v92 -= *(_WORD *)(v101 + 10);
      v95 = *(_QWORD *)v101 - v102[1];
      v95 |= (unint64_t)*(unsigned __int16 *)(v101 + 8) << 48;
      v84 = v95;
      v83 = v95;
      *((_QWORD *)v96 + 2) = v95;
      v82 = v84;
      *((_QWORD *)v96 + 1) = v99;
      v81[0] = v93;
      v81[1] = v92;
      v81[2] = 1;
      LOBYTE(v81[3]) = *(_BYTE *)(v101 + 12);
      HIBYTE(v81[3]) &= ~1u;
      HIBYTE(v81[3]) = HIBYTE(v81[3]) & 0xFD | (2 * (*(_BYTE *)(v101 + 14) & 1));
      HIBYTE(v81[3]) = HIBYTE(v81[3]) & 0xFB | (4 * ((*(_BYTE *)(v101 + 14) & 2) != 0));
      HIBYTE(v81[3]) &= 7u;
      memcpy(v102, v81, sizeof(_QWORD));
      if (v100)
        *v100 = (char *)v102 + v92;
      v71 = v96;
      v39 = 0;
      v38 = v68;
      do
      {
        if (_os_atomic_mo_has_acquire(3))
          v10 = __ldaxr(v38);
        else
          v10 = __ldxr(v38);
        v73 = v10;
        LODWORD(v37) = 0;
        WORD2(v37) = v74;
        HIWORD(v37) = HIWORD(v10) + 1;
        v72 = v37;
        if (_os_atomic_mo_has_release(3))
          v39 = __stlxr(v72, v38) == 0;
        else
          v39 = __stxr(v72, v38) == 0;
      }
      while (!v39);
      v36 = v39;
      v35 = 0;
      v33[0] = v44;
      v33[1] = v43;
      v34 = BYTE5(v73) & 0x3F;
      __memcpy_chk(v70 + 3, v33, 24, -1);
      LODWORD(v32) = 7;
      HIDWORD(v32) = *(unsigned __int8 *)(v76 + 12);
      atomic_store(v32, v70);
    }
  }
  else if ((*v68 & 0x400000000000) != 0)
  {
    do
    {
      if (_os_atomic_mo_has_acquire(0))
        v12 = __ldaxr(v68);
      else
        v12 = __ldxr(v68);
      v73 = v12;
      LODWORD(v28) = 0;
      BYTE4(v28) = 0;
      if ((BYTE5(v12) & 0x3Fu) + 1 >= 0x3F)
        v17 = 63;
      else
        v17 = (BYTE5(v73) & 0x3F) + 1;
      BYTE5(v28) = v17 & 0x3F | 0x40;
      HIWORD(v28) = HIWORD(v73);
      v72 = v28;
      if (_os_atomic_mo_has_release(0))
        v29 = __stlxr(v72, v68) == 0;
      else
        v29 = __stxr(v72, v68) == 0;
    }
    while (!v29);
  }
  else
  {
    v68[1] = mach_continuous_time();
    do
    {
      if (_os_atomic_mo_has_acquire(3))
        v11 = __ldaxr(v68);
      else
        v11 = __ldxr(v68);
      v73 = v11;
      LODWORD(v30) = 0;
      BYTE4(v30) = 0;
      if ((BYTE5(v11) & 0x3Fu) + 1 >= 0x3F)
        v18 = 63;
      else
        v18 = (BYTE5(v73) & 0x3F) + 1;
      BYTE5(v30) = v18 & 0x3F | 0x40;
      HIWORD(v30) = HIWORD(v73);
      v72 = v30;
      if (_os_atomic_mo_has_release(3))
        v31 = __stlxr(v72, v68) == 0;
      else
        v31 = __stxr(v72, v68) == 0;
    }
    while (!v31);
  }
  v13 = *(_QWORD *)(v76 + 8);
  v121 = *(_QWORD *)v76;
  v120 = v13;
  v119 = v73;
  v118 = v72;
  v133 = 772145172;
  v132 = v121;
  v131 = v13;
  v130 = v73;
  v129 = v72;
  if (MEMORY[0xFFFFFC100])
    kdebug_trace(v133, v132, v131, v130, v129);
  if ((v73 & 3) != 0)
    _dispatch_gate_broadcast_slow((uint64_t)v68, v73);
  if (BYTE4(v73) == 255)
    firehose_buffer_update_limits(v77);
  if (*((_BYTE *)v69 + 1568) == 1)
  {
    v14 = (unsigned __int8 *)(v69 + 196);
    do
      v15 = __ldaxr(v14);
    while (v15 == 1 && __stlxr(2u, v14));
    if (v15 == 1)
      firehose_client_start_quarantine((mach_port_context_t)v77);
  }
  return v71;
}

char *firehose_buffer_tracepoint_reserve_wait_for_chunks_from_logd(_QWORD *a1, uint64_t a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  int v8;
  unint64_t *v9;
  unint64_t v10;
  unint64_t v11;
  unint64_t v12;
  unint64_t v13;
  int v14;
  unint64_t v15;
  unint64_t v16;
  unsigned int *v17;
  unsigned int v18;
  unsigned int v19;
  uint64_t v20;
  unsigned int v21;
  unsigned int v22;
  unsigned int *v23;
  unsigned int v24;
  unsigned int v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  unsigned int v31;
  unsigned int v32;
  unsigned int *v34;
  unsigned int v35;
  unsigned int *v36;
  unsigned int v37;
  unint64_t *v38;
  uint64_t v39;
  unint64_t v40;
  BOOL v41;
  int v42;
  unsigned __int8 v43;
  unsigned __int8 v44;
  unint64_t v45;
  _QWORD *v46;
  unsigned __int8 v47;
  char v48;
  _QWORD *v49;
  uint64_t v50;
  _QWORD *v51;
  _BOOL4 v53;
  BOOL v54;
  unint64_t v55;
  unint64_t v56;
  unint64_t v57;
  _BOOL4 v58;
  unint64_t v59;
  unint64_t v60;
  unint64_t v61;
  unint64_t *v62;
  BOOL v63;
  unint64_t *v64;
  char v65;
  _QWORD *v66;
  char v67;
  __int16 v68;
  __int16 v69;
  __int16 v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  unint64_t v74;
  unint64_t v75;
  uint64_t v76;
  uint64_t v77;
  uint64_t v78;
  unint64_t v79;
  unint64_t v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  int v84;
  mach_msg_timeout_t option_time;
  int v86;
  int v87;
  unint64_t *v88;
  int v89;
  BOOL v90;
  _QWORD *v91;
  unsigned __int8 v92;
  unsigned __int16 v93;
  __int16 v94;
  __int16 v95;
  _QWORD *v96;
  unint64_t v97;
  unint64_t v98;
  _QWORD *v99;
  unsigned __int8 v100;
  char v101;
  _QWORD *v102;
  uint64_t v103;
  _QWORD *v104;
  uint64_t v105;
  uint64_t v106;
  unsigned __int8 v107;
  _QWORD *v108;
  _BOOL4 v109;
  BOOL v110;
  unsigned int v111;
  unsigned int v112;
  unsigned int v113;
  _BOOL4 v114;
  unsigned int v115;
  unsigned int v116;
  unsigned int *v117;
  _QWORD *v118;
  unsigned __int8 v119;
  _QWORD *v120;
  unint64_t v121;
  unsigned __int8 v122;
  __int16 v123;
  _QWORD *v124;
  _BOOL4 v125;
  BOOL v126;
  unsigned int v127;
  unsigned int v128;
  unsigned int v129;
  _BOOL4 v130;
  unsigned int v131;
  unsigned int v132;
  unsigned int *v133;
  _QWORD *v134;
  unsigned int v135;
  unsigned int v136;
  unsigned int v137;
  unsigned int v138;
  int v139;
  int v140;
  int v141;
  unsigned int v142;
  unsigned int v143;
  unsigned int v144;
  unsigned int *v145;
  BOOL v146;
  unsigned int v147;
  unsigned int v148;
  unsigned int v149;
  int v150;
  int v151;
  int v152;
  unsigned int v153;
  unsigned int v154;
  unsigned int v155;
  unsigned int *v156;
  BOOL v157;
  unsigned int v158;
  unsigned int v159;
  unsigned int v160;
  unint64_t v161;
  uint64_t v162;
  _BOOL8 v163;

  v51 = a1;
  v50 = a2;
  v49 = a3;
  v48 = 0;
  v48 = *(_BYTE *)(a2 + 14) & 1;
  v47 = v48 & 1;
  v46 = a1 + 56;
  v45 = 0;
  v42 = 5;
  do
  {
    v8 = v42--;
    v41 = 0;
    if (v8)
      v41 = firehose_drain_notifications_once((uint64_t)v51);
  }
  while (v41);
  if (((*(_BYTE *)(v50 + 13) ^ 1) & 1) == 0)
  {
    v43 = *((_BYTE *)v46 + 4);
    goto LABEL_26;
  }
  v45 = *v46;
  while (1)
  {
    v66 = v51;
    v65 = v48 & 1;
    v64 = &v45;
    v63 = 0;
    v62 = v51 + 56;
    v61 = v45;
    v60 = 0;
    do
    {
      if (!*((_WORD *)&v61 + (v65 & 1)))
      {
        v67 = 0;
        goto LABEL_17;
      }
      v60 = v61;
      --*((_WORD *)&v60 + (v65 & 1));
      v59 = v61;
      v58 = 0;
      v9 = v62;
      v56 = v60;
      v55 = v60;
      v57 = v60;
      v10 = v61;
      v11 = v60;
      do
        v12 = __ldaxr(v9);
      while (v12 == v10 && __stlxr(v11, v9));
      if (v12 != v10)
        v59 = v12;
      v54 = v12 == v10;
      v58 = v12 == v10;
      v61 = v59;
      v53 = v58;
      v63 = v12 == v10;
    }
    while (v12 != v10);
    *v64 = v60;
    v67 = 1;
LABEL_17:
    if ((v67 & 1) != 0)
      break;
    if ((*(_BYTE *)(v50 + 14) & 2) != 0)
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v51, v48 & 1, &v45, a4, a5, a6, a7, a8);
    else
      firehose_client_send_push_and_wait(v51, v48 & 1, &v45, a4, a5, a6, a7, a8);
    if (*((_DWORD *)v51 + v47 + 388) == -1)
      return 0;
  }
  v43 = BYTE4(v45);
  do
  {
LABEL_26:
    while (1)
    {
      v99 = v51;
      v98 = 0;
      v97 = 0;
      v96 = 0;
      v95 = 0;
      v94 = 0;
      v93 = 0;
      v92 = 0;
      v91 = 0;
      v90 = 0;
      v89 = 0;
      v88 = v51 + 32;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v13 = __ldaxr(v88);
        else
          v13 = __ldxr(v88);
        v97 = v13;
        v98 = v13;
        if ((unsigned __int16)v97 == WORD1(v97))
        {
          if (WORD2(v97) == HIWORD(v97))
          {
            __clrex();
            v100 = 0;
            goto LABEL_57;
          }
          ++WORD2(v98);
        }
        else
        {
          LOWORD(v98) = v98 + 1;
        }
        if (_os_atomic_mo_has_release(0))
        {
          LOBYTE(v89) = __stlxr(v98, v88) == 0;
          v89 = v89;
        }
        else
        {
          LOBYTE(v89) = __stxr(v98, v88) == 0;
          v89 = v89;
        }
      }
      while (!v89);
      v87 = v89;
      v90 = WORD2(v98) != WORD2(v97);
      if (WORD2(v98) == WORD2(v97))
      {
        v96 = v99;
        v93 = v97 & 0x3F;
      }
      else
      {
        v96 = v99 + 16;
        v93 = BYTE4(v97) & 0x3F;
      }
      v86 = 0;
      option_time = -1024;
      while (1)
      {
        v94 = *((_WORD *)v96 + v93);
        v86 = v94 & 0x3F;
        if (v86)
          break;
        v14 = option_time++;
        if (v14 < 0)
          __yield();
        else
          thread_switch(0, 4, option_time);
      }
      v84 = v86;
      v95 = (v94 & 0xFFC0) + 64;
      v92 = v94 & 0x3F;
      v102 = v99;
      v101 = v94 & 0x3F;
      v91 = &v99[512 * (unint64_t)(v94 & 0x3F)];
      if (!v90 && *((_BYTE *)v91 + 6) == 3)
      {
        v82 = ~(1 << v92);
        v81 = v82;
        v83 = v82;
        v79 = 0;
        v38 = v99 + 57;
        v77 = v82;
        v76 = v82;
        v78 = v82;
        v39 = v82;
        v40 = v99[57];
        do
        {
          v15 = v40;
          do
            v16 = __ldaxr(v38);
          while (v16 == v40 && __stlxr(v40 & v39, v38));
          v40 = v16;
        }
        while (v16 != v15);
        v75 = v16;
        v79 = v16;
        v74 = v16;
        v80 = v16 & v83;
      }
      v73 = 0x100000000000000;
      v72 = 0x100000000000000;
      *v91 = 0x100000000000000;
      v71 = v73;
      v70 = v95;
      v69 = v95;
      *((_WORD *)v96 + v93) = v95;
      v68 = v70;
      v100 = v92;
LABEL_57:
      v44 = v100;
      if (!v100)
        break;
      if (v100 >= (int)v43)
      {
        v108 = v51;
        v107 = v100;
        v106 = 0x4000;
        v105 = 15;
        v104 = v51 + 67;
        v103 = 0;
        v117 = (unsigned int *)(v51 + 67);
        v116 = 0;
        v135 = _dispatch_thread_getspecific(3uLL);
        v116 = v135 & 0xFFFFFFFC;
        v115 = 0;
        v114 = 0;
        v17 = v117;
        v112 = v135 & 0xFFFFFFFC;
        v111 = v135 & 0xFFFFFFFC;
        v113 = v135 & 0xFFFFFFFC;
        v18 = v135 & 0xFFFFFFFC;
        do
          v19 = __ldaxr(v17);
        while (!v19 && __stlxr(v18, v17));
        if (v19)
          v115 = v19;
        v110 = v19 == 0;
        v114 = v19 == 0;
        v109 = v114;
        if (v19)
          _dispatch_unfair_lock_lock_slow(v117, 0x10000);
        if (v107 >= (int)*((unsigned __int8 *)v108 + 532))
        {
          v20 = v108[65] & ~(1 << v107);
          v108[65] = v20;
          v103 = v20;
          v107 &= 0xFCu;
          if ((v20 & (15 << v107)) == 0)
          {
            v120 = v108;
            v119 = v107;
            madvise(&v108[512 * (unint64_t)v107], 0x4000uLL, 5);
          }
          v107 = 0;
        }
        v118 = v104;
        v156 = (unsigned int *)v104;
        v155 = 0;
        v154 = 0;
        v158 = _dispatch_thread_getspecific(3uLL);
        v154 = v158 & 0xFFFFFFFC;
        v153 = 0;
        v36 = v156;
        v151 = 0;
        v150 = 0;
        v152 = 0;
        v37 = *v156;
        do
        {
          v21 = v37;
          do
            v22 = __ldaxr(v36);
          while (v22 == v37 && __stlxr(0, v36));
          v37 = v22;
        }
        while (v22 != v21);
        v149 = v22;
        v153 = v22;
        v148 = v22;
        v155 = v22;
        if (v22 == v154)
        {
          v157 = 0;
        }
        else
        {
          _dispatch_unfair_lock_unlock_slow((uint64_t)v156, v155);
          v159 = v155;
          v157 = (v155 & 2) != 0;
        }
        v44 = v107;
        if (!v107)
          continue;
      }
      return firehose_buffer_stream_chunk_install(v51, v50, v49, v44);
    }
    v124 = v46;
    v123 = v43;
    v122 = 0;
    v121 = 0;
    v133 = (unsigned int *)(v46 + 11);
    v132 = 0;
    v136 = _dispatch_thread_getspecific(3uLL);
    v132 = v136 & 0xFFFFFFFC;
    v131 = 0;
    v130 = 0;
    v23 = v133;
    v128 = v136 & 0xFFFFFFFC;
    v127 = v136 & 0xFFFFFFFC;
    v129 = v136 & 0xFFFFFFFC;
    v24 = v136 & 0xFFFFFFFC;
    do
      v25 = __ldaxr(v23);
    while (!v25 && __stlxr(v24, v23));
    if (v25)
      v131 = v25;
    v126 = v25 == 0;
    v130 = v25 == 0;
    v125 = v130;
    if (v25)
      _dispatch_unfair_lock_lock_slow(v133, 0x10000);
    v121 = ~(v124[9] | (-1 << v123));
    if (v121)
    {
      v161 = v121;
      v163 = v121 != 0;
      v162 = 45;
      v122 = __clz(__rbit64(v121));
      v124[9] |= (1 << v122);
    }
    v134 = v124 + 11;
    v145 = (unsigned int *)(v124 + 11);
    v144 = 0;
    v143 = 0;
    v147 = _dispatch_thread_getspecific(3uLL);
    v143 = v147 & 0xFFFFFFFC;
    v142 = 0;
    v34 = v145;
    v140 = 0;
    v139 = 0;
    v141 = 0;
    v35 = *v145;
    do
    {
      v31 = v35;
      do
        v32 = __ldaxr(v34);
      while (v32 == v35 && __stlxr(0, v34));
      v35 = v32;
    }
    while (v32 != v31);
    v138 = v32;
    v142 = v32;
    v137 = v32;
    v144 = v32;
    if (v32 == v143)
    {
      v146 = 0;
    }
    else
    {
      _dispatch_unfair_lock_unlock_slow((uint64_t)v145, v144);
      v160 = v144;
      v146 = (v144 & 2) != 0;
    }
    v44 = v122;
    if (v122)
      break;
    if ((*(_BYTE *)(v50 + 14) & 2) != 0)
      __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(v51, v48 & 1, 0, v26, v27, v28, v29, v30);
    else
      firehose_client_send_push_and_wait(v51, v48 & 1, 0, v26, v27, v28, v29, v30);
  }
  while (*((_DWORD *)v51 + v47 + 388) != -1);
  return firehose_buffer_stream_chunk_install(v51, v50, v49, v44);
}

void firehose_client_start_quarantine(mach_port_context_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  unint64_t v24;
  unint64_t v25;
  unint64_t v26;
  unint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v32;
  unint64_t v33;
  unint64_t v34;
  unint64_t *v35;
  uint64_t v36;
  unint64_t v37;
  unint64_t v38;
  unint64_t *v39;
  uint64_t v40;
  unint64_t v41;
  unint64_t v42;
  unint64_t *v43;
  unint64_t *v44;
  _BOOL4 v45;
  BOOL v46;
  char v47;
  unint64_t v48;
  unint64_t v49;
  __int16 v50;
  _QWORD *v51;
  unsigned __int16 v52;
  unsigned __int16 v53;
  unsigned __int8 v54;
  unsigned __int8 v55;
  uint64_t v56;
  unint64_t *v57;
  uint64_t v58;
  _BOOL4 v59;
  __int16 v60;
  unint64_t *v61;
  _BOOL4 v62;
  BOOL v63;
  char v64;
  unint64_t v65;
  unint64_t v66;
  __int16 v67;
  _QWORD *v68;
  unsigned __int16 v69;
  unsigned __int16 v70;
  unsigned __int8 v71;
  unsigned __int8 v72;
  uint64_t v73;
  unint64_t *v74;
  uint64_t v75;
  _BOOL4 v76;
  __int16 v77;
  unint64_t *v78;
  _BOOL4 v79;
  BOOL v80;
  char v81;
  unint64_t v82;
  unint64_t v83;
  __int16 v84;
  _QWORD *v85;
  unsigned __int16 v86;
  unsigned __int16 v87;
  unsigned __int8 v88;
  unsigned __int8 v89;
  uint64_t v90;
  unint64_t *v91;
  uint64_t v92;
  __int16 v93;
  unint64_t *v94;
  unsigned __int16 v95;
  unint64_t *v96;
  __int16 v97;
  unint64_t *v98;
  unsigned __int16 v99;
  unint64_t *v100;
  __int16 v101;
  unint64_t *v102;
  unsigned __int16 v103;
  unint64_t *v104;

  if (*(uint64_t *)_voucher_libtrace_hooks > 4 && *(_QWORD *)(_voucher_libtrace_hooks + 40))
  {
    (*(void (**)(void))(_voucher_libtrace_hooks + 40))();
    *(_BYTE *)(a1 + 1569) = 1;
    v43 = (unint64_t *)(a1 + 768);
    v42 = *(_QWORD *)(a1 + 768);
    if (BYTE4(v42) && BYTE4(*(_QWORD *)(a1 + 768)) != 255)
    {
      v57 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v42) << 12));
      v56 = -1;
      v55 = 1;
      v54 = 0;
      v53 = 1;
      v52 = 0;
      v51 = 0;
      v50 = 24;
      v49 = 0;
      v48 = 0;
      v46 = (-1 - v57[1]) >> 48 == 0;
      v44 = v57;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v15 = __ldaxr(v44);
        else
          v15 = __ldxr(v44);
        v49 = v15;
        if (!v15 || (HIWORD(v49) & 0x1FF) != (unint64_t)v55)
        {
          __clrex();
          v58 = 0;
          goto LABEL_35;
        }
        v48 = v49;
        v104 = &v49;
        v103 = v53 + v52 + 24;
        if ((unsigned __int16)v49 + v103 <= WORD1(v49) && v46)
        {
          if (v54 > (int)BYTE5(v48))
            BYTE5(v48) = v54;
          if ((((_BYTE)v53 + 24) & 7) != 0)
            v30 = ((v53 + 24) & 0x1FFF8) + 8;
          else
            v30 = v53 + 24;
          v48 += v30;
          v48 -= (unint64_t)v52 << 16;
          v48 += 0x100000000;
          v102 = &v48;
          v101 = 40;
          if ((unsigned __int16)v48 + 40 > WORD1(v48))
            HIBYTE(v48) |= 1u;
          v47 = 0;
        }
        else
        {
          HIBYTE(v48) |= 1u;
          v47 = 1;
        }
        if (_os_atomic_mo_has_release(0))
          v45 = __stlxr(v48, v44) == 0;
        else
          v45 = __stxr(v48, v44) == 0;
      }
      while (!v45);
      if ((v47 & 1) != 0)
      {
        if (BYTE4(v48))
          v58 = 0;
        else
          v58 = -1;
      }
      else
      {
        if (v51)
          *v51 = (char *)v57 + WORD1(v48);
        v58 = (unsigned __int16)v49;
      }
LABEL_35:
      v40 = v58;
      if (v58 < 0)
        firehose_buffer_ring_enqueue(a1, BYTE4(v42));
      if (v40 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v40;
        __break(1u);
        JUMPOUT(0xA5218);
      }
      v41 = v42;
      BYTE4(v41) = 0;
      do
        v16 = __ldaxr(v43);
      while (v16 == v42 && __stlxr(v41, v43));
    }
    else
    {
      firehose_buffer_force_connect(a1, v1, v2, v3, v4, v5, v6, v7);
    }
    v39 = (unint64_t *)(a1 + 640);
    v38 = *(_QWORD *)(a1 + 640);
    if (BYTE4(v38) && BYTE4(*(_QWORD *)(a1 + 640)) != 255)
    {
      v74 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v38) << 12));
      v73 = -1;
      v72 = 0;
      v71 = 0;
      v70 = 1;
      v69 = 0;
      v68 = 0;
      v67 = 24;
      v66 = 0;
      v65 = 0;
      v64 = 0;
      v63 = 0;
      v63 = (-1 - v74[1]) >> 48 == 0;
      v62 = 0;
      v61 = v74;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v24 = __ldaxr(v61);
        else
          v24 = __ldxr(v61);
        v66 = v24;
        if (!v24 || (HIWORD(v66) & 0x1FF) != (unint64_t)v72)
        {
          __clrex();
          v75 = 0;
          goto LABEL_74;
        }
        v65 = v66;
        v100 = &v66;
        v99 = v70 + v69 + 24;
        if ((unsigned __int16)v66 + v99 <= WORD1(v66) && v63)
        {
          if (v71 > (int)BYTE5(v65))
            BYTE5(v65) = v71;
          if ((((_BYTE)v70 + 24) & 7) != 0)
            v29 = ((v70 + 24) & 0x1FFF8) + 8;
          else
            v29 = v70 + 24;
          v65 += v29;
          v65 -= (unint64_t)v69 << 16;
          v65 += 0x100000000;
          v60 = 16;
          v98 = &v65;
          v97 = 40;
          if ((unsigned __int16)v65 + 40 > WORD1(v65))
            HIBYTE(v65) |= 1u;
          v64 = 0;
        }
        else
        {
          HIBYTE(v65) |= 1u;
          v64 = 1;
        }
        if (_os_atomic_mo_has_release(0))
          v62 = __stlxr(v65, v61) == 0;
        else
          v62 = __stxr(v65, v61) == 0;
      }
      while (!v62);
      v59 = v62;
      if ((v64 & 1) != 0)
      {
        if (BYTE4(v65))
          v75 = 0;
        else
          v75 = -1;
      }
      else
      {
        if (v68)
          *v68 = (char *)v74 + WORD1(v65);
        v75 = (unsigned __int16)v66;
      }
LABEL_74:
      v36 = v75;
      if (v75 < 0)
        firehose_buffer_ring_enqueue(a1, BYTE4(v38));
      if (v36 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v36;
        __break(1u);
        JUMPOUT(0xA5704);
      }
      v37 = v38;
      BYTE4(v37) = 0;
      do
        v25 = __ldaxr(v39);
      while (v25 == v38 && __stlxr(v37, v39));
    }
    else
    {
      firehose_buffer_force_connect(a1, v8, v9, v10, v11, v12, v13, v14);
    }
    v35 = (unint64_t *)(a1 + 896);
    v34 = *(_QWORD *)(a1 + 896);
    if (BYTE4(v34) && BYTE4(*(_QWORD *)(a1 + 896)) != 255)
    {
      v91 = (unint64_t *)(a1 + ((unint64_t)BYTE4(v34) << 12));
      v90 = -1;
      v89 = 2;
      v88 = 0;
      v87 = 1;
      v86 = 0;
      v85 = 0;
      v84 = 24;
      v83 = 0;
      v82 = 0;
      v81 = 0;
      v80 = 0;
      v80 = (-1 - v91[1]) >> 48 == 0;
      v79 = 0;
      v78 = v91;
      do
      {
        if (_os_atomic_mo_has_acquire(0))
          v26 = __ldaxr(v78);
        else
          v26 = __ldxr(v78);
        v83 = v26;
        if (!v26 || (HIWORD(v83) & 0x1FF) != (unint64_t)v89)
        {
          __clrex();
          v92 = 0;
          goto LABEL_113;
        }
        v82 = v83;
        v96 = &v83;
        v95 = v87 + v86 + 24;
        if ((unsigned __int16)v83 + v95 <= WORD1(v83) && v80)
        {
          if (v88 > (int)BYTE5(v82))
            BYTE5(v82) = v88;
          if ((((_BYTE)v87 + 24) & 7) != 0)
            v28 = ((v87 + 24) & 0x1FFF8) + 8;
          else
            v28 = v87 + 24;
          v82 += v28;
          v82 -= (unint64_t)v86 << 16;
          v82 += 0x100000000;
          v77 = 16;
          v94 = &v82;
          v93 = 40;
          if ((unsigned __int16)v82 + 40 > WORD1(v82))
            HIBYTE(v82) |= 1u;
          v81 = 0;
        }
        else
        {
          HIBYTE(v82) |= 1u;
          v81 = 1;
        }
        if (_os_atomic_mo_has_release(0))
          v79 = __stlxr(v82, v78) == 0;
        else
          v79 = __stxr(v82, v78) == 0;
      }
      while (!v79);
      v76 = v79;
      if ((v81 & 1) != 0)
      {
        if (BYTE4(v82))
          v92 = 0;
        else
          v92 = -1;
      }
      else
      {
        if (v85)
          *v85 = (char *)v91 + WORD1(v82);
        v92 = (unsigned __int16)v83;
      }
LABEL_113:
      v32 = v92;
      if (v92 < 0)
        firehose_buffer_ring_enqueue(a1, BYTE4(v34));
      if (v32 >= 1)
      {
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: Allocation should always fail";
        qword_E4DA8 = v32;
        __break(1u);
        JUMPOUT(0xA5BF4);
      }
      v33 = v34;
      BYTE4(v33) = 0;
      do
        v27 = __ldaxr(v35);
      while (v27 == v34 && __stlxr(v33, v35));
    }
    else
    {
      firehose_buffer_force_connect(a1, v17, v18, v19, v20, v21, v22, v23);
    }
  }
}

void __FIREHOSE_CLIENT_THROTTLED_DUE_TO_HEAVY_LOGGING__(_QWORD *a1, char a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  firehose_client_send_push_and_wait(a1, a2 & 1, a3, a4, a5, a6, a7, a8);
}

void firehose_client_send_push_and_wait(_QWORD *a1, char a2, _QWORD *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t *v19;
  unint64_t v20;
  unint64_t *v21;
  unint64_t v22;
  BOOL v23;
  _QWORD __s2[5];
  int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  int v30;
  __int128 __s1;
  int v32;
  unsigned __int8 v33;
  _QWORD *v34;
  char v35;
  _QWORD *v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;

  v36 = a1;
  v35 = a2;
  v34 = a3;
  v33 = a2 & 1;
  v32 = 0;
  v32 = *((_DWORD *)a1 + (a2 & 1) + 388);
  __s1 = 0uLL;
  v30 = 0;
  v29 = 0;
  if (v32 == -1)
    return;
  if (v32)
  {
    v29 = firehose_send_push_and_wait(v32, &__s1, &v30);
    if (!v29)
      goto LABEL_23;
    if (v29 != 268435459)
    {
      if (v29 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0xA5E00);
      }
      v28 = v29;
      v40 = v29;
      v39 = 681;
      _dispatch_bug(v39, v40, v8, a4, a5, a6, a7, a8);
      v27 = v28;
    }
  }
  v32 = firehose_client_reconnect((mach_port_context_t)v36, v32, v33, a4, a5, a6, a7, a8);
  v23 = 0;
  if (v32)
    v23 = v32 != -1;
  if (!v23)
    goto LABEL_20;
  v29 = firehose_send_push_and_wait(v32, &__s1, &v30);
  if (v29)
  {
    if (v29 != 268435459)
    {
      if (v29 == -301)
      {
        qword_E4D78 = (uint64_t)"MIG_REPLY_MISMATCH";
        qword_E4DA8 = -301;
        __break(1u);
        JUMPOUT(0xA5F24);
      }
      v26 = v29;
      v38 = v29;
      v37 = 693;
      _dispatch_bug(v37, v38, v9, v10, v11, v12, v13, v14);
      v25 = v26;
    }
LABEL_20:
    if (v34)
    {
      __s2[4] = 0;
      *v34 = v36[56];
    }
    return;
  }
LABEL_23:
  __s2[0] = -1;
  __s2[1] = -1;
  if (!memcmp(&__s1, __s2, 0x10uLL))
  {
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Memory corruption in the logging buffers";
    __break(1u);
    JUMPOUT(0xA6008);
  }
  if ((v35 & 1) != 0)
  {
    v21 = v36 + 63;
    v22 = v36[63];
    do
    {
      v15 = v22;
      do
        v16 = __ldaxr(v21);
      while (v16 == v22 && __stlxr(v22 + 1, v21));
      v22 = v16;
    }
    while (v16 != v15);
  }
  else
  {
    v19 = v36 + 60;
    v20 = v36[60];
    do
    {
      v17 = v20;
      do
        v18 = __ldaxr(v19);
      while (v18 == v20 && __stlxr(v20 + 1, v19));
      v20 = v18;
    }
    while (v18 != v17);
  }
  firehose_client_merge_updates((uint64_t)v36, 0, __s1, *((unint64_t *)&__s1 + 1), v30 != 0, v34);
}

uint64_t _dispatch_iocntl(uint64_t result)
{
  unint64_t v1;

  v1 = (result - 1);
  if (v1 <= 3)
    __asm { BR              X8 }
  return result;
}

void _dispatch_io_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_dispose");
  if (*(_QWORD *)(a1 + 112) && (*(_DWORD *)(a1 + 120) & 3) == 0)
  {
    if (*(_QWORD *)(*(_QWORD *)(a1 + 112) + 8))
      **(_QWORD **)(*(_QWORD *)(a1 + 112) + 8) = 0;
    _dispatch_fd_entry_release(*(_QWORD *)(a1 + 112));
  }
  if (*(_QWORD *)(a1 + 48))
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  if (*(_QWORD *)(a1 + 56))
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  if (*(_QWORD *)(a1 + 64))
    dispatch_release(*(dispatch_object_t *)(a1 + 64));
}

void _dispatch_fd_entry_release(uint64_t a1)
{
  dispatch_resume(*(dispatch_object_t *)(a1 + 64));
}

dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void *cleanup_handler)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  void **v22;
  int v23;
  int v24;
  void (*v25)(uint64_t *, uint64_t);
  void *v26;
  void *v27;
  _QWORD *v28;
  dispatch_io_type_t v29;
  dispatch_queue_t v30;
  _QWORD *v31;
  dispatch_queue_t v32;
  dispatch_object_t v33;
  _QWORD *v34;
  void *v35;
  dispatch_queue_t v36;
  dispatch_fd_t v37;
  dispatch_io_type_t v38;

  v38 = type;
  v37 = fd;
  v36 = queue;
  v35 = cleanup_handler;
  if (type && v38 != 1)
    return 0;
  v34 = _dispatch_io_create(v38, *(uint64_t *)&fd, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  *((_DWORD *)v34 + 31) = v37;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create", v8, v9, v10, v11, v12, v13, v14, 363);
  *((_DWORD *)v34 + 32) = v37;
  v33 = (dispatch_object_t)v34[6];
  dispatch_suspend(v33);
  v32 = v36;
  _dispatch_retain((uint64_t)v36);
  v31 = v34;
  _dispatch_retain((uint64_t)v34);
  v22 = _NSConcreteStackBlock;
  v23 = 1107296256;
  v24 = 0;
  v25 = __dispatch_io_create_block_invoke;
  v26 = &__block_descriptor_tmp_1;
  v28 = v34;
  v29 = v38;
  v30 = v36;
  v27 = v35;
  _dispatch_fd_entry_init_async(v37, (uint64_t)&v22);
  _dispatch_object_debug((uint64_t)v34, "%s", v15, v16, v17, v18, v19, v20, (char)"dispatch_io_create");
  return (dispatch_io_t)v34;
}

_QWORD *_dispatch_io_create(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;

  v9 = _dispatch_object_alloc((uint64_t)_OS_dispatch_io_vtable, 0x98uLL, a3, a4, a5, a6, a7, a8);
  v9[2] = -1985229329;
  v9[3] = &off_E46C0;
  v9[9] = a1;
  v9[11] = -1;
  v9[10] = qword_E4D30 * dispatch_io_defaults;
  v9[6] = dispatch_queue_create("com.apple.libdispatch-io.channelq", 0);
  return v9;
}

void _dispatch_fd_entry_init_async(int a1, uint64_t a2)
{
  void **block;
  int v3;
  int v4;
  void (*v5)(uint64_t);
  void *v6;
  uint64_t v7;
  int v8;
  uint64_t v9;
  int v10;
  dispatch_queue_t (*v11)();
  void *v12;
  dispatch_once_t *v13;

  v10 = a1;
  v9 = a2;
  v13 = &_dispatch_io_init_pred;
  v12 = 0;
  v11 = _dispatch_io_queues_init;
  if (_dispatch_io_init_pred != -1)
    dispatch_once_f(v13, v12, (dispatch_function_t)v11);
  block = _NSConcreteStackBlock;
  v3 = 1107296256;
  v4 = 0;
  v5 = ___dispatch_fd_entry_init_async_block_invoke;
  v6 = &__block_descriptor_tmp_125;
  v8 = v10;
  v7 = v9;
  dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
}

void __dispatch_io_create_block_invoke(uint64_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  int v14;
  off_t v16;
  int v17;

  v17 = *(_DWORD *)(a2 + 24);
  if (!v17)
    v17 = _dispatch_io_validate_type(a1[5], *(_WORD *)(a2 + 36));
  if (!v17 && a1[6] == 1)
  {
    do
    {
      v16 = lseek(*(_DWORD *)a2, 0, 1);
      if (v16 == -1)
        v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      else
        v14 = 0;
      v17 = v14;
      if (!v14)
      {
        *(_QWORD *)(a1[5] + 136) = v16;
        goto LABEL_13;
      }
    }
    while (v14 == 4);
    _dispatch_bug(389, v14, v2, v3, v4, v5, v6, v7);
  }
LABEL_13:
  *(_DWORD *)(a1[5] + 144) = v17;
  _dispatch_fd_entry_retain(a2);
  _dispatch_io_init((_QWORD *)a1[5], a2, a1[7], v17, a1[4]);
  dispatch_resume(*(dispatch_object_t *)(a1[5] + 48));
  _dispatch_object_debug(a1[5], "%s", v8, v9, v10, v11, v12, v13, (char)"dispatch_io_create_block_invoke");
  _dispatch_release((unsigned int *)a1[5]);
  _dispatch_release((unsigned int *)a1[7]);
}

uint64_t _dispatch_io_validate_type(uint64_t a1, __int16 a2)
{
  unsigned int v3;

  v3 = 0;
  if ((a2 & 0xF000) == 0x4000)
  {
    return 21;
  }
  else if (*(_QWORD *)(a1 + 72) == 1 && ((a2 & 0xF000) == 0x1000 || (a2 & 0xF000) == 0xC000))
  {
    return 29;
  }
  return v3;
}

void _dispatch_fd_entry_retain(uint64_t a1)
{
  dispatch_suspend(*(dispatch_object_t *)(a1 + 64));
}

void _dispatch_io_init(_QWORD *a1, uint64_t a2, uint64_t a3, int a4, uint64_t a5)
{
  dispatch_queue_t v5;
  dispatch_queue_s *queue;
  void **block;
  int v8;
  int v9;
  void (*v10)(uint64_t);
  void *v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD *v14;
  int v15;
  uint64_t v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  uint64_t v20;
  _QWORD *v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  if (a5)
  {
    v16 = v19;
    _dispatch_retain(v19);
    if (v18)
      queue = (dispatch_queue_s *)v21[6];
    else
      queue = *(dispatch_queue_s **)(v20 + 64);
    block = _NSConcreteStackBlock;
    v8 = 1107296256;
    v9 = 0;
    v10 = ___dispatch_io_init_block_invoke;
    v11 = &__block_descriptor_tmp_65;
    v13 = v19;
    v14 = v21;
    v15 = v18;
    v12 = v17;
    dispatch_channel_async(queue, &block);
  }
  if (v20)
  {
    v21[14] = v20;
    dispatch_retain(*(dispatch_object_t *)(v20 + 72));
    dispatch_retain(*(dispatch_object_t *)(v20 + 80));
    v21[7] = *(_QWORD *)(v20 + 72);
    v21[8] = *(_QWORD *)(v20 + 80);
  }
  else
  {
    v5 = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
    v21[7] = v5;
    v21[8] = dispatch_group_create();
  }
}

void __copy_helper_block_8_32b(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 7);
}

void __destroy_helper_block_8_32b(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 32), 7);
}

dispatch_io_t dispatch_io_create_f(dispatch_io_type_t a1, dispatch_fd_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  void **v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t, unsigned int);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_queue_s *v15;
  dispatch_fd_t v16;
  dispatch_io_type_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  if (!a5)
    return dispatch_io_create(a1, a2, a3, 0);
  v6 = _NSConcreteStackBlock;
  v7 = 0x40000000;
  v8 = 0;
  v9 = __dispatch_io_create_f_block_invoke;
  v10 = &__block_descriptor_tmp_4;
  v11 = v13;
  v12 = v14;
  return dispatch_io_create(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_path(dispatch_io_type_t type, const char *path, int oflag, mode_t mode, dispatch_queue_t queue, void *cleanup_handler)
{
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  dispatch_queue_s *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  void **block;
  int v29;
  int v30;
  void (*v31)(uint64_t);
  void *v32;
  void *v33;
  uint64_t v34;
  _QWORD *v35;
  dispatch_queue_t v36;
  _QWORD *v37;
  dispatch_queue_t v38;
  _QWORD *v39;
  uint64_t v40;
  size_t v41;
  void *v42;
  dispatch_queue_t v43;
  mode_t v44;
  int v45;
  const char *v46;
  dispatch_io_type_t v47;

  v47 = type;
  v46 = path;
  v45 = oflag;
  v44 = mode;
  v43 = queue;
  v42 = cleanup_handler;
  if (type && v47 != 1)
    return 0;
  if (*v46 != 47)
    return 0;
  v41 = strlen(v46);
  v40 = malloc_type_malloc(v41 + 25, 1527294340);
  if (!v40)
    return 0;
  v39 = _dispatch_io_create(v47, v6, v7, v8, v9, v10, v11, v12);
  *((_DWORD *)v39 + 31) = -1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create with path %s", v13, v14, v15, v16, v17, v18, v19, 444);
  *((_DWORD *)v39 + 32) = -1;
  *(_QWORD *)v40 = v39;
  *(_DWORD *)(v40 + 8) = v45;
  *(_WORD *)(v40 + 12) = v44;
  *(_QWORD *)(v40 + 16) = v41;
  __memcpy_chk(v40 + 24, v46, v41 + 1, -1);
  v38 = v43;
  _dispatch_retain((uint64_t)v43);
  v37 = v39;
  _dispatch_retain((uint64_t)v39);
  v20 = (dispatch_queue_s *)v39[6];
  block = _NSConcreteStackBlock;
  v29 = 1107296256;
  v30 = 0;
  v31 = __dispatch_io_create_with_path_block_invoke;
  v32 = &__block_descriptor_tmp_8;
  v34 = v40;
  v35 = v39;
  v36 = v43;
  v33 = v42;
  dispatch_channel_async(v20, &block);
  _dispatch_object_debug((uint64_t)v39, "%s", v21, v22, v23, v24, v25, v26, (char)"dispatch_io_create_with_path");
  return (dispatch_io_t)v39;
}

void __dispatch_io_create_with_path_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  int v7;
  int v8;
  int v9;
  void **v11;
  int v12;
  int v13;
  void (*v14)(uint64_t);
  void *v15;
  uint64_t v16;
  uint64_t v17;
  _BYTE v18[144];
  uint64_t v19;
  uint64_t v20;
  dispatch_object_t object;
  unsigned int *v22;
  int v23;
  uint64_t i;
  _BYTE *v25;
  stat __b;
  int v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  _BYTE *v31;
  dispatch_queue_t (*v32)();
  void *v33;
  dispatch_once_t *v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  unint64_t StatusReg;
  unint64_t v40;

  v29 = a1;
  v28 = a1;
  v27 = 0;
  memset(&__b, 0, sizeof(__b));
  do
  {
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) & 0x100) == 0x100
      || (*(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) & 0x200000) == 0x200000)
    {
      v9 = lstat((const char *)(*(_QWORD *)(a1 + 40) + 24), &__b);
    }
    else
    {
      v9 = stat((const char *)(*(_QWORD *)(a1 + 40) + 24), &__b);
    }
    if (v9 == -1)
    {
      v35 = 1;
      v38 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v8 = **(_DWORD **)(StatusReg + 8);
    }
    else
    {
      v8 = 0;
    }
    v27 = v8;
    if (!v8)
    {
      v27 = _dispatch_io_validate_type(*(_QWORD *)(a1 + 48), __b.st_mode);
      goto LABEL_31;
    }
  }
  while (v8 == 4);
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 40) + 8) & 0x200) != 0
    && *(_BYTE *)(*(_QWORD *)(a1 + 40) + 24 + *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) - 1) != 47)
  {
    v25 = 0;
    i = 0;
    for (i = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 16) - 1; i >= 0; --i)
    {
      if (*(_BYTE *)(*(_QWORD *)(a1 + 40) + 24 + i) == 47)
      {
        v25 = (_BYTE *)(*(_QWORD *)(a1 + 40) + 24 + i);
        break;
      }
    }
    v31 = v25;
    v30 = 480;
    if (!v25)
      _dispatch_abort(v30, 0, v1, v2, v3, v4, v5, v6);
    *v25 = 0;
    v23 = 0;
    while (1)
    {
      if (stat((const char *)(*(_QWORD *)(a1 + 40) + 24), &__b) == -1)
      {
        v36 = 1;
        v37 = 1;
        v40 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v7 = **(_DWORD **)(v40 + 8);
      }
      else
      {
        v7 = 0;
      }
      v23 = v7;
      if (!v7)
        break;
      if (v7 != 4)
        goto LABEL_30;
    }
    __b.st_mode = 0x8000;
    v27 = 0;
LABEL_30:
    *v25 = 47;
  }
LABEL_31:
  *(_DWORD *)(*(_QWORD *)(a1 + 48) + 144) = v27;
  if (v27)
  {
    free(*(void **)(a1 + 40));
    _dispatch_io_init(*(_QWORD **)(a1 + 48), 0, *(_QWORD *)(a1 + 56), v27, *(_QWORD *)(a1 + 32));
    v22 = *(unsigned int **)(a1 + 48);
    _dispatch_release(v22);
    _dispatch_release(*(unsigned int **)(a1 + 56));
  }
  else
  {
    object = *(dispatch_object_t *)(*(_QWORD *)(a1 + 48) + 48);
    dispatch_suspend(object);
    v34 = &_dispatch_io_init_pred;
    v33 = 0;
    v32 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1)
      dispatch_once_f(v34, v33, (dispatch_function_t)v32);
    v11 = _NSConcreteStackBlock;
    v12 = 1107296256;
    v13 = 0;
    v14 = __dispatch_io_create_with_path_block_invoke_2;
    v15 = &__block_descriptor_tmp_7;
    v17 = *(_QWORD *)(a1 + 40);
    memcpy(v18, &__b, sizeof(v18));
    v19 = *(_QWORD *)(a1 + 48);
    v20 = *(_QWORD *)(a1 + 56);
    v16 = *(_QWORD *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &v11);
  }
}

dispatch_queue_t _dispatch_io_queues_init()
{
  dispatch_queue_t result;

  _dispatch_io_fds_lockq = (uint64_t)dispatch_queue_create("com.apple.libdispatch-io.fd_lockq", 0);
  result = dispatch_queue_create("com.apple.libdispatch-io.dev_lockq", 0);
  _dispatch_io_devs_lockq = (uint64_t)result;
  return result;
}

void __dispatch_io_create_with_path_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _QWORD *v8;

  v8 = _dispatch_fd_entry_create_with_path(*(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 48), *(_WORD *)(a1 + 52));
  _dispatch_io_init(*(_QWORD **)(a1 + 192), (uint64_t)v8, *(_QWORD *)(a1 + 200), 0, *(_QWORD *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 192) + 48));
  _dispatch_object_debug(*(_QWORD *)(a1 + 192), "%s", v1, v2, v3, v4, v5, v6, (char)"dispatch_io_create_with_path_block_invoke_2");
  _dispatch_release(*(unsigned int **)(a1 + 192));
  _dispatch_release(*(unsigned int **)(a1 + 200));
}

_QWORD *_dispatch_fd_entry_create_with_path(uint64_t a1, int a2, __int16 a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  dispatch_queue_s *v16;
  dispatch_queue_s *v17;
  void **v19;
  int v20;
  int v21;
  void (*v22)(uint64_t);
  void *v23;
  _QWORD *v24;
  void **block;
  int v26;
  int v27;
  void (*v28)(uint64_t);
  void *v29;
  _QWORD *v30;
  _QWORD *v31;
  __int16 v32;
  int v33;
  uint64_t v34;

  v34 = a1;
  v33 = a2;
  v32 = a3;
  v31 = 0;
  v31 = (_QWORD *)_dispatch_fd_entry_create(*(dispatch_queue_s **)(*(_QWORD *)a1 + 48));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: path %s", v3, v4, v5, v6, v7, v8, v9, 1588);
  if ((v32 & 0xF000) == 0x8000)
    _dispatch_disk_init(v31, HIBYTE(v33), v10, v11, v12, v13, v14, v15);
  else
    _dispatch_stream_init((uint64_t)v31, (dispatch_queue_s *)&off_E4640);
  *(_DWORD *)v31 = -1;
  *((_DWORD *)v31 + 4) = -1;
  v31[1] = v34;
  *((_DWORD *)v31 + 8) = v33;
  *((_WORD *)v31 + 18) = v32;
  v31[9] = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
  v31[10] = dispatch_group_create();
  v16 = (dispatch_queue_s *)v31[8];
  block = _NSConcreteStackBlock;
  v26 = 0x40000000;
  v27 = 0;
  v28 = ___dispatch_fd_entry_create_with_path_block_invoke;
  v29 = &__block_descriptor_tmp_141;
  v30 = v31;
  dispatch_channel_async(v16, &block);
  v17 = (dispatch_queue_s *)v31[8];
  v19 = _NSConcreteStackBlock;
  v20 = 0x40000000;
  v21 = 0;
  v22 = ___dispatch_fd_entry_create_with_path_block_invoke_2;
  v23 = &__block_descriptor_tmp_142;
  v24 = v31;
  dispatch_channel_async(v17, &v19);
  return v31;
}

dispatch_io_t dispatch_io_create_with_path_f(dispatch_io_type_t a1, const char *a2, int a3, mode_t a4, dispatch_queue_s *a5, uint64_t a6, uint64_t a7)
{
  void **v8;
  int v9;
  int v10;
  uint64_t (*v11)(uint64_t, unsigned int);
  void *v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  dispatch_queue_s *v17;
  mode_t v18;
  int v19;
  const char *v20;
  dispatch_io_type_t v21;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a6;
  v15 = a7;
  if (!a7)
    return dispatch_io_create_with_path(a1, a2, a3, a4, a5, 0);
  v8 = _NSConcreteStackBlock;
  v9 = 0x40000000;
  v10 = 0;
  v11 = __dispatch_io_create_with_path_f_block_invoke;
  v12 = &__block_descriptor_tmp_9;
  v13 = v15;
  v14 = v16;
  return dispatch_io_create_with_path(a1, a2, a3, a4, a5, &v8);
}

uint64_t __dispatch_io_create_with_path_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2);
}

dispatch_io_t dispatch_io_create_with_io(dispatch_io_type_t type, dispatch_io_t io, dispatch_queue_t queue, void *cleanup_handler)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_queue_s *v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  void **block;
  int v24;
  int v25;
  void (*v26)(uint64_t *);
  void *v27;
  void *v28;
  dispatch_io_t v29;
  _QWORD *v30;
  dispatch_queue_t v31;
  dispatch_io_type_t v32;
  dispatch_io_t v33;
  _QWORD *v34;
  dispatch_queue_t v35;
  dispatch_object_t v36;
  _QWORD *v37;
  void *v38;
  dispatch_queue_t v39;
  dispatch_io_t v40;
  dispatch_io_type_t v41;

  v41 = type;
  v40 = io;
  v39 = queue;
  v38 = cleanup_handler;
  if (type && v41 != 1)
    return 0;
  v37 = _dispatch_io_create(v41, (uint64_t)io, (uint64_t)queue, (uint64_t)cleanup_handler, v4, v5, v6, v7);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: create with channel %p", v8, v9, v10, v11, v12, v13, v14, 544);
  v36 = (dispatch_object_t)v37[6];
  dispatch_suspend(v36);
  v35 = v39;
  _dispatch_retain((uint64_t)v39);
  v34 = v37;
  _dispatch_retain((uint64_t)v37);
  v33 = v40;
  _dispatch_retain((uint64_t)v40);
  v15 = (dispatch_queue_s *)*((_QWORD *)v40 + 6);
  block = _NSConcreteStackBlock;
  v24 = 1107296256;
  v25 = 0;
  v26 = __dispatch_io_create_with_io_block_invoke;
  v27 = &__block_descriptor_tmp_13;
  v29 = v40;
  v30 = v37;
  v31 = v39;
  v28 = v38;
  v32 = v41;
  dispatch_channel_async(v15, &block);
  _dispatch_object_debug((uint64_t)v37, "%s", v16, v17, v18, v19, v20, v21, (char)"dispatch_io_create_with_io");
  return (dispatch_io_t)v37;
}

void __dispatch_io_create_with_io_block_invoke(uint64_t *a1)
{
  dispatch_queue_s *v1;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t *);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  unsigned int *v13;
  unsigned int *v14;
  dispatch_object_t v15;
  int error;
  uint64_t *v17;
  uint64_t *v18;

  v18 = a1;
  v17 = a1;
  error = 0;
  error = _dispatch_io_get_error(0, a1[5], 0);
  if (error)
  {
    *(_DWORD *)(a1[6] + 144) = error;
    _dispatch_io_init((_QWORD *)a1[6], 0, a1[7], error, a1[4]);
    v15 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v15);
    v14 = (unsigned int *)a1[6];
    _dispatch_release(v14);
    v13 = (unsigned int *)a1[5];
    _dispatch_release(v13);
    _dispatch_release((unsigned int *)a1[7]);
  }
  else
  {
    v1 = *(dispatch_queue_s **)(a1[5] + 56);
    block = _NSConcreteStackBlock;
    v4 = 1107296256;
    v5 = 0;
    v6 = __dispatch_io_create_with_io_block_invoke_2;
    v7 = &__block_descriptor_tmp_12;
    v9 = a1[5];
    v10 = a1[6];
    v11 = a1[8];
    v12 = a1[7];
    v8 = a1[4];
    dispatch_channel_async(v1, &block);
  }
}

uint64_t _dispatch_io_get_error(uint64_t a1, uint64_t a2, char a3)
{
  if (a1)
    a2 = *(_QWORD *)(a1 + 136);
  if ((*(_DWORD *)(a2 + 120) & 3) != 0)
  {
    if ((a3 & 1) != 0 && (*(_DWORD *)(a2 + 120) & 2) == 0)
      return 0;
    else
      return 89;
  }
  else if (a1)
  {
    return *(unsigned int *)(*(_QWORD *)(a1 + 144) + 24);
  }
  else
  {
    return *(unsigned int *)(a2 + 144);
  }
}

void __dispatch_io_create_with_io_block_invoke_2(uint64_t *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  int v13;
  uint64_t v15;
  void **block;
  int v17;
  int v18;
  void (*v19)(uint64_t);
  void *v20;
  uint64_t v21;
  _QWORD *v22;
  uint64_t v23;
  uint64_t v24;
  int v25;
  __int16 v26;
  _QWORD *v27;
  uint64_t v28;
  int v29;
  __int16 v30;
  unsigned int *v31;
  unsigned int *v32;
  dispatch_object_t v33;
  int v34;
  int v35;
  off_t v36;
  int error;
  uint64_t *v38;
  uint64_t *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  unint64_t StatusReg;

  v39 = a1;
  v38 = a1;
  error = 0;
  error = _dispatch_io_get_error(0, a1[5], 0);
  if (!error)
  {
    error = *(_DWORD *)(a1[5] + 144);
    if (!error)
      error = *(_DWORD *)(*(_QWORD *)(a1[5] + 112) + 24);
  }
  if (!error)
    error = _dispatch_io_validate_type(a1[6], *(_WORD *)(*(_QWORD *)(a1[5] + 112) + 36));
  if (!error && a1[7] == 1 && *(_DWORD *)(a1[5] + 124) != -1)
  {
    v36 = 0;
    do
    {
      v36 = lseek(**(_DWORD **)(a1[5] + 112), 0, 1);
      if (v36 == -1)
      {
        v42 = 1;
        v43 = 1;
        StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v13 = **(_DWORD **)(StatusReg + 8);
      }
      else
      {
        v13 = 0;
      }
      error = v13;
      if (!v13)
      {
        *(_QWORD *)(a1[6] + 136) = v36;
        goto LABEL_20;
      }
    }
    while (v13 == 4);
    v35 = error;
    v41 = error;
    v40 = 590;
    if (error)
      _dispatch_bug(v40, v41, v1, v2, v3, v4, v5, v6);
    v34 = v35;
  }
LABEL_20:
  *(_DWORD *)(a1[6] + 144) = error;
  if (error)
  {
    _dispatch_io_init((_QWORD *)a1[6], 0, a1[8], error, a1[4]);
    v33 = *(dispatch_object_t *)(a1[6] + 48);
    dispatch_resume(v33);
    v32 = (unsigned int *)a1[6];
    _dispatch_release(v32);
    v31 = (unsigned int *)a1[5];
    _dispatch_release(v31);
    _dispatch_release((unsigned int *)a1[8]);
  }
  else
  {
    if (*(_DWORD *)(a1[5] + 124) == -1)
    {
      *(_DWORD *)(a1[6] + 124) = -1;
      *(_DWORD *)(a1[6] + 128) = -1;
      v30 = 0;
      v30 = *(_WORD *)(*(_QWORD *)(a1[5] + 112) + 36);
      v29 = 0;
      v29 = *(_DWORD *)(*(_QWORD *)(a1[5] + 112) + 32);
      v28 = 0;
      v28 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1[5] + 112) + 8) + 16) + 25;
      v27 = (_QWORD *)malloc_type_malloc(v28, 743473637);
      __memcpy_chk(v27, *(_QWORD *)(*(_QWORD *)(a1[5] + 112) + 8), v28, -1);
      *v27 = a1[6];
      block = _NSConcreteStackBlock;
      v17 = 1107296256;
      v18 = 0;
      v19 = __dispatch_io_create_with_io_block_invoke_3;
      v20 = &__block_descriptor_tmp_11;
      v22 = v27;
      v25 = v29;
      v26 = v30;
      v23 = a1[6];
      v24 = a1[8];
      v21 = a1[4];
      dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
    }
    else
    {
      v15 = *(_QWORD *)(a1[5] + 112);
      *(_DWORD *)(a1[6] + 124) = *(_DWORD *)(a1[5] + 124);
      *(_DWORD *)(a1[6] + 128) = *(_DWORD *)(a1[5] + 128);
      _dispatch_fd_entry_retain(v15);
      _dispatch_io_init((_QWORD *)a1[6], v15, a1[8], 0, a1[4]);
      dispatch_resume(*(dispatch_object_t *)(a1[6] + 48));
      _dispatch_release((unsigned int *)a1[6]);
      _dispatch_release((unsigned int *)a1[8]);
    }
    _dispatch_release((unsigned int *)a1[5]);
    _dispatch_object_debug(a1[6], "%s", v7, v8, v9, v10, v11, v12, (char)"dispatch_io_create_with_io_block_invoke");
  }
}

void __dispatch_io_create_with_io_block_invoke_3(uint64_t a1)
{
  _QWORD *v2;

  v2 = _dispatch_fd_entry_create_with_path(*(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 64), *(_WORD *)(a1 + 68));
  _dispatch_io_init(*(_QWORD **)(a1 + 48), (uint64_t)v2, *(_QWORD *)(a1 + 56), 0, *(_QWORD *)(a1 + 32));
  dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 48) + 48));
  _dispatch_release(*(unsigned int **)(a1 + 48));
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

dispatch_io_t dispatch_io_create_with_io_f(dispatch_io_type_t a1, dispatch_io_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  void **v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t, unsigned int);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_queue_s *v15;
  dispatch_io_s *v16;
  dispatch_io_type_t v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  if (!a5)
    return dispatch_io_create_with_io(a1, a2, a3, 0);
  v6 = _NSConcreteStackBlock;
  v7 = 0x40000000;
  v8 = 0;
  v9 = __dispatch_io_create_with_io_f_block_invoke;
  v10 = &__block_descriptor_tmp_14;
  v11 = v13;
  v12 = v14;
  return dispatch_io_create_with_io(a1, a2, a3, &v6);
}

uint64_t __dispatch_io_create_with_io_f_block_invoke(uint64_t a1, unsigned int a2)
{
  return (*(uint64_t (**)(_QWORD, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2);
}

void dispatch_io_set_high_water(dispatch_io_t channel, size_t high_water)
{
  dispatch_queue_s *v2;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  dispatch_io_t v8;
  size_t v9;
  dispatch_io_t v10;
  size_t v11;
  dispatch_io_t v12;

  v12 = channel;
  v11 = high_water;
  v10 = channel;
  _dispatch_retain((uint64_t)channel);
  v2 = (dispatch_queue_s *)*((_QWORD *)v12 + 6);
  block = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = __dispatch_io_set_high_water_block_invoke;
  v7 = &__block_descriptor_tmp_16;
  v8 = v12;
  v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_high_water_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set high water: %zu", v1, v2, v3, v4, v5, v6, v7, 662);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) > *(_QWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) = *(_QWORD *)(a1 + 40);
  if (*(_QWORD *)(a1 + 40))
    v8 = *(_QWORD *)(a1 + 40);
  else
    v8 = 1;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) = v8;
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_set_low_water(dispatch_io_t channel, size_t low_water)
{
  dispatch_queue_s *v2;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  dispatch_io_t v8;
  size_t v9;
  dispatch_io_t v10;
  size_t v11;
  dispatch_io_t v12;

  v12 = channel;
  v11 = low_water;
  v10 = channel;
  _dispatch_retain((uint64_t)channel);
  v2 = (dispatch_queue_s *)*((_QWORD *)v12 + 6);
  block = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = __dispatch_io_set_low_water_block_invoke;
  v7 = &__block_descriptor_tmp_18;
  v8 = v12;
  v9 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_set_low_water_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set low water: %zu", v1, v2, v3, v4, v5, v6, v7, 676);
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) < *(_QWORD *)(a1 + 40))
  {
    if (*(_QWORD *)(a1 + 40))
      v8 = *(_QWORD *)(a1 + 40);
    else
      v8 = 1;
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) = v8;
  }
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 80) = *(_QWORD *)(a1 + 40);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_set_interval(dispatch_io_t channel, uint64_t interval, dispatch_io_interval_flags_t flags)
{
  dispatch_queue_s *v3;
  void **block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  dispatch_io_t v9;
  uint64_t v10;
  dispatch_io_interval_flags_t v11;
  dispatch_io_t v12;
  dispatch_io_interval_flags_t v13;
  uint64_t v14;
  dispatch_io_t v15;

  v15 = channel;
  v14 = interval;
  v13 = flags;
  v12 = channel;
  _dispatch_retain((uint64_t)channel);
  v3 = (dispatch_queue_s *)*((_QWORD *)v15 + 6);
  block = _NSConcreteStackBlock;
  v5 = 0x40000000;
  v6 = 0;
  v7 = __dispatch_io_set_interval_block_invoke;
  v8 = &__block_descriptor_tmp_20;
  v9 = v15;
  v10 = v14;
  v11 = v13;
  dispatch_channel_async(v3, &block);
}

void __dispatch_io_set_interval_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: set interval: %llu", v1, v2, v3, v4, v5, v6, v7, 692);
  if (*(_QWORD *)(a1 + 40) >= 0x7FFFFFFFFFFFFFFFuLL)
    v8 = 0x7FFFFFFFFFFFFFFFLL;
  else
    v8 = *(_QWORD *)(a1 + 40);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 96) = v8;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 104) = *(_QWORD *)(a1 + 48);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_io_set_target_queue(uint64_t a1, uint64_t a2)
{
  dispatch_queue_s *v2;
  void **v3;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;

  v13 = a1;
  v12 = a2;
  v11 = a2;
  _dispatch_retain(a2);
  v10 = v13;
  _dispatch_retain(v13);
  v2 = *(dispatch_queue_s **)(v13 + 48);
  v3 = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = ___dispatch_io_set_target_queue_block_invoke;
  v7 = &__block_descriptor_tmp_21;
  v8 = v13;
  v9 = v12;
  dispatch_channel_async(v2, &v3);
}

void ___dispatch_io_set_target_queue_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned int *v8;

  v8 = *(unsigned int **)(*(_QWORD *)(a1 + 32) + 24);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 24) = *(_QWORD *)(a1 + 40);
  _dispatch_release(v8);
  _dispatch_object_debug(*(_QWORD *)(a1 + 32), "%s", v1, v2, v3, v4, v5, v6, (char)"_dispatch_io_set_target_queue_block_invoke");
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

dispatch_fd_t dispatch_io_get_descriptor(dispatch_io_t channel)
{
  char *i;
  char *v5;

  if ((*((_DWORD *)channel + 30) & 3) != 0)
    return -1;
  if (*((_DWORD *)channel + 32) == -1 && !_dispatch_io_get_error(0, (uint64_t)channel, 0))
  {
    for (i = (char *)_dispatch_thread_getspecific(0x17uLL); i; i = *(char **)i)
    {
      if (*((char **)i + 1) == "io")
      {
        v5 = i;
        goto LABEL_11;
      }
    }
    v5 = 0;
LABEL_11:
    if (v5 && *((dispatch_io_t *)v5 + 2) == channel)
      _dispatch_fd_entry_open(*((_QWORD *)channel + 14), (uint64_t)channel);
  }
  return *((_DWORD *)channel + 32);
}

uint64_t _dispatch_fd_entry_open(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int *v8;
  unsigned int v9;
  unsigned int v10;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;

  if (*(_DWORD *)a1 == -1 && *(_QWORD *)(a1 + 8))
  {
    if (*(_DWORD *)(a1 + 24))
    {
      return *(unsigned int *)(a1 + 24);
    }
    else
    {
      if (*(_QWORD *)(a1 + 56))
        v12 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8) & 0xFFFFFFFB;
      else
        v12 = *(_DWORD *)(*(_QWORD *)(a1 + 8) + 8) | 4;
      while (1)
      {
        v14 = _dispatch_fd_entry_guarded_open(a1, *(_QWORD *)(a1 + 8) + 24, v12, *(_WORD *)(*(_QWORD *)(a1 + 8) + 12));
        if (v14 != -1)
          break;
        v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        if (v13 != 4)
        {
          v8 = (unsigned int *)(a1 + 24);
          do
            v9 = __ldaxr(v8);
          while (!v9 && __stlxr(v13, v8));
          return v13;
        }
      }
      do
        v10 = __ldaxr((unsigned int *)a1);
      while (v10 == -1 && __stlxr(v14, (unsigned int *)a1));
      if (v10 == -1)
        *(_DWORD *)(a2 + 128) = v14;
      else
        _dispatch_fd_entry_guarded_close(a1, v14);
      _dispatch_object_debug(a2, "%s", v2, v3, v4, v5, v6, v7, (char)"_dispatch_fd_entry_open");
      return 0;
    }
  }
  else
  {
    return 0;
  }
}

void dispatch_io_close(dispatch_io_t channel, dispatch_io_close_flags_t flags)
{
  dispatch_queue_s *v2;
  void **v3;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  dispatch_io_t v8;
  dispatch_io_t v9;
  dispatch_io_close_flags_t v10;
  dispatch_io_t v11;

  v11 = channel;
  v10 = flags;
  if ((flags & 1) != 0)
  {
    if ((*((_DWORD *)v11 + 30) & 2) == 0)
      _dispatch_io_stop((uint64_t)v11);
  }
  else if ((*((_DWORD *)v11 + 30) & 3) == 0)
  {
    v9 = v11;
    _dispatch_retain((uint64_t)v11);
    v2 = (dispatch_queue_s *)*((_QWORD *)v11 + 6);
    v3 = _NSConcreteStackBlock;
    v4 = 0x40000000;
    v5 = 0;
    v6 = __dispatch_io_close_block_invoke;
    v7 = &__block_descriptor_tmp_25;
    v8 = v11;
    dispatch_channel_async(v2, &v3);
  }
}

void _dispatch_io_stop(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  unsigned int v8;
  unsigned int v9;
  dispatch_queue_s *v10;
  unsigned int *v11;
  unsigned int v12;
  void **block;
  int v14;
  int v15;
  void (*v16)(uint64_t);
  void *v17;
  uint64_t v18;
  uint64_t v19;
  unsigned int v20;
  unsigned int v21;
  int v22;
  int v23;
  int v24;
  unsigned int v25;
  int v26;
  int v27;
  int v28;
  int v29;
  uint64_t v30;

  v30 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: stop", v1, v2, v3, v4, v5, v6, v7, 736);
  v28 = 2;
  v27 = 2;
  v29 = 2;
  v25 = 0;
  v11 = (unsigned int *)(v30 + 120);
  v23 = 2;
  v22 = 2;
  v24 = 2;
  v12 = *(_DWORD *)(v30 + 120);
  do
  {
    v8 = v12;
    do
      v9 = __ldaxr(v11);
    while (v9 == v12 && __stlxr(v12 | 2, v11));
    v12 = v9;
  }
  while (v9 != v8);
  v21 = v9;
  v25 = v9;
  v20 = v9;
  v26 = v9 | v29;
  v19 = v30;
  _dispatch_retain(v30);
  v10 = *(dispatch_queue_s **)(v30 + 48);
  block = _NSConcreteStackBlock;
  v14 = 0x40000000;
  v15 = 0;
  v16 = ___dispatch_io_stop_block_invoke;
  v17 = &__block_descriptor_tmp_76;
  v18 = v30;
  dispatch_channel_async(v10, &block);
}

void __dispatch_io_close_block_invoke(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a1;
  v2 = *(dispatch_queue_s **)(*(_QWORD *)(a1 + 32) + 56);
  block = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = __dispatch_io_close_block_invoke_2;
  v7 = &__block_descriptor_tmp_24;
  v8 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_close_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unsigned int v15;
  unsigned int v16;
  unsigned int *v17;
  unsigned int v18;
  uint64_t v20;

  _dispatch_object_debug(*(_QWORD *)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_io_close_block_invoke_2");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: close", v8, v9, v10, v11, v12, v13, v14, 794);
  if ((*(_DWORD *)(*(_QWORD *)(a1 + 32) + 120) & 3) == 0)
  {
    v17 = (unsigned int *)(*(_QWORD *)(a1 + 32) + 120);
    v18 = *v17;
    do
    {
      v15 = v18;
      do
        v16 = __ldaxr(v17);
      while (v16 == v18 && __stlxr(v18 | 1, v17));
      v18 = v16;
    }
    while (v16 != v15);
    v20 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
    if (v20)
    {
      if (*(_QWORD *)(v20 + 8))
        **(_QWORD **)(v20 + 8) = 0;
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = 0;
      _dispatch_fd_entry_release(v20);
    }
  }
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void dispatch_io_barrier(dispatch_io_t channel, dispatch_block_t barrier)
{
  dispatch_queue_s *v2;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t);
  void *v7;
  dispatch_block_t v8;
  dispatch_io_t v9;
  dispatch_io_t v10;
  dispatch_block_t v11;
  dispatch_io_t v12;

  v12 = channel;
  v11 = barrier;
  v10 = channel;
  _dispatch_retain((uint64_t)channel);
  v2 = (dispatch_queue_s *)*((_QWORD *)v12 + 6);
  block = _NSConcreteStackBlock;
  v4 = 1107296256;
  v5 = 0;
  v6 = __dispatch_io_barrier_block_invoke;
  v7 = &__block_descriptor_tmp_28;
  v9 = v12;
  v8 = v11;
  dispatch_channel_async(v2, &block);
}

void __dispatch_io_barrier_block_invoke(uint64_t a1)
{
  void **v1;
  int v2;
  int v3;
  void (*v4)(_QWORD *);
  void *v5;
  uint64_t v6;
  dispatch_queue_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dispatch_queue_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;

  v15 = a1;
  v14 = a1;
  v13 = 0;
  v13 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 24);
  v12 = 0;
  v12 = *(dispatch_queue_t *)(*(_QWORD *)(a1 + 40) + 56);
  v11 = 0;
  v11 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 64);
  v1 = _NSConcreteStackBlock;
  v2 = 1107296256;
  v3 = 0;
  v4 = __dispatch_io_barrier_block_invoke_2;
  v5 = &__block_descriptor_tmp_27;
  v7 = v12;
  v8 = v11;
  v9 = v13;
  v10 = *(_QWORD *)(a1 + 40);
  v6 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v12, &v1);
}

void __dispatch_io_barrier_block_invoke_2(_QWORD *a1)
{
  dispatch_group_s *v1;
  dispatch_queue_s *v2;
  void **block;
  int v5;
  int v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dispatch_object_t v12;
  _QWORD *v13;
  _QWORD *v14;

  v14 = a1;
  v13 = a1;
  v12 = (dispatch_object_t)a1[5];
  dispatch_suspend(v12);
  v1 = (dispatch_group_s *)a1[6];
  v2 = (dispatch_queue_s *)a1[7];
  block = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = __dispatch_io_barrier_block_invoke_3;
  v8 = &__block_descriptor_tmp_26;
  v10 = a1[8];
  v9 = a1[4];
  v11 = a1[5];
  dispatch_group_notify(v1, v2, &block);
}

void __dispatch_io_barrier_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  _QWORD v15[2];
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  _QWORD *v19;
  uint64_t *v20;
  uint64_t v21;
  _BOOL8 v22;

  v18 = a1;
  v17 = a1;
  v16 = 0;
  v15[0] = 0;
  v15[1] = "io";
  v16 = *(_QWORD *)(a1 + 40);
  _dispatch_object_debug(*(_QWORD *)(a1 + 40), "%s", a3, a4, a5, a6, a7, a8, (char)"dispatch_io_barrier_block_invoke_3");
  v19 = v15;
  v15[0] = _dispatch_thread_getspecific(0x17uLL);
  _dispatch_thread_setspecific(23, (uint64_t)v19);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  v20 = v15;
  v22 = _dispatch_thread_getspecific(0x17uLL) == v15;
  v21 = 449;
  if (!v22)
    _dispatch_abort(v21, 0, v8, v9, v10, v11, v12, v13);
  _dispatch_thread_setspecific(23, *v20);
  dispatch_resume(*(dispatch_object_t *)(a1 + 48));
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

void dispatch_io_barrier_f(dispatch_io_s *a1, uint64_t a2, uint64_t a3)
{
  void **barrier;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  dispatch_io_s *v12;

  v12 = a1;
  v11 = a2;
  v10 = a3;
  barrier = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = __dispatch_io_barrier_f_block_invoke;
  v7 = &__block_descriptor_tmp_29;
  v8 = a3;
  v9 = a2;
  dispatch_io_barrier(a1, &barrier);
}

uint64_t __dispatch_io_barrier_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

void dispatch_io_read(dispatch_io_t channel, off_t offset, size_t length, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_queue_s *v5;
  void **v6;
  int v7;
  int v8;
  void (*v9)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v10;
  dispatch_io_handler_t v11;
  dispatch_io_t v12;
  off_t v13;
  size_t v14;
  dispatch_queue_t v15;
  dispatch_queue_t v16;
  dispatch_io_t v17;
  dispatch_io_handler_t v18;
  dispatch_queue_t v19;
  size_t v20;
  off_t v21;
  dispatch_io_t v22;

  v22 = channel;
  v21 = offset;
  v20 = length;
  v19 = queue;
  v18 = io_handler;
  v17 = channel;
  _dispatch_retain((uint64_t)channel);
  v16 = v19;
  _dispatch_retain((uint64_t)v19);
  v5 = (dispatch_queue_s *)*((_QWORD *)v22 + 6);
  v6 = _NSConcreteStackBlock;
  v7 = 1107296256;
  v8 = 0;
  v9 = __dispatch_io_read_block_invoke;
  v10 = &__block_descriptor_tmp_31;
  v12 = v22;
  v13 = v21;
  v14 = v20;
  v15 = v19;
  v11 = v18;
  dispatch_channel_async(v5, &v6);
}

void __dispatch_io_read_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void **block;
  int v10;
  int v11;
  void (*v12)(uint64_t);
  void *v13;
  _QWORD *v14;
  dispatch_queue_t v15;
  _QWORD *v16;
  uint64_t v17;
  uint64_t v18;

  v18 = a1;
  v17 = a1;
  v16 = 0;
  v16 = _dispatch_operation_create(0, *(_QWORD **)(a1 + 40), *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56), &_dispatch_data_empty, *(dispatch_queue_s **)(a1 + 64), *(const void **)(a1 + 32), a8);
  if (v16)
  {
    v15 = 0;
    v15 = *(dispatch_queue_t *)(*(_QWORD *)(a1 + 40) + 56);
    block = _NSConcreteStackBlock;
    v10 = 0x40000000;
    v11 = 0;
    v12 = __dispatch_io_read_block_invoke_2;
    v13 = &__block_descriptor_tmp_30;
    v14 = v16;
    dispatch_channel_async(v15, &block);
  }
  _dispatch_release(*(unsigned int **)(a1 + 40));
  _dispatch_release(*(unsigned int **)(a1 + 64));
}

_QWORD *_dispatch_operation_create(unsigned int a1, _QWORD *a2, uint64_t a3, uint64_t a4, dispatch_object_s *a5, dispatch_queue_s *a6, const void *a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  dispatch_queue_s *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t i;
  _QWORD *v30;
  void **block;
  int v32;
  int v33;
  void (*v34)(uint64_t);
  void *v35;
  const void *v36;
  dispatch_queue_t v37;
  dispatch_object_t v38;
  _QWORD *v39;
  unsigned int v40;
  int v41;
  _QWORD *v42;
  dispatch_queue_t v43;
  dispatch_object_t v44;
  int error;
  const void *v46;
  dispatch_queue_t v47;
  dispatch_object_t v48;
  uint64_t v49;
  uint64_t v50;
  _QWORD *v51;
  unsigned int v52;
  uint64_t v54;
  _BOOL8 v55;

  v52 = a1;
  v51 = a2;
  v50 = a3;
  v49 = a4;
  v48 = a5;
  v47 = a6;
  v46 = a7;
  v55 = a1 < 2;
  v54 = 1064;
  if (a1 >= 2)
    _dispatch_abort(v54, v55, a3, a4, (uint64_t)a5, (uint64_t)a6, (uint64_t)a7, a8);
  error = _dispatch_io_get_error(0, (uint64_t)v51, 0);
  if (!error && v49)
  {
    v30 = _dispatch_object_alloc((uint64_t)_OS_dispatch_operation_vtable, 0x110uLL, v8, v9, v10, v11, v12, v13);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tchannel[%p]: operation create: %p", v15, v16, v17, v18, v19, v20, v21, 1092);
    v30[2] = -1985229329;
    *((_DWORD *)v30 + 3) = 0;
    v30[6] = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.opq", 0, v47);
    *((_BYTE *)v30 + 160) = 0;
    *((_DWORD *)v30 + 14) = v52;
    v30[13] = v50 + v51[17];
    v30[14] = v49;
    v30[16] = _dispatch_Block_copy(v46);
    _dispatch_retain((uint64_t)v51);
    v30[17] = v51;
    memcpy(v30 + 8, v51 + 9, 0x28uLL);
    for (i = *(_QWORD *)(v30[17] + 24); *(_QWORD *)(i + 24); i = *(_QWORD *)(i + 24))
      ;
    v30[3] = i;
    _dispatch_object_debug((uint64_t)v30, "%s", v22, v23, v24, v25, v26, v27, (char)"_dispatch_operation_create");
    return v30;
  }
  else
  {
    v44 = v48;
    dispatch_retain(v48);
    v43 = v47;
    _dispatch_retain((uint64_t)v47);
    v42 = v51;
    _dispatch_retain((uint64_t)v51);
    v14 = (dispatch_queue_s *)v51[7];
    block = _NSConcreteStackBlock;
    v32 = 1107296256;
    v33 = 0;
    v34 = ___dispatch_operation_create_block_invoke;
    v35 = &__block_descriptor_tmp_86;
    v37 = v47;
    v38 = v48;
    v40 = v52;
    v41 = error;
    v39 = v51;
    v36 = v46;
    dispatch_channel_async(v14, &block);
    return 0;
  }
}

void __dispatch_io_read_block_invoke_2(uint64_t a1)
{
  _dispatch_operation_enqueue(*(unsigned int **)(a1 + 32), 0, &_dispatch_data_empty);
}

void _dispatch_operation_enqueue(unsigned int *a1, unsigned int a2, dispatch_object_s *a3)
{
  dispatch_queue_s *v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  dispatch_queue_s *v11;
  dispatch_queue_s *v12;
  void **v13;
  int v14;
  int v15;
  void (*v16)(uint64_t);
  void *v17;
  uint64_t v18;
  unsigned int *v19;
  dispatch_object_s *v20;
  void **v21;
  int v22;
  int v23;
  void (*v24)(uint64_t);
  void *v25;
  dispatch_queue_s **v26;
  unsigned int *v27;
  dispatch_object_s *v28;
  dispatch_queue_s **v29;
  uint64_t v30;
  unsigned int *v31;
  void **block;
  int v33;
  int v34;
  void (*v35)(uint64_t);
  void *v36;
  uint64_t v37;
  dispatch_object_s *v38;
  unsigned int v39;
  int v40;
  uint64_t v41;
  int error;
  dispatch_object_s *v43;
  dispatch_object_s *v44;
  unsigned int v45;
  unsigned int *v46;

  v46 = a1;
  v45 = a2;
  v44 = a3;
  v43 = a3;
  dispatch_retain(a3);
  error = 0;
  error = _dispatch_io_get_error(0, *((_QWORD *)v46 + 17), 0);
  if (error)
  {
    v41 = 0;
    v41 = *((_QWORD *)v46 + 16);
    v3 = (dispatch_queue_s *)*((_QWORD *)v46 + 6);
    block = _NSConcreteStackBlock;
    v33 = 1107296256;
    v34 = 0;
    v35 = ___dispatch_operation_enqueue_block_invoke;
    v36 = &__block_descriptor_tmp_89;
    v38 = v44;
    v39 = v45;
    v40 = error;
    v37 = v41;
    dispatch_channel_async(v3, &block);
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v4, v5, v6, v7, v8, v9, v10, 1175);
    v31 = v46;
    _dispatch_release(v46);
  }
  else
  {
    *((_QWORD *)v46 + 18) = *(_QWORD *)(*((_QWORD *)v46 + 17) + 112);
    _dispatch_fd_entry_retain(*((_QWORD *)v46 + 18));
    dispatch_group_enter(*(dispatch_group_t *)(*((_QWORD *)v46 + 18) + 80));
    v30 = 0;
    v30 = *(_QWORD *)(*((_QWORD *)v46 + 18) + 56);
    if (v30)
    {
      v12 = *(dispatch_queue_s **)(v30 + 72);
      v13 = _NSConcreteStackBlock;
      v14 = 0x40000000;
      v15 = 0;
      v16 = ___dispatch_operation_enqueue_block_invoke_2;
      v17 = &__block_descriptor_tmp_93;
      v18 = v30;
      v19 = v46;
      v20 = v44;
      dispatch_channel_async(v12, &v13);
    }
    else
    {
      v29 = 0;
      v29 = *(dispatch_queue_s ***)(*((_QWORD *)v46 + 18) + 40 + 8 * v45);
      v11 = *v29;
      v21 = _NSConcreteStackBlock;
      v22 = 0x40000000;
      v23 = 0;
      v24 = ___dispatch_operation_enqueue_block_invoke_91;
      v25 = &__block_descriptor_tmp_92;
      v26 = v29;
      v27 = v46;
      v28 = v44;
      dispatch_channel_async(v11, &v21);
    }
  }
}

void dispatch_io_read_f(dispatch_io_s *a1, off_t a2, size_t a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  void **v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t, char, uint64_t, unsigned int);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_queue_s *v15;
  size_t v16;
  off_t v17;
  dispatch_io_s *v18;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v6 = _NSConcreteStackBlock;
  v7 = 0x40000000;
  v8 = 0;
  v9 = __dispatch_io_read_f_block_invoke;
  v10 = &__block_descriptor_tmp_33;
  v11 = a6;
  v12 = a5;
  dispatch_io_read(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_read_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_io_write(dispatch_io_t channel, off_t offset, dispatch_data_t data, dispatch_queue_t queue, dispatch_io_handler_t io_handler)
{
  dispatch_queue_s *v5;
  void **block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  dispatch_io_handler_t v11;
  dispatch_io_t v12;
  off_t v13;
  dispatch_data_t v14;
  dispatch_queue_t v15;
  dispatch_queue_t v16;
  dispatch_io_t v17;
  dispatch_data_t v18;
  dispatch_io_handler_t v19;
  dispatch_queue_t v20;
  dispatch_data_t v21;
  off_t v22;
  dispatch_io_t v23;

  v23 = channel;
  v22 = offset;
  v21 = data;
  v20 = queue;
  v19 = io_handler;
  v18 = data;
  dispatch_retain(data);
  v17 = v23;
  _dispatch_retain((uint64_t)v23);
  v16 = v20;
  _dispatch_retain((uint64_t)v20);
  v5 = (dispatch_queue_s *)*((_QWORD *)v23 + 6);
  block = _NSConcreteStackBlock;
  v7 = 1107296256;
  v8 = 0;
  v9 = __dispatch_io_write_block_invoke;
  v10 = &__block_descriptor_tmp_35;
  v12 = v23;
  v13 = v22;
  v14 = v21;
  v15 = v20;
  v11 = v19;
  dispatch_channel_async(v5, &block);
}

void __dispatch_io_write_block_invoke(uint64_t a1)
{
  size_t size;
  uint64_t v2;
  _QWORD *v3;
  uint64_t v4;
  void **block;
  int v7;
  int v8;
  void (*v9)(uint64_t);
  void *v10;
  _QWORD *v11;
  uint64_t v12;
  dispatch_queue_t v13;
  _QWORD *v14;
  uint64_t v15;
  uint64_t v16;

  v16 = a1;
  v15 = a1;
  v14 = 0;
  v3 = *(_QWORD **)(a1 + 40);
  v4 = *(_QWORD *)(a1 + 48);
  size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 56));
  v14 = _dispatch_operation_create(1u, v3, v4, size, *(dispatch_object_s **)(a1 + 56), *(dispatch_queue_s **)(a1 + 64), *(const void **)(a1 + 32), v2);
  if (v14)
  {
    v13 = 0;
    v13 = *(dispatch_queue_t *)(*(_QWORD *)(a1 + 40) + 56);
    block = _NSConcreteStackBlock;
    v7 = 0x40000000;
    v8 = 0;
    v9 = __dispatch_io_write_block_invoke_2;
    v10 = &__block_descriptor_tmp_34;
    v11 = v14;
    v12 = *(_QWORD *)(a1 + 56);
    dispatch_channel_async(v13, &block);
  }
  else
  {
    dispatch_release(*(dispatch_object_t *)(a1 + 56));
  }
  _dispatch_release(*(unsigned int **)(a1 + 40));
  _dispatch_release(*(unsigned int **)(a1 + 64));
}

void __dispatch_io_write_block_invoke_2(uint64_t a1)
{
  _dispatch_operation_enqueue(*(unsigned int **)(a1 + 32), 1u, *(dispatch_object_s **)(a1 + 40));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void dispatch_io_write_f(dispatch_io_s *a1, off_t a2, dispatch_data_s *a3, dispatch_queue_s *a4, uint64_t a5, uint64_t a6)
{
  void **v6;
  int v7;
  int v8;
  uint64_t (*v9)(uint64_t, char, uint64_t, unsigned int);
  void *v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  dispatch_queue_s *v15;
  dispatch_data_s *v16;
  off_t v17;
  dispatch_io_s *v18;

  v18 = a1;
  v17 = a2;
  v16 = a3;
  v15 = a4;
  v14 = a5;
  v13 = a6;
  v6 = _NSConcreteStackBlock;
  v7 = 0x40000000;
  v8 = 0;
  v9 = __dispatch_io_write_f_block_invoke;
  v10 = &__block_descriptor_tmp_36;
  v11 = a6;
  v12 = a5;
  dispatch_io_write(a1, a2, a3, a4, &v6);
}

uint64_t __dispatch_io_write_f_block_invoke(uint64_t a1, char a2, uint64_t a3, unsigned int a4)
{
  return (*(uint64_t (**)(_QWORD, _QWORD, uint64_t, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2 & 1, a3, a4);
}

void dispatch_read(dispatch_fd_t fd, size_t length, dispatch_queue_t queue, void *handler)
{
  void **v4;
  int v5;
  int v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v8;
  void *v9;
  dispatch_queue_t v10;
  size_t v11;
  dispatch_fd_t v12;
  dispatch_queue_t v13;
  void *v14;
  dispatch_queue_t v15;
  size_t v16;
  dispatch_fd_t v17;

  v17 = fd;
  v16 = length;
  v15 = queue;
  v14 = handler;
  v13 = queue;
  _dispatch_retain((uint64_t)queue);
  v4 = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = __dispatch_read_block_invoke;
  v8 = &__block_descriptor_tmp_45;
  v10 = v15;
  v12 = v17;
  v9 = v14;
  v11 = v16;
  _dispatch_fd_entry_init_async(v17, (uint64_t)&v4);
}

void __dispatch_read_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dispatch_queue_s *v8;
  dispatch_queue_s *v9;
  uint64_t v10;
  uint64_t v11;
  void **v13;
  int v14;
  int v15;
  void (*v16)(uint64_t, char, dispatch_data_s *, int);
  void *v17;
  _QWORD *v18;
  _QWORD *v19;
  unsigned int *v20;
  void **v21;
  int v22;
  int v23;
  void (*v24)(uint64_t);
  void *v25;
  uint64_t v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  int v30;
  _QWORD v31[2];
  int v32;
  int v33;
  int v34;
  _QWORD v35[2];
  int v36;
  int v37;
  dispatch_data_s *v38;
  dispatch_object_t v39;
  dispatch_object_t v40;
  _QWORD *v41;
  void **block;
  int v43;
  int v44;
  uint64_t (*v45)(uint64_t);
  void *v46;
  uint64_t v47;
  int v48;
  int v49;
  int v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;

  v53 = a1;
  v52 = a2;
  v51 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    v50 = 0;
    v50 = *(_DWORD *)(v52 + 24);
    v8 = *(dispatch_queue_s **)(a1 + 40);
    block = _NSConcreteStackBlock;
    v43 = 1107296256;
    v44 = 0;
    v45 = __dispatch_read_block_invoke_2;
    v46 = &__block_descriptor_tmp_38;
    v48 = *(_DWORD *)(a1 + 56);
    v47 = *(_QWORD *)(a1 + 32);
    v49 = v50;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(unsigned int **)(a1 + 40));
  }
  else
  {
    v41 = 0;
    v41 = *(_QWORD **)(v52 + 88);
    if (!v41)
    {
      v41 = _dispatch_io_create(0, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v41 + 31) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v41 + 32) = *(_DWORD *)(a1 + 56);
      v41[14] = v52;
      v40 = *(dispatch_object_t *)(v52 + 72);
      dispatch_retain(v40);
      v39 = *(dispatch_object_t *)(v52 + 80);
      dispatch_retain(v39);
      v41[7] = *(_QWORD *)(v52 + 72);
      v41[8] = *(_QWORD *)(v52 + 80);
      *(_QWORD *)(v52 + 88) = v41;
    }
    v35[0] = 0;
    v35[1] = v35;
    v36 = 0;
    v37 = 32;
    v38 = &_dispatch_data_empty;
    v31[0] = 0;
    v31[1] = v31;
    v32 = 0;
    v33 = 32;
    v34 = 0;
    v9 = *(dispatch_queue_s **)(v52 + 64);
    v21 = _NSConcreteStackBlock;
    v22 = 1107296256;
    v23 = 0;
    v24 = __dispatch_read_block_invoke_39;
    v25 = &__block_descriptor_tmp_42;
    v29 = *(_QWORD *)(a1 + 40);
    v30 = *(_DWORD *)(a1 + 56);
    v26 = *(_QWORD *)(a1 + 32);
    v27 = v35;
    v28 = v31;
    dispatch_channel_async(v9, &v21);
    v20 = 0;
    v10 = *(_QWORD *)(a1 + 48);
    v13 = _NSConcreteStackBlock;
    v14 = 1107296256;
    v15 = 0;
    v16 = __dispatch_read_block_invoke_43;
    v17 = &__block_descriptor_tmp_44;
    v18 = v35;
    v19 = v31;
    v20 = (unsigned int *)_dispatch_operation_create(0, v41, 0, v10, &_dispatch_data_empty, (dispatch_queue_s *)&off_E4640, &v13, v11);
    if (v20)
      _dispatch_operation_enqueue(v20, 0, &_dispatch_data_empty);
    _Block_object_dispose(v31, 8);
    _Block_object_dispose(v35, 8);
  }
}

uint64_t __dispatch_read_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 925);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __dispatch_read_block_invoke_39(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a1;
  v13 = a1;
  v2 = *(dispatch_queue_s **)(a1 + 56);
  block = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = __dispatch_read_block_invoke_2_40;
  v8 = &__block_descriptor_tmp_41;
  v12 = *(_DWORD *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

void __dispatch_read_block_invoke_2_40(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 948);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
}

void __copy_helper_block_8_32b40r48r(uint64_t a1, const void **a2)
{
  _Block_object_assign((void *)(a1 + 32), a2[4], 7);
  _Block_object_assign((void *)(a1 + 40), a2[5], 8);
  _Block_object_assign((void *)(a1 + 48), a2[6], 8);
}

void __destroy_helper_block_8_32b40r48r(const void **a1)
{
  _Block_object_dispose(a1[6], 8);
  _Block_object_dispose(a1[5], 8);
  _Block_object_dispose(a1[4], 7);
}

void __dispatch_read_block_invoke_43(uint64_t a1, char a2, dispatch_data_s *a3, int a4)
{
  dispatch_data_t concat;
  char v7;

  v7 = a2 & 1;
  if (a3)
  {
    concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24), a3);
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24));
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = concat;
  }
  if ((v7 & 1) != 0)
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a4;
}

void __copy_helper_block_8_32r40r(uint64_t a1, uint64_t a2)
{
  _Block_object_assign((void *)(a1 + 32), *(const void **)(a2 + 32), 8);
  _Block_object_assign((void *)(a1 + 40), *(const void **)(a2 + 40), 8);
}

void __destroy_helper_block_8_32r40r(uint64_t a1)
{
  _Block_object_dispose(*(const void **)(a1 + 40), 8);
  _Block_object_dispose(*(const void **)(a1 + 32), 8);
}

void dispatch_read_f(dispatch_fd_t a1, size_t a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  void **handler;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t, uint64_t, unsigned int);
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  dispatch_queue_s *v14;
  size_t v15;
  dispatch_fd_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  handler = _NSConcreteStackBlock;
  v6 = 0x40000000;
  v7 = 0;
  v8 = __dispatch_read_f_block_invoke;
  v9 = &__block_descriptor_tmp_47;
  v10 = a5;
  v11 = a4;
  dispatch_read(a1, a2, a3, &handler);
}

uint64_t __dispatch_read_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2, a3);
}

void dispatch_write(dispatch_fd_t fd, dispatch_data_t data, dispatch_queue_t queue, void *handler)
{
  void **v4;
  int v5;
  int v6;
  void (*v7)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v8;
  void *v9;
  dispatch_queue_t v10;
  dispatch_data_t v11;
  dispatch_fd_t v12;
  dispatch_queue_t v13;
  dispatch_data_t v14;
  void *v15;
  dispatch_queue_t v16;
  dispatch_data_t v17;
  dispatch_fd_t v18;

  v18 = fd;
  v17 = data;
  v16 = queue;
  v15 = handler;
  v14 = data;
  dispatch_retain(data);
  v13 = v16;
  _dispatch_retain((uint64_t)v16);
  v4 = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = __dispatch_write_block_invoke;
  v8 = &__block_descriptor_tmp_55_0;
  v10 = v16;
  v12 = v18;
  v9 = v15;
  v11 = v17;
  _dispatch_fd_entry_init_async(v18, (uint64_t)&v4);
}

void __dispatch_write_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  dispatch_queue_s *v8;
  dispatch_queue_s *v9;
  size_t size;
  dispatch_object_s *v11;
  uint64_t v12;
  _QWORD *v13;
  void **v15;
  int v16;
  int v17;
  void (*v18)(uint64_t, char, dispatch_object_s *, int);
  void *v19;
  _QWORD *v20;
  _QWORD *v21;
  unsigned int *v22;
  void **v23;
  int v24;
  int v25;
  void (*v26)(uint64_t);
  void *v27;
  uint64_t v28;
  _QWORD *v29;
  _QWORD *v30;
  uint64_t v31;
  int v32;
  _QWORD v33[2];
  int v34;
  int v35;
  int v36;
  _QWORD v37[2];
  int v38;
  int v39;
  uint64_t v40;
  dispatch_object_t v41;
  dispatch_object_t v42;
  _QWORD *v43;
  void **block;
  int v45;
  int v46;
  uint64_t (*v47)(uint64_t);
  void *v48;
  uint64_t v49;
  int v50;
  int v51;
  int v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;

  v55 = a1;
  v54 = a2;
  v53 = a1;
  if (*(_DWORD *)(a2 + 24))
  {
    v52 = 0;
    v52 = *(_DWORD *)(v54 + 24);
    v8 = *(dispatch_queue_s **)(a1 + 40);
    block = _NSConcreteStackBlock;
    v45 = 1107296256;
    v46 = 0;
    v47 = __dispatch_write_block_invoke_2;
    v48 = &__block_descriptor_tmp_48;
    v50 = *(_DWORD *)(a1 + 56);
    v49 = *(_QWORD *)(a1 + 32);
    v51 = v52;
    dispatch_channel_async(v8, &block);
    _dispatch_release(*(unsigned int **)(a1 + 40));
  }
  else
  {
    v43 = 0;
    v43 = *(_QWORD **)(v54 + 88);
    if (!v43)
    {
      v43 = _dispatch_io_create(0, a2, a3, a4, a5, a6, a7, a8);
      *((_DWORD *)v43 + 31) = *(_DWORD *)(a1 + 56);
      *((_DWORD *)v43 + 32) = *(_DWORD *)(a1 + 56);
      v43[14] = v54;
      v42 = *(dispatch_object_t *)(v54 + 72);
      dispatch_retain(v42);
      v41 = *(dispatch_object_t *)(v54 + 80);
      dispatch_retain(v41);
      v43[7] = *(_QWORD *)(v54 + 72);
      v43[8] = *(_QWORD *)(v54 + 80);
      *(_QWORD *)(v54 + 88) = v43;
    }
    v37[0] = 0;
    v37[1] = v37;
    v38 = 0;
    v39 = 32;
    v40 = 0;
    v33[0] = 0;
    v33[1] = v33;
    v34 = 0;
    v35 = 32;
    v36 = 0;
    v9 = *(dispatch_queue_s **)(v54 + 64);
    v23 = _NSConcreteStackBlock;
    v24 = 1107296256;
    v25 = 0;
    v26 = __dispatch_write_block_invoke_49;
    v27 = &__block_descriptor_tmp_52_0;
    v31 = *(_QWORD *)(a1 + 40);
    v32 = *(_DWORD *)(a1 + 56);
    v28 = *(_QWORD *)(a1 + 32);
    v29 = v37;
    v30 = v33;
    dispatch_channel_async(v9, &v23);
    v22 = 0;
    v13 = v43;
    size = dispatch_data_get_size(*(dispatch_data_t *)(a1 + 48));
    v11 = *(dispatch_object_s **)(a1 + 48);
    v15 = _NSConcreteStackBlock;
    v16 = 1107296256;
    v17 = 0;
    v18 = __dispatch_write_block_invoke_53;
    v19 = &__block_descriptor_tmp_54;
    v20 = v37;
    v21 = v33;
    v22 = (unsigned int *)_dispatch_operation_create(1u, v13, 0, size, v11, (dispatch_queue_s *)&off_E4640, &v15, v12);
    if (v22)
      _dispatch_operation_enqueue(v22, 1u, *(dispatch_object_s **)(a1 + 48));
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
    _Block_object_dispose(v33, 8);
    _Block_object_dispose(v37, 8);
  }
}

uint64_t __dispatch_write_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 994);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void __dispatch_write_block_invoke_49(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  uint64_t v13;
  uint64_t v14;

  v14 = a1;
  v13 = a1;
  v2 = *(dispatch_queue_s **)(a1 + 56);
  block = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = __dispatch_write_block_invoke_2_50;
  v8 = &__block_descriptor_tmp_51;
  v12 = *(_DWORD *)(a1 + 64);
  v9 = *(_QWORD *)(a1 + 32);
  v10 = *(_QWORD *)(a1 + 40);
  v11 = *(_QWORD *)(a1 + 48);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 56));
}

void __dispatch_write_block_invoke_2_50(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd[0x%x]: convenience handler invoke", v1, v2, v3, v4, v5, v6, v7, 1017);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24));
}

void __dispatch_write_block_invoke_53(uint64_t a1, char a2, dispatch_object_s *a3, int a4)
{
  if ((a2 & 1) != 0)
  {
    if (a3)
    {
      dispatch_retain(a3);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) = a3;
    }
    *(_DWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = a4;
  }
}

void dispatch_write_f(dispatch_fd_t a1, dispatch_data_s *a2, dispatch_queue_s *a3, uint64_t a4, uint64_t a5)
{
  void **handler;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t, uint64_t, unsigned int);
  void *v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  dispatch_queue_s *v14;
  dispatch_data_s *v15;
  dispatch_fd_t v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a5;
  handler = _NSConcreteStackBlock;
  v6 = 0x40000000;
  v7 = 0;
  v8 = __dispatch_write_f_block_invoke;
  v9 = &__block_descriptor_tmp_56;
  v10 = a5;
  v11 = a4;
  dispatch_write(a1, a2, a3, &handler);
}

uint64_t __dispatch_write_f_block_invoke(uint64_t a1, uint64_t a2, unsigned int a3)
{
  return (*(uint64_t (**)(_QWORD, uint64_t, _QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40), a2, a3);
}

void _dispatch_operation_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;

  _dispatch_object_debug(a1, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_operation_dispose");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: dispose", v8, v9, v10, v11, v12, v13, v14, 1121);
  if (*(_QWORD *)(a1 + 144))
  {
    _dispatch_operation_deliver_data(a1, 2, v15, v16, v17, v18, v19, v20);
    dispatch_group_leave(*(dispatch_group_t *)(*(_QWORD *)(a1 + 144) + 80));
    _dispatch_fd_entry_release(*(_QWORD *)(a1 + 144));
  }
  if (*(_QWORD *)(a1 + 136))
    _dispatch_release(*(unsigned int **)(a1 + 136));
  if (*(_QWORD *)(a1 + 152))
    dispatch_release(*(dispatch_object_t *)(a1 + 152));
  if (*(_QWORD *)(a1 + 176) && !*(_DWORD *)(a1 + 56))
    free(*(void **)(a1 + 176));
  if (*(_QWORD *)(a1 + 224))
    dispatch_release(*(dispatch_object_t *)(a1 + 224));
  if (*(_QWORD *)(a1 + 232))
    dispatch_release(*(dispatch_object_t *)(a1 + 232));
  if (*(_QWORD *)(a1 + 48))
    dispatch_release(*(dispatch_object_t *)(a1 + 48));
  _Block_release(*(const void **)(a1 + 128));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: disposed", v21, v22, v23, v24, v25, v26, v27, 1152);
}

void _dispatch_operation_deliver_data(uint64_t a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  dispatch_queue_s *v30;
  dispatch_data_s *v31;
  BOOL v32;
  void **block;
  int v34;
  int v35;
  void (*v36)(uint64_t);
  void *v37;
  uint64_t v38;
  dispatch_data_s *v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  int v43;
  int v44;
  int v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  int v50;
  uint64_t v51;
  dispatch_object_t v52;
  dispatch_data_s *v53;
  dispatch_data_t v54;
  dispatch_object_t v55;
  dispatch_data_s *v56;
  dispatch_object_t v57;
  dispatch_data_t concat;
  const void *v59;
  char v60;
  unint64_t v61;
  int v62;
  dispatch_data_s *subrange;
  int v64;
  uint64_t v65;
  uint64_t v66;
  _BOOL8 v67;

  v65 = a1;
  v64 = a2;
  subrange = 0;
  v62 = 0;
  v61 = 0;
  v61 = *(_QWORD *)(a1 + 208) + *(_QWORD *)(a1 + 200);
  v60 = 0;
  v32 = 1;
  if ((a2 & 3) == 0)
    v32 = (*(_DWORD *)(v65 + 184) & 1) != 0;
  v60 = v32;
  *(_DWORD *)(v65 + 184) = 0;
  if ((v60 & 1) != 0)
  {
    v62 = *(_DWORD *)(v65 + 120);
    if (!v62 && (*(_DWORD *)(*(_QWORD *)(v65 + 136) + 120) & 2) != 0)
    {
      v62 = 89;
      *(_DWORD *)(v65 + 120) = 89;
    }
  }
  else if (v61 < *(_QWORD *)(v65 + 72))
  {
    if (*(_QWORD *)(v65 + 200) < *(_QWORD *)(v65 + 192))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v8, v9, v10, v11, v12, v13, v14, 2622);
      return;
    }
  }
  else
  {
    v60 = 1;
  }
  if (!*(_DWORD *)(v65 + 56))
  {
    if (*(_QWORD *)(v65 + 200))
    {
      v59 = 0;
      v59 = *(const void **)(v65 + 176);
      subrange = dispatch_data_create(v59, *(_QWORD *)(v65 + 200), 0, &__block_literal_global);
      *(_QWORD *)(v65 + 176) = 0;
      *(_QWORD *)(v65 + 200) = 0;
      concat = 0;
      concat = dispatch_data_create_concat(*(dispatch_data_t *)(v65 + 232), subrange);
      v57 = *(dispatch_object_t *)(v65 + 232);
      dispatch_release(v57);
      v56 = subrange;
      dispatch_release(subrange);
      subrange = concat;
    }
    else
    {
      subrange = *(dispatch_data_s **)(v65 + 232);
    }
    if ((v60 & 1) != 0)
      v31 = &_dispatch_data_empty;
    else
      v31 = subrange;
    *(_QWORD *)(v65 + 232) = v31;
LABEL_33:
    if ((v60 & 1) != 0 && ((v64 & 8) == 0 || dispatch_data_get_size(subrange)))
    {
      *(_QWORD *)(v65 + 208) = 0;
      v51 = v65;
      _dispatch_object_debug(v65, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_operation_deliver_data");
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: deliver data", v23, v24, v25, v26, v27, v28, v29, 2687);
      v50 = 0;
      v50 = *(_DWORD *)(v65 + 56);
      v49 = 0;
      v49 = *(_QWORD *)(v65 + 128);
      v48 = 0;
      v48 = *(_QWORD *)(v65 + 144);
      _dispatch_fd_entry_retain(v48);
      v47 = 0;
      v47 = *(_QWORD *)(v65 + 136);
      v46 = v47;
      _dispatch_retain(v47);
      v30 = *(dispatch_queue_s **)(v65 + 48);
      block = _NSConcreteStackBlock;
      v34 = 1107296256;
      v35 = 0;
      v36 = ___dispatch_operation_deliver_data_block_invoke;
      v37 = &__block_descriptor_tmp_147;
      v43 = v64;
      v39 = subrange;
      v44 = v50;
      v45 = v62;
      v40 = v65;
      v38 = v49;
      v41 = v47;
      v42 = v48;
      dispatch_channel_async(v30, &block);
    }
    else
    {
      *(_QWORD *)(v65 + 208) = v61;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer data: undelivered %zu", v16, v17, v18, v19, v20, v21, v22, 2682);
    }
    return;
  }
  if (*(_DWORD *)(v65 + 56) == 1)
  {
    if ((v60 & 1) != 0)
      subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(v65 + 232), *(_QWORD *)(v65 + 200), *(_QWORD *)(v65 + 112));
    if (*(_QWORD *)(v65 + 224) && *(_QWORD *)(v65 + 200) == *(_QWORD *)(v65 + 192))
    {
      v55 = *(dispatch_object_t *)(v65 + 224);
      dispatch_release(v55);
      *(_QWORD *)(v65 + 224) = 0;
      *(_QWORD *)(v65 + 176) = 0;
      *(_QWORD *)(v65 + 200) = 0;
      v54 = 0;
      if ((v60 & 1) != 0)
      {
        v53 = subrange;
        dispatch_retain(subrange);
        v54 = subrange;
      }
      else
      {
        v54 = dispatch_data_create_subrange(*(dispatch_data_t *)(v65 + 232), *(_QWORD *)(v65 + 192), *(_QWORD *)(v65 + 112));
      }
      v52 = *(dispatch_object_t *)(v65 + 232);
      dispatch_release(v52);
      *(_QWORD *)(v65 + 232) = v54;
    }
    goto LABEL_33;
  }
  v15 = *(_DWORD *)(v65 + 56) < 2u;
  v67 = v15;
  v66 = 2677;
  if (!v15)
    _dispatch_abort(v66, v67, a3, a4, a5, a6, a7, a8);
}

void _dispatch_disk_dispose(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t i;

  if (*(_QWORD *)(a1 + 112))
    *(_QWORD *)(*(_QWORD *)(a1 + 112) + 120) = *(_QWORD *)(a1 + 120);
  **(_QWORD **)(a1 + 120) = *(_QWORD *)(a1 + 112);
  *(_QWORD *)(a1 + 112) = -1;
  *(_QWORD *)(a1 + 120) = -1;
  if (*(_QWORD *)(a1 + 48))
    _dispatch_abort(1792, *(_QWORD *)(a1 + 48) == 0, a3, a4, a5, a6, a7, a8);
  for (i = 0; i < *(_QWORD *)(a1 + 128); ++i)
  {
    if (*(_QWORD *)(a1 + 136 + 8 * i))
      _dispatch_abort(1795, *(_QWORD *)(a1 + 136 + 8 * i) == 0, a3, a4, a5, a6, a7, a8);
  }
  dispatch_release(*(dispatch_object_t *)(a1 + 72));
}

void ___dispatch_io_init_block_invoke(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  int v11;
  uint64_t v12;
  uint64_t v13;

  v13 = a1;
  v12 = a1;
  v2 = *(dispatch_queue_s **)(a1 + 40);
  block = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = ___dispatch_io_init_block_invoke_2;
  v8 = &__block_descriptor_tmp_64;
  v10 = *(_QWORD *)(a1 + 48);
  v11 = *(_DWORD *)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

uint64_t ___dispatch_io_init_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: cleanup handler invoke: err %d", v1, v2, v3, v4, v5, v6, v7, 270);
  return (*(uint64_t (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
}

void ___dispatch_io_stop_block_invoke(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v4;
  int v5;
  void (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = a1;
  v9 = a1;
  v2 = *(dispatch_queue_s **)(*(_QWORD *)(a1 + 32) + 56);
  block = _NSConcreteStackBlock;
  v4 = 0x40000000;
  v5 = 0;
  v6 = ___dispatch_io_stop_block_invoke_2;
  v7 = &__block_descriptor_tmp_75;
  v8 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v2, &block);
}

void ___dispatch_io_stop_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  void **block;
  int v17;
  int v18;
  void (*v19)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;

  v26 = a1;
  v25 = a1;
  v24 = *(_QWORD *)(a1 + 32);
  _dispatch_object_debug(v24, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_stop_block_invoke_2");
  v23 = 0;
  v23 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
  if (v23)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tchannel[%p]: stop cleanup", v8, v9, v10, v11, v12, v13, v14, 744);
    _dispatch_fd_entry_cleanup_operations(v23, *(_QWORD *)(a1 + 32));
    if ((*(_DWORD *)(*(_QWORD *)(a1 + 32) + 120) & 1) == 0)
    {
      if (*(_QWORD *)(v23 + 8))
        **(_QWORD **)(v23 + 8) = 0;
      *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = 0;
      _dispatch_fd_entry_release(v23);
    }
  }
  else if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 124) != -1)
  {
    v22 = *(_QWORD *)(a1 + 32);
    _dispatch_retain(v22);
    block = _NSConcreteStackBlock;
    v17 = 0x40000000;
    v18 = 0;
    v19 = ___dispatch_io_stop_block_invoke_3;
    v20 = &__block_descriptor_tmp_74;
    v21 = *(_QWORD *)(a1 + 32);
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_fds_lockq, &block);
  }
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_fd_entry_cleanup_operations(uint64_t a1, uint64_t a2)
{
  dispatch_queue_s *v2;
  dispatch_queue_s *v3;
  void **v4;
  int v5;
  int v6;
  void (*v7)(uint64_t *, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v8;
  dispatch_queue_s **v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  dispatch_queue_s **v13;
  unsigned int i;
  void **block;
  int v16;
  int v17;
  void (*v18)(uint64_t);
  void *v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;

  v24 = a1;
  v23 = a2;
  if (*(_QWORD *)(a1 + 56))
  {
    if (v23)
    {
      v22 = v23;
      _dispatch_retain(v23);
    }
    _dispatch_fd_entry_retain(v24);
    v2 = *(dispatch_queue_s **)(*(_QWORD *)(v24 + 56) + 72);
    block = _NSConcreteStackBlock;
    v16 = 0x40000000;
    v17 = 0;
    v18 = ___dispatch_fd_entry_cleanup_operations_block_invoke;
    v19 = &__block_descriptor_tmp_77;
    v20 = v24;
    v21 = v23;
    dispatch_channel_async(v2, &block);
  }
  else
  {
    for (i = 0; i < 2; ++i)
    {
      v13 = 0;
      v13 = *(dispatch_queue_s ***)(v24 + 40 + 8 * i);
      if (v13)
      {
        if (v23)
        {
          v12 = v23;
          _dispatch_retain(v23);
        }
        _dispatch_fd_entry_retain(v24);
        v3 = *v13;
        v4 = _NSConcreteStackBlock;
        v5 = 0x40000000;
        v6 = 0;
        v7 = ___dispatch_fd_entry_cleanup_operations_block_invoke_2;
        v8 = &__block_descriptor_tmp_78;
        v9 = v13;
        v10 = v23;
        v11 = v24;
        dispatch_channel_async(v3, &v4);
      }
    }
  }
}

void ___dispatch_io_stop_block_invoke_3(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t i;

  _dispatch_object_debug(*(_QWORD *)(a1 + 32), "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_io_stop_block_invoke_3");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: stop cleanup after close", v8, v9, v10, v11, v12, v13, v14, 759);
  for (i = _dispatch_io_fds[*(_DWORD *)(*(_QWORD *)(a1 + 32) + 124) & 0x3FLL]; i; i = *(_QWORD *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(*(_QWORD *)(a1 + 32) + 124))
    {
      _dispatch_fd_entry_cleanup_operations(i, *(_QWORD *)(a1 + 32));
      break;
    }
  }
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke(uint64_t a1)
{
  _dispatch_disk_cleanup_inactive_operations(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56), *(_QWORD *)(a1 + 40));
  _dispatch_fd_entry_release(*(_QWORD *)(a1 + 32));
  if (*(_QWORD *)(a1 + 40))
    _dispatch_release(*(unsigned int **)(a1 + 40));
}

void _dispatch_disk_cleanup_inactive_operations(uint64_t a1, uint64_t a2)
{
  _dispatch_disk_cleanup_specified_operations(a1, a2, 1);
}

void ___dispatch_fd_entry_cleanup_operations_block_invoke_2(uint64_t *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_stream_cleanup_operations(a1[4], a1[5], a3, a4, a5, a6, a7, a8);
  _dispatch_fd_entry_release(a1[6]);
  if (a1[5])
    _dispatch_release((unsigned int *)a1[5]);
}

void _dispatch_stream_cleanup_operations(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v8;
  char v9;
  uint64_t v10;
  uint64_t i;
  uint64_t j;

  v10 = 0;
  for (i = *(_QWORD *)(a1 + 48); ; i = v10)
  {
    v9 = 0;
    if (i)
    {
      v10 = *(_QWORD *)(i + 240);
      v9 = 1;
    }
    if ((v9 & 1) == 0)
      break;
    if (!a2 || *(_QWORD *)(i + 136) == a2)
      _dispatch_stream_complete_operation(a1, i, a3, a4, a5, a6, a7, a8);
  }
  for (j = *(_QWORD *)(a1 + 32); ; j = v10)
  {
    v8 = 0;
    if (j)
    {
      v10 = *(_QWORD *)(j + 240);
      v8 = 1;
    }
    if ((v8 & 1) == 0)
      break;
    if (!a2 || *(_QWORD *)(j + 136) == a2)
      _dispatch_stream_complete_operation(a1, j, a3, a4, a5, a6, a7, a8);
  }
  if ((*(_BYTE *)(a1 + 24) & 1) != 0 && !_dispatch_stream_operation_avail(a1))
  {
    dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
    *(_BYTE *)(a1 + 24) = 0;
  }
}

void _dispatch_disk_cleanup_specified_operations(uint64_t a1, uint64_t a2, char a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  char v16;
  uint64_t v17;
  uint64_t i;
  char v19;

  v19 = a3 & 1;
  v17 = 0;
  for (i = *(_QWORD *)(a1 + 48); ; i = v17)
  {
    v16 = 0;
    if (i)
    {
      v17 = *(_QWORD *)(i + 240);
      v16 = 1;
    }
    if ((v16 & 1) == 0)
      break;
    if (((v19 & 1) == 0 || (*(_BYTE *)(i + 160) & 1) == 0) && (!a2 || *(_QWORD *)(i + 136) == a2))
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: cleanup: disk %p", v3, v4, v5, v6, v7, v8, v9, 1985);
      _dispatch_disk_complete_operation(a1, i, v10, v11, v12, v13, v14, v15);
    }
  }
}

void _dispatch_disk_complete_operation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;

  _dispatch_object_debug(a2, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_disk_complete_operation");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: complete: disk %p", v8, v9, v10, v11, v12, v13, v14, 1869);
  if (*(_QWORD *)(a1 + 64) == a2)
    *(_QWORD *)(a1 + 64) = **(_QWORD **)(*(_QWORD *)(a2 + 248) + 8);
  if (!*(_QWORD *)(a2 + 64))
  {
    v22 = *(_QWORD *)(a2 + 256);
    if (v22)
      *(_QWORD *)(*(_QWORD *)(a2 + 256) + 264) = *(_QWORD *)(a2 + 264);
    else
      *(_QWORD *)(*(_QWORD *)(a2 + 144) + 104) = *(_QWORD *)(a2 + 264);
    **(_QWORD **)(a2 + 264) = *(_QWORD *)(a2 + 256);
    *(_QWORD *)(a2 + 256) = -1;
    *(_QWORD *)(a2 + 264) = -1;
    if (v22)
    {
      *(_QWORD *)(v22 + 240) = 0;
      *(_QWORD *)(v22 + 248) = *(_QWORD *)(a1 + 56);
      **(_QWORD **)(a1 + 56) = v22;
      *(_QWORD *)(a1 + 56) = v22 + 240;
    }
  }
  if (*(_QWORD *)(a2 + 240))
    *(_QWORD *)(*(_QWORD *)(a2 + 240) + 248) = *(_QWORD *)(a2 + 248);
  else
    *(_QWORD *)(a1 + 56) = *(_QWORD *)(a2 + 248);
  **(_QWORD **)(a2 + 248) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a2 + 240) = -1;
  *(_QWORD *)(a2 + 248) = -1;
  if (*(_QWORD *)(a2 + 152))
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk complete)", v15, v16, v17, v18, v19, v20, v21, 1888);
  _dispatch_release((unsigned int *)a2);
}

void _dispatch_stream_complete_operation(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;

  _dispatch_object_debug(a2, "%s", a3, a4, a5, a6, a7, a8, (char)"_dispatch_stream_complete_operation");
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: complete: stream %p", v8, v9, v10, v11, v12, v13, v14, 1851);
  if (*(_QWORD *)(a2 + 240))
    *(_QWORD *)(*(_QWORD *)(a2 + 240) + 248) = *(_QWORD *)(a2 + 248);
  else
    *(_QWORD *)(a1 + 32 + 16 * *(_QWORD *)(a2 + 64) + 8) = *(_QWORD *)(a2 + 248);
  **(_QWORD **)(a2 + 248) = *(_QWORD *)(a2 + 240);
  *(_QWORD *)(a2 + 240) = -1;
  *(_QWORD *)(a2 + 248) = -1;
  if (a2 == *(_QWORD *)(a1 + 16))
    *(_QWORD *)(a1 + 16) = 0;
  if (*(_QWORD *)(a2 + 152))
    dispatch_source_cancel(*(dispatch_source_t *)(a2 + 152));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (stream complete)", v15, v16, v17, v18, v19, v20, v21, 1860);
  _dispatch_release((unsigned int *)a2);
}

BOOL _dispatch_stream_operation_avail(uint64_t a1)
{
  BOOL v2;

  v2 = 1;
  if (!*(_QWORD *)(a1 + 48))
    return *(_QWORD *)(a1 + 32) != 0;
  return v2;
}

void ___dispatch_operation_create_block_invoke(uint64_t a1)
{
  dispatch_queue_s *v2;
  void **block;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  int v12;
  int v13;
  uint64_t v14;
  uint64_t v15;

  v15 = a1;
  v14 = a1;
  v2 = *(dispatch_queue_s **)(a1 + 40);
  block = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = ___dispatch_operation_create_block_invoke_2;
  v8 = &__block_descriptor_tmp_85;
  v10 = *(_QWORD *)(a1 + 48);
  v12 = *(_DWORD *)(a1 + 64);
  v13 = *(_DWORD *)(a1 + 68);
  v11 = *(_QWORD *)(a1 + 56);
  v9 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v2, &block);
  _dispatch_release(*(unsigned int **)(a1 + 40));
}

void ___dispatch_operation_create_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tchannel[%p]: IO handler invoke: err %d", v1, v2, v3, v4, v5, v6, v7, 1081);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _dispatch_release(*(unsigned int **)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void ___dispatch_operation_enqueue_block_invoke(uint64_t a1)
{
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void ___dispatch_operation_enqueue_block_invoke_91(uint64_t a1)
{
  _dispatch_stream_enqueue_operation(*(dispatch_queue_t **)(a1 + 32), *(_QWORD **)(a1 + 40), *(dispatch_object_s **)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

void _dispatch_stream_enqueue_operation(dispatch_queue_t *a1, _QWORD *a2, dispatch_object_s *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  BOOL v9;

  if ((_dispatch_operation_should_enqueue((uint64_t)a2, *a1, a3) & 1) != 0)
  {
    _dispatch_object_debug((uint64_t)a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_stream_enqueue_operation");
    v9 = !_dispatch_stream_operation_avail((uint64_t)a1);
    a2[30] = 0;
    a2[31] = a1[2 * a2[8] + 5];
    *(_QWORD *)a1[2 * a2[8] + 5] = a2;
    a1[2 * a2[8] + 5] = (dispatch_queue_t)(a2 + 30);
    if (v9)
      dispatch_channel_async_f(*a1, *a1, (dispatch_function_t)_dispatch_stream_queue_handler);
  }
}

void ___dispatch_operation_enqueue_block_invoke_2(uint64_t a1)
{
  _dispatch_disk_enqueue_operation(*(_QWORD *)(a1 + 32), *(_QWORD **)(a1 + 40), *(dispatch_object_s **)(a1 + 48));
  dispatch_release(*(dispatch_object_t *)(a1 + 48));
}

void _dispatch_disk_enqueue_operation(uint64_t a1, _QWORD *a2, dispatch_object_s *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  if ((_dispatch_operation_should_enqueue((uint64_t)a2, *(dispatch_queue_s **)(a1 + 72), a3) & 1) != 0)
  {
    _dispatch_object_debug((uint64_t)a2, "%s", v3, v4, v5, v6, v7, v8, (char)"_dispatch_disk_enqueue_operation");
    if (a2[8])
    {
      a2[30] = 0;
      a2[31] = *(_QWORD *)(a1 + 56);
      **(_QWORD **)(a1 + 56) = a2;
      *(_QWORD *)(a1 + 56) = a2 + 30;
    }
    else
    {
      if (!*(_QWORD *)(a2[18] + 96))
      {
        a2[30] = 0;
        a2[31] = *(_QWORD *)(a1 + 56);
        **(_QWORD **)(a1 + 56) = a2;
        *(_QWORD *)(a1 + 56) = a2 + 30;
      }
      a2[32] = 0;
      a2[33] = *(_QWORD *)(a2[18] + 104);
      **(_QWORD **)(a2[18] + 104) = a2;
      *(_QWORD *)(a2[18] + 104) = a2 + 32;
    }
    _dispatch_disk_handler(a1);
  }
}

uint64_t _dispatch_operation_should_enqueue(uint64_t a1, dispatch_queue_s *a2, dispatch_object_s *a3)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  dispatch_object_s *object;
  int error;
  char v23;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: enqueue", v3, v4, v5, v6, v7, v8, v9, 1203);
  dispatch_retain(a3);
  *(_QWORD *)(a1 + 232) = a3;
  error = _dispatch_io_get_error(a1, 0, 1);
  if (error)
  {
    *(_DWORD *)(a1 + 120) = error;
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: release -> %d, err %d", v10, v11, v12, v13, v14, v15, v16, 1210);
    _dispatch_release((unsigned int *)a1);
    v23 = 0;
  }
  else
  {
    if (*(_QWORD *)(a1 + 88))
    {
      object = (dispatch_object_s *)_dispatch_operation_timer(a2, a1);
      dispatch_resume(object);
    }
    v23 = 1;
  }
  return v23 & 1;
}

void _dispatch_stream_queue_handler(dispatch_object_s *a1)
{
  void *context;

  context = dispatch_get_context(a1);
  if (context)
    _dispatch_stream_handler((uint64_t)context);
}

uint64_t _dispatch_operation_timer(dispatch_queue_s *a1, uint64_t a2)
{
  dispatch_time_t v2;
  void **handler;
  int v5;
  int v6;
  void (*v7)(uint64_t);
  void *v8;
  dispatch_source_t v9;
  uint64_t v10;
  dispatch_source_t v11;
  uint64_t v12;
  dispatch_queue_t v13;

  v13 = a1;
  v12 = a2;
  if (!*(_QWORD *)(a2 + 152))
  {
    v11 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_timer, 0, 0, v13);
    v2 = dispatch_time(0, *(_QWORD *)(v12 + 88));
    dispatch_source_set_timer(v11, v2, *(_QWORD *)(v12 + 88), 0);
    handler = _NSConcreteStackBlock;
    v5 = 0x40000000;
    v6 = 0;
    v7 = ___dispatch_operation_timer_block_invoke;
    v8 = &__block_descriptor_tmp_95;
    v9 = v11;
    v10 = v12;
    dispatch_source_set_event_handler(v11, &handler);
    *(_QWORD *)(v12 + 152) = v11;
  }
  return *(_QWORD *)(v12 + 152);
}

void ___dispatch_operation_timer_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  _BOOL4 v8;

  if (!dispatch_source_testcancel(*(dispatch_source_t *)(a1 + 32)))
  {
    v8 = (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 96) & 1) != 0;
    if ((*(_BYTE *)(*(_QWORD *)(a1 + 40) + 160) & 1) != 0 && (*(_QWORD *)(*(_QWORD *)(a1 + 40) + 96) & 1) != 0)
      *(_DWORD *)(*(_QWORD *)(a1 + 40) + 184) = v8;
    else
      _dispatch_operation_deliver_data(*(_QWORD *)(a1 + 40), v8, v1, v2, v3, v4, v5, v6);
  }
}

void _dispatch_stream_handler(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  unint64_t v34;
  uint64_t v35;
  int error;
  uint64_t operation;

  while (1)
  {
    operation = _dispatch_stream_pick_next_operation(a1, *(_QWORD *)(a1 + 16));
    if (!operation)
    {
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\tno operation found: stream %p", v1, v2, v3, v4, v5, v6, v7, 2072);
      return;
    }
    error = _dispatch_io_get_error(operation, 0, 1);
    if (!error)
      break;
    *(_DWORD *)(operation + 120) = error;
    _dispatch_stream_complete_operation(a1, operation, v8, v9, v10, v11, v12, v13);
  }
  *(_QWORD *)(a1 + 16) = operation;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream handler", v14, v15, v16, v17, v18, v19, v20, 2082);
  v35 = *(_QWORD *)(operation + 144);
  _dispatch_fd_entry_retain(v35);
  if (!*(_QWORD *)(operation + 216) && (byte_E4D40 & 1) != 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: initial delivery", v21, v22, v23, v24, v25, v26, v27, 2088);
    _dispatch_operation_deliver_data(operation, 1, v28, v29, v30, v31, v32, v33);
  }
  v34 = _dispatch_operation_perform(operation) - 1;
  if (v34 <= 6)
    __asm { BR              X8 }
  _dispatch_fd_entry_release(v35);
}

uint64_t _dispatch_stream_pick_next_operation(uint64_t a1, uint64_t a2)
{
  uint64_t v3;
  uint64_t v4;

  v3 = a2;
  if (a2)
  {
    if (*(_QWORD *)(a2 + 64))
    {
      if (*(_QWORD *)(a2 + 64) == 1)
      {
        v4 = *(_QWORD *)(a2 + 240);
        if (!v4)
          return *(_QWORD *)(a1 + 48);
        return v4;
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return a2;
    }
  }
  else if (_dispatch_stream_operation_avail(a1))
  {
    if (*(_QWORD *)(a1 + 32))
      return *(_QWORD *)(a1 + 32);
    if (*(_QWORD *)(a1 + 48))
      return *(_QWORD *)(a1 + 48);
    return v3;
  }
  else
  {
    return 0;
  }
}

uint64_t _dispatch_operation_perform(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  dispatch_data_s *v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;
  uint64_t v53;
  uint64_t v54;
  uint64_t v55;
  unsigned int *v56;
  unsigned int v57;
  uint64_t NOCANCEL;
  uint64_t v60;
  uint64_t v61;
  uint64_t v62;
  dispatch_data_s *data;
  void **applier;
  int v65;
  int v66;
  BOOL (*v67)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v68;
  uint64_t v69;
  unint64_t v70;
  size_t size;
  unint64_t v72;
  unint64_t v73;
  uint64_t v74;
  int error;
  uint64_t v76;
  uint64_t v78;
  _BOOL8 v79;
  uint64_t v80;
  _BOOL8 v81;
  uint64_t v82;
  uint64_t v83;
  unint64_t StatusReg;

  v76 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: perform", v1, v2, v3, v4, v5, v6, v7, 2328);
  error = _dispatch_io_get_error(v76, 0, 1);
  if (error)
    goto LABEL_45;
  v74 = v76;
  _dispatch_object_debug(v76, "%s", v8, v9, v10, v11, v12, v13, (char)"_dispatch_operation_perform");
  if (!*(_QWORD *)(v76 + 176))
  {
    v73 = 0;
    v73 = *(_QWORD *)(v76 + 80);
    v72 = dispatch_io_defaults;
    if (*(_DWORD *)(v76 + 56))
    {
      if (*(_DWORD *)(v76 + 56) == 1)
      {
        if (v72 > v73)
          v72 = v73;
        *(_QWORD *)(v76 + 192) = 0;
        v27 = *(dispatch_data_s **)(v76 + 232);
        applier = _NSConcreteStackBlock;
        v65 = 0x40000000;
        v66 = 0;
        v67 = ___dispatch_operation_perform_block_invoke;
        v68 = &__block_descriptor_tmp_103;
        v69 = v76;
        v70 = v72;
        dispatch_data_apply(v27, &applier);
        if (*(_QWORD *)(v76 + 192) > v73)
          *(_QWORD *)(v76 + 192) = v73;
        data = dispatch_data_create_subrange(*(dispatch_data_t *)(v76 + 232), 0, *(_QWORD *)(v76 + 192));
        *(_QWORD *)(v76 + 224) = dispatch_data_create_map(data, (const void **)(v76 + 176), 0);
        dispatch_release(data);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: buffer mapped", v28, v29, v30, v31, v32, v33, v34, 2396);
      }
    }
    else
    {
      size = 0;
      size = dispatch_data_get_size(*(dispatch_data_t *)(v76 + 232));
      if (size)
      {
        v81 = size < v73;
        v80 = 2342;
        if (size >= v73)
          _dispatch_abort(v80, 0, v14, v15, v16, v17, v18, v19);
        v73 -= size;
      }
      if (v73 > v72)
        v73 = v72;
      if (*(_QWORD *)(v76 + 112) == -1)
      {
        *(_QWORD *)(v76 + 192) = v73;
      }
      else
      {
        *(_QWORD *)(v76 + 192) = *(_QWORD *)(v76 + 112) - *(_QWORD *)(v76 + 216);
        if (*(_QWORD *)(v76 + 192) > v73)
          *(_QWORD *)(v76 + 192) = v73;
      }
      error = malloc_type_posix_memalign(v76 + 176, vm_page_size, *(_QWORD *)(v76 + 192), 595666265);
      if (error)
        goto LABEL_45;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: buffer allocated", v20, v21, v22, v23, v24, v25, v26, 2370);
    }
  }
  if (**(_DWORD **)(v76 + 144) == -1)
  {
    error = _dispatch_fd_entry_open(*(_QWORD *)(v76 + 144), *(_QWORD *)(v76 + 136));
    if (error)
    {
LABEL_45:
      if (error == 35)
      {
        v79 = *(_QWORD *)(*(_QWORD *)(v76 + 144) + 56) == 0;
        v78 = 2583;
        if (!v79)
          _dispatch_abort(v78, 0, v8, v9, v10, v11, v12, v13);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: performed: EAGAIN/EWOULDBLOCK", v42, v43, v44, v45, v46, v47, v48, 2584);
        if (!*(_DWORD *)(v76 + 56)
          && *(_QWORD *)(v76 + 216)
          && *(_QWORD *)(v76 + 136) == *(_QWORD *)(*(_QWORD *)(v76 + 144) + 88))
        {
          return 4;
        }
        else
        {
          return 5;
        }
      }
      else
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: performed: err %d", v49, v50, v51, v52, v53, v54, v55, 2592);
        *(_DWORD *)(v76 + 120) = error;
        if (error == 9)
        {
          v56 = (unsigned int *)(*(_QWORD *)(v76 + 144) + 24);
          do
            v57 = __ldaxr(v56);
          while (!v57 && __stlxr(9u, v56));
          return 7;
        }
        else if (error == 89)
        {
          return 6;
        }
        else
        {
          return 1;
        }
      }
    }
  }
  v62 = *(_QWORD *)(v76 + 176) + *(_QWORD *)(v76 + 200);
  v61 = *(_QWORD *)(v76 + 192) - *(_QWORD *)(v76 + 200);
  v60 = *(_QWORD *)(v76 + 104) + *(_QWORD *)(v76 + 216);
  NOCANCEL = -1;
  while (1)
  {
    if (*(_DWORD *)(v76 + 56))
    {
      if (*(_DWORD *)(v76 + 56) == 1)
      {
        if (*(_QWORD *)(v76 + 64))
        {
          if (*(_QWORD *)(v76 + 64) == 1)
            NOCANCEL = pwrite_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61, v60);
        }
        else
        {
          NOCANCEL = write_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61);
        }
      }
    }
    else if (*(_QWORD *)(v76 + 64))
    {
      if (*(_QWORD *)(v76 + 64) == 1)
        NOCANCEL = pread_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61, v60);
    }
    else
    {
      NOCANCEL = read_NOCANCEL(**(unsigned int **)(v76 + 144), v62, v61);
    }
    if (NOCANCEL != -1)
      break;
    v82 = 1;
    v83 = 1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    error = **(_DWORD **)(StatusReg + 8);
    if (error != 4)
      goto LABEL_45;
  }
  if (NOCANCEL)
  {
    *(_QWORD *)(v76 + 200) += NOCANCEL;
    *(_QWORD *)(v76 + 216) += NOCANCEL;
    if (*(_QWORD *)(v76 + 216) == *(_QWORD *)(v76 + 112))
      return 1;
    else
      return 2;
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: performed: EOF", v35, v36, v37, v38, v39, v40, v41, 2568);
    return 3;
  }
}

dispatch_queue_t _dispatch_stream_source(dispatch_queue_t *a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  void **v17;
  int v18;
  int v19;
  void (*v20)(uint64_t);
  void *v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  dispatch_source_t v25;
  dispatch_source_t v26;
  int v27;
  uint64_t v28;
  dispatch_queue_t *v29;
  uint64_t v31;
  _BOOL8 v32;

  v29 = a1;
  v28 = a2;
  if (a1[1])
    return v29[1];
  v27 = 0;
  v27 = **(_DWORD **)(v28 + 144);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream source create", v2, v3, v4, v5, v6, v7, v8, 2015);
  v26 = 0;
  if (!*(_DWORD *)(v28 + 56))
  {
    v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_read, v27, 0, *v29);
LABEL_10:
    v25 = v26;
    dispatch_set_context(v26, v29);
    dispatch_source_set_event_handler_f(v26, (dispatch_function_t)_dispatch_stream_source_handler);
    v24 = 0;
    v24 = *(_QWORD *)(*(_QWORD *)(v28 + 144) + 64);
    v17 = _NSConcreteStackBlock;
    v18 = 0x40000000;
    v19 = 0;
    v20 = ___dispatch_stream_source_block_invoke;
    v21 = &__block_descriptor_tmp_110;
    v22 = v28;
    v23 = v24;
    dispatch_source_set_mandatory_cancel_handler(v26, &v17);
    v29[1] = (dispatch_queue_t)v26;
    return v29[1];
  }
  if (*(_DWORD *)(v28 + 56) == 1)
  {
    v26 = dispatch_source_create((dispatch_source_type_t)&_dispatch_source_type_write, v27, 0, *v29);
    goto LABEL_10;
  }
  v15 = *(_DWORD *)(v28 + 56) < 2u;
  v32 = v15;
  v31 = 2024;
  if (!v15)
    _dispatch_abort(v31, v32, v9, v10, v11, v12, v13, v14);
  return 0;
}

void ___dispatch_stream_handler_block_invoke(uint64_t a1)
{
  _dispatch_fd_entry_cleanup_operations(*(_QWORD *)(a1 + 32), 0);
  _dispatch_fd_entry_release(*(_QWORD *)(a1 + 32));
}

BOOL ___dispatch_operation_perform_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v6;

  v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) + a5;
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) || v6 <= *(_QWORD *)(a1 + 40))
    *(_QWORD *)(*(_QWORD *)(a1 + 32) + 192) = v6;
  return v6 < *(_QWORD *)(a1 + 40);
}

uint64_t _dispatch_stream_source_handler(uint64_t a1)
{
  dispatch_suspend(*(dispatch_object_t *)(a1 + 8));
  *(_BYTE *)(a1 + 24) = 0;
  return _dispatch_stream_handler(a1);
}

void ___dispatch_stream_source_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: stream source cancel", v1, v2, v3, v4, v5, v6, v7, 2034);
  dispatch_resume(*(dispatch_object_t *)(a1 + 40));
}

void _dispatch_disk_handler(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  uint64_t v38;
  uint64_t v39;
  uint64_t v40;
  int error;
  unint64_t v42;
  unint64_t v43;
  uint64_t operation;
  uint64_t v45;

  if ((*(_BYTE *)(a1 + 108) & 1) == 0)
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tdisk[%p]: disk handler", v1, v2, v3, v4, v5, v6, v7, 2146);
    v43 = *(_QWORD *)(a1 + 80);
    v42 = *(_QWORD *)(a1 + 88);
    if (v42 <= v43)
      v42 += *(_QWORD *)(a1 + 128);
    while (v43 <= v42)
    {
      if (*(_QWORD *)(a1 + 136 + 8 * (v43 % *(_QWORD *)(a1 + 128))))
        break;
      operation = _dispatch_disk_pick_next_operation(a1);
      if (!operation)
        break;
      error = _dispatch_io_get_error(operation, 0, 1);
      if (error)
      {
        *(_DWORD *)(operation + 120) = error;
        _dispatch_disk_complete_operation(a1, operation, v8, v9, v10, v11, v12, v13);
      }
      else
      {
        _dispatch_retain(operation);
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: retain -> %d", v14, v15, v16, v17, v18, v19, v20, 2162);
        *(_QWORD *)(a1 + 136 + 8 * (v43 % *(_QWORD *)(a1 + 128))) = operation;
        *(_BYTE *)(operation + 160) = 1;
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: activate: disk %p", v21, v22, v23, v24, v25, v26, v27, 2165);
        _dispatch_object_debug(operation, "%s", v28, v29, v30, v31, v32, v33, (char)"_dispatch_disk_handler");
        ++v43;
      }
    }
    *(_QWORD *)(a1 + 80) = v43 % *(_QWORD *)(a1 + 128);
    v45 = *(_QWORD *)(a1 + 136 + 8 * *(_QWORD *)(a1 + 88));
    if (v45)
    {
      *(_BYTE *)(a1 + 108) = 1;
      _dispatch_thread_getspecific(0);
      _dispatch_log("%u\t%p\top[%p]: async perform: disk %p", v34, v35, v36, v37, v38, v39, v40, 2177);
      dispatch_channel_async_f(*(dispatch_queue_t *)(v45 + 24), (void *)a1, (dispatch_function_t)_dispatch_disk_perform);
    }
  }
}

uint64_t _dispatch_disk_pick_next_operation(uint64_t a1)
{
  BOOL v2;
  uint64_t v3;

  if (!*(_QWORD *)(a1 + 48))
    return 0;
  if (*(_QWORD *)(a1 + 64))
  {
    v3 = *(_QWORD *)(a1 + 64);
    do
    {
      v3 = *(_QWORD *)(v3 + 240);
      if (!v3)
        v3 = *(_QWORD *)(a1 + 48);
      v2 = 0;
      if ((*(_BYTE *)(v3 + 160) & 1) != 0)
        v2 = v3 != *(_QWORD *)(a1 + 64);
    }
    while (v2);
  }
  else
  {
    v3 = *(_QWORD *)(a1 + 48);
  }
  if ((*(_BYTE *)(v3 + 160) & 1) != 0)
    return 0;
  *(_QWORD *)(a1 + 64) = v3;
  return v3;
}

void _dispatch_disk_perform(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  dispatch_queue_s *v34;
  void **block;
  int v36;
  int v37;
  void (*v38)(uint64_t);
  void *v39;
  uint64_t v40;
  _QWORD *v41;
  int v42;
  int v43;
  unint64_t v44;
  unint64_t v45;
  uint64_t v46;
  uint64_t v47;
  _QWORD *v48;
  _QWORD *v49;
  uint64_t v50;
  _BOOL8 v51;

  v49 = a1;
  v48 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tdisk[%p]: disk perform", v1, v2, v3, v4, v5, v6, v7, 2186);
  v47 = dispatch_io_defaults;
  v46 = 0;
  v45 = 0;
  v45 = v48[12];
  v44 = 0;
  v44 = v48[10];
  if (v44 <= v45)
    v44 += v48[16];
  while (1)
  {
    v46 = v48[v45 % v48[16] + 17];
    if (!v46)
      break;
    if (*(_DWORD *)(v46 + 56) != 1
      && (**(_DWORD **)(v46 + 144) != -1
       || !_dispatch_fd_entry_open(*(_QWORD *)(v46 + 144), *(_QWORD *)(v46 + 136))))
    {
      if (!*(_QWORD *)(v46 + 216) && (byte_E4D40 & 1) != 0)
      {
        _dispatch_thread_getspecific(0);
        _dispatch_log("%u\t%p\top[%p]: initial delivery", v14, v15, v16, v17, v18, v19, v20, 2211);
        _dispatch_operation_deliver_data(v46, 1, v21, v22, v23, v24, v25, v26);
      }
      if (v44 - v45 == 1 && !v48[v48[10] + 17] && !*(_QWORD *)(v46 + 168))
        v47 *= 2;
      _dispatch_operation_advise(v46, v47);
    }
    if (++v45 >= v44)
      goto LABEL_19;
  }
  v51 = v45 % v48[16] == v48[10];
  v50 = 2197;
  if (!v51)
    _dispatch_abort(v50, 0, v8, v9, v10, v11, v12, v13);
LABEL_19:
  v48[12] = v45 % v48[16];
  v46 = v48[v48[11] + 17];
  v43 = _dispatch_operation_perform(v46);
  v48[v48[11] + 17] = 0;
  v48[11] = (unint64_t)(v48[11] + 1) % v48[16];
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: async perform completion: disk %p", v27, v28, v29, v30, v31, v32, v33, 2227);
  v34 = (dispatch_queue_s *)v48[9];
  block = _NSConcreteStackBlock;
  v36 = 0x40000000;
  v37 = 0;
  v38 = ___dispatch_disk_perform_block_invoke;
  v39 = &__block_descriptor_tmp_120;
  v40 = v46;
  v42 = v43;
  v41 = v48;
  dispatch_channel_async(v34, &block);
}

void _dispatch_operation_advise(uint64_t a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  int v21;
  int v22;
  vm_size_t v23;
  int v24;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: advise", v2, v3, v4, v5, v6, v7, v8, 2270);
  if (!_dispatch_io_get_error(a1, 0, 1)
    && *(_QWORD *)(a1 + 168) <= (int64_t)(*(_QWORD *)(a1 + 104) + *(_QWORD *)(a1 + 216) + a2 + vm_page_size))
  {
    _dispatch_object_debug(a1, "%s", v9, v10, v11, v12, v13, v14, (char)"_dispatch_operation_advise");
    v24 = a2;
    if (!*(_QWORD *)(a1 + 168))
    {
      *(_QWORD *)(a1 + 168) = *(_QWORD *)(a1 + 104);
      v23 = (*(_QWORD *)(a1 + 104) + a2) % vm_page_size;
      if (v23)
        v22 = vm_page_size - v23;
      else
        v22 = 0;
      v24 = a2 + v22;
    }
    *(_QWORD *)(a1 + 168) += v24;
    while (1)
    {
      v21 = fcntl_NOCANCEL(**(unsigned int **)(a1 + 144), 44) == -1
          ? **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8)
          : 0;
      if (!v21)
        break;
      if (v21 != 4)
      {
        if (v21 != 27 && v21 != 45)
          _dispatch_bug(2308, v21, v15, v16, v17, v18, v19, v20);
        return;
      }
    }
  }
}

void ___dispatch_disk_perform_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  unint64_t v28;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: perform completion", v1, v2, v3, v4, v5, v6, v7, 2229);
  v28 = (*(_DWORD *)(a1 + 48) - 1);
  if (v28 <= 6)
    __asm { BR              X8 }
  if (!*(_DWORD *)(a1 + 48))
    _dispatch_abort(2248, *(int *)(a1 + 48), v8, v9, v10, v11, v12, v13);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: deactivate: disk %p", v14, v15, v16, v17, v18, v19, v20, 2251);
  *(_BYTE *)(*(_QWORD *)(a1 + 32) + 160) = 0;
  *(_BYTE *)(*(_QWORD *)(a1 + 40) + 108) = 0;
  _dispatch_disk_handler(*(_QWORD *)(a1 + 40));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: release -> %d (disk perform complete)", v21, v22, v23, v24, v25, v26, v27, 2259);
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void _dispatch_disk_cleanup_operations(uint64_t a1, uint64_t a2)
{
  _dispatch_disk_cleanup_specified_operations(a1, a2, 0);
}

void ___dispatch_fd_entry_init_async_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  dispatch_queue_s *v8;
  void **block;
  int v11;
  int v12;
  void (*v13)(uint64_t);
  void *v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t i;
  uint64_t v19;
  uint64_t v20;

  v20 = a1;
  v19 = a1;
  i = 0;
  v17 = 0;
  v17 = *(_DWORD *)(a1 + 40) & 0x3FLL;
  for (i = _dispatch_io_fds[v17]; i; i = *(_QWORD *)(i + 112))
  {
    if (*(_DWORD *)i == *(_DWORD *)(a1 + 40))
    {
      _dispatch_fd_entry_retain(i);
      break;
    }
  }
  if (!i)
    i = _dispatch_fd_entry_create_with_fd(*(_DWORD *)(a1 + 40), v17);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: init", v1, v2, v3, v4, v5, v6, v7, 1400);
  v8 = *(dispatch_queue_s **)(i + 72);
  block = _NSConcreteStackBlock;
  v11 = 1107296256;
  v12 = 0;
  v13 = ___dispatch_fd_entry_init_async_block_invoke_2;
  v14 = &__block_descriptor_tmp_124;
  v16 = i;
  v15 = *(_QWORD *)(a1 + 32);
  dispatch_channel_async(v8, &block);
}

uint64_t _dispatch_fd_entry_create_with_fd(int a1, uint64_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  dispatch_queue_s *v10;
  dispatch_queue_s *v11;
  dispatch_queue_s *v12;
  void **v14;
  int v15;
  int v16;
  void (*v17)(uint64_t);
  void *v18;
  uint64_t v19;
  int v20;
  void **v21;
  int v22;
  int v23;
  void (*v24)(uint64_t);
  void *v25;
  uint64_t v26;
  void **block;
  int v28;
  int v29;
  void (*v30)(uint64_t);
  void *v31;
  uint64_t v32;
  int v33;
  uint64_t v34;
  uint64_t v35;
  int v36;

  v36 = a1;
  v35 = a2;
  v34 = _dispatch_fd_entry_create((dispatch_queue_s *)_dispatch_io_fds_lockq);
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: create: fd %d", v2, v3, v4, v5, v6, v7, v8, 1431);
  *(_DWORD *)v34 = v36;
  v9 = _dispatch_io_fds[v35];
  *(_QWORD *)(v34 + 112) = v9;
  if (v9)
    *(_QWORD *)(_dispatch_io_fds[v35] + 120) = v34 + 112;
  _dispatch_io_fds[v35] = v34;
  *(_QWORD *)(v34 + 120) = &_dispatch_io_fds[v35];
  *(_QWORD *)(v34 + 72) = dispatch_queue_create("com.apple.libdispatch-io.barrierq", 0);
  *(_QWORD *)(v34 + 80) = dispatch_group_create();
  v10 = *(dispatch_queue_s **)(v34 + 72);
  block = _NSConcreteStackBlock;
  v28 = 0x40000000;
  v29 = 0;
  v30 = ___dispatch_fd_entry_create_with_fd_block_invoke;
  v31 = &__block_descriptor_tmp_129;
  v32 = v34;
  v33 = v36;
  dispatch_channel_async(v10, &block);
  v11 = *(dispatch_queue_s **)(v34 + 64);
  v21 = _NSConcreteStackBlock;
  v22 = 0x40000000;
  v23 = 0;
  v24 = ___dispatch_fd_entry_create_with_fd_block_invoke_3;
  v25 = &__block_descriptor_tmp_132;
  v26 = v34;
  dispatch_channel_async(v11, &v21);
  v12 = *(dispatch_queue_s **)(v34 + 64);
  v14 = _NSConcreteStackBlock;
  v15 = 0x40000000;
  v16 = 0;
  v17 = ___dispatch_fd_entry_create_with_fd_block_invoke_5;
  v18 = &__block_descriptor_tmp_136;
  v19 = v34;
  v20 = v36;
  dispatch_channel_async(v12, &v14);
  return v34;
}

void ___dispatch_fd_entry_init_async_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: init completion", v1, v2, v3, v4, v5, v6, v7, 1402);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _dispatch_fd_entry_release(*(_QWORD *)(a1 + 40));
}

uint64_t _dispatch_fd_entry_create(dispatch_queue_s *a1)
{
  uint64_t v2;

  v2 = _dispatch_calloc(1, 128);
  *(_QWORD *)(v2 + 64) = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.closeq", 0, a1);
  _dispatch_fd_entry_retain(v2);
  return v2;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  void **block;
  int v46;
  int v47;
  void (*v48)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v49;
  uint64_t v50;
  int v51;
  dispatch_object_t object;
  int st_dev_high;
  int v54;
  int v55;
  int v56;
  int v57;
  int v58;
  int v59;
  int v60;
  int v61;
  stat __b;
  int v63;
  int v64;
  int v65;
  uint64_t v66;
  uint64_t v67;
  uint64_t v68;
  uint64_t v69;
  uint64_t v70;
  uint64_t v71;
  uint64_t v72;
  uint64_t v73;
  uint64_t v74;
  uint64_t v75;
  uint64_t v76;
  uint64_t v77;
  dispatch_queue_t (*v78)();
  void *v79;
  dispatch_once_t *v80;
  uint64_t v81;
  uint64_t v82;
  uint64_t v83;
  uint64_t v84;
  uint64_t v85;
  uint64_t v86;
  uint64_t v87;
  uint64_t v88;
  uint64_t v89;
  uint64_t v90;
  uint64_t v91;
  uint64_t v92;
  unint64_t StatusReg;
  unint64_t v94;
  unint64_t v95;
  unint64_t v96;
  unint64_t v97;
  unint64_t v98;

  v67 = a1;
  v66 = a1;
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: stat", v1, v2, v3, v4, v5, v6, v7, 1459);
  v65 = 0;
  v64 = 0;
  v63 = -1;
  memset(&__b, 0, sizeof(__b));
  while (1)
  {
    if (fstat(*(_DWORD *)(a1 + 40), &__b) == -1)
    {
      v81 = 1;
      v92 = 1;
      StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v43 = **(_DWORD **)(StatusReg + 8);
    }
    else
    {
      v43 = 0;
    }
    v65 = v43;
    if (!v43)
      break;
    if (v43 != 4)
    {
      *(_DWORD *)(*(_QWORD *)(a1 + 32) + 24) = v65;
      return;
    }
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 32) = __b.st_dev;
  *(_WORD *)(*(_QWORD *)(a1 + 32) + 36) = __b.st_mode;
  _dispatch_object_finalize();
  while (1)
  {
    v64 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 3);
    if (v64 == -1)
    {
      v82 = 1;
      v91 = 1;
      v94 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
      v42 = **(_DWORD **)(v94 + 8);
    }
    else
    {
      v42 = 0;
    }
    v65 = v42;
    if (!v42)
      break;
    if (v42 != 4)
    {
      v61 = v65;
      v77 = v65;
      v76 = 1471;
      if (v65)
        _dispatch_bug(v76, v77, v8, v9, v10, v11, v12, v13);
      v60 = v61;
      break;
    }
  }
  if ((__b.st_mode & 0xF000) == 0x1000)
  {
    while (1)
    {
      v63 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 74);
      if (v63 == -1)
      {
        v83 = 1;
        v90 = 1;
        v95 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
        v41 = **(_DWORD **)(v95 + 8);
      }
      else
      {
        v41 = 0;
      }
      v65 = v41;
      if (!v41)
        break;
      if (v41 != 4)
      {
        v59 = v65;
        v75 = v65;
        v74 = 1477;
        if (v65)
          _dispatch_bug(v74, v75, v14, v15, v16, v17, v18, v19);
        v58 = v59;
        break;
      }
    }
    if (v63 != -1)
    {
      while (1)
      {
        v63 = fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 73);
        if (v63 == -1)
        {
          v84 = 1;
          v89 = 1;
          v96 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          v40 = **(_DWORD **)(v96 + 8);
        }
        else
        {
          v40 = 0;
        }
        v65 = v40;
        if (!v40)
          break;
        if (v40 != 4)
        {
          v63 = -1;
          v57 = v65;
          v73 = v65;
          v72 = 1484;
          if (v65)
            _dispatch_bug(v72, v73, v20, v21, v22, v23, v24, v25);
          v56 = v57;
          break;
        }
      }
    }
  }
  if ((__b.st_mode & 0xF000) == 0x8000)
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 4) == -1)
        {
          v85 = 1;
          v88 = 1;
          v97 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          v39 = **(_DWORD **)(v97 + 8);
        }
        else
        {
          v39 = 0;
        }
        v65 = v39;
        if (!v39)
          break;
        if (v39 != 4)
        {
          v64 = -1;
          v55 = v65;
          v71 = v65;
          v70 = 1496;
          if (v65)
            _dispatch_bug(v70, v71, v26, v27, v28, v29, v30, v31);
          v54 = v55;
          break;
        }
      }
    }
    st_dev_high = HIBYTE(__b.st_dev);
    object = *(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 72);
    dispatch_suspend(object);
    v80 = &_dispatch_io_init_pred;
    v79 = 0;
    v78 = _dispatch_io_queues_init;
    if (_dispatch_io_init_pred != -1)
      dispatch_once_f(v80, v79, (dispatch_function_t)v78);
    block = _NSConcreteStackBlock;
    v46 = 0x40000000;
    v47 = 0;
    v48 = ___dispatch_fd_entry_create_with_fd_block_invoke_2;
    v49 = &__block_descriptor_tmp_128;
    v50 = *(_QWORD *)(a1 + 32);
    v51 = st_dev_high;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }
  else
  {
    if (v64 != -1)
    {
      while (1)
      {
        if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 4) == -1)
        {
          v86 = 1;
          v87 = 1;
          v98 = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
          v38 = **(_DWORD **)(v98 + 8);
        }
        else
        {
          v38 = 0;
        }
        v65 = v38;
        if (!v38)
          break;
        if (v38 != 4)
        {
          v64 = -1;
          v69 = v65;
          v68 = 1516;
          if (v65)
            _dispatch_bug(v68, v69, v32, v33, v34, v35, v36, v37);
          break;
        }
      }
    }
    _dispatch_stream_init(*(_QWORD *)(a1 + 32), (dispatch_queue_s *)&off_E4640);
  }
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 16) = v64;
  *(_DWORD *)(*(_QWORD *)(a1 + 32) + 20) = v63;
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_2(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_disk_init(*(_QWORD **)(a1 + 32), *(_DWORD *)(a1 + 40), a3, a4, a5, a6, a7, a8);
  dispatch_resume(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 72));
}

uint64_t _dispatch_disk_init(_QWORD *a1, int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t result;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  _QWORD *i;
  char v15[45];

  v11 = a2 & 0x3F;
  for (i = (_QWORD *)_dispatch_io_devs[v11]; i; i = (_QWORD *)i[14])
  {
    if (*((_DWORD *)i + 26) == a2)
    {
      result = _dispatch_retain((uint64_t)i);
      goto LABEL_9;
    }
  }
  v10 = qword_E4D38;
  i = _dispatch_object_alloc((uint64_t)_OS_dispatch_disk_vtable, 8 * qword_E4D38 + 136, a3, a4, a5, a6, a7, a8);
  i[2] = -1985229329;
  *((_DWORD *)i + 3) = 0;
  i[16] = v10;
  i[3] = &off_E4640;
  *((_DWORD *)i + 26) = a2;
  i[6] = 0;
  i[7] = i + 6;
  i[8] = i[6];
  __snprintf_chk(v15, 0x2DuLL, 0, 0x2DuLL, "com.apple.libdispatch-io.deviceq.%d", a2);
  result = (uint64_t)dispatch_queue_create(v15, 0);
  i[9] = result;
  v9 = _dispatch_io_devs[v11];
  i[14] = v9;
  if (v9)
    *(_QWORD *)(_dispatch_io_devs[v11] + 120) = i + 14;
  _dispatch_io_devs[v11] = i;
  i[15] = &_dispatch_io_devs[v11];
LABEL_9:
  a1[7] = i;
  a1[12] = 0;
  a1[13] = a1 + 12;
  return result;
}

void _dispatch_stream_init(uint64_t a1, dispatch_queue_s *a2)
{
  dispatch_object_t *context;
  unsigned int i;

  for (i = 0; i < 2; ++i)
  {
    context = (dispatch_object_t *)_dispatch_calloc(1, 64);
    *context = dispatch_queue_create_with_target_V2("com.apple.libdispatch-io.streamq", 0, a2);
    dispatch_set_context(*context, context);
    context[6] = 0;
    context[7] = (dispatch_object_t)(context + 6);
    context[4] = 0;
    context[5] = (dispatch_object_t)(context + 4);
    *(_QWORD *)(a1 + 40 + 8 * i) = context;
  }
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_3(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  void **block;
  int v16;
  int v17;
  void (*v18)(uint64_t);
  void *v19;
  uint64_t v20;
  uint64_t v21;
  unsigned int i;
  uint64_t v23;
  uint64_t v24;

  v24 = a1;
  v23 = a1;
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56))
  {
    v21 = 0;
    v21 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 56);
    block = _NSConcreteStackBlock;
    v16 = 0x40000000;
    v17 = 0;
    v18 = ___dispatch_fd_entry_create_with_fd_block_invoke_4;
    v19 = &__block_descriptor_tmp_131;
    v20 = v21;
    dispatch_channel_async((dispatch_queue_t)_dispatch_io_devs_lockq, &block);
  }
  else
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\tfd_entry[%p]: close queue cleanup", v1, v2, v3, v4, v5, v6, v7, 1533);
    for (i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(_QWORD *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112))
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) + 120) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120);
  **(_QWORD **)(*(_QWORD *)(a1 + 32) + 120) = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112);
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 112) = -1;
  *(_QWORD *)(*(_QWORD *)(a1 + 32) + 120) = -1;
}

void _dispatch_stream_dispose(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  void *v8;

  v8 = *(void **)(a1 + 40 + 8 * a2);
  if (v8)
  {
    if (*((_QWORD *)v8 + 4))
      _dispatch_abort(1739, *((_QWORD *)v8 + 4) == 0, a3, a4, a5, a6, a7, a8);
    if (*((_QWORD *)v8 + 6))
      _dispatch_abort(1740, *((_QWORD *)v8 + 6) == 0, a3, a4, a5, a6, a7, a8);
    if (*((_QWORD *)v8 + 1))
    {
      _dispatch_fd_entry_retain(a1);
      dispatch_source_cancel(*((dispatch_source_t *)v8 + 1));
      dispatch_resume(*((dispatch_object_t *)v8 + 1));
      dispatch_release(*((dispatch_object_t *)v8 + 1));
    }
    dispatch_set_context(*(dispatch_object_t *)v8, 0);
    dispatch_release(*(dispatch_object_t *)v8);
    free(v8);
  }
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_4(uint64_t a1)
{
  _dispatch_release(*(unsigned int **)(a1 + 32));
}

void ___dispatch_fd_entry_create_with_fd_block_invoke_5(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  int v23;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue release", v1, v2, v3, v4, v5, v6, v7, 1551);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 64));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: barrier queue release", v8, v9, v10, v11, v12, v13, v14, 1553);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 72));
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: barrier group release", v15, v16, v17, v18, v19, v20, v21, 1555);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 80));
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 16) != -1)
  {
    do
    {
      if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 4) == -1)
        v23 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      else
        v23 = 0;
    }
    while (v23 == 4);
  }
  if (*(_DWORD *)(*(_QWORD *)(a1 + 32) + 20) != -1)
  {
    do
    {
      if (fcntl_NOCANCEL(*(unsigned int *)(a1 + 40), 73) == -1)
        v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      else
        v22 = 0;
    }
    while (v22 == 4);
  }
  _dispatch_object_finalize();
  if (*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88))
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 88) + 112) = 0;
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 88));
  }
  free(*(void **)(a1 + 32));
}

void ___dispatch_fd_entry_create_with_path_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  unsigned int i;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue cleanup", v1, v2, v3, v4, v5, v6, v7, 1611);
  if (!*(_QWORD *)(*(_QWORD *)(a1 + 32) + 56))
  {
    for (i = 0; i < 2; ++i)
      _dispatch_stream_dispose(*(_QWORD *)(a1 + 32), i, v8, v9, v10, v11, v12, v13);
  }
  if (**(_DWORD **)(a1 + 32) != -1)
    _dispatch_fd_entry_guarded_close(*(_QWORD *)(a1 + 32), **(_DWORD **)(a1 + 32));
  if (**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8))
    *(_QWORD *)(**(_QWORD **)(*(_QWORD *)(a1 + 32) + 8) + 112) = 0;
}

uint64_t _dispatch_fd_entry_guarded_close(uint64_t a1, unsigned int a2)
{
  uint64_t v3;
  unsigned int v4;
  uint64_t v5;

  v5 = a1;
  v4 = a2;
  if (*(_DWORD *)(a1 + 28))
  {
    v3 = v5;
    return guarded_close_np(v4, &v3);
  }
  else
  {
    return close_NOCANCEL(v4);
  }
}

void ___dispatch_fd_entry_create_with_path_block_invoke_2(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;

  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\tfd_entry[%p]: close queue release", v1, v2, v3, v4, v5, v6, v7, 1630);
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 64));
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 72));
  dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1 + 32) + 80));
  free(*(void **)(*(_QWORD *)(a1 + 32) + 8));
  free(*(void **)(a1 + 32));
}

uint64_t _dispatch_fd_entry_guarded_open(uint64_t a1, uint64_t a2, unsigned int a3, __int16 a4)
{
  unsigned int v5;
  uint64_t v6;
  __int16 v7;
  unsigned int v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v12;
  uint64_t v13;
  unint64_t StatusReg;

  v10 = a1;
  v9 = a2;
  v8 = a3;
  v7 = a4;
  v6 = a1;
  v5 = guarded_open_np(a2, &v6);
  if (v5 == -1)
  {
    v12 = 1;
    v13 = 1;
    StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
    **(_DWORD **)(StatusReg + 8) = 0;
    return open_NOCANCEL(v9, v8);
  }
  else
  {
    *(_DWORD *)(v10 + 28) = 15;
    return v5;
  }
}

void ___dispatch_operation_deliver_data_block_invoke(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;

  if ((*(_DWORD *)(a1 + 72) & 2) != 0
    && !*(_DWORD *)(a1 + 76)
    && *(_DWORD *)(a1 + 80)
    && dispatch_data_get_size(*(dispatch_data_t *)(a1 + 40)))
  {
    _dispatch_thread_getspecific(0);
    _dispatch_log("%u\t%p\top[%p]: IO handler invoke", v1, v2, v3, v4, v5, v6, v7, 2701);
    (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  }
  _dispatch_thread_getspecific(0);
  _dispatch_log("%u\t%p\top[%p]: IO handler invoke: err %d", v8, v9, v10, v11, v12, v13, v14, 2709);
  (*(void (**)(void))(*(_QWORD *)(a1 + 32) + 16))();
  _dispatch_release(*(unsigned int **)(a1 + 56));
  _dispatch_fd_entry_release(*(_QWORD *)(a1 + 64));
  dispatch_release(*(dispatch_object_t *)(a1 + 40));
}

void _dispatch_data_destroy_buffer(void *a1, mach_vm_size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  dispatch_queue_s *queue;

  queue = a3;
  if (a4 == &__block_literal_global)
  {
    free(a1);
  }
  else if (a4 != &__block_literal_global_50)
  {
    if (a4 == &__block_literal_global_53)
    {
      mach_vm_deallocate(mach_task_self_, (mach_vm_address_t)a1, a2);
    }
    else
    {
      if (!a3)
        queue = (dispatch_queue_s *)&off_E4640;
      dispatch_channel_async_f(queue, a4, (dispatch_function_t)_dispatch_call_block_and_release);
    }
  }
}

dispatch_data_t dispatch_data_create(const void *buffer, size_t size, dispatch_queue_t queue, dispatch_block_t destructor)
{
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  Block_layout *v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v16;
  dispatch_data_s *v17;
  Block_layout *v19;
  void *v22;
  _BYTE v24[9];
  dispatch_data_s *v25;
  dispatch_data_s *v26;
  _BYTE v27[9];
  dispatch_data_s *v28;
  dispatch_data_s *v29;
  _BYTE v30[9];
  dispatch_data_s *v31;
  dispatch_data_s *v32;

  v22 = (void *)buffer;
  if (buffer && size)
  {
    if (destructor)
    {
      if (destructor == &__block_literal_global_56)
      {
        if (size < 0xFFFFFFFFFFFFFFB0)
        {
          v27[8] = 0;
          if (is_mul_ok(0, 0x18uLL))
          {
            *(_QWORD *)v27 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
            v28 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, size + 80 + *(_QWORD *)&v27[1], (uint64_t)queue, (uint64_t)destructor, v4, v5, v6, v7);
            *((_QWORD *)v28 + 9) = 0;
            *((_QWORD *)v28 + 3) = &off_E4640;
            *((_QWORD *)v28 + 2) = -1985229329;
            v29 = v28;
          }
          else
          {
            v29 = 0;
          }
        }
        else
        {
          v29 = 0;
        }
        v17 = v29;
        v22 = (void *)__memcpy_chk((char *)v29 + 80, v22, size, -1);
        v19 = &__block_literal_global_50;
      }
      else
      {
        v24[8] = 0;
        if (is_mul_ok(0, 0x18uLL))
        {
          *(_QWORD *)v24 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
          v25 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, *(_QWORD *)&v24[1] + 80, (uint64_t)queue, (uint64_t)destructor, v4, v5, v6, v7);
          *((_QWORD *)v25 + 9) = 0;
          *((_QWORD *)v25 + 3) = &off_E4640;
          *((_QWORD *)v25 + 2) = -1985229329;
          v26 = v25;
        }
        else
        {
          v26 = 0;
        }
        v17 = v26;
        v19 = (Block_layout *)_dispatch_Block_copy(destructor);
      }
    }
    else
    {
      v16 = malloc_type_malloc(size, 4058601073);
      if (!v16)
        return 0;
      v22 = (void *)__memcpy_chk(v16, v22, size, -1);
      v30[8] = 0;
      if (is_mul_ok(0, 0x18uLL))
      {
        *(_QWORD *)v30 = (0 * (unsigned __int128)0x18uLL) >> 64 != 0;
        v31 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, *(_QWORD *)&v30[1] + 80, v9, v10, v11, v12, v13, v14);
        *((_QWORD *)v31 + 9) = 0;
        *((_QWORD *)v31 + 3) = &off_E4640;
        *((_QWORD *)v31 + 2) = -1985229329;
        v32 = v31;
      }
      else
      {
        v32 = 0;
      }
      v17 = v32;
      v19 = &__block_literal_global;
    }
    *((_QWORD *)v17 + 6) = v22;
    *((_QWORD *)v17 + 8) = size;
    *((_QWORD *)v17 + 7) = v19;
    if (queue)
    {
      _dispatch_retain((uint64_t)queue);
      *((_QWORD *)v17 + 3) = queue;
    }
    return v17;
  }
  else
  {
    if (destructor)
    {
      v8 = (Block_layout *)_dispatch_Block_copy(destructor);
      _dispatch_data_destroy_buffer(v22, size, queue, v8);
    }
    return &_dispatch_data_empty;
  }
}

dispatch_data_t dispatch_data_create_f(const void *a1, size_t a2, dispatch_queue_s *a3, Block_layout *a4)
{
  void **v5;
  int v6;
  int v7;
  uint64_t (*v8)(uint64_t);
  void *v9;
  Block_layout *v10;
  const void *v11;
  Block_layout *v12;
  Block_layout *v13;
  dispatch_queue_t v14;
  size_t v15;
  const void *v16;

  v16 = a1;
  v15 = a2;
  v14 = a3;
  v13 = a4;
  v12 = a4;
  if (a4
    && v12 != &__block_literal_global
    && v12 != &__block_literal_global_50
    && v12 != &__block_literal_global_53
    && v12 != &__block_literal_global_56)
  {
    v5 = _NSConcreteStackBlock;
    v6 = 0x40000000;
    v7 = 0;
    v8 = __dispatch_data_create_f_block_invoke;
    v9 = &__block_descriptor_tmp_2;
    v10 = v13;
    v11 = v16;
    v12 = (Block_layout *)&v5;
  }
  return dispatch_data_create(v16, v15, v14, v12);
}

uint64_t __dispatch_data_create_f_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(_QWORD))(a1 + 32))(*(_QWORD *)(a1 + 40));
}

dispatch_data_s *dispatch_data_create_alloc(unint64_t a1, _QWORD *a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _QWORD *v9;
  dispatch_data_s *v10;
  dispatch_data_s *v13;
  dispatch_data_s *v14;

  v10 = &_dispatch_data_empty;
  v9 = 0;
  if (a1)
  {
    if (a1 < 0xFFFFFFFFFFFFFFB0)
    {
      if (is_mul_ok(0, 0x18uLL))
      {
        v13 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, a1 + 80, a3, a4, a5, a6, a7, a8);
        *((_QWORD *)v13 + 9) = 0;
        *((_QWORD *)v13 + 3) = &off_E4640;
        *((_QWORD *)v13 + 2) = -1985229329;
        v14 = v13;
      }
      else
      {
        v14 = 0;
      }
    }
    else
    {
      v14 = 0;
    }
    v10 = v14;
    v9 = (_QWORD *)((char *)v14 + 80);
    *((_QWORD *)v14 + 6) = (char *)v14 + 80;
    *((_QWORD *)v14 + 8) = a1;
    *((_QWORD *)v14 + 7) = &__block_literal_global_50;
  }
  if (a2)
    *a2 = v9;
  return v10;
}

void _dispatch_data_dispose(uint64_t a1)
{
  unint64_t v1;
  unint64_t i;

  if (*(_QWORD *)(a1 + 72))
  {
    for (i = 0; ; ++i)
    {
      v1 = *(_QWORD *)(a1 + 72) ? *(_QWORD *)(a1 + 72) : 1;
      if (i >= v1)
        break;
      dispatch_release(*(dispatch_object_t *)(a1 + 80 + 24 * i));
    }
    free(*(void **)(a1 + 48));
  }
  else
  {
    _dispatch_data_destroy_buffer(*(void **)(a1 + 48), *(_QWORD *)(a1 + 64), *(dispatch_queue_s **)(a1 + 24), *(Block_layout **)(a1 + 56));
  }
}

size_t dispatch_data_get_size(dispatch_data_t data)
{
  return *((_QWORD *)data + 8);
}

dispatch_data_t dispatch_data_create_concat(dispatch_data_t data1, dispatch_data_t data2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  BOOL v8;
  unint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  unint64_t i;
  uint64_t v19;
  dispatch_data_s *v23;
  dispatch_data_s *v24;

  if (*((_QWORD *)data1 + 8))
  {
    if (*((_QWORD *)data2 + 8))
    {
      if (*((_QWORD *)data1 + 9))
        v17 = *((_QWORD *)data1 + 9);
      else
        v17 = 1;
      if (*((_QWORD *)data2 + 9))
        v16 = *((_QWORD *)data2 + 9);
      else
        v16 = 1;
      v8 = __CFADD__(v17, v16);
      v19 = v17 + v16;
      if (v8)
      {
        return 0;
      }
      else
      {
        if (((unint64_t)v19 * (unsigned __int128)0x18uLL) >> 64 != 0
          || (unint64_t)(24 * v19) >= 0xFFFFFFFFFFFFFFB0)
        {
          v24 = 0;
        }
        else
        {
          v23 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 24 * v19 + 80, v2, v3, v4, v5, v6, v7);
          *((_QWORD *)v23 + 9) = v19;
          *((_QWORD *)v23 + 3) = &off_E4640;
          *((_QWORD *)v23 + 2) = -1985229329;
          v24 = v23;
        }
        *((_QWORD *)v24 + 8) = *((_QWORD *)data1 + 8) + *((_QWORD *)data2 + 8);
        if (*((_QWORD *)data1 + 9))
        {
          __memcpy_chk((char *)v24 + 80, (char *)data1 + 80, 24 * *((_QWORD *)data1 + 9), -1);
        }
        else
        {
          *((_QWORD *)v24 + 11) = 0;
          *((_QWORD *)v24 + 12) = *((_QWORD *)data1 + 8);
          *((_QWORD *)v24 + 10) = data1;
        }
        if (*((_QWORD *)data2 + 9))
        {
          if (*((_QWORD *)data1 + 9))
            v12 = *((_QWORD *)data1 + 9);
          else
            v12 = 1;
          if (*((_QWORD *)data2 + 9))
            v11 = *((_QWORD *)data2 + 9);
          else
            v11 = 1;
          __memcpy_chk((char *)v24 + 24 * v12 + 80, (char *)data2 + 80, 24 * v11, -1);
        }
        else
        {
          if (*((_QWORD *)data1 + 9))
            v15 = *((_QWORD *)data1 + 9);
          else
            v15 = 1;
          *((_QWORD *)v24 + 3 * v15 + 11) = 0;
          if (*((_QWORD *)data1 + 9))
            v14 = *((_QWORD *)data1 + 9);
          else
            v14 = 1;
          *((_QWORD *)v24 + 3 * v14 + 12) = *((_QWORD *)data2 + 8);
          if (*((_QWORD *)data1 + 9))
            v13 = *((_QWORD *)data1 + 9);
          else
            v13 = 1;
          *((_QWORD *)v24 + 3 * v13 + 10) = data2;
        }
        for (i = 0; ; ++i)
        {
          v10 = *((_QWORD *)v24 + 9) ? *((_QWORD *)v24 + 9) : 1;
          if (i >= v10)
            break;
          dispatch_retain(*((dispatch_object_t *)v24 + 3 * i + 10));
        }
        return v24;
      }
    }
    else
    {
      dispatch_retain(data1);
      return data1;
    }
  }
  else
  {
    dispatch_retain(data2);
    return data2;
  }
}

dispatch_data_t dispatch_data_create_subrange(dispatch_data_t data, size_t offset, size_t length)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  char *v8;
  uint64_t v9;
  BOOL v11;
  unint64_t v12;
  size_t v13;
  size_t v14;
  unint64_t v15;
  unint64_t i;
  unint64_t j;
  BOOL v18;
  size_t lengtha;
  size_t v20;
  dispatch_data_s *v23;
  dispatch_data_s *v24;
  dispatch_data_s *v25;
  dispatch_data_s *v26;

  v20 = offset;
  lengtha = length;
  if (offset >= *((_QWORD *)data + 8) || !length)
    return &_dispatch_data_empty;
  if (length <= *((_QWORD *)data + 8) - offset)
  {
    if (length == *((_QWORD *)data + 8))
    {
      dispatch_retain(data);
      return data;
    }
  }
  else
  {
    lengtha = *((_QWORD *)data + 8) - offset;
  }
  if (*((_QWORD *)data + 9))
  {
    v12 = *((_QWORD *)data + 9);
    v18 = offset + lengtha == *((_QWORD *)data + 8);
    for (i = 0; ; ++i)
    {
      v11 = 0;
      if (i < v12)
        v11 = v20 >= *((_QWORD *)data + 3 * i + 12);
      if (!v11)
        break;
      v8 = (char *)data + 24 * i;
      v20 -= *((_QWORD *)v8 + 12);
    }
    if (i >= v12)
    {
      qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
      qword_E4DA8 = i;
      __break(1u);
      JUMPOUT(0xB2394);
    }
    if (v20 + lengtha > *((_QWORD *)data + 3 * i + 12))
    {
      v14 = 0;
      if (offset + lengtha == *((_QWORD *)data + 8))
      {
        v15 = v12 - i;
      }
      else
      {
        v14 = lengtha + v20 - *((_QWORD *)data + 3 * i + 12);
        v15 = 1;
        while (i + v15 < v12)
        {
          v9 = 24 * (i + v15++);
          v13 = *(_QWORD *)((char *)data + v9 + 96);
          if (v14 <= v13)
            break;
          v14 -= v13;
          if (i + v15 >= v12)
          {
            qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_create_subrange out of bounds";
            qword_E4DA8 = i + v15;
            __break(1u);
            JUMPOUT(0xB2540);
          }
        }
      }
      if (!is_mul_ok(v15, 0x18uLL) || 24 * v15 >= 0xFFFFFFFFFFFFFFB0)
      {
        v24 = 0;
      }
      else
      {
        v23 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 24 * v15 + 80, length, v3, v4, v5, v6, v7);
        *((_QWORD *)v23 + 9) = v15;
        *((_QWORD *)v23 + 3) = &off_E4640;
        *((_QWORD *)v23 + 2) = -1985229329;
        v24 = v23;
      }
      *((_QWORD *)v24 + 8) = lengtha;
      __memcpy_chk((char *)v24 + 80, (char *)data + 24 * i + 80, 24 * v15, -1);
      if (v20)
      {
        *((_QWORD *)v24 + 11) += v20;
        *((_QWORD *)v24 + 12) -= v20;
      }
      if (!v18)
        *((_QWORD *)v24 + 3 * v15 + 9) = v14;
      for (j = 0; j < v15; ++j)
        dispatch_retain(*((dispatch_object_t *)v24 + 3 * j + 10));
      return v24;
    }
    else
    {
      return dispatch_data_create_subrange(*((dispatch_data_t *)data + 3 * i + 10), *((_QWORD *)data + 3 * i + 11) + v20, lengtha);
    }
  }
  else
  {
    if (is_mul_ok(1uLL, 0x18uLL))
    {
      v25 = (dispatch_data_s *)_dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, 0x68uLL, length, v3, v4, v5, v6, v7);
      *((_QWORD *)v25 + 9) = 1;
      *((_QWORD *)v25 + 3) = &off_E4640;
      *((_QWORD *)v25 + 2) = -1985229329;
      v26 = v25;
    }
    else
    {
      v26 = 0;
    }
    *((_QWORD *)v26 + 8) = lengtha;
    *((_QWORD *)v26 + 11) = v20;
    *((_QWORD *)v26 + 12) = lengtha;
    *((_QWORD *)v26 + 10) = data;
    dispatch_retain(data);
    return v26;
  }
}

dispatch_data_t dispatch_data_create_map(dispatch_data_t data, const void **buffer_ptr, size_t *size_ptr)
{
  size_t size;
  void *buffer;
  dispatch_data_s *v6;
  char *v10;
  uint64_t v11;
  dispatch_data_t v12;

  v6 = 0;
  buffer = 0;
  size = *((_QWORD *)data + 8);
  if (size)
  {
    v12 = data;
    v11 = 0;
    if (*((_QWORD *)data + 9) == 1)
    {
      v11 = *((_QWORD *)data + 11);
      v12 = (dispatch_data_t)*((_QWORD *)data + 10);
    }
    if (*((_QWORD *)v12 + 9))
    {
      v10 = (char *)*((_QWORD *)v12 + 6);
      if (v10)
        v10 += v11;
    }
    else
    {
      v10 = (char *)(*((_QWORD *)v12 + 6) + v11);
    }
    buffer = v10;
    if (v10)
    {
      dispatch_retain(data);
      v6 = data;
    }
    else
    {
      buffer = (void *)_dispatch_data_flatten((uint64_t)data);
      if (buffer)
        v6 = dispatch_data_create(buffer, size, 0, &__block_literal_global);
      else
        size = 0;
    }
  }
  else
  {
    v6 = &_dispatch_data_empty;
  }
  if (buffer_ptr)
    *buffer_ptr = buffer;
  if (size_ptr)
    *size_ptr = size;
  return v6;
}

uint64_t _dispatch_data_flatten(uint64_t a1)
{
  void **applier;
  int v3;
  int v4;
  uint64_t (*v5)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v6;
  uint64_t v7;
  uint64_t v8;
  dispatch_data_t v9;

  v9 = (dispatch_data_t)a1;
  v8 = 0;
  v8 = malloc_type_malloc(*(_QWORD *)(a1 + 64), 1286759591);
  if (v8)
  {
    applier = _NSConcreteStackBlock;
    v3 = 0x40000000;
    v4 = 0;
    v5 = ___dispatch_data_flatten_block_invoke;
    v6 = &__block_descriptor_tmp_11_0;
    v7 = v8;
    dispatch_data_apply(v9, &applier);
  }
  return v8;
}

char *dispatch_data_get_flattened_bytes_4libxpc(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t *v8;
  unint64_t v9;
  uint64_t v11;
  unint64_t v12;
  char *v13;
  uint64_t v14;
  char *v15;
  _QWORD *v16;
  char *v18;
  char *v19;
  char *v20;
  char *v21;
  uint64_t *v22;
  uint64_t *v23;
  uint64_t v24;
  _QWORD *v25;
  _QWORD *v26;
  _QWORD *v27;
  _QWORD *v28;
  uint64_t v29;
  uint64_t v30;

  v16 = (_QWORD *)a1;
  v15 = 0;
  v14 = 0;
  if (!*(_QWORD *)(a1 + 64))
    return 0;
  v25 = v16;
  v24 = 0;
  v23 = (uint64_t *)&v16;
  v22 = &v14;
  v21 = 0;
  v30 = v16[8];
  v29 = 131;
  if (!v30)
    _dispatch_abort(v29, 0, a3, a4, a5, a6, a7, a8);
  v27 = v25;
  if (v25[9])
  {
    v28 = v25;
    v11 = v25[9] ? v25[9] : 1;
    if (v11 == 1)
    {
      v24 += v25[11];
      v25 = (_QWORD *)v25[10];
    }
  }
  v26 = v25;
  if (v25[9])
  {
    v20 = 0;
    v19 = (char *)v25[6];
    v20 = v19;
    v18 = v19;
    v21 = v19;
    if (v19)
      v21 += v24;
  }
  else
  {
    v21 = (char *)(v25[6] + v24);
  }
  if (v23)
    *v23 = (uint64_t)v25;
  if (v22)
    *v22 = v24;
  v15 = v21;
  if (v21)
    return v15;
  v13 = (char *)_dispatch_data_flatten((uint64_t)v16);
  if (!v13)
    return 0;
  v12 = 0;
  v8 = v16 + 6;
  do
    v9 = __ldaxr(v8);
  while (!v9 && __stlxr((unint64_t)v13, v8));
  if (v9)
    v12 = v9;
  v15 = (char *)v12;
  if (v9)
    free(v13);
  else
    v15 = v13;
  return &v15[v14];
}

uint64_t dispatch_data_apply_f(_QWORD *a1, uint64_t a2, uint64_t (*a3)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  char v9;

  if (a1[8])
    v9 = _dispatch_data_apply(a1, 0, 0, a1[8], a2, a3, a7, a8) & 1;
  else
    v9 = 1;
  return v9 & 1;
}

uint64_t _dispatch_data_apply(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t), uint64_t a7, uint64_t a8)
{
  char v9;
  unint64_t v10;
  unint64_t i;
  char v12;
  uint64_t v15;
  char v17;
  uint64_t v18;
  uint64_t v19;
  _QWORD *v20;

  v15 = a2;
  v12 = 1;
  v20 = a1;
  v19 = 0;
  if (!a1[8])
    _dispatch_abort(131, 0, a3, a4, a5, (uint64_t)a6, a7, a8);
  if (a1[9] == 1)
  {
    v19 = a1[11];
    v20 = (_QWORD *)a1[10];
  }
  if (v20[9])
  {
    v18 = v20[6];
    if (v18)
      v18 += v19;
  }
  else
  {
    v18 = v20[6] + v19;
  }
  if (v18)
  {
    v17 = _dispatch_data_apply_client_callout(a5, (uint64_t)a1, a2, v18 + a3, a4, a6) & 1;
  }
  else
  {
    for (i = 0; ; ++i)
    {
      v10 = a1[9] ? a1[9] : 1;
      v9 = 0;
      if (i < v10)
        v9 = v12;
      if ((v9 & 1) == 0)
        break;
      v12 = _dispatch_data_apply(a1[3 * i + 10], v15, a1[3 * i + 11], a1[3 * i + 12], a5, a6) & 1;
      v15 += a1[3 * i + 12];
    }
    v17 = v12;
  }
  return v17 & 1;
}

BOOL dispatch_data_apply(dispatch_data_t data, dispatch_data_applier_t applier)
{
  uint64_t (*v2)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  uint64_t v3;
  uint64_t v4;
  uint64_t v6;

  if (!*((_QWORD *)data + 8))
    return 1;
  v6 = *((_QWORD *)data + 8);
  v2 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))_Block_get_invoke_fn((uint64_t)applier);
  return _dispatch_data_apply(data, 0, 0, v6, (uint64_t)applier, v2, v3, v4) & 1;
}

dispatch_data_t dispatch_data_copy_region(dispatch_data_t data, size_t location, size_t *offset_ptr)
{
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;

  if (location < *((_QWORD *)data + 8))
  {
    *offset_ptr = 0;
    return (dispatch_data_t)_dispatch_data_copy_region(data, 0, *((_QWORD *)data + 8), location, offset_ptr, v3, v4, v5);
  }
  else
  {
    *offset_ptr = *((_QWORD *)data + 8);
    return &_dispatch_data_empty;
  }
}

dispatch_object_s *_dispatch_data_copy_region(dispatch_object_s *a1, unint64_t a2, uint64_t a3, unint64_t a4, _QWORD *a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  unint64_t v16;
  uint64_t v17;
  unint64_t v18;
  unint64_t v19;
  unint64_t i;
  _QWORD *v21;
  uint64_t v22;
  dispatch_object_s *v23;
  unint64_t v25;
  dispatch_object_s *v26;
  int v28;
  char v29;
  BOOL v30;
  uint64_t v31;
  uint64_t v32;
  unint64_t v33;
  _QWORD *v34;
  uint64_t v35;
  uint64_t v36;
  _QWORD *v37;
  dispatch_object_s *v38;
  BOOL v39;
  char v40;
  BOOL v41;
  char v42;
  unint64_t v43;
  unint64_t v44;
  unint64_t v45;
  unint64_t v46;
  unint64_t *v47;
  dispatch_object_s **v48;
  unint64_t v49;
  dispatch_object_s *v50;
  dispatch_object_s *v51;
  dispatch_object_s *v52;
  dispatch_object_s *v53;
  uint64_t v54;
  uint64_t v55;

  v26 = a1;
  v25 = a2;
  v23 = 0;
  v22 = 0;
  if (!a2 && a3 == *((_QWORD *)v26 + 8))
    v23 = v26;
  v50 = v26;
  v49 = v25;
  v48 = &v26;
  v47 = &v25;
  v46 = 0;
  v55 = *((_QWORD *)v26 + 8);
  v54 = 131;
  if (!v55)
    _dispatch_abort(v54, 0, a3, a4, (uint64_t)a5, a6, a7, a8);
  v52 = v50;
  if (*((_QWORD *)v50 + 9))
  {
    v53 = v50;
    v17 = *((_QWORD *)v50 + 9) ? *((_QWORD *)v50 + 9) : 1;
    if (v17 == 1)
    {
      v49 += *((_QWORD *)v50 + 11);
      v50 = (dispatch_object_s *)*((_QWORD *)v50 + 10);
    }
  }
  v51 = v50;
  if (*((_QWORD *)v50 + 9))
  {
    v45 = 0;
    v44 = *((_QWORD *)v50 + 6);
    v45 = v44;
    v43 = v44;
    v46 = v44;
    if (v44)
      v46 += v49;
  }
  else
  {
    v46 = *((_QWORD *)v50 + 6) + v49;
  }
  if (v48)
    *v48 = v50;
  if (v47)
    *v47 = v49;
  if (!v46)
  {
    for (i = 0; ; ++i)
    {
      v38 = v26;
      if (*((_QWORD *)v26 + 9))
        v16 = *((_QWORD *)v26 + 9);
      else
        v16 = 1;
      if (i >= v16)
      {
        v14 = *a5 + v22;
        qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: dispatch_data_copy_region out of bounds";
        qword_E4DA8 = v14;
        __break(1u);
        JUMPOUT(0xB39C0);
      }
      v18 = *((_QWORD *)v26 + 3 * i + 12);
      if (v25 < v18)
      {
        v19 = v18 - v25;
        if (a4 < v22 + v19)
        {
          v25 += *((_QWORD *)v26 + 3 * i + 11);
          v26 = (dispatch_object_s *)*((_QWORD *)v26 + 3 * i + 10);
          *a5 += v22;
          return (dispatch_object_s *)_dispatch_data_copy_region(v26, v25, v19, a4 - v22, a5);
        }
        v22 += v19;
        v25 = 0;
      }
      else
      {
        v25 -= v18;
      }
    }
  }
  if (v23)
  {
    dispatch_retain(v23);
    return v23;
  }
  else
  {
    dispatch_retain(v26);
    if (v25 || a3 != *((_QWORD *)v26 + 8))
    {
      v36 = 1;
      v35 = 0;
      v34 = 0;
      v32 = 80;
      v42 = 0;
      v31 = 24;
      v41 = !is_mul_ok(1uLL, 0x18uLL);
      v30 = v41;
      v33 = 104;
      v40 = 0;
      v29 = 0;
      v28 = v41;
      v39 = v41;
      if (v41)
      {
        v37 = 0;
      }
      else
      {
        v34 = _dispatch_object_alloc((uint64_t)_OS_dispatch_data_vtable, v33, v8, v9, v10, v11, v12, v13);
        v34[9] = v36;
        v34[3] = &off_E4640;
        v34[2] = -1985229329;
        v37 = v34;
      }
      v21 = v37;
      v37[8] = a3;
      v21[11] = v25;
      v21[12] = a3;
      v21[10] = v26;
      return (dispatch_object_s *)v21;
    }
    else
    {
      return v26;
    }
  }
}

uint64_t dispatch_data_make_memory_entry(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  uint64_t v23;
  uint64_t v24;
  kern_return_t v26;
  void **applier;
  int v28;
  int v29;
  uint64_t (*v30)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t);
  void *v31;
  mach_vm_address_t v32;
  kern_return_t v33;
  kern_return_t v34;
  BOOL i;
  kern_return_t memory_entry_64;
  vm_prot_t permission;
  mach_vm_address_t address;
  mach_vm_size_t size;
  memory_object_size_t v40;
  mach_port_t object_handle;
  dispatch_data_t v42;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  uint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;

  v42 = (dispatch_data_t)a1;
  object_handle = 0;
  v40 = 0;
  size = 0;
  size = *(_QWORD *)(a1 + 64);
  address = 0;
  permission = 0;
  memory_entry_64 = 0;
  i = 0;
  for (i = *(_QWORD *)(a1 + 56) != (_QWORD)&__block_literal_global_53; ; i = 1)
  {
    if (i)
    {
      address = vm_page_size;
      memory_entry_64 = mach_vm_allocate(mach_task_self_, &address, size, 1);
      if (memory_entry_64)
      {
        if (memory_entry_64 != 3)
        {
          v34 = memory_entry_64;
          v51 = memory_entry_64;
          v50 = 704;
          _dispatch_bug(v50, v51, v1, v2, v3, v4, v5, v6);
          v33 = v34;
        }
        return object_handle;
      }
      applier = _NSConcreteStackBlock;
      v28 = 0x40000000;
      v29 = 0;
      v30 = __dispatch_data_make_memory_entry_block_invoke;
      v31 = &__block_descriptor_tmp_9_0;
      v32 = address;
      dispatch_data_apply(v42, &applier);
    }
    else
    {
      address = *((_QWORD *)v42 + 6);
    }
    permission = 2097219;
    v40 = size;
    memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, 2097219, &object_handle, 0);
    if (memory_entry_64 == 18)
    {
      permission &= ~0x200000u;
      memory_entry_64 = mach_make_memory_entry_64(mach_task_self_, &v40, address, permission, &object_handle, 0);
    }
    v26 = memory_entry_64;
    v49 = memory_entry_64;
    v48 = 726;
    if (memory_entry_64)
      _dispatch_bug(v48, v49, v7, v8, v9, v10, v11, v12);
    if (v26)
    {
      object_handle = 0;
      goto LABEL_23;
    }
    if (v40 >= size)
      goto LABEL_23;
    memory_entry_64 = mach_port_deallocate(mach_task_self_, object_handle);
    v47 = memory_entry_64;
    v46 = 731;
    if (memory_entry_64)
      _dispatch_bug(v46, v47, v13, v14, v15, v16, v17, v18);
    if (i)
      break;
  }
  object_handle = 0;
LABEL_23:
  if (i)
  {
    memory_entry_64 = mach_vm_deallocate(mach_task_self_, address, size);
    v45 = memory_entry_64;
    v44 = 740;
    if (memory_entry_64)
      _dispatch_bug(v44, v45, v19, v20, v21, v22, v23, v24);
  }
  return object_handle;
}

uint64_t __dispatch_data_make_memory_entry_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __memcpy_chk(*(_QWORD *)(a1 + 32) + a3, a4, a5, -1);
  return 1;
}

uint64_t ___dispatch_data_flatten_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  __memcpy_chk(*(_QWORD *)(a1 + 32) + a3, a4, a5, -1);
  return 1;
}

uint64_t _dispatch_data_apply_client_callout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t (*a6)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t))
{
  return a6(a1, a2, a3, a4, a5) & 1;
}

dispatch_data_s *dispatch_data_create_with_transform(dispatch_data_s *a1, _QWORD *a2, uint64_t a3)
{
  uint64_t v4;
  dispatch_object_s *v5;
  _QWORD *v7;

  v7 = a2;
  if (*a2 == 16)
  {
    v7 = _dispatch_transform_detect_utf(a1);
    if (!v7)
      return 0;
  }
  if ((*v7 & ~*(_QWORD *)(a3 + 8)) != 0)
    return 0;
  if ((*(_QWORD *)a3 & ~v7[2]) != 0)
    return 0;
  if (!dispatch_data_get_size(a1))
    return a1;
  if (v7[3])
  {
    v5 = (dispatch_object_s *)((uint64_t (*)(dispatch_data_s *))v7[3])(a1);
  }
  else
  {
    dispatch_retain(a1);
    v5 = a1;
  }
  if (!v5)
    return 0;
  if (*(_QWORD *)(a3 + 32))
  {
    v4 = (*(uint64_t (**)(dispatch_object_s *))(a3 + 32))(v5);
  }
  else
  {
    dispatch_retain(v5);
    v4 = (uint64_t)v5;
  }
  dispatch_release(v5);
  return (dispatch_data_s *)v4;
}

void *_dispatch_transform_detect_utf(dispatch_data_s *a1)
{
  void *v2;
  dispatch_data_t v3;
  const void *v4[2];

  v4[1] = a1;
  v4[0] = 0;
  v3 = _dispatch_data_subrange_map(a1, v4, 0, 2uLL);
  if (!v3)
    return 0;
  v2 = &_dispatch_data_format_type_utf8;
  if (*(unsigned __int16 *)v4[0] == 65279)
  {
    v2 = &_dispatch_data_format_type_utf16le;
  }
  else if (*(unsigned __int16 *)v4[0] == 65534)
  {
    v2 = &_dispatch_data_format_type_utf16be;
  }
  dispatch_release(v3);
  return v2;
}

uint64_t _dispatch_transform_from_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32_decode_table, 91);
}

dispatch_data_t _dispatch_transform_to_base32(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"ABCDEFGHIJKLMNOPQRSTUVWXYZ234567");
}

uint64_t _dispatch_transform_from_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_from_base32_with_table(a1, (uint64_t)&base32hex_decode_table, 33);
}

dispatch_data_t _dispatch_transform_to_base32hex(dispatch_data_s *a1)
{
  return _dispatch_transform_to_base32_with_table(a1, (uint64_t)"0123456789ABCDEFGHIJKLMNOPQRSTUV");
}

uint64_t _dispatch_transform_from_base64(dispatch_data_s *a1)
{
  void **applier;
  int v3;
  int v4;
  uint64_t (*v5)(_QWORD *, uint64_t, uint64_t, uint64_t, unint64_t);
  void *v6;
  _QWORD *v7;
  _QWORD *v8;
  _QWORD *v9;
  uint64_t *v10;
  BOOL v11;
  uint64_t v12;
  uint64_t *v13;
  int v14;
  int v15;
  dispatch_data_s *v16;
  _QWORD v17[2];
  int v18;
  int v19;
  uint64_t v20;
  _QWORD v21[2];
  int v22;
  int v23;
  uint64_t v24;
  _QWORD v25[2];
  int v26;
  int v27;
  uint64_t v28;
  dispatch_data_s *v29;
  uint64_t v30;

  v29 = a1;
  v25[0] = 0;
  v25[1] = v25;
  v26 = 0;
  v27 = 32;
  v28 = 0;
  v21[0] = 0;
  v21[1] = v21;
  v22 = 0;
  v23 = 32;
  v24 = 0;
  v17[0] = 0;
  v17[1] = v17;
  v18 = 0;
  v19 = 32;
  v20 = 0;
  v12 = 0;
  v13 = &v12;
  v14 = 0;
  v15 = 32;
  v16 = &_dispatch_data_empty;
  v11 = 0;
  applier = _NSConcreteStackBlock;
  v3 = 1107296256;
  v4 = 0;
  v5 = ___dispatch_transform_from_base64_block_invoke;
  v6 = &__block_descriptor_tmp_2;
  v7 = v21;
  v8 = v17;
  v9 = v25;
  v10 = &v12;
  v11 = dispatch_data_apply(a1, &applier);
  if (v11)
  {
    v30 = v13[3];
  }
  else
  {
    dispatch_release((dispatch_object_t)v13[3]);
    v30 = 0;
  }
  _Block_object_dispose(&v12, 8);
  _Block_object_dispose(v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  return v30;
}

dispatch_data_t _dispatch_transform_to_base64(dispatch_data_s *a1)
{
  unint64_t v2;
  void **applier;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t);
  void *v7;
  _QWORD *v8;
  _QWORD *v9;
  dispatch_data_t v10;
  size_t v11;
  BOOL v12;
  _QWORD v13[2];
  int v14;
  int v15;
  void *v16;
  void *v17;
  int v18;
  _QWORD v19[2];
  int v20;
  int v21;
  uint64_t v22;
  size_t v23;
  size_t size;
  dispatch_data_t v25;
  dispatch_data_t v26;

  v25 = a1;
  size = dispatch_data_get_size(a1);
  v23 = 0;
  v19[0] = 0;
  v19[1] = v19;
  v20 = 0;
  v21 = 32;
  v22 = 0;
  if (size % 3)
    v2 = size / 3 + 1;
  else
    v2 = size / 3;
  v23 = v2;
  if (v2 <= 0x3FFFFFFFFFFFFFFFLL)
  {
    v23 *= 4;
    v17 = (void *)malloc_type_malloc(v23, 57655578);
    if (v17)
    {
      v13[0] = 0;
      v13[1] = v13;
      v14 = 0;
      v15 = 32;
      v16 = v17;
      v12 = 0;
      applier = _NSConcreteStackBlock;
      v4 = 1107296256;
      v5 = 0;
      v6 = ___dispatch_transform_to_base64_block_invoke;
      v7 = &__block_descriptor_tmp_3;
      v8 = v19;
      v10 = v25;
      v9 = v13;
      v11 = size;
      v12 = dispatch_data_apply(v25, &applier);
      if (v12)
      {
        v26 = dispatch_data_create(v17, v23, 0, &__block_literal_global);
      }
      else
      {
        free(v17);
        v26 = 0;
      }
      v18 = 1;
      _Block_object_dispose(v13, 8);
    }
    else
    {
      v26 = 0;
      v18 = 1;
    }
  }
  else
  {
    v26 = 0;
    v18 = 1;
  }
  _Block_object_dispose(v19, 8);
  return v26;
}

uint64_t _dispatch_transform_from_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 1);
}

uint64_t _dispatch_transform_to_utf16le(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 1);
}

uint64_t _dispatch_transform_from_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_from_utf16(a1, 2);
}

uint64_t _dispatch_transform_to_utf16be(dispatch_data_s *a1)
{
  return _dispatch_transform_to_utf16(a1, 2);
}

dispatch_data_t _dispatch_transform_to_utf8_without_bom(dispatch_data_s *a1)
{
  size_t size;
  dispatch_data_s *data;
  BOOL v4;
  dispatch_data_t v5;
  const void *v6;
  dispatch_data_s *v7;

  v7 = a1;
  v6 = 0;
  v5 = _dispatch_data_subrange_map(a1, &v6, 0, 3uLL);
  v4 = 0;
  if (v5)
  {
    v4 = memcmp(v6, &_dispatch_transform_to_utf8_without_bom_utf8_bom, 3uLL) == 0;
    dispatch_release(v5);
  }
  if (v4)
  {
    data = v7;
    size = dispatch_data_get_size(v7);
    return dispatch_data_create_subrange(data, 3uLL, size - 3);
  }
  else
  {
    dispatch_retain(v7);
    return v7;
  }
}

dispatch_data_t _dispatch_data_subrange_map(dispatch_data_s *a1, const void **a2, size_t a3, size_t a4)
{
  dispatch_data_t map;
  dispatch_data_s *data;

  map = 0;
  data = dispatch_data_create_subrange(a1, a3, a4);
  if (dispatch_data_get_size(data) == a4)
    map = dispatch_data_create_map(data, a2, 0);
  dispatch_release(data);
  return map;
}

uint64_t _dispatch_transform_from_base32_with_table(dispatch_data_s *a1, uint64_t a2, uint64_t a3)
{
  void **applier;
  int v5;
  int v6;
  uint64_t (*v7)(_QWORD *, uint64_t, uint64_t, uint64_t, unint64_t);
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  _QWORD *v11;
  uint64_t *v12;
  uint64_t v13;
  uint64_t v14;
  BOOL v15;
  uint64_t v16;
  uint64_t *v17;
  int v18;
  int v19;
  dispatch_data_s *v20;
  _QWORD v21[2];
  int v22;
  int v23;
  uint64_t v24;
  _QWORD v25[2];
  int v26;
  int v27;
  uint64_t v28;
  _QWORD v29[2];
  int v30;
  int v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  dispatch_data_s *v35;
  uint64_t v36;

  v35 = a1;
  v34 = a2;
  v33 = a3;
  v29[0] = 0;
  v29[1] = v29;
  v30 = 0;
  v31 = 32;
  v32 = 0;
  v25[0] = 0;
  v25[1] = v25;
  v26 = 0;
  v27 = 32;
  v28 = 0;
  v21[0] = 0;
  v21[1] = v21;
  v22 = 0;
  v23 = 32;
  v24 = 0;
  v16 = 0;
  v17 = &v16;
  v18 = 0;
  v19 = 32;
  v20 = &_dispatch_data_empty;
  v15 = 0;
  applier = _NSConcreteStackBlock;
  v5 = 1107296256;
  v6 = 0;
  v7 = ___dispatch_transform_from_base32_with_table_block_invoke;
  v8 = &__block_descriptor_tmp_3;
  v13 = a3;
  v14 = a2;
  v9 = v25;
  v10 = v21;
  v11 = v29;
  v12 = &v16;
  v15 = dispatch_data_apply(a1, &applier);
  if (v15)
  {
    v36 = v17[3];
  }
  else
  {
    dispatch_release((dispatch_object_t)v17[3]);
    v36 = 0;
  }
  _Block_object_dispose(&v16, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v25, 8);
  _Block_object_dispose(v29, 8);
  return v36;
}

uint64_t ___dispatch_transform_from_base32_with_table_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _BYTE *v5;
  unint64_t v7;
  unint64_t v8;
  dispatch_data_t concat;
  dispatch_data_s *data2;
  char v12;
  uint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  unint64_t i;
  char v19;

  if (a5 % 8)
    v8 = a5 / 8 + 1;
  else
    v8 = a5 / 8;
  v15 = (_BYTE *)malloc_type_malloc(5 * v8, 0x100004077774924);
  v14 = v15;
  if (v15)
  {
    for (i = 0; i < a5; ++i)
    {
      if (*(_BYTE *)(a4 + i) != 10 && *(_BYTE *)(a4 + i) != 9 && *(_BYTE *)(a4 + i) != 32)
      {
        v13 = *(unsigned __int8 *)(a4 + i);
        if (v13 >= a1[8] || *(char *)(a1[9] + v13) == -1)
        {
          free(v15);
          v19 = 0;
          return v19 & 1;
        }
        ++*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
        v12 = *(_BYTE *)(a1[9] + v13);
        if (v12 == -2)
        {
          v12 = 0;
          ++*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
        }
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) *= 32;
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) += v12;
        if ((*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) & 7) == 0)
        {
          *v14 = BYTE4(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v14[1] = BYTE3(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v14[2] = BYTE2(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v14[3] = BYTE1(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v5 = v14 + 4;
          v14 += 5;
          *v5 = *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24);
        }
      }
    }
    v7 = *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24) - 1;
    if (v7 <= 5)
      __asm { BR              X8 }
    data2 = dispatch_data_create(v15, v14 - v15, 0, &__block_literal_global);
    concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(_QWORD *)(a1[7] + 8) + 24), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1[7] + 8) + 24));
    *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = concat;
    v19 = 1;
  }
  else
  {
    v19 = 0;
  }
  return v19 & 1;
}

void __copy_helper_block_8_32r40r48r56r(uint64_t a1, const void **a2)
{
  _Block_object_assign((void *)(a1 + 32), a2[4], 8);
  _Block_object_assign((void *)(a1 + 40), a2[5], 8);
  _Block_object_assign((void *)(a1 + 48), a2[6], 8);
  _Block_object_assign((void *)(a1 + 56), a2[7], 8);
}

void __destroy_helper_block_8_32r40r48r56r(const void **a1)
{
  _Block_object_dispose(a1[7], 8);
  _Block_object_dispose(a1[6], 8);
  _Block_object_dispose(a1[5], 8);
  _Block_object_dispose(a1[4], 8);
}

dispatch_data_t _dispatch_transform_to_base32_with_table(dispatch_data_s *a1, uint64_t a2)
{
  unint64_t v3;
  void **applier;
  int v5;
  int v6;
  uint64_t (*v7)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t);
  void *v8;
  _QWORD *v9;
  _QWORD *v10;
  dispatch_data_t v11;
  uint64_t v12;
  size_t v13;
  BOOL v14;
  _QWORD v15[2];
  int v16;
  int v17;
  void *v18;
  void *v19;
  int v20;
  _QWORD v21[2];
  int v22;
  int v23;
  uint64_t v24;
  size_t v25;
  size_t size;
  uint64_t v27;
  dispatch_data_t v28;
  dispatch_data_t v29;

  v28 = a1;
  v27 = a2;
  size = dispatch_data_get_size(a1);
  v25 = 0;
  v21[0] = 0;
  v21[1] = v21;
  v22 = 0;
  v23 = 32;
  v24 = 0;
  if (size % 5)
    v3 = size / 5 + 1;
  else
    v3 = size / 5;
  v25 = v3;
  if (v3 <= 0x1FFFFFFFFFFFFFFFLL)
  {
    v25 *= 8;
    v19 = (void *)malloc_type_malloc(v25, 689401293);
    if (v19)
    {
      v15[0] = 0;
      v15[1] = v15;
      v16 = 0;
      v17 = 32;
      v18 = v19;
      v14 = 0;
      applier = _NSConcreteStackBlock;
      v5 = 1107296256;
      v6 = 0;
      v7 = ___dispatch_transform_to_base32_with_table_block_invoke;
      v8 = &__block_descriptor_tmp_1;
      v9 = v21;
      v11 = v28;
      v10 = v15;
      v12 = v27;
      v13 = size;
      v14 = dispatch_data_apply(v28, &applier);
      if (v14)
      {
        v29 = dispatch_data_create(v19, v25, 0, &__block_literal_global);
      }
      else
      {
        free(v19);
        v29 = 0;
      }
      v20 = 1;
      _Block_object_dispose(v15, 8);
    }
    else
    {
      v29 = 0;
      v20 = 1;
    }
  }
  else
  {
    v29 = 0;
    v20 = 1;
  }
  _Block_object_dispose(v21, 8);
  return v29;
}

uint64_t ___dispatch_transform_to_base32_with_table_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  unint64_t v6;
  unint64_t v7;
  unint64_t v8;
  dispatch_data_t v10;
  char *v11;
  char v12;
  char v13;
  unint64_t v14;
  uint64_t v15;
  uint64_t v16;
  unint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  char v22;

  v21 = a1;
  v20 = a2;
  v19 = a3;
  v18 = a4;
  v17 = a5;
  v16 = a1;
  v15 = a4;
  v14 = 0;
  while (v14 < v17)
  {
    v13 = 0;
    v13 = *(_BYTE *)(v15 + v14);
    v12 = 0;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 5uLL)
    {
      if (v14)
      {
        v12 = *(_BYTE *)(v15 + v14 - 1);
      }
      else
      {
        v11 = 0;
        v10 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v11, v19 - 1, 1uLL);
        if (!v10)
        {
          v22 = 0;
          return v22 & 1;
        }
        v12 = *v11;
        dispatch_release(v10);
      }
    }
    v8 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 5uLL;
    if (v8 <= 4)
      __asm { BR              X8 }
    ++v14;
    ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  if (v19 + v17 == *(_QWORD *)(a1 + 64))
  {
    v7 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 5uLL;
    if (v7 <= 4)
      __asm { BR              X8 }
    v6 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 5uLL;
    if (v6 <= 4)
      __asm { BR              X8 }
  }
  v22 = 1;
  return v22 & 1;
}

uint64_t ___dispatch_transform_from_base64_block_invoke(_QWORD *a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  _BYTE *v5;
  unint64_t v7;
  dispatch_data_t concat;
  dispatch_data_s *data2;
  size_t size;
  char v12;
  unint64_t v13;
  _BYTE *v14;
  _BYTE *v15;
  unint64_t i;
  char v19;

  if (a5 % 4)
    v7 = a5 / 4 + 1;
  else
    v7 = a5 / 4;
  v15 = (_BYTE *)malloc_type_malloc(3 * v7, 0x100004077774924);
  v14 = v15;
  if (v15)
  {
    for (i = 0; i < a5; ++i)
    {
      if (*(_BYTE *)(a4 + i) != 10 && *(_BYTE *)(a4 + i) != 9 && *(_BYTE *)(a4 + i) != 32)
      {
        v13 = *(unsigned __int8 *)(a4 + i);
        if (v13 >= 0x7B || base64_decode_table[v13] == -1)
        {
          free(v15);
          v19 = 0;
          return v19 & 1;
        }
        ++*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24);
        v12 = base64_decode_table[v13];
        if (v12 == -2)
        {
          v12 = 0;
          ++*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
        }
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) <<= 6;
        *(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24) += v12;
        if ((*(_QWORD *)(*(_QWORD *)(a1[4] + 8) + 24) & 3) == 0)
        {
          *v14 = BYTE2(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v14[1] = BYTE1(*(_QWORD *)(*(_QWORD *)(a1[6] + 8) + 24));
          v5 = v14 + 2;
          v14 += 3;
          *v5 = *(_BYTE *)(*(_QWORD *)(a1[6] + 8) + 24);
        }
      }
    }
    size = v14 - v15;
    if (*(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24))
      size -= *(_QWORD *)(*(_QWORD *)(a1[5] + 8) + 24);
    data2 = dispatch_data_create(v15, size, 0, &__block_literal_global);
    concat = dispatch_data_create_concat(*(dispatch_data_t *)(*(_QWORD *)(a1[7] + 8) + 24), data2);
    dispatch_release(data2);
    dispatch_release(*(dispatch_object_t *)(*(_QWORD *)(a1[7] + 8) + 24));
    *(_QWORD *)(*(_QWORD *)(a1[7] + 8) + 24) = concat;
    v19 = 1;
  }
  else
  {
    v19 = 0;
  }
  return v19 & 1;
}

uint64_t ___dispatch_transform_to_base64_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  char v5;
  uint64_t v6;
  char *v7;
  char v8;
  uint64_t v9;
  char *v10;
  char v11;
  uint64_t v12;
  char *v13;
  char v14;
  uint64_t v15;
  char *v16;
  char v17;
  uint64_t v18;
  char *v19;
  uint64_t v20;
  _BYTE *v21;
  uint64_t v22;
  _BYTE *v23;
  char v24;
  uint64_t v25;
  char *v26;
  uint64_t v27;
  _BYTE *v28;
  unint64_t v30;
  unint64_t v31;
  dispatch_data_t v33;
  char *v34;
  char v35;
  unsigned __int8 v36;
  unint64_t v37;
  uint64_t v38;
  uint64_t v39;
  unint64_t v40;
  uint64_t v41;
  uint64_t v42;
  uint64_t v43;
  uint64_t v44;
  char v45;

  v44 = a1;
  v43 = a2;
  v42 = a3;
  v41 = a4;
  v40 = a5;
  v39 = a1;
  v38 = a4;
  v37 = 0;
  while (v37 < v40)
  {
    v36 = 0;
    v36 = *(_BYTE *)(v38 + v37);
    v35 = 0;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 3uLL)
    {
      if (v37)
      {
        v35 = *(_BYTE *)(v38 + v37 - 1);
      }
      else
      {
        v34 = 0;
        v33 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v34, v42 - 1, 1uLL);
        if (!v33)
        {
          v45 = 0;
          return v45 & 1;
        }
        v35 = *v34;
        dispatch_release(v33);
      }
    }
    v31 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 3uLL;
    if (v31)
    {
      if (v31 == 1)
      {
        v8 = base64_encode_table[(((int)v36 >> 4) | (16 * v35)) & 0x3F];
        v9 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v10 = *(char **)(v9 + 24);
        *(_QWORD *)(v9 + 24) = v10 + 1;
        *v10 = v8;
      }
      else if (v31 == 2)
      {
        v11 = base64_encode_table[(((int)v36 >> 6) | (4 * v35)) & 0x3F];
        v12 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v13 = *(char **)(v12 + 24);
        *(_QWORD *)(v12 + 24) = v13 + 1;
        *v13 = v11;
        v14 = base64_encode_table[v36 & 0x3F];
        v15 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v16 = *(char **)(v15 + 24);
        *(_QWORD *)(v15 + 24) = v16 + 1;
        *v16 = v14;
      }
    }
    else
    {
      v5 = base64_encode_table[((int)v36 >> 2) & 0x3F];
      v6 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
      v7 = *(char **)(v6 + 24);
      *(_QWORD *)(v6 + 24) = v7 + 1;
      *v7 = v5;
    }
    ++v37;
    ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24);
  }
  if (v42 + v40 == *(_QWORD *)(a1 + 56))
  {
    v30 = *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24) % 3uLL;
    if (v30)
    {
      if (v30 == 1)
      {
        v17 = base64_encode_table[(16 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x30];
        v18 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v19 = *(char **)(v18 + 24);
        *(_QWORD *)(v18 + 24) = v19 + 1;
        *v19 = v17;
        v20 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v21 = *(_BYTE **)(v20 + 24);
        *(_QWORD *)(v20 + 24) = v21 + 1;
        *v21 = 61;
        v22 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v23 = *(_BYTE **)(v22 + 24);
        *(_QWORD *)(v22 + 24) = v23 + 1;
        *v23 = 61;
      }
      else if (v30 == 2)
      {
        v24 = base64_encode_table[(4 * *(unsigned __int8 *)(v38 + v40 - 1)) & 0x3C];
        v25 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v26 = *(char **)(v25 + 24);
        *(_QWORD *)(v25 + 24) = v26 + 1;
        *v26 = v24;
        v27 = *(_QWORD *)(*(_QWORD *)(a1 + 40) + 8);
        v28 = *(_BYTE **)(v27 + 24);
        *(_QWORD *)(v27 + 24) = v28 + 1;
        *v28 = 61;
      }
    }
  }
  v45 = 1;
  return v45 & 1;
}

uint64_t _dispatch_transform_from_utf16(dispatch_data_s *a1, int a2)
{
  void **applier;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, uint64_t, unint64_t);
  void *v7;
  uint64_t *v8;
  _QWORD *v9;
  dispatch_data_s *v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  __int128 v17;
  __int128 v18;
  _QWORD v19[2];
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  dispatch_data_s *v24;
  uint64_t v25;

  v24 = a1;
  v23 = a2;
  v19[0] = 0;
  v19[1] = v19;
  v20 = 0;
  v21 = 32;
  v22 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0;
  v16 = 56;
  v17 = off_E2150;
  v18 = xmmword_E2160;
  v12 = 0;
  applier = _NSConcreteStackBlock;
  v4 = 1107296256;
  v5 = 0;
  v6 = ___dispatch_transform_from_utf16_block_invoke;
  v7 = &__block_descriptor_tmp_4_0;
  v8 = &v13;
  v9 = v19;
  v10 = a1;
  v11 = a2;
  v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    v25 = v14[3];
  }
  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0, 0);
    dispatch_release((dispatch_object_t)v14[3]);
    v25 = 0;
  }
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_from_utf16_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, unint64_t a5)
{
  char v5;
  uint64_t v6;
  _BYTE *v7;
  char v8;
  uint64_t v9;
  _BYTE *v10;
  char v11;
  uint64_t v12;
  _BYTE *v13;
  char v14;
  uint64_t v15;
  _BYTE *v16;
  uint64_t v17;
  _BYTE *v18;
  char v19;
  uint64_t v20;
  _BYTE *v21;
  char v22;
  uint64_t v23;
  _BYTE *v24;
  uint64_t v25;
  _BYTE *v26;
  uint64_t v27;
  _BYTE *v28;
  char v29;
  uint64_t v30;
  _BYTE *v31;
  unint64_t v33;
  dispatch_data_t v35;
  const void *v36[2];
  dispatch_data_t v37;
  _QWORD *v38;
  uint64_t v39;
  unsigned __int16 v40;
  unsigned int v41;
  unint64_t v42;
  unint64_t i;
  uint64_t v44;
  uint64_t v45;
  uint64_t v46;
  unint64_t v47;
  uint64_t v48;
  uint64_t v49;
  uint64_t v50;
  uint64_t v51;
  char v52;
  BOOL v53;

  v51 = a1;
  v50 = a2;
  v49 = a3;
  v48 = a4;
  v47 = a5;
  v46 = a1;
  v45 = a4;
  if (a3
    || ((v44 = 0, v47 % 3) ? (v33 = v47 / 3 + 1) : (v33 = v47 / 3),
        v44 = 2 * v33,
        (_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 2 * v33, 0) & 1) != 0))
  {
    i = 0;
    v42 = v47 / 2;
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) < v47)
    {
      if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
      {
        v45 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v47 -= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        v42 = v47 / 2;
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
      }
      if (v47 % 2)
        ++v42;
      for (i = 0; i < v42; ++i)
      {
        v41 = 0;
        v40 = 0;
        v39 = 0;
        if (i == v42 - 1 && v42 > v47 / 2)
        {
          v38 = 0;
          v37 = 0;
          v37 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v38, v49 + 2 * i, 2uLL);
          if (!v37)
          {
            v52 = 0;
            return v52 & 1;
          }
          v40 = _dispatch_transform_swap_to_host(*v38, *(_DWORD *)(a1 + 56));
          v36[1] = v37;
          dispatch_release(v37);
          ++*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
        }
        else
        {
          v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
        }
        if (v40 == 65534 && !v49 && !i)
        {
          v52 = 0;
          return v52 & 1;
        }
        if (v40 != 65279 || v49 || i)
        {
          if (v40 < 0xD800u || v40 > 0xDBFFu)
          {
            if (v40 >= 0xDC00u && v40 < 0xE000u)
            {
              v52 = 0;
              return v52 & 1;
            }
            v41 = v40;
          }
          else
          {
            v41 = (v40 - 55296) << 10;
            if (++i < v42)
            {
              v40 = _dispatch_transform_swap_to_host(*(_WORD *)(v45 + 2 * i), *(_DWORD *)(a1 + 56));
            }
            else
            {
              v36[0] = 0;
              v35 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), v36, v49 + 2 * i, 2uLL);
              if (!v35)
              {
                v52 = 0;
                return v52 & 1;
              }
              v40 = _dispatch_transform_swap_to_host(*(_WORD *)v36[0], *(_DWORD *)(a1 + 56));
              dispatch_release(v35);
              *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += 2;
            }
            if (v40 < 0xDC00u || v40 >= 0xE000u)
            {
              v52 = 0;
              return v52 & 1;
            }
            v41 |= v40 & 0x3FF;
            v41 += 0x10000;
          }
          v39 = 2 * (v42 - i);
          v53 = (2 * (unsigned __int128)(v42 - i)) >> 64 != 0;
          if (!is_mul_ok(2uLL, v42 - i))
          {
            v52 = 0;
            return v52 & 1;
          }
          if (v41 >= 0x80)
          {
            if (v41 >= 0x800)
            {
              if (v41 >= 0x10000)
              {
                if (v41 < 0x200000)
                {
                  if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 4uLL, v39) & 1) == 0)
                  {
                    v52 = 0;
                    return v52 & 1;
                  }
                  v22 = (v41 >> 18) | 0xF0;
                  v23 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                  v24 = *(_BYTE **)(v23 + 40);
                  *(_QWORD *)(v23 + 40) = v24 + 1;
                  *v24 = v22;
                  LOBYTE(v24) = (v41 >> 12) & 0x3F | 0x80;
                  v25 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                  v26 = *(_BYTE **)(v25 + 40);
                  *(_QWORD *)(v25 + 40) = v26 + 1;
                  *v26 = (_BYTE)v24;
                  LOBYTE(v24) = (v41 >> 6) & 0x3F | 0x80;
                  v27 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                  v28 = *(_BYTE **)(v27 + 40);
                  *(_QWORD *)(v27 + 40) = v28 + 1;
                  *v28 = (_BYTE)v24;
                  v29 = v41 & 0x3F | 0x80;
                  v30 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                  v31 = *(_BYTE **)(v30 + 40);
                  *(_QWORD *)(v30 + 40) = v31 + 1;
                  *v31 = v29;
                }
              }
              else
              {
                if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 3uLL, v39) & 1) == 0)
                {
                  v52 = 0;
                  return v52 & 1;
                }
                v14 = (v41 >> 12) | 0xE0;
                v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                v16 = *(_BYTE **)(v15 + 40);
                *(_QWORD *)(v15 + 40) = v16 + 1;
                *v16 = v14;
                LOBYTE(v16) = (v41 >> 6) & 0x3F | 0x80;
                v17 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                v18 = *(_BYTE **)(v17 + 40);
                *(_QWORD *)(v17 + 40) = v18 + 1;
                *v18 = (_BYTE)v16;
                v19 = v41 & 0x3F | 0x80;
                v20 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
                v21 = *(_BYTE **)(v20 + 40);
                *(_QWORD *)(v20 + 40) = v21 + 1;
                *v21 = v19;
              }
            }
            else
            {
              if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 2uLL, v39) & 1) == 0)
              {
                v52 = 0;
                return v52 & 1;
              }
              v8 = (v41 >> 6) | 0xC0;
              v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              v10 = *(_BYTE **)(v9 + 40);
              *(_QWORD *)(v9 + 40) = v10 + 1;
              *v10 = v8;
              v11 = v41 & 0x3F | 0x80;
              v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
              v13 = *(_BYTE **)(v12 + 40);
              *(_QWORD *)(v12 + 40) = v13 + 1;
              *v13 = v11;
            }
          }
          else
          {
            if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 1uLL, v39) & 1) == 0)
            {
              v52 = 0;
              return v52 & 1;
            }
            v5 = v41;
            v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
            v7 = *(_BYTE **)(v6 + 40);
            *(_QWORD *)(v6 + 40) = v7 + 1;
            *v7 = v5;
          }
        }
      }
      _dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 0, 0);
      v52 = 1;
    }
    else
    {
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) -= v47;
      v52 = 1;
    }
  }
  else
  {
    v52 = 0;
  }
  return v52 & 1;
}

uint64_t _dispatch_transform_buffer_new(uint64_t a1, unint64_t a2, uint64_t a3)
{
  dispatch_data_t concat;
  dispatch_data_s *data2;
  char v9;

  if (a2 && *(_QWORD *)(a1 + 24) - (*(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8)) >= a2)
    goto LABEL_13;
  if (*(_QWORD *)(a1 + 8))
  {
    if (*(_QWORD *)(a1 + 16) <= *(_QWORD *)(a1 + 8))
    {
      free(*(void **)(a1 + 8));
    }
    else
    {
      data2 = dispatch_data_create(*(const void **)(a1 + 8), *(_QWORD *)(a1 + 16) - *(_QWORD *)(a1 + 8), 0, &__block_literal_global);
      concat = dispatch_data_create_concat(*(dispatch_data_t *)a1, data2);
      dispatch_release(data2);
      dispatch_release(*(dispatch_object_t *)a1);
      *(_QWORD *)a1 = concat;
    }
  }
  *(_QWORD *)(a1 + 24) = a2 + a3;
  *(_QWORD *)(a1 + 8) = 0;
  if (!*(_QWORD *)(a1 + 24))
  {
LABEL_12:
    *(_QWORD *)(a1 + 16) = *(_QWORD *)(a1 + 8);
LABEL_13:
    v9 = 1;
    return v9 & 1;
  }
  if (*(_QWORD *)(a1 + 24) <= 0x6400000uLL)
  {
    *(_QWORD *)(a1 + 8) = malloc_type_malloc(*(_QWORD *)(a1 + 24), 2918043961);
    if (!*(_QWORD *)(a1 + 8))
    {
      v9 = 0;
      return v9 & 1;
    }
    goto LABEL_12;
  }
  v9 = 0;
  return v9 & 1;
}

uint64_t _dispatch_transform_swap_to_host(unsigned __int16 a1, int a2)
{
  if (a2 == 1)
    return a1;
  else
    return (unsigned __int16)_OSSwapInt16(a1);
}

uint64_t _OSSwapInt16(unsigned __int16 a1)
{
  return (unsigned __int16)(((int)a1 >> 8) | (a1 << 8));
}

uint64_t _dispatch_transform_to_utf16(dispatch_data_s *a1, int a2)
{
  void **applier;
  int v4;
  int v5;
  uint64_t (*v6)(uint64_t, uint64_t, uint64_t, char *, unint64_t);
  void *v7;
  uint64_t *v8;
  _QWORD *v9;
  dispatch_data_s *v10;
  int v11;
  BOOL v12;
  uint64_t v13;
  uint64_t *v14;
  int v15;
  int v16;
  __int128 v17;
  __int128 v18;
  _QWORD v19[2];
  int v20;
  int v21;
  uint64_t v22;
  int v23;
  dispatch_data_s *v24;
  uint64_t v25;

  v24 = a1;
  v23 = a2;
  v19[0] = 0;
  v19[1] = v19;
  v20 = 0;
  v21 = 32;
  v22 = 0;
  v13 = 0;
  v14 = &v13;
  v15 = 0;
  v16 = 56;
  v17 = off_E21A0;
  v18 = xmmword_E21B0;
  v12 = 0;
  applier = _NSConcreteStackBlock;
  v4 = 1107296256;
  v5 = 0;
  v6 = ___dispatch_transform_to_utf16_block_invoke;
  v7 = &__block_descriptor_tmp_5;
  v8 = &v13;
  v11 = a2;
  v9 = v19;
  v10 = a1;
  v12 = dispatch_data_apply(a1, &applier);
  if (v12)
  {
    v25 = v14[3];
  }
  else
  {
    _dispatch_transform_buffer_new((uint64_t)(v14 + 3), 0, 0);
    dispatch_release((dispatch_object_t)v14[3]);
    v25 = 0;
  }
  _Block_object_dispose(&v13, 8);
  _Block_object_dispose(v19, 8);
  return v25;
}

uint64_t ___dispatch_transform_to_utf16_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, char *a4, unint64_t a5)
{
  __int16 v5;
  uint64_t v6;
  _WORD *v7;
  __int16 v8;
  uint64_t v9;
  _WORD *v10;
  __int16 v11;
  uint64_t v12;
  _WORD *v13;
  __int16 v14;
  uint64_t v15;
  _WORD *v16;
  dispatch_data_t v19;
  char *v20;
  uint64_t v21;
  unsigned __int8 v22;
  unsigned int utf8_sequence;
  int v24;
  BOOL v25;
  BOOL v26;
  uint64_t v27;
  unint64_t v28;
  unint64_t v29;
  char *v30;
  uint64_t v31;
  unint64_t v32;
  char *v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  char v37;
  BOOL v38;
  BOOL v39;
  BOOL v40;
  BOOL v41;

  v36 = a1;
  v35 = a2;
  v34 = a3;
  v33 = a4;
  v32 = a5;
  v31 = a1;
  v30 = a4;
  v29 = 0;
  v28 = 0;
  if (!a3)
  {
    v27 = 2 * v32;
    v41 = (v32 * (unsigned __int128)2uLL) >> 64 != 0;
    v26 = v41;
    v28 = 2 * v32 + 2;
    v40 = 2 * v32 >= 0xFFFFFFFFFFFFFFFELL;
    v25 = v40;
    v24 = v41 || v40;
    v39 = v24 != 0;
    if (v24)
    {
      v37 = 0;
      return v37 & 1;
    }
    if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, v28, 0) & 1) == 0)
    {
      v37 = 0;
      return v37 & 1;
    }
    v5 = _dispatch_transform_swap_to_host(0xFEFFu, *(_DWORD *)(a1 + 56));
    v6 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
    v7 = *(_WORD **)(v6 + 40);
    *(_QWORD *)(v6 + 40) = v7 + 1;
    *v7 = v5;
  }
  if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) < v32)
  {
    if (*(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24))
    {
      v30 += *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      v32 -= *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24);
      *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) = 0;
    }
    v29 = 0;
    while (v29 < v32)
    {
      utf8_sequence = 0;
      v22 = 0;
      v22 = _dispatch_transform_utf8_length(*v30);
      v21 = 0;
      if (!v22)
      {
        v37 = 0;
        return v37 & 1;
      }
      if (v22 + v29 <= v32)
      {
        utf8_sequence = _dispatch_transform_read_utf8_sequence(v30);
        v30 += v22;
        v29 += v22;
      }
      else
      {
        v20 = 0;
        v19 = _dispatch_data_subrange_map(*(dispatch_data_s **)(a1 + 48), (const void **)&v20, v34 + v29, v22);
        if (!v19)
        {
          v37 = 0;
          return v37 & 1;
        }
        utf8_sequence = _dispatch_transform_read_utf8_sequence(v20);
        *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) += v22 - (v32 - v29);
        v30 += v22;
        v29 = v32;
        dispatch_release(v19);
      }
      v21 = 2 * (v32 - v29);
      v38 = ((v32 - v29) * (unsigned __int128)2uLL) >> 64 != 0;
      if (!is_mul_ok(v32 - v29, 2uLL))
      {
        v37 = 0;
        return v37 & 1;
      }
      if (utf8_sequence != 65279 || v34 + v29 != 3)
      {
        if (utf8_sequence >= 0xD800 && utf8_sequence < 0xDFFF)
        {
          v37 = 0;
          return v37 & 1;
        }
        if (utf8_sequence < 0x10000)
        {
          if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 2uLL, v21) & 1) == 0)
          {
            v37 = 0;
            return v37 & 1;
          }
          v14 = _dispatch_transform_swap_to_host(utf8_sequence, *(_DWORD *)(a1 + 56));
          v15 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v16 = *(_WORD **)(v15 + 40);
          *(_QWORD *)(v15 + 40) = v16 + 1;
          *v16 = v14;
        }
        else
        {
          if ((_dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 4uLL, v21) & 1) == 0)
          {
            v37 = 0;
            return v37 & 1;
          }
          utf8_sequence -= 0x10000;
          v8 = _dispatch_transform_swap_to_host(((utf8_sequence >> 10) & 0x3FF) - 10240, *(_DWORD *)(a1 + 56));
          v9 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v10 = *(_WORD **)(v9 + 40);
          *(_QWORD *)(v9 + 40) = v10 + 1;
          *v10 = v8;
          v11 = _dispatch_transform_swap_to_host((utf8_sequence & 0x3FF) - 9216, *(_DWORD *)(a1 + 56));
          v12 = *(_QWORD *)(*(_QWORD *)(a1 + 32) + 8);
          v13 = *(_WORD **)(v12 + 40);
          *(_QWORD *)(v12 + 40) = v13 + 1;
          *v13 = v11;
        }
      }
    }
    _dispatch_transform_buffer_new(*(_QWORD *)(*(_QWORD *)(a1 + 32) + 8) + 24, 0, 0);
    v37 = 1;
  }
  else
  {
    *(_QWORD *)(*(_QWORD *)(*(_QWORD *)(a1 + 40) + 8) + 24) -= v32;
    v37 = 1;
  }
  return v37 & 1;
}

uint64_t _dispatch_transform_utf8_length(char a1)
{
  if (a1 < 0)
  {
    if ((a1 & 0xE0) == 0xC0)
    {
      return 2;
    }
    else if ((a1 & 0xF0) == 0xE0)
    {
      return 3;
    }
    else if ((a1 & 0xF8) == 0xF0)
    {
      return 4;
    }
    else
    {
      return 0;
    }
  }
  else
  {
    return 1;
  }
}

uint64_t _dispatch_transform_read_utf8_sequence(char *a1)
{
  unint64_t v2;
  _BYTE v3[5];
  _BYTE *v5;

  v3[4] = 0;
  *(_DWORD *)v3 = _dispatch_transform_utf8_length(*a1);
  v2 = v3[0] - 1;
  if (v2 <= 3)
    __asm { BR              X8 }
  v5 = a1 + 1;
  --v3[0];
  while (v3[0])
  {
    *(_DWORD *)&v3[1] |= *v5++ & 0x3F;
    if (--v3[0])
      *(_DWORD *)&v3[1] <<= 6;
  }
  return *(unsigned int *)&v3[1];
}

void _dispatch_time_init()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  double v6;
  BOOL v7;
  kern_return_t v8;
  mach_timebase_info info;
  uint64_t v10;
  uint64_t v11;

  info = 0;
  v8 = mach_timebase_info(&info);
  v11 = v8;
  v10 = 86;
  if (v8)
    _dispatch_bug(v10, v11, v0, v1, v2, v3, v4, v5);
  v7 = 0;
  if (info.numer == 125)
    v7 = info.denom == 3;
  if (!v7)
    _dispatch_host_time_init(&info, v6);
}

_DWORD *_dispatch_host_time_init(_DWORD *result, double a2)
{
  unint64_t v2;

  LODWORD(a2) = *result;
  *(double *)&v2 = (double)*(unint64_t *)&a2;
  _dispatch_host_time_data = v2;
  LODWORD(v2) = result[1];
  *(double *)&_dispatch_host_time_data = *(double *)&_dispatch_host_time_data / (double)v2;
  byte_E5728 = *result == result[1];
  _dispatch_host_time_mach2nano = (uint64_t (*)(_QWORD))_dispatch_mach_host_time_mach2nano;
  _dispatch_host_time_nano2mach = (uint64_t (*)(_QWORD))_dispatch_mach_host_time_nano2mach;
  return result;
}

dispatch_time_t dispatch_time(dispatch_time_t when, int64_t delta)
{
  uint64_t v3;
  uint64_t v4;
  int v5;
  unint64_t v6;
  int64_t v7;
  dispatch_time_t v8;
  unint64_t v10;
  uint64_t *v11;
  int *v12;
  char v13;
  uint64_t v14;
  dispatch_time_t v15;
  int v16;
  dispatch_time_t v18;
  int v19;
  dispatch_time_t v21;
  int v22;
  uint64_t v24;
  int v25;
  unint64_t v27;
  unint64_t v28;
  unint64_t v29;
  unint64_t v30;

  v8 = when;
  v7 = delta;
  v6 = 0;
  if (when == -1)
    return -1;
  v5 = 0;
  v4 = 0;
  v14 = v8;
  v13 = 1;
  v12 = &v5;
  v11 = &v4;
  v10 = 0;
  if (v8 == 0x8000000000000000)
  {
    *v12 = 1;
    *v11 = _dispatch_monotonic_time();
  }
  else if (v8 == -2)
  {
    *v12 = 2;
    *v11 = _dispatch_get_nanoseconds();
  }
  else if (v8)
  {
    if (v14 >= 0)
    {
      *v12 = 0;
      v10 = v14;
    }
    else if ((v14 & 0x4000000000000000) != 0)
    {
      *v12 = 2;
      v10 = -v14;
    }
    else
    {
      *v12 = 1;
      v10 = v14 & 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v10 <= 0x3FFFFFFFFFFFFFFFLL)
      v3 = v10;
    else
      v3 = -1;
    *v11 = v3;
  }
  else
  {
    *v12 = 0;
    *v11 = _dispatch_uptime();
  }
  if (v4 == -1)
    return -1;
  if (v5 == 2)
  {
    v6 = v7;
    if (v7 < 0)
    {
      v4 += v6;
      if (v4 < 1)
        v4 = 2;
    }
    else
    {
      v4 += v6;
      if (v4 <= 0)
        return -1;
    }
    v25 = 2;
    v24 = v4;
    if ((unint64_t)v4 < 0x3FFFFFFFFFFFFFFFLL)
      return -v24;
    else
      return -1;
  }
  else if (v7 < 0)
  {
    v27 = -v7;
    if (_dispatch_host_time_nano2mach)
    {
      v28 = _dispatch_host_time_nano2mach(v27);
    }
    else if (v27)
    {
      if (v27 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v27 < 0x5555555555555555)
          v28 = 3 * v27 / 0x7D;
        else
          v28 = 3 * (v27 / 0x7D);
      }
      else
      {
        v28 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v28 = 0;
    }
    v6 = v28;
    v4 -= v28;
    if (v4 >= 1)
    {
      v16 = v5;
      v15 = v4;
      if ((unint64_t)v4 >= 0x3FFFFFFFFFFFFFFFLL)
        return -1;
      if (!v16)
        return v15;
      if (v16 == 1)
        return v15 | 0x8000000000000000;
      return -(uint64_t)v15;
    }
    else
    {
      v19 = v5;
      v18 = 1;
      if (!v5)
        return v18;
      if (v19 == 1)
        return v18 | 0x8000000000000000;
      return -(uint64_t)v18;
    }
  }
  else
  {
    v29 = v7;
    if (_dispatch_host_time_nano2mach)
    {
      v30 = _dispatch_host_time_nano2mach(v29);
    }
    else if (v29)
    {
      if (v29 < 0x7FFFFFFFFFFFFFFFLL)
      {
        if (v29 < 0x5555555555555555)
          v30 = 3 * v29 / 0x7D;
        else
          v30 = 3 * (v29 / 0x7D);
      }
      else
      {
        v30 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v30 = 0;
    }
    v6 = v30;
    v4 += v30;
    if (v4 > 0)
    {
      v22 = v5;
      v21 = v4;
      if ((unint64_t)v4 >= 0x3FFFFFFFFFFFFFFFLL)
        return -1;
      if (!v22)
        return v21;
      if (v22 == 1)
        return v21 | 0x8000000000000000;
      return -(uint64_t)v21;
    }
    else
    {
      return -1;
    }
  }
}

uint64_t dispatch_time_to_nsecs(uint64_t a1, _QWORD *a2, unint64_t *a3)
{
  uint64_t v4;
  unint64_t v5;
  int v6;
  unint64_t *v7;
  _QWORD *v8;
  uint64_t v9;
  char v10;
  unint64_t v11;
  unint64_t *v12;
  int *v13;
  char v14;
  uint64_t v15;
  unint64_t v16;
  unint64_t v17;
  unint64_t v18;
  unint64_t v19;

  v9 = a1;
  v8 = a2;
  v7 = a3;
  v6 = 0;
  v5 = 0;
  if (a1 == -1)
    goto LABEL_41;
  v15 = v9;
  v14 = 1;
  v13 = &v6;
  v12 = &v5;
  v11 = 0;
  if (v9 == 0x8000000000000000)
  {
    *v13 = 1;
    *v12 = _dispatch_monotonic_time();
  }
  else if (v9 == -2)
  {
    *v13 = 2;
    *v12 = _dispatch_get_nanoseconds();
  }
  else if (v9)
  {
    if (v15 >= 0)
    {
      *v13 = 0;
      v11 = v15;
    }
    else if ((v15 & 0x4000000000000000) != 0)
    {
      *v13 = 2;
      v11 = -v15;
    }
    else
    {
      *v13 = 1;
      v11 = v15 & 0x7FFFFFFFFFFFFFFFLL;
    }
    if (v11 <= 0x3FFFFFFFFFFFFFFFLL)
      v4 = v11;
    else
      v4 = -1;
    *v12 = v4;
  }
  else
  {
    *v13 = 0;
    *v12 = _dispatch_uptime();
  }
  if (v6)
  {
    if (v6 != 1)
    {
      if (v6 == 2)
      {
        *v8 = 3;
        *v7 = v5;
        v10 = 1;
        return v10 & 1;
      }
LABEL_41:
      *v8 = 0;
      *v7 = -1;
      v10 = 0;
      return v10 & 1;
    }
    *v8 = 2;
    v16 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      v17 = _dispatch_host_time_mach2nano(v16);
    }
    else if (v16)
    {
      if (v16 < 0x3126E978D4FDF3ALL)
      {
        if (v16 < 0x20C49BA5E353F7CLL)
          v17 = 125 * v16 / 3;
        else
          v17 = 125 * (v16 / 3);
      }
      else
      {
        v17 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v17 = 0;
    }
    *v7 = v17;
    v10 = 1;
  }
  else
  {
    *v8 = 1;
    v18 = v5;
    if (_dispatch_host_time_mach2nano)
    {
      v19 = _dispatch_host_time_mach2nano(v18);
    }
    else if (v18)
    {
      if (v18 < 0x3126E978D4FDF3ALL)
      {
        if (v18 < 0x20C49BA5E353F7CLL)
          v19 = 125 * v18 / 3;
        else
          v19 = 125 * (v18 / 3);
      }
      else
      {
        v19 = 0x7FFFFFFFFFFFFFFFLL;
      }
    }
    else
    {
      v19 = 0;
    }
    *v7 = v19;
    v10 = 1;
  }
  return v10 & 1;
}

unint64_t dispatch_time_from_nsec(uint64_t a1, unint64_t a2)
{
  unint64_t v3;
  uint64_t v5;
  unint64_t v9;

  v3 = a2;
  if (a2 < 2)
    v3 = 2;
  if (_dispatch_host_time_nano2mach)
  {
    v9 = _dispatch_host_time_nano2mach(v3);
  }
  else if (v3)
  {
    if (v3 < 0x7FFFFFFFFFFFFFFFLL)
    {
      if (v3 < 0x5555555555555555)
        v9 = 3 * v3 / 0x7D;
      else
        v9 = 3 * (v3 / 0x7D);
    }
    else
    {
      v9 = 0x7FFFFFFFFFFFFFFFLL;
    }
  }
  else
  {
    v9 = 0;
  }
  switch(a1)
  {
    case 1:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL)
        return v9;
      else
        return -1;
    case 2:
      if (v9 < 0x3FFFFFFFFFFFFFFFLL)
        return v9 | 0x8000000000000000;
      else
        return -1;
    case 3:
      if (v3 < 0x3FFFFFFFFFFFFFFFLL)
        return -(uint64_t)v3;
      else
        return -1;
  }
  return v5;
}

dispatch_time_t dispatch_walltime(const timespec *when, int64_t delta)
{
  dispatch_time_t v2;
  __uint64_t nanoseconds;
  uint64_t v5;

  if (when)
    nanoseconds = 1000000000 * when->tv_sec + when->tv_nsec;
  else
    nanoseconds = _dispatch_get_nanoseconds();
  v5 = nanoseconds + delta;
  if (v5 > 1)
    return -v5;
  v2 = -2;
  if (delta >= 0)
    return -1;
  return v2;
}

unint64_t _dispatch_timeout(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v11;
  __uint64_t v12;
  int v13;
  __uint64_t nanoseconds;
  uint64_t v15;
  unint64_t v17;
  uint64_t *v18;
  int *v19;
  char v20;
  unint64_t v21;
  unint64_t v22;
  uint64_t v24;
  _BOOL8 v25;

  v15 = a1;
  nanoseconds = 0;
  switch(a1)
  {
    case -9223372036854775808:
    case -2:
      return 0;
    case -1:
      return -1;
    case 0:
      return 0;
  }
  v13 = 0;
  v12 = 0;
  v21 = v15;
  v20 = 0;
  v19 = &v13;
  v18 = (uint64_t *)&v12;
  v17 = 0;
  if (v15 >= 0)
  {
    *v19 = 0;
    v17 = v21;
  }
  else if ((v21 & 0x4000000000000000) != 0)
  {
    *v19 = 2;
    v17 = -(uint64_t)v21;
  }
  else
  {
    *v19 = 1;
    v17 = v21 & 0x7FFFFFFFFFFFFFFFLL;
  }
  if (v17 <= 0x3FFFFFFFFFFFFFFFLL)
    v11 = v17;
  else
    v11 = -1;
  *v18 = v11;
  if (v13 == 2)
  {
    nanoseconds = _dispatch_get_nanoseconds();
    if (nanoseconds < v12)
      return v12 - nanoseconds;
    else
      return 0;
  }
  else
  {
    if (v13)
    {
      v25 = v13 == 1;
      v24 = 241;
      if (v13 != 1)
        _dispatch_abort(v24, v25, a3, a4, a5, a6, a7, a8);
      nanoseconds = _dispatch_monotonic_time();
    }
    else
    {
      nanoseconds = _dispatch_uptime();
    }
    if (nanoseconds >= v12)
      return 0;
    v22 = v12 - nanoseconds;
    if (_dispatch_host_time_mach2nano)
      return _dispatch_host_time_mach2nano(v22);
    if (!v22)
      return 0;
    if (v22 >= 0x3126E978D4FDF3ALL)
      return 0x7FFFFFFFFFFFFFFFLL;
    if (v22 < 0x20C49BA5E353F7CLL)
      return 125 * v22 / 3;
    return 125 * (v22 / 3);
  }
}

unint64_t _dispatch_mach_host_time_mach2nano(unint64_t a1)
{
  char v2;

  v2 = 1;
  if (a1)
    v2 = byte_E5728;
  if ((v2 & 1) != 0)
    return a1;
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL)
    return 0x7FFFFFFFFFFFFFFFLL;
  if ((double)a1 * *(double *)&_dispatch_host_time_data + 0.5 < 9.22337204e18)
    return (unint64_t)((double)a1 * *(double *)&_dispatch_host_time_data + 0.5);
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_mach_host_time_nano2mach(unint64_t a1)
{
  char v2;

  v2 = 1;
  if (a1)
    v2 = byte_E5728;
  if ((v2 & 1) != 0)
    return a1;
  if (a1 >= 0x7FFFFFFFFFFFFFFFLL)
    return 0x7FFFFFFFFFFFFFFFLL;
  if ((double)a1 / *(double *)&_dispatch_host_time_data + 0.5 < 9.22337204e18)
    return (unint64_t)((double)a1 / *(double *)&_dispatch_host_time_data + 0.5);
  return 0x7FFFFFFFFFFFFFFFLL;
}

unint64_t _dispatch_continuation_alloc_from_heap()
{
  _dispatch_continuation_alloc_once();
  if ((_dispatch_use_dispatch_alloc & 1) != 0)
    return _dispatch_alloc_continuation_alloc();
  else
    return _dispatch_malloc_continuation_alloc();
}

void _dispatch_continuation_alloc_once()
{
  if (_dispatch_continuation_alloc_init_pred != -1)
    dispatch_once_f(&_dispatch_continuation_alloc_init_pred, 0, (dispatch_function_t)_dispatch_continuation_alloc_init);
}

unint64_t _dispatch_alloc_continuation_alloc()
{
  uint64_t v0;
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  unsigned int v6;
  unint64_t *v7;
  unsigned int unset_bit_upto_index;
  unint64_t *v9;
  unsigned int i;
  uint64_t v11;
  unint64_t v12;
  unsigned int v14;
  unint64_t *v15;
  uint64_t v16;
  uint64_t v17;

  v12 = 0;
  if (!_dispatch_main_heap)
    return _dispatch_alloc_continuation_from_heap_slow();
  v11 = 0;
  v17 = _dispatch_main_heap;
  v16 = 59;
  v14 = _dispatch_cpu_number();
  v11 = *(_QWORD *)(_dispatch_main_heap + ((unint64_t)v14 << 20) + 8);
  if (v11)
  {
    for (i = 0; i < 4; ++i)
    {
      v9 = (unint64_t *)(v11 + 8 * i);
      v15 = v9;
      unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v9, 0xFFFFFFFF);
      if (unset_bit_upto_index != -1)
      {
        v7 = 0;
        v6 = 0;
        get_cont_and_indices_for_bitmap_and_index((uint64_t)v9, unset_bit_upto_index, (uint64_t *)&v12, (uint64_t *)&v7, &v6);
        mark_bitmap_as_full_if_still_full(v7, v6, (uint64_t *)v9, v0, v1, v2, v3, v4);
        return v12;
      }
    }
  }
  v12 = _dispatch_alloc_continuation_from_heap(_dispatch_main_heap);
  if (v12)
    return v12;
  else
    return _dispatch_alloc_continuation_from_heap_slow();
}

uint64_t _dispatch_malloc_continuation_alloc()
{
  uint64_t v1;

  while (1)
  {
    v1 = malloc_type_calloc(1, 64, 2031856694);
    if (v1)
      break;
    _dispatch_temporary_resource_shortage();
  }
  return v1;
}

void _dispatch_continuation_free_to_heap(_QWORD *a1)
{
  if ((_dispatch_use_dispatch_alloc & 1) != 0)
    _dispatch_alloc_continuation_free(a1);
  else
    _dispatch_malloc_continuation_free(a1);
}

void _dispatch_alloc_continuation_free(_QWORD *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  BOOL v11;
  BOOL v12;
  unsigned int v13;
  unsigned int v14;
  unint64_t *v15;
  unint64_t *v16;
  _QWORD *v17;

  v17 = a1;
  v16 = 0;
  v15 = 0;
  v14 = 0;
  v13 = 0;
  *a1 = 0;
  get_maps_and_indices_for_continuation((uint64_t)v17, &v15, &v14, &v16, &v13);
  v12 = bitmap_clear_bit(v16, v13, 1, v1, v2, v3, v4, v5);
  if (v15)
    bitmap_clear_bit(v15, v14, 0, v6, v7, v8, v9, v10);
  v11 = 0;
  if (v12)
    v11 = v15 != 0;
  if (v11)
    _dispatch_alloc_maybe_madvise_page((uint64_t)v17);
}

void _dispatch_malloc_continuation_free(void *a1)
{
  free(a1);
}

const char *_dispatch_continuation_alloc_init()
{
  const char *result;
  BOOL v1;

  v1 = malloc_engaged_nano() == 0;
  result = getenv("LIBDISPATCH_CONTINUATION_ALLOCATOR");
  if (result)
  {
    result = (const char *)atoi(result);
    v1 = (_DWORD)result != 0;
  }
  _dispatch_use_dispatch_alloc = v1;
  if (v1)
    return (const char *)_os_object_atfork_prepare();
  return result;
}

uint64_t get_cont_and_indices_for_bitmap_and_index(uint64_t a1, unsigned int a2, uint64_t *a3, uint64_t *a4, unsigned int *a5)
{
  uint64_t result;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  unsigned int v12;
  unsigned int v13;
  unsigned int v14;
  uint64_t v15;

  result = magazine_for_continuation(a1);
  v15 = result;
  v14 = (a1 - (result + 64)) / 8;
  v13 = v14 % 0x40;
  v12 = v14 / 0x40;
  if (result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8 * (v14 % 0x40) != a1)
    _dispatch_abort(114, result + 64 + ((unint64_t)(v14 / 0x40) << 9) + 8 * (v14 % 0x40) == a1, v6, v7, v8, v9, v10, v11);
  if (a3)
  {
    result = continuation_address(result, v12, v13, a2, v8, v9, v10, v11);
    *a3 = result;
  }
  if (a4)
  {
    result = supermap_address(v15, v12);
    *a4 = result;
  }
  if (a5)
    *a5 = v13;
  return result;
}

BOOL mark_bitmap_as_full_if_still_full(unint64_t *a1, unsigned int a2, uint64_t *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  unint64_t v8;
  _BOOL8 result;
  _BOOL4 v10;
  unint64_t v11;
  unint64_t v12;
  uint64_t v13;

  if (a2 >= 0x40)
    _dispatch_abort(274, a2 < 0x40, (uint64_t)a3, a4, a5, a6, a7, a8);
  v13 = 1 << a2;
  while (1)
  {
    v8 = _os_atomic_mo_has_acquire(0) ? __ldaxr(a1) : __ldxr(a1);
    v12 = v8;
    result = bitmap_is_full(*a3);
    if (!result)
      break;
    v11 = v12 | v13;
    result = _os_atomic_mo_has_release(0);
    if (result)
      v10 = __stlxr(v11, a1) == 0;
    else
      v10 = __stxr(v11, a1) == 0;
    if (v10)
      return result;
  }
  __clrex();
  return result;
}

unint64_t _dispatch_alloc_continuation_from_heap(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v8;
  unint64_t page;

  v8 = _dispatch_cpu_number();
  if (v8 >= MEMORY[0xFFFFFC036])
    _dispatch_abort(440, v8 < MEMORY[0xFFFFFC036], v1, v2, v3, v4, v5, v6);
  page = alloc_continuation_from_first_page(a1 + ((unint64_t)v8 << 20));
  if (page)
    return page;
  else
    return alloc_continuation_from_magazine(a1 + ((unint64_t)v8 << 20));
}

unint64_t _dispatch_alloc_continuation_from_heap_slow()
{
  unint64_t v1;
  unint64_t *i;

  for (i = (unint64_t *)&_dispatch_main_heap; ; i = (unint64_t *)*i)
  {
    if (!*i)
      _dispatch_alloc_try_create_heap(i);
    v1 = _dispatch_alloc_continuation_from_heap(*i);
    if (v1)
      break;
  }
  return v1;
}

unint64_t _dispatch_cpu_number()
{
  return _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 2)) & 0xFFF;
}

uint64_t bitmap_set_first_unset_bit_upto_index(unint64_t *a1, unsigned int a2)
{
  unint64_t v2;
  int v3;
  int v4;
  _BOOL4 v8;
  unint64_t v9;
  unint64_t v10;
  unsigned int v11;

  do
  {
    if (_os_atomic_mo_has_acquire(0))
      v2 = __ldaxr(a1);
    else
      v2 = __ldxr(a1);
    v10 = v2;
    v3 = __clz(__rbit64(~v2));
    v4 = 0;
    if (v10 != -1)
      v4 = v3 + 1;
    if (!v4 || (v11 = v4 - 1, v4 - 1 > a2))
    {
      __clrex();
      return -1;
    }
    v9 = v10 | (1 << v11);
    if (_os_atomic_mo_has_release(0))
      v8 = __stlxr(v9, a1) == 0;
    else
      v8 = __stxr(v9, a1) == 0;
  }
  while (!v8);
  return v11;
}

unint64_t magazine_for_continuation(uint64_t a1)
{
  return a1 & 0xFFFFFFFFFFF00000;
}

unint64_t continuation_address(uint64_t a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  if (a2 >= 3)
    _dispatch_abort(88, a2 < 3, a3, a4, a5, a6, a7, a8);
  if (a3 >= 0x40)
    _dispatch_abort(89, a3 < 0x40, a3, a4, a5, a6, a7, a8);
  if (a4 >= 0x40)
    _dispatch_abort(90, a4 < 0x40, a3, a4, a5, a6, a7, a8);
  return a1
       + 0x4000
       + ((unint64_t)a2 << 18)
       + ((unint64_t)a3 << 12)
       + ((unint64_t)a4 << 6);
}

uint64_t supermap_address(uint64_t a1, unsigned int a2)
{
  return a1 + 16 + 8 * a2;
}

BOOL bitmap_is_full(uint64_t a1)
{
  return a1 == -1;
}

unint64_t alloc_continuation_from_first_page(uint64_t a1)
{
  int unset_bit_upto_index;
  unsigned int i;

  for (i = 0; i < 3; ++i)
  {
    unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((unint64_t *)(a1 + 1600 + 8 * i), 0xFFFFFFFF);
    if (unset_bit_upto_index != -1)
      return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
  }
  unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index((unint64_t *)(a1 + 1600 + 8 * i), 0x25u);
  if (unset_bit_upto_index == -1)
    return 0;
  return a1 + 1664 + ((unint64_t)(unset_bit_upto_index + (i << 6)) << 6);
}

unint64_t alloc_continuation_from_magazine(uint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  unint64_t *v17;
  unint64_t *v18;
  unsigned int unset_bit_upto_index;
  unsigned int j;
  unsigned int i;
  unint64_t bitmap_in_same_page;

  for (i = 0; i < 3; ++i)
  {
    v18 = (unint64_t *)supermap_address(a1, i);
    if (!bitmap_is_full(*v18))
    {
      for (j = 0; j < 0x40; ++j)
      {
        v17 = (unint64_t *)bitmap_address(a1, i, j);
        unset_bit_upto_index = bitmap_set_first_unset_bit_upto_index(v17, 0xFFFFFFFF);
        if (unset_bit_upto_index != -1)
        {
          bitmap_in_same_page = first_bitmap_in_same_page((unint64_t)v17);
          if (!_dispatch_main_heap)
            _dispatch_abort(50, 0, v1, v2, v3, v4, v5, v6);
          *(_QWORD *)(_dispatch_main_heap + ((unint64_t)_dispatch_cpu_number() << 20) + 8) = bitmap_in_same_page;
          mark_bitmap_as_full_if_still_full(v18, j, (uint64_t *)v17, v7, v8, v9, v10, v11);
          return continuation_address(a1, i, j, unset_bit_upto_index, v12, v13, v14, v15);
        }
      }
    }
  }
  return 0;
}

unint64_t bitmap_address(uint64_t a1, unsigned int a2, unsigned int a3)
{
  return a1 + 64 + ((unint64_t)a2 << 9) + 8 * a3;
}

unint64_t first_bitmap_in_same_page(unint64_t a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unint64_t v8;

  v8 = magazine_for_continuation(a1);
  if (a1 < v8 + 64)
    _dispatch_abort(201, a1 >= v8 + 64, v1, v2, v3, v4, v5, v6);
  if (a1 >= v8 + 2112)
    _dispatch_abort(203, a1 < v8 + 2112, v1, v2, v3, v4, v5, v6);
  return a1 & 0xFFFFFFFFFFFFFFE0;
}

void _dispatch_alloc_try_create_heap(unint64_t *a1)
{
  unint64_t *v1;
  mach_vm_address_t v2;
  unint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  int v10;
  void *v11;
  mach_vm_address_t address;
  mach_vm_offset_t v13;
  mach_vm_size_t v14;
  kern_return_t v15;
  unint64_t *v16;
  uint64_t v17;
  int v18;
  uint64_t v19;
  int v20;
  uint64_t v21;
  uint64_t v22;

  v16 = a1;
  v15 = 0;
  v20 = 0;
  v19 = 0xFFFFFC036;
  v14 = MEMORY[0xFFFFFC036] << 20;
  v13 = 0xFFFFFLL;
  for (address = vm_page_size; ; address = vm_page_size)
  {
    v15 = mach_vm_map(mach_task_self_, &address, v14, v13, 1241513985, 0, 0, 0, 3, 7, 1u);
    if (!v15)
      break;
    if (v15 != 3)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Could not allocate heap";
      qword_E4DA8 = v15;
      __break(1u);
      JUMPOUT(0xBA0C4);
    }
    _dispatch_temporary_resource_shortage();
  }
  v11 = (void *)address;
  v1 = v16;
  v2 = address;
  do
    v3 = __ldaxr(v1);
  while (!v3 && __stlxr(v2, v1));
  if (v3)
  {
    v18 = 0;
    v17 = 0xFFFFFC036;
    v10 = mprotect(v11, MEMORY[0xFFFFFC036] << 20, 0);
    v22 = v10;
    v21 = 424;
    if (v10)
      _dispatch_bug(v21, v22, v4, v5, v6, v7, v8, v9);
  }
}

BOOL get_maps_and_indices_for_continuation(uint64_t a1, _QWORD *a2, unsigned int *a3, _QWORD *a4, unsigned int *a5)
{
  _BOOL8 result;
  unint64_t v6;
  unsigned int v8;
  unsigned int v9;
  unsigned int v10;

  v6 = magazine_for_continuation(a1);
  result = continuation_is_in_first_page(a1);
  if (result)
  {
    v8 = ((uint64_t)(a1 - (v6 + 1664)) / 64) / 0x40;
    if (a2)
      *a2 = 0;
    if (a3)
      *a3 = v8;
    if (a4)
      *a4 = v6 + 1600 + 8 * v8;
    if (a5)
      *a5 = ((uint64_t)(a1 - (v6 + 1664)) / 64) % 0x40;
  }
  else
  {
    v10 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x1000;
    v9 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) / 0x40 % 0x40;
    if (a2)
      *a2 = v6 + 16 + 8 * v10;
    if (a3)
      *a3 = v9;
    if (a4)
      *a4 = v6 + 64 + ((unint64_t)v10 << 9) + 8 * v9;
    if (a5)
      *a5 = ((uint64_t)(a1 - (v6 + 0x4000)) / 64) % 0x40;
  }
  return result;
}

BOOL bitmap_clear_bit(unint64_t *a1, unsigned int a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  unint64_t v9;
  unint64_t v10;
  unint64_t v12;
  uint64_t v13;

  if (a2 >= 0x40)
    _dispatch_abort(251, a2 < 0x40, a3, a4, a5, a6, a7, a8);
  v13 = 1 << a2;
  if ((a3 & 1) != 0 && (*a1 & v13) == 0)
  {
    v8 = *a1;
    qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: Corruption: failed to clear bit exclusively";
    qword_E4DA8 = v8;
    __break(1u);
    JUMPOUT(0xBA614);
  }
  v12 = *a1;
  do
  {
    v9 = v12;
    do
      v10 = __ldaxr(a1);
    while (v10 == v12 && __stlxr(v12 & ~v13, a1));
    v12 = v10;
  }
  while (v10 != v9);
  return (v10 & ~v13) == 0;
}

void _dispatch_alloc_maybe_madvise_page(uint64_t a1)
{
  unint64_t *v1;
  unint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  unsigned int i;
  _QWORD *v12;
  void *v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;

  v14 = a1;
  v13 = (void *)madvisable_page_base_for_continuation(a1);
  if (v13)
  {
    v12 = 0;
    get_maps_and_indices_for_continuation((uint64_t)v13, 0, 0, &v12, 0);
    for (i = 0; i < 4; ++i)
    {
      if (v12[i])
        return;
    }
    v10 = 0;
    while (1)
    {
      v1 = &v12[v10];
      do
        v2 = __ldaxr(v1);
      while (!v2 && __stlxr(0xFFFFFFFFFFFFFFFFLL, v1));
      if (v2)
        break;
      if (++v10 >= 4)
      {
        __memset_chk(v13, 2947526575, 0x4000, -1);
        v9 = madvise(v13, 0x4000uLL, 5);
        v16 = v9;
        v15 = 563;
        if (v9)
          _dispatch_bug(v15, v16, v3, v4, v5, v6, v7, v8);
        break;
      }
    }
    while (v10 > 1)
      v12[--v10] = 0;
    if (v10)
      *v12 = 0;
  }
}

BOOL continuation_is_in_first_page(uint64_t a1)
{
  return (a1 & 0xFFFFFFFFFFF00000) == (a1 & 0xFFFFFFFFFFFFC000);
}

unint64_t madvisable_page_base_for_continuation(uint64_t a1)
{
  unint64_t v2;

  if (continuation_is_in_first_page(a1))
    return 0;
  v2 = magazine_for_continuation(a1);
  if ((a1 & 0xFFFFFFFFFFFFC000) < v2 + 0x4000)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too low";
    qword_E4DA8 = a1 & 0xFFFFFFFFFFFFC000;
    __break(1u);
    JUMPOUT(0xBAA58);
  }
  if ((a1 & 0xFFFFFFFFFFFFC000) > v2 + 802752)
  {
    qword_E4D78 = (uint64_t)"BUG IN LIBDISPATCH: madvisable continuation too high";
    qword_E4DA8 = a1 & 0xFFFFFFFFFFFFC000;
    __break(1u);
    JUMPOUT(0xBAABCLL);
  }
  return a1 & 0xFFFFFFFFFFFFC000;
}

uint64_t dispatch_benchmark(unint64_t a1, uint64_t a2)
{
  void (*v2)(uint64_t);

  v2 = (void (*)(uint64_t))_Block_get_invoke_fn(a2);
  return dispatch_benchmark_f(a1, a2, v2);
}

uint64_t dispatch_benchmark_f(unint64_t a1, uint64_t a2, void (*a3)(uint64_t))
{
  unint64_t v4;
  uint64_t v5;
  uint64_t v6;

  v4 = 0;
  if (dispatch_benchmark_f_pred != -1)
    dispatch_once_f(&dispatch_benchmark_f_pred, &dispatch_benchmark_f_bdata, (dispatch_function_t)_dispatch_benchmark_init);
  if (!a1)
    return 0;
  v6 = _dispatch_uptime();
  do
  {
    ++v4;
    a3(a2);
  }
  while (v4 < a1);
  v5 = _dispatch_uptime() - v6;
  return __udivti3(v5 * dispatch_benchmark_f_bdata, (v5 * (unsigned __int128)dispatch_benchmark_f_bdata) >> 64, dword_E4D4C * a1)- qword_E4D50;
}

uint64_t _dispatch_benchmark_init(unsigned int *a1)
{
  uint64_t v1;
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  unsigned __int128 v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t result;
  uint64_t v11;
  unint64_t v12;
  unint64_t v13;
  uint64_t v14;
  void (*v15)(uint64_t);
  uint64_t v17;

  v15 = (void (*)(uint64_t))*((_QWORD *)a1 + 2);
  v14 = *((_QWORD *)a1 + 3);
  v13 = *((_QWORD *)a1 + 4);
  v12 = 0;
  v17 = mach_timebase_info((mach_timebase_info_t)a1);
  if (v17)
    _dispatch_abort(53, v17, v1, v2, v3, v4, v5, v6);
  v11 = _dispatch_uptime();
  do
  {
    ++v12;
    v15(v14);
  }
  while (v12 < v13);
  v7 = (_dispatch_uptime() - v11) * (unsigned __int128)*a1;
  v8 = __udivti3(v7, *((_QWORD *)&v7 + 1), a1[1]);
  result = __udivti3(v8, v9, v13);
  *((_QWORD *)a1 + 1) = result;
  return result;
}

uint64_t _dispatch_send_wakeup_runloop_thread(unsigned int a1, mach_msg_timeout_t a2)
{
  unsigned int v3;
  mach_msg_header_t v4;
  mach_msg_timeout_t v5;
  unsigned int v6;

  v6 = a1;
  v5 = a2;
  *(_QWORD *)&v4.msgh_bits = 19;
  *(_QWORD *)&v4.msgh_voucher_port = 0x4E00000000;
  *(_QWORD *)&v4.msgh_remote_port = a1;
  v3 = mach_msg(&v4, 17, 0x18u, 0, 0, a2, 0);
  if (v3 == 268435460)
  {
    if ((unsigned __int16)(v4.msgh_bits & 0x1F00) >> 8 == 17)
      mach_port_deallocate(mach_task_self_, v4.msgh_local_port);
    mach_msg_destroy(&v4);
  }
  return v3;
}

uint64_t _dispatch_send_consume_send_once_right(unsigned int a1)
{
  mach_msg_header_t v2;
  unsigned int v3;

  v3 = a1;
  *(_QWORD *)&v2.msgh_bits = 18;
  *(_QWORD *)&v2.msgh_voucher_port = 0x4F00000000;
  *(_QWORD *)&v2.msgh_remote_port = a1;
  return mach_msg(&v2, 1, 0x18u, 0, 0, 0, 0);
}

uint64_t libdispatch_internal_protocol_server_routine(uint64_t a1)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a1 + 20) - 64;
  if (v2 < 0x10)
    return qword_E2210[5 * (int)v2 + 1];
  else
    return 0;
}

uint64_t _Xmach_notify_port_deleted(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;

  result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_mach_notify_port_deleted(*(unsigned int *)(a1 + 12), *(unsigned int *)(a1 + 32), v3, v4, v5, v6, v7, v8);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_send_possible(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_mach_notify_send_possible(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_port_destroyed(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_port_destroyed_t((int *)a1);
  if (!(_DWORD)result)
    _dispatch_mach_notify_port_destroyed(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 28));
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_no_senders(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if (!(_DWORD)result)
    _dispatch_mach_notify_no_senders(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xmach_notify_send_once(uint64_t a1, uint64_t a2)
{
  uint64_t result;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;

  result = __MIG_check__Request__mach_notify_send_once_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_mach_notify_send_once(*(unsigned int *)(a1 + 12), v3, v4, v5, v6, v7, v8, v9);
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xmach_notify_dead_name(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_port_deleted_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_mach_notify_dead_name(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xwakeup_runloop_thread(int *a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t _Xconsume_send_once_right(int *a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__mach_notify_send_once_t(a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = _dispatch_wakeup_runloop_thread();
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t libdispatch_internal_protocol_server(_DWORD *a1, uint64_t a2)
{
  void (*v3)(_DWORD *, uint64_t);

  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 20) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 79
    && (int)a1[5] >= 64
    && (v3 = (void (*)(_DWORD *, uint64_t))qword_E2210[5 * a1[5] - 319]) != 0)
  {
    v3(a1, a2);
    return 1;
  }
  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }
}

uint64_t __MIG_check__Request__mach_notify_port_deleted_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 36)
    return 0;
  else
    return -304;
}

uint64_t __MIG_check__Request__mach_notify_port_destroyed_t(int *a1)
{
  if (*a1 < 0 && a1[6] == 1 && a1[1] == 40)
  {
    if (!HIBYTE(a1[9]) && BYTE2(a1[9]) == 16)
      return 0;
    else
      return -300;
  }
  else
  {
    return -304;
  }
}

uint64_t __MIG_check__Request__mach_notify_send_once_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 24)
    return 0;
  else
    return -304;
}

uint64_t firehose_send_register(int a1, int a2, uint64_t a3, int a4, int a5, int a6, int a7, uint64_t a8)
{
  _BYTE __b[112];
  uint64_t v10;
  int v11;
  int v12;
  int v13;
  int v14;
  uint64_t v15;
  int v16;
  int v17;

  v17 = a1;
  v16 = a2;
  v15 = a3;
  v14 = a4;
  v13 = a5;
  v12 = a6;
  v11 = a7;
  v10 = a8;
  memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[24] = 5;
  *(_DWORD *)&__b[28] = v16;
  *(_DWORD *)&__b[36] = *(_DWORD *)&__b[36] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[36] &= 0xFFFFFFu;
  *(_DWORD *)&__b[40] = v14;
  *(_DWORD *)&__b[48] = *(_DWORD *)&__b[48] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[48] &= 0xFFFFFFu;
  *(_DWORD *)&__b[52] = v13;
  *(_DWORD *)&__b[60] = *(_DWORD *)&__b[60] & 0xFF00FFFF | 0x100000;
  *(_DWORD *)&__b[60] &= 0xFFFFFFu;
  *(_DWORD *)&__b[64] = v12;
  *(_DWORD *)&__b[72] = *(_DWORD *)&__b[72] & 0xFF00FFFF | 0x140000;
  *(_DWORD *)&__b[72] &= 0xFFFFFFu;
  *(_DWORD *)&__b[76] = v11;
  *(_DWORD *)&__b[84] = *(_DWORD *)&__b[84] & 0xFF00FFFF | 0x110000;
  *(_DWORD *)&__b[84] &= 0xFFFFFFu;
  *(NDR_record_t *)&__b[88] = NDR_record;
  *(_QWORD *)&__b[96] = v15;
  *(_QWORD *)&__b[104] = v10;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)__b = -2147483629;
  *(_DWORD *)&__b[8] = v17;
  *(_DWORD *)&__b[20] = 11600;
  *(_DWORD *)&__b[16] = 0;
  return mach_msg((mach_msg_header_t *)__b, 1, 0x70u, 0, 0, 0, 0);
}

uint64_t firehose_send_push_and_wait(int a1, _OWORD *a2, _DWORD *a3)
{
  void *v3;
  BOOL v4;
  unsigned int v6;
  unsigned int v7;
  _BYTE __b[64];

  v3 = memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port(v3);
  *(_DWORD *)__b = 5395;
  *(_DWORD *)&__b[8] = a1;
  *(_DWORD *)&__b[20] = 11601;
  *(_DWORD *)&__b[16] = 0;
  v7 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v7)
  {
    v4 = v7 == 268435459 || v7 == 268435458;
    if (!v4 && v7 != 268435472)
      mig_dealloc_special_reply_port(*(unsigned int *)&__b[12]);
  }
  if (v7)
  {
    return v7;
  }
  else
  {
    v6 = __MIG_check__Reply__push_and_wait_t((int *)__b);
    if (v6)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v6;
    }
    else
    {
      *a2 = *(_OWORD *)&__b[36];
      *a3 = *(_DWORD *)&__b[52];
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__push_and_wait_t(int *a1)
{
  int v2;

  if (a1[5] == 11701)
  {
    v2 = a1[1];
    if (*a1 >= 0 && (v2 == 56 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }
      else if (a1[8])
      {
        return a1[8];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehose_send_push_async(int a1, int a2, mach_msg_timeout_t a3)
{
  unsigned int v4;
  _BYTE __b[36];
  mach_msg_timeout_t v6;
  int v7;
  int v8;

  v8 = a1;
  v7 = a2;
  v6 = a3;
  memset(__b, 0, sizeof(__b));
  *(NDR_record_t *)&__b[24] = NDR_record;
  *(_DWORD *)&__b[32] = v7;
  *(_DWORD *)&__b[12] = 0;
  *(_DWORD *)__b = 19;
  *(_DWORD *)&__b[8] = v8;
  *(_DWORD *)&__b[20] = 11602;
  *(_DWORD *)&__b[16] = 0;
  v4 = mach_msg((mach_msg_header_t *)__b, 17, 0x24u, 0, 0, v6, 0);
  if (v4 == 268435460)
  {
    if ((unsigned __int16)(*(_WORD *)__b & 0x1F00) >> 8 == 17)
      mach_port_deallocate(mach_task_self_, *(mach_port_name_t *)&__b[12]);
    mach_msg_destroy((mach_msg_header_t *)__b);
  }
  return v4;
}

uint64_t firehose_send_get_logging_prefs(int a1, _DWORD *a2, _QWORD *a3)
{
  void *v3;
  BOOL v4;
  unsigned int v6;
  unsigned int v7;
  _BYTE __b[64];
  _QWORD *v9;
  _DWORD *v10;
  int v11;

  v11 = a1;
  v10 = a2;
  v9 = a3;
  v3 = memset(__b, 0, sizeof(__b));
  *(_DWORD *)&__b[12] = mig_get_special_reply_port(v3);
  *(_DWORD *)__b = 5395;
  *(_DWORD *)&__b[8] = v11;
  *(_DWORD *)&__b[20] = 11603;
  *(_DWORD *)&__b[16] = 0;
  v7 = mach_msg((mach_msg_header_t *)__b, 3162115, 0x18u, 0x40u, *(mach_port_name_t *)&__b[12], 0, 0);
  if (v7)
  {
    v4 = v7 == 268435459 || v7 == 268435458;
    if (!v4 && v7 != 268435472)
      mig_dealloc_special_reply_port(*(unsigned int *)&__b[12]);
  }
  if (v7)
  {
    return v7;
  }
  else
  {
    v6 = __MIG_check__Reply__get_logging_prefs_t((int *)__b);
    if (v6)
    {
      mach_msg_destroy((mach_msg_header_t *)__b);
      return v6;
    }
    else
    {
      *v10 = *(_DWORD *)&__b[28];
      *v9 = *(_QWORD *)&__b[48];
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__get_logging_prefs_t(int *a1)
{
  int v2;

  if (a1[5] == 11703)
  {
    v2 = a1[1];
    if (*a1 < 0 && a1[6] == 1 && v2 == 56 || *a1 >= 0 && v2 == 36 && a1[8])
    {
      if (a1[2])
      {
        return -300;
      }
      else if (*a1 < 0)
      {
        if (!HIBYTE(a1[9]) && BYTE2(a1[9]) == 17)
          return 0;
        else
          return -300;
      }
      else
      {
        return a1[8];
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehose_send_should_send_strings(mach_port_t a1, mach_port_t *a2)
{
  void *v2;
  BOOL v3;
  unsigned int v5;
  unsigned int v6;
  mach_msg_header_t __b[2];
  mach_port_t *v8;
  mach_port_t v9;

  v9 = a1;
  v8 = a2;
  v2 = memset(__b, 0, sizeof(__b));
  __b[0].msgh_local_port = mig_get_special_reply_port(v2);
  __b[0].msgh_bits = 5395;
  __b[0].msgh_remote_port = v9;
  __b[0].msgh_id = 11604;
  __b[0].msgh_voucher_port = 0;
  v6 = mach_msg(__b, 3162115, 0x18u, 0x30u, __b[0].msgh_local_port, 0, 0);
  if (v6)
  {
    v3 = v6 == 268435459 || v6 == 268435458;
    if (!v3 && v6 != 268435472)
      mig_dealloc_special_reply_port(__b[0].msgh_local_port);
  }
  if (v6)
  {
    return v6;
  }
  else
  {
    v5 = __MIG_check__Reply__should_send_strings_t((int *)__b);
    if (v5)
    {
      mach_msg_destroy(__b);
      return v5;
    }
    else
    {
      *v8 = __b[1].msgh_local_port;
      return 0;
    }
  }
}

uint64_t __MIG_check__Reply__should_send_strings_t(int *a1)
{
  int v2;

  if (a1[5] == 11704)
  {
    v2 = a1[1];
    if (*a1 >= 0 && (v2 == 40 || v2 == 36 && a1[8]))
    {
      if (a1[2])
      {
        return -300;
      }
      else if (a1[8])
      {
        return a1[8];
      }
      else
      {
        return 0;
      }
    }
    else
    {
      return -300;
    }
  }
  else if (a1[5] == 71)
  {
    return -308;
  }
  else
  {
    return -301;
  }
}

uint64_t firehoseReply_server_routine(uint64_t a1)
{
  unsigned int v2;

  v2 = *(_DWORD *)(a1 + 20) - 11700;
  if (v2 <= 4)
    return qword_E24B0[5 * (int)v2 + 1];
  else
    return 0;
}

uint64_t _Xpush_reply(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__push_reply_t((int *)a1);
  if (!(_DWORD)result)
    firehose_client_push_reply(*(unsigned int *)(a1 + 12), *(_DWORD *)(a1 + 32));
  *(_DWORD *)(a2 + 32) = result;
  *(NDR_record_t *)(a2 + 24) = NDR_record;
  return result;
}

uint64_t _Xpush_notify_async(uint64_t a1, uint64_t a2)
{
  uint64_t result;

  result = __MIG_check__Request__push_notify_async_t((int *)a1);
  if ((_DWORD)result)
  {
    *(_DWORD *)(a2 + 32) = result;
    *(NDR_record_t *)(a2 + 24) = NDR_record;
  }
  else
  {
    result = firehose_client_push_notify_async(*(unsigned int *)(a1 + 12), *(_QWORD *)(a1 + 32), *(_QWORD *)(a1 + 40), *(_DWORD *)(a1 + 48));
    *(_DWORD *)(a2 + 32) = result;
  }
  return result;
}

uint64_t firehoseReply_server(_DWORD *a1, uint64_t a2)
{
  void (*v3)(_DWORD *, uint64_t);

  *(_DWORD *)a2 = *a1 & 0x1F;
  *(_DWORD *)(a2 + 8) = a1[2];
  *(_DWORD *)(a2 + 4) = 36;
  *(_DWORD *)(a2 + 12) = 0;
  *(_DWORD *)(a2 + 20) = a1[5] + 100;
  *(_DWORD *)(a2 + 16) = 0;
  if ((int)a1[5] <= 11704
    && (int)a1[5] >= 11700
    && (v3 = (void (*)(_DWORD *, uint64_t))qword_E24B0[5 * a1[5] - 58499]) != 0)
  {
    v3(a1, a2);
    return 1;
  }
  else
  {
    *(NDR_record_t *)(a2 + 24) = NDR_record;
    *(_DWORD *)(a2 + 32) = -303;
    return 0;
  }
}

uint64_t __MIG_check__Request__push_reply_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 56)
    return 0;
  else
    return -304;
}

uint64_t __MIG_check__Request__push_notify_async_t(int *a1)
{
  if (*a1 >= 0 && a1[1] == 52)
    return 0;
  else
    return -304;
}

void _dispatch_bug(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  if (_dispatch_build_pred != -1)
    dispatch_once_f(&_dispatch_build_pred, 0, (dispatch_function_t)_dispatch_build_init);
  v9 = _dispatch_bug_last_seen;
  _dispatch_bug_last_seen = v8;
  if (v8 != v9)
    _dispatch_log("BUG in libdispatch: %s - %lu - 0x%lx", a2, a3, a4, a5, a6, a7, a8, (uint64_t)&_dispatch_build);
}

void _dispatch_log(char *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
  _QWORD v9[2];
  char **v10;
  uint64_t v11;
  char *v12;
  dispatch_function_t v13;
  void *v14;
  dispatch_once_t *v15;

  v9[1] = a1;
  v9[0] = &a9;
  v12 = a1;
  v11 = 0;
  v10 = (char **)v9;
  v15 = &_dispatch_logv_pred;
  v14 = 0;
  v13 = (dispatch_function_t)_dispatch_logv_init;
  if (_dispatch_logv_pred != -1)
    dispatch_once_f(v15, v14, v13);
  if ((dispatch_log_disabled & 1) == 0)
  {
    if (dispatch_logfile == -1)
    {
      if (v10)
        _dispatch_vsyslog(v12, *v10);
      else
        _dispatch_syslog((uint64_t)v12);
    }
    else if (v10)
    {
      _dispatch_logv_file(v12, *v10);
    }
    else
    {
      _dispatch_log_file((uint64_t)v12, v11);
    }
  }
}

void _dispatch_bug_mach_client(uint64_t a1, mach_error_t a2)
{
  uint64_t v2;
  uint64_t v3;
  uint64_t v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;

  v10 = _dispatch_bug_mach_client_last_seen;
  _dispatch_bug_mach_client_last_seen = v2;
  if (v2 != v10)
  {
    mach_error_string(a2);
    _dispatch_log("BUG in libdispatch client: %s %s - 0x%x", v3, v4, v5, v6, v7, v8, v9, a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_mach_client";
      __break(1u);
      JUMPOUT(0xBCC58);
    }
  }
}

void _dispatch_bug_kevent_client(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;
  uint64_t v10;
  uint64_t v11;
  uint64_t v12;
  uint64_t v13;
  uint64_t v14;
  uint64_t v15;
  uint64_t v16;
  uint64_t v17;
  uint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  uint64_t v22;
  char *v23;
  char *v24;
  uint64_t v25;
  uint64_t v26;
  uint64_t v27;
  uint64_t v28;
  uint64_t v29;
  uint64_t v30;
  uint64_t v31;
  uint64_t *v32;
  char *v33;
  uint64_t v34;
  uint64_t *v35;
  uint64_t v36;
  uint64_t v37;
  _BOOL4 v38;
  uint64_t v39;
  uint64_t v40;
  _BOOL4 v41;
  uint64_t v42;
  uint64_t function_symbol;
  uint64_t v44;
  uint64_t v45;
  char *v46;
  uint64_t v47;
  unsigned int v48;
  char *v49;
  uint64_t v50;
  uint64_t v51;
  uint64_t v52;

  v52 = a7;
  v51 = a1;
  v50 = a2;
  v49 = (char *)a3;
  v48 = a4;
  v47 = a5;
  v46 = (char *)a6;
  v45 = 0;
  v44 = 0;
  function_symbol = 0;
  if (a7)
  {
    v44 = ~*(_QWORD *)(v52 + 8);
    v36 = *(_QWORD *)(*(_QWORD *)v44 + 16);
    if (v36 == 275)
    {
      v45 = *(_QWORD *)(v52 + 40);
      if (v45)
        function_symbol = _dispatch_continuation_get_function_symbol(v45);
    }
    else if (v36 == 787)
    {
      function_symbol = *(_QWORD *)(v52 + 40);
    }
    v50 = **(_QWORD **)v52;
  }
  if (v49 && v48)
  {
    v42 = _dispatch_bug_kevent_client_last_seen;
    _dispatch_bug_kevent_client_last_seen = v37;
    v41 = v37 == v42;
    if (v37 != v42)
    {
      v34 = v51;
      v33 = v49;
      v35 = &v22;
      v30 = function_symbol;
      v29 = v47;
      v28 = v47;
      v27 = v50;
      v26 = (uint64_t)v46;
      v25 = v48;
      v24 = strerror(v48);
      v23 = v49;
      _dispatch_log("BUG in libdispatch client: %s %s: \"%s\" - 0x%x { 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", v8, v9, v10, v11, v12, v13, v14, v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBCE48);
      }
    }
  }
  else if (v49)
  {
    v40 = _dispatch_bug_kevent_client_last_seen_66;
    _dispatch_bug_kevent_client_last_seen_66 = v37;
    if (v37 != v40)
    {
      v28 = function_symbol;
      v27 = v47;
      v26 = v47;
      v25 = v50;
      v24 = v46;
      v23 = v49;
      _dispatch_log("BUG in libdispatch client: %s %s{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", a2, a3, a4, a5, a6, a7, a8, v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBCF18);
      }
    }
  }
  else
  {
    v39 = _dispatch_bug_kevent_client_last_seen_68;
    _dispatch_bug_kevent_client_last_seen_68 = v37;
    v38 = v37 == v39;
    if (v37 != v39)
    {
      v31 = v51;
      v32 = &v22;
      v29 = function_symbol;
      v28 = v47;
      v27 = v47;
      v26 = v50;
      v25 = (uint64_t)v46;
      v24 = (char *)v48;
      v23 = strerror(v48);
      _dispatch_log("BUG in libdispatch: %s: \"%s\" - 0x%x{ 0x%llx[%s], ident: %lld / 0x%llx, handler: %p }", v15, v16, v17, v18, v19, v20, v21, v51);
      if ((_dispatch_mode & 1) != 0)
      {
        qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_client";
        __break(1u);
        JUMPOUT(0xBCFF8);
      }
    }
  }
}

void _dispatch_bug_kevent_vanished(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  if (*(_QWORD *)(*(_QWORD *)~*(_QWORD *)(a1 + 8) + 16) == 275 && *(_QWORD *)(a1 + 40))
    _dispatch_continuation_get_function_symbol(*(_QWORD *)(a1 + 40));
  v9 = _dispatch_bug_kevent_vanished_last_seen;
  _dispatch_bug_kevent_vanished_last_seen = v8;
  if (v8 != v9)
  {
    _dispatch_log("BUG in libdispatch client: %s, monitored resource vanished before the source cancel handler was invoked { %p[%s], ident: %d / 0x%x, handler: %p }", a2, a3, a4, a5, a6, a7, a8, **(_QWORD **)a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_kevent_vanished";
      __break(1u);
      JUMPOUT(0xBD1BCLL);
    }
  }
}

void _dispatch_bug_deprecated(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v8;
  uint64_t v9;

  v9 = _dispatch_bug_deprecated_last_seen;
  _dispatch_bug_deprecated_last_seen = v8;
  if (v8 != v9)
  {
    _dispatch_log("DEPRECATED USE in libdispatch client: %s; set a breakpoint on _dispatch_bug_deprecated to debug",
      a2,
      a3,
      a4,
      a5,
      a6,
      a7,
      a8,
      a1);
    if ((_dispatch_mode & 1) != 0)
    {
      qword_E4D78 = (uint64_t)"BUG IN CLIENT OF LIBDISPATCH: LIBDISPATCH_STRICT: _dispatch_bug_deprecated";
      __break(1u);
      JUMPOUT(0xBD268);
    }
  }
}

void _dispatch_abort(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8)
{
  _dispatch_bug(a1, a2, a3, a4, a5, a6, a7, a8);
  abort();
}

void dispatch_debugv(dispatch_object_t object, const char *message, va_list ap)
{
  _dispatch_debugv((uint64_t)object, message, ap);
}

void dispatch_debug(dispatch_object_t object, const char *message, ...)
{
  va_list va;

  va_start(va, message);
  _dispatch_debugv((uint64_t)object, message, va);
}

size_t _dispatch_object_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6;

  v6 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "xref = %d, ref = %d, ", *(_DWORD *)(a1 + 12), *(_DWORD *)(a1 + 8));
  if (v6 < 0)
    return 0;
  if (v6 <= a3)
    return v6;
  else
    return a3;
}

size_t _dispatch_semaphore_debug(uint64_t a1, char *a2, size_t a3)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  int v10;
  int v11;
  int v12;
  size_t v14;
  size_t v15;

  v12 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), (const void *)a1);
  if (v12 >= 0)
  {
    if (v12 <= a3)
      v8 = v12;
    else
      v8 = a3;
    v9 = v8;
  }
  else
  {
    v9 = 0;
  }
  v14 = v9 + _dispatch_object_debug_attr(a1, &a2[v9], a3 - v9);
  v11 = __snprintf_chk(&a2[v14], a3 - v14, 0, 0xFFFFFFFFFFFFFFFFLL, "port = 0x%x, ", *(_DWORD *)(a1 + 64));
  if (v11 >= 0)
  {
    if (v11 <= a3 - v14)
      v6 = v11;
    else
      v6 = a3 - v14;
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  v15 = v14 + v7;
  v10 = __snprintf_chk(&a2[v15], a3 - v15, 0, 0xFFFFFFFFFFFFFFFFLL, "value = %ld, orig = %ld }", *(_QWORD *)(a1 + 48), *(_QWORD *)(a1 + 56));
  if (v10 >= 0)
  {
    if (v10 <= a3 - v15)
      v4 = v10;
    else
      v4 = a3 - v15;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return v15 + v5;
}

size_t _dispatch_group_debug(_QWORD *a1, char *a2, size_t a3)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  int v8;
  int v9;
  size_t v11;
  uint64_t v12;

  v12 = a1[6];
  v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*a1 + 24), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3)
      v6 = v9;
    else
      v6 = a3;
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  v8 = __snprintf_chk(&a2[v11], a3 - v11, 0, 0xFFFFFFFFFFFFFFFFLL, "count = %u, gen = %d, waiters = %d, notifs = %d }", -(v12 & 0xFFFFFFFC) >> 2, HIDWORD(v12), (v12 & 1) != 0, (v12 & 2) != 0);
  if (v8 >= 0)
  {
    if (v8 <= a3 - v11)
      v4 = v8;
    else
      v4 = a3 - v11;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return v11 + v5;
}

size_t _dispatch_queue_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v3;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  char *v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  size_t v29;
  size_t v30;
  size_t v31;
  size_t v32;
  const char *v33;
  int v34;
  int v35;
  int v36;
  int v37;
  int v38;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  int v45;
  int v46;
  unint64_t v48;
  _QWORD *v49;
  size_t v50;
  size_t v51;
  int v55;
  unsigned __int16 v56;
  int v57;

  v49 = *(_QWORD **)(a1 + 24);
  if (v49 && v49[9])
    v33 = (const char *)v49[9];
  else
    v33 = "";
  v48 = *(_QWORD *)(a1 + 56);
  v46 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "sref = %d, target = %s[%p], width = 0x%x, state = 0x%016llx", *(_DWORD *)(a1 + 96) + 1, v33, v49, *(unsigned __int16 *)(a1 + 80), v48);
  if (v46 >= 0)
  {
    if (v46 <= a3)
      v31 = v46;
    else
      v31 = a3;
    v32 = v31;
  }
  else
  {
    v32 = 0;
  }
  v50 = v32;
  if ((v48 & 0xFF80000000000000) != 0)
  {
    v45 = __snprintf_chk(&a2[v32], a3 - v32, 0, 0xFFFFFFFFFFFFFFFFLL, ", suspended = %d", v48 / 0x400000000000000);
    if (v45 >= 0)
    {
      if (v45 <= a3 - v32)
        v29 = v45;
      else
        v29 = a3 - v32;
      v30 = v29;
    }
    else
    {
      v30 = 0;
    }
    v50 = v32 + v30;
  }
  switch(v48 & 0x180000000000000)
  {
    case 0x180000000000000uLL:
      v44 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", inactive");
      if (v44 >= 0)
      {
        if (v44 <= a3 - v50)
          v27 = v44;
        else
          v27 = a3 - v50;
        v28 = v27;
      }
      else
      {
        v28 = 0;
      }
      v50 += v28;
      break;
    case 0x100000000000000uLL:
      v43 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activated");
      if (v43 >= 0)
      {
        if (v43 <= a3 - v50)
          v25 = v43;
        else
          v25 = a3 - v50;
        v26 = v25;
      }
      else
      {
        v26 = 0;
      }
      v50 += v26;
      break;
    case 0x80000000000000uLL:
      v42 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", activating");
      if (v42 >= 0)
      {
        if (v42 <= a3 - v50)
          v23 = v42;
        else
          v23 = a3 - v50;
        v24 = v23;
      }
      else
      {
        v24 = 0;
      }
      v50 += v24;
      break;
  }
  if ((v48 & 0x4000000001) != 0)
  {
    v41 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", enqueued");
    if (v41 >= 0)
    {
      if (v41 <= a3 - v50)
        v21 = v41;
      else
        v21 = a3 - v50;
      v22 = v21;
    }
    else
    {
      v22 = 0;
    }
    v50 += v22;
  }
  if ((v48 & 0x8000000000) != 0)
  {
    v40 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", dirty");
    if (v40 >= 0)
    {
      if (v40 <= a3 - v50)
        v19 = v40;
      else
        v19 = a3 - v50;
      v20 = v19;
    }
    else
    {
      v20 = 0;
    }
    v50 += v20;
  }
  v39 = (v48 & 0x700000000) >> 32;
  if (v39)
  {
    v38 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", max qos %d", v39);
    if (v38 >= 0)
    {
      if (v38 <= a3 - v50)
        v17 = v38;
      else
        v17 = a3 - v50;
      v18 = v17;
    }
    else
    {
      v18 = 0;
    }
    v50 += v18;
  }
  if ((v48 & 0xFFFFFFFC) != 0)
    v57 = v48 | 3;
  else
    v57 = 0;
  if (v57 && ((*(_DWORD *)(a1 + 80) & 0x40000) == 0 || (*(_DWORD *)(a1 + 80) & 0x1000000) != 0))
  {
    v37 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", draining on 0x%x", v57);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v50)
        v15 = v37;
      else
        v15 = a3 - v50;
      v16 = v15;
    }
    else
    {
      v16 = 0;
    }
    v50 += v16;
  }
  if ((v48 & 0x40000000000000) != 0)
  {
    v36 = __snprintf_chk(&a2[v50], a3 - v50, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-barrier");
    if (v36 >= 0)
    {
      if (v36 <= a3 - v50)
        v13 = v36;
      else
        v13 = a3 - v50;
      v14 = v13;
    }
    else
    {
      v14 = 0;
    }
    v51 = v50 + v14;
  }
  else
  {
    v11 = &a2[v50];
    v12 = a3 - v50;
    v56 = *(_WORD *)(a1 + 80);
    v55 = (v48 & 0x3FFE0000000000) >> 41;
    if ((v48 & 0x10000000000) != 0)
      v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56) - (v56 - 1));
    else
      v3 = __snprintf_chk(v11, v12, 0, 0xFFFFFFFFFFFFFFFFLL, ", in-flight = %d", v55 - (4096 - v56));
    if (v3 >= 0)
    {
      if (v3 <= a3 - v50)
        v9 = v3;
      else
        v9 = a3 - v50;
      v10 = v9;
    }
    else
    {
      v10 = 0;
    }
    v51 = v50 + v10;
  }
  if ((v48 & 0x10000000000) != 0)
  {
    v35 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", pending-barrier");
    if (v35 >= 0)
    {
      if (v35 <= a3 - v51)
        v7 = v35;
      else
        v7 = a3 - v51;
      v8 = v7;
    }
    else
    {
      v8 = 0;
    }
    v51 += v8;
  }
  if ((*(_DWORD *)(a1 + 80) & 0x40000) != 0 && (*(_DWORD *)(a1 + 80) & 0x1000000) == 0)
  {
    v34 = __snprintf_chk(&a2[v51], a3 - v51, 0, 0xFFFFFFFFFFFFFFFFLL, ", thread = 0x%x ", v57);
    if (v34 >= 0)
    {
      if (v34 <= a3 - v51)
        v5 = v34;
      else
        v5 = a3 - v51;
      v6 = v5;
    }
    else
    {
      v6 = 0;
    }
    v51 += v6;
  }
  return v51;
}

size_t _dispatch_queue_debug(const char **a1, char *a2, size_t a3)
{
  int v3;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  int v9;
  size_t v11;
  size_t v12;

  if (a1[9])
    v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", a1[9], a1);
  else
    v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *((const char **)*a1 + 3), a1);
  if (v3 >= 0)
  {
    if (v3 <= a3)
      v7 = v3;
    else
      v7 = a3;
    v8 = v7;
  }
  else
  {
    v8 = 0;
  }
  v11 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  v12 = v11 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  v9 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v12)
      v5 = v9;
    else
      v5 = a3 - v12;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  return v12 + v6;
}

size_t _dispatch_channel_debug(_DWORD *a1, char *a2, size_t a3)
{
  const char *v3;
  const char *v4;
  const char *v5;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  int v11;
  int v12;
  size_t v14;
  size_t v15;
  int v16;

  v16 = a1[20];
  v12 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), a1);
  if (v12 >= 0)
  {
    if (v12 <= a3)
      v9 = v12;
    else
      v9 = a3;
    v10 = v9;
  }
  else
  {
    v10 = 0;
  }
  v14 = v10 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v10], a3 - v10);
  v15 = v14 + _dispatch_queue_debug_attr((uint64_t)a1, &a2[v14], a3 - v14);
  if ((v16 & 0x10000000) != 0)
    v3 = "cancelled, ";
  else
    v3 = "";
  if ((v16 & 0x40000000) != 0)
    v4 = "needs-event, ";
  else
    v4 = "";
  v5 = "deleted, ";
  if (v16 >= 0)
    v5 = "";
  v11 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s%s%s", v3, v4, v5);
  if (v11 >= 0)
  {
    if (v11 <= a3)
      v7 = v11;
    else
      v7 = a3;
    v8 = v7;
  }
  else
  {
    v8 = 0;
  }
  return v15 + v8;
}

size_t _dispatch_source_debug(_QWORD *a1, char *a2, size_t a3)
{
  const char *v3;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  int v9;
  int v10;
  size_t v12;
  size_t v13;
  const char ***v14;

  v14 = (const char ***)a1[11];
  v10 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*a1 + 24), a1);
  if (v10 >= 0)
  {
    if (v10 <= a3)
      v7 = v10;
    else
      v7 = a3;
    v8 = v7;
  }
  else
  {
    v8 = 0;
  }
  v12 = v8 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v8], a3 - v8);
  v13 = v12 + _dispatch_source_debug_attr((uint64_t)a1, &a2[v12], a3 - v12);
  if ((*((_BYTE *)v14 + 29) & 2) != 0)
    v13 += _dispatch_timer_debug_attr((uint64_t)a1, &a2[v13], a3 - v13);
  if ((*((_BYTE *)v14 + 29) & 1) != 0)
    v3 = " (direct)";
  else
    v3 = "";
  v9 = __snprintf_chk(&a2[v13], a3 - v13, 0, 0xFFFFFFFFFFFFFFFFLL, "kevent = %p%s, filter = %s }", v14, v3, **v14);
  if (v9 >= 0)
  {
    if (v9 <= a3 - v13)
      v5 = v9;
    else
      v5 = a3 - v13;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  return v13 + v6;
}

unint64_t _dispatch_source_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v3;
  int v4;
  uint64_t v5;
  const char *v6;
  const char *v7;
  const char *v8;
  uint64_t v10;
  uint64_t *v13;
  const char *v14;
  char *v15;
  size_t v16;
  int v17;
  unint64_t v18;
  uint64_t v19;
  uint64_t v20;
  uint64_t v21;
  int v22;
  uint64_t v23;
  _QWORD *v24;
  size_t v25;
  char *v26;
  uint64_t v27;
  int v28;
  int v29;
  int v30;
  uint64_t v31;
  uint64_t v32;
  uint64_t v33;
  uint64_t v34;
  uint64_t v35;
  uint64_t v36;
  uint64_t v37;

  v27 = a1;
  v26 = a2;
  v25 = a3;
  v24 = 0;
  v24 = *(_QWORD **)(a1 + 24);
  v23 = 0;
  v23 = *(_QWORD *)(a1 + 88);
  v22 = 0;
  v21 = a1;
  v31 = a1;
  v30 = 0;
  v29 = *(_DWORD *)(a1 + 80);
  v30 = v29;
  v28 = v29;
  v22 = v29;
  v20 = 0;
  v19 = v23;
  v35 = v23;
  v34 = 0;
  v33 = *(_QWORD *)(v23 + 16);
  v34 = v33;
  v32 = v33;
  v20 = v33;
  v18 = a3;
  v17 = 0;
  v15 = a2;
  v16 = a3;
  if (v24 && v24[9])
    v14 = (const char *)v24[9];
  else
    v14 = "";
  v3 = *(_DWORD *)(v23 + 24);
  v4 = *(_DWORD *)(v23 + 32);
  v5 = *(_QWORD *)(v23 + 72);
  v37 = v20;
  v36 = v20;
  if ((v22 & 0x10000000) != 0)
    v6 = "cancelled, ";
  else
    v6 = "";
  if ((v22 & 0x40000000) != 0)
    v7 = "needs-event, ";
  else
    v7 = "";
  v8 = "deleted, ";
  if (v22 >= 0)
    v8 = "";
  v13 = &v10;
  v17 = __snprintf_chk(v15, v16, 0, 0xFFFFFFFFFFFFFFFFLL, "target = %s[%p], ident = 0x%x, mask = 0x%x, pending_data = 0x%llx, registered = %d, armed = %d, %s%s%s", v14, v24, v3, v4, v5, v20 != 0, (v20 & 1) != 0, v6, v7, v8);
  if (v17 < 0)
    return 0;
  if (v17 <= v18)
    return v17;
  else
    return v18;
}

size_t _dispatch_timer_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  int v6;

  v6 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "timer = { target = 0x%llx, deadline = 0x%llx, interval = 0x%llx, flags = 0x%x }, ", *(_QWORD *)(*(_QWORD *)(a1 + 88) + 80), *(_QWORD *)(*(_QWORD *)(a1 + 88) + 88), *(_QWORD *)(*(_QWORD *)(a1 + 88) + 96), *(unsigned __int8 *)(*(_QWORD *)(a1 + 88) + 30));
  if (v6 < 0)
    return 0;
  if (v6 <= a3)
    return v6;
  else
    return a3;
}

uint64_t _dispatch_mach_msg_debug(_DWORD *a1, char *a2, size_t a3)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  int v28;
  int v29;
  int v30;
  int v31;
  int v32;
  int v33;
  int v34;
  int v35;
  int v36;
  int v37;
  _DWORD *msg;
  int v39;
  int v40;
  size_t v42;
  size_t v43;
  size_t v44;
  size_t v45;

  v40 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), a1);
  if (v40 >= 0)
  {
    if (v40 <= a3)
      v26 = v40;
    else
      v26 = a3;
    v27 = v26;
  }
  else
  {
    v27 = 0;
  }
  v42 = v27 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v27], a3 - v27);
  v39 = __snprintf_chk(&a2[v42], a3 - v42, 0, 0xFFFFFFFFFFFFFFFFLL, "opts/err = 0x%x, msgh[%p] = { ", a1[12], a1 + 22);
  if (v39 >= 0)
  {
    if (v39 <= a3 - v42)
      v24 = v39;
    else
      v24 = a3 - v42;
    v25 = v24;
  }
  else
  {
    v25 = 0;
  }
  v43 = v42 + v25;
  msg = (_DWORD *)_dispatch_mach_msg_get_msg((uint64_t)a1);
  if (msg[5])
  {
    v37 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "id 0x%x, ", msg[5]);
    if (v37 >= 0)
    {
      if (v37 <= a3 - v43)
        v22 = v37;
      else
        v22 = a3 - v43;
      v23 = v22;
    }
    else
    {
      v23 = 0;
    }
    v43 += v23;
  }
  if (msg[1])
  {
    v36 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "size %u, ", msg[1]);
    if (v36 >= 0)
    {
      if (v36 <= a3 - v43)
        v20 = v36;
      else
        v20 = a3 - v43;
      v21 = v20;
    }
    else
    {
      v21 = 0;
    }
    v43 += v21;
  }
  if (*msg)
  {
    v35 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "bits <l %u, r %u", (*msg & 0x1F00u) >> 8, *msg & 0x1F);
    if (v35 >= 0)
    {
      if (v35 <= a3 - v43)
        v18 = v35;
      else
        v18 = a3 - v43;
      v19 = v18;
    }
    else
    {
      v19 = 0;
    }
    v44 = v43 + v19;
    if ((*msg & 0xFFE0E0E0) != 0)
    {
      v34 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, ", o 0x%x", *msg & 0xFFE0E0E0);
      if (v34 >= 0)
      {
        if (v34 <= a3 - v44)
          v16 = v34;
        else
          v16 = a3 - v44;
        v17 = v16;
      }
      else
      {
        v17 = 0;
      }
      v44 += v17;
    }
    v33 = __snprintf_chk(&a2[v44], a3 - v44, 0, 0xFFFFFFFFFFFFFFFFLL, ">, ");
    if (v33 >= 0)
    {
      if (v33 <= a3 - v44)
        v14 = v33;
      else
        v14 = a3 - v44;
      v15 = v14;
    }
    else
    {
      v15 = 0;
    }
    v43 = v44 + v15;
  }
  if (msg[3] && msg[2])
  {
    v32 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x, remote 0x%x", msg[3], msg[2]);
    if (v32 >= 0)
    {
      if (v32 <= a3 - v43)
        v12 = v32;
      else
        v12 = a3 - v43;
      v13 = v12;
    }
    else
    {
      v13 = 0;
    }
    v45 = v43 + v13;
  }
  else if (msg[3])
  {
    v31 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "local 0x%x", msg[3]);
    if (v31 >= 0)
    {
      if (v31 <= a3 - v43)
        v10 = v31;
      else
        v10 = a3 - v43;
      v11 = v10;
    }
    else
    {
      v11 = 0;
    }
    v45 = v43 + v11;
  }
  else if (msg[2])
  {
    v30 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "remote 0x%x", msg[2]);
    if (v30 >= 0)
    {
      if (v30 <= a3 - v43)
        v8 = v30;
      else
        v8 = a3 - v43;
      v9 = v8;
    }
    else
    {
      v9 = 0;
    }
    v45 = v43 + v9;
  }
  else
  {
    v29 = __snprintf_chk(&a2[v43], a3 - v43, 0, 0xFFFFFFFFFFFFFFFFLL, "no ports");
    if (v29 >= 0)
    {
      if (v29 <= a3 - v43)
        v6 = v29;
      else
        v6 = a3 - v43;
      v7 = v6;
    }
    else
    {
      v7 = 0;
    }
    v45 = v43 + v7;
  }
  v28 = __snprintf_chk(&a2[v45], a3 - v45, 0, 0xFFFFFFFFFFFFFFFFLL, " } }");
  if (v28 >= 0)
  {
    if (v28 <= a3 - v45)
      v4 = v28;
    else
      v4 = a3 - v45;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return v45 + v5;
}

size_t _dispatch_mach_debug(uint64_t a1, char *a2, size_t a3)
{
  int v3;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  int v9;
  size_t v11;
  size_t v12;

  if (!*(_QWORD *)(a1 + 72) || ((*(_WORD *)(a1 + 116) >> 3) & 1) != 0)
    v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), (const void *)a1);
  else
    v3 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(a1 + 72), (const void *)a1);
  if (v3 >= 0)
  {
    if (v3 <= a3)
      v7 = v3;
    else
      v7 = a3;
    v8 = v7;
  }
  else
  {
    v8 = 0;
  }
  v11 = v8 + _dispatch_object_debug_attr(a1, &a2[v8], a3 - v8);
  v12 = v11 + _dispatch_mach_debug_attr((_QWORD *)a1, &a2[v11], a3 - v11);
  v9 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v9 >= 0)
  {
    if (v9 <= a3 - v12)
      v5 = v9;
    else
      v5 = a3 - v12;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  return v12 + v6;
}

unint64_t _dispatch_mach_debug_attr(_QWORD *a1, char *a2, size_t a3)
{
  int v3;
  int v4;
  int v5;
  const char *v6;
  int v7;
  const char *v8;
  uint64_t v9;
  int v10;
  BOOL v11;
  uint64_t v13;
  uint64_t *v16;
  const char *v17;
  char *v18;
  size_t v19;
  char v20;
  char v21;
  char v22;
  int v23;
  unint64_t v24;
  uint64_t v25;
  uint64_t v26;
  _QWORD *v27;
  size_t v28;
  char *v29;
  _QWORD *v30;

  v30 = a1;
  v29 = a2;
  v28 = a3;
  v27 = 0;
  v27 = (_QWORD *)a1[3];
  v26 = 0;
  v26 = a1[15];
  v25 = 0;
  v25 = a1[11];
  v24 = a3;
  v23 = 0;
  v18 = a2;
  v19 = a3;
  if (v27 && v27[9])
    v17 = (const char *)v27[9];
  else
    v17 = "";
  v3 = *(_DWORD *)(v25 + 24);
  v4 = *(_DWORD *)(v26 + 92);
  v5 = *(_DWORD *)(v26 + 24);
  v22 = 0;
  v21 = *(_BYTE *)(v26 + 30);
  v22 = v21 & 1;
  v20 = v21 & 1;
  if ((v21 & 1) != 0)
    v6 = " (armed)";
  else
    v6 = "";
  v7 = *(_DWORD *)(v26 + 96);
  if (*(_QWORD *)(v26 + 48))
    v8 = " (pending)";
  else
    v8 = "";
  v9 = *(_QWORD *)(v26 + 64);
  v10 = *(_DWORD *)(v26 + 88);
  v11 = (v30[10] & 0x10000000) != 0;
  v16 = &v13;
  v23 = __snprintf_chk(v18, v19, 0, 0xFFFFFFFFFFFFFFFFLL, "target = %s[%p], receive = 0x%x, send = 0x%x, send-possible = 0x%x%s, checkin = 0x%x%s, send state = %016llx, disconnected = %d, canceled = %d ", v17, v27, v3, v4, v5, v6, v7, v8, v9, v10, v11);
  if (v23 < 0)
    return 0;
  if (v23 <= v24)
    return v23;
  else
    return v24;
}

unint64_t voucher_kvoucher_debug(ipc_space_read_t a1, mach_port_name_t a2, uint64_t a3, unint64_t a4, unint64_t a5, const char *a6, unint64_t a7)
{
  char *v7;
  size_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  size_t v14;
  size_t v15;
  size_t v16;
  size_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  size_t v22;
  size_t v23;
  size_t v24;
  size_t v25;
  size_t v26;
  size_t v27;
  size_t v28;
  unsigned int v29;
  char *v30;
  size_t v31;
  size_t v32;
  size_t v33;
  size_t v34;
  int v35;
  int v36;
  uint8_t *v37;
  unsigned int i;
  int v39;
  int v40;
  int v41;
  int v42;
  int v43;
  int v44;
  kern_return_t error_value;
  unsigned int object_type;
  unsigned int object_addr;
  mach_msg_type_number_t recipesCnt[2];
  unint64_t v49;
  const char *v50;
  unint64_t v51;
  unint64_t v52;
  uint64_t v53;
  mach_port_name_t name;
  ipc_space_read_t task;
  uint8_t recipes[8192];

  task = a1;
  name = a2;
  v53 = a3;
  v52 = a4;
  v51 = a5;
  v50 = a6;
  v49 = a7;
  bzero(recipes, 0x2000uLL);
  *(_QWORD *)recipesCnt = 0x2000;
  object_addr = 0;
  object_type = 0;
  if (mach_port_kernel_object(task, name, &object_type, &object_addr) || object_type != 37)
  {
    if (v50)
    {
      if (v52 <= v51)
        v14 = 0;
      else
        v14 = v52 - v51;
      v36 = __snprintf_chk((char *)(v53 + v51), v14, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
      if (v36 >= 0)
      {
        if (v36 <= v14)
          v12 = v36;
        else
          v12 = v14;
        v13 = v12;
      }
      else
      {
        v13 = 0;
      }
      v51 += v13;
    }
    if (v52 <= v51)
      v11 = 0;
    else
      v11 = v52 - v51;
    v35 = __snprintf_chk((char *)(v53 + v51), v11, 0, 0xFFFFFFFFFFFFFFFFLL, "Invalid voucher: 0x%x\n", name);
    if (v35 >= 0)
    {
      if (v35 <= v11)
        v9 = v35;
      else
        v9 = v11;
      v10 = v9;
    }
    else
    {
      v10 = 0;
    }
    v51 += v10;
  }
  else
  {
    error_value = mach_voucher_debug_info(task, name, recipes, recipesCnt);
    if (!error_value || error_value == 46)
    {
      if (*(_QWORD *)recipesCnt)
      {
        if (v50)
        {
          if (v52 <= v51)
            v20 = 0;
          else
            v20 = v52 - v51;
          v40 = __snprintf_chk((char *)(v53 + v51), v20, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v40 >= 0)
          {
            if (v40 <= v20)
              v18 = v40;
            else
              v18 = v20;
            v19 = v18;
          }
          else
          {
            v19 = 0;
          }
          v51 += v19;
        }
        if (v52 <= v51)
          v17 = 0;
        else
          v17 = v52 - v51;
        v39 = __snprintf_chk((char *)(v53 + v51), v17, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x\n", object_addr);
        if (v39 >= 0)
        {
          if (v39 <= v17)
            v15 = v39;
          else
            v15 = v17;
          v16 = v15;
        }
        else
        {
          v16 = 0;
        }
        v51 += v16;
        for (i = 0; *(_QWORD *)recipesCnt > (unint64_t)i; i += *((_DWORD *)v37 + 3) + 16)
        {
          v37 = &recipes[i];
          if (*(_DWORD *)v37)
            v51 = format_recipe_detail((uint64_t)v37, v53, v52, v51, v50, v49);
        }
      }
      else
      {
        if (v50)
        {
          if (v52 <= v51)
            v26 = 0;
          else
            v26 = v52 - v51;
          v42 = __snprintf_chk((char *)(v53 + v51), v26, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
          if (v42 >= 0)
          {
            if (v42 <= v26)
              v24 = v42;
            else
              v24 = v26;
            v25 = v24;
          }
          else
          {
            v25 = 0;
          }
          v51 += v25;
        }
        if (v52 <= v51)
          v23 = 0;
        else
          v23 = v52 - v51;
        v41 = __snprintf_chk((char *)(v53 + v51), v23, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x has no contents\n", object_addr);
        if (v41 >= 0)
        {
          if (v41 <= v23)
            v21 = v41;
          else
            v21 = v23;
          v22 = v21;
        }
        else
        {
          v22 = 0;
        }
        v51 += v22;
      }
    }
    else
    {
      if (v50)
      {
        if (v52 <= v51)
          v34 = 0;
        else
          v34 = v52 - v51;
        v44 = __snprintf_chk((char *)(v53 + v51), v34, 0, 0xFFFFFFFFFFFFFFFFLL, "%s", v50);
        if (v44 >= 0)
        {
          if (v44 <= v34)
            v32 = v44;
          else
            v32 = v34;
          v33 = v32;
        }
        else
        {
          v33 = 0;
        }
        v51 += v33;
      }
      if (v52 <= v51)
        v31 = 0;
      else
        v31 = v52 - v51;
      v30 = (char *)(v53 + v51);
      v29 = object_addr;
      v7 = mach_error_string(error_value);
      v43 = __snprintf_chk(v30, v31, 0, 0xFFFFFFFFFFFFFFFFLL, "Voucher: 0x%x Failed to get contents %s\n", v29, v7);
      if (v43 >= 0)
      {
        if (v43 <= v31)
          v27 = v43;
        else
          v27 = v31;
        v28 = v27;
      }
      else
      {
        v28 = 0;
      }
      v51 += v28;
    }
  }
  return v51;
}

size_t _dispatch_io_debug(const void *a1, char *a2, size_t a3)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  int v8;
  int v9;
  size_t v11;
  size_t v12;

  v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3)
      v6 = v9;
    else
      v6 = a3;
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  v12 = v11 + _dispatch_io_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  v8 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v8 >= 0)
  {
    if (v8 <= a3 - v12)
      v4 = v8;
    else
      v4 = a3 - v12;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return v12 + v5;
}

unint64_t _dispatch_io_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  const char *v3;
  const char *v4;
  const void *v5;
  const void *v6;
  int v7;
  uint64_t v8;
  uint64_t v9;
  const char *v10;
  uint64_t v11;
  uint64_t v13;
  uint64_t *v16;
  const char *v17;
  const char *v18;
  const void *v19;
  const void *v20;
  const char *v21;
  char *v22;
  size_t v23;
  const char *v24;
  uint64_t v25;
  int v26;
  unint64_t v27;
  _QWORD *v28;
  size_t v29;
  char *v30;
  uint64_t v31;

  v31 = a1;
  v30 = a2;
  v29 = a3;
  v28 = 0;
  v28 = *(_QWORD **)(a1 + 24);
  v27 = a3;
  v26 = 0;
  v22 = a2;
  v23 = a3;
  v3 = "stream";
  if (*(_QWORD *)(a1 + 72))
    v3 = "random";
  v24 = v3;
  v25 = *(int *)(v31 + 128);
  if ((*(_DWORD *)(v31 + 120) & 2) != 0)
  {
    v21 = "stopped, ";
  }
  else
  {
    v4 = "closed, ";
    if ((*(_DWORD *)(v31 + 120) & 1) == 0)
      v4 = "";
    v21 = v4;
  }
  v18 = v21;
  v19 = *(const void **)(v31 + 112);
  v20 = *(const void **)(v31 + 48);
  if (v28 && v28[9])
    v17 = (const char *)v28[9];
  else
    v17 = "";
  v5 = *(const void **)(v31 + 56);
  v6 = *(const void **)(v31 + 64);
  v7 = *(_DWORD *)(v31 + 144);
  v8 = *(_QWORD *)(v31 + 80);
  v9 = *(_QWORD *)(v31 + 88);
  if ((*(_QWORD *)(v31 + 104) & 1) != 0)
    v10 = "(strict)";
  else
    v10 = "";
  v11 = *(_QWORD *)(v31 + 96);
  v16 = &v13;
  v26 = __snprintf_chk(v22, v23, 0, 0xFFFFFFFFFFFFFFFFLL, "type = %s, fd = 0x%lx, %sfd_entry = %p, queue = %p, target = %s[%p], barrier_queue = %p, barrier_group = %p, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ", v24, v25, v18, v19, v20, v17, v28, v5, v6, v7, v8, v9, v10,
          v11);
  if (v26 < 0)
    return 0;
  if (v26 <= v27)
    return v26;
  else
    return v27;
}

size_t _dispatch_operation_debug(const void *a1, char *a2, size_t a3)
{
  size_t v4;
  size_t v5;
  size_t v6;
  size_t v7;
  int v8;
  int v9;
  size_t v11;
  size_t v12;

  v9 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "%s[%p] = { ", *(const char **)(*(_QWORD *)a1 + 24), a1);
  if (v9 >= 0)
  {
    if (v9 <= a3)
      v6 = v9;
    else
      v6 = a3;
    v7 = v6;
  }
  else
  {
    v7 = 0;
  }
  v11 = v7 + _dispatch_object_debug_attr((uint64_t)a1, &a2[v7], a3 - v7);
  v12 = v11 + _dispatch_operation_debug_attr((uint64_t)a1, &a2[v11], a3 - v11);
  v8 = __snprintf_chk(&a2[v12], a3 - v12, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v8 >= 0)
  {
    if (v8 <= a3 - v12)
      v4 = v8;
    else
      v4 = a3 - v12;
    v5 = v4;
  }
  else
  {
    v5 = 0;
  }
  return v12 + v5;
}

unint64_t _dispatch_operation_debug_attr(uint64_t a1, char *a2, size_t a3)
{
  const char *v3;
  const char *v4;
  uint64_t v5;
  uint64_t v6;
  uint64_t v7;
  uint64_t v8;
  int v9;
  int v10;
  uint64_t v11;
  uint64_t v12;
  const char *v13;
  uint64_t v14;
  uint64_t v16;
  uint64_t *v19;
  const char *v20;
  const char *v21;
  const void *v22;
  const char *v23;
  uint64_t v24;
  const void *v25;
  const void *v26;
  const void *v27;
  int v28;
  char *v29;
  size_t v30;
  const char *v31;
  const char *v32;
  _QWORD *v33;
  int v34;
  unint64_t v35;
  _QWORD *v36;
  _QWORD *v37;
  size_t v38;
  char *v39;
  uint64_t v40;

  v40 = a1;
  v39 = a2;
  v38 = a3;
  v37 = 0;
  v37 = *(_QWORD **)(a1 + 24);
  v36 = 0;
  if (*(_QWORD *)(a1 + 48))
    v33 = *(_QWORD **)(*(_QWORD *)(v40 + 48) + 24);
  else
    v33 = 0;
  v36 = v33;
  v35 = v38;
  v34 = 0;
  v29 = v39;
  v30 = v38;
  v3 = "stream";
  if (*(_QWORD *)(v40 + 64))
    v3 = "random";
  v31 = v3;
  v4 = "read";
  if (*(_DWORD *)(v40 + 56))
    v4 = "write";
  v32 = v4;
  if (*(_QWORD *)(v40 + 144))
    v28 = **(_DWORD **)(v40 + 144);
  else
    v28 = -1;
  v24 = v28;
  v25 = *(const void **)(v40 + 144);
  v26 = *(const void **)(v40 + 136);
  v27 = *(const void **)(v40 + 48);
  if (v36 && v36[9])
    v23 = (const char *)v36[9];
  else
    v23 = "";
  v21 = v23;
  v22 = v36;
  if (v37 && v37[9])
    v20 = (const char *)v37[9];
  else
    v20 = "";
  v5 = *(_QWORD *)(v40 + 104);
  v6 = *(_QWORD *)(v40 + 112);
  v7 = *(_QWORD *)(v40 + 216);
  v8 = *(_QWORD *)(v40 + 208) + *(_QWORD *)(v40 + 200);
  v9 = *(_DWORD *)(v40 + 184);
  v10 = *(_DWORD *)(v40 + 120);
  v11 = *(_QWORD *)(v40 + 72);
  v12 = *(_QWORD *)(v40 + 80);
  if ((*(_QWORD *)(v40 + 96) & 1) != 0)
    v13 = "(strict)";
  else
    v13 = "";
  v14 = *(_QWORD *)(v40 + 88);
  v19 = &v16;
  v34 = __snprintf_chk(v29, v30, 0, 0xFFFFFFFFFFFFFFFFLL, "type = %s %s, fd = 0x%lx, fd_entry = %p, channel = %p, queue = %p -> %s[%p], target = %s[%p], offset = %lld, length = %zu, done = %zu, undelivered = %zu, flags = %u, err = 0x%x, low = 0x%zx, high = 0x%zx, interval%s = %llu ", v31, v32, v24, v25, v26, v27, v21, v22, v20, v37, v5, v6, v7,
          v8,
          v9,
          v10,
          v11,
          v12,
          v13,
          v14);
  if (v34 < 0)
    return 0;
  if (v34 <= v35)
    return v34;
  else
    return v35;
}

size_t _dispatch_data_debug(uint64_t a1, char *a2, size_t a3)
{
  int v3;
  size_t v5;
  size_t v6;
  size_t v7;
  size_t v8;
  unint64_t v9;
  size_t v10;
  size_t v11;
  size_t v12;
  size_t v13;
  char *v14;
  size_t v15;
  uint64_t v16;
  uint64_t v17;
  size_t v18;
  size_t v19;
  size_t v20;
  size_t v21;
  int v22;
  int v23;
  unint64_t i;
  int v25;
  int v26;
  int v27;
  size_t v29;

  v27 = __snprintf_chk(a2, a3, 0, 0xFFFFFFFFFFFFFFFFLL, "data[%p] = { ", (const void *)a1);
  if (v27 >= 0)
  {
    if (v27 <= a3)
      v20 = v27;
    else
      v20 = a3;
    v21 = v20;
  }
  else
  {
    v21 = 0;
  }
  if (*(_QWORD *)(a1 + 72))
  {
    v14 = &a2[v21];
    v15 = a3 - v21;
    v16 = *(_QWORD *)(a1 + 64);
    v17 = *(_QWORD *)(a1 + 72);
    if (v17)
      v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, v17);
    else
      v3 = __snprintf_chk(v14, v15, 0, 0xFFFFFFFFFFFFFFFFLL, "composite, size = %zd, num_records = %zd ", v16, 1uLL);
    if (v3 >= 0)
    {
      if (v3 <= a3 - v21)
        v12 = v3;
      else
        v12 = a3 - v21;
      v13 = v12;
    }
    else
    {
      v13 = 0;
    }
    v29 = v21 + v13;
    if (*(_QWORD *)(a1 + 48))
    {
      v25 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, ", flatbuf = %p ", *(const void **)(a1 + 48));
      if (v25 >= 0)
      {
        if (v25 <= a3 - v29)
          v10 = v25;
        else
          v10 = a3 - v29;
        v11 = v10;
      }
      else
      {
        v11 = 0;
      }
      v29 += v11;
    }
    for (i = 0; ; ++i)
    {
      v9 = *(_QWORD *)(a1 + 72) ? *(_QWORD *)(a1 + 72) : 1;
      if (i >= v9)
        break;
      v23 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, "record[%zd] = { from = %zd, length = %zd, data_object = %p }, ", i, *(_QWORD *)(a1 + 80 + 24 * i + 8), *(_QWORD *)(a1 + 80 + 24 * i + 16), *(const void **)(a1 + 80 + 24 * i));
      if (v23 >= 0)
      {
        if (v23 <= a3 - v29)
          v7 = v23;
        else
          v7 = a3 - v29;
        v8 = v7;
      }
      else
      {
        v8 = 0;
      }
      v29 += v8;
    }
  }
  else
  {
    v26 = __snprintf_chk(&a2[v21], a3 - v21, 0, 0xFFFFFFFFFFFFFFFFLL, "leaf, size = %zd, buf = %p ", *(_QWORD *)(a1 + 64), *(const void **)(a1 + 48));
    if (v26 >= 0)
    {
      if (v26 <= a3 - v21)
        v18 = v26;
      else
        v18 = a3 - v21;
      v19 = v18;
    }
    else
    {
      v19 = 0;
    }
    v29 = v21 + v19;
  }
  v22 = __snprintf_chk(&a2[v29], a3 - v29, 0, 0xFFFFFFFFFFFFFFFFLL, "}");
  if (v22 >= 0)
  {
    if (v22 <= a3 - v29)
      v5 = v22;
    else
      v5 = a3 - v29;
    v6 = v5;
  }
  else
  {
    v6 = 0;
  }
  return v29 + v6;
}
